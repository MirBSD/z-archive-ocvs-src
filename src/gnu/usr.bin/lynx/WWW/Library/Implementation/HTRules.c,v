head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.48;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.38;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.27;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.02;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.00;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.40;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.50;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.14;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.47.04;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/*	Configuration manager for Hypertext Daemon		HTRules.c
 *	==========================================
 *
 *
 * History:
 *	 3 Jun 91	Written TBL
 *	10 Aug 91	Authorisation added after Daniel Martin (pass, fail)
 *			Rule order in file changed
 *			Comments allowed with # on 1st char of rule line
 *	17 Jun 92	Bug fix: pass and fail failed if didn't contain '*' TBL
 *	 1 Sep 93	Bug fix: no memory check - Nathan Torkington
 *			BYTE_ADDRESSING removed - Arthur Secret
 *	11 Sep 93  MD	Changed %i into %d in debug printf.
 *			VMS does not recognize %i.
 *			Bug Fix: in case of PASS, only one parameter to printf.
 *	19 Sep 93  AL	Added Access Authorization stuff.
 *	 1 Nov 93  AL	Added htbin.
 *	25 May 99  KW	Added redirect for lynx.
 *
 */

#include <HTUtils.h>

/* (c) CERN WorldWideWeb project 1990,91. See Copyright.html for details */
#include <HTRules.h>

#include <HTFile.h>
#include <LYLeaks.h>
#include <HTAAProt.h>

#define LINE_LENGTH 256

typedef struct _rule {
    struct _rule *next;
    HTRuleOp op;
    char *pattern;
    char *equiv;
    char *condition_op;		/* as strings - may be inefficient, */
    char *condition;		/* but this is not for a server - kw */
} rule;

#ifndef NO_RULES

#include <HTTP.h>		/* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h>	/* for LYUserSpecifiedURL - kw */
#include <LYUtils.h>		/* for LYFixCursesOn - kw */
#include <HTAlert.h>

/*	Global variables
 *	----------------
 */
char *HTBinDir = NULL;		/* Physical /htbin directory path.      */

				/* In future this should not be global. */
char *HTSearchScript = NULL;	/* Search script name.          */

/*	Module-wide variables
 *	---------------------
 */

static rule *rules = 0;		/* Pointer to first on list */

#ifndef PUT_ON_HEAD
static rule *rule_tail = 0;	/* Pointer to last on list */
#endif

/*	Add rule to the list					HTAddRule()
 *	--------------------
 *
 *  On entry,
 *	pattern		points to 0-terminated string containing a single "*"
 *	equiv		points to the equivalent string with * for the
 *			place where the text matched by * goes.
 *  On exit,
 *	returns		0 if success, -1 if error.
 */

int HTAddRule(HTRuleOp op, const char *pattern,
	      const char *equiv,
	      const char *cond_op,
	      const char *cond)
{				/* BYTE_ADDRESSING removed and memory check - AS - 1 Sep 93 */
    rule *temp;
    char *pPattern = NULL;

    temp = typecalloc(rule);
    if (temp == NULL)
	outofmem(__FILE__, "HTAddRule");
    if (equiv) {		/* Two operands */
	char *pEquiv = NULL;

	StrAllocCopy(pEquiv, equiv);
	temp->equiv = pEquiv;
    } else {
	temp->equiv = 0;
    }
    if (cond_op) {
	StrAllocCopy(temp->condition_op, cond_op);
	StrAllocCopy(temp->condition, cond);
    }
    StrAllocCopy(pPattern, pattern);
    temp->pattern = pPattern;
    temp->op = op;

    if (equiv) {
	CTRACE((tfp, "Rule: For `%s' op %d `%s'", pattern, op, equiv));
    } else {
	CTRACE((tfp, "Rule: For `%s' op %d", pattern, op));
    }
    if (cond_op) {
	CTRACE((tfp, "\t%s %s\n", cond_op, NONNULL(cond)));
    } else {
	CTRACE((tfp, "\n"));
    }

    if (!rules) {
#ifdef LY_FIND_LEAKS
	atexit(HTClearRules);
#endif
    }
#ifdef PUT_ON_HEAD
    temp->next = rules;
    rules = temp;
#else
    temp->next = 0;
    if (rule_tail)
	rule_tail->next = temp;
    else
	rules = temp;
    rule_tail = temp;
#endif

    return 0;
}

/*	Clear all rules						HTClearRules()
 *	---------------
 *
 * On exit,
 *	There are no rules
 *
 * See also
 *	HTAddRule()
 */
void HTClearRules(void)
{
    while (rules) {
	rule *temp = rules;

	rules = temp->next;
	FREE(temp->pattern);
	FREE(temp->equiv);
	FREE(temp->condition_op);
	FREE(temp->condition);
	FREE(temp);
    }
#ifndef PUT_ON_HEAD
    rule_tail = 0;
#endif
}

static BOOL rule_cond_ok(rule * r)
{
    BOOL result;

    if (!r->condition_op)
	return YES;
    if (strcmp(r->condition_op, "if") && strcmp(r->condition_op, "unless")) {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s'!\n",
		r->condition_op));
	return NO;
    }
    if (!strcmp(r->condition, "redirected"))
	result = (BOOL) (redirection_attempts > 0);
    else if (!strcmp(r->condition, "userspec"))
	result = LYUserSpecifiedURL;
    else {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s %s'!\n",
		r->condition_op, NONNULL(r->condition)));
	return NO;
    }
    if (!strcmp(r->condition_op, "if"))
	return result;
    else
	return (BOOL) (!result);

}

/*	Translate by rules					HTTranslate()
 *	------------------
 *
 *	The most recently defined rules are applied first.
 *
 * On entry,
 *	required	points to a string whose equivalent value is needed
 * On exit,
 *	returns		the address of the equivalent string allocated from
 *			the heap which the CALLER MUST FREE. If no translation
 *			occurred, then it is a copy of the original.
 * NEW FEATURES:
 *			When a "protect" or "defprot" rule is matched,
 *			a call to HTAA_setCurrentProtection() or
 *			HTAA_setDefaultProtection() is made to notify
 *			the Access Authorization module that the file is
 *			protected, and so it knows how to handle it.
 *								-- AL
 */
char *HTTranslate(const char *required)
{
    rule *r;
    char *current = NULL;
    char *msgtmp = NULL;
    const char *pMsg;
    int proxy_none_flag = 0;
    int permitredir_flag = 0;

    StrAllocCopy(current, required);

    HTAA_clearProtections();	/* Reset from previous call -- AL */

    for (r = rules; r; r = r->next) {
	char *p = r->pattern;
	int m = 0;		/* Number of characters matched against wildcard */
	const char *q = current;

	for (; *p && *q; p++, q++) {	/* Find first mismatch */
	    if (*p != *q)
		break;
	}

	if (*p == '*') {	/* Match up to wildcard */
	    m = strlen(q) - strlen(p + 1);	/* Amount to match to wildcard */
	    if (m < 0)
		continue;	/* tail is too short to match */
	    if (0 != strcmp(q + m, p + 1))
		continue;	/* Tail mismatch */
	} else
	    /* Not wildcard */ if (*p != *q)
	    continue;		/* plain mismatch: go to next rule */

	if (!rule_cond_ok(r))	/* check condition, next rule if false - kw */
	    continue;

	switch (r->op) {	/* Perform operation */

#ifdef ACCESS_AUTH
	case HT_DefProt:
	case HT_Protect:
	    {
		char *local_copy = NULL;
		char *p2;
		char *eff_ids = NULL;
		char *prot_file = NULL;

		CTRACE((tfp, "HTRule: `%s' matched %s %s: `%s'\n",
			current,
			(r->op == HT_Protect ? "Protect" : "DefProt"),
			"rule, setup",
			(r->equiv ? r->equiv :
			 (r->op == HT_Protect ? "DEFAULT" : "NULL!!"))));

		if (r->equiv) {
		    StrAllocCopy(local_copy, r->equiv);
		    p2 = local_copy;
		    prot_file = HTNextField(&p2);
		    eff_ids = HTNextField(&p2);
		}

		if (r->op == HT_Protect)
		    HTAA_setCurrentProtection(current, prot_file, eff_ids);
		else
		    HTAA_setDefaultProtection(current, prot_file, eff_ids);

		FREE(local_copy);

		/* continue translating rules */
	    }
	    break;
#endif /* ACCESS_AUTH */

	case HT_UserMsg:	/* Produce message immediately */
	    LYFixCursesOn("show rule message:");
	    HTUserMsg2((r->equiv ? r->equiv : "Rule: %s"), current);
	    break;
	case HT_InfoMsg:	/* Produce messages immediately */
	case HT_Progress:
	case HT_Alert:
	    LYFixCursesOn("show rule message:");	/* and fall through */
	case HT_AlwaysAlert:
	    pMsg = r->equiv ? r->equiv :
		(r->op == HT_AlwaysAlert) ? "%s" : "Rule: %s";
	    if (strchr(pMsg, '%')) {
		HTSprintf0(&msgtmp, pMsg, current);
		pMsg = msgtmp;
	    }
	    switch (r->op) {	/* Actually produce message */
	    case HT_InfoMsg:
		HTInfoMsg(pMsg);
		break;
	    case HT_Progress:
		HTProgress(pMsg);
		break;
	    case HT_Alert:
		HTAlert(pMsg);
		break;
	    case HT_AlwaysAlert:
		HTAlwaysAlert("Rule alert:", pMsg);
		break;
	    default:
		break;
	    }
	    FREE(msgtmp);
	    break;

	case HT_PermitRedir:	/* Set special flag */
	    permitredir_flag = 1;
	    CTRACE((tfp, "HTRule: Mark for redirection permitted\n"));
	    break;

	case HT_Pass:		/* Authorised */
	    if (!r->equiv) {
		if (proxy_none_flag) {
		    char *temp = NULL;

		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
		}
		CTRACE((tfp, "HTRule: Pass `%s'\n", current));
		return current;
	    }
	    /* Else fall through ...to map and pass */

	case HT_Map:
	case HT_Redirect:
	case HT_RedirectPerm:
	    if (*p == *q) {	/* End of both strings, no wildcard */
		CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
		StrAllocCopy(current, r->equiv);	/* use entire translation */
	    } else {
		char *ins = strchr(r->equiv, '*');	/* Insertion point */

		if (ins) {	/* Consistent rule!!! */
		    char *temp = NULL;

		    HTSprintf0(&temp, "%.*s%.*s%s",
			       ins - r->equiv,
			       r->equiv,
			       m,
			       q,
			       ins + 1);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */

		} else {	/* No insertion point */
		    char *temp = NULL;

		    StrAllocCopy(temp, r->equiv);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */
		}		/* If no insertion point exists */
	    }
	    if (r->op == HT_Pass) {
		if (proxy_none_flag) {
		    char *temp = NULL;

		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
		}
		CTRACE((tfp, "HTRule: ...and pass `%s'\n",
			current));
		return current;
	    } else if (r->op == HT_Redirect) {
		CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
			current));
		redirecting_url = current;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    } else if (r->op == HT_RedirectPerm) {
		CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
			current));
		redirecting_url = current;
		permanent_redirection = TRUE;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    }
	    break;

	case HT_UseProxy:
	    if (r->equiv && 0 == strcasecomp(r->equiv, "none")) {
		CTRACE((tfp, "For `%s' will not use proxy\n", current));
		proxy_none_flag = 1;
	    } else if (proxy_none_flag) {
		CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			current,
			NONNULL(r->equiv)));
	    } else {
		char *temp = NULL;

		StrAllocCopy(temp, "Proxied=");
		StrAllocCat(temp, r->equiv);
		StrAllocCat(temp, current);
		CTRACE((tfp, "HTRule: proxy server found: %s\n",
			NONNULL(r->equiv)));
		FREE(current);
		return temp;
	    }
	    break;

	case HT_Invalid:
	case HT_Fail:		/* Unauthorised */
	    CTRACE((tfp, "HTRule: *** FAIL `%s'\n", current));
	    FREE(current);
	    return (char *) 0;
	}			/* if tail matches ... switch operation */

    }				/* loop over rules */

    if (proxy_none_flag) {
	char *temp = NULL;

	StrAllocCopy(temp, "NoProxy=");
	StrAllocCat(temp, current);
	FREE(current);
	return temp;
    }

    return current;
}

/*	Load one line of configuration
 *	------------------------------
 *
 *	Call this, for example, to load a X resource with config info.
 *
 * returns	0 OK, < 0 syntax error.
 */
int HTSetConfiguration(char *config)
{
    HTRuleOp op;
    char *line = NULL;
    char *pointer = line;
    char *word1;
    const char *word2;
    const char *word3;
    const char *cond_op = NULL;
    const char *cond = NULL;
    float quality, secs, secs_per_byte;
    int maxbytes;
    int status;

    StrAllocCopy(line, config);
    {
	char *p = strchr(line, '#');	/* Chop off comments */

	if (p)
	    *p = 0;
    }
    pointer = line;
    word1 = HTNextField(&pointer);
    if (!word1) {
	FREE(line);
	return 0;
    };				/* Comment only or blank */

    word2 = HTNextField(&pointer);

    if (0 == strcasecomp(word1, "defprot") ||
	0 == strcasecomp(word1, "protect"))
	word3 = pointer;	/* The rest of the line to be parsed by AA module */
    else
	word3 = HTNextField(&pointer);	/* Just the next word */

    if (!word2) {
	fprintf(stderr, "HTRule: %s %s\n", RULE_NEEDS_DATA, line);
	FREE(line);
	return -2;		/*syntax error */
    }

    if (0 == strcasecomp(word1, "suffix")) {
	char *encoding = HTNextField(&pointer);

	if (pointer)
	    status = sscanf(pointer, "%f", &quality);
	else
	    status = 0;
	HTSetSuffix(word2, word3,
		    encoding ? encoding : "binary",
		    status >= 1 ? quality : (float) 1.0);

    } else if (0 == strcasecomp(word1, "presentation")) {
	if (pointer)
	    status = sscanf(pointer, "%f%f%f%d",
			    &quality, &secs, &secs_per_byte, &maxbytes);
	else
	    status = 0;
	HTSetPresentation(word2, word3, NULL,
			  status >= 1 ? quality : 1.0,
			  status >= 2 ? secs : 0.0,
			  status >= 3 ? secs_per_byte : 0.0,
			  status >= 4 ? maxbytes : 0,
			  mediaCFG);

    } else if (0 == strncasecomp(word1, "htbin", 5) ||
	       0 == strncasecomp(word1, "bindir", 6)) {
	StrAllocCopy(HTBinDir, word2);	/* Physical /htbin location */

    } else if (0 == strncasecomp(word1, "search", 6)) {
	StrAllocCopy(HTSearchScript, word2);	/* Search script name */

    } else {
	op = 0 == strcasecomp(word1, "map") ? HT_Map
	    : 0 == strcasecomp(word1, "pass") ? HT_Pass
	    : 0 == strcasecomp(word1, "fail") ? HT_Fail
	    : 0 == strcasecomp(word1, "redirect") ? HT_Redirect
	    : 0 == strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    : 0 == strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    : 0 == strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    : 0 == strcasecomp(word1, "useproxy") ? HT_UseProxy
	    : 0 == strcasecomp(word1, "alert") ? HT_Alert
	    : 0 == strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    : 0 == strcasecomp(word1, "progress") ? HT_Progress
	    : 0 == strcasecomp(word1, "usermsg") ? HT_UserMsg
	    : 0 == strcasecomp(word1, "infomsg") ? HT_InfoMsg
	    : 0 == strcasecomp(word1, "defprot") ? HT_DefProt
	    : 0 == strcasecomp(word1, "protect") ? HT_Protect
	    : HT_Invalid;
	if (op == HT_Invalid) {
	    fprintf(stderr, "HTRule: %s '%s'\n", RULE_INCORRECT, config);
	} else {
	    switch (op) {
	    case HT_Fail:	/* never a or other 2nd parameter */
	    case HT_PermitRedir:
		cond_op = word3;
		if (cond_op && *cond_op) {
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		}
		break;

	    case HT_Pass:	/* possibly a URL2 */
		if (word3 && (!strcasecomp(word3, "if") ||
			      !strcasecomp(word3, "unless"))) {
		    cond_op = word3;
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		    break;
		}
		/* else fall through */
	    case HT_Map:	/* always a URL2 (or other 2nd parameter) */
	    case HT_Redirect:
	    case HT_RedirectPerm:
	    case HT_UseProxy:
		cond_op = HTNextField(&pointer);
		/* check for extra status word in "Redirect" */
		if (op == HT_Redirect && 0 == strcasecomp(word1, "redirect") &&
		    cond_op &&
		    strcasecomp(cond_op, "if") &&
		    strcasecomp(cond_op, "unless")) {
		    if (0 == strcmp(word2, "301") ||
			0 == strcasecomp(word2, "permanent")) {
			op = HT_RedirectPerm;
		    } else if (!(0 == strcmp(word2, "302") ||
				 0 == strcmp(word2, "303") ||
				 0 == strcasecomp(word2, "temp") ||
				 0 == strcasecomp(word2, "seeother"))) {
			CTRACE((tfp, "Rule: Ignoring `%s' in Redirect\n", word2));
		    }
		    word2 = word3;
		    word3 = cond_op;	/* cond_op isn't condition op after all */
		    cond_op = HTNextField(&pointer);
		}
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		break;

	    case HT_Progress:
	    case HT_InfoMsg:
	    case HT_UserMsg:
	    case HT_Alert:
	    case HT_AlwaysAlert:
		cond_op = HTNextField(&pointer);
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		if (word3) {	/* Fix string with too may %s - kw */
		    const char *cp = word3;
		    char *cp1, *cp2;

		    while ((cp1 = strchr(cp, '%'))) {
			if (cp1[1] == '\0') {
			    *cp1 = '\0';
			    break;
			} else if (cp1[1] == '%') {
			    cp = cp1 + 2;
			    continue;
			} else
			    while ((cp2 = strchr(cp1 + 2, '%'))) {
				if (cp2[1] == '\0') {
				    *cp2 = '\0';
				    break;
				} else if (cp2[1] == '%') {
				    cp1 = cp2;
				} else {
				    *cp2 = '?';		/* replace bad % */
				    cp1 = cp2;
				}
			    }
			break;
		    }
		}
		break;

	    default:
		break;
	    }
	    if (cond_op && cond && *cond && !strcasecomp(cond_op, "unless")) {
		cond_op = "unless";
	    } else if (cond_op && cond && *cond &&
		       !strcasecomp(cond_op, "if")) {
		cond_op = "if";
	    } else if (cond_op || cond) {
		fprintf(stderr, "HTRule: %s '%s'\n", RULE_INCORRECT, config);
		FREE(line);	/* syntax error, condition is a mess - kw */
		return -2;	/* NB unrecognized cond passes here - kw */
	    }
	    if (cond && !strncasecomp(cond, "redirected", strlen(cond))) {
		cond = "redirected";	/* recognized, canonical case - kw */
	    } else if (cond && strlen(cond) >= 8 &&
		       !strncasecomp(cond, "userspecified", strlen(cond))) {
		cond = "userspec";	/* also allow abbreviation - kw */
	    }
	    HTAddRule(op, word2, word3, cond_op, cond);
	}
    }
    FREE(line);
    return 0;
}

/*	Load the rules from a file				HTLoadRules()
 *	--------------------------
 *
 * On entry,
 *	Rules can be in any state
 * On exit,
 *	Any existing rules will have been kept.
 *	Any new rules will have been loaded.
 *	Returns		0 if no error, 0 if error!
 *
 * Bugs:
 *	The strings may not contain spaces.
 */

int HTLoadRules(const char *filename)
{
    FILE *fp = fopen(filename, TXT_R);
    char line[LINE_LENGTH + 1];

    if (!fp) {
	CTRACE((tfp, "HTRules: Can't open rules file %s\n", filename));
	return -1;		/* File open error */
    }
    for (;;) {
	if (!fgets(line, LINE_LENGTH + 1, fp))
	    break;		/* EOF or error */
	(void) HTSetConfiguration(line);
    }
    fclose(fp);
    return 0;			/* No error or syntax errors ignored */
}

#endif /* NO_RULES */
@


1.5
log
@automatic merge of lynx-current
@
text
@d212 2
a213 1
    char *msgtmp = NULL, *pMsg;
d450 5
a454 2
    char *word1, *word2, *word3;
    char *cond_op = NULL, *cond = NULL;
d593 2
a594 1
		    char *cp = word3, *cp1, *cp2;
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 19
a20 19
**	==========================================
**
**
** History:
**	 3 Jun 91	Written TBL
**	10 Aug 91	Authorisation added after Daniel Martin (pass, fail)
**			Rule order in file changed
**			Comments allowed with # on 1st char of rule line
**	17 Jun 92	Bug fix: pass and fail failed if didn't contain '*' TBL
**	 1 Sep 93	Bug fix: no memory check - Nathan Torkington
**			BYTE_ADDRESSING removed - Arthur Secret
**	11 Sep 93  MD	Changed %i into %d in debug printf.
**			VMS does not recognize %i.
**			Bug Fix: in case of PASS, only one parameter to printf.
**	19 Sep 93  AL	Added Access Authorization stuff.
**	 1 Nov 93  AL	Added htbin.
**	25 May 99  KW	Added redirect for lynx.
**
*/
a32 1

d34 6
a39 6
	struct _rule *	next;
	HTRuleOp	op;
	char *		pattern;
	char *		equiv;
	char *		condition_op; /* as strings - may be inefficient, */
	char *		condition;    /* but this is not for a server - kw */
d44 2
a45 2
#include <HTTP.h> /* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h> /* for LYUserSpecifiedURL - kw */
d50 4
a53 3
**	----------------
*/
char *HTBinDir = NULL;	/* Physical /htbin directory path.	*/
d55 1
a55 1
char *HTSearchScript = NULL;	/* Search script name.		*/
d57 3
d61 1
a61 3
/*	Module-wide variables
**	---------------------
*/
a62 1
static rule * rules = 0;	/* Pointer to first on list */
d64 1
a64 1
static rule * rule_tail = 0;	/* Pointer to last on list */
a66 1

d68 17
a84 19
**	--------------------
**
**  On entry,
**	pattern		points to 0-terminated string containing a single "*"
**	equiv		points to the equivalent string with * for the
**			place where the text matched by * goes.
**  On exit,
**	returns		0 if success, -1 if error.
*/

int HTAddRule (
    HTRuleOp		op,
    const char *	pattern,
    const char *	equiv,
    const char *	cond_op,
    const char *	cond)
{ /* BYTE_ADDRESSING removed and memory check - AS - 1 Sep 93 */
    rule *	temp;
    char *	pPattern = NULL;
d87 1
a87 1
    if (temp==NULL)
d90 2
a91 1
	char *	pEquiv = NULL;
d126 4
a129 2
    if (rule_tail) rule_tail->next = temp;
    else rules = temp;
a132 1

a135 1

d137 9
a145 9
**	---------------
**
** On exit,
**	There are no rules
**
** See also
**	HTAddRule()
*/
void HTClearRules (void)
d148 2
a149 1
	rule * temp = rules;
d162 1
a162 2
static BOOL rule_cond_ok (
    rule *	 r)
d165 1
d170 1
a170 1
	       r->condition_op));
d179 1
a179 1
	       r->condition_op, NONNULL(r->condition)));
d188 1
d190 19
a208 20
**	------------------
**
**	The most recently defined rules are applied first.
**
** On entry,
**	required	points to a string whose equivalent value is needed
** On exit,
**	returns		the address of the equivalent string allocated from
**			the heap which the CALLER MUST FREE. If no translation
**			occurred, then it is a copy of the original.
** NEW FEATURES:
**			When a "protect" or "defprot" rule is matched,
**			a call to HTAA_setCurrentProtection() or
**			HTAA_setDefaultProtection() is made to notify
**			the Access Authorization module that the file is
**			protected, and so it knows how to handle it.
**								-- AL
*/
char * HTTranslate (
    const char *	required)
d210 1
a210 1
    rule * r;
d220 8
a227 6
    for(r = rules; r; r = r->next) {
	char * p = r->pattern;
	int m=0;   /* Number of characters matched against wildcard */
	const char * q = current;
	for(;*p && *q; p++, q++) {   /* Find first mismatch */
	    if (*p!=*q) break;
d230 9
a238 6
	if (*p == '*') {		/* Match up to wildcard */
	    m = strlen(q) - strlen(p+1); /* Amount to match to wildcard */
	    if(m<0) continue;		/* tail is too short to match */
	    if (0!=strcmp(q+m, p+1)) continue;	/* Tail mismatch */
	} else				/* Not wildcard */
	    if (*p != *q) continue;	/* plain mismatch: go to next rule */
d243 1
a243 1
	switch (r->op) {		/* Perform operation */
d255 5
a259 5
			    current,
			    (r->op==HT_Protect ? "Protect" : "DefProt"),
			    "rule, setup",
			    (r->equiv ? r->equiv :
			     (r->op==HT_Protect ?"DEFAULT" :"NULL!!"))));
d280 1
a280 1
	case HT_UserMsg:		/* Produce message immediately */
d284 1
a284 1
	case HT_InfoMsg:		/* Produce messages immediately */
d287 1
a287 1
	    LYFixCursesOn("show rule message:"); /* and fall through */
d290 1
a290 1
		(r->op==HT_AlwaysAlert) ? "%s" : "Rule: %s";
d295 15
a309 6
	    switch (r->op) {		/* Actually produce message */
	    case HT_InfoMsg:	HTInfoMsg(pMsg);	break;
	    case HT_Progress:	HTProgress(pMsg);	break;
	    case HT_Alert:	HTAlert(pMsg);		break;
	    case HT_AlwaysAlert: HTAlwaysAlert("Rule alert:", pMsg);	break;
	    default: break;
d314 1
a314 1
	case HT_PermitRedir:			/* Set special flag */
d319 1
a319 1
	case HT_Pass:				/* Authorised */
d322 2
a323 1
		    char * temp = NULL;
d337 3
a339 3
	    if (*p == *q) { /* End of both strings, no wildcard */
		  CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
		  StrAllocCopy(current, r->equiv); /* use entire translation */
d341 29
a369 51
		  char * ins = strchr(r->equiv, '*');	/* Insertion point */
		  if (ins) {	/* Consistent rule!!! */
			char * temp = NULL;

			HTSprintf0(&temp, "%.*s%.*s%s",
				   ins - r->equiv,
				   r->equiv,
				   m,
				   q,
				   ins + 1);
			CTRACE((tfp, "For `%s' using `%s'\n",
				    current, temp));
			FREE(current);
			current = temp;			/* Use this */

		    } else {	/* No insertion point */
			char * temp = NULL;

			StrAllocCopy(temp, r->equiv);
			CTRACE((tfp, "For `%s' using `%s'\n",
						current, temp));
			FREE(current);
			current = temp;			/* Use this */
		    } /* If no insertion point exists */
		}
		if (r->op == HT_Pass) {
		    if (proxy_none_flag) {
			char * temp = NULL;
			StrAllocCopy(temp, "NoProxy=");
			StrAllocCat(temp, current);
			FREE(current);
			current = temp;
		    }
		    CTRACE((tfp, "HTRule: ...and pass `%s'\n",
				current));
		    return current;
		} else if (r->op == HT_Redirect) {
		    CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
				current));
		    redirecting_url = current;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		} else if (r->op == HT_RedirectPerm) {
		    CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
				current));
		    redirecting_url = current;
		    permanent_redirection = TRUE;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		}
		break;
d371 1
a371 12
	case HT_UseProxy:
		if (r->equiv && 0==strcasecomp(r->equiv, "none")) {
		    CTRACE((tfp, "For `%s' will not use proxy\n", current));
		    proxy_none_flag = 1;
		} else if (proxy_none_flag) {
		    CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			   current,
			   NONNULL(r->equiv)));
		} else {
		    char * temp = NULL;
		    StrAllocCopy(temp, "Proxied=");
		    StrAllocCat(temp, r->equiv);
a372 2
		    CTRACE((tfp, "HTRule: proxy server found: %s\n",
			   NONNULL(r->equiv)));
d374 1
a374 1
		    return temp;
d376 39
a414 1
		break;
d417 5
a421 5
	case HT_Fail:				/* Unauthorised */
		CTRACE((tfp, "HTRule: *** FAIL `%s'\n", current));
		FREE(current);
		return (char *)0;
	} /* if tail matches ... switch operation */
d423 1
a423 1
    } /* loop over rules */
d426 2
a427 1
	char * temp = NULL;
d438 7
a444 8
**	------------------------------
**
**	Call this, for example, to load a X resource with config info.
**
** returns	0 OK, < 0 syntax error.
*/
int  HTSetConfiguration (
    char *		config)
d447 2
a448 2
    char * line = NULL;
    char * pointer = line;
d450 1
a450 1
    char *cond_op=NULL, *cond=NULL;
d457 4
a460 2
	char * p = strchr(line, '#');	/* Chop off comments */
	if (p) *p = 0;
d467 1
a467 1
    } ; /* Comment only or blank */
d471 3
a473 3
    if (0==strcasecomp(word1, "defprot") ||
	0==strcasecomp(word1, "protect"))
	word3 = pointer;  /* The rest of the line to be parsed by AA module */
d480 1
a480 1
	return -2;	/*syntax error */
d483 2
a484 7
    if (0==strcasecomp(word1, "suffix")) {
	char * encoding = HTNextField(&pointer);
	if (pointer) status = sscanf(pointer, "%f", &quality);
	else status = 0;
	HTSetSuffix(word2,	word3,
				encoding ? encoding : "binary",
				status >= 1? quality : (float) 1.0);
d486 11
a496 2
    } else if (0==strcasecomp(word1, "presentation")) {
	if (pointer) status = sscanf(pointer, "%f%f%f%d",
d498 8
a505 6
	else status = 0;
	HTSetPresentation(word2, word3,
		    status >= 1 ? quality		: 1.0,
		    status >= 2 ? secs			: 0.0,
		    status >= 3 ? secs_per_byte		: 0.0,
		    status >= 4 ? maxbytes		: 0 );
d507 2
a508 2
    } else if (0==strncasecomp(word1, "htbin", 5) ||
	       0==strncasecomp(word1, "bindir", 6)) {
d511 1
a511 1
    } else if (0==strncasecomp(word1, "search", 6)) {
d515 17
a531 17
	op =	0==strcasecomp(word1, "map")  ? HT_Map
	    :	0==strcasecomp(word1, "pass") ? HT_Pass
	    :	0==strcasecomp(word1, "fail") ? HT_Fail
	    :	0==strcasecomp(word1, "redirect") ? HT_Redirect
	    :	0==strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    :	0==strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    :	0==strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    :	0==strcasecomp(word1, "useproxy") ? HT_UseProxy
	    :	0==strcasecomp(word1, "alert") ? HT_Alert
	    :	0==strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    :	0==strcasecomp(word1, "progress") ? HT_Progress
	    :	0==strcasecomp(word1, "usermsg") ? HT_UserMsg
	    :	0==strcasecomp(word1, "infomsg") ? HT_InfoMsg
	    :	0==strcasecomp(word1, "defprot") ? HT_DefProt
	    :	0==strcasecomp(word1, "protect") ? HT_Protect
	    :						HT_Invalid;
	if (op==HT_Invalid) {
d551 2
a552 2
		} /* else fall through */

d559 1
a559 1
		if (op==HT_Redirect && 0==strcasecomp(word1, "redirect") &&
d563 2
a564 2
		    if (0==strcmp(word2, "301") ||
			0==strcasecomp(word2, "permanent")) {
d566 4
a569 4
		    } else if (!(0==strcmp(word2, "302") ||
				 0==strcmp(word2, "303") ||
				 0==strcasecomp(word2, "temp") ||
				 0==strcasecomp(word2, "seeother"))) {
d573 1
a573 1
		    word3 = cond_op; /* cond_op isn't condition op after all */
d590 2
a591 1
		    while ((cp1=strchr(cp, '%'))) {
d598 11
a608 9
			} else while ((cp2=strchr(cp1+2, '%'))) {
			    if (cp2[1] == '\0') {
				*cp2 = '\0';
				break;
			    } else if (cp2[1] == '%') {
				cp1 = cp2;
			    } else {
				*cp2 = '?'; /* replace bad % */
				cp1 = cp2;
a609 1
			}
d615 1
a615 1
		default:
d629 1
a629 1
		cond = "redirected"; /* recognized, canonical case - kw */
d631 2
a632 2
		!strncasecomp(cond, "userspecified", strlen(cond))) {
		cond = "userspec"; /* also allow abbreviation - kw */
a640 1

d642 12
a653 12
**	--------------------------
**
** On entry,
**	Rules can be in any state
** On exit,
**	Any existing rules will have been kept.
**	Any new rules will have been loaded.
**	Returns		0 if no error, 0 if error!
**
** Bugs:
**	The strings may not contain spaces.
*/
d655 1
a655 2
int HTLoadRules (
    const char *	filename)
d657 2
a658 2
    FILE * fp = fopen(filename, TXT_R);
    char line[LINE_LENGTH+1];
d662 1
a662 1
	return -1; /* File open error */
d664 3
a666 2
    for(;;) {
	if (!fgets(line, LINE_LENGTH+1, fp)) break;	/* EOF or error */
d670 1
a670 1
    return 0;		/* No error or syntax errors ignored */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d53 1
a53 1
PUBLIC char *HTBinDir = NULL;	/* Physical /htbin directory path.	*/
d55 1
a55 1
PUBLIC char *HTSearchScript = NULL;	/* Search script name.		*/
d62 1
a62 1
PRIVATE rule * rules = 0;	/* Pointer to first on list */
d64 1
a64 1
PRIVATE rule * rule_tail = 0;	/* Pointer to last on list */
d79 6
a84 6
PUBLIC int HTAddRule ARGS5(
    HTRuleOp,		op,
    CONST char *,	pattern,
    CONST char *,	equiv,
    CONST char *,	cond_op,
    CONST char *,	cond)
d147 1
a147 1
void HTClearRules NOARGS
d163 2
a164 2
PRIVATE BOOL rule_cond_ok ARGS1(
    rule *,	 r)
d208 2
a209 2
char * HTTranslate ARGS1(
    CONST char *,	required)
d224 1
a224 1
	CONST char * q = current;
d426 2
a427 2
PUBLIC int  HTSetConfiguration ARGS1(
    char *,		config)
d629 2
a630 2
int HTLoadRules ARGS1(
    CONST char *,	filename)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d18 1
d39 2
d45 5
d72 1
a72 1
**	pattern 	points to 0-terminated string containing a single "*"
d76 1
a76 1
**	returns 	0 if success, -1 if error.
d79 1
a79 1
PUBLIC int HTAddRule ARGS3(
d82 3
a84 1
    CONST char *,	equiv)
d87 1
a87 1
    char *	pPattern;
d89 1
a89 1
    temp = (rule *)malloc(sizeof(*temp));
a91 3
    pPattern = (char *)malloc(strlen(pattern)+1);
    if (pPattern==NULL)
	outofmem(__FILE__, "HTAddRule");
d93 2
a94 3
	char *	pEquiv = (char *)malloc(strlen(equiv)+1);
	if (pEquiv==NULL)
	    outofmem(__FILE__, "HTAddRule");
a95 1
	strcpy(pEquiv, equiv);
d99 5
a106 1
    strcpy(pPattern, pattern);
d108 1
a108 1
	CTRACE(tfp, "Rule: For `%s' op %d `%s'\n", pattern, op, equiv);
d110 6
a115 1
	CTRACE(tfp, "Rule: For `%s' op %d\n", pattern, op);
d138 1
a138 1
/*	Clear all rules 					HTClearRules()
d154 2
d163 24
d188 1
d195 1
a195 1
**	required	points to a string whose equivalent value is neeed
d197 1
a197 1
**	returns 	the address of the equivalent string allocated from
d199 1
a199 1
**			occured, then it is a copy of te original.
d201 1
a201 1
**			When a "protect" or "defprot" rule is mathed,
d213 4
d236 3
d250 1
a250 1
		CTRACE(tfp, "HTRule: `%s' matched %s %s: `%s'\n",
d255 1
a255 1
			     (r->op==HT_Protect ?"DEFAULT" :"NULL!!")));
d276 30
d307 7
a313 3
		if (!r->equiv) {
		    CTRACE(tfp, "HTRule: Pass `%s'\n", current);
		    return current;
d315 4
a318 1
		/* Else fall through ...to map and pass */
d321 2
d324 1
a324 1
		  CTRACE(tfp, "For `%s' using `%s'\n", current, r->equiv);
d329 10
a338 10
			char * temp = (char *)malloc(
				strlen(r->equiv)-1 + m + 1);
			if (temp==NULL)
			    outofmem(__FILE__, "HTTranslate"); /* NT & AS */
			strncpy(temp,	r->equiv, ins-r->equiv);
			/* Note: temp may be unterminated now! */
			strncpy(temp+(ins-r->equiv), q, m);  /* Matched bit */
			strcpy (temp+(ins-r->equiv)+m, ins+1);	/* Last bit */
			CTRACE(tfp, "For `%s' using `%s'\n",
				    current, temp);
d340 1
a340 1
			current = temp; 		/* Use this */
d343 5
a347 6
			char * temp = (char *)malloc(strlen(r->equiv)+1);
			if (temp==NULL)
			    outofmem(__FILE__, "HTTranslate"); /* NT & AS */
			strcpy(temp, r->equiv);
			CTRACE(tfp, "For `%s' using `%s'\n",
						current, temp);
d349 1
a349 1
			current = temp; 		/* Use this */
d353 9
a361 2
		    CTRACE(tfp, "HTRule: ...and pass `%s'\n",
				current);
d363 33
d401 1
a401 2
		CTRACE(tfp, "HTRule: *** FAIL `%s'\n",
			    current);
d408 7
d433 1
d470 1
a470 1
				status >= 1? quality : 1.0);
d477 1
a477 1
		    status >= 1? quality		: 1.0,
d479 1
a479 1
		    status >= 3 ? secs_per_byte 	: 0.0,
d493 10
d509 99
a607 1
	    HTAddRule(op, word2, word3);
d623 1
a623 1
**	Returns 	0 if no error, 0 if error!
d632 1
a632 1
    FILE * fp = fopen(filename, "r");
d636 1
a636 1
	CTRACE(tfp, "HTRules: Can't open rules file %s\n", filename);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 18
a19 19
 *	==========================================
 *
 *
 * History:
 *	 3 Jun 91	Written TBL
 *	10 Aug 91	Authorisation added after Daniel Martin (pass, fail)
 *			Rule order in file changed
 *			Comments allowed with # on 1st char of rule line
 *	17 Jun 92	Bug fix: pass and fail failed if didn't contain '*' TBL
 *	 1 Sep 93	Bug fix: no memory check - Nathan Torkington
 *			BYTE_ADDRESSING removed - Arthur Secret
 *	11 Sep 93  MD	Changed %i into %d in debug printf.
 *			VMS does not recognize %i.
 *			Bug Fix: in case of PASS, only one parameter to printf.
 *	19 Sep 93  AL	Added Access Authorization stuff.
 *	 1 Nov 93  AL	Added htbin.
 *	25 May 99  KW	Added redirect for lynx.
 *
 */
d32 1
d34 4
a37 6
    struct _rule *next;
    HTRuleOp op;
    char *pattern;
    char *equiv;
    char *condition_op;		/* as strings - may be inefficient, */
    char *condition;		/* but this is not for a server - kw */
a41 5
#include <HTTP.h>		/* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h>	/* for LYUserSpecifiedURL - kw */
#include <LYUtils.h>		/* for LYFixCursesOn - kw */
#include <HTAlert.h>

d43 5
a47 3
 *	----------------
 */
char *HTBinDir = NULL;		/* Physical /htbin directory path.      */
a48 2
				/* In future this should not be global. */
char *HTSearchScript = NULL;	/* Search script name.          */
d51 2
a52 4
 *	---------------------
 */

static rule *rules = 0;		/* Pointer to first on list */
d54 1
d56 1
a56 1
static rule *rule_tail = 0;	/* Pointer to last on list */
d59 1
d61 17
a77 17
 *	--------------------
 *
 *  On entry,
 *	pattern		points to 0-terminated string containing a single "*"
 *	equiv		points to the equivalent string with * for the
 *			place where the text matched by * goes.
 *  On exit,
 *	returns		0 if success, -1 if error.
 */

int HTAddRule(HTRuleOp op, const char *pattern,
	      const char *equiv,
	      const char *cond_op,
	      const char *cond)
{				/* BYTE_ADDRESSING removed and memory check - AS - 1 Sep 93 */
    rule *temp;
    char *pPattern = NULL;
d79 5
a83 2
    temp = typecalloc(rule);
    if (temp == NULL)
d86 3
a88 3
	char *pEquiv = NULL;

	StrAllocCopy(pEquiv, equiv);
d90 1
a93 5
    if (cond_op) {
	StrAllocCopy(temp->condition_op, cond_op);
	StrAllocCopy(temp->condition, cond);
    }
    StrAllocCopy(pPattern, pattern);
d97 1
d99 1
a99 6
	CTRACE((tfp, "Rule: For `%s' op %d `%s'", pattern, op, equiv));
    } else {
	CTRACE((tfp, "Rule: For `%s' op %d", pattern, op));
    }
    if (cond_op) {
	CTRACE((tfp, "\t%s %s\n", cond_op, NONNULL(cond)));
d101 1
a101 1
	CTRACE((tfp, "\n"));
d114 2
a115 4
    if (rule_tail)
	rule_tail->next = temp;
    else
	rules = temp;
d119 1
d123 11
a133 10
/*	Clear all rules						HTClearRules()
 *	---------------
 *
 * On exit,
 *	There are no rules
 *
 * See also
 *	HTAddRule()
 */
void HTClearRules(void)
d136 1
a136 2
	rule *temp = rules;

a139 2
	FREE(temp->condition_op);
	FREE(temp->condition);
a146 26
static BOOL rule_cond_ok(rule * r)
{
    BOOL result;

    if (!r->condition_op)
	return YES;
    if (strcmp(r->condition_op, "if") && strcmp(r->condition_op, "unless")) {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s'!\n",
		r->condition_op));
	return NO;
    }
    if (!strcmp(r->condition, "redirected"))
	result = (BOOL) (redirection_attempts > 0);
    else if (!strcmp(r->condition, "userspec"))
	result = LYUserSpecifiedURL;
    else {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s %s'!\n",
		r->condition_op, NONNULL(r->condition)));
	return NO;
    }
    if (!strcmp(r->condition_op, "if"))
	return result;
    else
	return (BOOL) (!result);

}
d149 20
a168 19
 *	------------------
 *
 *	The most recently defined rules are applied first.
 *
 * On entry,
 *	required	points to a string whose equivalent value is needed
 * On exit,
 *	returns		the address of the equivalent string allocated from
 *			the heap which the CALLER MUST FREE. If no translation
 *			occurred, then it is a copy of the original.
 * NEW FEATURES:
 *			When a "protect" or "defprot" rule is matched,
 *			a call to HTAA_setCurrentProtection() or
 *			HTAA_setDefaultProtection() is made to notify
 *			the Access Authorization module that the file is
 *			protected, and so it knows how to handle it.
 *								-- AL
 */
char *HTTranslate(const char *required)
d170 1
a170 1
    rule *r;
a171 5
    char *msgtmp = NULL;
    const char *pMsg;
    int proxy_none_flag = 0;
    int permitredir_flag = 0;

d176 6
a181 8
    for (r = rules; r; r = r->next) {
	char *p = r->pattern;
	int m = 0;		/* Number of characters matched against wildcard */
	const char *q = current;

	for (; *p && *q; p++, q++) {	/* Find first mismatch */
	    if (*p != *q)
		break;
d184 6
a189 12
	if (*p == '*') {	/* Match up to wildcard */
	    m = strlen(q) - strlen(p + 1);	/* Amount to match to wildcard */
	    if (m < 0)
		continue;	/* tail is too short to match */
	    if (0 != strcmp(q + m, p + 1))
		continue;	/* Tail mismatch */
	} else
	    /* Not wildcard */ if (*p != *q)
	    continue;		/* plain mismatch: go to next rule */

	if (!rule_cond_ok(r))	/* check condition, next rule if false - kw */
	    continue;
d191 1
a191 1
	switch (r->op) {	/* Perform operation */
d202 6
a207 6
		CTRACE((tfp, "HTRule: `%s' matched %s %s: `%s'\n",
			current,
			(r->op == HT_Protect ? "Protect" : "DefProt"),
			"rule, setup",
			(r->equiv ? r->equiv :
			 (r->op == HT_Protect ? "DEFAULT" : "NULL!!"))));
d228 4
a231 48
	case HT_UserMsg:	/* Produce message immediately */
	    LYFixCursesOn("show rule message:");
	    HTUserMsg2((r->equiv ? r->equiv : "Rule: %s"), current);
	    break;
	case HT_InfoMsg:	/* Produce messages immediately */
	case HT_Progress:
	case HT_Alert:
	    LYFixCursesOn("show rule message:");	/* and fall through */
	case HT_AlwaysAlert:
	    pMsg = r->equiv ? r->equiv :
		(r->op == HT_AlwaysAlert) ? "%s" : "Rule: %s";
	    if (strchr(pMsg, '%')) {
		HTSprintf0(&msgtmp, pMsg, current);
		pMsg = msgtmp;
	    }
	    switch (r->op) {	/* Actually produce message */
	    case HT_InfoMsg:
		HTInfoMsg(pMsg);
		break;
	    case HT_Progress:
		HTProgress(pMsg);
		break;
	    case HT_Alert:
		HTAlert(pMsg);
		break;
	    case HT_AlwaysAlert:
		HTAlwaysAlert("Rule alert:", pMsg);
		break;
	    default:
		break;
	    }
	    FREE(msgtmp);
	    break;

	case HT_PermitRedir:	/* Set special flag */
	    permitredir_flag = 1;
	    CTRACE((tfp, "HTRule: Mark for redirection permitted\n"));
	    break;

	case HT_Pass:		/* Authorised */
	    if (!r->equiv) {
		if (proxy_none_flag) {
		    char *temp = NULL;

		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
d233 1
a233 4
		CTRACE((tfp, "HTRule: Pass `%s'\n", current));
		return current;
	    }
	    /* Else fall through ...to map and pass */
d236 3
a238 5
	case HT_Redirect:
	case HT_RedirectPerm:
	    if (*p == *q) {	/* End of both strings, no wildcard */
		CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
		StrAllocCopy(current, r->equiv);	/* use entire translation */
d240 30
a269 34
		char *ins = strchr(r->equiv, '*');	/* Insertion point */

		if (ins) {	/* Consistent rule!!! */
		    char *temp = NULL;

		    HTSprintf0(&temp, "%.*s%.*s%s",
			       ins - r->equiv,
			       r->equiv,
			       m,
			       q,
			       ins + 1);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */

		} else {	/* No insertion point */
		    char *temp = NULL;

		    StrAllocCopy(temp, r->equiv);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */
		}		/* If no insertion point exists */
	    }
	    if (r->op == HT_Pass) {
		if (proxy_none_flag) {
		    char *temp = NULL;

		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
d271 1
a271 18
		CTRACE((tfp, "HTRule: ...and pass `%s'\n",
			current));
		return current;
	    } else if (r->op == HT_Redirect) {
		CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
			current));
		redirecting_url = current;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    } else if (r->op == HT_RedirectPerm) {
		CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
			current));
		redirecting_url = current;
		permanent_redirection = TRUE;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    }
	    break;
d273 7
a279 10
	case HT_UseProxy:
	    if (r->equiv && 0 == strcasecomp(r->equiv, "none")) {
		CTRACE((tfp, "For `%s' will not use proxy\n", current));
		proxy_none_flag = 1;
	    } else if (proxy_none_flag) {
		CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			current,
			NONNULL(r->equiv)));
	    } else {
		char *temp = NULL;
d281 1
a281 9
		StrAllocCopy(temp, "Proxied=");
		StrAllocCat(temp, r->equiv);
		StrAllocCat(temp, current);
		CTRACE((tfp, "HTRule: proxy server found: %s\n",
			NONNULL(r->equiv)));
		FREE(current);
		return temp;
	    }
	    break;
a282 17
	case HT_Invalid:
	case HT_Fail:		/* Unauthorised */
	    CTRACE((tfp, "HTRule: *** FAIL `%s'\n", current));
	    FREE(current);
	    return (char *) 0;
	}			/* if tail matches ... switch operation */

    }				/* loop over rules */

    if (proxy_none_flag) {
	char *temp = NULL;

	StrAllocCopy(temp, "NoProxy=");
	StrAllocCat(temp, current);
	FREE(current);
	return temp;
    }
d288 8
a295 7
 *	------------------------------
 *
 *	Call this, for example, to load a X resource with config info.
 *
 * returns	0 OK, < 0 syntax error.
 */
int HTSetConfiguration(char *config)
d298 3
a300 7
    char *line = NULL;
    char *pointer = line;
    char *word1;
    const char *word2;
    const char *word3;
    const char *cond_op = NULL;
    const char *cond = NULL;
d307 2
a308 4
	char *p = strchr(line, '#');	/* Chop off comments */

	if (p)
	    *p = 0;
d315 1
a315 1
    };				/* Comment only or blank */
d319 3
a321 3
    if (0 == strcasecomp(word1, "defprot") ||
	0 == strcasecomp(word1, "protect"))
	word3 = pointer;	/* The rest of the line to be parsed by AA module */
d328 1
a328 1
	return -2;		/*syntax error */
d331 7
a337 2
    if (0 == strcasecomp(word1, "suffix")) {
	char *encoding = HTNextField(&pointer);
d339 2
a340 11
	if (pointer)
	    status = sscanf(pointer, "%f", &quality);
	else
	    status = 0;
	HTSetSuffix(word2, word3,
		    encoding ? encoding : "binary",
		    status >= 1 ? quality : (float) 1.0);

    } else if (0 == strcasecomp(word1, "presentation")) {
	if (pointer)
	    status = sscanf(pointer, "%f%f%f%d",
d342 6
a347 8
	else
	    status = 0;
	HTSetPresentation(word2, word3, NULL,
			  status >= 1 ? quality : 1.0,
			  status >= 2 ? secs : 0.0,
			  status >= 3 ? secs_per_byte : 0.0,
			  status >= 4 ? maxbytes : 0,
			  mediaCFG);
d349 2
a350 2
    } else if (0 == strncasecomp(word1, "htbin", 5) ||
	       0 == strncasecomp(word1, "bindir", 6)) {
d353 1
a353 1
    } else if (0 == strncasecomp(word1, "search", 6)) {
d357 7
a363 17
	op = 0 == strcasecomp(word1, "map") ? HT_Map
	    : 0 == strcasecomp(word1, "pass") ? HT_Pass
	    : 0 == strcasecomp(word1, "fail") ? HT_Fail
	    : 0 == strcasecomp(word1, "redirect") ? HT_Redirect
	    : 0 == strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    : 0 == strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    : 0 == strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    : 0 == strcasecomp(word1, "useproxy") ? HT_UseProxy
	    : 0 == strcasecomp(word1, "alert") ? HT_Alert
	    : 0 == strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    : 0 == strcasecomp(word1, "progress") ? HT_Progress
	    : 0 == strcasecomp(word1, "usermsg") ? HT_UserMsg
	    : 0 == strcasecomp(word1, "infomsg") ? HT_InfoMsg
	    : 0 == strcasecomp(word1, "defprot") ? HT_DefProt
	    : 0 == strcasecomp(word1, "protect") ? HT_Protect
	    : HT_Invalid;
	if (op == HT_Invalid) {
d366 1
a366 102
	    switch (op) {
	    case HT_Fail:	/* never a or other 2nd parameter */
	    case HT_PermitRedir:
		cond_op = word3;
		if (cond_op && *cond_op) {
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		}
		break;

	    case HT_Pass:	/* possibly a URL2 */
		if (word3 && (!strcasecomp(word3, "if") ||
			      !strcasecomp(word3, "unless"))) {
		    cond_op = word3;
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		    break;
		}
		/* else fall through */
	    case HT_Map:	/* always a URL2 (or other 2nd parameter) */
	    case HT_Redirect:
	    case HT_RedirectPerm:
	    case HT_UseProxy:
		cond_op = HTNextField(&pointer);
		/* check for extra status word in "Redirect" */
		if (op == HT_Redirect && 0 == strcasecomp(word1, "redirect") &&
		    cond_op &&
		    strcasecomp(cond_op, "if") &&
		    strcasecomp(cond_op, "unless")) {
		    if (0 == strcmp(word2, "301") ||
			0 == strcasecomp(word2, "permanent")) {
			op = HT_RedirectPerm;
		    } else if (!(0 == strcmp(word2, "302") ||
				 0 == strcmp(word2, "303") ||
				 0 == strcasecomp(word2, "temp") ||
				 0 == strcasecomp(word2, "seeother"))) {
			CTRACE((tfp, "Rule: Ignoring `%s' in Redirect\n", word2));
		    }
		    word2 = word3;
		    word3 = cond_op;	/* cond_op isn't condition op after all */
		    cond_op = HTNextField(&pointer);
		}
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		break;

	    case HT_Progress:
	    case HT_InfoMsg:
	    case HT_UserMsg:
	    case HT_Alert:
	    case HT_AlwaysAlert:
		cond_op = HTNextField(&pointer);
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		if (word3) {	/* Fix string with too may %s - kw */
		    const char *cp = word3;
		    char *cp1, *cp2;

		    while ((cp1 = strchr(cp, '%'))) {
			if (cp1[1] == '\0') {
			    *cp1 = '\0';
			    break;
			} else if (cp1[1] == '%') {
			    cp = cp1 + 2;
			    continue;
			} else
			    while ((cp2 = strchr(cp1 + 2, '%'))) {
				if (cp2[1] == '\0') {
				    *cp2 = '\0';
				    break;
				} else if (cp2[1] == '%') {
				    cp1 = cp2;
				} else {
				    *cp2 = '?';		/* replace bad % */
				    cp1 = cp2;
				}
			    }
			break;
		    }
		}
		break;

	    default:
		break;
	    }
	    if (cond_op && cond && *cond && !strcasecomp(cond_op, "unless")) {
		cond_op = "unless";
	    } else if (cond_op && cond && *cond &&
		       !strcasecomp(cond_op, "if")) {
		cond_op = "if";
	    } else if (cond_op || cond) {
		fprintf(stderr, "HTRule: %s '%s'\n", RULE_INCORRECT, config);
		FREE(line);	/* syntax error, condition is a mess - kw */
		return -2;	/* NB unrecognized cond passes here - kw */
	    }
	    if (cond && !strncasecomp(cond, "redirected", strlen(cond))) {
		cond = "redirected";	/* recognized, canonical case - kw */
	    } else if (cond && strlen(cond) >= 8 &&
		       !strncasecomp(cond, "userspecified", strlen(cond))) {
		cond = "userspec";	/* also allow abbreviation - kw */
	    }
	    HTAddRule(op, word2, word3, cond_op, cond);
d373 1
d375 12
a386 12
 *	--------------------------
 *
 * On entry,
 *	Rules can be in any state
 * On exit,
 *	Any existing rules will have been kept.
 *	Any new rules will have been loaded.
 *	Returns		0 if no error, 0 if error!
 *
 * Bugs:
 *	The strings may not contain spaces.
 */
d388 2
a389 1
int HTLoadRules(const char *filename)
d391 2
a392 2
    FILE *fp = fopen(filename, TXT_R);
    char line[LINE_LENGTH + 1];
d395 2
a396 2
	CTRACE((tfp, "HTRules: Can't open rules file %s\n", filename));
	return -1;		/* File open error */
d398 2
a399 3
    for (;;) {
	if (!fgets(line, LINE_LENGTH + 1, fp))
	    break;		/* EOF or error */
d403 1
a403 1
    return 0;			/* No error or syntax errors ignored */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a17 1
**	25 May 99  KW	Added redirect for lynx.
a37 2
	char *		condition_op; /* as strings - may be inefficient, */
	char *		condition;    /* but this is not for a server - kw */
a41 5
#include <HTTP.h> /* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h> /* for LYUserSpecifiedURL - kw */
#include <LYUtils.h>		/* for LYFixCursesOn - kw */
#include <HTAlert.h>

d64 1
a64 1
**	pattern		points to 0-terminated string containing a single "*"
d68 1
a68 1
**	returns		0 if success, -1 if error.
d71 1
a71 1
PUBLIC int HTAddRule ARGS5(
d74 1
a74 3
    CONST char *,	equiv,
    CONST char *,	cond_op,
    CONST char *,	cond)
d77 1
a77 1
    char *	pPattern = NULL;
d79 1
a79 1
    temp = typecalloc(rule);
d82 3
d86 3
a88 2
	char *	pEquiv = NULL;
	StrAllocCopy(pEquiv, equiv);
d90 1
a93 5
    if (cond_op) {
	StrAllocCopy(temp->condition_op, cond_op);
	StrAllocCopy(temp->condition, cond);
    }
    StrAllocCopy(pPattern, pattern);
d97 1
d99 1
a99 1
	CTRACE((tfp, "Rule: For `%s' op %d `%s'", pattern, op, equiv));
d101 1
a101 6
	CTRACE((tfp, "Rule: For `%s' op %d", pattern, op));
    }
    if (cond_op) {
	CTRACE((tfp, "\t%s %s\n", cond_op, NONNULL(cond)));
    } else {
	CTRACE((tfp, "\n"));
d124 1
a124 1
/*	Clear all rules						HTClearRules()
a139 2
	FREE(temp->condition_op);
	FREE(temp->condition);
a146 24
PRIVATE BOOL rule_cond_ok ARGS1(
    rule *,	 r)
{
    BOOL result;
    if (!r->condition_op)
	return YES;
    if (strcmp(r->condition_op, "if") && strcmp(r->condition_op, "unless")) {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s'!\n",
	       r->condition_op));
	return NO;
    }
    if (!strcmp(r->condition, "redirected"))
	result = (BOOL) (redirection_attempts > 0);
    else if (!strcmp(r->condition, "userspec"))
	result = LYUserSpecifiedURL;
    else {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s %s'!\n",
	       r->condition_op, NONNULL(r->condition)));
	return NO;
    }
    if (!strcmp(r->condition_op, "if"))
	return result;
    else
	return (BOOL) (!result);
a147 1
}
d154 1
a154 1
**	required	points to a string whose equivalent value is needed
d156 1
a156 1
**	returns		the address of the equivalent string allocated from
d158 1
a158 1
**			occurred, then it is a copy of the original.
d160 1
a160 1
**			When a "protect" or "defprot" rule is matched,
a171 4
    char *msgtmp = NULL, *pMsg;
    int proxy_none_flag = 0;
    int permitredir_flag = 0;

a190 3
	if (!rule_cond_ok(r))	/* check condition, next rule if false - kw */
	    continue;

d202 1
a202 1
		CTRACE((tfp, "HTRule: `%s' matched %s %s: `%s'\n",
d207 1
a207 1
			     (r->op==HT_Protect ?"DEFAULT" :"NULL!!"))));
a227 30
	case HT_UserMsg:		/* Produce message immediately */
	    LYFixCursesOn("show rule message:");
	    HTUserMsg2((r->equiv ? r->equiv : "Rule: %s"), current);
	    break;
	case HT_InfoMsg:		/* Produce messages immediately */
	case HT_Progress:
	case HT_Alert:
	    LYFixCursesOn("show rule message:"); /* and fall through */
	case HT_AlwaysAlert:
	    pMsg = r->equiv ? r->equiv :
		(r->op==HT_AlwaysAlert) ? "%s" : "Rule: %s";
	    if (strchr(pMsg, '%')) {
		HTSprintf0(&msgtmp, pMsg, current);
		pMsg = msgtmp;
	    }
	    switch (r->op) {		/* Actually produce message */
	    case HT_InfoMsg:	HTInfoMsg(pMsg);	break;
	    case HT_Progress:	HTProgress(pMsg);	break;
	    case HT_Alert:	HTAlert(pMsg);		break;
	    case HT_AlwaysAlert: HTAlwaysAlert("Rule alert:", pMsg);	break;
	    default: break;
	    }
	    FREE(msgtmp);
	    break;

	case HT_PermitRedir:			/* Set special flag */
	    permitredir_flag = 1;
	    CTRACE((tfp, "HTRule: Mark for redirection permitted\n"));
	    break;

d229 3
a231 7
	    if (!r->equiv) {
		if (proxy_none_flag) {
		    char * temp = NULL;
		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
d233 1
a233 4
		CTRACE((tfp, "HTRule: Pass `%s'\n", current));
		return current;
	    }
	    /* Else fall through ...to map and pass */
a235 2
	case HT_Redirect:
	case HT_RedirectPerm:
d237 1
a237 1
		  CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
d242 10
a251 10
			char * temp = NULL;

			HTSprintf0(&temp, "%.*s%.*s%s",
				   ins - r->equiv,
				   r->equiv,
				   m,
				   q,
				   ins + 1);
			CTRACE((tfp, "For `%s' using `%s'\n",
				    current, temp));
d253 1
a253 1
			current = temp;			/* Use this */
d256 6
a261 5
			char * temp = NULL;

			StrAllocCopy(temp, r->equiv);
			CTRACE((tfp, "For `%s' using `%s'\n",
						current, temp));
d263 1
a263 1
			current = temp;			/* Use this */
d267 2
a268 9
		    if (proxy_none_flag) {
			char * temp = NULL;
			StrAllocCopy(temp, "NoProxy=");
			StrAllocCat(temp, current);
			FREE(current);
			current = temp;
		    }
		    CTRACE((tfp, "HTRule: ...and pass `%s'\n",
				current));
a269 33
		} else if (r->op == HT_Redirect) {
		    CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
				current));
		    redirecting_url = current;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		} else if (r->op == HT_RedirectPerm) {
		    CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
				current));
		    redirecting_url = current;
		    permanent_redirection = TRUE;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		}
		break;

	case HT_UseProxy:
		if (r->equiv && 0==strcasecomp(r->equiv, "none")) {
		    CTRACE((tfp, "For `%s' will not use proxy\n", current));
		    proxy_none_flag = 1;
		} else if (proxy_none_flag) {
		    CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			   current,
			   NONNULL(r->equiv)));
		} else {
		    char * temp = NULL;
		    StrAllocCopy(temp, "Proxied=");
		    StrAllocCat(temp, r->equiv);
		    StrAllocCat(temp, current);
		    CTRACE((tfp, "HTRule: proxy server found: %s\n",
			   NONNULL(r->equiv)));
		    FREE(current);
		    return temp;
d275 2
a276 1
		CTRACE((tfp, "HTRule: *** FAIL `%s'\n", current));
a282 7
    if (proxy_none_flag) {
	char * temp = NULL;
	StrAllocCopy(temp, "NoProxy=");
	StrAllocCat(temp, current);
	FREE(current);
	return temp;
    }
a300 1
    char *cond_op=NULL, *cond=NULL;
d337 1
a337 1
				status >= 1? quality : (float) 1.0);
d344 1
a344 1
		    status >= 1 ? quality		: 1.0,
d346 1
a346 1
		    status >= 3 ? secs_per_byte		: 0.0,
a359 10
	    :	0==strcasecomp(word1, "redirect") ? HT_Redirect
	    :	0==strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    :	0==strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    :	0==strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    :	0==strcasecomp(word1, "useproxy") ? HT_UseProxy
	    :	0==strcasecomp(word1, "alert") ? HT_Alert
	    :	0==strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    :	0==strcasecomp(word1, "progress") ? HT_Progress
	    :	0==strcasecomp(word1, "usermsg") ? HT_UserMsg
	    :	0==strcasecomp(word1, "infomsg") ? HT_InfoMsg
d366 1
a366 99
	    switch (op) {
	    case HT_Fail:	/* never a or other 2nd parameter */
	    case HT_PermitRedir:
		cond_op = word3;
		if (cond_op && *cond_op) {
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		}
		break;

	    case HT_Pass:	/* possibly a URL2 */
		if (word3 && (!strcasecomp(word3, "if") ||
			      !strcasecomp(word3, "unless"))) {
		    cond_op = word3;
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		    break;
		} /* else fall through */

	    case HT_Map:	/* always a URL2 (or other 2nd parameter) */
	    case HT_Redirect:
	    case HT_RedirectPerm:
	    case HT_UseProxy:
		cond_op = HTNextField(&pointer);
		/* check for extra status word in "Redirect" */
		if (op==HT_Redirect && 0==strcasecomp(word1, "redirect") &&
		    cond_op &&
		    strcasecomp(cond_op, "if") &&
		    strcasecomp(cond_op, "unless")) {
		    if (0==strcmp(word2, "301") ||
			0==strcasecomp(word2, "permanent")) {
			op = HT_RedirectPerm;
		    } else if (!(0==strcmp(word2, "302") ||
				 0==strcmp(word2, "303") ||
				 0==strcasecomp(word2, "temp") ||
				 0==strcasecomp(word2, "seeother"))) {
			CTRACE((tfp, "Rule: Ignoring `%s' in Redirect\n", word2));
		    }
		    word2 = word3;
		    word3 = cond_op; /* cond_op isn't condition op after all */
		    cond_op = HTNextField(&pointer);
		}
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		break;

	    case HT_Progress:
	    case HT_InfoMsg:
	    case HT_UserMsg:
	    case HT_Alert:
	    case HT_AlwaysAlert:
		cond_op = HTNextField(&pointer);
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		if (word3) {	/* Fix string with too may %s - kw */
		    char *cp = word3, *cp1, *cp2;
		    while ((cp1=strchr(cp, '%'))) {
			if (cp1[1] == '\0') {
			    *cp1 = '\0';
			    break;
			} else if (cp1[1] == '%') {
			    cp = cp1 + 2;
			    continue;
			} else while ((cp2=strchr(cp1+2, '%'))) {
			    if (cp2[1] == '\0') {
				*cp2 = '\0';
				break;
			    } else if (cp2[1] == '%') {
				cp1 = cp2;
			    } else {
				*cp2 = '?'; /* replace bad % */
				cp1 = cp2;
			    }
			}
			break;
		    }
		}
		break;

		default:
		break;
	    }
	    if (cond_op && cond && *cond && !strcasecomp(cond_op, "unless")) {
		cond_op = "unless";
	    } else if (cond_op && cond && *cond &&
		       !strcasecomp(cond_op, "if")) {
		cond_op = "if";
	    } else if (cond_op || cond) {
		fprintf(stderr, "HTRule: %s '%s'\n", RULE_INCORRECT, config);
		FREE(line);	/* syntax error, condition is a mess - kw */
		return -2;	/* NB unrecognized cond passes here - kw */
	    }
	    if (cond && !strncasecomp(cond, "redirected", strlen(cond))) {
		cond = "redirected"; /* recognized, canonical case - kw */
	    } else if (cond && strlen(cond) >= 8 &&
		!strncasecomp(cond, "userspecified", strlen(cond))) {
		cond = "userspec"; /* also allow abbreviation - kw */
	    }
	    HTAddRule(op, word2, word3, cond_op, cond);
d382 1
a382 1
**	Returns		0 if no error, 0 if error!
d391 1
a391 1
    FILE * fp = fopen(filename, TXT_R);
d395 1
a395 1
	CTRACE((tfp, "HTRules: Can't open rules file %s\n", filename));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d53 1
a53 1
char *HTBinDir = NULL;	/* Physical /htbin directory path.	*/
d55 1
a55 1
char *HTSearchScript = NULL;	/* Search script name.		*/
d62 1
a62 1
static rule * rules = 0;	/* Pointer to first on list */
d64 1
a64 1
static rule * rule_tail = 0;	/* Pointer to last on list */
d79 6
a84 6
int HTAddRule (
    HTRuleOp		op,
    const char *	pattern,
    const char *	equiv,
    const char *	cond_op,
    const char *	cond)
d147 1
a147 1
void HTClearRules (void)
d163 2
a164 2
static BOOL rule_cond_ok (
    rule *	 r)
d208 2
a209 2
char * HTTranslate (
    const char *	required)
d224 1
a224 1
	const char * q = current;
d426 2
a427 2
int  HTSetConfiguration (
    char *		config)
d629 2
a630 2
int HTLoadRules (
    const char *	filename)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 19
a20 19
 *	==========================================
 *
 *
 * History:
 *	 3 Jun 91	Written TBL
 *	10 Aug 91	Authorisation added after Daniel Martin (pass, fail)
 *			Rule order in file changed
 *			Comments allowed with # on 1st char of rule line
 *	17 Jun 92	Bug fix: pass and fail failed if didn't contain '*' TBL
 *	 1 Sep 93	Bug fix: no memory check - Nathan Torkington
 *			BYTE_ADDRESSING removed - Arthur Secret
 *	11 Sep 93  MD	Changed %i into %d in debug printf.
 *			VMS does not recognize %i.
 *			Bug Fix: in case of PASS, only one parameter to printf.
 *	19 Sep 93  AL	Added Access Authorization stuff.
 *	 1 Nov 93  AL	Added htbin.
 *	25 May 99  KW	Added redirect for lynx.
 *
 */
d33 1
d35 6
a40 6
    struct _rule *next;
    HTRuleOp op;
    char *pattern;
    char *equiv;
    char *condition_op;		/* as strings - may be inefficient, */
    char *condition;		/* but this is not for a server - kw */
d45 2
a46 2
#include <HTTP.h>		/* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h>	/* for LYUserSpecifiedURL - kw */
d51 5
a55 3
 *	----------------
 */
char *HTBinDir = NULL;		/* Physical /htbin directory path.      */
a56 2
				/* In future this should not be global. */
char *HTSearchScript = NULL;	/* Search script name.          */
d59 2
a60 4
 *	---------------------
 */

static rule *rules = 0;		/* Pointer to first on list */
d62 1
d64 1
a64 1
static rule *rule_tail = 0;	/* Pointer to last on list */
d67 1
d69 19
a87 17
 *	--------------------
 *
 *  On entry,
 *	pattern		points to 0-terminated string containing a single "*"
 *	equiv		points to the equivalent string with * for the
 *			place where the text matched by * goes.
 *  On exit,
 *	returns		0 if success, -1 if error.
 */

int HTAddRule(HTRuleOp op, const char *pattern,
	      const char *equiv,
	      const char *cond_op,
	      const char *cond)
{				/* BYTE_ADDRESSING removed and memory check - AS - 1 Sep 93 */
    rule *temp;
    char *pPattern = NULL;
d90 1
a90 1
    if (temp == NULL)
d93 1
a93 2
	char *pEquiv = NULL;

d128 2
a129 4
    if (rule_tail)
	rule_tail->next = temp;
    else
	rules = temp;
d133 1
d137 1
d139 9
a147 9
 *	---------------
 *
 * On exit,
 *	There are no rules
 *
 * See also
 *	HTAddRule()
 */
void HTClearRules(void)
d150 1
a150 2
	rule *temp = rules;

d163 2
a164 1
static BOOL rule_cond_ok(rule * r)
a166 1

d171 1
a171 1
		r->condition_op));
d180 1
a180 1
		r->condition_op, NONNULL(r->condition)));
a188 1

d190 20
a209 19
 *	------------------
 *
 *	The most recently defined rules are applied first.
 *
 * On entry,
 *	required	points to a string whose equivalent value is needed
 * On exit,
 *	returns		the address of the equivalent string allocated from
 *			the heap which the CALLER MUST FREE. If no translation
 *			occurred, then it is a copy of the original.
 * NEW FEATURES:
 *			When a "protect" or "defprot" rule is matched,
 *			a call to HTAA_setCurrentProtection() or
 *			HTAA_setDefaultProtection() is made to notify
 *			the Access Authorization module that the file is
 *			protected, and so it knows how to handle it.
 *								-- AL
 */
char *HTTranslate(const char *required)
d211 1
a211 1
    rule *r;
d221 6
a226 8
    for (r = rules; r; r = r->next) {
	char *p = r->pattern;
	int m = 0;		/* Number of characters matched against wildcard */
	const char *q = current;

	for (; *p && *q; p++, q++) {	/* Find first mismatch */
	    if (*p != *q)
		break;
d229 6
a234 9
	if (*p == '*') {	/* Match up to wildcard */
	    m = strlen(q) - strlen(p + 1);	/* Amount to match to wildcard */
	    if (m < 0)
		continue;	/* tail is too short to match */
	    if (0 != strcmp(q + m, p + 1))
		continue;	/* Tail mismatch */
	} else
	    /* Not wildcard */ if (*p != *q)
	    continue;		/* plain mismatch: go to next rule */
d239 1
a239 1
	switch (r->op) {	/* Perform operation */
d251 5
a255 5
			current,
			(r->op == HT_Protect ? "Protect" : "DefProt"),
			"rule, setup",
			(r->equiv ? r->equiv :
			 (r->op == HT_Protect ? "DEFAULT" : "NULL!!"))));
d276 1
a276 1
	case HT_UserMsg:	/* Produce message immediately */
d280 1
a280 1
	case HT_InfoMsg:	/* Produce messages immediately */
d283 1
a283 1
	    LYFixCursesOn("show rule message:");	/* and fall through */
d286 1
a286 1
		(r->op == HT_AlwaysAlert) ? "%s" : "Rule: %s";
d291 6
a296 15
	    switch (r->op) {	/* Actually produce message */
	    case HT_InfoMsg:
		HTInfoMsg(pMsg);
		break;
	    case HT_Progress:
		HTProgress(pMsg);
		break;
	    case HT_Alert:
		HTAlert(pMsg);
		break;
	    case HT_AlwaysAlert:
		HTAlwaysAlert("Rule alert:", pMsg);
		break;
	    default:
		break;
d301 1
a301 1
	case HT_PermitRedir:	/* Set special flag */
d306 1
a306 1
	case HT_Pass:		/* Authorised */
d309 1
a309 2
		    char *temp = NULL;

d323 3
a325 3
	    if (*p == *q) {	/* End of both strings, no wildcard */
		CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
		StrAllocCopy(current, r->equiv);	/* use entire translation */
d327 51
a377 1
		char *ins = strchr(r->equiv, '*');	/* Insertion point */
d379 12
a390 29
		if (ins) {	/* Consistent rule!!! */
		    char *temp = NULL;

		    HTSprintf0(&temp, "%.*s%.*s%s",
			       ins - r->equiv,
			       r->equiv,
			       m,
			       q,
			       ins + 1);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */

		} else {	/* No insertion point */
		    char *temp = NULL;

		    StrAllocCopy(temp, r->equiv);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */
		}		/* If no insertion point exists */
	    }
	    if (r->op == HT_Pass) {
		if (proxy_none_flag) {
		    char *temp = NULL;

		    StrAllocCopy(temp, "NoProxy=");
d392 2
d395 1
a395 1
		    current = temp;
d397 1
a397 18
		CTRACE((tfp, "HTRule: ...and pass `%s'\n",
			current));
		return current;
	    } else if (r->op == HT_Redirect) {
		CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
			current));
		redirecting_url = current;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    } else if (r->op == HT_RedirectPerm) {
		CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
			current));
		redirecting_url = current;
		permanent_redirection = TRUE;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    }
	    break;
d399 3
a401 16
	case HT_UseProxy:
	    if (r->equiv && 0 == strcasecomp(r->equiv, "none")) {
		CTRACE((tfp, "For `%s' will not use proxy\n", current));
		proxy_none_flag = 1;
	    } else if (proxy_none_flag) {
		CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			current,
			NONNULL(r->equiv)));
	    } else {
		char *temp = NULL;

		StrAllocCopy(temp, "Proxied=");
		StrAllocCat(temp, r->equiv);
		StrAllocCat(temp, current);
		CTRACE((tfp, "HTRule: proxy server found: %s\n",
			NONNULL(r->equiv)));
d403 2
a404 10
		return temp;
	    }
	    break;

	case HT_Invalid:
	case HT_Fail:		/* Unauthorised */
	    CTRACE((tfp, "HTRule: *** FAIL `%s'\n", current));
	    FREE(current);
	    return (char *) 0;
	}			/* if tail matches ... switch operation */
d406 1
a406 1
    }				/* loop over rules */
d409 1
a409 2
	char *temp = NULL;

d420 8
a427 7
 *	------------------------------
 *
 *	Call this, for example, to load a X resource with config info.
 *
 * returns	0 OK, < 0 syntax error.
 */
int HTSetConfiguration(char *config)
d430 2
a431 2
    char *line = NULL;
    char *pointer = line;
d433 1
a433 1
    char *cond_op = NULL, *cond = NULL;
d440 2
a441 4
	char *p = strchr(line, '#');	/* Chop off comments */

	if (p)
	    *p = 0;
d448 1
a448 1
    };				/* Comment only or blank */
d452 3
a454 3
    if (0 == strcasecomp(word1, "defprot") ||
	0 == strcasecomp(word1, "protect"))
	word3 = pointer;	/* The rest of the line to be parsed by AA module */
d461 1
a461 1
	return -2;		/*syntax error */
d464 7
a470 2
    if (0 == strcasecomp(word1, "suffix")) {
	char *encoding = HTNextField(&pointer);
d472 2
a473 11
	if (pointer)
	    status = sscanf(pointer, "%f", &quality);
	else
	    status = 0;
	HTSetSuffix(word2, word3,
		    encoding ? encoding : "binary",
		    status >= 1 ? quality : (float) 1.0);

    } else if (0 == strcasecomp(word1, "presentation")) {
	if (pointer)
	    status = sscanf(pointer, "%f%f%f%d",
d475 6
a480 8
	else
	    status = 0;
	HTSetPresentation(word2, word3, NULL,
			  status >= 1 ? quality : 1.0,
			  status >= 2 ? secs : 0.0,
			  status >= 3 ? secs_per_byte : 0.0,
			  status >= 4 ? maxbytes : 0,
			  mediaCFG);
d482 2
a483 2
    } else if (0 == strncasecomp(word1, "htbin", 5) ||
	       0 == strncasecomp(word1, "bindir", 6)) {
d486 1
a486 1
    } else if (0 == strncasecomp(word1, "search", 6)) {
d490 17
a506 17
	op = 0 == strcasecomp(word1, "map") ? HT_Map
	    : 0 == strcasecomp(word1, "pass") ? HT_Pass
	    : 0 == strcasecomp(word1, "fail") ? HT_Fail
	    : 0 == strcasecomp(word1, "redirect") ? HT_Redirect
	    : 0 == strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    : 0 == strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    : 0 == strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    : 0 == strcasecomp(word1, "useproxy") ? HT_UseProxy
	    : 0 == strcasecomp(word1, "alert") ? HT_Alert
	    : 0 == strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    : 0 == strcasecomp(word1, "progress") ? HT_Progress
	    : 0 == strcasecomp(word1, "usermsg") ? HT_UserMsg
	    : 0 == strcasecomp(word1, "infomsg") ? HT_InfoMsg
	    : 0 == strcasecomp(word1, "defprot") ? HT_DefProt
	    : 0 == strcasecomp(word1, "protect") ? HT_Protect
	    : HT_Invalid;
	if (op == HT_Invalid) {
d526 2
a527 2
		}
		/* else fall through */
d534 1
a534 1
		if (op == HT_Redirect && 0 == strcasecomp(word1, "redirect") &&
d538 2
a539 2
		    if (0 == strcmp(word2, "301") ||
			0 == strcasecomp(word2, "permanent")) {
d541 4
a544 4
		    } else if (!(0 == strcmp(word2, "302") ||
				 0 == strcmp(word2, "303") ||
				 0 == strcasecomp(word2, "temp") ||
				 0 == strcasecomp(word2, "seeother"))) {
d548 1
a548 1
		    word3 = cond_op;	/* cond_op isn't condition op after all */
d565 1
a565 2

		    while ((cp1 = strchr(cp, '%'))) {
d572 9
a580 11
			} else
			    while ((cp2 = strchr(cp1 + 2, '%'))) {
				if (cp2[1] == '\0') {
				    *cp2 = '\0';
				    break;
				} else if (cp2[1] == '%') {
				    cp1 = cp2;
				} else {
				    *cp2 = '?';		/* replace bad % */
				    cp1 = cp2;
				}
d582 1
d588 1
a588 1
	    default:
d602 1
a602 1
		cond = "redirected";	/* recognized, canonical case - kw */
d604 2
a605 2
		       !strncasecomp(cond, "userspecified", strlen(cond))) {
		cond = "userspec";	/* also allow abbreviation - kw */
d614 1
d616 12
a627 12
 *	--------------------------
 *
 * On entry,
 *	Rules can be in any state
 * On exit,
 *	Any existing rules will have been kept.
 *	Any new rules will have been loaded.
 *	Returns		0 if no error, 0 if error!
 *
 * Bugs:
 *	The strings may not contain spaces.
 */
d629 2
a630 1
int HTLoadRules(const char *filename)
d632 2
a633 2
    FILE *fp = fopen(filename, TXT_R);
    char line[LINE_LENGTH + 1];
d637 1
a637 1
	return -1;		/* File open error */
d639 2
a640 3
    for (;;) {
	if (!fgets(line, LINE_LENGTH + 1, fp))
	    break;		/* EOF or error */
d644 1
a644 1
    return 0;			/* No error or syntax errors ignored */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a17 1
**	25 May 99  KW	Added redirect for lynx.
a37 2
	char *		condition_op; /* as strings - may be inefficient, */
	char *		condition;    /* but this is not for a server - kw */
a41 5
#include <HTTP.h> /* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h> /* for LYUserSpecifiedURL - kw */
#include <LYUtils.h>		/* for LYFixCursesOn - kw */
#include <HTAlert.h>

d64 1
a64 1
**	pattern		points to 0-terminated string containing a single "*"
d68 1
a68 1
**	returns		0 if success, -1 if error.
d71 1
a71 1
PUBLIC int HTAddRule ARGS5(
d74 1
a74 3
    CONST char *,	equiv,
    CONST char *,	cond_op,
    CONST char *,	cond)
d77 1
a77 1
    char *	pPattern = NULL;
d79 1
a79 1
    temp = typecalloc(rule);
d82 3
d86 3
a88 2
	char *	pEquiv = NULL;
	StrAllocCopy(pEquiv, equiv);
d90 1
a93 5
    if (cond_op) {
	StrAllocCopy(temp->condition_op, cond_op);
	StrAllocCopy(temp->condition, cond);
    }
    StrAllocCopy(pPattern, pattern);
d97 1
d99 1
a99 6
	CTRACE((tfp, "Rule: For `%s' op %d `%s'", pattern, op, equiv));
    } else {
	CTRACE((tfp, "Rule: For `%s' op %d", pattern, op));
    }
    if (cond_op) {
	CTRACE((tfp, "\t%s %s\n", cond_op, NONNULL(cond)));
d101 1
a101 1
	CTRACE((tfp, "\n"));
d124 1
a124 1
/*	Clear all rules						HTClearRules()
a139 2
	FREE(temp->condition_op);
	FREE(temp->condition);
a146 24
PRIVATE BOOL rule_cond_ok ARGS1(
    rule *,	 r)
{
    BOOL result;
    if (!r->condition_op)
	return YES;
    if (strcmp(r->condition_op, "if") && strcmp(r->condition_op, "unless")) {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s'!\n",
	       r->condition_op));
	return NO;
    }
    if (!strcmp(r->condition, "redirected"))
	result = (BOOL) (redirection_attempts > 0);
    else if (!strcmp(r->condition, "userspec"))
	result = LYUserSpecifiedURL;
    else {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s %s'!\n",
	       r->condition_op, NONNULL(r->condition)));
	return NO;
    }
    if (!strcmp(r->condition_op, "if"))
	return result;
    else
	return (BOOL) (!result);
a147 1
}
d156 1
a156 1
**	returns		the address of the equivalent string allocated from
a171 3
    char *msgtmp = NULL, *pMsg;
    int proxy_none_flag = 0;
    int permitredir_flag = 0;
a190 3
	if (!rule_cond_ok(r))	/* check condition, next rule if false - kw */
	    continue;

d202 1
a202 1
		CTRACE((tfp, "HTRule: `%s' matched %s %s: `%s'\n",
d207 1
a207 1
			     (r->op==HT_Protect ?"DEFAULT" :"NULL!!"))));
a227 30
	case HT_UserMsg:		/* Produce message immediately */
	    LYFixCursesOn("show rule message:");
	    HTUserMsg2((r->equiv ? r->equiv : "Rule: %s"), current);
	    break;
	case HT_InfoMsg:		/* Produce messages immediately */
	case HT_Progress:
	case HT_Alert:
	    LYFixCursesOn("show rule message:"); /* and fall through */
	case HT_AlwaysAlert:
	    pMsg = r->equiv ? r->equiv :
		(r->op==HT_AlwaysAlert) ? "%s" : "Rule: %s";
	    if (strchr(pMsg, '%')) {
		HTSprintf0(&msgtmp, pMsg, current);
		pMsg = msgtmp;
	    }
	    switch (r->op) {		/* Actually produce message */
	    case HT_InfoMsg:	HTInfoMsg(pMsg);	break;
	    case HT_Progress:	HTProgress(pMsg);	break;
	    case HT_Alert:	HTAlert(pMsg);		break;
	    case HT_AlwaysAlert: HTAlwaysAlert("Rule alert:", pMsg);	break;
	    default: break;
	    }
	    FREE(msgtmp);
	    break;

	case HT_PermitRedir:			/* Set special flag */
	    permitredir_flag = 1;
	    CTRACE((tfp, "HTRule: Mark for redirection permitted\n"));
	    break;

d229 3
a231 7
	    if (!r->equiv) {
		if (proxy_none_flag) {
		    char * temp = NULL;
		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
d233 1
a233 4
		CTRACE((tfp, "HTRule: Pass `%s'\n", current));
		return current;
	    }
	    /* Else fall through ...to map and pass */
a235 2
	case HT_Redirect:
	case HT_RedirectPerm:
d237 1
a237 1
		  CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
d242 10
a251 10
			char * temp = NULL;

			HTSprintf0(&temp, "%.*s%.*s%s",
				   ins - r->equiv,
				   r->equiv,
				   m,
				   q,
				   ins + 1);
			CTRACE((tfp, "For `%s' using `%s'\n",
				    current, temp));
d253 1
a253 1
			current = temp;			/* Use this */
d256 6
a261 5
			char * temp = NULL;

			StrAllocCopy(temp, r->equiv);
			CTRACE((tfp, "For `%s' using `%s'\n",
						current, temp));
d263 1
a263 1
			current = temp;			/* Use this */
d267 2
a268 9
		    if (proxy_none_flag) {
			char * temp = NULL;
			StrAllocCopy(temp, "NoProxy=");
			StrAllocCat(temp, current);
			FREE(current);
			current = temp;
		    }
		    CTRACE((tfp, "HTRule: ...and pass `%s'\n",
				current));
a269 33
		} else if (r->op == HT_Redirect) {
		    CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
				current));
		    redirecting_url = current;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		} else if (r->op == HT_RedirectPerm) {
		    CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
				current));
		    redirecting_url = current;
		    permanent_redirection = TRUE;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		}
		break;

	case HT_UseProxy:
		if (r->equiv && 0==strcasecomp(r->equiv, "none")) {
		    CTRACE((tfp, "For `%s' will not use proxy\n", current));
		    proxy_none_flag = 1;
		} else if (proxy_none_flag) {
		    CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			   current,
			   NONNULL(r->equiv)));
		} else {
		    char * temp = NULL;
		    StrAllocCopy(temp, "Proxied=");
		    StrAllocCat(temp, r->equiv);
		    StrAllocCat(temp, current);
		    CTRACE((tfp, "HTRule: proxy server found: %s\n",
			   NONNULL(r->equiv)));
		    FREE(current);
		    return temp;
d275 2
a276 2
		CTRACE((tfp, "HTRule: *** FAIL `%s'\n",
			    current));
a282 6
    if (proxy_none_flag) {
	char * temp = NULL;
	StrAllocCopy(temp, "NoProxy=");
	StrAllocCat(temp, current);
	return temp;
    }
a300 1
    char *cond_op=NULL, *cond=NULL;
d337 1
a337 1
				status >= 1? quality : (float) 1.0);
d344 1
a344 1
		    status >= 1 ? quality		: 1.0,
d346 1
a346 1
		    status >= 3 ? secs_per_byte		: 0.0,
a359 10
	    :	0==strcasecomp(word1, "redirect") ? HT_Redirect
	    :	0==strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    :	0==strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    :	0==strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    :	0==strcasecomp(word1, "useproxy") ? HT_UseProxy
	    :	0==strcasecomp(word1, "alert") ? HT_Alert
	    :	0==strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    :	0==strcasecomp(word1, "progress") ? HT_Progress
	    :	0==strcasecomp(word1, "usermsg") ? HT_UserMsg
	    :	0==strcasecomp(word1, "infomsg") ? HT_InfoMsg
d366 1
a366 99
	    switch (op) {
	    case HT_Fail:	/* never a or other 2nd parameter */
	    case HT_PermitRedir:
		cond_op = word3;
		if (cond_op && *cond_op) {
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		}
		break;

	    case HT_Pass:	/* possibly a URL2 */
		if (word3 && (!strcasecomp(word3, "if") ||
			      !strcasecomp(word3, "unless"))) {
		    cond_op = word3;
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		    break;
		} /* else fall through */

	    case HT_Map:	/* always a URL2 (or other 2nd parameter) */
	    case HT_Redirect:
	    case HT_RedirectPerm:
	    case HT_UseProxy:
		cond_op = HTNextField(&pointer);
		/* check for extra status word in "Redirect" */
		if (op==HT_Redirect && 0==strcasecomp(word1, "redirect") &&
		    cond_op &&
		    strcasecomp(cond_op, "if") &&
		    strcasecomp(cond_op, "unless")) {
		    if (0==strcmp(word2, "301") ||
			0==strcasecomp(word2, "permanent")) {
			op = HT_RedirectPerm;
		    } else if (!(0==strcmp(word2, "302") ||
				 0==strcmp(word2, "303") ||
				 0==strcasecomp(word2, "temp") ||
				 0==strcasecomp(word2, "seeother"))) {
			CTRACE((tfp, "Rule: Ignoring `%s' in Redirect\n", word2));
		    }
		    word2 = word3;
		    word3 = cond_op; /* cond_op isn't condition op after all */
		    cond_op = HTNextField(&pointer);
		}
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		break;

	    case HT_Progress:
	    case HT_InfoMsg:
	    case HT_UserMsg:
	    case HT_Alert:
	    case HT_AlwaysAlert:
		cond_op = HTNextField(&pointer);
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		if (word3) {	/* Fix string with too may %s - kw */
		    char *cp = word3, *cp1, *cp2;
		    while ((cp1=strchr(cp, '%'))) {
			if (cp1[1] == '\0') {
			    *cp1 = '\0';
			    break;
			} else if (cp1[1] == '%') {
			    cp = cp1 + 2;
			    continue;
			} else while ((cp2=strchr(cp1+2, '%'))) {
			    if (cp2[1] == '\0') {
				*cp2 = '\0';
				break;
			    } else if (cp2[1] == '%') {
				cp1 = cp2;
			    } else {
				*cp2 = '?'; /* replace bad % */
				cp1 = cp2;
			    }
			}
			break;
		    }
		}
		break;

		default:
		break;
	    }
	    if (cond_op && cond && *cond && !strcasecomp(cond_op, "unless")) {
		cond_op = "unless";
	    } else if (cond_op && cond && *cond &&
		       !strcasecomp(cond_op, "if")) {
		cond_op = "if";
	    } else if (cond_op || cond) {
		fprintf(stderr, "HTRule: %s '%s'\n", RULE_INCORRECT, config);
		FREE(line);	/* syntax error, condition is a mess - kw */
		return -2;	/* NB unrecognized cond passes here - kw */
	    }
	    if (cond && !strncasecomp(cond, "redirected", strlen(cond))) {
		cond = "redirected"; /* recognized, canonical case - kw */
	    } else if (cond && strlen(cond) >= 8 &&
		!strncasecomp(cond, "userspecified", strlen(cond))) {
		cond = "userspec"; /* also allow abbreviation - kw */
	    }
	    HTAddRule(op, word2, word3, cond_op, cond);
d382 1
a382 1
**	Returns		0 if no error, 0 if error!
d391 1
a391 1
    FILE * fp = fopen(filename, TXT_R);
d395 1
a395 1
	CTRACE((tfp, "HTRules: Can't open rules file %s\n", filename));
@

