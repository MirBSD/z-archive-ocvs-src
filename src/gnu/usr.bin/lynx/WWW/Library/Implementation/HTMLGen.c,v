head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.4
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.2
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.10.11.20.30.35;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.36;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.27;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.01;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.59;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.33;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.50;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.15;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.47.12;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.11.20.16.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@automatic merge; regen configure
@
text
@/*		HTML Generator
 *		==============
 *
 *	This version of the HTML object sends HTML markup to the output stream.
 *
 * Bugs:	Line wrapping is not done at all.
 *		All data handled as PCDATA.
 *		Should convert old XMP, LISTING and PLAINTEXT to PRE.
 *
 *	It is not obvious to me right now whether the HEAD should be generated
 *	from the incomming data or the anchor.	Currently it is from the former
 *	which is cleanest.
 */

#include <HTUtils.h>

#define BUFFER_SIZE    200	/* Line buffer attempts to make neat breaks */
#define MAX_CLEANNESS	20

/* Implements:
*/
#include <HTMLGen.h>

#include <HTMLDTD.h>
#include <HTStream.h>
#include <SGML.h>
#include <HTFormat.h>

#ifdef USE_COLOR_STYLE
#include <LYCharUtils.h>
#include <AttrList.h>
#include <LYHash.h>
#include <LYStyle.h>
#endif

#include <LYGlobalDefs.h>
#include <LYCurses.h>
#include <LYLeaks.h>

#define PUTC(c) (*me->targetClass.put_character)(me->target, c)
/* #define PUTS(s) (*me->targetClass.put_string)(me->target, s) */
#define PUTB(s,l) (*me->targetClass.put_block)(me->target, s, l)

#ifdef USE_COLOR_STYLE
char class_string[TEMPSTRINGSIZE];

static char *Style_className = NULL;
static char myHash[128];
static int hcode;
#endif

/*		HTML Object
 *		-----------
 */
struct _HTStream {
    const HTStreamClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */
};

struct _HTStructured {
    const HTStructuredClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */

    char buffer[BUFFER_SIZE + 1];	/* 1for NL */
    int buffer_maxchars;
    char *write_pointer;
    char *line_break[MAX_CLEANNESS + 1];
    int cleanness;
    BOOL overflowed;
    BOOL delete_line_break_char[MAX_CLEANNESS + 1];
    BOOL preformatted;
    BOOL escape_specials;
    BOOL in_attrval;
#ifdef USE_COLOR_STYLE
    HText *text;
#endif
};

/*	Flush Buffer
 *	------------
 */

static void flush_breaks(HTStructured * me)
{
    int i;

    for (i = 0; i <= MAX_CLEANNESS; i++) {
	me->line_break[i] = NULL;
    }
}

static void HTMLGen_flush(HTStructured * me)
{
    (*me->targetClass.put_block) (me->target,
				  me->buffer,
				  me->write_pointer - me->buffer);
    me->write_pointer = me->buffer;
    flush_breaks(me);
    me->cleanness = 0;
    me->delete_line_break_char[0] = NO;
}

#ifdef USE_COLOR_STYLE
/*
 * We need to flush our buffer each time before we effect a color style change,
 * this also relies on the subsequent stage not doing any buffering - this is
 * currently true, in cases where it matters the target stream should be the
 * HTPlain converter.  The flushing currently prevents reasonable line breaking
 * in lines with tags.  Since color styles help visual scanning of displayed
 * source lines, and long lines are wrapped in GridText anyway, this is
 * probably acceptable (or even A Good Thing - more to see in one screenful). 
 * The pointer to the HText structure is initialized here before we effect the
 * first style change.  Getting it from the global HTMainText variable isn't
 * very clean, since it relies on the fact that HText_new() has already been
 * called for the current stream stack's document by the time we start
 * processing the first element; we rely on HTMLGenerator's callers
 * (HTMLParsedPresent in particular) to guarantee this when it matters. 
 * Normally the target stream will have been setup by HTPlainPresent, which
 * does what we need in this respect.  (A check whether we have the right
 * output stream could be done by checking that targetClass.name is
 * "PlainPresenter" or similar.)
 *
 * All special color style handling is only done if LYPreparsedSource is set. 
 * We could always do it for displaying source generated by an internal
 * gateway, but this makes the rule more simple for the user:  color styles are
 * applied to html source only with the -preparsed flag.  - kw
 */
static void do_cstyle_flush(HTStructured * me)
{
    if (!me->text && LYPreparsedSource) {
	me->text = HTMainText;
    }
    if (me->text) {
	HTMLGen_flush(me);
    }
}
#endif /* COLOR_STYLE */

/*	Weighted optional line break
 *
 *	We keep track of all the breaks for when we chop the line
 */

static void allow_break(HTStructured * me, int new_cleanness,
			BOOL dlbc)
{
    if (dlbc && me->write_pointer == me->buffer)
	dlbc = NO;
    me->line_break[new_cleanness] =
	dlbc ? me->write_pointer - 1	/* Point to space */
	: me->write_pointer;	/* point to gap */
    me->delete_line_break_char[new_cleanness] = dlbc;
    if (new_cleanness >= me->cleanness &&
	(me->overflowed || me->line_break[new_cleanness] > me->buffer))
	me->cleanness = new_cleanness;
}

/*	Character handling
 *	------------------
 *
 *	The tricky bits are the line break handling.  This attempts
 *	to synchrononise line breaks on sentence or phrase ends.  This
 *	is important if one stores SGML files in a line-oriented code
 *	repository, so that if a small change is made, line ends don't
 *	shift in a ripple-through to apparently change a large part of the
 *	file.  We give extra "cleanness" to spaces appearing directly
 *	after periods (full stops), [semi]colons and commas.
 *	   This should make the source files easier to read and modify
 *	by hand, too, though this is not a primary design consideration. TBL
 */
static void HTMLGen_put_character(HTStructured * me, char c)
{
    if (me->escape_specials && UCH(c) < 32) {
	if (c == HT_NON_BREAK_SPACE || c == HT_EN_SPACE ||
	    c == LY_SOFT_HYPHEN) {	/* recursion... */
	    HTMLGen_put_character(me, '&');
	    HTMLGen_put_character(me, '#');
	    HTMLGen_put_character(me, 'x');
	    switch (c) {
	    case HT_NON_BREAK_SPACE:	/* &#xA0; */
		HTMLGen_put_character(me, 'A');
		HTMLGen_put_character(me, '0');
		break;
	    case HT_EN_SPACE:	/* &#x2002; */
		HTMLGen_put_character(me, '2');
		HTMLGen_put_character(me, '0');
		HTMLGen_put_character(me, '0');
		HTMLGen_put_character(me, '2');
		break;
	    case LY_SOFT_HYPHEN:	/* &#xAD; */
		HTMLGen_put_character(me, 'A');
		HTMLGen_put_character(me, 'D');
		break;
	    }
	    c = ';';
	}
    }

    *me->write_pointer++ = c;

    if (c == '\n') {
	HTMLGen_flush(me);
	return;
    }

    /* Figure our whether we can break at this point
     */
    if ((!me->preformatted && (c == ' ' || c == '\t'))) {
	int new_cleanness = 3;

	if (me->write_pointer > (me->buffer + 1)) {
	    char delims[5];
	    char *p;

	    strcpy(delims, ",;:.");	/* @@@@ english bias */
	    p = strchr(delims, me->write_pointer[-2]);
	    if (p)
		new_cleanness = p - delims + 6;
	    if (!me->in_attrval)
		new_cleanness += 10;
	}
	allow_break(me, new_cleanness, YES);
    }

    /*
     * Flush buffer out when full, or whenever the line is over the nominal
     * maximum and we can break at all
     */
    if (me->write_pointer >= me->buffer + me->buffer_maxchars ||
	(me->overflowed && me->cleanness)) {
	if (me->cleanness) {
	    char line_break_char = me->line_break[me->cleanness][0];
	    char *saved = me->line_break[me->cleanness];

	    if (me->delete_line_break_char[me->cleanness])
		saved++;
	    me->line_break[me->cleanness][0] = '\n';
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  me->line_break[me->cleanness] -
					  me->buffer + 1);
	    me->line_break[me->cleanness][0] = line_break_char;
	    {			/* move next line in */
		char *p = saved;
		char *q;

		for (q = me->buffer; p < me->write_pointer;)
		    *q++ = *p++;
	    }
	    me->cleanness = 0;
	    /* Now we have to check whether ther are any perfectly good breaks
	     * which weren't good enough for the last line but may be good
	     * enough for the next
	     */
	    {
		int i;

		for (i = 0; i <= MAX_CLEANNESS; i++) {
		    if (me->line_break[i] != NULL &&
			me->line_break[i] > saved) {
			me->line_break[i] = me->line_break[i] -
			    (saved - me->buffer);
			me->cleanness = i;
		    } else {
			me->line_break[i] = NULL;
		    }
		}
	    }

	    me->delete_line_break_char[0] = 0;
	    me->write_pointer = me->write_pointer - (saved - me->buffer);
	    me->overflowed = NO;

	} else {
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  me->buffer_maxchars);
	    me->write_pointer = me->buffer;
	    flush_breaks(me);
	    me->overflowed = YES;
	}
    }
}

/*	String handling
 *	---------------
 */
static void HTMLGen_put_string(HTStructured * me, const char *s)
{
    const char *p;

    for (p = s; *p; p++)
	HTMLGen_put_character(me, *p);
}

static void HTMLGen_write(HTStructured * me, const char *s,
			  int l)
{
    const char *p;

    for (p = s; p < (s + l); p++)
	HTMLGen_put_character(me, *p);
}

/*	Start Element
 *	-------------
 *
 *	Within the opening tag, there may be spaces
 *	and the line may be broken at these spaces.
 */
static int HTMLGen_start_element(HTStructured * me, int element_number,
				 const BOOL *present,
				 const char **value,
				 int charset GCC_UNUSED,
				 char **insert GCC_UNUSED)
{
    int i;
    BOOL was_preformatted = me->preformatted;
    HTTag *tag = &HTML_dtd.tags[element_number];

#if defined(USE_COLOR_STYLE)
    char *title = NULL;
    char *title_tmp = NULL;

    if (LYPreparsedSource) {
	/*
	 * Same logic as in HTML_start_element, copied from there.  - kw
	 */
	HTSprintf(&Style_className, ";%s", HTML_dtd.tags[element_number].name);
	strcpy(myHash, HTML_dtd.tags[element_number].name);
	if (class_string[0]) {
	    int len = strlen(myHash);

	    sprintf(myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
	    HTSprintf(&Style_className, ".%s", class_string);
	}
	class_string[0] = '\0';
	strtolower(myHash);
	hcode = hash_code(myHash);
	strtolower(Style_className);

	if (TRACE_STYLE) {
	    fprintf(tfp, "CSSTRIM:%s -> %d", myHash, hcode);
	    if (hashStyles[hcode].code != hcode) {
		char *rp = strrchr(myHash, '.');

		fprintf(tfp, " (undefined) %s\n", myHash);
		if (rp) {
		    int hcd;

		    *rp = '\0';	/* trim the class */
		    hcd = hash_code(myHash);
		    fprintf(tfp, "CSS:%s -> %d", myHash, hcd);
		    if (hashStyles[hcd].code != hcd)
			fprintf(tfp, " (undefined) %s\n", myHash);
		    else
			fprintf(tfp, " ca=%d\n", hashStyles[hcd].color);
		}
	    } else
		fprintf(tfp, " ca=%d\n", hashStyles[hcode].color);
	}

	if (displayStyles[element_number + STARTAT].color > -2)		/* actually set */
	{
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSSTRIM: start_element: top <%s>\n",
		     HTML_dtd.tags[element_number].name));
	    do_cstyle_flush(me);
	    HText_characterStyle(me->text, hcode, 1);
	}
    }
#endif /* USE_COLOR_STYLE */
    me->preformatted = YES;	/* free text within tags */
    HTMLGen_put_character(me, '<');
    HTMLGen_put_string(me, tag->name);
    if (present) {
	BOOL had_attr = NO;

	for (i = 0; i < tag->number_of_attributes; i++) {
	    if (present[i]) {
		had_attr = YES;
		HTMLGen_put_character(me, ' ');
		allow_break(me, 11, YES);
#ifdef USE_COLOR_STYLE
		/*
		 * Try to mimic HTML_start_element's special handling for
		 * HTML_LINK.  If applicable, color the displayed attribute /
		 * value pairs differently.  - kw
		 */
		if (LYPreparsedSource &&
		    element_number == HTML_LINK && !title &&
		    present[HTML_LINK_CLASS] &&
		    value && *value[HTML_LINK_CLASS] != '\0' &&
		    !present[HTML_LINK_REV] &&
		    (present[HTML_LINK_REL] || present[HTML_LINK_HREF])) {
		    if (present[HTML_LINK_TITLE] && *value[HTML_LINK_TITLE]) {
			StrAllocCopy(title, value[HTML_LINK_TITLE]);
			LYTrimHead(title);
			LYTrimTail(title);
		    }
		    if ((!title || *title == '\0') && present[HTML_LINK_REL]) {
			StrAllocCopy(title, value[HTML_LINK_REL]);
		    }
		    if (title && *title) {
			HTSprintf0(&title_tmp, "link.%s.%s",
				   value[HTML_LINK_CLASS], title);
			CTRACE2(TRACE_STYLE,
				(tfp, "CSSTRIM:link=%s\n", title_tmp));

			do_cstyle_flush(me);
			HText_characterStyle(me->text, hash_code(title_tmp), 1);
		    }
		}
#endif
		HTMLGen_put_string(me, tag->attributes[i].name);
		if (value[i]) {
		    me->preformatted = was_preformatted;
		    me->in_attrval = YES;
		    if (strchr(value[i], '"') == NULL) {
			HTMLGen_put_string(me, "=\"");
			HTMLGen_put_string(me, value[i]);
			HTMLGen_put_character(me, '"');
		    } else if (strchr(value[i], '\'') == NULL) {
			HTMLGen_put_string(me, "='");
			HTMLGen_put_string(me, value[i]);
			HTMLGen_put_character(me, '\'');
		    } else {	/* attribute value has both kinds of quotes */
			const char *p;

			HTMLGen_put_string(me, "=\"");
			for (p = value[i]; *p; p++) {
			    if (*p != '"') {
				HTMLGen_put_character(me, *p);
			    } else {
				HTMLGen_put_string(me, "&#34;");
			    }
			}
			HTMLGen_put_character(me, '"');
		    }
		    me->preformatted = YES;
		    me->in_attrval = NO;
		}
	    }
	}
#ifdef USE_COLOR_STYLE
	if (had_attr && LYPreparsedSource && element_number == HTML_LINK) {
	    /*
	     * Clean up after special HTML_LINK handling - kw
	     */
	    if (title && *title) {
		do_cstyle_flush(me);
		HText_characterStyle(me->text, hash_code(title_tmp), 0);
		FREE(title_tmp);
	    }
	    FREE(title);
	}
#endif
	if (had_attr)
	    allow_break(me, 12, NO);
    }
    HTMLGen_put_string(me, ">");	/* got rid of \n LJM */

    /*
     * Make very specific HTML assumption that PRE can't be nested!
     */
    me->preformatted = (element_number == HTML_PRE) ? YES : was_preformatted;

    /*
     * Can break after element start.
     */
    if (!me->preformatted && tag->contents != SGML_EMPTY) {
	if (HTML_dtd.tags[element_number].contents == SGML_ELEMENT)
	    allow_break(me, 15, NO);
	else
	    allow_break(me, 2, NO);
    }
#if defined(USE_COLOR_STYLE)
    /*
     * Same logic as in HTML_start_element, copied from there.  - kw
     */

    /* end really empty tags straight away */
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:begin_element:ending EMPTY element style\n"));
	do_cstyle_flush(me);
	HText_characterStyle(me->text, hcode, STACK_OFF);
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
    }
#endif /* USE_COLOR_STYLE */
    if (element_number == HTML_OBJECT && tag->contents == SGML_LITTERAL) {
	/*
	 * These conditions only approximate the ones used in HTML.c.  Let our
	 * SGML parser know that further content is to be parsed normally not
	 * literally.  - kw
	 */
	if (!present) {
	    return HT_PARSER_OTHER_CONTENT;
	} else if (!present[HTML_OBJECT_DECLARE] &&
		   !(present[HTML_OBJECT_NAME] &&
		     value[HTML_OBJECT_NAME] && *value[HTML_OBJECT_NAME])) {
	    if (present[HTML_OBJECT_SHAPES] ||
		!(present[HTML_OBJECT_USEMAP] &&
		  value[HTML_OBJECT_USEMAP] && *value[HTML_OBJECT_USEMAP]))
		return HT_PARSER_OTHER_CONTENT;
	}
    }
    return HT_OK;
}

/*		End Element
 *		-----------
 *
 */
/*	When we end an element, the style must be returned to that
 *	in effect before that element.	Note that anchors (etc?)
 *	don't have an associated style, so that we must scan down the
 *	stack for an element with a defined style. (In fact, the styles
 *	should be linked to the whole stack not just the top one.)
 *	TBL 921119
 */
static int HTMLGen_end_element(HTStructured * me, int element_number,
			       char **insert GCC_UNUSED)
{
    if (!me->preformatted &&
	HTML_dtd.tags[element_number].contents != SGML_EMPTY) {
	/*
	 * Can break before element end.
	 */
	if (HTML_dtd.tags[element_number].contents == SGML_ELEMENT)
	    allow_break(me, 14, NO);
	else
	    allow_break(me, 1, NO);
    }
    HTMLGen_put_string(me, "</");
    HTMLGen_put_string(me, HTML_dtd.tags[element_number].name);
    HTMLGen_put_character(me, '>');
    if (element_number == HTML_PRE) {
	me->preformatted = NO;
    }
#ifdef USE_COLOR_STYLE
    /*
     * Same logic as in HTML_end_element, copied from there.  - kw
     */
    TrimColorClass(HTML_dtd.tags[element_number].name,
		   Style_className, &hcode);

    if (LYPreparsedSource && !ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:end_element: ending non-EMPTY style\n"));
	do_cstyle_flush(me);
	HText_characterStyle(me->text, hcode, STACK_OFF);
    }
#endif /* USE_COLOR_STYLE */
    return HT_OK;
}

/*		Expanding entities
 *		------------------
 *
 */
static int HTMLGen_put_entity(HTStructured * me, int entity_number)
{
    int nent = HTML_dtd.number_of_entities;

    HTMLGen_put_character(me, '&');
    if (entity_number < nent) {
	HTMLGen_put_string(me, HTML_dtd.entity_names[entity_number]);
    }
    HTMLGen_put_character(me, ';');
    return HT_OK;
}

/*	Free an HTML object
 *	-------------------
 *
 */
static void HTMLGen_free(HTStructured * me)
{
    (*me->targetClass.put_character) (me->target, '\n');
    HTMLGen_flush(me);
    (*me->targetClass._free) (me->target);	/* ripple through */
#ifdef USE_COLOR_STYLE
    FREE(Style_className);
#endif
    FREE(me);
}

static void PlainToHTML_free(HTStructured * me)
{
    HTMLGen_end_element(me, HTML_PRE, 0);
    HTMLGen_free(me);
}

static void HTMLGen_abort(HTStructured * me, HTError e GCC_UNUSED)
{
    HTMLGen_free(me);
#ifdef USE_COLOR_STYLE
    FREE(Style_className);
#endif
}

static void PlainToHTML_abort(HTStructured * me, HTError e GCC_UNUSED)
{
    PlainToHTML_free(me);
}

/*	Structured Object Class
 *	-----------------------
 */
static const HTStructuredClass HTMLGeneration =		/* As opposed to print etc */
{
    "HTMLGen",
    HTMLGen_free,
    HTMLGen_abort,
    HTMLGen_put_character, HTMLGen_put_string, HTMLGen_write,
    HTMLGen_start_element, HTMLGen_end_element,
    HTMLGen_put_entity
};

/*	Subclass-specific Methods
 *	-------------------------
 */
HTStructured *HTMLGenerator(HTStream *output)
{
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

    if (me == NULL)
	outofmem(__FILE__, "HTMLGenerator");
    me->isa = &HTMLGeneration;

    me->target = output;
    me->targetClass = *me->target->isa;		/* Copy pointers to routines for speed */

    me->write_pointer = me->buffer;
    flush_breaks(me);
    me->line_break[0] = me->buffer;
    me->cleanness = 0;
    me->overflowed = NO;
    me->delete_line_break_char[0] = NO;
    me->preformatted = NO;
    me->in_attrval = NO;

    /*
     * For what line length should we attempt to wrap ?  - kw
     */
    if (!LYPreparsedSource) {
	me->buffer_maxchars = 80;	/* work as before - kw */
    } else if (dump_output_width > 1) {
	me->buffer_maxchars = dump_output_width;	/* try to honor -width - kw */
    } else if (dump_output_immediately) {
	me->buffer_maxchars = 80;	/* try to honor -width - kw */
    } else {
	me->buffer_maxchars = (LYcolLimit - 1);
	if (me->buffer_maxchars < 38)	/* too narrow, let GridText deal */
	    me->buffer_maxchars = 40;
    }
    if (me->buffer_maxchars > 900)	/* likely not true - kw */
	me->buffer_maxchars = 78;
    if (me->buffer_maxchars > BUFFER_SIZE)	/* must not be larger! */
	me->buffer_maxchars = BUFFER_SIZE - 2;

    /*
     * If dump_output_immediately is set, there likely isn't anything after
     * this stream to interpret the Lynx special chars.  Also if they get
     * displayed via HTPlain, that will probably make non-breaking space chars
     * etc.  invisible.  So let's translate them to numerical character
     * references.  For debugging purposes we'll use the new hex format.
     */
    me->escape_specials = LYPreparsedSource;

#ifdef USE_COLOR_STYLE
    me->text = NULL;		/* Will be initialized when first needed. - kw */
    FREE(Style_className);
    class_string[0] = '\0';
#endif /* COLOR_STYLE */

    return me;
}

/*	Stream Object Class
 *	-------------------
 *
 *	This object just converts a plain text stream into HTML
 *	It is officially a structured strem but only the stream bits exist.
 *	This is just the easiest way of typecasting all the routines.
 */
static const HTStructuredClass PlainToHTMLConversion =
{
    "plaintexttoHTML",
    HTMLGen_free,
    PlainToHTML_abort,
    HTMLGen_put_character,
    HTMLGen_put_string,
    HTMLGen_write,
    NULL,			/* Structured stuff */
    NULL,
    NULL
};

/*	HTConverter from plain text to HTML Stream
 *	------------------------------------------
 */
HTStream *HTPlainToHTML(HTPresentation *pres GCC_UNUSED,
			HTParentAnchor *anchor GCC_UNUSED,
			HTStream *sink)
{
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

    if (me == NULL)
	outofmem(__FILE__, "PlainToHTML");
    me->isa = (const HTStructuredClass *) &PlainToHTMLConversion;

    /*
     * Copy pointers to routines for speed.
     */
    me->target = sink;
    me->targetClass = *me->target->isa;
    me->write_pointer = me->buffer;
    flush_breaks(me);
    me->cleanness = 0;
    me->overflowed = NO;
    me->delete_line_break_char[0] = NO;
    /* try to honor -width - kw */
    me->buffer_maxchars = (dump_output_width > 1 ?
			   dump_output_width : 80);

    HTMLGen_put_string(me, "<HTML>\n<BODY>\n<PRE>\n");
    me->preformatted = YES;
    me->escape_specials = NO;
    me->in_attrval = NO;
    return (HTStream *) me;
}
@


1.5
log
@automatic merge of lynx-current
@
text
@d37 1
a626 2
extern int LYcols;		/* LYCurses.h, set in LYMain.c  */

d657 1
a657 1
	me->buffer_maxchars = LYcols - 2;
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 12
a13 12
**		==============
**
**	This version of the HTML object sends HTML markup to the output stream.
**
** Bugs:	Line wrapping is not done at all.
**		All data handled as PCDATA.
**		Should convert old XMP, LISTING and PLAINTEXT to PRE.
**
**	It is not obvious to me right now whether the HEAD should be generated
**	from the incomming data or the anchor.	Currently it is from the former
**	which is cleanest.
*/
d52 2
a53 2
**		-----------
*/
d55 3
a57 3
	const HTStreamClass *		isa;
	HTStream *			target;
	HTStreamClass			targetClass;	/* COPY for speed */
d61 14
a74 14
	const HTStructuredClass *	isa;
	HTStream *			target;
	HTStreamClass			targetClass;	/* COPY for speed */

	char				buffer[BUFFER_SIZE+1]; /* 1for NL */
	int				buffer_maxchars;
	char *				write_pointer;
	char *				line_break [MAX_CLEANNESS+1];
	int				cleanness;
	BOOL				overflowed;
	BOOL				delete_line_break_char[MAX_CLEANNESS+1];
	BOOL				preformatted;
	BOOL				escape_specials;
	BOOL				in_attrval;
d76 1
a76 1
	HText *				text;
d81 2
a82 2
**	------------
*/
d84 1
a84 2
static void flush_breaks (
	HTStructured *		me)
d87 2
a88 1
    for (i=0; i<= MAX_CLEANNESS; i++) {
d93 1
a93 2
static void HTMLGen_flush (
	HTStructured *		me)
d95 3
a97 3
    (*me->targetClass.put_block)(me->target,
				 me->buffer,
				 me->write_pointer - me->buffer);
d106 22
a127 25
 *  We need to flush our buffer each time before we effect a color style
 *  change, this also relies on the subsequent stage not doing any
 *  buffering - this is currently true, in cases where it matters the
 *  target stream should be the HTPlain converter.
 *  The flushing currently prevents reasonable line breaking in lines
 *  with tags.  Since color styles help visual scanning of displayed
 *  source lines, and long lines are wrapped in GridText anyway, this
 *  is probably acceptable (or even A Good Thing - more to see in one
 *  screenful).
 *  The pointer to the HText structure is initialized here before
 *  we effect the first style change.  Getting it from the global
 *  HTMainText variable isn't very clean, since it relies on the fact
 *  that HText_new() has already been called for the current stream
 *  stack's document by the time we start processing the first element;
 *  we rely on HTMLGenerator's callers (HTMLParsedPresent in particular)
 *  to guarantee this when it matters.  Normally the target stream will
 *  have been setup by HTPlainPresent, which does what we need in this
 *  respect.  (A check whether we have the right output stream could be
 *  done by checking that targetClass.name is "PlainPresenter" or similar.)
 *
 *  All special color style handling is only done if LYPreparsedSource
 *  is set.  We could always do it for displaying source generated by
 *  an internal gateway, but this makes the rule more simple for the
 *  user: color styles are applied to html source only with the
 *  -preparsed flag. - kw
d129 1
a129 2
static void do_cstyle_flush (
	HTStructured *		me)
d141 3
a143 3
**
**	We keep track of all the breaks for when we chop the line
*/
d145 2
a146 4
static void allow_break (
	HTStructured * me,
	int		new_cleanness,
	BOOL		dlbc)
d148 2
a149 1
    if (dlbc && me->write_pointer == me->buffer) dlbc = NO;
d151 2
a152 2
			 dlbc ? me->write_pointer - 1 /* Point to space */
			      : me->write_pointer ;   /* point to gap */
d160 13
a172 15
**	------------------
**
**	The tricky bits are the line break handling.  This attempts
**	to synchrononise line breaks on sentence or phrase ends.  This
**	is important if one stores SGML files in a line-oriented code
**	repository, so that if a small change is made, line ends don't
**	shift in a ripple-through to apparently change a large part of the
**	file.  We give extra "cleanness" to spaces appearing directly
**	after periods (full stops), [semi]colons and commas.
**	   This should make the source files easier to read and modify
**	by hand, too, though this is not a primary design consideration. TBL
*/
static void HTMLGen_put_character (
	HTStructured *		me,
	char			c)
d176 1
a176 1
	    c == LY_SOFT_HYPHEN) { /* recursion... */
d180 2
a181 2
	    switch(c) {
	    case HT_NON_BREAK_SPACE: /* &#xA0; */
d185 1
a185 1
	    case HT_EN_SPACE: /* &#x2002; */
d191 1
a191 1
	    case LY_SOFT_HYPHEN: /* &#xAD; */
d208 1
a208 1
    */
d211 1
d214 3
a216 2
	    char * p;
	    strcpy(delims, ",;:.");		/* @@@@ english bias */
d218 4
a221 2
	    if (p) new_cleanness = p - delims + 6;
	    if (!me->in_attrval) new_cleanness += 10;
d227 2
a228 2
     *	Flush buffer out when full, or whenever the line is over
     *	the nominal maximum and we can break at all
d234 1
a234 1
	    char * saved = me->line_break[me->cleanness];
d236 2
a237 1
	    if (me->delete_line_break_char[me->cleanness]) saved++;
d239 4
a242 3
	    (*me->targetClass.put_block)(me->target,
					 me->buffer,
			       me->line_break[me->cleanness] - me->buffer + 1);
d244 2
a245 2
	    {  /* move next line in */
		char * p = saved;
d247 2
a248 1
		for (q = me->buffer; p < me->write_pointer; )
d253 3
a255 3
	    ** which weren't good enough for the last line but may be
	    **	good enough for the next
	    */
d258 2
a259 1
		for(i=0; i <= MAX_CLEANNESS; i++) {
d263 1
a263 1
						(saved-me->buffer);
d272 1
a272 1
	    me->write_pointer = me->write_pointer - (saved-me->buffer);
d276 3
a278 3
	    (*me->targetClass.put_block)(me->target,
					 me->buffer,
					 me->buffer_maxchars);
d287 3
a289 5
**	---------------
*/
static void HTMLGen_put_string (
	HTStructured *		me,
	const char *		s)
d291 1
a291 1
    const char * p;
d297 2
a298 4
static void HTMLGen_write (
	HTStructured *		me,
	const char *		s,
	int			l)
d300 1
a300 1
    const char * p;
d307 10
a316 12
**	-------------
**
**	Within the opening tag, there may be spaces
**	and the line may be broken at these spaces.
*/
static int HTMLGen_start_element (
	HTStructured *		me,
	int			element_number,
	const BOOL*		present,
	const char **		value,
	int			charset GCC_UNUSED,
	char **			insert GCC_UNUSED)
d320 1
a320 1
    HTTag * tag = &HTML_dtd.tags[element_number];
d328 1
a328 1
	 *  Same logic as in HTML_start_element, copied from there. - kw
d330 3
a332 4
	HTSprintf (&Style_className, ";%s", HTML_dtd.tags[element_number].name);
	strcpy (myHash, HTML_dtd.tags[element_number].name);
	if (class_string[0])
	{
d334 3
a336 2
	    sprintf (myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
	    HTSprintf (&Style_className, ".%s", class_string);
d343 1
a343 2
	if (TRACE_STYLE)
	{
d345 1
a345 2
	    if (hashStyles[hcode].code!=hcode)
	    {
d347 1
d349 1
a349 2
		if (rp)
		{
d351 2
a352 1
		    *rp = '\0'; /* trim the class */
d355 1
a355 1
		    if (hashStyles[hcd].code!=hcd)
d360 1
a360 2
	    }
	    else
d364 1
a364 1
	if (displayStyles[element_number + STARTAT].color > -2) /* actually set */
d368 1
a368 1
			  HTML_dtd.tags[element_number].name));
d379 1
d387 3
a389 3
		 *  Try to mimic HTML_start_element's special handling
		 *  for HTML_LINK.  If applicable, color the displayed
		 *  attribute / value pairs differently. - kw
d394 1
a394 1
		    value && *value[HTML_LINK_CLASS]!='\0' &&
d402 1
a402 1
		    if ((!title || *title=='\0') && present[HTML_LINK_REL]) {
d428 1
a428 1
		    } else {  /* attribute value has both kinds of quotes */
d430 1
d449 1
a449 1
	     *  Clean up after special HTML_LINK handling - kw
d462 1
a462 1
    HTMLGen_put_string(me, ">"); /* got rid of \n LJM */
d465 1
a465 1
     *	Make very specific HTML assumption that PRE can't be nested!
d467 1
a467 1
    me->preformatted = (element_number == HTML_PRE)  ? YES : was_preformatted;
d470 1
a470 1
     *	Can break after element start.
a477 1

d480 1
a480 1
     *  Same logic as in HTML_start_element, copied from there. - kw
d484 1
a484 2
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number))
    {
d495 3
a497 3
	 *  These conditions only approximate the ones used in HTML.c.
	 *  Let our SGML parser know that further content is to be parsed
	 *  normally not literally. - kw
d502 1
a502 1
		   !(present[HTML_OBJECT_NAME]  &&
d514 3
a516 3
**		-----------
**
*/
d518 8
a525 10
**	in effect before that element.	Note that anchors (etc?)
**	don't have an associated style, so that we must scan down the
**	stack for an element with a defined style. (In fact, the styles
**	should be linked to the whole stack not just the top one.)
**	TBL 921119
*/
static int HTMLGen_end_element (
	HTStructured *		me,
	int			element_number,
	char **		insert GCC_UNUSED)
d530 1
a530 1
	 *  Can break before element end.
d545 1
a545 1
     *  Same logic as in HTML_end_element, copied from there. - kw
d561 4
a564 6
**		------------------
**
*/
static int HTMLGen_put_entity (
	HTStructured *		me,
	int			entity_number)
d570 1
a570 1
      HTMLGen_put_string(me, HTML_dtd.entity_names[entity_number]);
d577 4
a580 5
**	-------------------
**
*/
static void HTMLGen_free (
	HTStructured *		me)
d582 1
a582 1
    (*me->targetClass.put_character)(me->target, '\n');
d584 1
a584 1
    (*me->targetClass._free)(me->target);	/* ripple through */
d591 1
a591 2
static void PlainToHTML_free (
	HTStructured *		me)
d597 1
a597 3
static void HTMLGen_abort (
	HTStructured *		me,
	HTError		e GCC_UNUSED)
d605 1
a605 3
static void PlainToHTML_abort (
	HTStructured *		me,
	HTError		e GCC_UNUSED)
d611 3
a613 3
**	-----------------------
*/
static const HTStructuredClass HTMLGeneration = /* As opposed to print etc */
d615 6
a620 6
	"HTMLGen",
	HTMLGen_free,
	HTMLGen_abort,
	HTMLGen_put_character,	HTMLGen_put_string, HTMLGen_write,
	HTMLGen_start_element,	HTMLGen_end_element,
	HTMLGen_put_entity
d624 3
a626 3
**	-------------------------
*/
extern int LYcols;			/* LYCurses.h, set in LYMain.c	*/
d628 1
a628 2
HTStructured * HTMLGenerator (
	HTStream *		output)
d630 2
a631 1
    HTStructured* me = (HTStructured*)malloc(sizeof(*me));
d637 1
a637 1
    me->targetClass = *me->target->isa; /* Copy pointers to routines for speed*/
d642 1
a642 1
    me->cleanness =	0;
d645 1
a645 1
    me->preformatted =	NO;
d649 1
a649 1
     *	For what line length should we attempt to wrap ? - kw
d652 1
a652 1
	me->buffer_maxchars = 80; /* work as before - kw */
d654 1
a654 1
	me->buffer_maxchars = dump_output_width; /* try to honor -width - kw */
d656 1
a656 1
	me->buffer_maxchars = 80; /* try to honor -width - kw */
d659 1
a659 1
	if (me->buffer_maxchars < 38) /* too narrow, let GridText deal */
d662 1
a662 1
    if (me->buffer_maxchars > 900) /* likely not true - kw */
d664 1
a664 1
    if (me->buffer_maxchars > BUFFER_SIZE) /* must not be larger! */
d668 5
a672 6
     *	If dump_output_immediately is set, there likely isn't anything
     *	after this stream to interpret the Lynx special chars.	Also
     *	if they get displayed via HTPlain, that will probably make
     *	non-breaking space chars etc. invisible.  So let's translate
     *	them to numerical character references.  For debugging
     *	purposes we'll use the new hex format.
d677 1
a677 1
    me->text = NULL;	/* Will be initialized when first needed. - kw */
d686 6
a691 6
**	-------------------
**
**	This object just converts a plain text stream into HTML
**	It is officially a structured strem but only the stream bits exist.
**	This is just the easiest way of typecasting all the routines.
*/
d694 9
a702 9
	"plaintexttoHTML",
	HTMLGen_free,
	PlainToHTML_abort,
	HTMLGen_put_character,
	HTMLGen_put_string,
	HTMLGen_write,
	NULL,		/* Structured stuff */
	NULL,
	NULL
d706 5
a710 6
**	------------------------------------------
*/
HTStream* HTPlainToHTML (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor GCC_UNUSED,
	HTStream *		sink)
d712 2
a713 1
    HTStructured *me = (HTStructured *)malloc(sizeof(*me));
d716 1
a716 1
    me->isa = (const HTStructuredClass *)&PlainToHTMLConversion;
d719 1
a719 1
     *	Copy pointers to routines for speed.
d725 1
a725 1
    me->cleanness =	0;
d736 1
a736 1
    return (HTStream*) me;
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d44 1
a44 1
PUBLIC char class_string[TEMPSTRINGSIZE];
d55 1
a55 1
	CONST HTStreamClass *		isa;
d61 1
a61 1
	CONST HTStructuredClass *	isa;
d84 2
a85 2
PRIVATE void flush_breaks ARGS1(
	HTStructured *,		me)
d93 2
a94 2
PRIVATE void HTMLGen_flush ARGS1(
	HTStructured *,		me)
d133 2
a134 2
PRIVATE void do_cstyle_flush ARGS1(
	HTStructured *,		me)
d150 4
a153 4
PRIVATE void allow_break ARGS3(
	HTStructured *, me,
	int,		new_cleanness,
	BOOL,		dlbc)
d178 3
a180 3
PRIVATE void HTMLGen_put_character ARGS2(
	HTStructured *,		me,
	char,			c)
d289 3
a291 3
PRIVATE void HTMLGen_put_string ARGS2(
	HTStructured *,		me,
	CONST char *,		s)
d293 1
a293 1
    CONST char * p;
d299 4
a302 4
PRIVATE void HTMLGen_write ARGS3(
	HTStructured *,		me,
	CONST char *,		s,
	int,			l)
d304 1
a304 1
    CONST char * p;
d316 7
a322 7
PRIVATE int HTMLGen_start_element ARGS6(
	HTStructured *,		me,
	int,			element_number,
	CONST BOOL*,		present,
	CONST char **,		value,
	int,			charset GCC_UNUSED,
	char **,		insert GCC_UNUSED)
d436 1
a436 1
			CONST char *p;
d532 4
a535 4
PRIVATE int HTMLGen_end_element ARGS3(
	HTStructured *,		me,
	int,			element_number,
	char **,		insert GCC_UNUSED)
d574 3
a576 3
PRIVATE int HTMLGen_put_entity ARGS2(
	HTStructured *,		me,
	int,			entity_number)
d592 2
a593 2
PRIVATE void HTMLGen_free ARGS1(
	HTStructured *,		me)
d604 2
a605 2
PRIVATE void PlainToHTML_free ARGS1(
	HTStructured *,		me)
d611 3
a613 3
PRIVATE void HTMLGen_abort ARGS2(
	HTStructured *,		me,
	HTError,		e GCC_UNUSED)
d621 3
a623 3
PRIVATE void PlainToHTML_abort ARGS2(
	HTStructured *,		me,
	HTError,		e GCC_UNUSED)
d631 1
a631 1
PRIVATE CONST HTStructuredClass HTMLGeneration = /* As opposed to print etc */
d646 2
a647 2
PUBLIC HTStructured * HTMLGenerator ARGS1(
	HTStream *,		output)
d711 1
a711 1
PRIVATE CONST HTStructuredClass PlainToHTMLConversion =
d727 4
a730 4
PUBLIC HTStream* HTPlainToHTML ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor GCC_UNUSED,
	HTStream *,		sink)
d735 1
a735 1
    me->isa = (CONST HTStructuredClass *)&PlainToHTMLConversion;
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d36 1
a38 2
extern BOOLEAN LYPreparsedSource;	/* Show source as preparsed?	*/

d85 1
a85 1
	HTStructured *, 	me)
d94 1
a94 1
	HTStructured *, 	me)
d134 1
a134 1
	HTStructured *, 	me)
d179 1
a179 1
	HTStructured *, 	me,
d182 1
a182 1
    if (me->escape_specials && (unsigned char)c < 32) {
d290 1
a290 1
	HTStructured *, 	me,
d300 1
a300 1
	HTStructured *, 	me,
d316 2
a317 2
PRIVATE void HTMLGen_start_element ARGS6(
	HTStructured *, 	me,
d340 2
a342 2
	    strcat (myHash, ".");
	    strcat (myHash, class_string);
d349 1
a349 1
	if (TRACE)
d354 1
a354 1
		char *rp=strrchr(myHash, '.');
d359 1
a359 1
		    *rp='\0'; /* trim the class */
d374 3
a376 2
	    CTRACE(tfp, "CSSTRIM: start_element: top <%s>\n",
		   HTML_dtd.tags[element_number].name);
d415 2
a416 1
			CTRACE(tfp, "CSSTRIM:link=%s\n", title_tmp);
d490 2
a491 5
/* end really empty tags straight away */
#define REALLY_EMPTY(e) ((HTML_dtd.tags[e].contents == SGML_EMPTY) && \
			 !(HTML_dtd.tags[e].flags & Tgf_nreie))

    if (LYPreparsedSource && REALLY_EMPTY(element_number))
d493 2
a494 1
	CTRACE(tfp, "STYLE:begin_element:ending EMPTY element style\n");
a495 3
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
a496 1
#endif /* USE_HASH */
d501 18
d532 2
a533 2
PRIVATE void HTMLGen_end_element ARGS3(
	HTStructured *, 	me,
d560 3
a562 3
    if (LYPreparsedSource && !REALLY_EMPTY(element_number))
    {
	CTRACE(tfp, "STYLE:end_element: ending non-EMPTY style\n");
a563 3
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
a564 1
#endif /* USE_HASH */
d567 1
d575 1
a575 1
	HTStructured *, 	me,
d593 1
a593 1
	HTStructured *, 	me)
d605 1
a605 1
	HTStructured *, 	me)
d612 1
a612 1
	HTStructured *, 	me,
d622 1
a622 1
	HTStructured *, 	me,
a644 2
extern BOOL dump_output_immediately;	/* TRUE if no interactive user	*/
extern int dump_output_width;		/* -width instead of 80 	*/
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 12
a13 12
 *		==============
 *
 *	This version of the HTML object sends HTML markup to the output stream.
 *
 * Bugs:	Line wrapping is not done at all.
 *		All data handled as PCDATA.
 *		Should convert old XMP, LISTING and PLAINTEXT to PRE.
 *
 *	It is not obvious to me right now whether the HEAD should be generated
 *	from the incomming data or the anchor.	Currently it is from the former
 *	which is cleanest.
 */
a35 2
#include <LYGlobalDefs.h>
#include <LYCurses.h>
d38 2
d45 1
a45 1
char class_string[TEMPSTRINGSIZE];
d53 2
a54 2
 *		-----------
 */
d56 3
a58 3
    const HTStreamClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */
d62 14
a75 14
    const HTStructuredClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */

    char buffer[BUFFER_SIZE + 1];	/* 1for NL */
    int buffer_maxchars;
    char *write_pointer;
    char *line_break[MAX_CLEANNESS + 1];
    int cleanness;
    BOOL overflowed;
    BOOL delete_line_break_char[MAX_CLEANNESS + 1];
    BOOL preformatted;
    BOOL escape_specials;
    BOOL in_attrval;
d77 1
a77 1
    HText *text;
d82 2
a83 2
 *	------------
 */
d85 2
a86 1
static void flush_breaks(HTStructured * me)
d89 1
a89 2

    for (i = 0; i <= MAX_CLEANNESS; i++) {
d94 2
a95 1
static void HTMLGen_flush(HTStructured * me)
d97 3
a99 3
    (*me->targetClass.put_block) (me->target,
				  me->buffer,
				  me->write_pointer - me->buffer);
d108 25
a132 22
 * We need to flush our buffer each time before we effect a color style change,
 * this also relies on the subsequent stage not doing any buffering - this is
 * currently true, in cases where it matters the target stream should be the
 * HTPlain converter.  The flushing currently prevents reasonable line breaking
 * in lines with tags.  Since color styles help visual scanning of displayed
 * source lines, and long lines are wrapped in GridText anyway, this is
 * probably acceptable (or even A Good Thing - more to see in one screenful). 
 * The pointer to the HText structure is initialized here before we effect the
 * first style change.  Getting it from the global HTMainText variable isn't
 * very clean, since it relies on the fact that HText_new() has already been
 * called for the current stream stack's document by the time we start
 * processing the first element; we rely on HTMLGenerator's callers
 * (HTMLParsedPresent in particular) to guarantee this when it matters. 
 * Normally the target stream will have been setup by HTPlainPresent, which
 * does what we need in this respect.  (A check whether we have the right
 * output stream could be done by checking that targetClass.name is
 * "PlainPresenter" or similar.)
 *
 * All special color style handling is only done if LYPreparsedSource is set. 
 * We could always do it for displaying source generated by an internal
 * gateway, but this makes the rule more simple for the user:  color styles are
 * applied to html source only with the -preparsed flag.  - kw
d134 2
a135 1
static void do_cstyle_flush(HTStructured * me)
d147 3
a149 3
 *
 *	We keep track of all the breaks for when we chop the line
 */
d151 4
a154 2
static void allow_break(HTStructured * me, int new_cleanness,
			BOOL dlbc)
d156 1
a156 2
    if (dlbc && me->write_pointer == me->buffer)
	dlbc = NO;
d158 2
a159 2
	dlbc ? me->write_pointer - 1	/* Point to space */
	: me->write_pointer;	/* point to gap */
d167 15
a181 13
 *	------------------
 *
 *	The tricky bits are the line break handling.  This attempts
 *	to synchrononise line breaks on sentence or phrase ends.  This
 *	is important if one stores SGML files in a line-oriented code
 *	repository, so that if a small change is made, line ends don't
 *	shift in a ripple-through to apparently change a large part of the
 *	file.  We give extra "cleanness" to spaces appearing directly
 *	after periods (full stops), [semi]colons and commas.
 *	   This should make the source files easier to read and modify
 *	by hand, too, though this is not a primary design consideration. TBL
 */
static void HTMLGen_put_character(HTStructured * me, char c)
d183 1
a183 1
    if (me->escape_specials && UCH(c) < 32) {
d185 1
a185 1
	    c == LY_SOFT_HYPHEN) {	/* recursion... */
d189 2
a190 2
	    switch (c) {
	    case HT_NON_BREAK_SPACE:	/* &#xA0; */
d194 1
a194 1
	    case HT_EN_SPACE:	/* &#x2002; */
d200 1
a200 1
	    case LY_SOFT_HYPHEN:	/* &#xAD; */
d217 1
a217 1
     */
a219 1

d222 2
a223 3
	    char *p;

	    strcpy(delims, ",;:.");	/* @@@@ english bias */
d225 2
a226 4
	    if (p)
		new_cleanness = p - delims + 6;
	    if (!me->in_attrval)
		new_cleanness += 10;
d232 2
a233 2
     * Flush buffer out when full, or whenever the line is over the nominal
     * maximum and we can break at all
d239 1
a239 1
	    char *saved = me->line_break[me->cleanness];
d241 1
a241 2
	    if (me->delete_line_break_char[me->cleanness])
		saved++;
d243 3
a245 4
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  me->line_break[me->cleanness] -
					  me->buffer + 1);
d247 2
a248 2
	    {			/* move next line in */
		char *p = saved;
d250 1
a250 2

		for (q = me->buffer; p < me->write_pointer;)
d255 3
a257 3
	     * which weren't good enough for the last line but may be good
	     * enough for the next
	     */
d260 1
a260 2

		for (i = 0; i <= MAX_CLEANNESS; i++) {
d264 1
a264 1
			    (saved - me->buffer);
d273 1
a273 1
	    me->write_pointer = me->write_pointer - (saved - me->buffer);
d277 3
a279 3
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  me->buffer_maxchars);
d288 5
a292 3
 *	---------------
 */
static void HTMLGen_put_string(HTStructured * me, const char *s)
d294 1
a294 1
    const char *p;
d300 4
a303 2
static void HTMLGen_write(HTStructured * me, const char *s,
			  int l)
d305 1
a305 1
    const char *p;
d312 12
a323 10
 *	-------------
 *
 *	Within the opening tag, there may be spaces
 *	and the line may be broken at these spaces.
 */
static int HTMLGen_start_element(HTStructured * me, int element_number,
				 const BOOL *present,
				 const char **value,
				 int charset GCC_UNUSED,
				 char **insert GCC_UNUSED)
d327 1
a327 1
    HTTag *tag = &HTML_dtd.tags[element_number];
d335 1
a335 1
	 * Same logic as in HTML_start_element, copied from there.  - kw
d337 7
a343 7
	HTSprintf(&Style_className, ";%s", HTML_dtd.tags[element_number].name);
	strcpy(myHash, HTML_dtd.tags[element_number].name);
	if (class_string[0]) {
	    int len = strlen(myHash);

	    sprintf(myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
	    HTSprintf(&Style_className, ".%s", class_string);
d350 2
a351 1
	if (TRACE_STYLE) {
d353 3
a355 3
	    if (hashStyles[hcode].code != hcode) {
		char *rp = strrchr(myHash, '.');

d357 2
a358 1
		if (rp) {
d360 1
a360 2

		    *rp = '\0';	/* trim the class */
d363 1
a363 1
		    if (hashStyles[hcd].code != hcd)
d368 2
a369 1
	    } else
d373 1
a373 1
	if (displayStyles[element_number + STARTAT].color > -2)		/* actually set */
d375 2
a376 3
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSSTRIM: start_element: top <%s>\n",
		     HTML_dtd.tags[element_number].name));
a386 1

d394 3
a396 3
		 * Try to mimic HTML_start_element's special handling for
		 * HTML_LINK.  If applicable, color the displayed attribute /
		 * value pairs differently.  - kw
d401 1
a401 1
		    value && *value[HTML_LINK_CLASS] != '\0' &&
d409 1
a409 1
		    if ((!title || *title == '\0') && present[HTML_LINK_REL]) {
d415 1
a415 2
			CTRACE2(TRACE_STYLE,
				(tfp, "CSSTRIM:link=%s\n", title_tmp));
d434 2
a435 3
		    } else {	/* attribute value has both kinds of quotes */
			const char *p;

d454 1
a454 1
	     * Clean up after special HTML_LINK handling - kw
d467 1
a467 1
    HTMLGen_put_string(me, ">");	/* got rid of \n LJM */
d470 1
a470 1
     * Make very specific HTML assumption that PRE can't be nested!
d472 1
a472 1
    me->preformatted = (element_number == HTML_PRE) ? YES : was_preformatted;
d475 1
a475 1
     * Can break after element start.
d483 1
d486 1
a486 1
     * Same logic as in HTML_start_element, copied from there.  - kw
d489 7
a495 4
    /* end really empty tags straight away */
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:begin_element:ending EMPTY element style\n"));
d497 3
d501 1
a505 18
    if (element_number == HTML_OBJECT && tag->contents == SGML_LITTERAL) {
	/*
	 * These conditions only approximate the ones used in HTML.c.  Let our
	 * SGML parser know that further content is to be parsed normally not
	 * literally.  - kw
	 */
	if (!present) {
	    return HT_PARSER_OTHER_CONTENT;
	} else if (!present[HTML_OBJECT_DECLARE] &&
		   !(present[HTML_OBJECT_NAME] &&
		     value[HTML_OBJECT_NAME] && *value[HTML_OBJECT_NAME])) {
	    if (present[HTML_OBJECT_SHAPES] ||
		!(present[HTML_OBJECT_USEMAP] &&
		  value[HTML_OBJECT_USEMAP] && *value[HTML_OBJECT_USEMAP]))
		return HT_PARSER_OTHER_CONTENT;
	}
    }
    return HT_OK;
d509 3
a511 3
 *		-----------
 *
 */
d513 10
a522 8
 *	in effect before that element.	Note that anchors (etc?)
 *	don't have an associated style, so that we must scan down the
 *	stack for an element with a defined style. (In fact, the styles
 *	should be linked to the whole stack not just the top one.)
 *	TBL 921119
 */
static int HTMLGen_end_element(HTStructured * me, int element_number,
			       char **insert GCC_UNUSED)
d527 1
a527 1
	 * Can break before element end.
d542 1
a542 1
     * Same logic as in HTML_end_element, copied from there.  - kw
d547 3
a549 3
    if (LYPreparsedSource && !ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:end_element: ending non-EMPTY style\n"));
d551 3
d555 1
a557 1
    return HT_OK;
d561 6
a566 4
 *		------------------
 *
 */
static int HTMLGen_put_entity(HTStructured * me, int entity_number)
d572 1
a572 1
	HTMLGen_put_string(me, HTML_dtd.entity_names[entity_number]);
d579 5
a583 4
 *	-------------------
 *
 */
static void HTMLGen_free(HTStructured * me)
d585 1
a585 1
    (*me->targetClass.put_character) (me->target, '\n');
d587 1
a587 1
    (*me->targetClass._free) (me->target);	/* ripple through */
d594 2
a595 1
static void PlainToHTML_free(HTStructured * me)
d601 3
a603 1
static void HTMLGen_abort(HTStructured * me, HTError e GCC_UNUSED)
d611 3
a613 1
static void PlainToHTML_abort(HTStructured * me, HTError e GCC_UNUSED)
d619 3
a621 3
 *	-----------------------
 */
static const HTStructuredClass HTMLGeneration =		/* As opposed to print etc */
d623 6
a628 6
    "HTMLGen",
    HTMLGen_free,
    HTMLGen_abort,
    HTMLGen_put_character, HTMLGen_put_string, HTMLGen_write,
    HTMLGen_start_element, HTMLGen_end_element,
    HTMLGen_put_entity
d632 8
a639 3
 *	-------------------------
 */
HTStructured *HTMLGenerator(HTStream *output)
d641 1
a641 2
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

d647 1
a647 1
    me->targetClass = *me->target->isa;		/* Copy pointers to routines for speed */
d652 1
a652 1
    me->cleanness = 0;
d655 1
a655 1
    me->preformatted = NO;
d659 1
a659 1
     * For what line length should we attempt to wrap ?  - kw
d662 1
a662 1
	me->buffer_maxchars = 80;	/* work as before - kw */
d664 1
a664 1
	me->buffer_maxchars = dump_output_width;	/* try to honor -width - kw */
d666 1
a666 1
	me->buffer_maxchars = 80;	/* try to honor -width - kw */
d668 2
a669 2
	me->buffer_maxchars = (LYcolLimit - 1);
	if (me->buffer_maxchars < 38)	/* too narrow, let GridText deal */
d672 1
a672 1
    if (me->buffer_maxchars > 900)	/* likely not true - kw */
d674 1
a674 1
    if (me->buffer_maxchars > BUFFER_SIZE)	/* must not be larger! */
d678 6
a683 5
     * If dump_output_immediately is set, there likely isn't anything after
     * this stream to interpret the Lynx special chars.  Also if they get
     * displayed via HTPlain, that will probably make non-breaking space chars
     * etc.  invisible.  So let's translate them to numerical character
     * references.  For debugging purposes we'll use the new hex format.
d688 1
a688 1
    me->text = NULL;		/* Will be initialized when first needed. - kw */
d697 7
a703 7
 *	-------------------
 *
 *	This object just converts a plain text stream into HTML
 *	It is officially a structured strem but only the stream bits exist.
 *	This is just the easiest way of typecasting all the routines.
 */
static const HTStructuredClass PlainToHTMLConversion =
d705 9
a713 9
    "plaintexttoHTML",
    HTMLGen_free,
    PlainToHTML_abort,
    HTMLGen_put_character,
    HTMLGen_put_string,
    HTMLGen_write,
    NULL,			/* Structured stuff */
    NULL,
    NULL
d717 6
a722 5
 *	------------------------------------------
 */
HTStream *HTPlainToHTML(HTPresentation *pres GCC_UNUSED,
			HTParentAnchor *anchor GCC_UNUSED,
			HTStream *sink)
d724 1
a724 2
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

d727 1
a727 1
    me->isa = (const HTStructuredClass *) &PlainToHTMLConversion;
d730 1
a730 1
     * Copy pointers to routines for speed.
d736 1
a736 1
    me->cleanness = 0;
d747 1
a747 1
    return (HTStream *) me;
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a35 1
#include <LYGlobalDefs.h>
d38 2
d86 1
a86 1
	HTStructured *,		me)
d95 1
a95 1
	HTStructured *,		me)
d135 1
a135 1
	HTStructured *,		me)
d180 1
a180 1
	HTStructured *,		me,
d183 1
a183 1
    if (me->escape_specials && UCH(c) < 32) {
d291 1
a291 1
	HTStructured *,		me,
d301 1
a301 1
	HTStructured *,		me,
d317 2
a318 2
PRIVATE int HTMLGen_start_element ARGS6(
	HTStructured *,		me,
a340 2
	    int len = strlen(myHash);
	    sprintf (myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
d342 2
d350 1
a350 1
	if (TRACE_STYLE)
d355 1
a355 1
		char *rp = strrchr(myHash, '.');
d360 1
a360 1
		    *rp = '\0'; /* trim the class */
d375 2
a376 3
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSSTRIM: start_element: top <%s>\n",
			  HTML_dtd.tags[element_number].name));
d415 1
a415 2
			CTRACE2(TRACE_STYLE,
				(tfp, "CSSTRIM:link=%s\n", title_tmp));
d489 5
a493 2
    /* end really empty tags straight away */
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number))
d495 1
a495 2
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:begin_element:ending EMPTY element style\n"));
d497 3
d501 1
a505 18
    if (element_number == HTML_OBJECT && tag->contents == SGML_LITTERAL) {
	/*
	 *  These conditions only approximate the ones used in HTML.c.
	 *  Let our SGML parser know that further content is to be parsed
	 *  normally not literally. - kw
	 */
	if (!present) {
	    return HT_PARSER_OTHER_CONTENT;
	} else if (!present[HTML_OBJECT_DECLARE] &&
		   !(present[HTML_OBJECT_NAME]  &&
		     value[HTML_OBJECT_NAME] && *value[HTML_OBJECT_NAME])) {
	    if (present[HTML_OBJECT_SHAPES] ||
		!(present[HTML_OBJECT_USEMAP] &&
		  value[HTML_OBJECT_USEMAP] && *value[HTML_OBJECT_USEMAP]))
		return HT_PARSER_OTHER_CONTENT;
	}
    }
    return HT_OK;
d519 2
a520 2
PRIVATE int HTMLGen_end_element ARGS3(
	HTStructured *,		me,
d547 3
a549 3
    if (LYPreparsedSource && !ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:end_element: ending non-EMPTY style\n"));
d551 3
d555 1
a557 1
    return HT_OK;
d565 1
a565 1
	HTStructured *,		me,
d583 1
a583 1
	HTStructured *,		me)
d595 1
a595 1
	HTStructured *,		me)
d602 1
a602 1
	HTStructured *,		me,
d612 1
a612 1
	HTStructured *,		me,
d635 2
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d44 1
a44 1
char class_string[TEMPSTRINGSIZE];
d55 1
a55 1
	const HTStreamClass *		isa;
d61 1
a61 1
	const HTStructuredClass *	isa;
d84 2
a85 2
static void flush_breaks (
	HTStructured *		me)
d93 2
a94 2
static void HTMLGen_flush (
	HTStructured *		me)
d133 2
a134 2
static void do_cstyle_flush (
	HTStructured *		me)
d150 4
a153 4
static void allow_break (
	HTStructured * me,
	int		new_cleanness,
	BOOL		dlbc)
d178 3
a180 3
static void HTMLGen_put_character (
	HTStructured *		me,
	char			c)
d289 3
a291 3
static void HTMLGen_put_string (
	HTStructured *		me,
	const char *		s)
d293 1
a293 1
    const char * p;
d299 4
a302 4
static void HTMLGen_write (
	HTStructured *		me,
	const char *		s,
	int			l)
d304 1
a304 1
    const char * p;
d316 7
a322 7
static int HTMLGen_start_element (
	HTStructured *		me,
	int			element_number,
	const BOOL*		present,
	const char **		value,
	int			charset GCC_UNUSED,
	char **			insert GCC_UNUSED)
d436 1
a436 1
			const char *p;
d532 4
a535 4
static int HTMLGen_end_element (
	HTStructured *		me,
	int			element_number,
	char **		insert GCC_UNUSED)
d574 3
a576 3
static int HTMLGen_put_entity (
	HTStructured *		me,
	int			entity_number)
d592 2
a593 2
static void HTMLGen_free (
	HTStructured *		me)
d604 2
a605 2
static void PlainToHTML_free (
	HTStructured *		me)
d611 3
a613 3
static void HTMLGen_abort (
	HTStructured *		me,
	HTError		e GCC_UNUSED)
d621 3
a623 3
static void PlainToHTML_abort (
	HTStructured *		me,
	HTError		e GCC_UNUSED)
d631 1
a631 1
static const HTStructuredClass HTMLGeneration = /* As opposed to print etc */
d646 2
a647 2
HTStructured * HTMLGenerator (
	HTStream *		output)
d711 1
a711 1
static const HTStructuredClass PlainToHTMLConversion =
d727 4
a730 4
HTStream* HTPlainToHTML (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor GCC_UNUSED,
	HTStream *		sink)
d735 1
a735 1
    me->isa = (const HTStructuredClass *)&PlainToHTMLConversion;
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 12
a13 12
 *		==============
 *
 *	This version of the HTML object sends HTML markup to the output stream.
 *
 * Bugs:	Line wrapping is not done at all.
 *		All data handled as PCDATA.
 *		Should convert old XMP, LISTING and PLAINTEXT to PRE.
 *
 *	It is not obvious to me right now whether the HEAD should be generated
 *	from the incomming data or the anchor.	Currently it is from the former
 *	which is cleanest.
 */
d52 2
a53 2
 *		-----------
 */
d55 3
a57 3
    const HTStreamClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */
d61 14
a74 14
    const HTStructuredClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */

    char buffer[BUFFER_SIZE + 1];	/* 1for NL */
    int buffer_maxchars;
    char *write_pointer;
    char *line_break[MAX_CLEANNESS + 1];
    int cleanness;
    BOOL overflowed;
    BOOL delete_line_break_char[MAX_CLEANNESS + 1];
    BOOL preformatted;
    BOOL escape_specials;
    BOOL in_attrval;
d76 1
a76 1
    HText *text;
d81 2
a82 2
 *	------------
 */
d84 2
a85 1
static void flush_breaks(HTStructured * me)
d88 1
a88 2

    for (i = 0; i <= MAX_CLEANNESS; i++) {
d93 2
a94 1
static void HTMLGen_flush(HTStructured * me)
d96 3
a98 3
    (*me->targetClass.put_block) (me->target,
				  me->buffer,
				  me->write_pointer - me->buffer);
d107 25
a131 22
 * We need to flush our buffer each time before we effect a color style change,
 * this also relies on the subsequent stage not doing any buffering - this is
 * currently true, in cases where it matters the target stream should be the
 * HTPlain converter.  The flushing currently prevents reasonable line breaking
 * in lines with tags.  Since color styles help visual scanning of displayed
 * source lines, and long lines are wrapped in GridText anyway, this is
 * probably acceptable (or even A Good Thing - more to see in one screenful). 
 * The pointer to the HText structure is initialized here before we effect the
 * first style change.  Getting it from the global HTMainText variable isn't
 * very clean, since it relies on the fact that HText_new() has already been
 * called for the current stream stack's document by the time we start
 * processing the first element; we rely on HTMLGenerator's callers
 * (HTMLParsedPresent in particular) to guarantee this when it matters. 
 * Normally the target stream will have been setup by HTPlainPresent, which
 * does what we need in this respect.  (A check whether we have the right
 * output stream could be done by checking that targetClass.name is
 * "PlainPresenter" or similar.)
 *
 * All special color style handling is only done if LYPreparsedSource is set. 
 * We could always do it for displaying source generated by an internal
 * gateway, but this makes the rule more simple for the user:  color styles are
 * applied to html source only with the -preparsed flag.  - kw
d133 2
a134 1
static void do_cstyle_flush(HTStructured * me)
d146 3
a148 3
 *
 *	We keep track of all the breaks for when we chop the line
 */
d150 4
a153 2
static void allow_break(HTStructured * me, int new_cleanness,
			BOOL dlbc)
d155 1
a155 2
    if (dlbc && me->write_pointer == me->buffer)
	dlbc = NO;
d157 2
a158 2
	dlbc ? me->write_pointer - 1	/* Point to space */
	: me->write_pointer;	/* point to gap */
d166 15
a180 13
 *	------------------
 *
 *	The tricky bits are the line break handling.  This attempts
 *	to synchrononise line breaks on sentence or phrase ends.  This
 *	is important if one stores SGML files in a line-oriented code
 *	repository, so that if a small change is made, line ends don't
 *	shift in a ripple-through to apparently change a large part of the
 *	file.  We give extra "cleanness" to spaces appearing directly
 *	after periods (full stops), [semi]colons and commas.
 *	   This should make the source files easier to read and modify
 *	by hand, too, though this is not a primary design consideration. TBL
 */
static void HTMLGen_put_character(HTStructured * me, char c)
d184 1
a184 1
	    c == LY_SOFT_HYPHEN) {	/* recursion... */
d188 2
a189 2
	    switch (c) {
	    case HT_NON_BREAK_SPACE:	/* &#xA0; */
d193 1
a193 1
	    case HT_EN_SPACE:	/* &#x2002; */
d199 1
a199 1
	    case LY_SOFT_HYPHEN:	/* &#xAD; */
d216 1
a216 1
     */
a218 1

d221 2
a222 3
	    char *p;

	    strcpy(delims, ",;:.");	/* @@@@ english bias */
d224 2
a225 4
	    if (p)
		new_cleanness = p - delims + 6;
	    if (!me->in_attrval)
		new_cleanness += 10;
d231 2
a232 2
     * Flush buffer out when full, or whenever the line is over the nominal
     * maximum and we can break at all
d238 1
a238 1
	    char *saved = me->line_break[me->cleanness];
d240 1
a240 2
	    if (me->delete_line_break_char[me->cleanness])
		saved++;
d242 3
a244 4
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  me->line_break[me->cleanness] -
					  me->buffer + 1);
d246 2
a247 2
	    {			/* move next line in */
		char *p = saved;
d249 1
a249 2

		for (q = me->buffer; p < me->write_pointer;)
d254 3
a256 3
	     * which weren't good enough for the last line but may be good
	     * enough for the next
	     */
d259 1
a259 2

		for (i = 0; i <= MAX_CLEANNESS; i++) {
d263 1
a263 1
			    (saved - me->buffer);
d272 1
a272 1
	    me->write_pointer = me->write_pointer - (saved - me->buffer);
d276 3
a278 3
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  me->buffer_maxchars);
d287 5
a291 3
 *	---------------
 */
static void HTMLGen_put_string(HTStructured * me, const char *s)
d293 1
a293 1
    const char *p;
d299 4
a302 2
static void HTMLGen_write(HTStructured * me, const char *s,
			  int l)
d304 1
a304 1
    const char *p;
d311 12
a322 10
 *	-------------
 *
 *	Within the opening tag, there may be spaces
 *	and the line may be broken at these spaces.
 */
static int HTMLGen_start_element(HTStructured * me, int element_number,
				 const BOOL *present,
				 const char **value,
				 int charset GCC_UNUSED,
				 char **insert GCC_UNUSED)
d326 1
a326 1
    HTTag *tag = &HTML_dtd.tags[element_number];
d334 1
a334 1
	 * Same logic as in HTML_start_element, copied from there.  - kw
d336 4
a339 3
	HTSprintf(&Style_className, ";%s", HTML_dtd.tags[element_number].name);
	strcpy(myHash, HTML_dtd.tags[element_number].name);
	if (class_string[0]) {
d341 2
a342 3

	    sprintf(myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
	    HTSprintf(&Style_className, ".%s", class_string);
d349 2
a350 1
	if (TRACE_STYLE) {
d352 2
a353 1
	    if (hashStyles[hcode].code != hcode) {
a354 1

d356 2
a357 1
		if (rp) {
d359 1
a359 2

		    *rp = '\0';	/* trim the class */
d362 1
a362 1
		    if (hashStyles[hcd].code != hcd)
d367 2
a368 1
	    } else
d372 1
a372 1
	if (displayStyles[element_number + STARTAT].color > -2)		/* actually set */
d376 1
a376 1
		     HTML_dtd.tags[element_number].name));
a386 1

d394 3
a396 3
		 * Try to mimic HTML_start_element's special handling for
		 * HTML_LINK.  If applicable, color the displayed attribute /
		 * value pairs differently.  - kw
d401 1
a401 1
		    value && *value[HTML_LINK_CLASS] != '\0' &&
d409 1
a409 1
		    if ((!title || *title == '\0') && present[HTML_LINK_REL]) {
d435 1
a435 1
		    } else {	/* attribute value has both kinds of quotes */
a436 1

d455 1
a455 1
	     * Clean up after special HTML_LINK handling - kw
d468 1
a468 1
    HTMLGen_put_string(me, ">");	/* got rid of \n LJM */
d471 1
a471 1
     * Make very specific HTML assumption that PRE can't be nested!
d473 1
a473 1
    me->preformatted = (element_number == HTML_PRE) ? YES : was_preformatted;
d476 1
a476 1
     * Can break after element start.
d484 1
d487 1
a487 1
     * Same logic as in HTML_start_element, copied from there.  - kw
d491 2
a492 1
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number)) {
d503 3
a505 3
	 * These conditions only approximate the ones used in HTML.c.  Let our
	 * SGML parser know that further content is to be parsed normally not
	 * literally.  - kw
d510 1
a510 1
		   !(present[HTML_OBJECT_NAME] &&
d522 3
a524 3
 *		-----------
 *
 */
d526 10
a535 8
 *	in effect before that element.	Note that anchors (etc?)
 *	don't have an associated style, so that we must scan down the
 *	stack for an element with a defined style. (In fact, the styles
 *	should be linked to the whole stack not just the top one.)
 *	TBL 921119
 */
static int HTMLGen_end_element(HTStructured * me, int element_number,
			       char **insert GCC_UNUSED)
d540 1
a540 1
	 * Can break before element end.
d555 1
a555 1
     * Same logic as in HTML_end_element, copied from there.  - kw
d571 6
a576 4
 *		------------------
 *
 */
static int HTMLGen_put_entity(HTStructured * me, int entity_number)
d582 1
a582 1
	HTMLGen_put_string(me, HTML_dtd.entity_names[entity_number]);
d589 5
a593 4
 *	-------------------
 *
 */
static void HTMLGen_free(HTStructured * me)
d595 1
a595 1
    (*me->targetClass.put_character) (me->target, '\n');
d597 1
a597 1
    (*me->targetClass._free) (me->target);	/* ripple through */
d604 2
a605 1
static void PlainToHTML_free(HTStructured * me)
d611 3
a613 1
static void HTMLGen_abort(HTStructured * me, HTError e GCC_UNUSED)
d621 3
a623 1
static void PlainToHTML_abort(HTStructured * me, HTError e GCC_UNUSED)
d629 3
a631 3
 *	-----------------------
 */
static const HTStructuredClass HTMLGeneration =		/* As opposed to print etc */
d633 6
a638 6
    "HTMLGen",
    HTMLGen_free,
    HTMLGen_abort,
    HTMLGen_put_character, HTMLGen_put_string, HTMLGen_write,
    HTMLGen_start_element, HTMLGen_end_element,
    HTMLGen_put_entity
d642 3
a644 3
 *	-------------------------
 */
extern int LYcols;		/* LYCurses.h, set in LYMain.c  */
d646 2
a647 1
HTStructured *HTMLGenerator(HTStream *output)
d649 1
a649 2
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

d655 1
a655 1
    me->targetClass = *me->target->isa;		/* Copy pointers to routines for speed */
d660 1
a660 1
    me->cleanness = 0;
d663 1
a663 1
    me->preformatted = NO;
d667 1
a667 1
     * For what line length should we attempt to wrap ?  - kw
d670 1
a670 1
	me->buffer_maxchars = 80;	/* work as before - kw */
d672 1
a672 1
	me->buffer_maxchars = dump_output_width;	/* try to honor -width - kw */
d674 1
a674 1
	me->buffer_maxchars = 80;	/* try to honor -width - kw */
d677 1
a677 1
	if (me->buffer_maxchars < 38)	/* too narrow, let GridText deal */
d680 1
a680 1
    if (me->buffer_maxchars > 900)	/* likely not true - kw */
d682 1
a682 1
    if (me->buffer_maxchars > BUFFER_SIZE)	/* must not be larger! */
d686 6
a691 5
     * If dump_output_immediately is set, there likely isn't anything after
     * this stream to interpret the Lynx special chars.  Also if they get
     * displayed via HTPlain, that will probably make non-breaking space chars
     * etc.  invisible.  So let's translate them to numerical character
     * references.  For debugging purposes we'll use the new hex format.
d696 1
a696 1
    me->text = NULL;		/* Will be initialized when first needed. - kw */
d705 6
a710 6
 *	-------------------
 *
 *	This object just converts a plain text stream into HTML
 *	It is officially a structured strem but only the stream bits exist.
 *	This is just the easiest way of typecasting all the routines.
 */
d713 9
a721 9
    "plaintexttoHTML",
    HTMLGen_free,
    PlainToHTML_abort,
    HTMLGen_put_character,
    HTMLGen_put_string,
    HTMLGen_write,
    NULL,			/* Structured stuff */
    NULL,
    NULL
d725 6
a730 5
 *	------------------------------------------
 */
HTStream *HTPlainToHTML(HTPresentation *pres GCC_UNUSED,
			HTParentAnchor *anchor GCC_UNUSED,
			HTStream *sink)
d732 1
a732 2
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

d735 1
a735 1
    me->isa = (const HTStructuredClass *) &PlainToHTMLConversion;
d738 1
a738 1
     * Copy pointers to routines for speed.
d744 1
a744 1
    me->cleanness = 0;
d755 1
a755 1
    return (HTStream *) me;
@


1.1.3.4
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a36 1
#include <LYCurses.h>
d626 2
d658 1
a658 1
	me->buffer_maxchars = (LYcolLimit - 1);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a35 1
#include <LYGlobalDefs.h>
d38 2
d86 1
a86 1
	HTStructured *,		me)
d95 1
a95 1
	HTStructured *,		me)
d135 1
a135 1
	HTStructured *,		me)
d180 1
a180 1
	HTStructured *,		me,
d183 1
a183 1
    if (me->escape_specials && UCH(c) < 32) {
d291 1
a291 1
	HTStructured *,		me,
d301 1
a301 1
	HTStructured *,		me,
d317 2
a318 2
PRIVATE int HTMLGen_start_element ARGS6(
	HTStructured *,		me,
a340 2
	    int len = strlen(myHash);
	    sprintf (myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
d342 2
d350 1
a350 1
	if (TRACE_STYLE)
d355 1
a355 1
		char *rp = strrchr(myHash, '.');
d360 1
a360 1
		    *rp = '\0'; /* trim the class */
d375 2
a376 3
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSSTRIM: start_element: top <%s>\n",
			  HTML_dtd.tags[element_number].name));
d415 1
a415 2
			CTRACE2(TRACE_STYLE,
				(tfp, "CSSTRIM:link=%s\n", title_tmp));
d489 5
a493 2
    /* end really empty tags straight away */
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number))
d495 1
a495 2
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:begin_element:ending EMPTY element style\n"));
d497 3
d501 1
a505 18
    if (element_number == HTML_OBJECT && tag->contents == SGML_LITTERAL) {
	/*
	 *  These conditions only approximate the ones used in HTML.c.
	 *  Let our SGML parser know that further content is to be parsed
	 *  normally not literally. - kw
	 */
	if (!present) {
	    return HT_PARSER_OTHER_CONTENT;
	} else if (!present[HTML_OBJECT_DECLARE] &&
		   !(present[HTML_OBJECT_NAME]  &&
		     value[HTML_OBJECT_NAME] && *value[HTML_OBJECT_NAME])) {
	    if (present[HTML_OBJECT_SHAPES] ||
		!(present[HTML_OBJECT_USEMAP] &&
		  value[HTML_OBJECT_USEMAP] && *value[HTML_OBJECT_USEMAP]))
		return HT_PARSER_OTHER_CONTENT;
	}
    }
    return HT_OK;
d519 2
a520 2
PRIVATE int HTMLGen_end_element ARGS3(
	HTStructured *,		me,
d547 3
a549 3
    if (LYPreparsedSource && !ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:end_element: ending non-EMPTY style\n"));
d551 3
d555 1
a557 1
    return HT_OK;
d565 1
a565 1
	HTStructured *,		me,
d583 1
a583 1
	HTStructured *,		me)
d595 1
a595 1
	HTStructured *,		me)
d602 1
a602 1
	HTStructured *,		me,
d612 1
a612 1
	HTStructured *,		me,
d635 2
@

