head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.8
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.6
	MIROS_X_BASE:1.4
	MIRBSD_XP_MIRPPC:1.4.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.4
	MIRBSD_XP_SPARC:1.4.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.48;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.21.17.06.14;	author tg;	state Stab;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.02;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.00;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.42;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.50;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.08.13.05.41;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.14;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.47.05;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTString.c,v 1.4 2004/07/21 17:06:14 tg Stab $ */

/*		Case-independent string comparison		HTString.c
 *
 *	Original version came with listserv implementation.
 *	Version TBL Oct 91 replaces one which modified the strings.
 *	02-Dec-91 (JFG) Added stralloccopy and stralloccat
 *	23 Jan 92 (TBL) Changed strallocc* to 8 char HTSAC* for VM and suchlike
 *	 6 Oct 92 (TBL) Moved WWW_TraceFlag in here to be in library
 *	15 Nov 98 (TD)  Added HTSprintf.
 */

#include <HTUtils.h>

#include <LYLeaks.h>
#include <LYStrings.h>

#ifndef NO_LYNX_TRACE
BOOLEAN WWW_TraceFlag = 0;	/* Global trace flag for ALL W3 code */
int WWW_TraceMask = 0;		/* Global trace flag for ALL W3 code */
#endif

#ifndef VC
#define VC "2.14"
#endif /* !VC */

#ifdef _WINDOWS
const char *HTLibraryVersion = "2.14FM";	/* String for help screen etc */

#else
const char *HTLibraryVersion = VC;	/* String for help screen etc */
#endif

/*
 *     strcasecomp8 is a variant of strcasecomp (below)
 *     ------------		    -----------
 *     but uses 8bit upper/lower case information
 *     from the current display charset.
 *     It returns 0 if exact match.
 */
int strcasecomp8(const char *a,
		 const char *b)
{
    const char *p = a;
    const char *q = b;

    for (; *p && *q; p++, q++) {
	int diff = UPPER8(*p, *q);

	if (diff)
	    return diff;
    }
    if (*p)
	return 1;		/* p was longer than q */
    if (*q)
	return -1;		/* p was shorter than q */
    return 0;			/* Exact match */
}

/*
 *     strncasecomp8 is a variant of strncasecomp (below)
 *     -------------		     ------------
 *     but uses 8bit upper/lower case information
 *     from the current display charset.
 *     It returns 0 if exact match.
 */
int strncasecomp8(const char *a,
		  const char *b,
		  int n)
{
    const char *p = a;
    const char *q = b;

    for (;; p++, q++) {
	int diff;

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
	if (!(*p && *q))
	    return (*p - *q);
	diff = UPPER8(*p, *q);
	if (diff)
	    return diff;
    }
    /*NOTREACHED */
}

#ifndef VM			/* VM has these already it seems */

#ifdef SH_EX			/* 1997/12/23 (Tue) 16:40:31 */

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static unsigned char charmap[] =
{
    '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
    '\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
    '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
    '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
    '\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
    '\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
    '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
    '\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
    '\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
    '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
    '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
    '\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
    '\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
    '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
    '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
    '\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
    '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
    '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
    '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
    '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
    '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
    '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
    '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
    '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
    '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
    '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
    '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\327',
    '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\337',
    '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
    '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
    '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
    '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};

int strcasecomp(const char *s1,
		const char *s2)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *) s1;
    register unsigned char *us2 = (unsigned char *) s2;

    while (cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return (0);
    return (cm[*us1] - cm[*--us2]);
}

int strncasecomp(const char *a,
		 const char *b,
		 int n)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *) a;
    register unsigned char *us2 = (unsigned char *) b;

    while ((long) (--n) >= 0 && cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return (0);
    return ((long) n < 0 ? 0 : cm[*us1] - cm[*--us2]);
}

int strcasecomp_asterisk(const char *a, const char *b)
{
	unsigned char *cm = charmap;
	unsigned char *us1 = (unsigned char *) a;
	unsigned char *us2 = (unsigned char *) b;

	if ((*a != '*') && (*b != '*'))
		return strcasecomp(a, b);

	if (*b == '*') {
		us1 = us2;
		us2 = (unsigned char *) a;
	}

	if (strlen(us2) < (strlen(us1) - 1))
		return 1;

	while (*++us1 != '\0')
		;
	while (*++us2 != '\0')
		;

	while (1) {
		if (cm[*--us1] != cm[*--us2])
			return 1;
		if ((*--us1) == '*')
			return 0;
		--us2;
	}
}

#else /* SH_EX */

/*	Strings of any length
 *	---------------------
 */
int strcasecomp(const char *a,
		const char *b)
{
    const char *p = a;
    const char *q = b;

    for (; *p && *q; p++, q++) {
	int diff = TOLOWER(*p) - TOLOWER(*q);

	if (diff)
	    return diff;
    }
    if (*p)
	return 1;		/* p was longer than q */
    if (*q)
	return -1;		/* p was shorter than q */
    return 0;			/* Exact match */
}

/*	With count limit
 *	----------------
 */
int strncasecomp(const char *a,
		 const char *b,
		 int n)
{
    const char *p = a;
    const char *q = b;

    for (;; p++, q++) {
	int diff;

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
	if (!(*p && *q))
	    return (*p - *q);
	diff = TOLOWER(*p) - TOLOWER(*q);
	if (diff)
	    return diff;
    }
    /*NOTREACHED */
}

int strcasecomp_asterisk(const char *a, const char *b)
{
	unsigned char *us1 = (unsigned char *) a;
	unsigned char *us2 = (unsigned char *) b;

	if ((*a != '*') && (*b != '*'))
		return strcasecomp(a, b);

	if (*b == '*') {
		us1 = us2;
		us2 = (unsigned char *) a;
	}

	if (strlen(us2) < (strlen(us1) - 1))
		return 1;

	while (*++us1 != '\0')
		;
	while (*++us2 != '\0')
		;

	while (1) {
		if (TOLOWER(*us1) != TOLOWER(*us2))
			return 1;
		if ((*--us1) == '*')
			return 0;
		--us2;
	}
}

#endif /* SH_EX */
#endif /* VM */

#ifdef NOT_ASCII

/*	Case-insensitive with ASCII collating sequence
 *	----------------
 */
int AS_casecomp(const char *p,
		const char *q)
{
    int diff;

    for (;; p++, q++) {
	if (!(*p && *q))
	    return (UCH(*p) - UCH(*q));
	diff = TOASCII(TOLOWER(*p))
	    - TOASCII(TOLOWER(*q));
	if (diff)
	    return diff;
    }
    /*NOTREACHED */
}

/*	With count limit and ASCII collating sequence
 *	----------------
 *	AS_cmp uses n == -1 to compare indefinite length.
 */
int AS_ncmp(const char *p,
	    const char *q,
	    unsigned int n)
{
    const char *a = p;
    int diff;

    for (; (unsigned) (p - a) < n; p++, q++) {
	if (!(*p && *q))
	    return (UCH(*p) - UCH(*q));
	diff = TOASCII(*p)
	    - TOASCII(*q);
	if (diff)
	    return diff;
    }
    return 0;			/*   Match up to n characters */
}
#endif /* NOT_ASCII */

/*	Allocate a new copy of a string, and returns it
*/
char *HTSACopy(char **dest,
	       const char *src)
{
    if (src != 0) {
	if (src != *dest) {
	    size_t size = strlen(src) + 1;

	    FREE(*dest);
	    *dest = (char *) malloc(size);
	    if (*dest == NULL)
		outofmem(__FILE__, "HTSACopy");
	    memcpy(*dest, src, size);
	}
    } else {
	FREE(*dest);
    }
    return *dest;
}

/*	String Allocate and Concatenate
*/
char *HTSACat(char **dest,
	      const char *src)
{
    if (src && *src && (src != *dest)) {
	if (*dest) {
	    size_t length = strlen(*dest);

	    *dest = (char *) realloc(*dest, length + strlen(src) + 1);
	    if (*dest == NULL)
		outofmem(__FILE__, "HTSACat");
	    strcpy(*dest + length, src);
	} else {
	    *dest = (char *) malloc(strlen(src) + 1);
	    if (*dest == NULL)
		outofmem(__FILE__, "HTSACat");
	    strcpy(*dest, src);
	}
    }
    return *dest;
}

/* optimized for heavily realloc'd strings, store length inside */

#define EXTRA_TYPE size_t	/* type we use for length */
#define EXTRA_SIZE sizeof(void *)	/* alignment >= sizeof(EXTRA_TYPE) */

void HTSAFree_extra(char *s)
{
    free(s - EXTRA_SIZE);
}

/* never shrink */
char *HTSACopy_extra(char **dest,
		     const char *src)
{
    if (src != 0) {
	size_t srcsize = strlen(src) + 1;
	EXTRA_TYPE size = 0;

	if (*dest != 0) {
	    size = *(EXTRA_TYPE *) ((*dest) - EXTRA_SIZE);
	}
	if (size < srcsize) {
	    FREE_extra(*dest);
	    size = srcsize * 2;	/* x2 step */
	    *dest = (char *) malloc(size + EXTRA_SIZE);
	    if (*dest == NULL)
		outofmem(__FILE__, "HTSACopy_extra");
	    *(EXTRA_TYPE *) (*dest) = size;
	    *dest += EXTRA_SIZE;
	}
	memcpy(*dest, src, srcsize);
    } else {
	Clear_extra(*dest);
    }
    return *dest;
}

/*	Find next Field
 *	---------------
 *
 * On entry,
 *	*pstr	points to a string containig white space separated
 *		field, optionlly quoted.
 *
 * On exit,
 *	*pstr	has been moved to the first delimiter past the
 *		field
 *		THE STRING HAS BEEN MUTILATED by a 0 terminator
 *
 *	returns a pointer to the first field
 */
char *HTNextField(char **pstr)
{
    char *p = *pstr;
    char *start;		/* start of field */

    while (*p && WHITE(*p))
	p++;			/* Strip white space */
    if (!*p) {
	*pstr = p;
	return NULL;		/* No first field */
    }
    if (*p == '"') {		/* quoted field */
	p++;
	start = p;
	for (; *p && *p != '"'; p++) {
	    if (*p == '\\' && p[1])
		p++;		/* Skip escaped chars */
	}
    } else {
	start = p;
	while (*p && !WHITE(*p))
	    p++;		/* Skip first field */
    }
    if (*p)
	*p++ = '\0';
    *pstr = p;
    return start;
}

/*	Find next Token
 *	---------------
 *	Finds the next token in a string
 *	On entry,
 *	*pstr	points to a string to be parsed.
 *	delims	lists characters to be recognized as delimiters.
 *		If NULL, default is white space "," ";" or "=".
 *		The word can optionally be quoted or enclosed with
 *		chars from bracks.
 *		Comments surrrounded by '(' ')' are filtered out
 *		unless they are specifically reqested by including
 *		' ' or '(' in delims or bracks.
 *	bracks	lists bracketing chars.  Some are recognized as
 *		special, for those give the opening char.
 *		If NULL, defaults to <"> and "<" ">".
 *	found	points to location to fill with the ending delimiter
 *		found, or is NULL.
 *
 *	On exit,
 *	*pstr	has been moved to the first delimiter past the
 *		field
 *		THE STRING HAS BEEN MUTILATED by a 0 terminator
 *	found	points to the delimiter found unless it was NULL.
 *	Returns a pointer to the first word or NULL on error
 */
char *HTNextTok(char **pstr,
		const char *delims,
		const char *bracks,
		char *found)
{
    char *p = *pstr;
    char *start = NULL;
    BOOL get_blanks, skip_comments;
    BOOL get_comments;
    BOOL get_closing_char_too = FALSE;
    char closer;

    if (isEmpty(pstr))
	return NULL;
    if (!delims)
	delims = " ;,=";
    if (!bracks)
	bracks = "<\"";

    get_blanks = (BOOL) (!strchr(delims, ' ') && !strchr(bracks, ' '));
    get_comments = (BOOL) (strchr(bracks, '(') != NULL);
    skip_comments = (BOOL) (!get_comments && !strchr(delims, '(') && !get_blanks);
#define skipWHITE(c) (!get_blanks && WHITE(c))

    while (*p && skipWHITE(*p))
	p++;			/* Strip white space */
    if (!*p) {
	*pstr = p;
	if (found)
	    *found = '\0';
	return NULL;		/* No first field */
    }
    while (1) {
	/* Strip white space and other delimiters */
	while (*p && (skipWHITE(*p) || strchr(delims, *p)))
	    p++;
	if (!*p) {
	    *pstr = p;
	    if (found)
		*found = *(p - 1);
	    return NULL;	/* No field */
	}

	if (*p == '(' && (skip_comments || get_comments)) {	/* Comment */
	    int comment_level = 0;

	    if (get_comments && !start)
		start = p + 1;
	    for (; *p && (*p != ')' || --comment_level > 0); p++) {
		if (*p == '(')
		    comment_level++;
		else if (*p == '"') {	/* quoted field within Comment */
		    for (p++; *p && *p != '"'; p++)
			if (*p == '\\' && *(p + 1))
			    p++;	/* Skip escaped chars */
		    if (!*p)
			break;	/* (invalid) end of string found, leave */
		}
		if (*p == '\\' && *(p + 1))
		    p++;	/* Skip escaped chars */
	    }
	    if (get_comments)
		break;
	    if (*p)
		p++;
	    if (get_closing_char_too) {
		if (!*p || (!strchr(bracks, *p) && strchr(delims, *p))) {
		    break;
		} else
		    get_closing_char_too = (BOOL) (strchr(bracks, *p) != NULL);
	    }
	} else if (strchr(bracks, *p)) {	/* quoted or bracketed field */
	    switch (*p) {
	    case '<':
		closer = '>';
		break;
	    case '[':
		closer = ']';
		break;
	    case '{':
		closer = '}';
		break;
	    case ':':
		closer = ';';
		break;
	    default:
		closer = *p;
	    }
	    if (!start)
		start = ++p;
	    for (; *p && *p != closer; p++)
		if (*p == '\\' && *(p + 1))
		    p++;	/* Skip escaped chars */
	    if (get_closing_char_too) {
		p++;
		if (!*p || (!strchr(bracks, *p) && strchr(delims, *p))) {
		    break;
		} else
		    get_closing_char_too = (BOOL) (strchr(bracks, *p) != NULL);
	    } else
		break;		/* kr95-10-9: needs to stop here */
	} else {		/* Spool field */
	    if (!start)
		start = p;
	    while (*p && !skipWHITE(*p) && !strchr(bracks, *p) &&
		   !strchr(delims, *p))
		p++;
	    if (*p && strchr(bracks, *p)) {
		get_closing_char_too = TRUE;
	    } else {
		if (*p == '(' && skip_comments) {
		    *pstr = p;
		    HTNextTok(pstr, NULL, "(", found);	/*      Advance pstr */
		    *p = '\0';
		    if (*pstr && **pstr)
			(*pstr)++;
		    return start;
		}
		break;		/* Got it */
	    }
	}
    }
    if (found)
	*found = *p;

    if (*p)
	*p++ = '\0';
    *pstr = p;
    return start;
}

static char *HTAlloc(char *ptr, size_t length)
{
    if (ptr != 0)
	ptr = (char *) realloc(ptr, length);
    else
	ptr = (char *) malloc(length);
    if (ptr == 0)
	outofmem(__FILE__, "HTAlloc");
    return ptr;
}

/*
 * If SAVE_TIME_NOT_SPACE is defined, StrAllocVsprintf will hang on to
 * its temporary string buffers instead of allocating and freeing them
 * in each invocation.  They only grow and never shrink, and won't be
 * cleaned up on exit. - kw
 */
#if defined(_REENTRANT) || defined(_THREAD_SAFE) || defined(LY_FIND_LEAKS)
#undef SAVE_TIME_NOT_SPACE
#endif

/*
 * Replacement for sprintf, allocates buffer on the fly according to what's
 * needed for its arguments.  Unlike sprintf, this always concatenates to the
 * destination buffer, so we do not have to provide both flavors.
 */
typedef enum {
    Flags,
    Width,
    Prec,
    Type,
    Format
} PRINTF;

#define VA_INTGR(type) ival = va_arg((*ap), type)
#define VA_FLOAT(type) fval = va_arg((*ap), type)
#define VA_POINT(type) pval = (char *)va_arg((*ap), type)

#define NUM_WIDTH 10		/* allow for width substituted for "*" in "%*s" */
		/* also number of chars assumed to be needed in addition
		   to a given precision in floating point formats */

#define GROW_EXPR(n) (((n) * 3) / 2)
#define GROW_SIZE 256

PUBLIC_IF_FIND_LEAKS char *StrAllocVsprintf(char **pstr,
					    size_t dst_len,
					    const char *fmt,
					    va_list * ap)
{
#ifdef SAVE_TIME_NOT_SPACE
    static size_t tmp_len = 0;
    static size_t fmt_len = 0;
    static char *tmp_ptr = NULL;
    static char *fmt_ptr = NULL;

#else
    size_t tmp_len = GROW_SIZE;
    char *tmp_ptr = 0;
    char *fmt_ptr;
#endif /* SAVE_TIME_NOT_SPACE */
    size_t have, need;
    char *dst_ptr = *pstr;
    const char *format = fmt;

    if (fmt == 0 || *fmt == '\0')
	return 0;

#ifdef USE_VASPRINTF
    if (pstr && !dst_len) {
	if (*pstr)
	    FREE(*pstr);
	if (vasprintf(pstr, fmt, *ap) >= 0) {
	    mark_malloced(*pstr, strlen(*pstr) + 1);
	    return (*pstr);
	}
    }
#endif /* USE_VASPRINTF */

    need = strlen(fmt) + 1;
#ifdef SAVE_TIME_NOT_SPACE
    if (!fmt_ptr || fmt_len < need * NUM_WIDTH) {
	fmt_ptr = HTAlloc(fmt_ptr, fmt_len = need * NUM_WIDTH);
    }
    if (!tmp_ptr || tmp_len < GROW_SIZE) {
	tmp_ptr = HTAlloc(tmp_ptr, tmp_len = GROW_SIZE);
    }
#else
    if ((fmt_ptr = malloc(need * NUM_WIDTH)) == 0
	|| (tmp_ptr = malloc(tmp_len)) == 0) {
	outofmem(__FILE__, "StrAllocVsprintf");
    }
#endif /* SAVE_TIME_NOT_SPACE */

    if (dst_ptr == 0) {
	dst_ptr = HTAlloc(dst_ptr, have = GROW_SIZE + need);
    } else {
	have = strlen(dst_ptr) + 1;
	need += dst_len;
	if (have < need)
	    dst_ptr = HTAlloc(dst_ptr, have = GROW_SIZE + need);
    }

    while (*fmt != '\0') {
	if (*fmt == '%') {
	    static char dummy[] = "";
	    PRINTF state = Flags;
	    char *pval = dummy;	/* avoid const-cast */
	    double fval = 0.0;
	    int done = FALSE;
	    int ival = 0;
	    int prec = -1;
	    int type = 0;
	    int used = 0;
	    int width = -1;
	    size_t f = 0;

	    fmt_ptr[f++] = *fmt;
	    while (*++fmt != '\0' && !done) {
		fmt_ptr[f++] = *fmt;

		if (isdigit(UCH(*fmt))) {
		    int num = *fmt - '0';

		    if (state == Flags && num != 0)
			state = Width;
		    if (state == Width) {
			if (width < 0)
			    width = 0;
			width = (width * 10) + num;
		    } else if (state == Prec) {
			if (prec < 0)
			    prec = 0;
			prec = (prec * 10) + num;
		    }
		} else if (*fmt == '*') {
		    VA_INTGR(int);

		    if (state == Flags)
			state = Width;
		    if (state == Width) {
			width = ival;
		    } else if (state == Prec) {
			prec = ival;
		    }
		    sprintf(&fmt_ptr[--f], "%d", ival);
		    f = strlen(fmt_ptr);
		} else if (isalpha(UCH(*fmt))) {
		    done = TRUE;
		    switch (*fmt) {
		    case 'Z':	/* FALLTHRU */
		    case 'h':	/* FALLTHRU */
		    case 'l':	/* FALLTHRU */
		    case 'L':	/* FALLTHRU */
			done = FALSE;
			type = *fmt;
			break;
		    case 'o':	/* FALLTHRU */
		    case 'i':	/* FALLTHRU */
		    case 'd':	/* FALLTHRU */
		    case 'u':	/* FALLTHRU */
		    case 'x':	/* FALLTHRU */
		    case 'X':	/* FALLTHRU */
			if (type == 'l')
			    VA_INTGR(long);

			else if (type == 'Z')
			    VA_INTGR(size_t);
			else
			    VA_INTGR(int);

			used = 'i';
			break;
		    case 'f':	/* FALLTHRU */
		    case 'e':	/* FALLTHRU */
		    case 'E':	/* FALLTHRU */
		    case 'g':	/* FALLTHRU */
		    case 'G':	/* FALLTHRU */
			VA_FLOAT(double);

			used = 'f';
			break;
		    case 'c':
			VA_INTGR(int);

			used = 'c';
			break;
		    case 's':
			VA_POINT(char *);

			if (prec < 0)
			    prec = strlen(pval);
			used = 's';
			break;
		    case 'p':
			VA_POINT(void *);

			used = 'p';
			break;
		    case 'n':
			VA_POINT(int *);

			used = 0;
			break;
		    default:
			CTRACE((tfp, "unknown format character '%c' in %s\n",
				*fmt, format));
			break;
		    }
		} else if (*fmt == '.') {
		    state = Prec;
		} else if (*fmt == '%') {
		    done = TRUE;
		    used = '%';
		}
	    }
	    fmt_ptr[f] = '\0';

	    if (prec > 0) {
		switch (used) {
		case 'f':
		    if (width < prec + NUM_WIDTH)
			width = prec + NUM_WIDTH;
		    /* FALLTHRU */
		case 'i':
		    /* FALLTHRU */
		case 'p':
		    if (width < prec + 2)
			width = prec + 2;	/* leading sign/space/zero, "0x" */
		    break;
		case 'c':
		    break;
		case '%':
		    break;
		default:
		    if (width < prec)
			width = prec;
		    break;
		}
	    }
	    if (width >= (int) tmp_len) {
		tmp_len = GROW_EXPR(tmp_len + width);
		tmp_ptr = HTAlloc(tmp_ptr, tmp_len);
	    }

	    switch (used) {
	    case 'i':
	    case 'c':
		sprintf(tmp_ptr, fmt_ptr, ival);
		break;
	    case 'f':
		sprintf(tmp_ptr, fmt_ptr, fval);
		break;
	    default:
		sprintf(tmp_ptr, fmt_ptr, pval);
		break;
	    }
	    need = dst_len + strlen(tmp_ptr) + 1;
	    if (need >= have) {
		dst_ptr = HTAlloc(dst_ptr, have = GROW_EXPR(need));
	    }
	    strcpy(dst_ptr + dst_len, tmp_ptr);
	    dst_len += strlen(tmp_ptr);
	} else {
	    if ((dst_len + 2) >= have) {
		dst_ptr = HTAlloc(dst_ptr, (have += GROW_SIZE));
	    }
	    dst_ptr[dst_len++] = *fmt++;
	}
    }

#ifndef SAVE_TIME_NOT_SPACE
    FREE(tmp_ptr);
    FREE(fmt_ptr);
#endif
    dst_ptr[dst_len] = '\0';
    if (pstr)
	*pstr = dst_ptr;
    return (dst_ptr);
}
#undef SAVE_TIME_NOT_SPACE

/*
 * Replacement for sprintf, allocates buffer on the fly according to what's
 * needed for its arguments.  Unlike sprintf, this always concatenates to the
 * destination buffer.
 */
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf in LYLeaks.c. - kw */
#ifdef HTSprintf		/* if hidden by LYLeaks stuff */
#undef HTSprintf
#endif
char *HTSprintf(char **pstr, const char *fmt,...)
{
    char *result = 0;
    size_t inuse = 0;
    va_list ap;

    LYva_start(ap, fmt);
    {
	if (pstr != 0 && *pstr != 0)
	    inuse = strlen(*pstr);
	result = StrAllocVsprintf(pstr, inuse, fmt, &ap);
    }
    va_end(ap);

    return (result);
}

/*
 * Replacement for sprintf, allocates buffer on the fly according to what's
 * needed for its arguments.  Like sprintf, this always resets the destination
 * buffer.
 */
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf0 in LYLeaks.c. - kw */
#ifdef HTSprintf0		/* if hidden by LYLeaks stuff */
#undef HTSprintf0
#endif
char *HTSprintf0(char **pstr, const char *fmt,...)
{
    char *result = 0;
    va_list ap;

    LYva_start(ap, fmt);
    {
#ifdef USE_VASPRINTF
	if (pstr) {
	    if (*pstr)
		FREE(*pstr);
	    if (vasprintf(pstr, fmt, ap) >= 0)	/* else call outofmem?? */
		mark_malloced(*pstr, strlen(*pstr) + 1);
	    result = *pstr;
	} else
#endif /* USE_VASPRINTF */
	    result = StrAllocVsprintf(pstr, 0, fmt, &ap);
    }
    va_end(ap);

    return (result);
}

/*
 * Returns a quoted or escaped form of the given parameter, suitable for use in
 * a command string.
 */
#if USE_QUOTED_PARAMETER
#define S_QUOTE '\''
#define D_QUOTE '"'
char *HTQuoteParameter(const char *parameter)
{
    size_t i;
    size_t last;
    size_t n = 0;
    size_t quoted = 0;
    char *result;

    if (parameter == 0)
	parameter = "";

    last = strlen(parameter);
    for (i = 0; i < last; ++i)
	if (strchr("\\&#$^*?(){}<>\"';`|", parameter[i]) != 0
	    || isspace(UCH(parameter[i])))
	    ++quoted;

    result = (char *) malloc(last + 5 * quoted + 3);
    if (result == NULL)
	outofmem(__FILE__, "HTQuoteParameter");

    n = 0;
    if (quoted)
	result[n++] = S_QUOTE;
    for (i = 0; i < last; i++) {
	if (parameter[i] == S_QUOTE) {
	    result[n++] = S_QUOTE;
	    result[n++] = D_QUOTE;
	    result[n++] = parameter[i];
	    result[n++] = D_QUOTE;
	    result[n++] = S_QUOTE;
	} else {
	    /* Note:  No special handling of other characters, including
	       backslash, since we are constructing a single-quoted string!
	       Backslash has no special escape meaning within those for sh
	       and compatible shells, so trying to escape a backslash by
	       doubling it is unnecessary and would be interpreted by the
	       shell as an additional data character. - kw 2000-05-02
	     */
	    result[n++] = parameter[i];
	}
    }
    if (quoted)
	result[n++] = S_QUOTE;
    result[n] = '\0';
    return result;
}
#endif

#define HTIsParam(string) ((string[0] == '%' && string[1] == 's'))

/*
 * Returns the number of "%s" tokens in a system command-template.
 */
int HTCountCommandArgs(const char *command)
{
    int number = 0;

    while (command[0] != 0) {
	if (HTIsParam(command))
	    number++;
	command++;
    }
    return number;
}

/*
 * Returns a pointer into the given string after the given parameter number
 */
static const char *HTAfterCommandArg(const char *command,
				     int number)
{
    while (number > 0) {
	if (command[0] != 0) {
	    if (HTIsParam(command)) {
		number--;
		command++;
	    }
	    command++;
	} else {
	    break;
	}
    }
    return command;
}

/*
 * Like HTAddParam, but the parameter may be an environment variable, which we
 * will expand and append.  Do this only for things like the command-verb,
 * where we obtain the parameter from the user's configuration.  Any quoting
 * required for the environment variable has to be done within its value, e.g.,
 *
 *	setenv EDITOR 'xvile -name "No such class"'
 *
 * This is useful only when we quote parameters, of course.
 */
#if USE_QUOTED_PARAMETER
void HTAddXpand(char **result,
		const char *command,
		int number,
		const char *parameter)
{
    if (number > 0) {
	const char *last = HTAfterCommandArg(command, number - 1);
	const char *next = last;

	if (number <= 1) {
	    FREE(*result);
	}

	while (next[0] != 0) {
	    if (HTIsParam(next)) {
		if (next != last) {
		    size_t len = (next - last)
		    + ((*result != 0) ? strlen(*result) : 0);

		    HTSACat(result, last);
		    (*result)[len] = 0;
		}
		HTSACat(result, parameter);
		CTRACE((tfp, "PARAM-EXP:%s\n", *result));
		return;
	    }
	    next++;
	}
    }
}
#endif /* USE_QUOTED_PARAMETER */

/*
 * Append string to a system command that we are constructing, without quoting. 
 * We're given the index of the newest parameter we're processing.  Zero
 * indicates none, so a value of '1' indicates that we copy from the beginning
 * of the command string up to the first parameter, substitute the quoted
 * parameter and return the result.
 *
 * Parameters are substituted at "%s" tokens, like printf.  Other printf-style
 * tokens are not substituted; they are passed through without change.
 */
void HTAddToCmd(char **result,
		const char *command,
		int number,
		const char *string)
{
    if (number > 0) {
	const char *last = HTAfterCommandArg(command, number - 1);
	const char *next = last;

	if (number <= 1) {
	    FREE(*result);
	}
	if (string == 0)
	    string = "";
	while (next[0] != 0) {
	    if (HTIsParam(next)) {
		if (next != last) {
		    size_t len = (next - last)
		    + ((*result != 0) ? strlen(*result) : 0);

		    HTSACat(result, last);
		    (*result)[len] = 0;
		}
		HTSACat(result, string);
		CTRACE((tfp, "PARAM-ADD:%s\n", *result));
		return;
	    }
	    next++;
	}
    }
}

/*
 * Append string-parameter to a system command that we are constructing.  The
 * string is a complete parameter (which is a necessary assumption so we can
 * quote it properly).
 */
void HTAddParam(char **result,
		const char *command,
		int number,
		const char *parameter)
{
    if (number > 0) {
#if USE_QUOTED_PARAMETER
	char *quoted = HTQuoteParameter(parameter);

	HTAddToCmd(result, command, number, quoted);
	FREE(quoted);
#else
	HTAddToCmd(result, command, number, parameter);
#endif
    }
}

/*
 * Append the remaining command-string to a system command (compare with
 * HTAddParam).  Any remaining "%s" tokens are copied as empty strings.
 */
void HTEndParam(char **result,
		const char *command,
		int number)
{
    const char *last;
    int count;

    count = HTCountCommandArgs(command);
    if (count < number)
	number = count;
    last = HTAfterCommandArg(command, number);
    if (last[0] != 0) {
	HTSACat(result, last);
    }
    CTRACE((tfp, "PARAM-END:%s\n", *result));
}

/* Binary-strings (may have embedded nulls).  Some modules (HTGopher) assume
 * there is a null on the end, anyway.
 */

/* Allocate a new bstring, and return it.
*/
void HTSABCopy(bstring **dest, const char *src,
	       int len)
{
    bstring *t;
    unsigned need = len + 1;

    CTRACE2(TRACE_BSTRING, (tfp, "HTSABCopy(%p, %p, %d)\n", dest, src, len));
    HTSABFree(dest);
    if (src) {
	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if ((t = (bstring *) malloc(sizeof(bstring))) == NULL)
	      outofmem(__FILE__, "HTSABCopy");

	if ((t->str = (char *) malloc(need)) == NULL)
	    outofmem(__FILE__, "HTSABCopy");
	memcpy(t->str, src, len);
	t->len = len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/*
 * Initialize with a null-terminated string (discards the null).
 */
void HTSABCopy0(bstring **dest, const char *src)
{
    HTSABCopy(dest, src, strlen(src));
}

/*
 * Append a block of memory to a bstring.
 */
void HTSABCat(bstring **dest, const char *src,
	      int len)
{
    bstring *t = *dest;

    CTRACE2(TRACE_BSTRING, (tfp, "HTSABCat(%p, %p, %d)\n", dest, src, len));
    if (src) {
	unsigned need = len + 1;

	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if (t) {
	    unsigned length = t->len + need;

	    if ((t->str = (char *) realloc(t->str, length)) == NULL)
		outofmem(__FILE__, "HTSACat");
	} else {
	    if ((t = typecalloc(bstring)) == NULL)
		  outofmem(__FILE__, "HTSACat");

	    t->str = (char *) malloc(need);
	}
	if (t->str == NULL)
	    outofmem(__FILE__, "HTSACat");
	memcpy(t->str + t->len, src, len);
	t->len += len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/*
 * Append a null-terminated string (discards the null).
 */
void HTSABCat0(bstring **dest, const char *src)
{
    HTSABCat(dest, src, strlen(src));
}

/*
 * Compare two bstring's for equality
 */
BOOL HTSABEql(bstring *a, bstring *b)
{
    unsigned len_a = (a != 0) ? a->len : 0;
    unsigned len_b = (b != 0) ? b->len : 0;

    if (len_a == len_b) {
	if (len_a == 0
	    || memcmp(a->str, b->str, a->len) == 0)
	    return TRUE;
    }
    return FALSE;
}

/*
 * Deallocate a bstring.
 */
void HTSABFree(bstring **ptr)
{
    if (*ptr != NULL) {
	FREE((*ptr)->str);
	FREE(*ptr);
	*ptr = NULL;
    }
}

/*
 * Use this function to perform formatted sprintf's onto the end of a bstring.
 * The bstring may contain embedded nulls; the formatted portions must not.
 */
bstring *HTBprintf(bstring **pstr, const char *fmt,...)
{
    bstring *result = 0;
    char *temp = 0;
    va_list ap;

    LYva_start(ap, fmt);
    {
	temp = StrAllocVsprintf(&temp, 0, fmt, &ap);
	if (!isEmpty(temp)) {
	    HTSABCat(pstr, temp, strlen(temp));
	}
	FREE(temp);
	result = *pstr;
    }
    va_end(ap);

    return (result);
}

/*
 * Write binary-data to the logfile, making it safe for most editors to view.
 * That is most, since we do not restrict line-length.  Nulls and other
 * non-printing characters are addressed.
 */
void trace_bstring2(const char *text,
		    int size)
{
    int n;

    if (text != 0) {
	for (n = 0; n < size; ++n) {
	    int ch = UCH(text[n]);

	    switch (ch) {
	    case '\\':
		fputs("\\\\", tfp);
		break;
	    case '\r':
		fputs("\\r", tfp);
		break;
	    case '\t':
		fputs("\\t", tfp);
		break;
	    case '\f':
		fputs("\\f", tfp);
		break;
	    default:
		if (isprint(ch) || isspace(ch)) {
		    fputc(ch, tfp);
		} else {
		    fprintf(tfp, "\\%03o", ch);
		}
		break;
	    }
	}
    }
}

void trace_bstring(bstring *data)
{
    trace_bstring2(BStrData(data), BStrLen(data));
}
@


1.4
log
@developed just now, between end of RCS and start of CVS mergers,
by yours truly: SSL Certificate CN wildcard matching! :-)

will be submitted upstream
@
text
@d1 1
a1 1
/* $MirBSD$ */
d24 1
a24 1
#define VC "unknown"
d632 1
a632 1
#define VA_POINT(type) pval = (void *)va_arg((*ap), type)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 2
d4 8
a11 8
**
**	Original version came with listserv implementation.
**	Version TBL Oct 91 replaces one which modified the strings.
**	02-Dec-91 (JFG) Added stralloccopy and stralloccat
**	23 Jan 92 (TBL) Changed strallocc* to 8 char HTSAC* for VM and suchlike
**	 6 Oct 92 (TBL) Moved WWW_TraceFlag in here to be in library
**	15 Nov 98 (TD)  Added HTSprintf.
*/
d19 2
a20 2
PUBLIC BOOLEAN WWW_TraceFlag = 0;	/* Global trace flag for ALL W3 code */
PUBLIC int WWW_TraceMask = 0;		/* Global trace flag for ALL W3 code */
d28 2
a29 1
CONST char * HTLibraryVersion = "2.14FM"; /* String for help screen etc */
d31 1
a31 1
PUBLIC CONST char * HTLibraryVersion = VC; /* String for help screen etc */
d35 8
a42 9
**     strcasecomp8 is a variant of strcasecomp (below)
**     ------------		    -----------
**     but uses 8bit upper/lower case information
**     from the current display charset.
**     It returns 0 if exact match.
*/
PUBLIC int strcasecomp8 ARGS2(
       CONST char*,    a,
       CONST char *,   b)
d44 2
a45 2
    CONST char *p = a;
    CONST char *q = b;
d47 1
a47 1
    for ( ; *p && *q; p++, q++) {
d49 3
a51 1
	if (diff) return diff;
d54 1
a54 1
	return 1;	/* p was longer than q */
d56 2
a57 2
	return -1;	/* p was shorter than q */
    return 0;		/* Exact match */
d61 9
a69 10
**     strncasecomp8 is a variant of strncasecomp (below)
**     -------------		     ------------
**     but uses 8bit upper/lower case information
**     from the current display charset.
**     It returns 0 if exact match.
*/
PUBLIC int strncasecomp8 ARGS3(
	CONST char*,	a,
	CONST char *,	b,
	int,		n)
d71 2
a72 2
    CONST char *p = a;
    CONST char *q = b;
d74 1
a74 1
    for ( ; ; p++, q++) {
d76 3
a78 2
	if (p == (a+n))
	    return 0;	/*   Match up to n characters */
d85 1
a85 1
    /*NOTREACHED*/
d88 1
a88 1
#ifndef VM		/* VM has these already it seems */
d90 1
a90 1
#ifdef SH_EX	/* 1997/12/23 (Tue) 16:40:31 */
d97 34
a130 33
static unsigned char charmap[] = {
	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\327',
	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\337',
	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
d133 2
a134 3
PUBLIC int strcasecomp ARGS2(
	CONST char*,	s1,
	CONST char*,	s2)
d137 2
a138 2
    register unsigned char *us1 = (unsigned char *)s1;
    register unsigned char *us2 = (unsigned char *)s2;
d142 1
a142 1
	    return(0);
d146 3
a148 4
PUBLIC int strncasecomp ARGS3(
	CONST char*,	a,
	CONST char*,	b,
	int,		n)
d151 2
a152 2
    register unsigned char *us1 = (unsigned char *)a;
    register unsigned char *us2 = (unsigned char *)b;
d154 1
a154 1
    while ((long)(--n) >= 0 && cm[*us1] == cm[*us2++])
d156 2
a157 2
	    return(0);
    return ((long)n < 0 ? 0 : cm[*us1] - cm[*--us2]);
d160 32
a191 1
#else	/* SH_EX */
d194 4
a197 5
**	---------------------
*/
PUBLIC int strcasecomp ARGS2(
	CONST char*,	a,
	CONST char *,	b)
d199 2
a200 2
    CONST char *p = a;
    CONST char *q = b;
d202 1
a202 1
    for ( ; *p && *q; p++, q++) {
d204 3
a206 1
	if (diff) return diff;
d209 1
a209 1
	return 1;	/* p was longer than q */
d211 2
a212 2
	return -1;	/* p was shorter than q */
    return 0;		/* Exact match */
a214 1

d216 5
a220 6
**	----------------
*/
PUBLIC int strncasecomp ARGS3(
	CONST char*,	a,
	CONST char *,	b,
	int,		n)
d222 2
a223 2
    CONST char *p = a;
    CONST char *q = b;
d225 1
a225 1
    for ( ; ; p++, q++) {
d227 3
a229 2
	if (p == (a+n))
	    return 0;	/*   Match up to n characters */
d236 31
a266 1
    /*NOTREACHED*/
d269 1
a269 1
#endif	/* SH_EX */
d275 4
a278 5
**	----------------
*/
PUBLIC int AS_casecomp ARGS2(
	CONST char*,	p,
	CONST char*,	q)
d282 1
a282 1
    for ( ; ; p++, q++) {
d284 1
a284 1
	    return (UCH(*p)  - UCH(*q));
d286 1
a286 1
	     - TOASCII(TOLOWER(*q));
d290 1
a290 1
    /*NOTREACHED*/
a292 1

d294 6
a299 7
**	----------------
**	AS_cmp uses n == -1 to compare indefinite length.
*/
PUBLIC int AS_ncmp ARGS3(
	CONST char *,	p,
	CONST char *,	q,
	unsigned int,	n)
d301 1
a301 1
    CONST char *a = p;
d304 1
a304 1
    for ( ; (p-a) < n; p++, q++) {
d308 1
a308 1
	     - TOASCII(*q);
d312 1
a312 12
    return 0;	/*   Match up to n characters */
}


/*	With ASCII collating sequence
**	----------------
*/
PUBLIC int AS_cmp ARGS2(
	CONST char *,	p,
	CONST char *,	q)
{
    return( AS_ncmp( p, q, -1 ) );
a315 1

d318 2
a319 3
PUBLIC char * HTSACopy ARGS2(
	char **,	dest,
	CONST char *,	src)
d324 1
d339 2
a340 3
PUBLIC char * HTSACat ARGS2(
	char **,	dest,
	CONST char *,	src)
d345 2
a346 1
	    *dest = (char *)realloc(*dest, length + strlen(src) + 1);
d349 1
a349 1
	    strcpy (*dest + length, src);
d351 1
a351 1
	    *dest = (char *)malloc(strlen(src) + 1);
d354 1
a354 1
	    strcpy (*dest, src);
a359 1

d362 1
a362 1
#define EXTRA_TYPE size_t		/* type we use for length */
d365 1
a365 2
PUBLIC void   HTSAFree_extra ARGS1(
	char *,		s)
d371 2
a372 3
PUBLIC char * HTSACopy_extra ARGS2(
	char **,	dest,
	CONST char *,	src)
d379 1
a379 1
	    size = *(EXTRA_TYPE *)((*dest) - EXTRA_SIZE);
d383 1
a383 1
	    size = srcsize * 2;   /* x2 step */
d387 1
a387 1
	    *(EXTRA_TYPE *)(*dest) = size;
d398 14
a411 15
**	---------------
**
** On entry,
**	*pstr	points to a string containig white space separated
**		field, optionlly quoted.
**
** On exit,
**	*pstr	has been moved to the first delimiter past the
**		field
**		THE STRING HAS BEEN MUTILATED by a 0 terminator
**
**	returns a pointer to the first field
*/
PUBLIC char * HTNextField ARGS1(
	char **,	pstr)
d413 2
a414 2
    char * p = *pstr;
    char * start;			/* start of field */
d417 1
a417 1
	p++;				/* Strip white space */
d422 1
a422 1
    if (*p == '"') {			/* quoted field */
d425 1
a425 1
	for (; *p && *p!='"'; p++) {
d427 1
a427 1
		p++;			/* Skip escaped chars */
d432 1
a432 1
	    p++;			/* Skip first field */
d441 28
a468 29
**	---------------
**	Finds the next token in a string
**	On entry,
**	*pstr	points to a string to be parsed.
**	delims	lists characters to be recognized as delimiters.
**		If NULL, default is white space "," ";" or "=".
**		The word can optionally be quoted or enclosed with
**		chars from bracks.
**		Comments surrrounded by '(' ')' are filtered out
**		unless they are specifically reqested by including
**		' ' or '(' in delims or bracks.
**	bracks	lists bracketing chars.  Some are recognized as
**		special, for those give the opening char.
**		If NULL, defaults to <"> and "<" ">".
**	found	points to location to fill with the ending delimiter
**		found, or is NULL.
**
**	On exit,
**	*pstr	has been moved to the first delimiter past the
**		field
**		THE STRING HAS BEEN MUTILATED by a 0 terminator
**	found	points to the delimiter found unless it was NULL.
**	Returns a pointer to the first word or NULL on error
*/
PUBLIC char * HTNextTok ARGS4(
	char **,	pstr,
	CONST char *,	delims,
	CONST char *,	bracks,
	char *,		found)
d470 2
a471 2
    char * p = *pstr;
    char * start = NULL;
d477 10
a486 7
    if (isEmpty(pstr)) return NULL;
    if (!delims) delims = " ;,=" ;
    if (!bracks) bracks = "<\"" ;

    get_blanks = (BOOL) (!strchr(delims,' ') && !strchr(bracks,' '));
    get_comments = (BOOL) (strchr(bracks,'(') != NULL);
    skip_comments = (BOOL) (!get_comments && !strchr(delims,'(') && !get_blanks);
d490 1
a490 1
	p++;				/* Strip white space */
d493 2
a494 1
	if (found) *found = '\0';
d499 2
a500 1
	while (*p && (skipWHITE(*p) || strchr(delims,*p))) p++;
d503 3
a505 2
	    if (found) *found = *(p-1);
	    return NULL;					 /* No field */
d508 1
a508 1
	if (*p == '(' && (skip_comments || get_comments)) {	  /* Comment */
d510 12
a521 7
	    if (get_comments && !start) start = p+1;
	    for(;*p && (*p!=')' || --comment_level>0); p++) {
		if (*p == '(') comment_level++;
		else if (*p == '"') {	      /* quoted field within Comment */
		    for(p++; *p && *p!='"'; p++)
			if (*p == '\\' && *(p+1)) p++; /* Skip escaped chars */
		    if (!*p) break; /* (invalid) end of string found, leave */
d523 2
a524 1
		if (*p == '\\' && *(p+1)) p++;	       /* Skip escaped chars */
d528 2
a529 1
	    if (*p) p++;
d531 1
a531 1
		if (!*p || (!strchr(bracks,*p) && strchr(delims,*p))) {
d534 1
a534 1
		    get_closing_char_too = (BOOL) (strchr(bracks,*p) != NULL);
d536 1
a536 1
	} else if (strchr(bracks,*p)) {	       /* quoted or bracketed field */
d538 14
a551 5
	       case '<': closer = '>'; break;
	       case '[': closer = ']'; break;
	       case '{': closer = '}'; break;
	       case ':': closer = ';'; break;
	    default:	 closer = *p;
d553 5
a557 3
	    if (!start) start = ++p;
	    for(;*p && *p!=closer; p++)
		if (*p == '\\' && *(p+1)) p++;	       /* Skip escaped chars */
d560 1
a560 1
		if (!*p || (!strchr(bracks,*p) && strchr(delims,*p))) {
d563 1
a563 1
		    get_closing_char_too = (BOOL) (strchr(bracks,*p) != NULL);
d565 6
a570 5
	    break;			    /* kr95-10-9: needs to stop here */
	} else {					      /* Spool field */
	    if (!start) start = p;
	    while(*p && !skipWHITE(*p) && !strchr(bracks,*p) &&
					  !strchr(delims,*p))
d572 1
a572 1
	    if (*p && strchr(bracks,*p)) {
d575 1
a575 1
		if (*p=='(' && skip_comments) {
d577 1
a577 1
		    HTNextTok(pstr, NULL, "(", found);	/*	Advance pstr */
d579 2
a580 1
		    if (*pstr && **pstr) (*pstr)++;
d583 1
a583 1
		    break;					   /* Got it */
d587 2
a588 1
    if (found) *found = *p;
d590 2
a591 1
    if (*p) *p++ = '\0';
d596 1
a596 1
PRIVATE char *HTAlloc ARGS2(char *, ptr, size_t, length)
d599 1
a599 1
	ptr = (char *)realloc(ptr, length);
d601 1
a601 1
	ptr = (char *)malloc(length);
d622 7
a628 1
typedef enum { Flags, Width, Prec, Type, Format } PRINTF;
d634 1
a634 1
#define NUM_WIDTH 10	/* allow for width substituted for "*" in "%*s" */
d641 4
a644 5
PUBLIC_IF_FIND_LEAKS char * StrAllocVsprintf ARGS4(
	char **,	pstr,
	size_t,		dst_len,
	CONST char *,	fmt,
	va_list *,	ap)
d651 1
d659 1
a659 1
    CONST char *format = fmt;
d669 2
a670 2
	    mark_malloced(*pstr, strlen(*pstr)+1);
	    return(*pstr);
d677 2
a678 2
    if (!fmt_ptr || fmt_len < need*NUM_WIDTH) {
	fmt_ptr = HTAlloc(fmt_ptr, fmt_len = need*NUM_WIDTH);
d684 2
a685 2
    if ((fmt_ptr = malloc(need*NUM_WIDTH)) == 0
     || (tmp_ptr = malloc(tmp_len)) == 0) {
d703 9
a711 9
	    char *pval   = dummy;	/* avoid const-cast */
	    double fval  = 0.0;
	    int done     = FALSE;
	    int ival     = 0;
	    int prec     = -1;
	    int type     = 0;
	    int used     = 0;
	    int width    = -1;
	    size_t f     = 0;
d719 1
d733 1
d746 4
a749 4
		    case 'Z': /* FALLTHRU */
		    case 'h': /* FALLTHRU */
		    case 'l': /* FALLTHRU */
		    case 'L': /* FALLTHRU */
d753 6
a758 6
		    case 'o': /* FALLTHRU */
		    case 'i': /* FALLTHRU */
		    case 'd': /* FALLTHRU */
		    case 'u': /* FALLTHRU */
		    case 'x': /* FALLTHRU */
		    case 'X': /* FALLTHRU */
d761 1
d766 1
d769 7
a775 6
		    case 'f': /* FALLTHRU */
		    case 'e': /* FALLTHRU */
		    case 'E': /* FALLTHRU */
		    case 'g': /* FALLTHRU */
		    case 'G': /* FALLTHRU */
			    VA_FLOAT(double);
d780 1
d785 1
d792 1
d797 1
d802 1
a802 1
				    *fmt, format));
d824 1
a824 1
			width = prec + 2; /* leading sign/space/zero, "0x" */
d836 1
a836 1
	    if (width >= (int)tmp_len) {
d888 1
a888 6
#if ANSI_VARARGS
PUBLIC char * HTSprintf (char ** pstr, CONST char * fmt, ...)
#else
PUBLIC char * HTSprintf (va_alist)
    va_dcl
#endif
d894 1
a894 1
    LYva_start(ap,fmt);
a895 4
#if !ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
d915 1
a915 6
#if ANSI_VARARGS
PUBLIC char * HTSprintf0 (char ** pstr, CONST char * fmt, ...)
#else
PUBLIC char * HTSprintf0 (va_alist)
    va_dcl
#endif
d920 1
a920 1
    LYva_start(ap,fmt);
a921 4
#if !ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
d926 2
a927 2
	    if (vasprintf(pstr, fmt, ap) >= 0) /* else call outofmem?? */
		mark_malloced(*pstr, strlen(*pstr)+1);
d931 1
a931 1
	result = StrAllocVsprintf(pstr, 0, fmt, &ap);
d945 1
a945 2
PUBLIC char *HTQuoteParameter ARGS1(
    CONST char *,	parameter)
d948 1
a948 1
    size_t last = strlen(parameter);
d951 4
a954 1
    char * result;
d956 2
a957 1
    for (i=0; i < last; ++i)
d959 1
a959 1
	 || isspace(UCH(parameter[i])))
d962 1
a962 1
    result = (char *)malloc(last + 5*quoted + 3);
d983 1
a983 1
	       */
d999 1
a999 2
PUBLIC int HTCountCommandArgs ARGS1(
    CONST char *,	command)
d1002 1
d1014 2
a1015 3
PRIVATE CONST char *HTAfterCommandArg ARGS2(
    CONST char *,	command,
    int,		number)
d1042 4
a1045 5
PUBLIC void HTAddXpand ARGS4(
    char **,		result,
    CONST char *,	command,
    int,		number,
    CONST char *,	parameter)
d1048 2
a1049 2
	CONST char *last = HTAfterCommandArg(command, number - 1);
	CONST char *next = last;
d1059 2
a1060 1
				+ ((*result != 0) ? strlen(*result) : 0);
d1075 5
a1079 6
 * Append string-parameter to a system command that we are constructing.  The
 * string is a complete parameter (which is a necessary assumption so we can
 * quote it properly).  We're given the index of the newest parameter we're
 * processing.  Zero indicates none, so a value of '1' indicates that we copy
 * from the beginning of the command string up to the first parameter,
 * substitute the quoted parameter and return the result.
d1084 4
a1087 5
PUBLIC void HTAddParam ARGS4(
    char **,		result,
    CONST char *,	command,
    int,		number,
    CONST char *,	parameter)
d1090 2
a1091 5
	CONST char *last = HTAfterCommandArg(command, number - 1);
	CONST char *next = last;
#if USE_QUOTED_PARAMETER
	char *quoted;
#endif
d1096 2
a1097 2
	if (parameter == 0)
	    parameter = "";
d1102 2
a1103 1
				+ ((*result != 0) ? strlen(*result) : 0);
d1107 1
a1107 7
#if USE_QUOTED_PARAMETER
		quoted = HTQuoteParameter(parameter);
		HTSACat(result, quoted);
		FREE(quoted);
#else
		HTSACat(result, parameter);
#endif
d1117 22
d1142 3
a1144 4
PUBLIC void HTEndParam ARGS3(
    char **,		result,
    CONST char *,	command,
    int,		number)
d1146 1
a1146 1
    CONST char *last;
d1149 1
a1149 1
    count = HTCountCommandArgs (command);
d1159 2
a1160 3

/*	Binary-strings (may have embedded nulls).
 *	Some modules (HTGopher) assume there is a null on the end, anyway.
d1163 1
a1163 1
/*	Allocate a new bstring, and return it.
d1165 2
a1166 4
PUBLIC void HTSABCopy ARGS3(
	bstring**,	dest,
	CONST char *,	src,
	int,		len)
d1179 4
a1182 3
	if ((t = (bstring*) malloc(sizeof(bstring))) == NULL)
	    outofmem(__FILE__, "HTSABCopy");
	if ((t->str = (char *) malloc (need)) == NULL)
d1184 1
a1184 1
	memcpy (t->str, src, len);
d1199 1
a1199 3
PUBLIC void HTSABCopy0 ARGS2(
	bstring**,	dest,
	CONST char *,	src)
d1207 2
a1208 4
PUBLIC void HTSABCat ARGS3(
	bstring **,	dest,
	CONST char *,	src,
	int,		len)
d1223 2
a1224 1
	    if ((t->str = (char *)realloc(t->str, length)) == NULL)
d1228 3
a1230 2
		outofmem(__FILE__, "HTSACat");
	    t->str = (char *)malloc(need);
d1234 1
a1234 1
	memcpy (t->str + t->len, src, len);
d1249 1
a1249 3
PUBLIC void HTSABCat0 ARGS2(
	bstring**,	dest,
	CONST char *,	src)
d1257 1
a1257 3
PUBLIC BOOL HTSABEql   ARGS2(
	bstring *,	a,
	bstring *,	b)
d1264 1
a1264 1
	 || memcmp(a->str, b->str, a->len) == 0)
d1273 1
a1273 2
PUBLIC void HTSABFree ARGS1(
	bstring **,	ptr)
d1286 1
a1286 5
#ifdef ANSI_VARARGS
PUBLIC bstring * HTBprintf (bstring ** pstr, CONST char * fmt, ...)
#else
PUBLIC bstring * HTBprintf ()
#endif
d1292 1
a1292 1
    LYva_start(ap,fmt);
a1293 4
#if !ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
d1296 1
a1296 1
	    HTSABCat (pstr, temp, strlen(temp));
d1311 2
a1312 3
PUBLIC void trace_bstring2 ARGS2(
	CONST char *,	text,
	int,		size)
d1319 1
d1345 1
a1345 2
PUBLIC void trace_bstring ARGS1(
	bstring *,	data)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d16 4
a19 1
PUBLIC int WWW_TraceFlag = 0;	/* Global trace flag for ALL W3 code */
d25 3
d29 1
d83 1
d86 73
d204 2
d221 1
a221 1
	    return ((unsigned char) *p - (unsigned char) *q);
d245 1
a245 1
	    return ((unsigned char) *p - (unsigned char) *q);
d275 1
d277 1
a277 1
	    *dest = (char *) malloc (strlen(src) + 1);
d280 1
a280 1
	    strcpy (*dest, src);
d296 1
a296 1
	    int length = strlen(*dest);
d312 39
d401 1
a401 1
**		If NULL default is white white space "," ";" or "=".
d409 1
a409 1
**		If NULL defaults to <"> and "<" ">".
d424 1
a424 1
	char *, 	found)
d432 2
a433 1
    if (!pstr || !*pstr) return NULL;
d437 3
a439 3
    get_blanks = (!strchr(delims,' ') && !strchr(bracks,' '));
    get_comments = (strchr(bracks,'(') != NULL);
    skip_comments = (!get_comments && !strchr(delims,'(') && !get_blanks);
d477 1
a477 1
		    get_closing_char_too = (strchr(bracks,*p) != NULL);
d479 1
a479 1
	} else if (strchr(bracks,*p)) {        /* quoted or bracketted field */
d495 1
a495 1
		    get_closing_char_too = (strchr(bracks,*p) != NULL);
a497 7
#if 0
	} else if (*p == '<') { 			     /* quoted field */
	    if (!start) start = ++p;
	    for(;*p && *p!='>'; p++)
		if (*p == '\\' && *(p+1)) p++;	       /* Skip escaped chars */
	    break;			    /* kr95-10-9: needs to stop here */
#endif
d536 13
a548 3
 * Replacement for sprintf, allocates buffer on the fly according to what's needed
 * for its arguments.  Unlike sprintf, this always concatenates to the destination
 * buffer, so we do not have to provide both flavors.
d563 1
a563 1
PRIVATE char * StrAllocVsprintf ARGS4(
d569 6
a575 1
    size_t have, need;
d578 2
d586 11
d598 8
d610 1
d639 1
a639 1
		if (isdigit(*fmt)) {
d663 1
a663 1
		} else if (isalpha(*fmt)) {
a691 5
#if 0	/* we don't need this, it doesn't work on SunOS 4.x */
			if (type == 'L')
			    VA_FLOAT(long double);
			else
#endif
d714 2
a715 2
			CTRACE(tfp, "unknown format character '%c' in %s\n",
			            *fmt, format);
d732 1
d734 1
d738 1
d740 1
d746 1
d780 1
d783 1
d786 1
a786 1
    	*pstr = dst_ptr;
d789 1
d792 3
a794 3
 * Replacement for sprintf, allocates buffer on the fly according to what's needed
 * for its arguments.  Unlike sprintf, this always concatenates to the destination
 * buffer.
d796 5
d832 5
d853 9
d887 1
a887 1
	 || isspace(parameter[i]))
a903 3
	} else if (parameter[i] == '\\') {
	    result[n++] = parameter[i];
	    result[n++] = parameter[i];
d905 7
d989 1
a989 1
		    		+ ((*result != 0) ? strlen(*result) : 0);
d994 1
a994 1
		CTRACE(tfp, "PARAM-EXP:%s\n", *result);
d1023 1
d1025 1
d1036 1
a1036 1
		    		+ ((*result != 0) ? strlen(*result) : 0);
d1047 1
a1047 1
		CTRACE(tfp, "PARAM-ADD:%s\n", *result);
d1066 1
d1074 210
a1283 1
    CTRACE(tfp, "PARAM-END:%s\n", *result);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 8
a9 8
 *
 *	Original version came with listserv implementation.
 *	Version TBL Oct 91 replaces one which modified the strings.
 *	02-Dec-91 (JFG) Added stralloccopy and stralloccat
 *	23 Jan 92 (TBL) Changed strallocc* to 8 char HTSAC* for VM and suchlike
 *	 6 Oct 92 (TBL) Moved WWW_TraceFlag in here to be in library
 *	15 Nov 98 (TD)  Added HTSprintf.
 */
d16 1
a16 4
#ifndef NO_LYNX_TRACE
BOOLEAN WWW_TraceFlag = 0;	/* Global trace flag for ALL W3 code */
int WWW_TraceMask = 0;		/* Global trace flag for ALL W3 code */
#endif
d19 1
a19 1
#define VC "2.14"
d22 1
a22 6
#ifdef _WINDOWS
const char *HTLibraryVersion = "2.14FM";	/* String for help screen etc */

#else
const char *HTLibraryVersion = VC;	/* String for help screen etc */
#endif
d25 9
a33 8
 *     strcasecomp8 is a variant of strcasecomp (below)
 *     ------------		    -----------
 *     but uses 8bit upper/lower case information
 *     from the current display charset.
 *     It returns 0 if exact match.
 */
int strcasecomp8(const char *a,
		 const char *b)
d35 2
a36 2
    const char *p = a;
    const char *q = b;
d38 1
a38 1
    for (; *p && *q; p++, q++) {
d40 1
a40 3

	if (diff)
	    return diff;
d43 1
a43 1
	return 1;		/* p was longer than q */
d45 2
a46 2
	return -1;		/* p was shorter than q */
    return 0;			/* Exact match */
d50 10
a59 9
 *     strncasecomp8 is a variant of strncasecomp (below)
 *     -------------		     ------------
 *     but uses 8bit upper/lower case information
 *     from the current display charset.
 *     It returns 0 if exact match.
 */
int strncasecomp8(const char *a,
		  const char *b,
		  int n)
d61 2
a62 2
    const char *p = a;
    const char *q = b;
d64 1
a64 1
    for (;; p++, q++) {
d66 2
a67 3

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
d74 1
a74 73
    /*NOTREACHED */
}

#ifndef VM			/* VM has these already it seems */

#ifdef SH_EX			/* 1997/12/23 (Tue) 16:40:31 */

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static unsigned char charmap[] =
{
    '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
    '\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
    '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
    '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
    '\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
    '\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
    '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
    '\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
    '\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
    '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
    '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
    '\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
    '\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
    '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
    '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
    '\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
    '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
    '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
    '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
    '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
    '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
    '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
    '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
    '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
    '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
    '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
    '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\327',
    '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\337',
    '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
    '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
    '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
    '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};

int strcasecomp(const char *s1,
		const char *s2)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *) s1;
    register unsigned char *us2 = (unsigned char *) s2;

    while (cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return (0);
    return (cm[*us1] - cm[*--us2]);
}

int strncasecomp(const char *a,
		 const char *b,
		 int n)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *) a;
    register unsigned char *us2 = (unsigned char *) b;

    while ((long) (--n) >= 0 && cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return (0);
    return ((long) n < 0 ? 0 : cm[*us1] - cm[*--us2]);
d76 1
a76 2

#else /* SH_EX */
d79 5
a83 4
 *	---------------------
 */
int strcasecomp(const char *a,
		const char *b)
d85 2
a86 2
    const char *p = a;
    const char *q = b;
d88 1
a88 1
    for (; *p && *q; p++, q++) {
d90 1
a90 3

	if (diff)
	    return diff;
d93 1
a93 1
	return 1;		/* p was longer than q */
d95 2
a96 2
	return -1;		/* p was shorter than q */
    return 0;			/* Exact match */
d99 1
d101 6
a106 5
 *	----------------
 */
int strncasecomp(const char *a,
		 const char *b,
		 int n)
d108 2
a109 2
    const char *p = a;
    const char *q = b;
d111 1
a111 1
    for (;; p++, q++) {
d113 2
a114 3

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
d121 1
a121 1
    /*NOTREACHED */
a122 2

#endif /* SH_EX */
d128 5
a132 4
 *	----------------
 */
int AS_casecomp(const char *p,
		const char *q)
d136 1
a136 1
    for (;; p++, q++) {
d138 1
a138 1
	    return (UCH(*p) - UCH(*q));
d140 1
a140 1
	    - TOASCII(TOLOWER(*q));
d144 1
a144 1
    /*NOTREACHED */
d147 1
d149 7
a155 6
 *	----------------
 *	AS_cmp uses n == -1 to compare indefinite length.
 */
int AS_ncmp(const char *p,
	    const char *q,
	    unsigned int n)
d157 1
a157 1
    const char *a = p;
d160 1
a160 1
    for (; (unsigned) (p - a) < n; p++, q++) {
d162 1
a162 1
	    return (UCH(*p) - UCH(*q));
d164 1
a164 1
	    - TOASCII(*q);
d168 12
a179 1
    return 0;			/*   Match up to n characters */
d183 1
d186 3
a188 2
char *HTSACopy(char **dest,
	       const char *src)
a191 2
	    size_t size = strlen(src) + 1;

d193 1
a193 1
	    *dest = (char *) malloc(size);
d196 1
a196 1
	    memcpy(*dest, src, size);
d206 3
a208 2
char *HTSACat(char **dest,
	      const char *src)
d212 2
a213 3
	    size_t length = strlen(*dest);

	    *dest = (char *) realloc(*dest, length + strlen(src) + 1);
d216 1
a216 1
	    strcpy(*dest + length, src);
d218 1
a218 1
	    *dest = (char *) malloc(strlen(src) + 1);
d221 1
a221 1
	    strcpy(*dest, src);
a226 36
/* optimized for heavily realloc'd strings, store length inside */

#define EXTRA_TYPE size_t	/* type we use for length */
#define EXTRA_SIZE sizeof(void *)	/* alignment >= sizeof(EXTRA_TYPE) */

void HTSAFree_extra(char *s)
{
    free(s - EXTRA_SIZE);
}

/* never shrink */
char *HTSACopy_extra(char **dest,
		     const char *src)
{
    if (src != 0) {
	size_t srcsize = strlen(src) + 1;
	EXTRA_TYPE size = 0;

	if (*dest != 0) {
	    size = *(EXTRA_TYPE *) ((*dest) - EXTRA_SIZE);
	}
	if (size < srcsize) {
	    FREE_extra(*dest);
	    size = srcsize * 2;	/* x2 step */
	    *dest = (char *) malloc(size + EXTRA_SIZE);
	    if (*dest == NULL)
		outofmem(__FILE__, "HTSACopy_extra");
	    *(EXTRA_TYPE *) (*dest) = size;
	    *dest += EXTRA_SIZE;
	}
	memcpy(*dest, src, srcsize);
    } else {
	Clear_extra(*dest);
    }
    return *dest;
}
d229 15
a243 14
 *	---------------
 *
 * On entry,
 *	*pstr	points to a string containig white space separated
 *		field, optionlly quoted.
 *
 * On exit,
 *	*pstr	has been moved to the first delimiter past the
 *		field
 *		THE STRING HAS BEEN MUTILATED by a 0 terminator
 *
 *	returns a pointer to the first field
 */
char *HTNextField(char **pstr)
d245 2
a246 2
    char *p = *pstr;
    char *start;		/* start of field */
d249 1
a249 1
	p++;			/* Strip white space */
d254 1
a254 1
    if (*p == '"') {		/* quoted field */
d257 1
a257 1
	for (; *p && *p != '"'; p++) {
d259 1
a259 1
		p++;		/* Skip escaped chars */
d264 1
a264 1
	    p++;		/* Skip first field */
d273 29
a301 28
 *	---------------
 *	Finds the next token in a string
 *	On entry,
 *	*pstr	points to a string to be parsed.
 *	delims	lists characters to be recognized as delimiters.
 *		If NULL, default is white space "," ";" or "=".
 *		The word can optionally be quoted or enclosed with
 *		chars from bracks.
 *		Comments surrrounded by '(' ')' are filtered out
 *		unless they are specifically reqested by including
 *		' ' or '(' in delims or bracks.
 *	bracks	lists bracketing chars.  Some are recognized as
 *		special, for those give the opening char.
 *		If NULL, defaults to <"> and "<" ">".
 *	found	points to location to fill with the ending delimiter
 *		found, or is NULL.
 *
 *	On exit,
 *	*pstr	has been moved to the first delimiter past the
 *		field
 *		THE STRING HAS BEEN MUTILATED by a 0 terminator
 *	found	points to the delimiter found unless it was NULL.
 *	Returns a pointer to the first word or NULL on error
 */
char *HTNextTok(char **pstr,
		const char *delims,
		const char *bracks,
		char *found)
d303 2
a304 2
    char *p = *pstr;
    char *start = NULL;
d309 7
a315 11

    if (isEmpty(pstr))
	return NULL;
    if (!delims)
	delims = " ;,=";
    if (!bracks)
	bracks = "<\"";

    get_blanks = (BOOL) (!strchr(delims, ' ') && !strchr(bracks, ' '));
    get_comments = (BOOL) (strchr(bracks, '(') != NULL);
    skip_comments = (BOOL) (!get_comments && !strchr(delims, '(') && !get_blanks);
d319 1
a319 1
	p++;			/* Strip white space */
d322 1
a322 2
	if (found)
	    *found = '\0';
d327 1
a327 2
	while (*p && (skipWHITE(*p) || strchr(delims, *p)))
	    p++;
d330 2
a331 3
	    if (found)
		*found = *(p - 1);
	    return NULL;	/* No field */
d334 1
a334 1
	if (*p == '(' && (skip_comments || get_comments)) {	/* Comment */
d336 7
a342 12

	    if (get_comments && !start)
		start = p + 1;
	    for (; *p && (*p != ')' || --comment_level > 0); p++) {
		if (*p == '(')
		    comment_level++;
		else if (*p == '"') {	/* quoted field within Comment */
		    for (p++; *p && *p != '"'; p++)
			if (*p == '\\' && *(p + 1))
			    p++;	/* Skip escaped chars */
		    if (!*p)
			break;	/* (invalid) end of string found, leave */
d344 1
a344 2
		if (*p == '\\' && *(p + 1))
		    p++;	/* Skip escaped chars */
d348 1
a348 2
	    if (*p)
		p++;
d350 1
a350 1
		if (!*p || (!strchr(bracks, *p) && strchr(delims, *p))) {
d353 1
a353 1
		    get_closing_char_too = (BOOL) (strchr(bracks, *p) != NULL);
d355 1
a355 1
	} else if (strchr(bracks, *p)) {	/* quoted or bracketed field */
d357 9
a365 20
	    case '<':
		closer = '>';
		break;
	    case '[':
		closer = ']';
		break;
	    case '{':
		closer = '}';
		break;
	    case ':':
		closer = ';';
		break;
	    default:
		closer = *p;
	    }
	    if (!start)
		start = ++p;
	    for (; *p && *p != closer; p++)
		if (*p == '\\' && *(p + 1))
		    p++;	/* Skip escaped chars */
d368 1
a368 1
		if (!*p || (!strchr(bracks, *p) && strchr(delims, *p))) {
d371 1
a371 1
		    get_closing_char_too = (BOOL) (strchr(bracks, *p) != NULL);
d373 12
a384 6
		break;		/* kr95-10-9: needs to stop here */
	} else {		/* Spool field */
	    if (!start)
		start = p;
	    while (*p && !skipWHITE(*p) && !strchr(bracks, *p) &&
		   !strchr(delims, *p))
d386 1
a386 1
	    if (*p && strchr(bracks, *p)) {
d389 1
a389 1
		if (*p == '(' && skip_comments) {
d391 1
a391 1
		    HTNextTok(pstr, NULL, "(", found);	/*      Advance pstr */
d393 1
a393 2
		    if (*pstr && **pstr)
			(*pstr)++;
d396 1
a396 1
		break;		/* Got it */
d400 1
a400 2
    if (found)
	*found = *p;
d402 1
a402 2
    if (*p)
	*p++ = '\0';
d407 1
a407 1
static char *HTAlloc(char *ptr, size_t length)
d410 1
a410 1
	ptr = (char *) realloc(ptr, length);
d412 1
a412 1
	ptr = (char *) malloc(length);
d419 3
a421 13
 * If SAVE_TIME_NOT_SPACE is defined, StrAllocVsprintf will hang on to
 * its temporary string buffers instead of allocating and freeing them
 * in each invocation.  They only grow and never shrink, and won't be
 * cleaned up on exit. - kw
 */
#if defined(_REENTRANT) || defined(_THREAD_SAFE) || defined(LY_FIND_LEAKS)
#undef SAVE_TIME_NOT_SPACE
#endif

/*
 * Replacement for sprintf, allocates buffer on the fly according to what's
 * needed for its arguments.  Unlike sprintf, this always concatenates to the
 * destination buffer, so we do not have to provide both flavors.
d423 1
a423 7
typedef enum {
    Flags,
    Width,
    Prec,
    Type,
    Format
} PRINTF;
d427 1
a427 1
#define VA_POINT(type) pval = (char *)va_arg((*ap), type)
d429 1
a429 1
#define NUM_WIDTH 10		/* allow for width substituted for "*" in "%*s" */
d436 6
a441 12
PUBLIC_IF_FIND_LEAKS char *StrAllocVsprintf(char **pstr,
					    size_t dst_len,
					    const char *fmt,
					    va_list * ap)
{
#ifdef SAVE_TIME_NOT_SPACE
    static size_t tmp_len = 0;
    static size_t fmt_len = 0;
    static char *tmp_ptr = NULL;
    static char *fmt_ptr = NULL;

#else
d443 1
a445 2
#endif /* SAVE_TIME_NOT_SPACE */
    size_t have, need;
d447 1
a447 1
    const char *format = fmt;
a451 11
#ifdef USE_VASPRINTF
    if (pstr && !dst_len) {
	if (*pstr)
	    FREE(*pstr);
	if (vasprintf(pstr, fmt, *ap) >= 0) {
	    mark_malloced(*pstr, strlen(*pstr) + 1);
	    return (*pstr);
	}
    }
#endif /* USE_VASPRINTF */

d453 2
a454 10
#ifdef SAVE_TIME_NOT_SPACE
    if (!fmt_ptr || fmt_len < need * NUM_WIDTH) {
	fmt_ptr = HTAlloc(fmt_ptr, fmt_len = need * NUM_WIDTH);
    }
    if (!tmp_ptr || tmp_len < GROW_SIZE) {
	tmp_ptr = HTAlloc(tmp_ptr, tmp_len = GROW_SIZE);
    }
#else
    if ((fmt_ptr = malloc(need * NUM_WIDTH)) == 0
	|| (tmp_ptr = malloc(tmp_len)) == 0) {
a456 1
#endif /* SAVE_TIME_NOT_SPACE */
d471 9
a479 9
	    char *pval = dummy;	/* avoid const-cast */
	    double fval = 0.0;
	    int done = FALSE;
	    int ival = 0;
	    int prec = -1;
	    int type = 0;
	    int used = 0;
	    int width = -1;
	    size_t f = 0;
d485 1
a485 1
		if (isdigit(UCH(*fmt))) {
a486 1

a499 1

d509 1
a509 1
		} else if (isalpha(UCH(*fmt))) {
d512 4
a515 4
		    case 'Z':	/* FALLTHRU */
		    case 'h':	/* FALLTHRU */
		    case 'l':	/* FALLTHRU */
		    case 'L':	/* FALLTHRU */
d519 6
a524 6
		    case 'o':	/* FALLTHRU */
		    case 'i':	/* FALLTHRU */
		    case 'd':	/* FALLTHRU */
		    case 'u':	/* FALLTHRU */
		    case 'x':	/* FALLTHRU */
		    case 'X':	/* FALLTHRU */
a526 1

a530 1

d533 11
a543 7
		    case 'f':	/* FALLTHRU */
		    case 'e':	/* FALLTHRU */
		    case 'E':	/* FALLTHRU */
		    case 'g':	/* FALLTHRU */
		    case 'G':	/* FALLTHRU */
			VA_FLOAT(double);

a547 1

a551 1

a557 1

a561 1

d565 2
a566 2
			CTRACE((tfp, "unknown format character '%c' in %s\n",
				*fmt, format));
a582 1
		    /* FALLTHRU */
a583 1
		    /* FALLTHRU */
d586 1
a586 2
			width = prec + 2;	/* leading sign/space/zero, "0x" */
		    break;
a587 1
		    break;
a592 1
		    break;
d595 1
a595 1
	    if (width >= (int) tmp_len) {
a625 1
#ifndef SAVE_TIME_NOT_SPACE
a627 1
#endif
d630 1
a630 1
	*pstr = dst_ptr;
a632 1
#undef SAVE_TIME_NOT_SPACE
d635 3
a637 3
 * Replacement for sprintf, allocates buffer on the fly according to what's
 * needed for its arguments.  Unlike sprintf, this always concatenates to the
 * destination buffer.
d639 5
a643 4
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf in LYLeaks.c. - kw */
#ifdef HTSprintf		/* if hidden by LYLeaks stuff */
#undef HTSprintf
a644 1
char *HTSprintf(char **pstr, const char *fmt,...)
d650 1
a650 1
    LYva_start(ap, fmt);
d652 4
d670 5
a674 4
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf0 in LYLeaks.c. - kw */
#ifdef HTSprintf0		/* if hidden by LYLeaks stuff */
#undef HTSprintf0
a675 1
char *HTSprintf0(char **pstr, const char *fmt,...)
d680 1
a680 1
    LYva_start(ap, fmt);
d682 5
a686 10
#ifdef USE_VASPRINTF
	if (pstr) {
	    if (*pstr)
		FREE(*pstr);
	    if (vasprintf(pstr, fmt, ap) >= 0)	/* else call outofmem?? */
		mark_malloced(*pstr, strlen(*pstr) + 1);
	    result = *pstr;
	} else
#endif /* USE_VASPRINTF */
	    result = StrAllocVsprintf(pstr, 0, fmt, &ap);
d700 2
a701 1
char *HTQuoteParameter(const char *parameter)
d704 1
a704 1
    size_t last;
d707 1
a707 4
    char *result;

    if (parameter == 0)
	parameter = "";
d709 1
a709 2
    last = strlen(parameter);
    for (i = 0; i < last; ++i)
d711 1
a711 1
	    || isspace(UCH(parameter[i])))
d714 1
a714 1
    result = (char *) malloc(last + 5 * quoted + 3);
d728 3
a731 7
	    /* Note:  No special handling of other characters, including
	       backslash, since we are constructing a single-quoted string!
	       Backslash has no special escape meaning within those for sh
	       and compatible shells, so trying to escape a backslash by
	       doubling it is unnecessary and would be interpreted by the
	       shell as an additional data character. - kw 2000-05-02
	     */
d747 2
a748 1
int HTCountCommandArgs(const char *command)
a750 1

d762 3
a764 2
static const char *HTAfterCommandArg(const char *command,
				     int number)
d791 5
a795 4
void HTAddXpand(char **result,
		const char *command,
		int number,
		const char *parameter)
d798 2
a799 2
	const char *last = HTAfterCommandArg(command, number - 1);
	const char *next = last;
d809 1
a809 2
		    + ((*result != 0) ? strlen(*result) : 0);

d814 1
a814 1
		CTRACE((tfp, "PARAM-EXP:%s\n", *result));
d824 6
a829 5
 * Append string to a system command that we are constructing, without quoting. 
 * We're given the index of the newest parameter we're processing.  Zero
 * indicates none, so a value of '1' indicates that we copy from the beginning
 * of the command string up to the first parameter, substitute the quoted
 * parameter and return the result.
d834 5
a838 4
void HTAddToCmd(char **result,
		const char *command,
		int number,
		const char *string)
d841 3
a843 2
	const char *last = HTAfterCommandArg(command, number - 1);
	const char *next = last;
d848 2
a849 2
	if (string == 0)
	    string = "";
d854 1
a854 2
		    + ((*result != 0) ? strlen(*result) : 0);

d858 8
a865 2
		HTSACat(result, string);
		CTRACE((tfp, "PARAM-ADD:%s\n", *result));
a873 22
 * Append string-parameter to a system command that we are constructing.  The
 * string is a complete parameter (which is a necessary assumption so we can
 * quote it properly).
 */
void HTAddParam(char **result,
		const char *command,
		int number,
		const char *parameter)
{
    if (number > 0) {
#if USE_QUOTED_PARAMETER
	char *quoted = HTQuoteParameter(parameter);

	HTAddToCmd(result, command, number, quoted);
	FREE(quoted);
#else
	HTAddToCmd(result, command, number, parameter);
#endif
    }
}

/*
d877 4
a880 3
void HTEndParam(char **result,
		const char *command,
		int number)
d882 1
a882 1
    const char *last;
d884 1
a884 2

    count = HTCountCommandArgs(command);
d891 1
a891 192
    CTRACE((tfp, "PARAM-END:%s\n", *result));
}

/* Binary-strings (may have embedded nulls).  Some modules (HTGopher) assume
 * there is a null on the end, anyway.
 */

/* Allocate a new bstring, and return it.
*/
void HTSABCopy(bstring **dest, const char *src,
	       int len)
{
    bstring *t;
    unsigned need = len + 1;

    CTRACE2(TRACE_BSTRING, (tfp, "HTSABCopy(%p, %p, %d)\n", dest, src, len));
    HTSABFree(dest);
    if (src) {
	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if ((t = (bstring *) malloc(sizeof(bstring))) == NULL)
	      outofmem(__FILE__, "HTSABCopy");

	if ((t->str = (char *) malloc(need)) == NULL)
	    outofmem(__FILE__, "HTSABCopy");
	memcpy(t->str, src, len);
	t->len = len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/*
 * Initialize with a null-terminated string (discards the null).
 */
void HTSABCopy0(bstring **dest, const char *src)
{
    HTSABCopy(dest, src, strlen(src));
}

/*
 * Append a block of memory to a bstring.
 */
void HTSABCat(bstring **dest, const char *src,
	      int len)
{
    bstring *t = *dest;

    CTRACE2(TRACE_BSTRING, (tfp, "HTSABCat(%p, %p, %d)\n", dest, src, len));
    if (src) {
	unsigned need = len + 1;

	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if (t) {
	    unsigned length = t->len + need;

	    if ((t->str = (char *) realloc(t->str, length)) == NULL)
		outofmem(__FILE__, "HTSACat");
	} else {
	    if ((t = typecalloc(bstring)) == NULL)
		  outofmem(__FILE__, "HTSACat");

	    t->str = (char *) malloc(need);
	}
	if (t->str == NULL)
	    outofmem(__FILE__, "HTSACat");
	memcpy(t->str + t->len, src, len);
	t->len += len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/*
 * Append a null-terminated string (discards the null).
 */
void HTSABCat0(bstring **dest, const char *src)
{
    HTSABCat(dest, src, strlen(src));
}

/*
 * Compare two bstring's for equality
 */
BOOL HTSABEql(bstring *a, bstring *b)
{
    unsigned len_a = (a != 0) ? a->len : 0;
    unsigned len_b = (b != 0) ? b->len : 0;

    if (len_a == len_b) {
	if (len_a == 0
	    || memcmp(a->str, b->str, a->len) == 0)
	    return TRUE;
    }
    return FALSE;
}

/*
 * Deallocate a bstring.
 */
void HTSABFree(bstring **ptr)
{
    if (*ptr != NULL) {
	FREE((*ptr)->str);
	FREE(*ptr);
	*ptr = NULL;
    }
}

/*
 * Use this function to perform formatted sprintf's onto the end of a bstring.
 * The bstring may contain embedded nulls; the formatted portions must not.
 */
bstring *HTBprintf(bstring **pstr, const char *fmt,...)
{
    bstring *result = 0;
    char *temp = 0;
    va_list ap;

    LYva_start(ap, fmt);
    {
	temp = StrAllocVsprintf(&temp, 0, fmt, &ap);
	if (!isEmpty(temp)) {
	    HTSABCat(pstr, temp, strlen(temp));
	}
	FREE(temp);
	result = *pstr;
    }
    va_end(ap);

    return (result);
}

/*
 * Write binary-data to the logfile, making it safe for most editors to view.
 * That is most, since we do not restrict line-length.  Nulls and other
 * non-printing characters are addressed.
 */
void trace_bstring2(const char *text,
		    int size)
{
    int n;

    if (text != 0) {
	for (n = 0; n < size; ++n) {
	    int ch = UCH(text[n]);

	    switch (ch) {
	    case '\\':
		fputs("\\\\", tfp);
		break;
	    case '\r':
		fputs("\\r", tfp);
		break;
	    case '\t':
		fputs("\\t", tfp);
		break;
	    case '\f':
		fputs("\\f", tfp);
		break;
	    default:
		if (isprint(ch) || isspace(ch)) {
		    fputc(ch, tfp);
		} else {
		    fprintf(tfp, "\\%03o", ch);
		}
		break;
	    }
	}
    }
}

void trace_bstring(bstring *data)
{
    trace_bstring2(BStrData(data), BStrLen(data));
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d16 1
a16 4
#ifndef NO_LYNX_TRACE
PUBLIC BOOLEAN WWW_TraceFlag = 0;	/* Global trace flag for ALL W3 code */
PUBLIC int WWW_TraceMask = 0;		/* Global trace flag for ALL W3 code */
#endif
a21 3
#ifdef _WINDOWS
CONST char * HTLibraryVersion = "2.14FM"; /* String for help screen etc */
#else
a22 1
#endif
a75 1

a77 73
#ifdef SH_EX	/* 1997/12/23 (Tue) 16:40:31 */

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static unsigned char charmap[] = {
	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\327',
	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\337',
	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};

PUBLIC int strcasecomp ARGS2(
	CONST char*,	s1,
	CONST char*,	s2)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *)s1;
    register unsigned char *us2 = (unsigned char *)s2;

    while (cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return(0);
    return (cm[*us1] - cm[*--us2]);
}

PUBLIC int strncasecomp ARGS3(
	CONST char*,	a,
	CONST char*,	b,
	int,		n)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *)a;
    register unsigned char *us2 = (unsigned char *)b;

    while ((long)(--n) >= 0 && cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return(0);
    return ((long)n < 0 ? 0 : cm[*us1] - cm[*--us2]);
}

#else	/* SH_EX */

a122 2

#endif	/* SH_EX */
d138 1
a138 1
	    return (UCH(*p)  - UCH(*q));
d162 1
a162 1
	    return (UCH(*p) - UCH(*q));
a191 1
	    size_t size = strlen(src) + 1;
d193 1
a193 1
	    *dest = (char *) malloc(size);
d196 1
a196 1
	    memcpy(*dest, src, size);
d212 1
a212 1
	    size_t length = strlen(*dest);
a227 39
/* optimized for heavily realloc'd strings, store length inside */

#define EXTRA_TYPE size_t		/* type we use for length */
#define EXTRA_SIZE sizeof(void *)	/* alignment >= sizeof(EXTRA_TYPE) */

PUBLIC void   HTSAFree_extra ARGS1(
	char *,		s)
{
    free(s - EXTRA_SIZE);
}

/* never shrink */
PUBLIC char * HTSACopy_extra ARGS2(
	char **,	dest,
	CONST char *,	src)
{
    if (src != 0) {
	size_t srcsize = strlen(src) + 1;
	EXTRA_TYPE size = 0;

	if (*dest != 0) {
	    size = *(EXTRA_TYPE *)((*dest) - EXTRA_SIZE);
	}
	if (size < srcsize) {
	    FREE_extra(*dest);
	    size = srcsize * 2;   /* x2 step */
	    *dest = (char *) malloc(size + EXTRA_SIZE);
	    if (*dest == NULL)
		outofmem(__FILE__, "HTSACopy_extra");
	    *(EXTRA_TYPE *)(*dest) = size;
	    *dest += EXTRA_SIZE;
	}
	memcpy(*dest, src, srcsize);
    } else {
	Clear_extra(*dest);
    }
    return *dest;
}

d278 1
a278 1
**		If NULL, default is white space "," ";" or "=".
d286 1
a286 1
**		If NULL, defaults to <"> and "<" ">".
d301 1
a301 1
	char *,		found)
d309 1
a309 2

    if (isEmpty(pstr)) return NULL;
d313 3
a315 3
    get_blanks = (BOOL) (!strchr(delims,' ') && !strchr(bracks,' '));
    get_comments = (BOOL) (strchr(bracks,'(') != NULL);
    skip_comments = (BOOL) (!get_comments && !strchr(delims,'(') && !get_blanks);
d353 1
a353 1
		    get_closing_char_too = (BOOL) (strchr(bracks,*p) != NULL);
d355 1
a355 1
	} else if (strchr(bracks,*p)) {	       /* quoted or bracketed field */
d371 1
a371 1
		    get_closing_char_too = (BOOL) (strchr(bracks,*p) != NULL);
d374 7
d419 3
a421 13
 * If SAVE_TIME_NOT_SPACE is defined, StrAllocVsprintf will hang on to
 * its temporary string buffers instead of allocating and freeing them
 * in each invocation.  They only grow and never shrink, and won't be
 * cleaned up on exit. - kw
 */
#if defined(_REENTRANT) || defined(_THREAD_SAFE) || defined(LY_FIND_LEAKS)
#undef SAVE_TIME_NOT_SPACE
#endif

/*
 * Replacement for sprintf, allocates buffer on the fly according to what's
 * needed for its arguments.  Unlike sprintf, this always concatenates to the
 * destination buffer, so we do not have to provide both flavors.
d436 1
a436 1
PUBLIC_IF_FIND_LEAKS char * StrAllocVsprintf ARGS4(
a441 6
#ifdef SAVE_TIME_NOT_SPACE
    static size_t tmp_len = 0;
    static size_t fmt_len = 0;
    static char *tmp_ptr = NULL;
    static char *fmt_ptr = NULL;
#else
d443 1
a445 2
#endif /* SAVE_TIME_NOT_SPACE */
    size_t have, need;
a451 11
#ifdef USE_VASPRINTF
    if (pstr && !dst_len) {
	if (*pstr)
	    FREE(*pstr);
	if (vasprintf(pstr, fmt, *ap) >= 0) {
	    mark_malloced(*pstr, strlen(*pstr)+1);
	    return(*pstr);
	}
    }
#endif /* USE_VASPRINTF */

a452 8
#ifdef SAVE_TIME_NOT_SPACE
    if (!fmt_ptr || fmt_len < need*NUM_WIDTH) {
	fmt_ptr = HTAlloc(fmt_ptr, fmt_len = need*NUM_WIDTH);
    }
    if (!tmp_ptr || tmp_len < GROW_SIZE) {
	tmp_ptr = HTAlloc(tmp_ptr, tmp_len = GROW_SIZE);
    }
#else
a456 1
#endif /* SAVE_TIME_NOT_SPACE */
d485 1
a485 1
		if (isdigit(UCH(*fmt))) {
d509 1
a509 1
		} else if (isalpha(UCH(*fmt))) {
d538 5
d565 2
a566 2
			CTRACE((tfp, "unknown format character '%c' in %s\n",
				    *fmt, format));
a582 1
		    /* FALLTHRU */
a583 1
		    /* FALLTHRU */
a586 1
		    break;
a587 1
		    break;
a592 1
		    break;
a625 1
#ifndef SAVE_TIME_NOT_SPACE
a627 1
#endif
d630 1
a630 1
	*pstr = dst_ptr;
a632 1
#undef SAVE_TIME_NOT_SPACE
d635 3
a637 3
 * Replacement for sprintf, allocates buffer on the fly according to what's
 * needed for its arguments.  Unlike sprintf, this always concatenates to the
 * destination buffer.
a638 5
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf in LYLeaks.c. - kw */
#ifdef HTSprintf		/* if hidden by LYLeaks stuff */
#undef HTSprintf
#endif
a669 5
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf0 in LYLeaks.c. - kw */
#ifdef HTSprintf0		/* if hidden by LYLeaks stuff */
#undef HTSprintf0
#endif
a685 9
#ifdef USE_VASPRINTF
	if (pstr) {
	    if (*pstr)
		FREE(*pstr);
	    if (vasprintf(pstr, fmt, ap) >= 0) /* else call outofmem?? */
		mark_malloced(*pstr, strlen(*pstr)+1);
	    result = *pstr;
	} else
#endif /* USE_VASPRINTF */
d711 1
a711 1
	 || isspace(UCH(parameter[i])))
d728 3
a731 7
	    /* Note:  No special handling of other characters, including
	       backslash, since we are constructing a single-quoted string!
	       Backslash has no special escape meaning within those for sh
	       and compatible shells, so trying to escape a backslash by
	       doubling it is unnecessary and would be interpreted by the
	       shell as an additional data character. - kw 2000-05-02
	       */
d809 1
a809 1
				+ ((*result != 0) ? strlen(*result) : 0);
d814 1
a814 1
		CTRACE((tfp, "PARAM-EXP:%s\n", *result));
a842 1
#if USE_QUOTED_PARAMETER
a843 1
#endif
d854 1
a854 1
				+ ((*result != 0) ? strlen(*result) : 0);
d865 1
a865 1
		CTRACE((tfp, "PARAM-ADD:%s\n", *result));
a883 1

d891 1
a891 210
    CTRACE((tfp, "PARAM-END:%s\n", *result));
}


/*	Binary-strings (may have embedded nulls).
 *	Some modules (HTGopher) assume there is a null on the end, anyway.
 */

/*	Allocate a new bstring, and return it.
*/
PUBLIC void HTSABCopy ARGS3(
	bstring**,	dest,
	CONST char *,	src,
	int,		len)
{
    bstring *t;
    unsigned need = len + 1;

    CTRACE2(TRACE_BSTRING, (tfp, "HTSABCopy(%p, %p, %d)\n", dest, src, len));
    HTSABFree(dest);
    if (src) {
	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if ((t = (bstring*) malloc(sizeof(bstring))) == NULL)
	    outofmem(__FILE__, "HTSABCopy");
	if ((t->str = (char *) malloc (need)) == NULL)
	    outofmem(__FILE__, "HTSABCopy");
	memcpy (t->str, src, len);
	t->len = len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/*
 * Initialize with a null-terminated string (discards the null).
 */
PUBLIC void HTSABCopy0 ARGS2(
	bstring**,	dest,
	CONST char *,	src)
{
    HTSABCopy(dest, src, strlen(src));
}

/*
 * Append a block of memory to a bstring.
 */
PUBLIC void HTSABCat ARGS3(
	bstring **,	dest,
	CONST char *,	src,
	int,		len)
{
    bstring *t = *dest;

    CTRACE2(TRACE_BSTRING, (tfp, "HTSABCat(%p, %p, %d)\n", dest, src, len));
    if (src) {
	unsigned need = len + 1;

	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if (t) {
	    unsigned length = t->len + need;
	    if ((t->str = (char *)realloc(t->str, length)) == NULL)
		outofmem(__FILE__, "HTSACat");
	} else {
	    if ((t = typecalloc(bstring)) == NULL)
		outofmem(__FILE__, "HTSACat");
	    t->str = (char *)malloc(need);
	}
	if (t->str == NULL)
	    outofmem(__FILE__, "HTSACat");
	memcpy (t->str + t->len, src, len);
	t->len += len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/*
 * Append a null-terminated string (discards the null).
 */
PUBLIC void HTSABCat0 ARGS2(
	bstring**,	dest,
	CONST char *,	src)
{
    HTSABCat(dest, src, strlen(src));
}

/*
 * Compare two bstring's for equality
 */
PUBLIC BOOL HTSABEql   ARGS2(
	bstring *,	a,
	bstring *,	b)
{
    unsigned len_a = (a != 0) ? a->len : 0;
    unsigned len_b = (b != 0) ? b->len : 0;

    if (len_a == len_b) {
	if (len_a == 0
	 || memcmp(a->str, b->str, a->len) == 0)
	    return TRUE;
    }
    return FALSE;
}

/*
 * Deallocate a bstring.
 */
PUBLIC void HTSABFree ARGS1(
	bstring **,	ptr)
{
    if (*ptr != NULL) {
	FREE((*ptr)->str);
	FREE(*ptr);
	*ptr = NULL;
    }
}

/*
 * Use this function to perform formatted sprintf's onto the end of a bstring.
 * The bstring may contain embedded nulls; the formatted portions must not.
 */
#ifdef ANSI_VARARGS
PUBLIC bstring * HTBprintf (bstring ** pstr, CONST char * fmt, ...)
#else
PUBLIC bstring * HTBprintf ()
#endif
{
    bstring *result = 0;
    char *temp = 0;
    va_list ap;

    LYva_start(ap,fmt);
    {
#if !ANSI_VARARGS
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
#endif
	temp = StrAllocVsprintf(&temp, 0, fmt, &ap);
	if (!isEmpty(temp)) {
	    HTSABCat (pstr, temp, strlen(temp));
	}
	FREE(temp);
	result = *pstr;
    }
    va_end(ap);

    return (result);
}

/*
 * Write binary-data to the logfile, making it safe for most editors to view.
 * That is most, since we do not restrict line-length.  Nulls and other
 * non-printing characters are addressed.
 */
PUBLIC void trace_bstring2 ARGS2(
	CONST char *,	text,
	int,		size)
{
    int n;

    if (text != 0) {
	for (n = 0; n < size; ++n) {
	    int ch = UCH(text[n]);
	    switch (ch) {
	    case '\\':
		fputs("\\\\", tfp);
		break;
	    case '\r':
		fputs("\\r", tfp);
		break;
	    case '\t':
		fputs("\\t", tfp);
		break;
	    case '\f':
		fputs("\\f", tfp);
		break;
	    default:
		if (isprint(ch) || isspace(ch)) {
		    fputc(ch, tfp);
		} else {
		    fprintf(tfp, "\\%03o", ch);
		}
		break;
	    }
	}
    }
}

PUBLIC void trace_bstring ARGS1(
	bstring *,	data)
{
    trace_bstring2(BStrData(data), BStrLen(data));
@


1.1.3.2
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d1004 6
a1009 5
 * Append string to a system command that we are constructing, without quoting. 
 * We're given the index of the newest parameter we're processing.  Zero
 * indicates none, so a value of '1' indicates that we copy from the beginning
 * of the command string up to the first parameter, substitute the quoted
 * parameter and return the result.
d1014 1
a1014 1
PUBLIC void HTAddToCmd ARGS4(
d1018 1
a1018 1
    CONST char *,	string)
d1023 3
d1030 2
a1031 2
	if (string == 0)
	    string = "";
d1040 7
a1046 1
		HTSACat(result, string);
a1055 22
 * Append string-parameter to a system command that we are constructing.  The
 * string is a complete parameter (which is a necessary assumption so we can
 * quote it properly).
 */
PUBLIC void HTAddParam ARGS4(
    char **,		result,
    CONST char *,	command,
    int,		number,
    CONST char *,	parameter)
{
    if (number > 0) {
#if USE_QUOTED_PARAMETER
	char *quoted = HTQuoteParameter(parameter);
	HTAddToCmd(result, command, number, quoted);
	FREE(quoted);
#else
	HTAddToCmd(result, command, number, parameter);
#endif
    }
}

/*
d1216 1
a1216 2
PUBLIC bstring * HTBprintf (va_alist)
    va_dcl
d1226 1
a1226 1
	bstring **	pstr = va_arg(ap, char **);
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d17 2
a18 2
BOOLEAN WWW_TraceFlag = 0;	/* Global trace flag for ALL W3 code */
int WWW_TraceMask = 0;		/* Global trace flag for ALL W3 code */
d26 1
a26 1
const char * HTLibraryVersion = "2.14FM"; /* String for help screen etc */
d28 1
a28 1
const char * HTLibraryVersion = VC; /* String for help screen etc */
d38 3
a40 3
int strcasecomp8 (
       const char*    a,
       const char *   b)
d42 2
a43 2
    const char *p = a;
    const char *q = b;
d63 4
a66 4
int strncasecomp8 (
	const char*	a,
	const char *	b,
	int		n)
d68 2
a69 2
    const char *p = a;
    const char *q = b;
d128 3
a130 3
int strcasecomp (
	const char*	s1,
	const char*	s2)
d142 4
a145 4
int strncasecomp (
	const char*	a,
	const char*	b,
	int		n)
d162 3
a164 3
int strcasecomp (
	const char*	a,
	const char *	b)
d166 2
a167 2
    const char *p = a;
    const char *q = b;
d184 4
a187 4
int strncasecomp (
	const char*	a,
	const char *	b,
	int		n)
d189 2
a190 2
    const char *p = a;
    const char *q = b;
d213 3
a215 3
int AS_casecomp (
	const char*	p,
	const char*	q)
d235 4
a238 4
int AS_ncmp (
	const char *	p,
	const char *	q,
	unsigned int	n)
d240 1
a240 1
    const char *a = p;
d258 3
a260 3
int AS_cmp (
	const char *	p,
	const char *	q)
d269 3
a271 3
char * HTSACopy (
	char **	dest,
	const char *	src)
d290 3
a292 3
char * HTSACat (
	char **	dest,
	const char *	src)
d317 2
a318 2
void   HTSAFree_extra (
	char *		s)
d324 3
a326 3
char * HTSACopy_extra (
	char **	dest,
	const char *	src)
d365 2
a366 2
char * HTNextField (
	char **	pstr)
d420 5
a424 5
char * HTNextTok (
	char **	pstr,
	const char *	delims,
	const char *	bracks,
	char *		found)
d524 1
a524 1
static char *HTAlloc (char *  ptr, size_t  length)
d563 5
a567 5
PUBLIC_IF_FIND_LEAKS char * StrAllocVsprintf (
	char **	pstr,
	size_t		dst_len,
	const char *	fmt,
	va_list *	ap)
d581 1
a581 1
    const char *format = fmt;
d802 1
a802 1
char * HTSprintf (char ** pstr, const char * fmt, ...)
d804 1
a804 1
char * HTSprintf (va_alist)
d816 1
a816 1
	const char *	fmt  = va_arg(ap, const char *);
d838 1
a838 1
char * HTSprintf0 (char ** pstr, const char * fmt, ...)
d840 1
a840 1
char * HTSprintf0 (va_alist)
d851 1
a851 1
	const char *	fmt  = va_arg(ap, const char *);
d876 2
a877 2
char *HTQuoteParameter (
    const char *	parameter)
d880 1
a880 1
    size_t last;
a884 4
    if (parameter == 0)
	parameter = "";

    last = strlen(parameter);
d927 2
a928 2
int HTCountCommandArgs (
    const char *	command)
d942 3
a944 3
static const char *HTAfterCommandArg (
    const char *	command,
    int		number)
d971 5
a975 5
void HTAddXpand (
    char **		result,
    const char *	command,
    int		number,
    const char *	parameter)
d978 2
a979 2
	const char *last = HTAfterCommandArg(command, number - 1);
	const char *next = last;
d1013 5
a1017 5
void HTAddToCmd (
    char **		result,
    const char *	command,
    int		number,
    const char *	string)
d1020 2
a1021 2
	const char *last = HTAfterCommandArg(command, number - 1);
	const char *next = last;
d1050 5
a1054 5
void HTAddParam (
    char **		result,
    const char *	command,
    int		number,
    const char *	parameter)
d1071 4
a1074 4
void HTEndParam (
    char **		result,
    const char *	command,
    int		number)
d1076 1
a1076 1
    const char *last;
d1096 4
a1099 4
void HTSABCopy (
	bstring**	dest,
	const char *	src,
	int		len)
d1131 3
a1133 3
void HTSABCopy0 (
	bstring**	dest,
	const char *	src)
d1141 4
a1144 4
void HTSABCat (
	bstring **	dest,
	const char *	src,
	int		len)
d1183 3
a1185 3
void HTSABCat0 (
	bstring**	dest,
	const char *	src)
d1193 3
a1195 3
BOOL HTSABEql   (
	bstring *	a,
	bstring *	b)
d1211 2
a1212 2
void HTSABFree (
	bstring **	ptr)
d1226 1
a1226 1
bstring * HTBprintf (bstring ** pstr, const char * fmt, ...)
d1228 1
a1228 1
bstring * HTBprintf (va_alist)
d1240 1
a1240 1
	const char *	fmt  = va_arg(ap, const char *);
d1259 3
a1261 3
void trace_bstring2 (
	const char *	text,
	int		size)
d1293 2
a1294 2
void trace_bstring (
	bstring *	data)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 8
a9 8
 *
 *	Original version came with listserv implementation.
 *	Version TBL Oct 91 replaces one which modified the strings.
 *	02-Dec-91 (JFG) Added stralloccopy and stralloccat
 *	23 Jan 92 (TBL) Changed strallocc* to 8 char HTSAC* for VM and suchlike
 *	 6 Oct 92 (TBL) Moved WWW_TraceFlag in here to be in library
 *	15 Nov 98 (TD)  Added HTSprintf.
 */
d26 1
a26 2
const char *HTLibraryVersion = "2.14FM";	/* String for help screen etc */

d28 1
a28 1
const char *HTLibraryVersion = VC;	/* String for help screen etc */
d32 9
a40 8
 *     strcasecomp8 is a variant of strcasecomp (below)
 *     ------------		    -----------
 *     but uses 8bit upper/lower case information
 *     from the current display charset.
 *     It returns 0 if exact match.
 */
int strcasecomp8(const char *a,
		 const char *b)
d45 1
a45 1
    for (; *p && *q; p++, q++) {
d47 1
a47 3

	if (diff)
	    return diff;
d50 1
a50 1
	return 1;		/* p was longer than q */
d52 2
a53 2
	return -1;		/* p was shorter than q */
    return 0;			/* Exact match */
d57 10
a66 9
 *     strncasecomp8 is a variant of strncasecomp (below)
 *     -------------		     ------------
 *     but uses 8bit upper/lower case information
 *     from the current display charset.
 *     It returns 0 if exact match.
 */
int strncasecomp8(const char *a,
		  const char *b,
		  int n)
d71 1
a71 1
    for (;; p++, q++) {
d73 2
a74 3

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
d81 1
a81 1
    /*NOTREACHED */
d84 1
a84 1
#ifndef VM			/* VM has these already it seems */
d86 1
a86 1
#ifdef SH_EX			/* 1997/12/23 (Tue) 16:40:31 */
d93 33
a125 34
static unsigned char charmap[] =
{
    '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
    '\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
    '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
    '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
    '\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
    '\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
    '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
    '\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
    '\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
    '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
    '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
    '\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
    '\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
    '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
    '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
    '\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
    '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
    '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
    '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
    '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
    '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
    '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
    '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
    '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
    '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
    '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
    '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\327',
    '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\337',
    '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
    '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
    '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
    '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
d128 3
a130 2
int strcasecomp(const char *s1,
		const char *s2)
d133 2
a134 2
    register unsigned char *us1 = (unsigned char *) s1;
    register unsigned char *us2 = (unsigned char *) s2;
d138 1
a138 1
	    return (0);
d142 4
a145 3
int strncasecomp(const char *a,
		 const char *b,
		 int n)
d148 2
a149 2
    register unsigned char *us1 = (unsigned char *) a;
    register unsigned char *us2 = (unsigned char *) b;
d151 1
a151 1
    while ((long) (--n) >= 0 && cm[*us1] == cm[*us2++])
d153 2
a154 2
	    return (0);
    return ((long) n < 0 ? 0 : cm[*us1] - cm[*--us2]);
d157 1
a157 1
#else /* SH_EX */
d160 5
a164 4
 *	---------------------
 */
int strcasecomp(const char *a,
		const char *b)
d169 1
a169 1
    for (; *p && *q; p++, q++) {
d171 1
a171 3

	if (diff)
	    return diff;
d174 1
a174 1
	return 1;		/* p was longer than q */
d176 2
a177 2
	return -1;		/* p was shorter than q */
    return 0;			/* Exact match */
d180 1
d182 6
a187 5
 *	----------------
 */
int strncasecomp(const char *a,
		 const char *b,
		 int n)
d192 1
a192 1
    for (;; p++, q++) {
d194 2
a195 3

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
d202 1
a202 1
    /*NOTREACHED */
d205 1
a205 1
#endif /* SH_EX */
d211 5
a215 4
 *	----------------
 */
int AS_casecomp(const char *p,
		const char *q)
d219 1
a219 1
    for (;; p++, q++) {
d221 1
a221 1
	    return (UCH(*p) - UCH(*q));
d223 1
a223 1
	    - TOASCII(TOLOWER(*q));
d227 1
a227 1
    /*NOTREACHED */
d230 1
d232 7
a238 6
 *	----------------
 *	AS_cmp uses n == -1 to compare indefinite length.
 */
int AS_ncmp(const char *p,
	    const char *q,
	    unsigned int n)
d243 1
a243 1
    for (; (unsigned) (p - a) < n; p++, q++) {
d247 1
a247 1
	    - TOASCII(*q);
d251 12
a262 1
    return 0;			/*   Match up to n characters */
d266 1
d269 3
a271 2
char *HTSACopy(char **dest,
	       const char *src)
a275 1

d290 3
a292 2
char *HTSACat(char **dest,
	      const char *src)
d297 1
a297 2

	    *dest = (char *) realloc(*dest, length + strlen(src) + 1);
d300 1
a300 1
	    strcpy(*dest + length, src);
d302 1
a302 1
	    *dest = (char *) malloc(strlen(src) + 1);
d305 1
a305 1
	    strcpy(*dest, src);
d311 1
d314 1
a314 1
#define EXTRA_TYPE size_t	/* type we use for length */
d317 2
a318 1
void HTSAFree_extra(char *s)
d324 3
a326 2
char *HTSACopy_extra(char **dest,
		     const char *src)
d333 1
a333 1
	    size = *(EXTRA_TYPE *) ((*dest) - EXTRA_SIZE);
d337 1
a337 1
	    size = srcsize * 2;	/* x2 step */
d341 1
a341 1
	    *(EXTRA_TYPE *) (*dest) = size;
d352 15
a366 14
 *	---------------
 *
 * On entry,
 *	*pstr	points to a string containig white space separated
 *		field, optionlly quoted.
 *
 * On exit,
 *	*pstr	has been moved to the first delimiter past the
 *		field
 *		THE STRING HAS BEEN MUTILATED by a 0 terminator
 *
 *	returns a pointer to the first field
 */
char *HTNextField(char **pstr)
d368 2
a369 2
    char *p = *pstr;
    char *start;		/* start of field */
d372 1
a372 1
	p++;			/* Strip white space */
d377 1
a377 1
    if (*p == '"') {		/* quoted field */
d380 1
a380 1
	for (; *p && *p != '"'; p++) {
d382 1
a382 1
		p++;		/* Skip escaped chars */
d387 1
a387 1
	    p++;		/* Skip first field */
d396 29
a424 28
 *	---------------
 *	Finds the next token in a string
 *	On entry,
 *	*pstr	points to a string to be parsed.
 *	delims	lists characters to be recognized as delimiters.
 *		If NULL, default is white space "," ";" or "=".
 *		The word can optionally be quoted or enclosed with
 *		chars from bracks.
 *		Comments surrrounded by '(' ')' are filtered out
 *		unless they are specifically reqested by including
 *		' ' or '(' in delims or bracks.
 *	bracks	lists bracketing chars.  Some are recognized as
 *		special, for those give the opening char.
 *		If NULL, defaults to <"> and "<" ">".
 *	found	points to location to fill with the ending delimiter
 *		found, or is NULL.
 *
 *	On exit,
 *	*pstr	has been moved to the first delimiter past the
 *		field
 *		THE STRING HAS BEEN MUTILATED by a 0 terminator
 *	found	points to the delimiter found unless it was NULL.
 *	Returns a pointer to the first word or NULL on error
 */
char *HTNextTok(char **pstr,
		const char *delims,
		const char *bracks,
		char *found)
d426 2
a427 2
    char *p = *pstr;
    char *start = NULL;
d433 7
a439 10
    if (isEmpty(pstr))
	return NULL;
    if (!delims)
	delims = " ;,=";
    if (!bracks)
	bracks = "<\"";

    get_blanks = (BOOL) (!strchr(delims, ' ') && !strchr(bracks, ' '));
    get_comments = (BOOL) (strchr(bracks, '(') != NULL);
    skip_comments = (BOOL) (!get_comments && !strchr(delims, '(') && !get_blanks);
d443 1
a443 1
	p++;			/* Strip white space */
d446 1
a446 2
	if (found)
	    *found = '\0';
d451 1
a451 2
	while (*p && (skipWHITE(*p) || strchr(delims, *p)))
	    p++;
d454 2
a455 3
	    if (found)
		*found = *(p - 1);
	    return NULL;	/* No field */
d458 1
a458 1
	if (*p == '(' && (skip_comments || get_comments)) {	/* Comment */
d460 7
a466 12

	    if (get_comments && !start)
		start = p + 1;
	    for (; *p && (*p != ')' || --comment_level > 0); p++) {
		if (*p == '(')
		    comment_level++;
		else if (*p == '"') {	/* quoted field within Comment */
		    for (p++; *p && *p != '"'; p++)
			if (*p == '\\' && *(p + 1))
			    p++;	/* Skip escaped chars */
		    if (!*p)
			break;	/* (invalid) end of string found, leave */
d468 1
a468 2
		if (*p == '\\' && *(p + 1))
		    p++;	/* Skip escaped chars */
d472 1
a472 2
	    if (*p)
		p++;
d474 1
a474 1
		if (!*p || (!strchr(bracks, *p) && strchr(delims, *p))) {
d477 1
a477 1
		    get_closing_char_too = (BOOL) (strchr(bracks, *p) != NULL);
d479 1
a479 1
	} else if (strchr(bracks, *p)) {	/* quoted or bracketed field */
d481 5
a485 14
	    case '<':
		closer = '>';
		break;
	    case '[':
		closer = ']';
		break;
	    case '{':
		closer = '}';
		break;
	    case ':':
		closer = ';';
		break;
	    default:
		closer = *p;
d487 3
a489 5
	    if (!start)
		start = ++p;
	    for (; *p && *p != closer; p++)
		if (*p == '\\' && *(p + 1))
		    p++;	/* Skip escaped chars */
d492 1
a492 1
		if (!*p || (!strchr(bracks, *p) && strchr(delims, *p))) {
d495 1
a495 1
		    get_closing_char_too = (BOOL) (strchr(bracks, *p) != NULL);
d497 5
a501 6
		break;		/* kr95-10-9: needs to stop here */
	} else {		/* Spool field */
	    if (!start)
		start = p;
	    while (*p && !skipWHITE(*p) && !strchr(bracks, *p) &&
		   !strchr(delims, *p))
d503 1
a503 1
	    if (*p && strchr(bracks, *p)) {
d506 1
a506 1
		if (*p == '(' && skip_comments) {
d508 1
a508 1
		    HTNextTok(pstr, NULL, "(", found);	/*      Advance pstr */
d510 1
a510 2
		    if (*pstr && **pstr)
			(*pstr)++;
d513 1
a513 1
		break;		/* Got it */
d517 1
a517 2
    if (found)
	*found = *p;
d519 1
a519 2
    if (*p)
	*p++ = '\0';
d524 1
a524 1
static char *HTAlloc(char *ptr, size_t length)
d527 1
a527 1
	ptr = (char *) realloc(ptr, length);
d529 1
a529 1
	ptr = (char *) malloc(length);
d550 1
a550 7
typedef enum {
    Flags,
    Width,
    Prec,
    Type,
    Format
} PRINTF;
d556 1
a556 1
#define NUM_WIDTH 10		/* allow for width substituted for "*" in "%*s" */
d563 5
a567 4
PUBLIC_IF_FIND_LEAKS char *StrAllocVsprintf(char **pstr,
					    size_t dst_len,
					    const char *fmt,
					    va_list * ap)
a573 1

d591 2
a592 2
	    mark_malloced(*pstr, strlen(*pstr) + 1);
	    return (*pstr);
d599 2
a600 2
    if (!fmt_ptr || fmt_len < need * NUM_WIDTH) {
	fmt_ptr = HTAlloc(fmt_ptr, fmt_len = need * NUM_WIDTH);
d606 2
a607 2
    if ((fmt_ptr = malloc(need * NUM_WIDTH)) == 0
	|| (tmp_ptr = malloc(tmp_len)) == 0) {
d625 9
a633 9
	    char *pval = dummy;	/* avoid const-cast */
	    double fval = 0.0;
	    int done = FALSE;
	    int ival = 0;
	    int prec = -1;
	    int type = 0;
	    int used = 0;
	    int width = -1;
	    size_t f = 0;
a640 1

a653 1

d666 4
a669 4
		    case 'Z':	/* FALLTHRU */
		    case 'h':	/* FALLTHRU */
		    case 'l':	/* FALLTHRU */
		    case 'L':	/* FALLTHRU */
d673 6
a678 6
		    case 'o':	/* FALLTHRU */
		    case 'i':	/* FALLTHRU */
		    case 'd':	/* FALLTHRU */
		    case 'u':	/* FALLTHRU */
		    case 'x':	/* FALLTHRU */
		    case 'X':	/* FALLTHRU */
a680 1

a684 1

d687 6
a692 7
		    case 'f':	/* FALLTHRU */
		    case 'e':	/* FALLTHRU */
		    case 'E':	/* FALLTHRU */
		    case 'g':	/* FALLTHRU */
		    case 'G':	/* FALLTHRU */
			VA_FLOAT(double);

a696 1

a700 1

a706 1

a710 1

d715 1
a715 1
				*fmt, format));
d737 1
a737 1
			width = prec + 2;	/* leading sign/space/zero, "0x" */
d749 1
a749 1
	    if (width >= (int) tmp_len) {
d801 6
a806 1
char *HTSprintf(char **pstr, const char *fmt,...)
d812 1
a812 1
    LYva_start(ap, fmt);
d814 4
d837 6
a842 1
char *HTSprintf0(char **pstr, const char *fmt,...)
d847 1
a847 1
    LYva_start(ap, fmt);
d849 4
d857 2
a858 2
	    if (vasprintf(pstr, fmt, ap) >= 0)	/* else call outofmem?? */
		mark_malloced(*pstr, strlen(*pstr) + 1);
d862 1
a862 1
	    result = StrAllocVsprintf(pstr, 0, fmt, &ap);
d876 2
a877 1
char *HTQuoteParameter(const char *parameter)
d883 1
a883 1
    char *result;
d889 1
a889 1
    for (i = 0; i < last; ++i)
d891 1
a891 1
	    || isspace(UCH(parameter[i])))
d894 1
a894 1
    result = (char *) malloc(last + 5 * quoted + 3);
d915 1
a915 1
	     */
d931 2
a932 1
int HTCountCommandArgs(const char *command)
a934 1

d946 3
a948 2
static const char *HTAfterCommandArg(const char *command,
				     int number)
d975 5
a979 4
void HTAddXpand(char **result,
		const char *command,
		int number,
		const char *parameter)
d993 1
a993 2
		    + ((*result != 0) ? strlen(*result) : 0);

d1017 5
a1021 4
void HTAddToCmd(char **result,
		const char *command,
		int number,
		const char *string)
d1036 1
a1036 2
		    + ((*result != 0) ? strlen(*result) : 0);

d1054 5
a1058 4
void HTAddParam(char **result,
		const char *command,
		int number,
		const char *parameter)
a1062 1

d1075 4
a1078 3
void HTEndParam(char **result,
		const char *command,
		int number)
d1083 1
a1083 1
    count = HTCountCommandArgs(command);
d1093 3
a1095 2
/* Binary-strings (may have embedded nulls).  Some modules (HTGopher) assume
 * there is a null on the end, anyway.
d1098 1
a1098 1
/* Allocate a new bstring, and return it.
d1100 4
a1103 2
void HTSABCopy(bstring **dest, const char *src,
	       int len)
d1116 3
a1118 4
	if ((t = (bstring *) malloc(sizeof(bstring))) == NULL)
	      outofmem(__FILE__, "HTSABCopy");

	if ((t->str = (char *) malloc(need)) == NULL)
d1120 1
a1120 1
	memcpy(t->str, src, len);
d1135 3
a1137 1
void HTSABCopy0(bstring **dest, const char *src)
d1145 4
a1148 2
void HTSABCat(bstring **dest, const char *src,
	      int len)
d1163 1
a1163 2

	    if ((t->str = (char *) realloc(t->str, length)) == NULL)
d1167 2
a1168 3
		  outofmem(__FILE__, "HTSACat");

	    t->str = (char *) malloc(need);
d1172 1
a1172 1
	memcpy(t->str + t->len, src, len);
d1187 3
a1189 1
void HTSABCat0(bstring **dest, const char *src)
d1197 3
a1199 1
BOOL HTSABEql(bstring *a, bstring *b)
d1206 1
a1206 1
	    || memcmp(a->str, b->str, a->len) == 0)
d1215 2
a1216 1
void HTSABFree(bstring **ptr)
d1229 6
a1234 1
bstring *HTBprintf(bstring **pstr, const char *fmt,...)
d1240 1
a1240 1
    LYva_start(ap, fmt);
d1242 4
d1248 1
a1248 1
	    HTSABCat(pstr, temp, strlen(temp));
d1263 3
a1265 2
void trace_bstring2(const char *text,
		    int size)
a1271 1

d1297 2
a1298 1
void trace_bstring(bstring *data)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d16 1
a16 4
#ifndef NO_LYNX_TRACE
PUBLIC BOOLEAN WWW_TraceFlag = 0;	/* Global trace flag for ALL W3 code */
PUBLIC int WWW_TraceMask = 0;		/* Global trace flag for ALL W3 code */
#endif
a21 3
#ifdef _WINDOWS
CONST char * HTLibraryVersion = "2.14FM"; /* String for help screen etc */
#else
a22 1
#endif
a75 1

a77 73
#ifdef SH_EX	/* 1997/12/23 (Tue) 16:40:31 */

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static unsigned char charmap[] = {
	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\327',
	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\337',
	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};

PUBLIC int strcasecomp ARGS2(
	CONST char*,	s1,
	CONST char*,	s2)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *)s1;
    register unsigned char *us2 = (unsigned char *)s2;

    while (cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return(0);
    return (cm[*us1] - cm[*--us2]);
}

PUBLIC int strncasecomp ARGS3(
	CONST char*,	a,
	CONST char*,	b,
	int,		n)
{
    register unsigned char *cm = charmap;
    register unsigned char *us1 = (unsigned char *)a;
    register unsigned char *us2 = (unsigned char *)b;

    while ((long)(--n) >= 0 && cm[*us1] == cm[*us2++])
	if (*us1++ == '\0')
	    return(0);
    return ((long)n < 0 ? 0 : cm[*us1] - cm[*--us2]);
}

#else	/* SH_EX */

a122 2

#endif	/* SH_EX */
d138 1
a138 1
	    return (UCH(*p)  - UCH(*q));
d162 1
a162 1
	    return (UCH(*p) - UCH(*q));
d278 1
a278 1
**		If NULL, default is white space "," ";" or "=".
d286 1
a286 1
**		If NULL, defaults to <"> and "<" ">".
d301 1
a301 1
	char *,		found)
d313 3
a315 3
    get_blanks = (BOOL) (!strchr(delims,' ') && !strchr(bracks,' '));
    get_comments = (BOOL) (strchr(bracks,'(') != NULL);
    skip_comments = (BOOL) (!get_comments && !strchr(delims,'(') && !get_blanks);
d353 1
a353 1
		    get_closing_char_too = (BOOL) (strchr(bracks,*p) != NULL);
d355 1
a355 1
	} else if (strchr(bracks,*p)) {	       /* quoted or bracketed field */
d371 1
a371 1
		    get_closing_char_too = (BOOL) (strchr(bracks,*p) != NULL);
d374 7
a418 10
 * If SAVE_TIME_NOT_SPACE is defined, StrAllocVsprintf will hang on to
 * its temporary string buffers instead of allocating and freeing them
 * in each invocation.  They only grow and never shrink, and won't be
 * cleaned up on exit. - kw
 */
#if defined(_REENTRANT) || defined(_THREAD_SAFE) || defined(LY_FIND_LEAKS)
#undef SAVE_TIME_NOT_SPACE
#endif

/*
d436 1
a436 1
PUBLIC_IF_FIND_LEAKS char * StrAllocVsprintf ARGS4(
a441 6
#ifdef SAVE_TIME_NOT_SPACE
    static size_t tmp_len = 0;
    static size_t fmt_len = 0;
    static char *tmp_ptr = NULL;
    static char *fmt_ptr = NULL;
#else
d443 1
a445 2
#endif /* SAVE_TIME_NOT_SPACE */
    size_t have, need;
a451 11
#ifdef USE_VASPRINTF
    if (pstr && !dst_len) {
	if (*pstr)
	    FREE(*pstr);
	if (vasprintf(pstr, fmt, *ap) >= 0) {
	    mark_malloced(*pstr, strlen(*pstr)+1);
	    return(*pstr);
	}
    }
#endif /* USE_VASPRINTF */

a452 8
#ifdef SAVE_TIME_NOT_SPACE
    if (!fmt_ptr || fmt_len < need*NUM_WIDTH) {
	fmt_ptr = HTAlloc(fmt_ptr, fmt_len = need*NUM_WIDTH);
    }
    if (!tmp_ptr || tmp_len < GROW_SIZE) {
	tmp_ptr = HTAlloc(tmp_ptr, tmp_len = GROW_SIZE);
    }
#else
a456 1
#endif /* SAVE_TIME_NOT_SPACE */
d485 1
a485 1
		if (isdigit(UCH(*fmt))) {
d509 1
a509 1
		} else if (isalpha(UCH(*fmt))) {
d538 5
d565 2
a566 2
			CTRACE((tfp, "unknown format character '%c' in %s\n",
				    *fmt, format));
a582 1
		    /* FALLTHRU */
a583 1
		    /* FALLTHRU */
a586 1
		    break;
a587 1
		    break;
a592 1
		    break;
a625 1
#ifndef SAVE_TIME_NOT_SPACE
a627 1
#endif
d630 1
a630 1
	*pstr = dst_ptr;
a632 1
#undef SAVE_TIME_NOT_SPACE
a638 5
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf in LYLeaks.c. - kw */
#ifdef HTSprintf		/* if hidden by LYLeaks stuff */
#undef HTSprintf
#endif
a669 5
/* Note: if making changes, also check the memory tracking version
 * LYLeakHTSprintf0 in LYLeaks.c. - kw */
#ifdef HTSprintf0		/* if hidden by LYLeaks stuff */
#undef HTSprintf0
#endif
a685 9
#ifdef USE_VASPRINTF
	if (pstr) {
	    if (*pstr)
		FREE(*pstr);
	    if (vasprintf(pstr, fmt, ap) >= 0) /* else call outofmem?? */
		mark_malloced(*pstr, strlen(*pstr)+1);
	    result = *pstr;
	} else
#endif /* USE_VASPRINTF */
d711 1
a711 1
	 || isspace(UCH(parameter[i])))
d728 3
a731 7
	    /* Note:  No special handling of other characters, including
	       backslash, since we are constructing a single-quoted string!
	       Backslash has no special escape meaning within those for sh
	       and compatible shells, so trying to escape a backslash by
	       doubling it is unnecessary and would be interpreted by the
	       shell as an additional data character. - kw 2000-05-02
	       */
d809 1
a809 1
				+ ((*result != 0) ? strlen(*result) : 0);
d814 1
a814 1
		CTRACE((tfp, "PARAM-EXP:%s\n", *result));
a842 1
#if USE_QUOTED_PARAMETER
a843 1
#endif
d854 1
a854 1
				+ ((*result != 0) ? strlen(*result) : 0);
d865 1
a865 1
		CTRACE((tfp, "PARAM-ADD:%s\n", *result));
d891 1
a891 62
    CTRACE((tfp, "PARAM-END:%s\n", *result));
}


#ifdef EXP_FILE_UPLOAD
/*	bstring Allocate and Concatenate
*/

/*	Allocate a new copy of a bstring, and returns it
*/
PUBLIC void HTSABCopy ARGS3(
	bstring**,	dest,
	CONST char *,	src,
	int,		len)
{
    bstring *t;
    CTRACE((tfp, "HTSABCopy(%p, %p, %d)\n", dest, src, len));
    /* if we already have a bstring ** ... */
    if (dest) {
	/* ... with a valid bstring *, free it ... */
	if (*dest) {
	    FREE((*dest)->str);
	    FREE(*dest);
	}
	*dest = malloc(sizeof(bstring));
	if (src) {
	    CTRACE((tfp, "%% [%s]\n", src));
	    t = (bstring*) malloc(sizeof(bstring));
	    if (t == NULL)
		outofmem(__FILE__, "HTSABCopy");
	    t->str = (char *) malloc (len);
	    if (t->str == NULL)
		outofmem(__FILE__, "HTSABCopy");
	    memcpy (t->str, src, len);
	    t->len = len;
	    *dest = t;
	}
    }
}

PUBLIC void HTSABCat ARGS3(
	bstring **,	dest,
	CONST char *,	src,
	int,		len)
{
    bstring *t = *dest;
    if (src) {
	if (t) {
	    int length = t->len;
	    t->str = (char *)realloc(t->str, length + len);
	} else {
	    t = typecalloc(bstring);
	    if (t == NULL)
		outofmem(__FILE__, "HTSACat");
	    t->str = (char *)malloc(len);
	}
	if (t->str == NULL)
	    outofmem(__FILE__, "HTSACat");
	memcpy (t->str + t->len, src, len);
	t->len += len;
	*dest = t;
    }
a892 1
#endif /* EXP_FILE_UPLOAD */
@

