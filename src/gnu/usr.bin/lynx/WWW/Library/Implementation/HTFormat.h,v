head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.10.26.20;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.33;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.26;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.44;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.55;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.23;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.48;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.23;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.10;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.46.32;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.32;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@/*                                            HTFormat: The format manager in the WWW Library
                            MANAGE DIFFERENT DOCUMENT FORMATS

   Here we describe the functions of the HTFormat module which handles conversion between
   different data representations.  (In MIME parlance, a representation is known as a
   content-type.  In WWW the term "format" is often used as it is shorter).

   This module is implemented by HTFormat.c.  This hypertext document is used to generate
   the HTFormat.h include file.  Part of the WWW library.

Preamble

 */
#ifndef HTFORMAT_H
#define HTFORMAT_H

#include <HTStream.h>
#include <HTAtom.h>
#include <HTList.h>
#include <HTAnchor.h>

#ifdef USE_SOURCE_CACHE
#include <HTChunk.h>
#endif

#ifdef USE_BZLIB
#include <bzlib.h>
#endif

#ifdef USE_ZLIB
#include <zlib.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
/*

   These macros (which used to be constants) define some basic internally
   referenced representations.  The www/xxx ones are of course not MIME
   standard.

   www/source is an output format which leaves the input untouched.  It is
   useful for diagnostics, and for users who want to see the original, whatever
   it is.

																	 *//* Internal ones *//* #define WWW_SOURCE HTAtom_for("www/source") *//* Whatever it was originally */ extern HTAtom *WWW_SOURCE;
    /* calculated once, heavy used */

/*

   www/present represents the user's perception of the document.  If you
   convert to www/present, you present the material to the user.

 */
#define WWW_PRESENT HTAtom_for("www/present")	/* The user's perception */

#define WWW_DEBUG       HTAtom_for("www/debug")
/*

   WWW_DEBUG represents the user's perception of debug information, for example
   sent as a HTML document in a HTTP redirection message.

 */

/*

   The message/rfc822 format means a MIME message or a plain text message with
   no MIME header.  This is what is returned by an HTTP server.

 */
#define WWW_MIME HTAtom_for("www/mime")		/* A MIME message */

/*
  For parsing only the header. - kw
  */
#define WWW_MIME_HEAD   HTAtom_for("message/x-rfc822-head")

/*

   www/print is like www/present except it represents a printed copy.

 */
#define WWW_PRINT HTAtom_for("www/print")	/* A printed copy */

/*

   www/unknown is a really unknown type.  Some default action is appropriate.

 */
#define WWW_UNKNOWN     HTAtom_for("www/unknown")

#ifdef DIRED_SUPPORT
/*
   www/dired signals directory edit mode.
*/
#define WWW_DIRED      HTAtom_for("www/dired")
#endif

/*

   These are regular MIME types.  HTML is assumed to be added by the W3 code. 
   application/octet-stream was mistakenly application/binary in earlier libwww
   versions (pre 2.11).

 */
#define WWW_PLAINTEXT   HTAtom_for("text/plain")
#define WWW_POSTSCRIPT  HTAtom_for("application/postscript")
#define WWW_RICHTEXT    HTAtom_for("application/rtf")
#define WWW_AUDIO       HTAtom_for("audio/basic")
#define WWW_HTML        HTAtom_for("text/html")
#define WWW_BINARY      HTAtom_for("application/octet-stream")

    typedef HTAtom *HTEncoding;

/*
 * The following are values for the MIME types:
 */
#define WWW_ENC_7BIT            HTAtom_for("7bit")
#define WWW_ENC_8BIT            HTAtom_for("8bit")
#define WWW_ENC_BINARY          HTAtom_for("binary")

/*
 * We also add
 */
#define WWW_ENC_COMPRESS        HTAtom_for("compress")

/*
 * Does a string designate a real encoding, or is it just
 * a "dummy" as for example 7bit, 8bit, and binary?
 */
#define IsUnityEncStr(senc) \
        ((senc)==NULL || *(senc)=='\0' || !strcmp(senc,"identity") ||\
        !strcmp(senc,"8bit") || !strcmp(senc,"binary") || !strcmp(senc,"7bit"))

#define IsUnityEnc(enc) \
        ((enc)==NULL || (enc)==HTAtom_for("identity") ||\
        (enc)==WWW_ENC_8BIT || (enc)==WWW_ENC_BINARY || (enc)==WWW_ENC_7BIT)

/*

The HTPresentation and HTConverter types

   This HTPresentation structure represents a possible conversion algorithm
   from one format to another.  It includes a pointer to a conversion routine. 
   The conversion routine returns a stream to which data should be fed.  See
   also HTStreamStack which scans the list of registered converters and calls
   one.  See the initialisation module for a list of conversion routines.

 */
    typedef struct _HTPresentation HTPresentation;

    typedef HTStream *HTConverter (HTPresentation *pres,
				   HTParentAnchor *anchor,
				   HTStream *sink);

    struct _HTPresentation {
	HTAtom *rep;		/* representation name atomized */
	HTAtom *rep_out;	/* resulting representation */
	HTConverter *converter;	/* routine to gen the stream stack */
	char *command;		/* MIME-format command string */
	char *testcommand;	/* MIME-format test string */
	float quality;		/* Between 0 (bad) and 1 (good) */
	float secs;
	float secs_per_byte;
	long int maxbytes;
	BOOL get_accept;	/* list in "Accept:" for GET */
	int accept_opt;		/* matches against LYAcceptMedia */
    };

/*

   The list of presentations is kept by this module.  It is also scanned by
   modules which want to know the set of formats supported.  for example.

 */
    extern HTList *HTPresentations;

/*

   The default presentation is used when no other is appropriate

 */
    extern HTPresentation *default_presentation;

/*
 * Options used for "Accept:" string
 */
    typedef enum {
	/* make the components powers of two so we can add them */
	mediaINT = 1		/* internal types predefined in HTInit.c */
	,mediaEXT = 2		/* external types predefined in HTInit.c */
	,mediaCFG = 4		/* types, e.g., viewers, from lynx.cfg */
	,mediaUSR = 8		/* user's mime-types, etc. */
	,mediaSYS = 16		/* system's mime-types, etc. */
	/* these are useful flavors for the options menu */
	,mediaOpt1 = mediaINT
	,mediaOpt2 = mediaINT + mediaCFG
	,mediaOpt3 = mediaINT + mediaCFG + mediaUSR
	,mediaOpt4 = mediaINT + mediaCFG + mediaUSR + mediaSYS
	/* this is the flavor from pre-2.8.6 */
	,mediaALL = mediaINT + mediaEXT + mediaCFG + mediaUSR + mediaSYS
    } AcceptMedia;

/*
 * Options used for "Accept-Encoding:" string
 */
    typedef enum {
	encodingNONE = 0
	,encodingGZIP = 1
	,encodingDEFLATE = 2
	,encodingCOMPRESS = 4
	,encodingBZIP2 = 8
	,encodingALL = (encodingGZIP
			+ encodingDEFLATE
			+ encodingCOMPRESS
			+ encodingBZIP2)
    } AcceptEncoding;

/*

HTSetPresentation: Register a system command to present a format

  ON ENTRY,

  rep                     is the MIME - style format name

  command                 is the MAILCAP - style command template

  testcommand             is the MAILCAP - style testcommand template

  quality                 A degradation faction 0..1.0

  secs                    A limit on the time user will wait (0.0 for infinity)
  secs_per_byte

  maxbytes                A limit on the length acceptable as input (0 infinite)

  media                   Used in filtering presentation types for "Accept:"

 */
    extern void HTSetPresentation(const char *representation,
				  const char *command,
				  const char *testcommand,
				  double quality,
				  double secs,
				  double secs_per_byte,
				  long int maxbytes,
				  AcceptMedia media
    );

/*

HTSetConversion:   Register a converstion routine

  ON ENTRY,

  rep_in                  is the content-type input

  rep_out                 is the resulting content-type

  converter               is the routine to make the stream to do it

 */

    extern void HTSetConversion(const char *rep_in,
				const char *rep_out,
				HTConverter *converter,
				float quality,
				float secs,
				float secs_per_byte,
				long int maxbytes,
				AcceptMedia media
    );

/*

HTStreamStack:   Create a stack of streams

   This is the routine which actually sets up the conversion.  It currently
   checks only for direct conversions, but multi-stage conversions are forseen. 
   It takes a stream into which the output should be sent in the final format,
   builds the conversion stack, and returns a stream into which the data in the
   input format should be fed.  The anchor is passed because hypertxet objects
   load information into the anchor object which represents them.

 */
    extern HTStream *HTStreamStack(HTFormat format_in,
				   HTFormat format_out,
				   HTStream *stream_out,
				   HTParentAnchor *anchor);

/*
HTReorderPresentation: put presentation near head of list

    Look up a presentation (exact match only) and, if found, reorder it to the
    start of the HTPresentations list.  - kw
    */

    extern void HTReorderPresentation(HTFormat format_in,
				      HTFormat format_out);

/*
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
    extern void HTFilterPresentations(void);

/*

HTStackValue: Find the cost of a filter stack

   Must return the cost of the same stack which HTStreamStack would set up.

  ON ENTRY,

  format_in               The fomat of the data to be converted

  format_out              The format required

  initial_value           The intrinsic "value" of the data before conversion on a scale
                         from 0 to 1

  length                  The number of bytes expected in the input format

 */
    extern float HTStackValue(HTFormat format_in,
			      HTFormat rep_out,
			      float initial_value,
			      long int length);

#define NO_VALUE_FOUND  -1e20	/* returned if none found */

/*	Display the page while transfer in progress
 *	-------------------------------------------
 *
 *   Repaint the page only when necessary.
 *   This is a traverse call for HText_pageDispaly() - it works!.
 *
 */
    extern void HTDisplayPartial(void);

    extern void HTFinishDisplayPartial(void);

/*

HTCopy:  Copy a socket to a stream

   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.

 */
    extern int HTCopy(HTParentAnchor *anchor,
		      int file_number,
		      void *handle,
		      HTStream *sink);

/*

HTFileCopy:  Copy a file to a stream

   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.  It is currently called by
   HTParseFile

 */
    extern int HTFileCopy(FILE *fp,
			  HTStream *sink);

#ifdef USE_SOURCE_CACHE
/*

HTMemCopy:  Copy a memory chunk to a stream

   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.  It is currently called by
   HTParseMem

 */
    extern int HTMemCopy(HTChunk *chunk,
			 HTStream *sink);
#endif

/*

HTCopyNoCR: Copy a socket to a stream, stripping CR characters.

   It is slower than HTCopy .

 */

    extern void HTCopyNoCR(HTParentAnchor *anchor,
			   int file_number,
			   HTStream *sink);

/*

Clear input buffer and set file number

   This routine and the one below provide simple character input from sockets. 
   (They are left over from the older architecture and may not be used very
   much.) The existence of a common routine and buffer saves memory space in
   small implementations.

 */
    extern void HTInitInput(int file_number);

/*

Get next character from buffer

 */
    extern int interrupted_in_htgetcharacter;
    extern int HTGetCharacter(void);

/*

HTParseSocket: Parse a socket given its format

   This routine is called by protocol modules to load an object.  uses
   HTStreamStack and the copy routines above.  Returns HT_LOADED if successful,
   <0 if not.

 */
    extern int HTParseSocket(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     int file_number,
			     HTStream *sink);

/*

HTParseFile: Parse a File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.

 */
    extern int HTParseFile(HTFormat format_in,
			   HTFormat format_out,
			   HTParentAnchor *anchor,
			   FILE *fp,
			   HTStream *sink);

#ifdef USE_SOURCE_CACHE
/*

HTParseMem: Parse a document in memory

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTMemCopy.  Returns HT_LOADED if successful, can also
   return <0 for failure.

 */
    extern int HTParseMem(HTFormat format_in,
			  HTFormat format_out,
			  HTParentAnchor *anchor,
			  HTChunk *chunk,
			  HTStream *sink);
#endif

#ifdef USE_ZLIB
/*
HTParseGzFile: Parse a gzip'ed File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTGzFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.
 */
    extern int HTParseGzFile(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     gzFile gzfp,
			     HTStream *sink);

/*
HTParseZzFile: Parse a deflate'd File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTZzFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.
 */
    extern int HTParseZzFile(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     FILE *zzfp,
			     HTStream *sink);

#endif				/* USE_ZLIB */

#ifdef USE_BZLIB
/*
HTParseBzFile: Parse a bzip2'ed File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTGzFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.
 */
    extern int HTParseBzFile(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     BZFILE * bzfp,
			     HTStream *sink);

#endif				/* USE_BZLIB */

/*

HTNetToText: Convert Net ASCII to local representation

   This is a filter stream suitable for taking text from a socket and passing
   it into a stream which expects text in the local C representation.  It does
   ASCII and newline conversion.  As usual, pass its output stream to it when
   creating it.

 */
    extern HTStream *HTNetToText(HTStream *sink);

/*

HTFormatInit: Set up default presentations and conversions

   These are defined in HTInit.c or HTSInit.c if these have been replaced.  If
   you don't call this routine, and you don't define any presentations, then
   this routine will automatically be called the first time a conversion is
   needed.  However, if you explicitly add some conversions (eg using
   HTLoadRules) then you may want also to explicitly call this to get the
   defaults as well.

 */
    extern void HTFormatInit(void);

/*

Epilogue

 */
    extern BOOL HTOutputSource;	/* Flag: shortcut parser */

#ifdef __cplusplus
}
#endif
#endif				/* HTFORMAT_H */
@


1.7
log
@automatic merge
@
text
@d20 1
d22 3
a24 1
/*
d26 3
a28 1
The HTFormat type
d30 3
a32 5
   We use the HTAtom object for holding representations.  This allows faster manipulation
   (comparison and copying) that if we stayed with strings.

 */
typedef HTAtom *HTFormat;
d34 3
d47 2
a48 4
 */
			/* Internal ones */
/* #define WWW_SOURCE HTAtom_for("www/source") *//* Whatever it was originally */
extern HTAtom *WWW_SOURCE;	/* calculated once, heavy used */
d114 1
a114 9
/*

   We must include the following file after defining HTFormat, to which it
   makes reference.

The HTEncoding type

 */
typedef HTAtom *HTEncoding;
d117 1
a117 3

   The following are values for the MIME types:

d124 1
a124 3

   We also add

d129 3
a131 3
   Does a string designate a real encoding, or is it just
   a "dummy" as for example 7bit, 8bit, and binary?
  */
a139 2
#include <HTAnchor.h>

d151 1
a151 1
typedef struct _HTPresentation HTPresentation;
d153 17
a169 17
typedef HTStream *HTConverter (HTPresentation *pres,
			       HTParentAnchor *anchor,
			       HTStream *sink);

struct _HTPresentation {
    HTAtom *rep;		/* representation name atomized */
    HTAtom *rep_out;		/* resulting representation */
    HTConverter *converter;	/* routine to gen the stream stack */
    char *command;		/* MIME-format command string */
    char *testcommand;		/* MIME-format test string */
    float quality;		/* Between 0 (bad) and 1 (good) */
    float secs;
    float secs_per_byte;
    long int maxbytes;
    BOOL get_accept;		/* list in "Accept:" for GET */
    int accept_opt;		/* matches against LYAcceptMedia */
};
d177 1
a177 1
extern HTList *HTPresentations;
d184 1
a184 1
extern HTPresentation *default_presentation;
d189 15
a203 15
typedef enum {
    /* make the components powers of two so we can add them */
    mediaINT = 1		/* internal types predefined in HTInit.c */
    ,mediaEXT = 2		/* external types predefined in HTInit.c */
    ,mediaCFG = 4		/* types, e.g., viewers, from lynx.cfg */
    ,mediaUSR = 8		/* user's mime-types, etc. */
    ,mediaSYS = 16		/* system's mime-types, etc. */
    /* these are useful flavors for the options menu */
    ,mediaOpt1 = mediaINT
    ,mediaOpt2 = mediaINT + mediaCFG
    ,mediaOpt3 = mediaINT + mediaCFG + mediaUSR
    ,mediaOpt4 = mediaINT + mediaCFG + mediaUSR + mediaSYS
    /* this is the flavor from pre-2.8.6 */
    ,mediaALL = mediaINT + mediaEXT + mediaCFG + mediaUSR + mediaSYS
} AcceptMedia;
d208 11
a218 11
typedef enum {
    encodingNONE = 0
    ,encodingGZIP = 1
    ,encodingDEFLATE = 2
    ,encodingCOMPRESS = 4
    ,encodingBZIP2 = 8
    ,encodingALL = (encodingGZIP
		    + encodingDEFLATE
		    + encodingCOMPRESS
		    + encodingBZIP2)
} AcceptEncoding;
d242 9
a250 9
extern void HTSetPresentation(const char *representation,
			      const char *command,
			      const char *testcommand,
			      double quality,
			      double secs,
			      double secs_per_byte,
			      long int maxbytes,
			      AcceptMedia media
);
d266 9
a274 9
extern void HTSetConversion(const char *rep_in,
			    const char *rep_out,
			    HTConverter *converter,
			    float quality,
			    float secs,
			    float secs_per_byte,
			    long int maxbytes,
			    AcceptMedia media
);
d288 4
a291 4
extern HTStream *HTStreamStack(HTFormat format_in,
			       HTFormat format_out,
			       HTStream *stream_out,
			       HTParentAnchor *anchor);
d300 2
a301 2
extern void HTReorderPresentation(HTFormat format_in,
				  HTFormat format_out);
d307 1
a307 1
extern void HTFilterPresentations(void);
d327 4
a330 4
extern float HTStackValue(HTFormat format_in,
			  HTFormat rep_out,
			  float initial_value,
			  long int length);
d341 1
a341 1
extern void HTDisplayPartial(void);
d343 1
a343 1
extern void HTFinishDisplayPartial(void);
d353 4
a356 4
extern int HTCopy(HTParentAnchor *anchor,
		  int file_number,
		  void *handle,
		  HTStream *sink);
d367 2
a368 2
extern int HTFileCopy(FILE *fp,
		      HTStream *sink);
a370 1
#include <HTChunk.h>
d380 2
a381 2
extern int HTMemCopy(HTChunk *chunk,
		     HTStream *sink);
d392 3
a394 3
extern void HTCopyNoCR(HTParentAnchor *anchor,
		       int file_number,
		       HTStream *sink);
d406 1
a406 1
extern void HTInitInput(int file_number);
d413 2
a414 2
extern int interrupted_in_htgetcharacter;
extern int HTGetCharacter(void);
d425 5
a429 5
extern int HTParseSocket(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 int file_number,
			 HTStream *sink);
d440 5
a444 5
extern int HTParseFile(HTFormat format_in,
		       HTFormat format_out,
		       HTParentAnchor *anchor,
		       FILE *fp,
		       HTStream *sink);
d456 5
a460 5
extern int HTParseMem(HTFormat format_in,
		      HTFormat format_out,
		      HTParentAnchor *anchor,
		      HTChunk *chunk,
		      HTStream *sink);
a463 1
#include <zlib.h>
d471 5
a475 5
extern int HTParseGzFile(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 gzFile gzfp,
			 HTStream *sink);
d484 5
a488 5
extern int HTParseZzFile(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 FILE *zzfp,
			 HTStream *sink);
d490 1
a490 1
#endif /* USE_ZLIB */
a492 1
#include <bzlib.h>
d500 5
a504 5
extern int HTParseBzFile(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 BZFILE * bzfp,
			 HTStream *sink);
d506 1
a506 1
#endif /* USE_BZLIB */
d518 1
a518 1
extern HTStream *HTNetToText(HTStream *sink);
d532 1
a532 1
extern void HTFormatInit(void);
d539 1
a539 1
extern BOOL HTOutputSource;	/* Flag: shortcut parser */
d541 4
a544 1
#endif /* HTFORMAT_H */
@


1.6
log
@automatic merge of lynx-current
@
text
@d221 7
a227 3
    ,encodingCOMPRESS = 2
    ,encodingBZIP2 = 4
    ,encodingALL = encodingGZIP + encodingCOMPRESS + encodingBZIP2
d487 13
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d29 1
a29 1
typedef HTAtom * HTFormat;
d33 3
a35 2
   These macros (which used to be constants) define some basic internally referenced
   representations.  The www/xxx ones are of course not MIME standard.
d37 3
a39 2
   www/source  is an output format which leaves the input untouched. It is useful for
   diagnostics, and for users who want to see the original, whatever it is.
d42 3
a44 3
                        /* Internal ones */
/* #define WWW_SOURCE HTAtom_for("www/source") */    /* Whatever it was originally*/
extern HTAtom * WWW_SOURCE;     /* calculated once, heavy used */
d48 2
a49 2
   www/present represents the user's perception of the document.  If you convert to
   www/present, you present the material to the user.
d52 1
a52 1
#define WWW_PRESENT HTAtom_for("www/present")   /* The user's perception */
d57 2
a58 2
   WWW_DEBUG represents the user's perception of debug information, for example sent as a
   HTML document in a HTTP redirection message.
d64 2
a65 2
   The message/rfc822 format means a MIME message or a plain text message with no MIME
   header.  This is what is returned by an HTTP server.
d68 1
a68 1
#define WWW_MIME HTAtom_for("www/mime")         /* A MIME message */
d80 1
a80 1
#define WWW_PRINT HTAtom_for("www/print")       /* A printed copy */
d98 3
a100 3
   These are regular MIME types.  HTML is assumed to be added by the W3 code.
   application/octet-stream was mistakenly application/binary in earlier libwww versions
   (pre 2.11).
d112 2
a113 2
   We must include the following file after defining HTFormat, to which it makes
   reference.
d118 1
a118 1
typedef HTAtom* HTEncoding;
a147 1

d154 5
a158 5
   This HTPresentation structure represents a possible conversion algorithm from one
   format to another.  It includes a pointer to a conversion routine.  The conversion
   routine returns a stream to which data should be fed. See also HTStreamStack which
   scans the list of registered converters and calls one.  See the initialisation module
   for a list of conversion routines.
d163 3
a165 4
typedef HTStream * HTConverter (
        HTPresentation *        pres,
        HTParentAnchor *        anchor,
        HTStream *              sink);
d168 11
a178 9
        HTAtom	*	rep;            /* representation name atomized */
        HTAtom	*	rep_out;        /* resulting representation */
        HTConverter *	converter;	/* routine to gen the stream stack */
        char *		command;        /* MIME-format string */
        float		quality;        /* Between 0 (bad) and 1 (good) */
        float		secs;
        float		secs_per_byte;
	long int	maxbytes;
	BOOL		get_accept;	/* list in "Accept:" for GET */
d183 2
a184 2
   The list of presentations is kept by this module.  It is also scanned by modules which
   want to know the set of formats supported. for example.
d187 1
a187 1
extern HTList * HTPresentations;
d194 31
a224 1
extern  HTPresentation* default_presentation;
d236 2
d245 2
d248 8
a255 7
extern void HTSetPresentation (
        const char *	representation,
        const char *	command,
        double		quality,
        double		secs,
        double		secs_per_byte,
	long int	maxbytes
a257 1

d272 8
a279 8
extern void HTSetConversion (
        const char *    rep_in,
        const char *    rep_out,
        HTConverter *   converter,
        float           quality,
        float           secs,
        float           secs_per_byte,
	long int	maxbytes
a281 1

d286 6
a291 6
   This is the routine which actually sets up the conversion.  It currently checks only for
   direct conversions, but multi-stage conversions are forseen.  It takes a stream into
   which the output should be sent in the final format, builds the conversion stack, and
   returns a stream into which the data in the input format should be fed.  The anchor is
   passed because hypertxet objects load information into the anchor object which
   represents them.
d294 4
a297 5
extern HTStream * HTStreamStack (
        HTFormat                format_in,
        HTFormat                format_out,
        HTStream*               stream_out,
        HTParentAnchor*         anchor);
d302 2
a303 2
    Look up a presentation (exact match only) and, if found, reorder
    it to the start of the HTPresentations list. - kw
d306 2
a307 3
extern void HTReorderPresentation (
        HTFormat                format_in,
        HTFormat                format_out);
d313 1
a313 1
extern void HTFilterPresentations (void);
d333 4
a336 5
extern float HTStackValue (
        HTFormat                format_in,
        HTFormat                rep_out,
        float                   initial_value,
        long int                length);
d341 7
a347 7
**	-------------------------------------------
**
**   Repaint the page only when necessary.
**   This is a traverse call for HText_pageDispaly() - it works!.
**
*/
extern void HTDisplayPartial (void);
d349 1
a349 1
extern void HTFinishDisplayPartial (void);
d355 2
a356 2
   This is used by the protocol engines to send data down a stream, typically one which
   has been generated by HTStreamStack.
d359 4
a362 6
extern int HTCopy (
	HTParentAnchor *	anchor,
        int                     file_number,
	void*			handle,
        HTStream*               sink);

d368 3
a370 2
   This is used by the protocol engines to send data down a stream, typically one which
   has been generated by HTStreamStack.  It is currently called by HTParseFile
d373 2
a374 4
extern int HTFileCopy (
        FILE*                   fp,
        HTStream*               sink);

d382 3
a384 2
   This is used by the protocol engines to send data down a stream, typically one which
   has been generated by HTStreamStack.  It is currently called by HTParseMem
d387 2
a388 3
extern int HTMemCopy (
	HTChunk *		chunk,
	HTStream*		sink);
a390 1

d399 3
a401 5
extern void HTCopyNoCR (
	HTParentAnchor *	anchor,
        int                     file_number,
        HTStream*               sink);

d407 4
a410 3
   This routine and the one below provide simple character input from sockets. (They are
   left over from the older architecure and may not be used very much.)  The existence of
   a common routine and buffer saves memory space in small implementations.
d413 1
a413 1
extern void HTInitInput (int file_number);
d421 1
a421 2
extern int HTGetCharacter (void);

d427 3
a429 2
   This routine is called by protocol modules to load an object.  uses HTStreamStack and
   the copy routines above.  Returns HT_LOADED if succesful, <0 if not.
d432 5
a436 6
extern int HTParseSocket (
        HTFormat        format_in,
        HTFormat        format_out,
        HTParentAnchor  *anchor,
        int             file_number,
        HTStream*       sink);
d447 5
a451 6
extern int HTParseFile (
        HTFormat        format_in,
        HTFormat        format_out,
        HTParentAnchor  *anchor,
        FILE            *fp,
        HTStream*       sink);
d463 5
a467 6
extern int HTParseMem (
	HTFormat	format_in,
	HTFormat	format_out,
	HTParentAnchor	*anchor,
	HTChunk*	chunk,
	HTStream*	sink);
d479 5
a483 6
extern int HTParseGzFile (
        HTFormat        format_in,
        HTFormat        format_out,
        HTParentAnchor  *anchor,
        gzFile          gzfp,
        HTStream*       sink);
d496 5
a500 6
extern int HTParseBzFile (
        HTFormat        format_in,
        HTFormat        format_out,
        HTParentAnchor  *anchor,
        BZFILE          *bzfp,
        HTStream*       sink);
d508 4
a511 3
   This is a filter stream suitable for taking text from a socket and passing it into a
   stream which expects text in the local C representation.  It does ASCII and newline
   conversion.  As usual, pass its output stream to it when creating it.
d514 1
a514 1
extern HTStream *  HTNetToText (HTStream * sink);
d520 6
a525 5
   These are defined in HTInit.c or HTSInit.c if these have been replaced. If you don't
   call this routine, and you don't define any presentations, then this routine will
   automatically be called the first time a conversion is needed. However, if you
   explicitly add some conversions (eg using HTLoadRules) then you may want also to
   explicitly call this to get the defaults as well.
d528 1
a528 1
extern void HTFormatInit (void);
d535 1
a535 1
extern BOOL HTOutputSource;     /* Flag: shortcut parser */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d162 1
a162 1
typedef HTStream * HTConverter PARAMS((
d165 1
a165 1
        HTStream *              sink));
d212 3
a214 3
extern void HTSetPresentation PARAMS((
        CONST char *	representation,
        CONST char *	command,
d219 1
a219 1
));
d236 3
a238 3
extern void HTSetConversion PARAMS((
        CONST char *    rep_in,
        CONST char *    rep_out,
d244 1
a244 1
));
d259 1
a259 1
extern HTStream * HTStreamStack PARAMS((
d263 1
a263 1
        HTParentAnchor*         anchor));
d272 1
a272 1
extern void HTReorderPresentation PARAMS((
d274 1
a274 1
        HTFormat                format_out));
d280 1
a280 1
extern void HTFilterPresentations NOPARAMS;
d300 1
a300 1
extern float HTStackValue PARAMS((
d304 1
a304 1
        long int                length));
d315 1
a315 1
extern void HTDisplayPartial NOPARAMS;
d317 1
a317 1
extern void HTFinishDisplayPartial NOPARAMS;
d327 1
a327 1
extern int HTCopy PARAMS((
d331 1
a331 1
        HTStream*               sink));
d342 1
a342 1
extern int HTFileCopy PARAMS((
d344 1
a344 1
        HTStream*               sink));
d357 1
a357 1
extern int HTMemCopy PARAMS((
d359 1
a359 1
	HTStream*		sink));
d371 1
a371 1
extern void HTCopyNoCR PARAMS((
d374 1
a374 1
        HTStream*               sink));
d386 1
a386 1
extern void HTInitInput PARAMS((int file_number));
d394 1
a394 1
extern int HTGetCharacter NOPARAMS;
d405 1
a405 1
extern int HTParseSocket PARAMS((
d410 1
a410 1
        HTStream*       sink));
d421 1
a421 1
extern int HTParseFile PARAMS((
d426 1
a426 1
        HTStream*       sink));
d438 1
a438 1
extern int HTParseMem PARAMS((
d443 1
a443 1
	HTStream*	sink));
d455 1
a455 1
extern int HTParseGzFile PARAMS((
d460 1
a460 1
        HTStream*       sink));
d473 1
a473 1
extern int HTParseBzFile PARAMS((
d478 1
a478 1
        HTStream*       sink));
d491 1
a491 1
extern HTStream *  HTNetToText PARAMS ((HTStream * sink));
d504 1
a504 1
extern void HTFormatInit NOPARAMS;
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d347 1
a347 1
#ifdef SOURCE_CACHE
d428 1
a428 1
#ifdef SOURCE_CACHE
a446 2

#ifdef USE_ZLIB
a447 1
#endif /* USE_ZLIB */
d449 1
a449 1
HTParseGzFile: Parse a gzipped File through a file pointer
d463 18
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d41 2
a42 1
#define WWW_SOURCE HTAtom_for("www/source")     /* Whatever it was originally*/
d52 8
d69 5
d154 1
a154 1
   format to annother.  It includes a pointer to a conversion routine.  The conversion
d168 1
a168 1
        HTAtom	*	rep;            /* representation name atmoized */
d170 1
a170 1
        HTConverter *	converter;  /* The routine to gen the stream stack */
d176 1
d189 1
a189 1
   The default presentation is used when no other is appriporate
d215 3
a217 3
        float		quality,
        float		secs,
        float		secs_per_byte,
d277 6
d306 1
a306 1
#define NO_VALUE_FOUND  -1e20           /* returned if none found */
a496 3
#endif

/*
d498 1
a498 1
   end */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a19 13
#include <HTAnchor.h>

#ifdef USE_SOURCE_CACHE
#include <HTChunk.h>
#endif

#ifdef USE_BZLIB
#include <bzlib.h>
#endif

#ifdef USE_ZLIB
#include <zlib.h>
#endif
a20 3
#ifdef __cplusplus
extern "C" {
#endif
d23 1
a23 3
   These macros (which used to be constants) define some basic internally
   referenced representations.  The www/xxx ones are of course not MIME
   standard.
d25 2
a26 3
   www/source is an output format which leaves the input untouched.  It is
   useful for diagnostics, and for users who want to see the original, whatever
   it is.
d28 2
a29 2
																	 *//* Internal ones *//* #define WWW_SOURCE HTAtom_for("www/source") *//* Whatever it was originally */ extern HTAtom *WWW_SOURCE;
    /* calculated once, heavy used */
d33 5
a37 2
   www/present represents the user's perception of the document.  If you
   convert to www/present, you present the material to the user.
d40 2
a41 1
#define WWW_PRESENT HTAtom_for("www/present")	/* The user's perception */
a42 1
#define WWW_DEBUG       HTAtom_for("www/debug")
d45 2
a46 2
   WWW_DEBUG represents the user's perception of debug information, for example
   sent as a HTML document in a HTTP redirection message.
d49 1
d53 2
a54 2
   The message/rfc822 format means a MIME message or a plain text message with
   no MIME header.  This is what is returned by an HTTP server.
d57 1
a57 6
#define WWW_MIME HTAtom_for("www/mime")		/* A MIME message */

/*
  For parsing only the header. - kw
  */
#define WWW_MIME_HEAD   HTAtom_for("message/x-rfc822-head")
d64 1
a64 1
#define WWW_PRINT HTAtom_for("www/print")	/* A printed copy */
d82 3
a84 3
   These are regular MIME types.  HTML is assumed to be added by the W3 code. 
   application/octet-stream was mistakenly application/binary in earlier libwww
   versions (pre 2.11).
d94 9
a102 1
    typedef HTAtom *HTEncoding;
d105 3
a107 1
 * The following are values for the MIME types:
d114 3
a116 1
 * We also add
d121 3
a123 3
 * Does a string designate a real encoding, or is it just
 * a "dummy" as for example 7bit, 8bit, and binary?
 */
d132 3
d139 5
a143 5
   This HTPresentation structure represents a possible conversion algorithm
   from one format to another.  It includes a pointer to a conversion routine. 
   The conversion routine returns a stream to which data should be fed.  See
   also HTStreamStack which scans the list of registered converters and calls
   one.  See the initialisation module for a list of conversion routines.
d146 1
a146 1
    typedef struct _HTPresentation HTPresentation;
d148 4
a151 3
    typedef HTStream *HTConverter (HTPresentation *pres,
				   HTParentAnchor *anchor,
				   HTStream *sink);
d153 10
a162 13
    struct _HTPresentation {
	HTAtom *rep;		/* representation name atomized */
	HTAtom *rep_out;	/* resulting representation */
	HTConverter *converter;	/* routine to gen the stream stack */
	char *command;		/* MIME-format command string */
	char *testcommand;	/* MIME-format test string */
	float quality;		/* Between 0 (bad) and 1 (good) */
	float secs;
	float secs_per_byte;
	long int maxbytes;
	BOOL get_accept;	/* list in "Accept:" for GET */
	int accept_opt;		/* matches against LYAcceptMedia */
    };
d166 2
a167 2
   The list of presentations is kept by this module.  It is also scanned by
   modules which want to know the set of formats supported.  for example.
d170 1
a170 1
    extern HTList *HTPresentations;
d174 1
a174 23
   The default presentation is used when no other is appropriate

 */
    extern HTPresentation *default_presentation;

/*
 * Options used for "Accept:" string
 */
    typedef enum {
	/* make the components powers of two so we can add them */
	mediaINT = 1		/* internal types predefined in HTInit.c */
	,mediaEXT = 2		/* external types predefined in HTInit.c */
	,mediaCFG = 4		/* types, e.g., viewers, from lynx.cfg */
	,mediaUSR = 8		/* user's mime-types, etc. */
	,mediaSYS = 16		/* system's mime-types, etc. */
	/* these are useful flavors for the options menu */
	,mediaOpt1 = mediaINT
	,mediaOpt2 = mediaINT + mediaCFG
	,mediaOpt3 = mediaINT + mediaCFG + mediaUSR
	,mediaOpt4 = mediaINT + mediaCFG + mediaUSR + mediaSYS
	/* this is the flavor from pre-2.8.6 */
	,mediaALL = mediaINT + mediaEXT + mediaCFG + mediaUSR + mediaSYS
    } AcceptMedia;
a175 2
/*
 * Options used for "Accept-Encoding:" string
d177 1
a177 11
    typedef enum {
	encodingNONE = 0
	,encodingGZIP = 1
	,encodingDEFLATE = 2
	,encodingCOMPRESS = 4
	,encodingBZIP2 = 8
	,encodingALL = (encodingGZIP
			+ encodingDEFLATE
			+ encodingCOMPRESS
			+ encodingBZIP2)
    } AcceptEncoding;
a188 2
  testcommand             is the MAILCAP - style testcommand template

d196 9
a204 1
  media                   Used in filtering presentation types for "Accept:"
a205 10
 */
    extern void HTSetPresentation(const char *representation,
				  const char *command,
				  const char *testcommand,
				  double quality,
				  double secs,
				  double secs_per_byte,
				  long int maxbytes,
				  AcceptMedia media
    );
d221 10
a230 9
    extern void HTSetConversion(const char *rep_in,
				const char *rep_out,
				HTConverter *converter,
				float quality,
				float secs,
				float secs_per_byte,
				long int maxbytes,
				AcceptMedia media
    );
d236 6
a241 6
   This is the routine which actually sets up the conversion.  It currently
   checks only for direct conversions, but multi-stage conversions are forseen. 
   It takes a stream into which the output should be sent in the final format,
   builds the conversion stack, and returns a stream into which the data in the
   input format should be fed.  The anchor is passed because hypertxet objects
   load information into the anchor object which represents them.
d244 5
a248 4
    extern HTStream *HTStreamStack(HTFormat format_in,
				   HTFormat format_out,
				   HTStream *stream_out,
				   HTParentAnchor *anchor);
d253 2
a254 2
    Look up a presentation (exact match only) and, if found, reorder it to the
    start of the HTPresentations list.  - kw
d257 3
a259 8
    extern void HTReorderPresentation(HTFormat format_in,
				      HTFormat format_out);

/*
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
    extern void HTFilterPresentations(void);
d279 5
a283 4
    extern float HTStackValue(HTFormat format_in,
			      HTFormat rep_out,
			      float initial_value,
			      long int length);
d285 1
a285 1
#define NO_VALUE_FOUND  -1e20	/* returned if none found */
d288 7
a294 7
 *	-------------------------------------------
 *
 *   Repaint the page only when necessary.
 *   This is a traverse call for HText_pageDispaly() - it works!.
 *
 */
    extern void HTDisplayPartial(void);
d296 1
a296 1
    extern void HTFinishDisplayPartial(void);
d302 2
a303 2
   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.
d306 6
a311 4
    extern int HTCopy(HTParentAnchor *anchor,
		      int file_number,
		      void *handle,
		      HTStream *sink);
d317 2
a318 3
   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.  It is currently called by
   HTParseFile
d321 4
a324 2
    extern int HTFileCopy(FILE *fp,
			  HTStream *sink);
d326 2
a327 1
#ifdef USE_SOURCE_CACHE
d332 2
a333 3
   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.  It is currently called by
   HTParseMem
d336 3
a338 2
    extern int HTMemCopy(HTChunk *chunk,
			 HTStream *sink);
d341 1
d350 5
a354 3
    extern void HTCopyNoCR(HTParentAnchor *anchor,
			   int file_number,
			   HTStream *sink);
d360 3
a362 4
   This routine and the one below provide simple character input from sockets. 
   (They are left over from the older architecture and may not be used very
   much.) The existence of a common routine and buffer saves memory space in
   small implementations.
d365 1
a365 1
    extern void HTInitInput(int file_number);
d372 3
a374 2
    extern int interrupted_in_htgetcharacter;
    extern int HTGetCharacter(void);
d380 2
a381 3
   This routine is called by protocol modules to load an object.  uses
   HTStreamStack and the copy routines above.  Returns HT_LOADED if successful,
   <0 if not.
d384 6
a389 5
    extern int HTParseSocket(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     int file_number,
			     HTStream *sink);
d400 6
a405 5
    extern int HTParseFile(HTFormat format_in,
			   HTFormat format_out,
			   HTParentAnchor *anchor,
			   FILE *fp,
			   HTStream *sink);
d407 1
a407 1
#ifdef USE_SOURCE_CACHE
d417 6
a422 5
    extern int HTParseMem(HTFormat format_in,
			  HTFormat format_out,
			  HTParentAnchor *anchor,
			  HTChunk *chunk,
			  HTStream *sink);
a425 12
/*
HTParseGzFile: Parse a gzip'ed File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTGzFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.
 */
    extern int HTParseGzFile(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     gzFile gzfp,
			     HTStream *sink);
d427 3
d431 1
a431 17
HTParseZzFile: Parse a deflate'd File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTZzFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.
 */
    extern int HTParseZzFile(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     FILE *zzfp,
			     HTStream *sink);

#endif				/* USE_ZLIB */

#ifdef USE_BZLIB
/*
HTParseBzFile: Parse a bzip2'ed File through a file pointer
d437 6
a442 5
    extern int HTParseBzFile(HTFormat format_in,
			     HTFormat format_out,
			     HTParentAnchor *anchor,
			     BZFILE * bzfp,
			     HTStream *sink);
d444 1
a444 1
#endif				/* USE_BZLIB */
d450 3
a452 4
   This is a filter stream suitable for taking text from a socket and passing
   it into a stream which expects text in the local C representation.  It does
   ASCII and newline conversion.  As usual, pass its output stream to it when
   creating it.
d455 1
a455 1
    extern HTStream *HTNetToText(HTStream *sink);
d461 5
a465 6
   These are defined in HTInit.c or HTSInit.c if these have been replaced.  If
   you don't call this routine, and you don't define any presentations, then
   this routine will automatically be called the first time a conversion is
   needed.  However, if you explicitly add some conversions (eg using
   HTLoadRules) then you may want also to explicitly call this to get the
   defaults as well.
d468 1
a468 1
    extern void HTFormatInit(void);
d475 4
a478 1
    extern BOOL HTOutputSource;	/* Flag: shortcut parser */
d480 1
a480 4
#ifdef __cplusplus
}
#endif
#endif				/* HTFORMAT_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d41 1
a41 2
/* #define WWW_SOURCE HTAtom_for("www/source") */    /* Whatever it was originally*/
extern HTAtom * WWW_SOURCE;     /* calculated once, heavy used */
a50 8
#define WWW_DEBUG       HTAtom_for("www/debug")
/*

   WWW_DEBUG represents the user's perception of debug information, for example sent as a
   HTML document in a HTTP redirection message.

 */

a59 5
  For parsing only the header. - kw
  */
#define WWW_MIME_HEAD   HTAtom_for("message/x-rfc822-head")

/*
d140 1
a140 1
   format to another.  It includes a pointer to a conversion routine.  The conversion
d154 1
a154 1
        HTAtom	*	rep;            /* representation name atomized */
d156 1
a156 1
        HTConverter *	converter;	/* routine to gen the stream stack */
a161 1
	BOOL		get_accept;	/* list in "Accept:" for GET */
d174 1
a174 1
   The default presentation is used when no other is appropriate
d200 3
a202 3
        double		quality,
        double		secs,
        double		secs_per_byte,
a261 6
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
extern void HTFilterPresentations NOPARAMS;

/*
d285 1
a285 1
#define NO_VALUE_FOUND  -1e20	/* returned if none found */
d476 3
d480 1
a480 1
#endif /* HTFORMAT_H */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d347 1
a347 1
#ifdef USE_SOURCE_CACHE
d428 1
a428 1
#ifdef USE_SOURCE_CACHE
d447 2
d450 1
d452 1
a452 1
HTParseGzFile: Parse a gzip'ed File through a file pointer
a465 18

#ifdef USE_BZLIB
#include <bzlib.h>
/*
HTParseBzFile: Parse a bzip2'ed File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTGzFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.
 */
extern int HTParseBzFile PARAMS((
        HTFormat        format_in,
        HTFormat        format_out,
        HTParentAnchor  *anchor,
        BZFILE          *bzfp,
        HTStream*       sink));

#endif /* USE_BZLIB */
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d162 1
a162 1
typedef HTStream * HTConverter (
d165 1
a165 1
        HTStream *              sink);
d212 3
a214 3
extern void HTSetPresentation (
        const char *	representation,
        const char *	command,
d219 1
a219 1
);
d236 3
a238 3
extern void HTSetConversion (
        const char *    rep_in,
        const char *    rep_out,
d244 1
a244 1
);
d259 1
a259 1
extern HTStream * HTStreamStack (
d263 1
a263 1
        HTParentAnchor*         anchor);
d272 1
a272 1
extern void HTReorderPresentation (
d274 1
a274 1
        HTFormat                format_out);
d280 1
a280 1
extern void HTFilterPresentations (void);
d300 1
a300 1
extern float HTStackValue (
d304 1
a304 1
        long int                length);
d315 1
a315 1
extern void HTDisplayPartial (void);
d317 1
a317 1
extern void HTFinishDisplayPartial (void);
d327 1
a327 1
extern int HTCopy (
d331 1
a331 1
        HTStream*               sink);
d342 1
a342 1
extern int HTFileCopy (
d344 1
a344 1
        HTStream*               sink);
d357 1
a357 1
extern int HTMemCopy (
d359 1
a359 1
	HTStream*		sink);
d371 1
a371 1
extern void HTCopyNoCR (
d374 1
a374 1
        HTStream*               sink);
d386 1
a386 1
extern void HTInitInput (int file_number);
d394 1
a394 1
extern int HTGetCharacter (void);
d405 1
a405 1
extern int HTParseSocket (
d410 1
a410 1
        HTStream*       sink);
d421 1
a421 1
extern int HTParseFile (
d426 1
a426 1
        HTStream*       sink);
d438 1
a438 1
extern int HTParseMem (
d443 1
a443 1
	HTStream*	sink);
d455 1
a455 1
extern int HTParseGzFile (
d460 1
a460 1
        HTStream*       sink);
d473 1
a473 1
extern int HTParseBzFile (
d478 1
a478 1
        HTStream*       sink);
d491 1
a491 1
extern HTStream *  HTNetToText (HTStream * sink);
d504 1
a504 1
extern void HTFormatInit (void);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d29 1
a29 1
typedef HTAtom *HTFormat;
d33 2
a34 3
   These macros (which used to be constants) define some basic internally
   referenced representations.  The www/xxx ones are of course not MIME
   standard.
d36 2
a37 3
   www/source is an output format which leaves the input untouched.  It is
   useful for diagnostics, and for users who want to see the original, whatever
   it is.
d40 3
a42 3
			/* Internal ones */
/* #define WWW_SOURCE HTAtom_for("www/source") *//* Whatever it was originally */
extern HTAtom *WWW_SOURCE;	/* calculated once, heavy used */
d46 2
a47 2
   www/present represents the user's perception of the document.  If you
   convert to www/present, you present the material to the user.
d50 1
a50 1
#define WWW_PRESENT HTAtom_for("www/present")	/* The user's perception */
d55 2
a56 2
   WWW_DEBUG represents the user's perception of debug information, for example
   sent as a HTML document in a HTTP redirection message.
d62 2
a63 2
   The message/rfc822 format means a MIME message or a plain text message with
   no MIME header.  This is what is returned by an HTTP server.
d66 1
a66 1
#define WWW_MIME HTAtom_for("www/mime")		/* A MIME message */
d78 1
a78 1
#define WWW_PRINT HTAtom_for("www/print")	/* A printed copy */
d96 3
a98 3
   These are regular MIME types.  HTML is assumed to be added by the W3 code. 
   application/octet-stream was mistakenly application/binary in earlier libwww
   versions (pre 2.11).
d110 2
a111 2
   We must include the following file after defining HTFormat, to which it
   makes reference.
d116 1
a116 1
typedef HTAtom *HTEncoding;
d146 1
d153 5
a157 5
   This HTPresentation structure represents a possible conversion algorithm
   from one format to another.  It includes a pointer to a conversion routine. 
   The conversion routine returns a stream to which data should be fed.  See
   also HTStreamStack which scans the list of registered converters and calls
   one.  See the initialisation module for a list of conversion routines.
d162 4
a165 3
typedef HTStream *HTConverter (HTPresentation *pres,
			       HTParentAnchor *anchor,
			       HTStream *sink);
d168 9
a176 11
    HTAtom *rep;		/* representation name atomized */
    HTAtom *rep_out;		/* resulting representation */
    HTConverter *converter;	/* routine to gen the stream stack */
    char *command;		/* MIME-format command string */
    char *testcommand;		/* MIME-format test string */
    float quality;		/* Between 0 (bad) and 1 (good) */
    float secs;
    float secs_per_byte;
    long int maxbytes;
    BOOL get_accept;		/* list in "Accept:" for GET */
    int accept_opt;		/* matches against LYAcceptMedia */
d181 2
a182 2
   The list of presentations is kept by this module.  It is also scanned by
   modules which want to know the set of formats supported.  for example.
d185 1
a185 1
extern HTList *HTPresentations;
d192 1
a192 31
extern HTPresentation *default_presentation;

/*
 * Options used for "Accept:" string
 */
typedef enum {
    /* make the components powers of two so we can add them */
    mediaINT = 1		/* internal types predefined in HTInit.c */
    ,mediaEXT = 2		/* external types predefined in HTInit.c */
    ,mediaCFG = 4		/* types, e.g., viewers, from lynx.cfg */
    ,mediaUSR = 8		/* user's mime-types, etc. */
    ,mediaSYS = 16		/* system's mime-types, etc. */
    /* these are useful flavors for the options menu */
    ,mediaOpt1 = mediaINT
    ,mediaOpt2 = mediaINT + mediaCFG
    ,mediaOpt3 = mediaINT + mediaCFG + mediaUSR
    ,mediaOpt4 = mediaINT + mediaCFG + mediaUSR + mediaSYS
    /* this is the flavor from pre-2.8.6 */
    ,mediaALL = mediaINT + mediaEXT + mediaCFG + mediaUSR + mediaSYS
} AcceptMedia;

/*
 * Options used for "Accept-Encoding:" string
 */
typedef enum {
    encodingNONE = 0
    ,encodingGZIP = 1
    ,encodingCOMPRESS = 2
    ,encodingBZIP2 = 4
    ,encodingALL = encodingGZIP + encodingCOMPRESS + encodingBZIP2
} AcceptEncoding;
a203 2
  testcommand             is the MAILCAP - style testcommand template

a210 2
  media                   Used in filtering presentation types for "Accept:"

d212 7
a218 8
extern void HTSetPresentation(const char *representation,
			      const char *command,
			      const char *testcommand,
			      double quality,
			      double secs,
			      double secs_per_byte,
			      long int maxbytes,
			      AcceptMedia media
d221 1
d236 8
a243 8
extern void HTSetConversion(const char *rep_in,
			    const char *rep_out,
			    HTConverter *converter,
			    float quality,
			    float secs,
			    float secs_per_byte,
			    long int maxbytes,
			    AcceptMedia media
d246 1
d251 6
a256 6
   This is the routine which actually sets up the conversion.  It currently
   checks only for direct conversions, but multi-stage conversions are forseen. 
   It takes a stream into which the output should be sent in the final format,
   builds the conversion stack, and returns a stream into which the data in the
   input format should be fed.  The anchor is passed because hypertxet objects
   load information into the anchor object which represents them.
d259 5
a263 4
extern HTStream *HTStreamStack(HTFormat format_in,
			       HTFormat format_out,
			       HTStream *stream_out,
			       HTParentAnchor *anchor);
d268 2
a269 2
    Look up a presentation (exact match only) and, if found, reorder it to the
    start of the HTPresentations list.  - kw
d272 3
a274 2
extern void HTReorderPresentation(HTFormat format_in,
				  HTFormat format_out);
d280 1
a280 1
extern void HTFilterPresentations(void);
d300 5
a304 4
extern float HTStackValue(HTFormat format_in,
			  HTFormat rep_out,
			  float initial_value,
			  long int length);
d309 7
a315 7
 *	-------------------------------------------
 *
 *   Repaint the page only when necessary.
 *   This is a traverse call for HText_pageDispaly() - it works!.
 *
 */
extern void HTDisplayPartial(void);
d317 1
a317 1
extern void HTFinishDisplayPartial(void);
d323 2
a324 2
   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.
d327 6
a332 4
extern int HTCopy(HTParentAnchor *anchor,
		  int file_number,
		  void *handle,
		  HTStream *sink);
d338 2
a339 3
   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.  It is currently called by
   HTParseFile
d342 4
a345 2
extern int HTFileCopy(FILE *fp,
		      HTStream *sink);
d353 2
a354 3
   This is used by the protocol engines to send data down a stream, typically
   one which has been generated by HTStreamStack.  It is currently called by
   HTParseMem
d357 3
a359 2
extern int HTMemCopy(HTChunk *chunk,
		     HTStream *sink);
d362 1
d371 5
a375 3
extern void HTCopyNoCR(HTParentAnchor *anchor,
		       int file_number,
		       HTStream *sink);
d381 3
a383 4
   This routine and the one below provide simple character input from sockets. 
   (They are left over from the older architecture and may not be used very
   much.) The existence of a common routine and buffer saves memory space in
   small implementations.
d386 1
a386 1
extern void HTInitInput(int file_number);
d394 2
a395 1
extern int HTGetCharacter(void);
d401 2
a402 3
   This routine is called by protocol modules to load an object.  uses
   HTStreamStack and the copy routines above.  Returns HT_LOADED if successful,
   <0 if not.
d405 6
a410 5
extern int HTParseSocket(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 int file_number,
			 HTStream *sink);
d421 6
a426 5
extern int HTParseFile(HTFormat format_in,
		       HTFormat format_out,
		       HTParentAnchor *anchor,
		       FILE *fp,
		       HTStream *sink);
d438 6
a443 5
extern int HTParseMem(HTFormat format_in,
		      HTFormat format_out,
		      HTParentAnchor *anchor,
		      HTChunk *chunk,
		      HTStream *sink);
d455 6
a460 5
extern int HTParseGzFile(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 gzFile gzfp,
			 HTStream *sink);
d473 6
a478 5
extern int HTParseBzFile(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 BZFILE * bzfp,
			 HTStream *sink);
d486 3
a488 4
   This is a filter stream suitable for taking text from a socket and passing
   it into a stream which expects text in the local C representation.  It does
   ASCII and newline conversion.  As usual, pass its output stream to it when
   creating it.
d491 1
a491 1
extern HTStream *HTNetToText(HTStream *sink);
d497 5
a501 6
   These are defined in HTInit.c or HTSInit.c if these have been replaced.  If
   you don't call this routine, and you don't define any presentations, then
   this routine will automatically be called the first time a conversion is
   needed.  However, if you explicitly add some conversions (eg using
   HTLoadRules) then you may want also to explicitly call this to get the
   defaults as well.
d504 1
a504 1
extern void HTFormatInit(void);
d511 1
a511 1
extern BOOL HTOutputSource;	/* Flag: shortcut parser */
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d221 3
a223 7
    ,encodingDEFLATE = 2
    ,encodingCOMPRESS = 4
    ,encodingBZIP2 = 8
    ,encodingALL = (encodingGZIP
		    + encodingDEFLATE
		    + encodingCOMPRESS
		    + encodingBZIP2)
a482 13
			 HTStream *sink);

/*
HTParseZzFile: Parse a deflate'd File through a file pointer

   This routine is called by protocols modules to load an object.  uses
   HTStreamStack and HTZzFileCopy.  Returns HT_LOADED if successful, can also
   return HT_PARTIAL_CONTENT, HT_NO_DATA, or other <0 for failure.
 */
extern int HTParseZzFile(HTFormat format_in,
			 HTFormat format_out,
			 HTParentAnchor *anchor,
			 FILE *zzfp,
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a50 8
#define WWW_DEBUG       HTAtom_for("www/debug")
/*

   WWW_DEBUG represents the user's perception of debug information, for example sent as a
   HTML document in a HTTP redirection message.

 */

a59 5
  For parsing only the header. - kw
  */
#define WWW_MIME_HEAD   HTAtom_for("message/x-rfc822-head")

/*
d140 1
a140 1
   format to another.  It includes a pointer to a conversion routine.  The conversion
d154 1
a154 1
        HTAtom	*	rep;            /* representation name atomized */
d156 1
a156 1
        HTConverter *	converter;	/* routine to gen the stream stack */
a161 1
	BOOL		get_accept;	/* list in "Accept:" for GET */
d174 1
a174 1
   The default presentation is used when no other is appropriate
d200 3
a202 3
        double		quality,
        double		secs,
        double		secs_per_byte,
a261 6
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
extern void HTFilterPresentations NOPARAMS;

/*
d285 1
a285 1
#define NO_VALUE_FOUND  -1e20	/* returned if none found */
@

