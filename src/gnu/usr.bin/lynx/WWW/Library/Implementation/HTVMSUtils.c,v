head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.50;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.39;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.28;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.03;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.01;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.01;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.53;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.17;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.47.47;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@
/* MODULE							HTVMSUtil.c
 *		VMS Utility Routines
 *
 * AUTHORS:
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	14 Nov 93  MD	Written
 *
 * BUGS:
 *
 *
 */

#include <HTUtils.h>
#ifdef VMS
#include <HTFormat.h>
#include <HTStream.h>
#include <UCDefs.h>
#include <UCMap.h>
#include <UCAux.h>
#include <HTFTP.h>
#include <HTTCP.h>
#include <HTVMSUtils.h>
#include <ssdef.h>
#include <jpidef.h>
#include <prvdef.h>
#include <acldef.h>
#include <chpdef.h>
#include <descrip.h>
#include <lib$routines.h>
#include <starlet.h>
#include <rmsdef.h>

#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYLeaks.h>
#include <LYStrings.h>

BOOL HTVMSFileVersions = FALSE;	/* Include version numbers in listing? */

typedef struct {
    unsigned long BufferLength:16;
    unsigned long ItemCode:16;
    unsigned long BufferAddress:32;
    unsigned long ReturnLengthAddress:32;
} ItemStruct;

/* PUBLIC							HTVMS_authSysPrv()
 *		CHECKS IF THIS PROCESS IS AUTHORIZED TO ENABLE SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	YES if SYSPRV is authorized
 */
BOOL HTVMS_authSysPrv(void)
{
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer[2];

    /* fill Item */
    ItemList[0].BufferLength = sizeof(Buffer);
    ItemList[0].BufferAddress = (unsigned long) Buffer;
    ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
    ItemList[0].ItemCode = JPI$_AUTHPRIV;

    /* terminate list */
    ItemList[1].ItemCode = 0;
    ItemList[1].BufferLength = 0;

    /* call system */
    Result = sys$getjpiw(0, 0, 0, ItemList, 0, 0, 0);

    if (Result != SS$_NORMAL)
	return (NO);

    if (Buffer[0] & PRV$M_SYSPRV)
	return (YES);

    return (NO);
}

/* PUBLIC							HTVMS_enableSysPrv()
 *		ENABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_enableSysPrv(void)
{
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];

    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(1, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (!(PreviousPrv[0] & PRV$M_SYSPRV)) {
	    CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
	}
    }
}

/* PUBLIC							HTVMS_disableSysPrv()
 *		DISABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_disableSysPrv(void)
{
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];

    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(0, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (PreviousPrv[0] & PRV$M_SYSPRV) {
	    CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
	}
    }
}

/* PUBLIC							HTVMS_checkAccess()
 *		CHECKS ACCESS TO FILE FOR CERTAIN USER
 * ON ENTRY:
 *	FileName	The file to be accessed
 *	UserName	Name of the user to check access for.
 *			User nobody, represented by "" is given NO for an answer
 *	Method		Name of the method to be chceked
 *
 * ON EXIT:
 *	returns YES if access is allowed
 *
 */
BOOL HTVMS_checkAccess(const char *FileName,
		       const char *UserName,
		       const char *Method)
{
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer;
    unsigned long ObjType;

    char *VmsName;

    struct dsc$descriptor_s FileNameDesc;
    struct dsc$descriptor_s UserNameDesc;

    char *colon;

    /* user nobody should access as from account under which server is running */
    if (0 == strcmp(UserName, ""))
	return (NO);

    /* check Filename and convert */
    colon = strchr(FileName, ':');
    if (colon)
	VmsName = HTVMS_name("", colon + 1);
    else
	VmsName = HTVMS_name("", FileName);

    /* check for GET */
    if (0 == strcmp(Method, "GET")) {
	/* fill Item */
	ItemList[0].BufferLength = sizeof(Buffer);
	ItemList[0].BufferAddress = (unsigned long) &Buffer;
	ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
	ItemList[0].ItemCode = CHP$_FLAGS;

	/* terminate list */
	ItemList[1].ItemCode = 0;
	ItemList[1].BufferLength = 0;

	/* fill input */
	ObjType = ACL$C_FILE;
	Buffer = CHP$M_READ;
	UserNameDesc.dsc$w_length = strlen(UserName);
	UserNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	UserNameDesc.dsc$b_class = DSC$K_CLASS_S;
	UserNameDesc.dsc$a_pointer = (char *) UserName;
	FileNameDesc.dsc$w_length = strlen(VmsName);
	FileNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	FileNameDesc.dsc$b_class = DSC$K_CLASS_S;
	FileNameDesc.dsc$a_pointer = VmsName;

	/* call system */
	Result = sys$check_access(&ObjType, &FileNameDesc, &UserNameDesc, ItemList);

	if (Result == SS$_NORMAL)
	    return (YES);
	else
	    return (NO);
    }

    return (NO);
}

/* PUBLIC							HTVMS_wwwName()
 *		CONVERTS VMS Name into WWW Name
 * ON ENTRY:
 *	vmsname		VMS file specification (NO NODE)
 *
 * ON EXIT:
 *	returns		www file specification
 *
 * EXAMPLES:
 *	vmsname				wwwname
 *	DISK$USER			disk$user
 *	DISK$USER:			/disk$user/
 *	DISK$USER:[DUNS]		/disk$user/duns
 *	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
 *	[DUNS]				duns
 *	[DUNS.ECHO]			duns/echo
 *	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
 *	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
 *	[.DUNS]				duns
 *	[.DUNS.ECHO]			duns/echo
 *	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
 *	TEST.COM			test.com
 *
 *
 */
const char *HTVMS_wwwName(const char *vmsname)
{
    static char wwwname[LY_MAXPATH];
    const char *src;
    char *dst;
    int dir;

    dst = wwwname;
    src = vmsname;
    dir = 0;
    if (strchr(src, ':'))
	*(dst++) = '/';
    for (; *src != '\0'; src++) {
	switch (*src) {
	case ':':
	    *(dst++) = '/';
	    break;
	case '-':
	    if (dir) {
		if ((*(src - 1) == '[' ||
		     *(src - 1) == '.' ||
		     *(src - 1) == '-') &&
		    (*(src + 1) == '.' ||
		     *(src + 1) == '-')) {
		    *(dst++) = '/';
		    *(dst++) = '.';
		    *(dst++) = '.';
		} else
		    *(dst++) = '-';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '-';
	    }
	    break;
	case '.':
	    if (dir) {
		if (*(src - 1) != '[')
		    *(dst++) = '/';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '.';
	    }
	    break;
	case '[':
	    dir = 1;
	    break;
	case ']':
	    dir = 0;
	    break;
	default:
	    if (*(src - 1) == ']')
		*(dst++) = '/';
	    *(dst++) = *src;
	    break;
	}
    }
    *(dst++) = '\0';
    return (wwwname);
}

/*
 *	The code below is for directory browsing by VMS Curses clients.
 *	It is based on the newer WWWLib's HTDirBrw.c. - Foteos Macrides
 */
int HTStat(const char *filename,
	   struct stat *info)
{
    /*
       the following stuff does not work in VMS with a normal stat...
       -->   /disk$user/duns/www if www is a directory
       is statted like:  /disk$user/duns/www.dir
       after a normal stat has failed
       -->   /disk$user/duns     if duns is a toplevel directory
       is statted like:  /disk$user/000000/duns.dir
       -->   /disk$user since disk$user is a device
       is statted like:  /disk$user/000000/000000.dir
       -->   /
       searches all devices, no solution yet...
       -->   /vxcern!/disk$cr/wwwteam/login.com
       is not statted but granted with fake information...
     */
    int Result;
    int Len;
    char *Ptr, *Ptr2;
    static char *Name;

    /* try normal stat... */
    Result = stat((char *) filename, info);
    if (Result == 0)
	return (Result);

    /* make local copy */
    StrAllocCopy(Name, filename);

    /* failed,so do device search in case root is requested */
    if (!strcmp(Name, "/")) {	/* root requested */
	return (-1);
    }

    /* failed so this might be a directory, add '.dir' */
    Len = strlen(Name);
    if (Name[Len - 1] == '/')
	Name[Len - 1] = '\0';

    /* fail in case of device */
    Ptr = strchr(Name + 1, '/');
    if ((Ptr == NULL) && (Name[0] == '/')) {	/* device only... */
	StrAllocCat(Name, "/000000/000000");
    }

    if (Ptr != NULL) {		/* correct filename in case of toplevel dir */
	Ptr2 = strchr(Ptr + 1, '/');
	if ((Ptr2 == NULL) && (Name[0] == '/')) {
	    char End[256];

	    LYstrncpy(End, Ptr, sizeof(End) - 1);
	    *(Ptr + 1) = '\0';
	    StrAllocCat(Name, "000000");
	    StrAllocCat(Name, End);
	}
    }

    /* try in case a file on toplevel directory or .DIR was already specified */
    Result = stat(Name, info);
    if (Result == 0)
	return (Result);

    /* add .DIR and try again */
    StrAllocCat(Name, ".dir");
    Result = stat(Name, info);
    return (Result);
}

#ifndef	_POSIX_SOURCE
#define	d_ino	d_fileno	/* compatability */
#ifndef	NULL
#define	NULL	0
#endif
#endif /* !_POSIX_SOURCE */

typedef struct __dirdesc {
    long context;		/* context descriptor for LIB$FIND_FILE calls */
    char dirname[255 + 1];	/* keeps the directory name, including *.* */
    struct dsc$descriptor_s dirname_desc;	/* descriptor of dirname */
} DIR;

static DIR *HTVMSopendir(char *dirname);
static struct dirent *HTVMSreaddir(DIR *dirp);
static int HTVMSclosedir(DIR *dirp);

/*** #include <sys_dirent.h> ***/
/*** "sys_dirent.h" ***/
struct dirent {
    unsigned long d_fileno;	/* file number of entry */
    unsigned short d_namlen;	/* length of string in d_name */
    char d_name[255 + 1];	/* name (up to MAXNAMLEN + 1) */
};

#ifndef	_POSIX_SOURCE
/*
 * It's unlikely to change, but make sure that sizeof d_name above is
 * at least MAXNAMLEN + 1 (more may be added for padding).
 */
#define	MAXNAMLEN	255
/*
 * The macro DIRSIZ(dp) gives the minimum amount of space required to represent
 * a directory entry.  For any directory entry dp->d_reclen >= DIRSIZ(dp).
 * Specific filesystem types may use this macro to construct the value
 * for d_reclen.
 */
#undef	DIRSIZ
#define	DIRSIZ(dp) \
	(((sizeof(struct dirent) - (MAXNAMLEN+1) + ((dp)->d_namlen+1)) +3) & ~3)

#endif /* !_POSIX_SOURCE */

static DIR *HTVMSopendir(char *dirname)
{
    static DIR dir;
    char *closebracket;
    long status;
    struct dsc$descriptor_s entryname_desc;
    struct dsc$descriptor_s dirname_desc;
    static char *DirEntry;
    char Actual[256];
    char VMSentry[256];
    char UnixEntry[256];
    int index;
    char *dot;

    /* check if directory exists */
    /* dirname can look like /disk$user/duns/www/test/multi    */
    /* or like               /disk$user/duns/www/test/multi/   */
    /* DirEntry should look like     disk$user:[duns.www.test]multi in both cases */
    /* dir.dirname should look like  disk$user:[duns.www.test.multi] */
    sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
    if (UnixEntry[strlen(UnixEntry) - 1] != '/')
	strcat(UnixEntry, "/");

    StrAllocCopy(DirEntry, HTVMS_name("", UnixEntry));
    if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
	return (NULL);
    strcpy(dir.dirname, DirEntry);
    index = strlen(DirEntry) - 1;

    if (DirEntry[index] == ']')
	DirEntry[index] = '\0';

    if ((dot = strrchr(DirEntry, '.')) == NULL) {	/* convert disk$user:[duns] into disk$user:[000000]duns.dir */
	char *openbr = strrchr(DirEntry, '[');

	if (!openbr) {		/* convert disk$user: into disk$user:[000000]000000.dir */
	    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
		return (NULL);
	    sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	    StrAllocCat(DirEntry, "[000000]000000.dir");
	} else {
	    char End[256];

	    strcpy(End, openbr + 1);
	    *(openbr + 1) = '\0';
	    StrAllocCat(DirEntry, "000000]");
	    StrAllocCat(DirEntry, End);
	    StrAllocCat(DirEntry, ".dir");
	}
    } else {
	*dot = ']';
	StrAllocCat(DirEntry, ".dir");
    }
    /* lib$find_file needs a fixed-size buffer */
    LYstrncpy(Actual, DirEntry, sizeof(Actual) - 1);

    dir.context = 0;
    dirname_desc.dsc$w_length = strlen(Actual);
    dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dirname_desc.dsc$a_pointer = (char *) &(Actual);

    /* look for the directory */
    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirname_desc),
			   &entryname_desc,
			   &(dir.context),
			   0, 0, 0, 0);
    if (!(status & 0x01)) {	/* directory not found */
	return (NULL);
    }

    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
	return (NULL);
    if (HTVMSFileVersions)
	strcat(dir.dirname, "*.*;*");
    else
	strcat(dir.dirname, "*.*");
    dir.context = 0;
    dir.dirname_desc.dsc$w_length = strlen(dir.dirname);
    dir.dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dir.dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dir.dirname_desc.dsc$a_pointer = (char *) &(dir.dirname);
    return (&dir);
}

static struct dirent *HTVMSreaddir(DIR *dirp)
{
    static struct dirent entry;
    long status;
    struct dsc$descriptor_s entryname_desc;
    char *space, *slash;
    char VMSentry[256];
    const char *UnixEntry;

    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirp->dirname_desc),
			   &entryname_desc,
			   &(dirp->context),
			   0, 0, 0, 0);
    if (status == RMS$_NMF) {	/* no more files */
	return (NULL);
    } else {			/* ok */
	if (!(status & 0x01))
	    return (0);
	if (HTVMSFileVersions)
	    space = strchr(VMSentry, ' ');
	else
	    space = strchr(VMSentry, ';');
	if (space)
	    *space = '\0';

	/* convert to unix style... */
	UnixEntry = HTVMS_wwwName(VMSentry);
	slash = strrchr(UnixEntry, '/') + 1;
	strcpy(entry.d_name, slash);
	entry.d_namlen = strlen(entry.d_name);
	entry.d_fileno = 1;
	return (&entry);
    }
}

static int HTVMSclosedir(DIR *dirp)
{
    long status;

    status = lib$find_file_end(&(dirp->context));
    if (!(status & 0x01))
	exit_immediately(status);
    dirp->context = 0;
    return (0);
}

#include <HTAnchor.h>
#include <HTParse.h>
#include <HTBTree.h>
#include <HTFile.h>		/* For HTFileFormat() */
#include <HTAlert.h>
/*
 *  Hypertext object building machinery.
 */
#include <HTML.h>
#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)
#define ABORT_TARGET (*targetClass._free)(target)
struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

#define STRUCT_DIRENT struct dirent

static char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

typedef struct _VMSEntryInfo {
    char *filename;
    char *type;
    char *date;
    unsigned int size;
    BOOLEAN display;		/* show this entry? */
} VMSEntryInfo;

static void free_VMSEntryInfo_contents(VMSEntryInfo * entry_info)
{
    if (entry_info) {
	FREE(entry_info->filename);
	FREE(entry_info->type);
	FREE(entry_info->date);
    }
    /* dont free the struct */
}

int compare_VMSEntryInfo_structs(VMSEntryInfo * entry1, VMSEntryInfo * entry2)
{
    int i, status;
    char date1[16], date2[16], time1[8], time2[8], month[4];

    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size == entry2->size)
	    return (strcasecomp(entry1->filename,
				entry2->filename));
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_DATE:
	if (entry1->date && entry2->date) {
	    /*
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 ||
		strlen(entry2->date) != 12) {
		return (strcasecomp(entry1->filename,
				    entry2->filename));
	    }
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[7] != ' ') {
		strcpy(date1, "9999");
		strcpy(time1, (char *) &entry1->date[7]);
	    } else {
		strcpy(date1, (char *) &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    strncat(date1, (char *) &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ') {
		date1[6] = '0';
	    }
	    strcat(date1, time1);
	    if (entry2->date[7] != ' ') {
		strcpy(date2, "9999");
		strcpy(time2, (char *) &entry2->date[7]);
	    } else {
		strcpy(date2, (char *) &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    strncat(date2, (char *) &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ') {
		date2[6] = '0';
	    }
	    strcat(date2, time2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_NAME:
    default:
	return (strcmp(entry1->filename,
		       entry2->filename));
    }
}

/*							HTVMSBrowseDir()
 *
 *	This function generates a directory listing as an HTML-object
 *	for local file URL's.  It assumes the first two elements of
 *	of the path are a device followed by a directory:
 *
 *		file://localhost/device/directory[/[foo]]
 *
 *	Will not accept 000000 as a directory name.
 *	Will offer links to parent through the top directory, unless
 *	a terminal slash was included in the calling URL.
 *
 *	Returns HT_LOADED on success, HTLoadError() messages on error.
 *
 *	Developed for Lynx by Foteos Macrides (macrides@@sci.wfeb.edu).
 */
int HTVMSBrowseDir(const char *address,
		   HTParentAnchor *anchor,
		   HTFormat format_out,
		   HTStream *sink)
{
    HTStructured *target;
    HTStructuredClass targetClass;
    char *pathname = HTParse(address, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *tail = NULL;
    char *title = NULL;
    char *header = NULL;
    char *parent = NULL;
    char *relative = NULL;
    char *cp, *cp1;
    int pathend, len;
    DIR *dp;
    struct stat file_info;
    time_t NowTime;
    static char ThisYear[8];
    VMSEntryInfo *entry_info = 0;
    char string_buffer[64];

    HTUnEscape(pathname);
    CTRACE((tfp, "HTVMSBrowseDir: Browsing `%s\'\n", pathname));

    /*
     * Require at least two elements (presumably a device and directory) and
     * disallow the device root (000000 directory).  Symbolic paths (e.g.,
     * sys$help) should have been translated and expanded (e.g., to
     * /sys$sysroot/syshlp) before calling this routine.
     */
    if (((*pathname != '/') ||
	 (cp = strchr(pathname + 1, '/')) == NULL ||
	 *(cp + 1) == '\0' ||
	 0 == strncmp((cp + 1), "000000", 6)) ||
	(dp = HTVMSopendir(pathname)) == NULL) {
	FREE(pathname);
	return HTLoadError(sink, 403, COULD_NOT_ACCESS_DIR);
    }

    /*
     * Set up the output stream.
     */
    _HTProgress(BUILDING_DIR_LIST);
    if (UCLYhndl_HTFile_for_unspec >= 0) {
	HTAnchor_setUCInfoStage(anchor,
				UCLYhndl_HTFile_for_unspec,
				UCT_STAGE_PARSER,
				UCT_SETBY_DEFAULT);
    }
    target = HTML_new(anchor, format_out, sink);
    targetClass = *(target->isa);

    /*
     * Set up the offset string of the anchor reference, and strings for the
     * title and header.
     */
    cp = strrchr(pathname, '/');	/* find lastslash */
    StrAllocCopy(tail, (cp + 1));	/* take slash off the beginning */
    if (*tail != '\0') {
	StrAllocCopy(title, tail);
	*cp = '\0';
	if ((cp1 = strrchr(pathname, '/')) != NULL &&
	    cp1 != pathname &&
	    strncmp((cp1 + 1), "000000", 6))
	    StrAllocCopy(parent, (cp1 + 1));
	*cp = '/';
    } else {
	pathname[strlen(pathname) - 1] = '\0';
	cp = strrchr(pathname, '/');
	StrAllocCopy(title, (cp + 1));
	pathname[strlen(pathname)] = '/';
    }
    StrAllocCopy(header, pathname);

    /*
     * Initialize path name for HTStat().
     */
    pathend = strlen(pathname);
    if (*(pathname + pathend - 1) != '/') {
	StrAllocCat(pathname, "/");
	pathend++;
    }

    /*
     * Output the title and header.
     */
    START(HTML_HTML);
    PUTC('\n');
    START(HTML_HEAD);
    PUTC('\n');
    HTUnEscape(title);
    START(HTML_TITLE);
    PUTS(title);
    PUTS(" directory");
    END(HTML_TITLE);
    PUTC('\n');
    FREE(title);
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_BODY);
    PUTC('\n');
    HTUnEscape(header);
    START(HTML_H1);
    PUTS(header);
    END(HTML_H1);
    PUTC('\n');
    if (HTDirReadme == HT_DIR_README_TOP) {
	FILE *fp;

	if (header[strlen(header) - 1] != '/')
	    StrAllocCat(header, "/");
	StrAllocCat(header, HT_DIR_README_FILE);
	if ((fp = fopen(header, "r")) != NULL) {
	    START(HTML_PRE);
	    for (;;) {
		char c = fgetc(fp);

		if (c == (char) EOF)
		    break;
#ifdef NOTDEFINED
		switch (c) {
		case '&':
		case '<':
		case '>':
		    PUTC('&');
		    PUTC('#');
		    PUTC((char) (c / 10));
		    PUTC((char) (c % 10));
		    PUTC(';');
		    break;
		default:
		    PUTC(c);
		}
#else
		PUTC(c);
#endif /* NOTDEFINED */
	    }
	    END(HTML_PRE);
	    fclose(fp);
	}
    }
    FREE(header);
    if (parent) {
	HTSprintf0(&relative, "%s/..", tail);
	HTStartAnchor(target, "", relative);
	PUTS("Up to ");
	HTUnEscape(parent);
	PUTS(parent);
	END(HTML_A);
	START(HTML_P);
	PUTC('\n');
	FREE(relative);
	FREE(parent);
    }

    /*
     * Set up the date comparison.
     */
    NowTime = time(NULL);
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
    ThisYear[4] = '\0';

    /*
     * Now, generate the Btree and put it out to the output stream.
     */
    {
	char dottest = 2;	/* To avoid two strcmp() each time */
	STRUCT_DIRENT *dirbuf;
	HTBTree *bt;

	/* Set up sort key and initialize BTree */
	bt = HTBTree_new((HTComparer) compare_VMSEntryInfo_structs);

	/* Build tree */
	while ((dirbuf = HTVMSreaddir(dp))) {
	    HTAtom *encoding = NULL;
	    HTFormat format;

	    /* Skip if not used */
	    if (!dirbuf->d_ino) {
		continue;
	    }

	    /* Current and parent directories are never shown in list */
	    if (dottest && (!strcmp(dirbuf->d_name, ".") ||
			    !strcmp(dirbuf->d_name, ".."))) {
		dottest--;
		continue;
	    }

	    /* Don't show the selective enabling file
	     * unless version numbers are included */
	    if (!strcasecomp(dirbuf->d_name, HT_DIR_ENABLE_FILE)) {
		continue;
	    }

	    /* Skip files beginning with a dot? */
	    if ((no_dotfiles || !show_dotfiles) && *dirbuf->d_name == '.') {
		continue;
	    }

	    /* OK, make an lstat() and get a key ready. */
	    *(pathname + pathend) = '\0';
	    StrAllocCat(pathname, dirbuf->d_name);
	    if (HTStat(pathname, &file_info)) {
		/* for VMS the failure here means the file is not readable...
		   we however continue to browse through the directory... */
		continue;
	    }
	    entry_info = (VMSEntryInfo *) malloc(sizeof(VMSEntryInfo));
	    if (entry_info == NULL)
		outofmem(__FILE__, "HTVMSBrowseDir");
	    entry_info->type = 0;
	    entry_info->size = 0;
	    entry_info->date = 0;
	    entry_info->filename = 0;
	    entry_info->display = TRUE;

	    /* Get the type */
	    format = HTFileFormat(dirbuf->d_name, &encoding,
				  (const char **) &cp);
	    if (!cp) {
		if (!strncmp(HTAtom_name(format), "application", 11)) {
		    cp = HTAtom_name(format) + 12;
		    if (!strncmp(cp, "x-", 2))
			cp += 2;
		} else
		    cp = HTAtom_name(format);
	    }
	    StrAllocCopy(entry_info->type, cp);

	    StrAllocCopy(entry_info->filename, dirbuf->d_name);
	    if (S_ISDIR(file_info.st_mode)) {
		/* strip .DIR part... */
		char *dot;

		dot = strstr(entry_info->filename, ".DIR");
		if (dot)
		    *dot = '\0';
		LYLowerCase(entry_info->filename);
		StrAllocCopy(entry_info->type, "Directory");
	    } else {
		if ((cp = strstr(entry_info->filename, "READ")) == NULL) {
		    cp = entry_info->filename;
		} else {
		    cp += 4;
		    if (!strncmp(cp, "ME", 2)) {
			cp += 2;
			while (cp && *cp && *cp != '.') {
			    cp++;
			}
		    } else if (!strncmp(cp, ".ME", 3)) {
			cp = (entry_info->filename +
			      strlen(entry_info->filename));
		    } else {
			cp = entry_info->filename;
		    }
		}
		LYLowerCase(cp);
		if (((len = strlen(entry_info->filename)) > 2) &&
		    entry_info->filename[len - 1] == 'z') {
		    if (entry_info->filename[len - 2] == '.' ||
			entry_info->filename[len - 2] == '_')
			entry_info->filename[len - 1] = 'Z';
		}
	    }

	    /* Get the date */
	    {
		char *t = (char *) ctime((const time_t *) &file_info.st_ctime);

		*(t + 24) = '\0';

		StrAllocCopy(entry_info->date, (t + 4));
		*((entry_info->date) + 7) = '\0';
		if ((atoi((t + 19))) < atoi(ThisYear))
		    StrAllocCat(entry_info->date, (t + 19));
		else {
		    StrAllocCat(entry_info->date, (t + 11));
		    *((entry_info->date) + 12) = '\0';
		}
	    }

	    /* Get the size */
	    if (!S_ISDIR(file_info.st_mode))
		entry_info->size = (unsigned int) file_info.st_size;
	    else
		entry_info->size = 0;

	    /* Now, update the BTree etc. */
	    if (entry_info->display) {
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
	    }

	}			/* End while HTVMSreaddir() */

	FREE(pathname);
	HTVMSclosedir(dp);

	START(HTML_PRE);
	/*
	 * Run through the BTree printing out in order
	 */
	{
	    HTBTElement *ele;
	    int i;

	    for (ele = HTBTree_next(bt, NULL);
		 ele != NULL;
		 ele = HTBTree_next(bt, ele)) {
		entry_info = (VMSEntryInfo *) HTBTree_object(ele);

		/* Output the date */
		if (entry_info->date) {
		    PUTS(entry_info->date);
		    PUTS("  ");
		} else
		    PUTS("     * ");

		/* Output the type */
		if (entry_info->type) {
		    for (i = 0; entry_info->type[i] != '\0' && i < 15; i++)
			PUTC(entry_info->type[i]);
		    for (; i < 17; i++)
			PUTC(' ');

		}

		/* Output the link for the name */
		HTDirEntry(target, tail, entry_info->filename);
		PUTS(entry_info->filename);
		END(HTML_A);

		/* Output the size */
		if (entry_info->size) {
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %d bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "  %dKb",
				entry_info->size / 1024);
		    PUTS(string_buffer);
		}

		PUTC('\n');	/* end of this entry */

		free_VMSEntryInfo_contents(entry_info);
	    }
	}

	HTBTreeAndObject_free(bt);

    }				/* End of both BTree loops */

    /*
     * Complete the output stream.
     */
    END(HTML_PRE);
    PUTC('\n');
    END(HTML_BODY);
    PUTC('\n');
    END(HTML_HTML);
    PUTC('\n');
    FREE(tail);
    FREE_TARGET;

    return HT_LOADED;

}				/* End of directory reading section */

/*
 * Remove all versions of the given file.  We assume there are no permissions
 * problems, since we do this mainly for removing temporary files.
 */
int HTVMS_remove(char *filename)
{
    int code = remove(filename);	/* return the first status code */

    while (remove(filename) == 0) ;
    return code;
}

/*
 * Remove all older versions of the given file.  We may fail to remove some
 * version due to permissions -- the loop stops either at that point, or when
 * we run out of older versions to remove.
 */
void HTVMS_purge(char *filename)
{
    char *older_file = 0;
    char *oldest_file = 0;
    struct stat sb;

    StrAllocCopy(older_file, filename);
    StrAllocCat(older_file, ";-1");

    while (remove(older_file) == 0) ;
    /*
     * If we do not have any more older versions, it is safe to rename the
     * current file to version #1.
     */
    if (stat(older_file, &sb) != 0) {
	StrAllocCopy(oldest_file, filename);
	StrAllocCat(oldest_file, ";1");
	rename(older_file, oldest_file);
	FREE(oldest_file);
    }

    FREE(older_file);
}
#endif /* VMS */
@


1.5
log
@automatic merge of lynx-current
@
text
@d550 1
a550 1
	exit(status);
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d3 12
a14 12
**		VMS Utility Routines
**
** AUTHORS:
**	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
**
** HISTORY:
**	14 Nov 93  MD	Written
**
** BUGS:
**
**
*/
d17 1
d41 1
a41 1
BOOL HTVMSFileVersions = FALSE; /* Include version numbers in listing? */
d44 4
a47 4
   unsigned long BufferLength : 16;
   unsigned long ItemCode : 16;
   unsigned long BufferAddress : 32;
   unsigned long ReturnLengthAddress : 32;
d51 8
a58 8
**		CHECKS IF THIS PROCESS IS AUTHORIZED TO ENABLE SYSPRV
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	YES if SYSPRV is authorized
*/
BOOL HTVMS_authSysPrv (void)
d60 17
a76 17
unsigned long Result;
ItemStruct ItemList[2];
unsigned long Length;
unsigned long Buffer[2];

  /* fill Item */
  ItemList[0].BufferLength = sizeof(Buffer);
  ItemList[0].BufferAddress = (unsigned long)Buffer;
  ItemList[0].ReturnLengthAddress = (unsigned long)&Length;
  ItemList[0].ItemCode = JPI$_AUTHPRIV;

  /* terminate list */
  ItemList[1].ItemCode = 0;
  ItemList[1].BufferLength = 0;

  /* call system */
  Result = sys$getjpiw(0, 0, 0, ItemList, 0, 0, 0);
d78 2
a79 2
  if (Result != SS$_NORMAL)
     return(NO);
d81 2
a82 2
  if (Buffer[0] & PRV$M_SYSPRV)
     return(YES);
d84 1
a84 1
  return(NO);
a86 2


d88 8
a95 8
**		ENABLES SYSPRV
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**
*/
void HTVMS_enableSysPrv (void)
d97 2
a98 2
unsigned long Result;
unsigned long Prv[2], PreviousPrv[2];
d100 9
a108 9
   Prv[0] = PRV$M_SYSPRV;
   Prv[1] = 0;
   Result = sys$setprv(1,&Prv,0,&PreviousPrv);

   if (Result == SS$_NORMAL) {
       if (!(PreviousPrv[0] & PRV$M_SYSPRV)) {
	   CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
       }
   }
a110 2


d112 8
a119 8
**		DISABLES SYSPRV
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**
*/
void HTVMS_disableSysPrv (void)
d121 2
a122 2
unsigned long Result;
unsigned long Prv[2], PreviousPrv[2];
d124 9
a132 9
   Prv[0] = PRV$M_SYSPRV;
   Prv[1] = 0;
   Result = sys$setprv(0,&Prv,0,&PreviousPrv);

   if (Result == SS$_NORMAL) {
       if (PreviousPrv[0] & PRV$M_SYSPRV) {
	   CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
       }
   }
a134 2


d136 14
a149 15
**		CHECKS ACCESS TO FILE FOR CERTAIN USER
** ON ENTRY:
**	FileName	The file to be accessed
**	UserName	Name of the user to check access for.
**			User nobody, represented by "" is given NO for an answer
**	Method		Name of the method to be chceked
**
** ON EXIT:
**	returns YES if access is allowed
**
*/
BOOL HTVMS_checkAccess (
	const char * FileName,
	const char * UserName,
	const char * Method)
d151 56
a206 57
unsigned long Result;
ItemStruct ItemList[2];
unsigned long Length;
unsigned long Buffer;
unsigned long ObjType;

char *VmsName;

struct dsc$descriptor_s FileNameDesc;
struct dsc$descriptor_s UserNameDesc;

char *colon;

   /* user nobody should access as from account under which server is running */
   if (0 == strcmp(UserName,""))
      return(NO);

   /* check Filename and convert */
   colon = strchr(FileName,':');
   if (colon)
      VmsName = HTVMS_name("",colon+1);
   else
      VmsName = HTVMS_name("",FileName);

   /* check for GET */
   if (0 == strcmp(Method,"GET"))
   {
     /* fill Item */
     ItemList[0].BufferLength = sizeof(Buffer);
     ItemList[0].BufferAddress = (unsigned long)&Buffer;
     ItemList[0].ReturnLengthAddress = (unsigned long)&Length;
     ItemList[0].ItemCode = CHP$_FLAGS;

     /* terminate list */
     ItemList[1].ItemCode = 0;
     ItemList[1].BufferLength = 0;

     /* fill input */
     ObjType = ACL$C_FILE;
     Buffer = CHP$M_READ;
     UserNameDesc.dsc$w_length = strlen(UserName);
     UserNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
     UserNameDesc.dsc$b_class = DSC$K_CLASS_S;
     UserNameDesc.dsc$a_pointer = (char *)UserName;
     FileNameDesc.dsc$w_length = strlen(VmsName);
     FileNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
     FileNameDesc.dsc$b_class = DSC$K_CLASS_S;
     FileNameDesc.dsc$a_pointer = VmsName;

     /* call system */
     Result = sys$check_access(&ObjType,&FileNameDesc,&UserNameDesc,ItemList);

     if (Result == SS$_NORMAL)
	return(YES);
     else
	return(NO);
   }
d208 1
a208 1
   return(NO);
a210 2


d212 25
a236 25
**		CONVERTS VMS Name into WWW Name
** ON ENTRY:
**	vmsname		VMS file specification (NO NODE)
**
** ON EXIT:
**	returns		www file specification
**
** EXAMPLES:
**	vmsname				wwwname
**	DISK$USER			disk$user
**	DISK$USER:			/disk$user/
**	DISK$USER:[DUNS]		/disk$user/duns
**	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
**	[DUNS]				duns
**	[DUNS.ECHO]			duns/echo
**	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
**	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
**	[.DUNS]				duns
**	[.DUNS.ECHO]			duns/echo
**	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
**	TEST.COM			test.com
**
**
*/
char * HTVMS_wwwName (const char *	vmsname)
d238 58
a295 50
static char wwwname[LY_MAXPATH];
const char *src;
char *dst;
int dir;
   dst = wwwname;
   src = vmsname;
   dir = 0;
   if (strchr(src,':')) *(dst++) = '/';
   for ( ; *src != '\0' ; src++)
   {
      switch(*src)
      {
	 case ':':  *(dst++) = '/'; break;
	 case '-': if (dir)
		   {
		      if ((*(src-1)=='[' || *(src-1)=='.' || *(src-1)=='-') &&
			  (*(src+1)=='.' || *(src+1)=='-'))
		      {
			  *(dst++) = '/';
			  *(dst++) = '.';
			  *(dst++) = '.';
		      }
		      else
			  *(dst++) = '-';
		   }
		   else
		   {
		      if (*(src-1) == ']') *(dst++) = '/';
		      *(dst++) = '-';
		   }
		   break;
	 case '.': if (dir)
		   {
		      if (*(src-1) != '[') *(dst++) = '/';
		   }
		   else
		   {
		      if (*(src-1) == ']') *(dst++) = '/';
		      *(dst++) = '.';
		   }
		   break;
	 case '[': dir = 1; break;
	 case ']': dir = 0; break;
	 default:  if (*(src-1) == ']') *(dst++) = '/';
		   *(dst++) = *src;
		   break;
      }
   }
   *(dst++) = '\0';
   return(wwwname);
a297 1

d299 5
a303 6
**	The code below is for directory browsing by VMS Curses clients.
**	It is based on the newer WWWLib's HTDirBrw.c. - Foteos Macrides
*/
int HTStat (
	const char * filename,
	struct stat * info)
d305 64
a368 67
   /*
      the following stuff does not work in VMS with a normal stat...
      -->   /disk$user/duns/www if www is a directory
		is statted like:	/disk$user/duns/www.dir
		after a normal stat has failed
      -->   /disk$user/duns	if duns is a toplevel directory
		is statted like:	/disk$user/000000/duns.dir
      -->   /disk$user since disk$user is a device
		is statted like:	/disk$user/000000/000000.dir
      -->   /
		searches all devices, no solution yet...
      -->   /vxcern!/disk$cr/wwwteam/login.com
		is not statted but granted with fake information...
   */
int Result;
int Len;
char *Ptr, *Ptr2;
static char *Name;

   /* try normal stat... */
   Result = stat((char *)filename,info);
   if (Result == 0)
      return(Result);

   /* make local copy */
   StrAllocCopy(Name,filename);

   /* failed,so do device search in case root is requested */
   if (!strcmp(Name,"/"))
   {  /* root requested */
      return(-1);
   }

   /* failed so this might be a directory, add '.dir' */
   Len = strlen(Name);
   if (Name[Len-1] == '/')
      Name[Len-1] = '\0';

   /* fail in case of device */
   Ptr = strchr(Name+1,'/');
   if ((Ptr == NULL) && (Name[0] == '/'))
   {  /* device only... */
      StrAllocCat(Name, "/000000/000000");
   }

   if (Ptr != NULL)
   {  /* correct filename in case of toplevel dir */
      Ptr2 = strchr(Ptr+1,'/');
      if ((Ptr2 == NULL) && (Name[0] == '/'))
      {
	 char End[256];
	 LYstrncpy(End, Ptr, sizeof(End) - 1);
	 *(Ptr+1) = '\0';
	 StrAllocCat(Name, "000000");
	 StrAllocCat(Name, End);
      }
   }

   /* try in case a file on toplevel directory or .DIR was already specified */
   Result = stat(Name,info);
   if (Result == 0)
      return(Result);

   /* add .DIR and try again */
   StrAllocCat(Name, ".dir");
   Result = stat(Name,info);
   return(Result);
d376 1
a376 1
#endif	/* !_POSIX_SOURCE */
d378 4
a381 4
typedef	struct __dirdesc {
	long	context;	/* context descriptor for LIB$FIND_FILE calls */
	char	dirname[255+1];	/* keeps the directory name, including *.* */
	struct dsc$descriptor_s dirname_desc;	/* descriptor of dirname */
d384 3
a386 3
static	DIR *HTVMSopendir(char *dirname);
static	struct dirent *HTVMSreaddir(DIR *dirp);
static	int HTVMSclosedir(DIR *dirp);
d390 4
a393 4
struct	dirent {
	unsigned long	d_fileno;	/* file number of entry */
	unsigned short	d_namlen;	/* length of string in d_name */
	char		d_name[255+1];	/* name (up to MAXNAMLEN + 1) */
d412 1
a412 2
#endif	/* !_POSIX_SOURCE */

d416 86
a501 91
static DIR dir;
char *closebracket;
long status;
struct dsc$descriptor_s entryname_desc;
struct dsc$descriptor_s dirname_desc;
static char *DirEntry;
char Actual[256];
char VMSentry[256];
char UnixEntry[256];
int index;
char *dot;

   /* check if directory exists */
   /* dirname can look like /disk$user/duns/www/test/multi    */
   /* or like               /disk$user/duns/www/test/multi/   */
   /* DirEntry should look like     disk$user:[duns.www.test]multi in both cases */
   /* dir.dirname should look like  disk$user:[duns.www.test.multi] */
   sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
   if (UnixEntry[strlen(UnixEntry)-1] != '/')
      strcat(UnixEntry,"/");

   StrAllocCopy(DirEntry, HTVMS_name("",UnixEntry));
   if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
      return (NULL);
   strcpy(dir.dirname, DirEntry);
   index = strlen(DirEntry) - 1;

   if (DirEntry[index] == ']')
      DirEntry[index] = '\0';

   if ((dot = strrchr(DirEntry,'.')) == NULL)
   {  /* convert disk$user:[duns] into disk$user:[000000]duns.dir */
      char *openbr = strrchr(DirEntry,'[');
      if (!openbr)
      { /* convert disk$user: into disk$user:[000000]000000.dir */
         if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
            return (NULL);
         sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	 StrAllocCat(DirEntry,"[000000]000000.dir");
      }
      else
      {
	 char End[256];
	 strcpy(End,openbr+1);
	 *(openbr+1) = '\0';
	 StrAllocCat(DirEntry,"000000]");
	 StrAllocCat(DirEntry,End);
	 StrAllocCat(DirEntry,".dir");
      }
   }
   else
   {
      *dot = ']';
      StrAllocCat(DirEntry,".dir");
   }
   /* lib$find_file needs a fixed-size buffer */
   LYstrncpy(Actual, DirEntry, sizeof(Actual)-1);

   dir.context = 0;
   dirname_desc.dsc$w_length = strlen(Actual);
   dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   dirname_desc.dsc$b_class = DSC$K_CLASS_S;
   dirname_desc.dsc$a_pointer = (char *)&(Actual);

   /* look for the directory */
   entryname_desc.dsc$w_length = 255;
   entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   entryname_desc.dsc$b_class = DSC$K_CLASS_S;
   entryname_desc.dsc$a_pointer = VMSentry;

   status = lib$find_file(&(dirname_desc),
			  &entryname_desc,
			  &(dir.context),
			  0,0,0,0);
   if (!(status & 0x01))
   { /* directory not found */
      return(NULL);
   }

   if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
       return (NULL);
   if (HTVMSFileVersions)
       strcat(dir.dirname,"*.*;*");
   else
       strcat(dir.dirname,"*.*");
   dir.context = 0;
   dir.dirname_desc.dsc$w_length = strlen(dir.dirname);
   dir.dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   dir.dirname_desc.dsc$b_class = DSC$K_CLASS_S;
   dir.dirname_desc.dsc$a_pointer = (char *)&(dir.dirname);
   return(&dir);
d506 36
a541 38
static struct dirent entry;
long status;
struct dsc$descriptor_s entryname_desc;
char *space, *slash;
char VMSentry[256];
char *UnixEntry;

   entryname_desc.dsc$w_length = 255;
   entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   entryname_desc.dsc$b_class = DSC$K_CLASS_S;
   entryname_desc.dsc$a_pointer = VMSentry;

   status = lib$find_file(&(dirp->dirname_desc),
			  &entryname_desc,
			  &(dirp->context),
			  0,0,0,0);
   if (status == RMS$_NMF)
   { /* no more files */
      return(NULL);
   }
   else
   { /* ok */
      if (!(status & 0x01)) return(0);
      if (HTVMSFileVersions)
	  space = strchr(VMSentry,' ');
      else
	  space = strchr(VMSentry,';');
      if (space)
	 *space = '\0';

      /* convert to unix style... */
      UnixEntry = HTVMS_wwwName(VMSentry);
      slash = strrchr(UnixEntry,'/') + 1;
      strcpy(entry.d_name,slash);
      entry.d_namlen = strlen(entry.d_name);
      entry.d_fileno = 1;
      return(&entry);
   }
d546 1
a546 1
long status;
d548 5
a552 4
   status = lib$find_file_end(&(dirp->context));
   if (!(status & 0x01)) exit(status);
   dirp->context = 0;
   return(0);
d558 1
a558 1
#include <HTFile.h>	/* For HTFileFormat() */
d561 2
a562 2
**  Hypertext object building machinery.
*/
d571 2
a572 2
	const HTStructuredClass *	isa;
	/* ... */
d577 4
a580 2
static char * months[12] = {
    "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
d584 3
a586 3
    char *       filename;
    char *       type;
    char *       date;
d588 1
a588 1
    BOOLEAN      display;  /* show this entry? */
d591 1
a591 1
static void free_VMSEntryInfo_contents (VMSEntryInfo * entry_info)
d598 1
a598 1
   /* dont free the struct */
d601 1
a601 2
int compare_VMSEntryInfo_structs (VMSEntryInfo * entry1,
					      VMSEntryInfo * entry2)
d606 94
a699 96
    switch(HTfileSortMethod)
      {
	case FILE_BY_SIZE:
			/* both equal or both 0 */
			if(entry1->size == entry2->size)
			    return(strcasecomp(entry1->filename,
					       entry2->filename));
			else
			    if(entry1->size > entry2->size)
				return(1);
			    else
				return(-1);
	case FILE_BY_TYPE:
			if(entry1->type && entry2->type) {
			    status = strcasecomp(entry1->type, entry2->type);
			    if(status)
				return(status);
			    /* else fall to filename comparison */
			}
			return (strcasecomp(entry1->filename,
					    entry2->filename));
	case FILE_BY_DATE:
			if(entry1->date && entry2->date) {
			    /*
			    ** Make sure we have the correct length. - FM
			    */
			    if (strlen(entry1->date) != 12 ||
				strlen(entry2->date) != 12) {
				return (strcasecomp(entry1->filename,
						    entry2->filename));
			    }
			    /*
			    ** Set up for sorting in reverse
			    ** chronological order. - FM
			    */
			    if (entry1->date[7] != ' ') {
				strcpy(date1, "9999");
				strcpy(time1, (char *)&entry1->date[7]);
			    } else {
				strcpy(date1, (char *)&entry1->date[8]);
				strcpy(time1, "00:00");
			    }
			    strncpy(month, entry1->date, 3);
			    month[3] = '\0';
			    for (i = 0; i < 12; i++) {
				if (!strcasecomp(month, months[i])) {
				    break;
				}
			    }
			    i++;
			    sprintf(month, "%02d", i);
			    strcat(date1, month);
			    strncat(date1, (char *)&entry1->date[4], 2);
			    date1[8] = '\0';
			    if (date1[6] == ' ') {
				date1[6] = '0';
			    }
			    strcat(date1, time1);
			    if (entry2->date[7] != ' ') {
				strcpy(date2, "9999");
				strcpy(time2, (char *)&entry2->date[7]);
			    } else {
				strcpy(date2, (char *)&entry2->date[8]);
				strcpy(time2, "00:00");
			    }
			    strncpy(month, entry2->date, 3);
			    month[3] = '\0';
			    for (i = 0; i < 12; i++) {
				if (!strcasecomp(month, months[i])) {
				    break;
				}
			    }
			    i++;
			    sprintf(month, "%02d", i);
			    strcat(date2, month);
			    strncat(date2, (char *)&entry2->date[4], 2);
			    date2[8] = '\0';
			    if (date2[6] == ' ') {
				date2[6] = '0';
			    }
			    strcat(date2, time2);
			    /*
			    ** Do the comparison. - FM
			    */
			    status = strcasecomp(date2, date1);
			    if(status)
				return(status);
			    /* else fall to filename comparison */
			}
			return (strcasecomp(entry1->filename,
					    entry2->filename));
	case FILE_BY_NAME:
	default:
			return (strcmp(entry1->filename,
					    entry2->filename));
      }
a701 1

d703 19
a721 21
**
**	This function generates a directory listing as an HTML-object
**	for local file URL's.  It assumes the first two elements of
**	of the path are a device followed by a directory:
**
**		file://localhost/device/directory[/[foo]]
**
**	Will not accept 000000 as a directory name.
**	Will offer links to parent through the top directory, unless
**	a terminal slash was included in the calling URL.
**
**	Returns HT_LOADED on success, HTLoadError() messages on error.
**
**	Developed for Lynx by Foteos Macrides (macrides@@sci.wfeb.edu).
*/
int HTVMSBrowseDir (
	const char *		address,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink
)
d723 1
a723 1
    HTStructured* target;
d732 1
a732 1
    int  pathend, len;
d741 1
a741 1
    CTRACE((tfp,"HTVMSBrowseDir: Browsing `%s\'\n", pathname));
d744 4
a747 4
     *  Require at least two elements (presumably a device and directory)
     *  and disallow the device root (000000 directory).  Symbolic paths
     *  (e.g., sys$help) should have been translated and expanded (e.g.,
     *  to /sys$sysroot/syshlp) before calling this routine.
d750 1
a750 1
	 (cp = strchr(pathname+1, '/')) == NULL ||
d759 1
a759 1
     *  Set up the output stream.
d761 1
a761 1
    _HTProgress (BUILDING_DIR_LIST);
d772 2
a773 2
     *  Set up the offset string of the anchor reference,
     *  and strings for the title and header.
d775 2
a776 2
    cp = strrchr(pathname, '/');  /* find lastslash */
    StrAllocCopy(tail, (cp+1)); /* take slash off the beginning */
d780 1
a780 1
	if ((cp1=strrchr(pathname, '/')) != NULL &&
d782 2
a783 2
	    strncmp((cp1+1), "000000", 6))
	    StrAllocCopy(parent, (cp1+1));
d786 1
a786 1
	pathname[strlen(pathname)-1] = '\0';
d788 1
a788 1
	StrAllocCopy(title, (cp+1));
d794 1
a794 1
     *  Initialize path name for HTStat().
d797 1
a797 1
    if (*(pathname+pathend-1) != '/') {
d803 1
a803 1
     *  Output the title and header.
d826 3
a828 2
	FILE * fp;
	if (header[strlen(header)-1] != '/')
d831 1
a831 1
	if ((fp = fopen(header,	 "r")) != NULL) {
d833 1
a833 1
	    for(;;) {
d835 2
a836 1
		if (c == (char)EOF)
d840 11
a850 11
		    case '&':
		    case '<':
		    case '>':
			PUTC('&');
			PUTC('#');
			PUTC((char)(c / 10));
			PUTC((char) (c % 10));
			PUTC(';');
			break;
		    default:
			PUTC(c);
d875 1
a875 1
     *  Set up the date comparison.
d878 1
a878 1
    strcpy(ThisYear, (char *)ctime(&NowTime)+20);
d898 1
a898 1
	    if (!dirbuf->d_ino)	{
d921 1
a921 1
	    *(pathname+pathend) = '\0';
d928 1
a928 1
	    entry_info = (VMSEntryInfo *)malloc(sizeof(VMSEntryInfo));
d939 1
a939 1
				  (const char **)&cp);
d941 1
a941 2
		if(!strncmp(HTAtom_name(format), "application",11))
		{
d943 1
a943 1
		    if(!strncmp(cp,"x-", 2))
d945 1
a945 2
		}
		else
d954 1
d957 1
a957 1
		   *dot = '\0';
d979 4
a982 4
		    entry_info->filename[len-1] == 'z') {
		    if (entry_info->filename[len-2] == '.' ||
			entry_info->filename[len-2] == '_')
			entry_info->filename[len-1] = 'Z';
d988 1
a988 2
		char *t = (char *)ctime((const time_t *)&file_info.st_ctime);
		*(t+24) = '\0';
d990 6
a995 4
		StrAllocCopy(entry_info->date, (t+4));
		*((entry_info->date)+7) = '\0';
		if ((atoi((t+19))) < atoi(ThisYear))
		    StrAllocCat(entry_info->date,  (t+19));
d997 2
a998 2
		    StrAllocCat(entry_info->date, (t+11));
		    *((entry_info->date)+12) = '\0';
d1004 1
a1004 1
		entry_info->size = (unsigned int)file_info.st_size;
d1009 5
a1013 6
	    if(entry_info->display)
	      {
		 CTRACE((tfp,"Adding file to BTree: %s\n",
						      entry_info->filename));
		 HTBTree_add(bt, entry_info);
	      }
d1015 1
a1015 1
	} /* End while HTVMSreaddir() */
d1025 1
a1025 1
	    HTBTElement * ele;
d1027 1
d1030 2
a1031 3
		 ele = HTBTree_next(bt, ele))
	    {
		entry_info = (VMSEntryInfo *)HTBTree_object(ele);
d1034 5
a1038 7
		if(entry_info->date)
		       {
			     PUTS(entry_info->date);
			     PUTS("  ");
		       }
		else
			PUTS("     * ");
d1041 2
a1042 3
		if(entry_info->type)
		  {
		    for(i = 0; entry_info->type[i] != '\0' && i < 15; i++)
d1044 1
a1044 1
		    for(; i < 17; i++)
d1047 1
a1047 1
		  }
d1055 9
a1063 10
		if(entry_info->size)
		  {
			  if(entry_info->size < 1024)
			      sprintf(string_buffer,"  %d bytes",
							entry_info->size);
			  else
			      sprintf(string_buffer,"  %dKb",
							entry_info->size/1024);
			  PUTS(string_buffer);
		  }
d1065 1
a1065 1
		PUTC('\n'); /* end of this entry */
d1073 1
a1073 1
    } /* End of both BTree loops */
d1076 1
a1076 1
     *  Complete the output stream.
d1089 1
a1089 1
} /* End of directory reading section */
d1098 2
a1099 2
    while (remove(filename) == 0)
	;
d1117 1
a1117 2
    while (remove(older_file) == 0)
	;
d1131 1
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d40 1
a40 1
PUBLIC BOOL HTVMSFileVersions = FALSE; /* Include version numbers in listing? */
d57 1
a57 1
PUBLIC BOOL HTVMS_authSysPrv NOARGS
d96 1
a96 1
PUBLIC void HTVMS_enableSysPrv NOARGS
d122 1
a122 1
PUBLIC void HTVMS_disableSysPrv NOARGS
d152 4
a155 4
PUBLIC BOOL HTVMS_checkAccess ARGS3(
	CONST char *, FileName,
	CONST char *, UserName,
	CONST char *, Method)
d245 1
a245 2
PUBLIC char * HTVMS_wwwName ARGS1(
	CONST char *,	vmsname)
d248 1
a248 1
CONST char *src;
d304 3
a306 3
PUBLIC int HTStat ARGS2(
	CONST char *, filename,
	struct stat *, info)
d390 3
a392 3
PRIVATE	DIR *HTVMSopendir(char *dirname);
PRIVATE	struct dirent *HTVMSreaddir(DIR *dirp);
PRIVATE	int HTVMSclosedir(DIR *dirp);
d421 1
a421 1
PRIVATE DIR *HTVMSopendir(char *dirname)
d516 1
a516 1
PRIVATE struct dirent *HTVMSreaddir(DIR *dirp)
d558 1
a558 1
PRIVATE int HTVMSclosedir(DIR *dirp)
d584 1
a584 1
	CONST HTStructuredClass *	isa;
d590 1
a590 1
PRIVATE char * months[12] = {
d602 1
a602 1
PRIVATE void free_VMSEntryInfo_contents ARGS1(VMSEntryInfo *,entry_info)
d612 2
a613 2
PUBLIC int compare_VMSEntryInfo_structs ARGS2(VMSEntryInfo *,entry1,
					      VMSEntryInfo *,entry2)
d733 5
a737 5
PUBLIC int HTVMSBrowseDir ARGS4(
	CONST char *,		address,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink
d954 1
a954 1
				  (CONST char **)&cp);
d1004 1
a1004 1
		char *t = (char *)ctime((CONST time_t *)&file_info.st_ctime);
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d22 2
d35 1
d38 1
d40 1
a40 3
#define INFINITY 512            	/* File name length @@@@ FIXME */

PUBLIC BOOL HTVMSFileVersions=FALSE; /* Include version numbers in listing? */
a48 2
extern CONST char * HTHostName NOPARAMS;

d107 1
a107 1
           CTRACE(tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n");
d133 1
a133 1
           CTRACE(tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n");
d210 1
a210 1
        return(YES);
d212 1
a212 1
        return(NO);
d226 1
a226 1
**	returns 	www file specification
d230 12
a241 12
**	DISK$USER 			disk$user
**	DISK$USER: 			/disk$user/
**	DISK$USER:[DUNS] 		/disk$user/duns
**	DISK$USER:[DUNS.ECHO] 		/disk$user/duns/echo
**	[DUNS] 				duns
**	[DUNS.ECHO] 			duns/echo
**	[DUNS.ECHO.-.TRANS] 		duns/echo/../trans
**	[DUNS.ECHO.--.TRANS] 		duns/echo/../../trans
**	[.DUNS] 			duns
**	[.DUNS.ECHO] 			duns/echo
**	[.DUNS.ECHO]TEST.COM 		duns/echo/test.com
**	TEST.COM 			test.com
d246 1
a246 1
	char *, vmsname)
d248 3
a250 2
static char wwwname[256];
char *src, *dst;
d260 5
a264 5
         case ':':  *(dst++) = '/'; break;
         case '-': if (dir)
	 	   {
	 	      if ((*(src-1)=='[' || *(src-1)=='.' || *(src-1)=='-') &&
		          (*(src+1)=='.' || *(src+1)=='-'))
d266 3
a268 3
		          *(dst++) = '/';
                          *(dst++) = '.';
                          *(dst++) = '.';
d271 1
a271 1
		          *(dst++) = '-';
d278 6
a283 6
                   break;
         case '.': if (dir)
                   {
                      if (*(src-1) != '[') *(dst++) = '/';
                   }
                   else
d286 1
a286 1
                      *(dst++) = '.';
d288 6
a293 6
                   break;
         case '[': dir = 1; break;
         case ']': dir = 0; break;
         default:  if (*(src-1) == ']') *(dst++) = '/';
                   *(dst++) = *src;
                   break;
a300 72
/* PUBLIC							HTVMS_name()
**		CONVERTS WWW name into a VMS name
** ON ENTRY:
**	nn		Node Name (optional)
**	fn		WWW file name
**
** ON EXIT:
**	returns 	vms file specification
**
** Bug:	Returns pointer to static -- non-reentrant
*/
PUBLIC char * HTVMS_name ARGS2(
	CONST char *, nn,
	CONST char *, fn)
{

/*	We try converting the filename into Files-11 syntax.  That is, we assume
**	first that the file is, like us, on a VMS node.  We try remote
**	(or local) DECnet access.  Files-11, VMS, VAX and DECnet
**	are trademarks of Digital Equipment Corporation.
**	The node is assumed to be local if the hostname WITHOUT DOMAIN
**	matches the local one. @@@@@@
*/
    static char vmsname[INFINITY];	/* returned */
    char * filename = (char*)malloc(strlen(fn)+1);
    char * nodename = (char*)malloc(strlen(nn)+2+1);	/* Copies to hack */
    char *second;		/* 2nd slash */
    char *last;			/* last slash */

    char * hostname = (char *)HTHostName();

    if (!filename || !nodename) outofmem(__FILE__, "HTVMSname");
    strcpy(filename, fn);
    strcpy(nodename, "");	/* On same node?  Yes if node names match */
    if (strncmp(nn,"localhost",9)) {
        char *p, *q;
        for (p=hostname, q=(char *)nn;
	     *p && *p!='.' && *q && *q!='.'; p++, q++){
	    if (TOUPPER(*p)!=TOUPPER(*q)) {
	        strcpy(nodename, nn);
		q = strchr(nodename, '.');	/* Mismatch */
		if (q) *q=0;			/* Chop domain */
		strcat(nodename, "::");		/* Try decnet anyway */
		break;
	    }
	}
    }

    second = strchr(filename+1, '/');		/* 2nd slash */
    last = strrchr(filename, '/');	/* last slash */

    if (!second) {				/* Only one slash */
	sprintf(vmsname, "%s%s", nodename, filename + 1);
    } else if(second==last) {		/* Exactly two slashes */
	*second = 0;		/* Split filename from disk */
	sprintf(vmsname, "%s%s:%s", nodename, filename+1, second+1);
	*second = '/';	/* restore */
    } else { 				/* More than two slashes */
	char * p;
	*second = 0;		/* Split disk from directories */
	*last = 0;		/* Split dir from filename */
	sprintf(vmsname, "%s%s:[%s]%s",
		nodename, filename+1, second+1, last+1);
	*second = *last = '/';	/* restore filename */
	for (p=strchr(vmsname, '['); *p!=']'; p++)
	    if (*p=='/') *p='.';	/* Convert dir sep.  to dots */
    }
    FREE(nodename);
    FREE(filename);
    return vmsname;
}

d312 1
a312 1
		is statted like: 	/disk$user/duns/www.dir
d326 1
a326 1
char Name[256];
d334 1
a334 26
   strcpy(Name,filename);

#ifdef NOT_USED
   /* if filename contains a node specification (! or ::), we will try to access
      the file via DECNET, but we do not stat it..., just return success
      with some fake information... */
   if (HTVMS_checkDecnet(Name))
   {
      /* set up fake info, only the one we use... */
      info->st_dev = NULL;
      info->st_ino[0] = 0;
      info->st_ino[1] = 0;
      info->st_ino[2] = 0;
      info->st_mode = S_IFREG | S_IREAD;	/* assume it is a regular Readable file */
      info->st_nlink = NULL;
      info->st_uid = 0;
      info->st_gid = 0;
      info->st_rdev = 0;
      info->st_size = 0;
      info->st_atime = time(NULL);
      info->st_mtime = time(NULL);
      info->st_ctime = time(NULL);

      return(0);
   }
#endif /* NOT_USED */
d351 1
a351 1
      strcat(Name,"/000000/000000");
d359 5
a363 5
         char End[256];
         strcpy(End,Ptr);
         *(Ptr+1) = '\0';
         strcat(Name,"000000");
         strcat(Name,End);
d367 1
a367 1
   /* try in case a file on toplevel directory or .DIR was alreadyt specified */
d373 1
a373 1
   strcat(Name,".dir");
d386 1
a386 9
#if 0
	int	dd_fd;		/* file descriptor */
	long	dd_loc;		/* buf offset of entry from last readddir() */
	long	dd_size;	/* amount of valid data in buffer */
	long	dd_bsize;	/* amount of entries read at a time */
	long	dd_off;		/* Current offset in dir (for telldir) */
	char	*dd_buf;	/* directory data buffer */
#endif
	long 	context;	/* context descriptor for LIB$FIND_FILE calls */
a393 11
#if 0
#ifndef	_POSIX_SOURCE
extern	void seekdir(/* DIR *dirp, int loc */);
extern	long telldir(/* DIR *dirp */);
#endif	/* POSIX_SOURCE */
extern	void rewinddir(/* DIR *dirp */);

#ifndef	lint
#define	rewinddir(dirp)	seekdir((dirp), (long)0)
#endif
#endif /* not defined for VMS */
a397 3
#if 0
	off_t		d_off;		/* offset of next disk dir entry */
#endif
a398 3
#if 0
	unsigned short	d_reclen;	/* length of this record */
#endif
d429 2
a430 1
char DirEntry[256];
d441 1
a441 1
   strcpy(UnixEntry,dirname);
d445 3
a447 1
   strcpy(DirEntry, HTVMS_name("",UnixEntry));
d459 4
a462 3
         strcpy(dir.dirname, DirEntry);
         strcat(dir.dirname, "[000000]");
         strcat(DirEntry,"[000000]000000.dir");
d466 6
a471 6
         char End[256];
         strcpy(End,openbr+1);
         *(openbr+1) = '\0';
         strcat(DirEntry,"000000]");
         strcat(DirEntry,End);
         strcat(DirEntry,".dir");
d477 1
a477 1
      strcat(DirEntry,".dir");
d479 2
d483 1
a483 1
   dirname_desc.dsc$w_length = strlen(DirEntry);
d486 1
a486 1
   dirname_desc.dsc$a_pointer = (char *)&(DirEntry);
d495 3
a497 3
                          &entryname_desc,
                          &(dir.context),
                          0,0,0,0);
d503 2
a504 10
#if 0
   /* now correct dirname, which looks like disk$user:[duns.www.test]multi */
   /* and should look like disk$user:[duns.www.test.multi] */
   closebracket = strchr(dir.dirname,']');
   *closebracket = '.';
   closebracket = strstr(dir.dirname,".dir");
   *closebracket = '\0';
   strcat(dir.dirname,"]");
#endif

d532 3
a534 3
                          &entryname_desc,
                          &(dirp->context),
                          0,0,0,0);
d543 1
a543 1
          space = strchr(VMSentry,' ');
d545 1
a545 1
          space = strchr(VMSentry,';');
d547 1
a547 1
         *space = '\0';
a612 6
#define FILE_BY_NAME 0
#define FILE_BY_TYPE 1
#define FILE_BY_SIZE 2
#define FILE_BY_DATE 3
extern BOOLEAN HTfileSortMethod;  /* specifies the method of sorting */

d621 1
a621 1
        case FILE_BY_SIZE:
d623 1
a623 1
                        if(entry1->size == entry2->size)
d631 3
a633 4
                        break;
        case FILE_BY_TYPE:
                        if(entry1->type && entry2->type) {
                            status = strcasecomp(entry1->type, entry2->type);
d638 1
a638 1
                        return (strcasecomp(entry1->filename,
d640 2
a641 3
                        break;
        case FILE_BY_DATE:
                        if(entry1->date && entry2->date) {
d646 1
a646 1
			        strlen(entry2->date) != 12) {
d655 1
a655 1
			        strcpy(date1, "9999");
d659 1
a659 1
			        strcpy(time1, "00:00");
d664 1
a664 1
			        if (!strcasecomp(month, months[i])) {
d669 1
a669 1
			    sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d674 1
a674 1
			        date1[6] = '0';
d678 1
a678 1
			        strcpy(date2, "9999");
d682 1
a682 1
			        strcpy(time2, "00:00");
d687 1
a687 1
			        if (!strcasecomp(month, months[i])) {
d692 1
a692 1
			    sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d697 1
a697 1
			        date2[6] = '0';
d703 1
a703 1
                            status = strcasecomp(date2, date1);
d708 1
a708 1
                        return (strcasecomp(entry1->filename,
d710 3
a712 4
                        break;
        case FILE_BY_NAME:
        default:
                        return (strcmp(entry1->filename,
d718 1
a718 1
/*						    	HTVMSBrowseDir()
d755 1
a755 1
    VMSEntryInfo *entry_info=0;
a756 1
    extern BOOLEAN no_dotfiles, show_dotfiles;
d759 1
a759 1
    CTRACE(tfp,"HTVMSBrowseDir: Browsing `%s\'\n", pathname);
d768 6
a773 6
    	 (cp=strchr(pathname+1, '/')) == NULL ||
	 *(cp+1) == '\0' ||
	 0==strncmp((cp+1), "000000", 6)) ||
        (dp=HTVMSopendir(pathname)) == NULL) {
        FREE(pathname);
    	return HTLoadError(sink, 403, COULD_NOT_ACCESS_DIR);
d796 1
a796 1
        StrAllocCopy(title, tail);
d804 1
a804 1
        pathname[strlen(pathname)-1] = '\0';
d844 1
a844 1
        FILE * fp;
d848 1
a848 1
        if ((fp = fopen(header,  "r")) != NULL) {
d851 2
a852 2
	        char c = fgetc(fp);
	        if (c == (char)EOF)
d855 2
a856 2
	        switch (c) {
	    	    case '&':
d867 1
a867 1
	        }
d874 1
a874 1
        }
d878 1
a878 4
	relative = (char*) malloc(strlen(tail) + 4);
	if (relative == NULL)
		outofmem(__FILE__, "HTVMSBrowseDir");
	sprintf(relative, "%s/..", tail);
d942 1
a942 1
                continue;
d944 1
a944 1
            entry_info = (VMSEntryInfo *)malloc(sizeof(VMSEntryInfo));
d970 5
a974 5
	        /* strip .DIR part... */
                char *dot;
                dot = strstr(entry_info->filename, ".DIR");
                if (dot)
                   *dot = '\0';
d978 2
a979 2
	        if ((cp = strstr(entry_info->filename, "READ")) == NULL) {
	            cp = entry_info->filename;
d983 1
a983 1
		        cp += 2;
d988 1
a988 1
		        cp = (entry_info->filename +
d991 1
a991 1
		        cp = entry_info->filename;
d998 1
a998 1
		        entry_info->filename[len-2] == '_')
d1005 1
a1005 1
	        char *t = (char *)ctime((CONST time_t *)&file_info.st_ctime);
d1008 1
a1008 1
	        StrAllocCopy(entry_info->date, (t+4));
d1020 1
a1020 1
	        entry_info->size = (unsigned int)file_info.st_size;
d1022 1
a1022 1
	        entry_info->size = 0;
d1027 3
a1029 3
		 CTRACE(tfp,"Adding file to BTree: %s\n",
						      entry_info->filename);
	         HTBTree_add(bt, (VMSEntryInfo *)entry_info);
d1053 2
a1054 2
		             PUTS(entry_info->date);
		             PUTS("  ");
d1063 1
a1063 1
		        PUTC(entry_info->type[i]);
d1065 1
a1065 1
		        PUTC(' ');
d1074 1
a1074 1
                /* Output the size */
d1077 1
a1077 1
		          if(entry_info->size < 1024)
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d3 12
a14 12
 *		VMS Utility Routines
 *
 * AUTHORS:
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	14 Nov 93  MD	Written
 *
 * BUGS:
 *
 *
 */
a16 1
#ifdef VMS
a21 2
#include <HTFTP.h>
#include <HTTCP.h>
a32 1
#include <LYGlobalDefs.h>
a34 1
#include <LYStrings.h>
d36 3
a38 1
BOOL HTVMSFileVersions = FALSE;	/* Include version numbers in listing? */
d41 4
a44 4
    unsigned long BufferLength:16;
    unsigned long ItemCode:16;
    unsigned long BufferAddress:32;
    unsigned long ReturnLengthAddress:32;
d47 2
d50 8
a57 8
 *		CHECKS IF THIS PROCESS IS AUTHORIZED TO ENABLE SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	YES if SYSPRV is authorized
 */
BOOL HTVMS_authSysPrv(void)
d59 17
a75 17
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer[2];

    /* fill Item */
    ItemList[0].BufferLength = sizeof(Buffer);
    ItemList[0].BufferAddress = (unsigned long) Buffer;
    ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
    ItemList[0].ItemCode = JPI$_AUTHPRIV;

    /* terminate list */
    ItemList[1].ItemCode = 0;
    ItemList[1].BufferLength = 0;

    /* call system */
    Result = sys$getjpiw(0, 0, 0, ItemList, 0, 0, 0);
d77 2
a78 2
    if (Result != SS$_NORMAL)
	return (NO);
d80 2
a81 2
    if (Buffer[0] & PRV$M_SYSPRV)
	return (YES);
d83 1
a83 1
    return (NO);
d86 2
d89 8
a96 8
 *		ENABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_enableSysPrv(void)
d98 2
a99 2
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];
d101 9
a109 9
    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(1, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (!(PreviousPrv[0] & PRV$M_SYSPRV)) {
	    CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
	}
    }
d112 2
d115 8
a122 8
 *		DISABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_disableSysPrv(void)
d124 2
a125 2
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];
d127 9
a135 9
    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(0, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (PreviousPrv[0] & PRV$M_SYSPRV) {
	    CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
	}
    }
d138 2
d141 15
a155 14
 *		CHECKS ACCESS TO FILE FOR CERTAIN USER
 * ON ENTRY:
 *	FileName	The file to be accessed
 *	UserName	Name of the user to check access for.
 *			User nobody, represented by "" is given NO for an answer
 *	Method		Name of the method to be chceked
 *
 * ON EXIT:
 *	returns YES if access is allowed
 *
 */
BOOL HTVMS_checkAccess(const char *FileName,
		       const char *UserName,
		       const char *Method)
d157 57
a213 56
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer;
    unsigned long ObjType;

    char *VmsName;

    struct dsc$descriptor_s FileNameDesc;
    struct dsc$descriptor_s UserNameDesc;

    char *colon;

    /* user nobody should access as from account under which server is running */
    if (0 == strcmp(UserName, ""))
	return (NO);

    /* check Filename and convert */
    colon = strchr(FileName, ':');
    if (colon)
	VmsName = HTVMS_name("", colon + 1);
    else
	VmsName = HTVMS_name("", FileName);

    /* check for GET */
    if (0 == strcmp(Method, "GET")) {
	/* fill Item */
	ItemList[0].BufferLength = sizeof(Buffer);
	ItemList[0].BufferAddress = (unsigned long) &Buffer;
	ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
	ItemList[0].ItemCode = CHP$_FLAGS;

	/* terminate list */
	ItemList[1].ItemCode = 0;
	ItemList[1].BufferLength = 0;

	/* fill input */
	ObjType = ACL$C_FILE;
	Buffer = CHP$M_READ;
	UserNameDesc.dsc$w_length = strlen(UserName);
	UserNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	UserNameDesc.dsc$b_class = DSC$K_CLASS_S;
	UserNameDesc.dsc$a_pointer = (char *) UserName;
	FileNameDesc.dsc$w_length = strlen(VmsName);
	FileNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	FileNameDesc.dsc$b_class = DSC$K_CLASS_S;
	FileNameDesc.dsc$a_pointer = VmsName;

	/* call system */
	Result = sys$check_access(&ObjType, &FileNameDesc, &UserNameDesc, ItemList);

	if (Result == SS$_NORMAL)
	    return (YES);
	else
	    return (NO);
    }
d215 1
a215 1
    return (NO);
d218 2
d221 26
a246 25
 *		CONVERTS VMS Name into WWW Name
 * ON ENTRY:
 *	vmsname		VMS file specification (NO NODE)
 *
 * ON EXIT:
 *	returns		www file specification
 *
 * EXAMPLES:
 *	vmsname				wwwname
 *	DISK$USER			disk$user
 *	DISK$USER:			/disk$user/
 *	DISK$USER:[DUNS]		/disk$user/duns
 *	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
 *	[DUNS]				duns
 *	[DUNS.ECHO]			duns/echo
 *	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
 *	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
 *	[.DUNS]				duns
 *	[.DUNS.ECHO]			duns/echo
 *	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
 *	TEST.COM			test.com
 *
 *
 */
const char *HTVMS_wwwName(const char *vmsname)
d248 49
a296 58
    static char wwwname[LY_MAXPATH];
    const char *src;
    char *dst;
    int dir;

    dst = wwwname;
    src = vmsname;
    dir = 0;
    if (strchr(src, ':'))
	*(dst++) = '/';
    for (; *src != '\0'; src++) {
	switch (*src) {
	case ':':
	    *(dst++) = '/';
	    break;
	case '-':
	    if (dir) {
		if ((*(src - 1) == '[' ||
		     *(src - 1) == '.' ||
		     *(src - 1) == '-') &&
		    (*(src + 1) == '.' ||
		     *(src + 1) == '-')) {
		    *(dst++) = '/';
		    *(dst++) = '.';
		    *(dst++) = '.';
		} else
		    *(dst++) = '-';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '-';
	    }
	    break;
	case '.':
	    if (dir) {
		if (*(src - 1) != '[')
		    *(dst++) = '/';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '.';
	    }
	    break;
	case '[':
	    dir = 1;
	    break;
	case ']':
	    dir = 0;
	    break;
	default:
	    if (*(src - 1) == ']')
		*(dst++) = '/';
	    *(dst++) = *src;
	    break;
	}
    }
    *(dst++) = '\0';
    return (wwwname);
d299 15
a313 6
/*
 *	The code below is for directory browsing by VMS Curses clients.
 *	It is based on the newer WWWLib's HTDirBrw.c. - Foteos Macrides
 */
int HTStat(const char *filename,
	   struct stat *info)
d315 31
a345 30
    /*
       the following stuff does not work in VMS with a normal stat...
       -->   /disk$user/duns/www if www is a directory
       is statted like:  /disk$user/duns/www.dir
       after a normal stat has failed
       -->   /disk$user/duns     if duns is a toplevel directory
       is statted like:  /disk$user/000000/duns.dir
       -->   /disk$user since disk$user is a device
       is statted like:  /disk$user/000000/000000.dir
       -->   /
       searches all devices, no solution yet...
       -->   /vxcern!/disk$cr/wwwteam/login.com
       is not statted but granted with fake information...
     */
    int Result;
    int Len;
    char *Ptr, *Ptr2;
    static char *Name;

    /* try normal stat... */
    Result = stat((char *) filename, info);
    if (Result == 0)
	return (Result);

    /* make local copy */
    StrAllocCopy(Name, filename);

    /* failed,so do device search in case root is requested */
    if (!strcmp(Name, "/")) {	/* root requested */
	return (-1);
d348 2
a349 10
    /* failed so this might be a directory, add '.dir' */
    Len = strlen(Name);
    if (Name[Len - 1] == '/')
	Name[Len - 1] = '\0';

    /* fail in case of device */
    Ptr = strchr(Name + 1, '/');
    if ((Ptr == NULL) && (Name[0] == '/')) {	/* device only... */
	StrAllocCat(Name, "/000000/000000");
    }
d351 15
a365 10
    if (Ptr != NULL) {		/* correct filename in case of toplevel dir */
	Ptr2 = strchr(Ptr + 1, '/');
	if ((Ptr2 == NULL) && (Name[0] == '/')) {
	    char End[256];

	    LYstrncpy(End, Ptr, sizeof(End) - 1);
	    *(Ptr + 1) = '\0';
	    StrAllocCat(Name, "000000");
	    StrAllocCat(Name, End);
	}
d367 4
d372 100
a471 9
    /* try in case a file on toplevel directory or .DIR was already specified */
    Result = stat(Name, info);
    if (Result == 0)
	return (Result);

    /* add .DIR and try again */
    StrAllocCat(Name, ".dir");
    Result = stat(Name, info);
    return (Result);
d479 1
a479 1
#endif /* !_POSIX_SOURCE */
d481 12
a492 4
typedef struct __dirdesc {
    long context;		/* context descriptor for LIB$FIND_FILE calls */
    char dirname[255 + 1];	/* keeps the directory name, including *.* */
    struct dsc$descriptor_s dirname_desc;	/* descriptor of dirname */
d495 14
a508 3
static DIR *HTVMSopendir(char *dirname);
static struct dirent *HTVMSreaddir(DIR *dirp);
static int HTVMSclosedir(DIR *dirp);
d512 10
a521 4
struct dirent {
    unsigned long d_fileno;	/* file number of entry */
    unsigned short d_namlen;	/* length of string in d_name */
    char d_name[255 + 1];	/* name (up to MAXNAMLEN + 1) */
d540 2
a541 1
#endif /* !_POSIX_SOURCE */
d543 1
a543 1
static DIR *HTVMSopendir(char *dirname)
d545 82
a626 53
    static DIR dir;
    char *closebracket;
    long status;
    struct dsc$descriptor_s entryname_desc;
    struct dsc$descriptor_s dirname_desc;
    static char *DirEntry;
    char Actual[256];
    char VMSentry[256];
    char UnixEntry[256];
    int index;
    char *dot;

    /* check if directory exists */
    /* dirname can look like /disk$user/duns/www/test/multi    */
    /* or like               /disk$user/duns/www/test/multi/   */
    /* DirEntry should look like     disk$user:[duns.www.test]multi in both cases */
    /* dir.dirname should look like  disk$user:[duns.www.test.multi] */
    sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
    if (UnixEntry[strlen(UnixEntry) - 1] != '/')
	strcat(UnixEntry, "/");

    StrAllocCopy(DirEntry, HTVMS_name("", UnixEntry));
    if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
	return (NULL);
    strcpy(dir.dirname, DirEntry);
    index = strlen(DirEntry) - 1;

    if (DirEntry[index] == ']')
	DirEntry[index] = '\0';

    if ((dot = strrchr(DirEntry, '.')) == NULL) {	/* convert disk$user:[duns] into disk$user:[000000]duns.dir */
	char *openbr = strrchr(DirEntry, '[');

	if (!openbr) {		/* convert disk$user: into disk$user:[000000]000000.dir */
	    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
		return (NULL);
	    sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	    StrAllocCat(DirEntry, "[000000]000000.dir");
	} else {
	    char End[256];

	    strcpy(End, openbr + 1);
	    *(openbr + 1) = '\0';
	    StrAllocCat(DirEntry, "000000]");
	    StrAllocCat(DirEntry, End);
	    StrAllocCat(DirEntry, ".dir");
	}
    } else {
	*dot = ']';
	StrAllocCat(DirEntry, ".dir");
    }
    /* lib$find_file needs a fixed-size buffer */
    LYstrncpy(Actual, DirEntry, sizeof(Actual) - 1);
d628 10
a637 32
    dir.context = 0;
    dirname_desc.dsc$w_length = strlen(Actual);
    dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dirname_desc.dsc$a_pointer = (char *) &(Actual);

    /* look for the directory */
    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirname_desc),
			   &entryname_desc,
			   &(dir.context),
			   0, 0, 0, 0);
    if (!(status & 0x01)) {	/* directory not found */
	return (NULL);
    }

    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
	return (NULL);
    if (HTVMSFileVersions)
	strcat(dir.dirname, "*.*;*");
    else
	strcat(dir.dirname, "*.*");
    dir.context = 0;
    dir.dirname_desc.dsc$w_length = strlen(dir.dirname);
    dir.dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dir.dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dir.dirname_desc.dsc$a_pointer = (char *) &(dir.dirname);
    return (&dir);
d640 1
a640 1
static struct dirent *HTVMSreaddir(DIR *dirp)
d642 38
a679 36
    static struct dirent entry;
    long status;
    struct dsc$descriptor_s entryname_desc;
    char *space, *slash;
    char VMSentry[256];
    const char *UnixEntry;

    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirp->dirname_desc),
			   &entryname_desc,
			   &(dirp->context),
			   0, 0, 0, 0);
    if (status == RMS$_NMF) {	/* no more files */
	return (NULL);
    } else {			/* ok */
	if (!(status & 0x01))
	    return (0);
	if (HTVMSFileVersions)
	    space = strchr(VMSentry, ' ');
	else
	    space = strchr(VMSentry, ';');
	if (space)
	    *space = '\0';

	/* convert to unix style... */
	UnixEntry = HTVMS_wwwName(VMSentry);
	slash = strrchr(UnixEntry, '/') + 1;
	strcpy(entry.d_name, slash);
	entry.d_namlen = strlen(entry.d_name);
	entry.d_fileno = 1;
	return (&entry);
    }
d682 1
a682 1
static int HTVMSclosedir(DIR *dirp)
d684 1
a684 1
    long status;
d686 4
a689 5
    status = lib$find_file_end(&(dirp->context));
    if (!(status & 0x01))
	exit_immediately(status);
    dirp->context = 0;
    return (0);
d695 1
a695 1
#include <HTFile.h>		/* For HTFileFormat() */
d698 2
a699 2
 *  Hypertext object building machinery.
 */
d708 2
a709 2
    const HTStructuredClass *isa;
    /* ... */
d714 2
a715 4
static char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
d719 3
a721 3
    char *filename;
    char *type;
    char *date;
d723 1
a723 1
    BOOLEAN display;		/* show this entry? */
d726 1
a726 1
static void free_VMSEntryInfo_contents(VMSEntryInfo * entry_info)
d733 1
a733 1
    /* dont free the struct */
d736 8
a743 1
int compare_VMSEntryInfo_structs(VMSEntryInfo * entry1, VMSEntryInfo * entry2)
d748 99
a846 94
    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size == entry2->size)
	    return (strcasecomp(entry1->filename,
				entry2->filename));
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_DATE:
	if (entry1->date && entry2->date) {
	    /*
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 ||
		strlen(entry2->date) != 12) {
		return (strcasecomp(entry1->filename,
				    entry2->filename));
	    }
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[7] != ' ') {
		strcpy(date1, "9999");
		strcpy(time1, (char *) &entry1->date[7]);
	    } else {
		strcpy(date1, (char *) &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    strncat(date1, (char *) &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ') {
		date1[6] = '0';
	    }
	    strcat(date1, time1);
	    if (entry2->date[7] != ' ') {
		strcpy(date2, "9999");
		strcpy(time2, (char *) &entry2->date[7]);
	    } else {
		strcpy(date2, (char *) &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    strncat(date2, (char *) &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ') {
		date2[6] = '0';
	    }
	    strcat(date2, time2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_NAME:
    default:
	return (strcmp(entry1->filename,
		       entry2->filename));
    }
d849 23
a871 20
/*							HTVMSBrowseDir()
 *
 *	This function generates a directory listing as an HTML-object
 *	for local file URL's.  It assumes the first two elements of
 *	of the path are a device followed by a directory:
 *
 *		file://localhost/device/directory[/[foo]]
 *
 *	Will not accept 000000 as a directory name.
 *	Will offer links to parent through the top directory, unless
 *	a terminal slash was included in the calling URL.
 *
 *	Returns HT_LOADED on success, HTLoadError() messages on error.
 *
 *	Developed for Lynx by Foteos Macrides (macrides@@sci.wfeb.edu).
 */
int HTVMSBrowseDir(const char *address,
		   HTParentAnchor *anchor,
		   HTFormat format_out,
		   HTStream *sink)
d873 1
a873 1
    HTStructured *target;
d882 1
a882 1
    int pathend, len;
d887 1
a887 1
    VMSEntryInfo *entry_info = 0;
d889 1
d892 1
a892 1
    CTRACE((tfp, "HTVMSBrowseDir: Browsing `%s\'\n", pathname));
d895 4
a898 4
     * Require at least two elements (presumably a device and directory) and
     * disallow the device root (000000 directory).  Symbolic paths (e.g.,
     * sys$help) should have been translated and expanded (e.g., to
     * /sys$sysroot/syshlp) before calling this routine.
d901 6
a906 6
	 (cp = strchr(pathname + 1, '/')) == NULL ||
	 *(cp + 1) == '\0' ||
	 0 == strncmp((cp + 1), "000000", 6)) ||
	(dp = HTVMSopendir(pathname)) == NULL) {
	FREE(pathname);
	return HTLoadError(sink, 403, COULD_NOT_ACCESS_DIR);
d910 1
a910 1
     * Set up the output stream.
d912 1
a912 1
    _HTProgress(BUILDING_DIR_LIST);
d923 2
a924 2
     * Set up the offset string of the anchor reference, and strings for the
     * title and header.
d926 2
a927 2
    cp = strrchr(pathname, '/');	/* find lastslash */
    StrAllocCopy(tail, (cp + 1));	/* take slash off the beginning */
d929 1
a929 1
	StrAllocCopy(title, tail);
d931 1
a931 1
	if ((cp1 = strrchr(pathname, '/')) != NULL &&
d933 2
a934 2
	    strncmp((cp1 + 1), "000000", 6))
	    StrAllocCopy(parent, (cp1 + 1));
d937 1
a937 1
	pathname[strlen(pathname) - 1] = '\0';
d939 1
a939 1
	StrAllocCopy(title, (cp + 1));
d945 1
a945 1
     * Initialize path name for HTStat().
d948 1
a948 1
    if (*(pathname + pathend - 1) != '/') {
d954 1
a954 1
     * Output the title and header.
d977 2
a978 3
	FILE *fp;

	if (header[strlen(header) - 1] != '/')
d981 1
a981 1
	if ((fp = fopen(header, "r")) != NULL) {
d983 3
a985 4
	    for (;;) {
		char c = fgetc(fp);

		if (c == (char) EOF)
d988 13
a1000 13
		switch (c) {
		case '&':
		case '<':
		case '>':
		    PUTC('&');
		    PUTC('#');
		    PUTC((char) (c / 10));
		    PUTC((char) (c % 10));
		    PUTC(';');
		    break;
		default:
		    PUTC(c);
		}
d1007 1
a1007 1
	}
d1011 4
a1014 1
	HTSprintf0(&relative, "%s/..", tail);
d1027 1
a1027 1
     * Set up the date comparison.
d1030 1
a1030 1
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
d1050 1
a1050 1
	    if (!dirbuf->d_ino) {
d1073 1
a1073 1
	    *(pathname + pathend) = '\0';
d1078 1
a1078 1
		continue;
d1080 1
a1080 1
	    entry_info = (VMSEntryInfo *) malloc(sizeof(VMSEntryInfo));
d1091 1
a1091 1
				  (const char **) &cp);
d1093 2
a1094 1
		if (!strncmp(HTAtom_name(format), "application", 11)) {
d1096 1
a1096 1
		    if (!strncmp(cp, "x-", 2))
d1098 2
a1099 1
		} else
d1106 5
a1110 6
		/* strip .DIR part... */
		char *dot;

		dot = strstr(entry_info->filename, ".DIR");
		if (dot)
		    *dot = '\0';
d1114 2
a1115 2
		if ((cp = strstr(entry_info->filename, "READ")) == NULL) {
		    cp = entry_info->filename;
d1119 1
a1119 1
			cp += 2;
d1124 1
a1124 1
			cp = (entry_info->filename +
d1127 1
a1127 1
			cp = entry_info->filename;
d1132 4
a1135 4
		    entry_info->filename[len - 1] == 'z') {
		    if (entry_info->filename[len - 2] == '.' ||
			entry_info->filename[len - 2] == '_')
			entry_info->filename[len - 1] = 'Z';
d1141 2
a1142 3
		char *t = (char *) ctime((const time_t *) &file_info.st_ctime);

		*(t + 24) = '\0';
d1144 4
a1147 4
		StrAllocCopy(entry_info->date, (t + 4));
		*((entry_info->date) + 7) = '\0';
		if ((atoi((t + 19))) < atoi(ThisYear))
		    StrAllocCat(entry_info->date, (t + 19));
d1149 2
a1150 2
		    StrAllocCat(entry_info->date, (t + 11));
		    *((entry_info->date) + 12) = '\0';
d1156 1
a1156 1
		entry_info->size = (unsigned int) file_info.st_size;
d1158 1
a1158 1
		entry_info->size = 0;
d1161 6
a1166 5
	    if (entry_info->display) {
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
	    }
d1168 1
a1168 1
	}			/* End while HTVMSreaddir() */
d1178 1
a1178 1
	    HTBTElement *ele;
a1179 1

d1182 3
a1184 2
		 ele = HTBTree_next(bt, ele)) {
		entry_info = (VMSEntryInfo *) HTBTree_object(ele);
d1187 7
a1193 5
		if (entry_info->date) {
		    PUTS(entry_info->date);
		    PUTS("  ");
		} else
		    PUTS("     * ");
d1196 6
a1201 5
		if (entry_info->type) {
		    for (i = 0; entry_info->type[i] != '\0' && i < 15; i++)
			PUTC(entry_info->type[i]);
		    for (; i < 17; i++)
			PUTC(' ');
d1203 1
a1203 1
		}
d1210 11
a1220 10
		/* Output the size */
		if (entry_info->size) {
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %d bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "  %dKb",
				entry_info->size / 1024);
		    PUTS(string_buffer);
		}
d1222 1
a1222 1
		PUTC('\n');	/* end of this entry */
d1230 1
a1230 1
    }				/* End of both BTree loops */
d1233 1
a1233 1
     * Complete the output stream.
d1246 1
a1246 1
}				/* End of directory reading section */
d1255 2
a1256 2

    while (remove(filename) == 0) ;
d1274 2
a1275 1
    while (remove(older_file) == 0) ;
a1288 1
#endif /* VMS */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a21 2
#include <HTFTP.h>
#include <HTTCP.h>
a32 1
#include <LYGlobalDefs.h>
a34 1
#include <LYStrings.h>
d36 3
a38 1
PUBLIC BOOL HTVMSFileVersions = FALSE; /* Include version numbers in listing? */
d47 2
d107 1
a107 1
	   CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
d133 1
a133 1
	   CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
d210 1
a210 1
	return(YES);
d212 1
a212 1
	return(NO);
d226 1
a226 1
**	returns		www file specification
d230 12
a241 12
**	DISK$USER			disk$user
**	DISK$USER:			/disk$user/
**	DISK$USER:[DUNS]		/disk$user/duns
**	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
**	[DUNS]				duns
**	[DUNS.ECHO]			duns/echo
**	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
**	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
**	[.DUNS]				duns
**	[.DUNS.ECHO]			duns/echo
**	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
**	TEST.COM			test.com
d246 1
a246 1
	CONST char *,	vmsname)
d248 2
a249 3
static char wwwname[LY_MAXPATH];
CONST char *src;
char *dst;
d259 5
a263 5
	 case ':':  *(dst++) = '/'; break;
	 case '-': if (dir)
		   {
		      if ((*(src-1)=='[' || *(src-1)=='.' || *(src-1)=='-') &&
			  (*(src+1)=='.' || *(src+1)=='-'))
d265 3
a267 3
			  *(dst++) = '/';
			  *(dst++) = '.';
			  *(dst++) = '.';
d270 1
a270 1
			  *(dst++) = '-';
d277 6
a282 6
		   break;
	 case '.': if (dir)
		   {
		      if (*(src-1) != '[') *(dst++) = '/';
		   }
		   else
d285 1
a285 1
		      *(dst++) = '.';
d287 6
a292 6
		   break;
	 case '[': dir = 1; break;
	 case ']': dir = 0; break;
	 default:  if (*(src-1) == ']') *(dst++) = '/';
		   *(dst++) = *src;
		   break;
d300 72
d383 1
a383 1
		is statted like:	/disk$user/duns/www.dir
d397 1
a397 1
static char *Name;
d405 26
a430 1
   StrAllocCopy(Name,filename);
d447 1
a447 1
      StrAllocCat(Name, "/000000/000000");
d455 5
a459 5
	 char End[256];
	 LYstrncpy(End, Ptr, sizeof(End) - 1);
	 *(Ptr+1) = '\0';
	 StrAllocCat(Name, "000000");
	 StrAllocCat(Name, End);
d463 1
a463 1
   /* try in case a file on toplevel directory or .DIR was already specified */
d469 1
a469 1
   StrAllocCat(Name, ".dir");
d482 9
a490 1
	long	context;	/* context descriptor for LIB$FIND_FILE calls */
d498 11
d513 3
d517 3
d550 1
a550 2
static char *DirEntry;
char Actual[256];
d561 1
a561 1
   sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
d565 1
a565 3
   StrAllocCopy(DirEntry, HTVMS_name("",UnixEntry));
   if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
      return (NULL);
d577 3
a579 4
         if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
            return (NULL);
         sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	 StrAllocCat(DirEntry,"[000000]000000.dir");
d583 6
a588 6
	 char End[256];
	 strcpy(End,openbr+1);
	 *(openbr+1) = '\0';
	 StrAllocCat(DirEntry,"000000]");
	 StrAllocCat(DirEntry,End);
	 StrAllocCat(DirEntry,".dir");
d594 1
a594 1
      StrAllocCat(DirEntry,".dir");
a595 2
   /* lib$find_file needs a fixed-size buffer */
   LYstrncpy(Actual, DirEntry, sizeof(Actual)-1);
d598 1
a598 1
   dirname_desc.dsc$w_length = strlen(Actual);
d601 1
a601 1
   dirname_desc.dsc$a_pointer = (char *)&(Actual);
d610 3
a612 3
			  &entryname_desc,
			  &(dir.context),
			  0,0,0,0);
d618 10
a627 2
   if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
       return (NULL);
d655 3
a657 3
			  &entryname_desc,
			  &(dirp->context),
			  0,0,0,0);
d666 1
a666 1
	  space = strchr(VMSentry,' ');
d668 1
a668 1
	  space = strchr(VMSentry,';');
d670 1
a670 1
	 *space = '\0';
d736 6
d750 1
a750 1
	case FILE_BY_SIZE:
d752 1
a752 1
			if(entry1->size == entry2->size)
d760 4
a763 3
	case FILE_BY_TYPE:
			if(entry1->type && entry2->type) {
			    status = strcasecomp(entry1->type, entry2->type);
d768 1
a768 1
			return (strcasecomp(entry1->filename,
d770 3
a772 2
	case FILE_BY_DATE:
			if(entry1->date && entry2->date) {
d777 1
a777 1
				strlen(entry2->date) != 12) {
d786 1
a786 1
				strcpy(date1, "9999");
d790 1
a790 1
				strcpy(time1, "00:00");
d795 1
a795 1
				if (!strcasecomp(month, months[i])) {
d800 1
a800 1
			    sprintf(month, "%02d", i);
d805 1
a805 1
				date1[6] = '0';
d809 1
a809 1
				strcpy(date2, "9999");
d813 1
a813 1
				strcpy(time2, "00:00");
d818 1
a818 1
				if (!strcasecomp(month, months[i])) {
d823 1
a823 1
			    sprintf(month, "%02d", i);
d828 1
a828 1
				date2[6] = '0';
d834 1
a834 1
			    status = strcasecomp(date2, date1);
d839 1
a839 1
			return (strcasecomp(entry1->filename,
d841 4
a844 3
	case FILE_BY_NAME:
	default:
			return (strcmp(entry1->filename,
d850 1
a850 1
/*							HTVMSBrowseDir()
d887 1
a887 1
    VMSEntryInfo *entry_info = 0;
d889 1
d892 1
a892 1
    CTRACE((tfp,"HTVMSBrowseDir: Browsing `%s\'\n", pathname));
d901 6
a906 6
	 (cp = strchr(pathname+1, '/')) == NULL ||
	 *(cp + 1) == '\0' ||
	 0 == strncmp((cp + 1), "000000", 6)) ||
	(dp = HTVMSopendir(pathname)) == NULL) {
	FREE(pathname);
	return HTLoadError(sink, 403, COULD_NOT_ACCESS_DIR);
d929 1
a929 1
	StrAllocCopy(title, tail);
d937 1
a937 1
	pathname[strlen(pathname)-1] = '\0';
d977 1
a977 1
	FILE * fp;
d981 1
a981 1
	if ((fp = fopen(header,	 "r")) != NULL) {
d984 2
a985 2
		char c = fgetc(fp);
		if (c == (char)EOF)
d988 2
a989 2
		switch (c) {
		    case '&':
d1000 1
a1000 1
		}
d1007 1
a1007 1
	}
d1011 4
a1014 1
	HTSprintf0(&relative, "%s/..", tail);
d1078 1
a1078 1
		continue;
d1080 1
a1080 1
	    entry_info = (VMSEntryInfo *)malloc(sizeof(VMSEntryInfo));
d1106 5
a1110 5
		/* strip .DIR part... */
		char *dot;
		dot = strstr(entry_info->filename, ".DIR");
		if (dot)
		   *dot = '\0';
d1114 2
a1115 2
		if ((cp = strstr(entry_info->filename, "READ")) == NULL) {
		    cp = entry_info->filename;
d1119 1
a1119 1
			cp += 2;
d1124 1
a1124 1
			cp = (entry_info->filename +
d1127 1
a1127 1
			cp = entry_info->filename;
d1134 1
a1134 1
			entry_info->filename[len-2] == '_')
d1141 1
a1141 1
		char *t = (char *)ctime((CONST time_t *)&file_info.st_ctime);
d1144 1
a1144 1
		StrAllocCopy(entry_info->date, (t+4));
d1156 1
a1156 1
		entry_info->size = (unsigned int)file_info.st_size;
d1158 1
a1158 1
		entry_info->size = 0;
d1163 3
a1165 3
		 CTRACE((tfp,"Adding file to BTree: %s\n",
						      entry_info->filename));
		 HTBTree_add(bt, entry_info);
d1189 2
a1190 2
			     PUTS(entry_info->date);
			     PUTS("  ");
d1199 1
a1199 1
			PUTC(entry_info->type[i]);
d1201 1
a1201 1
			PUTC(' ');
d1210 1
a1210 1
		/* Output the size */
d1213 1
a1213 1
			  if(entry_info->size < 1024)
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d40 1
a40 1
BOOL HTVMSFileVersions = FALSE; /* Include version numbers in listing? */
d57 1
a57 1
BOOL HTVMS_authSysPrv (void)
d96 1
a96 1
void HTVMS_enableSysPrv (void)
d122 1
a122 1
void HTVMS_disableSysPrv (void)
d152 4
a155 4
BOOL HTVMS_checkAccess (
	const char * FileName,
	const char * UserName,
	const char * Method)
d245 2
a246 1
char * HTVMS_wwwName (const char *	vmsname)
d249 1
a249 1
const char *src;
d305 3
a307 3
int HTStat (
	const char * filename,
	struct stat * info)
d391 3
a393 3
static	DIR *HTVMSopendir(char *dirname);
static	struct dirent *HTVMSreaddir(DIR *dirp);
static	int HTVMSclosedir(DIR *dirp);
d422 1
a422 1
static DIR *HTVMSopendir(char *dirname)
d517 1
a517 1
static struct dirent *HTVMSreaddir(DIR *dirp)
d559 1
a559 1
static int HTVMSclosedir(DIR *dirp)
d585 1
a585 1
	const HTStructuredClass *	isa;
d591 1
a591 1
static char * months[12] = {
d603 1
a603 1
static void free_VMSEntryInfo_contents (VMSEntryInfo * entry_info)
d613 2
a614 2
int compare_VMSEntryInfo_structs (VMSEntryInfo * entry1,
					      VMSEntryInfo * entry2)
d734 5
a738 5
int HTVMSBrowseDir (
	const char *		address,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink
d955 1
a955 1
				  (const char **)&cp);
d1005 1
a1005 1
		char *t = (char *)ctime((const time_t *)&file_info.st_ctime);
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d3 12
a14 12
 *		VMS Utility Routines
 *
 * AUTHORS:
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	14 Nov 93  MD	Written
 *
 * BUGS:
 *
 *
 */
a16 1
#ifdef VMS
d40 1
a40 1
BOOL HTVMSFileVersions = FALSE;	/* Include version numbers in listing? */
d43 4
a46 4
    unsigned long BufferLength:16;
    unsigned long ItemCode:16;
    unsigned long BufferAddress:32;
    unsigned long ReturnLengthAddress:32;
d50 8
a57 8
 *		CHECKS IF THIS PROCESS IS AUTHORIZED TO ENABLE SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	YES if SYSPRV is authorized
 */
BOOL HTVMS_authSysPrv(void)
d59 17
a75 17
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer[2];

    /* fill Item */
    ItemList[0].BufferLength = sizeof(Buffer);
    ItemList[0].BufferAddress = (unsigned long) Buffer;
    ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
    ItemList[0].ItemCode = JPI$_AUTHPRIV;

    /* terminate list */
    ItemList[1].ItemCode = 0;
    ItemList[1].BufferLength = 0;

    /* call system */
    Result = sys$getjpiw(0, 0, 0, ItemList, 0, 0, 0);
d77 2
a78 2
    if (Result != SS$_NORMAL)
	return (NO);
d80 2
a81 2
    if (Buffer[0] & PRV$M_SYSPRV)
	return (YES);
d83 1
a83 1
    return (NO);
d86 2
d89 8
a96 8
 *		ENABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_enableSysPrv(void)
d98 2
a99 2
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];
d101 9
a109 9
    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(1, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (!(PreviousPrv[0] & PRV$M_SYSPRV)) {
	    CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
	}
    }
d112 2
d115 8
a122 8
 *		DISABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_disableSysPrv(void)
d124 2
a125 2
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];
d127 9
a135 9
    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(0, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (PreviousPrv[0] & PRV$M_SYSPRV) {
	    CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
	}
    }
d138 2
d141 15
a155 14
 *		CHECKS ACCESS TO FILE FOR CERTAIN USER
 * ON ENTRY:
 *	FileName	The file to be accessed
 *	UserName	Name of the user to check access for.
 *			User nobody, represented by "" is given NO for an answer
 *	Method		Name of the method to be chceked
 *
 * ON EXIT:
 *	returns YES if access is allowed
 *
 */
BOOL HTVMS_checkAccess(const char *FileName,
		       const char *UserName,
		       const char *Method)
d157 57
a213 56
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer;
    unsigned long ObjType;

    char *VmsName;

    struct dsc$descriptor_s FileNameDesc;
    struct dsc$descriptor_s UserNameDesc;

    char *colon;

    /* user nobody should access as from account under which server is running */
    if (0 == strcmp(UserName, ""))
	return (NO);

    /* check Filename and convert */
    colon = strchr(FileName, ':');
    if (colon)
	VmsName = HTVMS_name("", colon + 1);
    else
	VmsName = HTVMS_name("", FileName);

    /* check for GET */
    if (0 == strcmp(Method, "GET")) {
	/* fill Item */
	ItemList[0].BufferLength = sizeof(Buffer);
	ItemList[0].BufferAddress = (unsigned long) &Buffer;
	ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
	ItemList[0].ItemCode = CHP$_FLAGS;

	/* terminate list */
	ItemList[1].ItemCode = 0;
	ItemList[1].BufferLength = 0;

	/* fill input */
	ObjType = ACL$C_FILE;
	Buffer = CHP$M_READ;
	UserNameDesc.dsc$w_length = strlen(UserName);
	UserNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	UserNameDesc.dsc$b_class = DSC$K_CLASS_S;
	UserNameDesc.dsc$a_pointer = (char *) UserName;
	FileNameDesc.dsc$w_length = strlen(VmsName);
	FileNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	FileNameDesc.dsc$b_class = DSC$K_CLASS_S;
	FileNameDesc.dsc$a_pointer = VmsName;

	/* call system */
	Result = sys$check_access(&ObjType, &FileNameDesc, &UserNameDesc, ItemList);

	if (Result == SS$_NORMAL)
	    return (YES);
	else
	    return (NO);
    }
d215 1
a215 1
    return (NO);
d218 2
d221 25
a245 25
 *		CONVERTS VMS Name into WWW Name
 * ON ENTRY:
 *	vmsname		VMS file specification (NO NODE)
 *
 * ON EXIT:
 *	returns		www file specification
 *
 * EXAMPLES:
 *	vmsname				wwwname
 *	DISK$USER			disk$user
 *	DISK$USER:			/disk$user/
 *	DISK$USER:[DUNS]		/disk$user/duns
 *	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
 *	[DUNS]				duns
 *	[DUNS.ECHO]			duns/echo
 *	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
 *	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
 *	[.DUNS]				duns
 *	[.DUNS.ECHO]			duns/echo
 *	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
 *	TEST.COM			test.com
 *
 *
 */
const char *HTVMS_wwwName(const char *vmsname)
d247 50
a296 58
    static char wwwname[LY_MAXPATH];
    const char *src;
    char *dst;
    int dir;

    dst = wwwname;
    src = vmsname;
    dir = 0;
    if (strchr(src, ':'))
	*(dst++) = '/';
    for (; *src != '\0'; src++) {
	switch (*src) {
	case ':':
	    *(dst++) = '/';
	    break;
	case '-':
	    if (dir) {
		if ((*(src - 1) == '[' ||
		     *(src - 1) == '.' ||
		     *(src - 1) == '-') &&
		    (*(src + 1) == '.' ||
		     *(src + 1) == '-')) {
		    *(dst++) = '/';
		    *(dst++) = '.';
		    *(dst++) = '.';
		} else
		    *(dst++) = '-';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '-';
	    }
	    break;
	case '.':
	    if (dir) {
		if (*(src - 1) != '[')
		    *(dst++) = '/';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '.';
	    }
	    break;
	case '[':
	    dir = 1;
	    break;
	case ']':
	    dir = 0;
	    break;
	default:
	    if (*(src - 1) == ']')
		*(dst++) = '/';
	    *(dst++) = *src;
	    break;
	}
    }
    *(dst++) = '\0';
    return (wwwname);
d299 1
d301 6
a306 5
 *	The code below is for directory browsing by VMS Curses clients.
 *	It is based on the newer WWWLib's HTDirBrw.c. - Foteos Macrides
 */
int HTStat(const char *filename,
	   struct stat *info)
d308 67
a374 64
    /*
       the following stuff does not work in VMS with a normal stat...
       -->   /disk$user/duns/www if www is a directory
       is statted like:  /disk$user/duns/www.dir
       after a normal stat has failed
       -->   /disk$user/duns     if duns is a toplevel directory
       is statted like:  /disk$user/000000/duns.dir
       -->   /disk$user since disk$user is a device
       is statted like:  /disk$user/000000/000000.dir
       -->   /
       searches all devices, no solution yet...
       -->   /vxcern!/disk$cr/wwwteam/login.com
       is not statted but granted with fake information...
     */
    int Result;
    int Len;
    char *Ptr, *Ptr2;
    static char *Name;

    /* try normal stat... */
    Result = stat((char *) filename, info);
    if (Result == 0)
	return (Result);

    /* make local copy */
    StrAllocCopy(Name, filename);

    /* failed,so do device search in case root is requested */
    if (!strcmp(Name, "/")) {	/* root requested */
	return (-1);
    }

    /* failed so this might be a directory, add '.dir' */
    Len = strlen(Name);
    if (Name[Len - 1] == '/')
	Name[Len - 1] = '\0';

    /* fail in case of device */
    Ptr = strchr(Name + 1, '/');
    if ((Ptr == NULL) && (Name[0] == '/')) {	/* device only... */
	StrAllocCat(Name, "/000000/000000");
    }

    if (Ptr != NULL) {		/* correct filename in case of toplevel dir */
	Ptr2 = strchr(Ptr + 1, '/');
	if ((Ptr2 == NULL) && (Name[0] == '/')) {
	    char End[256];

	    LYstrncpy(End, Ptr, sizeof(End) - 1);
	    *(Ptr + 1) = '\0';
	    StrAllocCat(Name, "000000");
	    StrAllocCat(Name, End);
	}
    }

    /* try in case a file on toplevel directory or .DIR was already specified */
    Result = stat(Name, info);
    if (Result == 0)
	return (Result);

    /* add .DIR and try again */
    StrAllocCat(Name, ".dir");
    Result = stat(Name, info);
    return (Result);
d382 1
a382 1
#endif /* !_POSIX_SOURCE */
d384 4
a387 4
typedef struct __dirdesc {
    long context;		/* context descriptor for LIB$FIND_FILE calls */
    char dirname[255 + 1];	/* keeps the directory name, including *.* */
    struct dsc$descriptor_s dirname_desc;	/* descriptor of dirname */
d390 3
a392 3
static DIR *HTVMSopendir(char *dirname);
static struct dirent *HTVMSreaddir(DIR *dirp);
static int HTVMSclosedir(DIR *dirp);
d396 4
a399 4
struct dirent {
    unsigned long d_fileno;	/* file number of entry */
    unsigned short d_namlen;	/* length of string in d_name */
    char d_name[255 + 1];	/* name (up to MAXNAMLEN + 1) */
d418 2
a419 1
#endif /* !_POSIX_SOURCE */
d423 91
a513 86
    static DIR dir;
    char *closebracket;
    long status;
    struct dsc$descriptor_s entryname_desc;
    struct dsc$descriptor_s dirname_desc;
    static char *DirEntry;
    char Actual[256];
    char VMSentry[256];
    char UnixEntry[256];
    int index;
    char *dot;

    /* check if directory exists */
    /* dirname can look like /disk$user/duns/www/test/multi    */
    /* or like               /disk$user/duns/www/test/multi/   */
    /* DirEntry should look like     disk$user:[duns.www.test]multi in both cases */
    /* dir.dirname should look like  disk$user:[duns.www.test.multi] */
    sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
    if (UnixEntry[strlen(UnixEntry) - 1] != '/')
	strcat(UnixEntry, "/");

    StrAllocCopy(DirEntry, HTVMS_name("", UnixEntry));
    if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
	return (NULL);
    strcpy(dir.dirname, DirEntry);
    index = strlen(DirEntry) - 1;

    if (DirEntry[index] == ']')
	DirEntry[index] = '\0';

    if ((dot = strrchr(DirEntry, '.')) == NULL) {	/* convert disk$user:[duns] into disk$user:[000000]duns.dir */
	char *openbr = strrchr(DirEntry, '[');

	if (!openbr) {		/* convert disk$user: into disk$user:[000000]000000.dir */
	    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
		return (NULL);
	    sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	    StrAllocCat(DirEntry, "[000000]000000.dir");
	} else {
	    char End[256];

	    strcpy(End, openbr + 1);
	    *(openbr + 1) = '\0';
	    StrAllocCat(DirEntry, "000000]");
	    StrAllocCat(DirEntry, End);
	    StrAllocCat(DirEntry, ".dir");
	}
    } else {
	*dot = ']';
	StrAllocCat(DirEntry, ".dir");
    }
    /* lib$find_file needs a fixed-size buffer */
    LYstrncpy(Actual, DirEntry, sizeof(Actual) - 1);

    dir.context = 0;
    dirname_desc.dsc$w_length = strlen(Actual);
    dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dirname_desc.dsc$a_pointer = (char *) &(Actual);

    /* look for the directory */
    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirname_desc),
			   &entryname_desc,
			   &(dir.context),
			   0, 0, 0, 0);
    if (!(status & 0x01)) {	/* directory not found */
	return (NULL);
    }

    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
	return (NULL);
    if (HTVMSFileVersions)
	strcat(dir.dirname, "*.*;*");
    else
	strcat(dir.dirname, "*.*");
    dir.context = 0;
    dir.dirname_desc.dsc$w_length = strlen(dir.dirname);
    dir.dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dir.dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dir.dirname_desc.dsc$a_pointer = (char *) &(dir.dirname);
    return (&dir);
d518 38
a555 36
    static struct dirent entry;
    long status;
    struct dsc$descriptor_s entryname_desc;
    char *space, *slash;
    char VMSentry[256];
    const char *UnixEntry;

    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirp->dirname_desc),
			   &entryname_desc,
			   &(dirp->context),
			   0, 0, 0, 0);
    if (status == RMS$_NMF) {	/* no more files */
	return (NULL);
    } else {			/* ok */
	if (!(status & 0x01))
	    return (0);
	if (HTVMSFileVersions)
	    space = strchr(VMSentry, ' ');
	else
	    space = strchr(VMSentry, ';');
	if (space)
	    *space = '\0';

	/* convert to unix style... */
	UnixEntry = HTVMS_wwwName(VMSentry);
	slash = strrchr(UnixEntry, '/') + 1;
	strcpy(entry.d_name, slash);
	entry.d_namlen = strlen(entry.d_name);
	entry.d_fileno = 1;
	return (&entry);
    }
d560 1
a560 1
    long status;
d562 4
a565 5
    status = lib$find_file_end(&(dirp->context));
    if (!(status & 0x01))
	exit(status);
    dirp->context = 0;
    return (0);
d571 1
a571 1
#include <HTFile.h>		/* For HTFileFormat() */
d574 2
a575 2
 *  Hypertext object building machinery.
 */
d584 2
a585 2
    const HTStructuredClass *isa;
    /* ... */
d590 2
a591 4
static char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
d595 3
a597 3
    char *filename;
    char *type;
    char *date;
d599 1
a599 1
    BOOLEAN display;		/* show this entry? */
d602 1
a602 1
static void free_VMSEntryInfo_contents(VMSEntryInfo * entry_info)
d609 1
a609 1
    /* dont free the struct */
d612 2
a613 1
int compare_VMSEntryInfo_structs(VMSEntryInfo * entry1, VMSEntryInfo * entry2)
d618 96
a713 94
    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size == entry2->size)
	    return (strcasecomp(entry1->filename,
				entry2->filename));
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_DATE:
	if (entry1->date && entry2->date) {
	    /*
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 ||
		strlen(entry2->date) != 12) {
		return (strcasecomp(entry1->filename,
				    entry2->filename));
	    }
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[7] != ' ') {
		strcpy(date1, "9999");
		strcpy(time1, (char *) &entry1->date[7]);
	    } else {
		strcpy(date1, (char *) &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    strncat(date1, (char *) &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ') {
		date1[6] = '0';
	    }
	    strcat(date1, time1);
	    if (entry2->date[7] != ' ') {
		strcpy(date2, "9999");
		strcpy(time2, (char *) &entry2->date[7]);
	    } else {
		strcpy(date2, (char *) &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    strncat(date2, (char *) &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ') {
		date2[6] = '0';
	    }
	    strcat(date2, time2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_NAME:
    default:
	return (strcmp(entry1->filename,
		       entry2->filename));
    }
d716 1
d718 21
a738 19
 *
 *	This function generates a directory listing as an HTML-object
 *	for local file URL's.  It assumes the first two elements of
 *	of the path are a device followed by a directory:
 *
 *		file://localhost/device/directory[/[foo]]
 *
 *	Will not accept 000000 as a directory name.
 *	Will offer links to parent through the top directory, unless
 *	a terminal slash was included in the calling URL.
 *
 *	Returns HT_LOADED on success, HTLoadError() messages on error.
 *
 *	Developed for Lynx by Foteos Macrides (macrides@@sci.wfeb.edu).
 */
int HTVMSBrowseDir(const char *address,
		   HTParentAnchor *anchor,
		   HTFormat format_out,
		   HTStream *sink)
d740 1
a740 1
    HTStructured *target;
d749 1
a749 1
    int pathend, len;
d758 1
a758 1
    CTRACE((tfp, "HTVMSBrowseDir: Browsing `%s\'\n", pathname));
d761 4
a764 4
     * Require at least two elements (presumably a device and directory) and
     * disallow the device root (000000 directory).  Symbolic paths (e.g.,
     * sys$help) should have been translated and expanded (e.g., to
     * /sys$sysroot/syshlp) before calling this routine.
d767 1
a767 1
	 (cp = strchr(pathname + 1, '/')) == NULL ||
d776 1
a776 1
     * Set up the output stream.
d778 1
a778 1
    _HTProgress(BUILDING_DIR_LIST);
d789 2
a790 2
     * Set up the offset string of the anchor reference, and strings for the
     * title and header.
d792 2
a793 2
    cp = strrchr(pathname, '/');	/* find lastslash */
    StrAllocCopy(tail, (cp + 1));	/* take slash off the beginning */
d797 1
a797 1
	if ((cp1 = strrchr(pathname, '/')) != NULL &&
d799 2
a800 2
	    strncmp((cp1 + 1), "000000", 6))
	    StrAllocCopy(parent, (cp1 + 1));
d803 1
a803 1
	pathname[strlen(pathname) - 1] = '\0';
d805 1
a805 1
	StrAllocCopy(title, (cp + 1));
d811 1
a811 1
     * Initialize path name for HTStat().
d814 1
a814 1
    if (*(pathname + pathend - 1) != '/') {
d820 1
a820 1
     * Output the title and header.
d843 2
a844 3
	FILE *fp;

	if (header[strlen(header) - 1] != '/')
d847 1
a847 1
	if ((fp = fopen(header, "r")) != NULL) {
d849 1
a849 1
	    for (;;) {
d851 1
a851 2

		if (c == (char) EOF)
d855 11
a865 11
		case '&':
		case '<':
		case '>':
		    PUTC('&');
		    PUTC('#');
		    PUTC((char) (c / 10));
		    PUTC((char) (c % 10));
		    PUTC(';');
		    break;
		default:
		    PUTC(c);
d890 1
a890 1
     * Set up the date comparison.
d893 1
a893 1
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
d913 1
a913 1
	    if (!dirbuf->d_ino) {
d936 1
a936 1
	    *(pathname + pathend) = '\0';
d943 1
a943 1
	    entry_info = (VMSEntryInfo *) malloc(sizeof(VMSEntryInfo));
d954 1
a954 1
				  (const char **) &cp);
d956 2
a957 1
		if (!strncmp(HTAtom_name(format), "application", 11)) {
d959 1
a959 1
		    if (!strncmp(cp, "x-", 2))
d961 2
a962 1
		} else
a970 1

d973 1
a973 1
		    *dot = '\0';
d995 4
a998 4
		    entry_info->filename[len - 1] == 'z') {
		    if (entry_info->filename[len - 2] == '.' ||
			entry_info->filename[len - 2] == '_')
			entry_info->filename[len - 1] = 'Z';
d1004 2
a1005 1
		char *t = (char *) ctime((const time_t *) &file_info.st_ctime);
d1007 4
a1010 6
		*(t + 24) = '\0';

		StrAllocCopy(entry_info->date, (t + 4));
		*((entry_info->date) + 7) = '\0';
		if ((atoi((t + 19))) < atoi(ThisYear))
		    StrAllocCat(entry_info->date, (t + 19));
d1012 2
a1013 2
		    StrAllocCat(entry_info->date, (t + 11));
		    *((entry_info->date) + 12) = '\0';
d1019 1
a1019 1
		entry_info->size = (unsigned int) file_info.st_size;
d1024 6
a1029 5
	    if (entry_info->display) {
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
	    }
d1031 1
a1031 1
	}			/* End while HTVMSreaddir() */
d1041 1
a1041 1
	    HTBTElement *ele;
a1042 1

d1045 3
a1047 2
		 ele = HTBTree_next(bt, ele)) {
		entry_info = (VMSEntryInfo *) HTBTree_object(ele);
d1050 7
a1056 5
		if (entry_info->date) {
		    PUTS(entry_info->date);
		    PUTS("  ");
		} else
		    PUTS("     * ");
d1059 3
a1061 2
		if (entry_info->type) {
		    for (i = 0; entry_info->type[i] != '\0' && i < 15; i++)
d1063 1
a1063 1
		    for (; i < 17; i++)
d1066 1
a1066 1
		}
d1074 10
a1083 9
		if (entry_info->size) {
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %d bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "  %dKb",
				entry_info->size / 1024);
		    PUTS(string_buffer);
		}
d1085 1
a1085 1
		PUTC('\n');	/* end of this entry */
d1093 1
a1093 1
    }				/* End of both BTree loops */
d1096 1
a1096 1
     * Complete the output stream.
d1109 1
a1109 1
}				/* End of directory reading section */
d1118 2
a1119 2

    while (remove(filename) == 0) ;
d1137 2
a1138 1
    while (remove(older_file) == 0) ;
a1151 1
#endif /* VMS */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a21 1
#include <HTFTP.h>
d35 2
a36 1
#include <LYStrings.h>
d107 1
a107 1
	   CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
d133 1
a133 1
	   CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
d210 1
a210 1
	return(YES);
d212 1
a212 1
	return(NO);
d226 1
a226 1
**	returns		www file specification
d230 12
a241 12
**	DISK$USER			disk$user
**	DISK$USER:			/disk$user/
**	DISK$USER:[DUNS]		/disk$user/duns
**	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
**	[DUNS]				duns
**	[DUNS.ECHO]			duns/echo
**	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
**	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
**	[.DUNS]				duns
**	[.DUNS.ECHO]			duns/echo
**	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
**	TEST.COM			test.com
d246 1
a246 1
	CONST char *,	vmsname)
d248 2
a249 3
static char wwwname[LY_MAXPATH];
CONST char *src;
char *dst;
d259 5
a263 5
	 case ':':  *(dst++) = '/'; break;
	 case '-': if (dir)
		   {
		      if ((*(src-1)=='[' || *(src-1)=='.' || *(src-1)=='-') &&
			  (*(src+1)=='.' || *(src+1)=='-'))
d265 3
a267 3
			  *(dst++) = '/';
			  *(dst++) = '.';
			  *(dst++) = '.';
d270 1
a270 1
			  *(dst++) = '-';
d277 6
a282 6
		   break;
	 case '.': if (dir)
		   {
		      if (*(src-1) != '[') *(dst++) = '/';
		   }
		   else
d285 1
a285 1
		      *(dst++) = '.';
d287 6
a292 6
		   break;
	 case '[': dir = 1; break;
	 case ']': dir = 0; break;
	 default:  if (*(src-1) == ']') *(dst++) = '/';
		   *(dst++) = *src;
		   break;
d300 72
d383 1
a383 1
		is statted like:	/disk$user/duns/www.dir
d397 1
a397 1
static char *Name;
d405 26
a430 1
   StrAllocCopy(Name,filename);
d447 1
a447 1
      StrAllocCat(Name, "/000000/000000");
d455 5
a459 5
	 char End[256];
	 LYstrncpy(End, Ptr, sizeof(End) - 1);
	 *(Ptr+1) = '\0';
	 StrAllocCat(Name, "000000");
	 StrAllocCat(Name, End);
d463 1
a463 1
   /* try in case a file on toplevel directory or .DIR was already specified */
d469 1
a469 1
   StrAllocCat(Name, ".dir");
d482 9
a490 1
	long	context;	/* context descriptor for LIB$FIND_FILE calls */
d498 11
d513 3
d517 3
d550 1
a550 2
static char *DirEntry;
char Actual[256];
d561 1
a561 1
   sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
d565 1
a565 3
   StrAllocCopy(DirEntry, HTVMS_name("",UnixEntry));
   if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
      return (NULL);
d577 3
a579 4
         if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
            return (NULL);
         sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	 StrAllocCat(DirEntry,"[000000]000000.dir");
d583 6
a588 6
	 char End[256];
	 strcpy(End,openbr+1);
	 *(openbr+1) = '\0';
	 StrAllocCat(DirEntry,"000000]");
	 StrAllocCat(DirEntry,End);
	 StrAllocCat(DirEntry,".dir");
d594 1
a594 1
      StrAllocCat(DirEntry,".dir");
a595 2
   /* lib$find_file needs a fixed-size buffer */
   LYstrncpy(Actual, DirEntry, sizeof(Actual)-1);
d598 1
a598 1
   dirname_desc.dsc$w_length = strlen(Actual);
d601 1
a601 1
   dirname_desc.dsc$a_pointer = (char *)&(Actual);
d610 3
a612 3
			  &entryname_desc,
			  &(dir.context),
			  0,0,0,0);
d618 10
a627 2
   if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
       return (NULL);
d655 3
a657 3
			  &entryname_desc,
			  &(dirp->context),
			  0,0,0,0);
d666 1
a666 1
	  space = strchr(VMSentry,' ');
d668 1
a668 1
	  space = strchr(VMSentry,';');
d670 1
a670 1
	 *space = '\0';
d736 6
d750 1
a750 1
	case FILE_BY_SIZE:
d752 1
a752 1
			if(entry1->size == entry2->size)
d760 4
a763 3
	case FILE_BY_TYPE:
			if(entry1->type && entry2->type) {
			    status = strcasecomp(entry1->type, entry2->type);
d768 1
a768 1
			return (strcasecomp(entry1->filename,
d770 3
a772 2
	case FILE_BY_DATE:
			if(entry1->date && entry2->date) {
d777 1
a777 1
				strlen(entry2->date) != 12) {
d786 1
a786 1
				strcpy(date1, "9999");
d790 1
a790 1
				strcpy(time1, "00:00");
d795 1
a795 1
				if (!strcasecomp(month, months[i])) {
d800 1
a800 1
			    sprintf(month, "%02d", i);
d805 1
a805 1
				date1[6] = '0';
d809 1
a809 1
				strcpy(date2, "9999");
d813 1
a813 1
				strcpy(time2, "00:00");
d818 1
a818 1
				if (!strcasecomp(month, months[i])) {
d823 1
a823 1
			    sprintf(month, "%02d", i);
d828 1
a828 1
				date2[6] = '0';
d834 1
a834 1
			    status = strcasecomp(date2, date1);
d839 1
a839 1
			return (strcasecomp(entry1->filename,
d841 4
a844 3
	case FILE_BY_NAME:
	default:
			return (strcmp(entry1->filename,
d850 1
a850 1
/*							HTVMSBrowseDir()
d892 1
a892 1
    CTRACE((tfp,"HTVMSBrowseDir: Browsing `%s\'\n", pathname));
d901 1
a901 1
	 (cp=strchr(pathname+1, '/')) == NULL ||
d904 3
a906 3
	(dp=HTVMSopendir(pathname)) == NULL) {
	FREE(pathname);
	return HTLoadError(sink, 403, COULD_NOT_ACCESS_DIR);
d929 1
a929 1
	StrAllocCopy(title, tail);
d937 1
a937 1
	pathname[strlen(pathname)-1] = '\0';
d977 1
a977 1
	FILE * fp;
d981 1
a981 1
	if ((fp = fopen(header,	 "r")) != NULL) {
d984 2
a985 2
		char c = fgetc(fp);
		if (c == (char)EOF)
d988 2
a989 2
		switch (c) {
		    case '&':
d1000 1
a1000 1
		}
d1007 1
a1007 1
	}
d1011 4
a1014 1
	HTSprintf0(&relative, "%s/..", tail);
d1078 1
a1078 1
		continue;
d1080 1
a1080 1
	    entry_info = (VMSEntryInfo *)malloc(sizeof(VMSEntryInfo));
d1106 5
a1110 5
		/* strip .DIR part... */
		char *dot;
		dot = strstr(entry_info->filename, ".DIR");
		if (dot)
		   *dot = '\0';
d1114 2
a1115 2
		if ((cp = strstr(entry_info->filename, "READ")) == NULL) {
		    cp = entry_info->filename;
d1119 1
a1119 1
			cp += 2;
d1124 1
a1124 1
			cp = (entry_info->filename +
d1127 1
a1127 1
			cp = entry_info->filename;
d1134 1
a1134 1
			entry_info->filename[len-2] == '_')
d1141 1
a1141 1
		char *t = (char *)ctime((CONST time_t *)&file_info.st_ctime);
d1144 1
a1144 1
		StrAllocCopy(entry_info->date, (t+4));
d1156 1
a1156 1
		entry_info->size = (unsigned int)file_info.st_size;
d1158 1
a1158 1
		entry_info->size = 0;
d1163 3
a1165 3
		 CTRACE((tfp,"Adding file to BTree: %s\n",
						      entry_info->filename));
		 HTBTree_add(bt, (VMSEntryInfo *)entry_info);
d1189 2
a1190 2
			     PUTS(entry_info->date);
			     PUTS("  ");
d1199 1
a1199 1
			PUTC(entry_info->type[i]);
d1201 1
a1201 1
			PUTC(' ');
d1210 1
a1210 1
		/* Output the size */
d1213 1
a1213 1
			  if(entry_info->size < 1024)
@

