head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.8
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.6
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.8.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.8
	MIRBSD_XP_SPARC:1.8.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.5
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.5.0.6
	MIRBSD_7:1.5.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.5
	MIRBSD_7_DEV:1.5.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.15.18.16.30;	author tg;	state Stab;
branches;
next	1.7;

1.7
date	2004.04.30.16.32.24;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.18.16.55.38;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.27.13.12.33;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.19.57.27;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.58;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.07;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.53;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.08;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.26;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.16;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.47.34;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/*		Access Manager					HTAccess.c
 *		==============
 *
 *  Authors
 *	TBL	Tim Berners-Lee timbl@@info.cern.ch
 *	JFG	Jean-Francois Groff jfg@@dxcern.cern.ch
 *	DD	Denis DeLaRoca (310) 825-4580  <CSP1DWD@@mvs.oac.ucla.edu>
 *	FM	Foteos Macrides macrides@@sci.wfeb.edu
 *	PDM	Danny Mayer mayer@@ljo.dec.com
 *
 *  History
 *	 8 Jun 92 Telnet hopping prohibited as telnet is not secure TBL
 *	26 Jun 92 When over DECnet, suppressed FTP, Gopher and News. JFG
 *	 6 Oct 92 Moved HTClientHost and logfile into here. TBL
 *	17 Dec 92 Tn3270 added, bug fix. DD
 *	 4 Feb 93 Access registration, Search escapes bad chars TBL
 *		  PARAMETERS TO HTSEARCH AND HTLOADRELATIVE CHANGED
 *	28 May 93 WAIS gateway explicit if no WAIS library linked in.
 *	31 May 94 Added DIRECT_WAIS support for VMS. FM
 *	27 Jan 95 Fixed proxy support to use NNTPSERVER for checking
 *		  whether or not to use the proxy server. PDM
 *	27 Jan 95 Ensured that proxy service will be overridden for files
 *		  on the local host (because HTLoadFile() doesn't try ftp
 *		  for those) and will substitute ftp for remote files. FM
 *	28 Jan 95 Tweaked PDM's proxy override mods to handle port info
 *		  for news and wais URL's. FM
 *
 *  Bugs
 *	This module assumes that that the graphic object is hypertext, as it
 *	needs to select it when it has been loaded.  A superclass needs to be
 *	defined which accepts select and select_anchor.
 */

#ifdef VMS
#define DIRECT_WAIS
#endif /* VMS */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTAlert.h>
/*
 *  Implements:
 */
#include <HTAccess.h>

/*
 *  Uses:
 */
#include <HTParse.h>
#include <HTML.h>		/* SCW */

#ifndef NO_RULES
#include <HTRules.h>
#endif

#include <HTList.h>
#include <HText.h>		/* See bugs above */
#include <HTCJK.h>
#include <UCMap.h>
#include <GridText.h>

#include <LYGlobalDefs.h>
#include <LYexit.h>
#include <LYUtils.h>
#include <LYLeaks.h>

/*
 *  These flags may be set to modify the operation of this module
 */
char *HTClientHost = NULL;	/* Name of remote login host if any */
FILE *HTlogfile = NULL;		/* File to which to output one-liners */
BOOL HTSecure = NO;		/* Disable access for telnet users? */
BOOL HTPermitRedir = NO;	/* Always allow redirection in getfile()? */

BOOL using_proxy = NO;		/* are we using a proxy gateway? */

/*
 *  To generate other things, play with these:
 */
HTFormat HTOutputFormat = NULL;
HTStream *HTOutputStream = NULL;	/* For non-interactive, set this */

static HTList *protocols = NULL;	/* List of registered protocol descriptors */

char *use_this_url_instead = NULL;

static int pushed_assume_LYhndl = -1;	/* see LYUC* functions below - kw */
static char *pushed_assume_MIMEname = NULL;

#ifdef LY_FIND_LEAKS
static void free_protocols(void)
{
    HTList_delete(protocols);
    protocols = NULL;
    FREE(pushed_assume_MIMEname);	/* shouldn't happen, just in case - kw */
}
#endif /* LY_FIND_LEAKS */

/*	Register a Protocol.				HTRegisterProtocol()
 *	--------------------
 */
BOOL HTRegisterProtocol(HTProtocol * protocol)
{
    if (!protocols) {
	protocols = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(free_protocols);
#endif
    }
    HTList_addObject(protocols, protocol);
    return YES;
}

/*	Register all known protocols.			HTAccessInit()
 *	-----------------------------
 *
 *	Add to or subtract from this list if you add or remove protocol
 *	modules.  This routine is called the first time the protocol list
 *	is needed, unless any protocols are already registered, in which
 *	case it is not called.	Therefore the application can override
 *	this list.
 *
 *	Compiling with NO_INIT prevents all known protocols from being
 *	forced in at link time.
 */
#ifndef NO_INIT
#ifdef GLOBALREF_IS_MACRO
extern GLOBALREF (HTProtocol, HTTP);
extern GLOBALREF (HTProtocol, HTTPS);
extern GLOBALREF (HTProtocol, HTFile);
extern GLOBALREF (HTProtocol, HTTelnet);
extern GLOBALREF (HTProtocol, HTTn3270);
extern GLOBALREF (HTProtocol, HTRlogin);

#ifndef DECNET
#ifndef DISABLE_FTP
extern GLOBALREF (HTProtocol, HTFTP);
#endif /* DISABLE_FTP */
#ifndef DISABLE_NEWS
extern GLOBALREF (HTProtocol, HTNews);
extern GLOBALREF (HTProtocol, HTNNTP);
extern GLOBALREF (HTProtocol, HTNewsPost);
extern GLOBALREF (HTProtocol, HTNewsReply);
extern GLOBALREF (HTProtocol, HTSNews);
extern GLOBALREF (HTProtocol, HTSNewsPost);
extern GLOBALREF (HTProtocol, HTSNewsReply);
#endif /* not DISABLE_NEWS */
#ifndef DISABLE_GOPHER
extern GLOBALREF (HTProtocol, HTGopher);
extern GLOBALREF (HTProtocol, HTCSO);
#endif /* not DISABLE_GOPHER */
#ifndef DISABLE_FINGER
extern GLOBALREF (HTProtocol, HTFinger);
#endif /* not DISABLE_FINGER */
#ifdef DIRECT_WAIS
extern GLOBALREF (HTProtocol, HTWAIS);
#endif /* DIRECT_WAIS */
#endif /* !DECNET */
#else
GLOBALREF HTProtocol HTTP, HTTPS, HTFile, HTTelnet, HTTn3270, HTRlogin;

#ifndef DECNET
#ifndef DISABLE_FTP
GLOBALREF HTProtocol HTFTP;
#endif /* DISABLE_FTP */
#ifndef DISABLE_NEWS
GLOBALREF HTProtocol HTNews, HTNNTP, HTNewsPost, HTNewsReply;
GLOBALREF HTProtocol HTSNews, HTSNewsPost, HTSNewsReply;
#endif /* not DISABLE_NEWS */
#ifndef DISABLE_GOPHER
GLOBALREF HTProtocol HTGopher, HTCSO;
#endif /* not DISABLE_GOPHER */
#ifndef DISABLE_FINGER
GLOBALREF HTProtocol HTFinger;
#endif /* not DISABLE_FINGER */
#ifdef DIRECT_WAIS
GLOBALREF HTProtocol HTWAIS;
#endif /* DIRECT_WAIS */
#endif /* !DECNET */
#endif /* GLOBALREF_IS_MACRO */

static void HTAccessInit(void)	/* Call me once */
{
    HTRegisterProtocol(&HTTP);
    HTRegisterProtocol(&HTTPS);
    HTRegisterProtocol(&HTFile);
    HTRegisterProtocol(&HTTelnet);
    HTRegisterProtocol(&HTTn3270);
    HTRegisterProtocol(&HTRlogin);
#ifndef DECNET
#ifndef DISABLE_FTP
    HTRegisterProtocol(&HTFTP);
#endif /* DISABLE_FTP */
#ifndef DISABLE_NEWS
    HTRegisterProtocol(&HTNews);
    HTRegisterProtocol(&HTNNTP);
    HTRegisterProtocol(&HTNewsPost);
    HTRegisterProtocol(&HTNewsReply);
    HTRegisterProtocol(&HTSNews);
    HTRegisterProtocol(&HTSNewsPost);
    HTRegisterProtocol(&HTSNewsReply);
#endif /* not DISABLE_NEWS */
#ifndef DISABLE_GOPHER
    HTRegisterProtocol(&HTGopher);
    HTRegisterProtocol(&HTCSO);
#endif /* not DISABLE_GOPHER */
#ifndef DISABLE_FINGER
    HTRegisterProtocol(&HTFinger);
#endif /* not DISABLE_FINGER */
#ifdef DIRECT_WAIS
    HTRegisterProtocol(&HTWAIS);
#endif /* DIRECT_WAIS */
#endif /* !DECNET */
    LYRegisterLynxProtocols();
}
#endif /* !NO_INIT */

/*	Check for proxy override.			override_proxy()
 *	-------------------------
 *
 *	Check the no_proxy environment variable to get the list
 *	of hosts for which proxy server is not consulted.
 *
 *	no_proxy is a comma- or space-separated list of machine
 *	or domain names, with optional :port part.  If no :port
 *	part is present, it applies to all ports on that domain.
 *
 *  Example:
 *	    no_proxy="cern.ch,some.domain:8001"
 *
 *  Use "*" to override all proxy service:
 *	     no_proxy="*"
 */
BOOL override_proxy(const char *addr)
{
    const char *no_proxy = getenv("no_proxy");
    char *p = NULL;
    char *at = NULL;
    char *host = NULL;
    char *Host = NULL;
    char *acc_method = NULL;
    int port = 0;
    int h_len = 0;

    /*
     * Check for global override.
     */
    if (no_proxy) {
	if (!strcmp(no_proxy, "*"))
	    return YES;
    }

    /*
     * Never proxy file:// URLs if they are on the local host.  HTLoadFile()
     * will not attempt ftp for those if direct access fails.  We'll check that
     * first, in case no_proxy hasn't been defined.  - FM
     */
    if (!addr)
	return NO;
    if (!(host = HTParse(addr, "", PARSE_HOST)))
	return NO;
    if (!*host) {
	FREE(host);
	return NO;
    }
    Host = (((at = strchr(host, '@@')) != NULL) ? (at + 1) : host);

    if ((acc_method = HTParse(addr, "", PARSE_ACCESS))) {
	if (!strcmp("file", acc_method) &&
	    (LYSameHostname(Host, "localhost") ||
	     LYSameHostname(Host, HTHostName()))) {
	    FREE(host);
	    FREE(acc_method);
	    return YES;
	}
	FREE(acc_method);
    }

    if (!no_proxy) {
	FREE(host);
	return NO;
    }

    if (NULL != (p = strrchr(Host, ':'))) {	/* Port specified */
	*p++ = 0;		/* Chop off port */
	port = atoi(p);
    } else {			/* Use default port */
	acc_method = HTParse(addr, "", PARSE_ACCESS);
	if (acc_method != NULL) {
	    /* *INDENT-OFF* */
	    if	    (!strcmp(acc_method, "http"))	port = 80;
	    else if (!strcmp(acc_method, "https"))	port = 443;
	    else if (!strcmp(acc_method, "ftp"))	port = 21;
#ifndef DISABLE_GOPHER
	    else if (!strcmp(acc_method, "gopher"))	port = 70;
#endif
	    else if (!strcmp(acc_method, "cso"))	port = 105;
#ifndef DISABLE_NEWS
	    else if (!strcmp(acc_method, "news"))	port = 119;
	    else if (!strcmp(acc_method, "nntp"))	port = 119;
	    else if (!strcmp(acc_method, "newspost"))	port = 119;
	    else if (!strcmp(acc_method, "newsreply"))	port = 119;
	    else if (!strcmp(acc_method, "snews"))	port = 563;
	    else if (!strcmp(acc_method, "snewspost"))	port = 563;
	    else if (!strcmp(acc_method, "snewsreply")) port = 563;
#endif
	    else if (!strcmp(acc_method, "wais"))	port = 210;
#ifndef DISABLE_FINGER
	    else if (!strcmp(acc_method, "finger"))	port = 79;
#endif
	    else if (!strcmp(acc_method, "telnet"))	port = 23;
	    else if (!strcmp(acc_method, "tn3270"))	port = 23;
	    else if (!strcmp(acc_method, "rlogin"))	port = 513;
	    /* *INDENT-ON* */

	    FREE(acc_method);
	}
    }
    if (!port)
	port = 80;		/* Default */
    h_len = strlen(Host);

    while (*no_proxy) {
	const char *end;
	const char *colon = NULL;
	int templ_port = 0;
	int t_len;

	while (*no_proxy && (WHITE(*no_proxy) || *no_proxy == ','))
	    no_proxy++;		/* Skip whitespace and separators */

	end = no_proxy;
	while (*end && !WHITE(*end) && *end != ',') {	/* Find separator */
	    if (*end == ':')
		colon = end;	/* Port number given */
	    end++;
	}

	if (colon) {
	    templ_port = atoi(colon + 1);
	    t_len = colon - no_proxy;
	} else {
	    t_len = end - no_proxy;
	}

	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
	     !strncasecomp(Host + h_len - t_len, no_proxy, t_len))) {
	    FREE(host);
	    return YES;
	}
#ifdef CJK_EX			/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
	     isdigit(UCH(*no_proxy)) && !strncmp(host, no_proxy, t_len))) {
	    FREE(host);
	    return YES;
	}
#endif /* ASATAKU PROXY HACK */

	if (*end)
	    no_proxy = (end + 1);
	else
	    break;
    }

    FREE(host);
    return NO;
}

/*	Find physical name and access protocol		get_physical()
 *	--------------------------------------
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		HT_NO_ACCESS		Error has occurred.
 *			HT_OK			Success
 */
static int get_physical(const char *addr,
			HTParentAnchor *anchor)
{
    int result;
    char *acc_method = NULL;	/* Name of access method */
    char *physical = NULL;
    char *Server_addr = NULL;
    BOOL override_flag = NO;

    CTRACE((tfp, "get_physical %s\n", addr));

    /*
     * Make sure the using_proxy variable is FALSE.
     */
    using_proxy = NO;

#ifndef NO_RULES
    if ((physical = HTTranslate(addr)) == 0) {
	if (redirecting_url) {
	    return HT_REDIRECTING;
	}
	return HT_FORBIDDEN;
    }
    if (anchor->isISMAPScript == TRUE) {
	StrAllocCat(physical, "?0,0");
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
    }
    if (!strncmp(physical, "Proxied=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	using_proxy = YES;
    } else if (!strncmp(physical, "NoProxy=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	override_flag = YES;
    } else {
	HTAnchor_setPhysical(anchor, physical);
    }
    FREE(physical);		/* free our copy */
#else
    if (anchor->isISMAPScript == TRUE) {
	StrAllocCopy(physical, addr);
	StrAllocCat(physical, "?0,0");
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
	HTAnchor_setPhysical(anchor, physical);
	FREE(physical);		/* free our copy */
    } else {
	HTAnchor_setPhysical(anchor, addr);
    }
#endif /* NO_RULES */

    acc_method = HTParse(HTAnchor_physical(anchor), STR_FILE_URL, PARSE_ACCESS);

    /*
     * Check whether gateway access has been set up for this.
     *
     * This function can be replaced by the rule system above.
     *
     * If the rule system has already determined that we should use a proxy, or
     * that we shouldn't, ignore proxy-related settings, don't use no_proxy
     * either.
     */
#define USE_GATEWAYS
#ifdef USE_GATEWAYS

    if (!override_flag && !using_proxy) {	/* else ignore no_proxy env var */
	if (!strcasecomp(acc_method, "news")) {
	    /*
	     * News is different, so we need to check the name of the server,
	     * as well as the default port for selective exclusions.
	     */
	    char *host = NULL;

	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (strchr(host, ':') == NULL) {
		    StrAllocCopy(Server_addr, "news://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":119/");
		}
		FREE(host);
	    } else if (LYGetEnv("NNTPSERVER") != NULL) {
		StrAllocCopy(Server_addr, "news://");
		StrAllocCat(Server_addr, LYGetEnv("NNTPSERVER"));
		StrAllocCat(Server_addr, ":119/");
	    }
	} else if (!strcasecomp(acc_method, "wais")) {
	    /*
	     * Wais also needs checking of the default port for selective
	     * exclusions.
	     */
	    char *host = NULL;

	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (!(strchr(host, ':'))) {
		    StrAllocCopy(Server_addr, "wais://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":210/");
		}
		FREE(host);
	    } else
		StrAllocCopy(Server_addr, addr);
	} else {
	    StrAllocCopy(Server_addr, addr);
	}
	override_flag = override_proxy(Server_addr);
    }

    if (!override_flag && !using_proxy) {
	char *gateway_parameter = NULL, *gateway, *proxy;

	/*
	 * Search for gateways.
	 */
	HTSprintf0(&gateway_parameter, "WWW_%s_GATEWAY", acc_method);
	gateway = LYGetEnv(gateway_parameter);	/* coerce for decstation */

	/*
	 * Search for proxy servers.
	 */
	if (!strcmp(acc_method, "file"))
	    /*
	     * If we got to here, a file URL is for ftp on a remote host. - FM
	     */
	    strcpy(gateway_parameter, "ftp_proxy");
	else
	    sprintf(gateway_parameter, "%s_proxy", acc_method);
	proxy = LYGetEnv(gateway_parameter);
	FREE(gateway_parameter);

	if (gateway)
	    CTRACE((tfp, "Gateway found: %s\n", gateway));
	if (proxy)
	    CTRACE((tfp, "proxy server found: %s\n", proxy));

	/*
	 * Proxy servers have precedence over gateway servers.
	 */
	if (proxy) {
	    char *gatewayed = NULL;

	    StrAllocCopy(gatewayed, proxy);
	    if (!strncmp(gatewayed, "http", 4)) {
		char *cp = strrchr(gatewayed, '/');

		/* Append a slash to the proxy specification if it doesn't
		 * end in one but otherwise looks normal (starts with "http",
		 * has no '/' other than ones before the hostname). - kw */
		if (cp && (cp - gatewayed) <= 7)
		    LYAddHtmlSep(&gatewayed);
	    }
	    /*
	     * Ensure that the proxy server uses ftp for file URLs. - FM
	     */
	    if (!strncmp(addr, "file", 4)) {
		StrAllocCat(gatewayed, "ftp");
		StrAllocCat(gatewayed, (addr + 4));
	    } else
		StrAllocCat(gatewayed, addr);
	    using_proxy = YES;
	    if (anchor->isISMAPScript == TRUE)
		StrAllocCat(gatewayed, "?0,0");
	    HTAnchor_setPhysical(anchor, gatewayed);
	    FREE(gatewayed);
	    FREE(acc_method);

	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);

	} else if (gateway) {
	    char *path = HTParse(addr, "",
				 PARSE_HOST + PARSE_PATH + PARSE_PUNCTUATION);

	    /* Chop leading / off to make host into part of path */
	    char *gatewayed = HTParse(path + 1, gateway, PARSE_ALL);

	    FREE(path);
	    HTAnchor_setPhysical(anchor, gatewayed);
	    FREE(gatewayed);
	    FREE(acc_method);

	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);
	}
    }
    FREE(Server_addr);
#endif /* use gateways */

    /*
     * Search registered protocols to find suitable one.
     */
    result = HT_NO_ACCESS;
    {
	int i, n;

#ifndef NO_INIT
	if (!protocols)
	    HTAccessInit();
#endif
	n = HTList_count(protocols);
	for (i = 0; i < n; i++) {
	    HTProtocol *p = (HTProtocol *) HTList_objectAt(protocols, i);

	    if (!strcmp(p->name, acc_method)) {
		HTAnchor_setProtocol(anchor, p);
		FREE(acc_method);
		result = HT_OK;
		break;
	    }
	}
    }

    FREE(acc_method);
    return result;
}

/*
 * Temporarily set the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec
 * used for charset "assuming" to the values implied by a HTParentAnchor's
 * UCStages, after saving the current values for later restoration.  - kw @@@@@@
 * These functions may not really belong here, but where else?  I want the
 * "pop" to occur as soon as possible after loading has finished.  - kw @@@@@@
 */
void LYUCPushAssumed(HTParentAnchor *anchor)
{
    int anchor_LYhndl = -1;
    LYUCcharset *anchor_UCI = NULL;

    if (anchor) {
	anchor_LYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
	if (anchor_LYhndl >= 0)
	    anchor_UCI = HTAnchor_getUCInfoStage(anchor,
						 UCT_STAGE_PARSER);
	if (anchor_UCI && anchor_UCI->MIMEname) {
	    pushed_assume_MIMEname = UCAssume_MIMEcharset;
	    UCAssume_MIMEcharset = NULL;
	    if (HTCJK == JAPANESE)
		StrAllocCopy(UCAssume_MIMEcharset, pushed_assume_MIMEname);
	    else
		StrAllocCopy(UCAssume_MIMEcharset, anchor_UCI->MIMEname);
	    pushed_assume_LYhndl = anchor_LYhndl;
	    /* some diagnostics */
	    if (UCLYhndl_for_unspec != anchor_LYhndl)
		CTRACE((tfp,
			"LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
			UCLYhndl_for_unspec,
			anchor_LYhndl));
	    UCLYhndl_for_unspec = anchor_LYhndl;
	    return;
	}
    }
    pushed_assume_LYhndl = -1;
    FREE(pushed_assume_MIMEname);
}

/*
 * Restore the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec used for
 * charset "assuming" from the values saved by LYUCPushAssumed, if any.  - kw
 */
int LYUCPopAssumed(void)
{

    if (pushed_assume_LYhndl >= 0) {
	/* some diagnostics */
	if (UCLYhndl_for_unspec != pushed_assume_LYhndl)
	    CTRACE((tfp,
		    "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
		    UCLYhndl_for_unspec,
		    pushed_assume_LYhndl));
	UCLYhndl_for_unspec = pushed_assume_LYhndl;
	pushed_assume_LYhndl = -1;
	FREE(UCAssume_MIMEcharset);
	UCAssume_MIMEcharset = pushed_assume_MIMEname;
	pushed_assume_MIMEname = NULL;
	return UCLYhndl_for_unspec;
    }
    return -1;
}

/*	Load a document					HTLoad()
 *	---------------
 *
 *	This is an internal routine, which has an address AND a matching
 *	anchor.  (The public routines are called with one OR the other.)
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		<0		Error has occurred.
 *			HT_LOADED	Success
 *			HT_NO_DATA	Success, but no document loaded.
 *					(telnet session started etc)
 */
static int HTLoad(const char *addr,
		  HTParentAnchor *anchor,
		  HTFormat format_out,
		  HTStream *sink)
{
    HTProtocol *p;
    int status = get_physical(addr, anchor);

    if (status == HT_FORBIDDEN) {
	/* prevent crash if telnet or similar was forbidden by rule. - kw */
	LYFixCursesOn("show alert:");
	return HTLoadError(sink, 500, gettext("Access forbidden by rule"));
    } else if (status == HT_REDIRECTING) {
	return status;		/* fake redirection by rule, to redirecting_url */
    }
    if (status < 0)
	return status;		/* Can't resolve or forbidden */

    /* prevent crash if telnet or similar mapped or proxied by rule. - kw */
    LYFixCursesOnForAccess(addr, HTAnchor_physical(anchor));
    p = (HTProtocol *) HTAnchor_protocol(anchor);
    anchor->parent->underway = TRUE;	/* Hack to deal with caching */
    status = p->load(HTAnchor_physical(anchor),
		     anchor, format_out, sink);
    anchor->parent->underway = FALSE;
    LYUCPopAssumed();
    return status;
}

/*	Get a save stream for a document		HTSaveStream()
 *	--------------------------------
 */
HTStream *HTSaveStream(HTParentAnchor *anchor)
{
    HTProtocol *p = (HTProtocol *) HTAnchor_protocol(anchor);

    if (!p)
	return NULL;

    return p->saveStream(anchor);
}

int redirection_attempts = 0;	/* counter in HTLoadDocument */

/*	Load a document - with logging etc		HTLoadDocument()
 *	----------------------------------
 *
 *	- Checks or documents already loaded
 *	- Logs the access
 *	- Allows stdin filter option
 *	- Trace output and error messages
 *
 *  On Entry,
 *	  anchor	    is the node_anchor for the document
 *	  full_address	    The address of the document to be accessed.
 *	  filter	    if YES, treat stdin as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
static BOOL HTLoadDocument(const char *full_address,	/* may include #fragment */
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
{
    int status;
    HText *text;
    const char *address_to_load = full_address;
    char *cp;
    BOOL ForcingNoCache = LYforce_no_cache;

    CTRACE((tfp, "HTAccess: loading document %s\n", address_to_load));

    /*
     * Free use_this_url_instead and reset permanent_redirection if not done
     * elsewhere.  - FM
     */
    FREE(use_this_url_instead);
    permanent_redirection = FALSE;

    /*
     * Make sure some yoyo doesn't send us 'round in circles with redirecting
     * URLs that point back to themselves.  We'll set the original Lynx limit
     * of 10 redirections per requested URL from a user, because the HTTP/1.1
     * will no longer specify a restriction to 5, but will leave it up to the
     * browser's discretion, in deference to Microsoft.  - FM
     */
    if (redirection_attempts > 10) {
	redirection_attempts = 0;
	HTAlert(TOO_MANY_REDIRECTIONS);
	return NO;
    }

    /*
     * If this is marked as an internal link but we don't have the document
     * loaded any more, and we haven't explicitly flagged that we want to
     * reload with LYforce_no_cache, then something has disappeared from the
     * cache when we expected it to be still there.  The user probably doesn't
     * expect a new network access.  So if we have POST data and safe is not
     * set in the anchor, ask for confirmation, and fail if not granted.  The
     * exception are LYNXIMGMAP documents, for which we defer to LYLoadIMGmap
     * for prompting if necessary.  - kw
     */
    text = (HText *) HTAnchor_document(anchor);
    if (LYinternal_flag && !text && !LYforce_no_cache &&
	anchor->post_data && !anchor->safe &&
	!isLYNXIMGMAP(full_address) &&
	HTConfirm(gettext("Document with POST content not found in cache.  Resubmit?"))
	!= TRUE) {
	return NO;
    }

    /*
     * If we don't have POST content, check whether this is a previous
     * redirecting URL, and keep re-checking until we get to the final
     * destination or redirection limit.  If we do have POST content, we didn't
     * allow permanent redirection, and an interactive user will be deciding
     * whether to keep redirecting.  - FM
     */
    if (!anchor->post_data) {
	while ((cp = HTAnchor_physical(anchor)) != NULL &&
	       !strncmp(cp, "Location=", 9)) {
	    DocAddress NewDoc;

	    CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		    anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp + 9));

	    /*
	     * Don't exceed the redirection_attempts limit.  - FM
	     */
	    if (++redirection_attempts > 10) {
		HTAlert(TOO_MANY_REDIRECTIONS);
		redirection_attempts = 0;
		FREE(use_this_url_instead);
		return NO;
	    }

	    /*
	     * Set up the redirection. - FM
	     */
	    StrAllocCopy(use_this_url_instead, cp + 9);
	    NewDoc.address = use_this_url_instead;
	    NewDoc.post_data = NULL;
	    NewDoc.post_content_type = NULL;
	    NewDoc.bookmark = anchor->bookmark;
	    NewDoc.isHEAD = anchor->isHEAD;
	    NewDoc.safe = anchor->safe;
	    anchor = HTAnchor_findAddress(&NewDoc);
	}
    }
    /*
     * If we had previous redirection, go back and check out that the URL under
     * the current restrictions.  - FM
     */
    if (use_this_url_instead) {
	FREE(redirecting_url);
	return (NO);
    }

    /*
     * See if we can use an already loaded document.
     */
    text = (HText *) HTAnchor_document(anchor);
    if (text && !LYforce_no_cache) {
	/*
	 * We have a cached rendition of the target document.  Check if it's OK
	 * to re-use it.  We consider it OK if:
	 * (1) the anchor does not have the no_cache element set, or
	 * (2) we've overridden it, e.g., because we are acting on a PREV_DOC
	 * command or a link in the History Page and it's not a reply from a
	 * POST with the LYresubmit_posts flag set, or
	 * (3) we are repositioning within the currently loaded document based
	 * on the target anchor's address (URL_Reference).
	 *
	 * If DONT_TRACK_INTERNAL_LINKS is defined, HText_AreDifferent() is
	 * used to determine whether (3) applies.  If the target address
	 * differs from that of the current document only by a fragment and the
	 * target address has an appended fragment, repositioning without
	 * reloading is always assumed.  Note that HText_AreDifferent()
	 * currently always returns TRUE if the target has a LYNXIMGMAP URL, so
	 * that an internally generated pseudo-document will normally not be
	 * re-used unless condition (2) applies.  (Condition (1) cannot apply
	 * since in LYMap.c, no_cache is always set in the anchor object). 
	 * This doesn't guarantee that the resource from which the MAP element
	 * is taken will be read again (reloaded) when the list of links for a
	 * client-side image map is regenerated, when in some cases it should
	 * (e.g., user requested RELOAD, or HTTP response with no-cache header
	 * and we are not overriding).
	 *
	 * If DONT_TRACK_INTERNAL_LINKS is undefined, a target address that
	 * points to the same URL as the current document may still result in
	 * reloading, depending on whether the original URL-Reference was given
	 * as an internal link in the context of the previously loaded
	 * document.  HText_AreDifferent() is not used here for testing whether
	 * we are just repositioning.  For an internal link, the potential
	 * callers of this function from mainloop() down will either avoid
	 * making the call (and do the repositioning differently) or set
	 * LYinternal_flag (or LYoverride_no_cache).  Note that (a) LYNXIMGMAP
	 * pseudo-documents and (b) The "List Page" document are treated
	 * logically as being part of the document on which they are based, for
	 * the purpose of whether to treat a link as internal, but the logic
	 * for this (by setting LYinternal_flag as necessary) is implemented
	 * elsewhere.  There is a specific test for LYNXIMGMAP here so that the
	 * generated pseudo-document will not be re-used unless
	 * LYoverride_no_cache is set.  The same caveat as above applies w.r.t. 
	 * reloading of the underlying resource.
	 *
	 * We also should be checking other aspects of cache regulation (e.g.,
	 * based on an If-Modified-Since check, etc.) but the code for doing
	 * those other things isn't available yet.
	 */
	if (LYoverride_no_cache ||
#ifdef DONT_TRACK_INTERNAL_LINKS
	    !HText_hasNoCacheSet(text) ||
	    !HText_AreDifferent(anchor, full_address)
#else
	    ((LYinternal_flag || !HText_hasNoCacheSet(text)) &&
	     !isLYNXIMGMAP(full_address))
#endif /* TRACK_INTERNAL_LINKS */
	    ) {
	    CTRACE((tfp, "HTAccess: Document already in memory.\n"));
	    HText_select(text);

#ifdef DIRED_SUPPORT
	    if (HTAnchor_format(anchor) == WWW_DIRED)
		lynx_edit_mode = TRUE;
#endif
	    redirection_attempts = 0;
	    return YES;
	} else {
	    ForcingNoCache = YES;
	    CTRACE((tfp, "HTAccess: Auto-reloading document.\n"));
	}
    }

    if (text && HText_HaveUserChangedForms(text)) {
	/*
	 * Issue a warning.  User forms content will be lost.
	 * Will not restore changed forms, currently.
	 */
	HTAlert(RELOADING_FORM);
    }

    /*
     * Get the document from the net.  If we are auto-reloading, the mutable
     * anchor elements from the previous rendition should be freed in
     * conjunction with loading of the new rendition.  - FM
     */
    LYforce_no_cache = NO;	/* reset after each time through */
    if (ForcingNoCache) {
	FREE(anchor->title);	/* ??? */
    }
    status = HTLoad(address_to_load, anchor, format_out, sink);
    CTRACE((tfp, "HTAccess:  status=%d\n", status));

    /*
     * RECOVERY:  if the loading failed, and we had a cached HText copy, and no
     * new HText created - use a previous copy, issue a warning.
     */
    if (text && status < 0 && (HText *) HTAnchor_document(anchor) == text) {
	HTAlert(gettext("Loading failed, use a previous copy."));
	CTRACE((tfp, "HTAccess: Loading failed, use a previous copy.\n"));
	HText_select(text);

#ifdef DIRED_SUPPORT
	if (HTAnchor_format(anchor) == WWW_DIRED)
	    lynx_edit_mode = TRUE;
#endif
	redirection_attempts = 0;
	return YES;
    }

    /*
     * Log the access if necessary.
     */
    if (HTlogfile) {
	time_t theTime;

	time(&theTime);
	fprintf(HTlogfile, "%24.24s %s %s %s\n",
		ctime(&theTime),
		HTClientHost ? HTClientHost : "local",
		status < 0 ? "FAIL" : "GET",
		full_address);
	fflush(HTlogfile);	/* Actually update it on disk */
	CTRACE((tfp, "Log: %24.24s %s %s %s\n",
		ctime(&theTime),
		HTClientHost ? HTClientHost : "local",
		status < 0 ? "FAIL" : "GET",
		full_address));
    }

    /*
     * Check out what we received from the net.
     */
    if (status == HT_REDIRECTING) {
	/* Exported from HTMIME.c, of all places.  */
	/* NO!! - FM */
	/*
	 * Doing this via HTMIME.c meant that the redirection cover page was
	 * already loaded before we learned that we want a different URL. 
	 * Also, changing anchor->address, as Lynx was doing, meant we could
	 * never again access its hash table entry, creating an insolvable
	 * memory leak.  Instead, if we had a 301 status and set
	 * permanent_redirection, we'll load the new URL in anchor->physical,
	 * preceded by a token, which we can check to make replacements on
	 * subsequent access attempts.  We'll check recursively, and retrieve
	 * the final URL if we had multiple redirections to it.  If we just
	 * went to HTLoad now, as Lou originally had this, we couldn't do
	 * Lynx's security checks and alternate handling of some URL types. 
	 * So, instead, we'll go all the way back to the top of getfile in
	 * LYGetFile.c when the status is HT_REDIRECTING.  This may seem
	 * bizarre, but it works like a charm!  - FM
	 *
	 * Actually, the location header for redirections is now again picked
	 * up in HTMIME.c.  But that's an internal matter between HTTP.c and
	 * HTMIME.c, is still under control of HTLoadHTTP for http URLs, is
	 * done in a way that doesn't load the redirection response's body
	 * (except when wanted as an error fallback), and thus need not concern
	 * us here.  - kw 1999-12-02
	 */
	CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		address_to_load));
	CTRACE((tfp, "HTAccess: Redirecting to '%s'\n",
		redirecting_url));
	/*
	 * Prevent circular references.
	 */
	if (strcmp(address_to_load, redirecting_url)) {		/* if different */
	    /*
	     * Load token and redirecting url into anchor->physical if we had
	     * 301 Permanent redirection.  HTTP.c does not allow this if we
	     * have POST content.  - FM
	     */
	    if (permanent_redirection) {
		StrAllocCopy(anchor->physical, "Location=");
		StrAllocCat(anchor->physical, redirecting_url);
	    }

	    /*
	     * Set up flags before return to getfile.  - FM
	     */
	    StrAllocCopy(use_this_url_instead, redirecting_url);
	    if (ForcingNoCache)
		LYforce_no_cache = YES;
	    ++redirection_attempts;
	    FREE(redirecting_url);
	    permanent_redirection = FALSE;
	    return (NO);
	}
	++redirection_attempts;
	FREE(redirecting_url);
	permanent_redirection = FALSE;
	return (YES);
    }

    /*
     * We did not receive a redirecting URL.  - FM
     */
    redirection_attempts = 0;
    FREE(redirecting_url);
    permanent_redirection = FALSE;

    if (status == HT_LOADED) {
	CTRACE((tfp, "HTAccess: `%s' has been accessed.\n",
		full_address));
	return YES;
    }
    if (status == HT_PARTIAL_CONTENT) {
	HTAlert(gettext("Loading incomplete."));
	CTRACE((tfp, "HTAccess: `%s' has been accessed, partial content.\n",
		full_address));
	return YES;
    }

    if (status == HT_NO_DATA) {
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data left.\n",
		full_address));
	return NO;
    }

    if (status == HT_NOT_LOADED) {
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data loaded.\n",
		full_address));
	return NO;
    }

    if (status == HT_INTERRUPTED) {
	CTRACE((tfp,
		"HTAccess: `%s' has been accessed, transfer interrupted.\n",
		full_address));
	return NO;
    }

    if (status > 0) {
	/*
	 * If you get this, then please find which routine is returning a
	 * positive unrecognized error code!
	 */
	fprintf(stderr,
		gettext("**** HTAccess: socket or file number returned by obsolete load routine!\n"));
	fprintf(stderr,
		gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@nongnu.org!\n"));
	fprintf(stderr, gettext("**** HTAccess: Status returned was: %d\n"), status);
	exit_immediately(EXIT_FAILURE);
    }

    /* Failure in accessing a document */
    cp = NULL;
    StrAllocCopy(cp, gettext("Can't Access"));
    StrAllocCat(cp, " `");
    StrAllocCat(cp, full_address);
    StrAllocCat(cp, "'");
    _HTProgress(cp);
    FREE(cp);

    CTRACE((tfp, "HTAccess: Can't access `%s'\n", full_address));
    HTLoadError(sink, 500, gettext("Unable to access document."));
    return NO;
}				/* HTLoadDocument */

/*	Load a document from absolute name.		HTLoadAbsolute()
 *	-----------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  filter   if YES, treat document as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadAbsolute(const DocAddress *docaddr)
{
    return HTLoadDocument(docaddr->address,
			  HTAnchor_findAddress(docaddr),
			  (HTOutputFormat ? HTOutputFormat : WWW_PRESENT),
			  HTOutputStream);
}

#ifdef NOT_USED_CODE
/*	Load a document from absolute name to stream.	HTLoadToStream()
 *	---------------------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  sink	   if non-NULL, send data down this stream
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadToStream(const char *addr,
		    BOOL filter,
		    HTStream *sink)
{
    return HTLoadDocument(addr,
			  HTAnchor_findSimpleAddress(addr),
			  (HTOutputFormat ? HTOutputFormat : WWW_PRESENT),
			  sink);
}
#endif /* NOT_USED_CODE */

/*	Load a document from relative name.		HTLoadRelative()
 *	-----------------------------------
 *
 *  On Entry,
 *	  relative_name     The relative address of the document
 *			    to be accessed.
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadRelative(const char *relative_name,
		    HTParentAnchor *here)
{
    DocAddress full_address;
    BOOL result;
    char *mycopy = NULL;
    char *stripped = NULL;

    full_address.address = NULL;
    full_address.post_data = NULL;
    full_address.post_content_type = NULL;
    full_address.bookmark = NULL;
    full_address.isHEAD = FALSE;
    full_address.safe = FALSE;

    StrAllocCopy(mycopy, relative_name);

    stripped = HTStrip(mycopy);
    full_address.address =
	HTParse(stripped,
		here->address,
		PARSE_ALL_WITHOUT_ANCHOR);
    result = HTLoadAbsolute(&full_address);
    /*
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  - FM
     */
    FREE(full_address.address);
    FREE(mycopy);		/* Memory leak fixed 10/7/92 -- JFG */
    return result;
}

/*	Load if necessary, and select an anchor.	HTLoadAnchor()
 *	----------------------------------------
 *
 *  On Entry,
 *	  destination		    The child or parent anchor to be loaded.
 *
 *  On Exit,
 *	  returns    YES     Success
 *		     NO      Failure
 */
BOOL HTLoadAnchor(HTAnchor * destination)
{
    HTParentAnchor *parent;
    BOOL loaded = NO;

    if (!destination)
	return NO;		/* No link */

    parent = HTAnchor_parent(destination);

    if (HTAnchor_document(parent) == NULL) {	/* If not already loaded */
	/* TBL 921202 */
	BOOL result;

	result = HTLoadDocument(parent->address,
				parent,
				HTOutputFormat ?
				HTOutputFormat : WWW_PRESENT,
				HTOutputStream);
	if (!result)
	    return NO;
	loaded = YES;
    } {
	HText *text = (HText *) HTAnchor_document(parent);

	if ((destination != (HTAnchor *) parent) &&
	    (destination != (HTAnchor *) (parent->parent))) {
	    /* If child anchor */
	    HText_selectAnchor(text,	/* Double display? @@@@ */
			       (HTChildAnchor *) destination);
	} else {
	    if (!loaded)
		HText_select(text);
	}
    }
    return YES;

}				/* HTLoadAnchor */

/*	Search.						HTSearch()
 *	-------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	 *keywords	space-separated keyword list or similar search list
 *	here		is anchor search is to be done on.
 */
static char hex(int i)
{
    const char *hexchars = "0123456789ABCDEF";

    return hexchars[i];
}

BOOL HTSearch(const char *keywords,
	      HTParentAnchor *here)
{
#define acceptable \
"1234567890abcdefghijlkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-_"

    char *q, *u;
    const char *p, *s, *e;	/* Pointers into keywords */
    char *address = NULL;
    BOOL result;
    char *escaped = typecallocn(char, (strlen(keywords) * 3) + 1);
    static const BOOL isAcceptable[96] =
    /* *INDENT-OFF* */
    /*	 0 1 2 3 4 5 6 7 8 9 A B C D E F */
    {	 0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,	/* 2x	!"#$%&'()*+,-./  */
	 1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,	/* 3x  0123456789:;<=>?  */
	 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	/* 4x  @@ABCDEFGHIJKLMNO  */
	 1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,	/* 5X  PQRSTUVWXYZ[\]^_  */
	 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	/* 6x  `abcdefghijklmno  */
	 1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };	/* 7X  pqrstuvwxyz{\}~	DEL */
    /* *INDENT-ON* */

    if (escaped == NULL)
	outofmem(__FILE__, "HTSearch");

    StrAllocCopy(address, here->isIndexAction);

    /*
     * Convert spaces to + and hex escape unacceptable characters.
     */
    for (s = keywords; *s && WHITE(*s); s++)	/* Scan */
	;			/* Skip white space */
    for (e = s + strlen(s); e > s && WHITE(*(e - 1)); e--)	/* Scan */
	;			/* Skip trailers */
    for (q = escaped, p = s; p < e; p++) {	/* Scan stripped field */
	unsigned char c = UCH(TOASCII(*p));

	if (WHITE(*p)) {
	    *q++ = '+';
	} else if (HTCJK != NOCJK) {
	    *q++ = *p;
	} else if (c >= 32 && c <= UCH(127) && isAcceptable[c - 32]) {
	    *q++ = *p;		/* 930706 TBL for MVS bug */
	} else {
	    *q++ = '%';
	    *q++ = hex((int) (c >> 4));
	    *q++ = hex((int) (c & 15));
	}
    }				/* Loop over string */
    *q = '\0';			/* Terminate escaped string */
    u = strchr(address, '?');	/* Find old search string */
    if (u != NULL)
	*u = '\0';		/* Chop old search off */

    StrAllocCat(address, "?");
    StrAllocCat(address, escaped);
    FREE(escaped);
    result = HTLoadRelative(address, here);
    FREE(address);

    /*
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  Only an http server (not a gopher or wais server) could
     * return redirection.  Lynx will go all the way back to its mainloop() and
     * subject a redirecting URL to all of its security and restrictions
     * checks.  - FM
     */
    return result;
}

/*	Search Given Indexname.			HTSearchAbsolute()
 *	-----------------------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	*keywords	space-separated keyword list or similar search list
 *	*indexname	is name of object search is to be done on.
 */
BOOL HTSearchAbsolute(const char *keywords,
		      char *indexname)
{
    DocAddress abs_doc;
    HTParentAnchor *anchor;

    abs_doc.address = indexname;
    abs_doc.post_data = NULL;
    abs_doc.post_content_type = NULL;
    abs_doc.bookmark = NULL;
    abs_doc.isHEAD = FALSE;
    abs_doc.safe = FALSE;

    anchor = HTAnchor_findAddress(&abs_doc);
    return HTSearch(keywords, anchor);
}

#ifdef NOT_USED_CODE
/*	Generate the anchor for the home page.		HTHomeAnchor()
 *	--------------------------------------
 *
 *	As it involves file access, this should only be done once
 *	when the program first runs.
 *	This is a default algorithm -- browser don't HAVE to use this.
 *	But consistency between browsers is STRONGLY recommended!
 *
 *  Priority order is:
 *		1	WWW_HOME environment variable (logical name, etc)
 *		2	~/WWW/default.html
 *		3	/usr/local/bin/default.html
 *		4	http://www.w3.org/default.html
 */
HTParentAnchor *HTHomeAnchor(void)
{
    char *my_home_document = NULL;
    char *home = LYGetEnv(LOGICAL_DEFAULT);
    char *ref;
    HTParentAnchor *anchor;

    if (home) {
	StrAllocCopy(my_home_document, home);
#define MAX_FILE_NAME 1024	/* @@@@@@ */
    } else if (HTClientHost) {	/* Telnet server */
	/*
	 * Someone telnets in, they get a special home.
	 */
	FILE *fp = fopen(REMOTE_POINTER, "r");
	char *status;

	if (fp) {
	    my_home_document = typecallocn(char, MAX_FILE_NAME);

	    if (my_home_document == NULL)
		outofmem(__FILE__, "HTHomeAnchor");
	    status = fgets(my_home_document, MAX_FILE_NAME, fp);
	    if (!status) {
		FREE(my_home_document);
	    }
	    fclose(fp);
	}
	if (my_home_document == NULL)
	    StrAllocCopy(my_home_document, REMOTE_ADDRESS);
    }
#ifdef UNIX
    if (my_home_document == NULL) {
	FILE *fp = NULL;
	char *home = LYGetEnv("HOME");

	if (home != 0) {
	    HTSprintf0(&my_home_document, "%s/%s", home, PERSONAL_DEFAULT);
	    fp = fopen(my_home_document, "r");
	}

	if (!fp) {
	    StrAllocCopy(my_home_document, LOCAL_DEFAULT_FILE);
	    fp = fopen(my_home_document, "r");
	}
	if (fp) {
	    fclose(fp);
	} else {
	    CTRACE((tfp, "HTBrowse: No local home document ~/%s or %s\n",
		    PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
	    FREE(my_home_document);
	}
    }
#endif /* UNIX */
    ref = HTParse((my_home_document ?
		   my_home_document : (HTClientHost ?
				       REMOTE_ADDRESS : LAST_RESORT)),
		  STR_FILE_URL,
		  PARSE_ALL_WITHOUT_ANCHOR);
    if (my_home_document) {
	CTRACE((tfp, "HTAccess: Using custom home page %s i.e., address %s\n",
		my_home_document, ref));
	FREE(my_home_document);
    }
    anchor = HTAnchor_findSimpleAddress(ref);
    FREE(ref);
    return anchor;
}
#endif /* NOT_USED_CODE */
@


1.8
log
@automatic merge of lynx-current
@
text
@d1080 1
a1080 1
	exit(EXIT_FAILURE);
d1245 1
a1245 1
    char *hexchars = "0123456789ABCDEF";
@


1.7
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 31
a32 31
**		==============
**
**  Authors
**	TBL	Tim Berners-Lee timbl@@info.cern.ch
**	JFG	Jean-Francois Groff jfg@@dxcern.cern.ch
**	DD	Denis DeLaRoca (310) 825-4580  <CSP1DWD@@mvs.oac.ucla.edu>
**	FM	Foteos Macrides macrides@@sci.wfeb.edu
**	PDM	Danny Mayer mayer@@ljo.dec.com
**
**  History
**	 8 Jun 92 Telnet hopping prohibited as telnet is not secure TBL
**	26 Jun 92 When over DECnet, suppressed FTP, Gopher and News. JFG
**	 6 Oct 92 Moved HTClientHost and logfile into here. TBL
**	17 Dec 92 Tn3270 added, bug fix. DD
**	 4 Feb 93 Access registration, Search escapes bad chars TBL
**		  PARAMETERS TO HTSEARCH AND HTLOADRELATIVE CHANGED
**	28 May 93 WAIS gateway explicit if no WAIS library linked in.
**	31 May 94 Added DIRECT_WAIS support for VMS. FM
**	27 Jan 95 Fixed proxy support to use NNTPSERVER for checking
**		  whether or not to use the proxy server. PDM
**	27 Jan 95 Ensured that proxy service will be overridden for files
**		  on the local host (because HTLoadFile() doesn't try ftp
**		  for those) and will substitute ftp for remote files. FM
**	28 Jan 95 Tweaked PDM's proxy override mods to handle port info
**		  for news and wais URL's. FM
**
**  Bugs
**	This module assumes that that the graphic object is hypertext, as it
**	needs to select it when it has been loaded.  A superclass needs to be
**	defined which accepts select and select_anchor.
*/
d42 2
a43 2
**  Implements:
*/
d47 2
a48 2
**  Uses:
*/
d57 1
a57 1
#include <HText.h>	/* See bugs above */
d68 6
a73 6
**  These flags may be set to modify the operation of this module
*/
char * HTClientHost = NULL; /* Name of remote login host if any */
FILE * HTlogfile = NULL;    /* File to which to output one-liners */
BOOL HTSecure = NO;	   /* Disable access for telnet users? */
BOOL HTPermitRedir = NO;	   /* Always allow redirection in getfile()? */
d75 1
a75 1
BOOL using_proxy = NO; /* are we using a proxy gateway? */
d78 2
a79 2
**  To generate other things, play with these:
*/
d81 1
a81 1
HTStream* HTOutputStream = NULL; /* For non-interactive, set this */
d83 1
a83 1
static HTList * protocols = NULL; /* List of registered protocol descriptors */
d87 2
a88 2
static int pushed_assume_LYhndl = -1; /* see LYUC* functions below - kw */
static char * pushed_assume_MIMEname = NULL;
d91 1
a91 1
static void free_protocols (void)
d95 1
a95 1
    FREE(pushed_assume_MIMEname); /* shouldn't happen, just in case - kw */
d100 3
a102 4
**	--------------------
*/
BOOL HTRegisterProtocol (
	HTProtocol *	protocol)
a113 1

d115 11
a125 11
**	-----------------------------
**
**	Add to or subtract from this list if you add or remove protocol
**	modules.  This routine is called the first time the protocol list
**	is needed, unless any protocols are already registered, in which
**	case it is not called.	Therefore the application can override
**	this list.
**
**	Compiling with NO_INIT prevents all known protocols from being
**	forced in at link time.
*/
d134 1
d161 1
d177 1
a177 1
GLOBALREF  HTProtocol HTWAIS;
d182 1
a182 1
static void HTAccessInit (void)			/* Call me once */
d219 16
a234 17
**	-------------------------
**
**	Check the no_proxy environment variable to get the list
**	of hosts for which proxy server is not consulted.
**
**	no_proxy is a comma- or space-separated list of machine
**	or domain names, with optional :port part.  If no :port
**	part is present, it applies to all ports on that domain.
**
**  Example:
**	    no_proxy="cern.ch,some.domain:8001"
**
**  Use "*" to override all proxy service:
**	     no_proxy="*"
*/
BOOL override_proxy (
	const char *	addr)
d236 6
a241 6
    const char * no_proxy = getenv("no_proxy");
    char * p = NULL;
    char * at = NULL;
    char * host = NULL;
    char * Host = NULL;
    char * acc_method = NULL;
d254 3
a256 4
     *	Never proxy file:// URLs if they are on the local host.
     *	HTLoadFile() will not attempt ftp for those if direct
     *	access fails.  We'll check that first, in case no_proxy
     *	hasn't been defined. - FM
d266 1
a266 1
    Host = (((at = strchr(host, '@@')) != NULL) ? (at+1) : host);
d285 1
a285 1
	*p++ = 0;				/* Chop off port */
d287 1
a287 1
    } else {					/* Use default port */
d290 1
d314 2
d320 1
a320 1
	port = 80;		    /* Default */
d324 2
a325 2
	const char * end;
	const char * colon = NULL;
d330 1
a330 1
	    no_proxy++;		    /* Skip whitespace and separators */
d334 2
a335 1
	    if (*end == ':') colon = end;		/* Port number given */
d340 1
a340 1
	    templ_port = atoi(colon+1);
d342 1
a342 2
	}
	else {
d346 2
a347 2
	if ((!templ_port || templ_port == port)  &&
	    (t_len > 0	&&  t_len <= h_len  &&
d352 3
a354 3
#ifdef CJK_EX	/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port)	 &&
	    (t_len > 0	&&  t_len <= h_len  &&
d359 1
a359 1
#endif	/* ASATAKU PROXY HACK */
d372 12
a383 13
**	--------------------------------------
**
**  On entry,
**	addr		must point to the fully qualified hypertext reference.
**	anchor		a parent anchor with whose address is addr
**
**  On exit,
**	returns		HT_NO_ACCESS		Error has occurred.
**			HT_OK			Success
*/
static int get_physical (
	const char *		addr,
	HTParentAnchor *	anchor)
d386 3
a388 3
    char * acc_method = NULL;	/* Name of access method */
    char * physical = NULL;
    char * Server_addr = NULL;
d394 2
a395 2
    **	Make sure the using_proxy variable is FALSE.
    */
d418 1
a418 1
    FREE(physical);			/* free our copy */
d425 1
a425 1
	FREE(physical);			/* free our copy */
d434 8
a441 8
    **	Check whether gateway access has been set up for this.
    **
    **	This function can be replaced by the rule system above.
    **
    **  If the rule system has already determined that we should
    **  use a proxy, or that we shouldn't, ignore proxy-related
    **  settings, don't use no_proxy either.
    */
d445 1
a445 1
    if (!override_flag && !using_proxy) {   /* else ignore no_proxy env var */
d448 3
a450 3
	    **  News is different, so we need to check the name of the server,
	    **  as well as the default port for selective exclusions.
	    */
d452 1
d467 3
a469 3
	    **  Wais also needs checking of the default port
	    **  for selective exclusions.
	    */
d471 1
d479 1
a479 2
	    }
	    else
d488 1
a488 1
	char * gateway_parameter = NULL, *gateway, *proxy;
d491 2
a492 2
	**  Search for gateways.
	*/
d494 1
a494 1
	gateway = LYGetEnv(gateway_parameter); /* coerce for decstation */
d497 2
a498 2
	**  Search for proxy servers.
	*/
d501 2
a502 2
	    ** If we got to here, a file URL is for ftp on a remote host. - FM
	    */
d515 2
a516 2
	**  Proxy servers have precedence over gateway servers.
	*/
d518 3
a520 2
	    char * gatewayed = NULL;
	    StrAllocCopy(gatewayed,proxy);
d523 1
d531 2
a532 2
	    ** Ensure that the proxy server uses ftp for file URLs. - FM
	    */
d549 6
a554 4
	    char * path = HTParse(addr, "",
		PARSE_HOST + PARSE_PATH + PARSE_PUNCTUATION);
		/* Chop leading / off to make host into part of path */
	    char * gatewayed = HTParse(path+1, gateway, PARSE_ALL);
d568 2
a569 2
    **	Search registered protocols to find suitable one.
    */
d573 1
d575 2
a576 1
	if (!protocols) HTAccessInit();
d580 2
a581 1
	    HTProtocol *p = (HTProtocol *)HTList_objectAt(protocols, i);
d596 5
a600 7
 *  Temporarily set the int UCLYhndl_for_unspec and string
 *  UCLYhndl_for_unspec used for charset "assuming" to the values
 *  implied by a HTParentAnchor's UCStages, after saving the current
 *  values for later restoration. - kw
 *  @@@@@@ These functions may not really belong here, but where else?
 *  I want the "pop" to occur as soon as possible after loading
 *  has finished. - kw @@@@@@
d602 1
a602 2
void LYUCPushAssumed (
    HTParentAnchor *	anchor)
d605 2
a606 1
    LYUCcharset * anchor_UCI = NULL;
d618 1
a618 1
	    StrAllocCopy(UCAssume_MIMEcharset, anchor_UCI->MIMEname);
d622 2
a623 1
	    CTRACE((tfp, "LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d633 1
d635 2
a636 3
 *  Restore the int UCLYhndl_for_unspec and string
 *  UCLYhndl_for_unspec used for charset "assuming" from the values
 *  saved by LYUCPushAssumed, if any. - kw
d638 1
a638 1
int LYUCPopAssumed (void)
d644 2
a645 1
	CTRACE((tfp, "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d659 19
a677 20
**	---------------
**
**	This is an internal routine, which has an address AND a matching
**	anchor.  (The public routines are called with one OR the other.)
**
**  On entry,
**	addr		must point to the fully qualified hypertext reference.
**	anchor		a parent anchor with whose address is addr
**
**  On exit,
**	returns		<0		Error has occurred.
**			HT_LOADED	Success
**			HT_NO_DATA	Success, but no document loaded.
**					(telnet session started etc)
*/
static int HTLoad (
	const char *		addr,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink)
d681 1
d683 1
a683 1
	 /* prevent crash if telnet or similar was forbidden by rule. - kw */
d687 1
a687 1
	return status;	/* fake redirection by rule, to redirecting_url */
d690 1
a690 1
	return status;	/* Can't resolve or forbidden */
d694 4
a697 4
    p = (HTProtocol *)HTAnchor_protocol(anchor);
    anchor->parent->underway = TRUE;		/* Hack to deal with caching */
    status= p->load(HTAnchor_physical(anchor),
			anchor, format_out, sink);
d704 3
a706 4
**	--------------------------------
*/
HTStream *HTSaveStream (
	HTParentAnchor *	anchor)
d708 2
a709 1
    HTProtocol *p = (HTProtocol *)HTAnchor_protocol(anchor);
d716 1
a716 1
int redirection_attempts = 0; /* counter in HTLoadDocument */
d719 20
a738 22
**	----------------------------------
**
**	- Checks or documents already loaded
**	- Logs the access
**	- Allows stdin filter option
**	- Trace output and error messages
**
**  On Entry,
**	  anchor	    is the node_anchor for the document
**	  full_address	    The address of the document to be accessed.
**	  filter	    if YES, treat stdin as HTML
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/

static BOOL HTLoadDocument (
	const char *		full_address, /* may include #fragment */
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream*		sink)
d740 3
a742 3
    int     status;
    HText * text;
    const char * address_to_load = full_address;
d749 3
a751 3
    **	Free use_this_url_instead and reset permanent_redirection
    **	if not done elsewhere. - FM
    */
d756 6
a761 8
    **	Make sure some yoyo doesn't send us 'round in circles
    **	with redirecting URLs that point back to themselves.
    **	We'll set the original Lynx limit of 10 redirections
    **	per requested URL from a user, because the HTTP/1.1
    **	will no longer specify a restriction to 5, but will
    **	leave it up to the browser's discretion, in deference
    **	to Microsoft.  - FM
    */
d769 8
a776 9
     *	If this is marked as an internal link but we don't have the
     *	document loaded any more, and we haven't explicitly flagged
     *	that we want to reload with LYforce_no_cache, then something
     *	has disappeared from the cache when we expected it to be still
     *	there.	The user probably doesn't expect a new network access.
     *	So if we have POST data and safe is not set in the anchor,
     *	ask for confirmation, and fail if not granted.	The exception
     *	are LYNXIMGMAP documents, for which we defer to LYLoadIMGmap
     *	for prompting if necessary. - kw
d778 1
a778 1
    text = (HText *)HTAnchor_document(anchor);
d788 6
a793 6
    **	If we don't have POST content, check whether this is a previous
    **	redirecting URL, and keep re-checking until we get to the final
    **	destination or redirection limit.  If we do have POST content,
    **	we didn't allow permanent redirection, and an interactive user
    **	will be deciding whether to keep redirecting. - FM
    */
d800 2
a801 2
			  anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp+9));
d804 2
a805 2
	    **	Don't exceed the redirection_attempts limit. - FM
	    */
d814 3
a816 3
	    ** Set up the redirection. - FM
	    **/
	    StrAllocCopy(use_this_url_instead, cp+9);
d827 3
a829 3
    **	If we had previous redirection, go back and check out
    **	that the URL under the current restrictions. - FM
    */
d832 1
a832 1
	return(NO);
d836 3
a838 3
    **	See if we can use an already loaded document.
    */
    text = (HText *)HTAnchor_document(anchor);
d841 46
a886 50
	**  We have a cached rendition of the target document.
	**  Check if it's OK to re-use it.  We consider it OK if:
	**   (1) the anchor does not have the no_cache element set, or
	**   (2) we've overridden it, e.g., because we are acting on
	**	 a PREV_DOC command or a link in the History Page and
	**	 it's not a reply from a POST with the LYresubmit_posts
	**	 flag set, or
	**   (3) we are repositioning within the currently loaded document
	**	 based on the target anchor's address (URL_Reference).
	*
	*    If DONT_TRACK_INTERNAL_LINKS is defined, HText_AreDifferent()
	*    is used to determine whether (3) applies.	If the target address
	*    differs from that of the current document only by a fragment
	*    and the target address has an appended fragment, repositioning
	*    without reloading is always assumed.
	*    Note that HText_AreDifferent() currently always returns TRUE
	*    if the target has a LYNXIMGMAP URL, so that an internally
	*    generated pseudo-document will normally not be re-used unless
	*    condition (2) applies. (Condition (1) cannot apply since in
	*    LYMap.c, no_cache is always set in the anchor object).  This
	*    doesn't guarantee that the resource from which the MAP element
	*    is taken will be read again (reloaded) when the list of links
	*    for a client-side image map is regenerated, when in some cases
	*    it should (e.g., user requested RELOAD, or HTTP response with
	*    no-cache header and we are not overriding).
	*
	*    If DONT_TRACK_INTERNAL_LINKS is undefined, a target address that
	*    points to the same URL as the current document may still result in
	*    reloading, depending on whether the original URL-Reference
	*    was given as an internal link in the context of the previously
	*    loaded document.  HText_AreDifferent() is not used here for
	*    testing whether we are just repositioning.  For an internal
	*    link, the potential callers of this function from mainloop()
	*    down will either avoid making the call (and do the repositioning
	*    differently) or set LYinternal_flag (or LYoverride_no_cache).
	*    Note that (a) LYNXIMGMAP pseudo-documents and (b) The "List Page"
	*    document are treated logically as being part of the document on
	*    which they are based, for the purpose of whether to treat a link
	*    as internal, but the logic for this (by setting LYinternal_flag
	*    as necessary) is implemented elsewhere.  There is a specific
	*    test for LYNXIMGMAP here so that the generated pseudo-document
	*    will not be re-used unless LYoverride_no_cache is set.  The same
	*    caveat as above applies w.r.t. reloading of the underlying
	*    resource.
	*
	**  We also should be checking other aspects of cache
	**  regulation (e.g., based on an If-Modified-Since check,
	**  etc.) but the code for doing those other things isn't
	**  available yet.
	*/
d895 1
a895 1
	) {
d920 5
a924 6
    **	Get the document from the net.	If we are auto-reloading,
    **	the mutable anchor elements from the previous rendition
    **	should be freed in conjunction with loading of the new
    **	rendition. - FM
    */
    LYforce_no_cache = NO;  /* reset after each time through */
d926 1
a926 1
	FREE(anchor->title);  /* ??? */
d932 2
a933 3
     *  RECOVERY:
     *  if the loading failed, and we had a cached HText copy,
     *  and no new HText created - use a previous copy, issue a warning.
d935 1
a935 1
    if (text && status < 0 && (HText *)HTAnchor_document(anchor) == text) {
d949 2
a950 2
    **	Log the access if necessary.
    */
d953 1
d962 4
a965 4
		    ctime(&theTime),
		    HTClientHost ? HTClientHost : "local",
		    status < 0 ? "FAIL" : "GET",
		    full_address));
d969 2
a970 2
    **	Check out what we received from the net.
    */
d972 2
a973 1
	/*  Exported from HTMIME.c, of all places. *//** NO!! - FM **/
d975 22
a996 23
	**  Doing this via HTMIME.c meant that the redirection cover
	**  page was already loaded before we learned that we want a
	**  different URL.  Also, changing anchor->address, as Lynx
	**  was doing, meant we could never again access its hash
	**  table entry, creating an insolvable memory leak.  Instead,
	**  if we had a 301 status and set permanent_redirection,
	**  we'll load the new URL in anchor->physical, preceded by a
	**  token, which we can check to make replacements on subsequent
	**  access attempts.  We'll check recursively, and retrieve the
	**  final URL if we had multiple redirections to it.  If we just
	**  went to HTLoad now, as Lou originally had this, we couldn't do
	**  Lynx's security checks and alternate handling of some URL types.
	**  So, instead, we'll go all the way back to the top of getfile
	**  in LYGetFile.c when the status is HT_REDIRECTING.  This may
	**  seem bizarre, but it works like a charm! - FM
	**
	**  Actually, the location header for redirections is now again
	**  picked up in HTMIME.c.  But that's an internal matter between
	**  HTTP.c and HTMIME.c, is still under control of HTLoadHTTP for
	**  http URLs, is done in a way that doesn't load the redirection
	**  response's body (except when wanted as an error fallback), and
	**  thus need not concern us here. - kw 1999-12-02
	*/
d998 1
a998 1
		    address_to_load));
d1000 1
a1000 1
		     redirecting_url));
d1002 3
a1004 3
	**  Prevent circular references.
	*/
	if (strcmp(address_to_load, redirecting_url)) { /* if different */
d1006 4
a1009 4
	    **	Load token and redirecting url into anchor->physical
	    **	if we had 301 Permanent redirection.  HTTP.c does not
	    **	allow this if we have POST content. - FM
	    */
d1016 2
a1017 2
	    **	Set up flags before return to getfile. - FM
	    */
d1024 1
a1024 1
	    return(NO);
d1029 1
a1029 1
	return(YES);
d1033 2
a1034 2
    **	We did not receive a redirecting URL. - FM
    */
d1041 1
a1041 1
		    full_address));
d1047 1
a1047 1
		    full_address));
d1053 1
a1053 1
		    full_address));
d1059 1
a1059 1
		    full_address));
d1064 3
a1066 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, transfer interrupted.\n",
		    full_address));
d1072 3
a1074 3
	**	If you get this, then please find which routine is returning
	**	a positive unrecognized error code!
	*/
d1076 1
a1076 1
 gettext("**** HTAccess: socket or file number returned by obsolete load routine!\n"));
d1078 2
a1079 2
 gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@sig.net!\n"));
	fprintf(stderr, gettext("**** HTAccess: Status returned was: %d\n"),status);
d1095 1
a1095 1
} /* HTLoadDocument */
d1098 11
a1108 12
**	-----------------------------------
**
**  On Entry,
**	  addr	   The absolute address of the document to be accessed.
**	  filter   if YES, treat document as HTML
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/
BOOL HTLoadAbsolute (
	const DocAddress *	docaddr)
d1118 13
a1130 14
**	---------------------------------------------
**
**  On Entry,
**	  addr	   The absolute address of the document to be accessed.
**	  sink	   if non-NULL, send data down this stream
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/
BOOL HTLoadToStream (
	const char *	addr,
	BOOL		filter,
	HTStream *	sink)
d1140 12
a1151 13
**	-----------------------------------
**
**  On Entry,
**	  relative_name     The relative address of the document
**			    to be accessed.
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/
BOOL HTLoadRelative (
	const char *		relative_name,
	HTParentAnchor *	here)
d1155 2
a1156 2
    char * mycopy = NULL;
    char * stripped = NULL;
d1169 3
a1171 3
		HTParse(stripped,
			here->address,
			PARSE_ALL_WITHOUT_ANCHOR);
d1174 4
a1177 4
    **	If we got redirection, result will be NO, but use_this_url_instead
    **	will be set.  The calling routine should check both and do whatever
    **	is appropriate. - FM
    */
d1179 1
a1179 1
    FREE(mycopy);  /* Memory leak fixed 10/7/92 -- JFG */
d1184 10
a1193 11
**	----------------------------------------
**
**  On Entry,
**	  destination		    The child or parent anchor to be loaded.
**
**  On Exit,
**	  returns    YES     Success
**		     NO      Failure
*/
BOOL HTLoadAnchor (
	HTAnchor *	destination)
d1195 1
a1195 1
    HTParentAnchor * parent;
d1197 1
d1199 1
a1199 1
	return NO;	/* No link */
d1204 1
a1204 1
						/* TBL 921202 */
d1212 2
a1213 1
	if (!result) return NO;
d1215 2
a1216 4
    }

    {
	HText *text = (HText*)HTAnchor_document(parent);
d1218 5
a1222 5
	if ((destination != (HTAnchor *)parent) &&
	    (destination != (HTAnchor *)(parent->parent))) {
						  /* If child anchor */
	    HText_selectAnchor(text,		  /* Double display? @@@@ */
			       (HTChildAnchor*)destination);
d1230 1
a1230 1
} /* HTLoadAnchor */
d1233 11
a1243 12
**	-------
**
**	Performs a keyword search on word given by the user.  Adds the
**	keyword to the end of the current address and attempts to open
**	the new address.
**
**  On Entry,
**	 *keywords	space-separated keyword list or similar search list
**	here		is anchor search is to be done on.
*/
static char hex (
    int		i)
d1245 2
a1246 1
    char * hexchars = "0123456789ABCDEF";
d1250 2
a1251 3
BOOL HTSearch (
	const char *		keywords,
	HTParentAnchor *	here)
d1257 2
a1258 2
    const char * p, *s, *e;		/* Pointers into keywords */
    char * address = NULL;
d1260 1
a1260 1
    char * escaped = typecallocn(char, (strlen(keywords)*3) + 1);
d1262 1
a1262 1

d1270 1
d1278 6
a1283 6
    **	Convert spaces to + and hex escape unacceptable characters.
    */
    for (s = keywords; *s && WHITE(*s); s++)		 /* Scan */
	;	/* Skip white space */
    for (e = s + strlen(s); e > s && WHITE(*(e-1)); e--) /* Scan */
	;	/* Skip trailers */
d1286 1
d1291 2
a1292 2
	} else if (c>=32 && c<=UCH(127) && isAcceptable[c-32]) {
	    *q++ = *p;				/* 930706 TBL for MVS bug */
d1295 2
a1296 2
	    *q++ = hex((int)(c >> 4));
	    *q++ = hex((int)(c & 15));
d1311 7
a1317 7
    **	If we got redirection, result will be NO, but use_this_url_instead
    **	will be set.  The calling routine should check both and do whatever
    **	is appropriate.  Only an http server (not a gopher or wais server)
    **	could return redirection.  Lynx will go all the way back to its
    **	mainloop() and subject a redirecting URL to all of its security and
    **	restrictions checks. - FM
    */
d1322 12
a1333 13
**	-----------------------
**
**	Performs a keyword search on word given by the user.  Adds the
**	keyword to the end of the current address and attempts to open
**	the new address.
**
**  On Entry,
**	*keywords	space-separated keyword list or similar search list
**	*indexname	is name of object search is to be done on.
*/
BOOL HTSearchAbsolute (
	const char *	keywords,
	char *		indexname)
d1336 2
a1337 1
    HTParentAnchor * anchor;
d1351 14
a1364 14
**	--------------------------------------
**
**	As it involves file access, this should only be done once
**	when the program first runs.
**	This is a default algorithm -- browser don't HAVE to use this.
**	But consistency between browsers is STRONGLY recommended!
**
**  Priority order is:
**		1	WWW_HOME environment variable (logical name, etc)
**		2	~/WWW/default.html
**		3	/usr/local/bin/default.html
**		4	http://www.w3.org/default.html
*/
HTParentAnchor * HTHomeAnchor (void)
d1366 4
a1369 4
    char * my_home_document = NULL;
    char * home = LYGetEnv(LOGICAL_DEFAULT);
    char * ref;
    HTParentAnchor * anchor;
d1373 2
a1374 2
#define MAX_FILE_NAME 1024			/* @@@@@@ */
    } else if (HTClientHost) {			/* Telnet server */
d1376 5
a1380 4
	**  Someone telnets in, they get a special home.
	*/
	FILE * fp = fopen(REMOTE_POINTER, "r");
	char * status;
d1383 1
a1394 1

d1397 3
a1399 2
	FILE * fp = NULL;
	char * home = LYGetEnv("HOME");
d1413 1
a1413 1
			PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
d1420 1
a1420 1
				     REMOTE_ADDRESS : LAST_RESORT)),
d1425 1
a1425 1
		    my_home_document, ref));
@


1.6
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d70 4
a73 4
PUBLIC char * HTClientHost = NULL; /* Name of remote login host if any */
PUBLIC FILE * HTlogfile = NULL;    /* File to which to output one-liners */
PUBLIC BOOL HTSecure = NO;	   /* Disable access for telnet users? */
PUBLIC BOOL HTPermitRedir = NO;	   /* Always allow redirection in getfile()? */
d75 1
a75 1
PUBLIC BOOL using_proxy = NO; /* are we using a proxy gateway? */
d80 2
a81 2
PUBLIC HTFormat HTOutputFormat = NULL;
PUBLIC HTStream* HTOutputStream = NULL; /* For non-interactive, set this */
d83 1
a83 1
PRIVATE HTList * protocols = NULL; /* List of registered protocol descriptors */
d85 1
a85 1
PUBLIC char *use_this_url_instead = NULL;
d87 2
a88 2
PRIVATE int pushed_assume_LYhndl = -1; /* see LYUC* functions below - kw */
PRIVATE char * pushed_assume_MIMEname = NULL;
d91 1
a91 1
PRIVATE void free_protocols NOARGS
d102 2
a103 2
PUBLIC BOOL HTRegisterProtocol ARGS1(
	HTProtocol *,	protocol)
d182 1
a182 1
PRIVATE void HTAccessInit NOARGS			/* Call me once */
d234 2
a235 2
PUBLIC BOOL override_proxy ARGS1(
	CONST char *,	addr)
d237 1
a237 1
    CONST char * no_proxy = getenv("no_proxy");
d323 2
a324 2
	CONST char * end;
	CONST char * colon = NULL;
d381 3
a383 3
PRIVATE int get_physical ARGS2(
	CONST char *,		addr,
	HTParentAnchor *,	anchor)
d596 2
a597 2
PUBLIC void LYUCPushAssumed ARGS1(
    HTParentAnchor *,	anchor)
d631 1
a631 1
PUBLIC int LYUCPopAssumed NOARGS
d666 5
a670 5
PRIVATE int HTLoad ARGS4(
	CONST char *,		addr,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
d698 2
a699 2
PUBLIC HTStream *HTSaveStream ARGS1(
	HTParentAnchor *,	anchor)
d708 1
a708 1
PUBLIC int redirection_attempts = 0; /* counter in HTLoadDocument */
d728 5
a732 5
PRIVATE BOOL HTLoadDocument ARGS4(
	CONST char *,		full_address, /* may include #fragment */
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d736 1
a736 1
    CONST char * address_to_load = full_address;
d1109 2
a1110 2
PUBLIC BOOL HTLoadAbsolute ARGS1(
	CONST DocAddress *,	docaddr)
d1130 4
a1133 4
PUBLIC BOOL HTLoadToStream ARGS3(
	CONST char *,	addr,
	BOOL,		filter,
	HTStream *,	sink)
d1153 3
a1155 3
PUBLIC BOOL HTLoadRelative ARGS2(
	CONST char *,		relative_name,
	HTParentAnchor *,	here)
d1197 2
a1198 2
PUBLIC BOOL HTLoadAnchor ARGS1(
	HTAnchor *,	destination)
d1248 2
a1249 2
PRIVATE char hex ARGS1(
    int,		i)
d1255 3
a1257 3
PUBLIC BOOL HTSearch ARGS2(
	CONST char *,		keywords,
	HTParentAnchor *,	here)
d1263 1
a1263 1
    CONST char * p, *s, *e;		/* Pointers into keywords */
d1267 1
a1267 1
    static CONST BOOL isAcceptable[96] =
d1336 3
a1338 3
PUBLIC BOOL HTSearchAbsolute ARGS2(
	CONST char *,	keywords,
	char *,		indexname)
d1368 1
a1368 1
PUBLIC HTParentAnchor * HTHomeAnchor NOARGS
@


1.5
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d729 1
a729 1
	CONST char *,		full_address,
d734 2
a735 2
    int		status;
    HText *	text;
d775 2
a776 1
    if (LYinternal_flag && !LYforce_no_cache &&
a777 1
	(text = (HText *)HTAnchor_document(anchor)) == NULL &&
d835 2
a836 1
    if (!LYforce_no_cache && (text = (HText *)HTAnchor_document(anchor))) {
d888 1
d890 2
a891 2
	if (LYoverride_no_cache || !HText_hasNoCacheSet(text) ||
	    !HText_AreDifferent(anchor, full_address))
a892 1
	if (LYoverride_no_cache ||
d894 1
a894 1
	     !isLYNXIMGMAP(full_address)))
d896 1
a896 1
	{
d912 8
d928 1
a928 1
	FREE(anchor->title);
d934 18
d1136 1
a1136 1
			  HTAnchor_findAddress(addr),
d1175 1
a1175 1
			PARSE_ACCESS|PARSE_HOST|PARSE_PATH|PARSE_PUNCTUATION);
@


1.4
log
@from OpenBSD:
- spelling fixes (deraadt)
@
text
@d25 1
a25 1
**	28 Jan 95 Tweeked PDM's proxy override mods to handle port info
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d716 1
a716 1
**	- Trace ouput and error messages
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a66 2
extern HTCJKlang HTCJK;

d73 1
d272 2
a273 7
	    (!strcmp(Host, "localhost") ||
#ifdef VMS
	     !strcasecomp(Host, HTHostName())
#else
	     !strcmp(Host, HTHostName())
#endif /* VMS */
	)) {
d312 3
d351 9
d385 1
d389 8
d399 4
a402 2
    physical = HTTranslate(addr);
    if (!physical) {
d407 10
a416 1
	CTRACE(tfp, "HTAccess: Appending '?0,0' coordinate pair.\n");
a417 1
    HTAnchor_setPhysical(anchor, physical);
d423 1
a423 1
	CTRACE(tfp, "HTAccess: Appending '?0,0' coordinate pair.\n");
d431 1
a431 2
    acc_method =  HTParse(HTAnchor_physical(anchor),
		"file:", PARSE_ACCESS);
d437 4
a443 4
    /*
    **	Make sure the using_proxy variable is FALSE.
    */
    using_proxy = NO;
d445 15
a459 8
    if (!strcasecomp(acc_method, "news")) {
	/*
	**  News is different, so we need to check the name of the server,
	**  as well as the default port for selective exclusions.
	*/
	char *host = NULL;
	if ((host = HTParse(addr, "", PARSE_HOST))) {
	    if (strchr(host, ':') == NULL) {
d461 1
a461 1
		StrAllocCat(Server_addr, host);
d464 13
a476 17
	    FREE(host);
	} else if (getenv("NNTPSERVER") != NULL) {
	    StrAllocCopy(Server_addr, "news://");
	    StrAllocCat(Server_addr, (char *)getenv("NNTPSERVER"));
	    StrAllocCat(Server_addr, ":119/");
	 }
    } else if (!strcasecomp(acc_method, "wais")) {
	/*
	**  Wais also needs checking of the default port
	**  for selective exclusions.
	*/
	char *host = NULL;
	if ((host = HTParse(addr, "", PARSE_HOST))) {
	    if (!(strchr(host, ':'))) {
		StrAllocCopy(Server_addr, "wais://");
		StrAllocCat(Server_addr, host);
		StrAllocCat(Server_addr, ":210/");
d478 4
a481 1
	    FREE(host);
d483 1
a483 4
	else
	    StrAllocCopy(Server_addr, addr);
    } else {
	StrAllocCopy(Server_addr, addr);
d486 2
a487 2
    if (!override_proxy(Server_addr)) {
	char * gateway_parameter, *gateway, *proxy;
d492 2
a493 7
	gateway_parameter = (char *)calloc(1, (strlen(acc_method) + 20));
	if (gateway_parameter == NULL)
	    outofmem(__FILE__, "HTLoad");
	strcpy(gateway_parameter, "WWW_");
	strcat(gateway_parameter, acc_method);
	strcat(gateway_parameter, "_GATEWAY");
	gateway = (char *)getenv(gateway_parameter); /* coerce for decstation */
d502 1
a502 1
	    strcpy(gateway_parameter, "ftp");
d504 2
a505 3
	    strcpy(gateway_parameter, acc_method);
	strcat(gateway_parameter, "_proxy");
	proxy = (char *)getenv(gateway_parameter);
d509 1
a509 1
	    CTRACE(tfp, "Gateway found: %s\n", gateway);
d511 1
a511 1
	    CTRACE(tfp, "proxy server found: %s\n", proxy);
d519 8
d542 2
a543 2
	    acc_method =  HTParse(HTAnchor_physical(anchor),
		"http:", PARSE_ACCESS);
d555 2
a556 2
	    acc_method =  HTParse(HTAnchor_physical(anchor),
		"http:", PARSE_ACCESS);
d565 1
d577 2
a578 1
		return (HT_OK);
d584 1
a584 1
    return HT_NO_ACCESS;
a595 3

extern char*UCAssume_MIMEcharset;

d609 3
d616 1
a616 1
	    CTRACE(tfp, "LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d618 1
a618 1
			anchor_LYhndl);
d637 1
a637 1
	CTRACE(tfp, "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d639 1
a639 1
		    pushed_assume_LYhndl);
d675 2
d678 2
d684 2
d687 2
a688 2
    anchor->underway = TRUE;		/* Hack to deal with caching */
    status= (*(p->load))(HTAnchor_physical(anchor),
d690 1
a690 1
    anchor->underway = FALSE;
d705 1
a705 1
    return (*p->saveStream)(anchor);
d708 2
d716 1
a716 1
**	- Trace output and error messages
a738 1
    static int redirection_attempts = 0;
d740 1
a740 1
    CTRACE (tfp, "HTAccess: loading document %s\n", address_to_load);
d778 1
a778 1
	strncmp(full_address, "LYNXIMGMAP:", 11) &&
d796 3
a798 3
	    CTRACE (tfp, "HTAccess: '%s' is a redirection URL.\n",
			  anchor->address);
	    CTRACE (tfp, "HTAccess: Redirecting to '%s'\n", cp+9);
d820 1
a820 1
	    anchor = (HTParentAnchor *)HTAnchor_findAddress(&NewDoc);
d893 1
a893 1
	     strncmp(full_address, "LYNXIMGMAP:", 11)))
d896 1
a896 1
	    CTRACE(tfp, "HTAccess: Document already in memory.\n");
d907 1
a907 1
	    CTRACE(tfp, "HTAccess: Auto-reloading document.\n");
d922 1
a922 1
    CTRACE(tfp, "HTAccess:  status=%d\n", status);
d936 1
a936 1
	CTRACE(tfp, "Log: %24.24s %s %s %s\n",
d940 1
a940 1
		    full_address);
d964 7
d972 4
a975 4
	CTRACE(tfp, "HTAccess: '%s' is a redirection URL.\n",
		    address_to_load);
	CTRACE(tfp, "HTAccess: Redirecting to '%s'\n",
		     redirecting_url);
d1015 2
a1016 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed.\n",
		    full_address);
d1021 2
a1022 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, partial content.\n",
		    full_address);
d1027 2
a1028 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, No data left.\n",
		    full_address);
d1033 2
a1034 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, No data loaded.\n",
		    full_address);
d1039 2
a1040 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, transfer interrupted.\n",
		    full_address);
d1052 1
a1052 1
 gettext("**** HTAccess: Internal software error.  Please mail lynx_dev@@sig.net!\n"));
d1054 1
a1054 1
	exit(-1);
d1066 1
a1066 1
    CTRACE(tfp, "HTAccess: Can't access `%s'\n", full_address);
d1086 1
a1086 1
			  HTAnchor_parent(HTAnchor_findAddress(docaddr)),
d1109 1
a1109 1
			  HTAnchor_parent(HTAnchor_findAddress(addr)),
a1133 1
    char * current_address = HTAnchor_address((HTAnchor*)here);
d1147 1
a1147 1
			current_address,
a1155 1
    FREE(current_address);
a1182 1
	char * address = HTAnchor_address((HTAnchor*) parent);
d1184 1
a1184 1
	result = HTLoadDocument(address,
a1188 1
	FREE(address);
d1196 3
a1198 1
	if (destination != (HTAnchor *)parent) {  /* If child anchor */
d1239 1
a1239 1
    char * escaped = (char *)calloc(1, ((strlen(keywords)*3) + 1));
d1263 1
a1263 1
	unsigned char c = (unsigned char)TOASCII(*p);
d1268 1
a1268 1
	} else if (c>=32 && c<=(unsigned char)127 && isAcceptable[c-32]) {
d1322 1
a1322 1
    anchor = (HTParentAnchor*)HTAnchor_findAddress(&abs_doc);
d1344 1
a1344 1
    char * home = (char *)getenv(LOGICAL_DEFAULT);
d1358 1
a1358 1
	    my_home_document = (char*)calloc(1, MAX_FILE_NAME);
d1371 1
a1371 1
#ifdef unix
d1374 2
a1375 2
	CONST char * home =  (CONST char*)getenv("HOME");
	if (home != null) {
d1387 2
a1388 2
	    CTRACE(tfp, "HTBrowse: No local home document ~/%s or %s\n",
			PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE);
d1392 1
a1392 1
#endif /* unix */
d1396 2
a1397 2
		  "file:",
		  PARSE_ACCESS|PARSE_HOST|PARSE_PATH|PARSE_PUNCTUATION);
d1399 2
a1400 2
	CTRACE(tfp, "HTAccess: Using custom home page %s i.e., address %s\n",
		    my_home_document, ref);
d1403 1
a1403 1
    anchor = (HTParentAnchor*)HTAnchor_findAddress(ref);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 31
a32 31
 *		==============
 *
 *  Authors
 *	TBL	Tim Berners-Lee timbl@@info.cern.ch
 *	JFG	Jean-Francois Groff jfg@@dxcern.cern.ch
 *	DD	Denis DeLaRoca (310) 825-4580  <CSP1DWD@@mvs.oac.ucla.edu>
 *	FM	Foteos Macrides macrides@@sci.wfeb.edu
 *	PDM	Danny Mayer mayer@@ljo.dec.com
 *
 *  History
 *	 8 Jun 92 Telnet hopping prohibited as telnet is not secure TBL
 *	26 Jun 92 When over DECnet, suppressed FTP, Gopher and News. JFG
 *	 6 Oct 92 Moved HTClientHost and logfile into here. TBL
 *	17 Dec 92 Tn3270 added, bug fix. DD
 *	 4 Feb 93 Access registration, Search escapes bad chars TBL
 *		  PARAMETERS TO HTSEARCH AND HTLOADRELATIVE CHANGED
 *	28 May 93 WAIS gateway explicit if no WAIS library linked in.
 *	31 May 94 Added DIRECT_WAIS support for VMS. FM
 *	27 Jan 95 Fixed proxy support to use NNTPSERVER for checking
 *		  whether or not to use the proxy server. PDM
 *	27 Jan 95 Ensured that proxy service will be overridden for files
 *		  on the local host (because HTLoadFile() doesn't try ftp
 *		  for those) and will substitute ftp for remote files. FM
 *	28 Jan 95 Tweaked PDM's proxy override mods to handle port info
 *		  for news and wais URL's. FM
 *
 *  Bugs
 *	This module assumes that that the graphic object is hypertext, as it
 *	needs to select it when it has been loaded.  A superclass needs to be
 *	defined which accepts select and select_anchor.
 */
d42 2
a43 2
 *  Implements:
 */
d47 2
a48 2
 *  Uses:
 */
d57 1
a57 1
#include <HText.h>		/* See bugs above */
d67 2
d70 5
a74 6
 *  These flags may be set to modify the operation of this module
 */
char *HTClientHost = NULL;	/* Name of remote login host if any */
FILE *HTlogfile = NULL;		/* File to which to output one-liners */
BOOL HTSecure = NO;		/* Disable access for telnet users? */
BOOL HTPermitRedir = NO;	/* Always allow redirection in getfile()? */
d76 1
a76 1
BOOL using_proxy = NO;		/* are we using a proxy gateway? */
d79 4
a82 4
 *  To generate other things, play with these:
 */
HTFormat HTOutputFormat = NULL;
HTStream *HTOutputStream = NULL;	/* For non-interactive, set this */
d84 1
a84 1
static HTList *protocols = NULL;	/* List of registered protocol descriptors */
d86 1
a86 1
char *use_this_url_instead = NULL;
d88 2
a89 2
static int pushed_assume_LYhndl = -1;	/* see LYUC* functions below - kw */
static char *pushed_assume_MIMEname = NULL;
d92 1
a92 1
static void free_protocols(void)
d96 1
a96 1
    FREE(pushed_assume_MIMEname);	/* shouldn't happen, just in case - kw */
d101 4
a104 3
 *	--------------------
 */
BOOL HTRegisterProtocol(HTProtocol * protocol)
d116 1
d118 11
a128 11
 *	-----------------------------
 *
 *	Add to or subtract from this list if you add or remove protocol
 *	modules.  This routine is called the first time the protocol list
 *	is needed, unless any protocols are already registered, in which
 *	case it is not called.	Therefore the application can override
 *	this list.
 *
 *	Compiling with NO_INIT prevents all known protocols from being
 *	forced in at link time.
 */
a136 1

a162 1

d178 1
a178 1
GLOBALREF HTProtocol HTWAIS;
d183 1
a183 1
static void HTAccessInit(void)	/* Call me once */
d220 17
a236 16
 *	-------------------------
 *
 *	Check the no_proxy environment variable to get the list
 *	of hosts for which proxy server is not consulted.
 *
 *	no_proxy is a comma- or space-separated list of machine
 *	or domain names, with optional :port part.  If no :port
 *	part is present, it applies to all ports on that domain.
 *
 *  Example:
 *	    no_proxy="cern.ch,some.domain:8001"
 *
 *  Use "*" to override all proxy service:
 *	     no_proxy="*"
 */
BOOL override_proxy(const char *addr)
d238 6
a243 6
    const char *no_proxy = getenv("no_proxy");
    char *p = NULL;
    char *at = NULL;
    char *host = NULL;
    char *Host = NULL;
    char *acc_method = NULL;
d256 4
a259 3
     * Never proxy file:// URLs if they are on the local host.  HTLoadFile()
     * will not attempt ftp for those if direct access fails.  We'll check that
     * first, in case no_proxy hasn't been defined.  - FM
d269 1
a269 1
    Host = (((at = strchr(host, '@@')) != NULL) ? (at + 1) : host);
d273 7
a279 2
	    (LYSameHostname(Host, "localhost") ||
	     LYSameHostname(Host, HTHostName()))) {
d293 1
a293 1
	*p++ = 0;		/* Chop off port */
d295 1
a295 1
    } else {			/* Use default port */
a297 1
	    /* *INDENT-OFF* */
a317 5
	    else if (!strcmp(acc_method, "telnet"))	port = 23;
	    else if (!strcmp(acc_method, "tn3270"))	port = 23;
	    else if (!strcmp(acc_method, "rlogin"))	port = 513;
	    /* *INDENT-ON* */

d322 1
a322 1
	port = 80;		/* Default */
d326 2
a327 2
	const char *end;
	const char *colon = NULL;
d332 1
a332 1
	    no_proxy++;		/* Skip whitespace and separators */
d336 1
a336 2
	    if (*end == ':')
		colon = end;	/* Port number given */
d341 1
a341 1
	    templ_port = atoi(colon + 1);
d343 2
a344 1
	} else {
d348 2
a349 2
	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
a353 9
#ifdef CJK_EX			/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
	     isdigit(UCH(*no_proxy)) && !strncmp(host, no_proxy, t_len))) {
	    FREE(host);
	    return YES;
	}
#endif /* ASATAKU PROXY HACK */

d365 13
a377 12
 *	--------------------------------------
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		HT_NO_ACCESS		Error has occurred.
 *			HT_OK			Success
 */
static int get_physical(const char *addr,
			HTParentAnchor *anchor)
d379 3
a381 12
    int result;
    char *acc_method = NULL;	/* Name of access method */
    char *physical = NULL;
    char *Server_addr = NULL;
    BOOL override_flag = NO;

    CTRACE((tfp, "get_physical %s\n", addr));

    /*
     * Make sure the using_proxy variable is FALSE.
     */
    using_proxy = NO;
d384 2
a385 4
    if ((physical = HTTranslate(addr)) == 0) {
	if (redirecting_url) {
	    return HT_REDIRECTING;
	}
d390 1
a390 1
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
d392 2
a393 10
    if (!strncmp(physical, "Proxied=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	using_proxy = YES;
    } else if (!strncmp(physical, "NoProxy=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	override_flag = YES;
    } else {
	HTAnchor_setPhysical(anchor, physical);
    }
    FREE(physical);		/* free our copy */
d398 1
a398 1
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
d400 1
a400 1
	FREE(physical);		/* free our copy */
d406 2
a407 1
    acc_method = HTParse(HTAnchor_physical(anchor), STR_FILE_URL, PARSE_ACCESS);
d410 4
a413 8
     * Check whether gateway access has been set up for this.
     *
     * This function can be replaced by the rule system above.
     *
     * If the rule system has already determined that we should use a proxy, or
     * that we shouldn't, ignore proxy-related settings, don't use no_proxy
     * either.
     */
d416 4
d421 8
a428 16
    if (!override_flag && !using_proxy) {	/* else ignore no_proxy env var */
	if (!strcasecomp(acc_method, "news")) {
	    /*
	     * News is different, so we need to check the name of the server,
	     * as well as the default port for selective exclusions.
	     */
	    char *host = NULL;

	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (strchr(host, ':') == NULL) {
		    StrAllocCopy(Server_addr, "news://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":119/");
		}
		FREE(host);
	    } else if (LYGetEnv("NNTPSERVER") != NULL) {
d430 1
a430 1
		StrAllocCat(Server_addr, LYGetEnv("NNTPSERVER"));
d433 21
a453 17
	} else if (!strcasecomp(acc_method, "wais")) {
	    /*
	     * Wais also needs checking of the default port for selective
	     * exclusions.
	     */
	    char *host = NULL;

	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (!(strchr(host, ':'))) {
		    StrAllocCopy(Server_addr, "wais://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":210/");
		}
		FREE(host);
	    } else
		StrAllocCopy(Server_addr, addr);
	} else {
d455 2
a456 2
	}
	override_flag = override_proxy(Server_addr);
d459 2
a460 2
    if (!override_flag && !using_proxy) {
	char *gateway_parameter = NULL, *gateway, *proxy;
d463 9
a471 4
	 * Search for gateways.
	 */
	HTSprintf0(&gateway_parameter, "WWW_%s_GATEWAY", acc_method);
	gateway = LYGetEnv(gateway_parameter);	/* coerce for decstation */
d474 2
a475 2
	 * Search for proxy servers.
	 */
d478 3
a480 3
	     * If we got to here, a file URL is for ftp on a remote host. - FM
	     */
	    strcpy(gateway_parameter, "ftp_proxy");
d482 3
a484 2
	    sprintf(gateway_parameter, "%s_proxy", acc_method);
	proxy = LYGetEnv(gateway_parameter);
d488 1
a488 1
	    CTRACE((tfp, "Gateway found: %s\n", gateway));
d490 1
a490 1
	    CTRACE((tfp, "proxy server found: %s\n", proxy));
d493 2
a494 2
	 * Proxy servers have precedence over gateway servers.
	 */
d496 2
a497 12
	    char *gatewayed = NULL;

	    StrAllocCopy(gatewayed, proxy);
	    if (!strncmp(gatewayed, "http", 4)) {
		char *cp = strrchr(gatewayed, '/');

		/* Append a slash to the proxy specification if it doesn't
		 * end in one but otherwise looks normal (starts with "http",
		 * has no '/' other than ones before the hostname). - kw */
		if (cp && (cp - gatewayed) <= 7)
		    LYAddHtmlSep(&gatewayed);
	    }
d499 2
a500 2
	     * Ensure that the proxy server uses ftp for file URLs. - FM
	     */
d513 2
a514 2
	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);
d517 4
a520 6
	    char *path = HTParse(addr, "",
				 PARSE_HOST + PARSE_PATH + PARSE_PUNCTUATION);

	    /* Chop leading / off to make host into part of path */
	    char *gatewayed = HTParse(path + 1, gateway, PARSE_ALL);

d526 2
a527 2
	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);
d534 2
a535 3
     * Search registered protocols to find suitable one.
     */
    result = HT_NO_ACCESS;
a537 1

d539 1
a539 2
	if (!protocols)
	    HTAccessInit();
d543 1
a543 2
	    HTProtocol *p = (HTProtocol *) HTList_objectAt(protocols, i);

d547 1
a547 2
		result = HT_OK;
		break;
d553 1
a553 1
    return result;
d557 7
a563 5
 * Temporarily set the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec
 * used for charset "assuming" to the values implied by a HTParentAnchor's
 * UCStages, after saving the current values for later restoration.  - kw @@@@@@
 * These functions may not really belong here, but where else?  I want the
 * "pop" to occur as soon as possible after loading has finished.  - kw @@@@@@
d565 5
a569 1
void LYUCPushAssumed(HTParentAnchor *anchor)
d572 1
a572 2
    LYUCcharset *anchor_UCI = NULL;

d581 1
a581 4
	    if (HTCJK == JAPANESE)
		StrAllocCopy(UCAssume_MIMEcharset, pushed_assume_MIMEname);
	    else
		StrAllocCopy(UCAssume_MIMEcharset, anchor_UCI->MIMEname);
d585 1
a585 2
		CTRACE((tfp,
			"LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d587 1
a587 1
			anchor_LYhndl));
a594 1

d596 3
a598 2
 * Restore the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec used for
 * charset "assuming" from the values saved by LYUCPushAssumed, if any.  - kw
d600 1
a600 1
int LYUCPopAssumed(void)
d606 1
a606 2
	    CTRACE((tfp,
		    "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d608 1
a608 1
		    pushed_assume_LYhndl));
d620 20
a639 19
 *	---------------
 *
 *	This is an internal routine, which has an address AND a matching
 *	anchor.  (The public routines are called with one OR the other.)
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		<0		Error has occurred.
 *			HT_LOADED	Success
 *			HT_NO_DATA	Success, but no document loaded.
 *					(telnet session started etc)
 */
static int HTLoad(const char *addr,
		  HTParentAnchor *anchor,
		  HTFormat format_out,
		  HTStream *sink)
a642 1

a643 2
	/* prevent crash if telnet or similar was forbidden by rule. - kw */
	LYFixCursesOn("show alert:");
a644 2
    } else if (status == HT_REDIRECTING) {
	return status;		/* fake redirection by rule, to redirecting_url */
d647 1
a647 1
	return status;		/* Can't resolve or forbidden */
d649 5
a653 7
    /* prevent crash if telnet or similar mapped or proxied by rule. - kw */
    LYFixCursesOnForAccess(addr, HTAnchor_physical(anchor));
    p = (HTProtocol *) HTAnchor_protocol(anchor);
    anchor->parent->underway = TRUE;	/* Hack to deal with caching */
    status = p->load(HTAnchor_physical(anchor),
		     anchor, format_out, sink);
    anchor->parent->underway = FALSE;
d659 4
a662 3
 *	--------------------------------
 */
HTStream *HTSaveStream(HTParentAnchor *anchor)
d664 1
a664 2
    HTProtocol *p = (HTProtocol *) HTAnchor_protocol(anchor);

d668 1
a668 1
    return p->saveStream(anchor);
a670 2
int redirection_attempts = 0;	/* counter in HTLoadDocument */

d672 22
a693 20
 *	----------------------------------
 *
 *	- Checks or documents already loaded
 *	- Logs the access
 *	- Allows stdin filter option
 *	- Trace output and error messages
 *
 *  On Entry,
 *	  anchor	    is the node_anchor for the document
 *	  full_address	    The address of the document to be accessed.
 *	  filter	    if YES, treat stdin as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
static BOOL HTLoadDocument(const char *full_address,	/* may include #fragment */
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
d695 3
a697 3
    int status;
    HText *text;
    const char *address_to_load = full_address;
d700 1
d702 1
a702 1
    CTRACE((tfp, "HTAccess: loading document %s\n", address_to_load));
d705 3
a707 3
     * Free use_this_url_instead and reset permanent_redirection if not done
     * elsewhere.  - FM
     */
d712 8
a719 6
     * Make sure some yoyo doesn't send us 'round in circles with redirecting
     * URLs that point back to themselves.  We'll set the original Lynx limit
     * of 10 redirections per requested URL from a user, because the HTTP/1.1
     * will no longer specify a restriction to 5, but will leave it up to the
     * browser's discretion, in deference to Microsoft.  - FM
     */
d727 9
a735 8
     * If this is marked as an internal link but we don't have the document
     * loaded any more, and we haven't explicitly flagged that we want to
     * reload with LYforce_no_cache, then something has disappeared from the
     * cache when we expected it to be still there.  The user probably doesn't
     * expect a new network access.  So if we have POST data and safe is not
     * set in the anchor, ask for confirmation, and fail if not granted.  The
     * exception are LYNXIMGMAP documents, for which we defer to LYLoadIMGmap
     * for prompting if necessary.  - kw
d737 1
a737 2
    text = (HText *) HTAnchor_document(anchor);
    if (LYinternal_flag && !text && !LYforce_no_cache &&
d739 2
a740 1
	!isLYNXIMGMAP(full_address) &&
d747 6
a752 6
     * If we don't have POST content, check whether this is a previous
     * redirecting URL, and keep re-checking until we get to the final
     * destination or redirection limit.  If we do have POST content, we didn't
     * allow permanent redirection, and an interactive user will be deciding
     * whether to keep redirecting.  - FM
     */
d758 3
a760 3
	    CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		    anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp + 9));
d763 2
a764 2
	     * Don't exceed the redirection_attempts limit.  - FM
	     */
d773 3
a775 3
	     * Set up the redirection. - FM
	     */
	    StrAllocCopy(use_this_url_instead, cp + 9);
d782 1
a782 1
	    anchor = HTAnchor_findAddress(&NewDoc);
d786 3
a788 3
     * If we had previous redirection, go back and check out that the URL under
     * the current restrictions.  - FM
     */
d791 1
a791 1
	return (NO);
d795 3
a797 4
     * See if we can use an already loaded document.
     */
    text = (HText *) HTAnchor_document(anchor);
    if (text && !LYforce_no_cache) {
d799 50
a848 47
	 * We have a cached rendition of the target document.  Check if it's OK
	 * to re-use it.  We consider it OK if:
	 * (1) the anchor does not have the no_cache element set, or
	 * (2) we've overridden it, e.g., because we are acting on a PREV_DOC
	 * command or a link in the History Page and it's not a reply from a
	 * POST with the LYresubmit_posts flag set, or
	 * (3) we are repositioning within the currently loaded document based
	 * on the target anchor's address (URL_Reference).
	 *
	 * If DONT_TRACK_INTERNAL_LINKS is defined, HText_AreDifferent() is
	 * used to determine whether (3) applies.  If the target address
	 * differs from that of the current document only by a fragment and the
	 * target address has an appended fragment, repositioning without
	 * reloading is always assumed.  Note that HText_AreDifferent()
	 * currently always returns TRUE if the target has a LYNXIMGMAP URL, so
	 * that an internally generated pseudo-document will normally not be
	 * re-used unless condition (2) applies.  (Condition (1) cannot apply
	 * since in LYMap.c, no_cache is always set in the anchor object). 
	 * This doesn't guarantee that the resource from which the MAP element
	 * is taken will be read again (reloaded) when the list of links for a
	 * client-side image map is regenerated, when in some cases it should
	 * (e.g., user requested RELOAD, or HTTP response with no-cache header
	 * and we are not overriding).
	 *
	 * If DONT_TRACK_INTERNAL_LINKS is undefined, a target address that
	 * points to the same URL as the current document may still result in
	 * reloading, depending on whether the original URL-Reference was given
	 * as an internal link in the context of the previously loaded
	 * document.  HText_AreDifferent() is not used here for testing whether
	 * we are just repositioning.  For an internal link, the potential
	 * callers of this function from mainloop() down will either avoid
	 * making the call (and do the repositioning differently) or set
	 * LYinternal_flag (or LYoverride_no_cache).  Note that (a) LYNXIMGMAP
	 * pseudo-documents and (b) The "List Page" document are treated
	 * logically as being part of the document on which they are based, for
	 * the purpose of whether to treat a link as internal, but the logic
	 * for this (by setting LYinternal_flag as necessary) is implemented
	 * elsewhere.  There is a specific test for LYNXIMGMAP here so that the
	 * generated pseudo-document will not be re-used unless
	 * LYoverride_no_cache is set.  The same caveat as above applies w.r.t. 
	 * reloading of the underlying resource.
	 *
	 * We also should be checking other aspects of cache regulation (e.g.,
	 * based on an If-Modified-Since check, etc.) but the code for doing
	 * those other things isn't available yet.
	 */
	if (LYoverride_no_cache ||
d850 2
a851 2
	    !HText_hasNoCacheSet(text) ||
	    !HText_AreDifferent(anchor, full_address)
d853 1
d855 1
a855 1
	     !isLYNXIMGMAP(full_address))
d857 2
a858 2
	    ) {
	    CTRACE((tfp, "HTAccess: Document already in memory.\n"));
d869 1
a869 1
	    CTRACE((tfp, "HTAccess: Auto-reloading document.\n"));
a872 8
    if (text && HText_HaveUserChangedForms(text)) {
	/*
	 * Issue a warning.  User forms content will be lost.
	 * Will not restore changed forms, currently.
	 */
	HTAlert(RELOADING_FORM);
    }

d874 6
a879 5
     * Get the document from the net.  If we are auto-reloading, the mutable
     * anchor elements from the previous rendition should be freed in
     * conjunction with loading of the new rendition.  - FM
     */
    LYforce_no_cache = NO;	/* reset after each time through */
d881 1
a881 1
	FREE(anchor->title);	/* ??? */
d884 1
a884 18
    CTRACE((tfp, "HTAccess:  status=%d\n", status));

    /*
     * RECOVERY:  if the loading failed, and we had a cached HText copy, and no
     * new HText created - use a previous copy, issue a warning.
     */
    if (text && status < 0 && (HText *) HTAnchor_document(anchor) == text) {
	HTAlert(gettext("Loading failed, use a previous copy."));
	CTRACE((tfp, "HTAccess: Loading failed, use a previous copy.\n"));
	HText_select(text);

#ifdef DIRED_SUPPORT
	if (HTAnchor_format(anchor) == WWW_DIRED)
	    lynx_edit_mode = TRUE;
#endif
	redirection_attempts = 0;
	return YES;
    }
d887 2
a888 2
     * Log the access if necessary.
     */
a890 1

d898 5
a902 5
	CTRACE((tfp, "Log: %24.24s %s %s %s\n",
		ctime(&theTime),
		HTClientHost ? HTClientHost : "local",
		status < 0 ? "FAIL" : "GET",
		full_address));
d906 2
a907 2
     * Check out what we received from the net.
     */
d909 1
a909 2
	/* Exported from HTMIME.c, of all places.  */
	/* NO!! - FM */
d911 20
a930 26
	 * Doing this via HTMIME.c meant that the redirection cover page was
	 * already loaded before we learned that we want a different URL. 
	 * Also, changing anchor->address, as Lynx was doing, meant we could
	 * never again access its hash table entry, creating an insolvable
	 * memory leak.  Instead, if we had a 301 status and set
	 * permanent_redirection, we'll load the new URL in anchor->physical,
	 * preceded by a token, which we can check to make replacements on
	 * subsequent access attempts.  We'll check recursively, and retrieve
	 * the final URL if we had multiple redirections to it.  If we just
	 * went to HTLoad now, as Lou originally had this, we couldn't do
	 * Lynx's security checks and alternate handling of some URL types. 
	 * So, instead, we'll go all the way back to the top of getfile in
	 * LYGetFile.c when the status is HT_REDIRECTING.  This may seem
	 * bizarre, but it works like a charm!  - FM
	 *
	 * Actually, the location header for redirections is now again picked
	 * up in HTMIME.c.  But that's an internal matter between HTTP.c and
	 * HTMIME.c, is still under control of HTLoadHTTP for http URLs, is
	 * done in a way that doesn't load the redirection response's body
	 * (except when wanted as an error fallback), and thus need not concern
	 * us here.  - kw 1999-12-02
	 */
	CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		address_to_load));
	CTRACE((tfp, "HTAccess: Redirecting to '%s'\n",
		redirecting_url));
d932 3
a934 3
	 * Prevent circular references.
	 */
	if (strcmp(address_to_load, redirecting_url)) {		/* if different */
d936 4
a939 4
	     * Load token and redirecting url into anchor->physical if we had
	     * 301 Permanent redirection.  HTTP.c does not allow this if we
	     * have POST content.  - FM
	     */
d946 2
a947 2
	     * Set up flags before return to getfile.  - FM
	     */
d954 1
a954 1
	    return (NO);
d959 1
a959 1
	return (YES);
d963 2
a964 2
     * We did not receive a redirecting URL.  - FM
     */
d970 2
a971 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed.\n",
		full_address));
d976 2
a977 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, partial content.\n",
		full_address));
d982 2
a983 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data left.\n",
		full_address));
d988 2
a989 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data loaded.\n",
		full_address));
d994 2
a995 3
	CTRACE((tfp,
		"HTAccess: `%s' has been accessed, transfer interrupted.\n",
		full_address));
d1001 3
a1003 3
	 * If you get this, then please find which routine is returning a
	 * positive unrecognized error code!
	 */
d1005 1
a1005 1
		gettext("**** HTAccess: socket or file number returned by obsolete load routine!\n"));
d1007 3
a1009 3
		gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@nongnu.org!\n"));
	fprintf(stderr, gettext("**** HTAccess: Status returned was: %d\n"), status);
	exit_immediately(EXIT_FAILURE);
d1021 1
a1021 1
    CTRACE((tfp, "HTAccess: Can't access `%s'\n", full_address));
d1024 1
a1024 1
}				/* HTLoadDocument */
d1027 12
a1038 11
 *	-----------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  filter   if YES, treat document as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadAbsolute(const DocAddress *docaddr)
d1041 1
a1041 1
			  HTAnchor_findAddress(docaddr),
d1048 14
a1061 13
 *	---------------------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  sink	   if non-NULL, send data down this stream
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadToStream(const char *addr,
		    BOOL filter,
		    HTStream *sink)
d1064 1
a1064 1
			  HTAnchor_findSimpleAddress(addr),
d1071 13
a1083 12
 *	-----------------------------------
 *
 *  On Entry,
 *	  relative_name     The relative address of the document
 *			    to be accessed.
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadRelative(const char *relative_name,
		    HTParentAnchor *here)
d1087 3
a1089 2
    char *mycopy = NULL;
    char *stripped = NULL;
d1102 3
a1104 3
	HTParse(stripped,
		here->address,
		PARSE_ALL_WITHOUT_ANCHOR);
d1107 4
a1110 4
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  - FM
     */
d1112 2
a1113 1
    FREE(mycopy);		/* Memory leak fixed 10/7/92 -- JFG */
d1118 11
a1128 10
 *	----------------------------------------
 *
 *  On Entry,
 *	  destination		    The child or parent anchor to be loaded.
 *
 *  On Exit,
 *	  returns    YES     Success
 *		     NO      Failure
 */
BOOL HTLoadAnchor(HTAnchor * destination)
d1130 1
a1130 1
    HTParentAnchor *parent;
a1131 1

d1133 1
a1133 1
	return NO;		/* No link */
d1138 1
a1138 1
	/* TBL 921202 */
d1140 1
d1142 1
a1142 1
	result = HTLoadDocument(parent->address,
d1147 2
a1148 2
	if (!result)
	    return NO;
d1150 4
a1153 2
    } {
	HText *text = (HText *) HTAnchor_document(parent);
d1155 3
a1157 5
	if ((destination != (HTAnchor *) parent) &&
	    (destination != (HTAnchor *) (parent->parent))) {
	    /* If child anchor */
	    HText_selectAnchor(text,	/* Double display? @@@@ */
			       (HTChildAnchor *) destination);
d1165 1
a1165 1
}				/* HTLoadAnchor */
d1168 12
a1179 11
 *	-------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	 *keywords	space-separated keyword list or similar search list
 *	here		is anchor search is to be done on.
 */
static char hex(int i)
d1181 1
a1181 2
    const char *hexchars = "0123456789ABCDEF";

d1185 3
a1187 2
BOOL HTSearch(const char *keywords,
	      HTParentAnchor *here)
d1193 2
a1194 2
    const char *p, *s, *e;	/* Pointers into keywords */
    char *address = NULL;
d1196 3
a1198 3
    char *escaped = typecallocn(char, (strlen(keywords) * 3) + 1);
    static const BOOL isAcceptable[96] =
    /* *INDENT-OFF* */
a1205 1
    /* *INDENT-ON* */
d1213 6
a1218 6
     * Convert spaces to + and hex escape unacceptable characters.
     */
    for (s = keywords; *s && WHITE(*s); s++)	/* Scan */
	;			/* Skip white space */
    for (e = s + strlen(s); e > s && WHITE(*(e - 1)); e--)	/* Scan */
	;			/* Skip trailers */
d1220 1
a1220 2
	unsigned char c = UCH(TOASCII(*p));

d1225 2
a1226 2
	} else if (c >= 32 && c <= UCH(127) && isAcceptable[c - 32]) {
	    *q++ = *p;		/* 930706 TBL for MVS bug */
d1229 2
a1230 2
	    *q++ = hex((int) (c >> 4));
	    *q++ = hex((int) (c & 15));
d1245 7
a1251 7
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  Only an http server (not a gopher or wais server) could
     * return redirection.  Lynx will go all the way back to its mainloop() and
     * subject a redirecting URL to all of its security and restrictions
     * checks.  - FM
     */
d1256 13
a1268 12
 *	-----------------------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	*keywords	space-separated keyword list or similar search list
 *	*indexname	is name of object search is to be done on.
 */
BOOL HTSearchAbsolute(const char *keywords,
		      char *indexname)
d1271 1
a1271 2
    HTParentAnchor *anchor;

d1279 1
a1279 1
    anchor = HTAnchor_findAddress(&abs_doc);
d1285 14
a1298 14
 *	--------------------------------------
 *
 *	As it involves file access, this should only be done once
 *	when the program first runs.
 *	This is a default algorithm -- browser don't HAVE to use this.
 *	But consistency between browsers is STRONGLY recommended!
 *
 *  Priority order is:
 *		1	WWW_HOME environment variable (logical name, etc)
 *		2	~/WWW/default.html
 *		3	/usr/local/bin/default.html
 *		4	http://www.w3.org/default.html
 */
HTParentAnchor *HTHomeAnchor(void)
d1300 4
a1303 4
    char *my_home_document = NULL;
    char *home = LYGetEnv(LOGICAL_DEFAULT);
    char *ref;
    HTParentAnchor *anchor;
d1307 2
a1308 2
#define MAX_FILE_NAME 1024	/* @@@@@@ */
    } else if (HTClientHost) {	/* Telnet server */
d1310 4
a1313 5
	 * Someone telnets in, they get a special home.
	 */
	FILE *fp = fopen(REMOTE_POINTER, "r");
	char *status;

d1315 1
a1315 2
	    my_home_document = typecallocn(char, MAX_FILE_NAME);

d1327 2
a1328 1
#ifdef UNIX
d1330 3
a1332 4
	FILE *fp = NULL;
	char *home = LYGetEnv("HOME");

	if (home != 0) {
d1344 2
a1345 2
	    CTRACE((tfp, "HTBrowse: No local home document ~/%s or %s\n",
		    PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
d1349 1
a1349 1
#endif /* UNIX */
d1352 3
a1354 3
				       REMOTE_ADDRESS : LAST_RESORT)),
		  STR_FILE_URL,
		  PARSE_ALL_WITHOUT_ANCHOR);
d1356 2
a1357 2
	CTRACE((tfp, "HTAccess: Using custom home page %s i.e., address %s\n",
		my_home_document, ref));
d1360 1
a1360 1
    anchor = HTAnchor_findSimpleAddress(ref);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d67 2
a74 1
PUBLIC BOOL HTPermitRedir = NO;	   /* Always allow redirection in getfile()? */
d273 7
a279 2
	    (LYSameHostname(Host, "localhost") ||
	     LYSameHostname(Host, HTHostName()))) {
a317 3
	    else if (!strcmp(acc_method, "telnet"))	port = 23;
	    else if (!strcmp(acc_method, "tn3270"))	port = 23;
	    else if (!strcmp(acc_method, "rlogin"))	port = 513;
a353 9
#ifdef CJK_EX	/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port)	 &&
	    (t_len > 0	&&  t_len <= h_len  &&
	     isdigit(UCH(*no_proxy)) && !strncmp(host, no_proxy, t_len))) {
	    FREE(host);
	    return YES;
	}
#endif	/* ASATAKU PROXY HACK */

a378 1
    int result;
a381 8
    BOOL override_flag = NO;

    CTRACE((tfp, "get_physical %s\n", addr));

    /*
    **	Make sure the using_proxy variable is FALSE.
    */
    using_proxy = NO;
d384 2
a385 4
    if ((physical = HTTranslate(addr)) == 0) {
	if (redirecting_url) {
	    return HT_REDIRECTING;
	}
d390 1
a390 10
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
    }
    if (!strncmp(physical, "Proxied=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	using_proxy = YES;
    } else if (!strncmp(physical, "NoProxy=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	override_flag = YES;
    } else {
	HTAnchor_setPhysical(anchor, physical);
d392 1
d398 1
a398 1
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
d406 2
a407 1
    acc_method = HTParse(HTAnchor_physical(anchor), STR_FILE_URL, PARSE_ACCESS);
a412 4
    **
    **  If the rule system has already determined that we should
    **  use a proxy, or that we shouldn't, ignore proxy-related
    **  settings, don't use no_proxy either.
d416 4
d421 8
a428 15
    if (!override_flag && !using_proxy) {   /* else ignore no_proxy env var */
	if (!strcasecomp(acc_method, "news")) {
	    /*
	    **  News is different, so we need to check the name of the server,
	    **  as well as the default port for selective exclusions.
	    */
	    char *host = NULL;
	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (strchr(host, ':') == NULL) {
		    StrAllocCopy(Server_addr, "news://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":119/");
		}
		FREE(host);
	    } else if (LYGetEnv("NNTPSERVER") != NULL) {
d430 1
a430 1
		StrAllocCat(Server_addr, LYGetEnv("NNTPSERVER"));
d433 17
a449 13
	} else if (!strcasecomp(acc_method, "wais")) {
	    /*
	    **  Wais also needs checking of the default port
	    **  for selective exclusions.
	    */
	    char *host = NULL;
	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (!(strchr(host, ':'))) {
		    StrAllocCopy(Server_addr, "wais://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":210/");
		}
		FREE(host);
d451 3
a453 3
	    else
		StrAllocCopy(Server_addr, addr);
	} else {
d455 2
a456 2
	}
	override_flag = override_proxy(Server_addr);
d459 2
a460 2
    if (!override_flag && !using_proxy) {
	char * gateway_parameter = NULL, *gateway, *proxy;
d465 7
a471 2
	HTSprintf0(&gateway_parameter, "WWW_%s_GATEWAY", acc_method);
	gateway = LYGetEnv(gateway_parameter); /* coerce for decstation */
d480 1
a480 1
	    strcpy(gateway_parameter, "ftp_proxy");
d482 3
a484 2
	    sprintf(gateway_parameter, "%s_proxy", acc_method);
	proxy = LYGetEnv(gateway_parameter);
d488 1
a488 1
	    CTRACE((tfp, "Gateway found: %s\n", gateway));
d490 1
a490 1
	    CTRACE((tfp, "proxy server found: %s\n", proxy));
a497 8
	    if (!strncmp(gatewayed, "http", 4)) {
		char *cp = strrchr(gatewayed, '/');
		/* Append a slash to the proxy specification if it doesn't
		 * end in one but otherwise looks normal (starts with "http",
		 * has no '/' other than ones before the hostname). - kw */
		if (cp && (cp - gatewayed) <= 7)
		    LYAddHtmlSep(&gatewayed);
	    }
d513 2
a514 2
	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);
d526 2
a527 2
	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);
a535 1
    result = HT_NO_ACCESS;
d547 1
a547 2
		result = HT_OK;
		break;
d553 1
a553 1
    return result;
d565 3
a580 3
	    if (HTCJK == JAPANESE)
		StrAllocCopy(UCAssume_MIMEcharset, pushed_assume_MIMEname);
	    else
d585 1
a585 1
	    CTRACE((tfp, "LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d587 1
a587 1
			anchor_LYhndl));
d606 1
a606 1
	CTRACE((tfp, "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d608 1
a608 1
		    pushed_assume_LYhndl));
a643 2
	 /* prevent crash if telnet or similar was forbidden by rule. - kw */
	LYFixCursesOn("show alert:");
a644 2
    } else if (status == HT_REDIRECTING) {
	return status;	/* fake redirection by rule, to redirecting_url */
a648 2
    /* prevent crash if telnet or similar mapped or proxied by rule. - kw */
    LYFixCursesOnForAccess(addr, HTAnchor_physical(anchor));
d650 2
a651 2
    anchor->parent->underway = TRUE;		/* Hack to deal with caching */
    status= p->load(HTAnchor_physical(anchor),
d653 1
a653 1
    anchor->parent->underway = FALSE;
d668 1
a668 1
    return p->saveStream(anchor);
a670 2
PUBLIC int redirection_attempts = 0; /* counter in HTLoadDocument */

d677 1
a677 1
**	- Trace ouput and error messages
d700 1
d702 1
a702 1
    CTRACE((tfp, "HTAccess: loading document %s\n", address_to_load));
d740 1
a740 1
	!isLYNXIMGMAP(full_address) &&
d758 3
a760 3
	    CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
			  anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp+9));
d782 1
a782 1
	    anchor = HTAnchor_findAddress(&NewDoc);
d855 1
a855 1
	     !isLYNXIMGMAP(full_address)))
d858 1
a858 1
	    CTRACE((tfp, "HTAccess: Document already in memory.\n"));
d869 1
a869 1
	    CTRACE((tfp, "HTAccess: Auto-reloading document.\n"));
d884 1
a884 1
    CTRACE((tfp, "HTAccess:  status=%d\n", status));
d898 1
a898 1
	CTRACE((tfp, "Log: %24.24s %s %s %s\n",
d902 1
a902 1
		    full_address));
a925 7
	**
	**  Actually, the location header for redirections is now again
	**  picked up in HTMIME.c.  But that's an internal matter between
	**  HTTP.c and HTMIME.c, is still under control of HTLoadHTTP for
	**  http URLs, is done in a way that doesn't load the redirection
	**  response's body (except when wanted as an error fallback), and
	**  thus need not concern us here. - kw 1999-12-02
d927 4
a930 4
	CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		    address_to_load));
	CTRACE((tfp, "HTAccess: Redirecting to '%s'\n",
		     redirecting_url));
d970 2
a971 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed.\n",
		    full_address));
d976 2
a977 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, partial content.\n",
		    full_address));
d982 2
a983 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data left.\n",
		    full_address));
d988 2
a989 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data loaded.\n",
		    full_address));
d994 2
a995 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, transfer interrupted.\n",
		    full_address));
d1007 1
a1007 1
 gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@sig.net!\n"));
d1009 1
a1009 1
	exit(EXIT_FAILURE);
d1021 1
a1021 1
    CTRACE((tfp, "HTAccess: Can't access `%s'\n", full_address));
d1041 1
a1041 1
			  HTAnchor_findAddress(docaddr),
d1064 1
a1064 1
			  HTAnchor_findAddress(addr),
d1089 1
d1103 1
a1103 1
			here->address,
d1112 1
d1140 1
d1142 1
a1142 1
	result = HTLoadDocument(parent->address,
d1147 1
d1155 1
a1155 3
	if ((destination != (HTAnchor *)parent) &&
	    (destination != (HTAnchor *)(parent->parent))) {
						  /* If child anchor */
d1196 1
a1196 1
    char * escaped = typecallocn(char, (strlen(keywords)*3) + 1);
d1220 1
a1220 1
	unsigned char c = UCH(TOASCII(*p));
d1225 1
a1225 1
	} else if (c>=32 && c<=UCH(127) && isAcceptable[c-32]) {
d1279 1
a1279 1
    anchor = HTAnchor_findAddress(&abs_doc);
d1301 1
a1301 1
    char * home = LYGetEnv(LOGICAL_DEFAULT);
d1315 1
a1315 1
	    my_home_document = typecallocn(char, MAX_FILE_NAME);
d1328 1
a1328 1
#ifdef UNIX
d1331 2
a1332 2
	char * home = LYGetEnv("HOME");
	if (home != 0) {
d1344 2
a1345 2
	    CTRACE((tfp, "HTBrowse: No local home document ~/%s or %s\n",
			PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
d1349 1
a1349 1
#endif /* UNIX */
d1353 2
a1354 2
		  STR_FILE_URL,
		  PARSE_ALL_WITHOUT_ANCHOR);
d1356 2
a1357 2
	CTRACE((tfp, "HTAccess: Using custom home page %s i.e., address %s\n",
		    my_home_document, ref));
d1360 1
a1360 1
    anchor = HTAnchor_findSimpleAddress(ref);
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d25 1
a25 1
**	28 Jan 95 Tweaked PDM's proxy override mods to handle port info
d716 1
a716 1
**	- Trace output and error messages
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d729 1
a729 1
	CONST char *,		full_address, /* may include #fragment */
d734 2
a735 2
    int     status;
    HText * text;
d775 1
a775 2
    text = (HText *)HTAnchor_document(anchor);
    if (LYinternal_flag && !text && !LYforce_no_cache &&
d777 1
d835 1
a835 2
    text = (HText *)HTAnchor_document(anchor);
    if (text && !LYforce_no_cache) {
a886 1
	if (LYoverride_no_cache ||
d888 2
a889 2
	    !HText_hasNoCacheSet(text) ||
	    !HText_AreDifferent(anchor, full_address)
d891 1
d893 1
a893 1
	     !isLYNXIMGMAP(full_address))
d895 1
a895 1
	) {
a910 8
    if (text && HText_HaveUserChangedForms(text)) {
	/*
	 * Issue a warning.  User forms content will be lost.
	 * Will not restore changed forms, currently.
	 */
	HTAlert(RELOADING_FORM);
    }

d919 1
a919 1
	FREE(anchor->title);  /* ??? */
a924 18
     *  RECOVERY:
     *  if the loading failed, and we had a cached HText copy,
     *  and no new HText created - use a previous copy, issue a warning.
     */
    if (text && status < 0 && (HText *)HTAnchor_document(anchor) == text) {
	HTAlert(gettext("Loading failed, use a previous copy."));
	CTRACE((tfp, "HTAccess: Loading failed, use a previous copy.\n"));
	HText_select(text);

#ifdef DIRED_SUPPORT
	if (HTAnchor_format(anchor) == WWW_DIRED)
	    lynx_edit_mode = TRUE;
#endif
	redirection_attempts = 0;
	return YES;
    }

    /*
d1109 1
a1109 1
			  HTAnchor_findSimpleAddress(addr),
d1148 1
a1148 1
			PARSE_ALL_WITHOUT_ANCHOR);
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d70 4
a73 4
char * HTClientHost = NULL; /* Name of remote login host if any */
FILE * HTlogfile = NULL;    /* File to which to output one-liners */
BOOL HTSecure = NO;	   /* Disable access for telnet users? */
BOOL HTPermitRedir = NO;	   /* Always allow redirection in getfile()? */
d75 1
a75 1
BOOL using_proxy = NO; /* are we using a proxy gateway? */
d80 2
a81 2
HTFormat HTOutputFormat = NULL;
HTStream* HTOutputStream = NULL; /* For non-interactive, set this */
d83 1
a83 1
static HTList * protocols = NULL; /* List of registered protocol descriptors */
d85 1
a85 1
char *use_this_url_instead = NULL;
d87 2
a88 2
static int pushed_assume_LYhndl = -1; /* see LYUC* functions below - kw */
static char * pushed_assume_MIMEname = NULL;
d91 1
a91 1
static void free_protocols (void)
d102 2
a103 2
BOOL HTRegisterProtocol (
	HTProtocol *	protocol)
d182 1
a182 1
static void HTAccessInit (void)			/* Call me once */
d234 2
a235 2
BOOL override_proxy (
	const char *	addr)
d237 1
a237 1
    const char * no_proxy = getenv("no_proxy");
d323 2
a324 2
	const char * end;
	const char * colon = NULL;
d381 3
a383 3
static int get_physical (
	const char *		addr,
	HTParentAnchor *	anchor)
d596 2
a597 2
void LYUCPushAssumed (
    HTParentAnchor *	anchor)
d631 1
a631 1
int LYUCPopAssumed (void)
d666 5
a670 5
static int HTLoad (
	const char *		addr,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink)
d698 2
a699 2
HTStream *HTSaveStream (
	HTParentAnchor *	anchor)
d708 1
a708 1
int redirection_attempts = 0; /* counter in HTLoadDocument */
d728 5
a732 5
static BOOL HTLoadDocument (
	const char *		full_address, /* may include #fragment */
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream*		sink)
d736 1
a736 1
    const char * address_to_load = full_address;
d1109 2
a1110 2
BOOL HTLoadAbsolute (
	const DocAddress *	docaddr)
d1130 4
a1133 4
BOOL HTLoadToStream (
	const char *	addr,
	BOOL		filter,
	HTStream *	sink)
d1153 3
a1155 3
BOOL HTLoadRelative (
	const char *		relative_name,
	HTParentAnchor *	here)
d1197 2
a1198 2
BOOL HTLoadAnchor (
	HTAnchor *	destination)
d1248 2
a1249 2
static char hex (
    int		i)
d1255 3
a1257 3
BOOL HTSearch (
	const char *		keywords,
	HTParentAnchor *	here)
d1263 1
a1263 1
    const char * p, *s, *e;		/* Pointers into keywords */
d1267 1
a1267 1
    static const BOOL isAcceptable[96] =
d1336 3
a1338 3
BOOL HTSearchAbsolute (
	const char *	keywords,
	char *		indexname)
d1368 1
a1368 1
HTParentAnchor * HTHomeAnchor (void)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 31
a32 31
 *		==============
 *
 *  Authors
 *	TBL	Tim Berners-Lee timbl@@info.cern.ch
 *	JFG	Jean-Francois Groff jfg@@dxcern.cern.ch
 *	DD	Denis DeLaRoca (310) 825-4580  <CSP1DWD@@mvs.oac.ucla.edu>
 *	FM	Foteos Macrides macrides@@sci.wfeb.edu
 *	PDM	Danny Mayer mayer@@ljo.dec.com
 *
 *  History
 *	 8 Jun 92 Telnet hopping prohibited as telnet is not secure TBL
 *	26 Jun 92 When over DECnet, suppressed FTP, Gopher and News. JFG
 *	 6 Oct 92 Moved HTClientHost and logfile into here. TBL
 *	17 Dec 92 Tn3270 added, bug fix. DD
 *	 4 Feb 93 Access registration, Search escapes bad chars TBL
 *		  PARAMETERS TO HTSEARCH AND HTLOADRELATIVE CHANGED
 *	28 May 93 WAIS gateway explicit if no WAIS library linked in.
 *	31 May 94 Added DIRECT_WAIS support for VMS. FM
 *	27 Jan 95 Fixed proxy support to use NNTPSERVER for checking
 *		  whether or not to use the proxy server. PDM
 *	27 Jan 95 Ensured that proxy service will be overridden for files
 *		  on the local host (because HTLoadFile() doesn't try ftp
 *		  for those) and will substitute ftp for remote files. FM
 *	28 Jan 95 Tweaked PDM's proxy override mods to handle port info
 *		  for news and wais URL's. FM
 *
 *  Bugs
 *	This module assumes that that the graphic object is hypertext, as it
 *	needs to select it when it has been loaded.  A superclass needs to be
 *	defined which accepts select and select_anchor.
 */
d42 2
a43 2
 *  Implements:
 */
d47 2
a48 2
 *  Uses:
 */
d57 1
a57 1
#include <HText.h>		/* See bugs above */
d68 6
a73 6
 *  These flags may be set to modify the operation of this module
 */
char *HTClientHost = NULL;	/* Name of remote login host if any */
FILE *HTlogfile = NULL;		/* File to which to output one-liners */
BOOL HTSecure = NO;		/* Disable access for telnet users? */
BOOL HTPermitRedir = NO;	/* Always allow redirection in getfile()? */
d75 1
a75 1
BOOL using_proxy = NO;		/* are we using a proxy gateway? */
d78 2
a79 2
 *  To generate other things, play with these:
 */
d81 1
a81 1
HTStream *HTOutputStream = NULL;	/* For non-interactive, set this */
d83 1
a83 1
static HTList *protocols = NULL;	/* List of registered protocol descriptors */
d87 2
a88 2
static int pushed_assume_LYhndl = -1;	/* see LYUC* functions below - kw */
static char *pushed_assume_MIMEname = NULL;
d91 1
a91 1
static void free_protocols(void)
d95 1
a95 1
    FREE(pushed_assume_MIMEname);	/* shouldn't happen, just in case - kw */
d100 4
a103 3
 *	--------------------
 */
BOOL HTRegisterProtocol(HTProtocol * protocol)
d115 1
d117 11
a127 11
 *	-----------------------------
 *
 *	Add to or subtract from this list if you add or remove protocol
 *	modules.  This routine is called the first time the protocol list
 *	is needed, unless any protocols are already registered, in which
 *	case it is not called.	Therefore the application can override
 *	this list.
 *
 *	Compiling with NO_INIT prevents all known protocols from being
 *	forced in at link time.
 */
a135 1

a161 1

d177 1
a177 1
GLOBALREF HTProtocol HTWAIS;
d182 1
a182 1
static void HTAccessInit(void)	/* Call me once */
d219 17
a235 16
 *	-------------------------
 *
 *	Check the no_proxy environment variable to get the list
 *	of hosts for which proxy server is not consulted.
 *
 *	no_proxy is a comma- or space-separated list of machine
 *	or domain names, with optional :port part.  If no :port
 *	part is present, it applies to all ports on that domain.
 *
 *  Example:
 *	    no_proxy="cern.ch,some.domain:8001"
 *
 *  Use "*" to override all proxy service:
 *	     no_proxy="*"
 */
BOOL override_proxy(const char *addr)
d237 6
a242 6
    const char *no_proxy = getenv("no_proxy");
    char *p = NULL;
    char *at = NULL;
    char *host = NULL;
    char *Host = NULL;
    char *acc_method = NULL;
d255 4
a258 3
     * Never proxy file:// URLs if they are on the local host.  HTLoadFile()
     * will not attempt ftp for those if direct access fails.  We'll check that
     * first, in case no_proxy hasn't been defined.  - FM
d268 1
a268 1
    Host = (((at = strchr(host, '@@')) != NULL) ? (at + 1) : host);
d287 1
a287 1
	*p++ = 0;		/* Chop off port */
d289 1
a289 1
    } else {			/* Use default port */
a291 1
	    /* *INDENT-OFF* */
a314 2
	    /* *INDENT-ON* */

d319 1
a319 1
	port = 80;		/* Default */
d323 2
a324 2
	const char *end;
	const char *colon = NULL;
d329 1
a329 1
	    no_proxy++;		/* Skip whitespace and separators */
d333 1
a333 2
	    if (*end == ':')
		colon = end;	/* Port number given */
d338 1
a338 1
	    templ_port = atoi(colon + 1);
d340 2
a341 1
	} else {
d345 2
a346 2
	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
d351 3
a353 3
#ifdef CJK_EX			/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
d358 1
a358 1
#endif /* ASATAKU PROXY HACK */
d371 13
a383 12
 *	--------------------------------------
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		HT_NO_ACCESS		Error has occurred.
 *			HT_OK			Success
 */
static int get_physical(const char *addr,
			HTParentAnchor *anchor)
d386 3
a388 3
    char *acc_method = NULL;	/* Name of access method */
    char *physical = NULL;
    char *Server_addr = NULL;
d394 2
a395 2
     * Make sure the using_proxy variable is FALSE.
     */
d418 1
a418 1
    FREE(physical);		/* free our copy */
d425 1
a425 1
	FREE(physical);		/* free our copy */
d434 8
a441 8
     * Check whether gateway access has been set up for this.
     *
     * This function can be replaced by the rule system above.
     *
     * If the rule system has already determined that we should use a proxy, or
     * that we shouldn't, ignore proxy-related settings, don't use no_proxy
     * either.
     */
d445 1
a445 1
    if (!override_flag && !using_proxy) {	/* else ignore no_proxy env var */
d448 3
a450 3
	     * News is different, so we need to check the name of the server,
	     * as well as the default port for selective exclusions.
	     */
a451 1

d466 3
a468 3
	     * Wais also needs checking of the default port for selective
	     * exclusions.
	     */
a469 1

d477 2
a478 1
	    } else
d487 1
a487 1
	char *gateway_parameter = NULL, *gateway, *proxy;
d490 2
a491 2
	 * Search for gateways.
	 */
d493 1
a493 1
	gateway = LYGetEnv(gateway_parameter);	/* coerce for decstation */
d496 2
a497 2
	 * Search for proxy servers.
	 */
d500 2
a501 2
	     * If we got to here, a file URL is for ftp on a remote host. - FM
	     */
d514 2
a515 2
	 * Proxy servers have precedence over gateway servers.
	 */
d517 2
a518 3
	    char *gatewayed = NULL;

	    StrAllocCopy(gatewayed, proxy);
a520 1

d528 2
a529 2
	     * Ensure that the proxy server uses ftp for file URLs. - FM
	     */
d546 4
a549 6
	    char *path = HTParse(addr, "",
				 PARSE_HOST + PARSE_PATH + PARSE_PUNCTUATION);

	    /* Chop leading / off to make host into part of path */
	    char *gatewayed = HTParse(path + 1, gateway, PARSE_ALL);

d563 2
a564 2
     * Search registered protocols to find suitable one.
     */
a567 1

d569 1
a569 2
	if (!protocols)
	    HTAccessInit();
d573 1
a573 2
	    HTProtocol *p = (HTProtocol *) HTList_objectAt(protocols, i);

d588 7
a594 5
 * Temporarily set the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec
 * used for charset "assuming" to the values implied by a HTParentAnchor's
 * UCStages, after saving the current values for later restoration.  - kw @@@@@@
 * These functions may not really belong here, but where else?  I want the
 * "pop" to occur as soon as possible after loading has finished.  - kw @@@@@@
d596 2
a597 1
void LYUCPushAssumed(HTParentAnchor *anchor)
d600 1
a600 2
    LYUCcharset *anchor_UCI = NULL;

d612 1
a612 1
		StrAllocCopy(UCAssume_MIMEcharset, anchor_UCI->MIMEname);
d616 1
a616 2
		CTRACE((tfp,
			"LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
a625 1

d627 3
a629 2
 * Restore the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec used for
 * charset "assuming" from the values saved by LYUCPushAssumed, if any.  - kw
d631 1
a631 1
int LYUCPopAssumed(void)
d637 1
a637 2
	    CTRACE((tfp,
		    "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d651 20
a670 19
 *	---------------
 *
 *	This is an internal routine, which has an address AND a matching
 *	anchor.  (The public routines are called with one OR the other.)
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		<0		Error has occurred.
 *			HT_LOADED	Success
 *			HT_NO_DATA	Success, but no document loaded.
 *					(telnet session started etc)
 */
static int HTLoad(const char *addr,
		  HTParentAnchor *anchor,
		  HTFormat format_out,
		  HTStream *sink)
a673 1

d675 1
a675 1
	/* prevent crash if telnet or similar was forbidden by rule. - kw */
d679 1
a679 1
	return status;		/* fake redirection by rule, to redirecting_url */
d682 1
a682 1
	return status;		/* Can't resolve or forbidden */
d686 4
a689 4
    p = (HTProtocol *) HTAnchor_protocol(anchor);
    anchor->parent->underway = TRUE;	/* Hack to deal with caching */
    status = p->load(HTAnchor_physical(anchor),
		     anchor, format_out, sink);
d696 4
a699 3
 *	--------------------------------
 */
HTStream *HTSaveStream(HTParentAnchor *anchor)
d701 1
a701 2
    HTProtocol *p = (HTProtocol *) HTAnchor_protocol(anchor);

d708 1
a708 1
int redirection_attempts = 0;	/* counter in HTLoadDocument */
d711 22
a732 20
 *	----------------------------------
 *
 *	- Checks or documents already loaded
 *	- Logs the access
 *	- Allows stdin filter option
 *	- Trace output and error messages
 *
 *  On Entry,
 *	  anchor	    is the node_anchor for the document
 *	  full_address	    The address of the document to be accessed.
 *	  filter	    if YES, treat stdin as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
static BOOL HTLoadDocument(const char *full_address,	/* may include #fragment */
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
d734 3
a736 3
    int status;
    HText *text;
    const char *address_to_load = full_address;
d743 3
a745 3
     * Free use_this_url_instead and reset permanent_redirection if not done
     * elsewhere.  - FM
     */
d750 8
a757 6
     * Make sure some yoyo doesn't send us 'round in circles with redirecting
     * URLs that point back to themselves.  We'll set the original Lynx limit
     * of 10 redirections per requested URL from a user, because the HTTP/1.1
     * will no longer specify a restriction to 5, but will leave it up to the
     * browser's discretion, in deference to Microsoft.  - FM
     */
d765 9
a773 8
     * If this is marked as an internal link but we don't have the document
     * loaded any more, and we haven't explicitly flagged that we want to
     * reload with LYforce_no_cache, then something has disappeared from the
     * cache when we expected it to be still there.  The user probably doesn't
     * expect a new network access.  So if we have POST data and safe is not
     * set in the anchor, ask for confirmation, and fail if not granted.  The
     * exception are LYNXIMGMAP documents, for which we defer to LYLoadIMGmap
     * for prompting if necessary.  - kw
d775 1
a775 1
    text = (HText *) HTAnchor_document(anchor);
d785 6
a790 6
     * If we don't have POST content, check whether this is a previous
     * redirecting URL, and keep re-checking until we get to the final
     * destination or redirection limit.  If we do have POST content, we didn't
     * allow permanent redirection, and an interactive user will be deciding
     * whether to keep redirecting.  - FM
     */
d797 2
a798 2
		    anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp + 9));
d801 2
a802 2
	     * Don't exceed the redirection_attempts limit.  - FM
	     */
d811 3
a813 3
	     * Set up the redirection. - FM
	     */
	    StrAllocCopy(use_this_url_instead, cp + 9);
d824 3
a826 3
     * If we had previous redirection, go back and check out that the URL under
     * the current restrictions.  - FM
     */
d829 1
a829 1
	return (NO);
d833 3
a835 3
     * See if we can use an already loaded document.
     */
    text = (HText *) HTAnchor_document(anchor);
d838 50
a887 46
	 * We have a cached rendition of the target document.  Check if it's OK
	 * to re-use it.  We consider it OK if:
	 * (1) the anchor does not have the no_cache element set, or
	 * (2) we've overridden it, e.g., because we are acting on a PREV_DOC
	 * command or a link in the History Page and it's not a reply from a
	 * POST with the LYresubmit_posts flag set, or
	 * (3) we are repositioning within the currently loaded document based
	 * on the target anchor's address (URL_Reference).
	 *
	 * If DONT_TRACK_INTERNAL_LINKS is defined, HText_AreDifferent() is
	 * used to determine whether (3) applies.  If the target address
	 * differs from that of the current document only by a fragment and the
	 * target address has an appended fragment, repositioning without
	 * reloading is always assumed.  Note that HText_AreDifferent()
	 * currently always returns TRUE if the target has a LYNXIMGMAP URL, so
	 * that an internally generated pseudo-document will normally not be
	 * re-used unless condition (2) applies.  (Condition (1) cannot apply
	 * since in LYMap.c, no_cache is always set in the anchor object). 
	 * This doesn't guarantee that the resource from which the MAP element
	 * is taken will be read again (reloaded) when the list of links for a
	 * client-side image map is regenerated, when in some cases it should
	 * (e.g., user requested RELOAD, or HTTP response with no-cache header
	 * and we are not overriding).
	 *
	 * If DONT_TRACK_INTERNAL_LINKS is undefined, a target address that
	 * points to the same URL as the current document may still result in
	 * reloading, depending on whether the original URL-Reference was given
	 * as an internal link in the context of the previously loaded
	 * document.  HText_AreDifferent() is not used here for testing whether
	 * we are just repositioning.  For an internal link, the potential
	 * callers of this function from mainloop() down will either avoid
	 * making the call (and do the repositioning differently) or set
	 * LYinternal_flag (or LYoverride_no_cache).  Note that (a) LYNXIMGMAP
	 * pseudo-documents and (b) The "List Page" document are treated
	 * logically as being part of the document on which they are based, for
	 * the purpose of whether to treat a link as internal, but the logic
	 * for this (by setting LYinternal_flag as necessary) is implemented
	 * elsewhere.  There is a specific test for LYNXIMGMAP here so that the
	 * generated pseudo-document will not be re-used unless
	 * LYoverride_no_cache is set.  The same caveat as above applies w.r.t. 
	 * reloading of the underlying resource.
	 *
	 * We also should be checking other aspects of cache regulation (e.g.,
	 * based on an If-Modified-Since check, etc.) but the code for doing
	 * those other things isn't available yet.
	 */
d896 1
a896 1
	    ) {
d921 6
a926 5
     * Get the document from the net.  If we are auto-reloading, the mutable
     * anchor elements from the previous rendition should be freed in
     * conjunction with loading of the new rendition.  - FM
     */
    LYforce_no_cache = NO;	/* reset after each time through */
d928 1
a928 1
	FREE(anchor->title);	/* ??? */
d934 3
a936 2
     * RECOVERY:  if the loading failed, and we had a cached HText copy, and no
     * new HText created - use a previous copy, issue a warning.
d938 1
a938 1
    if (text && status < 0 && (HText *) HTAnchor_document(anchor) == text) {
d952 2
a953 2
     * Log the access if necessary.
     */
a955 1

d964 4
a967 4
		ctime(&theTime),
		HTClientHost ? HTClientHost : "local",
		status < 0 ? "FAIL" : "GET",
		full_address));
d971 2
a972 2
     * Check out what we received from the net.
     */
d974 1
a974 2
	/* Exported from HTMIME.c, of all places.  */
	/* NO!! - FM */
d976 23
a998 22
	 * Doing this via HTMIME.c meant that the redirection cover page was
	 * already loaded before we learned that we want a different URL. 
	 * Also, changing anchor->address, as Lynx was doing, meant we could
	 * never again access its hash table entry, creating an insolvable
	 * memory leak.  Instead, if we had a 301 status and set
	 * permanent_redirection, we'll load the new URL in anchor->physical,
	 * preceded by a token, which we can check to make replacements on
	 * subsequent access attempts.  We'll check recursively, and retrieve
	 * the final URL if we had multiple redirections to it.  If we just
	 * went to HTLoad now, as Lou originally had this, we couldn't do
	 * Lynx's security checks and alternate handling of some URL types. 
	 * So, instead, we'll go all the way back to the top of getfile in
	 * LYGetFile.c when the status is HT_REDIRECTING.  This may seem
	 * bizarre, but it works like a charm!  - FM
	 *
	 * Actually, the location header for redirections is now again picked
	 * up in HTMIME.c.  But that's an internal matter between HTTP.c and
	 * HTMIME.c, is still under control of HTLoadHTTP for http URLs, is
	 * done in a way that doesn't load the redirection response's body
	 * (except when wanted as an error fallback), and thus need not concern
	 * us here.  - kw 1999-12-02
	 */
d1000 1
a1000 1
		address_to_load));
d1002 1
a1002 1
		redirecting_url));
d1004 3
a1006 3
	 * Prevent circular references.
	 */
	if (strcmp(address_to_load, redirecting_url)) {		/* if different */
d1008 4
a1011 4
	     * Load token and redirecting url into anchor->physical if we had
	     * 301 Permanent redirection.  HTTP.c does not allow this if we
	     * have POST content.  - FM
	     */
d1018 2
a1019 2
	     * Set up flags before return to getfile.  - FM
	     */
d1026 1
a1026 1
	    return (NO);
d1031 1
a1031 1
	return (YES);
d1035 2
a1036 2
     * We did not receive a redirecting URL.  - FM
     */
d1043 1
a1043 1
		full_address));
d1049 1
a1049 1
		full_address));
d1055 1
a1055 1
		full_address));
d1061 1
a1061 1
		full_address));
d1066 2
a1067 3
	CTRACE((tfp,
		"HTAccess: `%s' has been accessed, transfer interrupted.\n",
		full_address));
d1073 3
a1075 3
	 * If you get this, then please find which routine is returning a
	 * positive unrecognized error code!
	 */
d1077 1
a1077 1
		gettext("**** HTAccess: socket or file number returned by obsolete load routine!\n"));
d1079 2
a1080 2
		gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@nongnu.org!\n"));
	fprintf(stderr, gettext("**** HTAccess: Status returned was: %d\n"), status);
d1096 1
a1096 1
}				/* HTLoadDocument */
d1099 12
a1110 11
 *	-----------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  filter   if YES, treat document as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadAbsolute(const DocAddress *docaddr)
d1120 14
a1133 13
 *	---------------------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  sink	   if non-NULL, send data down this stream
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadToStream(const char *addr,
		    BOOL filter,
		    HTStream *sink)
d1143 13
a1155 12
 *	-----------------------------------
 *
 *  On Entry,
 *	  relative_name     The relative address of the document
 *			    to be accessed.
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadRelative(const char *relative_name,
		    HTParentAnchor *here)
d1159 2
a1160 2
    char *mycopy = NULL;
    char *stripped = NULL;
d1173 3
a1175 3
	HTParse(stripped,
		here->address,
		PARSE_ALL_WITHOUT_ANCHOR);
d1178 4
a1181 4
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  - FM
     */
d1183 1
a1183 1
    FREE(mycopy);		/* Memory leak fixed 10/7/92 -- JFG */
d1188 11
a1198 10
 *	----------------------------------------
 *
 *  On Entry,
 *	  destination		    The child or parent anchor to be loaded.
 *
 *  On Exit,
 *	  returns    YES     Success
 *		     NO      Failure
 */
BOOL HTLoadAnchor(HTAnchor * destination)
d1200 1
a1200 1
    HTParentAnchor *parent;
a1201 1

d1203 1
a1203 1
	return NO;		/* No link */
d1208 1
a1208 1
	/* TBL 921202 */
d1216 1
a1216 2
	if (!result)
	    return NO;
d1218 4
a1221 2
    } {
	HText *text = (HText *) HTAnchor_document(parent);
d1223 5
a1227 5
	if ((destination != (HTAnchor *) parent) &&
	    (destination != (HTAnchor *) (parent->parent))) {
	    /* If child anchor */
	    HText_selectAnchor(text,	/* Double display? @@@@ */
			       (HTChildAnchor *) destination);
d1235 1
a1235 1
}				/* HTLoadAnchor */
d1238 12
a1249 11
 *	-------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	 *keywords	space-separated keyword list or similar search list
 *	here		is anchor search is to be done on.
 */
static char hex(int i)
d1251 1
a1251 2
    char *hexchars = "0123456789ABCDEF";

d1255 3
a1257 2
BOOL HTSearch(const char *keywords,
	      HTParentAnchor *here)
d1263 2
a1264 2
    const char *p, *s, *e;	/* Pointers into keywords */
    char *address = NULL;
d1266 1
a1266 1
    char *escaped = typecallocn(char, (strlen(keywords) * 3) + 1);
d1268 1
a1268 1
    /* *INDENT-OFF* */
a1275 1
    /* *INDENT-ON* */
d1283 6
a1288 6
     * Convert spaces to + and hex escape unacceptable characters.
     */
    for (s = keywords; *s && WHITE(*s); s++)	/* Scan */
	;			/* Skip white space */
    for (e = s + strlen(s); e > s && WHITE(*(e - 1)); e--)	/* Scan */
	;			/* Skip trailers */
a1290 1

d1295 2
a1296 2
	} else if (c >= 32 && c <= UCH(127) && isAcceptable[c - 32]) {
	    *q++ = *p;		/* 930706 TBL for MVS bug */
d1299 2
a1300 2
	    *q++ = hex((int) (c >> 4));
	    *q++ = hex((int) (c & 15));
d1315 7
a1321 7
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  Only an http server (not a gopher or wais server) could
     * return redirection.  Lynx will go all the way back to its mainloop() and
     * subject a redirecting URL to all of its security and restrictions
     * checks.  - FM
     */
d1326 13
a1338 12
 *	-----------------------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	*keywords	space-separated keyword list or similar search list
 *	*indexname	is name of object search is to be done on.
 */
BOOL HTSearchAbsolute(const char *keywords,
		      char *indexname)
d1341 1
a1341 2
    HTParentAnchor *anchor;

d1355 14
a1368 14
 *	--------------------------------------
 *
 *	As it involves file access, this should only be done once
 *	when the program first runs.
 *	This is a default algorithm -- browser don't HAVE to use this.
 *	But consistency between browsers is STRONGLY recommended!
 *
 *  Priority order is:
 *		1	WWW_HOME environment variable (logical name, etc)
 *		2	~/WWW/default.html
 *		3	/usr/local/bin/default.html
 *		4	http://www.w3.org/default.html
 */
HTParentAnchor *HTHomeAnchor(void)
d1370 4
a1373 4
    char *my_home_document = NULL;
    char *home = LYGetEnv(LOGICAL_DEFAULT);
    char *ref;
    HTParentAnchor *anchor;
d1377 2
a1378 2
#define MAX_FILE_NAME 1024	/* @@@@@@ */
    } else if (HTClientHost) {	/* Telnet server */
d1380 4
a1383 5
	 * Someone telnets in, they get a special home.
	 */
	FILE *fp = fopen(REMOTE_POINTER, "r");
	char *status;

a1385 1

d1397 1
d1400 2
a1401 3
	FILE *fp = NULL;
	char *home = LYGetEnv("HOME");

d1415 1
a1415 1
		    PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
d1422 1
a1422 1
				       REMOTE_ADDRESS : LAST_RESORT)),
d1427 1
a1427 1
		my_home_document, ref));
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d67 2
a74 1
PUBLIC BOOL HTPermitRedir = NO;	   /* Always allow redirection in getfile()? */
d271 3
d275 1
a275 1
#define CompareHostname(a,b) strcasecomp(a, b)
d277 1
a277 1
#define CompareHostname(a,b) strcmp(a, b)
d279 1
a279 5

    if ((acc_method = HTParse(addr, "", PARSE_ACCESS))) {
	if (!strcmp("file", acc_method) &&
	    (!strcmp(Host, "localhost") ||
	     !CompareHostname(Host, HTHostName()))) {
a317 3
	    else if (!strcmp(acc_method, "telnet"))	port = 23;
	    else if (!strcmp(acc_method, "tn3270"))	port = 23;
	    else if (!strcmp(acc_method, "rlogin"))	port = 513;
a353 9
#ifdef CJK_EX	/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port)	 &&
	    (t_len > 0	&&  t_len <= h_len  &&
	     isdigit(UCH(*no_proxy)) && !strncmp(host, no_proxy, t_len))) {
	    FREE(host);
	    return YES;
	}
#endif	/* ASATAKU PROXY HACK */

a381 6
    BOOL override_flag = NO;

    /*
    **	Make sure the using_proxy variable is FALSE.
    */
    using_proxy = NO;
a385 3
	if (redirecting_url) {
	    return HT_REDIRECTING;
	}
d390 1
a390 10
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
    }
    if (!strncmp(physical, "Proxied=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	using_proxy = YES;
    } else if (!strncmp(physical, "NoProxy=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	override_flag = YES;
    } else {
	HTAnchor_setPhysical(anchor, physical);
d392 1
d398 1
a398 1
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
a412 4
    **
    **  If the rule system has already determined that we should
    **  use a proxy, or that we shouldn't, ignore proxy-related
    **  settings, don't use no_proxy either.
d416 4
d421 8
a428 15
    if (!override_flag && !using_proxy) {   /* else ignore no_proxy env var */
	if (!strcasecomp(acc_method, "news")) {
	    /*
	    **  News is different, so we need to check the name of the server,
	    **  as well as the default port for selective exclusions.
	    */
	    char *host = NULL;
	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (strchr(host, ':') == NULL) {
		    StrAllocCopy(Server_addr, "news://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":119/");
		}
		FREE(host);
	    } else if (getenv("NNTPSERVER") != NULL) {
d430 1
a430 1
		StrAllocCat(Server_addr, (char *)getenv("NNTPSERVER"));
d433 8
a440 2
	} else if (!strcasecomp(acc_method, "wais")) {
	    /*
d444 6
a449 8
	    char *host = NULL;
	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (!(strchr(host, ':'))) {
		    StrAllocCopy(Server_addr, "wais://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":210/");
		}
		FREE(host);
d451 3
a453 3
	    else
		StrAllocCopy(Server_addr, addr);
	} else {
d455 2
a456 2
	}
	override_flag = override_proxy(Server_addr);
d459 2
a460 2
    if (!override_flag && !using_proxy) {
	char * gateway_parameter = NULL, *gateway, *proxy;
d465 7
a471 2
	HTSprintf0(&gateway_parameter, "WWW_%s_GATEWAY", acc_method);
	gateway = getenv(gateway_parameter); /* coerce for decstation */
d480 1
a480 1
	    strcpy(gateway_parameter, "ftp_proxy");
d482 3
a484 2
	    sprintf(gateway_parameter, "%s_proxy", acc_method);
	proxy = getenv(gateway_parameter);
d488 1
a488 1
	    CTRACE((tfp, "Gateway found: %s\n", gateway));
d490 1
a490 1
	    CTRACE((tfp, "proxy server found: %s\n", proxy));
a497 8
	    if (!strncmp(gatewayed, "http", 4)) {
		char *cp = strrchr(gatewayed, '/');
		/* Append a slash to the proxy specification if it doesn't
		 * end in one but otherwise looks normal (starts with "http",
		 * has no '/' other than ones before the hostname). - kw */
		if (cp && (cp - gatewayed) <= 7)
		    LYAddHtmlSep(&gatewayed);
	    }
a580 3
	    if (HTCJK == JAPANESE)
		StrAllocCopy(UCAssume_MIMEcharset, pushed_assume_MIMEname);
	    else
d585 1
a585 1
	    CTRACE((tfp, "LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d587 1
a587 1
			anchor_LYhndl));
d606 1
a606 1
	CTRACE((tfp, "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d608 1
a608 1
		    pushed_assume_LYhndl));
a643 2
	 /* prevent crash if telnet or similar was forbidden by rule. - kw */
	LYFixCursesOn("show alert:");
a644 2
    } else if (status == HT_REDIRECTING) {
	return status;	/* fake redirection by rule, to redirecting_url */
a648 2
    /* prevent crash if telnet or similar mapped or proxied by rule. - kw */
    LYFixCursesOnForAccess(addr, HTAnchor_physical(anchor));
a670 2
PUBLIC int redirection_attempts = 0; /* counter in HTLoadDocument */

d700 1
d702 1
a702 1
    CTRACE((tfp, "HTAccess: loading document %s\n", address_to_load));
d758 3
a760 3
	    CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
			  anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp+9));
d782 1
a782 1
	    anchor = HTAnchor_parent(HTAnchor_findAddress(&NewDoc));
d858 1
a858 1
	    CTRACE((tfp, "HTAccess: Document already in memory.\n"));
d869 1
a869 1
	    CTRACE((tfp, "HTAccess: Auto-reloading document.\n"));
d884 1
a884 1
    CTRACE((tfp, "HTAccess:  status=%d\n", status));
d898 1
a898 1
	CTRACE((tfp, "Log: %24.24s %s %s %s\n",
d902 1
a902 1
		    full_address));
a925 7
	**
	**  Actually, the location header for redirections is now again
	**  picked up in HTMIME.c.  But that's an internal matter between
	**  HTTP.c and HTMIME.c, is still under control of HTLoadHTTP for
	**  http URLs, is done in a way that doesn't load the redirection
	**  response's body (except when wanted as an error fallback), and
	**  thus need not concern us here. - kw 1999-12-02
d927 4
a930 4
	CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		    address_to_load));
	CTRACE((tfp, "HTAccess: Redirecting to '%s'\n",
		     redirecting_url));
d970 2
a971 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed.\n",
		    full_address));
d976 2
a977 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, partial content.\n",
		    full_address));
d982 2
a983 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data left.\n",
		    full_address));
d988 2
a989 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data loaded.\n",
		    full_address));
d994 2
a995 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, transfer interrupted.\n",
		    full_address));
d1007 1
a1007 1
 gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@sig.net!\n"));
d1009 1
a1009 1
	exit(EXIT_FAILURE);
d1021 1
a1021 1
    CTRACE((tfp, "HTAccess: Can't access `%s'\n", full_address));
d1196 1
a1196 1
    char * escaped = typecallocn(char, (strlen(keywords)*3) + 1);
d1220 1
a1220 1
	unsigned char c = UCH(TOASCII(*p));
d1225 1
a1225 1
	} else if (c>=32 && c<=UCH(127) && isAcceptable[c-32]) {
d1315 1
a1315 1
	    my_home_document = typecallocn(char, MAX_FILE_NAME);
d1328 1
a1328 1
#ifdef UNIX
d1344 2
a1345 2
	    CTRACE((tfp, "HTBrowse: No local home document ~/%s or %s\n",
			PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
d1349 1
a1349 1
#endif /* UNIX */
d1356 2
a1357 2
	CTRACE((tfp, "HTAccess: Using custom home page %s i.e., address %s\n",
		    my_home_document, ref));
@

