head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.4
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.2
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.11.20.30.35;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.33;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.26;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.55;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.24;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.13;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.56;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.11.20.16.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/*			GOPHER ACCESS				HTGopher.c
 *			=============
 *
 *  History:
 *	26 Sep 90	Adapted from other accesses (News, HTTP) TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 *	10 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Added a
 *			  form-based CSO/PH gateway.  Can be invoked via a
 *			  "cso://host[:port]/" or "gopher://host:105/2"
 *			  URL.	If a gopher URL is used with a query token
 *			  ('?'), the old ISINDEX procedure will be used
 *			  instead of the form-based gateway.
 *	15 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Pass
 *			  port 79, gtype 0 gopher URLs to the finger
 *			  gateway.
 */

#include <HTUtils.h>		/* Coding convention macros */

#ifndef DISABLE_GOPHER
#include <HTAlert.h>
#include <HTParse.h>
#include <HTTCP.h>
#include <HTFinger.h>

/*
 *  Implements.
 */
#include <HTGopher.h>

#define GOPHER_PORT 70		/* See protocol spec */
#define CSO_PORT 105		/* See protocol spec */
#define BIG 1024		/* Bug */
#define LINE_LENGTH 256		/* Bug */

/*
 *  Gopher entity types.
 */
#define GOPHER_TEXT		'0'
#define GOPHER_MENU		'1'
#define GOPHER_CSO		'2'
#define GOPHER_ERROR		'3'
#define GOPHER_MACBINHEX	'4'
#define GOPHER_PCBINARY		'5'
#define GOPHER_UUENCODED	'6'
#define GOPHER_INDEX		'7'
#define GOPHER_TELNET		'8'
#define GOPHER_BINARY		'9'
#define GOPHER_GIF		'g'
#define GOPHER_HTML		'h'	/* HTML */
#define GOPHER_CHTML		'H'	/* HTML */
#define GOPHER_SOUND		's'
#define GOPHER_WWW		'w'	/* W3 address */
#define GOPHER_IMAGE		'I'
#define GOPHER_TN3270		'T'
#define GOPHER_INFO		'i'
#define GOPHER_DUPLICATE	'+'
#define GOPHER_PLUS_IMAGE	':'	/* Addition from Gopher Plus */
#define GOPHER_PLUS_MOVIE	';'
#define GOPHER_PLUS_SOUND	'<'
#define GOPHER_PLUS_PDF		'P'

#include <HTFormat.h>

/*
 *  Hypertext object building machinery.
 */
#include <HTML.h>

#include <LYStrings.h>
#include <LYUtils.h>
#include <LYLeaks.h>

#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)

#define NEXT_CHAR HTGetCharacter()

/*
 *  Module-wide variables.
 */
static int s;			/* Socket for gopher or CSO host */

struct _HTStructured {
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
};

static HTStructured *target;	/* the new gopher hypertext */
static HTStructuredClass targetClass;	/* Its action routines */

struct _HTStream {
    HTStreamClass *isa;		/* For form-based CSO  gateway - FM */
};

typedef struct _CSOfield_info {	/* For form-based CSO gateway - FM */
    struct _CSOfield_info *next;
    char *name;
    char *attributes;
    char *description;
    int id;
    int lookup;
    int indexed;
    int url;
    int max_size;
    int defreturn;
    int explicit_return;
    int reserved;
    int gpublic;
    char name_buf[16];		/* Avoid malloc if we can */
    char desc_buf[32];		/* Avoid malloc if we can */
    char attr_buf[80];		/* Avoid malloc if we can */
} CSOfield_info;

static CSOfield_info *CSOfields = NULL;		/* For form-based CSO gateway - FM */

typedef struct _CSOformgen_context {	/* For form-based CSO gateway - FM */
    char *host;
    char *seek;
    CSOfield_info *fld;
    int port;
    int cur_line;
    int cur_off;
    int rep_line;
    int rep_off;
    int public_override;
    int field_select;
} CSOformgen_context;

/*	Matrix of allowed characters in filenames
 *	=========================================
 */
static BOOL acceptable[256];
static BOOL acceptable_inited = NO;

static void init_acceptable(void)
{
    unsigned int i;
    const char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
	acceptable[i] = NO;
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
    acceptable_inited = YES;
}

/*	Decode one hex character
 *	========================
 */
static const char hex[17] = "0123456789abcdef";

static char from_hex(char c)
{
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
}

/*	Paste in an Anchor
 *	==================
 *
 *	The title of the destination is set, as there is no way
 *	of knowing what the title is when we arrive.
 *
 * On entry,
 *	HT	is in append mode.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext refernce address 0 terminated.
 */
BOOLEAN HT_Is_Gopher_URL = FALSE;

static void write_anchor(const char *text, const char *addr)
{
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];

    int i;

    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = 0;
    present[HTML_A_HREF] = YES;
    ((const char **) value)[HTML_A_HREF] = addr;
    present[HTML_A_TITLE] = YES;
    ((const char **) value)[HTML_A_TITLE] = text;

    CTRACE((tfp, "HTGopher: adding URL: %s\n", addr));

    HT_Is_Gopher_URL = TRUE;	/* tell HTML.c that this is a Gopher URL */
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);

    PUTS(text);
    END(HTML_A);
}

/*	Parse a Gopher Menu document
 *	============================
 */
static void parse_menu(const char *arg GCC_UNUSED,
		       HTParentAnchor *anAnchor)
{
    char gtype;
    int ich;
    char line[BIG];
    char *name = NULL, *selector = NULL;	/* Gopher menu fields */
    char *host = NULL;
    char *port;
    char *p = line;
    const char *title;
    int bytes = 0;
    int BytesReported = 0;
    char buffer[128];

#define TAB		'\t'
#define HEX_ESCAPE	'%'

    START(HTML_HTML);
    PUTC('\n');
    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_MENU_TITLE);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');

    START(HTML_BODY);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_MENU_TITLE);
    END(HTML_H1);
    PUTC('\n');
    START(HTML_PRE);
    while ((ich = NEXT_CHAR) != EOF) {

	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
	    goto end_html;
	}

	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;

	} else {
	    *p++ = '\0';	/* Terminate line */
	    bytes += p - line;	/* add size */
	    p = line;		/* Scan it to parse it */
	    port = 0;		/* Flag "not parsed" */
	    CTRACE((tfp, "HTGopher: Menu item: %s\n", line));
	    gtype = *p++;

	    if (bytes > BytesReported + 1024) {
		sprintf(buffer, TRANSFERRED_X_BYTES, bytes);
		HTProgress(buffer);
		BytesReported = bytes;
	    }

	    /* Break on line with a dot by itself */
	    if ((gtype == '.') && ((*p == '\r') || (*p == 0)))
		break;

	    if (gtype && *p) {
		name = p;
		selector = strchr(name, TAB);
		if (selector) {
		    *selector++ = '\0';		/* Terminate name */
		    /*
		     * Gopher+ Type=0+ objects can be binary, and will
		     * have 9 or 5 beginning their selector.  Make sure
		     * we don't trash the terminal by treating them as
		     * text. - FM
		     */
		    if (gtype == GOPHER_TEXT && (*selector == GOPHER_BINARY ||
						 *selector == GOPHER_PCBINARY))
			gtype = *selector;
		    host = strchr(selector, TAB);
		    if (host) {
			*host++ = '\0';		/* Terminate selector */
			port = strchr(host, TAB);
			if (port) {
			    char *junk;

			    port[0] = ':';	/* delimit host a la W3 */
			    junk = strchr(port, TAB);
			    if (junk)
				*junk++ = '\0';		/* Chop port */
			    if ((port[1] == '0') && (!port[2]))
				port[0] = '\0';		/* 0 means none */
			}	/* no port */
		    }		/* host ok */
		}		/* selector ok */
	    }
	    /* gtype and name ok */
	    /* Nameless files are a separator line */
	    if (gtype == GOPHER_TEXT) {
		int i = strlen(name) - 1;

		while (name[i] == ' ' && i >= 0)
		    name[i--] = '\0';
		if (i < 0)
		    gtype = GOPHER_INFO;
	    }

	    if (gtype == GOPHER_WWW) {	/* Gopher pointer to W3 */
		PUTS("(HTML) ");
		write_anchor(name, selector);

	    } else if (gtype == GOPHER_INFO) {
		/* Information or separator line */
		PUTS("       ");
		PUTS(name);

	    } else if (port) {	/* Other types need port */
		char *address = 0;
		const char *format = *selector ? "%s//%s@@%s/" : "%s//%s/";

		if (gtype == GOPHER_TELNET) {
		    PUTS(" (TEL) ");
		    HTSprintf0(&address, format, STR_TELNET_URL, selector, host);
		} else if (gtype == GOPHER_TN3270) {
		    PUTS("(3270) ");
		    HTSprintf0(&address, format, STR_TN3270_URL, selector, host);
		} else {	/* If parsed ok */
		    char *r;

		    switch (gtype) {
		    case GOPHER_TEXT:
			PUTS("(FILE) ");
			break;
		    case GOPHER_MENU:
			PUTS(" (DIR) ");
			break;
		    case GOPHER_CSO:
			PUTS(" (CSO) ");
			break;
		    case GOPHER_PCBINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_UUENCODED:
			PUTS(" (UUE) ");
			break;
		    case GOPHER_INDEX:
			PUTS("  (?)  ");
			break;
		    case GOPHER_BINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_GIF:
		    case GOPHER_IMAGE:
		    case GOPHER_PLUS_IMAGE:
			PUTS(" (IMG) ");
			break;
		    case GOPHER_SOUND:
		    case GOPHER_PLUS_SOUND:
			PUTS(" (SND) ");
			break;
		    case GOPHER_MACBINHEX:
			PUTS(" (HQX) ");
			break;
		    case GOPHER_HTML:
		    case GOPHER_CHTML:
			PUTS("(HTML) ");
			break;
		    case 'm':
			PUTS("(MIME) ");
			break;
		    case GOPHER_PLUS_MOVIE:
			PUTS(" (MOV) ");
			break;
		    case GOPHER_PLUS_PDF:
			PUTS(" (PDF) ");
			break;
		    default:
			PUTS("(UNKN) ");
			break;
		    }

		    HTSprintf0(&address, "//%s/%c", host, gtype);

		    for (r = selector; *r; r++) {	/* Encode selector string */
			if (acceptable[UCH(*r)]) {
			    HTSprintf(&address, "%c", *r);
			} else {
			    HTSprintf(&address, "%c%c%c",
				      HEX_ESCAPE,	/* Means hex coming */
				      hex[(TOASCII(*r)) >> 4],
				      hex[(TOASCII(*r)) & 15]);
			}
		    }
		}
		/* Error response from Gopher doesn't deserve to
		   be a hyperlink. */
		if (strcmp(address, "gopher://error.host:1/0"))
		    write_anchor(name, address);
		else
		    PUTS(name);
		FREE(address);
	    } else {		/* parse error */
		CTRACE((tfp, "HTGopher: Bad menu item.\n"));
		PUTS(line);

	    }			/* parse error */

	    PUTC('\n');
	    p = line;		/* Start again at beginning of line */

	}			/* if end of line */

    }				/* Loop over characters */

  end_html:
    END(HTML_PRE);
    PUTC('\n');
    END(HTML_BODY);
    PUTC('\n');
    END(HTML_HTML);
    PUTC('\n');
    FREE_TARGET;

    return;
}

/*	Parse a Gopher CSO document from an ISINDEX query.
 *	==================================================
 *
 *   Accepts an open socket to a CSO server waiting to send us
 *   data and puts it on the screen in a reasonable manner.
 *
 *   Perhaps this data can be automatically linked to some
 *   other source as well???
 *
 *  Taken from hacking by Lou Montulli@@ukanaix.cc.ukans.edu
 *  on XMosaic-1.1, and put on libwww 2.11 by Arthur Secret,
 *  secret@@dxcern.cern.ch .
 */
static void parse_cso(const char *arg,
		      HTParentAnchor *anAnchor)
{
    int ich;
    char line[BIG];
    char *p = line;
    char *second_colon, last_char = '\0';
    const char *title;

    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_CSO_SEARCH_RESULTS);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else {
	PUTS(arg);
	PUTS(GOPHER_SEARCH_RESULTS);
    }
    END(HTML_H1);
    PUTC('\n');
    START(HTML_PRE);

    /*
     * Start grabbing chars from the network.
     */
    while ((ich = NEXT_CHAR) != EOF) {
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;
	} else {
	    *p = '\0';		/* Terminate line */
	    p = line;		/* Scan it to parse it */
	    /*
	     * OK we now have a line in 'p'.  Lets parse it and print it.
	     */

	    /*
	     * Break on line that begins with a 2.  It's the end of data.
	     */
	    if (*p == '2')
		break;

	    /*
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
	    if (*p == '5') {
		START(HTML_H2);
		PUTS(p + 4);
		END(HTML_H2);
		break;
	    }

	    if (*p == '-') {
		/*
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 * Find the second colon and check the digit to the left of it
		 * to see if they are diferent.  If they are then a different
		 * person is starting.  Make this line an <h2>.
		 */

		/*
		 * Find the second_colon.
		 */
		second_colon = strchr(strchr(p, ':') + 1, ':');

		if (second_colon != NULL) {	/* error check */

		    if (*(second_colon - 1) != last_char)
			/* print seperator */
		    {
			END(HTML_PRE);
			START(HTML_H2);
		    }

		    /*
		     * Right now the record appears with the alias (first line)
		     * as the header and the rest as <pre> text.
		     *
		     * It might look better with the name as the header and the
		     * rest as a <ul> with <li> tags.  I'm not sure whether the
		     * name field comes in any special order or if its even
		     * required in a record, so for now the first line is the
		     * header no matter what it is (it's almost always the
		     * alias).
		     *
		     * A <dl> with the first line as the <DT> and the rest as
		     * some form of <DD> might good also?
		     */

		    /*
		     * Print data.
		     */
		    PUTS(second_colon + 1);
		    PUTC('\n');

		    if (*(second_colon - 1) != last_char)
			/* end seperator */
		    {
			END(HTML_H2);
			START(HTML_PRE);
		    }

		    /*
		     * Save the char before the second colon for comparison on
		     * the next pass.
		     */
		    last_char = *(second_colon - 1);

		}		/* end if second_colon */
	    }			/* end if *p == '-' */
	}			/* if end of line */

    }				/* Loop over characters */

    /* end the text block */
    PUTC('\n');
    END(HTML_PRE);
    PUTC('\n');
    FREE_TARGET;

    return;			/* all done */
}				/* end of procedure */

/*	Display a Gopher CSO ISINDEX cover page.
 *	========================================
 */
static void display_cso(const char *arg,
			HTParentAnchor *anAnchor)
{
    const char *title;

    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_CSO_INDEX);
    END(HTML_TITLE);
    PUTC('\n');
    START(HTML_ISINDEX);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else {
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
    }
    END(HTML_H1);
    PUTS(GOPHER_CSO_INDEX_SUBTITLE);
    START(HTML_P);
    PUTS(GOPHER_CSO_SOLICIT_KEYWORDS);
    START(HTML_P);
    PUTS(SEGMENT_KEYWORDS_WILL);
    PUTS(SEGMENT_PERSONS_DB_NAME);

    if (!HTAnchor_title(anAnchor))
	HTAnchor_setTitle(anAnchor, arg);

    FREE_TARGET;
    return;
}

/*	Display a Gopher Index document.
 *	================================
 */
static void display_index(const char *arg,
			  HTParentAnchor *anAnchor)
{
    const char *title;

    START(HTML_HEAD);
    PUTC('\n');
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_INDEX_TITLE);
    END(HTML_TITLE);
    PUTC('\n');
    START(HTML_ISINDEX);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else {
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
    }
    END(HTML_H1);
    PUTS(GOPHER_INDEX_SUBTITLE);
    START(HTML_P);
    PUTS(GOPHER_SOLICIT_KEYWORDS);

    if (!HTAnchor_title(anAnchor))
	HTAnchor_setTitle(anAnchor, arg);

    FREE_TARGET;
    return;
}

/*	De-escape a selector into a command.
 *	====================================
 *
 *	The % hex escapes are converted. Otheriwse, the string is copied.
 */
static void de_escape(char *command, const char *selector)
{
    const char *p = selector;
    char *q = command;

    if (command == NULL)
	outofmem(__FILE__, "HTLoadGopher");
    while (*p) {		/* Decode hex */
	if (*p == HEX_ESCAPE) {
	    char c;
	    unsigned int b;

	    p++;
	    c = *p++;
	    b = from_hex(c);
	    c = *p++;
	    if (!c)
		break;		/* Odd number of chars! */
	    *q++ = (char) FROMASCII((b << 4) + from_hex(c));
	} else {
	    *q++ = *p++;	/* Record */
	}
    }
    *q++ = '\0';		/* Terminate command */
}

/*	Free the CSOfields structures. - FM
 *	===================================
 */
static void free_CSOfields(void)
{
    CSOfield_info *cur = CSOfields;
    CSOfield_info *prev;

    while (cur) {
	if (cur->name != cur->name_buf)
	    FREE(cur->name);
	if (cur->attributes != cur->attr_buf)
	    FREE(cur->attributes);
	if (cur->description != cur->desc_buf)
	    FREE(cur->description);
	prev = cur;
	cur = cur->next;
	FREE(prev);
    }

    return;
}

/*	Interpret CSO/PH form template keys. - FM
 *	=========================================
 */
static void interpret_cso_key(const char *key,
			      char *buf,
			      int *length,
			      CSOformgen_context * ctx,
			      HTStream *Target)
{
    CSOfield_info *fld;

    if ((fld = ctx->fld) != 0) {
	/*
	 * Most substitutions only recognized inside of loops.
	 */
	int error = 0;

	if (0 == strncmp(key, "$(FID)", 6)) {
	    sprintf(buf, "%d", fld->id);
	} else if (0 == strncmp(key, "$(FDESC)", 8)) {
	    sprintf(buf, "%.2046s", fld->description);
	} else if (0 == strncmp(key, "$(FDEF)", 7)) {
	    strcpy(buf, fld->defreturn ? " checked" : "");
	} else if (0 == strncmp(key, "$(FNDX)", 7)) {
	    strcpy(buf, fld->indexed ? "*" : "");
	} else if (0 == strncmp(key, "$(FSIZE)", 8)) {
	    sprintf(buf, " size=%d maxlength=%d",
		    fld->max_size > 55 ? 55 : fld->max_size,
		    fld->max_size);
	} else if (0 == strncmp(key, "$(FSIZE2)", 9)) {
	    sprintf(buf, " maxlength=%d", fld->max_size);
	} else {
	    error = 1;
	}
	if (!error) {
	    *length = strlen(buf);
	    return;
	}
    }
    buf[0] = '\0';
    if (0 == strncmp(key, "$(NEXTFLD)", 10)) {
	if (!ctx->fld)
	    fld = CSOfields;
	else
	    fld = ctx->fld->next;
	switch (ctx->field_select) {
	case 0:
	    /*
	     * 'Query' fields, public and lookup attributes.
	     */
	    for (; fld; fld = fld->next)
		if (fld->gpublic && (fld->lookup == 1))
		    break;
	    break;
	case 1:
	    /*
	     * 'Query' fields, accept lookup attribute.
	     */
	    for (; fld; fld = fld->next)
		if (fld->lookup == 1)
		    break;
	    break;
	case 2:
	    /*
	     * 'Return' fields, public only.
	     */
	    for (; fld; fld = fld->next)
		if (fld->gpublic)
		    break;
	    break;
	case 3:
	    /*
	     * All fields.
	     */
	    break;
	}
	if (fld) {
	    ctx->cur_line = ctx->rep_line;
	    ctx->cur_off = ctx->rep_off;
	}
	ctx->fld = fld;

    } else if ((0 == strncmp(key, "$(QFIELDS)", 10)) ||
	       (0 == strncmp(key, "$(RFIELDS)", 10))) {
	/*
	 * Begin iteration sequence.
	 */
	ctx->rep_line = ctx->cur_line;
	ctx->rep_off = ctx->cur_off;
	ctx->fld = (CSOfield_info *) 0;
	ctx->seek = "$(NEXTFLD)";
	ctx->field_select = (key[2] == 'Q') ? 0 : 2;
	if (ctx->public_override)
	    ctx->field_select++;

    } else if (0 == strncmp(key, "$(NAMEFLD)", 10)) {
	/*
	 * Special, locate name field.  Flag lookup so QFIELDS will skip it.
	 */
	for (fld = CSOfields; fld; fld = fld->next)
	    if (strcmp(fld->name, "name") == 0 ||
		strcmp(fld->name, "Name") == 0) {
		if (fld->lookup)
		    fld->lookup = 2;
		break;
	    }
	ctx->fld = fld;
    } else if (0 == strncmp(key, "$(HOST)", 7)) {
	strcpy(buf, ctx->host);
    } else if (0 == strncmp(key, "$(PORT)", 7)) {
	sprintf(buf, "%d", ctx->port);
    } else {
	/*
	 * No match, dump key to buffer so client sees it for debugging.
	 */
	size_t out = 0;

	while (*key && (*key != ')')) {
	    buf[out++] = (*key++);
	    if (out > sizeof(buf) - 2) {
		buf[out] = '\0';
		(*Target->isa->put_block) (Target, buf, strlen(buf));
		out = 0;
	    }
	}
	buf[out++] = ')';
	buf[out] = '\0';
	*length = strlen(buf);
	return;
    }
    *length = strlen(buf);
    return;
}

/*	Parse the elements in a CSO/PH fields structure. - FM
 *	=====================================================
 */
static int parse_cso_field_info(CSOfield_info *blk)
{
    char *info, *max_spec;

    /*
     * Initialize all fields to default values.
     */
    blk->indexed = blk->lookup = blk->reserved = blk->max_size = blk->url = 0;
    blk->defreturn = blk->explicit_return = blk->gpublic = 0;

    /*
     * Search for keywords in info string and set values.  Attributes are
     * converted to all lower-case for comparison.
     */
    info = blk->attributes;
    LYLowerCase(info);
    if (strstr(info, "indexed "))
	blk->indexed = 1;
    if (strstr(info, "default "))
	blk->defreturn = 1;
    if (strstr(info, "public "))
	blk->gpublic = 1;
    if (strstr(info, "lookup "))
	blk->lookup = 1;
    if (strstr(info, "url ")) {
	blk->url = 1;
	blk->defreturn = 1;
    }
    max_spec = strstr(info, "max ");
    if (max_spec) {
	sscanf(&max_spec[4], "%d", &blk->max_size);
    } else {
	blk->max_size = 32;
    }

    return 0;
}

/*	Parse a reply from a CSO/PH fields request. - FM
 *	================================================
 */
static int parse_cso_fields(char *buf,
			    int size)
{
    int ich;
    char *p = buf;
    int i, code = 0, prev_code;
    size_t alen;
    char *indx, *name;
    CSOfield_info *last, *newf;

    last = CSOfields = (CSOfield_info *) 0;
    prev_code = -2555;
    buf[0] = '\0';

    /*
     * Start grabbing chars from the network.
     */
    while ((ich = NEXT_CHAR) != EOF) {
	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    free_CSOfields();
	    buf[0] = '\0';
	    return HT_INTERRUPTED;
	}

	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in buffer */
	    if (p < &buf[size - 1]) {
		p++;
	    }
	} else {
	    *p = '\0';		/* Terminate line */
	    p = buf;		/* Scan it to parse it */

	    /* OK we now have a line in 'p' lets parse it.
	     */

	    /*
	     * Break on line that begins with a 2.  It's the end of data.
	     */
	    if (*p == '2')
		break;

	    /*
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
	    if (*p == '5') {
		strcpy(buf, p);
		return 5;
	    }

	    if (*p == '-') {
		/*
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 */

		/*
		 * Check status, ignore any non-success.
		 */
		if (p[1] != '2')
		    continue;

		/*
		 * Parse fields within returned line into status, ndx, name,
		 * data.
		 */
		indx = NULL;
		name = NULL;
		for (i = 0; p[i]; i++) {
		    if (p[i] == ':') {
			p[i] = '\0';
			if (!indx) {
			    indx = (char *) &p[i + 1];
			    code = atoi(indx);
			} else if (!name) {
			    name = (char *) &p[i + 1];
			} else {
			    i++;
			    break;
			}
		    }
		}
		/*
		 * Add data to field structure.
		 */
		if (name) {
		    if (code == prev_code) {
			/*
			 * Remaining data are description.  Save in current
			 * info block.
			 */
			alen = strlen((char *) &p[i]) + 1;
			if (alen > sizeof(last->desc_buf)) {
			    if (last->description != last->desc_buf)
				FREE(last->description);
			    if (!(last->description = (char *) malloc(alen))) {
				outofmem(__FILE__, "HTLoadCSO");
			    }
			}
			strcpy(last->description, (char *) &p[i]);
		    } else {
			/*
			 * Initialize new block, append to end of list to
			 * preserve order.
			 */
			newf = typecalloc(CSOfield_info);

			if (!newf) {
			    outofmem(__FILE__, "HTLoadCSO");
			}
			if (last)
			    last->next = newf;
			else
			    CSOfields = newf;
			last = newf;

			newf->next = (CSOfield_info *) 0;
			newf->name = newf->name_buf;
			alen = strlen(name) + 1;
			if (alen > sizeof(newf->name_buf)) {
			    if (!(newf->name = (char *) malloc(alen))) {
				outofmem(__FILE__, "HTLoadCSO");
			    }
			}
			strcpy(newf->name, name);

			newf->attributes = newf->attr_buf;
			alen = strlen((char *) &p[i]) + 2;
			if (alen > sizeof(newf->attr_buf)) {
			    if (!(newf->attributes = (char *) malloc(alen))) {
				outofmem(__FILE__, "HTLoadCSO");
			    }
			}
			strcpy(newf->attributes, (char *) &p[i]);
			strcpy((char *) &newf->attributes[alen - 2], " ");
			newf->description = newf->desc_buf;
			newf->desc_buf[0] = '\0';
			newf->id = atoi(indx);
			/*
			 * Scan for keywords.
			 */
			parse_cso_field_info(newf);
		    }
		    prev_code = code;
		} else
		    break;
	    }			/* end if *p == '-' */
	}			/* if end of line */

    }				/* Loop over characters */

    /* end the text block */

    if (buf[0] == '\0') {
	return -1;		/* no response */
    }
    buf[0] = '\0';
    return 0;			/* all done */
}				/* end of procedure */

/*	Generate a form for submitting CSO/PH searches. - FM
 *	====================================================
 */
static int generate_cso_form(char *host,
			     int port,
			     char *buf,
			     HTStream *Target)
{
    int i, j, length;
    size_t out;
    int full_flag = 1;
    const char *key;
    const char *line;
    CSOformgen_context ctx;
    static const char *ctemplate[] =
    {
	"<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
	"<H2><I>CSO/PH Query Form</I> for <EM>$(HOST)</EM></H2>",
	"To search the database for a name, fill in one or more of the fields",
	"in the form below and activate the 'Submit query' button.  At least",
	"one of the entered fields must be flagged as indexed.",
	"<HR><FORM method=\"POST\" action=\"cso://$(HOST)/\">",
	"[ <input type=\"submit\" value=\"Submit query\"> | ",
	"<input type=\"reset\" value=\"Clear fields\"> ]",
	"<P><DL>",
	"   <DT>Search parameters (* indicates indexed field):",
	"   <DD>",
	"$(NAMEFLD)    <DL COMPACT>\n    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD>Last: <input name=\"q_$(FID)\" type=\"text\" size=49$(FSIZE2)>",
	"    <DD>First: <input name=\"q_$(FID)\" type=\"text\" size=48$(FSIZE2)>",
	"$(QFIELDS)    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD><input name=\"q_$(FID)\" type=\"text\" $(FSIZE)>\n$(NEXTFLD)",
	"    </DL>",
	"   </DL>\n<P><DL>",
	"   <DT>Output format:",
	"   <DD>Returned data option: <select name=\"return\">",
	"    <option>default<option selected>all<option>selected</select><BR>",
	"$(RFIELDS)    <input type=\"checkbox\" name=\"r_$(FID)\"$(FDEF)> $(FDESC)<BR>",
	"$(NEXTFLD)    ",
	"   </DL></FORM><HR>\n</BODY>\n</HTML>",
	(char *) 0
    };

    out = 0;
    ctx.host = host;
    ctx.seek = (char *) 0;
    ctx.port = port;
    ctx.fld = (CSOfield_info *) 0;
    ctx.public_override = full_flag;
    /*
     * Parse the strings in the template array to produce HTML document to send
     * to client.  First line is skipped for 'full' lists.
     */
    out = 0;
    buf[out] = '\0';
    for (i = full_flag ? /***1***/ 0 : 0;
	 ctemplate[i];
	 i++) {
	/*
	 * Search the current string for substitution, flagged by $(
	 */
	for (line = ctemplate[i], j = 0; line[j]; j++) {
	    if ((line[j] == '$') && (line[j + 1] == '(')) {
		/*
		 * Command detected, flush output buffer and find closing ')'
		 * that delimits the command.
		 */
		buf[out] = '\0';
		if (out > 0)
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
		out = 0;
		for (key = &line[j]; line[j + 1] && (line[j] != ')'); j++) ;
		/*
		 * Save context, interpet command and restore updated context.
		 */
		ctx.cur_line = i;
		ctx.cur_off = j;
		interpret_cso_key(key, buf, &length, &ctx, Target);
		i = ctx.cur_line;
		j = ctx.cur_off;
		line = ctemplate[i];
		out = length;

		if (ctx.seek) {
		    /*
		     * Command wants us to skip (forward) to indicated token. 
		     * Start at current position.
		     */
		    int slen = strlen(ctx.seek);

		    for (; ctemplate[i]; i++) {
			for (line = ctemplate[i]; line[j]; j++) {
			    if (line[j] == '$')
				if (0 == strncmp(ctx.seek, &line[j], slen)) {
				    if (j == 0)
					j = strlen(ctemplate[--i]) - 1;
				    else
					--j;
				    line = ctemplate[i];
				    ctx.seek = (char *) 0;
				    break;
				}
			}
			if (!ctx.seek)
			    break;
			j = 0;
		    }
		    if (ctx.seek) {
			char *temp = 0;

			HTSprintf0(&temp, GOPHER_CSO_SEEK_FAILED, ctx.seek);
			(*Target->isa->put_block) (Target, temp, strlen(temp));
			FREE(temp);
		    }
		}
	    } else {
		/*
		 * Non-command text, add to output buffer.
		 */
		buf[out++] = line[j];
		if (out > (sizeof(buf) - 3)) {
		    buf[out] = '\0';
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
		    out = 0;
		}
	    }
	}
	buf[out++] = '\n';
	buf[out] = '\0';
    }
    if (out > 0)
	(*Target->isa->put_block) (Target, buf, strlen(buf));

    return 0;
}

/*	Generate a results report for CSO/PH form-based searches. - FM
 *	==============================================================
 */
static int generate_cso_report(HTStream *Target)
{
    int ich;
    char line[BIG];
    char *buf = 0;
    char *p = line, *href = NULL;
    int len, i, prev_ndx, ndx;
    char *rcode, *ndx_str, *fname, *fvalue, *l;
    CSOfield_info *fld;
    BOOL stop = FALSE;

    /*
     * Read lines until non-negative status.
     */
    prev_ndx = -100;
    /*
     * Start grabbing chars from the network.
     */
    while (!stop && (ich = NEXT_CHAR) != EOF) {
	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    goto end_CSOreport;
	}

	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
		p++;
	    }
	} else {
	    *p = '\0';		/* Terminate line */
	    /*
	     * OK we now have a line.  Load it as 'p' and parse it.
	     */
	    p = line;
	    if (p[0] != '-' && p[0] != '1') {
		stop = TRUE;
	    }
	    rcode = (p[0] == '-') ? &p[1] : p;
	    ndx_str = fname = NULL;
	    len = strlen(p);
	    for (i = 0; i < len; i++) {
		if (p[i] == ':') {
		    p[i] = '\0';
		    if (!ndx_str) {
			fname = ndx_str = &p[i + 1];
		    } else {
			fname = &p[i + 1];
			break;
		    }
		}
	    }
	    if (ndx_str) {
		ndx = atoi(ndx_str);
		if (prev_ndx != ndx) {
		    if (prev_ndx != -100) {
			HTSprintf0(&buf, "</DL></DL>\n");
			(*Target->isa->put_block) (Target, buf, strlen(buf));
		    }
		    if (ndx == 0) {
			HTSprintf0(&buf,
				   "<HR><DL><DT>Information/status<DD><DL><DT>\n");
			(*Target->isa->put_block) (Target, buf, strlen(buf));
		    } else {
			HTSprintf0(&buf,
				   "<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n", ndx);
			(*Target->isa->put_block) (Target, buf, strlen(buf));
		    }
		    prev_ndx = ndx;
		}
	    } else {
		HTSprintf0(&buf, "<DD>%s\n", rcode);
		(*Target->isa->put_block) (Target, buf, strlen(buf));
		continue;
	    }
	    if ((*rcode >= '2') && (*rcode <= '5') && (fname != ndx_str)) {
		while (*fname == ' ') {
		    fname++;	/* trim leading spaces */
		}
		for (fvalue = fname; *fvalue; fvalue++) {
		    if (*fvalue == ':') {
			*fvalue++ = '\0';
			i = strlen(fname) - 1;
			while (i >= 0 && fname[i] == ' ') {
			    fname[i--] = '\0';	/* trim trailing */
			}
			break;
		    }
		}
		if (fvalue) {
		    while (*fvalue == ' ') {
			fvalue++;	/* trim leading spaces */
		    }
		}
		if (*fname) {
		    for (fld = CSOfields; fld; fld = fld->next) {
			if (!strcmp(fld->name, fname)) {
			    if (fld->description) {
				fname = fld->description;
			    }
			    break;
			}
		    }
		    if (fld && fld->url) {
			HTSprintf0(&buf,
				   "<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",
				   fname, fvalue, fvalue);
			(*Target->isa->put_block) (Target, buf, strlen(buf));
		    } else {
			HTSprintf0(&buf, "<DT><I>%s</I><DD>", fname);
			(*Target->isa->put_block) (Target, buf, strlen(buf));
			buf[0] = '\0';
			l = fvalue;
			while (*l) {
			    if (*l == '<') {
				StrAllocCat(buf, "&lt;");
				l++;
			    } else if (*l == '>') {
				StrAllocCat(buf, "&gt;");
				l++;
			    } else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				       strncmp(l, "snews://", 8) &&
				       strncmp(l, "nntp://", 7) &&
				       strncmp(l, "snewspost:", 10) &&
				       strncmp(l, "snewsreply:", 11) &&
				       strncmp(l, "newspost:", 9) &&
				       strncmp(l, "newsreply:", 10) &&
				       strncmp(l, "ftp://", 6) &&
				       strncmp(l, "file:/", 6) &&
				       strncmp(l, "finger://", 9) &&
				       strncmp(l, "http://", 7) &&
				       strncmp(l, "https://", 8) &&
				       strncmp(l, "wais://", 7) &&
				       strncmp(l, STR_MAILTO_URL,
					       LEN_MAILTO_URL) &&
				       strncmp(l, "cso://", 6) &&
				       strncmp(l, "gopher://", 9)) {
				HTSprintf(&buf, "%c", *l++);
			    } else {
				StrAllocCat(buf, "<a href=\"");
				StrAllocCopy(href, l);
				StrAllocCat(buf, strtok(href, " \r\n\t,>)\""));
				StrAllocCat(buf, "\">");
				while (*l && !strchr(" \r\n\t,>)\"", *l)) {
				    HTSprintf(&buf, "%c", *l++);
				}
				StrAllocCat(buf, "</a>");
				FREE(href);
			    }
			}
			StrAllocCat(buf, "\n");
			(*Target->isa->put_block) (Target, buf, strlen(buf));
		    }
		} else {
		    HTSprintf0(&buf, "<DD>");
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
		    buf[0] = '\0';
		    l = fvalue;
		    while (*l) {
			if (*l == '<') {
			    StrAllocCat(buf, "&lt;");
			    l++;
			} else if (*l == '>') {
			    StrAllocCat(buf, "&gt;");
			    l++;
			} else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				   strncmp(l, "snews://", 8) &&
				   strncmp(l, "nntp://", 7) &&
				   strncmp(l, "snewspost:", 10) &&
				   strncmp(l, "snewsreply:", 11) &&
				   strncmp(l, "newspost:", 9) &&
				   strncmp(l, "newsreply:", 10) &&
				   strncmp(l, "ftp://", 6) &&
				   strncmp(l, "file:/", 6) &&
				   strncmp(l, "finger://", 9) &&
				   strncmp(l, "http://", 7) &&
				   strncmp(l, "https://", 8) &&
				   strncmp(l, "wais://", 7) &&
				   strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
				   strncmp(l, "cso://", 6) &&
				   strncmp(l, "gopher://", 9)) {
			    HTSprintf(&buf, "%c", *l++);
			} else {
			    StrAllocCat(buf, "<a href=\"");
			    StrAllocCopy(href, l);
			    StrAllocCat(buf, strtok(href, " \r\n\t,>)\""));
			    StrAllocCat(buf, "\">");
			    while (*l && !strchr(" \r\n\t,>)\"", *l)) {
				HTSprintf(&buf, "%c", *l++);
			    }
			    StrAllocCat(buf, "</a>");
			    FREE(href);
			}
		    }
		    StrAllocCat(buf, "\n");
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
		}
	    } else {
		HTSprintf0(&buf, "<DD>%s\n", fname ? fname : rcode);
		(*Target->isa->put_block) (Target, buf, strlen(buf));
	    }
	}
    }
  end_CSOreport:
    if (prev_ndx != -100) {
	HTSprintf0(&buf, "</DL></DL>\n");
	(*Target->isa->put_block) (Target, buf, strlen(buf));
    }
    FREE(buf);
    return 0;
}

/*	CSO/PH form-based search gateway - FM			HTLoadCSO
 *	=====================================
 */
static int HTLoadCSO(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
{
    static const char end_form[] = "</BODY>\n</HTML>\n";
    char *host, *cp, *data;
    int port = CSO_PORT;
    int status;			/* tcp return */
    bstring *command = NULL;
    bstring *content = NULL;
    int len, i, j, start, finish, flen, ndx;
    int return_type, has_indexed;
    CSOfield_info *fld;
    char buf[2048];
    HTFormat format_in = WWW_HTML;
    HTStream *Target = NULL;

    if (!acceptable_inited)
	init_acceptable();

    if (!arg)
	return -3;		/* Bad if no name sepcified     */
    if (!*arg)
	return -2;		/* Bad if name had zero length  */
    CTRACE((tfp, "HTLoadCSO: Looking for %s\n", arg));

    /*
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "cso", CSO_PORT, &s);
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp,
		"HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	return HT_NOT_LOADED;
    }
    if (status < 0) {
	CTRACE((tfp, "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
		arg));
	return HTInetStatus("connect");
    }

    HTInitInput(s);		/* Set up input buffering */

    HTBprintf(&command, "fields%c%c", CR, LF);
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Connected, writing command `"));
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
    _HTProgress(GOPHER_SENDING_CSO_REQUEST);
    status = NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
    if (status < 0) {
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
	return HTInetStatus("send");
    }
    _HTProgress(GOPHER_SENT_CSO_REQUEST);

    /*
     * Now read the data from the socket.
     */
    status = parse_cso_fields(buf, sizeof(buf));
    if (status) {
	NETCLOSE(s);
	if (status == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	} else if (buf[0] != '\0') {
	    HTAlert(buf);
	} else {
	    HTAlert(FAILED_NO_RESPONSE);
	}
	return HT_NOT_LOADED;
    }
    Target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);
    if (!Target || Target == NULL) {
	char *temp = 0;

	HTSprintf0(&temp, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(temp);
	FREE(temp);
	NETCLOSE(s);
	return HT_NOT_LOADED;
    }
    host = HTParse(arg, "", PARSE_HOST);
    if ((cp = strchr(host, ':')) != NULL) {
	if (cp[1] >= '0' && cp[1] <= '9') {
	    port = atoi((cp + 1));
	    if (port == CSO_PORT) {
		*cp = '\0';
	    }
	}
    }
    anAnchor->safe = TRUE;
    if (isBEmpty(anAnchor->post_data)) {
	generate_cso_form(host, port, buf, Target);
	(*Target->isa->_free) (Target);
	FREE(host);
	NETCLOSE(s);
	free_CSOfields();
	return HT_LOADED;
    }

    HTBprintf(&command,
	      "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n",
	      host);
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
    BStrFree(command);
    FREE(host);

    BStrCopy(content, anAnchor->post_data);

    if (BStrData(content)[BStrLen(content) - 1] != '&')
	BStrCat0(content, "&");

    data = BStrData(content);
    len = BStrLen(content);
    for (i = 0; i < len; i++) {
	if (data[i] == '+') {
	    data[i] = ' ';
	}
    }

    data = BStrData(content);
    HTUnEscape(data);		/* FIXME: could it have embedded null? */
    len = BStrLen(content);

    return_type = 0;
    has_indexed = 0;
    start = finish = 0;
    for (i = 0; i < len; i++) {
	if (!data[i] || data[i] == '&') {
	    /*
	     * Value parsed.  Unescape characters and look for first '=' to
	     * delimit field name from value.
	     */
	    flen = i - start;
	    finish = start + flen;
	    data[finish] = '\0';
	    for (j = start; j < finish; j++) {
		if (data[j] == '=') {
		    /*
		     * data[start..j-1] is field name,
		     * [j+1..finish-1] is value.
		     */
		    if ((data[start + 1] == '_') &&
			((data[start] == 'r') || (data[start] == 'q'))) {
			/*
			 * Decode fields number and lookup field info.
			 */
			sscanf(&data[start + 2], "%d=", &ndx);
			for (fld = CSOfields; fld; fld = fld->next) {
			    if (ndx == fld->id) {
				if ((j + 1) >= finish)
				    break;	/* ignore nulls */
				if (data[start] == 'q') {
				    /*
				     * Append field to query line.
				     */
				    if (fld->lookup) {
					if (fld->indexed)
					    has_indexed = 1;
					if (isBEmpty(command)) {
					    BStrCopy0(command, "query ");
					} else {
					    BStrCat0(command, " ");
					}
					HTBprintf(&command, "%s=\"%s\"",
						  fld->name, &data[j + 1]);
				    } else {
					strcpy(buf,
					       "Warning: non-lookup field ignored<BR>\n");
					(*Target->isa->put_block) (Target,
								   buf,
								   strlen(buf));
				    }
				} else if (data[start] == 'r') {
				    fld->explicit_return = 1;
				}
				break;
			    }
			}
		    } else if (!strncmp(&data[start], "return=", 7)) {
			if (!strcmp(&data[start + 7], "all")) {
			    return_type = 1;
			} else if (!strcmp(&data[start + 7], "selected")) {
			    return_type = 2;
			}
		    }
		}
	    }
	    start = i + 1;
	}
    }
    BStrFree(content);
    if (isBEmpty(command) || !has_indexed) {
	NETCLOSE(s);
	strcpy(buf,
	       "<EM>Error:</EM> At least one indexed field value must be specified!\n");
	(*Target->isa->put_block) (Target, buf, strlen(buf));
	strcpy(buf, "</BODY>\n</HTML>\n");
	(*Target->isa->put_block) (Target, buf, strlen(buf));
	(*Target->isa->_free) (Target);
	free_CSOfields();
	return HT_LOADED;
    }
    /*
     * Append return fields.
     */
    if (return_type == 1) {
	BStrCat0(command, " return all");
    } else if (return_type == 2) {
	BStrCat0(command, " return");
	for (fld = CSOfields; fld; fld = fld->next) {
	    if (fld->explicit_return) {
		HTBprintf(&command, " %s", fld->name);
	    }
	}
    }
    HTBprintf(&command, "%c%c", CR, LF);
    strcpy(buf, "<H2>\n<EM>CSO/PH command:</EM> ");
    (*Target->isa->put_block) (Target, buf, strlen(buf));
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
    strcpy(buf, "</H2>\n");
    (*Target->isa->put_block) (Target, buf, strlen(buf));
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Writing command `"));
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
    status = NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
    if (status < 0) {
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
	free_CSOfields();
	return HTInetStatus("send");
    }
    generate_cso_report(Target);
    NETCLOSE(s);
    (*Target->isa->put_block) (Target, end_form, sizeof(end_form) - 1);
    (*Target->isa->_free) (Target);
    FREE(host);
    free_CSOfields();
    return HT_LOADED;
}

/*	Load by name.						HTLoadGopher
 *	=============
 *
 *  Bug:  No decoding of strange data types as yet.
 *
 */
static int HTLoadGopher(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
{
    char *command;		/* The whole command */
    int status;			/* tcp return */
    char gtype;			/* Gopher Node type */
    char *selector;		/* Selector string */

    if (!acceptable_inited)
	init_acceptable();

    if (!arg)
	return -3;		/* Bad if no name sepcified     */
    if (!*arg)
	return -2;		/* Bad if name had zero length  */
    CTRACE((tfp, "HTGopher: Looking for %s\n", arg));

    /*
     * If it's a port 105 GOPHER_CSO gtype with no ISINDEX token ('?'), use the
     * form-based CSO gateway (otherwise, return an ISINDEX cover page or do
     * the ISINDEX search).  - FM
     */
    {
	int len;

	if ((len = strlen(arg)) > 5) {
	    if (0 == strcmp((const char *) &arg[len - 6], ":105/2")) {
		/* Use CSO gateway. */
		CTRACE((tfp, "HTGopher: Passing to CSO/PH gateway.\n"));
		return HTLoadCSO(arg, anAnchor, format_out, sink);
	    }
	}
    }

    /*
     * If it's a port 79/0[/...] URL, use the finger gateway.  - FM
     */
    if (strstr(arg, ":79/0") != NULL) {
#ifndef DISABLE_FINGER
	CTRACE((tfp, "HTGopher: Passing to finger gateway.\n"));
	return HTLoadFinger(arg, anAnchor, format_out, sink);
#else /* finger is disabled */
	HTAlert(COULD_NOT_ACCESS_DOCUMENT);
	return HT_NOT_LOADED;
#endif /* DISABLE_FINGER */
    }

    /*
     * Get entity type, and selector string.
     */
    {
	char *p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);

	gtype = '1';		/* Default = menu */
	selector = p1;
	if ((*selector++ == '/') && (*selector)) {	/* Skip first slash */
	    gtype = *selector++;	/* Pick up gtype */
	}
	if (gtype == GOPHER_INDEX) {
	    char *query;

	    /*
	     * Search is allowed.
	     */
	    HTAnchor_setIndex(anAnchor, anAnchor->address);
	    query = strchr(selector, '?');	/* Look for search string */
	    if (!query || !query[1]) {	/* No search required */
		target = HTML_new(anAnchor, format_out, sink);
		targetClass = *target->isa;
		display_index(arg, anAnchor);	/* Display "cover page" */
		return HT_LOADED;	/* Local function only */
	    }
	    *query++ = '\0';	/* Skip '?'     */
	    command =
		(char *) malloc(strlen(selector) + 1 + strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");

	    de_escape(command, selector);	/* Bug fix TBL 921208 */

	    strcat(command, "\t");

	    {			/* Remove plus signs 921006 */
		char *p;

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
		}
	    }

	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */
	} else if (gtype == GOPHER_CSO) {
	    char *query;

	    /*
	     * Search is allowed.
	     */
	    query = strchr(selector, '?');	/* Look for search string */
	    if (!query || !query[1]) {	/* No search required */
		target = HTML_new(anAnchor, format_out, sink);
		targetClass = *target->isa;
		display_cso(arg, anAnchor);	/* Display "cover page" */
		return HT_LOADED;	/* Local function only */
	    }
	    HTAnchor_setIndex(anAnchor, anAnchor->address);
	    *query++ = '\0';	/* Skip '?'     */
	    command = (char *) malloc(strlen("query") + 1 +
				      strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");

	    de_escape(command, selector);	/* Bug fix TBL 921208 */

	    strcpy(command, "query ");

	    {			/* Remove plus signs 921006 */
		char *p;

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
		}
	    }
	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */

	} else {		/* Not index */
	    command = (char *) malloc(strlen(selector) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");
	    de_escape(command, selector);
	}
	FREE(p1);
    }

    {
	char *p = command + strlen(command);

	*p++ = CR;		/* Macros to be correct on Mac */
	*p++ = LF;
	*p++ = '\0';
    }

    /*
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "gopher", GOPHER_PORT, &s);
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp, "HTGopher: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	FREE(command);
	return HT_NOT_LOADED;
    }
    if (status < 0) {
	CTRACE((tfp, "HTGopher: Unable to connect to remote host for `%s'.\n",
		arg));
	FREE(command);
	return HTInetStatus("connect");
    }

    HTInitInput(s);		/* Set up input buffering */

    CTRACE((tfp, "HTGopher: Connected, writing command `%s' to socket %d\n",
	    command, s));

#ifdef NOT_ASCII
    {
	char *p;

	for (p = command; *p; p++) {
	    *p = TOASCII(*p);
	}
    }
#endif

    _HTProgress(GOPHER_SENDING_REQUEST);

    status = NETWRITE(s, command, (int) strlen(command));
    FREE(command);
    if (status < 0) {
	CTRACE((tfp, "HTGopher: Unable to send command.\n"));
	return HTInetStatus("send");
    }

    _HTProgress(GOPHER_SENT_REQUEST);

    /*
     * Now read the data from the socket.
     */
    switch (gtype) {

    case GOPHER_TEXT:
	HTParseSocket(WWW_PLAINTEXT, format_out, anAnchor, s, sink);
	break;

    case GOPHER_HTML:
    case GOPHER_CHTML:
	HTParseSocket(WWW_HTML, format_out, anAnchor, s, sink);
	break;

    case GOPHER_GIF:
    case GOPHER_IMAGE:
    case GOPHER_PLUS_IMAGE:
	HTParseSocket(HTAtom_for("image/gif"),
		      format_out, anAnchor, s, sink);
	break;

    case GOPHER_MENU:
    case GOPHER_INDEX:
	target = HTML_new(anAnchor, format_out, sink);
	targetClass = *target->isa;
	parse_menu(arg, anAnchor);
	break;

    case GOPHER_CSO:
	target = HTML_new(anAnchor, format_out, sink);
	targetClass = *target->isa;
	parse_cso(arg, anAnchor);
	break;

    case GOPHER_SOUND:
    case GOPHER_PLUS_SOUND:
	HTParseSocket(WWW_AUDIO, format_out, anAnchor, s, sink);
	break;

    case GOPHER_PLUS_MOVIE:
	HTParseSocket(HTAtom_for("video/mpeg"), format_out, anAnchor, s, sink);
	break;

    case GOPHER_PLUS_PDF:
	HTParseSocket(HTAtom_for("application/pdf"), format_out, anAnchor,
		      s, sink);
	break;

    case GOPHER_MACBINHEX:
    case GOPHER_PCBINARY:
    case GOPHER_UUENCODED:
    case GOPHER_BINARY:
    default:
	/*
	 * Specifying WWW_UNKNOWN forces dump to local disk.
	 */
	HTParseSocket(WWW_UNKNOWN, format_out, anAnchor, s, sink);
	break;

    }				/* switch(gtype) */

    NETCLOSE(s);
    return HT_LOADED;
}

#ifdef GLOBALDEF_IS_MACRO
#define _HTGOPHER_C_1_INIT { "gopher", HTLoadGopher, NULL }
GLOBALDEF(HTProtocol, HTGopher, _HTGOPHER_C_1_INIT);
#define _HTCSO_C_1_INIT { "cso", HTLoadCSO, NULL }
GLOBALDEF(HTProtocol, HTCSO, _HTCSO_C_1_INIT);
#else
GLOBALDEF HTProtocol HTGopher =
{"gopher", HTLoadGopher, NULL};
GLOBALDEF HTProtocol HTCSO =
{"cso", HTLoadCSO, NULL};
#endif /* GLOBALDEF_IS_MACRO */

#endif /* not DISABLE_GOPHER */
@


1.6
log
@automatic merge; regen configure
@
text
@d112 1
a112 1
    int public;
d142 1
a142 1
    char *good =
d331 1
a331 1
		char *format = *selector ? "%s//%s@@%s/" : "%s//%s/";
d728 1
a728 1
static void interpret_cso_key(char *key,
d776 1
a776 1
		if (fld->public && (fld->lookup == 1))
d792 1
a792 1
		if (fld->public)
d870 1
a870 1
    blk->defreturn = blk->explicit_return = blk->public = 0;
d883 1
a883 1
	blk->public = 1;
d911 1
a911 1
    CSOfield_info *last, *new;
d1011 1
a1011 1
			new = typecalloc(CSOfield_info);
d1013 1
a1013 1
			if (!new) {
d1017 1
a1017 1
			    last->next = new;
d1019 2
a1020 2
			    CSOfields = new;
			last = new;
d1022 2
a1023 2
			new->next = (CSOfield_info *) 0;
			new->name = new->name_buf;
d1025 2
a1026 2
			if (alen > sizeof(new->name_buf)) {
			    if (!(new->name = (char *) malloc(alen))) {
d1030 1
a1030 1
			strcpy(new->name, name);
d1032 1
a1032 1
			new->attributes = new->attr_buf;
d1034 2
a1035 2
			if (alen > sizeof(new->attr_buf)) {
			    if (!(new->attributes = (char *) malloc(alen))) {
d1039 5
a1043 5
			strcpy(new->attributes, (char *) &p[i]);
			strcpy((char *) &new->attributes[alen - 2], " ");
			new->description = new->desc_buf;
			new->desc_buf[0] = '\0';
			new->id = atoi(indx);
d1047 1
a1047 1
			parse_cso_field_info(new);
d1077 2
a1078 1
    char *key, *line;
d1080 1
a1080 1
    static char *template[] =
d1122 1
a1122 1
	 template[i];
d1127 1
a1127 1
	for (line = template[i], j = 0; line[j]; j++) {
d1146 1
a1146 1
		line = template[i];
d1156 2
a1157 2
		    for (; template[i]; i++) {
			for (line = template[i]; line[j]; j++) {
d1161 1
a1161 1
					j = strlen(template[--i]) - 1;
d1164 1
a1164 1
				    line = template[i];
@


1.5
log
@automatic merge of lynx-current
@
text
@a79 2
#define GOPHER_PROGRESS(foo) HTAlert(foo)

@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 15
a16 15
**			=============
**
**  History:
**	26 Sep 90	Adapted from other accesses (News, HTTP) TBL
**	29 Nov 91	Downgraded to C, for portable implementation.
**	10 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Added a
**			  form-based CSO/PH gateway.  Can be invoked via a
**			  "cso://host[:port]/" or "gopher://host:105/2"
**			  URL.	If a gopher URL is used with a query token
**			  ('?'), the old ISINDEX procedure will be used
**			  instead of the form-based gateway.
**	15 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Pass
**			  port 79, gtype 0 gopher URLs to the finger
**			  gateway.
*/
d27 2
a28 2
**  Implements.
*/
d37 2
a38 2
**  Gopher entity types.
*/
d50 2
a51 2
#define GOPHER_HTML		'h'		/* HTML */
#define GOPHER_CHTML		'H'		/* HTML */
d53 1
a53 1
#define GOPHER_WWW		'w'		/* W3 address */
d58 1
a58 1
#define GOPHER_PLUS_IMAGE	':'		/* Addition from Gopher Plus */
d66 2
a67 2
**  Hypertext object building machinery.
*/
d85 3
a87 3
**  Module-wide variables.
*/
static int s;				/* Socket for gopher or CSO host */
d90 2
a91 2
	const HTStructuredClass * isa;	/* For gopher streams */
	/* ... */
d94 1
a94 1
static HTStructured *target;		/* the new gopher hypertext */
d97 2
a98 3
struct _HTStream
{
  HTStreamClass * isa;			/* For form-based CSO  gateway - FM */
d101 17
a117 17
typedef struct _CSOfield_info {		/* For form-based CSO gateway - FM */
    struct _CSOfield_info *	next;
    char *			name;
    char *			attributes;
    char *			description;
    int				id;
    int				lookup;
    int				indexed;
    int				url;
    int				max_size;
    int				defreturn;
    int				explicit_return;
    int				reserved;
    int				public;
    char			name_buf[16];	/* Avoid malloc if we can */
    char			desc_buf[32];	/* Avoid malloc if we can */
    char			attr_buf[80];	/* Avoid malloc if we can */
d120 1
a120 1
static CSOfield_info *CSOfields = NULL; /* For form-based CSO gateway - FM */
d122 11
a132 11
typedef struct _CSOformgen_context {	 /* For form-based CSO gateway - FM */
    char *		host;
    char *		seek;
    CSOfield_info *	fld;
    int			port;
    int			cur_line;
    int			cur_off;
    int			rep_line;
    int			rep_off;
    int			public_override;
    int			field_select;
d136 2
a137 2
**	=========================================
*/
d141 1
a141 1
static void init_acceptable (void)
d144 4
a147 3
    char * good =
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
    for(i = 0; i < 256; i++)
d149 2
a150 2
    for(; *good; good++)
	acceptable[(unsigned int)*good] = YES;
d155 2
a156 2
**	========================
*/
d159 1
a159 1
static char from_hex (char  c)
d161 4
a164 4
    return (char) (       (c>='0')&&(c<='9') ? c-'0'
			: (c>='A')&&(c<='F') ? c-'A'+10
			: (c>='a')&&(c<='f') ? c-'a'+10
			:		       0);
d168 11
a178 11
**	==================
**
**	The title of the destination is set, as there is no way
**	of knowing what the title is when we arrive.
**
** On entry,
**	HT	is in append mode.
**	text	points to the text to be put into the file, 0 terminated.
**	addr	points to the hypertext refernce address 0 terminated.
*/
BOOLEAN HT_Is_Gopher_URL=FALSE;
d180 1
a180 1
static void write_anchor (const char * text, const char * addr)
d183 1
a183 1
    const char * value[HTML_A_ATTRIBUTES];
d190 1
a190 1
    ((const char **)value)[HTML_A_HREF] = addr;
d192 1
a192 1
    ((const char **)value)[HTML_A_TITLE] = text;
d194 1
a194 1
    CTRACE((tfp,"HTGopher: adding URL: %s\n",addr));
d196 3
a198 3
    HT_Is_Gopher_URL = TRUE;  /* tell HTML.c that this is a Gopher URL */
    (*targetClass.start_element)(target, HTML_A, present,
				 (const char **)value, -1, 0);
d205 4
a208 5
**	============================
*/
static void parse_menu (
	const char *		arg GCC_UNUSED,
	HTParentAnchor *	anAnchor)
a224 1

d249 1
a249 1
    while ((ich=NEXT_CHAR) != EOF) {
d252 2
a253 1
	    CTRACE((tfp, "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
d257 4
a260 3
	if ((char)ich != LF) {
	    *p = (char) ich;    /* Put character in line */
	    if (p< &line[BIG-1]) p++;
d264 1
a264 1
	    bytes += p-line;	/* add size */
d277 1
a277 1
	    if ((gtype=='.') && ((*p=='\r') || (*p==0)))
d284 1
a284 1
		    *selector++ = '\0'; /* Terminate name */
d296 1
a296 1
			*host++ = '\0'; /* Terminate selector */
d300 1
d303 9
a311 8
			    if (junk) *junk++ = '\0';	/* Chop port */
			    if ((port[1]=='0') && (!port[2]))
				port[0] = '\0'; /* 0 means none */
			} /* no port */
		    } /* host ok */
		} /* selector ok */
	    } /* gtype and name ok */

d314 2
a315 1
		int i = strlen(name)-1;
d327 1
a327 1
	    /* Information or separator line */
d331 1
a331 1
	    } else if (port) {		/* Other types need port */
d338 1
a338 3
		}
		else if (gtype == GOPHER_TN3270)
		{
d341 1
a341 2
		}
		else {			/* If parsed ok */
d344 50
a393 50
		    switch(gtype) {
			case GOPHER_TEXT:
			    PUTS("(FILE) ");
			    break;
			case GOPHER_MENU:
			    PUTS(" (DIR) ");
			    break;
			case GOPHER_CSO:
			    PUTS(" (CSO) ");
			    break;
			case GOPHER_PCBINARY:
			    PUTS(" (BIN) ");
			    break;
			case GOPHER_UUENCODED:
			    PUTS(" (UUE) ");
			    break;
			case GOPHER_INDEX:
			    PUTS("  (?)  ");
			    break;
			case GOPHER_BINARY:
			    PUTS(" (BIN) ");
			    break;
			case GOPHER_GIF:
			case GOPHER_IMAGE:
			case GOPHER_PLUS_IMAGE:
			    PUTS(" (IMG) ");
			    break;
			case GOPHER_SOUND:
			case GOPHER_PLUS_SOUND:
			    PUTS(" (SND) ");
			    break;
			case GOPHER_MACBINHEX:
			    PUTS(" (HQX) ");
			    break;
			case GOPHER_HTML:
			case GOPHER_CHTML:
			    PUTS("(HTML) ");
			    break;
			case 'm':
			    PUTS("(MIME) ");
			    break;
			case GOPHER_PLUS_MOVIE:
			    PUTS(" (MOV) ");
			    break;
			case GOPHER_PLUS_PDF:
			    PUTS(" (PDF) ");
			    break;
			default:
			    PUTS("(UNKN) ");
			    break;
d398 1
a398 1
		    for(r = selector; *r; r++) { /* Encode selector string */
d403 3
a405 3
				HEX_ESCAPE,	/* Means hex coming */
				hex[(TOASCII(*r)) >> 4],
				hex[(TOASCII(*r)) & 15]);
d411 1
a411 1
		if (strcmp (address, "gopher://error.host:1/0"))
d416 1
a416 1
	    } else { /* parse error */
d420 1
a420 1
	    } /* parse error */
d423 1
a423 1
	    p = line;	/* Start again at beginning of line */
d425 1
a425 1
	} /* if end of line */
d427 1
a427 1
    } /* Loop over characters */
d429 1
a429 1
end_html:
d442 14
a455 15
**	==================================================
**
**   Accepts an open socket to a CSO server waiting to send us
**   data and puts it on the screen in a reasonable manner.
**
**   Perhaps this data can be automatically linked to some
**   other source as well???
**
**  Taken from hacking by Lou Montulli@@ukanaix.cc.ukans.edu
**  on XMosaic-1.1, and put on libwww 2.11 by Arthur Secret,
**  secret@@dxcern.cern.ch .
*/
static void parse_cso (
	const char *		arg,
	HTParentAnchor *	anAnchor)
d460 1
a460 1
    char *second_colon, last_char='\0';
d486 29
a514 17
    **	Start grabbing chars from the network.
    */
    while ((ich=NEXT_CHAR) != EOF)
	{
	    if ((char)ich != LF)
		{
		    *p = (char) ich;    /* Put character in line */
		    if (p< &line[BIG-1]) p++;
		}
	    else
		{
		    *p = '\0';		/* Terminate line */
		    p = line;		/* Scan it to parse it */
		    /*
		    **	OK we now have a line in 'p'.
		    **	Lets parse it and print it.
		    */
d516 9
a524 6
		    /*
		    **	Break on line that begins with a 2.
		    **	It's the end of data.
		    */
		    if (*p == '2')
			break;
d526 11
a536 5
		    /*
		    **	Lines beginning with 5 are errors.
		    **	Print them and quit.
		    */
		    if (*p == '5') {
a537 3
			PUTS(p+4);
			END(HTML_H2);
			break;
d540 14
a553 10
		    if (*p == '-') {
			/*
			**  Data lines look like  -200:#:
			**  where # is the search result number and can be
			**  multiple digits (infinite?).
			**  Find the second colon and check the digit to the
			**  left of it to see if they are diferent.
			**  If they are then a different person is starting.
			**  Make this line an <h2>.
			*/
d555 5
a559 13
			/*
			**  Find the second_colon.
			*/
			second_colon = strchr( strchr(p,':')+1, ':');

			if(second_colon != NULL) {  /* error check */

			    if (*(second_colon-1) != last_char)
				/* print seperator */
			    {
				END(HTML_PRE);
				START(HTML_H2);
			    }
d561 6
d568 5
a572 27
			    /*
			    **	Right now the record appears with the alias
			    **	(first line) as the header and the rest as
			    **	<pre> text.
			    **	It might look better with the name as the
			    **	header and the rest as a <ul> with <li> tags.
			    **	I'm not sure whether the name field comes in
			    **	any special order or if its even required in
			    **	a record, so for now the first line is the
			    **	header no matter what it is (it's almost
			    **	always the alias).
			    **	A <dl> with the first line as the <DT> and
			    **	the rest as some form of <DD> might good also?
			    */

			    /*
			    **	Print data.
			    */
			    PUTS(second_colon+1);
			    PUTC('\n');

			    if (*(second_colon-1) != last_char)
				/* end seperator */
			    {
				END(HTML_H2);
				START(HTML_PRE);
			    }
d574 3
a576 9
			    /*
			    **	Save the char before the second colon
			    **	for comparison on the next pass.
			    */
			    last_char =  *(second_colon-1) ;

			} /* end if second_colon */
		    } /* end if *p == '-' */
		} /* if end of line */
d578 1
a578 1
	} /* Loop over characters */
d586 2
a587 2
    return;  /* all done */
} /* end of procedure */
d590 4
a593 5
**	========================================
*/
static void display_cso (
	const char *		arg,
	HTParentAnchor *	anAnchor)
d595 1
a595 1
    const char * title;
d614 2
a615 2
       PUTS(arg);
       PUTS(INDEX_SEGMENT);
d633 4
a636 5
**	================================
*/
static void display_index (
				  const char * arg,
				  HTParentAnchor *anAnchor)
d638 1
a638 1
    const char * title;
d658 2
a659 2
       PUTS(arg);
       PUTS(INDEX_SEGMENT);
d674 5
a678 5
**	====================================
**
**	The % hex escapes are converted. Otheriwse, the string is copied.
*/
static void de_escape (char * command, const char * selector)
d680 5
a684 4
    const char * p = selector;
    char * q = command;
	if (command == NULL)
	    outofmem(__FILE__, "HTLoadGopher");
d689 1
d692 1
a692 1
	    b =   from_hex(c);
d694 3
a696 2
	    if (!c) break;	/* Odd number of chars! */
	    *q++ = (char) FROMASCII((b<<4) + from_hex(c));
d701 1
a701 1
    *q++ = '\0';	/* Terminate command */
a703 1

d705 3
a707 3
**	===================================
*/
static void free_CSOfields (void)
d728 7
a734 8
**	=========================================
*/
static void interpret_cso_key (
	char *			key,
	char *			buf,
	int *			length,
	CSOformgen_context *	ctx,
	HTStream *		Target)
d740 2
a741 2
	**  Most substitutions only recognized inside of loops.
	*/
d743 1
d773 1
a773 1
	  case 0:
d775 2
a776 2
	    **	'Query' fields, public and lookup attributes.
	    */
d778 2
a779 2
		 if (fld->public && (fld->lookup==1))
		     break;
d781 1
a781 1
	  case 1:
d783 2
a784 2
	    **	'Query' fields, accept lookup attribute.
	    */
d789 1
a789 1
	  case 2:
d791 2
a792 2
	    **	'Return' fields, public only.
	    */
d797 1
a797 1
	  case 3:
d799 2
a800 2
	    **	All fields.
	    */
d812 2
a813 2
	**  Begin iteration sequence.
	*/
d824 2
a825 2
	**  Special, locate name field.  Flag lookup so QFIELDS will skip it.
	*/
d834 3
a836 3
    } else if (0 == strncmp (key, "$(HOST)", 7)) {
	strcpy (buf, ctx->host);
    } else if (0 == strncmp (key, "$(PORT)", 7)) {
d840 2
a841 2
	**  No match, dump key to buffer so client sees it for debugging.
	*/
d843 1
d846 1
a846 1
	    if (out > sizeof(buf)-2) {
d848 1
a848 1
		(*Target->isa->put_block)(Target, buf, strlen(buf));
d862 3
a864 4
**	=====================================================
*/
static int parse_cso_field_info (
	CSOfield_info *	blk)
d869 2
a870 2
    ** Initialize all fields to default values.
    */
d875 3
a877 3
    **	Search for keywords in info string and set values.  Attributes
    **	are converted to all lower-case for comparison.
    */
d903 4
a906 5
**	================================================
*/
static int parse_cso_fields (
	char *		buf,
	int		size)
d920 2
a921 2
    **	Start grabbing chars from the network.
    */
d924 2
a925 1
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d931 3
a933 3
	if ((char)ich != LF) {
	    *p = (char) ich;    /* Put character in buffer */
	    if (p < &buf[size-1]) {
d944 2
a945 3
	    **	Break on line that begins with a 2.
	    **	It's the end of data.
	    */
d950 2
a951 3
	    **	Lines beginning with 5 are errors.
	    **	Print them and quit.
	    */
d953 1
a953 1
		strcpy (buf, p);
d959 4
a962 4
		**  Data lines look like  -200:#:
		**  where # is the search result number and can be
		**  multiple digits (infinite?).
		*/
d965 3
a967 3
		** Check status, ignore any non-success.
		*/
		if (p[1] != '2' )
d971 3
a973 3
		** Parse fields within returned line into status, ndx, name,
		** data.
		*/
d977 1
a977 1
		    if (p[i] == ':' ) {
d980 2
a981 2
			    indx = (char *)&p[i+1];
			    code = atoi (indx);
d983 1
a983 1
			    name = (char *)&p[i+1];
d991 2
a992 2
		**  Add data to field structure.
		*/
d996 4
a999 4
			**  Remaining data are description.
			**  Save in current info block.
			*/
			alen = strlen((char *)&p[i]) + 1;
d1003 1
a1003 1
			    if (!(last->description = (char *)malloc(alen))) {
d1007 1
a1007 1
			strcpy(last->description, (char *)&p[i]);
d1010 3
a1012 3
			**  Initialize new block, append to end of list
			**  to preserve order.
			*/
d1014 1
d1028 1
a1028 1
			    if (!(new->name = (char *)malloc(alen))) {
d1032 1
a1032 1
			strcpy (new->name, name);
d1035 1
a1035 1
			alen = strlen((char *)&p[i]) + 2;
d1037 1
a1037 1
			    if (!(new->attributes = (char *)malloc(alen))) {
d1041 2
a1042 2
			strcpy(new->attributes, (char *)&p[i]);
			strcpy((char *)&new->attributes[alen-2], " ");
d1047 2
a1048 2
			**  Scan for keywords.
			*/
d1054 2
a1055 2
	    } /* end if *p == '-' */
	} /* if end of line */
d1057 1
a1057 1
    } /* Loop over characters */
d1062 1
a1062 1
	return -1; /* no response */
d1065 2
a1066 2
    return 0;  /* all done */
} /* end of procedure */
d1069 6
a1074 7
**	====================================================
*/
static int generate_cso_form (
	char *		host,
	int		port,
	char *		buf,
	HTStream *	Target)
d1081 27
a1107 25
    static char *template[] = {
   "<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
   "<H2><I>CSO/PH Query Form</I> for <EM>$(HOST)</EM></H2>",
   "To search the database for a name, fill in one or more of the fields",
   "in the form below and activate the 'Submit query' button.  At least",
   "one of the entered fields must be flagged as indexed.",
   "<HR><FORM method=\"POST\" action=\"cso://$(HOST)/\">",
   "[ <input type=\"submit\" value=\"Submit query\"> | ",
   "<input type=\"reset\" value=\"Clear fields\"> ]",
   "<P><DL>",
   "   <DT>Search parameters (* indicates indexed field):",
   "   <DD>", "$(NAMEFLD)    <DL COMPACT>\n    <DT><I>$(FDESC)</I>$(FNDX)",
   "    <DD>Last: <input name=\"q_$(FID)\" type=\"text\" size=49$(FSIZE2)>",
   "    <DD>First: <input name=\"q_$(FID)\" type=\"text\" size=48$(FSIZE2)>",
   "$(QFIELDS)    <DT><I>$(FDESC)</I>$(FNDX)",
   "    <DD><input name=\"q_$(FID)\" type=\"text\" $(FSIZE)>\n$(NEXTFLD)",
   "    </DL>",
   "   </DL>\n<P><DL>",
   "   <DT>Output format:",
   "   <DD>Returned data option: <select name=\"return\">",
   "    <option>default<option selected>all<option>selected</select><BR>",
   "$(RFIELDS)    <input type=\"checkbox\" name=\"r_$(FID)\"$(FDEF)> $(FDESC)<BR>",
   "$(NEXTFLD)    ",
   "   </DL></FORM><HR>\n</BODY>\n</HTML>",
   (char *) 0
d1117 3
a1119 3
    **	Parse the strings in the template array to produce HTML document
    **	to send to client.  First line is skipped for 'full' lists.
    */
d1122 3
a1124 1
    for (i = full_flag ? /***1***/ 0 : 0; template[i]; i++) {
d1126 4
a1129 4
	**  Search the current string for substitution, flagged by $(
	*/
	for (line=template[i], j = 0; line[j]; j++) {
	    if ((line[j] == '$') && (line[j+1] == '(')) {
d1131 3
a1133 3
		** Command detected, flush output buffer and find closing ')'
		** that delimits the command.
		*/
d1136 1
a1136 1
		    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1138 1
a1138 2
		for (key = &line[j]; line[j+1] && (line[j] != ')'); j++)
		    ;
d1140 2
a1141 2
		**  Save context, interpet command and restore updated context.
		*/
d1152 3
a1154 3
		    **	Command wants us to skip (forward) to indicated token.
		    **	Start at current position.
		    */
d1156 1
d1162 1
a1162 1
					j = strlen(template[--i])-1;
d1176 1
d1178 1
a1178 1
			(*Target->isa->put_block)(Target, temp, strlen(temp));
d1184 2
a1185 2
		**  Non-command text, add to output buffer.
		*/
d1187 1
a1187 1
		if (out > (sizeof(buf)-3)) {
d1189 1
a1189 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1198 1
a1198 1
	(*Target->isa->put_block)(Target, buf, strlen(buf));
d1204 3
a1206 4
**	==============================================================
*/
static int generate_cso_report (
	HTStream *	Target)
d1218 2
a1219 2
    **	Read lines until non-negative status.
    */
d1222 2
a1223 2
    **	Start grabbing chars from the network.
    */
d1226 3
a1228 2
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress (CONNECTION_INTERRUPTED);
d1232 3
a1234 3
	if ((char)ich != LF) {
	    *p = (char) ich;    /* Put character in line */
	    if (p < &line[BIG-1]) {
d1240 2
a1241 3
	    **	OK we now have a line.
	    **	Load it as 'p' and parse it.
	    */
d1253 1
a1253 1
			fname = ndx_str = &p[i+1];
d1255 1
a1255 1
			fname = &p[i+1];
d1265 1
a1265 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1269 2
a1270 2
		  "<HR><DL><DT>Information/status<DD><DL><DT>\n");
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1273 2
a1274 2
	      "<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n", ndx);
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1280 1
a1280 1
		(*Target->isa->put_block)(Target, buf, strlen(buf));
d1292 1
a1292 1
			    fname[i--] = '\0'; /* trim trailing */
d1313 3
a1315 3
				"<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",
				fname, fvalue, fvalue);
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1318 1
a1318 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1341 2
a1342 1
				       strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1359 1
a1359 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1363 1
a1363 1
		    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1403 1
a1403 1
		    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1406 2
a1407 2
		HTSprintf0(&buf, "<DD>%s\n", fname ? fname : rcode );
		(*Target->isa->put_block)(Target, buf, strlen(buf));
d1411 1
a1411 1
end_CSOreport:
d1414 1
a1414 1
	(*Target->isa->put_block)(Target, buf, strlen(buf));
d1421 6
a1426 7
**	=====================================
*/
static int HTLoadCSO (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1431 1
a1431 1
    int status;				/* tcp return */
d1442 1
a1442 1
	 init_acceptable();
d1445 1
a1445 1
	return -3;		/* Bad if no name sepcified	*/
d1447 1
a1447 1
	return -2;		/* Bad if name had zero length	*/
d1451 3
a1453 3
    **	Set up a socket to the server for the data.
    */
    status = HTDoConnect (arg, "cso", CSO_PORT, &s);
d1456 5
a1460 4
	**  Interrupt cleanly.
	*/
	CTRACE((tfp, "HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress (CONNECTION_INTERRUPTED);
d1465 1
a1465 1
		    arg));
d1477 1
a1477 1
    _HTProgress (GOPHER_SENDING_CSO_REQUEST);
d1484 1
a1484 1
    _HTProgress (GOPHER_SENT_CSO_REQUEST);
d1487 2
a1488 2
    **	Now read the data from the socket.
    */
d1493 1
a1493 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d1506 1
d1517 1
a1517 1
	    port = atoi((cp+1));
d1526 1
a1526 1
	(*Target->isa->_free)(Target);
d1534 3
a1536 3
     "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n",
	    host);
    (*Target->isa->put_block)(Target, BStrData(command), BStrLen(command));
d1542 1
a1542 1
    if (BStrData(content)[BStrLen(content)-1] != '&')
d1563 3
a1565 3
	    **	Value parsed.  Unescape characters and look for first '='
	    **	to delimit field name from value.
	    */
d1572 4
a1575 4
		    **	data[start..j-1] is field name,
		    **	[j+1..finish-1] is value.
		    */
		    if ((data[start+1] == '_') &&
d1578 3
a1580 3
			**  Decode fields number and lookup field info.
			*/
			sscanf (&data[start+2], "%d=", &ndx);
d1582 2
a1583 2
			    if (ndx==fld->id) {
				if ((j+1) >= finish)
d1598 1
a1598 1
						  fld->name, &data[j+1]);
d1601 4
a1604 4
				"Warning: non-lookup field ignored<BR>\n");
					(*Target->isa->put_block)(Target,
								  buf,
								  strlen(buf));
d1613 1
a1613 1
			if (!strcmp(&data[start+7], "all")) {
d1615 1
a1615 1
			} else if (!strcmp(&data[start+7], "selected")) {
d1628 2
a1629 2
  "<EM>Error:</EM> At least one indexed field value must be specified!\n");
	(*Target->isa->put_block)(Target, buf, strlen(buf));
d1631 2
a1632 2
	(*Target->isa->put_block)(Target, buf, strlen(buf));
	(*Target->isa->_free)(Target);
d1637 2
a1638 2
    **	Append return fields.
    */
d1651 2
a1652 2
    (*Target->isa->put_block)(Target, buf, strlen(buf));
    (*Target->isa->put_block)(Target, BStrData(command), BStrLen(command));
d1654 1
a1654 1
    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1656 1
a1656 1
	CTRACE((tfp, "HTLoadCSO: Writing command `"));  
d1669 2
a1670 2
    (*Target->isa->put_block)(Target, end_form, sizeof(end_form)-1);
    (*Target->isa->_free)(Target);
d1677 9
a1685 10
**	=============
**
**  Bug:  No decoding of strange data types as yet.
**
*/
static int HTLoadGopher (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1687 4
a1690 4
    char *command;			/* The whole command */
    int status;				/* tcp return */
    char gtype;				/* Gopher Node type */
    char * selector;			/* Selector string */
d1693 1
a1693 1
	 init_acceptable();
d1696 1
a1696 1
	return -3;		/* Bad if no name sepcified	*/
d1698 1
a1698 1
	return -2;		/* Bad if name had zero length	*/
d1702 4
a1705 4
    **	If it's a port 105 GOPHER_CSO gtype with no ISINDEX token ('?'),
    **	use the form-based CSO gateway (otherwise, return an ISINDEX
    **	cover page or do the ISINDEX search). - FM
    */
d1710 1
a1710 1
	    if (0 == strcmp((const char *)&arg[len-6], ":105/2")) {
d1719 2
a1720 2
    **	If it's a port 79/0[/...] URL, use the finger gateway. - FM
    */
d1732 2
a1733 2
    **	Get entity type, and selector string.
    */
d1735 2
a1736 1
	char * p1 = HTParse(arg, "", PARSE_PATH|PARSE_PUNCTUATION);
d1739 2
a1740 2
	if ((*selector++=='/') && (*selector)) {	/* Skip first slash */
	    gtype = *selector++;			/* Pick up gtype */
d1743 2
a1744 1
	    char * query;
d1746 2
a1747 2
	    **	Search is allowed.
	    */
d1750 1
a1750 1
	    if (!query || !query[1]) {		/* No search required */
d1754 1
a1754 1
		return HT_LOADED;		/* Local function only */
d1756 1
a1756 1
	    *query++ = '\0';			/* Skip '?'	*/
d1758 3
a1760 3
		    (char *)malloc(strlen(selector)+ 1 + strlen(query)+ 2 + 1);
	      if (command == NULL)
		  outofmem(__FILE__, "HTLoadGopher");
d1766 1
a1766 1
	    {					/* Remove plus signs 921006 */
d1768 4
a1771 2
		for (p=query; *p; p++) {
		    if (*p == '+') *p = ' ';
d1775 1
a1775 1
	    de_escape(&command[strlen(command)], query);/* bug fix LJM 940415 */
d1777 2
a1778 1
	    char * query;
d1780 2
a1781 2
	    **	Search is allowed.
	    */
d1783 1
a1783 1
	    if (!query || !query[1]) {		/* No search required */
d1787 1
a1787 1
		return HT_LOADED;		/* Local function only */
d1790 5
a1794 4
	    *query++ = '\0';			/* Skip '?'	*/
	    command = (char *)malloc(strlen("query")+1 + strlen(query)+2+1);
	      if (command == NULL)
		  outofmem(__FILE__, "HTLoadGopher");
d1800 1
a1800 1
	    {					/* Remove plus signs 921006 */
d1802 4
a1805 2
		for (p=query; *p; p++) {
		    if (*p == '+') *p = ' ';
d1808 1
a1808 1
	    de_escape(&command[strlen(command)], query);/* bug fix LJM 940415 */
d1810 2
a1811 2
	} else {				/* Not index */
	    command = (char *)malloc(strlen(selector)+2+1);
d1820 2
a1821 1
	char * p = command + strlen(command);
d1828 3
a1830 3
    **	Set up a socket to the server for the data.
    */
    status = HTDoConnect (arg, "gopher", GOPHER_PORT, &s);
d1833 2
a1834 2
	**  Interrupt cleanly.
	*/
d1836 1
a1836 1
	_HTProgress (CONNECTION_INTERRUPTED);
d1842 1
a1842 1
		    arg));
d1850 1
a1850 1
		command, s));
d1854 2
a1855 1
	char * p;
d1862 1
a1862 1
    _HTProgress (GOPHER_SENDING_REQUEST);
d1864 1
a1864 1
    status = NETWRITE(s, command, (int)strlen(command));
d1871 1
a1871 1
    _HTProgress (GOPHER_SENT_REQUEST);
d1874 2
a1875 2
    **	Now read the data from the socket.
    */
d1878 1
a1878 1
    case GOPHER_TEXT :
d1882 2
a1883 2
    case GOPHER_HTML :
    case GOPHER_CHTML :
d1891 1
a1891 1
			   format_out, anAnchor, s, sink);
d1894 2
a1895 2
    case GOPHER_MENU :
    case GOPHER_INDEX :
d1907 2
a1908 2
    case GOPHER_SOUND :
    case GOPHER_PLUS_SOUND :
d1918 1
a1918 1
				  s, sink);
d1927 3
a1929 3
	**  Specifying WWW_UNKNOWN forces dump to local disk.
	*/
	HTParseSocket (WWW_UNKNOWN, format_out, anAnchor, s, sink);
d1932 1
a1932 1
    } /* switch(gtype) */
d1940 1
a1940 1
GLOBALDEF (HTProtocol, HTGopher, _HTGOPHER_C_1_INIT);
d1942 1
a1942 1
GLOBALDEF (HTProtocol, HTCSO, _HTCSO_C_1_INIT);
d1944 4
a1947 2
GLOBALDEF HTProtocol HTGopher = { "gopher", HTLoadGopher, NULL };
GLOBALDEF HTProtocol HTCSO = { "cso", HTLoadCSO, NULL };
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d87 1
a87 1
PRIVATE int s;				/* Socket for gopher or CSO host */
d90 1
a90 1
	CONST HTStructuredClass * isa;	/* For gopher streams */
d94 2
a95 2
PRIVATE HTStructured *target;		/* the new gopher hypertext */
PRIVATE HTStructuredClass targetClass;	/* Its action routines */
d121 1
a121 1
PRIVATE CSOfield_info *CSOfields = NULL; /* For form-based CSO gateway - FM */
d139 2
a140 2
PRIVATE BOOL acceptable[256];
PRIVATE BOOL acceptable_inited = NO;
d142 1
a142 1
PRIVATE void init_acceptable NOARGS
d157 1
a157 1
PRIVATE CONST char hex[17] = "0123456789abcdef";
d159 1
a159 1
PRIVATE char from_hex ARGS1(char, c)
d178 1
a178 1
PUBLIC BOOLEAN HT_Is_Gopher_URL=FALSE;
d180 1
a180 1
PRIVATE void write_anchor ARGS2(CONST char *,text, CONST char *,addr)
d183 1
a183 1
    CONST char * value[HTML_A_ATTRIBUTES];
d190 1
a190 1
    ((CONST char **)value)[HTML_A_HREF] = addr;
d192 1
a192 1
    ((CONST char **)value)[HTML_A_TITLE] = text;
d198 1
a198 1
				 (CONST char **)value, -1, 0);
d207 3
a209 3
PRIVATE void parse_menu ARGS2(
	CONST char *,		arg GCC_UNUSED,
	HTParentAnchor *,	anAnchor)
d218 1
a218 1
    CONST char *title;
d454 3
a456 3
PRIVATE void parse_cso ARGS2(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor)
d462 1
a462 1
    CONST char *title;
d601 3
a603 3
PRIVATE void display_cso ARGS2(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor)
d605 1
a605 1
    CONST char * title;
d645 3
a647 3
PRIVATE void display_index ARGS2(
				  CONST char *, arg,
				  HTParentAnchor *,anAnchor)
d649 1
a649 1
    CONST char * title;
d689 1
a689 1
PRIVATE void de_escape ARGS2(char *, command, CONST char *, selector)
d691 1
a691 1
    CONST char * p = selector;
d716 1
a716 1
PRIVATE void free_CSOfields NOPARAMS
d739 6
a744 6
PRIVATE void interpret_cso_key ARGS5(
	char *,			key,
	char *,			buf,
	int *,			length,
	CSOformgen_context *,	ctx,
	HTStream *,		Target)
d872 2
a873 2
PRIVATE int parse_cso_field_info ARGS1(
	CSOfield_info *,	blk)
d914 3
a916 3
PRIVATE int parse_cso_fields ARGS2(
	char *,		buf,
	int,		size)
d1081 5
a1085 5
PRIVATE int generate_cso_form ARGS4(
	char *,		host,
	int,		port,
	char *,		buf,
	HTStream *,	Target)
d1212 2
a1213 2
PRIVATE int generate_cso_report ARGS1(
	HTStream *,	Target)
d1429 5
a1433 5
PRIVATE int HTLoadCSO ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1435 1
a1435 1
    static CONST char end_form[] = "</BODY>\n</HTML>\n";
d1687 5
a1691 5
PRIVATE int HTLoadGopher ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1716 1
a1716 1
	    if (0 == strcmp((CONST char *)&arg[len-6], ":105/2")) {
d1940 2
a1941 2
GLOBALDEF PUBLIC HTProtocol HTGopher = { "gopher", HTLoadGopher, NULL };
GLOBALDEF PUBLIC HTProtocol HTCSO = { "cso", HTLoadCSO, NULL };
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d161 1
a161 1
    return		  (c>='0')&&(c<='9') ? c-'0'
d164 1
a164 1
			:		       0;
d194 1
a194 1
    CTRACE(tfp,"HTGopher: adding URL: %s\n",addr);
d254 1
a254 1
	    CTRACE(tfp, "HTGopher: Interrupted in HTGetCharacter, apparently.\n");
d259 1
a259 1
	    *p = ich;		/* Put character in line */
d267 1
a267 1
	    CTRACE(tfp, "HTGopher: Menu item: %s\n", line);
d330 1
d334 1
a334 5
		    if (*selector)
			HTSprintf0(&address, "telnet://%s@@%s/",
					   selector, host);
		    else
			HTSprintf0(&address, "telnet://%s/", host);
d339 1
a339 5
		    if (*selector)
			HTSprintf0(&address, "tn3270://%s@@%s/",
				selector, host);
		    else
			HTSprintf0(&address, "tn3270://%s/", host);
d399 1
a399 1
			if (acceptable[(unsigned char)*r]) {
d417 1
a417 1
		CTRACE(tfp, "HTGopher: Bad menu item.\n");
d493 1
a493 1
		    *p = ich;		/* Put character in line */
d704 1
a704 1
	    *q++ = FROMASCII((b<<4) + from_hex(c));
d756 1
a756 3
	    sprintf(buf, "%s%s%s", fld->description,
		    ctx->public_override ? /***" "***/"" : "",
		    ctx->public_override ? /***fld->attributes***/"" : "");
d934 1
a934 1
	    CTRACE(tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
d941 1
a941 1
	    *p = ich;		/* Put character in buffer */
d975 5
a979 5
	    /*
	    **	Check status, ignore any non-success.
	    */
	    if (p[1] != '2' )
		continue;
d981 18
a998 16
	    /*
	    **	Parse fields within returned line into status, ndx, name, data.
	    */
	    indx = NULL;
	    name = NULL;
	    for (i = 0; p[i]; i++)
		if (p[i] == ':' ) {
		    p[i] = '\0';
		    if (!indx) {
			indx = (char *)&p[i+1];
			code = atoi (indx);
		    } else if (!name) {
			name = (char *)&p[i+1];
		    } else {
		       i++;
		       break;
d1024 1
a1024 1
			new = (CSOfield_info *)calloc(1, sizeof(CSOfield_info));
d1093 1
a1093 1
   "<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
d1233 1
a1233 1
	    CTRACE(tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
d1239 1
a1239 1
	    *p = ich;		/* Put character in line */
d1335 1
a1335 1
			    } else if (strncmp(l, "news:", 5) &&
d1348 1
a1348 1
				       strncmp(l, "mailto:", 7) &&
d1379 1
a1379 1
			} else if (strncmp(l, "news:", 5) &&
d1392 1
a1392 1
				   strncmp(l, "mailto:", 7) &&
d1436 1
a1436 1
    char *host, *cp;
d1439 2
a1440 2
    char *command = NULL;
    char *content = NULL;
d1455 1
a1455 1
    CTRACE(tfp, "HTLoadCSO: Looking for %s\n", arg);
d1465 1
a1465 1
	CTRACE(tfp, "HTLoadCSO: Interrupted on connect; recovering cleanly.\n");
d1470 2
a1471 2
	CTRACE(tfp, "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
		    arg);
d1477 6
a1482 3
    HTSprintf0(&command, "fields%c%c", CR, LF);
    CTRACE(tfp, "HTLoadCSO: Connected, writing command `%s' to socket %d\n",
		command, s);
d1484 2
a1485 2
    status = NETWRITE(s, command, (int)strlen(command));
    FREE(command);
d1487 1
a1487 1
	CTRACE(tfp, "HTLoadCSO: Unable to send command.\n");
d1520 1
a1520 1
    if ((cp=strchr(host, ':')) != NULL) {
d1529 1
a1529 1
    if (!(anAnchor->post_data && *anAnchor->post_data)) {
d1538 1
a1538 1
    HTSprintf0(&command,
d1541 2
a1542 2
    (*Target->isa->put_block)(Target, command, strlen(command));
    FREE(command);
d1545 7
a1551 4
    StrAllocCopy(content, anAnchor->post_data);
    if (content[strlen(content)-1] != '&')
	StrAllocCat(content, "&");
    len = strlen(content);
d1553 2
a1554 2
	if (content[i] == '+') {
	    content[i] = ' ';
d1557 5
a1561 2
    HTUnEscape(content);
    len = strlen(content);
d1566 1
a1566 1
	if (!content[i] || content[i] == '&') {
d1573 1
a1573 1
	    content[finish] = '\0';
d1575 1
a1575 1
		if (content[j] == '=') {
d1577 1
a1577 1
		    **	content[start..j-1] is field name,
d1580 2
a1581 2
		    if ((content[start+1] == '_') &&
			((content[start] == 'r') || (content[start] == 'q'))) {
d1585 1
a1585 1
			sscanf (&content[start+2], "%d=", &ndx);
d1590 1
a1590 1
				if (content[start] == 'q') {
d1597 2
a1598 2
					if (command == 0 || *command == 0) {
					    StrAllocCopy(command, "query ");
d1600 1
a1600 1
					    StrAllocCat(command, " ");
d1602 2
a1603 2
					HTSprintf(&command, "%s=\"%s\"",
						  fld->name, &content[j+1]);
d1611 1
a1611 1
				} else if (content[start] == 'r') {
d1617 2
a1618 2
		    } else if (!strncmp(&content[start],"return=",7)) {
			if (!strcmp(&content[start+7],"all")) {
d1620 1
a1620 1
			} else if (!strcmp(&content[start+7],"selected")) {
d1629 2
a1630 2
    FREE(content);
    if ((command == 0 || *command == 0) || !has_indexed) {
d1645 1
a1645 1
	StrAllocCat(command, " return all");
d1647 1
a1647 1
	StrAllocCat(command, " return");
d1650 1
a1650 1
		HTSprintf(&command, " %s", fld->name);
d1654 1
a1654 1
    HTSprintf(&command, "%c%c", CR, LF);
d1657 1
a1657 1
    (*Target->isa->put_block)(Target, command, strlen(command));
d1660 7
a1666 4
    CTRACE(tfp, "HTLoadCSO: Writing command `%s' to socket %d\n",
		command, s);
    status = NETWRITE(s, command, strlen(command));
    FREE(command);
d1668 1
a1668 1
	CTRACE(tfp, "HTLoadCSO: Unable to send command.\n");
d1705 1
a1705 1
    CTRACE(tfp, "HTGopher: Looking for %s\n", arg);
d1718 1
a1718 1
		CTRACE(tfp, "HTGopher: Passing to CSO/PH gateway.\n");
d1729 1
a1729 1
	CTRACE(tfp, "HTGopher: Passing to finger gateway.\n");
d1732 1
a1732 1
	HTAlert(gettext("Unable to access document!"));
d1832 1
a1832 1
	CTRACE(tfp, "HTGopher: Interrupted on connect; recovering cleanly.\n");
d1838 2
a1839 2
	CTRACE(tfp, "HTGopher: Unable to connect to remote host for `%s'.\n",
		    arg);
d1846 2
a1847 2
    CTRACE(tfp, "HTGopher: Connected, writing command `%s' to socket %d\n",
		command, s);
d1863 1
a1863 1
	CTRACE(tfp, "HTGopher: Unable to send command.\n");
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 15
a16 15
 *			=============
 *
 *  History:
 *	26 Sep 90	Adapted from other accesses (News, HTTP) TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 *	10 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Added a
 *			  form-based CSO/PH gateway.  Can be invoked via a
 *			  "cso://host[:port]/" or "gopher://host:105/2"
 *			  URL.	If a gopher URL is used with a query token
 *			  ('?'), the old ISINDEX procedure will be used
 *			  instead of the form-based gateway.
 *	15 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Pass
 *			  port 79, gtype 0 gopher URLs to the finger
 *			  gateway.
 */
d27 2
a28 2
 *  Implements.
 */
d37 2
a38 2
 *  Gopher entity types.
 */
d50 2
a51 2
#define GOPHER_HTML		'h'	/* HTML */
#define GOPHER_CHTML		'H'	/* HTML */
d53 1
a53 1
#define GOPHER_WWW		'w'	/* W3 address */
d58 1
a58 1
#define GOPHER_PLUS_IMAGE	':'	/* Addition from Gopher Plus */
d66 2
a67 2
 *  Hypertext object building machinery.
 */
d80 2
d85 3
a87 3
 *  Module-wide variables.
 */
static int s;			/* Socket for gopher or CSO host */
d90 2
a91 2
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
d94 2
a95 2
static HTStructured *target;	/* the new gopher hypertext */
static HTStructuredClass targetClass;	/* Its action routines */
d97 3
a99 2
struct _HTStream {
    HTStreamClass *isa;		/* For form-based CSO  gateway - FM */
d102 17
a118 17
typedef struct _CSOfield_info {	/* For form-based CSO gateway - FM */
    struct _CSOfield_info *next;
    char *name;
    char *attributes;
    char *description;
    int id;
    int lookup;
    int indexed;
    int url;
    int max_size;
    int defreturn;
    int explicit_return;
    int reserved;
    int gpublic;
    char name_buf[16];		/* Avoid malloc if we can */
    char desc_buf[32];		/* Avoid malloc if we can */
    char attr_buf[80];		/* Avoid malloc if we can */
d121 1
a121 1
static CSOfield_info *CSOfields = NULL;		/* For form-based CSO gateway - FM */
d123 11
a133 11
typedef struct _CSOformgen_context {	/* For form-based CSO gateway - FM */
    char *host;
    char *seek;
    CSOfield_info *fld;
    int port;
    int cur_line;
    int cur_off;
    int rep_line;
    int rep_off;
    int public_override;
    int field_select;
d137 4
a140 4
 *	=========================================
 */
static BOOL acceptable[256];
static BOOL acceptable_inited = NO;
d142 1
a142 1
static void init_acceptable(void)
d145 3
a147 4
    const char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
d149 2
a150 2
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
d155 3
a157 3
 *	========================
 */
static const char hex[17] = "0123456789abcdef";
d159 1
a159 1
static char from_hex(char c)
d161 4
a164 4
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
d168 11
a178 11
 *	==================
 *
 *	The title of the destination is set, as there is no way
 *	of knowing what the title is when we arrive.
 *
 * On entry,
 *	HT	is in append mode.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext refernce address 0 terminated.
 */
BOOLEAN HT_Is_Gopher_URL = FALSE;
d180 1
a180 1
static void write_anchor(const char *text, const char *addr)
d183 1
a183 1
    const char *value[HTML_A_ATTRIBUTES];
d190 1
a190 1
    ((const char **) value)[HTML_A_HREF] = addr;
d192 1
a192 1
    ((const char **) value)[HTML_A_TITLE] = text;
d194 1
a194 1
    CTRACE((tfp, "HTGopher: adding URL: %s\n", addr));
d196 3
a198 3
    HT_Is_Gopher_URL = TRUE;	/* tell HTML.c that this is a Gopher URL */
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);
d205 5
a209 4
 *	============================
 */
static void parse_menu(const char *arg GCC_UNUSED,
		       HTParentAnchor *anAnchor)
d218 1
a218 1
    const char *title;
d226 1
d251 1
a251 1
    while ((ich = NEXT_CHAR) != EOF) {
d254 1
a254 2
	    CTRACE((tfp,
		    "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
d258 3
a260 4
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;
d264 1
a264 1
	    bytes += p - line;	/* add size */
d267 1
a267 1
	    CTRACE((tfp, "HTGopher: Menu item: %s\n", line));
d277 1
a277 1
	    if ((gtype == '.') && ((*p == '\r') || (*p == 0)))
d284 1
a284 1
		    *selector++ = '\0';		/* Terminate name */
d296 1
a296 1
			*host++ = '\0';		/* Terminate selector */
a299 1

d302 8
a309 9
			    if (junk)
				*junk++ = '\0';		/* Chop port */
			    if ((port[1] == '0') && (!port[2]))
				port[0] = '\0';		/* 0 means none */
			}	/* no port */
		    }		/* host ok */
		}		/* selector ok */
	    }
	    /* gtype and name ok */
d312 1
a312 2
		int i = strlen(name) - 1;

d324 1
a324 1
		/* Information or separator line */
d328 1
a328 1
	    } else if (port) {	/* Other types need port */
a329 1
		const char *format = *selector ? "%s//%s@@%s/" : "%s//%s/";
d333 8
a340 2
		    HTSprintf0(&address, format, STR_TELNET_URL, selector, host);
		} else if (gtype == GOPHER_TN3270) {
d342 7
a348 2
		    HTSprintf0(&address, format, STR_TN3270_URL, selector, host);
		} else {	/* If parsed ok */
d351 50
a400 50
		    switch (gtype) {
		    case GOPHER_TEXT:
			PUTS("(FILE) ");
			break;
		    case GOPHER_MENU:
			PUTS(" (DIR) ");
			break;
		    case GOPHER_CSO:
			PUTS(" (CSO) ");
			break;
		    case GOPHER_PCBINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_UUENCODED:
			PUTS(" (UUE) ");
			break;
		    case GOPHER_INDEX:
			PUTS("  (?)  ");
			break;
		    case GOPHER_BINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_GIF:
		    case GOPHER_IMAGE:
		    case GOPHER_PLUS_IMAGE:
			PUTS(" (IMG) ");
			break;
		    case GOPHER_SOUND:
		    case GOPHER_PLUS_SOUND:
			PUTS(" (SND) ");
			break;
		    case GOPHER_MACBINHEX:
			PUTS(" (HQX) ");
			break;
		    case GOPHER_HTML:
		    case GOPHER_CHTML:
			PUTS("(HTML) ");
			break;
		    case 'm':
			PUTS("(MIME) ");
			break;
		    case GOPHER_PLUS_MOVIE:
			PUTS(" (MOV) ");
			break;
		    case GOPHER_PLUS_PDF:
			PUTS(" (PDF) ");
			break;
		    default:
			PUTS("(UNKN) ");
			break;
d405 2
a406 2
		    for (r = selector; *r; r++) {	/* Encode selector string */
			if (acceptable[UCH(*r)]) {
d410 3
a412 3
				      HEX_ESCAPE,	/* Means hex coming */
				      hex[(TOASCII(*r)) >> 4],
				      hex[(TOASCII(*r)) & 15]);
d418 1
a418 1
		if (strcmp(address, "gopher://error.host:1/0"))
d423 2
a424 2
	    } else {		/* parse error */
		CTRACE((tfp, "HTGopher: Bad menu item.\n"));
d427 1
a427 1
	    }			/* parse error */
d430 1
a430 1
	    p = line;		/* Start again at beginning of line */
d432 1
a432 1
	}			/* if end of line */
d434 1
a434 1
    }				/* Loop over characters */
d436 1
a436 1
  end_html:
d449 15
a463 14
 *	==================================================
 *
 *   Accepts an open socket to a CSO server waiting to send us
 *   data and puts it on the screen in a reasonable manner.
 *
 *   Perhaps this data can be automatically linked to some
 *   other source as well???
 *
 *  Taken from hacking by Lou Montulli@@ukanaix.cc.ukans.edu
 *  on XMosaic-1.1, and put on libwww 2.11 by Arthur Secret,
 *  secret@@dxcern.cern.ch .
 */
static void parse_cso(const char *arg,
		      HTParentAnchor *anAnchor)
d468 2
a469 2
    char *second_colon, last_char = '\0';
    const char *title;
d494 17
a510 13
     * Start grabbing chars from the network.
     */
    while ((ich = NEXT_CHAR) != EOF) {
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;
	} else {
	    *p = '\0';		/* Terminate line */
	    p = line;		/* Scan it to parse it */
	    /*
	     * OK we now have a line in 'p'.  Lets parse it and print it.
	     */
d512 6
a517 5
	    /*
	     * Break on line that begins with a 2.  It's the end of data.
	     */
	    if (*p == '2')
		break;
d519 5
a523 31
	    /*
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
	    if (*p == '5') {
		START(HTML_H2);
		PUTS(p + 4);
		END(HTML_H2);
		break;
	    }

	    if (*p == '-') {
		/*
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 * Find the second colon and check the digit to the left of it
		 * to see if they are diferent.  If they are then a different
		 * person is starting.  Make this line an <h2>.
		 */

		/*
		 * Find the second_colon.
		 */
		second_colon = strchr(strchr(p, ':') + 1, ':');

		if (second_colon != NULL) {	/* error check */

		    if (*(second_colon - 1) != last_char)
			/* print seperator */
		    {
			END(HTML_PRE);
d525 3
d530 10
a539 14
		    /*
		     * Right now the record appears with the alias (first line)
		     * as the header and the rest as <pre> text.
		     *
		     * It might look better with the name as the header and the
		     * rest as a <ul> with <li> tags.  I'm not sure whether the
		     * name field comes in any special order or if its even
		     * required in a record, so for now the first line is the
		     * header no matter what it is (it's almost always the
		     * alias).
		     *
		     * A <dl> with the first line as the <DT> and the rest as
		     * some form of <DD> might good also?
		     */
d541 13
a553 5
		    /*
		     * Print data.
		     */
		    PUTS(second_colon + 1);
		    PUTC('\n');
a554 6
		    if (*(second_colon - 1) != last_char)
			/* end seperator */
		    {
			END(HTML_H2);
			START(HTML_PRE);
		    }
d556 27
a582 5
		    /*
		     * Save the char before the second colon for comparison on
		     * the next pass.
		     */
		    last_char = *(second_colon - 1);
d584 9
a592 3
		}		/* end if second_colon */
	    }			/* end if *p == '-' */
	}			/* if end of line */
d594 1
a594 1
    }				/* Loop over characters */
d602 2
a603 2
    return;			/* all done */
}				/* end of procedure */
d606 5
a610 4
 *	========================================
 */
static void display_cso(const char *arg,
			HTParentAnchor *anAnchor)
d612 1
a612 1
    const char *title;
d631 2
a632 2
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
d650 5
a654 4
 *	================================
 */
static void display_index(const char *arg,
			  HTParentAnchor *anAnchor)
d656 1
a656 1
    const char *title;
d676 2
a677 2
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
d692 5
a696 5
 *	====================================
 *
 *	The % hex escapes are converted. Otheriwse, the string is copied.
 */
static void de_escape(char *command, const char *selector)
d698 4
a701 5
    const char *p = selector;
    char *q = command;

    if (command == NULL)
	outofmem(__FILE__, "HTLoadGopher");
a705 1

d708 1
a708 1
	    b = from_hex(c);
d710 2
a711 3
	    if (!c)
		break;		/* Odd number of chars! */
	    *q++ = (char) FROMASCII((b << 4) + from_hex(c));
d716 1
a716 1
    *q++ = '\0';		/* Terminate command */
d719 1
d721 3
a723 3
 *	===================================
 */
static void free_CSOfields(void)
d744 8
a751 7
 *	=========================================
 */
static void interpret_cso_key(const char *key,
			      char *buf,
			      int *length,
			      CSOformgen_context * ctx,
			      HTStream *Target)
d757 2
a758 2
	 * Most substitutions only recognized inside of loops.
	 */
a759 1

d763 3
a765 1
	    sprintf(buf, "%.2046s", fld->description);
d791 1
a791 1
	case 0:
d793 2
a794 2
	     * 'Query' fields, public and lookup attributes.
	     */
d796 2
a797 2
		if (fld->gpublic && (fld->lookup == 1))
		    break;
d799 1
a799 1
	case 1:
d801 2
a802 2
	     * 'Query' fields, accept lookup attribute.
	     */
d807 1
a807 1
	case 2:
d809 2
a810 2
	     * 'Return' fields, public only.
	     */
d812 1
a812 1
		if (fld->gpublic)
d815 1
a815 1
	case 3:
d817 2
a818 2
	     * All fields.
	     */
d830 2
a831 2
	 * Begin iteration sequence.
	 */
d842 2
a843 2
	 * Special, locate name field.  Flag lookup so QFIELDS will skip it.
	 */
d852 3
a854 3
    } else if (0 == strncmp(key, "$(HOST)", 7)) {
	strcpy(buf, ctx->host);
    } else if (0 == strncmp(key, "$(PORT)", 7)) {
d858 2
a859 2
	 * No match, dump key to buffer so client sees it for debugging.
	 */
a860 1

d863 1
a863 1
	    if (out > sizeof(buf) - 2) {
d865 1
a865 1
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d879 4
a882 3
 *	=====================================================
 */
static int parse_cso_field_info(CSOfield_info *blk)
d887 2
a888 2
     * Initialize all fields to default values.
     */
d890 1
a890 1
    blk->defreturn = blk->explicit_return = blk->gpublic = 0;
d893 3
a895 3
     * Search for keywords in info string and set values.  Attributes are
     * converted to all lower-case for comparison.
     */
d903 1
a903 1
	blk->gpublic = 1;
d921 5
a925 4
 *	================================================
 */
static int parse_cso_fields(char *buf,
			    int size)
d932 1
a932 1
    CSOfield_info *last, *newf;
d939 2
a940 2
     * Start grabbing chars from the network.
     */
d943 1
a943 2
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d949 3
a951 3
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in buffer */
	    if (p < &buf[size - 1]) {
d962 3
a964 2
	     * Break on line that begins with a 2.  It's the end of data.
	     */
d969 3
a971 2
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
d973 1
a973 1
		strcpy(buf, p);
d979 4
a982 4
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 */
d984 5
a988 5
		/*
		 * Check status, ignore any non-success.
		 */
		if (p[1] != '2')
		    continue;
d990 16
a1005 18
		/*
		 * Parse fields within returned line into status, ndx, name,
		 * data.
		 */
		indx = NULL;
		name = NULL;
		for (i = 0; p[i]; i++) {
		    if (p[i] == ':') {
			p[i] = '\0';
			if (!indx) {
			    indx = (char *) &p[i + 1];
			    code = atoi(indx);
			} else if (!name) {
			    name = (char *) &p[i + 1];
			} else {
			    i++;
			    break;
			}
d1009 2
a1010 2
		 * Add data to field structure.
		 */
d1014 4
a1017 4
			 * Remaining data are description.  Save in current
			 * info block.
			 */
			alen = strlen((char *) &p[i]) + 1;
d1021 1
a1021 1
			    if (!(last->description = (char *) malloc(alen))) {
d1025 1
a1025 1
			strcpy(last->description, (char *) &p[i]);
d1028 5
a1032 6
			 * Initialize new block, append to end of list to
			 * preserve order.
			 */
			newf = typecalloc(CSOfield_info);

			if (!newf) {
d1036 1
a1036 1
			    last->next = newf;
d1038 2
a1039 2
			    CSOfields = newf;
			last = newf;
d1041 2
a1042 2
			newf->next = (CSOfield_info *) 0;
			newf->name = newf->name_buf;
d1044 2
a1045 2
			if (alen > sizeof(newf->name_buf)) {
			    if (!(newf->name = (char *) malloc(alen))) {
d1049 1
a1049 1
			strcpy(newf->name, name);
d1051 4
a1054 4
			newf->attributes = newf->attr_buf;
			alen = strlen((char *) &p[i]) + 2;
			if (alen > sizeof(newf->attr_buf)) {
			    if (!(newf->attributes = (char *) malloc(alen))) {
d1058 5
a1062 5
			strcpy(newf->attributes, (char *) &p[i]);
			strcpy((char *) &newf->attributes[alen - 2], " ");
			newf->description = newf->desc_buf;
			newf->desc_buf[0] = '\0';
			newf->id = atoi(indx);
d1064 3
a1066 3
			 * Scan for keywords.
			 */
			parse_cso_field_info(newf);
d1071 2
a1072 2
	    }			/* end if *p == '-' */
	}			/* if end of line */
d1074 1
a1074 1
    }				/* Loop over characters */
d1079 1
a1079 1
	return -1;		/* no response */
d1082 2
a1083 2
    return 0;			/* all done */
}				/* end of procedure */
d1086 7
a1092 6
 *	====================================================
 */
static int generate_cso_form(char *host,
			     int port,
			     char *buf,
			     HTStream *Target)
d1097 1
a1097 2
    const char *key;
    const char *line;
d1099 25
a1123 27
    static const char *ctemplate[] =
    {
	"<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
	"<H2><I>CSO/PH Query Form</I> for <EM>$(HOST)</EM></H2>",
	"To search the database for a name, fill in one or more of the fields",
	"in the form below and activate the 'Submit query' button.  At least",
	"one of the entered fields must be flagged as indexed.",
	"<HR><FORM method=\"POST\" action=\"cso://$(HOST)/\">",
	"[ <input type=\"submit\" value=\"Submit query\"> | ",
	"<input type=\"reset\" value=\"Clear fields\"> ]",
	"<P><DL>",
	"   <DT>Search parameters (* indicates indexed field):",
	"   <DD>",
	"$(NAMEFLD)    <DL COMPACT>\n    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD>Last: <input name=\"q_$(FID)\" type=\"text\" size=49$(FSIZE2)>",
	"    <DD>First: <input name=\"q_$(FID)\" type=\"text\" size=48$(FSIZE2)>",
	"$(QFIELDS)    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD><input name=\"q_$(FID)\" type=\"text\" $(FSIZE)>\n$(NEXTFLD)",
	"    </DL>",
	"   </DL>\n<P><DL>",
	"   <DT>Output format:",
	"   <DD>Returned data option: <select name=\"return\">",
	"    <option>default<option selected>all<option>selected</select><BR>",
	"$(RFIELDS)    <input type=\"checkbox\" name=\"r_$(FID)\"$(FDEF)> $(FDESC)<BR>",
	"$(NEXTFLD)    ",
	"   </DL></FORM><HR>\n</BODY>\n</HTML>",
	(char *) 0
d1133 3
a1135 3
     * Parse the strings in the template array to produce HTML document to send
     * to client.  First line is skipped for 'full' lists.
     */
d1138 1
a1138 3
    for (i = full_flag ? /***1***/ 0 : 0;
	 ctemplate[i];
	 i++) {
d1140 4
a1143 4
	 * Search the current string for substitution, flagged by $(
	 */
	for (line = ctemplate[i], j = 0; line[j]; j++) {
	    if ((line[j] == '$') && (line[j + 1] == '(')) {
d1145 3
a1147 3
		 * Command detected, flush output buffer and find closing ')'
		 * that delimits the command.
		 */
d1150 1
a1150 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1152 2
a1153 1
		for (key = &line[j]; line[j + 1] && (line[j] != ')'); j++) ;
d1155 2
a1156 2
		 * Save context, interpet command and restore updated context.
		 */
d1162 1
a1162 1
		line = ctemplate[i];
d1167 3
a1169 3
		     * Command wants us to skip (forward) to indicated token. 
		     * Start at current position.
		     */
d1171 2
a1172 3

		    for (; ctemplate[i]; i++) {
			for (line = ctemplate[i]; line[j]; j++) {
d1176 1
a1176 1
					j = strlen(ctemplate[--i]) - 1;
d1179 1
a1179 1
				    line = ctemplate[i];
a1189 1

d1191 1
a1191 1
			(*Target->isa->put_block) (Target, temp, strlen(temp));
d1197 2
a1198 2
		 * Non-command text, add to output buffer.
		 */
d1200 1
a1200 1
		if (out > (sizeof(buf) - 3)) {
d1202 1
a1202 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1211 1
a1211 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1217 4
a1220 3
 *	==============================================================
 */
static int generate_cso_report(HTStream *Target)
d1232 2
a1233 2
     * Read lines until non-negative status.
     */
d1236 2
a1237 2
     * Start grabbing chars from the network.
     */
d1240 2
a1241 3
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
d1245 3
a1247 3
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
d1253 3
a1255 2
	     * OK we now have a line.  Load it as 'p' and parse it.
	     */
d1267 1
a1267 1
			fname = ndx_str = &p[i + 1];
d1269 1
a1269 1
			fname = &p[i + 1];
d1279 1
a1279 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1283 2
a1284 2
				   "<HR><DL><DT>Information/status<DD><DL><DT>\n");
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1287 2
a1288 2
				   "<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n", ndx);
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1294 1
a1294 1
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d1306 1
a1306 1
			    fname[i--] = '\0';	/* trim trailing */
d1327 3
a1329 3
				   "<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",
				   fname, fvalue, fvalue);
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1332 1
a1332 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1342 1
a1342 1
			    } else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1355 1
a1355 2
				       strncmp(l, STR_MAILTO_URL,
					       LEN_MAILTO_URL) &&
d1372 1
a1372 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1376 1
a1376 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1386 1
a1386 1
			} else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1399 1
a1399 1
				   strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1416 1
a1416 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1419 2
a1420 2
		HTSprintf0(&buf, "<DD>%s\n", fname ? fname : rcode);
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d1424 1
a1424 1
  end_CSOreport:
d1427 1
a1427 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1434 7
a1440 6
 *	=====================================
 */
static int HTLoadCSO(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
d1442 2
a1443 2
    static const char end_form[] = "</BODY>\n</HTML>\n";
    char *host, *cp, *data;
d1445 3
a1447 3
    int status;			/* tcp return */
    bstring *command = NULL;
    bstring *content = NULL;
d1456 1
a1456 1
	init_acceptable();
d1459 1
a1459 1
	return -3;		/* Bad if no name sepcified     */
d1461 2
a1462 2
	return -2;		/* Bad if name had zero length  */
    CTRACE((tfp, "HTLoadCSO: Looking for %s\n", arg));
d1465 3
a1467 3
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "cso", CSO_PORT, &s);
d1470 4
a1473 5
	 * Interrupt cleanly.
	 */
	CTRACE((tfp,
		"HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
d1477 2
a1478 2
	CTRACE((tfp, "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
		arg));
d1484 6
a1489 9
    HTBprintf(&command, "fields%c%c", CR, LF);
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Connected, writing command `"));
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
    _HTProgress(GOPHER_SENDING_CSO_REQUEST);
    status = NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
d1491 1
a1491 1
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
d1494 1
a1494 1
    _HTProgress(GOPHER_SENT_CSO_REQUEST);
d1497 2
a1498 2
     * Now read the data from the socket.
     */
d1503 1
a1503 1
	    _HTProgress(CONNECTION_INTERRUPTED);
a1515 1

d1524 1
a1524 1
    if ((cp = strchr(host, ':')) != NULL) {
d1526 1
a1526 1
	    port = atoi((cp + 1));
d1533 1
a1533 1
    if (isBEmpty(anAnchor->post_data)) {
d1535 1
a1535 1
	(*Target->isa->_free) (Target);
d1542 5
a1546 5
    HTBprintf(&command,
	      "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n",
	      host);
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
    BStrFree(command);
d1549 4
a1552 7
    BStrCopy(content, anAnchor->post_data);

    if (BStrData(content)[BStrLen(content) - 1] != '&')
	BStrCat0(content, "&");

    data = BStrData(content);
    len = BStrLen(content);
d1554 2
a1555 2
	if (data[i] == '+') {
	    data[i] = ' ';
d1558 2
a1559 5

    data = BStrData(content);
    HTUnEscape(data);		/* FIXME: could it have embedded null? */
    len = BStrLen(content);

d1564 1
a1564 1
	if (!data[i] || data[i] == '&') {
d1566 3
a1568 3
	     * Value parsed.  Unescape characters and look for first '=' to
	     * delimit field name from value.
	     */
d1571 1
a1571 1
	    data[finish] = '\0';
d1573 1
a1573 1
		if (data[j] == '=') {
d1575 5
a1579 5
		     * data[start..j-1] is field name,
		     * [j+1..finish-1] is value.
		     */
		    if ((data[start + 1] == '_') &&
			((data[start] == 'r') || (data[start] == 'q'))) {
d1581 3
a1583 3
			 * Decode fields number and lookup field info.
			 */
			sscanf(&data[start + 2], "%d=", &ndx);
d1585 2
a1586 2
			    if (ndx == fld->id) {
				if ((j + 1) >= finish)
d1588 1
a1588 1
				if (data[start] == 'q') {
d1595 2
a1596 2
					if (isBEmpty(command)) {
					    BStrCopy0(command, "query ");
d1598 1
a1598 1
					    BStrCat0(command, " ");
d1600 2
a1601 2
					HTBprintf(&command, "%s=\"%s\"",
						  fld->name, &data[j + 1]);
d1604 4
a1607 4
					       "Warning: non-lookup field ignored<BR>\n");
					(*Target->isa->put_block) (Target,
								   buf,
								   strlen(buf));
d1609 1
a1609 1
				} else if (data[start] == 'r') {
d1615 2
a1616 2
		    } else if (!strncmp(&data[start], "return=", 7)) {
			if (!strcmp(&data[start + 7], "all")) {
d1618 1
a1618 1
			} else if (!strcmp(&data[start + 7], "selected")) {
d1627 2
a1628 2
    BStrFree(content);
    if (isBEmpty(command) || !has_indexed) {
d1631 2
a1632 2
	       "<EM>Error:</EM> At least one indexed field value must be specified!\n");
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1634 2
a1635 2
	(*Target->isa->put_block) (Target, buf, strlen(buf));
	(*Target->isa->_free) (Target);
d1640 2
a1641 2
     * Append return fields.
     */
d1643 1
a1643 1
	BStrCat0(command, " return all");
d1645 1
a1645 1
	BStrCat0(command, " return");
d1648 1
a1648 1
		HTBprintf(&command, " %s", fld->name);
d1652 1
a1652 1
    HTBprintf(&command, "%c%c", CR, LF);
d1654 2
a1655 2
    (*Target->isa->put_block) (Target, buf, strlen(buf));
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
d1657 5
a1661 8
    (*Target->isa->put_block) (Target, buf, strlen(buf));
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Writing command `"));
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
    status = NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
d1663 1
a1663 1
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
d1669 2
a1670 2
    (*Target->isa->put_block) (Target, end_form, sizeof(end_form) - 1);
    (*Target->isa->_free) (Target);
d1677 10
a1686 9
 *	=============
 *
 *  Bug:  No decoding of strange data types as yet.
 *
 */
static int HTLoadGopher(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
d1688 4
a1691 4
    char *command;		/* The whole command */
    int status;			/* tcp return */
    char gtype;			/* Gopher Node type */
    char *selector;		/* Selector string */
d1694 1
a1694 1
	init_acceptable();
d1697 1
a1697 1
	return -3;		/* Bad if no name sepcified     */
d1699 2
a1700 2
	return -2;		/* Bad if name had zero length  */
    CTRACE((tfp, "HTGopher: Looking for %s\n", arg));
d1703 4
a1706 4
     * If it's a port 105 GOPHER_CSO gtype with no ISINDEX token ('?'), use the
     * form-based CSO gateway (otherwise, return an ISINDEX cover page or do
     * the ISINDEX search).  - FM
     */
d1711 1
a1711 1
	    if (0 == strcmp((const char *) &arg[len - 6], ":105/2")) {
d1713 1
a1713 1
		CTRACE((tfp, "HTGopher: Passing to CSO/PH gateway.\n"));
d1720 2
a1721 2
     * If it's a port 79/0[/...] URL, use the finger gateway.  - FM
     */
d1724 1
a1724 1
	CTRACE((tfp, "HTGopher: Passing to finger gateway.\n"));
d1727 1
a1727 1
	HTAlert(COULD_NOT_ACCESS_DOCUMENT);
d1733 2
a1734 2
     * Get entity type, and selector string.
     */
d1736 1
a1736 2
	char *p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);

d1739 2
a1740 2
	if ((*selector++ == '/') && (*selector)) {	/* Skip first slash */
	    gtype = *selector++;	/* Pick up gtype */
d1743 1
a1743 2
	    char *query;

d1745 2
a1746 2
	     * Search is allowed.
	     */
d1749 1
a1749 1
	    if (!query || !query[1]) {	/* No search required */
d1753 1
a1753 1
		return HT_LOADED;	/* Local function only */
d1755 1
a1755 1
	    *query++ = '\0';	/* Skip '?'     */
d1757 3
a1759 3
		(char *) malloc(strlen(selector) + 1 + strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");
d1765 1
a1765 1
	    {			/* Remove plus signs 921006 */
d1767 2
a1768 4

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
d1772 1
a1772 1
	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */
d1774 1
a1774 2
	    char *query;

d1776 2
a1777 2
	     * Search is allowed.
	     */
d1779 1
a1779 1
	    if (!query || !query[1]) {	/* No search required */
d1783 1
a1783 1
		return HT_LOADED;	/* Local function only */
d1786 4
a1789 5
	    *query++ = '\0';	/* Skip '?'     */
	    command = (char *) malloc(strlen("query") + 1 +
				      strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");
d1795 1
a1795 1
	    {			/* Remove plus signs 921006 */
d1797 2
a1798 4

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
d1801 1
a1801 1
	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */
d1803 2
a1804 2
	} else {		/* Not index */
	    command = (char *) malloc(strlen(selector) + 2 + 1);
d1813 1
a1813 2
	char *p = command + strlen(command);

d1820 3
a1822 3
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "gopher", GOPHER_PORT, &s);
d1825 4
a1828 4
	 * Interrupt cleanly.
	 */
	CTRACE((tfp, "HTGopher: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
d1833 2
a1834 2
	CTRACE((tfp, "HTGopher: Unable to connect to remote host for `%s'.\n",
		arg));
d1841 2
a1842 2
    CTRACE((tfp, "HTGopher: Connected, writing command `%s' to socket %d\n",
	    command, s));
d1846 1
a1846 2
	char *p;

d1853 1
a1853 1
    _HTProgress(GOPHER_SENDING_REQUEST);
d1855 1
a1855 1
    status = NETWRITE(s, command, (int) strlen(command));
d1858 1
a1858 1
	CTRACE((tfp, "HTGopher: Unable to send command.\n"));
d1862 1
a1862 1
    _HTProgress(GOPHER_SENT_REQUEST);
d1865 2
a1866 2
     * Now read the data from the socket.
     */
d1869 1
a1869 1
    case GOPHER_TEXT:
d1873 2
a1874 2
    case GOPHER_HTML:
    case GOPHER_CHTML:
d1882 1
a1882 1
		      format_out, anAnchor, s, sink);
d1885 2
a1886 2
    case GOPHER_MENU:
    case GOPHER_INDEX:
d1898 2
a1899 2
    case GOPHER_SOUND:
    case GOPHER_PLUS_SOUND:
d1909 1
a1909 1
		      s, sink);
d1918 3
a1920 3
	 * Specifying WWW_UNKNOWN forces dump to local disk.
	 */
	HTParseSocket(WWW_UNKNOWN, format_out, anAnchor, s, sink);
d1923 1
a1923 1
    }				/* switch(gtype) */
d1931 1
a1931 1
GLOBALDEF(HTProtocol, HTGopher, _HTGOPHER_C_1_INIT);
d1933 1
a1933 1
GLOBALDEF(HTProtocol, HTCSO, _HTCSO_C_1_INIT);
d1935 2
a1936 4
GLOBALDEF HTProtocol HTGopher =
{"gopher", HTLoadGopher, NULL};
GLOBALDEF HTProtocol HTCSO =
{"cso", HTLoadCSO, NULL};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d161 1
a161 1
    return (char) (       (c>='0')&&(c<='9') ? c-'0'
d164 1
a164 1
			:		       0);
d194 1
a194 1
    CTRACE((tfp,"HTGopher: adding URL: %s\n",addr));
d254 1
a254 1
	    CTRACE((tfp, "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
d259 1
a259 1
	    *p = (char) ich;    /* Put character in line */
d267 1
a267 1
	    CTRACE((tfp, "HTGopher: Menu item: %s\n", line));
a329 1
		char *format = *selector ? "%s//%s@@%s/" : "%s//%s/";
d333 5
a337 1
		    HTSprintf0(&address, format, STR_TELNET_URL, selector, host);
d342 5
a346 1
		    HTSprintf0(&address, format, STR_TN3270_URL, selector, host);
d406 1
a406 1
			if (acceptable[UCH(*r)]) {
d424 1
a424 1
		CTRACE((tfp, "HTGopher: Bad menu item.\n"));
d500 1
a500 1
		    *p = (char) ich;    /* Put character in line */
d711 1
a711 1
	    *q++ = (char) FROMASCII((b<<4) + from_hex(c));
d763 3
a765 1
	    sprintf(buf, "%.2046s", fld->description);
d943 1
a943 1
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d950 1
a950 1
	    *p = (char) ich;    /* Put character in buffer */
d984 5
a988 5
		/*
		** Check status, ignore any non-success.
		*/
		if (p[1] != '2' )
		    continue;
d990 16
a1005 18
		/*
		** Parse fields within returned line into status, ndx, name,
		** data.
		*/
		indx = NULL;
		name = NULL;
		for (i = 0; p[i]; i++) {
		    if (p[i] == ':' ) {
			p[i] = '\0';
			if (!indx) {
			    indx = (char *)&p[i+1];
			    code = atoi (indx);
			} else if (!name) {
			    name = (char *)&p[i+1];
			} else {
			    i++;
			    break;
			}
d1031 1
a1031 1
			new = typecalloc(CSOfield_info);
d1100 1
a1100 1
   "<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
d1240 1
a1240 1
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d1246 1
a1246 1
	    *p = (char) ich;    /* Put character in line */
d1342 1
a1342 1
			    } else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1355 1
a1355 1
				       strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1386 1
a1386 1
			} else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1399 1
a1399 1
				   strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1443 1
a1443 1
    char *host, *cp, *data;
d1446 2
a1447 2
    bstring *command = NULL;
    bstring *content = NULL;
d1462 1
a1462 1
    CTRACE((tfp, "HTLoadCSO: Looking for %s\n", arg));
d1472 1
a1472 1
	CTRACE((tfp, "HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
d1477 2
a1478 2
	CTRACE((tfp, "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
		    arg));
d1484 3
a1486 6
    HTBprintf(&command, "fields%c%c", CR, LF);
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Connected, writing command `"));
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
d1488 2
a1489 2
    status = NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
d1491 1
a1491 1
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
d1524 1
a1524 1
    if ((cp = strchr(host, ':')) != NULL) {
d1533 1
a1533 1
    if (isBEmpty(anAnchor->post_data)) {
d1542 1
a1542 1
    HTBprintf(&command,
d1545 2
a1546 2
    (*Target->isa->put_block)(Target, BStrData(command), BStrLen(command));
    BStrFree(command);
d1549 4
a1552 7
    BStrCopy(content, anAnchor->post_data);

    if (BStrData(content)[BStrLen(content)-1] != '&')
	BStrCat0(content, "&");

    data = BStrData(content);
    len = BStrLen(content);
d1554 2
a1555 2
	if (data[i] == '+') {
	    data[i] = ' ';
d1558 2
a1559 5

    data = BStrData(content);
    HTUnEscape(data);		/* FIXME: could it have embedded null? */
    len = BStrLen(content);

d1564 1
a1564 1
	if (!data[i] || data[i] == '&') {
d1571 1
a1571 1
	    data[finish] = '\0';
d1573 1
a1573 1
		if (data[j] == '=') {
d1575 1
a1575 1
		    **	data[start..j-1] is field name,
d1578 2
a1579 2
		    if ((data[start+1] == '_') &&
			((data[start] == 'r') || (data[start] == 'q'))) {
d1583 1
a1583 1
			sscanf (&data[start+2], "%d=", &ndx);
d1588 1
a1588 1
				if (data[start] == 'q') {
d1595 2
a1596 2
					if (isBEmpty(command)) {
					    BStrCopy0(command, "query ");
d1598 1
a1598 1
					    BStrCat0(command, " ");
d1600 2
a1601 2
					HTBprintf(&command, "%s=\"%s\"",
						  fld->name, &data[j+1]);
d1609 1
a1609 1
				} else if (data[start] == 'r') {
d1615 2
a1616 2
		    } else if (!strncmp(&data[start], "return=", 7)) {
			if (!strcmp(&data[start+7], "all")) {
d1618 1
a1618 1
			} else if (!strcmp(&data[start+7], "selected")) {
d1627 2
a1628 2
    BStrFree(content);
    if (isBEmpty(command) || !has_indexed) {
d1643 1
a1643 1
	BStrCat0(command, " return all");
d1645 1
a1645 1
	BStrCat0(command, " return");
d1648 1
a1648 1
		HTBprintf(&command, " %s", fld->name);
d1652 1
a1652 1
    HTBprintf(&command, "%c%c", CR, LF);
d1655 1
a1655 1
    (*Target->isa->put_block)(Target, BStrData(command), BStrLen(command));
d1658 4
a1661 7
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Writing command `"));  
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
    status = NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
d1663 1
a1663 1
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
d1700 1
a1700 1
    CTRACE((tfp, "HTGopher: Looking for %s\n", arg));
d1713 1
a1713 1
		CTRACE((tfp, "HTGopher: Passing to CSO/PH gateway.\n"));
d1724 1
a1724 1
	CTRACE((tfp, "HTGopher: Passing to finger gateway.\n"));
d1727 1
a1727 1
	HTAlert(COULD_NOT_ACCESS_DOCUMENT);
d1827 1
a1827 1
	CTRACE((tfp, "HTGopher: Interrupted on connect; recovering cleanly.\n"));
d1833 2
a1834 2
	CTRACE((tfp, "HTGopher: Unable to connect to remote host for `%s'.\n",
		    arg));
d1841 2
a1842 2
    CTRACE((tfp, "HTGopher: Connected, writing command `%s' to socket %d\n",
		command, s));
d1858 1
a1858 1
	CTRACE((tfp, "HTGopher: Unable to send command.\n"));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d87 1
a87 1
static int s;				/* Socket for gopher or CSO host */
d90 1
a90 1
	const HTStructuredClass * isa;	/* For gopher streams */
d94 2
a95 2
static HTStructured *target;		/* the new gopher hypertext */
static HTStructuredClass targetClass;	/* Its action routines */
d121 1
a121 1
static CSOfield_info *CSOfields = NULL; /* For form-based CSO gateway - FM */
d139 2
a140 2
static BOOL acceptable[256];
static BOOL acceptable_inited = NO;
d142 1
a142 1
static void init_acceptable (void)
d157 1
a157 1
static const char hex[17] = "0123456789abcdef";
d159 1
a159 1
static char from_hex (char  c)
d178 1
a178 1
BOOLEAN HT_Is_Gopher_URL=FALSE;
d180 1
a180 1
static void write_anchor (const char * text, const char * addr)
d183 1
a183 1
    const char * value[HTML_A_ATTRIBUTES];
d190 1
a190 1
    ((const char **)value)[HTML_A_HREF] = addr;
d192 1
a192 1
    ((const char **)value)[HTML_A_TITLE] = text;
d198 1
a198 1
				 (const char **)value, -1, 0);
d207 3
a209 3
static void parse_menu (
	const char *		arg GCC_UNUSED,
	HTParentAnchor *	anAnchor)
d218 1
a218 1
    const char *title;
d454 3
a456 3
static void parse_cso (
	const char *		arg,
	HTParentAnchor *	anAnchor)
d462 1
a462 1
    const char *title;
d601 3
a603 3
static void display_cso (
	const char *		arg,
	HTParentAnchor *	anAnchor)
d605 1
a605 1
    const char * title;
d645 3
a647 3
static void display_index (
				  const char * arg,
				  HTParentAnchor *anAnchor)
d649 1
a649 1
    const char * title;
d689 1
a689 1
static void de_escape (char * command, const char * selector)
d691 1
a691 1
    const char * p = selector;
d716 1
a716 1
static void free_CSOfields (void)
d739 6
a744 6
static void interpret_cso_key (
	char *			key,
	char *			buf,
	int *			length,
	CSOformgen_context *	ctx,
	HTStream *		Target)
d872 2
a873 2
static int parse_cso_field_info (
	CSOfield_info *	blk)
d914 3
a916 3
static int parse_cso_fields (
	char *		buf,
	int		size)
d1081 5
a1085 5
static int generate_cso_form (
	char *		host,
	int		port,
	char *		buf,
	HTStream *	Target)
d1212 2
a1213 2
static int generate_cso_report (
	HTStream *	Target)
d1429 5
a1433 5
static int HTLoadCSO (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1435 1
a1435 1
    static const char end_form[] = "</BODY>\n</HTML>\n";
d1687 5
a1691 5
static int HTLoadGopher (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1716 1
a1716 1
	    if (0 == strcmp((const char *)&arg[len-6], ":105/2")) {
d1940 2
a1941 2
GLOBALDEF HTProtocol HTGopher = { "gopher", HTLoadGopher, NULL };
GLOBALDEF HTProtocol HTCSO = { "cso", HTLoadCSO, NULL };
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 15
a16 15
 *			=============
 *
 *  History:
 *	26 Sep 90	Adapted from other accesses (News, HTTP) TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 *	10 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Added a
 *			  form-based CSO/PH gateway.  Can be invoked via a
 *			  "cso://host[:port]/" or "gopher://host:105/2"
 *			  URL.	If a gopher URL is used with a query token
 *			  ('?'), the old ISINDEX procedure will be used
 *			  instead of the form-based gateway.
 *	15 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Pass
 *			  port 79, gtype 0 gopher URLs to the finger
 *			  gateway.
 */
d27 2
a28 2
 *  Implements.
 */
d37 2
a38 2
 *  Gopher entity types.
 */
d50 2
a51 2
#define GOPHER_HTML		'h'	/* HTML */
#define GOPHER_CHTML		'H'	/* HTML */
d53 1
a53 1
#define GOPHER_WWW		'w'	/* W3 address */
d58 1
a58 1
#define GOPHER_PLUS_IMAGE	':'	/* Addition from Gopher Plus */
d66 2
a67 2
 *  Hypertext object building machinery.
 */
d85 3
a87 3
 *  Module-wide variables.
 */
static int s;			/* Socket for gopher or CSO host */
d90 2
a91 2
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
d94 1
a94 1
static HTStructured *target;	/* the new gopher hypertext */
d97 3
a99 2
struct _HTStream {
    HTStreamClass *isa;		/* For form-based CSO  gateway - FM */
d102 17
a118 17
typedef struct _CSOfield_info {	/* For form-based CSO gateway - FM */
    struct _CSOfield_info *next;
    char *name;
    char *attributes;
    char *description;
    int id;
    int lookup;
    int indexed;
    int url;
    int max_size;
    int defreturn;
    int explicit_return;
    int reserved;
    int public;
    char name_buf[16];		/* Avoid malloc if we can */
    char desc_buf[32];		/* Avoid malloc if we can */
    char attr_buf[80];		/* Avoid malloc if we can */
d121 1
a121 1
static CSOfield_info *CSOfields = NULL;		/* For form-based CSO gateway - FM */
d123 11
a133 11
typedef struct _CSOformgen_context {	/* For form-based CSO gateway - FM */
    char *host;
    char *seek;
    CSOfield_info *fld;
    int port;
    int cur_line;
    int cur_off;
    int rep_line;
    int rep_off;
    int public_override;
    int field_select;
d137 2
a138 2
 *	=========================================
 */
d142 1
a142 1
static void init_acceptable(void)
d145 3
a147 4
    char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
d149 2
a150 2
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
d155 2
a156 2
 *	========================
 */
d159 1
a159 1
static char from_hex(char c)
d161 4
a164 4
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
d168 11
a178 11
 *	==================
 *
 *	The title of the destination is set, as there is no way
 *	of knowing what the title is when we arrive.
 *
 * On entry,
 *	HT	is in append mode.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext refernce address 0 terminated.
 */
BOOLEAN HT_Is_Gopher_URL = FALSE;
d180 1
a180 1
static void write_anchor(const char *text, const char *addr)
d183 1
a183 1
    const char *value[HTML_A_ATTRIBUTES];
d190 1
a190 1
    ((const char **) value)[HTML_A_HREF] = addr;
d192 1
a192 1
    ((const char **) value)[HTML_A_TITLE] = text;
d194 1
a194 1
    CTRACE((tfp, "HTGopher: adding URL: %s\n", addr));
d196 3
a198 3
    HT_Is_Gopher_URL = TRUE;	/* tell HTML.c that this is a Gopher URL */
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);
d205 5
a209 4
 *	============================
 */
static void parse_menu(const char *arg GCC_UNUSED,
		       HTParentAnchor *anAnchor)
d226 1
d251 1
a251 1
    while ((ich = NEXT_CHAR) != EOF) {
d254 1
a254 2
	    CTRACE((tfp,
		    "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
d258 3
a260 4
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;
d264 1
a264 1
	    bytes += p - line;	/* add size */
d277 1
a277 1
	    if ((gtype == '.') && ((*p == '\r') || (*p == 0)))
d284 1
a284 1
		    *selector++ = '\0';		/* Terminate name */
d296 1
a296 1
			*host++ = '\0';		/* Terminate selector */
a299 1

d302 8
a309 9
			    if (junk)
				*junk++ = '\0';		/* Chop port */
			    if ((port[1] == '0') && (!port[2]))
				port[0] = '\0';		/* 0 means none */
			}	/* no port */
		    }		/* host ok */
		}		/* selector ok */
	    }
	    /* gtype and name ok */
d312 1
a312 2
		int i = strlen(name) - 1;

d324 1
a324 1
		/* Information or separator line */
d328 1
a328 1
	    } else if (port) {	/* Other types need port */
d335 3
a337 1
		} else if (gtype == GOPHER_TN3270) {
d340 2
a341 1
		} else {	/* If parsed ok */
d344 50
a393 50
		    switch (gtype) {
		    case GOPHER_TEXT:
			PUTS("(FILE) ");
			break;
		    case GOPHER_MENU:
			PUTS(" (DIR) ");
			break;
		    case GOPHER_CSO:
			PUTS(" (CSO) ");
			break;
		    case GOPHER_PCBINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_UUENCODED:
			PUTS(" (UUE) ");
			break;
		    case GOPHER_INDEX:
			PUTS("  (?)  ");
			break;
		    case GOPHER_BINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_GIF:
		    case GOPHER_IMAGE:
		    case GOPHER_PLUS_IMAGE:
			PUTS(" (IMG) ");
			break;
		    case GOPHER_SOUND:
		    case GOPHER_PLUS_SOUND:
			PUTS(" (SND) ");
			break;
		    case GOPHER_MACBINHEX:
			PUTS(" (HQX) ");
			break;
		    case GOPHER_HTML:
		    case GOPHER_CHTML:
			PUTS("(HTML) ");
			break;
		    case 'm':
			PUTS("(MIME) ");
			break;
		    case GOPHER_PLUS_MOVIE:
			PUTS(" (MOV) ");
			break;
		    case GOPHER_PLUS_PDF:
			PUTS(" (PDF) ");
			break;
		    default:
			PUTS("(UNKN) ");
			break;
d398 1
a398 1
		    for (r = selector; *r; r++) {	/* Encode selector string */
d403 3
a405 3
				      HEX_ESCAPE,	/* Means hex coming */
				      hex[(TOASCII(*r)) >> 4],
				      hex[(TOASCII(*r)) & 15]);
d411 1
a411 1
		if (strcmp(address, "gopher://error.host:1/0"))
d416 1
a416 1
	    } else {		/* parse error */
d420 1
a420 1
	    }			/* parse error */
d423 1
a423 1
	    p = line;		/* Start again at beginning of line */
d425 1
a425 1
	}			/* if end of line */
d427 1
a427 1
    }				/* Loop over characters */
d429 1
a429 1
  end_html:
d442 15
a456 14
 *	==================================================
 *
 *   Accepts an open socket to a CSO server waiting to send us
 *   data and puts it on the screen in a reasonable manner.
 *
 *   Perhaps this data can be automatically linked to some
 *   other source as well???
 *
 *  Taken from hacking by Lou Montulli@@ukanaix.cc.ukans.edu
 *  on XMosaic-1.1, and put on libwww 2.11 by Arthur Secret,
 *  secret@@dxcern.cern.ch .
 */
static void parse_cso(const char *arg,
		      HTParentAnchor *anAnchor)
d461 1
a461 1
    char *second_colon, last_char = '\0';
d487 17
a503 13
     * Start grabbing chars from the network.
     */
    while ((ich = NEXT_CHAR) != EOF) {
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;
	} else {
	    *p = '\0';		/* Terminate line */
	    p = line;		/* Scan it to parse it */
	    /*
	     * OK we now have a line in 'p'.  Lets parse it and print it.
	     */
d505 6
a510 5
	    /*
	     * Break on line that begins with a 2.  It's the end of data.
	     */
	    if (*p == '2')
		break;
d512 5
a516 31
	    /*
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
	    if (*p == '5') {
		START(HTML_H2);
		PUTS(p + 4);
		END(HTML_H2);
		break;
	    }

	    if (*p == '-') {
		/*
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 * Find the second colon and check the digit to the left of it
		 * to see if they are diferent.  If they are then a different
		 * person is starting.  Make this line an <h2>.
		 */

		/*
		 * Find the second_colon.
		 */
		second_colon = strchr(strchr(p, ':') + 1, ':');

		if (second_colon != NULL) {	/* error check */

		    if (*(second_colon - 1) != last_char)
			/* print seperator */
		    {
			END(HTML_PRE);
d518 3
d523 10
a532 14
		    /*
		     * Right now the record appears with the alias (first line)
		     * as the header and the rest as <pre> text.
		     *
		     * It might look better with the name as the header and the
		     * rest as a <ul> with <li> tags.  I'm not sure whether the
		     * name field comes in any special order or if its even
		     * required in a record, so for now the first line is the
		     * header no matter what it is (it's almost always the
		     * alias).
		     *
		     * A <dl> with the first line as the <DT> and the rest as
		     * some form of <DD> might good also?
		     */
d534 13
a546 5
		    /*
		     * Print data.
		     */
		    PUTS(second_colon + 1);
		    PUTC('\n');
a547 6
		    if (*(second_colon - 1) != last_char)
			/* end seperator */
		    {
			END(HTML_H2);
			START(HTML_PRE);
		    }
d549 27
a575 5
		    /*
		     * Save the char before the second colon for comparison on
		     * the next pass.
		     */
		    last_char = *(second_colon - 1);
d577 9
a585 3
		}		/* end if second_colon */
	    }			/* end if *p == '-' */
	}			/* if end of line */
d587 1
a587 1
    }				/* Loop over characters */
d595 2
a596 2
    return;			/* all done */
}				/* end of procedure */
d599 5
a603 4
 *	========================================
 */
static void display_cso(const char *arg,
			HTParentAnchor *anAnchor)
d605 1
a605 1
    const char *title;
d624 2
a625 2
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
d643 5
a647 4
 *	================================
 */
static void display_index(const char *arg,
			  HTParentAnchor *anAnchor)
d649 1
a649 1
    const char *title;
d669 2
a670 2
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
d685 5
a689 5
 *	====================================
 *
 *	The % hex escapes are converted. Otheriwse, the string is copied.
 */
static void de_escape(char *command, const char *selector)
d691 4
a694 5
    const char *p = selector;
    char *q = command;

    if (command == NULL)
	outofmem(__FILE__, "HTLoadGopher");
a698 1

d701 1
a701 1
	    b = from_hex(c);
d703 2
a704 3
	    if (!c)
		break;		/* Odd number of chars! */
	    *q++ = (char) FROMASCII((b << 4) + from_hex(c));
d709 1
a709 1
    *q++ = '\0';		/* Terminate command */
d712 1
d714 3
a716 3
 *	===================================
 */
static void free_CSOfields(void)
d737 8
a744 7
 *	=========================================
 */
static void interpret_cso_key(char *key,
			      char *buf,
			      int *length,
			      CSOformgen_context * ctx,
			      HTStream *Target)
d750 2
a751 2
	 * Most substitutions only recognized inside of loops.
	 */
a752 1

d782 1
a782 1
	case 0:
d784 2
a785 2
	     * 'Query' fields, public and lookup attributes.
	     */
d787 2
a788 2
		if (fld->public && (fld->lookup == 1))
		    break;
d790 1
a790 1
	case 1:
d792 2
a793 2
	     * 'Query' fields, accept lookup attribute.
	     */
d798 1
a798 1
	case 2:
d800 2
a801 2
	     * 'Return' fields, public only.
	     */
d806 1
a806 1
	case 3:
d808 2
a809 2
	     * All fields.
	     */
d821 2
a822 2
	 * Begin iteration sequence.
	 */
d833 2
a834 2
	 * Special, locate name field.  Flag lookup so QFIELDS will skip it.
	 */
d843 3
a845 3
    } else if (0 == strncmp(key, "$(HOST)", 7)) {
	strcpy(buf, ctx->host);
    } else if (0 == strncmp(key, "$(PORT)", 7)) {
d849 2
a850 2
	 * No match, dump key to buffer so client sees it for debugging.
	 */
a851 1

d854 1
a854 1
	    if (out > sizeof(buf) - 2) {
d856 1
a856 1
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d870 4
a873 3
 *	=====================================================
 */
static int parse_cso_field_info(CSOfield_info *blk)
d878 2
a879 2
     * Initialize all fields to default values.
     */
d884 3
a886 3
     * Search for keywords in info string and set values.  Attributes are
     * converted to all lower-case for comparison.
     */
d912 5
a916 4
 *	================================================
 */
static int parse_cso_fields(char *buf,
			    int size)
d930 2
a931 2
     * Start grabbing chars from the network.
     */
d934 1
a934 2
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d940 3
a942 3
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in buffer */
	    if (p < &buf[size - 1]) {
d953 3
a955 2
	     * Break on line that begins with a 2.  It's the end of data.
	     */
d960 3
a962 2
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
d964 1
a964 1
		strcpy(buf, p);
d970 4
a973 4
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 */
d976 3
a978 3
		 * Check status, ignore any non-success.
		 */
		if (p[1] != '2')
d982 3
a984 3
		 * Parse fields within returned line into status, ndx, name,
		 * data.
		 */
d988 1
a988 1
		    if (p[i] == ':') {
d991 2
a992 2
			    indx = (char *) &p[i + 1];
			    code = atoi(indx);
d994 1
a994 1
			    name = (char *) &p[i + 1];
d1002 2
a1003 2
		 * Add data to field structure.
		 */
d1007 4
a1010 4
			 * Remaining data are description.  Save in current
			 * info block.
			 */
			alen = strlen((char *) &p[i]) + 1;
d1014 1
a1014 1
			    if (!(last->description = (char *) malloc(alen))) {
d1018 1
a1018 1
			strcpy(last->description, (char *) &p[i]);
d1021 3
a1023 3
			 * Initialize new block, append to end of list to
			 * preserve order.
			 */
a1024 1

d1038 1
a1038 1
			    if (!(new->name = (char *) malloc(alen))) {
d1042 1
a1042 1
			strcpy(new->name, name);
d1045 1
a1045 1
			alen = strlen((char *) &p[i]) + 2;
d1047 1
a1047 1
			    if (!(new->attributes = (char *) malloc(alen))) {
d1051 2
a1052 2
			strcpy(new->attributes, (char *) &p[i]);
			strcpy((char *) &new->attributes[alen - 2], " ");
d1057 2
a1058 2
			 * Scan for keywords.
			 */
d1064 2
a1065 2
	    }			/* end if *p == '-' */
	}			/* if end of line */
d1067 1
a1067 1
    }				/* Loop over characters */
d1072 1
a1072 1
	return -1;		/* no response */
d1075 2
a1076 2
    return 0;			/* all done */
}				/* end of procedure */
d1079 7
a1085 6
 *	====================================================
 */
static int generate_cso_form(char *host,
			     int port,
			     char *buf,
			     HTStream *Target)
d1092 25
a1116 27
    static char *template[] =
    {
	"<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
	"<H2><I>CSO/PH Query Form</I> for <EM>$(HOST)</EM></H2>",
	"To search the database for a name, fill in one or more of the fields",
	"in the form below and activate the 'Submit query' button.  At least",
	"one of the entered fields must be flagged as indexed.",
	"<HR><FORM method=\"POST\" action=\"cso://$(HOST)/\">",
	"[ <input type=\"submit\" value=\"Submit query\"> | ",
	"<input type=\"reset\" value=\"Clear fields\"> ]",
	"<P><DL>",
	"   <DT>Search parameters (* indicates indexed field):",
	"   <DD>",
	"$(NAMEFLD)    <DL COMPACT>\n    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD>Last: <input name=\"q_$(FID)\" type=\"text\" size=49$(FSIZE2)>",
	"    <DD>First: <input name=\"q_$(FID)\" type=\"text\" size=48$(FSIZE2)>",
	"$(QFIELDS)    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD><input name=\"q_$(FID)\" type=\"text\" $(FSIZE)>\n$(NEXTFLD)",
	"    </DL>",
	"   </DL>\n<P><DL>",
	"   <DT>Output format:",
	"   <DD>Returned data option: <select name=\"return\">",
	"    <option>default<option selected>all<option>selected</select><BR>",
	"$(RFIELDS)    <input type=\"checkbox\" name=\"r_$(FID)\"$(FDEF)> $(FDESC)<BR>",
	"$(NEXTFLD)    ",
	"   </DL></FORM><HR>\n</BODY>\n</HTML>",
	(char *) 0
d1126 3
a1128 3
     * Parse the strings in the template array to produce HTML document to send
     * to client.  First line is skipped for 'full' lists.
     */
d1131 1
a1131 3
    for (i = full_flag ? /***1***/ 0 : 0;
	 template[i];
	 i++) {
d1133 4
a1136 4
	 * Search the current string for substitution, flagged by $(
	 */
	for (line = template[i], j = 0; line[j]; j++) {
	    if ((line[j] == '$') && (line[j + 1] == '(')) {
d1138 3
a1140 3
		 * Command detected, flush output buffer and find closing ')'
		 * that delimits the command.
		 */
d1143 1
a1143 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1145 2
a1146 1
		for (key = &line[j]; line[j + 1] && (line[j] != ')'); j++) ;
d1148 2
a1149 2
		 * Save context, interpet command and restore updated context.
		 */
d1160 3
a1162 3
		     * Command wants us to skip (forward) to indicated token. 
		     * Start at current position.
		     */
a1163 1

d1169 1
a1169 1
					j = strlen(template[--i]) - 1;
a1182 1

d1184 1
a1184 1
			(*Target->isa->put_block) (Target, temp, strlen(temp));
d1190 2
a1191 2
		 * Non-command text, add to output buffer.
		 */
d1193 1
a1193 1
		if (out > (sizeof(buf) - 3)) {
d1195 1
a1195 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1204 1
a1204 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1210 4
a1213 3
 *	==============================================================
 */
static int generate_cso_report(HTStream *Target)
d1225 2
a1226 2
     * Read lines until non-negative status.
     */
d1229 2
a1230 2
     * Start grabbing chars from the network.
     */
d1233 2
a1234 3
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
d1238 3
a1240 3
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
d1246 3
a1248 2
	     * OK we now have a line.  Load it as 'p' and parse it.
	     */
d1260 1
a1260 1
			fname = ndx_str = &p[i + 1];
d1262 1
a1262 1
			fname = &p[i + 1];
d1272 1
a1272 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1276 2
a1277 2
				   "<HR><DL><DT>Information/status<DD><DL><DT>\n");
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1280 2
a1281 2
				   "<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n", ndx);
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1287 1
a1287 1
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d1299 1
a1299 1
			    fname[i--] = '\0';	/* trim trailing */
d1320 3
a1322 3
				   "<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",
				   fname, fvalue, fvalue);
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1325 1
a1325 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1348 1
a1348 2
				       strncmp(l, STR_MAILTO_URL,
					       LEN_MAILTO_URL) &&
d1365 1
a1365 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1369 1
a1369 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1409 1
a1409 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1412 2
a1413 2
		HTSprintf0(&buf, "<DD>%s\n", fname ? fname : rcode);
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d1417 1
a1417 1
  end_CSOreport:
d1420 1
a1420 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1427 7
a1433 6
 *	=====================================
 */
static int HTLoadCSO(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
d1438 1
a1438 1
    int status;			/* tcp return */
d1449 1
a1449 1
	init_acceptable();
d1452 1
a1452 1
	return -3;		/* Bad if no name sepcified     */
d1454 1
a1454 1
	return -2;		/* Bad if name had zero length  */
d1458 3
a1460 3
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "cso", CSO_PORT, &s);
d1463 4
a1466 5
	 * Interrupt cleanly.
	 */
	CTRACE((tfp,
		"HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
d1471 1
a1471 1
		arg));
d1483 1
a1483 1
    _HTProgress(GOPHER_SENDING_CSO_REQUEST);
d1490 1
a1490 1
    _HTProgress(GOPHER_SENT_CSO_REQUEST);
d1493 2
a1494 2
     * Now read the data from the socket.
     */
d1499 1
a1499 1
	    _HTProgress(CONNECTION_INTERRUPTED);
a1511 1

d1522 1
a1522 1
	    port = atoi((cp + 1));
d1531 1
a1531 1
	(*Target->isa->_free) (Target);
d1539 3
a1541 3
	      "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n",
	      host);
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
d1547 1
a1547 1
    if (BStrData(content)[BStrLen(content) - 1] != '&')
d1568 3
a1570 3
	     * Value parsed.  Unescape characters and look for first '=' to
	     * delimit field name from value.
	     */
d1577 4
a1580 4
		     * data[start..j-1] is field name,
		     * [j+1..finish-1] is value.
		     */
		    if ((data[start + 1] == '_') &&
d1583 3
a1585 3
			 * Decode fields number and lookup field info.
			 */
			sscanf(&data[start + 2], "%d=", &ndx);
d1587 2
a1588 2
			    if (ndx == fld->id) {
				if ((j + 1) >= finish)
d1603 1
a1603 1
						  fld->name, &data[j + 1]);
d1606 4
a1609 4
					       "Warning: non-lookup field ignored<BR>\n");
					(*Target->isa->put_block) (Target,
								   buf,
								   strlen(buf));
d1618 1
a1618 1
			if (!strcmp(&data[start + 7], "all")) {
d1620 1
a1620 1
			} else if (!strcmp(&data[start + 7], "selected")) {
d1633 2
a1634 2
	       "<EM>Error:</EM> At least one indexed field value must be specified!\n");
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1636 2
a1637 2
	(*Target->isa->put_block) (Target, buf, strlen(buf));
	(*Target->isa->_free) (Target);
d1642 2
a1643 2
     * Append return fields.
     */
d1656 2
a1657 2
    (*Target->isa->put_block) (Target, buf, strlen(buf));
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
d1659 1
a1659 1
    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1661 1
a1661 1
	CTRACE((tfp, "HTLoadCSO: Writing command `"));
d1674 2
a1675 2
    (*Target->isa->put_block) (Target, end_form, sizeof(end_form) - 1);
    (*Target->isa->_free) (Target);
d1682 10
a1691 9
 *	=============
 *
 *  Bug:  No decoding of strange data types as yet.
 *
 */
static int HTLoadGopher(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
d1693 4
a1696 4
    char *command;		/* The whole command */
    int status;			/* tcp return */
    char gtype;			/* Gopher Node type */
    char *selector;		/* Selector string */
d1699 1
a1699 1
	init_acceptable();
d1702 1
a1702 1
	return -3;		/* Bad if no name sepcified     */
d1704 1
a1704 1
	return -2;		/* Bad if name had zero length  */
d1708 4
a1711 4
     * If it's a port 105 GOPHER_CSO gtype with no ISINDEX token ('?'), use the
     * form-based CSO gateway (otherwise, return an ISINDEX cover page or do
     * the ISINDEX search).  - FM
     */
d1716 1
a1716 1
	    if (0 == strcmp((const char *) &arg[len - 6], ":105/2")) {
d1725 2
a1726 2
     * If it's a port 79/0[/...] URL, use the finger gateway.  - FM
     */
d1738 2
a1739 2
     * Get entity type, and selector string.
     */
d1741 1
a1741 2
	char *p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);

d1744 2
a1745 2
	if ((*selector++ == '/') && (*selector)) {	/* Skip first slash */
	    gtype = *selector++;	/* Pick up gtype */
d1748 1
a1748 2
	    char *query;

d1750 2
a1751 2
	     * Search is allowed.
	     */
d1754 1
a1754 1
	    if (!query || !query[1]) {	/* No search required */
d1758 1
a1758 1
		return HT_LOADED;	/* Local function only */
d1760 1
a1760 1
	    *query++ = '\0';	/* Skip '?'     */
d1762 3
a1764 3
		(char *) malloc(strlen(selector) + 1 + strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");
d1770 1
a1770 1
	    {			/* Remove plus signs 921006 */
d1772 2
a1773 4

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
d1777 1
a1777 1
	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */
d1779 1
a1779 2
	    char *query;

d1781 2
a1782 2
	     * Search is allowed.
	     */
d1784 1
a1784 1
	    if (!query || !query[1]) {	/* No search required */
d1788 1
a1788 1
		return HT_LOADED;	/* Local function only */
d1791 4
a1794 5
	    *query++ = '\0';	/* Skip '?'     */
	    command = (char *) malloc(strlen("query") + 1 +
				      strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");
d1800 1
a1800 1
	    {			/* Remove plus signs 921006 */
d1802 2
a1803 4

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
d1806 1
a1806 1
	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */
d1808 2
a1809 2
	} else {		/* Not index */
	    command = (char *) malloc(strlen(selector) + 2 + 1);
d1818 1
a1818 2
	char *p = command + strlen(command);

d1825 3
a1827 3
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "gopher", GOPHER_PORT, &s);
d1830 2
a1831 2
	 * Interrupt cleanly.
	 */
d1833 1
a1833 1
	_HTProgress(CONNECTION_INTERRUPTED);
d1839 1
a1839 1
		arg));
d1847 1
a1847 1
	    command, s));
d1851 1
a1851 2
	char *p;

d1858 1
a1858 1
    _HTProgress(GOPHER_SENDING_REQUEST);
d1860 1
a1860 1
    status = NETWRITE(s, command, (int) strlen(command));
d1867 1
a1867 1
    _HTProgress(GOPHER_SENT_REQUEST);
d1870 2
a1871 2
     * Now read the data from the socket.
     */
d1874 1
a1874 1
    case GOPHER_TEXT:
d1878 2
a1879 2
    case GOPHER_HTML:
    case GOPHER_CHTML:
d1887 1
a1887 1
		      format_out, anAnchor, s, sink);
d1890 2
a1891 2
    case GOPHER_MENU:
    case GOPHER_INDEX:
d1903 2
a1904 2
    case GOPHER_SOUND:
    case GOPHER_PLUS_SOUND:
d1914 1
a1914 1
		      s, sink);
d1923 3
a1925 3
	 * Specifying WWW_UNKNOWN forces dump to local disk.
	 */
	HTParseSocket(WWW_UNKNOWN, format_out, anAnchor, s, sink);
d1928 1
a1928 1
    }				/* switch(gtype) */
d1936 1
a1936 1
GLOBALDEF(HTProtocol, HTGopher, _HTGOPHER_C_1_INIT);
d1938 1
a1938 1
GLOBALDEF(HTProtocol, HTCSO, _HTCSO_C_1_INIT);
d1940 2
a1941 4
GLOBALDEF HTProtocol HTGopher =
{"gopher", HTLoadGopher, NULL};
GLOBALDEF HTProtocol HTCSO =
{"cso", HTLoadCSO, NULL};
@


1.1.3.4
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d80 2
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d161 1
a161 1
    return (char) (       (c>='0')&&(c<='9') ? c-'0'
d164 1
a164 1
			:		       0);
d194 1
a194 1
    CTRACE((tfp,"HTGopher: adding URL: %s\n",addr));
d254 1
a254 1
	    CTRACE((tfp, "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
d259 1
a259 1
	    *p = (char) ich;    /* Put character in line */
d267 1
a267 1
	    CTRACE((tfp, "HTGopher: Menu item: %s\n", line));
d406 1
a406 1
			if (acceptable[UCH(*r)]) {
d424 1
a424 1
		CTRACE((tfp, "HTGopher: Bad menu item.\n"));
d500 1
a500 1
		    *p = (char) ich;    /* Put character in line */
d711 1
a711 1
	    *q++ = (char) FROMASCII((b<<4) + from_hex(c));
d763 3
a765 1
	    sprintf(buf, "%.2046s", fld->description);
d943 1
a943 1
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d950 1
a950 1
	    *p = (char) ich;    /* Put character in buffer */
d984 5
a988 5
		/*
		** Check status, ignore any non-success.
		*/
		if (p[1] != '2' )
		    continue;
d990 16
a1005 18
		/*
		** Parse fields within returned line into status, ndx, name,
		** data.
		*/
		indx = NULL;
		name = NULL;
		for (i = 0; p[i]; i++) {
		    if (p[i] == ':' ) {
			p[i] = '\0';
			if (!indx) {
			    indx = (char *)&p[i+1];
			    code = atoi (indx);
			} else if (!name) {
			    name = (char *)&p[i+1];
			} else {
			    i++;
			    break;
			}
d1031 1
a1031 1
			new = typecalloc(CSOfield_info);
d1100 1
a1100 1
   "<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
d1240 1
a1240 1
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d1246 1
a1246 1
	    *p = (char) ich;    /* Put character in line */
d1462 1
a1462 1
    CTRACE((tfp, "HTLoadCSO: Looking for %s\n", arg));
d1472 1
a1472 1
	CTRACE((tfp, "HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
d1477 2
a1478 2
	CTRACE((tfp, "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
		    arg));
d1485 2
a1486 2
    CTRACE((tfp, "HTLoadCSO: Connected, writing command `%s' to socket %d\n",
		command, s));
d1491 1
a1491 1
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
d1658 2
a1659 2
    CTRACE((tfp, "HTLoadCSO: Writing command `%s' to socket %d\n",
		command, s));
d1663 1
a1663 1
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
d1700 1
a1700 1
    CTRACE((tfp, "HTGopher: Looking for %s\n", arg));
d1713 1
a1713 1
		CTRACE((tfp, "HTGopher: Passing to CSO/PH gateway.\n"));
d1724 1
a1724 1
	CTRACE((tfp, "HTGopher: Passing to finger gateway.\n"));
d1727 1
a1727 1
	HTAlert(COULD_NOT_ACCESS_DOCUMENT);
d1827 1
a1827 1
	CTRACE((tfp, "HTGopher: Interrupted on connect; recovering cleanly.\n"));
d1833 2
a1834 2
	CTRACE((tfp, "HTGopher: Unable to connect to remote host for `%s'.\n",
		    arg));
d1841 2
a1842 2
    CTRACE((tfp, "HTGopher: Connected, writing command `%s' to socket %d\n",
		command, s));
d1858 1
a1858 1
	CTRACE((tfp, "HTGopher: Unable to send command.\n"));
@

