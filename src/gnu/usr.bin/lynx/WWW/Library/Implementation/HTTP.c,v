head	1.10;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.9
	tg-mergefixes-1-branch:1.9.0.4
	tg-mergefixes-1-base:1.9
	MIROS_X:1.9.0.2
	MIROS_X_BASE:1.9
	MIRBSD_XP_MIRPPC:1.7.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.3.2
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.3.2.0.6
	MIRBSD_7:1.1.3.2.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.1.3.2
	MIRBSD_7_DEV:1.1.3.2.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2005.01.03.00.45.49;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.20.10.26.20;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.11.20.30.35;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.21.17.06.15;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2003.09.27.13.12.35;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.07.20.54.30;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.19.52.04;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.03;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.11;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.01;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.48;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.53;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.07;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.26;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.16;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.47.32;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.16;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.33;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTTP.c,v 1.9 2004/10/20 10:26:20 tg Exp $ */

/*	HyperText Tranfer Protocol	- Client implementation		HTTP.c
 *	==========================
 * Modified:
 * 27 Jan 1994	PDM  Added Ari Luotonen's Fix for Reload when using proxy
 *		     servers.
 * 28 Apr 1997	AJL,FM Do Proxy Authorisation.
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <LYUtils.h>

#ifdef USE_SSL
#include <HTNews.h>
#endif

#define HTTP_VERSION	"HTTP/1.0"

#define HTTP_PORT   80
#define HTTPS_PORT  443
#define SNEWS_PORT  563

#define INIT_LINE_SIZE		1536	/* Start with line buffer this big */
#define LINE_EXTEND_THRESH	256	/* Minimum read size */
#define VERSION_LENGTH		20	/* for returned protocol version */

#include <HTParse.h>
#include <HTTCP.h>
#include <HTFormat.h>
#include <HTFile.h>
#include <HTAlert.h>
#include <HTMIME.h>
#include <HTML.h>
#include <HTInit.h>
#include <HTAABrow.h>
#include <HTAccess.h>		/* Are we using an HTTP gateway? */

#include <LYCookie.h>
#include <LYGlobalDefs.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYrcFile.h>
#include <LYLeaks.h>

struct _HTStream {
    HTStreamClass *isa;
};

BOOL reloading = FALSE;		/* Reloading => send no-cache pragma to proxy */
char *redirecting_url = NULL;	/* Location: value. */
BOOL permanent_redirection = FALSE;	/* Got 301 status? */
BOOL redirect_post_content = FALSE;	/* Don't convert to GET? */

#ifdef USE_SSL
SSL_CTX *ssl_ctx = NULL;	/* SSL ctx */
SSL *SSL_handle = NULL;
static int ssl_okay;

static void free_ssl_ctx(void)
{
    if (ssl_ctx != NULL)
	SSL_CTX_free(ssl_ctx);
}

static int HTSSLCallback(int preverify_ok, X509_STORE_CTX * x509_ctx)
{
    char *msg = NULL;
    int result = 1;

    if (!(preverify_ok || ssl_okay || ssl_noprompt)) {
#ifdef USE_X509_SUPPORT
	HTSprintf0(&msg, "SSL error:%s-Continue?",
		   X509_verify_cert_error_string(X509_STORE_CTX_get_error(x509_ctx)));
	if (HTForcedPrompt(ssl_noprompt, msg, YES))
	    ssl_okay = 1;
	else
	    result = 0;
#endif

	FREE(msg);
    }
    return result;
}

SSL *HTGetSSLHandle(void)
{
    if (ssl_ctx == NULL) {
	/*
	 * First time only.
	 */
#if SSLEAY_VERSION_NUMBER < 0x0800
	ssl_ctx = SSL_CTX_new();
	X509_set_default_verify_paths(ssl_ctx->cert);
#else
	SSLeay_add_ssl_algorithms();
	ssl_ctx = SSL_CTX_new(SSLv23_client_method());
	SSL_CTX_set_options(ssl_ctx, SSL_OP_ALL);
	SSL_CTX_set_default_verify_paths(ssl_ctx);
	SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, HTSSLCallback);
#endif /* SSLEAY_VERSION_NUMBER < 0x0800 */
	atexit(free_ssl_ctx);
    }
    ssl_okay = 0;
    return (SSL_new(ssl_ctx));
}

void HTSSLInitPRNG(void)
{
#if SSLEAY_VERSION_NUMBER >= 0x00905100
    if (RAND_status() == 0) {
	char rand_file[256];
	time_t t;
	int pid;
	long l, seed;

	t = time(NULL);
	pid = getpid();
	RAND_file_name(rand_file, 256);
	CTRACE((tfp, "HTTP: Seeding PRNG\n"));
	if (rand_file != NULL) {
	    /* Seed as much as 1024 bytes from RAND_file_name */
	    RAND_load_file(rand_file, 1024);
	}
	/* Seed in time (mod_ssl does this) */
	RAND_seed((unsigned char *) &t, sizeof(time_t));
	/* Seed in pid (mod_ssl does this) */
	RAND_seed((unsigned char *) &pid, sizeof(pid));
	/* Initialize system's random number generator */
	RAND_bytes((unsigned char *) &seed, sizeof(long));

	lynx_srand(seed);
	while (RAND_status() == 0) {
	    /* Repeatedly seed the PRNG using the system's random number generator until it has been seeded with enough data */
	    l = lynx_rand();
	    RAND_seed((unsigned char *) &l, sizeof(long));
	}
	if (rand_file != NULL) {
	    /* Write a rand_file */
	    RAND_write_file(rand_file);
	}
    }
#endif /* SSLEAY_VERSION_NUMBER >= 0x00905100 */
    return;
}

#define HTTP_NETREAD(sock, buff, size, handle) \
	(handle ? SSL_read(handle, buff, size) : NETREAD(sock, buff, size))
#define HTTP_NETWRITE(sock, buff, size, handle) \
	(handle ? SSL_write(handle, buff, size) : NETWRITE(sock, buff, size))
#define HTTP_NETCLOSE(sock, handle)  \
	{ (void)NETCLOSE(sock); if (handle) SSL_free(handle); SSL_handle = handle = NULL; }

#else
#define HTTP_NETREAD(a, b, c, d)   NETREAD(a, b, c)
#define HTTP_NETWRITE(a, b, c, d)  NETWRITE(a, b, c)
#define HTTP_NETCLOSE(a, b)  (void)NETCLOSE(a)
#endif /* USE_SSL */

#ifdef _WINDOWS			/* 1997/11/06 (Thu) 13:00:08 */

#define	BOX_TITLE	"Lynx " __FILE__
#define	BOX_FLAG	(MB_ICONINFORMATION | MB_SETFOREGROUND)

typedef struct {
    int fd;
    char *buf;
    int len;
} recv_data_t;

int ws_read_per_sec = 0;
static int ws_errno = 0;

static DWORD g_total_times = 0;
static DWORD g_total_bytes = 0;

char *str_speed(void)
{
    static char buff[32];

    if (ws_read_per_sec > 1000)
	sprintf(buff, "%d.%03dkB", ws_read_per_sec / 1000,
		(ws_read_per_sec % 1000));
    else
	sprintf(buff, "%3d", ws_read_per_sec);

    return buff;
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

static int ws_read(int fd, char *buf, int len)
{
    int res;
    int retry = 3;

    do {
	res = recv(fd, buf, len, 0);
	if (WSAEWOULDBLOCK == WSAGetLastError()) {
	    Sleep(100);
	    if (retry-- > 0)
		continue;
	}
    } while (res == SOCKET_ERROR && SOCKET_ERRNO == EINTR);

    return res;
}

static DWORD __stdcall _thread_func(void *p)
{
    int i, val, ret;
    recv_data_t *q = (recv_data_t *) p;

    i = 0;
    i++;
    val = ws_read(q->fd, q->buf, q->len);

    if (val == SOCKET_ERROR) {
	ws_errno = WSAGetLastError();
#if 0
	char buff[256];

	sprintf(buff, "Thread read: %d, error (%ld), fd = %d, len = %d",
		i, ws_errno, q->fd, q->len);
	MessageBox(NULL, buff, BOX_TITLE, BOX_FLAG);
#endif
	ret = -1;
    } else {
	ret = val;
    }

    return ((DWORD) ret);
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

int ws_netread(int fd, char *buf, int len)
{
    int i;
    char buff[256];

    /* 1998/03/30 (Mon) 09:01:21 */
    HANDLE hThread;
    DWORD dwThreadID;
    DWORD exitcode = 0;
    DWORD ret_val = -1, val, process_time, now_TickCount, save_TickCount;

    static recv_data_t para;

    extern int win32_check_interrupt(void);	/* LYUtil.c */
    extern int lynx_timeout;	/* LYMain.c */
    extern CRITICAL_SECTION critSec_READ;	/* LYMain.c */

#define TICK	5
#define STACK_SIZE	0x2000uL

    InitializeCriticalSection(&critSec_READ);

    para.fd = fd;
    para.buf = buf;
    para.len = len;

    ws_read_per_sec = 0;
    save_TickCount = GetTickCount();

    hThread = CreateThread(NULL, STACK_SIZE,
			   _thread_func,
			   (void *) &para, 0UL, &dwThreadID);

    if (hThread == 0) {
	HTInfoMsg("CreateThread Failed (read)");
	goto read_exit;
    }

    i = 0;
    while (1) {
	val = WaitForSingleObject(hThread, 1000 / TICK);
	i++;
	if (val == WAIT_FAILED) {
	    HTInfoMsg("Wait Failed");
	    ret_val = -1;
	    break;
	} else if (val == WAIT_TIMEOUT) {
	    i++;
	    if (i / TICK > (AlertSecs + 2)) {
		sprintf(buff, "Read Waiting (%2d.%01d) for %d Bytes",
			i / TICK, (i % TICK) * 10 / TICK, len);
		SetConsoleTitle(buff);
	    }
	    if (win32_check_interrupt() || ((i / TICK) > lynx_timeout)) {
		if (CloseHandle(hThread) == FALSE) {
		    HTInfoMsg("Thread terminate Failed");
		}
		WSASetLastError(ETIMEDOUT);
		ret_val = HT_INTERRUPTED;
		break;
	    }
	} else if (val == WAIT_OBJECT_0) {
	    if (GetExitCodeThread(hThread, &exitcode) == FALSE) {
		exitcode = -1;
	    }
	    if (CloseHandle(hThread) == FALSE) {
		HTInfoMsg("Thread terminate Failed");
	    }
	    now_TickCount = GetTickCount();
	    if (now_TickCount > save_TickCount)
		process_time = now_TickCount - save_TickCount;
	    else
		process_time = now_TickCount + (0xffffffff - save_TickCount);

	    g_total_times += process_time;
	    g_total_bytes += exitcode;

	    if (g_total_bytes > 2000000) {
		ws_read_per_sec = g_total_bytes / (g_total_times / 1000);
	    } else {
		ws_read_per_sec = g_total_bytes * 1000 / g_total_times;
	    }
	    ret_val = exitcode;
	    break;
	}
    }				/* end while(1) */

  read_exit:
    LeaveCriticalSection(&critSec_READ);
    return ret_val;
}
#endif

/*
 * Strip any username from the given string so we retain only the host.
 */
static void strip_userid(char *host)
{
    char *p1 = host;
    char *p2 = strchr(host, '@@');
    char *fake;

    if (p2 != 0) {
	*p2++ = '\0';
	if ((fake = HTParse(host, "", PARSE_HOST)) != NULL) {
	    char *msg = NULL;

	    CTRACE((tfp, "parsed:%s\n", fake));
	    HTSprintf0(&msg, gettext("Address contains a username: %s"), host);
	    HTAlert(msg);
	    FREE(msg);
	}
	while ((*p1++ = *p2++) != '\0') {
	    ;
	}
    }
}

/*
 * Check if the user's options specified to use the given encoding.  Normally
 * all encodings with compiled-in support are specified (encodingALL).
 */
static BOOL acceptEncoding(int code)
{
    BOOL result = FALSE;

    if ((code & LYAcceptEncoding) != 0) {
	const char *program = 0;

	switch (code) {
	case encodingGZIP:
	    program = HTGetProgramPath(ppGZIP);
	    break;
	case encodingDEFLATE:
	    program = HTGetProgramPath(ppINFLATE);
	    break;
	case encodingCOMPRESS:
	    program = HTGetProgramPath(ppCOMPRESS);
	    break;
	case encodingBZIP2:
	    program = HTGetProgramPath(ppBZIP2);
	    break;
	default:
	    break;
	}
	/*
	 * FIXME:  if lynx did not rely upon external programs to decompress
	 * files for external viewers, this check could be relaxed.
	 */
	result = (program != 0);
    }
    return result;
}

/*		Load Document from HTTP Server			HTLoadHTTP()
 *		==============================
 *
 *	Given a hypertext address, this routine loads a document.
 *
 *
 *  On entry,
 *	arg	is the hypertext reference of the article to be loaded.
 *
 *  On exit,
 *	returns >=0	If no error, a good socket number
 *		<0	Error.
 *
 *	The socket must be closed by the caller after the document has been
 *	read.
 *
 */
static int HTLoadHTTP(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *sink)
{
    static char *empty = "";
    int s;			/* Socket number for returned data */
    const char *url = arg;	/* The URL which get_physical() returned */
    bstring *command = NULL;	/* The whole command */
    char *eol;			/* End of line if found */
    char *start_of_data;	/* Start of body of reply */
    int status;			/* tcp return */
    int bytes_already_read;
    char crlf[3];		/* A CR LF equivalent string */
    HTStream *target;		/* Unconverted data */
    HTFormat format_in;		/* Format arriving in the message */
    BOOL do_head = FALSE;	/* Whether or not we should do a head */
    BOOL do_post = FALSE;	/* ARE WE posting ? */
    const char *METHOD;

    BOOL had_header;		/* Have we had at least one header? */
    char *line_buffer;
    char *line_kept_clean;
    int real_length_of_line;
    BOOL extensions;		/* Assume good HTTP server */
    char *linebuf = NULL;
    char temp[80];
    BOOL first_Accept = TRUE;
    BOOL show_401 = FALSE;
    BOOL show_407 = FALSE;
    BOOL auth_proxy = NO;	/* Generate a proxy authorization. - AJL */

    int length, rawlength, rv;
    int server_status;
    BOOL doing_redirect, already_retrying = FALSE;
    int len = 0;

#ifdef USE_SSL
    BOOL do_connect = FALSE;	/* ARE WE going to use a proxy tunnel ? */
    BOOL did_connect = FALSE;	/* ARE WE actually using a proxy tunnel ? */
    const char *connect_url = NULL;	/* The URL being proxied */
    char *connect_host = NULL;	/* The host being proxied */
    SSL *handle = NULL;		/* The SSL handle */
    char ssl_dn[256];
    char *cert_host;
    char *ssl_host;
    char *p;
    char *msg = NULL;

#if SSLEAY_VERSION_NUMBER >= 0x0900
    BOOL try_tls = TRUE;
#endif /* SSLEAY_VERSION_NUMBER >= 0x0900 */
    SSL_handle = NULL;
#else
    void *handle = NULL;
#endif /* USE_SSL */

    if (anAnchor->isHEAD)
	do_head = TRUE;
    else if (anAnchor->post_data)
	do_post = TRUE;

    if (!url) {
	status = -3;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
    if (!*url) {
	status = -2;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
#ifdef USE_SSL
    if (using_proxy && !strncmp(url, "http://", 7)) {
	if ((connect_url = strstr((url + 7), "https://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "https", PARSE_HOST);
	    if (!strchr(connect_host, ':')) {
		sprintf(temp, ":%d", HTTPS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	} else if ((connect_url = strstr((url + 7), "snews://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "snews", PARSE_HOST);
	    if (!strchr(connect_host, ':')) {
		sprintf(temp, ":%d", SNEWS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	}
    }
#endif /* USE_SSL */

    sprintf(crlf, "%c%c", CR, LF);

    /*
     * At this point, we're talking HTTP/1.0.
     */
    extensions = YES;

  try_again:
    /*
     * All initializations are moved down here from up above, so we can start
     * over here...
     */
    eol = 0;
    had_header = NO;
    length = 0;
    doing_redirect = FALSE;
    permanent_redirection = FALSE;
    redirect_post_content = FALSE;
    target = NULL;
    line_buffer = NULL;
    line_kept_clean = NULL;

#ifdef USE_SSL
    if (!strncmp(url, "https", 5))
	status = HTDoConnect(url, "HTTPS", HTTPS_PORT, &s);
    else
	status = HTDoConnect(url, "HTTP", HTTP_PORT, &s);
#else
    if (!strncmp(url, "https", 5)) {
	HTAlert(gettext("This client does not contain support for HTTPS URLs."));
	status = HT_NOT_LOADED;
	goto done;
    }
    status = HTDoConnect(arg, "HTTP", HTTP_PORT, &s);
#endif /* USE_SSL */
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp, "HTTP: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	status = HT_NOT_LOADED;
	goto done;
    }
    if (status < 0) {
#ifdef _WINDOWS
	CTRACE((tfp, "HTTP: Unable to connect to remote host for `%s'\n"
		" (status = %d, sock_errno = %d).\n",
		url, status, SOCKET_ERRNO));
#else
	CTRACE((tfp,
		"HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
		url, SOCKET_ERRNO));
#endif
	HTAlert(gettext("Unable to connect to remote host."));
	status = HT_NOT_LOADED;
	goto done;
    }
#ifdef USE_SSL
  use_tunnel:
    /*
     * If this is an https document, then do the SSL stuff here.
     */
    if (did_connect || !strncmp(url, "https", 5)) {
	SSL_handle = handle = HTGetSSLHandle();
	SSL_set_fd(handle, s);
#if SSLEAY_VERSION_NUMBER >= 0x0900
	if (!try_tls)
	    handle->options |= SSL_OP_NO_TLSv1;
#endif /* SSLEAY_VERSION_NUMBER >= 0x0900 */
	HTSSLInitPRNG();
	status = SSL_connect(handle);

	if (status <= 0) {
#if SSLEAY_VERSION_NUMBER >= 0x0900
	    if (try_tls) {
		_HTProgress(gettext("Retrying connection without TLS."));
		try_tls = FALSE;
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		goto try_again;
	    } else {
		unsigned long SSLerror;

		CTRACE((tfp,
			"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
			url, status));
		SSL_load_error_strings();
		while ((SSLerror = ERR_get_error()) != 0) {
		    CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
		}
		HTAlert("Unable to make secure connection to remote host.");
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		status = HT_NOT_LOADED;
		goto done;
	    }
#else
	    unsigned long SSLerror;

	    CTRACE((tfp,
		    "HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		    url, status));
	    SSL_load_error_strings();
	    while ((SSLerror = ERR_get_error()) != 0) {
		CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
	    }
	    HTAlert("Unable to make secure connection to remote host.");
	    if (did_connect)
		HTTP_NETCLOSE(s, handle);
	    status = HT_NOT_LOADED;
	    goto done;
#endif /* SSLEAY_VERSION_NUMBER >= 0x0900 */
	}

	X509_NAME_oneline(X509_get_subject_name(SSL_get_peer_certificate(handle)),
			  ssl_dn, sizeof(ssl_dn));
	if ((cert_host = strstr(ssl_dn, "/CN=")) == NULL) {
	    HTSprintf0(&msg,
		       gettext("SSL error:Can't find common name in certificate-Continue?"));
	    if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		status = HT_NOT_LOADED;
		FREE(msg);
		goto done;
	    }
	} else {
	    cert_host += 4;
	    if ((p = strchr(cert_host, '/')) != NULL)
		*p = '\0';
	    if ((p = strchr(cert_host, ':')) != NULL)
		*p = '\0';
	    ssl_host = HTParse(url, "", PARSE_HOST);
	    if ((p = strchr(ssl_host, ':')) != NULL)
		*p = '\0';
	    if (strcasecomp_asterisk(ssl_host, cert_host)) {
		HTSprintf0(&msg,
			   gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
			   ssl_host,
			   cert_host);
		if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		    status = HT_NOT_LOADED;
		    FREE(msg);
		    goto done;
		}
	    }
	}

	HTSprintf0(&msg,
		   gettext("Secure %d-bit %s (%s) HTTP connection"),
		   SSL_get_cipher_bits(handle, NULL),
		   SSL_get_cipher_version(handle),
		   SSL_get_cipher(handle));
	_HTProgress(msg);
	FREE(msg);
    }
#endif /* USE_SSL */

    /* Ask that node for the document, omitting the host name & anchor
     */
    {
	char *p1 = (HTParse(url, "", PARSE_PATH | PARSE_PUNCTUATION));

#ifdef USE_SSL
	if (do_connect) {
	    METHOD = "CONNECT";
	    BStrCopy0(command, "CONNECT ");
	} else
#endif /* USE_SSL */
	if (do_post) {
	    METHOD = "POST";
	    BStrCopy0(command, "POST ");
	} else if (do_head) {
	    METHOD = "HEAD";
	    BStrCopy0(command, "HEAD ");
	} else {
	    METHOD = "GET";
	    BStrCopy0(command, "GET ");
	}

	/*
	 * If we are using a proxy gateway don't copy in the first slash of
	 * say:  /gopher://a;lkdjfl;ajdf;lkj/;aldk/adflj so that just
	 * gopher://....  is sent.
	 */
#ifdef USE_SSL
	if (using_proxy && !did_connect) {
	    if (do_connect)
		BStrCat0(command, connect_host);
	    else
		BStrCat0(command, p1 + 1);
	}
#else
	if (using_proxy)
	    BStrCat0(command, p1 + 1);
#endif /* USE_SSL */
	else
	    BStrCat0(command, p1);
	FREE(p1);
    }
    if (extensions) {
	BStrCat0(command, " ");
	BStrCat0(command, HTTP_VERSION);
    }

    BStrCat0(command, crlf);	/* CR LF, as in rfc 977 */

    if (extensions) {
	int n, i;
	char *host = NULL;

	if ((host = HTParse(anAnchor->address, "", PARSE_HOST)) != NULL) {
	    strip_userid(host);
	    HTBprintf(&command, "Host: %s%c%c", host, CR, LF);
	    FREE(host);
	}

	if (!HTPresentations)
	    HTFormatInit();
	n = HTList_count(HTPresentations);

	first_Accept = TRUE;
	len = 0;
	for (i = 0; i < n; i++) {
	    HTPresentation *pres =
	    (HTPresentation *) HTList_objectAt(HTPresentations, i);

	    if (pres->get_accept) {
		if (pres->quality < 1.0) {
		    if (pres->maxbytes > 0) {
			sprintf(temp, ";q=%4.3f;mxb=%ld",
				pres->quality, pres->maxbytes);
		    } else {
			sprintf(temp, ";q=%4.3f", pres->quality);
		    }
		} else if (pres->maxbytes > 0) {
		    sprintf(temp, ";mxb=%ld", pres->maxbytes);
		} else {
		    temp[0] = '\0';
		}
		HTSprintf0(&linebuf, "%s%s%s",
			   (first_Accept ?
			    "Accept: " : ", "),
			   HTAtom_name(pres->rep),
			   temp);
		len += strlen(linebuf);
		if (len > 252 && !first_Accept) {
		    BStrCat0(command, crlf);
		    HTSprintf0(&linebuf, "Accept: %s%s",
			       HTAtom_name(pres->rep),
			       temp);
		    len = strlen(linebuf);
		}
		BStrCat0(command, linebuf);
		first_Accept = FALSE;
	    }
	}
	HTBprintf(&command, "%s*/*;q=0.01%c%c",
		  (first_Accept ?
		   "Accept: " : ", "), CR, LF);
	first_Accept = FALSE;
	len = 0;

	/*
	 * FIXME:  suppressing the "Accept-Encoding" in this case is done to
	 * work around limitations of the presentation logic used for the
	 * command-line "-base" option.  The remote site may transmit the
	 * document gzip'd, but the ensuing logic in HTSaveToFile() would see
	 * the mime-type as gzip rather than text/html, and not prepend the
	 * base URL.  This is less efficient than accepting the compressed data
	 * and uncompressing it, adding the base URL but is simpler than
	 * augmenting the dump's presentation logic -TD
	 */
	if (LYPrependBaseToSource && dump_output_immediately) {
	    CTRACE((tfp,
		    "omit Accept-Encoding to work-around interaction with -source\n"));
	} else {
	    char *list = 0;
	    int j, k;

	    for (j = 1; j < encodingALL; j <<= 1) {
		if (acceptEncoding(j)) {
		    for (k = 0; tbl_preferred_encoding[k].name != 0; ++k) {
			if (tbl_preferred_encoding[k].value == j) {
			    if (list != 0)
				StrAllocCat(list, ", ");
			    StrAllocCat(list, tbl_preferred_encoding[k].name);
			    break;
			}
		    }
		}
	    }

	    if (list != 0) {
		HTBprintf(&command, "Accept-Encoding: %s%c%c", list, CR, LF);
		free(list);
	    }
	}

	if (language && *language) {
	    HTBprintf(&command, "Accept-Language: %s%c%c", language, CR, LF);
	}

	if (pref_charset && *pref_charset) {
	    BStrCat0(command, "Accept-Charset: ");
	    StrAllocCopy(linebuf, pref_charset);
	    if (linebuf[strlen(linebuf) - 1] == ',')
		linebuf[strlen(linebuf) - 1] = '\0';
	    LYLowerCase(linebuf);
	    if (strstr(linebuf, "iso-8859-1") == NULL)
		StrAllocCat(linebuf, ", iso-8859-1;q=0.01");
	    if (strstr(linebuf, "us-ascii") == NULL)
		StrAllocCat(linebuf, ", us-ascii;q=0.01");
	    BStrCat0(command, linebuf);
	    HTBprintf(&command, "%c%c", CR, LF);
	}
#if 0
	/*
	 * Promote 300 (Multiple Choices) replies, if supported, over 406 (Not
	 * Acceptable) replies.  - FM
	 *
	 * This used to be done in versions 2.7 and 2.8*, but violates the
	 * specs for transparent content negotiation and has the effect that
	 * servers supporting those specs will send 300 (Multiple Choices)
	 * instead of a normal response (e.g.  200 OK), since they will assume
	 * that the client wants to make the choice.  It is not clear whether
	 * there are any servers or sites for which sending this header really
	 * improves anything.
	 *
	 * If there ever is a need to send "Negotiate:  trans" and really mean
	 * it, we should send "Negotiate:  trans,trans" or similar, since that
	 * is semantically equivalent and some servers may ignore "Negotiate: 
	 * trans" as a special case when it comes from Lynx (to work around the
	 * old faulty behavior).  - kw
	 *
	 * References:
	 * RFC 2295 (see also RFC 2296), and mail to lynx-dev and
	 * new-httpd@@apache.org from Koen Holtman, Jan 1999.
	 */
	if (!do_post) {
	    HTBprintf(&command, "Negotiate: trans%c%c", CR, LF);
	}
#endif /* 0 */

	/*
	 * When reloading give no-cache pragma to proxy server to make it
	 * refresh its cache.  -- Ari L.  <luotonen@@dxcern.cern.ch>
	 *
	 * Also send it as a Cache-Control header for HTTP/1.1.  - FM
	 */
	if (reloading) {
	    HTBprintf(&command, "Pragma: no-cache%c%c", CR, LF);
	    HTBprintf(&command, "Cache-Control: no-cache%c%c", CR, LF);
	}

	if (LYUserAgent && *LYUserAgent) {
	    char *cp = LYSkipBlanks(LYUserAgent);

	    /* Won't send it at all if all blank - kw */
	    if (*cp != '\0')
		HTBprintf(&command, "User-Agent: %.*s%c%c",
			  INIT_LINE_SIZE - 15, LYUserAgent, CR, LF);
	} else {
	    HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
		      HTAppName ? HTAppName : "unknown",
		      HTAppVersion ? HTAppVersion : "0.0",
		      HTLibraryVersion, CR, LF);
	}

	if (personal_mail_address && !LYNoFromHeader) {
	    HTBprintf(&command, "From: %s%c%c", personal_mail_address, CR, LF);
	}

	if (!(LYUserSpecifiedURL ||
	      LYNoRefererHeader || LYNoRefererForThis) &&
	    strcmp(HTLoadedDocumentURL(), "")) {
	    const char *cp = LYRequestReferer;

	    if (!cp)
		cp = HTLoadedDocumentURL();	/* @@@@@@ Try both? - kw */
	    BStrCat0(command, "Referer: ");
	    if (isLYNXIMGMAP(cp)) {
		char *pound = findPoundSelector(cp);
		int nn = (pound ? (int) (pound - cp) : (int) strlen(cp));

		HTSABCat(&command, cp + LEN_LYNXIMGMAP, nn);
	    } else {
		BStrCat0(command, cp);
	    }
	    HTBprintf(&command, "%c%c", CR, LF);
	} {
	    char *abspath;
	    char *docname;
	    char *hostname;
	    char *colon;
	    int portnumber;
	    char *auth, *cookie = NULL;
	    BOOL secure = (BOOL) (strncmp(anAnchor->address, "https", 5) ?
				  FALSE : TRUE);

	    abspath = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);
	    docname = HTParse(arg, "", PARSE_PATH);
	    hostname = HTParse(arg, "", PARSE_HOST);
	    if (hostname &&
		NULL != (colon = strchr(hostname, ':'))) {
		*(colon++) = '\0';	/* Chop off port number */
		portnumber = atoi(colon);
	    } else if (!strncmp(arg, "https", 5)) {
		portnumber = HTTPS_PORT;
	    } else {
		portnumber = HTTP_PORT;
	    }

	    /*
	     * Add Authorization, Proxy-Authorization, and/or Cookie headers,
	     * if applicable.
	     */
	    if (using_proxy) {
		/*
		 * If we are using a proxy, first determine if we should
		 * include an Authorization header and/or Cookie header for the
		 * ultimate target of this request.  - FM & AJL
		 */
		char *host2 = NULL, *path2 = NULL;
		int port2 = (strncmp(docname, "https", 5) ?
			     HTTP_PORT : HTTPS_PORT);

		host2 = HTParse(docname, "", PARSE_HOST);
		path2 = HTParse(docname, "", PARSE_PATH | PARSE_PUNCTUATION);
		if (host2) {
		    if ((colon = strchr(host2, ':')) != NULL) {
			/* Use non-default port number */
			*colon = '\0';
			colon++;
			port2 = atoi(colon);
		    }
		}
		/*
		 * This composeAuth() does file access, i.e., for the ultimate
		 * target of the request.  - AJL
		 */
		auth_proxy = NO;
		if ((auth = HTAA_composeAuth(host2, port2, path2,
					     auth_proxy)) != NULL &&
		    *auth != '\0') {
		    /*
		     * If auth is not NULL nor zero-length, it's an
		     * Authorization header to be included.  - FM
		     */
		    HTBprintf(&command, "%s%c%c", auth, CR, LF);
		    CTRACE((tfp, "HTTP: Sending authorization: %s\n", auth));
		} else if (auth && *auth == '\0') {
		    /*
		     * If auth is a zero-length string, the user either
		     * cancelled or goofed at the username and password prompt. 
		     * - FM
		     */
		    if (!(traversal || dump_output_immediately) &&
			HTConfirm(CONFIRM_WO_PASSWORD)) {
			show_401 = TRUE;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_NEED_PASSWD);
#ifdef USE_SSL
			if (did_connect)
			    HTTP_NETCLOSE(s, handle);
#endif /* USE_SSL */
			BStrFree(command);
			FREE(hostname);
			FREE(docname);
			FREE(abspath);
			FREE(host2);
			FREE(path2);
			status = HT_NOT_LOADED;
			goto done;
		    }
		} else {
		    CTRACE((tfp, "HTTP: Not sending authorization (yet).\n"));
		}
		/*
		 * Add 'Cookie:' header, if it's HTTP or HTTPS document being
		 * proxied.
		 */
		if (!strncmp(docname, "http", 4)) {
		    cookie = LYAddCookieHeader(host2, path2, port2, secure);
		}
		FREE(host2);
		FREE(path2);
		/*
		 * The next composeAuth() will be for the proxy.  - AJL
		 */
		auth_proxy = YES;
	    } else {
		/*
		 * Add cookie for a non-proxied request.  - FM
		 */
		cookie = LYAddCookieHeader(hostname, abspath, portnumber, secure);
		auth_proxy = NO;
	    }
	    /*
	     * If we do have a cookie set, add it to the request buffer.  - FM
	     */
	    if (cookie != NULL) {
		if (*cookie != '$') {
		    /*
		     * It's a historical cookie, so signal to the server that
		     * we support modern cookies.  - FM
		     */
		    BStrCat0(command, "Cookie2: $Version=\"1\"");
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n"));
		}
		if (*cookie != '\0') {
		    /*
		     * It's not a zero-length string, so add the header.  Note
		     * that any folding of long strings has been done already
		     * in LYCookie.c.  - FM
		     */
		    BStrCat0(command, "Cookie: ");
		    BStrCat0(command, cookie);
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie: %s\n", cookie));
		}
		FREE(cookie);
	    }
	    FREE(abspath);

	    /*
	     * If we are using a proxy, auth_proxy should be YES, and we check
	     * here whether we want a Proxy-Authorization header for it.  If we
	     * are not using a proxy, auth_proxy should still be NO, and we
	     * check here for whether we want an Authorization header.  - FM &
	     * AJL
	     */
	    if ((auth = HTAA_composeAuth(hostname,
					 portnumber,
					 docname,
					 auth_proxy)) != NULL &&
		*auth != '\0') {
		/*
		 * If auth is not NULL nor zero-length, it's an Authorization
		 * or Proxy-Authorization header to be included.  - FM
		 */
		HTBprintf(&command, "%s%c%c", auth, CR, LF);
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Sending proxy authorization: %s\n" :
			      "HTTP: Sending authorization: %s\n"),
			auth));
	    } else if (auth && *auth == '\0') {
		/*
		 * If auth is a zero-length string, the user either cancelled
		 * or goofed at the username and password prompt.  - FM
		 */
		if (!(traversal || dump_output_immediately) && HTConfirm(CONFIRM_WO_PASSWORD)) {
		    if (auth_proxy == TRUE) {
			show_407 = TRUE;
		    } else {
			show_401 = TRUE;
		    }
		} else {
		    if (traversal || dump_output_immediately)
			HTAlert(FAILED_NEED_PASSWD);
		    BStrFree(command);
		    FREE(hostname);
		    FREE(docname);
		    status = HT_NOT_LOADED;
		    goto done;
		}
	    } else {
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Not sending proxy authorization (yet).\n" :
			      "HTTP: Not sending authorization (yet).\n")));
	    }
	    FREE(hostname);
	    FREE(docname);
	}
	auth_proxy = NO;
    }

    if (
#ifdef USE_SSL
	   !do_connect &&
#endif /* USE_SSL */
	   do_post) {
	CTRACE((tfp, "HTTP: Doing post, content-type '%s'\n",
		anAnchor->post_content_type
		? anAnchor->post_content_type
		: "lose"));
	HTBprintf(&command, "Content-type: %s%c%c",
		  anAnchor->post_content_type
		  ? anAnchor->post_content_type
		  : "lose",
		  CR, LF);

	HTBprintf(&command, "Content-length: %d%c%c",
		  !isBEmpty(anAnchor->post_data)
		  ? BStrLen(anAnchor->post_data)
		  : 0,
		  CR, LF);

	BStrCat0(command, crlf);	/* Blank line means "end" of headers */

	BStrCat(command, anAnchor->post_data);
    } else
	BStrCat0(command, crlf);	/* Blank line means "end" of headers */

    if (TRACE) {
	CTRACE((tfp, "Writing:\n"));
	trace_bstring(command);
#ifdef USE_SSL
	CTRACE((tfp, "%s",
		(anAnchor->post_data && !do_connect ? crlf : "")));
#else
	CTRACE((tfp, "%s",
		(anAnchor->post_data ? crlf : "")));
#endif /* USE_SSL */
	CTRACE((tfp, "----------------------------------\n"));
    }

    _HTProgress(gettext("Sending HTTP request."));

#ifdef    NOT_ASCII		/* S/390 -- gil -- 0548 */
    {
	char *p2;

	for (p2 = BStrData(command);
	     p2 < BStrData(command) + BStrLen(command);
	     p2++)
	    *p2 = TOASCII(*p2);
    }
#endif /* NOT_ASCII */
    status = HTTP_NETWRITE(s, BStrData(command), BStrLen(command), handle);
    BStrFree(command);
    FREE(linebuf);
    if (status <= 0) {
	if (status == 0) {
	    CTRACE((tfp, "HTTP: Got status 0 in initial write\n"));
	    /* Do nothing. */
	} else if ((SOCKET_ERRNO == ENOTCONN ||
		    SOCKET_ERRNO == ECONNRESET ||
		    SOCKET_ERRNO == EPIPE) &&
		   !already_retrying &&
	    /* Don't retry if we're posting. */ !do_post) {
	    /*
	     * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
	     */
	    CTRACE((tfp,
		    "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n"));
	    _HTProgress(RETRYING_AS_HTTP0);
	    HTTP_NETCLOSE(s, handle);
	    extensions = NO;
	    already_retrying = TRUE;
	    goto try_again;
	} else {
	    CTRACE((tfp,
		    "HTTP: Hit unexpected network WRITE error; aborting connection.\n"));
	    HTTP_NETCLOSE(s, handle);
	    status = -1;
	    HTAlert(gettext("Unexpected network write error; connection aborted."));
	    goto done;
	}
    }

    CTRACE((tfp, "HTTP: WRITE delivered OK\n"));
    _HTProgress(gettext("HTTP request sent; waiting for response."));

    /*    Read the first line of the response
     * -----------------------------------
     */
    {
	/* Get numeric status etc */
	BOOL end_of_file = NO;
	int buffer_length = INIT_LINE_SIZE;

	line_buffer = typecallocn(char, buffer_length);

	if (line_buffer == NULL)
	    outofmem(__FILE__, "HTLoadHTTP");

	HTReadProgress(bytes_already_read = 0, 0);
	do {			/* Loop to read in the first line */
	    /*
	     * Extend line buffer if necessary for those crazy WAIS URLs ;-)
	     */
	    if (buffer_length - length < LINE_EXTEND_THRESH) {
		buffer_length = buffer_length + buffer_length;
		line_buffer =
		    (char *) realloc(line_buffer, (buffer_length * sizeof(char)));

		if (line_buffer == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
	    }
	    CTRACE((tfp, "HTTP: Trying to read %d\n", buffer_length - length - 1));
	    status = HTTP_NETREAD(s, line_buffer + length,
				  buffer_length - length - 1, handle);
	    CTRACE((tfp, "HTTP: Read %d\n", status));
	    if (status <= 0) {
		/*
		 * Retry if we get nothing back too.
		 * Bomb out if we get nothing twice.
		 */
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp, "HTTP: Interrupted initial read.\n"));
		    _HTProgress(CONNECTION_INTERRUPTED);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;
		} else if (status < 0 &&
			   (SOCKET_ERRNO == ENOTCONN ||
#ifdef _WINDOWS			/* 1997/11/09 (Sun) 16:59:58 */
			    SOCKET_ERRNO == ETIMEDOUT ||
#endif
			    SOCKET_ERRNO == ECONNRESET ||
			    SOCKET_ERRNO == EPIPE) &&
			   !already_retrying && !do_post) {
		    /*
		     * Arrrrgh, HTTP 0/1 compability problem, maybe.
		     */
		    CTRACE((tfp,
			    "HTTP: BONZO Trying again with HTTP0 request.\n"));
		    HTTP_NETCLOSE(s, handle);
		    FREE(line_buffer);
		    FREE(line_kept_clean);

		    extensions = NO;
		    already_retrying = TRUE;
		    _HTProgress(RETRYING_AS_HTTP0);
		    goto try_again;
		} else {
		    CTRACE((tfp,
			    "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			    status));
		    HTAlert(gettext("Unexpected network read error; connection aborted."));
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
	    }
#ifdef    NOT_ASCII		/* S/390 -- gil -- 0564 */
	    {
		char *p2;

		for (p2 = line_buffer + length;
		     p2 < line_buffer + length + status;
		     p2++)
		    *p2 = FROMASCII(*p2);
	    }
#endif /* NOT_ASCII */

	    bytes_already_read += status;
	    HTReadProgress(bytes_already_read, 0);

#ifdef UCX			/* UCX returns -1 on EOF */
	    if (status == 0 || status == -1)
#else
	    if (status == 0)
#endif
	    {
		end_of_file = YES;
		break;
	    }
	    line_buffer[length + status] = 0;

	    if (line_buffer) {
		FREE(line_kept_clean);
		line_kept_clean = (char *) malloc(buffer_length * sizeof(char));

		if (line_kept_clean == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
		memcpy(line_kept_clean, line_buffer, buffer_length);
		real_length_of_line = length + status;
	    }

	    eol = strchr(line_buffer + length, LF);
	    /* Do we *really* want to do this? */
	    if (eol && eol != line_buffer && *(eol - 1) == CR)
		*(eol - 1) = ' ';

	    length = length + status;

	    /* Do we really want to do *this*? */
	    if (eol)
		*eol = 0;	/* Terminate the line */
	}
	/* All we need is the first line of the response.  If it's a HTTP/1.0
	 * response, then the first line will be absurdly short and therefore
	 * we can safely gate the number of bytes read through this code (as
	 * opposed to below) to ~1000.
	 *
	 * Well, let's try 100.
	 */
	while (!eol && !end_of_file && bytes_already_read < 100);
    }				/* Scope of loop variables */

    /* save total length, in case we decide later to show it all - kw */
    rawlength = length;

    /*    We now have a terminated unfolded line.  Parse it.
     * --------------------------------------------------
     */
    CTRACE((tfp, "HTTP: Rx: %s\n", line_buffer));

    /*
     * Kludge to work with old buggy servers and the VMS Help gateway.  They
     * can't handle the third word, so we try again without it.
     */
    if (extensions &&		/* Old buggy server or Help gateway? */
	(0 == strncmp(line_buffer, "<TITLE>Bad File Request</TITLE>", 31) ||
	 0 == strncmp(line_buffer, "Address should begin with", 25) ||
	 0 == strncmp(line_buffer, "<TITLE>Help ", 12) ||
	 0 == strcmp(line_buffer,
		     "Document address invalid or access not authorised"))) {
	FREE(line_buffer);
	FREE(line_kept_clean);
	extensions = NO;
	already_retrying = TRUE;
	CTRACE((tfp, "HTTP: close socket %d to retry with HTTP0\n", s));
	HTTP_NETCLOSE(s, handle);
	/* print a progress message */
	_HTProgress(RETRYING_AS_HTTP0);
	goto try_again;
    } {
	int fields;
	char server_version[VERSION_LENGTH + 1];

	server_version[0] = 0;

	fields = sscanf(line_buffer, "%20s %d",
			server_version,
			&server_status);

	CTRACE((tfp, "HTTP: Scanned %d fields from line_buffer\n", fields));

	if (http_error_file) {	/* Make the status code externally available */
	    FILE *error_file;

#ifdef SERVER_STATUS_ONLY
	    error_file = fopen(http_error_file, TXT_W);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "error=%d\n", server_status);
		fclose(error_file);
	    }
#else
	    error_file = fopen(http_error_file, TXT_A);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "   URL=%s (%s)\n", url, METHOD);
		fprintf(error_file, "STATUS=%s\n", line_buffer);
		fclose(error_file);
	    }
#endif /* SERVER_STATUS_ONLY */
	}

	/*
	 * Rule out a non-HTTP/1.n reply as best we can.
	 */
	if (fields < 2 || !server_version[0] || server_version[0] != 'H' ||
	    server_version[1] != 'T' || server_version[2] != 'T' ||
	    server_version[3] != 'P' || server_version[4] != '/' ||
	    server_version[6] != '.') {
	    /*
	     * Ugh!  An HTTP0 reply,
	     */
	    HTAtom *encoding;

	    CTRACE((tfp, "--- Talking HTTP0.\n"));

	    format_in = HTFileFormat(url, &encoding, NULL);
	    /*
	     * Treat all plain text as HTML.  This sucks but its the only
	     * solution without without looking at content.
	     */
	    if (!strncmp(HTAtom_name(format_in), "text/plain", 10)) {
		CTRACE((tfp, "HTTP: format_in being changed to text/HTML\n"));
		format_in = WWW_HTML;
	    }
	    if (!IsUnityEnc(encoding)) {
		/*
		 * Change the format to that for "www/compressed".
		 */
		CTRACE((tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in)));
		StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
		StrAllocCopy(anAnchor->content_encoding, HTAtom_name(encoding));
		format_in = HTAtom_for("www/compressed");
		CTRACE((tfp, "        Treating as '%s' with encoding '%s'\n",
			"www/compressed", HTAtom_name(encoding)));
	    }

	    start_of_data = line_kept_clean;
	} else {
	    /*
	     * Set up to decode full HTTP/1.n response.  - FM
	     */
	    format_in = HTAtom_for("www/mime");
	    CTRACE((tfp, "--- Talking HTTP1.\n"));

	    /*
	     * We set start_of_data to "" when !eol here because there will be
	     * a put_block done below; we do *not* use the value of
	     * start_of_data (as a pointer) in the computation of length (or
	     * anything else) when !eol.  Otherwise, set the value of length to
	     * what we have beyond eol (i.e., beyond the status line).  - FM
	     */
	    start_of_data = eol ? eol + 1 : empty;
	    length = eol ? length - (start_of_data - line_buffer) : 0;

	    /*
	     * Trim trailing spaces in line_buffer so that we can use it in
	     * messages which include the status line.  - FM
	     */
	    while (line_buffer[strlen(line_buffer) - 1] == ' ')
		line_buffer[strlen(line_buffer) - 1] = '\0';

	    /*
	     * Take appropriate actions based on the status.  - FM
	     */
	    switch (server_status / 100) {
	    case 1:
		/*
		 * HTTP/1.1 Informational statuses.
		 * 100 Continue.
		 * 101 Switching Protocols.
		 * > 101 is unknown.
		 * We should never get these, and they have only the status
		 * line and possibly other headers, so we'll deal with them by
		 * showing the full header to the user as text/plain.  - FM
		 */
		HTAlert(gettext("Got unexpected Informational Status."));
		do_head = TRUE;
		break;

	    case 2:
		/*
		 * Good:  Got MIME object!  (Successful) - FM
		 */
		if (do_head) {
		    /*
		     * If HEAD was requested, show headers (and possibly bogus
		     * body) for all 2xx status codes as text/plain - KW
		     */
		    HTProgress(line_buffer);
		    break;
		}
		switch (server_status) {
		case 204:
		    /*
		     * No Content.
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    HTNoDataOK = 1;
		    status = HT_NO_DATA;
		    goto clean_up;

		case 205:
		    /*
		     * Reset Content.  The server has fulfilled the request but
		     * nothing is returned and we should reset any form
		     * content.  We'll instruct the user to do that, and
		     * restore the current document.  - FM
		     */
		    HTAlert(gettext("Request fulfilled.  Reset Content."));
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;

		case 206:
		    /*
		     * Partial Content.  We didn't send a Range so something
		     * went wrong somewhere.  Show the status message and
		     * restore the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;

		default:
		    /*
		     * 200 OK.
		     * 201 Created.
		     * 202 Accepted.
		     * 203 Non-Authoritative Information.
		     * > 206 is unknown.
		     * All should return something to display.
		     */
#if defined(USE_SSL) && !defined(DISABLE_NEWS)
		    if (do_connect) {
			CTRACE((tfp,
				"HTTP: Proxy tunnel to '%s' established.\n",
				connect_host));
			do_connect = FALSE;
			url = connect_url;
			FREE(line_buffer);
			FREE(line_kept_clean);
			if (!strncmp(connect_url, "snews", 5)) {
			    CTRACE((tfp,
				    "      Will attempt handshake and snews connection.\n"));
			    status = HTNewsProxyConnect(s, url, anAnchor,
							format_out, sink);
			    goto done;
			}
			did_connect = TRUE;
			already_retrying = TRUE;
			eol = 0;
			bytes_already_read = 0;
			had_header = NO;
			length = 0;
			doing_redirect = FALSE;
			permanent_redirection = FALSE;
			target = NULL;
			CTRACE((tfp,
				"      Will attempt handshake and resubmit headers.\n"));
			goto use_tunnel;
		    }
#endif /* USE_SSL */
		    HTProgress(line_buffer);
		}		/* case 2 switch */
		break;

	    case 3:
		/*
		 * Various forms of Redirection.  - FM
		 * 300 Multiple Choices.
		 * 301 Moved Permanently.
		 * 302 Found (temporary; we can, and do, use GET).
		 * 303 See Other (temporary; always use GET).
		 * 304 Not Modified.
		 * 305 Use Proxy.
		 * 306 Set Proxy.
		 * 307 Temporary Redirect with method retained.
		 * > 308 is unknown.
		 */
		if (no_url_redirection || do_head || keep_mime_headers) {
		    /*
		     * If any of these flags are set, we do not redirect, but
		     * instead show what was returned to the user as
		     * text/plain.  - FM
		     */
		    HTProgress(line_buffer);
		    break;
		}

		if (server_status == 300) {	/* Multiple Choices */
		    /*
		     * For client driven content negotiation.  The server
		     * should be sending some way for the user-agent to make a
		     * selection, so we'll show the user whatever the server
		     * returns.  There might be a Location:  header with the
		     * server's preference present, but the choice should be up
		     * to the user, someday based on an Alternates:  header,
		     * and a body always should be present with descriptions
		     * and links for the choices (i.e., we use the latter, for
		     * now).  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}

		if (server_status == 304) {	/* Not Modified */
		    /*
		     * We didn't send an "If-Modified-Since" header, so this
		     * status is inappropriate.  We'll deal with it by showing
		     * the full header to the user as text/plain.  - FM
		     */
		    HTAlert(gettext("Got unexpected 304 Not Modified status."));
		    do_head = TRUE;
		    break;
		}

		if (server_status == 305 ||
		    server_status == 306 ||
		    server_status > 307) {
		    /*
		     * Show user the content, if any, for 305, 306, or unknown
		     * status.  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}

		/*
		 * We do not load the file, but read the headers for the
		 * "Location:", check out that redirecting_url and if it's
		 * acceptible (e.g., not a telnet URL when we have that
		 * disabled), initiate a new fetch.  If that's another
		 * redirecting_url, we'll repeat the checks, and fetch
		 * initiations if acceptible, until we reach the actual URL, or
		 * the redirection limit set in HTAccess.c is exceeded.  If the
		 * status was 301 indicating that the relocation is permanent,
		 * we set the permanent_redirection flag to make it permanent
		 * for the current anchor tree (i.e., will persist until the
		 * tree is freed or the client exits).  If the redirection
		 * would include POST content, we seek confirmation from an
		 * interactive user, with option to use 303 for 301 (but not
		 * for 307), and otherwise refuse the redirection.  We also
		 * don't allow permanent redirection if we keep POST content. 
		 * If we don't find the Location header or it's value is
		 * zero-length, we display whatever the server returned, and
		 * the user should RELOAD that to try again, or make a
		 * selection from it if it contains links, or Left-Arrow to the
		 * previous document.  - FM
		 */
		{
		    if ((dump_output_immediately || traversal) &&
			do_post &&
			server_status != 303 &&
			server_status != 302 &&
			server_status != 301) {
			/*
			 * Don't redirect POST content without approval from an
			 * interactive user.  - FM
			 */
			HTTP_NETCLOSE(s, handle);
			status = -1;
			HTAlert(gettext("Redirection of POST content requires user approval."));
			if (traversal)
			    HTProgress(line_buffer);
			goto clean_up;
		    }

		    HTProgress(line_buffer);
		    if (server_status == 301) {		/* Moved Permanently */
			if (do_post) {
			    /*
			     * Don't make the redirection permanent if we have
			     * POST content.  - FM
			     */
			    CTRACE((tfp,
				    "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n"));
			    HTAlert(gettext("Have POST content.  Treating Permanent Redirection as Temporary.\n"));
			} else {
			    permanent_redirection = TRUE;
			}
		    }
		    doing_redirect = TRUE;

		    break;
		}

	    case 4:
		/*
		 * "I think I goofed!" (Client Error) - FM
		 */
		switch (server_status) {
		case 401:	/* Unauthorized */
		    /*
		     * Authorization for orgin server required.  If show_401 is
		     * set, proceed to showing the 401 body.  Otherwise, if we
		     * can set up authorization based on the WWW-Authenticate
		     * header, and the user provides a username and password,
		     * try again.  Otherwise, check whether to show the 401
		     * body or restore the current document.  - FM
		     */
		    if (show_401)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, NO)) {

			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !authentication_info[0]) {
			    fprintf(stderr,
				    "HTTP: Access authorization required.\n");
			    fprintf(stderr,
				    "       Use the -auth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}

			CTRACE((tfp, "%s %d %s\n",
				"HTTP: close socket", s,
				"to retry with Access Authorization"));

			_HTProgress(gettext("Retrying with access authorization information."));
			FREE(line_buffer);
			FREE(line_kept_clean);
#ifdef USE_SSL
			if (using_proxy && !strncmp(url, "https://", 8)) {
			    url = arg;
			    do_connect = TRUE;
			    did_connect = FALSE;
			}
#endif /* USE_SSL */
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 401 message body?"))) {
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_AUTH);
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }

		case 407:
		    /*
		     * Authorization for proxy server required.  If we are not
		     * in fact using a proxy, or show_407 is set, proceed to
		     * showing the 407 body.  Otherwise, if we can set up
		     * authorization based on the Proxy-Authenticate header,
		     * and the user provides a username and password, try
		     * again.  Otherwise, check whether to show the 401 body or
		     * restore the current document.  - FM & AJL
		     */
		    if (!using_proxy || show_407)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, YES)) {

			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !proxyauth_info[0]) {
			    fprintf(stderr,
				    "HTTP: Proxy authorization required.\n");
			    fprintf(stderr,
				    "       Use the -pauth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}

			CTRACE((tfp, "%s %d %s\n",
				"HTTP: close socket", s,
				"to retry with Proxy Authorization"));

			_HTProgress(HTTP_RETRY_WITH_PROXY);
			FREE(line_buffer);
			FREE(line_kept_clean);
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 407 message body?"))) {
			if (!dump_output_immediately &&
			    format_out == HTAtom_for("www/download")) {
			    /*
			     * Convert a download request to a presentation
			     * request for interactive users.  - FM
			     */
			    format_out = WWW_PRESENT;
			}
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_PROXY);
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }

		case 408:
		    /*
		     * Request Timeout.  Show the status message and restore
		     * the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto done;

		default:
		    /*
		     * 400 Bad Request.
		     * 402 Payment Required.
		     * 403 Forbidden.
		     * 404 Not Found.
		     * 405 Method Not Allowed.
		     * 406 Not Acceptable.
		     * 409 Conflict.
		     * 410 Gone.
		     * 411 Length Required.
		     * 412 Precondition Failed.
		     * 413 Request Entity Too Large.
		     * 414 Request-URI Too Long.
		     * 415 Unsupported Media Type.
		     * 416 List Response (for content negotiation).
		     * > 416 is unknown.
		     * Show the status message, and display the returned text
		     * if we are not doing a traversal.  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}		/* case 4 switch */
		break;

	    case 5:
		/*
		 * "I think YOU goofed!" (server error)
		 * 500 Internal Server Error
		 * 501 Not Implemented
		 * 502 Bad Gateway
		 * 503 Service Unavailable
		 * 504 Gateway Timeout
		 * 505 HTTP Version Not Supported
		 * > 505 is unknown.
		 * Should always include a message, which we always should
		 * display.  - FM
		 */
		HTAlert(line_buffer);
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
		    /*
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
		     */
		    format_out = WWW_PRESENT;
		}
		break;

	    default:
		/*
		 * Bad or unknown server_status number.  Take a chance and hope
		 * there is something to display.  - FM
		 */
		HTAlert(gettext("Unknown status reply from server!"));
		HTAlert(line_buffer);
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
		    /*
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
		     */
		    format_out = WWW_PRESENT;
		}
		break;
	    }			/* Switch on server_status/100 */

	}			/* Full HTTP reply */
    }				/* scope of fields */

    /*
     * The user may have pressed the 'z'ap key during the pause caused by one
     * of the HTAlerts above if the server reported an error, to skip loading
     * of the error response page.  Checking here before setting up the stream
     * stack and feeding it data avoids doing unnecessary work, it also can
     * avoid unnecessarily pushing a loaded document out of the cache to make
     * room for the unwanted error page.  - kw
     */
    if (HTCheckForInterrupt()) {
	HTTP_NETCLOSE(s, handle);
	if (doing_redirect) {
	    /*
	     * Impatient user.  - FM
	     */
	    CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	}
	status = HT_INTERRUPTED;
	goto clean_up;
    }
    /*
     * Set up the stream stack to handle the body of the message.
     */
    if (do_head || keep_mime_headers) {
	/*
	 * It was a HEAD request, or we want the headers and source.
	 */
	start_of_data = line_kept_clean;
#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
/* GIF file contains \0, so strlen does not return the data length */
	length = real_length_of_line;
#else
	length = rawlength;
#endif
	format_in = HTAtom_for("text/plain");

    } else if (doing_redirect) {

	format_in = HTAtom_for("message/x-http-redirection");
	StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
	if (traversal) {
	    format_out = WWW_DEBUG;
	    if (!sink)
		sink = HTErrorStream();
	} else if (!dump_output_immediately &&
		   format_out == HTAtom_for("www/download")) {
	    /*
	     * Convert a download request to a presentation request for
	     * interactive users.  - FM
	     */
	    format_out = WWW_PRESENT;
	}
    }

    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);

    if (target == NULL) {
	char *buffer = NULL;

	HTTP_NETCLOSE(s, handle);
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	_HTProgress(buffer);
	FREE(buffer);
	status = -1;
	goto clean_up;
    }

    /*
     * Recycle the first chunk of data, in all cases.
     */
    (*target->isa->put_block) (target, start_of_data, length);

    /*
     * Go pull the bulk of the data down.
     */
    rv = HTCopy(anAnchor, s, (void *) handle, target);

    /*
     * If we get here with doing_redirect set, it means that we were looking
     * for a Location header.  We either have got it now in redirecting_url -
     * in that case the stream should not have loaded any data.  Or we didn't
     * get it, in that case the stream may have presented the message body
     * normally.  - kw
     */

    if (rv == -1) {
	/*
	 * Intentional interrupt before data were received, not an error
	 */
/* (*target->isa->_abort)(target, NULL); *//* already done in HTCopy */
	if (doing_redirect && traversal)
	    status = -1;
	else
	    status = HT_INTERRUPTED;
	HTTP_NETCLOSE(s, handle);
	goto clean_up;
    }

    if (rv == -2) {
	/*
	 * Aw hell, a REAL error, maybe cuz it's a dumb HTTP0 server
	 */
	(*target->isa->_abort) (target, NULL);
	if (doing_redirect && redirecting_url) {
	    /*
	     * Got a location before the error occurred?  Then consider it an
	     * interrupt but proceed below as normal.  - kw
	     */
	    /* do nothing here */
	} else {
	    HTTP_NETCLOSE(s, handle);
	    if (!doing_redirect && !already_retrying && !do_post) {
		CTRACE((tfp, "HTTP: Trying again with HTTP0 request.\n"));
		/*
		 * May as well consider it an interrupt -- right?
		 */
		FREE(line_buffer);
		FREE(line_kept_clean);
		extensions = NO;
		already_retrying = TRUE;
		_HTProgress(RETRYING_AS_HTTP0);
		goto try_again;
	    } else {
		status = HT_NOT_LOADED;
		goto clean_up;
	    }
	}
    }

    /*
     * Free if complete transmission (socket was closed before return).  Close
     * socket if partial transmission (was freed on abort).
     */
    if (rv != HT_INTERRUPTED && rv != -2) {
	(*target->isa->_free) (target);
    } else {
	HTTP_NETCLOSE(s, handle);
    }

    if (doing_redirect) {
	if (redirecting_url) {
	    /*
	     * Set up for checking redirecting_url in LYGetFile.c for
	     * restrictions before we seek the document at that Location.  - FM
	     */
	    CTRACE((tfp, "HTTP: Picked up location '%s'\n",
		    redirecting_url));
	    if (rv == HT_INTERRUPTED) {
		/*
		 * Intentional interrupt after data were received, not an error
		 * (probably).  We take it as a user request to abandon the
		 * redirection chain.
		 *
		 * This could reasonably be changed (by just removing this
		 * block), it would make sense if there are redirecting
		 * resources that "hang" after sending the headers.  - kw
		 */
		FREE(redirecting_url);
		CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
		status = HT_INTERRUPTED;
		goto clean_up;
	    }
	    HTProgress(line_buffer);
	    if (server_status == 305) {		/* Use Proxy */
		/*
		 * Make sure the proxy field ends with a slash.  - FM
		 */
		if (redirecting_url[strlen(redirecting_url) - 1]
		    != '/')
		    StrAllocCat(redirecting_url, "/");
		/*
		 * Append our URL.  - FM
		 */
		StrAllocCat(redirecting_url, anAnchor->address);
		CTRACE((tfp, "HTTP: Proxy URL is '%s'\n",
			redirecting_url));
	    }
	    if (!do_post ||
		server_status == 303 ||
		server_status == 302) {
		/*
		 * We don't have POST content (nor support PUT or DELETE), or
		 * the status is "See Other" or "General Redirection" and we
		 * can convert to GET, so go back and check out the new URL.  -
		 * FM
		 */
		status = HT_REDIRECTING;
		goto clean_up;
	    }
	    /*
	     * Make sure the user wants to redirect the POST content, or treat
	     * as GET - FM & DK
	     */
	    switch (HTConfirmPostRedirect(redirecting_url,
					  server_status)) {
		/*
		 * User failed to confirm.  Abort the fetch.
		 */
	    case 0:
		doing_redirect = FALSE;
		FREE(redirecting_url);
		status = HT_NO_DATA;
		goto clean_up;

		/*
		 * User wants to treat as GET with no content.  Go back to
		 * check out the URL.
		 */
	    case 303:
		break;

		/*
		 * Set the flag to retain the POST content and go back to check
		 * out the URL.  - FM
		 */
	    default:
		redirect_post_content = TRUE;
	    }

	    /* Lou's old comment:  - FM */
	    /* OK, now we've got the redirection URL temporarily stored
	       in external variable redirecting_url, exported from HTMIME.c,
	       since there's no straightforward way to do this in the library
	       currently.  Do the right thing. */

	    status = HT_REDIRECTING;

	} else {
	    status = traversal ? -1 : HT_LOADED;
	}

    } else {
	/*
	 * If any data were received, treat as a complete transmission
	 */
	status = HT_LOADED;
    }

    /*
     * Clean up
     */
  clean_up:
    FREE(line_buffer);
    FREE(line_kept_clean);

  done:
    /*
     * Clear out on exit, just in case.
     */
    do_head = FALSE;
    do_post = FALSE;
    reloading = FALSE;
#ifdef USE_SSL
    do_connect = FALSE;
    did_connect = FALSE;
    FREE(connect_host);
    if (handle) {
	SSL_free(handle);
	SSL_handle = handle = NULL;
    }
#endif /* USE_SSL */
    return status;
}

/*	Protocol descriptor
*/
#ifdef GLOBALDEF_IS_MACRO
#define _HTTP_C_GLOBALDEF_1_INIT { "http", HTLoadHTTP, 0}
GLOBALDEF(HTProtocol, HTTP, _HTTP_C_GLOBALDEF_1_INIT);
#define _HTTP_C_GLOBALDEF_2_INIT { "https", HTLoadHTTP, 0}
GLOBALDEF(HTProtocol, HTTPS, _HTTP_C_GLOBALDEF_2_INIT);
#else
GLOBALDEF HTProtocol HTTP =
{"http", HTLoadHTTP, 0};
GLOBALDEF HTProtocol HTTPS =
{"https", HTLoadHTTP, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.9
log
@automatic merge
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTTP.c,v 1.8 2004/10/11 20:30:35 tg Exp $ */
d59 1
a59 1
int ssl_okay;
d362 1
a362 1
static BOOL acceptEncoding (int code)
d365 1
d368 1
d416 1
d429 1
a429 1
    char *METHOD;
d882 1
a882 1
	    char *cp = LYRequestReferer;
d888 2
a889 1
		char *cp1 = trimPoundSelector(cp);
d891 1
a891 2
		BStrCat0(command, cp + LEN_LYNXIMGMAP);
		restorePoundSelector(cp1);
d1408 1
a1408 1
	    start_of_data = eol ? eol + 1 : "";
@


1.8
log
@automatic merge; regen configure
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTTP.c,v 1.7 2004/07/21 17:06:15 tg Stab $ */
d358 34
d784 1
a784 1
		if ((j & LYAcceptEncoding) != 0) {
@


1.7
log
@developed just now, between end of RCS and start of CVS mergers,
by yours truly: SSL Certificate CN wildcard matching! :-)

will be submitted upstream
@
text
@d1 1
a1 1
/* $MirBSD$ */
a50 3
extern char *HTAppName;		/* Application name: please supply */
extern char *HTAppVersion;	/* Application version: please supply */

d347 1
a347 1
	    CTRACE((tfp, "FIXME:%s\n", fake));
d1900 1
a1900 1
    if (!target || target == NULL) {
@


1.6
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d1 1
a1 19
/* $MirBSD: HTTP.c,v 1.5 2003/07/07 20:54:30 tg Exp $
 *-
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
 *
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicense it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extend permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
 *-
 * These are patches to the Lynx web browser, which is licensed under
 * the GNU General Public License, Version 2.
 */
d4 6
a9 6
**	==========================
** Modified:
** 27 Jan 1994	PDM  Added Ari Luotonen's Fix for Reload when using proxy
**		     servers.
** 28 Apr 1997	AJL,FM Do Proxy Authorisation.
*/
d44 1
d47 2
a48 3
struct _HTStream
{
  HTStreamClass * isa;
d51 2
a52 2
extern char * HTAppName;	/* Application name: please supply */
extern char * HTAppVersion;	/* Application version: please supply */
d54 4
a57 4
PUBLIC BOOL reloading = FALSE;	/* Reloading => send no-cache pragma to proxy */
PUBLIC char * redirecting_url = NULL;	    /* Location: value. */
PUBLIC BOOL permanent_redirection = FALSE;  /* Got 301 status? */
PUBLIC BOOL redirect_post_content = FALSE;  /* Don't convert to GET? */
d60 3
a62 3
PUBLIC SSL_CTX * ssl_ctx = NULL;	/* SSL ctx */
PUBLIC SSL * SSL_handle = NULL;
PUBLIC int ssl_okay;
d64 1
a64 1
PRIVATE void free_ssl_ctx NOARGS
d70 1
a70 1
PRIVATE int HTSSLCallback(int preverify_ok, X509_STORE_CTX *x509_ctx)
d90 1
a90 1
PUBLIC SSL * HTGetSSLHandle NOARGS
d94 1
a94 1
	 *  First time only.
d109 1
a109 1
    return(SSL_new(ssl_ctx));
d112 1
a112 1
PUBLIC void HTSSLInitPRNG NOARGS
d119 1
a119 1
	long l,seed;
d124 2
a125 2
	CTRACE((tfp,"HTTP: Seeding PRNG\n"));
	if(rand_file != NULL) {
d130 1
a130 1
	RAND_seed((unsigned char *)&t, sizeof(time_t));
d132 1
a132 1
	RAND_seed((unsigned char *)&pid, sizeof(pid));
d134 2
a135 1
	RAND_bytes((unsigned char *)&seed, sizeof(long));
d140 1
a140 1
	    RAND_seed((unsigned char *)&l, sizeof(long));
d164 1
a164 1
#ifdef _WINDOWS		/* 1997/11/06 (Thu) 13:00:08 */
d170 3
a172 3
	int fd;
	char *buf;
	int len;
d175 2
a176 5
PUBLIC int ws_read_per_sec = 0;
PRIVATE int ws_errno = 0;

PRIVATE DWORD g_total_times = 0;
PRIVATE DWORD g_total_bytes = 0;
d178 2
d181 1
a181 1
PUBLIC char * str_speed(void)
d187 1
a187 1
			(ws_read_per_sec % 1000) );
d197 1
a197 1
PRIVATE int ws_read(int fd, char *buf, int len)
d199 2
a200 2
     int res;
     int retry = 3;
d202 1
a202 1
     do {
d205 3
a207 3
	  Sleep(100);
	  if (retry-- > 0)
	    continue;
d209 1
a209 1
     } while (res == SOCKET_ERROR && SOCKET_ERRNO == EINTR);
d211 1
a211 1
     return res;
d214 1
a214 1
PRIVATE void _thread_func (void *p)
d217 1
a217 1
    recv_data_t *q = (recv_data_t *)p;
d227 1
d237 1
a237 1
    ExitThread((DWORD)ret);
d243 1
a243 1
PUBLIC int ws_netread(int fd, char *buf, int len)
d248 1
a248 1
     /* 1998/03/30 (Mon) 09:01:21 */
d257 1
a257 1
    extern int lynx_timeout;			/* LYMain.c */
d272 3
a274 3
    hThread = CreateThread((void *)NULL, STACK_SIZE,
		 (LPTHREAD_START_ROUTINE)_thread_func,
		 (void *)&para, 0UL, &dwThreadID);
d283 1
a283 1
	val = WaitForSingleObject(hThread, 1000/TICK);
d291 1
a291 1
	    if (i/TICK > (AlertSecs + 2)) {
d293 1
a293 1
			i/TICK, (i%TICK) * 10 / TICK, len);
d296 1
a296 1
	    if (win32_check_interrupt() || ((i/TICK) > lynx_timeout)) {
d321 1
a321 1
		ws_read_per_sec = g_total_bytes / (g_total_times/1000);
d328 1
a328 1
    }	/* end while(1) */
d330 1
a330 1
    read_exit:
a337 1
 * If the
d339 1
a339 2
PRIVATE void strip_userid ARGS1(
	char *,		host)
d362 20
a381 21
**		==============================
**
**	Given a hypertext address, this routine loads a document.
**
**
**  On entry,
**	arg	is the hypertext reference of the article to be loaded.
**
**  On exit,
**	returns >=0	If no error, a good socket number
**		<0	Error.
**
**	The socket must be closed by the caller after the document has been
**	read.
**
*/
PRIVATE int HTLoadHTTP ARGS4 (
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d383 30
a412 30
  int s;			/* Socket number for returned data */
  CONST char *url = arg;	/* The URL which get_physical() returned */
  bstring *command = NULL;	/* The whole command */
  char *eol;			/* End of line if found */
  char *start_of_data;		/* Start of body of reply */
  int status;			/* tcp return */
  int bytes_already_read;
  char crlf[3];			/* A CR LF equivalent string */
  HTStream *target;		/* Unconverted data */
  HTFormat format_in;		/* Format arriving in the message */
  BOOL do_head = FALSE;		/* Whether or not we should do a head */
  BOOL do_post = FALSE;		/* ARE WE posting ? */
  char *METHOD;

  BOOL had_header;		/* Have we had at least one header? */
  char *line_buffer;
  char *line_kept_clean;
  int real_length_of_line;
  BOOL extensions;		/* Assume good HTTP server */
  char *linebuf = NULL;
  char temp[80];
  BOOL first_Accept = TRUE;
  BOOL show_401 = FALSE;
  BOOL show_407 = FALSE;
  BOOL auth_proxy = NO;		/* Generate a proxy authorization. - AJL */

  int length, rawlength, rv;
  int server_status;
  BOOL doing_redirect, already_retrying = FALSE;
  int len = 0;
d415 11
a425 10
  BOOL do_connect = FALSE;	/* ARE WE going to use a proxy tunnel ? */
  BOOL did_connect = FALSE;	/* ARE WE actually using a proxy tunnel ? */
  CONST char *connect_url = NULL; /* The URL being proxied */
  char *connect_host = NULL;	/* The host being proxied */
  SSL * handle = NULL;		/* The SSL handle */
  char ssl_dn[256];
  char *cert_host;
  char *ssl_host;
  char *p;
  char *msg = NULL;
d427 1
a427 1
  BOOL try_tls = TRUE;
d429 1
a429 1
  SSL_handle = NULL;
d431 1
a431 1
  void * handle = NULL;
d434 15
a448 16
  if (anAnchor->isHEAD)
      do_head = TRUE;
  else if (anAnchor->post_data)
      do_post = TRUE;

  if (!url) {
      status = -3;
      _HTProgress (BAD_REQUEST);
      goto done;
  }
  if (!*url) {
      status = -2;
      _HTProgress (BAD_REQUEST);
      goto done;
  }

d450 21
a470 21
  if (using_proxy && !strncmp(url, "http://", 7)) {
      if ((connect_url = strstr((url+7), "https://"))) {
	  do_connect = TRUE;
	  connect_host = HTParse(connect_url, "https", PARSE_HOST);
	  if (!strchr(connect_host, ':')) {
	      sprintf(temp, ":%d", HTTPS_PORT);
	      StrAllocCat(connect_host, temp);
	  }
	  CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	  CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
      } else if ((connect_url = strstr((url+7), "snews://"))) {
	  do_connect = TRUE;
	  connect_host = HTParse(connect_url, "snews", PARSE_HOST);
	  if (!strchr(connect_host, ':')) {
	      sprintf(temp, ":%d", SNEWS_PORT);
	      StrAllocCat(connect_host, temp);
	  }
	  CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	  CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
      }
  }
d473 6
a478 1
  sprintf(crlf, "%c%c", CR, LF);
d480 14
a493 19
  /*
  **  At this point, we're talking HTTP/1.0.
  */
  extensions = YES;

try_again:
  /*
  **  All initializations are moved down here from up above,
  **  so we can start over here...
  */
  eol = 0;
  had_header = NO;
  length = 0;
  doing_redirect = FALSE;
  permanent_redirection = FALSE;
  redirect_post_content = FALSE;
  target = NULL;
  line_buffer = NULL;
  line_kept_clean = NULL;
d496 4
a499 4
  if (!strncmp(url, "https", 5))
    status = HTDoConnect (url, "HTTPS", HTTPS_PORT, &s);
  else
    status = HTDoConnect (url, "HTTP", HTTP_PORT, &s);
d501 4
a504 5
  if (!strncmp(url, "https", 5))
    {
      HTAlert(gettext("This client does not contain support for HTTPS URLs."));
      status = HT_NOT_LOADED;
      goto done;
d506 1
a506 1
  status = HTDoConnect (arg, "HTTP", HTTP_PORT, &s);
d508 10
a517 10
  if (status == HT_INTERRUPTED) {
      /*
      **  Interrupt cleanly.
      */
       CTRACE((tfp, "HTTP: Interrupted on connect; recovering cleanly.\n"));
       _HTProgress (CONNECTION_INTERRUPTED);
       status = HT_NOT_LOADED;
       goto done;
   }
   if (status < 0) {
d519 3
a521 3
      CTRACE((tfp, "HTTP: Unable to connect to remote host for `%s'\n"
			  " (status = %d, sock_errno = %d).\n",
			  url, status, SOCKET_ERRNO));
d523 3
a525 3
      CTRACE((tfp,
	    "HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
	    url, SOCKET_ERRNO));
d527 4
a530 10
      HTAlert(gettext("Unable to connect to remote host."));
      status = HT_NOT_LOADED;
      goto done;
  }

/* *sob*  All this needs to be converted to handle binary strings
 * if we're going to be able to handle binary form uploads...
 * This is a nice long function as well.  *sigh*  -RJP
 */

d532 7
a538 8
use_tunnel:
  /*
  ** If this is an https document
  ** then do the SSL stuff here
  */
  if (did_connect || !strncmp(url, "https", 5)) {
      SSL_handle = handle = HTGetSSLHandle();
      SSL_set_fd(handle, s);
d540 2
a541 2
      if (!try_tls)
	  handle->options|=SSL_OP_NO_TLSv1;
d543 2
a544 2
      HTSSLInitPRNG();
      status = SSL_connect(handle);
d546 1
a546 1
      if (status <= 0) {
d548 22
a569 21
	  if (try_tls) {
	      _HTProgress(gettext("Retrying connection without TLS."));
	      try_tls = FALSE;
	      if (did_connect)
		  HTTP_NETCLOSE(s, handle);
	      goto try_again;
	  } else {
	      unsigned long SSLerror;
	      CTRACE((tfp,
"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
	      SSL_load_error_strings();
	      while((SSLerror=ERR_get_error())!=0) {
		  CTRACE((tfp,"HTTP: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	      }
	      HTAlert("Unable to make secure connection to remote host.");
	      if (did_connect)
		  HTTP_NETCLOSE(s, handle);
	      status = HT_NOT_LOADED;
	      goto done;
	  }
d571 14
a584 13
	  unsigned long SSLerror;
	  CTRACE((tfp,
"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
	  SSL_load_error_strings();
	  while((SSLerror=ERR_get_error())!=0) {
	      CTRACE((tfp,"HTTP: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	  }
	  HTAlert("Unable to make secure connection to remote host.");
	  if (did_connect)
	      HTTP_NETCLOSE(s, handle);
	  status = HT_NOT_LOADED;
	  goto done;
d586 33
a618 1
      }
d620 8
a627 40
      X509_NAME_oneline(X509_get_subject_name(SSL_get_peer_certificate(handle)),
		        ssl_dn, sizeof(ssl_dn));
      if ((cert_host = strstr(ssl_dn, "/CN=")) == NULL) {
	  HTSprintf0(&msg,
		     gettext("SSL error:Can't find common name in certificate-Continue?"));
	   if (! HTForcedPrompt(ssl_noprompt, msg, YES)) {
	      status = HT_NOT_LOADED;
	      FREE(msg);
	      goto done;
	  }
      } else {
	  cert_host += 4;
	  if ((p = strchr(cert_host, '/')) != NULL)
	      *p = '\0';
	  if ((p = strchr(cert_host, ':')) != NULL)
	      *p = '\0';
	  ssl_host = HTParse(url, "", PARSE_HOST);
	  if ((p = strchr(ssl_host, ':')) != NULL)
	      *p = '\0';
	  if (strcasecmp(ssl_host, cert_host)) {
	      HTSprintf0(&msg,
			 gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
			 ssl_host,
			 cert_host);
	      if (! HTForcedPrompt(ssl_noprompt, msg, YES)) {
		  status = HT_NOT_LOADED;
		  FREE(msg);
		  goto done;
	      }
	  }
      }

      HTSprintf0(&msg,
		 gettext("Secure %d-bit %s (%s) HTTP connection"),
		 SSL_get_cipher_bits(handle, NULL),
		 SSL_get_cipher_version(handle),
		 SSL_get_cipher(handle));
      _HTProgress(msg);
      FREE(msg);
  }
d630 4
a633 5
  /*	Ask that node for the document,
  **	omitting the host name & anchor
  */
  {
    char * p1 = (HTParse(url, "", PARSE_PATH|PARSE_PUNCTUATION));
d636 4
a639 4
    if (do_connect) {
	METHOD = "CONNECT";
	BStrCopy0(command, "CONNECT ");
    } else
d641 10
a650 10
    if (do_post) {
	METHOD = "POST";
	BStrCopy0(command, "POST ");
    } else if (do_head) {
	METHOD = "HEAD";
	BStrCopy0(command, "HEAD ");
    } else {
	METHOD = "GET";
	BStrCopy0(command, "GET ");
    }
d652 5
a656 5
    /*
    **	If we are using a proxy gateway don't copy in the first slash
    **	of say: /gopher://a;lkdjfl;ajdf;lkj/;aldk/adflj
    **	so that just gopher://.... is sent.
    */
d658 10
a667 3
    if (using_proxy && !did_connect) {
	if (do_connect)
	    BStrCat0(command, connect_host);
d669 2
a670 1
	    BStrCat0(command, p1+1);
d672 102
a773 115
#else
    if (using_proxy)
	BStrCat0(command, p1+1);
#endif /* USE_SSL */
    else
	BStrCat0(command, p1);
    FREE(p1);
  }
  if (extensions) {
      BStrCat0(command, " ");
      BStrCat0(command, HTTP_VERSION);
  }

  BStrCat0(command, crlf);	/* CR LF, as in rfc 977 */

  if (extensions) {
      int n, i;
      char * host = NULL;

      if ((host = HTParse(anAnchor->address, "", PARSE_HOST)) != NULL) {
	  strip_userid(host);
	  HTBprintf(&command, "Host: %s%c%c", host, CR,LF);
	  FREE(host);
      }

      if (!HTPresentations)
	  HTFormatInit();
      n = HTList_count(HTPresentations);

      first_Accept = TRUE;
      len = 0;
      for (i = 0; i < n; i++) {
	  HTPresentation *pres =
			(HTPresentation *)HTList_objectAt(HTPresentations, i);
	  if (pres->get_accept) {
	      if (pres->quality < 1.0) {
		  if (pres->maxbytes > 0) {
		      sprintf(temp, ";q=%4.3f;mxb=%ld",
				    pres->quality, pres->maxbytes);
		  } else {
		      sprintf(temp, ";q=%4.3f", pres->quality);
		  }
	      } else if (pres->maxbytes > 0) {
		  sprintf(temp, ";mxb=%ld", pres->maxbytes);
	      } else {
		  temp[0] = '\0';
	      }
	      HTSprintf0(&linebuf, "%s%s%s",
			    (first_Accept ?
			       "Accept: " : ", "),
			    HTAtom_name(pres->rep),
			    temp);
	      len += strlen(linebuf);
	      if (len > 252 && !first_Accept) {
		  BStrCat0(command, crlf);
		  HTSprintf0(&linebuf, "Accept: %s%s",
				HTAtom_name(pres->rep),
				temp);
		  len = strlen(linebuf);
	      }
	      BStrCat0(command, linebuf);
	      first_Accept = FALSE;
	  }
      }
      HTBprintf(&command, "%s*/*;q=0.01%c%c",
		    (first_Accept ?
		       "Accept: " : ", "), CR, LF);
      first_Accept = FALSE;
      len = 0;

      /*
       * FIXME:  suppressing the "Accept-Encoding" in this case is done to work
       * around limitations of the presentation logic used for the command-line
       * "-base" option.  The remote site may transmit the document gzip'd, but
       * the ensuing logic in HTSaveToFile() would see the mime-type as gzip
       * rather than text/html, and not prepend the base URL.  This is less
       * efficient than accepting the compressed data and uncompressing it,
       * adding the base URL but is simpler than augmenting the dump's
       * presentation logic -TD
       */
      if (LYPrependBaseToSource && dump_output_immediately) {
	  CTRACE((tfp, "omit Accept-Encoding to work-around interaction with -source\n"));
      } else {
	  char *list = 0;
#if defined(USE_ZLIB) || defined(GZIP_PATH)
	  StrAllocCopy(list, "gzip");
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
	  if (list != 0)
	      StrAllocCat(list, ", ");
	  StrAllocCat(list, "compress");
#endif
	  if (list != 0) {
	      HTBprintf(&command, "Accept-Encoding: %s%c%c", list, CR, LF);
	      free(list);
	  }
      }

      if (language && *language) {
	  HTBprintf(&command, "Accept-Language: %s%c%c", language, CR, LF);
      }

      if (pref_charset && *pref_charset) {
	  BStrCat0(command, "Accept-Charset: ");
	  StrAllocCopy(linebuf, pref_charset);
	  if (linebuf[strlen(linebuf)-1] == ',')
	      linebuf[strlen(linebuf)-1] = '\0';
	  LYLowerCase(linebuf);
	  if (strstr(linebuf, "iso-8859-1") == NULL)
	      StrAllocCat(linebuf, ", iso-8859-1;q=0.01");
	  if (strstr(linebuf, "us-ascii") == NULL)
	      StrAllocCat(linebuf, ", us-ascii;q=0.01");
	  BStrCat0(command, linebuf);
	  HTBprintf(&command, "%c%c", CR, LF);
      }
d775 13
d789 25
a813 25
      /*
      **  Promote 300 (Multiple Choices) replies, if supported,
      **  over 406 (Not Acceptable) replies. - FM
      **
      **  This used to be done in versions 2.7 and 2.8*, but violates
      **  the specs for transparent content negotiation and has the
      **  effect that servers supporting those specs will send 300
      **  (Multiple Choices) instead of a normal response (e.g. 200 OK),
      **  since they will assume that the client wants to make the
      **  choice.  It is not clear whether there are any servers or sites
      **  for which sending this header really improves anything.
      **
      **  If there ever is a need to send "Negotiate: trans" and really
      **  mean it, we should send "Negotiate: trans,trans" or similar,
      **  since that is semantically equivalent and some servers may
      **  ignore "Negotiate: trans" as a special case when it comes from
      **  Lynx (to work around the old faulty behavior). - kw
      **
      **  References:
      **  RFC 2295 (see also RFC 2296), and mail to lynx-dev and
      **  new-httpd@@apache.org from Koen Holtman, Jan 1999.
      */
      if (!do_post) {
	  HTBprintf(&command, "Negotiate: trans%c%c", CR, LF);
      }
d816 27
a842 65
      /*
      **  When reloading give no-cache pragma to proxy server to make
      **  it refresh its cache. -- Ari L. <luotonen@@dxcern.cern.ch>
      **
      **  Also send it as a Cache-Control header for HTTP/1.1. - FM
      */
      if (reloading) {
	  HTBprintf(&command, "Pragma: no-cache%c%c", CR, LF);
	  HTBprintf(&command, "Cache-Control: no-cache%c%c", CR, LF);
      }

      if (LYUserAgent && *LYUserAgent) {
	  char *cp = LYSkipBlanks(LYUserAgent);
	  /* Won't send it at all if all blank - kw */
	  if (*cp != '\0')
	      HTBprintf(&command, "User-Agent: %.*s%c%c",
		      INIT_LINE_SIZE-15, LYUserAgent, CR, LF);
      } else {
	  HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
		  HTAppName ? HTAppName : "unknown",
		  HTAppVersion ? HTAppVersion : "0.0",
		  HTLibraryVersion, CR, LF);
      }

      if (personal_mail_address && !LYNoFromHeader) {
	  HTBprintf(&command, "From: %s%c%c", personal_mail_address, CR,LF);
      }

      if (!(LYUserSpecifiedURL ||
	    LYNoRefererHeader || LYNoRefererForThis) &&
	  strcmp(HTLoadedDocumentURL(), "")) {
	  char *cp = LYRequestReferer;
	  if (!cp) cp = HTLoadedDocumentURL(); /* @@@@@@ Try both? - kw */
	  BStrCat0(command, "Referer: ");
	  if (isLYNXIMGMAP(cp)) {
	      char *cp1 = trimPoundSelector(cp);
	      BStrCat0(command, cp + LEN_LYNXIMGMAP);
	      restorePoundSelector(cp1);
	  } else {
	      BStrCat0(command, cp);
	  }
	  HTBprintf(&command, "%c%c", CR, LF);
      }

      {
	char *abspath;
	char *docname;
	char *hostname;
	char *colon;
	int portnumber;
	char *auth, *cookie = NULL;
	BOOL secure = (BOOL) (strncmp(anAnchor->address, "https", 5) ?
							FALSE : TRUE);

	abspath = HTParse(arg, "", PARSE_PATH|PARSE_PUNCTUATION);
	docname = HTParse(arg, "", PARSE_PATH);
	hostname = HTParse(arg, "", PARSE_HOST);
	if (hostname &&
	    NULL != (colon = strchr(hostname, ':'))) {
	    *(colon++) = '\0';	/* Chop off port number */
	    portnumber = atoi(colon);
	} else if (!strncmp(arg, "https", 5)) {
	    portnumber = HTTPS_PORT;
	} else	{
	    portnumber = HTTP_PORT;
d845 126
a970 5
	/*
	**  Add Authorization, Proxy-Authorization,
	**  and/or Cookie headers, if applicable.
	*/
	if (using_proxy) {
d972 22
a993 16
	    **	If we are using a proxy, first determine if
	    **	we should include an Authorization header
	    **	and/or Cookie header for the ultimate target
	    **	of this request. - FM & AJL
	    */
	    char *host2 = NULL, *path2 = NULL;
	    int port2 = (strncmp(docname, "https", 5) ?
					   HTTP_PORT : HTTPS_PORT);
	    host2 = HTParse(docname, "", PARSE_HOST);
	    path2 = HTParse(docname, "", PARSE_PATH|PARSE_PUNCTUATION);
	    if (host2) {
		if ((colon = strchr(host2, ':')) != NULL) {
		    /* Use non-default port number */
		    *colon = '\0';
		    colon++;
		    port2 = atoi(colon);
d995 1
d997 2
d1000 9
a1008 5
	    **	This composeAuth() does file access, i.e., for
	    **	the ultimate target of the request. - AJL
	    */
	    auth_proxy = NO;
	    if ((auth = HTAA_composeAuth(host2, port2, path2,
d1012 3
a1014 3
		**  If auth is not NULL nor zero-length, it's
		**  an Authorization header to be included. - FM
		*/
d1016 4
a1019 1
		CTRACE((tfp, "HTTP: Sending authorization: %s\n", auth));
d1022 9
a1030 7
		**  If auth is a zero-length string, the user either
		**  cancelled or goofed at the username and password
		**  prompt. - FM
		*/
		if (!(traversal || dump_output_immediately) &&
			HTConfirm(CONFIRM_WO_PASSWORD)) {
		    show_401 = TRUE;
a1033 4
#ifdef USE_SSL
		    if (did_connect)
			HTTP_NETCLOSE(s, handle);
#endif /* USE_SSL */
a1036 3
		    FREE(abspath);
		    FREE(host2);
		    FREE(path2);
d1041 3
a1043 1
		CTRACE((tfp, "HTTP: Not sending authorization (yet).\n"));
d1045 2
a1046 19
	    /*
	    **	Add 'Cookie:' header, if it's HTTP or HTTPS
	    **	document being proxied.
	    */
	    if (!strncmp(docname, "http", 4)) {
		cookie = LYAddCookieHeader(host2, path2, port2, secure);
	    }
	    FREE(host2);
	    FREE(path2);
	    /*
	    **	The next composeAuth() will be for the proxy. - AJL
	    */
	    auth_proxy = YES;
	} else {
	    /*
	    **	Add cookie for a non-proxied request. - FM
	    */
	    cookie = LYAddCookieHeader(hostname, abspath, portnumber, secure);
	    auth_proxy = NO;
d1048 2
a1049 81
	/*
	**  If we do have a cookie set, add it to the request buffer. - FM
	*/
	if (cookie != NULL) {
	    if (*cookie != '$') {
		/*
		**  It's a historical cookie, so signal to the
		**  server that we support modern cookies. - FM
		*/
		BStrCat0(command, "Cookie2: $Version=\"1\"");
		BStrCat0(command, crlf);
		CTRACE((tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n"));
	    }
	    if (*cookie != '\0') {
		/*
		**  It's not a zero-length string, so add the header.
		**  Note that any folding of long strings has been
		**  done already in LYCookie.c. - FM
		*/
		BStrCat0(command, "Cookie: ");
		BStrCat0(command, cookie);
		BStrCat0(command, crlf);
		CTRACE((tfp, "HTTP: Sending Cookie: %s\n", cookie));
	    }
	    FREE(cookie);
	}
	FREE(abspath);

	/*
	**  If we are using a proxy, auth_proxy should be YES, and
	**  we check here whether we want a Proxy-Authorization header
	**  for it.  If we are not using a proxy, auth_proxy should
	**  still be NO, and we check here for whether we want an
	**  Authorization header. - FM & AJL
	*/
	if ((auth = HTAA_composeAuth(hostname,
				     portnumber,
				     docname,
				     auth_proxy)) != NULL &&
	    *auth != '\0') {
	    /*
	    **	If auth is not NULL nor zero-length, it's
	    **	an Authorization or Proxy-Authorization
	    **	header to be included. - FM
	    */
	    HTBprintf(&command, "%s%c%c", auth, CR, LF);
	    CTRACE((tfp, (auth_proxy ?
			 "HTTP: Sending proxy authorization: %s\n" :
			 "HTTP: Sending authorization: %s\n"),
			auth));
	} else if (auth && *auth == '\0') {
	    /*
	    **	If auth is a zero-length string, the user either
	    **	cancelled or goofed at the username and password
	    **	prompt. - FM
	    */
	    if (!(traversal || dump_output_immediately) && HTConfirm(CONFIRM_WO_PASSWORD)) {
		if (auth_proxy == TRUE) {
		    show_407 = TRUE;
		} else {
		    show_401 = TRUE;
		}
	    } else {
		if (traversal || dump_output_immediately)
		    HTAlert(FAILED_NEED_PASSWD);
		BStrFree(command);
		FREE(hostname);
		FREE(docname);
		status = HT_NOT_LOADED;
		goto done;
	    }
	} else {
	    CTRACE((tfp, (auth_proxy ?
			 "HTTP: Not sending proxy authorization (yet).\n" :
			 "HTTP: Not sending authorization (yet).\n")));
	}
	FREE(hostname);
	FREE(docname);
      }
      auth_proxy = NO;
  }
d1053 1
a1053 1
	!do_connect &&
d1055 1
a1055 1
	do_post) {
d1057 3
a1059 3
		     anAnchor->post_content_type
		     ? anAnchor->post_content_type
		     : "lose"));
d1061 3
a1063 3
		   anAnchor->post_content_type
		   ? anAnchor->post_content_type
		   : "lose",
d1068 2
a1069 2
		   ? BStrLen(anAnchor->post_data)
		   : 0,
d1075 1
a1075 2
    }
    else
d1083 1
a1083 1
	       (anAnchor->post_data && !do_connect ? crlf : "")));
d1086 1
a1086 1
	       (anAnchor->post_data ? crlf : "")));
d1091 1
a1091 1
  _HTProgress (gettext("Sending HTTP request."));
d1093 3
a1095 2
#ifdef    NOT_ASCII  /* S/390 -- gil -- 0548 */
  {   char *p;
d1097 5
a1101 3
      for ( p = BStrData(command); p < BStrData(command) + BStrLen(command); p++ )
	  *p = TOASCII(*p);
  }
d1103 12
a1114 12
  status = HTTP_NETWRITE(s, BStrData(command), BStrLen(command), handle);
  BStrFree(command);
  FREE(linebuf);
  if (status <= 0) {
      if (status == 0) {
	  CTRACE((tfp, "HTTP: Got status 0 in initial write\n"));
	  /* Do nothing. */
      } else if ((SOCKET_ERRNO == ENOTCONN ||
		  SOCKET_ERRNO == ECONNRESET ||
		  SOCKET_ERRNO == EPIPE) &&
		 !already_retrying &&
		 /* Don't retry if we're posting. */ !do_post) {
d1116 5
a1120 4
	    **	Arrrrgh, HTTP 0/1 compatibility problem, maybe.
	    */
	    CTRACE((tfp, "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n"));
	    _HTProgress (RETRYING_AS_HTTP0);
d1125 12
a1136 23
      } else {
	  CTRACE((tfp, "HTTP: Hit unexpected network WRITE error; aborting connection.\n"));
	  HTTP_NETCLOSE(s, handle);
	  status = -1;
	  HTAlert(gettext("Unexpected network write error; connection aborted."));
	  goto done;
      }
  }

  CTRACE((tfp, "HTTP: WRITE delivered OK\n"));
  _HTProgress (gettext("HTTP request sent; waiting for response."));

  /*	Read the first line of the response
  **	-----------------------------------
  */
  {
    /* Get numeric status etc */
    BOOL end_of_file = NO;
    int buffer_length = INIT_LINE_SIZE;

    line_buffer = typecallocn(char, buffer_length);
    if (line_buffer == NULL)
	outofmem(__FILE__, "HTLoadHTTP");
d1138 15
a1152 17
    HTReadProgress (bytes_already_read = 0, 0);
    do {/* Loop to read in the first line */
	/*
	**  Extend line buffer if necessary for those crazy WAIS URLs ;-)
	*/
	if (buffer_length - length < LINE_EXTEND_THRESH) {
	    buffer_length = buffer_length + buffer_length;
	    line_buffer =
	      (char *)realloc(line_buffer, (buffer_length * sizeof(char)));
	    if (line_buffer == NULL)
		outofmem(__FILE__, "HTLoadHTTP");
	}
	CTRACE((tfp, "HTTP: Trying to read %d\n", buffer_length - length - 1));
	status = HTTP_NETREAD(s, line_buffer + length,
			      buffer_length - length - 1, handle);
	CTRACE((tfp, "HTTP: Read %d\n", status));
	if (status <= 0) {
d1154 1
a1154 2
	     *	Retry if we get nothing back too.
	     *	Bomb out if we get nothing twice.
d1156 27
a1182 10
	    if (status == HT_INTERRUPTED) {
		CTRACE((tfp, "HTTP: Interrupted initial read.\n"));
		_HTProgress (CONNECTION_INTERRUPTED);
		HTTP_NETCLOSE(s, handle);
		status = HT_NO_DATA;
		goto clean_up;
	    } else if  (status < 0 &&
			(SOCKET_ERRNO == ENOTCONN ||
#ifdef _WINDOWS	/* 1997/11/09 (Sun) 16:59:58 */
			 SOCKET_ERRNO == ETIMEDOUT ||
d1184 11
a1194 10
			 SOCKET_ERRNO == ECONNRESET ||
			 SOCKET_ERRNO == EPIPE) &&
			!already_retrying && !do_post) {
		/*
		**  Arrrrgh, HTTP 0/1 compability problem, maybe.
		*/
		CTRACE((tfp, "HTTP: BONZO Trying again with HTTP0 request.\n"));
		HTTP_NETCLOSE(s, handle);
		FREE(line_buffer);
		FREE(line_kept_clean);
d1196 13
a1208 11
		extensions = NO;
		already_retrying = TRUE;
		_HTProgress (RETRYING_AS_HTTP0);
		goto try_again;
	    } else {
		CTRACE((tfp, "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			   status));
		HTAlert(gettext("Unexpected network read error; connection aborted."));
		HTTP_NETCLOSE(s, handle);
		status = -1;
		goto clean_up;
d1210 3
a1212 1
	}
d1214 5
a1218 6
#ifdef    NOT_ASCII  /* S/390 -- gil -- 0564 */
	{   char *p;

	    for ( p = line_buffer + length; p < line_buffer + length + status; p++ )
		*p = FROMASCII(*p);
	}
d1221 2
a1222 2
	bytes_already_read += status;
	HTReadProgress (bytes_already_read, 0);
d1224 2
a1225 2
#ifdef UCX  /* UCX returns -1 on EOF */
	if (status == 0 || status == -1)
d1227 1
a1227 1
	if (status == 0)
d1229 15
a1243 5
	{
	    end_of_file = YES;
	    break;
	}
	line_buffer[length+status] = 0;
d1245 4
a1248 69
	if (line_buffer) {
	    FREE(line_kept_clean);
	    line_kept_clean = (char *)malloc(buffer_length * sizeof(char));
	    if (line_kept_clean == NULL)
		outofmem(__FILE__, "HTLoadHTTP");
	    memcpy(line_kept_clean, line_buffer, buffer_length);
	    real_length_of_line = length + status;
	}

	eol = strchr(line_buffer + length, LF);
	/* Do we *really* want to do this? */
	if (eol && eol != line_buffer && *(eol-1) == CR)
	    *(eol-1) = ' ';

	length = length + status;

	/* Do we really want to do *this*? */
	if (eol)
	    *eol = 0;		/* Terminate the line */
    }
    /*	All we need is the first line of the response.	If it's a HTTP/1.0
    **	response, then the first line will be absurdly short and therefore
    **	we can safely gate the number of bytes read through this code
    **	(as opposed to below) to ~1000.
    **
    **	Well, let's try 100.
    */
    while (!eol && !end_of_file && bytes_already_read < 100);
  } /* Scope of loop variables */

  /* save total length, in case we decide later to show it all - kw */
  rawlength = length;

  /*	We now have a terminated unfolded line.  Parse it.
  **	--------------------------------------------------
  */
  CTRACE((tfp, "HTTP: Rx: %s\n", line_buffer));

  /*
  **  Kludge to work with old buggy servers and the VMS Help gateway.
  **  They can't handle the third word, so we try again without it.
  */
  if (extensions &&	  /* Old buggy server or Help gateway? */
      (0==strncmp(line_buffer,"<TITLE>Bad File Request</TITLE>",31) ||
       0==strncmp(line_buffer,"Address should begin with",25) ||
       0==strncmp(line_buffer,"<TITLE>Help ",12) ||
       0==strcmp(line_buffer,
		 "Document address invalid or access not authorised"))) {
      FREE(line_buffer);
      FREE(line_kept_clean);
      extensions = NO;
      already_retrying = TRUE;
      CTRACE((tfp, "HTTP: close socket %d to retry with HTTP0\n", s));
      HTTP_NETCLOSE(s, handle);
      /* print a progress message */
      _HTProgress (RETRYING_AS_HTTP0);
      goto try_again;
  }


  {
    int fields;
    char server_version[VERSION_LENGTH+1];

    server_version[0] = 0;

    fields = sscanf(line_buffer, "%20s %d",
		    server_version,
		    &server_status);
d1250 1
a1250 1
    CTRACE((tfp, "HTTP: Scanned %d fields from line_buffer\n", fields));
d1252 3
a1254 7
    if (http_error_file) {     /* Make the status code externally available */
	FILE *error_file;
#ifdef SERVER_STATUS_ONLY
	error_file = fopen(http_error_file, TXT_W);
	if (error_file) {		/* Managed to open the file */
	    fprintf(error_file, "error=%d\n", server_status);
	    fclose(error_file);
d1256 17
a1272 9
#else
	error_file = fopen(http_error_file, TXT_A);
	if (error_file) {		/* Managed to open the file */
	    fprintf(error_file, "   URL=%s (%s)\n", url, METHOD);
	    fprintf(error_file, "STATUS=%s\n", line_buffer);
	    fclose(error_file);
	}
#endif /* SERVER_STATUS_ONLY */
    }
d1275 49
a1323 6
    **	Rule out a non-HTTP/1.n reply as best we can.
    */
    if (fields < 2 || !server_version[0] || server_version[0] != 'H' ||
	server_version[1] != 'T' || server_version[2] != 'T' ||
	server_version[3] != 'P' || server_version[4] != '/' ||
	server_version[6] != '.') {
d1325 1
a1325 1
	 *  Ugh!  An HTTP0 reply,
d1327 8
a1334 1
	HTAtom * encoding;
d1336 1
a1336 1
	CTRACE((tfp, "--- Talking HTTP0.\n"));
d1338 1
a1338 11
	format_in = HTFileFormat(url, &encoding, NULL);
	/*
	**  Treat all plain text as HTML.
	**  This sucks but its the only solution without
	**  without looking at content.
	*/
	if (!strncmp(HTAtom_name(format_in), "text/plain",10)) {
	    CTRACE((tfp, "HTTP: format_in being changed to text/HTML\n"));
	    format_in = WWW_HTML;
	}
	if (!IsUnityEnc(encoding)) {
d1340 16
a1355 7
	    **	Change the format to that for "www/compressed".
	    */
	    CTRACE((tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in)));
	    StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
	    StrAllocCopy(anAnchor->content_encoding, HTAtom_name(encoding));
	    format_in = HTAtom_for("www/compressed");
	    CTRACE((tfp, "        Treating as '%s' with encoding '%s'\n",
d1357 1
a1357 1
	}
d1359 7
a1365 7
	start_of_data = line_kept_clean;
    } else {
	/*
	**  Set up to decode full HTTP/1.n response. - FM
	*/
	format_in = HTAtom_for("www/mime");
	CTRACE((tfp, "--- Talking HTTP1.\n"));
d1367 9
a1375 10
	/*
	**  We set start_of_data to "" when !eol here because there
	**  will be a put_block done below; we do *not* use the value
	**  of start_of_data (as a pointer) in the computation of
	**  length (or anything else) when !eol.  Otherwise, set the
	**  value of length to what we have beyond eol (i.e., beyond
	**  the status line). - FM
	*/
	start_of_data = eol ? eol + 1 : "";
	length = eol ? length - (start_of_data - line_buffer) : 0;
a1376 12
	/*
	**  Trim trailing spaces in line_buffer so that we can use
	**  it in messages which include the status line. - FM
	*/
	while (line_buffer[strlen(line_buffer)-1] == ' ')
	       line_buffer[strlen(line_buffer)-1] = '\0';

	/*
	**  Take appropriate actions based on the status. - FM
	*/
	switch (server_status/100) {
	  case 1:
d1378 5
a1382 12
	    **	HTTP/1.1 Informational statuses.
	    **	100 Continue.
	    **	101 Switching Protocols.
	    **	> 101 is unknown.
	    **	We should never get these, and they have only
	    **	the status line and possibly other headers,
	    **	so we'll deal with them by showing the full
	    **	header to the user as text/plain. - FM
	    */
	    HTAlert(gettext("Got unexpected Informational Status."));
	    do_head = TRUE;
	    break;
a1383 1
	  case 2:
d1385 4
a1388 3
	    **	Good: Got MIME object! (Successful) - FM
	    */
	    if (do_head) {
d1390 7
a1396 2
		 *  If HEAD was requested, show headers (and possibly
		 *  bogus body) for all 2xx status codes as text/plain - KW
d1398 2
a1399 1
		HTProgress(line_buffer);
d1401 2
a1402 3
	    }
	    switch (server_status) {
	      case 204:
d1404 1
a1404 1
		 *  No Content.
d1406 18
a1423 5
		HTAlert(line_buffer);
		HTTP_NETCLOSE(s, handle);
		HTNoDataOK = 1;
		status = HT_NO_DATA;
		goto clean_up;
d1425 11
a1435 12
	      case 205:
		/*
		 *  Reset Content.  The server has fulfilled the
		 *  request but nothing is returned and we should
		 *  reset any form content.  We'll instruct the
		 *  user to do that, and restore the current
		 *  document. - FM
		 */
		HTAlert(gettext("Request fulfilled.  Reset Content."));
		HTTP_NETCLOSE(s, handle);
		status = HT_NO_DATA;
		goto clean_up;
d1437 10
a1446 11
	      case 206:
		/*
		 *  Partial Content.  We didn't send a Range
		 *  so something went wrong somewhere.	Show
		 *  the status message and restore the current
		 *  document. - FM
		 */
		HTAlert(line_buffer);
		HTTP_NETCLOSE(s, handle);
		status = HT_NO_DATA;
		goto clean_up;
d1448 9
a1456 9
	      default:
		/*
		 *  200 OK.
		 *  201 Created.
		 *  202 Accepted.
		 *  203 Non-Authoritative Information.
		 *  > 206 is unknown.
		 *  All should return something to display.
		 */
d1458 3
a1460 2
		if (do_connect) {
		    CTRACE((tfp, "HTTP: Proxy tunnel to '%s' established.\n",
d1462 20
a1481 5
		    do_connect = FALSE;
		    url = connect_url;
		    FREE(line_buffer);
		    FREE(line_kept_clean);
		    if (!strncmp(connect_url, "snews", 5)) {
d1483 2
a1484 4
			"      Will attempt handshake and snews connection.\n"));
			status = HTNewsProxyConnect(s, url, anAnchor,
						    format_out, sink);
			goto done;
a1485 13
		    did_connect = TRUE;
		    already_retrying = TRUE;
		    eol = 0;
		    bytes_already_read = 0;
		    had_header = NO;
		    length = 0;
		    doing_redirect = FALSE;
		    permanent_redirection = FALSE;
		    target = NULL;
		    CTRACE((tfp,
			"      Will attempt handshake and resubmit headers.\n"));
		    goto use_tunnel;
		}
d1487 2
a1488 24
		HTProgress(line_buffer);
	    } /* case 2 switch */
	    break;

	  case 3:
	    /*
	    **	Various forms of Redirection. - FM
	    **	300 Multiple Choices.
	    **	301 Moved Permanently.
	    **	302 Found (temporary; we can, and do, use GET).
	    **	303 See Other (temporary; always use GET).
	    **	304 Not Modified.
	    **	305 Use Proxy.
	    **	306 Set Proxy.
	    **	307 Temporary Redirect with method retained.
	    **	> 308 is unknown.
	    */
	    if (no_url_redirection || do_head || keep_mime_headers) {
		/*
		 *  If any of these flags are set, we do not redirect,
		 *  but instead show what was returned to the user as
		 *  text/plain. - FM
		 */
		HTProgress(line_buffer);
a1489 1
	    }
d1491 1
a1491 1
	    if (server_status == 300) { /* Multiple Choices */
d1493 10
a1502 9
		 *  For client driven content negotiation.  The server
		 *  should be sending some way for the user-agent to
		 *  make a selection, so we'll show the user whatever
		 *  the server returns.  There might be a Location:
		 *  header with the server's preference present, but
		 *  the choice should be up to the user, someday based
		 *  on an Alternates: header, and a body always should
		 *  be present with descriptions and links for the
		 *  choices (i.e., we use the latter, for now). - FM
d1504 8
a1511 5
		HTAlert(line_buffer);
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
d1513 2
a1514 2
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
d1516 9
a1524 3
		     *	Convert a download request to
		     *	a presentation request for
		     *	interactive users. - FM
d1526 15
a1540 1
		    format_out = WWW_PRESENT;
a1541 2
		break;
	    }
d1543 10
a1552 11
	    if (server_status == 304) { /* Not Modified */
		/*
		 *  We didn't send an "If-Modified-Since" header,
		 *  so this status is inappropriate.  We'll deal
		 *  with it by showing the full header to the user
		 *  as text/plain. - FM
		 */
		HTAlert(gettext("Got unexpected 304 Not Modified status."));
		do_head = TRUE;
		break;
	    }
d1554 3
a1556 15
	    if (server_status == 305 ||
		server_status == 306 ||
		server_status > 307) {
		/*
		 *  Show user the content, if any, for 305, 306,
		 *  or unknown status. - FM
		 */
		HTAlert(line_buffer);
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
d1558 2
a1559 3
		     *	Convert a download request to
		     *	a presentation request for
		     *	interactive users. - FM
d1561 15
a1575 1
		    format_out = WWW_PRESENT;
a1576 2
		break;
	    }
d1578 21
a1598 77
	    /*
	     *	We do not load the file, but read the headers for
	     *	the "Location:", check out that redirecting_url
	     *	and if it's acceptible (e.g., not a telnet URL
	     *	when we have that disabled), initiate a new fetch.
	     *	If that's another redirecting_url, we'll repeat the
	     *	checks, and fetch initiations if acceptible, until
	     *	we reach the actual URL, or the redirection limit
	     *	set in HTAccess.c is exceeded.	If the status was 301
	     *	indicating that the relocation is permanent, we set
	     *	the permanent_redirection flag to make it permanent
	     *	for the current anchor tree (i.e., will persist until
	     *	the tree is freed or the client exits).  If the
	     *	redirection would include POST content, we seek
	     *	confirmation from an interactive user, with option to
	     *	use 303 for 301 (but not for 307), and otherwise refuse
	     *	the redirection.  We also don't allow permanent
	     *	redirection if we keep POST content.  If we don't find
	     *	the Location header or it's value is zero-length, we
	     *	display whatever the server returned, and the user
	     *	should RELOAD that to try again, or make a selection
	     *	from it if it contains links, or Left-Arrow to the
	     *	previous document. - FM
	     */
	    {
	      if ((dump_output_immediately || traversal) &&
		  do_post &&
		  server_status != 303 &&
		  server_status != 302 &&
		  server_status != 301) {
		  /*
		   *  Don't redirect POST content without approval
		   *  from an interactive user. - FM
		   */
		  HTTP_NETCLOSE(s, handle);
		  status = -1;
		  HTAlert(
		       gettext("Redirection of POST content requires user approval."));
		  if (traversal)
		      HTProgress(line_buffer);
		  goto clean_up;
	      }

	      HTProgress(line_buffer);
	      if (server_status == 301) { /* Moved Permanently */
		  if (do_post) {
		      /*
		       *  Don't make the redirection permanent
		       *  if we have POST content. - FM
		       */
		      CTRACE((tfp, "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n"));
		      HTAlert(
	 gettext("Have POST content.  Treating Permanent Redirection as Temporary.\n"));
		  } else {
		      permanent_redirection = TRUE;
		  }
	      }
	      doing_redirect = TRUE;

	      break;
	   }

	  case 4:
	    /*
	    **	"I think I goofed!" (Client Error) - FM
	    */
	    switch (server_status) {
	      case 401:  /* Unauthorized */
		/*
		 *  Authorization for orgin server required.
		 *  If show_401 is set, proceed to showing the
		 *  401 body.  Otherwise, if we can set up
		 *  authorization based on the WWW-Authenticate
		 *  header, and the user provides a username and
		 *  password, try again.  Otherwise, check whether
		 *  to show the 401 body or restore the current
		 *  document. - FM
d1600 15
a1614 11
		if (show_401)
		    break;
		if (HTAA_shouldRetryWithAuth(start_of_data, length, s, NO)) {

		    HTTP_NETCLOSE(s, handle);
		    if (dump_output_immediately && !authentication_info[0]) {
			fprintf(stderr,
				"HTTP: Access authorization required.\n");
			fprintf(stderr,
				"       Use the -auth=id:pw parameter.\n");
			status = HT_NO_DATA;
d1618 15
a1632 3
		    CTRACE((tfp, "%s %d %s\n",
				"HTTP: close socket", s,
				"to retry with Access Authorization"));
a1633 14
		    _HTProgress (
			gettext("Retrying with access authorization information."));
		    FREE(line_buffer);
		    FREE(line_kept_clean);
#ifdef USE_SSL
		    if (using_proxy && !strncmp(url, "https://", 8)) {
			url = arg;
			do_connect = TRUE;
			did_connect = FALSE;
		    }
#endif /* USE_SSL */
		    goto try_again;
		} else if (!(traversal || dump_output_immediately) &&
			   HTConfirm(gettext("Show the 401 message body?"))) {
a1634 6
		} else {
		    if (traversal || dump_output_immediately)
			HTAlert(FAILED_RETRY_WITH_AUTH);
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
d1637 1
a1637 1
	      case 407:
d1639 1
a1639 9
		 *  Authorization for proxy server required.
		 *  If we are not in fact using a proxy, or
		 *  show_407 is set, proceed to showing the
		 *  407 body.  Otherwise, if we can set up
		 *  authorization based on the Proxy-Authenticate
		 *  header, and the user provides a username and
		 *  password, try again.  Otherwise, check whether
		 *  to show the 401 body or restore the current
		 *  document. - FM & AJL
d1641 27
a1667 3
		if (!using_proxy || show_407)
		    break;
		if (HTAA_shouldRetryWithAuth(start_of_data, length, s, YES)) {
d1669 19
a1687 7
		    HTTP_NETCLOSE(s, handle);
		    if (dump_output_immediately && !proxyauth_info[0]) {
			fprintf(stderr,
				"HTTP: Proxy authorization required.\n");
			fprintf(stderr,
				"       Use the -pauth=id:pw parameter.\n");
			status = HT_NO_DATA;
d1691 25
a1715 1
		    CTRACE((tfp, "%s %d %s\n",
d1719 59
a1777 6
		    _HTProgress (HTTP_RETRY_WITH_PROXY);
		    FREE(line_buffer);
		    FREE(line_kept_clean);
		    goto try_again;
		} else if (!(traversal || dump_output_immediately) &&
			   HTConfirm(gettext("Show the 407 message body?"))) {
d1781 2
a1782 3
			 *  Convert a download request to
			 *  a presentation request for
			 *  interactive users. - FM
d1787 18
a1804 3
		} else {
		    if (traversal || dump_output_immediately)
			HTAlert(FAILED_RETRY_WITH_PROXY);
d1809 9
d1819 1
a1819 11
	      case 408:
		/*
		 *  Request Timeout.  Show the status message
		 *  and restore the current document. - FM
		 */
		HTAlert(line_buffer);
		HTTP_NETCLOSE(s, handle);
		status = HT_NO_DATA;
		goto done;

	      default:
d1821 2
a1822 18
		 *  400 Bad Request.
		 *  402 Payment Required.
		 *  403 Forbidden.
		 *  404 Not Found.
		 *  405 Method Not Allowed.
		 *  406 Not Acceptable.
		 *  409 Conflict.
		 *  410 Gone.
		 *  411 Length Required.
		 *  412 Precondition Failed.
		 *  413 Request Entity Too Large.
		 *  414 Request-URI Too Long.
		 *  415 Unsupported Media Type.
		 *  416 List Response (for content negotiation).
		 *  > 416 is unknown.
		 *  Show the status message, and display
		 *  the returned text if we are not doing
		 *  a traversal. - FM
d1824 1
d1834 2
a1835 3
		     *	Convert a download request to
		     *	a presentation request for
		     *	interactive users. - FM
d1840 146
a1985 2
	    } /* case 4 switch */
	    break;
d1987 2
a1988 1
	  case 5:
d1990 18
a2007 15
	    **	"I think YOU goofed!" (server error)
	    **	500 Internal Server Error
	    **	501 Not Implemented
	    **	502 Bad Gateway
	    **	503 Service Unavailable
	    **	504 Gateway Timeout
	    **	505 HTTP Version Not Supported
	    **	> 505 is unknown.
	    **	Should always include a message, which
	    **	we always should display. - FM
	    */
	    HTAlert(line_buffer);
	    if (traversal) {
		HTTP_NETCLOSE(s, handle);
		status = -1;
d2010 18
a2027 2
	    if (!dump_output_immediately &&
		format_out == HTAtom_for("www/download")) {
d2029 4
a2032 3
		 *  Convert a download request to
		 *  a presentation request for
		 *  interactive users. - FM
d2034 2
a2035 1
		format_out = WWW_PRESENT;
a2036 3
	    break;

	  default:
d2038 12
a2049 9
	    **	Bad or unknown server_status number.
	    **	Take a chance and hope there is
	    **	something to display. - FM
	    */
	    HTAlert(gettext("Unknown status reply from server!"));
	    HTAlert(line_buffer);
	    if (traversal) {
		HTTP_NETCLOSE(s, handle);
		status = -1;
d2051 8
a2058 3
	    }
	    if (!dump_output_immediately &&
		format_out == HTAtom_for("www/download")) {
d2060 2
a2061 3
		 *  Convert a download request to
		 *  a presentation request for
		 *  interactive users. - FM
d2063 2
a2064 1
		format_out = WWW_PRESENT;
a2065 2
	    break;
	} /* Switch on server_status/100 */
d2067 11
a2077 2
      } /* Full HTTP reply */
  } /* scope of fields */
d2079 6
a2084 36
  /*
  **  The user may have pressed the 'z'ap key during the pause caused
  **  by one of the HTAlerts above if the server reported an error,
  **  to skip loading of the error response page.  Checking here before
  **  setting up the stream stack and feeding it data avoids doing
  **  unnecessary work, it also can avoid unnecessarily pushing a
  **  loaded document out of the cache to make room for the unwanted
  **  error page. - kw
  */
  if (HTCheckForInterrupt()) {
      HTTP_NETCLOSE(s, handle);
      if (doing_redirect) {
	  /*
	   *  Impatient user. - FM
	   */
	  CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	  _HTProgress (CONNECTION_INTERRUPTED);
      }
      status = HT_INTERRUPTED;
      goto clean_up;
  }
  /*
  **  Set up the stream stack to handle the body of the message.
  */
  if (do_head || keep_mime_headers) {
      /*
      **  It was a HEAD request, or we want the headers and source.
      */
      start_of_data = line_kept_clean;
#ifdef SH_EX	/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
/* GIF file contains \0, so strlen does not return the data length */
      length = real_length_of_line;
#else
      length = rawlength;
#endif
      format_in = HTAtom_for("text/plain");
d2086 6
a2091 1
  } else if (doing_redirect) {
d2093 7
a2099 221
      format_in = HTAtom_for("message/x-http-redirection");
      StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
      if (traversal) {
	  format_out = WWW_DEBUG;
	  if (!sink)
	      sink = HTErrorStream();
      } else if (!dump_output_immediately &&
	  format_out == HTAtom_for("www/download")) {
	  /*
	   *  Convert a download request to
	   *  a presentation request for
	   *  interactive users. - FM
	   */
	  format_out = WWW_PRESENT;
      }
  }

  target = HTStreamStack(format_in,
			 format_out,
			 sink, anAnchor);

  if (!target || target == NULL) {
      char *buffer = NULL;

      HTTP_NETCLOSE(s, handle);
      HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
	      HTAtom_name(format_in), HTAtom_name(format_out));
      _HTProgress (buffer);
      FREE(buffer);
      status = -1;
      goto clean_up;
  }

  /*
  **  Recycle the first chunk of data, in all cases.
  */
  (*target->isa->put_block)(target, start_of_data, length);

  /*
  **  Go pull the bulk of the data down.
  */
  rv = HTCopy(anAnchor, s, (void *)handle, target);

  /*
  **  If we get here with doing_redirect set, it means that we were
  **  looking for a Location header.  We either have got it now in
  **  redirecting_url - in that case the stream should not have loaded
  **  any data.  Or we didn't get it, in that case the stream may have
  **  presented the message body normally. - kw
  */

  if (rv == -1) {
      /*
      **  Intentional interrupt before data were received, not an error
      */
      /* (*target->isa->_abort)(target, NULL); */ /* already done in HTCopy */
      if (doing_redirect && traversal)
	  status = -1;
      else
	  status = HT_INTERRUPTED;
      HTTP_NETCLOSE(s, handle);
      goto clean_up;
  }

  if (rv == -2) {
      /*
      **  Aw hell, a REAL error, maybe cuz it's a dumb HTTP0 server
      */
      (*target->isa->_abort)(target, NULL);
      if (doing_redirect && redirecting_url) {
	  /*
	  **  Got a location before the error occurred?  Then consider it
	  **  an interrupt but proceed below as normal. - kw
	  */
	  /* do nothing here */
      } else {
	  HTTP_NETCLOSE(s, handle);
	  if (!doing_redirect && !already_retrying && !do_post) {
	      CTRACE((tfp, "HTTP: Trying again with HTTP0 request.\n"));
	      /*
	      **  May as well consider it an interrupt -- right?
	      */
	      FREE(line_buffer);
	      FREE(line_kept_clean);
	      extensions = NO;
	      already_retrying = TRUE;
	      _HTProgress (RETRYING_AS_HTTP0);
	      goto try_again;
	  } else {
	      status = HT_NOT_LOADED;
	      goto clean_up;
	  }
      }
  }

  /*
  **  Free if complete transmission (socket was closed before return).
  **  Close socket if partial transmission (was freed on abort).
  */
  if (rv != HT_INTERRUPTED && rv != -2) {
      (*target->isa->_free)(target);
  } else {
      HTTP_NETCLOSE(s, handle);
  }

  if (doing_redirect) {
      if (redirecting_url) {
	  /*
	   *  Set up for checking redirecting_url in
	   *  LYGetFile.c for restrictions before we
	   *  seek the document at that Location. - FM
	   */
	  CTRACE((tfp, "HTTP: Picked up location '%s'\n",
		  redirecting_url));
	  if (rv == HT_INTERRUPTED) {
	      /*
	      **  Intentional interrupt after data were received, not an
	      **  error (probably).  We take it as a user request to
	      **  abandon the redirection chain.
	      **  This could reasonably be changed (by just removing this
	      **  block), it would make sense if there are redirecting
	      **  resources that "hang" after sending the headers. - kw
	      */
	      FREE(redirecting_url);
	      CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	      status = HT_INTERRUPTED;
	      goto clean_up;
	  }
	  HTProgress(line_buffer);
	  if (server_status == 305) { /* Use Proxy */
	      /*
	       *	Make sure the proxy field ends with
	       *	a slash. - FM
	       */
	      if (redirecting_url[strlen(redirecting_url)-1]
		  != '/')
		  StrAllocCat(redirecting_url, "/");
	      /*
	       *	Append our URL. - FM
	       */
	      StrAllocCat(redirecting_url, anAnchor->address);
	      CTRACE((tfp, "HTTP: Proxy URL is '%s'\n",
		      redirecting_url));
	  }
	  if (!do_post ||
	      server_status == 303 ||
	      server_status == 302) {
	      /*
	       *	We don't have POST content (nor support PUT
	       *	or DELETE), or the status is "See Other"  or
	       *	"General Redirection" and we can convert to
	       *	GET, so go back and check out the new URL. - FM
	       */
	      status = HT_REDIRECTING;
	      goto clean_up;
	  }
	  /*
	   *  Make sure the user wants to redirect
	   *  the POST content, or treat as GET - FM & DK
	   */
	  switch (HTConfirmPostRedirect(redirecting_url,
					server_status)) {
	      /*
	       *	User failed to confirm.
	       *	Abort the fetch.
	       */
	  case 0:
	      doing_redirect = FALSE;
	      FREE(redirecting_url);
	      status = HT_NO_DATA;
	      goto clean_up;

	      /*
	       *	User wants to treat as GET with no content.
	       *	Go back to check out the URL.
	       */
	  case 303:
	      break;

	      /*
	       *	Set the flag to retain the POST
	       *	content and go back to check out
	       *	the URL. - FM
	       */
	  default:
	      redirect_post_content = TRUE;
	  }

	  /* Lou's old comment:  - FM */
	  /* OK, now we've got the redirection URL temporarily stored
	     in external variable redirecting_url, exported from HTMIME.c,
	     since there's no straightforward way to do this in the library
	     currently.  Do the right thing. */

	  status = HT_REDIRECTING;

      } else {
	  status = traversal ? -1 : HT_LOADED;
      }

  } else {
      /*
      **  If any data were received, treat as a complete transmission
      */
      status = HT_LOADED;
  }

  /*
  **  Clean up
  */
clean_up:
  FREE(line_buffer);
  FREE(line_kept_clean);

done:
  /*
  **  Clear out on exit, just in case.
  */
  do_head = FALSE;
  do_post = FALSE;
  reloading = FALSE;
d2101 7
a2107 7
  do_connect = FALSE;
  did_connect = FALSE;
  FREE(connect_host);
  if (handle) {
    SSL_free(handle);
    SSL_handle = handle = NULL;
  }
d2109 1
a2109 1
  return status;
d2116 1
a2116 1
GLOBALDEF (HTProtocol,HTTP,_HTTP_C_GLOBALDEF_1_INIT);
d2118 1
a2118 1
GLOBALDEF (HTProtocol,HTTPS,_HTTP_C_GLOBALDEF_2_INIT);
d2120 4
a2123 2
GLOBALDEF PUBLIC HTProtocol HTTP = { "http", HTLoadHTTP, 0 };
GLOBALDEF PUBLIC HTProtocol HTTPS = { "https", HTLoadHTTP, 0 };
@


1.5
log
@ignore case when comparing host names,
since DNS is case insensitive
@
text
@d1 1
a1 1
/* $MirBSD: HTTP.c,v 1.4 2003/07/07 19:52:04 tg Exp $
d94 1
a94 1

d101 1
@


1.4
log
@fix https:// certificate validation
from myself
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.4 2003/07/07 19:03:08 tg Exp $
d632 1
a632 1
	  if (strcmp(ssl_host, cert_host)) {
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 20
d627 2
d630 2
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d1 1
a1 1
/*	HyperText Tranfer Protocol	- Client implementation 	HTTP.c
d14 2
a15 5
#define free_func free__func
#include <openssl/ssl.h>
#include <openssl/crypto.h>
#undef free_func
#endif /* USE_SSL */
d36 1
a50 6
extern char * personal_mail_address;	/* User's name/email address */
extern char * LYUserAgent;	/* Lynx User-Agent string */
extern BOOL LYNoRefererHeader;	/* Never send Referer header? */
extern BOOL LYNoRefererForThis; /* No Referer header for this URL? */
extern BOOL LYNoFromHeader;	/* Never send From header? */
extern BOOL LYSetCookies;	/* Act on Set-Cookie headers? */
a51 1
extern BOOL using_proxy;	/* Are we using an HTTP gateway? */
a56 8
extern BOOLEAN LYUserSpecifiedURL; /* Is the URL a goto? */

extern BOOL keep_mime_headers;	 /* Include mime headers and force source dump */
extern BOOL no_url_redirection;  /* Don't follow Location: URL for */
extern char *http_error_file;	 /* Store HTTP status code in this file */
extern BOOL traversal;		 /* TRUE if we are doing a traversal */
extern BOOL dump_output_immediately;  /* TRUE if no interactive user */

d59 2
d65 20
a84 1
        SSL_CTX_free(ssl_ctx);
d90 1
a90 1
        /*
d94 1
a94 1
        ssl_ctx = SSL_CTX_new();
d101 1
d105 1
d109 38
d152 1
a152 1
	{ (void)NETCLOSE(sock); if (handle) SSL_free(handle); handle = NULL; }
a153 4
extern int HTNewsProxyConnect PARAMS (( int sock, CONST char *url, 
					HTParentAnchor *anAnchor,
					HTFormat format_out,
					HTStream *sink ));
d160 198
d384 1
a384 1
  char *command = NULL; 	/* The whole command */
d389 1
a389 1
  char crlf[3]; 		/* A CR LF equivalent string */
d392 2
a393 2
  BOOL do_head = FALSE; 	/* Whether or not we should do a head */
  BOOL do_post = FALSE; 	/* ARE WE posting ? */
d399 1
d401 1
a401 1
  char line[INIT_LINE_SIZE];
d406 1
a406 1
  BOOL auth_proxy = NO; 	/* Generate a proxy authorization. - AJL */
d408 3
a410 2
  int length, rv;
  BOOL doing_redirect, already_retrying = FALSE, bad_location = FALSE;
d414 2
a415 2
  BOOL do_connect = FALSE;    /* ARE WE going to use a proxy tunnel ? */
  BOOL did_connect = FALSE;   /* ARE WE actually using a proxy tunnel ? */
d417 7
a423 2
  char *connect_host = NULL;  /* The host being proxied */
  SSL * handle = NULL;                /* The SSL handle */
d427 1
d450 1
a450 1
      if (connect_url = strstr((url+7), "https://")) {
d457 3
a459 3
	  CTRACE(tfp, "HTTP: connect_url = '%s'\n", connect_url);
	  CTRACE(tfp, "HTTP: connect_host = '%s'\n", connect_host);
      } else if (connect_url = strstr((url+7), "snews://")) {
d466 2
a467 2
	  CTRACE(tfp, "HTTP: connect_url = '%s'\n", connect_url);
	  CTRACE(tfp, "HTTP: connect_host = '%s'\n", connect_host);
d494 1
a495 1
#ifdef USE_SSL
d500 1
d512 1
a512 1
       CTRACE (tfp, "HTTP: Interrupted on connect; recovering cleanly.\n");
d518 9
a526 2
	CTRACE(tfp, "HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
	    url, SOCKET_ERRNO);
d532 5
d544 1
a544 1
      handle = HTGetSSLHandle();
d548 1
a548 1
          handle->options|=SSL_OP_NO_TLSv1;
d550 1
d556 1
a556 2
              CTRACE(tfp, "HTTP: Retrying connection without TLS\n");
	      _HTProgress("Retrying connection.");
d559 2
a560 2
	          HTTP_NETCLOSE(s, handle);
      	      goto try_again;
d562 9
a570 4
              CTRACE(tfp,
"HTTP: Unable to complete SSL handshake for remote host '%s' (SSLerror = %d)\n",
				url, status);
      	      HTAlert("Unable to make secure connection to remote host.");
d572 3
a574 3
	          HTTP_NETCLOSE(s, handle);
      	      status = HT_NOT_LOADED;
      	      goto done;
d577 9
a585 4
              CTRACE(tfp,
"HTTP: Unable to complete SSL handshake for remote host '%s' (SSLerror = %d)\n",
				url, status);
      	  HTAlert("Unable to make secure connection to remote host.");
d588 2
a589 2
      	  status = HT_NOT_LOADED;
      	  goto done;
a591 1
      _HTProgress (SSL_get_cipher(handle));
d593 26
a618 9
#ifdef NOTDEFINED
      if (strcmp(HTParse(url, "", PARSE_HOST),
      		 strstr(X509_NAME_oneline(
		 	X509_get_subject_name(
				handle->session->peer)),"/CN=")+4)) {
	  HTAlert("Certificate is for different host name");
	  HTAlert(strstr(X509_NAME_oneline(
	  		 X509_get_subject_name(
			 	handle->session->peer)),"/CN=")+4);
d620 8
a627 1
#endif /* NOTDEFINED */
d640 1
a640 1
	StrAllocCopy(command, "CONNECT ");
d645 1
a645 1
	StrAllocCopy(command, "POST ");
d648 1
a648 1
	StrAllocCopy(command, "HEAD ");
d651 1
a651 1
	StrAllocCopy(command, "GET ");
d662 3
a664 3
	    StrAllocCat(command, connect_host);
      else
	StrAllocCat(command, p1+1);
d668 1
a668 1
	StrAllocCat(command, p1+1);
d671 1
a671 1
	StrAllocCat(command, p1);
d675 2
a676 2
      StrAllocCat(command, " ");
      StrAllocCat(command, HTTP_VERSION);
d679 1
a679 1
  StrAllocCat(command, crlf);	/* CR LF, as in rfc 977 */
d686 2
a687 2
	  sprintf(line, "Host: %s%c%c", host, CR,LF);
	  StrAllocCat(command, line);
d700 5
a704 14
	  if (pres->rep_out == WWW_PRESENT) {
	      if (pres->rep != WWW_SOURCE &&
		  strcasecomp(HTAtom_name(pres->rep), "www/mime") &&
		  strcasecomp(HTAtom_name(pres->rep), "www/compressed") &&
		  pres->quality <= 1.0 && pres->quality >= 0.0) {
		  if (pres->quality < 1.0) {
		      if (pres->maxbytes > 0) {
			  sprintf(temp, ";q=%4.3f;mxb=%ld",
					pres->quality, pres->maxbytes);
		      } else {
			  sprintf(temp, ";q=%4.3f", pres->quality);
		      }
		  } else if (pres->maxbytes > 0) {
		      sprintf(temp, ";mxb=%ld", pres->maxbytes);
d706 1
a706 1
		      temp[0] = '\0';
d708 14
a721 3
		  sprintf(line, "%s%s%s",
				(first_Accept ?
				   "Accept: " : ", "),
d724 1
a724 10
		  len += strlen(line);
		  if (len > 252 && !first_Accept) {
		      StrAllocCat(command, crlf);
		      sprintf(line, "Accept: %s%s",
				    HTAtom_name(pres->rep),
				    temp);
		      len = strlen(line);
		  }
		  StrAllocCat(command, line);
		  first_Accept = FALSE;
d726 2
d730 1
a730 1
      sprintf(line, "%s*/*;q=0.01%c%c",
a732 1
      StrAllocCat(command, line);
d736 27
a762 3
      sprintf(line, "Accept-Encoding: %s, %s%c%c",
		    "gzip", "compress", CR, LF);
      StrAllocCat(command, line);
d765 1
a765 2
	  sprintf(line, "Accept-Language: %s%c%c", language, CR, LF);
	  StrAllocCat(command, line);
d769 11
a779 12
	  StrAllocCat(command, "Accept-Charset: ");
	  strcpy(line, pref_charset);
	  if (line[strlen(line)-1] == ',')
	      line[strlen(line)-1] = '\0';
	  LYLowerCase(line);
	  if (strstr(line, "iso-8859-1") == NULL)
	      strcat(line, ", iso-8859-1;q=0.01");
	  if (strstr(line, "us-ascii") == NULL)
	      strcat(line, ", us-ascii;q=0.01");
	  StrAllocCat(command, line);
	  sprintf(line, "%c%c", CR, LF);
	  StrAllocCat(command, line);
d806 1
a806 2
	  sprintf(line, "Negotiate: trans%c%c", CR, LF);
	  StrAllocCat(command, line);
d817 2
a818 4
	  sprintf(line, "Pragma: no-cache%c%c", CR, LF);
	  StrAllocCat(command, line);
	  sprintf(line, "Cache-Control: no-cache%c%c", CR, LF);
	  StrAllocCat(command, line);
d822 5
a826 1
	  sprintf(line, "User-Agent: %s%c%c", LYUserAgent, CR, LF);
d828 1
a828 1
	  sprintf(line, "User-Agent: %s/%s  libwww-FM/%s%c%c",
a832 1
      StrAllocCat(command, line);
d835 1
a835 2
	  sprintf(line, "From: %s%c%c", personal_mail_address, CR,LF);
	  StrAllocCat(command, line);
d841 7
a847 9
	  char *cp = HTLoadedDocumentURL();
	  StrAllocCat(command, "Referer: ");
	  if (!strncasecomp(cp, "LYNXIMGMAP:", 11)) {
	      char *cp1 = strchr(cp, '#');
	      if (cp1)
		  *cp1 = '\0';
	      StrAllocCat(command, cp + 11);
	      if (cp1)
		  *cp1 = '#';
d849 1
a849 1
	      StrAllocCat(command, cp);
d851 1
a851 2
	  sprintf(line, "%c%c", CR, LF);
	  StrAllocCat(command, line);
d861 1
a861 1
	BOOL secure = (strncmp(anAnchor->address, "https", 5) ?
d913 2
a914 3
		sprintf(line, "%s%c%c", auth, CR, LF);
		StrAllocCat(command, line);
		CTRACE(tfp, "HTTP: Sending authorization: %s\n", auth);
d928 1
a928 1
		    if(did_connect)
d931 1
a931 1
		    FREE(command);
d941 1
a941 1
		CTRACE(tfp, "HTTP: Not sending authorization (yet).\n");
d948 1
a948 1
		cookie = LYCookie(host2, path2, port2, secure);
d960 1
a960 1
	    cookie = LYCookie(hostname, abspath, portnumber, secure);
d972 3
a974 3
		StrAllocCat(command, "Cookie2: $Version=\"1\"");
		StrAllocCat(command, crlf);
		CTRACE(tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n");
d982 4
a985 4
		StrAllocCat(command, "Cookie: ");
		StrAllocCat(command, cookie);
		StrAllocCat(command, crlf);
		CTRACE(tfp, "HTTP: Sending Cookie: %s\n", cookie);
d1008 2
a1009 3
	    sprintf(line, "%s%c%c", auth, CR, LF);
	    StrAllocCat(command, line);
	    CTRACE(tfp, (auth_proxy ?
d1012 1
a1012 1
			auth);
d1028 1
a1028 1
		FREE(command);
d1035 1
a1035 1
	    CTRACE(tfp, (auth_proxy ?
d1037 1
a1037 1
			 "HTTP: Not sending authorization (yet).\n"));
d1045 1
d1047 1
a1047 3
    if (!do_connect && do_post) {
#else
    if (do_post) {
d1049 16
a1064 17
	CTRACE (tfp, "HTTP: Doing post, content-type '%s'\n",
		     anAnchor->post_content_type ? anAnchor->post_content_type
						 : "lose");
      sprintf (line, "Content-type: %s%c%c",
	       anAnchor->post_content_type ? anAnchor->post_content_type
					   : "lose", CR, LF);
      StrAllocCat(command, line);
      {
	int content_length;
	if (!anAnchor->post_data)
	  content_length = 0;
	else
	  content_length = strlen (anAnchor->post_data);
	sprintf (line, "Content-length: %d%c%c",
		 content_length, CR, LF);
	StrAllocCat(command, line);
      }
d1066 1
a1066 1
      StrAllocCat(command, crlf);	/* Blank line means "end" of headers */
d1068 1
a1068 1
      StrAllocCat(command, anAnchor->post_data);
d1070 2
a1071 2
  else
      StrAllocCat(command, crlf);	/* Blank line means "end" of headers */
d1073 3
d1077 2
a1078 3
  CTRACE (tfp, "Writing:\n%s%s----------------------------------\n",
	       command,
	       (anAnchor->post_data && !do_connect ? crlf : ""));
d1080 2
a1081 3
  CTRACE (tfp, "Writing:\n%s%s----------------------------------\n",
	       command,
	       (anAnchor->post_data ? crlf : ""));
d1083 2
d1091 1
a1091 1
      for ( p = command; p < command + strlen(command); p++ )
d1095 3
a1097 2
  status = HTTP_NETWRITE(s, command, (int)strlen(command), handle);
  FREE(command);
d1100 1
a1100 1
	  CTRACE (tfp, "HTTP: Got status 0 in initial write\n");
d1108 1
a1108 1
	    **	Arrrrgh, HTTP 0/1 compability problem, maybe.
d1110 1
a1110 1
	    CTRACE (tfp, "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n");
d1117 1
a1117 1
	  CTRACE (tfp, "HTTP: Hit unexpected network WRITE error; aborting connection.\n");
d1125 1
a1125 1
  CTRACE (tfp, "HTTP: WRITE delivered OK\n");
d1136 1
a1136 1
    line_buffer = (char *)calloc(1, (buffer_length * sizeof(char)));
d1152 1
a1152 2
	CTRACE (tfp, "HTTP: Trying to read %d\n",
		     buffer_length - length - 1);
d1155 1
a1155 1
	CTRACE (tfp, "HTTP: Read %d\n", status);
d1162 1
a1162 1
		CTRACE (tfp, "HTTP: Interrupted initial read.\n");
d1169 3
d1178 1
a1178 1
		CTRACE (tfp, "HTTP: BONZO Trying again with HTTP0 request.\n");
d1188 2
a1189 2
		CTRACE (tfp, "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			   status);
d1225 1
d1249 2
d1255 1
a1255 1
  CTRACE(tfp, "HTTP: Rx: %s\n", line_buffer);
d1271 1
a1271 1
      CTRACE(tfp, "HTTP: close socket %d to retry with HTTP0\n", s);
a1281 1
    int server_status;
d1289 1
a1289 1
    CTRACE (tfp, "HTTP: Scanned %d fields from line_buffer\n", fields);
d1294 1
a1294 1
	error_file = fopen(http_error_file, "w");
d1300 1
a1300 1
	error_file = fopen(http_error_file, "a");
d1321 1
a1321 1
	CTRACE (tfp, "--- Talking HTTP0.\n");
d1330 1
a1330 1
	    CTRACE(tfp, "HTTP: format_in being changed to text/HTML\n");
d1337 1
a1337 1
	    CTRACE(tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in));
d1341 2
a1342 2
	    CTRACE(tfp, "        Treating as '%s' with encoding '%s'\n",
			"www/compressed", HTAtom_name(encoding));
d1351 1
a1351 1
	CTRACE (tfp, "--- Talking HTTP1.\n");
d1409 1
d1447 4
a1450 4
#ifdef USE_SSL
	        if (do_connect) {
		    CTRACE(tfp, "HTTP: Proxy tunnel to '%s' established.\n",
				connect_host);
d1456 2
a1457 2
			CTRACE(tfp,
			"      Will attempt handshake and snews connection.\n");
d1469 1
a1469 1
	            permanent_redirection = FALSE;
d1471 2
a1472 2
		    CTRACE(tfp,
			"      Will attempt handshake and resubmit headers.\n");
a1594 2
	      char *cp;

d1613 1
a1613 28
	      /*
	       *  Get the rest of the headers and data, if
	       *  any, and then close the connection. - FM
	       */
	      while ((status = HTTP_NETREAD(s, line_buffer,
					    (INIT_LINE_SIZE - 1),
					    handle)) > 0) {
#ifdef    NOT_ASCII  /* S/390 -- gil -- 0581 */
	      {   char *p;

		  for ( p = line_buffer; p < line_buffer + status; p++ )
		      *p = FROMASCII(*p);
	      }
#endif /* NOT_ASCII */
		  line_buffer[status] = '\0';
		  StrAllocCat(line_kept_clean, line_buffer);
	      }
	      HTTP_NETCLOSE(s, handle);
	      if (status == HT_INTERRUPTED) {
		  /*
		   *  Impatient user. - FM
		   */
		  CTRACE (tfp, "HTTP: Interrupted followup read.\n");
		  _HTProgress (CONNECTION_INTERRUPTED);
		  status = HT_INTERRUPTED;
		  goto clean_up;
	      }
	      doing_redirect = TRUE;
a1614 1
		  HTProgress(line_buffer);
d1620 1
a1620 1
		      CTRACE(tfp, "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n");
d1627 1
a1628 334
	      /*
	      **  Look for "Set-Cookie:" and "Set-Cookie2:" headers. - FM
	      */
	      if (LYSetCookies == TRUE) {
		  char *value = NULL;
		  char *SetCookie = NULL;
		  char *SetCookie2 = NULL;
		  cp = line_kept_clean;
		  while (*cp) {
		      /*
		      **  Assume a CRLF pair terminates
		      **  the header section. - FM
		      */
		      if (*cp == CR) {
			  if (*(cp+1) == LF &&
			      *(cp+2) == CR && *(cp+3) == LF) {
			      break;
			  }
		      }
		      if (TOUPPER(*cp) != 'S') {
			  cp++;
		      } else if (!strncasecomp(cp, "Set-Cookie:", 11))	{
			  char *cp1 = NULL, *cp2 = NULL;
			  cp += 11;
Cookie_continuation:
			  /*
			   *  Trim leading spaces. - FM
			   */
			  while (isspace((unsigned char)*cp))
			      cp++;
			  /*
			  **  Accept CRLF, LF, or CR as end of line. - FM
			  */
			  if (((cp1 = strchr(cp, LF)) != NULL) ||
			      (cp2 = strchr(cp, CR)) != NULL) {
			      if (*cp1) {
				  *cp1 = '\0';
				  if ((cp2 = strchr(cp, CR)) != NULL)
				      *cp2 = '\0';
			      } else {
				  *cp2 = '\0';
			      }
			  }
			  if (*cp == '\0') {
			      if (cp1)
				  *cp1 = LF;
			      if (cp2)
				  *cp2 = CR;
			      if (value != NULL) {
				  HTMIME_TrimDoubleQuotes(value);
				  if (SetCookie == NULL) {
				      StrAllocCopy(SetCookie, value);
				  } else {
				      StrAllocCat(SetCookie, ", ");
				      StrAllocCat(SetCookie, value);
				  }
				  FREE(value);
			      }
			      break;
			  }
			  StrAllocCat(value, cp);
			  cp += strlen(cp);
			  if (cp1) {
			      *cp1 = LF;
			      cp1 = NULL;
			  }
			  if (cp2) {
			      *cp2 = CR;
			      cp2 = NULL;
			  }
			  cp1 = cp;
			  if (*cp1 == CR)
			     cp1++;
			  if (*cp1 == LF)
			     cp1++;
			  if (*cp1 == ' ' || *cp1 == '\t') {
			      StrAllocCat(value, " ");
			      cp = cp1;
			      cp++;
			      cp1 = NULL;
			      goto Cookie_continuation;
			  }
			  HTMIME_TrimDoubleQuotes(value);
			  if (SetCookie == NULL) {
			      StrAllocCopy(SetCookie, value);
			  } else {
			      StrAllocCat(SetCookie, ", ");
			      StrAllocCat(SetCookie, value);
			  }
			  FREE(value);
		      } else if (!strncasecomp(cp, "Set-Cookie2:", 12))  {
			  char *cp1 = NULL, *cp2 = NULL;
			  cp += 12;
Cookie2_continuation:
			  /*
			   *  Trim leading spaces. - FM
			   */
			  while (isspace((unsigned char)*cp))
			      cp++;
			  /*
			  **  Accept CRLF, LF, or CR as end of line. - FM
			  */
			  if (((cp1 = strchr(cp, LF)) != NULL) ||
			      (cp2 = strchr(cp, CR)) != NULL) {
			      if (*cp1) {
				  *cp1 = '\0';
				  if ((cp2 = strchr(cp, CR)) != NULL)
				      *cp2 = '\0';
			      } else {
				  *cp2 = '\0';
			      }
			  }
			  if (*cp == '\0') {
			      if (cp1)
				  *cp1 = LF;
			      if (cp2)
				  *cp2 = CR;
			      if (value != NULL) {
				  HTMIME_TrimDoubleQuotes(value);
				  if (SetCookie2 == NULL) {
				      StrAllocCopy(SetCookie2, value);
				  } else {
				      StrAllocCat(SetCookie2, ", ");
				      StrAllocCat(SetCookie2, value);
				  }
				  FREE(value);
			      }
			      break;
			  }
			  StrAllocCat(value, cp);
			  cp += strlen(cp);
			  if (cp1) {
			      *cp1 = LF;
			      cp1 = NULL;
			  }
			  if (cp2) {
			      *cp2 = CR;
			      cp2 = NULL;
			  }
			  cp1 = cp;
			  if (*cp1 == CR)
			     cp1++;
			  if (*cp1 == LF)
			     cp1++;
			  if (*cp1 == ' ' || *cp1 == '\t') {
			      StrAllocCat(value, " ");
			      cp = cp1;
			      cp++;
			      cp1 = NULL;
			      goto Cookie2_continuation;
			  }
			  HTMIME_TrimDoubleQuotes(value);
			  if (SetCookie2 == NULL) {
			      StrAllocCopy(SetCookie2, value);
			  } else {
			      StrAllocCat(SetCookie2, ", ");
			      StrAllocCat(SetCookie2, value);
			  }
			  FREE(value);
		      } else {
			  cp++;
		      }
		  }
		  FREE(value);
		  if (SetCookie != NULL || SetCookie2 != NULL) {
		      LYSetCookie(SetCookie, SetCookie2, anAnchor->address);
		      FREE(SetCookie);
		      FREE(SetCookie2);
		  }
	      }

	      /*
	       *  Look for the "Location:" in the headers. - FM
	       */
	      cp = line_kept_clean;
	      while (*cp) {
		if (TOUPPER(*cp) != 'L') {
		    cp++;
		} else if (!strncasecomp(cp, "Location:", 9)) {
		    char *cp1 = NULL, *cp2 = NULL;
		    cp += 9;
		    /*
		     *	Trim leading spaces. - FM
		     */
		    while (isspace((unsigned char)*cp))
			cp++;
		    /*
		     *	Accept CRLF, LF, or CR as end of header. - FM
		     */
		    if (((cp1 = strchr(cp, LF)) != NULL) ||
			(cp2 = strchr(cp, CR)) != NULL) {
			if (*cp1) {
			    *cp1 = '\0';
			    if ((cp2 = strchr(cp, CR)) != NULL)
				*cp2 = '\0';
			} else {
			    *cp2 = '\0';
			}
			/*
			 *  Load the new URL into redirecting_url,
			 *  and make sure it's not zero-length. - FM
			 */
			StrAllocCopy(redirecting_url, cp);
			HTMIME_TrimDoubleQuotes(redirecting_url);
			if (*redirecting_url == '\0') {
			    /*
			     *	The "Location:" value is zero-length, and
			     *	thus is probably something in the body, so
			     *	we'll show the user what was returned. - FM
			     */
			    CTRACE(tfp, "HTTP: 'Location:' is zero-length!\n");
			    if (cp1)
				*cp1 = LF;
			    if (cp2)
				*cp2 = CR;
			    bad_location = TRUE;
			    FREE(redirecting_url);
			    HTAlert(
			       gettext("Got redirection with a bad Location header."));
			    HTProgress(line_buffer);
			    break;
			}

			/*
			 *  Set up for checking redirecting_url in
			 *  LYGetFile.c for restrictions before we
			 *  seek the document at that Location. - FM
			 */
			HTProgress(line_buffer);
			CTRACE(tfp, "HTTP: Picked up location '%s'\n",
				    redirecting_url);
			if (cp1)
			    *cp1 = LF;
			if (cp2)
			    *cp2 = CR;
			if (server_status == 305) { /* Use Proxy */
			    /*
			     *	Make sure the proxy field ends with
			     *	a slash. - FM
			     */
			    if (redirecting_url[strlen(redirecting_url)-1]
				!= '/')
				StrAllocCat(redirecting_url, "/");
			    /*
			     *	Append our URL. - FM
			     */
			    StrAllocCat(redirecting_url, anAnchor->address);
			    CTRACE(tfp, "HTTP: Proxy URL is '%s'\n",
					redirecting_url);
			}
			if (!do_post ||
			    server_status == 303 ||
			    server_status == 302) {
			    /*
			     *	We don't have POST content (nor support PUT
			     *	or DELETE), or the status is "See Other"  or
			     *	"General Redirection" and we can convert to
			     *	GET, so go back and check out the new URL. - FM
			     */
			    status = HT_REDIRECTING;
			    goto clean_up;
			}
			/*
			 *  Make sure the user wants to redirect
			 *  the POST content, or treat as GET - FM & DK
			 */
			switch (HTConfirmPostRedirect(redirecting_url,
						      server_status)) {
			    /*
			     *	User failed to confirm.
			     *	Abort the fetch.
			     */
			    case 0:
				doing_redirect = FALSE;
				FREE(redirecting_url);
				status = HT_NO_DATA;
				goto clean_up;

			    /*
			     *	User wants to treat as GET with no content.
			     *	Go back to check out the URL.
			     */
			    case 303:
				status = HT_REDIRECTING;
				goto clean_up;

			    /*
			     *	Set the flag to retain the POST
			     *	content and go back to check out
			     *	the URL. - FM
			     */
			    default:
				status = HT_REDIRECTING;
				redirect_post_content = TRUE;
				goto clean_up;
			}
		    }
		    break;
		} else {
		    /*
		     *	Keep looking for the Location header. - FM
		     */
		    cp++;
		}
	      }

	      /*
	       *  If we get to here, we didn't find the Location
	       *  header, so we'll show the user what we got, if
	       *  anything. - FM
	       */
	      CTRACE (tfp, "HTTP: Failed to pick up location.\n");
	      doing_redirect = FALSE;
	      permanent_redirection = FALSE;
	      start_of_data = line_kept_clean;
	      length = strlen(start_of_data);
	      if (!bad_location) {
		  HTAlert(gettext("Got redirection with no Location header."));
		  HTProgress(line_buffer);
	      }
	      if (traversal) {
		  HTTP_NETCLOSE(s, handle);
		  status = -1;
		  goto clean_up;
	      }
	      if (!dump_output_immediately &&
		  format_out == HTAtom_for("www/download")) {
		  /*
		   *  Convert a download request to
		   *  a presentation request for
		   *  interactive users. - FM
		   */
		  format_out = WWW_PRESENT;
	      }
d1662 1
a1662 1
		    CTRACE(tfp, "%s %d %s\n",
d1664 1
a1664 1
				"to retry with Access Authorization");
d1715 1
a1715 1
		    CTRACE(tfp, "%s %d %s\n",
d1717 1
a1717 1
				"to retry with Proxy Authorization");
d1862 7
d1880 6
a1885 1
      length = strlen(start_of_data);
d1887 18
d1912 1
a1912 1
      char buffer[1024];	/* @@@@@@@@@@@@@@@@ */
d1915 1
a1915 1
      sprintf(buffer, CANNOT_CONVERT_I_TO_O,
d1918 1
d1933 8
d1946 4
a1949 1
      status = HT_INTERRUPTED;
d1959 1
a1959 3
      HTTP_NETCLOSE(s, handle);
      if (!already_retrying && !do_post) {
	  CTRACE (tfp, "HTTP: Trying again with HTTP0 request.\n");
d1961 2
a1962 1
	  **  May as well consider it an interrupt -- right?
d1964 1
a1964 6
	  FREE(line_buffer);
	  FREE(line_kept_clean);
	  extensions = NO;
	  already_retrying = TRUE;
	  _HTProgress (RETRYING_AS_HTTP0);
	  goto try_again;
d1966 16
a1981 2
	  status = HT_NOT_LOADED;
	  goto clean_up;
d1989 1
a1989 1
  if (rv != HT_INTERRUPTED) {
d1996 94
a2089 10
      /*
      **  We already jumped over all this if the "case 3:" code worked
      **  above, but we'll check here as a backup in case it fails. - FM
      */
      /* Lou's old comment:  - FM */
      /* OK, now we've got the redirection URL temporarily stored
	 in external variable redirecting_url, exported from HTMIME.c,
	 since there's no straightforward way to do this in the library
	 currently.  Do the right thing. */
      status = HT_REDIRECTING;
d2117 1
a2117 1
    handle = NULL;
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d1 7
a7 7
/*	HyperText Tranfer Protocol	- Client implementation		HTTP.c
 *	==========================
 * Modified:
 * 27 Jan 1994	PDM  Added Ari Luotonen's Fix for Reload when using proxy
 *		     servers.
 * 28 Apr 1997	AJL,FM Do Proxy Authorisation.
 */
d14 5
a18 2
#include <HTNews.h>
#endif
a38 1
#include <HTAccess.h>		/* Are we using an HTTP gateway? */
a43 1
#include <LYrcFile.h>
d46 3
a48 2
struct _HTStream {
    HTStreamClass *isa;
d51 22
a72 4
BOOL reloading = FALSE;		/* Reloading => send no-cache pragma to proxy */
char *redirecting_url = NULL;	/* Location: value. */
BOOL permanent_redirection = FALSE;	/* Got 301 status? */
BOOL redirect_post_content = FALSE;	/* Don't convert to GET? */
d75 1
a75 3
SSL_CTX *ssl_ctx = NULL;	/* SSL ctx */
SSL *SSL_handle = NULL;
static int ssl_okay;
d77 1
a77 1
static void free_ssl_ctx(void)
d80 1
a80 21
	SSL_CTX_free(ssl_ctx);
}

static int HTSSLCallback(int preverify_ok, X509_STORE_CTX * x509_ctx)
{
    char *msg = NULL;
    int result = 1;

    if (!(preverify_ok || ssl_okay || ssl_noprompt)) {
#ifdef USE_X509_SUPPORT
	HTSprintf0(&msg, "SSL error:%s-Continue?",
		   X509_verify_cert_error_string(X509_STORE_CTX_get_error(x509_ctx)));
	if (HTForcedPrompt(ssl_noprompt, msg, YES))
	    ssl_okay = 1;
	else
	    result = 0;
#endif

	FREE(msg);
    }
    return result;
d83 1
a83 1
SSL *HTGetSSLHandle(void)
d86 2
a87 2
	/*
	 * First time only.
d90 1
a90 1
	ssl_ctx = SSL_CTX_new();
a96 1
	SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, HTSSLCallback);
d100 1
a100 41
    ssl_okay = 0;
    return (SSL_new(ssl_ctx));
}

void HTSSLInitPRNG(void)
{
#if SSLEAY_VERSION_NUMBER >= 0x00905100
    if (RAND_status() == 0) {
	char rand_file[256];
	time_t t;
	int pid;
	long l, seed;

	t = time(NULL);
	pid = getpid();
	RAND_file_name(rand_file, 256);
	CTRACE((tfp, "HTTP: Seeding PRNG\n"));
	if (rand_file != NULL) {
	    /* Seed as much as 1024 bytes from RAND_file_name */
	    RAND_load_file(rand_file, 1024);
	}
	/* Seed in time (mod_ssl does this) */
	RAND_seed((unsigned char *) &t, sizeof(time_t));
	/* Seed in pid (mod_ssl does this) */
	RAND_seed((unsigned char *) &pid, sizeof(pid));
	/* Initialize system's random number generator */
	RAND_bytes((unsigned char *) &seed, sizeof(long));

	lynx_srand(seed);
	while (RAND_status() == 0) {
	    /* Repeatedly seed the PRNG using the system's random number generator until it has been seeded with enough data */
	    l = lynx_rand();
	    RAND_seed((unsigned char *) &l, sizeof(long));
	}
	if (rand_file != NULL) {
	    /* Write a rand_file */
	    RAND_write_file(rand_file);
	}
    }
#endif /* SSLEAY_VERSION_NUMBER >= 0x00905100 */
    return;
d108 1
a108 1
	{ (void)NETCLOSE(sock); if (handle) SSL_free(handle); SSL_handle = handle = NULL; }
d110 4
a119 232
#ifdef _WINDOWS			/* 1997/11/06 (Thu) 13:00:08 */

#define	BOX_TITLE	"Lynx " __FILE__
#define	BOX_FLAG	(MB_ICONINFORMATION | MB_SETFOREGROUND)

typedef struct {
    int fd;
    char *buf;
    int len;
} recv_data_t;

int ws_read_per_sec = 0;
static int ws_errno = 0;

static DWORD g_total_times = 0;
static DWORD g_total_bytes = 0;

char *str_speed(void)
{
    static char buff[32];

    if (ws_read_per_sec > 1000)
	sprintf(buff, "%d.%03dkB", ws_read_per_sec / 1000,
		(ws_read_per_sec % 1000));
    else
	sprintf(buff, "%3d", ws_read_per_sec);

    return buff;
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

static int ws_read(int fd, char *buf, int len)
{
    int res;
    int retry = 3;

    do {
	res = recv(fd, buf, len, 0);
	if (WSAEWOULDBLOCK == WSAGetLastError()) {
	    Sleep(100);
	    if (retry-- > 0)
		continue;
	}
    } while (res == SOCKET_ERROR && SOCKET_ERRNO == EINTR);

    return res;
}

static DWORD __stdcall _thread_func(void *p)
{
    int i, val, ret;
    recv_data_t *q = (recv_data_t *) p;

    i = 0;
    i++;
    val = ws_read(q->fd, q->buf, q->len);

    if (val == SOCKET_ERROR) {
	ws_errno = WSAGetLastError();
#if 0
	char buff[256];

	sprintf(buff, "Thread read: %d, error (%ld), fd = %d, len = %d",
		i, ws_errno, q->fd, q->len);
	MessageBox(NULL, buff, BOX_TITLE, BOX_FLAG);
#endif
	ret = -1;
    } else {
	ret = val;
    }

    return ((DWORD) ret);
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

int ws_netread(int fd, char *buf, int len)
{
    int i;
    char buff[256];

    /* 1998/03/30 (Mon) 09:01:21 */
    HANDLE hThread;
    DWORD dwThreadID;
    DWORD exitcode = 0;
    DWORD ret_val = -1, val, process_time, now_TickCount, save_TickCount;

    static recv_data_t para;

    extern int win32_check_interrupt(void);	/* LYUtil.c */
    extern int lynx_timeout;	/* LYMain.c */
    extern CRITICAL_SECTION critSec_READ;	/* LYMain.c */

#define TICK	5
#define STACK_SIZE	0x2000uL

    InitializeCriticalSection(&critSec_READ);

    para.fd = fd;
    para.buf = buf;
    para.len = len;

    ws_read_per_sec = 0;
    save_TickCount = GetTickCount();

    hThread = CreateThread(NULL, STACK_SIZE,
			   _thread_func,
			   (void *) &para, 0UL, &dwThreadID);

    if (hThread == 0) {
	HTInfoMsg("CreateThread Failed (read)");
	goto read_exit;
    }

    i = 0;
    while (1) {
	val = WaitForSingleObject(hThread, 1000 / TICK);
	i++;
	if (val == WAIT_FAILED) {
	    HTInfoMsg("Wait Failed");
	    ret_val = -1;
	    break;
	} else if (val == WAIT_TIMEOUT) {
	    i++;
	    if (i / TICK > (AlertSecs + 2)) {
		sprintf(buff, "Read Waiting (%2d.%01d) for %d Bytes",
			i / TICK, (i % TICK) * 10 / TICK, len);
		SetConsoleTitle(buff);
	    }
	    if (win32_check_interrupt() || ((i / TICK) > lynx_timeout)) {
		if (CloseHandle(hThread) == FALSE) {
		    HTInfoMsg("Thread terminate Failed");
		}
		WSASetLastError(ETIMEDOUT);
		ret_val = HT_INTERRUPTED;
		break;
	    }
	} else if (val == WAIT_OBJECT_0) {
	    if (GetExitCodeThread(hThread, &exitcode) == FALSE) {
		exitcode = -1;
	    }
	    if (CloseHandle(hThread) == FALSE) {
		HTInfoMsg("Thread terminate Failed");
	    }
	    now_TickCount = GetTickCount();
	    if (now_TickCount > save_TickCount)
		process_time = now_TickCount - save_TickCount;
	    else
		process_time = now_TickCount + (0xffffffff - save_TickCount);

	    g_total_times += process_time;
	    g_total_bytes += exitcode;

	    if (g_total_bytes > 2000000) {
		ws_read_per_sec = g_total_bytes / (g_total_times / 1000);
	    } else {
		ws_read_per_sec = g_total_bytes * 1000 / g_total_times;
	    }
	    ret_val = exitcode;
	    break;
	}
    }				/* end while(1) */

  read_exit:
    LeaveCriticalSection(&critSec_READ);
    return ret_val;
}
#endif

/*
 * Strip any username from the given string so we retain only the host.
 */
static void strip_userid(char *host)
{
    char *p1 = host;
    char *p2 = strchr(host, '@@');
    char *fake;

    if (p2 != 0) {
	*p2++ = '\0';
	if ((fake = HTParse(host, "", PARSE_HOST)) != NULL) {
	    char *msg = NULL;

	    CTRACE((tfp, "parsed:%s\n", fake));
	    HTSprintf0(&msg, gettext("Address contains a username: %s"), host);
	    HTAlert(msg);
	    FREE(msg);
	}
	while ((*p1++ = *p2++) != '\0') {
	    ;
	}
    }
}

/*
 * Check if the user's options specified to use the given encoding.  Normally
 * all encodings with compiled-in support are specified (encodingALL).
 */
static BOOL acceptEncoding(int code)
{
    BOOL result = FALSE;

    if ((code & LYAcceptEncoding) != 0) {
	const char *program = 0;

	switch (code) {
	case encodingGZIP:
	    program = HTGetProgramPath(ppGZIP);
	    break;
	case encodingDEFLATE:
	    program = HTGetProgramPath(ppINFLATE);
	    break;
	case encodingCOMPRESS:
	    program = HTGetProgramPath(ppCOMPRESS);
	    break;
	case encodingBZIP2:
	    program = HTGetProgramPath(ppBZIP2);
	    break;
	default:
	    break;
	}
	/*
	 * FIXME:  if lynx did not rely upon external programs to decompress
	 * files for external viewers, this check could be relaxed.
	 */
	result = (program != 0);
    }
    return result;
}
d122 21
a142 20
 *		==============================
 *
 *	Given a hypertext address, this routine loads a document.
 *
 *
 *  On entry,
 *	arg	is the hypertext reference of the article to be loaded.
 *
 *  On exit,
 *	returns >=0	If no error, a good socket number
 *		<0	Error.
 *
 *	The socket must be closed by the caller after the document has been
 *	read.
 *
 */
static int HTLoadHTTP(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *sink)
d144 28
a171 31
    static char *empty = "";
    int s;			/* Socket number for returned data */
    const char *url = arg;	/* The URL which get_physical() returned */
    bstring *command = NULL;	/* The whole command */
    char *eol;			/* End of line if found */
    char *start_of_data;	/* Start of body of reply */
    int status;			/* tcp return */
    int bytes_already_read;
    char crlf[3];		/* A CR LF equivalent string */
    HTStream *target;		/* Unconverted data */
    HTFormat format_in;		/* Format arriving in the message */
    BOOL do_head = FALSE;	/* Whether or not we should do a head */
    BOOL do_post = FALSE;	/* ARE WE posting ? */
    const char *METHOD;

    BOOL had_header;		/* Have we had at least one header? */
    char *line_buffer;
    char *line_kept_clean;
    int real_length_of_line;
    BOOL extensions;		/* Assume good HTTP server */
    char *linebuf = NULL;
    char temp[80];
    BOOL first_Accept = TRUE;
    BOOL show_401 = FALSE;
    BOOL show_407 = FALSE;
    BOOL auth_proxy = NO;	/* Generate a proxy authorization. - AJL */

    int length, rawlength, rv;
    int server_status;
    BOOL doing_redirect, already_retrying = FALSE;
    int len = 0;
d174 5
a178 11
    BOOL do_connect = FALSE;	/* ARE WE going to use a proxy tunnel ? */
    BOOL did_connect = FALSE;	/* ARE WE actually using a proxy tunnel ? */
    const char *connect_url = NULL;	/* The URL being proxied */
    char *connect_host = NULL;	/* The host being proxied */
    SSL *handle = NULL;		/* The SSL handle */
    char ssl_dn[256];
    char *cert_host;
    char *ssl_host;
    char *p;
    char *msg = NULL;

d180 1
a180 1
    BOOL try_tls = TRUE;
a181 1
    SSL_handle = NULL;
d183 1
a183 1
    void *handle = NULL;
d186 16
a201 15
    if (anAnchor->isHEAD)
	do_head = TRUE;
    else if (anAnchor->post_data)
	do_post = TRUE;

    if (!url) {
	status = -3;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
    if (!*url) {
	status = -2;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
d203 21
a223 21
    if (using_proxy && !strncmp(url, "http://", 7)) {
	if ((connect_url = strstr((url + 7), "https://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "https", PARSE_HOST);
	    if (!strchr(connect_host, ':')) {
		sprintf(temp, ":%d", HTTPS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	} else if ((connect_url = strstr((url + 7), "snews://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "snews", PARSE_HOST);
	    if (!strchr(connect_host, ':')) {
		sprintf(temp, ":%d", SNEWS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	}
    }
d226 1
a226 6
    sprintf(crlf, "%c%c", CR, LF);

    /*
     * At this point, we're talking HTTP/1.0.
     */
    extensions = YES;
d228 19
a246 14
  try_again:
    /*
     * All initializations are moved down here from up above, so we can start
     * over here...
     */
    eol = 0;
    had_header = NO;
    length = 0;
    doing_redirect = FALSE;
    permanent_redirection = FALSE;
    redirect_post_content = FALSE;
    target = NULL;
    line_buffer = NULL;
    line_kept_clean = NULL;
d248 1
d250 3
a252 4
    if (!strncmp(url, "https", 5))
	status = HTDoConnect(url, "HTTPS", HTTPS_PORT, &s);
    else
	status = HTDoConnect(url, "HTTP", HTTP_PORT, &s);
d254 4
a257 4
    if (!strncmp(url, "https", 5)) {
	HTAlert(gettext("This client does not contain support for HTTPS URLs."));
	status = HT_NOT_LOADED;
	goto done;
d259 1
a259 1
    status = HTDoConnect(arg, "HTTP", HTTP_PORT, &s);
d261 17
a277 23
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp, "HTTP: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	status = HT_NOT_LOADED;
	goto done;
    }
    if (status < 0) {
#ifdef _WINDOWS
	CTRACE((tfp, "HTTP: Unable to connect to remote host for `%s'\n"
		" (status = %d, sock_errno = %d).\n",
		url, status, SOCKET_ERRNO));
#else
	CTRACE((tfp,
		"HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
		url, SOCKET_ERRNO));
#endif
	HTAlert(gettext("Unable to connect to remote host."));
	status = HT_NOT_LOADED;
	goto done;
    }
d279 8
a286 7
  use_tunnel:
    /*
     * If this is an https document, then do the SSL stuff here.
     */
    if (did_connect || !strncmp(url, "https", 5)) {
	SSL_handle = handle = HTGetSSLHandle();
	SSL_set_fd(handle, s);
d288 2
a289 2
	if (!try_tls)
	    handle->options |= SSL_OP_NO_TLSv1;
d291 1
a291 2
	HTSSLInitPRNG();
	status = SSL_connect(handle);
d293 1
a293 1
	if (status <= 0) {
d295 17
a311 22
	    if (try_tls) {
		_HTProgress(gettext("Retrying connection without TLS."));
		try_tls = FALSE;
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		goto try_again;
	    } else {
		unsigned long SSLerror;

		CTRACE((tfp,
			"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
			url, status));
		SSL_load_error_strings();
		while ((SSLerror = ERR_get_error()) != 0) {
		    CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
		}
		HTAlert("Unable to make secure connection to remote host.");
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		status = HT_NOT_LOADED;
		goto done;
	    }
d313 8
a320 14
	    unsigned long SSLerror;

	    CTRACE((tfp,
		    "HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		    url, status));
	    SSL_load_error_strings();
	    while ((SSLerror = ERR_get_error()) != 0) {
		CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
	    }
	    HTAlert("Unable to make secure connection to remote host.");
	    if (did_connect)
		HTTP_NETCLOSE(s, handle);
	    status = HT_NOT_LOADED;
	    goto done;
d322 2
a323 33
	}

	X509_NAME_oneline(X509_get_subject_name(SSL_get_peer_certificate(handle)),
			  ssl_dn, sizeof(ssl_dn));
	if ((cert_host = strstr(ssl_dn, "/CN=")) == NULL) {
	    HTSprintf0(&msg,
		       gettext("SSL error:Can't find common name in certificate-Continue?"));
	    if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		status = HT_NOT_LOADED;
		FREE(msg);
		goto done;
	    }
	} else {
	    cert_host += 4;
	    if ((p = strchr(cert_host, '/')) != NULL)
		*p = '\0';
	    if ((p = strchr(cert_host, ':')) != NULL)
		*p = '\0';
	    ssl_host = HTParse(url, "", PARSE_HOST);
	    if ((p = strchr(ssl_host, ':')) != NULL)
		*p = '\0';
	    if (strcasecomp(ssl_host, cert_host)) {
		HTSprintf0(&msg,
			   gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
			   ssl_host,
			   cert_host);
		if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		    status = HT_NOT_LOADED;
		    FREE(msg);
		    goto done;
		}
	    }
	}
d325 12
a336 8
	HTSprintf0(&msg,
		   gettext("Secure %d-bit %s (%s) HTTP connection"),
		   SSL_get_cipher_bits(handle, NULL),
		   SSL_get_cipher_version(handle),
		   SSL_get_cipher(handle));
	_HTProgress(msg);
	FREE(msg);
    }
d339 5
a343 4
    /* Ask that node for the document, omitting the host name & anchor
     */
    {
	char *p1 = (HTParse(url, "", PARSE_PATH | PARSE_PUNCTUATION));
d346 4
a349 4
	if (do_connect) {
	    METHOD = "CONNECT";
	    BStrCopy0(command, "CONNECT ");
	} else
d351 10
a360 10
	if (do_post) {
	    METHOD = "POST";
	    BStrCopy0(command, "POST ");
	} else if (do_head) {
	    METHOD = "HEAD";
	    BStrCopy0(command, "HEAD ");
	} else {
	    METHOD = "GET";
	    BStrCopy0(command, "GET ");
	}
d362 5
a366 5
	/*
	 * If we are using a proxy gateway don't copy in the first slash of
	 * say:  /gopher://a;lkdjfl;ajdf;lkj/;aldk/adflj so that just
	 * gopher://....  is sent.
	 */
d368 6
a373 6
	if (using_proxy && !did_connect) {
	    if (do_connect)
		BStrCat0(command, connect_host);
	    else
		BStrCat0(command, p1 + 1);
	}
d375 2
a376 2
	if (using_proxy)
	    BStrCat0(command, p1 + 1);
d378 95
a472 83
	else
	    BStrCat0(command, p1);
	FREE(p1);
    }
    if (extensions) {
	BStrCat0(command, " ");
	BStrCat0(command, HTTP_VERSION);
    }

    BStrCat0(command, crlf);	/* CR LF, as in rfc 977 */

    if (extensions) {
	int n, i;
	char *host = NULL;

	if ((host = HTParse(anAnchor->address, "", PARSE_HOST)) != NULL) {
	    strip_userid(host);
	    HTBprintf(&command, "Host: %s%c%c", host, CR, LF);
	    FREE(host);
	}

	if (!HTPresentations)
	    HTFormatInit();
	n = HTList_count(HTPresentations);

	first_Accept = TRUE;
	len = 0;
	for (i = 0; i < n; i++) {
	    HTPresentation *pres =
	    (HTPresentation *) HTList_objectAt(HTPresentations, i);

	    if (pres->get_accept) {
		if (pres->quality < 1.0) {
		    if (pres->maxbytes > 0) {
			sprintf(temp, ";q=%4.3f;mxb=%ld",
				pres->quality, pres->maxbytes);
		    } else {
			sprintf(temp, ";q=%4.3f", pres->quality);
		    }
		} else if (pres->maxbytes > 0) {
		    sprintf(temp, ";mxb=%ld", pres->maxbytes);
		} else {
		    temp[0] = '\0';
		}
		HTSprintf0(&linebuf, "%s%s%s",
			   (first_Accept ?
			    "Accept: " : ", "),
			   HTAtom_name(pres->rep),
			   temp);
		len += strlen(linebuf);
		if (len > 252 && !first_Accept) {
		    BStrCat0(command, crlf);
		    HTSprintf0(&linebuf, "Accept: %s%s",
			       HTAtom_name(pres->rep),
			       temp);
		    len = strlen(linebuf);
		}
		BStrCat0(command, linebuf);
		first_Accept = FALSE;
	    }
	}
	HTBprintf(&command, "%s*/*;q=0.01%c%c",
		  (first_Accept ?
		   "Accept: " : ", "), CR, LF);
	first_Accept = FALSE;
	len = 0;

	/*
	 * FIXME:  suppressing the "Accept-Encoding" in this case is done to
	 * work around limitations of the presentation logic used for the
	 * command-line "-base" option.  The remote site may transmit the
	 * document gzip'd, but the ensuing logic in HTSaveToFile() would see
	 * the mime-type as gzip rather than text/html, and not prepend the
	 * base URL.  This is less efficient than accepting the compressed data
	 * and uncompressing it, adding the base URL but is simpler than
	 * augmenting the dump's presentation logic -TD
	 */
	if (LYPrependBaseToSource && dump_output_immediately) {
	    CTRACE((tfp,
		    "omit Accept-Encoding to work-around interaction with -source\n"));
	} else {
	    char *list = 0;
	    int j, k;
a473 36
	    for (j = 1; j < encodingALL; j <<= 1) {
		if (acceptEncoding(j)) {
		    for (k = 0; tbl_preferred_encoding[k].name != 0; ++k) {
			if (tbl_preferred_encoding[k].value == j) {
			    if (list != 0)
				StrAllocCat(list, ", ");
			    StrAllocCat(list, tbl_preferred_encoding[k].name);
			    break;
			}
		    }
		}
	    }

	    if (list != 0) {
		HTBprintf(&command, "Accept-Encoding: %s%c%c", list, CR, LF);
		free(list);
	    }
	}

	if (language && *language) {
	    HTBprintf(&command, "Accept-Language: %s%c%c", language, CR, LF);
	}

	if (pref_charset && *pref_charset) {
	    BStrCat0(command, "Accept-Charset: ");
	    StrAllocCopy(linebuf, pref_charset);
	    if (linebuf[strlen(linebuf) - 1] == ',')
		linebuf[strlen(linebuf) - 1] = '\0';
	    LYLowerCase(linebuf);
	    if (strstr(linebuf, "iso-8859-1") == NULL)
		StrAllocCat(linebuf, ", iso-8859-1;q=0.01");
	    if (strstr(linebuf, "us-ascii") == NULL)
		StrAllocCat(linebuf, ", us-ascii;q=0.01");
	    BStrCat0(command, linebuf);
	    HTBprintf(&command, "%c%c", CR, LF);
	}
d475 26
a500 25
	/*
	 * Promote 300 (Multiple Choices) replies, if supported, over 406 (Not
	 * Acceptable) replies.  - FM
	 *
	 * This used to be done in versions 2.7 and 2.8*, but violates the
	 * specs for transparent content negotiation and has the effect that
	 * servers supporting those specs will send 300 (Multiple Choices)
	 * instead of a normal response (e.g.  200 OK), since they will assume
	 * that the client wants to make the choice.  It is not clear whether
	 * there are any servers or sites for which sending this header really
	 * improves anything.
	 *
	 * If there ever is a need to send "Negotiate:  trans" and really mean
	 * it, we should send "Negotiate:  trans,trans" or similar, since that
	 * is semantically equivalent and some servers may ignore "Negotiate: 
	 * trans" as a special case when it comes from Lynx (to work around the
	 * old faulty behavior).  - kw
	 *
	 * References:
	 * RFC 2295 (see also RFC 2296), and mail to lynx-dev and
	 * new-httpd@@apache.org from Koen Holtman, Jan 1999.
	 */
	if (!do_post) {
	    HTBprintf(&command, "Negotiate: trans%c%c", CR, LF);
	}
d503 68
a570 23
	/*
	 * When reloading give no-cache pragma to proxy server to make it
	 * refresh its cache.  -- Ari L.  <luotonen@@dxcern.cern.ch>
	 *
	 * Also send it as a Cache-Control header for HTTP/1.1.  - FM
	 */
	if (reloading) {
	    HTBprintf(&command, "Pragma: no-cache%c%c", CR, LF);
	    HTBprintf(&command, "Cache-Control: no-cache%c%c", CR, LF);
	}

	if (LYUserAgent && *LYUserAgent) {
	    char *cp = LYSkipBlanks(LYUserAgent);

	    /* Won't send it at all if all blank - kw */
	    if (*cp != '\0')
		HTBprintf(&command, "User-Agent: %.*s%c%c",
			  INIT_LINE_SIZE - 15, LYUserAgent, CR, LF);
	} else {
	    HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
		      HTAppName ? HTAppName : "unknown",
		      HTAppVersion ? HTAppVersion : "0.0",
		      HTLibraryVersion, CR, LF);
d573 5
a577 130
	if (personal_mail_address && !LYNoFromHeader) {
	    HTBprintf(&command, "From: %s%c%c", personal_mail_address, CR, LF);
	}

	if (!(LYUserSpecifiedURL ||
	      LYNoRefererHeader || LYNoRefererForThis) &&
	    strcmp(HTLoadedDocumentURL(), "")) {
	    const char *cp = LYRequestReferer;

	    if (!cp)
		cp = HTLoadedDocumentURL();	/* @@@@@@ Try both? - kw */
	    BStrCat0(command, "Referer: ");
	    if (isLYNXIMGMAP(cp)) {
		char *pound = findPoundSelector(cp);
		int nn = (pound ? (int) (pound - cp) : (int) strlen(cp));

		HTSABCat(&command, cp + LEN_LYNXIMGMAP, nn);
	    } else {
		BStrCat0(command, cp);
	    }
	    HTBprintf(&command, "%c%c", CR, LF);
	} {
	    char *abspath;
	    char *docname;
	    char *hostname;
	    char *colon;
	    int portnumber;
	    char *auth, *cookie = NULL;
	    BOOL secure = (BOOL) (strncmp(anAnchor->address, "https", 5) ?
				  FALSE : TRUE);

	    abspath = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);
	    docname = HTParse(arg, "", PARSE_PATH);
	    hostname = HTParse(arg, "", PARSE_HOST);
	    if (hostname &&
		NULL != (colon = strchr(hostname, ':'))) {
		*(colon++) = '\0';	/* Chop off port number */
		portnumber = atoi(colon);
	    } else if (!strncmp(arg, "https", 5)) {
		portnumber = HTTPS_PORT;
	    } else {
		portnumber = HTTP_PORT;
	    }

	    /*
	     * Add Authorization, Proxy-Authorization, and/or Cookie headers,
	     * if applicable.
	     */
	    if (using_proxy) {
		/*
		 * If we are using a proxy, first determine if we should
		 * include an Authorization header and/or Cookie header for the
		 * ultimate target of this request.  - FM & AJL
		 */
		char *host2 = NULL, *path2 = NULL;
		int port2 = (strncmp(docname, "https", 5) ?
			     HTTP_PORT : HTTPS_PORT);

		host2 = HTParse(docname, "", PARSE_HOST);
		path2 = HTParse(docname, "", PARSE_PATH | PARSE_PUNCTUATION);
		if (host2) {
		    if ((colon = strchr(host2, ':')) != NULL) {
			/* Use non-default port number */
			*colon = '\0';
			colon++;
			port2 = atoi(colon);
		    }
		}
		/*
		 * This composeAuth() does file access, i.e., for the ultimate
		 * target of the request.  - AJL
		 */
		auth_proxy = NO;
		if ((auth = HTAA_composeAuth(host2, port2, path2,
					     auth_proxy)) != NULL &&
		    *auth != '\0') {
		    /*
		     * If auth is not NULL nor zero-length, it's an
		     * Authorization header to be included.  - FM
		     */
		    HTBprintf(&command, "%s%c%c", auth, CR, LF);
		    CTRACE((tfp, "HTTP: Sending authorization: %s\n", auth));
		} else if (auth && *auth == '\0') {
		    /*
		     * If auth is a zero-length string, the user either
		     * cancelled or goofed at the username and password prompt. 
		     * - FM
		     */
		    if (!(traversal || dump_output_immediately) &&
			HTConfirm(CONFIRM_WO_PASSWORD)) {
			show_401 = TRUE;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_NEED_PASSWD);
#ifdef USE_SSL
			if (did_connect)
			    HTTP_NETCLOSE(s, handle);
#endif /* USE_SSL */
			BStrFree(command);
			FREE(hostname);
			FREE(docname);
			FREE(abspath);
			FREE(host2);
			FREE(path2);
			status = HT_NOT_LOADED;
			goto done;
		    }
		} else {
		    CTRACE((tfp, "HTTP: Not sending authorization (yet).\n"));
		}
		/*
		 * Add 'Cookie:' header, if it's HTTP or HTTPS document being
		 * proxied.
		 */
		if (!strncmp(docname, "http", 4)) {
		    cookie = LYAddCookieHeader(host2, path2, port2, secure);
		}
		FREE(host2);
		FREE(path2);
		/*
		 * The next composeAuth() will be for the proxy.  - AJL
		 */
		auth_proxy = YES;
	    } else {
		/*
		 * Add cookie for a non-proxied request.  - FM
		 */
		cookie = LYAddCookieHeader(hostname, abspath, portnumber, secure);
		auth_proxy = NO;
	    }
d579 16
a594 22
	     * If we do have a cookie set, add it to the request buffer.  - FM
	     */
	    if (cookie != NULL) {
		if (*cookie != '$') {
		    /*
		     * It's a historical cookie, so signal to the server that
		     * we support modern cookies.  - FM
		     */
		    BStrCat0(command, "Cookie2: $Version=\"1\"");
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n"));
		}
		if (*cookie != '\0') {
		    /*
		     * It's not a zero-length string, so add the header.  Note
		     * that any folding of long strings has been done already
		     * in LYCookie.c.  - FM
		     */
		    BStrCat0(command, "Cookie: ");
		    BStrCat0(command, cookie);
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie: %s\n", cookie));
a595 1
		FREE(cookie);
a596 2
	    FREE(abspath);

d598 5
a602 9
	     * If we are using a proxy, auth_proxy should be YES, and we check
	     * here whether we want a Proxy-Authorization header for it.  If we
	     * are not using a proxy, auth_proxy should still be NO, and we
	     * check here for whether we want an Authorization header.  - FM &
	     * AJL
	     */
	    if ((auth = HTAA_composeAuth(hostname,
					 portnumber,
					 docname,
d606 6
a611 8
		 * If auth is not NULL nor zero-length, it's an Authorization
		 * or Proxy-Authorization header to be included.  - FM
		 */
		HTBprintf(&command, "%s%c%c", auth, CR, LF);
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Sending proxy authorization: %s\n" :
			      "HTTP: Sending authorization: %s\n"),
			auth));
d614 7
a620 9
		 * If auth is a zero-length string, the user either cancelled
		 * or goofed at the username and password prompt.  - FM
		 */
		if (!(traversal || dump_output_immediately) && HTConfirm(CONFIRM_WO_PASSWORD)) {
		    if (auth_proxy == TRUE) {
			show_407 = TRUE;
		    } else {
			show_401 = TRUE;
		    }
d624 5
a628 1
		    BStrFree(command);
d631 3
d638 8
a645 3
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Not sending proxy authorization (yet).\n" :
			      "HTTP: Not sending authorization (yet).\n")));
d647 12
a658 2
	    FREE(hostname);
	    FREE(docname);
d660 82
a741 2
	auth_proxy = NO;
    }
a742 1
    if (
d744 3
a746 1
	   !do_connect &&
d748 17
a764 16
	   do_post) {
	CTRACE((tfp, "HTTP: Doing post, content-type '%s'\n",
		anAnchor->post_content_type
		? anAnchor->post_content_type
		: "lose"));
	HTBprintf(&command, "Content-type: %s%c%c",
		  anAnchor->post_content_type
		  ? anAnchor->post_content_type
		  : "lose",
		  CR, LF);

	HTBprintf(&command, "Content-length: %d%c%c",
		  !isBEmpty(anAnchor->post_data)
		  ? BStrLen(anAnchor->post_data)
		  : 0,
		  CR, LF);
d766 1
a766 1
	BStrCat0(command, crlf);	/* Blank line means "end" of headers */
d768 4
a771 3
	BStrCat(command, anAnchor->post_data);
    } else
	BStrCat0(command, crlf);	/* Blank line means "end" of headers */
a772 3
    if (TRACE) {
	CTRACE((tfp, "Writing:\n"));
	trace_bstring(command);
d774 3
a776 2
	CTRACE((tfp, "%s",
		(anAnchor->post_data && !do_connect ? crlf : "")));
d778 3
a780 2
	CTRACE((tfp, "%s",
		(anAnchor->post_data ? crlf : "")));
a781 2
	CTRACE((tfp, "----------------------------------\n"));
    }
d783 1
a783 1
    _HTProgress(gettext("Sending HTTP request."));
d785 2
a786 3
#ifdef    NOT_ASCII		/* S/390 -- gil -- 0548 */
    {
	char *p2;
d788 3
a790 5
	for (p2 = BStrData(command);
	     p2 < BStrData(command) + BStrLen(command);
	     p2++)
	    *p2 = TOASCII(*p2);
    }
d792 11
a802 12
    status = HTTP_NETWRITE(s, BStrData(command), BStrLen(command), handle);
    BStrFree(command);
    FREE(linebuf);
    if (status <= 0) {
	if (status == 0) {
	    CTRACE((tfp, "HTTP: Got status 0 in initial write\n"));
	    /* Do nothing. */
	} else if ((SOCKET_ERRNO == ENOTCONN ||
		    SOCKET_ERRNO == ECONNRESET ||
		    SOCKET_ERRNO == EPIPE) &&
		   !already_retrying &&
	    /* Don't retry if we're posting. */ !do_post) {
d804 4
a807 5
	     * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
	     */
	    CTRACE((tfp,
		    "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n"));
	    _HTProgress(RETRYING_AS_HTTP0);
d812 23
a834 9
	} else {
	    CTRACE((tfp,
		    "HTTP: Hit unexpected network WRITE error; aborting connection.\n"));
	    HTTP_NETCLOSE(s, handle);
	    status = -1;
	    HTAlert(gettext("Unexpected network write error; connection aborted."));
	    goto done;
	}
    }
d836 18
a853 18
    CTRACE((tfp, "HTTP: WRITE delivered OK\n"));
    _HTProgress(gettext("HTTP request sent; waiting for response."));

    /*    Read the first line of the response
     * -----------------------------------
     */
    {
	/* Get numeric status etc */
	BOOL end_of_file = NO;
	int buffer_length = INIT_LINE_SIZE;

	line_buffer = typecallocn(char, buffer_length);

	if (line_buffer == NULL)
	    outofmem(__FILE__, "HTLoadHTTP");

	HTReadProgress(bytes_already_read = 0, 0);
	do {			/* Loop to read in the first line */
d855 2
a856 1
	     * Extend line buffer if necessary for those crazy WAIS URLs ;-)
d858 18
a875 4
	    if (buffer_length - length < LINE_EXTEND_THRESH) {
		buffer_length = buffer_length + buffer_length;
		line_buffer =
		    (char *) realloc(line_buffer, (buffer_length * sizeof(char)));
d877 11
a887 2
		if (line_buffer == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
d889 1
a889 31
	    CTRACE((tfp, "HTTP: Trying to read %d\n", buffer_length - length - 1));
	    status = HTTP_NETREAD(s, line_buffer + length,
				  buffer_length - length - 1, handle);
	    CTRACE((tfp, "HTTP: Read %d\n", status));
	    if (status <= 0) {
		/*
		 * Retry if we get nothing back too.
		 * Bomb out if we get nothing twice.
		 */
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp, "HTTP: Interrupted initial read.\n"));
		    _HTProgress(CONNECTION_INTERRUPTED);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;
		} else if (status < 0 &&
			   (SOCKET_ERRNO == ENOTCONN ||
#ifdef _WINDOWS			/* 1997/11/09 (Sun) 16:59:58 */
			    SOCKET_ERRNO == ETIMEDOUT ||
#endif
			    SOCKET_ERRNO == ECONNRESET ||
			    SOCKET_ERRNO == EPIPE) &&
			   !already_retrying && !do_post) {
		    /*
		     * Arrrrgh, HTTP 0/1 compability problem, maybe.
		     */
		    CTRACE((tfp,
			    "HTTP: BONZO Trying again with HTTP0 request.\n"));
		    HTTP_NETCLOSE(s, handle);
		    FREE(line_buffer);
		    FREE(line_kept_clean);
d891 2
a892 17
		    extensions = NO;
		    already_retrying = TRUE;
		    _HTProgress(RETRYING_AS_HTTP0);
		    goto try_again;
		} else {
		    CTRACE((tfp,
			    "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			    status));
		    HTAlert(gettext("Unexpected network read error; connection aborted."));
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
	    }
#ifdef    NOT_ASCII		/* S/390 -- gil -- 0564 */
	    {
		char *p2;
d894 3
a896 5
		for (p2 = line_buffer + length;
		     p2 < line_buffer + length + status;
		     p2++)
		    *p2 = FROMASCII(*p2);
	    }
d899 2
a900 2
	    bytes_already_read += status;
	    HTReadProgress(bytes_already_read, 0);
d902 2
a903 2
#ifdef UCX			/* UCX returns -1 on EOF */
	    if (status == 0 || status == -1)
d905 1
a905 1
	    if (status == 0)
d907 3
a909 26
	    {
		end_of_file = YES;
		break;
	    }
	    line_buffer[length + status] = 0;

	    if (line_buffer) {
		FREE(line_kept_clean);
		line_kept_clean = (char *) malloc(buffer_length * sizeof(char));

		if (line_kept_clean == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
		memcpy(line_kept_clean, line_buffer, buffer_length);
		real_length_of_line = length + status;
	    }

	    eol = strchr(line_buffer + length, LF);
	    /* Do we *really* want to do this? */
	    if (eol && eol != line_buffer && *(eol - 1) == CR)
		*(eol - 1) = ' ';

	    length = length + status;

	    /* Do we really want to do *this*? */
	    if (eol)
		*eol = 0;	/* Terminate the line */
d911 1
a911 9
	/* All we need is the first line of the response.  If it's a HTTP/1.0
	 * response, then the first line will be absurdly short and therefore
	 * we can safely gate the number of bytes read through this code (as
	 * opposed to below) to ~1000.
	 *
	 * Well, let's try 100.
	 */
	while (!eol && !end_of_file && bytes_already_read < 100);
    }				/* Scope of loop variables */
d913 61
a973 7
    /* save total length, in case we decide later to show it all - kw */
    rawlength = length;

    /*    We now have a terminated unfolded line.  Parse it.
     * --------------------------------------------------
     */
    CTRACE((tfp, "HTTP: Rx: %s\n", line_buffer));
d975 1
a975 28
    /*
     * Kludge to work with old buggy servers and the VMS Help gateway.  They
     * can't handle the third word, so we try again without it.
     */
    if (extensions &&		/* Old buggy server or Help gateway? */
	(0 == strncmp(line_buffer, "<TITLE>Bad File Request</TITLE>", 31) ||
	 0 == strncmp(line_buffer, "Address should begin with", 25) ||
	 0 == strncmp(line_buffer, "<TITLE>Help ", 12) ||
	 0 == strcmp(line_buffer,
		     "Document address invalid or access not authorised"))) {
	FREE(line_buffer);
	FREE(line_kept_clean);
	extensions = NO;
	already_retrying = TRUE;
	CTRACE((tfp, "HTTP: close socket %d to retry with HTTP0\n", s));
	HTTP_NETCLOSE(s, handle);
	/* print a progress message */
	_HTProgress(RETRYING_AS_HTTP0);
	goto try_again;
    } {
	int fields;
	char server_version[VERSION_LENGTH + 1];

	server_version[0] = 0;

	fields = sscanf(line_buffer, "%20s %d",
			server_version,
			&server_status);
d977 3
a979 1
	CTRACE((tfp, "HTTP: Scanned %d fields from line_buffer\n", fields));
d981 1
a981 2
	if (http_error_file) {	/* Make the status code externally available */
	    FILE *error_file;
d983 2
d986 5
a990 5
	    error_file = fopen(http_error_file, TXT_W);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "error=%d\n", server_status);
		fclose(error_file);
	    }
d992 6
a997 6
	    error_file = fopen(http_error_file, TXT_A);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "   URL=%s (%s)\n", url, METHOD);
		fprintf(error_file, "STATUS=%s\n", line_buffer);
		fclose(error_file);
	    }
d999 1
a999 1
	}
d1001 7
d1009 1
a1009 1
	 * Rule out a non-HTTP/1.n reply as best we can.
d1011 15
a1025 4
	if (fields < 2 || !server_version[0] || server_version[0] != 'H' ||
	    server_version[1] != 'T' || server_version[2] != 'T' ||
	    server_version[3] != 'P' || server_version[4] != '/' ||
	    server_version[6] != '.') {
d1027 17
a1043 3
	     * Ugh!  An HTTP0 reply,
	     */
	    HTAtom *encoding;
d1045 10
a1054 1
	    CTRACE((tfp, "--- Talking HTTP0.\n"));
d1056 12
a1067 1
	    format_in = HTFileFormat(url, &encoding, NULL);
d1069 24
a1092 6
	     * Treat all plain text as HTML.  This sucks but its the only
	     * solution without without looking at content.
	     */
	    if (!strncmp(HTAtom_name(format_in), "text/plain", 10)) {
		CTRACE((tfp, "HTTP: format_in being changed to text/HTML\n"));
		format_in = WWW_HTML;
d1094 2
a1095 1
	    if (!IsUnityEnc(encoding)) {
d1097 1
a1097 1
		 * Change the format to that for "www/compressed".
d1099 4
a1102 7
		CTRACE((tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in)));
		StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
		StrAllocCopy(anAnchor->content_encoding, HTAtom_name(encoding));
		format_in = HTAtom_for("www/compressed");
		CTRACE((tfp, "        Treating as '%s' with encoding '%s'\n",
			"www/compressed", HTAtom_name(encoding)));
	    }
d1104 12
a1115 7
	    start_of_data = line_kept_clean;
	} else {
	    /*
	     * Set up to decode full HTTP/1.n response.  - FM
	     */
	    format_in = HTAtom_for("www/mime");
	    CTRACE((tfp, "--- Talking HTTP1.\n"));
d1117 11
a1127 9
	    /*
	     * We set start_of_data to "" when !eol here because there will be
	     * a put_block done below; we do *not* use the value of
	     * start_of_data (as a pointer) in the computation of length (or
	     * anything else) when !eol.  Otherwise, set the value of length to
	     * what we have beyond eol (i.e., beyond the status line).  - FM
	     */
	    start_of_data = eol ? eol + 1 : empty;
	    length = eol ? length - (start_of_data - line_buffer) : 0;
d1129 41
a1169 6
	    /*
	     * Trim trailing spaces in line_buffer so that we can use it in
	     * messages which include the status line.  - FM
	     */
	    while (line_buffer[strlen(line_buffer) - 1] == ' ')
		line_buffer[strlen(line_buffer) - 1] = '\0';
d1171 1
d1173 16
a1188 12
	     * Take appropriate actions based on the status.  - FM
	     */
	    switch (server_status / 100) {
	    case 1:
		/*
		 * HTTP/1.1 Informational statuses.
		 * 100 Continue.
		 * 101 Switching Protocols.
		 * > 101 is unknown.
		 * We should never get these, and they have only the status
		 * line and possibly other headers, so we'll deal with them by
		 * showing the full header to the user as text/plain.  - FM
d1190 1
a1190 2
		HTAlert(gettext("Got unexpected Informational Status."));
		do_head = TRUE;
d1192 1
d1194 1
a1194 1
	    case 2:
d1196 9
a1204 1
		 * Good:  Got MIME object!  (Successful) - FM
d1206 2
a1207 14
		if (do_head) {
		    /*
		     * If HEAD was requested, show headers (and possibly bogus
		     * body) for all 2xx status codes as text/plain - KW
		     */
		    HTProgress(line_buffer);
		    break;
		}
		switch (server_status) {
		case 204:
		    /*
		     * No Content.
		     */
		    HTAlert(line_buffer);
d1209 1
a1209 2
		    HTNoDataOK = 1;
		    status = HT_NO_DATA;
d1211 3
a1213 2

		case 205:
d1215 3
a1217 4
		     * Reset Content.  The server has fulfilled the request but
		     * nothing is returned and we should reset any form
		     * content.  We'll instruct the user to do that, and
		     * restore the current document.  - FM
d1219 4
a1222 4
		    HTAlert(gettext("Request fulfilled.  Reset Content."));
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;
d1224 9
a1232 52
		case 206:
		    /*
		     * Partial Content.  We didn't send a Range so something
		     * went wrong somewhere.  Show the status message and
		     * restore the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;

		default:
		    /*
		     * 200 OK.
		     * 201 Created.
		     * 202 Accepted.
		     * 203 Non-Authoritative Information.
		     * > 206 is unknown.
		     * All should return something to display.
		     */
#if defined(USE_SSL) && !defined(DISABLE_NEWS)
		    if (do_connect) {
			CTRACE((tfp,
				"HTTP: Proxy tunnel to '%s' established.\n",
				connect_host));
			do_connect = FALSE;
			url = connect_url;
			FREE(line_buffer);
			FREE(line_kept_clean);
			if (!strncmp(connect_url, "snews", 5)) {
			    CTRACE((tfp,
				    "      Will attempt handshake and snews connection.\n"));
			    status = HTNewsProxyConnect(s, url, anAnchor,
							format_out, sink);
			    goto done;
			}
			did_connect = TRUE;
			already_retrying = TRUE;
			eol = 0;
			bytes_already_read = 0;
			had_header = NO;
			length = 0;
			doing_redirect = FALSE;
			permanent_redirection = FALSE;
			target = NULL;
			CTRACE((tfp,
				"      Will attempt handshake and resubmit headers.\n"));
			goto use_tunnel;
		    }
#endif /* USE_SSL */
		    HTProgress(line_buffer);
		}		/* case 2 switch */
d1234 1
d1236 3
a1238 1
	    case 3:
d1240 2
a1241 10
		 * Various forms of Redirection.  - FM
		 * 300 Multiple Choices.
		 * 301 Moved Permanently.
		 * 302 Found (temporary; we can, and do, use GET).
		 * 303 See Other (temporary; always use GET).
		 * 304 Not Modified.
		 * 305 Use Proxy.
		 * 306 Set Proxy.
		 * 307 Temporary Redirect with method retained.
		 * > 308 is unknown.
d1243 8
a1250 1
		if (no_url_redirection || do_head || keep_mime_headers) {
d1252 3
a1254 3
		     * If any of these flags are set, we do not redirect, but
		     * instead show what was returned to the user as
		     * text/plain.  - FM
d1256 1
a1256 2
		    HTProgress(line_buffer);
		    break;
d1258 2
d1261 26
a1286 28
		if (server_status == 300) {	/* Multiple Choices */
		    /*
		     * For client driven content negotiation.  The server
		     * should be sending some way for the user-agent to make a
		     * selection, so we'll show the user whatever the server
		     * returns.  There might be a Location:  header with the
		     * server's preference present, but the choice should be up
		     * to the user, someday based on an Alternates:  header,
		     * and a body always should be present with descriptions
		     * and links for the choices (i.e., we use the latter, for
		     * now).  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}
d1288 242
a1529 1
		if (server_status == 304) {	/* Not Modified */
d1531 1
a1531 3
		     * We didn't send an "If-Modified-Since" header, so this
		     * status is inappropriate.  We'll deal with it by showing
		     * the full header to the user as text/plain.  - FM
d1533 2
a1534 8
		    HTAlert(gettext("Got unexpected 304 Not Modified status."));
		    do_head = TRUE;
		    break;
		}

		if (server_status == 305 ||
		    server_status == 306 ||
		    server_status > 307) {
d1536 1
a1536 2
		     * Show user the content, if any, for 305, 306, or unknown
		     * status.  - FM
d1538 9
a1546 8
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
d1548 2
a1549 2
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
d1551 20
a1570 4
			format_out = WWW_PRESENT;
		    }
		    break;
		}
a1571 28
		/*
		 * We do not load the file, but read the headers for the
		 * "Location:", check out that redirecting_url and if it's
		 * acceptible (e.g., not a telnet URL when we have that
		 * disabled), initiate a new fetch.  If that's another
		 * redirecting_url, we'll repeat the checks, and fetch
		 * initiations if acceptible, until we reach the actual URL, or
		 * the redirection limit set in HTAccess.c is exceeded.  If the
		 * status was 301 indicating that the relocation is permanent,
		 * we set the permanent_redirection flag to make it permanent
		 * for the current anchor tree (i.e., will persist until the
		 * tree is freed or the client exits).  If the redirection
		 * would include POST content, we seek confirmation from an
		 * interactive user, with option to use 303 for 301 (but not
		 * for 307), and otherwise refuse the redirection.  We also
		 * don't allow permanent redirection if we keep POST content. 
		 * If we don't find the Location header or it's value is
		 * zero-length, we display whatever the server returned, and
		 * the user should RELOAD that to try again, or make a
		 * selection from it if it contains links, or Left-Arrow to the
		 * previous document.  - FM
		 */
		{
		    if ((dump_output_immediately || traversal) &&
			do_post &&
			server_status != 303 &&
			server_status != 302 &&
			server_status != 301) {
d1573 41
a1613 2
			 * Don't redirect POST content without approval from an
			 * interactive user.  - FM
d1615 19
a1633 7
			HTTP_NETCLOSE(s, handle);
			status = -1;
			HTAlert(gettext("Redirection of POST content requires user approval."));
			if (traversal)
			    HTProgress(line_buffer);
			goto clean_up;
		    }
a1634 3
		    HTProgress(line_buffer);
		    if (server_status == 301) {		/* Moved Permanently */
			if (do_post) {
d1636 3
a1638 2
			     * Don't make the redirection permanent if we have
			     * POST content.  - FM
d1640 4
a1643 5
			    CTRACE((tfp,
				    "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n"));
			    HTAlert(gettext("Have POST content.  Treating Permanent Redirection as Temporary.\n"));
			} else {
			    permanent_redirection = TRUE;
a1645 2
		    doing_redirect = TRUE;

d1647 5
d1653 1
d1655 46
a1700 3
	    case 4:
		/*
		 * "I think I goofed!" (Client Error) - FM
d1702 3
a1704 13
		switch (server_status) {
		case 401:	/* Unauthorized */
		    /*
		     * Authorization for orgin server required.  If show_401 is
		     * set, proceed to showing the 401 body.  Otherwise, if we
		     * can set up authorization based on the WWW-Authenticate
		     * header, and the user provides a username and password,
		     * try again.  Otherwise, check whether to show the 401
		     * body or restore the current document.  - FM
		     */
		    if (show_401)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, NO)) {
d1706 9
a1714 9
			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !authentication_info[0]) {
			    fprintf(stderr,
				    "HTTP: Access authorization required.\n");
			    fprintf(stderr,
				    "       Use the -auth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}
d1716 1
a1716 1
			CTRACE((tfp, "%s %d %s\n",
d1718 1
a1718 1
				"to retry with Access Authorization"));
d1720 4
a1723 3
			_HTProgress(gettext("Retrying with access authorization information."));
			FREE(line_buffer);
			FREE(line_kept_clean);
d1725 5
a1729 5
			if (using_proxy && !strncmp(url, "https://", 8)) {
			    url = arg;
			    do_connect = TRUE;
			    did_connect = FALSE;
			}
d1731 11
a1741 11
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 401 message body?"))) {
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_AUTH);
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
d1743 15
a1757 13
		case 407:
		    /*
		     * Authorization for proxy server required.  If we are not
		     * in fact using a proxy, or show_407 is set, proceed to
		     * showing the 407 body.  Otherwise, if we can set up
		     * authorization based on the Proxy-Authenticate header,
		     * and the user provides a username and password, try
		     * again.  Otherwise, check whether to show the 401 body or
		     * restore the current document.  - FM & AJL
		     */
		    if (!using_proxy || show_407)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, YES)) {
d1759 7
a1765 34
			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !proxyauth_info[0]) {
			    fprintf(stderr,
				    "HTTP: Proxy authorization required.\n");
			    fprintf(stderr,
				    "       Use the -pauth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}

			CTRACE((tfp, "%s %d %s\n",
				"HTTP: close socket", s,
				"to retry with Proxy Authorization"));

			_HTProgress(HTTP_RETRY_WITH_PROXY);
			FREE(line_buffer);
			FREE(line_kept_clean);
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 407 message body?"))) {
			if (!dump_output_immediately &&
			    format_out == HTAtom_for("www/download")) {
			    /*
			     * Convert a download request to a presentation
			     * request for interactive users.  - FM
			     */
			    format_out = WWW_PRESENT;
			}
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_PROXY);
			HTTP_NETCLOSE(s, handle);
			status = -1;
d1769 3
a1771 9
		case 408:
		    /*
		     * Request Timeout.  Show the status message and restore
		     * the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto done;
d1773 6
a1778 26
		default:
		    /*
		     * 400 Bad Request.
		     * 402 Payment Required.
		     * 403 Forbidden.
		     * 404 Not Found.
		     * 405 Method Not Allowed.
		     * 406 Not Acceptable.
		     * 409 Conflict.
		     * 410 Gone.
		     * 411 Length Required.
		     * 412 Precondition Failed.
		     * 413 Request Entity Too Large.
		     * 414 Request-URI Too Long.
		     * 415 Unsupported Media Type.
		     * 416 List Response (for content negotiation).
		     * > 416 is unknown.
		     * Show the status message, and display the returned text
		     * if we are not doing a traversal.  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
d1782 3
a1784 2
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
d1789 7
a1795 2
		}		/* case 4 switch */
		break;
d1797 1
a1797 1
	    case 5:
d1799 2
a1800 10
		 * "I think YOU goofed!" (server error)
		 * 500 Internal Server Error
		 * 501 Not Implemented
		 * 502 Bad Gateway
		 * 503 Service Unavailable
		 * 504 Gateway Timeout
		 * 505 HTTP Version Not Supported
		 * > 505 is unknown.
		 * Should always include a message, which we always should
		 * display.  - FM
d1803 3
a1805 14
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
		    /*
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
		     */
		    format_out = WWW_PRESENT;
		}
		break;
d1807 1
a1807 1
	    default:
d1809 18
a1826 2
		 * Bad or unknown server_status number.  Take a chance and hope
		 * there is something to display.  - FM
a1827 1
		HTAlert(gettext("Unknown status reply from server!"));
d1837 3
a1839 2
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
d1844 2
a1845 4
	    }			/* Switch on server_status/100 */

	}			/* Full HTTP reply */
    }				/* scope of fields */
d1847 1
a1847 11
    /*
     * The user may have pressed the 'z'ap key during the pause caused by one
     * of the HTAlerts above if the server reported an error, to skip loading
     * of the error response page.  Checking here before setting up the stream
     * stack and feeding it data avoids doing unnecessary work, it also can
     * avoid unnecessarily pushing a loaded document out of the cache to make
     * room for the unwanted error page.  - kw
     */
    if (HTCheckForInterrupt()) {
	HTTP_NETCLOSE(s, handle);
	if (doing_redirect) {
d1849 19
a1867 104
	     * Impatient user.  - FM
	     */
	    CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	}
	status = HT_INTERRUPTED;
	goto clean_up;
    }
    /*
     * Set up the stream stack to handle the body of the message.
     */
    if (do_head || keep_mime_headers) {
	/*
	 * It was a HEAD request, or we want the headers and source.
	 */
	start_of_data = line_kept_clean;
#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
/* GIF file contains \0, so strlen does not return the data length */
	length = real_length_of_line;
#else
	length = rawlength;
#endif
	format_in = HTAtom_for("text/plain");

    } else if (doing_redirect) {

	format_in = HTAtom_for("message/x-http-redirection");
	StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
	if (traversal) {
	    format_out = WWW_DEBUG;
	    if (!sink)
		sink = HTErrorStream();
	} else if (!dump_output_immediately &&
		   format_out == HTAtom_for("www/download")) {
	    /*
	     * Convert a download request to a presentation request for
	     * interactive users.  - FM
	     */
	    format_out = WWW_PRESENT;
	}
    }

    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);

    if (target == NULL) {
	char *buffer = NULL;

	HTTP_NETCLOSE(s, handle);
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	_HTProgress(buffer);
	FREE(buffer);
	status = -1;
	goto clean_up;
    }

    /*
     * Recycle the first chunk of data, in all cases.
     */
    (*target->isa->put_block) (target, start_of_data, length);

    /*
     * Go pull the bulk of the data down.
     */
    rv = HTCopy(anAnchor, s, (void *) handle, target);

    /*
     * If we get here with doing_redirect set, it means that we were looking
     * for a Location header.  We either have got it now in redirecting_url -
     * in that case the stream should not have loaded any data.  Or we didn't
     * get it, in that case the stream may have presented the message body
     * normally.  - kw
     */

    if (rv == -1) {
	/*
	 * Intentional interrupt before data were received, not an error
	 */
/* (*target->isa->_abort)(target, NULL); *//* already done in HTCopy */
	if (doing_redirect && traversal)
	    status = -1;
	else
	    status = HT_INTERRUPTED;
	HTTP_NETCLOSE(s, handle);
	goto clean_up;
    }

    if (rv == -2) {
	/*
	 * Aw hell, a REAL error, maybe cuz it's a dumb HTTP0 server
	 */
	(*target->isa->_abort) (target, NULL);
	if (doing_redirect && redirecting_url) {
	    /*
	     * Got a location before the error occurred?  Then consider it an
	     * interrupt but proceed below as normal.  - kw
	     */
	    /* do nothing here */
	} else {
	    HTTP_NETCLOSE(s, handle);
	    if (!doing_redirect && !already_retrying && !do_post) {
		CTRACE((tfp, "HTTP: Trying again with HTTP0 request.\n"));
d1869 3
a1871 1
		 * May as well consider it an interrupt -- right?
d1873 1
a1873 9
		FREE(line_buffer);
		FREE(line_kept_clean);
		extensions = NO;
		already_retrying = TRUE;
		_HTProgress(RETRYING_AS_HTTP0);
		goto try_again;
	    } else {
		status = HT_NOT_LOADED;
		goto clean_up;
d1875 1
a1875 2
	}
    }
d1877 1
a1877 12
    /*
     * Free if complete transmission (socket was closed before return).  Close
     * socket if partial transmission (was freed on abort).
     */
    if (rv != HT_INTERRUPTED && rv != -2) {
	(*target->isa->_free) (target);
    } else {
	HTTP_NETCLOSE(s, handle);
    }

    if (doing_redirect) {
	if (redirecting_url) {
d1879 9
a1887 18
	     * Set up for checking redirecting_url in LYGetFile.c for
	     * restrictions before we seek the document at that Location.  - FM
	     */
	    CTRACE((tfp, "HTTP: Picked up location '%s'\n",
		    redirecting_url));
	    if (rv == HT_INTERRUPTED) {
		/*
		 * Intentional interrupt after data were received, not an error
		 * (probably).  We take it as a user request to abandon the
		 * redirection chain.
		 *
		 * This could reasonably be changed (by just removing this
		 * block), it would make sense if there are redirecting
		 * resources that "hang" after sending the headers.  - kw
		 */
		FREE(redirecting_url);
		CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
		status = HT_INTERRUPTED;
d1890 2
a1891 8
	    HTProgress(line_buffer);
	    if (server_status == 305) {		/* Use Proxy */
		/*
		 * Make sure the proxy field ends with a slash.  - FM
		 */
		if (redirecting_url[strlen(redirecting_url) - 1]
		    != '/')
		    StrAllocCat(redirecting_url, "/");
d1893 3
a1895 1
		 * Append our URL.  - FM
d1897 1
a1897 44
		StrAllocCat(redirecting_url, anAnchor->address);
		CTRACE((tfp, "HTTP: Proxy URL is '%s'\n",
			redirecting_url));
	    }
	    if (!do_post ||
		server_status == 303 ||
		server_status == 302) {
		/*
		 * We don't have POST content (nor support PUT or DELETE), or
		 * the status is "See Other" or "General Redirection" and we
		 * can convert to GET, so go back and check out the new URL.  -
		 * FM
		 */
		status = HT_REDIRECTING;
		goto clean_up;
	    }
	    /*
	     * Make sure the user wants to redirect the POST content, or treat
	     * as GET - FM & DK
	     */
	    switch (HTConfirmPostRedirect(redirecting_url,
					  server_status)) {
		/*
		 * User failed to confirm.  Abort the fetch.
		 */
	    case 0:
		doing_redirect = FALSE;
		FREE(redirecting_url);
		status = HT_NO_DATA;
		goto clean_up;

		/*
		 * User wants to treat as GET with no content.  Go back to
		 * check out the URL.
		 */
	    case 303:
		break;

		/*
		 * Set the flag to retain the POST content and go back to check
		 * out the URL.  - FM
		 */
	    default:
		redirect_post_content = TRUE;
d1899 2
d1902 2
a1903 5
	    /* Lou's old comment:  - FM */
	    /* OK, now we've got the redirection URL temporarily stored
	       in external variable redirecting_url, exported from HTMIME.c,
	       since there's no straightforward way to do this in the library
	       currently.  Do the right thing. */
d1905 126
a2030 27
	    status = HT_REDIRECTING;

	} else {
	    status = traversal ? -1 : HT_LOADED;
	}

    } else {
	/*
	 * If any data were received, treat as a complete transmission
	 */
	status = HT_LOADED;
    }

    /*
     * Clean up
     */
  clean_up:
    FREE(line_buffer);
    FREE(line_kept_clean);

  done:
    /*
     * Clear out on exit, just in case.
     */
    do_head = FALSE;
    do_post = FALSE;
    reloading = FALSE;
d2032 7
a2038 7
    do_connect = FALSE;
    did_connect = FALSE;
    FREE(connect_host);
    if (handle) {
	SSL_free(handle);
	SSL_handle = handle = NULL;
    }
d2040 1
a2040 1
    return status;
d2047 1
a2047 1
GLOBALDEF(HTProtocol, HTTP, _HTTP_C_GLOBALDEF_1_INIT);
d2049 1
a2049 1
GLOBALDEF(HTProtocol, HTTPS, _HTTP_C_GLOBALDEF_2_INIT);
d2051 2
a2052 4
GLOBALDEF HTProtocol HTTP =
{"http", HTLoadHTTP, 0};
GLOBALDEF HTProtocol HTTPS =
{"https", HTLoadHTTP, 0};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d1 1
a1 1
/*	HyperText Tranfer Protocol	- Client implementation		HTTP.c
d14 5
a18 2
#include <HTNews.h>
#endif
a38 1
#include <HTAccess.h>		/* Are we using an HTTP gateway? */
d53 6
d60 1
d66 8
a75 2
PUBLIC SSL * SSL_handle = NULL;
PUBLIC int ssl_okay;
d80 1
a80 20
	SSL_CTX_free(ssl_ctx);
}

PRIVATE int HTSSLCallback(int preverify_ok, X509_STORE_CTX *x509_ctx)
{
    char *msg = NULL;
    int result = 1;

    if (!(preverify_ok || ssl_okay || ssl_noprompt)) {

	HTSprintf0(&msg, "SSL error:%s-Continue?",
		   X509_verify_cert_error_string(X509_STORE_CTX_get_error(x509_ctx)));
	if (HTForcedPrompt(ssl_noprompt, msg, YES))
	    ssl_okay = 1;
	else
	    result = 0;

	FREE(msg);
    }
    return result;
d86 1
a86 1
	/*
d90 1
a90 1
	ssl_ctx = SSL_CTX_new();
a96 1
	SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, HTSSLCallback);
a99 1
    ssl_okay = 0;
a102 38
PUBLIC void HTSSLInitPRNG NOARGS
{
#if SSLEAY_VERSION_NUMBER >= 0x00905100
    if (RAND_status() == 0) {
	char rand_file[256];
	time_t t;
	int pid;
	long l,seed;

	t = time(NULL);
	pid = getpid();
	RAND_file_name(rand_file, 256);
	CTRACE((tfp,"HTTP: Seeding PRNG\n"));
	if(rand_file != NULL) {
	    /* Seed as much as 1024 bytes from RAND_file_name */
	    RAND_load_file(rand_file, 1024);
	}
	/* Seed in time (mod_ssl does this) */
	RAND_seed((unsigned char *)&t, sizeof(time_t));
	/* Seed in pid (mod_ssl does this) */
	RAND_seed((unsigned char *)&pid, sizeof(pid));
	/* Initialize system's random number generator */
	RAND_bytes((unsigned char *)&seed, sizeof(long));
	lynx_srand(seed);
	while (RAND_status() == 0) {
	    /* Repeatedly seed the PRNG using the system's random number generator until it has been seeded with enough data */
	    l = lynx_rand();
	    RAND_seed((unsigned char *)&l, sizeof(long));
	}
	if (rand_file != NULL) {
	    /* Write a rand_file */
	    RAND_write_file(rand_file);
	}
    }
#endif /* SSLEAY_VERSION_NUMBER >= 0x00905100 */
    return;
}

d108 1
a108 1
	{ (void)NETCLOSE(sock); if (handle) SSL_free(handle); SSL_handle = handle = NULL; }
d110 4
a119 198
#ifdef _WINDOWS		/* 1997/11/06 (Thu) 13:00:08 */

#define	BOX_TITLE	"Lynx " __FILE__
#define	BOX_FLAG	(MB_ICONINFORMATION | MB_SETFOREGROUND)

typedef struct {
	int fd;
	char *buf;
	int len;
} recv_data_t;

PUBLIC int ws_read_per_sec = 0;
PRIVATE int ws_errno = 0;

PRIVATE DWORD g_total_times = 0;
PRIVATE DWORD g_total_bytes = 0;


PUBLIC char * str_speed(void)
{
    static char buff[32];

    if (ws_read_per_sec > 1000)
	sprintf(buff, "%d.%03dkB", ws_read_per_sec / 1000,
			(ws_read_per_sec % 1000) );
    else
	sprintf(buff, "%3d", ws_read_per_sec);

    return buff;
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

PRIVATE int ws_read(int fd, char *buf, int len)
{
     int res;
     int retry = 3;

     do {
	res = recv(fd, buf, len, 0);
	if (WSAEWOULDBLOCK == WSAGetLastError()) {
	  Sleep(100);
	  if (retry-- > 0)
	    continue;
	}
     } while (res == SOCKET_ERROR && SOCKET_ERRNO == EINTR);

     return res;
}

PRIVATE void _thread_func (void *p)
{
    int i, val, ret;
    recv_data_t *q = (recv_data_t *)p;

    i = 0;
    i++;
    val = ws_read(q->fd, q->buf, q->len);

    if (val == SOCKET_ERROR) {
	ws_errno = WSAGetLastError();
#if 0
	char buff[256];
	sprintf(buff, "Thread read: %d, error (%ld), fd = %d, len = %d",
		i, ws_errno, q->fd, q->len);
	MessageBox(NULL, buff, BOX_TITLE, BOX_FLAG);
#endif
	ret = -1;
    } else {
	ret = val;
    }

    ExitThread((DWORD)ret);
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

PUBLIC int ws_netread(int fd, char *buf, int len)
{
    int i;
    char buff[256];

     /* 1998/03/30 (Mon) 09:01:21 */
    HANDLE hThread;
    DWORD dwThreadID;
    DWORD exitcode = 0;
    DWORD ret_val = -1, val, process_time, now_TickCount, save_TickCount;

    static recv_data_t para;

    extern int win32_check_interrupt(void);	/* LYUtil.c */
    extern int lynx_timeout;			/* LYMain.c */
    extern CRITICAL_SECTION critSec_READ;	/* LYMain.c */

#define TICK	5
#define STACK_SIZE	0x2000uL

    InitializeCriticalSection(&critSec_READ);

    para.fd = fd;
    para.buf = buf;
    para.len = len;

    ws_read_per_sec = 0;
    save_TickCount = GetTickCount();

    hThread = CreateThread((void *)NULL, STACK_SIZE,
		 (LPTHREAD_START_ROUTINE)_thread_func,
		 (void *)&para, 0UL, &dwThreadID);

    if (hThread == 0) {
	HTInfoMsg("CreateThread Failed (read)");
	goto read_exit;
    }

    i = 0;
    while (1) {
	val = WaitForSingleObject(hThread, 1000/TICK);
	i++;
	if (val == WAIT_FAILED) {
	    HTInfoMsg("Wait Failed");
	    ret_val = -1;
	    break;
	} else if (val == WAIT_TIMEOUT) {
	    i++;
	    if (i/TICK > (AlertSecs + 2)) {
		sprintf(buff, "Read Waiting (%2d.%01d) for %d Bytes",
			i/TICK, (i%TICK) * 10 / TICK, len);
		SetConsoleTitle(buff);
	    }
	    if (win32_check_interrupt() || ((i/TICK) > lynx_timeout)) {
		if (CloseHandle(hThread) == FALSE) {
		    HTInfoMsg("Thread terminate Failed");
		}
		WSASetLastError(ETIMEDOUT);
		ret_val = HT_INTERRUPTED;
		break;
	    }
	} else if (val == WAIT_OBJECT_0) {
	    if (GetExitCodeThread(hThread, &exitcode) == FALSE) {
		exitcode = -1;
	    }
	    if (CloseHandle(hThread) == FALSE) {
		HTInfoMsg("Thread terminate Failed");
	    }
	    now_TickCount = GetTickCount();
	    if (now_TickCount > save_TickCount)
		process_time = now_TickCount - save_TickCount;
	    else
		process_time = now_TickCount + (0xffffffff - save_TickCount);

	    g_total_times += process_time;
	    g_total_bytes += exitcode;

	    if (g_total_bytes > 2000000) {
		ws_read_per_sec = g_total_bytes / (g_total_times/1000);
	    } else {
		ws_read_per_sec = g_total_bytes * 1000 / g_total_times;
	    }
	    ret_val = exitcode;
	    break;
	}
    }	/* end while(1) */

    read_exit:
    LeaveCriticalSection(&critSec_READ);
    return ret_val;
}
#endif

/*
 * Strip any username from the given string so we retain only the host.
 * If the
 */
PRIVATE void strip_userid ARGS1(
	char *,		host)
{
    char *p1 = host;
    char *p2 = strchr(host, '@@');
    char *fake;

    if (p2 != 0) {
	*p2++ = '\0';
	if ((fake = HTParse(host, "", PARSE_HOST)) != NULL) {
	    char *msg = NULL;

	    CTRACE((tfp, "FIXME:%s\n", fake));
	    HTSprintf0(&msg, gettext("Address contains a username: %s"), host);
	    HTAlert(msg);
	    FREE(msg);
	}
	while ((*p1++ = *p2++) != '\0') {
	    ;
	}
    }
}
d146 1
a146 1
  bstring *command = NULL;	/* The whole command */
d151 1
a151 1
  char crlf[3];			/* A CR LF equivalent string */
d154 2
a155 2
  BOOL do_head = FALSE;		/* Whether or not we should do a head */
  BOOL do_post = FALSE;		/* ARE WE posting ? */
a160 1
  int real_length_of_line;
d162 1
a162 1
  char *linebuf = NULL;
d167 1
a167 1
  BOOL auth_proxy = NO;		/* Generate a proxy authorization. - AJL */
d169 2
a170 3
  int length, rawlength, rv;
  int server_status;
  BOOL doing_redirect, already_retrying = FALSE;
d174 2
a175 2
  BOOL do_connect = FALSE;	/* ARE WE going to use a proxy tunnel ? */
  BOOL did_connect = FALSE;	/* ARE WE actually using a proxy tunnel ? */
d177 2
a178 7
  char *connect_host = NULL;	/* The host being proxied */
  SSL * handle = NULL;		/* The SSL handle */
  char ssl_dn[256];
  char *cert_host;
  char *ssl_host;
  char *p;
  char *msg = NULL;
a181 1
  SSL_handle = NULL;
d204 1
a204 1
      if ((connect_url = strstr((url+7), "https://"))) {
d211 3
a213 3
	  CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	  CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
      } else if ((connect_url = strstr((url+7), "snews://"))) {
d220 2
a221 2
	  CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	  CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
d248 1
a249 1
  if (!strncmp(url, "https", 5))
a253 1
  if (!strncmp(url, "https", 5))
d265 1
a265 1
       CTRACE((tfp, "HTTP: Interrupted on connect; recovering cleanly.\n"));
d271 2
a272 9
#ifdef _WINDOWS
      CTRACE((tfp, "HTTP: Unable to connect to remote host for `%s'\n"
			  " (status = %d, sock_errno = %d).\n",
			  url, status, SOCKET_ERRNO));
#else
      CTRACE((tfp,
	    "HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
	    url, SOCKET_ERRNO));
#endif
a277 5
/* *sob*  All this needs to be converted to handle binary strings
 * if we're going to be able to handle binary form uploads...
 * This is a nice long function as well.  *sigh*  -RJP
 */

d285 1
a285 1
      SSL_handle = handle = HTGetSSLHandle();
d289 1
a289 1
	  handle->options|=SSL_OP_NO_TLSv1;
a290 1
      HTSSLInitPRNG();
d296 2
a297 1
	      _HTProgress(gettext("Retrying connection without TLS."));
d300 2
a301 2
		  HTTP_NETCLOSE(s, handle);
	      goto try_again;
d303 4
a306 9
	      unsigned long SSLerror;
	      CTRACE((tfp,
"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
	      SSL_load_error_strings();
	      while((SSLerror=ERR_get_error())!=0) {
		  CTRACE((tfp,"HTTP: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	      }
	      HTAlert("Unable to make secure connection to remote host.");
d308 3
a310 3
		  HTTP_NETCLOSE(s, handle);
	      status = HT_NOT_LOADED;
	      goto done;
d313 4
a316 9
	  unsigned long SSLerror;
	  CTRACE((tfp,
"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
	  SSL_load_error_strings();
	  while((SSLerror=ERR_get_error())!=0) {
	      CTRACE((tfp,"HTTP: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	  }
	  HTAlert("Unable to make secure connection to remote host.");
d319 2
a320 2
	  status = HT_NOT_LOADED;
	  goto done;
d323 1
d325 9
a333 26
      X509_NAME_oneline(X509_get_subject_name(SSL_get_peer_certificate(handle)),
		        ssl_dn, sizeof(ssl_dn));
      if ((cert_host = strstr(ssl_dn, "/CN=")) == NULL) {
	  HTSprintf0(&msg,
		     gettext("SSL error:Can't find common name in certificate-Continue?"));
	   if (! HTForcedPrompt(ssl_noprompt, msg, YES)) {
	      status = HT_NOT_LOADED;
	      FREE(msg);
	      goto done;
	  }
      } else {
	  cert_host += 4;
	  if ((p = strchr(cert_host, '/')) != NULL)
	      *p = '\0';
	  ssl_host = HTParse(url, "", PARSE_HOST);
	  if (strcmp(ssl_host, cert_host)) {
	      HTSprintf0(&msg,
			 gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
			 ssl_host,
			 cert_host);
	      if (! HTForcedPrompt(ssl_noprompt, msg, YES)) {
		  status = HT_NOT_LOADED;
		  FREE(msg);
		  goto done;
	      }
	  }
d335 1
a335 8

      HTSprintf0(&msg,
		 gettext("Secure %d-bit %s (%s) HTTP connection"),
		 SSL_get_cipher_bits(handle, NULL),
		 SSL_get_cipher_version(handle),
		 SSL_get_cipher(handle));
      _HTProgress(msg);
      FREE(msg);
d348 1
a348 1
	BStrCopy0(command, "CONNECT ");
d353 1
a353 1
	BStrCopy0(command, "POST ");
d356 1
a356 1
	BStrCopy0(command, "HEAD ");
d359 1
a359 1
	BStrCopy0(command, "GET ");
d370 3
a372 3
	    BStrCat0(command, connect_host);
	else
	    BStrCat0(command, p1+1);
d376 1
a376 1
	BStrCat0(command, p1+1);
d379 1
a379 1
	BStrCat0(command, p1);
d383 2
a384 2
      BStrCat0(command, " ");
      BStrCat0(command, HTTP_VERSION);
d387 1
a387 1
  BStrCat0(command, crlf);	/* CR LF, as in rfc 977 */
d394 2
a395 2
	  strip_userid(host);
	  HTBprintf(&command, "Host: %s%c%c", host, CR,LF);
d408 14
a421 5
	  if (pres->get_accept) {
	      if (pres->quality < 1.0) {
		  if (pres->maxbytes > 0) {
		      sprintf(temp, ";q=%4.3f;mxb=%ld",
				    pres->quality, pres->maxbytes);
d423 1
a423 1
		      sprintf(temp, ";q=%4.3f", pres->quality);
d425 3
a427 14
	      } else if (pres->maxbytes > 0) {
		  sprintf(temp, ";mxb=%ld", pres->maxbytes);
	      } else {
		  temp[0] = '\0';
	      }
	      HTSprintf0(&linebuf, "%s%s%s",
			    (first_Accept ?
			       "Accept: " : ", "),
			    HTAtom_name(pres->rep),
			    temp);
	      len += strlen(linebuf);
	      if (len > 252 && !first_Accept) {
		  BStrCat0(command, crlf);
		  HTSprintf0(&linebuf, "Accept: %s%s",
d430 10
a439 1
		  len = strlen(linebuf);
a440 2
	      BStrCat0(command, linebuf);
	      first_Accept = FALSE;
d443 1
a443 1
      HTBprintf(&command, "%s*/*;q=0.01%c%c",
d446 1
d450 3
a452 27
      /*
       * FIXME:  suppressing the "Accept-Encoding" in this case is done to work
       * around limitations of the presentation logic used for the command-line
       * "-base" option.  The remote site may transmit the document gzip'd, but
       * the ensuing logic in HTSaveToFile() would see the mime-type as gzip
       * rather than text/html, and not prepend the base URL.  This is less
       * efficient than accepting the compressed data and uncompressing it,
       * adding the base URL but is simpler than augmenting the dump's
       * presentation logic -TD
       */
      if (LYPrependBaseToSource && dump_output_immediately) {
	  CTRACE((tfp, "omit Accept-Encoding to work-around interaction with -source\n"));
      } else {
	  char *list = 0;
#if defined(USE_ZLIB) || defined(GZIP_PATH)
	  StrAllocCopy(list, "gzip");
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
	  if (list != 0)
	      StrAllocCat(list, ", ");
	  StrAllocCat(list, "compress");
#endif
	  if (list != 0) {
	      HTBprintf(&command, "Accept-Encoding: %s%c%c", list, CR, LF);
	      free(list);
	  }
      }
d455 2
a456 1
	  HTBprintf(&command, "Accept-Language: %s%c%c", language, CR, LF);
d460 12
a471 11
	  BStrCat0(command, "Accept-Charset: ");
	  StrAllocCopy(linebuf, pref_charset);
	  if (linebuf[strlen(linebuf)-1] == ',')
	      linebuf[strlen(linebuf)-1] = '\0';
	  LYLowerCase(linebuf);
	  if (strstr(linebuf, "iso-8859-1") == NULL)
	      StrAllocCat(linebuf, ", iso-8859-1;q=0.01");
	  if (strstr(linebuf, "us-ascii") == NULL)
	      StrAllocCat(linebuf, ", us-ascii;q=0.01");
	  BStrCat0(command, linebuf);
	  HTBprintf(&command, "%c%c", CR, LF);
d498 2
a499 1
	  HTBprintf(&command, "Negotiate: trans%c%c", CR, LF);
d510 4
a513 2
	  HTBprintf(&command, "Pragma: no-cache%c%c", CR, LF);
	  HTBprintf(&command, "Cache-Control: no-cache%c%c", CR, LF);
d517 1
a517 5
	  char *cp = LYSkipBlanks(LYUserAgent);
	  /* Won't send it at all if all blank - kw */
	  if (*cp != '\0')
	      HTBprintf(&command, "User-Agent: %.*s%c%c",
		      INIT_LINE_SIZE-15, LYUserAgent, CR, LF);
d519 1
a519 1
	  HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
d524 1
d527 2
a528 1
	  HTBprintf(&command, "From: %s%c%c", personal_mail_address, CR,LF);
d534 9
a542 7
	  char *cp = LYRequestReferer;
	  if (!cp) cp = HTLoadedDocumentURL(); /* @@@@@@ Try both? - kw */
	  BStrCat0(command, "Referer: ");
	  if (isLYNXIMGMAP(cp)) {
	      char *cp1 = trimPoundSelector(cp);
	      BStrCat0(command, cp + LEN_LYNXIMGMAP);
	      restorePoundSelector(cp1);
d544 1
a544 1
	      BStrCat0(command, cp);
d546 2
a547 1
	  HTBprintf(&command, "%c%c", CR, LF);
d557 1
a557 1
	BOOL secure = (BOOL) (strncmp(anAnchor->address, "https", 5) ?
d609 3
a611 2
		HTBprintf(&command, "%s%c%c", auth, CR, LF);
		CTRACE((tfp, "HTTP: Sending authorization: %s\n", auth));
d625 1
a625 1
		    if (did_connect)
d628 1
a628 1
		    BStrFree(command);
d638 1
a638 1
		CTRACE((tfp, "HTTP: Not sending authorization (yet).\n"));
d645 1
a645 1
		cookie = LYAddCookieHeader(host2, path2, port2, secure);
d657 1
a657 1
	    cookie = LYAddCookieHeader(hostname, abspath, portnumber, secure);
d669 3
a671 3
		BStrCat0(command, "Cookie2: $Version=\"1\"");
		BStrCat0(command, crlf);
		CTRACE((tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n"));
d679 4
a682 4
		BStrCat0(command, "Cookie: ");
		BStrCat0(command, cookie);
		BStrCat0(command, crlf);
		CTRACE((tfp, "HTTP: Sending Cookie: %s\n", cookie));
d705 3
a707 2
	    HTBprintf(&command, "%s%c%c", auth, CR, LF);
	    CTRACE((tfp, (auth_proxy ?
d710 1
a710 1
			auth));
d726 1
a726 1
		BStrFree(command);
d733 1
a733 1
	    CTRACE((tfp, (auth_proxy ?
d735 1
a735 1
			 "HTTP: Not sending authorization (yet).\n")));
a742 1
    if (
d744 3
a746 1
	!do_connect &&
d748 17
a764 16
	do_post) {
	CTRACE((tfp, "HTTP: Doing post, content-type '%s'\n",
		     anAnchor->post_content_type
		     ? anAnchor->post_content_type
		     : "lose"));
	HTBprintf(&command, "Content-type: %s%c%c",
		   anAnchor->post_content_type
		   ? anAnchor->post_content_type
		   : "lose",
		  CR, LF);

	HTBprintf(&command, "Content-length: %d%c%c",
		  !isBEmpty(anAnchor->post_data)
		   ? BStrLen(anAnchor->post_data)
		   : 0,
		  CR, LF);
d766 1
a766 1
	BStrCat0(command, crlf);	/* Blank line means "end" of headers */
d768 1
a768 1
	BStrCat(command, anAnchor->post_data);
d770 2
a771 2
    else
	BStrCat0(command, crlf);	/* Blank line means "end" of headers */
a772 3
    if (TRACE) {
	CTRACE((tfp, "Writing:\n"));
	trace_bstring(command);
d774 3
a776 2
	CTRACE((tfp, "%s",
	       (anAnchor->post_data && !do_connect ? crlf : "")));
d778 3
a780 2
	CTRACE((tfp, "%s",
	       (anAnchor->post_data ? crlf : "")));
a781 2
	CTRACE((tfp, "----------------------------------\n"));
    }
d788 1
a788 1
      for ( p = BStrData(command); p < BStrData(command) + BStrLen(command); p++ )
d792 2
a793 3
  status = HTTP_NETWRITE(s, BStrData(command), BStrLen(command), handle);
  BStrFree(command);
  FREE(linebuf);
d796 1
a796 1
	  CTRACE((tfp, "HTTP: Got status 0 in initial write\n"));
d804 1
a804 1
	    **	Arrrrgh, HTTP 0/1 compatibility problem, maybe.
d806 1
a806 1
	    CTRACE((tfp, "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n"));
d813 1
a813 1
	  CTRACE((tfp, "HTTP: Hit unexpected network WRITE error; aborting connection.\n"));
d821 1
a821 1
  CTRACE((tfp, "HTTP: WRITE delivered OK\n"));
d832 1
a832 1
    line_buffer = typecallocn(char, buffer_length);
d848 2
a849 1
	CTRACE((tfp, "HTTP: Trying to read %d\n", buffer_length - length - 1));
d852 1
a852 1
	CTRACE((tfp, "HTTP: Read %d\n", status));
d859 1
a859 1
		CTRACE((tfp, "HTTP: Interrupted initial read.\n"));
a865 3
#ifdef _WINDOWS	/* 1997/11/09 (Sun) 16:59:58 */
			 SOCKET_ERRNO == ETIMEDOUT ||
#endif
d872 1
a872 1
		CTRACE((tfp, "HTTP: BONZO Trying again with HTTP0 request.\n"));
d882 2
a883 2
		CTRACE((tfp, "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			   status));
a918 1
	    real_length_of_line = length + status;
a941 2
  /* save total length, in case we decide later to show it all - kw */
  rawlength = length;
d946 1
a946 1
  CTRACE((tfp, "HTTP: Rx: %s\n", line_buffer));
d962 1
a962 1
      CTRACE((tfp, "HTTP: close socket %d to retry with HTTP0\n", s));
d973 1
d981 1
a981 1
    CTRACE((tfp, "HTTP: Scanned %d fields from line_buffer\n", fields));
d986 1
a986 1
	error_file = fopen(http_error_file, TXT_W);
d992 1
a992 1
	error_file = fopen(http_error_file, TXT_A);
d1013 1
a1013 1
	CTRACE((tfp, "--- Talking HTTP0.\n"));
d1022 1
a1022 1
	    CTRACE((tfp, "HTTP: format_in being changed to text/HTML\n"));
d1029 1
a1029 1
	    CTRACE((tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in)));
d1033 2
a1034 2
	    CTRACE((tfp, "        Treating as '%s' with encoding '%s'\n",
			"www/compressed", HTAtom_name(encoding)));
d1043 1
a1043 1
	CTRACE((tfp, "--- Talking HTTP1.\n"));
a1100 1
		HTNoDataOK = 1;
d1138 4
a1141 4
#if defined(USE_SSL) && !defined(DISABLE_NEWS)
		if (do_connect) {
		    CTRACE((tfp, "HTTP: Proxy tunnel to '%s' established.\n",
				connect_host));
d1147 2
a1148 2
			CTRACE((tfp,
			"      Will attempt handshake and snews connection.\n"));
d1160 1
a1160 1
		    permanent_redirection = FALSE;
d1162 2
a1163 2
		    CTRACE((tfp,
			"      Will attempt handshake and resubmit headers.\n"));
d1286 2
d1306 28
a1333 1
	      HTProgress(line_buffer);
d1335 1
d1341 1
a1341 1
		      CTRACE((tfp, "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n"));
a1347 1
	      doing_redirect = TRUE;
d1349 334
d1716 1
a1716 1
		    CTRACE((tfp, "%s %d %s\n",
d1718 1
a1718 1
				"to retry with Access Authorization"));
d1769 1
a1769 1
		    CTRACE((tfp, "%s %d %s\n",
d1771 1
a1771 1
				"to retry with Proxy Authorization"));
a1915 7
      if (doing_redirect) {
	  /*
	   *  Impatient user. - FM
	   */
	  CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	  _HTProgress (CONNECTION_INTERRUPTED);
      }
d1927 1
a1927 6
#ifdef SH_EX	/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
/* GIF file contains \0, so strlen does not return the data length */
      length = real_length_of_line;
#else
      length = rawlength;
#endif
a1928 18

  } else if (doing_redirect) {

      format_in = HTAtom_for("message/x-http-redirection");
      StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
      if (traversal) {
	  format_out = WWW_DEBUG;
	  if (!sink)
	      sink = HTErrorStream();
      } else if (!dump_output_immediately &&
	  format_out == HTAtom_for("www/download")) {
	  /*
	   *  Convert a download request to
	   *  a presentation request for
	   *  interactive users. - FM
	   */
	  format_out = WWW_PRESENT;
      }
d1936 1
a1936 1
      char *buffer = NULL;
d1939 1
a1939 1
      HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
a1941 1
      FREE(buffer);
a1955 8
  /*
  **  If we get here with doing_redirect set, it means that we were
  **  looking for a Location header.  We either have got it now in
  **  redirecting_url - in that case the stream should not have loaded
  **  any data.  Or we didn't get it, in that case the stream may have
  **  presented the message body normally. - kw
  */

d1961 1
a1961 4
      if (doing_redirect && traversal)
	  status = -1;
      else
	  status = HT_INTERRUPTED;
d1971 3
a1973 1
      if (doing_redirect && redirecting_url) {
d1975 1
a1975 2
	  **  Got a location before the error occurred?  Then consider it
	  **  an interrupt but proceed below as normal. - kw
d1977 6
a1982 1
	  /* do nothing here */
d1984 2
a1985 16
	  HTTP_NETCLOSE(s, handle);
	  if (!doing_redirect && !already_retrying && !do_post) {
	      CTRACE((tfp, "HTTP: Trying again with HTTP0 request.\n"));
	      /*
	      **  May as well consider it an interrupt -- right?
	      */
	      FREE(line_buffer);
	      FREE(line_kept_clean);
	      extensions = NO;
	      already_retrying = TRUE;
	      _HTProgress (RETRYING_AS_HTTP0);
	      goto try_again;
	  } else {
	      status = HT_NOT_LOADED;
	      goto clean_up;
	  }
d1993 1
a1993 1
  if (rv != HT_INTERRUPTED && rv != -2) {
d2000 10
a2009 94
      if (redirecting_url) {
	  /*
	   *  Set up for checking redirecting_url in
	   *  LYGetFile.c for restrictions before we
	   *  seek the document at that Location. - FM
	   */
	  CTRACE((tfp, "HTTP: Picked up location '%s'\n",
		  redirecting_url));
	  if (rv == HT_INTERRUPTED) {
	      /*
	      **  Intentional interrupt after data were received, not an
	      **  error (probably).  We take it as a user request to
	      **  abandon the redirection chain.
	      **  This could reasonably be changed (by just removing this
	      **  block), it would make sense if there are redirecting
	      **  resources that "hang" after sending the headers. - kw
	      */
	      FREE(redirecting_url);
	      CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	      status = HT_INTERRUPTED;
	      goto clean_up;
	  }
	  HTProgress(line_buffer);
	  if (server_status == 305) { /* Use Proxy */
	      /*
	       *	Make sure the proxy field ends with
	       *	a slash. - FM
	       */
	      if (redirecting_url[strlen(redirecting_url)-1]
		  != '/')
		  StrAllocCat(redirecting_url, "/");
	      /*
	       *	Append our URL. - FM
	       */
	      StrAllocCat(redirecting_url, anAnchor->address);
	      CTRACE((tfp, "HTTP: Proxy URL is '%s'\n",
		      redirecting_url));
	  }
	  if (!do_post ||
	      server_status == 303 ||
	      server_status == 302) {
	      /*
	       *	We don't have POST content (nor support PUT
	       *	or DELETE), or the status is "See Other"  or
	       *	"General Redirection" and we can convert to
	       *	GET, so go back and check out the new URL. - FM
	       */
	      status = HT_REDIRECTING;
	      goto clean_up;
	  }
	  /*
	   *  Make sure the user wants to redirect
	   *  the POST content, or treat as GET - FM & DK
	   */
	  switch (HTConfirmPostRedirect(redirecting_url,
					server_status)) {
	      /*
	       *	User failed to confirm.
	       *	Abort the fetch.
	       */
	  case 0:
	      doing_redirect = FALSE;
	      FREE(redirecting_url);
	      status = HT_NO_DATA;
	      goto clean_up;

	      /*
	       *	User wants to treat as GET with no content.
	       *	Go back to check out the URL.
	       */
	  case 303:
	      break;

	      /*
	       *	Set the flag to retain the POST
	       *	content and go back to check out
	       *	the URL. - FM
	       */
	  default:
	      redirect_post_content = TRUE;
	  }

	  /* Lou's old comment:  - FM */
	  /* OK, now we've got the redirection URL temporarily stored
	     in external variable redirecting_url, exported from HTMIME.c,
	     since there's no straightforward way to do this in the library
	     currently.  Do the right thing. */

	  status = HT_REDIRECTING;

      } else {
	  status = traversal ? -1 : HT_LOADED;
      }

d2037 1
a2037 1
    SSL_handle = handle = NULL;
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d74 1
a74 1
#ifdef USE_X509_SUPPORT
a80 1
#endif
a606 2
	  if ((p = strchr(cert_host, ':')) != NULL)
	      *p = '\0';
d608 1
a608 3
	  if ((p = strchr(ssl_host, ':')) != NULL)
	      *p = '\0';
	  if (strcasecmp(ssl_host, cert_host)) {
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d613 1
a613 1
	  if (strcasecomp(ssl_host, cert_host)) {
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d52 4
a55 4
BOOL reloading = FALSE;	/* Reloading => send no-cache pragma to proxy */
char * redirecting_url = NULL;	    /* Location: value. */
BOOL permanent_redirection = FALSE;  /* Got 301 status? */
BOOL redirect_post_content = FALSE;  /* Don't convert to GET? */
d58 3
a60 3
SSL_CTX * ssl_ctx = NULL;	/* SSL ctx */
SSL * SSL_handle = NULL;
int ssl_okay;
d62 1
a62 1
static void free_ssl_ctx (void)
d68 1
a68 1
static int HTSSLCallback(int preverify_ok, X509_STORE_CTX *x509_ctx)
d88 1
a88 1
SSL * HTGetSSLHandle (void)
d110 1
a110 1
void HTSSLInitPRNG (void)
d172 2
a173 2
int ws_read_per_sec = 0;
static int ws_errno = 0;
d175 2
a176 2
static DWORD g_total_times = 0;
static DWORD g_total_bytes = 0;
d179 1
a179 1
char * str_speed(void)
d195 1
a195 1
static int ws_read(int fd, char *buf, int len)
d212 1
a212 1
static void _thread_func (void *p)
d240 1
a240 1
int ws_netread(int fd, char *buf, int len)
d337 2
a338 2
static void strip_userid (
	char *		host)
d377 5
a381 5
static int HTLoadHTTP (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d384 1
a384 1
  const char *url = arg;	/* The URL which get_physical() returned */
d417 1
a417 1
  const char *connect_url = NULL; /* The URL being proxied */
d2136 2
a2137 2
GLOBALDEF HTProtocol HTTP = { "http", HTLoadHTTP, 0 };
GLOBALDEF HTProtocol HTTPS = { "https", HTLoadHTTP, 0 };
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 6
a7 6
 *	==========================
 * Modified:
 * 27 Jan 1994	PDM  Added Ari Luotonen's Fix for Reload when using proxy
 *		     servers.
 * 28 Apr 1997	AJL,FM Do Proxy Authorisation.
 */
a41 1
#include <LYrcFile.h>
d44 3
a46 2
struct _HTStream {
    HTStreamClass *isa;
d49 2
a50 2
extern char *HTAppName;		/* Application name: please supply */
extern char *HTAppVersion;	/* Application version: please supply */
d52 4
a55 4
BOOL reloading = FALSE;		/* Reloading => send no-cache pragma to proxy */
char *redirecting_url = NULL;	/* Location: value. */
BOOL permanent_redirection = FALSE;	/* Got 301 status? */
BOOL redirect_post_content = FALSE;	/* Don't convert to GET? */
d58 2
a59 2
SSL_CTX *ssl_ctx = NULL;	/* SSL ctx */
SSL *SSL_handle = NULL;
d62 1
a62 1
static void free_ssl_ctx(void)
d68 1
a68 1
static int HTSSLCallback(int preverify_ok, X509_STORE_CTX * x509_ctx)
d88 1
a88 1
SSL *HTGetSSLHandle(void)
d92 1
a92 1
	 * First time only.
d107 1
a107 1
    return (SSL_new(ssl_ctx));
d110 1
a110 1
void HTSSLInitPRNG(void)
d117 1
a117 1
	long l, seed;
d122 2
a123 2
	CTRACE((tfp, "HTTP: Seeding PRNG\n"));
	if (rand_file != NULL) {
d128 1
a128 1
	RAND_seed((unsigned char *) &t, sizeof(time_t));
d130 1
a130 1
	RAND_seed((unsigned char *) &pid, sizeof(pid));
d132 1
a132 2
	RAND_bytes((unsigned char *) &seed, sizeof(long));

d137 1
a137 1
	    RAND_seed((unsigned char *) &l, sizeof(long));
d161 1
a161 1
#ifdef _WINDOWS			/* 1997/11/06 (Thu) 13:00:08 */
d167 3
a169 3
    int fd;
    char *buf;
    int len;
d178 2
a179 1
char *str_speed(void)
d185 1
a185 1
		(ws_read_per_sec % 1000));
d197 2
a198 2
    int res;
    int retry = 3;
d200 1
a200 1
    do {
d203 3
a205 3
	    Sleep(100);
	    if (retry-- > 0)
		continue;
d207 1
a207 1
    } while (res == SOCKET_ERROR && SOCKET_ERRNO == EINTR);
d209 1
a209 1
    return res;
d212 1
a212 1
static DWORD __stdcall _thread_func(void *p)
d215 1
a215 1
    recv_data_t *q = (recv_data_t *) p;
a224 1

d234 1
a234 1
    return ((DWORD) ret);
d245 1
a245 1
    /* 1998/03/30 (Mon) 09:01:21 */
d254 1
a254 1
    extern int lynx_timeout;	/* LYMain.c */
d269 3
a271 3
    hThread = CreateThread(NULL, STACK_SIZE,
			   _thread_func,
			   (void *) &para, 0UL, &dwThreadID);
d280 1
a280 1
	val = WaitForSingleObject(hThread, 1000 / TICK);
d288 1
a288 1
	    if (i / TICK > (AlertSecs + 2)) {
d290 1
a290 1
			i / TICK, (i % TICK) * 10 / TICK, len);
d293 1
a293 1
	    if (win32_check_interrupt() || ((i / TICK) > lynx_timeout)) {
d318 1
a318 1
		ws_read_per_sec = g_total_bytes / (g_total_times / 1000);
d325 1
a325 1
    }				/* end while(1) */
d327 1
a327 1
  read_exit:
d335 1
d337 2
a338 1
static void strip_userid(char *host)
d361 21
a381 20
 *		==============================
 *
 *	Given a hypertext address, this routine loads a document.
 *
 *
 *  On entry,
 *	arg	is the hypertext reference of the article to be loaded.
 *
 *  On exit,
 *	returns >=0	If no error, a good socket number
 *		<0	Error.
 *
 *	The socket must be closed by the caller after the document has been
 *	read.
 *
 */
static int HTLoadHTTP(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *sink)
d383 30
a412 30
    int s;			/* Socket number for returned data */
    const char *url = arg;	/* The URL which get_physical() returned */
    bstring *command = NULL;	/* The whole command */
    char *eol;			/* End of line if found */
    char *start_of_data;	/* Start of body of reply */
    int status;			/* tcp return */
    int bytes_already_read;
    char crlf[3];		/* A CR LF equivalent string */
    HTStream *target;		/* Unconverted data */
    HTFormat format_in;		/* Format arriving in the message */
    BOOL do_head = FALSE;	/* Whether or not we should do a head */
    BOOL do_post = FALSE;	/* ARE WE posting ? */
    char *METHOD;

    BOOL had_header;		/* Have we had at least one header? */
    char *line_buffer;
    char *line_kept_clean;
    int real_length_of_line;
    BOOL extensions;		/* Assume good HTTP server */
    char *linebuf = NULL;
    char temp[80];
    BOOL first_Accept = TRUE;
    BOOL show_401 = FALSE;
    BOOL show_407 = FALSE;
    BOOL auth_proxy = NO;	/* Generate a proxy authorization. - AJL */

    int length, rawlength, rv;
    int server_status;
    BOOL doing_redirect, already_retrying = FALSE;
    int len = 0;
d415 10
a424 11
    BOOL do_connect = FALSE;	/* ARE WE going to use a proxy tunnel ? */
    BOOL did_connect = FALSE;	/* ARE WE actually using a proxy tunnel ? */
    const char *connect_url = NULL;	/* The URL being proxied */
    char *connect_host = NULL;	/* The host being proxied */
    SSL *handle = NULL;		/* The SSL handle */
    char ssl_dn[256];
    char *cert_host;
    char *ssl_host;
    char *p;
    char *msg = NULL;

d426 1
a426 1
    BOOL try_tls = TRUE;
d428 1
a428 1
    SSL_handle = NULL;
d430 1
a430 1
    void *handle = NULL;
d433 16
a448 15
    if (anAnchor->isHEAD)
	do_head = TRUE;
    else if (anAnchor->post_data)
	do_post = TRUE;

    if (!url) {
	status = -3;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
    if (!*url) {
	status = -2;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
d450 21
a470 21
    if (using_proxy && !strncmp(url, "http://", 7)) {
	if ((connect_url = strstr((url + 7), "https://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "https", PARSE_HOST);
	    if (!strchr(connect_host, ':')) {
		sprintf(temp, ":%d", HTTPS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	} else if ((connect_url = strstr((url + 7), "snews://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "snews", PARSE_HOST);
	    if (!strchr(connect_host, ':')) {
		sprintf(temp, ":%d", SNEWS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	}
    }
d473 1
a473 6
    sprintf(crlf, "%c%c", CR, LF);

    /*
     * At this point, we're talking HTTP/1.0.
     */
    extensions = YES;
d475 19
a493 14
  try_again:
    /*
     * All initializations are moved down here from up above, so we can start
     * over here...
     */
    eol = 0;
    had_header = NO;
    length = 0;
    doing_redirect = FALSE;
    permanent_redirection = FALSE;
    redirect_post_content = FALSE;
    target = NULL;
    line_buffer = NULL;
    line_kept_clean = NULL;
d496 4
a499 4
    if (!strncmp(url, "https", 5))
	status = HTDoConnect(url, "HTTPS", HTTPS_PORT, &s);
    else
	status = HTDoConnect(url, "HTTP", HTTP_PORT, &s);
d501 5
a505 4
    if (!strncmp(url, "https", 5)) {
	HTAlert(gettext("This client does not contain support for HTTPS URLs."));
	status = HT_NOT_LOADED;
	goto done;
d507 1
a507 1
    status = HTDoConnect(arg, "HTTP", HTTP_PORT, &s);
d509 10
a518 10
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp, "HTTP: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	status = HT_NOT_LOADED;
	goto done;
    }
    if (status < 0) {
d520 3
a522 3
	CTRACE((tfp, "HTTP: Unable to connect to remote host for `%s'\n"
		" (status = %d, sock_errno = %d).\n",
		url, status, SOCKET_ERRNO));
d524 3
a526 3
	CTRACE((tfp,
		"HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
		url, SOCKET_ERRNO));
d528 10
a537 4
	HTAlert(gettext("Unable to connect to remote host."));
	status = HT_NOT_LOADED;
	goto done;
    }
d539 8
a546 7
  use_tunnel:
    /*
     * If this is an https document, then do the SSL stuff here.
     */
    if (did_connect || !strncmp(url, "https", 5)) {
	SSL_handle = handle = HTGetSSLHandle();
	SSL_set_fd(handle, s);
d548 2
a549 2
	if (!try_tls)
	    handle->options |= SSL_OP_NO_TLSv1;
d551 2
a552 2
	HTSSLInitPRNG();
	status = SSL_connect(handle);
d554 1
a554 1
	if (status <= 0) {
d556 21
a576 22
	    if (try_tls) {
		_HTProgress(gettext("Retrying connection without TLS."));
		try_tls = FALSE;
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		goto try_again;
	    } else {
		unsigned long SSLerror;

		CTRACE((tfp,
			"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
			url, status));
		SSL_load_error_strings();
		while ((SSLerror = ERR_get_error()) != 0) {
		    CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
		}
		HTAlert("Unable to make secure connection to remote host.");
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		status = HT_NOT_LOADED;
		goto done;
	    }
d578 13
a590 14
	    unsigned long SSLerror;

	    CTRACE((tfp,
		    "HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		    url, status));
	    SSL_load_error_strings();
	    while ((SSLerror = ERR_get_error()) != 0) {
		CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
	    }
	    HTAlert("Unable to make secure connection to remote host.");
	    if (did_connect)
		HTTP_NETCLOSE(s, handle);
	    status = HT_NOT_LOADED;
	    goto done;
d592 1
a592 33
	}

	X509_NAME_oneline(X509_get_subject_name(SSL_get_peer_certificate(handle)),
			  ssl_dn, sizeof(ssl_dn));
	if ((cert_host = strstr(ssl_dn, "/CN=")) == NULL) {
	    HTSprintf0(&msg,
		       gettext("SSL error:Can't find common name in certificate-Continue?"));
	    if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		status = HT_NOT_LOADED;
		FREE(msg);
		goto done;
	    }
	} else {
	    cert_host += 4;
	    if ((p = strchr(cert_host, '/')) != NULL)
		*p = '\0';
	    if ((p = strchr(cert_host, ':')) != NULL)
		*p = '\0';
	    ssl_host = HTParse(url, "", PARSE_HOST);
	    if ((p = strchr(ssl_host, ':')) != NULL)
		*p = '\0';
	    if (strcasecomp(ssl_host, cert_host)) {
		HTSprintf0(&msg,
			   gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
			   ssl_host,
			   cert_host);
		if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		    status = HT_NOT_LOADED;
		    FREE(msg);
		    goto done;
		}
	    }
	}
d594 40
a633 8
	HTSprintf0(&msg,
		   gettext("Secure %d-bit %s (%s) HTTP connection"),
		   SSL_get_cipher_bits(handle, NULL),
		   SSL_get_cipher_version(handle),
		   SSL_get_cipher(handle));
	_HTProgress(msg);
	FREE(msg);
    }
d636 5
a640 4
    /* Ask that node for the document, omitting the host name & anchor
     */
    {
	char *p1 = (HTParse(url, "", PARSE_PATH | PARSE_PUNCTUATION));
d643 4
a646 4
	if (do_connect) {
	    METHOD = "CONNECT";
	    BStrCopy0(command, "CONNECT ");
	} else
d648 10
a657 10
	if (do_post) {
	    METHOD = "POST";
	    BStrCopy0(command, "POST ");
	} else if (do_head) {
	    METHOD = "HEAD";
	    BStrCopy0(command, "HEAD ");
	} else {
	    METHOD = "GET";
	    BStrCopy0(command, "GET ");
	}
d659 5
a663 5
	/*
	 * If we are using a proxy gateway don't copy in the first slash of
	 * say:  /gopher://a;lkdjfl;ajdf;lkj/;aldk/adflj so that just
	 * gopher://....  is sent.
	 */
d665 6
a670 6
	if (using_proxy && !did_connect) {
	    if (do_connect)
		BStrCat0(command, connect_host);
	    else
		BStrCat0(command, p1 + 1);
	}
d672 2
a673 2
	if (using_proxy)
	    BStrCat0(command, p1 + 1);
d675 111
a785 106
	else
	    BStrCat0(command, p1);
	FREE(p1);
    }
    if (extensions) {
	BStrCat0(command, " ");
	BStrCat0(command, HTTP_VERSION);
    }

    BStrCat0(command, crlf);	/* CR LF, as in rfc 977 */

    if (extensions) {
	int n, i;
	char *host = NULL;

	if ((host = HTParse(anAnchor->address, "", PARSE_HOST)) != NULL) {
	    strip_userid(host);
	    HTBprintf(&command, "Host: %s%c%c", host, CR, LF);
	    FREE(host);
	}

	if (!HTPresentations)
	    HTFormatInit();
	n = HTList_count(HTPresentations);

	first_Accept = TRUE;
	len = 0;
	for (i = 0; i < n; i++) {
	    HTPresentation *pres =
	    (HTPresentation *) HTList_objectAt(HTPresentations, i);

	    if (pres->get_accept) {
		if (pres->quality < 1.0) {
		    if (pres->maxbytes > 0) {
			sprintf(temp, ";q=%4.3f;mxb=%ld",
				pres->quality, pres->maxbytes);
		    } else {
			sprintf(temp, ";q=%4.3f", pres->quality);
		    }
		} else if (pres->maxbytes > 0) {
		    sprintf(temp, ";mxb=%ld", pres->maxbytes);
		} else {
		    temp[0] = '\0';
		}
		HTSprintf0(&linebuf, "%s%s%s",
			   (first_Accept ?
			    "Accept: " : ", "),
			   HTAtom_name(pres->rep),
			   temp);
		len += strlen(linebuf);
		if (len > 252 && !first_Accept) {
		    BStrCat0(command, crlf);
		    HTSprintf0(&linebuf, "Accept: %s%s",
			       HTAtom_name(pres->rep),
			       temp);
		    len = strlen(linebuf);
		}
		BStrCat0(command, linebuf);
		first_Accept = FALSE;
	    }
	}
	HTBprintf(&command, "%s*/*;q=0.01%c%c",
		  (first_Accept ?
		   "Accept: " : ", "), CR, LF);
	first_Accept = FALSE;
	len = 0;

	/*
	 * FIXME:  suppressing the "Accept-Encoding" in this case is done to
	 * work around limitations of the presentation logic used for the
	 * command-line "-base" option.  The remote site may transmit the
	 * document gzip'd, but the ensuing logic in HTSaveToFile() would see
	 * the mime-type as gzip rather than text/html, and not prepend the
	 * base URL.  This is less efficient than accepting the compressed data
	 * and uncompressing it, adding the base URL but is simpler than
	 * augmenting the dump's presentation logic -TD
	 */
	if (LYPrependBaseToSource && dump_output_immediately) {
	    CTRACE((tfp,
		    "omit Accept-Encoding to work-around interaction with -source\n"));
	} else {
	    char *list = 0;
	    int j, k;

	    for (j = 1; j < encodingALL; j <<= 1) {
		if ((j & LYAcceptEncoding) != 0) {
		    for (k = 0; tbl_preferred_encoding[k].name != 0; ++k) {
			if (tbl_preferred_encoding[k].value == j) {
			    if (list != 0)
				StrAllocCat(list, ", ");
			    StrAllocCat(list, tbl_preferred_encoding[k].name);
			    break;
			}
		    }
		}
	    }

	    if (list != 0) {
		HTBprintf(&command, "Accept-Encoding: %s%c%c", list, CR, LF);
		free(list);
	    }
	}

	if (language && *language) {
	    HTBprintf(&command, "Accept-Language: %s%c%c", language, CR, LF);
	}
a786 13
	if (pref_charset && *pref_charset) {
	    BStrCat0(command, "Accept-Charset: ");
	    StrAllocCopy(linebuf, pref_charset);
	    if (linebuf[strlen(linebuf) - 1] == ',')
		linebuf[strlen(linebuf) - 1] = '\0';
	    LYLowerCase(linebuf);
	    if (strstr(linebuf, "iso-8859-1") == NULL)
		StrAllocCat(linebuf, ", iso-8859-1;q=0.01");
	    if (strstr(linebuf, "us-ascii") == NULL)
		StrAllocCat(linebuf, ", us-ascii;q=0.01");
	    BStrCat0(command, linebuf);
	    HTBprintf(&command, "%c%c", CR, LF);
	}
d788 25
a812 25
	/*
	 * Promote 300 (Multiple Choices) replies, if supported, over 406 (Not
	 * Acceptable) replies.  - FM
	 *
	 * This used to be done in versions 2.7 and 2.8*, but violates the
	 * specs for transparent content negotiation and has the effect that
	 * servers supporting those specs will send 300 (Multiple Choices)
	 * instead of a normal response (e.g.  200 OK), since they will assume
	 * that the client wants to make the choice.  It is not clear whether
	 * there are any servers or sites for which sending this header really
	 * improves anything.
	 *
	 * If there ever is a need to send "Negotiate:  trans" and really mean
	 * it, we should send "Negotiate:  trans,trans" or similar, since that
	 * is semantically equivalent and some servers may ignore "Negotiate: 
	 * trans" as a special case when it comes from Lynx (to work around the
	 * old faulty behavior).  - kw
	 *
	 * References:
	 * RFC 2295 (see also RFC 2296), and mail to lynx-dev and
	 * new-httpd@@apache.org from Koen Holtman, Jan 1999.
	 */
	if (!do_post) {
	    HTBprintf(&command, "Negotiate: trans%c%c", CR, LF);
	}
d815 65
a879 9
	/*
	 * When reloading give no-cache pragma to proxy server to make it
	 * refresh its cache.  -- Ari L.  <luotonen@@dxcern.cern.ch>
	 *
	 * Also send it as a Cache-Control header for HTTP/1.1.  - FM
	 */
	if (reloading) {
	    HTBprintf(&command, "Pragma: no-cache%c%c", CR, LF);
	    HTBprintf(&command, "Cache-Control: no-cache%c%c", CR, LF);
d882 5
a886 144
	if (LYUserAgent && *LYUserAgent) {
	    char *cp = LYSkipBlanks(LYUserAgent);

	    /* Won't send it at all if all blank - kw */
	    if (*cp != '\0')
		HTBprintf(&command, "User-Agent: %.*s%c%c",
			  INIT_LINE_SIZE - 15, LYUserAgent, CR, LF);
	} else {
	    HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
		      HTAppName ? HTAppName : "unknown",
		      HTAppVersion ? HTAppVersion : "0.0",
		      HTLibraryVersion, CR, LF);
	}

	if (personal_mail_address && !LYNoFromHeader) {
	    HTBprintf(&command, "From: %s%c%c", personal_mail_address, CR, LF);
	}

	if (!(LYUserSpecifiedURL ||
	      LYNoRefererHeader || LYNoRefererForThis) &&
	    strcmp(HTLoadedDocumentURL(), "")) {
	    char *cp = LYRequestReferer;

	    if (!cp)
		cp = HTLoadedDocumentURL();	/* @@@@@@ Try both? - kw */
	    BStrCat0(command, "Referer: ");
	    if (isLYNXIMGMAP(cp)) {
		char *cp1 = trimPoundSelector(cp);

		BStrCat0(command, cp + LEN_LYNXIMGMAP);
		restorePoundSelector(cp1);
	    } else {
		BStrCat0(command, cp);
	    }
	    HTBprintf(&command, "%c%c", CR, LF);
	} {
	    char *abspath;
	    char *docname;
	    char *hostname;
	    char *colon;
	    int portnumber;
	    char *auth, *cookie = NULL;
	    BOOL secure = (BOOL) (strncmp(anAnchor->address, "https", 5) ?
				  FALSE : TRUE);

	    abspath = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);
	    docname = HTParse(arg, "", PARSE_PATH);
	    hostname = HTParse(arg, "", PARSE_HOST);
	    if (hostname &&
		NULL != (colon = strchr(hostname, ':'))) {
		*(colon++) = '\0';	/* Chop off port number */
		portnumber = atoi(colon);
	    } else if (!strncmp(arg, "https", 5)) {
		portnumber = HTTPS_PORT;
	    } else {
		portnumber = HTTP_PORT;
	    }

	    /*
	     * Add Authorization, Proxy-Authorization, and/or Cookie headers,
	     * if applicable.
	     */
	    if (using_proxy) {
		/*
		 * If we are using a proxy, first determine if we should
		 * include an Authorization header and/or Cookie header for the
		 * ultimate target of this request.  - FM & AJL
		 */
		char *host2 = NULL, *path2 = NULL;
		int port2 = (strncmp(docname, "https", 5) ?
			     HTTP_PORT : HTTPS_PORT);

		host2 = HTParse(docname, "", PARSE_HOST);
		path2 = HTParse(docname, "", PARSE_PATH | PARSE_PUNCTUATION);
		if (host2) {
		    if ((colon = strchr(host2, ':')) != NULL) {
			/* Use non-default port number */
			*colon = '\0';
			colon++;
			port2 = atoi(colon);
		    }
		}
		/*
		 * This composeAuth() does file access, i.e., for the ultimate
		 * target of the request.  - AJL
		 */
		auth_proxy = NO;
		if ((auth = HTAA_composeAuth(host2, port2, path2,
					     auth_proxy)) != NULL &&
		    *auth != '\0') {
		    /*
		     * If auth is not NULL nor zero-length, it's an
		     * Authorization header to be included.  - FM
		     */
		    HTBprintf(&command, "%s%c%c", auth, CR, LF);
		    CTRACE((tfp, "HTTP: Sending authorization: %s\n", auth));
		} else if (auth && *auth == '\0') {
		    /*
		     * If auth is a zero-length string, the user either
		     * cancelled or goofed at the username and password prompt. 
		     * - FM
		     */
		    if (!(traversal || dump_output_immediately) &&
			HTConfirm(CONFIRM_WO_PASSWORD)) {
			show_401 = TRUE;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_NEED_PASSWD);
#ifdef USE_SSL
			if (did_connect)
			    HTTP_NETCLOSE(s, handle);
#endif /* USE_SSL */
			BStrFree(command);
			FREE(hostname);
			FREE(docname);
			FREE(abspath);
			FREE(host2);
			FREE(path2);
			status = HT_NOT_LOADED;
			goto done;
		    }
		} else {
		    CTRACE((tfp, "HTTP: Not sending authorization (yet).\n"));
		}
		/*
		 * Add 'Cookie:' header, if it's HTTP or HTTPS document being
		 * proxied.
		 */
		if (!strncmp(docname, "http", 4)) {
		    cookie = LYAddCookieHeader(host2, path2, port2, secure);
		}
		FREE(host2);
		FREE(path2);
		/*
		 * The next composeAuth() will be for the proxy.  - AJL
		 */
		auth_proxy = YES;
	    } else {
		/*
		 * Add cookie for a non-proxied request.  - FM
		 */
		cookie = LYAddCookieHeader(hostname, abspath, portnumber, secure);
		auth_proxy = NO;
	    }
d888 16
a903 22
	     * If we do have a cookie set, add it to the request buffer.  - FM
	     */
	    if (cookie != NULL) {
		if (*cookie != '$') {
		    /*
		     * It's a historical cookie, so signal to the server that
		     * we support modern cookies.  - FM
		     */
		    BStrCat0(command, "Cookie2: $Version=\"1\"");
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n"));
		}
		if (*cookie != '\0') {
		    /*
		     * It's not a zero-length string, so add the header.  Note
		     * that any folding of long strings has been done already
		     * in LYCookie.c.  - FM
		     */
		    BStrCat0(command, "Cookie: ");
		    BStrCat0(command, cookie);
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie: %s\n", cookie));
a904 1
		FREE(cookie);
a905 2
	    FREE(abspath);

d907 5
a911 9
	     * If we are using a proxy, auth_proxy should be YES, and we check
	     * here whether we want a Proxy-Authorization header for it.  If we
	     * are not using a proxy, auth_proxy should still be NO, and we
	     * check here for whether we want an Authorization header.  - FM &
	     * AJL
	     */
	    if ((auth = HTAA_composeAuth(hostname,
					 portnumber,
					 docname,
d915 3
a917 3
		 * If auth is not NULL nor zero-length, it's an Authorization
		 * or Proxy-Authorization header to be included.  - FM
		 */
d919 1
a919 4
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Sending proxy authorization: %s\n" :
			      "HTTP: Sending authorization: %s\n"),
			auth));
d922 7
a928 9
		 * If auth is a zero-length string, the user either cancelled
		 * or goofed at the username and password prompt.  - FM
		 */
		if (!(traversal || dump_output_immediately) && HTConfirm(CONFIRM_WO_PASSWORD)) {
		    if (auth_proxy == TRUE) {
			show_407 = TRUE;
		    } else {
			show_401 = TRUE;
		    }
d932 4
d939 3
d946 1
a946 3
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Not sending proxy authorization (yet).\n" :
			      "HTTP: Not sending authorization (yet).\n")));
d948 45
a992 2
	    FREE(hostname);
	    FREE(docname);
d994 55
a1048 2
	auth_proxy = NO;
    }
d1052 1
a1052 1
	   !do_connect &&
d1054 1
a1054 1
	   do_post) {
d1056 3
a1058 3
		anAnchor->post_content_type
		? anAnchor->post_content_type
		: "lose"));
d1060 3
a1062 3
		  anAnchor->post_content_type
		  ? anAnchor->post_content_type
		  : "lose",
d1067 2
a1068 2
		  ? BStrLen(anAnchor->post_data)
		  : 0,
d1074 2
a1075 1
    } else
d1083 1
a1083 1
		(anAnchor->post_data && !do_connect ? crlf : "")));
d1086 1
a1086 1
		(anAnchor->post_data ? crlf : "")));
d1091 1
a1091 1
    _HTProgress(gettext("Sending HTTP request."));
d1093 2
a1094 3
#ifdef    NOT_ASCII		/* S/390 -- gil -- 0548 */
    {
	char *p2;
d1096 3
a1098 5
	for (p2 = BStrData(command);
	     p2 < BStrData(command) + BStrLen(command);
	     p2++)
	    *p2 = TOASCII(*p2);
    }
d1100 12
a1111 12
    status = HTTP_NETWRITE(s, BStrData(command), BStrLen(command), handle);
    BStrFree(command);
    FREE(linebuf);
    if (status <= 0) {
	if (status == 0) {
	    CTRACE((tfp, "HTTP: Got status 0 in initial write\n"));
	    /* Do nothing. */
	} else if ((SOCKET_ERRNO == ENOTCONN ||
		    SOCKET_ERRNO == ECONNRESET ||
		    SOCKET_ERRNO == EPIPE) &&
		   !already_retrying &&
	    /* Don't retry if we're posting. */ !do_post) {
d1113 4
a1116 5
	     * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
	     */
	    CTRACE((tfp,
		    "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n"));
	    _HTProgress(RETRYING_AS_HTTP0);
d1121 23
a1143 9
	} else {
	    CTRACE((tfp,
		    "HTTP: Hit unexpected network WRITE error; aborting connection.\n"));
	    HTTP_NETCLOSE(s, handle);
	    status = -1;
	    HTAlert(gettext("Unexpected network write error; connection aborted."));
	    goto done;
	}
    }
d1145 17
a1161 18
    CTRACE((tfp, "HTTP: WRITE delivered OK\n"));
    _HTProgress(gettext("HTTP request sent; waiting for response."));

    /*    Read the first line of the response
     * -----------------------------------
     */
    {
	/* Get numeric status etc */
	BOOL end_of_file = NO;
	int buffer_length = INIT_LINE_SIZE;

	line_buffer = typecallocn(char, buffer_length);

	if (line_buffer == NULL)
	    outofmem(__FILE__, "HTLoadHTTP");

	HTReadProgress(bytes_already_read = 0, 0);
	do {			/* Loop to read in the first line */
d1163 2
a1164 1
	     * Extend line buffer if necessary for those crazy WAIS URLs ;-)
d1166 10
a1175 27
	    if (buffer_length - length < LINE_EXTEND_THRESH) {
		buffer_length = buffer_length + buffer_length;
		line_buffer =
		    (char *) realloc(line_buffer, (buffer_length * sizeof(char)));

		if (line_buffer == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
	    }
	    CTRACE((tfp, "HTTP: Trying to read %d\n", buffer_length - length - 1));
	    status = HTTP_NETREAD(s, line_buffer + length,
				  buffer_length - length - 1, handle);
	    CTRACE((tfp, "HTTP: Read %d\n", status));
	    if (status <= 0) {
		/*
		 * Retry if we get nothing back too.
		 * Bomb out if we get nothing twice.
		 */
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp, "HTTP: Interrupted initial read.\n"));
		    _HTProgress(CONNECTION_INTERRUPTED);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;
		} else if (status < 0 &&
			   (SOCKET_ERRNO == ENOTCONN ||
#ifdef _WINDOWS			/* 1997/11/09 (Sun) 16:59:58 */
			    SOCKET_ERRNO == ETIMEDOUT ||
d1177 10
a1186 11
			    SOCKET_ERRNO == ECONNRESET ||
			    SOCKET_ERRNO == EPIPE) &&
			   !already_retrying && !do_post) {
		    /*
		     * Arrrrgh, HTTP 0/1 compability problem, maybe.
		     */
		    CTRACE((tfp,
			    "HTTP: BONZO Trying again with HTTP0 request.\n"));
		    HTTP_NETCLOSE(s, handle);
		    FREE(line_buffer);
		    FREE(line_kept_clean);
d1188 11
a1198 13
		    extensions = NO;
		    already_retrying = TRUE;
		    _HTProgress(RETRYING_AS_HTTP0);
		    goto try_again;
		} else {
		    CTRACE((tfp,
			    "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			    status));
		    HTAlert(gettext("Unexpected network read error; connection aborted."));
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
d1200 4
a1203 3
#ifdef    NOT_ASCII		/* S/390 -- gil -- 0564 */
	    {
		char *p2;
d1205 3
a1207 5
		for (p2 = line_buffer + length;
		     p2 < line_buffer + length + status;
		     p2++)
		    *p2 = FROMASCII(*p2);
	    }
d1210 2
a1211 2
	    bytes_already_read += status;
	    HTReadProgress(bytes_already_read, 0);
d1213 2
a1214 2
#ifdef UCX			/* UCX returns -1 on EOF */
	    if (status == 0 || status == -1)
d1216 1
a1216 1
	    if (status == 0)
d1218 3
a1220 26
	    {
		end_of_file = YES;
		break;
	    }
	    line_buffer[length + status] = 0;

	    if (line_buffer) {
		FREE(line_kept_clean);
		line_kept_clean = (char *) malloc(buffer_length * sizeof(char));

		if (line_kept_clean == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
		memcpy(line_kept_clean, line_buffer, buffer_length);
		real_length_of_line = length + status;
	    }

	    eol = strchr(line_buffer + length, LF);
	    /* Do we *really* want to do this? */
	    if (eol && eol != line_buffer && *(eol - 1) == CR)
		*(eol - 1) = ' ';

	    length = length + status;

	    /* Do we really want to do *this*? */
	    if (eol)
		*eol = 0;	/* Terminate the line */
d1222 1
a1222 46
	/* All we need is the first line of the response.  If it's a HTTP/1.0
	 * response, then the first line will be absurdly short and therefore
	 * we can safely gate the number of bytes read through this code (as
	 * opposed to below) to ~1000.
	 *
	 * Well, let's try 100.
	 */
	while (!eol && !end_of_file && bytes_already_read < 100);
    }				/* Scope of loop variables */

    /* save total length, in case we decide later to show it all - kw */
    rawlength = length;

    /*    We now have a terminated unfolded line.  Parse it.
     * --------------------------------------------------
     */
    CTRACE((tfp, "HTTP: Rx: %s\n", line_buffer));

    /*
     * Kludge to work with old buggy servers and the VMS Help gateway.  They
     * can't handle the third word, so we try again without it.
     */
    if (extensions &&		/* Old buggy server or Help gateway? */
	(0 == strncmp(line_buffer, "<TITLE>Bad File Request</TITLE>", 31) ||
	 0 == strncmp(line_buffer, "Address should begin with", 25) ||
	 0 == strncmp(line_buffer, "<TITLE>Help ", 12) ||
	 0 == strcmp(line_buffer,
		     "Document address invalid or access not authorised"))) {
	FREE(line_buffer);
	FREE(line_kept_clean);
	extensions = NO;
	already_retrying = TRUE;
	CTRACE((tfp, "HTTP: close socket %d to retry with HTTP0\n", s));
	HTTP_NETCLOSE(s, handle);
	/* print a progress message */
	_HTProgress(RETRYING_AS_HTTP0);
	goto try_again;
    } {
	int fields;
	char server_version[VERSION_LENGTH + 1];

	server_version[0] = 0;

	fields = sscanf(line_buffer, "%20s %d",
			server_version,
			&server_status);
d1224 69
a1292 1
	CTRACE((tfp, "HTTP: Scanned %d fields from line_buffer\n", fields));
d1294 1
a1294 2
	if (http_error_file) {	/* Make the status code externally available */
	    FILE *error_file;
d1296 2
d1299 5
a1303 5
	    error_file = fopen(http_error_file, TXT_W);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "error=%d\n", server_status);
		fclose(error_file);
	    }
d1305 6
a1310 6
	    error_file = fopen(http_error_file, TXT_A);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "   URL=%s (%s)\n", url, METHOD);
		fprintf(error_file, "STATUS=%s\n", line_buffer);
		fclose(error_file);
	    }
d1312 1
a1312 1
	}
d1314 7
d1322 1
a1322 1
	 * Rule out a non-HTTP/1.n reply as best we can.
d1324 1
a1324 8
	if (fields < 2 || !server_version[0] || server_version[0] != 'H' ||
	    server_version[1] != 'T' || server_version[2] != 'T' ||
	    server_version[3] != 'P' || server_version[4] != '/' ||
	    server_version[6] != '.') {
	    /*
	     * Ugh!  An HTTP0 reply,
	     */
	    HTAtom *encoding;
d1326 1
a1326 1
	    CTRACE((tfp, "--- Talking HTTP0.\n"));
d1328 11
a1338 1
	    format_in = HTFileFormat(url, &encoding, NULL);
d1340 7
a1346 16
	     * Treat all plain text as HTML.  This sucks but its the only
	     * solution without without looking at content.
	     */
	    if (!strncmp(HTAtom_name(format_in), "text/plain", 10)) {
		CTRACE((tfp, "HTTP: format_in being changed to text/HTML\n"));
		format_in = WWW_HTML;
	    }
	    if (!IsUnityEnc(encoding)) {
		/*
		 * Change the format to that for "www/compressed".
		 */
		CTRACE((tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in)));
		StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
		StrAllocCopy(anAnchor->content_encoding, HTAtom_name(encoding));
		format_in = HTAtom_for("www/compressed");
		CTRACE((tfp, "        Treating as '%s' with encoding '%s'\n",
d1348 9
a1356 1
	    }
d1358 10
a1367 7
	    start_of_data = line_kept_clean;
	} else {
	    /*
	     * Set up to decode full HTTP/1.n response.  - FM
	     */
	    format_in = HTAtom_for("www/mime");
	    CTRACE((tfp, "--- Talking HTTP1.\n"));
d1369 6
a1374 9
	    /*
	     * We set start_of_data to "" when !eol here because there will be
	     * a put_block done below; we do *not* use the value of
	     * start_of_data (as a pointer) in the computation of length (or
	     * anything else) when !eol.  Otherwise, set the value of length to
	     * what we have beyond eol (i.e., beyond the status line).  - FM
	     */
	    start_of_data = eol ? eol + 1 : "";
	    length = eol ? length - (start_of_data - line_buffer) : 0;
d1376 5
d1382 12
a1393 5
	     * Trim trailing spaces in line_buffer so that we can use it in
	     * messages which include the status line.  - FM
	     */
	    while (line_buffer[strlen(line_buffer) - 1] == ' ')
		line_buffer[strlen(line_buffer) - 1] = '\0';
d1395 1
d1397 3
a1399 4
	     * Take appropriate actions based on the status.  - FM
	     */
	    switch (server_status / 100) {
	    case 1:
d1401 2
a1402 7
		 * HTTP/1.1 Informational statuses.
		 * 100 Continue.
		 * 101 Switching Protocols.
		 * > 101 is unknown.
		 * We should never get these, and they have only the status
		 * line and possibly other headers, so we'll deal with them by
		 * showing the full header to the user as text/plain.  - FM
d1404 1
a1404 2
		HTAlert(gettext("Got unexpected Informational Status."));
		do_head = TRUE;
d1406 11
d1418 1
a1418 1
	    case 2:
d1420 5
a1424 1
		 * Good:  Got MIME object!  (Successful) - FM
d1426 4
a1429 18
		if (do_head) {
		    /*
		     * If HEAD was requested, show headers (and possibly bogus
		     * body) for all 2xx status codes as text/plain - KW
		     */
		    HTProgress(line_buffer);
		    break;
		}
		switch (server_status) {
		case 204:
		    /*
		     * No Content.
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    HTNoDataOK = 1;
		    status = HT_NO_DATA;
		    goto clean_up;
d1431 11
a1441 11
		case 205:
		    /*
		     * Reset Content.  The server has fulfilled the request but
		     * nothing is returned and we should reset any form
		     * content.  We'll instruct the user to do that, and
		     * restore the current document.  - FM
		     */
		    HTAlert(gettext("Request fulfilled.  Reset Content."));
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;
d1443 9
a1451 20
		case 206:
		    /*
		     * Partial Content.  We didn't send a Range so something
		     * went wrong somewhere.  Show the status message and
		     * restore the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;

		default:
		    /*
		     * 200 OK.
		     * 201 Created.
		     * 202 Accepted.
		     * 203 Non-Authoritative Information.
		     * > 206 is unknown.
		     * All should return something to display.
		     */
d1453 2
a1454 3
		    if (do_connect) {
			CTRACE((tfp,
				"HTTP: Proxy tunnel to '%s' established.\n",
d1456 5
a1460 20
			do_connect = FALSE;
			url = connect_url;
			FREE(line_buffer);
			FREE(line_kept_clean);
			if (!strncmp(connect_url, "snews", 5)) {
			    CTRACE((tfp,
				    "      Will attempt handshake and snews connection.\n"));
			    status = HTNewsProxyConnect(s, url, anAnchor,
							format_out, sink);
			    goto done;
			}
			did_connect = TRUE;
			already_retrying = TRUE;
			eol = 0;
			bytes_already_read = 0;
			had_header = NO;
			length = 0;
			doing_redirect = FALSE;
			permanent_redirection = FALSE;
			target = NULL;
d1462 4
a1465 2
				"      Will attempt handshake and resubmit headers.\n"));
			goto use_tunnel;
d1467 13
d1481 24
a1504 2
		    HTProgress(line_buffer);
		}		/* case 2 switch */
d1506 1
d1508 1
a1508 1
	    case 3:
d1510 9
a1518 10
		 * Various forms of Redirection.  - FM
		 * 300 Multiple Choices.
		 * 301 Moved Permanently.
		 * 302 Found (temporary; we can, and do, use GET).
		 * 303 See Other (temporary; always use GET).
		 * 304 Not Modified.
		 * 305 Use Proxy.
		 * 306 Set Proxy.
		 * 307 Temporary Redirect with method retained.
		 * > 308 is unknown.
d1520 8
a1527 1
		if (no_url_redirection || do_head || keep_mime_headers) {
d1529 3
a1531 3
		     * If any of these flags are set, we do not redirect, but
		     * instead show what was returned to the user as
		     * text/plain.  - FM
d1533 1
a1533 2
		    HTProgress(line_buffer);
		    break;
d1535 14
d1550 15
a1564 1
		if (server_status == 300) {	/* Multiple Choices */
d1566 3
a1568 9
		     * For client driven content negotiation.  The server
		     * should be sending some way for the user-agent to make a
		     * selection, so we'll show the user whatever the server
		     * returns.  There might be a Location:  header with the
		     * server's preference present, but the choice should be up
		     * to the user, someday based on an Alternates:  header,
		     * and a body always should be present with descriptions
		     * and links for the choices (i.e., we use the latter, for
		     * now).  - FM
d1570 1
a1570 15
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
d1572 2
d1575 79
a1653 8
		if (server_status == 304) {	/* Not Modified */
		    /*
		     * We didn't send an "If-Modified-Since" header, so this
		     * status is inappropriate.  We'll deal with it by showing
		     * the full header to the user as text/plain.  - FM
		     */
		    HTAlert(gettext("Got unexpected 304 Not Modified status."));
		    do_head = TRUE;
d1655 1
a1655 1
		}
d1657 7
a1663 11
		if (server_status == 305 ||
		    server_status == 306 ||
		    server_status > 307) {
		    /*
		     * Show user the content, if any, for 305, 306, or unknown
		     * status.  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
a1665 10
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}
d1667 3
a1669 39
		/*
		 * We do not load the file, but read the headers for the
		 * "Location:", check out that redirecting_url and if it's
		 * acceptible (e.g., not a telnet URL when we have that
		 * disabled), initiate a new fetch.  If that's another
		 * redirecting_url, we'll repeat the checks, and fetch
		 * initiations if acceptible, until we reach the actual URL, or
		 * the redirection limit set in HTAccess.c is exceeded.  If the
		 * status was 301 indicating that the relocation is permanent,
		 * we set the permanent_redirection flag to make it permanent
		 * for the current anchor tree (i.e., will persist until the
		 * tree is freed or the client exits).  If the redirection
		 * would include POST content, we seek confirmation from an
		 * interactive user, with option to use 303 for 301 (but not
		 * for 307), and otherwise refuse the redirection.  We also
		 * don't allow permanent redirection if we keep POST content. 
		 * If we don't find the Location header or it's value is
		 * zero-length, we display whatever the server returned, and
		 * the user should RELOAD that to try again, or make a
		 * selection from it if it contains links, or Left-Arrow to the
		 * previous document.  - FM
		 */
		{
		    if ((dump_output_immediately || traversal) &&
			do_post &&
			server_status != 303 &&
			server_status != 302 &&
			server_status != 301) {
			/*
			 * Don't redirect POST content without approval from an
			 * interactive user.  - FM
			 */
			HTTP_NETCLOSE(s, handle);
			status = -1;
			HTAlert(gettext("Redirection of POST content requires user approval."));
			if (traversal)
			    HTProgress(line_buffer);
			goto clean_up;
		    }
d1671 9
a1679 13
		    HTProgress(line_buffer);
		    if (server_status == 301) {		/* Moved Permanently */
			if (do_post) {
			    /*
			     * Don't make the redirection permanent if we have
			     * POST content.  - FM
			     */
			    CTRACE((tfp,
				    "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n"));
			    HTAlert(gettext("Have POST content.  Treating Permanent Redirection as Temporary.\n"));
			} else {
			    permanent_redirection = TRUE;
			}
d1681 4
a1684 2
		    doing_redirect = TRUE;

d1686 6
d1694 1
a1694 1
	    case 4:
d1696 9
a1704 1
		 * "I think I goofed!" (Client Error) - FM
d1706 3
a1708 13
		switch (server_status) {
		case 401:	/* Unauthorized */
		    /*
		     * Authorization for orgin server required.  If show_401 is
		     * set, proceed to showing the 401 body.  Otherwise, if we
		     * can set up authorization based on the WWW-Authenticate
		     * header, and the user provides a username and password,
		     * try again.  Otherwise, check whether to show the 401
		     * body or restore the current document.  - FM
		     */
		    if (show_401)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, NO)) {
d1710 7
a1716 33
			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !authentication_info[0]) {
			    fprintf(stderr,
				    "HTTP: Access authorization required.\n");
			    fprintf(stderr,
				    "       Use the -auth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}

			CTRACE((tfp, "%s %d %s\n",
				"HTTP: close socket", s,
				"to retry with Access Authorization"));

			_HTProgress(gettext("Retrying with access authorization information."));
			FREE(line_buffer);
			FREE(line_kept_clean);
#ifdef USE_SSL
			if (using_proxy && !strncmp(url, "https://", 8)) {
			    url = arg;
			    do_connect = TRUE;
			    did_connect = FALSE;
			}
#endif /* USE_SSL */
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 401 message body?"))) {
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_AUTH);
			HTTP_NETCLOSE(s, handle);
			status = -1;
d1720 1
a1720 25
		case 407:
		    /*
		     * Authorization for proxy server required.  If we are not
		     * in fact using a proxy, or show_407 is set, proceed to
		     * showing the 407 body.  Otherwise, if we can set up
		     * authorization based on the Proxy-Authenticate header,
		     * and the user provides a username and password, try
		     * again.  Otherwise, check whether to show the 401 body or
		     * restore the current document.  - FM & AJL
		     */
		    if (!using_proxy || show_407)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, YES)) {

			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !proxyauth_info[0]) {
			    fprintf(stderr,
				    "HTTP: Proxy authorization required.\n");
			    fprintf(stderr,
				    "       Use the -pauth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}

			CTRACE((tfp, "%s %d %s\n",
d1724 6
a1729 59
			_HTProgress(HTTP_RETRY_WITH_PROXY);
			FREE(line_buffer);
			FREE(line_kept_clean);
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 407 message body?"))) {
			if (!dump_output_immediately &&
			    format_out == HTAtom_for("www/download")) {
			    /*
			     * Convert a download request to a presentation
			     * request for interactive users.  - FM
			     */
			    format_out = WWW_PRESENT;
			}
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_PROXY);
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }

		case 408:
		    /*
		     * Request Timeout.  Show the status message and restore
		     * the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto done;

		default:
		    /*
		     * 400 Bad Request.
		     * 402 Payment Required.
		     * 403 Forbidden.
		     * 404 Not Found.
		     * 405 Method Not Allowed.
		     * 406 Not Acceptable.
		     * 409 Conflict.
		     * 410 Gone.
		     * 411 Length Required.
		     * 412 Precondition Failed.
		     * 413 Request Entity Too Large.
		     * 414 Request-URI Too Long.
		     * 415 Unsupported Media Type.
		     * 416 List Response (for content negotiation).
		     * > 416 is unknown.
		     * Show the status message, and display the returned text
		     * if we are not doing a traversal.  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
d1733 3
a1735 2
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
d1740 7
a1746 2
		}		/* case 4 switch */
		break;
d1748 1
a1748 1
	    case 5:
d1750 2
a1751 10
		 * "I think YOU goofed!" (server error)
		 * 500 Internal Server Error
		 * 501 Not Implemented
		 * 502 Bad Gateway
		 * 503 Service Unavailable
		 * 504 Gateway Timeout
		 * 505 HTTP Version Not Supported
		 * > 505 is unknown.
		 * Should always include a message, which we always should
		 * display.  - FM
d1754 3
a1756 14
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
		    /*
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
		     */
		    format_out = WWW_PRESENT;
		}
		break;
d1758 1
a1758 1
	    default:
d1760 18
a1777 2
		 * Bad or unknown server_status number.  Take a chance and hope
		 * there is something to display.  - FM
a1778 1
		HTAlert(gettext("Unknown status reply from server!"));
d1788 3
a1790 2
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
d1795 2
a1796 4
	    }			/* Switch on server_status/100 */

	}			/* Full HTTP reply */
    }				/* scope of fields */
d1798 1
a1798 11
    /*
     * The user may have pressed the 'z'ap key during the pause caused by one
     * of the HTAlerts above if the server reported an error, to skip loading
     * of the error response page.  Checking here before setting up the stream
     * stack and feeding it data avoids doing unnecessary work, it also can
     * avoid unnecessarily pushing a loaded document out of the cache to make
     * room for the unwanted error page.  - kw
     */
    if (HTCheckForInterrupt()) {
	HTTP_NETCLOSE(s, handle);
	if (doing_redirect) {
d1800 19
a1818 104
	     * Impatient user.  - FM
	     */
	    CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	}
	status = HT_INTERRUPTED;
	goto clean_up;
    }
    /*
     * Set up the stream stack to handle the body of the message.
     */
    if (do_head || keep_mime_headers) {
	/*
	 * It was a HEAD request, or we want the headers and source.
	 */
	start_of_data = line_kept_clean;
#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
/* GIF file contains \0, so strlen does not return the data length */
	length = real_length_of_line;
#else
	length = rawlength;
#endif
	format_in = HTAtom_for("text/plain");

    } else if (doing_redirect) {

	format_in = HTAtom_for("message/x-http-redirection");
	StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
	if (traversal) {
	    format_out = WWW_DEBUG;
	    if (!sink)
		sink = HTErrorStream();
	} else if (!dump_output_immediately &&
		   format_out == HTAtom_for("www/download")) {
	    /*
	     * Convert a download request to a presentation request for
	     * interactive users.  - FM
	     */
	    format_out = WWW_PRESENT;
	}
    }

    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);

    if (!target || target == NULL) {
	char *buffer = NULL;

	HTTP_NETCLOSE(s, handle);
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	_HTProgress(buffer);
	FREE(buffer);
	status = -1;
	goto clean_up;
    }

    /*
     * Recycle the first chunk of data, in all cases.
     */
    (*target->isa->put_block) (target, start_of_data, length);

    /*
     * Go pull the bulk of the data down.
     */
    rv = HTCopy(anAnchor, s, (void *) handle, target);

    /*
     * If we get here with doing_redirect set, it means that we were looking
     * for a Location header.  We either have got it now in redirecting_url -
     * in that case the stream should not have loaded any data.  Or we didn't
     * get it, in that case the stream may have presented the message body
     * normally.  - kw
     */

    if (rv == -1) {
	/*
	 * Intentional interrupt before data were received, not an error
	 */
/* (*target->isa->_abort)(target, NULL); *//* already done in HTCopy */
	if (doing_redirect && traversal)
	    status = -1;
	else
	    status = HT_INTERRUPTED;
	HTTP_NETCLOSE(s, handle);
	goto clean_up;
    }

    if (rv == -2) {
	/*
	 * Aw hell, a REAL error, maybe cuz it's a dumb HTTP0 server
	 */
	(*target->isa->_abort) (target, NULL);
	if (doing_redirect && redirecting_url) {
	    /*
	     * Got a location before the error occurred?  Then consider it an
	     * interrupt but proceed below as normal.  - kw
	     */
	    /* do nothing here */
	} else {
	    HTTP_NETCLOSE(s, handle);
	    if (!doing_redirect && !already_retrying && !do_post) {
		CTRACE((tfp, "HTTP: Trying again with HTTP0 request.\n"));
d1820 3
a1822 1
		 * May as well consider it an interrupt -- right?
d1824 1
a1824 9
		FREE(line_buffer);
		FREE(line_kept_clean);
		extensions = NO;
		already_retrying = TRUE;
		_HTProgress(RETRYING_AS_HTTP0);
		goto try_again;
	    } else {
		status = HT_NOT_LOADED;
		goto clean_up;
d1826 1
a1826 12
	}
    }

    /*
     * Free if complete transmission (socket was closed before return).  Close
     * socket if partial transmission (was freed on abort).
     */
    if (rv != HT_INTERRUPTED && rv != -2) {
	(*target->isa->_free) (target);
    } else {
	HTTP_NETCLOSE(s, handle);
    }
d1828 1
a1828 2
    if (doing_redirect) {
	if (redirecting_url) {
d1830 9
a1838 18
	     * Set up for checking redirecting_url in LYGetFile.c for
	     * restrictions before we seek the document at that Location.  - FM
	     */
	    CTRACE((tfp, "HTTP: Picked up location '%s'\n",
		    redirecting_url));
	    if (rv == HT_INTERRUPTED) {
		/*
		 * Intentional interrupt after data were received, not an error
		 * (probably).  We take it as a user request to abandon the
		 * redirection chain.
		 *
		 * This could reasonably be changed (by just removing this
		 * block), it would make sense if there are redirecting
		 * resources that "hang" after sending the headers.  - kw
		 */
		FREE(redirecting_url);
		CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
		status = HT_INTERRUPTED;
d1841 2
a1842 18
	    HTProgress(line_buffer);
	    if (server_status == 305) {		/* Use Proxy */
		/*
		 * Make sure the proxy field ends with a slash.  - FM
		 */
		if (redirecting_url[strlen(redirecting_url) - 1]
		    != '/')
		    StrAllocCat(redirecting_url, "/");
		/*
		 * Append our URL.  - FM
		 */
		StrAllocCat(redirecting_url, anAnchor->address);
		CTRACE((tfp, "HTTP: Proxy URL is '%s'\n",
			redirecting_url));
	    }
	    if (!do_post ||
		server_status == 303 ||
		server_status == 302) {
d1844 3
a1846 4
		 * We don't have POST content (nor support PUT or DELETE), or
		 * the status is "See Other" or "General Redirection" and we
		 * can convert to GET, so go back and check out the new URL.  -
		 * FM
d1848 1
a1848 2
		status = HT_REDIRECTING;
		goto clean_up;
d1850 2
a1851 21
	    /*
	     * Make sure the user wants to redirect the POST content, or treat
	     * as GET - FM & DK
	     */
	    switch (HTConfirmPostRedirect(redirecting_url,
					  server_status)) {
		/*
		 * User failed to confirm.  Abort the fetch.
		 */
	    case 0:
		doing_redirect = FALSE;
		FREE(redirecting_url);
		status = HT_NO_DATA;
		goto clean_up;

		/*
		 * User wants to treat as GET with no content.  Go back to
		 * check out the URL.
		 */
	    case 303:
		break;
d1853 2
a1854 7
		/*
		 * Set the flag to retain the POST content and go back to check
		 * out the URL.  - FM
		 */
	    default:
		redirect_post_content = TRUE;
	    }
d1856 36
a1891 7
	    /* Lou's old comment:  - FM */
	    /* OK, now we've got the redirection URL temporarily stored
	       in external variable redirecting_url, exported from HTMIME.c,
	       since there's no straightforward way to do this in the library
	       currently.  Do the right thing. */

	    status = HT_REDIRECTING;
d1893 1
a1893 3
	} else {
	    status = traversal ? -1 : HT_LOADED;
	}
d1895 221
a2115 21
    } else {
	/*
	 * If any data were received, treat as a complete transmission
	 */
	status = HT_LOADED;
    }

    /*
     * Clean up
     */
  clean_up:
    FREE(line_buffer);
    FREE(line_kept_clean);

  done:
    /*
     * Clear out on exit, just in case.
     */
    do_head = FALSE;
    do_post = FALSE;
    reloading = FALSE;
d2117 7
a2123 7
    do_connect = FALSE;
    did_connect = FALSE;
    FREE(connect_host);
    if (handle) {
	SSL_free(handle);
	SSL_handle = handle = NULL;
    }
d2125 1
a2125 1
    return status;
d2132 1
a2132 1
GLOBALDEF(HTProtocol, HTTP, _HTTP_C_GLOBALDEF_1_INIT);
d2134 1
a2134 1
GLOBALDEF(HTProtocol, HTTPS, _HTTP_C_GLOBALDEF_2_INIT);
d2136 2
a2137 4
GLOBALDEF HTProtocol HTTP =
{"http", HTLoadHTTP, 0};
GLOBALDEF HTProtocol HTTPS =
{"https", HTLoadHTTP, 0};
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d49 3
d348 1
a348 1
	    CTRACE((tfp, "parsed:%s\n", fake));
d1901 1
a1901 1
    if (target == NULL) {
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a355 34
/*
 * Check if the user's options specified to use the given encoding.  Normally
 * all encodings with compiled-in support are specified (encodingALL).
 */
static BOOL acceptEncoding (int code)
{
    BOOL result = FALSE;
    if ((code & LYAcceptEncoding) != 0) {
	const char *program = 0;
	switch (code) {
	case encodingGZIP:
	    program = HTGetProgramPath(ppGZIP);
	    break;
	case encodingDEFLATE:
	    program = HTGetProgramPath(ppINFLATE);
	    break;
	case encodingCOMPRESS:
	    program = HTGetProgramPath(ppCOMPRESS);
	    break;
	case encodingBZIP2:
	    program = HTGetProgramPath(ppBZIP2);
	    break;
	default:
	    break;
	}
	/*
	 * FIXME:  if lynx did not rely upon external programs to decompress
	 * files for external viewers, this check could be relaxed.
	 */
	result = (program != 0);
    }
    return result;
}

d748 1
a748 1
		if (acceptEncoding(j)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d1 1
a1 1
/*	HyperText Tranfer Protocol	- Client implementation		HTTP.c
a9 3
#if defined(__DJGPP__) && defined (WATT32)
#include <tcp.h>
#endif /* __DJGPP__ */
d14 5
a18 2
#include <HTNews.h>
#endif
d80 1
a80 1
	SSL_CTX_free(ssl_ctx);
d86 1
a86 1
	/*
d90 1
a90 1
	ssl_ctx = SSL_CTX_new();
a102 38
PUBLIC void HTSSLInitPRNG NOARGS
{
#if SSLEAY_VERSION_NUMBER >= 0x00905100
    if (RAND_status() == 0) {
	char rand_file[256];
	time_t t;
	pid_t pid;
	long l,seed;

	t = time(NULL);
	pid = getpid();
	RAND_file_name(rand_file, 256);
	CTRACE((tfp,"HTTP: Seeding PRNG\n"));
	if(rand_file != NULL) {
	    /* Seed as much as 1024 bytes from RAND_file_name */
	    RAND_load_file(rand_file, 1024);
	}
	/* Seed in time (mod_ssl does this) */
	RAND_seed((unsigned char *)&t, sizeof(time_t));
	/* Seed in pid (mod_ssl does this) */
	RAND_seed((unsigned char *)&pid, sizeof(pid_t));
	/* Initialize system's random number generator */
	RAND_bytes((unsigned char *)&seed, sizeof(long));
	lynx_srand(seed);
	while (RAND_status() == 0) {
	    /* Repeatedly seed the PRNG using the system's random number generator until it has been seeded with enough data */
	    l = lynx_rand();
	    RAND_seed((unsigned char *)&l, sizeof(long));
	}
	if (rand_file != NULL) {
	    /* Write a rand_file */
	    RAND_write_file(rand_file);
	}
    }
#endif /* SSLEAY_VERSION_NUMBER >= 0x00905100 */
    return;
}

d110 4
a119 173
#ifdef _WINDOWS		/* 1997/11/06 (Thu) 13:00:08 */

#define	BOX_TITLE	"Lynx " __FILE__
#define	BOX_FLAG	(MB_ICONINFORMATION | MB_SETFOREGROUND)

typedef struct {
	int fd;
	char *buf;
	int len;
} recv_data_t;

PUBLIC int ws_read_per_sec = 0;
PRIVATE int ws_errno = 0;

PRIVATE DWORD g_total_times = 0;
PRIVATE DWORD g_total_bytes = 0;


PUBLIC char * str_speed(void)
{
    static char buff[32];

    if (ws_read_per_sec > 1000)
	sprintf(buff, "%d.%03dkB", ws_read_per_sec / 1000,
			(ws_read_per_sec % 1000) );
    else
	sprintf(buff, "%3d", ws_read_per_sec);

    return buff;
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

PRIVATE int ws_read(int fd, char *buf, int len)
{
     int res;
     int retry = 3;

     do {
	res = recv(fd, buf, len, 0);
	if (WSAEWOULDBLOCK == WSAGetLastError()) {
	  Sleep(100);
	  if (retry-- > 0)
	    continue;
	}
     } while (res == SOCKET_ERROR && SOCKET_ERRNO == EINTR);

     return res;
}

PRIVATE void _thread_func (void *p)
{
    int i, val, ret;
    recv_data_t *q = (recv_data_t *)p;

    i = 0;
    i++;
    val = ws_read(q->fd, q->buf, q->len);

    if (val == SOCKET_ERROR) {
	ws_errno = WSAGetLastError();
#if 0
	char buff[256];
	sprintf(buff, "Thread read: %d, error (%ld), fd = %d, len = %d",
		i, ws_errno, q->fd, q->len);
	MessageBox(NULL, buff, BOX_TITLE, BOX_FLAG);
#endif
	ret = -1;
    } else {
	ret = val;
    }

    ExitThread((DWORD)ret);
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

PUBLIC int ws_netread(int fd, char *buf, int len)
{
    int i;
    char buff[256];

     /* 1998/03/30 (Mon) 09:01:21 */
    HANDLE hThread;
    DWORD dwThreadID;
    DWORD exitcode = 0;
    DWORD ret_val = -1, val, process_time, now_TickCount, save_TickCount;

    static recv_data_t para;

    extern int win32_check_interrupt(void);	/* LYUtil.c */
    extern int lynx_timeout;			/* LYMain.c */
    extern int AlertSecs;			/* LYMain.c */
    extern CRITICAL_SECTION critSec_READ;	/* LYMain.c */

#define TICK	5
#define STACK_SIZE	0x2000uL

    InitializeCriticalSection(&critSec_READ);

    para.fd = fd;
    para.buf = buf;
    para.len = len;

    ws_read_per_sec = 0;
    save_TickCount = GetTickCount();

    hThread = CreateThread((void *)NULL, STACK_SIZE,
		 (LPTHREAD_START_ROUTINE)_thread_func,
		 (void *)&para, 0UL, &dwThreadID);

    if (hThread == 0) {
	HTInfoMsg("CreateThread Failed (read)");
	goto read_exit;
    }

    i = 0;
    while (1) {
	val = WaitForSingleObject(hThread, 1000/TICK);
	i++;
	if (val == WAIT_FAILED) {
	    HTInfoMsg("Wait Failed");
	    ret_val = -1;
	    break;
	} else if (val == WAIT_TIMEOUT) {
	    i++;
	    if (i/TICK > (AlertSecs + 2)) {
		sprintf(buff, "Read Waiting (%2d.%01d) for %d Bytes",
			i/TICK, (i%TICK) * 10 / TICK, len);
		SetConsoleTitle(buff);
	    }
	    if (win32_check_interrupt() || ((i/TICK) > lynx_timeout)) {
		if (CloseHandle(hThread) == FALSE) {
		    HTInfoMsg("Thread terminate Failed");
		}
		WSASetLastError(ETIMEDOUT);
		ret_val = HT_INTERRUPTED;
		break;
	    }
	} else if (val == WAIT_OBJECT_0) {
	    if (GetExitCodeThread(hThread, &exitcode) == FALSE) {
		exitcode = -1;
	    }
	    if (CloseHandle(hThread) == FALSE) {
		HTInfoMsg("Thread terminate Failed");
	    }
	    now_TickCount = GetTickCount();
	    if (now_TickCount > save_TickCount)
		process_time = now_TickCount - save_TickCount;
	    else
		process_time = now_TickCount + (0xffffffff - save_TickCount);

	    g_total_times += process_time;
	    g_total_bytes += exitcode;

	    if (g_total_bytes > 2000000) {
		ws_read_per_sec = g_total_bytes / (g_total_times/1000);
	    } else {
		ws_read_per_sec = g_total_bytes * 1000 / g_total_times;
	    }
	    ret_val = exitcode;
	    break;
	}
    }	/* end while(1) */

    read_exit:
    LeaveCriticalSection(&critSec_READ);
    return ret_val;
}
#endif

d146 1
a146 1
  char *command = NULL;		/* The whole command */
d151 1
a151 1
  char crlf[3];			/* A CR LF equivalent string */
d154 2
a155 2
  BOOL do_head = FALSE;		/* Whether or not we should do a head */
  BOOL do_post = FALSE;		/* ARE WE posting ? */
a160 1
  int real_length_of_line;
d162 1
a162 1
  char *linebuf = NULL;
d167 1
a167 1
  BOOL auth_proxy = NO;		/* Generate a proxy authorization. - AJL */
d169 2
a170 3
  int length, rawlength, rv;
  int server_status;
  BOOL doing_redirect, already_retrying = FALSE;
d174 2
a175 2
  BOOL do_connect = FALSE;	/* ARE WE going to use a proxy tunnel ? */
  BOOL did_connect = FALSE;	/* ARE WE actually using a proxy tunnel ? */
d177 2
a178 3
  char *connect_host = NULL;	/* The host being proxied */
  SSL * handle = NULL;		/* The SSL handle */
  char SSLprogress[256];	/* progress bar message */
d204 1
a204 1
      if ((connect_url = strstr((url+7), "https://"))) {
d211 3
a213 3
	  CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	  CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
      } else if ((connect_url = strstr((url+7), "snews://"))) {
d220 2
a221 2
	  CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	  CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
d248 1
a249 1
  if (!strncmp(url, "https", 5))
a253 1
  if (!strncmp(url, "https", 5))
d265 1
a265 1
       CTRACE((tfp, "HTTP: Interrupted on connect; recovering cleanly.\n"));
d271 2
a272 9
#ifdef _WINDOWS
      CTRACE((tfp, "HTTP: Unable to connect to remote host for `%s'\n"
			  " (status = %d, sock_errno = %d).\n",
			  url, status, SOCKET_ERRNO));
#else
      CTRACE((tfp,
	    "HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
	    url, SOCKET_ERRNO));
#endif
a277 5
/* *sob*  All this needs to be converted to handle binary strings
 * if we're going to be able to handle binary form uploads...
 * This is a nice long function as well.  *sigh*  -RJP
 */

d289 1
a289 1
	  handle->options|=SSL_OP_NO_TLSv1;
a290 1
      HTSSLInitPRNG();
d296 1
a296 1
	      CTRACE((tfp, "HTTP: Retrying connection without TLS\n"));
d300 2
a301 2
		  HTTP_NETCLOSE(s, handle);
	      goto try_again;
d303 4
a306 9
	      unsigned long SSLerror;
	      CTRACE((tfp,
"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
	      SSL_load_error_strings();
	      while((SSLerror=ERR_get_error())!=0) {
		  CTRACE((tfp,"HTTP: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	      }
	      HTAlert("Unable to make secure connection to remote host.");
d308 3
a310 3
		  HTTP_NETCLOSE(s, handle);
	      status = HT_NOT_LOADED;
	      goto done;
d313 4
a316 9
	  unsigned long SSLerror;
	  CTRACE((tfp,
"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
	  SSL_load_error_strings();
	  while((SSLerror=ERR_get_error())!=0) {
	      CTRACE((tfp,"HTTP: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	  }
	  HTAlert("Unable to make secure connection to remote host.");
d319 2
a320 2
	  status = HT_NOT_LOADED;
	  goto done;
d323 1
a323 2
      sprintf(SSLprogress,"Secure %d-bit %s (%s) HTTP connection",SSL_get_cipher_bits(handle,NULL),SSL_get_cipher_version(handle),SSL_get_cipher(handle));
      _HTProgress(SSLprogress);
d327 2
a328 2
		 strstr(X509_NAME_oneline(
			X509_get_subject_name(
d332 2
a333 2
			 X509_get_subject_name(
				handle->session->peer)),"/CN=")+4);
d371 2
a372 2
	else
	    StrAllocCat(command, p1+1);
d394 2
a395 1
	  HTSprintf(&command, "Host: %s%c%c", host, CR,LF);
d408 14
a421 5
	  if (pres->get_accept) {
	      if (pres->quality < 1.0) {
		  if (pres->maxbytes > 0) {
		      sprintf(temp, ";q=%4.3f;mxb=%ld",
				    pres->quality, pres->maxbytes);
d423 1
a423 1
		      sprintf(temp, ";q=%4.3f", pres->quality);
d425 3
a427 14
	      } else if (pres->maxbytes > 0) {
		  sprintf(temp, ";mxb=%ld", pres->maxbytes);
	      } else {
		  temp[0] = '\0';
	      }
	      HTSprintf0(&linebuf, "%s%s%s",
			    (first_Accept ?
			       "Accept: " : ", "),
			    HTAtom_name(pres->rep),
			    temp);
	      len += strlen(linebuf);
	      if (len > 252 && !first_Accept) {
		  StrAllocCat(command, crlf);
		  HTSprintf0(&linebuf, "Accept: %s%s",
d430 10
a439 1
		  len = strlen(linebuf);
a440 2
	      StrAllocCat(command, linebuf);
	      first_Accept = FALSE;
d443 1
a443 1
      HTSprintf(&command, "%s*/*;q=0.01%c%c",
d446 1
d450 1
a450 1
      HTSprintf(&command, "Accept-Encoding: %s, %s%c%c",
d452 1
d455 2
a456 1
	  HTSprintf(&command, "Accept-Language: %s%c%c", language, CR, LF);
d461 11
a471 10
	  StrAllocCopy(linebuf, pref_charset);
	  if (linebuf[strlen(linebuf)-1] == ',')
	      linebuf[strlen(linebuf)-1] = '\0';
	  LYLowerCase(linebuf);
	  if (strstr(linebuf, "iso-8859-1") == NULL)
	      StrAllocCat(linebuf, ", iso-8859-1;q=0.01");
	  if (strstr(linebuf, "us-ascii") == NULL)
	      StrAllocCat(linebuf, ", us-ascii;q=0.01");
	  StrAllocCat(command, linebuf);
	  HTSprintf(&command, "%c%c", CR, LF);
d498 2
a499 1
	  HTSprintf(&command, "Negotiate: trans%c%c", CR, LF);
d510 4
a513 2
	  HTSprintf(&command, "Pragma: no-cache%c%c", CR, LF);
	  HTSprintf(&command, "Cache-Control: no-cache%c%c", CR, LF);
d517 1
a517 5
	  char *cp = LYSkipBlanks(LYUserAgent);
	  /* Won't send it at all if all blank - kw */
	  if (*cp != '\0')
	      HTSprintf(&command, "User-Agent: %.*s%c%c",
		      INIT_LINE_SIZE-15, LYUserAgent, CR, LF);
d519 1
a519 1
	  HTSprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
d524 1
d527 2
a528 1
	  HTSprintf(&command, "From: %s%c%c", personal_mail_address, CR,LF);
d534 1
a534 2
	  char *cp = LYRequestReferer;
	  if (!cp) cp = HTLoadedDocumentURL(); /* @@@@@@ Try both? - kw */
d546 2
a547 1
	  HTSprintf(&command, "%c%c", CR, LF);
d557 1
a557 1
	BOOL secure = (BOOL) (strncmp(anAnchor->address, "https", 5) ?
d609 3
a611 2
		HTSprintf(&command, "%s%c%c", auth, CR, LF);
		CTRACE((tfp, "HTTP: Sending authorization: %s\n", auth));
d625 1
a625 1
		    if (did_connect)
d638 1
a638 1
		CTRACE((tfp, "HTTP: Not sending authorization (yet).\n"));
d671 1
a671 1
		CTRACE((tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n"));
d682 1
a682 1
		CTRACE((tfp, "HTTP: Sending Cookie: %s\n", cookie));
d705 3
a707 2
	    HTSprintf(&command, "%s%c%c", auth, CR, LF);
	    CTRACE((tfp, (auth_proxy ?
d710 1
a710 1
			auth));
d733 1
a733 1
	    CTRACE((tfp, (auth_proxy ?
d735 1
a735 1
			 "HTTP: Not sending authorization (yet).\n")));
a742 1
    if (
d744 3
a746 1
	!do_connect &&
d748 1
a748 2
	do_post) {
	CTRACE((tfp, "HTTP: Doing post, content-type '%s'\n",
d750 15
a764 15
						 : "lose"));
	HTSprintf(&command, "Content-type: %s%c%c",
		   anAnchor->post_content_type
		   ? anAnchor->post_content_type
		   : "lose",
		  CR, LF);
/*
 * Ack!  This assumes non-binary data!  Icky!
 *
 */
	HTSprintf(&command, "Content-length: %d%c%c",
		  (anAnchor->post_data)
		   ? strlen (anAnchor->post_data)
		   : 0,
		  CR, LF);
d766 1
a766 1
	StrAllocCat(command, crlf);	/* Blank line means "end" of headers */
d768 1
a768 1
	StrAllocCat(command, anAnchor->post_data);
d770 2
a771 2
    else
	StrAllocCat(command, crlf);	/* Blank line means "end" of headers */
d774 1
a774 1
  CTRACE((tfp, "Writing:\n%s%s----------------------------------\n",
d776 1
a776 1
	       (anAnchor->post_data && !do_connect ? crlf : "")));
d778 1
a778 1
  CTRACE((tfp, "Writing:\n%s%s----------------------------------\n",
d780 1
a780 1
	       (anAnchor->post_data ? crlf : "")));
a793 1
  FREE(linebuf);
d796 1
a796 1
	  CTRACE((tfp, "HTTP: Got status 0 in initial write\n"));
d806 1
a806 1
	    CTRACE((tfp, "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n"));
d813 1
a813 1
	  CTRACE((tfp, "HTTP: Hit unexpected network WRITE error; aborting connection.\n"));
d821 1
a821 1
  CTRACE((tfp, "HTTP: WRITE delivered OK\n"));
d832 1
a832 1
    line_buffer = typecallocn(char, buffer_length);
d848 2
a849 1
	CTRACE((tfp, "HTTP: Trying to read %d\n", buffer_length - length - 1));
d852 1
a852 1
	CTRACE((tfp, "HTTP: Read %d\n", status));
d859 1
a859 1
		CTRACE((tfp, "HTTP: Interrupted initial read.\n"));
a865 3
#ifdef _WINDOWS	/* 1997/11/09 (Sun) 16:59:58 */
			 SOCKET_ERRNO == ETIMEDOUT ||
#endif
d872 1
a872 1
		CTRACE((tfp, "HTTP: BONZO Trying again with HTTP0 request.\n"));
d882 2
a883 2
		CTRACE((tfp, "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			   status));
a918 1
	    real_length_of_line = length + status;
a941 2
  /* save total length, in case we decide later to show it all - kw */
  rawlength = length;
d946 1
a946 1
  CTRACE((tfp, "HTTP: Rx: %s\n", line_buffer));
d962 1
a962 1
      CTRACE((tfp, "HTTP: close socket %d to retry with HTTP0\n", s));
d973 1
d981 1
a981 1
    CTRACE((tfp, "HTTP: Scanned %d fields from line_buffer\n", fields));
d986 1
a986 1
	error_file = fopen(http_error_file, TXT_W);
d992 1
a992 1
	error_file = fopen(http_error_file, TXT_A);
d1013 1
a1013 1
	CTRACE((tfp, "--- Talking HTTP0.\n"));
d1022 1
a1022 1
	    CTRACE((tfp, "HTTP: format_in being changed to text/HTML\n"));
d1029 1
a1029 1
	    CTRACE((tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in)));
d1033 2
a1034 2
	    CTRACE((tfp, "        Treating as '%s' with encoding '%s'\n",
			"www/compressed", HTAtom_name(encoding)));
d1043 1
a1043 1
	CTRACE((tfp, "--- Talking HTTP1.\n"));
a1100 1
		HTNoDataOK = 1;
d1138 4
a1141 4
#if defined(USE_SSL) && !defined(DISABLE_NEWS)
		if (do_connect) {
		    CTRACE((tfp, "HTTP: Proxy tunnel to '%s' established.\n",
				connect_host));
d1147 2
a1148 2
			CTRACE((tfp,
			"      Will attempt handshake and snews connection.\n"));
d1160 1
a1160 1
		    permanent_redirection = FALSE;
d1162 2
a1163 2
		    CTRACE((tfp,
			"      Will attempt handshake and resubmit headers.\n"));
d1286 2
d1306 28
a1333 1
	      HTProgress(line_buffer);
d1335 1
d1341 1
a1341 1
		      CTRACE((tfp, "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n"));
a1347 1
	      doing_redirect = TRUE;
d1349 334
d1716 1
a1716 1
		    CTRACE((tfp, "%s %d %s\n",
d1718 1
a1718 1
				"to retry with Access Authorization"));
d1769 1
a1769 1
		    CTRACE((tfp, "%s %d %s\n",
d1771 1
a1771 1
				"to retry with Proxy Authorization"));
a1915 7
      if (doing_redirect) {
	  /*
	   *  Impatient user. - FM
	   */
	  CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	  _HTProgress (CONNECTION_INTERRUPTED);
      }
d1927 1
a1927 6
#ifdef SH_EX	/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
/* GIF file contains \0, so strlen does not return the data length */
      length = real_length_of_line;
#else
      length = rawlength;
#endif
a1928 18

  } else if (doing_redirect) {

      format_in = HTAtom_for("message/x-http-redirection");
      StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
      if (traversal) {
	  format_out = WWW_DEBUG;
	  if (!sink)
	      sink = HTErrorStream();
      } else if (!dump_output_immediately &&
	  format_out == HTAtom_for("www/download")) {
	  /*
	   *  Convert a download request to
	   *  a presentation request for
	   *  interactive users. - FM
	   */
	  format_out = WWW_PRESENT;
      }
d1936 1
a1936 1
      char *buffer = NULL;
d1939 1
a1939 1
      HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
a1941 1
      FREE(buffer);
a1955 8
  /*
  **  If we get here with doing_redirect set, it means that we were
  **  looking for a Location header.  We either have got it now in
  **  redirecting_url - in that case the stream should not have loaded
  **  any data.  Or we didn't get it, in that case the stream may have
  **  presented the message body normally. - kw
  */

d1961 1
a1961 4
      if (doing_redirect && traversal)
	  status = -1;
      else
	  status = HT_INTERRUPTED;
d1971 3
a1973 1
      if (doing_redirect && redirecting_url) {
d1975 1
a1975 2
	  **  Got a location before the error occurred?  Then consider it
	  **  an interrupt but proceed below as normal. - kw
d1977 6
a1982 1
	  /* do nothing here */
d1984 2
a1985 16
	  HTTP_NETCLOSE(s, handle);
	  if (!doing_redirect && !already_retrying && !do_post) {
	      CTRACE((tfp, "HTTP: Trying again with HTTP0 request.\n"));
	      /*
	      **  May as well consider it an interrupt -- right?
	      */
	      FREE(line_buffer);
	      FREE(line_kept_clean);
	      extensions = NO;
	      already_retrying = TRUE;
	      _HTProgress (RETRYING_AS_HTTP0);
	      goto try_again;
	  } else {
	      status = HT_NOT_LOADED;
	      goto clean_up;
	  }
d1993 1
a1993 1
  if (rv != HT_INTERRUPTED && rv != -2) {
d2000 10
a2009 94
      if (redirecting_url) {
	  /*
	   *  Set up for checking redirecting_url in
	   *  LYGetFile.c for restrictions before we
	   *  seek the document at that Location. - FM
	   */
	  CTRACE((tfp, "HTTP: Picked up location '%s'\n",
		  redirecting_url));
	  if (rv == HT_INTERRUPTED) {
	      /*
	      **  Intentional interrupt after data were received, not an
	      **  error (probably).  We take it as a user request to
	      **  abandon the redirection chain.
	      **  This could reasonably be changed (by just removing this
	      **  block), it would make sense if there are redirecting
	      **  resources that "hang" after sending the headers. - kw
	      */
	      FREE(redirecting_url);
	      CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	      status = HT_INTERRUPTED;
	      goto clean_up;
	  }
	  HTProgress(line_buffer);
	  if (server_status == 305) { /* Use Proxy */
	      /*
	       *	Make sure the proxy field ends with
	       *	a slash. - FM
	       */
	      if (redirecting_url[strlen(redirecting_url)-1]
		  != '/')
		  StrAllocCat(redirecting_url, "/");
	      /*
	       *	Append our URL. - FM
	       */
	      StrAllocCat(redirecting_url, anAnchor->address);
	      CTRACE((tfp, "HTTP: Proxy URL is '%s'\n",
		      redirecting_url));
	  }
	  if (!do_post ||
	      server_status == 303 ||
	      server_status == 302) {
	      /*
	       *	We don't have POST content (nor support PUT
	       *	or DELETE), or the status is "See Other"  or
	       *	"General Redirection" and we can convert to
	       *	GET, so go back and check out the new URL. - FM
	       */
	      status = HT_REDIRECTING;
	      goto clean_up;
	  }
	  /*
	   *  Make sure the user wants to redirect
	   *  the POST content, or treat as GET - FM & DK
	   */
	  switch (HTConfirmPostRedirect(redirecting_url,
					server_status)) {
	      /*
	       *	User failed to confirm.
	       *	Abort the fetch.
	       */
	  case 0:
	      doing_redirect = FALSE;
	      FREE(redirecting_url);
	      status = HT_NO_DATA;
	      goto clean_up;

	      /*
	       *	User wants to treat as GET with no content.
	       *	Go back to check out the URL.
	       */
	  case 303:
	      break;

	      /*
	       *	Set the flag to retain the POST
	       *	content and go back to check out
	       *	the URL. - FM
	       */
	  default:
	      redirect_post_content = TRUE;
	  }

	  /* Lou's old comment:  - FM */
	  /* OK, now we've got the redirection URL temporarily stored
	     in external variable redirecting_url, exported from HTMIME.c,
	     since there's no straightforward way to do this in the library
	     currently.  Do the right thing. */

	  status = HT_REDIRECTING;

      } else {
	  status = traversal ? -1 : HT_LOADED;
      }

@

