head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.7
	tg-mergefixes-1-branch:1.1.3.7.0.4
	tg-mergefixes-1-base:1.1.3.7
	MIROS_X:1.1.3.7.0.2
	MIROS_X_BASE:1.1.3.7
	MIRBSD_XP_MIRPPC:1.1.3.6.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.6
	MIRBSD_XP_SPARC:1.1.3.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.6
	lynx-2_8_6dev_5:1.1.3.6
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.5
	lynx-2_8_5:1.1.3.4
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.18.16.55.46;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.13.12.35;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.02;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.07;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.00;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.38;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.53;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.08;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.26;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.02.08.13.06.03;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.04.30.16.15.16;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.07.15.15.47.36;	author tg;	state Stab;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.33;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/*		Parse HyperText Document Address		HTParse.c
 *		================================
 */

#include <HTUtils.h>
#include <HTParse.h>

#include <LYUtils.h>
#include <LYLeaks.h>
#include <LYStrings.h>
#include <LYCharUtils.h>

#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef __MINGW32__
#include <malloc.h>
#endif /* __MINGW32__ */
#endif

#define HEX_ESCAPE '%'

struct struct_parts {
    char *access;
    char *host;
    char *absolute;
    char *relative;
    char *search;		/* treated normally as part of path */
    char *anchor;
};

#if 0				/* for debugging */
static void show_parts(const char *name, struct struct_parts *parts, int line)
{
    if (TRACE) {
	CTRACE((tfp, "struct_parts(%s) %s@@%d\n", name, __FILE__, line));
	CTRACE((tfp, "   access   '%s'\n", NONNULL(parts->access)));
	CTRACE((tfp, "   host     '%s'\n", NONNULL(parts->host)));
	CTRACE((tfp, "   absolute '%s'\n", NONNULL(parts->absolute)));
	CTRACE((tfp, "   relative '%s'\n", NONNULL(parts->relative)));
	CTRACE((tfp, "   search   '%s'\n", NONNULL(parts->search)));
	CTRACE((tfp, "   anchor   '%s'\n", NONNULL(parts->anchor)));
    }
}
#define SHOW_PARTS(name) show_parts(#name, &name, __LINE__)
#else
#define SHOW_PARTS(name)	/* nothing */
#endif

/*	Strip white space off a string.				HTStrip()
 *	-------------------------------
 *
 * On exit,
 *	Return value points to first non-white character, or to 0 if none.
 *	All trailing white space is OVERWRITTEN with zero.
 */
char *HTStrip(char *s)
{
#define SPACE(c) ((c == ' ') || (c == '\t') || (c == '\n'))
    char *p = s;

    for (p = s; *p; p++) ;	/* Find end of string */
    for (p--; p >= s; p--) {
	if (SPACE(*p))
	    *p = '\0';		/* Zap trailing blanks */
	else
	    break;
    }
    while (SPACE(*s))
	s++;			/* Strip leading blanks */
    return s;
}

/*	Scan a filename for its constituents.			scan()
 *	-------------------------------------
 *
 * On entry,
 *	name	points to a document name which may be incomplete.
 * On exit,
 *	absolute or relative may be nonzero (but not both).
 *	host, anchor and access may be nonzero if they were specified.
 *	Any which are nonzero point to zero terminated strings.
 */
static void scan(char *name,
		 struct struct_parts *parts)
{
    char *after_access;
    char *p;

    parts->access = NULL;
    parts->host = NULL;
    parts->absolute = NULL;
    parts->relative = NULL;
    parts->search = NULL;	/* normally not used - kw */
    parts->anchor = NULL;

    /*
     * Scan left-to-right for a scheme (access).
     */
    after_access = name;
    for (p = name; *p; p++) {
	if (*p == ':') {
	    *p = '\0';
	    parts->access = name;	/* Access name has been specified */
	    after_access = (p + 1);
	    break;
	}
	if (*p == '/' || *p == '#' || *p == ';' || *p == '?')
	    break;
    }

    /*
     * Scan left-to-right for a fragment (anchor).
     */
    for (p = after_access; *p; p++) {
	if (*p == '#') {
	    parts->anchor = (p + 1);
	    *p = '\0';		/* terminate the rest */
	    break;		/* leave things after first # alone - kw */
	}
    }

    /*
     * Scan left-to-right for a host or absolute path.
     */
    p = after_access;
    if (*p == '/') {
	if (p[1] == '/') {
	    parts->host = (p + 2);	/* host has been specified    */
	    *p = '\0';		/* Terminate access           */
	    p = strchr(parts->host, '/');	/* look for end of host name if any */
	    if (p != NULL) {
		*p = '\0';	/* Terminate host */
		parts->absolute = (p + 1);	/* Root has been found */
	    } else {
		p = strchr(parts->host, '?');
		if (p != NULL) {
		    *p = '\0';	/* Terminate host */
		    parts->search = (p + 1);
		}
	    }
	} else {
	    parts->absolute = (p + 1);	/* Root found but no host */
	}
    } else {
	parts->relative = (*after_access) ?
	    after_access : NULL;	/* NULL for "" */
    }

    /*
     * Check schemes that commonly have unescaped hashes.
     */
    if (parts->access && parts->anchor &&
    /* optimize */ strchr("lnsdLNSD", *parts->access) != NULL) {
	if ((!parts->host && strcasecomp(parts->access, "lynxcgi")) ||
	    !strcasecomp(parts->access, "nntp") ||
	    !strcasecomp(parts->access, "snews") ||
	    !strcasecomp(parts->access, "news") ||
	    !strcasecomp(parts->access, "data")) {
	    /*
	     * Access specified but no host and not a lynxcgi URL, so the
	     * anchor may not really be one, e.g., news:j462#36487@@foo.bar, or
	     * it's an nntp or snews URL, or news URL with a host.  Restore the
	     * '#' in the address.
	     */
	    /* but only if we have found a path component of which this will
	     * become part. - kw  */
	    if (parts->relative || parts->absolute) {
		*(parts->anchor - 1) = '#';
		parts->anchor = NULL;
	    }
	}
    }
}				/*scan */

#if defined(HAVE_ALLOCA) && !defined(LY_FIND_LEAKS)
#define LYalloca(x)        alloca(x)
#define LYalloca_free(x)   {}
#else
#define LYalloca(x)        malloc(x)
#define LYalloca_free(x)   free(x)
#endif

static char *strchr_or_end(char *string, int ch)
{
    char *result = strchr(string, ch);

    if (result == 0) {
	result = string + strlen(string);
    }
    return result;
}

/*	Parse a Name relative to another name.			HTParse()
 *	--------------------------------------
 *
 *	This returns those parts of a name which are given (and requested)
 *	substituting bits from the related name where necessary.
 *
 * On entry,
 *	aName		A filename given
 *	relatedName	A name relative to which aName is to be parsed
 *	wanted		A mask for the bits which are wanted.
 *
 * On exit,
 *     returns         A pointer to a malloc'd string which MUST BE FREED
 */
char *HTParse(const char *aName,
	      const char *relatedName,
	      int wanted)
{
    char *result = NULL;
    char *tail = NULL;		/* a pointer to the end of the 'result' string */
    char *return_value = NULL;
    int len, len1, len2;
    char *name = NULL;
    char *rel = NULL;
    char *p, *q;
    char *acc_method;
    struct struct_parts given, related;

    CTRACE((tfp, "HTParse: aName:`%s'\n", aName));
    CTRACE((tfp, "   relatedName:`%s'\n", relatedName));

    if (wanted & (PARSE_STRICTPATH | PARSE_QUERY)) {	/* if detail wanted... */
	if ((wanted & (PARSE_STRICTPATH | PARSE_QUERY))
	    == (PARSE_STRICTPATH | PARSE_QUERY))	/* if strictpath AND query */
	    wanted |= PARSE_PATH;	/* then treat as if PARSE_PATH wanted */
	if (wanted & PARSE_PATH)	/* if PARSE_PATH wanted */
	    wanted &= ~(PARSE_STRICTPATH | PARSE_QUERY);	/* ignore details */
    }
/* *INDENT-OFF* */
    CTRACE((tfp, "   want:%s%s%s%s%s%s%s\n",
	    wanted & PARSE_PUNCTUATION ? " punc"   : "",
	    wanted & PARSE_ANCHOR      ? " anchor" : "",
	    wanted & PARSE_PATH        ? " path"   : "",
	    wanted & PARSE_HOST        ? " host"   : "",
	    wanted & PARSE_ACCESS      ? " access" : "",
	    wanted & PARSE_STRICTPATH  ? " PATH"   : "",
	    wanted & PARSE_QUERY       ? " QUERY"  : ""));
/* *INDENT-ON* */

    /*
     * Allocate the temporary string. Optimized.
     */
    len1 = strlen(aName) + 1;
    len2 = strlen(relatedName) + 1;
    len = len1 + len2 + 8;	/* Lots of space: more than enough */

    result = tail = (char *) LYalloca(len * 2 + len1 + len2);
    if (result == NULL) {
	outofmem(__FILE__, "HTParse");
    }
    *result = '\0';
    name = result + len;
    rel = name + len1;

    /*
     * Make working copy of the input string to cut up.
     */
    memcpy(name, aName, len1);

    /*
     * Cut up the string into URL fields.
     */
    scan(name, &given);
    SHOW_PARTS(given);

    /*
     * Now related string.
     */
    if ((given.access && given.host && given.absolute) || !*relatedName) {
	/*
	 * Inherit nothing!
	 */
	related.access = NULL;
	related.host = NULL;
	related.absolute = NULL;
	related.relative = NULL;
	related.search = NULL;
	related.anchor = NULL;
    } else {
	memcpy(rel, relatedName, len2);
	scan(rel, &related);
    }
    SHOW_PARTS(related);

    /*
     * Handle the scheme (access) field.
     */
    if (given.access && given.host && !given.relative && !given.absolute) {
	if (!strcmp(given.access, "http") ||
	    !strcmp(given.access, "https") ||
	    !strcmp(given.access, "ftp"))
	    /*
	     * Assume root.
	     */
	    given.absolute = "";
    }
    acc_method = given.access ? given.access : related.access;
    if (wanted & PARSE_ACCESS) {
	if (acc_method) {
	    strcpy(tail, acc_method);
	    tail += strlen(tail);
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = ':';
		*tail = '\0';
	    }
	}
    }

    /*
     * If different schemes, inherit nothing.
     *
     * We'll try complying with RFC 1808 and the Fielding draft, and inherit
     * nothing if both schemes are given, rather than only when they differ,
     * except for file URLs - FM
     *
     * After trying it for a while, it's still premature, IHMO, to go along
     * with it, so this is back to inheriting for identical schemes whether or
     * not they are "file".  If you want to try it again yourself, uncomment
     * the strcasecomp() below.  - FM
     */
    if ((given.access && related.access) &&
	(			/* strcasecomp(given.access, "file") || */
	    strcmp(given.access, related.access))) {
	related.host = NULL;
	related.absolute = NULL;
	related.relative = NULL;
	related.search = NULL;
	related.anchor = NULL;
    }

    /*
     * Handle the host field.
     */
    if (wanted & PARSE_HOST) {
	if (given.host || related.host) {
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = '/';
		*tail++ = '/';
	    }
	    strcpy(tail, given.host ? given.host : related.host);
#define CLEAN_URLS
#ifdef CLEAN_URLS
	    /*
	     * Ignore default port numbers, and trailing dots on FQDNs, which
	     * will only cause identical addresses to look different.  (related
	     * is already a clean url).
	     */
	    {
		char *p2, *h;

		if ((p2 = strchr(result, '@@')) != NULL)
		    tail = (p2 + 1);
		p2 = strchr(tail, ':');
		if (p2 != NULL && !isdigit(UCH(p2[1])))
		    /*
		     * Colon not followed by a port number.
		     */
		    *p2 = '\0';
		if (p2 != NULL && *p2 != '\0' && acc_method != NULL) {
		    /*
		     * Port specified.
		     */
#define ACC_METHOD(a,b) (!strcmp(acc_method, a) && !strcmp(p2, b))
		    if (ACC_METHOD("http", ":80") ||
			ACC_METHOD("https", ":443") ||
			ACC_METHOD("gopher", ":70") ||
			ACC_METHOD("ftp", ":21") ||
			ACC_METHOD("wais", ":210") ||
			ACC_METHOD("nntp", ":119") ||
			ACC_METHOD("news", ":119") ||
			ACC_METHOD("newspost", ":119") ||
			ACC_METHOD("newsreply", ":119") ||
			ACC_METHOD("snews", ":563") ||
			ACC_METHOD("snewspost", ":563") ||
			ACC_METHOD("snewsreply", ":563") ||
			ACC_METHOD("finger", ":79") ||
			ACC_METHOD("telnet", ":23") ||
			ACC_METHOD("tn3270", ":23") ||
			ACC_METHOD("rlogin", ":513") ||
			ACC_METHOD("cso", ":105"))
			*p2 = '\0';	/* It is the default: ignore it */
		}
		if (p2 == NULL) {
		    int len3 = strlen(tail);

		    if (len3 > 0) {
			h = tail + len3 - 1;	/* last char of hostname */
			if (*h == '.')
			    *h = '\0';	/* chop final . */
		    }
		} else if (p2 != result) {
		    h = p2;
		    h--;	/* End of hostname */
		    if (*h == '.') {
			/*
			 * Slide p2 over h.
			 */
			while (*p2 != '\0')
			    *h++ = *p2++;
			*h = '\0';	/* terminate */
		    }
		}
	    }
#endif /* CLEAN_URLS */
	}
    }

    /*
     * Trim any blanks from the result so far - there's no excuse for blanks
     * in a hostname.  Also update the tail here.
     */
    tail = LYRemoveBlanks(result);

    /*
     * If host in given or related was ended directly with a '?' (no slash),
     * fake the search part into absolute.  This is the only case search is
     * returned from scan.  A host must have been present.  this restores the
     * '?' at which the host part had been truncated in scan, we have to do
     * this after host part handling is done.  - kw
     */
    if (given.search && *(given.search - 1) == '\0') {
	given.absolute = given.search - 1;
	given.absolute[0] = '?';
    } else if (related.search && !related.absolute &&
	       *(related.search - 1) == '\0') {
	related.absolute = related.search - 1;
	related.absolute[0] = '?';
    }

    /*
     * If different hosts, inherit no path.
     */
    if (given.host && related.host)
	if (strcmp(given.host, related.host) != 0) {
	    related.absolute = NULL;
	    related.relative = NULL;
	    related.anchor = NULL;
	}

    /*
     * Handle the path.
     */
    if (wanted & (PARSE_PATH | PARSE_STRICTPATH | PARSE_QUERY)) {
	int want_detail = (wanted & (PARSE_STRICTPATH | PARSE_QUERY));

	if (acc_method && !given.absolute && given.relative) {
	    /*
	     * Treat all given nntp or snews paths, or given paths for news
	     * URLs with a host, as absolute.
	     */
	    switch (*acc_method) {
	    case 'N':
	    case 'n':
		if (!strcasecomp(acc_method, "nntp") ||
		    (!strcasecomp(acc_method, "news") &&
		     !strncasecomp(result, "news://", 7))) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
	    case 'S':
	    case 's':
		if (!strcasecomp(acc_method, "snews")) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
	    }
	}

	if (given.absolute) {	/* All is given */
	    if (wanted & PARSE_PUNCTUATION)
		*tail++ = '/';
	    strcpy(tail, given.absolute);
	    CTRACE((tfp, "HTParse: (ABS)\n"));
	} else if (related.absolute) {	/* Adopt path not name */
	    char *base = tail;

	    *tail++ = '/';
	    strcpy(tail, related.absolute);
	    if (given.relative) {
		/* RFC 1808 part 4 step 5 (if URL path is empty) */
		/* a) if given has params, add/replace that */
		if (given.relative[0] == ';') {
		    strcpy(strchr_or_end(tail, ';'), given.relative);
		}
		/* b) if given has query, add/replace that */
		else if (given.relative[0] == '?') {
		    strcpy(strchr_or_end(tail, '?'), given.relative);
		}
		/* otherwise fall through to RFC 1808 part 4 step 6 */
		else {
		    p = strchr(tail, '?');	/* Search part? */
		    if (p == NULL)
			p = (tail + strlen(tail) - 1);
		    for (; *p != '/'; p--) ;	/* last / */
		    p[1] = '\0';	/* Remove filename */
		    strcat(p, given.relative);	/* Add given one */
		}
		HTSimplify(base);
		if (*base == '\0')
		    strcpy(base, "/");
	    }
	    CTRACE((tfp, "HTParse: (Related-ABS)\n"));
	} else if (given.relative) {
	    strcpy(tail, given.relative);	/* what we've got */
	    CTRACE((tfp, "HTParse: (REL)\n"));
	} else if (related.relative) {
	    strcpy(tail, related.relative);
	    CTRACE((tfp, "HTParse: (Related-REL)\n"));
	} else {		/* No inheritance */
	    if (!isLYNXCGI(aName) &&
		!isLYNXEXEC(aName) &&
		!isLYNXPROG(aName)) {
		*tail++ = '/';
		*tail = '\0';
	    }
	    if (!strcmp(result, "news:/"))
		result[5] = '*';
	    CTRACE((tfp, "HTParse: (No inheritance)\n"));
	}
	if (want_detail) {
	    p = strchr(tail, '?');	/* Search part? */
	    if (p) {
		if (PARSE_STRICTPATH) {
		    *p = '\0';
		} else {
		    if (!(wanted & PARSE_PUNCTUATION))
			p++;
		    do {
			*tail++ = *p;
		    } while (*p++);
		}
	    } else {
		if (wanted & PARSE_QUERY)
		    *tail = '\0';
	    }
	}
    }

    /*
     * Handle the fragment (anchor).  Never inherit.
     */
    if (wanted & PARSE_ANCHOR) {
	if (given.anchor && *given.anchor) {
	    tail += strlen(tail);
	    if (wanted & PARSE_PUNCTUATION)
		*tail++ = '#';
	    strcpy(tail, given.anchor);
	}
    }

    /*
     * If there are any blanks remaining in the string, escape them as needed.
     * See the discussion in LYLegitimizeHREF() for example.
     */
    if ((p = strchr(result, ' ')) != 0) {
	switch (is_url(result)) {
	case UNKNOWN_URL_TYPE:
	    CTRACE((tfp, "HTParse:      ignore:`%s'\n", result));
	    break;
	case LYNXEXEC_URL_TYPE:
	case LYNXPROG_URL_TYPE:
	case LYNXCGI_URL_TYPE:
	case LYNXPRINT_URL_TYPE:
	case LYNXHIST_URL_TYPE:
	case LYNXDOWNLOAD_URL_TYPE:
	case LYNXKEYMAP_URL_TYPE:
	case LYNXIMGMAP_URL_TYPE:
	case LYNXCOOKIE_URL_TYPE:
	case LYNXDIRED_URL_TYPE:
	case LYNXOPTIONS_URL_TYPE:
	case LYNXCFG_URL_TYPE:
	case LYNXCOMPILE_OPTS_URL_TYPE:
	case LYNXMESSAGES_URL_TYPE:
	    CTRACE((tfp, "HTParse:      spaces:`%s'\n", result));
	    break;
	case NOT_A_URL_TYPE:
	default:
	    CTRACE((tfp, "HTParse:      encode:`%s'\n", result));
	    do {
		q = p + strlen(p) + 2;

		while (q != p + 1) {
		    q[0] = q[-2];
		    --q;
		}
		p[0] = '%';
		p[1] = '2';
		p[2] = '0';
	    } while ((p = strchr(result, ' ')) != 0);
	    break;
	}
    }
    CTRACE((tfp, "HTParse:      result:`%s'\n", result));

    StrAllocCopy(return_value, result);
    LYalloca_free(result);

    /* FIXME: could be optimized using HTParse() internals */
    if (*relatedName &&
	((wanted & PARSE_ALL_WITHOUT_ANCHOR) == PARSE_ALL_WITHOUT_ANCHOR)) {
	/*
	 * Check whether to fill in localhost.  - FM
	 */
	LYFillLocalFileURL(&return_value, relatedName);
	CTRACE((tfp, "pass LYFillLocalFile:`%s'\n", return_value));
    }

    return return_value;	/* exactly the right length */
}

/*	HTParseAnchor(), fast HTParse() specialization
 *	----------------------------------------------
 *
 * On exit,
 *	returns		A pointer within input string (probably to its end '\0')
 */
const char *HTParseAnchor(const char *aName)
{
    const char *p = aName;

    for (; *p && *p != '#'; p++) ;
    if (*p == '#') {
	/* the safe way based on HTParse() -
	 * keeping in mind scan() peculiarities on schemes:
	 */
	struct struct_parts given;

	char *name = (char *) LYalloca((p - aName) + strlen(p) + 1);

	if (name == NULL) {
	    outofmem(__FILE__, "HTParseAnchor");
	}
	strcpy(name, aName);
	scan(name, &given);
	LYalloca_free(name);

	p++;			/*next to '#' */
	if (given.anchor == NULL) {
	    for (; *p; p++)	/*scroll to end '\0' */
		;
	}
    }
    return p;
}

/*	Simplify a filename.				HTSimplify()
 *	--------------------
 *
 *  A unix-style file is allowed to contain the sequence xxx/../ which may
 *  be replaced by "" , and the sequence "/./" which may be replaced by "/".
 *  Simplification helps us recognize duplicate filenames.
 *
 *	Thus,	/etc/junk/../fred	becomes /etc/fred
 *		/etc/junk/./fred	becomes /etc/junk/fred
 *
 *	but we should NOT change
 *		http://fred.xxx.edu/../..
 *
 *	or	../../albert.html
 */
void HTSimplify(char *filename)
{
    char *p;
    char *q, *q1;

    if (filename == NULL)
	return;

    if (!(filename[0] && filename[1]) ||
	filename[0] == '?' || filename[1] == '?' || filename[2] == '?')
	return;

    if (strchr(filename, '/') != NULL) {
	for (p = (filename + 2); *p; p++) {
	    if (*p == '?') {
		/*
		 * We're still treating a ?searchpart as part of the path in
		 * HTParse() and scan(), but if we encounter a '?' here, assume
		 * it's the delimiter and break.  We also could check for a
		 * parameter delimiter (';') here, but the current Fielding
		 * draft (wisely or ill-advisedly :) says that it should be
		 * ignored and collapsing be allowed in it's value).  The only
		 * defined parameter at present is ;type=[A, I, or D] for ftp
		 * URLs, so if there's a "/..", "/../", "/./", or terminal '.'
		 * following the ';', it must be due to the ';' being an
		 * unescaped path character and not actually a parameter
		 * delimiter.  - FM
		 */
		break;
	    }
	    if (*p == '/') {
		if ((p[1] == '.') && (p[2] == '.') &&
		    (p[3] == '/' || p[3] == '?' || p[3] == '\0')) {
		    /*
		     * Handle "../", "..?" or "..".
		     */
		    for (q = (p - 1); (q >= filename) && (*q != '/'); q--)
			/*
			 * Back up to previous slash or beginning of string.
			 */
			;
		    if ((q[0] == '/') &&
			(strncmp(q, "/../", 4) &&
			 strncmp(q, "/..?", 4)) &&
			!((q - 1) > filename && q[-1] == '/')) {
			/*
			 * Not at beginning of string or in a host field, so
			 * remove the "/xxx/..".
			 */
			q1 = (p + 3);
			p = q;
			while (*q1 != '\0')
			    *p++ = *q1++;
			*p = '\0';	/* terminate */
			/*
			 * Start again with previous slash.
			 */
			p = (q - 1);
		    }
		} else if (p[1] == '.' && p[2] == '/') {
		    /*
		     * Handle "./" by removing both characters.
		     */
		    q = p;
		    q1 = (p + 2);
		    while (*q1 != '\0')
			*q++ = *q1++;
		    *q = '\0';	/* terminate */
		    p--;
		} else if (p[1] == '.' && p[2] == '?') {
		    /*
		     * Handle ".?" by removing the dot.
		     */
		    q = (p + 1);
		    q1 = (p + 2);
		    while (*q1 != '\0')
			*q++ = *q1++;
		    *q = '\0';	/* terminate */
		    p--;
		} else if (p[1] == '.' && p[2] == '\0') {
		    /*
		     * Handle terminal "." by removing the character.
		     */
		    p[1] = '\0';
		}
	    }
	}
	if (p >= filename + 2 && *p == '?' && *(p - 1) == '.') {
	    if (*(p - 2) == '/') {
		/*
		 * Handle "/.?" by removing the dot.
		 */
		q = p - 1;
		q1 = p;
		while (*q1 != '\0')
		    *q++ = *q1++;
		*q = '\0';
	    } else if (*(p - 2) == '.' &&
		       p >= filename + 4 && *(p - 3) == '/' &&
		       (*(p - 4) != '/' ||
			(p > filename + 4 && *(p - 5) != ':'))) {
		/*
		 * Handle "xxx/..?"
		 */
		for (q = (p - 4); (q > filename) && (*q != '/'); q--)
		    /*
		     * Back up to previous slash or beginning of string.
		     */
		    ;
		if (*q == '/') {
		    if (q > filename && *(q - 1) == '/' &&
			!(q > filename + 1 && *(q - 1) != ':'))
			return;
		    q++;
		}
		if (strncmp(q, "../", 3) && strncmp(q, "./", 2)) {
		    /*
		     * Not after "//" at beginning of string or after "://",
		     * and xxx is not ".." or ".", so remove the "xxx/..".
		     */
		    q1 = p;
		    p = q;
		    while (*q1 != '\0')
			*p++ = *q1++;
		    *p = '\0';	/* terminate */
		}
	    }
	}
    }
}

/*	Make Relative Name.					HTRelative()
 *	-------------------
 *
 * This function creates and returns a string which gives an expression of
 * one address as related to another.  Where there is no relation, an absolute
 * address is returned.
 *
 *  On entry,
 *	Both names must be absolute, fully qualified names of nodes
 *	(no anchor bits)
 *
 *  On exit,
 *	The return result points to a newly allocated name which, if
 *	parsed by HTParse relative to relatedName, will yield aName.
 *	The caller is responsible for freeing the resulting name later.
 *
 */
char *HTRelative(const char *aName,
		 const char *relatedName)
{
    char *result = NULL;
    const char *p = aName;
    const char *q = relatedName;
    const char *after_access = NULL;
    const char *path = NULL;
    const char *last_slash = NULL;
    int slashes = 0;

    for (; *p; p++, q++) {	/* Find extent of match */
	if (*p != *q)
	    break;
	if (*p == ':')
	    after_access = p + 1;
	if (*p == '/') {
	    last_slash = p;
	    slashes++;
	    if (slashes == 3)
		path = p;
	}
    }

    /* q, p point to the first non-matching character or zero */

    if (!after_access) {	/* Different access */
	StrAllocCopy(result, aName);
    } else if (slashes < 3) {	/* Different nodes */
	StrAllocCopy(result, after_access);
    } else if (slashes == 3) {	/* Same node, different path */
	StrAllocCopy(result, path);
    } else {			/* Some path in common */
	int levels = 0;

	for (; *q && (*q != '#'); q++)
	    if (*q == '/')
		levels++;
	result = typecallocn(char, 3 * levels + strlen(last_slash) + 1);

	if (result == NULL)
	    outofmem(__FILE__, "HTRelative");
	result[0] = '\0';
	for (; levels; levels--)
	    strcat(result, "../");
	strcat(result, last_slash + 1);
    }
    CTRACE((tfp,
	    "HTparse: `%s' expressed relative to\n   `%s' is\n   `%s'.\n",
	    aName, relatedName, result));
    return result;
}

/*	Escape undesirable characters using %			HTEscape()
 *	-------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a calloc'd string.
 */
/* *INDENT-OFF* */
static const unsigned char isAcceptable[96] =

/*	Bit 0		xalpha		-- see HTFile.h
 *	Bit 1		xpalpha		-- as xalpha but with plus.
 *	Bit 2 ...	path		-- as xpalphas but with /
 */
    /*	 0 1 2 3 4 5 6 7 8 9 A B C D E F */
    {	 0,0,0,0,0,0,0,0,0,0,7,6,0,7,7,4,	/* 2x	!"#$%&'()*+,-./  */
	 7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,	/* 3x  0123456789:;<=>?  */
	 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,	/* 4x  @@ABCDEFGHIJKLMNO  */
	 7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,7,	/* 5X  PQRSTUVWXYZ[\]^_  */
	 0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,	/* 6x  `abcdefghijklmno  */
	 7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0 };	/* 7X  pqrstuvwxyz{|}~	DEL */
/* *INDENT-ON* */

static const char *hex = "0123456789ABCDEF";

#define ACCEPTABLE(a)	( a>=32 && a<128 && ((isAcceptable[a-32]) & mask))

char *HTEscape(const char *str,
	       unsigned char mask)
{
    const char *p;
    char *q;
    char *result;
    int unacceptable = 0;

    for (p = str; *p; p++)
	if (!ACCEPTABLE(UCH(TOASCII(*p))))
	    unacceptable++;
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

    if (result == NULL)
	outofmem(__FILE__, "HTEscape");
    for (q = result, p = str; *p; p++) {
	unsigned char a = TOASCII(*p);

	if (!ACCEPTABLE(a)) {
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	} else
	    *q++ = *p;
    }
    *q++ = '\0';		/* Terminate */
    return result;
}

/*	Escape unsafe characters using %			HTEscapeUnsafe()
 *	--------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be that may be unsafe are unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a malloc'd string.
 */
#define UNSAFE(ch) (((ch) <= 32) || ((ch) >= 127))

char *HTEscapeUnsafe(const char *str)
{
    const char *p;
    char *q;
    char *result;
    int unacceptable = 0;

    for (p = str; *p; p++)
	if (UNSAFE(UCH(TOASCII(*p))))
	    unacceptable++;
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

    if (result == NULL)
	outofmem(__FILE__, "HTEscapeUnsafe");
    for (q = result, p = str; *p; p++) {
	unsigned char a = TOASCII(*p);

	if (UNSAFE(a)) {
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	} else
	    *q++ = *p;
    }
    *q++ = '\0';		/* Terminate */
    return result;
}

/*	Escape undesirable characters using % but space to +.	HTEscapeSP()
 *	-----------------------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits,
 *	except that spaces are converted to '+' instead of %2B.
 *
 *	Unlike HTUnEscape(), this routine returns a calloced string.
 */
char *HTEscapeSP(const char *str,
		 unsigned char mask)
{
    const char *p;
    char *q;
    char *result;
    int unacceptable = 0;

    for (p = str; *p; p++)
	if (!(*p == ' ' || ACCEPTABLE(UCH(TOASCII(*p)))))
	    unacceptable++;
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

    if (result == NULL)
	outofmem(__FILE__, "HTEscape");
    for (q = result, p = str; *p; p++) {
	unsigned char a = TOASCII(*p);

	if (a == 32) {
	    *q++ = '+';
	} else if (!ACCEPTABLE(a)) {
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	} else {
	    *q++ = *p;
	}
    }
    *q++ = '\0';		/* Terminate */
    return result;
}

/*	Decode %xx escaped characters.				HTUnEscape()
 *	------------------------------
 *
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y.
 *	The string is converted in place, as it will never grow.
 */
static char from_hex(char c)
{
    return (char) (c >= '0' && c <= '9' ? c - '0'
		   : c >= 'A' && c <= 'F' ? c - 'A' + 10
		   : c - 'a' + 10);	/* accept small letters just in case */
}

char *HTUnEscape(char *str)
{
    char *p = str;
    char *q = str;

    if (!(p && *p))
	return str;

    while (*p != '\0') {
	if (*p == HEX_ESCAPE &&
	/*
	 * Tests shouldn't be needed, but better safe than sorry.
	 */
	    p[1] && p[2] &&
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2]))) {
	    p++;
	    if (*p)
		*q = (char) (from_hex(*p++) * 16);
	    if (*p) {
		/*
		 * Careful! FROMASCII() may evaluate its arg more than once!
		 */
		/* S/390 -- gil -- 0221 */
		*q = (char) (*q + from_hex(*p++));
	    }
	    *q = FROMASCII(*q);
	    q++;
	} else {
	    *q++ = *p++;
	}
    }

    *q++ = '\0';
    return str;

}				/* HTUnEscape */

/*	Decode some %xx escaped characters.		      HTUnEscapeSome()
 *	-----------------------------------			Klaus Weide
 *							    (kweide@@tezcat.com)
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y, and a pointer to
 *	a second string containing one or more characters which
 *	should be unescaped if escaped in the first string.
 *	The first string is converted in place, as it will never grow.
 */
char *HTUnEscapeSome(char *str,
		     const char *do_trans)
{
    char *p = str;
    char *q = str;
    char testcode;

    if (p == NULL || *p == '\0' || do_trans == NULL || *do_trans == '\0')
	return str;

    while (*p != '\0') {
	if (*p == HEX_ESCAPE &&
	    p[1] && p[2] &&	/* tests shouldn't be needed, but.. */
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2])) &&
	    (testcode = (char) FROMASCII(from_hex(p[1]) * 16 +
					 from_hex(p[2]))) &&	/* %00 no good */
	    strchr(do_trans, testcode)) {	/* it's one of the ones we want */
	    *q++ = testcode;
	    p += 3;
	} else {
	    *q++ = *p++;
	}
    }

    *q++ = '\0';
    return str;

}				/* HTUnEscapeSome */
/* *INDENT-OFF* */
static const unsigned char crfc[96] =

/*	Bit 0		xalpha		-- need "quoting"
 *	Bit 1		xpalpha		-- need \escape if quoted
 */
    /*	 0 1 2 3 4 5 6 7 8 9 A B C D E F */
    {	 1,0,3,0,0,0,0,0,1,1,0,0,1,0,1,0,	/* 2x	!"#$%&'()*+,-./  */
	 0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,	/* 3x  0123456789:;<=>?  */
	 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* 4x  @@ABCDEFGHIJKLMNO  */
	 0,0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,	/* 5X  PQRSTUVWXYZ[\]^_  */
	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* 6x  `abcdefghijklmno  */
	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3 };	/* 7X  pqrstuvwxyz{|}~	DEL */
/* *INDENT-ON* */

/*
 *  Turn a string which is not a RFC 822 token into a quoted-string. - KW
 *  The "quoted" parameter tells whether we need the beginning/ending quote
 *  marks.  If not, the caller will provide them -TD
 */
void HTMake822Word(char **str,
		   int quoted)
{
    const char *p;
    char *q;
    char *result;
    unsigned char a;
    int added = 0;

    if (isEmpty(*str)) {
	StrAllocCopy(*str, quoted ? "\"\"" : "");
	return;
    }
    for (p = *str; *p; p++) {
	a = TOASCII(*p);	/* S/390 -- gil -- 0240 */
	if (a < 32 || a >= 128 ||
	    ((crfc[a - 32]) & 1)) {
	    if (!added)
		added = 2;
	    if (a >= 160 || a == '\t')
		continue;
	    if (a == '\r' || a == '\n')
		added += 2;
	    else if ((a & 127) < 32 || ((crfc[a - 32]) & 2))
		added++;
	}
    }
    if (!added)
	return;
    result = typecallocn(char, p - (*str) + added + 1);
    if (result == NULL)
	outofmem(__FILE__, "HTMake822Word");

    q = result;
    if (quoted)
	*q++ = '"';
    /*
     * Having converted the character to ASCII, we can't use symbolic
     * escape codes, since they're in the host character set, which
     * is not necessarily ASCII.  Thus we use octal escape codes instead.
     * -- gil (Paul Gilmartin) <pg@@sweng.stortek.com>
     */
    /* S/390 -- gil -- 0268 */
    for (p = *str; *p; p++) {
	a = TOASCII(*p);
	if ((a != '\011') && ((a & 127) < 32 ||
			      (a < 128 && ((crfc[a - 32]) & 2))))
	    *q++ = '\033';
	*q++ = *p;
	if (a == '\012' || (a == '\015' && (TOASCII(*(p + 1)) != '\012')))
	    *q++ = ' ';
    }
    if (quoted)
	*q++ = '"';
    *q++ = '\0';		/* Terminate */
    FREE(*str);
    *str = result;
}
@


1.5
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d2 2
a3 2
**		================================
*/
d15 4
d24 6
a29 6
	char * access;
	char * host;
	char * absolute;
	char * relative;
	char * search;		/* treated normally as part of path */
	char * anchor;
d32 17
d51 7
a57 8
**	-------------------------------
**
** On exit,
**	Return value points to first non-white character, or to 0 if none.
**	All trailing white space is OVERWRITTEN with zero.
*/
PUBLIC char * HTStrip ARGS1(
	char *,		s)
d60 3
a62 3
    char * p = s;
    for (p = s; *p; p++)
	;			/* Find end of string */
d75 11
a85 12
**	-------------------------------------
**
** On entry,
**	name	points to a document name which may be incomplete.
** On exit,
**	absolute or relative may be nonzero (but not both).
**	host, anchor and access may be nonzero if they were specified.
**	Any which are nonzero point to zero terminated strings.
*/
PRIVATE void scan ARGS2(
	char *,			name,
	struct struct_parts *,	parts)
d87 2
a88 2
    char * after_access;
    char * p;
d98 2
a99 2
    **	Scan left-to-right for a scheme (access).
    */
d102 1
a102 1
	if (*p==':') {
d113 2
a114 2
    **	Scan left-to-right for a fragment (anchor).
    */
d116 1
a116 1
	if (*p =='#') {
d118 1
a118 1
	    *p = '\0';			/* terminate the rest */
d124 2
a125 2
    **	Scan left-to-right for a host or absolute path.
    */
d129 3
a131 3
	    parts->host = (p + 2);	  /* host has been specified	*/
	    *p = '\0';			  /* Terminate access		*/
	    p = strchr(parts->host, '/'); /* look for end of host name if any */
d133 1
a133 1
		*p = '\0';			/* Terminate host */
d138 1
a138 1
		    *p = '\0';			/* Terminate host */
d143 1
a143 1
	    parts->absolute = (p + 1);		/* Root found but no host */
d147 1
a147 1
			     after_access : NULL; /* NULL for "" */
d151 2
a152 2
    **	Check schemes that commonly have unescaped hashes.
    */
d154 1
a154 1
		/* optimize */ strchr("lnsdLNSD", *parts->access) != NULL) {
d161 4
a164 4
	     *	Access specified but no host and not a lynxcgi URL, so the
	     *	anchor may not really be one, e.g., news:j462#36487@@foo.bar,
	     *	or it's an nntp or snews URL, or news URL with a host.
	     *	Restore the '#' in the address.
d174 1
a174 1
} /*scan */
d184 10
d195 16
a210 17
**	--------------------------------------
**
**	This returns those parts of a name which are given (and requested)
**	substituting bits from the related name where necessary.
**
** On entry,
**	aName		A filename given
**	relatedName	A name relative to which aName is to be parsed
**	wanted		A mask for the bits which are wanted.
**
** On exit,
**     returns         A pointer to a malloc'd string which MUST BE FREED
*/
PUBLIC char * HTParse ARGS3(
	CONST char *,	aName,
	CONST char *,	relatedName,
	int,		wanted)
d212 3
a214 3
    char * result = NULL;
    char * tail = NULL;  /* a pointer to the end of the 'result' string */
    char * return_value = NULL;
d216 4
a219 4
    char * name = NULL;
    char * rel = NULL;
    char * p;
    char * acc_method;
d225 1
a225 1
    if (wanted & (PARSE_STRICTPATH | PARSE_QUERY)) { /* if detail wanted... */
d227 4
a230 4
	    == (PARSE_STRICTPATH | PARSE_QUERY)) /* if strictpath AND query */
	    wanted |= PARSE_PATH; /* then treat as if PARSE_PATH wanted */
	if (wanted & PARSE_PATH) /* if PARSE_PATH wanted */
	    wanted &= ~(PARSE_STRICTPATH | PARSE_QUERY); /* ignore details */
d232 1
d241 1
d244 2
a245 2
    ** Allocate the temporary string. Optimized.
    */
d248 1
a248 1
    len = len1 + len2 + 8;     /* Lots of space: more than enough */
d250 1
a250 1
    result = tail = (char*)LYalloca(len * 2 + len1 + len2);
d259 2
a260 2
    **	Make working copy of the input string to cut up.
    */
d264 2
a265 2
    **	Cut up the string into URL fields.
    */
d267 1
d270 2
a271 2
    **	Now related string.
    */
d274 2
a275 2
	**  Inherit nothing!
	*/
d284 1
a284 1
	scan(rel,  &related);
d286 1
a286 1

d289 2
a290 2
    **	Handle the scheme (access) field.
    */
d296 2
a297 2
	    **	Assume root.
	    */
d313 11
a323 15
    **	If different schemes, inherit nothing.
    **
    **	We'll try complying with RFC 1808 and
    **	the Fielding draft, and inherit nothing
    **	if both schemes are given, rather than
    **	only when they differ, except for
    **	file URLs - FM
    **
    **	After trying it for a while, it's still
    **	premature, IHMO, to go along with it, so
    **	this is back to inheriting for identical
    **	schemes whether or not they are "file".
    **	If you want to try it again yourself,
    **	uncomment the strcasecomp() below. - FM
    */
d325 2
a326 2
	(/* strcasecomp(given.access, "file") || */
	 strcmp(given.access, related.access))) {
d335 2
a336 2
    **	Handle the host field.
    */
d347 4
a350 4
	    **	Ignore default port numbers, and trailing dots on FQDNs,
	    **	which will only cause identical addresses to look different.
	    **  (related is already a clean url).
	    */
d353 1
d355 1
a355 1
		   tail = (p2 + 1);
d359 2
a360 2
		    **	Colon not followed by a port number.
		    */
d364 21
a384 20
		    **	Port specified.
		    */
		    if ((!strcmp(acc_method, "http"	 ) && !strcmp(p2, ":80" )) ||
			(!strcmp(acc_method, "https"	 ) && !strcmp(p2, ":443")) ||
			(!strcmp(acc_method, "gopher"	 ) && !strcmp(p2, ":70" )) ||
			(!strcmp(acc_method, "ftp"	 ) && !strcmp(p2, ":21" )) ||
			(!strcmp(acc_method, "wais"	 ) && !strcmp(p2, ":210")) ||
			(!strcmp(acc_method, "nntp"	 ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "news"	 ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "newspost"  ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "newsreply" ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "snews"	 ) && !strcmp(p2, ":563")) ||
			(!strcmp(acc_method, "snewspost" ) && !strcmp(p2, ":563")) ||
			(!strcmp(acc_method, "snewsreply") && !strcmp(p2, ":563")) ||
			(!strcmp(acc_method, "finger"	 ) && !strcmp(p2, ":79" )) ||
			(!strcmp(acc_method, "telnet"	 ) && !strcmp(p2, ":23" )) ||
			(!strcmp(acc_method, "tn3270"	 ) && !strcmp(p2, ":23" )) ||
			(!strcmp(acc_method, "rlogin"	 ) && !strcmp(p2, ":513")) ||
			(!strcmp(acc_method, "cso"	 ) && !strcmp(p2, ":105")))
		    *p2 = '\0'; /* It is the default: ignore it */
d392 1
a392 1
			    *h = '\0';		/* chop final . */
d396 1
a396 1
		    h--;		/* End of hostname */
d399 2
a400 2
			**  Slide p2 over h.
			*/
d418 6
a423 6
    **	If host in given or related was ended directly with a '?' (no
    **  slash), fake the search part into absolute.  This is the only
    **  case search is returned from scan.  A host must have been present.
    **  this restores the '?' at which the host part had been truncated in
    **  scan, we have to do this after host part handling is done. - kw
    */
d434 2
a435 2
    **	If different hosts, inherit no path.
    */
d444 2
a445 2
    **	Handle the path.
    */
d474 1
a474 1
	if (given.absolute) {			/* All is given */
d479 3
a481 1
	} else if (related.absolute) {		/* Adopt path not name */
d485 21
a505 8
		p = strchr(tail, '?');	/* Search part? */
		if (p == NULL)
		    p = (tail + strlen(tail) - 1);
		for (; *p != '/'; p--)
		    ;				/* last / */
		p[1] = '\0';			/* Remove filename */
		strcat(p, given.relative); /* Add given one */
		HTSimplify (result);
d509 1
a509 1
	    strcpy(tail, given.relative);		/* what we've got */
d514 1
a514 1
	} else {  /* No inheritance */
d545 2
a546 2
    **	Handle the fragment (anchor). Never inherit.
    */
d585 2
a586 1
		char *q = p + strlen(p) + 2;
d607 1
a607 1
	 *  Check whether to fill in localhost. - FM
d613 1
a613 1
    return return_value;		/* exactly the right length */
d617 6
a622 7
**	----------------------------------------------
**
** On exit,
**	returns		A pointer within input string (probably to its end '\0')
*/
PUBLIC CONST char * HTParseAnchor ARGS1(
	CONST char *,	aName)
d624 3
a626 3
    CONST char* p = aName;
    for ( ; *p && *p != '#'; p++)
	;
d633 2
a634 1
	char* name = (char*)LYalloca((p - aName) + strlen(p) + 1);
d642 1
a642 1
	p++; /*next to '#'*/
d644 1
a644 1
	    for ( ; *p; p++)  /*scroll to end '\0'*/
d652 15
a666 16
**	--------------------
**
**  A unix-style file is allowed to contain the sequence xxx/../ which may
**  be replaced by "" , and the sequence "/./" which may be replaced by "/".
**  Simplification helps us recognize duplicate filenames.
**
**	Thus,	/etc/junk/../fred	becomes /etc/fred
**		/etc/junk/./fred	becomes /etc/junk/fred
**
**	but we should NOT change
**		http://fred.xxx.edu/../..
**
**	or	../../albert.html
*/
PUBLIC void HTSimplify ARGS1(
	char *,		filename)
d682 12
a693 14
		**  We're still treating a ?searchpart as part of
		**  the path in HTParse() and scan(), but if we
		**  encounter a '?' here, assume it's the delimiter
		**  and break.	We also could check for a parameter
		**  delimiter (';') here, but the current Fielding
		**  draft (wisely or ill-advisedly :) says that it
		**  should be ignored and collapsing be allowed in
		**  it's value).  The only defined parameter at
		**  present is ;type=[A, I, or D] for ftp URLs, so
		**  if there's a "/..", "/../", "/./", or terminal
		**  '.' following the ';', it must be due to the
		**  ';' being an unescaped path character and not
		**  actually a parameter delimiter. - FM
		*/
d700 2
a701 2
		    **	Handle "../", "..?" or "..".
		    */
d704 2
a705 2
			**  Back up to previous slash or beginning of string.
			*/
d712 3
a714 3
			**  Not at beginning of string or in a
			**  host field, so remove the "/xxx/..".
			*/
d719 1
a719 1
			*p = '\0';		/* terminate */
d721 2
a722 2
			**  Start again with previous slash.
			*/
d727 2
a728 2
		    **	Handle "./" by removing both characters.
		    */
d733 1
a733 1
		    *q = '\0';		/* terminate */
d737 2
a738 2
		    **	Handle ".?" by removing the dot.
		    */
d743 1
a743 1
		    *q = '\0';		/* terminate */
d747 2
a748 2
		    **	Handle terminal "." by removing the character.
		    */
d753 2
a754 2
	if (p >= filename + 2 && *p == '?' && *(p-1)  == '.') {
	    if (*(p-2) == '/') {
d756 2
a757 2
		**  Handle "/.?" by removing the dot.
		*/
d763 8
a770 4
	    } else if (*(p-2) == '.' &&
		       p >= filename + 4 && *(p-3) == '/' &&
		       (*(p-4) != '/' ||
			(p > filename + 4 && *(p-5) != ':'))) {
d772 2
a773 6
		    **	Handle "xxx/..?"
		    */
		for (q = (p - 4); (q > filename) && (*q != '/'); q--)
			/*
			**  Back up to previous slash or beginning of string.
			*/
d776 2
a777 2
		    if (q > filename && *(q-1) == '/' &&
			!(q > filename + 1 && *(q-1) != ':'))
d782 4
a785 5
			/*
			**  Not after "//" at beginning of string or
			**  after "://", and xxx is not ".." or ".",
			**  so remove the "xxx/..".
			*/
d790 1
a790 1
		    *p = '\0';		/* terminate */
d798 18
a815 19
**	-------------------
**
** This function creates and returns a string which gives an expression of
** one address as related to another.  Where there is no relation, an absolute
** address is returned.
**
**  On entry,
**	Both names must be absolute, fully qualified names of nodes
**	(no anchor bits)
**
**  On exit,
**	The return result points to a newly allocated name which, if
**	parsed by HTParse relative to relatedName, will yield aName.
**	The caller is responsible for freeing the resulting name later.
**
*/
PUBLIC char * HTRelative ARGS2(
	CONST char *,	aName,
	CONST char *,	relatedName)
d817 6
a822 6
    char * result = NULL;
    CONST char *p = aName;
    CONST char *q = relatedName;
    CONST char * after_access = NULL;
    CONST char * path = NULL;
    CONST char * last_slash = NULL;
d829 1
a829 1
	    after_access = p+1;
d834 1
a834 1
		path=p;
d840 1
a840 1
    if (!after_access) {			/* Different access */
d842 1
a842 1
    } else if (slashes < 3){			/* Different nodes */
d844 1
a844 1
    } else if (slashes == 3){			/* Same node, different path */
d846 1
a846 1
    } else {					/* Some path in common */
d848 1
d852 2
a853 1
	result = typecallocn(char, 3*levels + strlen(last_slash) + 1);
d859 1
a859 1
	strcat(result, last_slash+1);
d868 11
a878 10
**	-------------------------------------
**
**	This function takes a pointer to a string in which
**	some characters may be unacceptable unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two hex digits.
**
**	Unlike HTUnEscape(), this routine returns a calloc'd string.
*/
PRIVATE CONST unsigned char isAcceptable[96] =
d881 3
a883 3
**	Bit 1		xpalpha		-- as xalpha but with plus.
**	Bit 2 ...	path		-- as xpalphas but with /
*/
d891 3
a894 1
PRIVATE char *hex = "0123456789ABCDEF";
d897 2
a898 3
PUBLIC char * HTEscape ARGS2(
	CONST char *,	str,
	unsigned char,	mask)
d900 3
a902 3
    CONST char * p;
    char * q;
    char * result;
d904 1
d908 2
a909 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d914 1
d919 2
a920 2
	}
	else *q++ = *p;
d927 9
a935 9
**	--------------------------------
**
**	This function takes a pointer to a string in which
**	some characters may be that may be unsafe are unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two hex digits.
**
**	Unlike HTUnEscape(), this routine returns a malloc'd string.
*/
d938 1
a938 2
PUBLIC char *HTEscapeUnsafe ARGS1(
	CONST char *,	str)
d940 3
a942 3
    CONST char * p;
    char * q;
    char * result;
d944 1
d948 2
a949 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d954 1
d959 2
a960 2
	}
	else *q++ = *p;
d967 12
a978 13
**	-----------------------------------------------------
**
**	This function takes a pointer to a string in which
**	some characters may be unacceptable unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two hex digits,
**	except that spaces are converted to '+' instead of %2B.
**
**	Unlike HTUnEscape(), this routine returns a calloced string.
*/
PUBLIC char * HTEscapeSP ARGS2(
	CONST char *,	str,
	unsigned char,	mask)
d980 3
a982 3
    CONST char * p;
    char * q;
    char * result;
d984 1
d988 2
a989 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d994 1
d1005 1
a1005 1
    *q++ = '\0';			/* Terminate */
d1010 8
a1017 9
**	------------------------------
**
**	This function takes a pointer to a string in which some
**	characters may have been encoded in %xy form, where xy is
**	the ASCII hex code for character 16x+y.
**	The string is converted in place, as it will never grow.
*/
PRIVATE char from_hex ARGS1(
	char,		c)
d1019 3
a1021 3
    return (char) ( c >= '0' && c <= '9' ?  c - '0'
	    : c >= 'A' && c <= 'F'? c - 'A' + 10
	    : c - 'a' + 10);     /* accept small letters just in case */
d1024 1
a1024 2
PUBLIC char * HTUnEscape ARGS1(
	char *,		str)
d1026 2
a1027 2
    char * p = str;
    char * q = str;
d1034 3
a1036 3
	    /*
	     *	Tests shouldn't be needed, but better safe than sorry.
	     */
d1045 3
a1047 2
		** Careful! FROMASCII() may evaluate its arg more than once!
		*/  /* S/390 -- gil -- 0221 */
d1060 1
a1060 1
} /* HTUnEscape */
d1063 11
a1073 12
**	-----------------------------------			Klaus Weide
**							    (kweide@@tezcat.com)
**	This function takes a pointer to a string in which some
**	characters may have been encoded in %xy form, where xy is
**	the ASCII hex code for character 16x+y, and a pointer to
**	a second string containing one or more characters which
**	should be unescaped if escaped in the first string.
**	The first string is converted in place, as it will never grow.
*/
PUBLIC char * HTUnEscapeSome ARGS2(
	char *,		str,
	CONST char *,	do_trans)
d1075 2
a1076 2
    char * p = str;
    char * q = str;
d1087 3
a1089 3
	    (testcode = (char) FROMASCII(from_hex(p[1])*16 +
		from_hex(p[2]))) && /* %00 no good*/
	    strchr(do_trans, testcode)) { /* it's one of the ones we want */
d1100 3
a1102 3
} /* HTUnEscapeSome */

PRIVATE CONST unsigned char crfc[96] =
d1105 2
a1106 2
**	Bit 1		xpalpha		-- need \escape if quoted
*/
d1114 1
d1117 6
a1122 7
**  Turn a string which is not a RFC 822 token into a quoted-string. - KW
**  The "quoted" parameter tells whether we need the beginning/ending quote
**  marks.  If not, the caller will provide them -TD
*/
PUBLIC void HTMake822Word ARGS2(
	char **,	str,
	int,		quoted)
d1124 3
a1126 3
    CONST char * p;
    char * q;
    char * result;
d1135 1
a1135 1
	a = TOASCII(*p);  /* S/390 -- gil -- 0240 */
d1137 1
a1137 1
	    ((crfc[a-32]) & 1)) {
d1144 1
a1144 1
	    else if ((a & 127) < 32 || ((crfc[a-32]) & 2))
d1150 1
a1150 1
    result = typecallocn(char, p-(*str) + added + 1);
d1158 6
a1163 5
    ** Having converted the character to ASCII, we can't use symbolic
    ** escape codes, since they're in the host character set, which
    ** is not necessarily ASCII.  Thus we use octal escape codes instead.
    ** -- gil (Paul Gilmartin) <pg@@sweng.stortek.com>
    */  /* S/390 -- gil -- 0268 */
d1167 1
a1167 1
			    ( a < 128 && ((crfc[a-32]) & 2))))
d1170 1
a1170 1
	if (a == '\012' || (a == '\015' && (TOASCII(*(p+1)) != '\012')))
d1175 1
a1175 1
    *q++ = '\0';			/* Terminate */
@


1.4
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d820 2
a821 2
	"HTparse: `%s' expressed relative to\n	 `%s' is\n   `%s'.\n",
		aName, relatedName, result));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d327 1
a327 1
 		   tail = (p2 + 1);
a517 1
	case NOT_A_URL_TYPE:
d537 1
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d8 1
d10 6
d24 1
a24 1
/*	char * search;		no - treated as part of path */
d29 1
a29 1
/*	Strip white space off a string. 			HTStrip()
d37 1
a37 1
	char *, 	s)
d54 2
a55 2
/*	Scan a filename for its consituents.			scan()
**	------------------------------------
d65 1
a65 1
	char *, 		name,
a69 3
#ifdef NOTDEFINED
    int length = strlen(name);
#endif /* NOTDEFINED */
d75 1
a92 3
#ifdef NOTDEFINED
    for (p = (name + length-1); p >= name; p--) {}
#endif /* NOTDEFINED */
d116 6
d134 2
a135 1
    if (parts->access && parts->anchor) {
a154 13

#ifdef NOT_DEFINED	/* search is just treated as part of path */
    {
	char *p = (relative ? relative : absolute);
	if (p != NULL) {
	    char *q = strchr(p, '?');	/* Any search string? */
	    if (q != NULL) {
		*q = '\0';		/* If so, chop that off. */
		parts->search = (q + 1);
	    }
	}
    }
#endif /* NOT_DEFINED */
d157 7
d177 1
a177 1
**	returns 	A pointer to a calloc'd string which MUST BE FREED
d185 1
d187 1
a187 1
    int len;
d194 2
a195 1
    CTRACE(tfp, "HTParse: aName:%s   relatedName:%s\n", aName, relatedName);
d204 9
d214 1
a214 1
    **	Allocate the output string.
d216 5
a220 2
    len = strlen(aName) + strlen(relatedName) + 10;
    result = (char *)calloc(1, len);	/* Lots of space: more than enough */
d224 3
d229 1
a229 1
    **	Make working copies of the input strings to cut up.
d231 1
a231 2
    StrAllocCopy(name, aName);
    StrAllocCopy(rel, relatedName);
d234 1
a234 1
    **	Cut up the strings into URL fields.
d237 19
a255 1
    scan(rel,  &related);
d272 6
a277 3
	    strcat(result, acc_method);
	    if (wanted & PARSE_PUNCTUATION)
		strcat(result, ":");
d303 1
d310 1
a310 1
    if (wanted & PARSE_HOST)
d312 5
a316 4
	    char *tail = result + strlen(result);
	    if (wanted & PARSE_PUNCTUATION)
		strcat(result, "//");
	    strcat(result, given.host ? given.host : related.host);
d322 1
d327 1
a327 1
		   tail = (p2 + 1);
d329 1
a329 1
		if (p2 != NULL && !isdigit((unsigned char)p2[1]))
d358 1
a358 1
		    int len2 = strlen(tail);
d360 2
a361 2
		    if (len2 > 0) {
			h = tail + len2 - 1;	/* last char of hostname */
d365 1
a365 1
		} else {
d380 23
a417 1
	char *tail = NULL;
d419 1
a419 2
	if (want_detail)
	    tail = result + strlen(result);
d421 21
a441 11
	    if (!strcasecomp(acc_method, "nntp") ||
		!strcasecomp(acc_method, "snews") ||
		(!strcasecomp(acc_method, "news") &&
		 !strncasecomp(result, "news://", 7))) {
		/*
		 *  Treat all given nntp or snews paths,
		 *  or given paths for news URLs with a host,
		 *  as absolute.
		 */
		given.absolute = given.relative;
		given.relative = NULL;
d444 1
d447 3
a449 3
		strcat(result, "/");
	    strcat(result, given.absolute);
	    CTRACE(tfp, "1\n");
d451 2
a452 2
	    strcat(result, "/");
	    strcat(result, related.absolute);
d454 1
a454 1
		p = strchr(result, '?');	/* Search part? */
d456 1
a456 1
		    p = (result + strlen(result) - 1);
d460 1
a460 1
		strcat(result, given.relative); /* Add given one */
d463 1
a463 1
	    CTRACE(tfp, "2\n");
d465 2
a466 2
	    strcat(result, given.relative);		/* what we've got */
	    CTRACE(tfp, "3\n");
d468 2
a469 2
	    strcat(result, related.relative);
	    CTRACE(tfp, "4\n");
d471 5
a475 4
	    if (strncasecomp(aName, "lynxcgi:", 8) &&
		strncasecomp(aName, "lynxexec:", 9) &&
		strncasecomp(aName, "lynxprog:", 9)) {
		strcat(result, "/");
d479 1
a479 1
	    CTRACE(tfp, "5\n");
d501 1
a501 1
    **	Handle the fragment (anchor).
d503 3
a505 3
    if (wanted & PARSE_ANCHOR)
	if ((given.anchor && *given.anchor) ||
	    (!given.anchor && related.anchor)) {
d507 47
a553 7
		strcat(result, "#");
	    strcat(result, (given.anchor) ?
			     given.anchor : related.anchor);
	}
    CTRACE(tfp, "HTParse:      result:%s\n", result);
    FREE(rel);
    FREE(name);
d556 11
a566 1
    FREE(result);
d571 35
d609 2
a610 2
**  A unix-style file is allowed to contain the seqeunce xxx/../ which may
**  be replaced by "" , and the seqeunce "/./" which may be replaced by "/".
d622 1
a622 1
	char *, 	filename)
a677 9
#ifdef NOTDEFINED
			/*
			**  Make sure filename has at least one slash.
			*/
			if (*filename == '\0') {
			    *filename = '/';
			    *(filename + 1) = '\0';
			}
#endif /* NOTDEFINED */
d690 1
a690 1
		       *q++ = *q1++;
d700 1
a700 1
		       *q++ = *q1++;
d761 1
a761 1
** address is retured.
d811 1
a811 1
	result = (char *)calloc(1, (3*levels + strlen(last_slash) + 1));
d819 3
a821 2
    CTRACE(tfp, "HT: `%s' expressed relative to\n    `%s' is\n   `%s'.",
		aName, relatedName, result);
d825 1
a825 1
/*	Escape undesirable characters using %		HTEscape()
d833 1
a833 1
**	Unlike HTUnEscape(), this routine returns a calloced string.
d838 1
a838 1
**	Bit 1		xpalpha 	-- as xalpha but with plus.
d861 1
a861 1
	if (!ACCEPTABLE((unsigned char)TOASCII(*p)))
d863 1
a863 1
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
d883 1
a883 1
**	some characters that may be unsafe are unescaped.
d885 1
a885 1
**	represented by a '%' character followed by two new hex digits.
d889 1
a889 1
#define UNSAFE(ch) (((ch) <= 32 ) || ((ch) >= 127))
d899 1
a899 1
        if (UNSAFE((unsigned char)TOASCII(*p)))
d901 1
a901 1
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
d903 1
a903 1
       outofmem(__FILE__, "HTEscapeUnsafe");
d905 1
a905 1
       unsigned char a = TOASCII(*p);
d907 5
a911 5
	  *q++ = HEX_ESCAPE;	/* Means hex coming */
	  *q++ = hex[a >> 4];
	  *q++ = hex[a & 15];
       }
       else *q++ = *p;
d937 1
a937 1
	if (!(*p == ' ' || ACCEPTABLE((unsigned char)TOASCII(*p))))
d939 1
a939 1
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
d947 1
a947 1
	    *q++ = HEX_ESCAPE;	/* Means hex commming */
d954 1
a954 1
    *q++ = '\0';		/* Terminate */
d963 1
a963 1
**	the acsii hex code for character 16x+y.
d969 1
a969 1
    return  c >= '0' && c <= '9' ?  c - '0'
d971 1
a971 1
	    : c - 'a' + 10;	/* accept small letters just in case */
d975 1
a975 1
	char *, 	str)
d989 2
a990 2
	    isxdigit((unsigned char)p[1]) &&
	    isxdigit((unsigned char)p[2])) {
d993 2
a994 2
	        *q = from_hex(*p++) * 16;
	    if (*p)
d996 1
a996 1
		** Careful!  FROMASCII() may evaluate its arg more than once!
d998 3
a1000 2
		*q =           *q + from_hex(*p++) ;
		*q = FROMASCII(*q                 );
d1017 1
a1017 1
**	the acsii hex code for character 16x+y, and a pointer to
d1023 1
a1023 1
	char *, 	str,
d1036 4
a1039 3
	    isxdigit((unsigned char)p[1]) &&
	    isxdigit((unsigned char)p[2]) &&
	    (testcode = FROMASCII(from_hex(p[1])*16 + from_hex(p[2]))) && /* %00 no good*/
d1056 1
a1056 1
**	Bit 1		xpalpha 	-- need \escape if quoted
d1068 2
d1071 3
a1073 2
PUBLIC void HTMake822Word ARGS1(
	char **,	str)
d1080 3
a1082 2
    if (!(*str) || !(**str)) {
	StrAllocCopy(*str, "\"\"");
d1101 1
a1101 1
    result = (char *)calloc(1, (p-(*str) + added + 1));
d1104 4
a1107 1
    result[0] = '"';
d1114 1
a1114 1
    for (q = result + 1, p = *str; *p; p++) {
d1123 2
a1124 1
    *q++ = '"';
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 2
a3 2
 *		================================
 */
a7 1
#include <LYUtils.h>
a8 10
#include <LYStrings.h>
#include <LYCharUtils.h>

#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef __MINGW32__
#include <malloc.h>
#endif /* __MINGW32__ */
#endif
d13 6
a18 6
    char *access;
    char *host;
    char *absolute;
    char *relative;
    char *search;		/* treated normally as part of path */
    char *anchor;
d21 10
a30 26
#if 0				/* for debugging */
static void show_parts(const char *name, struct struct_parts *parts, int line)
{
    if (TRACE) {
	CTRACE((tfp, "struct_parts(%s) %s@@%d\n", name, __FILE__, line));
	CTRACE((tfp, "   access   '%s'\n", NONNULL(parts->access)));
	CTRACE((tfp, "   host     '%s'\n", NONNULL(parts->host)));
	CTRACE((tfp, "   absolute '%s'\n", NONNULL(parts->absolute)));
	CTRACE((tfp, "   relative '%s'\n", NONNULL(parts->relative)));
	CTRACE((tfp, "   search   '%s'\n", NONNULL(parts->search)));
	CTRACE((tfp, "   anchor   '%s'\n", NONNULL(parts->anchor)));
    }
}
#define SHOW_PARTS(name) show_parts(#name, &name, __LINE__)
#else
#define SHOW_PARTS(name)	/* nothing */
#endif

/*	Strip white space off a string.				HTStrip()
 *	-------------------------------
 *
 * On exit,
 *	Return value points to first non-white character, or to 0 if none.
 *	All trailing white space is OVERWRITTEN with zero.
 */
char *HTStrip(char *s)
d33 3
a35 3
    char *p = s;

    for (p = s; *p; p++) ;	/* Find end of string */
d47 19
a65 15
/*	Scan a filename for its constituents.			scan()
 *	-------------------------------------
 *
 * On entry,
 *	name	points to a document name which may be incomplete.
 * On exit,
 *	absolute or relative may be nonzero (but not both).
 *	host, anchor and access may be nonzero if they were specified.
 *	Any which are nonzero point to zero terminated strings.
 */
static void scan(char *name,
		 struct struct_parts *parts)
{
    char *after_access;
    char *p;
a70 1
    parts->search = NULL;	/* normally not used - kw */
d74 2
a75 2
     * Scan left-to-right for a scheme (access).
     */
d78 1
a78 1
	if (*p == ':') {
d88 3
d92 2
a93 2
     * Scan left-to-right for a fragment (anchor).
     */
d95 1
a95 1
	if (*p == '#') {
d97 1
a97 1
	    *p = '\0';		/* terminate the rest */
d103 2
a104 2
     * Scan left-to-right for a host or absolute path.
     */
d108 3
a110 3
	    parts->host = (p + 2);	/* host has been specified    */
	    *p = '\0';		/* Terminate access           */
	    p = strchr(parts->host, '/');	/* look for end of host name if any */
d112 1
a112 1
		*p = '\0';	/* Terminate host */
a113 6
	    } else {
		p = strchr(parts->host, '?');
		if (p != NULL) {
		    *p = '\0';	/* Terminate host */
		    parts->search = (p + 1);
		}
d116 1
a116 1
	    parts->absolute = (p + 1);	/* Root found but no host */
d120 1
a120 1
	    after_access : NULL;	/* NULL for "" */
d124 3
a126 4
     * Check schemes that commonly have unescaped hashes.
     */
    if (parts->access && parts->anchor &&
    /* optimize */ strchr("lnsdLNSD", *parts->access) != NULL) {
d133 4
a136 4
	     * Access specified but no host and not a lynxcgi URL, so the
	     * anchor may not really be one, e.g., news:j462#36487@@foo.bar, or
	     * it's an nntp or snews URL, or news URL with a host.  Restore the
	     * '#' in the address.
a145 1
}				/*scan */
d147 13
a159 11
#if defined(HAVE_ALLOCA) && !defined(LY_FIND_LEAKS)
#define LYalloca(x)        alloca(x)
#define LYalloca_free(x)   {}
#else
#define LYalloca(x)        malloc(x)
#define LYalloca_free(x)   free(x)
#endif

static char *strchr_or_end(char *string, int ch)
{
    char *result = strchr(string, ch);
a160 5
    if (result == 0) {
	result = string + strlen(string);
    }
    return result;
}
d163 25
a187 25
 *	--------------------------------------
 *
 *	This returns those parts of a name which are given (and requested)
 *	substituting bits from the related name where necessary.
 *
 * On entry,
 *	aName		A filename given
 *	relatedName	A name relative to which aName is to be parsed
 *	wanted		A mask for the bits which are wanted.
 *
 * On exit,
 *     returns         A pointer to a malloc'd string which MUST BE FREED
 */
char *HTParse(const char *aName,
	      const char *relatedName,
	      int wanted)
{
    char *result = NULL;
    char *tail = NULL;		/* a pointer to the end of the 'result' string */
    char *return_value = NULL;
    int len, len1, len2;
    char *name = NULL;
    char *rel = NULL;
    char *p, *q;
    char *acc_method;
d190 1
a190 2
    CTRACE((tfp, "HTParse: aName:`%s'\n", aName));
    CTRACE((tfp, "   relatedName:`%s'\n", relatedName));
d192 1
a192 1
    if (wanted & (PARSE_STRICTPATH | PARSE_QUERY)) {	/* if detail wanted... */
d194 5
a198 16
	    == (PARSE_STRICTPATH | PARSE_QUERY))	/* if strictpath AND query */
	    wanted |= PARSE_PATH;	/* then treat as if PARSE_PATH wanted */
	if (wanted & PARSE_PATH)	/* if PARSE_PATH wanted */
	    wanted &= ~(PARSE_STRICTPATH | PARSE_QUERY);	/* ignore details */
    }
/* *INDENT-OFF* */
    CTRACE((tfp, "   want:%s%s%s%s%s%s%s\n",
	    wanted & PARSE_PUNCTUATION ? " punc"   : "",
	    wanted & PARSE_ANCHOR      ? " anchor" : "",
	    wanted & PARSE_PATH        ? " path"   : "",
	    wanted & PARSE_HOST        ? " host"   : "",
	    wanted & PARSE_ACCESS      ? " access" : "",
	    wanted & PARSE_STRICTPATH  ? " PATH"   : "",
	    wanted & PARSE_QUERY       ? " QUERY"  : ""));
/* *INDENT-ON* */

d200 4
a203 7
     * Allocate the temporary string. Optimized.
     */
    len1 = strlen(aName) + 1;
    len2 = strlen(relatedName) + 1;
    len = len1 + len2 + 8;	/* Lots of space: more than enough */

    result = tail = (char *) LYalloca(len * 2 + len1 + len2);
a206 3
    *result = '\0';
    name = result + len;
    rel = name + len1;
d209 4
a212 3
     * Make working copy of the input string to cut up.
     */
    memcpy(name, aName, len1);
d215 2
a216 2
     * Cut up the string into URL fields.
     */
d218 1
a218 20
    SHOW_PARTS(given);

    /*
     * Now related string.
     */
    if ((given.access && given.host && given.absolute) || !*relatedName) {
	/*
	 * Inherit nothing!
	 */
	related.access = NULL;
	related.host = NULL;
	related.absolute = NULL;
	related.relative = NULL;
	related.search = NULL;
	related.anchor = NULL;
    } else {
	memcpy(rel, relatedName, len2);
	scan(rel, &related);
    }
    SHOW_PARTS(related);
d221 2
a222 2
     * Handle the scheme (access) field.
     */
d228 2
a229 2
	     * Assume root.
	     */
d235 3
a237 6
	    strcpy(tail, acc_method);
	    tail += strlen(tail);
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = ':';
		*tail = '\0';
	    }
d242 15
a256 11
     * If different schemes, inherit nothing.
     *
     * We'll try complying with RFC 1808 and the Fielding draft, and inherit
     * nothing if both schemes are given, rather than only when they differ,
     * except for file URLs - FM
     *
     * After trying it for a while, it's still premature, IHMO, to go along
     * with it, so this is back to inheriting for identical schemes whether or
     * not they are "file".  If you want to try it again yourself, uncomment
     * the strcasecomp() below.  - FM
     */
d258 2
a259 2
	(			/* strcasecomp(given.access, "file") || */
	    strcmp(given.access, related.access))) {
a262 1
	related.search = NULL;
d267 3
a269 3
     * Handle the host field.
     */
    if (wanted & PARSE_HOST) {
d271 4
a274 5
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = '/';
		*tail++ = '/';
	    }
	    strcpy(tail, given.host ? given.host : related.host);
d278 3
a280 4
	     * Ignore default port numbers, and trailing dots on FQDNs, which
	     * will only cause identical addresses to look different.  (related
	     * is already a clean url).
	     */
a282 1

d284 1
a284 1
		    tail = (p2 + 1);
d286 1
a286 1
		if (p2 != NULL && !isdigit(UCH(p2[1])))
d288 2
a289 2
		     * Colon not followed by a port number.
		     */
d293 20
a312 21
		     * Port specified.
		     */
#define ACC_METHOD(a,b) (!strcmp(acc_method, a) && !strcmp(p2, b))
		    if (ACC_METHOD("http", ":80") ||
			ACC_METHOD("https", ":443") ||
			ACC_METHOD("gopher", ":70") ||
			ACC_METHOD("ftp", ":21") ||
			ACC_METHOD("wais", ":210") ||
			ACC_METHOD("nntp", ":119") ||
			ACC_METHOD("news", ":119") ||
			ACC_METHOD("newspost", ":119") ||
			ACC_METHOD("newsreply", ":119") ||
			ACC_METHOD("snews", ":563") ||
			ACC_METHOD("snewspost", ":563") ||
			ACC_METHOD("snewsreply", ":563") ||
			ACC_METHOD("finger", ":79") ||
			ACC_METHOD("telnet", ":23") ||
			ACC_METHOD("tn3270", ":23") ||
			ACC_METHOD("rlogin", ":513") ||
			ACC_METHOD("cso", ":105"))
			*p2 = '\0';	/* It is the default: ignore it */
d315 1
a315 1
		    int len3 = strlen(tail);
d317 2
a318 2
		    if (len3 > 0) {
			h = tail + len3 - 1;	/* last char of hostname */
d320 1
a320 1
			    *h = '\0';	/* chop final . */
d322 1
a322 1
		} else if (p2 != result) {
d324 1
a324 1
		    h--;	/* End of hostname */
d327 2
a328 2
			 * Slide p2 over h.
			 */
a336 23
    }

    /*
     * Trim any blanks from the result so far - there's no excuse for blanks
     * in a hostname.  Also update the tail here.
     */
    tail = LYRemoveBlanks(result);

    /*
     * If host in given or related was ended directly with a '?' (no slash),
     * fake the search part into absolute.  This is the only case search is
     * returned from scan.  A host must have been present.  this restores the
     * '?' at which the host part had been truncated in scan, we have to do
     * this after host part handling is done.  - kw
     */
    if (given.search && *(given.search - 1) == '\0') {
	given.absolute = given.search - 1;
	given.absolute[0] = '?';
    } else if (related.search && !related.absolute &&
	       *(related.search - 1) == '\0') {
	related.absolute = related.search - 1;
	related.absolute[0] = '?';
    }
d339 2
a340 2
     * If different hosts, inherit no path.
     */
d349 2
a350 2
     * Handle the path.
     */
d352 1
d354 2
a355 1

d357 11
a367 21
	    /*
	     * Treat all given nntp or snews paths, or given paths for news
	     * URLs with a host, as absolute.
	     */
	    switch (*acc_method) {
	    case 'N':
	    case 'n':
		if (!strcasecomp(acc_method, "nntp") ||
		    (!strcasecomp(acc_method, "news") &&
		     !strncasecomp(result, "news://", 7))) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
	    case 'S':
	    case 's':
		if (!strcasecomp(acc_method, "snews")) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
d370 1
a370 2

	if (given.absolute) {	/* All is given */
d372 6
a377 8
		*tail++ = '/';
	    strcpy(tail, given.absolute);
	    CTRACE((tfp, "HTParse: (ABS)\n"));
	} else if (related.absolute) {	/* Adopt path not name */
	    char *base = tail;

	    *tail++ = '/';
	    strcpy(tail, related.absolute);
d379 8
a386 21
		/* RFC 1808 part 4 step 5 (if URL path is empty) */
		/* a) if given has params, add/replace that */
		if (given.relative[0] == ';') {
		    strcpy(strchr_or_end(tail, ';'), given.relative);
		}
		/* b) if given has query, add/replace that */
		else if (given.relative[0] == '?') {
		    strcpy(strchr_or_end(tail, '?'), given.relative);
		}
		/* otherwise fall through to RFC 1808 part 4 step 6 */
		else {
		    p = strchr(tail, '?');	/* Search part? */
		    if (p == NULL)
			p = (tail + strlen(tail) - 1);
		    for (; *p != '/'; p--) ;	/* last / */
		    p[1] = '\0';	/* Remove filename */
		    strcat(p, given.relative);	/* Add given one */
		}
		HTSimplify(base);
		if (*base == '\0')
		    strcpy(base, "/");
d388 1
a388 1
	    CTRACE((tfp, "HTParse: (Related-ABS)\n"));
d390 2
a391 2
	    strcpy(tail, given.relative);	/* what we've got */
	    CTRACE((tfp, "HTParse: (REL)\n"));
d393 7
a399 8
	    strcpy(tail, related.relative);
	    CTRACE((tfp, "HTParse: (Related-REL)\n"));
	} else {		/* No inheritance */
	    if (!isLYNXCGI(aName) &&
		!isLYNXEXEC(aName) &&
		!isLYNXPROG(aName)) {
		*tail++ = '/';
		*tail = '\0';
d403 1
a403 1
	    CTRACE((tfp, "HTParse: (No inheritance)\n"));
d425 5
a429 5
     * Handle the fragment (anchor).  Never inherit.
     */
    if (wanted & PARSE_ANCHOR) {
	if (given.anchor && *given.anchor) {
	    tail += strlen(tail);
d431 7
a437 48
		*tail++ = '#';
	    strcpy(tail, given.anchor);
	}
    }

    /*
     * If there are any blanks remaining in the string, escape them as needed.
     * See the discussion in LYLegitimizeHREF() for example.
     */
    if ((p = strchr(result, ' ')) != 0) {
	switch (is_url(result)) {
	case UNKNOWN_URL_TYPE:
	    CTRACE((tfp, "HTParse:      ignore:`%s'\n", result));
	    break;
	case LYNXEXEC_URL_TYPE:
	case LYNXPROG_URL_TYPE:
	case LYNXCGI_URL_TYPE:
	case LYNXPRINT_URL_TYPE:
	case LYNXHIST_URL_TYPE:
	case LYNXDOWNLOAD_URL_TYPE:
	case LYNXKEYMAP_URL_TYPE:
	case LYNXIMGMAP_URL_TYPE:
	case LYNXCOOKIE_URL_TYPE:
	case LYNXDIRED_URL_TYPE:
	case LYNXOPTIONS_URL_TYPE:
	case LYNXCFG_URL_TYPE:
	case LYNXCOMPILE_OPTS_URL_TYPE:
	case LYNXMESSAGES_URL_TYPE:
	    CTRACE((tfp, "HTParse:      spaces:`%s'\n", result));
	    break;
	case NOT_A_URL_TYPE:
	default:
	    CTRACE((tfp, "HTParse:      encode:`%s'\n", result));
	    do {
		q = p + strlen(p) + 2;

		while (q != p + 1) {
		    q[0] = q[-2];
		    --q;
		}
		p[0] = '%';
		p[1] = '2';
		p[2] = '0';
	    } while ((p = strchr(result, ' ')) != 0);
	    break;
	}
    }
    CTRACE((tfp, "HTParse:      result:`%s'\n", result));
d440 1
a440 31
    LYalloca_free(result);

    /* FIXME: could be optimized using HTParse() internals */
    if (*relatedName &&
	((wanted & PARSE_ALL_WITHOUT_ANCHOR) == PARSE_ALL_WITHOUT_ANCHOR)) {
	/*
	 * Check whether to fill in localhost.  - FM
	 */
	LYFillLocalFileURL(&return_value, relatedName);
	CTRACE((tfp, "pass LYFillLocalFile:`%s'\n", return_value));
    }

    return return_value;	/* exactly the right length */
}

/*	HTParseAnchor(), fast HTParse() specialization
 *	----------------------------------------------
 *
 * On exit,
 *	returns		A pointer within input string (probably to its end '\0')
 */
const char *HTParseAnchor(const char *aName)
{
    const char *p = aName;

    for (; *p && *p != '#'; p++) ;
    if (*p == '#') {
	/* the safe way based on HTParse() -
	 * keeping in mind scan() peculiarities on schemes:
	 */
	struct struct_parts given;
d442 1
a442 16
	char *name = (char *) LYalloca((p - aName) + strlen(p) + 1);

	if (name == NULL) {
	    outofmem(__FILE__, "HTParseAnchor");
	}
	strcpy(name, aName);
	scan(name, &given);
	LYalloca_free(name);

	p++;			/*next to '#' */
	if (given.anchor == NULL) {
	    for (; *p; p++)	/*scroll to end '\0' */
		;
	}
    }
    return p;
d446 16
a461 15
 *	--------------------
 *
 *  A unix-style file is allowed to contain the sequence xxx/../ which may
 *  be replaced by "" , and the sequence "/./" which may be replaced by "/".
 *  Simplification helps us recognize duplicate filenames.
 *
 *	Thus,	/etc/junk/../fred	becomes /etc/fred
 *		/etc/junk/./fred	becomes /etc/junk/fred
 *
 *	but we should NOT change
 *		http://fred.xxx.edu/../..
 *
 *	or	../../albert.html
 */
void HTSimplify(char *filename)
d477 14
a490 12
		 * We're still treating a ?searchpart as part of the path in
		 * HTParse() and scan(), but if we encounter a '?' here, assume
		 * it's the delimiter and break.  We also could check for a
		 * parameter delimiter (';') here, but the current Fielding
		 * draft (wisely or ill-advisedly :) says that it should be
		 * ignored and collapsing be allowed in it's value).  The only
		 * defined parameter at present is ;type=[A, I, or D] for ftp
		 * URLs, so if there's a "/..", "/../", "/./", or terminal '.'
		 * following the ';', it must be due to the ';' being an
		 * unescaped path character and not actually a parameter
		 * delimiter.  - FM
		 */
d497 2
a498 2
		     * Handle "../", "..?" or "..".
		     */
d501 2
a502 2
			 * Back up to previous slash or beginning of string.
			 */
d509 3
a511 3
			 * Not at beginning of string or in a host field, so
			 * remove the "/xxx/..".
			 */
d516 10
a525 1
			*p = '\0';	/* terminate */
d527 2
a528 2
			 * Start again with previous slash.
			 */
d533 2
a534 2
		     * Handle "./" by removing both characters.
		     */
d538 2
a539 2
			*q++ = *q1++;
		    *q = '\0';	/* terminate */
d543 2
a544 2
		     * Handle ".?" by removing the dot.
		     */
d548 2
a549 2
			*q++ = *q1++;
		    *q = '\0';	/* terminate */
d553 2
a554 2
		     * Handle terminal "." by removing the character.
		     */
d559 2
a560 2
	if (p >= filename + 2 && *p == '?' && *(p - 1) == '.') {
	    if (*(p - 2) == '/') {
d562 2
a563 2
		 * Handle "/.?" by removing the dot.
		 */
d569 7
a575 7
	    } else if (*(p - 2) == '.' &&
		       p >= filename + 4 && *(p - 3) == '/' &&
		       (*(p - 4) != '/' ||
			(p > filename + 4 && *(p - 5) != ':'))) {
		/*
		 * Handle "xxx/..?"
		 */
d577 3
a579 3
		    /*
		     * Back up to previous slash or beginning of string.
		     */
d582 2
a583 2
		    if (q > filename && *(q - 1) == '/' &&
			!(q > filename + 1 && *(q - 1) != ':'))
d588 5
a592 4
		    /*
		     * Not after "//" at beginning of string or after "://",
		     * and xxx is not ".." or ".", so remove the "xxx/..".
		     */
d597 1
a597 1
		    *p = '\0';	/* terminate */
d605 26
a630 25
 *	-------------------
 *
 * This function creates and returns a string which gives an expression of
 * one address as related to another.  Where there is no relation, an absolute
 * address is returned.
 *
 *  On entry,
 *	Both names must be absolute, fully qualified names of nodes
 *	(no anchor bits)
 *
 *  On exit,
 *	The return result points to a newly allocated name which, if
 *	parsed by HTParse relative to relatedName, will yield aName.
 *	The caller is responsible for freeing the resulting name later.
 *
 */
char *HTRelative(const char *aName,
		 const char *relatedName)
{
    char *result = NULL;
    const char *p = aName;
    const char *q = relatedName;
    const char *after_access = NULL;
    const char *path = NULL;
    const char *last_slash = NULL;
d637 1
a637 1
	    after_access = p + 1;
d642 1
a642 1
		path = p;
d648 1
a648 1
    if (!after_access) {	/* Different access */
d650 1
a650 1
    } else if (slashes < 3) {	/* Different nodes */
d652 1
a652 1
    } else if (slashes == 3) {	/* Same node, different path */
d654 1
a654 1
    } else {			/* Some path in common */
a655 1

d659 1
a659 2
	result = typecallocn(char, 3 * levels + strlen(last_slash) + 1);

d665 1
a665 1
	strcat(result, last_slash + 1);
d667 2
a668 3
    CTRACE((tfp,
	    "HTparse: `%s' expressed relative to\n   `%s' is\n   `%s'.\n",
	    aName, relatedName, result));
d672 11
a682 12
/*	Escape undesirable characters using %			HTEscape()
 *	-------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a calloc'd string.
 */
/* *INDENT-OFF* */
static const unsigned char isAcceptable[96] =
d685 3
a687 3
 *	Bit 1		xpalpha		-- as xalpha but with plus.
 *	Bit 2 ...	path		-- as xpalphas but with /
 */
a694 3
/* *INDENT-ON* */

static const char *hex = "0123456789ABCDEF";
d696 1
d699 7
a705 6
char *HTEscape(const char *str,
	       unsigned char mask)
{
    const char *p;
    char *q;
    char *result;
a706 1

d708 1
a708 1
	if (!ACCEPTABLE(UCH(TOASCII(*p))))
d710 1
a710 2
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

a714 1

d719 2
a720 2
	} else
	    *q++ = *p;
d727 17
a743 16
 *	--------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be that may be unsafe are unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a malloc'd string.
 */
#define UNSAFE(ch) (((ch) <= 32) || ((ch) >= 127))

char *HTEscapeUnsafe(const char *str)
{
    const char *p;
    char *q;
    char *result;
a744 1

d746 1
a746 1
	if (UNSAFE(UCH(TOASCII(*p))))
d748 1
a748 2
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

d750 1
a750 1
	outofmem(__FILE__, "HTEscapeUnsafe");
d752 1
a752 2
	unsigned char a = TOASCII(*p);

d754 5
a758 5
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	} else
	    *q++ = *p;
d765 17
a781 16
 *	-----------------------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits,
 *	except that spaces are converted to '+' instead of %2B.
 *
 *	Unlike HTUnEscape(), this routine returns a calloced string.
 */
char *HTEscapeSP(const char *str,
		 unsigned char mask)
{
    const char *p;
    char *q;
    char *result;
a782 1

d784 1
a784 1
	if (!(*p == ' ' || ACCEPTABLE(UCH(TOASCII(*p)))))
d786 1
a786 2
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

a790 1

d794 1
a794 1
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
d806 13
a818 12
 *	------------------------------
 *
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y.
 *	The string is converted in place, as it will never grow.
 */
static char from_hex(char c)
{
    return (char) (c >= '0' && c <= '9' ? c - '0'
		   : c >= 'A' && c <= 'F' ? c - 'A' + 10
		   : c - 'a' + 10);	/* accept small letters just in case */
d821 2
a822 1
char *HTUnEscape(char *str)
d824 2
a825 2
    char *p = str;
    char *q = str;
d832 3
a834 3
	/*
	 * Tests shouldn't be needed, but better safe than sorry.
	 */
d836 2
a837 2
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2]))) {
d840 2
a841 2
		*q = (char) (from_hex(*p++) * 16);
	    if (*p) {
d843 4
a846 6
		 * Careful! FROMASCII() may evaluate its arg more than once!
		 */
		/* S/390 -- gil -- 0221 */
		*q = (char) (*q + from_hex(*p++));
	    }
	    *q = FROMASCII(*q);
d856 1
a856 1
}				/* HTUnEscape */
d859 12
a870 11
 *	-----------------------------------			Klaus Weide
 *							    (kweide@@tezcat.com)
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y, and a pointer to
 *	a second string containing one or more characters which
 *	should be unescaped if escaped in the first string.
 *	The first string is converted in place, as it will never grow.
 */
char *HTUnEscapeSome(char *str,
		     const char *do_trans)
d872 2
a873 2
    char *p = str;
    char *q = str;
d882 4
a885 5
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2])) &&
	    (testcode = (char) FROMASCII(from_hex(p[1]) * 16 +
					 from_hex(p[2]))) &&	/* %00 no good */
	    strchr(do_trans, testcode)) {	/* it's one of the ones we want */
d896 3
a898 3
}				/* HTUnEscapeSome */
/* *INDENT-OFF* */
static const unsigned char crfc[96] =
d901 2
a902 2
 *	Bit 1		xpalpha		-- need \escape if quoted
 */
a909 1
/* *INDENT-ON* */
d912 8
a919 10
 *  Turn a string which is not a RFC 822 token into a quoted-string. - KW
 *  The "quoted" parameter tells whether we need the beginning/ending quote
 *  marks.  If not, the caller will provide them -TD
 */
void HTMake822Word(char **str,
		   int quoted)
{
    const char *p;
    char *q;
    char *result;
d922 2
a923 3

    if (isEmpty(*str)) {
	StrAllocCopy(*str, quoted ? "\"\"" : "");
d927 1
a927 1
	a = TOASCII(*p);	/* S/390 -- gil -- 0240 */
d929 1
a929 1
	    ((crfc[a - 32]) & 1)) {
d936 1
a936 1
	    else if ((a & 127) < 32 || ((crfc[a - 32]) & 2))
d942 1
a942 1
    result = typecallocn(char, p - (*str) + added + 1);
d945 1
a945 4

    q = result;
    if (quoted)
	*q++ = '"';
d947 6
a952 7
     * Having converted the character to ASCII, we can't use symbolic
     * escape codes, since they're in the host character set, which
     * is not necessarily ASCII.  Thus we use octal escape codes instead.
     * -- gil (Paul Gilmartin) <pg@@sweng.stortek.com>
     */
    /* S/390 -- gil -- 0268 */
    for (p = *str; *p; p++) {
d955 1
a955 1
			      (a < 128 && ((crfc[a - 32]) & 2))))
d958 1
a958 1
	if (a == '\012' || (a == '\015' && (TOASCII(*(p + 1)) != '\012')))
d961 2
a962 3
    if (quoted)
	*q++ = '"';
    *q++ = '\0';		/* Terminate */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a7 1
#include <LYUtils.h>
a8 6
#include <LYStrings.h>
#include <LYCharUtils.h>

#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#endif
d17 1
a17 1
	char * search;		/* treated normally as part of path */
d22 1
a22 1
/*	Strip white space off a string.				HTStrip()
d30 1
a30 1
	char *,		s)
d47 2
a48 2
/*	Scan a filename for its constituents.			scan()
**	-------------------------------------
d58 1
a58 1
	char *,			name,
d63 3
a70 1
    parts->search = NULL;	/* normally not used - kw */
d88 3
a113 6
	    } else {
		p = strchr(parts->host, '?');
		if (p != NULL) {
		    *p = '\0';			/* Terminate host */
		    parts->search = (p + 1);
		}
d126 1
a126 2
    if (parts->access && parts->anchor &&
		/* optimize */ strchr("lnsdLNSD", *parts->access) != NULL) {
d146 13
a160 7
#if defined(HAVE_ALLOCA) && !defined(LY_FIND_LEAKS)
#define LYalloca(x)        alloca(x)
#define LYalloca_free(x)   {}
#else
#define LYalloca(x)        malloc(x)
#define LYalloca_free(x)   free(x)
#endif
d174 1
a174 1
**     returns         A pointer to a malloc'd string which MUST BE FREED
a181 1
    char * tail = NULL;  /* a pointer to the end of the 'result' string */
d183 1
a183 1
    int len, len1, len2;
d190 1
a190 2
    CTRACE((tfp, "HTParse: aName:`%s'\n", aName));
    CTRACE((tfp, "   relatedName:`%s'\n", relatedName));
a198 9
    CTRACE((tfp, "   want:%s%s%s%s%s%s%s\n",
	    wanted & PARSE_PUNCTUATION ? " punc"   : "",
	    wanted & PARSE_ANCHOR      ? " anchor" : "",
	    wanted & PARSE_PATH        ? " path"   : "",
	    wanted & PARSE_HOST        ? " host"   : "",
	    wanted & PARSE_ACCESS      ? " access" : "",
	    wanted & PARSE_STRICTPATH  ? " PATH"   : "",
	    wanted & PARSE_QUERY       ? " QUERY"  : ""));

d200 1
a200 1
    ** Allocate the temporary string. Optimized.
d202 2
a203 5
    len1 = strlen(aName) + 1;
    len2 = strlen(relatedName) + 1;
    len = len1 + len2 + 8;     /* Lots of space: more than enough */

    result = tail = (char*)LYalloca(len * 2 + len1 + len2);
a206 3
    *result = '\0';
    name = result + len;
    rel = name + len1;
d209 1
a209 1
    **	Make working copy of the input string to cut up.
d211 2
a212 1
    memcpy(name, aName, len1);
d215 1
a215 1
    **	Cut up the string into URL fields.
d218 1
a218 19

    /*
    **	Now related string.
    */
    if ((given.access && given.host && given.absolute) || !*relatedName) {
	/*
	**  Inherit nothing!
	*/
	related.access = NULL;
	related.host = NULL;
	related.absolute = NULL;
	related.relative = NULL;
	related.search = NULL;
	related.anchor = NULL;
    } else {
	memcpy(rel, relatedName, len2);
	scan(rel,  &related);
    }

d235 3
a237 6
	    strcpy(tail, acc_method);
	    tail += strlen(tail);
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = ':';
		*tail = '\0';
	    }
a262 1
	related.search = NULL;
d269 1
a269 1
    if (wanted & PARSE_HOST) {
d271 4
a274 5
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = '/';
		*tail++ = '/';
	    }
	    strcpy(tail, given.host ? given.host : related.host);
a279 1
	    **  (related is already a clean url).
d284 1
a284 1
 		   tail = (p2 + 1);
d286 1
a286 1
		if (p2 != NULL && !isdigit(UCH(p2[1])))
d315 1
a315 1
		    int len3 = strlen(tail);
d317 2
a318 2
		    if (len3 > 0) {
			h = tail + len3 - 1;	/* last char of hostname */
d322 1
a322 1
		} else if (p2 != result) {
a336 23
    }

    /*
     * Trim any blanks from the result so far - there's no excuse for blanks
     * in a hostname.  Also update the tail here.
     */
    tail = LYRemoveBlanks(result);

    /*
    **	If host in given or related was ended directly with a '?' (no
    **  slash), fake the search part into absolute.  This is the only
    **  case search is returned from scan.  A host must have been present.
    **  this restores the '?' at which the host part had been truncated in
    **  scan, we have to do this after host part handling is done. - kw
    */
    if (given.search && *(given.search - 1) == '\0') {
	given.absolute = given.search - 1;
	given.absolute[0] = '?';
    } else if (related.search && !related.absolute &&
	       *(related.search - 1) == '\0') {
	related.absolute = related.search - 1;
	related.absolute[0] = '?';
    }
d352 1
d354 2
a355 1

d357 11
a367 21
	    /*
	     * Treat all given nntp or snews paths, or given paths for news
	     * URLs with a host, as absolute.
	     */
	    switch (*acc_method) {
	    case 'N':
	    case 'n':
		if (!strcasecomp(acc_method, "nntp") ||
		    (!strcasecomp(acc_method, "news") &&
		     !strncasecomp(result, "news://", 7))) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
	    case 'S':
	    case 's':
		if (!strcasecomp(acc_method, "snews")) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
a369 1

d372 3
a374 3
		*tail++ = '/';
	    strcpy(tail, given.absolute);
	    CTRACE((tfp, "HTParse: (ABS)\n"));
d376 2
a377 2
	    *tail++ = '/';
	    strcpy(tail, related.absolute);
d379 1
a379 1
		p = strchr(tail, '?');	/* Search part? */
d381 1
a381 1
		    p = (tail + strlen(tail) - 1);
d385 1
a385 1
		strcat(p, given.relative); /* Add given one */
d388 1
a388 1
	    CTRACE((tfp, "HTParse: (Related-ABS)\n"));
d390 2
a391 2
	    strcpy(tail, given.relative);		/* what we've got */
	    CTRACE((tfp, "HTParse: (REL)\n"));
d393 2
a394 2
	    strcpy(tail, related.relative);
	    CTRACE((tfp, "HTParse: (Related-REL)\n"));
d396 4
a399 5
	    if (!isLYNXCGI(aName) &&
		!isLYNXEXEC(aName) &&
		!isLYNXPROG(aName)) {
		*tail++ = '/';
		*tail = '\0';
d403 1
a403 1
	    CTRACE((tfp, "HTParse: (No inheritance)\n"));
d425 1
a425 1
    **	Handle the fragment (anchor). Never inherit.
d427 3
a429 3
    if (wanted & PARSE_ANCHOR) {
	if (given.anchor && *given.anchor) {
	    tail += strlen(tail);
d431 7
a437 47
		*tail++ = '#';
	    strcpy(tail, given.anchor);
	}
    }

    /*
     * If there are any blanks remaining in the string, escape them as needed.
     * See the discussion in LYLegitimizeHREF() for example.
     */
    if ((p = strchr(result, ' ')) != 0) {
	switch (is_url(result)) {
	case NOT_A_URL_TYPE:
	case UNKNOWN_URL_TYPE:
	    CTRACE((tfp, "HTParse:      ignore:`%s'\n", result));
	    break;
	case LYNXEXEC_URL_TYPE:
	case LYNXPROG_URL_TYPE:
	case LYNXCGI_URL_TYPE:
	case LYNXPRINT_URL_TYPE:
	case LYNXHIST_URL_TYPE:
	case LYNXDOWNLOAD_URL_TYPE:
	case LYNXKEYMAP_URL_TYPE:
	case LYNXIMGMAP_URL_TYPE:
	case LYNXCOOKIE_URL_TYPE:
	case LYNXDIRED_URL_TYPE:
	case LYNXOPTIONS_URL_TYPE:
	case LYNXCFG_URL_TYPE:
	case LYNXCOMPILE_OPTS_URL_TYPE:
	case LYNXMESSAGES_URL_TYPE:
	    CTRACE((tfp, "HTParse:      spaces:`%s'\n", result));
	    break;
	default:
	    CTRACE((tfp, "HTParse:      encode:`%s'\n", result));
	    do {
		char *q = p + strlen(p) + 2;
		while (q != p + 1) {
		    q[0] = q[-2];
		    --q;
		}
		p[0] = '%';
		p[1] = '2';
		p[2] = '0';
	    } while ((p = strchr(result, ' ')) != 0);
	    break;
	}
    }
    CTRACE((tfp, "HTParse:      result:`%s'\n", result));
d440 1
a440 11
    LYalloca_free(result);

    /* FIXME: could be optimized using HTParse() internals */
    if (*relatedName &&
	((wanted & PARSE_ALL_WITHOUT_ANCHOR) == PARSE_ALL_WITHOUT_ANCHOR)) {
	/*
	 *  Check whether to fill in localhost. - FM
	 */
	LYFillLocalFileURL(&return_value, relatedName);
	CTRACE((tfp, "pass LYFillLocalFile:`%s'\n", return_value));
    }
a444 35
/*	HTParseAnchor(), fast HTParse() specialization
**	----------------------------------------------
**
** On exit,
**	returns		A pointer within input string (probably to its end '\0')
*/
PUBLIC CONST char * HTParseAnchor ARGS1(
	CONST char *,	aName)
{
    CONST char* p = aName;
    for ( ; *p && *p != '#'; p++)
	;
    if (*p == '#') {
	/* the safe way based on HTParse() -
	 * keeping in mind scan() peculiarities on schemes:
	 */
	struct struct_parts given;

	char* name = (char*)LYalloca((p - aName) + strlen(p) + 1);
	if (name == NULL) {
	    outofmem(__FILE__, "HTParseAnchor");
	}
	strcpy(name, aName);
	scan(name, &given);
	LYalloca_free(name);

	p++; /*next to '#'*/
	if (given.anchor == NULL) {
	    for ( ; *p; p++)  /*scroll to end '\0'*/
		;
	}
    }
    return p;
}

d448 2
a449 2
**  A unix-style file is allowed to contain the sequence xxx/../ which may
**  be replaced by "" , and the sequence "/./" which may be replaced by "/".
d461 1
a461 1
	char *,		filename)
d517 9
d538 1
a538 1
			*q++ = *q1++;
d548 1
a548 1
			*q++ = *q1++;
d609 1
a609 1
** address is returned.
d659 1
a659 1
	result = typecallocn(char, 3*levels + strlen(last_slash) + 1);
d667 2
a668 3
    CTRACE((tfp,
	"HTparse: `%s' expressed relative to\n	 `%s' is\n   `%s'.\n",
		aName, relatedName, result));
d672 1
a672 1
/*	Escape undesirable characters using %			HTEscape()
d680 1
a680 1
**	Unlike HTUnEscape(), this routine returns a calloc'd string.
d685 1
a685 1
**	Bit 1		xpalpha		-- as xalpha but with plus.
d708 1
a708 1
	if (!ACCEPTABLE(UCH(TOASCII(*p))))
d710 1
a710 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d730 1
a730 1
**	some characters may be that may be unsafe are unescaped.
d732 1
a732 1
**	represented by a '%' character followed by two hex digits.
d736 1
a736 1
#define UNSAFE(ch) (((ch) <= 32) || ((ch) >= 127))
d746 1
a746 1
	if (UNSAFE(UCH(TOASCII(*p))))
d748 1
a748 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d750 1
a750 1
	outofmem(__FILE__, "HTEscapeUnsafe");
d752 1
a752 1
	unsigned char a = TOASCII(*p);
d754 5
a758 5
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	}
	else *q++ = *p;
d784 1
a784 1
	if (!(*p == ' ' || ACCEPTABLE(UCH(TOASCII(*p)))))
d786 1
a786 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d794 1
a794 1
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
d801 1
a801 1
    *q++ = '\0';			/* Terminate */
d810 1
a810 1
**	the ASCII hex code for character 16x+y.
d816 1
a816 1
    return (char) ( c >= '0' && c <= '9' ?  c - '0'
d818 1
a818 1
	    : c - 'a' + 10);     /* accept small letters just in case */
d822 1
a822 1
	char *,		str)
d836 2
a837 2
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2]))) {
d840 2
a841 2
		*q = (char) (from_hex(*p++) * 16);
	    if (*p) {
d843 1
a843 1
		** Careful! FROMASCII() may evaluate its arg more than once!
d845 2
a846 3
		*q = (char) (*q + from_hex(*p++));
	    }
	    *q = FROMASCII(*q);
d863 1
a863 1
**	the ASCII hex code for character 16x+y, and a pointer to
d869 1
a869 1
	char *,		str,
d882 3
a884 4
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2])) &&
	    (testcode = (char) FROMASCII(from_hex(p[1])*16 +
		from_hex(p[2]))) && /* %00 no good*/
d901 1
a901 1
**	Bit 1		xpalpha		-- need \escape if quoted
a912 2
**  The "quoted" parameter tells whether we need the beginning/ending quote
**  marks.  If not, the caller will provide them -TD
d914 2
a915 3
PUBLIC void HTMake822Word ARGS2(
	char **,	str,
	int,		quoted)
d922 2
a923 3

    if (isEmpty(*str)) {
	StrAllocCopy(*str, quoted ? "\"\"" : "");
d942 1
a942 1
    result = typecallocn(char, p-(*str) + added + 1);
d945 1
a945 4

    q = result;
    if (quoted)
	*q++ = '"';
d952 1
a952 1
    for (p = *str; *p; p++) {
d961 1
a961 2
    if (quoted)
	*q++ = '"';
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d327 1
a327 1
		   tail = (p2 + 1);
d518 1
a537 1
	case NOT_A_URL_TYPE:
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d820 2
a821 2
	    "HTparse: `%s' expressed relative to\n   `%s' is\n   `%s'.\n",
	    aName, relatedName, result));
@


1.1.3.4
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a14 4
#else
#ifdef __MINGW32__
#include <malloc.h>
#endif /* __MINGW32__ */
@


1.1.3.5
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d40 2
a41 2
char * HTStrip (
	char *		s)
d68 3
a70 3
static void scan (
	char *			name,
	struct struct_parts *	parts)
d183 4
a186 4
char * HTParse (
	const char *	aName,
	const char *	relatedName,
	int		wanted)
d581 2
a582 2
const char * HTParseAnchor (
	const char *	aName)
d584 1
a584 1
    const char* p = aName;
d625 2
a626 2
void HTSimplify (
	char *		filename)
d777 3
a779 3
char * HTRelative (
	const char *	aName,
	const char *	relatedName)
d782 5
a786 5
    const char *p = aName;
    const char *q = relatedName;
    const char * after_access = NULL;
    const char * path = NULL;
    const char * last_slash = NULL;
d839 1
a839 1
static const unsigned char isAcceptable[96] =
d853 1
a853 1
static char *hex = "0123456789ABCDEF";
d856 3
a858 3
char * HTEscape (
	const char *	str,
	unsigned char	mask)
d860 1
a860 1
    const char * p;
d895 2
a896 2
char *HTEscapeUnsafe (
	const char *	str)
d898 1
a898 1
    const char * p;
d932 3
a934 3
char * HTEscapeSP (
	const char *	str,
	unsigned char	mask)
d936 1
a936 1
    const char * p;
d970 2
a971 2
static char from_hex (
	char		c)
d978 2
a979 2
char * HTUnEscape (
	char *		str)
d1026 3
a1028 3
char * HTUnEscapeSome (
	char *		str,
	const char *	do_trans)
d1057 1
a1057 1
static const unsigned char crfc[96] =
d1075 3
a1077 3
void HTMake822Word (
	char **	str,
	int		quoted)
d1079 1
a1079 1
    const char * p;
@


1.1.3.6
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 2
a3 2
 *		================================
 */
d24 6
a29 6
    char *access;
    char *host;
    char *absolute;
    char *relative;
    char *search;		/* treated normally as part of path */
    char *anchor;
d32 1
d34 8
a41 7
 *	-------------------------------
 *
 * On exit,
 *	Return value points to first non-white character, or to 0 if none.
 *	All trailing white space is OVERWRITTEN with zero.
 */
char *HTStrip(char *s)
d44 3
a46 3
    char *p = s;

    for (p = s; *p; p++) ;	/* Find end of string */
d59 12
a70 11
 *	-------------------------------------
 *
 * On entry,
 *	name	points to a document name which may be incomplete.
 * On exit,
 *	absolute or relative may be nonzero (but not both).
 *	host, anchor and access may be nonzero if they were specified.
 *	Any which are nonzero point to zero terminated strings.
 */
static void scan(char *name,
		 struct struct_parts *parts)
d72 2
a73 2
    char *after_access;
    char *p;
d83 2
a84 2
     * Scan left-to-right for a scheme (access).
     */
d87 1
a87 1
	if (*p == ':') {
d98 2
a99 2
     * Scan left-to-right for a fragment (anchor).
     */
d101 1
a101 1
	if (*p == '#') {
d103 1
a103 1
	    *p = '\0';		/* terminate the rest */
d109 2
a110 2
     * Scan left-to-right for a host or absolute path.
     */
d114 3
a116 3
	    parts->host = (p + 2);	/* host has been specified    */
	    *p = '\0';		/* Terminate access           */
	    p = strchr(parts->host, '/');	/* look for end of host name if any */
d118 1
a118 1
		*p = '\0';	/* Terminate host */
d123 1
a123 1
		    *p = '\0';	/* Terminate host */
d128 1
a128 1
	    parts->absolute = (p + 1);	/* Root found but no host */
d132 1
a132 1
	    after_access : NULL;	/* NULL for "" */
d136 2
a137 2
     * Check schemes that commonly have unescaped hashes.
     */
d139 1
a139 1
    /* optimize */ strchr("lnsdLNSD", *parts->access) != NULL) {
d146 4
a149 4
	     * Access specified but no host and not a lynxcgi URL, so the
	     * anchor may not really be one, e.g., news:j462#36487@@foo.bar, or
	     * it's an nntp or snews URL, or news URL with a host.  Restore the
	     * '#' in the address.
d159 1
a159 1
}				/*scan */
d170 17
a186 16
 *	--------------------------------------
 *
 *	This returns those parts of a name which are given (and requested)
 *	substituting bits from the related name where necessary.
 *
 * On entry,
 *	aName		A filename given
 *	relatedName	A name relative to which aName is to be parsed
 *	wanted		A mask for the bits which are wanted.
 *
 * On exit,
 *     returns         A pointer to a malloc'd string which MUST BE FREED
 */
char *HTParse(const char *aName,
	      const char *relatedName,
	      int wanted)
d188 3
a190 3
    char *result = NULL;
    char *tail = NULL;		/* a pointer to the end of the 'result' string */
    char *return_value = NULL;
d192 4
a195 4
    char *name = NULL;
    char *rel = NULL;
    char *p;
    char *acc_method;
d201 1
a201 1
    if (wanted & (PARSE_STRICTPATH | PARSE_QUERY)) {	/* if detail wanted... */
d203 4
a206 4
	    == (PARSE_STRICTPATH | PARSE_QUERY))	/* if strictpath AND query */
	    wanted |= PARSE_PATH;	/* then treat as if PARSE_PATH wanted */
	if (wanted & PARSE_PATH)	/* if PARSE_PATH wanted */
	    wanted &= ~(PARSE_STRICTPATH | PARSE_QUERY);	/* ignore details */
a207 1
/* *INDENT-OFF* */
a215 1
/* *INDENT-ON* */
d218 2
a219 2
     * Allocate the temporary string. Optimized.
     */
d222 1
a222 1
    len = len1 + len2 + 8;	/* Lots of space: more than enough */
d224 1
a224 1
    result = tail = (char *) LYalloca(len * 2 + len1 + len2);
d233 2
a234 2
     * Make working copy of the input string to cut up.
     */
d238 2
a239 2
     * Cut up the string into URL fields.
     */
d243 2
a244 2
     * Now related string.
     */
d247 2
a248 2
	 * Inherit nothing!
	 */
d257 1
a257 1
	scan(rel, &related);
d260 1
d262 2
a263 2
     * Handle the scheme (access) field.
     */
d269 2
a270 2
	     * Assume root.
	     */
d286 15
a300 11
     * If different schemes, inherit nothing.
     *
     * We'll try complying with RFC 1808 and the Fielding draft, and inherit
     * nothing if both schemes are given, rather than only when they differ,
     * except for file URLs - FM
     *
     * After trying it for a while, it's still premature, IHMO, to go along
     * with it, so this is back to inheriting for identical schemes whether or
     * not they are "file".  If you want to try it again yourself, uncomment
     * the strcasecomp() below.  - FM
     */
d302 2
a303 2
	(			/* strcasecomp(given.access, "file") || */
	    strcmp(given.access, related.access))) {
d312 2
a313 2
     * Handle the host field.
     */
d324 4
a327 4
	     * Ignore default port numbers, and trailing dots on FQDNs, which
	     * will only cause identical addresses to look different.  (related
	     * is already a clean url).
	     */
a329 1

d331 1
a331 1
		    tail = (p2 + 1);
d335 2
a336 2
		     * Colon not followed by a port number.
		     */
d340 20
a359 21
		     * Port specified.
		     */
#define ACC_METHOD(a,b) (!strcmp(acc_method, a) && !strcmp(p2, b))
		    if (ACC_METHOD("http", ":80") ||
			ACC_METHOD("https", ":443") ||
			ACC_METHOD("gopher", ":70") ||
			ACC_METHOD("ftp", ":21") ||
			ACC_METHOD("wais", ":210") ||
			ACC_METHOD("nntp", ":119") ||
			ACC_METHOD("news", ":119") ||
			ACC_METHOD("newspost", ":119") ||
			ACC_METHOD("newsreply", ":119") ||
			ACC_METHOD("snews", ":563") ||
			ACC_METHOD("snewspost", ":563") ||
			ACC_METHOD("snewsreply", ":563") ||
			ACC_METHOD("finger", ":79") ||
			ACC_METHOD("telnet", ":23") ||
			ACC_METHOD("tn3270", ":23") ||
			ACC_METHOD("rlogin", ":513") ||
			ACC_METHOD("cso", ":105"))
			*p2 = '\0';	/* It is the default: ignore it */
d367 1
a367 1
			    *h = '\0';	/* chop final . */
d371 1
a371 1
		    h--;	/* End of hostname */
d374 2
a375 2
			 * Slide p2 over h.
			 */
d393 6
a398 6
     * If host in given or related was ended directly with a '?' (no slash),
     * fake the search part into absolute.  This is the only case search is
     * returned from scan.  A host must have been present.  this restores the
     * '?' at which the host part had been truncated in scan, we have to do
     * this after host part handling is done.  - kw
     */
d409 2
a410 2
     * If different hosts, inherit no path.
     */
d419 2
a420 2
     * Handle the path.
     */
d449 1
a449 1
	if (given.absolute) {	/* All is given */
d454 1
a454 1
	} else if (related.absolute) {	/* Adopt path not name */
d461 5
a465 4
		for (; *p != '/'; p--) ;	/* last / */
		p[1] = '\0';	/* Remove filename */
		strcat(p, given.relative);	/* Add given one */
		HTSimplify(result);
d469 1
a469 1
	    strcpy(tail, given.relative);	/* what we've got */
d474 1
a474 1
	} else {		/* No inheritance */
d505 2
a506 2
     * Handle the fragment (anchor).  Never inherit.
     */
a545 1

d566 1
a566 1
	 * Check whether to fill in localhost.  - FM
d572 1
a572 1
    return return_value;	/* exactly the right length */
d576 7
a582 6
 *	----------------------------------------------
 *
 * On exit,
 *	returns		A pointer within input string (probably to its end '\0')
 */
const char *HTParseAnchor(const char *aName)
d584 3
a586 3
    const char *p = aName;

    for (; *p && *p != '#'; p++) ;
d593 1
a593 2
	char *name = (char *) LYalloca((p - aName) + strlen(p) + 1);

d601 1
a601 1
	p++;			/*next to '#' */
d603 1
a603 1
	    for (; *p; p++)	/*scroll to end '\0' */
d611 16
a626 15
 *	--------------------
 *
 *  A unix-style file is allowed to contain the sequence xxx/../ which may
 *  be replaced by "" , and the sequence "/./" which may be replaced by "/".
 *  Simplification helps us recognize duplicate filenames.
 *
 *	Thus,	/etc/junk/../fred	becomes /etc/fred
 *		/etc/junk/./fred	becomes /etc/junk/fred
 *
 *	but we should NOT change
 *		http://fred.xxx.edu/../..
 *
 *	or	../../albert.html
 */
void HTSimplify(char *filename)
d642 14
a655 12
		 * We're still treating a ?searchpart as part of the path in
		 * HTParse() and scan(), but if we encounter a '?' here, assume
		 * it's the delimiter and break.  We also could check for a
		 * parameter delimiter (';') here, but the current Fielding
		 * draft (wisely or ill-advisedly :) says that it should be
		 * ignored and collapsing be allowed in it's value).  The only
		 * defined parameter at present is ;type=[A, I, or D] for ftp
		 * URLs, so if there's a "/..", "/../", "/./", or terminal '.'
		 * following the ';', it must be due to the ';' being an
		 * unescaped path character and not actually a parameter
		 * delimiter.  - FM
		 */
d662 2
a663 2
		     * Handle "../", "..?" or "..".
		     */
d666 2
a667 2
			 * Back up to previous slash or beginning of string.
			 */
d674 3
a676 3
			 * Not at beginning of string or in a host field, so
			 * remove the "/xxx/..".
			 */
d681 1
a681 1
			*p = '\0';	/* terminate */
d683 2
a684 2
			 * Start again with previous slash.
			 */
d689 2
a690 2
		     * Handle "./" by removing both characters.
		     */
d695 1
a695 1
		    *q = '\0';	/* terminate */
d699 2
a700 2
		     * Handle ".?" by removing the dot.
		     */
d705 1
a705 1
		    *q = '\0';	/* terminate */
d709 2
a710 2
		     * Handle terminal "." by removing the character.
		     */
d715 2
a716 2
	if (p >= filename + 2 && *p == '?' && *(p - 1) == '.') {
	    if (*(p - 2) == '/') {
d718 2
a719 2
		 * Handle "/.?" by removing the dot.
		 */
d725 7
a731 7
	    } else if (*(p - 2) == '.' &&
		       p >= filename + 4 && *(p - 3) == '/' &&
		       (*(p - 4) != '/' ||
			(p > filename + 4 && *(p - 5) != ':'))) {
		/*
		 * Handle "xxx/..?"
		 */
d733 3
a735 3
		    /*
		     * Back up to previous slash or beginning of string.
		     */
d738 2
a739 2
		    if (q > filename && *(q - 1) == '/' &&
			!(q > filename + 1 && *(q - 1) != ':'))
d744 5
a748 4
		    /*
		     * Not after "//" at beginning of string or after "://",
		     * and xxx is not ".." or ".", so remove the "xxx/..".
		     */
d753 1
a753 1
		    *p = '\0';	/* terminate */
d761 19
a779 18
 *	-------------------
 *
 * This function creates and returns a string which gives an expression of
 * one address as related to another.  Where there is no relation, an absolute
 * address is returned.
 *
 *  On entry,
 *	Both names must be absolute, fully qualified names of nodes
 *	(no anchor bits)
 *
 *  On exit,
 *	The return result points to a newly allocated name which, if
 *	parsed by HTParse relative to relatedName, will yield aName.
 *	The caller is responsible for freeing the resulting name later.
 *
 */
char *HTRelative(const char *aName,
		 const char *relatedName)
d781 1
a781 1
    char *result = NULL;
d784 3
a786 3
    const char *after_access = NULL;
    const char *path = NULL;
    const char *last_slash = NULL;
d793 1
a793 1
	    after_access = p + 1;
d798 1
a798 1
		path = p;
d804 1
a804 1
    if (!after_access) {	/* Different access */
d806 1
a806 1
    } else if (slashes < 3) {	/* Different nodes */
d808 1
a808 1
    } else if (slashes == 3) {	/* Same node, different path */
d810 1
a810 1
    } else {			/* Some path in common */
a811 1

d815 1
a815 2
	result = typecallocn(char, 3 * levels + strlen(last_slash) + 1);

d821 1
a821 1
	strcat(result, last_slash + 1);
d830 9
a838 10
 *	-------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a calloc'd string.
 */
/* *INDENT-OFF* */
d842 3
a844 3
 *	Bit 1		xpalpha		-- as xalpha but with plus.
 *	Bit 2 ...	path		-- as xpalphas but with /
 */
a851 1
/* *INDENT-ON* */
a853 1

d856 3
a858 2
char *HTEscape(const char *str,
	       unsigned char mask)
d860 3
a862 3
    const char *p;
    char *q;
    char *result;
a863 1

d867 1
a867 2
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

a871 1

d876 2
a877 2
	} else
	    *q++ = *p;
d884 9
a892 9
 *	--------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be that may be unsafe are unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a malloc'd string.
 */
d895 2
a896 1
char *HTEscapeUnsafe(const char *str)
d898 3
a900 3
    const char *p;
    char *q;
    char *result;
a901 1

d905 1
a905 2
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

a909 1

d914 2
a915 2
	} else
	    *q++ = *p;
d922 13
a934 12
 *	-----------------------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits,
 *	except that spaces are converted to '+' instead of %2B.
 *
 *	Unlike HTUnEscape(), this routine returns a calloced string.
 */
char *HTEscapeSP(const char *str,
		 unsigned char mask)
d936 3
a938 3
    const char *p;
    char *q;
    char *result;
a939 1

d943 1
a943 2
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);

a947 1

d958 1
a958 1
    *q++ = '\0';		/* Terminate */
d963 9
a971 8
 *	------------------------------
 *
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y.
 *	The string is converted in place, as it will never grow.
 */
static char from_hex(char c)
d973 3
a975 3
    return (char) (c >= '0' && c <= '9' ? c - '0'
		   : c >= 'A' && c <= 'F' ? c - 'A' + 10
		   : c - 'a' + 10);	/* accept small letters just in case */
d978 2
a979 1
char *HTUnEscape(char *str)
d981 2
a982 2
    char *p = str;
    char *q = str;
d989 3
a991 3
	/*
	 * Tests shouldn't be needed, but better safe than sorry.
	 */
d1000 2
a1001 3
		 * Careful! FROMASCII() may evaluate its arg more than once!
		 */
		/* S/390 -- gil -- 0221 */
d1014 1
a1014 1
}				/* HTUnEscape */
d1017 12
a1028 11
 *	-----------------------------------			Klaus Weide
 *							    (kweide@@tezcat.com)
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y, and a pointer to
 *	a second string containing one or more characters which
 *	should be unescaped if escaped in the first string.
 *	The first string is converted in place, as it will never grow.
 */
char *HTUnEscapeSome(char *str,
		     const char *do_trans)
d1030 2
a1031 2
    char *p = str;
    char *q = str;
d1042 3
a1044 3
	    (testcode = (char) FROMASCII(from_hex(p[1]) * 16 +
					 from_hex(p[2]))) &&	/* %00 no good */
	    strchr(do_trans, testcode)) {	/* it's one of the ones we want */
d1055 2
a1056 2
}				/* HTUnEscapeSome */
/* *INDENT-OFF* */
d1060 2
a1061 2
 *	Bit 1		xpalpha		-- need \escape if quoted
 */
a1068 1
/* *INDENT-ON* */
d1071 7
a1077 6
 *  Turn a string which is not a RFC 822 token into a quoted-string. - KW
 *  The "quoted" parameter tells whether we need the beginning/ending quote
 *  marks.  If not, the caller will provide them -TD
 */
void HTMake822Word(char **str,
		   int quoted)
d1079 3
a1081 3
    const char *p;
    char *q;
    char *result;
d1090 1
a1090 1
	a = TOASCII(*p);	/* S/390 -- gil -- 0240 */
d1092 1
a1092 1
	    ((crfc[a - 32]) & 1)) {
d1099 1
a1099 1
	    else if ((a & 127) < 32 || ((crfc[a - 32]) & 2))
d1105 1
a1105 1
    result = typecallocn(char, p - (*str) + added + 1);
d1113 5
a1117 6
     * Having converted the character to ASCII, we can't use symbolic
     * escape codes, since they're in the host character set, which
     * is not necessarily ASCII.  Thus we use octal escape codes instead.
     * -- gil (Paul Gilmartin) <pg@@sweng.stortek.com>
     */
    /* S/390 -- gil -- 0268 */
d1121 1
a1121 1
			      (a < 128 && ((crfc[a - 32]) & 2))))
d1124 1
a1124 1
	if (a == '\012' || (a == '\015' && (TOASCII(*(p + 1)) != '\012')))
d1129 1
a1129 1
    *q++ = '\0';		/* Terminate */
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a31 18
#if 0				/* for debugging */
static void show_parts(const char *name, struct struct_parts *parts, int line)
{
    if (TRACE) {
	CTRACE((tfp, "struct_parts(%s) %s@@%d\n", name, __FILE__, line));
	CTRACE((tfp, "   access   '%s'\n", NONNULL(parts->access)));
	CTRACE((tfp, "   host     '%s'\n", NONNULL(parts->host)));
	CTRACE((tfp, "   absolute '%s'\n", NONNULL(parts->absolute)));
	CTRACE((tfp, "   relative '%s'\n", NONNULL(parts->relative)));
	CTRACE((tfp, "   search   '%s'\n", NONNULL(parts->search)));
	CTRACE((tfp, "   anchor   '%s'\n", NONNULL(parts->anchor)));
    }
}
#define SHOW_PARTS(name) show_parts(#name, &name, __LINE__)
#else
#define SHOW_PARTS(name)	/* nothing */
#endif

a165 10
static char *strchr_or_end(char *string, int ch)
{
    char *result = strchr(string, ch);

    if (result == 0) {
	result = string + strlen(string);
    }
    return result;
}

d190 1
a190 1
    char *p, *q;
a238 1
    SHOW_PARTS(given);
a256 1
    SHOW_PARTS(related);
d453 6
a458 18
		/* RFC 1808 part 4 step 5 (if URL path is empty) */
		/* a) if given has params, add/replace that */
		if (given.relative[0] == ';') {
		    strcpy(strchr_or_end(tail, ';'), given.relative);
		}
		/* b) if given has query, add/replace that */
		else if (given.relative[0] == '?') {
		    strcpy(strchr_or_end(tail, '?'), given.relative);
		}
		/* otherwise fall through to RFC 1808 part 4 step 6 */
		else {
		    p = strchr(tail, '?');	/* Search part? */
		    if (p == NULL)
			p = (tail + strlen(tail) - 1);
		    for (; *p != '/'; p--) ;	/* last / */
		    p[1] = '\0';	/* Remove filename */
		    strcat(p, given.relative);	/* Add given one */
		}
d539 1
a539 1
		q = p + strlen(p) + 2;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d17 1
a17 1
	char * search;		/* treated normally as part of path */
d22 1
a22 1
/*	Strip white space off a string.				HTStrip()
d30 1
a30 1
	char *,		s)
d58 1
a58 1
	char *,			name,
a70 1
    parts->search = NULL;	/* normally not used - kw */
a113 6
	    } else {
		p = strchr(parts->host, '?');
		if (p != NULL) {
		    *p = '\0';			/* Terminate host */
		    parts->search = (p + 1);
		}
d174 1
a174 1
**	returns		A pointer to a calloc'd string which MUST BE FREED
d190 1
a190 2
    CTRACE((tfp, "HTParse: aName:`%s'\n", aName));
    CTRACE((tfp, "   relatedName:`%s'\n", relatedName));
d203 1
a203 1
    result = typecallocn(char, len);	/* Lots of space: more than enough */
a262 1
	related.search = NULL;
d286 1
a286 1
		if (p2 != NULL && !isdigit(UCH(p2[1])))
d322 1
a322 1
		} else if (p2 != result) {
a338 17
    **	If host in given or related was ended directly with a '?' (no
    **  slash), fake the search part into absolute.  This is the only
    **  case search is returned from scan.  A host must have been present.
    **  this restores the '?' at which the host part had been truncated in
    **  scan, we have to do this after host part handling is done. - kw
    **
    */
    if (given.search && *(given.search - 1) == '\0') {
	given.absolute = given.search - 1;
	given.absolute[0] = '?';
    } else if (related.search && !related.absolute &&
	       *(related.search - 1) == '\0') {
	related.absolute = related.search - 1;
	related.absolute[0] = '?';
    }

    /*
d374 1
a374 1
	    CTRACE((tfp, "HTParse: (ABS)\n"));
d388 1
a388 1
	    CTRACE((tfp, "HTParse: (Related-ABS)\n"));
d391 1
a391 1
	    CTRACE((tfp, "HTParse: (REL)\n"));
d394 1
a394 1
	    CTRACE((tfp, "HTParse: (Related-REL)\n"));
d403 1
a403 1
	    CTRACE((tfp, "HTParse: (No inheritance)\n"));
d435 1
a435 1
    CTRACE((tfp, "HTParse:      result:%s\n", result));
d461 1
a461 1
	char *,		filename)
d659 1
a659 1
	result = typecallocn(char, 3*levels + strlen(last_slash) + 1);
d667 2
a668 3
    CTRACE((tfp,
	"HTparse: `%s' expressed relative to\n	 `%s' is\n   `%s'.\n",
		aName, relatedName, result));
d672 1
a672 1
/*	Escape undesirable characters using %			HTEscape()
d685 1
a685 1
**	Bit 1		xpalpha		-- as xalpha but with plus.
d708 1
a708 1
	if (!ACCEPTABLE(UCH(TOASCII(*p))))
d710 1
a710 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d730 1
a730 1
**	some characters may be that may be unsafe are unescaped.
d732 1
a732 1
**	represented by a '%' character followed by two hex digits.
d736 1
a736 1
#define UNSAFE(ch) (((ch) <= 32) || ((ch) >= 127))
d746 1
a746 1
	if (UNSAFE(UCH(TOASCII(*p))))
d748 1
a748 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d750 1
a750 1
	outofmem(__FILE__, "HTEscapeUnsafe");
d752 1
a752 1
	unsigned char a = TOASCII(*p);
d754 5
a758 5
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	}
	else *q++ = *p;
d784 1
a784 1
	if (!(*p == ' ' || ACCEPTABLE(UCH(TOASCII(*p)))))
d786 1
a786 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d801 1
a801 1
    *q++ = '\0';			/* Terminate */
d816 1
a816 1
    return (char) ( c >= '0' && c <= '9' ?  c - '0'
d818 1
a818 1
	    : c - 'a' + 10);     /* accept small letters just in case */
d822 1
a822 1
	char *,		str)
d836 2
a837 2
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2]))) {
d840 2
a841 2
		*q = (char) (from_hex(*p++) * 16);
	    if (*p) {
d843 1
a843 1
		** Careful! FROMASCII() may evaluate its arg more than once!
d845 2
a846 3
		*q = (char) (*q + from_hex(*p++));
	    }
	    *q = FROMASCII(*q);
d869 1
a869 1
	char *,		str,
d882 3
a884 4
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2])) &&
	    (testcode = (char) FROMASCII(from_hex(p[1])*16 +
		from_hex(p[2]))) && /* %00 no good*/
d901 1
a901 1
**	Bit 1		xpalpha		-- need \escape if quoted
d942 1
a942 1
    result = typecallocn(char, p-(*str) + added + 1);
@

