head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.33;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.26;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.55;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.25;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.13;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.52;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/* MODULE							HTGroup.c
 *		GROUP FILE ROUTINES
 *
 *	Contains group file parser and routines to match IP
 *	address templates and to find out group membership.
 *
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *
 * HISTORY:
 *
 *
 * BUGS:
 *
 *
 *
 * GROUP DEFINITION GRAMMAR:
 *
 *	string = "sequence of alphanumeric characters"
 *	user_name ::= string
 *	group_name ::= string
 *	group_ref ::= group_name
 *	user_def ::= user_name | group_ref
 *	user_def_list ::= user_def { ',' user_def }
 *	user_part = user_def | '(' user_def_list ')'
 *
 *	templ = "sequence of alphanumeric characters and '*'s"
 *	ip_number_mask ::= templ '.' templ '.' templ '.' templ
 *	domain_name_mask ::= templ { '.' templ }
 *	address ::= ip_number_mask | domain_name_mask
 *	address_def ::= address
 *	address_def_list ::= address_def { ',' address_def }
 *	address_part = address_def | '(' address_def_list ')'
 *
 *	item ::= [user_part] ['@@' address_part]
 *	item_list ::= item { ',' item }
 *	group_def ::= item_list
 *	group_decl ::= group_name ':' group_def
 *
 */

#include <HTUtils.h>

#include <HTAAUtil.h>
#include <HTLex.h>		/* Lexical analysor     */
#include <HTGroup.h>		/* Implemented here     */

#include <LYUtils.h>
#include <LYLeaks.h>

/*
 * Group file parser
 */

typedef HTList UserDefList;
typedef HTList AddressDefList;

typedef struct {
    UserDefList *user_def_list;
    AddressDefList *address_def_list;
} Item;

typedef struct {
    char *name;
    GroupDef *translation;
} Ref;

static void syntax_error(FILE *fp, const char *msg,
			 LexItem lex_item)
{
    char buffer[41];
    int cnt = 0;
    int ch;

    while ((ch = getc(fp)) != EOF && ch != '\n')
	if (cnt < 40)
	    buffer[cnt++] = (char) ch;
    buffer[cnt] = (char) 0;

    CTRACE((tfp, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
	    "HTGroup.c: Syntax error in rule file at line",
	    HTlex_line, buffer, msg, lex_verbose(lex_item)));
    HTlex_line++;
}

static AddressDefList *parse_address_part(FILE *fp)
{
    AddressDefList *address_def_list = NULL;
    LexItem lex_item;
    BOOL only_one = NO;

    lex_item = lex(fp);
    if (lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR)
	only_one = YES;
    else if (lex_item != LEX_OPEN_PAREN ||
	     ((lex_item = lex(fp)) != LEX_ALPH_STR &&
	      lex_item != LEX_TMPL_STR)) {
	syntax_error(fp, "Expecting a single address or '(' beginning list",
		     lex_item);
	return NULL;
    }
    address_def_list = HTList_new();

    for (;;) {
	Ref *ref = typecalloc(Ref);

	if (ref == NULL)
	    outofmem(__FILE__, "parse_address_part");
	ref->name = NULL;
	ref->translation = NULL;
	StrAllocCopy(ref->name, HTlex_buffer);

	HTList_addObject(address_def_list, (void *) ref);

	if (only_one || (lex_item = lex(fp)) != LEX_ITEM_SEP)
	    break;
	/*
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
	do {
	    lex_item = lex(fp);
	} while (lex_item == LEX_REC_SEP);

	if (lex_item != LEX_ALPH_STR && lex_item != LEX_TMPL_STR) {
	    syntax_error(fp, "Expecting an address template", lex_item);
	    HTList_delete(address_def_list);
	    address_def_list = NULL;
	    return NULL;
	}
    }

    if (!only_one && lex_item != LEX_CLOSE_PAREN) {
	HTList_delete(address_def_list);
	address_def_list = NULL;
	syntax_error(fp, "Expecting ')' closing address list", lex_item);
	return NULL;
    }
    return address_def_list;
}

static UserDefList *parse_user_part(FILE *fp)
{
    UserDefList *user_def_list = NULL;
    LexItem lex_item;
    BOOL only_one = NO;

    lex_item = lex(fp);
    if (lex_item == LEX_ALPH_STR)
	only_one = YES;
    else if (lex_item != LEX_OPEN_PAREN ||
	     (lex_item = lex(fp)) != LEX_ALPH_STR) {
	syntax_error(fp, "Expecting a single name or '(' beginning list",
		     lex_item);
	return NULL;
    }
    user_def_list = HTList_new();

    for (;;) {
	Ref *ref = typecalloc(Ref);

	if (ref == NULL)
	    outofmem(__FILE__, "parse_user_part");
	ref->name = NULL;
	ref->translation = NULL;
	StrAllocCopy(ref->name, HTlex_buffer);

	HTList_addObject(user_def_list, (void *) ref);

	if (only_one || (lex_item = lex(fp)) != LEX_ITEM_SEP)
	    break;
	/*
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
	do {
	    lex_item = lex(fp);
	} while (lex_item == LEX_REC_SEP);

	if (lex_item != LEX_ALPH_STR) {
	    syntax_error(fp, "Expecting user or group name", lex_item);
	    HTList_delete(user_def_list);
	    user_def_list = NULL;
	    return NULL;
	}
    }

    if (!only_one && lex_item != LEX_CLOSE_PAREN) {
	HTList_delete(user_def_list);
	user_def_list = NULL;
	syntax_error(fp, "Expecting ')' closing user/group list", lex_item);
	return NULL;
    }
    return user_def_list;
}

static Item *parse_item(FILE *fp)
{
    Item *item = NULL;
    UserDefList *user_def_list = NULL;
    AddressDefList *address_def_list = NULL;
    LexItem lex_item;

    lex_item = lex(fp);
    if (lex_item == LEX_ALPH_STR || lex_item == LEX_OPEN_PAREN) {
	unlex(lex_item);
	user_def_list = parse_user_part(fp);
	lex_item = lex(fp);
    }

    if (lex_item == LEX_AT_SIGN) {
	lex_item = lex(fp);
	if (lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR ||
	    lex_item == LEX_OPEN_PAREN) {
	    unlex(lex_item);
	    address_def_list = parse_address_part(fp);
	} else {
	    if (user_def_list) {
		HTList_delete(user_def_list);	/* @@@@@@@@ */
		user_def_list = NULL;
	    }
	    syntax_error(fp, "Expected address part (single address or list)",
			 lex_item);
	    return NULL;
	}
    } else
	unlex(lex_item);

    if (!user_def_list && !address_def_list) {
	syntax_error(fp, "Empty item not allowed", lex_item);
	return NULL;
    }
    item = typecalloc(Item);
    if (item == NULL)
	outofmem(__FILE__, "parse_item");
    item->user_def_list = user_def_list;
    item->address_def_list = address_def_list;
    return item;
}

static ItemList *parse_item_list(FILE *fp)
{
    ItemList *item_list = HTList_new();
    Item *item;
    LexItem lex_item;

    for (;;) {
	if (!(item = parse_item(fp))) {
	    HTList_delete(item_list);	/* @@@@@@@@ */
	    item_list = NULL;
	    return NULL;
	}
	HTList_addObject(item_list, (void *) item);
	lex_item = lex(fp);
	if (lex_item != LEX_ITEM_SEP) {
	    unlex(lex_item);
	    return item_list;
	}
	/*
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
	do {
	    lex_item = lex(fp);
	} while (lex_item == LEX_REC_SEP);
	unlex(lex_item);
    }
}

GroupDef *HTAA_parseGroupDef(FILE *fp)
{
    ItemList *item_list = NULL;
    GroupDef *group_def = NULL;
    LexItem lex_item;

    if (!(item_list = parse_item_list(fp))) {
	return NULL;
    }
    group_def = typecalloc(GroupDef);
    if (group_def == NULL)
	outofmem(__FILE__, "HTAA_parseGroupDef");
    group_def->group_name = NULL;
    group_def->item_list = item_list;

    if ((lex_item = lex(fp)) != LEX_REC_SEP) {
	syntax_error(fp, "Garbage after group definition", lex_item);
    }

    return group_def;
}

static GroupDef *parse_group_decl(FILE *fp)
{
    char *group_name = NULL;
    GroupDef *group_def = NULL;
    LexItem lex_item;

    do {
	lex_item = lex(fp);
    } while (lex_item == LEX_REC_SEP);	/* Ignore empty lines */

    if (lex_item != LEX_ALPH_STR) {
	if (lex_item != LEX_EOF)
	    syntax_error(fp, "Expecting group name", lex_item);
	return NULL;
    }
    StrAllocCopy(group_name, HTlex_buffer);

    if (LEX_FIELD_SEP != (lex_item = lex(fp))) {
	syntax_error(fp, "Expecting field separator", lex_item);
	FREE(group_name);
	return NULL;
    }

    if (!(group_def = HTAA_parseGroupDef(fp))) {
	FREE(group_name);
	return NULL;
    }
    group_def->group_name = group_name;

    return group_def;
}

/*
 * Group manipulation routines
 */

static GroupDef *find_group_def(GroupDefList *group_list,
				const char *group_name)
{
    if (group_list && group_name) {
	GroupDefList *cur = group_list;
	GroupDef *group_def;

	while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur))) {
	    if (!strcmp(group_name, group_def->group_name)) {
		return group_def;
	    }
	}
    }
    return NULL;
}

void HTAA_resolveGroupReferences(GroupDef *group_def,
				 GroupDefList *group_def_list)
{
    if (group_def && group_def->item_list && group_def_list) {
	ItemList *cur1 = group_def->item_list;
	Item *item;

	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
	    UserDefList *cur2 = item->user_def_list;
	    Ref *ref;

	    while (NULL != (ref = (Ref *) HTList_nextObject(cur2)))
		ref->translation = find_group_def(group_def_list, ref->name);

	    /* Does NOT translate address_def_list */
	}
    }
}

static void add_group_def(GroupDefList *group_def_list,
			  GroupDef *group_def)
{
    HTAA_resolveGroupReferences(group_def, group_def_list);
    HTList_addObject(group_def_list, (void *) group_def);
}

static GroupDefList *parse_group_file(FILE *fp)
{
    GroupDefList *group_def_list = HTList_new();
    GroupDef *group_def;

    while (NULL != (group_def = parse_group_decl(fp)))
	add_group_def(group_def_list, group_def);

    return group_def_list;
}

/*
 * Trace functions
 */

static void print_item(Item *item)
{
    if (!item)
	fprintf(tfp, "\tNULL-ITEM\n");
    else {
	UserDefList *cur1 = item->user_def_list;
	AddressDefList *cur2 = item->address_def_list;
	Ref *user_ref = (Ref *) HTList_nextObject(cur1);
	Ref *addr_ref = (Ref *) HTList_nextObject(cur2);

	if (user_ref) {
	    fprintf(tfp, "\t[%s%s", user_ref->name,
		    (user_ref->translation ? "*REF*" : ""));
	    while (NULL != (user_ref = (Ref *) HTList_nextObject(cur1)))
		fprintf(tfp, "; %s%s", user_ref->name,
			(user_ref->translation ? "*REF*" : ""));
	    fprintf(tfp, "] ");
	} else
	    fprintf(tfp, "\tANYBODY ");

	if (addr_ref) {
	    fprintf(tfp, "@@ [%s", addr_ref->name);
	    while (NULL != (addr_ref = (Ref *) HTList_nextObject(cur2)))
		fprintf(tfp, "; %s", addr_ref->name);
	    fprintf(tfp, "]\n");
	} else
	    fprintf(tfp, "@@ ANYADDRESS\n");
    }
}

static void print_item_list(ItemList *item_list)
{
    ItemList *cur = item_list;
    Item *item;

    if (!item_list)
	fprintf(tfp, "EMPTY");
    else
	while (NULL != (item = (Item *) HTList_nextObject(cur)))
	    print_item(item);
}

void HTAA_printGroupDef(GroupDef *group_def)
{
    if (!group_def) {
	fprintf(tfp, "\nNULL RECORD\n");
	return;
    }

    fprintf(tfp, "\nGroup %s:\n",
	    (group_def->group_name ? group_def->group_name : "NULL"));

    print_item_list(group_def->item_list);
    fprintf(tfp, "\n");
}

static void print_group_def_list(GroupDefList *group_list)
{
    GroupDefList *cur = group_list;
    GroupDef *group_def;

    while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur)))
	HTAA_printGroupDef(group_def);
}

/*
 * IP address template matching
 */

/* static						part_match()
 *		MATCH ONE PART OF INET ADDRESS AGAIST
 *		A PART OF MASK (inet address has 4 parts)
 * ON ENTRY:
 *	tcur	pointer to the beginning of template part.
 *	icur	pointer to the beginning of actual inet
 *		number part.
 *
 * ON EXIT:
 *	returns	YES, if match.
 */
static BOOL part_match(const char *tcur,
		       const char *icur)
{
    char required[4];
    char actual[4];
    const char *cur;
    int cnt;
    BOOL status;

    if (!tcur || !icur)
	return NO;

    cur = tcur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
	required[cnt++] = *(cur++);
    required[cnt] = (char) 0;

    cur = icur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
	actual[cnt++] = *(cur++);
    actual[cnt] = (char) 0;

    status = HTAA_templateMatch(required, actual);
    CTRACE((tfp, "part_match: req: '%s' act: '%s' match: %s\n",
	    required, actual, (status ? "yes" : "no")));

    return status;
}

/* static						ip_number_match()
 *		MATCH INET NUMBER AGAINST AN INET NUMBER MASK
 * ON ENTRY:
 *	template	mask to match agaist, e.g., 128.141.*.*
 *	the_inet_addr	actual inet address, e.g., 128.141.201.74
 *
 * ON EXIT:
 *	returns		YES, if match;  NO, if not.
 */
static BOOL ip_number_match(const char *ctemplate,
			    const char *the_inet_addr)
{
    const char *tcur = ctemplate;
    const char *icur = the_inet_addr;
    int cnt;

    for (cnt = 0; cnt < 4; cnt++) {
	if (!tcur || !icur || !part_match(tcur, icur))
	    return NO;
	if (NULL != (tcur = strchr(tcur, '.')))
	    tcur++;
	if (NULL != (icur = strchr(icur, '.')))
	    icur++;
    }
    return YES;
}

/* static						is_domain_mask()
 *		DETERMINE IF A GIVEN MASK IS A
 *		DOMAIN NAME MASK OR AN INET NUMBER MASK
 * ON ENTRY:
 *	mask	either a domain name mask,
 *		e.g.
 *			*.cern.ch
 *
 *		or an inet number mask,
 *		e.g.
 *			128.141.*.*
 *
 * ON EXIT:
 *	returns	YES, if mask is a domain name mask.
 *		NO, if it is an inet number mask.
 */
static BOOL is_domain_mask(const char *mask)
{
    const char *cur = mask;

    if (!mask)
	return NO;

    while (*cur) {
	if (*cur != '.' && *cur != '*' && (*cur < '0' || *cur > '9'))
	    return YES;		/* Even one non-digit makes it a domain name mask */
	cur++;
    }
    return NO;			/* All digits and dots, so it is an inet number mask */
}

/* static							ip_mask_match()
 *		MATCH AN IP NUMBER MASK OR IP NAME MASK
 *		AGAINST ACTUAL IP NUMBER OR IP NAME
 *
 * ON ENTRY:
 *	mask		mask.  Mask may be either an inet number
 *			mask or a domain name mask,
 *			e.g.
 *				128.141.*.*
 *			or
 *				*.cern.ch
 *
 *	ip_number	IP number of connecting host.
 *	ip_name		IP name of the connecting host.
 *
 * ON EXIT:
 *	returns		YES, if hostname/internet number
 *			matches the mask.
 *			NO, if no match (no fire).
 */
static BOOL ip_mask_match(const char *mask,
			  const char *ip_number,
			  const char *ip_name)
{
    if (mask && (ip_number || ip_name)) {
	if (is_domain_mask(mask)) {
	    if (HTAA_templateMatch(mask, ip_name))
		return YES;
	} else {
	    if (ip_number_match(mask, ip_number))
		return YES;
	}
    }
    return NO;
}

static BOOL ip_in_def_list(AddressDefList *address_def_list,
			   char *ip_number,
			   char *ip_name)
{
    if (address_def_list && (ip_number || ip_name)) {
	AddressDefList *cur = address_def_list;
	Ref *ref;

	while (NULL != (ref = (Ref *) HTList_nextObject(cur))) {
	    /* Value of ref->translation is ignored, i.e., */
	    /* no recursion for ip address tamplates.     */
	    if (ip_mask_match(ref->name, ip_number, ip_name))
		return YES;
	}
    }
    return NO;
}

/*
 * Group file cached reading
 */

typedef struct {
    char *group_filename;
    GroupDefList *group_list;
} GroupCache;

typedef HTList GroupCacheList;

static GroupCacheList *group_cache_list = NULL;

GroupDefList *HTAA_readGroupFile(const char *filename)
{
    FILE *fp;
    GroupCache *group_cache;

    if (isEmpty(filename))
	return NULL;

    if (!group_cache_list)
	group_cache_list = HTList_new();
    else {
	GroupCacheList *cur = group_cache_list;

	while (NULL != (group_cache = (GroupCache *) HTList_nextObject(cur))) {
	    if (!strcmp(filename, group_cache->group_filename)) {
		CTRACE((tfp, "%s '%s' %s\n",
			"HTAA_readGroupFile: group file",
			filename, "already found in cache"));
		return group_cache->group_list;
	    }			/* if cache match */
	}			/* while cached files remain */
    }				/* cache exists */

    CTRACE((tfp, "HTAA_readGroupFile: reading group file `%s'\n",
	    filename));

    if (!(fp = fopen(filename, TXT_R))) {
	CTRACE((tfp, "%s '%s'\n",
		"HTAA_readGroupFile: unable to open group file",
		filename));
	return NULL;
    }

    if ((group_cache = typecalloc(GroupCache)) == 0)
	outofmem(__FILE__, "HTAA_readGroupFile");

    group_cache->group_filename = NULL;
    StrAllocCopy(group_cache->group_filename, filename);
    group_cache->group_list = parse_group_file(fp);
    HTList_addObject(group_cache_list, (void *) group_cache);
    fclose(fp);

    CTRACE((tfp, "Read group file '%s', results follow:\n", filename));
    if (TRACE)
	print_group_def_list(group_cache->group_list);

    return group_cache->group_list;
}

/* PUBLIC					HTAA_userAndInetInGroup()
 *		CHECK IF USER BELONGS TO TO A GIVEN GROUP
 *		AND THAT THE CONNECTION COMES FROM AN
 *		ADDRESS THAT IS ALLOWED BY THAT GROUP
 * ON ENTRY:
 *	group		the group definition structure.
 *	username	connecting user.
 *	ip_number	browser host IP number, optional.
 *	ip_name		browser host IP name, optional.
 *			However, one of ip_number or ip_name
 *			must be given.
 * ON EXIT:
 *	returns		HTAA_IP_MASK, if IP address mask was
 *			reason for failing.
 *			HTAA_NOT_MEMBER, if user does not belong
 *			to the group.
 *			HTAA_OK if both IP address and user are ok.
 */
HTAAFailReasonType HTAA_userAndInetInGroup(GroupDef *group,
					   char *username,
					   char *ip_number,
					   char *ip_name)
{
    HTAAFailReasonType reason = HTAA_NOT_MEMBER;

    if (group && username) {
	ItemList *cur1 = group->item_list;
	Item *item;

	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
	    if (!item->address_def_list ||	/* Any address allowed */
		ip_in_def_list(item->address_def_list, ip_number, ip_name)) {

		if (!item->user_def_list)	/* Any user allowed */
		    return HTAA_OK;
		else {
		    UserDefList *cur2 = item->user_def_list;
		    Ref *ref;

		    while (NULL != (ref = (Ref *) HTList_nextObject(cur2))) {

			if (ref->translation) {		/* Group, check recursively */
			    reason = HTAA_userAndInetInGroup(ref->translation,
							     username,
							     ip_number, ip_name);
			    if (reason == HTAA_OK)
				return HTAA_OK;
			} else {	/* Username, check directly */
			    if (username && *username &&
				0 == strcmp(ref->name, username))
				return HTAA_OK;
			}
			/* Every user/group name in this group */
		    }
		    /* search for username */
		}
		/* IP address ok */
	    } else {
		reason = HTAA_IP_MASK;
	    }
	}			/* while items in group */
    }
    /* valid parameters */
    return reason;		/* No match, or invalid parameters */
}

void GroupDef_delete(GroupDef *group_def)
{
    if (group_def) {
	FREE(group_def->group_name);
	if (group_def->item_list) {
	    HTList_delete(group_def->item_list);	/* @@@@@@@@ */
	    group_def->item_list = NULL;
	}
	FREE(group_def);
    }
}
@


1.5
log
@automatic merge of lynx-current
@
text
@d69 1
a69 1
static void syntax_error(FILE *fp, char *msg,
d509 1
a509 1
static BOOL ip_number_match(const char *template,
d512 1
a512 1
    const char *tcur = template;
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@a0 1

d2 40
a41 41
**		GROUP FILE ROUTINES
**
**	Contains group file parser and routines to match IP
**	address templates and to find out group membership.
**
**
** AUTHORS:
**	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
**
** HISTORY:
**
**
** BUGS:
**
**
**
** GROUP DEFINITION GRAMMAR:
**
**	string = "sequence of alphanumeric characters"
**	user_name ::= string
**	group_name ::= string
**	group_ref ::= group_name
**	user_def ::= user_name | group_ref
**	user_def_list ::= user_def { ',' user_def }
**	user_part = user_def | '(' user_def_list ')'
**
**	templ = "sequence of alphanumeric characters and '*'s"
**	ip_number_mask ::= templ '.' templ '.' templ '.' templ
**	domain_name_mask ::= templ { '.' templ }
**	address ::= ip_number_mask | domain_name_mask
**	address_def ::= address
**	address_def_list ::= address_def { ',' address_def }
**	address_part = address_def | '(' address_def_list ')'
**
**	item ::= [user_part] ['@@' address_part]
**	item_list ::= item { ',' item }
**	group_def ::= item_list
**	group_decl ::= group_name ':' group_def
**
*/

d46 2
a47 2
#include <HTLex.h>	/* Lexical analysor	*/
#include <HTGroup.h>	/* Implemented here	*/
d53 2
a54 2
** Group file parser
*/
d60 2
a61 2
    UserDefList *	user_def_list;
    AddressDefList *	address_def_list;
d65 2
a66 2
    char *	name;
    GroupDef *	translation;
d69 2
a70 5


static void syntax_error (FILE *	 fp,
				char *	 msg,
				LexItem lex_item)
d76 4
a79 3
    while ((ch = getc(fp)) != EOF  &&  ch != '\n')
	if (cnt < 40) buffer[cnt++] = (char) ch;
    buffer[cnt] = (char)0;
d82 2
a83 2
		"HTGroup.c: Syntax error in rule file at line",
		HTlex_line, buffer, msg, lex_verbose(lex_item)));
d87 1
a87 2

static AddressDefList *parse_address_part (FILE *  fp)
d96 1
a96 1
    else if (lex_item != LEX_OPEN_PAREN  ||
d105 1
a105 1
    for(;;) {
d107 1
d114 1
a114 1
	HTList_addObject(address_def_list, (void*)ref);
d119 4
a122 4
	** Here lex_item == LEX_ITEM_SEP; after item separator it
	** is ok to have one or more newlines (LEX_REC_SEP) and
	** they are ignored (continuation line).
	*/
d144 1
a144 2

static UserDefList *parse_user_part (FILE *  fp)
d153 1
a153 1
    else if (lex_item != LEX_OPEN_PAREN  ||
d163 1
d170 1
a170 1
	HTList_addObject(user_def_list, (void*)ref);
d175 4
a178 4
	** Here lex_item == LEX_ITEM_SEP; after item separator it
	** is ok to have one or more newlines (LEX_REC_SEP) and
	** they are ignored (continuation line).
	*/
d200 1
a200 2

static Item *parse_item (FILE *  fp)
d220 1
a220 2
	}
	else {
d229 2
a230 2
    }
    else unlex(lex_item);
d244 1
a244 2

static ItemList *parse_item_list (FILE *  fp)
d250 1
a250 1
    for(;;) {
d256 1
a256 1
	HTList_addObject(item_list, (void*)item);
d263 4
a266 4
	** Here lex_item == LEX_ITEM_SEP; after item separator it
	** is ok to have one or more newlines (LEX_REC_SEP) and
	** they are ignored (continuation line).
	*/
d274 1
a274 2

GroupDef *HTAA_parseGroupDef (FILE *  fp)
d296 1
a296 2

static GroupDef *parse_group_decl (FILE *  fp)
a327 2


d329 2
a330 2
** Group manipulation routines
*/
d332 2
a333 2
static GroupDef *find_group_def (GroupDefList *	group_list,
				       const char *	group_name)
d339 1
a339 1
	while (NULL != (group_def = (GroupDef*)HTList_nextObject(cur))) {
d348 2
a349 3

void HTAA_resolveGroupReferences (GroupDef *	group_def,
					      GroupDefList *	group_def_list)
d355 1
a355 1
	while (NULL != (item = (Item*)HTList_nextObject(cur1))) {
d359 1
a359 1
	    while (NULL != (ref = (Ref*)HTList_nextObject(cur2)))
d367 2
a368 3

static void add_group_def (GroupDefList * group_def_list,
				 GroupDef *	 group_def)
d371 1
a371 1
    HTList_addObject(group_def_list, (void*)group_def);
d374 1
a374 2

static GroupDefList *parse_group_file (FILE *  fp)
a384 1

d386 2
a387 2
** Trace functions
*/
d389 1
a389 1
static void print_item (Item *  item)
d396 2
a397 2
	Ref *user_ref = (Ref*)HTList_nextObject(cur1);
	Ref *addr_ref = (Ref*)HTList_nextObject(cur2);
d402 1
a402 1
	    while (NULL != (user_ref = (Ref*)HTList_nextObject(cur1)))
d406 2
a407 1
	} else fprintf(tfp, "\tANYBODY ");
d411 1
a411 1
	    while (NULL != (addr_ref = (Ref*)HTList_nextObject(cur2)))
d414 2
a415 1
	} else fprintf(tfp, "@@ ANYADDRESS\n");
d419 1
a419 2

static void print_item_list (ItemList *  item_list)
d426 3
a428 2
    else while (NULL != (item = (Item*)HTList_nextObject(cur)))
	print_item(item);
d431 1
a431 2

void HTAA_printGroupDef (GroupDef *  group_def)
d445 1
a445 2

static void print_group_def_list (GroupDefList *  group_list)
d450 1
a450 1
    while (NULL != (group_def = (GroupDef*)HTList_nextObject(cur)))
a453 2


d455 2
a456 2
** IP address template matching
*/
d459 12
a470 12
**		MATCH ONE PART OF INET ADDRESS AGAIST
**		A PART OF MASK (inet address has 4 parts)
** ON ENTRY:
**	tcur	pointer to the beginning of template part.
**	icur	pointer to the beginning of actual inet
**		number part.
**
** ON EXIT:
**	returns	YES, if match.
*/
static BOOL part_match (const char * tcur,
			      const char * icur)
d478 2
a479 1
    if (!tcur || !icur) return NO;
d481 3
a483 3
    cur=tcur;
    cnt=0;
    while (cnt < 3  &&  *cur && *cur != '.')
d485 1
a485 1
    required[cnt] = (char)0;
d487 3
a489 3
    cur=icur;
    cnt=0;
    while (cnt < 3  &&  *cur && *cur != '.')
d491 1
a491 1
    actual[cnt] = (char)0;
d495 1
a495 1
		required, actual, (status ? "yes" : "no")));
a499 2


d501 10
a510 10
**		MATCH INET NUMBER AGAINST AN INET NUMBER MASK
** ON ENTRY:
**	template	mask to match agaist, e.g., 128.141.*.*
**	the_inet_addr	actual inet address, e.g., 128.141.201.74
**
** ON EXIT:
**	returns		YES, if match;  NO, if not.
*/
static BOOL ip_number_match (const char *	template,
				   const char *	the_inet_addr)
d516 1
a516 1
    for (cnt=0; cnt<4; cnt++) {
d519 4
a522 2
	if (NULL != (tcur = strchr(tcur, '.'))) tcur++;
	if (NULL != (icur = strchr(icur, '.'))) icur++;
a526 2


d528 16
a543 16
**		DETERMINE IF A GIVEN MASK IS A
**		DOMAIN NAME MASK OR AN INET NUMBER MASK
** ON ENTRY:
**	mask	either a domain name mask,
**		e.g.
**			*.cern.ch
**
**		or an inet number mask,
**		e.g.
**			128.141.*.*
**
** ON EXIT:
**	returns	YES, if mask is a domain name mask.
**		NO, if it is an inet number mask.
*/
static BOOL is_domain_mask (const char * 	mask)
d547 2
a548 1
    if (!mask) return NO;
d551 2
a552 2
	if (*cur != '.'  &&  *cur != '*'  &&  (*cur < '0' || *cur > '9'))
	    return YES;	/* Even one non-digit makes it a domain name mask */
d555 1
a555 1
    return NO;	/* All digits and dots, so it is an inet number mask */
a557 2


d559 22
a580 22
**		MATCH AN IP NUMBER MASK OR IP NAME MASK
**		AGAINST ACTUAL IP NUMBER OR IP NAME
**
** ON ENTRY:
**	mask		mask.  Mask may be either an inet number
**			mask or a domain name mask,
**			e.g.
**				128.141.*.*
**			or
**				*.cern.ch
**
**	ip_number	IP number of connecting host.
**	ip_name		IP name of the connecting host.
**
** ON EXIT:
**	returns		YES, if hostname/internet number
**			matches the mask.
**			NO, if no match (no fire).
*/
static BOOL ip_mask_match (const char *	mask,
				 const char *	ip_number,
				 const char *	ip_name)
d586 1
a586 2
	}
	else {
d594 3
a596 6



static BOOL ip_in_def_list (AddressDefList *	address_def_list,
				  char *		ip_number,
				  char *		ip_name)
d602 1
a602 1
	while (NULL != (ref = (Ref*)HTList_nextObject(cur))) {
d604 1
a604 1
	    /* no recursion for ip address tamplates.	  */
a611 1

d613 2
a614 2
** Group file cached reading
*/
d617 2
a618 2
    char *	   group_filename;
    GroupDefList * group_list;
d625 1
a625 2

GroupDefList *HTAA_readGroupFile (const char *  filename)
d630 2
a631 1
    if (isEmpty(filename)) return NULL;
d638 1
a638 1
	while (NULL != (group_cache = (GroupCache*)HTList_nextObject(cur))) {
d641 2
a642 2
			    "HTAA_readGroupFile: group file",
			    filename, "already found in cache"));
d644 3
a646 3
	    } /* if cache match */
	} /* while cached files remain */
    } /* cache exists */
d649 1
a649 1
		filename));
d653 2
a654 2
		    "HTAA_readGroupFile: unable to open group file",
		    filename));
d664 1
a664 1
    HTList_addObject(group_cache_list, (void*)group_cache);
a673 1

d675 21
a695 21
**		CHECK IF USER BELONGS TO TO A GIVEN GROUP
**		AND THAT THE CONNECTION COMES FROM AN
**		ADDRESS THAT IS ALLOWED BY THAT GROUP
** ON ENTRY:
**	group		the group definition structure.
**	username	connecting user.
**	ip_number	browser host IP number, optional.
**	ip_name		browser host IP name, optional.
**			However, one of ip_number or ip_name
**			must be given.
** ON EXIT:
**	returns		HTAA_IP_MASK, if IP address mask was
**			reason for failing.
**			HTAA_NOT_MEMBER, if user does not belong
**			to the group.
**			HTAA_OK if both IP address and user are ok.
*/
HTAAFailReasonType HTAA_userAndInetInGroup (GroupDef * group,
							char *	    username,
							char *	    ip_number,
							char *	    ip_name)
d703 1
a703 1
	while (NULL != (item = (Item*)HTList_nextObject(cur1))) {
d713 1
a713 1
		    while (NULL != (ref = (Ref*)HTList_nextObject(cur2))) {
d715 1
a715 1
			if (ref->translation) {	/* Group, check recursively */
d718 1
a718 1
							     ip_number,ip_name);
d721 1
a721 2
			}
			else {	/* Username, check directly */
d723 1
a723 1
				0==strcmp(ref->name, username))
d726 6
a731 4
		    } /* Every user/group name in this group */
		} /* search for username */
	    } /* IP address ok */
	    else {
d734 3
a736 3
	} /* while items in group */
    } /* valid parameters */

d740 1
a740 2

void GroupDef_delete (GroupDef *  group_def)
a750 1

@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d73 3
a75 3
PRIVATE void syntax_error ARGS3(FILE *,	 fp,
				char *,	 msg,
				LexItem, lex_item)
d92 1
a92 1
PRIVATE AddressDefList *parse_address_part ARGS1(FILE *, fp)
d149 1
a149 1
PRIVATE UserDefList *parse_user_part ARGS1(FILE *, fp)
d205 1
a205 1
PRIVATE Item *parse_item ARGS1(FILE *, fp)
d251 1
a251 1
PRIVATE ItemList *parse_item_list ARGS1(FILE *, fp)
d282 1
a282 1
PUBLIC GroupDef *HTAA_parseGroupDef ARGS1(FILE *, fp)
d305 1
a305 1
PRIVATE GroupDef *parse_group_decl ARGS1(FILE *, fp)
d343 2
a344 2
PRIVATE GroupDef *find_group_def ARGS2(GroupDefList *,	group_list,
				       CONST char *,	group_name)
d360 2
a361 2
PUBLIC void HTAA_resolveGroupReferences ARGS2(GroupDef *,	group_def,
					      GroupDefList *,	group_def_list)
d380 2
a381 2
PRIVATE void add_group_def ARGS2(GroupDefList *, group_def_list,
				 GroupDef *,	 group_def)
d388 1
a388 1
PRIVATE GroupDefList *parse_group_file ARGS1(FILE *, fp)
d404 1
a404 1
PRIVATE void print_item ARGS1(Item *, item)
d433 1
a433 1
PRIVATE void print_item_list ARGS1(ItemList *, item_list)
d445 1
a445 1
PUBLIC void HTAA_printGroupDef ARGS1(GroupDef *, group_def)
d460 1
a460 1
PRIVATE void print_group_def_list ARGS1(GroupDefList *, group_list)
d475 1
a475 1
/* PRIVATE						part_match()
d486 2
a487 2
PRIVATE BOOL part_match ARGS2(CONST char *, tcur,
			      CONST char *, icur)
d491 1
a491 1
    CONST char *cur;
d518 1
a518 1
/* PRIVATE						ip_number_match()
d527 2
a528 2
PRIVATE BOOL ip_number_match ARGS2(CONST char *,	template,
				   CONST char *,	the_inet_addr)
d530 2
a531 2
    CONST char *tcur = template;
    CONST char *icur = the_inet_addr;
d545 1
a545 1
/* PRIVATE						is_domain_mask()
d561 1
a561 1
PRIVATE BOOL is_domain_mask ARGS1(CONST char *,	mask)
d563 1
a563 1
    CONST char *cur = mask;
d577 1
a577 1
/* PRIVATE							ip_mask_match()
d597 3
a599 3
PRIVATE BOOL ip_mask_match ARGS3(CONST char *,	mask,
				 CONST char *,	ip_number,
				 CONST char *,	ip_name)
d617 3
a619 3
PRIVATE BOOL ip_in_def_list ARGS3(AddressDefList *,	address_def_list,
				  char *,		ip_number,
				  char *,		ip_name)
d647 1
a647 1
PRIVATE GroupCacheList *group_cache_list = NULL;
d650 1
a650 1
PUBLIC GroupDefList *HTAA_readGroupFile ARGS1(CONST char *, filename)
d717 4
a720 4
PUBLIC HTAAFailReasonType HTAA_userAndInetInGroup ARGS4(GroupDef *, group,
							char *,	    username,
							char *,	    ip_number,
							char *,	    ip_name)
d765 1
a765 1
PUBLIC void GroupDef_delete ARGS1(GroupDef *, group_def)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d51 1
d82 1
a82 1
	if (cnt < 40) buffer[cnt++] = ch;
d85 1
a85 1
    CTRACE(tfp, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
d87 1
a87 1
		HTlex_line, buffer, msg, lex_verbose(lex_item));
d111 1
a111 1
	Ref *ref = (Ref*)calloc(1, sizeof(Ref));
d167 1
a167 1
	Ref *ref = (Ref*)calloc(1, sizeof(Ref));
d242 1
a242 1
    item = (Item*)calloc(1, sizeof(Item));
d291 1
a291 1
    group_def = (GroupDef*)calloc(1, sizeof(GroupDef));
d510 2
a511 2
    CTRACE(tfp, "part_match: req: '%s' act: '%s' match: %s\n",
		required, actual, (status ? "yes" : "no"));
d655 1
a655 1
    if (!filename || !*filename) return NULL;
d664 1
a664 1
		CTRACE(tfp, "%s '%s' %s\n",
d666 1
a666 1
			    filename, "already found in cache");
d672 2
a673 2
    CTRACE(tfp, "HTAA_readGroupFile: reading group file `%s'\n",
		filename);
d675 2
a676 2
    if (!(fp = fopen(filename, "r"))) {
	CTRACE(tfp, "%s '%s'\n",
d678 1
a678 1
		    filename);
d682 1
a682 1
    if (!(group_cache = (GroupCache*)calloc(1, sizeof(GroupCache))))
d691 1
a691 1
    CTRACE(tfp, "Read group file '%s', results follow:\n", filename);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d1 1
d3 41
a43 40
 *		GROUP FILE ROUTINES
 *
 *	Contains group file parser and routines to match IP
 *	address templates and to find out group membership.
 *
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *
 * HISTORY:
 *
 *
 * BUGS:
 *
 *
 *
 * GROUP DEFINITION GRAMMAR:
 *
 *	string = "sequence of alphanumeric characters"
 *	user_name ::= string
 *	group_name ::= string
 *	group_ref ::= group_name
 *	user_def ::= user_name | group_ref
 *	user_def_list ::= user_def { ',' user_def }
 *	user_part = user_def | '(' user_def_list ')'
 *
 *	templ = "sequence of alphanumeric characters and '*'s"
 *	ip_number_mask ::= templ '.' templ '.' templ '.' templ
 *	domain_name_mask ::= templ { '.' templ }
 *	address ::= ip_number_mask | domain_name_mask
 *	address_def ::= address
 *	address_def_list ::= address_def { ',' address_def }
 *	address_part = address_def | '(' address_def_list ')'
 *
 *	item ::= [user_part] ['@@' address_part]
 *	item_list ::= item { ',' item }
 *	group_def ::= item_list
 *	group_decl ::= group_name ':' group_def
 *
 */
d48 2
a49 2
#include <HTLex.h>		/* Lexical analysor     */
#include <HTGroup.h>		/* Implemented here     */
a50 1
#include <LYUtils.h>
d54 2
a55 2
 * Group file parser
 */
d61 2
a62 2
    UserDefList *user_def_list;
    AddressDefList *address_def_list;
d66 2
a67 2
    char *name;
    GroupDef *translation;
d70 5
a74 2
static void syntax_error(FILE *fp, const char *msg,
			 LexItem lex_item)
d80 7
a86 8
    while ((ch = getc(fp)) != EOF && ch != '\n')
	if (cnt < 40)
	    buffer[cnt++] = (char) ch;
    buffer[cnt] = (char) 0;

    CTRACE((tfp, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
	    "HTGroup.c: Syntax error in rule file at line",
	    HTlex_line, buffer, msg, lex_verbose(lex_item)));
d90 2
a91 1
static AddressDefList *parse_address_part(FILE *fp)
d100 1
a100 1
    else if (lex_item != LEX_OPEN_PAREN ||
d109 2
a110 3
    for (;;) {
	Ref *ref = typecalloc(Ref);

d117 1
a117 1
	HTList_addObject(address_def_list, (void *) ref);
d122 4
a125 4
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
d147 2
a148 1
static UserDefList *parse_user_part(FILE *fp)
d157 1
a157 1
    else if (lex_item != LEX_OPEN_PAREN ||
d166 1
a166 2
	Ref *ref = typecalloc(Ref);

d173 1
a173 1
	HTList_addObject(user_def_list, (void *) ref);
d178 4
a181 4
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
d203 2
a204 1
static Item *parse_item(FILE *fp)
d224 2
a225 1
	} else {
d234 2
a235 2
    } else
	unlex(lex_item);
d241 1
a241 1
    item = typecalloc(Item);
d249 2
a250 1
static ItemList *parse_item_list(FILE *fp)
d256 1
a256 1
    for (;;) {
d262 1
a262 1
	HTList_addObject(item_list, (void *) item);
d269 4
a272 4
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
d280 2
a281 1
GroupDef *HTAA_parseGroupDef(FILE *fp)
d290 1
a290 1
    group_def = typecalloc(GroupDef);
d303 2
a304 1
static GroupDef *parse_group_decl(FILE *fp)
d336 2
d339 2
a340 2
 * Group manipulation routines
 */
d342 2
a343 2
static GroupDef *find_group_def(GroupDefList *group_list,
				const char *group_name)
d349 1
a349 1
	while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur))) {
d358 3
a360 2
void HTAA_resolveGroupReferences(GroupDef *group_def,
				 GroupDefList *group_def_list)
d366 1
a366 1
	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
d370 1
a370 1
	    while (NULL != (ref = (Ref *) HTList_nextObject(cur2)))
d378 3
a380 2
static void add_group_def(GroupDefList *group_def_list,
			  GroupDef *group_def)
d383 1
a383 1
    HTList_addObject(group_def_list, (void *) group_def);
d386 2
a387 1
static GroupDefList *parse_group_file(FILE *fp)
d398 1
d400 2
a401 2
 * Trace functions
 */
d403 1
a403 1
static void print_item(Item *item)
d410 2
a411 2
	Ref *user_ref = (Ref *) HTList_nextObject(cur1);
	Ref *addr_ref = (Ref *) HTList_nextObject(cur2);
d416 1
a416 1
	    while (NULL != (user_ref = (Ref *) HTList_nextObject(cur1)))
d420 1
a420 2
	} else
	    fprintf(tfp, "\tANYBODY ");
d424 1
a424 1
	    while (NULL != (addr_ref = (Ref *) HTList_nextObject(cur2)))
d427 1
a427 2
	} else
	    fprintf(tfp, "@@ ANYADDRESS\n");
d431 2
a432 1
static void print_item_list(ItemList *item_list)
d439 2
a440 3
    else
	while (NULL != (item = (Item *) HTList_nextObject(cur)))
	    print_item(item);
d443 2
a444 1
void HTAA_printGroupDef(GroupDef *group_def)
d458 2
a459 1
static void print_group_def_list(GroupDefList *group_list)
d464 1
a464 1
    while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur)))
d468 2
d471 2
a472 2
 * IP address template matching
 */
d474 13
a486 13
/* static						part_match()
 *		MATCH ONE PART OF INET ADDRESS AGAIST
 *		A PART OF MASK (inet address has 4 parts)
 * ON ENTRY:
 *	tcur	pointer to the beginning of template part.
 *	icur	pointer to the beginning of actual inet
 *		number part.
 *
 * ON EXIT:
 *	returns	YES, if match.
 */
static BOOL part_match(const char *tcur,
		       const char *icur)
d490 1
a490 1
    const char *cur;
d494 1
a494 2
    if (!tcur || !icur)
	return NO;
d496 3
a498 3
    cur = tcur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
d500 1
a500 1
    required[cnt] = (char) 0;
d502 3
a504 3
    cur = icur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
d506 1
a506 1
    actual[cnt] = (char) 0;
d509 2
a510 2
    CTRACE((tfp, "part_match: req: '%s' act: '%s' match: %s\n",
	    required, actual, (status ? "yes" : "no")));
d515 13
a527 11
/* static						ip_number_match()
 *		MATCH INET NUMBER AGAINST AN INET NUMBER MASK
 * ON ENTRY:
 *	template	mask to match agaist, e.g., 128.141.*.*
 *	the_inet_addr	actual inet address, e.g., 128.141.201.74
 *
 * ON EXIT:
 *	returns		YES, if match;  NO, if not.
 */
static BOOL ip_number_match(const char *ctemplate,
			    const char *the_inet_addr)
d529 2
a530 2
    const char *tcur = ctemplate;
    const char *icur = the_inet_addr;
d533 1
a533 1
    for (cnt = 0; cnt < 4; cnt++) {
d536 2
a537 4
	if (NULL != (tcur = strchr(tcur, '.')))
	    tcur++;
	if (NULL != (icur = strchr(icur, '.')))
	    icur++;
d542 19
a560 17
/* static						is_domain_mask()
 *		DETERMINE IF A GIVEN MASK IS A
 *		DOMAIN NAME MASK OR AN INET NUMBER MASK
 * ON ENTRY:
 *	mask	either a domain name mask,
 *		e.g.
 *			*.cern.ch
 *
 *		or an inet number mask,
 *		e.g.
 *			128.141.*.*
 *
 * ON EXIT:
 *	returns	YES, if mask is a domain name mask.
 *		NO, if it is an inet number mask.
 */
static BOOL is_domain_mask(const char *mask)
d562 1
a562 1
    const char *cur = mask;
d564 1
a564 2
    if (!mask)
	return NO;
d567 2
a568 2
	if (*cur != '.' && *cur != '*' && (*cur < '0' || *cur > '9'))
	    return YES;		/* Even one non-digit makes it a domain name mask */
d571 1
a571 1
    return NO;			/* All digits and dots, so it is an inet number mask */
d574 25
a598 23
/* static							ip_mask_match()
 *		MATCH AN IP NUMBER MASK OR IP NAME MASK
 *		AGAINST ACTUAL IP NUMBER OR IP NAME
 *
 * ON ENTRY:
 *	mask		mask.  Mask may be either an inet number
 *			mask or a domain name mask,
 *			e.g.
 *				128.141.*.*
 *			or
 *				*.cern.ch
 *
 *	ip_number	IP number of connecting host.
 *	ip_name		IP name of the connecting host.
 *
 * ON EXIT:
 *	returns		YES, if hostname/internet number
 *			matches the mask.
 *			NO, if no match (no fire).
 */
static BOOL ip_mask_match(const char *mask,
			  const char *ip_number,
			  const char *ip_name)
d604 2
a605 1
	} else {
d613 6
a618 3
static BOOL ip_in_def_list(AddressDefList *address_def_list,
			   char *ip_number,
			   char *ip_name)
d624 1
a624 1
	while (NULL != (ref = (Ref *) HTList_nextObject(cur))) {
d626 1
a626 1
	    /* no recursion for ip address tamplates.     */
d634 1
d636 2
a637 2
 * Group file cached reading
 */
d640 2
a641 2
    char *group_filename;
    GroupDefList *group_list;
d646 2
a647 1
static GroupCacheList *group_cache_list = NULL;
d649 1
a649 1
GroupDefList *HTAA_readGroupFile(const char *filename)
d654 1
a654 2
    if (isEmpty(filename))
	return NULL;
d661 1
a661 1
	while (NULL != (group_cache = (GroupCache *) HTList_nextObject(cur))) {
d663 3
a665 3
		CTRACE((tfp, "%s '%s' %s\n",
			"HTAA_readGroupFile: group file",
			filename, "already found in cache"));
d667 11
a677 11
	    }			/* if cache match */
	}			/* while cached files remain */
    }				/* cache exists */

    CTRACE((tfp, "HTAA_readGroupFile: reading group file `%s'\n",
	    filename));

    if (!(fp = fopen(filename, TXT_R))) {
	CTRACE((tfp, "%s '%s'\n",
		"HTAA_readGroupFile: unable to open group file",
		filename));
d681 1
a681 1
    if ((group_cache = typecalloc(GroupCache)) == 0)
d687 1
a687 1
    HTList_addObject(group_cache_list, (void *) group_cache);
d690 1
a690 1
    CTRACE((tfp, "Read group file '%s', results follow:\n", filename));
d697 1
d699 21
a719 21
 *		CHECK IF USER BELONGS TO TO A GIVEN GROUP
 *		AND THAT THE CONNECTION COMES FROM AN
 *		ADDRESS THAT IS ALLOWED BY THAT GROUP
 * ON ENTRY:
 *	group		the group definition structure.
 *	username	connecting user.
 *	ip_number	browser host IP number, optional.
 *	ip_name		browser host IP name, optional.
 *			However, one of ip_number or ip_name
 *			must be given.
 * ON EXIT:
 *	returns		HTAA_IP_MASK, if IP address mask was
 *			reason for failing.
 *			HTAA_NOT_MEMBER, if user does not belong
 *			to the group.
 *			HTAA_OK if both IP address and user are ok.
 */
HTAAFailReasonType HTAA_userAndInetInGroup(GroupDef *group,
					   char *username,
					   char *ip_number,
					   char *ip_name)
d727 1
a727 1
	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
d737 1
a737 1
		    while (NULL != (ref = (Ref *) HTList_nextObject(cur2))) {
d739 1
a739 1
			if (ref->translation) {		/* Group, check recursively */
d742 1
a742 1
							     ip_number, ip_name);
d745 2
a746 1
			} else {	/* Username, check directly */
d748 1
a748 1
				0 == strcmp(ref->name, username))
d751 4
a754 6
			/* Every user/group name in this group */
		    }
		    /* search for username */
		}
		/* IP address ok */
	    } else {
d757 3
a759 3
	}			/* while items in group */
    }
    /* valid parameters */
d763 2
a764 1
void GroupDef_delete(GroupDef *group_def)
d775 1
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a50 1
#include <LYUtils.h>
d81 1
a81 1
	if (cnt < 40) buffer[cnt++] = (char) ch;
d84 1
a84 1
    CTRACE((tfp, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
d86 1
a86 1
		HTlex_line, buffer, msg, lex_verbose(lex_item)));
d110 1
a110 1
	Ref *ref = typecalloc(Ref);
d166 1
a166 1
	Ref *ref = typecalloc(Ref);
d241 1
a241 1
    item = typecalloc(Item);
d290 1
a290 1
    group_def = typecalloc(GroupDef);
d509 2
a510 2
    CTRACE((tfp, "part_match: req: '%s' act: '%s' match: %s\n",
		required, actual, (status ? "yes" : "no")));
d654 1
a654 1
    if (isEmpty(filename)) return NULL;
d663 1
a663 1
		CTRACE((tfp, "%s '%s' %s\n",
d665 1
a665 1
			    filename, "already found in cache"));
d671 2
a672 2
    CTRACE((tfp, "HTAA_readGroupFile: reading group file `%s'\n",
		filename));
d674 2
a675 2
    if (!(fp = fopen(filename, TXT_R))) {
	CTRACE((tfp, "%s '%s'\n",
d677 1
a677 1
		    filename));
d681 1
a681 1
    if ((group_cache = typecalloc(GroupCache)) == 0)
d690 1
a690 1
    CTRACE((tfp, "Read group file '%s', results follow:\n", filename));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d73 3
a75 3
static void syntax_error (FILE *	 fp,
				char *	 msg,
				LexItem lex_item)
d92 1
a92 1
static AddressDefList *parse_address_part (FILE *  fp)
d149 1
a149 1
static UserDefList *parse_user_part (FILE *  fp)
d205 1
a205 1
static Item *parse_item (FILE *  fp)
d251 1
a251 1
static ItemList *parse_item_list (FILE *  fp)
d282 1
a282 1
GroupDef *HTAA_parseGroupDef (FILE *  fp)
d305 1
a305 1
static GroupDef *parse_group_decl (FILE *  fp)
d343 2
a344 2
static GroupDef *find_group_def (GroupDefList *	group_list,
				       const char *	group_name)
d360 2
a361 2
void HTAA_resolveGroupReferences (GroupDef *	group_def,
					      GroupDefList *	group_def_list)
d380 2
a381 2
static void add_group_def (GroupDefList * group_def_list,
				 GroupDef *	 group_def)
d388 1
a388 1
static GroupDefList *parse_group_file (FILE *  fp)
d404 1
a404 1
static void print_item (Item *  item)
d433 1
a433 1
static void print_item_list (ItemList *  item_list)
d445 1
a445 1
void HTAA_printGroupDef (GroupDef *  group_def)
d460 1
a460 1
static void print_group_def_list (GroupDefList *  group_list)
d475 1
a475 1
/* static						part_match()
d486 2
a487 2
static BOOL part_match (const char * tcur,
			      const char * icur)
d491 1
a491 1
    const char *cur;
d518 1
a518 1
/* static						ip_number_match()
d527 2
a528 2
static BOOL ip_number_match (const char *	template,
				   const char *	the_inet_addr)
d530 2
a531 2
    const char *tcur = template;
    const char *icur = the_inet_addr;
d545 1
a545 1
/* static						is_domain_mask()
d561 1
a561 1
static BOOL is_domain_mask (const char * 	mask)
d563 1
a563 1
    const char *cur = mask;
d577 1
a577 1
/* static							ip_mask_match()
d597 3
a599 3
static BOOL ip_mask_match (const char *	mask,
				 const char *	ip_number,
				 const char *	ip_name)
d617 3
a619 3
static BOOL ip_in_def_list (AddressDefList *	address_def_list,
				  char *		ip_number,
				  char *		ip_name)
d647 1
a647 1
static GroupCacheList *group_cache_list = NULL;
d650 1
a650 1
GroupDefList *HTAA_readGroupFile (const char *  filename)
d717 4
a720 4
HTAAFailReasonType HTAA_userAndInetInGroup (GroupDef * group,
							char *	    username,
							char *	    ip_number,
							char *	    ip_name)
d765 1
a765 1
void GroupDef_delete (GroupDef *  group_def)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d1 1
d3 41
a43 40
 *		GROUP FILE ROUTINES
 *
 *	Contains group file parser and routines to match IP
 *	address templates and to find out group membership.
 *
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *
 * HISTORY:
 *
 *
 * BUGS:
 *
 *
 *
 * GROUP DEFINITION GRAMMAR:
 *
 *	string = "sequence of alphanumeric characters"
 *	user_name ::= string
 *	group_name ::= string
 *	group_ref ::= group_name
 *	user_def ::= user_name | group_ref
 *	user_def_list ::= user_def { ',' user_def }
 *	user_part = user_def | '(' user_def_list ')'
 *
 *	templ = "sequence of alphanumeric characters and '*'s"
 *	ip_number_mask ::= templ '.' templ '.' templ '.' templ
 *	domain_name_mask ::= templ { '.' templ }
 *	address ::= ip_number_mask | domain_name_mask
 *	address_def ::= address
 *	address_def_list ::= address_def { ',' address_def }
 *	address_part = address_def | '(' address_def_list ')'
 *
 *	item ::= [user_part] ['@@' address_part]
 *	item_list ::= item { ',' item }
 *	group_def ::= item_list
 *	group_decl ::= group_name ':' group_def
 *
 */
d48 2
a49 2
#include <HTLex.h>		/* Lexical analysor     */
#include <HTGroup.h>		/* Implemented here     */
d55 2
a56 2
 * Group file parser
 */
d62 2
a63 2
    UserDefList *user_def_list;
    AddressDefList *address_def_list;
d67 2
a68 2
    char *name;
    GroupDef *translation;
d71 5
a75 2
static void syntax_error(FILE *fp, char *msg,
			 LexItem lex_item)
d81 3
a83 4
    while ((ch = getc(fp)) != EOF && ch != '\n')
	if (cnt < 40)
	    buffer[cnt++] = (char) ch;
    buffer[cnt] = (char) 0;
d86 2
a87 2
	    "HTGroup.c: Syntax error in rule file at line",
	    HTlex_line, buffer, msg, lex_verbose(lex_item)));
d91 2
a92 1
static AddressDefList *parse_address_part(FILE *fp)
d101 1
a101 1
    else if (lex_item != LEX_OPEN_PAREN ||
d110 1
a110 1
    for (;;) {
a111 1

d118 1
a118 1
	HTList_addObject(address_def_list, (void *) ref);
d123 4
a126 4
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
d148 2
a149 1
static UserDefList *parse_user_part(FILE *fp)
d158 1
a158 1
    else if (lex_item != LEX_OPEN_PAREN ||
a167 1

d174 1
a174 1
	HTList_addObject(user_def_list, (void *) ref);
d179 4
a182 4
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
d204 2
a205 1
static Item *parse_item(FILE *fp)
d225 2
a226 1
	} else {
d235 2
a236 2
    } else
	unlex(lex_item);
d250 2
a251 1
static ItemList *parse_item_list(FILE *fp)
d257 1
a257 1
    for (;;) {
d263 1
a263 1
	HTList_addObject(item_list, (void *) item);
d270 4
a273 4
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
d281 2
a282 1
GroupDef *HTAA_parseGroupDef(FILE *fp)
d304 2
a305 1
static GroupDef *parse_group_decl(FILE *fp)
d337 2
d340 2
a341 2
 * Group manipulation routines
 */
d343 2
a344 2
static GroupDef *find_group_def(GroupDefList *group_list,
				const char *group_name)
d350 1
a350 1
	while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur))) {
d359 3
a361 2
void HTAA_resolveGroupReferences(GroupDef *group_def,
				 GroupDefList *group_def_list)
d367 1
a367 1
	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
d371 1
a371 1
	    while (NULL != (ref = (Ref *) HTList_nextObject(cur2)))
d379 3
a381 2
static void add_group_def(GroupDefList *group_def_list,
			  GroupDef *group_def)
d384 1
a384 1
    HTList_addObject(group_def_list, (void *) group_def);
d387 2
a388 1
static GroupDefList *parse_group_file(FILE *fp)
d399 1
d401 2
a402 2
 * Trace functions
 */
d404 1
a404 1
static void print_item(Item *item)
d411 2
a412 2
	Ref *user_ref = (Ref *) HTList_nextObject(cur1);
	Ref *addr_ref = (Ref *) HTList_nextObject(cur2);
d417 1
a417 1
	    while (NULL != (user_ref = (Ref *) HTList_nextObject(cur1)))
d421 1
a421 2
	} else
	    fprintf(tfp, "\tANYBODY ");
d425 1
a425 1
	    while (NULL != (addr_ref = (Ref *) HTList_nextObject(cur2)))
d428 1
a428 2
	} else
	    fprintf(tfp, "@@ ANYADDRESS\n");
d432 2
a433 1
static void print_item_list(ItemList *item_list)
d440 2
a441 3
    else
	while (NULL != (item = (Item *) HTList_nextObject(cur)))
	    print_item(item);
d444 2
a445 1
void HTAA_printGroupDef(GroupDef *group_def)
d459 2
a460 1
static void print_group_def_list(GroupDefList *group_list)
d465 1
a465 1
    while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur)))
d469 2
d472 2
a473 2
 * IP address template matching
 */
d476 12
a487 12
 *		MATCH ONE PART OF INET ADDRESS AGAIST
 *		A PART OF MASK (inet address has 4 parts)
 * ON ENTRY:
 *	tcur	pointer to the beginning of template part.
 *	icur	pointer to the beginning of actual inet
 *		number part.
 *
 * ON EXIT:
 *	returns	YES, if match.
 */
static BOOL part_match(const char *tcur,
		       const char *icur)
d495 1
a495 2
    if (!tcur || !icur)
	return NO;
d497 3
a499 3
    cur = tcur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
d501 1
a501 1
    required[cnt] = (char) 0;
d503 3
a505 3
    cur = icur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
d507 1
a507 1
    actual[cnt] = (char) 0;
d511 1
a511 1
	    required, actual, (status ? "yes" : "no")));
d516 2
d519 10
a528 10
 *		MATCH INET NUMBER AGAINST AN INET NUMBER MASK
 * ON ENTRY:
 *	template	mask to match agaist, e.g., 128.141.*.*
 *	the_inet_addr	actual inet address, e.g., 128.141.201.74
 *
 * ON EXIT:
 *	returns		YES, if match;  NO, if not.
 */
static BOOL ip_number_match(const char *template,
			    const char *the_inet_addr)
d534 1
a534 1
    for (cnt = 0; cnt < 4; cnt++) {
d537 2
a538 4
	if (NULL != (tcur = strchr(tcur, '.')))
	    tcur++;
	if (NULL != (icur = strchr(icur, '.')))
	    icur++;
d543 2
d546 16
a561 16
 *		DETERMINE IF A GIVEN MASK IS A
 *		DOMAIN NAME MASK OR AN INET NUMBER MASK
 * ON ENTRY:
 *	mask	either a domain name mask,
 *		e.g.
 *			*.cern.ch
 *
 *		or an inet number mask,
 *		e.g.
 *			128.141.*.*
 *
 * ON EXIT:
 *	returns	YES, if mask is a domain name mask.
 *		NO, if it is an inet number mask.
 */
static BOOL is_domain_mask(const char *mask)
d565 1
a565 2
    if (!mask)
	return NO;
d568 2
a569 2
	if (*cur != '.' && *cur != '*' && (*cur < '0' || *cur > '9'))
	    return YES;		/* Even one non-digit makes it a domain name mask */
d572 1
a572 1
    return NO;			/* All digits and dots, so it is an inet number mask */
d575 2
d578 22
a599 22
 *		MATCH AN IP NUMBER MASK OR IP NAME MASK
 *		AGAINST ACTUAL IP NUMBER OR IP NAME
 *
 * ON ENTRY:
 *	mask		mask.  Mask may be either an inet number
 *			mask or a domain name mask,
 *			e.g.
 *				128.141.*.*
 *			or
 *				*.cern.ch
 *
 *	ip_number	IP number of connecting host.
 *	ip_name		IP name of the connecting host.
 *
 * ON EXIT:
 *	returns		YES, if hostname/internet number
 *			matches the mask.
 *			NO, if no match (no fire).
 */
static BOOL ip_mask_match(const char *mask,
			  const char *ip_number,
			  const char *ip_name)
d605 2
a606 1
	} else {
d614 6
a619 3
static BOOL ip_in_def_list(AddressDefList *address_def_list,
			   char *ip_number,
			   char *ip_name)
d625 1
a625 1
	while (NULL != (ref = (Ref *) HTList_nextObject(cur))) {
d627 1
a627 1
	    /* no recursion for ip address tamplates.     */
d635 1
d637 2
a638 2
 * Group file cached reading
 */
d641 2
a642 2
    char *group_filename;
    GroupDefList *group_list;
d649 2
a650 1
GroupDefList *HTAA_readGroupFile(const char *filename)
d655 1
a655 2
    if (isEmpty(filename))
	return NULL;
d662 1
a662 1
	while (NULL != (group_cache = (GroupCache *) HTList_nextObject(cur))) {
d665 2
a666 2
			"HTAA_readGroupFile: group file",
			filename, "already found in cache"));
d668 3
a670 3
	    }			/* if cache match */
	}			/* while cached files remain */
    }				/* cache exists */
d673 1
a673 1
	    filename));
d677 2
a678 2
		"HTAA_readGroupFile: unable to open group file",
		filename));
d688 1
a688 1
    HTList_addObject(group_cache_list, (void *) group_cache);
d698 1
d700 21
a720 21
 *		CHECK IF USER BELONGS TO TO A GIVEN GROUP
 *		AND THAT THE CONNECTION COMES FROM AN
 *		ADDRESS THAT IS ALLOWED BY THAT GROUP
 * ON ENTRY:
 *	group		the group definition structure.
 *	username	connecting user.
 *	ip_number	browser host IP number, optional.
 *	ip_name		browser host IP name, optional.
 *			However, one of ip_number or ip_name
 *			must be given.
 * ON EXIT:
 *	returns		HTAA_IP_MASK, if IP address mask was
 *			reason for failing.
 *			HTAA_NOT_MEMBER, if user does not belong
 *			to the group.
 *			HTAA_OK if both IP address and user are ok.
 */
HTAAFailReasonType HTAA_userAndInetInGroup(GroupDef *group,
					   char *username,
					   char *ip_number,
					   char *ip_name)
d728 1
a728 1
	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
d738 1
a738 1
		    while (NULL != (ref = (Ref *) HTList_nextObject(cur2))) {
d740 1
a740 1
			if (ref->translation) {		/* Group, check recursively */
d743 1
a743 1
							     ip_number, ip_name);
d746 2
a747 1
			} else {	/* Username, check directly */
d749 1
a749 1
				0 == strcmp(ref->name, username))
d752 4
a755 6
			/* Every user/group name in this group */
		    }
		    /* search for username */
		}
		/* IP address ok */
	    } else {
d758 3
a760 3
	}			/* while items in group */
    }
    /* valid parameters */
d764 2
a765 1
void GroupDef_delete(GroupDef *group_def)
d776 1
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a50 1
#include <LYUtils.h>
d81 1
a81 1
	if (cnt < 40) buffer[cnt++] = (char) ch;
d84 1
a84 1
    CTRACE((tfp, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
d86 1
a86 1
		HTlex_line, buffer, msg, lex_verbose(lex_item)));
d110 1
a110 1
	Ref *ref = typecalloc(Ref);
d166 1
a166 1
	Ref *ref = typecalloc(Ref);
d241 1
a241 1
    item = typecalloc(Item);
d290 1
a290 1
    group_def = typecalloc(GroupDef);
d509 2
a510 2
    CTRACE((tfp, "part_match: req: '%s' act: '%s' match: %s\n",
		required, actual, (status ? "yes" : "no")));
d663 1
a663 1
		CTRACE((tfp, "%s '%s' %s\n",
d665 1
a665 1
			    filename, "already found in cache"));
d671 2
a672 2
    CTRACE((tfp, "HTAA_readGroupFile: reading group file `%s'\n",
		filename));
d674 2
a675 2
    if (!(fp = fopen(filename, TXT_R))) {
	CTRACE((tfp, "%s '%s'\n",
d677 1
a677 1
		    filename));
d681 1
a681 1
    if ((group_cache = typecalloc(GroupCache)) == 0)
d690 1
a690 1
    CTRACE((tfp, "Read group file '%s', results follow:\n", filename));
@

