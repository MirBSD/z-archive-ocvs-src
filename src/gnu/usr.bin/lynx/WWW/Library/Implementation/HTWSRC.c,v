head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.45.51;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.43;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.29;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.53;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.04;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.11;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.02;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.58;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.53;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.26;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.17;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.47.39;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/*			Parse WAIS Source file			HTWSRC.c
 *			======================
 *
 *	This module parses a stream with WAIS source file
 *	format information on it and creates a structured stream.
 *	That structured stream is then converted into whatever.
 *
 *	3 June 93	Bug fix: Won't crash if no description
 */

#include <HTUtils.h>

#include <HTWSRC.h>
#include <LYUtils.h>

#include <HTML.h>
#include <HTParse.h>

#include <LYLeaks.h>

#define BIG 10000		/* Arbitrary limit to value length */
#define PARAM_MAX BIG
#define CACHE_PERIOD (7*86400)	/* Time to keep .src file in seconds */

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

#define PUTC(c) (*me->target->isa->put_character)(me->target, c)
#define PUTS(s) (*me->target->isa->put_string)(me->target, s)
#define START(e) (*me->target->isa->start_element)(me->target, e, 0, 0, -1, 0)
#define END(e) (*me->target->isa->end_element)(me->target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*me->target->isa->end_element)(me->target, e, 0)

/*	Here are the parameters which can be specified in a  source file
*/
static const char *par_name[] =
{
    "version",
    "ip-address",
#define PAR_IP_NAME 2
    "ip-name",
#define PAR_TCP_PORT 3
    "tcp-port",
#define PAR_DATABASE_NAME 4
    "database-name",
#define PAR_COST 5
    "cost",
#define PAR_COST_UNIT 6
    "cost-unit",
#define PAR_FREE 7
    "free",
#define PAR_MAINTAINER 8
    "maintainer",
#define PAR_DESCRIPTION 9
    "description",
    "keyword-list",
    "source",
    "window-geometry",
    "configuration",
    "script",
    "update-time",
    "contact-at",
    "last-contacted",
    "confidence",
    "num-docs-to-request",
    "font",
    "font-size",
#define PAR_UNKNOWN 22
    "unknown",
    0,				/* Terminate list */
#define PAR_COUNT 23
};

enum tokenstate {
    beginning,
    before_tag,
    colon,
    before_value,
    value,
    bracketed_value,
    quoted_value,
    escape_in_quoted,
    done
};

/*		Stream Object
 *		------------
 *
 *	The target is the structured stream down which the
 *	parsed results will go.
 *
 *	all the static stuff below should go in here to make it reentrant
 */

struct _HTStream {
    const HTStreamClass *isa;
    HTStructured *target;
    char *par_value[PAR_COUNT];
    enum tokenstate state;
    char param[BIG + 1];
    int param_number;
    int param_count;
};

/*	Decode one hex character
*/
char from_hex(char c)
{
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
}

/*			State machine
 *			-------------
 *
 * On entry,
 *	me->state	is a valid state (see WSRC_init)
 *	c		is the next character
 * On exit,
 *	returns 1	Done with file
 *		0	Continue. me->state is updated if necessary.
 *		-1	Syntax error error
 */

/*		Treat One Character
 *		-------------------
 */
static void WSRCParser_put_character(HTStream *me, char c)
{
    switch (me->state) {
    case beginning:
	if (c == '(')
	    me->state = before_tag;
	break;

    case before_tag:
	if (c == ')') {
	    me->state = done;
	    return;		/* Done with input file */
	} else if (c == ':') {
	    me->param_count = 0;
	    me->state = colon;
	}			/* Ignore other text */
	break;

    case colon:
	if (WHITE(c)) {
	    me->param[me->param_count++] = 0;	/* Terminate */
	    for (me->param_number = 0;
		 par_name[me->param_number];
		 me->param_number++) {
		if (0 == strcmp(par_name[me->param_number], me->param)) {
		    break;
		}
	    }
	    if (!par_name[me->param_number]) {	/* Unknown field */
		CTRACE((tfp, "HTWSRC: Unknown field `%s' in source file\n",
			me->param));
		me->param_number = PAR_UNKNOWN;
		me->state = before_value;	/* Could be better ignore */
		return;
	    }
	    me->state = before_value;
	} else {
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = c;
	}
	break;

    case before_value:
	if (c == ')') {
	    me->state = done;
	    return;		/* Done with input file */
	}
	if (WHITE(c))
	    return;		/* Skip white space */
	me->param_count = 0;
	if (c == '"') {
	    me->state = quoted_value;
	    break;
	}
	me->state = (c == '"') ? quoted_value :
	    (c == '(') ? bracketed_value : value;
	me->param[me->param_count++] = c;	/* Don't miss first character */
	break;

    case value:
	if (WHITE(c)) {
	    me->param[me->param_count] = 0;
	    StrAllocCopy(me->par_value[me->param_number], me->param);
	    me->state = before_tag;
	} else {
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = c;
	}
	break;

    case bracketed_value:
	if (c == ')') {
	    me->param[me->param_count] = 0;
	    StrAllocCopy(me->par_value[me->param_number], me->param);
	    me->state = before_tag;
	    break;
	}
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = c;
	break;

    case quoted_value:
	if (c == '"') {
	    me->param[me->param_count] = 0;
	    StrAllocCopy(me->par_value[me->param_number], me->param);
	    me->state = before_tag;
	    break;
	}

	if (c == '\\') {	/* Ignore escape but switch state */
	    me->state = escape_in_quoted;
	    break;
	}
	/* Fall through! */

    case escape_in_quoted:
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = c;
	me->state = quoted_value;
	break;

    case done:			/* Ignore anything after EOF */
	return;

    }				/* switch me->state */
}

/*			Open Cache file
 *			===============
 *
 *   Bugs: Maybe for filesystem-challenged platforms (MSDOS for example) we
 *   should make a hash code for the filename.
 */

#ifdef CACHE_FILE_PREFIX
static BOOL write_cache(HTStream *me)
{
    FILE *fp;
    char *cache_file_name = NULL;
    char *www_database;
    int result = NO;

    if (!me->par_value[PAR_DATABASE_NAME]
	|| !me->par_value[PAR_IP_NAME]
	)
	return NO;

    www_database = HTEscape(me->par_value[PAR_DATABASE_NAME], URL_XALPHAS);
    HTSprintf0(&cache_file_name, "%sWSRC-%s:%s:%.100s.txt",
	       CACHE_FILE_PREFIX,
	       me->par_value[PAR_IP_NAME],
	       (me->par_value[PAR_TCP_PORT]
		? me->par_value[PAR_TCP_PORT]
		: "210"),
	       www_database);

    if ((fp = fopen(cache_file_name, TXT_W)) != 0) {
	result = YES;
	if (me->par_value[PAR_DESCRIPTION])
	    fputs(me->par_value[PAR_DESCRIPTION], fp);
	else
	    fputs("Description not available\n", fp);
	fclose(fp);
    }
    FREE(www_database);
    FREE(cache_file_name);
    return result;
}
#endif

/*			Output equivalent HTML
 *			----------------------
 *
 */

static void give_parameter(HTStream *me, int p)
{
    PUTS(par_name[p]);
    if (me->par_value[p]) {
	PUTS(": ");
	PUTS(me->par_value[p]);
	PUTS("; ");
    } else {
	PUTS(gettext(" NOT GIVEN in source file; "));
    }
}

/*			Generate Outout
 *			===============
 */
static void WSRC_gen_html(HTStream *me, BOOL source_file)
{
    if (me->par_value[PAR_DATABASE_NAME]) {
	char *shortname = 0;
	int l;

	StrAllocCopy(shortname, me->par_value[PAR_DATABASE_NAME]);
	l = strlen(shortname);
	if (l > 4 && !strcasecomp(shortname + l - 4, ".src")) {
	    shortname[l - 4] = 0;	/* Chop of .src -- boring! */
	}

	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(shortname);
	PUTS(source_file ? gettext(" WAIS source file") : INDEX_SEGMENT);
	END(HTML_TITLE);
	PUTC('\n');
	END(HTML_HEAD);

	START(HTML_H1);
	PUTS(shortname);
	PUTS(source_file ? gettext(" description") : INDEX_SEGMENT);
	END(HTML_H1);
	PUTC('\n');
	FREE(shortname);
    }

    START(HTML_DL);		/* Definition list of details */

    if (source_file) {
	START(HTML_DT);
	PUTS(gettext("Access links"));
	MAYBE_END(HTML_DT);
	START(HTML_DD);
	if (me->par_value[PAR_IP_NAME] &&
	    me->par_value[PAR_DATABASE_NAME]) {

	    char *WSRC_address = NULL;
	    char *www_database;

	    www_database = HTEscape(me->par_value[PAR_DATABASE_NAME],
				    URL_XALPHAS);
	    HTSprintf0(&WSRC_address, "%s//%s%s%s/%s",
		       STR_WAIS_URL,
		       me->par_value[PAR_IP_NAME],
		       me->par_value[PAR_TCP_PORT] ? ":" : "",
		       (me->par_value[PAR_TCP_PORT]
			? me->par_value[PAR_TCP_PORT]
			: ""),
		       www_database);

	    HTStartAnchor(me->target, NULL, WSRC_address);
	    PUTS(gettext("Direct access"));
	    END(HTML_A);
	    /** Proxy will be used if defined, so let user know that - FM **/
	    PUTS(gettext(" (or via proxy server, if defined)"));

	    FREE(www_database);
	    FREE(WSRC_address);

	} else {
	    give_parameter(me, PAR_IP_NAME);
	    give_parameter(me, PAR_DATABASE_NAME);
	}
	MAYBE_END(HTML_DD);

    }
    /* end if source_file */
    if (me->par_value[PAR_MAINTAINER]) {
	START(HTML_DT);
	PUTS(gettext("Maintainer"));
	MAYBE_END(HTML_DT);
	START(HTML_DD);
	PUTS(me->par_value[PAR_MAINTAINER]);
	MAYBE_END(HTML_DD);
    }
    if (me->par_value[PAR_IP_NAME]) {
	START(HTML_DT);
	PUTS(gettext("Host"));
	MAYBE_END(HTML_DT);
	START(HTML_DD);
	PUTS(me->par_value[PAR_IP_NAME]);
	MAYBE_END(HTML_DD);
    }

    END(HTML_DL);

    if (me->par_value[PAR_DESCRIPTION]) {
	START(HTML_PRE);	/* Preformatted description */
	PUTS(me->par_value[PAR_DESCRIPTION]);
	END(HTML_PRE);
    }

    (*me->target->isa->_free) (me->target);

    return;
}				/* generate html */

static void WSRCParser_put_string(HTStream *context, const char *str)
{
    const char *p;

    for (p = str; *p; p++)
	WSRCParser_put_character(context, *p);
}

static void WSRCParser_write(HTStream *context, const char *str,
			     int l)
{
    const char *p;
    const char *e = str + l;

    for (p = str; p < e; p++)
	WSRCParser_put_character(context, *p);
}

static void WSRCParser_free(HTStream *me)
{
    WSRC_gen_html(me, YES);
#ifdef CACHE_FILE_PREFIX
    write_cache(me);
#endif
    {
	int p;

	for (p = 0; par_name[p]; p++) {		/* Clear out old values */
	    FREE(me->par_value[p]);
	}
    }
    FREE(me);
}

static void WSRCParser_abort(HTStream *me, HTError e GCC_UNUSED)
{
    WSRCParser_free(me);
}

/*		Stream subclass		-- method routines
 *		---------------
 */

static HTStreamClass WSRCParserClass =
{
    "WSRCParser",
    WSRCParser_free,
    WSRCParser_abort,
    WSRCParser_put_character,
    WSRCParser_put_string,
    WSRCParser_write
};

/*		Converter from WAIS Source to whatever
 *		--------------------------------------
 */
HTStream *HTWSRCConvert(HTPresentation *pres, HTParentAnchor *anchor,
			HTStream *sink)
{
    HTStream *me = (HTStream *) malloc(sizeof(*me));

    if (!me)
	outofmem(__FILE__, "HTWSRCConvert");

    me->isa = &WSRCParserClass;
    me->target = HTML_new(anchor, pres->rep_out, sink);

    {
	int p;

	for (p = 0; p < PAR_COUNT; p++) {	/* Clear out parameter values */
	    me->par_value[p] = 0;
	}
    }
    me->state = beginning;

    return me;
}
@


1.6
log
@automatic merge of lynx-current
@
text
@a107 2
const char *hex = "0123456789ABCDEF";

a109 1

d446 1
a446 1
HTStreamClass WSRCParserClass =
a453 1

@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 8
a9 8
**			======================
**
**	This module parses a stream with WAIS source file
**	format information on it and creates a structured stream.
**	That structured stream is then converted into whatever.
**
**	3 June 93	Bug fix: Won't crash if no description
*/
d26 2
a27 2
	const HTStructuredClass *	isa;
	/* ... */
a36 1

d39 4
a42 3
static const char* par_name[] = {
	"version",
	"ip-address",
d44 1
a44 1
	"ip-name",
d46 1
a46 1
	"tcp-port",
d48 1
a48 1
	"database-name",
d50 1
a50 1
	"cost",
d52 1
a52 1
	"cost-unit",
d54 1
a54 1
	"free",
d56 1
a56 1
	"maintainer",
d58 13
a70 13
	"description",
	"keyword-list",
	"source",
	"window-geometry",
	"configuration",
	"script",
	"update-time",
	"contact-at",
	"last-contacted",
	"confidence",
	"num-docs-to-request",
	"font",
	"font-size",
d72 2
a73 2
	"unknown",
	0,				/* Terminate list */
d75 1
a75 5
} ;


enum tokenstate { beginning, before_tag, colon, before_value,
		value, bracketed_value, quoted_value, escape_in_quoted, done };
d77 11
d90 7
a96 7
**		------------
**
**	The target is the structured stream down which the
**	parsed results will go.
**
**	all the static stuff below should go in here to make it reentrant
*/
d99 7
a105 7
	const HTStreamClass *	isa;
	HTStructured *		target;
	char *			par_value[PAR_COUNT];
	enum tokenstate		state;
	char			param[BIG+1];
	int			param_number;
	int			param_count;
d108 1
a108 4



const char * hex = "0123456789ABCDEF";
d113 1
a113 1
char from_hex (char  c)
d115 4
a118 4
    return  (char) (      (c>='0')&&(c<='9') ? c-'0'
			: (c>='A')&&(c<='F') ? c-'A'+10
			: (c>='a')&&(c<='f') ? c-'a'+10
			:		       0);
a120 1

d122 10
a131 11
**			-------------
**
** On entry,
**	me->state	is a valid state (see WSRC_init)
**	c		is the next character
** On exit,
**	returns 1	Done with file
**		0	Continue. me->state is updated if necessary.
**		-1	Syntax error error
*/

d134 3
a136 3
**		-------------------
*/
static void WSRCParser_put_character (HTStream*  me, char  c)
d140 2
a141 1
	if (c=='(') me->state = before_tag;
d145 1
a145 1
	if (c==')') {
d147 2
a148 2
	    return;			/* Done with input file */
	} else if (c==':') {
d151 1
a151 1
	}				/* Ignore other text */
d157 4
a160 2
	    for(me->param_number = 0; par_name[me->param_number]; me->param_number++) {
		if (0==strcmp(par_name[me->param_number], me->param)) {
d166 1
a166 1
			    me->param));
d173 2
a174 1
	    if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d179 1
a179 1
	if (c==')') {
d181 1
a181 1
	    return;			/* Done with input file */
d183 2
a184 1
	if (WHITE(c)) return;		/* Skip white space */
d186 1
a186 1
	if (c=='"') {
d190 2
a191 2
	me->state = (c=='"') ? quoted_value :
		    (c=='(') ? bracketed_value : value;
d201 2
a202 1
	    if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d207 1
a207 1
	if (c==')') {
d213 2
a214 1
	if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d218 1
a218 1
	if (c=='"') {
d225 1
a225 1
	if (c=='\\') {		/* Ignore escape but switch state */
d232 2
a233 1
	if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d237 1
a237 1
    case done:				/* Ignore anything after EOF */
d240 1
a240 1
    } /* switch me->state */
a242 1

d244 5
a248 5
**			===============
**
**   Bugs: Maybe for filesystem-challenged platforms (MSDOS for example) we
**   should make a hash code for the filename.
*/
d251 1
a251 1
static BOOL write_cache (HTStream *  me)
d253 3
a255 3
    FILE * fp;
    char * cache_file_name = NULL;
    char * www_database;
d260 2
a261 1
	) return NO;
d265 6
a270 4
	CACHE_FILE_PREFIX,
	me->par_value[PAR_IP_NAME],
	me->par_value[PAR_TCP_PORT] ? me->par_value[PAR_TCP_PORT] : "210",
	www_database);
d287 3
a289 3
**			----------------------
**
*/
d291 1
a291 1
static void give_parameter (HTStream *  me, int  p)
a302 1

d304 3
a306 4
**			===============
*/
static void WSRC_gen_html (HTStream *  me, BOOL  source_file)

d309 1
a309 1
	char * shortname = 0;
d311 1
d314 2
a315 2
	if ( l > 4 && !strcasecomp(shortname + l -4, ".src")) {
	    shortname[l-4] = 0; /* Chop of .src -- boring! */
d345 3
a347 2
	    char * WSRC_address = NULL;
	    char * www_database;
d349 1
a349 1
		URL_XALPHAS);
d351 7
a357 5
		STR_WAIS_URL,
		me->par_value[PAR_IP_NAME],
		me->par_value[PAR_TCP_PORT] ? ":" : "",
		me->par_value[PAR_TCP_PORT] ? me->par_value[PAR_TCP_PORT] :"",
		www_database);
d374 2
a375 2
    } /* end if source_file */

d396 1
a396 1
	START(HTML_PRE);		/* Preformatted description */
d401 1
a401 1
    (*me->target->isa->_free)(me->target);
d404 1
a404 2
} /* generate html */

d406 1
a406 1
static void WSRCParser_put_string (HTStream *  context, const char*  str)
d409 2
a410 1
    for(p=str; *p; p++)
d414 2
a415 5

static void WSRCParser_write (
		HTStream *	context,
		const char*	str,
		int		l)
d418 3
a420 2
    const char *e = str+l;
    for(p=str; p<e; p++)
d424 1
a424 2

static void WSRCParser_free (HTStream *  me)
d432 2
a433 1
	for (p = 0; par_name[p]; p++) { /* Clear out old values */
d440 1
a440 1
static void WSRCParser_abort (HTStream *  me, HTError  e GCC_UNUSED)
a444 1

d446 2
a447 2
**		---------------
*/
d449 8
a456 7
HTStreamClass WSRCParserClass = {
	"WSRCParser",
	WSRCParser_free,
	WSRCParser_abort,
	WSRCParser_put_character,
	WSRCParser_put_string,
	WSRCParser_write
a459 1

d461 4
a464 6
**		--------------------------------------
*/
HTStream* HTWSRCConvert (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d466 4
a469 2
    HTStream * me = (HTStream*) malloc(sizeof(*me));
    if (!me) outofmem(__FILE__, "HTWSRCConvert");
d476 2
a477 1
	for(p=0; p < PAR_COUNT; p++) {	/* Clear out parameter values */
a484 1

@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d26 1
a26 1
	CONST HTStructuredClass *	isa;
d40 1
a40 1
PRIVATE CONST char* par_name[] = {
d92 1
a92 1
	CONST HTStreamClass *	isa;
d104 1
a104 1
PUBLIC CONST char * hex = "0123456789ABCDEF";
d109 1
a109 1
PUBLIC char from_hex ARGS1(char, c)
d134 1
a134 1
PRIVATE void WSRCParser_put_character ARGS2(HTStream*, me, char, c)
d242 1
a242 1
PRIVATE BOOL write_cache ARGS1(HTStream *, me)
d279 1
a279 1
PRIVATE void give_parameter ARGS2(HTStream *, me, int, p)
d295 1
a295 1
PRIVATE void WSRC_gen_html ARGS2(HTStream *, me, BOOL, source_file)
d393 1
a393 1
PRIVATE void WSRCParser_put_string ARGS2(HTStream *, context, CONST char*, str)
d395 1
a395 1
    CONST char *p;
d401 4
a404 4
PRIVATE void WSRCParser_write ARGS3(
		HTStream *,	context,
		CONST char*,	str,
		int,		l)
d406 2
a407 2
    CONST char *p;
    CONST char *e = str+l;
d413 1
a413 1
PRIVATE void WSRCParser_free ARGS1(HTStream *, me)
d428 1
a428 1
PRIVATE void WSRCParser_abort ARGS2(HTStream *, me, HTError, e GCC_UNUSED)
d452 4
a455 4
PUBLIC HTStream* HTWSRCConvert ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d95 1
a95 1
	enum tokenstate 	state;
d434 1
a434 1
/*		Stream subclass 	-- method routines
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d14 1
a14 1

a24 2
#define HEX_ESCAPE '%'

d111 1
a111 1
    return		  (c>='0')&&(c<='9') ? c-'0'
d114 1
a114 1
			:		       0;
d160 2
a161 2
		CTRACE(tfp, "HTWSRC: Unknown field `%s' in source file\n",
			    me->param);
d245 1
a245 1
    char cache_file_name[256];
d247 2
d254 1
a254 1
    sprintf(cache_file_name, "%sWSRC-%s:%s:%.100s.txt",
d259 9
d269 2
a270 9
    fp = fopen(cache_file_name, "w");
    if (!fp) return NO;

    if (me->par_value[PAR_DESCRIPTION])
	fputs(me->par_value[PAR_DESCRIPTION], fp);
    else
	fputs("Description not available\n", fp);
    fclose(fp);
    return YES;
d334 1
a334 1
	    char WSRC_address[256];
d338 2
a339 1
	    sprintf(WSRC_address, "wais://%s%s%s/%s",
d352 1
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 8
a9 8
 *			======================
 *
 *	This module parses a stream with WAIS source file
 *	format information on it and creates a structured stream.
 *	That structured stream is then converted into whatever.
 *
 *	3 June 93	Bug fix: Won't crash if no description
 */
d14 1
a14 1
#include <LYUtils.h>
d25 2
d28 2
a29 2
    const HTStructuredClass *isa;
    /* ... */
d39 1
d42 3
a44 4
static const char *par_name[] =
{
    "version",
    "ip-address",
d46 1
a46 1
    "ip-name",
d48 1
a48 1
    "tcp-port",
d50 1
a50 1
    "database-name",
d52 1
a52 1
    "cost",
d54 1
a54 1
    "cost-unit",
d56 1
a56 1
    "free",
d58 1
a58 1
    "maintainer",
d60 13
a72 13
    "description",
    "keyword-list",
    "source",
    "window-geometry",
    "configuration",
    "script",
    "update-time",
    "contact-at",
    "last-contacted",
    "confidence",
    "num-docs-to-request",
    "font",
    "font-size",
d74 2
a75 2
    "unknown",
    0,				/* Terminate list */
d77 5
a81 1
};
a82 11
enum tokenstate {
    beginning,
    before_tag,
    colon,
    before_value,
    value,
    bracketed_value,
    quoted_value,
    escape_in_quoted,
    done
};
d85 7
a91 7
 *		------------
 *
 *	The target is the structured stream down which the
 *	parsed results will go.
 *
 *	all the static stuff below should go in here to make it reentrant
 */
d94 7
a100 7
    const HTStreamClass *isa;
    HTStructured *target;
    char *par_value[PAR_COUNT];
    enum tokenstate state;
    char param[BIG + 1];
    int param_number;
    int param_count;
d103 5
d110 2
a111 1
char from_hex(char c)
d113 4
a116 4
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
d119 1
d121 11
a131 10
 *			-------------
 *
 * On entry,
 *	me->state	is a valid state (see WSRC_init)
 *	c		is the next character
 * On exit,
 *	returns 1	Done with file
 *		0	Continue. me->state is updated if necessary.
 *		-1	Syntax error error
 */
d134 3
a136 3
 *		-------------------
 */
static void WSRCParser_put_character(HTStream *me, char c)
d140 1
a140 2
	if (c == '(')
	    me->state = before_tag;
d144 1
a144 1
	if (c == ')') {
d146 2
a147 2
	    return;		/* Done with input file */
	} else if (c == ':') {
d150 1
a150 1
	}			/* Ignore other text */
d156 2
a157 4
	    for (me->param_number = 0;
		 par_name[me->param_number];
		 me->param_number++) {
		if (0 == strcmp(par_name[me->param_number], me->param)) {
d162 2
a163 2
		CTRACE((tfp, "HTWSRC: Unknown field `%s' in source file\n",
			me->param));
d170 1
a170 2
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = c;
d175 1
a175 1
	if (c == ')') {
d177 1
a177 1
	    return;		/* Done with input file */
d179 1
a179 2
	if (WHITE(c))
	    return;		/* Skip white space */
d181 1
a181 1
	if (c == '"') {
d185 2
a186 2
	me->state = (c == '"') ? quoted_value :
	    (c == '(') ? bracketed_value : value;
d196 1
a196 2
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = c;
d201 1
a201 1
	if (c == ')') {
d207 1
a207 2
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = c;
d211 1
a211 1
	if (c == '"') {
d218 1
a218 1
	if (c == '\\') {	/* Ignore escape but switch state */
d225 1
a225 2
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = c;
d229 1
a229 1
    case done:			/* Ignore anything after EOF */
d232 1
a232 1
    }				/* switch me->state */
d235 1
d237 5
a241 5
 *			===============
 *
 *   Bugs: Maybe for filesystem-challenged platforms (MSDOS for example) we
 *   should make a hash code for the filename.
 */
d244 1
a244 1
static BOOL write_cache(HTStream *me)
d246 3
a248 5
    FILE *fp;
    char *cache_file_name = NULL;
    char *www_database;
    int result = NO;

d251 1
a251 2
	)
	return NO;
d254 5
a258 16
    HTSprintf0(&cache_file_name, "%sWSRC-%s:%s:%.100s.txt",
	       CACHE_FILE_PREFIX,
	       me->par_value[PAR_IP_NAME],
	       (me->par_value[PAR_TCP_PORT]
		? me->par_value[PAR_TCP_PORT]
		: "210"),
	       www_database);

    if ((fp = fopen(cache_file_name, TXT_W)) != 0) {
	result = YES;
	if (me->par_value[PAR_DESCRIPTION])
	    fputs(me->par_value[PAR_DESCRIPTION], fp);
	else
	    fputs("Description not available\n", fp);
	fclose(fp);
    }
d260 9
a268 2
    FREE(cache_file_name);
    return result;
d273 3
a275 3
 *			----------------------
 *
 */
d277 1
a277 1
static void give_parameter(HTStream *me, int p)
d289 1
d291 4
a294 3
 *			===============
 */
static void WSRC_gen_html(HTStream *me, BOOL source_file)
d297 1
a297 1
	char *shortname = 0;
a298 1

d301 2
a302 2
	if (l > 4 && !strcasecomp(shortname + l - 4, ".src")) {
	    shortname[l - 4] = 0;	/* Chop of .src -- boring! */
d332 2
a333 3
	    char *WSRC_address = NULL;
	    char *www_database;

d335 6
a340 9
				    URL_XALPHAS);
	    HTSprintf0(&WSRC_address, "%s//%s%s%s/%s",
		       STR_WAIS_URL,
		       me->par_value[PAR_IP_NAME],
		       me->par_value[PAR_TCP_PORT] ? ":" : "",
		       (me->par_value[PAR_TCP_PORT]
			? me->par_value[PAR_TCP_PORT]
			: ""),
		       www_database);
a348 1
	    FREE(WSRC_address);
d356 2
a357 2
    }
    /* end if source_file */
d378 1
a378 1
	START(HTML_PRE);	/* Preformatted description */
d383 1
a383 1
    (*me->target->isa->_free) (me->target);
d386 1
a386 1
}				/* generate html */
d388 2
a389 1
static void WSRCParser_put_string(HTStream *context, const char *str)
d391 2
a392 3
    const char *p;

    for (p = str; *p; p++)
a395 5
static void WSRCParser_write(HTStream *context, const char *str,
			     int l)
{
    const char *p;
    const char *e = str + l;
d397 8
a404 1
    for (p = str; p < e; p++)
d408 2
a409 1
static void WSRCParser_free(HTStream *me)
d417 1
a417 2

	for (p = 0; par_name[p]; p++) {		/* Clear out old values */
d424 1
a424 1
static void WSRCParser_abort(HTStream *me, HTError e GCC_UNUSED)
a428 3
/*		Stream subclass		-- method routines
 *		---------------
 */
d430 12
a441 8
static HTStreamClass WSRCParserClass =
{
    "WSRCParser",
    WSRCParser_free,
    WSRCParser_abort,
    WSRCParser_put_character,
    WSRCParser_put_string,
    WSRCParser_write
d444 1
d446 6
a451 4
 *		--------------------------------------
 */
HTStream *HTWSRCConvert(HTPresentation *pres, HTParentAnchor *anchor,
			HTStream *sink)
d453 2
a454 4
    HTStream *me = (HTStream *) malloc(sizeof(*me));

    if (!me)
	outofmem(__FILE__, "HTWSRCConvert");
d461 1
a461 2

	for (p = 0; p < PAR_COUNT; p++) {	/* Clear out parameter values */
d469 1
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d14 1
a14 1
#include <LYUtils.h>
d25 2
d113 1
a113 1
    return  (char) (      (c>='0')&&(c<='9') ? c-'0'
d116 1
a116 1
			:		       0);
d162 2
a163 2
		CTRACE((tfp, "HTWSRC: Unknown field `%s' in source file\n",
			    me->param));
d247 1
a247 1
    char * cache_file_name = NULL;
a248 2
    int result = NO;

d254 1
a254 1
    HTSprintf0(&cache_file_name, "%sWSRC-%s:%s:%.100s.txt",
d259 3
d263 6
a268 11
    if ((fp = fopen(cache_file_name, TXT_W)) != 0) {
	result = YES;
	if (me->par_value[PAR_DESCRIPTION])
	    fputs(me->par_value[PAR_DESCRIPTION], fp);
	else
	    fputs("Description not available\n", fp);
	fclose(fp);
    }
    FREE(www_database);
    FREE(cache_file_name);
    return result;
d332 1
a332 1
	    char * WSRC_address = NULL;
d336 1
a336 2
	    HTSprintf0(&WSRC_address, "%s//%s%s%s/%s",
		STR_WAIS_URL,
a348 1
	    FREE(WSRC_address);
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d95 1
a95 1
	enum tokenstate		state;
d434 1
a434 1
/*		Stream subclass		-- method routines
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d26 1
a26 1
	const HTStructuredClass *	isa;
d40 1
a40 1
static const char* par_name[] = {
d92 1
a92 1
	const HTStreamClass *	isa;
d104 1
a104 1
const char * hex = "0123456789ABCDEF";
d109 1
a109 1
char from_hex (char  c)
d134 1
a134 1
static void WSRCParser_put_character (HTStream*  me, char  c)
d242 1
a242 1
static BOOL write_cache (HTStream *  me)
d279 1
a279 1
static void give_parameter (HTStream *  me, int  p)
d295 1
a295 1
static void WSRC_gen_html (HTStream *  me, BOOL  source_file)
d393 1
a393 1
static void WSRCParser_put_string (HTStream *  context, const char*  str)
d395 1
a395 1
    const char *p;
d401 4
a404 4
static void WSRCParser_write (
		HTStream *	context,
		const char*	str,
		int		l)
d406 2
a407 2
    const char *p;
    const char *e = str+l;
d413 1
a413 1
static void WSRCParser_free (HTStream *  me)
d428 1
a428 1
static void WSRCParser_abort (HTStream *  me, HTError  e GCC_UNUSED)
d452 4
a455 4
HTStream* HTWSRCConvert (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 8
a9 8
 *			======================
 *
 *	This module parses a stream with WAIS source file
 *	format information on it and creates a structured stream.
 *	That structured stream is then converted into whatever.
 *
 *	3 June 93	Bug fix: Won't crash if no description
 */
d26 2
a27 2
    const HTStructuredClass *isa;
    /* ... */
d37 1
d40 3
a42 4
static const char *par_name[] =
{
    "version",
    "ip-address",
d44 1
a44 1
    "ip-name",
d46 1
a46 1
    "tcp-port",
d48 1
a48 1
    "database-name",
d50 1
a50 1
    "cost",
d52 1
a52 1
    "cost-unit",
d54 1
a54 1
    "free",
d56 1
a56 1
    "maintainer",
d58 13
a70 13
    "description",
    "keyword-list",
    "source",
    "window-geometry",
    "configuration",
    "script",
    "update-time",
    "contact-at",
    "last-contacted",
    "confidence",
    "num-docs-to-request",
    "font",
    "font-size",
d72 2
a73 2
    "unknown",
    0,				/* Terminate list */
d75 5
a79 1
};
a80 11
enum tokenstate {
    beginning,
    before_tag,
    colon,
    before_value,
    value,
    bracketed_value,
    quoted_value,
    escape_in_quoted,
    done
};
d83 7
a89 7
 *		------------
 *
 *	The target is the structured stream down which the
 *	parsed results will go.
 *
 *	all the static stuff below should go in here to make it reentrant
 */
d92 7
a98 7
    const HTStreamClass *isa;
    HTStructured *target;
    char *par_value[PAR_COUNT];
    enum tokenstate state;
    char param[BIG + 1];
    int param_number;
    int param_count;
d101 4
a104 1
const char *hex = "0123456789ABCDEF";
d109 1
a109 1
char from_hex(char c)
d111 4
a114 4
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
d117 1
d119 11
a129 10
 *			-------------
 *
 * On entry,
 *	me->state	is a valid state (see WSRC_init)
 *	c		is the next character
 * On exit,
 *	returns 1	Done with file
 *		0	Continue. me->state is updated if necessary.
 *		-1	Syntax error error
 */
d132 3
a134 3
 *		-------------------
 */
static void WSRCParser_put_character(HTStream *me, char c)
d138 1
a138 2
	if (c == '(')
	    me->state = before_tag;
d142 1
a142 1
	if (c == ')') {
d144 2
a145 2
	    return;		/* Done with input file */
	} else if (c == ':') {
d148 1
a148 1
	}			/* Ignore other text */
d154 2
a155 4
	    for (me->param_number = 0;
		 par_name[me->param_number];
		 me->param_number++) {
		if (0 == strcmp(par_name[me->param_number], me->param)) {
d161 1
a161 1
			me->param));
d168 1
a168 2
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = c;
d173 1
a173 1
	if (c == ')') {
d175 1
a175 1
	    return;		/* Done with input file */
d177 1
a177 2
	if (WHITE(c))
	    return;		/* Skip white space */
d179 1
a179 1
	if (c == '"') {
d183 2
a184 2
	me->state = (c == '"') ? quoted_value :
	    (c == '(') ? bracketed_value : value;
d194 1
a194 2
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = c;
d199 1
a199 1
	if (c == ')') {
d205 1
a205 2
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = c;
d209 1
a209 1
	if (c == '"') {
d216 1
a216 1
	if (c == '\\') {	/* Ignore escape but switch state */
d223 1
a223 2
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = c;
d227 1
a227 1
    case done:			/* Ignore anything after EOF */
d230 1
a230 1
    }				/* switch me->state */
d233 1
d235 5
a239 5
 *			===============
 *
 *   Bugs: Maybe for filesystem-challenged platforms (MSDOS for example) we
 *   should make a hash code for the filename.
 */
d242 1
a242 1
static BOOL write_cache(HTStream *me)
d244 3
a246 3
    FILE *fp;
    char *cache_file_name = NULL;
    char *www_database;
d251 1
a251 2
	)
	return NO;
d255 4
a258 6
	       CACHE_FILE_PREFIX,
	       me->par_value[PAR_IP_NAME],
	       (me->par_value[PAR_TCP_PORT]
		? me->par_value[PAR_TCP_PORT]
		: "210"),
	       www_database);
d275 3
a277 3
 *			----------------------
 *
 */
d279 1
a279 1
static void give_parameter(HTStream *me, int p)
d291 1
d293 4
a296 3
 *			===============
 */
static void WSRC_gen_html(HTStream *me, BOOL source_file)
d299 1
a299 1
	char *shortname = 0;
a300 1

d303 2
a304 2
	if (l > 4 && !strcasecomp(shortname + l - 4, ".src")) {
	    shortname[l - 4] = 0;	/* Chop of .src -- boring! */
d334 2
a335 3
	    char *WSRC_address = NULL;
	    char *www_database;

d337 1
a337 1
				    URL_XALPHAS);
d339 5
a343 7
		       STR_WAIS_URL,
		       me->par_value[PAR_IP_NAME],
		       me->par_value[PAR_TCP_PORT] ? ":" : "",
		       (me->par_value[PAR_TCP_PORT]
			? me->par_value[PAR_TCP_PORT]
			: ""),
		       www_database);
d360 2
a361 2
    }
    /* end if source_file */
d382 1
a382 1
	START(HTML_PRE);	/* Preformatted description */
d387 1
a387 1
    (*me->target->isa->_free) (me->target);
d390 2
a391 1
}				/* generate html */
d393 1
a393 1
static void WSRCParser_put_string(HTStream *context, const char *str)
d396 1
a396 2

    for (p = str; *p; p++)
d400 5
a404 2
static void WSRCParser_write(HTStream *context, const char *str,
			     int l)
d407 2
a408 3
    const char *e = str + l;

    for (p = str; p < e; p++)
d412 2
a413 1
static void WSRCParser_free(HTStream *me)
d421 1
a421 2

	for (p = 0; par_name[p]; p++) {		/* Clear out old values */
d428 1
a428 1
static void WSRCParser_abort(HTStream *me, HTError e GCC_UNUSED)
d433 1
d435 2
a436 2
 *		---------------
 */
d438 7
a444 8
HTStreamClass WSRCParserClass =
{
    "WSRCParser",
    WSRCParser_free,
    WSRCParser_abort,
    WSRCParser_put_character,
    WSRCParser_put_string,
    WSRCParser_write
d448 1
d450 6
a455 4
 *		--------------------------------------
 */
HTStream *HTWSRCConvert(HTPresentation *pres, HTParentAnchor *anchor,
			HTStream *sink)
d457 2
a458 4
    HTStream *me = (HTStream *) malloc(sizeof(*me));

    if (!me)
	outofmem(__FILE__, "HTWSRCConvert");
d465 1
a465 2

	for (p = 0; p < PAR_COUNT; p++) {	/* Clear out parameter values */
d473 1
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d25 2
d113 1
a113 1
    return  (char) (      (c>='0')&&(c<='9') ? c-'0'
d116 1
a116 1
			:		       0);
d162 2
a163 2
		CTRACE((tfp, "HTWSRC: Unknown field `%s' in source file\n",
			    me->param));
d247 1
a247 1
    char * cache_file_name = NULL;
a248 2
    int result = NO;

d254 1
a254 1
    HTSprintf0(&cache_file_name, "%sWSRC-%s:%s:%.100s.txt",
d259 3
d263 6
a268 11
    if ((fp = fopen(cache_file_name, TXT_W)) != 0) {
	result = YES;
	if (me->par_value[PAR_DESCRIPTION])
	    fputs(me->par_value[PAR_DESCRIPTION], fp);
	else
	    fputs("Description not available\n", fp);
	fclose(fp);
    }
    FREE(www_database);
    FREE(cache_file_name);
    return result;
d332 1
a332 1
	    char * WSRC_address = NULL;
d336 1
a336 1
	    HTSprintf0(&WSRC_address, "wais://%s%s%s/%s",
a348 1
	    FREE(WSRC_address);
@

