head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.30;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.24;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.58;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.04;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.04;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.13;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.55;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/* MODULE							HTAAUtil.c
 *		COMMON PARTS OF ACCESS AUTHORIZATION MODULE
 *			FOR BOTH SERVER AND BROWSER
 *
 * IMPORTANT:
 *	Routines in this module use dynamic allocation, but free
 *	automatically all the memory reserved by them.
 *
 *	Therefore the caller never has to (and never should)
 *	free() any object returned by these functions.
 *
 *	Therefore also all the strings returned by this package
 *	are only valid until the next call to the same function
 *	is made.  This approach is selected, because of the nature
 *	of access authorization: no string returned by the package
 *	needs to be valid longer than until the next call.
 *
 *	This also makes it easy to plug the AA package in:
 *	you don't have to ponder whether to free() something
 *	here or is it done somewhere else (because it is always
 *	done somewhere else).
 *
 *	The strings that the package needs to store are copied
 *	so the original strings given as parameters to AA
 *	functions may be freed or modified with no side effects.
 *
 *	The AA package does not free() anything else than what
 *	it has itself allocated.
 *
 *	AA (Access Authorization) package means modules which
 *	names start with HTAA.
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	 8 Nov 93  MD	(VMS only) Added case insensitive comparison in HTAA_templateCaseMatch
 *
 *
 * BUGS:
 *
 *
 */

#include <HTUtils.h>

#include <HTAAUtil.h>		/* Implemented here     */
#include <HTAssoc.h>		/* Assoc list           */
#include <HTTCP.h>
#include <HTTP.h>

#include <LYStrings.h>
#include <LYLeaks.h>

/* PUBLIC						HTAAScheme_enum()
 *		TRANSLATE SCHEME NAME INTO
 *		A SCHEME ENUMERATION
 *
 * ON ENTRY:
 *	name		is a string representing the scheme name.
 *
 * ON EXIT:
 *	returns		the enumerated constant for that scheme.
 */
HTAAScheme HTAAScheme_enum(const char *name)
{
    char *upcased = NULL;

    if (!name)
	return HTAA_UNKNOWN;

    StrAllocCopy(upcased, name);
    LYUpperCase(upcased);

    if (!strncmp(upcased, "NONE", 4)) {
	FREE(upcased);
	return HTAA_NONE;
    } else if (!strncmp(upcased, "BASIC", 5)) {
	FREE(upcased);
	return HTAA_BASIC;
    } else if (!strncmp(upcased, "PUBKEY", 6)) {
	FREE(upcased);
	return HTAA_PUBKEY;
    } else if (!strncmp(upcased, "KERBEROSV4", 10)) {
	FREE(upcased);
	return HTAA_KERBEROS_V4;
    } else if (!strncmp(upcased, "KERBEROSV5", 10)) {
	FREE(upcased);
	return HTAA_KERBEROS_V5;
    } else {
	FREE(upcased);
	return HTAA_UNKNOWN;
    }
}

/* PUBLIC						HTAAScheme_name()
 *			GET THE NAME OF A GIVEN SCHEME
 * ON ENTRY:
 *	scheme		is one of the scheme enum values:
 *			HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"None", "Basic", "Pubkey", ...
 */
const char *HTAAScheme_name(HTAAScheme scheme)
{
    switch (scheme) {
    case HTAA_NONE:
	return "None";
    case HTAA_BASIC:
	return "Basic";
    case HTAA_PUBKEY:
	return "Pubkey";
    case HTAA_KERBEROS_V4:
	return "KerberosV4";
    case HTAA_KERBEROS_V5:
	return "KerberosV5";
    case HTAA_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
    }
}

/* PUBLIC						    HTAAMethod_enum()
 *		TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
 * ON ENTRY:
 *	name		is the method name to translate.
 *
 * ON EXIT:
 *	returns		HTAAMethod enumerated value corresponding
 *			to the given name.
 */
HTAAMethod HTAAMethod_enum(const char *name)
{
    if (!name)
	return METHOD_UNKNOWN;

    if (0 == strcasecomp(name, "GET"))
	return METHOD_GET;
    else if (0 == strcasecomp(name, "PUT"))
	return METHOD_PUT;
    else
	return METHOD_UNKNOWN;
}

/* PUBLIC						HTAAMethod_name()
 *			GET THE NAME OF A GIVEN METHOD
 * ON ENTRY:
 *	method		is one of the method enum values:
 *			METHOD_GET, METHOD_PUT, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"GET", "PUT", ...
 */
const char *HTAAMethod_name(HTAAMethod method)
{
    switch (method) {
    case METHOD_GET:
	return "GET";
    case METHOD_PUT:
	return "PUT";
    case METHOD_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
    }
}

/* PUBLIC						HTAAMethod_inList()
 *		IS A METHOD IN A LIST OF METHOD NAMES
 * ON ENTRY:
 *	method		is the method to look for.
 *	list		is a list of method names.
 *
 * ON EXIT:
 *	returns		YES, if method was found.
 *			NO, if not found.
 */
BOOL HTAAMethod_inList(HTAAMethod method, HTList *list)
{
    HTList *cur = list;
    char *item;

    while (NULL != (item = (char *) HTList_nextObject(cur))) {
	CTRACE((tfp, " %s", item));
	if (method == HTAAMethod_enum(item))
	    return YES;
    }

    return NO;			/* Not found */
}

/* PUBLIC						HTAA_templateMatch()
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE
 * NOTE:
 *	This is essentially the same code as in HTRules.c, but it
 *	cannot be used because it is embedded in between other code.
 *	(In fact, HTRules.c should use this routine, but then this
 *	 routine would have to be more sophisticated... why is life
 *	 sometimes so hard...)
 *
 * ON ENTRY:
 *	ctemplate	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateMatch(const char *ctemplate,
			const char *filename)
{
    const char *p = ctemplate;
    const char *q = filename;
    int m;

    for (; *p && *q && *p == *q; p++, q++)	/* Find first mismatch */
	;			/* do nothing else */

    if (!*p && !*q)
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
	m = strlen(q) - strlen(p);	/* Amount to match to wildcard */
	if (m < 0)
	    return NO;		/* No match, filename too short */
	else {			/* Skip the matched characters and compare */
	    if (strcmp(p, q + m))
		return NO;	/* Tail mismatch */
	    else
		return YES;	/* Tail match */
	}
	/* if wildcard */
    } else
	return NO;		/* Length or character mismatch */
}

/* PUBLIC						HTAA_templateCaseMatch()
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
 * NOTE:
 *	This is essentially the same code as in HTAA_templateMatch, but
 *	it compares case insensitive (for VMS). Reason for this routine
 *	is that HTAA_templateMatch gets called from several places, also
 *	there where a case sensitive match is needed, so one cannot just
 *	change the HTAA_templateMatch routine for VMS.
 *
 * ON ENTRY:
 *	template	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateCaseMatch(const char *ctemplate,
			    const char *filename)
{
    const char *p = ctemplate;
    const char *q = filename;
    int m;

    /* Find first mismatch */
    for (; *p && *q && TOUPPER(*p) == TOUPPER(*q); p++, q++) ;	/* do nothing else */

    if (!*p && !*q)
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
	m = strlen(q) - strlen(p);	/* Amount to match to wildcard */
	if (m < 0)
	    return NO;		/* No match, filename too short */
	else {			/* Skip the matched characters and compare */
	    if (strcasecomp(p, q + m))
		return NO;	/* Tail mismatch */
	    else
		return YES;	/* Tail match */
	}
	/* if wildcard */
    } else
	return NO;		/* Length or character mismatch */
}

/* PUBLIC					HTAA_makeProtectionTemplate()
 *		CREATE A PROTECTION TEMPLATE FOR THE FILES
 *		IN THE SAME DIRECTORY AS THE GIVEN FILE
 *		(Used by server if there is no fancier way for
 *		it to tell the client, and by browser if server
 *		didn't send WWW-ProtectionTemplate: field)
 * ON ENTRY:
 *	docname is the document pathname (from URL).
 *
 * ON EXIT:
 *	returns a template matching docname, and other files
 *		files in that directory.
 *
 *		E.g.  /foo/bar/x.html  =>  /foo/bar/ *
 *						    ^
 *				Space only to prevent it from
 *				being a comment marker here,
 *				there really isn't any space.
 */
char *HTAA_makeProtectionTemplate(const char *docname)
{
    char *ctemplate = NULL;
    char *slash = NULL;

    if (docname) {
	StrAllocCopy(ctemplate, docname);
	slash = strrchr(ctemplate, '/');
	if (slash)
	    slash++;
	else
	    slash = ctemplate;
	*slash = '\0';
	StrAllocCat(ctemplate, "*");
    } else
	StrAllocCopy(ctemplate, "*");

    CTRACE((tfp, "make_template: made template `%s' for file `%s'\n",
	    ctemplate, docname));

    return ctemplate;
}

/*
 * Skip leading whitespace from *s forward
 */
#define SKIPWS(s) while (*s==' ' || *s=='\t') s++;

/*
 * Kill trailing whitespace starting from *(s-1) backwards
 */
#define KILLWS(s) {char *c=s-1; while (*c==' ' || *c=='\t') *(c--)='\0';}

/* PUBLIC						HTAA_parseArgList()
 *		PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
 * ON ENTRY:
 *	str	is a comma-separated list:
 *
 *			item, item, item
 *		where
 *			item ::= value
 *			       | name=value
 *			       | name="value"
 *
 *		Leading and trailing whitespace is ignored
 *		everywhere except inside quotes, so the following
 *		examples are equal:
 *
 *			name=value,foo=bar
 *			 name="value",foo="bar"
 *			  name = value ,  foo = bar
 *			   name = "value" ,  foo = "bar"
 *
 * ON EXIT:
 *	returns a list of name-value pairs (actually HTAssocList*).
 *		For items with no name, just value, the name is
 *		the number of order number of that item. E.g.
 *		"1" for the first, etc.
 */
HTAssocList *HTAA_parseArgList(char *str)
{
    HTAssocList *assoc_list = HTAssocList_new();
    char *cur = NULL;
    char *name = NULL;
    int n = 0;

    if (!str)
	return assoc_list;

    while (*str) {
	SKIPWS(str);		/* Skip leading whitespace */
	cur = str;
	n++;

	while (*cur && *cur != '=' && *cur != ',')
	    cur++;		/* Find end of name (or lonely value without a name) */
	KILLWS(cur);		/* Kill trailing whitespace */

	if (*cur == '=') {	/* Name followed by a value */
	    *(cur++) = '\0';	/* Terminate name */
	    StrAllocCopy(name, str);
	    SKIPWS(cur);	/* Skip WS leading the value */
	    str = cur;
	    if (*str == '"') {	/* Quoted value */
		str++;
		cur = str;
		while (*cur && *cur != '"')
		    cur++;
		if (*cur == '"')
		    *(cur++) = '\0';	/* Terminate value */
		/* else it is lacking terminating quote */
		SKIPWS(cur);	/* Skip WS leading comma */
		if (*cur == ',')
		    cur++;	/* Skip separating colon */
	    } else {		/* Unquoted value */
		while (*cur && *cur != ',')
		    cur++;
		KILLWS(cur);	/* Kill trailing whitespace */
		if (*cur == ',')
		    *(cur++) = '\0';
		/* else *cur already NULL */
	    }
	} else {		/* No name, just a value */
	    if (*cur == ',')
		*(cur++) = '\0';	/* Terminate value */
	    /* else last value on line (already terminated by NULL) */
	    HTSprintf0(&name, "%d", n);		/* Item order number for name */
	}
	HTAssocList_add(assoc_list, name, str);
	str = cur;
    }				/* while *str */

    FREE(name);
    return assoc_list;
}

/************** HEADER LINE READER -- DOES UNFOLDING *************************/

#define BUFFER_SIZE	1024

static size_t buffer_length;
static char *buffer = 0;
static char *start_pointer;
static char *end_pointer;
static int in_soc = -1;

#ifdef LY_FIND_LEAKS
static void FreeHTAAUtil(void)
{
    FREE(buffer);
}
#endif /* LY_FIND_LEAKS */

/* PUBLIC						HTAA_setupReader()
 *		SET UP HEADER LINE READER, i.e., give
 *		the already-read-but-not-yet-processed
 *		buffer of text to be read before more
 *		is read from the socket.
 * ON ENTRY:
 *	start_of_headers is a pointer to a buffer containing
 *			the beginning of the header lines
 *			(rest will be read from a socket).
 *	length		is the number of valid characters in
 *			'start_of_headers' buffer.
 *	soc		is the socket to use when start_of_headers
 *			buffer is used up.
 * ON EXIT:
 *	returns		nothing.
 *			Subsequent calls to HTAA_getUnfoldedLine()
 *			will use this buffer first and then
 *			proceed to read from socket.
 */
void HTAA_setupReader(char *start_of_headers,
		      int length,
		      int soc)
{
    if (!start_of_headers)
	length = 0;		/* initialize length (is this reached at all?) */
    if (buffer == NULL) {	/* first call? */
	buffer_length = length;
	if (buffer_length < BUFFER_SIZE)	/* would fall below BUFFER_SIZE? */
	    buffer_length = BUFFER_SIZE;
	buffer = (char *) malloc((size_t) (sizeof(char) * (buffer_length + 1)));
    } else if (length > (int) buffer_length) {	/* need more space? */
	buffer_length = length;
	buffer = (char *) realloc((char *) buffer,
				  (size_t) (sizeof(char) * (buffer_length + 1)));
    }
    if (buffer == NULL)
	outofmem(__FILE__, "HTAA_setupReader");
#ifdef LY_FIND_LEAKS
    atexit(FreeHTAAUtil);
#endif
    start_pointer = buffer;
    if (start_of_headers) {
	strncpy(buffer, start_of_headers, length);
	buffer[length] = '\0';
	end_pointer = buffer + length;
    } else {
	*start_pointer = '\0';
	end_pointer = start_pointer;
    }
    in_soc = soc;
}

/* PUBLIC						HTAA_getUnfoldedLine()
 *		READ AN UNFOLDED HEADER LINE FROM SOCKET
 * ON ENTRY:
 *	HTAA_setupReader must absolutely be called before
 *	this function to set up internal buffer.
 *
 * ON EXIT:
 *	returns a newly-allocated character string representing
 *		the read line.	The line is unfolded, i.e.
 *		lines that begin with whitespace are appended
 *		to current line.  E.g.
 *
 *			Field-Name: Blaa-Blaa
 *			 This-Is-A-Continuation-Line
 *			 Here-Is_Another
 *
 *		is seen by the caller as:
 *
 *	Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
 *
 */
char *HTAA_getUnfoldedLine(void)
{
    char *line = NULL;
    char *cur;
    int count;
    BOOL peek_for_folding = NO;

    if (in_soc < 0) {
	CTRACE((tfp, "%s %s\n",
		"HTAA_getUnfoldedLine: buffer not initialized",
		"with function HTAA_setupReader()"));
	return NULL;
    }

    for (;;) {

	/* Reading from socket */

	if (start_pointer >= end_pointer) {	/*Read the next block and continue */
#ifdef USE_SSL
	    if (SSL_handle)
		count = SSL_read(SSL_handle, buffer, BUFFER_SIZE);
	    else
		count = NETREAD(in_soc, buffer, BUFFER_SIZE);
#else
	    count = NETREAD(in_soc, buffer, BUFFER_SIZE);
#endif /* USE_SSL */
	    if (count <= 0) {
		in_soc = -1;
		return line;
	    }
	    start_pointer = buffer;
	    end_pointer = buffer + count;
	    *end_pointer = '\0';
#ifdef NOT_ASCII
	    cur = start_pointer;
	    while (cur < end_pointer) {
		*cur = TOASCII(*cur);
		cur++;
	    }
#endif /*NOT_ASCII */
	}
	cur = start_pointer;

	/* Unfolding */

	if (peek_for_folding) {
	    if (*cur != ' ' && *cur != '\t')
		return line;	/* Ok, no continuation line */
	    else		/* So this is a continuation line, continue */
		peek_for_folding = NO;
	}

	/* Finding end-of-line */

	while (cur < end_pointer && *cur != '\n')	/* Find the end-of-line */
	    cur++;		/* (or end-of-buffer).  */

	/* Terminating line */

	if (cur < end_pointer) {	/* So *cur==LF, terminate line */
	    *cur = '\0';	/* Overwrite LF */
	    if (*(cur - 1) == '\r')
		*(cur - 1) = '\0';	/* Overwrite CR */
	    peek_for_folding = YES;	/* Check for a continuation line */
	}

	/* Copying the result */

	if (line)
	    StrAllocCat(line, start_pointer);	/* Append */
	else
	    StrAllocCopy(line, start_pointer);	/* A new line */

	start_pointer = cur + 1;	/* Skip the read line */

    }				/* forever */
}
@


1.5
log
@automatic merge of lynx-current
@
text
@d107 1
a107 1
char *HTAAScheme_name(HTAAScheme scheme)
d159 1
a159 1
char *HTAAMethod_name(HTAAMethod method)
d208 1
a208 1
 *	template	is a template string to match the file name
d219 1
a219 1
BOOL HTAA_templateMatch(const char *template,
d222 1
a222 1
    const char *p = template;
d269 1
a269 1
BOOL HTAA_templateCaseMatch(const char *template,
d272 1
a272 1
    const char *p = template;
d318 1
a318 1
    char *template = NULL;
d322 2
a323 2
	StrAllocCopy(template, docname);
	slash = strrchr(template, '/');
d327 1
a327 1
	    slash = template;
d329 1
a329 1
	StrAllocCat(template, "*");
d331 1
a331 1
	StrAllocCopy(template, "*");
d334 1
a334 1
	    template, docname));
d336 1
a336 1
    return template;
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 43
a44 43
**		COMMON PARTS OF ACCESS AUTHORIZATION MODULE
**			FOR BOTH SERVER AND BROWSER
**
** IMPORTANT:
**	Routines in this module use dynamic allocation, but free
**	automatically all the memory reserved by them.
**
**	Therefore the caller never has to (and never should)
**	free() any object returned by these functions.
**
**	Therefore also all the strings returned by this package
**	are only valid until the next call to the same function
**	is made.  This approach is selected, because of the nature
**	of access authorization: no string returned by the package
**	needs to be valid longer than until the next call.
**
**	This also makes it easy to plug the AA package in:
**	you don't have to ponder whether to free() something
**	here or is it done somewhere else (because it is always
**	done somewhere else).
**
**	The strings that the package needs to store are copied
**	so the original strings given as parameters to AA
**	functions may be freed or modified with no side effects.
**
**	The AA package does not free() anything else than what
**	it has itself allocated.
**
**	AA (Access Authorization) package means modules which
**	names start with HTAA.
**
** AUTHORS:
**	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
**	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
**
** HISTORY:
**	 8 Nov 93  MD	(VMS only) Added case insensitive comparison in HTAA_templateCaseMatch
**
**
** BUGS:
**
**
*/
d48 2
a49 2
#include <HTAAUtil.h>	/* Implemented here	*/
#include <HTAssoc.h>	/* Assoc list		*/
d57 10
a66 10
**		TRANSLATE SCHEME NAME INTO
**		A SCHEME ENUMERATION
**
** ON ENTRY:
**	name		is a string representing the scheme name.
**
** ON EXIT:
**	returns		the enumerated constant for that scheme.
*/
HTAAScheme HTAAScheme_enum (const char* name)
a96 1

d98 10
a107 10
**			GET THE NAME OF A GIVEN SCHEME
** ON ENTRY:
**	scheme		is one of the scheme enum values:
**			HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
**
** ON EXIT:
**	returns		the name of the scheme, i.e.
**			"None", "Basic", "Pubkey", ...
*/
char *HTAAScheme_name (HTAAScheme scheme)
d110 14
a123 14
	case HTAA_NONE:
	    return "None";
	case HTAA_BASIC:
	    return "Basic";
	case HTAA_PUBKEY:
	    return "Pubkey";
	case HTAA_KERBEROS_V4:
	    return "KerberosV4";
	case HTAA_KERBEROS_V5:
	    return "KerberosV5";
	case HTAA_UNKNOWN:
	    return "UNKNOWN";
	default:
	    return "THIS-IS-A-BUG";
a126 1

d128 9
a136 9
**		TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
** ON ENTRY:
**	name		is the method name to translate.
**
** ON EXIT:
**	returns		HTAAMethod enumerated value corresponding
**			to the given name.
*/
HTAAMethod HTAAMethod_enum (const char * name)
d141 1
a141 1
    if (0==strcasecomp(name, "GET"))
d143 1
a143 1
    else if (0==strcasecomp(name, "PUT"))
a148 1

d150 10
a159 10
**			GET THE NAME OF A GIVEN METHOD
** ON ENTRY:
**	method		is one of the method enum values:
**			METHOD_GET, METHOD_PUT, ...
**
** ON EXIT:
**	returns		the name of the scheme, i.e.
**			"GET", "PUT", ...
*/
char *HTAAMethod_name (HTAAMethod method)
d162 8
a169 8
      case METHOD_GET:
	  return "GET";
      case METHOD_PUT:
	  return "PUT";
      case METHOD_UNKNOWN:
	  return "UNKNOWN";
      default:
	  return "THIS-IS-A-BUG";
a172 1

d174 10
a183 11
**		IS A METHOD IN A LIST OF METHOD NAMES
** ON ENTRY:
**	method		is the method to look for.
**	list		is a list of method names.
**
** ON EXIT:
**	returns		YES, if method was found.
**			NO, if not found.
*/
BOOL HTAAMethod_inList (HTAAMethod method,
				    HTList *	list)
d188 1
a188 1
    while (NULL != (item = (char*)HTList_nextObject(cur))) {
d194 1
a194 1
    return NO;	/* Not found */
a196 1

d198 23
a220 23
**		STRING COMPARISON FUNCTION FOR FILE NAMES
**		   WITH ONE WILDCARD * IN THE TEMPLATE
** NOTE:
**	This is essentially the same code as in HTRules.c, but it
**	cannot be used because it is embedded in between other code.
**	(In fact, HTRules.c should use this routine, but then this
**	 routine would have to be more sophisticated... why is life
**	 sometimes so hard...)
**
** ON ENTRY:
**	template	is a template string to match the file name
**			against, may contain a single wildcard
**			character * which matches zero or more
**			arbitrary characters.
**	filename	is the filename (or pathname) to be matched
**			against the template.
**
** ON EXIT:
**	returns		YES, if filename matches the template.
**			NO, otherwise.
*/
BOOL HTAA_templateMatch (const char * template,
				     const char * filename)
d226 2
a227 2
    for (; *p  &&  *q  &&  *p == *q; p++, q++)	/* Find first mismatch */
	; /* do nothing else */
d230 3
a232 3
	return YES;			/* Equally long equal strings */
    else if ('*' == *p) {		/* Wildcard */
	p++;				/* Skip wildcard character */
d235 1
a235 1
	    return NO;			/* No match, filename too short */
d237 1
a237 1
	    if (strcmp(p, q+m))
d242 2
a243 2
    }	/* if wildcard */
    else
a246 1

d248 23
a270 23
**		STRING COMPARISON FUNCTION FOR FILE NAMES
**		   WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
** NOTE:
**	This is essentially the same code as in HTAA_templateMatch, but
**	it compares case insensitive (for VMS). Reason for this routine
**	is that HTAA_templateMatch gets called from several places, also
**	there where a case sensitive match is needed, so one cannot just
**	change the HTAA_templateMatch routine for VMS.
**
** ON ENTRY:
**	template	is a template string to match the file name
**			against, may contain a single wildcard
**			character * which matches zero or more
**			arbitrary characters.
**	filename	is the filename (or pathname) to be matched
**			against the template.
**
** ON EXIT:
**	returns		YES, if filename matches the template.
**			NO, otherwise.
*/
BOOL HTAA_templateCaseMatch (const char * template,
					 const char * filename)
d277 1
a277 2
    for (; *p  &&  *q  &&  TOUPPER(*p) == TOUPPER(*q); p++, q++)
	; /* do nothing else */
d280 3
a282 3
	return YES;			/* Equally long equal strings */
    else if ('*' == *p) {		/* Wildcard */
	p++;				/* Skip wildcard character */
d285 1
a285 1
	    return NO;			/* No match, filename too short */
d287 1
a287 1
	    if (strcasecomp(p, q+m))
d292 2
a293 2
    }	/* if wildcard */
    else
a296 1

d298 19
a316 19
**		CREATE A PROTECTION TEMPLATE FOR THE FILES
**		IN THE SAME DIRECTORY AS THE GIVEN FILE
**		(Used by server if there is no fancier way for
**		it to tell the client, and by browser if server
**		didn't send WWW-ProtectionTemplate: field)
** ON ENTRY:
**	docname is the document pathname (from URL).
**
** ON EXIT:
**	returns a template matching docname, and other files
**		files in that directory.
**
**		E.g.  /foo/bar/x.html  =>  /foo/bar/ *
**						    ^
**				Space only to prevent it from
**				being a comment marker here,
**				there really isn't any space.
*/
char *HTAA_makeProtectionTemplate (const char * docname)
d330 1
a330 2
    }
    else
d334 1
a334 1
		template, docname));
a338 1

d340 2
a341 2
** Skip leading whitespace from *s forward
*/
d345 2
a346 2
** Kill trailing whitespace starting from *(s-1) backwards
*/
a348 1

d350 26
a375 26
**		PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
** ON ENTRY:
**	str	is a comma-separated list:
**
**			item, item, item
**		where
**			item ::= value
**			       | name=value
**			       | name="value"
**
**		Leading and trailing whitespace is ignored
**		everywhere except inside quotes, so the following
**		examples are equal:
**
**			name=value,foo=bar
**			 name="value",foo="bar"
**			  name = value ,  foo = bar
**			   name = "value" ,  foo = "bar"
**
** ON EXIT:
**	returns a list of name-value pairs (actually HTAssocList*).
**		For items with no name, just value, the name is
**		the number of order number of that item. E.g.
**		"1" for the first, etc.
*/
HTAssocList *HTAA_parseArgList (char * str)
d386 1
a386 1
	SKIPWS(str);				/* Skip leading whitespace */
d390 3
a392 3
	while (*cur  &&  *cur != '='  &&  *cur != ',')
	    cur++;	/* Find end of name (or lonely value without a name) */
	KILLWS(cur);	/* Kill trailing whitespace */
d394 2
a395 2
	if (*cur == '=') {			/* Name followed by a value */
	    *(cur++) = '\0';			/* Terminate name */
d397 1
a397 1
	    SKIPWS(cur);			/* Skip WS leading the value */
d399 1
a399 1
	    if (*str == '"') {			/* Quoted value */
d402 1
a402 1
		while (*cur  &&  *cur != '"')
d405 1
a405 1
		    *(cur++) = '\0';		/* Terminate value */
d407 1
a407 1
		SKIPWS(cur);			/* Skip WS leading comma */
d409 3
a411 4
		    cur++;			/* Skip separating colon */
	    }
	    else {				/* Unquoted value */
		while (*cur  &&  *cur != ',')
d413 1
a413 1
		KILLWS(cur);			/* Kill trailing whitespace */
d418 1
a418 2
	}
	else {	/* No name, just a value */
d420 1
a420 1
		*(cur++) = '\0';		/* Terminate value */
d426 1
a426 1
    } /* while *str */
a431 1

d443 1
a443 1
static void FreeHTAAUtil (void)
d450 21
a470 21
**		SET UP HEADER LINE READER, i.e., give
**		the already-read-but-not-yet-processed
**		buffer of text to be read before more
**		is read from the socket.
** ON ENTRY:
**	start_of_headers is a pointer to a buffer containing
**			the beginning of the header lines
**			(rest will be read from a socket).
**	length		is the number of valid characters in
**			'start_of_headers' buffer.
**	soc		is the socket to use when start_of_headers
**			buffer is used up.
** ON EXIT:
**	returns		nothing.
**			Subsequent calls to HTAA_getUnfoldedLine()
**			will use this buffer first and then
**			proceed to read from socket.
*/
void HTAA_setupReader (char *	start_of_headers,
				   int		length,
				   int		soc)
d473 2
a474 2
	length = 0;	       /* initialize length (is this reached at all?) */
    if (buffer == NULL) {				       /* first call? */
d476 1
a476 1
	if (buffer_length < BUFFER_SIZE)     /* would fall below BUFFER_SIZE? */
d478 2
a479 3
	buffer = (char*)malloc((size_t)(sizeof(char)*(buffer_length + 1)));
    }
    else if (length > (int)buffer_length) {		  /* need more space? */
d481 2
a482 2
	buffer = (char*)realloc((char*)buffer,
				(size_t)(sizeof(char)*(buffer_length + 1)));
d484 2
a485 1
    if (buffer == NULL) outofmem(__FILE__, "HTAA_setupReader");
d494 1
a494 2
    }
    else {
a500 1

d502 21
a522 21
**		READ AN UNFOLDED HEADER LINE FROM SOCKET
** ON ENTRY:
**	HTAA_setupReader must absolutely be called before
**	this function to set up internal buffer.
**
** ON EXIT:
**	returns a newly-allocated character string representing
**		the read line.	The line is unfolded, i.e.
**		lines that begin with whitespace are appended
**		to current line.  E.g.
**
**			Field-Name: Blaa-Blaa
**			 This-Is-A-Continuation-Line
**			 Here-Is_Another
**
**		is seen by the caller as:
**
**	Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
**
*/
char *HTAA_getUnfoldedLine (void)
d531 2
a532 2
		    "HTAA_getUnfoldedLine: buffer not initialized",
		    "with function HTAA_setupReader()"));
d536 1
a536 1
    for(;;) {
d540 1
a540 1
	if (start_pointer >= end_pointer) {/*Read the next block and continue*/
d562 1
a562 1
#endif /*NOT_ASCII*/
a565 1

d569 1
a569 1
	    if (*cur != ' '  &&  *cur != '\t')
a574 1

d577 2
a578 3
	while (cur < end_pointer && *cur != '\n') /* Find the end-of-line */
	    cur++;				  /* (or end-of-buffer).  */

d583 3
a585 3
	    *cur = '\0';		/* Overwrite LF */
	    if (*(cur-1) == '\r')
		*(cur-1) = '\0';	/* Overwrite CR */
a588 1

d596 1
a596 1
	start_pointer = cur+1;	/* Skip the read line */
d598 1
a598 1
    } /* forever */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d66 1
a66 1
PUBLIC HTAAScheme HTAAScheme_enum ARGS1(CONST char*, name)
d108 1
a108 1
PUBLIC char *HTAAScheme_name ARGS1(HTAAScheme, scheme)
d138 1
a138 1
PUBLIC HTAAMethod HTAAMethod_enum ARGS1(CONST char *, name)
d162 1
a162 1
PUBLIC char *HTAAMethod_name ARGS1(HTAAMethod, method)
d187 2
a188 2
PUBLIC BOOL HTAAMethod_inList ARGS2(HTAAMethod, method,
				    HTList *,	list)
d225 2
a226 2
PUBLIC BOOL HTAA_templateMatch ARGS2(CONST char *, template,
				     CONST char *, filename)
d228 2
a229 2
    CONST char *p = template;
    CONST char *q = filename;
d276 2
a277 2
PUBLIC BOOL HTAA_templateCaseMatch ARGS2(CONST char *, template,
					 CONST char *, filename)
d279 2
a280 2
    CONST char *p = template;
    CONST char *q = filename;
d325 1
a325 1
PUBLIC char *HTAA_makeProtectionTemplate ARGS1(CONST char *, docname)
d387 1
a387 1
PUBLIC HTAssocList *HTAA_parseArgList ARGS1(char *, str)
d451 5
a455 5
PRIVATE size_t buffer_length;
PRIVATE char *buffer = 0;
PRIVATE char *start_pointer;
PRIVATE char *end_pointer;
PRIVATE int in_soc = -1;
d458 1
a458 1
PRIVATE void FreeHTAAUtil NOARGS
d483 3
a485 3
PUBLIC void HTAA_setupReader ARGS3(char *,	start_of_headers,
				   int,		length,
				   int,		soc)
d539 1
a539 1
PUBLIC char *HTAA_getUnfoldedLine NOARGS
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d51 1
a51 7

#ifdef USE_SSL
#define free_func free__func
#include <openssl/ssl.h>
#undef free_func
PRIVATE SSL * Handle = NULL;	/* The SSL Handle	*/
#endif /* USE_SSL */
d194 1
a194 1
	CTRACE(tfp, " %s", item);
d343 2
a344 2
    CTRACE(tfp, "make_template: made template `%s' for file `%s'\n",
		template, docname);
d547 1
a547 1
	CTRACE(tfp, "%s %s\n",
d549 1
a549 1
		    "with function HTAA_setupReader()");
d559 2
a560 2
	    if (Handle)
		count = SSL_read(Handle, buffer, BUFFER_SIZE);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 43
a44 43
 *		COMMON PARTS OF ACCESS AUTHORIZATION MODULE
 *			FOR BOTH SERVER AND BROWSER
 *
 * IMPORTANT:
 *	Routines in this module use dynamic allocation, but free
 *	automatically all the memory reserved by them.
 *
 *	Therefore the caller never has to (and never should)
 *	free() any object returned by these functions.
 *
 *	Therefore also all the strings returned by this package
 *	are only valid until the next call to the same function
 *	is made.  This approach is selected, because of the nature
 *	of access authorization: no string returned by the package
 *	needs to be valid longer than until the next call.
 *
 *	This also makes it easy to plug the AA package in:
 *	you don't have to ponder whether to free() something
 *	here or is it done somewhere else (because it is always
 *	done somewhere else).
 *
 *	The strings that the package needs to store are copied
 *	so the original strings given as parameters to AA
 *	functions may be freed or modified with no side effects.
 *
 *	The AA package does not free() anything else than what
 *	it has itself allocated.
 *
 *	AA (Access Authorization) package means modules which
 *	names start with HTAA.
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	 8 Nov 93  MD	(VMS only) Added case insensitive comparison in HTAA_templateCaseMatch
 *
 *
 * BUGS:
 *
 *
 */
d48 2
a49 2
#include <HTAAUtil.h>		/* Implemented here     */
#include <HTAssoc.h>		/* Assoc list           */
d51 7
a57 1
#include <HTTP.h>
d63 10
a72 10
 *		TRANSLATE SCHEME NAME INTO
 *		A SCHEME ENUMERATION
 *
 * ON ENTRY:
 *	name		is a string representing the scheme name.
 *
 * ON EXIT:
 *	returns		the enumerated constant for that scheme.
 */
HTAAScheme HTAAScheme_enum(const char *name)
d103 1
d105 10
a114 10
 *			GET THE NAME OF A GIVEN SCHEME
 * ON ENTRY:
 *	scheme		is one of the scheme enum values:
 *			HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"None", "Basic", "Pubkey", ...
 */
const char *HTAAScheme_name(HTAAScheme scheme)
d117 14
a130 14
    case HTAA_NONE:
	return "None";
    case HTAA_BASIC:
	return "Basic";
    case HTAA_PUBKEY:
	return "Pubkey";
    case HTAA_KERBEROS_V4:
	return "KerberosV4";
    case HTAA_KERBEROS_V5:
	return "KerberosV5";
    case HTAA_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
d134 1
d136 9
a144 9
 *		TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
 * ON ENTRY:
 *	name		is the method name to translate.
 *
 * ON EXIT:
 *	returns		HTAAMethod enumerated value corresponding
 *			to the given name.
 */
HTAAMethod HTAAMethod_enum(const char *name)
d149 1
a149 1
    if (0 == strcasecomp(name, "GET"))
d151 1
a151 1
    else if (0 == strcasecomp(name, "PUT"))
d157 1
d159 10
a168 10
 *			GET THE NAME OF A GIVEN METHOD
 * ON ENTRY:
 *	method		is one of the method enum values:
 *			METHOD_GET, METHOD_PUT, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"GET", "PUT", ...
 */
const char *HTAAMethod_name(HTAAMethod method)
d171 8
a178 8
    case METHOD_GET:
	return "GET";
    case METHOD_PUT:
	return "PUT";
    case METHOD_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
d182 1
d184 11
a194 10
 *		IS A METHOD IN A LIST OF METHOD NAMES
 * ON ENTRY:
 *	method		is the method to look for.
 *	list		is a list of method names.
 *
 * ON EXIT:
 *	returns		YES, if method was found.
 *			NO, if not found.
 */
BOOL HTAAMethod_inList(HTAAMethod method, HTList *list)
d199 2
a200 2
    while (NULL != (item = (char *) HTList_nextObject(cur))) {
	CTRACE((tfp, " %s", item));
d205 1
a205 1
    return NO;			/* Not found */
d208 1
d210 23
a232 23
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE
 * NOTE:
 *	This is essentially the same code as in HTRules.c, but it
 *	cannot be used because it is embedded in between other code.
 *	(In fact, HTRules.c should use this routine, but then this
 *	 routine would have to be more sophisticated... why is life
 *	 sometimes so hard...)
 *
 * ON ENTRY:
 *	ctemplate	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateMatch(const char *ctemplate,
			const char *filename)
d234 2
a235 2
    const char *p = ctemplate;
    const char *q = filename;
d238 2
a239 2
    for (; *p && *q && *p == *q; p++, q++)	/* Find first mismatch */
	;			/* do nothing else */
d242 3
a244 3
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
d247 1
a247 1
	    return NO;		/* No match, filename too short */
d249 1
a249 1
	    if (strcmp(p, q + m))
d254 2
a255 2
	/* if wildcard */
    } else
d259 1
d261 23
a283 23
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
 * NOTE:
 *	This is essentially the same code as in HTAA_templateMatch, but
 *	it compares case insensitive (for VMS). Reason for this routine
 *	is that HTAA_templateMatch gets called from several places, also
 *	there where a case sensitive match is needed, so one cannot just
 *	change the HTAA_templateMatch routine for VMS.
 *
 * ON ENTRY:
 *	template	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateCaseMatch(const char *ctemplate,
			    const char *filename)
d285 2
a286 2
    const char *p = ctemplate;
    const char *q = filename;
d290 2
a291 1
    for (; *p && *q && TOUPPER(*p) == TOUPPER(*q); p++, q++) ;	/* do nothing else */
d294 3
a296 3
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
d299 1
a299 1
	    return NO;		/* No match, filename too short */
d301 1
a301 1
	    if (strcasecomp(p, q + m))
d306 2
a307 2
	/* if wildcard */
    } else
d311 1
d313 19
a331 19
 *		CREATE A PROTECTION TEMPLATE FOR THE FILES
 *		IN THE SAME DIRECTORY AS THE GIVEN FILE
 *		(Used by server if there is no fancier way for
 *		it to tell the client, and by browser if server
 *		didn't send WWW-ProtectionTemplate: field)
 * ON ENTRY:
 *	docname is the document pathname (from URL).
 *
 * ON EXIT:
 *	returns a template matching docname, and other files
 *		files in that directory.
 *
 *		E.g.  /foo/bar/x.html  =>  /foo/bar/ *
 *						    ^
 *				Space only to prevent it from
 *				being a comment marker here,
 *				there really isn't any space.
 */
char *HTAA_makeProtectionTemplate(const char *docname)
d333 1
a333 1
    char *ctemplate = NULL;
d337 2
a338 2
	StrAllocCopy(ctemplate, docname);
	slash = strrchr(ctemplate, '/');
d342 1
a342 1
	    slash = ctemplate;
d344 4
a347 3
	StrAllocCat(ctemplate, "*");
    } else
	StrAllocCopy(ctemplate, "*");
d349 2
a350 2
    CTRACE((tfp, "make_template: made template `%s' for file `%s'\n",
	    ctemplate, docname));
d352 1
a352 1
    return ctemplate;
d355 1
d357 2
a358 2
 * Skip leading whitespace from *s forward
 */
d362 2
a363 2
 * Kill trailing whitespace starting from *(s-1) backwards
 */
d366 1
d368 26
a393 26
 *		PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
 * ON ENTRY:
 *	str	is a comma-separated list:
 *
 *			item, item, item
 *		where
 *			item ::= value
 *			       | name=value
 *			       | name="value"
 *
 *		Leading and trailing whitespace is ignored
 *		everywhere except inside quotes, so the following
 *		examples are equal:
 *
 *			name=value,foo=bar
 *			 name="value",foo="bar"
 *			  name = value ,  foo = bar
 *			   name = "value" ,  foo = "bar"
 *
 * ON EXIT:
 *	returns a list of name-value pairs (actually HTAssocList*).
 *		For items with no name, just value, the name is
 *		the number of order number of that item. E.g.
 *		"1" for the first, etc.
 */
HTAssocList *HTAA_parseArgList(char *str)
d404 1
a404 1
	SKIPWS(str);		/* Skip leading whitespace */
d408 3
a410 3
	while (*cur && *cur != '=' && *cur != ',')
	    cur++;		/* Find end of name (or lonely value without a name) */
	KILLWS(cur);		/* Kill trailing whitespace */
d412 2
a413 2
	if (*cur == '=') {	/* Name followed by a value */
	    *(cur++) = '\0';	/* Terminate name */
d415 1
a415 1
	    SKIPWS(cur);	/* Skip WS leading the value */
d417 1
a417 1
	    if (*str == '"') {	/* Quoted value */
d420 1
a420 1
		while (*cur && *cur != '"')
d423 1
a423 1
		    *(cur++) = '\0';	/* Terminate value */
d425 1
a425 1
		SKIPWS(cur);	/* Skip WS leading comma */
d427 4
a430 3
		    cur++;	/* Skip separating colon */
	    } else {		/* Unquoted value */
		while (*cur && *cur != ',')
d432 1
a432 1
		KILLWS(cur);	/* Kill trailing whitespace */
d437 2
a438 1
	} else {		/* No name, just a value */
d440 1
a440 1
		*(cur++) = '\0';	/* Terminate value */
d446 1
a446 1
    }				/* while *str */
d452 1
d457 5
a461 5
static size_t buffer_length;
static char *buffer = 0;
static char *start_pointer;
static char *end_pointer;
static int in_soc = -1;
d464 1
a464 1
static void FreeHTAAUtil(void)
d471 21
a491 21
 *		SET UP HEADER LINE READER, i.e., give
 *		the already-read-but-not-yet-processed
 *		buffer of text to be read before more
 *		is read from the socket.
 * ON ENTRY:
 *	start_of_headers is a pointer to a buffer containing
 *			the beginning of the header lines
 *			(rest will be read from a socket).
 *	length		is the number of valid characters in
 *			'start_of_headers' buffer.
 *	soc		is the socket to use when start_of_headers
 *			buffer is used up.
 * ON EXIT:
 *	returns		nothing.
 *			Subsequent calls to HTAA_getUnfoldedLine()
 *			will use this buffer first and then
 *			proceed to read from socket.
 */
void HTAA_setupReader(char *start_of_headers,
		      int length,
		      int soc)
d494 2
a495 2
	length = 0;		/* initialize length (is this reached at all?) */
    if (buffer == NULL) {	/* first call? */
d497 1
a497 1
	if (buffer_length < BUFFER_SIZE)	/* would fall below BUFFER_SIZE? */
d499 3
a501 2
	buffer = (char *) malloc((size_t) (sizeof(char) * (buffer_length + 1)));
    } else if (length > (int) buffer_length) {	/* need more space? */
d503 2
a504 2
	buffer = (char *) realloc((char *) buffer,
				  (size_t) (sizeof(char) * (buffer_length + 1)));
d506 1
a506 2
    if (buffer == NULL)
	outofmem(__FILE__, "HTAA_setupReader");
d515 2
a516 1
    } else {
d523 1
d525 21
a545 21
 *		READ AN UNFOLDED HEADER LINE FROM SOCKET
 * ON ENTRY:
 *	HTAA_setupReader must absolutely be called before
 *	this function to set up internal buffer.
 *
 * ON EXIT:
 *	returns a newly-allocated character string representing
 *		the read line.	The line is unfolded, i.e.
 *		lines that begin with whitespace are appended
 *		to current line.  E.g.
 *
 *			Field-Name: Blaa-Blaa
 *			 This-Is-A-Continuation-Line
 *			 Here-Is_Another
 *
 *		is seen by the caller as:
 *
 *	Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
 *
 */
char *HTAA_getUnfoldedLine(void)
d553 3
a555 3
	CTRACE((tfp, "%s %s\n",
		"HTAA_getUnfoldedLine: buffer not initialized",
		"with function HTAA_setupReader()"));
d559 1
a559 1
    for (;;) {
d563 1
a563 1
	if (start_pointer >= end_pointer) {	/*Read the next block and continue */
d565 2
a566 2
	    if (SSL_handle)
		count = SSL_read(SSL_handle, buffer, BUFFER_SIZE);
d585 1
a585 1
#endif /*NOT_ASCII */
d589 1
d593 1
a593 1
	    if (*cur != ' ' && *cur != '\t')
d599 1
d602 3
a604 2
	while (cur < end_pointer && *cur != '\n')	/* Find the end-of-line */
	    cur++;		/* (or end-of-buffer).  */
d609 3
a611 3
	    *cur = '\0';	/* Overwrite LF */
	    if (*(cur - 1) == '\r')
		*(cur - 1) = '\0';	/* Overwrite CR */
d615 1
d623 1
a623 1
	start_pointer = cur + 1;	/* Skip the read line */
d625 1
a625 1
    }				/* forever */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d51 7
a57 1
#include <HTTP.h>
d200 1
a200 1
	CTRACE((tfp, " %s", item));
d349 2
a350 2
    CTRACE((tfp, "make_template: made template `%s' for file `%s'\n",
		template, docname));
d553 1
a553 1
	CTRACE((tfp, "%s %s\n",
d555 1
a555 1
		    "with function HTAA_setupReader()"));
d565 2
a566 2
	    if (SSL_handle)
		count = SSL_read(SSL_handle, buffer, BUFFER_SIZE);
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d66 1
a66 1
HTAAScheme HTAAScheme_enum (const char* name)
d108 1
a108 1
char *HTAAScheme_name (HTAAScheme scheme)
d138 1
a138 1
HTAAMethod HTAAMethod_enum (const char * name)
d162 1
a162 1
char *HTAAMethod_name (HTAAMethod method)
d187 2
a188 2
BOOL HTAAMethod_inList (HTAAMethod method,
				    HTList *	list)
d225 2
a226 2
BOOL HTAA_templateMatch (const char * template,
				     const char * filename)
d228 2
a229 2
    const char *p = template;
    const char *q = filename;
d276 2
a277 2
BOOL HTAA_templateCaseMatch (const char * template,
					 const char * filename)
d279 2
a280 2
    const char *p = template;
    const char *q = filename;
d325 1
a325 1
char *HTAA_makeProtectionTemplate (const char * docname)
d387 1
a387 1
HTAssocList *HTAA_parseArgList (char * str)
d451 5
a455 5
static size_t buffer_length;
static char *buffer = 0;
static char *start_pointer;
static char *end_pointer;
static int in_soc = -1;
d458 1
a458 1
static void FreeHTAAUtil (void)
d483 3
a485 3
void HTAA_setupReader (char *	start_of_headers,
				   int		length,
				   int		soc)
d539 1
a539 1
char *HTAA_getUnfoldedLine (void)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 43
a44 43
 *		COMMON PARTS OF ACCESS AUTHORIZATION MODULE
 *			FOR BOTH SERVER AND BROWSER
 *
 * IMPORTANT:
 *	Routines in this module use dynamic allocation, but free
 *	automatically all the memory reserved by them.
 *
 *	Therefore the caller never has to (and never should)
 *	free() any object returned by these functions.
 *
 *	Therefore also all the strings returned by this package
 *	are only valid until the next call to the same function
 *	is made.  This approach is selected, because of the nature
 *	of access authorization: no string returned by the package
 *	needs to be valid longer than until the next call.
 *
 *	This also makes it easy to plug the AA package in:
 *	you don't have to ponder whether to free() something
 *	here or is it done somewhere else (because it is always
 *	done somewhere else).
 *
 *	The strings that the package needs to store are copied
 *	so the original strings given as parameters to AA
 *	functions may be freed or modified with no side effects.
 *
 *	The AA package does not free() anything else than what
 *	it has itself allocated.
 *
 *	AA (Access Authorization) package means modules which
 *	names start with HTAA.
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	 8 Nov 93  MD	(VMS only) Added case insensitive comparison in HTAA_templateCaseMatch
 *
 *
 * BUGS:
 *
 *
 */
d48 2
a49 2
#include <HTAAUtil.h>		/* Implemented here     */
#include <HTAssoc.h>		/* Assoc list           */
d57 10
a66 10
 *		TRANSLATE SCHEME NAME INTO
 *		A SCHEME ENUMERATION
 *
 * ON ENTRY:
 *	name		is a string representing the scheme name.
 *
 * ON EXIT:
 *	returns		the enumerated constant for that scheme.
 */
HTAAScheme HTAAScheme_enum(const char *name)
d97 1
d99 10
a108 10
 *			GET THE NAME OF A GIVEN SCHEME
 * ON ENTRY:
 *	scheme		is one of the scheme enum values:
 *			HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"None", "Basic", "Pubkey", ...
 */
char *HTAAScheme_name(HTAAScheme scheme)
d111 14
a124 14
    case HTAA_NONE:
	return "None";
    case HTAA_BASIC:
	return "Basic";
    case HTAA_PUBKEY:
	return "Pubkey";
    case HTAA_KERBEROS_V4:
	return "KerberosV4";
    case HTAA_KERBEROS_V5:
	return "KerberosV5";
    case HTAA_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
d128 1
d130 9
a138 9
 *		TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
 * ON ENTRY:
 *	name		is the method name to translate.
 *
 * ON EXIT:
 *	returns		HTAAMethod enumerated value corresponding
 *			to the given name.
 */
HTAAMethod HTAAMethod_enum(const char *name)
d143 1
a143 1
    if (0 == strcasecomp(name, "GET"))
d145 1
a145 1
    else if (0 == strcasecomp(name, "PUT"))
d151 1
d153 10
a162 10
 *			GET THE NAME OF A GIVEN METHOD
 * ON ENTRY:
 *	method		is one of the method enum values:
 *			METHOD_GET, METHOD_PUT, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"GET", "PUT", ...
 */
char *HTAAMethod_name(HTAAMethod method)
d165 8
a172 8
    case METHOD_GET:
	return "GET";
    case METHOD_PUT:
	return "PUT";
    case METHOD_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
d176 1
d178 11
a188 10
 *		IS A METHOD IN A LIST OF METHOD NAMES
 * ON ENTRY:
 *	method		is the method to look for.
 *	list		is a list of method names.
 *
 * ON EXIT:
 *	returns		YES, if method was found.
 *			NO, if not found.
 */
BOOL HTAAMethod_inList(HTAAMethod method, HTList *list)
d193 1
a193 1
    while (NULL != (item = (char *) HTList_nextObject(cur))) {
d199 1
a199 1
    return NO;			/* Not found */
d202 1
d204 23
a226 23
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE
 * NOTE:
 *	This is essentially the same code as in HTRules.c, but it
 *	cannot be used because it is embedded in between other code.
 *	(In fact, HTRules.c should use this routine, but then this
 *	 routine would have to be more sophisticated... why is life
 *	 sometimes so hard...)
 *
 * ON ENTRY:
 *	template	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateMatch(const char *template,
			const char *filename)
d232 2
a233 2
    for (; *p && *q && *p == *q; p++, q++)	/* Find first mismatch */
	;			/* do nothing else */
d236 3
a238 3
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
d241 1
a241 1
	    return NO;		/* No match, filename too short */
d243 1
a243 1
	    if (strcmp(p, q + m))
d248 2
a249 2
	/* if wildcard */
    } else
d253 1
d255 23
a277 23
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
 * NOTE:
 *	This is essentially the same code as in HTAA_templateMatch, but
 *	it compares case insensitive (for VMS). Reason for this routine
 *	is that HTAA_templateMatch gets called from several places, also
 *	there where a case sensitive match is needed, so one cannot just
 *	change the HTAA_templateMatch routine for VMS.
 *
 * ON ENTRY:
 *	template	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateCaseMatch(const char *template,
			    const char *filename)
d284 2
a285 1
    for (; *p && *q && TOUPPER(*p) == TOUPPER(*q); p++, q++) ;	/* do nothing else */
d288 3
a290 3
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
d293 1
a293 1
	    return NO;		/* No match, filename too short */
d295 1
a295 1
	    if (strcasecomp(p, q + m))
d300 2
a301 2
	/* if wildcard */
    } else
d305 1
d307 19
a325 19
 *		CREATE A PROTECTION TEMPLATE FOR THE FILES
 *		IN THE SAME DIRECTORY AS THE GIVEN FILE
 *		(Used by server if there is no fancier way for
 *		it to tell the client, and by browser if server
 *		didn't send WWW-ProtectionTemplate: field)
 * ON ENTRY:
 *	docname is the document pathname (from URL).
 *
 * ON EXIT:
 *	returns a template matching docname, and other files
 *		files in that directory.
 *
 *		E.g.  /foo/bar/x.html  =>  /foo/bar/ *
 *						    ^
 *				Space only to prevent it from
 *				being a comment marker here,
 *				there really isn't any space.
 */
char *HTAA_makeProtectionTemplate(const char *docname)
d339 2
a340 1
    } else
d344 1
a344 1
	    template, docname));
d349 1
d351 2
a352 2
 * Skip leading whitespace from *s forward
 */
d356 2
a357 2
 * Kill trailing whitespace starting from *(s-1) backwards
 */
d360 1
d362 26
a387 26
 *		PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
 * ON ENTRY:
 *	str	is a comma-separated list:
 *
 *			item, item, item
 *		where
 *			item ::= value
 *			       | name=value
 *			       | name="value"
 *
 *		Leading and trailing whitespace is ignored
 *		everywhere except inside quotes, so the following
 *		examples are equal:
 *
 *			name=value,foo=bar
 *			 name="value",foo="bar"
 *			  name = value ,  foo = bar
 *			   name = "value" ,  foo = "bar"
 *
 * ON EXIT:
 *	returns a list of name-value pairs (actually HTAssocList*).
 *		For items with no name, just value, the name is
 *		the number of order number of that item. E.g.
 *		"1" for the first, etc.
 */
HTAssocList *HTAA_parseArgList(char *str)
d398 1
a398 1
	SKIPWS(str);		/* Skip leading whitespace */
d402 3
a404 3
	while (*cur && *cur != '=' && *cur != ',')
	    cur++;		/* Find end of name (or lonely value without a name) */
	KILLWS(cur);		/* Kill trailing whitespace */
d406 2
a407 2
	if (*cur == '=') {	/* Name followed by a value */
	    *(cur++) = '\0';	/* Terminate name */
d409 1
a409 1
	    SKIPWS(cur);	/* Skip WS leading the value */
d411 1
a411 1
	    if (*str == '"') {	/* Quoted value */
d414 1
a414 1
		while (*cur && *cur != '"')
d417 1
a417 1
		    *(cur++) = '\0';	/* Terminate value */
d419 1
a419 1
		SKIPWS(cur);	/* Skip WS leading comma */
d421 4
a424 3
		    cur++;	/* Skip separating colon */
	    } else {		/* Unquoted value */
		while (*cur && *cur != ',')
d426 1
a426 1
		KILLWS(cur);	/* Kill trailing whitespace */
d431 2
a432 1
	} else {		/* No name, just a value */
d434 1
a434 1
		*(cur++) = '\0';	/* Terminate value */
d440 1
a440 1
    }				/* while *str */
d446 1
d458 1
a458 1
static void FreeHTAAUtil(void)
d465 21
a485 21
 *		SET UP HEADER LINE READER, i.e., give
 *		the already-read-but-not-yet-processed
 *		buffer of text to be read before more
 *		is read from the socket.
 * ON ENTRY:
 *	start_of_headers is a pointer to a buffer containing
 *			the beginning of the header lines
 *			(rest will be read from a socket).
 *	length		is the number of valid characters in
 *			'start_of_headers' buffer.
 *	soc		is the socket to use when start_of_headers
 *			buffer is used up.
 * ON EXIT:
 *	returns		nothing.
 *			Subsequent calls to HTAA_getUnfoldedLine()
 *			will use this buffer first and then
 *			proceed to read from socket.
 */
void HTAA_setupReader(char *start_of_headers,
		      int length,
		      int soc)
d488 2
a489 2
	length = 0;		/* initialize length (is this reached at all?) */
    if (buffer == NULL) {	/* first call? */
d491 1
a491 1
	if (buffer_length < BUFFER_SIZE)	/* would fall below BUFFER_SIZE? */
d493 3
a495 2
	buffer = (char *) malloc((size_t) (sizeof(char) * (buffer_length + 1)));
    } else if (length > (int) buffer_length) {	/* need more space? */
d497 2
a498 2
	buffer = (char *) realloc((char *) buffer,
				  (size_t) (sizeof(char) * (buffer_length + 1)));
d500 1
a500 2
    if (buffer == NULL)
	outofmem(__FILE__, "HTAA_setupReader");
d509 2
a510 1
    } else {
d517 1
d519 21
a539 21
 *		READ AN UNFOLDED HEADER LINE FROM SOCKET
 * ON ENTRY:
 *	HTAA_setupReader must absolutely be called before
 *	this function to set up internal buffer.
 *
 * ON EXIT:
 *	returns a newly-allocated character string representing
 *		the read line.	The line is unfolded, i.e.
 *		lines that begin with whitespace are appended
 *		to current line.  E.g.
 *
 *			Field-Name: Blaa-Blaa
 *			 This-Is-A-Continuation-Line
 *			 Here-Is_Another
 *
 *		is seen by the caller as:
 *
 *	Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
 *
 */
char *HTAA_getUnfoldedLine(void)
d548 2
a549 2
		"HTAA_getUnfoldedLine: buffer not initialized",
		"with function HTAA_setupReader()"));
d553 1
a553 1
    for (;;) {
d557 1
a557 1
	if (start_pointer >= end_pointer) {	/*Read the next block and continue */
d579 1
a579 1
#endif /*NOT_ASCII */
d583 1
d587 1
a587 1
	    if (*cur != ' ' && *cur != '\t')
d593 1
d596 3
a598 2
	while (cur < end_pointer && *cur != '\n')	/* Find the end-of-line */
	    cur++;		/* (or end-of-buffer).  */
d603 3
a605 3
	    *cur = '\0';	/* Overwrite LF */
	    if (*(cur - 1) == '\r')
		*(cur - 1) = '\0';	/* Overwrite CR */
d609 1
d617 1
a617 1
	start_pointer = cur + 1;	/* Skip the read line */
d619 1
a619 1
    }				/* forever */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a50 1
#include <HTTP.h>
d53 3
d200 1
a200 1
	CTRACE((tfp, " %s", item));
d349 2
a350 2
    CTRACE((tfp, "make_template: made template `%s' for file `%s'\n",
		template, docname));
d553 1
a553 1
	CTRACE((tfp, "%s %s\n",
d555 1
a555 1
		    "with function HTAA_setupReader()"));
@

