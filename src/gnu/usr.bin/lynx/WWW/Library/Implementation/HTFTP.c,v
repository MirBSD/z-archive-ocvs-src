head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.7
	tg-mergefixes-1-branch:1.1.3.7.0.4
	tg-mergefixes-1-base:1.1.3.7
	MIROS_X:1.1.3.7.0.2
	MIROS_X_BASE:1.1.3.7
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.3.2
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.3.2.0.6
	MIRBSD_7:1.1.3.2.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.1.3.2
	MIRBSD_7_DEV:1.1.3.2.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.19.55.44;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.54;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.15;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.52;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.07;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.25;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.16;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.47.26;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.16;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.32;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/*			File Transfer Protocol (FTP) Client
 *			for a WorldWideWeb browser
 *			===================================
 *
 *	A cache of control connections is kept.
 *
 * Note: Port allocation
 *
 *	It is essential that the port is allocated by the system, rather
 *	than chosen in rotation by us (POLL_PORTS), or the following
 *	problem occurs.
 *
 *	It seems that an attempt by the server to connect to a port which has
 *	been used recently by a listen on the same socket, or by another
 *	socket this or another process causes a hangup of (almost exactly)
 *	one minute.  Therefore, we have to use a rotating port number.
 *	The problem remains that if the application is run twice in quick
 *	succession, it will hang for what remains of a minute.
 *
 * Authors
 *	TBL	Tim Berners-lee <timbl@@info.cern.ch>
 *	DD	Denis DeLaRoca 310 825-4580 <CSP1DWD@@mvs.oac.ucla.edu>
 *	LM	Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
 *	FM	Foteos Macrides <macrides@@sci.wfeb.edu>
 * History:
 *	 2 May 91	Written TBL, as a part of the WorldWideWeb project.
 *	15 Jan 92	Bug fix: close() was used for NETCLOSE for control soc
 *	10 Feb 92	Retry if cached connection times out or breaks
 *	 8 Dec 92	Bug fix 921208 TBL after DD
 *	17 Dec 92	Anon FTP password now just WWWuser@@ suggested by DD
 *			fails on princeton.edu!
 *	27 Dec 93 (FM)	Fixed up so FTP now works with VMS hosts.  Path
 *			must be Unix-style and cannot include the device
 *			or top directory.
 *	?? ??? ?? (LM)	Added code to prompt and send passwords for non
 *			anonymous FTP
 *	25 Mar 94 (LM)	Added code to recognize different ftp server types
 *			and code to parse dates and sizes on most hosts.
 *	27 Mar 93 (FM)	Added code for getting dates and sizes on VMS hosts.
 *
 * Notes:
 *			Portions Copyright 1994 Trustees of Dartmouth College
 *			Code for recognizing different FTP servers and
 *			parsing "ls -l" output taken from Macintosh Fetch
 *			program with permission from Jim Matthews,
 *			Dartmouth Software Development Team.
 */

/*
 * BUGS:	@@@@@@	Limit connection cache size!
 * 		Error reporting to user.
 * 		400 & 500 errors are ack'ed by user with windows.
 * 		Use configuration file for user names
 * 
 *		Note for portability this version does not use select() and
 *		so does not watch the control and data channels at the
 *		same time.
 */

#include <HTUtils.h>

#include <HTAlert.h>

#include <HTFTP.h>		/* Implemented here */
#include <HTTCP.h>
#include <HTTP.h>
#include <HTFont.h>

#define REPEAT_PORT		/* Give the port number for each file */
#define REPEAT_LISTEN		/* Close each listen socket and open a new one */

/* define POLL_PORTS		 If allocation does not work, poll ourselves.*/
#define LISTEN_BACKLOG 2	/* Number of pending connect requests (TCP) */

#define FIRST_TCP_PORT	1024	/* Region to try for a listening port */
#define LAST_TCP_PORT	5999

#define LINE_LENGTH 256

#include <HTParse.h>
#include <HTAnchor.h>
#include <HTFile.h>		/* For HTFileFormat() */
#include <HTBTree.h>
#include <HTChunk.h>
#ifndef IPPORT_FTP
#define IPPORT_FTP	21
#endif /* !IPORT_FTP */

#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYLeaks.h>

typedef struct _connection {
    struct _connection *next;	/* Link on list         */
    unsigned long addr;		/* IP address           */
    int socket;			/* Socket number for communication */
    BOOL binary;		/* Binary mode? */
} connection;

/*		Hypertext object building machinery
*/
#include <HTML.h>

/*
 * socklen_t is the standard, but there are many pre-standard variants.
 * This ifdef works around a few of those cases.
 *
 * Information was obtained from header files on these platforms:
 *	AIX 4.3.2, 5.1
 *	HPUX 10.20, 11.00, 11.11
 *	IRIX64 6.5
 *	Tru64 4.0G, 4.0D, 5.1
 */
#if defined(SYS_IRIX64)
	/* IRIX64 6.5 socket.h may use socklen_t if SGI_SOURCE is not defined */
#  if _NO_XOPEN4 && _NO_XOPEN5
#    define LY_SOCKLEN socklen_t
#  elif _ABIAPI
#    define LY_SOCKLEN int
#  elif _XOPEN5
#    if (_MIPS_SIM != _ABIO32)
#      define LY_SOCKLEN socklen_t
#    else
#      define LY_SOCKLEN int
#    endif
#  else
#    define LY_SOCKLEN size_t
#  endif
#elif defined(SYS_HPUX)
#  if defined(_XOPEN_SOURCE_EXTENDED) && defined(SO_PROTOTYPE)
#    define LY_SOCKLEN socklen_t
#  else	/* HPUX 10.20, etc. */
#    define LY_SOCKLEN int
#  endif
#elif defined(SYS_TRU64)
#  if defined(_POSIX_PII_SOCKET)
#    define LY_SOCKLEN socklen_t
#  elif defined(_XOPEN_SOURCE_EXTENDED)
#    define LY_SOCKLEN size_t
#  else
#    define LY_SOCKLEN int
#  endif
#else
#  define LY_SOCKLEN socklen_t
#endif

#define PUTC(c)      (*targetClass.put_character) (target, c)
#define PUTS(s)      (*targetClass.put_string)    (target, s)
#define START(e)     (*targetClass.start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*targetClass.end_element)   (target, e, 0)
#define FREE_TARGET  (*targetClass._free)         (target)
#define ABORT_TARGET (*targetClass._free)         (target)

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

/*	Global Variables
 *	---------------------
 */
int HTfileSortMethod = FILE_BY_NAME;

#ifndef DISABLE_FTP		/*This disables everything to end-of-file */
static char ThisYear[8];
static char LastYear[8];
static int TheDate;
static BOOLEAN HaveYears = FALSE;

/*	Module-Wide Variables
 *	---------------------
 */
static connection *connections = NULL;	/* Linked list of connections */
static char response_text[LINE_LENGTH + 1];	/* Last response from ftp host */
static connection *control = NULL;	/* Current connection */
static int data_soc = -1;	/* Socket for data transfer =invalid */
static char *user_entered_password = NULL;
static char *last_username_and_host = NULL;

/*
 * ProFTPD 1.2.5rc1 is known to have a broken implementation of RETR.  If asked
 * to retrieve a directory, it gets confused and fails subsequent commands such
 * as CWD and LIST.  Since this is an unusual bug, we should remove this ifdef
 * at some point - TD 2004/1/1.
 */
#define BROKEN_PROFTPD 1
static int ProFTPD_bugs = FALSE;

/*
 * wu-ftpd 2.6.2(12) is known to have a broken implementation of EPSV.  The
 * server will hang for a long time when we attempt to connect after issuing
 * this command - TD 2004/12/28
 */
#define BROKEN_WUFTPD 1
static int WU_FTPD_bugs = FALSE;

typedef enum {
    GENERIC_SERVER
    ,MACHTEN_SERVER
    ,UNIX_SERVER
    ,VMS_SERVER
    ,CMS_SERVER
    ,DCTS_SERVER
    ,TCPC_SERVER
    ,PETER_LEWIS_SERVER
    ,NCSA_SERVER
    ,WINDOWS_NT_SERVER
    ,WINDOWS_2K_SERVER
    ,MS_WINDOWS_SERVER
    ,MSDOS_SERVER
    ,APPLESHARE_SERVER
    ,NETPRESENZ_SERVER
    ,DLS_SERVER
} eServerType;

static eServerType server_type = GENERIC_SERVER;	/* the type of ftp host */
static int unsure_type = FALSE;	/* sure about the type? */
static BOOLEAN use_list = FALSE;	/* use the LIST command? */

static int interrupted_in_next_data_char = FALSE;

#ifdef POLL_PORTS
static PortNumber port_number = FIRST_TCP_PORT;
#endif /* POLL_PORTS */

static int master_socket = -1;	/* Listening socket = invalid   */
static char port_command[255];	/* Command for setting the port */
static fd_set open_sockets;	/* Mask of active channels */
static int num_sockets;		/* Number of sockets to scan */
static PortNumber passive_port;	/* Port server specified for data */

#define NEXT_CHAR HTGetCharacter()	/* Use function in HTFormat.c */

#define DATA_BUFFER_SIZE 2048
static char data_buffer[DATA_BUFFER_SIZE];	/* Input data buffer */
static char *data_read_pointer;
static char *data_write_pointer;

#define NEXT_DATA_CHAR next_data_char()
static int close_connection(connection * con);

#ifdef LY_FIND_LEAKS
/*
 *  This function frees module globals. - FM
 */
static void free_FTPGlobals(void)
{
    FREE(user_entered_password);
    FREE(last_username_and_host);
    if (control) {
	if (control->socket != -1)
	    close_connection(control);
	FREE(control);
    }
}
#endif /* LY_FIND_LEAKS */

/* PUBLIC						HTVMS_name()
 *		CONVERTS WWW name into a VMS name
 * ON ENTRY:
 *	nn		Node Name (optional)
 *	fn		WWW file name
 *
 * ON EXIT:
 *	returns		vms file specification
 *
 * Bug: Returns pointer to static -- non-reentrant
 */
char *HTVMS_name(const char *nn,
		 const char *fn)
{
    /* We try converting the filename into Files-11 syntax.  That is, we assume
     * first that the file is, like us, on a VMS node.  We try remote (or
     * local) DECnet access.  Files-11, VMS, VAX and DECnet are trademarks of
     * Digital Equipment Corporation.  The node is assumed to be local if the
     * hostname WITHOUT DOMAIN matches the local one.  @@@@@@
     */
    static char *vmsname;
    char *filename = (char *) malloc(strlen(fn) + 1);
    char *nodename = (char *) malloc(strlen(nn) + 2 + 1);	/* Copies to hack */
    char *second;		/* 2nd slash */
    char *last;			/* last slash */

    const char *hostname = HTHostName();

    if (!filename || !nodename)
	outofmem(__FILE__, "HTVMSname");
    strcpy(filename, fn);
    strcpy(nodename, "");	/* On same node?  Yes if node names match */
    if (strncmp(nn, "localhost", 9)) {
	const char *p;
	const char *q;

	for (p = hostname, q = nn;
	     *p && *p != '.' && *q && *q != '.'; p++, q++) {
	    if (TOUPPER(*p) != TOUPPER(*q)) {
		char *r;

		strcpy(nodename, nn);
		r = strchr(nodename, '.');	/* Mismatch */
		if (r)
		    *r = '\0';	/* Chop domain */
		strcat(nodename, "::");		/* Try decnet anyway */
		break;
	    }
	}
    }

    second = strchr(filename + 1, '/');		/* 2nd slash */
    last = strrchr(filename, '/');	/* last slash */

    if (!second) {		/* Only one slash */
	HTSprintf0(&vmsname, "%s%s", nodename, filename + 1);
    } else if (second == last) {	/* Exactly two slashes */
	*second = '\0';		/* Split filename from disk */
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename + 1, second + 1);
	*second = '/';		/* restore */
    } else {			/* More than two slashes */
	char *p;

	*second = '\0';		/* Split disk from directories */
	*last = '\0';		/* Split dir from filename */
	HTSprintf0(&vmsname, "%s%s:[%s]%s",
		   nodename, filename + 1, second + 1, last + 1);
	*second = *last = '/';	/* restore filename */
	for (p = strchr(vmsname, '['); *p != ']'; p++)
	    if (*p == '/')
		*p = '.';	/* Convert dir sep.  to dots */
    }
    FREE(nodename);
    FREE(filename);
    return vmsname;
}

/*	Procedure: Read a character from the data connection
 *	----------------------------------------------------
 */
static int next_data_char(void)
{
    int status;

    if (data_read_pointer >= data_write_pointer) {
	status = NETREAD(data_soc, data_buffer, DATA_BUFFER_SIZE);
	if (status == HT_INTERRUPTED)
	    interrupted_in_next_data_char = 1;
	if (status <= 0)
	    return -1;
	data_write_pointer = data_buffer + status;
	data_read_pointer = data_buffer;
    }
#ifdef NOT_ASCII
    {
	char c = *data_read_pointer++;

	return FROMASCII(c);
    }
#else
    return UCH(*data_read_pointer++);
#endif /* NOT_ASCII */
}

/*	Close an individual connection
 *
 */
static int close_connection(connection * con)
{
    connection *scan;
    int status;

    CTRACE((tfp, "HTFTP: Closing control socket %d\n", con->socket));
    status = NETCLOSE(con->socket);
    if (TRACE && status != 0) {
#ifdef UNIX
	CTRACE((tfp, "HTFTP:close_connection: %s", LYStrerror(errno)));
#else
	if (con->socket != INVSOC)
	    HTInetStatus("HTFTP:close_connection");
#endif
    }
    con->socket = -1;
    if (connections == con) {
	connections = con->next;
	return status;
    }
    for (scan = connections; scan; scan = scan->next) {
	if (scan->next == con) {
	    scan->next = con->next;	/* Unlink */
	    if (control == con)
		control = (connection *) 0;
	    return status;
	}			/*if */
    }				/* for */
    return -1;			/* very strange -- was not on list. */
}

static char *help_message_buffer = NULL;	/* global :( */

static void init_help_message_cache(void)
{
    FREE(help_message_buffer);
}

static void help_message_cache_add(char *string)
{
    if (help_message_buffer)
	StrAllocCat(help_message_buffer, string);
    else
	StrAllocCopy(help_message_buffer, string);

    CTRACE((tfp, "Adding message to help cache: %s\n", string));
}

static char *help_message_cache_non_empty(void)
{
    return (help_message_buffer);
}

static char *help_message_cache_contents(void)
{
    return (help_message_buffer);
}

/*	Send One Command
 *	----------------
 *
 *	This function checks whether we have a control connection, and sends
 *	one command if given.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command should already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  1 for success,
 *		  or negative for communication failure (in which case
 *		  the control connection will be closed).
 */
static int write_cmd(const char *cmd)
{
    int status;

    if (!control) {
	CTRACE((tfp, "HTFTP: No control connection set up!!\n"));
	return HT_NO_CONNECTION;
    }

    if (cmd) {
	CTRACE((tfp, "  Tx: %s", cmd));
#ifdef NOT_ASCII
	{
	    char *p;

	    for (p = cmd; *p; p++) {
		*p = TOASCII(*p);
	    }
	}
#endif /* NOT_ASCII */
	status = NETWRITE(control->socket, cmd, (int) strlen(cmd));
	if (status < 0) {
	    CTRACE((tfp,
		    "HTFTP: Error %d sending command: closing socket %d\n",
		    status, control->socket));
	    close_connection(control);
	    return status;
	}
    }
    return 1;
}

/*	Execute Command and get Response
 *	--------------------------------
 *
 *	See the state machine illustrated in RFC959, p57. This implements
 *	one command/reply sequence.  It also interprets lines which are to
 *	be continued, which are marked with a "-" immediately after the
 *	status code.
 *
 *	Continuation then goes on until a line with a matching reply code
 *	an a space after it.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command must already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  The first digit of the reply type,
 *		  or negative for communication failure.
 */
static int response(const char *cmd)
{
    int result;			/* Three-digit decimal code */
    int continuation_response = -1;
    int status;

    if ((status = write_cmd(cmd)) < 0)
	return status;

    do {
	char *p = response_text;

	for (;;) {
	    int ich = NEXT_CHAR;

	    if (((*p++ = (char) ich) == LF)
		|| (p == &response_text[LINE_LENGTH])) {

		char continuation;

		if (interrupted_in_htgetcharacter) {
		    CTRACE((tfp,
			    "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return HT_INTERRUPTED;
		}

		*p = '\0';	/* Terminate the string */
		CTRACE((tfp, "    Rx: %s", response_text));

		/* Check for login or help messages */
		if (!strncmp(response_text, "230-", 4) ||
		    !strncmp(response_text, "250-", 4) ||
		    !strncmp(response_text, "220-", 4))
		    help_message_cache_add(response_text + 4);

		sscanf(response_text, "%d%c", &result, &continuation);
		if (continuation_response == -1) {
		    if (continuation == '-')	/* start continuation */
			continuation_response = result;
		} else {	/* continuing */
		    if (continuation_response == result &&
			continuation == ' ')
			continuation_response = -1;	/* ended */
		}
#ifdef BROKEN_PROFTPD
		if (result == 220 && LYstrstr(response_text, "ProFTPD 1.2.5")) {
		    ProFTPD_bugs = TRUE;
		    CTRACE((tfp, "This server is broken (RETR)\n"));
		}
#endif
#ifdef BROKEN_WUFTPD
		if (result == 220 && LYstrstr(response_text,
					      "(Version wu-2.6.2-12)")) {
		    WU_FTPD_bugs = TRUE;
		    CTRACE((tfp, "This server is broken (EPSV)\n"));
		}
#endif
		break;
	    }
	    /* if end of line */
	    if (interrupted_in_htgetcharacter) {
		CTRACE((tfp,
			"HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		NETCLOSE(control->socket);
		control->socket = -1;
		return HT_INTERRUPTED;
	    }

	    if (ich == EOF) {
		CTRACE((tfp, "Error on rx: closing socket %d\n",
			control->socket));
		strcpy(response_text, "000 *** TCP read error on response\n");
		close_connection(control);
		return -1;	/* End of file on response */
	    }
	}			/* Loop over characters */

    } while (continuation_response != -1);

    if (result == 421) {
	CTRACE((tfp, "HTFTP: They close so we close socket %d\n",
		control->socket));
	close_connection(control);
	return -1;
    }
    if ((result == 255 && server_type == CMS_SERVER) &&
	(0 == strncasecomp(cmd, "CWD", 3) ||
	 0 == strcasecomp(cmd, "CDUP"))) {
	/*
	 * Alas, CMS returns 255 on failure to CWD to parent of root.  - PG
	 */
	result = 555;
    }
    return result / 100;
}

static int send_cmd_1(const char *verb)
{
    char command[80];

    sprintf(command, "%.*s%c%c", (int) sizeof(command) - 4, verb, CR, LF);
    return response(command);
}

static int send_cmd_2(const char *verb, const char *param)
{
    char *command = 0;
    int status;

    HTSprintf0(&command, "%s %s%c%c", verb, param, CR, LF);
    status = response(command);
    FREE(command);

    return status;
}

#define send_cwd(path) send_cmd_2("CWD", path)

/*
 * This function should try to set the macintosh server into binary mode.  Some
 * servers need an additional letter after the MACB command.
 */
static int set_mac_binary(eServerType ServerType)
{
    /* try to set mac binary mode */
    if (ServerType == APPLESHARE_SERVER ||
	ServerType == NETPRESENZ_SERVER) {
	/*
	 * Presumably E means "Enable".  - KW
	 */
	return (2 == response("MACB E\r\n"));
    } else {
	return (2 == response("MACB\r\n"));
    }
}

/* This function gets the current working directory to help
 * determine what kind of host it is
 */

static void get_ftp_pwd(eServerType *ServerType, BOOLEAN *UseList)
{
    char *cp;

    /* get the working directory (to see what it looks like) */
    int status = response("PWD\r\n");

    if (status < 0) {
	return;
    } else {
	cp = strchr(response_text + 5, '"');
	if (cp)
	    *cp = '\0';
	if (*ServerType == TCPC_SERVER) {
	    *ServerType = ((response_text[5] == '/') ?
			   NCSA_SERVER : TCPC_SERVER);
	    CTRACE((tfp, "HTFTP: Treating as %s server.\n",
		    ((*ServerType == NCSA_SERVER) ?
		     "NCSA" : "TCPC")));
	} else if (response_text[5] == '/') {
	    /* path names beginning with / imply Unix,
	     * right?
	     */
	    if (set_mac_binary(*ServerType)) {
		*ServerType = NCSA_SERVER;
		CTRACE((tfp, "HTFTP: Treating as NCSA server.\n"));
	    } else {
		*ServerType = UNIX_SERVER;
		*UseList = TRUE;
		CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
	    }
	    return;
	} else if (response_text[strlen(response_text) - 1] == ']') {
	    /* path names ending with ] imply VMS, right? */
	    *ServerType = VMS_SERVER;
	    *UseList = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	} else {
	    *ServerType = GENERIC_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Generic server.\n"));
	}

	if ((*ServerType == NCSA_SERVER) ||
	    (*ServerType == TCPC_SERVER) ||
	    (*ServerType == PETER_LEWIS_SERVER) ||
	    (*ServerType == NETPRESENZ_SERVER))
	    set_mac_binary(*ServerType);
    }
}

/* This function turns MSDOS-like directory output off for
 * Windows NT servers.
 */

static void set_unix_dirstyle(eServerType *ServerType, BOOLEAN *UseList)
{
    char *cp;

    /* This is a toggle.  It seems we have to toggle in order to see
     * the current state (after toggling), so we may end up toggling
     * twice.  - kw
     */
    int status = response("SITE DIRSTYLE\r\n");

    if (status != 2) {
	*ServerType = GENERIC_SERVER;
	CTRACE((tfp, "HTFTP: DIRSTYLE failed, treating as Generic server.\n"));
	return;
    } else {
	*UseList = TRUE;
	/* Expecting one of:
	 * 200 MSDOS-like directory output is off
	 * 200 MSDOS-like directory output is on
	 * The following code doesn't look for the full exact string -
	 * who knows how the wording may change in some future version.
	 * If the first response isn't recognized, we toggle again
	 * anyway, under the assumption that it's more likely that
	 * the MSDOS setting was "off" originally. - kw
	 */
	cp = strstr(response_text + 4, "MSDOS");
	if (cp && strstr(cp, " off")) {
	    return;		/* already off now. */
	} else {
	    response("SITE DIRSTYLE\r\n");
	}
    }
}

/*	Get a valid connection to the host
 *	----------------------------------
 *
 * On entry,
 *	arg	points to the name of the host in a hypertext address
 * On exit,
 *	returns <0 if error
 *		socket number if success
 *
 *	This routine takes care of managing timed-out connections, and
 *	limiting the number of connections in use at any one time.
 *
 *	It ensures that all connections are logged in if they exist.
 *	It ensures they have the port number transferred.
 */
static int get_connection(const char *arg,
			  HTParentAnchor *anchor)
{
    int status;
    char *command = 0;
    connection *con;
    char *username = NULL;
    char *password = NULL;
    static BOOLEAN firstuse = TRUE;

    if (firstuse) {
	/*
	 * Set up freeing at exit.  - FM
	 */
#ifdef LY_FIND_LEAKS
	atexit(free_FTPGlobals);
#endif
	firstuse = FALSE;
    }

    if (control) {
	/*
	 * Reuse this object - KW, DW & FM
	 */
	if (control->socket != -1) {
	    NETCLOSE(control->socket);
	}
	con = control;
	con->addr = 0;
	con->binary = FALSE;
    } else {
	/*
	 * Allocate and init control struct.
	 */
	con = typecalloc(connection);
	if (con == NULL)
	    outofmem(__FILE__, "get_connection");
    }
    con->socket = -1;

    if (!arg)
	return -1;		/* Bad if no name specified     */
    if (!*arg)
	return -1;		/* Bad if name had zero length  */

/* Get node name:
*/
    CTRACE((tfp, "get_connection(%s)\n", arg));
    {
	char *p1 = HTParse(arg, "", PARSE_HOST);
	char *p2 = strrchr(p1, '@@');	/* user? */
	char *pw = NULL;

	if (p2 != NULL) {
	    username = p1;
	    *p2 = '\0';		/* terminate */
	    p1 = p2 + 1;	/* point to host */
	    pw = strchr(username, ':');
	    if (pw != NULL) {
		*pw++ = '\0';
		password = HTUnEscape(pw);
	    }
	    if (*username)
		HTUnEscape(username);

	    /*
	     * If the password doesn't exist then we are going to have to ask
	     * the user for it.  The only problem is that we don't want to ask
	     * for it every time, so we will store away in a primitive fashion.
	     */
	    if (!password) {
		char *tmp = NULL;

		HTSprintf0(&tmp, "%s@@%s", username, p1);
		/*
		 * If the user@@host is not equal to the last time through or
		 * user_entered_password has no data then we need to ask the
		 * user for the password.
		 */
		if (!last_username_and_host ||
		    strcmp(tmp, last_username_and_host) ||
		    !user_entered_password) {

		    StrAllocCopy(last_username_and_host, tmp);
		    HTSprintf0(&tmp, gettext("Enter password for user %s@@%s:"),
			       username, p1);
		    FREE(user_entered_password);
		    user_entered_password = HTPromptPassword(tmp);

		}		/* else we already know the password */
		password = user_entered_password;
		FREE(tmp);
	    }
	}

	if (!username)
	    FREE(p1);
    }				/* scope of p1 */

    status = HTDoConnect(arg, "FTP", IPPORT_FTP, (int *) &con->socket);

    if (status < 0) {
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted on connect\n"));
	} else {
	    CTRACE((tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
		    arg));
	}
	if (status == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	    status = HT_NOT_LOADED;
	} else {
	    HTAlert(gettext("Unable to connect to FTP host."));
	}
	if (con->socket != -1) {
	    NETCLOSE(con->socket);
	}

	FREE(username);
	if (control == con)
	    control = NULL;
	FREE(con);
	return status;		/* Bad return */
    }

    CTRACE((tfp, "FTP connected, socket %d  control %p\n",
	    con->socket, con));
    control = con;		/* Current control connection */

    /* Initialise buffering for control connection */
    HTInitInput(control->socket);
    init_help_message_cache();	/* Clear the login message buffer. */

/*	Now we log in		Look up username, prompt for pw.
*/
    status = response((char *) 0);	/* Get greeting */

    if (status == HT_INTERRUPTED) {
	CTRACE((tfp, "HTFTP: Interrupted at beginning of login.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	NETCLOSE(control->socket);
	control->socket = -1;
	return HT_INTERRUPTED;
    }
    server_type = GENERIC_SERVER;	/* reset */
    if (status == 2) {		/* Send username */
	char *cp;		/* look at greeting text */

	/* don't gettext() this -- incoming text: */
	if (strlen(response_text) > 4) {
	    if ((cp = strstr(response_text, " awaits your command")) ||
		(cp = strstr(response_text, " ready."))) {
		*cp = '\0';
	    }
	    cp = response_text + 4;
	    if (!strncasecomp(cp, "NetPresenz", 10))
		server_type = NETPRESENZ_SERVER;
	} else {
	    cp = response_text;
	}
	StrAllocCopy(anchor->server, cp);

	status = send_cmd_2("USER", (username && *username)
			    ? username
			    : "anonymous");

	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending username.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}
    }
    if (status == 3) {		/* Send password */
	if (password) {
	    /*
	     * We have non-zero length password, so send it. - FM
	     */
	    HTSprintf0(&command, "PASS %s%c%c", password, CR, LF);
	} else {
	    /*
	     * Create and send a mail address as the password. - FM
	     */
	    char *the_address;
	    char *user = NULL;
	    const char *host = NULL;
	    char *cp;

	    the_address = anonftp_password;
	    if (isEmpty(the_address))
		the_address = personal_mail_address;
	    if (isEmpty(the_address))
		the_address = LYGetEnv("USER");
	    if (isEmpty(the_address))
		the_address = "WWWuser";

	    StrAllocCopy(user, the_address);
	    if ((cp = strchr(user, '@@')) != NULL) {
		*cp++ = '\0';
		if (*cp == '\0')
		    host = HTHostName();
		else
		    host = cp;
	    } else {
		host = HTHostName();
	    }

	    /*
	     * If host is not fully qualified, suppress it
	     * as ftp.uu.net prefers a blank to a bad name
	     */
	    if (!(host) || strchr(host, '.') == NULL)
		host = "";

	    HTSprintf0(&command, "PASS %s@@%s%c%c", user, host, CR, LF);
	    FREE(user);
	}
	status = response(command);
	FREE(command);
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}
    }
    FREE(username);

    if (status == 3) {
	status = send_cmd_1("ACCT noaccount");
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}

    }
    if (status != 2) {
	CTRACE((tfp, "HTFTP: Login fail: %s", response_text));
	/* if (control->socket > 0) close_connection(control->socket); */
	return -1;		/* Bad return */
    }
    CTRACE((tfp, "HTFTP: Logged in.\n"));

    /* Check for host type */
    if (server_type != NETPRESENZ_SERVER)
	server_type = GENERIC_SERVER;	/* reset */
    use_list = FALSE;		/* reset */
    if ((status = response("SYST\r\n")) == 2) {
	/* we got a line -- what kind of server are we talking to? */
	if (strncmp(response_text + 4,
		    "UNIX Type: L8 MAC-OS MachTen", 28) == 0) {
	    server_type = MACHTEN_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MachTen server.\n"));

	} else if (strstr(response_text + 4, "UNIX") != NULL ||
		   strstr(response_text + 4, "Unix") != NULL) {
	    server_type = UNIX_SERVER;
	    unsure_type = FALSE;	/* to the best of out knowledge... */
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));

	} else if (strstr(response_text + 4, "MSDOS") != NULL) {
	    server_type = MSDOS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n"));

	} else if (strncmp(response_text + 4, "VMS", 3) == 0) {
	    char *tilde = strstr(arg, "/~");

	    use_list = TRUE;
	    if (tilde != 0
		&& tilde[2] != 0
		&& strstr(response_text + 4, "MadGoat") != 0) {
		server_type = UNIX_SERVER;
		CTRACE((tfp, "HTFTP: Treating VMS as UNIX server.\n"));
	    } else {
		server_type = VMS_SERVER;
		CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	    }

	} else if ((strncmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (strncmp(response_text + 4, "VM ", 3) == 0)) {
	    server_type = CMS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as CMS server.\n"));

	} else if (strncmp(response_text + 4, "DCTS", 4) == 0) {
	    server_type = DCTS_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as DCTS server.\n"));

	} else if (strstr(response_text + 4, "MAC-OS TCP/Connect II") != NULL) {
	    server_type = TCPC_SERVER;
	    CTRACE((tfp, "HTFTP: Looks like a TCPC server.\n"));
	    get_ftp_pwd(&server_type, &use_list);
	    unsure_type = TRUE;

	} else if (server_type == NETPRESENZ_SERVER) {	/* already set above */
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n"));

	} else if (strncmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
	    server_type = PETER_LEWIS_SERVER;
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n"));

	} else if (strncmp(response_text + 4, "Windows_NT", 10) == 0) {
	    server_type = WINDOWS_NT_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_NT server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (strncmp(response_text + 4, "Windows2000", 11) == 0) {
	    server_type = WINDOWS_2K_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_2K server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (strncmp(response_text + 4, "MS Windows", 10) == 0) {
	    server_type = MS_WINDOWS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MS Windows server.\n"));

	} else if (strncmp(response_text + 4,
			   "MACOS AppleShare IP FTP Server", 30) == 0) {
	    server_type = APPLESHARE_SERVER;
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as AppleShare server.\n"));

	} else {
	    server_type = GENERIC_SERVER;
	    CTRACE((tfp, "HTFTP: Ugh!  A Generic server.\n"));
	    get_ftp_pwd(&server_type, &use_list);
	    unsure_type = TRUE;
	}
    } else {
	/* SYST fails :(  try to get the type from the PWD command */
	get_ftp_pwd(&server_type, &use_list);
    }

/*  Now we inform the server of the port number we will listen on
*/
#ifdef NOTREPEAT_PORT
    {
	int status = response(port_command);

	if (status != 2) {
	    if (control->socket)
		close_connection(control->socket);
	    return -status;	/* Bad return */
	}
	CTRACE((tfp, "HTFTP: Port defined.\n"));
    }
#endif /* NOTREPEAT_PORT */
    return con->socket;		/* Good return */
}

/*	Close Master (listening) socket
 *	-------------------------------
 *
 *
 */
static int close_master_socket(void)
{
    int status;

    if (master_socket != -1)
	FD_CLR(master_socket, &open_sockets);
    status = NETCLOSE(master_socket);
    CTRACE((tfp, "HTFTP: Closed master socket %d\n", master_socket));
    master_socket = -1;
    if (status < 0)
	return HTInetStatus(gettext("close master socket"));
    else
	return status;
}

/*	Open a master socket for listening on
 *	-------------------------------------
 *
 *	When data is transferred, we open a port, and wait for the server to
 *	connect with the data.
 *
 * On entry,
 *	master_socket	Must be negative if not set up already.
 * On exit,
 *	Returns		socket number if good
 *			less than zero if error.
 *	master_socket	is socket number if good, else negative.
 *	port_number	is valid if good.
 */
static int get_listen_socket(void)
{
#ifdef INET6
    struct sockaddr_storage soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = (struct sockaddr_in *) &soc_address;
    int af;
    LY_SOCKLEN slen;

#else
    struct sockaddr_in soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = &soc_address;
#endif /* INET6 */
    int new_socket;		/* Will be master_socket */

    FD_ZERO(&open_sockets);	/* Clear our record of open sockets */
    num_sockets = 0;

#ifndef REPEAT_LISTEN
    if (master_socket >= 0)
	return master_socket;	/* Done already */
#endif /* !REPEAT_LISTEN */

#ifdef INET6
    /* query address family of control connection */
    slen = sizeof(soc_address);
    if (getsockname(control->socket, (struct sockaddr *) &soc_address,
		    &slen) < 0) {
	return HTInetStatus("getsockname failed");
    }
    af = ((struct sockaddr *) &soc_address)->sa_family;
    memset(&soc_address, 0, sizeof(soc_address));
#endif /* INET6 */

/*  Create internet socket
*/
#ifdef INET6
    new_socket = socket(af, SOCK_STREAM, IPPROTO_TCP);
#else
    new_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
#endif /* INET6 */

    if (new_socket < 0)
	return HTInetStatus(gettext("socket for master socket"));

    CTRACE((tfp, "HTFTP: Opened master socket number %d\n", new_socket));

/*  Search for a free port.
*/
#ifdef INET6
    memset(&soc_address, 0, sizeof(soc_address));
    ((struct sockaddr *) &soc_address)->sa_family = af;
    switch (af) {
    case AF_INET:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in);
#endif /* SIN6_LEN */
	break;
    case AF_INET6:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in6);
#endif /* SIN6_LEN */
	break;
    default:
	HTInetStatus("AF");
    }
#else
    soc_in->sin_family = AF_INET;	/* Family = internet, host order  */
    soc_in->sin_addr.s_addr = INADDR_ANY;	/* Any peer address */
#endif /* INET6 */
#ifdef POLL_PORTS
    {
	PortNumber old_port_number = port_number;

	for (port_number = (old_port_number + 1);; port_number++) {
	    int status;

	    if (port_number > LAST_TCP_PORT)
		port_number = FIRST_TCP_PORT;
	    if (port_number == old_port_number) {
		return HTInetStatus("bind");
	    }
#ifdef INET6
	    soc_in->sin_port = htons(port_number);
#else
	    soc_address.sin_port = htons(port_number);
#endif /* INET6 */
#ifdef SOCKS
	    if (socks_flag)
		if ((status = Rbind(new_socket,
				    (struct sockaddr *) &soc_address,
		/* Cast to generic sockaddr */
				    SOCKADDR_LEN(soc_address)
#ifndef SHORTENED_RBIND
				    ,socks_bind_remoteAddr
#endif /* !SHORTENED_RBIND */
		     )) == 0) {
		    break;
		} else
#endif /* SOCKS */
		    if ((status = bind(new_socket,
				       (struct sockaddr *) &soc_address,
		    /* Cast to generic sockaddr */
				       SOCKADDR_LEN(soc_address)
			 )) == 0) {
		    break;
		}
	    CTRACE((tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		    port_number, status, SOCKET_ERRNO));
	}			/* for */
    }
#else
    {
	int status;
	LY_SOCKLEN address_length = sizeof(soc_address);

#ifdef SOCKS
	if (socks_flag)
	    status = Rgetsockname(control->socket,
				  (struct sockaddr *) &soc_address,
				  &address_length);
	else
#endif /* SOCKS */
	    status = getsockname(control->socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0)
	    return HTInetStatus("getsockname");
#ifdef INET6
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString((SockA *) soc_in)));

	soc_in->sin_port = 0;	/* Unspecified: please allocate */
#else
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString(soc_in)));

	soc_address.sin_port = 0;	/* Unspecified: please allocate */
#endif /* INET6 */
#ifdef SOCKS
	if (socks_flag)
	    status = Rbind(new_socket,
			   (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			   sizeof(soc_address)
#ifndef SHORTENED_RBIND
#ifdef INET6
			   socks_bind_remoteAddr
#else
			   ,socks_bind_remoteAddr
#endif /* INET6 */
#endif /* !SHORTENED_RBIND */
		);
	else
#endif /* SOCKS */
	    status = bind(new_socket,
			  (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			  SOCKADDR_LEN(soc_address)
		);
	if (status < 0)
	    return HTInetStatus("bind");

	address_length = sizeof(soc_address);
#ifdef SOCKS
	if (socks_flag)
	    status = Rgetsockname(new_socket,
				  (struct sockaddr *) &soc_address,
				  &address_length);
	else
#endif /* SOCKS */
	    status = getsockname(new_socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0)
	    return HTInetStatus("getsockname");
    }
#endif /* POLL_PORTS */

#ifdef INET6
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString((SockA *) soc_in)));
#else
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString(soc_in)));
#endif /* INET6 */

#ifdef REPEAT_LISTEN
    if (master_socket >= 0)
	(void) close_master_socket();
#endif /* REPEAT_LISTEN */

    master_socket = new_socket;

/*	Now we must find out who we are to tell the other guy
*/
    (void) HTHostName();	/* Make address valid - doesn't work */
#ifdef INET6
    switch (((struct sockaddr *) &soc_address)->sa_family) {
    case AF_INET:
#endif /* INET6 */
	sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
		(int) *((unsigned char *) (&soc_in->sin_addr) + 0),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 1),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 2),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 3),
		(int) *((unsigned char *) (&soc_in->sin_port) + 0),
		(int) *((unsigned char *) (&soc_in->sin_port) + 1),
		CR, LF);

#ifdef INET6
	break;

    case AF_INET6:
	{
	    char hostbuf[MAXHOSTNAMELEN];
	    char portbuf[MAXHOSTNAMELEN];

	    getnameinfo((struct sockaddr *) &soc_address,
			SOCKADDR_LEN(soc_address),
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		    CR, LF);
	    break;
	}
    default:
	sprintf(port_command, "JUNK%c%c", CR, LF);
	break;
    }
#endif /* INET6 */

    /*  Inform TCP that we will accept connections
     */
    {
	int status;

#ifdef SOCKS
	if (socks_flag)
	    status = Rlisten(master_socket, 1);
	else
#endif /* SOCKS */
	    status = listen(master_socket, 1);
	if (status < 0) {
	    master_socket = -1;
	    return HTInetStatus("listen");
	}
    }
    CTRACE((tfp, "TCP: Master socket(), bind() and listen() all OK\n"));
    FD_SET(master_socket, &open_sockets);
    if ((master_socket + 1) > num_sockets)
	num_sockets = master_socket + 1;

    return master_socket;	/* Good */

}				/* get_listen_socket */

static const char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

/*	Procedure: Set the current and last year strings and date integer
 *	-----------------------------------------------------------------
 *
 *	Bug:
 *		This code is for sorting listings by date, if that option
 *		is selected in Lynx, and doesn't take into account time
 *		zones or ensure resetting at midnight, so the sort may not
 *		be perfect, but the actual date isn't changed in the display,
 *		i.e., the date is still correct. - FM
 */
static void set_years_and_date(void)
{
    char day[8], month[8], date[12];
    time_t NowTime;
    int i;

    NowTime = time(NULL);
    strncpy(day, (char *) ctime(&NowTime) + 8, 2);
    day[2] = '\0';
    if (day[0] == ' ') {
	day[0] = '0';
    }
    strncpy(month, (char *) ctime(&NowTime) + 4, 3);
    month[3] = '\0';
    for (i = 0; i < 12; i++) {
	if (!strcasecomp(month, months[i])) {
	    break;
	}
    }
    i++;
    sprintf(date, "9999%02d%.2s", i, day);
    TheDate = atoi(date);
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
    ThisYear[4] = '\0';
    sprintf(LastYear, "%d", (atoi(ThisYear) - 1));
    HaveYears = TRUE;
}

typedef struct _EntryInfo {
    char *filename;
    char *linkname;
    char *type;
    char *date;
    unsigned int size;
    BOOLEAN display;		/* show this entry? */
} EntryInfo;

static void free_entryinfo_struct_contents(EntryInfo *entry_info)
{
    if (entry_info) {
	FREE(entry_info->filename);
	FREE(entry_info->linkname);
	FREE(entry_info->type);
	FREE(entry_info->date);
    }
    /* dont free the struct */
}

/*
 * is_ls_date() --
 *	Return TRUE if s points to a string of the form:
 *		"Sep  1  1990 " or
 *		"Sep 11 11:59 " or
 *		"Dec 12 1989  " or
 *		"FCv 23 1990  " ...
 */
static BOOLEAN is_ls_date(char *s)
{
    /* must start with three alpha characters */
    if (!isalpha(UCH(*s++)) || !isalpha(UCH(*s++)) || !isalpha(UCH(*s++)))
	return FALSE;

    /* space or HT_NON_BREAK_SPACE */
    if (!(*s == ' ' || *s == HT_NON_BREAK_SPACE)) {
	s++;
	return FALSE;
    }
    s++;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	s++;
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* space */
    if (*s++ != ' ')
	return FALSE;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	s++;
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* colon or digit */
    if (!(*s == ':' || isdigit(UCH(*s)))) {
	s++;
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	s++;
	return FALSE;
    }
    s++;

    /* space */
    if (*s++ != ' ')
	return FALSE;

    return TRUE;
}				/* is_ls_date() */

/*
 * Extract the name, size, and date from an EPLF line.  - 08-06-96 DJB
 */
static void parse_eplf_line(char *line,
			    EntryInfo *info)
{
    char *cp = line;
    char ct[26];
    unsigned long size;
    time_t secs;
    static time_t base;		/* time() value on this OS in 1970 */
    static int flagbase = 0;

    if (!flagbase) {
	struct tm t;

	t.tm_year = 70;
	t.tm_mon = 0;
	t.tm_mday = 0;
	t.tm_hour = 0;
	t.tm_min = 0;
	t.tm_sec = 0;
	t.tm_isdst = -1;
	base = mktime(&t);	/* could return -1 */
	flagbase = 1;
    }

    while (*cp) {
	switch (*cp) {
	case '\t':
	    StrAllocCopy(info->filename, cp + 1);
	    return;
	case 's':
	    size = 0;
	    while (*(++cp) && (*cp != ','))
		size = (size * 10) + (*cp - '0');
	    info->size = size;
	    break;
	case 'm':
	    secs = 0;
	    while (*(++cp) && (*cp != ','))
		secs = (secs * 10) + (*cp - '0');
	    secs += base;	/* assumes that time_t is #seconds */
	    strcpy(ct, ctime(&secs));
	    ct[24] = 0;
	    StrAllocCopy(info->date, ct);
	    break;
	case '/':
	    StrAllocCopy(info->type, ENTRY_IS_DIRECTORY);
	    /* FALLTHRU */
	default:
	    while (*cp) {
		if (*cp++ == ',')
		    break;
	    }
	    break;
	}
    }
}				/* parse_eplf_line */

/*
 * Extract the name, size, and date from an ls -l line.
 */
static void parse_ls_line(char *line,
			  EntryInfo *entry_info)
{
    int i, j;
    int base = 1;
    int size_num = 0;

    for (i = strlen(line) - 1;
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i - 12]));
	 i--) ;			/* null body */
    line[i] = '\0';
    if (i > 13) {
	StrAllocCopy(entry_info->date, &line[i - 12]);
	/* replace the 4th location with nbsp if it is a space or zero */
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0')
	    entry_info->date[4] = HT_NON_BREAK_SPACE;
	/* make sure year or time is flush right */
	if (entry_info->date[11] == ' ') {
	    for (j = 11; j > 6; j--) {
		entry_info->date[j] = entry_info->date[j - 1];
	    }
	}
    }
    j = i - 14;
    while (isdigit(UCH(line[j]))) {
	size_num += (line[j] - '0') * base;
	base *= 10;
	j--;
    }
    entry_info->size = size_num;
    StrAllocCopy(entry_info->filename, &line[i + 1]);
}				/* parse_ls_line() */

/*
 * Extract the name and size info and whether it refers to a directory from a
 * LIST line in "dls" format.
 */
static void parse_dls_line(char *line,
			   EntryInfo *entry_info,
			   char **pspilledname)
{
    short j;
    int base = 1;
    int size_num = 0;
    int len;
    char *cps = NULL;

    /* README              763  Information about this server\0
       bin/                  -  \0
       etc/                  =  \0
       ls-lR                 0  \0
       ls-lR.Z               3  \0
       pub/                  =  Public area\0
       usr/                  -  \0
       morgan               14  -> ../real/morgan\0
       TIMIT.mostlikely.Z\0
       79215    \0
     */

    len = strlen(line);
    if (len == 0) {
	FREE(*pspilledname);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(line);
    if (*cps == '\0') {		/* only a filename, save it and return. */
	StrAllocCopy(*pspilledname, line);
	entry_info->display = FALSE;
	return;
    }
    if (len < 24 || line[23] != ' ' ||
	(isspace(UCH(line[0])) && !*pspilledname)) {
	/* this isn't the expected "dls" format! */
	if (!isspace(UCH(line[0])))
	    *cps = '\0';
	if (*pspilledname && !*line) {
	    entry_info->filename = *pspilledname;
	    *pspilledname = NULL;
	    if (entry_info->filename[strlen(entry_info->filename) - 1] == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	} else {
	    StrAllocCopy(entry_info->filename, line);
	    if (cps && cps != line && *(cps - 1) == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	    FREE(*pspilledname);
	}
	return;
    }

    j = 22;
    if (line[j] == '=' || line[j] == '-') {
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    } else {
	while (isdigit(UCH(line[j]))) {
	    size_num += (line[j] - '0') * base;
	    base *= 10;
	    j--;
	}
    }
    entry_info->size = size_num;

    cps = LYSkipBlanks(&line[23]);
    if (!strncmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
	StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
	StrAllocCopy(entry_info->linkname, LYSkipBlanks(cps + 3));
	entry_info->size = 0;	/* don't display size */
    }

    if (j > 0)
	line[j] = '\0';

    LYTrimTrailing(line);

    len = strlen(line);
    if (len == 0 && *pspilledname && **pspilledname) {
	line = *pspilledname;
	len = strlen(*pspilledname);
    }
    if (len > 0 && line[len - 1] == '/') {
	/*
	 * It's a dir, remove / and mark it as such.
	 */
	if (len > 1)
	    line[len - 1] = '\0';
	if (!entry_info->type)
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    }

    StrAllocCopy(entry_info->filename, line);
    FREE(*pspilledname);
}				/* parse_dls_line() */

/*
 * parse_vms_dir_entry()
 *	Format the name, date, and size from a VMS LIST line
 *	into the EntryInfo structure - FM
 */
static void parse_vms_dir_entry(char *line,
				EntryInfo *entry_info)
{
    int i, j;
    unsigned int ialloc;
    char *cp, *cpd, *cps, date[16];
    const char *sp = " ";

    /* Get rid of blank lines, and information lines.  Valid lines have the ';'
     * version number token.
     */
    if (!strlen(line) || (cp = strchr(line, ';')) == NULL) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name at VMS version number. */
    *cp++ = '\0';
    StrAllocCopy(entry_info->filename, line);

    /* Cast VMS non-README file and directory names to lowercase. */
    if (strstr(entry_info->filename, "READ") == NULL) {
	LYLowerCase(entry_info->filename);
	i = strlen(entry_info->filename);
    } else {
	i = ((strstr(entry_info->filename, "READ") - entry_info->filename) + 4);
	if (!strncmp(&entry_info->filename[i], "ME", 2)) {
	    i += 2;
	    while (entry_info->filename[i] && entry_info->filename[i] != '.') {
		i++;
	    }
	} else if (!strncmp(&entry_info->filename[i], ".ME", 3)) {
	    i = strlen(entry_info->filename);
	} else {
	    i = 0;
	}
	LYLowerCase(entry_info->filename + i);
    }

    /* Uppercase terminal .z's or _z's. */
    if ((--i > 2) &&
	entry_info->filename[i] == 'z' &&
	(entry_info->filename[i - 1] == '.' ||
	 entry_info->filename[i - 1] == '_'))
	entry_info->filename[i] = 'Z';

    /* Convert any tabs in rest of line to spaces. */
    cps = cp - 1;
    while ((cps = strchr(cps + 1, '\t')) != NULL)
	*cps = ' ';

    /* Collapse serial spaces. */
    i = 0;
    j = 1;
    cps = cp;
    while (cps[j] != '\0') {
	if (cps[i] == ' ' && cps[j] == ' ')
	    j++;
	else
	    cps[++i] = cps[j++];
    }
    cps[++i] = '\0';

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    if ((cpd = strchr(cp, '-')) != NULL &&
	strlen(cpd) > 9 && isdigit(UCH(*(cpd - 1))) &&
	isalpha(UCH(*(cpd + 1))) && *(cpd + 4) == '-') {

	/* Month */
	*(cpd + 2) = (char) TOLOWER(*(cpd + 2));
	*(cpd + 3) = (char) TOLOWER(*(cpd + 3));
	sprintf(date, "%.3s ", cpd + 1);

	/* Day */
	if (isdigit(UCH(*(cpd - 2))))
	    sprintf(date + 4, "%.2s ", cpd - 2);
	else
	    sprintf(date + 4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd - 1);

	/* Time or Year */
	if (!strncmp(ThisYear, cpd + 5, 4) &&
	    strlen(cpd) > 15 && *(cpd + 12) == ':') {
	    sprintf(date + 7, "%.5s", cpd + 10);
	} else {
	    sprintf(date + 7, " %.4s", cpd + 5);
	}

	StrAllocCopy(entry_info->date, date);
    }

    /* Track down the size */
    if ((cpd = strchr(cp, '/')) != NULL) {
	/* Appears be in used/allocated format */
	cps = cpd;
	while (isdigit(UCH(*(cps - 1))))
	    cps--;
	if (cps < cpd)
	    *cpd = '\0';
	entry_info->size = atoi(cps);
	cps = cpd + 1;
	while (isdigit(UCH(*cps)))
	    cps++;
	*cps = '\0';
	ialloc = atoi(cpd + 1);
	/* Check if used is in blocks or bytes */
	if (entry_info->size <= ialloc)
	    entry_info->size *= 512;

    } else if ((cps = strtok(cp, sp)) != NULL) {
	/* We just initialized on the version number */
	/* Now let's hunt for a lone, size number    */
	while ((cps = strtok(NULL, sp)) != NULL) {
	    cpd = cps;
	    while (isdigit(UCH(*cpd)))
		cpd++;
	    if (*cpd == '\0') {
		/* Assume it's blocks */
		entry_info->size = atoi(cps) * 512;
		break;
	    }
	}
    }

    /* Wrap it up */
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %u\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
    return;
}				/* parse_vms_dir_entry() */

/*
 * parse_ms_windows_dir_entry() --
 *	Format the name, date, and size from an MS_WINDOWS LIST line into
 *	the EntryInfo structure (assumes Chameleon NEWT format). - FM
 */
static void parse_ms_windows_dir_entry(char *line,
				       EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    cpd = cps;
    StrAllocCopy(entry_info->filename, cp);

    /* Track down the size */
    if (cps < end) {
	cps = LYSkipBlanks(cps);
	cpd = LYSkipNonBlanks(cps);
	*cpd++ = '\0';
	if (isdigit(UCH(*cps))) {
	    entry_info->size = atoi(cps);
	} else {
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	}
    } else {
	StrAllocCopy(entry_info->type, "");
    }

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    if (cpd < end) {
	cpd = LYSkipBlanks(cpd);
	if (strlen(cpd) > 17) {
	    *(cpd + 6) = '\0';	/* Month and Day */
	    *(cpd + 11) = '\0';	/* Year */
	    *(cpd + 17) = '\0';	/* Time */
	    if (strcmp(ThisYear, cpd + 7))
		/* Not this year, so show the year */
		sprintf(date, "%.6s  %.4s", cpd, (cpd + 7));
	    else
		/* Is this year, so show the time */
		sprintf(date, "%.6s %.5s", cpd, (cpd + 12));
	    StrAllocCopy(entry_info->date, date);
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
		entry_info->date[4] = HT_NON_BREAK_SPACE;
	    }
	}
    }

    /* Wrap it up */
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %u\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
    return;
}				/* parse_ms_windows_dir_entry */

/*
 * parse_windows_nt_dir_entry() --
 *	Format the name, date, and size from a WINDOWS_NT LIST line into
 *	the EntryInfo structure (assumes Chameleon NEWT format). - FM
 */
#ifdef NOTDEFINED
static void parse_windows_nt_dir_entry(char *line,
				       EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);
    int i;

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cpd = cp;
    cps = LYSkipNonBlanks(end - 1);
    cp = (cps + 1);
    if (!strcmp(cp, ".") || !strcmp(cp, "..")) {
	entry_info->display = FALSE;
	return;
    }
    StrAllocCopy(entry_info->filename, cp);
    if (cps < cpd)
	return;
    *cp = '\0';
    end = cp;

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Cut out the date. */
    cp = cps = cpd;
    cps = LYSkipNonBlanks(cps);
    *cps++ = '\0';
    if (cps > end) {
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipBlanks(cps);
    cpd = LYSkipNonBlanks(cps);
    *cps++ = '\0';
    if (cps > end || cpd == cps || strlen(cpd) < 7) {
	entry_info->display = FALSE;
	return;
    }
    if (strlen(cp) == 8 &&
	isdigit(*cp) && isdigit(*(cp + 1)) && *(cp + 2) == '-' &&
	isdigit(*(cp + 3)) && isdigit(*(cp + 4)) && *(cp + 5) == '-') {
	*(cp + 2) = '\0';	/* Month */
	i = atoi(cp) - 1;
	*(cp + 5) = '\0';	/* Day */
	sprintf(date, "%.3s %.2s", months[i], (cp + 3));
	if (date[4] == '0')
	    date[4] = ' ';
	cp += 6;		/* Year */
	if (strcmp((ThisYear + 2), cp)) {
	    /* Not this year, so show the year */
	    if (atoi(cp) < 70) {
		sprintf(&date[6], "  20%.2s", cp);
	    } else {
		sprintf(&date[6], "  19%.2s", cp);
	    }
	} else {
	    /* Is this year, so show the time */
	    *(cpd + 2) = '\0';	/* Hour */
	    i = atoi(cpd);
	    if (*(cpd + 5) == 'P' || *(cpd + 5) == 'p')
		i += 12;
	    sprintf(&date[6], " %02d:%.2s", i, (cpd + 3));
	}
	StrAllocCopy(entry_info->date, date);
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
	    entry_info->date[4] = HT_NON_BREAK_SPACE;
	}
    }

    /* Track down the size */
    if (cps < end) {
	cps = LYSkipBlanks(cps);
	cpd = LYSkipNonBlanks(cps);
	*cpd = '\0';
	if (isdigit(*cps)) {
	    entry_info->size = atoi(cps);
	} else {
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	}
    } else {
	StrAllocCopy(entry_info->type, "");
    }

    /* Wrap it up */
    CTRACE((tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
    return;
}				/* parse_windows_nt_dir_entry */
#endif /* NOTDEFINED */

/*
 * parse_cms_dir_entry() --
 *	Format the name, date, and size from a VM/CMS line into
 *	the EntryInfo structure. - FM
 */
static void parse_cms_dir_entry(char *line,
				EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);
    int RecordLength = 0;
    int Records = 0;
    int i;

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    StrAllocCopy(entry_info->filename, cp);
    if (strchr(entry_info->filename, '.') != NULL)
	/* If we already have a dot, we did an NLST. */
	return;
    cp = LYSkipBlanks(cps);
    if (!(*cp)) {
	/* If we don't have more, we've misparsed. */
	FREE(entry_info->filename);
	FREE(entry_info->type);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    if ((0 == strcasecomp(cp, "DIR")) && (cp - line) > 17) {
	/* It's an SFS directory. */
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	entry_info->size = 0;
    } else {
	/* It's a file. */
	cp--;
	*cp = '.';
	StrAllocCat(entry_info->filename, cp);

	/* Track down the VM/CMS RECFM or type. */
	cp = cps;
	if (cp < end) {
	    cp = LYSkipBlanks(cp);
	    cps = LYSkipNonBlanks(cp);
	    *cps++ = '\0';
	    /* Check cp here, if it's relevant someday. */
	}
    }

    /* Track down the record length or dash. */
    cp = cps;
    if (cp < end) {
	cp = LYSkipBlanks(cp);
	cps = LYSkipNonBlanks(cp);
	*cps++ = '\0';
	if (isdigit(UCH(*cp))) {
	    RecordLength = atoi(cp);
	}
    }

    /* Track down the number of records or the dash. */
    cp = cps;
    if (cps < end) {
	cp = LYSkipBlanks(cp);
	cps = LYSkipNonBlanks(cp);
	*cps++ = '\0';
	if (isdigit(UCH(*cp))) {
	    Records = atoi(cp);
	}
	if (Records > 0 && RecordLength > 0) {
	    /* Compute an approximate size. */
	    entry_info->size = (Records * RecordLength);
	}
    }

    /* Set the years and date, if we don't have them yet. */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    cpd = cps;
    if (((cps < end) &&
	 (cps = strchr(cpd, ':')) != NULL) &&
	(cps < (end - 3) &&
	 isdigit(UCH(*(cps + 1))) && isdigit(UCH(*(cps + 2))) && *(cps + 3) == ':')) {
	cps += 3;
	*cps = '\0';
	if ((cps - cpd) >= 14) {
	    cpd = (cps - 14);
	    *(cpd + 2) = '\0';	/* Month */
	    *(cpd + 5) = '\0';	/* Day */
	    *(cpd + 8) = '\0';	/* Year */
	    cps -= 5;		/* Time */
	    if (*cpd == ' ')
		*cpd = '0';
	    i = atoi(cpd) - 1;
	    sprintf(date, "%.3s %.2s", months[i], (cpd + 3));
	    if (date[4] == '0')
		date[4] = ' ';
	    cpd += 6;		/* Year */
	    if (strcmp((ThisYear + 2), cpd)) {
		/* Not this year, so show the year. */
		if (atoi(cpd) < 70) {
		    sprintf(&date[6], "  20%.2s", cpd);
		} else {
		    sprintf(&date[6], "  19%.2s", cpd);
		}
	    } else {
		/* Is this year, so show the time. */
		*(cps + 2) = '\0';	/* Hour */
		i = atoi(cps);
		sprintf(&date[6], " %02d:%.2s", i, (cps + 3));
	    }
	    StrAllocCopy(entry_info->date, date);
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
		entry_info->date[4] = HT_NON_BREAK_SPACE;
	    }
	}
    }

    /* Wrap it up. */
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %u\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
    return;
}				/* parse_cms_dir_entry */

/*
 * Given a line of LIST/NLST output in entry, return results and a file/dir
 * name in entry_info struct
 *
 * If first is true, this is the first name in a directory.
 */
static EntryInfo *parse_dir_entry(char *entry,
				  BOOLEAN *first,
				  char **pspilledname)
{
    EntryInfo *entry_info;
    int i;
    int len;
    BOOLEAN remove_size = FALSE;
    char *cp;

    entry_info = (EntryInfo *) malloc(sizeof(EntryInfo));

    if (entry_info == NULL)
	outofmem(__FILE__, "parse_dir_entry");
    entry_info->filename = NULL;
    entry_info->linkname = NULL;
    entry_info->type = NULL;
    entry_info->date = NULL;
    entry_info->size = 0;
    entry_info->display = TRUE;

    switch (server_type) {
    case DLS_SERVER:

	/*
	 * Interpret and edit LIST output from a Unix server in "dls" format. 
	 * This one must have claimed to be Unix in order to get here; if the
	 * first line looks fishy, we revert to Unix and hope that fits better
	 * (this recovery is untested).  - kw
	 */

	if (*first) {
	    len = strlen(entry);
	    if (!len || entry[0] == ' ' ||
		(len >= 24 && entry[23] != ' ') ||
		(len < 24 && strchr(entry, ' '))) {
		server_type = UNIX_SERVER;
		CTRACE((tfp,
			"HTFTP: Falling back to treating as Unix server.\n"));
	    } else {
		*first = FALSE;
	    }
	}

	if (server_type == DLS_SERVER) {
	    /* if still unchanged... */
	    parse_dls_line(entry, entry_info, pspilledname);

	    if (!entry_info->filename || *entry_info->filename == '\0') {
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    if (!strcmp(entry_info->filename, "..") ||
		!strcmp(entry_info->filename, "."))
		entry_info->display = FALSE;
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
	    /*
	     * Goto the bottom and get real type.
	     */
	    break;
	}
	/* fall through if server_type changed for *first == TRUE ! */
    case UNIX_SERVER:
    case PETER_LEWIS_SERVER:
    case MACHTEN_SERVER:
    case MSDOS_SERVER:
    case WINDOWS_NT_SERVER:
    case WINDOWS_2K_SERVER:
    case APPLESHARE_SERVER:
    case NETPRESENZ_SERVER:
	/*
	 * Check for EPLF output (local times).
	 */
	if (*entry == '+') {
	    parse_eplf_line(entry, entry_info);
	    break;
	}

	/*
	 * Interpret and edit LIST output from Unix server.
	 */
	len = strlen(entry);
	if (*first) {
	    /* don't gettext() this -- incoming text: */
	    if (!strcmp(entry, "can not access directory .")) {
		/*
		 * Don't reset *first, nothing real will follow.  - KW
		 */
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    *first = FALSE;
	    if (!strncmp(entry, "total ", 6) ||
		strstr(entry, "not available") != NULL) {
		entry_info->display = FALSE;
		return (entry_info);
	    } else if (unsure_type) {
		/* this isn't really a unix server! */
		server_type = GENERIC_SERVER;
		entry_info->display = FALSE;
		return (entry_info);
	    }
	}

	/*
	 * Check first character of ls -l output.
	 */
	if (TOUPPER(entry[0]) == 'D') {
	    /*
	     * It's a directory.
	     */
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	} else if (entry[0] == 'l') {
	    /*
	     * It's a symbolic link, does the user care about knowing if it is
	     * symbolic?  I think so since it might be a directory.
	     */
	    StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
	    remove_size = TRUE;	/* size is not useful */

	    /*
	     * Strip off " -> pathname".
	     */
	    for (i = len - 1; (i > 3) &&
		 (!isspace(UCH(entry[i])) ||
		  (entry[i - 1] != '>') ||
		  (entry[i - 2] != '-') ||
		  (entry[i - 3] != ' ')); i--) ;	/* null body */
	    if (i > 3) {
		entry[i - 3] = '\0';
		len = i - 3;
		StrAllocCopy(entry_info->linkname, LYSkipBlanks(entry + i));
	    }
	}
	/* link */
	parse_ls_line(entry, entry_info);

	if (!strcmp(entry_info->filename, "..") ||
	    !strcmp(entry_info->filename, "."))
	    entry_info->display = FALSE;
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    case VMS_SERVER:
	/*
	 * Interpret and edit LIST output from VMS server and convert
	 * information lines to zero length.
	 */
	parse_vms_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);

	/*
	 * Trim off VMS directory extensions.
	 */
	len = strlen(entry_info->filename);
	if ((len > 4) && !strcmp(&entry_info->filename[len - 4], ".dir")) {
	    entry_info->filename[len - 4] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    case MS_WINDOWS_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_ms_windows_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

#ifdef NOTDEFINED
    case WINDOWS_NT_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_windows_nt_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
#endif /* NOTDEFINED */

    case CMS_SERVER:
	{
	    /*
	     * Interpret and edit LIST output from VM/CMS server and convert
	     * any information lines to zero length.
	     */
	    parse_cms_dir_entry(entry, entry_info);

	    /*
	     * Get rid of any junk lines.
	     */
	    if (!entry_info->display)
		return (entry_info);
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
	    /*
	     * Goto the bottom and get real type.
	     */
	    break;
	}

    case NCSA_SERVER:
    case TCPC_SERVER:
	/*
	 * Directories identified by trailing "/" characters.
	 */
	StrAllocCopy(entry_info->filename, entry);
	len = strlen(entry);
	if (entry[len - 1] == '/') {
	    /*
	     * It's a dir, remove / and mark it as such.
	     */
	    entry[len - 1] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    default:
	/*
	 * We can't tell if it is a directory since we only did an NLST :( List
	 * bad file types anyways?  NOT!
	 */
	StrAllocCopy(entry_info->filename, entry);
	return (entry_info);	/* mostly empty info */

    }				/* switch (server_type) */

    if (remove_size && entry_info->size) {
	entry_info->size = 0;
    }

    if (entry_info->filename && strlen(entry_info->filename) > 3) {
	if (((cp = strrchr(entry_info->filename, '.')) != NULL &&
	     0 == strncasecomp(cp, ".me", 3)) &&
	    (cp[3] == '\0' || cp[3] == ';')) {
	    /*
	     * Don't treat this as application/x-Troff-me if it's a Unix server
	     * but has the string "read.me", or if it's not a Unix server.  -
	     * FM
	     */
	    if ((server_type != UNIX_SERVER) ||
		(cp > (entry_info->filename + 3) &&
		 0 == strncasecomp((cp - 4), "read.me", 7))) {
		StrAllocCopy(entry_info->type, "text/plain");
	    }
	}
    }

    /*
     * Get real types eventually.
     */
    if (!entry_info->type) {
	const char *cp2;
	HTFormat format;
	HTAtom *encoding;	/* @@@@ not used at all */

	format = HTFileFormat(entry_info->filename, &encoding, &cp2);

	if (cp2 == NULL) {
	    if (!strncmp(HTAtom_name(format), "application", 11)) {
		cp2 = HTAtom_name(format) + 12;
		if (!strncmp(cp2, "x-", 2))
		    cp2 += 2;
	    } else {
		cp2 = HTAtom_name(format);
	    }
	}

	StrAllocCopy(entry_info->type, cp2);
    }

    return (entry_info);
}				/* parse_dir_entry */

static int compare_EntryInfo_structs(EntryInfo *entry1, EntryInfo *entry2)
{
    int i, status;
    char date1[16], date2[16], time1[8], time2[8], month[4];

    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size == entry2->size)
	    return (strcmp(entry1->filename, entry2->filename));
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);

    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcmp(entry1->filename, entry2->filename));

    case FILE_BY_DATE:
	if (entry1->date && entry2->date) {
	    /*
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 || strlen(entry2->date) != 12) {
		return (strcmp(entry1->filename, entry2->filename));
	    }
	    /*
	     * Set the years and date,
	     * if we don't have them yet.
	     */
	    if (!HaveYears) {
		set_years_and_date();
	    }
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[9] == ':') {
		strcpy(date1, "9999");
		strcpy(time1, &entry1->date[7]);
		if (time1[0] == ' ') {
		    time1[0] = '0';
		}
	    } else {
		strcpy(date1, &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    strncat(date1, &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ' || date1[6] == HT_NON_BREAK_SPACE) {
		date1[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date1[i] = LastYear[i];
		}
	    }
	    strcat(date1, time1);
	    if (entry2->date[9] == ':') {
		strcpy(date2, "9999");
		strcpy(time2, &entry2->date[7]);
		if (time2[0] == ' ') {
		    time2[0] = '0';
		}
	    } else {
		strcpy(date2, &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    strncat(date2, &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ' || date2[6] == HT_NON_BREAK_SPACE) {
		date2[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date2[i] = LastYear[i];
		}
	    }
	    strcat(date2, time2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcmp(entry1->filename, entry2->filename));

    case FILE_BY_NAME:
    default:
	return (strcmp(entry1->filename, entry2->filename));
    }
}

/*	Read a directory into an hypertext object from the data socket
 *	--------------------------------------------------------------
 *
 * On entry,
 *	anchor		Parent anchor to link the this node to
 *	address		Address of the directory
 * On exit,
 *	returns		HT_LOADED if OK
 *			<0 if error.
 */
static int read_directory(HTParentAnchor *parent,
			  const char *address,
			  HTFormat format_out,
			  HTStream *sink)
{
    int status;
    BOOLEAN WasInterrupted = FALSE;
    HTStructured *target = HTML_new(parent, format_out, sink);
    HTStructuredClass targetClass;
    char *filename = HTParse(address, "", PARSE_PATH + PARSE_PUNCTUATION);
    EntryInfo *entry_info;
    BOOLEAN first = TRUE;
    char string_buffer[64];
    char *lastpath = NULL;	/* prefix for link, either "" (for root) or xxx  */
    BOOL need_parent_link = FALSE;
    BOOL tildeIsTop = FALSE;

    targetClass = *(target->isa);

    _HTProgress(gettext("Receiving FTP directory."));

    /*
     * Force the current Date and Year (TheDate, ThisYear, and LastYear) to be
     * recalculated for each directory request.  Otherwise we have a problem
     * with long-running sessions assuming the wrong date for today.  - kw
     */
    HaveYears = FALSE;
    /*
     * Check whether we always want the home directory treated as Welcome.  -
     * FM
     */
    if (server_type == VMS_SERVER)
	tildeIsTop = TRUE;

    /*
     * This should always come back FALSE, since the flag is set only for local
     * directory listings if LONG_LIST was defined on compilation, but we could
     * someday set up an equivalent listing for Unix ftp servers.  - FM
     */
    need_parent_link = HTDirTitles(target, parent, tildeIsTop);

    data_read_pointer = data_write_pointer = data_buffer;

    if (*filename == '\0') {	/* Empty filename: use root. */
	StrAllocCopy(lastpath, "/");
    } else if (!strcmp(filename, "/")) {	/* Root path. */
	StrAllocCopy(lastpath, "/foo/..");
    } else {
	char *p = strrchr(filename, '/');	/* Find the lastslash. */
	char *cp;

	if (server_type == CMS_SERVER) {
	    StrAllocCopy(lastpath, filename);	/* Use absolute path for CMS. */
	} else {
	    StrAllocCopy(lastpath, p + 1);	/* Take slash off the beginning. */
	}
	if ((cp = strrchr(lastpath, ';')) != NULL) {	/* Trim type= param. */
	    if (!strncasecomp((cp + 1), "type=", 5)) {
		if (TOUPPER(*(cp + 6)) == 'D' ||
		    TOUPPER(*(cp + 6)) == 'A' ||
		    TOUPPER(*(cp + 6)) == 'I')
		    *cp = '\0';
	    }
	}
    }
    FREE(filename);

    {
	HTBTree *bt = HTBTree_new((HTComparer) compare_EntryInfo_structs);
	int ic;
	HTChunk *chunk = HTChunkCreate(128);
	int BytesReceived = 0;
	int BytesReported = 0;
	char NumBytes[64];
	char *spilledname = NULL;

	PUTC('\n');		/* prettier LJM */
	for (ic = 0; ic != EOF;) {	/* For each entry in the directory */
	    HTChunkClear(chunk);

	    if (HTCheckForInterrupt()) {
		CTRACE((tfp,
			"read_directory: interrupted after %d bytes\n",
			BytesReceived));
		WasInterrupted = TRUE;
		if (BytesReceived) {
		    goto unload_btree;	/* unload btree */
		} else {
		    ABORT_TARGET;
		    HTBTreeAndObject_free(bt);
		    FREE(spilledname);
		    return HT_INTERRUPTED;
		}
	    }

	    /*   read directory entry
	     */
	    interrupted_in_next_data_char = FALSE;
	    for (;;) {		/* Read in one line as filename */
		ic = NEXT_DATA_CHAR;
	      AgainForMultiNet:
		if (interrupted_in_next_data_char) {
		    CTRACE((tfp,
			    "read_directory: interrupted_in_next_data_char after %d bytes\n",
			    BytesReceived));
		    WasInterrupted = TRUE;
		    if (BytesReceived) {
			goto unload_btree;	/* unload btree */
		    } else {
			ABORT_TARGET;
			HTBTreeAndObject_free(bt);
			FREE(spilledname);
			return HT_INTERRUPTED;
		    }
		} else if ((char) ic == CR || (char) ic == LF) {	/* Terminator? */
		    if (chunk->size != 0) {	/* got some text */
			/* Deal with MultiNet's wrapping of long lines */
			if (server_type == VMS_SERVER) {
			    /* Deal with MultiNet's wrapping of long lines - F.M. */
			    if (data_read_pointer < data_write_pointer &&
				*(data_read_pointer + 1) == ' ')
				data_read_pointer++;
			    else if (data_read_pointer >= data_write_pointer) {
				status = NETREAD(data_soc, data_buffer,
						 DATA_BUFFER_SIZE);
				if (status == HT_INTERRUPTED) {
				    interrupted_in_next_data_char = 1;
				    goto AgainForMultiNet;
				}
				if (status <= 0) {
				    ic = EOF;
				    break;
				}
				data_write_pointer = data_buffer + status;
				data_read_pointer = data_buffer;
				if (*data_read_pointer == ' ')
				    data_read_pointer++;
				else
				    break;
			    } else
				break;
			} else
			    break;	/* finish getting one entry */
		    }
		} else if (ic == EOF) {
		    break;	/* End of file */
		} else {
		    HTChunkPutc(chunk, (char) ic);
		}
	    }
	    HTChunkTerminate(chunk);

	    BytesReceived += chunk->size;
	    if (BytesReceived > BytesReported + 1024) {
#ifdef _WINDOWS
		sprintf(NumBytes, gettext("Transferred %d bytes (%5d)"),
			BytesReceived, ws_read_per_sec);
#else
		sprintf(NumBytes, TRANSFERRED_X_BYTES, BytesReceived);
#endif
		HTProgress(NumBytes);
		BytesReported = BytesReceived;
	    }

	    if (ic == EOF && chunk->size == 1)
		/* 1 means empty: includes terminating 0 */
		break;
	    CTRACE((tfp, "HTFTP: Line in %s is %s\n",
		    lastpath, chunk->data));

	    entry_info = parse_dir_entry(chunk->data, &first, &spilledname);
	    if (entry_info->display) {
		FREE(spilledname);
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
	    } else {
		free_entryinfo_struct_contents(entry_info);
		FREE(entry_info);
	    }

	}			/* next entry */

      unload_btree:

	HTChunkFree(chunk);
	FREE(spilledname);

	/* print out the handy help message if it exists :) */
	if (help_message_cache_non_empty()) {
	    START(HTML_PRE);
	    START(HTML_HR);
	    PUTC('\n');
	    PUTS(help_message_cache_contents());
	    init_help_message_cache();	/* to free memory */
	    START(HTML_HR);
	    PUTC('\n');
	} else {
	    START(HTML_PRE);
	    PUTC('\n');
	}

	/* Put up header
	 */
	/* PUTS("    Date        Type             Size     Filename\n");
	 */

	/* Run through tree printing out in order
	 */
	{
#ifdef SH_EX			/* 1997/10/18 (Sat) 14:14:28 */
	    char *p, name_buff[256];
	    int name_len, dot_len;

#define	FNAME_WIDTH	30
#define	FILE_GAP	1

#endif
	    HTBTElement *ele;
	    int i;

	    for (ele = HTBTree_next(bt, NULL);
		 ele != NULL;
		 ele = HTBTree_next(bt, ele)) {
		entry_info = (EntryInfo *) HTBTree_object(ele);

		if (entry_info->date) {
		    PUTS(entry_info->date);
		    PUTS("  ");
		} else {
		    PUTS("     * ");
		}

		if (entry_info->type) {
		    for (i = 0; entry_info->type[i] != '\0' && i < 16; i++)
			PUTC(entry_info->type[i]);
		    for (; i < 17; i++)
			PUTC(' ');
		}

		/* start the anchor */
		HTDirEntry(target, lastpath, entry_info->filename);
#ifdef SH_EX			/* 1997/10/18 (Sat) 16:00 */
		name_len = strlen(entry_info->filename);

		sprintf(name_buff, "%-*s", FNAME_WIDTH, entry_info->filename);

		if (name_len < FNAME_WIDTH) {
		    dot_len = FNAME_WIDTH - FILE_GAP - name_len;
		    if (dot_len > 0) {
			p = name_buff + name_len + 1;
			while (dot_len-- > 0)
			    *p++ = '.';
		    }
		} else {
		    name_buff[FNAME_WIDTH] = '\0';
		}

		PUTS(name_buff);
#else
		PUTS(entry_info->filename);
#endif
		END(HTML_A);

		if (entry_info->size) {
#ifdef SH_EX			/* 1998/02/02 (Mon) 16:34:52 */
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "%6d bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "%6d Kb",
				entry_info->size / 1024);
#else
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %u bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "  %uKb",
				entry_info->size / 1024);
#endif
		    PUTS(string_buffer);
		} else if (entry_info->linkname != 0) {
		    PUTS(" -> ");
		    PUTS(entry_info->linkname);
		}

		PUTC('\n');	/* end of this entry */

		free_entryinfo_struct_contents(entry_info);
	    }
	}
	END(HTML_PRE);
	FREE_TARGET;
	HTBTreeAndObject_free(bt);
    }

    FREE(lastpath);

    if (WasInterrupted || data_soc != -1) {	/* should always be true */
	/*
	 * Without closing the data socket first, the response(0) later may
	 * hang.  Some servers expect the client to fin/ack the close of the
	 * data connection before proceeding with the conversation on the
	 * control connection.  - kw
	 */
	CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	status = NETCLOSE(data_soc);
	if (status == -1)
	    HTInetStatus("close");	/* Comment only */
	data_soc = -1;
    }

    if (WasInterrupted || HTCheckForInterrupt()) {
	_HTProgress(TRANSFER_INTERRUPTED);
    }
    return HT_LOADED;
}

/*
 * Setup an FTP connection.
 */
static int setup_connection(const char *name,
			    HTParentAnchor *anchor)
{
    int retry;			/* How many times tried? */
    int status = HT_NO_CONNECTION;

    CTRACE((tfp, "setup_connection(%s)\n", name));

    /* set use_list to NOT since we don't know what kind of server
     * this is yet.  And set the type to GENERIC
     */
    use_list = FALSE;
    server_type = GENERIC_SERVER;
    ProFTPD_bugs = FALSE;
    WU_FTPD_bugs = FALSE;

    for (retry = 0; retry < 2; retry++) {	/* For timed out/broken connections */
	status = get_connection(name, anchor);
	if (status < 0) {
	    break;
	}

	if (!ftp_local_passive) {
	    status = get_listen_socket();
	    if (status < 0) {
		NETCLOSE(control->socket);
		control->socket = -1;
#ifdef INET6
		if (master_socket >= 0)
		    (void) close_master_socket();
#else
		close_master_socket();
#endif /* INET6 */
		/* HT_INTERRUPTED would fall through, if we could interrupt
		   somehow in the middle of it, which we currently can't. */
		break;
	    }
#ifdef REPEAT_PORT
	    /*  Inform the server of the port number we will listen on
	     */
	    status = response(port_command);
	    if (status == HT_INTERRUPTED) {
		CTRACE((tfp, "HTFTP: Interrupted in response (port_command)\n"));
		_HTProgress(CONNECTION_INTERRUPTED);
		NETCLOSE(control->socket);
		control->socket = -1;
		close_master_socket();
		status = HT_INTERRUPTED;
		break;
	    }
	    if (status != 2) {	/* Could have timed out */
		if (status < 0)
		    continue;	/* try again - net error */
		status = -status;	/* bad reply */
		break;
	    }
	    CTRACE((tfp, "HTFTP: Port defined.\n"));
#endif /* REPEAT_PORT */
	} else {		/* Tell the server to be passive */
	    char *command = NULL;
	    const char *p = "?";
	    int h0, h1, h2, h3, p0, p1;		/* Parts of reply */

#ifdef INET6
	    char dst[LINE_LENGTH + 1];
#endif

	    data_soc = status;

#ifdef INET6
	    /* see RFC 2428 */
	    if (WU_FTPD_bugs)
		status = 1;
	    else
		status = send_cmd_1(p = "EPSV");
	    if (status < 0)	/* retry or Bad return */
		continue;
	    else if (status != 2) {
		status = send_cmd_1(p = "PASV");
		if (status < 0) {	/* retry or Bad return */
		    continue;
		} else if (status != 2) {
		    status = -status;	/* bad reply */
		    break;
		}
	    }

	    if (strcmp(p, "PASV") == 0) {
		for (p = response_text; *p && *p != ','; p++) {
		    ;		/* null body */
		}

		while (--p > response_text && '0' <= *p && *p <= '9') {
		    ;		/* null body */
		}
		status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
				&h0, &h1, &h2, &h3, &p0, &p1);
		if (status < 4) {
		    fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = (p0 << 8) + p1;
		sprintf(dst, "%d.%d.%d.%d", h0, h1, h2, h3);
	    } else if (strcmp(p, "EPSV") == 0) {
		char c0, c1, c2, c3;
		struct sockaddr_storage ss;
		LY_SOCKLEN sslen;

		/*
		 * EPSV bla (|||port|)
		 */
		for (p = response_text; *p && !isspace(*p); p++) {
		    ;		/* null body */
		}
		for ( /*nothing */ ;
		     *p && *p && *p != '(';
		     p++)	/*) */
		    ;		/* null body */
		status = sscanf(p, "(%c%c%c%d%c)", &c0, &c1, &c2, &p0, &c3);
		if (status != 5) {
		    fprintf(tfp, "HTFTP: EPSV reply has invalid format!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = p0;

		sslen = sizeof(ss);
		if (getpeername(control->socket, (struct sockaddr *) &ss,
				&sslen) < 0) {
		    fprintf(tfp, "HTFTP: getpeername(control) failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		if (getnameinfo((struct sockaddr *) &ss, sslen, dst,
				sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
		    fprintf(tfp, "HTFTP: getnameinfo failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
	    }
#else
	    status = send_cmd_1("PASV");
	    if (status != 2) {
		if (status < 0)
		    continue;	/* retry or Bad return */
		status = -status;	/* bad reply */
		break;
	    }
	    for (p = response_text; *p && *p != ','; p++) {
		;		/* null body */
	    }

	    while (--p > response_text && '0' <= *p && *p <= '9') {
		;		/* null body */
	    }

	    status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
			    &h0, &h1, &h2, &h3, &p0, &p1);
	    if (status < 4) {
		fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		status = HT_NO_CONNECTION;
		break;
	    }
	    passive_port = (PortNumber) ((p0 << 8) + p1);
#endif /* INET6 */
	    CTRACE((tfp, "HTFTP: Server is listening on port %d\n",
		    passive_port));

	    /* Open connection for data:  */

#ifdef INET6
	    HTSprintf0(&command, "%s//%s:%d/", STR_FTP_URL, dst, passive_port);
#else
	    HTSprintf0(&command, "%s//%d.%d.%d.%d:%d/",
		       STR_FTP_URL, h0, h1, h2, h3, passive_port);
#endif
	    status = HTDoConnect(command, "FTP data", passive_port, &data_soc);
	    FREE(command);

	    if (status < 0) {
		(void) HTInetStatus(gettext("connect for data"));
		NETCLOSE(data_soc);
		break;
	    }

	    CTRACE((tfp, "FTP data connected, socket %d\n", data_soc));
	}
	status = 0;
	break;			/* No more retries */

    }				/* for retries */
    CTRACE((tfp, "setup_connection returns %d\n", status));
    return status;
}

/*	Retrieve File from Server
 *	-------------------------
 *
 * On entry,
 *	name		WWW address of a file: document, including hostname
 * On exit,
 *	returns		Socket number for file if good.
 *			<0 if bad.
 */
int HTFTPLoad(const char *name,
	      HTParentAnchor *anchor,
	      HTFormat format_out,
	      HTStream *sink)
{
    BOOL isDirectory = NO;
    HTAtom *encoding = NULL;
    int status, final_status;
    int outstanding = 1;	/* outstanding control connection responses

				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
    HTFormat format;

    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n",
	    name,
	    (ftp_local_passive
	     ? "passive"
	     : "normal")));

    HTReadProgress(0, 0);

    status = setup_connection(name, anchor);
    if (status < 0)
	return status;		/* Failed with this code */

    /*  Ask for the file:
     */
    {
	char *filename = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
	char *fname = filename;	/* Save for subsequent free() */
	char *vmsname = NULL;
	BOOL binary;
	const char *type = NULL;
	char *types = NULL;
	char *cp;

	if (server_type == CMS_SERVER) {
	    /* If the unescaped path has a %2f, reject it as illegal. - FM */
	    if (((cp = strstr(filename, "%2")) != NULL) &&
		TOUPPER(cp[2]) == 'F') {
		FREE(fname);
		init_help_message_cache();	/* to free memory */
		NETCLOSE(control->socket);
		control->socket = -1;
		CTRACE((tfp,
			"HTFTP: Rejecting path due to illegal escaped slash.\n"));
		return -1;
	    }
	}

	if (!*filename) {
	    StrAllocCopy(filename, "/");
	    type = "D";
	} else if ((type = types = strrchr(filename, ';')) != NULL) {
	    /*
	     * Check and trim the type= parameter.  - FM
	     */
	    if (!strncasecomp((type + 1), "type=", 5)) {
		switch (TOUPPER(*(type + 6))) {
		case 'D':
		    *types = '\0';
		    type = "D";
		    break;
		case 'A':
		    *types = '\0';
		    type = "A";
		    break;
		case 'I':
		    *types = '\0';
		    type = "I";
		    break;
		default:
		    type = "";
		    break;
		}
		if (!*filename) {
		    *filename = '/';
		    *(filename + 1) = '\0';
		}
	    }
	    if (*type != '\0') {
		CTRACE((tfp, "HTFTP: type=%s\n", type));
	    }
	}
	HTUnEscape(filename);
	CTRACE((tfp, "HTFTP: UnEscaped %s\n", filename));
	if (filename[1] == '~') {
	    /*
	     * Check if translation of HOME as tilde is supported,
	     * and adjust filename if so. - FM
	     */
	    char *cp2 = NULL;
	    char *fn = NULL;

	    if ((cp2 = strchr((filename + 1), '/')) != NULL) {
		*cp2 = '\0';
	    }
	    status = send_cmd_1("PWD");
	    if (status == 2 && response_text[5] == '/') {
		status = send_cwd(filename + 1);
		if (status == 2) {
		    StrAllocCopy(fn, (filename + 1));
		    if (cp2) {
			*cp2 = '/';
			if (fn[strlen(fn) - 1] != '/') {
			    StrAllocCat(fn, cp2);
			} else {
			    StrAllocCat(fn, (cp2 + 1));
			}
			cp2 = NULL;
		    }
		    FREE(fname);
		    fname = filename = fn;
		}
	    }
	    if (cp2) {
		*cp2 = '/';
	    }
	}
	if (strlen(filename) > 3) {
	    char *cp2;

	    if (((cp2 = strrchr(filename, '.')) != NULL &&
		 0 == strncasecomp(cp2, ".me", 3)) &&
		(cp2[3] == '\0' || cp2[3] == ';')) {
		/*
		 * Don't treat this as application/x-Troff-me if it's a Unix
		 * server but has the string "read.me", or if it's not a Unix
		 * server.  - FM
		 */
		if ((server_type != UNIX_SERVER) ||
		    (cp2 > (filename + 3) &&
		     0 == strncasecomp((cp2 - 4), "read.me", 7))) {
		    *cp2 = '\0';
		    format = HTFileFormat(filename, &encoding, NULL);
		    *cp2 = '.';
		} else {
		    format = HTFileFormat(filename, &encoding, NULL);
		}
	    } else {
		format = HTFileFormat(filename, &encoding, NULL);
	    }
	} else {
	    format = HTFileFormat(filename, &encoding, NULL);
	}
	format = HTCharsetFormat(format, anchor, -1);
	binary = (BOOL) (encoding != HTAtom_for("8bit") &&
			 encoding != HTAtom_for("7bit"));
	if (!binary &&
	/*
	 * Force binary if we're in source, download or dump mode and this is
	 * not a VM/CMS server, so we don't get CRLF instead of LF (or CR) for
	 * newlines in text files.  Can't do this for VM/CMS or we'll get raw
	 * EBCDIC.  - FM
	 */
	    (format_out == WWW_SOURCE ||
	     format_out == HTAtom_for("www/download") ||
	     format_out == HTAtom_for("www/dump")) &&
	    (server_type != CMS_SERVER))
	    binary = TRUE;
	if (!binary && type && *type == 'I') {
	    /*
	     * Force binary if we had ;type=I - FM
	     */
	    binary = TRUE;
	} else if (binary && type && *type == 'A') {
	    /*
	     * Force ASCII if we had ;type=A - FM
	     */
	    binary = FALSE;
	}
	if (binary != control->binary) {
	    /*
	     * Act on our setting if not already set.  - FM
	     */
	    const char *mode = binary ? "I" : "A";

	    status = send_cmd_2("TYPE", mode);
	    if (status != 2) {
		init_help_message_cache();	/* to free memory */
		return ((status < 0) ? status : -status);
	    }
	    control->binary = binary;
	}
	switch (server_type) {
	    /*
	     * Handle what for Lynx are special case servers, e.g., for which
	     * we respect RFC 1738, or which have known conflicts in suffix
	     * mappings.  - FM
	     */
	case VMS_SERVER:
	    {
		char *cp1, *cp2;
		BOOL included_device = FALSE;
		BOOL found_tilde = FALSE;

		/* Accept only Unix-style filename */
		if (strchr(filename, ':') != NULL ||
		    strchr(filename, '[') != NULL) {
		    FREE(fname);
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    CTRACE((tfp,
			    "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
		    return -1;
		}
		/* Handle any unescaped "/%2F" path */
		if (!strncmp(filename, "//", 2)) {
		    int i;

		    included_device = TRUE;
		    for (i = 0; filename[(i + 1)]; i++)
			filename[i] = filename[(i + 1)];
		    filename[i] = '\0';
		    CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		    cp = HTVMS_name("", filename);
		    CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
		    if ((cp1 = strrchr(cp, ']')) != NULL) {
			strcpy(filename, ++cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			*cp1 = '\0';
			status = send_cwd(cp);
			if (status != 2) {
			    char *dotslash = 0;

			    if ((cp1 = strchr(cp, '[')) != NULL) {
				*cp1++ = '\0';
				status = send_cwd(cp);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
				HTSprintf0(&dotslash, "[.%s", cp1);
				status = send_cwd(dotslash);
				FREE(dotslash);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
			    } else {
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			}
		    } else if ((cp1 = strchr(cp, ':')) != NULL &&
			       strchr(cp, '[') == NULL &&
			       strchr(cp, ']') == NULL) {
			cp1++;
			if (*cp1 != '\0') {
			    strcpy(filename, cp1);
			    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			    HTSprintf0(&vmsname, "%.*s[%s]", cp1 - cp, cp, filename);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				HTSprintf(&vmsname, "%.*s[000000]", cp1 - cp, cp);
				status = send_cwd(vmsname);
				if (status != 2) {
				    HTSprintf(&vmsname, "%.*s", cp1 - cp, cp);
				    status = send_cwd(vmsname);
				    if (status != 2) {
					FREE(fname);
					init_help_message_cache();
					NETCLOSE(control->socket);
					control->socket = -1;
					return ((status < 0) ? status : -status);
				    }
				}
			    } else {
				HTSprintf0(&vmsname, "000000");
				filename = vmsname;
			    }
			}
		    } else if (0 == strcmp(cp, (filename + 1))) {
			status = send_cwd(cp);
			if (status != 2) {
			    HTSprintf0(&vmsname, "%s:", cp);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			}
			HTSprintf0(&vmsname, "000000");
			filename = vmsname;
		    }
		}
		/* Trim trailing slash if filename is not the top directory */
		if (strlen(filename) > 1 && filename[strlen(filename) - 1] == '/')
		    filename[strlen(filename) - 1] = '\0';

#ifdef MAINTAIN_CONNECTION	/* Don't need this if always new connection - F.M. */
		if (!included_device) {
		    /* Get the current default VMS device:[directory] */
		    status = send_cmd_1("PWD");
		    if (status != 2) {
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Go to the VMS account's top directory */
		    if ((cp = strchr(response_text, '[')) != NULL &&
			(cp1 = strrchr(response_text, ']')) != NULL) {
			char *tmp = 0;
			unsigned len = 4;

			StrAllocCopy(tmp, cp);
			if ((cp2 = strchr(cp, '.')) != NULL && cp2 < cp1) {
			    len += (cp2 - cp);
			} else {
			    len += (cp1 - cp);
			}
			tmp[len] = 0;
			StrAllocCat(tmp, "]");

			status = send_cwd(tmp);
			FREE(tmp);

			if (status != 2) {
			    FREE(fname);
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		}
#endif /* MAINTAIN_CONNECTION */

		/* If we want the VMS account's top directory, list it now */
		if (!(strcmp(filename, "/~")) ||
		    (included_device && 0 == strcmp(filename, "000000")) ||
		    (strlen(filename) == 1 && *filename == '/')) {
		    isDirectory = YES;
		    status = send_cmd_1("LIST");
		    FREE(fname);
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
		}
		/* Otherwise, go to appropriate directory and doctor filename */
		if (!strncmp(filename, "/~", 2)) {
		    filename += 2;
		    found_tilde = TRUE;
		}
		CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
		if (!included_device &&
		    (cp = strchr(filename, '/')) != NULL &&
		    (cp1 = strrchr(cp, '/')) != NULL &&
		    (cp1 - cp) > 1) {
		    char *tmp = 0;

		    HTSprintf0(&tmp, "[.%.*s]", cp1 - cp - 1, cp + 1);

		    CTRACE((tfp, "change path '%s'\n", tmp));
		    while ((cp2 = strrchr(tmp, '/')) != NULL)
			*cp2 = '.';
		    CTRACE((tfp, "...to  path '%s'\n", tmp));

		    status = send_cwd(tmp);
		    FREE(tmp);

		    if (status != 2) {
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    filename = cp1 + 1;
		} else {
		    if (!included_device && !found_tilde) {
			filename += 1;
		    }
		}
		break;
	    }
	case CMS_SERVER:
	    {
		/*
		 * If we want the CMS account's top directory, or a base SFS or
		 * anonymous directory path (i.e., without a slash), list it
		 * now.  FM
		 */
		if ((strlen(filename) == 1 && *filename == '/') ||
		    ((0 == strncasecomp((filename + 1), "vmsysu:", 7)) &&
		     (cp = strchr((filename + 1), '.')) != NULL &&
		     strchr(cp, '/') == NULL) ||
		    (0 == strncasecomp(filename + 1, "anonymou.", 9) &&
		     strchr(filename + 1, '/') == NULL)) {
		    if (filename[1] != '\0') {
			status = send_cwd(filename + 1);
			if (status != 2) {
			    /* Action not started */
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		    isDirectory = YES;
		    if (use_list)
			status = send_cmd_1("LIST");
		    else
			status = send_cmd_1("NLST");
		    FREE(fname);
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
		}
		filename++;

		/* Otherwise, go to appropriate directory and adjust filename */
		while ((cp = strchr(filename, '/')) != NULL) {
		    *cp++ = '\0';
		    status = send_cwd(filename);
		    if (status == 2) {
			if (*cp == '\0') {
			    isDirectory = YES;
			    if (use_list)
				status = send_cmd_1("LIST");
			    else
				status = send_cmd_1("NLST");
			    FREE(fname);
			    if (status != 1) {
				/* Action not started */
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			    /* Clear any messages from the login directory */
			    init_help_message_cache();
			    /* Big goto! */
			    goto listen;
			}
			filename = cp;
		    }
		}
		break;
	    }
	default:
	    /* Shift for any unescaped "/%2F" path */
	    if (!strncmp(filename, "//", 2))
		filename++;
	    break;
	}
	/*
	 * Act on a file or listing request, or try to figure out which we're
	 * dealing with if we don't know yet.  - FM
	 */
	if (!(type) || (type && *type != 'D')) {
	    status = send_cmd_2("RETR", filename);
#ifdef BROKEN_PROFTPD
	    /*
	     * ProFTPD 1.2.5rc1 gets confused when asked to RETR a directory.
	     */
	    if (status >= 5) {
		int check;

		if (ProFTPD_bugs) {
		    CTRACE((tfp, "{{reconnecting...\n"));
		    close_connection(control);
		    check = setup_connection(name, anchor);
		    CTRACE((tfp, "...done }}reconnecting\n"));
		    if (check < 0)
			return check;
		}
	    }
#endif
	} else {
	    status = 5;		/* Failed status set as flag. - FM */
	}
	if (status != 1) {	/* Failed : try to CWD to it */
	    /* Clear any login messages if this isn't the login directory */
	    if (strcmp(filename, "/"))
		init_help_message_cache();

	    status = send_cwd(filename);
	    if (status == 2) {	/* Succeeded : let's NAME LIST it */
		isDirectory = YES;
		if (use_list)
		    status = send_cmd_1("LIST");
		else
		    status = send_cmd_1("NLST");
	    }
	}
	FREE(fname);
	FREE(vmsname);
	if (status != 1) {
	    init_help_message_cache();	/* to free memory */
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    if (status < 0)
		return status;
	    else
		return -status;
	}
    }

  listen:
    if (!ftp_local_passive) {
	/* Wait for the connection */
#ifdef INET6
	struct sockaddr_storage soc_address;

#else
	struct sockaddr_in soc_address;
#endif /* INET6 */
	LY_SOCKLEN soc_addrlen = sizeof(soc_address);

#ifdef SOCKS
	if (socks_flag)
	    status = Raccept(master_socket,
			     (struct sockaddr *) &soc_address,
			     &soc_addrlen);
	else
#endif /* SOCKS */
	    status = accept(master_socket,
			    (struct sockaddr *) &soc_address,
			    &soc_addrlen);
	if (status < 0) {
	    init_help_message_cache();	/* to free memory */
	    return HTInetStatus("accept");
	}
	CTRACE((tfp, "TCP: Accepted new socket %d\n", status));
	data_soc = status;
    }
    /* !ftp_local_passive */
#if 0				/* no - this makes the data connection go away too soon (2.8.3dev.22) */
    if ((status = send_cmd_nowait("QUIT")) == 1)
	outstanding++;
#endif

    if (isDirectory) {
	if (server_type == UNIX_SERVER && !unsure_type &&
	    !strcmp(response_text,
		    "150 Opening ASCII mode data connection for /bin/dl.\n")) {
	    CTRACE((tfp, "HTFTP: Treating as \"dls\" server.\n"));
	    server_type = DLS_SERVER;
	}
	final_status = read_directory(anchor, name, format_out, sink);
	if (final_status > 0) {
	    if (server_type != CMS_SERVER)
		if (outstanding-- > 0) {
		    status = response(0);
		    if (status < 0 ||
			(status == 2 && !strncmp(response_text, "221", 3)))
			outstanding = 0;
		}
	} else {		/* HT_INTERRUPTED */
	    /* User may have pressed 'z' to give up because no
	       packets got through, so let's not make them wait
	       any longer - kw */
	    outstanding = 0;
	}

	if (data_soc != -1) {	/* normally done in read_directory */
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	    if (status == -1)
		HTInetStatus("close");	/* Comment only */
	}
	status = final_status;
    } else {
	int rv;
	char *FileName = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);

	/* Clear any login messages */
	init_help_message_cache();

	/* Fake a Content-Encoding for compressed files. - FM */
	HTUnEscape(FileName);
	if (!IsUnityEnc(encoding)) {
	    /*
	     * We already know from the call to HTFileFormat above that this is
	     * a compressed file, no need to look at the filename again.  - kw
	     */
	    StrAllocCopy(anchor->content_type, format->name);
	    StrAllocCopy(anchor->content_encoding, HTAtom_name(encoding));
	    format = HTAtom_for("www/compressed");

	} else {
	    int rootlen;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &rootlen);

	    if (cft != cftNone) {
		FileName[rootlen] = '\0';
		format = HTFileFormat(FileName, &encoding, NULL);
		format = HTCharsetFormat(format, anchor, -1);
		StrAllocCopy(anchor->content_type, format->name);
		format = HTAtom_for("www/compressed");

		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    break;
		case cftGzip:
		    StrAllocCopy(anchor->content_encoding, "x-gzip");
		    break;
		case cftDeflate:
		    StrAllocCopy(anchor->content_encoding, "x-deflate");
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    break;
		case cftNone:
		    break;
		}
	    }
	}
	FREE(FileName);

	_HTProgress(gettext("Receiving FTP file."));
	rv = HTParseSocket(format, format_out, anchor, data_soc, sink);

	HTInitInput(control->socket);
	/* Reset buffering to control connection DD 921208 */

	if (rv < 0) {
#if 0				/* any known servers where ABOR would work this way? */
	    if (rv == HT_INTERRUPTED || rv == -501)
		if (send_cmd_nowait("ABOR") == 1) {
		    outstanding++;
		    CTRACE((tfp, "HTFTP: outstanding responses: %d\n", outstanding));
		}
#endif
	    if (rv == -2)	/* weird error, don't expect much response */
		outstanding--;
	    else if (rv == HT_INTERRUPTED || rv == -1)
		/* User may have pressed 'z' to give up because no
		   packets got through, so let's not make them wait
		   longer - kw */
		outstanding = 0;
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	} else
	    status = 2;		/* data_soc already closed in HTCopy - kw */

	if (status < 0 && rv != HT_INTERRUPTED && rv != -1) {
	    (void) HTInetStatus("close");	/* Comment only */
	} else {
	    if (rv != HT_LOADED && outstanding--) {
		status = response(0);	/* Pick up final reply */
		if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		    data_soc = -1;	/* invalidate it */
		    init_help_message_cache();	/* to free memory */
		    return HTLoadError(sink, 500, response_text);
		} else if (status <= 0) {
		    outstanding = 0;
		} else if (status == 2 && !strncmp(response_text, "221", 3))
		    outstanding = 0;
	    }
	}
	final_status = HT_LOADED;
    }
    while (outstanding-- > 0 &&
	   (status > 0)) {
	status = response(0);
	if (status == 2 && !strncmp(response_text, "221", 3))
	    break;
    }
    data_soc = -1;		/* invalidate it */
    CTRACE((tfp, "HTFTPLoad: normal end; "));
    if (control->socket < 0) {
	CTRACE((tfp, "control socket is %d\n", control->socket));
    } else {
	CTRACE((tfp, "closing control socket %d\n", control->socket));
	status = NETCLOSE(control->socket);
	if (status == -1)
	    HTInetStatus("control connection close");	/* Comment only */
    }
    control->socket = -1;
    init_help_message_cache();	/* to free memory */
    /* returns HT_LOADED (always for file if we get here) or error */
    return final_status;
}				/* open_file_read */

/*
 *  This function frees any user entered password, so that
 *  it must be entered again for a future request. - FM
 */
void HTClearFTPPassword(void)
{
    /*
     * Need code to check cached documents from non-anonymous ftp accounts and
     * do something to ensure that they no longer can be accessed without a new
     * retrieval.  - FM
     */

    /*
     * Now free the current user entered password, if any.  - FM
     */
    FREE(user_entered_password);
}

#endif /* ifndef DISABLE_FTP */
@


1.4
log
@from OpenBSD (with minor changes):
- default to ftp passive (deraadt)
When passive FTP fails, switch to active FTP and try again

Submitted by Andrew Basterfield <bob@@cemetery.homeunix.org>
@
text
@d1 46
a46 18
/* $MirBSD: licence.template,v 1.4 2003/07/07 19:03:08 tg Exp $
 *-
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
 *
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicense it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extend permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
 *-
 * These are patches to the Lynx web browser, which is licensed under
 * the GNU General Public License, Version 2.
a48 48
/*			File Transfer Protocol (FTP) Client
**			for a WorldWideWeb browser
**			===================================
**
**	A cache of control connections is kept.
**
** Note: Port allocation
**
**	It is essential that the port is allocated by the system, rather
**	than chosen in rotation by us (POLL_PORTS), or the following
**	problem occurs.
**
**	It seems that an attempt by the server to connect to a port which has
**	been used recently by a listen on the same socket, or by another
**	socket this or another process causes a hangup of (almost exactly)
**	one minute.  Therefore, we have to use a rotating port number.
**	The problem remains that if the application is run twice in quick
**	succession, it will hang for what remains of a minute.
**
** Authors
**	TBL	Tim Berners-lee <timbl@@info.cern.ch>
**	DD	Denis DeLaRoca 310 825-4580 <CSP1DWD@@mvs.oac.ucla.edu>
**	LM	Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
**	FM	Foteos Macrides <macrides@@sci.wfeb.edu>
** History:
**	 2 May 91	Written TBL, as a part of the WorldWideWeb project.
**	15 Jan 92	Bug fix: close() was used for NETCLOSE for control soc
**	10 Feb 92	Retry if cached connection times out or breaks
**	 8 Dec 92	Bug fix 921208 TBL after DD
**	17 Dec 92	Anon FTP password now just WWWuser@@ suggested by DD
**			fails on princeton.edu!
**	27 Dec 93 (FM)	Fixed up so FTP now works with VMS hosts.  Path
**			must be Unix-style and cannot include the device
**			or top directory.
**	?? ??? ?? (LM)	Added code to prompt and send passwords for non
**			anonymous FTP
**	25 Mar 94 (LM)	Added code to recognize different ftp server types
**			and code to parse dates and sizes on most hosts.
**	27 Mar 93 (FM)	Added code for getting dates and sizes on VMS hosts.
**
** Notes:
**			Portions Copyright 1994 Trustees of Dartmouth College
**			Code for recognizing different FTP servers and
**			parsing "ls -l" output taken from Macintosh Fetch
**			program with permission from Jim Matthews,
**			Dartmouth Software Development Team.
*/

d50 9
a58 9
BUGS:	@@@@@@	Limit connection cache size!
		Error reporting to user.
		400 & 500 errors are ack'ed by user with windows.
		Use configuration file for user names

**		Note for portability this version does not use select() and
**		so does not watch the control and data channels at the
**		same time.
*/
d64 1
a64 1
#include <HTFTP.h>	/* Implemented here */
d69 2
a70 2
#define REPEAT_PORT	/* Give the port number for each file */
#define REPEAT_LISTEN	/* Close each listen socket and open a new one */
d73 1
a73 1
#define LISTEN_BACKLOG 2	/* Number of pending connect requests (TCP)*/
d82 1
a82 1
#include <HTFile.h>	/* For HTFileFormat() */
d95 4
a98 4
    struct _connection *	next;	/* Link on list		*/
    u_long			addr;	/* IP address		*/
    int				socket; /* Socket number for communication */
    BOOL			binary; /* Binary mode? */
d105 50
a154 6
#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)
#define ABORT_TARGET (*targetClass._free)(target)
d156 2
a157 2
	CONST HTStructuredClass *	isa;
	/* ... */
d161 9
a169 8
**	---------------------
*/
PUBLIC int HTfileSortMethod = FILE_BY_NAME;
#ifndef DISABLE_FTP /*This disables everything to end-of-file */
PRIVATE char ThisYear[8];
PRIVATE char LastYear[8];
PRIVATE int TheDate;
PRIVATE BOOLEAN HaveYears = FALSE;
d172 25
a196 8
**	---------------------
*/
PRIVATE connection * connections = NULL;/* Linked list of connections */
PRIVATE char response_text[LINE_LENGTH+1];/* Last response from ftp host */
PRIVATE connection * control = NULL;	/* Current connection */
PRIVATE int data_soc = -1;		/* Socket for data transfer =invalid */
PRIVATE char *user_entered_password = NULL;
PRIVATE char *last_username_and_host = NULL;
d199 16
a214 16
	GENERIC_SERVER
	, MACHTEN_SERVER
	, UNIX_SERVER
	, VMS_SERVER
	, CMS_SERVER
	, DCTS_SERVER
	, TCPC_SERVER
	, PETER_LEWIS_SERVER
	, NCSA_SERVER
	, WINDOWS_NT_SERVER
	, WINDOWS_2K_SERVER
	, MS_WINDOWS_SERVER
	, MSDOS_SERVER
	, APPLESHARE_SERVER
	, NETPRESENZ_SERVER
	, DLS_SERVER
d217 3
a219 3
PRIVATE eServerType server_type = GENERIC_SERVER; /* the type of ftp host */
PRIVATE int	unsure_type = FALSE;		/* sure about the type? */
PRIVATE BOOLEAN use_list = FALSE;		/* use the LIST command? */
d221 1
a221 1
PRIVATE int	interrupted_in_next_data_char = FALSE;
d224 1
a224 1
PRIVATE PortNumber	port_number = FIRST_TCP_PORT;
d227 5
a231 6
PRIVATE int	master_socket = -1;	/* Listening socket = invalid	*/
PRIVATE char	port_command[255];	/* Command for setting the port */
PRIVATE fd_set	open_sockets;		/* Mask of active channels */
PRIVATE int	num_sockets;		/* Number of sockets to scan */
PRIVATE PortNumber	passive_port;	/* Port server specified for data */

d236 4
a239 3
PRIVATE char data_buffer[DATA_BUFFER_SIZE];		/* Input data buffer */
PRIVATE char * data_read_pointer;
PRIVATE char * data_write_pointer;
d241 1
a241 3
PRIVATE int close_connection PARAMS((
	connection *	con));

d245 3
a247 3
**  This function frees module globals. - FM
*/
PRIVATE void free_FTPGlobals NOARGS
d260 12
a271 13
**		CONVERTS WWW name into a VMS name
** ON ENTRY:
**	nn		Node Name (optional)
**	fn		WWW file name
**
** ON EXIT:
**	returns		vms file specification
**
** Bug: Returns pointer to static -- non-reentrant
*/
PUBLIC char * HTVMS_name ARGS2(
	CONST char *,	nn,
	CONST char *,	fn)
d273 6
a278 8

/*	We try converting the filename into Files-11 syntax.  That is, we assume
**	first that the file is, like us, on a VMS node.  We try remote
**	(or local) DECnet access.  Files-11, VMS, VAX and DECnet
**	are trademarks of Digital Equipment Corporation.
**	The node is assumed to be local if the hostname WITHOUT DOMAIN
**	matches the local one. @@@@@@
*/
d280 2
a281 2
    char * filename = (char*)malloc(strlen(fn)+1);
    char * nodename = (char*)malloc(strlen(nn)+2+1);	/* Copies to hack */
d285 1
a285 1
    CONST char * hostname = HTHostName();
d292 3
a294 2
	CONST char *p;
	CONST char *q;
d296 1
a296 1
	     *p && *p != '.' && *q && *q != '.'; p++, q++){
d299 1
d303 1
a303 1
		    *r = '\0';			/* Chop domain */
d310 1
a310 1
    second = strchr(filename+1, '/');		/* 2nd slash */
d313 1
a313 1
    if (!second) {				/* Only one slash */
d315 1
a315 1
    } else if (second == last) {		/* Exactly two slashes */
d317 5
a321 4
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename+1, second+1);
	*second = '/';	/* restore */
    } else {				/* More than two slashes */
	char * p;
d325 1
a325 1
		nodename, filename+1, second+1, last+1);
d327 1
a327 1
	for (p = strchr(vmsname, '['); *p!=']'; p++)
d329 1
a329 1
		*p = '.';		/* Convert dir sep.  to dots */
d337 3
a339 3
**	----------------------------------------------------
*/
PRIVATE int next_data_char NOARGS
d342 1
d345 6
a350 6
      if (status == HT_INTERRUPTED)
	interrupted_in_next_data_char = 1;
      if (status <= 0)
	return -1;
      data_write_pointer = data_buffer + status;
      data_read_pointer = data_buffer;
d355 1
a362 1

d364 3
a366 4
**
*/
PRIVATE int close_connection ARGS1(
	connection *,	con)
d368 1
a368 1
    connection * scan;
d370 1
d390 1
a390 1
		control = (connection*)0;
d392 3
a394 3
	} /*if */
    } /* for */
    return -1;		/* very strange -- was not on list. */
d397 1
a397 1
PRIVATE char *help_message_buffer = NULL;  /* global :( */
d399 1
a399 1
PRIVATE void init_help_message_cache NOARGS
d404 1
a404 2
PRIVATE void help_message_cache_add ARGS1(
	char *,		string)
d411 1
a411 1
    CTRACE((tfp,"Adding message to help cache: %s\n",string));
d414 1
a414 1
PRIVATE char *help_message_cache_non_empty NOARGS
d416 1
a416 1
  return(help_message_buffer);
d419 1
a419 1
PRIVATE char *help_message_cache_contents NOARGS
d421 1
a421 1
   return(help_message_buffer);
d425 17
a441 18
**	----------------
**
**	This function checks whether we have a control connection, and sends
**	one command if given.
**
** On entry,
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
**
**	The command should already be terminated with the CRLF pair.
**
** On exit,
**	returns:  1 for success,
**		  or negative for communication failure (in which case
**		  the control connection will be closed).
*/
PRIVATE int write_cmd ARGS1(
	char *,		cmd)
d447 1
a447 1
	return -99;
d454 2
a455 1
	    char * p;
d461 1
a461 1
	status = NETWRITE(control->socket, cmd, (int)strlen(cmd));
d463 3
a465 2
	    CTRACE((tfp, "HTFTP: Error %d sending command: closing socket %d\n",
			status, control->socket));
d474 21
a494 22
**	--------------------------------
**
**	See the state machine illustrated in RFC959, p57. This implements
**	one command/reply sequence.  It also interprets lines which are to
**	be continued, which are marked with a "-" immediately after the
**	status code.
**
**	Continuation then goes on until a line with a matching reply code
**	an a space after it.
**
** On entry,
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
**
**	The command must already be terminated with the CRLF pair.
**
** On exit,
**	returns:  The first digit of the reply type,
**		  or negative for communication failure.
*/
PRIVATE int response ARGS1(
	char *,		cmd)
d496 1
a496 1
    int result;				/* Three-digit decimal code */
d505 1
d508 1
d510 1
a510 1
			|| (p == &response_text[LINE_LENGTH])) {
d515 3
a517 2
		    CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		    NETCLOSE (control->socket);
d522 1
a522 1
		*p = '\0';			/* Terminate the string */
d526 4
a529 4
		if (!strncmp(response_text,"230-",4) ||
		    !strncmp(response_text,"250-",4) ||
		    !strncmp(response_text,"220-",4))
		    help_message_cache_add(response_text+4);
d532 3
a534 3
		if  (continuation_response == -1) {
			if (continuation == '-')  /* start continuation */
			    continuation_response = result;
d536 15
a550 3
			if (continuation_response == result &&
			    continuation == ' ')
			    continuation_response = -1; /* ended */
d552 1
d554 2
a555 2
	    } /* if end of line */

d557 3
a559 2
		CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		NETCLOSE (control->socket);
d566 1
a566 1
			    control->socket));
d571 1
a571 1
	} /* Loop over characters */
d577 1
a577 1
		    control->socket));
d585 2
a586 2
	**  Alas, CMS returns 255 on failure to CWD to parent of root. - PG
	*/
d589 1
a589 1
    return result/100;
d592 1
a592 1
PRIVATE int send_cmd_1 ARGS1(char *, verb)
d596 2
a597 2
    sprintf(command, "%.*s%c%c", (int) sizeof(command)-4, verb, CR, LF);
    return response (command);
d600 1
a600 1
PRIVATE int send_cmd_2 ARGS2(char *, verb, char *, param)
d606 1
a606 1
    status = response (command);
d615 2
a616 2
 *  This function should try to set the macintosh server into binary mode.
 *  Some servers need an additional letter after the MACB command.
d618 1
a618 2
PRIVATE int set_mac_binary ARGS1(
	eServerType,	ServerType)
d624 1
a624 1
	 *  Presumably E means "Enable".  - KW
d626 1
a626 1
	return(2 == response("MACB E\r\n"));
d628 1
a628 1
	return(2 == response("MACB\r\n"));
d636 1
a636 3
PRIVATE void get_ftp_pwd ARGS2(
	eServerType *,	ServerType,
	BOOLEAN *,	UseList)
d638 1
a639 1
    char *cp;
d642 1
d646 1
a646 1
	cp = strchr(response_text+5,'"');
d651 1
a651 1
					  NCSA_SERVER : TCPC_SERVER);
d653 2
a654 2
			 ((*ServerType == NCSA_SERVER) ?
						 "NCSA" : "TCPC")));
d663 3
a665 3
		 *ServerType = UNIX_SERVER;
		 *UseList = TRUE;
		 CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d668 1
a668 1
	} else if (response_text[strlen(response_text)-1] == ']') {
d690 1
a690 3
PRIVATE void set_unix_dirstyle ARGS2(
	eServerType *,	ServerType,
	BOOLEAN *,	UseList)
d692 1
a693 1
    char *cp;
d699 1
d715 1
a715 1
	cp = strstr(response_text+4, "MSDOS");
d725 16
a740 17
**	----------------------------------
**
** On entry,
**	arg	points to the name of the host in a hypertext address
** On exit,
**	returns <0 if error
**		socket number if success
**
**	This routine takes care of managing timed-out connections, and
**	limiting the number of connections in use at any one time.
**
**	It ensures that all connections are logged in if they exist.
**	It ensures they have the port number transferred.
*/
PRIVATE int get_connection ARGS2(
	CONST char *,		arg,
	HTParentAnchor *,	anchor)
d743 4
a746 4
    char * command = 0;
    connection * con;
    char * username = NULL;
    char * password = NULL;
d751 2
a752 2
	**  Set up freeing at exit. - FM
	*/
d761 2
a762 2
	**  Reuse this object - KW, DW & FM
	*/
d771 2
a772 2
	**  Allocate and init control struct.
	*/
d779 4
a782 2
    if (!arg) return -1;		/* Bad if no name specified	*/
    if (!*arg) return -1;		/* Bad if name had zero length	*/
d790 1
a790 1
	char * pw = NULL;
d794 2
a795 2
	    *p2 = '\0';			/* terminate */
	    p1 = p2+1;			/* point to host */
d805 3
a807 4
	     *	If the password doesn't exist then we are going to have
	     *	to ask the user for it.  The only problem is that we
	     *	don't want to ask for it every time, so we will store
	     *	away in a primitive fashion.
d814 3
a816 3
		 *  If the user@@host is not equal to the last time through
		 *  or user_entered_password has no data then we need
		 *  to ask the user for the password.
d824 1
a824 1
				     username, p1);
d828 1
a828 1
		} /* else we already know the password */
d836 1
a836 1
    } /* scope of p1 */
d838 1
a838 1
    status = HTDoConnect (arg, "FTP", IPPORT_FTP, (int *)&con->socket);
d845 1
a845 1
			arg));
d848 1
a848 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d853 2
a854 3
	if (con->socket != -1)
	{
	  NETCLOSE(con->socket);
d861 1
a861 1
	return status;			/* Bad return */
d865 1
a865 1
		con->socket, con));
a871 1

d874 1
a874 1
    status = response((char *)0);	/* Get greeting */
d878 1
a878 1
	_HTProgress (CONNECTION_INTERRUPTED);
d907 1
a907 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d923 1
d925 10
a934 2
	    CONST char *host = NULL;
	    char * cp;
d936 6
a941 8
	    if (personal_mail_address && *personal_mail_address) {
		/*
		 * We have a non-zero length personal
		 * mail address, so use that. - FM
		 */
		StrAllocCopy(user, personal_mail_address);
		if ((cp=strchr(user, '@@')) != NULL) {
		    *cp++ = '\0';
a942 3
		} else {
		    host = HTHostName();
		}
a943 7
		/*
		 * Use an environment variable and the host global. - FM
		 */
		if ((cp=LYGetEnv("USER")) != NULL)
		    StrAllocCopy(user, cp);
		else
		    StrAllocCopy(user, "WWWuser");
d961 1
a961 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d973 1
a973 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d987 1
a987 1
    /** Check for host type **/
d990 2
a991 2
    use_list = FALSE;			/* reset */
    if ((status=response("SYST\r\n")) == 2) {
d993 1
a993 1
	if (strncmp(response_text+4,
d999 2
a1000 2
	} else if (strstr(response_text+4, "UNIX") != NULL ||
		   strstr(response_text+4, "Unix") != NULL) {
d1002 1
a1002 1
	    unsure_type = FALSE; /* to the best of out knowledge... */
d1006 1
a1006 1
	} else if (strstr(response_text+4, "MSDOS") != NULL) {
d1011 1
a1011 1
	} else if (strncmp(response_text+4, "VMS", 3) == 0) {
d1013 1
d1016 2
a1017 2
	     && tilde[2] != 0
	     && strstr(response_text+4, "MadGoat") != 0) {
d1025 2
a1026 2
	} else if ((strncmp(response_text+4, "VM/CMS", 6) == 0) ||
		   (strncmp(response_text+4, "VM ", 3) == 0)) {
d1031 1
a1031 1
	} else if (strncmp(response_text+4, "DCTS", 4) == 0) {
d1035 1
a1035 1
	} else if (strstr(response_text+4, "MAC-OS TCP/Connect II") != NULL) {
d1041 1
a1041 1
	} else if (server_type == NETPRESENZ_SERVER) { /* already set above */
d1046 1
a1046 1
	} else if (strncmp(response_text+4, "MACOS Peter's Server", 20) == 0) {
d1052 1
a1052 1
	} else if (strncmp(response_text+4, "Windows_NT", 10) == 0) {
d1057 1
a1057 1
	} else if (strncmp(response_text+4, "Windows2000", 11) == 0) {
d1062 1
a1062 1
	} else if (strncmp(response_text+4, "MS Windows", 10) == 0) {
d1067 1
a1067 1
	} else if (strncmp(response_text+4,
d1074 1
a1074 1
	} else	{
d1079 1
a1079 1
	 }
d1082 1
a1082 1
	 get_ftp_pwd(&server_type, &use_list);
d1090 1
d1094 1
a1094 1
	    return -status;		/* Bad return */
d1099 1
a1099 1
    return con->socket;			/* Good return */
a1101 1

d1103 5
a1107 5
**	-------------------------------
**
**
*/
PRIVATE int close_master_socket NOARGS
a1121 1

d1123 14
a1136 14
**	-------------------------------------
**
**	When data is transferred, we open a port, and wait for the server to
**	connect with the data.
**
** On entry,
**	master_socket	Must be negative if not set up already.
** On exit,
**	Returns		socket number if good
**			less than zero if error.
**	master_socket	is socket number if good, else negative.
**	port_number	is valid if good.
*/
PRIVATE int get_listen_socket NOARGS
d1140 1
a1140 1
    struct sockaddr_in* soc_in = (struct sockaddr_in *)&soc_address;
d1142 2
a1143 1
    int slen;
d1146 1
a1146 1
    struct sockaddr_in* soc_in = &soc_address;
d1148 1
a1148 2
    int new_socket;			/* Will be master_socket */

d1155 1
a1155 1
	return master_socket;  /* Done already */
d1161 2
a1162 2
    if (getsockname(control->socket, (struct sockaddr *)&soc_address,
		&slen) < 0) {
d1165 1
a1165 1
    af = ((struct sockaddr *)&soc_address)->sa_family;
d1186 1
a1186 1
    ((struct sockaddr *)&soc_address)->sa_family = af;
d1190 1
a1190 1
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in);
d1195 1
a1195 1
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in6);
d1202 2
a1203 2
    soc_in->sin_family = AF_INET;	    /* Family = internet, host order  */
    soc_in->sin_addr.s_addr = INADDR_ANY;   /* Any peer address */
d1208 2
a1209 1
	for (port_number = (old_port_number+1); ; port_number++) {
d1211 1
d1224 4
a1227 4
		if ((status=Rbind(new_socket,
			(struct sockaddr*)&soc_address,
			    /* Cast to generic sockaddr */
			SOCKADDR_LEN(soc_address)
d1229 1
a1229 1
			,socks_bind_remoteAddr
d1231 1
a1231 1
						)) == 0) {
d1235 7
a1241 7
	    if ((status=bind(new_socket,
		    (struct sockaddr*)&soc_address,
			    /* Cast to generic sockaddr */
		    SOCKADDR_LEN(soc_address)
		    )) == 0) {
		break;
	    }
d1243 2
a1244 2
		port_number, status, SOCKET_ERRNO));
	} /* for */
d1249 2
a1250 1
	int address_length = sizeof(soc_address);
d1254 2
a1255 2
				  (struct sockaddr *)&soc_address,
				  (void *)&address_length);
d1258 5
a1262 4
	status = getsockname(control->socket,
			     (struct sockaddr *)&soc_address,
			     (void *)&address_length);
	if (status<0) return HTInetStatus("getsockname");
d1265 1
a1265 1
	    HTInetString((SockA *)soc_in)));
d1270 1
a1270 1
	    HTInetString(soc_in)));
d1276 4
a1279 4
	    status=Rbind(new_socket,
			 (struct sockaddr*)&soc_address,
			 /* Cast to generic sockaddr */
			 sizeof(soc_address)
d1282 1
a1282 1
			socks_bind_remoteAddr
d1284 1
a1284 1
			,socks_bind_remoteAddr
d1287 1
a1287 1
						);
d1290 7
a1296 6
	status=bind(new_socket,
		    (struct sockaddr*)&soc_address,
		    /* Cast to generic sockaddr */
		    SOCKADDR_LEN(soc_address)
		    );
	if (status<0) return HTInetStatus("bind");
d1302 2
a1303 2
				  (struct sockaddr*)&soc_address,
				  (void *)&address_length);
d1306 5
a1310 4
	status = getsockname(new_socket,
			     (struct sockaddr*)&soc_address,
			     (void *)&address_length);
	if (status<0) return HTInetStatus("getsockname");
d1316 2
a1317 2
		(int)ntohs(soc_in->sin_port),
		HTInetString((SockA *)soc_in)));
d1320 2
a1321 2
		(int)ntohs(soc_in->sin_port),
		HTInetString(soc_in)));
d1333 1
a1333 1
    (void)HTHostName();		/* Make address valid - doesn't work*/
d1335 1
a1335 1
    switch (((struct sockaddr *)&soc_address)->sa_family) {
d1339 7
a1345 7
		    (int)*((unsigned char *)(&soc_in->sin_addr)+0),
		    (int)*((unsigned char *)(&soc_in->sin_addr)+1),
		    (int)*((unsigned char *)(&soc_in->sin_addr)+2),
		    (int)*((unsigned char *)(&soc_in->sin_addr)+3),
		    (int)*((unsigned char *)(&soc_in->sin_port)+0),
		    (int)*((unsigned char *)(&soc_in->sin_port)+1),
		    CR, LF);
d1351 12
a1362 11
      {
	char hostbuf[MAXHOSTNAMELEN];
	char portbuf[MAXHOSTNAMELEN];
	getnameinfo((struct sockaddr *)&soc_address,
	    SOCKADDR_LEN(soc_address),
	    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
	    NI_NUMERICHOST | NI_NUMERICSERV);
	sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		CR, LF);
	break;
      }
d1369 2
a1370 2
    /*	Inform TCP that we will accept connections
    */
d1373 1
d1387 2
a1388 2
    if ((master_socket+1) > num_sockets)
	num_sockets = master_socket+1;
d1390 1
a1390 1
    return master_socket;		/* Good */
d1392 1
a1392 1
} /* get_listen_socket */
d1394 4
a1397 2
PRIVATE char * months[12] = {
    "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
d1401 10
a1410 10
**	-----------------------------------------------------------------
**
**	Bug:
**		This code is for sorting listings by date, if that option
**		is selected in Lynx, and doesn't take into account time
**		zones or ensure resetting at midnight, so the sort may not
**		be perfect, but the actual date isn't changed in the display,
**		i.e., the date is still correct. - FM
*/
PRIVATE void set_years_and_date NOARGS
d1417 1
a1417 1
    strncpy(day, (char *)ctime(&NowTime)+8, 2);
d1422 1
a1422 1
    strncpy(month, (char *)ctime(&NowTime)+4, 3);
d1432 1
a1432 1
    strcpy(ThisYear, (char *)ctime(&NowTime)+20);
d1439 4
a1442 3
    char *	 filename;
    char *	 type;
    char *	 date;
d1444 1
a1444 1
    BOOLEAN	 display;  /* show this entry? */
d1447 1
a1447 2
PRIVATE void free_entryinfo_struct_contents ARGS1(
	EntryInfo *,	entry_info)
d1451 1
d1455 1
a1455 1
   /* dont free the struct */
d1466 1
a1466 2
PRIVATE BOOLEAN is_ls_date ARGS1(
	char *,		s)
d1528 1
a1528 1
} /* is_ls_date() */
d1531 1
a1531 2
 *  parse_eplf_line() --
 *	Extract the name, size, and date from an EPLF line. - 08-06-96 DJB
d1533 2
a1534 3
PRIVATE void parse_eplf_line ARGS2(
	char *,		line,
	EntryInfo *,	info)
d1540 1
a1540 1
    static time_t base; /* time() value on this OS in 1970 */
d1545 7
a1551 2
	t.tm_year = 70; t.tm_mon = 0; t.tm_mday = 0;
	t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0;
d1553 1
a1553 1
	base = mktime(&t); /* could return -1 */
d1558 28
a1585 28
	switch(*cp) {
	    case '\t':
		StrAllocCopy(info->filename, cp + 1);
		return;
	    case 's':
		size = 0;
		while (*(++cp) && (*cp != ','))
		    size = (size * 10) + (*cp - '0');
		info->size = size;
		break;
	    case 'm':
		secs = 0;
		while (*(++cp) && (*cp != ','))
		    secs = (secs * 10) + (*cp - '0');
		secs += base; /* assumes that time_t is #seconds */
		strcpy(ct, ctime(&secs));
		ct[24] = 0;
		StrAllocCopy(info->date, ct);
		break;
	    case '/':
		StrAllocCopy(info->type, ENTRY_IS_DIRECTORY);
		/* FALLTHRU */
	    default:
		while (*cp) {
		    if (*cp++ == ',')
		      break;
		}
		break;
d1588 1
a1588 1
} /* parse_eplf_line */
d1591 1
a1591 2
 * parse_ls_line() --
 *	Extract the name, size, and date from an ls -l line.
d1593 6
a1598 7
PRIVATE void parse_ls_line ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
{
    int    i, j;
    int    base=1;
    int    size_num=0;
d1601 2
a1602 2
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i-12])); i--)
	; /* null body */
d1605 1
a1605 1
	StrAllocCopy(entry_info->date, &line[i-12]);
d1612 1
a1612 1
		entry_info->date[j] = entry_info->date[j-1];
d1624 1
a1624 1
} /* parse_ls_line() */
d1627 11
a1637 13
 * parse_dls_line() --
 *	Extract the name and size info and whether it refers to a
 *      directory from a LIST line in "dls" format.
 */
PRIVATE void parse_dls_line ARGS3(
	char *,		line,
	EntryInfo *,	entry_info,
	char **,	pspilledname)
{
    short  j;
    int    base=1;
    int    size_num=0;
    int    len;
d1640 8
a1647 8
    /* README		   763	Information about this server\0
       bin/		     -	\0
       etc/		     =	\0
       ls-lR		     0	\0
       ls-lR.Z		     3	\0
       pub/		     =	Public area\0
       usr/		     -	\0
       morgan		    14	-> ../real/morgan\0
d1649 2
a1650 2
			 79215	\0
	*/
d1672 1
a1672 1
	    if (entry_info->filename[strlen(entry_info->filename)-1] == '/')
d1678 1
a1678 1
	    if (cps && cps != line && *(cps-1) == '/')
d1702 1
d1716 4
a1719 4
    if (len > 0 && line[len-1] == '/') {
		/*
		**  It's a dir, remove / and mark it as such.
		*/
d1721 1
a1721 1
	    line[len-1] = '\0';
d1728 1
a1728 1
} /* parse_dls_line() */
d1735 2
a1736 3
PRIVATE void parse_vms_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d1740 2
a1741 1
    char *cp, *cpd, *cps, date[16], *sp = " ";
d1743 3
a1745 2
    /**  Get rid of blank lines, and information lines.  **/
    /**  Valid lines have the ';' version number token.  **/
d1751 3
a1753 3
    /** Cut out file or directory name at VMS version number. **/
    *cp++ ='\0';
    StrAllocCopy(entry_info->filename,line);
d1755 1
a1755 1
    /** Cast VMS non-README file and directory names to lowercase. **/
d1774 1
a1774 1
    /** Uppercase terminal .z's or _z's. **/
d1777 2
a1778 2
	(entry_info->filename[i-1] == '.' ||
	 entry_info->filename[i-1] == '_'))
d1781 3
a1783 3
    /** Convert any tabs in rest of line to spaces. **/
    cps = cp-1;
    while ((cps=strchr(cps+1, '\t')) != NULL)
d1786 3
a1788 2
    /** Collapse serial spaces. **/
    i = 0; j = 1;
d1798 1
a1798 1
    /* Set the years and date, if we don't have them yet. **/
d1803 13
a1815 13
    /** Track down the date. **/
    if ((cpd=strchr(cp, '-')) != NULL &&
	strlen(cpd) > 9 && isdigit(UCH(*(cpd-1))) &&
	isalpha(UCH(*(cpd+1))) && *(cpd+4) == '-') {

	/** Month **/
	*(cpd+2) = (char) TOLOWER(*(cpd+2));
	*(cpd+3) = (char) TOLOWER(*(cpd+3));
	sprintf(date, "%.3s ", cpd+1);

	/** Day **/
	if (isdigit(UCH(*(cpd-2))))
	    sprintf(date+4, "%.2s ", cpd-2);
d1817 1
a1817 1
	    sprintf(date+4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd-1);
d1819 4
a1822 4
	/** Time or Year **/
	if (!strncmp(ThisYear, cpd+5, 4) &&
	    strlen(cpd) > 15 && *(cpd+12) == ':') {
	    sprintf(date+7, "%.5s", cpd+10);
d1824 1
a1824 1
	    sprintf(date+7, " %.4s", cpd+5);
d1830 2
a1831 2
    /** Track down the size **/
    if ((cpd=strchr(cp, '/')) != NULL) {
d1834 1
a1834 1
	while (isdigit(UCH(*(cps-1))))
d1839 1
a1839 1
	cps = cpd+1;
d1843 1
a1843 1
	ialloc = atoi(cpd+1);
d1848 1
a1848 1
    } else if ((cps=strtok(cp, sp)) != NULL) {
d1851 1
a1851 1
	while ((cps=strtok(NULL, sp)) != NULL) {
d1863 5
a1867 5
    /** Wrap it up **/
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %d\n",
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d1869 1
a1869 1
} /* parse_vms_dir_entry() */
d1876 2
a1877 3
PRIVATE void parse_ms_windows_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d1883 1
a1883 1
    /**  Get rid of blank or junk lines.  **/
d1890 1
a1890 1
    /** Cut out file or directory name. **/
d1892 1
a1892 1
    *cps++ ='\0';
d1896 1
a1896 1
    /** Track down the size **/
d1910 1
a1910 1
    /* Set the years and date, if we don't have them yet. **/
d1915 1
a1915 1
    /** Track down the date. **/
d1919 4
a1922 4
	    *(cpd+6)  = '\0';  /* Month and Day */
	    *(cpd+11) = '\0';  /* Year */
	    *(cpd+17) = '\0';  /* Time */
	    if (strcmp(ThisYear, cpd+7))
d1924 1
a1924 1
		sprintf(date, "%.6s  %.4s", cpd, (cpd+7));
d1927 1
a1927 1
		sprintf(date, "%.6s %.5s", cpd, (cpd+12));
d1929 1
a1929 1
	    if (entry_info->date[4] == ' '|| entry_info->date[4] == '0') {
d1935 5
a1939 5
    /** Wrap it up **/
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %d\n",
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d1941 1
a1941 1
} /* parse_ms_windows_dir_entry */
d1949 2
a1950 3
PRIVATE void parse_windows_nt_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d1957 1
a1957 1
    /**  Get rid of blank or junk lines.  **/
d1964 1
a1964 1
    /** Cut out file or directory name. **/
d1966 2
a1967 2
    cps = LYSkipNonBlanks(end-1);
    cp = (cps+1);
d1978 1
a1978 1
    /* Set the years and date, if we don't have them yet. **/
d1983 1
a1983 1
    /** Cut out the date. **/
d1986 1
a1986 1
    *cps++ ='\0';
d1993 1
a1993 1
    *cps++ ='\0';
d1999 3
a2001 3
	isdigit(*cp) && isdigit(*(cp+1)) && *(cp+2) == '-' &&
	isdigit(*(cp+3)) && isdigit(*(cp+4)) && *(cp+5) == '-') {
	*(cp+2)  = '\0';	/* Month */
d2003 2
a2004 2
	*(cp+5) = '\0';		/* Day */
	sprintf(date, "%.3s %.2s", months[i], (cp+3));
d2007 2
a2008 2
	cp += 6;			/* Year */
	if (strcmp((ThisYear+2), cp)) {
d2017 1
a2017 1
	    *(cpd+2) = '\0';	/* Hour */
d2019 1
a2019 1
	    if (*(cpd+5) == 'P' || *(cpd+5) == 'p')
d2021 1
a2021 1
	    sprintf(&date[6], " %02d:%.2s", i, (cpd+3));
d2024 1
a2024 1
	if (entry_info->date[4] == ' '|| entry_info->date[4] == '0') {
d2029 1
a2029 1
    /** Track down the size **/
d2043 1
a2043 1
    /** Wrap it up **/
d2045 3
a2047 3
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d2049 1
a2049 1
} /* parse_windows_nt_dir_entry */
d2057 2
a2058 3
PRIVATE void parse_cms_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d2067 1
a2067 1
    /**  Get rid of blank or junk lines.  **/
d2074 1
a2074 1
    /** Cut out file or directory name. **/
d2076 1
a2076 1
    *cps++ ='\0';
d2079 1
a2079 1
	/** If we already have a dot, we did an NLST. **/
d2083 1
a2083 1
	/** If we don't have more, we've misparsed. **/
d2090 1
a2090 1
    *cps++ ='\0';
d2092 1
a2092 1
	/** It's an SFS directory. **/
d2096 1
a2096 1
	/** It's a file. **/
d2101 1
a2101 1
	/** Track down the VM/CMS RECFM or type. **/
d2107 1
a2107 1
	    /** Check cp here, if it's relevant someday. **/
d2111 1
a2111 1
    /** Track down the record length or dash. **/
d2122 1
a2122 1
    /** Track down the number of records or the dash. **/
d2132 1
a2132 1
	    /** Compute an approximate size. **/
d2137 1
a2137 1
    /** Set the years and date, if we don't have them yet. **/
d2142 1
a2142 1
    /** Track down the date. **/
d2147 1
a2147 1
	 isdigit(UCH(*(cps+1))) && isdigit(UCH(*(cps+2))) && *(cps+3) == ':')) {
d2152 3
a2154 3
	    *(cpd+2) = '\0';	/* Month */
	    *(cpd+5) = '\0';	/* Day */
	    *(cpd+8) = '\0';	/* Year */
d2159 1
a2159 1
	    sprintf(date, "%.3s %.2s", months[i], (cpd+3));
d2163 1
a2163 1
	    if (strcmp((ThisYear+2), cpd)) {
d2172 1
a2172 1
		*(cps+2) = '\0';	/* Hour */
d2174 1
a2174 1
		sprintf(&date[6], " %02d:%.2s", i, (cps+3));
d2177 1
a2177 1
	    if (entry_info->date[4] == ' '|| entry_info->date[4] == '0') {
d2183 5
a2187 5
    /** Wrap it up. **/
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %d\n",
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d2189 1
a2189 1
} /* parse_cms_dir_entry */
d2192 2
a2193 3
 *     parse_dir_entry()
 *	Given a line of LIST/NLST output in entry, return results
 *	and a file/dir name in entry_info struct
d2195 1
a2195 1
 *	If first is true, this is the first name in a directory.
d2197 3
a2199 5

PRIVATE EntryInfo * parse_dir_entry ARGS3(
	char *,		entry,
	BOOLEAN *,	first,
	char **,	pspilledname)
d2202 3
a2204 3
    int  i;
    int  len;
    BOOLEAN remove_size=FALSE;
d2207 2
a2208 1
    entry_info = (EntryInfo *)malloc(sizeof(EntryInfo));
d2212 1
d2219 8
a2226 1
	case DLS_SERVER:
d2228 10
a2237 20
	    /*
	    **	Interpret and edit LIST output from a Unix server
	    **  in "dls" format.
	    **  This one must have claimed to be Unix in order to
	    **  get here; if the first line looks fishy, we revert
	    **  to Unix and hope that fits better (this recovery is
	    **  untested). - kw
	    */

	    if (*first) {
		len = strlen(entry);
		if (!len || entry[0] == ' ' ||
		    (len >= 24 && entry[23] != ' ') ||
		    (len < 24 && strchr(entry, ' '))) {
		    server_type = UNIX_SERVER;
		    CTRACE((tfp,
			   "HTFTP: Falling back to treating as Unix server.\n"));
		} else {
		    *first = FALSE;
		}
d2239 1
d2241 3
a2243 3
	    if (server_type == DLS_SERVER) {
		/* if still unchanged... */
		parse_dls_line(entry, entry_info, pspilledname);
d2245 3
a2247 31
		if (!entry_info->filename || *entry_info->filename == '\0') {
		    entry_info->display = FALSE;
		    return(entry_info);
		}
		if (!strcmp(entry_info->filename,"..") ||
		    !strcmp(entry_info->filename,"."))
		    entry_info->display = FALSE;
		if (entry_info->type && *entry_info->type == '\0') {
		    FREE(entry_info->type);
		    return(entry_info);
		}
		/*
		**	Goto the bottom and get real type.
		*/
		break;
	    } /* fall through if server_type changed for *first == TRUE ! */

	case UNIX_SERVER:
	case PETER_LEWIS_SERVER:
	case MACHTEN_SERVER:
	case MSDOS_SERVER:
	case WINDOWS_NT_SERVER:
	case WINDOWS_2K_SERVER:
	case APPLESHARE_SERVER:
	case NETPRESENZ_SERVER:
	    /*
	    **	Check for EPLF output (local times).
	    */
	    if (*entry == '+') {
		parse_eplf_line(entry, entry_info);
		break;
d2249 6
a2254 25

	    /*
	    **	Interpret and edit LIST output from Unix server.
	    */
	    len = strlen(entry);
	    if (*first) {
		/* don't gettext() this -- incoming text: */
		if (!strcmp(entry, "can not access directory .")) {
		    /*
		     *	Don't reset *first, nothing real will follow. - KW
		     */
		    entry_info->display = FALSE;
		    return(entry_info);
		}
		*first = FALSE;
		if (!strncmp(entry, "total ", 6) ||
		    strstr(entry, "not available") != NULL) {
		    entry_info->display = FALSE;
		    return(entry_info);
		} else if (unsure_type) {
		    /* this isn't really a unix server! */
		    server_type = GENERIC_SERVER;
		    entry_info->display = FALSE;
		    return(entry_info);
		}
a2255 1

d2257 20
a2276 16
	    **	Check first character of ls -l output.
	    */
	    if (TOUPPER(entry[0]) == 'D')  {
		/*
		**  It's a directory.
		*/
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
		remove_size=TRUE; /* size is not useful */
	    } else if (entry[0] == 'l') {
		/*
		**  It's a symbolic link, does the user care about
		**  knowing if it is symbolic?	I think so since
		**  it might be a directory.
		*/
		StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
		remove_size=TRUE; /* size is not useful */
d2278 7
d2286 13
a2298 18
		**  Strip off " -> pathname".
		*/
		for (i = len - 1; (i > 3) &&
				  (!isspace(UCH(entry[i])) ||
				   (entry[i-1] != '>')	||
				   (entry[i-2] != '-') ||
				   (entry[i-3] != ' ')); i--)
		    ; /* null body */
		if (i > 3) {
		    entry[i-3] = '\0';
		    len = i - 3;
		}
	    } /* link */

	    parse_ls_line(entry, entry_info);

	    if (!strcmp(entry_info->filename,"..") ||
		!strcmp(entry_info->filename,"."))
d2300 3
a2302 4
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2304 4
a2307 1
	case VMS_SERVER:
d2309 5
a2313 5
	    **	Interpret and edit LIST output from VMS server
	    **	and convert information lines to zero length.
	    */
	    parse_vms_dir_entry(entry, entry_info);

d2315 5
a2319 4
	    **	Get rid of any junk lines.
	    */
	    if (!entry_info->display)
		return(entry_info);
d2322 23
a2344 12
	    **	Trim off VMS directory extensions.
	    */
	    len = strlen(entry_info->filename);
	    if ((len > 4) && !strcmp(&entry_info->filename[len-4], ".dir")) {
		entry_info->filename[len-4] = '\0';
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
		remove_size=TRUE; /* size is not useful */
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2346 6
a2351 6
	case MS_WINDOWS_SERVER:
	    /*
	    **	Interpret and edit LIST output from MS_WINDOWS server
	    **	and convert information lines to zero length.
	    */
	    parse_ms_windows_dir_entry(entry, entry_info);
d2353 40
a2392 13
	    /*
	    **	Get rid of any junk lines.
	    */
	    if (!entry_info->display)
		return(entry_info);
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return(entry_info);
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2395 6
a2400 6
	case WINDOWS_NT_SERVER:
	    /*
	    **	Interpret and edit LIST output from MS_WINDOWS server
	    **	and convert information lines to zero length.
	    */
	    parse_windows_nt_dir_entry(entry, entry_info);
d2402 13
a2414 13
	    /*
	    **	Get rid of any junk lines.
	    */
	    if (!entry_info->display)
		return(entry_info);
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return(entry_info);
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2417 2
a2418 2
	case CMS_SERVER:
	  {
d2420 3
a2422 3
	    **	Interpret and edit LIST output from VM/CMS server
	    **	and convert any information lines to zero length.
	    */
d2426 2
a2427 2
	    **	Get rid of any junk lines.
	    */
d2429 1
a2429 1
		return(entry_info);
d2432 1
a2432 1
		return(entry_info);
d2435 2
a2436 2
	    **	Goto the bottom and get real type.
	    */
d2438 1
a2438 1
	  }
d2440 8
a2447 2
	case NCSA_SERVER:
	case TCPC_SERVER:
d2449 10
a2458 16
	    **	Directories identified by trailing "/" characters.
	    */
	    StrAllocCopy(entry_info->filename, entry);
	    len = strlen(entry);
	    if (entry[len-1] == '/') {
		/*
		**  It's a dir, remove / and mark it as such.
		*/
		entry[len-1] = '\0';
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
		remove_size=TRUE; /* size is not useful */
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2460 7
a2466 7
	default:
	    /*
	    **	We can't tell if it is a directory since we only
	    **	did an NLST :(	List bad file types anyways?  NOT!
	    */
	    StrAllocCopy(entry_info->filename, entry);
	    return(entry_info); /* mostly empty info */
d2468 1
a2468 1
    } /* switch (server_type) */
d2475 1
a2475 1
	if (((cp=strrchr(entry_info->filename, '.')) != NULL &&
d2479 4
a2482 4
	    **	Don't treat this as application/x-Troff-me
	    **	if it's a Unix server but has the string
	    **	"read.me", or if it's not a Unix server. - FM
	    */
d2492 2
a2493 2
    **	Get real types eventually.
    */
d2495 1
a2495 1
	CONST char *cp2;
d2497 2
a2498 1
	HTAtom * encoding;  /* @@@@ not used at all */
d2502 1
a2502 1
	    if (!strncmp(HTAtom_name(format), "application",11)) {
d2504 1
a2504 1
		if (!strncmp(cp2,"x-",2))
d2514 2
a2515 2
    return(entry_info);
} /* parse_dir_entry */
d2517 1
a2517 3
PRIVATE int compare_EntryInfo_structs ARGS2(
	EntryInfo *,	entry1,
	EntryInfo *,	entry2)
d2522 18
a2539 10
    switch(HTfileSortMethod) {
	case FILE_BY_SIZE:
	    /* both equal or both 0 */
	    if (entry1->size == entry2->size)
		return(strcmp(entry1->filename, entry2->filename));
	    else
		if (entry1->size > entry2->size)
		    return(1);
		else
		    return(-1);
d2541 14
a2554 6
	case FILE_BY_TYPE:
	    if (entry1->type && entry2->type) {
		status = strcasecomp(entry1->type, entry2->type);
		if (status)
		    return(status);
		/* else fall to filename comparison */
d2556 9
a2564 9
	    return (strcmp(entry1->filename, entry2->filename));

	case FILE_BY_DATE:
	    if (entry1->date && entry2->date) {
		/*
		** Make sure we have the correct length. - FM
		*/
		if (strlen(entry1->date) != 12 || strlen(entry2->date) != 12) {
		    return(strcmp(entry1->filename, entry2->filename));
d2566 9
a2574 6
		/*
		** Set the years and date,
		** if we don't have them yet.
		*/
		if (!HaveYears) {
		    set_years_and_date();
d2576 16
a2591 13
		/*
		** Set up for sorting in reverse
		** chronological order. - FM
		*/
		if (entry1->date[9] == ':') {
		    strcpy(date1, "9999");
		    strcpy(time1, &entry1->date[7]);
		    if (time1[0] == ' ') {
			 time1[0] = '0';
		    }
		} else {
		    strcpy(date1, &entry1->date[8]);
		    strcpy(time1, "00:00");
d2593 7
a2599 6
		strncpy(month, entry1->date, 3);
		month[3] = '\0';
		for (i = 0; i < 12; i++) {
		    if (!strcasecomp(month, months[i])) {
			break;
		    }
d2601 9
a2609 16
		i++;
		sprintf(month, "%02d", i);
		strcat(date1, month);
		strncat(date1, &entry1->date[4], 2);
		date1[8] = '\0';
		if (date1[6] == ' ' || date1[6] == HT_NON_BREAK_SPACE) {
		    date1[6] = '0';
		}
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
		    for (i = 0; i < 4; i++) {
			date1[i] = LastYear[i];
		    }
d2611 16
a2626 10
		strcat(date1, time1);
		if (entry2->date[9] == ':') {
		    strcpy(date2, "9999");
		    strcpy(time2, &entry2->date[7]);
		    if (time2[0] == ' ') {
			time2[0] = '0';
		    }
		} else {
		    strcpy(date2, &entry2->date[8]);
		    strcpy(time2, "00:00");
a2627 32
		strncpy(month, entry2->date, 3);
		month[3] = '\0';
		for (i = 0; i < 12; i++) {
		    if (!strcasecomp(month, months[i])) {
			break;
		    }
		}
		i++;
		sprintf(month, "%02d", i);
		strcat(date2, month);
		strncat(date2, &entry2->date[4], 2);
		date2[8] = '\0';
		if (date2[6] == ' ' || date2[6] == HT_NON_BREAK_SPACE) {
		    date2[6] = '0';
		}
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
		    for (i = 0; i < 4; i++) {
			date2[i] = LastYear[i];
		    }
		}
		strcat(date2, time2);
		/*
		** Do the comparison. - FM
		*/
		status = strcasecomp(date2, date1);
		if (status)
		    return(status);
		/* else fall to filename comparison */
d2629 10
a2638 1
	    return (strcmp(entry1->filename, entry2->filename));
d2640 3
a2642 3
	case FILE_BY_NAME:
	default:
	    return (strcmp(entry1->filename, entry2->filename));
a2645 1

d2647 13
a2659 14
**	--------------------------------------------------------------
**
** On entry,
**	anchor		Parent anchor to link the this node to
**	address		Address of the directory
** On exit,
**	returns		HT_LOADED if OK
**			<0 if error.
*/
PRIVATE int read_directory ARGS4(
	HTParentAnchor *,	parent,
	CONST char *,		address,
	HTFormat,		format_out,
	HTStream *,		sink)
d2663 1
a2663 1
    HTStructured* target = HTML_new(parent, format_out, sink);
d2669 1
a2669 1
    char *lastpath = NULL;/* prefix for link, either "" (for root) or xxx  */
d2675 1
a2675 1
    _HTProgress (gettext("Receiving FTP directory."));
d2678 3
a2680 4
     *  Force the current Date and Year (TheDate, ThisYear, and LastYear)
     *  to be recalculated for each directory request.  Otherwise we have
     *  a problem with long-running sessions assuming the wrong date for
     *  today. - kw
d2684 3
a2686 3
    **	Check whether we always want the home
    **	directory treated as Welcome. - FM
    */
d2691 4
a2694 6
    **	This should always come back FALSE, since the
    **	flag is set only for local directory listings
    **	if LONG_LIST was defined on compilation, but
    **	we could someday set up an equivalent listing
    **	for Unix ftp servers. - FM
    */
d2699 4
a2702 4
    if (*filename == '\0') {		  /* Empty filename: use root. */
	StrAllocCopy (lastpath, "/");
    } else if (!strcmp(filename,"/")) {   /* Root path. */
	StrAllocCopy (lastpath, "/foo/..");
d2704 1
a2704 1
	char * p = strrchr(filename, '/');	     /* Find the lastslash. */
d2708 1
a2708 1
	    StrAllocCopy(lastpath, filename); /* Use absolute path for CMS. */
d2710 1
a2710 1
	    StrAllocCopy(lastpath, p+1);   /* Take slash off the beginning. */
d2712 5
a2716 5
	if ((cp = strrchr(lastpath, ';')) != NULL) {   /* Trim type= param. */
	    if (!strncasecomp((cp+1), "type=", 5)) {
		if (TOUPPER(*(cp+6)) == 'D' ||
		    TOUPPER(*(cp+6)) == 'A' ||
		    TOUPPER(*(cp+6)) == 'I')
d2721 1
a2721 1
    FREE (filename);
d2724 1
a2724 1
	HTBTree * bt = HTBTree_new((HTComparer)compare_EntryInfo_structs);
d2726 1
a2726 1
	HTChunk * chunk = HTChunkCreate(128);
d2731 2
a2732 1
	PUTC('\n');  /* prettier LJM */
d2738 2
a2739 2
		       "read_directory: interrupted after %d bytes\n",
		       BytesReceived));
d2751 1
a2751 1
	    /*	 read directory entry
d2754 1
a2754 1
	    for (;;) {			/* Read in one line as filename */
d2756 1
a2756 1
AgainForMultiNet:
d2759 2
a2760 2
			   "read_directory: interrupted_in_next_data_char after %d bytes\n",
			   BytesReceived));
d2763 1
a2763 1
			goto unload_btree;  /* unload btree */
d2770 2
a2771 2
		} else if ((char)ic == CR || (char)ic == LF) {    /* Terminator? */
		    if (chunk->size != 0) {  /* got some text */
d2774 1
a2774 1
			/* Deal with MultiNet's wrapping of long lines - F.M. */
d2776 1
a2776 1
				*(data_read_pointer+1) == ' ')
d2795 1
a2795 2
			    }
			    else
d2797 1
a2797 2
			}
			else
d2801 1
a2801 1
		    break;		/* End of file */
d2803 1
a2803 1
		    HTChunkPutc(chunk, (char)ic);
d2811 2
a2812 2
		sprintf(NumBytes,gettext("Transferred %d bytes (%5d)"),
				BytesReceived, ws_read_per_sec);
d2821 1
a2821 1
	    /* 1 means empty: includes terminating 0 */
d2824 1
a2824 1
			lastpath, chunk->data));
d2830 1
a2830 1
			    entry_info->filename));
d2837 1
a2837 1
	}  /* next entry */
d2839 1
a2839 1
unload_btree:
d2844 1
a2844 1
	/* print out the handy help message if it exits :) */
d2860 1
a2860 1
	/* PUTS("    Date	 Type		  Size	   Filename\n");
d2866 1
a2866 1
#ifdef SH_EX	/* 1997/10/18 (Sat) 14:14:28 */
d2868 1
a2868 1
	    int  name_len, dot_len;
d2871 1
a2871 1
#define	FILE_GAP	2
d2874 1
a2874 1
	    HTBTElement * ele;
d2876 1
d2880 1
a2880 1
		entry_info = (EntryInfo *)HTBTree_object(ele);
d2898 1
a2898 1
#ifdef SH_EX	/* 1997/10/18 (Sat) 16:00 */
d2901 1
a2901 1
		sprintf(name_buff, "%-30s", entry_info->filename);
d2907 1
a2907 1
			while (dot_len--)
d2921 1
a2921 1
#ifdef SH_EX	/* 1998/02/02 (Mon) 16:34:52 */
d2924 1
a2924 1
					       entry_info->size);
d2927 1
a2927 1
						entry_info->size/1024);
d2930 2
a2931 2
			sprintf(string_buffer, "  %d bytes",
					       entry_info->size);
d2933 2
a2934 2
			sprintf(string_buffer, "  %dKb",
						entry_info->size/1024);
d2937 3
d2942 1
a2942 1
		PUTC('\n'); /* end of this entry */
d2954 1
a2954 1
    if (WasInterrupted || data_soc != -1) { /* should always be true */
d2956 4
a2959 5
	 *  Without closing the data socket first,
	 *  the response(0) later may hang.
	 *  Some servers expect the client to fin/ack the close
	 *  of the data connection before proceeding with the
	 *  conversation on the control connection. - kw
d2974 5
a2978 14
/*	Retrieve File from Server
**	-------------------------
**
** On entry,
**	name		WWW address of a file: document, including hostname
** On exit,
**	returns		Socket number for file if good.
**			<0 if bad.
*/
PUBLIC int HTFTPLoad ARGS4(
	CONST char *,		name,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
a2979 3
    BOOL isDirectory = NO;
    HTAtom * encoding = NULL;
    int status, final_status;
d2981 1
a2981 4
    int outstanding = 1;	/* outstanding control connection responses
				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
    HTFormat format;
d2983 1
a2983 1
    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n", name, ftp_local_passive ? "passive" : "normal"));
d2990 2
a2991 1
    HTReadProgress(0,0);
d2993 1
a2993 1
    for (retry = 0; retry < 2; retry++) { /* For timed out/broken connections */
d2995 3
a2997 2
	if (status < 0)
	    return status;
d3002 1
a3002 1
		NETCLOSE (control->socket);
d3006 1
a3006 1
		    (void)close_master_socket ();
d3008 1
a3008 1
		close_master_socket ();
d3012 1
a3012 1
		return status;
a3013 1

d3015 2
a3016 2
	    /*	Inform the server of the port number we will listen on
	    */
d3020 2
a3021 2
		_HTProgress (CONNECTION_INTERRUPTED);
		NETCLOSE (control->socket);
d3023 3
a3025 2
		close_master_socket ();
		return HT_INTERRUPTED;
d3027 1
a3027 1
	    if (status != 2) {		/* Could have timed out */
d3029 3
a3031 2
		    continue;		/* try again - net error*/
		return -status;		/* bad reply */
d3037 3
a3039 2
	    char *p;
	    int h0, h1, h2, h3, p0, p1;	/* Parts of reply */
d3041 1
a3041 1
	    char dst[LINE_LENGTH+1];
d3047 5
a3051 1
	    status = send_cmd_1(p = "EPSV");
d3056 1
a3056 1
		if (status < 0)	/* retry or Bad return */
d3058 3
a3060 2
		else if (status != 2) {
		    return -status;	/* bad reply */
d3065 3
a3067 2
		for (p = response_text; *p && *p != ','; p++)
		    ; /* null body */
d3069 5
a3073 4
		while (--p > response_text && '0' <= *p && *p <= '9')
		    ; /* null body */
		status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
		       &h0, &h1, &h2, &h3, &p0, &p1);
d3076 2
a3077 1
		    return -99;
d3079 1
a3079 1
		passive_port = (p0<<8) + p1;
d3082 1
a3082 1
		unsigned char c0, c1, c2, c3;
d3084 1
a3084 1
		int sslen;
d3089 7
a3095 4
		for (p = response_text; *p && !isspace(*p); p++)
		    ; /* null body */
		for (/*nothing*/; *p && *p && *p != '('; p++)	/*)*/
		    ; /* null body */
d3099 2
a3100 1
		    return -99;
d3105 2
a3106 2
		if (getpeername(control->socket, (struct sockaddr *)&ss,
		    &sslen) < 0) {
d3108 2
a3109 1
		    return -99;
d3111 2
a3112 2
		if (getnameinfo((struct sockaddr *)&ss, sslen, dst,
		    sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
d3114 2
a3115 1
		    return -99;
d3122 6
a3127 2
		    continue;		/* retry or Bad return */
		return -status;		/* bad reply */
a3128 2
	    for (p = response_text; *p && *p != ','; p++)
		; /* null body */
d3130 3
a3132 2
	    while (--p > response_text && '0' <= *p && *p <= '9')
		; /* null body */
d3134 1
a3134 1
	    status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
d3138 2
a3139 1
		return -99;
d3141 1
a3141 1
	    passive_port = (PortNumber)((p0<<8) + p1);
d3144 1
a3144 1
			 passive_port));
d3152 1
a3152 1
		    STR_FTP_URL, h0, h1, h2, h3, passive_port);
d3160 1
a3160 1
		return status;			/* Bad return */
d3166 35
a3200 1
	break;	/* No more retries */
d3202 3
a3204 1
    } /* for retries */
d3208 2
a3209 2
/*	Ask for the file:
*/
d3212 1
a3212 1
	char *fname = filename; /** Save for subsequent free() **/
d3215 2
a3216 1
	char *type = NULL;
d3220 1
a3220 1
	    /** If the unescaped path has a %2f, reject it as illegal. - FM **/
d3224 1
a3224 1
		init_help_message_cache();  /* to free memory */
d3227 2
a3228 1
		CTRACE((tfp, "HTFTP: Rejecting path due to illegal escaped slash.\n"));
d3236 1
a3236 1
	} else if ((type = strrchr(filename, ';')) != NULL) {
d3238 4
a3241 4
	    **	Check and trim the type= parameter. - FM
	    */
	    if (!strncasecomp((type+1), "type=", 5)) {
		switch(TOUPPER(*(type+6))) {
d3243 1
a3243 1
		    *type = '\0';
d3247 1
a3247 1
		    *type = '\0';
d3251 1
a3251 1
		    *type = '\0';
d3260 1
a3260 1
		    *(filename+1) = '\0';
d3271 3
a3273 3
	    ** Check if translation of HOME as tilde is supported,
	    ** and adjust filename if so. - FM
	    */
d3277 1
a3277 1
	    if ((cp2 = strchr((filename+1), '/')) != NULL) {
d3282 1
a3282 1
		status = send_cwd(filename+1);
d3284 1
a3284 1
		    StrAllocCopy(fn, (filename+1));
d3287 1
a3287 1
			if (fn[strlen(fn)-1] != '/') {
d3290 1
a3290 1
			    StrAllocCat(fn, (cp2+1));
d3304 2
a3305 1
	    if (((cp2=strrchr(filename, '.')) != NULL &&
d3309 4
a3312 4
		**  Don't treat this as application/x-Troff-me
		**  if it's a Unix server but has the string
		**  "read.me", or if it's not a Unix server. - FM
		*/
d3330 1
a3330 1
		  encoding != HTAtom_for("7bit"));
d3332 6
a3337 7
	    /*
	    **	Force binary if we're in source, download or dump
	    **	mode and this is not a VM/CMS server, so we don't
	    **	get CRLF instead of LF (or CR) for newlines in text
	    **	files.	Can't do this for VM/CMS or we'll get
	    **	raw EBCDIC.  - FM
	    */
d3345 2
a3346 2
	    **	Force binary if we had ;type=I - FM
	    */
d3350 2
a3351 2
	    **	Force ASCII if we had ;type=A - FM
	    */
d3356 4
a3359 3
	    **	Act on our setting if not already set. - FM
	    */
	    char * mode = binary ? "I" : "A";
d3362 1
a3362 1
		init_help_message_cache();  /* to free memory */
d3368 5
a3372 5
	/*
	**  Handle what for Lynx are special case servers, e.g.,
	**  for which we respect RFC 1738, or which have known
	**  conflicts in suffix mappings. - FM
	*/
d3374 56
a3429 35
	  {
	    char *cp1, *cp2;
	    BOOL included_device = FALSE;
	    BOOL found_tilde = FALSE;
	    /** Accept only Unix-style filename **/
	    if (strchr(filename, ':') != NULL ||
		strchr(filename, '[') != NULL) {
		FREE(fname);
		init_help_message_cache();  /* to free memory */
		NETCLOSE(control->socket);
		control->socket = -1;
		CTRACE((tfp, "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
		return -1;
	    }
	    /** Handle any unescaped "/%2F" path **/
	    if (!strncmp(filename, "//", 2)) {
		int i;
		included_device = TRUE;
		for (i = 0; filename[(i+1)]; i++)
		    filename[i] = filename[(i+1)];
		filename[i] = '\0';
		CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		cp = HTVMS_name("", filename);
		CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
		if ((cp1=strrchr(cp, ']')) != NULL) {
		    strcpy(filename, ++cp1);
		    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
		    *cp1 = '\0';
		    status = send_cwd(cp);
		    if (status != 2) {
			char *dotslash = 0;
			if ((cp1=strchr(cp, '[')) != NULL) {
			    *cp1++ = '\0';
			    status = send_cwd(cp);
			    if (status != 2) {
d3431 1
a3431 1
				init_help_message_cache(); /* to free memory */
d3436 34
a3469 3
			    HTSprintf0(&dotslash, "[.%s", cp1);
			    status = send_cwd(dotslash);
			    FREE(dotslash);
d3472 1
a3472 1
				init_help_message_cache(); /* to free memory */
a3476 6
			} else {
			    FREE(fname);
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
d3478 2
d3481 25
a3505 23
		} else if ((cp1=strchr(cp, ':')) != NULL &&
			   strchr(cp, '[') == NULL &&
			   strchr(cp, ']') == NULL) {
		    cp1++;
		    if (*cp1 != '\0') {
			strcpy(filename, cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			HTSprintf0(&vmsname, "%.*s[%s]", cp1-cp, cp, filename);
			status = send_cwd(vmsname);
			if (status != 2) {
			    HTSprintf(&vmsname, "%.*s[000000]", cp1-cp, cp);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				HTSprintf(&vmsname, "%.*s", cp1-cp, cp);
				status = send_cwd(vmsname);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
			    }
d3507 1
a3507 2
			    HTSprintf0(&vmsname, "000000");
			    filename = vmsname;
d3509 6
a3514 6
		    }
		} else if (0==strcmp(cp, (filename+1))) {
		    status = send_cwd(cp);
		    if (status != 2) {
			HTSprintf0(&vmsname, "%s:", cp);
			status = send_cwd(vmsname);
a3522 2
		    HTSprintf0(&vmsname, "000000");
		    filename = vmsname;
d3524 8
a3531 10
	    }
	    /** Trim trailing slash if filename is not the top directory **/
	    if (strlen(filename) > 1 && filename[strlen(filename)-1] == '/')
		filename[strlen(filename)-1] = '\0';

#ifdef MAINTAIN_CONNECTION /* Don't need this if always new connection - F.M. */
	    if (!included_device) {
		/** Get the current default VMS device:[directory] **/
		status = send_cmd_1("PWD");
		if (status != 2) {
d3533 9
a3541 4
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
d3543 10
a3552 3
		/** Go to the VMS account's top directory **/
		if ((cp=strchr(response_text, '[')) != NULL &&
		    (cp1=strrchr(response_text, ']')) != NULL) {
a3553 1
		    unsigned len = 4;
d3555 6
a3560 8
		    StrAllocCopy(tmp, cp);
		    if ((cp2=strchr(cp, '.')) != NULL && cp2 < cp1) {
			len += (cp2 - cp);
		    } else {
			len += (cp1 - cp);
		    }
		    tmp[len] = 0;
		    StrAllocCat(tmp, "]");
d3567 1
a3567 1
			init_help_message_cache();  /* to free memory */
d3572 5
d3578 1
d3580 28
a3607 42
#endif /* MAINTAIN_CONNECTION */

	    /** If we want the VMS account's top directory, list it now **/
	    if (!(strcmp(filename, "/~")) ||
		(included_device && 0==strcmp(filename, "000000")) ||
		(strlen(filename) == 1 && *filename == '/')) {
		isDirectory = YES;
		status = send_cmd_1("LIST");
		FREE(fname);
		if (status != 1) {
		    /* Action not started */
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
		}
		/** Big goto! **/
		goto listen;
	    }
	    /** Otherwise, go to appropriate directory and doctor filename **/
	    if (!strncmp(filename, "/~", 2)) {
		filename += 2;
		found_tilde = TRUE;
	    }
	    CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
	    if (!included_device &&
		(cp = strchr(filename, '/')) != NULL &&
		(cp1 = strrchr(cp, '/')) != NULL &&
		(cp1 - cp) > 1) {
		char *tmp = 0;

		HTSprintf0(&tmp, "[.%.*s]", cp1-cp-1, cp+1);

		CTRACE((tfp, "change path '%s'\n", tmp));
		while ((cp2 = strrchr(tmp, '/')) != NULL)
		    *cp2 = '.';
		CTRACE((tfp, "...to  path '%s'\n", tmp));

		status = send_cwd(tmp);
		FREE(tmp);

		if (status != 2) {
d3609 1
a3609 29
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
		}
		filename = cp1+1;
	    } else {
		if (!included_device && !found_tilde) {
		    filename += 1;
		}
	    }
	    break;
	  }
	case CMS_SERVER:
	  {
	    /*
	    **	If we want the CMS account's top directory, or a base
	    **	SFS or anonymous directory path (i.e., without a slash),
	    **	list it now. FM
	    */
	    if ((strlen(filename) == 1 && *filename == '/') ||
		((0 == strncasecomp((filename+1), "vmsysu:", 7)) &&
		 (cp = strchr((filename+1), '.')) != NULL &&
		 strchr(cp, '/') == NULL) ||
		(0 == strncasecomp(filename+1, "anonymou.", 9) &&
		 strchr(filename+1, '/') == NULL)) {
		if (filename[1] != '\0') {
		    status = send_cwd(filename+1);
		    if (status != 2) {
d3611 1
a3611 1
			init_help_message_cache();  /* to free memory */
d3616 2
d3619 1
a3619 17
		isDirectory = YES;
		if (use_list)
		    status = send_cmd_1("LIST");
		else
		    status = send_cmd_1("NLST");
		FREE(fname);
		if (status != 1) {
		    /* Action not started */
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
		}
		/** Big goto! **/
		goto listen;
	    }
	    filename++;
d3621 23
a3643 18
	    /** Otherwise, go to appropriate directory and adjust filename **/
	    while ((cp = strchr(filename, '/')) != NULL) {
		*cp++ = '\0';
		status = send_cwd(filename);
		if (status == 2) {
		    if (*cp == '\0') {
			isDirectory = YES;
			if (use_list)
			    status = send_cmd_1("LIST");
			else
			    status = send_cmd_1("NLST");
			FREE(fname);
			if (status != 1) {
			    /** Action not started **/
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
d3645 1
a3645 4
			/** Clear any messages from the login directory **/
			init_help_message_cache();
			/** Big goto! **/
			goto listen;
a3646 1
		    filename = cp;
d3648 1
a3649 2
	    break;
	  }
d3651 1
a3651 1
	    /** Shift for any unescaped "/%2F" path **/
d3657 3
a3659 3
	**  Act on a file or listing request, or try to figure out
	**  which we're dealing with if we don't know yet. - FM
	*/
d3662 17
d3683 1
a3683 1
	    /** Clear any login messages if this isn't the login directory **/
d3709 2
a3710 2
listen:
    if(!ftp_local_passive) {
d3714 1
d3718 2
a3719 1
	int	soc_addrlen=sizeof(soc_address);
d3723 2
a3724 2
			     (struct sockaddr *)&soc_address,
			     (void *)&soc_addrlen);
d3727 3
a3729 3
	status = accept(master_socket,
			(struct sockaddr *)&soc_address,
			(void *)&soc_addrlen);
d3736 3
a3738 3
    } /* !ftp_local_passive */

#if 0	/* no - this makes the data connection go away too soon (2.8.3dev.22) */
d3750 1
a3750 1
	final_status = read_directory (anchor, name, format_out, sink);
d3766 1
a3766 1
	if (data_soc != -1) { /* normally done in read_directory */
d3777 1
a3777 1
	/** Clear any login messages **/
d3780 1
a3780 1
	/** Fake a Content-Encoding for compressed files. - FM **/
d3784 2
a3785 3
	     *	We already know from the call to HTFileFormat above that
	     *	this is a compressed file, no need to look at the filename
	     *	again. - kw
d3792 2
a3793 2
	    char *dot;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &dot);
d3796 1
a3796 1
		*dot = '\0';
d3809 3
d3815 1
a3815 1
		default:
d3822 1
a3822 1
	_HTProgress (gettext("Receiving FTP file."));
d3829 1
a3829 1
#if 0	/* any known servers where ABOR would work this way? */
d3846 1
a3846 1
	    status = 2;	/* data_soc already closed in HTCopy - kw */
d3852 1
a3852 1
		status = response(0);		/* Pick up final reply */
d3854 2
a3855 2
		    data_soc = -1;		/* invalidate it */
		    init_help_message_cache();  /* to free memory */
d3871 1
a3871 1
    data_soc = -1;			/* invalidate it */
d3882 2
a3883 2
    init_help_message_cache();  /* to free memory */
      /* returns HT_LOADED (always for file if we get here) or error */
d3885 1
a3885 1
} /* open_file_read */
d3888 4
a3891 4
**  This function frees any user entered password, so that
**  it must be entered again for a future request. - FM
*/
PUBLIC void HTClearFTPPassword NOARGS
d3894 4
a3897 5
    **	Need code to check cached documents from
    **	non-anonymous ftp accounts and do something
    **	to ensure that they no longer can be accessed
    **	without a new retrieval. - FM
    */
d3900 2
a3901 3
    **	Now free the current user entered password,
    **	if any. - FM
    */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 20
d2949 1
a2949 1
    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n", name, ftp_passive ? "passive" : "normal"));
d2963 1
a2963 1
	if (!ftp_passive) {
d3594 1
a3594 1
    if(!ftp_passive) {
d3618 1
a3618 1
    } /* !ftp_passive */
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a59 4
#ifdef DJGPP
#define u_long unsigned long
#endif

d65 3
a67 3

/* this define should be in HTFont.h :( */
#define HT_NON_BREAK_SPACE ((char)1)   /* For now */
a78 3
#define COMMAND_LENGTH 256

#define INFINITY 512
a80 1
#include <HTTCP.h>
a100 4
#ifndef NIL
#define NIL 0
#endif /* !NIL */

a124 5
#ifdef SOCKS
extern BOOLEAN socks_flag;
extern unsigned long socks_bind_remoteAddr;
#endif /* SOCKS */
extern char *personal_mail_address;
d136 18
a153 14
#define GENERIC_SERVER	   0
#define MACHTEN_SERVER	   1
#define UNIX_SERVER	   2
#define VMS_SERVER	   3
#define CMS_SERVER	   4
#define DCTS_SERVER	   5
#define TCPC_SERVER	   6
#define PETER_LEWIS_SERVER 7
#define NCSA_SERVER	   8
#define WINDOWS_NT_SERVER  9
#define MS_WINDOWS_SERVER 10
#define MSDOS_SERVER	  11
#define APPLESHARE_SERVER 12
#define NETPRESENZ_SERVER 13
d155 1
a155 1
PRIVATE int	server_type = GENERIC_SERVER;	/* the type of ftp host */
d162 1
a162 1
PRIVATE unsigned short	port_number = FIRST_TCP_PORT;
d169 1
a169 1
PRIVATE unsigned short	passive_port;	/* Port server specified for data */
d199 1
a199 1
/* PUBLIC						HTMake_VMS_name()
d210 1
a210 1
PUBLIC char * HTMake_VMS_name ARGS2(
d222 1
a222 1
    static char vmsname[INFINITY];	/* returned */
d255 1
a255 1
	sprintf(vmsname, "%s%s", nodename, filename + 1);
d258 1
a258 1
	sprintf(vmsname, "%s%s:%s", nodename, filename+1, second+1);
d264 1
a264 1
	sprintf(vmsname, "%s%s:[%s]%s",
d297 1
a297 1
    return (unsigned char)(*data_read_pointer++);
d309 4
a312 3
    int status = NETCLOSE(con->socket);
    if (TRACE) {
	CTRACE(tfp, "HTFTP: Closing control socket %d\n", con->socket);
d314 4
a317 2
	if (status != 0)
	    perror("HTFTP:close_connection");
d351 1
a351 1
    CTRACE(tfp,"Adding message to help cache: %s\n",string);
d358 1
d364 2
a365 2
/*	Execute Command and get Response
**	--------------------------------
d367 2
a368 7
**	See the state machine illustrated in RFC959, p57. This implements
**	one command/reply sequence.  It also interprets lines which are to
**	be continued, which are marked with a "-" immediately after the
**	status code.
**
**	Continuation then goes on until a line with a matching reply code
**	an a space after it.
d371 2
a372 2
**	con	points to the connection which is established.
**	cmd	points to a command, or is NIL to just get the response.
d374 1
a374 1
**	The command is terminated with the CRLF pair.
d377 3
a379 2
**	returns:  The first digit of the reply type,
**		  or negative for communication failure.
d381 1
a381 1
PRIVATE int response ARGS1(
a383 2
    int result;				/* Three-digit decimal code */
    int continuation_response = -1;
d387 1
a387 1
	CTRACE(tfp, "HTFTP: No control connection set up!!\n");
d392 1
a392 1
	CTRACE(tfp, "  Tx: %s", cmd);
d403 2
a404 2
	    CTRACE(tfp, "HTFTP: Error %d sending command: closing socket %d\n",
			status, control->socket);
d409 33
d447 1
a447 1
	    if (((*p++ = ich) == LF)
d453 1
a453 1
		    CTRACE (tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
d460 1
a460 1
		CTRACE(tfp, "    Rx: %s", response_text);
d481 1
a481 1
		CTRACE (tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
d488 2
a489 2
		CTRACE(tfp, "Error on rx: closing socket %d\n",
			    control->socket);
d499 2
a500 2
	CTRACE(tfp, "HTFTP: They close so we close socket %d\n",
		    control->socket);
d542 1
a542 1
	int,		ServerType)
d561 1
a561 1
	int *,		ServerType,
d577 1
a577 1
	    CTRACE(tfp, "HTFTP: Treating as %s server.\n",
d579 1
a579 1
						 "NCSA" : "TCPC"));
d586 1
a586 1
		CTRACE(tfp, "HTFTP: Treating as NCSA server.\n");
d590 1
a590 1
		 CTRACE(tfp, "HTFTP: Treating as Unix server.\n");
d597 1
a597 1
	    CTRACE(tfp, "HTFTP: Treating as VMS server.\n");
d600 1
a600 1
	    CTRACE(tfp, "HTFTP: Treating as Generic server.\n");
d611 39
d700 1
a700 1
	con = (connection *)calloc(1, sizeof(connection));
d711 1
d768 1
a768 1
	    CTRACE (tfp, "HTFTP: Interrupted on connect\n");
d770 2
a771 2
	    CTRACE(tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
			arg);
d791 2
a792 2
    CTRACE(tfp, "FTP connected, socket %d  control %ld\n",
		con->socket, (long)con);
d805 1
a805 1
	CTRACE (tfp, "HTFTP: Interrupted at beginning of login.\n");
d834 1
a834 1
	    CTRACE (tfp, "HTFTP: Interrupted while sending username.\n");
d871 1
a871 1
		if ((cp=getenv("USER")) != NULL)
d891 1
a891 2
	    CTRACE (tfp,
		       "HTFTP: Interrupted while sending password.\n");
d903 1
a903 1
	    CTRACE (tfp, "HTFTP: Interrupted while sending password.\n");
d912 1
a912 1
	CTRACE(tfp, "HTFTP: Login fail: %s", response_text);
d916 1
a916 1
    CTRACE(tfp, "HTFTP: Logged in.\n");
d928 1
a928 1
	    CTRACE(tfp, "HTFTP: Treating as MachTen server.\n");
d933 1
d935 1
a935 1
	    CTRACE(tfp, "HTFTP: Treating as Unix server.\n");
d940 1
a940 1
	    CTRACE(tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n");
d943 1
a943 1
	    server_type = VMS_SERVER;
d945 9
a953 1
	    CTRACE(tfp, "HTFTP: Treating as VMS server.\n");
d959 1
a959 1
	    CTRACE(tfp, "HTFTP: Treating as CMS server.\n");
d963 1
a963 1
	    CTRACE(tfp, "HTFTP: Treating as DCTS server.\n");
d967 1
a967 1
	    CTRACE(tfp, "HTFTP: Looks like a TCPC server.\n");
d974 1
a974 1
	    CTRACE(tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n");
d980 1
a980 1
	    CTRACE(tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n");
d984 7
a990 2
	    use_list = TRUE;
	    CTRACE(tfp, "HTFTP: Treating as Window_NT server.\n");
d995 1
a995 1
	    CTRACE(tfp, "HTFTP: Treating as MS Windows server.\n");
d1002 1
a1002 1
	    CTRACE(tfp, "HTFTP: Treating as AppleShare server.\n");
d1006 1
a1006 1
	    CTRACE(tfp, "HTFTP: Ugh!  A Generic server.\n");
d1025 1
a1025 1
	CTRACE(tfp, "HTFTP: Port defined.\n");
d1044 1
a1044 1
    CTRACE(tfp, "HTFTP: Closed master socket %d\n", master_socket);
d1069 6
d1077 1
d1089 11
d1102 3
d1106 1
d1111 1
a1111 1
    CTRACE(tfp, "HTFTP: Opened master socket number %d\n", new_socket);
d1115 18
d1135 1
d1138 1
a1138 1
	unsigned short old_port_number = port_number;
d1146 3
d1150 1
d1156 1
a1156 1
			sizeof(soc_address)
d1160 1
a1160 1
						)) == 0)
d1162 1
a1162 1
	    else
d1167 2
a1168 1
		    sizeof(soc_address))) == 0)
d1170 3
a1172 2
	    CTRACE(tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		port_number, status, SOCKET_ERRNO);
d1190 8
a1197 2
	CTRACE(tfp, "HTFTP: This host is %s\n",
	    HTInetString(soc_in));
d1200 1
d1208 3
d1212 1
d1220 2
a1221 1
		    sizeof(soc_address));
d1239 2
a1240 1
    CTRACE(tfp, "HTFTP: bound to port %d on %s\n",
d1242 6
a1247 1
		HTInetString(soc_in));
d1252 1
a1252 1
#endif /* REPEAD_LISTEN */
d1259 5
a1263 1
    sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
d1272 20
d1293 4
a1296 4
/*	Inform TCP that we will accept connections
*/
  {
    int status;
d1298 3
a1300 3
    if (socks_flag)
	status = Rlisten(master_socket, 1);
    else
d1302 5
a1306 4
    status = listen(master_socket, 1);
    if (status < 0) {
	master_socket = -1;
	return HTInetStatus("listen");
d1308 1
a1308 2
  }
    CTRACE(tfp, "TCP: Master socket(), bind() and listen() all OK\n");
a1343 1
    strncpy(month, (char *)ctime(&NowTime)+4, 3);
d1351 1
a1351 2
    sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
    sprintf(date, "9999%.2s%.2s", month, day);
d1390 1
a1390 1
    if (!isalpha(*s++) || !isalpha(*s++) || !isalpha(*s++))
d1401 1
a1401 1
    if (!(*s == ' ' || isdigit(*s))) {
d1408 1
a1408 1
    if (!isdigit(*s++))
d1416 1
a1416 1
    if (!(*s == ' ' || isdigit(*s))) {
d1423 1
a1423 1
    if (!isdigit(*s++))
d1427 1
a1427 1
    if (!(*s == ':' || isdigit(*s))) {
d1434 1
a1434 1
    if (!isdigit(*s++))
d1438 1
a1438 1
    if (!(*s == ' ' || isdigit(*s))) {
d1497 1
d1516 1
a1516 1
    short  i, j;
d1521 1
a1521 1
	 (i > 13) && (!isspace(line[i]) || !is_ls_date(&line[i-12])); i--)
d1537 1
a1537 1
    while (isdigit(line[j])) {
d1547 105
d1724 2
a1725 2
	strlen(cpd) > 9 && isdigit(*(cpd-1)) &&
	isalpha(*(cpd+1)) && *(cpd+4) == '-') {
d1728 3
a1730 5
	*(cpd+4) = '\0';
	*(cpd+2) = TOLOWER(*(cpd+2));
	*(cpd+3) = TOLOWER(*(cpd+3));
	sprintf(date, "%s ", cpd+1);
	*(cpd+4) = '-';
d1733 2
a1734 3
	*cpd = '\0';
	if (isdigit(*(cpd-2)))
	    sprintf(date+4, "%s ", cpd-2);
d1736 1
a1736 2
	    sprintf(date+4, "%c%s ", HT_NON_BREAK_SPACE, cpd-1);
	*cpd = '-';
d1741 1
a1741 3
	    *(cpd+15) = '\0';
	    sprintf(date+7, "%s", cpd+10);
	    *(cpd+15) = ' ';
d1743 1
a1743 3
	    *(cpd+9) = '\0';
	    sprintf(date+7, " %s", cpd+5);
	    *(cpd+9) = ' ';
d1753 1
a1753 1
	while (isdigit(*(cps-1)))
d1759 1
a1759 1
	while (isdigit(*cps))
d1772 1
a1772 1
	    while (isdigit(*cpd))
d1783 1
a1783 1
    CTRACE(tfp, "HTFTP: VMS filename: %s  date: %s  size: %d\n",
d1785 2
a1786 2
		entry_info->date ? entry_info->date : "",
		entry_info->size);
d1821 1
a1821 1
	if (isdigit(*cps)) {
d1844 1
a1844 1
		sprintf(date, "%s  %s", cpd, (cpd+7));
d1847 1
a1847 1
		sprintf(date, "%s %s", cpd, (cpd+12));
d1856 1
a1856 1
    CTRACE(tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %d\n",
d1858 2
a1859 2
		entry_info->date ? entry_info->date : "",
		entry_info->size);
d1925 1
a1925 1
	sprintf(date, "%s %s", months[i], (cp+3));
d1932 1
a1932 1
		sprintf(&date[6], "  20%s", cp);
d1934 1
a1934 1
		sprintf(&date[6], "  19%s", cp);
d1942 1
a1942 3
	    *(cpd+5) = '\0';
	    sprintf(&date[6], " %s%d:%s",
				     (i < 10 ? "0" : ""), i, (cpd+3));
d1965 1
a1965 1
    CTRACE(tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
d1967 2
a1968 2
		entry_info->date ? entry_info->date : "",
		entry_info->size);
d2039 1
a2039 1
	if (isdigit(*cp)) {
d2050 1
a2050 1
	if (isdigit(*cp)) {
d2069 1
a2069 1
	 isdigit(*(cps+1)) && isdigit(*(cps+2)) && *(cps+3) == ':')) {
d2081 1
a2081 1
	    sprintf(date, "%s %s", months[i], (cpd+3));
d2088 1
a2088 1
		    sprintf(&date[6], "  20%s", cpd);
d2090 1
a2090 1
		    sprintf(&date[6], "  19%s", cpd);
d2096 1
a2096 2
		sprintf(&date[6], " %s%d:%s",
				     (i < 10 ? "0" : ""), i, (cps+3));
d2106 1
a2106 1
    CTRACE(tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %d\n",
d2108 2
a2109 2
		entry_info->date ? entry_info->date : "",
		entry_info->size);
d2121 1
a2121 1
PRIVATE EntryInfo * parse_dir_entry ARGS2(
d2123 2
a2124 1
	BOOLEAN *,	first)
d2142 45
d2192 1
d2251 1
a2251 1
				  (!isspace(entry[i]) ||
d2506 1
a2506 1
		sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d2513 5
a2517 1
		if (date1[0] == '9' && atoi(date1) > TheDate) {
d2523 5
a2527 9
		    if (entry2->date[9] == ':') {
			strcpy(date2, "9999");
			strcpy(time2, &entry2->date[7]);
			if (time2[0] == ' ') {
			    time2[0] = '0';
			}
		    } else {
			strcpy(date2, &entry2->date[8]);
			strcpy(time2, "00:00");
d2529 4
d2541 1
a2541 1
		sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d2548 5
a2552 1
		if (date2[0] == '9' && atoi(date2) > TheDate) {
d2608 7
d2628 1
a2628 1
    need_parent_link = HTDirTitles(target, (HTAnchor*)parent, tildeIsTop);
a2655 1

d2663 1
d2669 3
d2678 1
d2685 1
d2690 3
d2699 1
d2744 4
d2749 1
d2757 2
a2758 2
	    CTRACE(tfp, "HTFTP: Line in %s is %s\n",
			lastpath, chunk->data);
d2760 1
a2760 1
	    entry_info = parse_dir_entry(chunk->data, &first);
d2762 4
a2765 3
		CTRACE(tfp, "Adding file to BTree: %s\n",
			    entry_info->filename);
		HTBTree_add(bt, (EntryInfo *)entry_info);
d2776 1
d2800 8
d2823 1
a2823 1
		    for (i = 0; entry_info->type[i] != '\0' && i < 15; i++)
d2831 18
d2850 1
d2854 8
d2868 1
d2884 1
a2884 2
    if (server_type == APPLESHARE_SERVER ||
	server_type == NETPRESENZ_SERVER) {
d2887 4
a2890 1
	 *  the response(NIL) below hangs. - KW
d2892 5
a2896 1
	NETCLOSE(data_soc);
a2899 2
	if (server_type != CMS_SERVER)
	    response(NIL);
a2900 1
	return HT_LOADED;
a2901 2
    if (server_type != CMS_SERVER)
	response(NIL);
a2902 3
#ifdef NOTDEFINED
    return response(NIL) == 2 ? HT_LOADED : -1;
#endif /* NOTDEFINED */
d2922 1
a2922 1
    int status;
d2924 3
d2929 1
d2936 1
d2943 1
a2943 1
	if (!ftp_local_passive) {
d2948 4
d2953 1
d2960 1
a2960 1
	    /* Inform the server of the port number we will listen on
d2964 1
a2964 1
		CTRACE (tfp, "HTFTP: Interrupted in response (port_command)\n");
d2976 1
a2976 1
	    CTRACE(tfp, "HTFTP: Port defined.\n");
d2979 1
a2979 1
	    char command[LINE_LENGTH+1];
d2981 4
a2984 1
	    int reply, h0, h1, h2, h3, p0, p1;	/* Parts of reply */
d2988 59
d3059 21
a3079 16
	   status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
		   &h0, &h1, &h2, &h3, &p0, &p1);
	   if (status < 4) {
	       fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
	       return -99;
	   }
	   passive_port = (p0<<8) + p1;
	   CTRACE(tfp, "HTFTP: Server is listening on port %d\n",
			passive_port);


/*	Open connection for data:
*/
	    sprintf(command,
		    "ftp://%d.%d.%d.%d:%d/",h0,h1,h2,h3,passive_port);
	    status = HTDoConnect(name, "FTP", passive_port, &data_soc);
d3087 1
a3087 1
	    CTRACE(tfp, "FTP data connected, socket %d\n", data_soc);
d3101 1
d3114 1
a3114 1
		CTRACE(tfp, "HTFTP: Rejecting path due to illegal escaped slash.\n");
d3150 1
a3150 1
		CTRACE(tfp, "HTFTP: type=%s\n", type);
d3154 1
a3154 1
	CTRACE(tfp, "HTFTP: UnEscaped %s\n", filename);
d3214 1
a3214 1
	binary = (encoding != HTAtom_for("8bit") &&
d3262 1
d3270 1
a3270 1
		CTRACE(tfp, "HTFTP: Rejecting path due to non-Unix-style syntax.\n");
d3280 3
a3282 3
		CTRACE(tfp, "HTFTP: Trimmed '%s'\n", filename);
		cp = HTMake_VMS_name("", filename);
		CTRACE(tfp, "HTFTP: VMSized '%s'\n", cp);
d3284 2
a3285 5
		    cp1++;
		    for (i = 0; cp1[i]; i++)
			filename[i] = cp1[i];
		    filename[i] = '\0';
		    CTRACE(tfp, "HTFTP: Filename '%s'\n", filename);
d3323 4
a3326 9
			for (i = 0; cp1[i]; i++)
			    filename[i] = cp1[i];
			filename[i] = '\0';
			CTRACE(tfp, "HTFTP: Filename '%s'\n", filename);
			*cp1 = '\0';
			strcat(cp, "[");
			strcat(cp, filename);
			strcat(cp, "]");
			status = send_cwd(cp);
d3328 2
a3329 3
			    *cp1 = '\0';
			    strcat(cp, "[000000]");
			    status = send_cwd(cp);
d3331 2
a3332 2
				*cp1 = '\0';
				status = send_cwd(cp);
d3342 2
a3343 2
			    strcpy(cp, "000000");
			    filename = cp;
d3349 2
a3350 2
			strcat(cp, ":");
			status = send_cwd(cp);
d3359 2
a3360 2
		    strcpy(cp, "000000");
		    filename = cp;
d3425 1
a3425 1
	    if (!strncmp(filename, "/~", 2))
d3427 3
a3429 1
	    CTRACE(tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename);
d3438 1
a3438 1
		CTRACE(tfp, "change path '%s'\n", tmp);
d3441 1
a3441 1
		CTRACE(tfp, "...to  path '%s'\n", tmp);
d3455 1
a3455 1
		if (!included_device) {
d3561 1
d3574 1
a3574 1
    if (!ftp_local_passive) {
d3576 3
d3580 1
d3596 1
a3596 1
	CTRACE(tfp, "TCP: Accepted new socket %d\n", status);
d3598 6
a3603 1
    } /* !ftp_local_passive */
d3606 29
a3634 7
	status = read_directory (anchor, name, format_out, sink);
	NETCLOSE(data_soc);
	NETCLOSE(control->socket);
	control->socket = -1;
	init_help_message_cache();  /* to free memory */
	return status;
      /* returns HT_LOADED or error */
a3636 1
	int len;
d3654 3
a3656 5
	} else if ((len = strlen(FileName)) > 2) {
	    if ((FileName[len - 1] == 'Z') &&
		(FileName[len - 2] == '.' ||
		 FileName[len - 2] == '-' ||
		 FileName[len - 2] == '_')) {
d3658 2
a3659 1
		FileName[len - 2] = '\0';
a3662 1
		StrAllocCopy(anchor->content_encoding, "x-compress");
d3664 6
a3669 9
	    } else if ((len > 3) &&
		       !strcasecomp((char *)&FileName[len - 2], "gz")) {
		if (FileName[len - 3] == '.' ||
		    FileName[len - 3] == '-' ||
		    FileName[len - 3] == '_') {
		    FileName[len - 3] = '\0';
		    format = HTFileFormat(FileName, &encoding, NULL);
		    format = HTCharsetFormat(format, anchor, -1);
		    StrAllocCopy(anchor->content_type, format->name);
d3671 6
a3676 1
		    format = HTAtom_for("www/compressed");
a3684 3
	if (rv == HT_INTERRUPTED)
	     _HTProgress(TRANSFER_INTERRUPTED);

d3688 20
a3707 2
	status = NETCLOSE(data_soc);
	CTRACE(tfp, "HTFTP: Closing data socket %d\n", data_soc);
a3709 1
	    data_soc = -1;			/* invalidate it */
d3711 19
a3729 12
	    data_soc = -1;			/* invalidate it */
	    status = response(NIL);		/* Pick up final reply */
	    if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		init_help_message_cache();  /* to free memory */
		return HTLoadError(sink, 500, response_text);
	    }
	}

	NETCLOSE(control->socket);
	control->socket = -1;
	init_help_message_cache();  /* to free memory */
	return HT_LOADED;
d3731 14
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 46
a47 46
 *			for a WorldWideWeb browser
 *			===================================
 *
 *	A cache of control connections is kept.
 *
 * Note: Port allocation
 *
 *	It is essential that the port is allocated by the system, rather
 *	than chosen in rotation by us (POLL_PORTS), or the following
 *	problem occurs.
 *
 *	It seems that an attempt by the server to connect to a port which has
 *	been used recently by a listen on the same socket, or by another
 *	socket this or another process causes a hangup of (almost exactly)
 *	one minute.  Therefore, we have to use a rotating port number.
 *	The problem remains that if the application is run twice in quick
 *	succession, it will hang for what remains of a minute.
 *
 * Authors
 *	TBL	Tim Berners-lee <timbl@@info.cern.ch>
 *	DD	Denis DeLaRoca 310 825-4580 <CSP1DWD@@mvs.oac.ucla.edu>
 *	LM	Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
 *	FM	Foteos Macrides <macrides@@sci.wfeb.edu>
 * History:
 *	 2 May 91	Written TBL, as a part of the WorldWideWeb project.
 *	15 Jan 92	Bug fix: close() was used for NETCLOSE for control soc
 *	10 Feb 92	Retry if cached connection times out or breaks
 *	 8 Dec 92	Bug fix 921208 TBL after DD
 *	17 Dec 92	Anon FTP password now just WWWuser@@ suggested by DD
 *			fails on princeton.edu!
 *	27 Dec 93 (FM)	Fixed up so FTP now works with VMS hosts.  Path
 *			must be Unix-style and cannot include the device
 *			or top directory.
 *	?? ??? ?? (LM)	Added code to prompt and send passwords for non
 *			anonymous FTP
 *	25 Mar 94 (LM)	Added code to recognize different ftp server types
 *			and code to parse dates and sizes on most hosts.
 *	27 Mar 93 (FM)	Added code for getting dates and sizes on VMS hosts.
 *
 * Notes:
 *			Portions Copyright 1994 Trustees of Dartmouth College
 *			Code for recognizing different FTP servers and
 *			parsing "ls -l" output taken from Macintosh Fetch
 *			program with permission from Jim Matthews,
 *			Dartmouth Software Development Team.
 */
d50 13
a62 9
 * BUGS:	@@@@@@	Limit connection cache size!
 * 		Error reporting to user.
 * 		400 & 500 errors are ack'ed by user with windows.
 * 		Use configuration file for user names
 * 
 *		Note for portability this version does not use select() and
 *		so does not watch the control and data channels at the
 *		same time.
 */
d68 4
a71 4
#include <HTFTP.h>		/* Implemented here */
#include <HTTCP.h>
#include <HTTP.h>
#include <HTFont.h>
d73 2
a74 2
#define REPEAT_PORT		/* Give the port number for each file */
#define REPEAT_LISTEN		/* Close each listen socket and open a new one */
d77 1
a77 1
#define LISTEN_BACKLOG 2	/* Number of pending connect requests (TCP) */
d83 3
d88 1
d90 1
a90 1
#include <HTFile.h>		/* For HTFileFormat() */
d103 4
a106 4
    struct _connection *next;	/* Link on list         */
    unsigned long addr;		/* IP address           */
    int socket;			/* Socket number for communication */
    BOOL binary;		/* Binary mode? */
d109 4
d117 6
a122 50
/*
 * socklen_t is the standard, but there are many pre-standard variants.
 * This ifdef works around a few of those cases.
 *
 * Information was obtained from header files on these platforms:
 *	AIX 4.3.2, 5.1
 *	HPUX 10.20, 11.00, 11.11
 *	IRIX64 6.5
 *	Tru64 4.0G, 4.0D, 5.1
 */
#if defined(SYS_IRIX64)
	/* IRIX64 6.5 socket.h may use socklen_t if SGI_SOURCE is not defined */
#  if _NO_XOPEN4 && _NO_XOPEN5
#    define LY_SOCKLEN socklen_t
#  elif _ABIAPI
#    define LY_SOCKLEN int
#  elif _XOPEN5
#    if (_MIPS_SIM != _ABIO32)
#      define LY_SOCKLEN socklen_t
#    else
#      define LY_SOCKLEN int
#    endif
#  else
#    define LY_SOCKLEN size_t
#  endif
#elif defined(SYS_HPUX)
#  if defined(_XOPEN_SOURCE_EXTENDED) && defined(SO_PROTOTYPE)
#    define LY_SOCKLEN socklen_t
#  else	/* HPUX 10.20, etc. */
#    define LY_SOCKLEN int
#  endif
#elif defined(SYS_TRU64)
#  if defined(_POSIX_PII_SOCKET)
#    define LY_SOCKLEN socklen_t
#  elif defined(_XOPEN_SOURCE_EXTENDED)
#    define LY_SOCKLEN size_t
#  else
#    define LY_SOCKLEN int
#  endif
#else
#  define LY_SOCKLEN socklen_t
#endif

#define PUTC(c)      (*targetClass.put_character) (target, c)
#define PUTS(s)      (*targetClass.put_string)    (target, s)
#define START(e)     (*targetClass.start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*targetClass.end_element)   (target, e, 0)
#define FREE_TARGET  (*targetClass._free)         (target)
#define ABORT_TARGET (*targetClass._free)         (target)

d124 2
a125 2
    const HTStructuredClass *isa;
    /* ... */
d129 13
a141 9
 *	---------------------
 */
int HTfileSortMethod = FILE_BY_NAME;

#ifndef DISABLE_FTP		/*This disables everything to end-of-file */
static char ThisYear[8];
static char LastYear[8];
static int TheDate;
static BOOLEAN HaveYears = FALSE;
d144 27
a170 48
 *	---------------------
 */
static connection *connections = NULL;	/* Linked list of connections */
static char response_text[LINE_LENGTH + 1];	/* Last response from ftp host */
static connection *control = NULL;	/* Current connection */
static int data_soc = -1;	/* Socket for data transfer =invalid */
static char *user_entered_password = NULL;
static char *last_username_and_host = NULL;

/*
 * ProFTPD 1.2.5rc1 is known to have a broken implementation of RETR.  If asked
 * to retrieve a directory, it gets confused and fails subsequent commands such
 * as CWD and LIST.  Since this is an unusual bug, we should remove this ifdef
 * at some point - TD 2004/1/1.
 */
#define BROKEN_PROFTPD 1
static int ProFTPD_bugs = FALSE;

/*
 * wu-ftpd 2.6.2(12) is known to have a broken implementation of EPSV.  The
 * server will hang for a long time when we attempt to connect after issuing
 * this command - TD 2004/12/28
 */
#define BROKEN_WUFTPD 1
static int WU_FTPD_bugs = FALSE;

typedef enum {
    GENERIC_SERVER
    ,MACHTEN_SERVER
    ,UNIX_SERVER
    ,VMS_SERVER
    ,CMS_SERVER
    ,DCTS_SERVER
    ,TCPC_SERVER
    ,PETER_LEWIS_SERVER
    ,NCSA_SERVER
    ,WINDOWS_NT_SERVER
    ,WINDOWS_2K_SERVER
    ,MS_WINDOWS_SERVER
    ,MSDOS_SERVER
    ,APPLESHARE_SERVER
    ,NETPRESENZ_SERVER
    ,DLS_SERVER
} eServerType;

static eServerType server_type = GENERIC_SERVER;	/* the type of ftp host */
static int unsure_type = FALSE;	/* sure about the type? */
static BOOLEAN use_list = FALSE;	/* use the LIST command? */
d172 1
a172 1
static int interrupted_in_next_data_char = FALSE;
d175 1
a175 1
static PortNumber port_number = FIRST_TCP_PORT;
d178 6
a183 5
static int master_socket = -1;	/* Listening socket = invalid   */
static char port_command[255];	/* Command for setting the port */
static fd_set open_sockets;	/* Mask of active channels */
static int num_sockets;		/* Number of sockets to scan */
static PortNumber passive_port;	/* Port server specified for data */
d188 6
a193 3
static char data_buffer[DATA_BUFFER_SIZE];	/* Input data buffer */
static char *data_read_pointer;
static char *data_write_pointer;
a194 2
#define NEXT_DATA_CHAR next_data_char()
static int close_connection(connection * con);
d198 3
a200 3
 *  This function frees module globals. - FM
 */
static void free_FTPGlobals(void)
d212 14
a225 13
/* PUBLIC						HTVMS_name()
 *		CONVERTS WWW name into a VMS name
 * ON ENTRY:
 *	nn		Node Name (optional)
 *	fn		WWW file name
 *
 * ON EXIT:
 *	returns		vms file specification
 *
 * Bug: Returns pointer to static -- non-reentrant
 */
char *HTVMS_name(const char *nn,
		 const char *fn)
d227 11
a237 9
    /* We try converting the filename into Files-11 syntax.  That is, we assume
     * first that the file is, like us, on a VMS node.  We try remote (or
     * local) DECnet access.  Files-11, VMS, VAX and DECnet are trademarks of
     * Digital Equipment Corporation.  The node is assumed to be local if the
     * hostname WITHOUT DOMAIN matches the local one.  @@@@@@
     */
    static char *vmsname;
    char *filename = (char *) malloc(strlen(fn) + 1);
    char *nodename = (char *) malloc(strlen(nn) + 2 + 1);	/* Copies to hack */
d241 1
a241 1
    const char *hostname = HTHostName();
d248 2
a249 3
	const char *p;
	const char *q;

d251 1
a251 1
	     *p && *p != '.' && *q && *q != '.'; p++, q++) {
a253 1

d257 1
a257 1
		    *r = '\0';	/* Chop domain */
d264 1
a264 1
    second = strchr(filename + 1, '/');		/* 2nd slash */
d267 3
a269 3
    if (!second) {		/* Only one slash */
	HTSprintf0(&vmsname, "%s%s", nodename, filename + 1);
    } else if (second == last) {	/* Exactly two slashes */
d271 4
a274 5
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename + 1, second + 1);
	*second = '/';		/* restore */
    } else {			/* More than two slashes */
	char *p;

d277 2
a278 2
	HTSprintf0(&vmsname, "%s%s:[%s]%s",
		   nodename, filename + 1, second + 1, last + 1);
d280 1
a280 1
	for (p = strchr(vmsname, '['); *p != ']'; p++)
d282 1
a282 1
		*p = '.';	/* Convert dir sep.  to dots */
d290 3
a292 3
 *	----------------------------------------------------
 */
static int next_data_char(void)
a294 1

d297 6
a302 6
	if (status == HT_INTERRUPTED)
	    interrupted_in_next_data_char = 1;
	if (status <= 0)
	    return -1;
	data_write_pointer = data_buffer + status;
	data_read_pointer = data_buffer;
a306 1

d310 1
a310 1
    return UCH(*data_read_pointer++);
d314 1
d316 4
a319 3
 *
 */
static int close_connection(connection * con)
d321 4
a324 6
    connection *scan;
    int status;

    CTRACE((tfp, "HTFTP: Closing control socket %d\n", con->socket));
    status = NETCLOSE(con->socket);
    if (TRACE && status != 0) {
d326 2
a327 4
	CTRACE((tfp, "HTFTP:close_connection: %s", LYStrerror(errno)));
#else
	if (con->socket != INVSOC)
	    HTInetStatus("HTFTP:close_connection");
d339 1
a339 1
		control = (connection *) 0;
d341 3
a343 3
	}			/*if */
    }				/* for */
    return -1;			/* very strange -- was not on list. */
d346 1
a346 1
static char *help_message_buffer = NULL;	/* global :( */
d348 1
a348 1
static void init_help_message_cache(void)
d353 2
a354 1
static void help_message_cache_add(char *string)
d361 1
a361 1
    CTRACE((tfp, "Adding message to help cache: %s\n", string));
d364 1
a364 1
static char *help_message_cache_non_empty(void)
d366 1
a366 1
    return (help_message_buffer);
d368 1
a368 2

static char *help_message_cache_contents(void)
d370 1
a370 1
    return (help_message_buffer);
d373 23
a395 18
/*	Send One Command
 *	----------------
 *
 *	This function checks whether we have a control connection, and sends
 *	one command if given.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command should already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  1 for success,
 *		  or negative for communication failure (in which case
 *		  the control connection will be closed).
 */
static int write_cmd(const char *cmd)
d397 2
d402 2
a403 2
	CTRACE((tfp, "HTFTP: No control connection set up!!\n"));
	return HT_NO_CONNECTION;
d407 1
a407 1
	CTRACE((tfp, "  Tx: %s", cmd));
d410 1
a410 2
	    char *p;

d416 1
a416 1
	status = NETWRITE(control->socket, cmd, (int) strlen(cmd));
d418 2
a419 3
	    CTRACE((tfp,
		    "HTFTP: Error %d sending command: closing socket %d\n",
		    status, control->socket));
a423 32
    return 1;
}

/*	Execute Command and get Response
 *	--------------------------------
 *
 *	See the state machine illustrated in RFC959, p57. This implements
 *	one command/reply sequence.  It also interprets lines which are to
 *	be continued, which are marked with a "-" immediately after the
 *	status code.
 *
 *	Continuation then goes on until a line with a matching reply code
 *	an a space after it.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command must already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  The first digit of the reply type,
 *		  or negative for communication failure.
 */
static int response(const char *cmd)
{
    int result;			/* Three-digit decimal code */
    int continuation_response = -1;
    int status;

    if ((status = write_cmd(cmd)) < 0)
	return status;
a426 1

d429 2
a430 3

	    if (((*p++ = (char) ich) == LF)
		|| (p == &response_text[LINE_LENGTH])) {
d435 2
a436 3
		    CTRACE((tfp,
			    "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		    NETCLOSE(control->socket);
d441 2
a442 2
		*p = '\0';	/* Terminate the string */
		CTRACE((tfp, "    Rx: %s", response_text));
d445 4
a448 4
		if (!strncmp(response_text, "230-", 4) ||
		    !strncmp(response_text, "250-", 4) ||
		    !strncmp(response_text, "220-", 4))
		    help_message_cache_add(response_text + 4);
d451 3
a453 3
		if (continuation_response == -1) {
		    if (continuation == '-')	/* start continuation */
			continuation_response = result;
d455 3
a457 15
		    if (continuation_response == result &&
			continuation == ' ')
			continuation_response = -1;	/* ended */
		}
#ifdef BROKEN_PROFTPD
		if (result == 220 && LYstrstr(response_text, "ProFTPD 1.2.5")) {
		    ProFTPD_bugs = TRUE;
		    CTRACE((tfp, "This server is broken (RETR)\n"));
		}
#endif
#ifdef BROKEN_WUFTPD
		if (result == 220 && LYstrstr(response_text,
					      "(Version wu-2.6.2-12)")) {
		    WU_FTPD_bugs = TRUE;
		    CTRACE((tfp, "This server is broken (EPSV)\n"));
a458 1
#endif
d460 2
a461 2
	    }
	    /* if end of line */
d463 2
a464 3
		CTRACE((tfp,
			"HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		NETCLOSE(control->socket);
d470 2
a471 2
		CTRACE((tfp, "Error on rx: closing socket %d\n",
			control->socket));
d476 1
a476 1
	}			/* Loop over characters */
d481 2
a482 2
	CTRACE((tfp, "HTFTP: They close so we close socket %d\n",
		control->socket));
d490 2
a491 2
	 * Alas, CMS returns 255 on failure to CWD to parent of root.  - PG
	 */
d494 1
a494 1
    return result / 100;
d497 1
a497 1
static int send_cmd_1(const char *verb)
d501 2
a502 2
    sprintf(command, "%.*s%c%c", (int) sizeof(command) - 4, verb, CR, LF);
    return response(command);
d505 1
a505 1
static int send_cmd_2(const char *verb, const char *param)
d511 1
a511 1
    status = response(command);
d520 2
a521 2
 * This function should try to set the macintosh server into binary mode.  Some
 * servers need an additional letter after the MACB command.
d523 2
a524 1
static int set_mac_binary(eServerType ServerType)
d530 1
a530 1
	 * Presumably E means "Enable".  - KW
d532 1
a532 1
	return (2 == response("MACB E\r\n"));
d534 1
a534 1
	return (2 == response("MACB\r\n"));
d542 3
a544 1
static void get_ftp_pwd(eServerType *ServerType, BOOLEAN *UseList)
d546 1
a547 1

a549 1

d553 1
a553 1
	cp = strchr(response_text + 5, '"');
d558 4
a561 4
			   NCSA_SERVER : TCPC_SERVER);
	    CTRACE((tfp, "HTFTP: Treating as %s server.\n",
		    ((*ServerType == NCSA_SERVER) ?
		     "NCSA" : "TCPC")));
d568 1
a568 1
		CTRACE((tfp, "HTFTP: Treating as NCSA server.\n"));
d570 3
a572 3
		*ServerType = UNIX_SERVER;
		*UseList = TRUE;
		CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d575 1
a575 1
	} else if (response_text[strlen(response_text) - 1] == ']') {
d579 1
a579 1
	    CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
d582 1
a582 1
	    CTRACE((tfp, "HTFTP: Treating as Generic server.\n"));
a592 38
/* This function turns MSDOS-like directory output off for
 * Windows NT servers.
 */

static void set_unix_dirstyle(eServerType *ServerType, BOOLEAN *UseList)
{
    char *cp;

    /* This is a toggle.  It seems we have to toggle in order to see
     * the current state (after toggling), so we may end up toggling
     * twice.  - kw
     */
    int status = response("SITE DIRSTYLE\r\n");

    if (status != 2) {
	*ServerType = GENERIC_SERVER;
	CTRACE((tfp, "HTFTP: DIRSTYLE failed, treating as Generic server.\n"));
	return;
    } else {
	*UseList = TRUE;
	/* Expecting one of:
	 * 200 MSDOS-like directory output is off
	 * 200 MSDOS-like directory output is on
	 * The following code doesn't look for the full exact string -
	 * who knows how the wording may change in some future version.
	 * If the first response isn't recognized, we toggle again
	 * anyway, under the assumption that it's more likely that
	 * the MSDOS setting was "off" originally. - kw
	 */
	cp = strstr(response_text + 4, "MSDOS");
	if (cp && strstr(cp, " off")) {
	    return;		/* already off now. */
	} else {
	    response("SITE DIRSTYLE\r\n");
	}
    }
}

d594 17
a610 16
 *	----------------------------------
 *
 * On entry,
 *	arg	points to the name of the host in a hypertext address
 * On exit,
 *	returns <0 if error
 *		socket number if success
 *
 *	This routine takes care of managing timed-out connections, and
 *	limiting the number of connections in use at any one time.
 *
 *	It ensures that all connections are logged in if they exist.
 *	It ensures they have the port number transferred.
 */
static int get_connection(const char *arg,
			  HTParentAnchor *anchor)
d613 4
a616 4
    char *command = 0;
    connection *con;
    char *username = NULL;
    char *password = NULL;
d621 2
a622 2
	 * Set up freeing at exit.  - FM
	 */
d631 2
a632 2
	 * Reuse this object - KW, DW & FM
	 */
d641 3
a643 3
	 * Allocate and init control struct.
	 */
	con = typecalloc(connection);
d649 2
a650 4
    if (!arg)
	return -1;		/* Bad if no name specified     */
    if (!*arg)
	return -1;		/* Bad if name had zero length  */
a653 1
    CTRACE((tfp, "get_connection(%s)\n", arg));
d657 1
a657 1
	char *pw = NULL;
d661 2
a662 2
	    *p2 = '\0';		/* terminate */
	    p1 = p2 + 1;	/* point to host */
d672 4
a675 3
	     * If the password doesn't exist then we are going to have to ask
	     * the user for it.  The only problem is that we don't want to ask
	     * for it every time, so we will store away in a primitive fashion.
d682 3
a684 3
		 * If the user@@host is not equal to the last time through or
		 * user_entered_password has no data then we need to ask the
		 * user for the password.
d692 1
a692 1
			       username, p1);
d696 1
a696 1
		}		/* else we already know the password */
d704 1
a704 1
    }				/* scope of p1 */
d706 1
a706 1
    status = HTDoConnect(arg, "FTP", IPPORT_FTP, (int *) &con->socket);
d710 1
a710 1
	    CTRACE((tfp, "HTFTP: Interrupted on connect\n"));
d712 2
a713 2
	    CTRACE((tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
		    arg));
d716 1
a716 1
	    _HTProgress(CONNECTION_INTERRUPTED);
d721 3
a723 2
	if (con->socket != -1) {
	    NETCLOSE(con->socket);
d730 1
a730 1
	return status;		/* Bad return */
d733 2
a734 2
    CTRACE((tfp, "FTP connected, socket %d  control %p\n",
	    con->socket, con));
d741 1
d744 1
a744 1
    status = response((char *) 0);	/* Get greeting */
d747 2
a748 2
	CTRACE((tfp, "HTFTP: Interrupted at beginning of login.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
d776 2
a777 2
	    CTRACE((tfp, "HTFTP: Interrupted while sending username.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
a792 1
	    char *the_address;
d794 2
a795 2
	    const char *host = NULL;
	    char *cp;
d797 10
a806 12
	    the_address = anonftp_password;
	    if (isEmpty(the_address))
		the_address = personal_mail_address;
	    if (isEmpty(the_address))
		the_address = LYGetEnv("USER");
	    if (isEmpty(the_address))
		the_address = "WWWuser";

	    StrAllocCopy(user, the_address);
	    if ((cp = strchr(user, '@@')) != NULL) {
		*cp++ = '\0';
		if (*cp == '\0')
d808 7
d816 1
a816 2
		    host = cp;
	    } else {
d833 3
a835 2
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
d846 2
a847 2
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
d855 1
a855 1
	CTRACE((tfp, "HTFTP: Login fail: %s", response_text));
d859 1
a859 1
    CTRACE((tfp, "HTFTP: Logged in.\n"));
d861 1
a861 1
    /* Check for host type */
d864 2
a865 2
    use_list = FALSE;		/* reset */
    if ((status = response("SYST\r\n")) == 2) {
d867 1
a867 1
	if (strncmp(response_text + 4,
d871 1
a871 1
	    CTRACE((tfp, "HTFTP: Treating as MachTen server.\n"));
d873 2
a874 2
	} else if (strstr(response_text + 4, "UNIX") != NULL ||
		   strstr(response_text + 4, "Unix") != NULL) {
a875 1
	    unsure_type = FALSE;	/* to the best of out knowledge... */
d877 1
a877 1
	    CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d879 1
a879 1
	} else if (strstr(response_text + 4, "MSDOS") != NULL) {
d882 1
a882 4
	    CTRACE((tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n"));

	} else if (strncmp(response_text + 4, "VMS", 3) == 0) {
	    char *tilde = strstr(arg, "/~");
d884 2
d887 1
a887 9
	    if (tilde != 0
		&& tilde[2] != 0
		&& strstr(response_text + 4, "MadGoat") != 0) {
		server_type = UNIX_SERVER;
		CTRACE((tfp, "HTFTP: Treating VMS as UNIX server.\n"));
	    } else {
		server_type = VMS_SERVER;
		CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	    }
d889 2
a890 2
	} else if ((strncmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (strncmp(response_text + 4, "VM ", 3) == 0)) {
d893 1
a893 1
	    CTRACE((tfp, "HTFTP: Treating as CMS server.\n"));
d895 1
a895 1
	} else if (strncmp(response_text + 4, "DCTS", 4) == 0) {
d897 1
a897 1
	    CTRACE((tfp, "HTFTP: Treating as DCTS server.\n"));
d899 1
a899 1
	} else if (strstr(response_text + 4, "MAC-OS TCP/Connect II") != NULL) {
d901 1
a901 1
	    CTRACE((tfp, "HTFTP: Looks like a TCPC server.\n"));
d905 1
a905 1
	} else if (server_type == NETPRESENZ_SERVER) {	/* already set above */
d908 1
a908 1
	    CTRACE((tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n"));
d910 1
a910 1
	} else if (strncmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
d914 1
a914 1
	    CTRACE((tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n"));
d916 1
a916 1
	} else if (strncmp(response_text + 4, "Windows_NT", 10) == 0) {
d918 2
a919 7
	    CTRACE((tfp, "HTFTP: Treating as Window_NT server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (strncmp(response_text + 4, "Windows2000", 11) == 0) {
	    server_type = WINDOWS_2K_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_2K server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);
d921 1
a921 1
	} else if (strncmp(response_text + 4, "MS Windows", 10) == 0) {
d924 1
a924 1
	    CTRACE((tfp, "HTFTP: Treating as MS Windows server.\n"));
d926 1
a926 1
	} else if (strncmp(response_text + 4,
d931 1
a931 1
	    CTRACE((tfp, "HTFTP: Treating as AppleShare server.\n"));
d933 1
a933 1
	} else {
d935 1
a935 1
	    CTRACE((tfp, "HTFTP: Ugh!  A Generic server.\n"));
d938 1
a938 1
	}
d941 1
a941 1
	get_ftp_pwd(&server_type, &use_list);
a948 1

d952 1
a952 1
	    return -status;	/* Bad return */
d954 1
a954 1
	CTRACE((tfp, "HTFTP: Port defined.\n"));
d957 1
a957 1
    return con->socket;		/* Good return */
d960 1
d962 5
a966 5
 *	-------------------------------
 *
 *
 */
static int close_master_socket(void)
d973 1
a973 1
    CTRACE((tfp, "HTFTP: Closed master socket %d\n", master_socket));
d981 1
d983 14
a996 14
 *	-------------------------------------
 *
 *	When data is transferred, we open a port, and wait for the server to
 *	connect with the data.
 *
 * On entry,
 *	master_socket	Must be negative if not set up already.
 * On exit,
 *	Returns		socket number if good
 *			less than zero if error.
 *	master_socket	is socket number if good, else negative.
 *	port_number	is valid if good.
 */
static int get_listen_socket(void)
d998 3
a1000 5
#ifdef INET6
    struct sockaddr_storage soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = (struct sockaddr_in *) &soc_address;
    int af;
    LY_SOCKLEN slen;
a1001 5
#else
    struct sockaddr_in soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = &soc_address;
#endif /* INET6 */
    int new_socket;		/* Will be master_socket */
d1008 1
a1008 1
	return master_socket;	/* Done already */
a1010 11
#ifdef INET6
    /* query address family of control connection */
    slen = sizeof(soc_address);
    if (getsockname(control->socket, (struct sockaddr *) &soc_address,
		    &slen) < 0) {
	return HTInetStatus("getsockname failed");
    }
    af = ((struct sockaddr *) &soc_address)->sa_family;
    memset(&soc_address, 0, sizeof(soc_address));
#endif /* INET6 */

a1012 3
#ifdef INET6
    new_socket = socket(af, SOCK_STREAM, IPPROTO_TCP);
#else
a1013 1
#endif /* INET6 */
d1018 1
a1018 1
    CTRACE((tfp, "HTFTP: Opened master socket number %d\n", new_socket));
d1022 2
a1023 21
#ifdef INET6
    memset(&soc_address, 0, sizeof(soc_address));
    ((struct sockaddr *) &soc_address)->sa_family = af;
    switch (af) {
    case AF_INET:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in);
#endif /* SIN6_LEN */
	break;
    case AF_INET6:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in6);
#endif /* SIN6_LEN */
	break;
    default:
	HTInetStatus("AF");
    }
#else
    soc_in->sin_family = AF_INET;	/* Family = internet, host order  */
    soc_in->sin_addr.s_addr = INADDR_ANY;	/* Any peer address */
#endif /* INET6 */
d1026 2
a1027 3
	PortNumber old_port_number = port_number;

	for (port_number = (old_port_number + 1);; port_number++) {
a1028 1

a1033 3
#ifdef INET6
	    soc_in->sin_port = htons(port_number);
#else
a1034 1
#endif /* INET6 */
d1037 4
a1040 4
		if ((status = Rbind(new_socket,
				    (struct sockaddr *) &soc_address,
		/* Cast to generic sockaddr */
				    SOCKADDR_LEN(soc_address)
d1042 1
a1042 1
				    ,socks_bind_remoteAddr
d1044 1
a1044 1
		     )) == 0) {
d1046 1
a1046 1
		} else
d1048 8
a1055 10
		    if ((status = bind(new_socket,
				       (struct sockaddr *) &soc_address,
		    /* Cast to generic sockaddr */
				       SOCKADDR_LEN(soc_address)
			 )) == 0) {
		    break;
		}
	    CTRACE((tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		    port_number, status, SOCKET_ERRNO));
	}			/* for */
d1060 1
a1060 2
	LY_SOCKLEN address_length = sizeof(soc_address);

d1064 2
a1065 2
				  (struct sockaddr *) &soc_address,
				  &address_length);
d1068 6
a1073 13
	    status = getsockname(control->socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0)
	    return HTInetStatus("getsockname");
#ifdef INET6
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString((SockA *) soc_in)));

	soc_in->sin_port = 0;	/* Unspecified: please allocate */
#else
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString(soc_in)));
a1075 1
#endif /* INET6 */
d1078 4
a1081 4
	    status = Rbind(new_socket,
			   (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			   sizeof(soc_address)
d1083 1
a1083 5
#ifdef INET6
			   socks_bind_remoteAddr
#else
			   ,socks_bind_remoteAddr
#endif /* INET6 */
d1085 1
a1085 1
		);
d1088 5
a1092 7
	    status = bind(new_socket,
			  (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			  SOCKADDR_LEN(soc_address)
		);
	if (status < 0)
	    return HTInetStatus("bind");
d1098 2
a1099 2
				  (struct sockaddr *) &soc_address,
				  &address_length);
d1102 4
a1105 5
	    status = getsockname(new_socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0)
	    return HTInetStatus("getsockname");
d1109 3
a1111 9
#ifdef INET6
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString((SockA *) soc_in)));
#else
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString(soc_in)));
#endif /* INET6 */
d1116 1
a1116 1
#endif /* REPEAT_LISTEN */
d1122 8
a1129 27
    (void) HTHostName();	/* Make address valid - doesn't work */
#ifdef INET6
    switch (((struct sockaddr *) &soc_address)->sa_family) {
    case AF_INET:
#endif /* INET6 */
	sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
		(int) *((unsigned char *) (&soc_in->sin_addr) + 0),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 1),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 2),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 3),
		(int) *((unsigned char *) (&soc_in->sin_port) + 0),
		(int) *((unsigned char *) (&soc_in->sin_port) + 1),
		CR, LF);

#ifdef INET6
	break;

    case AF_INET6:
	{
	    char hostbuf[MAXHOSTNAMELEN];
	    char portbuf[MAXHOSTNAMELEN];

	    getnameinfo((struct sockaddr *) &soc_address,
			SOCKADDR_LEN(soc_address),
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
a1130 7
	    break;
	}
    default:
	sprintf(port_command, "JUNK%c%c", CR, LF);
	break;
    }
#endif /* INET6 */
a1131 4
    /*  Inform TCP that we will accept connections
     */
    {
	int status;
d1133 4
d1138 3
a1140 3
	if (socks_flag)
	    status = Rlisten(master_socket, 1);
	else
d1142 4
a1145 5
	    status = listen(master_socket, 1);
	if (status < 0) {
	    master_socket = -1;
	    return HTInetStatus("listen");
	}
d1147 2
a1148 1
    CTRACE((tfp, "TCP: Master socket(), bind() and listen() all OK\n"));
d1150 2
a1151 2
    if ((master_socket + 1) > num_sockets)
	num_sockets = master_socket + 1;
d1153 1
a1153 1
    return master_socket;	/* Good */
d1155 1
a1155 1
}				/* get_listen_socket */
d1157 2
a1158 4
static const char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
d1162 10
a1171 10
 *	-----------------------------------------------------------------
 *
 *	Bug:
 *		This code is for sorting listings by date, if that option
 *		is selected in Lynx, and doesn't take into account time
 *		zones or ensure resetting at midnight, so the sort may not
 *		be perfect, but the actual date isn't changed in the display,
 *		i.e., the date is still correct. - FM
 */
static void set_years_and_date(void)
d1178 1
a1178 1
    strncpy(day, (char *) ctime(&NowTime) + 8, 2);
d1183 2
a1184 1
    strncpy(month, (char *) ctime(&NowTime) + 4, 3);
d1192 2
a1193 1
    sprintf(date, "9999%02d%.2s", i, day);
d1195 1
a1195 1
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
d1202 3
a1204 4
    char *filename;
    char *linkname;
    char *type;
    char *date;
d1206 1
a1206 1
    BOOLEAN display;		/* show this entry? */
d1209 2
a1210 1
static void free_entryinfo_struct_contents(EntryInfo *entry_info)
a1213 1
	FREE(entry_info->linkname);
d1217 1
a1217 1
    /* dont free the struct */
d1228 2
a1229 1
static BOOLEAN is_ls_date(char *s)
d1232 1
a1232 1
    if (!isalpha(UCH(*s++)) || !isalpha(UCH(*s++)) || !isalpha(UCH(*s++)))
d1243 1
a1243 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
d1250 1
a1250 1
    if (!isdigit(UCH(*s++)))
d1258 1
a1258 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
d1265 1
a1265 1
    if (!isdigit(UCH(*s++)))
d1269 1
a1269 1
    if (!(*s == ':' || isdigit(UCH(*s)))) {
d1276 1
a1276 1
    if (!isdigit(UCH(*s++)))
d1280 1
a1280 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
d1291 1
a1291 1
}				/* is_ls_date() */
d1294 2
a1295 1
 * Extract the name, size, and date from an EPLF line.  - 08-06-96 DJB
d1297 3
a1299 2
static void parse_eplf_line(char *line,
			    EntryInfo *info)
d1305 1
a1305 1
    static time_t base;		/* time() value on this OS in 1970 */
d1310 2
a1311 7

	t.tm_year = 70;
	t.tm_mon = 0;
	t.tm_mday = 0;
	t.tm_hour = 0;
	t.tm_min = 0;
	t.tm_sec = 0;
d1313 1
a1313 1
	base = mktime(&t);	/* could return -1 */
d1318 27
a1344 28
	switch (*cp) {
	case '\t':
	    StrAllocCopy(info->filename, cp + 1);
	    return;
	case 's':
	    size = 0;
	    while (*(++cp) && (*cp != ','))
		size = (size * 10) + (*cp - '0');
	    info->size = size;
	    break;
	case 'm':
	    secs = 0;
	    while (*(++cp) && (*cp != ','))
		secs = (secs * 10) + (*cp - '0');
	    secs += base;	/* assumes that time_t is #seconds */
	    strcpy(ct, ctime(&secs));
	    ct[24] = 0;
	    StrAllocCopy(info->date, ct);
	    break;
	case '/':
	    StrAllocCopy(info->type, ENTRY_IS_DIRECTORY);
	    /* FALLTHRU */
	default:
	    while (*cp) {
		if (*cp++ == ',')
		    break;
	    }
	    break;
d1347 1
a1347 1
}				/* parse_eplf_line */
d1350 2
a1351 1
 * Extract the name, size, and date from an ls -l line.
d1353 7
a1359 6
static void parse_ls_line(char *line,
			  EntryInfo *entry_info)
{
    int i, j;
    int base = 1;
    int size_num = 0;
d1362 2
a1363 2
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i - 12]));
	 i--) ;			/* null body */
d1366 1
a1366 1
	StrAllocCopy(entry_info->date, &line[i - 12]);
d1373 1
a1373 1
		entry_info->date[j] = entry_info->date[j - 1];
d1378 1
a1378 1
    while (isdigit(UCH(line[j]))) {
d1385 1
a1385 1
}				/* parse_ls_line() */
d1388 3
a1390 2
 * Extract the name and size info and whether it refers to a directory from a
 * LIST line in "dls" format.
d1392 7
a1398 21
static void parse_dls_line(char *line,
			   EntryInfo *entry_info,
			   char **pspilledname)
{
    short j;
    int base = 1;
    int size_num = 0;
    int len;
    char *cps = NULL;

    /* README              763  Information about this server\0
       bin/                  -  \0
       etc/                  =  \0
       ls-lR                 0  \0
       ls-lR.Z               3  \0
       pub/                  =  Public area\0
       usr/                  -  \0
       morgan               14  -> ../real/morgan\0
       TIMIT.mostlikely.Z\0
       79215    \0
     */
d1400 3
a1402 3
    len = strlen(line);
    if (len == 0) {
	FREE(*pspilledname);
d1406 18
a1423 18
    cps = LYSkipNonBlanks(line);
    if (*cps == '\0') {		/* only a filename, save it and return. */
	StrAllocCopy(*pspilledname, line);
	entry_info->display = FALSE;
	return;
    }
    if (len < 24 || line[23] != ' ' ||
	(isspace(UCH(line[0])) && !*pspilledname)) {
	/* this isn't the expected "dls" format! */
	if (!isspace(UCH(line[0])))
	    *cps = '\0';
	if (*pspilledname && !*line) {
	    entry_info->filename = *pspilledname;
	    *pspilledname = NULL;
	    if (entry_info->filename[strlen(entry_info->filename) - 1] == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
d1425 1
a1425 6
	    StrAllocCopy(entry_info->filename, line);
	    if (cps && cps != line && *(cps - 1) == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	    FREE(*pspilledname);
d1427 1
a1427 1
	return;
d1430 6
a1435 67
    j = 22;
    if (line[j] == '=' || line[j] == '-') {
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    } else {
	while (isdigit(UCH(line[j]))) {
	    size_num += (line[j] - '0') * base;
	    base *= 10;
	    j--;
	}
    }
    entry_info->size = size_num;

    cps = LYSkipBlanks(&line[23]);
    if (!strncmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
	StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
	StrAllocCopy(entry_info->linkname, LYSkipBlanks(cps + 3));
	entry_info->size = 0;	/* don't display size */
    }

    if (j > 0)
	line[j] = '\0';

    LYTrimTrailing(line);

    len = strlen(line);
    if (len == 0 && *pspilledname && **pspilledname) {
	line = *pspilledname;
	len = strlen(*pspilledname);
    }
    if (len > 0 && line[len - 1] == '/') {
	/*
	 * It's a dir, remove / and mark it as such.
	 */
	if (len > 1)
	    line[len - 1] = '\0';
	if (!entry_info->type)
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    }

    StrAllocCopy(entry_info->filename, line);
    FREE(*pspilledname);
}				/* parse_dls_line() */

/*
 * parse_vms_dir_entry()
 *	Format the name, date, and size from a VMS LIST line
 *	into the EntryInfo structure - FM
 */
static void parse_vms_dir_entry(char *line,
				EntryInfo *entry_info)
{
    int i, j;
    unsigned int ialloc;
    char *cp, *cpd, *cps, date[16];
    const char *sp = " ";

    /* Get rid of blank lines, and information lines.  Valid lines have the ';'
     * version number token.
     */
    if (!strlen(line) || (cp = strchr(line, ';')) == NULL) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name at VMS version number. */
    *cp++ = '\0';
    StrAllocCopy(entry_info->filename, line);
d1437 3
a1439 29
    /* Cast VMS non-README file and directory names to lowercase. */
    if (strstr(entry_info->filename, "READ") == NULL) {
	LYLowerCase(entry_info->filename);
	i = strlen(entry_info->filename);
    } else {
	i = ((strstr(entry_info->filename, "READ") - entry_info->filename) + 4);
	if (!strncmp(&entry_info->filename[i], "ME", 2)) {
	    i += 2;
	    while (entry_info->filename[i] && entry_info->filename[i] != '.') {
		i++;
	    }
	} else if (!strncmp(&entry_info->filename[i], ".ME", 3)) {
	    i = strlen(entry_info->filename);
	} else {
	    i = 0;
	}
	LYLowerCase(entry_info->filename + i);
    }

    /* Uppercase terminal .z's or _z's. */
    if ((--i > 2) &&
	entry_info->filename[i] == 'z' &&
	(entry_info->filename[i - 1] == '.' ||
	 entry_info->filename[i - 1] == '_'))
	entry_info->filename[i] = 'Z';

    /* Convert any tabs in rest of line to spaces. */
    cps = cp - 1;
    while ((cps = strchr(cps + 1, '\t')) != NULL)
d1442 2
a1443 3
    /* Collapse serial spaces. */
    i = 0;
    j = 1;
d1453 1
a1453 1
    /* Set the years and date, if we don't have them yet. * */
d1458 16
a1473 13
    /* Track down the date. */
    if ((cpd = strchr(cp, '-')) != NULL &&
	strlen(cpd) > 9 && isdigit(UCH(*(cpd - 1))) &&
	isalpha(UCH(*(cpd + 1))) && *(cpd + 4) == '-') {

	/* Month */
	*(cpd + 2) = (char) TOLOWER(*(cpd + 2));
	*(cpd + 3) = (char) TOLOWER(*(cpd + 3));
	sprintf(date, "%.3s ", cpd + 1);

	/* Day */
	if (isdigit(UCH(*(cpd - 2))))
	    sprintf(date + 4, "%.2s ", cpd - 2);
d1475 2
a1476 1
	    sprintf(date + 4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd - 1);
d1478 6
a1483 4
	/* Time or Year */
	if (!strncmp(ThisYear, cpd + 5, 4) &&
	    strlen(cpd) > 15 && *(cpd + 12) == ':') {
	    sprintf(date + 7, "%.5s", cpd + 10);
d1485 3
a1487 1
	    sprintf(date + 7, " %.4s", cpd + 5);
d1493 2
a1494 2
    /* Track down the size */
    if ((cpd = strchr(cp, '/')) != NULL) {
d1497 1
a1497 1
	while (isdigit(UCH(*(cps - 1))))
d1502 2
a1503 2
	cps = cpd + 1;
	while (isdigit(UCH(*cps)))
d1506 1
a1506 1
	ialloc = atoi(cpd + 1);
d1511 1
a1511 1
    } else if ((cps = strtok(cp, sp)) != NULL) {
d1514 1
a1514 1
	while ((cps = strtok(NULL, sp)) != NULL) {
d1516 1
a1516 1
	    while (isdigit(UCH(*cpd)))
d1526 5
a1530 5
    /* Wrap it up */
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %u\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1532 1
a1532 1
}				/* parse_vms_dir_entry() */
d1539 3
a1541 2
static void parse_ms_windows_dir_entry(char *line,
				       EntryInfo *entry_info)
d1547 1
a1547 1
    /*  Get rid of blank or junk lines.  */
d1554 1
a1554 1
    /* Cut out file or directory name. */
d1556 1
a1556 1
    *cps++ = '\0';
d1560 1
a1560 1
    /* Track down the size */
d1565 1
a1565 1
	if (isdigit(UCH(*cps))) {
d1574 1
a1574 1
    /* Set the years and date, if we don't have them yet. * */
d1579 1
a1579 1
    /* Track down the date. */
d1583 4
a1586 4
	    *(cpd + 6) = '\0';	/* Month and Day */
	    *(cpd + 11) = '\0';	/* Year */
	    *(cpd + 17) = '\0';	/* Time */
	    if (strcmp(ThisYear, cpd + 7))
d1588 1
a1588 1
		sprintf(date, "%.6s  %.4s", cpd, (cpd + 7));
d1591 1
a1591 1
		sprintf(date, "%.6s %.5s", cpd, (cpd + 12));
d1593 1
a1593 1
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
d1599 5
a1603 5
    /* Wrap it up */
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %u\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1605 1
a1605 1
}				/* parse_ms_windows_dir_entry */
d1613 3
a1615 2
static void parse_windows_nt_dir_entry(char *line,
				       EntryInfo *entry_info)
d1622 1
a1622 1
    /*  Get rid of blank or junk lines.  */
d1629 1
a1629 1
    /* Cut out file or directory name. */
d1631 2
a1632 2
    cps = LYSkipNonBlanks(end - 1);
    cp = (cps + 1);
d1643 1
a1643 1
    /* Set the years and date, if we don't have them yet. * */
d1648 1
a1648 1
    /* Cut out the date. */
d1651 1
a1651 1
    *cps++ = '\0';
d1658 1
a1658 1
    *cps++ = '\0';
d1664 3
a1666 3
	isdigit(*cp) && isdigit(*(cp + 1)) && *(cp + 2) == '-' &&
	isdigit(*(cp + 3)) && isdigit(*(cp + 4)) && *(cp + 5) == '-') {
	*(cp + 2) = '\0';	/* Month */
d1668 2
a1669 2
	*(cp + 5) = '\0';	/* Day */
	sprintf(date, "%.3s %.2s", months[i], (cp + 3));
d1672 2
a1673 2
	cp += 6;		/* Year */
	if (strcmp((ThisYear + 2), cp)) {
d1676 1
a1676 1
		sprintf(&date[6], "  20%.2s", cp);
d1678 1
a1678 1
		sprintf(&date[6], "  19%.2s", cp);
d1682 1
a1682 1
	    *(cpd + 2) = '\0';	/* Hour */
d1684 1
a1684 1
	    if (*(cpd + 5) == 'P' || *(cpd + 5) == 'p')
d1686 3
a1688 1
	    sprintf(&date[6], " %02d:%.2s", i, (cpd + 3));
d1691 1
a1691 1
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
d1696 1
a1696 1
    /* Track down the size */
d1710 5
a1714 5
    /* Wrap it up */
    CTRACE((tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1716 1
a1716 1
}				/* parse_windows_nt_dir_entry */
d1724 3
a1726 2
static void parse_cms_dir_entry(char *line,
				EntryInfo *entry_info)
d1735 1
a1735 1
    /*  Get rid of blank or junk lines.  */
d1742 1
a1742 1
    /* Cut out file or directory name. */
d1744 1
a1744 1
    *cps++ = '\0';
d1747 1
a1747 1
	/* If we already have a dot, we did an NLST. */
d1751 1
a1751 1
	/* If we don't have more, we've misparsed. */
d1758 1
a1758 1
    *cps++ = '\0';
d1760 1
a1760 1
	/* It's an SFS directory. */
d1764 1
a1764 1
	/* It's a file. */
d1769 1
a1769 1
	/* Track down the VM/CMS RECFM or type. */
d1775 1
a1775 1
	    /* Check cp here, if it's relevant someday. */
d1779 1
a1779 1
    /* Track down the record length or dash. */
d1785 1
a1785 1
	if (isdigit(UCH(*cp))) {
d1790 1
a1790 1
    /* Track down the number of records or the dash. */
d1796 1
a1796 1
	if (isdigit(UCH(*cp))) {
d1800 1
a1800 1
	    /* Compute an approximate size. */
d1805 1
a1805 1
    /* Set the years and date, if we don't have them yet. */
d1810 1
a1810 1
    /* Track down the date. */
d1815 1
a1815 1
	 isdigit(UCH(*(cps + 1))) && isdigit(UCH(*(cps + 2))) && *(cps + 3) == ':')) {
d1820 3
a1822 3
	    *(cpd + 2) = '\0';	/* Month */
	    *(cpd + 5) = '\0';	/* Day */
	    *(cpd + 8) = '\0';	/* Year */
d1827 1
a1827 1
	    sprintf(date, "%.3s %.2s", months[i], (cpd + 3));
d1831 1
a1831 1
	    if (strcmp((ThisYear + 2), cpd)) {
d1834 1
a1834 1
		    sprintf(&date[6], "  20%.2s", cpd);
d1836 1
a1836 1
		    sprintf(&date[6], "  19%.2s", cpd);
d1840 1
a1840 1
		*(cps + 2) = '\0';	/* Hour */
d1842 2
a1843 1
		sprintf(&date[6], " %02d:%.2s", i, (cps + 3));
d1846 1
a1846 1
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
d1852 5
a1856 5
    /* Wrap it up. */
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %u\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1858 1
a1858 1
}				/* parse_cms_dir_entry */
d1861 3
a1863 2
 * Given a line of LIST/NLST output in entry, return results and a file/dir
 * name in entry_info struct
d1865 1
a1865 1
 * If first is true, this is the first name in a directory.
d1867 4
a1870 3
static EntryInfo *parse_dir_entry(char *entry,
				  BOOLEAN *first,
				  char **pspilledname)
d1873 3
a1875 3
    int i;
    int len;
    BOOLEAN remove_size = FALSE;
d1878 1
a1878 2
    entry_info = (EntryInfo *) malloc(sizeof(EntryInfo));

a1881 1
    entry_info->linkname = NULL;
d1888 14
a1901 1
    case DLS_SERVER:
d1903 3
a1905 8
	/*
	 * Interpret and edit LIST output from a Unix server in "dls" format. 
	 * This one must have claimed to be Unix in order to get here; if the
	 * first line looks fishy, we revert to Unix and hope that fits better
	 * (this recovery is untested).  - kw
	 */

	if (*first) {
d1907 9
a1915 7
	    if (!len || entry[0] == ' ' ||
		(len >= 24 && entry[23] != ' ') ||
		(len < 24 && strchr(entry, ' '))) {
		server_type = UNIX_SERVER;
		CTRACE((tfp,
			"HTFTP: Falling back to treating as Unix server.\n"));
	    } else {
d1917 10
a1927 1
	}
d1929 34
a1962 3
	if (server_type == DLS_SERVER) {
	    /* if still unchanged... */
	    parse_dls_line(entry, entry_info, pspilledname);
d1964 2
a1965 6
	    if (!entry_info->filename || *entry_info->filename == '\0') {
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    if (!strcmp(entry_info->filename, "..") ||
		!strcmp(entry_info->filename, "."))
a1966 4
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
d1968 2
a1969 2
	     * Goto the bottom and get real type.
	     */
a1970 17
	}
	/* fall through if server_type changed for *first == TRUE ! */
    case UNIX_SERVER:
    case PETER_LEWIS_SERVER:
    case MACHTEN_SERVER:
    case MSDOS_SERVER:
    case WINDOWS_NT_SERVER:
    case WINDOWS_2K_SERVER:
    case APPLESHARE_SERVER:
    case NETPRESENZ_SERVER:
	/*
	 * Check for EPLF output (local times).
	 */
	if (*entry == '+') {
	    parse_eplf_line(entry, entry_info);
	    break;
	}
d1972 12
a1983 25
	/*
	 * Interpret and edit LIST output from Unix server.
	 */
	len = strlen(entry);
	if (*first) {
	    /* don't gettext() this -- incoming text: */
	    if (!strcmp(entry, "can not access directory .")) {
		/*
		 * Don't reset *first, nothing real will follow.  - KW
		 */
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    *first = FALSE;
	    if (!strncmp(entry, "total ", 6) ||
		strstr(entry, "not available") != NULL) {
		entry_info->display = FALSE;
		return (entry_info);
	    } else if (unsure_type) {
		/* this isn't really a unix server! */
		server_type = GENERIC_SERVER;
		entry_info->display = FALSE;
		return (entry_info);
	    }
	}
a1984 4
	/*
	 * Check first character of ls -l output.
	 */
	if (TOUPPER(entry[0]) == 'D') {
d1986 8
a1993 5
	     * It's a directory.
	     */
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	} else if (entry[0] == 'l') {
d1995 3
a1997 5
	     * It's a symbolic link, does the user care about knowing if it is
	     * symbolic?  I think so since it might be a directory.
	     */
	    StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
	    remove_size = TRUE;	/* size is not useful */
d1999 1
d2001 4
a2004 23
	     * Strip off " -> pathname".
	     */
	    for (i = len - 1; (i > 3) &&
		 (!isspace(UCH(entry[i])) ||
		  (entry[i - 1] != '>') ||
		  (entry[i - 2] != '-') ||
		  (entry[i - 3] != ' ')); i--) ;	/* null body */
	    if (i > 3) {
		entry[i - 3] = '\0';
		len = i - 3;
		StrAllocCopy(entry_info->linkname, LYSkipBlanks(entry + i));
	    }
	}
	/* link */
	parse_ls_line(entry, entry_info);

	if (!strcmp(entry_info->filename, "..") ||
	    !strcmp(entry_info->filename, "."))
	    entry_info->display = FALSE;
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2006 13
a2018 47
    case VMS_SERVER:
	/*
	 * Interpret and edit LIST output from VMS server and convert
	 * information lines to zero length.
	 */
	parse_vms_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);

	/*
	 * Trim off VMS directory extensions.
	 */
	len = strlen(entry_info->filename);
	if ((len > 4) && !strcmp(&entry_info->filename[len - 4], ".dir")) {
	    entry_info->filename[len - 4] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    case MS_WINDOWS_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_ms_windows_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2021 6
a2026 6
    case WINDOWS_NT_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_windows_nt_dir_entry(entry, entry_info);
d2028 13
a2040 13
	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2043 2
a2044 2
    case CMS_SERVER:
	{
d2046 3
a2048 3
	     * Interpret and edit LIST output from VM/CMS server and convert
	     * any information lines to zero length.
	     */
d2052 2
a2053 2
	     * Get rid of any junk lines.
	     */
d2055 1
a2055 1
		return (entry_info);
d2058 1
a2058 1
		return (entry_info);
d2061 2
a2062 2
	     * Goto the bottom and get real type.
	     */
d2064 1
a2064 1
	}
d2066 15
a2080 8
    case NCSA_SERVER:
    case TCPC_SERVER:
	/*
	 * Directories identified by trailing "/" characters.
	 */
	StrAllocCopy(entry_info->filename, entry);
	len = strlen(entry);
	if (entry[len - 1] == '/') {
d2082 3
a2084 10
	     * It's a dir, remove / and mark it as such.
	     */
	    entry[len - 1] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2086 7
a2092 7
    default:
	/*
	 * We can't tell if it is a directory since we only did an NLST :( List
	 * bad file types anyways?  NOT!
	 */
	StrAllocCopy(entry_info->filename, entry);
	return (entry_info);	/* mostly empty info */
d2094 1
a2094 1
    }				/* switch (server_type) */
d2101 1
a2101 1
	if (((cp = strrchr(entry_info->filename, '.')) != NULL &&
d2105 4
a2108 4
	     * Don't treat this as application/x-Troff-me if it's a Unix server
	     * but has the string "read.me", or if it's not a Unix server.  -
	     * FM
	     */
d2118 2
a2119 2
     * Get real types eventually.
     */
d2121 1
a2121 1
	const char *cp2;
d2123 1
a2123 2
	HTAtom *encoding;	/* @@@@ not used at all */

d2127 1
a2127 1
	    if (!strncmp(HTAtom_name(format), "application", 11)) {
d2129 1
a2129 1
		if (!strncmp(cp2, "x-", 2))
d2139 2
a2140 2
    return (entry_info);
}				/* parse_dir_entry */
d2142 3
a2144 1
static int compare_EntryInfo_structs(EntryInfo *entry1, EntryInfo *entry2)
d2149 18
a2166 4
    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size == entry2->size)
a2167 4
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
d2169 14
a2182 33
    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcmp(entry1->filename, entry2->filename));

    case FILE_BY_DATE:
	if (entry1->date && entry2->date) {
	    /*
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 || strlen(entry2->date) != 12) {
		return (strcmp(entry1->filename, entry2->filename));
	    }
	    /*
	     * Set the years and date,
	     * if we don't have them yet.
	     */
	    if (!HaveYears) {
		set_years_and_date();
	    }
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[9] == ':') {
		strcpy(date1, "9999");
		strcpy(time1, &entry1->date[7]);
		if (time1[0] == ' ') {
		    time1[0] = '0';
d2184 13
a2196 9
	    } else {
		strcpy(date1, &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
d2198 6
a2203 16
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    strncat(date1, &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ' || date1[6] == HT_NON_BREAK_SPACE) {
		date1[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date1[i] = LastYear[i];
d2205 12
a2216 7
	    }
	    strcat(date1, time1);
	    if (entry2->date[9] == ':') {
		strcpy(date2, "9999");
		strcpy(time2, &entry2->date[7]);
		if (time2[0] == ' ') {
		    time2[0] = '0';
d2218 17
a2234 9
	    } else {
		strcpy(date2, &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
d2236 12
a2247 16
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    strncat(date2, &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ' || date2[6] == HT_NON_BREAK_SPACE) {
		date2[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date2[i] = LastYear[i];
d2249 8
d2258 5
a2262 14
	    strcat(date2, time2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcmp(entry1->filename, entry2->filename));

    case FILE_BY_NAME:
    default:
	return (strcmp(entry1->filename, entry2->filename));
d2266 1
d2268 14
a2281 13
 *	--------------------------------------------------------------
 *
 * On entry,
 *	anchor		Parent anchor to link the this node to
 *	address		Address of the directory
 * On exit,
 *	returns		HT_LOADED if OK
 *			<0 if error.
 */
static int read_directory(HTParentAnchor *parent,
			  const char *address,
			  HTFormat format_out,
			  HTStream *sink)
d2285 1
a2285 1
    HTStructured *target = HTML_new(parent, format_out, sink);
d2291 1
a2291 1
    char *lastpath = NULL;	/* prefix for link, either "" (for root) or xxx  */
d2297 1
a2297 1
    _HTProgress(gettext("Receiving FTP directory."));
d2300 3
a2302 9
     * Force the current Date and Year (TheDate, ThisYear, and LastYear) to be
     * recalculated for each directory request.  Otherwise we have a problem
     * with long-running sessions assuming the wrong date for today.  - kw
     */
    HaveYears = FALSE;
    /*
     * Check whether we always want the home directory treated as Welcome.  -
     * FM
     */
d2307 7
a2313 5
     * This should always come back FALSE, since the flag is set only for local
     * directory listings if LONG_LIST was defined on compilation, but we could
     * someday set up an equivalent listing for Unix ftp servers.  - FM
     */
    need_parent_link = HTDirTitles(target, parent, tildeIsTop);
d2317 4
a2320 4
    if (*filename == '\0') {	/* Empty filename: use root. */
	StrAllocCopy(lastpath, "/");
    } else if (!strcmp(filename, "/")) {	/* Root path. */
	StrAllocCopy(lastpath, "/foo/..");
d2322 1
a2322 1
	char *p = strrchr(filename, '/');	/* Find the lastslash. */
d2326 1
a2326 1
	    StrAllocCopy(lastpath, filename);	/* Use absolute path for CMS. */
d2328 1
a2328 1
	    StrAllocCopy(lastpath, p + 1);	/* Take slash off the beginning. */
d2330 5
a2334 5
	if ((cp = strrchr(lastpath, ';')) != NULL) {	/* Trim type= param. */
	    if (!strncasecomp((cp + 1), "type=", 5)) {
		if (TOUPPER(*(cp + 6)) == 'D' ||
		    TOUPPER(*(cp + 6)) == 'A' ||
		    TOUPPER(*(cp + 6)) == 'I')
d2339 2
a2340 1
    FREE(filename);
d2343 1
a2343 1
	HTBTree *bt = HTBTree_new((HTComparer) compare_EntryInfo_structs);
d2345 1
a2345 1
	HTChunk *chunk = HTChunkCreate(128);
d2349 1
a2349 3
	char *spilledname = NULL;

	PUTC('\n');		/* prettier LJM */
a2353 3
		CTRACE((tfp,
			"read_directory: interrupted after %d bytes\n",
			BytesReceived));
a2359 1
		    FREE(spilledname);
d2364 1
a2364 1
	    /*   read directory entry
d2366 1
a2366 2
	    interrupted_in_next_data_char = FALSE;
	    for (;;) {		/* Read in one line as filename */
d2368 1
a2368 1
	      AgainForMultiNet:
a2369 3
		    CTRACE((tfp,
			    "read_directory: interrupted_in_next_data_char after %d bytes\n",
			    BytesReceived));
d2372 1
a2372 1
			goto unload_btree;	/* unload btree */
a2375 1
			FREE(spilledname);
d2378 2
a2379 2
		} else if ((char) ic == CR || (char) ic == LF) {	/* Terminator? */
		    if (chunk->size != 0) {	/* got some text */
d2382 1
a2382 1
			    /* Deal with MultiNet's wrapping of long lines - F.M. */
d2384 1
a2384 1
				*(data_read_pointer + 1) == ' ')
d2403 2
a2404 1
			    } else
d2406 2
a2407 1
			} else
d2411 1
a2411 1
		    break;	/* End of file */
d2413 1
a2413 1
		    HTChunkPutc(chunk, (char) ic);
a2419 4
#ifdef _WINDOWS
		sprintf(NumBytes, gettext("Transferred %d bytes (%5d)"),
			BytesReceived, ws_read_per_sec);
#else
a2420 1
#endif
d2426 1
a2426 1
		/* 1 means empty: includes terminating 0 */
d2428 2
a2429 2
	    CTRACE((tfp, "HTFTP: Line in %s is %s\n",
		    lastpath, chunk->data));
d2431 1
a2431 1
	    entry_info = parse_dir_entry(chunk->data, &first, &spilledname);
d2433 3
a2435 4
		FREE(spilledname);
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
d2441 1
a2441 1
	}			/* next entry */
d2443 1
a2443 1
      unload_btree:
a2445 1
	FREE(spilledname);
d2447 1
a2447 1
	/* print out the handy help message if it exists :) */
d2463 1
a2463 1
	/* PUTS("    Date        Type             Size     Filename\n");
d2469 1
a2469 9
#ifdef SH_EX			/* 1997/10/18 (Sat) 14:14:28 */
	    char *p, name_buff[256];
	    int name_len, dot_len;

#define	FNAME_WIDTH	30
#define	FILE_GAP	1

#endif
	    HTBTElement *ele;
a2470 1

d2474 1
a2474 1
		entry_info = (EntryInfo *) HTBTree_object(ele);
d2484 1
a2484 1
		    for (i = 0; entry_info->type[i] != '\0' && i < 16; i++)
d2492 2
a2493 2
#ifdef SH_EX			/* 1997/10/18 (Sat) 16:00 */
		name_len = strlen(entry_info->filename);
d2495 4
a2498 31
		sprintf(name_buff, "%-*s", FNAME_WIDTH, entry_info->filename);

		if (name_len < FNAME_WIDTH) {
		    dot_len = FNAME_WIDTH - FILE_GAP - name_len;
		    if (dot_len > 0) {
			p = name_buff + name_len + 1;
			while (dot_len-- > 0)
			    *p++ = '.';
		    }
		} else {
		    name_buff[FNAME_WIDTH] = '\0';
		}

		PUTS(name_buff);
#else
		PUTS(entry_info->filename);
#endif
		END(HTML_A);

		if (entry_info->size) {
#ifdef SH_EX			/* 1998/02/02 (Mon) 16:34:52 */
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "%6d bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "%6d Kb",
				entry_info->size / 1024);
#else
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %u bytes",
				entry_info->size);
d2500 2
a2501 3
			sprintf(string_buffer, "  %uKb",
				entry_info->size / 1024);
#endif
a2502 3
		} else if (entry_info->linkname != 0) {
		    PUTS(" -> ");
		    PUTS(entry_info->linkname);
d2505 1
a2505 1
		PUTC('\n');	/* end of this entry */
d2517 2
a2518 1
    if (WasInterrupted || data_soc != -1) {	/* should always be true */
d2520 2
a2521 4
	 * Without closing the data socket first, the response(0) later may
	 * hang.  Some servers expect the client to fin/ack the close of the
	 * data connection before proceeding with the conversation on the
	 * control connection.  - kw
d2523 1
a2523 5
	CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	status = NETCLOSE(data_soc);
	if (status == -1)
	    HTInetStatus("close");	/* Comment only */
	data_soc = -1;
d2527 2
d2530 1
d2532 2
d2535 3
d2540 14
a2553 5
/*
 * Setup an FTP connection.
 */
static int setup_connection(const char *name,
			    HTParentAnchor *anchor)
d2555 3
d2559 1
a2559 1
    int status = HT_NO_CONNECTION;
a2560 1
    CTRACE((tfp, "setup_connection(%s)\n", name));
a2566 2
    ProFTPD_bugs = FALSE;
    WU_FTPD_bugs = FALSE;
d2568 1
a2568 1
    for (retry = 0; retry < 2; retry++) {	/* For timed out/broken connections */
d2570 2
a2571 3
	if (status < 0) {
	    break;
	}
d2576 1
a2576 1
		NETCLOSE(control->socket);
d2578 1
a2578 6
#ifdef INET6
		if (master_socket >= 0)
		    (void) close_master_socket();
#else
		close_master_socket();
#endif /* INET6 */
d2581 1
a2581 1
		break;
d2583 1
d2585 2
a2586 2
	    /*  Inform the server of the port number we will listen on
	     */
d2589 3
a2591 3
		CTRACE((tfp, "HTFTP: Interrupted in response (port_command)\n"));
		_HTProgress(CONNECTION_INTERRUPTED);
		NETCLOSE(control->socket);
d2593 2
a2594 3
		close_master_socket();
		status = HT_INTERRUPTED;
		break;
d2596 1
a2596 1
	    if (status != 2) {	/* Could have timed out */
d2598 2
a2599 3
		    continue;	/* try again - net error */
		status = -status;	/* bad reply */
		break;
d2601 1
a2601 1
	    CTRACE((tfp, "HTFTP: Port defined.\n"));
d2604 3
a2606 7
	    char *command = NULL;
	    const char *p = "?";
	    int h0, h1, h2, h3, p0, p1;		/* Parts of reply */

#ifdef INET6
	    char dst[LINE_LENGTH + 1];
#endif
a2609 73
#ifdef INET6
	    /* see RFC 2428 */
	    if (WU_FTPD_bugs)
		status = 1;
	    else
		status = send_cmd_1(p = "EPSV");
	    if (status < 0)	/* retry or Bad return */
		continue;
	    else if (status != 2) {
		status = send_cmd_1(p = "PASV");
		if (status < 0) {	/* retry or Bad return */
		    continue;
		} else if (status != 2) {
		    status = -status;	/* bad reply */
		    break;
		}
	    }

	    if (strcmp(p, "PASV") == 0) {
		for (p = response_text; *p && *p != ','; p++) {
		    ;		/* null body */
		}

		while (--p > response_text && '0' <= *p && *p <= '9') {
		    ;		/* null body */
		}
		status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
				&h0, &h1, &h2, &h3, &p0, &p1);
		if (status < 4) {
		    fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = (p0 << 8) + p1;
		sprintf(dst, "%d.%d.%d.%d", h0, h1, h2, h3);
	    } else if (strcmp(p, "EPSV") == 0) {
		char c0, c1, c2, c3;
		struct sockaddr_storage ss;
		LY_SOCKLEN sslen;

		/*
		 * EPSV bla (|||port|)
		 */
		for (p = response_text; *p && !isspace(*p); p++) {
		    ;		/* null body */
		}
		for ( /*nothing */ ;
		     *p && *p && *p != '(';
		     p++)	/*) */
		    ;		/* null body */
		status = sscanf(p, "(%c%c%c%d%c)", &c0, &c1, &c2, &p0, &c3);
		if (status != 5) {
		    fprintf(tfp, "HTFTP: EPSV reply has invalid format!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = p0;

		sslen = sizeof(ss);
		if (getpeername(control->socket, (struct sockaddr *) &ss,
				&sslen) < 0) {
		    fprintf(tfp, "HTFTP: getpeername(control) failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		if (getnameinfo((struct sockaddr *) &ss, sslen, dst,
				sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
		    fprintf(tfp, "HTFTP: getnameinfo failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
	    }
#else
d2613 2
a2614 6
		    continue;	/* retry or Bad return */
		status = -status;	/* bad reply */
		break;
	    }
	    for (p = response_text; *p && *p != ','; p++) {
		;		/* null body */
d2616 2
d2619 2
a2620 3
	    while (--p > response_text && '0' <= *p && *p <= '9') {
		;		/* null body */
	    }
d2622 9
a2630 11
	    status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
			    &h0, &h1, &h2, &h3, &p0, &p1);
	    if (status < 4) {
		fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		status = HT_NO_CONNECTION;
		break;
	    }
	    passive_port = (PortNumber) ((p0 << 8) + p1);
#endif /* INET6 */
	    CTRACE((tfp, "HTFTP: Server is listening on port %d\n",
		    passive_port));
a2631 1
	    /* Open connection for data:  */
d2633 5
a2637 8
#ifdef INET6
	    HTSprintf0(&command, "%s//%s:%d/", STR_FTP_URL, dst, passive_port);
#else
	    HTSprintf0(&command, "%s//%d.%d.%d.%d:%d/",
		       STR_FTP_URL, h0, h1, h2, h3, passive_port);
#endif
	    status = HTDoConnect(command, "FTP data", passive_port, &data_soc);
	    FREE(command);
d2642 1
a2642 1
		break;
d2645 1
a2645 1
	    CTRACE((tfp, "FTP data connected, socket %d\n", data_soc));
d2648 1
a2648 25
	break;			/* No more retries */

    }				/* for retries */
    CTRACE((tfp, "setup_connection returns %d\n", status));
    return status;
}

/*	Retrieve File from Server
 *	-------------------------
 *
 * On entry,
 *	name		WWW address of a file: document, including hostname
 * On exit,
 *	returns		Socket number for file if good.
 *			<0 if bad.
 */
int HTFTPLoad(const char *name,
	      HTParentAnchor *anchor,
	      HTFormat format_out,
	      HTStream *sink)
{
    BOOL isDirectory = NO;
    HTAtom *encoding = NULL;
    int status, final_status;
    int outstanding = 1;	/* outstanding control connection responses
d2650 1
a2650 13
				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
    HTFormat format;

    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n",
	    name,
	    (ftp_local_passive
	     ? "passive"
	     : "normal")));

    HTReadProgress(0, 0);

    status = setup_connection(name, anchor);
d2654 2
a2655 2
    /*  Ask for the file:
     */
d2658 1
a2658 2
	char *fname = filename;	/* Save for subsequent free() */
	char *vmsname = NULL;
d2660 1
a2660 2
	const char *type = NULL;
	char *types = NULL;
d2664 1
a2664 1
	    /* If the unescaped path has a %2f, reject it as illegal. - FM */
d2668 1
a2668 1
		init_help_message_cache();	/* to free memory */
d2671 1
a2671 2
		CTRACE((tfp,
			"HTFTP: Rejecting path due to illegal escaped slash.\n"));
d2679 1
a2679 1
	} else if ((type = types = strrchr(filename, ';')) != NULL) {
d2681 4
a2684 4
	     * Check and trim the type= parameter.  - FM
	     */
	    if (!strncasecomp((type + 1), "type=", 5)) {
		switch (TOUPPER(*(type + 6))) {
d2686 1
a2686 1
		    *types = '\0';
d2690 1
a2690 1
		    *types = '\0';
d2694 1
a2694 1
		    *types = '\0';
d2703 1
a2703 1
		    *(filename + 1) = '\0';
d2707 1
a2707 1
		CTRACE((tfp, "HTFTP: type=%s\n", type));
d2711 1
a2711 1
	CTRACE((tfp, "HTFTP: UnEscaped %s\n", filename));
d2714 3
a2716 3
	     * Check if translation of HOME as tilde is supported,
	     * and adjust filename if so. - FM
	     */
d2720 1
a2720 1
	    if ((cp2 = strchr((filename + 1), '/')) != NULL) {
d2725 1
a2725 1
		status = send_cwd(filename + 1);
d2727 1
a2727 1
		    StrAllocCopy(fn, (filename + 1));
d2730 1
a2730 1
			if (fn[strlen(fn) - 1] != '/') {
d2733 1
a2733 1
			    StrAllocCat(fn, (cp2 + 1));
d2747 1
a2747 2

	    if (((cp2 = strrchr(filename, '.')) != NULL &&
d2751 4
a2754 4
		 * Don't treat this as application/x-Troff-me if it's a Unix
		 * server but has the string "read.me", or if it's not a Unix
		 * server.  - FM
		 */
d2771 2
a2772 2
	binary = (BOOL) (encoding != HTAtom_for("8bit") &&
			 encoding != HTAtom_for("7bit"));
d2774 7
a2780 6
	/*
	 * Force binary if we're in source, download or dump mode and this is
	 * not a VM/CMS server, so we don't get CRLF instead of LF (or CR) for
	 * newlines in text files.  Can't do this for VM/CMS or we'll get raw
	 * EBCDIC.  - FM
	 */
d2788 2
a2789 2
	     * Force binary if we had ;type=I - FM
	     */
d2793 2
a2794 2
	     * Force ASCII if we had ;type=A - FM
	     */
d2799 3
a2801 4
	     * Act on our setting if not already set.  - FM
	     */
	    const char *mode = binary ? "I" : "A";

d2804 1
a2804 1
		init_help_message_cache();	/* to free memory */
d2810 5
a2814 5
	    /*
	     * Handle what for Lynx are special case servers, e.g., for which
	     * we respect RFC 1738, or which have known conflicts in suffix
	     * mappings.  - FM
	     */
d2816 27
a2842 23
	    {
		char *cp1, *cp2;
		BOOL included_device = FALSE;
		BOOL found_tilde = FALSE;

		/* Accept only Unix-style filename */
		if (strchr(filename, ':') != NULL ||
		    strchr(filename, '[') != NULL) {
		    FREE(fname);
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    CTRACE((tfp,
			    "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
		    return -1;
		}
		/* Handle any unescaped "/%2F" path */
		if (!strncmp(filename, "//", 2)) {
		    int i;

		    included_device = TRUE;
		    for (i = 0; filename[(i + 1)]; i++)
			filename[i] = filename[(i + 1)];
d2844 9
a2852 32
		    CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		    cp = HTVMS_name("", filename);
		    CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
		    if ((cp1 = strrchr(cp, ']')) != NULL) {
			strcpy(filename, ++cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			*cp1 = '\0';
			status = send_cwd(cp);
			if (status != 2) {
			    char *dotslash = 0;

			    if ((cp1 = strchr(cp, '[')) != NULL) {
				*cp1++ = '\0';
				status = send_cwd(cp);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
				HTSprintf0(&dotslash, "[.%s", cp1);
				status = send_cwd(dotslash);
				FREE(dotslash);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
			    } else {
d2854 1
a2854 1
				init_help_message_cache();	/* to free memory */
d2859 3
a2861 10
			}
		    } else if ((cp1 = strchr(cp, ':')) != NULL &&
			       strchr(cp, '[') == NULL &&
			       strchr(cp, ']') == NULL) {
			cp1++;
			if (*cp1 != '\0') {
			    strcpy(filename, cp1);
			    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			    HTSprintf0(&vmsname, "%.*s[%s]", cp1 - cp, cp, filename);
			    status = send_cwd(vmsname);
d2863 5
a2867 16
				HTSprintf(&vmsname, "%.*s[000000]", cp1 - cp, cp);
				status = send_cwd(vmsname);
				if (status != 2) {
				    HTSprintf(&vmsname, "%.*s", cp1 - cp, cp);
				    status = send_cwd(vmsname);
				    if (status != 2) {
					FREE(fname);
					init_help_message_cache();
					NETCLOSE(control->socket);
					control->socket = -1;
					return ((status < 0) ? status : -status);
				    }
				}
			    } else {
				HTSprintf0(&vmsname, "000000");
				filename = vmsname;
d2869 6
d2876 14
a2889 1
		    } else if (0 == strcmp(cp, (filename + 1))) {
d2892 3
a2894 2
			    HTSprintf0(&vmsname, "%s:", cp);
			    status = send_cwd(vmsname);
d2896 9
a2904 5
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
d2906 3
a2909 2
			HTSprintf0(&vmsname, "000000");
			filename = vmsname;
d2911 2
a2912 9
		}
		/* Trim trailing slash if filename is not the top directory */
		if (strlen(filename) > 1 && filename[strlen(filename) - 1] == '/')
		    filename[strlen(filename) - 1] = '\0';

#ifdef MAINTAIN_CONNECTION	/* Don't need this if always new connection - F.M. */
		if (!included_device) {
		    /* Get the current default VMS device:[directory] */
		    status = send_cmd_1("PWD");
d2914 2
a2915 24
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Go to the VMS account's top directory */
		    if ((cp = strchr(response_text, '[')) != NULL &&
			(cp1 = strrchr(response_text, ']')) != NULL) {
			char *tmp = 0;
			unsigned len = 4;

			StrAllocCopy(tmp, cp);
			if ((cp2 = strchr(cp, '.')) != NULL && cp2 < cp1) {
			    len += (cp2 - cp);
			} else {
			    len += (cp1 - cp);
			}
			tmp[len] = 0;
			StrAllocCat(tmp, "]");

			status = send_cwd(tmp);
			FREE(tmp);

d2924 2
d2927 10
a2936 8
#endif /* MAINTAIN_CONNECTION */

		/* If we want the VMS account's top directory, list it now */
		if (!(strcmp(filename, "/~")) ||
		    (included_device && 0 == strcmp(filename, "000000")) ||
		    (strlen(filename) == 1 && *filename == '/')) {
		    isDirectory = YES;
		    status = send_cmd_1("LIST");
d2938 4
a2941 9
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
d2943 3
a2945 10
		/* Otherwise, go to appropriate directory and doctor filename */
		if (!strncmp(filename, "/~", 2)) {
		    filename += 2;
		    found_tilde = TRUE;
		}
		CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
		if (!included_device &&
		    (cp = strchr(filename, '/')) != NULL &&
		    (cp1 = strrchr(cp, '/')) != NULL &&
		    (cp1 - cp) > 1) {
d2947 1
d2949 8
a2956 6
		    HTSprintf0(&tmp, "[.%.*s]", cp1 - cp - 1, cp + 1);

		    CTRACE((tfp, "change path '%s'\n", tmp));
		    while ((cp2 = strrchr(tmp, '/')) != NULL)
			*cp2 = '.';
		    CTRACE((tfp, "...to  path '%s'\n", tmp));
d2963 1
a2963 1
			init_help_message_cache();	/* to free memory */
a2967 5
		    filename = cp1 + 1;
		} else {
		    if (!included_device && !found_tilde) {
			filename += 1;
		    }
a2968 1
		break;
d2970 54
d3025 15
a3039 29
	    {
		/*
		 * If we want the CMS account's top directory, or a base SFS or
		 * anonymous directory path (i.e., without a slash), list it
		 * now.  FM
		 */
		if ((strlen(filename) == 1 && *filename == '/') ||
		    ((0 == strncasecomp((filename + 1), "vmsysu:", 7)) &&
		     (cp = strchr((filename + 1), '.')) != NULL &&
		     strchr(cp, '/') == NULL) ||
		    (0 == strncasecomp(filename + 1, "anonymou.", 9) &&
		     strchr(filename + 1, '/') == NULL)) {
		    if (filename[1] != '\0') {
			status = send_cwd(filename + 1);
			if (status != 2) {
			    /* Action not started */
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		    isDirectory = YES;
		    if (use_list)
			status = send_cmd_1("LIST");
		    else
			status = send_cmd_1("NLST");
		    FREE(fname);
		    if (status != 1) {
d3041 1
a3041 1
			init_help_message_cache();	/* to free memory */
a3045 2
		    /* Big goto! */
		    goto listen;
d3047 17
a3063 1
		filename++;
d3065 18
a3082 23
		/* Otherwise, go to appropriate directory and adjust filename */
		while ((cp = strchr(filename, '/')) != NULL) {
		    *cp++ = '\0';
		    status = send_cwd(filename);
		    if (status == 2) {
			if (*cp == '\0') {
			    isDirectory = YES;
			    if (use_list)
				status = send_cmd_1("LIST");
			    else
				status = send_cmd_1("NLST");
			    FREE(fname);
			    if (status != 1) {
				/* Action not started */
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			    /* Clear any messages from the login directory */
			    init_help_message_cache();
			    /* Big goto! */
			    goto listen;
d3084 4
a3087 1
			filename = cp;
d3089 1
a3090 1
		break;
d3092 2
d3095 1
a3095 1
	    /* Shift for any unescaped "/%2F" path */
d3101 3
a3103 3
	 * Act on a file or listing request, or try to figure out which we're
	 * dealing with if we don't know yet.  - FM
	 */
a3105 17
#ifdef BROKEN_PROFTPD
	    /*
	     * ProFTPD 1.2.5rc1 gets confused when asked to RETR a directory.
	     */
	    if (status >= 5) {
		int check;

		if (ProFTPD_bugs) {
		    CTRACE((tfp, "{{reconnecting...\n"));
		    close_connection(control);
		    check = setup_connection(name, anchor);
		    CTRACE((tfp, "...done }}reconnecting\n"));
		    if (check < 0)
			return check;
		}
	    }
#endif
d3110 1
a3110 1
	    /* Clear any login messages if this isn't the login directory */
a3123 1
	FREE(vmsname);
d3135 1
a3135 1
  listen:
a3137 4
#ifdef INET6
	struct sockaddr_storage soc_address;

#else
d3139 1
a3139 3
#endif /* INET6 */
	LY_SOCKLEN soc_addrlen = sizeof(soc_address);

d3143 2
a3144 2
			     (struct sockaddr *) &soc_address,
			     &soc_addrlen);
d3147 3
a3149 3
	    status = accept(master_socket,
			    (struct sockaddr *) &soc_address,
			    &soc_addrlen);
d3154 1
a3154 1
	CTRACE((tfp, "TCP: Accepted new socket %d\n", status));
d3156 1
a3156 6
    }
    /* !ftp_local_passive */
#if 0				/* no - this makes the data connection go away too soon (2.8.3dev.22) */
    if ((status = send_cmd_nowait("QUIT")) == 1)
	outstanding++;
#endif
d3159 7
a3165 29
	if (server_type == UNIX_SERVER && !unsure_type &&
	    !strcmp(response_text,
		    "150 Opening ASCII mode data connection for /bin/dl.\n")) {
	    CTRACE((tfp, "HTFTP: Treating as \"dls\" server.\n"));
	    server_type = DLS_SERVER;
	}
	final_status = read_directory(anchor, name, format_out, sink);
	if (final_status > 0) {
	    if (server_type != CMS_SERVER)
		if (outstanding-- > 0) {
		    status = response(0);
		    if (status < 0 ||
			(status == 2 && !strncmp(response_text, "221", 3)))
			outstanding = 0;
		}
	} else {		/* HT_INTERRUPTED */
	    /* User may have pressed 'z' to give up because no
	       packets got through, so let's not make them wait
	       any longer - kw */
	    outstanding = 0;
	}

	if (data_soc != -1) {	/* normally done in read_directory */
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	    if (status == -1)
		HTInetStatus("close");	/* Comment only */
	}
	status = final_status;
d3168 1
d3171 1
a3171 1
	/* Clear any login messages */
d3174 1
a3174 1
	/* Fake a Content-Encoding for compressed files. - FM */
d3178 3
a3180 2
	     * We already know from the call to HTFileFormat above that this is
	     * a compressed file, no need to look at the filename again.  - kw
d3186 5
a3190 3
	} else {
	    int rootlen;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &rootlen);
d3192 1
a3192 2
	    if (cft != cftNone) {
		FileName[rootlen] = '\0';
d3196 1
d3198 9
a3206 6

		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    break;
		case cftGzip:
d3208 1
a3208 9
		    break;
		case cftDeflate:
		    StrAllocCopy(anchor->content_encoding, "x-deflate");
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    break;
		case cftNone:
		    break;
d3214 1
a3214 1
	_HTProgress(gettext("Receiving FTP file."));
d3217 3
d3223 2
a3224 20
	if (rv < 0) {
#if 0				/* any known servers where ABOR would work this way? */
	    if (rv == HT_INTERRUPTED || rv == -501)
		if (send_cmd_nowait("ABOR") == 1) {
		    outstanding++;
		    CTRACE((tfp, "HTFTP: outstanding responses: %d\n", outstanding));
		}
#endif
	    if (rv == -2)	/* weird error, don't expect much response */
		outstanding--;
	    else if (rv == HT_INTERRUPTED || rv == -1)
		/* User may have pressed 'z' to give up because no
		   packets got through, so let's not make them wait
		   longer - kw */
		outstanding = 0;
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	} else
	    status = 2;		/* data_soc already closed in HTCopy - kw */

d3227 1
d3229 5
a3233 10
	    if (rv != HT_LOADED && outstanding--) {
		status = response(0);	/* Pick up final reply */
		if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		    data_soc = -1;	/* invalidate it */
		    init_help_message_cache();	/* to free memory */
		    return HTLoadError(sink, 500, response_text);
		} else if (status <= 0) {
		    outstanding = 0;
		} else if (status == 2 && !strncmp(response_text, "221", 3))
		    outstanding = 0;
d3236 5
a3240 7
	final_status = HT_LOADED;
    }
    while (outstanding-- > 0 &&
	   (status > 0)) {
	status = response(0);
	if (status == 2 && !strncmp(response_text, "221", 3))
	    break;
d3242 1
a3242 15
    data_soc = -1;		/* invalidate it */
    CTRACE((tfp, "HTFTPLoad: normal end; "));
    if (control->socket < 0) {
	CTRACE((tfp, "control socket is %d\n", control->socket));
    } else {
	CTRACE((tfp, "closing control socket %d\n", control->socket));
	status = NETCLOSE(control->socket);
	if (status == -1)
	    HTInetStatus("control connection close");	/* Comment only */
    }
    control->socket = -1;
    init_help_message_cache();	/* to free memory */
    /* returns HT_LOADED (always for file if we get here) or error */
    return final_status;
}				/* open_file_read */
d3245 4
a3248 4
 *  This function frees any user entered password, so that
 *  it must be entered again for a future request. - FM
 */
void HTClearFTPPassword(void)
d3251 5
a3255 4
     * Need code to check cached documents from non-anonymous ftp accounts and
     * do something to ensure that they no longer can be accessed without a new
     * retrieval.  - FM
     */
d3258 3
a3260 2
     * Now free the current user entered password, if any.  - FM
     */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d60 4
d69 3
a71 3
#include <HTTCP.h>
#include <HTTP.h>
#include <HTFont.h>
d83 3
d88 1
d109 4
d137 5
d153 14
a166 18
typedef enum {
	GENERIC_SERVER
	, MACHTEN_SERVER
	, UNIX_SERVER
	, VMS_SERVER
	, CMS_SERVER
	, DCTS_SERVER
	, TCPC_SERVER
	, PETER_LEWIS_SERVER
	, NCSA_SERVER
	, WINDOWS_NT_SERVER
	, WINDOWS_2K_SERVER
	, MS_WINDOWS_SERVER
	, MSDOS_SERVER
	, APPLESHARE_SERVER
	, NETPRESENZ_SERVER
	, DLS_SERVER
} eServerType;
d168 1
a168 1
PRIVATE eServerType server_type = GENERIC_SERVER; /* the type of ftp host */
d175 1
a175 1
PRIVATE PortNumber	port_number = FIRST_TCP_PORT;
d182 1
a182 1
PRIVATE PortNumber	passive_port;	/* Port server specified for data */
d212 1
a212 1
/* PUBLIC						HTVMS_name()
d223 1
a223 1
PUBLIC char * HTVMS_name ARGS2(
d235 1
a235 1
    static char *vmsname;
d268 1
a268 1
	HTSprintf0(&vmsname, "%s%s", nodename, filename + 1);
d271 1
a271 1
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename+1, second+1);
d277 1
a277 1
	HTSprintf0(&vmsname, "%s%s:[%s]%s",
d310 1
a310 1
    return UCH(*data_read_pointer++);
d322 3
a324 4
    int status;
    CTRACE((tfp, "HTFTP: Closing control socket %d\n", con->socket));
    status = NETCLOSE(con->socket);
    if (TRACE && status != 0) {
d326 2
a327 4
	CTRACE((tfp, "HTFTP:close_connection: %s", LYStrerror(errno)));
#else
	if (con->socket != INVSOC)
	    HTInetStatus("HTFTP:close_connection");
d361 1
a361 1
    CTRACE((tfp,"Adding message to help cache: %s\n",string));
a367 1

d373 2
a374 2
/*	Send One Command
**	----------------
d376 7
a382 2
**	This function checks whether we have a control connection, and sends
**	one command if given.
d385 2
a386 2
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
d388 1
a388 1
**	The command should already be terminated with the CRLF pair.
d391 2
a392 3
**	returns:  1 for success,
**		  or negative for communication failure (in which case
**		  the control connection will be closed).
d394 1
a394 1
PRIVATE int write_cmd ARGS1(
d397 2
d402 1
a402 1
	CTRACE((tfp, "HTFTP: No control connection set up!!\n"));
d407 1
a407 1
	CTRACE((tfp, "  Tx: %s", cmd));
d418 2
a419 2
	    CTRACE((tfp, "HTFTP: Error %d sending command: closing socket %d\n",
			status, control->socket));
a423 33
    return 1;
}

/*	Execute Command and get Response
**	--------------------------------
**
**	See the state machine illustrated in RFC959, p57. This implements
**	one command/reply sequence.  It also interprets lines which are to
**	be continued, which are marked with a "-" immediately after the
**	status code.
**
**	Continuation then goes on until a line with a matching reply code
**	an a space after it.
**
** On entry,
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
**
**	The command must already be terminated with the CRLF pair.
**
** On exit,
**	returns:  The first digit of the reply type,
**		  or negative for communication failure.
*/
PRIVATE int response ARGS1(
	char *,		cmd)
{
    int result;				/* Three-digit decimal code */
    int continuation_response = -1;
    int status;

    if ((status = write_cmd(cmd)) < 0)
	return status;
d429 1
a429 1
	    if (((*p++ = (char) ich) == LF)
d435 1
a435 1
		    CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
d442 1
a442 1
		CTRACE((tfp, "    Rx: %s", response_text));
d463 1
a463 1
		CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
d470 2
a471 2
		CTRACE((tfp, "Error on rx: closing socket %d\n",
			    control->socket));
d481 2
a482 2
	CTRACE((tfp, "HTFTP: They close so we close socket %d\n",
		    control->socket));
d524 1
a524 1
	eServerType,	ServerType)
d543 1
a543 1
	eServerType *,	ServerType,
d559 1
a559 1
	    CTRACE((tfp, "HTFTP: Treating as %s server.\n",
d561 1
a561 1
						 "NCSA" : "TCPC")));
d568 1
a568 1
		CTRACE((tfp, "HTFTP: Treating as NCSA server.\n"));
d572 1
a572 1
		 CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d579 1
a579 1
	    CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
d582 1
a582 1
	    CTRACE((tfp, "HTFTP: Treating as Generic server.\n"));
a592 39
/* This function turns MSDOS-like directory output off for
 * Windows NT servers.
 */

PRIVATE void set_unix_dirstyle ARGS2(
	eServerType *,	ServerType,
	BOOLEAN *,	UseList)
{

    char *cp;
    /* This is a toggle.  It seems we have to toggle in order to see
     * the current state (after toggling), so we may end up toggling
     * twice.  - kw
     */
    int status = response("SITE DIRSTYLE\r\n");
    if (status != 2) {
	*ServerType = GENERIC_SERVER;
	CTRACE((tfp, "HTFTP: DIRSTYLE failed, treating as Generic server.\n"));
	return;
    } else {
	*UseList = TRUE;
	/* Expecting one of:
	 * 200 MSDOS-like directory output is off
	 * 200 MSDOS-like directory output is on
	 * The following code doesn't look for the full exact string -
	 * who knows how the wording may change in some future version.
	 * If the first response isn't recognized, we toggle again
	 * anyway, under the assumption that it's more likely that
	 * the MSDOS setting was "off" originally. - kw
	 */
	cp = strstr(response_text+4, "MSDOS");
	if (cp && strstr(cp, " off")) {
	    return;		/* already off now. */
	} else {
	    response("SITE DIRSTYLE\r\n");
	}
    }
}

d643 1
a643 1
	con = typecalloc(connection);
a653 1
    CTRACE((tfp, "get_connection(%s)\n", arg));
d710 1
a710 1
	    CTRACE((tfp, "HTFTP: Interrupted on connect\n"));
d712 2
a713 2
	    CTRACE((tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
			arg));
d733 2
a734 2
    CTRACE((tfp, "FTP connected, socket %d  control %p\n",
		con->socket, con));
d747 1
a747 1
	CTRACE((tfp, "HTFTP: Interrupted at beginning of login.\n"));
d776 1
a776 1
	    CTRACE((tfp, "HTFTP: Interrupted while sending username.\n"));
d813 1
a813 1
		if ((cp=LYGetEnv("USER")) != NULL)
d833 2
a834 1
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
d846 1
a846 1
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
d855 1
a855 1
	CTRACE((tfp, "HTFTP: Login fail: %s", response_text));
d859 1
a859 1
    CTRACE((tfp, "HTFTP: Logged in.\n"));
d871 1
a871 1
	    CTRACE((tfp, "HTFTP: Treating as MachTen server.\n"));
a875 1
	    unsure_type = FALSE; /* to the best of out knowledge... */
d877 1
a877 1
	    CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d882 1
a882 1
	    CTRACE((tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n"));
d885 1
a885 1
	    char *tilde = strstr(arg, "/~");
d887 1
a887 9
	    if (tilde != 0
	     && tilde[2] != 0
	     && strstr(response_text+4, "MadGoat") != 0) {
		server_type = UNIX_SERVER;
		CTRACE((tfp, "HTFTP: Treating VMS as UNIX server.\n"));
	    } else {
		server_type = VMS_SERVER;
		CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	    }
d893 1
a893 1
	    CTRACE((tfp, "HTFTP: Treating as CMS server.\n"));
d897 1
a897 1
	    CTRACE((tfp, "HTFTP: Treating as DCTS server.\n"));
d901 1
a901 1
	    CTRACE((tfp, "HTFTP: Looks like a TCPC server.\n"));
d908 1
a908 1
	    CTRACE((tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n"));
d914 1
a914 1
	    CTRACE((tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n"));
d918 2
a919 7
	    CTRACE((tfp, "HTFTP: Treating as Window_NT server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (strncmp(response_text+4, "Windows2000", 11) == 0) {
	    server_type = WINDOWS_2K_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_2K server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);
d924 1
a924 1
	    CTRACE((tfp, "HTFTP: Treating as MS Windows server.\n"));
d931 1
a931 1
	    CTRACE((tfp, "HTFTP: Treating as AppleShare server.\n"));
d935 1
a935 1
	    CTRACE((tfp, "HTFTP: Ugh!  A Generic server.\n"));
d954 1
a954 1
	CTRACE((tfp, "HTFTP: Port defined.\n"));
d973 1
a973 1
    CTRACE((tfp, "HTFTP: Closed master socket %d\n", master_socket));
a997 6
#ifdef INET6
    struct sockaddr_storage soc_address;	/* Binary network address */
    struct sockaddr_in* soc_in = (struct sockaddr_in *)&soc_address;
    int af;
    int slen;
#else
a999 1
#endif /* INET6 */
a1010 11
#ifdef INET6
    /* query address family of control connection */
    slen = sizeof(soc_address);
    if (getsockname(control->socket, (struct sockaddr *)&soc_address,
		&slen) < 0) {
	return HTInetStatus("getsockname failed");
    }
    af = ((struct sockaddr *)&soc_address)->sa_family;
    memset(&soc_address, 0, sizeof(soc_address));
#endif /* INET6 */

a1012 3
#ifdef INET6
    new_socket = socket(af, SOCK_STREAM, IPPROTO_TCP);
#else
a1013 1
#endif /* INET6 */
d1018 1
a1018 1
    CTRACE((tfp, "HTFTP: Opened master socket number %d\n", new_socket));
a1021 18
#ifdef INET6
    memset(&soc_address, 0, sizeof(soc_address));
    ((struct sockaddr *)&soc_address)->sa_family = af;
    switch (af) {
    case AF_INET:
#ifdef SIN6_LEN
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in);
#endif /* SIN6_LEN */
	break;
    case AF_INET6:
#ifdef SIN6_LEN
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in6);
#endif /* SIN6_LEN */
	break;
    default:
	HTInetStatus("AF");
    }
#else
a1023 1
#endif /* INET6 */
d1026 1
a1026 1
	PortNumber old_port_number = port_number;
a1033 3
#ifdef INET6
	    soc_in->sin_port = htons(port_number);
#else
a1034 1
#endif /* INET6 */
d1040 1
a1040 1
			SOCKADDR_LEN(soc_address)
d1044 1
a1044 1
						)) == 0) {
d1046 1
a1046 1
		} else
d1051 1
a1051 2
		    SOCKADDR_LEN(soc_address)
		    )) == 0) {
d1053 2
a1054 3
	    }
	    CTRACE((tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		port_number, status, SOCKET_ERRNO));
d1072 2
a1073 8
#ifdef INET6
	CTRACE((tfp, "HTFTP: This host is %s\n",
	    HTInetString((SockA *)soc_in)));

	soc_in->sin_port = 0;	/* Unspecified: please allocate */
#else
	CTRACE((tfp, "HTFTP: This host is %s\n",
	    HTInetString(soc_in)));
a1075 1
#endif /* INET6 */
a1082 3
#ifdef INET6
			socks_bind_remoteAddr
#else
a1083 1
#endif /* INET6 */
d1091 1
a1091 2
		    SOCKADDR_LEN(soc_address)
		    );
d1109 1
a1109 2
#ifdef INET6
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
d1111 1
a1111 6
		HTInetString((SockA *)soc_in)));
#else
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
		(int)ntohs(soc_in->sin_port),
		HTInetString(soc_in)));
#endif /* INET6 */
d1116 1
a1116 1
#endif /* REPEAT_LISTEN */
d1123 1
a1123 5
#ifdef INET6
    switch (((struct sockaddr *)&soc_address)->sa_family) {
    case AF_INET:
#endif /* INET6 */
	sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
a1131 2
#ifdef INET6
	break;
d1133 4
a1136 22
    case AF_INET6:
      {
	char hostbuf[MAXHOSTNAMELEN];
	char portbuf[MAXHOSTNAMELEN];
	getnameinfo((struct sockaddr *)&soc_address,
	    SOCKADDR_LEN(soc_address),
	    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
	    NI_NUMERICHOST | NI_NUMERICSERV);
	sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		CR, LF);
	break;
      }
    default:
	sprintf(port_command, "JUNK%c%c", CR, LF);
	break;
    }
#endif /* INET6 */

    /*	Inform TCP that we will accept connections
    */
    {
	int status;
d1138 3
a1140 3
	if (socks_flag)
	    status = Rlisten(master_socket, 1);
	else
d1142 4
a1145 5
	    status = listen(master_socket, 1);
	if (status < 0) {
	    master_socket = -1;
	    return HTInetStatus("listen");
	}
d1147 2
a1148 1
    CTRACE((tfp, "TCP: Master socket(), bind() and listen() all OK\n"));
d1184 1
d1192 2
a1193 1
    sprintf(date, "9999%02d%.2s", i, day);
d1232 1
a1232 1
    if (!isalpha(UCH(*s++)) || !isalpha(UCH(*s++)) || !isalpha(UCH(*s++)))
d1243 1
a1243 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
d1250 1
a1250 1
    if (!isdigit(UCH(*s++)))
d1258 1
a1258 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
d1265 1
a1265 1
    if (!isdigit(UCH(*s++)))
d1269 1
a1269 1
    if (!(*s == ':' || isdigit(UCH(*s)))) {
d1276 1
a1276 1
    if (!isdigit(UCH(*s++)))
d1280 1
a1280 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
a1338 1
		/* FALLTHRU */
d1357 1
a1357 1
    int    i, j;
d1362 1
a1362 1
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i-12])); i--)
d1378 1
a1378 1
    while (isdigit(UCH(line[j]))) {
a1387 105
 * parse_dls_line() --
 *	Extract the name and size info and whether it refers to a
 *      directory from a LIST line in "dls" format.
 */
PRIVATE void parse_dls_line ARGS3(
	char *,		line,
	EntryInfo *,	entry_info,
	char **,	pspilledname)
{
    short  j;
    int    base=1;
    int    size_num=0;
    int    len;
    char *cps = NULL;

    /* README		   763	Information about this server\0
       bin/		     -	\0
       etc/		     =	\0
       ls-lR		     0	\0
       ls-lR.Z		     3	\0
       pub/		     =	Public area\0
       usr/		     -	\0
       morgan		    14	-> ../real/morgan\0
       TIMIT.mostlikely.Z\0
			 79215	\0
	*/

    len = strlen(line);
    if (len == 0) {
	FREE(*pspilledname);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(line);
    if (*cps == '\0') {		/* only a filename, save it and return. */
	StrAllocCopy(*pspilledname, line);
	entry_info->display = FALSE;
	return;
    }
    if (len < 24 || line[23] != ' ' ||
	(isspace(UCH(line[0])) && !*pspilledname)) {
	/* this isn't the expected "dls" format! */
	if (!isspace(UCH(line[0])))
	    *cps = '\0';
	if (*pspilledname && !*line) {
	    entry_info->filename = *pspilledname;
	    *pspilledname = NULL;
	    if (entry_info->filename[strlen(entry_info->filename)-1] == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	} else {
	    StrAllocCopy(entry_info->filename, line);
	    if (cps && cps != line && *(cps-1) == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	    FREE(*pspilledname);
	}
	return;
    }

    j = 22;
    if (line[j] == '=' || line[j] == '-') {
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    } else {
	while (isdigit(UCH(line[j]))) {
	    size_num += (line[j] - '0') * base;
	    base *= 10;
	    j--;
	}
    }
    entry_info->size = size_num;

    cps = LYSkipBlanks(&line[23]);
    if (!strncmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
	StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
	entry_info->size = 0;	/* don't display size */
    }

    if (j > 0)
	line[j] = '\0';

    LYTrimTrailing(line);

    len = strlen(line);
    if (len == 0 && *pspilledname && **pspilledname) {
	line = *pspilledname;
	len = strlen(*pspilledname);
    }
    if (len > 0 && line[len-1] == '/') {
		/*
		**  It's a dir, remove / and mark it as such.
		*/
	if (len > 1)
	    line[len-1] = '\0';
	if (!entry_info->type)
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    }

    StrAllocCopy(entry_info->filename, line);
    FREE(*pspilledname);
} /* parse_dls_line() */

/*
d1460 2
a1461 2
	strlen(cpd) > 9 && isdigit(UCH(*(cpd-1))) &&
	isalpha(UCH(*(cpd+1))) && *(cpd+4) == '-') {
d1464 5
a1468 3
	*(cpd+2) = (char) TOLOWER(*(cpd+2));
	*(cpd+3) = (char) TOLOWER(*(cpd+3));
	sprintf(date, "%.3s ", cpd+1);
d1471 3
a1473 2
	if (isdigit(UCH(*(cpd-2))))
	    sprintf(date+4, "%.2s ", cpd-2);
d1475 2
a1476 1
	    sprintf(date+4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd-1);
d1481 3
a1483 1
	    sprintf(date+7, "%.5s", cpd+10);
d1485 3
a1487 1
	    sprintf(date+7, " %.4s", cpd+5);
d1497 1
a1497 1
	while (isdigit(UCH(*(cps-1))))
d1503 1
a1503 1
	while (isdigit(UCH(*cps)))
d1516 1
a1516 1
	    while (isdigit(UCH(*cpd)))
d1527 1
a1527 1
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %d\n",
d1529 2
a1530 2
		NonNull(entry_info->date),
		entry_info->size));
d1565 1
a1565 1
	if (isdigit(UCH(*cps))) {
d1588 1
a1588 1
		sprintf(date, "%.6s  %.4s", cpd, (cpd+7));
d1591 1
a1591 1
		sprintf(date, "%.6s %.5s", cpd, (cpd+12));
d1600 1
a1600 1
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %d\n",
d1602 2
a1603 2
		NonNull(entry_info->date),
		entry_info->size));
d1669 1
a1669 1
	sprintf(date, "%.3s %.2s", months[i], (cp+3));
d1676 1
a1676 1
		sprintf(&date[6], "  20%.2s", cp);
d1678 1
a1678 1
		sprintf(&date[6], "  19%.2s", cp);
d1686 3
a1688 1
	    sprintf(&date[6], " %02d:%.2s", i, (cpd+3));
d1711 1
a1711 1
    CTRACE((tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
d1713 2
a1714 2
		NonNull(entry_info->date),
		entry_info->size));
d1785 1
a1785 1
	if (isdigit(UCH(*cp))) {
d1796 1
a1796 1
	if (isdigit(UCH(*cp))) {
d1815 1
a1815 1
	 isdigit(UCH(*(cps+1))) && isdigit(UCH(*(cps+2))) && *(cps+3) == ':')) {
d1827 1
a1827 1
	    sprintf(date, "%.3s %.2s", months[i], (cpd+3));
d1834 1
a1834 1
		    sprintf(&date[6], "  20%.2s", cpd);
d1836 1
a1836 1
		    sprintf(&date[6], "  19%.2s", cpd);
d1842 2
a1843 1
		sprintf(&date[6], " %02d:%.2s", i, (cps+3));
d1853 1
a1853 1
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %d\n",
d1855 2
a1856 2
		NonNull(entry_info->date),
		entry_info->size));
d1868 1
a1868 1
PRIVATE EntryInfo * parse_dir_entry ARGS3(
d1870 1
a1870 2
	BOOLEAN *,	first,
	char **,	pspilledname)
a1887 45
	case DLS_SERVER:

	    /*
	    **	Interpret and edit LIST output from a Unix server
	    **  in "dls" format.
	    **  This one must have claimed to be Unix in order to
	    **  get here; if the first line looks fishy, we revert
	    **  to Unix and hope that fits better (this recovery is
	    **  untested). - kw
	    */

	    if (*first) {
		len = strlen(entry);
		if (!len || entry[0] == ' ' ||
		    (len >= 24 && entry[23] != ' ') ||
		    (len < 24 && strchr(entry, ' '))) {
		    server_type = UNIX_SERVER;
		    CTRACE((tfp,
			   "HTFTP: Falling back to treating as Unix server.\n"));
		} else {
		    *first = FALSE;
		}
	    }

	    if (server_type == DLS_SERVER) {
		/* if still unchanged... */
		parse_dls_line(entry, entry_info, pspilledname);

		if (!entry_info->filename || *entry_info->filename == '\0') {
		    entry_info->display = FALSE;
		    return(entry_info);
		}
		if (!strcmp(entry_info->filename,"..") ||
		    !strcmp(entry_info->filename,"."))
		    entry_info->display = FALSE;
		if (entry_info->type && *entry_info->type == '\0') {
		    FREE(entry_info->type);
		    return(entry_info);
		}
		/*
		**	Goto the bottom and get real type.
		*/
		break;
	    } /* fall through if server_type changed for *first == TRUE ! */

a1892 1
	case WINDOWS_2K_SERVER:
d1951 1
a1951 1
				  (!isspace(UCH(entry[i])) ||
d2206 1
a2206 1
		sprintf(month, "%02d", i);
d2213 1
a2213 5
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
d2219 9
a2227 5
		if (entry2->date[9] == ':') {
		    strcpy(date2, "9999");
		    strcpy(time2, &entry2->date[7]);
		    if (time2[0] == ' ') {
			time2[0] = '0';
a2228 4
		} else {
		    strcpy(date2, &entry2->date[8]);
		    strcpy(time2, "00:00");
		}
d2237 1
a2237 1
		sprintf(month, "%02d", i);
d2244 1
a2244 5
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
a2299 7
     *  Force the current Date and Year (TheDate, ThisYear, and LastYear)
     *  to be recalculated for each directory request.  Otherwise we have
     *  a problem with long-running sessions assuming the wrong date for
     *  today. - kw
     */
    HaveYears = FALSE;
    /*
d2313 1
a2313 1
    need_parent_link = HTDirTitles(target, parent, tildeIsTop);
d2341 1
a2348 1
	char *spilledname = NULL;
a2353 3
		CTRACE((tfp,
		       "read_directory: interrupted after %d bytes\n",
		       BytesReceived));
a2359 1
		    FREE(spilledname);
a2365 1
	    interrupted_in_next_data_char = FALSE;
a2369 3
		    CTRACE((tfp,
			   "read_directory: interrupted_in_next_data_char after %d bytes\n",
			   BytesReceived));
a2375 1
			FREE(spilledname);
a2419 4
#ifdef _WINDOWS
		sprintf(NumBytes,gettext("Transferred %d bytes (%5d)"),
				BytesReceived, ws_read_per_sec);
#else
a2420 1
#endif
d2428 2
a2429 2
	    CTRACE((tfp, "HTFTP: Line in %s is %s\n",
			lastpath, chunk->data));
d2431 1
a2431 1
	    entry_info = parse_dir_entry(chunk->data, &first, &spilledname);
d2433 3
a2435 4
		FREE(spilledname);
		CTRACE((tfp, "Adding file to BTree: %s\n",
			    entry_info->filename));
		HTBTree_add(bt, entry_info);
a2445 1
	FREE(spilledname);
a2468 8
#ifdef SH_EX	/* 1997/10/18 (Sat) 14:14:28 */
	    char *p, name_buff[256];
	    int  name_len, dot_len;

#define	FNAME_WIDTH	30
#define	FILE_GAP	2

#endif
d2484 1
a2484 1
		    for (i = 0; entry_info->type[i] != '\0' && i < 16; i++)
a2491 18
#ifdef SH_EX	/* 1997/10/18 (Sat) 16:00 */
		name_len = strlen(entry_info->filename);

		sprintf(name_buff, "%-30s", entry_info->filename);

		if (name_len < FNAME_WIDTH) {
		    dot_len = FNAME_WIDTH - FILE_GAP - name_len;
		    if (dot_len > 0) {
			p = name_buff + name_len + 1;
			while (dot_len--)
			    *p++ = '.';
		    }
		} else {
		    name_buff[FNAME_WIDTH] = '\0';
		}

		PUTS(name_buff);
#else
a2492 1
#endif
a2495 8
#ifdef SH_EX	/* 1998/02/02 (Mon) 16:34:52 */
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "%6d bytes",
					       entry_info->size);
		    else
			sprintf(string_buffer, "%6d Kb",
						entry_info->size/1024);
#else
a2501 1
#endif
d2517 2
a2518 1
    if (WasInterrupted || data_soc != -1) { /* should always be true */
d2521 1
a2521 4
	 *  the response(0) later may hang.
	 *  Some servers expect the client to fin/ack the close
	 *  of the data connection before proceeding with the
	 *  conversation on the control connection. - kw
d2523 1
a2523 5
	CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	status = NETCLOSE(data_soc);
	if (status == -1)
	    HTInetStatus("close");	/* Comment only */
	data_soc = -1;
d2527 2
d2530 1
d2532 2
d2535 3
d2557 1
a2557 1
    int status, final_status;
a2558 3
    int outstanding = 1;	/* outstanding control connection responses
				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
a2560 1
    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n", name, ftp_passive ? "passive" : "normal"));
a2566 1
    HTReadProgress(0,0);
d2573 1
a2573 1
	if (!ftp_passive) {
a2577 4
#ifdef INET6
		if (master_socket >= 0)
		    (void)close_master_socket ();
#else
a2578 1
#endif /* INET6 */
d2585 1
a2585 1
	    /*	Inform the server of the port number we will listen on
d2589 1
a2589 1
		CTRACE((tfp, "HTFTP: Interrupted in response (port_command)\n"));
d2601 1
a2601 1
	    CTRACE((tfp, "HTFTP: Port defined.\n"));
d2604 1
a2604 1
	    char *command = NULL;
d2606 1
a2606 4
	    int h0, h1, h2, h3, p0, p1;	/* Parts of reply */
#ifdef INET6
	    char dst[LINE_LENGTH+1];
#endif
a2609 59
#ifdef INET6
	    status = send_cmd_1(p = "EPSV");
	    if (status < 0)	/* retry or Bad return */
		continue;
	    else if (status != 2) {
		status = send_cmd_1(p = "PASV");
		if (status < 0)	/* retry or Bad return */
		    continue;
		else if (status != 2) {
		    return -status;	/* bad reply */
		}
	    }

	    if (strcmp(p, "PASV") == 0) {
		for (p = response_text; *p && *p != ','; p++)
		    ; /* null body */

		while (--p > response_text && '0' <= *p && *p <= '9')
		    ; /* null body */
		status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
		       &h0, &h1, &h2, &h3, &p0, &p1);
		if (status < 4) {
		    fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		    return -99;
		}
		passive_port = (p0<<8) + p1;
		sprintf(dst, "%d.%d.%d.%d", h0, h1, h2, h3);
	    } else if (strcmp(p, "EPSV") == 0) {
		unsigned char c0, c1, c2, c3;
		struct sockaddr_storage ss;
		int sslen;

		/*
		 * EPSV bla (|||port|)
		 */
		for (p = response_text; *p && !isspace(*p); p++)
		    ; /* null body */
		for (/*nothing*/; *p && *p && *p != '('; p++)	/*)*/
		    ; /* null body */
		status = sscanf(p, "(%c%c%c%d%c)", &c0, &c1, &c2, &p0, &c3);
		if (status != 5) {
		    fprintf(tfp, "HTFTP: EPSV reply has invalid format!\n");
		    return -99;
		}
		passive_port = p0;

		sslen = sizeof(ss);
		if (getpeername(control->socket, (struct sockaddr *)&ss,
		    &sslen) < 0) {
		    fprintf(tfp, "HTFTP: getpeername(control) failed\n");
		    return -99;
		}
		if (getnameinfo((struct sockaddr *)&ss, sslen, dst,
		    sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
		    fprintf(tfp, "HTFTP: getnameinfo failed\n");
		    return -99;
		}
	    }
#else
d2622 16
a2637 21
	    status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
			    &h0, &h1, &h2, &h3, &p0, &p1);
	    if (status < 4) {
		fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		return -99;
	    }
	    passive_port = (PortNumber)((p0<<8) + p1);
#endif /* INET6 */
	    CTRACE((tfp, "HTFTP: Server is listening on port %d\n",
			 passive_port));

	    /* Open connection for data:  */

#ifdef INET6
	    HTSprintf0(&command, "%s//%s:%d/", STR_FTP_URL, dst, passive_port);
#else
	    HTSprintf0(&command, "%s//%d.%d.%d.%d:%d/",
		    STR_FTP_URL, h0, h1, h2, h3, passive_port);
#endif
	    status = HTDoConnect(command, "FTP data", passive_port, &data_soc);
	    FREE(command);
d2645 1
a2645 1
	    CTRACE((tfp, "FTP data connected, socket %d\n", data_soc));
a2658 1
	char *vmsname = NULL;
d2671 1
a2671 1
		CTRACE((tfp, "HTFTP: Rejecting path due to illegal escaped slash.\n"));
d2707 1
a2707 1
		CTRACE((tfp, "HTFTP: type=%s\n", type));
d2711 1
a2711 1
	CTRACE((tfp, "HTFTP: UnEscaped %s\n", filename));
d2771 1
a2771 1
	binary = (BOOL) (encoding != HTAtom_for("8bit") &&
a2818 1
	    BOOL found_tilde = FALSE;
d2826 1
a2826 1
		CTRACE((tfp, "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
d2836 3
a2838 3
		CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		cp = HTVMS_name("", filename);
		CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
d2840 5
a2844 2
		    strcpy(filename, ++cp1);
		    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
d2882 9
a2890 4
			strcpy(filename, cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			HTSprintf0(&vmsname, "%.*s[%s]", cp1-cp, cp, filename);
			status = send_cwd(vmsname);
d2892 3
a2894 2
			    HTSprintf(&vmsname, "%.*s[000000]", cp1-cp, cp);
			    status = send_cwd(vmsname);
d2896 2
a2897 2
				HTSprintf(&vmsname, "%.*s", cp1-cp, cp);
				status = send_cwd(vmsname);
d2907 2
a2908 2
			    HTSprintf0(&vmsname, "000000");
			    filename = vmsname;
d2914 2
a2915 2
			HTSprintf0(&vmsname, "%s:", cp);
			status = send_cwd(vmsname);
d2924 2
a2925 2
		    HTSprintf0(&vmsname, "000000");
		    filename = vmsname;
d2990 1
a2990 1
	    if (!strncmp(filename, "/~", 2)) {
d2992 1
a2992 3
		found_tilde = TRUE;
	    }
	    CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
d3001 1
a3001 1
		CTRACE((tfp, "change path '%s'\n", tmp));
d3004 1
a3004 1
		CTRACE((tfp, "...to  path '%s'\n", tmp));
d3018 1
a3018 1
		if (!included_device && !found_tilde) {
a3123 1
	FREE(vmsname);
d3136 1
a3136 1
    if(!ftp_passive) {
a3137 3
#ifdef INET6
	struct sockaddr_storage soc_address;
#else
a3138 1
#endif /* INET6 */
d3154 1
a3154 1
	CTRACE((tfp, "TCP: Accepted new socket %d\n", status));
d3156 1
a3156 6
    } /* !ftp_passive */

#if 0	/* no - this makes the data connection go away too soon (2.8.3dev.22) */
    if ((status = send_cmd_nowait("QUIT")) == 1)
	outstanding++;
#endif
d3159 7
a3165 29
	if (server_type == UNIX_SERVER && !unsure_type &&
	    !strcmp(response_text,
		    "150 Opening ASCII mode data connection for /bin/dl.\n")) {
	    CTRACE((tfp, "HTFTP: Treating as \"dls\" server.\n"));
	    server_type = DLS_SERVER;
	}
	final_status = read_directory (anchor, name, format_out, sink);
	if (final_status > 0) {
	    if (server_type != CMS_SERVER)
		if (outstanding-- > 0) {
		    status = response(0);
		    if (status < 0 ||
			(status == 2 && !strncmp(response_text, "221", 3)))
			outstanding = 0;
		}
	} else {		/* HT_INTERRUPTED */
	    /* User may have pressed 'z' to give up because no
	       packets got through, so let's not make them wait
	       any longer - kw */
	    outstanding = 0;
	}

	if (data_soc != -1) { /* normally done in read_directory */
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	    if (status == -1)
		HTInetStatus("close");	/* Comment only */
	}
	status = final_status;
d3168 1
d3186 5
a3190 3
	} else {
	    char *dot;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &dot);
d3192 1
a3192 2
	    if (cft != cftNone) {
		*dot = '\0';
d3196 1
d3198 9
a3206 6

		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    break;
		case cftGzip:
d3208 1
a3208 6
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    break;
		default:
		    break;
d3217 3
d3223 2
a3224 20
	if (rv < 0) {
#if 0	/* any known servers where ABOR would work this way? */
	    if (rv == HT_INTERRUPTED || rv == -501)
		if (send_cmd_nowait("ABOR") == 1) {
		    outstanding++;
		    CTRACE((tfp, "HTFTP: outstanding responses: %d\n", outstanding));
		}
#endif
	    if (rv == -2)	/* weird error, don't expect much response */
		outstanding--;
	    else if (rv == HT_INTERRUPTED || rv == -1)
		/* User may have pressed 'z' to give up because no
		   packets got through, so let's not make them wait
		   longer - kw */
		outstanding = 0;
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	} else
	    status = 2;	/* data_soc already closed in HTCopy - kw */

d3227 1
d3229 12
a3240 19
	    if (rv != HT_LOADED && outstanding--) {
		status = response(0);		/* Pick up final reply */
		if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		    data_soc = -1;		/* invalidate it */
		    init_help_message_cache();  /* to free memory */
		    return HTLoadError(sink, 500, response_text);
		} else if (status <= 0) {
		    outstanding = 0;
		} else if (status == 2 && !strncmp(response_text, "221", 3))
		    outstanding = 0;
	    }
	}
	final_status = HT_LOADED;
    }
    while (outstanding-- > 0 &&
	   (status > 0)) {
	status = response(0);
	if (status == 2 && !strncmp(response_text, "221", 3))
	    break;
a3241 14
    data_soc = -1;			/* invalidate it */
    CTRACE((tfp, "HTFTPLoad: normal end; "));
    if (control->socket < 0) {
	CTRACE((tfp, "control socket is %d\n", control->socket));
    } else {
	CTRACE((tfp, "closing control socket %d\n", control->socket));
	status = NETCLOSE(control->socket);
	if (status == -1)
	    HTInetStatus("control connection close");	/* Comment only */
    }
    control->socket = -1;
    init_help_message_cache();  /* to free memory */
      /* returns HT_LOADED (always for file if we get here) or error */
    return final_status;
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d2929 1
a2929 1
    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n", name, ftp_local_passive ? "passive" : "normal"));
d2943 1
a2943 1
	if (!ftp_local_passive) {
d3574 1
a3574 1
    if(!ftp_local_passive) {
d3598 1
a3598 1
    } /* !ftp_local_passive */
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d96 1
a96 1
    unsigned long		addr;	/* IP address		*/
d105 6
a110 7
#define PUTC(c)      (*targetClass.put_character) (target, c)
#define PUTS(s)      (*targetClass.put_string)    (target, s)
#define START(e)     (*targetClass.start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*targetClass.end_element)   (target, e, 0)
#define FREE_TARGET  (*targetClass._free)         (target)
#define ABORT_TARGET (*targetClass._free)         (target)

a119 1

a135 9
/*
 * ProFTPD 1.2.5rc1 is known to have a broken implementation of RETR.  If asked
 * to retrieve a directory, it gets confused and fails subsequent commands such
 * as CWD and LIST.  Since this is an unusual bug, we should remove this ifdef
 * at some point - TD 2004/1/1.
 */
#define BROKEN_PROFTPD 1
PRIVATE int ProFTPD_bugs = FALSE;

a476 6
#ifdef BROKEN_PROFTPD
		if (result == 220 && LYstrstr(response_text, "ProFTPD 1.2.5")) {
		    ProFTPD_bugs = TRUE;
		    CTRACE((tfp, "This server is broken (RETR)\n"));
		}
#endif
d2905 10
a2914 4
/*
 * Setup an FTP connection.
 */
PRIVATE int setup_connection ARGS2(
d2916 3
a2918 1
	HTParentAnchor *,	anchor)
d2920 3
d2924 6
a2929 1
    int status;
d2936 1
a2936 1
    ProFTPD_bugs = FALSE;
a3092 31
    return status;
}

/*	Retrieve File from Server
**	-------------------------
**
** On entry,
**	name		WWW address of a file: document, including hostname
** On exit,
**	returns		Socket number for file if good.
**			<0 if bad.
*/
PUBLIC int HTFTPLoad ARGS4(
	CONST char *,		name,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
{
    BOOL isDirectory = NO;
    HTAtom * encoding = NULL;
    int status, final_status;
    int outstanding = 1;	/* outstanding control connection responses
				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
    HTFormat format;

    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n", name, ftp_local_passive ? "passive" : "normal"));

    HTReadProgress(0,0);

    status = setup_connection(name, anchor);
a3542 17
#ifdef BROKEN_PROFTPD
	    /*
	     * ProFTPD 1.2.5rc1 gets confused when asked to RETR a directory.
	     */
	    if (status >= 5) {
		int check;

		if (ProFTPD_bugs) {
		    CTRACE((tfp, "{{reconnecting...\n"));
		    close_connection(control);
		    check = setup_connection(name, anchor);
		    CTRACE((tfp, "...done }}reconnecting\n"));
		    if (check < 0)
			return check;
		}
	    }
#endif
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d113 1
a113 1
	const HTStructuredClass *	isa;
d120 1
a120 1
int HTfileSortMethod = FILE_BY_NAME;
d123 4
a126 4
static char ThisYear[8];
static char LastYear[8];
static int TheDate;
static BOOLEAN HaveYears = FALSE;
d131 6
a136 6
static connection * connections = NULL;/* Linked list of connections */
static char response_text[LINE_LENGTH+1];/* Last response from ftp host */
static connection * control = NULL;	/* Current connection */
static int data_soc = -1;		/* Socket for data transfer =invalid */
static char *user_entered_password = NULL;
static char *last_username_and_host = NULL;
d145 1
a145 1
static int ProFTPD_bugs = FALSE;
d166 3
a168 3
static eServerType server_type = GENERIC_SERVER; /* the type of ftp host */
static int	unsure_type = FALSE;		/* sure about the type? */
static BOOLEAN use_list = FALSE;		/* use the LIST command? */
d170 1
a170 1
static int	interrupted_in_next_data_char = FALSE;
d173 1
a173 1
static PortNumber	port_number = FIRST_TCP_PORT;
d176 5
a180 5
static int	master_socket = -1;	/* Listening socket = invalid	*/
static char	port_command[255];	/* Command for setting the port */
static fd_set	open_sockets;		/* Mask of active channels */
static int	num_sockets;		/* Number of sockets to scan */
static PortNumber	passive_port;	/* Port server specified for data */
d186 3
a188 3
static char data_buffer[DATA_BUFFER_SIZE];		/* Input data buffer */
static char * data_read_pointer;
static char * data_write_pointer;
d190 2
a191 2
static int close_connection (
	connection *	con);
d198 1
a198 1
static void free_FTPGlobals (void)
d221 3
a223 3
char * HTVMS_name (
	const char *	nn,
	const char *	fn)
d239 1
a239 1
    const char * hostname = HTHostName();
d246 2
a247 2
	const char *p;
	const char *q;
d290 1
a290 1
static int next_data_char (void)
d316 2
a317 2
static int close_connection (
	connection *	con)
d347 1
a347 1
static char *help_message_buffer = NULL;  /* global :( */
d349 1
a349 1
static void init_help_message_cache (void)
d354 2
a355 2
static void help_message_cache_add (
	char *		string)
d365 1
a365 1
static char *help_message_cache_non_empty (void)
d370 1
a370 1
static char *help_message_cache_contents (void)
d392 2
a393 2
static int write_cmd (
	char *		cmd)
d444 2
a445 2
static int response (
	char *		cmd)
d532 1
a532 1
static int send_cmd_1 (char *  verb)
d540 1
a540 1
static int send_cmd_2 (char *  verb, char *  param)
d558 2
a559 2
static int set_mac_binary (
	eServerType	ServerType)
d577 3
a579 3
static void get_ftp_pwd (
	eServerType *	ServerType,
	BOOLEAN *	UseList)
d632 3
a634 3
static void set_unix_dirstyle (
	eServerType *	ServerType,
	BOOLEAN *	UseList)
d682 3
a684 3
static int get_connection (
	const char *		arg,
	HTParentAnchor *	anchor)
d869 1
a869 1
	    const char *host = NULL;
d1054 1
a1054 1
static int close_master_socket (void)
d1084 1
a1084 1
static int get_listen_socket (void)
d1334 1
a1334 1
static char * months[12] = {
d1348 1
a1348 1
static void set_years_and_date (void)
d1384 2
a1385 2
static void free_entryinfo_struct_contents (
	EntryInfo *	entry_info)
d1403 2
a1404 2
static BOOLEAN is_ls_date (
	char *		s)
d1472 3
a1474 3
static void parse_eplf_line (
	char *		line,
	EntryInfo *	info)
d1529 3
a1531 3
static void parse_ls_line (
	char *		line,
	EntryInfo *	entry_info)
d1568 4
a1571 4
static void parse_dls_line (
	char *		line,
	EntryInfo *	entry_info,
	char **	pspilledname)
d1673 3
a1675 3
static void parse_vms_dir_entry (
	char *		line,
	EntryInfo *	entry_info)
d1812 3
a1814 3
static void parse_ms_windows_dir_entry (
	char *		line,
	EntryInfo *	entry_info)
d1886 3
a1888 3
static void parse_windows_nt_dir_entry (
	char *		line,
	EntryInfo *	entry_info)
d1995 3
a1997 3
static void parse_cms_dir_entry (
	char *		line,
	EntryInfo *	entry_info)
d2138 4
a2141 4
static EntryInfo * parse_dir_entry (
	char *		entry,
	BOOLEAN *	first,
	char **	pspilledname)
d2438 1
a2438 1
	const char *cp2;
d2459 3
a2461 3
static int compare_EntryInfo_structs (
	EntryInfo *	entry1,
	EntryInfo *	entry2)
d2602 5
a2606 5
static int read_directory (
	HTParentAnchor *	parent,
	const char *		address,
	HTFormat		format_out,
	HTStream *		sink)
d2925 3
a2927 3
static int setup_connection (
	const char *		name,
	HTParentAnchor *	anchor)
d3106 5
a3110 5
int HTFTPLoad (
	const char *		name,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink)
d3800 1
a3800 1
void HTClearFTPPassword (void)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 46
a47 46
 *			for a WorldWideWeb browser
 *			===================================
 *
 *	A cache of control connections is kept.
 *
 * Note: Port allocation
 *
 *	It is essential that the port is allocated by the system, rather
 *	than chosen in rotation by us (POLL_PORTS), or the following
 *	problem occurs.
 *
 *	It seems that an attempt by the server to connect to a port which has
 *	been used recently by a listen on the same socket, or by another
 *	socket this or another process causes a hangup of (almost exactly)
 *	one minute.  Therefore, we have to use a rotating port number.
 *	The problem remains that if the application is run twice in quick
 *	succession, it will hang for what remains of a minute.
 *
 * Authors
 *	TBL	Tim Berners-lee <timbl@@info.cern.ch>
 *	DD	Denis DeLaRoca 310 825-4580 <CSP1DWD@@mvs.oac.ucla.edu>
 *	LM	Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
 *	FM	Foteos Macrides <macrides@@sci.wfeb.edu>
 * History:
 *	 2 May 91	Written TBL, as a part of the WorldWideWeb project.
 *	15 Jan 92	Bug fix: close() was used for NETCLOSE for control soc
 *	10 Feb 92	Retry if cached connection times out or breaks
 *	 8 Dec 92	Bug fix 921208 TBL after DD
 *	17 Dec 92	Anon FTP password now just WWWuser@@ suggested by DD
 *			fails on princeton.edu!
 *	27 Dec 93 (FM)	Fixed up so FTP now works with VMS hosts.  Path
 *			must be Unix-style and cannot include the device
 *			or top directory.
 *	?? ??? ?? (LM)	Added code to prompt and send passwords for non
 *			anonymous FTP
 *	25 Mar 94 (LM)	Added code to recognize different ftp server types
 *			and code to parse dates and sizes on most hosts.
 *	27 Mar 93 (FM)	Added code for getting dates and sizes on VMS hosts.
 *
 * Notes:
 *			Portions Copyright 1994 Trustees of Dartmouth College
 *			Code for recognizing different FTP servers and
 *			parsing "ls -l" output taken from Macintosh Fetch
 *			program with permission from Jim Matthews,
 *			Dartmouth Software Development Team.
 */
d50 9
a58 9
 * BUGS:	@@@@@@	Limit connection cache size!
 * 		Error reporting to user.
 * 		400 & 500 errors are ack'ed by user with windows.
 * 		Use configuration file for user names
 * 
 *		Note for portability this version does not use select() and
 *		so does not watch the control and data channels at the
 *		same time.
 */
d64 1
a64 1
#include <HTFTP.h>		/* Implemented here */
d69 2
a70 2
#define REPEAT_PORT		/* Give the port number for each file */
#define REPEAT_LISTEN		/* Close each listen socket and open a new one */
d73 1
a73 1
#define LISTEN_BACKLOG 2	/* Number of pending connect requests (TCP) */
d82 1
a82 1
#include <HTFile.h>		/* For HTFileFormat() */
d95 4
a98 4
    struct _connection *next;	/* Link on list         */
    unsigned long addr;		/* IP address           */
    int socket;			/* Socket number for communication */
    BOOL binary;		/* Binary mode? */
d113 2
a114 2
    const HTStructuredClass *isa;
    /* ... */
d118 2
a119 2
 *	---------------------
 */
d122 1
a122 1
#ifndef DISABLE_FTP		/*This disables everything to end-of-file */
d129 6
a134 6
 *	---------------------
 */
static connection *connections = NULL;	/* Linked list of connections */
static char response_text[LINE_LENGTH + 1];	/* Last response from ftp host */
static connection *control = NULL;	/* Current connection */
static int data_soc = -1;	/* Socket for data transfer =invalid */
d148 16
a163 16
    GENERIC_SERVER
    ,MACHTEN_SERVER
    ,UNIX_SERVER
    ,VMS_SERVER
    ,CMS_SERVER
    ,DCTS_SERVER
    ,TCPC_SERVER
    ,PETER_LEWIS_SERVER
    ,NCSA_SERVER
    ,WINDOWS_NT_SERVER
    ,WINDOWS_2K_SERVER
    ,MS_WINDOWS_SERVER
    ,MSDOS_SERVER
    ,APPLESHARE_SERVER
    ,NETPRESENZ_SERVER
    ,DLS_SERVER
d166 3
a168 3
static eServerType server_type = GENERIC_SERVER;	/* the type of ftp host */
static int unsure_type = FALSE;	/* sure about the type? */
static BOOLEAN use_list = FALSE;	/* use the LIST command? */
d170 1
a170 1
static int interrupted_in_next_data_char = FALSE;
d173 1
a173 1
static PortNumber port_number = FIRST_TCP_PORT;
d176 6
a181 5
static int master_socket = -1;	/* Listening socket = invalid   */
static char port_command[255];	/* Command for setting the port */
static fd_set open_sockets;	/* Mask of active channels */
static int num_sockets;		/* Number of sockets to scan */
static PortNumber passive_port;	/* Port server specified for data */
d186 6
a191 3
static char data_buffer[DATA_BUFFER_SIZE];	/* Input data buffer */
static char *data_read_pointer;
static char *data_write_pointer;
a192 2
#define NEXT_DATA_CHAR next_data_char()
static int close_connection(connection * con);
d196 3
a198 3
 *  This function frees module globals. - FM
 */
static void free_FTPGlobals(void)
d211 13
a223 12
 *		CONVERTS WWW name into a VMS name
 * ON ENTRY:
 *	nn		Node Name (optional)
 *	fn		WWW file name
 *
 * ON EXIT:
 *	returns		vms file specification
 *
 * Bug: Returns pointer to static -- non-reentrant
 */
char *HTVMS_name(const char *nn,
		 const char *fn)
d227 6
a232 6
 *	first that the file is, like us, on a VMS node.  We try remote
 *	(or local) DECnet access.  Files-11, VMS, VAX and DECnet
 *	are trademarks of Digital Equipment Corporation.
 *	The node is assumed to be local if the hostname WITHOUT DOMAIN
 *	matches the local one. @@@@@@
 */
d234 2
a235 2
    char *filename = (char *) malloc(strlen(fn) + 1);
    char *nodename = (char *) malloc(strlen(nn) + 2 + 1);	/* Copies to hack */
d239 1
a239 1
    const char *hostname = HTHostName();
a247 1

d249 1
a249 1
	     *p && *p != '.' && *q && *q != '.'; p++, q++) {
a251 1

d255 1
a255 1
		    *r = '\0';	/* Chop domain */
d262 1
a262 1
    second = strchr(filename + 1, '/');		/* 2nd slash */
d265 1
a265 1
    if (!second) {		/* Only one slash */
d267 1
a267 1
    } else if (second == last) {	/* Exactly two slashes */
d269 4
a272 5
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename + 1, second + 1);
	*second = '/';		/* restore */
    } else {			/* More than two slashes */
	char *p;

d276 1
a276 1
		   nodename, filename + 1, second + 1, last + 1);
d278 1
a278 1
	for (p = strchr(vmsname, '['); *p != ']'; p++)
d280 1
a280 1
		*p = '.';	/* Convert dir sep.  to dots */
d288 3
a290 3
 *	----------------------------------------------------
 */
static int next_data_char(void)
a292 1

d295 6
a300 6
	if (status == HT_INTERRUPTED)
	    interrupted_in_next_data_char = 1;
	if (status <= 0)
	    return -1;
	data_write_pointer = data_buffer + status;
	data_read_pointer = data_buffer;
a304 1

d312 1
d314 4
a317 3
 *
 */
static int close_connection(connection * con)
d319 1
a319 1
    connection *scan;
a320 1

d340 1
a340 1
		control = (connection *) 0;
d342 3
a344 3
	}			/*if */
    }				/* for */
    return -1;			/* very strange -- was not on list. */
d347 1
a347 1
static char *help_message_buffer = NULL;	/* global :( */
d349 1
a349 1
static void init_help_message_cache(void)
d354 2
a355 1
static void help_message_cache_add(char *string)
d362 1
a362 1
    CTRACE((tfp, "Adding message to help cache: %s\n", string));
d365 1
a365 1
static char *help_message_cache_non_empty(void)
d367 1
a367 1
    return (help_message_buffer);
d370 1
a370 1
static char *help_message_cache_contents(void)
d372 1
a372 1
    return (help_message_buffer);
d376 18
a393 17
 *	----------------
 *
 *	This function checks whether we have a control connection, and sends
 *	one command if given.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command should already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  1 for success,
 *		  or negative for communication failure (in which case
 *		  the control connection will be closed).
 */
static int write_cmd(char *cmd)
d406 1
a406 2
	    char *p;

d412 1
a412 1
	status = NETWRITE(control->socket, cmd, (int) strlen(cmd));
d414 2
a415 3
	    CTRACE((tfp,
		    "HTFTP: Error %d sending command: closing socket %d\n",
		    status, control->socket));
d424 22
a445 21
 *	--------------------------------
 *
 *	See the state machine illustrated in RFC959, p57. This implements
 *	one command/reply sequence.  It also interprets lines which are to
 *	be continued, which are marked with a "-" immediately after the
 *	status code.
 *
 *	Continuation then goes on until a line with a matching reply code
 *	an a space after it.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command must already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  The first digit of the reply type,
 *		  or negative for communication failure.
 */
static int response(char *cmd)
d447 1
a447 1
    int result;			/* Three-digit decimal code */
a455 1

a457 1

d459 1
a459 1
		|| (p == &response_text[LINE_LENGTH])) {
d464 2
a465 3
		    CTRACE((tfp,
			    "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		    NETCLOSE(control->socket);
d470 1
a470 1
		*p = '\0';	/* Terminate the string */
d474 4
a477 4
		if (!strncmp(response_text, "230-", 4) ||
		    !strncmp(response_text, "250-", 4) ||
		    !strncmp(response_text, "220-", 4))
		    help_message_cache_add(response_text + 4);
d480 3
a482 3
		if (continuation_response == -1) {
		    if (continuation == '-')	/* start continuation */
			continuation_response = result;
d484 3
a486 3
		    if (continuation_response == result &&
			continuation == ' ')
			continuation_response = -1;	/* ended */
d495 2
a496 2
	    }
	    /* if end of line */
d498 2
a499 3
		CTRACE((tfp,
			"HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		NETCLOSE(control->socket);
d506 1
a506 1
			control->socket));
d511 1
a511 1
	}			/* Loop over characters */
d517 1
a517 1
		control->socket));
d525 2
a526 2
	 * Alas, CMS returns 255 on failure to CWD to parent of root.  - PG
	 */
d529 1
a529 1
    return result / 100;
d532 1
a532 1
static int send_cmd_1(char *verb)
d536 2
a537 2
    sprintf(command, "%.*s%c%c", (int) sizeof(command) - 4, verb, CR, LF);
    return response(command);
d540 1
a540 1
static int send_cmd_2(char *verb, char *param)
d546 1
a546 1
    status = response(command);
d555 2
a556 2
 * This function should try to set the macintosh server into binary mode.  Some
 * servers need an additional letter after the MACB command.
d558 2
a559 1
static int set_mac_binary(eServerType ServerType)
d565 1
a565 1
	 * Presumably E means "Enable".  - KW
d567 1
a567 1
	return (2 == response("MACB E\r\n"));
d569 1
a569 1
	return (2 == response("MACB\r\n"));
d577 3
a579 1
static void get_ftp_pwd(eServerType *ServerType, BOOLEAN *UseList)
a582 1

a584 1

d588 1
a588 1
	cp = strchr(response_text + 5, '"');
d593 1
a593 1
			   NCSA_SERVER : TCPC_SERVER);
d595 2
a596 2
		    ((*ServerType == NCSA_SERVER) ?
		     "NCSA" : "TCPC")));
d605 3
a607 3
		*ServerType = UNIX_SERVER;
		*UseList = TRUE;
		CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d610 1
a610 1
	} else if (response_text[strlen(response_text) - 1] == ']') {
d632 3
a634 1
static void set_unix_dirstyle(eServerType *ServerType, BOOLEAN *UseList)
a637 1

a642 1

d658 1
a658 1
	cp = strstr(response_text + 4, "MSDOS");
d668 17
a684 16
 *	----------------------------------
 *
 * On entry,
 *	arg	points to the name of the host in a hypertext address
 * On exit,
 *	returns <0 if error
 *		socket number if success
 *
 *	This routine takes care of managing timed-out connections, and
 *	limiting the number of connections in use at any one time.
 *
 *	It ensures that all connections are logged in if they exist.
 *	It ensures they have the port number transferred.
 */
static int get_connection(const char *arg,
			  HTParentAnchor *anchor)
d687 4
a690 4
    char *command = 0;
    connection *con;
    char *username = NULL;
    char *password = NULL;
d695 2
a696 2
	 * Set up freeing at exit.  - FM
	 */
d705 2
a706 2
	 * Reuse this object - KW, DW & FM
	 */
d715 2
a716 2
	 * Allocate and init control struct.
	 */
d723 2
a724 4
    if (!arg)
	return -1;		/* Bad if no name specified     */
    if (!*arg)
	return -1;		/* Bad if name had zero length  */
d732 1
a732 1
	char *pw = NULL;
d736 2
a737 2
	    *p2 = '\0';		/* terminate */
	    p1 = p2 + 1;	/* point to host */
d747 4
a750 3
	     * If the password doesn't exist then we are going to have to ask
	     * the user for it.  The only problem is that we don't want to ask
	     * for it every time, so we will store away in a primitive fashion.
d757 3
a759 3
		 * If the user@@host is not equal to the last time through or
		 * user_entered_password has no data then we need to ask the
		 * user for the password.
d767 1
a767 1
			       username, p1);
d771 1
a771 1
		}		/* else we already know the password */
d779 1
a779 1
    }				/* scope of p1 */
d781 1
a781 1
    status = HTDoConnect(arg, "FTP", IPPORT_FTP, (int *) &con->socket);
d788 1
a788 1
		    arg));
d791 1
a791 1
	    _HTProgress(CONNECTION_INTERRUPTED);
d796 3
a798 2
	if (con->socket != -1) {
	    NETCLOSE(con->socket);
d805 1
a805 1
	return status;		/* Bad return */
d809 1
a809 1
	    con->socket, con));
d816 1
d819 1
a819 1
    status = response((char *) 0);	/* Get greeting */
d823 1
a823 1
	_HTProgress(CONNECTION_INTERRUPTED);
d852 1
a852 1
	    _HTProgress(CONNECTION_INTERRUPTED);
d870 1
a870 1
	    char *cp;
d878 1
a878 1
		if ((cp = strchr(user, '@@')) != NULL) {
d888 1
a888 1
		if ((cp = LYGetEnv("USER")) != NULL)
d909 1
a909 1
	    _HTProgress(CONNECTION_INTERRUPTED);
d921 1
a921 1
	    _HTProgress(CONNECTION_INTERRUPTED);
d935 1
a935 1
    /* Check for host type */
d938 2
a939 2
    use_list = FALSE;		/* reset */
    if ((status = response("SYST\r\n")) == 2) {
d941 1
a941 1
	if (strncmp(response_text + 4,
d947 2
a948 2
	} else if (strstr(response_text + 4, "UNIX") != NULL ||
		   strstr(response_text + 4, "Unix") != NULL) {
d950 1
a950 1
	    unsure_type = FALSE;	/* to the best of out knowledge... */
d954 1
a954 1
	} else if (strstr(response_text + 4, "MSDOS") != NULL) {
d959 1
a959 1
	} else if (strncmp(response_text + 4, "VMS", 3) == 0) {
a960 1

d963 2
a964 2
		&& tilde[2] != 0
		&& strstr(response_text + 4, "MadGoat") != 0) {
d972 2
a973 2
	} else if ((strncmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (strncmp(response_text + 4, "VM ", 3) == 0)) {
d978 1
a978 1
	} else if (strncmp(response_text + 4, "DCTS", 4) == 0) {
d982 1
a982 1
	} else if (strstr(response_text + 4, "MAC-OS TCP/Connect II") != NULL) {
d988 1
a988 1
	} else if (server_type == NETPRESENZ_SERVER) {	/* already set above */
d993 1
a993 1
	} else if (strncmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
d999 1
a999 1
	} else if (strncmp(response_text + 4, "Windows_NT", 10) == 0) {
d1004 1
a1004 1
	} else if (strncmp(response_text + 4, "Windows2000", 11) == 0) {
d1009 1
a1009 1
	} else if (strncmp(response_text + 4, "MS Windows", 10) == 0) {
d1014 1
a1014 1
	} else if (strncmp(response_text + 4,
d1021 1
a1021 1
	} else {
d1026 1
a1026 1
	}
d1029 1
a1029 1
	get_ftp_pwd(&server_type, &use_list);
a1036 1

d1040 1
a1040 1
	    return -status;	/* Bad return */
d1045 1
a1045 1
    return con->socket;		/* Good return */
d1048 1
d1050 5
a1054 5
 *	-------------------------------
 *
 *
 */
static int close_master_socket(void)
d1069 1
d1071 14
a1084 14
 *	-------------------------------------
 *
 *	When data is transferred, we open a port, and wait for the server to
 *	connect with the data.
 *
 * On entry,
 *	master_socket	Must be negative if not set up already.
 * On exit,
 *	Returns		socket number if good
 *			less than zero if error.
 *	master_socket	is socket number if good, else negative.
 *	port_number	is valid if good.
 */
static int get_listen_socket(void)
d1088 1
a1088 1
    struct sockaddr_in *soc_in = (struct sockaddr_in *) &soc_address;
a1090 1

d1093 1
a1093 1
    struct sockaddr_in *soc_in = &soc_address;
d1095 2
a1096 1
    int new_socket;		/* Will be master_socket */
d1103 1
a1103 1
	return master_socket;	/* Done already */
d1109 2
a1110 2
    if (getsockname(control->socket, (struct sockaddr *) &soc_address,
		    &slen) < 0) {
d1113 1
a1113 1
    af = ((struct sockaddr *) &soc_address)->sa_family;
d1134 1
a1134 1
    ((struct sockaddr *) &soc_address)->sa_family = af;
d1138 1
a1138 1
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in);
d1143 1
a1143 1
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in6);
d1150 2
a1151 2
    soc_in->sin_family = AF_INET;	/* Family = internet, host order  */
    soc_in->sin_addr.s_addr = INADDR_ANY;	/* Any peer address */
d1156 1
a1156 2

	for (port_number = (old_port_number + 1);; port_number++) {
a1157 1

d1170 4
a1173 4
		if ((status = Rbind(new_socket,
				    (struct sockaddr *) &soc_address,
		/* Cast to generic sockaddr */
				    SOCKADDR_LEN(soc_address)
d1175 1
a1175 1
				    ,socks_bind_remoteAddr
d1177 1
a1177 1
		     )) == 0) {
d1181 7
a1187 7
		    if ((status = bind(new_socket,
				       (struct sockaddr *) &soc_address,
		    /* Cast to generic sockaddr */
				       SOCKADDR_LEN(soc_address)
			 )) == 0) {
		    break;
		}
d1189 2
a1190 2
		    port_number, status, SOCKET_ERRNO));
	}			/* for */
a1195 1

d1199 2
a1200 2
				  (struct sockaddr *) &soc_address,
				  (void *) &address_length);
d1203 4
a1206 5
	    status = getsockname(control->socket,
				 (struct sockaddr *) &soc_address,
				 (void *) &address_length);
	if (status < 0)
	    return HTInetStatus("getsockname");
d1209 1
a1209 1
		HTInetString((SockA *) soc_in)));
d1214 1
a1214 1
		HTInetString(soc_in)));
d1220 4
a1223 4
	    status = Rbind(new_socket,
			   (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			   sizeof(soc_address)
d1226 1
a1226 1
			   socks_bind_remoteAddr
d1228 1
a1228 1
			   ,socks_bind_remoteAddr
d1231 1
a1231 1
		);
d1234 6
a1239 7
	    status = bind(new_socket,
			  (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			  SOCKADDR_LEN(soc_address)
		);
	if (status < 0)
	    return HTInetStatus("bind");
d1245 2
a1246 2
				  (struct sockaddr *) &soc_address,
				  (void *) &address_length);
d1249 4
a1252 5
	    status = getsockname(new_socket,
				 (struct sockaddr *) &soc_address,
				 (void *) &address_length);
	if (status < 0)
	    return HTInetStatus("getsockname");
d1258 2
a1259 2
	    (int) ntohs(soc_in->sin_port),
	    HTInetString((SockA *) soc_in)));
d1262 2
a1263 2
	    (int) ntohs(soc_in->sin_port),
	    HTInetString(soc_in)));
d1275 1
a1275 1
    (void) HTHostName();	/* Make address valid - doesn't work */
d1277 1
a1277 1
    switch (((struct sockaddr *) &soc_address)->sa_family) {
d1281 7
a1287 7
		(int) *((unsigned char *) (&soc_in->sin_addr) + 0),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 1),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 2),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 3),
		(int) *((unsigned char *) (&soc_in->sin_port) + 0),
		(int) *((unsigned char *) (&soc_in->sin_port) + 1),
		CR, LF);
d1293 11
a1303 12
	{
	    char hostbuf[MAXHOSTNAMELEN];
	    char portbuf[MAXHOSTNAMELEN];

	    getnameinfo((struct sockaddr *) &soc_address,
			SOCKADDR_LEN(soc_address),
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		    CR, LF);
	    break;
	}
d1310 2
a1311 2
    /*  Inform TCP that we will accept connections
     */
a1313 1

d1327 2
a1328 2
    if ((master_socket + 1) > num_sockets)
	num_sockets = master_socket + 1;
d1330 1
a1330 1
    return master_socket;	/* Good */
d1332 1
a1332 1
}				/* get_listen_socket */
d1334 2
a1335 4
static char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
d1339 10
a1348 10
 *	-----------------------------------------------------------------
 *
 *	Bug:
 *		This code is for sorting listings by date, if that option
 *		is selected in Lynx, and doesn't take into account time
 *		zones or ensure resetting at midnight, so the sort may not
 *		be perfect, but the actual date isn't changed in the display,
 *		i.e., the date is still correct. - FM
 */
static void set_years_and_date(void)
d1355 1
a1355 1
    strncpy(day, (char *) ctime(&NowTime) + 8, 2);
d1360 1
a1360 1
    strncpy(month, (char *) ctime(&NowTime) + 4, 3);
d1370 1
a1370 1
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
d1377 3
a1379 3
    char *filename;
    char *type;
    char *date;
d1381 1
a1381 1
    BOOLEAN display;		/* show this entry? */
d1384 2
a1385 1
static void free_entryinfo_struct_contents(EntryInfo *entry_info)
d1392 1
a1392 1
    /* dont free the struct */
d1403 2
a1404 1
static BOOLEAN is_ls_date(char *s)
d1466 1
a1466 1
}				/* is_ls_date() */
d1469 2
a1470 1
 * Extract the name, size, and date from an EPLF line.  - 08-06-96 DJB
d1472 3
a1474 2
static void parse_eplf_line(char *line,
			    EntryInfo *info)
d1480 1
a1480 1
    static time_t base;		/* time() value on this OS in 1970 */
d1485 2
a1486 7

	t.tm_year = 70;
	t.tm_mon = 0;
	t.tm_mday = 0;
	t.tm_hour = 0;
	t.tm_min = 0;
	t.tm_sec = 0;
d1488 1
a1488 1
	base = mktime(&t);	/* could return -1 */
d1493 28
a1520 28
	switch (*cp) {
	case '\t':
	    StrAllocCopy(info->filename, cp + 1);
	    return;
	case 's':
	    size = 0;
	    while (*(++cp) && (*cp != ','))
		size = (size * 10) + (*cp - '0');
	    info->size = size;
	    break;
	case 'm':
	    secs = 0;
	    while (*(++cp) && (*cp != ','))
		secs = (secs * 10) + (*cp - '0');
	    secs += base;	/* assumes that time_t is #seconds */
	    strcpy(ct, ctime(&secs));
	    ct[24] = 0;
	    StrAllocCopy(info->date, ct);
	    break;
	case '/':
	    StrAllocCopy(info->type, ENTRY_IS_DIRECTORY);
	    /* FALLTHRU */
	default:
	    while (*cp) {
		if (*cp++ == ',')
		    break;
	    }
	    break;
d1523 1
a1523 1
}				/* parse_eplf_line */
d1526 2
a1527 1
 * Extract the name, size, and date from an ls -l line.
d1529 7
a1535 6
static void parse_ls_line(char *line,
			  EntryInfo *entry_info)
{
    int i, j;
    int base = 1;
    int size_num = 0;
d1538 2
a1539 2
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i - 12]));
	 i--) ;			/* null body */
d1542 1
a1542 1
	StrAllocCopy(entry_info->date, &line[i - 12]);
d1549 1
a1549 1
		entry_info->date[j] = entry_info->date[j - 1];
d1561 1
a1561 1
}				/* parse_ls_line() */
d1564 13
a1576 11
 * Extract the name and size info and whether it refers to a directory from a
 * LIST line in "dls" format.
 */
static void parse_dls_line(char *line,
			   EntryInfo *entry_info,
			   char **pspilledname)
{
    short j;
    int base = 1;
    int size_num = 0;
    int len;
d1579 8
a1586 8
    /* README              763  Information about this server\0
       bin/                  -  \0
       etc/                  =  \0
       ls-lR                 0  \0
       ls-lR.Z               3  \0
       pub/                  =  Public area\0
       usr/                  -  \0
       morgan               14  -> ../real/morgan\0
d1588 2
a1589 2
       79215    \0
     */
d1611 1
a1611 1
	    if (entry_info->filename[strlen(entry_info->filename) - 1] == '/')
d1617 1
a1617 1
	    if (cps && cps != line && *(cps - 1) == '/')
d1654 4
a1657 4
    if (len > 0 && line[len - 1] == '/') {
	/*
	 * It's a dir, remove / and mark it as such.
	 */
d1659 1
a1659 1
	    line[len - 1] = '\0';
d1666 1
a1666 1
}				/* parse_dls_line() */
d1673 3
a1675 2
static void parse_vms_dir_entry(char *line,
				EntryInfo *entry_info)
d1681 2
a1682 3
    /* Get rid of blank lines, and information lines.  Valid lines have the ';'
     * version number token.
     */
d1688 3
a1690 3
    /* Cut out file or directory name at VMS version number. */
    *cp++ = '\0';
    StrAllocCopy(entry_info->filename, line);
d1692 1
a1692 1
    /* Cast VMS non-README file and directory names to lowercase. */
d1711 1
a1711 1
    /* Uppercase terminal .z's or _z's. */
d1714 2
a1715 2
	(entry_info->filename[i - 1] == '.' ||
	 entry_info->filename[i - 1] == '_'))
d1718 3
a1720 3
    /* Convert any tabs in rest of line to spaces. */
    cps = cp - 1;
    while ((cps = strchr(cps + 1, '\t')) != NULL)
d1723 2
a1724 3
    /* Collapse serial spaces. */
    i = 0;
    j = 1;
d1734 1
a1734 1
    /* Set the years and date, if we don't have them yet. * */
d1739 13
a1751 13
    /* Track down the date. */
    if ((cpd = strchr(cp, '-')) != NULL &&
	strlen(cpd) > 9 && isdigit(UCH(*(cpd - 1))) &&
	isalpha(UCH(*(cpd + 1))) && *(cpd + 4) == '-') {

	/* Month */
	*(cpd + 2) = (char) TOLOWER(*(cpd + 2));
	*(cpd + 3) = (char) TOLOWER(*(cpd + 3));
	sprintf(date, "%.3s ", cpd + 1);

	/* Day */
	if (isdigit(UCH(*(cpd - 2))))
	    sprintf(date + 4, "%.2s ", cpd - 2);
d1753 1
a1753 1
	    sprintf(date + 4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd - 1);
d1755 4
a1758 4
	/* Time or Year */
	if (!strncmp(ThisYear, cpd + 5, 4) &&
	    strlen(cpd) > 15 && *(cpd + 12) == ':') {
	    sprintf(date + 7, "%.5s", cpd + 10);
d1760 1
a1760 1
	    sprintf(date + 7, " %.4s", cpd + 5);
d1766 2
a1767 2
    /* Track down the size */
    if ((cpd = strchr(cp, '/')) != NULL) {
d1770 1
a1770 1
	while (isdigit(UCH(*(cps - 1))))
d1775 1
a1775 1
	cps = cpd + 1;
d1779 1
a1779 1
	ialloc = atoi(cpd + 1);
d1784 1
a1784 1
    } else if ((cps = strtok(cp, sp)) != NULL) {
d1787 1
a1787 1
	while ((cps = strtok(NULL, sp)) != NULL) {
d1799 1
a1799 1
    /* Wrap it up */
d1801 3
a1803 3
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1805 1
a1805 1
}				/* parse_vms_dir_entry() */
d1812 3
a1814 2
static void parse_ms_windows_dir_entry(char *line,
				       EntryInfo *entry_info)
d1820 1
a1820 1
    /*  Get rid of blank or junk lines.  */
d1827 1
a1827 1
    /* Cut out file or directory name. */
d1829 1
a1829 1
    *cps++ = '\0';
d1833 1
a1833 1
    /* Track down the size */
d1847 1
a1847 1
    /* Set the years and date, if we don't have them yet. * */
d1852 1
a1852 1
    /* Track down the date. */
d1856 4
a1859 4
	    *(cpd + 6) = '\0';	/* Month and Day */
	    *(cpd + 11) = '\0';	/* Year */
	    *(cpd + 17) = '\0';	/* Time */
	    if (strcmp(ThisYear, cpd + 7))
d1861 1
a1861 1
		sprintf(date, "%.6s  %.4s", cpd, (cpd + 7));
d1864 1
a1864 1
		sprintf(date, "%.6s %.5s", cpd, (cpd + 12));
d1866 1
a1866 1
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
d1872 1
a1872 1
    /* Wrap it up */
d1874 3
a1876 3
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1878 1
a1878 1
}				/* parse_ms_windows_dir_entry */
d1886 3
a1888 2
static void parse_windows_nt_dir_entry(char *line,
				       EntryInfo *entry_info)
d1895 1
a1895 1
    /*  Get rid of blank or junk lines.  */
d1902 1
a1902 1
    /* Cut out file or directory name. */
d1904 2
a1905 2
    cps = LYSkipNonBlanks(end - 1);
    cp = (cps + 1);
d1916 1
a1916 1
    /* Set the years and date, if we don't have them yet. * */
d1921 1
a1921 1
    /* Cut out the date. */
d1924 1
a1924 1
    *cps++ = '\0';
d1931 1
a1931 1
    *cps++ = '\0';
d1937 3
a1939 3
	isdigit(*cp) && isdigit(*(cp + 1)) && *(cp + 2) == '-' &&
	isdigit(*(cp + 3)) && isdigit(*(cp + 4)) && *(cp + 5) == '-') {
	*(cp + 2) = '\0';	/* Month */
d1941 2
a1942 2
	*(cp + 5) = '\0';	/* Day */
	sprintf(date, "%.3s %.2s", months[i], (cp + 3));
d1945 2
a1946 2
	cp += 6;		/* Year */
	if (strcmp((ThisYear + 2), cp)) {
d1955 1
a1955 1
	    *(cpd + 2) = '\0';	/* Hour */
d1957 1
a1957 1
	    if (*(cpd + 5) == 'P' || *(cpd + 5) == 'p')
d1959 1
a1959 1
	    sprintf(&date[6], " %02d:%.2s", i, (cpd + 3));
d1962 1
a1962 1
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
d1967 1
a1967 1
    /* Track down the size */
d1981 1
a1981 1
    /* Wrap it up */
d1983 3
a1985 3
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1987 1
a1987 1
}				/* parse_windows_nt_dir_entry */
d1995 3
a1997 2
static void parse_cms_dir_entry(char *line,
				EntryInfo *entry_info)
d2006 1
a2006 1
    /*  Get rid of blank or junk lines.  */
d2013 1
a2013 1
    /* Cut out file or directory name. */
d2015 1
a2015 1
    *cps++ = '\0';
d2018 1
a2018 1
	/* If we already have a dot, we did an NLST. */
d2022 1
a2022 1
	/* If we don't have more, we've misparsed. */
d2029 1
a2029 1
    *cps++ = '\0';
d2031 1
a2031 1
	/* It's an SFS directory. */
d2035 1
a2035 1
	/* It's a file. */
d2040 1
a2040 1
	/* Track down the VM/CMS RECFM or type. */
d2046 1
a2046 1
	    /* Check cp here, if it's relevant someday. */
d2050 1
a2050 1
    /* Track down the record length or dash. */
d2061 1
a2061 1
    /* Track down the number of records or the dash. */
d2071 1
a2071 1
	    /* Compute an approximate size. */
d2076 1
a2076 1
    /* Set the years and date, if we don't have them yet. */
d2081 1
a2081 1
    /* Track down the date. */
d2086 1
a2086 1
	 isdigit(UCH(*(cps + 1))) && isdigit(UCH(*(cps + 2))) && *(cps + 3) == ':')) {
d2091 3
a2093 3
	    *(cpd + 2) = '\0';	/* Month */
	    *(cpd + 5) = '\0';	/* Day */
	    *(cpd + 8) = '\0';	/* Year */
d2098 1
a2098 1
	    sprintf(date, "%.3s %.2s", months[i], (cpd + 3));
d2102 1
a2102 1
	    if (strcmp((ThisYear + 2), cpd)) {
d2111 1
a2111 1
		*(cps + 2) = '\0';	/* Hour */
d2113 1
a2113 1
		sprintf(&date[6], " %02d:%.2s", i, (cps + 3));
d2116 1
a2116 1
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
d2122 1
a2122 1
    /* Wrap it up. */
d2124 3
a2126 3
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d2128 1
a2128 1
}				/* parse_cms_dir_entry */
d2131 3
a2133 2
 * Given a line of LIST/NLST output in entry, return results and a file/dir
 * name in entry_info struct
d2135 1
a2135 1
 * If first is true, this is the first name in a directory.
d2137 5
a2141 3
static EntryInfo *parse_dir_entry(char *entry,
				  BOOLEAN *first,
				  char **pspilledname)
d2144 3
a2146 3
    int i;
    int len;
    BOOLEAN remove_size = FALSE;
d2149 1
a2149 2
    entry_info = (EntryInfo *) malloc(sizeof(EntryInfo));

d2159 1
a2159 1
    case DLS_SERVER:
d2161 20
a2180 17
	/*
	 * Interpret and edit LIST output from a Unix server in "dls" format. 
	 * This one must have claimed to be Unix in order to get here; if the
	 * first line looks fishy, we revert to Unix and hope that fits better
	 * (this recovery is untested).  - kw
	 */

	if (*first) {
	    len = strlen(entry);
	    if (!len || entry[0] == ' ' ||
		(len >= 24 && entry[23] != ' ') ||
		(len < 24 && strchr(entry, ' '))) {
		server_type = UNIX_SERVER;
		CTRACE((tfp,
			"HTFTP: Falling back to treating as Unix server.\n"));
	    } else {
		*first = FALSE;
a2181 1
	}
d2183 3
a2185 3
	if (server_type == DLS_SERVER) {
	    /* if still unchanged... */
	    parse_dls_line(entry, entry_info, pspilledname);
d2187 16
a2202 32
	    if (!entry_info->filename || *entry_info->filename == '\0') {
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    if (!strcmp(entry_info->filename, "..") ||
		!strcmp(entry_info->filename, "."))
		entry_info->display = FALSE;
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
	    /*
	     * Goto the bottom and get real type.
	     */
	    break;
	}
	/* fall through if server_type changed for *first == TRUE ! */
    case UNIX_SERVER:
    case PETER_LEWIS_SERVER:
    case MACHTEN_SERVER:
    case MSDOS_SERVER:
    case WINDOWS_NT_SERVER:
    case WINDOWS_2K_SERVER:
    case APPLESHARE_SERVER:
    case NETPRESENZ_SERVER:
	/*
	 * Check for EPLF output (local times).
	 */
	if (*entry == '+') {
	    parse_eplf_line(entry, entry_info);
	    break;
	}
d2204 14
a2217 23
	/*
	 * Interpret and edit LIST output from Unix server.
	 */
	len = strlen(entry);
	if (*first) {
	    /* don't gettext() this -- incoming text: */
	    if (!strcmp(entry, "can not access directory .")) {
		/*
		 * Don't reset *first, nothing real will follow.  - KW
		 */
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    *first = FALSE;
	    if (!strncmp(entry, "total ", 6) ||
		strstr(entry, "not available") != NULL) {
		entry_info->display = FALSE;
		return (entry_info);
	    } else if (unsure_type) {
		/* this isn't really a unix server! */
		server_type = GENERIC_SERVER;
		entry_info->display = FALSE;
		return (entry_info);
a2218 1
	}
a2219 4
	/*
	 * Check first character of ls -l output.
	 */
	if (TOUPPER(entry[0]) == 'D') {
d2221 24
a2244 11
	     * It's a directory.
	     */
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	} else if (entry[0] == 'l') {
	    /*
	     * It's a symbolic link, does the user care about knowing if it is
	     * symbolic?  I think so since it might be a directory.
	     */
	    StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
	    remove_size = TRUE;	/* size is not useful */
d2247 16
a2262 22
	     * Strip off " -> pathname".
	     */
	    for (i = len - 1; (i > 3) &&
		 (!isspace(UCH(entry[i])) ||
		  (entry[i - 1] != '>') ||
		  (entry[i - 2] != '-') ||
		  (entry[i - 3] != ' ')); i--) ;	/* null body */
	    if (i > 3) {
		entry[i - 3] = '\0';
		len = i - 3;
	    }
	}
	/* link */
	parse_ls_line(entry, entry_info);

	if (!strcmp(entry_info->filename, "..") ||
	    !strcmp(entry_info->filename, "."))
	    entry_info->display = FALSE;
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2264 14
a2277 6
    case VMS_SERVER:
	/*
	 * Interpret and edit LIST output from VMS server and convert
	 * information lines to zero length.
	 */
	parse_vms_dir_entry(entry, entry_info);
d2279 1
a2279 5
	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
d2281 7
a2287 13
	/*
	 * Trim off VMS directory extensions.
	 */
	len = strlen(entry_info->filename);
	if ((len > 4) && !strcmp(&entry_info->filename[len - 4], ".dir")) {
	    entry_info->filename[len - 4] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2289 6
a2294 6
    case MS_WINDOWS_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_ms_windows_dir_entry(entry, entry_info);
d2296 5
a2300 13
	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2302 13
a2314 22
#ifdef NOTDEFINED
    case WINDOWS_NT_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_windows_nt_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
#endif /* NOTDEFINED */
d2316 1
a2316 2
    case CMS_SERVER:
	{
d2318 4
a2321 4
	     * Interpret and edit LIST output from VM/CMS server and convert
	     * any information lines to zero length.
	     */
	    parse_cms_dir_entry(entry, entry_info);
d2324 2
a2325 2
	     * Get rid of any junk lines.
	     */
d2327 1
a2327 1
		return (entry_info);
d2330 1
a2330 1
		return (entry_info);
d2333 2
a2334 2
	     * Goto the bottom and get real type.
	     */
a2335 1
	}
d2337 61
a2397 8
    case NCSA_SERVER:
    case TCPC_SERVER:
	/*
	 * Directories identified by trailing "/" characters.
	 */
	StrAllocCopy(entry_info->filename, entry);
	len = strlen(entry);
	if (entry[len - 1] == '/') {
d2399 3
a2401 10
	     * It's a dir, remove / and mark it as such.
	     */
	    entry[len - 1] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
d2403 7
a2409 7
    default:
	/*
	 * We can't tell if it is a directory since we only did an NLST :( List
	 * bad file types anyways?  NOT!
	 */
	StrAllocCopy(entry_info->filename, entry);
	return (entry_info);	/* mostly empty info */
d2411 1
a2411 1
    }				/* switch (server_type) */
d2418 1
a2418 1
	if (((cp = strrchr(entry_info->filename, '.')) != NULL &&
d2422 4
a2425 4
	     * Don't treat this as application/x-Troff-me if it's a Unix server
	     * but has the string "read.me", or if it's not a Unix server.  -
	     * FM
	     */
d2435 2
a2436 2
     * Get real types eventually.
     */
d2440 1
a2440 2
	HTAtom *encoding;	/* @@@@ not used at all */

d2444 1
a2444 1
	    if (!strncmp(HTAtom_name(format), "application", 11)) {
d2446 1
a2446 1
		if (!strncmp(cp2, "x-", 2))
d2456 2
a2457 2
    return (entry_info);
}				/* parse_dir_entry */
d2459 3
a2461 1
static int compare_EntryInfo_structs(EntryInfo *entry1, EntryInfo *entry2)
d2466 18
a2483 4
    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size == entry2->size)
a2484 4
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
d2486 28
a2513 33
    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcmp(entry1->filename, entry2->filename));

    case FILE_BY_DATE:
	if (entry1->date && entry2->date) {
	    /*
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 || strlen(entry2->date) != 12) {
		return (strcmp(entry1->filename, entry2->filename));
	    }
	    /*
	     * Set the years and date,
	     * if we don't have them yet.
	     */
	    if (!HaveYears) {
		set_years_and_date();
	    }
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[9] == ':') {
		strcpy(date1, "9999");
		strcpy(time1, &entry1->date[7]);
		if (time1[0] == ' ') {
		    time1[0] = '0';
d2515 6
a2520 9
	    } else {
		strcpy(date1, &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
d2522 16
a2537 16
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    strncat(date1, &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ' || date1[6] == HT_NON_BREAK_SPACE) {
		date1[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date1[i] = LastYear[i];
d2539 10
a2548 7
	    }
	    strcat(date1, time1);
	    if (entry2->date[9] == ':') {
		strcpy(date2, "9999");
		strcpy(time2, &entry2->date[7]);
		if (time2[0] == ' ') {
		    time2[0] = '0';
d2550 6
a2555 9
	    } else {
		strcpy(date2, &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
d2557 16
a2572 16
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    strncat(date2, &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ' || date2[6] == HT_NON_BREAK_SPACE) {
		date2[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date2[i] = LastYear[i];
d2574 8
d2583 1
a2583 10
	    strcat(date2, time2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcmp(entry1->filename, entry2->filename));
d2585 3
a2587 3
    case FILE_BY_NAME:
    default:
	return (strcmp(entry1->filename, entry2->filename));
d2591 1
d2593 14
a2606 13
 *	--------------------------------------------------------------
 *
 * On entry,
 *	anchor		Parent anchor to link the this node to
 *	address		Address of the directory
 * On exit,
 *	returns		HT_LOADED if OK
 *			<0 if error.
 */
static int read_directory(HTParentAnchor *parent,
			  const char *address,
			  HTFormat format_out,
			  HTStream *sink)
d2610 1
a2610 1
    HTStructured *target = HTML_new(parent, format_out, sink);
d2616 1
a2616 1
    char *lastpath = NULL;	/* prefix for link, either "" (for root) or xxx  */
d2622 1
a2622 1
    _HTProgress(gettext("Receiving FTP directory."));
d2625 4
a2628 3
     * Force the current Date and Year (TheDate, ThisYear, and LastYear) to be
     * recalculated for each directory request.  Otherwise we have a problem
     * with long-running sessions assuming the wrong date for today.  - kw
d2632 3
a2634 3
     * Check whether we always want the home directory treated as Welcome.  -
     * FM
     */
d2639 6
a2644 4
     * This should always come back FALSE, since the flag is set only for local
     * directory listings if LONG_LIST was defined on compilation, but we could
     * someday set up an equivalent listing for Unix ftp servers.  - FM
     */
d2649 4
a2652 4
    if (*filename == '\0') {	/* Empty filename: use root. */
	StrAllocCopy(lastpath, "/");
    } else if (!strcmp(filename, "/")) {	/* Root path. */
	StrAllocCopy(lastpath, "/foo/..");
d2654 1
a2654 1
	char *p = strrchr(filename, '/');	/* Find the lastslash. */
d2658 1
a2658 1
	    StrAllocCopy(lastpath, filename);	/* Use absolute path for CMS. */
d2660 1
a2660 1
	    StrAllocCopy(lastpath, p + 1);	/* Take slash off the beginning. */
d2662 5
a2666 5
	if ((cp = strrchr(lastpath, ';')) != NULL) {	/* Trim type= param. */
	    if (!strncasecomp((cp + 1), "type=", 5)) {
		if (TOUPPER(*(cp + 6)) == 'D' ||
		    TOUPPER(*(cp + 6)) == 'A' ||
		    TOUPPER(*(cp + 6)) == 'I')
d2671 1
a2671 1
    FREE(filename);
d2674 1
a2674 1
	HTBTree *bt = HTBTree_new((HTComparer) compare_EntryInfo_structs);
d2676 1
a2676 1
	HTChunk *chunk = HTChunkCreate(128);
d2681 1
a2681 2

	PUTC('\n');		/* prettier LJM */
d2687 2
a2688 2
			"read_directory: interrupted after %d bytes\n",
			BytesReceived));
d2700 1
a2700 1
	    /*   read directory entry
d2703 1
a2703 1
	    for (;;) {		/* Read in one line as filename */
d2705 1
a2705 1
	      AgainForMultiNet:
d2708 2
a2709 2
			    "read_directory: interrupted_in_next_data_char after %d bytes\n",
			    BytesReceived));
d2712 1
a2712 1
			goto unload_btree;	/* unload btree */
d2719 2
a2720 2
		} else if ((char) ic == CR || (char) ic == LF) {	/* Terminator? */
		    if (chunk->size != 0) {	/* got some text */
d2723 1
a2723 1
			    /* Deal with MultiNet's wrapping of long lines - F.M. */
d2725 1
a2725 1
				*(data_read_pointer + 1) == ' ')
d2744 2
a2745 1
			    } else
d2747 2
a2748 1
			} else
d2752 1
a2752 1
		    break;	/* End of file */
d2754 1
a2754 1
		    HTChunkPutc(chunk, (char) ic);
d2762 2
a2763 2
		sprintf(NumBytes, gettext("Transferred %d bytes (%5d)"),
			BytesReceived, ws_read_per_sec);
d2772 1
a2772 1
		/* 1 means empty: includes terminating 0 */
d2775 1
a2775 1
		    lastpath, chunk->data));
d2781 1
a2781 1
			entry_info->filename));
d2788 1
a2788 1
	}			/* next entry */
d2790 1
a2790 1
      unload_btree:
d2811 1
a2811 1
	/* PUTS("    Date        Type             Size     Filename\n");
d2817 1
a2817 1
#ifdef SH_EX			/* 1997/10/18 (Sat) 14:14:28 */
d2819 1
a2819 1
	    int name_len, dot_len;
d2825 1
a2825 1
	    HTBTElement *ele;
a2826 1

d2830 1
a2830 1
		entry_info = (EntryInfo *) HTBTree_object(ele);
d2848 1
a2848 1
#ifdef SH_EX			/* 1997/10/18 (Sat) 16:00 */
d2871 1
a2871 1
#ifdef SH_EX			/* 1998/02/02 (Mon) 16:34:52 */
d2874 1
a2874 1
				entry_info->size);
d2877 1
a2877 1
				entry_info->size / 1024);
d2881 1
a2881 1
				entry_info->size);
d2884 1
a2884 1
				entry_info->size / 1024);
d2889 1
a2889 1
		PUTC('\n');	/* end of this entry */
d2901 1
a2901 1
    if (WasInterrupted || data_soc != -1) {	/* should always be true */
d2903 5
a2907 4
	 * Without closing the data socket first, the response(0) later may
	 * hang.  Some servers expect the client to fin/ack the close of the
	 * data connection before proceeding with the conversation on the
	 * control connection.  - kw
d2925 3
a2927 2
static int setup_connection(const char *name,
			    HTParentAnchor *anchor)
d2939 1
a2939 1
    for (retry = 0; retry < 2; retry++) {	/* For timed out/broken connections */
d2947 1
a2947 1
		NETCLOSE(control->socket);
d2951 1
a2951 1
		    (void) close_master_socket();
d2953 1
a2953 1
		close_master_socket();
d2959 1
d2961 2
a2962 2
	    /*  Inform the server of the port number we will listen on
	     */
d2966 2
a2967 2
		_HTProgress(CONNECTION_INTERRUPTED);
		NETCLOSE(control->socket);
d2969 1
a2969 1
		close_master_socket();
d2972 1
a2972 1
	    if (status != 2) {	/* Could have timed out */
d2974 2
a2975 2
		    continue;	/* try again - net error */
		return -status;	/* bad reply */
d2982 1
a2982 2
	    int h0, h1, h2, h3, p0, p1;		/* Parts of reply */

d2984 1
a2984 1
	    char dst[LINE_LENGTH + 1];
d3003 2
a3004 1
		for (p = response_text; *p && *p != ','; p++) ;		/* null body */
d3006 4
a3009 3
		while (--p > response_text && '0' <= *p && *p <= '9') ;		/* null body */
		status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
				&h0, &h1, &h2, &h3, &p0, &p1);
d3014 1
a3014 1
		passive_port = (p0 << 8) + p1;
d3024 4
a3027 5
		for (p = response_text; *p && !isspace(*p); p++) ;	/* null body */
		for ( /*nothing */ ;
		     *p && *p && *p != '(';
		     p++)	/*) */
		    ;		/* null body */
d3036 2
a3037 2
		if (getpeername(control->socket, (struct sockaddr *) &ss,
				&sslen) < 0) {
d3041 2
a3042 2
		if (getnameinfo((struct sockaddr *) &ss, sslen, dst,
				sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
d3051 2
a3052 2
		    continue;	/* retry or Bad return */
		return -status;	/* bad reply */
d3054 2
a3055 1
	    for (p = response_text; *p && *p != ','; p++) ;	/* null body */
d3057 2
a3058 1
	    while (--p > response_text && '0' <= *p && *p <= '9') ;	/* null body */
d3060 1
a3060 1
	    status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
d3066 1
a3066 1
	    passive_port = (PortNumber) ((p0 << 8) + p1);
d3069 1
a3069 1
		    passive_port));
d3077 1
a3077 1
		       STR_FTP_URL, h0, h1, h2, h3, passive_port);
d3085 1
a3085 1
		return status;	/* Bad return */
d3091 1
a3091 1
	break;			/* No more retries */
d3093 1
a3093 1
    }				/* for retries */
d3098 13
a3110 12
 *	-------------------------
 *
 * On entry,
 *	name		WWW address of a file: document, including hostname
 * On exit,
 *	returns		Socket number for file if good.
 *			<0 if bad.
 */
int HTFTPLoad(const char *name,
	      HTParentAnchor *anchor,
	      HTFormat format_out,
	      HTStream *sink)
d3113 1
a3113 1
    HTAtom *encoding = NULL;
a3115 1

d3120 1
a3120 5
    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n",
	    name,
	    (ftp_local_passive
	     ? "passive"
	     : "normal")));
d3122 1
a3122 1
    HTReadProgress(0, 0);
d3132 1
a3132 1
	char *fname = filename;	/* Save for subsequent free() */
d3139 1
a3139 1
	    /* If the unescaped path has a %2f, reject it as illegal. - FM */
d3143 1
a3143 1
		init_help_message_cache();	/* to free memory */
d3146 1
a3146 2
		CTRACE((tfp,
			"HTFTP: Rejecting path due to illegal escaped slash.\n"));
d3156 4
a3159 4
	     * Check and trim the type= parameter.  - FM
	     */
	    if (!strncasecomp((type + 1), "type=", 5)) {
		switch (TOUPPER(*(type + 6))) {
d3178 1
a3178 1
		    *(filename + 1) = '\0';
d3189 3
a3191 3
	     * Check if translation of HOME as tilde is supported,
	     * and adjust filename if so. - FM
	     */
d3195 1
a3195 1
	    if ((cp2 = strchr((filename + 1), '/')) != NULL) {
d3200 1
a3200 1
		status = send_cwd(filename + 1);
d3202 1
a3202 1
		    StrAllocCopy(fn, (filename + 1));
d3205 1
a3205 1
			if (fn[strlen(fn) - 1] != '/') {
d3208 1
a3208 1
			    StrAllocCat(fn, (cp2 + 1));
d3222 1
a3222 2

	    if (((cp2 = strrchr(filename, '.')) != NULL &&
d3226 4
a3229 4
		 * Don't treat this as application/x-Troff-me if it's a Unix
		 * server but has the string "read.me", or if it's not a Unix
		 * server.  - FM
		 */
d3247 1
a3247 1
			 encoding != HTAtom_for("7bit"));
d3249 7
a3255 6
	/*
	 * Force binary if we're in source, download or dump mode and this is
	 * not a VM/CMS server, so we don't get CRLF instead of LF (or CR) for
	 * newlines in text files.  Can't do this for VM/CMS or we'll get raw
	 * EBCDIC.  - FM
	 */
d3263 2
a3264 2
	     * Force binary if we had ;type=I - FM
	     */
d3268 2
a3269 2
	     * Force ASCII if we had ;type=A - FM
	     */
d3274 3
a3276 4
	     * Act on our setting if not already set.  - FM
	     */
	    char *mode = binary ? "I" : "A";

d3279 1
a3279 1
		init_help_message_cache();	/* to free memory */
d3285 5
a3289 5
	    /*
	     * Handle what for Lynx are special case servers, e.g., for which
	     * we respect RFC 1738, or which have known conflicts in suffix
	     * mappings.  - FM
	     */
d3291 45
a3335 56
	    {
		char *cp1, *cp2;
		BOOL included_device = FALSE;
		BOOL found_tilde = FALSE;

		/* Accept only Unix-style filename */
		if (strchr(filename, ':') != NULL ||
		    strchr(filename, '[') != NULL) {
		    FREE(fname);
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    CTRACE((tfp,
			    "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
		    return -1;
		}
		/* Handle any unescaped "/%2F" path */
		if (!strncmp(filename, "//", 2)) {
		    int i;

		    included_device = TRUE;
		    for (i = 0; filename[(i + 1)]; i++)
			filename[i] = filename[(i + 1)];
		    filename[i] = '\0';
		    CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		    cp = HTVMS_name("", filename);
		    CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
		    if ((cp1 = strrchr(cp, ']')) != NULL) {
			strcpy(filename, ++cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			*cp1 = '\0';
			status = send_cwd(cp);
			if (status != 2) {
			    char *dotslash = 0;

			    if ((cp1 = strchr(cp, '[')) != NULL) {
				*cp1++ = '\0';
				status = send_cwd(cp);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
				HTSprintf0(&dotslash, "[.%s", cp1);
				status = send_cwd(dotslash);
				FREE(dotslash);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
			    } else {
d3337 1
a3337 1
				init_help_message_cache();	/* to free memory */
d3342 6
d3349 12
a3360 8
		    } else if ((cp1 = strchr(cp, ':')) != NULL &&
			       strchr(cp, '[') == NULL &&
			       strchr(cp, ']') == NULL) {
			cp1++;
			if (*cp1 != '\0') {
			    strcpy(filename, cp1);
			    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			    HTSprintf0(&vmsname, "%.*s[%s]", cp1 - cp, cp, filename);
d3363 1
a3363 1
				HTSprintf(&vmsname, "%.*s[000000]", cp1 - cp, cp);
d3366 5
a3370 9
				    HTSprintf(&vmsname, "%.*s", cp1 - cp, cp);
				    status = send_cwd(vmsname);
				    if (status != 2) {
					FREE(fname);
					init_help_message_cache();
					NETCLOSE(control->socket);
					control->socket = -1;
					return ((status < 0) ? status : -status);
				    }
a3371 3
			    } else {
				HTSprintf0(&vmsname, "000000");
				filename = vmsname;
d3373 3
a3376 15
		    } else if (0 == strcmp(cp, (filename + 1))) {
			status = send_cwd(cp);
			if (status != 2) {
			    HTSprintf0(&vmsname, "%s:", cp);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			}
			HTSprintf0(&vmsname, "000000");
			filename = vmsname;
d3378 2
a3379 9
		}
		/* Trim trailing slash if filename is not the top directory */
		if (strlen(filename) > 1 && filename[strlen(filename) - 1] == '/')
		    filename[strlen(filename) - 1] = '\0';

#ifdef MAINTAIN_CONNECTION	/* Don't need this if always new connection - F.M. */
		if (!included_device) {
		    /* Get the current default VMS device:[directory] */
		    status = send_cmd_1("PWD");
d3381 2
a3382 24
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Go to the VMS account's top directory */
		    if ((cp = strchr(response_text, '[')) != NULL &&
			(cp1 = strrchr(response_text, ']')) != NULL) {
			char *tmp = 0;
			unsigned len = 4;

			StrAllocCopy(tmp, cp);
			if ((cp2 = strchr(cp, '.')) != NULL && cp2 < cp1) {
			    len += (cp2 - cp);
			} else {
			    len += (cp1 - cp);
			}
			tmp[len] = 0;
			StrAllocCat(tmp, "]");

			status = send_cwd(tmp);
			FREE(tmp);

d3391 2
d3394 10
a3403 8
#endif /* MAINTAIN_CONNECTION */

		/* If we want the VMS account's top directory, list it now */
		if (!(strcmp(filename, "/~")) ||
		    (included_device && 0 == strcmp(filename, "000000")) ||
		    (strlen(filename) == 1 && *filename == '/')) {
		    isDirectory = YES;
		    status = send_cmd_1("LIST");
d3405 4
a3408 9
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
d3410 3
a3412 10
		/* Otherwise, go to appropriate directory and doctor filename */
		if (!strncmp(filename, "/~", 2)) {
		    filename += 2;
		    found_tilde = TRUE;
		}
		CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
		if (!included_device &&
		    (cp = strchr(filename, '/')) != NULL &&
		    (cp1 = strrchr(cp, '/')) != NULL &&
		    (cp1 - cp) > 1) {
d3414 1
d3416 8
a3423 6
		    HTSprintf0(&tmp, "[.%.*s]", cp1 - cp - 1, cp + 1);

		    CTRACE((tfp, "change path '%s'\n", tmp));
		    while ((cp2 = strrchr(tmp, '/')) != NULL)
			*cp2 = '.';
		    CTRACE((tfp, "...to  path '%s'\n", tmp));
d3430 1
a3430 1
			init_help_message_cache();	/* to free memory */
a3434 5
		    filename = cp1 + 1;
		} else {
		    if (!included_device && !found_tilde) {
			filename += 1;
		    }
a3435 1
		break;
d3437 56
d3494 15
a3508 29
	    {
		/*
		 * If we want the CMS account's top directory, or a base SFS or
		 * anonymous directory path (i.e., without a slash), list it
		 * now.  FM
		 */
		if ((strlen(filename) == 1 && *filename == '/') ||
		    ((0 == strncasecomp((filename + 1), "vmsysu:", 7)) &&
		     (cp = strchr((filename + 1), '.')) != NULL &&
		     strchr(cp, '/') == NULL) ||
		    (0 == strncasecomp(filename + 1, "anonymou.", 9) &&
		     strchr(filename + 1, '/') == NULL)) {
		    if (filename[1] != '\0') {
			status = send_cwd(filename + 1);
			if (status != 2) {
			    /* Action not started */
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		    isDirectory = YES;
		    if (use_list)
			status = send_cmd_1("LIST");
		    else
			status = send_cmd_1("NLST");
		    FREE(fname);
		    if (status != 1) {
d3510 1
a3510 1
			init_help_message_cache();	/* to free memory */
a3514 2
		    /* Big goto! */
		    goto listen;
d3516 17
a3532 1
		filename++;
d3534 18
a3551 23
		/* Otherwise, go to appropriate directory and adjust filename */
		while ((cp = strchr(filename, '/')) != NULL) {
		    *cp++ = '\0';
		    status = send_cwd(filename);
		    if (status == 2) {
			if (*cp == '\0') {
			    isDirectory = YES;
			    if (use_list)
				status = send_cmd_1("LIST");
			    else
				status = send_cmd_1("NLST");
			    FREE(fname);
			    if (status != 1) {
				/* Action not started */
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			    /* Clear any messages from the login directory */
			    init_help_message_cache();
			    /* Big goto! */
			    goto listen;
d3553 4
a3556 1
			filename = cp;
d3558 1
a3559 1
		break;
d3561 2
d3564 1
a3564 1
	    /* Shift for any unescaped "/%2F" path */
d3570 3
a3572 3
	 * Act on a file or listing request, or try to figure out which we're
	 * dealing with if we don't know yet.  - FM
	 */
d3596 1
a3596 1
	    /* Clear any login messages if this isn't the login directory */
d3622 2
a3623 2
  listen:
    if (!ftp_local_passive) {
a3626 1

d3630 1
a3630 2
	int soc_addrlen = sizeof(soc_address);

d3634 2
a3635 2
			     (struct sockaddr *) &soc_address,
			     (void *) &soc_addrlen);
d3638 3
a3640 3
	    status = accept(master_socket,
			    (struct sockaddr *) &soc_address,
			    (void *) &soc_addrlen);
d3647 3
a3649 3
    }
    /* !ftp_local_passive */
#if 0				/* no - this makes the data connection go away too soon (2.8.3dev.22) */
d3661 1
a3661 1
	final_status = read_directory(anchor, name, format_out, sink);
d3677 1
a3677 1
	if (data_soc != -1) {	/* normally done in read_directory */
d3688 1
a3688 1
	/* Clear any login messages */
d3691 1
a3691 1
	/* Fake a Content-Encoding for compressed files. - FM */
d3695 3
a3697 2
	     * We already know from the call to HTFileFormat above that this is
	     * a compressed file, no need to look at the filename again.  - kw
d3731 1
a3731 1
	_HTProgress(gettext("Receiving FTP file."));
d3738 1
a3738 1
#if 0				/* any known servers where ABOR would work this way? */
d3755 1
a3755 1
	    status = 2;		/* data_soc already closed in HTCopy - kw */
d3761 1
a3761 1
		status = response(0);	/* Pick up final reply */
d3763 2
a3764 2
		    data_soc = -1;	/* invalidate it */
		    init_help_message_cache();	/* to free memory */
d3780 1
a3780 1
    data_soc = -1;		/* invalidate it */
d3791 2
a3792 2
    init_help_message_cache();	/* to free memory */
    /* returns HT_LOADED (always for file if we get here) or error */
d3794 1
a3794 1
}				/* open_file_read */
d3797 4
a3800 4
 *  This function frees any user entered password, so that
 *  it must be entered again for a future request. - FM
 */
void HTClearFTPPassword(void)
d3803 5
a3807 4
     * Need code to check cached documents from non-anonymous ftp accounts and
     * do something to ensure that they no longer can be accessed without a new
     * retrieval.  - FM
     */
d3810 3
a3812 2
     * Now free the current user entered password, if any.  - FM
     */
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a1388 1
    char *linkname;
a1398 1
	FREE(entry_info->linkname);
a1648 1
	StrAllocCopy(entry_info->linkname, LYSkipBlanks(cps + 3));
a2156 1
    entry_info->linkname = NULL;
a2275 1
		StrAllocCopy(entry_info->linkname, LYSkipBlanks(entry + i));
d2814 1
a2814 1
#define	FILE_GAP	1
d2844 1
a2844 1
		sprintf(name_buff, "%-*s", FNAME_WIDTH, entry_info->filename);
d2850 1
a2850 1
			while (dot_len-- > 0)
a2879 3
		} else if (entry_info->linkname != 0) {
		    PUTS(" -> ");
		    PUTS(entry_info->linkname);
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a3727 3
		case cftDeflate:
		    StrAllocCopy(anchor->content_encoding, "x-deflate");
		    break;
d3731 1
a3731 1
		case cftNone:
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d60 1
a60 1
#if defined(DJGPP) && !defined(WATT32)
d69 3
a71 2
#include <HTTCP.h>
#include <HTFont.h>
d83 3
d88 1
d109 4
d153 14
a166 18
typedef enum {
	GENERIC_SERVER
	, MACHTEN_SERVER
	, UNIX_SERVER
	, VMS_SERVER
	, CMS_SERVER
	, DCTS_SERVER
	, TCPC_SERVER
	, PETER_LEWIS_SERVER
	, NCSA_SERVER
	, WINDOWS_NT_SERVER
	, WINDOWS_2K_SERVER
	, MS_WINDOWS_SERVER
	, MSDOS_SERVER
	, APPLESHARE_SERVER
	, NETPRESENZ_SERVER
	, DLS_SERVER
} eServerType;
d168 1
a168 1
PRIVATE eServerType server_type = GENERIC_SERVER; /* the type of ftp host */
d175 1
a175 1
PRIVATE PortNumber	port_number = FIRST_TCP_PORT;
d182 1
a182 1
PRIVATE PortNumber	passive_port;	/* Port server specified for data */
d212 1
a212 1
/* PUBLIC						HTVMS_name()
d223 1
a223 1
PUBLIC char * HTVMS_name ARGS2(
d235 1
a235 1
    static char *vmsname;
d268 1
a268 1
	HTSprintf0(&vmsname, "%s%s", nodename, filename + 1);
d271 1
a271 1
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename+1, second+1);
d277 1
a277 1
	HTSprintf0(&vmsname, "%s%s:[%s]%s",
d310 1
a310 1
    return UCH(*data_read_pointer++);
d322 3
a324 4
    int status;
    CTRACE((tfp, "HTFTP: Closing control socket %d\n", con->socket));
    status = NETCLOSE(con->socket);
    if (TRACE && status != 0) {
d326 2
a327 4
	CTRACE((tfp, "HTFTP:close_connection: %s", LYStrerror(errno)));
#else
	if (con->socket != INVSOC)
	    HTInetStatus("HTFTP:close_connection");
d361 1
a361 1
    CTRACE((tfp,"Adding message to help cache: %s\n",string));
d373 7
a379 2
/*	Send One Command
**	----------------
d381 2
a382 2
**	This function checks whether we have a control connection, and sends
**	one command if given.
d385 2
a386 2
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
d388 1
a388 1
**	The command should already be terminated with the CRLF pair.
d391 2
a392 3
**	returns:  1 for success,
**		  or negative for communication failure (in which case
**		  the control connection will be closed).
d394 1
a394 1
PRIVATE int write_cmd ARGS1(
d397 2
d402 1
a402 1
	CTRACE((tfp, "HTFTP: No control connection set up!!\n"));
d407 1
a407 1
	CTRACE((tfp, "  Tx: %s", cmd));
d418 2
a419 2
	    CTRACE((tfp, "HTFTP: Error %d sending command: closing socket %d\n",
			status, control->socket));
a423 33
    return 1;
}

/*	Execute Command and get Response
**	--------------------------------
**
**	See the state machine illustrated in RFC959, p57. This implements
**	one command/reply sequence.  It also interprets lines which are to
**	be continued, which are marked with a "-" immediately after the
**	status code.
**
**	Continuation then goes on until a line with a matching reply code
**	an a space after it.
**
** On entry,
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
**
**	The command must already be terminated with the CRLF pair.
**
** On exit,
**	returns:  The first digit of the reply type,
**		  or negative for communication failure.
*/
PRIVATE int response ARGS1(
	char *,		cmd)
{
    int result;				/* Three-digit decimal code */
    int continuation_response = -1;
    int status;

    if ((status = write_cmd(cmd)) < 0)
	return status;
d429 1
a429 1
	    if (((*p++ = (char) ich) == LF)
d435 1
a435 1
		    CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
d442 1
a442 1
		CTRACE((tfp, "    Rx: %s", response_text));
d463 1
a463 1
		CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
d470 2
a471 2
		CTRACE((tfp, "Error on rx: closing socket %d\n",
			    control->socket));
d481 2
a482 2
	CTRACE((tfp, "HTFTP: They close so we close socket %d\n",
		    control->socket));
d524 1
a524 1
	eServerType,	ServerType)
d543 1
a543 1
	eServerType *,	ServerType,
d559 1
a559 1
	    CTRACE((tfp, "HTFTP: Treating as %s server.\n",
d561 1
a561 1
						 "NCSA" : "TCPC")));
d568 1
a568 1
		CTRACE((tfp, "HTFTP: Treating as NCSA server.\n"));
d572 1
a572 1
		 CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d579 1
a579 1
	    CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
d582 1
a582 1
	    CTRACE((tfp, "HTFTP: Treating as Generic server.\n"));
a592 39
/* This function turns MSDOS-like directory output off for
 * Windows NT servers.
 */

PRIVATE void set_unix_dirstyle ARGS2(
	eServerType *,	ServerType,
	BOOLEAN *,	UseList)
{

    char *cp;
    /* This is a toggle.  It seems we have to toggle in order to see
     * the current state (after toggling), so we may end up toggling
     * twice.  - kw
     */
    int status = response("SITE DIRSTYLE\r\n");
    if (status != 2) {
	*ServerType = GENERIC_SERVER;
	CTRACE((tfp, "HTFTP: DIRSTYLE failed, treating as Generic server.\n"));
	return;
    } else {
	*UseList = TRUE;
	/* Expecting one of:
	 * 200 MSDOS-like directory output is off
	 * 200 MSDOS-like directory output is on
	 * The following code doesn't look for the full exact string -
	 * who knows how the wording may change in some future version.
	 * If the first response isn't recognized, we toggle again
	 * anyway, under the assumption that it's more likely that
	 * the MSDOS setting was "off" originally. - kw
	 */
	cp = strstr(response_text+4, "MSDOS");
	if (cp && strstr(cp, " off")) {
	    return;		/* already off now. */
	} else {
	    response("SITE DIRSTYLE\r\n");
	}
    }
}

d643 1
a643 1
	con = typecalloc(connection);
a653 1
    CTRACE((tfp, "get_connection(%s)\n", arg));
d710 1
a710 1
	    CTRACE((tfp, "HTFTP: Interrupted on connect\n"));
d712 2
a713 2
	    CTRACE((tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
			arg));
d733 2
a734 2
    CTRACE((tfp, "FTP connected, socket %d  control %ld\n",
		con->socket, (long)con));
d747 1
a747 1
	CTRACE((tfp, "HTFTP: Interrupted at beginning of login.\n"));
d776 1
a776 1
	    CTRACE((tfp, "HTFTP: Interrupted while sending username.\n"));
d833 2
a834 1
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
d846 1
a846 1
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
d855 1
a855 1
	CTRACE((tfp, "HTFTP: Login fail: %s", response_text));
d859 1
a859 1
    CTRACE((tfp, "HTFTP: Logged in.\n"));
d871 1
a871 1
	    CTRACE((tfp, "HTFTP: Treating as MachTen server.\n"));
a875 1
	    unsure_type = FALSE; /* to the best of out knowledge... */
d877 1
a877 1
	    CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d882 1
a882 1
	    CTRACE((tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n"));
d885 1
a885 1
	    char *tilde = strstr(arg, "/~");
d887 1
a887 9
	    if (tilde != 0
	     && tilde[2] != 0
	     && strstr(response_text+4, "MadGoat") != 0) {
		server_type = UNIX_SERVER;
		CTRACE((tfp, "HTFTP: Treating VMS as UNIX server.\n"));
	    } else {
		server_type = VMS_SERVER;
		CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	    }
d893 1
a893 1
	    CTRACE((tfp, "HTFTP: Treating as CMS server.\n"));
d897 1
a897 1
	    CTRACE((tfp, "HTFTP: Treating as DCTS server.\n"));
d901 1
a901 1
	    CTRACE((tfp, "HTFTP: Looks like a TCPC server.\n"));
d908 1
a908 1
	    CTRACE((tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n"));
d914 1
a914 1
	    CTRACE((tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n"));
d918 2
a919 7
	    CTRACE((tfp, "HTFTP: Treating as Window_NT server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (strncmp(response_text+4, "Windows2000", 11) == 0) {
	    server_type = WINDOWS_2K_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_2K server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);
d924 1
a924 1
	    CTRACE((tfp, "HTFTP: Treating as MS Windows server.\n"));
d931 1
a931 1
	    CTRACE((tfp, "HTFTP: Treating as AppleShare server.\n"));
d935 1
a935 1
	    CTRACE((tfp, "HTFTP: Ugh!  A Generic server.\n"));
d954 1
a954 1
	CTRACE((tfp, "HTFTP: Port defined.\n"));
d973 1
a973 1
    CTRACE((tfp, "HTFTP: Closed master socket %d\n", master_socket));
a997 6
#ifdef INET6
    struct sockaddr_storage soc_address;	/* Binary network address */
    struct sockaddr_in* soc_in = (struct sockaddr_in *)&soc_address;
    int af;
    int slen;
#else
a999 1
#endif /* INET6 */
a1010 11
#ifdef INET6
    /* query address family of control connection */
    slen = sizeof(soc_address);
    if (getsockname(control->socket, (struct sockaddr *)&soc_address,
		&slen) < 0) {
	return HTInetStatus("getsockname failed");
    }
    af = ((struct sockaddr *)&soc_address)->sa_family;
    memset(&soc_address, 0, sizeof(soc_address));
#endif /* INET6 */

a1012 3
#ifdef INET6
    new_socket = socket(af, SOCK_STREAM, IPPROTO_TCP);
#else
a1013 1
#endif /* INET6 */
d1018 1
a1018 1
    CTRACE((tfp, "HTFTP: Opened master socket number %d\n", new_socket));
a1021 18
#ifdef INET6
    memset(&soc_address, 0, sizeof(soc_address));
    ((struct sockaddr *)&soc_address)->sa_family = af;
    switch (af) {
    case AF_INET:
#ifdef SIN6_LEN
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in);
#endif /* SIN6_LEN */
	break;
    case AF_INET6:
#ifdef SIN6_LEN
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in6);
#endif /* SIN6_LEN */
	break;
    default:
	HTInetStatus("AF");
    }
#else
a1023 1
#endif /* INET6 */
d1026 1
a1026 1
	PortNumber old_port_number = port_number;
a1033 3
#ifdef INET6
	    soc_in->sin_port = htons(port_number);
#else
a1034 1
#endif /* INET6 */
d1040 1
a1040 1
			SOCKADDR_LEN(soc_address)
d1044 1
a1044 1
						)) == 0) {
d1046 1
a1046 1
		} else
d1051 1
a1051 2
		    SOCKADDR_LEN(soc_address)
		    )) == 0) {
d1053 2
a1054 3
	    }
	    CTRACE((tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		port_number, status, SOCKET_ERRNO));
d1072 2
a1073 8
#ifdef INET6
	CTRACE((tfp, "HTFTP: This host is %s\n",
	    HTInetString((SockA *)soc_in)));

	soc_in->sin_port = 0;	/* Unspecified: please allocate */
#else
	CTRACE((tfp, "HTFTP: This host is %s\n",
	    HTInetString(soc_in)));
a1075 1
#endif /* INET6 */
a1082 3
#ifdef INET6
			socks_bind_remoteAddr
#else
a1083 1
#endif /* INET6 */
d1091 1
a1091 2
		    SOCKADDR_LEN(soc_address)
		    );
d1109 1
a1109 2
#ifdef INET6
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
d1111 1
a1111 6
		HTInetString((SockA *)soc_in)));
#else
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
		(int)ntohs(soc_in->sin_port),
		HTInetString(soc_in)));
#endif /* INET6 */
d1116 1
a1116 1
#endif /* REPEAT_LISTEN */
d1123 1
a1123 5
#ifdef INET6
    switch (((struct sockaddr *)&soc_address)->sa_family) {
    case AF_INET:
#endif /* INET6 */
	sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
a1131 2
#ifdef INET6
	break;
d1133 4
a1136 22
    case AF_INET6:
      {
	char hostbuf[MAXHOSTNAMELEN];
	char portbuf[MAXHOSTNAMELEN];
	getnameinfo((struct sockaddr *)&soc_address,
	    SOCKADDR_LEN(soc_address),
	    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
	    NI_NUMERICHOST | NI_NUMERICSERV);
	sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		CR, LF);
	break;
      }
    default:
	sprintf(port_command, "JUNK%c%c", CR, LF);
	break;
    }
#endif /* INET6 */

    /*	Inform TCP that we will accept connections
    */
    {
	int status;
d1138 3
a1140 3
	if (socks_flag)
	    status = Rlisten(master_socket, 1);
	else
d1142 4
a1145 5
	    status = listen(master_socket, 1);
	if (status < 0) {
	    master_socket = -1;
	    return HTInetStatus("listen");
	}
d1147 2
a1148 1
    CTRACE((tfp, "TCP: Master socket(), bind() and listen() all OK\n"));
d1184 1
d1192 2
a1193 1
    sprintf(date, "9999%02d%.2s", i, day);
d1232 1
a1232 1
    if (!isalpha(UCH(*s++)) || !isalpha(UCH(*s++)) || !isalpha(UCH(*s++)))
d1243 1
a1243 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
d1250 1
a1250 1
    if (!isdigit(UCH(*s++)))
d1258 1
a1258 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
d1265 1
a1265 1
    if (!isdigit(UCH(*s++)))
d1269 1
a1269 1
    if (!(*s == ':' || isdigit(UCH(*s)))) {
d1276 1
a1276 1
    if (!isdigit(UCH(*s++)))
d1280 1
a1280 1
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
a1338 1
		/* FALLTHRU */
d1357 1
a1357 1
    int    i, j;
d1362 1
a1362 1
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i-12])); i--)
d1378 1
a1378 1
    while (isdigit(UCH(line[j]))) {
a1387 105
 * parse_dls_line() --
 *	Extract the name and size info and whether it refers to a
 *      directory from a LIST line in "dls" format.
 */
PRIVATE void parse_dls_line ARGS3(
	char *,		line,
	EntryInfo *,	entry_info,
	char **,	pspilledname)
{
    short  j;
    int    base=1;
    int    size_num=0;
    int    len;
    char *cps = NULL;

    /* README		   763	Information about this server\0
       bin/		     -	\0
       etc/		     =	\0
       ls-lR		     0	\0
       ls-lR.Z		     3	\0
       pub/		     =	Public area\0
       usr/		     -	\0
       morgan		    14	-> ../real/morgan\0
       TIMIT.mostlikely.Z\0
			 79215	\0
	*/

    len = strlen(line);
    if (len == 0) {
	FREE(*pspilledname);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(line);
    if (*cps == '\0') {		/* only a filename, save it and return. */
	StrAllocCopy(*pspilledname, line);
	entry_info->display = FALSE;
	return;
    }
    if (len < 24 || line[23] != ' ' ||
	(isspace(UCH(line[0])) && !*pspilledname)) {
	/* this isn't the expected "dls" format! */
	if (!isspace(UCH(line[0])))
	    *cps = '\0';
	if (*pspilledname && !*line) {
	    entry_info->filename = *pspilledname;
	    *pspilledname = NULL;
	    if (entry_info->filename[strlen(entry_info->filename)-1] == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	} else {
	    StrAllocCopy(entry_info->filename, line);
	    if (cps && cps != line && *(cps-1) == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	    FREE(*pspilledname);
	}
	return;
    }

    j = 22;
    if (line[j] == '=' || line[j] == '-') {
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    } else {
	while (isdigit(UCH(line[j]))) {
	    size_num += (line[j] - '0') * base;
	    base *= 10;
	    j--;
	}
    }
    entry_info->size = size_num;

    cps = LYSkipBlanks(&line[23]);
    if (!strncmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
	StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
	entry_info->size = 0;	/* don't display size */
    }

    if (j > 0)
	line[j] = '\0';

    LYTrimTrailing(line);

    len = strlen(line);
    if (len == 0 && *pspilledname && **pspilledname) {
	line = *pspilledname;
	len = strlen(*pspilledname);
    }
    if (len > 0 && line[len-1] == '/') {
		/*
		**  It's a dir, remove / and mark it as such.
		*/
	if (len > 1)
	    line[len-1] = '\0';
	if (!entry_info->type)
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    }

    StrAllocCopy(entry_info->filename, line);
    FREE(*pspilledname);
} /* parse_dls_line() */

/*
d1460 2
a1461 2
	strlen(cpd) > 9 && isdigit(UCH(*(cpd-1))) &&
	isalpha(UCH(*(cpd+1))) && *(cpd+4) == '-') {
d1464 5
a1468 3
	*(cpd+2) = (char) TOLOWER(*(cpd+2));
	*(cpd+3) = (char) TOLOWER(*(cpd+3));
	sprintf(date, "%.3s ", cpd+1);
d1471 3
a1473 2
	if (isdigit(UCH(*(cpd-2))))
	    sprintf(date+4, "%.2s ", cpd-2);
d1475 2
a1476 1
	    sprintf(date+4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd-1);
d1481 3
a1483 1
	    sprintf(date+7, "%.5s", cpd+10);
d1485 3
a1487 1
	    sprintf(date+7, " %.4s", cpd+5);
d1497 1
a1497 1
	while (isdigit(UCH(*(cps-1))))
d1503 1
a1503 1
	while (isdigit(UCH(*cps)))
d1516 1
a1516 1
	    while (isdigit(UCH(*cpd)))
d1527 1
a1527 1
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %d\n",
d1530 1
a1530 1
		entry_info->size));
d1565 1
a1565 1
	if (isdigit(UCH(*cps))) {
d1588 1
a1588 1
		sprintf(date, "%.6s  %.4s", cpd, (cpd+7));
d1591 1
a1591 1
		sprintf(date, "%.6s %.5s", cpd, (cpd+12));
d1600 1
a1600 1
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %d\n",
d1603 1
a1603 1
		entry_info->size));
d1669 1
a1669 1
	sprintf(date, "%.3s %.2s", months[i], (cp+3));
d1676 1
a1676 1
		sprintf(&date[6], "  20%.2s", cp);
d1678 1
a1678 1
		sprintf(&date[6], "  19%.2s", cp);
d1686 3
a1688 1
	    sprintf(&date[6], " %02d:%.2s", i, (cpd+3));
d1711 1
a1711 1
    CTRACE((tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
d1714 1
a1714 1
		entry_info->size));
d1785 1
a1785 1
	if (isdigit(UCH(*cp))) {
d1796 1
a1796 1
	if (isdigit(UCH(*cp))) {
d1815 1
a1815 1
	 isdigit(UCH(*(cps+1))) && isdigit(UCH(*(cps+2))) && *(cps+3) == ':')) {
d1827 1
a1827 1
	    sprintf(date, "%.3s %.2s", months[i], (cpd+3));
d1834 1
a1834 1
		    sprintf(&date[6], "  20%.2s", cpd);
d1836 1
a1836 1
		    sprintf(&date[6], "  19%.2s", cpd);
d1842 2
a1843 1
		sprintf(&date[6], " %02d:%.2s", i, (cps+3));
d1853 1
a1853 1
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %d\n",
d1856 1
a1856 1
		entry_info->size));
d1868 1
a1868 1
PRIVATE EntryInfo * parse_dir_entry ARGS3(
d1870 1
a1870 2
	BOOLEAN *,	first,
	char **,	pspilledname)
a1887 45
	case DLS_SERVER:

	    /*
	    **	Interpret and edit LIST output from a Unix server
	    **  in "dls" format.
	    **  This one must have claimed to be Unix in order to
	    **  get here; if the first line looks fishy, we revert
	    **  to Unix and hope that fits better (this recovery is
	    **  untested). - kw
	    */

	    if (*first) {
		len = strlen(entry);
		if (!len || entry[0] == ' ' ||
		    (len >= 24 && entry[23] != ' ') ||
		    (len < 24 && strchr(entry, ' '))) {
		    server_type = UNIX_SERVER;
		    CTRACE((tfp,
			   "HTFTP: Falling back to treating as Unix server.\n"));
		} else {
		    *first = FALSE;
		}
	    }

	    if (server_type == DLS_SERVER) {
		/* if still unchanged... */
		parse_dls_line(entry, entry_info, pspilledname);

		if (!entry_info->filename || *entry_info->filename == '\0') {
		    entry_info->display = FALSE;
		    return(entry_info);
		}
		if (!strcmp(entry_info->filename,"..") ||
		    !strcmp(entry_info->filename,"."))
		    entry_info->display = FALSE;
		if (entry_info->type && *entry_info->type == '\0') {
		    FREE(entry_info->type);
		    return(entry_info);
		}
		/*
		**	Goto the bottom and get real type.
		*/
		break;
	    } /* fall through if server_type changed for *first == TRUE ! */

a1892 1
	case WINDOWS_2K_SERVER:
d1951 1
a1951 1
				  (!isspace(UCH(entry[i])) ||
d2206 1
a2206 1
		sprintf(month, "%02d", i);
d2213 1
a2213 5
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
d2219 9
a2227 5
		if (entry2->date[9] == ':') {
		    strcpy(date2, "9999");
		    strcpy(time2, &entry2->date[7]);
		    if (time2[0] == ' ') {
			time2[0] = '0';
a2228 4
		} else {
		    strcpy(date2, &entry2->date[8]);
		    strcpy(time2, "00:00");
		}
d2237 1
a2237 1
		sprintf(month, "%02d", i);
d2244 1
a2244 5
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
a2299 7
     *  Force the current Date and Year (TheDate, ThisYear, and LastYear)
     *  to be recalculated for each directory request.  Otherwise we have
     *  a problem with long-running sessions assuming the wrong date for
     *  today. - kw
     */
    HaveYears = FALSE;
    /*
a2348 1
	char *spilledname = NULL;
a2353 3
		CTRACE((tfp,
		       "read_directory: interrupted after %d bytes\n",
		       BytesReceived));
a2359 1
		    FREE(spilledname);
a2365 1
	    interrupted_in_next_data_char = FALSE;
a2369 3
		    CTRACE((tfp,
			   "read_directory: interrupted_in_next_data_char after %d bytes\n",
			   BytesReceived));
a2375 1
			FREE(spilledname);
a2419 6
#ifdef _WINDOWS
		extern int ws_read_per_sec;

		sprintf(NumBytes,gettext("Transferred %d bytes (%5d)"),
				BytesReceived, ws_read_per_sec);
#else
a2420 1
#endif
d2428 2
a2429 2
	    CTRACE((tfp, "HTFTP: Line in %s is %s\n",
			lastpath, chunk->data));
d2431 1
a2431 1
	    entry_info = parse_dir_entry(chunk->data, &first, &spilledname);
d2433 2
a2434 3
		FREE(spilledname);
		CTRACE((tfp, "Adding file to BTree: %s\n",
			    entry_info->filename));
a2445 1
	FREE(spilledname);
a2468 8
#ifdef SH_EX	/* 1997/10/18 (Sat) 14:14:28 */
	    char *p, name_buff[256];
	    int  name_len, dot_len;

#define	FNAME_WIDTH	30
#define	FILE_GAP	2

#endif
d2484 1
a2484 1
		    for (i = 0; entry_info->type[i] != '\0' && i < 16; i++)
a2491 18
#ifdef SH_EX	/* 1997/10/18 (Sat) 16:00 */
		name_len = strlen(entry_info->filename);

		sprintf(name_buff, "%-30s", entry_info->filename);

		if (name_len < FNAME_WIDTH) {
		    dot_len = FNAME_WIDTH - FILE_GAP - name_len;
		    if (dot_len > 0) {
			p = name_buff + name_len + 1;
			while (dot_len--)
			    *p++ = '.';
		    }
		} else {
		    name_buff[FNAME_WIDTH] = '\0';
		}

		PUTS(name_buff);
#else
a2492 1
#endif
a2495 8
#ifdef SH_EX	/* 1998/02/02 (Mon) 16:34:52 */
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "%6d bytes",
					       entry_info->size);
		    else
			sprintf(string_buffer, "%6d Kb",
						entry_info->size/1024);
#else
a2501 1
#endif
d2517 2
a2518 1
    if (WasInterrupted || data_soc != -1) { /* should always be true */
d2521 1
a2521 4
	 *  the response(0) later may hang.
	 *  Some servers expect the client to fin/ack the close
	 *  of the data connection before proceeding with the
	 *  conversation on the control connection. - kw
d2523 1
a2523 5
	CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	status = NETCLOSE(data_soc);
	if (status == -1)
	    HTInetStatus("close");	/* Comment only */
	data_soc = -1;
d2527 2
d2530 1
d2532 2
d2535 3
d2557 1
a2557 1
    int status, final_status;
a2558 3
    int outstanding = 1;	/* outstanding control connection responses
				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
d2561 1
a2566 1
    HTReadProgress(0,0);
a2577 4
#ifdef INET6
		if (master_socket >= 0)
		    (void)close_master_socket ();
#else
a2578 1
#endif /* INET6 */
d2585 1
a2585 1
	    /*	Inform the server of the port number we will listen on
d2589 1
a2589 1
		CTRACE((tfp, "HTFTP: Interrupted in response (port_command)\n"));
d2601 1
a2601 1
	    CTRACE((tfp, "HTFTP: Port defined.\n"));
d2604 1
a2604 1
	    char *command = NULL;
d2606 1
a2606 4
	    int h0, h1, h2, h3, p0, p1;	/* Parts of reply */
#ifdef INET6
	    char dst[LINE_LENGTH+1];
#endif
a2609 59
#ifdef INET6
	    status = send_cmd_1(p = "EPSV");
	    if (status < 0)	/* retry or Bad return */
		continue;
	    else if (status != 2) {
		status = send_cmd_1(p = "PASV");
		if (status < 0)	/* retry or Bad return */
		    continue;
		else if (status != 2) {
		    return -status;	/* bad reply */
		}
	    }

	    if (strcmp(p, "PASV") == 0) {
		for (p = response_text; *p && *p != ','; p++)
		    ; /* null body */

		while (--p > response_text && '0' <= *p && *p <= '9')
		    ; /* null body */
		status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
		       &h0, &h1, &h2, &h3, &p0, &p1);
		if (status < 4) {
		    fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		    return -99;
		}
		passive_port = (p0<<8) + p1;
		snprintf(dst, sizeof(dst), "%d.%d.%d.%d", h0, h1, h2, h3);
	    } else if (strcmp(p, "EPSV") == 0) {
		unsigned char c0, c1, c2, c3;
		struct sockaddr_storage ss;
		int sslen;

		/*
		 * EPSV bla (|||port|)
		 */
		for (p = response_text; *p && !isspace(*p); p++)
		    ; /* null body */
		for (/*nothing*/; *p && *p && *p != '('; p++)	/*)*/
		    ; /* null body */
		status = sscanf(p, "(%c%c%c%d%c)", &c0, &c1, &c2, &p0, &c3);
		if (status != 5) {
		    fprintf(tfp, "HTFTP: EPSV reply has invalid format!\n");
		    return -99;
		}
		passive_port = p0;

		sslen = sizeof(ss);
		if (getpeername(control->socket, (struct sockaddr *)&ss,
		    &sslen) < 0) {
		    fprintf(tfp, "HTFTP: getpeername(control) failed\n");
		    return -99;
		}
		if (getnameinfo((struct sockaddr *)&ss, sslen, dst,
		    sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
		    fprintf(tfp, "HTFTP: getnameinfo failed\n");
		    return -99;
		}
	    }
#else
d2622 16
a2637 21
	    status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
			    &h0, &h1, &h2, &h3, &p0, &p1);
	    if (status < 4) {
		fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		return -99;
	    }
	    passive_port = (PortNumber)((p0<<8) + p1);
#endif /* INET6 */
	    CTRACE((tfp, "HTFTP: Server is listening on port %d\n",
			 passive_port));

	    /* Open connection for data:  */

#ifdef INET6
	    HTSprintf0(&command, "ftp://%s:%d/", dst, passive_port);
#else
	    HTSprintf0(&command, "ftp://%d.%d.%d.%d:%d/",
		    h0, h1, h2, h3, passive_port);
#endif
	    status = HTDoConnect(command, "FTP data", passive_port, &data_soc);
	    FREE(command);
d2645 1
a2645 1
	    CTRACE((tfp, "FTP data connected, socket %d\n", data_soc));
a2658 1
	char *vmsname = NULL;
d2671 1
a2671 1
		CTRACE((tfp, "HTFTP: Rejecting path due to illegal escaped slash.\n"));
d2707 1
a2707 1
		CTRACE((tfp, "HTFTP: type=%s\n", type));
d2711 1
a2711 1
	CTRACE((tfp, "HTFTP: UnEscaped %s\n", filename));
d2771 1
a2771 1
	binary = (BOOL) (encoding != HTAtom_for("8bit") &&
a2818 1
	    BOOL found_tilde = FALSE;
d2826 1
a2826 1
		CTRACE((tfp, "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
d2836 3
a2838 3
		CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		cp = HTVMS_name("", filename);
		CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
d2840 5
a2844 2
		    strcpy(filename, ++cp1);
		    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
d2882 9
a2890 4
			strcpy(filename, cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			HTSprintf0(&vmsname, "%.*s[%s]", cp1-cp, cp, filename);
			status = send_cwd(vmsname);
d2892 3
a2894 2
			    HTSprintf(&vmsname, "%.*s[000000]", cp1-cp, cp);
			    status = send_cwd(vmsname);
d2896 2
a2897 2
				HTSprintf(&vmsname, "%.*s", cp1-cp, cp);
				status = send_cwd(vmsname);
d2907 2
a2908 2
			    HTSprintf0(&vmsname, "000000");
			    filename = vmsname;
d2914 2
a2915 2
			HTSprintf0(&vmsname, "%s:", cp);
			status = send_cwd(vmsname);
d2924 2
a2925 2
		    HTSprintf0(&vmsname, "000000");
		    filename = vmsname;
d2990 1
a2990 1
	    if (!strncmp(filename, "/~", 2)) {
d2992 1
a2992 3
		found_tilde = TRUE;
	    }
	    CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
d3001 1
a3001 1
		CTRACE((tfp, "change path '%s'\n", tmp));
d3004 1
a3004 1
		CTRACE((tfp, "...to  path '%s'\n", tmp));
d3018 1
a3018 1
		if (!included_device && !found_tilde) {
a3123 1
	FREE(vmsname);
d3136 1
a3136 1
    if(!ftp_local_passive) {
a3137 3
#ifdef INET6
	struct sockaddr_storage soc_address;
#else
a3138 1
#endif /* INET6 */
d3154 1
a3154 1
	CTRACE((tfp, "TCP: Accepted new socket %d\n", status));
a3157 5
#if 0	/* no - this makes the data connection go away too soon (2.8.3dev.22) */
    if ((status = send_cmd_nowait("QUIT")) == 1)
	outstanding++;
#endif

d3159 7
a3165 29
	if (server_type == UNIX_SERVER && !unsure_type &&
	    !strcmp(response_text,
		    "150 Opening ASCII mode data connection for /bin/dl.\n")) {
	    CTRACE((tfp, "HTFTP: Treating as \"dls\" server.\n"));
	    server_type = DLS_SERVER;
	}
	final_status = read_directory (anchor, name, format_out, sink);
	if (final_status > 0) {
	    if (server_type != CMS_SERVER)
		if (outstanding-- > 0) {
		    status = response(0);
		    if (status < 0 ||
			(status == 2 && !strncmp(response_text, "221", 3)))
			outstanding = 0;
		}
	} else {		/* HT_INTERRUPTED */
	    /* User may have pressed 'z' to give up because no
	       packets got through, so let's not make them wait
	       any longer - kw */
	    outstanding = 0;
	}

	if (data_soc != -1) { /* normally done in read_directory */
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	    if (status == -1)
		HTInetStatus("close");	/* Comment only */
	}
	status = final_status;
d3168 1
d3186 5
a3190 3
	} else {
	    char *dot;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &dot);
d3192 1
a3192 2
	    if (cft != cftNone) {
		*dot = '\0';
d3196 1
d3198 9
a3206 6

		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    break;
		case cftGzip:
d3208 1
a3208 6
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    break;
		default:
		    break;
d3217 3
d3223 2
a3224 20
	if (rv < 0) {
#if 0	/* any known servers where ABOR would work this way? */
	    if (rv == HT_INTERRUPTED || rv == -501)
		if (send_cmd_nowait("ABOR") == 1) {
		    outstanding++;
		    CTRACE((tfp, "HTFTP: outstanding responses: %d\n", outstanding));
		}
#endif
	    if (rv == -2)	/* weird error, don't expect much response */
		outstanding--;
	    else if (rv == HT_INTERRUPTED || rv == -1)
		/* User may have pressed 'z' to give up because no
		   packets got through, so let's not make them wait
		   longer - kw */
		outstanding = 0;
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	} else
	    status = 2;	/* data_soc already closed in HTCopy - kw */

d3227 1
d3229 12
a3240 19
	    if (rv != HT_LOADED && outstanding--) {
		status = response(0);		/* Pick up final reply */
		if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		    data_soc = -1;		/* invalidate it */
		    init_help_message_cache();  /* to free memory */
		    return HTLoadError(sink, 500, response_text);
		} else if (status <= 0) {
		    outstanding = 0;
		} else if (status == 2 && !strncmp(response_text, "221", 3))
		    outstanding = 0;
	    }
	}
	final_status = HT_LOADED;
    }
    while (outstanding-- > 0 &&
	   (status > 0)) {
	status = response(0);
	if (status == 2 && !strncmp(response_text, "221", 3))
	    break;
a3241 14
    data_soc = -1;			/* invalidate it */
    CTRACE((tfp, "HTFTPLoad: normal end; "));
    if (control->socket < 0) {
	CTRACE((tfp, "control socket is %d\n", control->socket));
    } else {
	CTRACE((tfp, "closing control socket %d\n", control->socket));
	status = NETCLOSE(control->socket);
	if (status == -1)
	    HTInetStatus("control connection close");	/* Comment only */
    }
    control->socket = -1;
    init_help_message_cache();  /* to free memory */
      /* returns HT_LOADED (always for file if we get here) or error */
    return final_status;
@

