head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.1
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.1
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.30;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.24;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.58;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.05;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.48;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.10;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/*                                            Utilities for the Authorization parts of libwww
             COMMON PARTS OF AUTHORIZATION MODULE TO BOTH SERVER AND BROWSER

   This module is the interface to the common parts of Access Authorization (AA) package
   for both server and browser.  Important to know about memory allocation:

   Routines in this module use dynamic allocation, but free automatically all the memory
   reserved by them.

   Therefore the caller never has to (and never should) free() any object returned by
   these functions.

   Therefore also all the strings returned by this package are only valid until the next
   call to the same function is made. This approach is selected, because of the nature of
   access authorization: no string returned by the package needs to be valid longer than
   until the next call.

   This also makes it easy to plug the AA package in: you don't have to ponder whether to
   free() something here or is it done somewhere else (because it is always done somewhere
   else).

   The strings that the package needs to store are copied so the original strings given as
   parameters to AA functions may be freed or modified with no side effects.

   Also note: The AA package does not free() anything else than what it has itself
   allocated.

 */

#ifndef HTAAUTIL_H
#define HTAAUTIL_H

#include <HTList.h>

#ifdef __cplusplus
extern "C" {
#endif
/*
 * Numeric constants
 */
#define MAX_USERNAME_LEN        16	/* @@@@ Longest allowed username    */
#define MAX_PASSWORD_LEN        3*13	/* @@@@ Longest allowed password    */
    /* (encrypted, so really only 3*8) */
#define MAX_METHODNAME_LEN      12	/* @@@@ Longest allowed method name */
#define MAX_FIELDNAME_LEN       16	/* @@@@ Longest field name in       */
    /* protection setup file          */
#define MAX_PATHNAME_LEN        80	/* @@@@ Longest passwd/group file   */
/* pathname to allow               *//*

   Datatype definitions

   HTAASCHEME

   The enumeration HTAAScheme represents the possible authentication schemes used by the
   WWW Access Authorization.

 */ typedef enum {
	HTAA_UNKNOWN,
	HTAA_NONE,
	HTAA_BASIC,
	HTAA_PUBKEY,
	HTAA_KERBEROS_V4,
	HTAA_KERBEROS_V5,
	HTAA_MAX_SCHEMES	/* THIS MUST ALWAYS BE LAST! Number of schemes */
    } HTAAScheme;

/*

  ENUMERATION TO REPRESENT HTTP METHODS

 */

    typedef enum {
	METHOD_UNKNOWN,
	METHOD_GET,
	METHOD_PUT
    } HTAAMethod;

/*

Authentication Schemes

 */

/* PUBLIC                                               HTAAScheme_enum()
 *              TRANSLATE SCHEME NAME TO A SCHEME ENUMERATION
 * ON ENTRY:
 *      name            is a string representing the scheme name.
 *
 * ON EXIT:
 *      returns         the enumerated constant for that scheme.
 */
    extern HTAAScheme HTAAScheme_enum(const char *name);

/* PUBLIC                                               HTAAScheme_name()
 *                      GET THE NAME OF A GIVEN SCHEME
 * ON ENTRY:
 *      scheme          is one of the scheme enum values:
 *                      HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
 *
 * ON EXIT:
 *      returns         the name of the scheme, i.e.
 *                      "none", "basic", "pubkey", ...
 */
    extern const char *HTAAScheme_name(HTAAScheme scheme);

/*

Methods

 */

/* PUBLIC                                                   HTAAMethod_enum()
 *              TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
 * ON ENTRY:
 *      name            is the method name to translate.
 *
 * ON EXIT:
 *      returns         HTAAMethod enumerated value corresponding
 *                      to the given name.
 */
    extern HTAAMethod HTAAMethod_enum(const char *name);

/* PUBLIC                                               HTAAMethod_name()
 *                      GET THE NAME OF A GIVEN METHOD
 * ON ENTRY:
 *      method          is one of the method enum values:
 *                      METHOD_GET, METHOD_PUT, ...
 *
 * ON EXIT:
 *      returns         the name of the scheme, i.e.
 *                      "GET", "PUT", ...
 */
    extern const char *HTAAMethod_name(HTAAMethod method);

/* PUBLIC                                               HTAAMethod_inList()
 *              IS A METHOD IN A LIST OF METHOD NAMES
 * ON ENTRY:
 *      method          is the method to look for.
 *      list            is a list of method names.
 *
 * ON EXIT:
 *      returns         YES, if method was found.
 *                      NO, if not found.
 */
    extern BOOL HTAAMethod_inList(HTAAMethod method, HTList *list);

/*

Match Template Against Filename

 */

/* PUBLIC                                               HTAA_templateMatch()
 *              STRING COMPARISON FUNCTION FOR FILE NAMES
 *                 WITH ONE WILDCARD * IN THE TEMPLATE
 * NOTE:
 *      This is essentially the same code as in HTRules.c, but it
 *      cannot be used because it is embedded in between other code.
 *      (In fact, HTRules.c should use this routine, but then this
 *       routine would have to be more sophisticated... why is life
 *       sometimes so hard...)
 *
 * ON ENTRY:
 *      ctemplate       is a template string to match the file name
 *                      against, may contain a single wildcard
 *                      character * which matches zero or more
 *                      arbitrary characters.
 *      filename        is the filename (or pathname) to be matched
 *                      against the template.
 *
 * ON EXIT:
 *      returns         YES, if filename matches the template.
 *                      NO, otherwise.
 */
    extern BOOL HTAA_templateMatch(const char *ctemplate,
				   const char *filename);

/* PUBLIC                                               HTAA_templateCaseMatch()
 *              STRING COMPARISON FUNCTION FOR FILE NAMES
 *                 WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
 * NOTE:
 *      This is essentially the same code as in HTAA_templateMatch, but
 *      it compares case insensitive (for VMS). Reason for this routine
 *      is that HTAA_templateMatch gets called from several places, also
 *      there where a case sensitive match is needed, so one cannot just
 *      change the HTAA_templateMatch routine for VMS.
 *
 * ON ENTRY:
 *      ctemplate       is a template string to match the file name
 *                      against, may contain a single wildcard
 *                      character * which matches zero or more
 *                      arbitrary characters.
 *      filename        is the filename (or pathname) to be matched
 *                      against the template.
 *
 * ON EXIT:
 *      returns         YES, if filename matches the template.
 *                      NO, otherwise.
 */
    extern BOOL HTAA_templateCaseMatch(const char *ctemplate,
				       const char *filename);

/* PUBLIC                                       HTAA_makeProtectionTemplate()
 *              CREATE A PROTECTION TEMPLATE FOR THE FILES
 *              IN THE SAME DIRECTORY AS THE GIVEN FILE
 *              (Used by server if there is no fancier way for
 *              it to tell the client, and by browser if server
 *              didn't send WWW-ProtectionTemplate: field)
 * ON ENTRY:
 *      docname is the document pathname (from URL).
 *
 * ON EXIT:
 *      returns a template matching docname, and other files
 *              files in that directory.
 *
 *              E.g.  /foo/bar/x.html  =>  /foo/bar/ *
 *                                                  ^
 *                              Space only to prevent it from
 *                              being a comment marker here,
 *                              there really isn't any space.
 */
    extern char *HTAA_makeProtectionTemplate(const char *docname);

/*

MIME Argument List Parser

 */

/* PUBLIC                                               HTAA_parseArgList()
 *              PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
 * ON ENTRY:
 *      str     is a comma-separated list:
 *
 *                      item, item, item
 *              where
 *                      item ::= value
 *                             | name=value
 *                             | name="value"
 *
 *              Leading and trailing whitespace is ignored
 *              everywhere except inside quotes, so the following
 *              examples are equal:
 *
 *                      name=value,foo=bar
 *                       name="value",foo="bar"
 *                        name = value ,  foo = bar
 *                         name = "value" ,  foo = "bar"
 *
 * ON EXIT:
 *      returns a list of name-value pairs (actually HTAssocList*).
 *              For items with no name, just value, the name is
 *              the number of order number of that item. E.g.
 *              "1" for the first, etc.
 */
    extern HTList *HTAA_parseArgList(char *str);

/*

Header Line Reader

 */

/* PUBLIC                                               HTAA_setupReader()
 *              SET UP HEADER LINE READER, i.e., give
 *              the already-read-but-not-yet-processed
 *              buffer of text to be read before more
 *              is read from the socket.
 * ON ENTRY:
 *      start_of_headers is a pointer to a buffer containing
 *                      the beginning of the header lines
 *                      (rest will be read from a socket).
 *      length          is the number of valid characters in
 *                      'start_of_headers' buffer.
 *      soc             is the socket to use when start_of_headers
 *                      buffer is used up.
 * ON EXIT:
 *      returns         nothing.
 *                      Subsequent calls to HTAA_getUnfoldedLine()
 *                      will use this buffer first and then
 *                      proceed to read from socket.
 */
    extern void HTAA_setupReader(char *start_of_headers,
				 int length,
				 int soc);

/* PUBLIC                                               HTAA_getUnfoldedLine()
 *              READ AN UNFOLDED HEADER LINE FROM SOCKET
 * ON ENTRY:
 *      HTAA_setupReader must absolutely be called before
 *      this function to set up internal buffer.
 *
 * ON EXIT:
 *      returns a newly-allocated character string representing
 *              the read line.  The line is unfolded, i.e.
 *              lines that begin with whitespace are appended
 *              to current line.  E.g.
 *
 *                      Field-Name: Blaa-Blaa
 *                       This-Is-A-Continuation-Line
 *                       Here-Is_Another
 *
 *              is seen by the caller as:
 *
 *      Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
 *
 */
    extern char *HTAA_getUnfoldedLine(void);

#ifdef __cplusplus
}
#endif
#endif				/* NOT HTAAUTIL_H */
@


1.5
log
@automatic merge of lynx-current
@
text
@d35 3
d43 1
a43 1
					/* (encrypted, so really only 3*8) */
d46 1
a46 1
					/* protection setup file          */
d48 1
a48 1
					/* pathname to allow               */
d50 1
a50 3
/*

Datatype definitions
d52 1
a52 1
  HTAASCHEME
d57 9
a65 11
 */

typedef enum {
    HTAA_UNKNOWN,
    HTAA_NONE,
    HTAA_BASIC,
    HTAA_PUBKEY,
    HTAA_KERBEROS_V4,
    HTAA_KERBEROS_V5,
    HTAA_MAX_SCHEMES		/* THIS MUST ALWAYS BE LAST! Number of schemes */
} HTAAScheme;
d73 5
a77 5
typedef enum {
    METHOD_UNKNOWN,
    METHOD_GET,
    METHOD_PUT
} HTAAMethod;
d93 1
a93 1
extern HTAAScheme HTAAScheme_enum(const char *name);
d105 1
a105 1
extern char *HTAAScheme_name(HTAAScheme scheme);
d122 1
a122 1
extern HTAAMethod HTAAMethod_enum(const char *name);
d134 1
a134 1
extern char *HTAAMethod_name(HTAAMethod method);
d146 1
a146 1
extern BOOL HTAAMethod_inList(HTAAMethod method, HTList *list);
d165 1
a165 1
 *      template        is a template string to match the file name
d176 2
a177 2
extern BOOL HTAA_templateMatch(const char *template,
			       const char *filename);
d190 1
a190 1
 *      template        is a template string to match the file name
d201 2
a202 2
extern BOOL HTAA_templateCaseMatch(const char *template,
				   const char *filename);
d223 1
a223 1
extern char *HTAA_makeProtectionTemplate(const char *docname);
d257 1
a257 1
extern HTList *HTAA_parseArgList(char *str);
d284 3
a286 3
extern void HTAA_setupReader(char *start_of_headers,
			     int length,
			     int soc);
d309 1
a309 1
extern char *HTAA_getUnfoldedLine(void);
d311 4
a314 1
#endif /* NOT HTAAUTIL_H */
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d36 10
a45 10
** Numeric constants
*/
#define MAX_USERNAME_LEN        16      /* @@@@ Longest allowed username    */
#define MAX_PASSWORD_LEN        3*13    /* @@@@ Longest allowed password    */
                                        /* (encrypted, so really only 3*8)*/
#define MAX_METHODNAME_LEN      12      /* @@@@ Longest allowed method name */
#define MAX_FIELDNAME_LEN       16      /* @@@@ Longest field name in       */
                                        /* protection setup file          */
#define MAX_PATHNAME_LEN        80      /* @@@@ Longest passwd/group file   */
                                        /* pathname to allow               */
d65 1
a65 1
    HTAA_MAX_SCHEMES /* THIS MUST ALWAYS BE LAST! Number of schemes */
d87 8
a94 9
**              TRANSLATE SCHEME NAME TO A SCHEME ENUMERATION
** ON ENTRY:
**      name            is a string representing the scheme name.
**
** ON EXIT:
**      returns         the enumerated constant for that scheme.
*/
extern HTAAScheme HTAAScheme_enum (const char* name);

d97 10
a106 10
**                      GET THE NAME OF A GIVEN SCHEME
** ON ENTRY:
**      scheme          is one of the scheme enum values:
**                      HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
**
** ON EXIT:
**      returns         the name of the scheme, i.e.
**                      "none", "basic", "pubkey", ...
*/
extern char *HTAAScheme_name (HTAAScheme scheme);
d115 9
a123 10
**              TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
** ON ENTRY:
**      name            is the method name to translate.
**
** ON EXIT:
**      returns         HTAAMethod enumerated value corresponding
**                      to the given name.
*/
extern HTAAMethod HTAAMethod_enum (const char * name);

d126 10
a135 10
**                      GET THE NAME OF A GIVEN METHOD
** ON ENTRY:
**      method          is one of the method enum values:
**                      METHOD_GET, METHOD_PUT, ...
**
** ON EXIT:
**      returns         the name of the scheme, i.e.
**                      "GET", "PUT", ...
*/
extern char *HTAAMethod_name (HTAAMethod method);
d137 11
a148 12
/* PUBLIC                                               HTAAMethod_inList()
**              IS A METHOD IN A LIST OF METHOD NAMES
** ON ENTRY:
**      method          is the method to look for.
**      list            is a list of method names.
**
** ON EXIT:
**      returns         YES, if method was found.
**                      NO, if not found.
*/
extern BOOL HTAAMethod_inList (HTAAMethod        method,
                                     HTList *           list);
d156 23
a178 24
**              STRING COMPARISON FUNCTION FOR FILE NAMES
**                 WITH ONE WILDCARD * IN THE TEMPLATE
** NOTE:
**      This is essentially the same code as in HTRules.c, but it
**      cannot be used because it is embedded in between other code.
**      (In fact, HTRules.c should use this routine, but then this
**       routine would have to be more sophisticated... why is life
**       sometimes so hard...)
**
** ON ENTRY:
**      template        is a template string to match the file name
**                      against, may contain a single wildcard
**                      character * which matches zero or more
**                      arbitrary characters.
**      filename        is the filename (or pathname) to be matched
**                      against the template.
**
** ON EXIT:
**      returns         YES, if filename matches the template.
**                      NO, otherwise.
*/
extern BOOL HTAA_templateMatch (const char * template,
                                       const char * filename);

d181 23
a203 23
**              STRING COMPARISON FUNCTION FOR FILE NAMES
**                 WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
** NOTE:
**      This is essentially the same code as in HTAA_templateMatch, but
**      it compares case insensitive (for VMS). Reason for this routine
**      is that HTAA_templateMatch gets called from several places, also
**      there where a case sensitive match is needed, so one cannot just
**      change the HTAA_templateMatch routine for VMS.
**
** ON ENTRY:
**      template        is a template string to match the file name
**                      against, may contain a single wildcard
**                      character * which matches zero or more
**                      arbitrary characters.
**      filename        is the filename (or pathname) to be matched
**                      against the template.
**
** ON EXIT:
**      returns         YES, if filename matches the template.
**                      NO, otherwise.
*/
extern BOOL HTAA_templateCaseMatch (const char * template,
                                         const char * filename);
d205 20
a225 20
/* PUBLIC                                       HTAA_makeProtectionTemplate()
**              CREATE A PROTECTION TEMPLATE FOR THE FILES
**              IN THE SAME DIRECTORY AS THE GIVEN FILE
**              (Used by server if there is no fancier way for
**              it to tell the client, and by browser if server
**              didn't send WWW-ProtectionTemplate: field)
** ON ENTRY:
**      docname is the document pathname (from URL).
**
** ON EXIT:
**      returns a template matching docname, and other files
**              files in that directory.
**
**              E.g.  /foo/bar/x.html  =>  /foo/bar/ *
**                                                  ^
**                              Space only to prevent it from
**                              being a comment marker here,
**                              there really isn't any space.
*/
extern char *HTAA_makeProtectionTemplate (const char * docname);
a231 1

d233 26
a258 26
**              PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
** ON ENTRY:
**      str     is a comma-separated list:
**
**                      item, item, item
**              where
**                      item ::= value
**                             | name=value
**                             | name="value"
**
**              Leading and trailing whitespace is ignored
**              everywhere except inside quotes, so the following
**              examples are equal:
**
**                      name=value,foo=bar
**                       name="value",foo="bar"
**                        name = value ,  foo = bar
**                         name = "value" ,  foo = "bar"
**
** ON EXIT:
**      returns a list of name-value pairs (actually HTAssocList*).
**              For items with no name, just value, the name is
**              the number of order number of that item. E.g.
**              "1" for the first, etc.
*/
extern HTList *HTAA_parseArgList (char * str);
d267 21
a287 22
**              SET UP HEADER LINE READER, i.e., give
**              the already-read-but-not-yet-processed
**              buffer of text to be read before more
**              is read from the socket.
** ON ENTRY:
**      start_of_headers is a pointer to a buffer containing
**                      the beginning of the header lines
**                      (rest will be read from a socket).
**      length          is the number of valid characters in
**                      'start_of_headers' buffer.
**      soc             is the socket to use when start_of_headers
**                      buffer is used up.
** ON EXIT:
**      returns         nothing.
**                      Subsequent calls to HTAA_getUnfoldedLine()
**                      will use this buffer first and then
**                      proceed to read from socket.
*/
extern void HTAA_setupReader (char *     start_of_headers,
                                     int        length,
                                     int        soc);

d290 21
a310 21
**              READ AN UNFOLDED HEADER LINE FROM SOCKET
** ON ENTRY:
**      HTAA_setupReader must absolutely be called before
**      this function to set up internal buffer.
**
** ON EXIT:
**      returns a newly-allocated character string representing
**              the read line.  The line is unfolded, i.e.
**              lines that begin with whitespace are appended
**              to current line.  E.g.
**
**                      Field-Name: Blaa-Blaa
**                       This-Is-A-Continuation-Line
**                       Here-Is_Another
**
**              is seen by the caller as:
**
**      Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
**
*/
extern char *HTAA_getUnfoldedLine (void);
d312 1
a312 1
#endif  /* NOT HTAAUTIL_H */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d94 1
a94 1
PUBLIC HTAAScheme HTAAScheme_enum PARAMS((CONST char* name));
d107 1
a107 1
PUBLIC char *HTAAScheme_name PARAMS((HTAAScheme scheme));
d124 1
a124 1
PUBLIC HTAAMethod HTAAMethod_enum PARAMS((CONST char * name));
d137 1
a137 1
PUBLIC char *HTAAMethod_name PARAMS((HTAAMethod method));
d150 2
a151 2
PUBLIC BOOL HTAAMethod_inList PARAMS((HTAAMethod        method,
                                     HTList *           list));
d180 2
a181 2
PUBLIC BOOL HTAA_templateMatch PARAMS((CONST char * template,
                                       CONST char * filename));
d206 2
a207 2
PUBLIC BOOL HTAA_templateCaseMatch PARAMS((CONST char * template,
                                         CONST char * filename));
d229 1
a229 1
PUBLIC char *HTAA_makeProtectionTemplate PARAMS((CONST char * docname));
d263 1
a263 1
PUBLIC HTList *HTAA_parseArgList PARAMS((char * str));
d290 1
a290 1
PUBLIC void HTAA_setupReader PARAMS((char *     start_of_headers,
d292 1
a292 1
                                     int        soc));
d316 1
a316 1
PUBLIC char *HTAA_getUnfoldedLine NOPARAMS;
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a34 3
#ifdef __cplusplus
extern "C" {
#endif
d36 12
a47 10
 * Numeric constants
 */
#define MAX_USERNAME_LEN        16	/* @@@@ Longest allowed username    */
#define MAX_PASSWORD_LEN        3*13	/* @@@@ Longest allowed password    */
    /* (encrypted, so really only 3*8) */
#define MAX_METHODNAME_LEN      12	/* @@@@ Longest allowed method name */
#define MAX_FIELDNAME_LEN       16	/* @@@@ Longest field name in       */
    /* protection setup file          */
#define MAX_PATHNAME_LEN        80	/* @@@@ Longest passwd/group file   */
/* pathname to allow               *//*
d49 1
a49 1
   Datatype definitions
d51 1
a51 1
   HTAASCHEME
d56 11
a66 9
 */ typedef enum {
	HTAA_UNKNOWN,
	HTAA_NONE,
	HTAA_BASIC,
	HTAA_PUBKEY,
	HTAA_KERBEROS_V4,
	HTAA_KERBEROS_V5,
	HTAA_MAX_SCHEMES	/* THIS MUST ALWAYS BE LAST! Number of schemes */
    } HTAAScheme;
d74 5
a78 5
    typedef enum {
	METHOD_UNKNOWN,
	METHOD_GET,
	METHOD_PUT
    } HTAAMethod;
d87 9
a95 8
 *              TRANSLATE SCHEME NAME TO A SCHEME ENUMERATION
 * ON ENTRY:
 *      name            is a string representing the scheme name.
 *
 * ON EXIT:
 *      returns         the enumerated constant for that scheme.
 */
    extern HTAAScheme HTAAScheme_enum(const char *name);
d98 10
a107 10
 *                      GET THE NAME OF A GIVEN SCHEME
 * ON ENTRY:
 *      scheme          is one of the scheme enum values:
 *                      HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
 *
 * ON EXIT:
 *      returns         the name of the scheme, i.e.
 *                      "none", "basic", "pubkey", ...
 */
    extern const char *HTAAScheme_name(HTAAScheme scheme);
d116 10
a125 9
 *              TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
 * ON ENTRY:
 *      name            is the method name to translate.
 *
 * ON EXIT:
 *      returns         HTAAMethod enumerated value corresponding
 *                      to the given name.
 */
    extern HTAAMethod HTAAMethod_enum(const char *name);
d128 11
a138 10
 *                      GET THE NAME OF A GIVEN METHOD
 * ON ENTRY:
 *      method          is one of the method enum values:
 *                      METHOD_GET, METHOD_PUT, ...
 *
 * ON EXIT:
 *      returns         the name of the scheme, i.e.
 *                      "GET", "PUT", ...
 */
    extern const char *HTAAMethod_name(HTAAMethod method);
d141 11
a151 11
 *              IS A METHOD IN A LIST OF METHOD NAMES
 * ON ENTRY:
 *      method          is the method to look for.
 *      list            is a list of method names.
 *
 * ON EXIT:
 *      returns         YES, if method was found.
 *                      NO, if not found.
 */
    extern BOOL HTAAMethod_inList(HTAAMethod method, HTList *list);

d159 24
a182 23
 *              STRING COMPARISON FUNCTION FOR FILE NAMES
 *                 WITH ONE WILDCARD * IN THE TEMPLATE
 * NOTE:
 *      This is essentially the same code as in HTRules.c, but it
 *      cannot be used because it is embedded in between other code.
 *      (In fact, HTRules.c should use this routine, but then this
 *       routine would have to be more sophisticated... why is life
 *       sometimes so hard...)
 *
 * ON ENTRY:
 *      ctemplate       is a template string to match the file name
 *                      against, may contain a single wildcard
 *                      character * which matches zero or more
 *                      arbitrary characters.
 *      filename        is the filename (or pathname) to be matched
 *                      against the template.
 *
 * ON EXIT:
 *      returns         YES, if filename matches the template.
 *                      NO, otherwise.
 */
    extern BOOL HTAA_templateMatch(const char *ctemplate,
				   const char *filename);
d185 24
a208 23
 *              STRING COMPARISON FUNCTION FOR FILE NAMES
 *                 WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
 * NOTE:
 *      This is essentially the same code as in HTAA_templateMatch, but
 *      it compares case insensitive (for VMS). Reason for this routine
 *      is that HTAA_templateMatch gets called from several places, also
 *      there where a case sensitive match is needed, so one cannot just
 *      change the HTAA_templateMatch routine for VMS.
 *
 * ON ENTRY:
 *      ctemplate       is a template string to match the file name
 *                      against, may contain a single wildcard
 *                      character * which matches zero or more
 *                      arbitrary characters.
 *      filename        is the filename (or pathname) to be matched
 *                      against the template.
 *
 * ON EXIT:
 *      returns         YES, if filename matches the template.
 *                      NO, otherwise.
 */
    extern BOOL HTAA_templateCaseMatch(const char *ctemplate,
				       const char *filename);
d211 19
a229 20
 *              CREATE A PROTECTION TEMPLATE FOR THE FILES
 *              IN THE SAME DIRECTORY AS THE GIVEN FILE
 *              (Used by server if there is no fancier way for
 *              it to tell the client, and by browser if server
 *              didn't send WWW-ProtectionTemplate: field)
 * ON ENTRY:
 *      docname is the document pathname (from URL).
 *
 * ON EXIT:
 *      returns a template matching docname, and other files
 *              files in that directory.
 *
 *              E.g.  /foo/bar/x.html  =>  /foo/bar/ *
 *                                                  ^
 *                              Space only to prevent it from
 *                              being a comment marker here,
 *                              there really isn't any space.
 */
    extern char *HTAA_makeProtectionTemplate(const char *docname);

d236 1
d238 26
a263 26
 *              PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
 * ON ENTRY:
 *      str     is a comma-separated list:
 *
 *                      item, item, item
 *              where
 *                      item ::= value
 *                             | name=value
 *                             | name="value"
 *
 *              Leading and trailing whitespace is ignored
 *              everywhere except inside quotes, so the following
 *              examples are equal:
 *
 *                      name=value,foo=bar
 *                       name="value",foo="bar"
 *                        name = value ,  foo = bar
 *                         name = "value" ,  foo = "bar"
 *
 * ON EXIT:
 *      returns a list of name-value pairs (actually HTAssocList*).
 *              For items with no name, just value, the name is
 *              the number of order number of that item. E.g.
 *              "1" for the first, etc.
 */
    extern HTList *HTAA_parseArgList(char *str);
d272 22
a293 21
 *              SET UP HEADER LINE READER, i.e., give
 *              the already-read-but-not-yet-processed
 *              buffer of text to be read before more
 *              is read from the socket.
 * ON ENTRY:
 *      start_of_headers is a pointer to a buffer containing
 *                      the beginning of the header lines
 *                      (rest will be read from a socket).
 *      length          is the number of valid characters in
 *                      'start_of_headers' buffer.
 *      soc             is the socket to use when start_of_headers
 *                      buffer is used up.
 * ON EXIT:
 *      returns         nothing.
 *                      Subsequent calls to HTAA_getUnfoldedLine()
 *                      will use this buffer first and then
 *                      proceed to read from socket.
 */
    extern void HTAA_setupReader(char *start_of_headers,
				 int length,
				 int soc);
d296 21
a316 21
 *              READ AN UNFOLDED HEADER LINE FROM SOCKET
 * ON ENTRY:
 *      HTAA_setupReader must absolutely be called before
 *      this function to set up internal buffer.
 *
 * ON EXIT:
 *      returns a newly-allocated character string representing
 *              the read line.  The line is unfolded, i.e.
 *              lines that begin with whitespace are appended
 *              to current line.  E.g.
 *
 *                      Field-Name: Blaa-Blaa
 *                       This-Is-A-Continuation-Line
 *                       Here-Is_Another
 *
 *              is seen by the caller as:
 *
 *      Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
 *
 */
    extern char *HTAA_getUnfoldedLine(void);
d318 1
a318 4
#ifdef __cplusplus
}
#endif
#endif				/* NOT HTAAUTIL_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d94 1
a94 1
extern HTAAScheme HTAAScheme_enum (const char* name);
d107 1
a107 1
extern char *HTAAScheme_name (HTAAScheme scheme);
d124 1
a124 1
extern HTAAMethod HTAAMethod_enum (const char * name);
d137 1
a137 1
extern char *HTAAMethod_name (HTAAMethod method);
d150 2
a151 2
extern BOOL HTAAMethod_inList (HTAAMethod        method,
                                     HTList *           list);
d180 2
a181 2
extern BOOL HTAA_templateMatch (const char * template,
                                       const char * filename);
d206 2
a207 2
extern BOOL HTAA_templateCaseMatch (const char * template,
                                         const char * filename);
d229 1
a229 1
extern char *HTAA_makeProtectionTemplate (const char * docname);
d263 1
a263 1
extern HTList *HTAA_parseArgList (char * str);
d290 1
a290 1
extern void HTAA_setupReader (char *     start_of_headers,
d292 1
a292 1
                                     int        soc);
d316 1
a316 1
extern char *HTAA_getUnfoldedLine (void);
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d36 10
a45 10
 * Numeric constants
 */
#define MAX_USERNAME_LEN        16	/* @@@@ Longest allowed username    */
#define MAX_PASSWORD_LEN        3*13	/* @@@@ Longest allowed password    */
					/* (encrypted, so really only 3*8) */
#define MAX_METHODNAME_LEN      12	/* @@@@ Longest allowed method name */
#define MAX_FIELDNAME_LEN       16	/* @@@@ Longest field name in       */
					/* protection setup file          */
#define MAX_PATHNAME_LEN        80	/* @@@@ Longest passwd/group file   */
					/* pathname to allow               */
d65 1
a65 1
    HTAA_MAX_SCHEMES		/* THIS MUST ALWAYS BE LAST! Number of schemes */
d87 9
a95 8
 *              TRANSLATE SCHEME NAME TO A SCHEME ENUMERATION
 * ON ENTRY:
 *      name            is a string representing the scheme name.
 *
 * ON EXIT:
 *      returns         the enumerated constant for that scheme.
 */
extern HTAAScheme HTAAScheme_enum(const char *name);
d98 10
a107 10
 *                      GET THE NAME OF A GIVEN SCHEME
 * ON ENTRY:
 *      scheme          is one of the scheme enum values:
 *                      HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
 *
 * ON EXIT:
 *      returns         the name of the scheme, i.e.
 *                      "none", "basic", "pubkey", ...
 */
extern char *HTAAScheme_name(HTAAScheme scheme);
d116 10
a125 9
 *              TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
 * ON ENTRY:
 *      name            is the method name to translate.
 *
 * ON EXIT:
 *      returns         HTAAMethod enumerated value corresponding
 *                      to the given name.
 */
extern HTAAMethod HTAAMethod_enum(const char *name);
d128 11
a138 10
 *                      GET THE NAME OF A GIVEN METHOD
 * ON ENTRY:
 *      method          is one of the method enum values:
 *                      METHOD_GET, METHOD_PUT, ...
 *
 * ON EXIT:
 *      returns         the name of the scheme, i.e.
 *                      "GET", "PUT", ...
 */
extern char *HTAAMethod_name(HTAAMethod method);
d141 11
a151 11
 *              IS A METHOD IN A LIST OF METHOD NAMES
 * ON ENTRY:
 *      method          is the method to look for.
 *      list            is a list of method names.
 *
 * ON EXIT:
 *      returns         YES, if method was found.
 *                      NO, if not found.
 */
extern BOOL HTAAMethod_inList(HTAAMethod method, HTList *list);

d159 24
a182 23
 *              STRING COMPARISON FUNCTION FOR FILE NAMES
 *                 WITH ONE WILDCARD * IN THE TEMPLATE
 * NOTE:
 *      This is essentially the same code as in HTRules.c, but it
 *      cannot be used because it is embedded in between other code.
 *      (In fact, HTRules.c should use this routine, but then this
 *       routine would have to be more sophisticated... why is life
 *       sometimes so hard...)
 *
 * ON ENTRY:
 *      template        is a template string to match the file name
 *                      against, may contain a single wildcard
 *                      character * which matches zero or more
 *                      arbitrary characters.
 *      filename        is the filename (or pathname) to be matched
 *                      against the template.
 *
 * ON EXIT:
 *      returns         YES, if filename matches the template.
 *                      NO, otherwise.
 */
extern BOOL HTAA_templateMatch(const char *template,
			       const char *filename);
d185 24
a208 23
 *              STRING COMPARISON FUNCTION FOR FILE NAMES
 *                 WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
 * NOTE:
 *      This is essentially the same code as in HTAA_templateMatch, but
 *      it compares case insensitive (for VMS). Reason for this routine
 *      is that HTAA_templateMatch gets called from several places, also
 *      there where a case sensitive match is needed, so one cannot just
 *      change the HTAA_templateMatch routine for VMS.
 *
 * ON ENTRY:
 *      template        is a template string to match the file name
 *                      against, may contain a single wildcard
 *                      character * which matches zero or more
 *                      arbitrary characters.
 *      filename        is the filename (or pathname) to be matched
 *                      against the template.
 *
 * ON EXIT:
 *      returns         YES, if filename matches the template.
 *                      NO, otherwise.
 */
extern BOOL HTAA_templateCaseMatch(const char *template,
				   const char *filename);
d211 19
a229 20
 *              CREATE A PROTECTION TEMPLATE FOR THE FILES
 *              IN THE SAME DIRECTORY AS THE GIVEN FILE
 *              (Used by server if there is no fancier way for
 *              it to tell the client, and by browser if server
 *              didn't send WWW-ProtectionTemplate: field)
 * ON ENTRY:
 *      docname is the document pathname (from URL).
 *
 * ON EXIT:
 *      returns a template matching docname, and other files
 *              files in that directory.
 *
 *              E.g.  /foo/bar/x.html  =>  /foo/bar/ *
 *                                                  ^
 *                              Space only to prevent it from
 *                              being a comment marker here,
 *                              there really isn't any space.
 */
extern char *HTAA_makeProtectionTemplate(const char *docname);

d236 1
d238 26
a263 26
 *              PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
 * ON ENTRY:
 *      str     is a comma-separated list:
 *
 *                      item, item, item
 *              where
 *                      item ::= value
 *                             | name=value
 *                             | name="value"
 *
 *              Leading and trailing whitespace is ignored
 *              everywhere except inside quotes, so the following
 *              examples are equal:
 *
 *                      name=value,foo=bar
 *                       name="value",foo="bar"
 *                        name = value ,  foo = bar
 *                         name = "value" ,  foo = "bar"
 *
 * ON EXIT:
 *      returns a list of name-value pairs (actually HTAssocList*).
 *              For items with no name, just value, the name is
 *              the number of order number of that item. E.g.
 *              "1" for the first, etc.
 */
extern HTList *HTAA_parseArgList(char *str);
d272 22
a293 21
 *              SET UP HEADER LINE READER, i.e., give
 *              the already-read-but-not-yet-processed
 *              buffer of text to be read before more
 *              is read from the socket.
 * ON ENTRY:
 *      start_of_headers is a pointer to a buffer containing
 *                      the beginning of the header lines
 *                      (rest will be read from a socket).
 *      length          is the number of valid characters in
 *                      'start_of_headers' buffer.
 *      soc             is the socket to use when start_of_headers
 *                      buffer is used up.
 * ON EXIT:
 *      returns         nothing.
 *                      Subsequent calls to HTAA_getUnfoldedLine()
 *                      will use this buffer first and then
 *                      proceed to read from socket.
 */
extern void HTAA_setupReader(char *start_of_headers,
			     int length,
			     int soc);
d296 21
a316 21
 *              READ AN UNFOLDED HEADER LINE FROM SOCKET
 * ON ENTRY:
 *      HTAA_setupReader must absolutely be called before
 *      this function to set up internal buffer.
 *
 * ON EXIT:
 *      returns a newly-allocated character string representing
 *              the read line.  The line is unfolded, i.e.
 *              lines that begin with whitespace are appended
 *              to current line.  E.g.
 *
 *                      Field-Name: Blaa-Blaa
 *                       This-Is-A-Continuation-Line
 *                       Here-Is_Another
 *
 *              is seen by the caller as:
 *
 *      Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
 *
 */
extern char *HTAA_getUnfoldedLine(void);
d318 1
a318 1
#endif /* NOT HTAAUTIL_H */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@
