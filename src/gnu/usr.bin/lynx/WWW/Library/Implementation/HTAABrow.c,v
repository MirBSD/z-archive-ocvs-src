head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.45;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.29;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.24;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.58;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.04;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.53;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.02;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.13;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.53;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@
/* MODULE							HTAABrow.c
 *		BROWSER SIDE ACCESS AUTHORIZATION MODULE
 *
 *	Contains the code for keeping track on server hostnames,
 *	port numbers, scheme names, usernames, passwords
 *	(and servers' public keys).
 *
 * IMPORTANT:
 *	Routines in this module use dynamic allocation, but free
 *	automatically all the memory reserved by them.
 *
 *	Therefore the caller never has to (and never should)
 *	free() any object returned by these functions.
 *
 *	Therefore also all the strings returned by this package
 *	are only valid until the next call to the same function
 *	is made.  This approach is selected, because of the nature
 *	of access authorization: no string returned by the package
 *	needs to be valid longer than until the next call.
 *
 *	This also makes it easy to plug the AA package in:
 *	you don't have to ponder whether to free() something
 *	here or is it done somewhere else (because it is always
 *	done somewhere else).
 *
 *	The strings that the package needs to store are copied
 *	so the original strings given as parameters to AA
 *	functions may be freed or modified with no side effects.
 *
 *	The AA package does not free() anything else than what
 *	it has itself allocated.
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *
 * HISTORY:
 *	Oct 17	AL	Made corrections suggested by marca:
 *			Added  if (!realm->username) return NULL;
 *			Changed some ""s to NULLs.
 *			Now doing calloc() to init uuencode source;
 *			otherwise HTUU_encode() reads uninitialized memory
 *			every now and then (not a real bug but not pretty).
 *			Corrected the formula for uuencode destination size.
 *
 * 28 Apr 1997	AJL	Do Proxy Authorisation.
 *
 * BUGS:
 *
 *
 */

#include <HTUtils.h>
#include <HTString.h>
#include <HTParse.h>		/* URL parsing function         */
#include <HTList.h>		/* HTList object                */
#include <HTAlert.h>		/* HTConfirm(), HTPrompt()      */
#include <HTAAUtil.h>		/* AA common to both sides      */
#include <HTAssoc.h>		/* Assoc list                   */
#include <HTAccess.h>		/* Are we using an HTTP gateway? */
#include <HTAABrow.h>		/* Implemented here             */
#include <HTUU.h>		/* Uuencoding and uudecoding    */

#include <LYLeaks.h>

/*
 *  Local datatype definitions
 *
 *  HTAAServer contains all the information about one server.
 */
typedef struct {

    char *hostname;		/* Host's name                  */
    int portnumber;		/* Port number                  */
    BOOL IsProxy;		/* Is it a proxy?               */
    HTList *setups;		/* List of protection setups 
				   on this server; i.e., valid
				   authentication schemes and
				   templates when to use them.
				   This is actually a list of
				   HTAASetup objects.           */
    HTList *realms;		/* Information about passwords  */
} HTAAServer;

/*
 *  HTAASetup contains information about one server's one
 *  protected tree of documents.
 */
typedef struct {
    HTAAServer *server;		/* Which server serves this tree             */
    char *ctemplate;		/* Template for this tree                    */
    HTList *valid_schemes;	/* Valid authentic.schemes                   */
    HTAssocList **scheme_specifics;	/* Scheme specific params                  */
    BOOL retry;			/* Failed last time -- reprompt (or whatever) */
} HTAASetup;

/*
 *  Information about usernames and passwords in
 *  Basic and Pubkey authentication schemes;
 */
typedef struct {
    char *realmname;		/* Password domain name         */
    char *username;		/* Username in that domain      */
    char *password;		/* Corresponding password       */
} HTAARealm;

/*
 *  To free off all globals. - FM
 */
static void free_HTAAGlobals(void);
static BOOL free_HTAAGlobalsSet = FALSE;
static char *HTAA_composeAuthResult = NULL;
static char *compose_auth_stringResult = NULL;	/* Uuencoded presentation */

/*
 *  Module-wide global variables
 */
static HTList *server_table = NULL;	/* Browser's info about servers      */
static char *secret_key = NULL;	/* Browser's latest secret key       */
static HTAASetup *current_setup = NULL;		/* The server setup we are currently */

					/* talking to                        */
static char *current_hostname = NULL;	/* The server's name and portnumber  */
static int current_portnumber = 80;	/* where we are currently trying to  */

					/* connect.                          */
static char *current_docname = NULL;	/* The document's name we are        */

					/* trying to access.                 */
static char *HTAAForwardAuth = NULL;	/* Authorization: line to forward    */

					/* (used by gateway httpds)          */
static HTAASetup *proxy_setup = NULL;	/* Same as above, but for Proxy -AJL */
static char *proxy_hostname = NULL;
static char *proxy_docname = NULL;
static int proxy_portnumber = 80;

/*** HTAAForwardAuth for enabling gateway-httpds to forward Authorization ***/

void HTAAForwardAuth_set(const char *scheme_name,
			 const char *scheme_specifics)
{
    int len = 20 + (scheme_name ? strlen(scheme_name) : 0)
    + (scheme_specifics ? strlen(scheme_specifics) : 0);

    FREE(HTAAForwardAuth);
    if ((HTAAForwardAuth = typecallocn(char, len)) == 0)
	  outofmem(__FILE__, "HTAAForwardAuth_set");

    strcpy(HTAAForwardAuth, "Authorization: ");
    if (scheme_name) {
	strcat(HTAAForwardAuth, scheme_name);
	strcat(HTAAForwardAuth, " ");
	if (scheme_specifics) {
	    strcat(HTAAForwardAuth, scheme_specifics);
	}
    }
}

void HTAAForwardAuth_reset(void)
{
    FREE(HTAAForwardAuth);
}

/**************************** HTAAServer ***********************************/

static void HTAASetup_delete(HTAASetup * killme);	/* Forward */

/* static						HTAAServer_new()
 *		ALLOCATE A NEW NODE TO HOLD SERVER INFO
 *		AND ADD IT TO THE LIST OF SERVERS
 * ON ENTRY:
 *	hostname	is the name of the host that the server
 *			is running in.
 *	portnumber	is the portnumber which the server listens.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns		the newly-allocated node with all the strings
 *			duplicated.
 *			Strings will be automatically freed by
 *			the function HTAAServer_delete(), which also
 *			frees the node itself.
 */
static HTAAServer *HTAAServer_new(const char *hostname,
				  int portnumber,
				  BOOL IsProxy)
{
    HTAAServer *server;

    if ((server = typecalloc(HTAAServer)) == 0)
	  outofmem(__FILE__, "HTAAServer_new");

    server->hostname = NULL;
    server->portnumber = (portnumber > 0 ? portnumber : 80);
    server->IsProxy = IsProxy;
    server->setups = HTList_new();
    server->realms = HTList_new();

    if (hostname)
	StrAllocCopy(server->hostname, hostname);

    if (!server_table)
	server_table = HTList_new();

    HTList_addObject(server_table, (void *) server);

    return server;
}

/* static						HTAAServer_delete()
 *
 *	DELETE THE ENTRY FOR THE SERVER FROM THE HOST TABLE,
 *	AND FREE THE MEMORY USED BY IT.
 *
 * ON ENTRY:
 *	killme		points to the HTAAServer to be freed.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAAServer_delete(HTAAServer *killme)
{
    int n, i;
    HTAASetup *setup;
    HTAARealm *realm;
    HTList *cur;

    if (killme) {
	if (killme->setups != NULL) {
	    n = HTList_count(killme->setups);
	    for (i = (n - 1); i >= 0; i--) {
		if ((setup = (HTAASetup *) HTList_objectAt(killme->setups,
							   i)) != NULL) {
		    HTAASetup_delete(setup);
		    setup = NULL;
		}
	    }
	    HTList_delete(killme->setups);
	    killme->setups = NULL;
	}

	cur = killme->realms;
	while (NULL != (realm = (HTAARealm *) HTList_nextObject(cur))) {
	    FREE(realm->realmname);
	    FREE(realm->username);
	    FREE(realm->password);
	    FREE(realm);
	}
	HTList_delete(killme->realms);
	killme->realms = NULL;

	FREE(killme->hostname);

	HTList_removeObject(server_table, (void *) killme);
	FREE(killme);
    }
}

/* static						HTAAServer_lookup()
 *		LOOK UP SERVER BY HOSTNAME AND PORTNUMBER
 * ON ENTRY:
 *	hostname	obvious.
 *	portnumber	if non-positive defaults to 80.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *	Looks up the server in the module-global server_table.
 *
 * ON EXIT:
 *	returns		pointer to a HTAAServer structure
 *			representing the looked-up server.
 *			NULL, if not found.
 */
static HTAAServer *HTAAServer_lookup(const char *hostname,
				     int portnumber,
				     BOOL IsProxy)
{
    if (hostname) {
	HTList *cur = server_table;
	HTAAServer *server;

	if (portnumber <= 0)
	    portnumber = 80;

	while (NULL != (server = (HTAAServer *) HTList_nextObject(cur))) {
	    if (server->portnumber == portnumber &&
		0 == strcmp(server->hostname, hostname) &&
		server->IsProxy == IsProxy)
		return server;
	}
    }
    return NULL;		/* NULL parameter, or not found */
}

/*************************** HTAASetup *******************************/

/* static						HTAASetup_lookup()
 *	FIGURE OUT WHICH AUTHENTICATION SETUP THE SERVER
 *	IS USING FOR A GIVEN FILE ON A GIVEN HOST AND PORT
 *
 * ON ENTRY:
 *	hostname	is the name of the server host machine.
 *	portnumber	is the port that the server is running in.
 *	docname		is the (URL-)pathname of the document we
 *			are trying to access.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *	This function goes through the information known about
 *	all the setups of the server, and finds out if the given
 *	filename resides in one of the protected directories.
 *
 * ON EXIT:
 *	returns		NULL if no match.
 *			Otherwise, a HTAASetup structure representing
 *			the protected server setup on the corresponding
 *			document tree.
 *
 */
static HTAASetup *HTAASetup_lookup(const char *hostname,
				   int portnumber,
				   const char *docname,
				   BOOL IsProxy)
{
    HTAAServer *server;
    HTAASetup *setup;

    if (portnumber <= 0)
	portnumber = 80;

    if (hostname && docname && *hostname && *docname &&
	NULL != (server = HTAAServer_lookup(hostname,
					    portnumber,
					    IsProxy))) {

	HTList *cur = server->setups;

	CTRACE((tfp, "%s %s (%s:%d:%s)\n",
		"HTAASetup_lookup: resolving setup for",
		(IsProxy ? "proxy" : "server"),
		hostname, portnumber, docname));

	while (NULL != (setup = (HTAASetup *) HTList_nextObject(cur))) {
	    if (HTAA_templateMatch(setup->ctemplate, docname)) {
		CTRACE((tfp, "%s `%s' %s `%s'\n",
			"HTAASetup_lookup:", docname,
			"matched template", setup->ctemplate));
		return setup;
	    } else {
		CTRACE((tfp, "%s `%s' %s `%s'\n",
			"HTAASetup_lookup:", docname,
			"did NOT match template", setup->ctemplate));
	    }
	}			/* while setups remain */
    }
    /* if valid parameters and server found */
    CTRACE((tfp, "%s `%s' %s\n",
	    "HTAASetup_lookup: No template matched",
	    NONNULL(docname),
	    "(so probably not protected)"));

    return NULL;		/* NULL in parameters, or not found */
}

/* static						HTAASetup_new()
 *			CREATE A NEW SETUP NODE
 * ON ENTRY:
 *	server		is a pointer to a HTAAServer structure
 *			to which this setup belongs.
 *	ctemplate	documents matching this template
 *			are protected according to this setup.
 *	valid_schemes	a list containing all valid authentication
 *			schemes for this setup.
 *			If NULL, all schemes are disallowed.
 *	scheme_specifics is an array of assoc lists, which
 *			contain scheme specific parameters given
 *			by server in Authenticate: fields.
 *			If NULL, all scheme specifics are
 *			set to NULL.
 * ON EXIT:
 *	returns		a new HTAASetup node, and also adds it as
 *			part of the HTAAServer given as parameter.
 */
static HTAASetup *HTAASetup_new(HTAAServer *server, char *ctemplate,
				HTList *valid_schemes,
				HTAssocList **scheme_specifics)
{
    HTAASetup *setup;

    if (!server || isEmpty(ctemplate))
	return NULL;

    if ((setup = typecalloc(HTAASetup)) == 0)
	outofmem(__FILE__, "HTAASetup_new");

    setup->retry = NO;
    setup->server = server;
    setup->ctemplate = NULL;
    if (ctemplate)
	StrAllocCopy(setup->ctemplate, ctemplate);
    setup->valid_schemes = valid_schemes;
    setup->scheme_specifics = scheme_specifics;

    HTList_addObject(server->setups, (void *) setup);

    return setup;
}

/* static						HTAASetup_delete()
 *			FREE A HTAASetup STRUCTURE
 * ON ENTRY:
 *	killme		is a pointer to the structure to free().
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAASetup_delete(HTAASetup * killme)
{
    int scheme;

    if (killme) {
	FREE(killme->ctemplate);
	if (killme->valid_schemes) {
	    HTList_delete(killme->valid_schemes);
	    killme->valid_schemes = NULL;
	}
	for (scheme = 0; scheme < HTAA_MAX_SCHEMES; scheme++)
	    if (killme->scheme_specifics[scheme])
		HTAssocList_delete(killme->scheme_specifics[scheme]);
	FREE(killme->scheme_specifics);
	FREE(killme);
    }
}

/* static					HTAASetup_updateSpecifics()
 *		COPY SCHEME SPECIFIC PARAMETERS
 *		TO HTAASetup STRUCTURE
 * ON ENTRY:
 *	setup		destination setup structure.
 *	specifics	string array containing scheme
 *			specific parameters for each scheme.
 *			If NULL, all the scheme specific
 *			parameters are set to NULL.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAASetup_updateSpecifics(HTAASetup * setup, HTAssocList **specifics)
{
    int scheme;

    if (setup) {
	if (setup->scheme_specifics) {
	    for (scheme = 0; scheme < HTAA_MAX_SCHEMES; scheme++) {
		if (setup->scheme_specifics[scheme])
		    HTAssocList_delete(setup->scheme_specifics[scheme]);
	    }
	    FREE(setup->scheme_specifics);
	}
	setup->scheme_specifics = specifics;
    }
}

/*************************** HTAARealm **********************************/

/* static						HTAARealm_lookup()
 *		LOOKUP HTAARealm STRUCTURE BY REALM NAME
 * ON ENTRY:
 *	realm_table	a list of realm objects.
 *	realmname	is the name of realm to look for.
 *
 * ON EXIT:
 *	returns		the realm.  NULL, if not found.
 */
static HTAARealm *HTAARealm_lookup(HTList *realm_table,
				   const char *realmname)
{
    if (realm_table && realmname) {
	HTList *cur = realm_table;
	HTAARealm *realm;

	while (NULL != (realm = (HTAARealm *) HTList_nextObject(cur))) {
	    if (0 == strcmp(realm->realmname, realmname))
		return realm;
	}
    }
    return NULL;		/* No table, NULL param, or not found */
}

/* static						HTAARealm_new()
 *		CREATE A NODE CONTAINING USERNAME AND
 *		PASSWORD USED FOR THE GIVEN REALM.
 *		IF REALM ALREADY EXISTS, CHANGE
 *		USERNAME/PASSWORD.
 * ON ENTRY:
 *	realm_table	a list of realms to where to add
 *			the new one, too.
 *	realmname	is the name of the password domain.
 *	username	and
 *	password	are what you can expect them to be.
 *
 * ON EXIT:
 *	returns		the created realm.
 */
static HTAARealm *HTAARealm_new(HTList *realm_table,
				const char *realmname,
				const char *username,
				const char *password)
{
    HTAARealm *realm;

    realm = HTAARealm_lookup(realm_table, realmname);

    if (!realm) {
	if ((realm = typecalloc(HTAARealm)) == 0)
	      outofmem(__FILE__, "HTAARealm_new");

	realm->realmname = NULL;
	realm->username = NULL;
	realm->password = NULL;
	StrAllocCopy(realm->realmname, realmname);
	if (realm_table)
	    HTList_addObject(realm_table, (void *) realm);
    }
    if (username)
	StrAllocCopy(realm->username, username);
    if (password)
	StrAllocCopy(realm->password, password);

    return realm;
}

/***************** Basic and Pubkey Authentication ************************/

/* static						compose_auth_string()
 *
 *		COMPOSE Basic OR Pubkey AUTHENTICATION STRING;
 *		PROMPTS FOR USERNAME AND PASSWORD IF NEEDED
 *
 * ON ENTRY:
 *	scheme		is either HTAA_BASIC or HTAA_PUBKEY.
 *	setup		is the current server setup.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns		a newly composed authorization string,
 *			(with, of course, a newly generated secret
 *			key and fresh timestamp, if Pubkey-scheme
 *			is being used).
 *			NULL, if something fails.
 * NOTE:
 *	Like throughout the entire AA package, no string or structure
 *	returned by AA package needs to (or should) be freed.
 *
 */
static char *compose_auth_string(HTAAScheme scheme, HTAASetup * setup, BOOL IsProxy)
{
    char *cleartext = NULL;	/* Cleartext presentation */
    char *ciphertext = NULL;	/* Encrypted presentation */
    int len;
    char *msg = NULL;
    char *username = NULL;
    char *password = NULL;
    char *realmname = NULL;
    char *theHost = NULL;
    char *proxiedHost = NULL;
    char *thePort = NULL;
    HTAARealm *realm;
    const char *i_net_addr = "0.0.0.0";		/* Change... @@@@@@@@ */
    const char *timestamp = "42";	/* ... these @@@@@@@@ */

    FREE(compose_auth_stringResult);	/* From previous call */

    if ((scheme != HTAA_BASIC && scheme != HTAA_PUBKEY) || !setup ||
	!setup->scheme_specifics || !setup->scheme_specifics[scheme] ||
	!setup->server || !setup->server->realms)
	return NULL;

    realmname = HTAssocList_lookup(setup->scheme_specifics[scheme], "realm");
    if (!realmname)
	return NULL;

    realm = HTAARealm_lookup(setup->server->realms, realmname);
    if (!(realm &&
	  realm->username && *realm->username &&
	  realm->password) || setup->retry) {
	if (!realm) {
	    CTRACE((tfp, "%s `%s' %s\n",
		    "compose_auth_string: realm:", realmname,
		    "not found -- creating"));
	    realm = HTAARealm_new(setup->server->realms,
				  realmname, NULL, NULL);
	}
	/*
	 * The template should be either the '*' global for everything on the
	 * server (always true for proxy authorization setups), or a path for
	 * the start of a protected limb, with no host field, but we'll check
	 * for a host anyway in case a WWW-Protection-Template header set an
	 * absolute URL instead of a path.  If we do get a host from this, it
	 * will include the port.  - FM
	 */
	if ((!IsProxy) && using_proxy && setup->ctemplate) {
	    proxiedHost = HTParse(setup->ctemplate, "", PARSE_HOST);
	    if (proxiedHost && *proxiedHost != '\0') {
		theHost = proxiedHost;
	    }
	}
	/*
	 * If we didn't get a host field from the template, set up the host
	 * name and port from the setup->server elements.  - FM
	 */
	if (!theHost)
	    theHost = setup->server->hostname;
	if (setup->server->portnumber > 0 &&
	    setup->server->portnumber != 80) {
	    HTSprintf0(&thePort, ":%d", setup->server->portnumber);
	}
	/*
	 * Set up the message for the username prompt, and then issue the
	 * prompt.  The default username is included in the call to the
	 * prompting function, but the password is NULL-ed and always replaced. 
	 * - FM
	 */
	len = strlen(realm->realmname) +
	    strlen(theHost ?
		   theHost : "??") + 50;
	HTSprintf0(&msg, gettext("Username for '%s' at %s '%s%s':"),
		   realm->realmname,
		   (IsProxy ? "proxy" : "server"),
		   (theHost ? theHost : "??"),
		   NonNull(thePort));
	FREE(proxiedHost);
	FREE(thePort);
	username = realm->username;
	password = NULL;
	HTPromptUsernameAndPassword(msg, &username, &password, IsProxy);

	FREE(msg);
	FREE(realm->username);
	FREE(realm->password);
	realm->username = username;
	realm->password = password;

	if (!realm->username || !realm->password) {
	    /*
	     * Signals to retry.  - FM
	     */
	    return NULL;
	} else if (*realm->username == '\0') {
	    /*
	     * Signals to abort.  - FM
	     */
	    StrAllocCopy(compose_auth_stringResult, "");
	    return compose_auth_stringResult;
	}
    }

    len = strlen(NonNull(realm->username)) +
	strlen(NonNull(realm->password)) + 3;

    if (scheme == HTAA_PUBKEY) {
#ifdef PUBKEY
	/* Generate new secret key */
	StrAllocCopy(secret_key, HTAA_generateRandomKey());
#endif /* PUBKEY */
	/* Room for secret key, timestamp and inet address */
	len += strlen(NonNull(secret_key)) + 30;
    } else {
	FREE(secret_key);
    }

    if ((cleartext = typecallocn(char, len)) == 0)
	  outofmem(__FILE__, "compose_auth_string");

    if (realm->username)
	strcpy(cleartext, realm->username);
    else
	*cleartext = '\0';

    strcat(cleartext, ":");

    if (realm->password)
	strcat(cleartext, realm->password);

    if (scheme == HTAA_PUBKEY) {
	strcat(cleartext, ":");
	strcat(cleartext, i_net_addr);
	strcat(cleartext, ":");
	strcat(cleartext, timestamp);
	strcat(cleartext, ":");
	if (secret_key)
	    strcat(cleartext, secret_key);

	if (!((ciphertext = typecallocn(char, 2 * len)) &&
	        (compose_auth_stringResult = typecallocn(char, 3 * len))))
	      outofmem(__FILE__, "compose_auth_string");

#ifdef PUBKEY
	HTPK_encrypt(cleartext, ciphertext, server->public_key);
	HTUU_encode((unsigned char *) ciphertext, strlen(ciphertext),
		    compose_auth_stringResult);
#endif /* PUBKEY */
	FREE(cleartext);
	FREE(ciphertext);
    } else {			/* scheme == HTAA_BASIC */
	if (!(compose_auth_stringResult =
	      typecallocn(char, (4 * ((len + 2) / 3)) + 1)))
	      outofmem(__FILE__, "compose_auth_string");

	HTUU_encode((unsigned char *) cleartext, strlen(cleartext),
		    compose_auth_stringResult);
	FREE(cleartext);
    }
    return compose_auth_stringResult;
}

/* BROWSER static					HTAA_selectScheme()
 *		SELECT THE AUTHENTICATION SCHEME TO USE
 * ON ENTRY:
 *	setup	is the server setup structure which can
 *		be used to make the decision about the
 *		used scheme.
 *
 *	When new authentication methods are added to library
 *	this function makes the decision about which one to
 *	use at a given time.  This can be done by inspecting
 *	environment variables etc.
 *
 *	Currently only searches for the first valid scheme,
 *	and if nothing found suggests Basic scheme;
 *
 * ON EXIT:
 *	returns	the authentication scheme to use.
 */
static HTAAScheme HTAA_selectScheme(HTAASetup * setup)
{
    int scheme;

    if (setup && setup->valid_schemes) {
	for (scheme = HTAA_BASIC; scheme < HTAA_MAX_SCHEMES; scheme++)
	    if (-1 < HTList_indexOf(setup->valid_schemes, (void *) scheme))
		return (HTAAScheme) scheme;
    }
    return HTAA_BASIC;
}

/*
 *  Purpose:	Free off all module globals.
 *  Arguments:	void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *	To be used at program exit.
 *  Revision History:
 *	06-19-96	created - FM
 */
static void free_HTAAGlobals(void)
{
    HTAAServer *server;
    int n, i;

    if (server_table != NULL) {
	n = HTList_count(server_table);
	for (i = (n - 1); i >= 0; i--) {
	    if ((server = (HTAAServer *) HTList_objectAt(server_table,
							 i)) != NULL) {
		HTAAServer_delete(server);
		server = NULL;
	    }
	}
	HTList_delete(server_table);
	server_table = NULL;
    }

    HTAAForwardAuth_reset();
    FREE(HTAA_composeAuthResult);
    FREE(current_hostname);
    FREE(current_docname);
    FREE(proxy_hostname);
    FREE(proxy_docname);
    FREE(compose_auth_stringResult);
    FREE(secret_key);
}

/* BROWSER PUBLIC					HTAA_composeAuth()
 *
 *	SELECT THE AUTHENTICATION SCHEME AND
 *	COMPOSE THE ENTIRE AUTHORIZATION HEADER LINE
 *	IF WE ALREADY KNOW THAT THE HOST REQUIRES AUTHENTICATION
 *
 * ON ENTRY:
 *	hostname	is the hostname of the server.
 *	portnumber	is the portnumber in which the server runs.
 *	docname		is the pathname of the document (as in URL)
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns	NULL, if no authorization seems to be needed, or
 *		if it is the entire Authorization: line, e.g.
 *
 *		   "Authorization: Basic username:password"
 *
 *		As usual, this string is automatically freed.
 */
char *HTAA_composeAuth(const char *hostname,
		       const int portnumber,
		       const char *docname,
		       BOOL IsProxy)
{
    char *auth_string;
    BOOL retry;
    HTAAScheme scheme;
    int len;

    /*
     * Setup atexit() freeing if not done already.  - FM
     */
    if (!free_HTAAGlobalsSet) {
#ifdef LY_FIND_LEAKS
	atexit(free_HTAAGlobals);
#endif
	free_HTAAGlobalsSet = TRUE;
    }

    /*
     * Make gateway httpds pass authorization field as it was received.  (This
     * still doesn't really work because Authenticate:  headers from remote
     * server are not forwarded to client yet so it cannot really know that it
     * should send authorization; I will not implement it yet because I feel we
     * will soon change radically the way requests are represented to allow
     * multithreading on server-side.  Life is hard.)
     */
    if (HTAAForwardAuth) {
	CTRACE((tfp, "HTAA_composeAuth: %s\n",
		"Forwarding received authorization"));
	StrAllocCopy(HTAA_composeAuthResult, HTAAForwardAuth);
	HTAAForwardAuth_reset();	/* Just a precaution */
	return HTAA_composeAuthResult;
    }

    FREE(HTAA_composeAuthResult);	/* From previous call */

    if (IsProxy) {
	/*
	 * Proxy Authorization required.  - AJL
	 */

	CTRACE((tfp, "Composing Proxy Authorization for %s:%d/%s\n",
		hostname, portnumber, docname));

	if (proxy_portnumber != portnumber ||
	    !proxy_hostname || !proxy_docname ||
	    !hostname || !docname ||
	    0 != strcmp(proxy_hostname, hostname) ||
	    0 != strcmp(proxy_docname, docname)) {

	    retry = NO;

	    proxy_portnumber = portnumber;

	    if (hostname)
		StrAllocCopy(proxy_hostname, hostname);
	    else
		FREE(proxy_hostname);

	    if (docname)
		StrAllocCopy(proxy_docname, docname);
	    else
		FREE(proxy_docname);
	} else {
	    retry = YES;
	}

	if (!proxy_setup || !retry)
	    proxy_setup = HTAASetup_lookup(hostname, portnumber,
					   docname, IsProxy);

	if (!proxy_setup)
	    return NULL;

	switch (scheme = HTAA_selectScheme(proxy_setup)) {
	case HTAA_BASIC:
	case HTAA_PUBKEY:
	    auth_string = compose_auth_string(scheme, proxy_setup, IsProxy);
	    break;
	case HTAA_KERBEROS_V4:
	    /* OTHER AUTHENTICATION ROUTINES ARE CALLED HERE */
	default:
	    {
		char *msg = NULL;

		HTSprintf0(&msg, "%s `%s'",
			   gettext("This client doesn't know how to compose proxy authorization information for scheme"),
			   HTAAScheme_name(scheme));
		HTAlert(msg);
		FREE(msg);
		auth_string = NULL;
	    }
	}			/* switch scheme */

	proxy_setup->retry = NO;

	if (!auth_string)
	    /*
	     * Signal a failure.  - FM
	     */
	    return NULL;	/* Added by marca. */
	if (*auth_string == '\0') {
	    /*
	     * Signal an abort.  - FM
	     */
	    StrAllocCopy(HTAA_composeAuthResult, "");
	    return (HTAA_composeAuthResult);
	}
	len = strlen(auth_string) + strlen(HTAAScheme_name(scheme)) + 26;
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
	      outofmem(__FILE__, "HTAA_composeAuth");

	strcpy(HTAA_composeAuthResult, "Proxy-Authorization: ");

    } else {
	/*
	 * Normal WWW authorization.
	 */
	CTRACE((tfp, "Composing Authorization for %s:%d/%s\n",
		hostname, portnumber, docname));

	if (current_portnumber != portnumber ||
	    !current_hostname || !current_docname ||
	    !hostname || !docname ||
	    0 != strcmp(current_hostname, hostname) ||
	    0 != strcmp(current_docname, docname)) {

	    retry = NO;

	    current_portnumber = portnumber;

	    if (hostname)
		StrAllocCopy(current_hostname, hostname);
	    else
		FREE(current_hostname);

	    if (docname)
		StrAllocCopy(current_docname, docname);
	    else
		FREE(current_docname);
	} else {
	    retry = YES;
	}

	if (!current_setup || !retry)
	    current_setup = HTAASetup_lookup(hostname, portnumber,
					     docname, IsProxy);

	if (!current_setup)
	    return NULL;

	switch (scheme = HTAA_selectScheme(current_setup)) {
	case HTAA_BASIC:
	case HTAA_PUBKEY:
	    auth_string = compose_auth_string(scheme, current_setup, IsProxy);
	    break;
	case HTAA_KERBEROS_V4:
	    /* OTHER AUTHENTICATION ROUTINES ARE CALLED HERE */
	default:
	    {
		char *msg = 0;

		HTSprintf0(&msg, "%s `%s'",
			   gettext("This client doesn't know how to compose authorization information for scheme"),
			   HTAAScheme_name(scheme));
		HTAlert(msg);
		FREE(msg);
		auth_string = NULL;
	    }
	}			/* switch scheme */

	current_setup->retry = NO;

	if (!auth_string)
	    /*
	     * Signal a failure.  - FM
	     */
	    return NULL;	/* Added by marca. */
	if (*auth_string == '\0') {
	    /*
	     * Signal an abort.  - FM
	     */
	    StrAllocCopy(HTAA_composeAuthResult, "");
	    return (HTAA_composeAuthResult);
	}

	len = strlen(auth_string) + strlen(HTAAScheme_name(scheme)) + 20;
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
	      outofmem(__FILE__, "HTAA_composeAuth");

	strcpy(HTAA_composeAuthResult, "Authorization: ");
    }

    strcat(HTAA_composeAuthResult, HTAAScheme_name(scheme));
    strcat(HTAA_composeAuthResult, " ");
    strcat(HTAA_composeAuthResult, auth_string);
    return HTAA_composeAuthResult;
}

/* BROWSER PUBLIC				HTAA_shouldRetryWithAuth()
 *
 *		DETERMINES IF WE SHOULD RETRY THE SERVER
 *		WITH AUTHORIZATION
 *		(OR IF ALREADY RETRIED, WITH A DIFFERENT
 *		USERNAME AND/OR PASSWORD (IF MISSPELLED))
 * ON ENTRY:
 *	start_of_headers is the first block already read from socket,
 *			but status line skipped; i.e., points to the
 *			start of the header section.
 *	length		is the remaining length of the first block.
 *	soc		is the socket to read the rest of server reply.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *			This function should only be called when
 *			server has replied with a 401 (Unauthorized)
 *			status code.
 * ON EXIT:
 *	returns		YES, if connection should be retried.
 *			     The node containing all the necessary
 *			     information is
 *				* either constructed if it does not exist
 *				* or password is reset to NULL to indicate
 *				  that username and password should be
 *				  reprompted when composing Authorization:
 *				  field (in function HTAA_composeAuth()).
 *			NO, otherwise.
 */
BOOL HTAA_shouldRetryWithAuth(char *start_of_headers,
			      int length,
			      int soc,
			      BOOL IsProxy)
{
    HTAAScheme scheme;
    char *line = NULL;
    int num_schemes = 0;
    HTList *valid_schemes = HTList_new();
    HTAssocList **scheme_specifics = NULL;
    char *ctemplate = NULL;
    char *temp = NULL;

    /*
     * Setup atexit() freeing if not done already.  - FM
     */
    if (!free_HTAAGlobalsSet) {
#ifdef LY_FIND_LEAKS
	atexit(free_HTAAGlobals);
#endif
	free_HTAAGlobalsSet = TRUE;
    }

    /*
     * Read server reply header lines
     */
    CTRACE((tfp, "Server reply header lines:\n"));

    HTAA_setupReader(start_of_headers, length, soc);
    while (NULL != (line = HTAA_getUnfoldedLine()) && *line != '\0') {
	CTRACE((tfp, "%s\n", line));

	if (strchr(line, ':')) {	/* Valid header line */

	    char *p = line;
	    char *fieldname = HTNextField(&p);
	    char *arg1 = HTNextField(&p);
	    char *args = p;

	    if ((IsProxy &&
		 0 == strcasecomp(fieldname, "Proxy-Authenticate:")) ||
		(!IsProxy &&
		 0 == strcasecomp(fieldname, "WWW-Authenticate:"))) {
		if (!(arg1 && *arg1 && args && *args)) {
		    HTSprintf0(&temp, gettext("Invalid header '%s%s%s%s%s'"), line,
			       (!isEmpty(arg1) ? " " : ""),
			       (!isEmpty(arg1) ? arg1 : ""),
			       (!isEmpty(args) ? " " : ""),
			       (!isEmpty(args) ? args : ""));
		    HTAlert(temp);
		    FREE(temp);
		} else if (HTAA_UNKNOWN != (scheme = HTAAScheme_enum(arg1))) {
		    HTList_addObject(valid_schemes, (void *) scheme);
		    if (!scheme_specifics) {
			int i;

			scheme_specifics =
			    typecallocn(HTAssocList *, HTAA_MAX_SCHEMES);

			if (!scheme_specifics)
			    outofmem(__FILE__, "HTAA_shouldRetryWithAuth");
			for (i = 0; i < HTAA_MAX_SCHEMES; i++)
			    scheme_specifics[i] = NULL;
		    }
		    scheme_specifics[scheme] = HTAA_parseArgList(args);
		    num_schemes++;
		} else {
		    CTRACE((tfp, "Unknown scheme `%s' %s\n",
			    NONNULL(arg1),
			    (IsProxy ?
			     "in Proxy-Authenticate: field" :
			     "in WWW-Authenticate: field")));
		}
	    }

	    else if (!IsProxy &&
		     0 == strcasecomp(fieldname, "WWW-Protection-Template:")) {
		CTRACE((tfp, "Protection template set to `%s'\n", arg1));
		StrAllocCopy(ctemplate, arg1);
	    }

	} else {
	    CTRACE((tfp, "Invalid header line `%s' ignored\n", line));
	}

	FREE(line);
    }				/* while header lines remain */
    FREE(line);

    /*
     * So should we retry with authorization?
     */
    if (IsProxy) {
	if (num_schemes == 0) {
	    /*
	     * No proxy authorization valid
	     */
	    proxy_setup = NULL;
	    return NO;
	}
	/*
	 * Doing it for proxy.  -AJL
	 */
	if (proxy_setup && proxy_setup->server) {
	    /*
	     * We have already tried with proxy authorization.  Either we don't
	     * have access or username or password was misspelled.
	     *
	     * Update scheme-specific parameters (in case they have expired by
	     * chance).
	     */
	    HTAASetup_updateSpecifics(proxy_setup, scheme_specifics);

	    if (NO == HTConfirm(AUTH_FAILED_PROMPT)) {
		proxy_setup = NULL;
		return NO;
	    } else {
		/*
		 * Re-ask username+password (if misspelled).
		 */
		proxy_setup->retry = YES;
		return YES;
	    }
	} else {
	    /*
	     * proxy_setup == NULL, i.e., we have a first connection to a
	     * protected server or the server serves a wider set of documents
	     * than we expected so far.
	     */
	    HTAAServer *server = HTAAServer_lookup(proxy_hostname,
						   proxy_portnumber,
						   IsProxy);

	    if (!server) {
		server = HTAAServer_new(proxy_hostname,
					proxy_portnumber,
					IsProxy);
	    }
	    if (!ctemplate)	/* Proxy matches everything  -AJL */
		StrAllocCopy(ctemplate, "*");
	    proxy_setup = HTAASetup_new(server,
					ctemplate,
					valid_schemes,
					scheme_specifics);
	    FREE(ctemplate);

	    HTAlert(gettext("Proxy authorization required -- retrying"));
	    return YES;
	}
	/* Never reached */
    }
    /*
     * Normal WWW authorization.
     */
    if (num_schemes == 0) {
	/*
	 * No authorization valid.
	 */
	current_setup = NULL;
	return NO;
    }
    if (current_setup && current_setup->server) {
	/*
	 * So we have already tried with WWW authorization.  Either we don't
	 * have access or username or password was misspelled.
	 *
	 * Update scheme-specific parameters (in case they have expired by
	 * chance).
	 */
	HTAASetup_updateSpecifics(current_setup, scheme_specifics);

	if (NO == HTConfirm(AUTH_FAILED_PROMPT)) {
	    current_setup = NULL;
	    return NO;
	} else {
	    /*
	     * Re-ask username+password (if misspelled).
	     */
	    current_setup->retry = YES;
	    return YES;
	}
    } else {
	/*
	 * current_setup == NULL, i.e., we have a first connection to a
	 * protected server or the server serves a wider set of documents than
	 * we expected so far.
	 */
	HTAAServer *server = HTAAServer_lookup(current_hostname,
					       current_portnumber,
					       IsProxy);

	if (!server) {
	    server = HTAAServer_new(current_hostname,
				    current_portnumber,
				    IsProxy);
	}
	if (!ctemplate)
	    ctemplate = HTAA_makeProtectionTemplate(current_docname);
	current_setup = HTAASetup_new(server,
				      ctemplate,
				      valid_schemes,
				      scheme_specifics);
	FREE(ctemplate);

	HTAlert(gettext("Access without authorization denied -- retrying"));
	return YES;
    }
    /* Never reached */
}

/*
 *  This function clears all authorization information by
 *  invoking the free_HTAAGlobals() function, which normally
 *  is invoked at exit.  It allows a browser command to do
 *  this at any time, for example, if the user is leaving
 *  the terminal for a period of time, but does not want
 *  to end the current session.  - FM
 */
void HTClearHTTPAuthInfo(void)
{
    /*
     * Need code to check cached documents against the protection templates,
     * and do something to ensure that any protected documents no longer can be
     * accessed without a new retrieval.  - FM
     */

    /*
     * Now free all of the authorization info, and reset the
     * free_HTAAGlobalsSet flag.  - FM
     */
    free_HTAAGlobals();
    free_HTAAGlobalsSet = FALSE;
}
@


1.5
log
@automatic merge of lynx-current
@
text
@d91 1
a91 1
    char *template;		/* Template for this tree                    */
d343 1
a343 1
	    if (HTAA_templateMatch(setup->template, docname)) {
d346 1
a346 1
			"matched template", setup->template));
d351 1
a351 1
			"did NOT match template", setup->template));
d369 1
a369 1
 *	template	documents matching this template
d383 1
a383 1
static HTAASetup *HTAASetup_new(HTAAServer *server, char *template,
d389 1
a389 1
    if (!server || isEmpty(template))
d397 3
a399 3
    setup->template = NULL;
    if (template)
	StrAllocCopy(setup->template, template);
d421 1
a421 1
	FREE(killme->template);
d568 2
a569 2
    char *i_net_addr = "0.0.0.0";	/* Change... @@@@@@@@ */
    char *timestamp = "42";	/* ... these @@@@@@@@ */
d601 2
a602 2
	if ((!IsProxy) && using_proxy && setup->template) {
	    proxiedHost = HTParse(setup->template, "", PARSE_HOST);
d736 1
a736 1
    HTAAScheme scheme;
d741 1
a741 1
		return scheme;
d913 1
a913 1
	len = strlen(auth_string) + strlen((char *) HTAAScheme_name(scheme)) + 26;
d991 1
a991 1
	len = strlen(auth_string) + strlen((char *) HTAAScheme_name(scheme)) + 20;
d1042 1
a1042 1
    char *template = NULL;
d1077 4
a1080 4
			       ((arg1 && *arg1) ? " " : ""),
			       ((arg1 && *arg1) ? arg1 : ""),
			       ((args && *args) ? " " : ""),
			       ((args && *args) ? args : ""));
d1110 1
a1110 1
		StrAllocCopy(template, arg1);
d1170 2
a1171 2
	    if (!template)	/* Proxy matches everything  -AJL */
		StrAllocCopy(template, "*");
d1173 1
a1173 1
					template,
d1176 1
a1176 1
	    FREE(template);
d1228 2
a1229 2
	if (!template)
	    template = HTAA_makeProtectionTemplate(current_docname);
d1231 1
a1231 1
				      template,
d1234 1
a1234 1
	FREE(template);
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d3 49
a51 49
**		BROWSER SIDE ACCESS AUTHORIZATION MODULE
**
**	Contains the code for keeping track on server hostnames,
**	port numbers, scheme names, usernames, passwords
**	(and servers' public keys).
**
** IMPORTANT:
**	Routines in this module use dynamic allocation, but free
**	automatically all the memory reserved by them.
**
**	Therefore the caller never has to (and never should)
**	free() any object returned by these functions.
**
**	Therefore also all the strings returned by this package
**	are only valid until the next call to the same function
**	is made.  This approach is selected, because of the nature
**	of access authorization: no string returned by the package
**	needs to be valid longer than until the next call.
**
**	This also makes it easy to plug the AA package in:
**	you don't have to ponder whether to free() something
**	here or is it done somewhere else (because it is always
**	done somewhere else).
**
**	The strings that the package needs to store are copied
**	so the original strings given as parameters to AA
**	functions may be freed or modified with no side effects.
**
**	The AA package does not free() anything else than what
**	it has itself allocated.
**
** AUTHORS:
**	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
**
** HISTORY:
**	Oct 17	AL	Made corrections suggested by marca:
**			Added  if (!realm->username) return NULL;
**			Changed some ""s to NULLs.
**			Now doing calloc() to init uuencode source;
**			otherwise HTUU_encode() reads uninitialized memory
**			every now and then (not a real bug but not pretty).
**			Corrected the formula for uuencode destination size.
**
** 28 Apr 1997	AJL	Do Proxy Authorisation.
**
** BUGS:
**
**
*/
d55 5
a59 5
#include <HTParse.h>		/* URL parsing function		*/
#include <HTList.h>		/* HTList object		*/
#include <HTAlert.h>		/* HTConfirm(), HTPrompt()	*/
#include <HTAAUtil.h>		/* AA common to both sides	*/
#include <HTAssoc.h>		/* Assoc list			*/
d61 2
a62 2
#include <HTAABrow.h>		/* Implemented here		*/
#include <HTUU.h>		/* Uuencoding and uudecoding	*/
d67 4
a70 4
**  Local datatype definitions
**
**  HTAAServer contains all the information about one server.
*/
d73 10
a82 10
    char *	hostname;	/* Host's name			*/
    int		portnumber;	/* Port number			*/
    BOOL	IsProxy;	/* Is it a proxy?		*/
    HTList *	setups;		/* List of protection setups	*/
				/* on this server; i.e., valid	*/
				/* authentication schemes and	*/
				/* templates when to use them.	*/
				/* This is actually a list of	*/
				/* HTAASetup objects.		*/
    HTList *	realms;		/* Information about passwords	*/
d86 3
a88 3
**  HTAASetup contains information about one server's one
**  protected tree of documents.
*/
d90 5
a94 5
    HTAAServer *server;		/* Which server serves this tree	     */
    char *	template;	/* Template for this tree		     */
    HTList *	valid_schemes;	/* Valid authentic.schemes		     */
    HTAssocList**scheme_specifics;/* Scheme specific params		     */
    BOOL	retry;		/* Failed last time -- reprompt (or whatever)*/
d98 3
a100 3
**  Information about usernames and passwords in
**  Basic and Pubkey authentication schemes;
*/
d102 3
a104 3
    char *	realmname;	/* Password domain name		*/
    char *	username;	/* Username in that domain	*/
    char *	password;	/* Corresponding password	*/
d108 3
a110 3
**  To free off all globals. - FM
*/
static void free_HTAAGlobals (void);
d116 21
a136 18
**  Module-wide global variables
*/
static HTList *server_table	= NULL;	/* Browser's info about servers	     */
static char *secret_key	= NULL;	/* Browser's latest secret key       */
static HTAASetup *current_setup= NULL;	/* The server setup we are currently */
					/* talking to			     */
static char *current_hostname	= NULL;	/* The server's name and portnumber  */
static int current_portnumber	= 80;	/* where we are currently trying to  */
					/* connect.			     */
static char *current_docname	= NULL; /* The document's name we are	     */
					/* trying to access.		     */
static char *HTAAForwardAuth	= NULL;	/* Authorization: line to forward    */
					/* (used by gateway httpds)	     */
static HTAASetup *proxy_setup	= NULL;	/* Same as above, but for Proxy -AJL */
static char *proxy_hostname	= NULL;
static char *proxy_docname	= NULL;
static int proxy_portnumber	= 80;

d140 2
a141 3
void HTAAForwardAuth_set (
	const char *	scheme_name,
	const char *	scheme_specifics)
d143 2
a144 2
    int len = 20 + (scheme_name      ? strlen(scheme_name)      : 0)
		 + (scheme_specifics ? strlen(scheme_specifics) : 0);
d148 1
a148 1
	outofmem(__FILE__, "HTAAForwardAuth_set");
d160 1
a160 1
void HTAAForwardAuth_reset (void)
a164 1

d167 1
a167 1
static void HTAASetup_delete (HTAASetup * killme);	/* Forward */
d170 18
a187 19
**		ALLOCATE A NEW NODE TO HOLD SERVER INFO
**		AND ADD IT TO THE LIST OF SERVERS
** ON ENTRY:
**	hostname	is the name of the host that the server
**			is running in.
**	portnumber	is the portnumber which the server listens.
**	IsProxy		should be TRUE if this is a proxy.
**
** ON EXIT:
**	returns		the newly-allocated node with all the strings
**			duplicated.
**			Strings will be automatically freed by
**			the function HTAAServer_delete(), which also
**			frees the node itself.
*/
static HTAAServer *HTAAServer_new (
	const char*	hostname,
	int		portnumber,
	BOOL		IsProxy)
d192 1
a192 1
	outofmem(__FILE__, "HTAAServer_new");
d194 5
a198 5
    server->hostname	= NULL;
    server->portnumber	= (portnumber > 0 ? portnumber : 80);
    server->IsProxy	= IsProxy;
    server->setups	= HTList_new();
    server->realms	= HTList_new();
d206 1
a206 1
    HTList_addObject(server_table, (void*)server);
a210 1

d212 11
a222 12
**
**	DELETE THE ENTRY FOR THE SERVER FROM THE HOST TABLE,
**	AND FREE THE MEMORY USED BY IT.
**
** ON ENTRY:
**	killme		points to the HTAAServer to be freed.
**
** ON EXIT:
**	returns		nothing.
*/
static void HTAAServer_delete (
	HTAAServer *	killme)
d233 2
a234 2
		if ((setup = (HTAASetup*)HTList_objectAt(killme->setups,
							 i)) != NULL) {
d244 1
a244 1
	while (NULL != (realm = (HTAARealm*)HTList_nextObject(cur))) {
d255 1
a255 1
	HTList_removeObject(server_table, (void*)killme);
d261 16
a276 17
**		LOOK UP SERVER BY HOSTNAME AND PORTNUMBER
** ON ENTRY:
**	hostname	obvious.
**	portnumber	if non-positive defaults to 80.
**	IsProxy		should be TRUE if this is a proxy.
**
**	Looks up the server in the module-global server_table.
**
** ON EXIT:
**	returns		pointer to a HTAAServer structure
**			representing the looked-up server.
**			NULL, if not found.
*/
static HTAAServer *HTAAServer_lookup (
	const char *	hostname,
	int		portnumber,
	BOOL		IsProxy)
d285 3
a287 3
	while (NULL != (server = (HTAAServer*)HTList_nextObject(cur))) {
	    if (server->portnumber == portnumber  &&
		0==strcmp(server->hostname, hostname) &&
d292 1
a292 1
    return NULL;	/* NULL parameter, or not found */
a294 1

d298 25
a322 26
**	FIGURE OUT WHICH AUTHENTICATION SETUP THE SERVER
**	IS USING FOR A GIVEN FILE ON A GIVEN HOST AND PORT
**
** ON ENTRY:
**	hostname	is the name of the server host machine.
**	portnumber	is the port that the server is running in.
**	docname		is the (URL-)pathname of the document we
**			are trying to access.
**	IsProxy		should be TRUE if this is a proxy.
**
**	This function goes through the information known about
**	all the setups of the server, and finds out if the given
**	filename resides in one of the protected directories.
**
** ON EXIT:
**	returns		NULL if no match.
**			Otherwise, a HTAASetup structure representing
**			the protected server setup on the corresponding
**			document tree.
**
*/
static HTAASetup *HTAASetup_lookup (
	const char *	hostname,
	int		portnumber,
	const char *	docname,
	BOOL		IsProxy)
d338 3
a340 3
		    "HTAASetup_lookup: resolving setup for",
		    (IsProxy ? "proxy" : "server"),
		    hostname, portnumber, docname));
d342 1
a342 1
	while (NULL != (setup = (HTAASetup*)HTList_nextObject(cur))) {
d345 2
a346 2
			    "HTAASetup_lookup:", docname,
			    "matched template", setup->template));
d350 2
a351 2
			    "HTAASetup_lookup:", docname,
			    "did NOT match template", setup->template));
d353 3
a355 3
	} /* while setups remain */
    } /* if valid parameters and server found */

d357 3
a359 3
		 "HTAASetup_lookup: No template matched",
		 NONNULL(docname),
		 "(so probably not protected)"));
d361 1
a361 1
    return NULL;	/* NULL in parameters, or not found */
d365 21
a385 23
**			CREATE A NEW SETUP NODE
** ON ENTRY:
**	server		is a pointer to a HTAAServer structure
**			to which this setup belongs.
**	template	documents matching this template
**			are protected according to this setup.
**	valid_schemes	a list containing all valid authentication
**			schemes for this setup.
**			If NULL, all schemes are disallowed.
**	scheme_specifics is an array of assoc lists, which
**			contain scheme specific parameters given
**			by server in Authenticate: fields.
**			If NULL, all scheme specifics are
**			set to NULL.
** ON EXIT:
**	returns		a new HTAASetup node, and also adds it as
**			part of the HTAAServer given as parameter.
*/
static HTAASetup *HTAASetup_new (
	HTAAServer *	server,
	char *		template,
	HTList *	valid_schemes,
	HTAssocList **	scheme_specifics)
d403 1
a403 1
    HTList_addObject(server->setups, (void*)setup);
d409 8
a416 9
**			FREE A HTAASetup STRUCTURE
** ON ENTRY:
**	killme		is a pointer to the structure to free().
**
** ON EXIT:
**	returns		nothing.
*/
static void HTAASetup_delete (
	HTAASetup *	killme)
d435 13
a447 15
*		COPY SCHEME SPECIFIC PARAMETERS
**		TO HTAASetup STRUCTURE
** ON ENTRY:
**	setup		destination setup structure.
**	specifics	string array containing scheme
**			specific parameters for each scheme.
**			If NULL, all the scheme specific
**			parameters are set to NULL.
**
** ON EXIT:
**	returns		nothing.
*/
static void HTAASetup_updateSpecifics (
	HTAASetup *	setup,
	HTAssocList **	specifics)
a462 1

d466 10
a475 11
**		LOOKUP HTAARealm STRUCTURE BY REALM NAME
** ON ENTRY:
**	realm_table	a list of realm objects.
**	realmname	is the name of realm to look for.
**
** ON EXIT:
**	returns		the realm.  NULL, if not found.
*/
static HTAARealm *HTAARealm_lookup (
	HTList *	realm_table,
	const char *	realmname)
d481 2
a482 2
	while (NULL != (realm = (HTAARealm*)HTList_nextObject(cur))) {
	    if (0==strcmp(realm->realmname, realmname))
d486 1
a486 1
    return NULL;	/* No table, NULL param, or not found */
d490 18
a507 19
**		CREATE A NODE CONTAINING USERNAME AND
**		PASSWORD USED FOR THE GIVEN REALM.
**		IF REALM ALREADY EXISTS, CHANGE
**		USERNAME/PASSWORD.
** ON ENTRY:
**	realm_table	a list of realms to where to add
**			the new one, too.
**	realmname	is the name of the password domain.
**	username	and
**	password	are what you can expect them to be.
**
** ON EXIT:
**	returns		the created realm.
*/
static HTAARealm *HTAARealm_new (
	HTList *	realm_table,
	const char *	realmname,
	const char *	username,
	const char *	password)
d515 2
a516 1
	    outofmem(__FILE__, "HTAARealm_new");
d522 1
a522 1
	    HTList_addObject(realm_table, (void*)realm);
a531 1

d535 21
a555 24
**
**		COMPOSE Basic OR Pubkey AUTHENTICATION STRING;
**		PROMPTS FOR USERNAME AND PASSWORD IF NEEDED
**
** ON ENTRY:
**	scheme		is either HTAA_BASIC or HTAA_PUBKEY.
**	setup		is the current server setup.
**	IsProxy		should be TRUE if this is a proxy.
**
** ON EXIT:
**	returns		a newly composed authorization string,
**			(with, of course, a newly generated secret
**			key and fresh timestamp, if Pubkey-scheme
**			is being used).
**			NULL, if something fails.
** NOTE:
**	Like throughout the entire AA package, no string or structure
**	returned by AA package needs to (or should) be freed.
**
*/
static char *compose_auth_string (
	HTAAScheme	scheme,
	HTAASetup *	setup,
	BOOL		IsProxy)
d569 1
a569 2
    char *timestamp = "42";		/* ... these @@@@@@@@ */

d575 1
a575 1
	!setup->server  ||  !setup->server->realms)
d588 2
a589 2
			"compose_auth_string: realm:", realmname,
			"not found -- creating"));
d594 6
a599 8
	 *  The template should be either the '*' global
	 *  for everything on the server (always true for
	 *  proxy authorization setups), or a path for
	 *  the start of a protected limb, with no host
	 *  field, but we'll check for a host anyway in
	 *  case a WWW-Protection-Template header set an
	 *  absolute URL instead of a path.  If we do get
	 *  a host from this, it will include the port. - FM
d608 2
a609 3
	 *  If we didn't get a host field from the
	 *  template, set up the host name and port
	 *  from the setup->server elements. - FM
d618 4
a621 5
	 *  Set up the message for the username prompt,
	 *  and then issue the prompt.  The default
	 *  username is included in the call to the
	 *  prompting function, but the password is
	 *  NULL-ed and always replaced. - FM
d624 2
a625 2
	      strlen(theHost ?
		     theHost : "??") + 50;
d627 4
a630 4
		     realm->realmname,
		     (IsProxy ? "proxy" : "server"),
		     (theHost ? theHost : "??"),
		     NonNull(thePort));
d645 1
a645 1
	     *  Signals to retry. - FM
d650 1
a650 1
	     *  Signals to abort. - FM
d658 1
a658 1
	  strlen(NonNull(realm->password)) + 3;
d672 1
a672 1
	outofmem(__FILE__, "compose_auth_string");
d694 3
a696 2
	      (compose_auth_stringResult = typecallocn(char, 3 * len))))
	    outofmem(__FILE__, "compose_auth_string");
d699 1
a699 1
	HTUU_encode((unsigned char *)ciphertext, strlen(ciphertext),
d704 1
a704 2
    }
    else { /* scheme == HTAA_BASIC */
d706 4
a709 3
				typecallocn(char, (4 * ((len+2)/3)) + 1)))
	    outofmem(__FILE__, "compose_auth_string");
	HTUU_encode((unsigned char *)cleartext, strlen(cleartext),
d717 18
a734 19
**		SELECT THE AUTHENTICATION SCHEME TO USE
** ON ENTRY:
**	setup	is the server setup structure which can
**		be used to make the decision about the
**		used scheme.
**
**	When new authentication methods are added to library
**	this function makes the decision about which one to
**	use at a given time.  This can be done by inspecting
**	environment variables etc.
**
**	Currently only searches for the first valid scheme,
**	and if nothing found suggests Basic scheme;
**
** ON EXIT:
**	returns	the authentication scheme to use.
*/
static HTAAScheme HTAA_selectScheme (
	HTAASetup *	setup)
d740 1
a740 1
	    if (-1 < HTList_indexOf(setup->valid_schemes, (void*)scheme))
d747 9
a755 9
**  Purpose:	Free off all module globals.
**  Arguments:	void
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**	To be used at program exit.
**  Revision History:
**	06-19-96	created - FM
*/
static void free_HTAAGlobals (void)
d757 1
a757 1
    HTAAServer * server;
d763 2
a764 2
	    if ((server = (HTAAServer*)HTList_objectAt(server_table,
							i)) != NULL) {
d784 23
a806 24
**
**	SELECT THE AUTHENTICATION SCHEME AND
**	COMPOSE THE ENTIRE AUTHORIZATION HEADER LINE
**	IF WE ALREADY KNOW THAT THE HOST REQUIRES AUTHENTICATION
**
** ON ENTRY:
**	hostname	is the hostname of the server.
**	portnumber	is the portnumber in which the server runs.
**	docname		is the pathname of the document (as in URL)
**	IsProxy		should be TRUE if this is a proxy.
**
** ON EXIT:
**	returns	NULL, if no authorization seems to be needed, or
**		if it is the entire Authorization: line, e.g.
**
**		   "Authorization: Basic username:password"
**
**		As usual, this string is automatically freed.
*/
char *HTAA_composeAuth (
	const char *	hostname,
	const int	portnumber,
	const char *	docname,
	BOOL		IsProxy)
d814 2
a815 2
    **  Setup atexit() freeing if not done already. - FM
    */
d824 7
a830 8
    ** Make gateway httpds pass authorization field as it was received.
    ** (This still doesn't really work because Authenticate: headers
    **  from remote server are not forwarded to client yet so it cannot
    **  really know that it should send authorization;  I will not
    **  implement it yet because I feel we will soon change radically
    **  the way requests are represented to allow multithreading
    **  on server-side.  Life is hard.)
    */
d833 1
a833 1
		    "Forwarding received authorization"));
d843 2
a844 2
	**  Proxy Authorization required. - AJL
	*/
d847 1
a847 1
		    hostname, portnumber, docname));
d849 3
a851 3
	if (proxy_portnumber  != portnumber       ||
	    !proxy_hostname   || !proxy_docname   ||
	    !hostname         || !docname         ||
d880 2
a881 2
	  case HTAA_BASIC:
	  case HTAA_PUBKEY:
d884 1
a884 1
	  case HTAA_KERBEROS_V4:
d886 1
a886 1
	  default:
d889 1
d891 2
a892 2
			gettext("This client doesn't know how to compose proxy authorization information for scheme"),
			HTAAScheme_name(scheme));
d897 1
a897 1
	} /* switch scheme */
d903 3
a905 3
	    **  Signal a failure. - FM
	    */
	    return NULL;  /* Added by marca. */
d908 2
a909 2
	    **  Signal an abort. - FM
	    */
d911 1
a911 1
	    return(HTAA_composeAuthResult);
d913 1
a913 1
	len = strlen(auth_string) + strlen((char *)HTAAScheme_name(scheme)) + 26;
d915 2
a916 1
	    outofmem(__FILE__, "HTAA_composeAuth");
d921 2
a922 2
	**  Normal WWW authorization.
	*/
d924 1
a924 1
		    hostname, portnumber, docname));
d928 1
a928 1
	    !hostname         || !docname         ||
d957 2
a958 2
	  case HTAA_BASIC:
	  case HTAA_PUBKEY:
d961 1
a961 1
	  case HTAA_KERBEROS_V4:
d963 1
a963 1
	  default:
d966 1
d968 2
a969 2
			gettext("This client doesn't know how to compose authorization information for scheme"),
			HTAAScheme_name(scheme));
d974 1
a974 1
	} /* switch scheme */
d980 3
a982 3
	    **  Signal a failure. - FM
	    */
	    return NULL;  /* Added by marca. */
d985 2
a986 2
	    **  Signal an abort. - FM
	    */
d988 1
a988 1
	    return(HTAA_composeAuthResult);
d991 1
a991 1
	len = strlen(auth_string) + strlen((char *)HTAAScheme_name(scheme)) + 20;
d993 2
a994 1
	    outofmem(__FILE__, "HTAA_composeAuth");
d1005 31
a1035 32
**
**		DETERMINES IF WE SHOULD RETRY THE SERVER
**		WITH AUTHORIZATION
**		(OR IF ALREADY RETRIED, WITH A DIFFERENT
**		USERNAME AND/OR PASSWORD (IF MISSPELLED))
** ON ENTRY:
**	start_of_headers is the first block already read from socket,
**			but status line skipped; i.e., points to the
**			start of the header section.
**	length		is the remaining length of the first block.
**	soc		is the socket to read the rest of server reply.
**	IsProxy		should be TRUE if this is a proxy.
**
**			This function should only be called when
**			server has replied with a 401 (Unauthorized)
**			status code.
** ON EXIT:
**	returns		YES, if connection should be retried.
**			     The node containing all the necessary
**			     information is
**				* either constructed if it does not exist
**				* or password is reset to NULL to indicate
**				  that username and password should be
**				  reprompted when composing Authorization:
**				  field (in function HTAA_composeAuth()).
**			NO, otherwise.
*/
BOOL HTAA_shouldRetryWithAuth (
	char *		start_of_headers,
	int		length,
	int		soc,
	BOOL		IsProxy)
d1046 2
a1047 2
    **  Setup atexit() freeing if not done already. - FM
    */
d1056 2
a1057 2
    **  Read server reply header lines
    */
d1061 1
a1061 1
    while (NULL != (line = HTAA_getUnfoldedLine())  &&  *line != '\0') {
d1072 1
a1072 1
		 0==strcasecomp(fieldname, "Proxy-Authenticate:")) ||
d1074 1
a1074 1
		 0==strcasecomp(fieldname, "WWW-Authenticate:"))) {
d1077 4
a1080 4
				  ((arg1 && *arg1) ? " "  : ""),
				  ((arg1 && *arg1) ? arg1 : ""),
				  ((args && *args) ? " "  : ""),
				  ((args && *args) ? args : ""));
d1083 2
a1084 3
		}
		else if (HTAA_UNKNOWN != (scheme = HTAAScheme_enum(arg1))) {
		    HTList_addObject(valid_schemes, (void*)scheme);
d1087 1
d1090 1
d1093 1
a1093 1
			for (i=0; i < HTAA_MAX_SCHEMES; i++)
d1108 1
a1108 1
		     0==strcasecomp(fieldname, "WWW-Protection-Template:")) {
d1113 1
a1113 2
	} /* if a valid header line */
	else {
d1115 1
a1115 1
	} /* else invalid header line */
d1118 1
a1118 1
    } /* while header lines remain */
a1120 1

d1122 2
a1123 2
    **  So should we retry with authorization?
    */
d1127 2
a1128 2
	    **  No proxy authorization valid
	    */
d1133 2
a1134 2
	**  Doing it for proxy.  -AJL
	*/
d1137 6
a1142 7
	    **  We have already tried with proxy authorization.
	    **  Either we don't have access or username or
	    **  password was misspelled.
	    **
	    **  Update scheme-specific parameters
	    **  (in case they have expired by chance).
	    */
d1150 2
a1151 2
		**  Re-ask username+password (if misspelled).
		*/
d1157 4
a1160 5
	    **  proxy_setup == NULL, i.e., we have a
	    **  first connection to a protected server or
	    **  the server serves a wider set of documents
	    **  than we expected so far.
	    */
d1164 1
d1173 3
a1175 3
					  template,
					  valid_schemes,
					  scheme_specifics);
d1184 2
a1185 2
    **  Normal WWW authorization.
    */
d1188 2
a1189 2
	**  No authorization valid.
	*/
d1195 6
a1200 7
	**  So we have already tried with WWW authorization.
	**  Either we don't have access or username or
	**  password was misspelled.
	**
	**  Update scheme-specific parameters
	**  (in case they have expired by chance).
	*/
d1208 2
a1209 2
	    **  Re-ask username+password (if misspelled).
	    */
d1215 4
a1218 5
	**  current_setup == NULL, i.e., we have a
	**  first connection to a protected server or
	**  the server serves a wider set of documents
	**  than we expected so far.
	*/
d1222 1
d1243 8
a1250 8
**  This function clears all authorization information by
**  invoking the free_HTAAGlobals() function, which normally
**  is invoked at exit.  It allows a browser command to do
**  this at any time, for example, if the user is leaving
**  the terminal for a period of time, but does not want
**  to end the current session.  - FM
*/
void HTClearHTTPAuthInfo (void)
d1253 4
a1256 5
    **  Need code to check cached documents against the
    **  protection templates, and do something to ensure
    **  that any protected documents no longer can be
    **  accessed without a new retrieval. - FM
    */
d1259 3
a1261 3
    **  Now free all of the authorization info, and
    **  reset the free_HTAAGlobalsSet flag. - FM
    */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d110 4
a113 4
PRIVATE void free_HTAAGlobals NOPARAMS;
PRIVATE BOOL free_HTAAGlobalsSet = FALSE;
PRIVATE char *HTAA_composeAuthResult = NULL;
PRIVATE char *compose_auth_stringResult = NULL;	/* Uuencoded presentation */
d118 3
a120 3
PRIVATE HTList *server_table	= NULL;	/* Browser's info about servers	     */
PRIVATE char *secret_key	= NULL;	/* Browser's latest secret key       */
PRIVATE HTAASetup *current_setup= NULL;	/* The server setup we are currently */
d122 2
a123 2
PRIVATE char *current_hostname	= NULL;	/* The server's name and portnumber  */
PRIVATE int current_portnumber	= 80;	/* where we are currently trying to  */
d125 1
a125 1
PRIVATE char *current_docname	= NULL; /* The document's name we are	     */
d127 1
a127 1
PRIVATE char *HTAAForwardAuth	= NULL;	/* Authorization: line to forward    */
d129 4
a132 4
PRIVATE HTAASetup *proxy_setup	= NULL;	/* Same as above, but for Proxy -AJL */
PRIVATE char *proxy_hostname	= NULL;
PRIVATE char *proxy_docname	= NULL;
PRIVATE int proxy_portnumber	= 80;
d137 3
a139 3
PUBLIC void HTAAForwardAuth_set ARGS2(
	CONST char *,	scheme_name,
	CONST char *,	scheme_specifics)
d158 1
a158 1
PUBLIC void HTAAForwardAuth_reset NOARGS
d166 1
a166 1
PRIVATE void HTAASetup_delete PARAMS((HTAASetup * killme));	/* Forward */
d168 1
a168 1
/* PRIVATE						HTAAServer_new()
d184 4
a187 4
PRIVATE HTAAServer *HTAAServer_new ARGS3(
	CONST char*,	hostname,
	int,		portnumber,
	BOOL,		IsProxy)
d212 1
a212 1
/* PRIVATE						HTAAServer_delete()
d223 2
a224 2
PRIVATE void HTAAServer_delete ARGS1(
	HTAAServer *,	killme)
d262 1
a262 1
/* PRIVATE						HTAAServer_lookup()
d276 4
a279 4
PRIVATE HTAAServer *HTAAServer_lookup ARGS3(
	CONST char *,	hostname,
	int,		portnumber,
	BOOL,		IsProxy)
d301 1
a301 1
/* PRIVATE						HTAASetup_lookup()
d323 5
a327 5
PRIVATE HTAASetup *HTAASetup_lookup ARGS4(
	CONST char *,	hostname,
	int,		portnumber,
	CONST char *,	docname,
	BOOL,		IsProxy)
d369 1
a369 1
/* PRIVATE						HTAASetup_new()
d388 5
a392 5
PRIVATE HTAASetup *HTAASetup_new ARGS4(
	HTAAServer *,	server,
	char *,		template,
	HTList *,	valid_schemes,
	HTAssocList **,	scheme_specifics)
d415 1
a415 1
/* PRIVATE						HTAASetup_delete()
d423 2
a424 2
PRIVATE void HTAASetup_delete ARGS1(
	HTAASetup *,	killme)
d442 1
a442 1
/* PRIVATE					HTAASetup_updateSpecifics()
d455 3
a457 3
PRIVATE void HTAASetup_updateSpecifics ARGS2(
	HTAASetup *,	setup,
	HTAssocList **,	specifics)
d476 1
a476 1
/* PRIVATE						HTAARealm_lookup()
d485 3
a487 3
PRIVATE HTAARealm *HTAARealm_lookup ARGS2(
	HTList *,	realm_table,
	CONST char *,	realmname)
d501 1
a501 1
/* PRIVATE						HTAARealm_new()
d516 5
a520 5
PRIVATE HTAARealm *HTAARealm_new ARGS4(
	HTList *,	realm_table,
	CONST char *,	realmname,
	CONST char *,	username,
	CONST char *,	password)
d547 1
a547 1
/* PRIVATE						compose_auth_string()
d568 4
a571 4
PRIVATE char *compose_auth_string ARGS3(
	HTAAScheme,	scheme,
	HTAASetup *,	setup,
	BOOL,		IsProxy)
d736 1
a736 1
/* BROWSER PRIVATE					HTAA_selectScheme()
d754 2
a755 2
PRIVATE HTAAScheme HTAA_selectScheme ARGS1(
	HTAASetup *,	setup)
d776 1
a776 1
PRIVATE void free_HTAAGlobals NOARGS
d824 5
a828 5
PUBLIC char *HTAA_composeAuth ARGS4(
	CONST char *,	hostname,
	CONST int,	portnumber,
	CONST char *,	docname,
	BOOL,		IsProxy)
d1051 5
a1055 5
PUBLIC BOOL HTAA_shouldRetryWithAuth ARGS4(
	char *,		start_of_headers,
	int,		length,
	int,		soc,
	BOOL,		IsProxy)
d1273 1
a1273 1
PUBLIC void HTClearHTTPAuthInfo NOARGS
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d60 1
a65 2
extern BOOL using_proxy;	/* Are we using an HTTP gateway? */

d77 5
a81 5
                                /* on this server; i.e., valid	*/
                                /* authentication schemes and	*/
                                /* templates when to use them.	*/
                                /* This is actually a list of	*/
                                /* HTAASetup objects.		*/
d92 1
a92 1
    HTList *	valid_schemes;	/* Valid authentic.schemes   		     */
d121 1
a121 1
                                        /* talking to			     */
d124 3
a126 3
                                        /* connect.			     */
PRIVATE char *current_docname	= NULL;	/* The document's name we are        */
                                        /* trying to access.		     */
d128 1
a128 1
                                        /* (used by gateway httpds)	     */
d142 1
a142 1
	         + (scheme_specifics ? strlen(scheme_specifics) : 0);
d145 1
a145 1
    if (!(HTAAForwardAuth = (char*)calloc(1, sizeof(char) * len)))
d191 1
a191 1
    if (!(server = (HTAAServer *)calloc(1, sizeof(HTAAServer))))
d201 1
a201 1
        StrAllocCopy(server->hostname, hostname);
d204 1
a204 1
        server_table = HTList_new();
d235 2
a236 2
	        if ((setup = (HTAASetup*)HTList_objectAt(killme->setups,
	     						 i)) != NULL) {
d312 1
a312 1
** 	This function goes through the information known about
d333 1
a333 1
        portnumber = 80;
d342 1
a342 1
	CTRACE(tfp, "%s %s (%s:%d:%s)\n",
d345 1
a345 1
		    hostname, portnumber, docname);
d349 1
a349 1
		CTRACE(tfp, "%s `%s' %s `%s'\n",
d351 1
a351 1
			    "matched template", setup->template);
d354 1
a354 1
	        CTRACE(tfp, "%s `%s' %s `%s'\n",
d356 1
a356 1
			    "did NOT match template", setup->template);
d361 1
a361 1
    CTRACE(tfp, "%s `%s' %s\n",
d363 2
a364 2
		 (docname ? docname : "(null)"),
		 "(so probably not protected)");
d396 2
a397 2
    if (!server || !template || !*template)
        return NULL;
d399 1
a399 1
    if (!(setup = (HTAASetup*)calloc(1, sizeof(HTAASetup))))
d406 1
a406 1
        StrAllocCopy(setup->template, template);
d430 1
a430 1
	if (killme->valid_schemes)
d433 1
d476 1
a476 1
/* PRIVATE 						HTAARealm_lookup()
d527 1
a527 1
	if (!(realm = (HTAARealm*)calloc(1, sizeof(HTAARealm))))
d537 1
a537 1
        StrAllocCopy(realm->username, username);
d539 1
a539 1
        StrAllocCopy(realm->password, password);
d597 1
a597 1
        return NULL;
d601 1
a601 1
    	  realm->username && *realm->username &&
d604 1
a604 1
	    CTRACE(tfp, "%s `%s' %s\n",
d606 1
a606 1
			"not found -- creating");
d623 1
a623 1
	        theHost = proxiedHost;
d633 4
a636 4
	    if (setup->server->portnumber > 0 &&
		setup->server->portnumber != 80) {
		HTSprintf0(&thePort, ":%d", setup->server->portnumber);
	    }
d646 1
a646 1
	      	     theHost : "??") + 50;
d651 1
a651 1
		     (thePort ? thePort : ""));
d678 2
a679 2
    len = strlen(realm->username ? realm->username : "") +
	  strlen(realm->password ? realm->password : "") + 3;
d687 1
a687 1
	len += strlen(secret_key ? secret_key : "") + 30;
d692 1
a692 1
    if (!(cleartext  = (char*)calloc(1, sizeof(char) * len)))
d696 1
a696 1
        strcpy(cleartext, realm->username);
d698 1
a698 1
        *cleartext = '\0';
d703 1
a703 1
        strcat(cleartext, realm->password);
d714 2
a715 3
	if (!((ciphertext = (char *)calloc(1, (sizeof(char) * 2) * len)) &&
	      (compose_auth_stringResult =
	      		    (char *)calloc(1, (sizeof(char) * 3) * len))))
d727 1
a727 1
				(char*)calloc(1, (4 * ((len+2)/3)) + 1)))
d782 1
a782 1
        n = HTList_count(server_table);
d785 2
a786 2
	     						i)) != NULL) {
	        HTAAServer_delete(server);
d840 1
a840 1
        atexit(free_HTAAGlobals);
d855 2
a856 2
	CTRACE(tfp, "HTAA_composeAuth: %s\n",
		    "Forwarding received authorization");
d865 1
a865 1
        /*
d869 2
a870 2
	CTRACE(tfp, "Composing Proxy Authorization for %s:%d/%s\n",
		    hostname, portnumber, docname);
d872 2
a873 2
	if (proxy_portnumber != portnumber ||
	    !proxy_hostname || !proxy_docname ||
d902 1
a902 1
    	switch (scheme = HTAA_selectScheme(proxy_setup)) {
d936 1
a936 1
	if (!(HTAA_composeAuthResult = (char*)calloc(1, sizeof(char) * len)))
d944 2
a945 2
	CTRACE(tfp, "Composing Authorization for %s:%d/%s\n",
		    hostname, portnumber, docname);
d1012 1
a1012 1
	if (!(HTAA_composeAuthResult = (char*)calloc(1, sizeof(char) * len)))
d1070 1
a1070 1
        atexit(free_HTAAGlobals);
d1078 1
a1078 1
    CTRACE(tfp, "Server reply header lines:\n");
d1082 1
a1082 1
	CTRACE(tfp, "%s\n", line);
d1093 1
a1093 1
	        (!IsProxy &&
d1095 1
a1095 1
	        if (!(arg1 && *arg1 && args && *args)) {
d1108 2
a1109 2
			scheme_specifics = (HTAssocList**)
			    calloc(1, HTAA_MAX_SCHEMES * sizeof(HTAssocList*));
d1118 2
a1119 2
		    CTRACE(tfp, "Unknown scheme `%s' %s\n",
			    (arg1 ? arg1 : "(null)"),
d1122 1
a1122 1
			     "in WWW-Authenticate: field"));
d1128 1
a1128 1
		CTRACE(tfp, "Protection template set to `%s'\n", arg1);
d1134 1
a1134 1
	    CTRACE(tfp, "Invalid header line `%s' ignored\n", line);
d1153 1
a1153 1
        /*
d1171 1
a1171 1
	        /*
d1237 1
a1237 1
        /*
d1259 1
a1259 1
        HTAlert(gettext("Access without authorization denied -- retrying"));
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d3 49
a51 49
 *		BROWSER SIDE ACCESS AUTHORIZATION MODULE
 *
 *	Contains the code for keeping track on server hostnames,
 *	port numbers, scheme names, usernames, passwords
 *	(and servers' public keys).
 *
 * IMPORTANT:
 *	Routines in this module use dynamic allocation, but free
 *	automatically all the memory reserved by them.
 *
 *	Therefore the caller never has to (and never should)
 *	free() any object returned by these functions.
 *
 *	Therefore also all the strings returned by this package
 *	are only valid until the next call to the same function
 *	is made.  This approach is selected, because of the nature
 *	of access authorization: no string returned by the package
 *	needs to be valid longer than until the next call.
 *
 *	This also makes it easy to plug the AA package in:
 *	you don't have to ponder whether to free() something
 *	here or is it done somewhere else (because it is always
 *	done somewhere else).
 *
 *	The strings that the package needs to store are copied
 *	so the original strings given as parameters to AA
 *	functions may be freed or modified with no side effects.
 *
 *	The AA package does not free() anything else than what
 *	it has itself allocated.
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *
 * HISTORY:
 *	Oct 17	AL	Made corrections suggested by marca:
 *			Added  if (!realm->username) return NULL;
 *			Changed some ""s to NULLs.
 *			Now doing calloc() to init uuencode source;
 *			otherwise HTUU_encode() reads uninitialized memory
 *			every now and then (not a real bug but not pretty).
 *			Corrected the formula for uuencode destination size.
 *
 * 28 Apr 1997	AJL	Do Proxy Authorisation.
 *
 * BUGS:
 *
 *
 */
d55 7
a61 8
#include <HTParse.h>		/* URL parsing function         */
#include <HTList.h>		/* HTList object                */
#include <HTAlert.h>		/* HTConfirm(), HTPrompt()      */
#include <HTAAUtil.h>		/* AA common to both sides      */
#include <HTAssoc.h>		/* Assoc list                   */
#include <HTAccess.h>		/* Are we using an HTTP gateway? */
#include <HTAABrow.h>		/* Implemented here             */
#include <HTUU.h>		/* Uuencoding and uudecoding    */
d65 2
d68 4
a71 4
 *  Local datatype definitions
 *
 *  HTAAServer contains all the information about one server.
 */
d74 10
a83 10
    char *hostname;		/* Host's name                  */
    int portnumber;		/* Port number                  */
    BOOL IsProxy;		/* Is it a proxy?               */
    HTList *setups;		/* List of protection setups 
				   on this server; i.e., valid
				   authentication schemes and
				   templates when to use them.
				   This is actually a list of
				   HTAASetup objects.           */
    HTList *realms;		/* Information about passwords  */
d87 3
a89 3
 *  HTAASetup contains information about one server's one
 *  protected tree of documents.
 */
d91 5
a95 5
    HTAAServer *server;		/* Which server serves this tree             */
    char *ctemplate;		/* Template for this tree                    */
    HTList *valid_schemes;	/* Valid authentic.schemes                   */
    HTAssocList **scheme_specifics;	/* Scheme specific params                  */
    BOOL retry;			/* Failed last time -- reprompt (or whatever) */
d99 3
a101 3
 *  Information about usernames and passwords in
 *  Basic and Pubkey authentication schemes;
 */
d103 3
a105 3
    char *realmname;		/* Password domain name         */
    char *username;		/* Username in that domain      */
    char *password;		/* Corresponding password       */
d109 6
a114 6
 *  To free off all globals. - FM
 */
static void free_HTAAGlobals(void);
static BOOL free_HTAAGlobalsSet = FALSE;
static char *HTAA_composeAuthResult = NULL;
static char *compose_auth_stringResult = NULL;	/* Uuencoded presentation */
d117 18
a134 21
 *  Module-wide global variables
 */
static HTList *server_table = NULL;	/* Browser's info about servers      */
static char *secret_key = NULL;	/* Browser's latest secret key       */
static HTAASetup *current_setup = NULL;		/* The server setup we are currently */

					/* talking to                        */
static char *current_hostname = NULL;	/* The server's name and portnumber  */
static int current_portnumber = 80;	/* where we are currently trying to  */

					/* connect.                          */
static char *current_docname = NULL;	/* The document's name we are        */

					/* trying to access.                 */
static char *HTAAForwardAuth = NULL;	/* Authorization: line to forward    */

					/* (used by gateway httpds)          */
static HTAASetup *proxy_setup = NULL;	/* Same as above, but for Proxy -AJL */
static char *proxy_hostname = NULL;
static char *proxy_docname = NULL;
static int proxy_portnumber = 80;
d138 3
a140 2
void HTAAForwardAuth_set(const char *scheme_name,
			 const char *scheme_specifics)
d142 2
a143 2
    int len = 20 + (scheme_name ? strlen(scheme_name) : 0)
    + (scheme_specifics ? strlen(scheme_specifics) : 0);
d146 2
a147 2
    if ((HTAAForwardAuth = typecallocn(char, len)) == 0)
	  outofmem(__FILE__, "HTAAForwardAuth_set");
d159 1
a159 1
void HTAAForwardAuth_reset(void)
d164 1
d167 1
a167 1
static void HTAASetup_delete(HTAASetup * killme);	/* Forward */
d169 20
a188 19
/* static						HTAAServer_new()
 *		ALLOCATE A NEW NODE TO HOLD SERVER INFO
 *		AND ADD IT TO THE LIST OF SERVERS
 * ON ENTRY:
 *	hostname	is the name of the host that the server
 *			is running in.
 *	portnumber	is the portnumber which the server listens.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns		the newly-allocated node with all the strings
 *			duplicated.
 *			Strings will be automatically freed by
 *			the function HTAAServer_delete(), which also
 *			frees the node itself.
 */
static HTAAServer *HTAAServer_new(const char *hostname,
				  int portnumber,
				  BOOL IsProxy)
d192 2
a193 2
    if ((server = typecalloc(HTAAServer)) == 0)
	  outofmem(__FILE__, "HTAAServer_new");
d195 5
a199 5
    server->hostname = NULL;
    server->portnumber = (portnumber > 0 ? portnumber : 80);
    server->IsProxy = IsProxy;
    server->setups = HTList_new();
    server->realms = HTList_new();
d202 1
a202 1
	StrAllocCopy(server->hostname, hostname);
d205 1
a205 1
	server_table = HTList_new();
d207 1
a207 1
    HTList_addObject(server_table, (void *) server);
d212 14
a225 12
/* static						HTAAServer_delete()
 *
 *	DELETE THE ENTRY FOR THE SERVER FROM THE HOST TABLE,
 *	AND FREE THE MEMORY USED BY IT.
 *
 * ON ENTRY:
 *	killme		points to the HTAAServer to be freed.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAAServer_delete(HTAAServer *killme)
d236 2
a237 2
		if ((setup = (HTAASetup *) HTList_objectAt(killme->setups,
							   i)) != NULL) {
d247 1
a247 1
	while (NULL != (realm = (HTAARealm *) HTList_nextObject(cur))) {
d258 1
a258 1
	HTList_removeObject(server_table, (void *) killme);
d263 18
a280 17
/* static						HTAAServer_lookup()
 *		LOOK UP SERVER BY HOSTNAME AND PORTNUMBER
 * ON ENTRY:
 *	hostname	obvious.
 *	portnumber	if non-positive defaults to 80.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *	Looks up the server in the module-global server_table.
 *
 * ON EXIT:
 *	returns		pointer to a HTAAServer structure
 *			representing the looked-up server.
 *			NULL, if not found.
 */
static HTAAServer *HTAAServer_lookup(const char *hostname,
				     int portnumber,
				     BOOL IsProxy)
d289 3
a291 3
	while (NULL != (server = (HTAAServer *) HTList_nextObject(cur))) {
	    if (server->portnumber == portnumber &&
		0 == strcmp(server->hostname, hostname) &&
d296 1
a296 1
    return NULL;		/* NULL parameter, or not found */
d299 1
d302 27
a328 26
/* static						HTAASetup_lookup()
 *	FIGURE OUT WHICH AUTHENTICATION SETUP THE SERVER
 *	IS USING FOR A GIVEN FILE ON A GIVEN HOST AND PORT
 *
 * ON ENTRY:
 *	hostname	is the name of the server host machine.
 *	portnumber	is the port that the server is running in.
 *	docname		is the (URL-)pathname of the document we
 *			are trying to access.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *	This function goes through the information known about
 *	all the setups of the server, and finds out if the given
 *	filename resides in one of the protected directories.
 *
 * ON EXIT:
 *	returns		NULL if no match.
 *			Otherwise, a HTAASetup structure representing
 *			the protected server setup on the corresponding
 *			document tree.
 *
 */
static HTAASetup *HTAASetup_lookup(const char *hostname,
				   int portnumber,
				   const char *docname,
				   BOOL IsProxy)
d334 1
a334 1
	portnumber = 80;
d343 10
a352 10
	CTRACE((tfp, "%s %s (%s:%d:%s)\n",
		"HTAASetup_lookup: resolving setup for",
		(IsProxy ? "proxy" : "server"),
		hostname, portnumber, docname));

	while (NULL != (setup = (HTAASetup *) HTList_nextObject(cur))) {
	    if (HTAA_templateMatch(setup->ctemplate, docname)) {
		CTRACE((tfp, "%s `%s' %s `%s'\n",
			"HTAASetup_lookup:", docname,
			"matched template", setup->ctemplate));
d355 3
a357 3
		CTRACE((tfp, "%s `%s' %s `%s'\n",
			"HTAASetup_lookup:", docname,
			"did NOT match template", setup->ctemplate));
d359 7
a365 7
	}			/* while setups remain */
    }
    /* if valid parameters and server found */
    CTRACE((tfp, "%s `%s' %s\n",
	    "HTAASetup_lookup: No template matched",
	    NONNULL(docname),
	    "(so probably not protected)"));
d367 1
a367 1
    return NULL;		/* NULL in parameters, or not found */
d370 24
a393 22
/* static						HTAASetup_new()
 *			CREATE A NEW SETUP NODE
 * ON ENTRY:
 *	server		is a pointer to a HTAAServer structure
 *			to which this setup belongs.
 *	ctemplate	documents matching this template
 *			are protected according to this setup.
 *	valid_schemes	a list containing all valid authentication
 *			schemes for this setup.
 *			If NULL, all schemes are disallowed.
 *	scheme_specifics is an array of assoc lists, which
 *			contain scheme specific parameters given
 *			by server in Authenticate: fields.
 *			If NULL, all scheme specifics are
 *			set to NULL.
 * ON EXIT:
 *	returns		a new HTAASetup node, and also adds it as
 *			part of the HTAAServer given as parameter.
 */
static HTAASetup *HTAASetup_new(HTAAServer *server, char *ctemplate,
				HTList *valid_schemes,
				HTAssocList **scheme_specifics)
d397 2
a398 2
    if (!server || isEmpty(ctemplate))
	return NULL;
d400 1
a400 1
    if ((setup = typecalloc(HTAASetup)) == 0)
d405 3
a407 3
    setup->ctemplate = NULL;
    if (ctemplate)
	StrAllocCopy(setup->ctemplate, ctemplate);
d411 1
a411 1
    HTList_addObject(server->setups, (void *) setup);
d416 10
a425 9
/* static						HTAASetup_delete()
 *			FREE A HTAASetup STRUCTURE
 * ON ENTRY:
 *	killme		is a pointer to the structure to free().
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAASetup_delete(HTAASetup * killme)
d430 2
a431 2
	FREE(killme->ctemplate);
	if (killme->valid_schemes) {
a433 1
	}
d442 16
a457 14
/* static					HTAASetup_updateSpecifics()
 *		COPY SCHEME SPECIFIC PARAMETERS
 *		TO HTAASetup STRUCTURE
 * ON ENTRY:
 *	setup		destination setup structure.
 *	specifics	string array containing scheme
 *			specific parameters for each scheme.
 *			If NULL, all the scheme specific
 *			parameters are set to NULL.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAASetup_updateSpecifics(HTAASetup * setup, HTAssocList **specifics)
d473 1
d476 12
a487 11
/* static						HTAARealm_lookup()
 *		LOOKUP HTAARealm STRUCTURE BY REALM NAME
 * ON ENTRY:
 *	realm_table	a list of realm objects.
 *	realmname	is the name of realm to look for.
 *
 * ON EXIT:
 *	returns		the realm.  NULL, if not found.
 */
static HTAARealm *HTAARealm_lookup(HTList *realm_table,
				   const char *realmname)
d493 2
a494 2
	while (NULL != (realm = (HTAARealm *) HTList_nextObject(cur))) {
	    if (0 == strcmp(realm->realmname, realmname))
d498 1
a498 1
    return NULL;		/* No table, NULL param, or not found */
d501 20
a520 19
/* static						HTAARealm_new()
 *		CREATE A NODE CONTAINING USERNAME AND
 *		PASSWORD USED FOR THE GIVEN REALM.
 *		IF REALM ALREADY EXISTS, CHANGE
 *		USERNAME/PASSWORD.
 * ON ENTRY:
 *	realm_table	a list of realms to where to add
 *			the new one, too.
 *	realmname	is the name of the password domain.
 *	username	and
 *	password	are what you can expect them to be.
 *
 * ON EXIT:
 *	returns		the created realm.
 */
static HTAARealm *HTAARealm_new(HTList *realm_table,
				const char *realmname,
				const char *username,
				const char *password)
d527 2
a528 3
	if ((realm = typecalloc(HTAARealm)) == 0)
	      outofmem(__FILE__, "HTAARealm_new");

d534 1
a534 1
	    HTList_addObject(realm_table, (void *) realm);
d537 1
a537 1
	StrAllocCopy(realm->username, username);
d539 1
a539 1
	StrAllocCopy(realm->password, password);
d544 1
d547 25
a571 22
/* static						compose_auth_string()
 *
 *		COMPOSE Basic OR Pubkey AUTHENTICATION STRING;
 *		PROMPTS FOR USERNAME AND PASSWORD IF NEEDED
 *
 * ON ENTRY:
 *	scheme		is either HTAA_BASIC or HTAA_PUBKEY.
 *	setup		is the current server setup.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns		a newly composed authorization string,
 *			(with, of course, a newly generated secret
 *			key and fresh timestamp, if Pubkey-scheme
 *			is being used).
 *			NULL, if something fails.
 * NOTE:
 *	Like throughout the entire AA package, no string or structure
 *	returned by AA package needs to (or should) be freed.
 *
 */
static char *compose_auth_string(HTAAScheme scheme, HTAASetup * setup, BOOL IsProxy)
d584 3
a586 2
    const char *i_net_addr = "0.0.0.0";		/* Change... @@@@@@@@ */
    const char *timestamp = "42";	/* ... these @@@@@@@@ */
d592 1
a592 1
	!setup->server || !setup->server->realms)
d597 1
a597 1
	return NULL;
d601 1
a601 1
	  realm->username && *realm->username &&
d604 3
a606 3
	    CTRACE((tfp, "%s `%s' %s\n",
		    "compose_auth_string: realm:", realmname,
		    "not found -- creating"));
d611 8
a618 6
	 * The template should be either the '*' global for everything on the
	 * server (always true for proxy authorization setups), or a path for
	 * the start of a protected limb, with no host field, but we'll check
	 * for a host anyway in case a WWW-Protection-Template header set an
	 * absolute URL instead of a path.  If we do get a host from this, it
	 * will include the port.  - FM
d620 2
a621 2
	if ((!IsProxy) && using_proxy && setup->ctemplate) {
	    proxiedHost = HTParse(setup->ctemplate, "", PARSE_HOST);
d623 1
a623 1
		theHost = proxiedHost;
d627 3
a629 2
	 * If we didn't get a host field from the template, set up the host
	 * name and port from the setup->server elements.  - FM
d633 4
a636 4
	if (setup->server->portnumber > 0 &&
	    setup->server->portnumber != 80) {
	    HTSprintf0(&thePort, ":%d", setup->server->portnumber);
	}
d638 5
a642 4
	 * Set up the message for the username prompt, and then issue the
	 * prompt.  The default username is included in the call to the
	 * prompting function, but the password is NULL-ed and always replaced. 
	 * - FM
d645 2
a646 2
	    strlen(theHost ?
		   theHost : "??") + 50;
d648 4
a651 4
		   realm->realmname,
		   (IsProxy ? "proxy" : "server"),
		   (theHost ? theHost : "??"),
		   NonNull(thePort));
d666 1
a666 1
	     * Signals to retry.  - FM
d671 1
a671 1
	     * Signals to abort.  - FM
d678 2
a679 2
    len = strlen(NonNull(realm->username)) +
	strlen(NonNull(realm->password)) + 3;
d687 1
a687 1
	len += strlen(NonNull(secret_key)) + 30;
d692 2
a693 2
    if ((cleartext = typecallocn(char, len)) == 0)
	  outofmem(__FILE__, "compose_auth_string");
d696 1
a696 1
	strcpy(cleartext, realm->username);
d698 1
a698 1
	*cleartext = '\0';
d703 1
a703 1
	strcat(cleartext, realm->password);
d714 4
a717 4
	if (!((ciphertext = typecallocn(char, 2 * len)) &&
	        (compose_auth_stringResult = typecallocn(char, 3 * len))))
	      outofmem(__FILE__, "compose_auth_string");

d720 1
a720 1
	HTUU_encode((unsigned char *) ciphertext, strlen(ciphertext),
d725 2
a726 1
    } else {			/* scheme == HTAA_BASIC */
d728 3
a730 4
	      typecallocn(char, (4 * ((len + 2) / 3)) + 1)))
	      outofmem(__FILE__, "compose_auth_string");

	HTUU_encode((unsigned char *) cleartext, strlen(cleartext),
d737 20
a756 19
/* BROWSER static					HTAA_selectScheme()
 *		SELECT THE AUTHENTICATION SCHEME TO USE
 * ON ENTRY:
 *	setup	is the server setup structure which can
 *		be used to make the decision about the
 *		used scheme.
 *
 *	When new authentication methods are added to library
 *	this function makes the decision about which one to
 *	use at a given time.  This can be done by inspecting
 *	environment variables etc.
 *
 *	Currently only searches for the first valid scheme,
 *	and if nothing found suggests Basic scheme;
 *
 * ON EXIT:
 *	returns	the authentication scheme to use.
 */
static HTAAScheme HTAA_selectScheme(HTAASetup * setup)
d758 1
a758 1
    int scheme;
d762 2
a763 2
	    if (-1 < HTList_indexOf(setup->valid_schemes, (void *) scheme))
		return (HTAAScheme) scheme;
d769 9
a777 9
 *  Purpose:	Free off all module globals.
 *  Arguments:	void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *	To be used at program exit.
 *  Revision History:
 *	06-19-96	created - FM
 */
static void free_HTAAGlobals(void)
d779 1
a779 1
    HTAAServer *server;
d783 1
a783 1
	n = HTList_count(server_table);
d785 3
a787 3
	    if ((server = (HTAAServer *) HTList_objectAt(server_table,
							 i)) != NULL) {
		HTAAServer_delete(server);
d806 24
a829 23
 *
 *	SELECT THE AUTHENTICATION SCHEME AND
 *	COMPOSE THE ENTIRE AUTHORIZATION HEADER LINE
 *	IF WE ALREADY KNOW THAT THE HOST REQUIRES AUTHENTICATION
 *
 * ON ENTRY:
 *	hostname	is the hostname of the server.
 *	portnumber	is the portnumber in which the server runs.
 *	docname		is the pathname of the document (as in URL)
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns	NULL, if no authorization seems to be needed, or
 *		if it is the entire Authorization: line, e.g.
 *
 *		   "Authorization: Basic username:password"
 *
 *		As usual, this string is automatically freed.
 */
char *HTAA_composeAuth(const char *hostname,
		       const int portnumber,
		       const char *docname,
		       BOOL IsProxy)
d837 2
a838 2
     * Setup atexit() freeing if not done already.  - FM
     */
d841 1
a841 1
	atexit(free_HTAAGlobals);
d847 8
a854 7
     * Make gateway httpds pass authorization field as it was received.  (This
     * still doesn't really work because Authenticate:  headers from remote
     * server are not forwarded to client yet so it cannot really know that it
     * should send authorization; I will not implement it yet because I feel we
     * will soon change radically the way requests are represented to allow
     * multithreading on server-side.  Life is hard.)
     */
d856 2
a857 2
	CTRACE((tfp, "HTAA_composeAuth: %s\n",
		"Forwarding received authorization"));
d866 3
a868 3
	/*
	 * Proxy Authorization required.  - AJL
	 */
d870 2
a871 2
	CTRACE((tfp, "Composing Proxy Authorization for %s:%d/%s\n",
		hostname, portnumber, docname));
d875 1
a875 1
	    !hostname || !docname ||
d903 3
a905 3
	switch (scheme = HTAA_selectScheme(proxy_setup)) {
	case HTAA_BASIC:
	case HTAA_PUBKEY:
d908 1
a908 1
	case HTAA_KERBEROS_V4:
d910 1
a910 1
	default:
a912 1

d914 2
a915 2
			   gettext("This client doesn't know how to compose proxy authorization information for scheme"),
			   HTAAScheme_name(scheme));
d920 1
a920 1
	}			/* switch scheme */
d926 3
a928 3
	     * Signal a failure.  - FM
	     */
	    return NULL;	/* Added by marca. */
d931 2
a932 2
	     * Signal an abort.  - FM
	     */
d934 1
a934 1
	    return (HTAA_composeAuthResult);
d936 3
a938 4
	len = strlen(auth_string) + strlen(HTAAScheme_name(scheme)) + 26;
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
	      outofmem(__FILE__, "HTAA_composeAuth");

d943 4
a946 4
	 * Normal WWW authorization.
	 */
	CTRACE((tfp, "Composing Authorization for %s:%d/%s\n",
		hostname, portnumber, docname));
d950 1
a950 1
	    !hostname || !docname ||
d979 2
a980 2
	case HTAA_BASIC:
	case HTAA_PUBKEY:
d983 1
a983 1
	case HTAA_KERBEROS_V4:
d985 1
a985 1
	default:
a987 1

d989 2
a990 2
			   gettext("This client doesn't know how to compose authorization information for scheme"),
			   HTAAScheme_name(scheme));
d995 1
a995 1
	}			/* switch scheme */
d1001 3
a1003 3
	     * Signal a failure.  - FM
	     */
	    return NULL;	/* Added by marca. */
d1006 2
a1007 2
	     * Signal an abort.  - FM
	     */
d1009 1
a1009 1
	    return (HTAA_composeAuthResult);
d1012 3
a1014 4
	len = strlen(auth_string) + strlen(HTAAScheme_name(scheme)) + 20;
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
	      outofmem(__FILE__, "HTAA_composeAuth");

d1025 32
a1056 31
 *
 *		DETERMINES IF WE SHOULD RETRY THE SERVER
 *		WITH AUTHORIZATION
 *		(OR IF ALREADY RETRIED, WITH A DIFFERENT
 *		USERNAME AND/OR PASSWORD (IF MISSPELLED))
 * ON ENTRY:
 *	start_of_headers is the first block already read from socket,
 *			but status line skipped; i.e., points to the
 *			start of the header section.
 *	length		is the remaining length of the first block.
 *	soc		is the socket to read the rest of server reply.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *			This function should only be called when
 *			server has replied with a 401 (Unauthorized)
 *			status code.
 * ON EXIT:
 *	returns		YES, if connection should be retried.
 *			     The node containing all the necessary
 *			     information is
 *				* either constructed if it does not exist
 *				* or password is reset to NULL to indicate
 *				  that username and password should be
 *				  reprompted when composing Authorization:
 *				  field (in function HTAA_composeAuth()).
 *			NO, otherwise.
 */
BOOL HTAA_shouldRetryWithAuth(char *start_of_headers,
			      int length,
			      int soc,
			      BOOL IsProxy)
d1063 1
a1063 1
    char *ctemplate = NULL;
d1067 2
a1068 2
     * Setup atexit() freeing if not done already.  - FM
     */
d1071 1
a1071 1
	atexit(free_HTAAGlobals);
d1077 3
a1079 3
     * Read server reply header lines
     */
    CTRACE((tfp, "Server reply header lines:\n"));
d1082 2
a1083 2
    while (NULL != (line = HTAA_getUnfoldedLine()) && *line != '\0') {
	CTRACE((tfp, "%s\n", line));
d1093 4
a1096 4
		 0 == strcasecomp(fieldname, "Proxy-Authenticate:")) ||
		(!IsProxy &&
		 0 == strcasecomp(fieldname, "WWW-Authenticate:"))) {
		if (!(arg1 && *arg1 && args && *args)) {
d1098 4
a1101 4
			       (!isEmpty(arg1) ? " " : ""),
			       (!isEmpty(arg1) ? arg1 : ""),
			       (!isEmpty(args) ? " " : ""),
			       (!isEmpty(args) ? args : ""));
d1104 3
a1106 2
		} else if (HTAA_UNKNOWN != (scheme = HTAAScheme_enum(arg1))) {
		    HTList_addObject(valid_schemes, (void *) scheme);
d1109 2
a1110 4

			scheme_specifics =
			    typecallocn(HTAssocList *, HTAA_MAX_SCHEMES);

d1113 1
a1113 1
			for (i = 0; i < HTAA_MAX_SCHEMES; i++)
d1119 2
a1120 2
		    CTRACE((tfp, "Unknown scheme `%s' %s\n",
			    NONNULL(arg1),
d1123 1
a1123 1
			     "in WWW-Authenticate: field")));
d1128 3
a1130 3
		     0 == strcasecomp(fieldname, "WWW-Protection-Template:")) {
		CTRACE((tfp, "Protection template set to `%s'\n", arg1));
		StrAllocCopy(ctemplate, arg1);
d1133 4
a1136 3
	} else {
	    CTRACE((tfp, "Invalid header line `%s' ignored\n", line));
	}
d1139 1
a1139 1
    }				/* while header lines remain */
d1142 1
d1144 2
a1145 2
     * So should we retry with authorization?
     */
d1149 2
a1150 2
	     * No proxy authorization valid
	     */
d1154 3
a1156 3
	/*
	 * Doing it for proxy.  -AJL
	 */
d1159 7
a1165 6
	     * We have already tried with proxy authorization.  Either we don't
	     * have access or username or password was misspelled.
	     *
	     * Update scheme-specific parameters (in case they have expired by
	     * chance).
	     */
d1172 3
a1174 3
		/*
		 * Re-ask username+password (if misspelled).
		 */
d1180 5
a1184 4
	     * proxy_setup == NULL, i.e., we have a first connection to a
	     * protected server or the server serves a wider set of documents
	     * than we expected so far.
	     */
a1187 1

d1193 2
a1194 2
	    if (!ctemplate)	/* Proxy matches everything  -AJL */
		StrAllocCopy(ctemplate, "*");
d1196 4
a1199 4
					ctemplate,
					valid_schemes,
					scheme_specifics);
	    FREE(ctemplate);
d1207 2
a1208 2
     * Normal WWW authorization.
     */
d1211 2
a1212 2
	 * No authorization valid.
	 */
d1218 7
a1224 6
	 * So we have already tried with WWW authorization.  Either we don't
	 * have access or username or password was misspelled.
	 *
	 * Update scheme-specific parameters (in case they have expired by
	 * chance).
	 */
d1232 2
a1233 2
	     * Re-ask username+password (if misspelled).
	     */
d1238 6
a1243 5
	/*
	 * current_setup == NULL, i.e., we have a first connection to a
	 * protected server or the server serves a wider set of documents than
	 * we expected so far.
	 */
a1246 1

d1252 2
a1253 2
	if (!ctemplate)
	    ctemplate = HTAA_makeProtectionTemplate(current_docname);
d1255 1
a1255 1
				      ctemplate,
d1258 1
a1258 1
	FREE(ctemplate);
d1260 1
a1260 1
	HTAlert(gettext("Access without authorization denied -- retrying"));
d1267 8
a1274 8
 *  This function clears all authorization information by
 *  invoking the free_HTAAGlobals() function, which normally
 *  is invoked at exit.  It allows a browser command to do
 *  this at any time, for example, if the user is leaving
 *  the terminal for a period of time, but does not want
 *  to end the current session.  - FM
 */
void HTClearHTTPAuthInfo(void)
d1277 5
a1281 4
     * Need code to check cached documents against the protection templates,
     * and do something to ensure that any protected documents no longer can be
     * accessed without a new retrieval.  - FM
     */
d1284 3
a1286 3
     * Now free all of the authorization info, and reset the
     * free_HTAAGlobalsSet flag.  - FM
     */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a59 1
#include <HTAccess.h>		/* Are we using an HTTP gateway? */
d65 2
d78 5
a82 5
				/* on this server; i.e., valid	*/
				/* authentication schemes and	*/
				/* templates when to use them.	*/
				/* This is actually a list of	*/
				/* HTAASetup objects.		*/
d93 1
a93 1
    HTList *	valid_schemes;	/* Valid authentic.schemes		     */
d122 1
a122 1
					/* talking to			     */
d125 3
a127 3
					/* connect.			     */
PRIVATE char *current_docname	= NULL; /* The document's name we are	     */
					/* trying to access.		     */
d129 1
a129 1
					/* (used by gateway httpds)	     */
d143 1
a143 1
		 + (scheme_specifics ? strlen(scheme_specifics) : 0);
d146 1
a146 1
    if ((HTAAForwardAuth = typecallocn(char, len)) == 0)
d192 1
a192 1
    if ((server = typecalloc(HTAAServer)) == 0)
d202 1
a202 1
	StrAllocCopy(server->hostname, hostname);
d205 1
a205 1
	server_table = HTList_new();
d236 2
a237 2
		if ((setup = (HTAASetup*)HTList_objectAt(killme->setups,
							 i)) != NULL) {
d313 1
a313 1
**	This function goes through the information known about
d334 1
a334 1
	portnumber = 80;
d343 1
a343 1
	CTRACE((tfp, "%s %s (%s:%d:%s)\n",
d346 1
a346 1
		    hostname, portnumber, docname));
d350 1
a350 1
		CTRACE((tfp, "%s `%s' %s `%s'\n",
d352 1
a352 1
			    "matched template", setup->template));
d355 1
a355 1
		CTRACE((tfp, "%s `%s' %s `%s'\n",
d357 1
a357 1
			    "did NOT match template", setup->template));
d362 1
a362 1
    CTRACE((tfp, "%s `%s' %s\n",
d364 2
a365 2
		 NONNULL(docname),
		 "(so probably not protected)"));
d397 2
a398 2
    if (!server || isEmpty(template))
	return NULL;
d400 1
a400 1
    if ((setup = typecalloc(HTAASetup)) == 0)
d407 1
a407 1
	StrAllocCopy(setup->template, template);
d431 1
a431 1
	if (killme->valid_schemes) {
a433 1
	}
d476 1
a476 1
/* PRIVATE						HTAARealm_lookup()
d527 1
a527 1
	if ((realm = typecalloc(HTAARealm)) == 0)
d537 1
a537 1
	StrAllocCopy(realm->username, username);
d539 1
a539 1
	StrAllocCopy(realm->password, password);
d597 1
a597 1
	return NULL;
d601 1
a601 1
	  realm->username && *realm->username &&
d604 1
a604 1
	    CTRACE((tfp, "%s `%s' %s\n",
d606 1
a606 1
			"not found -- creating"));
d623 1
a623 1
		theHost = proxiedHost;
d633 4
a636 4
	if (setup->server->portnumber > 0 &&
	    setup->server->portnumber != 80) {
	    HTSprintf0(&thePort, ":%d", setup->server->portnumber);
	}
d646 1
a646 1
		     theHost : "??") + 50;
d651 1
a651 1
		     NonNull(thePort));
d678 2
a679 2
    len = strlen(NonNull(realm->username)) +
	  strlen(NonNull(realm->password)) + 3;
d687 1
a687 1
	len += strlen(NonNull(secret_key)) + 30;
d692 1
a692 1
    if ((cleartext = typecallocn(char, len)) == 0)
d696 1
a696 1
	strcpy(cleartext, realm->username);
d698 1
a698 1
	*cleartext = '\0';
d703 1
a703 1
	strcat(cleartext, realm->password);
d714 3
a716 2
	if (!((ciphertext = typecallocn(char, 2 * len)) &&
	      (compose_auth_stringResult = typecallocn(char, 3 * len))))
d728 1
a728 1
				typecallocn(char, (4 * ((len+2)/3)) + 1)))
d783 1
a783 1
	n = HTList_count(server_table);
d786 2
a787 2
							i)) != NULL) {
		HTAAServer_delete(server);
d841 1
a841 1
	atexit(free_HTAAGlobals);
d856 2
a857 2
	CTRACE((tfp, "HTAA_composeAuth: %s\n",
		    "Forwarding received authorization"));
d866 1
a866 1
	/*
d870 2
a871 2
	CTRACE((tfp, "Composing Proxy Authorization for %s:%d/%s\n",
		    hostname, portnumber, docname));
d873 2
a874 2
	if (proxy_portnumber  != portnumber       ||
	    !proxy_hostname   || !proxy_docname   ||
d903 1
a903 1
	switch (scheme = HTAA_selectScheme(proxy_setup)) {
d937 1
a937 1
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
d945 2
a946 2
	CTRACE((tfp, "Composing Authorization for %s:%d/%s\n",
		    hostname, portnumber, docname));
d1013 1
a1013 1
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
d1071 1
a1071 1
	atexit(free_HTAAGlobals);
d1079 1
a1079 1
    CTRACE((tfp, "Server reply header lines:\n"));
d1083 1
a1083 1
	CTRACE((tfp, "%s\n", line));
d1094 1
a1094 1
		(!IsProxy &&
d1096 1
a1096 1
		if (!(arg1 && *arg1 && args && *args)) {
d1109 2
a1110 2
			scheme_specifics =
			    typecallocn(HTAssocList *, HTAA_MAX_SCHEMES);
d1119 2
a1120 2
		    CTRACE((tfp, "Unknown scheme `%s' %s\n",
			    NONNULL(arg1),
d1123 1
a1123 1
			     "in WWW-Authenticate: field")));
d1129 1
a1129 1
		CTRACE((tfp, "Protection template set to `%s'\n", arg1));
d1135 1
a1135 1
	    CTRACE((tfp, "Invalid header line `%s' ignored\n", line));
d1154 1
a1154 1
	/*
d1172 1
a1172 1
		/*
d1238 1
a1238 1
	/*
d1260 1
a1260 1
	HTAlert(gettext("Access without authorization denied -- retrying"));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d110 4
a113 4
static void free_HTAAGlobals (void);
static BOOL free_HTAAGlobalsSet = FALSE;
static char *HTAA_composeAuthResult = NULL;
static char *compose_auth_stringResult = NULL;	/* Uuencoded presentation */
d118 3
a120 3
static HTList *server_table	= NULL;	/* Browser's info about servers	     */
static char *secret_key	= NULL;	/* Browser's latest secret key       */
static HTAASetup *current_setup= NULL;	/* The server setup we are currently */
d122 2
a123 2
static char *current_hostname	= NULL;	/* The server's name and portnumber  */
static int current_portnumber	= 80;	/* where we are currently trying to  */
d125 1
a125 1
static char *current_docname	= NULL; /* The document's name we are	     */
d127 1
a127 1
static char *HTAAForwardAuth	= NULL;	/* Authorization: line to forward    */
d129 4
a132 4
static HTAASetup *proxy_setup	= NULL;	/* Same as above, but for Proxy -AJL */
static char *proxy_hostname	= NULL;
static char *proxy_docname	= NULL;
static int proxy_portnumber	= 80;
d137 3
a139 3
void HTAAForwardAuth_set (
	const char *	scheme_name,
	const char *	scheme_specifics)
d158 1
a158 1
void HTAAForwardAuth_reset (void)
d166 1
a166 1
static void HTAASetup_delete (HTAASetup * killme);	/* Forward */
d168 1
a168 1
/* static						HTAAServer_new()
d184 4
a187 4
static HTAAServer *HTAAServer_new (
	const char*	hostname,
	int		portnumber,
	BOOL		IsProxy)
d212 1
a212 1
/* static						HTAAServer_delete()
d223 2
a224 2
static void HTAAServer_delete (
	HTAAServer *	killme)
d262 1
a262 1
/* static						HTAAServer_lookup()
d276 4
a279 4
static HTAAServer *HTAAServer_lookup (
	const char *	hostname,
	int		portnumber,
	BOOL		IsProxy)
d301 1
a301 1
/* static						HTAASetup_lookup()
d323 5
a327 5
static HTAASetup *HTAASetup_lookup (
	const char *	hostname,
	int		portnumber,
	const char *	docname,
	BOOL		IsProxy)
d369 1
a369 1
/* static						HTAASetup_new()
d388 5
a392 5
static HTAASetup *HTAASetup_new (
	HTAAServer *	server,
	char *		template,
	HTList *	valid_schemes,
	HTAssocList **	scheme_specifics)
d415 1
a415 1
/* static						HTAASetup_delete()
d423 2
a424 2
static void HTAASetup_delete (
	HTAASetup *	killme)
d442 1
a442 1
/* static					HTAASetup_updateSpecifics()
d455 3
a457 3
static void HTAASetup_updateSpecifics (
	HTAASetup *	setup,
	HTAssocList **	specifics)
d476 1
a476 1
/* static						HTAARealm_lookup()
d485 3
a487 3
static HTAARealm *HTAARealm_lookup (
	HTList *	realm_table,
	const char *	realmname)
d501 1
a501 1
/* static						HTAARealm_new()
d516 5
a520 5
static HTAARealm *HTAARealm_new (
	HTList *	realm_table,
	const char *	realmname,
	const char *	username,
	const char *	password)
d547 1
a547 1
/* static						compose_auth_string()
d568 4
a571 4
static char *compose_auth_string (
	HTAAScheme	scheme,
	HTAASetup *	setup,
	BOOL		IsProxy)
d736 1
a736 1
/* BROWSER static					HTAA_selectScheme()
d754 2
a755 2
static HTAAScheme HTAA_selectScheme (
	HTAASetup *	setup)
d776 1
a776 1
static void free_HTAAGlobals (void)
d824 5
a828 5
char *HTAA_composeAuth (
	const char *	hostname,
	const int	portnumber,
	const char *	docname,
	BOOL		IsProxy)
d1051 5
a1055 5
BOOL HTAA_shouldRetryWithAuth (
	char *		start_of_headers,
	int		length,
	int		soc,
	BOOL		IsProxy)
d1273 1
a1273 1
void HTClearHTTPAuthInfo (void)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d3 49
a51 49
 *		BROWSER SIDE ACCESS AUTHORIZATION MODULE
 *
 *	Contains the code for keeping track on server hostnames,
 *	port numbers, scheme names, usernames, passwords
 *	(and servers' public keys).
 *
 * IMPORTANT:
 *	Routines in this module use dynamic allocation, but free
 *	automatically all the memory reserved by them.
 *
 *	Therefore the caller never has to (and never should)
 *	free() any object returned by these functions.
 *
 *	Therefore also all the strings returned by this package
 *	are only valid until the next call to the same function
 *	is made.  This approach is selected, because of the nature
 *	of access authorization: no string returned by the package
 *	needs to be valid longer than until the next call.
 *
 *	This also makes it easy to plug the AA package in:
 *	you don't have to ponder whether to free() something
 *	here or is it done somewhere else (because it is always
 *	done somewhere else).
 *
 *	The strings that the package needs to store are copied
 *	so the original strings given as parameters to AA
 *	functions may be freed or modified with no side effects.
 *
 *	The AA package does not free() anything else than what
 *	it has itself allocated.
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *
 * HISTORY:
 *	Oct 17	AL	Made corrections suggested by marca:
 *			Added  if (!realm->username) return NULL;
 *			Changed some ""s to NULLs.
 *			Now doing calloc() to init uuencode source;
 *			otherwise HTUU_encode() reads uninitialized memory
 *			every now and then (not a real bug but not pretty).
 *			Corrected the formula for uuencode destination size.
 *
 * 28 Apr 1997	AJL	Do Proxy Authorisation.
 *
 * BUGS:
 *
 *
 */
d55 5
a59 5
#include <HTParse.h>		/* URL parsing function         */
#include <HTList.h>		/* HTList object                */
#include <HTAlert.h>		/* HTConfirm(), HTPrompt()      */
#include <HTAAUtil.h>		/* AA common to both sides      */
#include <HTAssoc.h>		/* Assoc list                   */
d61 2
a62 2
#include <HTAABrow.h>		/* Implemented here             */
#include <HTUU.h>		/* Uuencoding and uudecoding    */
d67 4
a70 4
 *  Local datatype definitions
 *
 *  HTAAServer contains all the information about one server.
 */
d73 10
a82 10
    char *hostname;		/* Host's name                  */
    int portnumber;		/* Port number                  */
    BOOL IsProxy;		/* Is it a proxy?               */
    HTList *setups;		/* List of protection setups 
				   on this server; i.e., valid
				   authentication schemes and
				   templates when to use them.
				   This is actually a list of
				   HTAASetup objects.           */
    HTList *realms;		/* Information about passwords  */
d86 3
a88 3
 *  HTAASetup contains information about one server's one
 *  protected tree of documents.
 */
d90 5
a94 5
    HTAAServer *server;		/* Which server serves this tree             */
    char *template;		/* Template for this tree                    */
    HTList *valid_schemes;	/* Valid authentic.schemes                   */
    HTAssocList **scheme_specifics;	/* Scheme specific params                  */
    BOOL retry;			/* Failed last time -- reprompt (or whatever) */
d98 3
a100 3
 *  Information about usernames and passwords in
 *  Basic and Pubkey authentication schemes;
 */
d102 3
a104 3
    char *realmname;		/* Password domain name         */
    char *username;		/* Username in that domain      */
    char *password;		/* Corresponding password       */
d108 3
a110 3
 *  To free off all globals. - FM
 */
static void free_HTAAGlobals(void);
d116 18
a133 21
 *  Module-wide global variables
 */
static HTList *server_table = NULL;	/* Browser's info about servers      */
static char *secret_key = NULL;	/* Browser's latest secret key       */
static HTAASetup *current_setup = NULL;		/* The server setup we are currently */

					/* talking to                        */
static char *current_hostname = NULL;	/* The server's name and portnumber  */
static int current_portnumber = 80;	/* where we are currently trying to  */

					/* connect.                          */
static char *current_docname = NULL;	/* The document's name we are        */

					/* trying to access.                 */
static char *HTAAForwardAuth = NULL;	/* Authorization: line to forward    */

					/* (used by gateway httpds)          */
static HTAASetup *proxy_setup = NULL;	/* Same as above, but for Proxy -AJL */
static char *proxy_hostname = NULL;
static char *proxy_docname = NULL;
static int proxy_portnumber = 80;
d137 3
a139 2
void HTAAForwardAuth_set(const char *scheme_name,
			 const char *scheme_specifics)
d141 2
a142 2
    int len = 20 + (scheme_name ? strlen(scheme_name) : 0)
    + (scheme_specifics ? strlen(scheme_specifics) : 0);
d146 1
a146 1
	  outofmem(__FILE__, "HTAAForwardAuth_set");
d158 1
a158 1
void HTAAForwardAuth_reset(void)
d163 1
d166 1
a166 1
static void HTAASetup_delete(HTAASetup * killme);	/* Forward */
d169 19
a187 18
 *		ALLOCATE A NEW NODE TO HOLD SERVER INFO
 *		AND ADD IT TO THE LIST OF SERVERS
 * ON ENTRY:
 *	hostname	is the name of the host that the server
 *			is running in.
 *	portnumber	is the portnumber which the server listens.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns		the newly-allocated node with all the strings
 *			duplicated.
 *			Strings will be automatically freed by
 *			the function HTAAServer_delete(), which also
 *			frees the node itself.
 */
static HTAAServer *HTAAServer_new(const char *hostname,
				  int portnumber,
				  BOOL IsProxy)
d192 1
a192 1
	  outofmem(__FILE__, "HTAAServer_new");
d194 5
a198 5
    server->hostname = NULL;
    server->portnumber = (portnumber > 0 ? portnumber : 80);
    server->IsProxy = IsProxy;
    server->setups = HTList_new();
    server->realms = HTList_new();
d206 1
a206 1
    HTList_addObject(server_table, (void *) server);
d211 1
d213 12
a224 11
 *
 *	DELETE THE ENTRY FOR THE SERVER FROM THE HOST TABLE,
 *	AND FREE THE MEMORY USED BY IT.
 *
 * ON ENTRY:
 *	killme		points to the HTAAServer to be freed.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAAServer_delete(HTAAServer *killme)
d235 2
a236 2
		if ((setup = (HTAASetup *) HTList_objectAt(killme->setups,
							   i)) != NULL) {
d246 1
a246 1
	while (NULL != (realm = (HTAARealm *) HTList_nextObject(cur))) {
d257 1
a257 1
	HTList_removeObject(server_table, (void *) killme);
d263 17
a279 16
 *		LOOK UP SERVER BY HOSTNAME AND PORTNUMBER
 * ON ENTRY:
 *	hostname	obvious.
 *	portnumber	if non-positive defaults to 80.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *	Looks up the server in the module-global server_table.
 *
 * ON EXIT:
 *	returns		pointer to a HTAAServer structure
 *			representing the looked-up server.
 *			NULL, if not found.
 */
static HTAAServer *HTAAServer_lookup(const char *hostname,
				     int portnumber,
				     BOOL IsProxy)
d288 3
a290 3
	while (NULL != (server = (HTAAServer *) HTList_nextObject(cur))) {
	    if (server->portnumber == portnumber &&
		0 == strcmp(server->hostname, hostname) &&
d295 1
a295 1
    return NULL;		/* NULL parameter, or not found */
d298 1
d302 26
a327 25
 *	FIGURE OUT WHICH AUTHENTICATION SETUP THE SERVER
 *	IS USING FOR A GIVEN FILE ON A GIVEN HOST AND PORT
 *
 * ON ENTRY:
 *	hostname	is the name of the server host machine.
 *	portnumber	is the port that the server is running in.
 *	docname		is the (URL-)pathname of the document we
 *			are trying to access.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *	This function goes through the information known about
 *	all the setups of the server, and finds out if the given
 *	filename resides in one of the protected directories.
 *
 * ON EXIT:
 *	returns		NULL if no match.
 *			Otherwise, a HTAASetup structure representing
 *			the protected server setup on the corresponding
 *			document tree.
 *
 */
static HTAASetup *HTAASetup_lookup(const char *hostname,
				   int portnumber,
				   const char *docname,
				   BOOL IsProxy)
d343 3
a345 3
		"HTAASetup_lookup: resolving setup for",
		(IsProxy ? "proxy" : "server"),
		hostname, portnumber, docname));
d347 1
a347 1
	while (NULL != (setup = (HTAASetup *) HTList_nextObject(cur))) {
d350 2
a351 2
			"HTAASetup_lookup:", docname,
			"matched template", setup->template));
d355 2
a356 2
			"HTAASetup_lookup:", docname,
			"did NOT match template", setup->template));
d358 3
a360 3
	}			/* while setups remain */
    }
    /* if valid parameters and server found */
d362 3
a364 3
	    "HTAASetup_lookup: No template matched",
	    NONNULL(docname),
	    "(so probably not protected)"));
d366 1
a366 1
    return NULL;		/* NULL in parameters, or not found */
d370 23
a392 21
 *			CREATE A NEW SETUP NODE
 * ON ENTRY:
 *	server		is a pointer to a HTAAServer structure
 *			to which this setup belongs.
 *	template	documents matching this template
 *			are protected according to this setup.
 *	valid_schemes	a list containing all valid authentication
 *			schemes for this setup.
 *			If NULL, all schemes are disallowed.
 *	scheme_specifics is an array of assoc lists, which
 *			contain scheme specific parameters given
 *			by server in Authenticate: fields.
 *			If NULL, all scheme specifics are
 *			set to NULL.
 * ON EXIT:
 *	returns		a new HTAASetup node, and also adds it as
 *			part of the HTAAServer given as parameter.
 */
static HTAASetup *HTAASetup_new(HTAAServer *server, char *template,
				HTList *valid_schemes,
				HTAssocList **scheme_specifics)
d410 1
a410 1
    HTList_addObject(server->setups, (void *) setup);
d416 9
a424 8
 *			FREE A HTAASetup STRUCTURE
 * ON ENTRY:
 *	killme		is a pointer to the structure to free().
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAASetup_delete(HTAASetup * killme)
d443 15
a457 13
 *		COPY SCHEME SPECIFIC PARAMETERS
 *		TO HTAASetup STRUCTURE
 * ON ENTRY:
 *	setup		destination setup structure.
 *	specifics	string array containing scheme
 *			specific parameters for each scheme.
 *			If NULL, all the scheme specific
 *			parameters are set to NULL.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAASetup_updateSpecifics(HTAASetup * setup, HTAssocList **specifics)
d473 1
d477 11
a487 10
 *		LOOKUP HTAARealm STRUCTURE BY REALM NAME
 * ON ENTRY:
 *	realm_table	a list of realm objects.
 *	realmname	is the name of realm to look for.
 *
 * ON EXIT:
 *	returns		the realm.  NULL, if not found.
 */
static HTAARealm *HTAARealm_lookup(HTList *realm_table,
				   const char *realmname)
d493 2
a494 2
	while (NULL != (realm = (HTAARealm *) HTList_nextObject(cur))) {
	    if (0 == strcmp(realm->realmname, realmname))
d498 1
a498 1
    return NULL;		/* No table, NULL param, or not found */
d502 19
a520 18
 *		CREATE A NODE CONTAINING USERNAME AND
 *		PASSWORD USED FOR THE GIVEN REALM.
 *		IF REALM ALREADY EXISTS, CHANGE
 *		USERNAME/PASSWORD.
 * ON ENTRY:
 *	realm_table	a list of realms to where to add
 *			the new one, too.
 *	realmname	is the name of the password domain.
 *	username	and
 *	password	are what you can expect them to be.
 *
 * ON EXIT:
 *	returns		the created realm.
 */
static HTAARealm *HTAARealm_new(HTList *realm_table,
				const char *realmname,
				const char *username,
				const char *password)
d528 1
a528 2
	      outofmem(__FILE__, "HTAARealm_new");

d534 1
a534 1
	    HTList_addObject(realm_table, (void *) realm);
d544 1
d548 24
a571 21
 *
 *		COMPOSE Basic OR Pubkey AUTHENTICATION STRING;
 *		PROMPTS FOR USERNAME AND PASSWORD IF NEEDED
 *
 * ON ENTRY:
 *	scheme		is either HTAA_BASIC or HTAA_PUBKEY.
 *	setup		is the current server setup.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns		a newly composed authorization string,
 *			(with, of course, a newly generated secret
 *			key and fresh timestamp, if Pubkey-scheme
 *			is being used).
 *			NULL, if something fails.
 * NOTE:
 *	Like throughout the entire AA package, no string or structure
 *	returned by AA package needs to (or should) be freed.
 *
 */
static char *compose_auth_string(HTAAScheme scheme, HTAASetup * setup, BOOL IsProxy)
d585 2
a586 1
    char *timestamp = "42";	/* ... these @@@@@@@@ */
d592 1
a592 1
	!setup->server || !setup->server->realms)
d605 2
a606 2
		    "compose_auth_string: realm:", realmname,
		    "not found -- creating"));
d611 8
a618 6
	 * The template should be either the '*' global for everything on the
	 * server (always true for proxy authorization setups), or a path for
	 * the start of a protected limb, with no host field, but we'll check
	 * for a host anyway in case a WWW-Protection-Template header set an
	 * absolute URL instead of a path.  If we do get a host from this, it
	 * will include the port.  - FM
d627 3
a629 2
	 * If we didn't get a host field from the template, set up the host
	 * name and port from the setup->server elements.  - FM
d638 5
a642 4
	 * Set up the message for the username prompt, and then issue the
	 * prompt.  The default username is included in the call to the
	 * prompting function, but the password is NULL-ed and always replaced. 
	 * - FM
d645 2
a646 2
	    strlen(theHost ?
		   theHost : "??") + 50;
d648 4
a651 4
		   realm->realmname,
		   (IsProxy ? "proxy" : "server"),
		   (theHost ? theHost : "??"),
		   NonNull(thePort));
d666 1
a666 1
	     * Signals to retry.  - FM
d671 1
a671 1
	     * Signals to abort.  - FM
d679 1
a679 1
	strlen(NonNull(realm->password)) + 3;
d693 1
a693 1
	  outofmem(__FILE__, "compose_auth_string");
d715 2
a716 3
	        (compose_auth_stringResult = typecallocn(char, 3 * len))))
	      outofmem(__FILE__, "compose_auth_string");

d719 1
a719 1
	HTUU_encode((unsigned char *) ciphertext, strlen(ciphertext),
d724 2
a725 1
    } else {			/* scheme == HTAA_BASIC */
d727 3
a729 4
	      typecallocn(char, (4 * ((len + 2) / 3)) + 1)))
	      outofmem(__FILE__, "compose_auth_string");

	HTUU_encode((unsigned char *) cleartext, strlen(cleartext),
d737 19
a755 18
 *		SELECT THE AUTHENTICATION SCHEME TO USE
 * ON ENTRY:
 *	setup	is the server setup structure which can
 *		be used to make the decision about the
 *		used scheme.
 *
 *	When new authentication methods are added to library
 *	this function makes the decision about which one to
 *	use at a given time.  This can be done by inspecting
 *	environment variables etc.
 *
 *	Currently only searches for the first valid scheme,
 *	and if nothing found suggests Basic scheme;
 *
 * ON EXIT:
 *	returns	the authentication scheme to use.
 */
static HTAAScheme HTAA_selectScheme(HTAASetup * setup)
d761 1
a761 1
	    if (-1 < HTList_indexOf(setup->valid_schemes, (void *) scheme))
d768 9
a776 9
 *  Purpose:	Free off all module globals.
 *  Arguments:	void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *	To be used at program exit.
 *  Revision History:
 *	06-19-96	created - FM
 */
static void free_HTAAGlobals(void)
d778 1
a778 1
    HTAAServer *server;
d784 2
a785 2
	    if ((server = (HTAAServer *) HTList_objectAt(server_table,
							 i)) != NULL) {
d805 24
a828 23
 *
 *	SELECT THE AUTHENTICATION SCHEME AND
 *	COMPOSE THE ENTIRE AUTHORIZATION HEADER LINE
 *	IF WE ALREADY KNOW THAT THE HOST REQUIRES AUTHENTICATION
 *
 * ON ENTRY:
 *	hostname	is the hostname of the server.
 *	portnumber	is the portnumber in which the server runs.
 *	docname		is the pathname of the document (as in URL)
 *	IsProxy		should be TRUE if this is a proxy.
 *
 * ON EXIT:
 *	returns	NULL, if no authorization seems to be needed, or
 *		if it is the entire Authorization: line, e.g.
 *
 *		   "Authorization: Basic username:password"
 *
 *		As usual, this string is automatically freed.
 */
char *HTAA_composeAuth(const char *hostname,
		       const int portnumber,
		       const char *docname,
		       BOOL IsProxy)
d836 2
a837 2
     * Setup atexit() freeing if not done already.  - FM
     */
d846 8
a853 7
     * Make gateway httpds pass authorization field as it was received.  (This
     * still doesn't really work because Authenticate:  headers from remote
     * server are not forwarded to client yet so it cannot really know that it
     * should send authorization; I will not implement it yet because I feel we
     * will soon change radically the way requests are represented to allow
     * multithreading on server-side.  Life is hard.)
     */
d856 1
a856 1
		"Forwarding received authorization"));
d866 2
a867 2
	 * Proxy Authorization required.  - AJL
	 */
d870 1
a870 1
		hostname, portnumber, docname));
d872 3
a874 3
	if (proxy_portnumber != portnumber ||
	    !proxy_hostname || !proxy_docname ||
	    !hostname || !docname ||
d903 2
a904 2
	case HTAA_BASIC:
	case HTAA_PUBKEY:
d907 1
a907 1
	case HTAA_KERBEROS_V4:
d909 1
a909 1
	default:
a911 1

d913 2
a914 2
			   gettext("This client doesn't know how to compose proxy authorization information for scheme"),
			   HTAAScheme_name(scheme));
d919 1
a919 1
	}			/* switch scheme */
d925 3
a927 3
	     * Signal a failure.  - FM
	     */
	    return NULL;	/* Added by marca. */
d930 2
a931 2
	     * Signal an abort.  - FM
	     */
d933 1
a933 1
	    return (HTAA_composeAuthResult);
d935 1
a935 1
	len = strlen(auth_string) + strlen((char *) HTAAScheme_name(scheme)) + 26;
d937 1
a937 2
	      outofmem(__FILE__, "HTAA_composeAuth");

d942 2
a943 2
	 * Normal WWW authorization.
	 */
d945 1
a945 1
		hostname, portnumber, docname));
d949 1
a949 1
	    !hostname || !docname ||
d978 2
a979 2
	case HTAA_BASIC:
	case HTAA_PUBKEY:
d982 1
a982 1
	case HTAA_KERBEROS_V4:
d984 1
a984 1
	default:
a986 1

d988 2
a989 2
			   gettext("This client doesn't know how to compose authorization information for scheme"),
			   HTAAScheme_name(scheme));
d994 1
a994 1
	}			/* switch scheme */
d1000 3
a1002 3
	     * Signal a failure.  - FM
	     */
	    return NULL;	/* Added by marca. */
d1005 2
a1006 2
	     * Signal an abort.  - FM
	     */
d1008 1
a1008 1
	    return (HTAA_composeAuthResult);
d1011 1
a1011 1
	len = strlen(auth_string) + strlen((char *) HTAAScheme_name(scheme)) + 20;
d1013 1
a1013 2
	      outofmem(__FILE__, "HTAA_composeAuth");

d1024 32
a1055 31
 *
 *		DETERMINES IF WE SHOULD RETRY THE SERVER
 *		WITH AUTHORIZATION
 *		(OR IF ALREADY RETRIED, WITH A DIFFERENT
 *		USERNAME AND/OR PASSWORD (IF MISSPELLED))
 * ON ENTRY:
 *	start_of_headers is the first block already read from socket,
 *			but status line skipped; i.e., points to the
 *			start of the header section.
 *	length		is the remaining length of the first block.
 *	soc		is the socket to read the rest of server reply.
 *	IsProxy		should be TRUE if this is a proxy.
 *
 *			This function should only be called when
 *			server has replied with a 401 (Unauthorized)
 *			status code.
 * ON EXIT:
 *	returns		YES, if connection should be retried.
 *			     The node containing all the necessary
 *			     information is
 *				* either constructed if it does not exist
 *				* or password is reset to NULL to indicate
 *				  that username and password should be
 *				  reprompted when composing Authorization:
 *				  field (in function HTAA_composeAuth()).
 *			NO, otherwise.
 */
BOOL HTAA_shouldRetryWithAuth(char *start_of_headers,
			      int length,
			      int soc,
			      BOOL IsProxy)
d1066 2
a1067 2
     * Setup atexit() freeing if not done already.  - FM
     */
d1076 2
a1077 2
     * Read server reply header lines
     */
d1081 1
a1081 1
    while (NULL != (line = HTAA_getUnfoldedLine()) && *line != '\0') {
d1092 1
a1092 1
		 0 == strcasecomp(fieldname, "Proxy-Authenticate:")) ||
d1094 1
a1094 1
		 0 == strcasecomp(fieldname, "WWW-Authenticate:"))) {
d1097 4
a1100 4
			       ((arg1 && *arg1) ? " " : ""),
			       ((arg1 && *arg1) ? arg1 : ""),
			       ((args && *args) ? " " : ""),
			       ((args && *args) ? args : ""));
d1103 3
a1105 2
		} else if (HTAA_UNKNOWN != (scheme = HTAAScheme_enum(arg1))) {
		    HTList_addObject(valid_schemes, (void *) scheme);
a1107 1

a1109 1

d1112 1
a1112 1
			for (i = 0; i < HTAA_MAX_SCHEMES; i++)
d1127 1
a1127 1
		     0 == strcasecomp(fieldname, "WWW-Protection-Template:")) {
d1132 2
a1133 1
	} else {
d1135 1
a1135 1
	}
d1138 1
a1138 1
    }				/* while header lines remain */
d1141 1
d1143 2
a1144 2
     * So should we retry with authorization?
     */
d1148 2
a1149 2
	     * No proxy authorization valid
	     */
d1154 2
a1155 2
	 * Doing it for proxy.  -AJL
	 */
d1158 7
a1164 6
	     * We have already tried with proxy authorization.  Either we don't
	     * have access or username or password was misspelled.
	     *
	     * Update scheme-specific parameters (in case they have expired by
	     * chance).
	     */
d1172 2
a1173 2
		 * Re-ask username+password (if misspelled).
		 */
d1179 5
a1183 4
	     * proxy_setup == NULL, i.e., we have a first connection to a
	     * protected server or the server serves a wider set of documents
	     * than we expected so far.
	     */
a1186 1

d1195 3
a1197 3
					template,
					valid_schemes,
					scheme_specifics);
d1206 2
a1207 2
     * Normal WWW authorization.
     */
d1210 2
a1211 2
	 * No authorization valid.
	 */
d1217 7
a1223 6
	 * So we have already tried with WWW authorization.  Either we don't
	 * have access or username or password was misspelled.
	 *
	 * Update scheme-specific parameters (in case they have expired by
	 * chance).
	 */
d1231 2
a1232 2
	     * Re-ask username+password (if misspelled).
	     */
d1238 5
a1242 4
	 * current_setup == NULL, i.e., we have a first connection to a
	 * protected server or the server serves a wider set of documents than
	 * we expected so far.
	 */
a1245 1

d1266 8
a1273 8
 *  This function clears all authorization information by
 *  invoking the free_HTAAGlobals() function, which normally
 *  is invoked at exit.  It allows a browser command to do
 *  this at any time, for example, if the user is leaving
 *  the terminal for a period of time, but does not want
 *  to end the current session.  - FM
 */
void HTClearHTTPAuthInfo(void)
d1276 5
a1280 4
     * Need code to check cached documents against the protection templates,
     * and do something to ensure that any protected documents no longer can be
     * accessed without a new retrieval.  - FM
     */
d1283 3
a1285 3
     * Now free all of the authorization info, and reset the
     * free_HTAAGlobalsSet flag.  - FM
     */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d78 5
a82 5
				/* on this server; i.e., valid	*/
				/* authentication schemes and	*/
				/* templates when to use them.	*/
				/* This is actually a list of	*/
				/* HTAASetup objects.		*/
d93 1
a93 1
    HTList *	valid_schemes;	/* Valid authentic.schemes		     */
d122 1
a122 1
					/* talking to			     */
d125 3
a127 3
					/* connect.			     */
PRIVATE char *current_docname	= NULL; /* The document's name we are	     */
					/* trying to access.		     */
d129 1
a129 1
					/* (used by gateway httpds)	     */
d143 1
a143 1
		 + (scheme_specifics ? strlen(scheme_specifics) : 0);
d146 1
a146 1
    if ((HTAAForwardAuth = typecallocn(char, len)) == 0)
d192 1
a192 1
    if ((server = typecalloc(HTAAServer)) == 0)
d202 1
a202 1
	StrAllocCopy(server->hostname, hostname);
d205 1
a205 1
	server_table = HTList_new();
d236 2
a237 2
		if ((setup = (HTAASetup*)HTList_objectAt(killme->setups,
							 i)) != NULL) {
d313 1
a313 1
**	This function goes through the information known about
d334 1
a334 1
	portnumber = 80;
d343 1
a343 1
	CTRACE((tfp, "%s %s (%s:%d:%s)\n",
d346 1
a346 1
		    hostname, portnumber, docname));
d350 1
a350 1
		CTRACE((tfp, "%s `%s' %s `%s'\n",
d352 1
a352 1
			    "matched template", setup->template));
d355 1
a355 1
		CTRACE((tfp, "%s `%s' %s `%s'\n",
d357 1
a357 1
			    "did NOT match template", setup->template));
d362 1
a362 1
    CTRACE((tfp, "%s `%s' %s\n",
d364 2
a365 2
		 NONNULL(docname),
		 "(so probably not protected)"));
d398 1
a398 1
	return NULL;
d400 1
a400 1
    if ((setup = typecalloc(HTAASetup)) == 0)
d407 1
a407 1
	StrAllocCopy(setup->template, template);
d431 1
a431 1
	if (killme->valid_schemes) {
a433 1
	}
d476 1
a476 1
/* PRIVATE						HTAARealm_lookup()
d527 1
a527 1
	if ((realm = typecalloc(HTAARealm)) == 0)
d537 1
a537 1
	StrAllocCopy(realm->username, username);
d539 1
a539 1
	StrAllocCopy(realm->password, password);
d597 1
a597 1
	return NULL;
d601 1
a601 1
	  realm->username && *realm->username &&
d604 1
a604 1
	    CTRACE((tfp, "%s `%s' %s\n",
d606 1
a606 1
			"not found -- creating"));
d623 1
a623 1
		theHost = proxiedHost;
d633 4
a636 4
	if (setup->server->portnumber > 0 &&
	    setup->server->portnumber != 80) {
	    HTSprintf0(&thePort, ":%d", setup->server->portnumber);
	}
d646 1
a646 1
		     theHost : "??") + 50;
d692 1
a692 1
    if ((cleartext = typecallocn(char, len)) == 0)
d696 1
a696 1
	strcpy(cleartext, realm->username);
d698 1
a698 1
	*cleartext = '\0';
d703 1
a703 1
	strcat(cleartext, realm->password);
d714 3
a716 2
	if (!((ciphertext = typecallocn(char, 2 * len)) &&
	      (compose_auth_stringResult = typecallocn(char, 3 * len))))
d728 1
a728 1
				typecallocn(char, (4 * ((len+2)/3)) + 1)))
d783 1
a783 1
	n = HTList_count(server_table);
d786 2
a787 2
							i)) != NULL) {
		HTAAServer_delete(server);
d841 1
a841 1
	atexit(free_HTAAGlobals);
d856 2
a857 2
	CTRACE((tfp, "HTAA_composeAuth: %s\n",
		    "Forwarding received authorization"));
d866 1
a866 1
	/*
d870 2
a871 2
	CTRACE((tfp, "Composing Proxy Authorization for %s:%d/%s\n",
		    hostname, portnumber, docname));
d873 2
a874 2
	if (proxy_portnumber  != portnumber       ||
	    !proxy_hostname   || !proxy_docname   ||
d903 1
a903 1
	switch (scheme = HTAA_selectScheme(proxy_setup)) {
d937 1
a937 1
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
d945 2
a946 2
	CTRACE((tfp, "Composing Authorization for %s:%d/%s\n",
		    hostname, portnumber, docname));
d1013 1
a1013 1
	if ((HTAA_composeAuthResult = typecallocn(char, len)) == 0)
d1071 1
a1071 1
	atexit(free_HTAAGlobals);
d1079 1
a1079 1
    CTRACE((tfp, "Server reply header lines:\n"));
d1083 1
a1083 1
	CTRACE((tfp, "%s\n", line));
d1094 1
a1094 1
		(!IsProxy &&
d1096 1
a1096 1
		if (!(arg1 && *arg1 && args && *args)) {
d1109 2
a1110 2
			scheme_specifics =
			    typecallocn(HTAssocList *, HTAA_MAX_SCHEMES);
d1119 2
a1120 2
		    CTRACE((tfp, "Unknown scheme `%s' %s\n",
			    NONNULL(arg1),
d1123 1
a1123 1
			     "in WWW-Authenticate: field")));
d1129 1
a1129 1
		CTRACE((tfp, "Protection template set to `%s'\n", arg1));
d1135 1
a1135 1
	    CTRACE((tfp, "Invalid header line `%s' ignored\n", line));
d1154 1
a1154 1
	/*
d1172 1
a1172 1
		/*
d1238 1
a1238 1
	/*
d1260 1
a1260 1
	HTAlert(gettext("Access without authorization denied -- retrying"));
@

