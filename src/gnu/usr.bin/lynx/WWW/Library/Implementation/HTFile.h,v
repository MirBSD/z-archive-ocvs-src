head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.10.26.19;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.32;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.26;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.42;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.55;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.19;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.49;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.24;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.11;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.46.46;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.32;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@/*							File access in libwww
 *				FILE ACCESS
 *
 *  These are routines for local file access used by WWW browsers and servers.
 *  Implemented by HTFile.c.
 *
 *  If the file is not a local file, then we pass it on to HTFTP in case it
 *  can be reached by FTP.
 */
#ifndef HTFILE_H
#define HTFILE_H

#include <HTFormat.h>
#include <HTAccess.h>

#ifndef HTML_H
#include <HTML.h>		/* SCW */
#endif /* HTML_H */

#ifdef __cplusplus
extern "C" {
#endif
/*
 *  Controlling globals
 *
 *  These flags control how directories and files are represented as
 *  hypertext, and are typically set by the application from command
 *  line options, etc.
				 */ extern int HTDirAccess;
    /* Directory access level */

#define HT_DIR_FORBID           0	/* Altogether forbidden */
#define HT_DIR_SELECTIVE        1	/* If HT_DIR_ENABLE_FILE exists */
#define HT_DIR_OK               2	/* Any accesible directory */

#define HT_DIR_ENABLE_FILE      ".www_browsable"	/* If exists, can browse */

    extern int HTDirReadme;	/* Include readme files in listing? */

    /* Values: */
#define HT_DIR_README_NONE      0	/* No */
#define HT_DIR_README_TOP       1	/* Yes, first */
#define HT_DIR_README_BOTTOM    2	/* Yes, at the end */

#define HT_DIR_README_FILE              "README"

/*
 *  Convert filenames between local and WWW formats
 */
    extern char *HTURLPath_toFile(const char *name, BOOL expand_all, BOOL is_remote);
    extern char *HTnameOfFile_WWW(const char *name, BOOL WWW_prefix, BOOL expand_all);

#define HTLocalName(name)      HTnameOfFile_WWW(name,TRUE,TRUE)
#define HTfullURL_toFile(name) HTnameOfFile_WWW(name,FALSE,TRUE)
#define HTpartURL_toFile(name) HTnameOfFile_WWW(name,FALSE,FALSE)

/*
 *  Make a WWW name from a full local path name
 */
    extern char *WWW_nameOfFile(const char *name);

/*
 *  Generate the name of a cache file
 */
    extern char *HTCacheFileName(const char *name);

/*
 *  Output directory titles
 *
 * This is (like the next one) used by HTFTP. It is common code to generate
 * the title and heading 1 and the parent directory link for any anchor.
 *
 * changed to return TRUE if parent directory link was generated,
 * FALSE otherwise - KW
 */
    extern BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
			    BOOL tildeIsTop);

/*
 *	Check existence.
 */
    extern int HTStat(const char *filename,
		      struct stat *data);

/*	Load a document.
 *	----------------
 */
    extern int HTLoadFile(const char *addr,
			  HTParentAnchor *anchor,
			  HTFormat format_out,
			  HTStream *sink);

/*
 *  Output a directory entry
 *
 * This is used by HTFTP.c for example -- it is a common routine for
 *  generating a linked directory entry.
 */
    extern void HTDirEntry(HTStructured * target, /* in which to put the linked text */ const char *tail,	/* last part of directory name */
			   const char *entry);	/* name of this entry */

/*
 *  HTSetSuffix: Define the representation for a file suffix
 *
 *  This defines a mapping between local file suffixes and file content
 *  types and encodings.
 *
 *  ON ENTRY,
 *
 *  suffix		includes the "." if that is important (normally, yes!)
 *
 *  representation	is MIME-style content-type
 *
 *  encoding		is MIME-style content-transfer-encoding
 *			(8bit, 7bit, etc) or HTTP-style content-encoding
 *			(gzip, compress etc.)
 *
 *  quality		an a priori judgement of the quality of such files
 *			(0.0..1.0)
 *
 *  HTSetSuffix5 has one more parameter for a short description of the type
 *  which is otherwise derived from the representation:
 *
 *  desc		is a short textual description, or NULL
 *
 *  Examples:   HTSetSuffix(".ps", "application/postscript", "8bit", 1.0);
 *  Examples:   HTSetSuffix(".psz", "application/postscript", "gzip", 1.0);
 *  A MIME type could also indicate a non-trivial encoding on its own
 *  ("application/x-compressed-tar"), but in that case don't use enconding
 *  to also indicate it but use "binary" etc.
 */
    extern void HTSetSuffix5(const char *suffix,
			     const char *representation,
			     const char *encoding,
			     const char *desc,
			     double quality);

#define HTSetSuffix(suff,rep,enc,q) HTSetSuffix5(suff, rep, enc, NULL, q)

/*
 *  HTFileFormat: Get Representation and Encoding from file name.
 *
 *  ON EXIT,
 *
 *  return		The represntation it imagines the file is in.
 *
 *  *pEncoding		The encoding (binary, 7bit, etc). See HTSetSuffix.
 */
    extern HTFormat HTFileFormat(const char *filename,
				 HTAtom **pEncoding,
				 const char **pDesc);

/*
 *  HTCharsetFormat: Revise the file format in relation to the Lynx charset.
 *
 *  This checks the format associated with an anchor for
 *  for an extended MIME Content-Type, and if a charset is
 *  indicated, sets Lynx up for proper handling in relation
 *  to the currently selected character set. - FM
 */
    extern HTFormat HTCharsetFormat(HTFormat format,
				    HTParentAnchor *anchor,
				    int default_LYhndl);

/*	Get various pieces of meta info from file name.
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
    extern void LYGetFileInfo(const char *filename,
			      HTParentAnchor **pfile_anchor,
			      HTFormat *pformat,
			      HTAtom **pencoding,
			      const char **pdesc,
			      const char **pcharset,
			      int *pfile_cs);

/*
 *  Determine file value from file name.
 */
    extern float HTFileValue(const char *filename);

/*
 *  Known compression types.
 */
    typedef enum {
	cftNone
	,cftCompress
	,cftGzip
	,cftBzip2
	,cftDeflate
    } CompressFileType;

/*
 *  Determine compression type from file name, by looking at its suffix.
 */
    extern CompressFileType HTCompressFileType(const char *filename,
					       const char *dots,
					       int *rootlen);

/*
 *  Determine compression type from the content-type.
 */
    extern CompressFileType HTContentToCompressType(const char *encoding);

/*
 *  Determine compression type from the content-encoding.
 */
    extern CompressFileType HTEncodingToCompressType(const char *encoding);

/*
 *  Determine write access to a file.
 *
 *  ON EXIT,
 *
 *  return value	YES if file can be accessed and can be written to.
 *
 *  BUGS
 *
 *   Isn't there a quicker way?
 */

#if defined(HAVE_CONFIG_H)

#ifndef HAVE_GETGROUPS
#define NO_GROUPS
#endif

#else

#ifdef VMS
#define NO_GROUPS
#endif				/* VMS */
#ifdef NO_UNIX_IO
#define NO_GROUPS
#endif				/* NO_UNIX_IO */
#ifdef PCNFS
#define NO_GROUPS
#endif				/* PCNFS */
#ifdef NOUSERS
#define NO_GROUPS
#endif				/* PCNFS */

#endif				/* HAVE_CONFIG_H */

    extern BOOL HTEditable(const char *filename);

/*	Make a save stream.
 *	-------------------
 */
    extern HTStream *HTFileSaveStream(HTParentAnchor *anchor);

/*
 * Determine a suitable suffix, given the representation.
 *
 *  ON ENTRY,
 *
 *  rep			is the atomized MIME style representation
 *  enc			is an encoding (8bit, binary, gzip, compress,..)
 *
 *  ON EXIT,
 *
 *  returns		a pointer to a suitable suffix string if one has
 *			been found, else NULL.
 */
    extern const char *HTFileSuffix(HTAtom *rep,
				    const char *enc);

/*
 * Enumerate external programs that lynx may assume exists.  Unlike those
 * given in download scripts, etc., lynx would really like to know their
 * absolute paths, for better security.
 */
    typedef enum {
	ppUnknown = 0
	,ppBZIP2
	,ppCHMOD
	,ppCOMPRESS
	,ppCOPY
	,ppCSWING
	,ppGZIP
	,ppINFLATE
	,ppINSTALL
	,ppMKDIR
	,ppMV
	,ppRLOGIN
	,ppRM
	,ppRMDIR
	,ppTAR
	,ppTELNET
	,ppTN3270
	,ppTOUCH
	,ppUNCOMPRESS
	,ppUNZIP
	,ppUUDECODE
	,ppZCAT
	,ppZIP
	,pp_Last
    } ProgramPaths;

/*
 * Given a program number, return its path
 */
    extern const char *HTGetProgramPath(ProgramPaths code);

/*
 * Store a program's path 
 */
    extern void HTSetProgramPath(ProgramPaths code,
				 const char *path);

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
    extern void HTInitProgramPaths(void);

/*
 *  The Protocols
 */
#ifdef GLOBALREF_IS_MACRO
    extern GLOBALREF (HTProtocol, HTFTP);
    extern GLOBALREF (HTProtocol, HTFile);

#else
    GLOBALREF HTProtocol HTFTP, HTFile;
#endif				/* GLOBALREF_IS_MACRO */

#ifdef __cplusplus
}
#endif
#endif				/* HTFILE_H */
@


1.7
log
@automatic merge
@
text
@d15 1
d20 3
d29 2
a30 2
 */
extern int HTDirAccess;		/* Directory access level */
d38 1
a38 1
extern int HTDirReadme;		/* Include readme files in listing? */
d40 1
a40 1
					/* Values: */
d50 2
a51 2
extern char *HTURLPath_toFile(const char *name, BOOL expand_all, BOOL is_remote);
extern char *HTnameOfFile_WWW(const char *name, BOOL WWW_prefix, BOOL expand_all);
d60 1
a60 1
extern char *WWW_nameOfFile(const char *name);
d65 1
a65 1
extern char *HTCacheFileName(const char *name);
d76 2
a77 2
extern BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
			BOOL tildeIsTop);
d82 2
a83 2
extern int HTStat(const char *filename,
		  struct stat *data);
d88 4
a91 4
extern int HTLoadFile(const char *addr,
		      HTParentAnchor *anchor,
		      HTFormat format_out,
		      HTStream *sink);
d99 2
a100 2
extern void HTDirEntry(HTStructured * target, /* in which to put the linked text */ const char *tail,	/* last part of directory name */
		       const char *entry);	/* name of this entry */
d132 5
a136 5
extern void HTSetSuffix5(const char *suffix,
			 const char *representation,
			 const char *encoding,
			 const char *desc,
			 double quality);
d149 3
a151 3
extern HTFormat HTFileFormat(const char *filename,
			     HTAtom **pEncoding,
			     const char **pDesc);
d161 3
a163 3
extern HTFormat HTCharsetFormat(HTFormat format,
				HTParentAnchor *anchor,
				int default_LYhndl);
d185 7
a191 7
extern void LYGetFileInfo(const char *filename,
			  HTParentAnchor **pfile_anchor,
			  HTFormat *pformat,
			  HTAtom **pencoding,
			  const char **pdesc,
			  const char **pcharset,
			  int *pfile_cs);
d196 1
a196 1
extern float HTFileValue(const char *filename);
d201 7
a207 7
typedef enum {
    cftNone
    ,cftCompress
    ,cftGzip
    ,cftBzip2
    ,cftDeflate
} CompressFileType;
d212 3
a214 3
extern CompressFileType HTCompressFileType(char *filename,
					   char *dots,
					   char **suffix);
d219 1
a219 1
extern CompressFileType HTContentToCompressType(const char *encoding);
d224 1
a224 1
extern CompressFileType HTEncodingToCompressType(const char *encoding);
d248 1
a248 1
#endif /* VMS */
d251 1
a251 1
#endif /* NO_UNIX_IO */
d254 1
a254 1
#endif /* PCNFS */
d257 1
a257 1
#endif /* PCNFS */
d259 1
a259 1
#endif /* HAVE_CONFIG_H */
d261 1
a261 1
extern BOOL HTEditable(const char *filename);
d266 1
a266 1
extern HTStream *HTFileSaveStream(HTParentAnchor *anchor);
d281 2
a282 2
extern const char *HTFileSuffix(HTAtom *rep,
				const char *enc);
d289 26
a314 26
typedef enum {
    ppUnknown = 0
    ,ppBZIP2
    ,ppCHMOD
    ,ppCOMPRESS
    ,ppCOPY
    ,ppCSWING
    ,ppGZIP
    ,ppINFLATE
    ,ppINSTALL
    ,ppMKDIR
    ,ppMV
    ,ppRLOGIN
    ,ppRM
    ,ppRMDIR
    ,ppTAR
    ,ppTELNET
    ,ppTN3270
    ,ppTOUCH
    ,ppUNCOMPRESS
    ,ppUNZIP
    ,ppUUDECODE
    ,ppZCAT
    ,ppZIP
    ,pp_Last
} ProgramPaths;
d319 1
a319 1
extern const char *HTGetProgramPath(ProgramPaths code);
d324 2
a325 2
extern void HTSetProgramPath(ProgramPaths code,
			     const char *path);
d330 1
a330 1
extern void HTInitProgramPaths(void);
d336 2
a337 2
extern GLOBALREF (HTProtocol, HTFTP);
extern GLOBALREF (HTProtocol, HTFile);
d340 2
a341 2
GLOBALREF HTProtocol HTFTP, HTFile;
#endif /* GLOBALREF_IS_MACRO */
d343 4
a346 1
#endif /* HTFILE_H */
@


1.6
log
@automatic merge of lynx-current
@
text
@d195 1
a195 1
 *  Determine compression type from file name, by looking at its suffix.
d202 1
d205 3
d213 10
d293 1
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 8
a9 8
**				FILE ACCESS
**
**  These are routines for local file access used by WWW browsers and servers.
**  Implemented by HTFile.c.
**
**  If the file is not a local file, then we pass it on to HTFTP in case it
**  can be reached by FTP.
*/
d16 1
a16 1
#include <HTML.h>               /* SCW */
d20 20
a39 19
**  Controlling globals
**
**  These flags control how directories and files are represented as
**  hypertext, and are typically set by the application from command
**  line options, etc.
*/
extern int HTDirAccess;         /* Directory access level */

#define HT_DIR_FORBID           0       /* Altogether forbidden */
#define HT_DIR_SELECTIVE        1       /* If HT_DIR_ENABLE_FILE exists */
#define HT_DIR_OK               2       /* Any accesible directory */

#define HT_DIR_ENABLE_FILE      ".www_browsable" /* If exists, can browse */

extern int HTDirReadme;         /* Include readme files in listing? */
                                        /* Values: */
#define HT_DIR_README_NONE      0       /* No */
#define HT_DIR_README_TOP       1       /* Yes, first */
#define HT_DIR_README_BOTTOM    2       /* Yes, at the end */
d44 5
a48 4
**  Convert filenames between local and WWW formats
*/
extern char * HTURLPath_toFile (const char * name, BOOL expand_all, BOOL is_remote);
extern char * HTnameOfFile_WWW (const char * name, BOOL WWW_prefix, BOOL expand_all);
d54 26
a79 29
**  Make a WWW name from a full local path name
*/
extern char * WWW_nameOfFile (const char * name);

/*
**  Generate the name of a cache file
*/
extern char * HTCacheFileName (const char * name);

/*
**  Output directory titles
**
** This is (like the next one) used by HTFTP. It is common code to generate
** the title and heading 1 and the parent directory link for any anchor.
**
** changed to return TRUE if parent directory link was generated,
** FALSE otherwise - KW
*/
extern BOOL HTDirTitles (
        HTStructured *  target,
        HTParentAnchor* anchor,
	BOOL		tildeIsTop);

/*
**	Check existence.
*/
extern int HTStat (
	const char *	filename,
	struct stat *	data);
d82 51
a132 55
**	----------------
*/
extern int HTLoadFile (
	const char *		addr,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink);

/*
**  Output a directory entry
**
** This is used by HTFTP.c for example -- it is a common routine for
**  generating a linked directory entry.
*/
extern void HTDirEntry (
        HTStructured *  target,         /* in which to put the linked text */
        const char *    tail,           /* last part of directory name */
        const char *    entry);        /* name of this entry */

/*
**  HTSetSuffix: Define the representation for a file suffix
**
**  This defines a mapping between local file suffixes and file content
**  types and encodings.
**
**  ON ENTRY,
**
**  suffix		includes the "." if that is important (normally, yes!)
**
**  representation	is MIME-style content-type
**
**  encoding		is MIME-style content-transfer-encoding
**			(8bit, 7bit, etc) or HTTP-style content-encoding
**			(gzip, compress etc.)
**
**  quality		an a priori judgement of the quality of such files
**			(0.0..1.0)
**
**  HTSetSuffix5 has one more parameter for a short description of the type
**  which is otherwise derived from the representation:
**
**  desc		is a short textual description, or NULL
**
**  Examples:   HTSetSuffix(".ps", "application/postscript", "8bit", 1.0);
**  Examples:   HTSetSuffix(".psz", "application/postscript", "gzip", 1.0);
**  A MIME type could also indicate a non-trivial encoding on its own
**  ("application/x-compressed-tar"), but in that case don't use enconding
**  to also indicate it but use "binary" etc.
*/
extern void HTSetSuffix5 (
        const char *    suffix,
        const char *    representation,
        const char *    encoding,
        const char *    desc,
        double          quality);
d137 23
a159 25
**  HTFileFormat: Get Representation and Encoding from file name.
**
**  ON EXIT,
**
**  return		The represntation it imagines the file is in.
**
**  *pEncoding		The encoding (binary, 7bit, etc). See HTSetSuffix.
*/
extern HTFormat HTFileFormat (
	const char *		filename,
	HTAtom **		pEncoding,
	const char **		pDesc);

/*
**  HTCharsetFormat: Revise the file format in relation to the Lynx charset.
**
**  This checks the format associated with an anchor for
**  for an extended MIME Content-Type, and if a charset is
**  indicated, sets Lynx up for proper handling in relation
**  to the currently selected character set. - FM
*/
extern HTFormat HTCharsetFormat (
	HTFormat		format,
	HTParentAnchor *	anchor,
	int			default_LYhndl);
d162 31
a192 33
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
extern void LYGetFileInfo (
	const char *		filename,
	HTParentAnchor **	pfile_anchor,
	HTFormat *		pformat,
	HTAtom **		pencoding,
	const char**		pdesc,
	const char**		pcharset,
	int *			pfile_cs);

/*
**  Determine file value from file name.
*/
extern float HTFileValue (
	const char *	filename);
d195 2
a196 2
**  Determine compression type from file name, by looking at its suffix.
*/
d199 3
a201 3
    , cftCompress
    , cftGzip
    , cftBzip2
d204 15
a218 16
extern CompressFileType HTCompressFileType (
	char *			filename,
	char *			dots,
	char **			suffix);

/*
**  Determine write access to a file.
**
**  ON EXIT,
**
**  return value	YES if file can be accessed and can be written to.
**
**  BUGS
**
**   Isn't there a quicker way?
*/
d243 1
a243 1
extern BOOL HTEditable (const char * filename);
d246 19
a264 21
**	-------------------
*/
extern HTStream * HTFileSaveStream (
	HTParentAnchor *	anchor);

/*
** Determine a suitable suffix, given the representation.
**
**  ON ENTRY,
**
**  rep			is the atomized MIME style representation
**  enc			is an encoding (8bit, binary, gzip, compress,..)
**
**  ON EXIT,
**
**  returns		a pointer to a suitable suffix string if one has
**			been found, else NULL.
*/
extern const char * HTFileSuffix (
                HTAtom* rep,
                const char* enc);
d300 1
a300 2
extern const char * HTGetProgramPath (
		ProgramPaths code);
d305 2
a306 3
extern void HTSetProgramPath (
		ProgramPaths code,
		const char *path);
d311 1
a311 1
extern void HTInitProgramPaths (void);
d314 2
a315 2
**  The Protocols
*/
d317 3
a319 2
extern GLOBALREF (HTProtocol,HTFTP);
extern GLOBALREF (HTProtocol,HTFile);
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d45 2
a46 2
extern char * HTURLPath_toFile PARAMS((CONST char * name, BOOL expand_all, BOOL is_remote));
extern char * HTnameOfFile_WWW PARAMS((CONST char * name, BOOL WWW_prefix, BOOL expand_all));
d54 1
a54 1
extern char * WWW_nameOfFile PARAMS((CONST char * name));
d59 1
a59 1
extern char * HTCacheFileName PARAMS((CONST char * name));
d70 1
a70 1
extern BOOL HTDirTitles PARAMS((
d73 1
a73 1
	BOOL		tildeIsTop));
d78 3
a80 3
extern int HTStat PARAMS((
	CONST char *	filename,
	struct stat *	data));
d85 2
a86 2
extern int HTLoadFile PARAMS((
	CONST char *		addr,
d89 1
a89 1
	HTStream *		sink));
d97 1
a97 1
extern void HTDirEntry PARAMS((
d99 2
a100 2
        CONST char *    tail,           /* last part of directory name */
        CONST char *    entry));        /* name of this entry */
d132 6
a137 6
extern void HTSetSuffix5 PARAMS((
        CONST char *    suffix,
        CONST char *    representation,
        CONST char *    encoding,
        CONST char *    desc,
        double          quality));
d150 2
a151 2
extern HTFormat HTFileFormat PARAMS((
	CONST char *		filename,
d153 1
a153 1
	CONST char **		pDesc));
d163 1
a163 1
extern HTFormat HTCharsetFormat PARAMS((
d166 1
a166 1
	int			default_LYhndl));
d188 2
a189 2
extern void LYGetFileInfo PARAMS((
	CONST char *		filename,
d193 3
a195 3
	CONST char**		pdesc,
	CONST char**		pcharset,
	int *			pfile_cs));
d200 2
a201 2
extern float HTFileValue PARAMS((
	CONST char *	filename));
d213 1
a213 1
extern CompressFileType HTCompressFileType PARAMS((
d216 1
a216 1
	char **			suffix));
d253 1
a253 1
extern BOOL HTEditable PARAMS((CONST char * filename));
d258 2
a259 2
extern HTStream * HTFileSaveStream PARAMS((
	HTParentAnchor *	anchor));
d274 1
a274 1
extern CONST char * HTFileSuffix PARAMS((
d276 1
a276 1
                CONST char* enc));
d312 2
a313 2
extern CONST char * HTGetProgramPath PARAMS((
		ProgramPaths code));
d318 1
a318 1
extern void HTSetProgramPath PARAMS((
d320 1
a320 1
		CONST char *path));
d325 1
a325 1
extern void HTInitProgramPaths NOPARAMS;
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d296 1
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d45 1
d72 1
a72 1
        HTAnchor *      anchor,
d75 7
d137 1
a137 1
        float           quality));
d168 29
d204 15
d229 24
d279 48
d335 1
a336 2

/* end of HTFile */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 8
a9 8
 *				FILE ACCESS
 *
 *  These are routines for local file access used by WWW browsers and servers.
 *  Implemented by HTFile.c.
 *
 *  If the file is not a local file, then we pass it on to HTFTP in case it
 *  can be reached by FTP.
 */
a14 1

d16 1
a16 1
#include <HTML.h>		/* SCW */
d19 20
a38 24
#ifdef __cplusplus
extern "C" {
#endif
/*
 *  Controlling globals
 *
 *  These flags control how directories and files are represented as
 *  hypertext, and are typically set by the application from command
 *  line options, etc.
				 */ extern int HTDirAccess;
    /* Directory access level */

#define HT_DIR_FORBID           0	/* Altogether forbidden */
#define HT_DIR_SELECTIVE        1	/* If HT_DIR_ENABLE_FILE exists */
#define HT_DIR_OK               2	/* Any accesible directory */

#define HT_DIR_ENABLE_FILE      ".www_browsable"	/* If exists, can browse */

    extern int HTDirReadme;	/* Include readme files in listing? */

    /* Values: */
#define HT_DIR_README_NONE      0	/* No */
#define HT_DIR_README_TOP       1	/* Yes, first */
#define HT_DIR_README_BOTTOM    2	/* Yes, at the end */
d43 3
a45 5
 *  Convert filenames between local and WWW formats
 */
    extern char *HTURLPath_toFile(const char *name, BOOL expand_all, BOOL is_remote);
    extern char *HTnameOfFile_WWW(const char *name, BOOL WWW_prefix, BOOL expand_all);

d51 22
a72 26
 *  Make a WWW name from a full local path name
 */
    extern char *WWW_nameOfFile(const char *name);

/*
 *  Generate the name of a cache file
 */
    extern char *HTCacheFileName(const char *name);

/*
 *  Output directory titles
 *
 * This is (like the next one) used by HTFTP. It is common code to generate
 * the title and heading 1 and the parent directory link for any anchor.
 *
 * changed to return TRUE if parent directory link was generated,
 * FALSE otherwise - KW
 */
    extern BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
			    BOOL tildeIsTop);

/*
 *	Check existence.
 */
    extern int HTStat(const char *filename,
		      struct stat *data);
d75 55
a129 51
 *	----------------
 */
    extern int HTLoadFile(const char *addr,
			  HTParentAnchor *anchor,
			  HTFormat format_out,
			  HTStream *sink);

/*
 *  Output a directory entry
 *
 * This is used by HTFTP.c for example -- it is a common routine for
 *  generating a linked directory entry.
 */
    extern void HTDirEntry(HTStructured * target, /* in which to put the linked text */ const char *tail,	/* last part of directory name */
			   const char *entry);	/* name of this entry */

/*
 *  HTSetSuffix: Define the representation for a file suffix
 *
 *  This defines a mapping between local file suffixes and file content
 *  types and encodings.
 *
 *  ON ENTRY,
 *
 *  suffix		includes the "." if that is important (normally, yes!)
 *
 *  representation	is MIME-style content-type
 *
 *  encoding		is MIME-style content-transfer-encoding
 *			(8bit, 7bit, etc) or HTTP-style content-encoding
 *			(gzip, compress etc.)
 *
 *  quality		an a priori judgement of the quality of such files
 *			(0.0..1.0)
 *
 *  HTSetSuffix5 has one more parameter for a short description of the type
 *  which is otherwise derived from the representation:
 *
 *  desc		is a short textual description, or NULL
 *
 *  Examples:   HTSetSuffix(".ps", "application/postscript", "8bit", 1.0);
 *  Examples:   HTSetSuffix(".psz", "application/postscript", "gzip", 1.0);
 *  A MIME type could also indicate a non-trivial encoding on its own
 *  ("application/x-compressed-tar"), but in that case don't use enconding
 *  to also indicate it but use "binary" etc.
 */
    extern void HTSetSuffix5(const char *suffix,
			     const char *representation,
			     const char *encoding,
			     const char *desc,
			     double quality);
d134 44
a177 121
 *  HTFileFormat: Get Representation and Encoding from file name.
 *
 *  ON EXIT,
 *
 *  return		The represntation it imagines the file is in.
 *
 *  *pEncoding		The encoding (binary, 7bit, etc). See HTSetSuffix.
 */
    extern HTFormat HTFileFormat(const char *filename,
				 HTAtom **pEncoding,
				 const char **pDesc);

/*
 *  HTCharsetFormat: Revise the file format in relation to the Lynx charset.
 *
 *  This checks the format associated with an anchor for
 *  for an extended MIME Content-Type, and if a charset is
 *  indicated, sets Lynx up for proper handling in relation
 *  to the currently selected character set. - FM
 */
    extern HTFormat HTCharsetFormat(HTFormat format,
				    HTParentAnchor *anchor,
				    int default_LYhndl);

/*	Get various pieces of meta info from file name.
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
    extern void LYGetFileInfo(const char *filename,
			      HTParentAnchor **pfile_anchor,
			      HTFormat *pformat,
			      HTAtom **pencoding,
			      const char **pdesc,
			      const char **pcharset,
			      int *pfile_cs);

/*
 *  Determine file value from file name.
 */
    extern float HTFileValue(const char *filename);

/*
 *  Known compression types.
 */
    typedef enum {
	cftNone
	,cftCompress
	,cftGzip
	,cftBzip2
	,cftDeflate
    } CompressFileType;

/*
 *  Determine compression type from file name, by looking at its suffix.
 */
    extern CompressFileType HTCompressFileType(const char *filename,
					       const char *dots,
					       int *rootlen);

/*
 *  Determine compression type from the content-type.
 */
    extern CompressFileType HTContentToCompressType(const char *encoding);

/*
 *  Determine compression type from the content-encoding.
 */
    extern CompressFileType HTEncodingToCompressType(const char *encoding);

/*
 *  Determine write access to a file.
 *
 *  ON EXIT,
 *
 *  return value	YES if file can be accessed and can be written to.
 *
 *  BUGS
 *
 *   Isn't there a quicker way?
 */

#if defined(HAVE_CONFIG_H)

#ifndef HAVE_GETGROUPS
#define NO_GROUPS
#endif

#else

#ifdef VMS
#define NO_GROUPS
#endif				/* VMS */
#ifdef NO_UNIX_IO
#define NO_GROUPS
#endif				/* NO_UNIX_IO */
#ifdef PCNFS
#define NO_GROUPS
#endif				/* PCNFS */
#ifdef NOUSERS
#define NO_GROUPS
#endif				/* PCNFS */

#endif				/* HAVE_CONFIG_H */

    extern BOOL HTEditable(const char *filename);
d180 21
a200 67
 *	-------------------
 */
    extern HTStream *HTFileSaveStream(HTParentAnchor *anchor);

/*
 * Determine a suitable suffix, given the representation.
 *
 *  ON ENTRY,
 *
 *  rep			is the atomized MIME style representation
 *  enc			is an encoding (8bit, binary, gzip, compress,..)
 *
 *  ON EXIT,
 *
 *  returns		a pointer to a suitable suffix string if one has
 *			been found, else NULL.
 */
    extern const char *HTFileSuffix(HTAtom *rep,
				    const char *enc);

/*
 * Enumerate external programs that lynx may assume exists.  Unlike those
 * given in download scripts, etc., lynx would really like to know their
 * absolute paths, for better security.
 */
    typedef enum {
	ppUnknown = 0
	,ppBZIP2
	,ppCHMOD
	,ppCOMPRESS
	,ppCOPY
	,ppCSWING
	,ppGZIP
	,ppINFLATE
	,ppINSTALL
	,ppMKDIR
	,ppMV
	,ppRLOGIN
	,ppRM
	,ppRMDIR
	,ppTAR
	,ppTELNET
	,ppTN3270
	,ppTOUCH
	,ppUNCOMPRESS
	,ppUNZIP
	,ppUUDECODE
	,ppZCAT
	,ppZIP
	,pp_Last
    } ProgramPaths;

/*
 * Given a program number, return its path
 */
    extern const char *HTGetProgramPath(ProgramPaths code);

/*
 * Store a program's path 
 */
    extern void HTSetProgramPath(ProgramPaths code,
				 const char *path);

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
    extern void HTInitProgramPaths(void);
d203 2
a204 2
 *  The Protocols
 */
d206 2
a207 3
    extern GLOBALREF (HTProtocol, HTFTP);
    extern GLOBALREF (HTProtocol, HTFile);

d209 3
a211 2
    GLOBALREF HTProtocol HTFTP, HTFile;
#endif				/* GLOBALREF_IS_MACRO */
d213 1
a213 4
#ifdef __cplusplus
}
#endif
#endif				/* HTFILE_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a44 1
extern char * HTURLPath_toFile PARAMS((CONST char * name, BOOL expand_all, BOOL is_remote));
d71 1
a71 1
        HTParentAnchor* anchor,
a73 7
/*
**	Check existence.
*/
extern int HTStat PARAMS((
	CONST char *	filename,
	struct stat *	data));

d129 1
a129 1
        double          quality));
a159 29
/*	Get various pieces of meta info from file name.
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
extern void LYGetFileInfo PARAMS((
	CONST char *		filename,
	HTParentAnchor **	pfile_anchor,
	HTFormat *		pformat,
	HTAtom **		pencoding,
	CONST char**		pdesc,
	CONST char**		pcharset,
	int *			pfile_cs));

a166 15
**  Determine compression type from file name, by looking at its suffix.
*/
typedef enum {
    cftNone
    , cftCompress
    , cftGzip
    , cftBzip2
} CompressFileType;

extern CompressFileType HTCompressFileType PARAMS((
	char *			filename,
	char *			dots,
	char **			suffix));

/*
a176 24

#if defined(HAVE_CONFIG_H)

#ifndef HAVE_GETGROUPS
#define NO_GROUPS
#endif

#else

#ifdef VMS
#define NO_GROUPS
#endif /* VMS */
#ifdef NO_UNIX_IO
#define NO_GROUPS
#endif /* NO_UNIX_IO */
#ifdef PCNFS
#define NO_GROUPS
#endif /* PCNFS */
#ifdef NOUSERS
#define NO_GROUPS
#endif /* PCNFS */

#endif /* HAVE_CONFIG_H */

a202 48
 * Enumerate external programs that lynx may assume exists.  Unlike those
 * given in download scripts, etc., lynx would really like to know their
 * absolute paths, for better security.
 */
typedef enum {
    ppUnknown = 0
    ,ppBZIP2
    ,ppCHMOD
    ,ppCOMPRESS
    ,ppCOPY
    ,ppCSWING
    ,ppGZIP
    ,ppINSTALL
    ,ppMKDIR
    ,ppMV
    ,ppRLOGIN
    ,ppRM
    ,ppTAR
    ,ppTELNET
    ,ppTN3270
    ,ppTOUCH
    ,ppUNCOMPRESS
    ,ppUNZIP
    ,ppUUDECODE
    ,ppZCAT
    ,ppZIP
    ,pp_Last
} ProgramPaths;

/*
 * Given a program number, return its path
 */
extern CONST char * HTGetProgramPath PARAMS((
		ProgramPaths code));

/*
 * Store a program's path 
 */
extern void HTSetProgramPath PARAMS((
		ProgramPaths code,
		CONST char *path));

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
extern void HTInitProgramPaths NOPARAMS;

/*
d211 1
d213 1
a213 1
#endif /* HTFILE_H */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@a295 1
    ,ppRMDIR
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d45 2
a46 2
extern char * HTURLPath_toFile (const char * name, BOOL expand_all, BOOL is_remote);
extern char * HTnameOfFile_WWW (const char * name, BOOL WWW_prefix, BOOL expand_all);
d54 1
a54 1
extern char * WWW_nameOfFile (const char * name);
d59 1
a59 1
extern char * HTCacheFileName (const char * name);
d70 1
a70 1
extern BOOL HTDirTitles (
d73 1
a73 1
	BOOL		tildeIsTop);
d78 3
a80 3
extern int HTStat (
	const char *	filename,
	struct stat *	data);
d85 2
a86 2
extern int HTLoadFile (
	const char *		addr,
d89 1
a89 1
	HTStream *		sink);
d97 1
a97 1
extern void HTDirEntry (
d99 2
a100 2
        const char *    tail,           /* last part of directory name */
        const char *    entry);        /* name of this entry */
d132 6
a137 6
extern void HTSetSuffix5 (
        const char *    suffix,
        const char *    representation,
        const char *    encoding,
        const char *    desc,
        double          quality);
d150 2
a151 2
extern HTFormat HTFileFormat (
	const char *		filename,
d153 1
a153 1
	const char **		pDesc);
d163 1
a163 1
extern HTFormat HTCharsetFormat (
d166 1
a166 1
	int			default_LYhndl);
d188 2
a189 2
extern void LYGetFileInfo (
	const char *		filename,
d193 3
a195 3
	const char**		pdesc,
	const char**		pcharset,
	int *			pfile_cs);
d200 2
a201 2
extern float HTFileValue (
	const char *	filename);
d213 1
a213 1
extern CompressFileType HTCompressFileType (
d216 1
a216 1
	char **			suffix);
d253 1
a253 1
extern BOOL HTEditable (const char * filename);
d258 2
a259 2
extern HTStream * HTFileSaveStream (
	HTParentAnchor *	anchor);
d274 1
a274 1
extern const char * HTFileSuffix (
d276 1
a276 1
                const char* enc);
d312 2
a313 2
extern const char * HTGetProgramPath (
		ProgramPaths code);
d318 1
a318 1
extern void HTSetProgramPath (
d320 1
a320 1
		const char *path);
d325 1
a325 1
extern void HTInitProgramPaths (void);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 8
a9 8
 *				FILE ACCESS
 *
 *  These are routines for local file access used by WWW browsers and servers.
 *  Implemented by HTFile.c.
 *
 *  If the file is not a local file, then we pass it on to HTFTP in case it
 *  can be reached by FTP.
 */
d16 1
a16 1
#include <HTML.h>		/* SCW */
d20 19
a38 20
 *  Controlling globals
 *
 *  These flags control how directories and files are represented as
 *  hypertext, and are typically set by the application from command
 *  line options, etc.
 */
extern int HTDirAccess;		/* Directory access level */

#define HT_DIR_FORBID           0	/* Altogether forbidden */
#define HT_DIR_SELECTIVE        1	/* If HT_DIR_ENABLE_FILE exists */
#define HT_DIR_OK               2	/* Any accesible directory */

#define HT_DIR_ENABLE_FILE      ".www_browsable"	/* If exists, can browse */

extern int HTDirReadme;		/* Include readme files in listing? */

					/* Values: */
#define HT_DIR_README_NONE      0	/* No */
#define HT_DIR_README_TOP       1	/* Yes, first */
#define HT_DIR_README_BOTTOM    2	/* Yes, at the end */
d43 4
a46 5
 *  Convert filenames between local and WWW formats
 */
extern char *HTURLPath_toFile(const char *name, BOOL expand_all, BOOL is_remote);
extern char *HTnameOfFile_WWW(const char *name, BOOL WWW_prefix, BOOL expand_all);

d52 29
a80 26
 *  Make a WWW name from a full local path name
 */
extern char *WWW_nameOfFile(const char *name);

/*
 *  Generate the name of a cache file
 */
extern char *HTCacheFileName(const char *name);

/*
 *  Output directory titles
 *
 * This is (like the next one) used by HTFTP. It is common code to generate
 * the title and heading 1 and the parent directory link for any anchor.
 *
 * changed to return TRUE if parent directory link was generated,
 * FALSE otherwise - KW
 */
extern BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
			BOOL tildeIsTop);

/*
 *	Check existence.
 */
extern int HTStat(const char *filename,
		  struct stat *data);
d83 55
a137 51
 *	----------------
 */
extern int HTLoadFile(const char *addr,
		      HTParentAnchor *anchor,
		      HTFormat format_out,
		      HTStream *sink);

/*
 *  Output a directory entry
 *
 * This is used by HTFTP.c for example -- it is a common routine for
 *  generating a linked directory entry.
 */
extern void HTDirEntry(HTStructured * target, /* in which to put the linked text */ const char *tail,	/* last part of directory name */
		       const char *entry);	/* name of this entry */

/*
 *  HTSetSuffix: Define the representation for a file suffix
 *
 *  This defines a mapping between local file suffixes and file content
 *  types and encodings.
 *
 *  ON ENTRY,
 *
 *  suffix		includes the "." if that is important (normally, yes!)
 *
 *  representation	is MIME-style content-type
 *
 *  encoding		is MIME-style content-transfer-encoding
 *			(8bit, 7bit, etc) or HTTP-style content-encoding
 *			(gzip, compress etc.)
 *
 *  quality		an a priori judgement of the quality of such files
 *			(0.0..1.0)
 *
 *  HTSetSuffix5 has one more parameter for a short description of the type
 *  which is otherwise derived from the representation:
 *
 *  desc		is a short textual description, or NULL
 *
 *  Examples:   HTSetSuffix(".ps", "application/postscript", "8bit", 1.0);
 *  Examples:   HTSetSuffix(".psz", "application/postscript", "gzip", 1.0);
 *  A MIME type could also indicate a non-trivial encoding on its own
 *  ("application/x-compressed-tar"), but in that case don't use enconding
 *  to also indicate it but use "binary" etc.
 */
extern void HTSetSuffix5(const char *suffix,
			 const char *representation,
			 const char *encoding,
			 const char *desc,
			 double quality);
d142 25
a166 23
 *  HTFileFormat: Get Representation and Encoding from file name.
 *
 *  ON EXIT,
 *
 *  return		The represntation it imagines the file is in.
 *
 *  *pEncoding		The encoding (binary, 7bit, etc). See HTSetSuffix.
 */
extern HTFormat HTFileFormat(const char *filename,
			     HTAtom **pEncoding,
			     const char **pDesc);

/*
 *  HTCharsetFormat: Revise the file format in relation to the Lynx charset.
 *
 *  This checks the format associated with an anchor for
 *  for an extended MIME Content-Type, and if a charset is
 *  indicated, sets Lynx up for proper handling in relation
 *  to the currently selected character set. - FM
 */
extern HTFormat HTCharsetFormat(HTFormat format,
				HTParentAnchor *anchor,
				int default_LYhndl);
d169 33
a201 31
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
extern void LYGetFileInfo(const char *filename,
			  HTParentAnchor **pfile_anchor,
			  HTFormat *pformat,
			  HTAtom **pencoding,
			  const char **pdesc,
			  const char **pcharset,
			  int *pfile_cs);

/*
 *  Determine file value from file name.
 */
extern float HTFileValue(const char *filename);
d204 2
a205 2
 *  Determine compression type from file name, by looking at its suffix.
 */
d208 3
a210 3
    ,cftCompress
    ,cftGzip
    ,cftBzip2
d213 16
a228 15
extern CompressFileType HTCompressFileType(char *filename,
					   char *dots,
					   char **suffix);

/*
 *  Determine write access to a file.
 *
 *  ON EXIT,
 *
 *  return value	YES if file can be accessed and can be written to.
 *
 *  BUGS
 *
 *   Isn't there a quicker way?
 */
d253 1
a253 1
extern BOOL HTEditable(const char *filename);
d256 21
a276 19
 *	-------------------
 */
extern HTStream *HTFileSaveStream(HTParentAnchor *anchor);

/*
 * Determine a suitable suffix, given the representation.
 *
 *  ON ENTRY,
 *
 *  rep			is the atomized MIME style representation
 *  enc			is an encoding (8bit, binary, gzip, compress,..)
 *
 *  ON EXIT,
 *
 *  returns		a pointer to a suitable suffix string if one has
 *			been found, else NULL.
 */
extern const char *HTFileSuffix(HTAtom *rep,
				const char *enc);
d312 2
a313 1
extern const char *HTGetProgramPath(ProgramPaths code);
d318 3
a320 2
extern void HTSetProgramPath(ProgramPaths code,
			     const char *path);
d325 1
a325 1
extern void HTInitProgramPaths(void);
d328 2
a329 2
 *  The Protocols
 */
d331 2
a332 3
extern GLOBALREF (HTProtocol, HTFTP);
extern GLOBALREF (HTProtocol, HTFile);

@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d195 1
a195 1
 *  Known compression types.
a201 1
    ,cftDeflate
a203 3
/*
 *  Determine compression type from file name, by looking at its suffix.
 */
a208 10
 *  Determine compression type from the content-type.
 */
extern CompressFileType HTContentToCompressType(const char *encoding);

/*
 *  Determine compression type from the content-encoding.
 */
extern CompressFileType HTEncodingToCompressType(const char *encoding);

/*
a278 1
    ,ppINFLATE
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a44 1
extern char * HTURLPath_toFile PARAMS((CONST char * name, BOOL expand_all));
a73 7
/*
**	Check existence.
*/
extern int HTStat PARAMS((
	CONST char *	filename,
	struct stat *	data));

d129 1
a129 1
        double          quality));
a159 29
/*	Get various pieces of meta info from file name.
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
extern void LYGetFileInfo PARAMS((
	CONST char *		filename,
	HTParentAnchor **	pfile_anchor,
	HTFormat *		pformat,
	HTAtom **		pencoding,
	CONST char**		pdesc,
	CONST char**		pcharset,
	int *			pfile_cs));

a166 15
**  Determine compression type from file name, by looking at its suffix.
*/
typedef enum {
    cftNone
    , cftCompress
    , cftGzip
    , cftBzip2
} CompressFileType;

extern CompressFileType HTCompressFileType PARAMS((
	char *			filename,
	char *			dots,
	char **			suffix));

/*
a176 24

#if defined(HAVE_CONFIG_H)

#ifndef HAVE_GETGROUPS
#define NO_GROUPS
#endif

#else

#ifdef VMS
#define NO_GROUPS
#endif /* VMS */
#ifdef NO_UNIX_IO
#define NO_GROUPS
#endif /* NO_UNIX_IO */
#ifdef PCNFS
#define NO_GROUPS
#endif /* PCNFS */
#ifdef NOUSERS
#define NO_GROUPS
#endif /* PCNFS */

#endif /* HAVE_CONFIG_H */

@

