head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.45.50;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.41;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.28;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.51;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.04;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.10;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.02;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.55;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.48;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.23;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.09;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.46.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/*							HTVMS_WAISUI.c
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	30-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/

/*
 *	Routines originally from UI.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Brewster@@think.com
 */

/*
 * this is a simple ui toolkit for building other ui's on top.
 * -brewster
 *
 * top level functions:
 *   generate_search_apdu
 *   generate_retrieval_apdu
 *   interpret_message
 *
 */

/* to do:
 *   generate multiple queries for long documents.
 *     this will crash if the file being retrieved is larger than 100k.
 *   do log_write()
 *
 */

#include <HTUtils.h>

#ifdef VMS
#include <HTVMS_WaisUI.h>
#include <HTVMS_WaisProt.h>
#include <HTTCP.h>

#undef MAXINT			/* we don't need it here, and www_tcp.h may conflict */
#include <math.h>

#include <LYexit.h>
#include <LYLeaks.h>

void log_write(char *s GCC_UNUSED)
{
    return;
}

/*----------------------------------------------------------------------*/

/* returns a pointer in the buffer of the first free byte.
   if it overflows, then NULL is returned
 */
char *generate_search_apdu(char *buff,	/* buffer to hold the apdu */
			   long *buff_len,	/* length of the buffer changed to reflect new data written */
			   char *seed_words,	/* string of the seed words */
			   char *database_name,
			   DocObj **docobjs,
			   long maxDocsRetrieved)
{
    /* local variables */

    SearchAPDU *search3;
    char *end_ptr;
    static char *database_names[2] =
    {"", 0};
    any refID;
    WAISSearch *query;

    refID.size = 1;
    refID.bytes = "3";

    database_names[0] = database_name;
    query = makeWAISSearch(seed_words,
			   docobjs,	/* DocObjsPtr */
			   0,
			   1,	/* DateFactor */
			   0,	/* BeginDateRange */
			   0,	/* EndDateRange */
			   maxDocsRetrieved
	);

    search3 = makeSearchAPDU(30,
			     5000,	/* should be large */
			     30,
			     1,	/* replace indicator */
			     "",	/* result set name */
			     database_names,	/* database name */
			     QT_RelevanceFeedbackQuery,		/* query_type */
			     0,	/* element name */
			     NULL,	/* reference ID */
			     query);

    end_ptr = writeSearchAPDU(search3, buff, buff_len);

    CSTFreeWAISSearch(query);
    freeSearchAPDU(search3);
    return (end_ptr);
}

/*----------------------------------------------------------------------*/

/* returns a pointer into the buffer of the next free byte.
   if it overflowed, then NULL is returned
 */

char *generate_retrieval_apdu(char *buff,
			      long *buff_len,	/* length of the buffer changed to reflect new data written */
			      any *docID,
			      long chunk_type,
			      long start,
			      long end,
			      char *type,
			      char *database_name)
{
    SearchAPDU *search;
    char *end_ptr;

    static char *database_names[2];
    static char *element_names[3];
    any refID;

    DocObj *DocObjs[2];
    any *query;			/* changed from char* by brewster */

    if (NULL == type)
	type = s_strdup("TEXT");

    database_names[0] = database_name;
    database_names[1] = NULL;

    element_names[0] = " ";
    element_names[1] = ES_DocumentText;
    element_names[2] = NULL;

    refID.size = 1;
    refID.bytes = "3";

    switch (chunk_type) {
    case CT_line:
	DocObjs[0] = makeDocObjUsingLines(docID, type, start, end);
	break;
    case CT_byte:
	DocObjs[0] = makeDocObjUsingBytes(docID, type, start, end);
	break;
    }
    DocObjs[1] = NULL;

    query = makeWAISTextQuery(DocObjs);
    search = makeSearchAPDU(10, 16, 15,
			    1,	/* replace indicator */
			    "FOO",	/* result set name */
			    database_names,	/* database name */
			    QT_TextRetrievalQuery,	/* query_type */
			    element_names,	/* element name */
			    &refID,	/* reference ID */
			    query);
    end_ptr = writeSearchAPDU(search, buff, buff_len);
    CSTFreeWAISTextQuery(query);
    freeSearchAPDU(search);
    return (end_ptr);
}

/*----------------------------------------------------------------------*/

/* this is a safe version of unix 'read' it does all the checking
 * and looping necessary
 * to those trying to modify the transport code to use non-UNIX streams:
 *  This is the function to modify!
 */
static long read_from_stream(int d, char *buf, long nbytes)
{
    long didRead;
    long toRead = nbytes;
    long totalRead = 0;		/* paranoia */

    while (toRead > 0) {
	didRead = NETREAD(d, buf, (int) toRead);
	if (didRead == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
	if (didRead == -1)	/* error */
	    return (-1);
	if (didRead == 0)	/* eof */
	    return (-2);	/* maybe this should return 0? */
	toRead -= didRead;
	buf += didRead;
	totalRead += didRead;
    }
    if (totalRead != nbytes)	/* we overread for some reason */
	return (-totalRead);	/* bad news */
    return (totalRead);
}

/*----------------------------------------------------------------------*/

/* returns the length of the response, 0 if an error */

static long transport_message(long connection,
			      char *request_message,
			      long request_length,
			      char *response_message,
			      long response_buffer_length)
{
    WAISMessage header;
    long response_length;
    int rv;

    /* Write out message.  Read back header.  Figure out response length. */

    if (request_length + HEADER_LENGTH !=
	NETWRITE(connection, request_message,
		 (int) (request_length + HEADER_LENGTH)))
	return 0;

    /* read for the first '0' */

    while (1) {
	rv = read_from_stream(connection, response_message, 1);
	if (rv == HT_INTERRUPTED)
	    return HT_INTERRUPTED;
	if (rv < 0)
	    return 0;
	if ('0' == response_message[0])
	    break;
    }

    rv = read_from_stream(connection, response_message + 1, HEADER_LENGTH - 1);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;

    readWAISPacketHeader(response_message, &header);
    {
	char length_array[11];

	strncpy(length_array, header.msg_len, 10);
	length_array[10] = '\0';
	response_length = atol(length_array);
	/*
	   if(verbose){
	   printf("WAIS header: '%s' length_array: '%s'\n",
	   response_message, length_array);
	   }
	 */
	if (response_length > response_buffer_length) {
	    /* we got a message that is too long, therefore empty the message out,
	       and return 0 */
	    long i;

	    for (i = 0; i < response_length; i++) {
		rv = read_from_stream(connection,
				      response_message + HEADER_LENGTH,
				      1);
		if (rv == HT_INTERRUPTED)
		    return HT_INTERRUPTED;
		if (rv < 0)
		    return 0;
	    }
	    return (0);
	}
    }
    rv = read_from_stream(connection,
			  response_message + HEADER_LENGTH,
			  response_length);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;
    return (response_length);
}

/*----------------------------------------------------------------------*/

/* returns the number of bytes written.  0 if an error */
long interpret_message(char *request_message,
		       long request_length,	/* length of the buffer */
		       char *response_message,
		       long response_buffer_length,
		       long connection,
		       boolean verbose GCC_UNUSED)
{
    long response_length;

    /* ?
       if(verbose){
       printf ("sending");
       if(hostname_internal && strlen(hostname_internal) > 0)
       printf(" to host %s", hostname_internal);
       if(service_name && strlen(service_name) > 0)
       printf(" for service %s", service_name);
       printf("\n");
       twais_dsply_rsp_apdu(request_message + HEADER_LENGTH,
       request_length);
       }

     */

    writeWAISPacketHeader(request_message,
			  request_length,
			  (long) 'z',	/* Z39.50 */
			  "wais      ",		/* server name */
			  (long) NO_COMPRESSION,	/* no compression */
			  (long) NO_ENCODING, (long) HEADER_VERSION);
    if (connection != 0) {
	response_length = transport_message(connection, request_message,
					    request_length,
					    response_message,
					    response_buffer_length);
	if (response_length == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
    } else
	return (0);

    return (response_length);
}

/*----------------------------------------------------------------------*/

/* modifies the string to exclude all seeker codes. sets length to
   the new length. */
static char *delete_seeker_codes(char *string, long *length)
{
    long original_count;	/* index into the original string */
    long new_count = 0;		/* index into the collapsed string */

    for (original_count = 0; original_count < *length; original_count++) {
	if (27 == string[original_count]) {
	    /* then we have an escape code */
	    /* if the next letter is '(' or ')', then ignore two letters */
	    if ('(' == string[original_count + 1] ||
		')' == string[original_count + 1])
		original_count += 1;	/* it is a term marker */
	    else
		original_count += 4;	/* it is a paragraph marker */
	} else
	    string[new_count++] = string[original_count];
    }
    *length = new_count;
    return (string);
}

/*----------------------------------------------------------------------*/

#if defined(VMS) && defined(__GNUC__)	/* 10-AUG-1995 [pr] */
/*
  Workaround for an obscure bug in gcc's 2.6.[123] and 2.7.0 vax/vms port;
  sometimes global variables will end up not being defined properly,
  causing first gas to assume they're routines, then the linker to complain
  about unresolved symbols, and finally the program to reference the wrong
  objects (provoking ACCVIO).  It's triggered by the specific ordering of
  variable usage in the source code, hence rarely appears.  This bug is
  fixed in gcc 2.7.1, and was not present in 2.6.0 and earlier.

   Make a reference to VAXCRTL's _ctype_[], and also one to this dummy
   variable itself to prevent any "defined but not used" warning.
 */
static __const void *__const ctype_dummy[] =
{&_ctype_, &ctype_dummy};
#endif /* VMS && __GNUC__ */

/* returns a pointer to a string with good stuff */
char *trim_junk(char *headline)
{
    long length = strlen(headline) + 1;		/* include the trailing null */
    size_t i;

    headline = delete_seeker_codes(headline, &length);
    /* delete leading spaces */
    for (i = 0; i < strlen(headline); i++) {
	if (isprint(headline[i])) {
	    break;
	}
    }
    headline = headline + i;
    /* delete trailing stuff */
    for (i = strlen(headline) - 1; i > 0; i--) {
	if (isprint(headline[i])) {
	    break;
	}
	headline[i] = '\0';
    }
    return (headline);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from ZProt.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:`
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */

#define RESERVE_SPACE_FOR_HEADER(spaceLeft)		\
	*spaceLeft -= HEADER_LEN;

#define RELEASE_HEADER_SPACE(spaceLeft)			\
	if (*spaceLeft > 0)				\
	  *spaceLeft += HEADER_LEN;

/*----------------------------------------------------------------------*/

InitResponseAPDU *makeInitResponseAPDU(boolean result,
				       boolean search,
				       boolean present,
				       boolean deleteIt,
				       boolean accessControl,
				       boolean resourceControl,
				       long prefSize,
				       long maxMsgSize,
				       char *auth,
				       char *id,
				       char *name,
				       char *version,
				       any *refID,
				       void *userInfo)
/* build an initResponse APDU with user specified information */
{
    InitResponseAPDU *init = (InitResponseAPDU *) s_malloc((size_t) sizeof(InitResponseAPDU));

    init->PDUType = initResponseAPDU;
    init->Result = result;
    init->willSearch = search;
    init->willPresent = present;
    init->willDelete = deleteIt;
    init->supportAccessControl = accessControl;
    init->supportResourceControl = resourceControl;
    init->PreferredMessageSize = prefSize;
    init->MaximumRecordSize = maxMsgSize;
    init->IDAuthentication = s_strdup(auth);
    init->ImplementationID = s_strdup(id);
    init->ImplementationName = s_strdup(name);
    init->ImplementationVersion = s_strdup(version);
    init->ReferenceID = duplicateAny(refID);
    init->UserInformationField = userInfo;	/* not copied! */

    return (init);
}

/*----------------------------------------------------------------------*/

void freeInitResponseAPDU(InitResponseAPDU *init)
/* free an initAPDU */
{
    s_free(init->IDAuthentication);
    s_free(init->ImplementationID);
    s_free(init->ImplementationName);
    s_free(init->ImplementationVersion);
    freeAny(init->ReferenceID);
    s_free(init);
}

/*----------------------------------------------------------------------*/

char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len)
/* write the initResponse to a buffer, adding system information */
{
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;
    bit_map *optionsBM = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(init->PDUType, buf, len);
    buf = writeBoolean(init->Result, buf, len);
    buf = writeProtocolVersion(buf, len);

    optionsBM = makeBitMap((unsigned long) 5, init->willSearch, init->willPresent,
			   init->willDelete, init->supportAccessControl,
			   init->supportResourceControl);
    buf = writeBitMap(optionsBM, DT_Options, buf, len);
    freeBitMap(optionsBM);

    buf = writeNum(init->PreferredMessageSize,
		   DT_PreferredMessageSize,
		   buf,
		   len);
    buf = writeNum(init->MaximumRecordSize,
		   DT_MaximumRecordSize,
		   buf,
		   len);
    buf = writeString(init->IDAuthentication,
		      DT_IDAuthentication,
		      buf,
		      len);
    buf = writeString(init->ImplementationID,
		      DT_ImplementationID,
		      buf,
		      len);
    buf = writeString(init->ImplementationName,
		      DT_ImplementationName,
		      buf,
		      len);
    buf = writeString(init->ImplementationVersion,
		      DT_ImplementationVersion,
		      buf,
		      len);
    buf = writeAny(init->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (init->UserInformationField != NULL)
	buf = writeInitResponseInfo(init, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer)
{
    char *buf = buffer;
    boolean search, present, delete, accessControl, resourceControl;
    long prefSize, maxMsgSize;
    char *auth, *id, *name, *version;
    long size;
    pdu_type pduType;
    bit_map *versionBM = NULL;
    bit_map *optionsBM = NULL;
    boolean result;
    any *refID = NULL;
    void *userInfo = NULL;

    auth = id = name = version = NULL;
    refID = NULL;

    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBoolean(&result, buf);
    buf = readBitMap(&versionBM, buf);
    buf = readBitMap(&optionsBM, buf);
    buf = readNum(&prefSize, buf);
    buf = readNum(&maxMsgSize, buf);

    /* decode optionsBM */
    search = bitAtPos(0, optionsBM);
    present = bitAtPos(1, optionsBM);
    delete = bitAtPos(2, optionsBM);
    accessControl = bitAtPos(3, optionsBM);
    resourceControl = bitAtPos(4, optionsBM);

    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_IDAuthentication:
	    buf = readString(&auth, buf);
	    break;
	case DT_ImplementationID:
	    buf = readString(&id, buf);
	    break;
	case DT_ImplementationName:
	    buf = readString(&name, buf);
	    break;
	case DT_ImplementationVersion:
	    buf = readString(&version, buf);
	    break;
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
	    break;
	default:
	    freeBitMap(versionBM);
	    freeBitMap(optionsBM);
	    s_free(auth);
	    s_free(id);
	    s_free(name);
	    s_free(version);
	    freeAny(refID);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    buf = readInitResponseInfo(&userInfo, buf);
    if (buf == NULL) {
	freeBitMap(versionBM);
	freeBitMap(optionsBM);
	s_free(auth);
	s_free(id);
	s_free(name);
	s_free(version);
	freeAny(refID);
    }
    RETURN_ON_NULL(buf);

    /* construct the basic init object */
    *init = makeInitResponseAPDU(result,
				 search,
				 present,
				 delete,
				 accessControl,
				 resourceControl,
				 prefSize,
				 maxMsgSize,
				 auth,
				 id,
				 name,
				 version,
				 refID,
				 userInfo);

    freeBitMap(versionBM);
    freeBitMap(optionsBM);
    s_free(auth);
    s_free(id);
    s_free(name);
    s_free(version);
    freeAny(refID);

    return (buf);
}

/*----------------------------------------------------------------------*/

InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo)
/* respond to an init message in the default way - echoing back
   the init info
 */
{
    InitResponseAPDU *initResp;

    initResp = makeInitResponseAPDU(result,
				    init->willSearch,
				    init->willPresent,
				    init->willDelete,
				    init->supportAccessControl,
				    init->supportResourceControl,
				    init->PreferredMessageSize,
				    init->MaximumRecordSize,
				    init->IDAuthentication,
				    defaultImplementationID(),
				    defaultImplementationName(),
				    defaultImplementationVersion(),
				    init->ReferenceID,
				    userInfo);
    return (initResp);
}

/*----------------------------------------------------------------------*/

SearchAPDU *makeSearchAPDU(long small,
			   long large,
			   long medium,
			   boolean replace,
			   char *name,
			   char **databases,
			   char *type,
			   char **elements,
			   any *refID,
			   void *queryInfo)
{
    char *ptr = NULL;
    long i;
    SearchAPDU *query = (SearchAPDU *) s_malloc((size_t) sizeof(SearchAPDU));

    query->PDUType = searchAPDU;
    query->SmallSetUpperBound = small;
    query->LargeSetLowerBound = large;
    query->MediumSetPresentNumber = medium;
    query->ReplaceIndicator = replace;
    query->ResultSetName = s_strdup(name);
    query->DatabaseNames = NULL;
    if (databases != NULL) {
	for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	    if (query->DatabaseNames == NULL)
		query->DatabaseNames = (char **) s_malloc((size_t) (sizeof(char
									   *)
								    * 2));

	    else
		query->DatabaseNames = (char **) s_realloc((char *) query->DatabaseNames,
							   (size_t) (sizeof(char
									    *) *
								       (i + 2)));

	    query->DatabaseNames[i] = s_strdup(ptr);
	    query->DatabaseNames[i + 1] = NULL;
	}
    }
    query->QueryType = s_strdup(type);
    query->ElementSetNames = NULL;
    if (elements != NULL) {
	for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	    if (query->ElementSetNames == NULL)
		query->ElementSetNames =
		    (char **) s_malloc((size_t) (sizeof(char *) * 2));

	    else
		query->ElementSetNames = (char **) s_realloc((char *) query->ElementSetNames,
							     (size_t) (sizeof(char
									      *) *
								         (i + 2)));

	    query->ElementSetNames[i] = s_strdup(ptr);
	    query->ElementSetNames[i + 1] = NULL;
	}
    }
    query->ReferenceID = duplicateAny(refID);
    query->Query = queryInfo;	/* not copied! */
    return (query);
}

/*----------------------------------------------------------------------*/

void freeSearchAPDU(SearchAPDU *query)
{
    s_free(query->ResultSetName);
    s_free(query->QueryType);
    doList((void **) query->DatabaseNames, fs_free);	/* can't use the macro here ! */
    s_free(query->DatabaseNames);
    doList((void **) query->ElementSetNames, fs_free);	/* can't use the macro here ! */
    s_free(query->ElementSetNames);
    freeAny(query->ReferenceID);
    s_free(query);
}

/*----------------------------------------------------------------------*/

#define DB_DELIMITER	"\037"	/* hex 1F occurs between each database name */
#define ES_DELIMITER_1	"\037"	/* separates database name from element name */
#define ES_DELIMITER_2	"\036"	/* hex 1E separates <db,es> groups from one another */

char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len)
{
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size, i;
    char *ptr = NULL;
    char *scratch = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(query->PDUType, buf, len);
    buf = writeBinaryInteger(query->SmallSetUpperBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->LargeSetLowerBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->MediumSetPresentNumber, (size_t) 3, buf, len);
    buf = writeBoolean(query->ReplaceIndicator, buf, len);
    buf = writeString(query->ResultSetName, DT_ResultSetName, buf, len);
    /* write database names */
    if (query->DatabaseNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL;
	     ptr = query->DatabaseNames[++i]) {
	    if (scratch == NULL)
		scratch = s_strdup(ptr);
	    else {
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) + 2);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, DB_DELIMITER, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
	    }
	}
	buf = writeString(scratch, DT_DatabaseNames, buf, len);
	s_free(scratch);
    }
    buf = writeString(query->QueryType, DT_QueryType, buf, len);
    /* write element set names */
    if (query->ElementSetNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->ElementSetNames[i];
	     ptr != NULL;
	     ptr = query->ElementSetNames[++i]) {
	    if (scratch == NULL) {
		if (query->ElementSetNames[i + 1] == NULL)	/* there is a single element set name */
		{
		    scratch = (char *) s_malloc((size_t) strlen(ptr) + 2);
		    strncpy(scratch, ES_DELIMITER_1, 2);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, strlen(ptr) + 2);
		} else {	/* this is the first of a series of element set names */
		    size_t newScratchSize = (size_t) (strlen(ptr) +
						      strlen(query->ElementSetNames[i
										    + 1])
						      + 2);

		    scratch = s_strdup(ptr);	/* the database name */
		    ptr = query->ElementSetNames[++i];	/* the element set name */
		    scratch = (char *) s_realloc(scratch, newScratchSize);
		    s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
		}
	    } else {
		char *esPtr = query->ElementSetNames[++i];	/* the element set name */
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) +
						  strlen(esPtr) +
						  3);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_2, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		s_strncat(scratch, esPtr, strlen(esPtr) + 1, newScratchSize);
	    }
	}
	buf = writeString(scratch, DT_ElementSetNames, buf, len);
	s_free(scratch);
    }
    buf = writeAny(query->ReferenceID, DT_ReferenceID, buf, len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (query->Query != NULL)
	buf = writeSearchInfo(query, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

SearchResponseAPDU *makeSearchResponseAPDU(long result,
					   long count,
					   long recordsReturned,
					   long nextPos,
					   long resultStatus,
					   long presentStatus,
					   any *refID,
					   void *records)
{
    SearchResponseAPDU *query =
    (SearchResponseAPDU *) s_malloc((size_t) sizeof(SearchResponseAPDU));

    query->PDUType = searchResponseAPDU;
    query->SearchStatus = result;
    query->ResultCount = count;
    query->NumberOfRecordsReturned = recordsReturned;
    query->NextResultSetPosition = nextPos;
    query->ResultSetStatus = resultStatus;
    query->PresentStatus = presentStatus;
    query->ReferenceID = duplicateAny(refID);
    query->DatabaseDiagnosticRecords = records;
    return (query);
}

/*----------------------------------------------------------------------*/

void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse)
{
    freeAny(queryResponse->ReferenceID);
    s_free(queryResponse);
}

/*----------------------------------------------------------------------*/

char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char *buffer,
			      long *len)
{
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(queryResponse->PDUType,
		       buf,
		       len);
    buf = writeBinaryInteger(queryResponse->SearchStatus,
			     (size_t) 1,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->ResultCount,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NumberOfRecordsReturned,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NextResultSetPosition,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeNum(queryResponse->ResultSetStatus,
		   DT_ResultSetStatus,
		   buf,
		   len);
    buf = writeNum(queryResponse->PresentStatus,
		   DT_PresentStatus,
		   buf,
		   len);
    buf = writeAny(queryResponse->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (queryResponse->DatabaseDiagnosticRecords != NULL)
	buf = writeSearchResponseInfo(queryResponse, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer)
{
    char *buf = buffer;
    long size;
    pdu_type pduType;
    long result, count, recordsReturned, nextPos;
    long resultStatus, presentStatus;
    any *refID = NULL;
    void *userInfo = NULL;

    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBinaryInteger(&result, (size_t) 1, buf);
    buf = readBinaryInteger(&count, (size_t) 3, buf);
    buf = readBinaryInteger(&recordsReturned, (size_t) 3, buf);
    buf = readBinaryInteger(&nextPos, (size_t) 3, buf);

    resultStatus = presentStatus = UNUSED;
    refID = NULL;

    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_ResultSetStatus:
	    buf = readNum(&resultStatus, buf);
	    break;
	case DT_PresentStatus:
	    buf = readNum(&presentStatus, buf);
	    break;
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
	    break;
	default:
	    freeAny(refID);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    buf = readSearchResponseInfo(&userInfo, buf);
    if (buf == NULL)
	freeAny(refID);
    RETURN_ON_NULL(buf);

    /* construct the search object */
    *queryResponse = makeSearchResponseAPDU(result,
					    count,
					    recordsReturned,
					    nextPos,
					    (long) resultStatus,
					    (long) presentStatus,
					    refID,
					    userInfo);

    freeAny(refID);

    return (buf);
}

/*
 *	Routines originally from ZUtil.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - fixed include file names, changed
 *		- writeCompressedIntegerWithPadding() to
 *		  writeCompressedIntWithPadding()
 *		- generalized conditional includes (see c-dialect.h)
 * 3.7.91   Jonny Goldman.  Replaced "short" in makeBitMap with "int" line 632.
 */

char *readErrorPosition = NULL;	/* pos where buf stoped making sense */

/*----------------------------------------------------------------------*/
/* A note on error handling
   read - these are low level routines, they do not check the type tags
   which (sometimes) preceed the data (this is done by the higher
   level functions which call these functions).  There is no
   attempt made to check that the reading does not exceed the read
   buffer.  Such cases should be very rare and usually will be
   caught by the calling functions. (note - it is unlikely that
   a series of low level reads will go far off the edge without
   triggering a type error.  However, it is possible for a single
   bad read in an array function (eg. readAny) to attempt to read a
   large ammount, possibly causing a segmentation violation or out
   of memory condition.
 */
/*----------------------------------------------------------------------*/

diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo)
{
    diagnosticRecord *diag =
    (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));

    diag->SURROGATE = surrogate;
    memcpy(diag->DIAG, code, DIAGNOSTIC_CODE_SIZE);
    diag->ADDINFO = s_strdup(addInfo);

    return (diag);
}

/*----------------------------------------------------------------------*/

void freeDiag(diagnosticRecord * diag)
{
    if (diag != NULL) {
	if (diag->ADDINFO != NULL)
	    s_free(diag->ADDINFO);
	s_free(diag);
    }
}

/*----------------------------------------------------------------------*/

#define END_OF_RECORD	0x1D

char *writeDiag(diagnosticRecord * diag, char *buffer, long *len)
/* diagnostics (as per Appendix D) have a very weird format - this changes
   in SR-1
 */
{
    char *buf = buffer;
    long length;

    if (diag == NULL)		/* handle unspecified optional args */
	return (buf);

    buf = writeTag(DT_DatabaseDiagnosticRecords, buf, len);
    CHECK_FOR_SPACE_LEFT(0, len);

    length = 3;
    if (diag->ADDINFO != NULL)
	length += strlen(diag->ADDINFO);

    if (length >= 0xFFFF)	/* make sure the length is reasonable */
    {
	length = 0xFFFF - 1;
	diag->ADDINFO[0xFFFF - 3 - 1] = '\0';
    }

    buf = writeBinaryInteger(length, 2, buf, len);

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[0];
    buf++;

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[1];
    buf++;

    if (length > 3) {
	CHECK_FOR_SPACE_LEFT(3, len);
	memcpy(buf, diag->ADDINFO, (size_t) length - 3);
	buf += length - 3;
    }

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->SURROGATE;
    buf++;

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = END_OF_RECORD;
    buf++;

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readDiag(diagnosticRecord ** diag, char *buffer)
{
    char *buf = buffer;
    diagnosticRecord *d = (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));
    data_tag tag;
    long len;

    buf = readTag(&tag, buf);

    buf = readBinaryInteger(&len, 2, buf);

    d->DIAG[0] = buf[0];
    d->DIAG[1] = buf[1];
    d->DIAG[2] = '\0';

    if (len > 3) {
	d->ADDINFO = (char *) s_malloc((size_t) (len - 3 + 1));
	memcpy(d->ADDINFO, (char *) (buf + 2), (size_t) (len - 3));
	d->ADDINFO[len - 3] = '\0';
    } else
	d->ADDINFO = NULL;

    d->SURROGATE = buf[len - 1];

    *diag = d;

    return (buf + len + 1);
}

/*----------------------------------------------------------------------*/

#define continueBit	0x80
#define dataMask	0x7F
#define dataBits	7

char *writeCompressedInteger(unsigned long num, char *buf, long *len)
/* write a binary integer in the format described on p. 40.
   this might be sped up
*/
{
    char byte;
    unsigned long i;
    unsigned long size;

    size = writtenCompressedIntSize(num);
    CHECK_FOR_SPACE_LEFT(size, len);

    for (i = size - 1; i != 0; i--) {
	byte = num & dataMask;
	if (i != (size - 1))	/* turn on continue bit */
	    byte = (char) (byte | continueBit);
	buf[i] = byte;
	num = num >> dataBits;	/* don't and here */
    }

    return (buf + size);
}

/*----------------------------------------------------------------------*/

char *readCompressedInteger(unsigned long *num, char *buf)
/* read a binary integer in the format described on p. 40.
   this might be sped up
*/
{
    long i = 0;
    unsigned char byte;

    *num = 0;

    do {
	byte = buf[i++];
	*num = *num << dataBits;
	*num += (byte & dataMask);
    }
    while (byte & continueBit);

    return (buf + i);
}

/*----------------------------------------------------------------------*/

#define pad	128		/* high bit is set */

char *writeCompressedIntWithPadding(unsigned long num,
				    unsigned long size,
				    char *buffer,
				    long *len)
/* Like writeCompressedInteger, except writes padding (128) to make
   sure that size bytes are used.  This can be read correctly by
   readCompressedInteger()
*/
{
    char *buf = buffer;
    unsigned long needed, padding;
    long i;

    CHECK_FOR_SPACE_LEFT(size, len);

    needed = writtenCompressedIntSize(num);
    padding = size - needed;
    i = padding - 1;

    for (i = padding - 1; i >= 0; i--) {
	buf[i] = pad;
    }

    buf = writeCompressedInteger(num, buf + padding, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

unsigned long writtenCompressedIntSize(unsigned long num)
/* return the number of bytes needed to represnet the value num in
   compressed format.  curently limited to 4 bytes
 */
{
    if (num < CompressedInt1Byte)
	return (1);
    else if (num < CompressedInt2Byte)
	return (2);
    else if (num < CompressedInt3Byte)
	return (3);
    else
	return (4);
}

/*----------------------------------------------------------------------*/

char *writeTag(data_tag tag, char *buf, long *len)
/* write out a data tag */
{
    return (writeCompressedInteger(tag, buf, len));
}

/*----------------------------------------------------------------------*/

char *readTag(data_tag *tag, char *buf)
/* read a data tag */
{
    return (readCompressedInteger(tag, buf));
}

/*----------------------------------------------------------------------*/

unsigned long writtenTagSize(data_tag tag)
{
    return (writtenCompressedIntSize(tag));
}

/*----------------------------------------------------------------------*/

data_tag peekTag(char *buf)
/* read a data tag without advancing the buffer */
{
    data_tag tag;

    readTag(&tag, buf);
    return (tag);
}

/*----------------------------------------------------------------------*/

any *makeAny(unsigned long size, char *data)
{
    any *a = (any *) s_malloc((size_t) sizeof(any));

    a->size = size;
    a->bytes = data;
    return (a);
}

/*----------------------------------------------------------------------*/

void freeAny(any *a)
/* destroy an any and its associated data.  Assumes a->bytes was
   allocated using the s_malloc family of libraries
 */
{
    if (a != NULL) {
	if (a->bytes != NULL)
	    s_free(a->bytes);
	s_free(a);
    }
}

/*----------------------------------------------------------------------*/

any *duplicateAny(any *a)
{
    any *copy = NULL;

    if (a == NULL)
	return (NULL);

    copy = (any *) s_malloc((size_t) sizeof(any));

    copy->size = a->size;
    if (a->bytes == NULL)
	copy->bytes = NULL;
    else {
	copy->bytes = (char *) s_malloc((size_t) copy->size);
	memcpy(copy->bytes, a->bytes, (size_t) copy->size);
    }
    return (copy);
}

/*----------------------------------------------------------------------*/

char *writeAny(any *a, data_tag tag, char *buffer, long *len)
/* write an any + tag and size info */
{
    char *buf = buffer;

    if (a == NULL)		/* handle unspecified optional args */
	return (buf);

    /* write the tags */
    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(a->size, buf, len);

    /* write the bytes */
    CHECK_FOR_SPACE_LEFT(a->size, len);
    memcpy(buf, a->bytes, (size_t) a->size);

    return (buf + a->size);
}

/*----------------------------------------------------------------------*/

char *readAny(any **anAny, char *buffer)
/* read an any + tag and size info */
{
    char *buf;
    any *a;
    data_tag tag;

    a = (any *) s_malloc((size_t) sizeof(any));

    buf = buffer;

    buf = readTag(&tag, buf);

    buf = readCompressedInteger(&a->size, buf);

    /* now simply copy the bytes */
    a->bytes = (char *) s_malloc((size_t) a->size);
    memcpy(a->bytes, buf, (size_t) a->size);
    *anAny = a;

    return (buf + a->size);
}

/*----------------------------------------------------------------------*/

unsigned long writtenAnySize(data_tag tag, any *a)
{
    unsigned long size;

    if (a == NULL)
	return (0);

    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(a->size);
    size += a->size;
    return (size);
}

/*----------------------------------------------------------------------*/

any *stringToAny(char *s)
{
    any *a = NULL;

    if (s == NULL)
	return (NULL);

    a = (any *) s_malloc((size_t) sizeof(any));

    a->size = strlen(s);
    a->bytes = (char *) s_malloc((size_t) a->size);
    memcpy(a->bytes, s, (size_t) a->size);
    return (a);
}

/*----------------------------------------------------------------------*/

char *anyToString(any *a)
{
    char *s = NULL;

    if (a == NULL)
	return (NULL);

    s = s_malloc((size_t) (a->size + 1));
    memcpy(s, a->bytes, (size_t) a->size);
    s[a->size] = '\0';
    return (s);
}

/*----------------------------------------------------------------------*/

char *writeString(char *s, data_tag tag, char *buffer, long *len)
/* Write a C style string.  The terminating null is not written.
   This function is not part of the Z39.50 spec.  It is provided
   for the convienience of those wishing to pass C strings in
   the place of an any.
 */
{
    char *buf = buffer;
    any *data = NULL;

    if (s == NULL)
	return (buffer);	/* handle unused optional item before making an any */
    data = (any *) s_malloc((size_t) sizeof(any));

    data->size = strlen(s);
    data->bytes = s;		/* save a copy here by not using stringToAny() */
    buf = writeAny(data, tag, buf, len);
    s_free(data);		/* don't use freeAny() since it will free s too */
    return (buf);
}

/*----------------------------------------------------------------------*/

char *readString(char **s, char *buffer)
/* Read an any and convert it into a C style string.
   This function is not part of the Z39.50 spec.  It is provided
   for the convienience of those wishing to pass C strings in
   the place of an any.
 */
{
    any *data = NULL;
    char *buf = readAny(&data, buffer);

    *s = anyToString(data);
    freeAny(data);
    return (buf);
}

/*----------------------------------------------------------------------*/

unsigned long writtenStringSize(data_tag tag, char *s)
{
    unsigned long size;

    if (s == NULL)
	return (0);

    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(size);
    size += strlen(s);
    return (size);
}

/*----------------------------------------------------------------------*/

any *longToAny(long num)
/* a convienience function */
{
    char s[40];

    sprintf(s, "%ld", num);

    return (stringToAny(s));
}

/*----------------------------------------------------------------------*/

long anyToLong(any *a)
/* a convienience function */
{
    long num;
    char *str = NULL;

    str = anyToString(a);
    sscanf(str, "%ld", &num);	/* could check the result and return
				   an error */
    s_free(str);
    return (num);
}

/*----------------------------------------------------------------------*/

#define bitsPerByte	8

bit_map *makeBitMap(unsigned long numBits,...)
/* construct and return a bitmap with numBits elements */
{
    va_list ap;
    unsigned long i, j;
    bit_map *bm = NULL;

    LYva_start(ap, numBits);

    bm = (bit_map *) s_malloc((size_t) sizeof(bit_map));

    bm->size = (unsigned long) (ceil((double) numBits / bitsPerByte));
    bm->bytes = (char *) s_malloc((size_t) bm->size);

    /* fill up the bits */
    for (i = 0; i < bm->size; i++)	/* iterate over bytes */
    {
	char byte = 0;

	for (j = 0; j < bitsPerByte; j++)	/* iterate over bits */
	{
	    if ((i * bitsPerByte + j) < numBits) {
		boolean bit = false;

		bit = (boolean) va_arg(ap, boolean);

		if (bit) {
		    byte = byte | (1 << (bitsPerByte - j - 1));
		}
	    }
	}
	bm->bytes[i] = byte;
    }

    va_end(ap);
    return (bm);
}

/*----------------------------------------------------------------------*/

void freeBitMap(bit_map *bm)
/* destroy a bit map created by makeBitMap() */
{
    s_free(bm->bytes);
    s_free(bm);
}

/*----------------------------------------------------------------------*/

/* use this routine to interpret a bit map.  pos specifies the bit
   number.  bit 0 is the Leftmost bit of the first byte.
   Could do bounds checking.
 */

boolean bitAtPos(unsigned long pos, bit_map *bm)
{
    if (pos > bm->size * bitsPerByte)
	return false;
    else
	return ((bm->bytes[(pos / bitsPerByte)] &
		 (0x80 >> (pos % bitsPerByte))) ?
		true : false);
}

/*----------------------------------------------------------------------*/

char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len)
/* write a bitmap + type and size info */
{
    return (writeAny((any *) bm, tag, buffer, len));
}

/*----------------------------------------------------------------------*/

char *readBitMap(bit_map **bm, char *buffer)
/* read a bitmap + type and size info */
{
    char *c;

    c = readAny((any **) bm, buffer);
    return (c);
}

/*----------------------------------------------------------------------*/

char *writeByte(unsigned long byte, char *buf, long *len)
{
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = byte & 0xFF;	/* we really only want the first byte */
    return (buf + 1);
}

/*----------------------------------------------------------------------*/

char *readByte(unsigned char *byte, char *buf)
{
    *byte = buf[0];
    return (buf + 1);
}

/*----------------------------------------------------------------------*/

char *writeBoolean(boolean flag, char *buf, long *len)
{
    return (writeByte(flag, buf, len));
}

/*----------------------------------------------------------------------*/

char *readBoolean(boolean *flag, char *buffer)
{
    unsigned char byte;
    char *buf = readByte(&byte, buffer);

    *flag = (byte == true) ? true : false;
    return (buf);
}

/*----------------------------------------------------------------------*/

char *writePDUType(pdu_type pduType, char *buf, long *len)
/* PDUType is a single byte */
{
    return (writeBinaryInteger((long) pduType, (unsigned long) 1, buf, len));
}

/*----------------------------------------------------------------------*/

char *readPDUType(pdu_type *pduType, char *buf)
/* PDUType is a single byte */
{
    return (readBinaryInteger((long *) pduType, (unsigned long) 1, buf));
}

/*----------------------------------------------------------------------*/

pdu_type peekPDUType(char *buf)
/* read the next pdu without advancing the buffer, Note that this
   function is to be used on a buffer that is known to contain an
   APDU.  The pdu_type is written HEADER_LEN bytes into the buffer
 */
{
    pdu_type pdu;

    readPDUType(&pdu, buf + HEADER_LEN);
    return (pdu);
}

/*----------------------------------------------------------------------*/

#define BINARY_INTEGER_BYTES	sizeof(long)	/* the number of bytes used by
						   a "binary integer" */
char *writeBinaryInteger(long num, unsigned long size, char *buf, long *len)
/* write out first size bytes of num - no type info
  XXX should this take unsigned longs instead ???  */
{
    long i;
    char byte;

    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (NULL);		/* error */

    CHECK_FOR_SPACE_LEFT(size, len);

    for (i = size - 1; i >= 0; i--) {
	byte = (char) (num & 255);
	buf[i] = byte;
	num = num >> bitsPerByte;	/* don't and here */
    }

    return (buf + size);
}

/*----------------------------------------------------------------------*/

char *readBinaryInteger(long *num, unsigned long size, char *buf)
/* read in first size bytes of num - no type info
  XXX this should take unsigned longs instead !!! */
{
    unsigned long i;
    unsigned char byte;

    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (buf);		/* error */
    *num = 0;

    for (i = 0; i < size; i++) {
	byte = buf[i];
	*num = *num << bitsPerByte;
	*num += byte;
    }

    return (buf + size);
}

/*----------------------------------------------------------------------*/

unsigned long writtenCompressedBinIntSize(long num)
/* return the number of bytes needed to represent the value num.
   currently limited to max of 4 bytes
   Only compresses for positive nums - negatives get whole 4 bytes
 */
{
    if (num < 0L)
	return (4);
    else if (num < 256L)	/* 2**8 */
	return (1);
    else if (num < 65536L)	/* 2**16 */
	return (2);
    else if (num < 16777216L)	/* 2**24 */
	return (3);
    else
	return (4);
}

/*----------------------------------------------------------------------*/

char *writeNum(long num, data_tag tag, char *buffer, long *len)
/* write a binary integer + size and tag info */
{
    char *buf = buffer;
    long size = writtenCompressedBinIntSize(num);

    if (num == UNUSED)
	return (buffer);

    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(size, buf, len);
    buf = writeBinaryInteger(num, (unsigned long) size, buf, len);
    return (buf);
}

/*----------------------------------------------------------------------*/

char *readNum(long *num, char *buffer)
/* read a binary integer + size and tag info */
{
    char *buf = buffer;
    data_tag tag;
    unsigned long size;
    unsigned long val;

    buf = readTag(&tag, buf);
    buf = readCompressedInteger(&val, buf);
    size = (unsigned long) val;
    buf = readBinaryInteger(num, size, buf);
    return (buf);
}

/*----------------------------------------------------------------------*/

unsigned long writtenNumSize(data_tag tag, long num)
{
    long dataSize = writtenCompressedBinIntSize(num);
    long size;

    size = writtenTagSize(tag);	/* space for the tag */
    size += writtenCompressedIntSize(dataSize);		/* space for the size */
    size += dataSize;		/* space for the data */

    return (size);
}

/*----------------------------------------------------------------------*/

typedef void (voidfunc) (void *);

void doList(void **list, voidfunc * func)
/* call func on each element of the NULL terminated list of pointers */
{
    register long i;
    register void *ptr = NULL;

    if (list == NULL)
	return;
    for (i = 0, ptr = list[i]; ptr != NULL; ptr = list[++i])
	(*func) (ptr);
}

/*----------------------------------------------------------------------*/

char *writeProtocolVersion(char *buf, long *len)
/* write a bitmap describing the protocols available */
{
    static bit_map *version = NULL;

    if (version == NULL) {
	version = makeBitMap((unsigned long) 1, true);	/* version 1! */
    }

    return (writeBitMap(version, DT_ProtocolVersion, buf, len));
}

/*----------------------------------------------------------------------*/

char *defaultImplementationID(void)
{
    static char ImplementationID[] = "TMC";

    return (ImplementationID);
}

/*----------------------------------------------------------------------*/

char *defaultImplementationName(void)
{
    static char ImplementationName[] = "Thinking Machines Corporation Z39.50";

    return (ImplementationName);
}

/*----------------------------------------------------------------------*/

char *defaultImplementationVersion(void)
{
    static char ImplementationVersion[] = "2.0A";

    return (ImplementationVersion);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from ZType1.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
/*----------------------------------------------------------------------*/

query_term *makeAttributeTerm(char *use,
			      char *relation,
			      char *position,
			      char *structure,
			      char *truncation,
			      char *completeness,
			      any *term)
{
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));

    qt->TermType = TT_Attribute;

    /* copy in the attributes */
    strncpy(qt->Use, use, ATTRIBUTE_SIZE);
    strncpy(qt->Relation, relation, ATTRIBUTE_SIZE);
    strncpy(qt->Position, position, ATTRIBUTE_SIZE);
    strncpy(qt->Structure, structure, ATTRIBUTE_SIZE);
    strncpy(qt->Truncation, truncation, ATTRIBUTE_SIZE);
    strncpy(qt->Completeness, completeness, ATTRIBUTE_SIZE);

    qt->Term = duplicateAny(term);

    qt->ResultSetID = NULL;

    return (qt);
}

/*----------------------------------------------------------------------*/

query_term *makeResultSetTerm(any *resultSet)
{
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));

    qt->TermType = TT_ResultSetID;

    qt->ResultSetID = duplicateAny(resultSet);

    qt->Term = NULL;

    return (qt);
}

/*----------------------------------------------------------------------*/

query_term *makeOperatorTerm(char *operatorCode)
{
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));

    qt->TermType = TT_Operator;

    strncpy(qt->Operator, operatorCode, OPERATOR_SIZE);

    qt->Term = NULL;
    qt->ResultSetID = NULL;

    return (qt);
}

/*----------------------------------------------------------------------*/

void freeTerm(void *param)
{
    query_term *qt = (query_term *) param;

    switch (qt->TermType) {
    case TT_Attribute:
	freeAny(qt->Term);
	break;
    case TT_ResultSetID:
	freeAny(qt->ResultSetID);
	break;
    case TT_Operator:
	/* do nothing */
	break;
    default:
	panic("Implementation error: Unknown term type %ld",
	      qt->TermType);
	break;
    }
    s_free(qt);
}

/*----------------------------------------------------------------------*/

#define ATTRIBUTE_LIST_SIZE	ATTRIBUTE_SIZE * 6
#define AT_DELIMITER	" "

char *writeQueryTerm(query_term *qt, char *buffer, long *len)
{
    char *buf = buffer;
    char attributes[ATTRIBUTE_LIST_SIZE];

    switch (qt->TermType) {
    case TT_Attribute:
	strncpy(attributes, qt->Use, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Relation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Position, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Structure, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Truncation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Completeness, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	buf = writeString(attributes, DT_AttributeList, buf, len);
	buf = writeAny(qt->Term, DT_Term, buf, len);
	break;
    case TT_ResultSetID:
	buf = writeAny(qt->ResultSetID, DT_ResultSetID, buf, len);
	break;
    case TT_Operator:
	buf = writeString(qt->Operator, DT_Operator, buf, len);
	break;
    default:
	panic("Implementation error: Unknown term type %ld",
	      qt->TermType);
	break;
    }

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readQueryTerm(query_term **qt, char *buffer)
{
    char *buf = buffer;
    char *attributeList = NULL;
    char *operator = NULL;
    any *term;
    char *use = NULL;
    char *relation = NULL;
    char *position = NULL;
    char *structure = NULL;
    char *truncation = NULL;
    char *completeness;
    any *resultSetID = NULL;
    data_tag tag;

    tag = peekTag(buffer);

    switch (tag) {
    case DT_AttributeList:
	buf = readString(&attributeList, buf);
	buf = readAny(&term, buf);
	use = strtok(attributeList, AT_DELIMITER);
	relation = strtok(NULL, AT_DELIMITER);
	position = strtok(NULL, AT_DELIMITER);
	structure = strtok(NULL, AT_DELIMITER);
	truncation = strtok(NULL, AT_DELIMITER);
	completeness = strtok(NULL, AT_DELIMITER);
	*qt = makeAttributeTerm(use, relation, position, structure,
				truncation, completeness, term);
	s_free(attributeList);
	freeAny(term);
	break;
    case DT_ResultSetID:
	buf = readAny(&resultSetID, buf);
	*qt = makeResultSetTerm(resultSetID);
	freeAny(resultSetID);
	break;
    case DT_Operator:
	buf = readString(&operator, buf);
	*qt = makeOperatorTerm(operator);
	s_free(operator);
	break;
    default:
	REPORT_READ_ERROR(buf);
	break;
    }

    return (buf);
}

/*----------------------------------------------------------------------*/

static unsigned long getQueryTermSize(query_term *qt);

static unsigned long getQueryTermSize(query_term *qt)
/* figure out how many bytes it will take to write this query */
{
    unsigned long size = 0;
    static char attributes[] = "11 22 33 44 55 66";	/* we just need this to

							   calculate its written
							   size */

    switch (qt->TermType) {
    case TT_Attribute:
	size = writtenStringSize(DT_AttributeList, attributes);
	size += writtenAnySize(DT_Term, qt->Term);
	break;
    case TT_ResultSetID:
	size = writtenAnySize(DT_ResultSetID, qt->ResultSetID);
	break;
    case TT_Operator:
	size = writtenStringSize(DT_Operator, qt->Operator);
	break;
    default:
	panic("Implementation error: Unknown term type %ld",
	      qt->TermType);
	break;
    }

    return (size);
}

/*----------------------------------------------------------------------*/

/* A query is simply a null terminated list of query terms.  For
   transmission, a query is written into an any which is sent as
   the user information field. */

any *writeQuery(query_term **terms)
{
    any *info = NULL;
    char *writePos = NULL;
    char *data = NULL;
    unsigned long size = 0;
    long remaining = 0;
    long i;
    query_term *qt = NULL;

    if (terms == NULL)
	return (NULL);

    /* calculate the size of write buffer */
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	size += getQueryTermSize(qt);

    data = (char *) s_malloc((size_t) size);

    /* write the terms */
    writePos = data;
    remaining = size;
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	writePos = writeQueryTerm(qt, writePos, &remaining);

    info = makeAny(size, data);

    return (info);
}

/*----------------------------------------------------------------------*/

query_term **readQuery(any *info)
{
    char *readPos = info->bytes;
    query_term **terms = NULL;
    query_term *qt = NULL;
    long numTerms = 0L;
    char tmp[100];

    sprintf(tmp, "readquery: bytes: %ld", info->size);
    log_write(tmp);

    while (readPos < info->bytes + info->size) {
	readPos = readQueryTerm(&qt, readPos);

	if (terms == NULL) {
	    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 2));
	} else {
	    terms =
		(query_term **) s_realloc((char *) terms,
					  (size_t) (sizeof(query_term *) *
						      (numTerms + 2)));
	}
	if (qt == NULL)
	    log_write("qt = null");
	terms[numTerms++] = qt;
	terms[numTerms] = NULL;
    }

    return (terms);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from panic.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Morris@@think.com
 */

/* panic is an error system interface.  On the Mac, it will pop
 * up a little window to explain the problem.
 * On a unix box, it will print out the error and call perror()
 */

/*----------------------------------------------------------------------*/

static void exitAction(long error);

static void exitAction(long error GCC_UNUSED)
{
    long i;

    for (i = 0; i < 100000; i++) ;
    exit_immediately(0);
}

/*----------------------------------------------------------------------*/

#define PANIC_HEADER "Fatal Error:  "

void panic(char *format,...)
{
    va_list ap;			/* the variable arguments */

    fprintf(stderr, PANIC_HEADER);
    LYva_start(ap, format);	/* init ap */
    vfprintf(stderr, format, ap);	/* print the contents */
    va_end(ap);			/* free ap */
    fflush(stderr);

    exitAction(0);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from cutil.c -- FM
 *
 *----------------------------------------------------------------------*/
/* Wide AREA INFORMATION SERVER SOFTWARE
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */

/*----------------------------------------------------------------------*/

void fs_checkPtr(void *ptr)
/* If the ptr is NULL, give an error */
{
    if (ptr == NULL)
	panic("checkPtr found a NULL pointer");
}

/*----------------------------------------------------------------------*/

void *fs_malloc(size_t size)
/* does safety checks and optional accounting */
{
    register void *ptr = NULL;

    ptr = (void *) calloc((size_t) size, (size_t) 1);
    s_checkPtr(ptr);

    return (ptr);
}

/*----------------------------------------------------------------------*/

void *fs_realloc(void *ptr, size_t size)
/* does safety checks and optional accounting
   note - we don't know how big ptr's memory is, so we can't ensure
   that any new memory allocated is NULLed!
 */
{
    register void *nptr = NULL;

    if (ptr == NULL)		/* this is really a malloc */
	return (s_malloc(size));

    nptr = (void *) realloc(ptr, size);
    s_checkPtr(ptr);

    return (nptr);
}

/*----------------------------------------------------------------------*/

void fs_free(void *ptr)
/* does safety checks and optional accounting */
{
    if (ptr != NULL)		/* some non-ansi compilers/os's cant handle freeing null */
    {				/* if we knew the size of this block of memory, we could clear it - oh well */
	free(ptr);
	ptr = NULL;
    }
}

/*----------------------------------------------------------------------*/

char *s_strdup(char *s)

/* return a copy of s.  This is identical to the standard library routine
   strdup(), except that it is safe.  If s == NULL or malloc fails,
   appropriate action is taken.
 */
{
    unsigned long len;
    char *copy = NULL;

    if (s == NULL)		/* saftey check to postpone stupid errors */
	return (NULL);

    len = strlen(s);		/* length of string - terminator */
    copy = (char *) s_malloc((size_t) (sizeof(char) * (len + 1)));

    strncpy(copy, s, len + 1);
    return (copy);
}

/*----------------------------------------------------------------------*/

char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal)

/* like strncat, except the fourth argument limits the maximum total
   length of the resulting string
 */
{
    size_t dstSize = strlen(dst);
    size_t srcSize = strlen(src);

    if (dstSize + srcSize < maxTotal)	/* use regular old strncat */
	return (strncat(dst, src, maxToAdd));
    else {
	size_t truncateTo = maxTotal - dstSize - 1;
	char saveChar = src[truncateTo];
	char *result = NULL;

	src[truncateTo] = '\0';
	result = strncat(dst, src, maxToAdd);
	src[truncateTo] = saveChar;
	return (result);
    }
}

/*----------------------------------------------------------------------*/

char char_downcase(unsigned long long_ch)
{
    unsigned char ch = long_ch & 0xFF;	/* just want one byte */

    /* when ansi is the way of the world, this can be tolower */
    return (((ch >= 'A') && (ch <= 'Z')) ? (ch + 'a' - 'A') : ch);
}

char *string_downcase(char *word)
{
    long i = 0;

    while (word[i] != '\0') {
	word[i] = char_downcase((unsigned long) word[i]);
	i++;
    }
    return (word);
}

/*----------------------------------------------------------------------*/
#endif /* VMS */
@


1.6
log
@automatic merge of lynx-current
@
text
@d2125 1
a2125 1
    exit(0);
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 6
a7 6
**
**	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
**
**	30-May-1994 FM	Initial version.
**
**----------------------------------------------------------------------*/
d10 3
a12 3
**	Routines originally from UI.c -- FM
**
**----------------------------------------------------------------------*/
d14 5
a18 5
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   Brewster@@think.com
*/
d39 2
d45 1
a45 1
#undef MAXINT	/* we don't need it here, and www_tcp.h may conflict */
d51 1
a51 2
void
log_write(char *s GCC_UNUSED)
d61 45
a105 45
char *
generate_search_apdu(
char* buff,     /* buffer to hold the apdu */
long *buff_len,    /* length of the buffer changed to reflect new data written */
char *seed_words,    /* string of the seed words */
char *database_name,
DocObj** docobjs,
long maxDocsRetrieved)
{
  /* local variables */

  SearchAPDU *search3;
  char  *end_ptr;
  static char *database_names[2] = {"", 0};
  any refID;
  WAISSearch *query;
  refID.size = 1;
  refID.bytes = "3";

  database_names[0] = database_name;
  query = makeWAISSearch(seed_words,
                         docobjs, /* DocObjsPtr */
                         0,
                         1,     /* DateFactor */
                         0,     /* BeginDateRange */
                         0,     /* EndDateRange */
                         maxDocsRetrieved
                         );

  search3 = makeSearchAPDU(30,
			   5000, /* should be large */
			   30,
                           1,	/* replace indicator */
                           "",	/* result set name */
                           database_names, /* database name */
                           QT_RelevanceFeedbackQuery, /* query_type */
                           0,   /* element name */
                           NULL, /* reference ID */
                           query);

  end_ptr = writeSearchAPDU(search3, buff, buff_len);

  CSTFreeWAISSearch(query);
  freeSearchAPDU(search3);
  return(end_ptr);
d114 55
a168 57
char *
generate_retrieval_apdu(
char *buff,
long *buff_len,    /* length of the buffer changed to reflect new data written */
any *docID,
long chunk_type,
long start,
long end,
char *type,
char *database_name)
{
  SearchAPDU *search;
  char  *end_ptr;

  static char *database_names[2];
  static char *element_names[3];
  any refID;

  DocObj *DocObjs[2];
  any *query;			/* changed from char* by brewster */

  if(NULL == type)
    type = s_strdup("TEXT");

  database_names[0] = database_name;
  database_names[1] = NULL;

  element_names[0] = " ";
  element_names[1] = ES_DocumentText;
  element_names[2] = NULL;

  refID.size = 1;
  refID.bytes = "3";

  switch(chunk_type){
  case CT_line:
    DocObjs[0] = makeDocObjUsingLines(docID, type, start, end);
    break;
  case CT_byte:
    DocObjs[0] = makeDocObjUsingBytes(docID, type, start, end);
    break;
  }
  DocObjs[1] = NULL;

  query = makeWAISTextQuery(DocObjs);
  search = makeSearchAPDU( 10, 16, 15,
			  1,	/* replace indicator */
			  "FOO", /* result set name */
			  database_names, /* database name */
			  QT_TextRetrievalQuery, /* query_type */
			  element_names, /* element name */
			  &refID, /* reference ID */
			  query);
  end_ptr = writeSearchAPDU(search, buff, buff_len);
  CSTFreeWAISTextQuery(query);
  freeSearchAPDU(search);
  return(end_ptr);
d180 19
a198 19
  long didRead;
  long toRead = nbytes;
  long totalRead = 0;		/* paranoia */

  while (toRead > 0){
    didRead = NETREAD (d, buf, (int)toRead);
    if(didRead == HT_INTERRUPTED)
      return(HT_INTERRUPTED);
    if(didRead == -1)		/* error*/
      return(-1);
    if(didRead == 0)		/* eof */
      return(-2);		/* maybe this should return 0? */
    toRead -= didRead;
    buf += didRead;
    totalRead += didRead;
  }
  if(totalRead != nbytes)	/* we overread for some reason */
    return(- totalRead);	/* bad news */
  return(totalRead);
d205 28
a232 19
static long
transport_message(
	long connection,
	char *request_message,
	long request_length,
	char *response_message,
	long response_buffer_length)
{
  WAISMessage header;
  long response_length;
  int rv;


  /* Write out message.  Read back header.  Figure out response length. */

  if( request_length + HEADER_LENGTH !=
      NETWRITE(connection,request_message,
		  (int)( request_length +HEADER_LENGTH)) )
    return 0;
d234 5
a238 1
  /* read for the first '0' */
d240 33
a272 2
  while(1){
    rv = read_from_stream(connection, response_message, 1);
d274 1
a274 1
      return HT_INTERRUPTED;
d276 2
a277 47
      return 0;
    if('0' == response_message[0])
      break;
  }

  rv = read_from_stream(connection, response_message + 1, HEADER_LENGTH -1);
  if (rv == HT_INTERRUPTED)
    return HT_INTERRUPTED;
  if (rv < 0)
    return 0;

  readWAISPacketHeader(response_message, &header);
  {
    char length_array[11];
    strncpy(length_array, header.msg_len, 10);
    length_array[10] = '\0';
    response_length = atol(length_array);
    /*
      if(verbose){
      printf("WAIS header: '%s' length_array: '%s'\n",
      response_message, length_array);
      }
      */
    if(response_length > response_buffer_length){
      /* we got a message that is too long, therefore empty the message out,
	 and return 0 */
      long i;
      for(i = 0; i < response_length; i++){
	rv = read_from_stream(connection,
			      response_message + HEADER_LENGTH,
			      1);
	if (rv == HT_INTERRUPTED)
	  return HT_INTERRUPTED;
	if (rv < 0)
	  return 0;
      }
      return(0);
    }
  }
  rv = read_from_stream(connection,
			response_message + HEADER_LENGTH,
			response_length);
  if (rv == HT_INTERRUPTED)
    return HT_INTERRUPTED;
  if (rv < 0)
    return 0;
  return(response_length);
d283 38
a320 41
long
interpret_message(
	char *request_message,
	long request_length, /* length of the buffer */
	char *response_message,
	long response_buffer_length,
	long connection,
	boolean verbose GCC_UNUSED)
{
  long response_length;

  /* ?
  if(verbose){
    printf ("sending");
    if(hostname_internal && strlen(hostname_internal) > 0)
      printf(" to host %s", hostname_internal);
    if(service_name && strlen(service_name) > 0)
      printf(" for service %s", service_name);
    printf("\n");
    twais_dsply_rsp_apdu(request_message + HEADER_LENGTH,
			 request_length);
  }

  */

  writeWAISPacketHeader(request_message,
			request_length,
			(long)'z',	/* Z39.50 */
			"wais      ", /* server name */
			(long)NO_COMPRESSION,	/* no compression */
			(long)NO_ENCODING,(long)HEADER_VERSION);
  if(connection != 0) {
    response_length = transport_message(connection, request_message,
					request_length,
					response_message,
					response_buffer_length);
    if (response_length == HT_INTERRUPTED)
      return(HT_INTERRUPTED);
  }
  else
      return(0);
d322 1
a322 1
  return(response_length);
d331 17
a347 15
  long original_count; /* index into the original string */
  long new_count = 0; /* index into the collapsed string */
  for(original_count = 0; original_count < *length; original_count++){
    if(27 == string[original_count]){
      /* then we have an escape code */
      /* if the next letter is '(' or ')', then ignore two letters */
      if('(' == string[original_count + 1] ||
    ')' == string[original_count + 1])
     original_count += 1;    /* it is a term marker */
      else original_count += 4; /* it is a paragraph marker */
    }
    else string[new_count++] = string[original_count];
  }
  *length = new_count;
  return(string);
d352 1
a352 1
#if defined(VMS) && defined(__GNUC__)			/* 10-AUG-1995 [pr] */
d365 2
a366 1
static __const void *__const ctype_dummy[] = { &_ctype_, &ctype_dummy };
d372 19
a390 18
  long length = strlen(headline) + 1; /* include the trailing null */
  size_t i;
  headline = delete_seeker_codes(headline, &length);
  /* delete leading spaces */
  for(i=0; i < strlen(headline); i++){
    if(isprint(headline[i])){
      break;
    }
  }
  headline = headline + i;
  /* delete trailing stuff */
  for(i=strlen(headline) - 1 ; i > 0; i--){
    if(isprint(headline[i])){
      break;
    }
    headline[i] = '\0';
  }
  return(headline);
a394 1

d396 3
a398 3
**	Routines originally from ZProt.c -- FM
**
**----------------------------------------------------------------------*/
d400 7
a406 7
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   3.26.90	Harry Morris, morris@@think.com
   3.30.90  Harry Morris - Changed any->bits to any->bytes
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
*/
d417 14
a430 16
InitResponseAPDU*
makeInitResponseAPDU(
boolean result,
boolean search,
boolean present,
boolean deleteIt,
boolean accessControl,
boolean resourceControl,
long prefSize,
long maxMsgSize,
char* auth,
char* id,
char* name,
char* version,
any* refID,
void* userInfo)
d433 1
a433 1
  InitResponseAPDU* init = (InitResponseAPDU*)s_malloc((size_t)sizeof(InitResponseAPDU));
d435 15
a449 15
  init->PDUType = initResponseAPDU;
  init->Result = result;
  init->willSearch = search;
  init->willPresent = present;
  init->willDelete = deleteIt;
  init->supportAccessControl = accessControl;
  init->supportResourceControl = resourceControl;
  init->PreferredMessageSize = prefSize;
  init->MaximumRecordSize = maxMsgSize;
  init->IDAuthentication = s_strdup(auth);
  init->ImplementationID = s_strdup(id);
  init->ImplementationName = s_strdup(name);
  init->ImplementationVersion = s_strdup(version);
  init->ReferenceID = duplicateAny(refID);
  init->UserInformationField = userInfo; /* not copied! */
d451 1
a451 1
  return(init);
d456 1
a456 2
void
freeInitResponseAPDU(InitResponseAPDU* init)
d459 6
a464 6
  s_free(init->IDAuthentication);
  s_free(init->ImplementationID);
  s_free(init->ImplementationName);
  s_free(init->ImplementationVersion);
  freeAny(init->ReferenceID);
  s_free(init);
d469 1
a469 2
char*
writeInitResponseAPDU(InitResponseAPDU* init, char* buffer, long* len)
d472 98
a569 77
  char* buf = buffer + HEADER_LEN; /* leave room for the header-length-indicator */
  long size;
  bit_map* optionsBM = NULL;

  RESERVE_SPACE_FOR_HEADER(len);

  buf = writePDUType(init->PDUType,buf,len);
  buf = writeBoolean(init->Result,buf,len);
  buf = writeProtocolVersion(buf,len);

  optionsBM = makeBitMap((unsigned long)5,init->willSearch,init->willPresent,
                         init->willDelete,init->supportAccessControl,
                         init->supportResourceControl);
  buf = writeBitMap(optionsBM,DT_Options,buf,len);
  freeBitMap(optionsBM);

  buf = writeNum(init->PreferredMessageSize,DT_PreferredMessageSize,buf,len);
  buf = writeNum(init->MaximumRecordSize,DT_MaximumRecordSize,buf,len);
  buf = writeString(init->IDAuthentication,DT_IDAuthentication,buf,len);
  buf = writeString(init->ImplementationID,DT_ImplementationID,buf,len);
  buf = writeString(init->ImplementationName,DT_ImplementationName,buf,len);
  buf = writeString(init->ImplementationVersion,DT_ImplementationVersion,buf,len);
  buf = writeAny(init->ReferenceID,DT_ReferenceID,buf,len);

  /* go back and write the header-length-indicator */
  RELEASE_HEADER_SPACE(len);
  size = buf - buffer - HEADER_LEN;
  writeBinaryInteger(size,HEADER_LEN,buffer,len);

  if (init->UserInformationField != NULL)
    buf = writeInitResponseInfo(init,buf,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readInitResponseAPDU(InitResponseAPDU** init, char* buffer)
{
  char* buf = buffer;
  boolean search,present,delete,accessControl,resourceControl;
  long prefSize,maxMsgSize;
  char *auth,*id,*name,*version;
  long size;
  pdu_type pduType;
  bit_map* versionBM = NULL;
  bit_map* optionsBM = NULL;
  boolean result;
  any *refID = NULL;
  void* userInfo = NULL;

  auth = id = name = version = NULL;
  refID = NULL;

  /* read required part */
  buf = readBinaryInteger(&size,HEADER_LEN,buf);
  buf = readPDUType(&pduType,buf);
  buf = readBoolean(&result,buf);
  buf = readBitMap(&versionBM,buf);
  buf = readBitMap(&optionsBM,buf);
  buf = readNum(&prefSize,buf);
  buf = readNum(&maxMsgSize,buf);

  /* decode optionsBM */
  search = bitAtPos(0,optionsBM);
  present = bitAtPos(1,optionsBM);
  delete = bitAtPos(2,optionsBM);
  accessControl = bitAtPos(3,optionsBM);
  resourceControl = bitAtPos(4,optionsBM);

  /* read optional part */
  while (buf < (buffer + size + HEADER_LEN))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_IDAuthentication:
	    buf = readString(&auth,buf);
d571 2
a572 2
	  case DT_ImplementationID:
	    buf = readString(&id,buf);
d574 2
a575 2
	  case DT_ImplementationName:
	    buf = readString(&name,buf);
d577 2
a578 2
	  case DT_ImplementationVersion:
	    buf = readString(&version,buf);
d580 2
a581 2
	  case DT_ReferenceID:
	    buf = readAny(&refID,buf);
d583 1
a583 1
	  default:
d593 1
a593 1
	  }
d596 35
a630 16
  buf = readInitResponseInfo(&userInfo,buf);
  if (buf == NULL)
    { freeBitMap(versionBM);
      freeBitMap(optionsBM);
      s_free(auth);
      s_free(id);
      s_free(name);
      s_free(version);
      freeAny(refID);
    }
  RETURN_ON_NULL(buf);

  /* construct the basic init object */
  *init = makeInitResponseAPDU(result,
			       search,present,delete,accessControl,resourceControl,
			       prefSize,maxMsgSize,auth,id,name,version,refID,userInfo);
d632 1
a632 9
  freeBitMap(versionBM);
  freeBitMap(optionsBM);
  s_free(auth);
  s_free(id);
  s_free(name);
  s_free(version);
  freeAny(refID);

  return(buf);
d637 1
a637 2
InitResponseAPDU*
replyToInitAPDU(InitAPDU* init, boolean result, void* userInfo)
d642 17
a658 9
  InitResponseAPDU* initResp;
  initResp = makeInitResponseAPDU(result,
				  init->willSearch,init->willPresent,init->willDelete,
				  init->supportAccessControl,init->supportResourceControl,
				  init->PreferredMessageSize,init->MaximumRecordSize,
				  init->IDAuthentication,defaultImplementationID(),defaultImplementationName(),
				  defaultImplementationVersion(),
				  init->ReferenceID,userInfo);
  return(initResp);
d663 35
a697 30
SearchAPDU*
makeSearchAPDU(
long small,
long large,
long medium,
boolean replace,
char* name,
char** databases,
char* type,
char** elements,
any* refID,
void* queryInfo)
{
  char* ptr = NULL;
  long i;
  SearchAPDU* query = (SearchAPDU*)s_malloc((size_t)sizeof(SearchAPDU));
  query->PDUType = searchAPDU;
  query->SmallSetUpperBound = small;
  query->LargeSetLowerBound = large;
  query->MediumSetPresentNumber = medium;
  query->ReplaceIndicator = replace;
  query->ResultSetName = s_strdup(name);
  query->DatabaseNames = NULL;
  if (databases != NULL) {
    for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	if (query->DatabaseNames == NULL)
	    query->DatabaseNames = (char**)s_malloc((size_t)(sizeof(char*) * 2));
        else
          query->DatabaseNames = (char**)s_realloc((char*)query->DatabaseNames,
						   (size_t)(sizeof(char*) * (i + 2)));
d699 1
a699 1
	    query->DatabaseNames[i+1] = NULL;
d702 14
a715 9
  query->QueryType = s_strdup(type);
  query->ElementSetNames = NULL;
  if (elements != NULL) {
    for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	if (query->ElementSetNames == NULL)
	    query->ElementSetNames = (char**)s_malloc((size_t)(sizeof(char*) * 2));
        else
          query->ElementSetNames = (char**)s_realloc((char*)query->ElementSetNames,
						     (size_t)(sizeof(char*) * (i + 2)));
d717 6
a722 6
	    query->ElementSetNames[i+1] = NULL;
	  }
      }
  query->ReferenceID = duplicateAny(refID);
  query->Query = queryInfo;	/* not copied! */
  return(query);
d727 10
a736 11
void
freeSearchAPDU(SearchAPDU* query)
{
  s_free(query->ResultSetName);
  s_free(query->QueryType);
  doList((void**)query->DatabaseNames,fs_free); /* can't use the macro here ! */
  s_free(query->DatabaseNames);
  doList((void**)query->ElementSetNames,fs_free); /* can't use the macro here ! */
  s_free(query->ElementSetNames);
  freeAny(query->ReferenceID);
  s_free(query);
d745 1
a745 2
char*
writeSearchAPDU(SearchAPDU* query, char* buffer, long* len)
d747 27
a773 24
  char* buf = buffer + HEADER_LEN; /* leave room for the header-length-indicator */
  long size,i;
  char* ptr = NULL;
  char* scratch = NULL;

  RESERVE_SPACE_FOR_HEADER(len);

  buf = writePDUType(query->PDUType,buf,len);
  buf = writeBinaryInteger(query->SmallSetUpperBound,(size_t)3,buf,len);
  buf = writeBinaryInteger(query->LargeSetLowerBound,(size_t)3,buf,len);
  buf = writeBinaryInteger(query->MediumSetPresentNumber,(size_t)3,buf,len);
  buf = writeBoolean(query->ReplaceIndicator,buf,len);
  buf = writeString(query->ResultSetName,DT_ResultSetName,buf,len);
  /* write database names */
  if (query->DatabaseNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL; ptr = query->DatabaseNames[++i]) {
	if (scratch == NULL)
	    scratch = s_strdup(ptr);
        else
	  { size_t newScratchSize = (size_t)(strlen(scratch) + strlen(ptr) + 2);
	    scratch = (char*)s_realloc(scratch,newScratchSize);
	    s_strncat(scratch,DB_DELIMITER,2,newScratchSize);
	    s_strncat(scratch,ptr,strlen(ptr) + 1,newScratchSize);
	  }
d775 1
a775 1
	buf = writeString(scratch,DT_DatabaseNames,buf,len);
d777 24
a800 10
      }
  buf = writeString(query->QueryType,DT_QueryType,buf,len);
  /* write element set names */
  if (query->ElementSetNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->ElementSetNames[i]; ptr != NULL; ptr = query->ElementSetNames[++i]) {
	if (scratch == NULL) {
	    if (query->ElementSetNames[i+1] == NULL) /* there is a single element set name */
		{ scratch = (char*)s_malloc((size_t)strlen(ptr) + 2);
		  strncpy(scratch,ES_DELIMITER_1,2);
		  s_strncat(scratch,ptr,strlen(ptr) + 1,strlen(ptr) + 2);
d802 15
a816 20
	    else		/* this is the first of a series of element set names */
	      { size_t newScratchSize = (size_t)(strlen(ptr) + strlen(query->ElementSetNames[i + 1]) + 2);
		scratch = s_strdup(ptr); /* the database name */
		ptr = query->ElementSetNames[++i]; /* the element set name */
		scratch = (char*)s_realloc(scratch,newScratchSize);
		s_strncat(scratch,ES_DELIMITER_1,2,newScratchSize);
		s_strncat(scratch,ptr,strlen(ptr) + 1,newScratchSize);
	      }
	  }
        else
	  { char* esPtr = query->ElementSetNames[++i]; /* the element set name */
	    size_t newScratchSize = (size_t)(strlen(scratch) + strlen(ptr) + strlen(esPtr) + 3);
	    scratch = (char*)s_realloc(scratch,newScratchSize);
	    s_strncat(scratch,ES_DELIMITER_2,2,newScratchSize);
	    s_strncat(scratch,ptr,strlen(ptr) + 1,newScratchSize);
	    s_strncat(scratch,ES_DELIMITER_1,2,newScratchSize);
	    s_strncat(scratch,esPtr,strlen(esPtr) + 1,newScratchSize);
	  }
	  }
	buf = writeString(scratch,DT_ElementSetNames,buf,len);
d818 2
a819 2
      }
  buf = writeAny(query->ReferenceID,DT_ReferenceID,buf,len);
d821 4
a824 4
  /* go back and write the header-length-indicator */
  RELEASE_HEADER_SPACE(len);
  size = buf - buffer - HEADER_LEN;
  writeBinaryInteger(size,HEADER_LEN,buffer,len);
d826 2
a827 2
  if (query->Query != NULL)
    buf = writeSearchInfo(query,buf,len);
d829 1
a829 1
  return(buf);
d834 8
a841 10
SearchResponseAPDU*
makeSearchResponseAPDU(
long result,
long count,
long recordsReturned,
long nextPos,
long resultStatus,
long presentStatus,
any* refID,
void* records)
d843 13
a855 11
  SearchResponseAPDU* query = (SearchResponseAPDU*)s_malloc((size_t)sizeof(SearchResponseAPDU));
  query->PDUType = searchResponseAPDU;
  query->SearchStatus = result;
  query->ResultCount = count;
  query->NumberOfRecordsReturned = recordsReturned;
  query->NextResultSetPosition = nextPos;
  query->ResultSetStatus = resultStatus;
  query->PresentStatus = presentStatus;
  query->ReferenceID = duplicateAny(refID);
  query->DatabaseDiagnosticRecords = records;
  return(query);
d860 1
a860 2
void
freeSearchResponseAPDU(SearchResponseAPDU* queryResponse)
d862 2
a863 2
  freeAny(queryResponse->ReferenceID);
  s_free(queryResponse);
d868 2
a869 2
char*
writeSearchResponseAPDU(SearchResponseAPDU* queryResponse, char* buffer, long* len)
d871 2
a872 2
  char* buf = buffer + HEADER_LEN; /* leave room for the header-length-indicator */
  long size;
d874 1
a874 1
  RESERVE_SPACE_FOR_HEADER(len);
d876 31
a906 8
  buf = writePDUType(queryResponse->PDUType,buf,len);
  buf = writeBinaryInteger(queryResponse->SearchStatus,(size_t)1,buf,len);
  buf = writeBinaryInteger(queryResponse->ResultCount,(size_t)3,buf,len);
  buf = writeBinaryInteger(queryResponse->NumberOfRecordsReturned,(size_t)3,buf,len);
  buf = writeBinaryInteger(queryResponse->NextResultSetPosition,(size_t)3,buf,len);
  buf = writeNum(queryResponse->ResultSetStatus,DT_ResultSetStatus,buf,len);
  buf = writeNum(queryResponse->PresentStatus,DT_PresentStatus,buf,len);
  buf = writeAny(queryResponse->ReferenceID,DT_ReferenceID,buf,len);
d908 4
a911 4
  /* go back and write the header-length-indicator */
  RELEASE_HEADER_SPACE(len);
  size = buf - buffer - HEADER_LEN;
  writeBinaryInteger(size,HEADER_LEN,buffer,len);
d913 2
a914 2
  if (queryResponse->DatabaseDiagnosticRecords != NULL)
    buf = writeSearchResponseInfo(queryResponse,buf,len);
d916 1
a916 1
  return(buf);
d921 1
a921 2
char*
readSearchResponseAPDU(SearchResponseAPDU** queryResponse, char* buffer)
d923 7
a929 7
  char* buf = buffer;
  long size;
  pdu_type pduType;
  long result,count,recordsReturned,nextPos;
  long resultStatus,presentStatus;
  any *refID = NULL;
  void* userInfo = NULL;
d931 7
a937 7
  /* read required part */
  buf = readBinaryInteger(&size,HEADER_LEN,buf);
  buf = readPDUType(&pduType,buf);
  buf = readBinaryInteger(&result,(size_t)1,buf);
  buf = readBinaryInteger(&count,(size_t)3,buf);
  buf = readBinaryInteger(&recordsReturned,(size_t)3,buf);
  buf = readBinaryInteger(&nextPos,(size_t)3,buf);
d939 2
a940 2
  resultStatus = presentStatus = UNUSED;
  refID = NULL;
d942 7
a948 6
  /* read optional part */
  while (buf < (buffer + size + HEADER_LEN))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_ResultSetStatus:
	    buf = readNum(&resultStatus,buf);
d950 2
a951 2
	  case DT_PresentStatus:
	    buf = readNum(&presentStatus,buf);
d953 2
a954 2
	  case DT_ReferenceID:
	    buf = readAny(&refID,buf);
d956 1
a956 1
	  default:
d960 1
a960 1
	  }
d963 15
a977 2
  buf = readSearchResponseInfo(&userInfo,buf);
  if (buf == NULL)
a978 5
  RETURN_ON_NULL(buf);

  /* construct the search object */
  *queryResponse = makeSearchResponseAPDU(result,count,recordsReturned,nextPos,
					  (long)resultStatus,(long)presentStatus,refID,userInfo);
d980 1
a980 3
  freeAny(refID);

  return(buf);
a982 1

d984 3
a986 3
**	Routines originally from ZUtil.c -- FM
**
**----------------------------------------------------------------------*/
d988 11
a998 2
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.
d1000 1
a1000 10
   3.26.90	Harry Morris, morris@@think.com
   3.30.90  Harry Morris - Changed any->bits to any->bytes
   4.11.90  HWM - fixed include file names, changed
		- writeCompressedIntegerWithPadding() to
		  writeCompressedIntWithPadding()
		- generalized conditional includes (see c-dialect.h)
   3.7.91   Jonny Goldman.  Replaced "short" in makeBitMap with "int" line 632.
*/

char* readErrorPosition = NULL; /* pos where buf stoped making sense */
d1018 1
a1018 2
diagnosticRecord*
makeDiag(boolean surrogate, char* code, char* addInfo)
d1020 2
a1021 2
  diagnosticRecord* diag =
    (diagnosticRecord*)s_malloc((size_t)sizeof(diagnosticRecord));
d1023 3
a1025 3
  diag->SURROGATE = surrogate;
  memcpy(diag->DIAG,code,DIAGNOSTIC_CODE_SIZE);
  diag->ADDINFO = s_strdup(addInfo);
d1027 1
a1027 1
  return(diag);
d1032 1
a1032 2
void
freeDiag(diagnosticRecord* diag)
d1034 5
a1038 5
  if (diag != NULL) {
    if (diag->ADDINFO != NULL)
	s_free(diag->ADDINFO);
    s_free(diag);
  }
d1045 1
a1045 2
char*
writeDiag(diagnosticRecord* diag, char* buffer, long* len)
d1050 2
a1051 2
  char* buf = buffer;
  long  length;
d1053 2
a1054 2
  if (diag == NULL)		/* handle unspecified optional args */
    return(buf);
d1056 2
a1057 2
  buf = writeTag(DT_DatabaseDiagnosticRecords,buf,len);
  CHECK_FOR_SPACE_LEFT(0,len);
d1059 3
a1061 3
  length = 3;
  if (diag->ADDINFO != NULL)
    length += strlen(diag->ADDINFO);
d1063 4
a1066 3
  if (length >= 0xFFFF )	/* make sure the length is reasonable */
    { length = 0xFFFF - 1;
      diag->ADDINFO[0xFFFF - 3 - 1] = '\0';
d1069 1
a1069 1
  buf = writeBinaryInteger(length,2,buf,len);
d1071 3
a1073 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = diag->DIAG[0];
  buf++;
d1075 3
a1077 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = diag->DIAG[1];
  buf++;
d1079 4
a1082 4
  if (length > 3)
    { CHECK_FOR_SPACE_LEFT(3,len);
      memcpy(buf,diag->ADDINFO,(size_t)length - 3);
      buf += length - 3;
d1085 3
a1087 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = diag->SURROGATE;
  buf++;
d1089 3
a1091 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = END_OF_RECORD;
  buf++;
d1093 1
a1093 1
  return(buf);
d1098 1
a1098 2
char*
readDiag(diagnosticRecord** diag, char* buffer)
d1100 4
a1103 5
  char* buf = buffer;
  diagnosticRecord* d
    = (diagnosticRecord*)s_malloc((size_t)sizeof(diagnosticRecord));
  data_tag tag;
  long len;
d1105 1
a1105 1
  buf = readTag(&tag,buf);
d1107 1
a1107 1
  buf = readBinaryInteger(&len,2,buf);
d1109 3
a1111 3
  d->DIAG[0] = buf[0];
  d->DIAG[1] = buf[1];
  d->DIAG[2] = '\0';
d1113 6
a1118 7
  if (len > 3)
    { d->ADDINFO = (char*)s_malloc((size_t)(len - 3 + 1));
      memcpy(d->ADDINFO,(char*)(buf + 2),(size_t)(len - 3));
      d->ADDINFO[len - 3] = '\0';
    }
  else
    d->ADDINFO = NULL;
d1120 1
a1120 1
  d->SURROGATE = buf[len - 1];
d1122 1
a1122 1
  *diag = d;
d1124 1
a1124 1
  return(buf + len + 1);
d1133 1
a1133 2
char*
writeCompressedInteger(unsigned long num, char* buf, long* len)
d1138 3
a1140 3
  char byte;
  unsigned long i;
  unsigned long size;
d1142 2
a1143 2
  size = writtenCompressedIntSize(num);
  CHECK_FOR_SPACE_LEFT(size,len);
d1145 6
a1150 6
  for (i = size - 1; i != 0; i--)
    { byte = num & dataMask;
      if (i != (size-1))	/* turn on continue bit */
	byte = (char)(byte | continueBit);
      buf[i] = byte;
      num = num >> dataBits;	/* don't and here */
d1153 1
a1153 1
  return(buf + size);
d1158 1
a1158 2
char*
readCompressedInteger(unsigned long *num, char* buf)
d1163 2
a1164 2
  long i = 0;
  unsigned char byte;
d1166 1
a1166 1
  *num = 0;
d1168 4
a1171 4
  do
    { byte = buf[i++];
      *num = *num << dataBits;
      *num += (byte & dataMask);
d1173 1
a1173 1
  while (byte & continueBit);
d1175 1
a1175 1
  return(buf + i);
d1180 1
a1180 1
#define pad	128 /* high bit is set */
d1182 4
a1185 6
char*
writeCompressedIntWithPadding(
unsigned long num,
unsigned long size,
char* buffer,
long* len)
d1191 3
a1193 3
  char* buf = buffer;
  unsigned long needed,padding;
  long i;
d1195 1
a1195 1
  CHECK_FOR_SPACE_LEFT(size,len);
d1197 3
a1199 3
  needed = writtenCompressedIntSize(num);
  padding = size - needed;
  i = padding - 1;
d1201 2
a1202 2
  for (i = padding - 1;i >= 0;i--)
    { buf[i] = pad;
d1205 1
a1205 1
  buf = writeCompressedInteger(num,buf + padding,len);
d1207 1
a1207 1
  return(buf);
d1212 1
a1212 2
unsigned long
writtenCompressedIntSize(unsigned long num)
d1217 8
a1224 8
  if (num < CompressedInt1Byte)
    return(1);
  else if (num < CompressedInt2Byte)
    return(2);
  else if (num < CompressedInt3Byte)
    return(3);
  else
    return(4);
d1229 1
a1229 2
char*
writeTag(data_tag tag, char* buf, long* len)
d1232 1
a1232 1
  return(writeCompressedInteger(tag,buf,len));
d1237 1
a1237 2
char*
readTag(data_tag* tag, char* buf)
d1240 1
a1240 1
  return(readCompressedInteger(tag,buf));
d1245 1
a1245 2
unsigned long
writtenTagSize(data_tag tag)
d1247 1
a1247 1
  return(writtenCompressedIntSize(tag));
d1252 1
a1252 2
data_tag
peekTag(char* buf)
d1255 4
a1258 3
  data_tag tag;
  readTag(&tag,buf);
  return(tag);
d1263 1
a1263 2
any*
makeAny(unsigned long size, char* data)
d1265 5
a1269 4
  any* a = (any*)s_malloc((size_t)sizeof(any));
  a->size = size;
  a->bytes = data;
  return(a);
d1274 1
a1274 2
void
freeAny(any* a)
d1279 4
a1282 4
  if (a != NULL)
    { if (a->bytes != NULL)
	s_free(a->bytes);
      s_free(a);
d1288 1
a1288 2
any*
duplicateAny(any* a)
d1290 1
a1290 1
  any* copy = NULL;
d1292 2
a1293 2
  if (a == NULL)
    return(NULL);
d1295 8
a1302 7
  copy = (any*)s_malloc((size_t)sizeof(any));
  copy->size = a->size;
  if (a->bytes == NULL)
    copy->bytes = NULL;
  else
    { copy->bytes = (char*)s_malloc((size_t)copy->size);
      memcpy(copy->bytes,a->bytes,(size_t)copy->size);
d1304 1
a1304 1
  return(copy);
d1309 1
a1309 2
char*
writeAny(any* a, data_tag tag, char* buffer, long* len)
d1312 1
a1312 1
  char* buf = buffer;
d1314 2
a1315 2
  if (a == NULL)		/* handle unspecified optional args */
    return(buf);
d1317 3
a1319 3
  /* write the tags */
  buf = writeTag(tag,buf,len);
  buf = writeCompressedInteger(a->size,buf,len);
d1321 3
a1323 3
  /* write the bytes */
  CHECK_FOR_SPACE_LEFT(a->size,len);
  memcpy(buf,a->bytes,(size_t)a->size);
d1325 1
a1325 1
  return(buf+a->size);
d1330 1
a1330 2

char *readAny(any** anAny, char* buffer)
d1333 3
a1335 3
  char *buf;
  any* a;
  data_tag tag;
d1337 1
d1339 1
d1341 1
a1341 1
a=(any*)s_malloc((size_t)sizeof(any));
d1343 1
a1343 1
  buf=buffer;
d1345 4
a1348 1
  buf = readTag(&tag,buf);
d1350 1
a1350 8
  buf = readCompressedInteger(&a->size,buf);

  /* now simply copy the bytes */
  a->bytes = (char*)s_malloc((size_t)a->size);
  memcpy(a->bytes,buf,(size_t)a->size);
  *anAny = a;

  return(buf+a->size);
d1355 1
a1355 2
unsigned long
writtenAnySize(data_tag tag, any* a)
d1357 1
a1357 1
  unsigned long size;
d1359 2
a1360 2
  if (a == NULL)
    return(0);
d1362 4
a1365 4
  size = writtenTagSize(tag);
  size += writtenCompressedIntSize(a->size);
  size += a->size;
  return(size);
d1370 1
a1370 2
any*
stringToAny(char* s)
d1372 1
a1372 1
  any* a = NULL;
d1374 2
a1375 2
  if (s == NULL)
    return(NULL);
d1377 6
a1382 5
  a = (any*)s_malloc((size_t)sizeof(any));
  a->size = strlen(s);
  a->bytes = (char*)s_malloc((size_t)a->size);
  memcpy(a->bytes,s,(size_t)a->size);
  return(a);
d1387 1
a1387 2
char*
anyToString(any* a)
d1389 1
a1389 1
  char* s = NULL;
d1391 2
a1392 2
  if (a == NULL)
    return(NULL);
d1394 4
a1397 4
  s = s_malloc((size_t)(a->size + 1));
  memcpy(s,a->bytes,(size_t)a->size);
  s[a->size] = '\0';
  return(s);
d1402 1
a1402 2
char*
writeString(char* s, data_tag tag, char* buffer, long* len)
d1409 12
a1420 10
  char* buf = buffer;
  any* data = NULL;
  if (s == NULL)
    return(buffer);		/* handle unused optional item before making an any */
  data = (any*)s_malloc((size_t)sizeof(any));
  data->size = strlen(s);
  data->bytes = s;		/* save a copy here by not using stringToAny() */
  buf = writeAny(data,tag,buf,len);
  s_free(data);			/* don't use freeAny() since it will free s too */
  return(buf);
d1425 1
a1425 2
char*
readString(char** s, char* buffer)
d1432 6
a1437 5
  any* data = NULL;
  char* buf = readAny(&data,buffer);
  *s = anyToString(data);
  freeAny(data);
  return(buf);
d1442 1
a1442 2
unsigned long
writtenStringSize(data_tag tag, char* s)
d1444 1
a1444 1
  unsigned long size;
d1446 2
a1447 2
  if (s == NULL)
   return(0);
d1449 4
a1452 4
  size = writtenTagSize(tag);
  size += writtenCompressedIntSize(size);
  size += strlen(s);
  return(size);
d1457 1
a1457 2
any*
longToAny(long num)
d1460 1
a1460 1
  char s[40];
d1462 1
a1462 1
  sprintf(s,"%ld",num);
d1464 1
a1464 1
  return(stringToAny(s));
d1469 1
a1469 2
long
anyToLong(any* a)
d1472 5
a1476 4
  long num;
  char* str = NULL;
  str = anyToString(a);
  sscanf(str,"%ld",&num);	/* could check the result and return
d1478 2
a1479 2
  s_free(str);
  return(num);
d1486 1
a1486 2
bit_map*
makeBitMap(unsigned long numBits, ...)
d1489 26
a1514 20
  va_list ap;
  unsigned long i,j;
  bit_map* bm = NULL;

  LYva_start(ap,numBits);

  bm = (bit_map*)s_malloc((size_t)sizeof(bit_map));
  bm->size = (unsigned long)(ceil((double)numBits / bitsPerByte));
  bm->bytes = (char*)s_malloc((size_t)bm->size);

  /* fill up the bits */
  for (i = 0; i < bm->size; i++) /* iterate over bytes */
    { char byte = 0;
      for (j = 0; j < bitsPerByte; j++) /* iterate over bits */
	{ if ((i * bitsPerByte + j) < numBits)
	    { boolean bit = false;
	      bit = (boolean)va_arg(ap,boolean);
	      if (bit)
	        { byte = byte | (1 << (bitsPerByte - j - 1));
	        }
d1516 2
a1517 2
	  }
      bm->bytes[i] = byte;
d1520 2
a1521 2
  va_end(ap);
  return(bm);
a1523 1

d1526 1
a1526 2
void
freeBitMap(bit_map* bm)
d1529 2
a1530 2
  s_free(bm->bytes);
  s_free(bm);
d1540 1
a1540 2
boolean
bitAtPos(unsigned long pos, bit_map* bm)
d1542 6
a1547 6
  if (pos > bm->size*bitsPerByte)
    return false;
  else
    return((bm->bytes[(pos / bitsPerByte)] &
	    (0x80>>(pos % bitsPerByte))) ?
	   true : false);
d1552 1
a1552 2
char*
writeBitMap(bit_map* bm, data_tag tag, char* buffer, long* len)
d1555 1
a1555 1
  return(writeAny((any*)bm,tag,buffer,len));
d1560 1
a1560 2
char*
readBitMap(bit_map** bm, char* buffer)
d1564 3
a1566 2
    c = readAny((any**)bm,buffer);
    return(c);
d1571 1
a1571 2
char*
writeByte(unsigned long byte, char* buf, long* len)
d1573 3
a1575 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = byte & 0xFF; /* we really only want the first byte */
  return(buf + 1);
d1580 1
a1580 2
char*
readByte(unsigned char* byte, char* buf)
d1582 2
a1583 2
  *byte = buf[0];
  return(buf + 1);
d1588 1
a1588 2
char*
writeBoolean(boolean flag, char* buf, long* len)
d1590 1
a1590 1
  return(writeByte(flag,buf,len));
d1595 1
a1595 2
char*
readBoolean(boolean* flag, char* buffer)
d1597 5
a1601 4
  unsigned char byte;
  char* buf = readByte(&byte,buffer);
  *flag = (byte == true) ? true : false;
  return(buf);
d1606 1
a1606 2
char*
writePDUType(pdu_type pduType, char* buf, long* len)
d1609 1
a1609 1
  return(writeBinaryInteger((long)pduType,(unsigned long)1,buf,len));
d1614 1
a1614 2
char*
readPDUType(pdu_type* pduType, char* buf)
d1617 1
a1617 1
  return(readBinaryInteger((long*)pduType,(unsigned long)1,buf));
d1622 1
a1622 2
pdu_type
peekPDUType(char* buf)
d1628 4
a1631 3
  pdu_type pdu;
  readPDUType(&pdu,buf + HEADER_LEN);
  return(pdu);
d1636 3
a1638 4
#define BINARY_INTEGER_BYTES	sizeof(long) /* the number of bytes used by
						a "binary integer" */
char*
writeBinaryInteger(long num, unsigned long size, char* buf, long* len)
d1642 2
a1643 2
  long i;
  char byte;
d1645 2
a1646 2
  if (size < 1 || size > BINARY_INTEGER_BYTES)
    return(NULL);		/* error */
d1648 1
a1648 1
  CHECK_FOR_SPACE_LEFT(size,len);
d1650 4
a1653 4
  for (i = size - 1; i >= 0; i--)
    { byte = (char)(num & 255);
      buf[i] = byte;
      num = num >> bitsPerByte; /* don't and here */
d1656 1
a1656 1
  return(buf + size);
d1661 1
a1661 2
char*
readBinaryInteger(long* num, unsigned long size, char* buf)
d1665 2
a1666 2
  unsigned long i;
  unsigned char byte;
d1668 3
a1670 3
  if (size < 1 || size > BINARY_INTEGER_BYTES)
    return(buf);		/* error */
  *num = 0;
d1672 4
a1675 4
  for (i = 0; i < size; i++)
    { byte = buf[i];
      *num = *num << bitsPerByte;
      *num += byte;
d1678 1
a1678 1
  return(buf + size);
d1683 1
a1683 2
unsigned long
writtenCompressedBinIntSize(long num)
d1689 10
a1698 10
  if (num < 0L)
    return(4);
  else if (num < 256L)		/* 2**8 */
    return(1);
  else if (num < 65536L)	/* 2**16 */
    return(2);
  else if (num < 16777216L)	/* 2**24 */
    return(3);
  else
    return(4);
d1703 1
a1703 2
char*
writeNum(long num, data_tag tag, char* buffer, long* len)
d1706 2
a1707 2
  char* buf = buffer;
  long size = writtenCompressedBinIntSize(num);
d1709 2
a1710 2
  if (num == UNUSED)
    return(buffer);
d1712 4
a1715 4
  buf = writeTag(tag,buf,len);
  buf = writeCompressedInteger(size,buf,len);
  buf = writeBinaryInteger(num,(unsigned long)size,buf,len);
  return(buf);
d1720 1
a1720 2
char*
readNum(long* num, char* buffer)
d1723 4
a1726 4
  char* buf = buffer;
  data_tag tag;
  unsigned long size;
  unsigned long val;
d1728 5
a1732 5
  buf = readTag(&tag,buf);
  buf = readCompressedInteger(&val,buf);
  size = (unsigned long)val;
  buf = readBinaryInteger(num,size,buf);
  return(buf);
d1737 1
a1737 2
unsigned long
writtenNumSize(data_tag tag, long num)
d1739 2
a1740 2
  long dataSize = writtenCompressedBinIntSize(num);
  long size;
d1742 3
a1744 3
  size = writtenTagSize(tag); /* space for the tag */
  size += writtenCompressedIntSize(dataSize); /* space for the size */
  size += dataSize; /* space for the data */
d1746 1
a1746 1
  return(size);
d1751 1
a1751 1
typedef void (voidfunc)(void *);
d1753 1
a1753 2
void
doList(void** list, voidfunc *func)
d1756 7
a1762 6
  register long i;
  register void* ptr = NULL;
  if (list == NULL)
    return;
  for (i = 0,ptr = list[i]; ptr != NULL; ptr = list[++i])
    (*func)(ptr);
d1767 1
a1767 2
char*
writeProtocolVersion(char* buf, long* len)
d1770 1
a1770 1
  static bit_map* version = NULL;
d1772 3
a1774 3
  if (version == NULL)
   { version = makeBitMap((unsigned long)1,true); /* version 1! */
   }
d1776 1
a1776 1
  return(writeBitMap(version,DT_ProtocolVersion,buf,len));
d1781 1
a1781 2
char*
defaultImplementationID(void)
d1783 3
a1785 2
  static char	ImplementationID[] = "TMC";
  return(ImplementationID);
d1790 1
a1790 2
char*
defaultImplementationName(void)
d1792 3
a1794 2
  static char ImplementationName[] = "Thinking Machines Corporation Z39.50";
  return(ImplementationName);
d1799 1
a1799 2
char*
defaultImplementationVersion(void)
d1801 3
a1803 2
  static char	ImplementationVersion[] = "2.0A";
  return(ImplementationVersion);
a1807 1

d1809 3
a1811 3
**	Routines originally from ZType1.c -- FM
**
**----------------------------------------------------------------------*/
d1813 6
a1818 6
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   3.26.90	Harry Morris, morris@@think.com
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
*/
d1821 7
a1827 9
query_term*
makeAttributeTerm(
char* use,
char* relation,
char* position,
char* structure,
char* truncation,
char* completeness,
any* term)
d1829 1
a1829 1
  query_term* qt = (query_term*)s_malloc((size_t)sizeof(query_term));
d1831 1
a1831 1
  qt->TermType = TT_Attribute;
d1833 7
a1839 7
  /* copy in the attributes */
  strncpy(qt->Use,use,ATTRIBUTE_SIZE);
  strncpy(qt->Relation,relation,ATTRIBUTE_SIZE);
  strncpy(qt->Position,position,ATTRIBUTE_SIZE);
  strncpy(qt->Structure,structure,ATTRIBUTE_SIZE);
  strncpy(qt->Truncation,truncation,ATTRIBUTE_SIZE);
  strncpy(qt->Completeness,completeness,ATTRIBUTE_SIZE);
d1841 1
a1841 1
  qt->Term = duplicateAny(term);
d1843 1
a1843 1
  qt->ResultSetID = NULL;
d1845 1
a1845 1
  return(qt);
d1850 1
a1850 2
query_term*
makeResultSetTerm(any* resultSet)
d1852 1
a1852 1
  query_term* qt = (query_term*)s_malloc((size_t)sizeof(query_term));
d1854 1
a1854 1
  qt->TermType = TT_ResultSetID;
d1856 1
a1856 1
  qt->ResultSetID = duplicateAny(resultSet);
d1858 1
a1858 1
  qt->Term = NULL;
d1860 1
a1860 1
  return(qt);
d1865 1
a1865 2
query_term*
makeOperatorTerm(char* operatorCode)
d1867 1
a1867 1
  query_term* qt = (query_term*)s_malloc((size_t)sizeof(query_term));
d1869 1
a1869 1
  qt->TermType = TT_Operator;
d1871 1
a1871 1
  strncpy(qt->Operator,operatorCode,OPERATOR_SIZE);
d1873 2
a1874 2
  qt->Term = NULL;
  qt->ResultSetID = NULL;
d1876 1
a1876 1
  return(qt);
d1881 1
a1881 2
void
freeTerm(void* param)
d1883 4
a1886 3
  query_term* qt = (query_term*)param;
  switch (qt->TermType)
    { case TT_Attribute:
d1889 1
a1889 1
      case TT_ResultSetID:
d1892 1
a1892 1
      case TT_Operator:
d1895 1
a1895 1
      default:
d1899 2
a1900 2
      }
  s_free(qt);
d1908 1
a1908 2
char*
writeQueryTerm(query_term* qt, char* buffer, long* len)
d1910 2
a1911 2
  char* buf = buffer;
  char attributes[ATTRIBUTE_LIST_SIZE];
d1913 15
a1927 15
  switch (qt->TermType)
    { case TT_Attribute:
	strncpy(attributes,qt->Use,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Relation,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Position,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Structure,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Truncation,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Completeness,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	buf = writeString(attributes,DT_AttributeList,buf,len);
	buf = writeAny(qt->Term,DT_Term,buf,len);
d1929 2
a1930 2
      case TT_ResultSetID:
	buf = writeAny(qt->ResultSetID,DT_ResultSetID,buf,len);
d1932 2
a1933 2
      case TT_Operator:
	buf = writeString(qt->Operator,DT_Operator,buf,len);
d1935 1
a1935 1
      default:
d1939 1
a1939 1
      }
d1941 1
a1941 1
  return(buf);
d1946 29
a1974 31
char*
readQueryTerm(query_term** qt, char* buffer)
{
  char* buf = buffer;
  char  *attributeList = NULL;
  char* operator = NULL;
  any*  term;
  char* use = NULL;
  char* relation = NULL;
  char* position = NULL;
  char* structure = NULL;
  char* truncation = NULL;
  char* completeness;
  any*	resultSetID = NULL;
  data_tag tag;


  tag = peekTag(buffer);

  switch(tag)
    { case DT_AttributeList:
	buf = readString(&attributeList,buf);
	buf = readAny(&term,buf);
	use = strtok(attributeList,AT_DELIMITER);
	relation = strtok(NULL,AT_DELIMITER);
	position = strtok(NULL,AT_DELIMITER);
	structure = strtok(NULL,AT_DELIMITER);
	truncation = strtok(NULL,AT_DELIMITER);
	completeness = strtok(NULL,AT_DELIMITER);
	*qt = makeAttributeTerm(use,relation,position,structure,
				truncation,completeness,term);
d1978 2
a1979 2
      case DT_ResultSetID:
	buf = readAny(&resultSetID,buf);
d1983 2
a1984 2
      case DT_Operator:
	buf = readString(&operator,buf);
d1988 1
a1988 1
      default:
d1991 1
a1991 1
      }
d1993 1
a1993 1
  return(buf);
d1998 1
a1998 1
static unsigned long getQueryTermSize (query_term* qt);
d2000 1
a2000 2
static unsigned long
getQueryTermSize(query_term* qt)
d2003 10
a2012 9
  unsigned long size = 0;
  static char attributes[] = "11 22 33 44 55 66"; /* we just need this to
						     calculate its written
						     size */

  switch (qt->TermType)
    { case TT_Attribute:
	size = writtenStringSize(DT_AttributeList,attributes);
	size += writtenAnySize(DT_Term,qt->Term);
d2014 2
a2015 2
      case TT_ResultSetID:
	size = writtenAnySize(DT_ResultSetID,qt->ResultSetID);
d2017 2
a2018 2
      case TT_Operator:
	size = writtenStringSize(DT_Operator,qt->Operator);
d2020 1
a2020 1
      default:
d2024 1
a2024 1
      }
d2026 1
a2026 1
  return(size);
d2035 1
a2035 2
any*
writeQuery(query_term** terms)
d2037 7
a2043 7
  any* info = NULL;
  char* writePos = NULL;
  char* data = NULL;
  unsigned long size = 0;
  long remaining = 0;
  long i;
  query_term* qt = NULL;
d2045 2
a2046 2
  if (terms == NULL)
    return(NULL);
d2048 3
a2050 3
  /* calculate the size of write buffer */
  for (i = 0,qt = terms[i]; qt != NULL; qt = terms[++i])
    size += getQueryTermSize(qt);
d2052 1
a2052 1
  data = (char*)s_malloc((size_t)size);
d2054 5
a2058 5
  /* write the terms */
  writePos = data;
  remaining = size;
  for (i = 0,qt = terms[i]; qt != NULL; qt = terms[++i])
    writePos = writeQueryTerm(qt,writePos,&remaining);
d2060 1
a2060 1
  info = makeAny(size,data);
d2062 1
a2062 1
  return(info);
d2067 1
a2067 2
query_term**
readQuery(any *info)
d2069 5
a2073 5
  char* readPos = info->bytes;
  query_term** terms = NULL;
  query_term* qt = NULL;
  long numTerms = 0L;
  char tmp[100];
d2075 2
a2076 2
  sprintf(tmp,"readquery: bytes: %ld",info->size);
  log_write(tmp);
d2078 2
a2079 2
  while (readPos < info->bytes + info->size)
    { readPos = readQueryTerm(&qt,readPos);
d2081 7
a2087 2
      if (terms == NULL)
	{ terms = (query_term**)s_malloc((size_t)(sizeof(query_term*)*2));
d2089 4
a2092 9
      else
	{ terms =
	    (query_term**)s_realloc((char*)terms,
				    (size_t)(sizeof(query_term*)*(numTerms+2)));
	  }
      if (qt == NULL)
	log_write("qt = null");
      terms[numTerms++] = qt;
      terms[numTerms] = NULL;
d2095 1
a2095 1
  return(terms);
a2099 1

d2101 3
a2103 3
**	Routines originally from panic.c -- FM
**
**----------------------------------------------------------------------*/
d2105 5
a2109 5
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   Morris@@think.com
*/
d2118 1
a2118 1
static void exitAction (long error);
d2120 1
a2120 2
static void
exitAction(long error GCC_UNUSED)
d2122 4
a2125 4
  long i;
  for (i = 0; i < 100000; i++)
    ;
  exit(0);
d2132 1
a2132 2
void
panic(char *format, ...)
d2134 1
a2134 1
  va_list ap;			/* the variable arguments */
d2136 5
a2140 5
  fprintf(stderr,PANIC_HEADER);
  LYva_start(ap, format);	/* init ap */
  vfprintf(stderr,format,ap);	/* print the contents */
  va_end(ap);			/* free ap */
  fflush(stderr);
d2142 1
a2142 1
  exitAction(0);
a2146 1

d2148 3
a2150 3
**	Routines originally from cutil.c -- FM
**
**----------------------------------------------------------------------*/
d2152 6
a2157 6
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   3.26.90	Harry Morris, morris@@think.com
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
*/
d2161 1
a2161 2
void
fs_checkPtr(void* ptr)
d2164 2
a2165 2
  if (ptr == NULL)
    panic("checkPtr found a NULL pointer");
d2170 1
a2170 2
void*
fs_malloc(size_t size)
d2173 1
a2173 1
  register void* ptr = NULL;
d2175 2
a2176 2
  ptr = (void*)calloc((size_t)size,(size_t)1);
  s_checkPtr(ptr);
d2178 1
a2178 1
  return(ptr);
d2183 1
a2183 2
void*
fs_realloc(void* ptr, size_t size)
d2189 1
a2189 1
  register void* nptr = NULL;
d2191 2
a2192 2
  if (ptr == NULL)		/* this is really a malloc */
    return(s_malloc(size));
d2194 2
a2195 2
  nptr = (void*)realloc(ptr,size);
  s_checkPtr(ptr);
d2197 1
a2197 1
  return(nptr);
d2202 1
a2202 2
void
fs_free(void* ptr)
d2205 1
a2205 1
  if (ptr != NULL)		/* some non-ansi compilers/os's cant handle freeing null */
d2207 2
a2208 2
      free(ptr);
      ptr = NULL;
d2214 1
a2214 2
char*
s_strdup(char* s)
d2221 5
a2225 2
  unsigned long len;
  char* copy = NULL;
d2227 2
a2228 2
  if (s == NULL)		/* saftey check to postpone stupid errors */
    return(NULL);
d2230 2
a2231 4
  len = strlen(s);		/* length of string - terminator */
  copy = (char*)s_malloc((size_t)(sizeof(char)*(len + 1)));
  strncpy(copy,s,len + 1);
  return(copy);
d2236 1
a2236 2
char*
fs_strncat(char* dst, char* src, size_t maxToAdd, size_t maxTotal)
d2242 2
a2243 2
  size_t dstSize = strlen(dst);
  size_t srcSize = strlen(src);
d2245 11
a2255 10
  if (dstSize + srcSize < maxTotal) /* use regular old strncat */
    return(strncat(dst,src,maxToAdd));
  else
    { size_t truncateTo = maxTotal - dstSize - 1;
      char   saveChar = src[truncateTo];
      char*  result = NULL;
      src[truncateTo] = '\0';
      result = strncat(dst,src,maxToAdd);
      src[truncateTo] = saveChar;
      return(result);
d2263 4
a2266 3
  unsigned char ch = long_ch & 0xFF; /* just want one byte */
  /* when ansi is the way of the world, this can be tolower */
  return (((ch >= 'A') && (ch <= 'Z')) ? (ch + 'a' -'A') : ch);
d2271 7
a2277 6
  long i = 0;
  while(word[i] != '\0'){
    word[i] = char_downcase((unsigned long)word[i]);
    i++;
  }
  return(word);
d2281 1
a2281 1

@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d179 1
a179 1
PRIVATE long read_from_stream(int d, char *buf, long nbytes)
d206 1
a206 1
PRIVATE long
d334 1
a334 1
PRIVATE char *delete_seeker_codes(char *string, long *length)
d1958 1
a1958 1
static unsigned long getQueryTermSize PARAMS((query_term* qt));
d2081 1
a2081 1
static void exitAction PARAMS((long error));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d699 3
a701 3
#define DB_DELIMITER 	"\037" 	/* hex 1F occurs between each database name */
#define ES_DELIMITER_1 	"\037" 	/* separates database name from element name */
#define ES_DELIMITER_2 	"\036" 	/* hex 1E separates <db,es> groups from one another */
d914 3
a916 3
   				- writeCompressedIntegerWithPadding() to
                  writeCompressedIntWithPadding()
                - generalized conditional includes (see c-dialect.h)
d1910 1
a1910 1
  any* 	term;
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d43 1
a43 1
#undef MAXINT	/* we don't need it here, and tcp.h may conflict */
d223 1
a223 1
   		  (int)( request_length +HEADER_LENGTH)) )
d653 3
a655 3
  if (databases != NULL)
    { for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i])
	{ if (query->DatabaseNames == NULL)
d662 2
a663 2
	  }
      }
d666 3
a668 3
  if (elements != NULL)
    { for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i])
	{ if (query->ElementSetNames == NULL)
d720 3
a722 3
  if (query->DatabaseNames != NULL)
    { for (i = 0,scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL; ptr = query->DatabaseNames[++i])
	{ if (scratch == NULL)
d730 1
a730 1
	  }
d736 4
a739 4
  if (query->ElementSetNames != NULL)
    { for (i = 0,scratch = NULL, ptr = query->ElementSetNames[i]; ptr != NULL; ptr = query->ElementSetNames[++i])
	{ if (scratch == NULL)
	    { if (query->ElementSetNames[i+1] == NULL) /* there is a single element set name */
d752 1
a752 1
	      }
d956 2
a957 2
  if (diag != NULL)
    { if (diag->ADDINFO != NULL)
d959 2
a960 2
	s_free(diag);
      }
d2035 1
a2035 1
char tmp[100];
d2037 2
a2038 2
sprintf(tmp,"readquery: bytes: %ld",info->size);
log_write(tmp);
d2051 1
a2051 1
if(qt==NULL)
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 6
a7 6
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	30-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/
d10 3
a12 3
 *	Routines originally from UI.c -- FM
 *
 *----------------------------------------------------------------------*/
d14 5
a18 5
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Brewster@@think.com
 */
a38 2

#ifdef VMS
d43 1
a43 1
#undef MAXINT			/* we don't need it here, and www_tcp.h may conflict */
d49 2
a50 1
void log_write(char *s GCC_UNUSED)
d60 45
a104 45
char *generate_search_apdu(char *buff,	/* buffer to hold the apdu */
			   long *buff_len,	/* length of the buffer changed to reflect new data written */
			   char *seed_words,	/* string of the seed words */
			   char *database_name,
			   DocObj **docobjs,
			   long maxDocsRetrieved)
{
    /* local variables */

    SearchAPDU *search3;
    char *end_ptr;
    static char *database_names[2] =
    {"", 0};
    any refID;
    WAISSearch *query;

    refID.size = 1;
    refID.bytes = "3";

    database_names[0] = database_name;
    query = makeWAISSearch(seed_words,
			   docobjs,	/* DocObjsPtr */
			   0,
			   1,	/* DateFactor */
			   0,	/* BeginDateRange */
			   0,	/* EndDateRange */
			   maxDocsRetrieved
	);

    search3 = makeSearchAPDU(30,
			     5000,	/* should be large */
			     30,
			     1,	/* replace indicator */
			     "",	/* result set name */
			     database_names,	/* database name */
			     QT_RelevanceFeedbackQuery,		/* query_type */
			     0,	/* element name */
			     NULL,	/* reference ID */
			     query);

    end_ptr = writeSearchAPDU(search3, buff, buff_len);

    CSTFreeWAISSearch(query);
    freeSearchAPDU(search3);
    return (end_ptr);
d113 57
a169 55
char *generate_retrieval_apdu(char *buff,
			      long *buff_len,	/* length of the buffer changed to reflect new data written */
			      any *docID,
			      long chunk_type,
			      long start,
			      long end,
			      char *type,
			      char *database_name)
{
    SearchAPDU *search;
    char *end_ptr;

    static char *database_names[2];
    static char *element_names[3];
    any refID;

    DocObj *DocObjs[2];
    any *query;			/* changed from char* by brewster */

    if (NULL == type)
	type = s_strdup("TEXT");

    database_names[0] = database_name;
    database_names[1] = NULL;

    element_names[0] = " ";
    element_names[1] = ES_DocumentText;
    element_names[2] = NULL;

    refID.size = 1;
    refID.bytes = "3";

    switch (chunk_type) {
    case CT_line:
	DocObjs[0] = makeDocObjUsingLines(docID, type, start, end);
	break;
    case CT_byte:
	DocObjs[0] = makeDocObjUsingBytes(docID, type, start, end);
	break;
    }
    DocObjs[1] = NULL;

    query = makeWAISTextQuery(DocObjs);
    search = makeSearchAPDU(10, 16, 15,
			    1,	/* replace indicator */
			    "FOO",	/* result set name */
			    database_names,	/* database name */
			    QT_TextRetrievalQuery,	/* query_type */
			    element_names,	/* element name */
			    &refID,	/* reference ID */
			    query);
    end_ptr = writeSearchAPDU(search, buff, buff_len);
    CSTFreeWAISTextQuery(query);
    freeSearchAPDU(search);
    return (end_ptr);
d179 1
a179 1
static long read_from_stream(int d, char *buf, long nbytes)
d181 19
a199 19
    long didRead;
    long toRead = nbytes;
    long totalRead = 0;		/* paranoia */

    while (toRead > 0) {
	didRead = NETREAD(d, buf, (int) toRead);
	if (didRead == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
	if (didRead == -1)	/* error */
	    return (-1);
	if (didRead == 0)	/* eof */
	    return (-2);	/* maybe this should return 0? */
	toRead -= didRead;
	buf += didRead;
	totalRead += didRead;
    }
    if (totalRead != nbytes)	/* we overread for some reason */
	return (-totalRead);	/* bad news */
    return (totalRead);
d206 19
a224 16
static long transport_message(long connection,
			      char *request_message,
			      long request_length,
			      char *response_message,
			      long response_buffer_length)
{
    WAISMessage header;
    long response_length;
    int rv;

    /* Write out message.  Read back header.  Figure out response length. */

    if (request_length + HEADER_LENGTH !=
	NETWRITE(connection, request_message,
		 (int) (request_length + HEADER_LENGTH)))
	return 0;
d226 1
a226 1
    /* read for the first '0' */
d228 36
a263 2
    while (1) {
	rv = read_from_stream(connection, response_message, 1);
d265 1
a265 1
	    return HT_INTERRUPTED;
d267 13
a279 49
	    return 0;
	if ('0' == response_message[0])
	    break;
    }

    rv = read_from_stream(connection, response_message + 1, HEADER_LENGTH - 1);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;

    readWAISPacketHeader(response_message, &header);
    {
	char length_array[11];

	strncpy(length_array, header.msg_len, 10);
	length_array[10] = '\0';
	response_length = atol(length_array);
	/*
	   if(verbose){
	   printf("WAIS header: '%s' length_array: '%s'\n",
	   response_message, length_array);
	   }
	 */
	if (response_length > response_buffer_length) {
	    /* we got a message that is too long, therefore empty the message out,
	       and return 0 */
	    long i;

	    for (i = 0; i < response_length; i++) {
		rv = read_from_stream(connection,
				      response_message + HEADER_LENGTH,
				      1);
		if (rv == HT_INTERRUPTED)
		    return HT_INTERRUPTED;
		if (rv < 0)
		    return 0;
	    }
	    return (0);
	}
    }
    rv = read_from_stream(connection,
			  response_message + HEADER_LENGTH,
			  response_length);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;
    return (response_length);
d285 41
a325 38
long interpret_message(char *request_message,
		       long request_length,	/* length of the buffer */
		       char *response_message,
		       long response_buffer_length,
		       long connection,
		       boolean verbose GCC_UNUSED)
{
    long response_length;

    /* ?
       if(verbose){
       printf ("sending");
       if(hostname_internal && strlen(hostname_internal) > 0)
       printf(" to host %s", hostname_internal);
       if(service_name && strlen(service_name) > 0)
       printf(" for service %s", service_name);
       printf("\n");
       twais_dsply_rsp_apdu(request_message + HEADER_LENGTH,
       request_length);
       }

     */

    writeWAISPacketHeader(request_message,
			  request_length,
			  (long) 'z',	/* Z39.50 */
			  "wais      ",		/* server name */
			  (long) NO_COMPRESSION,	/* no compression */
			  (long) NO_ENCODING, (long) HEADER_VERSION);
    if (connection != 0) {
	response_length = transport_message(connection, request_message,
					    request_length,
					    response_message,
					    response_buffer_length);
	if (response_length == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
    } else
	return (0);
d327 1
a327 1
    return (response_length);
d334 1
a334 1
static char *delete_seeker_codes(char *string, long *length)
d336 10
a345 14
    long original_count;	/* index into the original string */
    long new_count = 0;		/* index into the collapsed string */

    for (original_count = 0; original_count < *length; original_count++) {
	if (27 == string[original_count]) {
	    /* then we have an escape code */
	    /* if the next letter is '(' or ')', then ignore two letters */
	    if ('(' == string[original_count + 1] ||
		')' == string[original_count + 1])
		original_count += 1;	/* it is a term marker */
	    else
		original_count += 4;	/* it is a paragraph marker */
	} else
	    string[new_count++] = string[original_count];
d347 4
a350 2
    *length = new_count;
    return (string);
d355 1
a355 1
#if defined(VMS) && defined(__GNUC__)	/* 10-AUG-1995 [pr] */
d368 1
a368 2
static __const void *__const ctype_dummy[] =
{&_ctype_, &ctype_dummy};
d374 18
a391 19
    long length = strlen(headline) + 1;		/* include the trailing null */
    size_t i;

    headline = delete_seeker_codes(headline, &length);
    /* delete leading spaces */
    for (i = 0; i < strlen(headline); i++) {
	if (isprint(headline[i])) {
	    break;
	}
    }
    headline = headline + i;
    /* delete trailing stuff */
    for (i = strlen(headline) - 1; i > 0; i--) {
	if (isprint(headline[i])) {
	    break;
	}
	headline[i] = '\0';
    }
    return (headline);
d396 1
d398 3
a400 3
 *	Routines originally from ZProt.c -- FM
 *
 *----------------------------------------------------------------------*/
d402 7
a408 7
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
d419 16
a434 14
InitResponseAPDU *makeInitResponseAPDU(boolean result,
				       boolean search,
				       boolean present,
				       boolean deleteIt,
				       boolean accessControl,
				       boolean resourceControl,
				       long prefSize,
				       long maxMsgSize,
				       char *auth,
				       char *id,
				       char *name,
				       char *version,
				       any *refID,
				       void *userInfo)
d437 1
a437 1
    InitResponseAPDU *init = (InitResponseAPDU *) s_malloc((size_t) sizeof(InitResponseAPDU));
d439 15
a453 15
    init->PDUType = initResponseAPDU;
    init->Result = result;
    init->willSearch = search;
    init->willPresent = present;
    init->willDelete = deleteIt;
    init->supportAccessControl = accessControl;
    init->supportResourceControl = resourceControl;
    init->PreferredMessageSize = prefSize;
    init->MaximumRecordSize = maxMsgSize;
    init->IDAuthentication = s_strdup(auth);
    init->ImplementationID = s_strdup(id);
    init->ImplementationName = s_strdup(name);
    init->ImplementationVersion = s_strdup(version);
    init->ReferenceID = duplicateAny(refID);
    init->UserInformationField = userInfo;	/* not copied! */
d455 1
a455 1
    return (init);
d460 2
a461 1
void freeInitResponseAPDU(InitResponseAPDU *init)
d464 6
a469 6
    s_free(init->IDAuthentication);
    s_free(init->ImplementationID);
    s_free(init->ImplementationName);
    s_free(init->ImplementationVersion);
    freeAny(init->ReferenceID);
    s_free(init);
d474 2
a475 1
char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len)
d478 77
a554 98
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;
    bit_map *optionsBM = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(init->PDUType, buf, len);
    buf = writeBoolean(init->Result, buf, len);
    buf = writeProtocolVersion(buf, len);

    optionsBM = makeBitMap((unsigned long) 5, init->willSearch, init->willPresent,
			   init->willDelete, init->supportAccessControl,
			   init->supportResourceControl);
    buf = writeBitMap(optionsBM, DT_Options, buf, len);
    freeBitMap(optionsBM);

    buf = writeNum(init->PreferredMessageSize,
		   DT_PreferredMessageSize,
		   buf,
		   len);
    buf = writeNum(init->MaximumRecordSize,
		   DT_MaximumRecordSize,
		   buf,
		   len);
    buf = writeString(init->IDAuthentication,
		      DT_IDAuthentication,
		      buf,
		      len);
    buf = writeString(init->ImplementationID,
		      DT_ImplementationID,
		      buf,
		      len);
    buf = writeString(init->ImplementationName,
		      DT_ImplementationName,
		      buf,
		      len);
    buf = writeString(init->ImplementationVersion,
		      DT_ImplementationVersion,
		      buf,
		      len);
    buf = writeAny(init->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (init->UserInformationField != NULL)
	buf = writeInitResponseInfo(init, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer)
{
    char *buf = buffer;
    boolean search, present, delete, accessControl, resourceControl;
    long prefSize, maxMsgSize;
    char *auth, *id, *name, *version;
    long size;
    pdu_type pduType;
    bit_map *versionBM = NULL;
    bit_map *optionsBM = NULL;
    boolean result;
    any *refID = NULL;
    void *userInfo = NULL;

    auth = id = name = version = NULL;
    refID = NULL;

    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBoolean(&result, buf);
    buf = readBitMap(&versionBM, buf);
    buf = readBitMap(&optionsBM, buf);
    buf = readNum(&prefSize, buf);
    buf = readNum(&maxMsgSize, buf);

    /* decode optionsBM */
    search = bitAtPos(0, optionsBM);
    present = bitAtPos(1, optionsBM);
    delete = bitAtPos(2, optionsBM);
    accessControl = bitAtPos(3, optionsBM);
    resourceControl = bitAtPos(4, optionsBM);

    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_IDAuthentication:
	    buf = readString(&auth, buf);
d556 2
a557 2
	case DT_ImplementationID:
	    buf = readString(&id, buf);
d559 2
a560 2
	case DT_ImplementationName:
	    buf = readString(&name, buf);
d562 2
a563 2
	case DT_ImplementationVersion:
	    buf = readString(&version, buf);
d565 2
a566 2
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
d568 1
a568 1
	default:
d578 12
a589 1
	}
d591 6
d598 7
a604 35
    buf = readInitResponseInfo(&userInfo, buf);
    if (buf == NULL) {
	freeBitMap(versionBM);
	freeBitMap(optionsBM);
	s_free(auth);
	s_free(id);
	s_free(name);
	s_free(version);
	freeAny(refID);
    }
    RETURN_ON_NULL(buf);

    /* construct the basic init object */
    *init = makeInitResponseAPDU(result,
				 search,
				 present,
				 delete,
				 accessControl,
				 resourceControl,
				 prefSize,
				 maxMsgSize,
				 auth,
				 id,
				 name,
				 version,
				 refID,
				 userInfo);

    freeBitMap(versionBM);
    freeBitMap(optionsBM);
    s_free(auth);
    s_free(id);
    s_free(name);
    s_free(version);
    freeAny(refID);
d606 1
a606 1
    return (buf);
d611 2
a612 1
InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo)
d617 9
a625 17
    InitResponseAPDU *initResp;

    initResp = makeInitResponseAPDU(result,
				    init->willSearch,
				    init->willPresent,
				    init->willDelete,
				    init->supportAccessControl,
				    init->supportResourceControl,
				    init->PreferredMessageSize,
				    init->MaximumRecordSize,
				    init->IDAuthentication,
				    defaultImplementationID(),
				    defaultImplementationName(),
				    defaultImplementationVersion(),
				    init->ReferenceID,
				    userInfo);
    return (initResp);
d630 30
a659 35
SearchAPDU *makeSearchAPDU(long small,
			   long large,
			   long medium,
			   boolean replace,
			   char *name,
			   char **databases,
			   char *type,
			   char **elements,
			   any *refID,
			   void *queryInfo)
{
    char *ptr = NULL;
    long i;
    SearchAPDU *query = (SearchAPDU *) s_malloc((size_t) sizeof(SearchAPDU));

    query->PDUType = searchAPDU;
    query->SmallSetUpperBound = small;
    query->LargeSetLowerBound = large;
    query->MediumSetPresentNumber = medium;
    query->ReplaceIndicator = replace;
    query->ResultSetName = s_strdup(name);
    query->DatabaseNames = NULL;
    if (databases != NULL) {
	for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	    if (query->DatabaseNames == NULL)
		query->DatabaseNames = (char **) s_malloc((size_t) (sizeof(char
									   *)
								    * 2));

	    else
		query->DatabaseNames = (char **) s_realloc((char *) query->DatabaseNames,
							   (size_t) (sizeof(char
									    *) *
								       (i + 2)));

d661 12
a672 17
	    query->DatabaseNames[i + 1] = NULL;
	}
    }
    query->QueryType = s_strdup(type);
    query->ElementSetNames = NULL;
    if (elements != NULL) {
	for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	    if (query->ElementSetNames == NULL)
		query->ElementSetNames =
		    (char **) s_malloc((size_t) (sizeof(char *) * 2));

	    else
		query->ElementSetNames = (char **) s_realloc((char *) query->ElementSetNames,
							     (size_t) (sizeof(char
									      *) *
								         (i + 2)));

d674 6
a679 6
	    query->ElementSetNames[i + 1] = NULL;
	}
    }
    query->ReferenceID = duplicateAny(refID);
    query->Query = queryInfo;	/* not copied! */
    return (query);
d684 11
a694 10
void freeSearchAPDU(SearchAPDU *query)
{
    s_free(query->ResultSetName);
    s_free(query->QueryType);
    doList((void **) query->DatabaseNames, fs_free);	/* can't use the macro here ! */
    s_free(query->DatabaseNames);
    doList((void **) query->ElementSetNames, fs_free);	/* can't use the macro here ! */
    s_free(query->ElementSetNames);
    freeAny(query->ReferenceID);
    s_free(query);
d699 33
a731 35
#define DB_DELIMITER	"\037"	/* hex 1F occurs between each database name */
#define ES_DELIMITER_1	"\037"	/* separates database name from element name */
#define ES_DELIMITER_2	"\036"	/* hex 1E separates <db,es> groups from one another */

char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len)
{
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size, i;
    char *ptr = NULL;
    char *scratch = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(query->PDUType, buf, len);
    buf = writeBinaryInteger(query->SmallSetUpperBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->LargeSetLowerBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->MediumSetPresentNumber, (size_t) 3, buf, len);
    buf = writeBoolean(query->ReplaceIndicator, buf, len);
    buf = writeString(query->ResultSetName, DT_ResultSetName, buf, len);
    /* write database names */
    if (query->DatabaseNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL;
	     ptr = query->DatabaseNames[++i]) {
	    if (scratch == NULL)
		scratch = s_strdup(ptr);
	    else {
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) + 2);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, DB_DELIMITER, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
	    }
	}
	buf = writeString(scratch, DT_DatabaseNames, buf, len);
d733 10
a742 24
    }
    buf = writeString(query->QueryType, DT_QueryType, buf, len);
    /* write element set names */
    if (query->ElementSetNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->ElementSetNames[i];
	     ptr != NULL;
	     ptr = query->ElementSetNames[++i]) {
	    if (scratch == NULL) {
		if (query->ElementSetNames[i + 1] == NULL)	/* there is a single element set name */
		{
		    scratch = (char *) s_malloc((size_t) strlen(ptr) + 2);
		    strncpy(scratch, ES_DELIMITER_1, 2);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, strlen(ptr) + 2);
		} else {	/* this is the first of a series of element set names */
		    size_t newScratchSize = (size_t) (strlen(ptr) +
						      strlen(query->ElementSetNames[i
										    + 1])
						      + 2);

		    scratch = s_strdup(ptr);	/* the database name */
		    ptr = query->ElementSetNames[++i];	/* the element set name */
		    scratch = (char *) s_realloc(scratch, newScratchSize);
		    s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
d744 20
a763 15
	    } else {
		char *esPtr = query->ElementSetNames[++i];	/* the element set name */
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) +
						  strlen(esPtr) +
						  3);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_2, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		s_strncat(scratch, esPtr, strlen(esPtr) + 1, newScratchSize);
	    }
	}
	buf = writeString(scratch, DT_ElementSetNames, buf, len);
d765 2
a766 2
    }
    buf = writeAny(query->ReferenceID, DT_ReferenceID, buf, len);
d768 4
a771 4
    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);
d773 2
a774 2
    if (query->Query != NULL)
	buf = writeSearchInfo(query, buf, len);
d776 1
a776 1
    return (buf);
d781 10
a790 8
SearchResponseAPDU *makeSearchResponseAPDU(long result,
					   long count,
					   long recordsReturned,
					   long nextPos,
					   long resultStatus,
					   long presentStatus,
					   any *refID,
					   void *records)
d792 11
a802 13
    SearchResponseAPDU *query =
    (SearchResponseAPDU *) s_malloc((size_t) sizeof(SearchResponseAPDU));

    query->PDUType = searchResponseAPDU;
    query->SearchStatus = result;
    query->ResultCount = count;
    query->NumberOfRecordsReturned = recordsReturned;
    query->NextResultSetPosition = nextPos;
    query->ResultSetStatus = resultStatus;
    query->PresentStatus = presentStatus;
    query->ReferenceID = duplicateAny(refID);
    query->DatabaseDiagnosticRecords = records;
    return (query);
d807 2
a808 1
void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse)
d810 2
a811 2
    freeAny(queryResponse->ReferenceID);
    s_free(queryResponse);
d816 2
a817 2
char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char *buffer,
			      long *len)
d819 2
a820 2
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;
d822 1
a822 1
    RESERVE_SPACE_FOR_HEADER(len);
d824 8
a831 31
    buf = writePDUType(queryResponse->PDUType,
		       buf,
		       len);
    buf = writeBinaryInteger(queryResponse->SearchStatus,
			     (size_t) 1,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->ResultCount,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NumberOfRecordsReturned,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NextResultSetPosition,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeNum(queryResponse->ResultSetStatus,
		   DT_ResultSetStatus,
		   buf,
		   len);
    buf = writeNum(queryResponse->PresentStatus,
		   DT_PresentStatus,
		   buf,
		   len);
    buf = writeAny(queryResponse->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);
d833 4
a836 4
    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);
d838 2
a839 2
    if (queryResponse->DatabaseDiagnosticRecords != NULL)
	buf = writeSearchResponseInfo(queryResponse, buf, len);
d841 1
a841 1
    return (buf);
d846 2
a847 1
char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer)
d849 7
a855 15
    char *buf = buffer;
    long size;
    pdu_type pduType;
    long result, count, recordsReturned, nextPos;
    long resultStatus, presentStatus;
    any *refID = NULL;
    void *userInfo = NULL;

    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBinaryInteger(&result, (size_t) 1, buf);
    buf = readBinaryInteger(&count, (size_t) 3, buf);
    buf = readBinaryInteger(&recordsReturned, (size_t) 3, buf);
    buf = readBinaryInteger(&nextPos, (size_t) 3, buf);
d857 7
a863 2
    resultStatus = presentStatus = UNUSED;
    refID = NULL;
d865 2
a866 3
    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);
d868 6
a873 3
	switch (tag) {
	case DT_ResultSetStatus:
	    buf = readNum(&resultStatus, buf);
d875 2
a876 2
	case DT_PresentStatus:
	    buf = readNum(&presentStatus, buf);
d878 2
a879 2
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
d881 1
a881 1
	default:
d885 1
a885 1
	}
d888 8
a895 14
    buf = readSearchResponseInfo(&userInfo, buf);
    if (buf == NULL)
	freeAny(refID);
    RETURN_ON_NULL(buf);

    /* construct the search object */
    *queryResponse = makeSearchResponseAPDU(result,
					    count,
					    recordsReturned,
					    nextPos,
					    (long) resultStatus,
					    (long) presentStatus,
					    refID,
					    userInfo);
d897 1
a897 1
    freeAny(refID);
d899 1
a899 1
    return (buf);
d902 1
d904 3
a906 3
 *	Routines originally from ZUtil.c -- FM
 *
 *----------------------------------------------------------------------*/
d908 11
a918 11
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - fixed include file names, changed
 *		- writeCompressedIntegerWithPadding() to
 *		  writeCompressedIntWithPadding()
 *		- generalized conditional includes (see c-dialect.h)
 * 3.7.91   Jonny Goldman.  Replaced "short" in makeBitMap with "int" line 632.
 */
d920 1
a920 1
char *readErrorPosition = NULL;	/* pos where buf stoped making sense */
d938 2
a939 1
diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo)
d941 2
a942 2
    diagnosticRecord *diag =
    (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));
d944 3
a946 3
    diag->SURROGATE = surrogate;
    memcpy(diag->DIAG, code, DIAGNOSTIC_CODE_SIZE);
    diag->ADDINFO = s_strdup(addInfo);
d948 1
a948 1
    return (diag);
d953 2
a954 1
void freeDiag(diagnosticRecord * diag)
d956 3
a958 3
    if (diag != NULL) {
	if (diag->ADDINFO != NULL)
	    s_free(diag->ADDINFO);
d960 1
a960 1
    }
d967 2
a968 1
char *writeDiag(diagnosticRecord * diag, char *buffer, long *len)
d973 2
a974 2
    char *buf = buffer;
    long length;
d976 2
a977 2
    if (diag == NULL)		/* handle unspecified optional args */
	return (buf);
d979 2
a980 2
    buf = writeTag(DT_DatabaseDiagnosticRecords, buf, len);
    CHECK_FOR_SPACE_LEFT(0, len);
d982 3
a984 3
    length = 3;
    if (diag->ADDINFO != NULL)
	length += strlen(diag->ADDINFO);
d986 3
a988 4
    if (length >= 0xFFFF)	/* make sure the length is reasonable */
    {
	length = 0xFFFF - 1;
	diag->ADDINFO[0xFFFF - 3 - 1] = '\0';
d991 1
a991 1
    buf = writeBinaryInteger(length, 2, buf, len);
d993 3
a995 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[0];
    buf++;
d997 3
a999 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[1];
    buf++;
d1001 4
a1004 4
    if (length > 3) {
	CHECK_FOR_SPACE_LEFT(3, len);
	memcpy(buf, diag->ADDINFO, (size_t) length - 3);
	buf += length - 3;
d1007 3
a1009 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->SURROGATE;
    buf++;
d1011 3
a1013 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = END_OF_RECORD;
    buf++;
d1015 1
a1015 1
    return (buf);
d1020 2
a1021 1
char *readDiag(diagnosticRecord ** diag, char *buffer)
d1023 5
a1027 4
    char *buf = buffer;
    diagnosticRecord *d = (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));
    data_tag tag;
    long len;
d1029 1
a1029 1
    buf = readTag(&tag, buf);
d1031 1
a1031 1
    buf = readBinaryInteger(&len, 2, buf);
d1033 3
a1035 3
    d->DIAG[0] = buf[0];
    d->DIAG[1] = buf[1];
    d->DIAG[2] = '\0';
d1037 7
a1043 6
    if (len > 3) {
	d->ADDINFO = (char *) s_malloc((size_t) (len - 3 + 1));
	memcpy(d->ADDINFO, (char *) (buf + 2), (size_t) (len - 3));
	d->ADDINFO[len - 3] = '\0';
    } else
	d->ADDINFO = NULL;
d1045 1
a1045 1
    d->SURROGATE = buf[len - 1];
d1047 1
a1047 1
    *diag = d;
d1049 1
a1049 1
    return (buf + len + 1);
d1058 2
a1059 1
char *writeCompressedInteger(unsigned long num, char *buf, long *len)
d1064 3
a1066 3
    char byte;
    unsigned long i;
    unsigned long size;
d1068 2
a1069 2
    size = writtenCompressedIntSize(num);
    CHECK_FOR_SPACE_LEFT(size, len);
d1071 6
a1076 6
    for (i = size - 1; i != 0; i--) {
	byte = num & dataMask;
	if (i != (size - 1))	/* turn on continue bit */
	    byte = (char) (byte | continueBit);
	buf[i] = byte;
	num = num >> dataBits;	/* don't and here */
d1079 1
a1079 1
    return (buf + size);
d1084 2
a1085 1
char *readCompressedInteger(unsigned long *num, char *buf)
d1090 2
a1091 2
    long i = 0;
    unsigned char byte;
d1093 1
a1093 1
    *num = 0;
d1095 4
a1098 4
    do {
	byte = buf[i++];
	*num = *num << dataBits;
	*num += (byte & dataMask);
d1100 1
a1100 1
    while (byte & continueBit);
d1102 1
a1102 1
    return (buf + i);
d1107 1
a1107 1
#define pad	128		/* high bit is set */
d1109 6
a1114 4
char *writeCompressedIntWithPadding(unsigned long num,
				    unsigned long size,
				    char *buffer,
				    long *len)
d1120 3
a1122 3
    char *buf = buffer;
    unsigned long needed, padding;
    long i;
d1124 1
a1124 1
    CHECK_FOR_SPACE_LEFT(size, len);
d1126 3
a1128 3
    needed = writtenCompressedIntSize(num);
    padding = size - needed;
    i = padding - 1;
d1130 2
a1131 2
    for (i = padding - 1; i >= 0; i--) {
	buf[i] = pad;
d1134 1
a1134 1
    buf = writeCompressedInteger(num, buf + padding, len);
d1136 1
a1136 1
    return (buf);
d1141 2
a1142 1
unsigned long writtenCompressedIntSize(unsigned long num)
d1147 8
a1154 8
    if (num < CompressedInt1Byte)
	return (1);
    else if (num < CompressedInt2Byte)
	return (2);
    else if (num < CompressedInt3Byte)
	return (3);
    else
	return (4);
d1159 2
a1160 1
char *writeTag(data_tag tag, char *buf, long *len)
d1163 1
a1163 1
    return (writeCompressedInteger(tag, buf, len));
d1168 2
a1169 1
char *readTag(data_tag *tag, char *buf)
d1172 1
a1172 1
    return (readCompressedInteger(tag, buf));
d1177 2
a1178 1
unsigned long writtenTagSize(data_tag tag)
d1180 1
a1180 1
    return (writtenCompressedIntSize(tag));
d1185 2
a1186 1
data_tag peekTag(char *buf)
d1189 3
a1191 4
    data_tag tag;

    readTag(&tag, buf);
    return (tag);
d1196 2
a1197 1
any *makeAny(unsigned long size, char *data)
d1199 4
a1202 5
    any *a = (any *) s_malloc((size_t) sizeof(any));

    a->size = size;
    a->bytes = data;
    return (a);
d1207 2
a1208 1
void freeAny(any *a)
d1213 4
a1216 4
    if (a != NULL) {
	if (a->bytes != NULL)
	    s_free(a->bytes);
	s_free(a);
d1222 2
a1223 1
any *duplicateAny(any *a)
d1225 1
a1225 4
    any *copy = NULL;

    if (a == NULL)
	return (NULL);
d1227 2
a1228 1
    copy = (any *) s_malloc((size_t) sizeof(any));
d1230 7
a1236 6
    copy->size = a->size;
    if (a->bytes == NULL)
	copy->bytes = NULL;
    else {
	copy->bytes = (char *) s_malloc((size_t) copy->size);
	memcpy(copy->bytes, a->bytes, (size_t) copy->size);
d1238 1
a1238 1
    return (copy);
d1243 2
a1244 1
char *writeAny(any *a, data_tag tag, char *buffer, long *len)
d1247 1
a1247 1
    char *buf = buffer;
d1249 2
a1250 2
    if (a == NULL)		/* handle unspecified optional args */
	return (buf);
d1252 3
a1254 3
    /* write the tags */
    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(a->size, buf, len);
d1256 3
a1258 3
    /* write the bytes */
    CHECK_FOR_SPACE_LEFT(a->size, len);
    memcpy(buf, a->bytes, (size_t) a->size);
d1260 1
a1260 1
    return (buf + a->size);
d1265 2
a1266 1
char *readAny(any **anAny, char *buffer)
d1269 5
a1273 3
    char *buf;
    any *a;
    data_tag tag;
d1275 1
a1275 1
    a = (any *) s_malloc((size_t) sizeof(any));
d1277 1
a1277 1
    buf = buffer;
d1279 1
a1279 1
    buf = readTag(&tag, buf);
d1281 1
a1281 1
    buf = readCompressedInteger(&a->size, buf);
d1283 4
a1286 4
    /* now simply copy the bytes */
    a->bytes = (char *) s_malloc((size_t) a->size);
    memcpy(a->bytes, buf, (size_t) a->size);
    *anAny = a;
d1288 1
a1288 1
    return (buf + a->size);
d1293 2
a1294 1
unsigned long writtenAnySize(data_tag tag, any *a)
d1296 1
a1296 1
    unsigned long size;
d1298 2
a1299 2
    if (a == NULL)
	return (0);
d1301 4
a1304 4
    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(a->size);
    size += a->size;
    return (size);
d1309 2
a1310 1
any *stringToAny(char *s)
d1312 1
a1312 1
    any *a = NULL;
d1314 2
a1315 2
    if (s == NULL)
	return (NULL);
d1317 5
a1321 6
    a = (any *) s_malloc((size_t) sizeof(any));

    a->size = strlen(s);
    a->bytes = (char *) s_malloc((size_t) a->size);
    memcpy(a->bytes, s, (size_t) a->size);
    return (a);
d1326 2
a1327 1
char *anyToString(any *a)
d1329 1
a1329 1
    char *s = NULL;
d1331 2
a1332 2
    if (a == NULL)
	return (NULL);
d1334 4
a1337 4
    s = s_malloc((size_t) (a->size + 1));
    memcpy(s, a->bytes, (size_t) a->size);
    s[a->size] = '\0';
    return (s);
d1342 2
a1343 1
char *writeString(char *s, data_tag tag, char *buffer, long *len)
d1350 10
a1359 12
    char *buf = buffer;
    any *data = NULL;

    if (s == NULL)
	return (buffer);	/* handle unused optional item before making an any */
    data = (any *) s_malloc((size_t) sizeof(any));

    data->size = strlen(s);
    data->bytes = s;		/* save a copy here by not using stringToAny() */
    buf = writeAny(data, tag, buf, len);
    s_free(data);		/* don't use freeAny() since it will free s too */
    return (buf);
d1364 2
a1365 1
char *readString(char **s, char *buffer)
d1372 5
a1376 6
    any *data = NULL;
    char *buf = readAny(&data, buffer);

    *s = anyToString(data);
    freeAny(data);
    return (buf);
d1381 2
a1382 1
unsigned long writtenStringSize(data_tag tag, char *s)
d1384 1
a1384 1
    unsigned long size;
d1386 2
a1387 2
    if (s == NULL)
	return (0);
d1389 4
a1392 4
    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(size);
    size += strlen(s);
    return (size);
d1397 2
a1398 1
any *longToAny(long num)
d1401 1
a1401 1
    char s[40];
d1403 1
a1403 1
    sprintf(s, "%ld", num);
d1405 1
a1405 1
    return (stringToAny(s));
d1410 2
a1411 1
long anyToLong(any *a)
d1414 4
a1417 5
    long num;
    char *str = NULL;

    str = anyToString(a);
    sscanf(str, "%ld", &num);	/* could check the result and return
d1419 2
a1420 2
    s_free(str);
    return (num);
d1427 2
a1428 1
bit_map *makeBitMap(unsigned long numBits,...)
d1431 20
a1450 26
    va_list ap;
    unsigned long i, j;
    bit_map *bm = NULL;

    LYva_start(ap, numBits);

    bm = (bit_map *) s_malloc((size_t) sizeof(bit_map));

    bm->size = (unsigned long) (ceil((double) numBits / bitsPerByte));
    bm->bytes = (char *) s_malloc((size_t) bm->size);

    /* fill up the bits */
    for (i = 0; i < bm->size; i++)	/* iterate over bytes */
    {
	char byte = 0;

	for (j = 0; j < bitsPerByte; j++)	/* iterate over bits */
	{
	    if ((i * bitsPerByte + j) < numBits) {
		boolean bit = false;

		bit = (boolean) va_arg(ap, boolean);

		if (bit) {
		    byte = byte | (1 << (bitsPerByte - j - 1));
		}
d1452 2
a1453 2
	}
	bm->bytes[i] = byte;
d1456 2
a1457 2
    va_end(ap);
    return (bm);
d1460 1
d1463 2
a1464 1
void freeBitMap(bit_map *bm)
d1467 2
a1468 2
    s_free(bm->bytes);
    s_free(bm);
d1478 2
a1479 1
boolean bitAtPos(unsigned long pos, bit_map *bm)
d1481 6
a1486 6
    if (pos > bm->size * bitsPerByte)
	return false;
    else
	return ((bm->bytes[(pos / bitsPerByte)] &
		 (0x80 >> (pos % bitsPerByte))) ?
		true : false);
d1491 2
a1492 1
char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len)
d1495 1
a1495 1
    return (writeAny((any *) bm, tag, buffer, len));
d1500 2
a1501 1
char *readBitMap(bit_map **bm, char *buffer)
d1505 2
a1506 3

    c = readAny((any **) bm, buffer);
    return (c);
d1511 2
a1512 1
char *writeByte(unsigned long byte, char *buf, long *len)
d1514 3
a1516 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = byte & 0xFF;	/* we really only want the first byte */
    return (buf + 1);
d1521 2
a1522 1
char *readByte(unsigned char *byte, char *buf)
d1524 2
a1525 2
    *byte = buf[0];
    return (buf + 1);
d1530 2
a1531 1
char *writeBoolean(boolean flag, char *buf, long *len)
d1533 1
a1533 1
    return (writeByte(flag, buf, len));
d1538 2
a1539 1
char *readBoolean(boolean *flag, char *buffer)
d1541 4
a1544 5
    unsigned char byte;
    char *buf = readByte(&byte, buffer);

    *flag = (byte == true) ? true : false;
    return (buf);
d1549 2
a1550 1
char *writePDUType(pdu_type pduType, char *buf, long *len)
d1553 1
a1553 1
    return (writeBinaryInteger((long) pduType, (unsigned long) 1, buf, len));
d1558 2
a1559 1
char *readPDUType(pdu_type *pduType, char *buf)
d1562 1
a1562 1
    return (readBinaryInteger((long *) pduType, (unsigned long) 1, buf));
d1567 2
a1568 1
pdu_type peekPDUType(char *buf)
d1574 3
a1576 4
    pdu_type pdu;

    readPDUType(&pdu, buf + HEADER_LEN);
    return (pdu);
d1581 4
a1584 3
#define BINARY_INTEGER_BYTES	sizeof(long)	/* the number of bytes used by
						   a "binary integer" */
char *writeBinaryInteger(long num, unsigned long size, char *buf, long *len)
d1588 2
a1589 2
    long i;
    char byte;
d1591 2
a1592 2
    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (NULL);		/* error */
d1594 1
a1594 1
    CHECK_FOR_SPACE_LEFT(size, len);
d1596 4
a1599 4
    for (i = size - 1; i >= 0; i--) {
	byte = (char) (num & 255);
	buf[i] = byte;
	num = num >> bitsPerByte;	/* don't and here */
d1602 1
a1602 1
    return (buf + size);
d1607 2
a1608 1
char *readBinaryInteger(long *num, unsigned long size, char *buf)
d1612 2
a1613 2
    unsigned long i;
    unsigned char byte;
d1615 3
a1617 3
    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (buf);		/* error */
    *num = 0;
d1619 4
a1622 4
    for (i = 0; i < size; i++) {
	byte = buf[i];
	*num = *num << bitsPerByte;
	*num += byte;
d1625 1
a1625 1
    return (buf + size);
d1630 2
a1631 1
unsigned long writtenCompressedBinIntSize(long num)
d1637 10
a1646 10
    if (num < 0L)
	return (4);
    else if (num < 256L)	/* 2**8 */
	return (1);
    else if (num < 65536L)	/* 2**16 */
	return (2);
    else if (num < 16777216L)	/* 2**24 */
	return (3);
    else
	return (4);
d1651 2
a1652 1
char *writeNum(long num, data_tag tag, char *buffer, long *len)
d1655 2
a1656 2
    char *buf = buffer;
    long size = writtenCompressedBinIntSize(num);
d1658 2
a1659 2
    if (num == UNUSED)
	return (buffer);
d1661 4
a1664 4
    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(size, buf, len);
    buf = writeBinaryInteger(num, (unsigned long) size, buf, len);
    return (buf);
d1669 2
a1670 1
char *readNum(long *num, char *buffer)
d1673 4
a1676 4
    char *buf = buffer;
    data_tag tag;
    unsigned long size;
    unsigned long val;
d1678 5
a1682 5
    buf = readTag(&tag, buf);
    buf = readCompressedInteger(&val, buf);
    size = (unsigned long) val;
    buf = readBinaryInteger(num, size, buf);
    return (buf);
d1687 2
a1688 1
unsigned long writtenNumSize(data_tag tag, long num)
d1690 2
a1691 2
    long dataSize = writtenCompressedBinIntSize(num);
    long size;
d1693 3
a1695 3
    size = writtenTagSize(tag);	/* space for the tag */
    size += writtenCompressedIntSize(dataSize);		/* space for the size */
    size += dataSize;		/* space for the data */
d1697 1
a1697 1
    return (size);
d1702 1
a1702 1
typedef void (voidfunc) (void *);
d1704 2
a1705 1
void doList(void **list, voidfunc * func)
d1708 6
a1713 7
    register long i;
    register void *ptr = NULL;

    if (list == NULL)
	return;
    for (i = 0, ptr = list[i]; ptr != NULL; ptr = list[++i])
	(*func) (ptr);
d1718 2
a1719 1
char *writeProtocolVersion(char *buf, long *len)
d1722 1
a1722 1
    static bit_map *version = NULL;
d1724 3
a1726 3
    if (version == NULL) {
	version = makeBitMap((unsigned long) 1, true);	/* version 1! */
    }
d1728 1
a1728 1
    return (writeBitMap(version, DT_ProtocolVersion, buf, len));
d1733 2
a1734 1
char *defaultImplementationID(void)
d1736 2
a1737 3
    static char ImplementationID[] = "TMC";

    return (ImplementationID);
d1742 2
a1743 1
char *defaultImplementationName(void)
d1745 2
a1746 3
    static char ImplementationName[] = "Thinking Machines Corporation Z39.50";

    return (ImplementationName);
d1751 2
a1752 1
char *defaultImplementationVersion(void)
d1754 2
a1755 3
    static char ImplementationVersion[] = "2.0A";

    return (ImplementationVersion);
d1760 1
d1762 3
a1764 3
 *	Routines originally from ZType1.c -- FM
 *
 *----------------------------------------------------------------------*/
d1766 6
a1771 6
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
d1774 9
a1782 7
query_term *makeAttributeTerm(char *use,
			      char *relation,
			      char *position,
			      char *structure,
			      char *truncation,
			      char *completeness,
			      any *term)
d1784 1
a1784 1
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));
d1786 1
a1786 1
    qt->TermType = TT_Attribute;
d1788 7
a1794 7
    /* copy in the attributes */
    strncpy(qt->Use, use, ATTRIBUTE_SIZE);
    strncpy(qt->Relation, relation, ATTRIBUTE_SIZE);
    strncpy(qt->Position, position, ATTRIBUTE_SIZE);
    strncpy(qt->Structure, structure, ATTRIBUTE_SIZE);
    strncpy(qt->Truncation, truncation, ATTRIBUTE_SIZE);
    strncpy(qt->Completeness, completeness, ATTRIBUTE_SIZE);
d1796 1
a1796 1
    qt->Term = duplicateAny(term);
d1798 1
a1798 1
    qt->ResultSetID = NULL;
d1800 1
a1800 1
    return (qt);
d1805 2
a1806 1
query_term *makeResultSetTerm(any *resultSet)
d1808 1
a1808 1
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));
d1810 1
a1810 1
    qt->TermType = TT_ResultSetID;
d1812 1
a1812 1
    qt->ResultSetID = duplicateAny(resultSet);
d1814 1
a1814 1
    qt->Term = NULL;
d1816 1
a1816 1
    return (qt);
d1821 2
a1822 1
query_term *makeOperatorTerm(char *operatorCode)
d1824 1
a1824 1
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));
d1826 1
a1826 1
    qt->TermType = TT_Operator;
d1828 1
a1828 1
    strncpy(qt->Operator, operatorCode, OPERATOR_SIZE);
d1830 2
a1831 2
    qt->Term = NULL;
    qt->ResultSetID = NULL;
d1833 1
a1833 1
    return (qt);
d1838 2
a1839 1
void freeTerm(void *param)
d1841 3
a1843 4
    query_term *qt = (query_term *) param;

    switch (qt->TermType) {
    case TT_Attribute:
d1846 1
a1846 1
    case TT_ResultSetID:
d1849 1
a1849 1
    case TT_Operator:
d1852 1
a1852 1
    default:
d1856 2
a1857 2
    }
    s_free(qt);
d1865 2
a1866 1
char *writeQueryTerm(query_term *qt, char *buffer, long *len)
d1868 2
a1869 2
    char *buf = buffer;
    char attributes[ATTRIBUTE_LIST_SIZE];
d1871 15
a1885 15
    switch (qt->TermType) {
    case TT_Attribute:
	strncpy(attributes, qt->Use, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Relation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Position, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Structure, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Truncation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Completeness, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	buf = writeString(attributes, DT_AttributeList, buf, len);
	buf = writeAny(qt->Term, DT_Term, buf, len);
d1887 2
a1888 2
    case TT_ResultSetID:
	buf = writeAny(qt->ResultSetID, DT_ResultSetID, buf, len);
d1890 2
a1891 2
    case TT_Operator:
	buf = writeString(qt->Operator, DT_Operator, buf, len);
d1893 1
a1893 1
    default:
d1897 1
a1897 1
    }
d1899 1
a1899 1
    return (buf);
d1904 31
a1934 29
char *readQueryTerm(query_term **qt, char *buffer)
{
    char *buf = buffer;
    char *attributeList = NULL;
    char *operator = NULL;
    any *term;
    char *use = NULL;
    char *relation = NULL;
    char *position = NULL;
    char *structure = NULL;
    char *truncation = NULL;
    char *completeness;
    any *resultSetID = NULL;
    data_tag tag;

    tag = peekTag(buffer);

    switch (tag) {
    case DT_AttributeList:
	buf = readString(&attributeList, buf);
	buf = readAny(&term, buf);
	use = strtok(attributeList, AT_DELIMITER);
	relation = strtok(NULL, AT_DELIMITER);
	position = strtok(NULL, AT_DELIMITER);
	structure = strtok(NULL, AT_DELIMITER);
	truncation = strtok(NULL, AT_DELIMITER);
	completeness = strtok(NULL, AT_DELIMITER);
	*qt = makeAttributeTerm(use, relation, position, structure,
				truncation, completeness, term);
d1938 2
a1939 2
    case DT_ResultSetID:
	buf = readAny(&resultSetID, buf);
d1943 2
a1944 2
    case DT_Operator:
	buf = readString(&operator, buf);
d1948 1
a1948 1
    default:
d1951 1
a1951 1
    }
d1953 1
a1953 1
    return (buf);
d1958 1
a1958 1
static unsigned long getQueryTermSize(query_term *qt);
d1960 2
a1961 1
static unsigned long getQueryTermSize(query_term *qt)
d1964 9
a1972 10
    unsigned long size = 0;
    static char attributes[] = "11 22 33 44 55 66";	/* we just need this to

							   calculate its written
							   size */

    switch (qt->TermType) {
    case TT_Attribute:
	size = writtenStringSize(DT_AttributeList, attributes);
	size += writtenAnySize(DT_Term, qt->Term);
d1974 2
a1975 2
    case TT_ResultSetID:
	size = writtenAnySize(DT_ResultSetID, qt->ResultSetID);
d1977 2
a1978 2
    case TT_Operator:
	size = writtenStringSize(DT_Operator, qt->Operator);
d1980 1
a1980 1
    default:
d1984 1
a1984 1
    }
d1986 1
a1986 1
    return (size);
d1995 2
a1996 1
any *writeQuery(query_term **terms)
d1998 7
a2004 7
    any *info = NULL;
    char *writePos = NULL;
    char *data = NULL;
    unsigned long size = 0;
    long remaining = 0;
    long i;
    query_term *qt = NULL;
d2006 2
a2007 2
    if (terms == NULL)
	return (NULL);
d2009 3
a2011 3
    /* calculate the size of write buffer */
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	size += getQueryTermSize(qt);
d2013 1
a2013 1
    data = (char *) s_malloc((size_t) size);
d2015 5
a2019 5
    /* write the terms */
    writePos = data;
    remaining = size;
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	writePos = writeQueryTerm(qt, writePos, &remaining);
d2021 1
a2021 1
    info = makeAny(size, data);
d2023 1
a2023 1
    return (info);
d2028 2
a2029 1
query_term **readQuery(any *info)
d2031 5
a2035 5
    char *readPos = info->bytes;
    query_term **terms = NULL;
    query_term *qt = NULL;
    long numTerms = 0L;
    char tmp[100];
d2037 2
a2038 2
    sprintf(tmp, "readquery: bytes: %ld", info->size);
    log_write(tmp);
d2040 2
a2041 2
    while (readPos < info->bytes + info->size) {
	readPos = readQueryTerm(&qt, readPos);
d2043 2
a2044 7
	if (terms == NULL) {
	    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 2));
	} else {
	    terms =
		(query_term **) s_realloc((char *) terms,
					  (size_t) (sizeof(query_term *) *
						      (numTerms + 2)));
d2046 9
a2054 4
	if (qt == NULL)
	    log_write("qt = null");
	terms[numTerms++] = qt;
	terms[numTerms] = NULL;
d2057 1
a2057 1
    return (terms);
d2062 1
d2064 3
a2066 3
 *	Routines originally from panic.c -- FM
 *
 *----------------------------------------------------------------------*/
d2068 5
a2072 5
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Morris@@think.com
 */
d2081 1
a2081 1
static void exitAction(long error);
d2083 2
a2084 1
static void exitAction(long error GCC_UNUSED)
d2086 4
a2089 4
    long i;

    for (i = 0; i < 100000; i++) ;
    exit_immediately(0);
d2096 2
a2097 1
void panic(char *format,...)
d2099 1
a2099 1
    va_list ap;			/* the variable arguments */
d2101 5
a2105 5
    fprintf(stderr, PANIC_HEADER);
    LYva_start(ap, format);	/* init ap */
    vfprintf(stderr, format, ap);	/* print the contents */
    va_end(ap);			/* free ap */
    fflush(stderr);
d2107 1
a2107 1
    exitAction(0);
d2112 1
d2114 3
a2116 3
 *	Routines originally from cutil.c -- FM
 *
 *----------------------------------------------------------------------*/
d2118 6
a2123 6
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
d2127 2
a2128 1
void fs_checkPtr(void *ptr)
d2131 2
a2132 2
    if (ptr == NULL)
	panic("checkPtr found a NULL pointer");
d2137 2
a2138 1
void *fs_malloc(size_t size)
d2141 1
a2141 1
    register void *ptr = NULL;
d2143 2
a2144 2
    ptr = (void *) calloc((size_t) size, (size_t) 1);
    s_checkPtr(ptr);
d2146 1
a2146 1
    return (ptr);
d2151 2
a2152 1
void *fs_realloc(void *ptr, size_t size)
d2158 1
a2158 1
    register void *nptr = NULL;
d2160 2
a2161 2
    if (ptr == NULL)		/* this is really a malloc */
	return (s_malloc(size));
d2163 2
a2164 2
    nptr = (void *) realloc(ptr, size);
    s_checkPtr(ptr);
d2166 1
a2166 1
    return (nptr);
d2171 2
a2172 1
void fs_free(void *ptr)
d2175 1
a2175 1
    if (ptr != NULL)		/* some non-ansi compilers/os's cant handle freeing null */
d2177 2
a2178 2
	free(ptr);
	ptr = NULL;
d2184 2
a2185 1
char *s_strdup(char *s)
d2192 2
a2193 5
    unsigned long len;
    char *copy = NULL;

    if (s == NULL)		/* saftey check to postpone stupid errors */
	return (NULL);
d2195 2
a2196 2
    len = strlen(s);		/* length of string - terminator */
    copy = (char *) s_malloc((size_t) (sizeof(char) * (len + 1)));
d2198 4
a2201 2
    strncpy(copy, s, len + 1);
    return (copy);
d2206 2
a2207 1
char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal)
d2213 2
a2214 2
    size_t dstSize = strlen(dst);
    size_t srcSize = strlen(src);
d2216 10
a2225 11
    if (dstSize + srcSize < maxTotal)	/* use regular old strncat */
	return (strncat(dst, src, maxToAdd));
    else {
	size_t truncateTo = maxTotal - dstSize - 1;
	char saveChar = src[truncateTo];
	char *result = NULL;

	src[truncateTo] = '\0';
	result = strncat(dst, src, maxToAdd);
	src[truncateTo] = saveChar;
	return (result);
d2233 3
a2235 4
    unsigned char ch = long_ch & 0xFF;	/* just want one byte */

    /* when ansi is the way of the world, this can be tolower */
    return (((ch >= 'A') && (ch <= 'Z')) ? (ch + 'a' - 'A') : ch);
d2240 6
a2245 7
    long i = 0;

    while (word[i] != '\0') {
	word[i] = char_downcase((unsigned long) word[i]);
	i++;
    }
    return (word);
d2249 1
a2249 1
#endif /* VMS */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d43 1
a43 1
#undef MAXINT	/* we don't need it here, and www_tcp.h may conflict */
d223 1
a223 1
		  (int)( request_length +HEADER_LENGTH)) )
d653 3
a655 3
  if (databases != NULL) {
    for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	if (query->DatabaseNames == NULL)
d662 2
a663 2
	}
    }
d666 3
a668 3
  if (elements != NULL) {
    for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	if (query->ElementSetNames == NULL)
d720 3
a722 3
  if (query->DatabaseNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL; ptr = query->DatabaseNames[++i]) {
	if (scratch == NULL)
d730 1
a730 1
	}
d736 4
a739 4
  if (query->ElementSetNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->ElementSetNames[i]; ptr != NULL; ptr = query->ElementSetNames[++i]) {
	if (scratch == NULL) {
	    if (query->ElementSetNames[i+1] == NULL) /* there is a single element set name */
d752 1
a752 1
	  }
d956 2
a957 2
  if (diag != NULL) {
    if (diag->ADDINFO != NULL)
d959 2
a960 2
    s_free(diag);
  }
d2035 1
a2035 1
  char tmp[100];
d2037 2
a2038 2
  sprintf(tmp,"readquery: bytes: %ld",info->size);
  log_write(tmp);
d2051 1
a2051 1
      if (qt == NULL)
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d699 3
a701 3
#define DB_DELIMITER	"\037"	/* hex 1F occurs between each database name */
#define ES_DELIMITER_1	"\037"	/* separates database name from element name */
#define ES_DELIMITER_2	"\036"	/* hex 1E separates <db,es> groups from one another */
d914 3
a916 3
		- writeCompressedIntegerWithPadding() to
		  writeCompressedIntWithPadding()
		- generalized conditional includes (see c-dialect.h)
d1910 1
a1910 1
  any*  term;
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d179 1
a179 1
static long read_from_stream(int d, char *buf, long nbytes)
d206 1
a206 1
static long
d334 1
a334 1
static char *delete_seeker_codes(char *string, long *length)
d1958 1
a1958 1
static unsigned long getQueryTermSize (query_term* qt);
d2081 1
a2081 1
static void exitAction (long error);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 6
a7 6
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	30-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/
d10 3
a12 3
 *	Routines originally from UI.c -- FM
 *
 *----------------------------------------------------------------------*/
d14 5
a18 5
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Brewster@@think.com
 */
a38 2

#ifdef VMS
d43 1
a43 1
#undef MAXINT			/* we don't need it here, and www_tcp.h may conflict */
d49 2
a50 1
void log_write(char *s GCC_UNUSED)
d60 45
a104 45
char *generate_search_apdu(char *buff,	/* buffer to hold the apdu */
			   long *buff_len,	/* length of the buffer changed to reflect new data written */
			   char *seed_words,	/* string of the seed words */
			   char *database_name,
			   DocObj **docobjs,
			   long maxDocsRetrieved)
{
    /* local variables */

    SearchAPDU *search3;
    char *end_ptr;
    static char *database_names[2] =
    {"", 0};
    any refID;
    WAISSearch *query;

    refID.size = 1;
    refID.bytes = "3";

    database_names[0] = database_name;
    query = makeWAISSearch(seed_words,
			   docobjs,	/* DocObjsPtr */
			   0,
			   1,	/* DateFactor */
			   0,	/* BeginDateRange */
			   0,	/* EndDateRange */
			   maxDocsRetrieved
	);

    search3 = makeSearchAPDU(30,
			     5000,	/* should be large */
			     30,
			     1,	/* replace indicator */
			     "",	/* result set name */
			     database_names,	/* database name */
			     QT_RelevanceFeedbackQuery,		/* query_type */
			     0,	/* element name */
			     NULL,	/* reference ID */
			     query);

    end_ptr = writeSearchAPDU(search3, buff, buff_len);

    CSTFreeWAISSearch(query);
    freeSearchAPDU(search3);
    return (end_ptr);
d113 57
a169 55
char *generate_retrieval_apdu(char *buff,
			      long *buff_len,	/* length of the buffer changed to reflect new data written */
			      any *docID,
			      long chunk_type,
			      long start,
			      long end,
			      char *type,
			      char *database_name)
{
    SearchAPDU *search;
    char *end_ptr;

    static char *database_names[2];
    static char *element_names[3];
    any refID;

    DocObj *DocObjs[2];
    any *query;			/* changed from char* by brewster */

    if (NULL == type)
	type = s_strdup("TEXT");

    database_names[0] = database_name;
    database_names[1] = NULL;

    element_names[0] = " ";
    element_names[1] = ES_DocumentText;
    element_names[2] = NULL;

    refID.size = 1;
    refID.bytes = "3";

    switch (chunk_type) {
    case CT_line:
	DocObjs[0] = makeDocObjUsingLines(docID, type, start, end);
	break;
    case CT_byte:
	DocObjs[0] = makeDocObjUsingBytes(docID, type, start, end);
	break;
    }
    DocObjs[1] = NULL;

    query = makeWAISTextQuery(DocObjs);
    search = makeSearchAPDU(10, 16, 15,
			    1,	/* replace indicator */
			    "FOO",	/* result set name */
			    database_names,	/* database name */
			    QT_TextRetrievalQuery,	/* query_type */
			    element_names,	/* element name */
			    &refID,	/* reference ID */
			    query);
    end_ptr = writeSearchAPDU(search, buff, buff_len);
    CSTFreeWAISTextQuery(query);
    freeSearchAPDU(search);
    return (end_ptr);
d181 19
a199 19
    long didRead;
    long toRead = nbytes;
    long totalRead = 0;		/* paranoia */

    while (toRead > 0) {
	didRead = NETREAD(d, buf, (int) toRead);
	if (didRead == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
	if (didRead == -1)	/* error */
	    return (-1);
	if (didRead == 0)	/* eof */
	    return (-2);	/* maybe this should return 0? */
	toRead -= didRead;
	buf += didRead;
	totalRead += didRead;
    }
    if (totalRead != nbytes)	/* we overread for some reason */
	return (-totalRead);	/* bad news */
    return (totalRead);
d206 19
a224 16
static long transport_message(long connection,
			      char *request_message,
			      long request_length,
			      char *response_message,
			      long response_buffer_length)
{
    WAISMessage header;
    long response_length;
    int rv;

    /* Write out message.  Read back header.  Figure out response length. */

    if (request_length + HEADER_LENGTH !=
	NETWRITE(connection, request_message,
		 (int) (request_length + HEADER_LENGTH)))
	return 0;
d226 1
a226 1
    /* read for the first '0' */
d228 36
a263 2
    while (1) {
	rv = read_from_stream(connection, response_message, 1);
d265 1
a265 1
	    return HT_INTERRUPTED;
d267 13
a279 49
	    return 0;
	if ('0' == response_message[0])
	    break;
    }

    rv = read_from_stream(connection, response_message + 1, HEADER_LENGTH - 1);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;

    readWAISPacketHeader(response_message, &header);
    {
	char length_array[11];

	strncpy(length_array, header.msg_len, 10);
	length_array[10] = '\0';
	response_length = atol(length_array);
	/*
	   if(verbose){
	   printf("WAIS header: '%s' length_array: '%s'\n",
	   response_message, length_array);
	   }
	 */
	if (response_length > response_buffer_length) {
	    /* we got a message that is too long, therefore empty the message out,
	       and return 0 */
	    long i;

	    for (i = 0; i < response_length; i++) {
		rv = read_from_stream(connection,
				      response_message + HEADER_LENGTH,
				      1);
		if (rv == HT_INTERRUPTED)
		    return HT_INTERRUPTED;
		if (rv < 0)
		    return 0;
	    }
	    return (0);
	}
    }
    rv = read_from_stream(connection,
			  response_message + HEADER_LENGTH,
			  response_length);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;
    return (response_length);
d285 41
a325 38
long interpret_message(char *request_message,
		       long request_length,	/* length of the buffer */
		       char *response_message,
		       long response_buffer_length,
		       long connection,
		       boolean verbose GCC_UNUSED)
{
    long response_length;

    /* ?
       if(verbose){
       printf ("sending");
       if(hostname_internal && strlen(hostname_internal) > 0)
       printf(" to host %s", hostname_internal);
       if(service_name && strlen(service_name) > 0)
       printf(" for service %s", service_name);
       printf("\n");
       twais_dsply_rsp_apdu(request_message + HEADER_LENGTH,
       request_length);
       }

     */

    writeWAISPacketHeader(request_message,
			  request_length,
			  (long) 'z',	/* Z39.50 */
			  "wais      ",		/* server name */
			  (long) NO_COMPRESSION,	/* no compression */
			  (long) NO_ENCODING, (long) HEADER_VERSION);
    if (connection != 0) {
	response_length = transport_message(connection, request_message,
					    request_length,
					    response_message,
					    response_buffer_length);
	if (response_length == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
    } else
	return (0);
d327 1
a327 1
    return (response_length);
d336 15
a350 17
    long original_count;	/* index into the original string */
    long new_count = 0;		/* index into the collapsed string */

    for (original_count = 0; original_count < *length; original_count++) {
	if (27 == string[original_count]) {
	    /* then we have an escape code */
	    /* if the next letter is '(' or ')', then ignore two letters */
	    if ('(' == string[original_count + 1] ||
		')' == string[original_count + 1])
		original_count += 1;	/* it is a term marker */
	    else
		original_count += 4;	/* it is a paragraph marker */
	} else
	    string[new_count++] = string[original_count];
    }
    *length = new_count;
    return (string);
d355 1
a355 1
#if defined(VMS) && defined(__GNUC__)	/* 10-AUG-1995 [pr] */
d368 1
a368 2
static __const void *__const ctype_dummy[] =
{&_ctype_, &ctype_dummy};
d374 18
a391 19
    long length = strlen(headline) + 1;		/* include the trailing null */
    size_t i;

    headline = delete_seeker_codes(headline, &length);
    /* delete leading spaces */
    for (i = 0; i < strlen(headline); i++) {
	if (isprint(headline[i])) {
	    break;
	}
    }
    headline = headline + i;
    /* delete trailing stuff */
    for (i = strlen(headline) - 1; i > 0; i--) {
	if (isprint(headline[i])) {
	    break;
	}
	headline[i] = '\0';
    }
    return (headline);
d396 1
d398 3
a400 3
 *	Routines originally from ZProt.c -- FM
 *
 *----------------------------------------------------------------------*/
d402 7
a408 7
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
d419 16
a434 14
InitResponseAPDU *makeInitResponseAPDU(boolean result,
				       boolean search,
				       boolean present,
				       boolean deleteIt,
				       boolean accessControl,
				       boolean resourceControl,
				       long prefSize,
				       long maxMsgSize,
				       char *auth,
				       char *id,
				       char *name,
				       char *version,
				       any *refID,
				       void *userInfo)
d437 1
a437 1
    InitResponseAPDU *init = (InitResponseAPDU *) s_malloc((size_t) sizeof(InitResponseAPDU));
d439 15
a453 15
    init->PDUType = initResponseAPDU;
    init->Result = result;
    init->willSearch = search;
    init->willPresent = present;
    init->willDelete = deleteIt;
    init->supportAccessControl = accessControl;
    init->supportResourceControl = resourceControl;
    init->PreferredMessageSize = prefSize;
    init->MaximumRecordSize = maxMsgSize;
    init->IDAuthentication = s_strdup(auth);
    init->ImplementationID = s_strdup(id);
    init->ImplementationName = s_strdup(name);
    init->ImplementationVersion = s_strdup(version);
    init->ReferenceID = duplicateAny(refID);
    init->UserInformationField = userInfo;	/* not copied! */
d455 1
a455 1
    return (init);
d460 2
a461 1
void freeInitResponseAPDU(InitResponseAPDU *init)
d464 6
a469 6
    s_free(init->IDAuthentication);
    s_free(init->ImplementationID);
    s_free(init->ImplementationName);
    s_free(init->ImplementationVersion);
    freeAny(init->ReferenceID);
    s_free(init);
d474 2
a475 1
char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len)
d478 77
a554 98
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;
    bit_map *optionsBM = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(init->PDUType, buf, len);
    buf = writeBoolean(init->Result, buf, len);
    buf = writeProtocolVersion(buf, len);

    optionsBM = makeBitMap((unsigned long) 5, init->willSearch, init->willPresent,
			   init->willDelete, init->supportAccessControl,
			   init->supportResourceControl);
    buf = writeBitMap(optionsBM, DT_Options, buf, len);
    freeBitMap(optionsBM);

    buf = writeNum(init->PreferredMessageSize,
		   DT_PreferredMessageSize,
		   buf,
		   len);
    buf = writeNum(init->MaximumRecordSize,
		   DT_MaximumRecordSize,
		   buf,
		   len);
    buf = writeString(init->IDAuthentication,
		      DT_IDAuthentication,
		      buf,
		      len);
    buf = writeString(init->ImplementationID,
		      DT_ImplementationID,
		      buf,
		      len);
    buf = writeString(init->ImplementationName,
		      DT_ImplementationName,
		      buf,
		      len);
    buf = writeString(init->ImplementationVersion,
		      DT_ImplementationVersion,
		      buf,
		      len);
    buf = writeAny(init->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (init->UserInformationField != NULL)
	buf = writeInitResponseInfo(init, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer)
{
    char *buf = buffer;
    boolean search, present, delete, accessControl, resourceControl;
    long prefSize, maxMsgSize;
    char *auth, *id, *name, *version;
    long size;
    pdu_type pduType;
    bit_map *versionBM = NULL;
    bit_map *optionsBM = NULL;
    boolean result;
    any *refID = NULL;
    void *userInfo = NULL;

    auth = id = name = version = NULL;
    refID = NULL;

    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBoolean(&result, buf);
    buf = readBitMap(&versionBM, buf);
    buf = readBitMap(&optionsBM, buf);
    buf = readNum(&prefSize, buf);
    buf = readNum(&maxMsgSize, buf);

    /* decode optionsBM */
    search = bitAtPos(0, optionsBM);
    present = bitAtPos(1, optionsBM);
    delete = bitAtPos(2, optionsBM);
    accessControl = bitAtPos(3, optionsBM);
    resourceControl = bitAtPos(4, optionsBM);

    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_IDAuthentication:
	    buf = readString(&auth, buf);
d556 2
a557 2
	case DT_ImplementationID:
	    buf = readString(&id, buf);
d559 2
a560 2
	case DT_ImplementationName:
	    buf = readString(&name, buf);
d562 2
a563 2
	case DT_ImplementationVersion:
	    buf = readString(&version, buf);
d565 2
a566 2
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
d568 1
a568 1
	default:
d578 12
a589 1
	}
d591 6
d598 7
a604 35
    buf = readInitResponseInfo(&userInfo, buf);
    if (buf == NULL) {
	freeBitMap(versionBM);
	freeBitMap(optionsBM);
	s_free(auth);
	s_free(id);
	s_free(name);
	s_free(version);
	freeAny(refID);
    }
    RETURN_ON_NULL(buf);

    /* construct the basic init object */
    *init = makeInitResponseAPDU(result,
				 search,
				 present,
				 delete,
				 accessControl,
				 resourceControl,
				 prefSize,
				 maxMsgSize,
				 auth,
				 id,
				 name,
				 version,
				 refID,
				 userInfo);

    freeBitMap(versionBM);
    freeBitMap(optionsBM);
    s_free(auth);
    s_free(id);
    s_free(name);
    s_free(version);
    freeAny(refID);
d606 1
a606 1
    return (buf);
d611 2
a612 1
InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo)
d617 9
a625 17
    InitResponseAPDU *initResp;

    initResp = makeInitResponseAPDU(result,
				    init->willSearch,
				    init->willPresent,
				    init->willDelete,
				    init->supportAccessControl,
				    init->supportResourceControl,
				    init->PreferredMessageSize,
				    init->MaximumRecordSize,
				    init->IDAuthentication,
				    defaultImplementationID(),
				    defaultImplementationName(),
				    defaultImplementationVersion(),
				    init->ReferenceID,
				    userInfo);
    return (initResp);
d630 30
a659 35
SearchAPDU *makeSearchAPDU(long small,
			   long large,
			   long medium,
			   boolean replace,
			   char *name,
			   char **databases,
			   char *type,
			   char **elements,
			   any *refID,
			   void *queryInfo)
{
    char *ptr = NULL;
    long i;
    SearchAPDU *query = (SearchAPDU *) s_malloc((size_t) sizeof(SearchAPDU));

    query->PDUType = searchAPDU;
    query->SmallSetUpperBound = small;
    query->LargeSetLowerBound = large;
    query->MediumSetPresentNumber = medium;
    query->ReplaceIndicator = replace;
    query->ResultSetName = s_strdup(name);
    query->DatabaseNames = NULL;
    if (databases != NULL) {
	for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	    if (query->DatabaseNames == NULL)
		query->DatabaseNames = (char **) s_malloc((size_t) (sizeof(char
									   *)
								    * 2));

	    else
		query->DatabaseNames = (char **) s_realloc((char *) query->DatabaseNames,
							   (size_t) (sizeof(char
									    *) *
								       (i + 2)));

d661 1
a661 1
	    query->DatabaseNames[i + 1] = NULL;
d664 9
a672 14
    query->QueryType = s_strdup(type);
    query->ElementSetNames = NULL;
    if (elements != NULL) {
	for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	    if (query->ElementSetNames == NULL)
		query->ElementSetNames =
		    (char **) s_malloc((size_t) (sizeof(char *) * 2));

	    else
		query->ElementSetNames = (char **) s_realloc((char *) query->ElementSetNames,
							     (size_t) (sizeof(char
									      *) *
								         (i + 2)));

d674 6
a679 6
	    query->ElementSetNames[i + 1] = NULL;
	}
    }
    query->ReferenceID = duplicateAny(refID);
    query->Query = queryInfo;	/* not copied! */
    return (query);
d684 11
a694 10
void freeSearchAPDU(SearchAPDU *query)
{
    s_free(query->ResultSetName);
    s_free(query->QueryType);
    doList((void **) query->DatabaseNames, fs_free);	/* can't use the macro here ! */
    s_free(query->DatabaseNames);
    doList((void **) query->ElementSetNames, fs_free);	/* can't use the macro here ! */
    s_free(query->ElementSetNames);
    freeAny(query->ReferenceID);
    s_free(query);
d703 2
a704 1
char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len)
d706 24
a729 27
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size, i;
    char *ptr = NULL;
    char *scratch = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(query->PDUType, buf, len);
    buf = writeBinaryInteger(query->SmallSetUpperBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->LargeSetLowerBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->MediumSetPresentNumber, (size_t) 3, buf, len);
    buf = writeBoolean(query->ReplaceIndicator, buf, len);
    buf = writeString(query->ResultSetName, DT_ResultSetName, buf, len);
    /* write database names */
    if (query->DatabaseNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL;
	     ptr = query->DatabaseNames[++i]) {
	    if (scratch == NULL)
		scratch = s_strdup(ptr);
	    else {
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) + 2);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, DB_DELIMITER, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
	    }
d731 1
a731 1
	buf = writeString(scratch, DT_DatabaseNames, buf, len);
d733 10
a742 24
    }
    buf = writeString(query->QueryType, DT_QueryType, buf, len);
    /* write element set names */
    if (query->ElementSetNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->ElementSetNames[i];
	     ptr != NULL;
	     ptr = query->ElementSetNames[++i]) {
	    if (scratch == NULL) {
		if (query->ElementSetNames[i + 1] == NULL)	/* there is a single element set name */
		{
		    scratch = (char *) s_malloc((size_t) strlen(ptr) + 2);
		    strncpy(scratch, ES_DELIMITER_1, 2);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, strlen(ptr) + 2);
		} else {	/* this is the first of a series of element set names */
		    size_t newScratchSize = (size_t) (strlen(ptr) +
						      strlen(query->ElementSetNames[i
										    + 1])
						      + 2);

		    scratch = s_strdup(ptr);	/* the database name */
		    ptr = query->ElementSetNames[++i];	/* the element set name */
		    scratch = (char *) s_realloc(scratch, newScratchSize);
		    s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
d744 20
a763 15
	    } else {
		char *esPtr = query->ElementSetNames[++i];	/* the element set name */
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) +
						  strlen(esPtr) +
						  3);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_2, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		s_strncat(scratch, esPtr, strlen(esPtr) + 1, newScratchSize);
	    }
	}
	buf = writeString(scratch, DT_ElementSetNames, buf, len);
d765 2
a766 2
    }
    buf = writeAny(query->ReferenceID, DT_ReferenceID, buf, len);
d768 4
a771 4
    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);
d773 2
a774 2
    if (query->Query != NULL)
	buf = writeSearchInfo(query, buf, len);
d776 1
a776 1
    return (buf);
d781 10
a790 8
SearchResponseAPDU *makeSearchResponseAPDU(long result,
					   long count,
					   long recordsReturned,
					   long nextPos,
					   long resultStatus,
					   long presentStatus,
					   any *refID,
					   void *records)
d792 11
a802 13
    SearchResponseAPDU *query =
    (SearchResponseAPDU *) s_malloc((size_t) sizeof(SearchResponseAPDU));

    query->PDUType = searchResponseAPDU;
    query->SearchStatus = result;
    query->ResultCount = count;
    query->NumberOfRecordsReturned = recordsReturned;
    query->NextResultSetPosition = nextPos;
    query->ResultSetStatus = resultStatus;
    query->PresentStatus = presentStatus;
    query->ReferenceID = duplicateAny(refID);
    query->DatabaseDiagnosticRecords = records;
    return (query);
d807 2
a808 1
void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse)
d810 2
a811 2
    freeAny(queryResponse->ReferenceID);
    s_free(queryResponse);
d816 2
a817 2
char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char *buffer,
			      long *len)
d819 2
a820 2
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;
d822 1
a822 1
    RESERVE_SPACE_FOR_HEADER(len);
d824 8
a831 31
    buf = writePDUType(queryResponse->PDUType,
		       buf,
		       len);
    buf = writeBinaryInteger(queryResponse->SearchStatus,
			     (size_t) 1,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->ResultCount,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NumberOfRecordsReturned,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NextResultSetPosition,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeNum(queryResponse->ResultSetStatus,
		   DT_ResultSetStatus,
		   buf,
		   len);
    buf = writeNum(queryResponse->PresentStatus,
		   DT_PresentStatus,
		   buf,
		   len);
    buf = writeAny(queryResponse->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);
d833 4
a836 4
    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);
d838 2
a839 2
    if (queryResponse->DatabaseDiagnosticRecords != NULL)
	buf = writeSearchResponseInfo(queryResponse, buf, len);
d841 1
a841 1
    return (buf);
d846 2
a847 1
char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer)
d849 7
a855 7
    char *buf = buffer;
    long size;
    pdu_type pduType;
    long result, count, recordsReturned, nextPos;
    long resultStatus, presentStatus;
    any *refID = NULL;
    void *userInfo = NULL;
d857 7
a863 7
    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBinaryInteger(&result, (size_t) 1, buf);
    buf = readBinaryInteger(&count, (size_t) 3, buf);
    buf = readBinaryInteger(&recordsReturned, (size_t) 3, buf);
    buf = readBinaryInteger(&nextPos, (size_t) 3, buf);
d865 2
a866 2
    resultStatus = presentStatus = UNUSED;
    refID = NULL;
d868 6
a873 7
    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_ResultSetStatus:
	    buf = readNum(&resultStatus, buf);
d875 2
a876 2
	case DT_PresentStatus:
	    buf = readNum(&presentStatus, buf);
d878 2
a879 2
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
d881 1
a881 1
	default:
d885 1
a885 1
	}
d888 8
a895 14
    buf = readSearchResponseInfo(&userInfo, buf);
    if (buf == NULL)
	freeAny(refID);
    RETURN_ON_NULL(buf);

    /* construct the search object */
    *queryResponse = makeSearchResponseAPDU(result,
					    count,
					    recordsReturned,
					    nextPos,
					    (long) resultStatus,
					    (long) presentStatus,
					    refID,
					    userInfo);
d897 1
a897 1
    freeAny(refID);
d899 1
a899 1
    return (buf);
d902 1
d904 3
a906 3
 *	Routines originally from ZUtil.c -- FM
 *
 *----------------------------------------------------------------------*/
d908 11
a918 11
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - fixed include file names, changed
 *		- writeCompressedIntegerWithPadding() to
 *		  writeCompressedIntWithPadding()
 *		- generalized conditional includes (see c-dialect.h)
 * 3.7.91   Jonny Goldman.  Replaced "short" in makeBitMap with "int" line 632.
 */
d920 1
a920 1
char *readErrorPosition = NULL;	/* pos where buf stoped making sense */
d938 2
a939 1
diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo)
d941 2
a942 2
    diagnosticRecord *diag =
    (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));
d944 3
a946 3
    diag->SURROGATE = surrogate;
    memcpy(diag->DIAG, code, DIAGNOSTIC_CODE_SIZE);
    diag->ADDINFO = s_strdup(addInfo);
d948 1
a948 1
    return (diag);
d953 2
a954 1
void freeDiag(diagnosticRecord * diag)
d956 5
a960 5
    if (diag != NULL) {
	if (diag->ADDINFO != NULL)
	    s_free(diag->ADDINFO);
	s_free(diag);
    }
d967 2
a968 1
char *writeDiag(diagnosticRecord * diag, char *buffer, long *len)
d973 2
a974 2
    char *buf = buffer;
    long length;
d976 2
a977 2
    if (diag == NULL)		/* handle unspecified optional args */
	return (buf);
d979 2
a980 2
    buf = writeTag(DT_DatabaseDiagnosticRecords, buf, len);
    CHECK_FOR_SPACE_LEFT(0, len);
d982 3
a984 3
    length = 3;
    if (diag->ADDINFO != NULL)
	length += strlen(diag->ADDINFO);
d986 3
a988 4
    if (length >= 0xFFFF)	/* make sure the length is reasonable */
    {
	length = 0xFFFF - 1;
	diag->ADDINFO[0xFFFF - 3 - 1] = '\0';
d991 1
a991 1
    buf = writeBinaryInteger(length, 2, buf, len);
d993 3
a995 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[0];
    buf++;
d997 3
a999 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[1];
    buf++;
d1001 4
a1004 4
    if (length > 3) {
	CHECK_FOR_SPACE_LEFT(3, len);
	memcpy(buf, diag->ADDINFO, (size_t) length - 3);
	buf += length - 3;
d1007 3
a1009 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->SURROGATE;
    buf++;
d1011 3
a1013 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = END_OF_RECORD;
    buf++;
d1015 1
a1015 1
    return (buf);
d1020 2
a1021 1
char *readDiag(diagnosticRecord ** diag, char *buffer)
d1023 5
a1027 4
    char *buf = buffer;
    diagnosticRecord *d = (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));
    data_tag tag;
    long len;
d1029 1
a1029 1
    buf = readTag(&tag, buf);
d1031 1
a1031 1
    buf = readBinaryInteger(&len, 2, buf);
d1033 3
a1035 3
    d->DIAG[0] = buf[0];
    d->DIAG[1] = buf[1];
    d->DIAG[2] = '\0';
d1037 7
a1043 6
    if (len > 3) {
	d->ADDINFO = (char *) s_malloc((size_t) (len - 3 + 1));
	memcpy(d->ADDINFO, (char *) (buf + 2), (size_t) (len - 3));
	d->ADDINFO[len - 3] = '\0';
    } else
	d->ADDINFO = NULL;
d1045 1
a1045 1
    d->SURROGATE = buf[len - 1];
d1047 1
a1047 1
    *diag = d;
d1049 1
a1049 1
    return (buf + len + 1);
d1058 2
a1059 1
char *writeCompressedInteger(unsigned long num, char *buf, long *len)
d1064 3
a1066 3
    char byte;
    unsigned long i;
    unsigned long size;
d1068 2
a1069 2
    size = writtenCompressedIntSize(num);
    CHECK_FOR_SPACE_LEFT(size, len);
d1071 6
a1076 6
    for (i = size - 1; i != 0; i--) {
	byte = num & dataMask;
	if (i != (size - 1))	/* turn on continue bit */
	    byte = (char) (byte | continueBit);
	buf[i] = byte;
	num = num >> dataBits;	/* don't and here */
d1079 1
a1079 1
    return (buf + size);
d1084 2
a1085 1
char *readCompressedInteger(unsigned long *num, char *buf)
d1090 2
a1091 2
    long i = 0;
    unsigned char byte;
d1093 1
a1093 1
    *num = 0;
d1095 4
a1098 4
    do {
	byte = buf[i++];
	*num = *num << dataBits;
	*num += (byte & dataMask);
d1100 1
a1100 1
    while (byte & continueBit);
d1102 1
a1102 1
    return (buf + i);
d1107 1
a1107 1
#define pad	128		/* high bit is set */
d1109 6
a1114 4
char *writeCompressedIntWithPadding(unsigned long num,
				    unsigned long size,
				    char *buffer,
				    long *len)
d1120 3
a1122 3
    char *buf = buffer;
    unsigned long needed, padding;
    long i;
d1124 1
a1124 1
    CHECK_FOR_SPACE_LEFT(size, len);
d1126 3
a1128 3
    needed = writtenCompressedIntSize(num);
    padding = size - needed;
    i = padding - 1;
d1130 2
a1131 2
    for (i = padding - 1; i >= 0; i--) {
	buf[i] = pad;
d1134 1
a1134 1
    buf = writeCompressedInteger(num, buf + padding, len);
d1136 1
a1136 1
    return (buf);
d1141 2
a1142 1
unsigned long writtenCompressedIntSize(unsigned long num)
d1147 8
a1154 8
    if (num < CompressedInt1Byte)
	return (1);
    else if (num < CompressedInt2Byte)
	return (2);
    else if (num < CompressedInt3Byte)
	return (3);
    else
	return (4);
d1159 2
a1160 1
char *writeTag(data_tag tag, char *buf, long *len)
d1163 1
a1163 1
    return (writeCompressedInteger(tag, buf, len));
d1168 2
a1169 1
char *readTag(data_tag *tag, char *buf)
d1172 1
a1172 1
    return (readCompressedInteger(tag, buf));
d1177 2
a1178 1
unsigned long writtenTagSize(data_tag tag)
d1180 1
a1180 1
    return (writtenCompressedIntSize(tag));
d1185 2
a1186 1
data_tag peekTag(char *buf)
d1189 3
a1191 4
    data_tag tag;

    readTag(&tag, buf);
    return (tag);
d1196 2
a1197 1
any *makeAny(unsigned long size, char *data)
d1199 4
a1202 5
    any *a = (any *) s_malloc((size_t) sizeof(any));

    a->size = size;
    a->bytes = data;
    return (a);
d1207 2
a1208 1
void freeAny(any *a)
d1213 4
a1216 4
    if (a != NULL) {
	if (a->bytes != NULL)
	    s_free(a->bytes);
	s_free(a);
d1222 2
a1223 1
any *duplicateAny(any *a)
d1225 1
a1225 1
    any *copy = NULL;
d1227 2
a1228 2
    if (a == NULL)
	return (NULL);
d1230 7
a1236 8
    copy = (any *) s_malloc((size_t) sizeof(any));

    copy->size = a->size;
    if (a->bytes == NULL)
	copy->bytes = NULL;
    else {
	copy->bytes = (char *) s_malloc((size_t) copy->size);
	memcpy(copy->bytes, a->bytes, (size_t) copy->size);
d1238 1
a1238 1
    return (copy);
d1243 2
a1244 1
char *writeAny(any *a, data_tag tag, char *buffer, long *len)
d1247 1
a1247 1
    char *buf = buffer;
d1249 2
a1250 2
    if (a == NULL)		/* handle unspecified optional args */
	return (buf);
d1252 3
a1254 3
    /* write the tags */
    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(a->size, buf, len);
d1256 3
a1258 3
    /* write the bytes */
    CHECK_FOR_SPACE_LEFT(a->size, len);
    memcpy(buf, a->bytes, (size_t) a->size);
d1260 1
a1260 1
    return (buf + a->size);
d1265 2
a1266 1
char *readAny(any **anAny, char *buffer)
d1269 3
a1271 3
    char *buf;
    any *a;
    data_tag tag;
a1272 1
    a = (any *) s_malloc((size_t) sizeof(any));
a1273 1
    buf = buffer;
d1275 1
a1275 1
    buf = readTag(&tag, buf);
d1277 1
a1277 1
    buf = readCompressedInteger(&a->size, buf);
d1279 1
a1279 4
    /* now simply copy the bytes */
    a->bytes = (char *) s_malloc((size_t) a->size);
    memcpy(a->bytes, buf, (size_t) a->size);
    *anAny = a;
d1281 8
a1288 1
    return (buf + a->size);
d1293 2
a1294 1
unsigned long writtenAnySize(data_tag tag, any *a)
d1296 1
a1296 1
    unsigned long size;
d1298 2
a1299 2
    if (a == NULL)
	return (0);
d1301 4
a1304 4
    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(a->size);
    size += a->size;
    return (size);
d1309 2
a1310 1
any *stringToAny(char *s)
d1312 1
a1312 1
    any *a = NULL;
d1314 2
a1315 2
    if (s == NULL)
	return (NULL);
d1317 5
a1321 6
    a = (any *) s_malloc((size_t) sizeof(any));

    a->size = strlen(s);
    a->bytes = (char *) s_malloc((size_t) a->size);
    memcpy(a->bytes, s, (size_t) a->size);
    return (a);
d1326 2
a1327 1
char *anyToString(any *a)
d1329 1
a1329 1
    char *s = NULL;
d1331 2
a1332 2
    if (a == NULL)
	return (NULL);
d1334 4
a1337 4
    s = s_malloc((size_t) (a->size + 1));
    memcpy(s, a->bytes, (size_t) a->size);
    s[a->size] = '\0';
    return (s);
d1342 2
a1343 1
char *writeString(char *s, data_tag tag, char *buffer, long *len)
d1350 10
a1359 12
    char *buf = buffer;
    any *data = NULL;

    if (s == NULL)
	return (buffer);	/* handle unused optional item before making an any */
    data = (any *) s_malloc((size_t) sizeof(any));

    data->size = strlen(s);
    data->bytes = s;		/* save a copy here by not using stringToAny() */
    buf = writeAny(data, tag, buf, len);
    s_free(data);		/* don't use freeAny() since it will free s too */
    return (buf);
d1364 2
a1365 1
char *readString(char **s, char *buffer)
d1372 5
a1376 6
    any *data = NULL;
    char *buf = readAny(&data, buffer);

    *s = anyToString(data);
    freeAny(data);
    return (buf);
d1381 2
a1382 1
unsigned long writtenStringSize(data_tag tag, char *s)
d1384 1
a1384 1
    unsigned long size;
d1386 2
a1387 2
    if (s == NULL)
	return (0);
d1389 4
a1392 4
    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(size);
    size += strlen(s);
    return (size);
d1397 2
a1398 1
any *longToAny(long num)
d1401 1
a1401 1
    char s[40];
d1403 1
a1403 1
    sprintf(s, "%ld", num);
d1405 1
a1405 1
    return (stringToAny(s));
d1410 2
a1411 1
long anyToLong(any *a)
d1414 4
a1417 5
    long num;
    char *str = NULL;

    str = anyToString(a);
    sscanf(str, "%ld", &num);	/* could check the result and return
d1419 2
a1420 2
    s_free(str);
    return (num);
d1427 2
a1428 1
bit_map *makeBitMap(unsigned long numBits,...)
d1431 20
a1450 26
    va_list ap;
    unsigned long i, j;
    bit_map *bm = NULL;

    LYva_start(ap, numBits);

    bm = (bit_map *) s_malloc((size_t) sizeof(bit_map));

    bm->size = (unsigned long) (ceil((double) numBits / bitsPerByte));
    bm->bytes = (char *) s_malloc((size_t) bm->size);

    /* fill up the bits */
    for (i = 0; i < bm->size; i++)	/* iterate over bytes */
    {
	char byte = 0;

	for (j = 0; j < bitsPerByte; j++)	/* iterate over bits */
	{
	    if ((i * bitsPerByte + j) < numBits) {
		boolean bit = false;

		bit = (boolean) va_arg(ap, boolean);

		if (bit) {
		    byte = byte | (1 << (bitsPerByte - j - 1));
		}
d1452 2
a1453 2
	}
	bm->bytes[i] = byte;
d1456 2
a1457 2
    va_end(ap);
    return (bm);
d1460 1
d1463 2
a1464 1
void freeBitMap(bit_map *bm)
d1467 2
a1468 2
    s_free(bm->bytes);
    s_free(bm);
d1478 2
a1479 1
boolean bitAtPos(unsigned long pos, bit_map *bm)
d1481 6
a1486 6
    if (pos > bm->size * bitsPerByte)
	return false;
    else
	return ((bm->bytes[(pos / bitsPerByte)] &
		 (0x80 >> (pos % bitsPerByte))) ?
		true : false);
d1491 2
a1492 1
char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len)
d1495 1
a1495 1
    return (writeAny((any *) bm, tag, buffer, len));
d1500 2
a1501 1
char *readBitMap(bit_map **bm, char *buffer)
d1505 2
a1506 3

    c = readAny((any **) bm, buffer);
    return (c);
d1511 2
a1512 1
char *writeByte(unsigned long byte, char *buf, long *len)
d1514 3
a1516 3
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = byte & 0xFF;	/* we really only want the first byte */
    return (buf + 1);
d1521 2
a1522 1
char *readByte(unsigned char *byte, char *buf)
d1524 2
a1525 2
    *byte = buf[0];
    return (buf + 1);
d1530 2
a1531 1
char *writeBoolean(boolean flag, char *buf, long *len)
d1533 1
a1533 1
    return (writeByte(flag, buf, len));
d1538 2
a1539 1
char *readBoolean(boolean *flag, char *buffer)
d1541 4
a1544 5
    unsigned char byte;
    char *buf = readByte(&byte, buffer);

    *flag = (byte == true) ? true : false;
    return (buf);
d1549 2
a1550 1
char *writePDUType(pdu_type pduType, char *buf, long *len)
d1553 1
a1553 1
    return (writeBinaryInteger((long) pduType, (unsigned long) 1, buf, len));
d1558 2
a1559 1
char *readPDUType(pdu_type *pduType, char *buf)
d1562 1
a1562 1
    return (readBinaryInteger((long *) pduType, (unsigned long) 1, buf));
d1567 2
a1568 1
pdu_type peekPDUType(char *buf)
d1574 3
a1576 4
    pdu_type pdu;

    readPDUType(&pdu, buf + HEADER_LEN);
    return (pdu);
d1581 4
a1584 3
#define BINARY_INTEGER_BYTES	sizeof(long)	/* the number of bytes used by
						   a "binary integer" */
char *writeBinaryInteger(long num, unsigned long size, char *buf, long *len)
d1588 2
a1589 2
    long i;
    char byte;
d1591 2
a1592 2
    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (NULL);		/* error */
d1594 1
a1594 1
    CHECK_FOR_SPACE_LEFT(size, len);
d1596 4
a1599 4
    for (i = size - 1; i >= 0; i--) {
	byte = (char) (num & 255);
	buf[i] = byte;
	num = num >> bitsPerByte;	/* don't and here */
d1602 1
a1602 1
    return (buf + size);
d1607 2
a1608 1
char *readBinaryInteger(long *num, unsigned long size, char *buf)
d1612 2
a1613 2
    unsigned long i;
    unsigned char byte;
d1615 3
a1617 3
    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (buf);		/* error */
    *num = 0;
d1619 4
a1622 4
    for (i = 0; i < size; i++) {
	byte = buf[i];
	*num = *num << bitsPerByte;
	*num += byte;
d1625 1
a1625 1
    return (buf + size);
d1630 2
a1631 1
unsigned long writtenCompressedBinIntSize(long num)
d1637 10
a1646 10
    if (num < 0L)
	return (4);
    else if (num < 256L)	/* 2**8 */
	return (1);
    else if (num < 65536L)	/* 2**16 */
	return (2);
    else if (num < 16777216L)	/* 2**24 */
	return (3);
    else
	return (4);
d1651 2
a1652 1
char *writeNum(long num, data_tag tag, char *buffer, long *len)
d1655 2
a1656 2
    char *buf = buffer;
    long size = writtenCompressedBinIntSize(num);
d1658 2
a1659 2
    if (num == UNUSED)
	return (buffer);
d1661 4
a1664 4
    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(size, buf, len);
    buf = writeBinaryInteger(num, (unsigned long) size, buf, len);
    return (buf);
d1669 2
a1670 1
char *readNum(long *num, char *buffer)
d1673 4
a1676 4
    char *buf = buffer;
    data_tag tag;
    unsigned long size;
    unsigned long val;
d1678 5
a1682 5
    buf = readTag(&tag, buf);
    buf = readCompressedInteger(&val, buf);
    size = (unsigned long) val;
    buf = readBinaryInteger(num, size, buf);
    return (buf);
d1687 2
a1688 1
unsigned long writtenNumSize(data_tag tag, long num)
d1690 2
a1691 2
    long dataSize = writtenCompressedBinIntSize(num);
    long size;
d1693 3
a1695 3
    size = writtenTagSize(tag);	/* space for the tag */
    size += writtenCompressedIntSize(dataSize);		/* space for the size */
    size += dataSize;		/* space for the data */
d1697 1
a1697 1
    return (size);
d1702 1
a1702 1
typedef void (voidfunc) (void *);
d1704 2
a1705 1
void doList(void **list, voidfunc * func)
d1708 6
a1713 7
    register long i;
    register void *ptr = NULL;

    if (list == NULL)
	return;
    for (i = 0, ptr = list[i]; ptr != NULL; ptr = list[++i])
	(*func) (ptr);
d1718 2
a1719 1
char *writeProtocolVersion(char *buf, long *len)
d1722 1
a1722 1
    static bit_map *version = NULL;
d1724 3
a1726 3
    if (version == NULL) {
	version = makeBitMap((unsigned long) 1, true);	/* version 1! */
    }
d1728 1
a1728 1
    return (writeBitMap(version, DT_ProtocolVersion, buf, len));
d1733 2
a1734 1
char *defaultImplementationID(void)
d1736 2
a1737 3
    static char ImplementationID[] = "TMC";

    return (ImplementationID);
d1742 2
a1743 1
char *defaultImplementationName(void)
d1745 2
a1746 3
    static char ImplementationName[] = "Thinking Machines Corporation Z39.50";

    return (ImplementationName);
d1751 2
a1752 1
char *defaultImplementationVersion(void)
d1754 2
a1755 3
    static char ImplementationVersion[] = "2.0A";

    return (ImplementationVersion);
d1760 1
d1762 3
a1764 3
 *	Routines originally from ZType1.c -- FM
 *
 *----------------------------------------------------------------------*/
d1766 6
a1771 6
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
d1774 9
a1782 7
query_term *makeAttributeTerm(char *use,
			      char *relation,
			      char *position,
			      char *structure,
			      char *truncation,
			      char *completeness,
			      any *term)
d1784 1
a1784 1
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));
d1786 1
a1786 1
    qt->TermType = TT_Attribute;
d1788 7
a1794 7
    /* copy in the attributes */
    strncpy(qt->Use, use, ATTRIBUTE_SIZE);
    strncpy(qt->Relation, relation, ATTRIBUTE_SIZE);
    strncpy(qt->Position, position, ATTRIBUTE_SIZE);
    strncpy(qt->Structure, structure, ATTRIBUTE_SIZE);
    strncpy(qt->Truncation, truncation, ATTRIBUTE_SIZE);
    strncpy(qt->Completeness, completeness, ATTRIBUTE_SIZE);
d1796 1
a1796 1
    qt->Term = duplicateAny(term);
d1798 1
a1798 1
    qt->ResultSetID = NULL;
d1800 1
a1800 1
    return (qt);
d1805 2
a1806 1
query_term *makeResultSetTerm(any *resultSet)
d1808 1
a1808 1
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));
d1810 1
a1810 1
    qt->TermType = TT_ResultSetID;
d1812 1
a1812 1
    qt->ResultSetID = duplicateAny(resultSet);
d1814 1
a1814 1
    qt->Term = NULL;
d1816 1
a1816 1
    return (qt);
d1821 2
a1822 1
query_term *makeOperatorTerm(char *operatorCode)
d1824 1
a1824 1
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));
d1826 1
a1826 1
    qt->TermType = TT_Operator;
d1828 1
a1828 1
    strncpy(qt->Operator, operatorCode, OPERATOR_SIZE);
d1830 2
a1831 2
    qt->Term = NULL;
    qt->ResultSetID = NULL;
d1833 1
a1833 1
    return (qt);
d1838 2
a1839 1
void freeTerm(void *param)
d1841 3
a1843 4
    query_term *qt = (query_term *) param;

    switch (qt->TermType) {
    case TT_Attribute:
d1846 1
a1846 1
    case TT_ResultSetID:
d1849 1
a1849 1
    case TT_Operator:
d1852 1
a1852 1
    default:
d1856 2
a1857 2
    }
    s_free(qt);
d1865 2
a1866 1
char *writeQueryTerm(query_term *qt, char *buffer, long *len)
d1868 2
a1869 2
    char *buf = buffer;
    char attributes[ATTRIBUTE_LIST_SIZE];
d1871 15
a1885 15
    switch (qt->TermType) {
    case TT_Attribute:
	strncpy(attributes, qt->Use, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Relation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Position, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Structure, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Truncation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Completeness, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	buf = writeString(attributes, DT_AttributeList, buf, len);
	buf = writeAny(qt->Term, DT_Term, buf, len);
d1887 2
a1888 2
    case TT_ResultSetID:
	buf = writeAny(qt->ResultSetID, DT_ResultSetID, buf, len);
d1890 2
a1891 2
    case TT_Operator:
	buf = writeString(qt->Operator, DT_Operator, buf, len);
d1893 1
a1893 1
    default:
d1897 1
a1897 1
    }
d1899 1
a1899 1
    return (buf);
d1904 31
a1934 29
char *readQueryTerm(query_term **qt, char *buffer)
{
    char *buf = buffer;
    char *attributeList = NULL;
    char *operator = NULL;
    any *term;
    char *use = NULL;
    char *relation = NULL;
    char *position = NULL;
    char *structure = NULL;
    char *truncation = NULL;
    char *completeness;
    any *resultSetID = NULL;
    data_tag tag;

    tag = peekTag(buffer);

    switch (tag) {
    case DT_AttributeList:
	buf = readString(&attributeList, buf);
	buf = readAny(&term, buf);
	use = strtok(attributeList, AT_DELIMITER);
	relation = strtok(NULL, AT_DELIMITER);
	position = strtok(NULL, AT_DELIMITER);
	structure = strtok(NULL, AT_DELIMITER);
	truncation = strtok(NULL, AT_DELIMITER);
	completeness = strtok(NULL, AT_DELIMITER);
	*qt = makeAttributeTerm(use, relation, position, structure,
				truncation, completeness, term);
d1938 2
a1939 2
    case DT_ResultSetID:
	buf = readAny(&resultSetID, buf);
d1943 2
a1944 2
    case DT_Operator:
	buf = readString(&operator, buf);
d1948 1
a1948 1
    default:
d1951 1
a1951 1
    }
d1953 1
a1953 1
    return (buf);
d1958 1
a1958 1
static unsigned long getQueryTermSize(query_term *qt);
d1960 2
a1961 1
static unsigned long getQueryTermSize(query_term *qt)
d1964 9
a1972 10
    unsigned long size = 0;
    static char attributes[] = "11 22 33 44 55 66";	/* we just need this to

							   calculate its written
							   size */

    switch (qt->TermType) {
    case TT_Attribute:
	size = writtenStringSize(DT_AttributeList, attributes);
	size += writtenAnySize(DT_Term, qt->Term);
d1974 2
a1975 2
    case TT_ResultSetID:
	size = writtenAnySize(DT_ResultSetID, qt->ResultSetID);
d1977 2
a1978 2
    case TT_Operator:
	size = writtenStringSize(DT_Operator, qt->Operator);
d1980 1
a1980 1
    default:
d1984 1
a1984 1
    }
d1986 1
a1986 1
    return (size);
d1995 2
a1996 1
any *writeQuery(query_term **terms)
d1998 7
a2004 7
    any *info = NULL;
    char *writePos = NULL;
    char *data = NULL;
    unsigned long size = 0;
    long remaining = 0;
    long i;
    query_term *qt = NULL;
d2006 2
a2007 2
    if (terms == NULL)
	return (NULL);
d2009 3
a2011 3
    /* calculate the size of write buffer */
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	size += getQueryTermSize(qt);
d2013 1
a2013 1
    data = (char *) s_malloc((size_t) size);
d2015 5
a2019 5
    /* write the terms */
    writePos = data;
    remaining = size;
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	writePos = writeQueryTerm(qt, writePos, &remaining);
d2021 1
a2021 1
    info = makeAny(size, data);
d2023 1
a2023 1
    return (info);
d2028 2
a2029 1
query_term **readQuery(any *info)
d2031 5
a2035 5
    char *readPos = info->bytes;
    query_term **terms = NULL;
    query_term *qt = NULL;
    long numTerms = 0L;
    char tmp[100];
d2037 2
a2038 2
    sprintf(tmp, "readquery: bytes: %ld", info->size);
    log_write(tmp);
d2040 2
a2041 2
    while (readPos < info->bytes + info->size) {
	readPos = readQueryTerm(&qt, readPos);
d2043 2
a2044 7
	if (terms == NULL) {
	    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 2));
	} else {
	    terms =
		(query_term **) s_realloc((char *) terms,
					  (size_t) (sizeof(query_term *) *
						      (numTerms + 2)));
d2046 9
a2054 4
	if (qt == NULL)
	    log_write("qt = null");
	terms[numTerms++] = qt;
	terms[numTerms] = NULL;
d2057 1
a2057 1
    return (terms);
d2062 1
d2064 3
a2066 3
 *	Routines originally from panic.c -- FM
 *
 *----------------------------------------------------------------------*/
d2068 5
a2072 5
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Morris@@think.com
 */
d2081 1
a2081 1
static void exitAction(long error);
d2083 2
a2084 1
static void exitAction(long error GCC_UNUSED)
d2086 4
a2089 4
    long i;

    for (i = 0; i < 100000; i++) ;
    exit(0);
d2096 2
a2097 1
void panic(char *format,...)
d2099 1
a2099 1
    va_list ap;			/* the variable arguments */
d2101 5
a2105 5
    fprintf(stderr, PANIC_HEADER);
    LYva_start(ap, format);	/* init ap */
    vfprintf(stderr, format, ap);	/* print the contents */
    va_end(ap);			/* free ap */
    fflush(stderr);
d2107 1
a2107 1
    exitAction(0);
d2112 1
d2114 3
a2116 3
 *	Routines originally from cutil.c -- FM
 *
 *----------------------------------------------------------------------*/
d2118 6
a2123 6
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
d2127 2
a2128 1
void fs_checkPtr(void *ptr)
d2131 2
a2132 2
    if (ptr == NULL)
	panic("checkPtr found a NULL pointer");
d2137 2
a2138 1
void *fs_malloc(size_t size)
d2141 1
a2141 1
    register void *ptr = NULL;
d2143 2
a2144 2
    ptr = (void *) calloc((size_t) size, (size_t) 1);
    s_checkPtr(ptr);
d2146 1
a2146 1
    return (ptr);
d2151 2
a2152 1
void *fs_realloc(void *ptr, size_t size)
d2158 1
a2158 1
    register void *nptr = NULL;
d2160 2
a2161 2
    if (ptr == NULL)		/* this is really a malloc */
	return (s_malloc(size));
d2163 2
a2164 2
    nptr = (void *) realloc(ptr, size);
    s_checkPtr(ptr);
d2166 1
a2166 1
    return (nptr);
d2171 2
a2172 1
void fs_free(void *ptr)
d2175 1
a2175 1
    if (ptr != NULL)		/* some non-ansi compilers/os's cant handle freeing null */
d2177 2
a2178 2
	free(ptr);
	ptr = NULL;
d2184 2
a2185 1
char *s_strdup(char *s)
d2192 2
a2193 5
    unsigned long len;
    char *copy = NULL;

    if (s == NULL)		/* saftey check to postpone stupid errors */
	return (NULL);
d2195 2
a2196 2
    len = strlen(s);		/* length of string - terminator */
    copy = (char *) s_malloc((size_t) (sizeof(char) * (len + 1)));
d2198 4
a2201 2
    strncpy(copy, s, len + 1);
    return (copy);
d2206 2
a2207 1
char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal)
d2213 2
a2214 2
    size_t dstSize = strlen(dst);
    size_t srcSize = strlen(src);
d2216 10
a2225 11
    if (dstSize + srcSize < maxTotal)	/* use regular old strncat */
	return (strncat(dst, src, maxToAdd));
    else {
	size_t truncateTo = maxTotal - dstSize - 1;
	char saveChar = src[truncateTo];
	char *result = NULL;

	src[truncateTo] = '\0';
	result = strncat(dst, src, maxToAdd);
	src[truncateTo] = saveChar;
	return (result);
d2233 3
a2235 4
    unsigned char ch = long_ch & 0xFF;	/* just want one byte */

    /* when ansi is the way of the world, this can be tolower */
    return (((ch >= 'A') && (ch <= 'Z')) ? (ch + 'a' - 'A') : ch);
d2240 6
a2245 7
    long i = 0;

    while (word[i] != '\0') {
	word[i] = char_downcase((unsigned long) word[i]);
	i++;
    }
    return (word);
d2249 1
a2249 1
#endif /* VMS */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d43 1
a43 1
#undef MAXINT	/* we don't need it here, and www_tcp.h may conflict */
d223 1
a223 1
		  (int)( request_length +HEADER_LENGTH)) )
d653 3
a655 3
  if (databases != NULL) {
    for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	if (query->DatabaseNames == NULL)
d662 2
a663 2
	}
    }
d666 3
a668 3
  if (elements != NULL) {
    for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	if (query->ElementSetNames == NULL)
d720 3
a722 3
  if (query->DatabaseNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL; ptr = query->DatabaseNames[++i]) {
	if (scratch == NULL)
d730 1
a730 1
	}
d736 4
a739 4
  if (query->ElementSetNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->ElementSetNames[i]; ptr != NULL; ptr = query->ElementSetNames[++i]) {
	if (scratch == NULL) {
	    if (query->ElementSetNames[i+1] == NULL) /* there is a single element set name */
d752 1
a752 1
	  }
d956 2
a957 2
  if (diag != NULL) {
    if (diag->ADDINFO != NULL)
d959 2
a960 2
    s_free(diag);
  }
d2035 1
a2035 1
  char tmp[100];
d2037 2
a2038 2
  sprintf(tmp,"readquery: bytes: %ld",info->size);
  log_write(tmp);
d2051 1
a2051 1
      if (qt == NULL)
@

