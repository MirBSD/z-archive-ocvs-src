head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.4
	tg-mergefixes-1-branch:1.1.3.4.0.8
	tg-mergefixes-1-base:1.1.3.4
	MIROS_X:1.1.3.4.0.6
	MIROS_X_BASE:1.1.3.4
	MIRBSD_XP_MIRPPC:1.1.3.4.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.1.3.4
	MIRBSD_XP_SPARC:1.1.3.4.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.1.3.2
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.1.3.2.0.6
	MIRBSD_7:1.1.3.2.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.1.3.2
	MIRBSD_7_DEV:1.1.3.2.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.19.52.49;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.01;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.00;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.37;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.54;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.10;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.20;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.47.49;	author tg;	state Stab;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/*			NEWS ACCESS				HTNews.c
 *			===========
 *
 * History:
 *	26 Sep 90	Written TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 */

#include <HTUtils.h>		/* Coding convention macros */

#ifndef DISABLE_NEWS

/* Implements:
*/
#include <HTNews.h>

#include <HTCJK.h>
#include <HTMIME.h>
#include <HTFont.h>
#include <HTFormat.h>
#include <HTTCP.h>
#include <LYUtils.h>
#include <LYStrings.h>

#define NEWS_PORT 119		/* See rfc977 */
#define SNEWS_PORT 563		/* See Lou Montulli */
#define APPEND			/* Use append methods */
int HTNewsChunkSize = 30;	/* Number of articles for quick display */
int HTNewsMaxChunk = 40;	/* Largest number of articles in one window */

#ifndef DEFAULT_NEWS_HOST
#define DEFAULT_NEWS_HOST "news"
#endif /* DEFAULT_NEWS_HOST */

#ifndef NEWS_SERVER_FILE
#define NEWS_SERVER_FILE "/usr/local/lib/rn/server"
#endif /* NEWS_SERVER_FILE */

#ifndef NEWS_AUTH_FILE
#define NEWS_AUTH_FILE ".newsauth"
#endif /* NEWS_AUTH_FILE */

#ifdef USE_SSL
static SSL *Handle = NULL;
static int channel_s = 1;

#define NEWS_NETWRITE(sock, buff, size) \
	(Handle ? SSL_write(Handle, buff, size) : NETWRITE(sock, buff, size))
#define NEWS_NETCLOSE(sock) \
	{ (void)NETCLOSE(sock); if (Handle) { SSL_free(Handle); Handle = NULL; } }
static char HTNewsGetCharacter(void);

#define NEXT_CHAR HTNewsGetCharacter()
#else
#define NEWS_NETWRITE  NETWRITE
#define NEWS_NETCLOSE  NETCLOSE
#define NEXT_CHAR HTGetCharacter()
#endif /* USE_SSL */

#include <HTML.h>
#include <HTAccess.h>
#include <HTParse.h>
#include <HTFormat.h>
#include <HTAlert.h>

#include <LYNews.h>
#include <LYGlobalDefs.h>
#include <LYLeaks.h>

#define SnipIn(d,fmt,len,s)      sprintf(d, fmt,      (int)sizeof(d)-len, s)
#define SnipIn2(d,fmt,tag,len,s) sprintf(d, fmt, tag, (int)sizeof(d)-len, s)

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};
struct _HTStream {
    HTStreamClass *isa;
};

#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
#define GROUP_NAME_LENGTH	256	/* Maximum length of group name */

/*
 *  Module-wide variables.
 */
char *HTNewsHost = NULL;	/* Default host */
static char *NewsHost = NULL;	/* Current host */
static char *NewsHREF = NULL;	/* Current HREF prefix */
static int s;			/* Socket for NewsHost */
static int HTCanPost = FALSE;	/* Current POST permission */
static char response_text[LINE_LENGTH + 1];	/* Last response */

/* static HText *	HT;	*//* the new hypertext */
static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */
static HTStream *rawtarget = NULL;	/* The output sink for rawtext */
static HTStreamClass rawtargetClass;	/* Copy of fn addresses */
static HTParentAnchor *node_anchor;	/* Its anchor */
static int diagnostic;		/* level: 0=none 2=source */
static BOOL rawtext = NO;	/* Flag: HEAD or -mime_headers */
static HTList *NNTP_AuthInfo = NULL;	/* AUTHINFO database */
static char *name = NULL;
static char *address = NULL;
static char *dbuf = NULL;	/* dynamic buffer for long messages etc. */

#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define RAW_PUTS(s) (*rawtargetClass.put_string)(rawtarget, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*targetClass.end_element)(target, e, 0)
#define FREE_TARGET if (rawtext) (*rawtargetClass._free)(rawtarget); \
			else (*targetClass._free)(target)
#define ABORT_TARGET if (rawtext) (*rawtargetClass._abort)(rawtarget, NULL); \
			else (*targetClass._abort)(target, NULL)

typedef struct _NNTPAuth {
    char *host;
    char *user;
    char *pass;
} NNTPAuth;

#ifdef LY_FIND_LEAKS
static void free_news_globals(void)
{
    if (s >= 0) {
	NEWS_NETCLOSE(s);
	s = -1;
    }
    FREE(HTNewsHost);
    FREE(NewsHost);
    FREE(NewsHREF);
    FREE(name);
    FREE(address);
    FREE(dbuf);
}
#endif /* LY_FIND_LEAKS */

static void free_NNTP_AuthInfo(void)
{
    HTList *cur = NNTP_AuthInfo;
    NNTPAuth *auth = NULL;

    if (!cur)
	return;

    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
	FREE(auth->host);
	FREE(auth->user);
	FREE(auth->pass);
	FREE(auth);
    }
    HTList_delete(NNTP_AuthInfo);
    NNTP_AuthInfo = NULL;
    return;
}

/*
 * Initialize the authentication list by loading the user's $HOME/.newsauth
 * file.  That file is part of tin's configuration and is used by a few other
 * programs.
 */
static void load_NNTP_AuthInfo(void)
{
    FILE *fp;
    char fname[LY_MAXPATH];
    char buffer[LINE_LENGTH + 1];

    LYAddPathToHome(fname, sizeof(fname), NEWS_AUTH_FILE);

    if ((fp = fopen(fname, "r")) != 0) {
	while (fgets(buffer, sizeof(buffer), fp) != 0) {
	    char the_host[LINE_LENGTH + 1];
	    char the_pass[LINE_LENGTH + 1];
	    char the_user[LINE_LENGTH + 1];

	    if (sscanf(buffer, "%s%s%s", the_host, the_pass, the_user) == 3
		&& strlen(the_host) != 0
		&& strlen(the_pass) != 0
		&& strlen(the_user) != 0) {
		NNTPAuth *auth = typecalloc(NNTPAuth);

		if (auth == NULL)
		    break;
		StrAllocCopy(auth->host, the_host);
		StrAllocCopy(auth->pass, the_pass);
		StrAllocCopy(auth->user, the_user);

		HTList_appendObject(NNTP_AuthInfo, auth);
	    }
	}
	fclose(fp);
    }
}

const char *HTGetNewsHost(void)
{
    return HTNewsHost;
}

void HTSetNewsHost(const char *value)
{
    StrAllocCopy(HTNewsHost, value);
}

/*	Initialisation for this module
 *	------------------------------
 *
 *	Except on the NeXT, we pick up the NewsHost name from
 *
 *	1.	Environment variable NNTPSERVER
 *	2.	File NEWS_SERVER_FILE
 *	3.	Compilation time macro DEFAULT_NEWS_HOST
 *	4.	Default to "news"
 *
 *	On the NeXT, we pick up the NewsHost name from, in order:
 *
 *	1.	WorldWideWeb default "NewsHost"
 *	2.	Global default "NewsHost"
 *	3.	News default "NewsHost"
 *	4.	Compilation time macro DEFAULT_NEWS_HOST
 *	5.	Default to "news"
 */
static BOOL initialized = NO;
static BOOL initialize(void)
{
#ifdef NeXTStep
    char *cp = NULL;
#endif

    /*
     * Get name of Host.
     */
#ifdef NeXTStep
    if ((cp = NXGetDefaultValue("WorldWideWeb", "NewsHost")) == 0) {
	if ((cp = NXGetDefaultValue("News", "NewsHost")) == 0) {
	    StrAllocCopy(HTNewsHost, DEFAULT_NEWS_HOST);
	}
    }
    if (cp) {
	StrAllocCopy(HTNewsHost, cp);
	cp = NULL;
    }
#else
    if (LYGetEnv("NNTPSERVER")) {
	StrAllocCopy(HTNewsHost, LYGetEnv("NNTPSERVER"));
	CTRACE((tfp, "HTNews: NNTPSERVER defined as `%s'\n",
		HTNewsHost));
    } else {
	FILE *fp = fopen(NEWS_SERVER_FILE, TXT_R);

	if (fp) {
	    char server_name[MAXHOSTNAMELEN + 1];

	    if (fgets(server_name, sizeof server_name, fp) != NULL) {
		char *p = strchr(server_name, '\n');

		if (p != NULL)
		    *p = '\0';
		StrAllocCopy(HTNewsHost, server_name);
		CTRACE((tfp, "HTNews: File %s defines news host as `%s'\n",
			NEWS_SERVER_FILE, HTNewsHost));
	    }
	    fclose(fp);
	}
    }
    if (!HTNewsHost)
	StrAllocCopy(HTNewsHost, DEFAULT_NEWS_HOST);
#endif /* NeXTStep */

    s = -1;			/* Disconnected */
#ifdef LY_FIND_LEAKS
    atexit(free_news_globals);
#endif
    return YES;
}

/*	Send NNTP Command line to remote host & Check Response
 *	------------------------------------------------------
 *
 * On entry,
 *	command points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is an NNTP status.
 */
static int response(char *command)
{
    int result;
    char *p = response_text;
    int ich;

    if (command) {
	int status;
	int length = strlen(command);

	CTRACE((tfp, "NNTP command to be sent: %s", command));
#ifdef NOT_ASCII
	{
	    const char *p2;
	    char *q;
	    char ascii[LINE_LENGTH + 1];

	    for (p2 = command, q = ascii; *p2; p2++, q++) {
		*q = TOASCII(*p2);
	    }
	    status = NEWS_NETWRITE(s, ascii, length);
	}
#else
	status = NEWS_NETWRITE(s, (char *) command, length);
#endif /* NOT_ASCII */
	if (status < 0) {
	    CTRACE((tfp, "HTNews: Unable to send command. Disconnecting.\n"));
	    NEWS_NETCLOSE(s);
	    s = -1;
	    return status;
	}			/* if bad status */
    }
    /* if command to be sent */
    for (;;) {
	ich = NEXT_CHAR;
	if (((*p++ = (char) ich) == LF) ||
	    (p == &response_text[LINE_LENGTH])) {
	    *--p = '\0';	/* Terminate the string */
	    CTRACE((tfp, "NNTP Response: %s\n", response_text));
	    sscanf(response_text, "%d", &result);
	    return result;
	}
	/* if end of line */
	if (ich == EOF) {
	    *(p - 1) = '\0';
	    if (interrupted_in_htgetcharacter) {
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
	    } else {
		CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n",
			s));
	    }
	    NEWS_NETCLOSE(s);	/* End of file, close socket */
	    s = -1;
	    if (interrupted_in_htgetcharacter) {
		interrupted_in_htgetcharacter = 0;
		return (HT_INTERRUPTED);
	    }
	    return ((int) EOF);	/* End of file on response */
	}
    }				/* Loop over characters */
}

/*	Case insensitive string comparisons
 *	-----------------------------------
 *
 * On entry,
 *	template must be already in upper case.
 *	unknown may be in upper or lower or mixed case to match.
 */
static BOOL match(const char *unknown, const char *ctemplate)
{
    const char *u = unknown;
    const char *t = ctemplate;

    for (; *u && *t && (TOUPPER(*u) == *t); u++, t++) ;		/* Find mismatch or end */
    return (BOOL) (*t == 0);	/* OK if end of template */
}

typedef enum {
    NNTPAUTH_ERROR = 0,		/* general failure */
    NNTPAUTH_OK = 281,		/* authenticated successfully */
    NNTPAUTH_CLOSE = 502	/* server probably closed connection */
} NNTPAuthResult;

/*
 *  This function handles nntp authentication. - FM
 */
static NNTPAuthResult HTHandleAuthInfo(char *host)
{
    HTList *cur = NULL;
    NNTPAuth *auth = NULL;
    char *UserName = NULL;
    char *PassWord = NULL;
    char *msg = NULL;
    char buffer[512];
    int status, tries;

    /*
     * Make sure we have an interactive user and a host.  - FM
     */
    if (dump_output_immediately || !(host && *host))
	return NNTPAUTH_ERROR;

    /*
     * Check for an existing authorization entry.  - FM
     */
    if (NNTP_AuthInfo == NULL) {
	NNTP_AuthInfo = HTList_new();
	load_NNTP_AuthInfo();
#ifdef LY_FIND_LEAKS
	atexit(free_NNTP_AuthInfo);
#endif
    }

    cur = NNTP_AuthInfo;
    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
	if (!strcmp(auth->host, host)) {
	    UserName = auth->user;
	    PassWord = auth->pass;
	    break;
	}
    }

    /*
     * Handle the username.  - FM
     */
    buffer[sizeof(buffer) - 1] = '\0';
    tries = 3;

    while (tries) {
	if (UserName == NULL) {
	    HTSprintf0(&msg, gettext("Username for news host '%s':"), host);
	    UserName = HTPrompt(msg, NULL);
	    FREE(msg);
	    if (!(UserName && *UserName)) {
		FREE(UserName);
		return NNTPAUTH_ERROR;
	    }
	}
	sprintf(buffer, "AUTHINFO USER %.*s%c%c",
		(int) sizeof(buffer) - 17, UserName, CR, LF);
	if ((status = response(buffer)) < 0) {
	    if (status == HT_INTERRUPTED)
		_HTProgress(CONNECTION_INTERRUPTED);
	    else
		HTAlert(FAILED_CONNECTION_CLOSED);
	    if (auth) {
		if (auth->user != UserName) {
		    FREE(auth->user);
		    auth->user = UserName;
		}
	    } else {
		FREE(UserName);
	    }
	    return NNTPAUTH_CLOSE;
	}
	if (status == 281) {
	    /*
	     * Username is accepted and no password is required.  - FM
	     */
	    if (auth) {
		if (auth->user != UserName) {
		    FREE(auth->user);
		    auth->user = UserName;
		}
	    } else {
		/*
		 * Store the accepted username and no password.  - FM
		 */
		if ((auth = typecalloc(NNTPAuth)) != NULL) {
		    StrAllocCopy(auth->host, host);
		    auth->user = UserName;
		    HTList_appendObject(NNTP_AuthInfo, auth);
		}
	    }
	    return NNTPAUTH_OK;
	}
	if (status != 381) {
	    /*
	     * Not success, nor a request for the password, so it must be an
	     * error.  - FM
	     */
	    HTAlert(response_text);
	    tries--;
	    if ((tries > 0) && HTConfirm(gettext("Change username?"))) {
		if (!auth || auth->user != UserName) {
		    FREE(UserName);
		}
		if ((UserName = HTPrompt(gettext("Username:"), UserName))
		    != NULL &&
		    *UserName) {
		    continue;
		}
	    }
	    if (auth) {
		if (auth->user != UserName) {
		    FREE(auth->user);
		}
		FREE(auth->pass);
	    }
	    FREE(UserName);
	    return NNTPAUTH_ERROR;
	}
	break;
    }

    if (status == 381) {
	/*
	 * Handle the password.  - FM
	 */
	tries = 3;
	while (tries) {
	    if (PassWord == NULL) {
		HTSprintf0(&msg, gettext("Password for news host '%s':"), host);
		PassWord = HTPromptPassword(msg);
		FREE(msg);
		if (!(PassWord && *PassWord)) {
		    FREE(PassWord);
		    return NNTPAUTH_ERROR;
		}
	    }
	    sprintf(buffer, "AUTHINFO PASS %.*s%c%c",
		    (int) sizeof(buffer) - 17, PassWord, CR, LF);
	    if ((status = response(buffer)) < 0) {
		if (status == HT_INTERRUPTED) {
		    _HTProgress(CONNECTION_INTERRUPTED);
		} else {
		    HTAlert(FAILED_CONNECTION_CLOSED);
		}
		if (auth) {
		    if (auth->user != UserName) {
			FREE(auth->user);
			auth->user = UserName;
		    }
		    if (auth->pass != PassWord) {
			FREE(auth->pass);
			auth->pass = PassWord;
		    }
		} else {
		    FREE(UserName);
		    FREE(PassWord);
		}
		return NNTPAUTH_CLOSE;
	    }
	    if (status == 502) {
		/*
		 * That's what INN's nnrpd returns.  It closes the connection
		 * after this.  - kw
		 */
		HTAlert(response_text);
		if (auth) {
		    if (auth->user == UserName)
			UserName = NULL;
		    FREE(auth->user);
		    if (auth->pass == PassWord)
			PassWord = NULL;
		    FREE(auth->pass);
		}
		FREE(UserName);
		FREE(PassWord);
		return NNTPAUTH_CLOSE;
	    }
	    if (status == 281) {
		/*
		 * Password also is accepted, and everything has been stored. 
		 * - FM
		 */
		if (auth) {
		    if (auth->user != UserName) {
			FREE(auth->user);
			auth->user = UserName;
		    }
		    if (auth->pass != PassWord) {
			FREE(auth->pass);
			auth->pass = PassWord;
		    }
		} else {
		    if ((auth = typecalloc(NNTPAuth)) != NULL) {
			StrAllocCopy(auth->host, host);
			auth->user = UserName;
			auth->pass = PassWord;
			HTList_appendObject(NNTP_AuthInfo, auth);
		    }
		}
		return NNTPAUTH_OK;
	    }
	    /*
	     * Not success, so it must be an error.  - FM
	     */
	    HTAlert(response_text);
	    if (!auth || auth->pass != PassWord) {
		FREE(PassWord);
	    } else {
		PassWord = NULL;
	    }
	    tries--;
	    if ((tries > 0) && HTConfirm(gettext("Change password?"))) {
		continue;
	    }
	    if (auth) {
		if (auth->user == UserName)
		    UserName = NULL;
		FREE(auth->user);
		FREE(auth->pass);
	    }
	    FREE(UserName);
	    break;
	}
    }

    return NNTPAUTH_ERROR;
}

/*	Find Author's name in mail address
 *	----------------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "Tim Berners-Lee" if given any of
 *	" Tim Berners-Lee <tim@@online.cern.ch> "
 *  or	" tim@@online.cern.ch ( Tim Berners-Lee ) "
 */
static char *author_name(char *email)
{
    char *p, *e;

    StrAllocCopy(name, email);
    CTRACE((tfp, "Trying to find name in: %s\n", name));

    if ((p = strrchr(name, '(')) && (e = strrchr(name, ')'))) {
	if (e > p) {
	    *e = '\0';		/* Chop off everything after the ')'  */
	    return HTStrip(p + 1);	/* Remove leading and trailing spaces */
	}
    }

    if ((p = strrchr(name, '<')) && (e = strrchr(name, '>'))) {
	if (e++ > p) {
	    while ((*p++ = *e++) != 0)	/* Remove <...> */
		;
	    return HTStrip(name);	/* Remove leading and trailing spaces */
	}
    }

    return HTStrip(name);	/* Default to the whole thing */
}

/*	Find Author's mail address
 *	--------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "montulli@@spaced.out.galaxy.net" if given any of
 *	" Lou Montulli <montulli@@spaced.out.galaxy.net> "
 *  or	" montulli@@spaced.out.galaxy.net ( Lou "The Stud" Montulli ) "
 */
static char *author_address(char *email)
{
    char *p, *at, *e;

    StrAllocCopy(address, email);
    CTRACE((tfp, "Trying to find address in: %s\n", address));

    if ((p = strrchr(address, '<'))) {
	if ((e = strrchr(p, '>')) && (at = strrchr(p, '@@'))) {
	    if (at < e) {
		*e = '\0';	/* Remove > */
		return HTStrip(p + 1);	/* Remove leading and trailing spaces */
	    }
	}
    }

    if ((p = strrchr(address, '(')) &&
	(e = strrchr(address, ')')) && (at = strchr(address, '@@'))) {
	if (e > p && at < e) {
	    *p = '\0';		/* Chop off everything after the ')'  */
	    return HTStrip(address);	/* Remove leading and trailing spaces */
	}
    }

    if ((at = strrchr(address, '@@')) && at > address) {
	p = (at - 1);
	e = (at + 1);
	while (p > address && !isspace(UCH(*p)))
	    p--;
	while (*e && !isspace(UCH(*e)))
	    e++;
	*e = 0;
	return HTStrip(p);
    }

    /*
     * Default to the first word.
     */
    p = address;
    while (isspace(UCH(*p)))
	p++;			/* find first non-space */
    e = p;
    while (!isspace(UCH(*e)) && *e != '\0')
	e++;			/* find next space or end */
    *e = '\0';			/* terminate space */

    return (p);
}

/*	Start anchor element
 *	--------------------
 */
static void start_anchor(const char *href)
{
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
    value[HTML_A_HREF] = href;
    (*targetClass.start_element) (target, HTML_A, present, value, -1, 0);
}

/*	Start link element
 *	------------------
 */
static void start_link(const char *href, const char *rev)
{
    BOOL present[HTML_LINK_ATTRIBUTES];
    const char *value[HTML_LINK_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_LINK_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_LINK_HREF || i == HTML_LINK_REV);
    value[HTML_LINK_HREF] = href;
    value[HTML_LINK_REV] = rev;
    (*targetClass.start_element) (target, HTML_LINK, present, value, -1, 0);
}

/*	Start list element
 *	------------------
 */
static void start_list(int seqnum)
{
    BOOL present[HTML_OL_ATTRIBUTES];
    const char *value[HTML_OL_ATTRIBUTES];
    char SeqNum[20];
    int i;

    for (i = 0; i < HTML_OL_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_OL_SEQNUM || i == HTML_OL_START);
    sprintf(SeqNum, "%d", seqnum);
    value[HTML_OL_SEQNUM] = SeqNum;
    value[HTML_OL_START] = SeqNum;
    (*targetClass.start_element) (target, HTML_OL, present, value, -1, 0);
}

/*	Paste in an Anchor
 *	------------------
 *
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext reference address,
 *		terminated by white space, comma, NULL or '>'
 */
static void write_anchor(const char *text, const char *addr)
{
    char href[LINE_LENGTH + 1];
    const char *p;
    char *q;

    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p != ','); p++) ;
    if (strlen(NewsHREF) + (p - addr) + 1 < sizeof(href)) {
	q = href;
	strcpy(q, NewsHREF);
	strncat(q, addr, p - addr);	/* Make complete hypertext reference */
    } else {
	q = NULL;
	HTSprintf0(&q, "%s%.*s", NewsHREF, p - addr, addr);
    }

    start_anchor(q);
    PUTS(text);
    END(HTML_A);

    if (q != href)
	FREE(q);
}

/*	Write list of anchors
 *	---------------------
 *
 *	We take a pointer to a list of objects, and write out each,
 *	generating an anchor for each.
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to a comma or space separated list of addresses.
 * On exit,
 *	*text	is NOT any more chopped up into substrings.
 */
static void write_anchors(char *text)
{
    char *start = text;
    char *end;
    char c;

    for (;;) {
	for (; *start && (WHITE(*start)); start++) ;	/* Find start */
	if (!*start)
	    return;		/* (Done) */
	for (end = start;
	     *end && (*end != ' ') && (*end != ','); end++) ;	/* Find end */
	if (*end)
	    end++;		/* Include comma or space but not NULL */
	c = *end;
	*end = '\0';
	if (*start == '<')
	    write_anchor(start, start + 1);
	else
	    write_anchor(start, start);
	START(HTML_BR);
	*end = c;
	start = end;		/* Point to next one */
    }
}

/*	Abort the connection					abort_socket
 *	--------------------
 */
static void abort_socket(void)
{
    CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n", s));
    NEWS_NETCLOSE(s);		/* End of file, close socket */
    if (rawtext) {
	RAW_PUTS("Network Error: connection lost\n");
    } else {
	PUTS("Network Error: connection lost");
	PUTC('\n');
    }
    s = -1;			/* End of file on response */
}

/*
 *  Determine if a line is a valid header line.			valid_header
 *  -------------------------------------------
 */
static BOOLEAN valid_header(char *line)
{
    char *colon, *space;

    /*
     * Blank or tab in first position implies this is a continuation header.
     */
    if (line[0] == ' ' || line[0] == '\t')
	return (TRUE);

    /*
     * Just check for initial letter, colon, and space to make sure we discard
     * only invalid headers.
     */
    colon = strchr(line, ':');
    space = strchr(line, ' ');
    if (isalpha(UCH(line[0])) && colon && space == colon + 1)
	return (TRUE);

    /*
     * Anything else is a bad header -- it should be ignored.
     */
    return (FALSE);
}

/*	post in an Article					post_article
 *	------------------
 *			(added by FM, modeled on Lynx's previous mini inews)
 *
 *	Note the termination condition of a single dot on a line by itself.
 *
 *  On entry,
 *	s		Global socket number is OK
 *	postfile	file with header and article to post.
 */
static void post_article(char *postfile)
{
    char line[512];
    char buf[512];
    char crlf[3];
    char *cp;
    int status;
    FILE *fd;
    int in_header = 1, seen_header = 0, seen_fromline = 0;
    int blen = 0, llen = 0;

    /*
     * Open the temporary file with the nntp headers and message body.  - FM
     */
    if ((fd = fopen(NonNull(postfile), TXT_R)) == NULL) {
	HTAlert(FAILED_CANNOT_OPEN_POST);
	return;
    }

    /*
     * Read the temporary file and post in maximum 512 byte chunks.  - FM
     */
    buf[0] = '\0';
    sprintf(crlf, "%c%c", CR, LF);
    while (fgets(line, sizeof(line) - 2, fd) != NULL) {
	if ((cp = strchr(line, '\n')) != NULL)
	    *cp = '\0';
	if (line[0] == '.') {
	    /*
	     * A single '.' means end of transmission for nntp.  Lead dots on
	     * lines normally are trimmed and the EOF is not registered if the
	     * dot was not followed by CRLF.  We prepend an extra dot for any
	     * line beginning with one, to retain the one intended, as well as
	     * avoid a false EOF signal.  We know we have room for it in the
	     * buffer, because we normally send when it would exceed 510.  - FM
	     */
	    strcat(buf, ".");
	    blen++;
	}
	llen = strlen(line);
	if (in_header && !strncasecomp(line, "From:", 5)) {
	    seen_header = 1;
	    seen_fromline = 1;
	}
	if (in_header && line[0] == '\0') {
	    if (seen_header) {
		in_header = 0;
		if (!seen_fromline) {
		    if (blen >= (int) sizeof(buf) - 35) {
			NEWS_NETWRITE(s, buf, blen);
			buf[blen = 0] = 0;
		    }
		    strcat(buf, "From: anonymous@@nowhere.you.know");
		    strcat(buf, crlf);
		    blen += 34;
		}
	    } else {
		continue;
	    }
	} else if (in_header) {
	    if (valid_header(line)) {
		seen_header = 1;
	    } else {
		continue;
	    }
	}
	strcat(line, crlf);
	llen += 2;
	if ((blen + llen) >= (int) sizeof(buf) - 1) {
	    NEWS_NETWRITE(s, buf, blen);
	    buf[blen = 0] = 0;
	}
	strcat(buf, line);
	blen += llen;
    }
    fclose(fd);
    HTSYS_remove(postfile);

    /*
     * Send the nntp EOF and get the server's response.  - FM
     */
    if (blen >= (int) sizeof(buf) - 4) {
	NEWS_NETWRITE(s, buf, blen);
	buf[blen = 0] = 0;
    }
    strcat(buf, ".");
    strcat(buf, crlf);
    blen += 3;
    NEWS_NETWRITE(s, buf, blen);

    status = response(NULL);
    if (status == 240) {
	/*
	 * Successful post.  - FM
	 */
	HTProgress(response_text);
    } else {
	/*
	 * Shucks, something went wrong.  - FM
	 */
	HTAlert(response_text);
    }
}

#ifdef SH_EX			/* for MIME */
#ifdef NEWS_DEBUG
/* for DEBUG 1997/11/07 (Fri) 17:20:16 */
void debug_print(unsigned char *p)
{
    while (*p) {
	if (*p == '\0')
	    break;
	if (*p == 0x1b)
	    printf("[ESC]");
	else if (*p == '\n')
	    printf("[NL]");
	else if (*p < ' ' || *p >= 0x80)
	    printf("(%02x)", *p);
	else
	    putchar(*p);
	p++;
    }
    printf("]\n");
}
#endif

static char *decode_mime(char *str)
{
    char temp[LINE_LENGTH];	/* FIXME: what determines the actual size? */
    char *p, *q;

    if (str == NULL)
	return "";

    if (HTCJK != JAPANESE)
	return str;

    LYstrncpy(temp, str, sizeof(temp) - 1);
    q = temp;
    while ((p = strchr(q, '=')) != 0) {
	if (p[1] == '?') {
	    HTmmdecode(p, p);
	    q = p + 2;
	} else {
	    q = p + 1;
	}
    }
#ifdef NEWS_DEBUG
    printf("new=[");
    debug_print(temp);
#endif
    HTrjis(temp, temp);
    strcpy(str, temp);

    return str;
}
#else /* !SH_EX */
static char *decode_mime(char *str)
{
    HTmmdecode(str, str);
    HTrjis(str, str);
    return str;
}
#endif

/*	Read in an Article					read_article
 *	------------------
 *
 *	Note the termination condition of a single dot on a line by itself.
 *	RFC 977 specifies that the line "folding" of RFC850 is not used, so we
 *	do not handle it here.
 *
 * On entry,
 *	s	Global socket number is OK
 *	HT	Global hypertext object is ready for appending text
 */
static int read_article(HTParentAnchor *thisanchor)
{
    char line[LINE_LENGTH + 1];
    char *full_line = NULL;
    char *subject = NULL;	/* Subject string           */
    char *from = NULL;		/* From string              */
    char *replyto = NULL;	/* Reply-to string          */
    char *date = NULL;		/* Date string              */
    char *organization = NULL;	/* Organization string      */
    char *references = NULL;	/* Hrefs for other articles */
    char *newsgroups = NULL;	/* Newsgroups list          */
    char *followupto = NULL;	/* Followup list            */
    char *href = NULL;
    char *p = line;
    char *cp;
    const char *ccp;
    BOOL done = NO;

    /*
     * Read in the HEADer of the article.
     *
     * The header fields are either ignored, or formatted and put into the
     * text.
     */
    if (!diagnostic && !rawtext) {
	while (!done) {
	    int ich = NEXT_CHAR;

	    *p++ = (char) ich;
	    if (ich == EOF) {
		if (interrupted_in_htgetcharacter) {
		    interrupted_in_htgetcharacter = 0;
		    CTRACE((tfp,
			    "HTNews: Interrupted on read, closing socket %d\n",
			    s));
		    NEWS_NETCLOSE(s);
		    s = -1;
		    return (HT_INTERRUPTED);
		}
		abort_socket();	/* End of file, close socket */
		return (HT_LOADED);	/* End of file on response */
	    }
	    if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
		*--p = '\0';	/* Terminate the string */
		CTRACE((tfp, "H %s\n", line));

		if (line[0] == '\t' || line[0] == ' ') {
		    int i = 0;

		    while (line[i]) {
			if (line[i] == '\t')
			    line[i] = ' ';
			i++;
		    }
		    if (full_line == NULL) {
			StrAllocCopy(full_line, line);
		    } else {
			StrAllocCat(full_line, line);
		    }
		} else {
		    StrAllocCopy(full_line, line);
		}

		if (full_line[0] == '.') {
		    /*
		     * End of article?
		     */
		    if (UCH(full_line[1]) < ' ') {
			done = YES;
			break;
		    }
		} else if (UCH(full_line[0]) < ' ') {
		    break;	/* End of Header? */

		} else if (match(full_line, "SUBJECT:")) {
		    StrAllocCopy(subject, HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(subject);
		} else if (match(full_line, "DATE:")) {
		    StrAllocCopy(date, HTStrip(strchr(full_line, ':') + 1));

		} else if (match(full_line, "ORGANIZATION:")) {
		    StrAllocCopy(organization,
				 HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(organization);

		} else if (match(full_line, "FROM:")) {
		    StrAllocCopy(from, HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(from);

		} else if (match(full_line, "REPLY-TO:")) {
		    StrAllocCopy(replyto, HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(replyto);

		} else if (match(full_line, "NEWSGROUPS:")) {
		    StrAllocCopy(newsgroups, HTStrip(strchr(full_line, ':') + 1));

		} else if (match(full_line, "REFERENCES:")) {
		    StrAllocCopy(references, HTStrip(strchr(full_line, ':') + 1));

		} else if (match(full_line, "FOLLOWUP-TO:")) {
		    StrAllocCopy(followupto, HTStrip(strchr(full_line, ':') + 1));

		} else if (match(full_line, "MESSAGE-ID:")) {
		    char *msgid = HTStrip(full_line + 11);

		    if (msgid[0] == '<' && msgid[strlen(msgid) - 1] == '>') {
			msgid[strlen(msgid) - 1] = '\0';	/* Chop > */
			msgid++;	/* Chop < */
			HTAnchor_setMessageID(thisanchor, msgid);
		    }

		}		/* end if match */
		p = line;	/* Restart at beginning */
	    }			/* if end of line */
	}			/* Loop over characters */
	FREE(full_line);

	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	if (subject && *subject != '\0')
	    PUTS(subject);
	else
	    PUTS("No Subject");
	END(HTML_TITLE);
	PUTC('\n');
	/*
	 * Put in the owner as a link rel.
	 */
	if (from || replyto) {
	    char *temp = NULL;

	    StrAllocCopy(temp, author_address(replyto ? replyto : from));
	    StrAllocCopy(href, STR_MAILTO_URL);
	    if (strchr(temp, '%') || strchr(temp, '?')) {
		cp = HTEscape(temp, URL_XPALPHAS);
		StrAllocCat(href, cp);
		FREE(cp);
	    } else {
		StrAllocCat(href, temp);
	    }
	    start_link(href, "made");
	    PUTC('\n');
	    FREE(temp);
	}
	END(HTML_HEAD);
	PUTC('\n');

	START(HTML_H1);
	if (subject && *subject != '\0')
	    PUTS(subject);
	else
	    PUTS("No Subject");
	END(HTML_H1);
	PUTC('\n');

	if (subject)
	    FREE(subject);

	START(HTML_DLC);
	PUTC('\n');

	if (from || replyto) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("From:");
	    END(HTML_B);
	    PUTC(' ');
	    if (from)
		PUTS(from);
	    else
		PUTS(replyto);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');

	    if (!replyto)
		StrAllocCopy(replyto, from);
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Reply to:");
	    END(HTML_B);
	    PUTC(' ');
	    start_anchor(href);
	    if (*replyto != '<')
		PUTS(author_name(replyto));
	    else
		PUTS(author_address(replyto));
	    END(HTML_A);
	    START(HTML_BR);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');

	    FREE(from);
	    FREE(replyto);
	}

	if (date) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Date:");
	    END(HTML_B);
	    PUTC(' ');
	    PUTS(date);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    FREE(date);
	}

	if (organization) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Organization:");
	    END(HTML_B);
	    PUTC(' ');
	    PUTS(organization);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    FREE(organization);
	}

	/* sanitize some headers - kw */
	if (newsgroups &&
	    ((cp = strchr(newsgroups, '/')) ||
	     (cp = strchr(newsgroups, '(')))) {
	    *cp = '\0';
	}
	if (newsgroups && !*newsgroups) {
	    FREE(newsgroups);
	}
	if (followupto &&
	    ((cp = strchr(followupto, '/')) ||
	     (cp = strchr(followupto, '(')))) {
	    *cp = '\0';
	}
	if (followupto && !*followupto) {
	    FREE(followupto);
	}

	if (newsgroups && HTCanPost) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Newsgroups:");
	    END(HTML_B);
	    PUTC('\n');
	    MAYBE_END(HTML_DT);
	    START(HTML_DD);
	    write_anchors(newsgroups);
	    MAYBE_END(HTML_DD);
	    PUTC('\n');
	}

	if (followupto && !strcasecomp(followupto, "poster")) {
	    /*
	     * "Followup-To:  poster" has special meaning.  Don't use it to
	     * construct a newsreply link.  -kw
	     */
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Followup to:");
	    END(HTML_B);
	    PUTC(' ');
	    if (href) {
		start_anchor(href);
		PUTS("poster");
		END(HTML_A);
	    } else {
		PUTS("poster");
	    }
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    FREE(followupto);
	}

	if (newsgroups && HTCanPost) {
	    /*
	     * We have permission to POST to this host, so add a link for
	     * posting followups for this article.  - FM
	     */
	    if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
		StrAllocCopy(href, "snewsreply://");
	    else
		StrAllocCopy(href, "newsreply://");
	    StrAllocCat(href, NewsHost);
	    StrAllocCat(href, "/");
	    StrAllocCat(href, (followupto ? followupto : newsgroups));
	    if (*href == 'n' &&
		(ccp = HTAnchor_messageID(thisanchor)) && *ccp) {
		StrAllocCat(href, ";ref=");
		if (strchr(ccp, '<') || strchr(ccp, '&') ||
		    strchr(ccp, ' ') || strchr(ccp, ':') ||
		    strchr(ccp, '/') || strchr(ccp, '%') ||
		    strchr(ccp, ';')) {
		    char *cp1 = HTEscape(ccp, URL_XPALPHAS);

		    StrAllocCat(href, cp1);
		    FREE(cp1);
		} else {
		    StrAllocCat(href, ccp);
		}
	    }

	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Followup to:");
	    END(HTML_B);
	    PUTC(' ');
	    start_anchor(href);
	    if (strchr((followupto ? followupto : newsgroups), ',')) {
		PUTS("newsgroups");
	    } else {
		PUTS("newsgroup");
	    }
	    END(HTML_A);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	}
	FREE(newsgroups);
	FREE(followupto);

	if (references) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("References:");
	    END(HTML_B);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    START(HTML_DD);
	    write_anchors(references);
	    MAYBE_END(HTML_DD);
	    PUTC('\n');
	    FREE(references);
	}

	END(HTML_DLC);
	PUTC('\n');
	FREE(href);
    }

    if (rawtext) {
	/*
	 * No tags, and never do a PUTC.  - kw
	 */
	;
    } else if (diagnostic) {
	/*
	 * Read in the HEAD and BODY of the Article as XMP formatted text.  -
	 * FM
	 */
	START(HTML_XMP);
	PUTC('\n');
    } else {
	/*
	 * Read in the BODY of the Article as PRE formatted text.  - FM
	 */
	START(HTML_PRE);
	PUTC('\n');
    }

    p = line;
    while (!done) {
	int ich = NEXT_CHAR;

	*p++ = (char) ich;
	if (ich == EOF) {
	    if (interrupted_in_htgetcharacter) {
		interrupted_in_htgetcharacter = 0;
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
		NEWS_NETCLOSE(s);
		s = -1;
		return (HT_INTERRUPTED);
	    }
	    abort_socket();	/* End of file, close socket */
	    return (HT_LOADED);	/* End of file on response */
	}
	if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
	    *p++ = '\0';	/* Terminate the string */
	    CTRACE((tfp, "B %s", line));
#ifdef NEWS_DEBUG		/* 1997/11/09 (Sun) 15:56:11 */
	    debug_print(line);	/* @@@@@@ */
#endif
	    if (line[0] == '.') {
		/*
		 * End of article?
		 */
		if (UCH(line[1]) < ' ') {
		    done = YES;
		    break;
		} else {	/* Line starts with dot */
		    if (rawtext) {
			RAW_PUTS(&line[1]);
		    } else {
			PUTS(&line[1]);		/* Ignore first dot */
		    }
		}
	    } else {
		if (rawtext) {
		    RAW_PUTS(line);
		} else if (diagnostic || !scan_for_buried_news_references) {
		    /*
		     * All lines are passed as unmodified source.  - FM
		     */
		    PUTS(line);
		} else {
		    /*
		     * Normal lines are scanned for buried references to other
		     * articles.  Unfortunately, it could pick up mail
		     * addresses as well!  It also can corrupt uuencoded
		     * messages!  So we don't do this when fetching articles as
		     * WWW_SOURCE or when downloading (diagnostic is TRUE) or
		     * if the client has set scan_for_buried_news_references to
		     * FALSE.  Otherwise, we convert all "<...@@...>" strings
		     * preceded by "rticle " to "news:...@@..." links, and any
		     * strings that look like URLs to links.  - FM
		     */
		    char *l = line;
		    char *p2;

		    while ((p2 = strstr(l, "rticle <")) != NULL) {
			char *q = strrchr(p2, '>');
			char *at = strrchr(p2, '@@');

			if (q && at && at < q) {
			    char c = q[1];

			    q[1] = 0;	/* chop up */
			    p2 += 7;
			    *p2 = 0;
			    while (*l) {
				if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				    strncmp(l, "snews://", 8) &&
				    strncmp(l, "nntp://", 7) &&
				    strncmp(l, "snewspost:", 10) &&
				    strncmp(l, "snewsreply:", 11) &&
				    strncmp(l, "newspost:", 9) &&
				    strncmp(l, "newsreply:", 10) &&
				    strncmp(l, "ftp://", 6) &&
				    strncmp(l, "file:/", 6) &&
				    strncmp(l, "finger://", 9) &&
				    strncmp(l, "http://", 7) &&
				    strncmp(l, "https://", 8) &&
				    strncmp(l, "wais://", 7) &&
				    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
				    strncmp(l, "cso://", 6) &&
				    strncmp(l, "gopher://", 9)) {
				    PUTC(*l++);
				} else {
				    StrAllocCopy(href, l);
				    start_anchor(strtok(href, " \r\n\t,>)\""));
				    while (*l && !strchr(" \r\n\t,>)\"", *l))
					PUTC(*l++);
				    END(HTML_A);
				    FREE(href);
				}
			    }
			    *p2 = '<';	/* again */
			    *q = 0;
			    start_anchor(p2 + 1);
			    *q = '>';	/* again */
			    PUTS(p2);
			    END(HTML_A);
			    q[1] = c;	/* again */
			    l = q + 1;
			} else {
			    break;	/* line has unmatched <> */
			}
		    }
		    while (*l) {	/* Last bit of the line */
			if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
			    strncmp(l, "snews://", 8) &&
			    strncmp(l, "nntp://", 7) &&
			    strncmp(l, "snewspost:", 10) &&
			    strncmp(l, "snewsreply:", 11) &&
			    strncmp(l, "newspost:", 9) &&
			    strncmp(l, "newsreply:", 10) &&
			    strncmp(l, "ftp://", 6) &&
			    strncmp(l, "file:/", 6) &&
			    strncmp(l, "finger://", 9) &&
			    strncmp(l, "http://", 7) &&
			    strncmp(l, "https://", 8) &&
			    strncmp(l, "wais://", 7) &&
			    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
			    strncmp(l, "cso://", 6) &&
			    strncmp(l, "gopher://", 9))
			    PUTC(*l++);
			else {
			    StrAllocCopy(href, l);
			    start_anchor(strtok(href, " \r\n\t,>)\""));
			    while (*l && !strchr(" \r\n\t,>)\"", *l))
				PUTC(*l++);
			    END(HTML_A);
			    FREE(href);
			}
		    }
		}		/* if diagnostic or not scan_for_buried_news_references */
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */

    if (rawtext)
	return (HT_LOADED);

    if (diagnostic)
	END(HTML_XMP);
    else
	END(HTML_PRE);
    PUTC('\n');
    return (HT_LOADED);
}

/*	Read in a List of Newsgroups
 *	----------------------------
 *
 *  Note the termination condition of a single dot on a line by itself.
 *  RFC 977 specifies that the line "folding" of RFC850 is not used,
 *  so we do not handle it here.
 */
static int read_list(char *arg)
{
    char line[LINE_LENGTH + 1];
    char *p;
    BOOL done = NO;
    BOOL head = NO;
    BOOL tail = NO;
    BOOL skip_this_line = NO;
    BOOL skip_rest_of_line = NO;
    int listing = 0;
    char *pattern = NULL;
    int len = 0;

    /*
     * Support head or tail matches for groups to list.  - FM
     */
    if (arg && strlen(arg) > 1) {
	if (*arg == '*') {
	    tail = YES;
	    StrAllocCopy(pattern, (arg + 1));
	} else if (arg[strlen(arg) - 1] == '*') {
	    head = YES;
	    StrAllocCopy(pattern, arg);
	    pattern[strlen(pattern) - 1] = '\0';
	}
	if (tail || head) {
	    len = strlen(pattern);
	}

    }

    /*
     * Read the server's reply.
     *
     * The lines are scanned for newsgroup names and descriptions.
     */
    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    PUTS("Newsgroups");
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    PUTS("Newsgroups");
    END(HTML_H1);
    PUTC('\n');
    p = line;
    START(HTML_DLC);
    PUTC('\n');
    while (!done) {
	int ich = NEXT_CHAR;
	char ch = (char) ich;

	if (ich == EOF) {
	    if (interrupted_in_htgetcharacter) {
		interrupted_in_htgetcharacter = 0;
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
		NEWS_NETCLOSE(s);
		s = -1;
		return (HT_INTERRUPTED);
	    }
	    abort_socket();	/* End of file, close socket */
	    FREE(pattern);
	    return (HT_LOADED);	/* End of file on response */
	} else if (skip_this_line) {
	    if (ch == LF) {
		skip_this_line = skip_rest_of_line = NO;
		p = line;
	    }
	    continue;
	} else if (skip_rest_of_line) {
	    if (ch != LF) {
		continue;
	    }
	} else if (p == &line[LINE_LENGTH]) {
	    CTRACE((tfp, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch));
	    *p = '\0';
	    if (ch == LF) {
		;		/* Will be dealt with below */
	    } else if (WHITE(ch)) {
		ch = LF;	/* May treat as line without description */
		skip_this_line = YES;	/* ...and ignore until LF */
	    } else if (strchr(line, ' ') == NULL &&
		       strchr(line, '\t') == NULL) {
		/* No separator found */
		CTRACE((tfp, "HTNews..... group name too long, discarding.\n"));
		skip_this_line = YES;	/* ignore whole line */
		continue;
	    } else {
		skip_rest_of_line = YES;	/* skip until ch == LF found */
	    }
	} else {
	    *p++ = ch;
	}
	if (ch == LF) {
	    skip_rest_of_line = NO;	/* done, reset flag */
	    *p = '\0';		/* Terminate the string */
	    CTRACE((tfp, "B %s", line));
	    if (line[0] == '.') {
		/*
		 * End of article?
		 */
		if (UCH(line[1]) < ' ') {
		    done = YES;
		    break;
		} else {	/* Line starts with dot */
		    START(HTML_DT);
		    PUTS(&line[1]);
		    MAYBE_END(HTML_DT);
		}
	    } else if (line[0] == '#') {	/* Comment? */
		p = line;	/* Restart at beginning */
		continue;
	    } else {
		/*
		 * Normal lines are scanned for references to newsgroups.
		 */
		int i = 0;

		/* find whitespace if it exits */
		for (; line[i] != '\0' && !WHITE(line[i]); i++) ;	/* null body */

		if (line[i] != '\0') {
		    line[i] = '\0';
		    if ((head && strncasecomp(line, pattern, len)) ||
			(tail && (i < len ||
				  strcasecomp((line + (i - len)), pattern)))) {
			p = line;	/* Restart at beginning */
			continue;
		    }
		    START(HTML_DT);
		    write_anchor(line, line);
		    listing++;
		    MAYBE_END(HTML_DT);
		    PUTC('\n');
		    START(HTML_DD);
		    PUTS(&line[i + 1]);		/* put description */
		    MAYBE_END(HTML_DD);
		} else {
		    if ((head && strncasecomp(line, pattern, len)) ||
			(tail && (i < len ||
				  strcasecomp((line + (i - len)), pattern)))) {
			p = line;	/* Restart at beginning */
			continue;
		    }
		    START(HTML_DT);
		    write_anchor(line, line);
		    MAYBE_END(HTML_DT);
		    listing++;
		}
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */
    if (!listing) {
	char *msg = NULL;

	START(HTML_DT);
	HTSprintf0(&msg, gettext("No matches for: %s"), arg);
	PUTS(msg);
	MAYBE_END(HTML_DT);
	FREE(msg);
    }
    END(HTML_DLC);
    PUTC('\n');
    FREE(pattern);
    return (HT_LOADED);
}

/*	Read in a Newsgroup
 *	-------------------
 *
 *  Unfortunately, we have to ask for each article one by one if we
 *  want more than one field.
 *
 */
static int read_group(const char *groupName,
		      int first_required,
		      int last_required)
{
    char line[LINE_LENGTH + 1];
    char author[LINE_LENGTH + 1];
    char subject[LINE_LENGTH + 1];
    char *date = NULL;
    int i;
    char *p;
    BOOL done;

    char buffer[LINE_LENGTH + 1];
    char *temp = NULL;
    char *reference = NULL;	/* Href for article */
    int art;			/* Article number WITHIN GROUP */
    int status, count, first, last;	/* Response fields */

    /* count is only an upper limit */

    author[0] = '\0';
    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    PUTS("Newsgroup ");
    PUTS(groupName);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');

    sscanf(response_text, " %d %d %d %d", &status, &count, &first, &last);
    CTRACE((tfp, "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
	    status, count, first, last, first_required, last_required));
    if (last == 0) {
	PUTS(gettext("\nNo articles in this group.\n"));
	goto add_post;
    }
#define FAST_THRESHOLD 100	/* Above this, read IDs fast */
#define CHOP_THRESHOLD 50	/* Above this, chop off the rest */

    if (first_required < first)
	first_required = first;	/* clip */
    if ((last_required == 0) || (last_required > last))
	last_required = last;

    if (last_required < first_required) {
	PUTS(gettext("\nNo articles in this range.\n"));
	goto add_post;
    }

    if (last_required - first_required + 1 > HTNewsMaxChunk) {	/* Trim this block */
	first_required = last_required - HTNewsChunkSize + 1;
    }
    CTRACE((tfp, "    Chunk will be (%d-%d)\n",
	    first_required, last_required));

    /*
     * Set window title.
     */
    HTSprintf0(&temp, gettext("%s,  Articles %d-%d"),
	       groupName, first_required, last_required);
    START(HTML_H1);
    PUTS(temp);
    FREE(temp);
    END(HTML_H1);
    PUTC('\n');

    /*
     * Link to earlier articles.
     */
    if (first_required > first) {
	int before;		/* Start of one before */

	if (first_required - HTNewsMaxChunk <= first)
	    before = first;
	else
	    before = first_required - HTNewsChunkSize;
	HTSprintf0(&dbuf, "%s%s/%d-%d", NewsHREF, groupName,
		   before, first_required - 1);
	CTRACE((tfp, "    Block before is %s\n", dbuf));
	PUTC('(');
	start_anchor(dbuf);
	PUTS(gettext("Earlier articles"));
	END(HTML_A);
	PUTS("...)\n");
	START(HTML_P);
	PUTC('\n');
    }

    done = NO;

/*#define USE_XHDR*/
#ifdef USE_XHDR
    if (count > FAST_THRESHOLD) {
	HTSprintf0(&temp,
		   gettext("\nThere are about %d articles currently available in %s, IDs as follows:\n\n"),
		   count, groupName);
	PUTS(temp);
	FREE(temp);
	sprintf(buffer, "XHDR Message-ID %d-%d%c%c", first, last, CR, LF);
	status = response(buffer);
	if (status == 221) {
	    p = line;
	    while (!done) {
		int ich = NEXT_CHAR;

		*p++ = ich;
		if (ich == EOF) {
		    if (interrupted_in_htgetcharacter) {
			interrupted_in_htgetcharacter = 0;
			CTRACE((tfp,
				"HTNews: Interrupted on read, closing socket %d\n",
				s));
			NEWS_NETCLOSE(s);
			s = -1;
			return (HT_INTERRUPTED);
		    }
		    abort_socket();	/* End of file, close socket */
		    return (HT_LOADED);		/* End of file on response */
		}
		if (((char) ich == '\n') || (p == &line[LINE_LENGTH])) {
		    *p = '\0';	/* Terminate the string */
		    CTRACE((tfp, "X %s", line));
		    if (line[0] == '.') {
			/*
			 * End of article?
			 */
			if (UCH(line[1]) < ' ') {
			    done = YES;
			    break;
			} else {	/* Line starts with dot */
			    /* Ignore strange line */
			}
		    } else {
			/*
			 * Normal lines are scanned for references to articles.
			 */
			char *space = strchr(line, ' ');

			if (space++)
			    write_anchor(space, space);
		    }		/* if not dot */
		    p = line;	/* Restart at beginning */
		}		/* if end of line */
	    }			/* Loop over characters */

	    /* leaving loop with "done" set */
	}			/* Good status */
    }
#endif /* USE_XHDR */

    /*
     * Read newsgroup using individual fields.
     */
    if (!done) {
	START(HTML_B);
	if (first == first_required && last == last_required)
	    PUTS(gettext("All available articles in "));
	else
	    PUTS("Articles in ");
	PUTS(groupName);
	END(HTML_B);
	PUTC('\n');
	if (LYListNewsNumbers)
	    start_list(first_required);
	else
	    START(HTML_UL);
	for (art = first_required; art <= last_required; art++) {
/*#define OVERLAP*/
#ifdef OVERLAP
	    /*
	     * With this code we try to keep the server running flat out by
	     * queuing just one extra command ahead of time.  We assume (1)
	     * that the server won't abort if it gets input during output, and
	     * (2) that TCP buffering is enough for the two commands.  Both
	     * these assumptions seem very reasonable.  However, we HAVE had a
	     * hangup with a loaded server.
	     */
	    if (art == first_required) {
		if (art == last_required) {	/* Only one */
		    sprintf(buffer, "HEAD %d%c%c",
			    art, CR, LF);
		    status = response(buffer);
		} else {	/* First of many */
		    sprintf(buffer, "HEAD %d%c%cHEAD %d%c%c",
			    art, CR, LF, art + 1, CR, LF);
		    status = response(buffer);
		}
	    } else if (art == last_required) {	/* Last of many */
		status = response(NULL);
	    } else {		/* Middle of many */
		sprintf(buffer, "HEAD %d%c%c", art + 1, CR, LF);
		status = response(buffer);
	    }
#else /* Not OVERLAP: */
	    sprintf(buffer, "HEAD %d%c%c", art, CR, LF);
	    status = response(buffer);
#endif /* OVERLAP */
	    /*
	     * Check for a good response (221) for the HEAD request, and if so,
	     * parse it.  Otherwise, indicate the error so that the number of
	     * listings corresponds to what's claimed for the range, and if we
	     * are listing numbers via an ordered list, they stay in synchrony
	     * with the article numbers.  - FM
	     */
	    if (status == 221) {	/* Head follows - parse it: */
		p = line;	/* Write pointer */
		done = NO;
		while (!done) {
		    int ich = NEXT_CHAR;

		    *p++ = (char) ich;
		    if (ich == EOF) {
			if (interrupted_in_htgetcharacter) {
			    interrupted_in_htgetcharacter = 0;
			    CTRACE((tfp,
				    "HTNews: Interrupted on read, closing socket %d\n",
				    s));
			    NEWS_NETCLOSE(s);
			    s = -1;
			    return (HT_INTERRUPTED);
			}
			abort_socket();		/* End of file, close socket */
			return (HT_LOADED);	/* End of file on response */
		    }
		    if (((char) ich == LF) ||
			(p == &line[LINE_LENGTH])) {

			*--p = '\0';	/* Terminate  & chop LF */
			p = line;	/* Restart at beginning */
			CTRACE((tfp, "G %s\n", line));
			switch (line[0]) {

			case '.':
			    /*
			     * End of article?
			     */
			    done = (BOOL) (UCH(line[1]) < ' ');
			    break;

			case 'S':
			case 's':
			    if (match(line, "SUBJECT:")) {
				LYstrncpy(subject, line + 9, sizeof(subject) - 1);	/* Save subject */
				decode_mime(subject);
			    }
			    break;

			case 'M':
			case 'm':
			    if (match(line, "MESSAGE-ID:")) {
				char *addr = HTStrip(line + 11) + 1;	/* Chop < */

				addr[strlen(addr) - 1] = '\0';	/* Chop > */
				StrAllocCopy(reference, addr);
			    }
			    break;

			case 'f':
			case 'F':
			    if (match(line, "FROM:")) {
				char *p2;

				LYstrncpy(author,
					  author_name(strchr(line, ':') + 1),
					  sizeof(author) - 1);
				decode_mime(author);
				p2 = author + strlen(author) - 1;
				if (*p2 == LF)
				    *p2 = '\0';		/* Chop off newline */
			    }
			    break;

			case 'd':
			case 'D':
			    if (LYListNewsDates && match(line, "DATE:")) {
				StrAllocCopy(date,
					     HTStrip(strchr(line, ':') + 1));
			    }
			    break;

			}	/* end switch on first character */
		    }		/* if end of line */
		}		/* Loop over characters */

		PUTC('\n');
		START(HTML_LI);
#ifdef SH_EX			/* for MIME */
		HTSprintf0(&temp, "\"%s\"", decode_mime(subject));
#else
		HTSprintf0(&temp, "\"%s\"", subject);
#endif
		if (reference) {
		    write_anchor(temp, reference);
		    FREE(reference);
		} else {
		    PUTS(temp);
		}
		FREE(temp);

		if (author[0] != '\0') {
		    PUTS(" - ");
		    if (LYListNewsDates)
			START(HTML_I);
#ifdef SH_EX			/* for MIME */
		    PUTS(decode_mime(author));
#else
		    PUTS(author);
#endif
		    if (LYListNewsDates)
			END(HTML_I);
		    author[0] = '\0';
		}
		if (date) {
		    if (!diagnostic) {
			for (i = 0; date[i]; i++) {
			    if (date[i] == ' ') {
				date[i] = HT_NON_BREAK_SPACE;
			    }
			}
		    }
		    sprintf(buffer, " [%.*s]", (int) (sizeof(buffer) - 4), date);
		    PUTS(buffer);
		    FREE(date);
		}
		MAYBE_END(HTML_LI);
		/*
		 * Indicate progress!  @@@@@@@@@@@@
		 */
	    } else if (status == HT_INTERRUPTED) {
		interrupted_in_htgetcharacter = 0;
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
		NEWS_NETCLOSE(s);
		s = -1;
		return (HT_INTERRUPTED);
	    } else {
		/*
		 * Use the response text on error.  - FM
		 */
		PUTC('\n');
		START(HTML_LI);
		START(HTML_I);
		if (LYListNewsNumbers)
		    LYstrncpy(buffer, "Status:", sizeof(buffer) - 1);
		else
		    sprintf(buffer, "Status (ARTICLE %d):", art);
		PUTS(buffer);
		END(HTML_I);
		PUTC(' ');
		PUTS(response_text);
		MAYBE_END(HTML_LI);
	    }			/* Handle response to HEAD request */
	}			/* Loop over article */
    }				/* If read headers */
    PUTC('\n');
    if (LYListNewsNumbers)
	END(HTML_OL);
    else
	END(HTML_UL);
    PUTC('\n');

    /*
     * Link to later articles.
     */
    if (last_required < last) {
	int after;		/* End of article after */

	after = last_required + HTNewsChunkSize;
	if (after == last)
	    HTSprintf0(&dbuf, "%s%s", NewsHREF, groupName);	/* original group */
	else
	    HTSprintf0(&dbuf, "%s%s/%d-%d", NewsHREF, groupName,
		       last_required + 1, after);
	CTRACE((tfp, "    Block after is %s\n", dbuf));
	PUTC('(');
	start_anchor(dbuf);
	PUTS(gettext("Later articles"));
	END(HTML_A);
	PUTS("...)\n");
    }

  add_post:
    if (HTCanPost) {
	/*
	 * We have permission to POST to this host, so add a link for posting
	 * messages to this newsgroup.  - FM
	 */
	char *href = NULL;

	START(HTML_HR);
	PUTC('\n');
	if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
	    StrAllocCopy(href, "snewspost://");
	else
	    StrAllocCopy(href, "newspost://");
	StrAllocCat(href, NewsHost);
	StrAllocCat(href, "/");
	StrAllocCat(href, groupName);
	start_anchor(href);
	PUTS(gettext("Post to "));
	PUTS(groupName);
	END(HTML_A);
	FREE(href);
    } else {
	START(HTML_HR);
    }
    PUTC('\n');
    return (HT_LOADED);
}

/*	Load by name.						HTLoadNews
 *	=============
 */
static int HTLoadNews(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *stream)
{
    char command[262];		/* The whole command */
    char proxycmd[260];		/* The proxy command */
    char groupName[GROUP_NAME_LENGTH];	/* Just the group name */
    int status;			/* tcp return */
    int retries;		/* A count of how hard we have tried */
    BOOL normal_url;		/* Flag: "news:" or "nntp:" (physical) URL */
    BOOL group_wanted;		/* Flag: group was asked for, not article */
    BOOL list_wanted;		/* Flag: list was asked for, not article */
    BOOL post_wanted;		/* Flag: new post to group was asked for */
    BOOL reply_wanted;		/* Flag: followup post was asked for */
    BOOL spost_wanted;		/* Flag: new SSL post to group was asked for */
    BOOL sreply_wanted;		/* Flag: followup SSL post was asked for */
    BOOL head_wanted = NO;	/* Flag: want HEAD of single article */
    int first, last;		/* First and last articles asked for */
    char *cp = 0;
    char *ListArg = NULL;
    char *ProxyHost = NULL;
    char *ProxyHREF = NULL;
    char *postfile = NULL;

#ifdef USE_SSL
    char SSLprogress[256];
#endif /* USE_SSL */

    diagnostic = (format_out == WWW_SOURCE ||	/* set global flag */
		  format_out == HTAtom_for("www/download") ||
		  format_out == HTAtom_for("www/dump"));
    rawtext = NO;

    CTRACE((tfp, "HTNews: Looking for %s\n", arg));

    if (!initialized)
	initialized = initialize();
    if (!initialized)
	return -1;		/* FAIL */

    FREE(NewsHREF);
    command[0] = '\0';
    command[sizeof(command) - 1] = '\0';
    proxycmd[0] = '\0';
    proxycmd[sizeof(proxycmd) - 1] = '\0';

    {
	const char *p1 = arg;

	/*
	 * We will ask for the document, omitting the host name & anchor.
	 *
	 * Syntax of address is
	 * xxx@@yyy                 Article
	 * <xxx@@yyy>               Same article
	 * xxxxx                   News group (no "@@")
	 * group/n1-n2             Articles n1 to n2 in group
	 */
	normal_url = (BOOL) (!strncmp(arg, STR_NEWS_URL, LEN_NEWS_URL) ||
			     !strncmp(arg, "nntp:", 5));
	spost_wanted = (BOOL) (!normal_url && strstr(arg, "snewspost:") != NULL);
	sreply_wanted = (BOOL) (!(normal_url || spost_wanted) &&
				strstr(arg, "snewsreply:") != NULL);
	post_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted) &&
			      strstr(arg, "newspost:") != NULL);
	reply_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted ||
				 post_wanted) &&
			       strstr(arg, "newsreply:") != NULL);
	group_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
				  post_wanted || reply_wanted) &&
				strchr(arg, '@@') == NULL) &&
			       (strchr(arg, '*') == NULL));
	list_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
				 post_wanted || reply_wanted ||
				 group_wanted) &&
			       strchr(arg, '@@') == NULL) &&
			      (strchr(arg, '*') != NULL));

#ifndef USE_SSL
	if (!strncasecomp(arg, "snewspost:", 10) ||
	    !strncasecomp(arg, "snewsreply:", 11)) {
	    HTAlert(FAILED_CANNOT_POST_SSL);
	    return HT_NOT_LOADED;
	}
#endif /* !USE_SSL */
	if (post_wanted || reply_wanted || spost_wanted || sreply_wanted) {
	    /*
	     * Make sure we have a non-zero path for the newsgroup(s).  - FM
	     */
	    if ((p1 = strrchr(arg, '/')) != NULL) {
		p1++;
	    } else if ((p1 = strrchr(arg, ':')) != NULL) {
		p1++;
	    }
	    if (!(p1 && *p1)) {
		HTAlert(WWW_ILLEGAL_URL_MESSAGE);
		return (HT_NO_DATA);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    HTSprintf0(&NewsHREF, "%s://%.*s/",
		       (post_wanted ?
			"newspost" :
			(reply_wanted ?
			 "newreply" :
			 (spost_wanted ?
			  "snewspost" : "snewsreply"))),
		       (int) sizeof(command) - 15, NewsHost);

	    /*
	     * If the SSL daemon is being used as a proxy, reset p1 to the
	     * start of the proxied URL rather than to the start of the
	     * newsgroup(s).  - FM
	     */
	    if (spost_wanted && strncasecomp(arg, "snewspost:", 10))
		p1 = strstr(arg, "snewspost:");
	    if (sreply_wanted && strncasecomp(arg, "snewsreply:", 11))
		p1 = strstr(arg, "snewsreply:");

	    /* p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION); */
	    /*
	     * Don't use HTParse because news:  access doesn't follow
	     * traditional rules.  For instance, if the article reference
	     * contains a '#', the rest of it is lost -- JFG 10/7/92, from a
	     * bug report
	     */
	} else if (isNNTP_URL(arg)) {
	    if (((*(arg + 5) == '\0') ||
		 (!strcmp((arg + 5), "/") ||
		  !strcmp((arg + 5), "//") ||
		  !strcmp((arg + 5), "///"))) ||
		((!strncmp((arg + 5), "//", 2)) &&
		 (!(cp = strchr((arg + 7), '/')) || *(cp + 1) == '\0'))) {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    } else if (*(arg + 5) != '/') {
		p1 = (arg + 5);
	    } else if (*(arg + 5) == '/' && *(arg + 6) != '/') {
		p1 = (arg + 6);
	    } else {
		p1 = (cp + 1);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    SnipIn2(command, "%s//%.*s/", STR_NNTP_URL, 9, NewsHost);
	    StrAllocCopy(NewsHREF, command);
	} else if (!strncasecomp(arg, STR_SNEWS_URL, 6)) {
#ifdef USE_SSL
	    if (((*(arg + 6) == '\0') ||
		 (!strcmp((arg + 6), "/") ||
		  !strcmp((arg + 6), "//") ||
		  !strcmp((arg + 6), "///"))) ||
		((!strncmp((arg + 6), "//", 2)) &&
		 (!(cp = strchr((arg + 8), '/')) || *(cp + 1) == '\0'))) {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    } else if (*(arg + 6) != '/') {
		p1 = (arg + 6);
	    } else if (*(arg + 6) == '/' && *(arg + 7) != '/') {
		p1 = (arg + 7);
	    } else {
		p1 = (cp + 1);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    sprintf(command, "%s//%.250s/", STR_SNEWS_URL, NewsHost);
	    StrAllocCopy(NewsHREF, command);
#else
	    HTAlert(gettext("This client does not contain support for SNEWS URLs."));
	    return HT_NOT_LOADED;
#endif /* USE_SSL */
	} else if (!strncasecomp(arg, "news:/", 6)) {
	    if (((*(arg + 6) == '\0') ||
		 !strcmp((arg + 6), "/") ||
		 !strcmp((arg + 6), "//")) ||
		((*(arg + 6) == '/') &&
		 (!(cp = strchr((arg + 7), '/')) || *(cp + 1) == '\0'))) {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    } else if (*(arg + 6) != '/') {
		p1 = (arg + 6);
	    } else {
		p1 = (cp + 1);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    SnipIn(command, "news://%.*s/", 9, NewsHost);
	    StrAllocCopy(NewsHREF, command);
	} else {
	    p1 = (arg + 5);	/* Skip "news:" prefix */
	    if (*p1 == '\0') {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    }
	    if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		NEWS_NETCLOSE(s);
		s = -1;
	    }
	    StrAllocCopy(NewsHost, HTNewsHost);
	    StrAllocCopy(NewsHREF, STR_NEWS_URL);
	}

	/*
	 * Set up any proxy for snews URLs that returns NNTP responses for Lynx
	 * to convert to HTML, instead of doing the conversion itself, and for
	 * handling posts or followups.  - TZ & FM
	 */
	if (!strncasecomp(p1, STR_SNEWS_URL, 6) ||
	    !strncasecomp(p1, "snewspost:", 10) ||
	    !strncasecomp(p1, "snewsreply:", 11)) {
	    StrAllocCopy(ProxyHost, NewsHost);
	    if ((cp = HTParse(p1, "", PARSE_HOST)) != NULL && *cp != '\0') {
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, cp);
		StrAllocCopy(NewsHost, cp);
	    } else {
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, NewsHost);
	    }
	    command[sizeof(command) - 2] = '\0';
	    FREE(cp);
	    sprintf(proxycmd, "GET %.*s%c%c%c%c",
		    (int) sizeof(proxycmd) - 9, command,
		    CR, LF, CR, LF);
	    CTRACE((tfp, "HTNews: Proxy command is '%.*s'\n",
		    (int) (strlen(proxycmd) - 4), proxycmd));
	    strcat(command, "/");
	    StrAllocCopy(ProxyHREF, NewsHREF);
	    StrAllocCopy(NewsHREF, command);
	    if (spost_wanted || sreply_wanted) {
		/*
		 * Reset p1 so that it points to the newsgroup(s).
		 */
		if ((p1 = strrchr(arg, '/')) != NULL) {
		    p1++;
		} else {
		    p1 = (strrchr(arg, ':') + 1);
		}
	    } else {
		/*
		 * Reset p1 so that it points to the newsgroup (or a wildcard),
		 * or the article.
		 */
		if (!(cp = strrchr((p1 + 6), '/')) || *(cp + 1) == '\0') {
		    p1 = "*";
		    group_wanted = FALSE;
		    list_wanted = TRUE;
		} else {
		    p1 = (cp + 1);
		}
	    }
	}

	/*
	 * Set up command for a post, listing, or article request.  - FM
	 */
	if (post_wanted || reply_wanted || spost_wanted || sreply_wanted) {
	    strcpy(command, "POST");
	} else if (list_wanted) {
	    if (strlen(p1) > 249) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    SnipIn(command, "XGTITLE %.*s", 11, p1);
	} else if (group_wanted) {
	    char *slash = strchr(p1, '/');

	    first = 0;
	    last = 0;
	    if (slash) {
		*slash = '\0';
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
		*slash = '/';
		(void) sscanf(slash + 1, "%d-%d", &first, &last);
		if ((first > 0) && (isdigit(UCH(*(slash + 1)))) &&
		    (strchr(slash + 1, '-') == NULL || first == last)) {
		    /*
		     * We got a number greater than 0, which will be loaded as
		     * first, and either no range or the range computes to
		     * zero, so make last negative, as a flag to select the
		     * group and then fetch an article by number (first)
		     * instead of by messageID.  - FM
		     */
		    last = -1;
		}
	    } else {
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
	    }
	    SnipIn(command, "GROUP %.*s", 9, groupName);
	} else {
	    int add_open = (strchr(p1, '<') == 0);
	    int add_close = (strchr(p1, '>') == 0);

	    if (strlen(p1) + add_open + add_close >= 252) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    sprintf(command, "ARTICLE %s%.*s%s",
		    add_open ? "<" : "",
		    (int) (sizeof(command) - (11 + add_open + add_close)),
		    p1,
		    add_close ? ">" : "");
	}

	{
	    char *p = command + strlen(command);

	    /*
	     * Terminate command with CRLF, as in RFC 977.
	     */
	    *p++ = CR;		/* Macros to be correct on Mac */
	    *p++ = LF;
	    *p++ = 0;
	}
	StrAllocCopy(ListArg, p1);
    }				/* scope of p1 */

    if (!*arg) {
	FREE(NewsHREF);
	FREE(ProxyHost);
	FREE(ProxyHREF);
	FREE(ListArg);
	return NO;		/* Ignore if no name */
    }

    if (!(post_wanted || reply_wanted || spost_wanted || sreply_wanted ||
	  (group_wanted && last != -1) || list_wanted)) {
	head_wanted = anAnchor->isHEAD;
	if (head_wanted && !strncmp(command, "ARTICLE ", 8)) {
	    /* overwrite "ARTICLE" - hack... */
	    strcpy(command, "HEAD ");
	    for (cp = command + 5;; cp++)
		if ((*cp = *(cp + 3)) == '\0')
		    break;
	}
	rawtext = (BOOL) (head_wanted || keep_mime_headers);
    }
    if (rawtext) {
	node_anchor = anAnchor;
	rawtarget = HTStreamStack(WWW_PLAINTEXT,
				  format_out,
				  stream, anAnchor);
	if (!rawtarget) {
	    FREE(NewsHost);
	    FREE(NewsHREF);
	    FREE(ProxyHost);
	    FREE(ProxyHREF);
	    FREE(ListArg);
	    HTAlert(gettext("No target for raw text!"));
	    return (HT_NOT_LOADED);
	}			/* Copy routine entry points */
	rawtargetClass = *rawtarget->isa;
    } else
	/*
	 * Make a hypertext object with an anchor list.
	 */
    if (!(post_wanted || reply_wanted || spost_wanted || sreply_wanted)) {
	node_anchor = anAnchor;
	target = HTML_new(anAnchor, format_out, stream);
	targetClass = *target->isa;	/* Copy routine entry points */
    }

    /*
     * Now, let's get a stream setup up from the NewsHost.
     */
    for (retries = 0; retries < 2; retries++) {
	if (s < 0) {
	    /* CONNECTING to news host */
	    char url[260];

	    if (!strcmp(NewsHREF, STR_NEWS_URL)) {
		SnipIn(url, "lose://%.*s/", 9, NewsHost);
	    } else if (ProxyHREF) {
		SnipIn(url, "%.*s", 1, ProxyHREF);
	    } else {
		SnipIn(url, "%.*s", 1, NewsHREF);
	    }
	    CTRACE((tfp, "News: doing HTDoConnect on '%s'\n", url));

	    _HTProgress(gettext("Connecting to NewsHost ..."));

#ifdef USE_SSL
	    if (!using_proxy &&
		(!strncmp(arg, STR_SNEWS_URL, 6) ||
		 !strncmp(arg, "snewspost:", 10) ||
		 !strncmp(arg, "snewsreply:", 11)))
		status = HTDoConnect(url, "NNTPS", SNEWS_PORT, &s);
	    else
		status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
#else
	    status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
#endif /* USE_SSL */

	    if (status == HT_INTERRUPTED) {
		/*
		 * Interrupt cleanly.
		 */
		CTRACE((tfp,
			"HTNews: Interrupted on connect; recovering cleanly.\n"));
		_HTProgress(CONNECTION_INTERRUPTED);
		if (!(post_wanted || reply_wanted ||
		      spost_wanted || sreply_wanted)) {
		    ABORT_TARGET;
		}
		FREE(NewsHost);
		FREE(NewsHREF);
		FREE(ProxyHost);
		FREE(ProxyHREF);
		FREE(ListArg);
#ifdef USE_SSL
		if (Handle) {
		    SSL_free(Handle);
		    Handle = NULL;
		}
#endif /* USE_SSL */
		if (postfile) {
		    HTSYS_remove(postfile);
		    FREE(postfile);
		}
		return HT_NOT_LOADED;
	    }
	    if (status < 0) {
		NEWS_NETCLOSE(s);
		s = -1;
		CTRACE((tfp, "HTNews: Unable to connect to news host.\n"));
		if (retries < 1)
		    continue;
		if (!(post_wanted || reply_wanted ||
		      spost_wanted || sreply_wanted)) {
		    ABORT_TARGET;
		}
		HTSprintf0(&dbuf, gettext("Could not access %s."), NewsHost);
		FREE(NewsHost);
		FREE(NewsHREF);
		FREE(ProxyHost);
		FREE(ProxyHREF);
		FREE(ListArg);
		if (postfile) {
		    HTSYS_remove(postfile);
		    FREE(postfile);
		}
		return HTLoadError(stream, 500, dbuf);
	    } else {
		CTRACE((tfp, "HTNews: Connected to news host %s.\n",
			NewsHost));
#ifdef USE_SSL
		/*
		 * If this is an snews url, then do the SSL stuff here
		 */
		if (!using_proxy &&
		    (!strncmp(url, "snews", 5) ||
		     !strncmp(url, "snewspost:", 10) ||
		     !strncmp(url, "snewsreply:", 11))) {
		    Handle = HTGetSSLHandle();
		    SSL_set_fd(Handle, s);
		    HTSSLInitPRNG();
		    status = SSL_connect(Handle);

		    if (status <= 0) {
			unsigned long SSLerror;

			CTRACE((tfp,
				"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
			SSL_load_error_strings();
			while ((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp, "HTNews: SSL: %s\n",
				    ERR_error_string(SSLerror, NULL)));
			}
			HTAlert("Unable to make secure connection to remote host.");
			NEWS_NETCLOSE(s);
			s = -1;
			if (!(post_wanted || reply_wanted ||
			      spost_wanted || sreply_wanted))
			    (*targetClass._abort) (target, NULL);
			FREE(NewsHost);
			FREE(NewsHREF);
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			if (postfile) {
#ifdef VMS
			    while (remove(postfile) == 0) ;	/* loop through all versions */
#else
			    remove(postfile);
#endif /* VMS */
			    FREE(postfile);
			}
			return HT_NOT_LOADED;
		    }
		    sprintf(SSLprogress,
			    "Secure %d-bit %s (%s) NNTP connection",
			    SSL_get_cipher_bits(Handle, NULL),
			    SSL_get_cipher_version(Handle),
			    SSL_get_cipher(Handle));
		    _HTProgress(SSLprogress);
		}
#endif /* USE_SSL */
		HTInitInput(s);	/* set up buffering */
		if (proxycmd[0]) {
		    status = NEWS_NETWRITE(s, proxycmd, strlen(proxycmd));
		    CTRACE((tfp,
			    "HTNews: Proxy command returned status '%d'.\n",
			    status));
		}
		if (((status = response(NULL)) / 100) != 2) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		    if (status == HT_INTERRUPTED) {
			_HTProgress(CONNECTION_INTERRUPTED);
			if (!(post_wanted || reply_wanted ||
			      spost_wanted || sreply_wanted)) {
			    ABORT_TARGET;
			}
			FREE(NewsHost);
			FREE(NewsHREF);
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			if (postfile) {
			    HTSYS_remove(postfile);
			    FREE(postfile);
			}
			return (HT_NOT_LOADED);
		    }
		    if (retries < 1)
			continue;
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    FREE(ListArg);
		    FREE(postfile);
		    if (!(post_wanted || reply_wanted ||
			  spost_wanted || sreply_wanted)) {
			ABORT_TARGET;
		    }
		    if (response_text[0]) {
			HTSprintf0(&dbuf,
				   gettext("Can't read news info.  News host %.20s responded: %.200s"),
				   NewsHost, response_text);
		    } else {
			HTSprintf0(&dbuf,
				   gettext("Can't read news info, empty response from host %s"),
				   NewsHost);
		    }
		    return HTLoadError(stream, 500, dbuf);
		}
		if (status == 200) {
		    HTCanPost = TRUE;
		} else {
		    HTCanPost = FALSE;
		    if (post_wanted || reply_wanted ||
			spost_wanted || sreply_wanted) {
			HTAlert(CANNOT_POST);
			FREE(NewsHREF);
			if (ProxyHREF) {
			    StrAllocCopy(NewsHost, ProxyHost);
			    FREE(ProxyHost);
			    FREE(ProxyHREF);
			}
			FREE(ListArg);
			if (postfile) {
			    HTSYS_remove(postfile);
			    FREE(postfile);
			}
			return (HT_NOT_LOADED);
		    }
		}
	    }
	}
	/* If needed opening */
	if (post_wanted || reply_wanted ||
	    spost_wanted || sreply_wanted) {
	    if (!HTCanPost) {
		HTAlert(CANNOT_POST);
		FREE(NewsHREF);
		if (ProxyHREF) {
		    StrAllocCopy(NewsHost, ProxyHost);
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		}
		FREE(ListArg);
		if (postfile) {
		    HTSYS_remove(postfile);
		    FREE(postfile);
		}
		return (HT_NOT_LOADED);
	    }
	    if (postfile == NULL) {
		postfile = LYNewsPost(ListArg,
				      (BOOLEAN) (reply_wanted || sreply_wanted));
	    }
	    if (postfile == NULL) {
		HTProgress(CANCELLED);
		FREE(NewsHREF);
		if (ProxyHREF) {
		    StrAllocCopy(NewsHost, ProxyHost);
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		}
		FREE(ListArg);
		return (HT_NOT_LOADED);
	    }
	} else {
	    /*
	     * Ensure reader mode, but don't bother checking the status for
	     * anything but HT_INTERRUPTED or a 480 Authorization request,
	     * because if the reader mode command is not needed, the server
	     * probably returned a 500, which is irrelevant at this point.  -
	     * FM
	     */
	    char buffer[20];

	    sprintf(buffer, "mode reader%c%c", CR, LF);
	    if ((status = response(buffer)) == HT_INTERRUPTED) {
		_HTProgress(CONNECTION_INTERRUPTED);
		break;
	    }
	    if (status == 480) {
		NNTPAuthResult auth_result = HTHandleAuthInfo(NewsHost);

		if (auth_result == NNTPAUTH_CLOSE) {
		    if (s != -1 && !(ProxyHost || ProxyHREF)) {
			NEWS_NETCLOSE(s);
			s = -1;
		    }
		}
		if (auth_result != NNTPAUTH_OK) {
		    break;
		}
		if ((status = response(buffer)) == HT_INTERRUPTED) {
		    _HTProgress(CONNECTION_INTERRUPTED);
		    break;
		}
	    }
	}

      Send_NNTP_command:
#ifdef NEWS_DEB
	if (postfile)
	    printf("postfile = %s, command = %s", postfile, command);
	else
	    printf("command = %s", command);
#endif
	if ((status = response(command)) == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	    break;
	}
	if (status < 0) {
	    if (retries < 1) {
		continue;
	    } else {
		break;
	    }
	}
	/*
	 * For some well known error responses which are expected to occur in
	 * normal use, break from the loop without retrying and without closing
	 * the connection.  It is unlikely that these are leftovers from a
	 * timed-out connection (but we do some checks to see whether the
	 * response corresponds to the last command), or that they will give
	 * anything else when automatically retried.  - kw
	 */
	if (status == 411 && group_wanted &&
	    !strncmp(command, "GROUP ", 6) &&
	    !strncasecomp(response_text + 3, " No such group ", 15) &&
	    !strcmp(response_text + 18, groupName)) {

	    HTAlert(response_text);
	    break;
	} else if (status == 430 && !group_wanted && !list_wanted &&
		   !strncmp(command, "ARTICLE <", 9) &&
		   !strcasecomp(response_text + 3, " No such article")) {

	    HTAlert(response_text);
	    break;
	}
	if ((status / 100) != 2 &&
	    status != 340 &&
	    status != 480) {
	    if (retries) {
		if (list_wanted && !strncmp(command, "XGTITLE", 7)) {
		    sprintf(command, "LIST NEWSGROUPS%c%c", CR, LF);
		    goto Send_NNTP_command;
		}
		HTAlert(response_text);
	    } else {
		_HTProgress(response_text);
	    }
	    NEWS_NETCLOSE(s);
	    s = -1;
	    /*
	     * Message might be a leftover "Timeout-disconnected", so try again
	     * if the retries maximum has not been reached.
	     */
	    continue;
	}

	/*
	 * Post or load a group, article, etc
	 */
	if (status == 480) {
	    NNTPAuthResult auth_result;

	    /*
	     * Some servers return 480 for a failed XGTITLE.  - FM
	     */
	    if (list_wanted && !strncmp(command, "XGTITLE", 7) &&
		strstr(response_text, "uthenticat") == NULL &&
		strstr(response_text, "uthor") == NULL) {
		sprintf(command, "LIST NEWSGROUPS%c%c", CR, LF);
		goto Send_NNTP_command;
	    }
	    /*
	     * Handle Authorization.  - FM
	     */
	    if ((auth_result = HTHandleAuthInfo(NewsHost)) == NNTPAUTH_OK) {
		goto Send_NNTP_command;
	    } else if (auth_result == NNTPAUTH_CLOSE) {
		if (s != -1 && !(ProxyHost || ProxyHREF)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		if (retries < 1)
		    continue;
	    }
	    status = HT_NOT_LOADED;
	} else if (post_wanted || reply_wanted ||
		   spost_wanted || sreply_wanted) {
	    /*
	     * Handle posting of an article.  - FM
	     */
	    if (status != 340) {
		HTAlert(CANNOT_POST);
		if (postfile) {
		    HTSYS_remove(postfile);
		}
	    } else {
		post_article(postfile);
	    }
	    FREE(postfile);
	    status = HT_NOT_LOADED;
	} else if (list_wanted) {
	    /*
	     * List available newsgroups.  - FM
	     */
	    _HTProgress(gettext("Reading list of available newsgroups."));
	    status = read_list(ListArg);
	} else if (group_wanted) {
	    /*
	     * List articles in a news group.  - FM
	     */
	    if (last < 0) {
		/*
		 * We got one article number rather than a range following the
		 * slash which followed the group name, or the range was zero,
		 * so now that we have selected that group, load ARTICLE and
		 * the the number (first) as the command and go back to send it
		 * and check the response.  - FM
		 */
		sprintf(command, "%s %d%c%c",
			head_wanted ? "HEAD" : "ARTICLE",
			first, CR, LF);
		group_wanted = FALSE;
		retries = 2;
		goto Send_NNTP_command;
	    }
	    _HTProgress(gettext("Reading list of articles in newsgroup."));
	    status = read_group(groupName, first, last);
	} else {
	    /*
	     * Get an article from a news group.  - FM
	     */
	    _HTProgress(gettext("Reading news article."));
	    status = read_article(anAnchor);
	}
	if (status == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	    status = HT_LOADED;
	}
	if (!(post_wanted || reply_wanted ||
	      spost_wanted || sreply_wanted)) {
	    if (status == HT_NOT_LOADED) {
		ABORT_TARGET;
	    } else {
		FREE_TARGET;
	    }
	}
	FREE(NewsHREF);
	if (ProxyHREF) {
	    StrAllocCopy(NewsHost, ProxyHost);
	    FREE(ProxyHost);
	    FREE(ProxyHREF);
	}
	FREE(ListArg);
	if (postfile) {
	    HTSYS_remove(postfile);
	    FREE(postfile);
	}
	return status;
    }				/* Retry loop */

#if 0
    HTAlert(gettext("Sorry, could not load requested news."));
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL, NULL, NULL, arg);
    /* No -- message earlier wil have covered it */
#endif

    if (!(post_wanted || reply_wanted ||
	  spost_wanted || sreply_wanted)) {
	ABORT_TARGET;
    }
    FREE(NewsHREF);
    if (ProxyHREF) {
	StrAllocCopy(NewsHost, ProxyHost);
	FREE(ProxyHost);
	FREE(ProxyHREF);
    }
    FREE(ListArg);
    if (postfile) {
	HTSYS_remove(postfile);
	FREE(postfile);
    }
    return HT_NOT_LOADED;
}

/*
 *  This function clears all authorization information by
 *  invoking the free_NNTP_AuthInfo() function, which normally
 *  is invoked at exit.  It allows a browser command to do
 *  this at any time, for example, if the user is leaving
 *  the terminal for a period of time, but does not want
 *  to end the current session.  - FM
 */
void HTClearNNTPAuthInfo(void)
{
    /*
     * Need code to check cached documents and do something to ensure that any
     * protected documents no longer can be accessed without a new retrieval. 
     * - FM
     */

    /*
     * Now free all of the authorization info.  - FM
     */
    free_NNTP_AuthInfo();
}

#ifdef USE_SSL
static char HTNewsGetCharacter(void)
{
    if (!Handle)
	return HTGetCharacter();
    else
	return HTGetSSLCharacter((void *) Handle);
}

int HTNewsProxyConnect(int sock,
		       const char *url,
		       HTParentAnchor *anAnchor,
		       HTFormat format_out,
		       HTStream *sink)
{
    int status;
    const char *arg = url;
    char SSLprogress[256];

    s = channel_s = sock;
    Handle = HTGetSSLHandle();
    SSL_set_fd(Handle, s);
    HTSSLInitPRNG();
    status = SSL_connect(Handle);

    if (status <= 0) {
	unsigned long SSLerror;

	channel_s = -1;
	CTRACE((tfp,
		"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		url, status));
	SSL_load_error_strings();
	while ((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp, "HTNews: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
	}
	HTAlert("Unable to make secure connection to remote host.");
	NEWS_NETCLOSE(s);
	s = -1;
	return HT_NOT_LOADED;
    }
    sprintf(SSLprogress, "Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle, NULL),
	    SSL_get_cipher_version(Handle),
	    SSL_get_cipher(Handle));
    _HTProgress(SSLprogress);
    status = HTLoadNews(arg, anAnchor, format_out, sink);
    channel_s = -1;
    return status;
}
#endif /* USE_SSL */

#ifdef GLOBALDEF_IS_MACRO
#define _HTNEWS_C_1_INIT { "news", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNews, _HTNEWS_C_1_INIT);
#define _HTNEWS_C_2_INIT { "nntp", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNNTP, _HTNEWS_C_2_INIT);
#define _HTNEWS_C_3_INIT { "newspost", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNewsPost, _HTNEWS_C_3_INIT);
#define _HTNEWS_C_4_INIT { "newsreply", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNewsReply, _HTNEWS_C_4_INIT);
#define _HTNEWS_C_5_INIT { "snews", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTSNews, _HTNEWS_C_5_INIT);
#define _HTNEWS_C_6_INIT { "snewspost", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTSNewsPost, _HTNEWS_C_6_INIT);
#define _HTNEWS_C_7_INIT { "snewsreply", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTSNewsReply, _HTNEWS_C_7_INIT);
#else
GLOBALDEF HTProtocol HTNews =
{"news", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNNTP =
{"nntp", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsPost =
{"newspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsReply =
{"newsreply", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNews =
{"snews", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsPost =
{"snewspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsReply =
{"snewsreply", HTLoadNews, NULL};
#endif /* GLOBALDEF_IS_MACRO */

#endif /* not DISABLE_NEWS */
@


1.4
log
@from OpenBSD:
- replace unbounded fscanf with fgets (avsm)
@
text
@d1 6
a6 18
/* $MirBSD: licence.template,v 1.4 2003/07/07 19:03:08 tg Exp $
 *-
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
 *
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicense it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extend permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
 *-
 * These are patches to the Lynx web browser, which is licensed under
 * the GNU General Public License, Version 2.
a8 8
/*			NEWS ACCESS				HTNews.c
**			===========
**
** History:
**	26 Sep 90	Written TBL
**	29 Nov 91	Downgraded to C, for portable implementation.
*/

d28 2
a29 2
PUBLIC int HTNewsChunkSize = 30;/* Number of articles for quick display */
PUBLIC int HTNewsMaxChunk = 40; /* Largest number of articles in one window */
d34 8
a41 3
#ifndef SERVER_FILE
#define SERVER_FILE "/usr/local/lib/rn/server"
#endif /* SERVER_FILE */
d44 3
a46 3
extern SSL_CTX * ssl_ctx;
PRIVATE SSL * Handle = NULL;
PRIVATE int channel_s = 1;
d50 3
a52 2
	{ (void)NETCLOSE(sock); if (Handle) SSL_free(Handle); Handle = NULL; }
PRIVATE char HTNewsGetCharacter NOPARAMS;
d74 2
a75 2
	CONST HTStructuredClass *	isa;
	/* ... */
d77 2
a78 3
struct _HTStream
{
  HTStreamClass * isa;
d81 1
a81 1
#define LINE_LENGTH 512			/* Maximum length of line of ARTICLE etc */
d85 21
a105 20
**  Module-wide variables.
*/
PUBLIC	char * HTNewsHost = NULL;		/* Default host */
PRIVATE char * NewsHost = NULL;			/* Current host */
PRIVATE char * NewsHREF = NULL;			/* Current HREF prefix */
PRIVATE int s;					/* Socket for NewsHost */
PRIVATE int HTCanPost = FALSE;			/* Current POST permission */
PRIVATE char response_text[LINE_LENGTH+1];	/* Last response */
/* PRIVATE HText *	HT;	*/		/* the new hypertext */
PRIVATE HTStructured * target;			/* The output sink */
PRIVATE HTStructuredClass targetClass;		/* Copy of fn addresses */
PRIVATE HTStream * rawtarget = NULL;		/* The output sink for rawtext */
PRIVATE HTStreamClass rawtargetClass;		/* Copy of fn addresses */
PRIVATE HTParentAnchor *node_anchor;		/* Its anchor */
PRIVATE int	diagnostic;			/* level: 0=none 2=source */
PRIVATE BOOL rawtext = NO;			/* Flag: HEAD or -mime_headers */
PRIVATE HTList *NNTP_AuthInfo = NULL;		/* AUTHINFO database */
PRIVATE char *name = NULL;
PRIVATE char *address = NULL;
PRIVATE char *dbuf = NULL;	/* dynamic buffer for long messages etc. */
d120 3
a122 3
   char * host;
   char * user;
   char * pass;
d126 1
a126 1
PRIVATE void free_news_globals NOARGS
d141 1
a141 1
PRIVATE void free_NNTP_AuthInfo NOARGS
d149 1
a149 1
    while (NULL != (auth = (NNTPAuth *)HTList_nextObject(cur))) {
d160 6
a165 1
PUBLIC CONST char * HTGetNewsHost NOARGS
d167 34
a200 1
	return HTNewsHost;
d203 1
a203 1
PUBLIC void HTSetNewsHost ARGS1(CONST char *, value)
d205 1
a205 1
	StrAllocCopy(HTNewsHost, value);
d209 19
a227 19
**	------------------------------
**
**	Except on the NeXT, we pick up the NewsHost name from
**
**	1.	Environment variable NNTPSERVER
**	2.	File SERVER_FILE
**	3.	Compilation time macro DEFAULT_NEWS_HOST
**	4.	Default to "news"
**
**	On the NeXT, we pick up the NewsHost name from, in order:
**
**	1.	WorldWideWeb default "NewsHost"
**	2.	Global default "NewsHost"
**	3.	News default "NewsHost"
**	4.	Compilation time macro DEFAULT_NEWS_HOST
**	5.	Default to "news"
*/
PRIVATE BOOL initialized = NO;
PRIVATE BOOL initialize NOARGS
d234 2
a235 2
    **	Get name of Host.
    */
d237 2
a238 2
    if ((cp = NXGetDefaultValue("WorldWideWeb","NewsHost"))==0) {
	if ((cp = NXGetDefaultValue("News","NewsHost")) == 0) {
d250 1
a250 1
		    HTNewsHost));
d252 2
a253 1
	FILE* fp = fopen(SERVER_FILE, TXT_R);
d255 2
a256 1
	    char server_name[MAXHOSTNAMELEN+1];
d259 1
d264 1
a264 1
			    SERVER_FILE, HTNewsHost));
d273 1
a273 1
    s = -1;		/* Disconnected */
d281 10
a290 10
**	------------------------------------------------------
**
** On entry,
**	command points to the command to be sent, including CRLF, or is null
**		pointer if no command to be sent.
** On exit,
**	Negative status indicates transmission error, socket closed.
**	Positive status is an NNTP status.
*/
PRIVATE int response ARGS1(char *,command)
d293 1
a293 1
    char * p = response_text;
d299 1
d303 6
a308 5
	    CONST char	* p;
	    char	* q;
	    char ascii[LINE_LENGTH+1];
	    for(p = command, q=ascii; *p; p++, q++) {
		*q = TOASCII(*p);
d313 1
a313 1
	status = NEWS_NETWRITE(s, (char *)command, length);
d315 1
a315 1
	if (status < 0){
d320 3
a322 3
	} /* if bad status */
    } /* if command to be sent */

d327 1
a327 1
	    *--p = '\0';			/* Terminate the string */
d331 2
a332 2
	} /* if end of line */

d334 1
a334 1
	    *(p-1) = '\0';
d336 3
a338 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d341 1
a341 1
			    s));
d347 1
a347 1
		return(HT_INTERRUPTED);
d349 1
a349 1
	    return((int)EOF);	/* End of file on response */
d351 1
a351 1
    } /* Loop over characters */
d355 7
a361 7
**	-----------------------------------
**
** On entry,
**	template must be already un upper case.
**	unknown may be in upper or lower or mixed case to match.
*/
PRIVATE BOOL match ARGS2 (CONST char *,unknown, CONST char *,template)
d363 5
a367 5
    CONST char * u = unknown;
    CONST char * t = template;
    for (; *u && *t && (TOUPPER(*u) == *t); u++, t++)
	; /* Find mismatch or end */
    return (BOOL)(*t == 0);		/* OK if end of template */
d371 3
a373 3
    NNTPAUTH_ERROR =	  0,	/* general failure */
    NNTPAUTH_OK =	281,	/* authenticated successfully */
    NNTPAUTH_CLOSE =	502	/* server probably closed connection */
d375 1
d377 3
a379 4
**  This function handles nntp authentication. - FM
*/
PRIVATE NNTPAuthResult HTHandleAuthInfo ARGS1(
	char *,		host)
d390 2
a391 2
    **	Make sure we have an interactive user and a host. - FM
    */
d396 3
a398 12
    **	Check for an existing authorization entry. - FM
    */
    if (NNTP_AuthInfo != NULL) {
	cur = NNTP_AuthInfo;
	while (NULL != (auth = (NNTPAuth *)HTList_nextObject(cur))) {
	    if (!strcmp(auth->host, host)) {
		UserName = auth->user;
		PassWord = auth->pass;
		break;
	    }
	}
    } else {
d400 1
d406 9
d416 3
a418 3
    **	Handle the username. - FM
    */
    buffer[sizeof(buffer)-1] = '\0';
d432 1
a432 1
		(int) sizeof(buffer)-17, UserName, CR, LF);
d450 2
a451 2
	    **  Username is accepted and no password is required. - FM
	    */
d459 2
a460 2
		**  Store the accepted username and no password. - FM
		*/
d471 3
a473 3
	    **  Not success, nor a request for the password,
	    **  so it must be an error. - FM
	    */
d480 2
a481 1
		if ((UserName = HTPrompt(gettext("Username:"), UserName)) != NULL &&
d500 2
a501 2
	**  Handle the password. - FM
	*/
d514 1
a514 1
		    (int) sizeof(buffer)-17, PassWord, CR, LF);
d538 2
a539 2
		 *  That's what INN's nnrpd returns.
		 *  It closes the connection after this. - kw
d555 4
a558 4
	    /*
	    **	Password also is accepted, and everything
	    **	has been stored. - FM
	    */
d579 2
a580 2
	    **	Not success, so it must be an error. - FM
	    */
d606 12
a617 12
**	----------------------------------
**
** On exit,
**	Returns allocated string which cannot be freed by the
**	calling function, and is reallocated on subsequent calls
**	to this function.
**
** For example, returns "Tim Berners-Lee" if given any of
**	" Tim Berners-Lee <tim@@online.cern.ch> "
**  or	" tim@@online.cern.ch ( Tim Berners-Lee ) "
*/
PRIVATE char * author_name ARGS1 (char *,email)
d622 1
a622 1
    CTRACE((tfp,"Trying to find name in: %s\n",name));
d626 2
a627 2
	    *e = '\0';			/* Chop off everything after the ')'  */
	    return HTStrip(p+1);	/* Remove leading and trailing spaces */
d639 1
a639 1
    return HTStrip(name);		/* Default to the whole thing */
d643 12
a654 12
**	--------------------------
**
** On exit,
**	Returns allocated string which cannot be freed by the
**	calling function, and is reallocated on subsequent calls
**	to this function.
**
** For example, returns "montulli@@spaced.out.galaxy.net" if given any of
**	" Lou Montulli <montulli@@spaced.out.galaxy.net> "
**  or	" montulli@@spaced.out.galaxy.net ( Lou "The Stud" Montulli ) "
*/
PRIVATE char * author_address ARGS1(char *,email)
d659 1
a659 1
    CTRACE((tfp,"Trying to find address in: %s\n",address));
d664 2
a665 2
		*e = '\0';		 /* Remove > */
		return HTStrip(p+1);  /* Remove leading and trailing spaces */
d673 1
a673 1
	    *p = '\0';			/* Chop off everything after the ')'  */
d690 2
a691 2
    **	Default to the first word.
    */
d694 1
a694 1
	p++; /* find first non-space */
d697 2
a698 2
	e++; /* find next space or end */
    *e = '\0'; /* terminate space */
d700 1
a700 1
    return(p);
d704 3
a706 3
**	--------------------
*/
PRIVATE void start_anchor ARGS1(CONST char *,  href)
d708 2
a709 2
    BOOL		present[HTML_A_ATTRIBUTES];
    CONST char*		value[HTML_A_ATTRIBUTES];
d712 1
a712 1
    for(i=0; i < HTML_A_ATTRIBUTES; i++)
d715 1
a715 1
    (*targetClass.start_element)(target, HTML_A, present, value, -1, 0);
d719 3
a721 3
**	------------------
*/
PRIVATE void start_link ARGS2(CONST char *,  href, CONST char *, rev)
d723 2
a724 2
    BOOL		present[HTML_LINK_ATTRIBUTES];
    CONST char*		value[HTML_LINK_ATTRIBUTES];
d727 1
a727 1
    for(i=0; i < HTML_LINK_ATTRIBUTES; i++)
d730 2
a731 2
    value[HTML_LINK_REV]  = rev;
    (*targetClass.start_element)(target, HTML_LINK, present, value, -1, 0);
d735 3
a737 3
**	------------------
*/
PRIVATE void start_list ARGS1(int, seqnum)
d739 2
a740 2
    BOOL		present[HTML_OL_ATTRIBUTES];
    CONST char*		value[HTML_OL_ATTRIBUTES];
d748 2
a749 2
    value[HTML_OL_START]  = SeqNum;
    (*targetClass.start_element)(target, HTML_OL, present, value, -1, 0);
d753 10
a762 10
**	------------------
**
**
** On entry,
**	HT	has a selection of zero length at the end.
**	text	points to the text to be put into the file, 0 terminated.
**	addr	points to the hypertext reference address,
**		terminated by white space, comma, NULL or '>'
*/
PRIVATE void write_anchor ARGS2(CONST char *,text, CONST char *,addr)
d764 2
a765 2
    char href[LINE_LENGTH+1];
    CONST char * p;
d768 1
a768 2
    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p!=','); p++)
	;
d772 1
a772 1
	strncat(q, addr, p-addr);	/* Make complete hypertext reference */
d775 1
a775 1
	HTSprintf0(&q, "%s%.*s", NewsHREF, p-addr, addr);
d787 12
a798 12
**	---------------------
**
**	We take a pointer to a list of objects, and write out each,
**	generating an anchor for each.
**
** On entry,
**	HT	has a selection of zero length at the end.
**	text	points to a comma or space separated list of addresses.
** On exit,
**	*text	is NOT any more chopped up into substrings.
*/
PRIVATE void write_anchors ARGS1 (char *,text)
d800 2
a801 2
    char * start = text;
    char * end;
d803 1
d805 1
a805 2
	for (; *start && (WHITE(*start)); start++)
	    ;  /* Find start */
d807 1
a807 1
	    return;			/* (Done) */
d809 1
a809 2
	     *end && (*end != ' ') && (*end != ','); end++)
	    ;/* Find end */
d811 1
a811 1
	    end++;	/* Include comma or space but not NULL */
d815 1
a815 1
	    write_anchor(start, start+1);
d820 1
a820 1
	start = end;			/* Point to next one */
d825 3
a827 3
**	--------------------
*/
PRIVATE void abort_socket NOARGS
d830 1
a830 1
    NEWS_NETCLOSE(s);	/* End of file, close socket */
d837 1
a837 1
    s = -1;		/* End of file on response */
d841 4
a844 5
**  Determine if a line is a valid header line.			valid_header
**  -------------------------------------------
*/
PRIVATE BOOLEAN valid_header ARGS1(
	char *,		line)
d849 2
a850 3
    **	Blank or tab in first position implies
    **	this is a continuation header.
    */
d852 1
a852 1
	return(TRUE);
d855 3
a857 3
    **	Just check for initial letter, colon, and space to make
    **	sure we discard only invalid headers.
    */
d861 1
a861 1
	return(TRUE);
d864 3
a866 3
    **	Anything else is a bad header -- it should be ignored.
    */
    return(FALSE);
d870 10
a879 11
**	------------------
**			(added by FM, modeled on Lynx's previous mini inews)
**
**	Note the termination condition of a single dot on a line by itself.
**
**  On entry,
**	s		Global socket number is OK
**	postfile	file with header and article to post.
*/
PRIVATE void post_article ARGS1(
	char *,		postfile)
a889 1

d891 2
a892 3
    **	Open the temporary file with the
    **	nntp headers and message body. - FM
    */
d899 2
a900 3
    **	Read the temporary file and post
    **	in maximum 512 byte chunks. - FM
    */
d903 1
a903 1
    while (fgets(line, sizeof(line)-2, fd) != NULL) {
d908 7
a914 11
	    **	A single '.' means end of transmission
	    **	for nntp.  Lead dots on lines normally
	    **	are trimmed and the EOF is not registered
	    **	if the dot was not followed by CRLF.
	    **	We prepend an extra dot for any line
	    **	beginning with one, to retain the one
	    **	intended, as well as avoid a false EOF
	    **	signal.  We know we have room for it in
	    **	the buffer, because we normally send when
	    **	it would exceed 510. - FM
	    */
d935 1
a935 1
	     } else {
d947 1
a947 1
	if ((blen + llen) >= (int) sizeof(buf)-1) {
d958 3
a960 3
    **	Send the nntp EOF and get the server's response. - FM
    */
    if (blen >= (int) sizeof(buf)-4) {
d972 2
a973 2
	**  Successful post. - FM
	*/
d977 2
a978 2
	**  Shucks, something went wrong. - FM
	*/
d983 1
a983 1
#ifdef SH_EX	/* for MIME */
d992 1
a992 1
	   printf("[ESC]");
d994 1
a994 1
	   printf("[NL]");
d996 1
a996 1
	   printf("(%02x)", *p);
d998 2
a999 2
	   putchar(*p);
       p++;
d1036 1
a1036 1
static char *decode_mime ARGS1(char *, str)
a1043 1

d1045 11
a1055 12
**	------------------
**
**	Note the termination condition of a single dot on a line by itself.
**	RFC 977 specifies that the line "folding" of RFC850 is not used, so we
**	do not handle it here.
**
** On entry,
**	s	Global socket number is OK
**	HT	Global hypertext object is ready for appending text
*/
PRIVATE int read_article ARGS1(
	HTParentAnchor *,	thisanchor)
d1057 1
a1057 1
    char line[LINE_LENGTH+1];
d1059 8
a1066 8
    char *subject = NULL;			/* Subject string	    */
    char *from = NULL;				/* From string		    */
    char *replyto = NULL;			/* Reply-to string	    */
    char *date = NULL;				/* Date string		    */
    char *organization = NULL;			/* Organization string	    */
    char *references = NULL;			/* Hrefs for other articles */
    char *newsgroups = NULL;			/* Newsgroups list	    */
    char *followupto = NULL;			/* Followup list	    */
d1070 1
a1070 1
    CONST char *ccp;
d1074 5
a1078 5
    **	Read in the HEADer of the article.
    **
    **	The header fields are either ignored,
    **	or formatted and put into the text.
    */
d1082 1
d1087 3
a1089 2
		    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				s));
d1092 1
a1092 1
		    return(HT_INTERRUPTED);
d1094 2
a1095 2
		abort_socket();		/* End of file, close socket */
		return(HT_LOADED);	/* End of file on response */
d1097 2
a1098 2
	    if (((char)ich == LF) || (p == &line[LINE_LENGTH])) {
		*--p = '\0';			/* Terminate the string */
d1103 1
d1120 2
a1121 2
		    **	End of article?
		    */
d1127 1
a1127 1
		    break;		/* End of Header? */
d1130 1
a1130 1
		    StrAllocCopy(subject, HTStrip(strchr(full_line,':')+1));
d1133 1
a1133 1
		    StrAllocCopy(date, HTStrip(strchr(full_line,':')+1));
d1137 1
a1137 1
				 HTStrip(strchr(full_line,':')+1));
d1141 1
a1141 1
		    StrAllocCopy(from, HTStrip(strchr(full_line,':')+1));
d1145 1
a1145 1
		    StrAllocCopy(replyto, HTStrip(strchr(full_line,':')+1));
d1149 1
a1149 1
		    StrAllocCopy(newsgroups, HTStrip(strchr(full_line,':')+1));
d1152 1
a1152 1
		    StrAllocCopy(references, HTStrip(strchr(full_line,':')+1));
d1155 1
a1155 1
		    StrAllocCopy(followupto, HTStrip(strchr(full_line,':')+1));
d1158 5
a1162 4
		    char * msgid = HTStrip(full_line+11);
		    if (msgid[0] == '<' && msgid[strlen(msgid)-1] == '>') {
			msgid[strlen(msgid)-1] = '\0';	/* Chop > */
			msgid++;			/* Chop < */
d1166 4
a1169 4
		} /* end if match */
		p = line;			/* Restart at beginning */
	    } /* if end of line */
	} /* Loop over characters */
d1182 2
a1183 2
	**  Put in the owner as a link rel.
	*/
d1186 1
d1308 3
a1310 3
	    **	"Followup-To: poster" has special meaning.
	    **  Don't use it to construct a newsreply link. -kw
	    */
d1330 3
a1332 4
	    **	We have permission to POST to this host,
	    **	so add a link for posting followups for
	    **	this article. - FM
	    */
d1334 1
a1334 1
		StrAllocCopy(href,"snewsreply://");
d1336 1
a1336 1
		StrAllocCopy(href,"newsreply://");
d1348 1
d1395 1
a1395 1
	 *  No tags, and never do a PUTC. - kw
d1400 3
a1402 3
	**  Read in the HEAD and BODY of the Article
	**  as XMP formatted text. - FM
	*/
d1407 2
a1408 3
	**  Read in the BODY of the Article
	**  as PRE formatted text. - FM
	*/
d1416 1
d1421 3
a1423 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1426 1
a1426 1
		return(HT_INTERRUPTED);
d1429 1
a1429 1
	    return(HT_LOADED);	/* End of file on response */
d1431 2
a1432 2
	if (((char)ich == LF) || (p == &line[LINE_LENGTH])) {
	    *p++ = '\0';			/* Terminate the string */
d1434 1
a1434 1
#ifdef NEWS_DEBUG	/* 1997/11/09 (Sun) 15:56:11 */
d1439 2
a1440 2
		**  End of article?
		*/
d1444 1
a1444 1
		} else {			/* Line starts with dot */
d1448 1
a1448 1
			PUTS(&line[1]); /* Ignore first dot */
d1456 2
a1457 2
		    **	All lines are passed as unmodified source. - FM
		    */
d1461 10
a1470 11
		    **	Normal lines are scanned for buried references
		    **	to other articles.  Unfortunately, it could pick
		    **	up mail addresses as well!  It also can corrupt
		    **	uuencoded messages!  So we don't do this when
		    **	fetching articles as WWW_SOURCE or when downloading
		    **	(diagnostic is TRUE) or if the client has set
		    **	scan_for_buried_news_references to FALSE.
		    **	Otherwise, we convert all "<...@@...>" strings
		    **	preceded by "rticle " to "news:...@@..." links,
		    **	and any strings that look like URLs to links. - FM
		    */
d1475 1
a1475 1
			char *q  = strrchr(p2,'>');
d1477 2
a1478 1
			if (q && at && at<q) {
d1480 2
a1481 1
			    q[1] = 0;		/* chop up */
d1501 1
a1501 1
				    PUTC (*l++);
d1511 1
a1511 1
			    *p2 = '<';		/* again */
d1513 2
a1514 2
			    start_anchor(p2+1);
			    *q = '>';		/* again */
d1517 1
a1517 1
			    q[1] = c;		/* again */
d1520 1
a1520 1
			    break;		/* line has unmatched <> */
d1523 1
a1523 1
		    while (*l) {		/* Last bit of the line */
d1540 1
a1540 1
			    PUTC (*l++);
d1550 5
a1554 5
		} /* if diagnostic or not scan_for_buried_news_references */
	    } /* if not dot */
	    p = line;				/* Restart at beginning */
	} /* if end of line */
    } /* Loop over characters */
d1557 1
a1557 1
	return(HT_LOADED);
d1564 1
a1564 1
    return(HT_LOADED);
d1568 7
a1574 7
**	----------------------------
**
**  Note the termination condition of a single dot on a line by itself.
**  RFC 977 specifies that the line "folding" of RFC850 is not used,
**  so we do not handle it here.
*/
PRIVATE int read_list ARGS1(char *, arg)
d1576 1
a1576 1
    char line[LINE_LENGTH+1];
d1588 2
a1589 2
    **	Support head or tail matches for groups to list. - FM
    */
d1593 2
a1594 2
	    StrAllocCopy(pattern, (arg+1));
	} else if (arg[strlen(arg)-1] == '*') {
d1597 1
a1597 1
	    pattern[strlen(pattern)-1] = '\0';
d1600 1
a1600 1
	   len = strlen(pattern);
d1606 4
a1609 5
    **	Read the server's reply.
    **
    **	The lines are scanned for newsgroup
    **	names and descriptions.
    */
d1619 1
a1619 1
    PUTS( "Newsgroups");
d1628 1
d1632 3
a1634 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1637 1
a1637 1
		return(HT_INTERRUPTED);
d1641 1
a1641 1
	    return(HT_LOADED);	/* End of file on response */
d1659 1
a1659 1
		skip_this_line = YES; /* ...and ignore until LF */
d1664 1
a1664 1
		skip_this_line = YES; /* ignore whole line */
d1667 1
a1667 1
		skip_rest_of_line = YES; /* skip until ch == LF found */
d1674 1
a1674 1
	    *p = '\0';			/* Terminate the string */
d1678 2
a1679 2
		**  End of article?
		*/
d1683 1
a1683 1
		} else {			/* Line starts with dot */
d1689 1
a1689 1
		p = line;			/* Restart at beginning */
d1693 2
a1694 2
		**  Normal lines are scanned for references to newsgroups.
		*/
d1698 1
a1698 2
		for (; line[i] != '\0' && !WHITE(line[i]); i++)
		    ;  /* null body */
d1714 1
a1714 1
		    PUTS(&line[i+1]); /* put description */
d1728 4
a1731 4
	    } /* if not dot */
	    p = line;			/* Restart at beginning */
	} /* if end of line */
    } /* Loop over characters */
d1734 1
d1744 1
a1744 1
    return(HT_LOADED);
d1748 13
a1760 14
**	-------------------
**
**  Unfortunately, we have to ask for each article one by one if we
**  want more than one field.
**
*/
PRIVATE int read_group ARGS3(
	CONST char *,	groupName,
	int,		first_required,
	int,		last_required)
{
    char line[LINE_LENGTH+1];
    char author[LINE_LENGTH+1];
    char subject[LINE_LENGTH+1];
d1766 1
a1766 1
    char buffer[LINE_LENGTH+1];
d1768 2
a1769 2
    char *reference = NULL;		/* Href for article */
    int art;				/* Article number WITHIN GROUP */
d1771 2
a1772 1
					/* count is only an upper limit */
d1787 1
a1787 1
		status, count, first, last, first_required, last_required));
a1791 1

d1796 1
a1796 1
	first_required = first;		/* clip */
d1805 2
a1806 2
    if (last_required-first_required+1 > HTNewsMaxChunk) { /* Trim this block */
	first_required = last_required-HTNewsChunkSize+1;
d1809 1
a1809 1
		first_required, last_required));
d1812 2
a1813 2
    **	Set window title.
    */
d1815 1
a1815 1
		    groupName, first_required, last_required);
d1823 2
a1824 2
    **	Link to earlier articles.
    */
d1826 3
a1828 2
	int before;			/* Start of one before */
	if (first_required-HTNewsMaxChunk <= first)
d1831 1
a1831 1
	    before = first_required-HTNewsChunkSize;
d1833 1
a1833 1
				      before, first_required-1);
d1848 1
a1848 1
    if (count > FAST_THRESHOLD)  {
d1850 2
a1851 2
 gettext("\nThere are about %d articles currently available in %s, IDs as follows:\n\n"),
		count, groupName);
d1860 1
d1865 3
a1867 2
			CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				    s));
d1870 1
a1870 1
			return(HT_INTERRUPTED);
d1873 1
a1873 1
		    return(HT_LOADED);	/* End of file on response */
d1875 2
a1876 2
		if (((char)ich == '\n') || (p == &line[LINE_LENGTH])) {
		    *p = '\0';		/* Terminate the string */
d1880 2
a1881 2
			**  End of article?
			*/
d1885 2
a1886 2
			} else {		/* Line starts with dot */
				/* Ignore strange line */
d1890 4
a1893 4
			**  Normal lines are scanned for
			**  references to articles.
			*/
			char * space = strchr(line, ' ');
d1896 4
a1899 4
		    } /* if not dot */
		    p = line;			/* Restart at beginning */
		} /* if end of line */
	    } /* Loop over characters */
d1902 1
a1902 1
	} /* Good status */
d1907 2
a1908 2
    **	Read newsgroup using individual fields.
    */
d1926 7
a1932 7
	    **	With this code we try to keep the server running flat out
	    **	by queuing just one extra command ahead of time.
	    **	We assume (1) that the server won't abort if it gets input
	    **	during output, and (2) that TCP buffering is enough for the
	    **	two commands.  Both these assumptions seem very reasonable.
	    **	However, we HAVE had a hangup with a loaded server.
	    */
d1934 1
a1934 1
		if (art == last_required) {		/* Only one */
d1936 1
a1936 1
				    art, CR, LF);
d1938 1
a1938 1
		} else {				/* First of many */
d1940 2
a1941 2
				    art, CR, LF, art+1, CR, LF);
			status = response(buffer);
d1943 1
a1943 1
	    } else if (art == last_required) {		/* Last of many */
d1945 2
a1946 2
	    } else {					/* Middle of many */
		sprintf(buffer, "HEAD %d%c%c", art+1, CR, LF);
d1949 1
a1949 1
#else	/* Not OVERLAP: */
d1952 1
a1952 1
#endif	/* OVERLAP */
d1954 8
a1961 9
	    **	Check for a good response (221) for the HEAD request,
	    **	and if so, parse it.  Otherwise, indicate the error
	    **	so that the number of listings corresponds to what's
	    **	claimed for the range, and if we are listing numbers
	    **	via an ordered list, they stay in synchrony with the
	    **	article numbers. - FM
	    */
	    if (status == 221) {	/* Head follows - parse it:*/
		p = line;				/* Write pointer */
d1963 1
a1963 1
		while( !done ) {
d1965 1
d1970 3
a1972 2
			    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
					s));
d1975 1
a1975 1
			    return(HT_INTERRUPTED);
d1978 1
a1978 1
			return(HT_LOADED);	/* End of file on response */
d1980 1
a1980 1
		    if (((char)ich == LF) ||
d1983 2
a1984 2
			*--p = '\0';		/* Terminate  & chop LF*/
			p = line;		/* Restart at beginning */
d1986 1
a1986 1
			switch(line[0]) {
d1990 2
a1991 2
			    **	End of article?
			    */
d1998 1
a1998 1
				LYstrncpy(subject, line+9, sizeof(subject)-1);/* Save subject */
d2006 3
a2008 2
				char * addr = HTStrip(line+11) +1; /* Chop < */
				addr[strlen(addr)-1] = '\0';	   /* Chop > */
d2016 2
a2017 1
				char * p2;
d2019 2
a2020 2
					author_name(strchr(line,':')+1),
					sizeof(author)-1);
d2023 2
a2024 2
				if (*p2==LF)
				    *p2 = '\0'; /* Chop off newline */
d2032 1
a2032 1
					     HTStrip(strchr(line,':')+1));
d2036 3
a2038 3
			} /* end switch on first character */
		    } /* if end of line */
		} /* Loop over characters */
d2042 1
a2042 1
#ifdef SH_EX	/* for MIME */
d2056 5
a2060 5
		     PUTS(" - ");
		     if (LYListNewsDates)
			 START(HTML_I);
#ifdef SH_EX	/* for MIME */
		     PUTS(decode_mime(author));
d2062 1
a2062 1
		     PUTS(author);
d2064 3
a2066 3
		     if (LYListNewsDates)
			 END(HTML_I);
		     author[0] = '\0';
d2076 1
a2076 1
		    sprintf(buffer, " [%.*s]", (int)(sizeof(buffer) - 4), date);
d2082 2
a2083 2
		**  Indicate progress!	 @@@@@@@@@@@@
		*/
d2086 3
a2088 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d2091 1
a2091 1
		return(HT_INTERRUPTED);
d2094 2
a2095 2
		**  Use the response text on error. - FM
		*/
d2108 3
a2110 3
	    } /* Handle response to HEAD request */
	} /* Loop over article */
    } /* If read headers */
d2119 2
a2120 2
    **	Link to later articles.
    */
d2122 3
a2124 2
	int after;			/* End of article after */
	after = last_required+HTNewsChunkSize;
d2126 1
a2126 1
	    HTSprintf0(&dbuf, "%s%s", NewsHREF, groupName); /* original group */
d2129 1
a2129 1
					  last_required+1, after);
d2138 1
a2138 1
add_post:
d2141 3
a2143 4
	**  We have permission to POST to this host,
	**  so add a link for posting messages to
	**  this newsgroup. - FM
	*/
d2149 1
a2149 1
	    StrAllocCopy(href,"snewspost://");
d2151 1
a2151 1
	    StrAllocCopy(href,"newspost://");
d2154 1
a2154 1
	StrAllocCat(href,groupName);
d2164 1
a2164 1
    return(HT_LOADED);
d2168 6
a2173 7
**	=============
*/
PRIVATE int HTLoadNews ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		stream)
d2175 2
a2176 2
    char command[262];			/* The whole command */
    char proxycmd[260];			/* The proxy command */
d2178 2
a2179 2
    int status;				/* tcp return */
    int retries;			/* A count of how hard we have tried */
d2194 1
d2209 1
a2209 1
	return -1;	/* FAIL */
d2213 1
a2213 1
    command[sizeof(command)-1] = '\0';
d2215 1
a2215 1
    proxycmd[sizeof(proxycmd)-1] = '\0';
d2218 1
a2218 1
	CONST char * p1 = arg;
d2221 10
a2230 9
	**  We will ask for the document, omitting the host name & anchor.
	**
	**  Syntax of address is
	**	xxx@@yyy			Article
	**	<xxx@@yyy>		Same article
	**	xxxxx			News group (no "@@")
	**	group/n1-n2		Articles n1 to n2 in group
	*/
	normal_url = (BOOL) (!strncmp(arg, STR_NEWS_URL, LEN_NEWS_URL) || !strncmp(arg, "nntp:", 5));
d2233 1
a2233 1
			 strstr(arg, "snewsreply:") != NULL);
d2235 1
a2235 1
			strstr(arg, "newspost:") != NULL);
d2237 2
a2238 2
			  post_wanted) &&
			strstr(arg, "newsreply:") != NULL);
d2240 8
a2247 6
			  post_wanted || reply_wanted) &&
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') == NULL));
	list_wanted  = (BOOL) ((!(spost_wanted || sreply_wanted ||
			  post_wanted || reply_wanted ||
			  group_wanted) &&
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') != NULL));
d2258 2
a2259 2
	    **	Make sure we have a non-zero path for the newsgroup(s). - FM
	    */
d2267 1
a2267 1
		return(HT_NO_DATA);
d2284 7
a2290 7
			     (post_wanted ?
			       "newspost" :
			    (reply_wanted ?
			       "newreply" :
			    (spost_wanted ?
			      "snewspost" : "snewsreply"))),
			    (int) sizeof(command) - 15, NewsHost);
d2293 4
a2296 4
	    **	If the SSL daemon is being used as a proxy,
	    **	reset p1 to the start of the proxied URL
	    **	rather than to the start of the newsgroup(s). - FM
	    */
d2302 7
a2308 6
	/* p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION); */
	/*
	**  Don't use HTParse because news: access doesn't follow traditional
	**  rules.  For instance, if the article reference contains a '#',
	**  the rest of it is lost -- JFG 10/7/92, from a bug report
	*/
d2342 1
a2342 2
	}
	else if (!strncasecomp(arg, STR_SNEWS_URL, 6)) {
d2380 1
a2380 2
	}
	else if (!strncasecomp (arg, "news:/", 6)) {
d2411 1
a2411 1
	    p1 = (arg + 5);  /* Skip "news:" prefix */
d2426 4
a2429 5
	**  Set up any proxy for snews URLs that returns NNTP
	**  responses for Lynx to convert to HTML, instead of
	**  doing the conversion itself, and for handling posts
	**  or followups.  - TZ & FM
	*/
d2440 1
a2440 1
	    command[sizeof(command)-2] = '\0';
d2443 1
a2443 1
		    (int) sizeof(proxycmd)-9, command,
d2446 1
a2446 1
			(int)(strlen(proxycmd) - 4), proxycmd));
d2452 2
a2453 2
		**  Reset p1 so that it points to the newsgroup(s).
		*/
d2461 3
a2463 3
		**  Reset p1 so that it points to the newsgroup
		**  (or a wildcard), or the article.
		*/
d2475 2
a2476 2
	**  Set up command for a post, listing, or article request. - FM
	*/
d2488 2
a2489 1
	    char * slash = strchr(p1, '/');
d2502 3
a2504 3
		(void)sscanf(slash+1, "%d-%d", &first, &last);
		if ((first > 0) && (isdigit(UCH(*(slash+1)))) &&
		    (strchr(slash+1, '-') == NULL || first == last)) {
d2506 6
a2511 7
		    **	We got a number greater than 0, which will be
		    **	loaded as first, and either no range or the
		    **	range computes to zero, so make last negative,
		    **	as a flag to select the group and then fetch
		    **	an article by number (first) instead of by
		    **	messageID. - FM
		    */
d2525 3
a2527 2
	    int add_open=(strchr(p1, '<') == 0);
	    int add_close=(strchr(p1, '>') == 0);
d2542 2
a2543 1
	    char * p = command + strlen(command);
d2545 2
a2546 2
	    **	Terminate command with CRLF, as in RFC 977.
	    */
d2552 1
a2552 1
    } /* scope of p1 */
d2559 1
a2559 1
	return NO;			/* Ignore if no name */
d2568 1
a2568 1
	    for (cp = command + 5; ; cp++)
d2586 2
a2587 2
	    return(HT_NOT_LOADED);
	}	/* Copy routine entry points */
d2590 3
a2592 3
    /*
    **	Make a hypertext object with an anchor list.
    */
d2600 2
a2601 2
    **	Now, let's get a stream setup up from the NewsHost.
    */
d2606 1
d2608 1
a2608 1
		SnipIn (url, "lose://%.*s/", 9, NewsHost);
d2610 1
a2610 1
		SnipIn (url, "%.*s", 1, ProxyHREF);
d2612 1
a2612 1
		SnipIn (url, "%.*s", 1, NewsHREF);
d2623 1
a2623 1
		status = HTDoConnect (url, "NNTPS", SNEWS_PORT, &s);
d2625 1
a2625 1
		status = HTDoConnect (url, "NNTP", NEWS_PORT, &s);
d2627 1
a2627 1
	    status = HTDoConnect (url, "NNTP", NEWS_PORT, &s);
d2632 4
a2635 3
		**  Interrupt cleanly.
		*/
		CTRACE((tfp, "HTNews: Interrupted on connect; recovering cleanly.\n"));
d2681 1
a2681 1
			    NewsHost));
d2684 2
a2685 3
		**  If this is an snews url,
		**  then do the SSL stuff here
		*/
d2697 4
a2700 1
			CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
d2702 3
a2704 2
			while((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
d2706 1
a2706 2
			HTAlert(
			    "Unable to make secure connection to remote host.");
d2711 1
a2711 1
			    (*targetClass._abort)(target, NULL);
d2719 1
a2719 2
			    while (remove(postfile) == 0)
			    ; /* loop through all versions */
d2727 5
a2731 1
		    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",SSL_get_cipher_bits(Handle,NULL),SSL_get_cipher_version(Handle),SSL_get_cipher(Handle));
d2735 1
a2735 1
		HTInitInput(s);		/* set up buffering */
d2738 3
a2740 2
		    CTRACE((tfp, "HTNews: Proxy command returned status '%d'.\n",
				status));
d2743 7
a2749 18
			NEWS_NETCLOSE(s);
			s = -1;
			if (status == HT_INTERRUPTED) {
			    _HTProgress(CONNECTION_INTERRUPTED);
			    if (!(post_wanted || reply_wanted ||
				  spost_wanted || sreply_wanted)) {
				ABORT_TARGET;
			    }
			    FREE(NewsHost);
			    FREE(NewsHREF);
			    FREE(ProxyHost);
			    FREE(ProxyHREF);
			    FREE(ListArg);
			    if (postfile) {
				HTSYS_remove(postfile);
				FREE(postfile);
			    }
			    return(HT_NOT_LOADED);
d2751 2
a2752 2
			if (retries < 1)
			    continue;
d2756 3
a2758 4
			FREE(postfile);
			if (!(post_wanted || reply_wanted ||
			      spost_wanted || sreply_wanted)) {
			    ABORT_TARGET;
d2760 22
a2781 10
			if (response_text[0]) {
			    HTSprintf0(&dbuf,
				gettext("Can't read news info.  News host %.20s responded: %.200s"),
				NewsHost, response_text);
			} else {
			    HTSprintf0(&dbuf,
				gettext("Can't read news info, empty response from host %s"),
				NewsHost);
			}
			return HTLoadError(stream, 500, dbuf);
d2801 1
a2801 1
			return(HT_NOT_LOADED);
d2805 2
a2806 2
	} /* If needed opening */

d2808 1
a2808 1
	     spost_wanted || sreply_wanted) {
d2822 1
a2822 1
		return(HT_NOT_LOADED);
d2826 1
a2826 1
				(BOOLEAN)(reply_wanted || sreply_wanted));
d2837 1
a2837 1
		return(HT_NOT_LOADED);
d2841 6
a2846 6
	    **	Ensure reader mode, but don't bother checking the
	    **	status for anything but HT_INTERRUPTED or a 480
	    **	Authorization request, because if the reader mode
	    **	command is not needed, the server probably returned
	    **	a 500, which is irrelevant at this point. - FM
	    */
d2856 1
d2873 1
a2873 1
Send_NNTP_command:
d2892 6
a2897 7
	 *  For some well known error responses which are expected
	 *  to occur in normal use, break from the loop without retrying
	 *  and without closing the connection.  It is unlikely that
	 *  these are leftovers from a timed-out connection (but we do
	 *  some checks to see whether the response corresponds to the
	 *  last command), or that they will give anything else when
	 *  automatically retried.  - kw
d2907 2
a2908 2
	    !strncmp(command, "ARTICLE <", 9) &&
	    !strcasecomp(response_text + 3, " No such article")) {
d2913 1
a2913 1
	if ((status/100) != 2 &&
d2928 3
a2930 4
	    **	Message might be a leftover "Timeout-disconnected",
	    **	so try again if the retries maximum has not been
	    **	reached.
	    */
d2935 2
a2936 2
	**  Post or load a group, article, etc
	*/
d2939 1
d2941 1
a2941 1
	     *	Some servers return 480 for a failed XGTITLE. - FM
d2950 2
a2951 2
	    **	Handle Authorization. - FM
	    */
d2966 2
a2967 2
	    **	Handle posting of an article. - FM
	    */
d2980 2
a2981 2
	    **	List available newsgroups. - FM
	    */
d2986 2
a2987 2
	    **	List articles in a news group. - FM
	    */
d2990 6
a2995 7
		**  We got one article number rather than a range
		**  following the slash which followed the group
		**  name, or the range was zero, so now that we
		**  have selected that group, load ARTICLE and the
		**  the number (first) as the command and go back
		**  to send it and check the response. - FM
		*/
d3007 2
a3008 2
	    **	Get an article from a news group. - FM
	    */
d3036 1
a3036 1
    } /* Retry loop */
d3040 1
a3040 1
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL,NULL,NULL, arg);
d3063 8
a3070 8
**  This function clears all authorization information by
**  invoking the free_NNTP_AuthInfo() function, which normally
**  is invoked at exit.  It allows a browser command to do
**  this at any time, for example, if the user is leaving
**  the terminal for a period of time, but does not want
**  to end the current session.  - FM
*/
PUBLIC void HTClearNNTPAuthInfo NOARGS
d3073 4
a3076 5
    **	Need code to check cached documents and do
    **	something to ensure that any protected
    **	documents no longer can be accessed without
    **	a new retrieval. - FM
    */
d3079 2
a3080 2
    **	Now free all of the authorization info. - FM
    */
d3085 1
a3085 1
PRIVATE char HTNewsGetCharacter NOARGS
d3090 1
a3090 1
	return HTGetSSLCharacter((void *)Handle);
d3093 5
a3097 6
PUBLIC int HTNewsProxyConnect ARGS5 (
    int,		sock,
    CONST char *,	url,
    HTParentAnchor *,	anAnchor,
    HTFormat,		format_out,
    HTStream *,		sink)
d3100 1
a3100 1
    CONST char * arg = url;
d3111 1
d3113 3
a3115 1
	CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
d3117 2
a3118 2
	while((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
d3125 2
a3126 2
    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle,NULL),
d3138 1
a3138 1
GLOBALDEF (HTProtocol,HTNews,_HTNEWS_C_1_INIT);
d3140 1
a3140 1
GLOBALDEF (HTProtocol,HTNNTP,_HTNEWS_C_2_INIT);
d3142 1
a3142 1
GLOBALDEF (HTProtocol,HTNewsPost,_HTNEWS_C_3_INIT);
d3144 1
a3144 1
GLOBALDEF (HTProtocol,HTNewsReply,_HTNEWS_C_4_INIT);
d3146 1
a3146 1
GLOBALDEF (HTProtocol,HTSNews,_HTNEWS_C_5_INIT);
d3148 1
a3148 1
GLOBALDEF (HTProtocol,HTSNewsPost,_HTNEWS_C_6_INIT);
d3150 1
a3150 1
GLOBALDEF (HTProtocol,HTSNewsReply,_HTNEWS_C_7_INIT);
d3152 14
a3165 7
GLOBALDEF PUBLIC HTProtocol HTNews = { "news", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTNNTP = { "nntp", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTNewsPost = { "newspost", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTNewsReply = { "newsreply", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTSNews = { "snews", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTSNewsPost = { "snewspost", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTSNewsReply = { "snewsreply", HTLoadNews, NULL };
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 20
a227 1
	char server_name[256];
d230 5
a234 1
	    if (fscanf(fp, "%s", server_name)==1) {
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d19 2
d23 1
a23 3

/* this define should be in HTFont.h :( */
#define HT_NON_BREAK_SPACE ((char)1)   /* For now */
a38 3
#define free_func free__func
#include <openssl/ssl.h>
#undef free_func
a39 1
extern SSL * HTGetSSLHandle NOPARAMS;
a45 1
extern char HTGetSSLCharacter PARAMS((void *handle));
d55 1
d64 2
d76 1
a76 1
#define LINE_LENGTH 512 		/* Maximum length of line of ARTICLE etc */
a77 7
extern BOOLEAN scan_for_buried_news_references;
extern BOOLEAN LYListNewsNumbers;
extern BOOLEAN LYListNewsDates;
extern HTCJKlang HTCJK;
extern int interrupted_in_htgetcharacter;
extern BOOL keep_mime_headers;	 /* Include mime headers and force raw text */
extern BOOL using_proxy;	/* Are we using an NNTP proxy? */
d83 2
a84 2
PRIVATE char * NewsHost = NULL; 		/* Current host */
PRIVATE char * NewsHREF = NULL; 		/* Current HREF prefix */
d203 4
a206 4
    if (getenv("NNTPSERVER")) {
	StrAllocCopy(HTNewsHost, (char *)getenv("NNTPSERVER"));
	CTRACE(tfp, "HTNews: NNTPSERVER defined as `%s'\n",
		    HTNewsHost);
d209 1
a209 1
	FILE* fp = fopen(SERVER_FILE, "r");
d213 2
a214 2
		CTRACE(tfp, "HTNews: File %s defines news host as `%s'\n",
			    SERVER_FILE, HTNewsHost);
d240 1
a240 1
PRIVATE int response ARGS1(CONST char *,command)
d249 1
a249 1
	CTRACE(tfp, "NNTP command to be sent: %s", command);
d264 1
a264 1
	    CTRACE(tfp, "HTNews: Unable to send command. Disconnecting.\n");
d273 1
a273 1
	if (((*p++ = ich) == LF) ||
d276 1
a276 1
	    CTRACE(tfp, "NNTP Response: %s\n", response_text);
d284 2
a285 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d287 2
a288 2
		CTRACE(tfp, "HTNews: EOF on read, closing socket %d\n",
			    s);
d326 1
a326 1
	char *, 	host)
d364 1
a364 1
    buffer[511] = '\0';
d369 1
a369 4
	    if ((msg = (char *)calloc(1, (strlen(host) + 30))) == NULL) {
		outofmem(__FILE__, "HTHandleAuthInfo");
	    }
	    sprintf(msg, gettext("Username for news host '%s':"), host);
d377 2
a378 1
	sprintf(buffer, "AUTHINFO USER %.*s%c%c", 495, UserName, CR, LF);
d407 1
a407 2
		if ((auth =
		    (NNTPAuth *)calloc(1, sizeof(NNTPAuth))) != NULL) {
d450 1
a450 4
		if ((msg = (char *)calloc(1, (strlen(host) + 30))) == NULL) {
		    outofmem(__FILE__, "HTHandleAuthInfo");
		}
		sprintf(msg, gettext("Password for news host '%s':"), host);
d458 2
a459 1
	    sprintf(buffer, "AUTHINFO PASS %.*s%c%c", 495, PassWord, CR, LF);
d514 1
a514 2
		    if ((auth =
			(NNTPAuth *)calloc(1, sizeof(NNTPAuth))) != NULL) {
d567 1
a567 1
    CTRACE(tfp,"Trying to find name in: %s\n",name);
d569 1
a569 1
    if ((p = strchr(name, '(')) && (e = strchr(name, ')'))) {
d576 4
a579 3
    if ((p = strchr(name, '<')) && (e = strchr(name, '>'))) {
	if (e > p) {
	    strcpy(p, e+1);		/* Remove <...> */
d604 1
a604 1
    CTRACE(tfp,"Trying to find address in: %s\n",address);
d606 2
a607 2
    if ((p = strchr(address, '<'))) {
	if ((e = strchr(p, '>')) && (at = strchr(p, '@@'))) {
d615 2
a616 2
    if ((p = strchr(address, '(')) &&
	(e = strchr(address, ')')) && (at = strchr(address, '@@'))) {
d623 1
a623 1
    if ((at = strchr(address, '@@')) && at > address) {
d626 1
a626 1
	while (p > address && !isspace((unsigned char)*p))
d628 1
a628 1
	while (*e && !isspace((unsigned char)*e))
d638 1
a638 1
    while (isspace((unsigned char)*p))
d641 1
a641 1
    while (!isspace((unsigned char)*e) && *e != '\0')
d654 2
a655 1
    CONST char* 	value[HTML_A_ATTRIBUTES];
d657 4
a660 8
    {
	int i;
	for(i=0; i < HTML_A_ATTRIBUTES; i++)
	    present[i] = (i == HTML_A_HREF);
    }
    ((CONST char **)value)[HTML_A_HREF] = href;
    (*targetClass.start_element)(target, HTML_A , present,
				 (CONST char **)value, -1, 0);
d669 2
a670 1
    CONST char* 	value[HTML_LINK_ATTRIBUTES];
d672 5
a676 9
    {
	int i;
	for(i=0; i < HTML_LINK_ATTRIBUTES; i++)
	    present[i] = (i == HTML_LINK_HREF || i == HTML_LINK_REV);
    }
    ((CONST char **)value)[HTML_LINK_HREF] = href;
    ((CONST char **)value)[HTML_LINK_REV]  = rev;
    (*targetClass.start_element)(target, HTML_LINK, present,
				 (CONST char **)value, -1, 0);
d685 1
a685 1
    CONST char* 	value[HTML_OL_ATTRIBUTES];
d690 1
a690 1
	present[i] = (i == HTML_OL_SEQNUM || i == HTML_OL_START);
d692 3
a694 4
    ((CONST char **)value)[HTML_OL_SEQNUM] = SeqNum;
    ((CONST char **)value)[HTML_OL_START]  = SeqNum;
    (*targetClass.start_element)(target, HTML_OL , present,
				 (CONST char **)value, -1, 0);
d710 2
d713 9
a721 6
    {
	CONST char * p;
	strcpy(href, NewsHREF);
	for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p!=','); p++)
	    ;
	strncat(href, addr, p-addr);	/* Make complete hypertext reference */
d724 1
a724 1
    start_anchor(href);
d727 3
d776 1
a776 1
    CTRACE(tfp, "HTNews: EOF on read, closing socket %d\n", s);
d778 6
a783 2
    PUTS("Network Error: connection lost");
    PUTC('\n');
d788 1
a788 1
**  Determine if a line is a valid header line. 		valid_header
d792 1
a792 1
	char *, 	line)
d809 1
a809 1
    if (isalpha(line[0]) && colon && space == colon + 1)
d829 1
a829 1
	char *, 	postfile)
d845 1
a845 1
    if ((fd = fopen((postfile ? postfile : ""), "r")) == NULL) {
d856 1
a856 1
    while (fgets(line, sizeof(line), fd) != NULL) {
d884 1
a884 5
		    if (blen < 475) {
			strcat(buf, "From: anonymous@@nowhere.you.know");
			strcat(buf, crlf);
			blen += 34;
		    } else {
d886 1
a886 3
			sprintf(buf,
				"From: anonymous@@nowhere.you.know%s", crlf);
			blen = 34;
d888 3
d904 1
a904 4
	if ((blen + llen) < 511) {
	    strcat(buf, line);
	    blen += llen;
	} else {
d906 1
a906 2
	    strcpy(buf, line);
	    blen = llen;
d908 2
d917 1
a917 9
    if (blen < 508) {
	strcat(buf, ".");
	strcat(buf, crlf);
	blen += 3;
	NEWS_NETWRITE(s, buf, blen);
    } else {
	NEWS_NETWRITE(s, buf, blen);
	sprintf(buf, ".%s", crlf);
	blen = 3;
d919 1
d921 5
d940 62
d1041 1
a1041 1
	    *p++ = ich;
d1045 2
a1046 2
		    CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
				s);
d1051 1
a1051 1
		abort_socket(); 	/* End of file, close socket */
d1056 1
a1056 1
		CTRACE(tfp, "H %s\n", line);
d1078 1
a1078 1
		    if ((unsigned char)full_line[1] < ' ') {
d1082 1
a1082 1
		} else if ((unsigned char)full_line[0] < ' ') {
d1087 1
a1087 8
		    if (HTCJK == JAPANESE) {
			HTmmdecode(subject, subject);
			HTrjis(subject, subject);
		    }
		    if (*subject) {
			HTAnchor_setSubject(thisanchor, subject);
		    }

d1094 1
a1094 4
		    if (HTCJK == JAPANESE) {
			HTmmdecode(organization, organization);
			HTrjis(organization, organization);
		    }
d1098 1
a1098 4
		    if (HTCJK == JAPANESE) {
			HTmmdecode(from, from);
			HTrjis(from, from);
		    }
d1102 1
a1102 4
		    if (HTCJK == JAPANESE) {
			HTmmdecode(replyto, replyto);
			HTrjis(replyto, replyto);
		    }
d1117 1
a1117 1
			msgid++; 			/* Chop < */
d1140 1
a1140 1
	    char *temp=NULL;
d1142 1
a1142 1
	    StrAllocCopy(href,"mailto:");
d1288 1
a1288 1
	    if (!strncasecomp(NewsHREF, "snews:", 6))
d1349 1
a1349 1
	 *  No tags - kw
d1358 1
d1365 1
a1366 1
    PUTC('\n');
d1371 1
a1371 1
	*p++ = ich;
d1375 2
a1376 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d1386 4
a1389 1
	    CTRACE(tfp, "B %s", line);
d1394 1
a1394 1
		if ((unsigned char)line[1] < ' ') {
d1398 1
a1398 1
		    if (rawtext)
d1400 1
a1400 1
		    else
d1402 1
d1429 2
a1430 2
			char *q  = strchr(p2,'>');
			char *at = strchr(p2, '@@');
d1437 1
a1437 1
				if (strncmp(l, "news:", 5) &&
d1450 1
a1450 1
				    strncmp(l, "mailto:", 7) &&
d1452 1
a1452 1
				    strncmp(l, "gopher://", 9))
d1454 1
a1454 1
				else {
d1470 1
a1470 1
			    l=q+1;
d1476 1
a1476 1
			if (strncmp(l, "news:", 5) &&
d1489 1
a1489 1
			    strncmp(l, "mailto:", 7) &&
d1580 1
a1580 1
	char ch = ich;
d1584 2
a1585 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d1604 1
a1604 1
	    CTRACE(tfp, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch);
d1614 1
a1614 1
		CTRACE(tfp, "HTNews..... group name too long, discarding.\n");
d1626 1
a1626 1
	    CTRACE(tfp, "B %s", line);
d1631 1
a1631 1
		if ((unsigned char)line[1] < ' ') {
d1685 1
d1687 2
a1688 2
	sprintf(line, gettext("No matches for: %s"), arg);
	PUTS(line);
d1690 1
d1706 3
a1708 3
  CONST char *,groupName,
  int,first_required,
  int,last_required)
d1718 2
a1719 1
    char buffer[LINE_LENGTH];
d1737 2
a1738 2
    CTRACE(tfp, "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
		status, count, first, last, first_required, last_required);
d1748 1
a1748 1
	first_required = first; 	/* clip */
d1760 2
a1761 2
    CTRACE(tfp, "    Chunk will be (%d-%d)\n",
		first_required, last_required);
d1766 1
a1766 1
    sprintf(buffer, gettext("%s,  Articles %d-%d"),
d1769 2
a1770 1
    PUTS(buffer);
d1785 1
a1785 1
	CTRACE(tfp, "    Block before is %s\n", dbuf);
d1800 1
a1800 1
	sprintf(buffer,
d1803 2
a1804 1
	PUTS(buffer);
d1815 2
a1816 2
			CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
				    s);
d1826 1
a1826 1
		    CTRACE(tfp, "X %s", line);
d1831 1
a1831 1
			if ((unsigned char)line[1] < ' ') {
d1915 1
a1915 1
		    *p++ = ich;
d1919 2
a1920 2
			    CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
					s);
d1925 1
a1925 1
			abort_socket(); 	/* End of file, close socket */
d1933 1
a1933 1
			CTRACE(tfp, "G %s\n", line);
d1940 1
a1940 1
			    done = ((unsigned char)line[1] < ' ');
d1946 2
a1947 5
				strcpy(subject, line+9);/* Save subject */
				if (HTCJK == JAPANESE) {
				    HTmmdecode(subject, subject);
				    HTrjis(subject, subject);
				}
d1964 4
a1967 6
				strcpy(author,
					author_name(strchr(line,':')+1));
				if (HTCJK == JAPANESE) {
				    HTmmdecode(author, author);
				    HTrjis(author, author);
				}
d1988 5
a1992 1
		sprintf(buffer, "\"%s\"", subject);
d1994 1
a1994 1
		    write_anchor(buffer, reference);
d1997 1
a1997 1
		    PUTS(buffer);
d1999 2
d2005 3
d2009 1
d2022 1
a2022 1
		    sprintf(buffer, " [%s]", date);
d2032 2
a2033 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d2045 1
a2045 1
		    strcpy(buffer, "Status:");
d2074 1
a2074 1
	CTRACE(tfp, "    Block after is %s\n", dbuf);
d2093 1
a2093 1
	if (!strncasecomp(NewsHREF, "snews:", 6))
d2121 2
a2122 2
    char command[260];			/* The whole command */
    char proxycmd[260]; 		/* The proxy command */
d2124 1
a2124 1
    int status; 			/* tcp return */
d2126 1
d2132 1
a2132 1
    BOOL sreply_wanted; 	/* Flag: followup SSL post was asked for */
d2140 3
d2149 1
a2149 1
    CTRACE(tfp, "HTNews: Looking for %s\n", arg);
d2158 1
a2158 1
    command[259] = '\0';
d2160 1
a2160 1
    proxycmd[259] = '\0';
d2169 1
a2169 1
	**	xxx@@yyy 		Article
d2174 3
a2176 2
	spost_wanted = (strstr(arg, "snewspost:") != NULL);
	sreply_wanted = (!(spost_wanted) &&
d2178 1
a2178 1
	post_wanted = (!(spost_wanted || sreply_wanted) &&
d2180 1
a2180 1
	reply_wanted = (!(spost_wanted || sreply_wanted ||
d2183 1
a2183 1
	group_wanted = (!(spost_wanted || sreply_wanted ||
d2185 2
a2186 2
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') == NULL);
	list_wanted  = (!(spost_wanted || sreply_wanted ||
d2189 1
a2189 1
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') != NULL);
d2225 1
a2225 1
	    sprintf(command, "%s://%.245s/",
d2231 2
a2232 2
			      "snewspost" : "snewsreply"))), NewsHost);
	    StrAllocCopy(NewsHREF, command);
d2250 1
a2250 1
	} else if (!strncasecomp (arg, "nntp:", 5)) {
d2281 1
a2281 1
	    sprintf(command, "nntp://%.251s/", NewsHost);
d2284 1
a2284 1
	else if (!strncasecomp(arg, "snews:", 6)) {
d2313 1
a2313 1
	    StrAllocCopy(NewsHost, cp);
d2316 1
a2316 1
	    sprintf(command, "snews://%.250s/", NewsHost);
d2351 1
a2351 1
	    sprintf(command, "news://%.251s/", NewsHost);
d2365 1
a2365 1
	    StrAllocCopy(NewsHREF, "news:");
d2374 1
a2374 1
	if (!strncasecomp(p1, "snews:", 6) ||
d2379 1
a2379 1
		sprintf(command, "snews://%.250s", cp);
d2382 1
a2382 1
		sprintf(command, "snews://%.250s", NewsHost);
d2384 1
a2384 1
	    command[258] = '\0';
d2386 5
a2390 3
	    sprintf(proxycmd, "GET %.251s%c%c%c%c", command, CR, LF, CR, LF);
	    CTRACE(tfp, "HTNews: Proxy command is '%.*s'\n",
			(int)(strlen(proxycmd) - 4), proxycmd);
d2405 1
a2405 1
		**  Reset p1 so that it points to the newgroup
d2424 7
a2430 1
	    sprintf(command, "XGTITLE %.*s", 249, p1);
a2432 1
	    strcpy(command, "GROUP ");
d2437 7
a2443 1
		strcpy(groupName, p1);
d2446 1
a2446 1
		if ((first > 0) && (isdigit(*(slash+1))) &&
d2459 7
a2465 1
		strcpy(groupName, p1);
d2467 1
a2467 1
	    strcat(command, groupName);
d2469 13
a2481 6
	    strcpy(command, "ARTICLE ");
	    if (strchr(p1, '<') == 0)
		strcat(command,"<");
	    strcat(command, p1);
	    if (strchr(p1, '>') == 0)
		strcat(command,">");
d2507 1
a2507 1
	if (head_wanted && !strncmp(command, "ARTICLE_", 8)) {
d2514 1
a2514 1
	rawtext = (head_wanted || keep_mime_headers);
d2548 2
a2549 2
	    if (!strcmp(NewsHREF, "news:")) {
		sprintf (url, "lose://%.251s/", NewsHost);
d2551 1
a2551 1
		sprintf (url, "%.259s", ProxyHREF);
d2553 1
a2553 1
		sprintf (url, "%.259s", NewsHREF);
d2555 1
a2555 1
	    CTRACE (tfp, "News: doing HTDoConnect on '%s'\n", url);
d2561 1
a2561 1
		(!strncmp(arg, "snews:", 6) ||
d2575 1
a2575 1
		CTRACE(tfp, "HTNews: Interrupted on connect; recovering cleanly.\n");
d2601 1
a2601 1
		CTRACE(tfp, "HTNews: Unable to connect to news host.\n");
d2620 2
a2621 2
		CTRACE(tfp, "HTNews: Connected to news host %s.\n",
			    NewsHost);
d2633 1
d2637 6
a2642 3
			CTRACE(tfp,
"HTNews: Unable to complete SSL handshake for remote host '%s' (SSLerror = %d)\n",
			       url, status);
d2666 2
a2667 1
		    _HTProgress(SSL_get_cipher(Handle));
d2670 1
a2670 1
		HTInitInput(s); 	/* set up buffering */
d2673 2
a2674 2
		    CTRACE(tfp, "HTNews: Proxy command returned status '%d'.\n",
				status);
d2698 4
d2706 2
a2707 1
			HTSprintf0(&dbuf,
d2710 5
d2759 2
a2760 1
		postfile = LYNewsPost(ListArg, (reply_wanted || sreply_wanted));
d2807 6
d2829 1
a2829 1
	 *  some checks to see whether the response rorresponds to the
d2973 5
a2977 4
    /* HTAlert(gettext("Sorry, could not load requested news.")); */

/*    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.",
	    NULL,NULL,NULL, arg);No -- message earlier wil have covered it */
d2999 1
a2999 1
**  invoking the free_HTAAGlobals() function, which normally
d3024 1
a3024 1
        return HTGetCharacter();
d3026 1
a3026 1
        return HTGetSSLCharacter((void *)Handle);
d3029 6
a3034 4
PUBLIC int HTNewsProxyConnect ARGS5 (int, sock, CONST char *, url, 
				     HTParentAnchor *, anAnchor,
				     HTFormat, format_out,
				     HTStream *, sink)
d3038 1
d3043 1
d3047 7
a3053 4
        channel_s = -1;
	CTRACE(tfp,
"HTTP: Unable to complete SSL handshake for remote host '%s' (SSLerror = %d)\n",
		   url, status);
d3059 5
a3063 1
    _HTProgress(SSL_get_cipher(Handle));
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 6
a7 6
 *			===========
 *
 * History:
 *	26 Sep 90	Written TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 */
a18 2
#include <HTFont.h>
#include <HTFormat.h>
d21 3
a23 1
#include <LYStrings.h>
d28 2
a29 2
int HTNewsChunkSize = 30;	/* Number of articles for quick display */
int HTNewsMaxChunk = 40;	/* Largest number of articles in one window */
d34 3
a36 8

#ifndef NEWS_SERVER_FILE
#define NEWS_SERVER_FILE "/usr/local/lib/rn/server"
#endif /* NEWS_SERVER_FILE */

#ifndef NEWS_AUTH_FILE
#define NEWS_AUTH_FILE ".newsauth"
#endif /* NEWS_AUTH_FILE */
d39 7
a45 3
static SSL *Handle = NULL;
static int channel_s = 1;

d49 3
a51 3
	{ (void)NETCLOSE(sock); if (Handle) { SSL_free(Handle); Handle = NULL; } }
static char HTNewsGetCharacter(void);

a59 1
#include <HTAccess.h>
a67 2
#define SnipIn(d,fmt,len,s)      sprintf(d, fmt,      (int)sizeof(d)-len, s)
#define SnipIn2(d,fmt,tag,len,s) sprintf(d, fmt, tag, (int)sizeof(d)-len, s)
d70 2
a71 2
    const HTStructuredClass *isa;
    /* ... */
d73 3
a75 2
struct _HTStream {
    HTStreamClass *isa;
d78 1
a78 1
#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
d80 7
d89 20
a108 21
 *  Module-wide variables.
 */
char *HTNewsHost = NULL;	/* Default host */
static char *NewsHost = NULL;	/* Current host */
static char *NewsHREF = NULL;	/* Current HREF prefix */
static int s;			/* Socket for NewsHost */
static int HTCanPost = FALSE;	/* Current POST permission */
static char response_text[LINE_LENGTH + 1];	/* Last response */

/* static HText *	HT;	*//* the new hypertext */
static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */
static HTStream *rawtarget = NULL;	/* The output sink for rawtext */
static HTStreamClass rawtargetClass;	/* Copy of fn addresses */
static HTParentAnchor *node_anchor;	/* Its anchor */
static int diagnostic;		/* level: 0=none 2=source */
static BOOL rawtext = NO;	/* Flag: HEAD or -mime_headers */
static HTList *NNTP_AuthInfo = NULL;	/* AUTHINFO database */
static char *name = NULL;
static char *address = NULL;
static char *dbuf = NULL;	/* dynamic buffer for long messages etc. */
d123 3
a125 3
    char *host;
    char *user;
    char *pass;
d129 1
a129 1
static void free_news_globals(void)
d144 1
a144 1
static void free_NNTP_AuthInfo(void)
d152 1
a152 1
    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
d163 1
a163 39
/*
 * Initialize the authentication list by loading the user's $HOME/.newsauth
 * file.  That file is part of tin's configuration and is used by a few other
 * programs.
 */
static void load_NNTP_AuthInfo(void)
{
    FILE *fp;
    char fname[LY_MAXPATH];
    char buffer[LINE_LENGTH + 1];

    LYAddPathToHome(fname, sizeof(fname), NEWS_AUTH_FILE);

    if ((fp = fopen(fname, "r")) != 0) {
	while (fgets(buffer, sizeof(buffer), fp) != 0) {
	    char the_host[LINE_LENGTH + 1];
	    char the_pass[LINE_LENGTH + 1];
	    char the_user[LINE_LENGTH + 1];

	    if (sscanf(buffer, "%s%s%s", the_host, the_pass, the_user) == 3
		&& strlen(the_host) != 0
		&& strlen(the_pass) != 0
		&& strlen(the_user) != 0) {
		NNTPAuth *auth = typecalloc(NNTPAuth);

		if (auth == NULL)
		    break;
		StrAllocCopy(auth->host, the_host);
		StrAllocCopy(auth->pass, the_pass);
		StrAllocCopy(auth->user, the_user);

		HTList_appendObject(NNTP_AuthInfo, auth);
	    }
	}
	fclose(fp);
    }
}

const char *HTGetNewsHost(void)
d165 1
a165 1
    return HTNewsHost;
d168 1
a168 1
void HTSetNewsHost(const char *value)
d170 1
a170 1
    StrAllocCopy(HTNewsHost, value);
d174 19
a192 19
 *	------------------------------
 *
 *	Except on the NeXT, we pick up the NewsHost name from
 *
 *	1.	Environment variable NNTPSERVER
 *	2.	File NEWS_SERVER_FILE
 *	3.	Compilation time macro DEFAULT_NEWS_HOST
 *	4.	Default to "news"
 *
 *	On the NeXT, we pick up the NewsHost name from, in order:
 *
 *	1.	WorldWideWeb default "NewsHost"
 *	2.	Global default "NewsHost"
 *	3.	News default "NewsHost"
 *	4.	Compilation time macro DEFAULT_NEWS_HOST
 *	5.	Default to "news"
 */
static BOOL initialized = NO;
static BOOL initialize(void)
d199 2
a200 2
     * Get name of Host.
     */
d202 2
a203 2
    if ((cp = NXGetDefaultValue("WorldWideWeb", "NewsHost")) == 0) {
	if ((cp = NXGetDefaultValue("News", "NewsHost")) == 0) {
d212 4
a215 4
    if (LYGetEnv("NNTPSERVER")) {
	StrAllocCopy(HTNewsHost, LYGetEnv("NNTPSERVER"));
	CTRACE((tfp, "HTNews: NNTPSERVER defined as `%s'\n",
		HTNewsHost));
d217 2
a218 2
	FILE *fp = fopen(NEWS_SERVER_FILE, TXT_R);

d220 1
a220 7
	    char server_name[MAXHOSTNAMELEN + 1];

	    if (fgets(server_name, sizeof server_name, fp) != NULL) {
		char *p = strchr(server_name, '\n');

		if (p != NULL)
		    *p = '\0';
d222 2
a223 2
		CTRACE((tfp, "HTNews: File %s defines news host as `%s'\n",
			NEWS_SERVER_FILE, HTNewsHost));
d232 1
a232 1
    s = -1;			/* Disconnected */
d240 10
a249 10
 *	------------------------------------------------------
 *
 * On entry,
 *	command points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is an NNTP status.
 */
static int response(char *command)
d252 1
a252 1
    char *p = response_text;
d258 1
a258 2

	CTRACE((tfp, "NNTP command to be sent: %s", command));
d261 5
a265 6
	    const char *p2;
	    char *q;
	    char ascii[LINE_LENGTH + 1];

	    for (p2 = command, q = ascii; *p2; p2++, q++) {
		*q = TOASCII(*p2);
d270 1
a270 1
	status = NEWS_NETWRITE(s, (char *) command, length);
d272 2
a273 2
	if (status < 0) {
	    CTRACE((tfp, "HTNews: Unable to send command. Disconnecting.\n"));
d277 3
a279 3
	}			/* if bad status */
    }
    /* if command to be sent */
d282 1
a282 1
	if (((*p++ = (char) ich) == LF) ||
d284 2
a285 2
	    *--p = '\0';	/* Terminate the string */
	    CTRACE((tfp, "NNTP Response: %s\n", response_text));
d288 2
a289 2
	}
	/* if end of line */
d291 1
a291 1
	    *(p - 1) = '\0';
d293 2
a294 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d296 2
a297 2
		CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n",
			s));
d303 1
a303 1
		return (HT_INTERRUPTED);
d305 1
a305 1
	    return ((int) EOF);	/* End of file on response */
d307 1
a307 1
    }				/* Loop over characters */
d311 7
a317 7
 *	-----------------------------------
 *
 * On entry,
 *	template must be already in upper case.
 *	unknown may be in upper or lower or mixed case to match.
 */
static BOOL match(const char *unknown, const char *ctemplate)
d319 5
a323 5
    const char *u = unknown;
    const char *t = ctemplate;

    for (; *u && *t && (TOUPPER(*u) == *t); u++, t++) ;		/* Find mismatch or end */
    return (BOOL) (*t == 0);	/* OK if end of template */
d327 3
a329 3
    NNTPAUTH_ERROR = 0,		/* general failure */
    NNTPAUTH_OK = 281,		/* authenticated successfully */
    NNTPAUTH_CLOSE = 502	/* server probably closed connection */
a330 1

d332 4
a335 3
 *  This function handles nntp authentication. - FM
 */
static NNTPAuthResult HTHandleAuthInfo(char *host)
d346 2
a347 2
     * Make sure we have an interactive user and a host.  - FM
     */
d352 12
a363 3
     * Check for an existing authorization entry.  - FM
     */
    if (NNTP_AuthInfo == NULL) {
a364 1
	load_NNTP_AuthInfo();
a369 9
    cur = NNTP_AuthInfo;
    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
	if (!strcmp(auth->host, host)) {
	    UserName = auth->user;
	    PassWord = auth->pass;
	    break;
	}
    }

d371 3
a373 3
     * Handle the username.  - FM
     */
    buffer[sizeof(buffer) - 1] = '\0';
d378 4
a381 1
	    HTSprintf0(&msg, gettext("Username for news host '%s':"), host);
d389 1
a389 2
	sprintf(buffer, "AUTHINFO USER %.*s%c%c",
		(int) sizeof(buffer) - 17, UserName, CR, LF);
d407 2
a408 2
	     * Username is accepted and no password is required.  - FM
	     */
d416 4
a419 3
		 * Store the accepted username and no password.  - FM
		 */
		if ((auth = typecalloc(NNTPAuth)) != NULL) {
d429 3
a431 3
	     * Not success, nor a request for the password, so it must be an
	     * error.  - FM
	     */
d438 1
a438 2
		if ((UserName = HTPrompt(gettext("Username:"), UserName))
		    != NULL &&
d457 2
a458 2
	 * Handle the password.  - FM
	 */
d462 4
a465 1
		HTSprintf0(&msg, gettext("Password for news host '%s':"), host);
d473 1
a473 2
	    sprintf(buffer, "AUTHINFO PASS %.*s%c%c",
		    (int) sizeof(buffer) - 17, PassWord, CR, LF);
d497 2
a498 2
		 * That's what INN's nnrpd returns.  It closes the connection
		 * after this.  - kw
d514 4
a517 4
		/*
		 * Password also is accepted, and everything has been stored. 
		 * - FM
		 */
d528 2
a529 1
		    if ((auth = typecalloc(NNTPAuth)) != NULL) {
d539 2
a540 2
	     * Not success, so it must be an error.  - FM
	     */
d566 12
a577 12
 *	----------------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "Tim Berners-Lee" if given any of
 *	" Tim Berners-Lee <tim@@online.cern.ch> "
 *  or	" tim@@online.cern.ch ( Tim Berners-Lee ) "
 */
static char *author_name(char *email)
d582 1
a582 1
    CTRACE((tfp, "Trying to find name in: %s\n", name));
d584 1
a584 1
    if ((p = strrchr(name, '(')) && (e = strrchr(name, ')'))) {
d586 2
a587 2
	    *e = '\0';		/* Chop off everything after the ')'  */
	    return HTStrip(p + 1);	/* Remove leading and trailing spaces */
d591 3
a593 4
    if ((p = strrchr(name, '<')) && (e = strrchr(name, '>'))) {
	if (e++ > p) {
	    while ((*p++ = *e++) != 0)	/* Remove <...> */
		;
d598 1
a598 1
    return HTStrip(name);	/* Default to the whole thing */
d602 12
a613 12
 *	--------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "montulli@@spaced.out.galaxy.net" if given any of
 *	" Lou Montulli <montulli@@spaced.out.galaxy.net> "
 *  or	" montulli@@spaced.out.galaxy.net ( Lou "The Stud" Montulli ) "
 */
static char *author_address(char *email)
d618 1
a618 1
    CTRACE((tfp, "Trying to find address in: %s\n", address));
d620 2
a621 2
    if ((p = strrchr(address, '<'))) {
	if ((e = strrchr(p, '>')) && (at = strrchr(p, '@@'))) {
d623 2
a624 2
		*e = '\0';	/* Remove > */
		return HTStrip(p + 1);	/* Remove leading and trailing spaces */
d629 2
a630 2
    if ((p = strrchr(address, '(')) &&
	(e = strrchr(address, ')')) && (at = strchr(address, '@@'))) {
d632 1
a632 1
	    *p = '\0';		/* Chop off everything after the ')'  */
d637 1
a637 1
    if ((at = strrchr(address, '@@')) && at > address) {
d640 1
a640 1
	while (p > address && !isspace(UCH(*p)))
d642 1
a642 1
	while (*e && !isspace(UCH(*e)))
d649 2
a650 2
     * Default to the first word.
     */
d652 2
a653 2
    while (isspace(UCH(*p)))
	p++;			/* find first non-space */
d655 3
a657 3
    while (!isspace(UCH(*e)) && *e != '\0')
	e++;			/* find next space or end */
    *e = '\0';			/* terminate space */
d659 1
a659 1
    return (p);
d663 3
a665 3
 *	--------------------
 */
static void start_anchor(const char *href)
d667 2
a668 3
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];
    int i;
d670 8
a677 4
    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
    value[HTML_A_HREF] = href;
    (*targetClass.start_element) (target, HTML_A, present, value, -1, 0);
d681 3
a683 3
 *	------------------
 */
static void start_link(const char *href, const char *rev)
d685 2
a686 3
    BOOL present[HTML_LINK_ATTRIBUTES];
    const char *value[HTML_LINK_ATTRIBUTES];
    int i;
d688 9
a696 5
    for (i = 0; i < HTML_LINK_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_LINK_HREF || i == HTML_LINK_REV);
    value[HTML_LINK_HREF] = href;
    value[HTML_LINK_REV] = rev;
    (*targetClass.start_element) (target, HTML_LINK, present, value, -1, 0);
d700 3
a702 3
 *	------------------
 */
static void start_list(int seqnum)
d704 2
a705 2
    BOOL present[HTML_OL_ATTRIBUTES];
    const char *value[HTML_OL_ATTRIBUTES];
d710 1
a710 1
	present[i] = (BOOL) (i == HTML_OL_SEQNUM || i == HTML_OL_START);
d712 4
a715 3
    value[HTML_OL_SEQNUM] = SeqNum;
    value[HTML_OL_START] = SeqNum;
    (*targetClass.start_element) (target, HTML_OL, present, value, -1, 0);
d719 19
a737 23
 *	------------------
 *
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext reference address,
 *		terminated by white space, comma, NULL or '>'
 */
static void write_anchor(const char *text, const char *addr)
{
    char href[LINE_LENGTH + 1];
    const char *p;
    char *q;

    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p != ','); p++) ;
    if (strlen(NewsHREF) + (p - addr) + 1 < sizeof(href)) {
	q = href;
	strcpy(q, NewsHREF);
	strncat(q, addr, p - addr);	/* Make complete hypertext reference */
    } else {
	q = NULL;
	HTSprintf0(&q, "%s%.*s", NewsHREF, p - addr, addr);
d740 1
a740 1
    start_anchor(q);
a742 3

    if (q != href)
	FREE(q);
d746 12
a757 12
 *	---------------------
 *
 *	We take a pointer to a list of objects, and write out each,
 *	generating an anchor for each.
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to a comma or space separated list of addresses.
 * On exit,
 *	*text	is NOT any more chopped up into substrings.
 */
static void write_anchors(char *text)
d759 2
a760 2
    char *start = text;
    char *end;
a761 1

d763 2
a764 1
	for (; *start && (WHITE(*start)); start++) ;	/* Find start */
d766 1
a766 1
	    return;		/* (Done) */
d768 2
a769 1
	     *end && (*end != ' ') && (*end != ','); end++) ;	/* Find end */
d771 1
a771 1
	    end++;		/* Include comma or space but not NULL */
d775 1
a775 1
	    write_anchor(start, start + 1);
d780 1
a780 1
	start = end;		/* Point to next one */
d785 3
a787 3
 *	--------------------
 */
static void abort_socket(void)
d789 5
a793 9
    CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n", s));
    NEWS_NETCLOSE(s);		/* End of file, close socket */
    if (rawtext) {
	RAW_PUTS("Network Error: connection lost\n");
    } else {
	PUTS("Network Error: connection lost");
	PUTC('\n');
    }
    s = -1;			/* End of file on response */
d797 5
a801 4
 *  Determine if a line is a valid header line.			valid_header
 *  -------------------------------------------
 */
static BOOLEAN valid_header(char *line)
d806 3
a808 2
     * Blank or tab in first position implies this is a continuation header.
     */
d810 1
a810 1
	return (TRUE);
d813 3
a815 3
     * Just check for initial letter, colon, and space to make sure we discard
     * only invalid headers.
     */
d818 2
a819 2
    if (isalpha(UCH(line[0])) && colon && space == colon + 1)
	return (TRUE);
d822 3
a824 3
     * Anything else is a bad header -- it should be ignored.
     */
    return (FALSE);
d828 11
a838 10
 *	------------------
 *			(added by FM, modeled on Lynx's previous mini inews)
 *
 *	Note the termination condition of a single dot on a line by itself.
 *
 *  On entry,
 *	s		Global socket number is OK
 *	postfile	file with header and article to post.
 */
static void post_article(char *postfile)
d849 1
d851 4
a854 3
     * Open the temporary file with the nntp headers and message body.  - FM
     */
    if ((fd = fopen(NonNull(postfile), TXT_R)) == NULL) {
d860 3
a862 2
     * Read the temporary file and post in maximum 512 byte chunks.  - FM
     */
d865 1
a865 1
    while (fgets(line, sizeof(line) - 2, fd) != NULL) {
d870 11
a880 7
	     * A single '.' means end of transmission for nntp.  Lead dots on
	     * lines normally are trimmed and the EOF is not registered if the
	     * dot was not followed by CRLF.  We prepend an extra dot for any
	     * line beginning with one, to retain the one intended, as well as
	     * avoid a false EOF signal.  We know we have room for it in the
	     * buffer, because we normally send when it would exceed 510.  - FM
	     */
d893 5
a897 1
		    if (blen >= (int) sizeof(buf) - 35) {
d899 3
a901 1
			buf[blen = 0] = 0;
a902 3
		    strcat(buf, "From: anonymous@@nowhere.you.know");
		    strcat(buf, crlf);
		    blen += 34;
d904 1
a904 1
	    } else {
d916 4
a919 1
	if ((blen + llen) >= (int) sizeof(buf) - 1) {
d921 2
a922 1
	    buf[blen = 0] = 0;
a923 2
	strcat(buf, line);
	blen += llen;
d929 11
a939 3
     * Send the nntp EOF and get the server's response.  - FM
     */
    if (blen >= (int) sizeof(buf) - 4) {
a940 1
	buf[blen = 0] = 0;
a941 5
    strcat(buf, ".");
    strcat(buf, crlf);
    blen += 3;
    NEWS_NETWRITE(s, buf, blen);

d945 2
a946 2
	 * Successful post.  - FM
	 */
d950 2
a951 2
	 * Shucks, something went wrong.  - FM
	 */
a955 61
#ifdef SH_EX			/* for MIME */
#ifdef NEWS_DEBUG
/* for DEBUG 1997/11/07 (Fri) 17:20:16 */
void debug_print(unsigned char *p)
{
    while (*p) {
	if (*p == '\0')
	    break;
	if (*p == 0x1b)
	    printf("[ESC]");
	else if (*p == '\n')
	    printf("[NL]");
	else if (*p < ' ' || *p >= 0x80)
	    printf("(%02x)", *p);
	else
	    putchar(*p);
	p++;
    }
    printf("]\n");
}
#endif

static char *decode_mime(char *str)
{
    char temp[LINE_LENGTH];	/* FIXME: what determines the actual size? */
    char *p, *q;

    if (str == NULL)
	return "";

    if (HTCJK != JAPANESE)
	return str;

    LYstrncpy(temp, str, sizeof(temp) - 1);
    q = temp;
    while ((p = strchr(q, '=')) != 0) {
	if (p[1] == '?') {
	    HTmmdecode(p, p);
	    q = p + 2;
	} else {
	    q = p + 1;
	}
    }
#ifdef NEWS_DEBUG
    printf("new=[");
    debug_print(temp);
#endif
    HTrjis(temp, temp);
    strcpy(str, temp);

    return str;
}
#else /* !SH_EX */
static char *decode_mime(char *str)
{
    HTmmdecode(str, str);
    HTrjis(str, str);
    return str;
}
#endif

d957 12
a968 11
 *	------------------
 *
 *	Note the termination condition of a single dot on a line by itself.
 *	RFC 977 specifies that the line "folding" of RFC850 is not used, so we
 *	do not handle it here.
 *
 * On entry,
 *	s	Global socket number is OK
 *	HT	Global hypertext object is ready for appending text
 */
static int read_article(HTParentAnchor *thisanchor)
d970 1
a970 1
    char line[LINE_LENGTH + 1];
d972 8
a979 8
    char *subject = NULL;	/* Subject string           */
    char *from = NULL;		/* From string              */
    char *replyto = NULL;	/* Reply-to string          */
    char *date = NULL;		/* Date string              */
    char *organization = NULL;	/* Organization string      */
    char *references = NULL;	/* Hrefs for other articles */
    char *newsgroups = NULL;	/* Newsgroups list          */
    char *followupto = NULL;	/* Followup list            */
d983 1
a983 1
    const char *ccp;
d987 5
a991 5
     * Read in the HEADer of the article.
     *
     * The header fields are either ignored, or formatted and put into the
     * text.
     */
d995 1
a995 2

	    *p++ = (char) ich;
d999 2
a1000 3
		    CTRACE((tfp,
			    "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1003 1
a1003 1
		    return (HT_INTERRUPTED);
d1005 2
a1006 2
		abort_socket();	/* End of file, close socket */
		return (HT_LOADED);	/* End of file on response */
d1008 3
a1010 3
	    if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
		*--p = '\0';	/* Terminate the string */
		CTRACE((tfp, "H %s\n", line));
a1013 1

d1030 3
a1032 3
		     * End of article?
		     */
		    if (UCH(full_line[1]) < ' ') {
d1036 2
a1037 2
		} else if (UCH(full_line[0]) < ' ') {
		    break;	/* End of Header? */
d1040 9
a1048 2
		    StrAllocCopy(subject, HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(subject);
d1050 1
a1050 1
		    StrAllocCopy(date, HTStrip(strchr(full_line, ':') + 1));
d1054 5
a1058 2
				 HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(organization);
d1061 5
a1065 2
		    StrAllocCopy(from, HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(from);
d1068 5
a1072 2
		    StrAllocCopy(replyto, HTStrip(strchr(full_line, ':') + 1));
		    decode_mime(replyto);
d1075 1
a1075 1
		    StrAllocCopy(newsgroups, HTStrip(strchr(full_line, ':') + 1));
d1078 1
a1078 1
		    StrAllocCopy(references, HTStrip(strchr(full_line, ':') + 1));
d1081 1
a1081 1
		    StrAllocCopy(followupto, HTStrip(strchr(full_line, ':') + 1));
d1084 4
a1087 5
		    char *msgid = HTStrip(full_line + 11);

		    if (msgid[0] == '<' && msgid[strlen(msgid) - 1] == '>') {
			msgid[strlen(msgid) - 1] = '\0';	/* Chop > */
			msgid++;	/* Chop < */
d1091 4
a1094 4
		}		/* end if match */
		p = line;	/* Restart at beginning */
	    }			/* if end of line */
	}			/* Loop over characters */
d1107 2
a1108 2
	 * Put in the owner as a link rel.
	 */
d1110 1
a1110 2
	    char *temp = NULL;

d1112 1
a1112 1
	    StrAllocCopy(href, STR_MAILTO_URL);
d1232 3
a1234 3
	     * "Followup-To:  poster" has special meaning.  Don't use it to
	     * construct a newsreply link.  -kw
	     */
d1254 6
a1259 5
	     * We have permission to POST to this host, so add a link for
	     * posting followups for this article.  - FM
	     */
	    if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
		StrAllocCopy(href, "snewsreply://");
d1261 1
a1261 1
		StrAllocCopy(href, "newsreply://");
a1272 1

d1319 1
a1319 1
	 * No tags, and never do a PUTC.  - kw
d1324 3
a1326 3
	 * Read in the HEAD and BODY of the Article as XMP formatted text.  -
	 * FM
	 */
a1327 1
	PUTC('\n');
d1330 3
a1332 2
	 * Read in the BODY of the Article as PRE formatted text.  - FM
	 */
a1333 1
	PUTC('\n');
d1335 1
d1340 1
a1340 2

	*p++ = (char) ich;
d1344 2
a1345 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d1348 1
a1348 1
		return (HT_INTERRUPTED);
d1351 1
a1351 1
	    return (HT_LOADED);	/* End of file on response */
d1353 3
a1355 6
	if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
	    *p++ = '\0';	/* Terminate the string */
	    CTRACE((tfp, "B %s", line));
#ifdef NEWS_DEBUG		/* 1997/11/09 (Sun) 15:56:11 */
	    debug_print(line);	/* @@@@@@ */
#endif
d1358 3
a1360 3
		 * End of article?
		 */
		if (UCH(line[1]) < ' ') {
d1363 2
a1364 2
		} else {	/* Line starts with dot */
		    if (rawtext) {
d1366 2
a1367 3
		    } else {
			PUTS(&line[1]);		/* Ignore first dot */
		    }
d1374 2
a1375 2
		     * All lines are passed as unmodified source.  - FM
		     */
d1379 11
a1389 10
		     * Normal lines are scanned for buried references to other
		     * articles.  Unfortunately, it could pick up mail
		     * addresses as well!  It also can corrupt uuencoded
		     * messages!  So we don't do this when fetching articles as
		     * WWW_SOURCE or when downloading (diagnostic is TRUE) or
		     * if the client has set scan_for_buried_news_references to
		     * FALSE.  Otherwise, we convert all "<...@@...>" strings
		     * preceded by "rticle " to "news:...@@..." links, and any
		     * strings that look like URLs to links.  - FM
		     */
d1394 3
a1396 4
			char *q = strrchr(p2, '>');
			char *at = strrchr(p2, '@@');

			if (q && at && at < q) {
d1398 1
a1398 2

			    q[1] = 0;	/* chop up */
d1402 1
a1402 1
				if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1415 1
a1415 1
				    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1417 3
a1419 3
				    strncmp(l, "gopher://", 9)) {
				    PUTC(*l++);
				} else {
d1428 1
a1428 1
			    *p2 = '<';	/* again */
d1430 2
a1431 2
			    start_anchor(p2 + 1);
			    *q = '>';	/* again */
d1434 2
a1435 2
			    q[1] = c;	/* again */
			    l = q + 1;
d1437 1
a1437 1
			    break;	/* line has unmatched <> */
d1440 2
a1441 2
		    while (*l) {	/* Last bit of the line */
			if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1454 1
a1454 1
			    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1457 1
a1457 1
			    PUTC(*l++);
d1467 5
a1471 5
		}		/* if diagnostic or not scan_for_buried_news_references */
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */
d1474 1
a1474 1
	return (HT_LOADED);
d1481 1
a1481 1
    return (HT_LOADED);
d1485 7
a1491 7
 *	----------------------------
 *
 *  Note the termination condition of a single dot on a line by itself.
 *  RFC 977 specifies that the line "folding" of RFC850 is not used,
 *  so we do not handle it here.
 */
static int read_list(char *arg)
d1493 1
a1493 1
    char line[LINE_LENGTH + 1];
d1505 2
a1506 2
     * Support head or tail matches for groups to list.  - FM
     */
d1510 2
a1511 2
	    StrAllocCopy(pattern, (arg + 1));
	} else if (arg[strlen(arg) - 1] == '*') {
d1514 1
a1514 1
	    pattern[strlen(pattern) - 1] = '\0';
d1517 1
a1517 1
	    len = strlen(pattern);
d1523 5
a1527 4
     * Read the server's reply.
     *
     * The lines are scanned for newsgroup names and descriptions.
     */
d1537 1
a1537 1
    PUTS("Newsgroups");
d1545 1
a1545 2
	char ch = (char) ich;

d1549 2
a1550 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d1553 1
a1553 1
		return (HT_INTERRUPTED);
d1557 1
a1557 1
	    return (HT_LOADED);	/* End of file on response */
d1569 1
a1569 1
	    CTRACE((tfp, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch));
d1575 1
a1575 1
		skip_this_line = YES;	/* ...and ignore until LF */
d1579 2
a1580 2
		CTRACE((tfp, "HTNews..... group name too long, discarding.\n"));
		skip_this_line = YES;	/* ignore whole line */
d1583 1
a1583 1
		skip_rest_of_line = YES;	/* skip until ch == LF found */
d1590 2
a1591 2
	    *p = '\0';		/* Terminate the string */
	    CTRACE((tfp, "B %s", line));
d1594 3
a1596 3
		 * End of article?
		 */
		if (UCH(line[1]) < ' ') {
d1599 1
a1599 1
		} else {	/* Line starts with dot */
d1605 1
a1605 1
		p = line;	/* Restart at beginning */
d1609 2
a1610 2
		 * Normal lines are scanned for references to newsgroups.
		 */
d1614 2
a1615 1
		for (; line[i] != '\0' && !WHITE(line[i]); i++) ;	/* null body */
d1631 1
a1631 1
		    PUTS(&line[i + 1]);		/* put description */
d1645 4
a1648 4
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */
a1649 2
	char *msg = NULL;

d1651 2
a1652 2
	HTSprintf0(&msg, gettext("No matches for: %s"), arg);
	PUTS(msg);
a1653 1
	FREE(msg);
d1658 1
a1658 1
    return (HT_LOADED);
d1662 14
a1675 13
 *	-------------------
 *
 *  Unfortunately, we have to ask for each article one by one if we
 *  want more than one field.
 *
 */
static int read_group(const char *groupName,
		      int first_required,
		      int last_required)
{
    char line[LINE_LENGTH + 1];
    char author[LINE_LENGTH + 1];
    char subject[LINE_LENGTH + 1];
d1681 3
a1683 4
    char buffer[LINE_LENGTH + 1];
    char *temp = NULL;
    char *reference = NULL;	/* Href for article */
    int art;			/* Article number WITHIN GROUP */
d1685 1
a1685 2

    /* count is only an upper limit */
d1699 2
a1700 2
    CTRACE((tfp, "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
	    status, count, first, last, first_required, last_required));
d1705 1
d1710 1
a1710 1
	first_required = first;	/* clip */
d1719 2
a1720 2
    if (last_required - first_required + 1 > HTNewsMaxChunk) {	/* Trim this block */
	first_required = last_required - HTNewsChunkSize + 1;
d1722 2
a1723 2
    CTRACE((tfp, "    Chunk will be (%d-%d)\n",
	    first_required, last_required));
d1726 4
a1729 4
     * Set window title.
     */
    HTSprintf0(&temp, gettext("%s,  Articles %d-%d"),
	       groupName, first_required, last_required);
d1731 1
a1731 2
    PUTS(temp);
    FREE(temp);
d1736 2
a1737 2
     * Link to earlier articles.
     */
d1739 2
a1740 3
	int before;		/* Start of one before */

	if (first_required - HTNewsMaxChunk <= first)
d1743 1
a1743 1
	    before = first_required - HTNewsChunkSize;
d1745 2
a1746 2
		   before, first_required - 1);
	CTRACE((tfp, "    Block before is %s\n", dbuf));
d1760 5
a1764 6
    if (count > FAST_THRESHOLD) {
	HTSprintf0(&temp,
		   gettext("\nThere are about %d articles currently available in %s, IDs as follows:\n\n"),
		   count, groupName);
	PUTS(temp);
	FREE(temp);
a1770 1

d1775 2
a1776 3
			CTRACE((tfp,
				"HTNews: Interrupted on read, closing socket %d\n",
				s));
d1779 1
a1779 1
			return (HT_INTERRUPTED);
d1782 1
a1782 1
		    return (HT_LOADED);		/* End of file on response */
d1784 3
a1786 3
		if (((char) ich == '\n') || (p == &line[LINE_LENGTH])) {
		    *p = '\0';	/* Terminate the string */
		    CTRACE((tfp, "X %s", line));
d1789 3
a1791 3
			 * End of article?
			 */
			if (UCH(line[1]) < ' ') {
d1794 2
a1795 2
			} else {	/* Line starts with dot */
			    /* Ignore strange line */
d1799 4
a1802 4
			 * Normal lines are scanned for references to articles.
			 */
			char *space = strchr(line, ' ');

d1805 4
a1808 4
		    }		/* if not dot */
		    p = line;	/* Restart at beginning */
		}		/* if end of line */
	    }			/* Loop over characters */
d1811 1
a1811 1
	}			/* Good status */
d1816 2
a1817 2
     * Read newsgroup using individual fields.
     */
d1835 7
a1841 7
	     * With this code we try to keep the server running flat out by
	     * queuing just one extra command ahead of time.  We assume (1)
	     * that the server won't abort if it gets input during output, and
	     * (2) that TCP buffering is enough for the two commands.  Both
	     * these assumptions seem very reasonable.  However, we HAVE had a
	     * hangup with a loaded server.
	     */
d1843 1
a1843 1
		if (art == last_required) {	/* Only one */
d1845 1
a1845 1
			    art, CR, LF);
d1847 1
a1847 1
		} else {	/* First of many */
d1849 2
a1850 2
			    art, CR, LF, art + 1, CR, LF);
		    status = response(buffer);
d1852 1
a1852 1
	    } else if (art == last_required) {	/* Last of many */
d1854 2
a1855 2
	    } else {		/* Middle of many */
		sprintf(buffer, "HEAD %d%c%c", art + 1, CR, LF);
d1858 1
a1858 1
#else /* Not OVERLAP: */
d1861 1
a1861 1
#endif /* OVERLAP */
d1863 9
a1871 8
	     * Check for a good response (221) for the HEAD request, and if so,
	     * parse it.  Otherwise, indicate the error so that the number of
	     * listings corresponds to what's claimed for the range, and if we
	     * are listing numbers via an ordered list, they stay in synchrony
	     * with the article numbers.  - FM
	     */
	    if (status == 221) {	/* Head follows - parse it: */
		p = line;	/* Write pointer */
d1873 1
a1873 1
		while (!done) {
d1875 1
a1875 2

		    *p++ = (char) ich;
d1879 2
a1880 3
			    CTRACE((tfp,
				    "HTNews: Interrupted on read, closing socket %d\n",
				    s));
d1883 1
a1883 1
			    return (HT_INTERRUPTED);
d1885 2
a1886 2
			abort_socket();		/* End of file, close socket */
			return (HT_LOADED);	/* End of file on response */
d1888 1
a1888 1
		    if (((char) ich == LF) ||
d1891 4
a1894 4
			*--p = '\0';	/* Terminate  & chop LF */
			p = line;	/* Restart at beginning */
			CTRACE((tfp, "G %s\n", line));
			switch (line[0]) {
d1898 3
a1900 3
			     * End of article?
			     */
			    done = (BOOL) (UCH(line[1]) < ' ');
d1906 5
a1910 2
				LYstrncpy(subject, line + 9, sizeof(subject) - 1);	/* Save subject */
				decode_mime(subject);
d1917 2
a1918 3
				char *addr = HTStrip(line + 11) + 1;	/* Chop < */

				addr[strlen(addr) - 1] = '\0';	/* Chop > */
d1926 7
a1932 6
				char *p2;

				LYstrncpy(author,
					  author_name(strchr(line, ':') + 1),
					  sizeof(author) - 1);
				decode_mime(author);
d1934 2
a1935 2
				if (*p2 == LF)
				    *p2 = '\0';		/* Chop off newline */
d1943 1
a1943 1
					     HTStrip(strchr(line, ':') + 1));
d1947 3
a1949 3
			}	/* end switch on first character */
		    }		/* if end of line */
		}		/* Loop over characters */
d1953 1
a1953 5
#ifdef SH_EX			/* for MIME */
		HTSprintf0(&temp, "\"%s\"", decode_mime(subject));
#else
		HTSprintf0(&temp, "\"%s\"", subject);
#endif
d1955 1
a1955 1
		    write_anchor(temp, reference);
d1958 1
a1958 1
		    PUTS(temp);
a1959 2
		FREE(temp);

d1961 7
a1967 11
		    PUTS(" - ");
		    if (LYListNewsDates)
			START(HTML_I);
#ifdef SH_EX			/* for MIME */
		    PUTS(decode_mime(author));
#else
		    PUTS(author);
#endif
		    if (LYListNewsDates)
			END(HTML_I);
		    author[0] = '\0';
d1977 1
a1977 1
		    sprintf(buffer, " [%.*s]", (int) (sizeof(buffer) - 4), date);
d1983 2
a1984 2
		 * Indicate progress!  @@@@@@@@@@@@
		 */
d1987 2
a1988 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d1991 1
a1991 1
		return (HT_INTERRUPTED);
d1994 2
a1995 2
		 * Use the response text on error.  - FM
		 */
d2000 1
a2000 1
		    LYstrncpy(buffer, "Status:", sizeof(buffer) - 1);
d2008 3
a2010 3
	    }			/* Handle response to HEAD request */
	}			/* Loop over article */
    }				/* If read headers */
d2019 2
a2020 2
     * Link to later articles.
     */
d2022 2
a2023 3
	int after;		/* End of article after */

	after = last_required + HTNewsChunkSize;
d2025 1
a2025 1
	    HTSprintf0(&dbuf, "%s%s", NewsHREF, groupName);	/* original group */
d2028 2
a2029 2
		       last_required + 1, after);
	CTRACE((tfp, "    Block after is %s\n", dbuf));
d2037 1
a2037 1
  add_post:
d2040 4
a2043 3
	 * We have permission to POST to this host, so add a link for posting
	 * messages to this newsgroup.  - FM
	 */
d2048 2
a2049 2
	if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
	    StrAllocCopy(href, "snewspost://");
d2051 1
a2051 1
	    StrAllocCopy(href, "newspost://");
d2054 1
a2054 1
	StrAllocCat(href, groupName);
d2064 1
a2064 1
    return (HT_LOADED);
d2068 7
a2074 6
 *	=============
 */
static int HTLoadNews(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *stream)
d2076 2
a2077 2
    char command[262];		/* The whole command */
    char proxycmd[260];		/* The proxy command */
d2079 2
a2080 3
    int status;			/* tcp return */
    int retries;		/* A count of how hard we have tried */
    BOOL normal_url;		/* Flag: "news:" or "nntp:" (physical) URL */
d2086 1
a2086 1
    BOOL sreply_wanted;		/* Flag: followup SSL post was asked for */
a2094 4
#ifdef USE_SSL
    char SSLprogress[256];
#endif /* USE_SSL */

d2100 1
a2100 1
    CTRACE((tfp, "HTNews: Looking for %s\n", arg));
d2105 1
a2105 1
	return -1;		/* FAIL */
d2109 1
a2109 1
    command[sizeof(command) - 1] = '\0';
d2111 1
a2111 1
    proxycmd[sizeof(proxycmd) - 1] = '\0';
d2114 1
a2114 1
	const char *p1 = arg;
d2117 23
a2139 27
	 * We will ask for the document, omitting the host name & anchor.
	 *
	 * Syntax of address is
	 * xxx@@yyy                 Article
	 * <xxx@@yyy>               Same article
	 * xxxxx                   News group (no "@@")
	 * group/n1-n2             Articles n1 to n2 in group
	 */
	normal_url = (BOOL) (!strncmp(arg, STR_NEWS_URL, LEN_NEWS_URL) ||
			     !strncmp(arg, "nntp:", 5));
	spost_wanted = (BOOL) (!normal_url && strstr(arg, "snewspost:") != NULL);
	sreply_wanted = (BOOL) (!(normal_url || spost_wanted) &&
				strstr(arg, "snewsreply:") != NULL);
	post_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted) &&
			      strstr(arg, "newspost:") != NULL);
	reply_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted ||
				 post_wanted) &&
			       strstr(arg, "newsreply:") != NULL);
	group_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
				  post_wanted || reply_wanted) &&
				strchr(arg, '@@') == NULL) &&
			       (strchr(arg, '*') == NULL));
	list_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
				 post_wanted || reply_wanted ||
				 group_wanted) &&
			       strchr(arg, '@@') == NULL) &&
			      (strchr(arg, '*') != NULL));
d2150 2
a2151 2
	     * Make sure we have a non-zero path for the newsgroup(s).  - FM
	     */
d2159 1
a2159 1
		return (HT_NO_DATA);
d2175 8
a2182 8
	    HTSprintf0(&NewsHREF, "%s://%.*s/",
		       (post_wanted ?
			"newspost" :
			(reply_wanted ?
			 "newreply" :
			 (spost_wanted ?
			  "snewspost" : "snewsreply"))),
		       (int) sizeof(command) - 15, NewsHost);
d2185 4
a2188 4
	     * If the SSL daemon is being used as a proxy, reset p1 to the
	     * start of the proxied URL rather than to the start of the
	     * newsgroup(s).  - FM
	     */
d2194 7
a2200 8
	    /* p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION); */
	    /*
	     * Don't use HTParse because news:  access doesn't follow
	     * traditional rules.  For instance, if the article reference
	     * contains a '#', the rest of it is lost -- JFG 10/7/92, from a
	     * bug report
	     */
	} else if (isNNTP_URL(arg)) {
d2231 1
a2231 1
	    SnipIn2(command, "%s//%.*s/", STR_NNTP_URL, 9, NewsHost);
d2233 2
a2234 1
	} else if (!strncasecomp(arg, STR_SNEWS_URL, 6)) {
d2263 1
a2263 1
		StrAllocCopy(NewsHost, cp);
d2266 1
a2266 1
	    sprintf(command, "%s//%.250s/", STR_SNEWS_URL, NewsHost);
d2272 2
a2273 1
	} else if (!strncasecomp(arg, "news:/", 6)) {
d2301 1
a2301 1
	    SnipIn(command, "news://%.*s/", 9, NewsHost);
d2304 1
a2304 1
	    p1 = (arg + 5);	/* Skip "news:" prefix */
d2315 1
a2315 1
	    StrAllocCopy(NewsHREF, STR_NEWS_URL);
d2319 6
a2324 5
	 * Set up any proxy for snews URLs that returns NNTP responses for Lynx
	 * to convert to HTML, instead of doing the conversion itself, and for
	 * handling posts or followups.  - TZ & FM
	 */
	if (!strncasecomp(p1, STR_SNEWS_URL, 6) ||
d2329 1
a2329 1
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, cp);
d2332 1
a2332 1
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, NewsHost);
d2334 1
a2334 1
	    command[sizeof(command) - 2] = '\0';
d2336 3
a2338 5
	    sprintf(proxycmd, "GET %.*s%c%c%c%c",
		    (int) sizeof(proxycmd) - 9, command,
		    CR, LF, CR, LF);
	    CTRACE((tfp, "HTNews: Proxy command is '%.*s'\n",
		    (int) (strlen(proxycmd) - 4), proxycmd));
d2344 2
a2345 2
		 * Reset p1 so that it points to the newsgroup(s).
		 */
d2353 3
a2355 3
		 * Reset p1 so that it points to the newsgroup (or a wildcard),
		 * or the article.
		 */
d2367 2
a2368 2
	 * Set up command for a post, listing, or article request.  - FM
	 */
d2372 1
a2372 7
	    if (strlen(p1) > 249) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    SnipIn(command, "XGTITLE %.*s", 11, p1);
d2374 2
a2375 2
	    char *slash = strchr(p1, '/');

d2380 1
a2380 7
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2382 3
a2384 3
		(void) sscanf(slash + 1, "%d-%d", &first, &last);
		if ((first > 0) && (isdigit(UCH(*(slash + 1)))) &&
		    (strchr(slash + 1, '-') == NULL || first == last)) {
d2386 7
a2392 6
		     * We got a number greater than 0, which will be loaded as
		     * first, and either no range or the range computes to
		     * zero, so make last negative, as a flag to select the
		     * group and then fetch an article by number (first)
		     * instead of by messageID.  - FM
		     */
d2396 1
a2396 7
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2398 1
a2398 1
	    SnipIn(command, "GROUP %.*s", 9, groupName);
d2400 6
a2405 14
	    int add_open = (strchr(p1, '<') == 0);
	    int add_close = (strchr(p1, '>') == 0);

	    if (strlen(p1) + add_open + add_close >= 252) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    sprintf(command, "ARTICLE %s%.*s%s",
		    add_open ? "<" : "",
		    (int) (sizeof(command) - (11 + add_open + add_close)),
		    p1,
		    add_close ? ">" : "");
d2409 1
a2409 2
	    char *p = command + strlen(command);

d2411 2
a2412 2
	     * Terminate command with CRLF, as in RFC 977.
	     */
d2418 1
a2418 1
    }				/* scope of p1 */
d2425 1
a2425 1
	return NO;		/* Ignore if no name */
d2431 1
a2431 1
	if (head_wanted && !strncmp(command, "ARTICLE ", 8)) {
d2434 1
a2434 1
	    for (cp = command + 5;; cp++)
d2438 1
a2438 1
	rawtext = (BOOL) (head_wanted || keep_mime_headers);
d2452 2
a2453 2
	    return (HT_NOT_LOADED);
	}			/* Copy routine entry points */
d2456 3
a2458 3
	/*
	 * Make a hypertext object with an anchor list.
	 */
d2466 2
a2467 2
     * Now, let's get a stream setup up from the NewsHost.
     */
d2472 2
a2473 3

	    if (!strcmp(NewsHREF, STR_NEWS_URL)) {
		SnipIn(url, "lose://%.*s/", 9, NewsHost);
d2475 1
a2475 1
		SnipIn(url, "%.*s", 1, ProxyHREF);
d2477 1
a2477 1
		SnipIn(url, "%.*s", 1, NewsHREF);
d2479 1
a2479 1
	    CTRACE((tfp, "News: doing HTDoConnect on '%s'\n", url));
d2485 1
a2485 1
		(!strncmp(arg, STR_SNEWS_URL, 6) ||
d2488 1
a2488 1
		status = HTDoConnect(url, "NNTPS", SNEWS_PORT, &s);
d2490 1
a2490 1
		status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
d2492 1
a2492 1
	    status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
d2497 3
a2499 4
		 * Interrupt cleanly.
		 */
		CTRACE((tfp,
			"HTNews: Interrupted on connect; recovering cleanly.\n"));
d2525 1
a2525 1
		CTRACE((tfp, "HTNews: Unable to connect to news host.\n"));
d2544 2
a2545 2
		CTRACE((tfp, "HTNews: Connected to news host %s.\n",
			NewsHost));
d2548 3
a2550 2
		 * If this is an snews url, then do the SSL stuff here
		 */
a2556 1
		    HTSSLInitPRNG();
d2560 5
a2564 11
			unsigned long SSLerror;

			CTRACE((tfp,
				"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
			SSL_load_error_strings();
			while ((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp, "HTNews: SSL: %s\n",
				    ERR_error_string(SSLerror, NULL)));
			}
			HTAlert("Unable to make secure connection to remote host.");
d2569 1
a2569 1
			    (*targetClass._abort) (target, NULL);
d2577 2
a2578 1
			    while (remove(postfile) == 0) ;	/* loop through all versions */
d2586 1
a2586 6
		    sprintf(SSLprogress,
			    "Secure %d-bit %s (%s) NNTP connection",
			    SSL_get_cipher_bits(Handle, NULL),
			    SSL_get_cipher_version(Handle),
			    SSL_get_cipher(Handle));
		    _HTProgress(SSLprogress);
d2589 1
a2589 1
		HTInitInput(s);	/* set up buffering */
d2592 2
a2593 3
		    CTRACE((tfp,
			    "HTNews: Proxy command returned status '%d'.\n",
			    status));
d2596 21
a2616 4
		    NEWS_NETCLOSE(s);
		    s = -1;
		    if (status == HT_INTERRUPTED) {
			_HTProgress(CONNECTION_INTERRUPTED);
a2620 26
			FREE(NewsHost);
			FREE(NewsHREF);
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			if (postfile) {
			    HTSYS_remove(postfile);
			    FREE(postfile);
			}
			return (HT_NOT_LOADED);
		    }
		    if (retries < 1)
			continue;
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    FREE(ListArg);
		    FREE(postfile);
		    if (!(post_wanted || reply_wanted ||
			  spost_wanted || sreply_wanted)) {
			ABORT_TARGET;
		    }
		    if (response_text[0]) {
			HTSprintf0(&dbuf,
				   gettext("Can't read news info.  News host %.20s responded: %.200s"),
				   NewsHost, response_text);
		    } else {
d2622 3
a2624 4
				   gettext("Can't read news info, empty response from host %s"),
				   NewsHost);
		    }
		    return HTLoadError(stream, 500, dbuf);
d2644 1
a2644 1
			return (HT_NOT_LOADED);
d2648 2
a2649 2
	}
	/* If needed opening */
d2651 1
a2651 1
	    spost_wanted || sreply_wanted) {
d2665 1
a2665 1
		return (HT_NOT_LOADED);
d2668 1
a2668 2
		postfile = LYNewsPost(ListArg,
				      (BOOLEAN) (reply_wanted || sreply_wanted));
d2679 1
a2679 1
		return (HT_NOT_LOADED);
d2683 6
a2688 6
	     * Ensure reader mode, but don't bother checking the status for
	     * anything but HT_INTERRUPTED or a 480 Authorization request,
	     * because if the reader mode command is not needed, the server
	     * probably returned a 500, which is irrelevant at this point.  -
	     * FM
	     */
a2697 1

d2714 1
a2714 7
      Send_NNTP_command:
#ifdef NEWS_DEB
	if (postfile)
	    printf("postfile = %s, command = %s", postfile, command);
	else
	    printf("command = %s", command);
#endif
d2727 7
a2733 6
	 * For some well known error responses which are expected to occur in
	 * normal use, break from the loop without retrying and without closing
	 * the connection.  It is unlikely that these are leftovers from a
	 * timed-out connection (but we do some checks to see whether the
	 * response corresponds to the last command), or that they will give
	 * anything else when automatically retried.  - kw
d2743 2
a2744 2
		   !strncmp(command, "ARTICLE <", 9) &&
		   !strcasecomp(response_text + 3, " No such article")) {
d2749 1
a2749 1
	if ((status / 100) != 2 &&
d2764 4
a2767 3
	     * Message might be a leftover "Timeout-disconnected", so try again
	     * if the retries maximum has not been reached.
	     */
d2772 2
a2773 2
	 * Post or load a group, article, etc
	 */
a2775 1

d2777 1
a2777 1
	     * Some servers return 480 for a failed XGTITLE.  - FM
d2786 2
a2787 2
	     * Handle Authorization.  - FM
	     */
d2802 2
a2803 2
	     * Handle posting of an article.  - FM
	     */
d2816 2
a2817 2
	     * List available newsgroups.  - FM
	     */
d2822 2
a2823 2
	     * List articles in a news group.  - FM
	     */
d2826 7
a2832 6
		 * We got one article number rather than a range following the
		 * slash which followed the group name, or the range was zero,
		 * so now that we have selected that group, load ARTICLE and
		 * the the number (first) as the command and go back to send it
		 * and check the response.  - FM
		 */
d2844 2
a2845 2
	     * Get an article from a news group.  - FM
	     */
d2873 3
a2875 1
    }				/* Retry loop */
d2877 2
a2878 5
#if 0
    HTAlert(gettext("Sorry, could not load requested news."));
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL, NULL, NULL, arg);
    /* No -- message earlier wil have covered it */
#endif
d2899 15
a2913 14
 *  This function clears all authorization information by
 *  invoking the free_NNTP_AuthInfo() function, which normally
 *  is invoked at exit.  It allows a browser command to do
 *  this at any time, for example, if the user is leaving
 *  the terminal for a period of time, but does not want
 *  to end the current session.  - FM
 */
void HTClearNNTPAuthInfo(void)
{
    /*
     * Need code to check cached documents and do something to ensure that any
     * protected documents no longer can be accessed without a new retrieval. 
     * - FM
     */
d2916 2
a2917 2
     * Now free all of the authorization info.  - FM
     */
d2922 1
a2922 1
static char HTNewsGetCharacter(void)
d2925 1
a2925 1
	return HTGetCharacter();
d2927 1
a2927 1
	return HTGetSSLCharacter((void *) Handle);
d2930 4
a2933 5
int HTNewsProxyConnect(int sock,
		       const char *url,
		       HTParentAnchor *anAnchor,
		       HTFormat format_out,
		       HTStream *sink)
d2936 1
a2936 2
    const char *arg = url;
    char SSLprogress[256];
a2940 1
    HTSSLInitPRNG();
d2944 4
a2947 10
	unsigned long SSLerror;

	channel_s = -1;
	CTRACE((tfp,
		"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		url, status));
	SSL_load_error_strings();
	while ((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp, "HTNews: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
	}
d2953 1
a2953 5
    sprintf(SSLprogress, "Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle, NULL),
	    SSL_get_cipher_version(Handle),
	    SSL_get_cipher(Handle));
    _HTProgress(SSLprogress);
d2962 1
a2962 1
GLOBALDEF(HTProtocol, HTNews, _HTNEWS_C_1_INIT);
d2964 1
a2964 1
GLOBALDEF(HTProtocol, HTNNTP, _HTNEWS_C_2_INIT);
d2966 1
a2966 1
GLOBALDEF(HTProtocol, HTNewsPost, _HTNEWS_C_3_INIT);
d2968 1
a2968 1
GLOBALDEF(HTProtocol, HTNewsReply, _HTNEWS_C_4_INIT);
d2970 1
a2970 1
GLOBALDEF(HTProtocol, HTSNews, _HTNEWS_C_5_INIT);
d2972 1
a2972 1
GLOBALDEF(HTProtocol, HTSNewsPost, _HTNEWS_C_6_INIT);
d2974 1
a2974 1
GLOBALDEF(HTProtocol, HTSNewsReply, _HTNEWS_C_7_INIT);
d2976 7
a2982 14
GLOBALDEF HTProtocol HTNews =
{"news", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNNTP =
{"nntp", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsPost =
{"newspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsReply =
{"newsreply", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNews =
{"snews", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsPost =
{"snewspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsReply =
{"snewsreply", HTLoadNews, NULL};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a18 2
#include <HTFont.h>
#include <HTFormat.h>
d21 3
a23 1
#include <LYStrings.h>
d39 3
d43 1
d50 1
a59 1
#include <HTAccess.h>
a67 2
#define SnipIn(d,fmt,len,s)      sprintf(d, fmt,      (int)sizeof(d)-len, s)
#define SnipIn2(d,fmt,tag,len,s) sprintf(d, fmt, tag, (int)sizeof(d)-len, s)
d78 1
a78 1
#define LINE_LENGTH 512			/* Maximum length of line of ARTICLE etc */
d80 7
d92 2
a93 2
PRIVATE char * NewsHost = NULL;			/* Current host */
PRIVATE char * NewsHREF = NULL;			/* Current HREF prefix */
d212 4
a215 4
    if (LYGetEnv("NNTPSERVER")) {
	StrAllocCopy(HTNewsHost, LYGetEnv("NNTPSERVER"));
	CTRACE((tfp, "HTNews: NNTPSERVER defined as `%s'\n",
		    HTNewsHost));
d218 1
a218 1
	FILE* fp = fopen(SERVER_FILE, TXT_R);
d222 2
a223 2
		CTRACE((tfp, "HTNews: File %s defines news host as `%s'\n",
			    SERVER_FILE, HTNewsHost));
d249 1
a249 1
PRIVATE int response ARGS1(char *,command)
d258 1
a258 1
	CTRACE((tfp, "NNTP command to be sent: %s", command));
d273 1
a273 1
	    CTRACE((tfp, "HTNews: Unable to send command. Disconnecting.\n"));
d282 1
a282 1
	if (((*p++ = (char) ich) == LF) ||
d285 1
a285 1
	    CTRACE((tfp, "NNTP Response: %s\n", response_text));
d293 2
a294 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d296 2
a297 2
		CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n",
			    s));
d335 1
a335 1
	char *,		host)
d373 1
a373 1
    buffer[sizeof(buffer)-1] = '\0';
d378 4
a381 1
	    HTSprintf0(&msg, gettext("Username for news host '%s':"), host);
d389 1
a389 2
	sprintf(buffer, "AUTHINFO USER %.*s%c%c",
		(int) sizeof(buffer)-17, UserName, CR, LF);
d418 2
a419 1
		if ((auth = typecalloc(NNTPAuth)) != NULL) {
d462 4
a465 1
		HTSprintf0(&msg, gettext("Password for news host '%s':"), host);
d473 1
a473 2
	    sprintf(buffer, "AUTHINFO PASS %.*s%c%c",
		    (int) sizeof(buffer)-17, PassWord, CR, LF);
d528 2
a529 1
		    if ((auth = typecalloc(NNTPAuth)) != NULL) {
d582 1
a582 1
    CTRACE((tfp,"Trying to find name in: %s\n",name));
d584 1
a584 1
    if ((p = strrchr(name, '(')) && (e = strrchr(name, ')'))) {
d591 3
a593 4
    if ((p = strrchr(name, '<')) && (e = strrchr(name, '>'))) {
	if (e++ > p) {
	    while ((*p++ = *e++) != 0)	/* Remove <...> */
		;
d618 1
a618 1
    CTRACE((tfp,"Trying to find address in: %s\n",address));
d620 2
a621 2
    if ((p = strrchr(address, '<'))) {
	if ((e = strrchr(p, '>')) && (at = strrchr(p, '@@'))) {
d629 2
a630 2
    if ((p = strrchr(address, '(')) &&
	(e = strrchr(address, ')')) && (at = strchr(address, '@@'))) {
d637 1
a637 1
    if ((at = strrchr(address, '@@')) && at > address) {
d640 1
a640 1
	while (p > address && !isspace(UCH(*p)))
d642 1
a642 1
	while (*e && !isspace(UCH(*e)))
d652 1
a652 1
    while (isspace(UCH(*p)))
d655 1
a655 1
    while (!isspace(UCH(*e)) && *e != '\0')
d668 1
a668 2
    CONST char*		value[HTML_A_ATTRIBUTES];
    int i;
d670 8
a677 4
    for(i=0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
    value[HTML_A_HREF] = href;
    (*targetClass.start_element)(target, HTML_A, present, value, -1, 0);
d686 1
a686 2
    CONST char*		value[HTML_LINK_ATTRIBUTES];
    int i;
d688 9
a696 5
    for(i=0; i < HTML_LINK_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_LINK_HREF || i == HTML_LINK_REV);
    value[HTML_LINK_HREF] = href;
    value[HTML_LINK_REV]  = rev;
    (*targetClass.start_element)(target, HTML_LINK, present, value, -1, 0);
d705 1
a705 1
    CONST char*		value[HTML_OL_ATTRIBUTES];
d710 1
a710 1
	present[i] = (BOOL) (i == HTML_OL_SEQNUM || i == HTML_OL_START);
d712 4
a715 3
    value[HTML_OL_SEQNUM] = SeqNum;
    value[HTML_OL_START]  = SeqNum;
    (*targetClass.start_element)(target, HTML_OL, present, value, -1, 0);
a730 2
    CONST char * p;
    char *q;
d732 6
a737 9
    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p!=','); p++)
	;
    if (strlen(NewsHREF) + (p - addr) + 1 < sizeof(href)) {
	q = href;
	strcpy(q, NewsHREF);
	strncat(q, addr, p-addr);	/* Make complete hypertext reference */
    } else {
	q = NULL;
	HTSprintf0(&q, "%s%.*s", NewsHREF, p-addr, addr);
d740 1
a740 1
    start_anchor(q);
a742 3

    if (q != href)
	FREE(q);
d789 1
a789 1
    CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n", s));
d791 2
a792 6
    if (rawtext) {
	RAW_PUTS("Network Error: connection lost\n");
    } else {
	PUTS("Network Error: connection lost");
	PUTC('\n');
    }
d797 1
a797 1
**  Determine if a line is a valid header line.			valid_header
d801 1
a801 1
	char *,		line)
d818 1
a818 1
    if (isalpha(UCH(line[0])) && colon && space == colon + 1)
d838 1
a838 1
	char *,		postfile)
d854 1
a854 1
    if ((fd = fopen(NonNull(postfile), TXT_R)) == NULL) {
d865 1
a865 1
    while (fgets(line, sizeof(line)-2, fd) != NULL) {
d893 5
a897 1
		    if (blen >= (int) sizeof(buf) - 35) {
d899 3
a901 1
			buf[blen = 0] = 0;
a902 3
		    strcat(buf, "From: anonymous@@nowhere.you.know");
		    strcat(buf, crlf);
		    blen += 34;
d916 4
a919 1
	if ((blen + llen) >= (int) sizeof(buf)-1) {
d921 2
a922 1
	    buf[blen = 0] = 0;
a923 2
	strcat(buf, line);
	blen += llen;
d931 9
a939 1
    if (blen >= (int) sizeof(buf)-4) {
a940 1
	buf[blen = 0] = 0;
a941 5
    strcat(buf, ".");
    strcat(buf, crlf);
    blen += 3;
    NEWS_NETWRITE(s, buf, blen);

a955 62
#ifdef SH_EX	/* for MIME */
#ifdef NEWS_DEBUG
/* for DEBUG 1997/11/07 (Fri) 17:20:16 */
void debug_print(unsigned char *p)
{
    while (*p) {
	if (*p == '\0')
	    break;
	if (*p == 0x1b)
	   printf("[ESC]");
	else if (*p == '\n')
	   printf("[NL]");
	else if (*p < ' ' || *p >= 0x80)
	   printf("(%02x)", *p);
	else
	   putchar(*p);
       p++;
    }
    printf("]\n");
}
#endif

static char *decode_mime(char *str)
{
    char temp[LINE_LENGTH];	/* FIXME: what determines the actual size? */
    char *p, *q;

    if (str == NULL)
	return "";

    if (HTCJK != JAPANESE)
	return str;

    LYstrncpy(temp, str, sizeof(temp) - 1);
    q = temp;
    while ((p = strchr(q, '=')) != 0) {
	if (p[1] == '?') {
	    HTmmdecode(p, p);
	    q = p + 2;
	} else {
	    q = p + 1;
	}
    }
#ifdef NEWS_DEBUG
    printf("new=[");
    debug_print(temp);
#endif
    HTrjis(temp, temp);
    strcpy(str, temp);

    return str;
}
#else /* !SH_EX */
static char *decode_mime ARGS1(char *, str)
{
    HTmmdecode(str, str);
    HTrjis(str, str);
    return str;
}
#endif


d995 1
a995 1
	    *p++ = (char) ich;
d999 2
a1000 2
		    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				s));
d1005 1
a1005 1
		abort_socket();		/* End of file, close socket */
d1010 1
a1010 1
		CTRACE((tfp, "H %s\n", line));
d1032 1
a1032 1
		    if (UCH(full_line[1]) < ' ') {
d1036 1
a1036 1
		} else if (UCH(full_line[0]) < ' ') {
d1041 8
a1048 1
		    decode_mime(subject);
d1055 4
a1058 1
		    decode_mime(organization);
d1062 4
a1065 1
		    decode_mime(from);
d1069 4
a1072 1
		    decode_mime(replyto);
d1087 1
a1087 1
			msgid++;			/* Chop < */
d1110 1
a1110 1
	    char *temp = NULL;
d1112 1
a1112 1
	    StrAllocCopy(href, STR_MAILTO_URL);
d1258 1
a1258 1
	    if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
d1319 1
a1319 1
	 *  No tags, and never do a PUTC. - kw
a1327 1
	PUTC('\n');
a1333 1
	PUTC('\n');
d1335 1
d1340 1
a1340 1
	*p++ = (char) ich;
d1344 2
a1345 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1355 1
a1355 4
	    CTRACE((tfp, "B %s", line));
#ifdef NEWS_DEBUG	/* 1997/11/09 (Sun) 15:56:11 */
	    debug_print(line);	/* @@@@@@ */
#endif
d1360 1
a1360 1
		if (UCH(line[1]) < ' ') {
d1364 1
a1364 1
		    if (rawtext) {
d1366 1
a1366 1
		    } else {
a1367 1
		    }
d1394 2
a1395 2
			char *q  = strrchr(p2,'>');
			char *at = strrchr(p2, '@@');
d1402 1
a1402 1
				if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1415 1
a1415 1
				    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1417 1
a1417 1
				    strncmp(l, "gopher://", 9)) {
d1419 1
a1419 1
				} else {
d1435 1
a1435 1
			    l = q + 1;
d1441 1
a1441 1
			if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d1454 1
a1454 1
			    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1545 1
a1545 1
	char ch = (char) ich;
d1549 2
a1550 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1569 1
a1569 1
	    CTRACE((tfp, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch));
d1579 1
a1579 1
		CTRACE((tfp, "HTNews..... group name too long, discarding.\n"));
d1591 1
a1591 1
	    CTRACE((tfp, "B %s", line));
d1596 1
a1596 1
		if (UCH(line[1]) < ' ') {
a1649 1
	char *msg = NULL;
d1651 2
a1652 2
	HTSprintf0(&msg, gettext("No matches for: %s"), arg);
	PUTS(msg);
a1653 1
	FREE(msg);
d1669 3
a1671 3
	CONST char *,	groupName,
	int,		first_required,
	int,		last_required)
d1681 1
a1681 2
    char buffer[LINE_LENGTH+1];
    char *temp = NULL;
d1699 2
a1700 2
    CTRACE((tfp, "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
		status, count, first, last, first_required, last_required));
d1710 1
a1710 1
	first_required = first;		/* clip */
d1722 2
a1723 2
    CTRACE((tfp, "    Chunk will be (%d-%d)\n",
		first_required, last_required));
d1728 1
a1728 1
    HTSprintf0(&temp, gettext("%s,  Articles %d-%d"),
d1731 1
a1731 2
    PUTS(temp);
    FREE(temp);
d1746 1
a1746 1
	CTRACE((tfp, "    Block before is %s\n", dbuf));
d1761 1
a1761 1
	HTSprintf0(&temp,
d1764 1
a1764 2
	PUTS(temp);
	FREE(temp);
d1775 2
a1776 2
			CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				    s));
d1786 1
a1786 1
		    CTRACE((tfp, "X %s", line));
d1791 1
a1791 1
			if (UCH(line[1]) < ' ') {
d1875 1
a1875 1
		    *p++ = (char) ich;
d1879 2
a1880 2
			    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
					s));
d1885 1
a1885 1
			abort_socket();		/* End of file, close socket */
d1893 1
a1893 1
			CTRACE((tfp, "G %s\n", line));
d1900 1
a1900 1
			    done = (BOOL) (UCH(line[1]) < ' ');
d1906 5
a1910 2
				LYstrncpy(subject, line+9, sizeof(subject)-1);/* Save subject */
				decode_mime(subject);
d1927 6
a1932 4
				LYstrncpy(author,
					author_name(strchr(line,':')+1),
					sizeof(author)-1);
				decode_mime(author);
d1953 1
a1953 5
#ifdef SH_EX	/* for MIME */
		HTSprintf0(&temp, "\"%s\"", decode_mime(subject));
#else
		HTSprintf0(&temp, "\"%s\"", subject);
#endif
d1955 1
a1955 1
		    write_anchor(temp, reference);
d1958 1
a1958 1
		    PUTS(temp);
a1959 2
		FREE(temp);

a1963 3
#ifdef SH_EX	/* for MIME */
		     PUTS(decode_mime(author));
#else
a1964 1
#endif
d1977 1
a1977 1
		    sprintf(buffer, " [%.*s]", (int)(sizeof(buffer) - 4), date);
d1987 2
a1988 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d2000 1
a2000 1
		    LYstrncpy(buffer, "Status:", sizeof(buffer) - 1);
d2029 1
a2029 1
	CTRACE((tfp, "    Block after is %s\n", dbuf));
d2048 1
a2048 1
	if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
d2076 2
a2077 2
    char command[262];			/* The whole command */
    char proxycmd[260];			/* The proxy command */
d2079 1
a2079 1
    int status;				/* tcp return */
a2080 1
    BOOL normal_url;		/* Flag: "news:" or "nntp:" (physical) URL */
d2086 1
a2086 1
    BOOL sreply_wanted;		/* Flag: followup SSL post was asked for */
a2093 3
#ifdef USE_SSL
    char SSLprogress[256];
#endif /* USE_SSL */
d2100 1
a2100 1
    CTRACE((tfp, "HTNews: Looking for %s\n", arg));
d2109 1
a2109 1
    command[sizeof(command)-1] = '\0';
d2111 1
a2111 1
    proxycmd[sizeof(proxycmd)-1] = '\0';
d2120 1
a2120 1
	**	xxx@@yyy			Article
d2125 2
a2126 3
	normal_url = (BOOL) (!strncmp(arg, STR_NEWS_URL, LEN_NEWS_URL) || !strncmp(arg, "nntp:", 5));
	spost_wanted = (BOOL) (!normal_url && strstr(arg, "snewspost:") != NULL);
	sreply_wanted = (BOOL) (!(normal_url || spost_wanted) &&
d2128 1
a2128 1
	post_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted) &&
d2130 1
a2130 1
	reply_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted ||
d2133 1
a2133 1
	group_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
d2135 2
a2136 2
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') == NULL));
	list_wanted  = (BOOL) ((!(spost_wanted || sreply_wanted ||
d2139 1
a2139 1
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') != NULL));
d2175 1
a2175 1
	    HTSprintf0(&NewsHREF, "%s://%.*s/",
d2181 2
a2182 2
			      "snewspost" : "snewsreply"))),
			    (int) sizeof(command) - 15, NewsHost);
d2200 1
a2200 1
	} else if (isNNTP_URL(arg)) {
d2231 1
a2231 1
	    SnipIn2(command, "%s//%.*s/", STR_NNTP_URL, 9, NewsHost);
d2234 1
a2234 1
	else if (!strncasecomp(arg, STR_SNEWS_URL, 6)) {
d2263 1
a2263 1
		StrAllocCopy(NewsHost, cp);
d2266 1
a2266 1
	    sprintf(command, "%s//%.250s/", STR_SNEWS_URL, NewsHost);
d2301 1
a2301 1
	    SnipIn(command, "news://%.*s/", 9, NewsHost);
d2315 1
a2315 1
	    StrAllocCopy(NewsHREF, STR_NEWS_URL);
d2324 1
a2324 1
	if (!strncasecomp(p1, STR_SNEWS_URL, 6) ||
d2329 1
a2329 1
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, cp);
d2332 1
a2332 1
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, NewsHost);
d2334 1
a2334 1
	    command[sizeof(command)-2] = '\0';
d2336 3
a2338 5
	    sprintf(proxycmd, "GET %.*s%c%c%c%c",
		    (int) sizeof(proxycmd)-9, command,
		    CR, LF, CR, LF);
	    CTRACE((tfp, "HTNews: Proxy command is '%.*s'\n",
			(int)(strlen(proxycmd) - 4), proxycmd));
d2353 1
a2353 1
		**  Reset p1 so that it points to the newsgroup
d2372 1
a2372 7
	    if (strlen(p1) > 249) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    SnipIn(command, "XGTITLE %.*s", 11, p1);
d2375 1
d2380 1
a2380 7
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2383 1
a2383 1
		if ((first > 0) && (isdigit(UCH(*(slash+1)))) &&
d2396 1
a2396 7
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2398 1
a2398 1
	    SnipIn(command, "GROUP %.*s", 9, groupName);
d2400 6
a2405 13
	    int add_open=(strchr(p1, '<') == 0);
	    int add_close=(strchr(p1, '>') == 0);
	    if (strlen(p1) + add_open + add_close >= 252) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    sprintf(command, "ARTICLE %s%.*s%s",
		    add_open ? "<" : "",
		    (int) (sizeof(command) - (11 + add_open + add_close)),
		    p1,
		    add_close ? ">" : "");
d2431 1
a2431 1
	if (head_wanted && !strncmp(command, "ARTICLE ", 8)) {
d2438 1
a2438 1
	rawtext = (BOOL) (head_wanted || keep_mime_headers);
d2472 2
a2473 2
	    if (!strcmp(NewsHREF, STR_NEWS_URL)) {
		SnipIn (url, "lose://%.*s/", 9, NewsHost);
d2475 1
a2475 1
		SnipIn (url, "%.*s", 1, ProxyHREF);
d2477 1
a2477 1
		SnipIn (url, "%.*s", 1, NewsHREF);
d2479 1
a2479 1
	    CTRACE((tfp, "News: doing HTDoConnect on '%s'\n", url));
d2485 1
a2485 1
		(!strncmp(arg, STR_SNEWS_URL, 6) ||
d2499 1
a2499 1
		CTRACE((tfp, "HTNews: Interrupted on connect; recovering cleanly.\n"));
d2525 1
a2525 1
		CTRACE((tfp, "HTNews: Unable to connect to news host.\n"));
d2544 2
a2545 2
		CTRACE((tfp, "HTNews: Connected to news host %s.\n",
			    NewsHost));
a2556 1
		    HTSSLInitPRNG();
d2560 3
a2562 6
			unsigned long SSLerror;
			CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
			SSL_load_error_strings();
			while((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
			}
d2586 1
a2586 2
		    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",SSL_get_cipher_bits(Handle,NULL),SSL_get_cipher_version(Handle),SSL_get_cipher(Handle));
		    _HTProgress(SSLprogress);
d2589 1
a2589 1
		HTInitInput(s);		/* set up buffering */
d2592 2
a2593 2
		    CTRACE((tfp, "HTNews: Proxy command returned status '%d'.\n",
				status));
a2616 4
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			FREE(postfile);
d2621 1
a2621 2
			if (response_text[0]) {
			    HTSprintf0(&dbuf,
a2623 5
			} else {
			    HTSprintf0(&dbuf,
				gettext("Can't read news info, empty response from host %s"),
				NewsHost);
			}
d2668 1
a2668 2
		postfile = LYNewsPost(ListArg,
				(BOOLEAN)(reply_wanted || sreply_wanted));
a2714 6
#ifdef NEWS_DEB
	if (postfile)
	    printf("postfile = %s, command = %s", postfile, command);
	else
	    printf("command = %s", command);
#endif
d2731 1
a2731 1
	 *  some checks to see whether the response corresponds to the
d2875 4
a2878 5
#if 0
    HTAlert(gettext("Sorry, could not load requested news."));
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL,NULL,NULL, arg);
    /* No -- message earlier wil have covered it */
#endif
d2900 1
a2900 1
**  invoking the free_NNTP_AuthInfo() function, which normally
d2925 1
a2925 1
	return HTGetCharacter();
d2927 1
a2927 1
	return HTGetSSLCharacter((void *)Handle);
d2930 4
a2933 6
PUBLIC int HTNewsProxyConnect ARGS5 (
    int,		sock,
    CONST char *,	url,
    HTParentAnchor *,	anAnchor,
    HTFormat,		format_out,
    HTStream *,		sink)
a2936 1
    char SSLprogress[256];
a2940 1
    HTSSLInitPRNG();
d2944 4
a2947 7
	unsigned long SSLerror;
	channel_s = -1;
	CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
	SSL_load_error_strings();
	while((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	}
d2953 1
a2953 5
    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle,NULL),
	    SSL_get_cipher_version(Handle),
	    SSL_get_cipher(Handle));
    _HTProgress(SSLprogress);
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d208 1
d211 1
a211 5
	    char server_name[MAXHOSTNAMELEN+1];
	    if (fgets(server_name, sizeof server_name, fp) != NULL) {
		char *p = strchr(server_name, '\n');
		if (p != NULL)
		    *p = '\0';
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d28 2
a29 2
int HTNewsChunkSize = 30;/* Number of articles for quick display */
int HTNewsMaxChunk = 40; /* Largest number of articles in one window */
d40 2
a41 2
static SSL * Handle = NULL;
static int channel_s = 1;
d46 1
a46 1
static char HTNewsGetCharacter (void);
d68 1
a68 1
	const HTStructuredClass *	isa;
d82 18
a99 18
char * HTNewsHost = NULL;		/* Default host */
static char * NewsHost = NULL;			/* Current host */
static char * NewsHREF = NULL;			/* Current HREF prefix */
static int s;					/* Socket for NewsHost */
static int HTCanPost = FALSE;			/* Current POST permission */
static char response_text[LINE_LENGTH+1];	/* Last response */
/* static HText *	HT;	*/		/* the new hypertext */
static HTStructured * target;			/* The output sink */
static HTStructuredClass targetClass;		/* Copy of fn addresses */
static HTStream * rawtarget = NULL;		/* The output sink for rawtext */
static HTStreamClass rawtargetClass;		/* Copy of fn addresses */
static HTParentAnchor *node_anchor;		/* Its anchor */
static int	diagnostic;			/* level: 0=none 2=source */
static BOOL rawtext = NO;			/* Flag: HEAD or -mime_headers */
static HTList *NNTP_AuthInfo = NULL;		/* AUTHINFO database */
static char *name = NULL;
static char *address = NULL;
static char *dbuf = NULL;	/* dynamic buffer for long messages etc. */
d120 1
a120 1
static void free_news_globals (void)
d135 1
a135 1
static void free_NNTP_AuthInfo (void)
d154 1
a154 1
const char * HTGetNewsHost (void)
d159 1
a159 1
void HTSetNewsHost (const char *  value)
d182 2
a183 2
static BOOL initialized = NO;
static BOOL initialize (void)
d243 1
a243 1
static int response (char * command)
d255 1
a255 1
	    const char	* p;
d311 1
a311 1
static BOOL match (const char * unknown, const char * template)
d313 2
a314 2
    const char * u = unknown;
    const char * t = template;
d328 2
a329 2
static NNTPAuthResult HTHandleAuthInfo (
	char *		host)
d565 1
a565 1
static char * author_name (char * email)
d602 1
a602 1
static char * author_address (char * email)
d654 1
a654 1
static void start_anchor (const char *   href)
d657 1
a657 1
    const char*		value[HTML_A_ATTRIBUTES];
d669 1
a669 1
static void start_link (const char *   href, const char *  rev)
d672 1
a672 1
    const char*		value[HTML_LINK_ATTRIBUTES];
d685 1
a685 1
static void start_list (int  seqnum)
d688 1
a688 1
    const char*		value[HTML_OL_ATTRIBUTES];
d710 1
a710 1
static void write_anchor (const char * text, const char * addr)
d713 1
a713 1
    const char * p;
d747 1
a747 1
static void write_anchors (char * text)
d777 1
a777 1
static void abort_socket (void)
d794 2
a795 2
static BOOLEAN valid_header (
	char *		line)
d831 2
a832 2
static void post_article (
	char *		postfile)
d996 1
a996 1
static char *decode_mime (char *  str)
d1016 2
a1017 2
static int read_article (
	HTParentAnchor *	thisanchor)
d1032 1
a1032 1
    const char *ccp;
d1529 1
a1529 1
static int read_list (char *  arg)
d1708 4
a1711 4
static int read_group (
	const char *	groupName,
	int		first_required,
	int		last_required)
d2118 5
a2122 5
static int HTLoadNews (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		stream)
d2166 1
a2166 1
	const char * p1 = arg;
d3008 1
a3008 1
void HTClearNNTPAuthInfo (void)
d3024 1
a3024 1
static char HTNewsGetCharacter (void)
d3032 6
a3037 6
int HTNewsProxyConnect (
    int		sock,
    const char *	url,
    HTParentAnchor *	anAnchor,
    HTFormat		format_out,
    HTStream *		sink)
d3040 1
a3040 1
    const char * arg = url;
d3089 7
a3095 7
GLOBALDEF HTProtocol HTNews = { "news", HTLoadNews, NULL };
GLOBALDEF HTProtocol HTNNTP = { "nntp", HTLoadNews, NULL };
GLOBALDEF HTProtocol HTNewsPost = { "newspost", HTLoadNews, NULL };
GLOBALDEF HTProtocol HTNewsReply = { "newsreply", HTLoadNews, NULL };
GLOBALDEF HTProtocol HTSNews = { "snews", HTLoadNews, NULL };
GLOBALDEF HTProtocol HTSNewsPost = { "snewspost", HTLoadNews, NULL };
GLOBALDEF HTProtocol HTSNewsReply = { "snewsreply", HTLoadNews, NULL };
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 6
a7 6
 *			===========
 *
 * History:
 *	26 Sep 90	Written TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 */
d28 2
a29 2
int HTNewsChunkSize = 30;	/* Number of articles for quick display */
int HTNewsMaxChunk = 40;	/* Largest number of articles in one window */
d34 3
a36 8

#ifndef NEWS_SERVER_FILE
#define NEWS_SERVER_FILE "/usr/local/lib/rn/server"
#endif /* NEWS_SERVER_FILE */

#ifndef NEWS_AUTH_FILE
#define NEWS_AUTH_FILE ".newsauth"
#endif /* NEWS_AUTH_FILE */
d39 2
a40 2
extern SSL_CTX *ssl_ctx;
static SSL *Handle = NULL;
a41 1

d45 2
a46 3
	{ (void)NETCLOSE(sock); if (Handle) { SSL_free(Handle); Handle = NULL; } }
static char HTNewsGetCharacter(void);

d68 2
a69 2
    const HTStructuredClass *isa;
    /* ... */
d71 3
a73 2
struct _HTStream {
    HTStreamClass *isa;
d76 1
a76 1
#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
d80 17
a96 18
 *  Module-wide variables.
 */
char *HTNewsHost = NULL;	/* Default host */
static char *NewsHost = NULL;	/* Current host */
static char *NewsHREF = NULL;	/* Current HREF prefix */
static int s;			/* Socket for NewsHost */
static int HTCanPost = FALSE;	/* Current POST permission */
static char response_text[LINE_LENGTH + 1];	/* Last response */

/* static HText *	HT;	*//* the new hypertext */
static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */
static HTStream *rawtarget = NULL;	/* The output sink for rawtext */
static HTStreamClass rawtargetClass;	/* Copy of fn addresses */
static HTParentAnchor *node_anchor;	/* Its anchor */
static int diagnostic;		/* level: 0=none 2=source */
static BOOL rawtext = NO;	/* Flag: HEAD or -mime_headers */
static HTList *NNTP_AuthInfo = NULL;	/* AUTHINFO database */
d114 3
a116 3
    char *host;
    char *user;
    char *pass;
d120 1
a120 1
static void free_news_globals(void)
d135 1
a135 1
static void free_NNTP_AuthInfo(void)
d143 1
a143 1
    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
d154 1
a154 39
/*
 * Initialize the authentication list by loading the user's $HOME/.newsauth
 * file.  That file is part of tin's configuration and is used by a few other
 * programs.
 */
static void load_NNTP_AuthInfo(void)
{
    FILE *fp;
    char fname[LY_MAXPATH];
    char buffer[LINE_LENGTH + 1];

    LYAddPathToHome(fname, sizeof(fname), NEWS_AUTH_FILE);

    if ((fp = fopen(fname, "r")) != 0) {
	while (fgets(buffer, sizeof(buffer), fp) != 0) {
	    char the_host[LINE_LENGTH + 1];
	    char the_pass[LINE_LENGTH + 1];
	    char the_user[LINE_LENGTH + 1];

	    if (sscanf(buffer, "%s%s%s", the_host, the_pass, the_user) == 3
		&& strlen(the_host) != 0
		&& strlen(the_pass) != 0
		&& strlen(the_user) != 0) {
		NNTPAuth *auth = typecalloc(NNTPAuth);

		if (auth == NULL)
		    break;
		StrAllocCopy(auth->host, the_host);
		StrAllocCopy(auth->pass, the_pass);
		StrAllocCopy(auth->user, the_user);

		HTList_appendObject(NNTP_AuthInfo, auth);
	    }
	}
	fclose(fp);
    }
}

const char *HTGetNewsHost(void)
d156 1
a156 1
    return HTNewsHost;
d159 1
a159 1
void HTSetNewsHost(const char *value)
d161 1
a161 1
    StrAllocCopy(HTNewsHost, value);
d165 17
a181 17
 *	------------------------------
 *
 *	Except on the NeXT, we pick up the NewsHost name from
 *
 *	1.	Environment variable NNTPSERVER
 *	2.	File NEWS_SERVER_FILE
 *	3.	Compilation time macro DEFAULT_NEWS_HOST
 *	4.	Default to "news"
 *
 *	On the NeXT, we pick up the NewsHost name from, in order:
 *
 *	1.	WorldWideWeb default "NewsHost"
 *	2.	Global default "NewsHost"
 *	3.	News default "NewsHost"
 *	4.	Compilation time macro DEFAULT_NEWS_HOST
 *	5.	Default to "news"
 */
d183 1
a183 1
static BOOL initialize(void)
d190 2
a191 2
     * Get name of Host.
     */
d193 2
a194 2
    if ((cp = NXGetDefaultValue("WorldWideWeb", "NewsHost")) == 0) {
	if ((cp = NXGetDefaultValue("News", "NewsHost")) == 0) {
d206 1
a206 1
		HTNewsHost));
d208 1
a208 2
	FILE *fp = fopen(NEWS_SERVER_FILE, TXT_R);

d210 1
a210 2
	    char server_name[MAXHOSTNAMELEN + 1];

a212 1

d217 1
a217 1
			NEWS_SERVER_FILE, HTNewsHost));
d226 1
a226 1
    s = -1;			/* Disconnected */
d234 10
a243 10
 *	------------------------------------------------------
 *
 * On entry,
 *	command points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is an NNTP status.
 */
static int response(char *command)
d246 1
a246 1
    char *p = response_text;
a251 1

d255 5
a259 6
	    const char *p2;
	    char *q;
	    char ascii[LINE_LENGTH + 1];

	    for (p2 = command, q = ascii; *p2; p2++, q++) {
		*q = TOASCII(*p2);
d264 1
a264 1
	status = NEWS_NETWRITE(s, (char *) command, length);
d266 1
a266 1
	if (status < 0) {
d271 3
a273 3
	}			/* if bad status */
    }
    /* if command to be sent */
d278 1
a278 1
	    *--p = '\0';	/* Terminate the string */
d282 2
a283 2
	}
	/* if end of line */
d285 1
a285 1
	    *(p - 1) = '\0';
d287 2
a288 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d291 1
a291 1
			s));
d297 1
a297 1
		return (HT_INTERRUPTED);
d299 1
a299 1
	    return ((int) EOF);	/* End of file on response */
d301 1
a301 1
    }				/* Loop over characters */
d305 7
a311 7
 *	-----------------------------------
 *
 * On entry,
 *	template must be already in upper case.
 *	unknown may be in upper or lower or mixed case to match.
 */
static BOOL match(const char *unknown, const char *template)
d313 5
a317 5
    const char *u = unknown;
    const char *t = template;

    for (; *u && *t && (TOUPPER(*u) == *t); u++, t++) ;		/* Find mismatch or end */
    return (BOOL) (*t == 0);	/* OK if end of template */
d321 3
a323 3
    NNTPAUTH_ERROR = 0,		/* general failure */
    NNTPAUTH_OK = 281,		/* authenticated successfully */
    NNTPAUTH_CLOSE = 502	/* server probably closed connection */
a324 1

d326 4
a329 3
 *  This function handles nntp authentication. - FM
 */
static NNTPAuthResult HTHandleAuthInfo(char *host)
d340 2
a341 2
     * Make sure we have an interactive user and a host.  - FM
     */
d346 12
a357 3
     * Check for an existing authorization entry.  - FM
     */
    if (NNTP_AuthInfo == NULL) {
a358 1
	load_NNTP_AuthInfo();
a363 9
    cur = NNTP_AuthInfo;
    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
	if (!strcmp(auth->host, host)) {
	    UserName = auth->user;
	    PassWord = auth->pass;
	    break;
	}
    }

d365 3
a367 3
     * Handle the username.  - FM
     */
    buffer[sizeof(buffer) - 1] = '\0';
d381 1
a381 1
		(int) sizeof(buffer) - 17, UserName, CR, LF);
d399 2
a400 2
	     * Username is accepted and no password is required.  - FM
	     */
d408 2
a409 2
		 * Store the accepted username and no password.  - FM
		 */
d420 3
a422 3
	     * Not success, nor a request for the password, so it must be an
	     * error.  - FM
	     */
d429 1
a429 2
		if ((UserName = HTPrompt(gettext("Username:"), UserName))
		    != NULL &&
d448 2
a449 2
	 * Handle the password.  - FM
	 */
d462 1
a462 1
		    (int) sizeof(buffer) - 17, PassWord, CR, LF);
d486 2
a487 2
		 * That's what INN's nnrpd returns.  It closes the connection
		 * after this.  - kw
d503 4
a506 4
		/*
		 * Password also is accepted, and everything has been stored. 
		 * - FM
		 */
d527 2
a528 2
	     * Not success, so it must be an error.  - FM
	     */
d554 12
a565 12
 *	----------------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "Tim Berners-Lee" if given any of
 *	" Tim Berners-Lee <tim@@online.cern.ch> "
 *  or	" tim@@online.cern.ch ( Tim Berners-Lee ) "
 */
static char *author_name(char *email)
d570 1
a570 1
    CTRACE((tfp, "Trying to find name in: %s\n", name));
d574 2
a575 2
	    *e = '\0';		/* Chop off everything after the ')'  */
	    return HTStrip(p + 1);	/* Remove leading and trailing spaces */
d587 1
a587 1
    return HTStrip(name);	/* Default to the whole thing */
d591 12
a602 12
 *	--------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "montulli@@spaced.out.galaxy.net" if given any of
 *	" Lou Montulli <montulli@@spaced.out.galaxy.net> "
 *  or	" montulli@@spaced.out.galaxy.net ( Lou "The Stud" Montulli ) "
 */
static char *author_address(char *email)
d607 1
a607 1
    CTRACE((tfp, "Trying to find address in: %s\n", address));
d612 2
a613 2
		*e = '\0';	/* Remove > */
		return HTStrip(p + 1);	/* Remove leading and trailing spaces */
d621 1
a621 1
	    *p = '\0';		/* Chop off everything after the ')'  */
d638 2
a639 2
     * Default to the first word.
     */
d642 1
a642 1
	p++;			/* find first non-space */
d645 2
a646 2
	e++;			/* find next space or end */
    *e = '\0';			/* terminate space */
d648 1
a648 1
    return (p);
d652 3
a654 3
 *	--------------------
 */
static void start_anchor(const char *href)
d656 2
a657 2
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];
d660 1
a660 1
    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
d663 1
a663 1
    (*targetClass.start_element) (target, HTML_A, present, value, -1, 0);
d667 3
a669 3
 *	------------------
 */
static void start_link(const char *href, const char *rev)
d671 2
a672 2
    BOOL present[HTML_LINK_ATTRIBUTES];
    const char *value[HTML_LINK_ATTRIBUTES];
d675 1
a675 1
    for (i = 0; i < HTML_LINK_ATTRIBUTES; i++)
d678 2
a679 2
    value[HTML_LINK_REV] = rev;
    (*targetClass.start_element) (target, HTML_LINK, present, value, -1, 0);
d683 3
a685 3
 *	------------------
 */
static void start_list(int seqnum)
d687 2
a688 2
    BOOL present[HTML_OL_ATTRIBUTES];
    const char *value[HTML_OL_ATTRIBUTES];
d696 2
a697 2
    value[HTML_OL_START] = SeqNum;
    (*targetClass.start_element) (target, HTML_OL, present, value, -1, 0);
d701 10
a710 10
 *	------------------
 *
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext reference address,
 *		terminated by white space, comma, NULL or '>'
 */
static void write_anchor(const char *text, const char *addr)
d712 2
a713 2
    char href[LINE_LENGTH + 1];
    const char *p;
d716 2
a717 1
    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p != ','); p++) ;
d721 1
a721 1
	strncat(q, addr, p - addr);	/* Make complete hypertext reference */
d724 1
a724 1
	HTSprintf0(&q, "%s%.*s", NewsHREF, p - addr, addr);
d736 12
a747 12
 *	---------------------
 *
 *	We take a pointer to a list of objects, and write out each,
 *	generating an anchor for each.
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to a comma or space separated list of addresses.
 * On exit,
 *	*text	is NOT any more chopped up into substrings.
 */
static void write_anchors(char *text)
d749 2
a750 2
    char *start = text;
    char *end;
a751 1

d753 2
a754 1
	for (; *start && (WHITE(*start)); start++) ;	/* Find start */
d756 1
a756 1
	    return;		/* (Done) */
d758 2
a759 1
	     *end && (*end != ' ') && (*end != ','); end++) ;	/* Find end */
d761 1
a761 1
	    end++;		/* Include comma or space but not NULL */
d765 1
a765 1
	    write_anchor(start, start + 1);
d770 1
a770 1
	start = end;		/* Point to next one */
d775 3
a777 3
 *	--------------------
 */
static void abort_socket(void)
d780 1
a780 1
    NEWS_NETCLOSE(s);		/* End of file, close socket */
d787 1
a787 1
    s = -1;			/* End of file on response */
d791 5
a795 4
 *  Determine if a line is a valid header line.			valid_header
 *  -------------------------------------------
 */
static BOOLEAN valid_header(char *line)
d800 3
a802 2
     * Blank or tab in first position implies this is a continuation header.
     */
d804 1
a804 1
	return (TRUE);
d807 3
a809 3
     * Just check for initial letter, colon, and space to make sure we discard
     * only invalid headers.
     */
d813 1
a813 1
	return (TRUE);
d816 3
a818 3
     * Anything else is a bad header -- it should be ignored.
     */
    return (FALSE);
d822 11
a832 10
 *	------------------
 *			(added by FM, modeled on Lynx's previous mini inews)
 *
 *	Note the termination condition of a single dot on a line by itself.
 *
 *  On entry,
 *	s		Global socket number is OK
 *	postfile	file with header and article to post.
 */
static void post_article(char *postfile)
d843 1
d845 3
a847 2
     * Open the temporary file with the nntp headers and message body.  - FM
     */
d854 3
a856 2
     * Read the temporary file and post in maximum 512 byte chunks.  - FM
     */
d859 1
a859 1
    while (fgets(line, sizeof(line) - 2, fd) != NULL) {
d864 11
a874 7
	     * A single '.' means end of transmission for nntp.  Lead dots on
	     * lines normally are trimmed and the EOF is not registered if the
	     * dot was not followed by CRLF.  We prepend an extra dot for any
	     * line beginning with one, to retain the one intended, as well as
	     * avoid a false EOF signal.  We know we have room for it in the
	     * buffer, because we normally send when it would exceed 510.  - FM
	     */
d895 1
a895 1
	    } else {
d907 1
a907 1
	if ((blen + llen) >= (int) sizeof(buf) - 1) {
d918 3
a920 3
     * Send the nntp EOF and get the server's response.  - FM
     */
    if (blen >= (int) sizeof(buf) - 4) {
d932 2
a933 2
	 * Successful post.  - FM
	 */
d937 2
a938 2
	 * Shucks, something went wrong.  - FM
	 */
d943 1
a943 1
#ifdef SH_EX			/* for MIME */
d952 1
a952 1
	    printf("[ESC]");
d954 1
a954 1
	    printf("[NL]");
d956 1
a956 1
	    printf("(%02x)", *p);
d958 2
a959 2
	    putchar(*p);
	p++;
d996 1
a996 1
static char *decode_mime(char *str)
d1004 1
d1006 12
a1017 11
 *	------------------
 *
 *	Note the termination condition of a single dot on a line by itself.
 *	RFC 977 specifies that the line "folding" of RFC850 is not used, so we
 *	do not handle it here.
 *
 * On entry,
 *	s	Global socket number is OK
 *	HT	Global hypertext object is ready for appending text
 */
static int read_article(HTParentAnchor *thisanchor)
d1019 1
a1019 1
    char line[LINE_LENGTH + 1];
d1021 8
a1028 8
    char *subject = NULL;	/* Subject string           */
    char *from = NULL;		/* From string              */
    char *replyto = NULL;	/* Reply-to string          */
    char *date = NULL;		/* Date string              */
    char *organization = NULL;	/* Organization string      */
    char *references = NULL;	/* Hrefs for other articles */
    char *newsgroups = NULL;	/* Newsgroups list          */
    char *followupto = NULL;	/* Followup list            */
d1036 5
a1040 5
     * Read in the HEADer of the article.
     *
     * The header fields are either ignored, or formatted and put into the
     * text.
     */
a1043 1

d1048 2
a1049 3
		    CTRACE((tfp,
			    "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1052 1
a1052 1
		    return (HT_INTERRUPTED);
d1054 2
a1055 2
		abort_socket();	/* End of file, close socket */
		return (HT_LOADED);	/* End of file on response */
d1057 2
a1058 2
	    if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
		*--p = '\0';	/* Terminate the string */
a1062 1

d1079 2
a1080 2
		     * End of article?
		     */
d1086 1
a1086 1
		    break;	/* End of Header? */
d1089 1
a1089 1
		    StrAllocCopy(subject, HTStrip(strchr(full_line, ':') + 1));
d1092 1
a1092 1
		    StrAllocCopy(date, HTStrip(strchr(full_line, ':') + 1));
d1096 1
a1096 1
				 HTStrip(strchr(full_line, ':') + 1));
d1100 1
a1100 1
		    StrAllocCopy(from, HTStrip(strchr(full_line, ':') + 1));
d1104 1
a1104 1
		    StrAllocCopy(replyto, HTStrip(strchr(full_line, ':') + 1));
d1108 1
a1108 1
		    StrAllocCopy(newsgroups, HTStrip(strchr(full_line, ':') + 1));
d1111 1
a1111 1
		    StrAllocCopy(references, HTStrip(strchr(full_line, ':') + 1));
d1114 1
a1114 1
		    StrAllocCopy(followupto, HTStrip(strchr(full_line, ':') + 1));
d1117 4
a1120 5
		    char *msgid = HTStrip(full_line + 11);

		    if (msgid[0] == '<' && msgid[strlen(msgid) - 1] == '>') {
			msgid[strlen(msgid) - 1] = '\0';	/* Chop > */
			msgid++;	/* Chop < */
d1124 4
a1127 4
		}		/* end if match */
		p = line;	/* Restart at beginning */
	    }			/* if end of line */
	}			/* Loop over characters */
d1140 2
a1141 2
	 * Put in the owner as a link rel.
	 */
a1143 1

d1265 3
a1267 3
	     * "Followup-To:  poster" has special meaning.  Don't use it to
	     * construct a newsreply link.  -kw
	     */
d1287 4
a1290 3
	     * We have permission to POST to this host, so add a link for
	     * posting followups for this article.  - FM
	     */
d1292 1
a1292 1
		StrAllocCopy(href, "snewsreply://");
d1294 1
a1294 1
		StrAllocCopy(href, "newsreply://");
a1305 1

d1352 1
a1352 1
	 * No tags, and never do a PUTC.  - kw
d1357 3
a1359 3
	 * Read in the HEAD and BODY of the Article as XMP formatted text.  -
	 * FM
	 */
d1364 3
a1366 2
	 * Read in the BODY of the Article as PRE formatted text.  - FM
	 */
a1373 1

d1378 2
a1379 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d1382 1
a1382 1
		return (HT_INTERRUPTED);
d1385 1
a1385 1
	    return (HT_LOADED);	/* End of file on response */
d1387 2
a1388 2
	if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
	    *p++ = '\0';	/* Terminate the string */
d1390 1
a1390 1
#ifdef NEWS_DEBUG		/* 1997/11/09 (Sun) 15:56:11 */
d1395 2
a1396 2
		 * End of article?
		 */
d1400 1
a1400 1
		} else {	/* Line starts with dot */
d1404 1
a1404 1
			PUTS(&line[1]);		/* Ignore first dot */
d1412 2
a1413 2
		     * All lines are passed as unmodified source.  - FM
		     */
d1417 11
a1427 10
		     * Normal lines are scanned for buried references to other
		     * articles.  Unfortunately, it could pick up mail
		     * addresses as well!  It also can corrupt uuencoded
		     * messages!  So we don't do this when fetching articles as
		     * WWW_SOURCE or when downloading (diagnostic is TRUE) or
		     * if the client has set scan_for_buried_news_references to
		     * FALSE.  Otherwise, we convert all "<...@@...>" strings
		     * preceded by "rticle " to "news:...@@..." links, and any
		     * strings that look like URLs to links.  - FM
		     */
d1432 1
a1432 1
			char *q = strrchr(p2, '>');
d1434 1
a1434 2

			if (q && at && at < q) {
d1436 1
a1436 2

			    q[1] = 0;	/* chop up */
d1456 1
a1456 1
				    PUTC(*l++);
d1466 1
a1466 1
			    *p2 = '<';	/* again */
d1468 2
a1469 2
			    start_anchor(p2 + 1);
			    *q = '>';	/* again */
d1472 1
a1472 1
			    q[1] = c;	/* again */
d1475 1
a1475 1
			    break;	/* line has unmatched <> */
d1478 1
a1478 1
		    while (*l) {	/* Last bit of the line */
d1495 1
a1495 1
			    PUTC(*l++);
d1505 5
a1509 5
		}		/* if diagnostic or not scan_for_buried_news_references */
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */
d1512 1
a1512 1
	return (HT_LOADED);
d1519 1
a1519 1
    return (HT_LOADED);
d1523 7
a1529 7
 *	----------------------------
 *
 *  Note the termination condition of a single dot on a line by itself.
 *  RFC 977 specifies that the line "folding" of RFC850 is not used,
 *  so we do not handle it here.
 */
static int read_list(char *arg)
d1531 1
a1531 1
    char line[LINE_LENGTH + 1];
d1543 2
a1544 2
     * Support head or tail matches for groups to list.  - FM
     */
d1548 2
a1549 2
	    StrAllocCopy(pattern, (arg + 1));
	} else if (arg[strlen(arg) - 1] == '*') {
d1552 1
a1552 1
	    pattern[strlen(pattern) - 1] = '\0';
d1555 1
a1555 1
	    len = strlen(pattern);
d1561 5
a1565 4
     * Read the server's reply.
     *
     * The lines are scanned for newsgroup names and descriptions.
     */
d1575 1
a1575 1
    PUTS("Newsgroups");
a1583 1

d1587 2
a1588 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d1591 1
a1591 1
		return (HT_INTERRUPTED);
d1595 1
a1595 1
	    return (HT_LOADED);	/* End of file on response */
d1613 1
a1613 1
		skip_this_line = YES;	/* ...and ignore until LF */
d1618 1
a1618 1
		skip_this_line = YES;	/* ignore whole line */
d1621 1
a1621 1
		skip_rest_of_line = YES;	/* skip until ch == LF found */
d1628 1
a1628 1
	    *p = '\0';		/* Terminate the string */
d1632 2
a1633 2
		 * End of article?
		 */
d1637 1
a1637 1
		} else {	/* Line starts with dot */
d1643 1
a1643 1
		p = line;	/* Restart at beginning */
d1647 2
a1648 2
		 * Normal lines are scanned for references to newsgroups.
		 */
d1652 2
a1653 1
		for (; line[i] != '\0' && !WHITE(line[i]); i++) ;	/* null body */
d1669 1
a1669 1
		    PUTS(&line[i + 1]);		/* put description */
d1683 4
a1686 4
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */
a1688 1

d1698 1
a1698 1
    return (HT_LOADED);
d1702 14
a1715 13
 *	-------------------
 *
 *  Unfortunately, we have to ask for each article one by one if we
 *  want more than one field.
 *
 */
static int read_group(const char *groupName,
		      int first_required,
		      int last_required)
{
    char line[LINE_LENGTH + 1];
    char author[LINE_LENGTH + 1];
    char subject[LINE_LENGTH + 1];
d1721 1
a1721 1
    char buffer[LINE_LENGTH + 1];
d1723 2
a1724 2
    char *reference = NULL;	/* Href for article */
    int art;			/* Article number WITHIN GROUP */
d1726 1
a1726 2

    /* count is only an upper limit */
d1741 1
a1741 1
	    status, count, first, last, first_required, last_required));
d1746 1
d1751 1
a1751 1
	first_required = first;	/* clip */
d1760 2
a1761 2
    if (last_required - first_required + 1 > HTNewsMaxChunk) {	/* Trim this block */
	first_required = last_required - HTNewsChunkSize + 1;
d1764 1
a1764 1
	    first_required, last_required));
d1767 2
a1768 2
     * Set window title.
     */
d1770 1
a1770 1
	       groupName, first_required, last_required);
d1778 2
a1779 2
     * Link to earlier articles.
     */
d1781 2
a1782 3
	int before;		/* Start of one before */

	if (first_required - HTNewsMaxChunk <= first)
d1785 1
a1785 1
	    before = first_required - HTNewsChunkSize;
d1787 1
a1787 1
		   before, first_required - 1);
d1802 1
a1802 1
    if (count > FAST_THRESHOLD) {
d1804 2
a1805 2
		   gettext("\nThere are about %d articles currently available in %s, IDs as follows:\n\n"),
		   count, groupName);
a1813 1

d1818 2
a1819 3
			CTRACE((tfp,
				"HTNews: Interrupted on read, closing socket %d\n",
				s));
d1822 1
a1822 1
			return (HT_INTERRUPTED);
d1825 1
a1825 1
		    return (HT_LOADED);		/* End of file on response */
d1827 2
a1828 2
		if (((char) ich == '\n') || (p == &line[LINE_LENGTH])) {
		    *p = '\0';	/* Terminate the string */
d1832 2
a1833 2
			 * End of article?
			 */
d1837 2
a1838 2
			} else {	/* Line starts with dot */
			    /* Ignore strange line */
d1842 4
a1845 4
			 * Normal lines are scanned for references to articles.
			 */
			char *space = strchr(line, ' ');

d1848 4
a1851 4
		    }		/* if not dot */
		    p = line;	/* Restart at beginning */
		}		/* if end of line */
	    }			/* Loop over characters */
d1854 1
a1854 1
	}			/* Good status */
d1859 2
a1860 2
     * Read newsgroup using individual fields.
     */
d1878 7
a1884 7
	     * With this code we try to keep the server running flat out by
	     * queuing just one extra command ahead of time.  We assume (1)
	     * that the server won't abort if it gets input during output, and
	     * (2) that TCP buffering is enough for the two commands.  Both
	     * these assumptions seem very reasonable.  However, we HAVE had a
	     * hangup with a loaded server.
	     */
d1886 1
a1886 1
		if (art == last_required) {	/* Only one */
d1888 1
a1888 1
			    art, CR, LF);
d1890 1
a1890 1
		} else {	/* First of many */
d1892 2
a1893 2
			    art, CR, LF, art + 1, CR, LF);
		    status = response(buffer);
d1895 1
a1895 1
	    } else if (art == last_required) {	/* Last of many */
d1897 2
a1898 2
	    } else {		/* Middle of many */
		sprintf(buffer, "HEAD %d%c%c", art + 1, CR, LF);
d1901 1
a1901 1
#else /* Not OVERLAP: */
d1904 1
a1904 1
#endif /* OVERLAP */
d1906 9
a1914 8
	     * Check for a good response (221) for the HEAD request, and if so,
	     * parse it.  Otherwise, indicate the error so that the number of
	     * listings corresponds to what's claimed for the range, and if we
	     * are listing numbers via an ordered list, they stay in synchrony
	     * with the article numbers.  - FM
	     */
	    if (status == 221) {	/* Head follows - parse it: */
		p = line;	/* Write pointer */
d1916 1
a1916 1
		while (!done) {
a1917 1

d1922 2
a1923 3
			    CTRACE((tfp,
				    "HTNews: Interrupted on read, closing socket %d\n",
				    s));
d1926 1
a1926 1
			    return (HT_INTERRUPTED);
d1929 1
a1929 1
			return (HT_LOADED);	/* End of file on response */
d1931 1
a1931 1
		    if (((char) ich == LF) ||
d1934 2
a1935 2
			*--p = '\0';	/* Terminate  & chop LF */
			p = line;	/* Restart at beginning */
d1937 1
a1937 1
			switch (line[0]) {
d1941 2
a1942 2
			     * End of article?
			     */
d1949 1
a1949 1
				LYstrncpy(subject, line + 9, sizeof(subject) - 1);	/* Save subject */
d1957 2
a1958 3
				char *addr = HTStrip(line + 11) + 1;	/* Chop < */

				addr[strlen(addr) - 1] = '\0';	/* Chop > */
d1966 1
a1966 2
				char *p2;

d1968 2
a1969 2
					  author_name(strchr(line, ':') + 1),
					  sizeof(author) - 1);
d1972 2
a1973 2
				if (*p2 == LF)
				    *p2 = '\0';		/* Chop off newline */
d1981 1
a1981 1
					     HTStrip(strchr(line, ':') + 1));
d1985 3
a1987 3
			}	/* end switch on first character */
		    }		/* if end of line */
		}		/* Loop over characters */
d1991 1
a1991 1
#ifdef SH_EX			/* for MIME */
d2005 5
a2009 5
		    PUTS(" - ");
		    if (LYListNewsDates)
			START(HTML_I);
#ifdef SH_EX			/* for MIME */
		    PUTS(decode_mime(author));
d2011 1
a2011 1
		    PUTS(author);
d2013 3
a2015 3
		    if (LYListNewsDates)
			END(HTML_I);
		    author[0] = '\0';
d2025 1
a2025 1
		    sprintf(buffer, " [%.*s]", (int) (sizeof(buffer) - 4), date);
d2031 2
a2032 2
		 * Indicate progress!  @@@@@@@@@@@@
		 */
d2035 2
a2036 3
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
d2039 1
a2039 1
		return (HT_INTERRUPTED);
d2042 2
a2043 2
		 * Use the response text on error.  - FM
		 */
d2056 3
a2058 3
	    }			/* Handle response to HEAD request */
	}			/* Loop over article */
    }				/* If read headers */
d2067 2
a2068 2
     * Link to later articles.
     */
d2070 2
a2071 3
	int after;		/* End of article after */

	after = last_required + HTNewsChunkSize;
d2073 1
a2073 1
	    HTSprintf0(&dbuf, "%s%s", NewsHREF, groupName);	/* original group */
d2076 1
a2076 1
		       last_required + 1, after);
d2085 1
a2085 1
  add_post:
d2088 4
a2091 3
	 * We have permission to POST to this host, so add a link for posting
	 * messages to this newsgroup.  - FM
	 */
d2097 1
a2097 1
	    StrAllocCopy(href, "snewspost://");
d2099 1
a2099 1
	    StrAllocCopy(href, "newspost://");
d2102 1
a2102 1
	StrAllocCat(href, groupName);
d2112 1
a2112 1
    return (HT_LOADED);
d2116 7
a2122 6
 *	=============
 */
static int HTLoadNews(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *stream)
d2124 2
a2125 2
    char command[262];		/* The whole command */
    char proxycmd[260];		/* The proxy command */
d2127 2
a2128 2
    int status;			/* tcp return */
    int retries;		/* A count of how hard we have tried */
a2142 1

d2157 1
a2157 1
	return -1;		/* FAIL */
d2161 1
a2161 1
    command[sizeof(command) - 1] = '\0';
d2163 1
a2163 1
    proxycmd[sizeof(proxycmd) - 1] = '\0';
d2166 1
a2166 1
	const char *p1 = arg;
d2169 9
a2177 10
	 * We will ask for the document, omitting the host name & anchor.
	 *
	 * Syntax of address is
	 * xxx@@yyy                 Article
	 * <xxx@@yyy>               Same article
	 * xxxxx                   News group (no "@@")
	 * group/n1-n2             Articles n1 to n2 in group
	 */
	normal_url = (BOOL) (!strncmp(arg, STR_NEWS_URL, LEN_NEWS_URL) ||
			     !strncmp(arg, "nntp:", 5));
d2180 1
a2180 1
				strstr(arg, "snewsreply:") != NULL);
d2182 1
a2182 1
			      strstr(arg, "newspost:") != NULL);
d2184 2
a2185 2
				 post_wanted) &&
			       strstr(arg, "newsreply:") != NULL);
d2187 6
a2192 8
				  post_wanted || reply_wanted) &&
				strchr(arg, '@@') == NULL) &&
			       (strchr(arg, '*') == NULL));
	list_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
				 post_wanted || reply_wanted ||
				 group_wanted) &&
			       strchr(arg, '@@') == NULL) &&
			      (strchr(arg, '*') != NULL));
d2203 2
a2204 2
	     * Make sure we have a non-zero path for the newsgroup(s).  - FM
	     */
d2212 1
a2212 1
		return (HT_NO_DATA);
d2229 7
a2235 7
		       (post_wanted ?
			"newspost" :
			(reply_wanted ?
			 "newreply" :
			 (spost_wanted ?
			  "snewspost" : "snewsreply"))),
		       (int) sizeof(command) - 15, NewsHost);
d2238 4
a2241 4
	     * If the SSL daemon is being used as a proxy, reset p1 to the
	     * start of the proxied URL rather than to the start of the
	     * newsgroup(s).  - FM
	     */
d2247 6
a2252 7
	    /* p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION); */
	    /*
	     * Don't use HTParse because news:  access doesn't follow
	     * traditional rules.  For instance, if the article reference
	     * contains a '#', the rest of it is lost -- JFG 10/7/92, from a
	     * bug report
	     */
d2286 2
a2287 1
	} else if (!strncasecomp(arg, STR_SNEWS_URL, 6)) {
d2325 2
a2326 1
	} else if (!strncasecomp(arg, "news:/", 6)) {
d2357 1
a2357 1
	    p1 = (arg + 5);	/* Skip "news:" prefix */
d2372 5
a2376 4
	 * Set up any proxy for snews URLs that returns NNTP responses for Lynx
	 * to convert to HTML, instead of doing the conversion itself, and for
	 * handling posts or followups.  - TZ & FM
	 */
d2387 1
a2387 1
	    command[sizeof(command) - 2] = '\0';
d2390 1
a2390 1
		    (int) sizeof(proxycmd) - 9, command,
d2393 1
a2393 1
		    (int) (strlen(proxycmd) - 4), proxycmd));
d2399 2
a2400 2
		 * Reset p1 so that it points to the newsgroup(s).
		 */
d2408 3
a2410 3
		 * Reset p1 so that it points to the newsgroup (or a wildcard),
		 * or the article.
		 */
d2422 2
a2423 2
	 * Set up command for a post, listing, or article request.  - FM
	 */
d2435 1
a2435 2
	    char *slash = strchr(p1, '/');

d2448 3
a2450 3
		(void) sscanf(slash + 1, "%d-%d", &first, &last);
		if ((first > 0) && (isdigit(UCH(*(slash + 1)))) &&
		    (strchr(slash + 1, '-') == NULL || first == last)) {
d2452 7
a2458 6
		     * We got a number greater than 0, which will be loaded as
		     * first, and either no range or the range computes to
		     * zero, so make last negative, as a flag to select the
		     * group and then fetch an article by number (first)
		     * instead of by messageID.  - FM
		     */
d2472 2
a2473 3
	    int add_open = (strchr(p1, '<') == 0);
	    int add_close = (strchr(p1, '>') == 0);

d2488 1
a2488 2
	    char *p = command + strlen(command);

d2490 2
a2491 2
	     * Terminate command with CRLF, as in RFC 977.
	     */
d2497 1
a2497 1
    }				/* scope of p1 */
d2504 1
a2504 1
	return NO;		/* Ignore if no name */
d2513 1
a2513 1
	    for (cp = command + 5;; cp++)
d2531 2
a2532 2
	    return (HT_NOT_LOADED);
	}			/* Copy routine entry points */
d2535 3
a2537 3
	/*
	 * Make a hypertext object with an anchor list.
	 */
d2545 2
a2546 2
     * Now, let's get a stream setup up from the NewsHost.
     */
a2550 1

d2552 1
a2552 1
		SnipIn(url, "lose://%.*s/", 9, NewsHost);
d2554 1
a2554 1
		SnipIn(url, "%.*s", 1, ProxyHREF);
d2556 1
a2556 1
		SnipIn(url, "%.*s", 1, NewsHREF);
d2567 1
a2567 1
		status = HTDoConnect(url, "NNTPS", SNEWS_PORT, &s);
d2569 1
a2569 1
		status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
d2571 1
a2571 1
	    status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
d2576 3
a2578 4
		 * Interrupt cleanly.
		 */
		CTRACE((tfp,
			"HTNews: Interrupted on connect; recovering cleanly.\n"));
d2624 1
a2624 1
			NewsHost));
d2627 3
a2629 2
		 * If this is an snews url, then do the SSL stuff here
		 */
d2641 1
a2641 4

			CTRACE((tfp,
				"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
d2643 2
a2644 3
			while ((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp, "HTNews: SSL: %s\n",
				    ERR_error_string(SSLerror, NULL)));
d2646 2
a2647 1
			HTAlert("Unable to make secure connection to remote host.");
d2652 1
a2652 1
			    (*targetClass._abort) (target, NULL);
d2660 2
a2661 1
			    while (remove(postfile) == 0) ;	/* loop through all versions */
d2669 1
a2669 5
		    sprintf(SSLprogress,
			    "Secure %d-bit %s (%s) NNTP connection",
			    SSL_get_cipher_bits(Handle, NULL),
			    SSL_get_cipher_version(Handle),
			    SSL_get_cipher(Handle));
d2673 1
a2673 1
		HTInitInput(s);	/* set up buffering */
d2676 2
a2677 3
		    CTRACE((tfp,
			    "HTNews: Proxy command returned status '%d'.\n",
			    status));
d2680 25
a2704 4
		    NEWS_NETCLOSE(s);
		    s = -1;
		    if (status == HT_INTERRUPTED) {
			_HTProgress(CONNECTION_INTERRUPTED);
d2709 8
a2716 8
			FREE(NewsHost);
			FREE(NewsHREF);
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			if (postfile) {
			    HTSYS_remove(postfile);
			    FREE(postfile);
d2718 1
a2718 22
			return (HT_NOT_LOADED);
		    }
		    if (retries < 1)
			continue;
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    FREE(ListArg);
		    FREE(postfile);
		    if (!(post_wanted || reply_wanted ||
			  spost_wanted || sreply_wanted)) {
			ABORT_TARGET;
		    }
		    if (response_text[0]) {
			HTSprintf0(&dbuf,
				   gettext("Can't read news info.  News host %.20s responded: %.200s"),
				   NewsHost, response_text);
		    } else {
			HTSprintf0(&dbuf,
				   gettext("Can't read news info, empty response from host %s"),
				   NewsHost);
		    }
		    return HTLoadError(stream, 500, dbuf);
d2738 1
a2738 1
			return (HT_NOT_LOADED);
d2742 2
a2743 2
	}
	/* If needed opening */
d2745 1
a2745 1
	    spost_wanted || sreply_wanted) {
d2759 1
a2759 1
		return (HT_NOT_LOADED);
d2763 1
a2763 1
				      (BOOLEAN) (reply_wanted || sreply_wanted));
d2774 1
a2774 1
		return (HT_NOT_LOADED);
d2778 6
a2783 6
	     * Ensure reader mode, but don't bother checking the status for
	     * anything but HT_INTERRUPTED or a 480 Authorization request,
	     * because if the reader mode command is not needed, the server
	     * probably returned a 500, which is irrelevant at this point.  -
	     * FM
	     */
a2792 1

d2809 1
a2809 1
      Send_NNTP_command:
d2828 7
a2834 6
	 * For some well known error responses which are expected to occur in
	 * normal use, break from the loop without retrying and without closing
	 * the connection.  It is unlikely that these are leftovers from a
	 * timed-out connection (but we do some checks to see whether the
	 * response corresponds to the last command), or that they will give
	 * anything else when automatically retried.  - kw
d2844 2
a2845 2
		   !strncmp(command, "ARTICLE <", 9) &&
		   !strcasecomp(response_text + 3, " No such article")) {
d2850 1
a2850 1
	if ((status / 100) != 2 &&
d2865 4
a2868 3
	     * Message might be a leftover "Timeout-disconnected", so try again
	     * if the retries maximum has not been reached.
	     */
d2873 2
a2874 2
	 * Post or load a group, article, etc
	 */
a2876 1

d2878 1
a2878 1
	     * Some servers return 480 for a failed XGTITLE.  - FM
d2887 2
a2888 2
	     * Handle Authorization.  - FM
	     */
d2903 2
a2904 2
	     * Handle posting of an article.  - FM
	     */
d2917 2
a2918 2
	     * List available newsgroups.  - FM
	     */
d2923 2
a2924 2
	     * List articles in a news group.  - FM
	     */
d2927 7
a2933 6
		 * We got one article number rather than a range following the
		 * slash which followed the group name, or the range was zero,
		 * so now that we have selected that group, load ARTICLE and
		 * the the number (first) as the command and go back to send it
		 * and check the response.  - FM
		 */
d2945 2
a2946 2
	     * Get an article from a news group.  - FM
	     */
d2974 1
a2974 1
    }				/* Retry loop */
d2978 1
a2978 1
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL, NULL, NULL, arg);
d3001 15
a3015 14
 *  This function clears all authorization information by
 *  invoking the free_NNTP_AuthInfo() function, which normally
 *  is invoked at exit.  It allows a browser command to do
 *  this at any time, for example, if the user is leaving
 *  the terminal for a period of time, but does not want
 *  to end the current session.  - FM
 */
void HTClearNNTPAuthInfo(void)
{
    /*
     * Need code to check cached documents and do something to ensure that any
     * protected documents no longer can be accessed without a new retrieval. 
     * - FM
     */
d3018 2
a3019 2
     * Now free all of the authorization info.  - FM
     */
d3024 1
a3024 1
static char HTNewsGetCharacter(void)
d3029 1
a3029 1
	return HTGetSSLCharacter((void *) Handle);
d3032 6
a3037 5
int HTNewsProxyConnect(int sock,
		       const char *url,
		       HTParentAnchor *anAnchor,
		       HTFormat format_out,
		       HTStream *sink)
d3040 1
a3040 1
    const char *arg = url;
a3050 1

d3052 1
a3052 3
	CTRACE((tfp,
		"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		url, status));
d3054 2
a3055 2
	while ((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp, "HTNews: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
d3062 2
a3063 2
    sprintf(SSLprogress, "Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle, NULL),
d3075 1
a3075 1
GLOBALDEF(HTProtocol, HTNews, _HTNEWS_C_1_INIT);
d3077 1
a3077 1
GLOBALDEF(HTProtocol, HTNNTP, _HTNEWS_C_2_INIT);
d3079 1
a3079 1
GLOBALDEF(HTProtocol, HTNewsPost, _HTNEWS_C_3_INIT);
d3081 1
a3081 1
GLOBALDEF(HTProtocol, HTNewsReply, _HTNEWS_C_4_INIT);
d3083 1
a3083 1
GLOBALDEF(HTProtocol, HTSNews, _HTNEWS_C_5_INIT);
d3085 1
a3085 1
GLOBALDEF(HTProtocol, HTSNewsPost, _HTNEWS_C_6_INIT);
d3087 1
a3087 1
GLOBALDEF(HTProtocol, HTSNewsReply, _HTNEWS_C_7_INIT);
d3089 7
a3095 14
GLOBALDEF HTProtocol HTNews =
{"news", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNNTP =
{"nntp", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsPost =
{"newspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsReply =
{"newsreply", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNews =
{"snews", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsPost =
{"snewspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsReply =
{"snewsreply", HTLoadNews, NULL};
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a18 1
#include <HTFont.h>
d21 3
a23 1
#include <LYStrings.h>
d39 3
d43 1
d50 1
a67 1
#define SnipIn(d,fmt,len,s) sprintf(d, fmt, (int)sizeof(d)-len, s)
d78 1
a78 1
#define LINE_LENGTH 512			/* Maximum length of line of ARTICLE etc */
d83 1
d92 2
a93 2
PRIVATE char * NewsHost = NULL;			/* Current host */
PRIVATE char * NewsHREF = NULL;			/* Current HREF prefix */
d214 2
a215 2
	CTRACE((tfp, "HTNews: NNTPSERVER defined as `%s'\n",
		    HTNewsHost));
d217 2
a218 1
	FILE* fp = fopen(SERVER_FILE, TXT_R);
d220 1
a220 5
	    char server_name[MAXHOSTNAMELEN+1];
	    if (fgets(server_name, sizeof server_name, fp) != NULL) {
		char *p = strchr(server_name, '\n');
		if (p != NULL)
		    *p = '\0';
d222 2
a223 2
		CTRACE((tfp, "HTNews: File %s defines news host as `%s'\n",
			    SERVER_FILE, HTNewsHost));
d249 1
a249 1
PRIVATE int response ARGS1(char *,command)
d258 1
a258 1
	CTRACE((tfp, "NNTP command to be sent: %s", command));
d273 1
a273 1
	    CTRACE((tfp, "HTNews: Unable to send command. Disconnecting.\n"));
d282 1
a282 1
	if (((*p++ = (char) ich) == LF) ||
d285 1
a285 1
	    CTRACE((tfp, "NNTP Response: %s\n", response_text));
d293 2
a294 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d296 2
a297 2
		CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n",
			    s));
d335 1
a335 1
	char *,		host)
d373 1
a373 1
    buffer[sizeof(buffer)-1] = '\0';
d378 4
a381 1
	    HTSprintf0(&msg, gettext("Username for news host '%s':"), host);
d389 1
a389 2
	sprintf(buffer, "AUTHINFO USER %.*s%c%c",
		(int) sizeof(buffer)-17, UserName, CR, LF);
d418 2
a419 1
		if ((auth = typecalloc(NNTPAuth)) != NULL) {
d462 4
a465 1
		HTSprintf0(&msg, gettext("Password for news host '%s':"), host);
d473 1
a473 2
	    sprintf(buffer, "AUTHINFO PASS %.*s%c%c",
		    (int) sizeof(buffer)-17, PassWord, CR, LF);
d528 2
a529 1
		    if ((auth = typecalloc(NNTPAuth)) != NULL) {
d582 1
a582 1
    CTRACE((tfp,"Trying to find name in: %s\n",name));
d584 1
a584 1
    if ((p = strrchr(name, '(')) && (e = strrchr(name, ')'))) {
d591 3
a593 4
    if ((p = strrchr(name, '<')) && (e = strrchr(name, '>'))) {
	if (e++ > p) {
	    while ((*p++ = *e++) != 0)	/* Remove <...> */
		;
d618 1
a618 1
    CTRACE((tfp,"Trying to find address in: %s\n",address));
d620 2
a621 2
    if ((p = strrchr(address, '<'))) {
	if ((e = strrchr(p, '>')) && (at = strrchr(p, '@@'))) {
d629 2
a630 2
    if ((p = strrchr(address, '(')) &&
	(e = strrchr(address, ')')) && (at = strchr(address, '@@'))) {
d637 1
a637 1
    if ((at = strrchr(address, '@@')) && at > address) {
d640 1
a640 1
	while (p > address && !isspace(UCH(*p)))
d642 1
a642 1
	while (*e && !isspace(UCH(*e)))
d652 1
a652 1
    while (isspace(UCH(*p)))
d655 1
a655 1
    while (!isspace(UCH(*e)) && *e != '\0')
d668 1
a668 2
    CONST char*		value[HTML_A_ATTRIBUTES];
    int i;
d670 8
a677 4
    for(i=0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
    value[HTML_A_HREF] = href;
    (*targetClass.start_element)(target, HTML_A, present, value, -1, 0);
d686 1
a686 2
    CONST char*		value[HTML_LINK_ATTRIBUTES];
    int i;
d688 9
a696 5
    for(i=0; i < HTML_LINK_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_LINK_HREF || i == HTML_LINK_REV);
    value[HTML_LINK_HREF] = href;
    value[HTML_LINK_REV]  = rev;
    (*targetClass.start_element)(target, HTML_LINK, present, value, -1, 0);
d705 1
a705 1
    CONST char*		value[HTML_OL_ATTRIBUTES];
d710 1
a710 1
	present[i] = (BOOL) (i == HTML_OL_SEQNUM || i == HTML_OL_START);
d712 4
a715 3
    value[HTML_OL_SEQNUM] = SeqNum;
    value[HTML_OL_START]  = SeqNum;
    (*targetClass.start_element)(target, HTML_OL, present, value, -1, 0);
a730 2
    CONST char * p;
    char *q;
d732 6
a737 9
    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p!=','); p++)
	;
    if (strlen(NewsHREF) + (p - addr) + 1 < sizeof(href)) {
	q = href;
	strcpy(q, NewsHREF);
	strncat(q, addr, p-addr);	/* Make complete hypertext reference */
    } else {
	q = NULL;
	HTSprintf0(&q, "%s%.*s", NewsHREF, p-addr, addr);
d740 1
a740 1
    start_anchor(q);
a742 3

    if (q != href)
	FREE(q);
d789 1
a789 1
    CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n", s));
d791 2
a792 6
    if (rawtext) {
	RAW_PUTS("Network Error: connection lost\n");
    } else {
	PUTS("Network Error: connection lost");
	PUTC('\n');
    }
d797 1
a797 1
**  Determine if a line is a valid header line.			valid_header
d801 1
a801 1
	char *,		line)
d818 1
a818 1
    if (isalpha(UCH(line[0])) && colon && space == colon + 1)
d838 1
a838 1
	char *,		postfile)
d854 1
a854 1
    if ((fd = fopen((postfile ? postfile : ""), TXT_R)) == NULL) {
d865 1
a865 1
    while (fgets(line, sizeof(line)-2, fd) != NULL) {
d893 5
a897 1
		    if (blen >= (int) sizeof(buf) - 35) {
d899 3
a901 1
			buf[blen = 0] = 0;
a902 3
		    strcat(buf, "From: anonymous@@nowhere.you.know");
		    strcat(buf, crlf);
		    blen += 34;
d916 4
a919 1
	if ((blen + llen) >= (int) sizeof(buf)-1) {
d921 2
a922 1
	    buf[blen = 0] = 0;
a923 2
	strcat(buf, line);
	blen += llen;
d931 9
a939 1
    if (blen >= (int) sizeof(buf)-4) {
a940 1
	buf[blen = 0] = 0;
a941 5
    strcat(buf, ".");
    strcat(buf, crlf);
    blen += 3;
    NEWS_NETWRITE(s, buf, blen);

a955 63
#ifdef SH_EX	/* for MIME */
#define NEWS_DEBUG 0
#if NEWS_DEBUG
/* for DEBUG 1997/11/07 (Fri) 17:20:16 */
void debug_print(unsigned char *p)
{
    while (*p) {
	if (*p == '\0')
	    break;
	if (*p == 0x1b)
	   printf("[ESC]");
	else if (*p == '\n')
	   printf("[NL]");
	else if (*p < ' ' || *p >= 0x80)
	   printf("(%02x)", *p);
	else
	   putchar(*p);
       p++;
    }
    printf("]\n");
}
#endif

static char *decode_mime(char *str)
{
    char temp[LINE_LENGTH];	/* FIXME: what determines the actual size? */
    char *p, *q;

    if (str == NULL)
	return "";

    if (HTCJK != JAPANESE)
	return str;

    LYstrncpy(temp, str, sizeof(temp) - 1);
    q = temp;
    while ((p = strchr(q, '=')) != 0) {
	if (p[1] == '?') {
	    HTmmdecode(p, p);
	    q = p + 2;
	} else {
	    q = p + 1;
	}
    }
#if NEWS_DEBUG
    printf("new=[");
    debug_print(temp);
#endif
    HTrjis(temp, temp);
    strcpy(str, temp);

    return str;
}
#else /* !SH_EX */
static char *decode_mime ARGS1(char *, str)
{
    HTmmdecode(str, str);
    HTrjis(str, str);
    return str;
}
#endif


d995 1
a995 1
	    *p++ = (char) ich;
d999 2
a1000 2
		    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				s));
d1005 1
a1005 1
		abort_socket();		/* End of file, close socket */
d1010 1
a1010 1
		CTRACE((tfp, "H %s\n", line));
d1032 1
a1032 1
		    if (UCH(full_line[1]) < ' ') {
d1036 1
a1036 1
		} else if (UCH(full_line[0]) < ' ') {
d1041 8
a1048 1
		    decode_mime(subject);
d1055 4
a1058 1
		    decode_mime(organization);
d1062 4
a1065 1
		    decode_mime(from);
d1069 4
a1072 1
		    decode_mime(replyto);
d1087 1
a1087 1
			msgid++;			/* Chop < */
d1110 1
a1110 1
	    char *temp = NULL;
d1319 1
a1319 1
	 *  No tags, and never do a PUTC. - kw
a1327 1
	PUTC('\n');
a1333 1
	PUTC('\n');
d1335 1
d1340 1
a1340 1
	*p++ = (char) ich;
d1344 2
a1345 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1355 1
a1355 4
	    CTRACE((tfp, "B %s", line));
#if NEWS_DEBUG	/* 1997/11/09 (Sun) 15:56:11 */
	    debug_print(line);	/* @@@@@@ */
#endif
d1360 1
a1360 1
		if (UCH(line[1]) < ' ') {
d1364 1
a1364 1
		    if (rawtext) {
d1366 1
a1366 1
		    } else {
a1367 1
		    }
d1394 2
a1395 2
			char *q  = strrchr(p2,'>');
			char *at = strrchr(p2, '@@');
d1417 1
a1417 1
				    strncmp(l, "gopher://", 9)) {
d1419 1
a1419 1
				} else {
d1435 1
a1435 1
			    l = q + 1;
d1545 1
a1545 1
	char ch = (char) ich;
d1549 2
a1550 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1569 1
a1569 1
	    CTRACE((tfp, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch));
d1579 1
a1579 1
		CTRACE((tfp, "HTNews..... group name too long, discarding.\n"));
d1591 1
a1591 1
	    CTRACE((tfp, "B %s", line));
d1596 1
a1596 1
		if (UCH(line[1]) < ' ') {
a1649 1
	char *msg = NULL;
d1651 2
a1652 2
	HTSprintf0(&msg, gettext("No matches for: %s"), arg);
	PUTS(msg);
a1653 1
	FREE(msg);
d1669 3
a1671 3
	CONST char *,	groupName,
	int,		first_required,
	int,		last_required)
d1681 1
a1681 2
    char buffer[LINE_LENGTH+1];
    char *temp = NULL;
d1699 2
a1700 2
    CTRACE((tfp, "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
		status, count, first, last, first_required, last_required));
d1710 1
a1710 1
	first_required = first;		/* clip */
d1722 2
a1723 2
    CTRACE((tfp, "    Chunk will be (%d-%d)\n",
		first_required, last_required));
d1728 1
a1728 1
    HTSprintf0(&temp, gettext("%s,  Articles %d-%d"),
d1731 1
a1731 2
    PUTS(temp);
    FREE(temp);
d1746 1
a1746 1
	CTRACE((tfp, "    Block before is %s\n", dbuf));
d1761 1
a1761 1
	HTSprintf0(&temp,
d1764 1
a1764 2
	PUTS(temp);
	FREE(temp);
d1775 2
a1776 2
			CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				    s));
d1786 1
a1786 1
		    CTRACE((tfp, "X %s", line));
d1791 1
a1791 1
			if (UCH(line[1]) < ' ') {
d1875 1
a1875 1
		    *p++ = (char) ich;
d1879 2
a1880 2
			    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
					s));
d1885 1
a1885 1
			abort_socket();		/* End of file, close socket */
d1893 1
a1893 1
			CTRACE((tfp, "G %s\n", line));
d1900 1
a1900 1
			    done = (BOOL) (UCH(line[1]) < ' ');
d1906 5
a1910 2
				LYstrncpy(subject, line+9, sizeof(subject)-1);/* Save subject */
				decode_mime(subject);
d1927 6
a1932 4
				LYstrncpy(author,
					author_name(strchr(line,':')+1),
					sizeof(author)-1);
				decode_mime(author);
d1953 1
a1953 5
#ifdef SH_EX	/* for MIME */
		HTSprintf0(&temp, "\"%s\"", decode_mime(subject));
#else
		HTSprintf0(&temp, "\"%s\"", subject);
#endif
d1955 1
a1955 1
		    write_anchor(temp, reference);
d1958 1
a1958 1
		    PUTS(temp);
a1959 2
		FREE(temp);

a1963 3
#ifdef SH_EX	/* for MIME */
		     PUTS(decode_mime(author));
#else
a1964 1
#endif
d1977 1
a1977 1
		    sprintf(buffer, " [%.*s]", (int)(sizeof(buffer) - 4), date);
d1987 2
a1988 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d2000 1
a2000 1
		    LYstrncpy(buffer, "Status:", sizeof(buffer) - 1);
d2029 1
a2029 1
	CTRACE((tfp, "    Block after is %s\n", dbuf));
d2076 2
a2077 2
    char command[262];			/* The whole command */
    char proxycmd[260];			/* The proxy command */
d2079 1
a2079 1
    int status;				/* tcp return */
a2080 1
    BOOL normal_url;		/* Flag: "news:" or "nntp:" (physical) URL */
d2086 1
a2086 1
    BOOL sreply_wanted;		/* Flag: followup SSL post was asked for */
a2093 3
#ifdef USE_SSL
    char SSLprogress[256];
#endif /* USE_SSL */
d2100 1
a2100 1
    CTRACE((tfp, "HTNews: Looking for %s\n", arg));
d2109 1
a2109 1
    command[sizeof(command)-1] = '\0';
d2111 1
a2111 1
    proxycmd[sizeof(proxycmd)-1] = '\0';
d2120 1
a2120 1
	**	xxx@@yyy			Article
d2125 2
a2126 3
	normal_url = (BOOL) (!strncmp(arg, "news:", 5) || !strncmp(arg, "nntp:", 5));
	spost_wanted = (BOOL) (!normal_url && strstr(arg, "snewspost:") != NULL);
	sreply_wanted = (BOOL) (!(normal_url || spost_wanted) &&
d2128 1
a2128 1
	post_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted) &&
d2130 1
a2130 1
	reply_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted ||
d2133 1
a2133 1
	group_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
d2135 2
a2136 2
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') == NULL));
	list_wanted  = (BOOL) ((!(spost_wanted || sreply_wanted ||
d2139 1
a2139 1
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') != NULL));
d2175 1
a2175 1
	    HTSprintf0(&NewsHREF, "%s://%.*s/",
d2181 2
a2182 2
			      "snewspost" : "snewsreply"))),
			    (int) sizeof(command) - 15, NewsHost);
d2231 1
a2231 1
	    SnipIn(command, "nntp://%.*s/", 9, NewsHost);
d2301 1
a2301 1
	    SnipIn(command, "news://%.*s/", 9, NewsHost);
d2329 1
a2329 1
		SnipIn(command, "snews://%.*s", 10, cp);
d2332 1
a2332 1
		SnipIn(command, "snews://%.*s", 10, NewsHost);
d2334 1
a2334 1
	    command[sizeof(command)-2] = '\0';
d2336 3
a2338 5
	    sprintf(proxycmd, "GET %.*s%c%c%c%c",
		    (int) sizeof(proxycmd)-9, command,
		    CR, LF, CR, LF);
	    CTRACE((tfp, "HTNews: Proxy command is '%.*s'\n",
			(int)(strlen(proxycmd) - 4), proxycmd));
d2353 1
a2353 1
		**  Reset p1 so that it points to the newsgroup
d2372 1
a2372 7
	    if (strlen(p1) > 249) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    SnipIn(command, "XGTITLE %.*s", 11, p1);
d2375 1
d2380 1
a2380 7
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2383 1
a2383 1
		if ((first > 0) && (isdigit(UCH(*(slash+1)))) &&
d2396 1
a2396 7
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2398 1
a2398 1
	    SnipIn(command, "GROUP %.*s", 9, groupName);
d2400 6
a2405 13
	    int add_open=(strchr(p1, '<') == 0);
	    int add_close=(strchr(p1, '>') == 0);
	    if (strlen(p1) + add_open + add_close >= 252) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    sprintf(command, "ARTICLE %s%.*s%s",
		    add_open ? "<" : "",
		    (int) (sizeof(command) - (11 + add_open + add_close)),
		    p1,
		    add_close ? ">" : "");
d2431 1
a2431 1
	if (head_wanted && !strncmp(command, "ARTICLE ", 8)) {
d2438 1
a2438 1
	rawtext = (BOOL) (head_wanted || keep_mime_headers);
d2473 1
a2473 1
		SnipIn (url, "lose://%.*s/", 9, NewsHost);
d2475 1
a2475 1
		SnipIn (url, "%.*s", 1, ProxyHREF);
d2477 1
a2477 1
		SnipIn (url, "%.*s", 1, NewsHREF);
d2479 1
a2479 1
	    CTRACE((tfp, "News: doing HTDoConnect on '%s'\n", url));
d2499 1
a2499 1
		CTRACE((tfp, "HTNews: Interrupted on connect; recovering cleanly.\n"));
d2525 1
a2525 1
		CTRACE((tfp, "HTNews: Unable to connect to news host.\n"));
d2544 2
a2545 2
		CTRACE((tfp, "HTNews: Connected to news host %s.\n",
			    NewsHost));
a2556 1
		    HTSSLInitPRNG();
d2560 3
a2562 6
			unsigned long SSLerror;
			CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
			SSL_load_error_strings();
			while((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
			}
d2586 1
a2586 2
		    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",SSL_get_cipher_bits(Handle,NULL),SSL_get_cipher_version(Handle),SSL_get_cipher(Handle));
		    _HTProgress(SSLprogress);
d2589 1
a2589 1
		HTInitInput(s);		/* set up buffering */
d2592 2
a2593 2
		    CTRACE((tfp, "HTNews: Proxy command returned status '%d'.\n",
				status));
a2616 4
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			FREE(postfile);
d2621 1
a2621 2
			if (response_text[0]) {
			    HTSprintf0(&dbuf,
a2623 5
			} else {
			    HTSprintf0(&dbuf,
				gettext("Can't read news info, empty response from host %s"),
				NewsHost);
			}
d2668 1
a2668 2
		postfile = LYNewsPost(ListArg,
				(BOOLEAN)(reply_wanted || sreply_wanted));
a2714 6
#ifdef NEWS_DEB
	if (postfile)
	    printf("postfile = %s, command = %s", postfile, command);
	else
	    printf("command = %s", command);
#endif
d2731 1
a2731 1
	 *  some checks to see whether the response corresponds to the
d2875 4
a2878 5
#if 0
    HTAlert(gettext("Sorry, could not load requested news."));
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL,NULL,NULL, arg);
    /* No -- message earlier wil have covered it */
#endif
d2900 1
a2900 1
**  invoking the free_NNTP_AuthInfo() function, which normally
d2925 1
a2925 1
	return HTGetCharacter();
d2927 1
a2927 1
	return HTGetSSLCharacter((void *)Handle);
d2930 4
a2933 6
PUBLIC int HTNewsProxyConnect ARGS5 (
    int,		sock,
    CONST char *,	url,
    HTParentAnchor *,	anAnchor,
    HTFormat,		format_out,
    HTStream *,		sink)
a2936 1
    char SSLprogress[256];
a2940 1
    HTSSLInitPRNG();
d2944 4
a2947 7
	unsigned long SSLerror;
	channel_s = -1;
	CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
	SSL_load_error_strings();
	while((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
	}
d2953 1
a2953 5
    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle,NULL),
	    SSL_get_cipher_version(Handle),
	    SSL_get_cipher(Handle));
    _HTProgress(SSLprogress);
@

