head	1.4;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.6
	tg-mergefixes-1-branch:1.1.3.6.0.4
	tg-mergefixes-1-base:1.1.3.6
	MIROS_X:1.1.3.6.0.2
	MIROS_X_BASE:1.1.3.6
	MIRBSD_XP_MIRPPC:1.1.3.4.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.1.3.4
	MIRBSD_XP_SPARC:1.1.3.4.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.4
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.4
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.4
	cvs-200401261630:1.1.1.4
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.3
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.3
	cvs-200309251530:1.1.1.3
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;
expand	@b@;


1.4
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.55;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.11.18.09.02;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.01.26.18.02.32;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.29;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.50;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.24;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.13;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.46.59;	author tg;	state Stab;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.11.20.16.16;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.20.10.10.32;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@soft merge
@
text
@/*			MIME Message Parse			HTMIME.c
 *			==================
 *
 *	This is RFC 1341-specific code.
 *	The input stream pushed into this parser is assumed to be
 *	stripped on CRs, ie lines end with LF, not CR LF.
 *	(It is easy to change this except for the body part where
 *	conversion can be slow.)
 *
 * History:
 *	   Feb 92	Written Tim Berners-Lee, CERN
 *
 */
#include <HTUtils.h>
#include <HTMIME.h>		/* Implemented here */
#include <HTTP.h>		/* for redirecting_url */
#include <HTAlert.h>
#include <HTFile.h>
#include <HTCJK.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYCookie.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYLeaks.h>

/*		MIME Object
 *		-----------
 */

typedef enum {
    MIME_TRANSPARENT,		/* put straight through to target ASAP! */
    miBEGINNING_OF_LINE,	/* first character and not a continuation */
    miA,
    miACCEPT_RANGES,
    miAGE,
    miAL,
    miALLOW,
    miALTERNATES,
    miC,
    miCACHE_CONTROL,
    miCO,
    miCOOKIE,
    miCON,
    miCONNECTION,
    miCONTENT_,
    miCONTENT_BASE,
    miCONTENT_DISPOSITION,
    miCONTENT_ENCODING,
    miCONTENT_FEATURES,
    miCONTENT_L,
    miCONTENT_LANGUAGE,
    miCONTENT_LENGTH,
    miCONTENT_LOCATION,
    miCONTENT_MD5,
    miCONTENT_RANGE,
    miCONTENT_T,
    miCONTENT_TRANSFER_ENCODING,
    miCONTENT_TYPE,
    miDATE,
    miE,
    miETAG,
    miEXPIRES,
    miKEEP_ALIVE,
    miL,
    miLAST_MODIFIED,
    miLINK,
    miLOCATION,
    miP,
    miPR,
    miPRAGMA,
    miPROXY_AUTHENTICATE,
    miPUBLIC,
    miR,
    miRE,
    miREFRESH,
    miRETRY_AFTER,
    miS,
    miSAFE,
    miSE,
    miSERVER,
    miSET_COOKIE,
    miSET_COOKIE1,
    miSET_COOKIE2,
    miT,
    miTITLE,
    miTRANSFER_ENCODING,
    miU,
    miUPGRADE,
    miURI,
    miV,
    miVARY,
    miVIA,
    miW,
    miWARNING,
    miWWW_AUTHENTICATE,
    miSKIP_GET_VALUE,		/* Skip space then get value */
    miGET_VALUE,		/* Get value till white space */
    miJUNK_LINE,		/* Ignore the rest of this folded line */
    miNEWLINE,			/* Just found a LF .. maybe continuation */
    miCHECK,			/* check against check_pointer */
    MIME_NET_ASCII,		/* Translate from net ascii */
    MIME_IGNORE			/* Ignore entire file */
    /* TRANSPARENT and IGNORE are defined as stg else in _WINDOWS */
} MIME_state;

#define VALUE_SIZE 5120		/* @@@@@@@@@@@@@@ Arbitrary? */
struct _HTStream {
    const HTStreamClass *isa;

    BOOL net_ascii;		/* Is input net ascii? */
    MIME_state state;		/* current state */
    MIME_state if_ok;		/* got this state if match */
    MIME_state field;		/* remember which field */
    MIME_state fold_state;	/* state on a fold */
    BOOL head_only;		/* only parsing header */
    BOOL pickup_redirection;	/* parsing for location */
    BOOL no_streamstack;	/* use sink directly */
    const char *check_pointer;	/* checking input */

    char *value_pointer;	/* storing values */
    char value[VALUE_SIZE];

    HTParentAnchor *anchor;	/* Given on creation */
    HTStream *sink;		/* Given on creation */

    char *boundary;		/* For multipart */
    char *set_cookie;		/* Set-Cookie */
    char *set_cookie2;		/* Set-Cookie2 */
    char *location;		/* Location */

    char *refresh_url;		/* "Refresh:" URL */

    HTFormat encoding;		/* Content-Transfer-Encoding */
    char *compression_encoding;
    HTFormat format;		/* Content-Type */
    HTStream *target;		/* While writing out */
    HTStreamClass targetClass;

    HTAtom *targetRep;		/* Converting into? */
};

/*
 *  This function is for trimming off any paired
 *  open- and close-double quotes from header values.
 *  It does not parse the string for embedded quotes,
 *  and will not modify the string unless both the
 *  first and last characters are double-quotes. - FM
 */
void HTMIME_TrimDoubleQuotes(char *value)
{
    int i;
    char *cp = value;

    if (!(cp && *cp) || *cp != '"')
	return;

    i = strlen(cp);
    if (cp[(i - 1)] != '"')
	return;
    else
	cp[(i - 1)] = '\0';

    for (i = 0; value[i]; i++)
	value[i] = cp[(i + 1)];
}

/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.
 */
static BOOL content_is_compressed(HTStream *me)
{
    char *encoding = me->anchor->content_encoding;
    BOOL result = (HTEncodingToCompressType(encoding) != cftNone);

    CTRACE((tfp, "content is%s compressed\n", result ? "" : " NOT"));
    return result;
}

/*
 * Strip quotes from a refresh-URL.
 */
static void dequote(char *url)
{
    int len;

    len = strlen(url);
    if (*url == '\'' && len > 1 && url[len - 1] == url[0]) {
	url[len - 1] = '\0';
	while ((url[0] = url[1]) != '\0') {
	    ++url;
	}
    }
}

static int pumpData(HTStream *me)
{
    if (strchr(HTAtom_name(me->format), ';') != NULL) {
	char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;

	CTRACE((tfp, "HTMIME: Extended MIME Content-Type is %s\n",
		HTAtom_name(me->format)));
	StrAllocCopy(cp, HTAtom_name(me->format));
	/*
	 * Note that the Content-Type value was converted
	 * to lower case when we loaded into me->format,
	 * but there may have been a mixed or upper-case
	 * atom, so we'll force lower-casing again.  We
	 * also stripped spaces and double-quotes, but
	 * we'll make sure they're still gone from any
	 * charset parameter we check.  - FM
	 */
	LYLowerCase(cp);
	if ((cp1 = strchr(cp, ';')) != NULL) {
	    BOOL chartrans_ok = NO;

	    if ((cp2 = strstr(cp1, "charset")) != NULL) {
		int chndl;

		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
		    cp2++;
		StrAllocCopy(cp3, cp2);		/* copy to mutilate more */
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
				 *cp4 != ';' && *cp4 != ':' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
		*cp4 = '\0';
		cp4 = cp3;
		chndl = UCGetLYhndl_byMIME(cp3);
		if (UCCanTranslateFromTo(chndl,
					 current_char_set)) {
		    chartrans_ok = YES;
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		} else if (chndl < 0) {		/* got something but we don't
						   recognize it */
		    chndl = UCLYhndl_for_unrec;
		    if (chndl < 0)
			/*
			 * UCLYhndl_for_unrec not defined :-( fallback to
			 * UCLYhndl_for_unspec which always valid.
			 */
			chndl = UCLYhndl_for_unspec;	/* always >= 0 */
		    if (UCCanTranslateFromTo(chndl,
					     current_char_set)) {
			chartrans_ok = YES;
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
			HTAnchor_setUCInfoStage(me->anchor, chndl,
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		} else {
		    /*
		     * Something like 'big5' - we cannot translate it, but
		     * the user may still be able to navigate the links.
		     */
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		}
		if (chartrans_ok) {
		    LYUCcharset *p_in =
		    HTAnchor_getUCInfoStage(me->anchor,
					    UCT_STAGE_MIME);
		    LYUCcharset *p_out =
		    HTAnchor_setUCInfoStage(me->anchor,
					    current_char_set,
					    UCT_STAGE_HTEXT,
					    UCT_SETBY_DEFAULT);

		    if (!p_out)
			/*
			 * Try again.
			 */
			p_out =
			    HTAnchor_getUCInfoStage(me->anchor,
						    UCT_STAGE_HTEXT);

		    if (!strcmp(p_in->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_HTEXT),
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		    if (!strcmp(p_out->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_MIME),
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		    }
		    if ((p_in->enc != UCT_ENC_CJK)
#ifndef EXP_JAPANESEUTF8_SUPPORT
			&& ((p_in->enc != UCT_ENC_UTF8)
			    || (p_out->enc != UCT_ENC_CJK))
#endif
			) {
			HTCJK = NOCJK;
			if (!(p_in->codepoints &
			      UCT_CP_SUBSETOF_LAT1) &&
			    chndl == current_char_set) {
			    HTPassEightBitRaw = TRUE;
			}
		    } else if (p_out->enc == UCT_ENC_CJK) {
			Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
		    }
		} else {
		    /*
		     * Cannot translate.  If according to some heuristic the
		     * given charset and the current display character both are
		     * likely to be like ISO-8859 in structure, pretend we have
		     * some kind of match.
		     */
		    BOOL given_is_8859 =
		    (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
			    isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like =
		    (BOOL) (given_is_8859 ||
			    !strncmp(cp4, "windows-", 8) ||
			    !strncmp(cp4, "cp12", 4) ||
			    !strncmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like =
		    (BOOL) (given_is_8859like &&
			    (strstr(LYchar_set_names[current_char_set],
				    "ISO-8859") ||
			     strstr(LYchar_set_names[current_char_set],
				    "windows-")));

		    if (given_and_display_8859like) {
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
		    }
		    if (given_is_8859) {
			cp1 = &cp4[10];
			while (*cp1 &&
			       isdigit(UCH(*cp1)))
			    cp1++;
			*cp1 = '\0';
		    }
		    if (given_and_display_8859like) {
			StrAllocCopy(me->anchor->charset, cp4);
			HTPassEightBitRaw = TRUE;
		    }
		    HTAlert(*cp4 ? cp4 : me->anchor->charset);
		}
		FREE(cp3);
	    } else {
		/*
		 * No charset parameter is present.  Ignore all other
		 * parameters, as we do when charset is present.  - FM
		 */
		*cp1 = '\0';
		me->format = HTAtom_for(cp);
	    }
	}
	FREE(cp);
    }
    /*
     * If we have an Expires header and haven't already set the no_cache
     * element for the anchor, check if we should set it based on that header. 
     * - FM
     */
    if (me->anchor->no_cache == FALSE &&
	me->anchor->expires != NULL) {
	if (!strcmp(me->anchor->expires, "0")) {
	    /*
	     * The value is zero, which we treat as an absolute no-cache
	     * directive.  - FM
	     */
	    me->anchor->no_cache = TRUE;
	} else if (me->anchor->date != NULL) {
	    /*
	     * We have a Date header, so check if the value is less than or
	     * equal to that.  - FM
	     */
	    if (LYmktime(me->anchor->expires, TRUE) <=
		LYmktime(me->anchor->date, TRUE)) {
		me->anchor->no_cache = TRUE;
	    }
	} else if (LYmktime(me->anchor->expires, FALSE) == 0) {
	    /*
	     * We don't have a Date header, and the value is in past for us.  -
	     * FM
	     */
	    me->anchor->no_cache = TRUE;
	}
    }
    StrAllocCopy(me->anchor->content_type,
		 HTAtom_name(me->format));

    if (me->set_cookie != NULL || me->set_cookie2 != NULL) {
	LYSetCookie(me->set_cookie,
		    me->set_cookie2,
		    me->anchor->address);
	FREE(me->set_cookie);
	FREE(me->set_cookie2);
    }
    if (me->pickup_redirection) {
	if (me->location && *me->location) {
	    redirecting_url = me->location;
	    me->location = NULL;
	    if (me->targetRep != WWW_DEBUG || me->sink)
		me->head_only = YES;

	} else {
	    permanent_redirection = FALSE;
	    if (me->location) {
		CTRACE((tfp, "HTTP: 'Location:' is zero-length!\n"));
		HTAlert(REDIRECTION_WITH_BAD_LOCATION);
	    }
	    CTRACE((tfp, "HTTP: Failed to pick up location.\n"));
	    if (me->location) {
		FREE(me->location);
	    } else {
		HTAlert(REDIRECTION_WITH_NO_LOCATION);
	    }
	}
    }
    if (me->head_only) {
	/* We are done! - kw */
	me->state = MIME_IGNORE;
	return HT_OK;
    }

    if (me->no_streamstack) {
	me->target = me->sink;
    } else {
	if (!me->compression_encoding) {
	    CTRACE((tfp,
		    "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	} else {
	    /*
	     * Change the format to that for "www/compressed" and set up a
	     * stream to deal with it.  - FM
	     */
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format)));
	    me->format = HTAtom_for("www/compressed");
	    CTRACE((tfp, "        Treating as '%s'.  Converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	    FREE(me->compression_encoding);
	}
	me->target = HTStreamStack(me->format, me->targetRep,
				   me->sink, me->anchor);
	if (!me->target) {
	    CTRACE((tfp, "HTMIME: Can't translate! ** \n"));
	    me->target = me->sink;	/* Cheat */
	}
    }
    if (me->target) {
	me->targetClass = *me->target->isa;
	/*
	 * Check for encoding and select state from there, someday, but until
	 * we have the relevant code, from now push straight through.  - FM
	 */
	me->state = MIME_TRANSPARENT;	/* Pump rest of data right through */
    } else {
	me->state = MIME_IGNORE;	/* What else to do? */
    }
    if (me->refresh_url != NULL && !content_is_compressed(me)) {
	char *url = NULL;
	char *num = NULL;
	char *txt = NULL;
	const char *base = "";	/* FIXME: refresh_url may be relative to doc */

	LYParseRefreshURL(me->refresh_url, &num, &url);
	if (url != NULL && me->format == WWW_HTML) {
	    CTRACE((tfp, "Formatting refresh-url as first line of result\n"));
	    HTSprintf0(&txt, gettext("Refresh: "));
	    HTSprintf(&txt, gettext("%s seconds "), num);
	    dequote(url);
	    HTSprintf(&txt, "<a href=\"%s%s\">%s</a><br>", base, url, url);
	    CTRACE((tfp, "URL %s%s\n", base, url));
	    (me->isa->put_string) (me, txt);
	    free(txt);
	}
	FREE(num);
	FREE(url);
    }
    return HT_OK;
}

static int dispatchField(HTStream *me)
{
    int i, j;
    char *cp;

    *me->value_pointer = '\0';

    cp = me->value_pointer;
    while ((cp > me->value) && *(--cp) == ' ')	/* S/390 -- gil -- 0146 */
	/*
	 * Trim trailing spaces.
	 */
	*cp = '\0';

    switch (me->field) {
    case miACCEPT_RANGES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
		me->value));
	break;
    case miAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Age: '%s'\n",
		me->value));
	break;
    case miALLOW:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Allow: '%s'\n",
		me->value));
	break;
    case miALTERNATES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Alternates: '%s'\n",
		me->value));
	break;
    case miCACHE_CONTROL:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cache-Control: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->cache_control, me->value);
	/*
	 * Check whether to set no_cache for the anchor.  - FM
	 */
	{
	    char *cp1, *cp0 = me->value;

	    while ((cp1 = strstr(cp0, "no-cache")) != NULL) {
		cp1 += 8;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '\0' || *cp1 == ';') {
		    me->anchor->no_cache = TRUE;
		    break;
		}
		cp0 = cp1;
	    }
	    if (me->anchor->no_cache == TRUE)
		break;
	    cp0 = me->value;
	    while ((cp1 = strstr(cp0, "max-age")) != NULL) {
		cp1 += 7;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '=') {
		    cp1++;
		    while (*cp1 != '\0' && WHITE(*cp1))
			cp1++;
		    if (isdigit(UCH(*cp1))) {
			cp0 = cp1;
			while (isdigit(UCH(*cp1)))
			    cp1++;
			if (*cp0 == '0' && cp1 == (cp0 + 1)) {
			    me->anchor->no_cache = TRUE;
			    break;
			}
		    }
		}
		cp0 = cp1;
	    }
	}
	break;
    case miCOOKIE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cookie: '%s'\n",
		me->value));
	break;
    case miCONNECTION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Connection: '%s'\n",
		me->value));
	break;
    case miCONTENT_BASE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Base: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_base, me->value);
	break;
    case miCONTENT_DISPOSITION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Disposition: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_disposition, me->value);
	/*
	 * It's not clear yet from existing RFCs and IDs whether we should be
	 * looking for file;, attachment;, and/or inline; before the
	 * filename=value, so we'll just search for "filename" followed by '='
	 * and just hope we get the intended value.  It is purely a suggested
	 * name, anyway.  - FM
	 */
	cp = me->anchor->content_disposition;
	while (*cp != '\0' && strncasecomp(cp, "filename", 8))
	    cp++;
	if (*cp == '\0')
	    break;
	cp += 8;
	while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
	    cp++;
	if (*cp == '\0')
	    break;
	while (*cp != '\0' && WHITE(*cp))
	    cp++;
	if (*cp == '\0')
	    break;
	StrAllocCopy(me->anchor->SugFname, cp);
	if (*me->anchor->SugFname == '"') {
	    if ((cp = strchr((me->anchor->SugFname + 1),
			     '"')) != NULL) {
		*(cp + 1) = '\0';
		HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
	    } else {
		FREE(me->anchor->SugFname);
		break;
	    }
	}
	cp = me->anchor->SugFname;
	while (*cp != '\0' && !WHITE(*cp))
	    cp++;
	*cp = '\0';
	if (*me->anchor->SugFname == '\0')
	    FREE(me->anchor->SugFname);
	break;
    case miCONTENT_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value) ||
	    !strcasecomp(me->value, "identity"))
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_encoding, me->value);
	FREE(me->compression_encoding);
	if (content_is_compressed(me)) {
	    /*
	     * Save it to use as a flag for setting up a "www/compressed"
	     * target.  - FM
	     */
	    StrAllocCopy(me->compression_encoding, me->value);
	} else {
	    /*
	     * Some server indicated "8bit", "7bit" or "binary"
	     * inappropriately.  We'll ignore it.  - FM
	     */
	    CTRACE((tfp, "                Ignoring it!\n"));
	}
	break;
    case miCONTENT_FEATURES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Features: '%s'\n",
		me->value));
	break;
    case miCONTENT_LANGUAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Language: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_language, me->value);
	break;
    case miCONTENT_LENGTH:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Length: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Convert to integer and indicate in anchor.  - FM
	 */
	me->anchor->content_length = atoi(me->value);
	if (me->anchor->content_length < 0)
	    me->anchor->content_length = 0;
	CTRACE((tfp, "        Converted to integer: '%d'\n",
		me->anchor->content_length));
	break;
    case miCONTENT_LOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Location: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_location, me->value);
	break;
    case miCONTENT_MD5:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-MD5: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_md5, me->value);
	break;
    case miCONTENT_RANGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Range: '%s'\n",
		me->value));
	break;
    case miCONTENT_TRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Force the Content-Transfer-Encoding value to all lower case.  - FM
	 */
	LYLowerCase(me->value);
	me->encoding = HTAtom_for(me->value);
	break;
    case miCONTENT_TYPE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Type: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Force the Content-Type value to all lower case and strip spaces and
	 * double-quotes.  - FM
	 */
	for (i = 0, j = 0; me->value[i]; i++) {
	    if (me->value[i] != ' ' && me->value[i] != '"') {
		me->value[j++] = (char) TOLOWER(me->value[i]);
	    }
	}
	me->value[j] = '\0';
	me->format = HTAtom_for(me->value);
	StrAllocCopy(me->anchor->content_type_params, me->value);
	break;
    case miDATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Date: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->date, me->value);
	break;
    case miETAG:
	/* Do not trim double quotes:  an entity tag consists of an opaque
	 * quoted string, possibly prefixed by a weakness indicator.
	 */
	CTRACE((tfp, "HTMIME: PICKED UP ETag: %s\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->ETag, me->value);
	break;
    case miEXPIRES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Expires: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->expires, me->value);
	break;
    case miKEEP_ALIVE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Keep-Alive: '%s'\n",
		me->value));
	break;
    case miLAST_MODIFIED:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Last-Modified: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->last_modified, me->value);
	break;
    case miLINK:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Link: '%s'\n",
		me->value));
	break;
    case miLOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Location: '%s'\n",
		me->value));
	if (me->pickup_redirection && !me->location) {
	    StrAllocCopy(me->location, me->value);
	} else {
	    CTRACE((tfp, "HTMIME: *** Ignoring Location!\n"));
	}
	break;
    case miPRAGMA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Pragma: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Check whether to set no_cache for the anchor.  - FM
	 */
	if (!strcmp(me->value, "no-cache"))
	    me->anchor->no_cache = TRUE;
	break;
    case miPROXY_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
		me->value));
	break;
    case miPUBLIC:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Public: '%s'\n",
		me->value));
	break;
    case miREFRESH:		/* nonstandard: Netscape */
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Refresh: '%s'\n",
		me->value));
	StrAllocCopy(me->refresh_url, me->value);
	break;
    case miRETRY_AFTER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Retry-After: '%s'\n",
		me->value));
	break;
    case miSAFE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Safe: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor if "YES" or "TRUE".  - FM
	 */
	if (!strcasecomp(me->value, "YES") ||
	    !strcasecomp(me->value, "TRUE")) {
	    me->anchor->safe = TRUE;
	} else if (!strcasecomp(me->value, "NO") ||
		   !strcasecomp(me->value, "FALSE")) {
	    /*
	     * If server explicitly tells us that it has changed its mind,
	     * reset flag in anchor.  - kw
	     */
	    me->anchor->safe = FALSE;
	}
	break;
    case miSERVER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Server: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->server, me->value);
	break;
    case miSET_COOKIE1:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie: '%s'\n",
		me->value));
	if (me->set_cookie == NULL) {
	    StrAllocCopy(me->set_cookie, me->value);
	} else {
	    StrAllocCat(me->set_cookie, ", ");
	    StrAllocCat(me->set_cookie, me->value);
	}
	break;
    case miSET_COOKIE2:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
		me->value));
	if (me->set_cookie2 == NULL) {
	    StrAllocCopy(me->set_cookie2, me->value);
	} else {
	    StrAllocCat(me->set_cookie2, ", ");
	    StrAllocCat(me->set_cookie2, me->value);
	}
	break;
    case miTITLE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Title: '%s'\n",
		me->value));
	break;
    case miTRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
		me->value));
	break;
    case miUPGRADE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Upgrade: '%s'\n",
		me->value));
	break;
    case miURI:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP URI: '%s'\n",
		me->value));
	break;
    case miVARY:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Vary: '%s'\n",
		me->value));
	break;
    case miVIA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Via: '%s'\n",
		me->value));
	break;
    case miWARNING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Warning: '%s'\n",
		me->value));
	break;
    case miWWW_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
		me->value));
	break;
    default:			/* Should never get here */
	return HT_ERROR;
    }
    return HT_OK;
}

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 */

/*	Character handling
 *	------------------
 *
 *	This is a FSM parser. It ignores field names it does not understand.
 *	Folded header fields are recognized.  Lines without a fieldname at
 *	the beginning (that are not folded continuation lines) are ignored
 *	as unknown field names.  Fields with empty values are not picked up.
 */
static void HTMIME_put_character(HTStream *me,
				 char c)
{
    if (me->state == MIME_TRANSPARENT) {
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
	return;
    }

    /*
     * This slightly simple conversion just strips CR and turns LF to newline. 
     * On unix LF is \n but on Mac \n is CR for example.  See NetToText for an
     * implementation which preserves single CR or LF.
     */
    if (me->net_ascii) {
	/*
	 * <sigh> This is evidence that at one time, this code supported
	 * local character sets other than ASCII.  But there is so much
	 * code in HTTP.c that depends on line_buffer's having been
	 * translated to local character set that I needed to put the
	 * FROMASCII translation there, leaving this translation purely
	 * destructive.  -- gil
	 */
	/* S/390 -- gil -- 0118 */
#ifndef   NOT_ASCII
	c = FROMASCII(c);
#endif /* NOT_ASCII */
	if (c == CR)
	    return;
	else if (c == LF)
	    c = '\n';
    }

    switch (me->state) {

    case MIME_IGNORE:
	return;

    case MIME_TRANSPARENT:	/* Not reached see above */
	(*me->targetClass.put_character) (me->target, c);
	return;

    case MIME_NET_ASCII:
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
	return;

    case miNEWLINE:
	if (c != '\n' && WHITE(c)) {	/* Folded line */
	    me->state = me->fold_state;		/* pop state before newline */
	    if (me->state == miGET_VALUE &&
		me->value_pointer && me->value_pointer != me->value &&
		!WHITE(*(me->value_pointer - 1))) {
		c = ' ';
		goto GET_VALUE;	/* will add space to value if it fits - kw */
	    }
	    break;
	} else if (me->fold_state == miGET_VALUE) {
	    /* Got a field, and now we know it's complete - so
	     * act on it. - kw */
	    dispatchField(me);
	}
	/* FALLTHRU */

    case miBEGINNING_OF_LINE:
	me->net_ascii = YES;
	switch (c) {
	case 'a':
	case 'A':
	    me->state = miA;
	    CTRACE((tfp, "HTMIME: Got 'A' at beginning of line, state now A\n"));
	    break;

	case 'c':
	case 'C':
	    me->state = miC;
	    CTRACE((tfp, "HTMIME: Got 'C' at beginning of line, state now C\n"));
	    break;

	case 'd':
	case 'D':
	    me->check_pointer = "ate:";
	    me->if_ok = miDATE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->state = miE;
	    CTRACE((tfp, "HTMIME: Got 'E' at beginning of line, state now E\n"));
	    break;

	case 'k':
	case 'K':
	    me->check_pointer = "eep-alive:";
	    me->if_ok = miKEEP_ALIVE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
	    break;

	case 'l':
	case 'L':
	    me->state = miL;
	    CTRACE((tfp, "HTMIME: Got 'L' at beginning of line, state now L\n"));
	    break;

	case 'p':
	case 'P':
	    me->state = miP;
	    CTRACE((tfp, "HTMIME: Got 'P' at beginning of line, state now P\n"));
	    break;

	case 'r':
	case 'R':
	    me->state = miR;
	    CTRACE((tfp, "HTMIME: Got 'R' at beginning of line, state now R\n"));
	    break;

	case 's':
	case 'S':
	    me->state = miS;
	    CTRACE((tfp, "HTMIME: Got 'S' at beginning of line, state now S\n"));
	    break;

	case 't':
	case 'T':
	    me->state = miT;
	    CTRACE((tfp, "HTMIME: Got 'T' at beginning of line, state now T\n"));
	    break;

	case 'u':
	case 'U':
	    me->state = miU;
	    CTRACE((tfp, "HTMIME: Got 'U' at beginning of line, state now U\n"));
	    break;

	case 'v':
	case 'V':
	    me->state = miV;
	    CTRACE((tfp, "HTMIME: Got 'V' at beginning of line, state now V\n"));
	    break;

	case 'w':
	case 'W':
	    me->state = miW;
	    CTRACE((tfp, "HTMIME: Got 'W' at beginning of line, state now W\n"));
	    break;

	case '\n':		/* Blank line: End of Header! */
	    {
		me->net_ascii = NO;
		pumpData(me);
	    }
	    break;

	default:
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miA:			/* Check for 'c','g' or 'l' */
	switch (c) {
	case 'c':
	case 'C':
	    me->check_pointer = "cept-ranges:";
	    me->if_ok = miACCEPT_RANGES;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
	    break;

	case 'g':
	case 'G':
	    me->check_pointer = "e:";
	    me->if_ok = miAGE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was A, found G, checking for 'e:'\n"));
	    break;

	case 'l':
	case 'L':
	    me->state = miAL;
	    CTRACE((tfp, "HTMIME: Was A, found L, state now AL'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'g' or 'l'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miAL:			/* Check for 'l' or 't' */
	switch (c) {
	case 'l':
	case 'L':
	    me->check_pointer = "ow:";
	    me->if_ok = miALLOW;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was AL, found L, checking for 'ow:'\n"));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ernates:";
	    me->if_ok = miALTERNATES;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was AL, found T, checking for 'ernates:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'l' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miC:			/* Check for 'a' or 'o' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "che-control:";
	    me->if_ok = miCACHE_CONTROL;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was C, found A, checking for 'che-control:'\n"));
	    break;

	case 'o':
	case 'O':
	    me->state = miCO;
	    CTRACE((tfp, "HTMIME: Was C, found O, state now CO'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCO:			/* Check for 'n' or 'o' */
	switch (c) {
	case 'n':
	case 'N':
	    me->state = miCON;
	    CTRACE((tfp, "HTMIME: Was CO, found N, state now CON\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "kie:";
	    me->if_ok = miCOOKIE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CO, found O, checking for 'kie:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCON:		/* Check for 'n' or 't' */
	switch (c) {
	case 'n':
	case 'N':
	    me->check_pointer = "ection:";
	    me->if_ok = miCONNECTION;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CON, found N, checking for 'ection:'\n"));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ent-";
	    me->if_ok = miCONTENT_;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CON, found T, checking for 'ent-'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miE:			/* Check for 't' or 'x' */
	switch (c) {
	case 't':
	case 'T':
	    me->check_pointer = "ag:";
	    me->if_ok = miETAG;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was E, found T, checking for 'ag:'\n"));
	    break;

	case 'x':
	case 'X':
	    me->check_pointer = "pires:";
	    me->if_ok = miEXPIRES;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was E, found X, checking for 'pires:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'t' or 'x'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miL:			/* Check for 'a', 'i' or 'o' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "st-modified:";
	    me->if_ok = miLAST_MODIFIED;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
	    break;

	case 'i':
	case 'I':
	    me->check_pointer = "nk:";
	    me->if_ok = miLINK;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was L, found I, checking for 'nk:'\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "cation:";
	    me->if_ok = miLOCATION;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was L, found O, checking for 'cation:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a', 'i' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miP:			/* Check for 'r' or 'u' */
	switch (c) {
	case 'r':
	case 'R':
	    me->state = miPR;
	    CTRACE((tfp, "HTMIME: Was P, found R, state now PR'\n"));
	    break;

	case 'u':
	case 'U':
	    me->check_pointer = "blic:";
	    me->if_ok = miPUBLIC;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was P, found U, checking for 'blic:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 'u'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miPR:			/* Check for 'a' or 'o' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "gma:";
	    me->if_ok = miPRAGMA;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was PR, found A, checking for 'gma'\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "xy-authenticate:";
	    me->if_ok = miPROXY_AUTHENTICATE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miR:			/* Check for 'e' */
	switch (c) {
	case 'e':
	case 'E':
	    me->state = miRE;
	    CTRACE((tfp, "HTMIME: Was R, found E\n"));
	    break;
	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'e'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miRE:			/* Check for 'a' or 'o' */
	switch (c) {
	case 'f':
	case 'F':		/* nonstandard: Netscape */
	    me->check_pointer = "resh:";
	    me->if_ok = miREFRESH;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found F, checking for '%s'\n", me->check_pointer));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ry-after:";
	    me->if_ok = miRETRY_AFTER;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found T, checking for '%s'\n", me->check_pointer));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'f' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miS:			/* Check for 'a' or 'e' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "fe:";
	    me->if_ok = miSAFE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was S, found A, checking for 'fe:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->state = miSE;
	    CTRACE((tfp, "HTMIME: Was S, found E, state now SE'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'e'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miSE:			/* Check for 'r' or 't' */
	switch (c) {
	case 'r':
	case 'R':
	    me->check_pointer = "ver:";
	    me->if_ok = miSERVER;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was SE, found R, checking for 'ver'\n"));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "-cookie";
	    me->if_ok = miSET_COOKIE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was SE, found T, checking for '-cookie'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miSET_COOKIE:		/* Check for ':' or '2' */
	switch (c) {
	case ':':
	    me->field = miSET_COOKIE1;	/* remember it */
	    me->state = miSKIP_GET_VALUE;
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found :, processing\n"));
	    break;

	case '2':
	    me->check_pointer = ":";
	    me->if_ok = miSET_COOKIE2;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "':' or '2'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miT:			/* Check for 'i' or 'r' */
	switch (c) {
	case 'i':
	case 'I':
	    me->check_pointer = "tle:";
	    me->if_ok = miTITLE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was T, found I, checking for 'tle:'\n"));
	    break;

	case 'r':
	case 'R':
	    me->check_pointer = "ansfer-encoding:";
	    me->if_ok = miTRANSFER_ENCODING;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'i' or 'r'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miU:			/* Check for 'p' or 'r' */
	switch (c) {
	case 'p':
	case 'P':
	    me->check_pointer = "grade:";
	    me->if_ok = miUPGRADE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was U, found P, checking for 'grade:'\n"));
	    break;

	case 'r':
	case 'R':
	    me->check_pointer = "i:";
	    me->if_ok = miURI;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was U, found R, checking for 'i:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'p' or 'r'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miV:			/* Check for 'a' or 'i' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "ry:";
	    me->if_ok = miVARY;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was V, found A, checking for 'ry:'\n"));
	    break;

	case 'i':
	case 'I':
	    me->check_pointer = "a:";
	    me->if_ok = miVIA;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was V, found I, checking for 'a:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'i'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miW:			/* Check for 'a' or 'w' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "rning:";
	    me->if_ok = miWARNING;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was W, found A, checking for 'rning:'\n"));
	    break;

	case 'w':
	case 'W':
	    me->check_pointer = "w-authenticate:";
	    me->if_ok = miWWW_AUTHENTICATE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'w'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCHECK:		/* Check against string */
	if (TOLOWER(c) == *(me->check_pointer)++) {
	    if (!*me->check_pointer)
		me->state = me->if_ok;
	} else {		/* Error */
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, me->check_pointer - 1));
	    goto bad_field_name;
	}
	break;

    case miCONTENT_:
	CTRACE((tfp, "HTMIME: in case CONTENT_\n"));

	switch (c) {
	case 'b':
	case 'B':
	    me->check_pointer = "ase:";
	    me->if_ok = miCONTENT_BASE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
	    break;

	case 'd':
	case 'D':
	    me->check_pointer = "isposition:";
	    me->if_ok = miCONTENT_DISPOSITION;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->check_pointer = "ncoding:";
	    me->if_ok = miCONTENT_ENCODING;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
	    break;

	case 'f':
	case 'F':
	    me->check_pointer = "eatures:";
	    me->if_ok = miCONTENT_FEATURES;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
	    break;

	case 'l':
	case 'L':
	    me->state = miCONTENT_L;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
	    break;

	case 'm':
	case 'M':
	    me->check_pointer = "d5:";
	    me->if_ok = miCONTENT_MD5;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n"));
	    break;

	case 'r':
	case 'R':
	    me->check_pointer = "ange:";
	    me->if_ok = miCONTENT_RANGE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
	    break;

	case 't':
	case 'T':
	    me->state = miCONTENT_T;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
	    break;

	default:
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found nothing; bleah\n"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCONTENT_L:
	CTRACE((tfp, "HTMIME: in case CONTENT_L\n"));

	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "nguage:";
	    me->if_ok = miCONTENT_LANGUAGE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->check_pointer = "ngth:";
	    me->if_ok = miCONTENT_LENGTH;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "cation:";
	    me->if_ok = miCONTENT_LOCATION;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
	    break;

	default:
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found nothing; bleah\n"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCONTENT_T:
	CTRACE((tfp, "HTMIME: in case CONTENT_T\n"));

	switch (c) {
	case 'r':
	case 'R':
	    me->check_pointer = "ansfer-encoding:";
	    me->if_ok = miCONTENT_TRANSFER_ENCODING;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
	    break;

	case 'y':
	case 'Y':
	    me->check_pointer = "pe:";
	    me->if_ok = miCONTENT_TYPE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
	    break;

	default:
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found nothing; bleah\n"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miACCEPT_RANGES:
    case miAGE:
    case miALLOW:
    case miALTERNATES:
    case miCACHE_CONTROL:
    case miCOOKIE:
    case miCONNECTION:
    case miCONTENT_BASE:
    case miCONTENT_DISPOSITION:
    case miCONTENT_ENCODING:
    case miCONTENT_FEATURES:
    case miCONTENT_LANGUAGE:
    case miCONTENT_LENGTH:
    case miCONTENT_LOCATION:
    case miCONTENT_MD5:
    case miCONTENT_RANGE:
    case miCONTENT_TRANSFER_ENCODING:
    case miCONTENT_TYPE:
    case miDATE:
    case miETAG:
    case miEXPIRES:
    case miKEEP_ALIVE:
    case miLAST_MODIFIED:
    case miLINK:
    case miLOCATION:
    case miPRAGMA:
    case miPROXY_AUTHENTICATE:
    case miPUBLIC:
    case miREFRESH:
    case miRETRY_AFTER:
    case miSAFE:
    case miSERVER:
    case miSET_COOKIE1:
    case miSET_COOKIE2:
    case miTITLE:
    case miTRANSFER_ENCODING:
    case miUPGRADE:
    case miURI:
    case miVARY:
    case miVIA:
    case miWARNING:
    case miWWW_AUTHENTICATE:
	me->field = me->state;	/* remember it */
	me->state = miSKIP_GET_VALUE;
	/* Fall through! */

    case miSKIP_GET_VALUE:
	if (c == '\n') {
	    me->fold_state = me->state;
	    me->state = miNEWLINE;
	    break;
	}
	if (WHITE(c))
	    /*
	     * Skip white space.
	     */
	    break;

	me->value_pointer = me->value;
	me->state = miGET_VALUE;
	/* Fall through to store first character */

    case miGET_VALUE:
      GET_VALUE:
	if (c != '\n') {	/* Not end of line */
	    if (me->value_pointer < me->value + VALUE_SIZE - 1) {
		*me->value_pointer++ = c;
		break;
	    } else {
		goto value_too_long;
	    }
	}
	/* Fall through (if end of line) */

    case miJUNK_LINE:
	if (c == '\n') {
	    me->fold_state = me->state;
	    me->state = miNEWLINE;
	}
	break;

    }				/* switch on state */

#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, c);
    if (me->state == MIME_TRANSPARENT) {
	HTChunkTerminate(&me->anchor->http_headers);
	CTRACE((tfp, "Server Headers:\n%.*s\n",
		me->anchor->http_headers.size,
		me->anchor->http_headers.data));
	CTRACE((tfp, "Server Content-Type:%s\n",
		me->anchor->content_type_params));
    }
#endif
    return;

  value_too_long:
    CTRACE((tfp, "HTMIME: *** Syntax error. (string too long)\n"));

  bad_field_name:		/* Ignore it */
    me->state = miJUNK_LINE;

#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, c);
#endif

    return;

}

/*	String handling
 *	---------------
 *
 *	Strings must be smaller than this buffer size.
 */
static void HTMIME_put_string(HTStream *me,
			      const char *s)
{
    const char *p;

    if (me->state == MIME_TRANSPARENT) {	/* Optimisation */
	(*me->targetClass.put_string) (me->target, s);

    } else if (me->state != MIME_IGNORE) {
	CTRACE((tfp, "HTMIME:  %s\n", s));

	for (p = s; *p; p++)
	    HTMIME_put_character(me, *p);
    }
}

/*	Buffer write.  Buffers can (and should!) be big.
 *	------------
 */
static void HTMIME_write(HTStream *me,
			 const char *s,
			 int l)
{
    const char *p;

    if (me->state == MIME_TRANSPARENT) {	/* Optimisation */
	(*me->targetClass.put_block) (me->target, s, l);

    } else {
	CTRACE((tfp, "HTMIME:  %.*s\n", l, s));

	for (p = s; p < s + l; p++)
	    HTMIME_put_character(me, *p);
    }
}

/*	Free an HTML object
 *	-------------------
 *
 */
static void HTMIME_free(HTStream *me)
{
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._free) (me->target);
	FREE(me);
    }
}

/*	End writing
*/
static void HTMIME_abort(HTStream *me,
			 HTError e)
{
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._abort) (me->target, e);
	FREE(me);
    }
}

/*	Structured Object Class
 *	-----------------------
 */
static const HTStreamClass HTMIME =
{
    "MIMEParser",
    HTMIME_free,
    HTMIME_abort,
    HTMIME_put_character,
    HTMIME_put_string,
    HTMIME_write
};

/*	Subclass-specific Methods
 *	-------------------------
 */
HTStream *HTMIMEConvert(HTPresentation *pres,
			HTParentAnchor *anchor,
			HTStream *sink)
{
    HTStream *me;

    me = typecalloc(HTStream);

    if (me == NULL)
	outofmem(__FILE__, "HTMIMEConvert");
    me->isa = &HTMIME;
    me->sink = sink;
    me->anchor = anchor;
    me->anchor->safe = FALSE;
    me->anchor->no_cache = FALSE;
    FREE(me->anchor->cache_control);
    FREE(me->anchor->SugFname);
    FREE(me->anchor->charset);
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&me->anchor->http_headers);
    HTChunkInit(&me->anchor->http_headers, 128);
#endif
    FREE(me->anchor->content_type_params);
    FREE(me->anchor->content_language);
    FREE(me->anchor->content_encoding);
    FREE(me->anchor->content_base);
    FREE(me->anchor->content_disposition);
    FREE(me->anchor->content_location);
    FREE(me->anchor->content_md5);
    me->anchor->content_length = 0;
    FREE(me->anchor->date);
    FREE(me->anchor->expires);
    FREE(me->anchor->last_modified);
    FREE(me->anchor->ETag);
    FREE(me->anchor->server);
    me->target = NULL;
    me->state = miBEGINNING_OF_LINE;
    /*
     * Sadly enough, change this to always default to WWW_HTML to parse all
     * text as HTML for the users.
     * GAB 06-30-94
     * Thanks to Robert Rowland robert@@cyclops.pei.edu
     *
     * After discussion of the correct handline, should be application/octet-
     * stream or unknown; causing servers to send a correct content type.
     *
     * The consequence of using WWW_UNKNOWN is that you end up downloading as a
     * binary file what 99.9% of the time is an HTML file, which should have
     * been rendered or displayed.  So sadly enough, I'm changing it back to
     * WWW_HTML, and it will handle the situation like Mosaic does, and as
     * Robert Rowland suggested, because being functionally correct 99.9% of
     * the time is better than being technically correct but functionally
     * nonsensical.  - FM
     */
    /***
    me->format	  =	WWW_UNKNOWN;
    ***/
    me->format = WWW_HTML;
    me->targetRep = pres->rep_out;
    me->boundary = NULL;	/* Not set yet */
    me->set_cookie = NULL;	/* Not set yet */
    me->set_cookie2 = NULL;	/* Not set yet */
    me->refresh_url = NULL;	/* Not set yet */
    me->encoding = 0;		/* Not set yet */
    me->compression_encoding = NULL;	/* Not set yet */
    me->net_ascii = NO;		/* Local character set */
    HTAnchor_setUCInfoStage(me->anchor, current_char_set,
			    UCT_STAGE_STRUCTURED,
			    UCT_SETBY_DEFAULT);
    HTAnchor_setUCInfoStage(me->anchor, current_char_set,
			    UCT_STAGE_HTEXT,
			    UCT_SETBY_DEFAULT);
    return me;
}

HTStream *HTNetMIME(HTPresentation *pres,
		    HTParentAnchor *anchor,
		    HTStream *sink)
{
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

    if (!me)
	return NULL;

    me->net_ascii = YES;
    return me;
}

HTStream *HTMIMERedirect(HTPresentation *pres,
			 HTParentAnchor *anchor,
			 HTStream *sink)
{
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

    if (!me)
	return NULL;

    me->pickup_redirection = YES;
    if (me->targetRep == WWW_DEBUG && sink)
	me->no_streamstack = YES;
    return me;
}

/*		Japanese header handling functions
 *		==================================
 *
 *	K&Rized and added 07-Jun-96 by FM, based on:
 *
////////////////////////////////////////////////////////////////////////
 *
 *	ISO-2022-JP handling routines
 *			&
 *	MIME decode routines (quick hack just for ISO-2022-JP)
 *
 *		Thu Jan 25 10:11:42 JST 1996
 *
 *  Copyright (C) 1994, 1995, 1996
 *  Shuichi Ichikawa (ichikawa@@nuee.nagoya-u.ac.jp)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either versions 2, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with SKK, see the file COPYING.  If not, write to the Free
 *  Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *  MIME decoding routines
 *
 *	Written by S. Ichikawa,
 *	partially inspired by encdec.c of <jh@@efd.lth.se>.
 *	Assume caller's buffer is LINE_LENGTH bytes, these decode to
 *	no longer than the input strings.
 */
#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
#ifdef ESC
#undef ESC
#endif /* ESC */
#include <LYCharVals.h>		/* S/390 -- gil -- 0163 */
#define ESC	CH_ESC

static char HTmm64[] =
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static char HTmmquote[] = "0123456789ABCDEF";
static int HTmmcont = 0;

void HTmmdec_base64(char *t,
		    char *s)
{
    int d, count, j, val;
    char buf[LINE_LENGTH], *bp, nw[4], *p;

    for (bp = buf; *s; s += 4) {
	val = 0;
	if (s[2] == '=')
	    count = 1;
	else if (s[3] == '=')
	    count = 2;
	else
	    count = 3;

	for (j = 0; j <= count; j++) {
	    if (!(p = strchr(HTmm64, s[j]))) {
		return;
	    }
	    d = p - HTmm64;
	    d <<= (3 - j) * 6;
	    val += d;
	}
	for (j = 2; j >= 0; j--) {
	    nw[j] = (char) (val & 255);
	    val >>= 8;
	}
	if (count--)
	    *bp++ = nw[0];
	if (count--)
	    *bp++ = nw[1];
	if (count)
	    *bp++ = nw[2];
    }
    *bp = '\0';
    strcpy(t, buf);
}

void HTmmdec_quote(char *t,
		   char *s)
{
    char buf[LINE_LENGTH], cval, *bp, *p;

    for (bp = buf; *s;) {
	if (*s == '=') {
	    cval = 0;
	    if (s[1] && (p = strchr(HTmmquote, s[1]))) {
		cval += (char) (p - HTmmquote);
	    } else {
		*bp++ = *s++;
		continue;
	    }
	    if (s[2] && (p = strchr(HTmmquote, s[2]))) {
		cval <<= 4;
		cval += (char) (p - HTmmquote);
		*bp++ = cval;
		s += 3;
	    } else {
		*bp++ = *s++;
	    }
	} else if (*s == '_') {
	    *bp++ = 0x20;
	    s++;
	} else {
	    *bp++ = *s++;
	}
    }
    *bp = '\0';
    strcpy(t, buf);
}

/*
 *	HTmmdecode for ISO-2022-JP - FM
 */
void HTmmdecode(char *trg,
		char *str)
{
    char buf[LINE_LENGTH], mmbuf[LINE_LENGTH];
    char *s, *t, *u;
    int base64, quote;

    buf[0] = '\0';

    for (s = str, u = buf; *s;) {
	if (!strncasecomp(s, "=?ISO-2022-JP?B?", 16)) {
	    base64 = 1;
	} else {
	    base64 = 0;
	}
	if (!strncasecomp(s, "=?ISO-2022-JP?Q?", 16)) {
	    quote = 1;
	} else {
	    quote = 0;
	}
	if (base64 || quote) {
	    if (HTmmcont) {
		for (t = s - 1;
		     t >= str && (*t == ' ' || *t == '\t'); t--) {
		    u--;
		}
	    }
	    for (s += 16, t = mmbuf; *s;) {
		if (s[0] == '?' && s[1] == '=') {
		    break;
		} else {
		    *t++ = *s++;
		}
	    }
	    if (s[0] != '?' || s[1] != '=') {
		goto end;
	    } else {
		s += 2;
		*t = '\0';
	    }
	    if (base64)
		HTmmdec_base64(mmbuf, mmbuf);
	    if (quote)
		HTmmdec_quote(mmbuf, mmbuf);
	    for (t = mmbuf; *t;)
		*u++ = *t++;
	    HTmmcont = 1;
	    /* if (*s == ' ' || *s == '\t') *u++ = *s; */
	    /* for ( ; *s == ' ' || *s == '\t'; s++) ; */
	} else {
	    if (*s != ' ' && *s != '\t')
		HTmmcont = 0;
	    *u++ = *s++;
	}
    }
    *u = '\0';
  end:
    strcpy(trg, buf);
}

/*
 *  Insert ESC where it seems lost.
 *  (The author of this function "rjis" is S. Ichikawa.)
 */
int HTrjis(char *t,
	   char *s)
{
    char *p, buf[LINE_LENGTH];
    int kanji = 0;

    if (strchr(s, ESC) || !strchr(s, '$')) {
	if (s != t)
	    strcpy(t, s);
	return 1;
    }
    for (p = buf; *s;) {
	if (!kanji && s[0] == '$' && (s[1] == '@@' || s[1] == 'B')) {
	    if (HTmaybekanji((int) s[2], (int) s[3])) {
		kanji = 1;
		*p++ = ESC;
		*p++ = *s++;
		*p++ = *s++;
		*p++ = *s++;
		*p++ = *s++;
		continue;
	    }
	    *p++ = *s++;
	    continue;
	}
	if (kanji && s[0] == '(' && (s[1] == 'J' || s[1] == 'B')) {
	    kanji = 0;
	    *p++ = ESC;
	    *p++ = *s++;
	    *p++ = *s++;
	    continue;
	}
	*p++ = *s++;
    }
    *p = *s;			/* terminate string */

    strcpy(t, buf);
    return 0;
}

/*
 *  The following function "maybekanji" is derived from
 *  RJIS-1.0 by Mr. Hironobu Takahashi.
 *  Maybekanji() is included here under the courtesy of the author.
 *  The original comment of rjis.c is also included here.
 */
/*
 * RJIS ( Recover JIS code from broken file )
 * $Header: rjis.c,v 0.2 92/09/04 takahasi Exp $
 * Copyright (C) 1992 1994
 * Hironobu Takahashi (takahasi@@tiny.or.jp)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either versions 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SKK, see the file COPYING.  If not, write to the Free
 * Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

int HTmaybekanji(int c1,
		 int c2)
{

    if ((c2 < 33) || (c2 > 126))
	return 0;
    if ((c1 < 33) || ((40 < c1) && (c1 < 48)) || (116 < c1))
	return 0;
    c2 -= 32;
    switch (c1 - 32) {
    case 2:
	if ((14 < c2) && (c2 < 26))
	    return 0;
	if ((33 < c2) && (c2 < 42))
	    return 0;
	if ((48 < c2) && (c2 < 60))
	    return 0;
	if ((74 < c2) && (c2 < 82))
	    return 0;
	if ((89 < c2) && (c2 < 94))
	    return 0;
	break;
    case 3:
	if (c2 < 16)
	    return 0;
	if ((25 < c2) && (c2 < 33))
	    return 0;
	if ((58 < c2) && (c2 < 65))
	    return 0;
	if (90 < c2)
	    return 0;
	break;
    case 4:
	if (83 < c2)
	    return 0;
	break;
    case 5:
	if (86 < c2)
	    return 0;
	break;
    case 6:
	if ((24 < c2) && (c2 < 33))
	    return 0;
	if (56 < c2)
	    return 0;
	break;
    case 7:
	if ((33 < c2) && (c2 < 49))
	    return 0;
	if (81 < c2)
	    return 0;
	break;
    case 8:
	if (32 < c2)
	    return 0;
	break;
    case 47:
	if (51 < c2)
	    return 0;
	break;
    case 84:
	if (6 < c2)
	    return 0;
	break;
    }
    return 1;
}
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d2 12
a13 12
**			==================
**
**	This is RFC 1341-specific code.
**	The input stream pushed into this parser is assumed to be
**	stripped on CRs, ie lines end with LF, not CR LF.
**	(It is easy to change this except for the body part where
**	conversion can be slow.)
**
** History:
**	   Feb 92	Written Tim Berners-Lee, CERN
**
*/
d18 1
d32 2
a33 2
**		-----------
*/
d36 73
a108 73
	MIME_TRANSPARENT,	/* put straight through to target ASAP! */
	miBEGINNING_OF_LINE,	/* first character and not a continuation */
	miA,
	miACCEPT_RANGES,
	miAGE,
	miAL,
	miALLOW,
	miALTERNATES,
	miC,
	miCACHE_CONTROL,
	miCO,
	miCOOKIE,
	miCON,
	miCONNECTION,
	miCONTENT_,
	miCONTENT_BASE,
	miCONTENT_DISPOSITION,
	miCONTENT_ENCODING,
	miCONTENT_FEATURES,
	miCONTENT_L,
	miCONTENT_LANGUAGE,
	miCONTENT_LENGTH,
	miCONTENT_LOCATION,
	miCONTENT_MD5,
	miCONTENT_RANGE,
	miCONTENT_T,
	miCONTENT_TRANSFER_ENCODING,
	miCONTENT_TYPE,
	miDATE,
	miE,
	miETAG,
	miEXPIRES,
	miKEEP_ALIVE,
	miL,
	miLAST_MODIFIED,
	miLINK,
	miLOCATION,
	miP,
	miPR,
	miPRAGMA,
	miPROXY_AUTHENTICATE,
	miPUBLIC,
	miR,
	miRE,
	miREFRESH,
	miRETRY_AFTER,
	miS,
	miSAFE,
	miSE,
	miSERVER,
	miSET_COOKIE,
	miSET_COOKIE1,
	miSET_COOKIE2,
	miT,
	miTITLE,
	miTRANSFER_ENCODING,
	miU,
	miUPGRADE,
	miURI,
	miV,
	miVARY,
	miVIA,
	miW,
	miWARNING,
	miWWW_AUTHENTICATE,
	miSKIP_GET_VALUE,	/* Skip space then get value */
	miGET_VALUE,		/* Get value till white space */
	miJUNK_LINE,		/* Ignore the rest of this folded line */
	miNEWLINE,		/* Just found a LF .. maybe continuation */
	miCHECK,		/* check against check_pointer */
	MIME_NET_ASCII,		/* Translate from net ascii */
	MIME_IGNORE		/* Ignore entire file */
	/* TRANSPARENT and IGNORE are defined as stg else in _WINDOWS */
d113 1
a113 1
	CONST HTStreamClass *	isa;
d115 28
a142 28
	BOOL			net_ascii;	/* Is input net ascii? */
	MIME_state		state;		/* current state */
	MIME_state		if_ok;		/* got this state if match */
	MIME_state		field;		/* remember which field */
	MIME_state		fold_state;	/* state on a fold */
	BOOL			head_only;	/* only parsing header */
	BOOL			pickup_redirection; /* parsing for location */
	BOOL			no_streamstack; /* use sink directly */
	CONST char *		check_pointer;	/* checking input */

	char *			value_pointer;	/* storing values */
	char			value[VALUE_SIZE];

	HTParentAnchor *	anchor;		/* Given on creation */
	HTStream *		sink;		/* Given on creation */

	char *			boundary;	/* For multipart */
	char *			set_cookie;	/* Set-Cookie */
	char *			set_cookie2;	/* Set-Cookie2 */
	char *			location;	/* Location */

	char *			refresh_url;	/* "Refresh:" URL */

	HTFormat		encoding;	/* Content-Transfer-Encoding */
	char *			compression_encoding;
	HTFormat		format;		/* Content-Type */
	HTStream *		target;		/* While writing out */
	HTStreamClass		targetClass;
d144 1
a144 1
	HTAtom *		targetRep;	/* Converting into? */
d148 7
a154 8
**  This function is for trimming off any paired
**  open- and close-double quotes from header values.
**  It does not parse the string for embedded quotes,
**  and will not modify the string unless both the
**  first and last characters are double-quotes. - FM
*/
PUBLIC void HTMIME_TrimDoubleQuotes ARGS1(
	char *,		value)
d159 1
a159 1
    if (!(cp && *cp) || *cp != '\"')
d163 1
a163 1
    if (cp[(i - 1)] != '\"')
d169 1
a169 1
	value[i] = cp[(i +1)];
d172 5
a176 1
PRIVATE BOOL content_is_compressed ARGS1(HTStream *, me)
d179 1
d181 2
a182 4
    return encoding != 0
        && strcmp(encoding, "8bit") != 0
	&& strcmp(encoding, "7bit") != 0
	&& strcmp(encoding, "binary") != 0;
d186 1
a186 1
 * Strip parameters and quotes from a URL.
d188 1
a188 1
PRIVATE void dequote ARGS1(char *, url)
a189 1
    char *p;
a191 2
    if ((p = strchr(url, '?')) != NULL)
	*p = '\0';
d193 2
a194 2
    if (*url == '\'' && len > 1 && url[len-1] == url[0]) {
	url[len-1] = '\0';
d201 1
a201 1
PRIVATE int pumpData ARGS1(HTStream *, me)
d210 8
a217 8
	** Note that the Content-Type value was converted
	** to lower case when we loaded into me->format,
	** but there may have been a mixed or upper-case
	** atom, so we'll force lower-casing again.  We
	** also stripped spaces and double-quotes, but
	** we'll make sure they're still gone from any
	** charset parameter we check.  - FM
	*/
d221 1
d226 1
a226 1
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
d228 4
a231 5
		StrAllocCopy(cp3, cp2); /* copy to mutilate more */
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '\"' &&
				 *cp4 != ';'  && *cp4 != ':' &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
d244 2
a245 3
		}
		else if (chndl < 0) {/* got something but we don't
					recognize it */
d249 4
a252 5
			**  UCLYhndl_for_unrec not defined :-(
			**  fallback to UCLYhndl_for_unspec
			**  which always valid.
			*/
			chndl = UCLYhndl_for_unspec;  /* always >= 0 */
d262 11
d275 9
a283 8
		    LYUCcharset * p_in =
			HTAnchor_getUCInfoStage(me->anchor,
						UCT_STAGE_MIME);
		    LYUCcharset * p_out =
			HTAnchor_setUCInfoStage(me->anchor,
						current_char_set,
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
d286 2
a287 2
			**	Try again.
			*/
d310 6
a315 1
		    if (p_in->enc != UCT_ENC_CJK) {
d327 19
a345 21
		    **  Cannot translate.
		    **  If according to some heuristic the given
		    **  charset and the current display character
		    **  both are likely to be like ISO-8859 in
		    **  structure, pretend we have some kind
		    **  of match.
		    */
		    BOOL given_is_8859
			= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
				  isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like
			= (BOOL) (given_is_8859 ||
				  !strncmp(cp4, "windows-", 8) ||
				  !strncmp(cp4, "cp12", 4) ||
				  !strncmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like
			= (BOOL) (given_is_8859like &&
				  (strstr(LYchar_set_names[current_char_set],
					  "ISO-8859") ||
				   strstr(LYchar_set_names[current_char_set],
					  "windows-")));
d367 3
a369 4
		**	No charset parameter is present.
		**	Ignore all other parameters, as
		**	we do when charset is present. - FM
		*/
d377 4
a380 5
    **  If we have an Expires header and haven't
    **  already set the no_cache element for the
    **  anchor, check if we should set it based
    **  on that header. - FM
    */
d385 2
a386 2
	     *  The value is zero, which we treat as
	     *  an absolute no-cache directive. - FM
d391 3
a393 4
	    **  We have a Date header, so check if
	    **  the value is less than or equal to
	    **  that. - FM
	    */
d400 3
a402 3
	    **  We don't have a Date header, and
	    **  the value is in past for us. - FM
	    */
d447 2
a448 1
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
d452 3
a454 3
	    **	Change the format to that for "www/compressed"
	    **	and set up a stream to deal with it. - FM
	    */
d462 1
a462 1
				   me->sink , me->anchor);
d471 3
a473 4
	**	Check for encoding and select state from there,
	**	someday, but until we have the relevant code,
	**	from now push straight through. - FM
	*/
d482 1
a482 1
	char *base = "";	/* FIXME: refresh_url may be relative to doc */
d485 1
a485 1
	if (url != NULL) {
d492 1
a492 1
	    (me->isa->put_string)(me, txt);
d501 1
a501 1
PRIVATE int dispatchField ARGS1(HTStream *, me)
d507 1
d509 1
a509 1
    while ((cp > me->value) && *(--cp) == ' ')  /* S/390 -- gil -- 0146 */
d511 2
a512 2
	**  Trim trailing spaces.
	*/
d543 2
a544 2
	**  Convert to lowercase and indicate in anchor. - FM
	*/
d548 2
a549 2
	**  Check whether to set no_cache for the anchor. - FM
	*/
d605 2
a606 2
	**  Indicate in anchor. - FM
	*/
d616 2
a617 2
	**  Indicate in anchor. - FM
	*/
d620 6
a625 7
	**  It's not clear yet from existing RFCs and IDs
	**  whether we should be looking for file;, attachment;,
	**  and/or inline; before the filename=value, so we'll
	**  just search for "filename" followed by '=' and just
	**  hope we get the intended value.  It is purely a
	**  suggested name, anyway. - FM
	*/
d641 1
a641 1
	if (*me->anchor->SugFname == '\"') {
d643 1
a643 1
			     '\"')) != NULL) {
d666 2
a667 2
	**  Convert to lowercase and indicate in anchor. - FM
	*/
d673 3
a675 3
	    **	Save it to use as a flag for setting
	    **	up a "www/compressed" target. - FM
	    */
d679 3
a681 3
	    **	Some server indicated "8bit", "7bit" or "binary"
	    **	inappropriately.  We'll ignore it. - FM
	    */
d697 2
a698 2
	**  Convert to lowercase and indicate in anchor. - FM
	*/
d709 2
a710 2
	**  Convert to integer and indicate in anchor. - FM
	*/
d724 2
a725 2
	**  Indicate in anchor. - FM
	*/
d735 2
a736 2
	**  Indicate in anchor. - FM
	*/
d751 2
a752 3
	**  Force the Content-Transfer-Encoding value
	**  to all lower case. - FM
	*/
d763 3
a765 3
	**  Force the Content-Type value to all lower case
	**  and strip spaces and double-quotes. - FM
	*/
d767 1
a767 1
	    if (me->value[i] != ' ' && me->value[i] != '\"') {
d773 1
d782 2
a783 2
	**  Indicate in anchor. - FM
	*/
d787 2
a788 3
	/*  Do not trim double quotes:
	 *  an entity tag consists of an opaque quoted string,
	 *  possibly prefixed by a weakness indicator.
d795 2
a796 2
	**  Indicate in anchor. - FM
	*/
d806 2
a807 2
	**  Indicate in anchor. - FM
	*/
d822 2
a823 2
	**  Indicate in anchor. - FM
	*/
d848 2
a849 2
	**  Check whether to set no_cache for the anchor. - FM
	*/
d881 2
a882 2
	**  Indicate in anchor if "YES" or "TRUE". - FM
	*/
d889 3
a891 3
	    **  If server explicitly tells us that it has changed
	    **  its mind, reset flag in anchor. - kw
	    */
d902 2
a903 2
	**  Indicate in anchor. - FM
	*/
d968 1
a968 1
    default:		/* Should never get here */
a973 1

d975 3
a977 3
**
**			A C T I O N	R O U T I N E S
*/
d980 9
a988 10
**	------------------
**
**	This is a FSM parser. It ignores field names it does not understand.
**	Folded header fields are recognized.  Lines without a fieldname at
**	the beginning (that are not folded continuation lines) are ignored
**	as unknown field names.  Fields with empty values are not picked up.
*/
PRIVATE void HTMIME_put_character ARGS2(
	HTStream *,	me,
	char,		c)
d991 1
a991 1
	(*me->targetClass.put_character)(me->target, c);/* MUST BE FAST */
d996 4
a999 4
    **	This slightly simple conversion just strips CR and turns LF to
    **	newline.  On unix LF is \n but on Mac \n is CR for example.
    **	See NetToText for an implementation which preserves single CR or LF.
    */
d1002 8
a1009 7
	** <sigh> This is evidence that at one time, this code supported
	** local character sets other than ASCII.  But there is so much
	** code in HTTP.c that depends on line_buffer's having been
	** translated to local character set that I needed to put the
	** FROMASCII translation there, leaving this translation purely
	** destructive.  -- gil
	*/  /* S/390 -- gil -- 0118 */
d1019 1
a1019 1
    switch(me->state) {
d1024 2
a1025 2
    case MIME_TRANSPARENT:		/* Not reached see above */
	(*me->targetClass.put_character)(me->target, c);
d1029 1
a1029 1
	(*me->targetClass.put_character)(me->target, c); /* MUST BE FAST */
d1033 2
a1034 2
	if (c != '\n' && WHITE(c)) {		/* Folded line */
	    me->state = me->fold_state; /* pop state before newline */
d1037 1
a1037 1
		!WHITE(*(me->value_pointer-1))) {
d1069 2
a1070 1
	    CTRACE((tfp, "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
d1084 2
a1085 1
	    CTRACE((tfp, "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
d1136 1
a1136 1
	case '\n':			/* Blank line: End of Header! */
d1144 1
a1144 1
	   goto bad_field_name;
d1146 1
a1146 1
	} /* switch on character */
d1149 1
a1149 1
    case miA:				/* Check for 'c','g' or 'l' */
d1156 2
a1157 1
	    CTRACE((tfp, "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
d1175 3
a1177 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'g' or 'l'"));
d1180 1
a1180 1
	} /* switch on character */
d1183 1
a1183 1
    case miAL:				/* Check for 'l' or 't' */
d1202 3
a1204 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'l' or 't'"));
d1207 1
a1207 1
	} /* switch on character */
d1210 1
a1210 1
    case miC:				/* Check for 'a' or 'o' */
d1217 2
a1218 1
	    CTRACE((tfp, "HTMIME: Was C, found A, checking for 'che-control:'\n"));
d1228 3
a1230 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
d1233 1
a1233 1
	} /* switch on character */
d1236 1
a1236 1
    case miCO:				/* Check for 'n' or 'o' */
d1253 3
a1255 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 'o'"));
d1258 1
a1258 1
	} /* switch on character */
d1261 1
a1261 1
    case miCON:				/* Check for 'n' or 't' */
d1280 3
a1282 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 't'"));
d1285 1
a1285 1
	} /* switch on character */
d1288 1
a1288 1
    case miE:				/* Check for 't' or 'x' */
d1307 3
a1309 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'t' or 'x'"));
d1312 1
a1312 1
	} /* switch on character */
d1315 1
a1315 1
    case miL:				/* Check for 'a', 'i' or 'o' */
d1322 2
a1323 1
	    CTRACE((tfp, "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
d1343 3
a1345 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a', 'i' or 'o'"));
d1348 1
a1348 1
	} /* switch on character */
d1351 1
a1351 1
    case miP:				/* Check for 'r' or 'u' */
d1368 3
a1370 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 'u'"));
d1373 1
a1373 1
	} /* switch on character */
d1376 1
a1376 1
    case miPR:				/* Check for 'a' or 'o' */
d1391 2
a1392 1
	    CTRACE((tfp, "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
d1396 3
a1398 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
d1401 1
a1401 1
	} /* switch on character */
d1404 1
a1404 1
    case miR:				/* Check for 'e' */
d1412 3
a1414 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'e'"));
d1417 1
a1417 1
	} /* switch on character */
d1420 1
a1420 1
    case miRE:				/* Check for 'a' or 'o' */
d1423 1
a1423 1
	case 'F':			/* nonstandard: Netscape */
d1439 3
a1441 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'f' or 't'"));
d1444 1
a1444 1
	} /* switch on character */
d1447 1
a1447 1
    case miS:				/* Check for 'a' or 'e' */
d1464 3
a1466 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'e'"));
d1469 1
a1469 1
	} /* switch on character */
d1472 1
a1472 1
    case miSE:				/* Check for 'r' or 't' */
d1491 3
a1493 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 't'"));
d1496 1
a1496 1
	} /* switch on character */
d1499 1
a1499 1
    case miSET_COOKIE:			/* Check for ':' or '2' */
d1502 1
a1502 1
	    me->field = miSET_COOKIE1;		/* remember it */
d1515 3
a1517 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "':' or '2'"));
d1520 1
a1520 1
	} /* switch on character */
d1523 1
a1523 1
    case miT:				/* Check for 'i' or 'r' */
d1538 2
a1539 1
	    CTRACE((tfp, "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
d1543 3
a1545 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'i' or 'r'"));
d1548 1
a1548 1
	} /* switch on character */
d1551 1
a1551 1
    case miU:				/* Check for 'p' or 'r' */
d1570 3
a1572 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'p' or 'r'"));
d1575 1
a1575 1
	} /* switch on character */
d1578 1
a1578 1
    case miV:				/* Check for 'a' or 'i' */
d1597 3
a1599 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'i'"));
d1602 1
a1602 1
	} /* switch on character */
d1605 1
a1605 1
    case miW:				/* Check for 'a' or 'w' */
d1620 2
a1621 1
	    CTRACE((tfp, "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
d1625 3
a1627 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'w'"));
d1630 1
a1630 1
	} /* switch on character */
d1633 1
a1633 1
    case miCHECK:			/* Check against string */
d1638 3
a1640 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, me->check_pointer - 1));
d1648 1
a1648 1
	switch(c) {
d1654 2
a1655 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
d1663 2
a1664 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
d1672 2
a1673 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
d1681 2
a1682 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
d1688 2
a1689 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
d1705 2
a1706 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
d1712 2
a1713 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
d1720 1
a1720 1
	} /* switch on character */
d1726 1
a1726 1
      switch(c) {
d1732 2
a1733 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
d1741 2
a1742 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
d1750 2
a1751 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
d1758 1
a1758 1
	} /* switch on character */
d1764 1
a1764 1
      switch(c) {
d1770 2
a1771 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
d1779 2
a1780 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
d1787 1
a1787 1
	} /* switch on character */
d1832 1
a1832 1
	me->field = me->state;		/* remember it */
d1844 2
a1845 2
	    **	Skip white space.
	    */
d1853 2
a1854 2
    GET_VALUE:
	if (c != '\n') {			/* Not end of line */
d1871 1
d1873 11
a1883 2
    } /* switch on state*/

d1886 1
a1886 1
value_too_long:
d1889 1
a1889 1
bad_field_name:				/* Ignore it */
d1891 5
a1899 2


d1901 6
a1906 7
**	---------------
**
**	Strings must be smaller than this buffer size.
*/
PRIVATE void HTMIME_put_string ARGS2(
	HTStream *,	me,
	CONST char *,	s)
d1908 1
a1908 1
    CONST char * p;
d1911 1
a1911 1
	(*me->targetClass.put_string)(me->target,s);
d1916 1
a1916 1
	for (p=s; *p; p++)
a1920 1

d1922 5
a1926 6
**	------------
*/
PRIVATE void HTMIME_write ARGS3(
	HTStream *,	me,
	CONST char *,	s,
	int,		l)
d1928 1
a1928 1
    CONST char * p;
d1931 1
a1931 1
	(*me->targetClass.put_block)(me->target, s, l);
d1936 1
a1936 1
	for (p = s; p < s+l; p++)
a1940 1

d1942 4
a1945 5
**	-------------------
**
*/
PRIVATE void HTMIME_free ARGS1(
	HTStream *,	me)
d1951 1
a1951 1
	    (*me->targetClass._free)(me->target);
d1958 2
a1959 3
PRIVATE void HTMIME_abort ARGS2(
	HTStream *,	me,
	HTError,	e)
d1965 1
a1965 1
	    (*me->targetClass._abort)(me->target, e);
a1969 1

d1971 3
a1973 3
**	-----------------------
*/
PRIVATE CONST HTStreamClass HTMIME =
d1975 6
a1980 6
	"MIMEParser",
	HTMIME_free,
	HTMIME_abort,
	HTMIME_put_character,
	HTMIME_put_string,
	HTMIME_write
a1982 1

d1984 5
a1988 6
**	-------------------------
*/
PUBLIC HTStream* HTMIMEConvert ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d1990 1
a1990 1
    HTStream* me;
d1993 1
d1996 3
a1998 3
    me->isa	=	&HTMIME;
    me->sink	=	sink;
    me->anchor	=	anchor;
d2004 5
d2021 2
a2022 2
    me->target	=	NULL;
    me->state	=	miBEGINNING_OF_LINE;
d2024 4
a2027 4
     *	Sadly enough, change this to always default to WWW_HTML
     *	to parse all text as HTML for the users.
     *	GAB 06-30-94
     *	Thanks to Robert Rowland robert@@cyclops.pei.edu
d2029 2
a2030 3
     *	After discussion of the correct handline, should be application/octet-
     *		stream or unknown; causing servers to send a correct content
     *		type.
d2032 9
a2040 8
     *	The consequence of using WWW_UNKNOWN is that you end up downloading
     *	as a binary file what 99.9% of the time is an HTML file, which should
     *	have been rendered or displayed.  So sadly enough, I'm changing it
     *	back to WWW_HTML, and it will handle the situation like Mosaic does,
     *	and as Robert Rowland suggested, because being functionally correct
     *	99.9% of the time is better than being technically correct but
     *	functionally nonsensical. - FM
     *//***
d2042 8
a2049 8
	***/
    me->format	  =	WWW_HTML;
    me->targetRep =	pres->rep_out;
    me->boundary  =	NULL;		/* Not set yet */
    me->set_cookie =	NULL;		/* Not set yet */
    me->set_cookie2 =	NULL;		/* Not set yet */
    me->refresh_url =	NULL;		/* Not set yet */
    me->encoding  =	0;		/* Not set yet */
d2051 1
a2051 1
    me->net_ascii =	NO;		/* Local character set */
d2061 3
a2063 4
PUBLIC HTStream* HTNetMIME ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d2065 2
a2066 1
    HTStream* me = HTMIMEConvert(pres,anchor, sink);
d2074 3
a2076 4
PUBLIC HTStream* HTMIMERedirect ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d2078 2
a2079 1
    HTStream* me = HTMIMEConvert(pres,anchor, sink);
d2090 4
a2093 4
**		==================================
**
**	K&Rized and added 07-Jun-96 by FM, based on:
**
d2095 24
a2118 24
**
**	ISO-2022-JP handling routines
**			&
**	MIME decode routines (quick hack just for ISO-2022-JP)
**
**		Thu Jan 25 10:11:42 JST 1996
**
**  Copyright (C) 1994, 1995, 1996
**  Shuichi Ichikawa (ichikawa@@nuee.nagoya-u.ac.jp)
**
**  This program is free software; you can redistribute it and/or modify
**  it under the terms of the GNU General Public License as published by
**  the Free Software Foundation; either versions 2, or (at your option)
**  any later version.
**
**  This program is distributed in the hope that it will be useful
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**  GNU General Public License for more details.
**
**  You should have received a copy of the GNU General Public License
**  along with SKK, see the file COPYING.  If not, write to the Free
**  Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/
d2121 7
a2127 7
**  MIME decoding routines
**
**	Written by S. Ichikawa,
**	partially inspired by encdec.c of <jh@@efd.lth.se>.
**	Assume caller's buffer is LINE_LENGTH bytes, these decode to
**	no longer than the input strings.
*/
d2132 1
a2132 1
#include <LYCharVals.h>  /* S/390 -- gil -- 0163 */
d2135 7
a2141 8
PRIVATE char HTmm64[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" ;
PRIVATE char HTmmquote[] = "0123456789ABCDEF";
PRIVATE int HTmmcont = 0;

PUBLIC void HTmmdec_base64 ARGS2(
	char *,		t,
	char *,		s)
d2143 2
a2144 2
    int   d, count, j, val;
    char  buf[LINE_LENGTH], *bp, nw[4], *p;
d2156 6
a2161 6
		if (!(p = strchr(HTmm64, s[j]))) {
			return;
		}
		d = p - HTmm64;
		d <<= (3-j)*6;
		val += d;
d2164 2
a2165 2
		nw[j] = (char) (val & 255);
		val >>= 8;
d2178 2
a2179 3
PUBLIC void HTmmdec_quote ARGS2(
	char *,		t,
	char *,		s)
d2181 1
a2181 1
    char  buf[LINE_LENGTH], cval, *bp, *p;
d2183 1
a2183 1
    for (bp = buf; *s; ) {
d2212 4
a2215 5
**	HTmmdecode for ISO-2022-JP - FM
*/
PUBLIC void HTmmdecode ARGS2(
	char *,		trg,
	char *,		str)
d2219 1
a2219 1
    int  base64, quote;
d2223 1
a2223 1
    for (s = str, u = buf; *s; ) {
d2237 2
a2238 2
		    t >= str && (*t == ' ' || *t == '\t'); t--) {
			u--;
d2241 1
a2241 1
	    for (s += 16, t = mmbuf; *s; ) {
d2258 1
a2258 1
	    for (t = mmbuf; *t; )
d2270 1
a2270 1
end:
d2275 5
a2279 6
**  Insert ESC where it seems lost.
**  (The author of this function "rjis" is S. Ichikawa.)
*/
PUBLIC int HTrjis ARGS2(
	char *,		t,
	char *,		s)
d2289 1
a2289 1
    for (p = buf; *s; ) {
d2291 1
a2291 1
	    if (HTmaybekanji((int)s[2], (int)s[3])) {
d2312 1
a2312 1
    *p = *s;	/* terminate string */
d2319 5
a2323 5
**  The following function "maybekanji" is derived from
**  RJIS-1.0 by Mr. Hironobu Takahashi.
**  Maybekanji() is included here under the courtesy of the author.
**  The original comment of rjis.c is also included here.
*/
d2345 2
a2346 3
PUBLIC int HTmaybekanji ARGS2(
	int,		c1,
	int,		c2)
d2354 3
a2356 3
    switch(c1-32) {
      case 2:
	if ((14 < c2) && ( c2 < 26))
d2358 1
a2358 1
	if ((33 < c2) && ( c2 < 42))
d2360 1
a2360 1
	if ((48 < c2) && ( c2 < 60))
d2362 1
a2362 1
	if ((74 < c2) && ( c2 < 82))
d2364 1
a2364 1
	if ((89 < c2) && ( c2 < 94))
d2367 1
a2367 1
      case 3:
d2370 1
a2370 1
	if ((25 < c2) && ( c2 < 33))
d2372 1
a2372 1
	if ((58 < c2) && ( c2 < 65))
d2377 1
a2377 1
      case 4:
d2381 1
a2381 1
      case 5:
d2385 2
a2386 2
      case 6:
	if ((24 < c2) && ( c2 < 33))
d2391 2
a2392 2
      case 7:
	if ((33 < c2) && ( c2 < 49))
d2397 1
a2397 1
      case 8:
d2401 1
a2401 1
      case 47:
d2405 1
a2405 1
      case 84:
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d16 1
d25 1
a29 3
extern BOOL HTPassEightBitRaw;
extern HTCJKlang HTCJK;

d34 1
a34 1
typedef enum _MIME_state {
d77 3
d105 1
a105 1
	MIME_NET_ASCII, 	/* Translate from net ascii */
d110 1
a110 1
#define VALUE_SIZE 5120 	/* @@@@@@@@@@@@@@ Arbitrary? */
d119 3
d127 1
a127 1
	HTParentAnchor *	anchor; 	/* Given on creation */
d133 3
d139 2
a140 2
	HTFormat		format; 	/* Content-Type */
	HTStream *		target; 	/* While writing out */
d154 1
a154 1
	char *, 	value)
d172 794
d974 4
a977 3
**	This is a FSM parser which is tolerant as it can be of all
**	syntax errors.	It ignores field names it does not understand,
**	and resynchronises on line beginnings.
a982 2
    int i, j;

d1027 6
d1034 4
d1039 1
a1039 2

	/*	else Falls through */
d1047 1
a1047 1
	    CTRACE(tfp, "HTMIME: Got 'A' at beginning of line, state now A\n");
d1053 1
a1053 1
	    CTRACE (tfp, "HTMIME: Got 'C' at beginning of line, state now C\n");
d1061 1
a1061 1
	    CTRACE (tfp, "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n");
d1067 1
a1067 1
	    CTRACE (tfp, "HTMIME: Got 'E' at beginning of line, state now E\n");
d1075 1
a1075 1
	    CTRACE(tfp, "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n");
d1081 1
a1081 1
	    CTRACE (tfp, "HTMIME: Got 'L' at beginning of line, state now L\n");
d1087 1
a1087 1
	    CTRACE (tfp, "HTMIME: Got 'P' at beginning of line, state now P\n");
d1092 2
a1093 4
	    me->check_pointer = "etry-after:";
	    me->if_ok = miRETRY_AFTER;
	    me->state = miCHECK;
	    CTRACE(tfp, "HTMIME: Got 'R' at beginning of line, checking for 'etry-after'\n");
d1099 1
a1099 1
	    CTRACE (tfp, "HTMIME: Got 'S' at beginning of line, state now S\n");
d1105 1
a1105 1
	    CTRACE (tfp, "HTMIME: Got 'T' at beginning of line, state now T\n");
d1111 1
a1111 1
	    CTRACE (tfp, "HTMIME: Got 'U' at beginning of line, state now U\n");
d1117 1
a1117 1
	    CTRACE (tfp, "HTMIME: Got 'V' at beginning of line, state now V\n");
d1123 1
a1123 1
	    CTRACE (tfp, "HTMIME: Got 'W' at beginning of line, state now W\n");
d1129 1
a1129 233
		if (strchr(HTAtom_name(me->format), ';') != NULL) {
		    char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;

		    CTRACE(tfp, "HTMIME: Extended MIME Content-Type is %s\n",
				HTAtom_name(me->format));
		    StrAllocCopy(cp, HTAtom_name(me->format));
		    /*
		    **	Note that the Content-Type value was converted
		    **	to lower case when we loaded into me->format,
		    **	but there may have been a mixed or upper-case
		    **	atom, so we'll force lower-casing again.  We
		    **	also stripped spaces and double-quotes, but
		    **	we'll make sure they're still gone from any
		    **	charset parameter we check. - FM
		    */
		    LYLowerCase(cp);
		    if ((cp1 = strchr(cp, ';')) != NULL) {
			BOOL chartrans_ok = NO;
			if ((cp2 = strstr(cp1, "charset")) != NULL) {
			    int chndl;

			    cp2 += 7;
			    while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
				cp2++;
			    StrAllocCopy(cp3, cp2); /* copy to mutilate more */
			    for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '\"' &&
					     *cp4 != ';'  && *cp4 != ':' &&
					     !WHITE(*cp4));	cp4++)
				; /* do nothing */
			    *cp4 = '\0';
			    cp4 = cp3;
			    chndl = UCGetLYhndl_byMIME(cp3);
			    if (UCCanTranslateFromTo(chndl,
						     current_char_set)) {
				chartrans_ok = YES;
				*cp1 = '\0';
				me->format = HTAtom_for(cp);
				StrAllocCopy(me->anchor->charset, cp4);
				HTAnchor_setUCInfoStage(me->anchor, chndl,
							UCT_STAGE_MIME,
							UCT_SETBY_MIME);
			    }
			    else if (chndl < 0) {/* got something but we don't
						 recognize it */
				chndl = UCLYhndl_for_unrec;
				if (chndl < 0)
				/*
				 **  UCLYhndl_for_unrec not defined :-(
				 **  fallback to UCLYhndl_for_unspec
				 **  which always valid.
				 */
				chndl = UCLYhndl_for_unspec;  /* always >= 0 */
				if (UCCanTranslateFromTo(chndl,
							 current_char_set)) {
				    chartrans_ok = YES;
				    *cp1 = '\0';
				    me->format = HTAtom_for(cp);
				    HTAnchor_setUCInfoStage(me->anchor, chndl,
							    UCT_STAGE_MIME,
							    UCT_SETBY_DEFAULT);
				}
			    }
			    if (chartrans_ok) {
				LYUCcharset * p_in =
				    HTAnchor_getUCInfoStage(me->anchor,
							    UCT_STAGE_MIME);
				LYUCcharset * p_out =
				    HTAnchor_setUCInfoStage(me->anchor,
							    current_char_set,
							    UCT_STAGE_HTEXT,
							    UCT_SETBY_DEFAULT);
				if (!p_out)
				    /*
				    **	Try again.
				    */
				    p_out =
				      HTAnchor_getUCInfoStage(me->anchor,
							      UCT_STAGE_HTEXT);

				if (!strcmp(p_in->MIMEname,
					    "x-transparent")) {
				    HTPassEightBitRaw = TRUE;
				    HTAnchor_setUCInfoStage(me->anchor,
				       HTAnchor_getUCLYhndl(me->anchor,
							    UCT_STAGE_HTEXT),
							    UCT_STAGE_MIME,
							    UCT_SETBY_DEFAULT);
				}
				if (!strcmp(p_out->MIMEname,
					    "x-transparent")) {
				    HTPassEightBitRaw = TRUE;
				    HTAnchor_setUCInfoStage(me->anchor,
					 HTAnchor_getUCLYhndl(me->anchor,
							      UCT_STAGE_MIME),
							    UCT_STAGE_HTEXT,
							    UCT_SETBY_DEFAULT);
				}
				if (p_in->enc != UCT_ENC_CJK) {
				    HTCJK = NOCJK;
				    if (!(p_in->codepoints &
					  UCT_CP_SUBSETOF_LAT1) &&
					chndl == current_char_set) {
					HTPassEightBitRaw = TRUE;
				    }
				} else if (p_out->enc == UCT_ENC_CJK) {
				    Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
				}
			    } else {
				/*
				**  Cannot translate.
				**  If according to some heuristic the given
				**  charset and the current display character
				**  both are likely to be like ISO-8859 in
				**  structure, pretend we have some kind
				**  of match.
				*/
				BOOL given_is_8859
				    = (!strncmp(cp4, "iso-8859-", 9) &&
				       isdigit((unsigned char)cp4[9]));
				BOOL given_is_8859like
				    = (given_is_8859 ||
				       !strncmp(cp4, "windows-", 8) ||
				       !strncmp(cp4, "cp12", 4) ||
				       !strncmp(cp4, "cp-12", 5));
				BOOL given_and_display_8859like
				    = (given_is_8859like &&
				       (strstr(LYchar_set_names[current_char_set],
					       "ISO-8859") ||
					strstr(LYchar_set_names[current_char_set],
					       "windows-")));

				if (given_and_display_8859like) {
				    *cp1 = '\0';
				    me->format = HTAtom_for(cp);
				}
				if (given_is_8859) {
				    cp1 = &cp4[10];
				    while (*cp1 &&
					   isdigit((unsigned char)(*cp1)))
					cp1++;
				    *cp1 = '\0';
				}
				if (given_and_display_8859like) {
				    StrAllocCopy(me->anchor->charset, cp4);
				    HTPassEightBitRaw = TRUE;
				}
				HTAlert(*cp4 ? cp4 : me->anchor->charset);
			    }
			    FREE(cp3);
			} else {
			    /*
			    **	No charset parameter is present.
			    **	Ignore all other parameters, as
			    **	we do when charset is present. - FM
			    */
			    *cp1 = '\0';
			    me->format = HTAtom_for(cp);
			}
		    }
		    FREE(cp);
		}
		/*
		**  If we have an Expires header and haven't
		**  already set the no_cache element for the
		**  anchor, check if we should set it based
		**  on that header. - FM
		*/
		if (me->anchor->no_cache == FALSE &&
		    me->anchor->expires != NULL) {
		    if (!strcmp(me->anchor->expires, "0")) {
			/*
			 *  The value is zero, which we treat as
			 *  an absolute no-cache directive. - FM
			 */
			me->anchor->no_cache = TRUE;
		    } else if (me->anchor->date != NULL) {
			/*
			**  We have a Date header, so check if
			**  the value is less than or equal to
			**  that. - FM
			*/
			if (LYmktime(me->anchor->expires, TRUE) <=
			    LYmktime(me->anchor->date, TRUE)) {
			    me->anchor->no_cache = TRUE;
			}
		    } else if (LYmktime(me->anchor->expires, FALSE) <= 0) {
			/*
			**  We don't have a Date header, and
			**  the value is in past for us. - FM
			*/
			me->anchor->no_cache = TRUE;
		    }
		}
		StrAllocCopy(me->anchor->content_type,
			     HTAtom_name(me->format));
		if (!me->compression_encoding) {
		    CTRACE(tfp, "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
				HTAtom_name(me->format), HTAtom_name(me->targetRep));
		} else {
		    /*
		    **	Change the format to that for "www/compressed"
		    **	and set up a stream to deal with it. - FM
		    */
		    CTRACE(tfp, "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format));
		    me->format = HTAtom_for("www/compressed");
		    CTRACE(tfp, "        Treating as '%s'.  Converting to '%s'\n",
				HTAtom_name(me->format), HTAtom_name(me->targetRep));
		}
		if (me->set_cookie != NULL || me->set_cookie2 != NULL) {
		    LYSetCookie(me->set_cookie,
				me->set_cookie2,
				me->anchor->address);
		    FREE(me->set_cookie);
		    FREE(me->set_cookie2);
		}
		me->target = HTStreamStack(me->format, me->targetRep,
					   me->sink , me->anchor);
		if (!me->target) {
		    CTRACE(tfp, "HTMIME: Can't translate! ** \n");
		    me->target = me->sink;	/* Cheat */
		}
		if (me->target) {
		    me->targetClass = *me->target->isa;
		    /*
		    **	Check for encoding and select state from there,
		    **	someday, but until we have the relevant code,
		    **	from now push straight through. - FM
		    */
		    me->state = MIME_TRANSPARENT;
		} else {
		    me->state = MIME_IGNORE;	/* What else to do? */
		}
		FREE(me->compression_encoding);
d1146 1
a1146 1
	    CTRACE(tfp, "HTMIME: Was A, found C, checking for 'cept-ranges:'\n");
d1154 1
a1154 1
	    CTRACE(tfp, "HTMIME: Was A, found G, checking for 'e:'\n");
d1160 1
a1160 1
	    CTRACE(tfp, "HTMIME: Was A, found L, state now AL'\n");
d1164 2
a1165 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'g' or 'l'");
d1178 1
a1178 1
	    CTRACE(tfp, "HTMIME: Was AL, found L, checking for 'ow:'\n");
d1186 1
a1186 1
	    CTRACE(tfp, "HTMIME: Was AL, found T, checking for 'ernates:'\n");
d1190 2
a1191 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'l' or 't'");
d1204 1
a1204 1
	    CTRACE(tfp, "HTMIME: Was C, found A, checking for 'che-control:'\n");
d1210 1
a1210 1
	    CTRACE(tfp, "HTMIME: Was C, found O, state now CO'\n");
d1214 2
a1215 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'");
d1226 1
a1226 1
	    CTRACE(tfp, "HTMIME: Was CO, found N, state now CON\n");
d1234 1
a1234 1
	    CTRACE(tfp, "HTMIME: Was CO, found O, checking for 'kie:'\n");
d1238 2
a1239 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 'o'");
d1245 1
a1245 1
    case miCON: 			/* Check for 'n' or 't' */
d1252 1
a1252 1
	    CTRACE(tfp, "HTMIME: Was CON, found N, checking for 'ection:'\n");
d1260 1
a1260 1
	    CTRACE(tfp, "HTMIME: Was CON, found T, checking for 'ent-'\n");
d1264 2
a1265 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 't'");
d1278 1
a1278 1
	    CTRACE(tfp, "HTMIME: Was E, found T, checking for 'ag:'\n");
d1286 1
a1286 1
	    CTRACE(tfp, "HTMIME: Was E, found X, checking for 'pires:'\n");
d1290 2
a1291 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'t' or 'x'");
d1304 1
a1304 1
	    CTRACE(tfp, "HTMIME: Was L, found A, checking for 'st-modified:'\n");
d1312 1
a1312 1
	    CTRACE(tfp, "HTMIME: Was L, found I, checking for 'nk:'\n");
d1320 1
a1320 1
	    CTRACE(tfp, "HTMIME: Was L, found O, checking for 'cation:'\n");
d1324 2
a1325 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a', 'i' or 'o'");
d1336 1
a1336 1
	    CTRACE(tfp, "HTMIME: Was P, found R, state now PR'\n");
d1344 1
a1344 1
	    CTRACE(tfp, "HTMIME: Was P, found U, checking for 'blic:'\n");
d1348 2
a1349 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 'u'");
d1362 1
a1362 1
	    CTRACE(tfp, "HTMIME: Was PR, found A, checking for 'gma'\n");
d1370 42
a1411 1
	    CTRACE(tfp, "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n");
d1415 2
a1416 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'");
d1429 1
a1429 1
	    CTRACE(tfp, "HTMIME: Was S, found A, checking for 'fe:'\n");
d1435 1
a1435 1
	    CTRACE(tfp, "HTMIME: Was S, found E, state now SE'\n");
d1439 2
a1440 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'e'");
d1453 1
a1453 1
	    CTRACE(tfp, "HTMIME: Was SE, found R, checking for 'ver'\n");
d1461 1
a1461 1
	    CTRACE(tfp, "HTMIME: Was SE, found T, checking for '-cookie'\n");
d1465 2
a1466 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 't'");
d1477 1
a1477 1
	    CTRACE(tfp, "HTMIME: Was SET_COOKIE, found :, processing\n");
d1484 1
a1484 1
	    CTRACE(tfp, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n");
d1488 2
a1489 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "':' or '2'");
d1502 1
a1502 1
	    CTRACE(tfp, "HTMIME: Was T, found I, checking for 'tle:'\n");
d1510 1
a1510 1
	    CTRACE(tfp, "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n");
d1514 2
a1515 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'i' or 'r'");
d1528 1
a1528 1
	    CTRACE(tfp, "HTMIME: Was U, found P, checking for 'grade:'\n");
d1536 1
a1536 1
	    CTRACE(tfp, "HTMIME: Was U, found R, checking for 'i:'\n");
d1540 2
a1541 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'p' or 'r'");
d1554 1
a1554 1
	    CTRACE(tfp, "HTMIME: Was V, found A, checking for 'ry:'\n");
d1562 1
a1562 1
	    CTRACE(tfp, "HTMIME: Was V, found I, checking for 'a:'\n");
d1566 2
a1567 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'i'");
d1580 1
a1580 1
	    CTRACE(tfp, "HTMIME: Was W, found A, checking for 'rning:'\n");
d1588 1
a1588 1
	    CTRACE(tfp, "HTMIME: Was W, found W, checking for 'w-authenticate:'\n");
d1592 2
a1593 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'w'");
d1604 2
a1605 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, me->check_pointer - 1);
d1611 1
a1611 1
	CTRACE (tfp, "HTMIME: in case CONTENT_\n");
d1619 1
a1619 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n");
d1627 1
a1627 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n");
d1635 1
a1635 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n");
d1643 1
a1643 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n");
d1649 1
a1649 1
	    CTRACE (tfp, "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n");
d1657 1
a1657 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n");
d1665 1
a1665 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n");
d1671 1
a1671 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n");
d1675 1
a1675 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found nothing; bleah\n");
d1682 1
a1682 1
	CTRACE (tfp, "HTMIME: in case CONTENT_L\n");
d1690 1
a1690 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n");
d1698 1
a1698 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n");
d1706 1
a1706 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n");
d1710 1
a1710 1
	    CTRACE (tfp, "HTMIME: Was CONTENT_L, found nothing; bleah\n");
d1717 1
a1717 1
	CTRACE (tfp, "HTMIME: in case CONTENT_T\n");
d1725 1
a1725 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n");
d1733 1
a1733 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n");
d1737 1
a1737 1
	    CTRACE (tfp, "HTMIME: Was CONTENT_T, found nothing; bleah\n");
d1771 1
d1791 3
a1793 3
	   me->fold_state = me->state;
	   me->state = miNEWLINE;
	   break;
d1806 2
a1807 452
    	if (WHITE(c) && c != ' ') {			/* End of field */
	    char *cp;
	    *me->value_pointer = '\0';
	    cp = (me->value_pointer - 1);
	    while ((cp >= me->value) && *cp == ' ')  /* S/390 -- gil -- 0146 */
		/*
		**  Trim trailing spaces.
		*/
		*cp = '\0';
	    switch (me->field) {
	    case miACCEPT_RANGES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
			    me->value);
		break;
	    case miAGE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Age: '%s'\n",
			    me->value);
		break;
	    case miALLOW:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Allow: '%s'\n",
			    me->value);
		break;
	    case miALTERNATES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Alternates: '%s'\n",
			    me->value);
		break;
	    case miCACHE_CONTROL:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Cache-Control: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Convert to lowercase and indicate in anchor. - FM
		*/
		LYLowerCase(me->value);
		StrAllocCopy(me->anchor->cache_control, me->value);
		/*
		**  Check whether to set no_cache for the anchor. - FM
		*/
		{
		    char *cp1, *cp0 = me->value;

		    while ((cp1 = strstr(cp0, "no-cache")) != NULL) {
			cp1 += 8;
			while (*cp1 != '\0' && WHITE(*cp1))
			    cp1++;
			if (*cp1 == '\0' || *cp1 == ';') {
			    me->anchor->no_cache = TRUE;
			    break;
			}
			cp0 = cp1;
		    }
		    if (me->anchor->no_cache == TRUE)
			break;
		    cp0 = me->value;
		    while ((cp1 = strstr(cp0, "max-age")) != NULL) {
			cp1 += 7;
			while (*cp1 != '\0' && WHITE(*cp1))
			    cp1++;
			if (*cp1 == '=') {
			    cp1++;
			    while (*cp1 != '\0' && WHITE(*cp1))
				cp1++;
			    if (isdigit((unsigned char)*cp1)) {
				cp0 = cp1;
				while (isdigit((unsigned char)*cp1))
				    cp1++;
				if (*cp0 == '0' && cp1 == (cp0 + 1)) {
				    me->anchor->no_cache = TRUE;
				    break;
				}
			    }
			}
			cp0 = cp1;
		    }
		}
		break;
	    case miCOOKIE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Cookie: '%s'\n",
			    me->value);
		break;
	    case miCONNECTION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Connection: '%s'\n",
			    me->value);
		break;
	    case miCONTENT_BASE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Base: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_base, me->value);
		break;
	    case miCONTENT_DISPOSITION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Disposition: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_disposition, me->value);
		/*
		**  It's not clear yet from existing RFCs and IDs
		**  whether we should be looking for file;, attachment;,
		**  and/or inline; before the filename=value, so we'll
		**  just search for "filename" followed by '=' and just
		**  hope we get the intended value.  It is purely a
		**  suggested name, anyway. - FM
		*/
		cp = me->anchor->content_disposition;
		while (*cp != '\0' && strncasecomp(cp, "filename", 8))
		    cp++;
		if (*cp == '\0')
		    break;
		cp += 8;
		while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
		    cp++;
		if (*cp == '\0')
		    break;
		while (*cp != '\0' && WHITE(*cp))
		    cp++;
		if (*cp == '\0')
		    break;
		StrAllocCopy(me->anchor->SugFname, cp);
		if (*me->anchor->SugFname == '\"') {
		    if ((cp = strchr((me->anchor->SugFname + 1),
				     '\"')) != NULL) {
			*(cp + 1) = '\0';
			HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
		    } else {
			FREE(me->anchor->SugFname);
			break;
		    }
		}
		cp = me->anchor->SugFname;
		while (*cp != '\0' && !WHITE(*cp))
		    cp++;
		*cp = '\0';
		if (*me->anchor->SugFname == '\0')
		    FREE(me->anchor->SugFname);
		break;
	    case miCONTENT_ENCODING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Encoding: '%s'\n",
			    me->value);
		if (!(me->value && *me->value) ||
		    !strcasecomp(me->value, "identity"))
		    break;
		/*
		**  Convert to lowercase and indicate in anchor. - FM
		*/
		LYLowerCase(me->value);
		StrAllocCopy(me->anchor->content_encoding, me->value);
		FREE(me->compression_encoding);
		if (!strcmp(me->value, "8bit") ||
		    !strcmp(me->value, "7bit") ||
		    !strcmp(me->value, "binary")) {
		    /*
		    **	Some server indicated "8bit", "7bit" or "binary"
		    **	inappropriately.  We'll ignore it. - FM
		    */
		    CTRACE(tfp, "                Ignoring it!\n");
		} else {
		    /*
		    **	Save it to use as a flag for setting
		    **	up a "www/compressed" target. - FM
		    */
		    StrAllocCopy(me->compression_encoding, me->value);
		}
		break;
	    case miCONTENT_FEATURES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Features: '%s'\n",
			    me->value);
		break;
	    case miCONTENT_LANGUAGE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Language: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Convert to lowercase and indicate in anchor. - FM
		*/
		LYLowerCase(me->value);
		StrAllocCopy(me->anchor->content_language, me->value);
		break;
	    case miCONTENT_LENGTH:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Length: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Convert to integer and indicate in anchor. - FM
		*/
		me->anchor->content_length = atoi(me->value);
		if (me->anchor->content_length < 0)
		    me->anchor->content_length = 0;
		CTRACE(tfp, "        Converted to integer: '%d'\n",
			    me->anchor->content_length);
		break;
	    case miCONTENT_LOCATION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Location: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_location, me->value);
		break;
	    case miCONTENT_MD5:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-MD5: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_md5, me->value);
		break;
	    case miCONTENT_RANGE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Range: '%s'\n",
			    me->value);
		break;
	    case miCONTENT_TRANSFER_ENCODING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Force the Content-Transfer-Encoding value
		**  to all lower case. - FM
		*/
		LYLowerCase(me->value);
		me->encoding = HTAtom_for(me->value);
		break;
	    case miCONTENT_TYPE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Type: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Force the Content-Type value to all lower case
		**  and strip spaces and double-quotes. - FM
		*/
		for (i = 0, j = 0; me->value[i]; i++) {
		    if (me->value[i] != ' ' && me->value[i] != '\"') {
			me->value[j++] = TOLOWER(me->value[i]);
		    }
		}
		me->value[j] = '\0';
		me->format = HTAtom_for(me->value);
		break;
	    case miDATE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Date: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->date, me->value);
		break;
	    case miETAG:
		/*  Do not trim double quotes:
		 *  an entity tag consists of an opaque quoted string,
		 *  possibly prefixed by a weakness indicator.
		 */
		CTRACE(tfp, "HTMIME: PICKED UP ETag: %s\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->ETag, me->value);
		break;
	    case miEXPIRES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Expires: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->expires, me->value);
		break;
	    case miKEEP_ALIVE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Keep-Alive: '%s'\n",
			    me->value);
		break;
	    case miLAST_MODIFIED:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Last-Modified: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->last_modified, me->value);
		break;
	    case miLINK:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Link: '%s'\n",
			    me->value);
		break;
	    case miLOCATION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Location: '%s'\n",
			    me->value);
		break;
	    case miPRAGMA:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Pragma: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Check whether to set no_cache for the anchor. - FM
		*/
		if (!strcmp(me->value, "no-cache"))
		    me->anchor->no_cache = TRUE;
		break;
	    case miPROXY_AUTHENTICATE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
			    me->value);
		break;
	    case miPUBLIC:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Public: '%s'\n",
			    me->value);
		break;
	    case miRETRY_AFTER:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Retry-After: '%s'\n",
			    me->value);
		break;
	    case miSAFE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Safe: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor if "YES" or "TRUE". - FM
		*/
		if (!strcasecomp(me->value, "YES") ||
		    !strcasecomp(me->value, "TRUE")) {
		    me->anchor->safe = TRUE;
		}
		break;
	    case miSERVER:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Server: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->server, me->value);
		break;
	    case miSET_COOKIE1:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Set-Cookie: '%s'\n",
			    me->value);
		if (me->set_cookie == NULL) {
		    StrAllocCopy(me->set_cookie, me->value);
		} else {
		    StrAllocCat(me->set_cookie, ", ");
		    StrAllocCat(me->set_cookie, me->value);
		}
		break;
	    case miSET_COOKIE2:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
			    me->value);
		if (me->set_cookie2 == NULL) {
		    StrAllocCopy(me->set_cookie2, me->value);
		} else {
		    StrAllocCat(me->set_cookie2, ", ");
		    StrAllocCat(me->set_cookie2, me->value);
		}
		break;
	    case miTITLE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Title: '%s'\n",
			    me->value);
		break;
	    case miTRANSFER_ENCODING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
			    me->value);
		break;
	    case miUPGRADE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Upgrade: '%s'\n",
			    me->value);
		break;
	    case miURI:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP URI: '%s'\n",
			    me->value);
		break;
	    case miVARY:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Vary: '%s'\n",
			    me->value);
		break;
	    case miVIA:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Via: '%s'\n",
			    me->value);
		break;
	    case miWARNING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Warning: '%s'\n",
			    me->value);
		break;
	    case miWWW_AUTHENTICATE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
			    me->value);
		break;
	    default:		/* Should never get here */
		break;
	    }
	} else {
d1815 1
a1815 1
	/* Fall through */
d1819 1
a1820 1
	    me->fold_state = me->state;
d1830 1
a1830 1
    CTRACE(tfp, "HTMIME: *** Syntax error. (string too long)\n");
d1832 1
a1832 1
bad_field_name: 			/* Ignore it */
d1855 1
a1855 1
	CTRACE(tfp, "HTMIME:  %s\n", s);
d1877 1
a1877 1
	CTRACE(tfp, "HTMIME:  %.*s\n", l, s);
d1892 7
a1898 3
    if (me->target)
	(*me->targetClass._free)(me->target);
    FREE(me);
d1907 7
a1913 3
    if (me->target)
	(*me->targetClass._abort)(me->target, e);
    FREE(me);
d1941 1
a1941 1
    me = (HTStream *)calloc(1, sizeof(*me));
d1989 3
a1991 2
    me->set_cookie  =	NULL;		/* Not set yet */
    me->set_cookie2  =	NULL;		/* Not set yet */
d2017 15
d2068 2
d2071 1
a2071 1
#define BUFLEN	1024
d2084 2
a2085 2
	char *, 	t,
	char *, 	s)
d2088 1
a2088 1
    char  buf[BUFLEN], *bp, nw[4], *p;
d2108 1
a2108 1
		nw[j] = val & 255;
d2123 2
a2124 2
	char *, 	t,
	char *, 	s)
d2126 1
a2126 1
    char  buf[BUFLEN], cval, *bp, *p;
d2132 1
a2132 1
		cval += (p - HTmmquote);
d2139 1
a2139 1
		cval += (p - HTmmquote);
a2155 96
#ifdef NOTDEFINED
/*
**	Generalized HTmmdecode for chartrans - K. Weide 1997-03-06
*/
PUBLIC void HTmmdecode ARGS2(
	char *, 	trg,
	char *, 	str)
{
    char buf[BUFLEN], mmbuf[BUFLEN];
    char *s, *t, *u, *qm2;
    int  base64, quote;

    buf[0] = '\0';

    /*
    **	Encoded-words look like
    **		=?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
    */
    for (s = str, u = buf; *s; ) {
	base64 = quote = 0;
	if (*s == '=' && s[1] == '?' &&
	    (s == str || *(s-1) == '(' || WHITE(*(s-1))))
	{ /* must be beginning of word */
	    qm2 = strchr(s+2, '?'); /* 2nd question mark */
	    if (qm2 &&
		(qm2[1] == 'B' || qm2[1] == 'b' || qm2[1] == 'Q' ||
		 qm2[1] == 'q') &&
		qm2[2] == '?') { /* 3rd question mark */
		char * qm4 = strchr(qm2 + 3, '?'); /* 4th question mark */
		if (qm4 && qm4 - s < 74 &&  /* RFC 2047 length restriction */
		    qm4[1] == '=') {
		    char *p;
		    BOOL invalid = NO;
		    for (p = s+2; p < qm4; p++)
			if (WHITE(*p)) {
			    invalid = YES;
			    break;
			}
		    if (!invalid) {
			int LYhndl;

			*qm2 = '\0';
			invalid = ((LYhndl = UCGetLYhndl_byMIME(s+2)) < 0 ||
				   UCCanTranslateFromTo(LYhndl,
						 current_char_set));
			*qm2 = '?';
		    }
		    if (!invalid) {
			if (qm2[1] == 'B' || qm2[1] == 'b')
			    base64 = 1;
			else if (qm2[1] == 'Q' || qm2[1] == 'q')
			    quote = 1;
		    }
		}
	    }
	}
	if (base64 || quote) {
	    if (HTmmcont) {
		for (t = s - 1;
		    t >= str && (*t == ' ' || *t == '\t'); t--) {
			u--;
		}
	    }
	    for (s = qm2 + 3, t = mmbuf; *s; ) {
		if (s[0] == '?' && s[1] == '=') {
		    break;
		} else {
		    *t++ = *s++;
		}
	    }
	    if (s[0] != '?' || s[1] != '=') {
		goto end;
	    } else {
		s += 2;
		*t = '\0';
	    }
	    if (base64)
		HTmmdec_base64(mmbuf, mmbuf);
	    if (quote)
		HTmmdec_quote(mmbuf, mmbuf);
	    for (t = mmbuf; *t; )
		*u++ = *t++;
	    HTmmcont = 1;
	    /* if (*s == ' ' || *s == '\t') *u++ = *s; */
	    /* for ( ; *s == ' ' || *s == '\t'; s++) ; */
	} else {
	    if (*s != ' ' && *s != '\t')
		HTmmcont = 0;
	    *u++ = *s++;
	}
    }
    *u = '\0';
end:
    strcpy(trg, buf);
}
#else
d2160 2
a2161 2
	char *, 	trg,
	char *, 	str)
d2163 1
a2163 1
    char buf[BUFLEN], mmbuf[BUFLEN];
a2218 1
#endif /* NOTDEFINED */
d2225 2
a2226 2
	char *, 	t,
	char *, 	s)
d2228 1
a2228 1
    char *p, buf[BUFLEN];
d2273 1
a2273 1
 * $Header: /lcvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.1 2003/03/22 17:42:10 tg Exp $
@


1.1
log
@Initial revision
@
text
@d2176 1
a2176 1
 * $Header: /cvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.2 2000/03/25 18:16:47 maja Exp $
@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 12
a13 12
 *			==================
 *
 *	This is RFC 1341-specific code.
 *	The input stream pushed into this parser is assumed to be
 *	stripped on CRs, ie lines end with LF, not CR LF.
 *	(It is easy to change this except for the body part where
 *	conversion can be slow.)
 *
 * History:
 *	   Feb 92	Written Tim Berners-Lee, CERN
 *
 */
a15 1
#include <HTTP.h>		/* for redirecting_url */
a16 1
#include <HTFile.h>
a23 1
#include <LYCharUtils.h>
d28 3
d32 2
a33 2
 *		-----------
 */
d35 71
a105 74
typedef enum {
    MIME_TRANSPARENT,		/* put straight through to target ASAP! */
    miBEGINNING_OF_LINE,	/* first character and not a continuation */
    miA,
    miACCEPT_RANGES,
    miAGE,
    miAL,
    miALLOW,
    miALTERNATES,
    miC,
    miCACHE_CONTROL,
    miCO,
    miCOOKIE,
    miCON,
    miCONNECTION,
    miCONTENT_,
    miCONTENT_BASE,
    miCONTENT_DISPOSITION,
    miCONTENT_ENCODING,
    miCONTENT_FEATURES,
    miCONTENT_L,
    miCONTENT_LANGUAGE,
    miCONTENT_LENGTH,
    miCONTENT_LOCATION,
    miCONTENT_MD5,
    miCONTENT_RANGE,
    miCONTENT_T,
    miCONTENT_TRANSFER_ENCODING,
    miCONTENT_TYPE,
    miDATE,
    miE,
    miETAG,
    miEXPIRES,
    miKEEP_ALIVE,
    miL,
    miLAST_MODIFIED,
    miLINK,
    miLOCATION,
    miP,
    miPR,
    miPRAGMA,
    miPROXY_AUTHENTICATE,
    miPUBLIC,
    miR,
    miRE,
    miREFRESH,
    miRETRY_AFTER,
    miS,
    miSAFE,
    miSE,
    miSERVER,
    miSET_COOKIE,
    miSET_COOKIE1,
    miSET_COOKIE2,
    miT,
    miTITLE,
    miTRANSFER_ENCODING,
    miU,
    miUPGRADE,
    miURI,
    miV,
    miVARY,
    miVIA,
    miW,
    miWARNING,
    miWWW_AUTHENTICATE,
    miSKIP_GET_VALUE,		/* Skip space then get value */
    miGET_VALUE,		/* Get value till white space */
    miJUNK_LINE,		/* Ignore the rest of this folded line */
    miNEWLINE,			/* Just found a LF .. maybe continuation */
    miCHECK,			/* check against check_pointer */
    MIME_NET_ASCII,		/* Translate from net ascii */
    MIME_IGNORE			/* Ignore entire file */
    /* TRANSPARENT and IGNORE are defined as stg else in _WINDOWS */
d108 1
a108 1
#define VALUE_SIZE 5120		/* @@@@@@@@@@@@@@ Arbitrary? */
d110 1
a110 1
    const HTStreamClass *isa;
d112 22
a133 28
    BOOL net_ascii;		/* Is input net ascii? */
    MIME_state state;		/* current state */
    MIME_state if_ok;		/* got this state if match */
    MIME_state field;		/* remember which field */
    MIME_state fold_state;	/* state on a fold */
    BOOL head_only;		/* only parsing header */
    BOOL pickup_redirection;	/* parsing for location */
    BOOL no_streamstack;	/* use sink directly */
    const char *check_pointer;	/* checking input */

    char *value_pointer;	/* storing values */
    char value[VALUE_SIZE];

    HTParentAnchor *anchor;	/* Given on creation */
    HTStream *sink;		/* Given on creation */

    char *boundary;		/* For multipart */
    char *set_cookie;		/* Set-Cookie */
    char *set_cookie2;		/* Set-Cookie2 */
    char *location;		/* Location */

    char *refresh_url;		/* "Refresh:" URL */

    HTFormat encoding;		/* Content-Transfer-Encoding */
    char *compression_encoding;
    HTFormat format;		/* Content-Type */
    HTStream *target;		/* While writing out */
    HTStreamClass targetClass;
d135 1
a135 1
    HTAtom *targetRep;		/* Converting into? */
d139 8
a146 7
 *  This function is for trimming off any paired
 *  open- and close-double quotes from header values.
 *  It does not parse the string for embedded quotes,
 *  and will not modify the string unless both the
 *  first and last characters are double-quotes. - FM
 */
void HTMIME_TrimDoubleQuotes(char *value)
d151 1
a151 1
    if (!(cp && *cp) || *cp != '"')
d155 1
a155 1
    if (cp[(i - 1)] != '"')
d161 1
a161 1
	value[i] = cp[(i + 1)];
d164 4
a167 8
/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.
 */
static BOOL content_is_compressed(HTStream *me)
{
    char *encoding = me->anchor->content_encoding;
    BOOL result = (HTEncodingToCompressType(encoding) != cftNone);
d169 10
a178 321
    CTRACE((tfp, "content is%s compressed\n", result ? "" : " NOT"));
    return result;
}

/*
 * Strip quotes from a refresh-URL.
 */
static void dequote(char *url)
{
    int len;

    len = strlen(url);
    if (*url == '\'' && len > 1 && url[len - 1] == url[0]) {
	url[len - 1] = '\0';
	while ((url[0] = url[1]) != '\0') {
	    ++url;
	}
    }
}

static int pumpData(HTStream *me)
{
    if (strchr(HTAtom_name(me->format), ';') != NULL) {
	char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;

	CTRACE((tfp, "HTMIME: Extended MIME Content-Type is %s\n",
		HTAtom_name(me->format)));
	StrAllocCopy(cp, HTAtom_name(me->format));
	/*
	 * Note that the Content-Type value was converted
	 * to lower case when we loaded into me->format,
	 * but there may have been a mixed or upper-case
	 * atom, so we'll force lower-casing again.  We
	 * also stripped spaces and double-quotes, but
	 * we'll make sure they're still gone from any
	 * charset parameter we check.  - FM
	 */
	LYLowerCase(cp);
	if ((cp1 = strchr(cp, ';')) != NULL) {
	    BOOL chartrans_ok = NO;

	    if ((cp2 = strstr(cp1, "charset")) != NULL) {
		int chndl;

		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
		    cp2++;
		StrAllocCopy(cp3, cp2);		/* copy to mutilate more */
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
				 *cp4 != ';' && *cp4 != ':' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
		*cp4 = '\0';
		cp4 = cp3;
		chndl = UCGetLYhndl_byMIME(cp3);
		if (UCCanTranslateFromTo(chndl,
					 current_char_set)) {
		    chartrans_ok = YES;
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		} else if (chndl < 0) {		/* got something but we don't
						   recognize it */
		    chndl = UCLYhndl_for_unrec;
		    if (chndl < 0)
			/*
			 * UCLYhndl_for_unrec not defined :-( fallback to
			 * UCLYhndl_for_unspec which always valid.
			 */
			chndl = UCLYhndl_for_unspec;	/* always >= 0 */
		    if (UCCanTranslateFromTo(chndl,
					     current_char_set)) {
			chartrans_ok = YES;
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
			HTAnchor_setUCInfoStage(me->anchor, chndl,
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		} else {
		    /*
		     * Something like 'big5' - we cannot translate it, but
		     * the user may still be able to navigate the links.
		     */
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		}
		if (chartrans_ok) {
		    LYUCcharset *p_in =
		    HTAnchor_getUCInfoStage(me->anchor,
					    UCT_STAGE_MIME);
		    LYUCcharset *p_out =
		    HTAnchor_setUCInfoStage(me->anchor,
					    current_char_set,
					    UCT_STAGE_HTEXT,
					    UCT_SETBY_DEFAULT);

		    if (!p_out)
			/*
			 * Try again.
			 */
			p_out =
			    HTAnchor_getUCInfoStage(me->anchor,
						    UCT_STAGE_HTEXT);

		    if (!strcmp(p_in->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_HTEXT),
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		    if (!strcmp(p_out->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_MIME),
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		    }
		    if ((p_in->enc != UCT_ENC_CJK)
#ifndef EXP_JAPANESEUTF8_SUPPORT
			&& ((p_in->enc != UCT_ENC_UTF8)
			    || (p_out->enc != UCT_ENC_CJK))
#endif
			) {
			HTCJK = NOCJK;
			if (!(p_in->codepoints &
			      UCT_CP_SUBSETOF_LAT1) &&
			    chndl == current_char_set) {
			    HTPassEightBitRaw = TRUE;
			}
		    } else if (p_out->enc == UCT_ENC_CJK) {
			Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
		    }
		} else {
		    /*
		     * Cannot translate.  If according to some heuristic the
		     * given charset and the current display character both are
		     * likely to be like ISO-8859 in structure, pretend we have
		     * some kind of match.
		     */
		    BOOL given_is_8859 =
		    (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
			    isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like =
		    (BOOL) (given_is_8859 ||
			    !strncmp(cp4, "windows-", 8) ||
			    !strncmp(cp4, "cp12", 4) ||
			    !strncmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like =
		    (BOOL) (given_is_8859like &&
			    (strstr(LYchar_set_names[current_char_set],
				    "ISO-8859") ||
			     strstr(LYchar_set_names[current_char_set],
				    "windows-")));

		    if (given_and_display_8859like) {
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
		    }
		    if (given_is_8859) {
			cp1 = &cp4[10];
			while (*cp1 &&
			       isdigit(UCH(*cp1)))
			    cp1++;
			*cp1 = '\0';
		    }
		    if (given_and_display_8859like) {
			StrAllocCopy(me->anchor->charset, cp4);
			HTPassEightBitRaw = TRUE;
		    }
		    HTAlert(*cp4 ? cp4 : me->anchor->charset);
		}
		FREE(cp3);
	    } else {
		/*
		 * No charset parameter is present.  Ignore all other
		 * parameters, as we do when charset is present.  - FM
		 */
		*cp1 = '\0';
		me->format = HTAtom_for(cp);
	    }
	}
	FREE(cp);
    }
    /*
     * If we have an Expires header and haven't already set the no_cache
     * element for the anchor, check if we should set it based on that header. 
     * - FM
     */
    if (me->anchor->no_cache == FALSE &&
	me->anchor->expires != NULL) {
	if (!strcmp(me->anchor->expires, "0")) {
	    /*
	     * The value is zero, which we treat as an absolute no-cache
	     * directive.  - FM
	     */
	    me->anchor->no_cache = TRUE;
	} else if (me->anchor->date != NULL) {
	    /*
	     * We have a Date header, so check if the value is less than or
	     * equal to that.  - FM
	     */
	    if (LYmktime(me->anchor->expires, TRUE) <=
		LYmktime(me->anchor->date, TRUE)) {
		me->anchor->no_cache = TRUE;
	    }
	} else if (LYmktime(me->anchor->expires, FALSE) == 0) {
	    /*
	     * We don't have a Date header, and the value is in past for us.  -
	     * FM
	     */
	    me->anchor->no_cache = TRUE;
	}
    }
    StrAllocCopy(me->anchor->content_type,
		 HTAtom_name(me->format));

    if (me->set_cookie != NULL || me->set_cookie2 != NULL) {
	LYSetCookie(me->set_cookie,
		    me->set_cookie2,
		    me->anchor->address);
	FREE(me->set_cookie);
	FREE(me->set_cookie2);
    }
    if (me->pickup_redirection) {
	if (me->location && *me->location) {
	    redirecting_url = me->location;
	    me->location = NULL;
	    if (me->targetRep != WWW_DEBUG || me->sink)
		me->head_only = YES;

	} else {
	    permanent_redirection = FALSE;
	    if (me->location) {
		CTRACE((tfp, "HTTP: 'Location:' is zero-length!\n"));
		HTAlert(REDIRECTION_WITH_BAD_LOCATION);
	    }
	    CTRACE((tfp, "HTTP: Failed to pick up location.\n"));
	    if (me->location) {
		FREE(me->location);
	    } else {
		HTAlert(REDIRECTION_WITH_NO_LOCATION);
	    }
	}
    }
    if (me->head_only) {
	/* We are done! - kw */
	me->state = MIME_IGNORE;
	return HT_OK;
    }

    if (me->no_streamstack) {
	me->target = me->sink;
    } else {
	if (!me->compression_encoding) {
	    CTRACE((tfp,
		    "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	} else {
	    /*
	     * Change the format to that for "www/compressed" and set up a
	     * stream to deal with it.  - FM
	     */
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format)));
	    me->format = HTAtom_for("www/compressed");
	    CTRACE((tfp, "        Treating as '%s'.  Converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	    FREE(me->compression_encoding);
	}
	me->target = HTStreamStack(me->format, me->targetRep,
				   me->sink, me->anchor);
	if (!me->target) {
	    CTRACE((tfp, "HTMIME: Can't translate! ** \n"));
	    me->target = me->sink;	/* Cheat */
	}
    }
    if (me->target) {
	me->targetClass = *me->target->isa;
	/*
	 * Check for encoding and select state from there, someday, but until
	 * we have the relevant code, from now push straight through.  - FM
	 */
	me->state = MIME_TRANSPARENT;	/* Pump rest of data right through */
    } else {
	me->state = MIME_IGNORE;	/* What else to do? */
    }
    if (me->refresh_url != NULL && !content_is_compressed(me)) {
	char *url = NULL;
	char *num = NULL;
	char *txt = NULL;
	const char *base = "";	/* FIXME: refresh_url may be relative to doc */

	LYParseRefreshURL(me->refresh_url, &num, &url);
	if (url != NULL && me->format == WWW_HTML) {
	    CTRACE((tfp, "Formatting refresh-url as first line of result\n"));
	    HTSprintf0(&txt, gettext("Refresh: "));
	    HTSprintf(&txt, gettext("%s seconds "), num);
	    dequote(url);
	    HTSprintf(&txt, "<a href=\"%s%s\">%s</a><br>", base, url, url);
	    CTRACE((tfp, "URL %s%s\n", base, url));
	    (me->isa->put_string) (me, txt);
	    free(txt);
	}
	FREE(num);
	FREE(url);
    }
    return HT_OK;
}

static int dispatchField(HTStream *me)
a180 474
    char *cp;

    *me->value_pointer = '\0';

    cp = me->value_pointer;
    while ((cp > me->value) && *(--cp) == ' ')	/* S/390 -- gil -- 0146 */
	/*
	 * Trim trailing spaces.
	 */
	*cp = '\0';

    switch (me->field) {
    case miACCEPT_RANGES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
		me->value));
	break;
    case miAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Age: '%s'\n",
		me->value));
	break;
    case miALLOW:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Allow: '%s'\n",
		me->value));
	break;
    case miALTERNATES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Alternates: '%s'\n",
		me->value));
	break;
    case miCACHE_CONTROL:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cache-Control: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->cache_control, me->value);
	/*
	 * Check whether to set no_cache for the anchor.  - FM
	 */
	{
	    char *cp1, *cp0 = me->value;

	    while ((cp1 = strstr(cp0, "no-cache")) != NULL) {
		cp1 += 8;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '\0' || *cp1 == ';') {
		    me->anchor->no_cache = TRUE;
		    break;
		}
		cp0 = cp1;
	    }
	    if (me->anchor->no_cache == TRUE)
		break;
	    cp0 = me->value;
	    while ((cp1 = strstr(cp0, "max-age")) != NULL) {
		cp1 += 7;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '=') {
		    cp1++;
		    while (*cp1 != '\0' && WHITE(*cp1))
			cp1++;
		    if (isdigit(UCH(*cp1))) {
			cp0 = cp1;
			while (isdigit(UCH(*cp1)))
			    cp1++;
			if (*cp0 == '0' && cp1 == (cp0 + 1)) {
			    me->anchor->no_cache = TRUE;
			    break;
			}
		    }
		}
		cp0 = cp1;
	    }
	}
	break;
    case miCOOKIE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cookie: '%s'\n",
		me->value));
	break;
    case miCONNECTION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Connection: '%s'\n",
		me->value));
	break;
    case miCONTENT_BASE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Base: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_base, me->value);
	break;
    case miCONTENT_DISPOSITION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Disposition: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_disposition, me->value);
	/*
	 * It's not clear yet from existing RFCs and IDs whether we should be
	 * looking for file;, attachment;, and/or inline; before the
	 * filename=value, so we'll just search for "filename" followed by '='
	 * and just hope we get the intended value.  It is purely a suggested
	 * name, anyway.  - FM
	 */
	cp = me->anchor->content_disposition;
	while (*cp != '\0' && strncasecomp(cp, "filename", 8))
	    cp++;
	if (*cp == '\0')
	    break;
	cp += 8;
	while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
	    cp++;
	if (*cp == '\0')
	    break;
	while (*cp != '\0' && WHITE(*cp))
	    cp++;
	if (*cp == '\0')
	    break;
	StrAllocCopy(me->anchor->SugFname, cp);
	if (*me->anchor->SugFname == '"') {
	    if ((cp = strchr((me->anchor->SugFname + 1),
			     '"')) != NULL) {
		*(cp + 1) = '\0';
		HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
	    } else {
		FREE(me->anchor->SugFname);
		break;
	    }
	}
	cp = me->anchor->SugFname;
	while (*cp != '\0' && !WHITE(*cp))
	    cp++;
	*cp = '\0';
	if (*me->anchor->SugFname == '\0')
	    FREE(me->anchor->SugFname);
	break;
    case miCONTENT_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value) ||
	    !strcasecomp(me->value, "identity"))
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_encoding, me->value);
	FREE(me->compression_encoding);
	if (content_is_compressed(me)) {
	    /*
	     * Save it to use as a flag for setting up a "www/compressed"
	     * target.  - FM
	     */
	    StrAllocCopy(me->compression_encoding, me->value);
	} else {
	    /*
	     * Some server indicated "8bit", "7bit" or "binary"
	     * inappropriately.  We'll ignore it.  - FM
	     */
	    CTRACE((tfp, "                Ignoring it!\n"));
	}
	break;
    case miCONTENT_FEATURES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Features: '%s'\n",
		me->value));
	break;
    case miCONTENT_LANGUAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Language: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_language, me->value);
	break;
    case miCONTENT_LENGTH:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Length: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Convert to integer and indicate in anchor.  - FM
	 */
	me->anchor->content_length = atoi(me->value);
	if (me->anchor->content_length < 0)
	    me->anchor->content_length = 0;
	CTRACE((tfp, "        Converted to integer: '%d'\n",
		me->anchor->content_length));
	break;
    case miCONTENT_LOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Location: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_location, me->value);
	break;
    case miCONTENT_MD5:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-MD5: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_md5, me->value);
	break;
    case miCONTENT_RANGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Range: '%s'\n",
		me->value));
	break;
    case miCONTENT_TRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Force the Content-Transfer-Encoding value to all lower case.  - FM
	 */
	LYLowerCase(me->value);
	me->encoding = HTAtom_for(me->value);
	break;
    case miCONTENT_TYPE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Type: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Force the Content-Type value to all lower case and strip spaces and
	 * double-quotes.  - FM
	 */
	for (i = 0, j = 0; me->value[i]; i++) {
	    if (me->value[i] != ' ' && me->value[i] != '"') {
		me->value[j++] = (char) TOLOWER(me->value[i]);
	    }
	}
	me->value[j] = '\0';
	me->format = HTAtom_for(me->value);
	StrAllocCopy(me->anchor->content_type_params, me->value);
	break;
    case miDATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Date: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->date, me->value);
	break;
    case miETAG:
	/* Do not trim double quotes:  an entity tag consists of an opaque
	 * quoted string, possibly prefixed by a weakness indicator.
	 */
	CTRACE((tfp, "HTMIME: PICKED UP ETag: %s\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->ETag, me->value);
	break;
    case miEXPIRES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Expires: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->expires, me->value);
	break;
    case miKEEP_ALIVE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Keep-Alive: '%s'\n",
		me->value));
	break;
    case miLAST_MODIFIED:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Last-Modified: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->last_modified, me->value);
	break;
    case miLINK:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Link: '%s'\n",
		me->value));
	break;
    case miLOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Location: '%s'\n",
		me->value));
	if (me->pickup_redirection && !me->location) {
	    StrAllocCopy(me->location, me->value);
	} else {
	    CTRACE((tfp, "HTMIME: *** Ignoring Location!\n"));
	}
	break;
    case miPRAGMA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Pragma: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Check whether to set no_cache for the anchor.  - FM
	 */
	if (!strcmp(me->value, "no-cache"))
	    me->anchor->no_cache = TRUE;
	break;
    case miPROXY_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
		me->value));
	break;
    case miPUBLIC:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Public: '%s'\n",
		me->value));
	break;
    case miREFRESH:		/* nonstandard: Netscape */
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Refresh: '%s'\n",
		me->value));
	StrAllocCopy(me->refresh_url, me->value);
	break;
    case miRETRY_AFTER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Retry-After: '%s'\n",
		me->value));
	break;
    case miSAFE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Safe: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor if "YES" or "TRUE".  - FM
	 */
	if (!strcasecomp(me->value, "YES") ||
	    !strcasecomp(me->value, "TRUE")) {
	    me->anchor->safe = TRUE;
	} else if (!strcasecomp(me->value, "NO") ||
		   !strcasecomp(me->value, "FALSE")) {
	    /*
	     * If server explicitly tells us that it has changed its mind,
	     * reset flag in anchor.  - kw
	     */
	    me->anchor->safe = FALSE;
	}
	break;
    case miSERVER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Server: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->server, me->value);
	break;
    case miSET_COOKIE1:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie: '%s'\n",
		me->value));
	if (me->set_cookie == NULL) {
	    StrAllocCopy(me->set_cookie, me->value);
	} else {
	    StrAllocCat(me->set_cookie, ", ");
	    StrAllocCat(me->set_cookie, me->value);
	}
	break;
    case miSET_COOKIE2:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
		me->value));
	if (me->set_cookie2 == NULL) {
	    StrAllocCopy(me->set_cookie2, me->value);
	} else {
	    StrAllocCat(me->set_cookie2, ", ");
	    StrAllocCat(me->set_cookie2, me->value);
	}
	break;
    case miTITLE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Title: '%s'\n",
		me->value));
	break;
    case miTRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
		me->value));
	break;
    case miUPGRADE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Upgrade: '%s'\n",
		me->value));
	break;
    case miURI:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP URI: '%s'\n",
		me->value));
	break;
    case miVARY:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Vary: '%s'\n",
		me->value));
	break;
    case miVIA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Via: '%s'\n",
		me->value));
	break;
    case miWARNING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Warning: '%s'\n",
		me->value));
	break;
    case miWWW_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
		me->value));
	break;
    default:			/* Should never get here */
	return HT_ERROR;
    }
    return HT_OK;
}

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 */
a181 11
/*	Character handling
 *	------------------
 *
 *	This is a FSM parser. It ignores field names it does not understand.
 *	Folded header fields are recognized.  Lines without a fieldname at
 *	the beginning (that are not folded continuation lines) are ignored
 *	as unknown field names.  Fields with empty values are not picked up.
 */
static void HTMIME_put_character(HTStream *me,
				 char c)
{
d183 1
a183 1
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
d188 4
a191 4
     * This slightly simple conversion just strips CR and turns LF to newline. 
     * On unix LF is \n but on Mac \n is CR for example.  See NetToText for an
     * implementation which preserves single CR or LF.
     */
d194 7
a200 8
	 * <sigh> This is evidence that at one time, this code supported
	 * local character sets other than ASCII.  But there is so much
	 * code in HTTP.c that depends on line_buffer's having been
	 * translated to local character set that I needed to put the
	 * FROMASCII translation there, leaving this translation purely
	 * destructive.  -- gil
	 */
	/* S/390 -- gil -- 0118 */
d210 1
a210 1
    switch (me->state) {
d215 2
a216 2
    case MIME_TRANSPARENT:	/* Not reached see above */
	(*me->targetClass.put_character) (me->target, c);
d220 1
a220 1
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
d224 2
a225 8
	if (c != '\n' && WHITE(c)) {	/* Folded line */
	    me->state = me->fold_state;		/* pop state before newline */
	    if (me->state == miGET_VALUE &&
		me->value_pointer && me->value_pointer != me->value &&
		!WHITE(*(me->value_pointer - 1))) {
		c = ' ';
		goto GET_VALUE;	/* will add space to value if it fits - kw */
	    }
a226 4
	} else if (me->fold_state == miGET_VALUE) {
	    /* Got a field, and now we know it's complete - so
	     * act on it. - kw */
	    dispatchField(me);
d228 2
a229 1
	/* FALLTHRU */
d237 1
a237 1
	    CTRACE((tfp, "HTMIME: Got 'A' at beginning of line, state now A\n"));
d243 1
a243 1
	    CTRACE((tfp, "HTMIME: Got 'C' at beginning of line, state now C\n"));
d251 1
a251 2
	    CTRACE((tfp,
		    "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
d257 1
a257 1
	    CTRACE((tfp, "HTMIME: Got 'E' at beginning of line, state now E\n"));
d265 1
a265 2
	    CTRACE((tfp,
		    "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
d271 1
a271 1
	    CTRACE((tfp, "HTMIME: Got 'L' at beginning of line, state now L\n"));
d277 1
a277 1
	    CTRACE((tfp, "HTMIME: Got 'P' at beginning of line, state now P\n"));
d282 4
a285 2
	    me->state = miR;
	    CTRACE((tfp, "HTMIME: Got 'R' at beginning of line, state now R\n"));
d291 1
a291 1
	    CTRACE((tfp, "HTMIME: Got 'S' at beginning of line, state now S\n"));
d297 1
a297 1
	    CTRACE((tfp, "HTMIME: Got 'T' at beginning of line, state now T\n"));
d303 1
a303 1
	    CTRACE((tfp, "HTMIME: Got 'U' at beginning of line, state now U\n"));
d309 1
a309 1
	    CTRACE((tfp, "HTMIME: Got 'V' at beginning of line, state now V\n"));
d314 240
a553 8
	    me->state = miW;
	    CTRACE((tfp, "HTMIME: Got 'W' at beginning of line, state now W\n"));
	    break;

	case '\n':		/* Blank line: End of Header! */
	    {
		me->net_ascii = NO;
		pumpData(me);
d558 1
a558 1
	    goto bad_field_name;
d560 1
a560 1
	}			/* switch on character */
d563 1
a563 1
    case miA:			/* Check for 'c','g' or 'l' */
d570 1
a570 2
	    CTRACE((tfp,
		    "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
d578 1
a578 1
	    CTRACE((tfp, "HTMIME: Was A, found G, checking for 'e:'\n"));
d584 1
a584 1
	    CTRACE((tfp, "HTMIME: Was A, found L, state now AL'\n"));
d588 2
a589 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'g' or 'l'"));
d592 1
a592 1
	}			/* switch on character */
d595 1
a595 1
    case miAL:			/* Check for 'l' or 't' */
d602 1
a602 1
	    CTRACE((tfp, "HTMIME: Was AL, found L, checking for 'ow:'\n"));
d610 1
a610 1
	    CTRACE((tfp, "HTMIME: Was AL, found T, checking for 'ernates:'\n"));
d614 2
a615 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'l' or 't'"));
d618 1
a618 1
	}			/* switch on character */
d621 1
a621 1
    case miC:			/* Check for 'a' or 'o' */
d628 1
a628 2
	    CTRACE((tfp,
		    "HTMIME: Was C, found A, checking for 'che-control:'\n"));
d634 1
a634 1
	    CTRACE((tfp, "HTMIME: Was C, found O, state now CO'\n"));
d638 2
a639 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
d642 1
a642 1
	}			/* switch on character */
d645 1
a645 1
    case miCO:			/* Check for 'n' or 'o' */
d650 1
a650 1
	    CTRACE((tfp, "HTMIME: Was CO, found N, state now CON\n"));
d658 1
a658 1
	    CTRACE((tfp, "HTMIME: Was CO, found O, checking for 'kie:'\n"));
d662 2
a663 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 'o'"));
d666 1
a666 1
	}			/* switch on character */
d669 1
a669 1
    case miCON:		/* Check for 'n' or 't' */
d676 1
a676 1
	    CTRACE((tfp, "HTMIME: Was CON, found N, checking for 'ection:'\n"));
d684 1
a684 1
	    CTRACE((tfp, "HTMIME: Was CON, found T, checking for 'ent-'\n"));
d688 2
a689 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 't'"));
d692 1
a692 1
	}			/* switch on character */
d695 1
a695 1
    case miE:			/* Check for 't' or 'x' */
d702 1
a702 1
	    CTRACE((tfp, "HTMIME: Was E, found T, checking for 'ag:'\n"));
d710 1
a710 1
	    CTRACE((tfp, "HTMIME: Was E, found X, checking for 'pires:'\n"));
d714 2
a715 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'t' or 'x'"));
d718 1
a718 1
	}			/* switch on character */
d721 1
a721 1
    case miL:			/* Check for 'a', 'i' or 'o' */
d728 1
a728 2
	    CTRACE((tfp,
		    "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
d736 1
a736 1
	    CTRACE((tfp, "HTMIME: Was L, found I, checking for 'nk:'\n"));
d744 1
a744 1
	    CTRACE((tfp, "HTMIME: Was L, found O, checking for 'cation:'\n"));
d748 2
a749 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a', 'i' or 'o'"));
d752 1
a752 1
	}			/* switch on character */
d755 1
a755 1
    case miP:			/* Check for 'r' or 'u' */
d760 1
a760 1
	    CTRACE((tfp, "HTMIME: Was P, found R, state now PR'\n"));
d768 1
a768 1
	    CTRACE((tfp, "HTMIME: Was P, found U, checking for 'blic:'\n"));
d772 2
a773 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 'u'"));
d776 1
a776 1
	}			/* switch on character */
d779 1
a779 1
    case miPR:			/* Check for 'a' or 'o' */
d786 1
a786 1
	    CTRACE((tfp, "HTMIME: Was PR, found A, checking for 'gma'\n"));
d794 1
a794 45
	    CTRACE((tfp,
		    "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miR:			/* Check for 'e' */
	switch (c) {
	case 'e':
	case 'E':
	    me->state = miRE;
	    CTRACE((tfp, "HTMIME: Was R, found E\n"));
	    break;
	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'e'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miRE:			/* Check for 'a' or 'o' */
	switch (c) {
	case 'f':
	case 'F':		/* nonstandard: Netscape */
	    me->check_pointer = "resh:";
	    me->if_ok = miREFRESH;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found F, checking for '%s'\n", me->check_pointer));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ry-after:";
	    me->if_ok = miRETRY_AFTER;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found T, checking for '%s'\n", me->check_pointer));
d798 2
a799 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'f' or 't'"));
d802 1
a802 1
	}			/* switch on character */
d805 1
a805 1
    case miS:			/* Check for 'a' or 'e' */
d812 1
a812 1
	    CTRACE((tfp, "HTMIME: Was S, found A, checking for 'fe:'\n"));
d818 1
a818 1
	    CTRACE((tfp, "HTMIME: Was S, found E, state now SE'\n"));
d822 2
a823 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'e'"));
d826 1
a826 1
	}			/* switch on character */
d829 1
a829 1
    case miSE:			/* Check for 'r' or 't' */
d836 1
a836 1
	    CTRACE((tfp, "HTMIME: Was SE, found R, checking for 'ver'\n"));
d844 1
a844 1
	    CTRACE((tfp, "HTMIME: Was SE, found T, checking for '-cookie'\n"));
d848 2
a849 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 't'"));
d852 1
a852 1
	}			/* switch on character */
d855 1
a855 1
    case miSET_COOKIE:		/* Check for ':' or '2' */
d858 1
a858 1
	    me->field = miSET_COOKIE1;	/* remember it */
d860 1
a860 1
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found :, processing\n"));
d867 1
a867 1
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n"));
d871 2
a872 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "':' or '2'"));
d875 1
a875 1
	}			/* switch on character */
d878 1
a878 1
    case miT:			/* Check for 'i' or 'r' */
d885 1
a885 1
	    CTRACE((tfp, "HTMIME: Was T, found I, checking for 'tle:'\n"));
d893 1
a893 2
	    CTRACE((tfp,
		    "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
d897 2
a898 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'i' or 'r'"));
d901 1
a901 1
	}			/* switch on character */
d904 1
a904 1
    case miU:			/* Check for 'p' or 'r' */
d911 1
a911 1
	    CTRACE((tfp, "HTMIME: Was U, found P, checking for 'grade:'\n"));
d919 1
a919 1
	    CTRACE((tfp, "HTMIME: Was U, found R, checking for 'i:'\n"));
d923 2
a924 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'p' or 'r'"));
d927 1
a927 1
	}			/* switch on character */
d930 1
a930 1
    case miV:			/* Check for 'a' or 'i' */
d937 1
a937 1
	    CTRACE((tfp, "HTMIME: Was V, found A, checking for 'ry:'\n"));
d945 1
a945 1
	    CTRACE((tfp, "HTMIME: Was V, found I, checking for 'a:'\n"));
d949 2
a950 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'i'"));
d953 1
a953 1
	}			/* switch on character */
d956 1
a956 1
    case miW:			/* Check for 'a' or 'w' */
d963 1
a963 1
	    CTRACE((tfp, "HTMIME: Was W, found A, checking for 'rning:'\n"));
d971 1
a971 2
	    CTRACE((tfp,
		    "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
d975 2
a976 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'w'"));
d979 1
a979 1
	}			/* switch on character */
d982 1
a982 1
    case miCHECK:		/* Check against string */
d987 2
a988 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, me->check_pointer - 1));
d994 1
a994 1
	CTRACE((tfp, "HTMIME: in case CONTENT_\n"));
d996 1
a996 1
	switch (c) {
d1002 1
a1002 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
d1010 1
a1010 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
d1018 1
a1018 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
d1026 1
a1026 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
d1032 1
a1032 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
d1040 1
a1040 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n"));
d1048 1
a1048 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
d1054 1
a1054 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
d1058 1
a1058 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found nothing; bleah\n"));
d1061 1
a1061 1
	}			/* switch on character */
d1065 1
a1065 1
	CTRACE((tfp, "HTMIME: in case CONTENT_L\n"));
d1067 1
a1067 1
	switch (c) {
d1073 1
a1073 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
d1081 1
a1081 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
d1089 1
a1089 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
d1093 1
a1093 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found nothing; bleah\n"));
d1096 1
a1096 1
	}			/* switch on character */
d1100 1
a1100 1
	CTRACE((tfp, "HTMIME: in case CONTENT_T\n"));
d1102 1
a1102 1
	switch (c) {
d1108 1
a1108 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
d1116 1
a1116 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
d1120 1
a1120 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found nothing; bleah\n"));
d1123 1
a1123 1
	}			/* switch on character */
a1153 1
    case miREFRESH:
d1167 1
a1167 1
	me->field = me->state;	/* remember it */
d1173 3
a1175 3
	    me->fold_state = me->state;
	    me->state = miNEWLINE;
	    break;
d1179 2
a1180 2
	     * Skip white space.
	     */
d1188 452
a1639 2
      GET_VALUE:
	if (c != '\n') {	/* Not end of line */
d1647 1
a1647 1
	/* Fall through (if end of line) */
d1651 1
a1652 1
	    me->state = miNEWLINE;
a1655 1
    }				/* switch on state */
d1657 2
a1658 11
#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, c);
    if (me->state == MIME_TRANSPARENT) {
	HTChunkTerminate(&me->anchor->http_headers);
	CTRACE((tfp, "Server Headers:\n%.*s\n",
		me->anchor->http_headers.size,
		me->anchor->http_headers.data));
	CTRACE((tfp, "Server Content-Type:%s\n",
		me->anchor->content_type_params));
    }
#endif
d1661 2
a1662 2
  value_too_long:
    CTRACE((tfp, "HTMIME: *** Syntax error. (string too long)\n"));
d1664 1
a1664 1
  bad_field_name:		/* Ignore it */
d1666 1
d1668 1
a1668 3
#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, c);
#endif
a1669 1
    return;
a1670 1
}
d1673 7
a1679 6
 *	---------------
 *
 *	Strings must be smaller than this buffer size.
 */
static void HTMIME_put_string(HTStream *me,
			      const char *s)
d1681 1
a1681 1
    const char *p;
d1684 1
a1684 1
	(*me->targetClass.put_string) (me->target, s);
d1687 1
a1687 1
	CTRACE((tfp, "HTMIME:  %s\n", s));
d1689 1
a1689 1
	for (p = s; *p; p++)
d1694 1
d1696 6
a1701 5
 *	------------
 */
static void HTMIME_write(HTStream *me,
			 const char *s,
			 int l)
d1703 1
a1703 1
    const char *p;
d1706 1
a1706 1
	(*me->targetClass.put_block) (me->target, s, l);
d1709 1
a1709 1
	CTRACE((tfp, "HTMIME:  %.*s\n", l, s));
d1711 1
a1711 1
	for (p = s; p < s + l; p++)
d1716 1
d1718 5
a1722 4
 *	-------------------
 *
 */
static void HTMIME_free(HTStream *me)
d1724 3
a1726 7
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._free) (me->target);
	FREE(me);
    }
d1731 3
a1733 2
static void HTMIME_abort(HTStream *me,
			 HTError e)
d1735 3
a1737 7
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._abort) (me->target, e);
	FREE(me);
    }
d1740 1
d1742 3
a1744 3
 *	-----------------------
 */
static const HTStreamClass HTMIME =
d1746 6
a1751 6
    "MIMEParser",
    HTMIME_free,
    HTMIME_abort,
    HTMIME_put_character,
    HTMIME_put_string,
    HTMIME_write
d1754 1
d1756 6
a1761 5
 *	-------------------------
 */
HTStream *HTMIMEConvert(HTPresentation *pres,
			HTParentAnchor *anchor,
			HTStream *sink)
d1763 1
a1763 3
    HTStream *me;

    me = typecalloc(HTStream);
d1765 1
d1768 3
a1770 3
    me->isa = &HTMIME;
    me->sink = sink;
    me->anchor = anchor;
a1775 5
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&me->anchor->http_headers);
    HTChunkInit(&me->anchor->http_headers, 128);
#endif
    FREE(me->anchor->content_type_params);
d1788 2
a1789 2
    me->target = NULL;
    me->state = miBEGINNING_OF_LINE;
d1791 4
a1794 4
     * Sadly enough, change this to always default to WWW_HTML to parse all
     * text as HTML for the users.
     * GAB 06-30-94
     * Thanks to Robert Rowland robert@@cyclops.pei.edu
d1796 3
a1798 2
     * After discussion of the correct handline, should be application/octet-
     * stream or unknown; causing servers to send a correct content type.
d1800 8
a1807 9
     * The consequence of using WWW_UNKNOWN is that you end up downloading as a
     * binary file what 99.9% of the time is an HTML file, which should have
     * been rendered or displayed.  So sadly enough, I'm changing it back to
     * WWW_HTML, and it will handle the situation like Mosaic does, and as
     * Robert Rowland suggested, because being functionally correct 99.9% of
     * the time is better than being technically correct but functionally
     * nonsensical.  - FM
     */
    /***
d1809 7
a1815 8
    ***/
    me->format = WWW_HTML;
    me->targetRep = pres->rep_out;
    me->boundary = NULL;	/* Not set yet */
    me->set_cookie = NULL;	/* Not set yet */
    me->set_cookie2 = NULL;	/* Not set yet */
    me->refresh_url = NULL;	/* Not set yet */
    me->encoding = 0;		/* Not set yet */
d1817 1
a1817 1
    me->net_ascii = NO;		/* Local character set */
d1827 4
a1830 3
HTStream *HTNetMIME(HTPresentation *pres,
		    HTParentAnchor *anchor,
		    HTStream *sink)
d1832 1
a1832 2
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

a1839 15
HTStream *HTMIMERedirect(HTPresentation *pres,
			 HTParentAnchor *anchor,
			 HTStream *sink)
{
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

    if (!me)
	return NULL;

    me->pickup_redirection = YES;
    if (me->targetRep == WWW_DEBUG && sink)
	me->no_streamstack = YES;
    return me;
}

d1841 4
a1844 4
 *		==================================
 *
 *	K&Rized and added 07-Jun-96 by FM, based on:
 *
d1846 24
a1869 24
 *
 *	ISO-2022-JP handling routines
 *			&
 *	MIME decode routines (quick hack just for ISO-2022-JP)
 *
 *		Thu Jan 25 10:11:42 JST 1996
 *
 *  Copyright (C) 1994, 1995, 1996
 *  Shuichi Ichikawa (ichikawa@@nuee.nagoya-u.ac.jp)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either versions 2, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with SKK, see the file COPYING.  If not, write to the Free
 *  Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
d1872 6
a1877 8
 *  MIME decoding routines
 *
 *	Written by S. Ichikawa,
 *	partially inspired by encdec.c of <jh@@efd.lth.se>.
 *	Assume caller's buffer is LINE_LENGTH bytes, these decode to
 *	no longer than the input strings.
 */
#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
d1881 1
a1881 1
#include <LYCharVals.h>		/* S/390 -- gil -- 0163 */
d1884 8
a1891 7
static char HTmm64[] =
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static char HTmmquote[] = "0123456789ABCDEF";
static int HTmmcont = 0;

void HTmmdec_base64(char *t,
		    char *s)
d1893 2
a1894 2
    int d, count, j, val;
    char buf[LINE_LENGTH], *bp, nw[4], *p;
d1906 6
a1911 6
	    if (!(p = strchr(HTmm64, s[j]))) {
		return;
	    }
	    d = p - HTmm64;
	    d <<= (3 - j) * 6;
	    val += d;
d1914 2
a1915 2
	    nw[j] = (char) (val & 255);
	    val >>= 8;
d1928 3
a1930 2
void HTmmdec_quote(char *t,
		   char *s)
d1932 1
a1932 1
    char buf[LINE_LENGTH], cval, *bp, *p;
d1934 1
a1934 1
    for (bp = buf; *s;) {
d1938 1
a1938 1
		cval += (char) (p - HTmmquote);
d1945 1
a1945 1
		cval += (char) (p - HTmmquote);
d1962 96
d2059 5
a2063 4
 *	HTmmdecode for ISO-2022-JP - FM
 */
void HTmmdecode(char *trg,
		char *str)
d2065 1
a2065 1
    char buf[LINE_LENGTH], mmbuf[LINE_LENGTH];
d2067 1
a2067 1
    int base64, quote;
d2071 1
a2071 1
    for (s = str, u = buf; *s;) {
d2085 2
a2086 2
		     t >= str && (*t == ' ' || *t == '\t'); t--) {
		    u--;
d2089 1
a2089 1
	    for (s += 16, t = mmbuf; *s;) {
d2106 1
a2106 1
	    for (t = mmbuf; *t;)
d2118 1
a2118 1
  end:
d2121 1
d2124 6
a2129 5
 *  Insert ESC where it seems lost.
 *  (The author of this function "rjis" is S. Ichikawa.)
 */
int HTrjis(char *t,
	   char *s)
d2131 1
a2131 1
    char *p, buf[LINE_LENGTH];
d2139 1
a2139 1
    for (p = buf; *s;) {
d2141 1
a2141 1
	    if (HTmaybekanji((int) s[2], (int) s[3])) {
d2162 1
a2162 1
    *p = *s;			/* terminate string */
d2169 5
a2173 5
 *  The following function "maybekanji" is derived from
 *  RJIS-1.0 by Mr. Hironobu Takahashi.
 *  Maybekanji() is included here under the courtesy of the author.
 *  The original comment of rjis.c is also included here.
 */
d2176 1
a2176 1
 * $Header: rjis.c,v 0.2 92/09/04 takahasi Exp $
d2195 3
a2197 2
int HTmaybekanji(int c1,
		 int c2)
d2205 3
a2207 3
    switch (c1 - 32) {
    case 2:
	if ((14 < c2) && (c2 < 26))
d2209 1
a2209 1
	if ((33 < c2) && (c2 < 42))
d2211 1
a2211 1
	if ((48 < c2) && (c2 < 60))
d2213 1
a2213 1
	if ((74 < c2) && (c2 < 82))
d2215 1
a2215 1
	if ((89 < c2) && (c2 < 94))
d2218 1
a2218 1
    case 3:
d2221 1
a2221 1
	if ((25 < c2) && (c2 < 33))
d2223 1
a2223 1
	if ((58 < c2) && (c2 < 65))
d2228 1
a2228 1
    case 4:
d2232 1
a2232 1
    case 5:
d2236 2
a2237 2
    case 6:
	if ((24 < c2) && (c2 < 33))
d2242 2
a2243 2
    case 7:
	if ((33 < c2) && (c2 < 49))
d2248 1
a2248 1
    case 8:
d2252 1
a2252 1
    case 47:
d2256 1
a2256 1
    case 84:
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a15 1
#include <HTTP.h>		/* for redirecting_url */
a23 1
#include <LYCharUtils.h>
d28 3
d35 1
a35 1
typedef enum {
a77 3
	miR,
	miRE,
	miREFRESH,
d103 1
a103 1
	MIME_NET_ASCII,		/* Translate from net ascii */
d108 1
a108 1
#define VALUE_SIZE 5120		/* @@@@@@@@@@@@@@ Arbitrary? */
a116 3
	BOOL			head_only;	/* only parsing header */
	BOOL			pickup_redirection; /* parsing for location */
	BOOL			no_streamstack; /* use sink directly */
d122 1
a122 1
	HTParentAnchor *	anchor;		/* Given on creation */
a127 3
	char *			location;	/* Location */

	char *			refresh_url;	/* "Refresh:" URL */
d131 2
a132 2
	HTFormat		format;		/* Content-Type */
	HTStream *		target;		/* While writing out */
d146 1
a146 1
	char *,		value)
a163 794
PRIVATE BOOL content_is_compressed ARGS1(HTStream *, me)
{
    char *encoding = me->anchor->content_encoding;

    return encoding != 0
        && strcmp(encoding, "8bit") != 0
	&& strcmp(encoding, "7bit") != 0
	&& strcmp(encoding, "binary") != 0;
}

/*
 * Strip parameters and quotes from a URL.
 */
PRIVATE void dequote ARGS1(char *, url)
{
    char *p;
    int len;

    if ((p = strchr(url, '?')) != NULL)
	*p = '\0';
    len = strlen(url);
    if (*url == '\'' && len > 1 && url[len-1] == url[0]) {
	url[len-1] = '\0';
	while ((url[0] = url[1]) != '\0') {
	    ++url;
	}
    }
}

PRIVATE int pumpData ARGS1(HTStream *, me)
{
    if (strchr(HTAtom_name(me->format), ';') != NULL) {
	char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;

	CTRACE((tfp, "HTMIME: Extended MIME Content-Type is %s\n",
		HTAtom_name(me->format)));
	StrAllocCopy(cp, HTAtom_name(me->format));
	/*
	** Note that the Content-Type value was converted
	** to lower case when we loaded into me->format,
	** but there may have been a mixed or upper-case
	** atom, so we'll force lower-casing again.  We
	** also stripped spaces and double-quotes, but
	** we'll make sure they're still gone from any
	** charset parameter we check.  - FM
	*/
	LYLowerCase(cp);
	if ((cp1 = strchr(cp, ';')) != NULL) {
	    BOOL chartrans_ok = NO;
	    if ((cp2 = strstr(cp1, "charset")) != NULL) {
		int chndl;

		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
		    cp2++;
		StrAllocCopy(cp3, cp2); /* copy to mutilate more */
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '\"' &&
				 *cp4 != ';'  && *cp4 != ':' &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
		*cp4 = '\0';
		cp4 = cp3;
		chndl = UCGetLYhndl_byMIME(cp3);
		if (UCCanTranslateFromTo(chndl,
					 current_char_set)) {
		    chartrans_ok = YES;
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		}
		else if (chndl < 0) {/* got something but we don't
					recognize it */
		    chndl = UCLYhndl_for_unrec;
		    if (chndl < 0)
			/*
			**  UCLYhndl_for_unrec not defined :-(
			**  fallback to UCLYhndl_for_unspec
			**  which always valid.
			*/
			chndl = UCLYhndl_for_unspec;  /* always >= 0 */
		    if (UCCanTranslateFromTo(chndl,
					     current_char_set)) {
			chartrans_ok = YES;
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
			HTAnchor_setUCInfoStage(me->anchor, chndl,
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		}
		if (chartrans_ok) {
		    LYUCcharset * p_in =
			HTAnchor_getUCInfoStage(me->anchor,
						UCT_STAGE_MIME);
		    LYUCcharset * p_out =
			HTAnchor_setUCInfoStage(me->anchor,
						current_char_set,
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		    if (!p_out)
			/*
			**	Try again.
			*/
			p_out =
			    HTAnchor_getUCInfoStage(me->anchor,
						    UCT_STAGE_HTEXT);

		    if (!strcmp(p_in->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_HTEXT),
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		    if (!strcmp(p_out->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_MIME),
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		    }
		    if (p_in->enc != UCT_ENC_CJK) {
			HTCJK = NOCJK;
			if (!(p_in->codepoints &
			      UCT_CP_SUBSETOF_LAT1) &&
			    chndl == current_char_set) {
			    HTPassEightBitRaw = TRUE;
			}
		    } else if (p_out->enc == UCT_ENC_CJK) {
			Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
		    }
		} else {
		    /*
		    **  Cannot translate.
		    **  If according to some heuristic the given
		    **  charset and the current display character
		    **  both are likely to be like ISO-8859 in
		    **  structure, pretend we have some kind
		    **  of match.
		    */
		    BOOL given_is_8859
			= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
				  isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like
			= (BOOL) (given_is_8859 ||
				  !strncmp(cp4, "windows-", 8) ||
				  !strncmp(cp4, "cp12", 4) ||
				  !strncmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like
			= (BOOL) (given_is_8859like &&
				  (strstr(LYchar_set_names[current_char_set],
					  "ISO-8859") ||
				   strstr(LYchar_set_names[current_char_set],
					  "windows-")));

		    if (given_and_display_8859like) {
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
		    }
		    if (given_is_8859) {
			cp1 = &cp4[10];
			while (*cp1 &&
			       isdigit(UCH(*cp1)))
			    cp1++;
			*cp1 = '\0';
		    }
		    if (given_and_display_8859like) {
			StrAllocCopy(me->anchor->charset, cp4);
			HTPassEightBitRaw = TRUE;
		    }
		    HTAlert(*cp4 ? cp4 : me->anchor->charset);
		}
		FREE(cp3);
	    } else {
		/*
		**	No charset parameter is present.
		**	Ignore all other parameters, as
		**	we do when charset is present. - FM
		*/
		*cp1 = '\0';
		me->format = HTAtom_for(cp);
	    }
	}
	FREE(cp);
    }
    /*
    **  If we have an Expires header and haven't
    **  already set the no_cache element for the
    **  anchor, check if we should set it based
    **  on that header. - FM
    */
    if (me->anchor->no_cache == FALSE &&
	me->anchor->expires != NULL) {
	if (!strcmp(me->anchor->expires, "0")) {
	    /*
	     *  The value is zero, which we treat as
	     *  an absolute no-cache directive. - FM
	     */
	    me->anchor->no_cache = TRUE;
	} else if (me->anchor->date != NULL) {
	    /*
	    **  We have a Date header, so check if
	    **  the value is less than or equal to
	    **  that. - FM
	    */
	    if (LYmktime(me->anchor->expires, TRUE) <=
		LYmktime(me->anchor->date, TRUE)) {
		me->anchor->no_cache = TRUE;
	    }
	} else if (LYmktime(me->anchor->expires, FALSE) == 0) {
	    /*
	    **  We don't have a Date header, and
	    **  the value is in past for us. - FM
	    */
	    me->anchor->no_cache = TRUE;
	}
    }
    StrAllocCopy(me->anchor->content_type,
		 HTAtom_name(me->format));

    if (me->set_cookie != NULL || me->set_cookie2 != NULL) {
	LYSetCookie(me->set_cookie,
		    me->set_cookie2,
		    me->anchor->address);
	FREE(me->set_cookie);
	FREE(me->set_cookie2);
    }
    if (me->pickup_redirection) {
	if (me->location && *me->location) {
	    redirecting_url = me->location;
	    me->location = NULL;
	    if (me->targetRep != WWW_DEBUG || me->sink)
		me->head_only = YES;

	} else {
	    permanent_redirection = FALSE;
	    if (me->location) {
		CTRACE((tfp, "HTTP: 'Location:' is zero-length!\n"));
		HTAlert(REDIRECTION_WITH_BAD_LOCATION);
	    }
	    CTRACE((tfp, "HTTP: Failed to pick up location.\n"));
	    if (me->location) {
		FREE(me->location);
	    } else {
		HTAlert(REDIRECTION_WITH_NO_LOCATION);
	    }
	}
    }
    if (me->head_only) {
	/* We are done! - kw */
	me->state = MIME_IGNORE;
	return HT_OK;
    }

    if (me->no_streamstack) {
	me->target = me->sink;
    } else {
	if (!me->compression_encoding) {
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	} else {
	    /*
	    **	Change the format to that for "www/compressed"
	    **	and set up a stream to deal with it. - FM
	    */
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format)));
	    me->format = HTAtom_for("www/compressed");
	    CTRACE((tfp, "        Treating as '%s'.  Converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	    FREE(me->compression_encoding);
	}
	me->target = HTStreamStack(me->format, me->targetRep,
				   me->sink , me->anchor);
	if (!me->target) {
	    CTRACE((tfp, "HTMIME: Can't translate! ** \n"));
	    me->target = me->sink;	/* Cheat */
	}
    }
    if (me->target) {
	me->targetClass = *me->target->isa;
	/*
	**	Check for encoding and select state from there,
	**	someday, but until we have the relevant code,
	**	from now push straight through. - FM
	*/
	me->state = MIME_TRANSPARENT;	/* Pump rest of data right through */
    } else {
	me->state = MIME_IGNORE;	/* What else to do? */
    }
    if (me->refresh_url != NULL && !content_is_compressed(me)) {
	char *url = NULL;
	char *num = NULL;
	char *txt = NULL;
	char *base = "";	/* FIXME: refresh_url may be relative to doc */

	LYParseRefreshURL(me->refresh_url, &num, &url);
	if (url != NULL) {
	    CTRACE((tfp, "Formatting refresh-url as first line of result\n"));
	    HTSprintf0(&txt, gettext("Refresh: "));
	    HTSprintf(&txt, gettext("%s seconds "), num);
	    dequote(url);
	    HTSprintf(&txt, "<a href=\"%s%s\">%s</a><br>", base, url, url);
	    CTRACE((tfp, "URL %s%s\n", base, url));
	    (me->isa->put_string)(me, txt);
	    free(txt);
	}
	FREE(num);
	FREE(url);
    }
    return HT_OK;
}

PRIVATE int dispatchField ARGS1(HTStream *, me)
{
    int i, j;
    char *cp;

    *me->value_pointer = '\0';
    cp = me->value_pointer;
    while ((cp > me->value) && *(--cp) == ' ')  /* S/390 -- gil -- 0146 */
	/*
	**  Trim trailing spaces.
	*/
	*cp = '\0';

    switch (me->field) {
    case miACCEPT_RANGES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
		me->value));
	break;
    case miAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Age: '%s'\n",
		me->value));
	break;
    case miALLOW:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Allow: '%s'\n",
		me->value));
	break;
    case miALTERNATES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Alternates: '%s'\n",
		me->value));
	break;
    case miCACHE_CONTROL:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cache-Control: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Convert to lowercase and indicate in anchor. - FM
	*/
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->cache_control, me->value);
	/*
	**  Check whether to set no_cache for the anchor. - FM
	*/
	{
	    char *cp1, *cp0 = me->value;

	    while ((cp1 = strstr(cp0, "no-cache")) != NULL) {
		cp1 += 8;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '\0' || *cp1 == ';') {
		    me->anchor->no_cache = TRUE;
		    break;
		}
		cp0 = cp1;
	    }
	    if (me->anchor->no_cache == TRUE)
		break;
	    cp0 = me->value;
	    while ((cp1 = strstr(cp0, "max-age")) != NULL) {
		cp1 += 7;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '=') {
		    cp1++;
		    while (*cp1 != '\0' && WHITE(*cp1))
			cp1++;
		    if (isdigit(UCH(*cp1))) {
			cp0 = cp1;
			while (isdigit(UCH(*cp1)))
			    cp1++;
			if (*cp0 == '0' && cp1 == (cp0 + 1)) {
			    me->anchor->no_cache = TRUE;
			    break;
			}
		    }
		}
		cp0 = cp1;
	    }
	}
	break;
    case miCOOKIE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cookie: '%s'\n",
		me->value));
	break;
    case miCONNECTION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Connection: '%s'\n",
		me->value));
	break;
    case miCONTENT_BASE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Base: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_base, me->value);
	break;
    case miCONTENT_DISPOSITION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Disposition: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_disposition, me->value);
	/*
	**  It's not clear yet from existing RFCs and IDs
	**  whether we should be looking for file;, attachment;,
	**  and/or inline; before the filename=value, so we'll
	**  just search for "filename" followed by '=' and just
	**  hope we get the intended value.  It is purely a
	**  suggested name, anyway. - FM
	*/
	cp = me->anchor->content_disposition;
	while (*cp != '\0' && strncasecomp(cp, "filename", 8))
	    cp++;
	if (*cp == '\0')
	    break;
	cp += 8;
	while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
	    cp++;
	if (*cp == '\0')
	    break;
	while (*cp != '\0' && WHITE(*cp))
	    cp++;
	if (*cp == '\0')
	    break;
	StrAllocCopy(me->anchor->SugFname, cp);
	if (*me->anchor->SugFname == '\"') {
	    if ((cp = strchr((me->anchor->SugFname + 1),
			     '\"')) != NULL) {
		*(cp + 1) = '\0';
		HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
	    } else {
		FREE(me->anchor->SugFname);
		break;
	    }
	}
	cp = me->anchor->SugFname;
	while (*cp != '\0' && !WHITE(*cp))
	    cp++;
	*cp = '\0';
	if (*me->anchor->SugFname == '\0')
	    FREE(me->anchor->SugFname);
	break;
    case miCONTENT_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value) ||
	    !strcasecomp(me->value, "identity"))
	    break;
	/*
	**  Convert to lowercase and indicate in anchor. - FM
	*/
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_encoding, me->value);
	FREE(me->compression_encoding);
	if (content_is_compressed(me)) {
	    /*
	    **	Save it to use as a flag for setting
	    **	up a "www/compressed" target. - FM
	    */
	    StrAllocCopy(me->compression_encoding, me->value);
	} else {
	    /*
	    **	Some server indicated "8bit", "7bit" or "binary"
	    **	inappropriately.  We'll ignore it. - FM
	    */
	    CTRACE((tfp, "                Ignoring it!\n"));
	}
	break;
    case miCONTENT_FEATURES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Features: '%s'\n",
		me->value));
	break;
    case miCONTENT_LANGUAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Language: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Convert to lowercase and indicate in anchor. - FM
	*/
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_language, me->value);
	break;
    case miCONTENT_LENGTH:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Length: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Convert to integer and indicate in anchor. - FM
	*/
	me->anchor->content_length = atoi(me->value);
	if (me->anchor->content_length < 0)
	    me->anchor->content_length = 0;
	CTRACE((tfp, "        Converted to integer: '%d'\n",
		me->anchor->content_length));
	break;
    case miCONTENT_LOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Location: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_location, me->value);
	break;
    case miCONTENT_MD5:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-MD5: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_md5, me->value);
	break;
    case miCONTENT_RANGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Range: '%s'\n",
		me->value));
	break;
    case miCONTENT_TRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Force the Content-Transfer-Encoding value
	**  to all lower case. - FM
	*/
	LYLowerCase(me->value);
	me->encoding = HTAtom_for(me->value);
	break;
    case miCONTENT_TYPE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Type: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Force the Content-Type value to all lower case
	**  and strip spaces and double-quotes. - FM
	*/
	for (i = 0, j = 0; me->value[i]; i++) {
	    if (me->value[i] != ' ' && me->value[i] != '\"') {
		me->value[j++] = (char) TOLOWER(me->value[i]);
	    }
	}
	me->value[j] = '\0';
	me->format = HTAtom_for(me->value);
	break;
    case miDATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Date: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->date, me->value);
	break;
    case miETAG:
	/*  Do not trim double quotes:
	 *  an entity tag consists of an opaque quoted string,
	 *  possibly prefixed by a weakness indicator.
	 */
	CTRACE((tfp, "HTMIME: PICKED UP ETag: %s\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->ETag, me->value);
	break;
    case miEXPIRES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Expires: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->expires, me->value);
	break;
    case miKEEP_ALIVE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Keep-Alive: '%s'\n",
		me->value));
	break;
    case miLAST_MODIFIED:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Last-Modified: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->last_modified, me->value);
	break;
    case miLINK:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Link: '%s'\n",
		me->value));
	break;
    case miLOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Location: '%s'\n",
		me->value));
	if (me->pickup_redirection && !me->location) {
	    StrAllocCopy(me->location, me->value);
	} else {
	    CTRACE((tfp, "HTMIME: *** Ignoring Location!\n"));
	}
	break;
    case miPRAGMA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Pragma: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Check whether to set no_cache for the anchor. - FM
	*/
	if (!strcmp(me->value, "no-cache"))
	    me->anchor->no_cache = TRUE;
	break;
    case miPROXY_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
		me->value));
	break;
    case miPUBLIC:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Public: '%s'\n",
		me->value));
	break;
    case miREFRESH:		/* nonstandard: Netscape */
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Refresh: '%s'\n",
		me->value));
	StrAllocCopy(me->refresh_url, me->value);
	break;
    case miRETRY_AFTER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Retry-After: '%s'\n",
		me->value));
	break;
    case miSAFE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Safe: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor if "YES" or "TRUE". - FM
	*/
	if (!strcasecomp(me->value, "YES") ||
	    !strcasecomp(me->value, "TRUE")) {
	    me->anchor->safe = TRUE;
	} else if (!strcasecomp(me->value, "NO") ||
		   !strcasecomp(me->value, "FALSE")) {
	    /*
	    **  If server explicitly tells us that it has changed
	    **  its mind, reset flag in anchor. - kw
	    */
	    me->anchor->safe = FALSE;
	}
	break;
    case miSERVER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Server: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->server, me->value);
	break;
    case miSET_COOKIE1:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie: '%s'\n",
		me->value));
	if (me->set_cookie == NULL) {
	    StrAllocCopy(me->set_cookie, me->value);
	} else {
	    StrAllocCat(me->set_cookie, ", ");
	    StrAllocCat(me->set_cookie, me->value);
	}
	break;
    case miSET_COOKIE2:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
		me->value));
	if (me->set_cookie2 == NULL) {
	    StrAllocCopy(me->set_cookie2, me->value);
	} else {
	    StrAllocCat(me->set_cookie2, ", ");
	    StrAllocCat(me->set_cookie2, me->value);
	}
	break;
    case miTITLE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Title: '%s'\n",
		me->value));
	break;
    case miTRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
		me->value));
	break;
    case miUPGRADE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Upgrade: '%s'\n",
		me->value));
	break;
    case miURI:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP URI: '%s'\n",
		me->value));
	break;
    case miVARY:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Vary: '%s'\n",
		me->value));
	break;
    case miVIA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Via: '%s'\n",
		me->value));
	break;
    case miWARNING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Warning: '%s'\n",
		me->value));
	break;
    case miWWW_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
		me->value));
	break;
    default:		/* Should never get here */
	return HT_ERROR;
    }
    return HT_OK;
}


d172 3
a174 4
**	This is a FSM parser. It ignores field names it does not understand.
**	Folded header fields are recognized.  Lines without a fieldname at
**	the beginning (that are not folded continuation lines) are ignored
**	as unknown field names.  Fields with empty values are not picked up.
d180 2
a225 6
	    if (me->state == miGET_VALUE &&
		me->value_pointer && me->value_pointer != me->value &&
		!WHITE(*(me->value_pointer-1))) {
		c = ' ';
		goto GET_VALUE;	/* will add space to value if it fits - kw */
	    }
a226 4
	} else if (me->fold_state == miGET_VALUE) {
	    /* Got a field, and now we know it's complete - so
	     * act on it. - kw */
	    dispatchField(me);
d228 2
a229 1
	/* FALLTHRU */
d237 1
a237 1
	    CTRACE((tfp, "HTMIME: Got 'A' at beginning of line, state now A\n"));
d243 1
a243 1
	    CTRACE((tfp, "HTMIME: Got 'C' at beginning of line, state now C\n"));
d251 1
a251 1
	    CTRACE((tfp, "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
d257 1
a257 1
	    CTRACE((tfp, "HTMIME: Got 'E' at beginning of line, state now E\n"));
d265 1
a265 1
	    CTRACE((tfp, "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
d271 1
a271 1
	    CTRACE((tfp, "HTMIME: Got 'L' at beginning of line, state now L\n"));
d277 1
a277 1
	    CTRACE((tfp, "HTMIME: Got 'P' at beginning of line, state now P\n"));
d282 4
a285 2
	    me->state = miR;
	    CTRACE((tfp, "HTMIME: Got 'R' at beginning of line, state now R\n"));
d291 1
a291 1
	    CTRACE((tfp, "HTMIME: Got 'S' at beginning of line, state now S\n"));
d297 1
a297 1
	    CTRACE((tfp, "HTMIME: Got 'T' at beginning of line, state now T\n"));
d303 1
a303 1
	    CTRACE((tfp, "HTMIME: Got 'U' at beginning of line, state now U\n"));
d309 1
a309 1
	    CTRACE((tfp, "HTMIME: Got 'V' at beginning of line, state now V\n"));
d315 1
a315 1
	    CTRACE((tfp, "HTMIME: Got 'W' at beginning of line, state now W\n"));
d321 233
a553 1
		pumpData(me);
d570 1
a570 1
	    CTRACE((tfp, "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
d578 1
a578 1
	    CTRACE((tfp, "HTMIME: Was A, found G, checking for 'e:'\n"));
d584 1
a584 1
	    CTRACE((tfp, "HTMIME: Was A, found L, state now AL'\n"));
d588 2
a589 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'g' or 'l'"));
d602 1
a602 1
	    CTRACE((tfp, "HTMIME: Was AL, found L, checking for 'ow:'\n"));
d610 1
a610 1
	    CTRACE((tfp, "HTMIME: Was AL, found T, checking for 'ernates:'\n"));
d614 2
a615 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'l' or 't'"));
d628 1
a628 1
	    CTRACE((tfp, "HTMIME: Was C, found A, checking for 'che-control:'\n"));
d634 1
a634 1
	    CTRACE((tfp, "HTMIME: Was C, found O, state now CO'\n"));
d638 2
a639 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
d650 1
a650 1
	    CTRACE((tfp, "HTMIME: Was CO, found N, state now CON\n"));
d658 1
a658 1
	    CTRACE((tfp, "HTMIME: Was CO, found O, checking for 'kie:'\n"));
d662 2
a663 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 'o'"));
d669 1
a669 1
    case miCON:				/* Check for 'n' or 't' */
d676 1
a676 1
	    CTRACE((tfp, "HTMIME: Was CON, found N, checking for 'ection:'\n"));
d684 1
a684 1
	    CTRACE((tfp, "HTMIME: Was CON, found T, checking for 'ent-'\n"));
d688 2
a689 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 't'"));
d702 1
a702 1
	    CTRACE((tfp, "HTMIME: Was E, found T, checking for 'ag:'\n"));
d710 1
a710 1
	    CTRACE((tfp, "HTMIME: Was E, found X, checking for 'pires:'\n"));
d714 2
a715 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'t' or 'x'"));
d728 1
a728 1
	    CTRACE((tfp, "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
d736 1
a736 1
	    CTRACE((tfp, "HTMIME: Was L, found I, checking for 'nk:'\n"));
d744 1
a744 1
	    CTRACE((tfp, "HTMIME: Was L, found O, checking for 'cation:'\n"));
d748 2
a749 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a', 'i' or 'o'"));
d760 1
a760 1
	    CTRACE((tfp, "HTMIME: Was P, found R, state now PR'\n"));
d768 1
a768 1
	    CTRACE((tfp, "HTMIME: Was P, found U, checking for 'blic:'\n"));
d772 2
a773 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 'u'"));
d786 1
a786 1
	    CTRACE((tfp, "HTMIME: Was PR, found A, checking for 'gma'\n"));
d794 1
a794 42
	    CTRACE((tfp, "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
	    break;

	default:
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
	    goto bad_field_name;

	} /* switch on character */
	break;

    case miR:				/* Check for 'e' */
	switch (c) {
	case 'e':
	case 'E':
	    me->state = miRE;
	    CTRACE((tfp, "HTMIME: Was R, found E\n"));
	    break;
	default:
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'e'"));
	    goto bad_field_name;

	} /* switch on character */
	break;

    case miRE:				/* Check for 'a' or 'o' */
	switch (c) {
	case 'f':
	case 'F':			/* nonstandard: Netscape */
	    me->check_pointer = "resh:";
	    me->if_ok = miREFRESH;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found F, checking for '%s'\n", me->check_pointer));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ry-after:";
	    me->if_ok = miRETRY_AFTER;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found T, checking for '%s'\n", me->check_pointer));
d798 2
a799 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'f' or 't'"));
d812 1
a812 1
	    CTRACE((tfp, "HTMIME: Was S, found A, checking for 'fe:'\n"));
d818 1
a818 1
	    CTRACE((tfp, "HTMIME: Was S, found E, state now SE'\n"));
d822 2
a823 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'e'"));
d836 1
a836 1
	    CTRACE((tfp, "HTMIME: Was SE, found R, checking for 'ver'\n"));
d844 1
a844 1
	    CTRACE((tfp, "HTMIME: Was SE, found T, checking for '-cookie'\n"));
d848 2
a849 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 't'"));
d860 1
a860 1
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found :, processing\n"));
d867 1
a867 1
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n"));
d871 2
a872 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "':' or '2'"));
d885 1
a885 1
	    CTRACE((tfp, "HTMIME: Was T, found I, checking for 'tle:'\n"));
d893 1
a893 1
	    CTRACE((tfp, "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
d897 2
a898 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'i' or 'r'"));
d911 1
a911 1
	    CTRACE((tfp, "HTMIME: Was U, found P, checking for 'grade:'\n"));
d919 1
a919 1
	    CTRACE((tfp, "HTMIME: Was U, found R, checking for 'i:'\n"));
d923 2
a924 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'p' or 'r'"));
d937 1
a937 1
	    CTRACE((tfp, "HTMIME: Was V, found A, checking for 'ry:'\n"));
d945 1
a945 1
	    CTRACE((tfp, "HTMIME: Was V, found I, checking for 'a:'\n"));
d949 2
a950 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'i'"));
d963 1
a963 1
	    CTRACE((tfp, "HTMIME: Was W, found A, checking for 'rning:'\n"));
d971 1
a971 1
	    CTRACE((tfp, "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
d975 2
a976 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'w'"));
d987 2
a988 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, me->check_pointer - 1));
d994 1
a994 1
	CTRACE((tfp, "HTMIME: in case CONTENT_\n"));
d1002 1
a1002 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
d1010 1
a1010 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
d1018 1
a1018 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
d1026 1
a1026 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
d1032 1
a1032 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
d1040 1
a1040 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n"));
d1048 1
a1048 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
d1054 1
a1054 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
d1058 1
a1058 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found nothing; bleah\n"));
d1065 1
a1065 1
	CTRACE((tfp, "HTMIME: in case CONTENT_L\n"));
d1073 1
a1073 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
d1081 1
a1081 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
d1089 1
a1089 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
d1093 1
a1093 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found nothing; bleah\n"));
d1100 1
a1100 1
	CTRACE((tfp, "HTMIME: in case CONTENT_T\n"));
d1108 1
a1108 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
d1116 1
a1116 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
d1120 1
a1120 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found nothing; bleah\n"));
a1153 1
    case miREFRESH:
d1173 3
a1175 3
	    me->fold_state = me->state;
	    me->state = miNEWLINE;
	    break;
d1188 452
a1639 2
    GET_VALUE:
	if (c != '\n') {			/* Not end of line */
d1647 1
a1647 1
	/* Fall through (if end of line) */
d1651 1
a1652 1
	    me->state = miNEWLINE;
d1662 1
a1662 1
    CTRACE((tfp, "HTMIME: *** Syntax error. (string too long)\n"));
d1664 1
a1664 1
bad_field_name:				/* Ignore it */
d1687 1
a1687 1
	CTRACE((tfp, "HTMIME:  %s\n", s));
d1709 1
a1709 1
	CTRACE((tfp, "HTMIME:  %.*s\n", l, s));
d1724 3
a1726 7
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._free)(me->target);
	FREE(me);
    }
d1735 3
a1737 7
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._abort)(me->target, e);
	FREE(me);
    }
d1765 1
a1765 1
    me = typecalloc(HTStream);
d1813 2
a1814 3
    me->set_cookie =	NULL;		/* Not set yet */
    me->set_cookie2 =	NULL;		/* Not set yet */
    me->refresh_url =	NULL;		/* Not set yet */
a1839 15
PUBLIC HTStream* HTMIMERedirect ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
{
    HTStream* me = HTMIMEConvert(pres,anchor, sink);
    if (!me)
	return NULL;

    me->pickup_redirection = YES;
    if (me->targetRep == WWW_DEBUG && sink)
	me->no_streamstack = YES;
    return me;
}

a1875 2
**	Assume caller's buffer is LINE_LENGTH bytes, these decode to
**	no longer than the input strings.
d1877 1
a1877 1
#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
d1890 2
a1891 2
	char *,		t,
	char *,		s)
d1894 1
a1894 1
    char  buf[LINE_LENGTH], *bp, nw[4], *p;
d1914 1
a1914 1
		nw[j] = (char) (val & 255);
d1929 2
a1930 2
	char *,		t,
	char *,		s)
d1932 1
a1932 1
    char  buf[LINE_LENGTH], cval, *bp, *p;
d1938 1
a1938 1
		cval += (char) (p - HTmmquote);
d1945 1
a1945 1
		cval += (char) (p - HTmmquote);
d1962 96
d2062 2
a2063 2
	char *,		trg,
	char *,		str)
d2065 1
a2065 1
    char buf[LINE_LENGTH], mmbuf[LINE_LENGTH];
d2121 1
d2128 2
a2129 2
	char *,		t,
	char *,		s)
d2131 1
a2131 1
    char *p, buf[LINE_LENGTH];
d2176 1
a2176 1
 * $Header: rjis.c,v 0.2 92/09/04 takahasi Exp $
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d183 1
a183 1
 * Strip quotes from a refresh-URL.
d187 1
d190 2
d475 1
a475 1
	if (url != NULL && me->format == WWW_HTML) {
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d112 1
a112 1
	const HTStreamClass *	isa;
d122 1
a122 1
	const char *		check_pointer;	/* checking input */
d153 2
a154 2
void HTMIME_TrimDoubleQuotes (
	char *		value)
d172 1
a172 1
static BOOL content_is_compressed (HTStream *  me)
d185 1
a185 1
static void dequote (char *  url)
d198 1
a198 1
static int pumpData (HTStream *  me)
d488 1
a488 1
static int dispatchField (HTStream *  me)
d976 3
a978 3
static void HTMIME_put_character (
	HTStream *	me,
	char		c)
d1842 3
a1844 3
static void HTMIME_put_string (
	HTStream *	me,
	const char *	s)
d1846 1
a1846 1
    const char * p;
d1863 4
a1866 4
static void HTMIME_write (
	HTStream *	me,
	const char *	s,
	int		l)
d1868 1
a1868 1
    const char * p;
d1886 2
a1887 2
static void HTMIME_free (
	HTStream *	me)
d1900 3
a1902 3
static void HTMIME_abort (
	HTStream *	me,
	HTError	e)
d1917 1
a1917 1
static const HTStreamClass HTMIME =
d1931 4
a1934 4
HTStream* HTMIMEConvert (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d2001 4
a2004 4
HTStream* HTNetMIME (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d2014 4
a2017 4
HTStream* HTMIMERedirect (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d2075 1
a2075 1
static char HTmm64[] =
d2077 2
a2078 2
static char HTmmquote[] = "0123456789ABCDEF";
static int HTmmcont = 0;
d2080 3
a2082 3
void HTmmdec_base64 (
	char *		t,
	char *		s)
d2119 3
a2121 3
void HTmmdec_quote (
	char *		t,
	char *		s)
d2156 3
a2158 3
void HTmmdecode (
	char *		trg,
	char *		str)
d2221 3
a2223 3
int HTrjis (
	char *		t,
	char *		s)
d2289 3
a2291 3
int HTmaybekanji (
	int		c1,
	int		c2)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 12
a13 12
 *			==================
 *
 *	This is RFC 1341-specific code.
 *	The input stream pushed into this parser is assumed to be
 *	stripped on CRs, ie lines end with LF, not CR LF.
 *	(It is easy to change this except for the body part where
 *	conversion can be slow.)
 *
 * History:
 *	   Feb 92	Written Tim Berners-Lee, CERN
 *
 */
d31 2
a32 2
 *		-----------
 */
d35 73
a107 73
    MIME_TRANSPARENT,		/* put straight through to target ASAP! */
    miBEGINNING_OF_LINE,	/* first character and not a continuation */
    miA,
    miACCEPT_RANGES,
    miAGE,
    miAL,
    miALLOW,
    miALTERNATES,
    miC,
    miCACHE_CONTROL,
    miCO,
    miCOOKIE,
    miCON,
    miCONNECTION,
    miCONTENT_,
    miCONTENT_BASE,
    miCONTENT_DISPOSITION,
    miCONTENT_ENCODING,
    miCONTENT_FEATURES,
    miCONTENT_L,
    miCONTENT_LANGUAGE,
    miCONTENT_LENGTH,
    miCONTENT_LOCATION,
    miCONTENT_MD5,
    miCONTENT_RANGE,
    miCONTENT_T,
    miCONTENT_TRANSFER_ENCODING,
    miCONTENT_TYPE,
    miDATE,
    miE,
    miETAG,
    miEXPIRES,
    miKEEP_ALIVE,
    miL,
    miLAST_MODIFIED,
    miLINK,
    miLOCATION,
    miP,
    miPR,
    miPRAGMA,
    miPROXY_AUTHENTICATE,
    miPUBLIC,
    miR,
    miRE,
    miREFRESH,
    miRETRY_AFTER,
    miS,
    miSAFE,
    miSE,
    miSERVER,
    miSET_COOKIE,
    miSET_COOKIE1,
    miSET_COOKIE2,
    miT,
    miTITLE,
    miTRANSFER_ENCODING,
    miU,
    miUPGRADE,
    miURI,
    miV,
    miVARY,
    miVIA,
    miW,
    miWARNING,
    miWWW_AUTHENTICATE,
    miSKIP_GET_VALUE,		/* Skip space then get value */
    miGET_VALUE,		/* Get value till white space */
    miJUNK_LINE,		/* Ignore the rest of this folded line */
    miNEWLINE,			/* Just found a LF .. maybe continuation */
    miCHECK,			/* check against check_pointer */
    MIME_NET_ASCII,		/* Translate from net ascii */
    MIME_IGNORE			/* Ignore entire file */
    /* TRANSPARENT and IGNORE are defined as stg else in _WINDOWS */
d112 1
a112 1
    const HTStreamClass *isa;
d114 28
a141 28
    BOOL net_ascii;		/* Is input net ascii? */
    MIME_state state;		/* current state */
    MIME_state if_ok;		/* got this state if match */
    MIME_state field;		/* remember which field */
    MIME_state fold_state;	/* state on a fold */
    BOOL head_only;		/* only parsing header */
    BOOL pickup_redirection;	/* parsing for location */
    BOOL no_streamstack;	/* use sink directly */
    const char *check_pointer;	/* checking input */

    char *value_pointer;	/* storing values */
    char value[VALUE_SIZE];

    HTParentAnchor *anchor;	/* Given on creation */
    HTStream *sink;		/* Given on creation */

    char *boundary;		/* For multipart */
    char *set_cookie;		/* Set-Cookie */
    char *set_cookie2;		/* Set-Cookie2 */
    char *location;		/* Location */

    char *refresh_url;		/* "Refresh:" URL */

    HTFormat encoding;		/* Content-Transfer-Encoding */
    char *compression_encoding;
    HTFormat format;		/* Content-Type */
    HTStream *target;		/* While writing out */
    HTStreamClass targetClass;
d143 1
a143 1
    HTAtom *targetRep;		/* Converting into? */
d147 8
a154 7
 *  This function is for trimming off any paired
 *  open- and close-double quotes from header values.
 *  It does not parse the string for embedded quotes,
 *  and will not modify the string unless both the
 *  first and last characters are double-quotes. - FM
 */
void HTMIME_TrimDoubleQuotes(char *value)
d169 1
a169 1
	value[i] = cp[(i + 1)];
d172 1
a172 1
static BOOL content_is_compressed(HTStream *me)
d177 1
a177 1
	&& strcmp(encoding, "8bit") != 0
d185 1
a185 1
static void dequote(char *url)
d190 2
a191 2
    if (*url == '\'' && len > 1 && url[len - 1] == url[0]) {
	url[len - 1] = '\0';
d198 1
a198 1
static int pumpData(HTStream *me)
d207 8
a214 8
	 * Note that the Content-Type value was converted
	 * to lower case when we loaded into me->format,
	 * but there may have been a mixed or upper-case
	 * atom, so we'll force lower-casing again.  We
	 * also stripped spaces and double-quotes, but
	 * we'll make sure they're still gone from any
	 * charset parameter we check.  - FM
	 */
a217 1

d224 1
a224 1
		StrAllocCopy(cp3, cp2);		/* copy to mutilate more */
d226 3
a228 2
				 *cp4 != ';' && *cp4 != ':' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
d241 3
a243 2
		} else if (chndl < 0) {		/* got something but we don't
						   recognize it */
d247 5
a251 4
			 * UCLYhndl_for_unrec not defined :-( fallback to
			 * UCLYhndl_for_unspec which always valid.
			 */
			chndl = UCLYhndl_for_unspec;	/* always >= 0 */
d263 8
a270 9
		    LYUCcharset *p_in =
		    HTAnchor_getUCInfoStage(me->anchor,
					    UCT_STAGE_MIME);
		    LYUCcharset *p_out =
		    HTAnchor_setUCInfoStage(me->anchor,
					    current_char_set,
					    UCT_STAGE_HTEXT,
					    UCT_SETBY_DEFAULT);

d273 2
a274 2
			 * Try again.
			 */
d297 1
a297 6
		    if ((p_in->enc != UCT_ENC_CJK)
#ifndef EXP_JAPANESEUTF8_SUPPORT
			&& ((p_in->enc != UCT_ENC_UTF8)
			    || (p_out->enc != UCT_ENC_CJK))
#endif
			) {
d309 21
a329 19
		     * Cannot translate.  If according to some heuristic the
		     * given charset and the current display character both are
		     * likely to be like ISO-8859 in structure, pretend we have
		     * some kind of match.
		     */
		    BOOL given_is_8859 =
		    (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
			    isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like =
		    (BOOL) (given_is_8859 ||
			    !strncmp(cp4, "windows-", 8) ||
			    !strncmp(cp4, "cp12", 4) ||
			    !strncmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like =
		    (BOOL) (given_is_8859like &&
			    (strstr(LYchar_set_names[current_char_set],
				    "ISO-8859") ||
			     strstr(LYchar_set_names[current_char_set],
				    "windows-")));
d351 4
a354 3
		 * No charset parameter is present.  Ignore all other
		 * parameters, as we do when charset is present.  - FM
		 */
d362 5
a366 4
     * If we have an Expires header and haven't already set the no_cache
     * element for the anchor, check if we should set it based on that header. 
     * - FM
     */
d371 2
a372 2
	     * The value is zero, which we treat as an absolute no-cache
	     * directive.  - FM
d377 4
a380 3
	     * We have a Date header, so check if the value is less than or
	     * equal to that.  - FM
	     */
d387 3
a389 3
	     * We don't have a Date header, and the value is in past for us.  -
	     * FM
	     */
d434 1
a434 2
	    CTRACE((tfp,
		    "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
d438 3
a440 3
	     * Change the format to that for "www/compressed" and set up a
	     * stream to deal with it.  - FM
	     */
d448 1
a448 1
				   me->sink, me->anchor);
d457 4
a460 3
	 * Check for encoding and select state from there, someday, but until
	 * we have the relevant code, from now push straight through.  - FM
	 */
d479 1
a479 1
	    (me->isa->put_string) (me, txt);
d488 1
a488 1
static int dispatchField(HTStream *me)
a493 1

d495 1
a495 1
    while ((cp > me->value) && *(--cp) == ' ')	/* S/390 -- gil -- 0146 */
d497 2
a498 2
	 * Trim trailing spaces.
	 */
d529 2
a530 2
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
d534 2
a535 2
	 * Check whether to set no_cache for the anchor.  - FM
	 */
d591 2
a592 2
	 * Indicate in anchor.  - FM
	 */
d602 2
a603 2
	 * Indicate in anchor.  - FM
	 */
d606 7
a612 6
	 * It's not clear yet from existing RFCs and IDs whether we should be
	 * looking for file;, attachment;, and/or inline; before the
	 * filename=value, so we'll just search for "filename" followed by '='
	 * and just hope we get the intended value.  It is purely a suggested
	 * name, anyway.  - FM
	 */
d653 2
a654 2
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
d660 3
a662 3
	     * Save it to use as a flag for setting up a "www/compressed"
	     * target.  - FM
	     */
d666 3
a668 3
	     * Some server indicated "8bit", "7bit" or "binary"
	     * inappropriately.  We'll ignore it.  - FM
	     */
d684 2
a685 2
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
d696 2
a697 2
	 * Convert to integer and indicate in anchor.  - FM
	 */
d711 2
a712 2
	 * Indicate in anchor.  - FM
	 */
d722 2
a723 2
	 * Indicate in anchor.  - FM
	 */
d738 3
a740 2
	 * Force the Content-Transfer-Encoding value to all lower case.  - FM
	 */
d751 3
a753 3
	 * Force the Content-Type value to all lower case and strip spaces and
	 * double-quotes.  - FM
	 */
a760 1
	StrAllocCopy(me->anchor->content_type_params, me->value);
d769 2
a770 2
	 * Indicate in anchor.  - FM
	 */
d774 3
a776 2
	/* Do not trim double quotes:  an entity tag consists of an opaque
	 * quoted string, possibly prefixed by a weakness indicator.
d783 2
a784 2
	 * Indicate in anchor.  - FM
	 */
d794 2
a795 2
	 * Indicate in anchor.  - FM
	 */
d810 2
a811 2
	 * Indicate in anchor.  - FM
	 */
d836 2
a837 2
	 * Check whether to set no_cache for the anchor.  - FM
	 */
d869 2
a870 2
	 * Indicate in anchor if "YES" or "TRUE".  - FM
	 */
d877 3
a879 3
	     * If server explicitly tells us that it has changed its mind,
	     * reset flag in anchor.  - kw
	     */
d890 2
a891 2
	 * Indicate in anchor.  - FM
	 */
d956 1
a956 1
    default:			/* Should never get here */
d962 1
d964 3
a966 3
 *
 *			A C T I O N	R O U T I N E S
 */
d969 10
a978 9
 *	------------------
 *
 *	This is a FSM parser. It ignores field names it does not understand.
 *	Folded header fields are recognized.  Lines without a fieldname at
 *	the beginning (that are not folded continuation lines) are ignored
 *	as unknown field names.  Fields with empty values are not picked up.
 */
static void HTMIME_put_character(HTStream *me,
				 char c)
d981 1
a981 1
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
d986 4
a989 4
     * This slightly simple conversion just strips CR and turns LF to newline. 
     * On unix LF is \n but on Mac \n is CR for example.  See NetToText for an
     * implementation which preserves single CR or LF.
     */
d992 7
a998 8
	 * <sigh> This is evidence that at one time, this code supported
	 * local character sets other than ASCII.  But there is so much
	 * code in HTTP.c that depends on line_buffer's having been
	 * translated to local character set that I needed to put the
	 * FROMASCII translation there, leaving this translation purely
	 * destructive.  -- gil
	 */
	/* S/390 -- gil -- 0118 */
d1008 1
a1008 1
    switch (me->state) {
d1013 2
a1014 2
    case MIME_TRANSPARENT:	/* Not reached see above */
	(*me->targetClass.put_character) (me->target, c);
d1018 1
a1018 1
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
d1022 2
a1023 2
	if (c != '\n' && WHITE(c)) {	/* Folded line */
	    me->state = me->fold_state;		/* pop state before newline */
d1026 1
a1026 1
		!WHITE(*(me->value_pointer - 1))) {
d1058 1
a1058 2
	    CTRACE((tfp,
		    "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
d1072 1
a1072 2
	    CTRACE((tfp,
		    "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
d1123 1
a1123 1
	case '\n':		/* Blank line: End of Header! */
d1131 1
a1131 1
	    goto bad_field_name;
d1133 1
a1133 1
	}			/* switch on character */
d1136 1
a1136 1
    case miA:			/* Check for 'c','g' or 'l' */
d1143 1
a1143 2
	    CTRACE((tfp,
		    "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
d1161 2
a1162 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'g' or 'l'"));
d1165 1
a1165 1
	}			/* switch on character */
d1168 1
a1168 1
    case miAL:			/* Check for 'l' or 't' */
d1187 2
a1188 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'l' or 't'"));
d1191 1
a1191 1
	}			/* switch on character */
d1194 1
a1194 1
    case miC:			/* Check for 'a' or 'o' */
d1201 1
a1201 2
	    CTRACE((tfp,
		    "HTMIME: Was C, found A, checking for 'che-control:'\n"));
d1211 2
a1212 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
d1215 1
a1215 1
	}			/* switch on character */
d1218 1
a1218 1
    case miCO:			/* Check for 'n' or 'o' */
d1235 2
a1236 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 'o'"));
d1239 1
a1239 1
	}			/* switch on character */
d1242 1
a1242 1
    case miCON:		/* Check for 'n' or 't' */
d1261 2
a1262 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 't'"));
d1265 1
a1265 1
	}			/* switch on character */
d1268 1
a1268 1
    case miE:			/* Check for 't' or 'x' */
d1287 2
a1288 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'t' or 'x'"));
d1291 1
a1291 1
	}			/* switch on character */
d1294 1
a1294 1
    case miL:			/* Check for 'a', 'i' or 'o' */
d1301 1
a1301 2
	    CTRACE((tfp,
		    "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
d1321 2
a1322 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a', 'i' or 'o'"));
d1325 1
a1325 1
	}			/* switch on character */
d1328 1
a1328 1
    case miP:			/* Check for 'r' or 'u' */
d1345 2
a1346 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 'u'"));
d1349 1
a1349 1
	}			/* switch on character */
d1352 1
a1352 1
    case miPR:			/* Check for 'a' or 'o' */
d1367 1
a1367 2
	    CTRACE((tfp,
		    "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
d1371 2
a1372 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
d1375 1
a1375 1
	}			/* switch on character */
d1378 1
a1378 1
    case miR:			/* Check for 'e' */
d1386 2
a1387 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'e'"));
d1390 1
a1390 1
	}			/* switch on character */
d1393 1
a1393 1
    case miRE:			/* Check for 'a' or 'o' */
d1396 1
a1396 1
	case 'F':		/* nonstandard: Netscape */
d1412 2
a1413 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'f' or 't'"));
d1416 1
a1416 1
	}			/* switch on character */
d1419 1
a1419 1
    case miS:			/* Check for 'a' or 'e' */
d1436 2
a1437 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'e'"));
d1440 1
a1440 1
	}			/* switch on character */
d1443 1
a1443 1
    case miSE:			/* Check for 'r' or 't' */
d1462 2
a1463 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 't'"));
d1466 1
a1466 1
	}			/* switch on character */
d1469 1
a1469 1
    case miSET_COOKIE:		/* Check for ':' or '2' */
d1472 1
a1472 1
	    me->field = miSET_COOKIE1;	/* remember it */
d1485 2
a1486 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "':' or '2'"));
d1489 1
a1489 1
	}			/* switch on character */
d1492 1
a1492 1
    case miT:			/* Check for 'i' or 'r' */
d1507 1
a1507 2
	    CTRACE((tfp,
		    "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
d1511 2
a1512 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'i' or 'r'"));
d1515 1
a1515 1
	}			/* switch on character */
d1518 1
a1518 1
    case miU:			/* Check for 'p' or 'r' */
d1537 2
a1538 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'p' or 'r'"));
d1541 1
a1541 1
	}			/* switch on character */
d1544 1
a1544 1
    case miV:			/* Check for 'a' or 'i' */
d1563 2
a1564 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'i'"));
d1567 1
a1567 1
	}			/* switch on character */
d1570 1
a1570 1
    case miW:			/* Check for 'a' or 'w' */
d1585 1
a1585 2
	    CTRACE((tfp,
		    "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
d1589 2
a1590 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'w'"));
d1593 1
a1593 1
	}			/* switch on character */
d1596 1
a1596 1
    case miCHECK:		/* Check against string */
d1601 2
a1602 3
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, me->check_pointer - 1));
d1610 1
a1610 1
	switch (c) {
d1616 1
a1616 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
d1624 1
a1624 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
d1632 1
a1632 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
d1640 1
a1640 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
d1646 1
a1646 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
d1662 1
a1662 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
d1668 1
a1668 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
d1675 1
a1675 1
	}			/* switch on character */
d1681 1
a1681 1
	switch (c) {
d1687 1
a1687 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
d1695 1
a1695 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
d1703 1
a1703 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
d1710 1
a1710 1
	}			/* switch on character */
d1716 1
a1716 1
	switch (c) {
d1722 1
a1722 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
d1730 1
a1730 2
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
d1737 1
a1737 1
	}			/* switch on character */
d1782 1
a1782 1
	me->field = me->state;	/* remember it */
d1794 2
a1795 2
	     * Skip white space.
	     */
d1803 2
a1804 2
      GET_VALUE:
	if (c != '\n') {	/* Not end of line */
a1820 1
    }				/* switch on state */
d1822 2
a1823 11
#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, c);
    if (me->state == MIME_TRANSPARENT) {
	HTChunkTerminate(&me->anchor->http_headers);
	CTRACE((tfp, "Server Headers:\n%.*s\n",
		me->anchor->http_headers.size,
		me->anchor->http_headers.data));
	CTRACE((tfp, "Server Content-Type:%s\n",
		me->anchor->content_type_params));
    }
#endif
d1826 1
a1826 1
  value_too_long:
d1829 1
a1829 1
  bad_field_name:		/* Ignore it */
d1831 1
d1833 1
a1833 3
#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, c);
#endif
a1834 1
    return;
a1835 1
}
d1838 7
a1844 6
 *	---------------
 *
 *	Strings must be smaller than this buffer size.
 */
static void HTMIME_put_string(HTStream *me,
			      const char *s)
d1846 1
a1846 1
    const char *p;
d1849 1
a1849 1
	(*me->targetClass.put_string) (me->target, s);
d1854 1
a1854 1
	for (p = s; *p; p++)
d1859 1
d1861 6
a1866 5
 *	------------
 */
static void HTMIME_write(HTStream *me,
			 const char *s,
			 int l)
d1868 1
a1868 1
    const char *p;
d1871 1
a1871 1
	(*me->targetClass.put_block) (me->target, s, l);
d1876 1
a1876 1
	for (p = s; p < s + l; p++)
d1881 1
d1883 5
a1887 4
 *	-------------------
 *
 */
static void HTMIME_free(HTStream *me)
d1893 1
a1893 1
	    (*me->targetClass._free) (me->target);
d1900 3
a1902 2
static void HTMIME_abort(HTStream *me,
			 HTError e)
d1908 1
a1908 1
	    (*me->targetClass._abort) (me->target, e);
d1913 1
d1915 2
a1916 2
 *	-----------------------
 */
d1919 6
a1924 6
    "MIMEParser",
    HTMIME_free,
    HTMIME_abort,
    HTMIME_put_character,
    HTMIME_put_string,
    HTMIME_write
d1927 1
d1929 6
a1934 5
 *	-------------------------
 */
HTStream *HTMIMEConvert(HTPresentation *pres,
			HTParentAnchor *anchor,
			HTStream *sink)
d1936 1
a1936 1
    HTStream *me;
a1938 1

d1941 3
a1943 3
    me->isa = &HTMIME;
    me->sink = sink;
    me->anchor = anchor;
a1948 5
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&me->anchor->http_headers);
    HTChunkInit(&me->anchor->http_headers, 128);
#endif
    FREE(me->anchor->content_type_params);
d1961 2
a1962 2
    me->target = NULL;
    me->state = miBEGINNING_OF_LINE;
d1964 4
a1967 4
     * Sadly enough, change this to always default to WWW_HTML to parse all
     * text as HTML for the users.
     * GAB 06-30-94
     * Thanks to Robert Rowland robert@@cyclops.pei.edu
d1969 3
a1971 2
     * After discussion of the correct handline, should be application/octet-
     * stream or unknown; causing servers to send a correct content type.
d1973 8
a1980 9
     * The consequence of using WWW_UNKNOWN is that you end up downloading as a
     * binary file what 99.9% of the time is an HTML file, which should have
     * been rendered or displayed.  So sadly enough, I'm changing it back to
     * WWW_HTML, and it will handle the situation like Mosaic does, and as
     * Robert Rowland suggested, because being functionally correct 99.9% of
     * the time is better than being technically correct but functionally
     * nonsensical.  - FM
     */
    /***
d1982 8
a1989 8
    ***/
    me->format = WWW_HTML;
    me->targetRep = pres->rep_out;
    me->boundary = NULL;	/* Not set yet */
    me->set_cookie = NULL;	/* Not set yet */
    me->set_cookie2 = NULL;	/* Not set yet */
    me->refresh_url = NULL;	/* Not set yet */
    me->encoding = 0;		/* Not set yet */
d1991 1
a1991 1
    me->net_ascii = NO;		/* Local character set */
d2001 4
a2004 3
HTStream *HTNetMIME(HTPresentation *pres,
		    HTParentAnchor *anchor,
		    HTStream *sink)
d2006 1
a2006 2
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

d2014 4
a2017 3
HTStream *HTMIMERedirect(HTPresentation *pres,
			 HTParentAnchor *anchor,
			 HTStream *sink)
d2019 1
a2019 2
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

d2030 4
a2033 4
 *		==================================
 *
 *	K&Rized and added 07-Jun-96 by FM, based on:
 *
d2035 24
a2058 24
 *
 *	ISO-2022-JP handling routines
 *			&
 *	MIME decode routines (quick hack just for ISO-2022-JP)
 *
 *		Thu Jan 25 10:11:42 JST 1996
 *
 *  Copyright (C) 1994, 1995, 1996
 *  Shuichi Ichikawa (ichikawa@@nuee.nagoya-u.ac.jp)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either versions 2, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with SKK, see the file COPYING.  If not, write to the Free
 *  Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
d2061 7
a2067 7
 *  MIME decoding routines
 *
 *	Written by S. Ichikawa,
 *	partially inspired by encdec.c of <jh@@efd.lth.se>.
 *	Assume caller's buffer is LINE_LENGTH bytes, these decode to
 *	no longer than the input strings.
 */
d2072 1
a2072 1
#include <LYCharVals.h>		/* S/390 -- gil -- 0163 */
d2076 1
a2076 1
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
d2080 3
a2082 2
void HTmmdec_base64(char *t,
		    char *s)
d2084 2
a2085 2
    int d, count, j, val;
    char buf[LINE_LENGTH], *bp, nw[4], *p;
d2097 6
a2102 6
	    if (!(p = strchr(HTmm64, s[j]))) {
		return;
	    }
	    d = p - HTmm64;
	    d <<= (3 - j) * 6;
	    val += d;
d2105 2
a2106 2
	    nw[j] = (char) (val & 255);
	    val >>= 8;
d2119 3
a2121 2
void HTmmdec_quote(char *t,
		   char *s)
d2123 1
a2123 1
    char buf[LINE_LENGTH], cval, *bp, *p;
d2125 1
a2125 1
    for (bp = buf; *s;) {
d2154 5
a2158 4
 *	HTmmdecode for ISO-2022-JP - FM
 */
void HTmmdecode(char *trg,
		char *str)
d2162 1
a2162 1
    int base64, quote;
d2166 1
a2166 1
    for (s = str, u = buf; *s;) {
d2180 2
a2181 2
		     t >= str && (*t == ' ' || *t == '\t'); t--) {
		    u--;
d2184 1
a2184 1
	    for (s += 16, t = mmbuf; *s;) {
d2201 1
a2201 1
	    for (t = mmbuf; *t;)
d2213 1
a2213 1
  end:
d2218 6
a2223 5
 *  Insert ESC where it seems lost.
 *  (The author of this function "rjis" is S. Ichikawa.)
 */
int HTrjis(char *t,
	   char *s)
d2233 1
a2233 1
    for (p = buf; *s;) {
d2235 1
a2235 1
	    if (HTmaybekanji((int) s[2], (int) s[3])) {
d2256 1
a2256 1
    *p = *s;			/* terminate string */
d2263 5
a2267 5
 *  The following function "maybekanji" is derived from
 *  RJIS-1.0 by Mr. Hironobu Takahashi.
 *  Maybekanji() is included here under the courtesy of the author.
 *  The original comment of rjis.c is also included here.
 */
d2289 3
a2291 2
int HTmaybekanji(int c1,
		 int c2)
d2299 3
a2301 3
    switch (c1 - 32) {
    case 2:
	if ((14 < c2) && (c2 < 26))
d2303 1
a2303 1
	if ((33 < c2) && (c2 < 42))
d2305 1
a2305 1
	if ((48 < c2) && (c2 < 60))
d2307 1
a2307 1
	if ((74 < c2) && (c2 < 82))
d2309 1
a2309 1
	if ((89 < c2) && (c2 < 94))
d2312 1
a2312 1
    case 3:
d2315 1
a2315 1
	if ((25 < c2) && (c2 < 33))
d2317 1
a2317 1
	if ((58 < c2) && (c2 < 65))
d2322 1
a2322 1
    case 4:
d2326 1
a2326 1
    case 5:
d2330 2
a2331 2
    case 6:
	if ((24 < c2) && (c2 < 33))
d2336 2
a2337 2
    case 7:
	if ((33 < c2) && (c2 < 49))
d2342 1
a2342 1
    case 8:
d2346 1
a2346 1
    case 47:
d2350 1
a2350 1
    case 84:
@


1.1.3.5
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d158 1
a158 1
    if (!(cp && *cp) || *cp != '"')
d162 1
a162 1
    if (cp[(i - 1)] != '"')
d222 1
a222 1
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
d225 1
a225 1
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
a257 11
		} else {
		    /*
		     * Something like 'big5' - we cannot translate it, but
		     * the user may still be able to navigate the links.
		     */
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
d626 1
a626 1
	if (*me->anchor->SugFname == '"') {
d628 1
a628 1
			     '"')) != NULL) {
d752 1
a752 1
	    if (me->value[i] != ' ' && me->value[i] != '"') {
@


1.1.3.6
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a17 1
#include <HTFile.h>
a170 4
/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.
 */
a173 1
    BOOL result = (HTEncodingToCompressType(encoding) != cftNone);
d175 4
a178 2
    CTRACE((tfp, "content is%s compressed\n", result ? "" : " NOT"));
    return result;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a15 1
#include <HTTP.h>		/* for redirecting_url */
d29 1
d35 1
a35 1
typedef enum {
d103 1
a103 1
	MIME_NET_ASCII,		/* Translate from net ascii */
d108 1
a108 1
#define VALUE_SIZE 5120		/* @@@@@@@@@@@@@@ Arbitrary? */
a116 3
	BOOL			head_only;	/* only parsing header */
	BOOL			pickup_redirection; /* parsing for location */
	BOOL			no_streamstack; /* use sink directly */
d122 1
a122 1
	HTParentAnchor *	anchor;		/* Given on creation */
a127 1
	char *			location;	/* Location */
d131 2
a132 2
	HTFormat		format;		/* Content-Type */
	HTStream *		target;		/* While writing out */
d146 1
a146 1
	char *,		value)
a163 741
PRIVATE int pumpData ARGS1(HTStream *, me)
{
    if (strchr(HTAtom_name(me->format), ';') != NULL) {
	char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;

	CTRACE((tfp, "HTMIME: Extended MIME Content-Type is %s\n",
		HTAtom_name(me->format)));
	StrAllocCopy(cp, HTAtom_name(me->format));
	/*
	**	Note that the Content-Type value was converted
	**	to lower case when we loaded into me->format,
	**	but there may have been a mixed or upper-case
	**	atom, so we'll force lower-casing again.  We
	**	also stripped spaces and double-quotes, but
	**	we'll make sure they're still gone from any
	**	charset parameter we check. - FM
	*/
	LYLowerCase(cp);
	if ((cp1 = strchr(cp, ';')) != NULL) {
	    BOOL chartrans_ok = NO;
	    if ((cp2 = strstr(cp1, "charset")) != NULL) {
		int chndl;

		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
		    cp2++;
		StrAllocCopy(cp3, cp2); /* copy to mutilate more */
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '\"' &&
				 *cp4 != ';'  && *cp4 != ':' &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
		*cp4 = '\0';
		cp4 = cp3;
		chndl = UCGetLYhndl_byMIME(cp3);
		if (UCCanTranslateFromTo(chndl,
					 current_char_set)) {
		    chartrans_ok = YES;
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		}
		else if (chndl < 0) {/* got something but we don't
					recognize it */
		    chndl = UCLYhndl_for_unrec;
		    if (chndl < 0)
			/*
			**  UCLYhndl_for_unrec not defined :-(
			**  fallback to UCLYhndl_for_unspec
			**  which always valid.
			*/
			chndl = UCLYhndl_for_unspec;  /* always >= 0 */
		    if (UCCanTranslateFromTo(chndl,
					     current_char_set)) {
			chartrans_ok = YES;
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
			HTAnchor_setUCInfoStage(me->anchor, chndl,
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		}
		if (chartrans_ok) {
		    LYUCcharset * p_in =
			HTAnchor_getUCInfoStage(me->anchor,
						UCT_STAGE_MIME);
		    LYUCcharset * p_out =
			HTAnchor_setUCInfoStage(me->anchor,
						current_char_set,
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		    if (!p_out)
			/*
			**	Try again.
			*/
			p_out =
			    HTAnchor_getUCInfoStage(me->anchor,
						    UCT_STAGE_HTEXT);

		    if (!strcmp(p_in->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_HTEXT),
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		    if (!strcmp(p_out->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_MIME),
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		    }
		    if (p_in->enc != UCT_ENC_CJK) {
			HTCJK = NOCJK;
			if (!(p_in->codepoints &
			      UCT_CP_SUBSETOF_LAT1) &&
			    chndl == current_char_set) {
			    HTPassEightBitRaw = TRUE;
			}
		    } else if (p_out->enc == UCT_ENC_CJK) {
			Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
		    }
		} else {
		    /*
		    **  Cannot translate.
		    **  If according to some heuristic the given
		    **  charset and the current display character
		    **  both are likely to be like ISO-8859 in
		    **  structure, pretend we have some kind
		    **  of match.
		    */
		    BOOL given_is_8859
			= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
				  isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like
			= (BOOL) (given_is_8859 ||
				  !strncmp(cp4, "windows-", 8) ||
				  !strncmp(cp4, "cp12", 4) ||
				  !strncmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like
			= (BOOL) (given_is_8859like &&
				  (strstr(LYchar_set_names[current_char_set],
					  "ISO-8859") ||
				   strstr(LYchar_set_names[current_char_set],
					  "windows-")));

		    if (given_and_display_8859like) {
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
		    }
		    if (given_is_8859) {
			cp1 = &cp4[10];
			while (*cp1 &&
			       isdigit(UCH(*cp1)))
			    cp1++;
			*cp1 = '\0';
		    }
		    if (given_and_display_8859like) {
			StrAllocCopy(me->anchor->charset, cp4);
			HTPassEightBitRaw = TRUE;
		    }
		    HTAlert(*cp4 ? cp4 : me->anchor->charset);
		}
		FREE(cp3);
	    } else {
		/*
		**	No charset parameter is present.
		**	Ignore all other parameters, as
		**	we do when charset is present. - FM
		*/
		*cp1 = '\0';
		me->format = HTAtom_for(cp);
	    }
	}
	FREE(cp);
    }
    /*
    **  If we have an Expires header and haven't
    **  already set the no_cache element for the
    **  anchor, check if we should set it based
    **  on that header. - FM
    */
    if (me->anchor->no_cache == FALSE &&
	me->anchor->expires != NULL) {
	if (!strcmp(me->anchor->expires, "0")) {
	    /*
	     *  The value is zero, which we treat as
	     *  an absolute no-cache directive. - FM
	     */
	    me->anchor->no_cache = TRUE;
	} else if (me->anchor->date != NULL) {
	    /*
	    **  We have a Date header, so check if
	    **  the value is less than or equal to
	    **  that. - FM
	    */
	    if (LYmktime(me->anchor->expires, TRUE) <=
		LYmktime(me->anchor->date, TRUE)) {
		me->anchor->no_cache = TRUE;
	    }
	} else if (LYmktime(me->anchor->expires, FALSE) <= 0) {
	    /*
	    **  We don't have a Date header, and
	    **  the value is in past for us. - FM
	    */
	    me->anchor->no_cache = TRUE;
	}
    }
    StrAllocCopy(me->anchor->content_type,
		 HTAtom_name(me->format));

    if (me->set_cookie != NULL || me->set_cookie2 != NULL) {
	LYSetCookie(me->set_cookie,
		    me->set_cookie2,
		    me->anchor->address);
	FREE(me->set_cookie);
	FREE(me->set_cookie2);
    }
    if (me->pickup_redirection) {
	if (me->location && *me->location) {
	    redirecting_url = me->location;
	    me->location = NULL;
	    if (me->targetRep != WWW_DEBUG || me->sink)
		me->head_only = YES;

	} else {
	    permanent_redirection = FALSE;
	    if (me->location) {
		CTRACE((tfp, "HTTP: 'Location:' is zero-length!\n"));
		HTAlert(REDIRECTION_WITH_BAD_LOCATION);
	    }
	    CTRACE((tfp, "HTTP: Failed to pick up location.\n"));
	    if (me->location) {
		FREE(me->location);
	    } else {
		HTAlert(REDIRECTION_WITH_NO_LOCATION);
	    }
	}
    }
    if (me->head_only) {
	/* We are done! - kw */
	me->state = MIME_IGNORE;
	return HT_OK;
    }

    if (me->no_streamstack) {
	me->target = me->sink;
    } else {
	if (!me->compression_encoding) {
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	} else {
	    /*
	    **	Change the format to that for "www/compressed"
	    **	and set up a stream to deal with it. - FM
	    */
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format)));
	    me->format = HTAtom_for("www/compressed");
	    CTRACE((tfp, "        Treating as '%s'.  Converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	    FREE(me->compression_encoding);
	}
	me->target = HTStreamStack(me->format, me->targetRep,
				   me->sink , me->anchor);
	if (!me->target) {
	    CTRACE((tfp, "HTMIME: Can't translate! ** \n"));
	    me->target = me->sink;	/* Cheat */
	}
    }
    if (me->target) {
	me->targetClass = *me->target->isa;
	/*
	**	Check for encoding and select state from there,
	**	someday, but until we have the relevant code,
	**	from now push straight through. - FM
	*/
	me->state = MIME_TRANSPARENT;	/* Pump rest of data right through */
    } else {
	me->state = MIME_IGNORE;	/* What else to do? */
    }
    return HT_OK;
}

PRIVATE int dispatchField ARGS1(HTStream *, me)
{
    int i, j;
    char *cp;

    *me->value_pointer = '\0';
    cp = me->value_pointer;
    while ((cp > me->value) && *(--cp) == ' ')  /* S/390 -- gil -- 0146 */
	/*
	**  Trim trailing spaces.
	*/
	*cp = '\0';

    switch (me->field) {
    case miACCEPT_RANGES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
		me->value));
	break;
    case miAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Age: '%s'\n",
		me->value));
	break;
    case miALLOW:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Allow: '%s'\n",
		me->value));
	break;
    case miALTERNATES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Alternates: '%s'\n",
		me->value));
	break;
    case miCACHE_CONTROL:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cache-Control: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Convert to lowercase and indicate in anchor. - FM
	*/
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->cache_control, me->value);
	/*
	**  Check whether to set no_cache for the anchor. - FM
	*/
	{
	    char *cp1, *cp0 = me->value;

	    while ((cp1 = strstr(cp0, "no-cache")) != NULL) {
		cp1 += 8;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '\0' || *cp1 == ';') {
		    me->anchor->no_cache = TRUE;
		    break;
		}
		cp0 = cp1;
	    }
	    if (me->anchor->no_cache == TRUE)
		break;
	    cp0 = me->value;
	    while ((cp1 = strstr(cp0, "max-age")) != NULL) {
		cp1 += 7;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '=') {
		    cp1++;
		    while (*cp1 != '\0' && WHITE(*cp1))
			cp1++;
		    if (isdigit(UCH(*cp1))) {
			cp0 = cp1;
			while (isdigit(UCH(*cp1)))
			    cp1++;
			if (*cp0 == '0' && cp1 == (cp0 + 1)) {
			    me->anchor->no_cache = TRUE;
			    break;
			}
		    }
		}
		cp0 = cp1;
	    }
	}
	break;
    case miCOOKIE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cookie: '%s'\n",
		me->value));
	break;
    case miCONNECTION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Connection: '%s'\n",
		me->value));
	break;
    case miCONTENT_BASE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Base: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_base, me->value);
	break;
    case miCONTENT_DISPOSITION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Disposition: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_disposition, me->value);
	/*
	**  It's not clear yet from existing RFCs and IDs
	**  whether we should be looking for file;, attachment;,
	**  and/or inline; before the filename=value, so we'll
	**  just search for "filename" followed by '=' and just
	**  hope we get the intended value.  It is purely a
	**  suggested name, anyway. - FM
	*/
	cp = me->anchor->content_disposition;
	while (*cp != '\0' && strncasecomp(cp, "filename", 8))
	    cp++;
	if (*cp == '\0')
	    break;
	cp += 8;
	while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
	    cp++;
	if (*cp == '\0')
	    break;
	while (*cp != '\0' && WHITE(*cp))
	    cp++;
	if (*cp == '\0')
	    break;
	StrAllocCopy(me->anchor->SugFname, cp);
	if (*me->anchor->SugFname == '\"') {
	    if ((cp = strchr((me->anchor->SugFname + 1),
			     '\"')) != NULL) {
		*(cp + 1) = '\0';
		HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
	    } else {
		FREE(me->anchor->SugFname);
		break;
	    }
	}
	cp = me->anchor->SugFname;
	while (*cp != '\0' && !WHITE(*cp))
	    cp++;
	*cp = '\0';
	if (*me->anchor->SugFname == '\0')
	    FREE(me->anchor->SugFname);
	break;
    case miCONTENT_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value) ||
	    !strcasecomp(me->value, "identity"))
	    break;
	/*
	**  Convert to lowercase and indicate in anchor. - FM
	*/
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_encoding, me->value);
	FREE(me->compression_encoding);
	if (!strcmp(me->value, "8bit") ||
	    !strcmp(me->value, "7bit") ||
	    !strcmp(me->value, "binary")) {
	    /*
	    **	Some server indicated "8bit", "7bit" or "binary"
	    **	inappropriately.  We'll ignore it. - FM
	    */
	    CTRACE((tfp, "                Ignoring it!\n"));
	} else {
	    /*
	    **	Save it to use as a flag for setting
	    **	up a "www/compressed" target. - FM
	    */
	    StrAllocCopy(me->compression_encoding, me->value);
	}
	break;
    case miCONTENT_FEATURES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Features: '%s'\n",
		me->value));
	break;
    case miCONTENT_LANGUAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Language: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Convert to lowercase and indicate in anchor. - FM
	*/
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_language, me->value);
	break;
    case miCONTENT_LENGTH:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Length: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Convert to integer and indicate in anchor. - FM
	*/
	me->anchor->content_length = atoi(me->value);
	if (me->anchor->content_length < 0)
	    me->anchor->content_length = 0;
	CTRACE((tfp, "        Converted to integer: '%d'\n",
		me->anchor->content_length));
	break;
    case miCONTENT_LOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Location: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_location, me->value);
	break;
    case miCONTENT_MD5:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-MD5: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->content_md5, me->value);
	break;
    case miCONTENT_RANGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Range: '%s'\n",
		me->value));
	break;
    case miCONTENT_TRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Force the Content-Transfer-Encoding value
	**  to all lower case. - FM
	*/
	LYLowerCase(me->value);
	me->encoding = HTAtom_for(me->value);
	break;
    case miCONTENT_TYPE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Type: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Force the Content-Type value to all lower case
	**  and strip spaces and double-quotes. - FM
	*/
	for (i = 0, j = 0; me->value[i]; i++) {
	    if (me->value[i] != ' ' && me->value[i] != '\"') {
		me->value[j++] = (char) TOLOWER(me->value[i]);
	    }
	}
	me->value[j] = '\0';
	me->format = HTAtom_for(me->value);
	break;
    case miDATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Date: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->date, me->value);
	break;
    case miETAG:
	/*  Do not trim double quotes:
	 *  an entity tag consists of an opaque quoted string,
	 *  possibly prefixed by a weakness indicator.
	 */
	CTRACE((tfp, "HTMIME: PICKED UP ETag: %s\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->ETag, me->value);
	break;
    case miEXPIRES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Expires: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->expires, me->value);
	break;
    case miKEEP_ALIVE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Keep-Alive: '%s'\n",
		me->value));
	break;
    case miLAST_MODIFIED:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Last-Modified: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->last_modified, me->value);
	break;
    case miLINK:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Link: '%s'\n",
		me->value));
	break;
    case miLOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Location: '%s'\n",
		me->value));
	if (me->pickup_redirection && !me->location) {
	    StrAllocCopy(me->location, me->value);
	} else {
	    CTRACE((tfp, "HTMIME: *** Ignoring Location!\n"));
	}
	break;
    case miPRAGMA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Pragma: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Check whether to set no_cache for the anchor. - FM
	*/
	if (!strcmp(me->value, "no-cache"))
	    me->anchor->no_cache = TRUE;
	break;
    case miPROXY_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
		me->value));
	break;
    case miPUBLIC:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Public: '%s'\n",
		me->value));
	break;
    case miRETRY_AFTER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Retry-After: '%s'\n",
		me->value));
	break;
    case miSAFE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Safe: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor if "YES" or "TRUE". - FM
	*/
	if (!strcasecomp(me->value, "YES") ||
	    !strcasecomp(me->value, "TRUE")) {
	    me->anchor->safe = TRUE;
	} else if (!strcasecomp(me->value, "NO") ||
		   !strcasecomp(me->value, "FALSE")) {
	    /*
	    **  If server explicitly tells us that it has changed
	    **  its mind, reset flag in anchor. - kw
	    */
	    me->anchor->safe = FALSE;
	}
	break;
    case miSERVER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Server: '%s'\n",
		me->value));
	if (!(me->value && *me->value))
	    break;
	/*
	**  Indicate in anchor. - FM
	*/
	StrAllocCopy(me->anchor->server, me->value);
	break;
    case miSET_COOKIE1:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie: '%s'\n",
		me->value));
	if (me->set_cookie == NULL) {
	    StrAllocCopy(me->set_cookie, me->value);
	} else {
	    StrAllocCat(me->set_cookie, ", ");
	    StrAllocCat(me->set_cookie, me->value);
	}
	break;
    case miSET_COOKIE2:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
		me->value));
	if (me->set_cookie2 == NULL) {
	    StrAllocCopy(me->set_cookie2, me->value);
	} else {
	    StrAllocCat(me->set_cookie2, ", ");
	    StrAllocCat(me->set_cookie2, me->value);
	}
	break;
    case miTITLE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Title: '%s'\n",
		me->value));
	break;
    case miTRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
		me->value));
	break;
    case miUPGRADE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Upgrade: '%s'\n",
		me->value));
	break;
    case miURI:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP URI: '%s'\n",
		me->value));
	break;
    case miVARY:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Vary: '%s'\n",
		me->value));
	break;
    case miVIA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Via: '%s'\n",
		me->value));
	break;
    case miWARNING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Warning: '%s'\n",
		me->value));
	break;
    case miWWW_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
		me->value));
	break;
    default:		/* Should never get here */
	return HT_ERROR;
    }
    return HT_OK;
}


d172 3
a174 4
**	This is a FSM parser. It ignores field names it does not understand.
**	Folded header fields are recognized.  Lines without a fieldname at
**	the beginning (that are not folded continuation lines) are ignored
**	as unknown field names.  Fields with empty values are not picked up.
d180 2
a225 6
	    if (me->state == miGET_VALUE &&
		me->value_pointer && me->value_pointer != me->value &&
		!WHITE(*(me->value_pointer-1))) {
		c = ' ';
		goto GET_VALUE;	/* will add space to value if it fits - kw */
	    }
a226 4
	} else if (me->fold_state == miGET_VALUE) {
	    /* Got a field, and now we know it's complete - so
	     * act on it. - kw */
	    dispatchField(me);
d228 2
a229 1
	/* FALLTHRU */
d237 1
a237 1
	    CTRACE((tfp, "HTMIME: Got 'A' at beginning of line, state now A\n"));
d243 1
a243 1
	    CTRACE((tfp, "HTMIME: Got 'C' at beginning of line, state now C\n"));
d251 1
a251 1
	    CTRACE((tfp, "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
d257 1
a257 1
	    CTRACE((tfp, "HTMIME: Got 'E' at beginning of line, state now E\n"));
d265 1
a265 1
	    CTRACE((tfp, "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
d271 1
a271 1
	    CTRACE((tfp, "HTMIME: Got 'L' at beginning of line, state now L\n"));
d277 1
a277 1
	    CTRACE((tfp, "HTMIME: Got 'P' at beginning of line, state now P\n"));
d285 1
a285 1
	    CTRACE((tfp, "HTMIME: Got 'R' at beginning of line, checking for 'etry-after'\n"));
d291 1
a291 1
	    CTRACE((tfp, "HTMIME: Got 'S' at beginning of line, state now S\n"));
d297 1
a297 1
	    CTRACE((tfp, "HTMIME: Got 'T' at beginning of line, state now T\n"));
d303 1
a303 1
	    CTRACE((tfp, "HTMIME: Got 'U' at beginning of line, state now U\n"));
d309 1
a309 1
	    CTRACE((tfp, "HTMIME: Got 'V' at beginning of line, state now V\n"));
d315 1
a315 1
	    CTRACE((tfp, "HTMIME: Got 'W' at beginning of line, state now W\n"));
d321 233
a553 1
		pumpData(me);
d570 1
a570 1
	    CTRACE((tfp, "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
d578 1
a578 1
	    CTRACE((tfp, "HTMIME: Was A, found G, checking for 'e:'\n"));
d584 1
a584 1
	    CTRACE((tfp, "HTMIME: Was A, found L, state now AL'\n"));
d588 2
a589 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'g' or 'l'"));
d602 1
a602 1
	    CTRACE((tfp, "HTMIME: Was AL, found L, checking for 'ow:'\n"));
d610 1
a610 1
	    CTRACE((tfp, "HTMIME: Was AL, found T, checking for 'ernates:'\n"));
d614 2
a615 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'l' or 't'"));
d628 1
a628 1
	    CTRACE((tfp, "HTMIME: Was C, found A, checking for 'che-control:'\n"));
d634 1
a634 1
	    CTRACE((tfp, "HTMIME: Was C, found O, state now CO'\n"));
d638 2
a639 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
d650 1
a650 1
	    CTRACE((tfp, "HTMIME: Was CO, found N, state now CON\n"));
d658 1
a658 1
	    CTRACE((tfp, "HTMIME: Was CO, found O, checking for 'kie:'\n"));
d662 2
a663 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 'o'"));
d669 1
a669 1
    case miCON:				/* Check for 'n' or 't' */
d676 1
a676 1
	    CTRACE((tfp, "HTMIME: Was CON, found N, checking for 'ection:'\n"));
d684 1
a684 1
	    CTRACE((tfp, "HTMIME: Was CON, found T, checking for 'ent-'\n"));
d688 2
a689 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 't'"));
d702 1
a702 1
	    CTRACE((tfp, "HTMIME: Was E, found T, checking for 'ag:'\n"));
d710 1
a710 1
	    CTRACE((tfp, "HTMIME: Was E, found X, checking for 'pires:'\n"));
d714 2
a715 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'t' or 'x'"));
d728 1
a728 1
	    CTRACE((tfp, "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
d736 1
a736 1
	    CTRACE((tfp, "HTMIME: Was L, found I, checking for 'nk:'\n"));
d744 1
a744 1
	    CTRACE((tfp, "HTMIME: Was L, found O, checking for 'cation:'\n"));
d748 2
a749 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a', 'i' or 'o'"));
d760 1
a760 1
	    CTRACE((tfp, "HTMIME: Was P, found R, state now PR'\n"));
d768 1
a768 1
	    CTRACE((tfp, "HTMIME: Was P, found U, checking for 'blic:'\n"));
d772 2
a773 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 'u'"));
d786 1
a786 1
	    CTRACE((tfp, "HTMIME: Was PR, found A, checking for 'gma'\n"));
d794 1
a794 1
	    CTRACE((tfp, "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
d798 2
a799 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
d812 1
a812 1
	    CTRACE((tfp, "HTMIME: Was S, found A, checking for 'fe:'\n"));
d818 1
a818 1
	    CTRACE((tfp, "HTMIME: Was S, found E, state now SE'\n"));
d822 2
a823 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'e'"));
d836 1
a836 1
	    CTRACE((tfp, "HTMIME: Was SE, found R, checking for 'ver'\n"));
d844 1
a844 1
	    CTRACE((tfp, "HTMIME: Was SE, found T, checking for '-cookie'\n"));
d848 2
a849 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 't'"));
d860 1
a860 1
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found :, processing\n"));
d867 1
a867 1
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n"));
d871 2
a872 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "':' or '2'"));
d885 1
a885 1
	    CTRACE((tfp, "HTMIME: Was T, found I, checking for 'tle:'\n"));
d893 1
a893 1
	    CTRACE((tfp, "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
d897 2
a898 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'i' or 'r'"));
d911 1
a911 1
	    CTRACE((tfp, "HTMIME: Was U, found P, checking for 'grade:'\n"));
d919 1
a919 1
	    CTRACE((tfp, "HTMIME: Was U, found R, checking for 'i:'\n"));
d923 2
a924 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'p' or 'r'"));
d937 1
a937 1
	    CTRACE((tfp, "HTMIME: Was V, found A, checking for 'ry:'\n"));
d945 1
a945 1
	    CTRACE((tfp, "HTMIME: Was V, found I, checking for 'a:'\n"));
d949 2
a950 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'i'"));
d963 1
a963 1
	    CTRACE((tfp, "HTMIME: Was W, found A, checking for 'rning:'\n"));
d971 1
a971 1
	    CTRACE((tfp, "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
d975 2
a976 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'w'"));
d987 2
a988 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, me->check_pointer - 1));
d994 1
a994 1
	CTRACE((tfp, "HTMIME: in case CONTENT_\n"));
d1002 1
a1002 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
d1010 1
a1010 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
d1018 1
a1018 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
d1026 1
a1026 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
d1032 1
a1032 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
d1040 1
a1040 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n"));
d1048 1
a1048 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
d1054 1
a1054 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
d1058 1
a1058 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found nothing; bleah\n"));
d1065 1
a1065 1
	CTRACE((tfp, "HTMIME: in case CONTENT_L\n"));
d1073 1
a1073 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
d1081 1
a1081 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
d1089 1
a1089 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
d1093 1
a1093 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found nothing; bleah\n"));
d1100 1
a1100 1
	CTRACE((tfp, "HTMIME: in case CONTENT_T\n"));
d1108 1
a1108 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
d1116 1
a1116 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
d1120 1
a1120 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found nothing; bleah\n"));
d1173 3
a1175 3
	    me->fold_state = me->state;
	    me->state = miNEWLINE;
	    break;
d1188 452
a1639 2
    GET_VALUE:
	if (c != '\n') {			/* Not end of line */
d1647 1
a1647 1
	/* Fall through (if end of line) */
d1651 1
a1652 1
	    me->state = miNEWLINE;
d1662 1
a1662 1
    CTRACE((tfp, "HTMIME: *** Syntax error. (string too long)\n"));
d1664 1
a1664 1
bad_field_name:				/* Ignore it */
d1687 1
a1687 1
	CTRACE((tfp, "HTMIME:  %s\n", s));
d1709 1
a1709 1
	CTRACE((tfp, "HTMIME:  %.*s\n", l, s));
d1724 3
a1726 7
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._free)(me->target);
	FREE(me);
    }
d1735 3
a1737 7
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._abort)(me->target, e);
	FREE(me);
    }
d1765 1
a1765 1
    me = typecalloc(HTStream);
a1839 15
PUBLIC HTStream* HTMIMERedirect ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
{
    HTStream* me = HTMIMEConvert(pres,anchor, sink);
    if (!me)
	return NULL;

    me->pickup_redirection = YES;
    if (me->targetRep == WWW_DEBUG && sink)
	me->no_streamstack = YES;
    return me;
}

a1875 2
**	Assume caller's buffer is LINE_LENGTH bytes, these decode to
**	no longer than the input strings.
d1877 1
a1877 1
#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
d1890 2
a1891 2
	char *,		t,
	char *,		s)
d1894 1
a1894 1
    char  buf[LINE_LENGTH], *bp, nw[4], *p;
d1914 1
a1914 1
		nw[j] = (char) (val & 255);
d1929 2
a1930 2
	char *,		t,
	char *,		s)
d1932 1
a1932 1
    char  buf[LINE_LENGTH], cval, *bp, *p;
d1938 1
a1938 1
		cval += (char) (p - HTmmquote);
d1945 1
a1945 1
		cval += (char) (p - HTmmquote);
d1962 96
d2062 2
a2063 2
	char *,		trg,
	char *,		str)
d2065 1
a2065 1
    char buf[LINE_LENGTH], mmbuf[LINE_LENGTH];
d2121 1
d2128 2
a2129 2
	char *,		t,
	char *,		s)
d2131 1
a2131 1
    char *p, buf[LINE_LENGTH];
d2176 1
a2176 1
 * $Header: /cvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.3 2003/05/01 18:59:36 avsm Exp $
@


1.1.1.3
log
@Import the complete OpenBSD source tree (base system)
as of CTM delta 3496 (roughly 1200 UTC today) into the
vendor branch.
Attention: this is a big update. Don't even try to
build this system, OpenBSD 3.4-beta, yet on your own.
@
text
@d2175 1
a2175 1
 * $Header: /ocvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.3 2003/05/01 18:59:36 avsm Exp $
@


1.1.1.4
log
@Import OpenBSD as of today again (seems pretty stable, I hope)

Prominent changes: more bgpd, tcpmd5; tcpdump/isakmpd fixes
@
text
@d2175 1
a2175 1
 * $Header: /cvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.3 2003/05/01 18:59:36 avsm Exp $
@


