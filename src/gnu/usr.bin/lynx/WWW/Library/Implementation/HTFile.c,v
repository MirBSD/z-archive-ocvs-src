head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.3
	MIRBSD_7quater:1.1.3.2
	cvs-200405160640:1.1.1.3
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.3
	cvs-200401261630:1.1.1.3
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.3
	MIRBSD_7_ALPHA:1.1.3.2.0.6
	MIRBSD_7:1.1.3.2.0.4
	cvs-200312222040:1.1.1.3
	MIRBSD_7ter:1.1.3.2
	MIRBSD_7_DEV:1.1.3.2.0.2
	cvs-200310020700:1.1.1.3
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.3
	cvs-200309251530:1.1.1.3
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.3
	cvs-200308171200:1.1.1.3
	ctm-3496:1.1.1.3
	ctm-3449:1.1.1.3
	ctm-3437:1.1.1.3
	cvs-200307191805:1.1.1.3
	ctm-3425:1.1.1.3
	cvs-200307091500:1.1.1.3
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.3
	cvs-200306291430:1.1.1.3
	ctm-3341:1.1.1.3
	MIRBSD_5:1.1.1.3
	cvs-200306082100:1.1.1.3
	ctm-3316:1.1.1.3
	ctm-3272:1.1.1.3
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.45.46;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.28.02.13.57;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.28.02.02.03;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.27.13.12.34;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.07.19.56.57;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.19.55.44;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.57.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.05;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.54;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.21.18.49.35;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.19;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.54;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.11;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.27;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.22;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.47.55;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.16;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.32;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/*			File Access				HTFile.c
 *			===========
 *
 *	This is unix-specific code in general, with some VMS bits.
 *	These are routines for file access used by browsers.
 *	Development of this module for Unix DIRED_SUPPORT in Lynx
 *	 regrettably has has been conducted in a manner with now
 *	 creates a major impediment for hopes of adapting Lynx to
 *	 a newer version of the library.
 *
 *  History:
 *	   Feb 91	Written Tim Berners-Lee CERN/CN
 *	   Apr 91	vms-vms access included using DECnet syntax
 *	26 Jun 92 (JFG) When running over DECnet, suppressed FTP.
 *			Fixed access bug for relative names on VMS.
 *	   Sep 93 (MD)	Access to VMS files allows sharing.
 *	15 Nov 93 (MD)	Moved HTVMSname to HTVMSUTILS.C
 *	27 Dec 93 (FM)	FTP now works with VMS hosts.
 *			FTP path must be Unix-style and cannot include
 *			the device or top directory.
 */

#include <HTUtils.h>

#ifndef VMS
#if defined(DOSPATH)
#undef LONG_LIST
#define LONG_LIST		/* Define this for long style unix listings (ls -l),
				   the actual style is configurable from lynx.cfg */
#endif
/* #define NO_PARENT_DIR_REFERENCE *//* Define this for no parent links */
#endif /* !VMS */

#if defined(DOSPATH)
#define HAVE_READDIR 1
#define USE_DIRENT
#endif

#if defined(USE_DOS_DRIVES)
#include <HTDOS.h>
#endif

#include <HTFile.h>		/* Implemented here */

#ifdef VMS
#include <stat.h>
#endif /* VMS */

#if defined (USE_ZLIB) || defined (USE_BZLIB)
#include <GridText.h>
#endif

#define MULTI_SUFFIX ".multi"	/* Extension for scanning formats */

#include <HTParse.h>
#include <HTTCP.h>
#ifndef DECNET
#include <HTFTP.h>
#endif /* !DECNET */
#include <HTAnchor.h>
#include <HTAtom.h>
#include <HTAAProt.h>
#include <HTFWriter.h>
#include <HTInit.h>
#include <HTBTree.h>
#include <HTAlert.h>
#include <HTCJK.h>
#include <UCDefs.h>
#include <UCMap.h>
#include <UCAux.h>

#include <LYexit.h>
#include <LYCharSets.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYLeaks.h>

typedef struct _HTSuffix {
    char *suffix;
    HTAtom *rep;
    HTAtom *encoding;
    char *desc;
    float quality;
} HTSuffix;

typedef struct {
    struct stat file_info;
    char sort_tags;
    char file_name[1];		/* on the end of the struct, since its length varies */
} DIRED;

#ifndef NGROUPS
#ifdef NGROUPS_MAX
#define NGROUPS NGROUPS_MAX
#else
#define NGROUPS 32
#endif /* NGROUPS_MAX */
#endif /* NGROUPS */

#ifndef GETGROUPS_T
#define GETGROUPS_T int
#endif

#include <HTML.h>		/* For directory object building */

#define PUTC(c) (*target->isa->put_character)(target, c)
#define PUTS(s) (*target->isa->put_string)(target, s)
#define START(e) (*target->isa->start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*target->isa->end_element)(target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*target->isa->end_element)(target, e, 0)
#define FREE_TARGET (*target->isa->_free)(target)
#define ABORT_TARGET (*targetClass._abort)(target, NULL);

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

/*
 *  Controlling globals.
 */
int HTDirAccess = HT_DIR_OK;

#ifdef DIRED_SUPPORT
int HTDirReadme = HT_DIR_README_NONE;

#else
int HTDirReadme = HT_DIR_README_TOP;
#endif /* DIRED_SUPPORT */

static const char *HTMountRoot = "/Net/";	/* Where to find mounts */

#ifdef VMS
static const char *HTCacheRoot = "/WWW$SCRATCH";	/* Where to cache things */

#else
static const char *HTCacheRoot = "/tmp/W3_Cache_";	/* Where to cache things */
#endif /* VMS */

/*
 *  Suffix registration.
 */
static HTList *HTSuffixes = 0;
static HTSuffix no_suffix =
{"*", NULL, NULL, NULL, 1.0};
static HTSuffix unknown_suffix =
{"*.*", NULL, NULL, NULL, 1.0};

/*	To free up the suffixes at program exit.
 *	----------------------------------------
 */
#ifdef LY_FIND_LEAKS
static void free_suffixes(void);
#endif

#ifdef LONG_LIST
static char *FormatStr(char **bufp,
		       char *start,
		       const char *entry)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*ss", (int) sizeof(fmt) - 3, start);
	HTSprintf0(bufp, fmt, entry);
    } else if (*bufp && !(entry && *entry)) {
	**bufp = '\0';
    } else if (entry) {
	StrAllocCopy(*bufp, entry);
    }
    return *bufp;
}

static char *FormatNum(char **bufp,
		       char *start,
		       int entry)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*sd", (int) sizeof(fmt) - 3, start);
	HTSprintf0(bufp, fmt, entry);
    } else {
	sprintf(fmt, "%d", entry);
	StrAllocCopy(*bufp, fmt);
    }
    return *bufp;
}

static void LYListFmtParse(const char *fmtstr,
			   DIRED * data,
			   char *file,
			   HTStructured * target,
			   char *tail)
{
    char c;
    char *s;
    char *end;
    char *start;
    char *str = NULL;
    char *buf = NULL;
    char tmp[LY_MAXPATH];
    char type;

#ifndef NOUSERS
    const char *name;
#endif
    time_t now;
    char *datestr;

#ifdef S_IFLNK
    int len;
#endif
#define SEC_PER_YEAR	(60 * 60 * 24 * 365)

#ifdef _WINDOWS			/* 1998/01/06 (Tue) 21:20:53 */
    static const char *pbits[] =
    {
	"---", "--x", "-w-", "-wx",
	"r--", "r-x", "rw-", "rwx",
	0};

#define PBIT(a, n, s)  pbits[((a) >> (n)) & 0x7]

#else
    static const char *pbits[] =
    {"---", "--x", "-w-", "-wx",
     "r--", "r-x", "rw-", "rwx", 0};
    static const char *psbits[] =
    {"--S", "--s", "-wS", "-ws",
     "r-S", "r-s", "rwS", "rws", 0};

#define PBIT(a, n, s)  (s) ? psbits[((a) >> (n)) & 0x7] : \
	pbits[((a) >> (n)) & 0x7]
#endif
#ifdef S_ISVTX
    static const char *ptbits[] =
    {"--T", "--t", "-wT", "-wt",
     "r-T", "r-t", "rwT", "rwt", 0};

#define PTBIT(a, s)  (s) ? ptbits[(a) & 0x7] : pbits[(a) & 0x7]
#else
#define PTBIT(a, s)  PBIT(a, 0, 0)
#endif

    if (data->file_info.st_mode == 0)
	fmtstr = "    %a";	/* can't stat so just do anchor */

    StrAllocCopy(str, fmtstr);
    s = str;
    end = str + strlen(str);
    START(HTML_PRE);
    while (*s) {
	start = s;
	while (*s) {
	    if (*s == '%') {
		if (*(s + 1) == '%')	/* literal % */
		    s++;
		else
		    break;
	    }
	    s++;
	}
	/* s is positioned either at a % or at \0 */
	*s = '\0';
	if (s > start) {	/* some literal chars. */
	    PUTS(start);
	}
	if (s == end)
	    break;
	start = ++s;
	while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
	       *s == '#' || *s == '+' || *s == '\'')
	    s++;
	c = *s;			/* the format char. or \0 */
	*s = '\0';

	switch (c) {
	case '\0':
	    PUTS(start);
	    continue;

	case 'A':
	case 'a':		/* anchor */
	    HTDirEntry(target, tail, data->file_name);
	    FormatStr(&buf, start, data->file_name);
	    PUTS(buf);
	    END(HTML_A);
	    *buf = '\0';
#ifdef S_IFLNK
	    if (c != 'A' && S_ISLNK(data->file_info.st_mode) &&
		(len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
		PUTS(" -> ");
		tmp[len] = '\0';
		PUTS(tmp);
	    }
#endif
	    break;

	case 'T':		/* MIME type */
	case 't':		/* MIME type description */
	    if (S_ISDIR(data->file_info.st_mode)) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else {
		const char *cp2;
		HTFormat format;

		format = HTFileFormat(file, NULL, &cp2);

		if (c != 'T') {
		    if (cp2 == NULL) {
			if (!strncmp(HTAtom_name(format),
				     "application", 11)) {
			    cp2 = HTAtom_name(format) + 12;
			    if (!strncmp(cp2, "x-", 2))
				cp2 += 2;
			} else {
			    cp2 = HTAtom_name(format);
			}
		    }
		    FormatStr(&buf, start, cp2);
		} else {
		    FormatStr(&buf, start, HTAtom_name(format));
		}
	    }
	    break;

	case 'd':		/* date */
	    now = time(0);
	    datestr = ctime(&data->file_info.st_mtime);
	    if ((now - data->file_info.st_mtime) < SEC_PER_YEAR / 2)
		/*
		 * MMM DD HH:MM
		 */
		sprintf(tmp, "%.12s", datestr + 4);
	    else
		/*
		 * MMM DD YYYY
		 */
		sprintf(tmp, "%.7s %.4s ", datestr + 4,
			datestr + 20);
	    FormatStr(&buf, start, tmp);
	    break;

	case 's':		/* size in bytes */
	    FormatNum(&buf, start, (int) data->file_info.st_size);
	    break;

	case 'K':		/* size in Kilobytes but not for directories */
	    if (S_ISDIR(data->file_info.st_mode)) {
		FormatStr(&buf, start, "");
		StrAllocCat(buf, " ");
		break;
	    }
	    /* FALL THROUGH */
	case 'k':		/* size in Kilobytes */
	    FormatNum(&buf, start, (int) ((data->file_info.st_size + 1023) / 1024));
	    StrAllocCat(buf, "K");
	    break;

	case 'p':		/* unix-style permission bits */
	    switch (data->file_info.st_mode & S_IFMT) {
#if defined(_MSC_VER) && defined(_S_IFIFO)
	    case _S_IFIFO:
		type = 'p';
		break;
#else
	    case S_IFIFO:
		type = 'p';
		break;
#endif
	    case S_IFCHR:
		type = 'c';
		break;
	    case S_IFDIR:
		type = 'd';
		break;
	    case S_IFREG:
		type = '-';
		break;
#ifdef S_IFBLK
	    case S_IFBLK:
		type = 'b';
		break;
#endif
#ifdef S_IFLNK
	    case S_IFLNK:
		type = 'l';
		break;
#endif
#ifdef S_IFSOCK
# ifdef S_IFIFO			/* some older machines (e.g., apollo) have a conflict */
#  if S_IFIFO != S_IFSOCK
	    case S_IFSOCK:
		type = 's';
		break;
#  endif
# else
	    case S_IFSOCK:
		type = 's';
		break;
# endif
#endif /* S_IFSOCK */
	    default:
		type = '?';
		break;
	    }
#ifdef _WINDOWS
	    sprintf(tmp, "%c%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_IRWXU));
#else
	    sprintf(tmp, "%c%s%s%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_ISUID),
		    PBIT(data->file_info.st_mode, 3, data->file_info.st_mode & S_ISGID),
		    PTBIT(data->file_info.st_mode, data->file_info.st_mode & S_ISVTX));
#endif
	    FormatStr(&buf, start, tmp);
	    break;

	case 'o':		/* owner */
#ifndef NOUSERS
	    name = HTAA_UidToName(data->file_info.st_uid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_uid);
	    }
#endif
	    break;

	case 'g':		/* group */
#ifndef NOUSERS
	    name = HTAA_GidToName(data->file_info.st_gid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_gid);
	    }
#endif
	    break;

	case 'l':		/* link count */
	    FormatNum(&buf, start, (int) data->file_info.st_nlink);
	    break;

	case '%':		/* literal % with flags/width */
	    FormatStr(&buf, start, "%");
	    break;

	default:
	    fprintf(stderr,
		    "Unknown format character `%c' in list format\n", c);
	    break;
	}
	if (buf)
	    PUTS(buf);

	s++;
    }
    FREE(buf);
    END(HTML_PRE);
    PUTC('\n');
    FREE(str);
}
#endif /* LONG_LIST */

/*	Define the representation associated with a file suffix.
 *	--------------------------------------------------------
 *
 *	Calling this with suffix set to "*" will set the default
 *	representation.
 *	Calling this with suffix set to "*.*" will set the default
 *	representation for unknown suffix files which contain a ".".
 *
 *	The encoding parameter can give a trivial (8bit, 7bit, binary)
 *	or real (gzip, compress) encoding.
 *
 *	If filename suffix is already defined with the same encoding
 *	its previous definition is overridden.
 */
void HTSetSuffix5(const char *suffix,
		  const char *representation,
		  const char *encoding,
		  const char *desc,
		  double value)
{
    HTSuffix *suff;
    BOOL trivial_enc = (BOOL) IsUnityEncStr(encoding);

    if (strcmp(suffix, "*") == 0)
	suff = &no_suffix;
    else if (strcmp(suffix, "*.*") == 0)
	suff = &unknown_suffix;
    else {
	HTList *cur = HTSuffixes;

	while (NULL != (suff = (HTSuffix *) HTList_nextObject(cur))) {
	    if (suff->suffix && 0 == strcmp(suff->suffix, suffix) &&
		((trivial_enc && IsUnityEnc(suff->encoding)) ||
		 (!trivial_enc && !IsUnityEnc(suff->encoding) &&
		  strcmp(encoding, HTAtom_name(suff->encoding)) == 0)))
		break;
	}
	if (!suff) {		/* Not found -- create a new node */
	    suff = typecalloc(HTSuffix);
	    if (suff == NULL)
		outofmem(__FILE__, "HTSetSuffix");

	    /*
	     * Memory leak fixed.
	     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	     */
	    if (!HTSuffixes) {
		HTSuffixes = HTList_new();
#ifdef LY_FIND_LEAKS
		atexit(free_suffixes);
#endif
	    }

	    HTList_addObject(HTSuffixes, suff);

	    StrAllocCopy(suff->suffix, suffix);
	}
    }

    if (representation)
	suff->rep = HTAtom_for(representation);

    /*
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     * Invariant code removed.
     */
    suff->encoding = HTAtom_for(encoding);

    StrAllocCopy(suff->desc, desc);

    suff->quality = (float) value;
}

#ifdef LY_FIND_LEAKS
/*
 *	Purpose:	Free all added suffixes.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		To be used at program exit.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void free_suffixes(void)
{
    HTSuffix *suff = NULL;

    /*
     * Loop through all suffixes.
     */
    while (!HTList_isEmpty(HTSuffixes)) {
	/*
	 * Free off each item and its members if need be.
	 */
	suff = (HTSuffix *) HTList_removeLastObject(HTSuffixes);
	FREE(suff->suffix);
	FREE(suff->desc);
	FREE(suff);
    }
    /*
     * Free off the list itself.
     */
    HTList_delete(HTSuffixes);
    HTSuffixes = NULL;
}
#endif /* LY_FIND_LEAKS */

/*	Make the cache file name for a W3 document.
 *	-------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	/tmp/WWW_Cache_news/1234@@cernvax.cern.ch
 *		/tmp/WWW_Cache_http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTCacheFileName(const char *name)
{
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *result = NULL;

    HTSprintf0(&result, "%s/WWW/%s/%s%s", HTCacheRoot, acc_method, host, path);

    FREE(path);
    FREE(acc_method);
    FREE(host);
    return result;
}

/*	Open a file for write, creating the path.
 *	-----------------------------------------
 */
#ifdef NOT_IMPLEMENTED
static int HTCreatePath(const char *path)
{
    return -1;
}
#endif /* NOT_IMPLEMENTED */

/*	Convert filename from URL-path syntax to local path format
 *	----------------------------------------------------------
 *	Input name is assumed to be the URL-path of a local file
 *      URL, i.e. what comes after the "file://localhost".
 *      '#'-fragments to be treated as such must already be stripped.
 *      If expand_all is FALSE, unescape only escaped '/'. - kw
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTURLPath_toFile(const char *name,
		       BOOL expand_all,
		       BOOL is_remote GCC_UNUSED)
{
    char *path = NULL;
    char *result = NULL;

    StrAllocCopy(path, name);
    if (expand_all)
	HTUnEscape(path);	/* Interpret all % signs */
    else
	HTUnEscapeSome(path, "/");	/* Interpret % signs for path delims */

    CTRACE((tfp, "URLPath `%s' means path `%s'\n", name, path));
#if defined(USE_DOS_DRIVES)
    StrAllocCopy(result, is_remote ? path : HTDOS_name(path));
#else
    StrAllocCopy(result, path);
#endif

    FREE(path);

    return result;
}
/*	Convert filenames between local and WWW formats.
 *	------------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	$(HOME)/WWW/news/1234@@cernvax.cern.ch
 *		$(HOME)/WWW/http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
/* NOTE: Don't use this function if you know that the input is a URL path
	 rather than a full URL, use HTURLPath_toFile instead.  Otherwise
	 this function will return the wrong thing for some unusual
	 paths (like ones containing "//", possibly escaped). - kw
*/
char *HTnameOfFile_WWW(const char *name,
		       BOOL WWW_prefix,
		       BOOL expand_all)
{
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    const char *home;
    char *result = NULL;

    if (expand_all) {
	HTUnEscape(path);	/* Interpret all % signs */
    } else
	HTUnEscapeSome(path, "/");	/* Interpret % signs for path delims */

    if (0 == strcmp(acc_method, "file")		/* local file */
	||!*acc_method) {	/* implicitly local? */
	if ((0 == strcasecomp(host, HTHostName())) ||
	    (0 == strcasecomp(host, "localhost")) || !*host) {
	    CTRACE((tfp, "Node `%s' means path `%s'\n", name, path));
	    StrAllocCopy(result, HTSYS_name(path));
	} else if (WWW_prefix) {
	    HTSprintf0(&result, "%s%s%s", "/Net/", host, path);
	    CTRACE((tfp, "Node `%s' means file `%s'\n", name, result));
	} else {
	    StrAllocCopy(result, path);
	}
    } else if (WWW_prefix) {	/* other access */
#ifdef VMS
	if ((home = LYGetEnv("HOME")) == 0)
	    home = HTCacheRoot;
	else
	    home = HTVMS_wwwName(home);
#else
#if defined(_WINDOWS)		/* 1997/10/16 (Thu) 20:42:51 */
	home = Home_Dir();
#else
	home = LYGetEnv("HOME");
#endif
	if (home == 0)
	    home = "/tmp";
#endif /* VMS */
	HTSprintf0(&result, "%s/WWW/%s/%s%s", home, acc_method, host, path);
    } else {
	StrAllocCopy(result, path);
    }

    FREE(host);
    FREE(path);
    FREE(acc_method);

    CTRACE((tfp, "HTnameOfFile_WWW(%s,%d,%d) = %s\n",
	    name, WWW_prefix, expand_all, result));

    return result;
}

/*	Make a WWW name from a full local path name.
 *	--------------------------------------------
 *
 *  Bugs:
 *	At present, only the names of two network root nodes are hand-coded
 *	in and valid for the NeXT only.  This should be configurable in
 *	the general case.
 */
char *WWW_nameOfFile(const char *name)
{
    char *result = NULL;

#ifdef NeXT
    if (0 == strncmp("/private/Net/", name, 13)) {
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 13);
    } else
#endif /* NeXT */
    if (0 == strncmp(HTMountRoot, name, 5)) {
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 5);
    } else {
	HTSprintf0(&result, "%s//%s%s", STR_FILE_URL, HTHostName(), name);
    }
    CTRACE((tfp, "File `%s'\n\tmeans node `%s'\n", name, result));
    return result;
}

/*	Determine a suitable suffix, given the representation.
 *	------------------------------------------------------
 *
 *  On entry,
 *	rep	is the atomized MIME style representation
 *	enc	is an encoding, trivial (8bit, binary, etc.) or gzip etc.
 *
 *  On exit:
 *	Returns a pointer to a suitable suffix string if one has been
 *	found, else "".
 */
const char *HTFileSuffix(HTAtom *rep,
			 const char *enc)
{
    HTSuffix *suff;

#ifdef FNAMES_8_3
    HTSuffix *first_found = NULL;
#endif
    BOOL trivial_enc;
    int n;
    int i;

#define NO_INIT			/* don't init anymore since I do it in Lynx at startup */
#ifndef NO_INIT
    if (!HTSuffixes)
	HTFileInit();
#endif /* !NO_INIT */

    trivial_enc = (BOOL) IsUnityEncStr(enc);
    n = HTList_count(HTSuffixes);
    for (i = 0; i < n; i++) {
	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
	if (suff->rep == rep &&
#if defined(VMS) || defined(FNAMES_8_3)
	/*  Don't return a suffix whose first char is a dot, and which
	   has more dots or asterisks after that, for
	   these systems - kw */
	    (!suff->suffix || !suff->suffix[0] || suff->suffix[0] != '.' ||
	     (strchr(suff->suffix + 1, '.') == NULL &&
	      strchr(suff->suffix + 1, '*') == NULL)) &&
#endif
	    ((trivial_enc && IsUnityEnc(suff->encoding)) ||
	     (!trivial_enc && !IsUnityEnc(suff->encoding) &&
	      strcmp(enc, HTAtom_name(suff->encoding)) == 0))) {
#ifdef FNAMES_8_3
	    if (suff->suffix && (strlen(suff->suffix) <= 4)) {
		/*
		 * If length of suffix (including dot) is 4 or smaller, return
		 * this one even if we found a longer one earlier - kw
		 */
		return suff->suffix;
	    } else if (!first_found) {
		first_found = suff;	/* remember this one */
	    }
#else
	    return suff->suffix;	/* OK -- found */
#endif
	}
    }
#ifdef FNAMES_8_3
    if (first_found)
	return first_found->suffix;
#endif
    return "";			/* Dunno */
}

/*
 * Trim version from VMS filenames to avoid confusing comparisons.
 */
#ifdef VMS
static const char *VMS_trim_version(const char *filename)
{
    const char *result = filename;
    const char *version = strchr(filename, ';');

    if (version != 0) {
	static char *stripped;

	StrAllocCopy(stripped, filename);
	stripped[version - filename] = '\0';
	result = (const char *) stripped;
    }
    return result;
}
#define VMS_DEL_VERSION(name) name = VMS_trim_version(name)
#else
#define VMS_DEL_VERSION(name)	/* nothing */
#endif

/*	Determine file format from file name.
 *	-------------------------------------
 *
 *	This version will return the representation and also set
 *	a variable for the encoding.
 *
 *	Encoding may be a unity encoding (binary, 8bit, etc.) or
 *	a content-coding like gzip, compress.
 *
 *	It will handle for example  x.txt, x.txt,Z, x.Z
 */
HTFormat HTFileFormat(const char *filename,
		      HTAtom **pencoding,
		      const char **pdesc)
{
    HTSuffix *suff;
    int n;
    int i;
    int lf;

    VMS_DEL_VERSION(filename);

    if (pencoding)
	*pencoding = NULL;
    if (pdesc)
	*pdesc = NULL;
    if (LYforce_HTML_mode) {
	if (pencoding)
	    *pencoding = WWW_ENC_8BIT;
	return WWW_HTML;
    }
#ifndef NO_INIT
    if (!HTSuffixes)
	HTFileInit();
#endif /* !NO_INIT */
    lf = strlen(filename);
    n = HTList_count(HTSuffixes);
    for (i = 0; i < n; i++) {
	int ls;

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
	ls = strlen(suff->suffix);
	if ((ls <= lf) && 0 == strcasecomp(suff->suffix, filename + lf - ls)) {
	    int j;

	    if (pencoding)
		*pencoding = suff->encoding;
	    if (pdesc)
		*pdesc = suff->desc;
	    if (suff->rep) {
		return suff->rep;	/* OK -- found */
	    }
	    for (j = 0; j < n; j++) {	/* Got encoding, need representation */
		int ls2;

		suff = (HTSuffix *) HTList_objectAt(HTSuffixes, j);
		ls2 = strlen(suff->suffix);
		if ((ls + ls2 <= lf) &&
		    !strncasecomp(suff->suffix,
				  filename + lf - ls - ls2, ls2)) {
		    if (suff->rep) {
			if (pdesc && !(*pdesc))
			    *pdesc = suff->desc;
			if (pencoding && IsUnityEnc(*pencoding) &&
			    *pencoding != WWW_ENC_7BIT &&
			    !IsUnityEnc(suff->encoding))
			    *pencoding = suff->encoding;
			return suff->rep;
		    }
		}
	    }

	}
    }

    /* defaults tree */

    suff = strchr(filename, '.') ?	/* Unknown suffix */
	(unknown_suffix.rep ? &unknown_suffix : &no_suffix)
	: &no_suffix;

    /*
     * Set default encoding unless found with suffix already.
     */
    if (pencoding && !*pencoding) {
	*pencoding = (suff->encoding
		      ? suff->encoding
		      : HTAtom_for("binary"));
    }
    return suff->rep ? suff->rep : WWW_BINARY;
}

/*	Revise the file format in relation to the Lynx charset. - FM
 *	-------------------------------------------------------
 *
 *	This checks the format associated with an anchor for
 *	an extended MIME Content-Type, and if a charset is
 *	indicated, sets Lynx up for proper handling in relation
 *	to the currently selected character set. - FM
 */
HTFormat HTCharsetFormat(HTFormat format,
			 HTParentAnchor *anchor,
			 int default_LYhndl)
{
    char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;
    BOOL chartrans_ok = FALSE;
    int chndl = -1;

    FREE(anchor->charset);
    StrAllocCopy(cp, format->name);
    LYLowerCase(cp);
    if (((cp1 = strchr(cp, ';')) != NULL) &&
	(cp2 = strstr(cp1, "charset")) != NULL) {
	CTRACE((tfp, "HTCharsetFormat: Extended MIME Content-Type is %s\n",
		format->name));
	cp2 += 7;
	while (*cp2 == ' ' || *cp2 == '=')
	    cp2++;
	StrAllocCopy(cp3, cp2);	/* copy to mutilate more */
	for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
			 *cp4 != ';' && *cp4 != ':' &&
			 !WHITE(*cp4)); cp4++) {
	    ;			/* do nothing */
	}
	*cp4 = '\0';
	cp4 = cp3;
	chndl = UCGetLYhndl_byMIME(cp3);
	if (UCCanTranslateFromTo(chndl, current_char_set)) {
	    chartrans_ok = YES;
	    *cp1 = '\0';
	    format = HTAtom_for(cp);
	    StrAllocCopy(anchor->charset, cp4);
	    HTAnchor_setUCInfoStage(anchor, chndl,
				    UCT_STAGE_MIME,
				    UCT_SETBY_MIME);
	} else if (chndl < 0) {
	    /*
	     * Got something but we don't recognize it.
	     */
	    chndl = UCLYhndl_for_unrec;
	    if (chndl < 0)
		/*
		 * UCLYhndl_for_unrec not defined :-( fallback to
		 * UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	    if (UCCanTranslateFromTo(chndl, current_char_set)) {
		chartrans_ok = YES;
		HTAnchor_setUCInfoStage(anchor, chndl,
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
	    }
	}
	if (chartrans_ok) {
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(anchor,
							UCT_STAGE_MIME);
	    LYUCcharset *p_out = HTAnchor_setUCInfoStage(anchor,
							 current_char_set,
							 UCT_STAGE_HTEXT,
							 UCT_SETBY_DEFAULT);

	    if (!p_out) {
		/*
		 * Try again.
		 */
		p_out = HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT);
	    }
	    if (!strcmp(p_in->MIMEname, "x-transparent")) {
		HTPassEightBitRaw = TRUE;
		HTAnchor_setUCInfoStage(anchor,
					HTAnchor_getUCLYhndl(anchor,
							     UCT_STAGE_HTEXT),
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
	    }
	    if (!strcmp(p_out->MIMEname, "x-transparent")) {
		HTPassEightBitRaw = TRUE;
		HTAnchor_setUCInfoStage(anchor,
					HTAnchor_getUCLYhndl(anchor,
							     UCT_STAGE_MIME),
					UCT_STAGE_HTEXT,
					UCT_SETBY_DEFAULT);
	    }
	    if (p_in->enc != UCT_ENC_CJK) {
		HTCJK = NOCJK;
		if (!(p_in->codepoints &
		      UCT_CP_SUBSETOF_LAT1) &&
		    chndl == current_char_set) {
		    HTPassEightBitRaw = TRUE;
		}
	    } else if (p_out->enc == UCT_ENC_CJK) {
		Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
	    }
	} else {
	    /*
	     * Cannot translate.  If according to some heuristic the given
	     * charset and the current display character both are likely to be
	     * like ISO-8859 in structure, pretend we have some kind of match.
	     */
	    BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
					 isdigit(UCH(cp4[9])));
	    BOOL given_is_8859like = (BOOL) (given_is_8859 ||
					     !strncmp(cp4, "windows-", 8) ||
					     !strncmp(cp4, "cp12", 4) ||
					     !strncmp(cp4, "cp-12", 5));
	    BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
						      (strstr(LYchar_set_names[current_char_set],
							      "ISO-8859") ||
						       strstr(LYchar_set_names[current_char_set],
							      "windows-")));

	    if (given_and_display_8859like) {
		*cp1 = '\0';
		format = HTAtom_for(cp);
	    }
	    if (given_is_8859) {
		cp1 = &cp4[10];
		while (*cp1 &&
		       isdigit(UCH(*cp1)))
		    cp1++;
		*cp1 = '\0';
	    }
	    if (given_and_display_8859like) {
		StrAllocCopy(anchor->charset, cp4);
		HTPassEightBitRaw = TRUE;
	    }
	    HTAlert(*cp4 ? cp4 : anchor->charset);
	}
	FREE(cp3);
    } else if (cp1 != NULL) {
	/*
	 * No charset parameter is present.  Ignore all other parameters, as we
	 * do when charset is present.  - FM
	 */
	*cp1 = '\0';
	format = HTAtom_for(cp);
    }
    FREE(cp);

    /*
     * Set up defaults, if needed.  - FM
     */
    if (!chartrans_ok && !anchor->charset && default_LYhndl >= 0) {
	HTAnchor_setUCInfoStage(anchor, default_LYhndl,
				UCT_STAGE_MIME,
				UCT_SETBY_DEFAULT);
    }
    HTAnchor_copyUCInfoStage(anchor,
			     UCT_STAGE_PARSER,
			     UCT_STAGE_MIME,
			     -1);

    return format;
}

/*	Get various pieces of meta info from file name.
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
void LYGetFileInfo(const char *filename,
		   HTParentAnchor **pfile_anchor,
		   HTFormat *pformat,
		   HTAtom **pencoding,
		   const char **pdesc,
		   const char **pcharset,
		   int *pfile_cs)
{
    char *Afn;
    char *Aname = NULL;
    HTFormat format;
    HTAtom *myEnc = NULL;
    HTParentAnchor *file_anchor;
    const char *file_csname;
    int file_cs;

    /*
     * Convert filename to URL.  Note that it is always supposed to be a
     * filename, not maybe-filename-maybe-URL, so we don't use
     * LYFillLocalFileURL and LYEnsureAbsoluteURL.  - kw
     */
    Afn = HTEscape(filename, URL_PATH);
    LYLocalFileToURL(&Aname, Afn);
    file_anchor = HTAnchor_findSimpleAddress(Aname);

    file_csname = file_anchor->charset;
    format = HTFileFormat(filename, &myEnc, pdesc);
    format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
    file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
    if (!file_csname) {
	if (file_cs >= 0)
	    file_csname = LYCharSet_UC[file_cs].MIMEname;
	else
	    file_csname = "display character set";
    }
    CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	    filename,
	    ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
	     *HTAtom_name(format) == 'a' ? "n" : ""),
	    myEnc ? HTAtom_name(myEnc) : "",
	    HTAtom_name(format),
	    file_csname,
	    file_cs));
    FREE(Afn);
    FREE(Aname);
    if (pfile_anchor)
	*pfile_anchor = file_anchor;
    if (pformat)
	*pformat = format;
    if (pencoding)
	*pencoding = myEnc;
    if (pcharset)
	*pcharset = file_csname;
    if (pfile_cs)
	*pfile_cs = file_cs;
}

/*	Determine value from file name.
 *	-------------------------------
 *
 */
float HTFileValue(const char *filename)
{
    HTSuffix *suff;
    int n;
    int i;
    int lf = strlen(filename);

#ifndef NO_INIT
    if (!HTSuffixes)
	HTFileInit();
#endif /* !NO_INIT */
    n = HTList_count(HTSuffixes);
    for (i = 0; i < n; i++) {
	int ls;

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
	ls = strlen(suff->suffix);
	if ((ls <= lf) && 0 == strcmp(suff->suffix, filename + lf - ls)) {
	    CTRACE((tfp, "File: Value of %s is %.3f\n",
		    filename, suff->quality));
	    return suff->quality;	/* OK -- found */
	}
    }
    return (float) 0.3;		/* Dunno! */
}

/*
 *  Determine compression type from file name, by looking at its suffix.
 *  Sets as side-effect a pointer to the "dot" that begins the suffix.
 */
CompressFileType HTCompressFileType(const char *filename,
				    const char *dots,
				    int *rootlen)
{
    CompressFileType result = cftNone;
    size_t len = strlen(filename);
    const char *ftype = filename + len;

    VMS_DEL_VERSION(filename);

    if ((len > 4)
	&& !strcasecomp((ftype - 3), "bz2")
	&& strchr(dots, ftype[-4]) != 0) {
	result = cftBzip2;
	ftype -= 4;
    } else if ((len > 3)
	       && !strcasecomp((ftype - 2), "gz")
	       && strchr(dots, ftype[-3]) != 0) {
	result = cftGzip;
	ftype -= 3;
    } else if ((len > 3)
	       && !strcasecomp((ftype - 2), "zz")
	       && strchr(dots, ftype[-3]) != 0) {
	result = cftDeflate;
	ftype -= 3;
    } else if ((len > 2)
	       && !strcmp((ftype - 1), "Z")
	       && strchr(dots, ftype[-2]) != 0) {
	result = cftCompress;
	ftype -= 2;
    }

    *rootlen = (ftype - filename);

    CTRACE((tfp, "HTCompressFileType(%s) returns %d:%s\n",
	    filename, (int) result, filename + *rootlen));
    return result;
}

/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.  RFC 2068 (and cut/paste into RFC 2616) lists these:
 *	gzip
 *	compress
 *	deflate
 * as well as "identity" (but that does nothing).
 */
CompressFileType HTEncodingToCompressType(const char *coding)
{
    CompressFileType result = cftNone;

    if (coding == 0) {
	result = cftNone;
    } else if (!strcasecomp(coding, "gzip") ||
	       !strcasecomp(coding, "x-gzip")) {
	result = cftGzip;
    } else if (!strcasecomp(coding, "compress") ||
	       !strcasecomp(coding, "x-compress")) {
	result = cftCompress;
    } else if (!strcasecomp(coding, "bzip2") ||
	       !strcasecomp(coding, "x-bzip2")) {
	result = cftBzip2;
    } else if (!strcasecomp(coding, "deflate") ||
	       !strcasecomp(coding, "x-deflate")) {
	result = cftDeflate;
    }
    return result;
}

/*	Determine write access to a file.
 *	---------------------------------
 *
 *  On exit:
 *	Returns YES if file can be accessed and can be written to.
 *
 *  Bugs:
 *	1.	No code for non-unix systems.
 *	2.	Isn't there a quicker way?
 */
BOOL HTEditable(const char *filename)
{
#ifndef NO_GROUPS
    GETGROUPS_T groups[NGROUPS];
    uid_t myUid;
    int ngroups;		/* The number of groups  */
    struct stat fileStatus;
    int i;

    if (stat(filename, &fileStatus))	/* Get details of filename */
	return NO;		/* Can't even access file! */

    ngroups = getgroups(NGROUPS, groups);	/* Groups to which I belong  */
    myUid = geteuid();		/* Get my user identifier */

    if (TRACE) {
	int i2;

	fprintf(tfp,
		"File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",
		(unsigned int) fileStatus.st_mode,
		(int) fileStatus.st_uid,
		(int) fileStatus.st_gid,
		(int) myUid,
		(int) ngroups);
	for (i2 = 0; i2 < ngroups; i2++)
	    fprintf(tfp, " %d", (int) groups[i2]);
	fprintf(tfp, ")\n");
    }

    if (fileStatus.st_mode & 0002)	/* I can write anyway? */
	return YES;

    if ((fileStatus.st_mode & 0200)	/* I can write my own file? */
	&&(fileStatus.st_uid == myUid))
	return YES;

    if (fileStatus.st_mode & 0020)	/* Group I am in can write? */
    {
	for (i = 0; i < ngroups; i++) {
	    if (groups[i] == fileStatus.st_gid)
		return YES;
	}
    }
    CTRACE((tfp, "\tFile is not editable.\n"));
#endif /* NO_GROUPS */
    return NO;			/* If no excuse, can't do */
}

/*	Make a save stream.
 *	-------------------
 *
 *	The stream must be used for writing back the file.
 *	@@@@@@ no backup done
 */
HTStream *HTFileSaveStream(HTParentAnchor *anchor)
{
    const char *addr = anchor->address;
    char *localname = HTLocalName(addr);
    FILE *fp = fopen(localname, BIN_W);

    FREE(localname);
    if (!fp)
	return NULL;

    return HTFWriter_new(fp);
}

/*	Output one directory entry.
 *	---------------------------
 */
void HTDirEntry(HTStructured * target, const char *tail,
		const char *entry)
{
    char *relative = NULL;
    char *stripped = NULL;
    char *escaped = NULL;
    int len;

    StrAllocCopy(escaped, entry);
    LYTrimPathSep(escaped);
    if (strcmp(escaped, "..") != 0) {
	stripped = escaped;
	escaped = HTEscape(stripped, URL_XPALPHAS);
	if (((len = strlen(escaped)) > 2) &&
	    escaped[(len - 3)] == '%' &&
	    escaped[(len - 2)] == '2' &&
	    TOUPPER(escaped[(len - 1)]) == 'F') {
	    escaped[(len - 3)] = '\0';
	}
    }

    if (tail == NULL || *tail == '\0') {
	/*
	 * Handle extra slash at end of path.
	 */
	HTStartAnchor(target, NULL, (escaped[0] != '\0' ? escaped : "/"));
    } else {
	/*
	 * If empty tail, gives absolute ref below.
	 */
	relative = 0;
	HTSprintf0(&relative, "%s%s%s",
		   tail,
		   (*escaped != '\0' ? "/" : ""),
		   escaped);
	HTStartAnchor(target, NULL, relative);
	FREE(relative);
    }
    FREE(stripped);
    FREE(escaped);
}

/*	Output parent directory entry.
 *	------------------------------
 *
 *    This gives the TITLE and H1 header, and also a link
 *    to the parent directory if appropriate.
 *
 *  On exit:
 *	Returns TRUE if an "Up to <parent>" link was not created
 *	for a readable local directory because LONG_LIST is defined
 *	and NO_PARENT_DIR_REFERENCE is not defined, so that the
 *	calling function should use LYListFmtParse() to create a link
 *	to the parent directory.  Otherwise, it returns FALSE. - FM
 */
BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
		 BOOL tildeIsTop)
{
    const char *logical = anchor->address;
    char *path = HTParse(logical, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *current;
    char *cp = NULL;
    BOOL need_parent_link = FALSE;
    int i;

#if defined(USE_DOS_DRIVES)
    BOOL local_link = (strlen(logical) > 18
		       && !strncasecomp(logical, "file://localhost/", 17)
		       && LYIsDosDrive(logical + 17));
    BOOL is_remote = !local_link;

#else
#define is_remote TRUE
#endif

    /*
     * Check tildeIsTop for treating home directory as Welcome (assume the
     * tilde is not followed by a username).  - FM
     */
    if (tildeIsTop && !strncmp(path, "/~", 2)) {
	if (path[2] == '\0') {
	    path[1] = '\0';
	} else {
	    for (i = 0; path[(i + 2)]; i++) {
		path[i] = path[(i + 2)];
	    }
	    path[i] = '\0';
	}
    }

    /*
     * Trim out the ;type= parameter, if present.  - FM
     */
    if ((cp = strrchr(path, ';')) != NULL) {
	if (!strncasecomp((cp + 1), "type=", 5)) {
	    if (TOUPPER(*(cp + 6)) == 'D' ||
		TOUPPER(*(cp + 6)) == 'A' ||
		TOUPPER(*(cp + 6)) == 'I')
		*cp = '\0';
	}
	cp = NULL;
    }
    current = LYPathLeaf(path);	/* last part or "" */

    {
	char *printable = NULL;

#ifdef DIRED_SUPPORT
	printable = HTURLPath_toFile(((!strncasecomp(path, "/%2F", 4))	/* "//" ? */
				      ? (path + 1)
				      : path),
				     TRUE,
				     is_remote);
	if (0 == strncasecomp(printable, "/vmsysu:", 8) ||
	    0 == strncasecomp(printable, "/anonymou.", 10)) {
	    StrAllocCopy(cp, (printable + 1));
	    StrAllocCopy(printable, cp);
	    FREE(cp);
	}
#else
	StrAllocCopy(printable, current);
	HTUnEscape(printable);
#endif /* DIRED_SUPPORT */

	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(*printable ? printable : WELCOME_MSG);
	PUTS(SEGMENT_DIRECTORY);
	END(HTML_TITLE);
	PUTC('\n');
	END(HTML_HEAD);
	PUTC('\n');

#ifdef DIRED_SUPPORT
	START(HTML_H2);
	PUTS(*printable ? SEGMENT_CURRENT_DIR : "");
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H2);
	PUTC('\n');
#else
	START(HTML_H1);
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H1);
	PUTC('\n');
#endif /* DIRED_SUPPORT */
	if (((0 == strncasecomp(printable, "vmsysu:", 7)) &&
	     (cp = strchr(printable, '.')) != NULL &&
	     strchr(cp, '/') == NULL) ||
	    (0 == strncasecomp(printable, "anonymou.", 9) &&
	     strchr(printable, '/') == NULL)) {
	    FREE(printable);
	    FREE(path);
	    return (need_parent_link);
	}
	FREE(printable);
    }

#ifndef NO_PARENT_DIR_REFERENCE
    /*
     * Make link back to parent directory.
     */
    if (current - path > 0
	&& LYIsPathSep(current[-1])
	&& current[0] != '\0') {	/* was a slash AND something else too */
	char *parent = NULL;
	char *relative = NULL;

	current[-1] = '\0';
	parent = strrchr(path, '/');	/* penultimate slash */

	if ((parent &&
	     (!strcmp(parent, "/..") ||
	      !strncasecomp(parent, "/%2F", 4))) ||
	    !strncasecomp(current, "%2F", 3)) {
	    FREE(path);
	    return (need_parent_link);
	}

	relative = 0;
	HTSprintf0(&relative, "%s/..", current);

#if defined(DOSPATH) || defined(__EMX__)
	if (local_link) {
	    if (parent != 0 && strlen(parent) == 3) {
		StrAllocCat(relative, "/.");
	    }
	} else
#endif

#if !defined (VMS)
	{
	    /*
	     * On Unix, if it's not ftp and the directory cannot be read, don't
	     * put out a link.
	     *
	     * On VMS, this problem is dealt with internally by
	     * HTVMSBrowseDir().
	     */
	    DIR *dp = NULL;

	    if (LYisLocalFile(logical)) {
		/*
		 * We need an absolute file path for the opendir.  We also need
		 * to unescape for this test.  Don't worry about %2F now, they
		 * presumably have been dealt with above, and shouldn't appear
		 * for local files anyway...  Assume OS / filesystem will just
		 * ignore superfluous slashes.  - KW
		 */
		char *fullparentpath = NULL;

		/*
		 * Path has been shortened above.
		 */
		StrAllocCopy(fullparentpath, *path ? path : "/");

		/*
		 * Guard against weirdness.
		 */
		if (0 == strcmp(current, "..")) {
		    StrAllocCat(fullparentpath, "/../..");
		} else if (0 == strcmp(current, ".")) {
		    StrAllocCat(fullparentpath, "/..");
		}

		HTUnEscape(fullparentpath);
		if ((dp = opendir(fullparentpath)) == NULL) {
		    FREE(fullparentpath);
		    FREE(relative);
		    FREE(path);
		    return (need_parent_link);
		}
		closedir(dp);
		FREE(fullparentpath);
#ifdef LONG_LIST
		need_parent_link = TRUE;
		FREE(path);
		FREE(relative);
		return (need_parent_link);
#endif /* LONG_LIST */
	    }
	}
#endif /* !VMS */
	HTStartAnchor(target, "", relative);
	FREE(relative);

	PUTS(SEGMENT_UP_TO);
	if (parent) {
	    if ((0 == strcmp(current, ".")) ||
		(0 == strcmp(current, ".."))) {
		/*
		 * Should not happen, but if it does, at least avoid giving
		 * misleading info.  - KW
		 */
		PUTS("..");
	    } else {
		char *printable = NULL;

		StrAllocCopy(printable, parent + 1);
		HTUnEscape(printable);
		PUTS(printable);
		FREE(printable);
	    }
	} else {
	    PUTC('/');
	}
	END(HTML_A);
	PUTC('\n');
    }
#endif /* !NO_PARENT_DIR_REFERENCE */

    FREE(path);
    return (need_parent_link);
}

#if defined HAVE_READDIR
/*	Send README file.
 *	-----------------
 *
 *  If a README file exists, then it is inserted into the document here.
 */
static void do_readme(HTStructured * target, const char *localname)
{
    FILE *fp;
    char *readme_file_name = NULL;
    int ch;

    HTSprintf0(&readme_file_name, "%s/%s", localname, HT_DIR_README_FILE);

    fp = fopen(readme_file_name, "r");

    if (fp) {
	HTStructuredClass targetClass;

	targetClass = *target->isa;	/* (Can't init agregate in K&R) */
	START(HTML_PRE);
	while ((ch = fgetc(fp)) != EOF) {
	    PUTC((char) ch);
	}
	END(HTML_PRE);
	HTDisplayPartial();
	fclose(fp);
    }
    FREE(readme_file_name);
}

#define DIRED_BLOK(obj) (((DIRED *)(obj))->sort_tags)
#define DIRED_NAME(obj) (((DIRED *)(obj))->file_name)

#define NM_cmp(a,b) ((a) < (b) ? -1 : ((a) > (b) ? 1 : 0))

#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
static const char *file_type(const char *path)
{
    const char *type;

    while (*path == '.')
	++path;
    type = strchr(path, '.');
    if (type == NULL)
	type = "";
    return type;
}
#endif /* LONG_LIST && DIRED_SUPPORT */

static int dired_cmp(void *a, void *b)
{
    DIRED *p = (DIRED *) a;
    DIRED *q = (DIRED *) b;
    int code = p->sort_tags - q->sort_tags;

#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
    if (code == 0) {
	switch (dir_list_order) {
	case ORDER_BY_SIZE:
	    code = -NM_cmp(p->file_info.st_size, q->file_info.st_size);
	    break;
	case ORDER_BY_DATE:
	    code = -NM_cmp(p->file_info.st_mtime, q->file_info.st_mtime);
	    break;
	case ORDER_BY_MODE:
	    code = NM_cmp(p->file_info.st_mode, q->file_info.st_mode);
	    break;
	case ORDER_BY_USER:
	    code = NM_cmp(p->file_info.st_uid, q->file_info.st_uid);
	    break;
	case ORDER_BY_GROUP:
	    code = NM_cmp(p->file_info.st_gid, q->file_info.st_gid);
	    break;
	case ORDER_BY_TYPE:
	    code = AS_cmp(file_type(p->file_name), file_type(q->file_name));
	    break;
	default:
	    code = 0;
	    break;
	}
    }
#endif /* LONG_LIST && DIRED_SUPPORT */
    if (code == 0)
	code = AS_cmp(p->file_name, q->file_name);
#if 0
    CTRACE((tfp, "dired_cmp(%d) ->%d\n\t%c:%s (%s)\n\t%c:%s (%s)\n",
	    dir_list_order,
	    code,
	    p->sort_tags, p->file_name, file_type(p->file_name),
	    q->sort_tags, q->file_name, file_type(q->file_name)));
#endif
    return code;
}

static int print_local_dir(DIR *dp, char *localname,
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
{
    HTStructured *target;	/* HTML object */
    HTStructuredClass targetClass;
    STRUCT_DIRENT *dirbuf;
    char *pathname = NULL;
    char *tail = NULL;
    BOOL present[HTML_A_ATTRIBUTES];
    char *tmpfilename = NULL;
    BOOL need_parent_link = FALSE;
    int status;
    int i;
    struct stat *actual_info;

#ifdef S_IFLNK
    struct stat link_info;
#endif

    CTRACE((tfp, "print_local_dir() started\n"));

    pathname = HTParse(anchor->address, "",
		       PARSE_PATH + PARSE_PUNCTUATION);

    if (!strcmp(pathname, "/")) {
	/*
	 * Root path.
	 */
	StrAllocCopy(tail, "/foo/..");
    } else {
	char *p = strrchr(pathname, '/');	/* find last slash */

	if (!p) {
	    /*
	     * This probably should not happen, but be prepared if it does.  -
	     * KW
	     */
	    StrAllocCopy(tail, "/foo/..");
	} else {
	    /*
	     * Take slash off the beginning.
	     */
	    StrAllocCopy(tail, (p + 1));
	}
    }
    FREE(pathname);

    if (UCLYhndl_HTFile_for_unspec >= 0) {
	HTAnchor_setUCInfoStage(anchor,
				UCLYhndl_HTFile_for_unspec,
				UCT_STAGE_PARSER,
				UCT_SETBY_DEFAULT);
    }

    target = HTML_new(anchor, format_out, sink);
    targetClass = *target->isa;	/* Copy routine entry points */

    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);

    /*
     * The need_parent_link flag will be set if an "Up to <parent>" link was
     * not created for a readable parent in HTDirTitles() because LONG_LIST is
     * defined and NO_PARENT_DIR_REFERENCE is not defined so that need we to
     * create the link via an LYListFmtParse() call.  - FM
     */
    need_parent_link = HTDirTitles(target, anchor, FALSE);

#ifdef DIRED_SUPPORT
    if (!isLYNXCGI(anchor->address)) {
	HTAnchor_setFormat(anchor, WWW_DIRED);
	lynx_edit_mode = TRUE;
    }
#endif /* DIRED_SUPPORT */
    if (HTDirReadme == HT_DIR_README_TOP)
	do_readme(target, localname);

    {
	HTBTree *bt = HTBTree_new(dired_cmp);
	int num_of_entries = 0;	/* lines counter */

	_HTProgress(READING_DIRECTORY);
	status = HT_LOADED;	/* assume we don't get interrupted */
	while ((dirbuf = readdir(dp)) != NULL) {
	    /*
	     * While there are directory entries to be read...
	     */
	    DIRED *data = NULL;

#if !(defined(DOSPATH) || defined(__EMX__))
	    if (dirbuf->d_ino == 0)
		/*
		 * If the entry is not being used, skip it.
		 */
		continue;
#endif
	    /*
	     * Skip self, parent if handled in HTDirTitles() or if
	     * NO_PARENT_DIR_REFERENCE is not defined, and any dot files if
	     * no_dotfiles is set or show_dotfiles is not set.  - FM
	     */
	    if (!strcmp(dirbuf->d_name, ".") /* self       */ ||
		(!strcmp(dirbuf->d_name, "..") /* parent */ &&
		 need_parent_link == FALSE) ||
		((strcmp(dirbuf->d_name, "..")) &&
		 (dirbuf->d_name[0] == '.' &&
		  (no_dotfiles || !show_dotfiles))))
		continue;

	    StrAllocCopy(tmpfilename, localname);
	    /*
	     * If filename is not root directory, add trailing separator.
	     */
	    LYAddPathSep(&tmpfilename);

	    StrAllocCat(tmpfilename, dirbuf->d_name);
	    data = (DIRED *) malloc(sizeof(DIRED) + strlen(dirbuf->d_name) + 4);
	    if (data == NULL) {
		status = HT_PARTIAL_CONTENT;
		break;
	    }
	    LYTrimPathSep(tmpfilename);

	    actual_info = &(data->file_info);
#ifdef S_IFLNK
	    if (lstat(tmpfilename, actual_info) < 0) {
		actual_info->st_mode = 0;
	    } else {
		if (S_ISLNK(actual_info->st_mode)) {
		    actual_info = &link_info;
		    if (stat(tmpfilename, actual_info) < 0)
			actual_info->st_mode = 0;
		}
	    }
#else
	    if (stat(tmpfilename, actual_info) < 0)
		actual_info->st_mode = 0;
#endif

	    strcpy(data->file_name, dirbuf->d_name);
#ifndef DIRED_SUPPORT
	    if (S_ISDIR(actual_info->st_mode)) {
		data->sort_tags = 'D';
	    } else {
		data->sort_tags = 'F';
		/* D & F to have first directories, then files */
	    }
#else
	    if (S_ISDIR(actual_info->st_mode)) {
		if (dir_list_style == MIXED_STYLE) {
		    data->sort_tags = ' ';
		    LYAddPathSep0(data->file_name);
		} else if (!strcmp(dirbuf->d_name, "..")) {
		    data->sort_tags = 'A';
		} else {
		    data->sort_tags = 'D';
		}
	    } else if (dir_list_style == MIXED_STYLE) {
		data->sort_tags = ' ';
	    } else if (dir_list_style == FILES_FIRST) {
		data->sort_tags = 'C';
		/* C & D to have first files, then directories */
	    } else {
		data->sort_tags = 'F';
	    }
#endif /* !DIRED_SUPPORT */
	    /*
	     * Sort dirname in the tree bt.
	     */
	    HTBTree_add(bt, data);

#ifdef DISP_PARTIAL
	    /* optimize for expensive operation: */
	    if (num_of_entries % (partial_threshold > 0 ?
				  partial_threshold : display_lines)
		== 0) {
		if (HTCheckForInterrupt()) {
		    status = HT_PARTIAL_CONTENT;
		    break;
		}
	    }
	    num_of_entries++;
#endif /* DISP_PARTIAL */

	}			/* end while directory entries left to read */

	if (status != HT_PARTIAL_CONTENT)
	    _HTProgress(OPERATION_OK);
	else
	    CTRACE((tfp, "Reading the directory interrupted by user\n"));

	/*
	 * Run through tree printing out in order.
	 */
	{
	    HTBTElement *next_element = HTBTree_next(bt, NULL);

	    /* pick up the first element of the list */
	    int num_of_entries_output = 0;	/* lines counter */

	    char state;

	    /* I for initial (.. file),
	       D for directory file,
	       F for file */

#ifdef DIRED_SUPPORT
	    char test;
#endif /* DIRED_SUPPORT */
	    state = 'I';

	    while (next_element != NULL) {
		DIRED *entry;

#ifndef DISP_PARTIAL
		if (num_of_entries_output % HTMAX(display_lines, 10) == 0) {
		    if (HTCheckForInterrupt()) {
			_HTProgress(TRANSFER_INTERRUPTED);
			status = HT_PARTIAL_CONTENT;
			break;
		    }
		}
#endif
		StrAllocCopy(tmpfilename, localname);
		/*
		 * If filename is not root directory.
		 */
		LYAddPathSep(&tmpfilename);

		entry = (DIRED *) (HTBTree_object(next_element));
		/*
		 * Append the current entry's filename to the path.
		 */
		StrAllocCat(tmpfilename, entry->file_name);
		HTSimplify(tmpfilename);
		/*
		 * Output the directory entry.
		 */
		if (strcmp(DIRED_NAME(HTBTree_object(next_element)), "..")) {
#ifdef DIRED_SUPPORT
		    test = (DIRED_BLOK(HTBTree_object(next_element))
			    == 'D' ? 'D' : 'F');
		    if (state != test) {
#ifndef LONG_LIST
			if (dir_list_style == FILES_FIRST) {
			    if (state == 'F') {
				END(HTML_DIR);
				PUTC('\n');
			    }
			} else if (dir_list_style != MIXED_STYLE)
			    if (state == 'D') {
				END(HTML_DIR);
				PUTC('\n');
			    }
#endif /* !LONG_LIST */
			state =
			    (char) (DIRED_BLOK(HTBTree_object(next_element))
				    == 'D' ? 'D' : 'F');
			START(HTML_H2);
			if (dir_list_style != MIXED_STYLE) {
			    START(HTML_EM);
			    PUTS(state == 'D'
				 ? LABEL_SUBDIRECTORIES
				 : LABEL_FILES);
			    END(HTML_EM);
			}
			END(HTML_H2);
			PUTC('\n');
#ifndef LONG_LIST
			START(HTML_DIR);
			PUTC('\n');
#endif /* !LONG_LIST */
		    }
#else
		    if (state != DIRED_BLOK(HTBTree_object(next_element))) {
#ifndef LONG_LIST
			if (state == 'D') {
			    END(HTML_DIR);
			    PUTC('\n');
			}
#endif /* !LONG_LIST */
			state =
			    (char) (DIRED_BLOK(HTBTree_object(next_element))
				    == 'D' ? 'D' : 'F');
			START(HTML_H2);
			START(HTML_EM);
			PUTS(state == 'D'
			     ? LABEL_SUBDIRECTORIES
			     : LABEL_FILES);
			END(HTML_EM);
			END(HTML_H2);
			PUTC('\n');
#ifndef LONG_LIST
			START(HTML_DIR);
			PUTC('\n');
#endif /* !LONG_LIST */
		    }
#endif /* DIRED_SUPPORT */
#ifndef LONG_LIST
		    START(HTML_LI);
#endif /* !LONG_LIST */
		}
#ifdef LONG_LIST
		LYListFmtParse(list_format, entry, tmpfilename, target, tail);
#else
		HTDirEntry(target, tail, entry->file_name);
		PUTS(entry->file_name);
		END(HTML_A);
		MAYBE_END(HTML_LI);
		PUTC('\n');
#endif /* LONG_LIST */

		next_element = HTBTree_next(bt, next_element);
		/* pick up the next element of the list;
		   if none, return NULL */

		/* optimize for expensive operation: */
#ifdef DISP_PARTIAL
		if (num_of_entries_output %
		    (partial_threshold > 0 ? partial_threshold : display_lines)
		    == 0) {
		    /* num_of_entries, num_of_entries_output... */
		    /* HTReadProgress...(bytes, 0); */
		    HTDisplayPartial();

		    if (HTCheckForInterrupt()) {
			_HTProgress(TRANSFER_INTERRUPTED);
			status = HT_PARTIAL_CONTENT;
			break;
		    }
		}
		num_of_entries_output++;
#endif /* DISP_PARTIAL */

	    }			/* end while next_element */

	    if (status == HT_LOADED) {
		if (state == 'I') {
		    START(HTML_P);
		    PUTS("Empty Directory");
		}
#ifndef LONG_LIST
		else
		    END(HTML_DIR);
#endif /* !LONG_LIST */
	    }
	}			/* end printing out the tree in order */

	FREE(tmpfilename);
	FREE(tail);
	HTBTreeAndObject_free(bt);

	if (status == HT_LOADED) {
	    if (HTDirReadme == HT_DIR_README_BOTTOM)
		do_readme(target, localname);
	    FREE_TARGET;
	} else {
	    ABORT_TARGET;
	}
    }
    HTFinishDisplayPartial();
    return status;		/* document loaded, maybe partial */
}
#endif /* HAVE_READDIR */

#ifndef VMS
int HTStat(const char *filename,
	   struct stat *data)
{
    int result = -1;
    size_t len = strlen(filename);

    if (len != 0 && LYIsPathSep(filename[len - 1])) {
	char *temp_name = NULL;

	HTSprintf0(&temp_name, "%s.", filename);
	result = HTStat(temp_name, data);
	FREE(temp_name);
    } else {
	result = stat(filename, data);
#ifdef _WINDOWS
	/*
	 * Someone claims that stat() doesn't give the proper result for a
	 * directory on Windows.
	 */
	if (result == -1
	    && access(filename, 0) == 0) {
	    data->st_mode = S_IFDIR;
	    result = 0;
	}
#endif
    }
    return result;
}
#endif

#ifdef VMS
#define FOPEN_MODE(bin) "r", "shr=put", "shr=upd"
#define DOT_STRING "._-"	/* FIXME: should we check if suffix is after ']' or ':' ? */
#else
#define FOPEN_MODE(bin) (bin ? BIN_R : "r")
#define DOT_STRING "."
#endif

static int decompressAndParse(HTParentAnchor *anchor,
			      HTFormat format_out,
			      HTStream *sink,
			      char *nodename GCC_UNUSED,
			      char *filename,
			      HTAtom *myEncoding,
			      HTFormat format,
			      int *statusp)
{
    HTAtom *encoding = 0;

#ifdef USE_ZLIB
    FILE *zzfp = 0;
    gzFile gzfp = 0;
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
    BZFILE *bzfp = 0;
#endif /* USE_ZLIB */
#if defined(USE_ZLIB) || defined(USE_BZLIB)
    CompressFileType internal_decompress = cftNone;
    BOOL failed_decompress = NO;
#endif
    int rootlen = 0;
    char *localname = filename;
    int bin;
    FILE *fp;

#ifdef VMS
    /*
     * Assume that the file is in Unix-style syntax if it contains a '/' after
     * the leading one.  @@@@
     */
    localname = (strchr(localname + 1, '/')
		 ? HTVMS_name(nodename, localname)
		 : localname + 1);
#endif /* VMS */

    bin = HTCompressFileType(filename, ".", &rootlen) != cftNone;
    fp = fopen(localname, FOPEN_MODE(bin));

#ifdef VMS
    /*
     * If the file wasn't VMS syntax, then perhaps it is Ultrix.
     */
    if (!fp) {
	char *ultrixname = 0;

	CTRACE((tfp, "HTLoadFile: Can't open as %s\n", localname));
	HTSprintf0(&ultrixname, "%s::\"%s\"", nodename, filename);
	fp = fopen(ultrixname, FOPEN_MODE(bin));
	if (!fp) {
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", ultrixname));
	}
	FREE(ultrixname);
    }
#endif /* VMS */
    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n", localname, fp));
    if (fp) {			/* Good! */
	if (HTEditable(localname)) {
	    HTAtom *put = HTAtom_for("PUT");
	    HTList *methods = HTAnchor_methods(anchor);

	    if (HTList_indexOf(methods, put) == (-1)) {
		HTList_addObject(methods, put);
	    }
	}
	/*
	 * Fake a Content-Encoding for compressed files.  - FM
	 */
	if (!IsUnityEnc(myEncoding)) {
	    /*
	     * We already know from the call to HTFileFormat that
	     * this is a compressed file, no need to look at the filename
	     * again.  - kw
	     */
	    CompressFileType method = HTEncodingToCompressType(HTAtom_name(myEncoding));

#define isDOWNLOAD(m) (strcmp(format_out->name, "www/download") && (method == m))
#ifdef USE_ZLIB
	    if (isDOWNLOAD(cftGzip)) {
		fclose(fp);
		gzfp = gzopen(localname, BIN_R);

		CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			localname, gzfp));
		internal_decompress = cftGzip;
	    } else if (isDOWNLOAD(cftDeflate)) {
		zzfp = fp;
		fp = 0;

		CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			localname, zzfp));
		internal_decompress = cftDeflate;
	    } else
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
	    if (isDOWNLOAD(cftBzip2)) {
		fclose(fp);
		bzfp = BZ2_bzopen(localname, BIN_R);

		CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			localname, bzfp));
		internal_decompress = cftBzip2;
	    } else
#endif /* USE_BZLIB */
	    {
		StrAllocCopy(anchor->content_type, format->name);
		StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
		format = HTAtom_for("www/compressed");
	    }
	} else {
	    CompressFileType cft = HTCompressFileType(localname, DOT_STRING, &rootlen);

	    if (cft != cftNone) {
		char *cp = NULL;

		StrAllocCopy(cp, localname);
		cp[rootlen] = '\0';
		format = HTFileFormat(cp, &encoding, NULL);
		FREE(cp);
		format = HTCharsetFormat(format, anchor,
					 UCLYhndl_HTFile_for_unspec);
		StrAllocCopy(anchor->content_type, format->name);
	    }

	    switch (cft) {
	    case cftCompress:
		StrAllocCopy(anchor->content_encoding, "x-compress");
		format = HTAtom_for("www/compressed");
		break;
	    case cftDeflate:
		StrAllocCopy(anchor->content_encoding, "x-deflate");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    zzfp = fp;
		    fp = 0;

		    CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			    localname, zzfp));
		    internal_decompress = cftDeflate;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftGzip:
		StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    fclose(fp);
		    gzfp = gzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			    localname, gzfp));
		    internal_decompress = cftGzip;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftBzip2:
		StrAllocCopy(anchor->content_encoding, "x-bzip2");
#ifdef USE_BZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    fclose(fp);
		    bzfp = BZ2_bzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			    localname, bzfp));
		    internal_decompress = cftBzip2;
		}
#else /* USE_BZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_BZLIB */
		break;
	    case cftNone:
		break;
	    }
	}
#if defined(USE_ZLIB) || defined(USE_BZLIB)
	if (internal_decompress != cftNone) {
	    switch (internal_decompress) {
#ifdef USE_ZLIB
	    case cftDeflate:
		failed_decompress = (zzfp == 0);
		break;
	    case cftCompress:
	    case cftGzip:
		failed_decompress = (gzfp == 0);
		break;
#endif
#ifdef USE_BZLIB
	    case cftBzip2:
		failed_decompress = (bzfp == 0);
		break;
#endif
	    default:
		failed_decompress = YES;
		break;
	    }
	    if (failed_decompress) {
		*statusp = HTLoadError(NULL,
				       -(HT_ERROR),
				       FAILED_OPEN_COMPRESSED_FILE);
	    } else {
		char *sugfname = NULL;

		if (anchor->SugFname) {
		    StrAllocCopy(sugfname, anchor->SugFname);
		} else {
		    char *anchor_path = HTParse(anchor->address, "",
						PARSE_PATH + PARSE_PUNCTUATION);
		    char *lastslash;

		    HTUnEscape(anchor_path);
		    lastslash = strrchr(anchor_path, '/');
		    if (lastslash)
			StrAllocCopy(sugfname, lastslash + 1);
		    FREE(anchor_path);
		}
		FREE(anchor->content_encoding);
		if (sugfname && *sugfname)
		    HTCheckFnameForCompression(&sugfname, anchor,
					       TRUE);
		if (sugfname && *sugfname)
		    StrAllocCopy(anchor->SugFname, sugfname);
		FREE(sugfname);
#ifdef USE_BZLIB
		if (bzfp)
		    *statusp = HTParseBzFile(format, format_out,
					     anchor,
					     bzfp, sink);
#endif
#ifdef USE_ZLIB
		if (gzfp)
		    *statusp = HTParseGzFile(format, format_out,
					     anchor,
					     gzfp, sink);
		else if (zzfp)
		    *statusp = HTParseZzFile(format, format_out,
					     anchor,
					     zzfp, sink);
#endif
	    }
	} else
#endif /* USE_ZLIB || USE_BZLIB */
	{
	    *statusp = HTParseFile(format, format_out, anchor, fp, sink);
	    fclose(fp);
	}
	return TRUE;
    }				/* If successful open */
    return FALSE;
}

/*	Load a document.
 *	----------------
 *
 *  On entry:
 *	addr		must point to the fully qualified hypertext reference.
 *			This is the physical address of the file
 *
 *  On exit:
 *	returns		<0		Error has occurred.
 *			HTLOADED	OK
 *
 */
int HTLoadFile(const char *addr,
	       HTParentAnchor *anchor,
	       HTFormat format_out,
	       HTStream *sink)
{
    char *filename = NULL;
    char *acc_method = NULL;
    char *ftp_newhost;
    HTFormat format;
    char *nodename = NULL;
    char *newname = NULL;	/* Simplified name of file */
    HTAtom *myEncoding = NULL;	/* enc of this file, may be gzip etc. */
    int status = -1;

#ifdef VMS
    struct stat stat_info;
#endif /* VMS */

    /*
     * Reduce the filename to a basic form (hopefully unique!).
     */
    StrAllocCopy(newname, addr);
    filename = HTParse(newname, "", PARSE_PATH | PARSE_PUNCTUATION);
    nodename = HTParse(newname, "", PARSE_HOST);

    /*
     * If access is ftp, or file is on another host, invoke ftp now.
     */
    acc_method = HTParse(newname, "", PARSE_ACCESS);
    if (strcmp("ftp", acc_method) == 0 ||
	(!LYSameHostname("localhost", nodename) &&
	 !LYSameHostname(nodename, HTHostName()))) {
	status = -1;
	FREE(newname);
	FREE(filename);
	FREE(nodename);
	FREE(acc_method);
#ifndef DISABLE_FTP
	ftp_newhost = HTParse(addr, "", PARSE_HOST);
	if (strcmp(ftp_lasthost, ftp_newhost))
	    ftp_local_passive = ftp_passive;

	status = HTFTPLoad(addr, anchor, format_out, sink);

	if (ftp_passive == ftp_local_passive) {
	    if ((status >= 400) || (status < 0)) {
		ftp_local_passive = !ftp_passive;
		status = HTFTPLoad(addr, anchor, format_out, sink);
	    }
	}

	free(ftp_lasthost);
	ftp_lasthost = ftp_newhost;
#endif /* DISABLE_FTP */
	return status;
    } else {
	FREE(newname);
	FREE(acc_method);
    }
#if defined(VMS) || defined(USE_DOS_DRIVES)
    HTUnEscape(filename);
#endif /* VMS */

    /*
     * Determine the format and encoding mapped to any suffix.
     */
    if (anchor->content_type && anchor->content_encoding) {
	/*
	 * If content_type and content_encoding are BOTH already set in the
	 * anchor object, we believe it and don't try to derive format and
	 * encoding from the filename.  - kw
	 */
	format = HTAtom_for(anchor->content_type);
	myEncoding = HTAtom_for(anchor->content_encoding);
    } else {
	int default_UCLYhndl = UCLYhndl_HTFile_for_unspec;

	if (force_old_UCLYhndl_on_reload) {
	    force_old_UCLYhndl_on_reload = FALSE;
	    default_UCLYhndl = forced_UCLYhdnl;
	}

	format = HTFileFormat(filename, &myEncoding, NULL);

	/*
	 * Check the format for an extended MIME charset value, and act on it
	 * if present.  Otherwise, assume what is indicated by the last
	 * parameter (fallback will effectively be UCLYhndl_for_unspec, by
	 * default ISO-8859-1).  - kw
	 */
	format = HTCharsetFormat(format, anchor, default_UCLYhndl);
    }

#ifdef VMS
    /*
     * Check to see if the 'filename' is in fact a directory.  If it is create
     * a new hypertext object containing a list of files and subdirectories
     * contained in the directory.  All of these are links to the directories
     * or files listed.
     */
    if (HTStat(filename, &stat_info) == -1) {
	CTRACE((tfp, "HTLoadFile: Can't stat %s\n", filename));
    } else {
	if (S_ISDIR(stat_info.st_mode)) {
	    if (HTDirAccess == HT_DIR_FORBID) {
		FREE(filename);
		FREE(nodename);
		return HTLoadError(sink, 403, DISALLOWED_DIR_SCAN);
	    }

	    if (HTDirAccess == HT_DIR_SELECTIVE) {
		char *enable_file_name = NULL;

		HTSprintf0(&enable_file_name, "%s/%s", filename, HT_DIR_ENABLE_FILE);
		if (HTStat(enable_file_name, &stat_info) == -1) {
		    FREE(filename);
		    FREE(nodename);
		    FREE(enable_file_name);
		    return HTLoadError(sink, 403, DISALLOWED_SELECTIVE_ACCESS);
		}
	    }

	    FREE(filename);
	    FREE(nodename);
	    return HTVMSBrowseDir(addr, anchor, format_out, sink);
	}
    }

    if (decompressAndParse(anchor,
			   format_out,
			   sink,
			   nodename,
			   filename,
			   myEncoding,
			   format,
			   &status)) {
	FREE(nodename);
	FREE(filename);
	return status;
    }
    FREE(filename);

#else /* not VMS: */

    FREE(filename);

    /*
     * For unix, we try to translate the name into the name of a transparently
     * mounted file.
     *
     * Not allowed in secure (HTClientHost) situations.  TBL 921019
     */
#ifndef NO_UNIX_IO
    /*  Need protection here for telnet server but not httpd server. */

    if (!HTSecure) {		/* try local file system */
	char *localname = HTLocalName(addr);
	struct stat dir_info;

#ifdef HAVE_READDIR
	/*
	 * Multiformat handling.
	 *
	 * If needed, scan directory to find a good file.  Bug:  We don't stat
	 * the file to find the length.
	 */
	if ((strlen(localname) > strlen(MULTI_SUFFIX)) &&
	    (0 == strcmp(localname + strlen(localname) - strlen(MULTI_SUFFIX),
			 MULTI_SUFFIX))) {
	    DIR *dp = 0;
	    BOOL forget_multi = NO;

	    STRUCT_DIRENT *dirbuf;
	    float best = (float) NO_VALUE_FOUND;	/* So far best is bad */
	    HTFormat best_rep = NULL;	/* Set when rep found */
	    HTAtom *best_enc = NULL;
	    char *best_name = NULL;	/* Best dir entry so far */

	    char *base = strrchr(localname, '/');
	    int baselen = 0;

	    if (!base || base == localname) {
		forget_multi = YES;
	    } else {
		*base++ = '\0';	/* Just got directory name */
		baselen = strlen(base) - strlen(MULTI_SUFFIX);
		base[baselen] = '\0';	/* Chop off suffix */

		dp = opendir(localname);
	    }
	    if (forget_multi || !dp) {
		FREE(localname);
		FREE(nodename);
		return HTLoadError(sink, 500, FAILED_DIR_SCAN);
	    }

	    while ((dirbuf = readdir(dp)) != NULL) {
		/*
		 * While there are directory entries to be read...
		 */
#if !(defined(DOSPATH) || defined(__EMX__))
		if (dirbuf->d_ino == 0)
		    continue;	/* if the entry is not being used, skip it */
#endif
		if ((int) strlen(dirbuf->d_name) > baselen &&	/* Match? */
		    !strncmp(dirbuf->d_name, base, baselen)) {
		    HTAtom *enc;
		    HTFormat rep = HTFileFormat(dirbuf->d_name, &enc, NULL);
		    float filevalue = HTFileValue(dirbuf->d_name);
		    float value = HTStackValue(rep, format_out,
					       filevalue,
					       0L /* @@@@@@@@@@@@ */ );

		    if (value <= 0.0) {
			int rootlen = 0;
			const char *atomname = NULL;
			CompressFileType cft =
			HTCompressFileType(dirbuf->d_name, ".", &rootlen);
			char *cp = NULL;

			enc = NULL;
			if (cft != cftNone) {
			    StrAllocCopy(cp, dirbuf->d_name);
			    cp[rootlen] = '\0';
			    format = HTFileFormat(cp, NULL, NULL);
			    FREE(cp);
			    value = HTStackValue(format, format_out,
						 filevalue, 0);
			    switch (cft) {
			    case cftCompress:
				atomname = "application/x-compressed";
				break;
			    case cftGzip:
				atomname = "application/x-gzip";
				break;
			    case cftDeflate:
				atomname = "application/x-deflate";
				break;
			    case cftBzip2:
				atomname = "application/x-bzip2";
				break;
			    case cftNone:
				break;
			    }
			}

			if (atomname != NULL) {
			    value = HTStackValue(format, format_out,
						 filevalue, 0);
			    if (value <= 0.0) {
				format = HTAtom_for(atomname);
				value = HTStackValue(format, format_out,
						     filevalue, 0);
			    }
			    if (value <= 0.0) {
				format = HTAtom_for("www/compressed");
				value = HTStackValue(format, format_out,
						     filevalue, 0);
			    }
			}
		    }
		    if (value != NO_VALUE_FOUND) {
			CTRACE((tfp,
				"HTLoadFile: value of presenting %s is %f\n",
				HTAtom_name(rep), value));
			if (value > best) {
			    best_rep = rep;
			    best_enc = enc;
			    best = value;
			    StrAllocCopy(best_name, dirbuf->d_name);
			}
		    }		/* if best so far */
		}
		/* if match */
	    }			/* end while directory entries left to read */
	    closedir(dp);

	    if (best_rep) {
		format = best_rep;
		myEncoding = best_enc;
		base[-1] = '/';	/* Restore directory name */
		base[0] = '\0';
		StrAllocCat(localname, best_name);
		FREE(best_name);
	    } else {		/* If not found suitable file */
		FREE(localname);
		FREE(nodename);
		return HTLoadError(sink, 403, FAILED_NO_REPRESENTATION);
	    }
	    /*NOTREACHED */
	}
	/* if multi suffix */
	/*
	 * Check to see if the 'localname' is in fact a directory.  If it is
	 * create a new hypertext object containing a list of files and
	 * subdirectories contained in the directory.  All of these are links
	 * to the directories or files listed.  NB This assumes the existence
	 * of a type 'STRUCT_DIRENT', which will hold the directory entry, and
	 * a type 'DIR' which is used to point to the current directory being
	 * read.
	 */
#if defined(USE_DOS_DRIVES)
	if (strlen(localname) == 2 && LYIsDosDrive(localname))
	    LYAddPathSep(&localname);
#endif
	if (HTStat(localname, &dir_info) == -1)		/* get file information */
	{
	    /* if can't read file information */
	    CTRACE((tfp, "HTLoadFile: can't stat %s\n", localname));

	} else {		/* Stat was OK */

	    if (S_ISDIR(dir_info.st_mode)) {
		/*
		 * If localname is a directory.
		 */
		DIR *dp;
		struct stat file_info;

		CTRACE((tfp, "%s is a directory\n", localname));

		/*
		 * Check directory access.  Selective access means only those
		 * directories containing a marker file can be browsed.
		 */
		if (HTDirAccess == HT_DIR_FORBID) {
		    FREE(localname);
		    FREE(nodename);
		    return HTLoadError(sink, 403, DISALLOWED_DIR_SCAN);
		}

		if (HTDirAccess == HT_DIR_SELECTIVE) {
		    char *enable_file_name = NULL;

		    HTSprintf0(&enable_file_name, "%s/%s", localname, HT_DIR_ENABLE_FILE);
		    if (stat(enable_file_name, &file_info) != 0) {
			FREE(localname);
			FREE(nodename);
			FREE(enable_file_name);
			return HTLoadError(sink, 403, DISALLOWED_SELECTIVE_ACCESS);
		    }
		}

		CTRACE((tfp, "Opening directory %s\n", localname));
		dp = opendir(localname);
		if (!dp) {
		    FREE(localname);
		    FREE(nodename);
		    return HTLoadError(sink, 403, FAILED_DIR_UNREADABLE);
		}

		/*
		 * Directory access is allowed and possible.
		 */

		status = print_local_dir(dp, localname,
					 anchor, format_out, sink);
		closedir(dp);
		FREE(localname);
		FREE(nodename);
		return status;	/* document loaded, maybe partial */

	    }
	    /* end if localname is a directory */
	    if (S_ISREG(dir_info.st_mode)) {
#ifdef INT_MAX
		if (dir_info.st_size <= INT_MAX)
#endif
		    anchor->content_length = dir_info.st_size;
	    }

	}			/* end if file stat worked */

/* End of directory reading section
*/
#endif /* HAVE_READDIR */
	if (decompressAndParse(anchor,
			       format_out,
			       sink,
			       nodename,
			       localname,
			       myEncoding,
			       format,
			       &status)) {
	    FREE(nodename);
	    FREE(localname);
	    return status;
	}
	FREE(localname);
    }				/* local unix file system */
#endif /* !NO_UNIX_IO */
#endif /* VMS */

#ifndef DECNET
    /*
     * Now, as transparently mounted access has failed, we try FTP.
     */
    {
	/*
	 * Deal with case-sensitivity differences on VMS versus Unix.
	 */
#ifdef VMS
	if (strcasecomp(nodename, HTHostName()) != 0)
#else
	if (strcmp(nodename, HTHostName()) != 0)
#endif /* VMS */
	{
	    status = -1;
	    FREE(nodename);
	    if (strncmp(addr, "file://localhost", 16)) {
		/* never go to ftp site when URL
		 * is file://localhost
		 */
#ifndef DISABLE_FTP
		status = HTFTPLoad(addr, anchor, format_out, sink);
#endif /* DISABLE_FTP */
	    }
	    return status;
	}
	FREE(nodename);
    }
#endif /* !DECNET */

    /*
     * All attempts have failed.
     */
    {
	CTRACE((tfp, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO));

	return HTLoadError(sink, 403, FAILED_FILE_UNREADABLE);
    }
}

static const char *program_paths[pp_Last];

/*
 * Given a program number, return its path
 */
const char *HTGetProgramPath(ProgramPaths code)
{
    const char *result = NULL;

    if (code > ppUnknown && code < pp_Last)
	result = program_paths[code];
    return result;
}

/*
 * Store a program's path.  The caller must allocate the string used for 'path',
 * since HTInitProgramPaths() may free it.
 */
void HTSetProgramPath(ProgramPaths code, const char *path)
{
    if (code > ppUnknown && code < pp_Last) {
	program_paths[code] = isEmpty(path) ? 0 : path;
    }
}

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
void HTInitProgramPaths(void)
{
    ProgramPaths code;
    int n;
    const char *path;
    const char *test;

    for (n = (int) ppUnknown + 1; n < (int) pp_Last; ++n) {
	switch (code = (ProgramPaths) n) {
#ifdef BZIP2_PATH
	case ppBZIP2:
	    path = BZIP2_PATH;
	    break;
#endif
#ifdef CHMOD_PATH
	case ppCHMOD:
	    path = CHMOD_PATH;
	    break;
#endif
#ifdef COMPRESS_PATH
	case ppCOMPRESS:
	    path = COMPRESS_PATH;
	    break;
#endif
#ifdef COPY_PATH
	case ppCOPY:
	    path = COPY_PATH;
	    break;
#endif
#ifdef CSWING_PATH
	case ppCSWING:
	    path = CSWING_PATH;
	    break;
#endif
#ifdef GZIP_PATH
	case ppGZIP:
	    path = GZIP_PATH;
	    break;
#endif
#ifdef INFLATE_PATH
	case ppINFLATE:
	    path = INFLATE_PATH;
	    break;
#endif
#ifdef INSTALL_PATH
	case ppINSTALL:
	    path = INSTALL_PATH;
	    break;
#endif
#ifdef MKDIR_PATH
	case ppMKDIR:
	    path = MKDIR_PATH;
	    break;
#endif
#ifdef MV_PATH
	case ppMV:
	    path = MV_PATH;
	    break;
#endif
#ifdef RLOGIN_PATH
	case ppRLOGIN:
	    path = RLOGIN_PATH;
	    break;
#endif
#ifdef RM_PATH
	case ppRM:
	    path = RM_PATH;
	    break;
#endif
#ifdef RMDIR_PATH
	case ppRMDIR:
	    path = RMDIR_PATH;
	    break;
#endif
#ifdef TAR_PATH
	case ppTAR:
	    path = TAR_PATH;
	    break;
#endif
#ifdef TELNET_PATH
	case ppTELNET:
	    path = TELNET_PATH;
	    break;
#endif
#ifdef TN3270_PATH
	case ppTN3270:
	    path = TN3270_PATH;
	    break;
#endif
#ifdef TOUCH_PATH
	case ppTOUCH:
	    path = TOUCH_PATH;
	    break;
#endif
#ifdef UNCOMPRESS_PATH
	case ppUNCOMPRESS:
	    path = UNCOMPRESS_PATH;
	    break;
#endif
#ifdef UNZIP_PATH
	case ppUNZIP:
	    path = UNZIP_PATH;
	    break;
#endif
#ifdef UUDECODE_PATH
	case ppUUDECODE:
	    path = UUDECODE_PATH;
	    break;
#endif
#ifdef ZCAT_PATH
	case ppZCAT:
	    path = ZCAT_PATH;
	    break;
#endif
#ifdef ZIP_PATH
	case ppZIP:
	    path = ZIP_PATH;
	    break;
#endif
	default:
	    path = NULL;
	    break;
	}
	test = HTGetProgramPath(code);
	if (test != NULL && test != path) {
	    free((void *)test);
	}
	HTSetProgramPath(code, path);
    }
}

/*
 *	Protocol descriptors
 */
#ifdef GLOBALDEF_IS_MACRO
#define _HTFILE_C_1_INIT { "ftp", HTLoadFile, 0 }
GLOBALDEF(HTProtocol, HTFTP, _HTFILE_C_1_INIT);
#define _HTFILE_C_2_INIT { "file", HTLoadFile, HTFileSaveStream }
GLOBALDEF(HTProtocol, HTFile, _HTFILE_C_2_INIT);
#else
GLOBALDEF HTProtocol HTFTP =
{"ftp", HTLoadFile, 0};
GLOBALDEF HTProtocol HTFile =
{"file", HTLoadFile, HTFileSaveStream};
#endif /* GLOBALDEF_IS_MACRO */
@


1.8
log
@uh... how am I supposed to free a const char * ?
this doesn't work correctly either...
@
text
@d133 1
a133 1
static char *HTMountRoot = "/Net/";	/* Where to find mounts */
d136 1
a136 1
static char *HTCacheRoot = "/WWW$SCRATCH";	/* Where to cache things */
d139 1
a139 1
static char *HTCacheRoot = "/tmp/W3_Cache_";	/* Where to cache things */
d192 1
a192 1
static void LYListFmtParse(char *fmtstr,
d208 1
a208 1
    char *name;
d219 1
a219 1
    static char *pbits[] =
d228 1
a228 1
    static char *pbits[] =
d231 1
a231 1
    static char *psbits[] =
d239 1
a239 1
    static char *ptbits[] =
d822 1
a822 1
    char *version = strchr(filename, ';');
d828 1
a828 1
	stripped[(const char *) version - filename] = '\0';
d1204 3
a1206 3
CompressFileType HTCompressFileType(char *filename,
				    char *dots,
				    char **suffix)
d1210 1
a1210 1
    char *ftype = filename + len;
d1236 1
a1236 1
    *suffix = ftype;
d1239 1
a1239 1
	    filename, result, *suffix));
d1666 1
a1666 1
static char *file_type(char *path)
d1668 1
a1668 1
    char *type;
d2152 1
a2152 1
    char *dot = 0;
d2167 1
a2167 1
    bin = HTCompressFileType(filename, ".", &dot) != cftNone;
d2241 1
a2241 1
	    CompressFileType cft = HTCompressFileType(localname, DOT_STRING, &dot);
d2247 1
a2247 1
		cp[dot - localname] = '\0';
a2409 1
    char *dot;
d2611 2
a2612 1
			char *atomname = NULL;
d2614 1
a2614 1
			HTCompressFileType(dirbuf->d_name, ".", &dot);
d2620 1
a2620 1
			    cp[dot - dirbuf->d_name] = '\0';
d2860 2
a2861 1
    int code;
d2865 2
a2866 2
    for (code = (int) ppUnknown + 1; code < (int) pp_Last; ++code) {
	switch (code) {
@


1.7
log
@* fix a few cases where DESTDIR wasn't honoured
* fix a few cases where CFLAGS (specifically the
  new global -Werror) wasn't honoured
* fix a bunch of warnings and errors
  (for takers: there are quite a few left, I fixed
  the most important ones. Don't care about gcc3.2
  though, it'll die RSN. Perl or Lynx are probably
  good targets.)
* fix parameter passing to HTML manpage generation
  (noticed outside the chroot and with a known bad
  config only... jarejare... we should build stuff
  with a ports-like systrace (I have worn the idea
  for weeks).
* sync lists

I'm not too sure about this code being release-quality
yet, but OTOH it works without too much failures.
@
text
@d2982 1
a2982 1
	    free(test);
@


1.6
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d1 20
a20 18
/* $MirBSD: HTFile.c,v 1.5 2003/07/07 19:56:57 tg Exp $
 *-
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
 *
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicense it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extend permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
 *-
 * These are patches to the Lynx web browser, which is licensed under
 * the GNU General Public License, Version 2.
a22 22
/*			File Access				HTFile.c
**			===========
**
**	This is unix-specific code in general, with some VMS bits.
**	These are routines for file access used by browsers.
**	Development of this module for Unix DIRED_SUPPORT in Lynx
**	 regrettably has has been conducted in a manner with now
**	 creates a major impediment for hopes of adapting Lynx to
**	 a newer version of the library.
**
**  History:
**	   Feb 91	Written Tim Berners-Lee CERN/CN
**	   Apr 91	vms-vms access included using DECnet syntax
**	26 Jun 92 (JFG) When running over DECnet, suppressed FTP.
**			Fixed access bug for relative names on VMS.
**	   Sep 93 (MD)	Access to VMS files allows sharing.
**	15 Nov 93 (MD)	Moved HTVMSname to HTVMSUTILS.C
**	27 Dec 93 (FM)	FTP now works with VMS hosts.
**			FTP path must be Unix-style and cannot include
**			the device or top directory.
*/

d28 2
a29 2
#define LONG_LIST  /* Define this for long style unix listings (ls -l),
		     the actual style is configurable from lynx.cfg */
d31 1
a31 1
/* #define NO_PARENT_DIR_REFERENCE */ /* Define this for no parent links */
d49 1
a49 1
#ifdef USE_ZLIB
d80 5
a84 5
	char *		suffix;
	HTAtom *	rep;
	HTAtom *	encoding;
	char *		desc;
	float		quality;
d90 1
a90 1
    char file_name[1];	/* on the end of the struct, since its length varies */
d117 2
a118 2
	CONST HTStructuredClass *	isa;
	/* ... */
d122 3
a124 3
**  Controlling globals.
*/
PUBLIC int HTDirAccess = HT_DIR_OK;
d127 2
a128 1
PUBLIC int HTDirReadme = HT_DIR_README_NONE;
d130 1
a130 1
PUBLIC int HTDirReadme = HT_DIR_README_TOP;
d133 2
a134 1
PRIVATE char *HTMountRoot = "/Net/";		/* Where to find mounts */
d136 2
a137 1
PRIVATE char *HTCacheRoot = "/WWW$SCRATCH";	/* Where to cache things */
d139 1
a139 1
PRIVATE char *HTCacheRoot = "/tmp/W3_Cache_";	/* Where to cache things */
d143 7
a149 6
**  Suffix registration.
*/
PRIVATE HTList * HTSuffixes = 0;
PRIVATE HTSuffix no_suffix = { "*", NULL, NULL, NULL, 1.0 };
PRIVATE HTSuffix unknown_suffix = { "*.*", NULL, NULL, NULL, 1.0};

d152 2
a153 2
**	----------------------------------------
*/
d155 1
a155 1
PRIVATE void free_suffixes NOPARAMS;
d159 3
a161 4
PRIVATE char *FormatStr ARGS3(
    char **,	bufp,
    char *,	start,
    CONST char *,	entry)
d164 1
d176 3
a178 4
PRIVATE char *FormatNum ARGS3(
    char **,	bufp,
    char *,	start,
    int,	entry)
d181 1
d192 15
a206 15
PRIVATE void LYListFmtParse ARGS5(
	char *,		fmtstr,
	DIRED *,	data,
	char *,		file,
	HTStructured *, target,
	char *,		tail)
{
	char c;
	char *s;
	char *end;
	char *start;
	char *str = NULL;
	char *buf = NULL;
	char tmp[LY_MAXPATH];
	char type;
d208 1
a208 1
	char *name;
d210 3
a212 2
	time_t now;
	char *datestr;
d214 1
a214 1
	int len;
d218 7
a224 5
#ifdef _WINDOWS	/* 1998/01/06 (Tue) 21:20:53 */
	static char *pbits[] = {
		"---", "--x", "-w-", "-wx",
		"r--", "r-x", "rw-", "rwx",
		0 };
d228 7
a234 4
	static char *pbits[] = { "---", "--x", "-w-", "-wx",
		"r--", "r-x", "rw-", "rwx", 0 };
	static char *psbits[] = { "--S", "--s", "-wS", "-ws",
		"r-S", "r-s", "rwS", "rws", 0 };
d239 4
a242 2
	static char *ptbits[] = { "--T", "--t", "-wT", "-wt",
		"r-T", "r-t", "rwT", "rwt", 0 };
d248 2
a249 2
	if (data->file_info.st_mode == 0)
		fmtstr = "    %a";	/* can't stat so just do anchor */
d251 6
a256 4
	StrAllocCopy(str, fmtstr);
	s = str;
	end = str + strlen(str);
	START(HTML_PRE);
d258 34
a291 36
		start = s;
		while (*s) {
			if (*s == '%') {
				if (*(s+1) == '%') /* literal % */
					s++;
				else
					break;
			}
			s++;
		}
		/* s is positioned either at a % or at \0 */
		*s = '\0';
		if (s > start) {	/* some literal chars. */
			PUTS(start);
		}
		if (s == end)
			break;
		start = ++s;
		while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
		    *s == '#' || *s == '+' || *s == '\'')
			s++;
		c = *s;		/* the format char. or \0 */
		*s = '\0';

		switch (c) {
		case '\0':
			PUTS(start);
			continue;

		case 'A':
		case 'a':	/* anchor */
			HTDirEntry(target, tail, data->file_name);
			FormatStr(&buf, start, data->file_name);
			PUTS(buf);
			END(HTML_A);
			*buf = '\0';
d293 6
a298 6
			if (c != 'A' && S_ISLNK(data->file_info.st_mode) &&
			    (len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
				PUTS(" -> ");
				tmp[len] = '\0';
				PUTS(tmp);
			}
d300 15
a314 1
			break;
d316 7
a322 5
		case 'T':	/* MIME type */
		case 't':	/* MIME type description */
		    if (S_ISDIR(data->file_info.st_mode)) {
			if (c != 'T') {
			    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
d324 1
a324 21
			    FormatStr(&buf, start, "");
			}
		    } else {
			CONST char *cp2;
			HTFormat format;
			format = HTFileFormat(file, NULL, &cp2);

			if (c != 'T') {
			    if (cp2 == NULL) {
				if (!strncmp(HTAtom_name(format),
					     "application",11)) {
				    cp2 = HTAtom_name(format) + 12;
				    if (!strncmp(cp2,"x-",2))
					cp2 += 2;
				} else {
				    cp2 = HTAtom_name(format);
				}
			    }
			    FormatStr(&buf, start, cp2);
			} else {
			    FormatStr(&buf, start, HTAtom_name(format));
d327 6
a332 1
		    break;
d334 16
a349 16
		case 'd':	/* date */
			now = time(0);
			datestr = ctime(&data->file_info.st_mtime);
			if ((now - data->file_info.st_mtime) < SEC_PER_YEAR/2)
				/*
				**  MMM DD HH:MM
				*/
				sprintf(tmp, "%.12s", datestr + 4);
			else
				/*
				**  MMM DD  YYYY
				*/
				sprintf(tmp, "%.7s %.4s ", datestr + 4,
					datestr + 20);
			FormatStr(&buf, start, tmp);
			break;
d351 3
a353 3
		case 's':	/* size in bytes */
			FormatNum(&buf, start, (int) data->file_info.st_size);
			break;
d355 11
a365 11
		case 'K':	/* size in Kilobytes but not for directories */
			if (S_ISDIR(data->file_info.st_mode)) {
				FormatStr(&buf, start, "");
				StrAllocCat(buf, " ");
				break;
			}
			/* FALL THROUGH */
		case 'k':	/* size in Kilobytes */
			FormatNum(&buf, start, (int)((data->file_info.st_size+1023)/1024));
			StrAllocCat(buf, "K");
			break;
d367 2
a368 2
		case 'p':	/* unix-style permission bits */
			switch(data->file_info.st_mode & S_IFMT) {
d370 3
a372 1
			case _S_IFIFO: type = 'p'; break;
d374 3
a376 1
			case S_IFIFO: type = 'p'; break;
d378 9
a386 3
			case S_IFCHR: type = 'c'; break;
			case S_IFDIR: type = 'd'; break;
			case S_IFREG: type = '-'; break;
d388 3
a390 1
			case S_IFBLK: type = 'b'; break;
d393 3
a395 1
			case S_IFLNK: type = 'l'; break;
d398 1
a398 1
# ifdef S_IFIFO		/* some older machines (e.g., apollo) have a conflict */
d400 3
a402 1
			case S_IFSOCK: type = 's'; break;
d405 3
a407 1
			case S_IFSOCK: type = 's'; break;
d410 4
a413 2
			default: type = '?'; break;
			}
d415 2
a416 2
			sprintf(tmp, "%c%s", type,
				PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_IRWXU));
d418 4
a421 4
			sprintf(tmp, "%c%s%s%s", type,
				PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_ISUID),
				PBIT(data->file_info.st_mode, 3, data->file_info.st_mode & S_ISGID),
				PTBIT(data->file_info.st_mode,   data->file_info.st_mode & S_ISVTX));
d423 2
a424 2
			FormatStr(&buf, start, tmp);
			break;
d426 1
a426 1
		case 'o':	/* owner */
d428 6
a433 6
			name = HTAA_UidToName (data->file_info.st_uid);
			if (*name) {
				FormatStr(&buf, start, name);
			} else {
				FormatNum(&buf, start, (int) data->file_info.st_uid);
			}
d435 1
a435 1
			break;
d437 1
a437 1
		case 'g':	/* group */
d439 6
a444 6
			name = HTAA_GidToName(data->file_info.st_gid);
			if (*name) {
				FormatStr(&buf, start, name);
			} else {
				FormatNum(&buf, start, (int) data->file_info.st_gid);
			}
d446 1
a446 1
			break;
d448 3
a450 3
		case 'l':	/* link count */
			FormatNum(&buf, start, (int) data->file_info.st_nlink);
			break;
d452 3
a454 3
		case '%':	/* literal % with flags/width */
			FormatStr(&buf, start, "%");
			break;
d456 7
a462 7
		default:
			fprintf(stderr,
			"Unknown format character `%c' in list format\n", c);
			break;
		}
		if (buf)
		    PUTS(buf);
d464 6
a469 6
		s++;
	}
	FREE(buf);
	END(HTML_PRE);
	PUTC('\n');
	FREE(str);
d474 18
a491 19
**	--------------------------------------------------------
**
**	Calling this with suffix set to "*" will set the default
**	representation.
**	Calling this with suffix set to "*.*" will set the default
**	representation for unknown suffix files which contain a ".".
**
**	The encoding parameter can give a trivial (8bit, 7bit, binary)
**	or real (gzip, compress) encoding.
**
**	If filename suffix is already defined with the same encoding
**	its previous definition is overridden.
*/
PUBLIC void HTSetSuffix5 ARGS5(
	CONST char *,	suffix,
	CONST char *,	representation,
	CONST char *,	encoding,
	CONST char *,	desc,
	double,		value)
d493 1
a493 1
    HTSuffix * suff;
d503 1
a503 1
	while (NULL != (suff = (HTSuffix*)HTList_nextObject(cur))) {
d507 1
a507 1
		     strcmp(encoding, HTAtom_name(suff->encoding)) == 0)))
d510 1
a510 1
	if (!suff) { /* Not found -- create a new node */
d516 4
a519 4
	    **	Memory leak fixed.
	    **	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	    */
	    if (!HTSuffixes)	{
d536 4
a539 4
    **	Memory leak fixed.
    **	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
    **	Invariant code removed.
    */
d549 9
a557 9
**	Purpose:	Free all added suffixes.
**	Arguments:	void
**	Return Value:	void
**	Remarks/Portability/Dependencies/Restrictions:
**		To be used at program exit.
**	Revision History:
**		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void free_suffixes NOARGS
d559 1
a559 1
    HTSuffix * suff = NULL;
d562 2
a563 2
    **	Loop through all suffixes.
    */
d566 3
a568 3
	**  Free off each item and its members if need be.
	*/
	suff = (HTSuffix *)HTList_removeLastObject(HTSuffixes);
d574 2
a575 2
    **	Free off the list itself.
    */
a580 1

d582 10
a591 11
**	-------------------------------------------
**	Make up a suitable name for saving the node in
**
**	E.g.	/tmp/WWW_Cache_news/1234@@cernvax.cern.ch
**		/tmp/WWW_Cache_http/crnvmc/FIND/xx.xxx.xx
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
PUBLIC char * HTCacheFileName ARGS1(
	CONST char *,	name)
d593 4
a596 4
    char * acc_method = HTParse(name, "", PARSE_ACCESS);
    char * host = HTParse(name, "", PARSE_HOST);
    char * path = HTParse(name, "", PARSE_PATH+PARSE_PUNCTUATION);
    char * result = NULL;
d607 2
a608 2
**	-----------------------------------------
*/
d610 1
a610 1
PRIVATE int HTCreatePath ARGS1(CONST char *,path)
d617 12
a628 13
**	----------------------------------------------------------
**	Input name is assumed to be the URL-path of a local file
**      URL, i.e. what comes after the "file://localhost".
**      '#'-fragments to be treated as such must already be stripped.
**      If expand_all is FALSE, unescape only escaped '/'. - kw
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
PUBLIC char * HTURLPath_toFile ARGS3(
	CONST char *,	name,
	BOOL,		expand_all,
	BOOL,		is_remote GCC_UNUSED)
d630 2
a631 2
    char * path = NULL;
    char * result = NULL;
d635 1
a635 1
	HTUnEscape(path);		/* Interpret all % signs */
d651 9
a659 9
**	------------------------------------------------
**	Make up a suitable name for saving the node in
**
**	E.g.	$(HOME)/WWW/news/1234@@cernvax.cern.ch
**		$(HOME)/WWW/http/crnvmc/FIND/xx.xxx.xx
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
d665 9
a673 10
PUBLIC char * HTnameOfFile_WWW ARGS3(
	CONST char *,	name,
	BOOL,		WWW_prefix,
	BOOL,		expand_all)
{
    char * acc_method = HTParse(name, "", PARSE_ACCESS);
    char * host = HTParse(name, "", PARSE_HOST);
    char * path = HTParse(name, "", PARSE_PATH+PARSE_PUNCTUATION);
    char * home;
    char * result = NULL;
d676 1
a676 1
	HTUnEscape(path);		/* Interpret all % signs */
d680 2
a681 2
    if (0 == strcmp(acc_method, "file")	/* local file */
     || !*acc_method) {			/* implicitly local? */
d692 1
a692 1
    } else if (WWW_prefix) {  /* other access */
d699 2
a700 2
#if defined(_WINDOWS)	/* 1997/10/16 (Thu) 20:42:51 */
	home =  (char *)Home_Dir();
d723 8
a730 9
**	--------------------------------------------
**
**  Bugs:
**	At present, only the names of two network root nodes are hand-coded
**	in and valid for the NeXT only.  This should be configurable in
**	the general case.
*/
PUBLIC char * WWW_nameOfFile ARGS1(
	CONST char *,	name)
d732 2
a733 1
    char * result = NULL;
d736 1
a736 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name+13);
d740 1
a740 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name+5);
d749 12
a760 13
**	------------------------------------------------------
**
**  On entry,
**	rep	is the atomized MIME style representation
**	enc	is an encoding, trivial (8bit, binary, etc.) or gzip etc.
**
**  On exit:
**	Returns a pointer to a suitable suffix string if one has been
**	found, else "".
*/
PUBLIC CONST char * HTFileSuffix ARGS2(
	HTAtom*,	rep,
	CONST char *,	enc)
d762 2
a763 1
    HTSuffix * suff;
d765 1
a765 1
    HTSuffix * first_found = NULL;
d771 1
a771 1
#define NO_INIT  /* don't init anymore since I do it in Lynx at startup */
d780 1
a780 1
	suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
d783 3
a785 3
	    /*	Don't return a suffix whose first char is a dot, and which
		has more dots or asterisks after that, for
		these systems - kw */
d796 2
a797 3
		 *  If length of suffix (including dot) is 4 or smaller,
		 *  return this one even if we found a longer one
		 *  earlier - kw
d801 1
a801 1
		first_found = suff;		/* remember this one */
d804 1
a804 1
	    return suff->suffix;		/* OK -- found */
d812 1
a812 1
    return "";		/* Dunno */
d815 23
d839 13
a851 14
**	-------------------------------------
**
**	This version will return the representation and also set
**	a variable for the encoding.
**
**	Encoding may be a unity encoding (binary, 8bit, etc.) or
**	a content-coding like gzip, compress.
**
**	It will handle for example  x.txt, x.txt,Z, x.Z
*/
PUBLIC HTFormat HTFileFormat ARGS3(
	CONST char *,	filename,
	HTAtom **,	pencoding,
	CONST char**,	pdesc)
d853 1
a853 1
    HTSuffix * suff;
d857 2
a858 3
#ifdef VMS
    char *semicolon = NULL;
#endif /* VMS */
a868 11

#ifdef VMS
    /*
    **	Trim at semicolon if a version number was
    **	included, so it doesn't interfere with the
    **	code for getting the MIME type. - FM
    */
    if ((semicolon = strchr(filename, ';')) != NULL)
	*semicolon = '\0';
#endif /* VMS */

d873 1
a873 1
    lf	= strlen(filename);
d877 2
a878 1
	suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
d882 1
d888 1
a888 5
#ifdef VMS
		if (semicolon != NULL)
		    *semicolon = ';';
#endif /* VMS */
		return suff->rep;		/* OK -- found */
d890 1
a890 1
	    for (j = 0; j < n; j++) {  /* Got encoding, need representation */
d892 2
a893 1
		suff = (HTSuffix *)HTList_objectAt(HTSuffixes, j);
d895 3
a897 2
		if ((ls + ls2 <= lf) && 0 == strncasecomp(
			suff->suffix, filename + lf - ls -ls2, ls2)) {
a904 4
#ifdef VMS
			if (semicolon != NULL)
			    *semicolon = ';';
#endif /* VMS */
d916 2
a917 2
	 ( unknown_suffix.rep ? &unknown_suffix : &no_suffix)
	 : &no_suffix;
d920 7
a926 9
    **	Set default encoding unless found with suffix already.
    */
    if (pencoding && !*pencoding)
	*pencoding = suff->encoding ? suff->encoding
				    : HTAtom_for("binary");
#ifdef VMS
    if (semicolon != NULL)
	*semicolon = ';';
#endif /* VMS */
d931 10
a940 11
**	-------------------------------------------------------
**
**	This checks the format associated with an anchor for
**	an extended MIME Content-Type, and if a charset is
**	indicated, sets Lynx up for proper handling in relation
**	to the currently selected character set. - FM
*/
PUBLIC HTFormat HTCharsetFormat ARGS3(
	HTFormat,		format,
	HTParentAnchor *,	anchor,
	int,			default_LYhndl)
d952 1
a952 1
		    format->name));
d956 1
a956 1
	StrAllocCopy(cp3, cp2); /* copy to mutilate more */
d958 1
a958 1
			 *cp4 != ';'  && *cp4 != ':' &&
d960 1
a960 1
	    ; /* do nothing */
d975 2
a976 2
	    **	Got something but we don't recognize it.
	    */
d979 5
a983 5
	    /*
	    **  UCLYhndl_for_unrec not defined :-(
	    **  fallback to UCLYhndl_for_unspec which always valid.
	    */
	    chndl = UCLYhndl_for_unspec;  /* always >= 0 */
d998 1
d1001 2
a1002 2
		**  Try again.
		*/
d1033 15
a1047 21
	    **  Cannot translate.
	    **  If according to some heuristic the given
	    **  charset and the current display character
	    **  both are likely to be like ISO-8859 in
	    **  structure, pretend we have some kind
	    **  of match.
	    */
	    BOOL given_is_8859
		= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		   isdigit(UCH(cp4[9])));
	    BOOL given_is_8859like
		= (BOOL) (given_is_8859 ||
		   !strncmp(cp4, "windows-", 8) ||
		   !strncmp(cp4, "cp12", 4) ||
		   !strncmp(cp4, "cp-12", 5));
	    BOOL given_and_display_8859like
		= (BOOL) (given_is_8859like &&
		   (strstr(LYchar_set_names[current_char_set],
			   "ISO-8859") ||
		    strstr(LYchar_set_names[current_char_set],
			   "windows-")));
d1069 3
a1071 4
	**  No charset parameter is present.
	**  Ignore all other parameters, as
	**  we do when charset is present. - FM
	*/
d1078 2
a1079 2
    **	Set up defaults, if needed. - FM
    */
d1086 3
a1088 3
			    UCT_STAGE_PARSER,
			    UCT_STAGE_MIME,
			    -1);
a1092 2


d1094 34
a1127 35
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
PUBLIC void LYGetFileInfo ARGS7(
	CONST char *,		filename,
	HTParentAnchor **,	pfile_anchor,
	HTFormat *,		pformat,
	HTAtom **,		pencoding,
	CONST char**,		pdesc,
	CONST char**,		pcharset,
	int *,			pfile_cs)
{
	char *Afn;
	char *Aname = NULL;
	HTFormat format;
	HTAtom * myEnc = NULL;
	HTParentAnchor *file_anchor;
	CONST char *file_csname;
	int file_cs;
d1129 18
a1146 38
	/*
	 *  Convert filename to URL.  Note that it is always supposed to
	 *  be a filename, not maybe-filename-maybe-URL, so we don't
	 *  use LYFillLocalFileURL and LYEnsureAbsoluteURL. - kw
	 */
	Afn = HTEscape(filename, URL_PATH);
	LYLocalFileToURL(&Aname, Afn);
	file_anchor = HTAnchor_findSimpleAddress(Aname);

	file_csname = file_anchor->charset;
	format = HTFileFormat(filename, &myEnc, pdesc);
	format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
	file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
	if (!file_csname) {
	    if (file_cs >= 0)
		file_csname = LYCharSet_UC[file_cs].MIMEname;
	    else file_csname = "display character set";
	}
	CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	       filename,
	       ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
		*HTAtom_name(format) == 'a' ? "n" : ""),
	       myEnc ? HTAtom_name(myEnc) : "",
	       HTAtom_name(format),
	       file_csname,
	       file_cs));
	FREE(Afn);
	FREE(Aname);
	if (pfile_anchor)
	    *pfile_anchor = file_anchor;
	if (pformat)
	    *pformat = format;
	if (pencoding)
	    *pencoding = myEnc;
	if (pcharset)
	    *pcharset = file_csname;
	if (pfile_cs)
	    *pfile_cs = file_cs;
d1148 21
d1171 4
a1174 5
**	-------------------------------
**
*/
PUBLIC float HTFileValue ARGS1(
	CONST char *,	filename)
d1176 1
a1176 1
    HTSuffix * suff;
d1188 2
a1189 1
	suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
d1191 1
a1191 1
	if ((ls <= lf) && 0==strcmp(suff->suffix, filename + lf - ls)) {
d1193 2
a1194 2
			filename, suff->quality));
	    return suff->quality;		/* OK -- found */
d1197 1
a1197 1
    return (float)0.3;		/* Dunno! */
d1201 6
a1206 7
**  Determine compression type from file name, by looking at its suffix.
**  Sets as side-effect a pointer to the "dot" that begins the suffix.
*/
PUBLIC CompressFileType HTCompressFileType ARGS3(
	char *,		filename,
	char *,		dots,
	char **,	suffix)
d1212 2
d1215 2
a1216 2
     && !strcasecomp((ftype - 3), "bz2")
     && strchr(dots, ftype[-4]) != 0) {
d1220 2
a1221 2
     && !strcasecomp((ftype - 2), "gz")
     && strchr(dots, ftype[-3]) != 0) {
d1224 5
d1230 2
a1231 2
     && !strcmp((ftype - 1), "Z")
     && strchr(dots, ftype[-2]) != 0) {
d1237 1
d1239 31
a1269 1
		 filename, result, *suffix));
d1274 10
a1283 11
**	---------------------------------
**
**  On exit:
**	Returns YES if file can be accessed and can be written to.
**
**  Bugs:
**	1.	No code for non-unix systems.
**	2.	Isn't there a quicker way?
*/
PUBLIC BOOL HTEditable ARGS1(
	CONST char *,	filename)
d1287 2
a1288 2
    uid_t	myUid;
    int		ngroups;			/* The number of groups	 */
d1290 1
a1290 1
    int		i;
d1292 2
a1293 2
    if (stat(filename, &fileStatus))		/* Get details of filename */
	return NO;				/* Can't even access file! */
d1296 1
a1296 1
    myUid = geteuid();				/* Get my user identifier */
d1300 1
d1302 6
a1307 6
	    "File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",
	    (unsigned int) fileStatus.st_mode,
	    (int) fileStatus.st_uid,
	    (int) fileStatus.st_gid,
	    (int) myUid,
	    (int) ngroups);
d1313 1
a1313 1
    if (fileStatus.st_mode & 0002)		/* I can write anyway? */
d1316 2
a1317 2
    if ((fileStatus.st_mode & 0200)		/* I can write my own file? */
     && (fileStatus.st_uid == myUid))
d1320 1
a1320 1
    if (fileStatus.st_mode & 0020)		/* Group I am in can write? */
d1329 1
a1329 1
    return NO;					/* If no excuse, can't do */
d1333 6
a1338 7
**	-------------------
**
**	The stream must be used for writing back the file.
**	@@@@@@ no backup done
*/
PUBLIC HTStream * HTFileSaveStream ARGS1(
	HTParentAnchor *,	anchor)
d1340 3
a1342 3
    CONST char * addr = anchor->address;
    char * localname = HTLocalName(addr);
    FILE * fp = fopen(localname, BIN_W);
d1352 8
a1359 10
**	---------------------------
*/
PUBLIC void HTDirEntry ARGS3(
	HTStructured *, target,
	CONST char *,	tail,
	CONST char *,	entry)
{
    char * relative = NULL;
    char * stripped = NULL;
    char * escaped = NULL;
d1377 2
a1378 2
	**  Handle extra slash at end of path.
	*/
d1382 2
a1383 2
	**  If empty tail, gives absolute ref below.
	*/
d1386 3
a1388 3
			   tail,
			   (*escaped != '\0' ? "/" : ""),
			   escaped);
d1397 19
a1415 21
**	------------------------------
**
**    This gives the TITLE and H1 header, and also a link
**    to the parent directory if appropriate.
**
**  On exit:
**	Returns TRUE if an "Up to <parent>" link was not created
**	for a readable local directory because LONG_LIST is defined
**	and NO_PARENT_DIR_REFERENCE is not defined, so that the
**	calling function should use LYListFmtParse() to create a link
**	to the parent directory.  Otherwise, it returns FALSE. - FM
*/
PUBLIC BOOL HTDirTitles ARGS3(
	HTStructured *, target,
	HTParentAnchor *, anchor,
	BOOL,		tildeIsTop)
{
    CONST char * logical = anchor->address;
    char * path = HTParse(logical, "", PARSE_PATH + PARSE_PUNCTUATION);
    char * current;
    char * cp = NULL;
d1418 1
d1421 2
a1422 2
		     && !strncasecomp(logical, "file://localhost/", 17)
		     && LYIsDosDrive(logical + 17));
d1424 1
d1430 3
a1432 3
    **	Check tildeIsTop for treating home directory as Welcome
    **	(assume the tilde is not followed by a username). - FM
    */
d1445 2
a1446 2
    **	Trim out the ;type= parameter, if present. - FM
    */
d1448 4
a1451 4
	if (!strncasecomp((cp+1), "type=", 5)) {
	    if (TOUPPER(*(cp+6)) == 'D' ||
		TOUPPER(*(cp+6)) == 'A' ||
		TOUPPER(*(cp+6)) == 'I')
d1456 1
a1456 1
    current = LYPathLeaf (path);	/* last part or "" */
d1459 1
a1459 1
      char * printable = NULL;
d1462 11
a1472 12
      printable = HTURLPath_toFile(
	    (0 == strncasecomp(path, "/%2F", 4))	/* "//" ? */
	    ? (path+1)
	    : path,
	    TRUE,
	    is_remote);
      if (0 == strncasecomp(printable, "/vmsysu:", 8) ||
	  0 == strncasecomp(printable, "/anonymou.", 10)) {
	  StrAllocCopy(cp, (printable+1));
	  StrAllocCopy(printable, cp);
	  FREE(cp);
      }
d1474 2
a1475 2
      StrAllocCopy(printable, current);
      HTUnEscape(printable);
d1478 9
a1486 9
      START(HTML_HEAD);
      PUTC('\n');
      START(HTML_TITLE);
      PUTS(*printable ? printable : WELCOME_MSG);
      PUTS(SEGMENT_DIRECTORY);
      END(HTML_TITLE);
      PUTC('\n');
      END(HTML_HEAD);
      PUTC('\n');
d1489 10
a1498 10
      START(HTML_H2);
      PUTS(*printable ? SEGMENT_CURRENT_DIR : "");
      PUTS(*printable ? printable : WELCOME_MSG);
      END(HTML_H2);
      PUTC('\n');
#else
      START(HTML_H1);
      PUTS(*printable ? printable : WELCOME_MSG);
      END(HTML_H1);
      PUTC('\n');
d1500 10
a1509 10
      if (((0 == strncasecomp(printable, "vmsysu:", 7)) &&
	   (cp = strchr(printable, '.')) != NULL &&
	   strchr(cp, '/') == NULL) ||
	  (0 == strncasecomp(printable, "anonymou.", 9) &&
	   strchr(printable, '/') == NULL)) {
	  FREE(printable);
	  FREE(path);
	  return(need_parent_link);
      }
      FREE(printable);
d1514 2
a1515 2
    **	Make link back to parent directory.
    */
d1517 4
a1520 4
      && LYIsPathSep(current[-1])
      && current[0] != '\0') {	/* was a slash AND something else too */
	char * parent = NULL;
	char * relative = NULL;
d1523 1
a1523 1
	parent = strrchr(path, '/');  /* penultimate slash */
d1530 1
a1530 1
	    return(need_parent_link);
d1538 1
a1538 1
	    if (parent != 0 && strlen(parent) == 3 ) {
d1541 1
a1541 2
	}
	else
d1547 7
a1553 7
	    **	On Unix, if it's not ftp and the directory cannot
	    **	be read, don't put out a link.
	    **
	    **	On VMS, this problem is dealt with internally by
	    **	HTVMSBrowseDir().
	    */
	    DIR  * dp = NULL;
d1557 7
a1563 8
		**  We need an absolute file path for the opendir.
		**  We also need to unescape for this test.
		**  Don't worry about %2F now, they presumably have been
		**  dealt with above, and shouldn't appear for local
		**  files anyway...  Assume OS / filesystem will just
		**  ignore superfluous slashes. - KW
		*/
		char * fullparentpath = NULL;
d1566 2
a1567 2
		**  Path has been shortened above.
		*/
d1571 6
a1576 6
		**  Guard against weirdness.
		*/
		if (0 == strcmp(current,"..")) {
		    StrAllocCat(fullparentpath,"/../..");
		} else if (0 == strcmp(current,".")) {
		    StrAllocCat(fullparentpath,"/..");
d1584 1
a1584 1
		    return(need_parent_link);
d1592 1
a1592 1
		return(need_parent_link);
d1602 2
a1603 2
	    if ((0 == strcmp(current,".")) ||
		(0 == strcmp(current,".."))) {
d1605 3
a1607 3
		**  Should not happen, but if it does,
		**  at least avoid giving misleading info. - KW
		*/
d1610 2
a1611 1
		char * printable = NULL;
d1626 1
a1626 1
    return(need_parent_link);
d1631 5
a1635 5
**	-----------------
**
**  If a README file exists, then it is inserted into the document here.
*/
PRIVATE void do_readme ARGS2(HTStructured *, target, CONST char *, localname)
d1637 2
a1638 2
    FILE * fp;
    char * readme_file_name = NULL;
d1648 1
a1648 1
	targetClass =  *target->isa;	/* (Can't init agregate in K&R) */
d1651 1
a1651 1
	    PUTC((char)ch);
d1666 1
a1666 1
PRIVATE char *file_type ARGS1(char *, path)
d1669 1
d1679 1
a1679 1
PRIVATE int dired_cmp ARGS2(void *, a, void *, b)
d1681 2
a1682 2
    DIRED *p = (DIRED *)a;
    DIRED *q = (DIRED *)b;
d1684 1
d1724 4
a1727 6
PRIVATE int print_local_dir ARGS5(
	DIR  *,			dp,
	char *,			localname,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
d1731 1
a1731 1
    STRUCT_DIRENT * dirbuf;
d1735 1
a1735 1
    char * tmpfilename = NULL;
d1739 5
d1750 1
a1750 1
    if (!strcmp(pathname,"/")) {
d1752 3
a1754 3
	**  Root path.
	*/
	StrAllocCopy (tail, "/foo/..");
d1756 1
a1756 1
	char *p = strrchr(pathname, '/');  /* find last slash */
d1760 4
a1763 4
	    **	This probably should not happen,
	    **	but be prepared if it does. - KW
	    */
	    StrAllocCopy (tail, "/foo/..");
d1766 2
a1767 2
	    **	Take slash off the beginning.
	    */
d1781 1
a1781 1
    targetClass = *target->isa;	    /* Copy routine entry points */
d1787 5
a1791 7
    **	The need_parent_link flag will be set if an
    **	"Up to <parent>" link was not created for a
    **	readable parent in HTDirTitles() because
    **	LONG_LIST is defined and NO_PARENT_DIR_REFERENCE
    **	is not defined so that need we to create the
    **	link via an LYListFmtParse() call. - FM
    */
d1804 2
a1805 2
	HTBTree * bt = HTBTree_new(dired_cmp);
	int num_of_entries = 0;	    /* lines counter */
d1807 2
a1808 2
	_HTProgress (READING_DIRECTORY);
	status = HT_LOADED; /* assume we don't get interrupted */
d1811 2
a1812 2
	    **	While there are directory entries to be read...
	    */
d1818 2
a1819 2
		**  If the entry is not being used, skip it.
		*/
d1823 5
a1827 6
	    **	Skip self, parent if handled in HTDirTitles()
	    **	or if NO_PARENT_DIR_REFERENCE is not defined,
	    **	and any dot files if no_dotfiles is set or
	    **	show_dotfiles is not set. - FM
	    */
	    if (!strcmp(dirbuf->d_name, ".")   /* self	 */ ||
d1837 2
a1838 2
	    **  If filename is not root directory, add trailing separator.
	    */
d1842 1
a1842 1
	    data = (DIRED *)malloc(sizeof(DIRED) + strlen(dirbuf->d_name) + 4);
d1844 15
a1858 1
		/* FIXME */
d1860 4
a1863 3
	    LYTrimPathSep (tmpfilename);
	    if (lstat(tmpfilename, &(data->file_info)) < 0)
		data->file_info.st_mode = 0;
d1867 1
a1867 1
	    if (S_ISDIR(data->file_info.st_mode)) {
d1874 1
a1874 1
	    if (S_ISDIR(data->file_info.st_mode)) {
d1893 2
a1894 2
	    **	Sort dirname in the tree bt.
	    */
d1899 1
a1899 1
	    if (num_of_entries % (partial_threshold > 0  ?
d1901 1
a1901 1
			       == 0) {
d1910 1
a1910 1
	}   /* end while directory entries left to read */
d1913 1
a1913 1
	    _HTProgress (OPERATION_OK);
a1916 1

d1918 2
a1919 2
	**  Run through tree printing out in order.
	*/
d1921 4
a1924 3
	    HTBTElement * next_element = HTBTree_next(bt,NULL);
		/* pick up the first element of the list */
	    int num_of_entries_output = 0; /* lines counter */
d1927 4
a1930 3
		/* I for initial (.. file),
		   D for directory file,
		   F for file */
d1941 1
a1941 1
		if (num_of_entries_output % HTMAX(display_lines,10) == 0) {
d1943 1
a1943 1
			_HTProgress (TRANSFER_INTERRUPTED);
d1951 2
a1952 2
		**	If filename is not root directory.
		*/
d1955 1
a1955 1
		entry = (DIRED *)(HTBTree_object(next_element));
d1957 2
a1958 3
		**  Append the current entry's filename
		**  to the path.
		*/
d1962 2
a1963 2
		**  Output the directory entry.
		*/
d1982 2
a1983 2
			   (char) (DIRED_BLOK(HTBTree_object(next_element))
			    == 'D' ? 'D' : 'F');
d1986 5
a1990 5
			   START(HTML_EM);
			   PUTS(state == 'D'
			      ? LABEL_SUBDIRECTORIES
			      : LABEL_FILES);
			   END(HTML_EM);
d2008 2
a2009 2
			  (char) (DIRED_BLOK(HTBTree_object(next_element))
			   == 'D' ? 'D' : 'F');
d2013 2
a2014 2
			    ? LABEL_SUBDIRECTORIES
			    : LABEL_FILES);
a2027 1

d2039 2
a2040 2
		    /* pick up the next element of the list;
		     if none, return NULL*/
d2052 1
a2052 1
			_HTProgress (TRANSFER_INTERRUPTED);
d2060 1
a2060 1
	    } /* end while next_element */
d2072 1
a2072 1
	} /* end printing out the tree in order */
d2087 1
a2087 1
    return status;  /* document loaded, maybe partial */
a2090 1

d2092 2
a2093 3
PUBLIC int HTStat ARGS2(
	CONST char *,	filename,
	struct stat *,	data)
d2098 1
a2098 1
    if (len != 0 && LYIsPathSep(filename[len-1])) {
d2100 1
d2112 1
a2112 1
	 && access(filename, 0) == 0) {
d2122 263
d2386 19
a2404 20
**	----------------
**
**  On entry:
**	addr		must point to the fully qualified hypertext reference.
**			This is the physical address of the file
**
**  On exit:
**	returns		<0		Error has occurred.
**			HTLOADED	OK
**
*/
PUBLIC int HTLoadFile ARGS4(
	CONST char *,		addr,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
{
    char * filename = NULL;
    char * acc_method = NULL;
    char * ftp_newhost;
d2406 4
a2409 5
    char * nodename = NULL;
    char * newname = NULL;	/* Simplified name of file */
    HTAtom * encoding;		/* @@@@ not used yet */
    HTAtom * myEncoding = NULL; /* enc of this file, may be gzip etc. */
    int status;
d2411 1
a2414 4
#ifdef USE_ZLIB
    gzFile gzfp = 0;
    BOOL use_gzread = NO;
#endif /* USE_ZLIB */
d2417 2
a2418 2
    **	Reduce the filename to a basic form (hopefully unique!).
    */
d2420 2
a2421 2
    filename=HTParse(newname, "", PARSE_PATH|PARSE_PUNCTUATION);
    nodename=HTParse(newname, "", PARSE_HOST);
d2424 2
a2425 2
    **	If access is ftp, or file is on another host, invoke ftp now.
    */
d2428 2
a2429 2
       (!LYSameHostname("localhost", nodename) &&
	!LYSameHostname(nodename, HTHostName()))) {
d2442 2
a2443 2
	if ( ftp_passive == ftp_local_passive ) {
	    if (( status >= 400 ) || ( status < 0 )) {
d2462 2
a2463 2
    **	Determine the format and encoding mapped to any suffix.
    */
d2466 3
a2468 3
	 *  If content_type and content_encoding are BOTH already set
	 *  in the anchor object, we believe it and don't try to
	 *  derive format and encoding from the filename. - kw
d2482 7
a2488 7
    /*
    **	Check the format for an extended MIME charset value, and
    **	act on it if present.  Otherwise, assume what is indicated
    **	by the last parameter (fallback will effectively be
    **	UCLYhndl_for_unspec, by default ISO-8859-1). - kw
    */
	format = HTCharsetFormat(format, anchor, default_UCLYhndl );
d2493 5
a2497 5
    **	Check to see if the 'filename' is in fact a directory.	If it is
    **	create a new hypertext object containing a list of files and
    **	subdirectories contained in the directory.  All of these are links
    **	to the directories or files listed.
    */
d2509 1
a2509 1
		char * enable_file_name = NULL;
d2526 9
a2534 158
    /*
    **	Assume that the file is in Unix-style syntax if it contains a '/'
    **	after the leading one. @@@@
    */
    {
	FILE * fp;
	char * vmsname = strchr(filename + 1, '/') ?
		    HTVMS_name(nodename, filename) : filename + 1;
	fp = fopen(vmsname, "r", "shr=put", "shr=upd");

	/*
	**  If the file wasn't VMS syntax, then perhaps it is Ultrix.
	*/
	if (!fp) {
	    char * ultrixname = 0;
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", vmsname));
	    HTSprintf0(&ultrixname, "%s::\"%s\"", nodename, filename);
	    fp = fopen(ultrixname, "r", "shr=put", "shr=upd");
	    if (!fp) {
		CTRACE((tfp, "HTLoadFile: Can't open as %s\n",
			    ultrixname));
	    }
	    FREE(ultrixname);
	}
	if (fp) {
	    char *semicolon = NULL;

	    if (HTEditable(vmsname)) {
		HTAtom * put = HTAtom_for("PUT");
		HTList * methods = HTAnchor_methods(anchor);
		if (HTList_indexOf(methods, put) == (-1)) {
		    HTList_addObject(methods, put);
		}
	    }
	    /*
	    **	Trim vmsname at semicolon if a version number was
	    **	included, so it doesn't interfere with the check
	    **	for a compressed file. - FM
	    */
	    if ((semicolon = strchr(vmsname, ';')) != NULL)
		*semicolon = '\0';
	    /*
	    **	Fake a Content-Encoding for compressed files. - FM
	    */
	    if (!IsUnityEnc(myEncoding)) {
		/*
		 *  We already know from the call to HTFileFormat above
		 *  that this is a compressed file, no need to look at
		 *  the filename again. - kw
		 */
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0 &&
		    (!strcmp(HTAtom_name(myEncoding), "gzip") ||
		     !strcmp(HTAtom_name(myEncoding), "x-gzip"))) {
		    fclose(fp);
		    if (semicolon != NULL)
			*semicolon = ';';
		    gzfp = gzopen(vmsname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				vmsname, (void*)gzfp));
		    use_gzread = YES;
		} else
#endif	/* USE_ZLIB */
		{
		    StrAllocCopy(anchor->content_type, format->name);
		    StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
		    format = HTAtom_for("www/compressed");
		}
	    } else {
		/* FIXME: should we check if suffix is after ']' or ':' ? */
		CompressFileType cft = HTCompressFileType(vmsname, "._-", &dot);

		if (cft != cftNone) {
		    char *cp = NULL;

		    StrAllocCopy(cp, vmsname);
		    cp[dot - vmsname] = '\0';
		    format = HTFileFormat(cp, &encoding, NULL);
		    FREE(cp);
		    format = HTCharsetFormat(format, anchor,
					     UCLYhndl_HTFile_for_unspec);
		    StrAllocCopy(anchor->content_type, format->name);
		}

		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    format = HTAtom_for("www/compressed");
		    break;
		case cftGzip:
		    StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
		    if (strcmp(format_out->name, "www/download") != 0) {
			fclose(fp);
			if (semicolon != NULL)
			    *semicolon = ';';
			gzfp = gzopen(vmsname, BIN_R);

			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    vmsname, (void*)gzfp));
			use_gzread = YES;
		    }
#else  /* USE_ZLIB */
		    format = HTAtom_for("www/compressed");
#endif	/* USE_ZLIB */
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    format = HTAtom_for("www/compressed");
		    break;
		case cftNone:
		    break;
		}
	    }
	    if (semicolon != NULL)
		*semicolon = ';';
	    FREE(filename);
	    FREE(nodename);
#ifdef USE_ZLIB
	    if (use_gzread) {
		if (gzfp) {
		    char * sugfname = NULL;
		    if (anchor->SugFname) {
			StrAllocCopy(sugfname, anchor->SugFname);
		    } else {
			char * anchor_path = HTParse(anchor->address, "",
						     PARSE_PATH + PARSE_PUNCTUATION);
			char * lastslash;
			HTUnEscape(anchor_path);
			lastslash = strrchr(anchor_path, '/');
			if (lastslash)
			    StrAllocCopy(sugfname, lastslash + 1);
			FREE(anchor_path);
		    }
		    FREE(anchor->content_encoding);
		    if (sugfname && *sugfname)
			HTCheckFnameForCompression(&sugfname, anchor,
						   TRUE);
		    if (sugfname && *sugfname)
			StrAllocCopy(anchor->SugFname, sugfname);
		    FREE(sugfname);
		    status = HTParseGzFile(format, format_out,
					   anchor,
					   gzfp, sink);
		} else {
		    status = HTLoadError(NULL,
					 -(HT_ERROR),
					 FAILED_OPEN_COMPRESSED_FILE);
		}
	    } else
#endif /* USE_ZLIB */
	    {
		status = HTParseFile(format, format_out, anchor, fp, sink);
		fclose(fp);
	    }
	    return status;
	}  /* If successful open */
d2536 1
d2538 1
d2545 5
a2549 5
    **	For unix, we try to translate the name into the name of a
    **	transparently mounted file.
    **
    **	Not allowed in secure (HTClienntHost) situations. TBL 921019
    */
d2551 1
a2551 1
    /*	Need protection here for telnet server but not httpd server. */
d2554 1
a2554 1
	char * localname = HTLocalName(addr);
d2559 5
a2563 5
	**  Multiformat handling.
	**
	**  If needed, scan directory to find a good file.
	**  Bug:  We don't stat the file to find the length.
	*/
d2570 2
a2571 2
	    STRUCT_DIRENT * dirbuf;
	    float best = (float) NO_VALUE_FOUND; /* So far best is bad */
d2573 2
a2574 2
	    HTAtom * best_enc = NULL;
	    char * best_name = NULL;	/* Best dir entry so far */
d2582 2
a2583 2
		*base++ = '\0';		/* Just got directory name */
		baselen = strlen(base)- strlen(MULTI_SUFFIX);
d2596 2
a2597 2
		**  While there are directory entries to be read...
		*/
d2602 1
a2602 1
		if ((int)strlen(dirbuf->d_name) > baselen &&	 /* Match? */
d2604 1
a2604 1
		    HTAtom * enc;
d2608 3
a2610 2
						filevalue,
						0L  /* @@@@@@@@@@@@ */);
d2613 3
a2615 2
			CompressFileType cft = HTCompressFileType(dirbuf->d_name, ".", &dot);
			char * cp = NULL;
d2632 3
d2659 4
a2662 3
			CTRACE((tfp, "HTLoadFile: value of presenting %s is %f\n",
				    HTAtom_name(rep), value));
			if  (value > best) {
d2668 4
a2671 4
		    }	/* if best so far */
		 } /* if match */

	    } /* end while directory entries left to read */
d2677 1
a2677 1
		base[-1] = '/';		/* Restore directory name */
d2681 1
a2681 1
	    } else {			/* If not found suitable file */
d2686 3
a2688 3
	    /*NOTREACHED*/
	} /* if multi suffix */

d2690 8
a2697 8
	**  Check to see if the 'localname' is in fact a directory.  If it
	**  is create a new hypertext object containing a list of files and
	**  subdirectories contained in the directory.	All of these are
	**  links to the directories or files listed.
	**  NB This assumes the existence of a type 'STRUCT_DIRENT', which
	**  will hold the directory entry, and a type 'DIR' which is used
	**  to point to the current directory being read.
	*/
d2702 1
a2702 1
	if (HTStat(localname,&dir_info) == -1)	   /* get file information */
d2704 1
a2704 1
				/* if can't read file information */
d2707 1
a2707 1
	}  else {		/* Stat was OK */
d2711 2
a2712 2
		**  If localname is a directory.
		*/
d2719 3
a2721 4
		**  Check directory access.
		**  Selective access means only those directories containing
		**  a marker file can be browsed.
		*/
d2729 1
a2729 1
		    char * enable_file_name = NULL;
d2749 2
a2750 2
		**  Directory access is allowed and possible.
		*/
d2753 1
a2753 1
					anchor, format_out, sink);
d2759 2
a2760 2
	    } /* end if localname is a directory */

d2768 1
a2768 1
	} /* end if file stat worked */
d2773 9
a2781 124
	{
	    int bin = HTCompressFileType(localname, ".", &dot) != cftNone;
	    FILE * fp = fopen(localname, (bin ? BIN_R : "r"));

	    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n",
				 localname, (void*)fp));
	    if (fp) {		/* Good! */
		if (HTEditable(localname)) {
		    HTAtom * put = HTAtom_for("PUT");
		    HTList * methods = HTAnchor_methods(anchor);
		    if (HTList_indexOf(methods, put) == (-1)) {
			HTList_addObject(methods, put);
		    }
		}
		/*
		**  Fake a Content-Encoding for compressed files. - FM
		*/
		if (!IsUnityEnc(myEncoding)) {
		    /*
		     *	We already know from the call to HTFileFormat above
		     *	that this is a compressed file, no need to look at
		     *	the filename again. - kw
		     */
#ifdef USE_ZLIB
		    if (strcmp(format_out->name, "www/download") != 0 &&
			(!strcmp(HTAtom_name(myEncoding), "gzip") ||
			 !strcmp(HTAtom_name(myEncoding), "x-gzip"))) {
			fclose(fp);
			gzfp = gzopen(localname, BIN_R);

			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    localname, (void*)gzfp));
			use_gzread = YES;
		    } else
#endif	/* USE_ZLIB */
		    {
			StrAllocCopy(anchor->content_type, format->name);
			StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
			format = HTAtom_for("www/compressed");
		    }
		} else {
		    CompressFileType cft = HTCompressFileType(localname, ".", &dot);

		    if (cft != cftNone) {
			char *cp = NULL;

			StrAllocCopy(cp, localname);
			cp[dot - localname] = '\0';
			format = HTFileFormat(cp, &encoding, NULL);
			FREE(cp);
			format = HTCharsetFormat(format, anchor,
						 UCLYhndl_HTFile_for_unspec);
			StrAllocCopy(anchor->content_type, format->name);
		    }

		    switch (cft) {
		    case cftCompress:
			StrAllocCopy(anchor->content_encoding, "x-compress");
			format = HTAtom_for("www/compressed");
			break;
		    case cftGzip:
			StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
			if (strcmp(format_out->name, "www/download") != 0) {
			    fclose(fp);
			    gzfp = gzopen(localname, BIN_R);

			    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					localname, (void*)gzfp));
			    use_gzread = YES;
			}
#else  /* USE_ZLIB */
			format = HTAtom_for("www/compressed");
#endif	/* USE_ZLIB */
			break;
		    case cftBzip2:
			StrAllocCopy(anchor->content_encoding, "x-bzip2");
			format = HTAtom_for("www/compressed");
			break;
		    case cftNone:
			break;
		    }
		}
		FREE(localname);
		FREE(nodename);
#ifdef USE_ZLIB
		if (use_gzread) {
		    if (gzfp) {
			char * sugfname = NULL;
			if (anchor->SugFname) {
			    StrAllocCopy(sugfname, anchor->SugFname);
			} else {
			    char * anchor_path = HTParse(anchor->address, "",
							 PARSE_PATH + PARSE_PUNCTUATION);
			    char * lastslash;
			    HTUnEscape(anchor_path);
			    lastslash = strrchr(anchor_path, '/');
			    if (lastslash)
				StrAllocCopy(sugfname, lastslash + 1);
			    FREE(anchor_path);
			}
			FREE(anchor->content_encoding);
			if (sugfname && *sugfname)
			    HTCheckFnameForCompression(&sugfname, anchor,
						       TRUE);
			if (sugfname && *sugfname)
			    StrAllocCopy(anchor->SugFname, sugfname);
			FREE(sugfname);
			status = HTParseGzFile(format, format_out,
					       anchor,
					       gzfp, sink);
		    } else {
			status = HTLoadError(NULL,
					     -(HT_ERROR),
					     FAILED_OPEN_COMPRESSED_FILE);
		    }
		} else
#endif /* USE_ZLIB */
		{
		    status = HTParseFile(format, format_out, anchor, fp, sink);
		    fclose(fp);
		}
		return status;
	    }  /* If successful open */
d2783 4
a2786 2
	}  /* scope of fp */
    }  /* local unix file system */
d2792 2
a2793 2
    **	Now, as transparently mounted access has failed, we try FTP.
    */
d2796 2
a2797 2
	**  Deal with case-sensitivity differences on VMS versus Unix.
	*/
d2821 2
a2822 2
    **	All attempts have failed.
    */
d2830 1
a2830 1
static CONST char *program_paths[pp_Last];
d2835 1
a2835 2
PUBLIC CONST char * HTGetProgramPath ARGS1(
	ProgramPaths,	code)
d2837 2
a2838 1
    CONST char *result = NULL;
d2848 1
a2848 3
PUBLIC void HTSetProgramPath ARGS2(
	ProgramPaths,	code,
	CONST char *,	path)
d2858 1
a2858 1
PUBLIC void HTInitProgramPaths NOARGS
d2861 2
a2862 2
    CONST char *path;
    CONST char *test;
d2896 5
d2926 5
d2982 1
a2982 1
	    free((char *)test);
d2989 2
a2990 2
**	Protocol descriptors
*/
d2993 1
a2993 1
GLOBALDEF (HTProtocol,HTFTP,_HTFILE_C_1_INIT);
d2995 1
a2995 1
GLOBALDEF (HTProtocol,HTFile,_HTFILE_C_2_INIT);
d2997 4
a3000 2
GLOBALDEF PUBLIC HTProtocol HTFTP  = { "ftp", HTLoadFile, 0 };
GLOBALDEF PUBLIC HTProtocol HTFile = { "file", HTLoadFile, HTFileSaveStream };
@


1.5
log
@idea from OpenBSD:
date: 2003/05/08 21:04:17;  author: vincent;  state: Exp;  lines: +1 -1
multiple readlink() calls that forgot the -1...
@
text
@d1 1
a1 1
/* $MirBSD: HTFile.c,v 1.4 2003/07/07 19:55:44 tg Exp $
d2131 1
a2131 1
		ftp_local_passive = ftp_passive;
d2136 4
a2139 4
		if (( status >= 400 ) || ( status < 0 )) {
			ftp_local_passive = !ftp_passive;
			status = HTFTPLoad(addr, anchor, format_out, sink);
		}
d2141 1
a2141 1
	
@


1.4
log
@from OpenBSD (with minor changes):
- default to ftp passive (deraadt)
When passive FTP fails, switch to active FTP and try again

Submitted by Andrew Basterfield <bob@@cemetery.homeunix.org>
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.4 2003/07/07 19:03:08 tg Exp $
d302 1
a302 1
			    (len = readlink(file, tmp, sizeof(tmp))) >= 0) {
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 20
d2093 1
d2129 4
d2134 10
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d26 2
a27 1
#ifdef DOSPATH
a29 1
#define lstat stat
d34 1
a34 1
#ifdef DOSPATH
d37 3
d41 1
a41 1
#endif /* DOSPATH */
d44 1
a52 1
#define INFINITY 512		/* file name length @@@@ FIXME */
d87 6
a131 3
extern BOOL HTPassEightBitRaw;
extern HTCJKlang HTCJK;

a138 2
/*PRIVATE char *HTSaveRoot  = "$(HOME)/WWW/";*/ /* Where to save things */

a146 8
#ifdef _WINDOWS
int exists(char *filename)
{
 return (access(filename,0)==0);
}
#endif


d164 4
a167 2
    } else {
	HTSprintf0(bufp, "%s", entry);
d183 1
a183 1
	StrAllocCat(*bufp, fmt);
d190 1
a192 1
	char *,		entry,
a199 1
	struct stat st;
d203 1
d205 1
d208 1
d210 1
d212 9
d227 1
d236 1
a236 1
	if (lstat(file, &st) < 0)
d262 1
a262 1
		while (isdigit(*s) || *s == '.' || *s == '-' || *s == ' ' ||
d275 2
a276 2
			HTDirEntry(target, tail, entry);
			FormatStr(&buf, start, entry);
d281 1
a281 1
			if (c != 'A' && S_ISLNK(st.st_mode) &&
d292 1
a292 1
		    if (S_ISDIR(st.st_mode)) {
d323 2
a324 2
			datestr = ctime(&st.st_mtime);
			if ((now - st.st_mtime) < SEC_PER_YEAR/2)
d339 1
a339 1
			FormatNum(&buf, start, (int) st.st_size);
d343 1
a343 1
			if (S_ISDIR(st.st_mode)) {
d345 1
d350 1
a350 1
			FormatNum(&buf, start, (int)((st.st_size+1023)/1024));
d355 4
a358 1
			switch(st.st_mode & S_IFMT) {
d360 1
d381 4
d386 4
a389 3
				PBIT(st.st_mode, 6, st.st_mode & S_ISUID),
				PBIT(st.st_mode, 3, st.st_mode & S_ISGID),
				PTBIT(st.st_mode,   st.st_mode & S_ISVTX));
d394 2
a395 1
			name = HTAA_UidToName (st.st_uid);
d399 1
a399 1
				FormatNum(&buf, start, (int) st.st_uid);
d401 1
d405 2
a406 1
			name = HTAA_GidToName(st.st_gid);
d410 1
a410 1
				FormatNum(&buf, start, (int) st.st_gid);
d412 1
d416 1
a416 1
			FormatNum(&buf, start, (int) st.st_nlink);
d459 1
a459 1
	float,		value)
d462 1
a462 1
    BOOL trivial_enc = IsUnityEncStr(encoding);
d479 1
a479 1
	    suff = (HTSuffix *) calloc(1, sizeof(HTSuffix));
d512 1
a512 1
    suff->quality = value;
d586 35
d631 5
d647 1
a647 1
    if (expand_all)
d649 1
a649 1
    else
d656 2
a657 16
	    CTRACE(tfp, "Node `%s' means path `%s'\n", name, path);
#ifdef DOSPATH
	    StrAllocCopy(result, HTDOS_name(path));
#else
#ifdef __EMX__
	    if (path[0] == '/'
	     && isalpha(path[1])
	     && path[2] == ':') /* pesky leading slash */
		StrAllocCopy(result, path+1);
	    else
		StrAllocCopy(result, path);
	    CTRACE(tfp, "EMX hack changed `%s' to `%s'\n", path, result);
#else
	    StrAllocCopy(result, path);
#endif /* __EMX__ */
#endif /* DOSPATH */
d660 1
a660 1
	    CTRACE(tfp, "Node `%s' means file `%s'\n", name, result);
d666 1
a666 1
	if ((home = getenv("HOME")) == 0)
d671 6
a676 1
	if ((home = getenv("HOME")) == 0)
d688 3
d708 1
a708 1
	HTSprintf0(&result, "file://%s", name+13);
d712 1
a712 1
	HTSprintf0(&result, "file://%s", name+5);
d714 1
a714 1
	HTSprintf0(&result, "file://%s%s", HTHostName(), name);
d716 1
a716 1
    CTRACE(tfp, "File `%s'\n\tmeans node `%s'\n", name, result);
d749 1
a749 1
    trivial_enc = IsUnityEncStr(enc);
d864 4
d921 2
a922 2
	CTRACE(tfp, "HTCharsetFormat: Extended MIME Content-Type is %s\n",
		    format->name);
d1010 2
a1011 2
		= (!strncmp(cp4, "iso-8859-", 9) &&
		   isdigit((unsigned char)cp4[9]));
d1013 1
a1013 1
		= (given_is_8859 ||
d1018 1
a1018 1
		= (given_is_8859like &&
d1031 1
a1031 1
		       isdigit((unsigned char)(*cp1)))
d1069 79
d1170 2
a1171 2
	    CTRACE(tfp, "File: Value of %s is %.3f\n",
			filename, suff->quality);
d1175 37
a1211 1
    return 0.3;		/* Dunno! */
a1223 24

#if defined(HAVE_CONFIG_H)

#ifndef HAVE_GETGROUPS
#define NO_GROUPS
#endif

#else

#ifdef VMS
#define NO_GROUPS
#endif /* VMS */
#ifdef NO_UNIX_IO
#define NO_GROUPS
#endif /* NO_UNIX_IO */
#ifdef PCNFS
#define NO_GROUPS
#endif /* PCNFS */
#ifdef NOUSERS
#define NO_GROUPS
#endif /* PCNFS */

#endif	/* HAVE_CONFIG_H */

d1227 1
a1227 3
#ifdef NO_GROUPS
    return NO;		/* Safe answer till we find the correct algorithm */
#else
d1268 2
a1269 1
    CTRACE(tfp, "\tFile is not editable.\n");
a1270 1
#endif /* NO_GROUPS */
d1282 3
a1284 2
    CONST char * addr = HTAnchor_address((HTAnchor*)anchor);
    char *  localname = HTLocalName(addr);
d1286 1
a1286 1
    FILE* fp = fopen(localname, "w");
d1302 1
d1306 5
a1310 7
    if (0 == strcmp(entry,"../")) {
	/*
	**  Undo slash appending for anchor creation.
	*/
	StrAllocCopy(escaped,"..");
    } else {
	escaped = HTEscape(entry, URL_XPALPHAS);
d1336 1
d1349 3
a1351 3
**	and NO_PARENT_DIR_REFERENCE is not defined, such that the
**	calling function use LYListFmtParse() to create a link to
**	the parent directory.  Otherwise, it returns FALSE. - FM
d1355 1
a1355 1
	HTAnchor *,	anchor,
d1358 1
a1358 1
    char * logical = HTAnchor_address(anchor);
d1364 8
a1372 4
#ifdef DOSPATH
    BOOL local_link = FALSE;
    if (logical[18] == ':') local_link = TRUE;
#endif
d1400 1
a1400 1
    current = strrchr(path, '/');	/* last part or "" */
d1406 1
a1406 1
      printable = HTfullURL_toFile(
d1409 3
a1411 1
	    : path);
d1419 1
a1419 1
      StrAllocCopy(printable, (current ? current + 1 : ""));
a1450 1
	  FREE(logical);
d1461 3
a1463 1
    if (current && current[1]) {   /* was a slash AND something else too */
d1467 1
a1467 1
	*current++ = '\0';
a1473 1
	    FREE(logical);
d1481 3
a1483 3
#ifdef DOSPATH
	if (local_link)
	    if (strlen(parent) == 3 )
d1485 3
a1490 3
#ifdef DOSPATH
	if(!local_link)
#endif
a1528 1
		    FREE(logical);
a1536 1
		FREE(logical);
a1570 1
    FREE(logical);
d1584 4
a1587 7
    char * readme_file_name =
	malloc(strlen(localname)+ 1 + strlen(HT_DIR_README_FILE) + 1);
    if (readme_file_name == NULL)
	outofmem(__FILE__, "do_readme");
    strcpy(readme_file_name, localname);
    strcat(readme_file_name, "/");
    strcat(readme_file_name, HT_DIR_README_FILE);
d1589 1
a1589 1
    fp = fopen(readme_file_name,  "r");
d1596 2
a1597 23
	for (;;){
	    char c = fgetc(fp);
	    if (c == (char)EOF) break;
#ifdef NOTDEFINED
	    switch (c) {
		case '&':
		case '<':
		case '>':
			PUTC('&');
			PUTC('#');
			PUTC((char)(c / 10));
			PUTC((char) (c % 10));
			PUTC(';');
			break;
/*		case '\n':
			PUTC('\r');
Bug removed thanks to joe@@athena.mit.edu */
		default:
			PUTC(c);
	    }
#else
	    PUTC(c);
#endif /* NOTDEFINED */
d1606 62
a1677 1
    char *logical = NULL;
a1682 1
    struct stat file_info;
d1684 1
d1686 1
a1686 1
    CTRACE(tfp, "print_local_dir() started\n");
d1688 1
a1688 2
    logical = HTAnchor_address((HTAnchor*)anchor);
    pathname = HTParse(logical, "",
d1724 2
a1725 4
    { int i;
	   for (i = 0; i < HTML_A_ATTRIBUTES; i++)
		   present[i] = (i == HTML_A_HREF);
    }
d1735 1
a1735 2
    need_parent_link = HTDirTitles(target,
				   (HTAnchor *)anchor, FALSE);
d1738 2
a1739 2
    if (strncmp(anchor->address, "lynxcgi:", 8)) {
	HTAnchor_setFormat((HTParentAnchor *) anchor, WWW_DIRED);
a1745 1

d1747 1
a1747 1
	HTBTree * bt = HTBTree_new((HTComparer)AS_cmp);
d1750 1
a1750 1
	_HTProgress (gettext("Reading directory..."));
d1756 1
a1756 1
	    char * dirname = NULL;
d1758 1
a1758 1
#ifndef DOSPATH
d1780 4
a1783 5
	    if (strcmp(localname, "/"))
		/*
		**  If filename is not root directory.
		*/
		StrAllocCat(tmpfilename, "/");
d1786 9
a1794 2
	    stat(tmpfilename, &file_info);
	    if (S_ISDIR(file_info.st_mode))
d1796 4
a1799 3
		HTSprintf0(&dirname, "D%s",dirbuf->d_name);
	    else
		HTSprintf0(&dirname, "F%s",dirbuf->d_name);
d1801 1
d1803 16
a1818 7
	    {
		if (dir_list_style == MIXED_STYLE)
		    HTSprintf0(&dirname, " %s/", dirbuf->d_name);
		else if (!strcmp(dirbuf->d_name, ".."))
		    HTSprintf0(&dirname, "A%s", dirbuf->d_name);
		else
		    HTSprintf0(&dirname, "D%s", dirbuf->d_name);
a1819 7
	    else if (dir_list_style == MIXED_STYLE)
		HTSprintf0(&dirname, " %s", dirbuf->d_name);
	    else if (dir_list_style == FILES_FIRST)
		HTSprintf0(&dirname, "C%s", dirbuf->d_name);
		/* C & D to have first files, then directories */
	    else
		HTSprintf0(&dirname, "F%s", dirbuf->d_name);
d1824 1
a1824 1
	    HTBTree_add(bt, dirname);
d1842 1
a1842 1
	    _HTProgress (gettext("OK"));
d1844 1
a1844 1
	    CTRACE(tfp, "Reading the directory interrupred by user\n");
d1853 1
a1853 1
	    int num_of_entries_partial = 0; /* lines counter */
d1866 1
a1866 1
		char *entry, *file_extra;
d1868 14
a1881 6
		StrAllocCopy(tmpfilename,localname);
		if (strcmp(localname, "/"))
		    /*
		    **	If filename is not root directory.
		    */
		    StrAllocCat(tmpfilename, "/");
d1883 1
a1883 2
		StrAllocCat(tmpfilename,
			    (char *)HTBTree_object(next_element)+1);
d1888 1
d1893 1
a1893 5
		if (strcmp((char *)
			   (HTBTree_object(next_element)), "D..") &&
		    strcmp((char *)
			   (HTBTree_object(next_element)), "A.."))
		{
d1895 1
a1895 1
		    test = (*(char *)(HTBTree_object(next_element))
d1911 1
a1911 1
			   (*(char *)(HTBTree_object(next_element))
d1929 1
a1929 2
		    if (state != *(char *)(HTBTree_object(
					     next_element))) {
d1937 1
a1937 1
			  (*(char *)(HTBTree_object(next_element))
a1956 2
		entry = (char*)HTBTree_object(next_element)+1;
		file_extra = NULL;
d1959 1
a1959 2
		LYListFmtParse(list_format, tmpfilename, target,
		    entry, tail);
d1961 2
a1962 2
		HTDirEntry(target, tail, entry);
		PUTS(entry);
a1963 4
		if (file_extra) {
		    PUTS(file_extra);
		    FREE(file_extra);
		}
d1974 1
a1974 1
		if (num_of_entries_partial %
d1977 1
a1977 1
		    /* num_of_entries, num_of_entries_partial... */
d1987 1
a1987 1
		num_of_entries_partial++;
a2003 2
	closedir(dp);
	FREE(logical);
d2022 30
a2072 1
    char * ftp_newhost;
d2079 1
d2100 3
a2102 7
       (strcmp("localhost", nodename) != 0 &&
#ifdef VMS
	strcasecomp(nodename, HTHostName()) != 0
#else
	strcmp(nodename, HTHostName()) != 0
#endif /* VMS */
    )) {
a2107 4
	ftp_newhost = HTParse(addr, "", PARSE_HOST);	/* HTParse mallocs */
	if (strcmp(ftp_lasthost, ftp_newhost))
		ftp_local_passive = ftp_passive;	/* set to default */

d2109 1
a2109 9

	if ( ftp_passive == ftp_local_passive ) {
		if (( status <= -4 ) || ( status == -1 )) {
			ftp_local_passive = !ftp_passive;
			status = HTFTPLoad(addr, anchor, format_out, sink);
		}
	}
	free(ftp_lasthost);
	ftp_lasthost = ftp_newhost;
a2110 3
#else
	return -1;
#endif /* DISABLE_FTP */
d2115 1
a2115 1
#ifdef VMS
d2157 1
a2157 1
	CTRACE(tfp, "HTLoadFile: Can't stat %s\n", filename);
d2167 3
a2169 8
		char * enable_file_name =
		    malloc(strlen(filename)+ 1 +
		    strlen(HT_DIR_ENABLE_FILE) + 1);
		if (enable_file_name == NULL)
		    outofmem(__FILE__, "HTLoadFile");
		strcpy(enable_file_name, filename);
		strcat(enable_file_name, "/");
		strcat(enable_file_name, HT_DIR_ENABLE_FILE);
d2199 1
a2199 1
	    CTRACE(tfp, "HTLoadFile: Can't open as %s\n", vmsname);
d2203 2
a2204 2
		CTRACE(tfp, "HTLoadFile: Can't open as %s\n",
			    ultrixname);
a2208 2
	    int len;
	    char *cp = NULL;
d2241 1
a2241 1
		    gzfp = gzopen(vmsname, "rb");
d2243 2
a2244 2
		    CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				vmsname, (void*)gzfp);
d2253 7
a2259 7
	    } else if ((len = strlen(vmsname)) > 2) {
		if ((vmsname[len - 1] == 'Z') &&
		    (vmsname[len - 2] == '.' ||
		     vmsname[len - 2] == '-' ||
		     vmsname[len - 2] == '_') &&
		    vmsname[len - 3] != ']' &&
		    vmsname[len - 3] != ':') {
d2261 1
a2261 1
		    cp[len - 2] = '\0';
d2267 4
d2273 3
a2275 13
		} else if ((len > 3) &&
			   !strcasecomp((char *)&vmsname[len - 2], "gz")) {
		    if (vmsname[len - 3] == '.' ||
			vmsname[len - 3] == '-' ||
			vmsname[len - 3] == '_') {
			StrAllocCopy(cp, vmsname);
			cp[len - 3] = '\0';
			format = HTFileFormat(cp, &encoding, NULL);
			FREE(cp);
			format = HTCharsetFormat(format, anchor,
						 UCLYhndl_HTFile_for_unspec);
			StrAllocCopy(anchor->content_type, format->name);
			StrAllocCopy(anchor->content_encoding, "x-gzip");
d2277 5
a2281 5
			if (strcmp(format_out->name, "www/download") != 0) {
			    fclose(fp);
			    if (semicolon != NULL)
				*semicolon = ';';
			    gzfp = gzopen(vmsname, "rb");
d2283 4
a2286 4
			    CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					vmsname, (void*)gzfp);
			    use_gzread = YES;
			}
d2288 1
a2288 1
			format = HTAtom_for("www/compressed");
d2290 7
a2296 1
		    }
d2345 1
a2345 1
#else /* Unix: */
d2376 1
a2376 1
	    float best = NO_VALUE_FOUND;	/* So far best is bad */
d2403 1
a2403 1
#ifndef DOSPATH
d2416 2
d2419 1
a2419 1
			int len = strlen(dirbuf->d_name);
d2421 1
a2421 3
			if (len > 2 &&
			    dirbuf->d_name[len - 1] == 'Z' &&
			    dirbuf->d_name[len - 2] == '.') {
d2423 1
a2423 1
			    cp[len - 2] = '\0';
d2428 12
a2439 4
			    if (value <= 0.0) {
				format = HTAtom_for("application/x-compressed");
				value = HTStackValue(format, format_out,
						     filevalue, 0);
d2441 3
a2443 13
			    if (value <= 0.0) {
				format = HTAtom_for("www/compressed");
				value = HTStackValue(format, format_out,
						     filevalue, 0);
			    }
			} else if ((len > 3) &&
				   !strcasecomp((char *)&dirbuf->d_name[len - 2],
						"gz") &&
				   dirbuf->d_name[len - 3] == '.') {
			    StrAllocCopy(cp, dirbuf->d_name);
			    cp[len - 3] = '\0';
			    format = HTFileFormat(cp, NULL, NULL);
			    FREE(cp);
d2447 1
a2447 1
				format = HTAtom_for("application/x-gzip");
d2459 2
a2460 2
			CTRACE(tfp, "HTLoadFile: value of presenting %s is %f\n",
				    HTAtom_name(rep), value);
d2497 3
a2499 4
#ifdef _WINDOWS
	if (!exists(localname))
#else
	if (stat(localname,&dir_info) == -1)	   /* get file information */
d2501 1
d2504 1
a2504 1
	    CTRACE(tfp, "HTLoadFile: can't stat %s\n", localname);
a2507 4
#ifdef _WINDOWS
	    if (stat(localname,&dir_info) == -1) dir_info.st_mode = S_IFDIR;
#endif

d2515 1
a2515 1
		CTRACE(tfp, "%s is a directory\n", localname);
d2528 2
d2531 1
a2531 9
		if (HTDirAccess == HT_DIR_SELECTIVE) {
		    char * enable_file_name =
			malloc(strlen(localname)+ 1 +
				      strlen(HT_DIR_ENABLE_FILE) + 1);
		    if (enable_file_name == NULL)
			outofmem(__FILE__, "HTLoadFile");
		    strcpy(enable_file_name, localname);
		    strcat(enable_file_name, "/");
		    strcat(enable_file_name, HT_DIR_ENABLE_FILE);
d2540 1
d2554 1
d2559 8
a2566 1
	   } /* end if localname is a directory */
d2574 2
a2575 7
#  ifdef __EMX__
	    int len = strlen(localname);
	    int bin = ((len > 3) && !strcasecomp(localname + len - 3, ".gz"));
	    FILE * fp = fopen(localname, (bin ? "rb" : "r"));
#  else	/* !( defined __EMX__ ) */
	    FILE * fp = fopen(localname, "r");
#  endif
d2577 2
a2578 2
	    CTRACE (tfp, "HTLoadFile: Opening `%s' gives %p\n",
				 localname, (void*)fp);
a2579 3
		int len;
		char *cp = NULL;

d2601 1
a2601 1
			gzfp = gzopen(localname, "rb");
d2603 2
a2604 2
			CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    localname, (void*)gzfp);
d2613 6
a2618 3
		} else if ((len = strlen(localname)) > 2) {
		    if (localname[len - 1] == 'Z' &&
			localname[len - 2] == '.') {
d2620 1
a2620 1
			cp[len - 2] = '\0';
d2626 4
d2632 2
a2633 11
		    } else if ((len > 3) &&
			       !strcasecomp((char *)&localname[len - 2],
					    "gz") &&
			       localname[len - 3] == '.') {
			StrAllocCopy(cp, localname);
			cp[len - 3] = '\0';
			format = HTFileFormat(cp, &encoding, NULL);
			FREE(cp);
			format = HTCharsetFormat(format, anchor,
						 UCLYhndl_HTFile_for_unspec);
			StrAllocCopy(anchor->content_type, format->name);
d2638 1
a2638 1
			    gzfp = gzopen(localname, "rb");
d2640 2
a2641 2
			    CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					localname, (void*)gzfp);
d2647 7
d2717 1
d2719 4
a2722 5
	    if (!strncmp(addr, "file://localhost", 16)) {
		return -1;  /* never go to ftp site when URL
			     * is file://localhost
			     */
	    } else {
d2724 1
a2724 3
		return HTFTPLoad(addr, anchor, format_out, sink);
#else
		return -1;
d2727 1
d2737 1
a2737 1
	CTRACE(tfp, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO);
d2740 150
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 20
a21 20
 *			===========
 *
 *	This is unix-specific code in general, with some VMS bits.
 *	These are routines for file access used by browsers.
 *	Development of this module for Unix DIRED_SUPPORT in Lynx
 *	 regrettably has has been conducted in a manner with now
 *	 creates a major impediment for hopes of adapting Lynx to
 *	 a newer version of the library.
 *
 *  History:
 *	   Feb 91	Written Tim Berners-Lee CERN/CN
 *	   Apr 91	vms-vms access included using DECnet syntax
 *	26 Jun 92 (JFG) When running over DECnet, suppressed FTP.
 *			Fixed access bug for relative names on VMS.
 *	   Sep 93 (MD)	Access to VMS files allows sharing.
 *	15 Nov 93 (MD)	Moved HTVMSname to HTVMSUTILS.C
 *	27 Dec 93 (FM)	FTP now works with VMS hosts.
 *			FTP path must be Unix-style and cannot include
 *			the device or top directory.
 */
d26 4
a29 4
#if defined(DOSPATH)
#undef LONG_LIST
#define LONG_LIST		/* Define this for long style unix listings (ls -l),
				   the actual style is configurable from lynx.cfg */
d31 1
a31 1
/* #define NO_PARENT_DIR_REFERENCE *//* Define this for no parent links */
d34 1
a34 1
#if defined(DOSPATH)
a36 3
#endif

#if defined(USE_DOS_DRIVES)
d38 1
a38 1
#endif
a40 1

d45 1
a45 1
#if defined (USE_ZLIB) || defined (USE_BZLIB)
d49 1
d77 5
a81 5
    char *suffix;
    HTAtom *rep;
    HTAtom *encoding;
    char *desc;
    float quality;
a83 6
typedef struct {
    struct stat file_info;
    char sort_tags;
    char file_name[1];		/* on the end of the struct, since its length varies */
} DIRED;

d108 2
a109 2
    const HTStructuredClass *isa;
    /* ... */
d113 3
a115 3
 *  Controlling globals.
 */
int HTDirAccess = HT_DIR_OK;
d118 1
a118 2
int HTDirReadme = HT_DIR_README_NONE;

d120 1
a120 1
int HTDirReadme = HT_DIR_README_TOP;
d123 2
a124 1
static const char *HTMountRoot = "/Net/";	/* Where to find mounts */
d126 1
d128 1
a128 2
static const char *HTCacheRoot = "/WWW$SCRATCH";	/* Where to cache things */

d130 1
a130 1
static const char *HTCacheRoot = "/tmp/W3_Cache_";	/* Where to cache things */
d133 2
d136 14
a149 7
 *  Suffix registration.
 */
static HTList *HTSuffixes = 0;
static HTSuffix no_suffix =
{"*", NULL, NULL, NULL, 1.0};
static HTSuffix unknown_suffix =
{"*.*", NULL, NULL, NULL, 1.0};
d152 2
a153 2
 *	----------------------------------------
 */
d155 1
a155 1
static void free_suffixes(void);
d159 4
a162 3
static char *FormatStr(char **bufp,
		       char *start,
		       const char *entry)
a164 1

d168 2
a169 4
    } else if (*bufp && !(entry && *entry)) {
	**bufp = '\0';
    } else if (entry) {
	StrAllocCopy(*bufp, entry);
d174 4
a177 3
static char *FormatNum(char **bufp,
		       char *start,
		       int entry)
a179 1

d185 1
a185 1
	StrAllocCopy(*bufp, fmt);
d190 20
a209 24
static void LYListFmtParse(const char *fmtstr,
			   DIRED * data,
			   char *file,
			   HTStructured * target,
			   char *tail)
{
    char c;
    char *s;
    char *end;
    char *start;
    char *str = NULL;
    char *buf = NULL;
    char tmp[LY_MAXPATH];
    char type;

#ifndef NOUSERS
    const char *name;
#endif
    time_t now;
    char *datestr;

#ifdef S_IFLNK
    int len;
#endif
d211 4
a214 18

#ifdef _WINDOWS			/* 1998/01/06 (Tue) 21:20:53 */
    static const char *pbits[] =
    {
	"---", "--x", "-w-", "-wx",
	"r--", "r-x", "rw-", "rwx",
	0};

#define PBIT(a, n, s)  pbits[((a) >> (n)) & 0x7]

#else
    static const char *pbits[] =
    {"---", "--x", "-w-", "-wx",
     "r--", "r-x", "rw-", "rwx", 0};
    static const char *psbits[] =
    {"--S", "--s", "-wS", "-ws",
     "r-S", "r-s", "rwS", "rws", 0};

a216 1
#endif
d218 2
a219 4
    static const char *ptbits[] =
    {"--T", "--t", "-wT", "-wt",
     "r-T", "r-t", "rwT", "rwt", 0};

d225 2
a226 2
    if (data->file_info.st_mode == 0)
	fmtstr = "    %a";	/* can't stat so just do anchor */
d228 4
a231 6
    StrAllocCopy(str, fmtstr);
    s = str;
    end = str + strlen(str);
    START(HTML_PRE);
    while (*s) {
	start = s;
d233 36
a268 34
	    if (*s == '%') {
		if (*(s + 1) == '%')	/* literal % */
		    s++;
		else
		    break;
	    }
	    s++;
	}
	/* s is positioned either at a % or at \0 */
	*s = '\0';
	if (s > start) {	/* some literal chars. */
	    PUTS(start);
	}
	if (s == end)
	    break;
	start = ++s;
	while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
	       *s == '#' || *s == '+' || *s == '\'')
	    s++;
	c = *s;			/* the format char. or \0 */
	*s = '\0';

	switch (c) {
	case '\0':
	    PUTS(start);
	    continue;

	case 'A':
	case 'a':		/* anchor */
	    HTDirEntry(target, tail, data->file_name);
	    FormatStr(&buf, start, data->file_name);
	    PUTS(buf);
	    END(HTML_A);
	    *buf = '\0';
d270 6
a275 6
	    if (c != 'A' && S_ISLNK(data->file_info.st_mode) &&
		(len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
		PUTS(" -> ");
		tmp[len] = '\0';
		PUTS(tmp);
	    }
d277 1
a277 13
	    break;

	case 'T':		/* MIME type */
	case 't':		/* MIME type description */
	    if (S_ISDIR(data->file_info.st_mode)) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else {
		const char *cp2;
		HTFormat format;
d279 25
a303 9
		format = HTFileFormat(file, NULL, &cp2);

		if (c != 'T') {
		    if (cp2 == NULL) {
			if (!strncmp(HTAtom_name(format),
				     "application", 11)) {
			    cp2 = HTAtom_name(format) + 12;
			    if (!strncmp(cp2, "x-", 2))
				cp2 += 2;
d305 1
a305 1
			    cp2 = HTAtom_name(format);
d308 33
a340 6
		    FormatStr(&buf, start, cp2);
		} else {
		    FormatStr(&buf, start, HTAtom_name(format));
		}
	    }
	    break;
d342 6
a347 53
	case 'd':		/* date */
	    now = time(0);
	    datestr = ctime(&data->file_info.st_mtime);
	    if ((now - data->file_info.st_mtime) < SEC_PER_YEAR / 2)
		/*
		 * MMM DD HH:MM
		 */
		sprintf(tmp, "%.12s", datestr + 4);
	    else
		/*
		 * MMM DD YYYY
		 */
		sprintf(tmp, "%.7s %.4s ", datestr + 4,
			datestr + 20);
	    FormatStr(&buf, start, tmp);
	    break;

	case 's':		/* size in bytes */
	    FormatNum(&buf, start, (int) data->file_info.st_size);
	    break;

	case 'K':		/* size in Kilobytes but not for directories */
	    if (S_ISDIR(data->file_info.st_mode)) {
		FormatStr(&buf, start, "");
		StrAllocCat(buf, " ");
		break;
	    }
	    /* FALL THROUGH */
	case 'k':		/* size in Kilobytes */
	    FormatNum(&buf, start, (int) ((data->file_info.st_size + 1023) / 1024));
	    StrAllocCat(buf, "K");
	    break;

	case 'p':		/* unix-style permission bits */
	    switch (data->file_info.st_mode & S_IFMT) {
#if defined(_MSC_VER) && defined(_S_IFIFO)
	    case _S_IFIFO:
		type = 'p';
		break;
#else
	    case S_IFIFO:
		type = 'p';
		break;
#endif
	    case S_IFCHR:
		type = 'c';
		break;
	    case S_IFDIR:
		type = 'd';
		break;
	    case S_IFREG:
		type = '-';
		break;
d349 1
a349 3
	    case S_IFBLK:
		type = 'b';
		break;
d352 1
a352 3
	    case S_IFLNK:
		type = 'l';
		break;
d355 1
a355 1
# ifdef S_IFIFO			/* some older machines (e.g., apollo) have a conflict */
d357 1
a357 3
	    case S_IFSOCK:
		type = 's';
		break;
d360 1
a360 3
	    case S_IFSOCK:
		type = 's';
		break;
d363 26
a388 26
	    default:
		type = '?';
		break;
	    }
#ifdef _WINDOWS
	    sprintf(tmp, "%c%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_IRWXU));
#else
	    sprintf(tmp, "%c%s%s%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_ISUID),
		    PBIT(data->file_info.st_mode, 3, data->file_info.st_mode & S_ISGID),
		    PTBIT(data->file_info.st_mode, data->file_info.st_mode & S_ISVTX));
#endif
	    FormatStr(&buf, start, tmp);
	    break;

	case 'o':		/* owner */
#ifndef NOUSERS
	    name = HTAA_UidToName(data->file_info.st_uid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_uid);
	    }
#endif
	    break;
d390 3
a392 10
	case 'g':		/* group */
#ifndef NOUSERS
	    name = HTAA_GidToName(data->file_info.st_gid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_gid);
	    }
#endif
	    break;
d394 3
a396 3
	case 'l':		/* link count */
	    FormatNum(&buf, start, (int) data->file_info.st_nlink);
	    break;
d398 7
a404 3
	case '%':		/* literal % with flags/width */
	    FormatStr(&buf, start, "%");
	    break;
d406 1
a406 4
	default:
	    fprintf(stderr,
		    "Unknown format character `%c' in list format\n", c);
	    break;
d408 4
a411 9
	if (buf)
	    PUTS(buf);

	s++;
    }
    FREE(buf);
    END(HTML_PRE);
    PUTC('\n');
    FREE(str);
d416 19
a434 18
 *	--------------------------------------------------------
 *
 *	Calling this with suffix set to "*" will set the default
 *	representation.
 *	Calling this with suffix set to "*.*" will set the default
 *	representation for unknown suffix files which contain a ".".
 *
 *	The encoding parameter can give a trivial (8bit, 7bit, binary)
 *	or real (gzip, compress) encoding.
 *
 *	If filename suffix is already defined with the same encoding
 *	its previous definition is overridden.
 */
void HTSetSuffix5(const char *suffix,
		  const char *representation,
		  const char *encoding,
		  const char *desc,
		  double value)
d436 2
a437 2
    HTSuffix *suff;
    BOOL trivial_enc = (BOOL) IsUnityEncStr(encoding);
d446 1
a446 1
	while (NULL != (suff = (HTSuffix *) HTList_nextObject(cur))) {
d450 1
a450 1
		  strcmp(encoding, HTAtom_name(suff->encoding)) == 0)))
d453 2
a454 2
	if (!suff) {		/* Not found -- create a new node */
	    suff = typecalloc(HTSuffix);
d459 4
a462 4
	     * Memory leak fixed.
	     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	     */
	    if (!HTSuffixes) {
d479 4
a482 4
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     * Invariant code removed.
     */
d487 1
a487 1
    suff->quality = (float) value;
d492 9
a500 9
 *	Purpose:	Free all added suffixes.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		To be used at program exit.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void free_suffixes(void)
d502 1
a502 1
    HTSuffix *suff = NULL;
d505 2
a506 2
     * Loop through all suffixes.
     */
d509 3
a511 3
	 * Free off each item and its members if need be.
	 */
	suff = (HTSuffix *) HTList_removeLastObject(HTSuffixes);
d517 2
a518 2
     * Free off the list itself.
     */
d524 1
d526 16
a541 15
 *	-------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	/tmp/WWW_Cache_news/1234@@cernvax.cern.ch
 *		/tmp/WWW_Cache_http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTCacheFileName(const char *name)
{
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *result = NULL;
d552 2
a553 2
 *	-----------------------------------------
 */
d555 1
a555 1
static int HTCreatePath(const char *path)
d561 20
a580 16
/*	Convert filename from URL-path syntax to local path format
 *	----------------------------------------------------------
 *	Input name is assumed to be the URL-path of a local file
 *      URL, i.e. what comes after the "file://localhost".
 *      '#'-fragments to be treated as such must already be stripped.
 *      If expand_all is FALSE, unescape only escaped '/'. - kw
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTURLPath_toFile(const char *name,
		       BOOL expand_all,
		       BOOL is_remote GCC_UNUSED)
{
    char *path = NULL;
    char *result = NULL;
a581 1
    StrAllocCopy(path, name);
d583 1
a583 1
	HTUnEscape(path);	/* Interpret all % signs */
d587 2
a588 43
    CTRACE((tfp, "URLPath `%s' means path `%s'\n", name, path));
#if defined(USE_DOS_DRIVES)
    StrAllocCopy(result, is_remote ? path : HTDOS_name(path));
#else
    StrAllocCopy(result, path);
#endif

    FREE(path);

    return result;
}
/*	Convert filenames between local and WWW formats.
 *	------------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	$(HOME)/WWW/news/1234@@cernvax.cern.ch
 *		$(HOME)/WWW/http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
/* NOTE: Don't use this function if you know that the input is a URL path
	 rather than a full URL, use HTURLPath_toFile instead.  Otherwise
	 this function will return the wrong thing for some unusual
	 paths (like ones containing "//", possibly escaped). - kw
*/
char *HTnameOfFile_WWW(const char *name,
		       BOOL WWW_prefix,
		       BOOL expand_all)
{
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    const char *home;
    char *result = NULL;

    if (expand_all) {
	HTUnEscape(path);	/* Interpret all % signs */
    } else
	HTUnEscapeSome(path, "/");	/* Interpret % signs for path delims */

    if (0 == strcmp(acc_method, "file")		/* local file */
	||!*acc_method) {	/* implicitly local? */
d591 16
a606 2
	    CTRACE((tfp, "Node `%s' means path `%s'\n", name, path));
	    StrAllocCopy(result, HTSYS_name(path));
d609 1
a609 1
	    CTRACE((tfp, "Node `%s' means file `%s'\n", name, result));
d613 1
a613 1
    } else if (WWW_prefix) {	/* other access */
d615 1
a615 1
	if ((home = LYGetEnv("HOME")) == 0)
d620 1
a620 6
#if defined(_WINDOWS)		/* 1997/10/16 (Thu) 20:42:51 */
	home = Home_Dir();
#else
	home = LYGetEnv("HOME");
#endif
	if (home == 0)
a631 3
    CTRACE((tfp, "HTnameOfFile_WWW(%s,%d,%d) = %s\n",
	    name, WWW_prefix, expand_all, result));

d636 9
a644 8
 *	--------------------------------------------
 *
 *  Bugs:
 *	At present, only the names of two network root nodes are hand-coded
 *	in and valid for the NeXT only.  This should be configurable in
 *	the general case.
 */
char *WWW_nameOfFile(const char *name)
d646 1
a646 2
    char *result = NULL;

d649 1
a649 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 13);
d653 1
a653 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 5);
d655 1
a655 1
	HTSprintf0(&result, "%s//%s%s", STR_FILE_URL, HTHostName(), name);
d657 1
a657 1
    CTRACE((tfp, "File `%s'\n\tmeans node `%s'\n", name, result));
d662 13
a674 12
 *	------------------------------------------------------
 *
 *  On entry,
 *	rep	is the atomized MIME style representation
 *	enc	is an encoding, trivial (8bit, binary, etc.) or gzip etc.
 *
 *  On exit:
 *	Returns a pointer to a suitable suffix string if one has been
 *	found, else "".
 */
const char *HTFileSuffix(HTAtom *rep,
			 const char *enc)
d676 1
a676 2
    HTSuffix *suff;

d678 1
a678 1
    HTSuffix *first_found = NULL;
d684 1
a684 1
#define NO_INIT			/* don't init anymore since I do it in Lynx at startup */
d690 1
a690 1
    trivial_enc = (BOOL) IsUnityEncStr(enc);
d693 1
a693 1
	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
d696 3
a698 3
	/*  Don't return a suffix whose first char is a dot, and which
	   has more dots or asterisks after that, for
	   these systems - kw */
d709 3
a711 2
		 * If length of suffix (including dot) is 4 or smaller, return
		 * this one even if we found a longer one earlier - kw
d715 1
a715 1
		first_found = suff;	/* remember this one */
d718 1
a718 1
	    return suff->suffix;	/* OK -- found */
d726 1
a726 20
    return "";			/* Dunno */
}

/*
 * Trim version from VMS filenames to avoid confusing comparisons.
 */
#ifdef VMS
static const char *VMS_trim_version(const char *filename)
{
    const char *result = filename;
    const char *version = strchr(filename, ';');

    if (version != 0) {
	static char *stripped;

	StrAllocCopy(stripped, filename);
	stripped[version - filename] = '\0';
	result = (const char *) stripped;
    }
    return result;
a727 4
#define VMS_DEL_VERSION(name) name = VMS_trim_version(name)
#else
#define VMS_DEL_VERSION(name)	/* nothing */
#endif
d730 14
a743 13
 *	-------------------------------------
 *
 *	This version will return the representation and also set
 *	a variable for the encoding.
 *
 *	Encoding may be a unity encoding (binary, 8bit, etc.) or
 *	a content-coding like gzip, compress.
 *
 *	It will handle for example  x.txt, x.txt,Z, x.Z
 */
HTFormat HTFileFormat(const char *filename,
		      HTAtom **pencoding,
		      const char **pdesc)
d745 1
a745 1
    HTSuffix *suff;
d749 3
a751 2

    VMS_DEL_VERSION(filename);
d762 11
d777 1
a777 1
    lf = strlen(filename);
d781 1
a781 2

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
a784 1

d790 5
a794 1
		return suff->rep;	/* OK -- found */
d796 1
a796 1
	    for (j = 0; j < n; j++) {	/* Got encoding, need representation */
d798 1
a798 2

		suff = (HTSuffix *) HTList_objectAt(HTSuffixes, j);
d800 2
a801 3
		if ((ls + ls2 <= lf) &&
		    !strncasecomp(suff->suffix,
				  filename + lf - ls - ls2, ls2)) {
d805 4
a808 4
			if (pencoding && IsUnityEnc(*pencoding) &&
			    *pencoding != WWW_ENC_7BIT &&
			    !IsUnityEnc(suff->encoding))
			    *pencoding = suff->encoding;
d820 2
a821 2
	(unknown_suffix.rep ? &unknown_suffix : &no_suffix)
	: &no_suffix;
d824 9
a832 7
     * Set default encoding unless found with suffix already.
     */
    if (pencoding && !*pencoding) {
	*pencoding = (suff->encoding
		      ? suff->encoding
		      : HTAtom_for("binary"));
    }
d837 11
a847 10
 *	-------------------------------------------------------
 *
 *	This checks the format associated with an anchor for
 *	an extended MIME Content-Type, and if a charset is
 *	indicated, sets Lynx up for proper handling in relation
 *	to the currently selected character set. - FM
 */
HTFormat HTCharsetFormat(HTFormat format,
			 HTParentAnchor *anchor,
			 int default_LYhndl)
d858 2
a859 2
	CTRACE((tfp, "HTCharsetFormat: Extended MIME Content-Type is %s\n",
		format->name));
d863 1
a863 1
	StrAllocCopy(cp3, cp2);	/* copy to mutilate more */
d865 1
a865 1
			 *cp4 != ';' && *cp4 != ':' &&
d867 1
a867 1
	    ;			/* do nothing */
d882 2
a883 2
	     * Got something but we don't recognize it.
	     */
d886 5
a890 5
		/*
		 * UCLYhndl_for_unrec not defined :-( fallback to
		 * UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
a904 1

d907 2
a908 2
		 * Try again.
		 */
d939 21
a959 15
	     * Cannot translate.  If according to some heuristic the given
	     * charset and the current display character both are likely to be
	     * like ISO-8859 in structure, pretend we have some kind of match.
	     */
	    BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
					 isdigit(UCH(cp4[9])));
	    BOOL given_is_8859like = (BOOL) (given_is_8859 ||
					     !strncmp(cp4, "windows-", 8) ||
					     !strncmp(cp4, "cp12", 4) ||
					     !strncmp(cp4, "cp-12", 5));
	    BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
						      (strstr(LYchar_set_names[current_char_set],
							      "ISO-8859") ||
						       strstr(LYchar_set_names[current_char_set],
							      "windows-")));
d968 1
a968 1
		       isdigit(UCH(*cp1)))
d981 4
a984 3
	 * No charset parameter is present.  Ignore all other parameters, as we
	 * do when charset is present.  - FM
	 */
d991 2
a992 2
     * Set up defaults, if needed.  - FM
     */
d999 3
a1001 3
			     UCT_STAGE_PARSER,
			     UCT_STAGE_MIME,
			     -1);
a1005 77
/*	Get various pieces of meta info from file name.
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
void LYGetFileInfo(const char *filename,
		   HTParentAnchor **pfile_anchor,
		   HTFormat *pformat,
		   HTAtom **pencoding,
		   const char **pdesc,
		   const char **pcharset,
		   int *pfile_cs)
{
    char *Afn;
    char *Aname = NULL;
    HTFormat format;
    HTAtom *myEnc = NULL;
    HTParentAnchor *file_anchor;
    const char *file_csname;
    int file_cs;

    /*
     * Convert filename to URL.  Note that it is always supposed to be a
     * filename, not maybe-filename-maybe-URL, so we don't use
     * LYFillLocalFileURL and LYEnsureAbsoluteURL.  - kw
     */
    Afn = HTEscape(filename, URL_PATH);
    LYLocalFileToURL(&Aname, Afn);
    file_anchor = HTAnchor_findSimpleAddress(Aname);

    file_csname = file_anchor->charset;
    format = HTFileFormat(filename, &myEnc, pdesc);
    format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
    file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
    if (!file_csname) {
	if (file_cs >= 0)
	    file_csname = LYCharSet_UC[file_cs].MIMEname;
	else
	    file_csname = "display character set";
    }
    CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	    filename,
	    ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
	     *HTAtom_name(format) == 'a' ? "n" : ""),
	    myEnc ? HTAtom_name(myEnc) : "",
	    HTAtom_name(format),
	    file_csname,
	    file_cs));
    FREE(Afn);
    FREE(Aname);
    if (pfile_anchor)
	*pfile_anchor = file_anchor;
    if (pformat)
	*pformat = format;
    if (pencoding)
	*pencoding = myEnc;
    if (pcharset)
	*pcharset = file_csname;
    if (pfile_cs)
	*pfile_cs = file_cs;
}

d1007 5
a1011 4
 *	-------------------------------
 *
 */
float HTFileValue(const char *filename)
d1013 1
a1013 1
    HTSuffix *suff;
d1025 1
a1025 2

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
d1027 4
a1030 4
	if ((ls <= lf) && 0 == strcmp(suff->suffix, filename + lf - ls)) {
	    CTRACE((tfp, "File: Value of %s is %.3f\n",
		    filename, suff->quality));
	    return suff->quality;	/* OK -- found */
d1033 1
a1033 1
    return (float) 0.3;		/* Dunno! */
d1036 16
a1051 35
/*
 *  Determine compression type from file name, by looking at its suffix.
 *  Sets as side-effect a pointer to the "dot" that begins the suffix.
 */
CompressFileType HTCompressFileType(const char *filename,
				    const char *dots,
				    int *rootlen)
{
    CompressFileType result = cftNone;
    size_t len = strlen(filename);
    const char *ftype = filename + len;

    VMS_DEL_VERSION(filename);

    if ((len > 4)
	&& !strcasecomp((ftype - 3), "bz2")
	&& strchr(dots, ftype[-4]) != 0) {
	result = cftBzip2;
	ftype -= 4;
    } else if ((len > 3)
	       && !strcasecomp((ftype - 2), "gz")
	       && strchr(dots, ftype[-3]) != 0) {
	result = cftGzip;
	ftype -= 3;
    } else if ((len > 3)
	       && !strcasecomp((ftype - 2), "zz")
	       && strchr(dots, ftype[-3]) != 0) {
	result = cftDeflate;
	ftype -= 3;
    } else if ((len > 2)
	       && !strcmp((ftype - 1), "Z")
	       && strchr(dots, ftype[-2]) != 0) {
	result = cftCompress;
	ftype -= 2;
    }
d1053 1
a1053 1
    *rootlen = (ftype - filename);
d1055 12
a1066 4
    CTRACE((tfp, "HTCompressFileType(%s) returns %d:%s\n",
	    filename, (int) result, filename + *rootlen));
    return result;
}
d1068 1
a1068 29
/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.  RFC 2068 (and cut/paste into RFC 2616) lists these:
 *	gzip
 *	compress
 *	deflate
 * as well as "identity" (but that does nothing).
 */
CompressFileType HTEncodingToCompressType(const char *coding)
{
    CompressFileType result = cftNone;

    if (coding == 0) {
	result = cftNone;
    } else if (!strcasecomp(coding, "gzip") ||
	       !strcasecomp(coding, "x-gzip")) {
	result = cftGzip;
    } else if (!strcasecomp(coding, "compress") ||
	       !strcasecomp(coding, "x-compress")) {
	result = cftCompress;
    } else if (!strcasecomp(coding, "bzip2") ||
	       !strcasecomp(coding, "x-bzip2")) {
	result = cftBzip2;
    } else if (!strcasecomp(coding, "deflate") ||
	       !strcasecomp(coding, "x-deflate")) {
	result = cftDeflate;
    }
    return result;
}
d1070 2
a1071 11
/*	Determine write access to a file.
 *	---------------------------------
 *
 *  On exit:
 *	Returns YES if file can be accessed and can be written to.
 *
 *  Bugs:
 *	1.	No code for non-unix systems.
 *	2.	Isn't there a quicker way?
 */
BOOL HTEditable(const char *filename)
d1073 3
a1075 1
#ifndef NO_GROUPS
d1077 2
a1078 2
    uid_t myUid;
    int ngroups;		/* The number of groups  */
d1080 1
a1080 1
    int i;
d1082 2
a1083 2
    if (stat(filename, &fileStatus))	/* Get details of filename */
	return NO;		/* Can't even access file! */
d1086 1
a1086 1
    myUid = geteuid();		/* Get my user identifier */
a1089 1

d1091 6
a1096 6
		"File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",
		(unsigned int) fileStatus.st_mode,
		(int) fileStatus.st_uid,
		(int) fileStatus.st_gid,
		(int) myUid,
		(int) ngroups);
d1102 1
a1102 1
    if (fileStatus.st_mode & 0002)	/* I can write anyway? */
d1105 2
a1106 2
    if ((fileStatus.st_mode & 0200)	/* I can write my own file? */
	&&(fileStatus.st_uid == myUid))
d1109 1
a1109 1
    if (fileStatus.st_mode & 0020)	/* Group I am in can write? */
d1116 2
a1117 1
    CTRACE((tfp, "\tFile is not editable.\n"));
a1118 1
    return NO;			/* If no excuse, can't do */
d1122 10
a1131 10
 *	-------------------
 *
 *	The stream must be used for writing back the file.
 *	@@@@@@ no backup done
 */
HTStream *HTFileSaveStream(HTParentAnchor *anchor)
{
    const char *addr = anchor->address;
    char *localname = HTLocalName(addr);
    FILE *fp = fopen(localname, BIN_W);
d1133 1
a1133 1
    FREE(localname);
d1141 9
a1149 8
 *	---------------------------
 */
void HTDirEntry(HTStructured * target, const char *tail,
		const char *entry)
{
    char *relative = NULL;
    char *stripped = NULL;
    char *escaped = NULL;
d1152 7
a1158 5
    StrAllocCopy(escaped, entry);
    LYTrimPathSep(escaped);
    if (strcmp(escaped, "..") != 0) {
	stripped = escaped;
	escaped = HTEscape(stripped, URL_XPALPHAS);
d1169 2
a1170 2
	 * Handle extra slash at end of path.
	 */
d1174 2
a1175 2
	 * If empty tail, gives absolute ref below.
	 */
d1178 3
a1180 3
		   tail,
		   (*escaped != '\0' ? "/" : ""),
		   escaped);
a1183 1
    FREE(stripped);
d1188 21
a1208 19
 *	------------------------------
 *
 *    This gives the TITLE and H1 header, and also a link
 *    to the parent directory if appropriate.
 *
 *  On exit:
 *	Returns TRUE if an "Up to <parent>" link was not created
 *	for a readable local directory because LONG_LIST is defined
 *	and NO_PARENT_DIR_REFERENCE is not defined, so that the
 *	calling function should use LYListFmtParse() to create a link
 *	to the parent directory.  Otherwise, it returns FALSE. - FM
 */
BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
		 BOOL tildeIsTop)
{
    const char *logical = anchor->address;
    char *path = HTParse(logical, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *current;
    char *cp = NULL;
d1212 3
a1214 8
#if defined(USE_DOS_DRIVES)
    BOOL local_link = (strlen(logical) > 18
		       && !strncasecomp(logical, "file://localhost/", 17)
		       && LYIsDosDrive(logical + 17));
    BOOL is_remote = !local_link;

#else
#define is_remote TRUE
a1215 1

d1217 3
a1219 3
     * Check tildeIsTop for treating home directory as Welcome (assume the
     * tilde is not followed by a username).  - FM
     */
d1232 2
a1233 2
     * Trim out the ;type= parameter, if present.  - FM
     */
d1235 4
a1238 4
	if (!strncasecomp((cp + 1), "type=", 5)) {
	    if (TOUPPER(*(cp + 6)) == 'D' ||
		TOUPPER(*(cp + 6)) == 'A' ||
		TOUPPER(*(cp + 6)) == 'I')
d1243 1
a1243 1
    current = LYPathLeaf(path);	/* last part or "" */
d1246 1
a1246 1
	char *printable = NULL;
d1249 10
a1258 11
	printable = HTURLPath_toFile(((!strncasecomp(path, "/%2F", 4))	/* "//" ? */
				      ? (path + 1)
				      : path),
				     TRUE,
				     is_remote);
	if (0 == strncasecomp(printable, "/vmsysu:", 8) ||
	    0 == strncasecomp(printable, "/anonymou.", 10)) {
	    StrAllocCopy(cp, (printable + 1));
	    StrAllocCopy(printable, cp);
	    FREE(cp);
	}
d1260 2
a1261 2
	StrAllocCopy(printable, current);
	HTUnEscape(printable);
d1264 9
a1272 9
	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(*printable ? printable : WELCOME_MSG);
	PUTS(SEGMENT_DIRECTORY);
	END(HTML_TITLE);
	PUTC('\n');
	END(HTML_HEAD);
	PUTC('\n');
d1275 10
a1284 10
	START(HTML_H2);
	PUTS(*printable ? SEGMENT_CURRENT_DIR : "");
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H2);
	PUTC('\n');
#else
	START(HTML_H1);
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H1);
	PUTC('\n');
d1286 11
a1296 10
	if (((0 == strncasecomp(printable, "vmsysu:", 7)) &&
	     (cp = strchr(printable, '.')) != NULL &&
	     strchr(cp, '/') == NULL) ||
	    (0 == strncasecomp(printable, "anonymou.", 9) &&
	     strchr(printable, '/') == NULL)) {
	    FREE(printable);
	    FREE(path);
	    return (need_parent_link);
	}
	FREE(printable);
d1301 5
a1305 7
     * Make link back to parent directory.
     */
    if (current - path > 0
	&& LYIsPathSep(current[-1])
	&& current[0] != '\0') {	/* was a slash AND something else too */
	char *parent = NULL;
	char *relative = NULL;
d1307 2
a1308 2
	current[-1] = '\0';
	parent = strrchr(path, '/');	/* penultimate slash */
d1314 1
d1316 1
a1316 1
	    return (need_parent_link);
d1322 3
a1324 3
#if defined(DOSPATH) || defined(__EMX__)
	if (local_link) {
	    if (parent != 0 && strlen(parent) == 3) {
a1325 2
	    }
	} else
d1329 3
d1334 7
a1340 7
	     * On Unix, if it's not ftp and the directory cannot be read, don't
	     * put out a link.
	     *
	     * On VMS, this problem is dealt with internally by
	     * HTVMSBrowseDir().
	     */
	    DIR *dp = NULL;
d1344 8
a1351 7
		 * We need an absolute file path for the opendir.  We also need
		 * to unescape for this test.  Don't worry about %2F now, they
		 * presumably have been dealt with above, and shouldn't appear
		 * for local files anyway...  Assume OS / filesystem will just
		 * ignore superfluous slashes.  - KW
		 */
		char *fullparentpath = NULL;
d1354 2
a1355 2
		 * Path has been shortened above.
		 */
d1359 6
a1364 6
		 * Guard against weirdness.
		 */
		if (0 == strcmp(current, "..")) {
		    StrAllocCat(fullparentpath, "/../..");
		} else if (0 == strcmp(current, ".")) {
		    StrAllocCat(fullparentpath, "/..");
d1370 1
d1373 1
a1373 1
		    return (need_parent_link);
d1379 1
d1382 1
a1382 1
		return (need_parent_link);
d1392 2
a1393 2
	    if ((0 == strcmp(current, ".")) ||
		(0 == strcmp(current, ".."))) {
d1395 3
a1397 3
		 * Should not happen, but if it does, at least avoid giving
		 * misleading info.  - KW
		 */
d1400 1
a1400 2
		char *printable = NULL;

d1414 1
d1416 1
a1416 1
    return (need_parent_link);
d1421 14
a1434 9
 *	-----------------
 *
 *  If a README file exists, then it is inserted into the document here.
 */
static void do_readme(HTStructured * target, const char *localname)
{
    FILE *fp;
    char *readme_file_name = NULL;
    int ch;
d1436 1
a1436 3
    HTSprintf0(&readme_file_name, "%s/%s", localname, HT_DIR_README_FILE);

    fp = fopen(readme_file_name, "r");
d1441 1
a1441 1
	targetClass = *target->isa;	/* (Can't init agregate in K&R) */
d1443 23
a1465 2
	while ((ch = fgetc(fp)) != EOF) {
	    PUTC((char) ch);
d1474 6
a1479 68
#define DIRED_BLOK(obj) (((DIRED *)(obj))->sort_tags)
#define DIRED_NAME(obj) (((DIRED *)(obj))->file_name)

#define NM_cmp(a,b) ((a) < (b) ? -1 : ((a) > (b) ? 1 : 0))

#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
static const char *file_type(const char *path)
{
    const char *type;

    while (*path == '.')
	++path;
    type = strchr(path, '.');
    if (type == NULL)
	type = "";
    return type;
}
#endif /* LONG_LIST && DIRED_SUPPORT */

static int dired_cmp(void *a, void *b)
{
    DIRED *p = (DIRED *) a;
    DIRED *q = (DIRED *) b;
    int code = p->sort_tags - q->sort_tags;

#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
    if (code == 0) {
	switch (dir_list_order) {
	case ORDER_BY_SIZE:
	    code = -NM_cmp(p->file_info.st_size, q->file_info.st_size);
	    break;
	case ORDER_BY_DATE:
	    code = -NM_cmp(p->file_info.st_mtime, q->file_info.st_mtime);
	    break;
	case ORDER_BY_MODE:
	    code = NM_cmp(p->file_info.st_mode, q->file_info.st_mode);
	    break;
	case ORDER_BY_USER:
	    code = NM_cmp(p->file_info.st_uid, q->file_info.st_uid);
	    break;
	case ORDER_BY_GROUP:
	    code = NM_cmp(p->file_info.st_gid, q->file_info.st_gid);
	    break;
	case ORDER_BY_TYPE:
	    code = AS_cmp(file_type(p->file_name), file_type(q->file_name));
	    break;
	default:
	    code = 0;
	    break;
	}
    }
#endif /* LONG_LIST && DIRED_SUPPORT */
    if (code == 0)
	code = AS_cmp(p->file_name, q->file_name);
#if 0
    CTRACE((tfp, "dired_cmp(%d) ->%d\n\t%c:%s (%s)\n\t%c:%s (%s)\n",
	    dir_list_order,
	    code,
	    p->sort_tags, p->file_name, file_type(p->file_name),
	    q->sort_tags, q->file_name, file_type(q->file_name)));
#endif
    return code;
}

static int print_local_dir(DIR *dp, char *localname,
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
d1483 2
a1484 1
    STRUCT_DIRENT *dirbuf;
d1488 1
a1488 1
    char *tmpfilename = NULL;
d1490 1
a1491 6
    int i;
    struct stat *actual_info;

#ifdef S_IFLNK
    struct stat link_info;
#endif
d1493 1
a1493 1
    CTRACE((tfp, "print_local_dir() started\n"));
d1495 2
a1496 1
    pathname = HTParse(anchor->address, "",
d1499 1
a1499 1
    if (!strcmp(pathname, "/")) {
d1501 3
a1503 3
	 * Root path.
	 */
	StrAllocCopy(tail, "/foo/..");
d1505 1
a1505 1
	char *p = strrchr(pathname, '/');	/* find last slash */
d1509 4
a1512 4
	     * This probably should not happen, but be prepared if it does.  -
	     * KW
	     */
	    StrAllocCopy(tail, "/foo/..");
d1515 2
a1516 2
	     * Take slash off the beginning.
	     */
d1530 1
a1530 1
    targetClass = *target->isa;	/* Copy routine entry points */
d1532 4
a1535 2
    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
d1538 9
a1546 6
     * The need_parent_link flag will be set if an "Up to <parent>" link was
     * not created for a readable parent in HTDirTitles() because LONG_LIST is
     * defined and NO_PARENT_DIR_REFERENCE is not defined so that need we to
     * create the link via an LYListFmtParse() call.  - FM
     */
    need_parent_link = HTDirTitles(target, anchor, FALSE);
d1549 2
a1550 2
    if (!isLYNXCGI(anchor->address)) {
	HTAnchor_setFormat(anchor, WWW_DIRED);
d1557 1
d1559 2
a1560 2
	HTBTree *bt = HTBTree_new(dired_cmp);
	int num_of_entries = 0;	/* lines counter */
d1562 2
a1563 2
	_HTProgress(READING_DIRECTORY);
	status = HT_LOADED;	/* assume we don't get interrupted */
d1566 3
a1568 3
	     * While there are directory entries to be read...
	     */
	    DIRED *data = NULL;
d1570 1
a1570 1
#if !(defined(DOSPATH) || defined(__EMX__))
d1573 2
a1574 2
		 * If the entry is not being used, skip it.
		 */
d1578 6
a1583 5
	     * Skip self, parent if handled in HTDirTitles() or if
	     * NO_PARENT_DIR_REFERENCE is not defined, and any dot files if
	     * no_dotfiles is set or show_dotfiles is not set.  - FM
	     */
	    if (!strcmp(dirbuf->d_name, ".") /* self       */ ||
d1592 5
a1596 4
	    /*
	     * If filename is not root directory, add trailing separator.
	     */
	    LYAddPathSep(&tmpfilename);
d1599 2
a1600 24
	    data = (DIRED *) malloc(sizeof(DIRED) + strlen(dirbuf->d_name) + 4);
	    if (data == NULL) {
		status = HT_PARTIAL_CONTENT;
		break;
	    }
	    LYTrimPathSep(tmpfilename);

	    actual_info = &(data->file_info);
#ifdef S_IFLNK
	    if (lstat(tmpfilename, actual_info) < 0) {
		actual_info->st_mode = 0;
	    } else {
		if (S_ISLNK(actual_info->st_mode)) {
		    actual_info = &link_info;
		    if (stat(tmpfilename, actual_info) < 0)
			actual_info->st_mode = 0;
		}
	    }
#else
	    if (stat(tmpfilename, actual_info) < 0)
		actual_info->st_mode = 0;
#endif

	    strcpy(data->file_name, dirbuf->d_name);
d1602 3
a1604 4
	    if (S_ISDIR(actual_info->st_mode)) {
		data->sort_tags = 'D';
	    } else {
		data->sort_tags = 'F';
d1606 8
d1615 4
a1618 14
#else
	    if (S_ISDIR(actual_info->st_mode)) {
		if (dir_list_style == MIXED_STYLE) {
		    data->sort_tags = ' ';
		    LYAddPathSep0(data->file_name);
		} else if (!strcmp(dirbuf->d_name, "..")) {
		    data->sort_tags = 'A';
		} else {
		    data->sort_tags = 'D';
		}
	    } else if (dir_list_style == MIXED_STYLE) {
		data->sort_tags = ' ';
	    } else if (dir_list_style == FILES_FIRST) {
		data->sort_tags = 'C';
d1620 2
a1621 3
	    } else {
		data->sort_tags = 'F';
	    }
d1624 3
a1626 3
	     * Sort dirname in the tree bt.
	     */
	    HTBTree_add(bt, data);
d1630 1
a1630 1
	    if (num_of_entries % (partial_threshold > 0 ?
d1632 1
a1632 1
		== 0) {
d1641 1
a1641 1
	}			/* end while directory entries left to read */
d1644 1
a1644 1
	    _HTProgress(OPERATION_OK);
d1646 2
a1647 1
	    CTRACE((tfp, "Reading the directory interrupted by user\n"));
d1650 2
a1651 2
	 * Run through tree printing out in order.
	 */
d1653 3
a1655 4
	    HTBTElement *next_element = HTBTree_next(bt, NULL);

	    /* pick up the first element of the list */
	    int num_of_entries_output = 0;	/* lines counter */
d1658 3
a1660 4

	    /* I for initial (.. file),
	       D for directory file,
	       F for file */
d1668 1
a1668 1
		DIRED *entry;
d1670 6
a1675 14
#ifndef DISP_PARTIAL
		if (num_of_entries_output % HTMAX(display_lines, 10) == 0) {
		    if (HTCheckForInterrupt()) {
			_HTProgress(TRANSFER_INTERRUPTED);
			status = HT_PARTIAL_CONTENT;
			break;
		    }
		}
#endif
		StrAllocCopy(tmpfilename, localname);
		/*
		 * If filename is not root directory.
		 */
		LYAddPathSep(&tmpfilename);
d1677 2
a1678 1
		entry = (DIRED *) (HTBTree_object(next_element));
d1680 3
a1682 3
		 * Append the current entry's filename to the path.
		 */
		StrAllocCat(tmpfilename, entry->file_name);
d1685 7
a1691 3
		 * Output the directory entry.
		 */
		if (strcmp(DIRED_NAME(HTBTree_object(next_element)), "..")) {
d1693 1
a1693 1
		    test = (DIRED_BLOK(HTBTree_object(next_element))
d1709 2
a1710 2
			    (char) (DIRED_BLOK(HTBTree_object(next_element))
				    == 'D' ? 'D' : 'F');
d1713 5
a1717 5
			    START(HTML_EM);
			    PUTS(state == 'D'
				 ? LABEL_SUBDIRECTORIES
				 : LABEL_FILES);
			    END(HTML_EM);
d1727 2
a1728 1
		    if (state != DIRED_BLOK(HTBTree_object(next_element))) {
d1736 2
a1737 2
			    (char) (DIRED_BLOK(HTBTree_object(next_element))
				    == 'D' ? 'D' : 'F');
d1741 2
a1742 2
			     ? LABEL_SUBDIRECTORIES
			     : LABEL_FILES);
d1756 3
d1760 2
a1761 1
		LYListFmtParse(list_format, entry, tmpfilename, target, tail);
d1763 2
a1764 2
		HTDirEntry(target, tail, entry->file_name);
		PUTS(entry->file_name);
d1766 4
d1775 2
a1776 2
		/* pick up the next element of the list;
		   if none, return NULL */
d1780 1
a1780 1
		if (num_of_entries_output %
d1783 1
a1783 1
		    /* num_of_entries, num_of_entries_output... */
d1788 1
a1788 1
			_HTProgress(TRANSFER_INTERRUPTED);
d1793 1
a1793 1
		num_of_entries_output++;
d1796 1
a1796 1
	    }			/* end while next_element */
d1808 1
a1808 1
	}			/* end printing out the tree in order */
d1810 2
d1825 1
a1825 1
    return status;		/* document loaded, maybe partial */
a1828 154
#ifndef VMS
int HTStat(const char *filename,
	   struct stat *data)
{
    int result = -1;
    size_t len = strlen(filename);

    if (len != 0 && LYIsPathSep(filename[len - 1])) {
	char *temp_name = NULL;

	HTSprintf0(&temp_name, "%s.", filename);
	result = HTStat(temp_name, data);
	FREE(temp_name);
    } else {
	result = stat(filename, data);
#ifdef _WINDOWS
	/*
	 * Someone claims that stat() doesn't give the proper result for a
	 * directory on Windows.
	 */
	if (result == -1
	    && access(filename, 0) == 0) {
	    data->st_mode = S_IFDIR;
	    result = 0;
	}
#endif
    }
    return result;
}
#endif

#ifdef VMS
#define FOPEN_MODE(bin) "r", "shr=put", "shr=upd"
#define DOT_STRING "._-"	/* FIXME: should we check if suffix is after ']' or ':' ? */
#else
#define FOPEN_MODE(bin) (bin ? BIN_R : "r")
#define DOT_STRING "."
#endif

static int decompressAndParse(HTParentAnchor *anchor,
			      HTFormat format_out,
			      HTStream *sink,
			      char *nodename GCC_UNUSED,
			      char *filename,
			      HTAtom *myEncoding,
			      HTFormat format,
			      int *statusp)
{
    HTAtom *encoding = 0;

#ifdef USE_ZLIB
    FILE *zzfp = 0;
    gzFile gzfp = 0;
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
    BZFILE *bzfp = 0;
#endif /* USE_ZLIB */
#if defined(USE_ZLIB) || defined(USE_BZLIB)
    CompressFileType internal_decompress = cftNone;
    BOOL failed_decompress = NO;
#endif
    int rootlen = 0;
    char *localname = filename;
    int bin;
    FILE *fp;

#ifdef VMS
    /*
     * Assume that the file is in Unix-style syntax if it contains a '/' after
     * the leading one.  @@@@
     */
    localname = (strchr(localname + 1, '/')
		 ? HTVMS_name(nodename, localname)
		 : localname + 1);
#endif /* VMS */

    bin = HTCompressFileType(filename, ".", &rootlen) != cftNone;
    fp = fopen(localname, FOPEN_MODE(bin));

#ifdef VMS
    /*
     * If the file wasn't VMS syntax, then perhaps it is Ultrix.
     */
    if (!fp) {
	char *ultrixname = 0;

	CTRACE((tfp, "HTLoadFile: Can't open as %s\n", localname));
	HTSprintf0(&ultrixname, "%s::\"%s\"", nodename, filename);
	fp = fopen(ultrixname, FOPEN_MODE(bin));
	if (!fp) {
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", ultrixname));
	}
	FREE(ultrixname);
    }
#endif /* VMS */
    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n", localname, fp));
    if (fp) {			/* Good! */
	if (HTEditable(localname)) {
	    HTAtom *put = HTAtom_for("PUT");
	    HTList *methods = HTAnchor_methods(anchor);

	    if (HTList_indexOf(methods, put) == (-1)) {
		HTList_addObject(methods, put);
	    }
	}
	/*
	 * Fake a Content-Encoding for compressed files.  - FM
	 */
	if (!IsUnityEnc(myEncoding)) {
	    /*
	     * We already know from the call to HTFileFormat that
	     * this is a compressed file, no need to look at the filename
	     * again.  - kw
	     */
	    CompressFileType method = HTEncodingToCompressType(HTAtom_name(myEncoding));

#define isDOWNLOAD(m) (strcmp(format_out->name, "www/download") && (method == m))
#ifdef USE_ZLIB
	    if (isDOWNLOAD(cftGzip)) {
		fclose(fp);
		gzfp = gzopen(localname, BIN_R);

		CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			localname, gzfp));
		internal_decompress = cftGzip;
	    } else if (isDOWNLOAD(cftDeflate)) {
		zzfp = fp;
		fp = 0;

		CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			localname, zzfp));
		internal_decompress = cftDeflate;
	    } else
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
	    if (isDOWNLOAD(cftBzip2)) {
		fclose(fp);
		bzfp = BZ2_bzopen(localname, BIN_R);

		CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			localname, bzfp));
		internal_decompress = cftBzip2;
	    } else
#endif /* USE_BZLIB */
	    {
		StrAllocCopy(anchor->content_type, format->name);
		StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
		format = HTAtom_for("www/compressed");
	    }
	} else {
	    CompressFileType cft = HTCompressFileType(localname, DOT_STRING, &rootlen);

	    if (cft != cftNone) {
		char *cp = NULL;
a1829 138
		StrAllocCopy(cp, localname);
		cp[rootlen] = '\0';
		format = HTFileFormat(cp, &encoding, NULL);
		FREE(cp);
		format = HTCharsetFormat(format, anchor,
					 UCLYhndl_HTFile_for_unspec);
		StrAllocCopy(anchor->content_type, format->name);
	    }

	    switch (cft) {
	    case cftCompress:
		StrAllocCopy(anchor->content_encoding, "x-compress");
		format = HTAtom_for("www/compressed");
		break;
	    case cftDeflate:
		StrAllocCopy(anchor->content_encoding, "x-deflate");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    zzfp = fp;
		    fp = 0;

		    CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			    localname, zzfp));
		    internal_decompress = cftDeflate;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftGzip:
		StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    fclose(fp);
		    gzfp = gzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			    localname, gzfp));
		    internal_decompress = cftGzip;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftBzip2:
		StrAllocCopy(anchor->content_encoding, "x-bzip2");
#ifdef USE_BZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    fclose(fp);
		    bzfp = BZ2_bzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			    localname, bzfp));
		    internal_decompress = cftBzip2;
		}
#else /* USE_BZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_BZLIB */
		break;
	    case cftNone:
		break;
	    }
	}
#if defined(USE_ZLIB) || defined(USE_BZLIB)
	if (internal_decompress != cftNone) {
	    switch (internal_decompress) {
#ifdef USE_ZLIB
	    case cftDeflate:
		failed_decompress = (zzfp == 0);
		break;
	    case cftCompress:
	    case cftGzip:
		failed_decompress = (gzfp == 0);
		break;
#endif
#ifdef USE_BZLIB
	    case cftBzip2:
		failed_decompress = (bzfp == 0);
		break;
#endif
	    default:
		failed_decompress = YES;
		break;
	    }
	    if (failed_decompress) {
		*statusp = HTLoadError(NULL,
				       -(HT_ERROR),
				       FAILED_OPEN_COMPRESSED_FILE);
	    } else {
		char *sugfname = NULL;

		if (anchor->SugFname) {
		    StrAllocCopy(sugfname, anchor->SugFname);
		} else {
		    char *anchor_path = HTParse(anchor->address, "",
						PARSE_PATH + PARSE_PUNCTUATION);
		    char *lastslash;

		    HTUnEscape(anchor_path);
		    lastslash = strrchr(anchor_path, '/');
		    if (lastslash)
			StrAllocCopy(sugfname, lastslash + 1);
		    FREE(anchor_path);
		}
		FREE(anchor->content_encoding);
		if (sugfname && *sugfname)
		    HTCheckFnameForCompression(&sugfname, anchor,
					       TRUE);
		if (sugfname && *sugfname)
		    StrAllocCopy(anchor->SugFname, sugfname);
		FREE(sugfname);
#ifdef USE_BZLIB
		if (bzfp)
		    *statusp = HTParseBzFile(format, format_out,
					     anchor,
					     bzfp, sink);
#endif
#ifdef USE_ZLIB
		if (gzfp)
		    *statusp = HTParseGzFile(format, format_out,
					     anchor,
					     gzfp, sink);
		else if (zzfp)
		    *statusp = HTParseZzFile(format, format_out,
					     anchor,
					     zzfp, sink);
#endif
	    }
	} else
#endif /* USE_ZLIB || USE_BZLIB */
	{
	    *statusp = HTParseFile(format, format_out, anchor, fp, sink);
	    fclose(fp);
	}
	return TRUE;
    }				/* If successful open */
    return FALSE;
}
d1832 20
a1851 19
 *	----------------
 *
 *  On entry:
 *	addr		must point to the fully qualified hypertext reference.
 *			This is the physical address of the file
 *
 *  On exit:
 *	returns		<0		Error has occurred.
 *			HTLOADED	OK
 *
 */
int HTLoadFile(const char *addr,
	       HTParentAnchor *anchor,
	       HTFormat format_out,
	       HTStream *sink)
{
    char *filename = NULL;
    char *acc_method = NULL;
    char *ftp_newhost;
d1853 5
a1857 5
    char *nodename = NULL;
    char *newname = NULL;	/* Simplified name of file */
    HTAtom *myEncoding = NULL;	/* enc of this file, may be gzip etc. */
    int status = -1;

d1861 4
d1867 2
a1868 2
     * Reduce the filename to a basic form (hopefully unique!).
     */
d1870 2
a1871 2
    filename = HTParse(newname, "", PARSE_PATH | PARSE_PUNCTUATION);
    nodename = HTParse(newname, "", PARSE_HOST);
d1874 2
a1875 2
     * If access is ftp, or file is on another host, invoke ftp now.
     */
d1878 7
a1884 3
	(!LYSameHostname("localhost", nodename) &&
	 !LYSameHostname(nodename, HTHostName()))) {
	status = -1;
d1890 1
a1890 1
	ftp_newhost = HTParse(addr, "", PARSE_HOST);
d1892 1
a1892 1
	    ftp_local_passive = ftp_passive;
d1896 5
a1900 5
	if (ftp_passive == ftp_local_passive) {
	    if ((status >= 400) || (status < 0)) {
		ftp_local_passive = !ftp_passive;
		status = HTFTPLoad(addr, anchor, format_out, sink);
	    }
a1901 1

d1904 3
a1907 1
	return status;
d1912 1
a1912 1
#if defined(VMS) || defined(USE_DOS_DRIVES)
d1917 2
a1918 2
     * Determine the format and encoding mapped to any suffix.
     */
d1921 3
a1923 3
	 * If content_type and content_encoding are BOTH already set in the
	 * anchor object, we believe it and don't try to derive format and
	 * encoding from the filename.  - kw
d1937 7
a1943 7
	/*
	 * Check the format for an extended MIME charset value, and act on it
	 * if present.  Otherwise, assume what is indicated by the last
	 * parameter (fallback will effectively be UCLYhndl_for_unspec, by
	 * default ISO-8859-1).  - kw
	 */
	format = HTCharsetFormat(format, anchor, default_UCLYhndl);
d1948 5
a1952 5
     * Check to see if the 'filename' is in fact a directory.  If it is create
     * a new hypertext object containing a list of files and subdirectories
     * contained in the directory.  All of these are links to the directories
     * or files listed.
     */
d1954 1
a1954 1
	CTRACE((tfp, "HTLoadFile: Can't stat %s\n", filename));
d1964 8
a1971 3
		char *enable_file_name = NULL;

		HTSprintf0(&enable_file_name, "%s/%s", filename, HT_DIR_ENABLE_FILE);
d1986 160
a2145 9
    if (decompressAndParse(anchor,
			   format_out,
			   sink,
			   nodename,
			   filename,
			   myEncoding,
			   format,
			   &status)) {
	FREE(nodename);
a2146 1
	return status;
a2147 1
    FREE(filename);
d2149 1
a2149 1
#else /* not VMS: */
d2154 5
a2158 5
     * For unix, we try to translate the name into the name of a transparently
     * mounted file.
     *
     * Not allowed in secure (HTClientHost) situations.  TBL 921019
     */
d2160 1
a2160 1
    /*  Need protection here for telnet server but not httpd server. */
d2163 1
a2163 1
	char *localname = HTLocalName(addr);
d2168 5
a2172 5
	 * Multiformat handling.
	 *
	 * If needed, scan directory to find a good file.  Bug:  We don't stat
	 * the file to find the length.
	 */
d2179 2
a2180 2
	    STRUCT_DIRENT *dirbuf;
	    float best = (float) NO_VALUE_FOUND;	/* So far best is bad */
d2182 2
a2183 2
	    HTAtom *best_enc = NULL;
	    char *best_name = NULL;	/* Best dir entry so far */
d2191 2
a2192 2
		*base++ = '\0';	/* Just got directory name */
		baselen = strlen(base) - strlen(MULTI_SUFFIX);
d2205 3
a2207 3
		 * While there are directory entries to be read...
		 */
#if !(defined(DOSPATH) || defined(__EMX__))
d2211 1
a2211 1
		if ((int) strlen(dirbuf->d_name) > baselen &&	/* Match? */
d2213 1
a2213 1
		    HTAtom *enc;
d2217 2
a2218 3
					       filevalue,
					       0L /* @@@@@@@@@@@@ */ );

d2220 2
a2221 6
			int rootlen = 0;
			const char *atomname = NULL;
			CompressFileType cft =
			HTCompressFileType(dirbuf->d_name, ".", &rootlen);
			char *cp = NULL;

d2223 3
a2225 1
			if (cft != cftNone) {
d2227 1
a2227 1
			    cp[rootlen] = '\0';
d2232 9
a2240 15
			    switch (cft) {
			    case cftCompress:
				atomname = "application/x-compressed";
				break;
			    case cftGzip:
				atomname = "application/x-gzip";
				break;
			    case cftDeflate:
				atomname = "application/x-deflate";
				break;
			    case cftBzip2:
				atomname = "application/x-bzip2";
				break;
			    case cftNone:
				break;
d2242 8
a2249 3
			}

			if (atomname != NULL) {
d2253 1
a2253 1
				format = HTAtom_for(atomname);
d2265 3
a2267 4
			CTRACE((tfp,
				"HTLoadFile: value of presenting %s is %f\n",
				HTAtom_name(rep), value));
			if (value > best) {
d2273 4
a2276 4
		    }		/* if best so far */
		}
		/* if match */
	    }			/* end while directory entries left to read */
d2282 1
a2282 1
		base[-1] = '/';	/* Restore directory name */
d2286 1
a2286 1
	    } else {		/* If not found suitable file */
d2291 3
a2293 3
	    /*NOTREACHED */
	}
	/* if multi suffix */
d2295 12
a2306 11
	 * Check to see if the 'localname' is in fact a directory.  If it is
	 * create a new hypertext object containing a list of files and
	 * subdirectories contained in the directory.  All of these are links
	 * to the directories or files listed.  NB This assumes the existence
	 * of a type 'STRUCT_DIRENT', which will hold the directory entry, and
	 * a type 'DIR' which is used to point to the current directory being
	 * read.
	 */
#if defined(USE_DOS_DRIVES)
	if (strlen(localname) == 2 && LYIsDosDrive(localname))
	    LYAddPathSep(&localname);
a2307 1
	if (HTStat(localname, &dir_info) == -1)		/* get file information */
d2309 2
a2310 2
	    /* if can't read file information */
	    CTRACE((tfp, "HTLoadFile: can't stat %s\n", localname));
d2312 5
a2316 1
	} else {		/* Stat was OK */
d2320 2
a2321 2
		 * If localname is a directory.
		 */
d2325 1
a2325 1
		CTRACE((tfp, "%s is a directory\n", localname));
d2328 4
a2331 3
		 * Check directory access.  Selective access means only those
		 * directories containing a marker file can be browsed.
		 */
d2338 1
d2340 8
a2347 3
		    char *enable_file_name = NULL;

		    HTSprintf0(&enable_file_name, "%s/%s", localname, HT_DIR_ENABLE_FILE);
a2355 1
		CTRACE((tfp, "Opening directory %s\n", localname));
d2364 2
a2365 2
		 * Directory access is allowed and possible.
		 */
d2368 1
a2368 2
					 anchor, format_out, sink);
		closedir(dp);
d2373 1
a2373 8
	    }
	    /* end if localname is a directory */
	    if (S_ISREG(dir_info.st_mode)) {
#ifdef INT_MAX
		if (dir_info.st_size <= INT_MAX)
#endif
		    anchor->content_length = dir_info.st_size;
	    }
d2375 1
a2375 1
	}			/* end if file stat worked */
d2380 127
a2506 9
	if (decompressAndParse(anchor,
			       format_out,
			       sink,
			       nodename,
			       localname,
			       myEncoding,
			       format,
			       &status)) {
	    FREE(nodename);
d2508 2
a2509 4
	    return status;
	}
	FREE(localname);
    }				/* local unix file system */
d2515 2
a2516 2
     * Now, as transparently mounted access has failed, we try FTP.
     */
d2519 2
a2520 2
	 * Deal with case-sensitivity differences on VMS versus Unix.
	 */
a2526 1
	    status = -1;
d2528 5
a2532 4
	    if (strncmp(addr, "file://localhost", 16)) {
		/* never go to ftp site when URL
		 * is file://localhost
		 */
d2534 3
a2536 1
		status = HTFTPLoad(addr, anchor, format_out, sink);
a2538 1
	    return status;
d2545 2
a2546 2
     * All attempts have failed.
     */
d2548 1
a2548 1
	CTRACE((tfp, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO));
a2553 2
static const char *program_paths[pp_Last];

d2555 2
a2556 159
 * Given a program number, return its path
 */
const char *HTGetProgramPath(ProgramPaths code)
{
    const char *result = NULL;

    if (code > ppUnknown && code < pp_Last)
	result = program_paths[code];
    return result;
}

/*
 * Store a program's path.  The caller must allocate the string used for 'path',
 * since HTInitProgramPaths() may free it.
 */
void HTSetProgramPath(ProgramPaths code, const char *path)
{
    if (code > ppUnknown && code < pp_Last) {
	program_paths[code] = isEmpty(path) ? 0 : path;
    }
}

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
void HTInitProgramPaths(void)
{
    ProgramPaths code;
    int n;
    const char *path;
    const char *test;

    for (n = (int) ppUnknown + 1; n < (int) pp_Last; ++n) {
	switch (code = (ProgramPaths) n) {
#ifdef BZIP2_PATH
	case ppBZIP2:
	    path = BZIP2_PATH;
	    break;
#endif
#ifdef CHMOD_PATH
	case ppCHMOD:
	    path = CHMOD_PATH;
	    break;
#endif
#ifdef COMPRESS_PATH
	case ppCOMPRESS:
	    path = COMPRESS_PATH;
	    break;
#endif
#ifdef COPY_PATH
	case ppCOPY:
	    path = COPY_PATH;
	    break;
#endif
#ifdef CSWING_PATH
	case ppCSWING:
	    path = CSWING_PATH;
	    break;
#endif
#ifdef GZIP_PATH
	case ppGZIP:
	    path = GZIP_PATH;
	    break;
#endif
#ifdef INFLATE_PATH
	case ppINFLATE:
	    path = INFLATE_PATH;
	    break;
#endif
#ifdef INSTALL_PATH
	case ppINSTALL:
	    path = INSTALL_PATH;
	    break;
#endif
#ifdef MKDIR_PATH
	case ppMKDIR:
	    path = MKDIR_PATH;
	    break;
#endif
#ifdef MV_PATH
	case ppMV:
	    path = MV_PATH;
	    break;
#endif
#ifdef RLOGIN_PATH
	case ppRLOGIN:
	    path = RLOGIN_PATH;
	    break;
#endif
#ifdef RM_PATH
	case ppRM:
	    path = RM_PATH;
	    break;
#endif
#ifdef RMDIR_PATH
	case ppRMDIR:
	    path = RMDIR_PATH;
	    break;
#endif
#ifdef TAR_PATH
	case ppTAR:
	    path = TAR_PATH;
	    break;
#endif
#ifdef TELNET_PATH
	case ppTELNET:
	    path = TELNET_PATH;
	    break;
#endif
#ifdef TN3270_PATH
	case ppTN3270:
	    path = TN3270_PATH;
	    break;
#endif
#ifdef TOUCH_PATH
	case ppTOUCH:
	    path = TOUCH_PATH;
	    break;
#endif
#ifdef UNCOMPRESS_PATH
	case ppUNCOMPRESS:
	    path = UNCOMPRESS_PATH;
	    break;
#endif
#ifdef UNZIP_PATH
	case ppUNZIP:
	    path = UNZIP_PATH;
	    break;
#endif
#ifdef UUDECODE_PATH
	case ppUUDECODE:
	    path = UUDECODE_PATH;
	    break;
#endif
#ifdef ZCAT_PATH
	case ppZCAT:
	    path = ZCAT_PATH;
	    break;
#endif
#ifdef ZIP_PATH
	case ppZIP:
	    path = ZIP_PATH;
	    break;
#endif
	default:
	    path = NULL;
	    break;
	}
	test = HTGetProgramPath(code);
	if (test != NULL && test != path) {
	    free((char *) test);
	}
	HTSetProgramPath(code, path);
    }
}

/*
 *	Protocol descriptors
 */
d2559 1
a2559 1
GLOBALDEF(HTProtocol, HTFTP, _HTFILE_C_1_INIT);
d2561 1
a2561 1
GLOBALDEF(HTProtocol, HTFile, _HTFILE_C_2_INIT);
d2563 2
a2564 4
GLOBALDEF HTProtocol HTFTP =
{"ftp", HTLoadFile, 0};
GLOBALDEF HTProtocol HTFile =
{"file", HTLoadFile, HTFileSaveStream};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d26 1
a26 2
#if defined(DOSPATH)
#undef LONG_LIST
d29 1
d34 1
a34 1
#if defined(DOSPATH)
a36 3
#endif

#if defined(USE_DOS_DRIVES)
d38 1
a38 1
#endif
a40 1

d49 1
a83 6
typedef struct {
    struct stat file_info;
    char sort_tags;
    char file_name[1];	/* on the end of the struct, since its length varies */
} DIRED;

d123 3
d133 2
d143 8
d168 2
a169 4
    } else if (*bufp && !(entry && *entry)) {
	**bufp = '\0';
    } else if (entry) {
	StrAllocCopy(*bufp, entry);
d185 1
a185 1
	StrAllocCopy(*bufp, fmt);
a191 1
	DIRED *,	data,
d194 1
d202 1
a205 1
#ifndef NOUSERS
a206 1
#endif
a208 1
#ifdef S_IFLNK
a209 1
#endif
a210 9

#ifdef _WINDOWS	/* 1998/01/06 (Tue) 21:20:53 */
	static char *pbits[] = {
		"---", "--x", "-w-", "-wx",
		"r--", "r-x", "rw-", "rwx",
		0 };
#define PBIT(a, n, s)  pbits[((a) >> (n)) & 0x7]

#else
a216 1
#endif
d225 1
a225 1
	if (data->file_info.st_mode == 0)
d251 1
a251 1
		while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
d264 2
a265 2
			HTDirEntry(target, tail, data->file_name);
			FormatStr(&buf, start, data->file_name);
d270 1
a270 1
			if (c != 'A' && S_ISLNK(data->file_info.st_mode) &&
d281 1
a281 1
		    if (S_ISDIR(data->file_info.st_mode)) {
d312 2
a313 2
			datestr = ctime(&data->file_info.st_mtime);
			if ((now - data->file_info.st_mtime) < SEC_PER_YEAR/2)
d328 1
a328 1
			FormatNum(&buf, start, (int) data->file_info.st_size);
d332 1
a332 1
			if (S_ISDIR(data->file_info.st_mode)) {
a333 1
				StrAllocCat(buf, " ");
d338 1
a338 1
			FormatNum(&buf, start, (int)((data->file_info.st_size+1023)/1024));
d343 1
a343 4
			switch(data->file_info.st_mode & S_IFMT) {
#if defined(_MSC_VER) && defined(_S_IFIFO)
			case _S_IFIFO: type = 'p'; break;
#else
a344 1
#endif
a364 4
#ifdef _WINDOWS
			sprintf(tmp, "%c%s", type,
				PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_IRWXU));
#else
d366 3
a368 4
				PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_ISUID),
				PBIT(data->file_info.st_mode, 3, data->file_info.st_mode & S_ISGID),
				PTBIT(data->file_info.st_mode,   data->file_info.st_mode & S_ISVTX));
#endif
d373 1
a373 2
#ifndef NOUSERS
			name = HTAA_UidToName (data->file_info.st_uid);
d377 1
a377 1
				FormatNum(&buf, start, (int) data->file_info.st_uid);
a378 1
#endif
d382 1
a382 2
#ifndef NOUSERS
			name = HTAA_GidToName(data->file_info.st_gid);
d386 1
a386 1
				FormatNum(&buf, start, (int) data->file_info.st_gid);
a387 1
#endif
d391 1
a391 1
			FormatNum(&buf, start, (int) data->file_info.st_nlink);
d434 1
a434 1
	double,		value)
d437 1
a437 1
    BOOL trivial_enc = (BOOL) IsUnityEncStr(encoding);
d454 1
a454 1
	    suff = typecalloc(HTSuffix);
d487 1
a487 1
    suff->quality = (float) value;
a560 35
/*	Convert filename from URL-path syntax to local path format
**	----------------------------------------------------------
**	Input name is assumed to be the URL-path of a local file
**      URL, i.e. what comes after the "file://localhost".
**      '#'-fragments to be treated as such must already be stripped.
**      If expand_all is FALSE, unescape only escaped '/'. - kw
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
PUBLIC char * HTURLPath_toFile ARGS3(
	CONST char *,	name,
	BOOL,		expand_all,
	BOOL,		is_remote GCC_UNUSED)
{
    char * path = NULL;
    char * result = NULL;

    StrAllocCopy(path, name);
    if (expand_all)
	HTUnEscape(path);		/* Interpret all % signs */
    else
	HTUnEscapeSome(path, "/");	/* Interpret % signs for path delims */

    CTRACE((tfp, "URLPath `%s' means path `%s'\n", name, path));
#if defined(USE_DOS_DRIVES)
    StrAllocCopy(result, is_remote ? path : HTDOS_name(path));
#else
    StrAllocCopy(result, path);
#endif

    FREE(path);

    return result;
}
a570 5
/* NOTE: Don't use this function if you know that the input is a URL path
	 rather than a full URL, use HTURLPath_toFile instead.  Otherwise
	 this function will return the wrong thing for some unusual
	 paths (like ones containing "//", possibly escaped). - kw
*/
d582 1
a582 1
    if (expand_all) {
d584 1
a584 1
    } else
d591 16
a606 2
	    CTRACE((tfp, "Node `%s' means path `%s'\n", name, path));
	    StrAllocCopy(result, HTSYS_name(path));
d609 1
a609 1
	    CTRACE((tfp, "Node `%s' means file `%s'\n", name, result));
d615 1
a615 1
	if ((home = LYGetEnv("HOME")) == 0)
d620 1
a620 6
#if defined(_WINDOWS)	/* 1997/10/16 (Thu) 20:42:51 */
	home =  (char *)Home_Dir();
#else
	home = LYGetEnv("HOME");
#endif
	if (home == 0)
a631 3
    CTRACE((tfp, "HTnameOfFile_WWW(%s,%d,%d) = %s\n",
	    name, WWW_prefix, expand_all, result));

d649 1
a649 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name+13);
d653 1
a653 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name+5);
d655 1
a655 1
	HTSprintf0(&result, "%s//%s%s", STR_FILE_URL, HTHostName(), name);
d657 1
a657 1
    CTRACE((tfp, "File `%s'\n\tmeans node `%s'\n", name, result));
d690 1
a690 1
    trivial_enc = (BOOL) IsUnityEncStr(enc);
a804 4
			if (pencoding && IsUnityEnc(*pencoding) &&
			    *pencoding != WWW_ENC_7BIT &&
			    !IsUnityEnc(suff->encoding))
			    *pencoding = suff->encoding;
d858 2
a859 2
	CTRACE((tfp, "HTCharsetFormat: Extended MIME Content-Type is %s\n",
		    format->name));
d947 2
a948 2
		= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		   isdigit(UCH(cp4[9])));
d950 1
a950 1
		= (BOOL) (given_is_8859 ||
d955 1
a955 1
		= (BOOL) (given_is_8859like &&
d968 1
a968 1
		       isdigit(UCH(*cp1)))
a1005 79


/*	Get various pieces of meta info from file name.
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
PUBLIC void LYGetFileInfo ARGS7(
	CONST char *,		filename,
	HTParentAnchor **,	pfile_anchor,
	HTFormat *,		pformat,
	HTAtom **,		pencoding,
	CONST char**,		pdesc,
	CONST char**,		pcharset,
	int *,			pfile_cs)
{
	char *Afn;
	char *Aname = NULL;
	HTFormat format;
	HTAtom * myEnc = NULL;
	HTParentAnchor *file_anchor;
	CONST char *file_csname;
	int file_cs;

	/*
	 *  Convert filename to URL.  Note that it is always supposed to
	 *  be a filename, not maybe-filename-maybe-URL, so we don't
	 *  use LYFillLocalFileURL and LYEnsureAbsoluteURL. - kw
	 */
	Afn = HTEscape(filename, URL_PATH);
	LYLocalFileToURL(&Aname, Afn);
	file_anchor = HTAnchor_findSimpleAddress(Aname);

	file_csname = file_anchor->charset;
	format = HTFileFormat(filename, &myEnc, pdesc);
	format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
	file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
	if (!file_csname) {
	    if (file_cs >= 0)
		file_csname = LYCharSet_UC[file_cs].MIMEname;
	    else file_csname = "display character set";
	}
	CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	       filename,
	       ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
		*HTAtom_name(format) == 'a' ? "n" : ""),
	       myEnc ? HTAtom_name(myEnc) : "",
	       HTAtom_name(format),
	       file_csname,
	       file_cs));
	FREE(Afn);
	FREE(Aname);
	if (pfile_anchor)
	    *pfile_anchor = file_anchor;
	if (pformat)
	    *pformat = format;
	if (pencoding)
	    *pencoding = myEnc;
	if (pcharset)
	    *pcharset = file_csname;
	if (pfile_cs)
	    *pfile_cs = file_cs;
    }

d1028 2
a1029 2
	    CTRACE((tfp, "File: Value of %s is %.3f\n",
			filename, suff->quality));
d1033 1
a1033 37
    return (float)0.3;		/* Dunno! */
}

/*
**  Determine compression type from file name, by looking at its suffix.
**  Sets as side-effect a pointer to the "dot" that begins the suffix.
*/
PUBLIC CompressFileType HTCompressFileType ARGS3(
	char *,		filename,
	char *,		dots,
	char **,	suffix)
{
    CompressFileType result = cftNone;
    size_t len = strlen(filename);
    char *ftype = filename + len;

    if ((len > 4)
     && !strcasecomp((ftype - 3), "bz2")
     && strchr(dots, ftype[-4]) != 0) {
	result = cftBzip2;
	ftype -= 4;
    } else if ((len > 3)
     && !strcasecomp((ftype - 2), "gz")
     && strchr(dots, ftype[-3]) != 0) {
	result = cftGzip;
	ftype -= 3;
    } else if ((len > 2)
     && !strcmp((ftype - 1), "Z")
     && strchr(dots, ftype[-2]) != 0) {
	result = cftCompress;
	ftype -= 2;
    }

    *suffix = ftype;
    CTRACE((tfp, "HTCompressFileType(%s) returns %d:%s\n",
		 filename, result, *suffix));
    return result;
d1046 24
d1073 3
a1075 1
#ifndef NO_GROUPS
d1116 2
a1117 1
    CTRACE((tfp, "\tFile is not editable.\n"));
a1118 1
    return NO;					/* If no excuse, can't do */
d1130 2
a1131 3
    CONST char * addr = anchor->address;
    char * localname = HTLocalName(addr);
    FILE * fp = fopen(localname, BIN_W);
d1133 1
a1133 1
    FREE(localname);
a1148 1
    char * stripped = NULL;
d1152 7
a1158 5
    StrAllocCopy(escaped, entry);
    LYTrimPathSep(escaped);
    if (strcmp(escaped, "..") != 0) {
	stripped = escaped;
	escaped = HTEscape(stripped, URL_XPALPHAS);
a1183 1
    FREE(stripped);
d1196 3
a1198 3
**	and NO_PARENT_DIR_REFERENCE is not defined, so that the
**	calling function should use LYListFmtParse() to create a link
**	to the parent directory.  Otherwise, it returns FALSE. - FM
d1202 1
a1202 1
	HTParentAnchor *, anchor,
d1205 1
a1205 1
    CONST char * logical = anchor->address;
d1211 4
a1214 7
#if defined(USE_DOS_DRIVES)
    BOOL local_link = (strlen(logical) > 18
		     && !strncasecomp(logical, "file://localhost/", 17)
		     && LYIsDosDrive(logical + 17));
    BOOL is_remote = !local_link;
#else
#define is_remote TRUE
a1215 1

d1243 1
a1243 1
    current = LYPathLeaf (path);	/* last part or "" */
d1249 1
a1249 1
      printable = HTURLPath_toFile(
d1252 1
a1252 3
	    : path,
	    TRUE,
	    is_remote);
d1260 1
a1260 1
      StrAllocCopy(printable, current);
d1292 1
d1303 1
a1303 3
    if (current - path > 0
      && LYIsPathSep(current[-1])
      && current[0] != '\0') {	/* was a slash AND something else too */
d1307 1
a1307 1
	current[-1] = '\0';
d1314 1
d1322 3
a1324 3
#if defined(DOSPATH) || defined(__EMX__)
	if (local_link) {
	    if (parent != 0 && strlen(parent) == 3 ) {
a1325 3
	    }
	}
	else
d1329 3
d1370 1
d1379 1
d1414 1
d1428 7
a1434 4
    char * readme_file_name = NULL;
    int ch;

    HTSprintf0(&readme_file_name, "%s/%s", localname, HT_DIR_README_FILE);
d1436 1
a1436 1
    fp = fopen(readme_file_name, "r");
d1443 23
a1465 2
	while ((ch = fgetc(fp)) != EOF) {
	    PUTC((char)ch);
a1473 62
#define DIRED_BLOK(obj) (((DIRED *)(obj))->sort_tags)
#define DIRED_NAME(obj) (((DIRED *)(obj))->file_name)

#define NM_cmp(a,b) ((a) < (b) ? -1 : ((a) > (b) ? 1 : 0))

#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
PRIVATE char *file_type ARGS1(char *, path)
{
    char *type;
    while (*path == '.')
	++path;
    type = strchr(path, '.');
    if (type == NULL)
	type = "";
    return type;
}
#endif /* LONG_LIST && DIRED_SUPPORT */

PRIVATE int dired_cmp ARGS2(void *, a, void *, b)
{
    DIRED *p = (DIRED *)a;
    DIRED *q = (DIRED *)b;
    int code = p->sort_tags - q->sort_tags;
#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
    if (code == 0) {
	switch (dir_list_order) {
	case ORDER_BY_SIZE:
	    code = -NM_cmp(p->file_info.st_size, q->file_info.st_size);
	    break;
	case ORDER_BY_DATE:
	    code = -NM_cmp(p->file_info.st_mtime, q->file_info.st_mtime);
	    break;
	case ORDER_BY_MODE:
	    code = NM_cmp(p->file_info.st_mode, q->file_info.st_mode);
	    break;
	case ORDER_BY_USER:
	    code = NM_cmp(p->file_info.st_uid, q->file_info.st_uid);
	    break;
	case ORDER_BY_GROUP:
	    code = NM_cmp(p->file_info.st_gid, q->file_info.st_gid);
	    break;
	case ORDER_BY_TYPE:
	    code = AS_cmp(file_type(p->file_name), file_type(q->file_name));
	    break;
	default:
	    code = 0;
	    break;
	}
    }
#endif /* LONG_LIST && DIRED_SUPPORT */
    if (code == 0)
	code = AS_cmp(p->file_name, q->file_name);
#if 0
    CTRACE((tfp, "dired_cmp(%d) ->%d\n\t%c:%s (%s)\n\t%c:%s (%s)\n",
	    dir_list_order,
	    code,
	    p->sort_tags, p->file_name, file_type(p->file_name),
	    q->sort_tags, q->file_name, file_type(q->file_name)));
#endif
    return code;
}

d1484 1
d1490 1
a1491 1
    int i;
d1493 1
a1493 1
    CTRACE((tfp, "print_local_dir() started\n"));
d1495 2
a1496 1
    pathname = HTParse(anchor->address, "",
d1532 4
a1535 2
    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
d1545 2
a1546 1
    need_parent_link = HTDirTitles(target, anchor, FALSE);
d1549 2
a1550 2
    if (!isLYNXCGI(anchor->address)) {
	HTAnchor_setFormat(anchor, WWW_DIRED);
d1557 1
d1559 1
a1559 1
	HTBTree * bt = HTBTree_new(dired_cmp);
d1562 1
a1562 1
	_HTProgress (READING_DIRECTORY);
d1568 1
a1568 1
	    DIRED *data = NULL;
d1570 1
a1570 1
#if !(defined(DOSPATH) || defined(__EMX__))
d1592 5
a1596 4
	    /*
	    **  If filename is not root directory, add trailing separator.
	    */
	    LYAddPathSep(&tmpfilename);
d1599 2
a1600 9
	    data = (DIRED *)malloc(sizeof(DIRED) + strlen(dirbuf->d_name) + 4);
	    if (data == NULL) {
		/* FIXME */
	    }
	    LYTrimPathSep (tmpfilename);
	    if (lstat(tmpfilename, &(data->file_info)) < 0)
		data->file_info.st_mode = 0;

	    strcpy(data->file_name, dirbuf->d_name);
d1602 3
a1604 4
	    if (S_ISDIR(data->file_info.st_mode)) {
		data->sort_tags = 'D';
	    } else {
		data->sort_tags = 'F';
d1606 8
d1615 4
a1618 14
#else
	    if (S_ISDIR(data->file_info.st_mode)) {
		if (dir_list_style == MIXED_STYLE) {
		    data->sort_tags = ' ';
		    LYAddPathSep0(data->file_name);
		} else if (!strcmp(dirbuf->d_name, "..")) {
		    data->sort_tags = 'A';
		} else {
		    data->sort_tags = 'D';
		}
	    } else if (dir_list_style == MIXED_STYLE) {
		data->sort_tags = ' ';
	    } else if (dir_list_style == FILES_FIRST) {
		data->sort_tags = 'C';
d1620 2
a1621 3
	    } else {
		data->sort_tags = 'F';
	    }
d1626 1
a1626 1
	    HTBTree_add(bt, data);
d1644 1
a1644 1
	    _HTProgress (OPERATION_OK);
d1646 1
a1646 1
	    CTRACE((tfp, "Reading the directory interrupted by user\n"));
d1655 1
a1655 1
	    int num_of_entries_output = 0; /* lines counter */
d1668 1
a1668 1
		DIRED *entry;
d1670 6
a1675 14
#ifndef DISP_PARTIAL
		if (num_of_entries_output % HTMAX(display_lines,10) == 0) {
		    if (HTCheckForInterrupt()) {
			_HTProgress (TRANSFER_INTERRUPTED);
			status = HT_PARTIAL_CONTENT;
			break;
		    }
		}
#endif
		StrAllocCopy(tmpfilename, localname);
		/*
		**	If filename is not root directory.
		*/
		LYAddPathSep(&tmpfilename);
d1677 2
a1678 1
		entry = (DIRED *)(HTBTree_object(next_element));
a1682 1
		StrAllocCat(tmpfilename, entry->file_name);
d1687 5
a1691 1
		if (strcmp(DIRED_NAME(HTBTree_object(next_element)), "..")) {
d1693 1
a1693 1
		    test = (DIRED_BLOK(HTBTree_object(next_element))
d1709 1
a1709 1
			   (char) (DIRED_BLOK(HTBTree_object(next_element))
d1727 2
a1728 1
		    if (state != DIRED_BLOK(HTBTree_object(next_element))) {
d1736 1
a1736 1
			  (char) (DIRED_BLOK(HTBTree_object(next_element))
d1756 2
d1760 2
a1761 1
		LYListFmtParse(list_format, entry, tmpfilename, target, tail);
d1763 2
a1764 2
		HTDirEntry(target, tail, entry->file_name);
		PUTS(entry->file_name);
d1766 4
d1780 1
a1780 1
		if (num_of_entries_output %
d1783 1
a1783 1
		    /* num_of_entries, num_of_entries_output... */
d1793 1
a1793 1
		num_of_entries_output++;
d1810 2
a1829 30
#ifndef VMS
PUBLIC int HTStat ARGS2(
	CONST char *,	filename,
	struct stat *,	data)
{
    int result = -1;
    size_t len = strlen(filename);

    if (len != 0 && LYIsPathSep(filename[len-1])) {
	char *temp_name = NULL;
	HTSprintf0(&temp_name, "%s.", filename);
	result = HTStat(temp_name, data);
	FREE(temp_name);
    } else {
	result = stat(filename, data);
#ifdef _WINDOWS
	/*
	 * Someone claims that stat() doesn't give the proper result for a
	 * directory on Windows.
	 */
	if (result == -1
	 && access(filename, 0) == 0) {
	    data->st_mode = S_IFDIR;
	    result = 0;
	}
#endif
    }
    return result;
}
#endif
d1851 1
a1857 1
    char *dot;
d1878 7
a1884 3
       (!LYSameHostname("localhost", nodename) &&
	!LYSameHostname(nodename, HTHostName()))) {
	status = -1;
d1890 4
d1895 12
a1907 1
	return status;
d1912 1
a1912 1
#if defined(VMS) || defined(USE_DOS_DRIVES)
d1954 1
a1954 1
	CTRACE((tfp, "HTLoadFile: Can't stat %s\n", filename));
d1964 8
a1971 3
		char * enable_file_name = NULL;

		HTSprintf0(&enable_file_name, "%s/%s", filename, HT_DIR_ENABLE_FILE);
d2001 1
a2001 1
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", vmsname));
d2005 2
a2006 2
		CTRACE((tfp, "HTLoadFile: Can't open as %s\n",
			    ultrixname));
d2011 2
d2045 1
a2045 1
		    gzfp = gzopen(vmsname, BIN_R);
d2047 2
a2048 2
		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				vmsname, (void*)gzfp));
d2057 7
a2063 7
	    } else {
		/* FIXME: should we check if suffix is after ']' or ':' ? */
		CompressFileType cft = HTCompressFileType(vmsname, "._-", &dot);

		if (cft != cftNone) {
		    char *cp = NULL;

d2065 1
a2065 1
		    cp[dot - vmsname] = '\0';
a2070 4
		}

		switch (cft) {
		case cftCompress:
d2073 13
a2085 3
		    break;
		case cftGzip:
		    StrAllocCopy(anchor->content_encoding, "x-gzip");
d2087 5
a2091 5
		    if (strcmp(format_out->name, "www/download") != 0) {
			fclose(fp);
			if (semicolon != NULL)
			    *semicolon = ';';
			gzfp = gzopen(vmsname, BIN_R);
d2093 4
a2096 4
			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    vmsname, (void*)gzfp));
			use_gzread = YES;
		    }
d2098 1
a2098 1
		    format = HTAtom_for("www/compressed");
d2100 1
a2100 7
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    format = HTAtom_for("www/compressed");
		    break;
		case cftNone:
		    break;
d2149 1
a2149 1
#else /* not VMS: */
d2180 1
a2180 1
	    float best = (float) NO_VALUE_FOUND; /* So far best is bad */
d2207 1
a2207 1
#if !(defined(DOSPATH) || defined(__EMX__))
a2219 2
			char *atomname = NULL;
			CompressFileType cft = HTCompressFileType(dirbuf->d_name, ".", &dot);
d2221 1
a2221 1

d2223 3
a2225 1
			if (cft != cftNone) {
d2227 1
a2227 1
			    cp[dot - dirbuf->d_name] = '\0';
d2232 9
a2240 12
			    switch (cft) {
			    case cftCompress:
				atomname = "application/x-compressed";
				break;
			    case cftGzip:
				atomname = "application/x-gzip";
				break;
			    case cftBzip2:
				atomname = "application/x-bzip2";
				break;
			    case cftNone:
				break;
d2242 8
a2249 3
			}

			if (atomname != NULL) {
d2253 1
a2253 1
				format = HTAtom_for(atomname);
d2265 2
a2266 2
			CTRACE((tfp, "HTLoadFile: value of presenting %s is %f\n",
				    HTAtom_name(rep), value));
d2303 4
a2306 3
#if defined(USE_DOS_DRIVES)
	if (strlen(localname) == 2 && LYIsDosDrive(localname))
	    LYAddPathSep(&localname);
a2307 1
	if (HTStat(localname,&dir_info) == -1)	   /* get file information */
d2310 1
a2310 1
	    CTRACE((tfp, "HTLoadFile: can't stat %s\n", localname));
d2314 4
d2325 1
a2325 1
		CTRACE((tfp, "%s is a directory\n", localname));
d2338 1
d2340 8
a2347 3
		    char * enable_file_name = NULL;

		    HTSprintf0(&enable_file_name, "%s/%s", localname, HT_DIR_ENABLE_FILE);
a2355 1
		CTRACE((tfp, "Opening directory %s\n", localname));
a2368 1
		closedir(dp);
d2373 1
a2373 8
	    } /* end if localname is a directory */

	    if (S_ISREG(dir_info.st_mode)) {
#ifdef INT_MAX
		if (dir_info.st_size <= INT_MAX)
#endif
		    anchor->content_length = dir_info.st_size;
	    }
d2381 7
a2387 2
	    int bin = HTCompressFileType(localname, ".", &dot) != cftNone;
	    FILE * fp = fopen(localname, (bin ? BIN_R : "r"));
d2389 2
a2390 2
	    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n",
				 localname, (void*)fp));
d2392 3
d2416 1
a2416 1
			gzfp = gzopen(localname, BIN_R);
d2418 2
a2419 2
			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    localname, (void*)gzfp));
d2428 3
a2430 6
		} else {
		    CompressFileType cft = HTCompressFileType(localname, ".", &dot);

		    if (cft != cftNone) {
			char *cp = NULL;

d2432 1
a2432 1
			cp[dot - localname] = '\0';
a2437 4
		    }

		    switch (cft) {
		    case cftCompress:
d2440 11
a2450 2
			break;
		    case cftGzip:
d2455 1
a2455 1
			    gzfp = gzopen(localname, BIN_R);
d2457 2
a2458 2
			    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					localname, (void*)gzfp));
a2463 7
			break;
		    case cftBzip2:
			StrAllocCopy(anchor->content_encoding, "x-bzip2");
			format = HTAtom_for("www/compressed");
			break;
		    case cftNone:
			break;
a2526 1
	    status = -1;
d2528 5
a2532 4
	    if (strncmp(addr, "file://localhost", 16)) {
		/* never go to ftp site when URL
		 * is file://localhost
		 */
d2534 3
a2536 1
		status = HTFTPLoad(addr, anchor, format_out, sink);
a2538 1
	    return status;
d2548 1
a2548 1
	CTRACE((tfp, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO));
a2550 150
    }
}

static CONST char *program_paths[pp_Last];

/*
 * Given a program number, return its path
 */
PUBLIC CONST char * HTGetProgramPath ARGS1(
	ProgramPaths,	code)
{
    CONST char *result = NULL;
    if (code > ppUnknown && code < pp_Last)
	result = program_paths[code];
    return result;
}

/*
 * Store a program's path.  The caller must allocate the string used for 'path',
 * since HTInitProgramPaths() may free it.
 */
PUBLIC void HTSetProgramPath ARGS2(
	ProgramPaths,	code,
	CONST char *,	path)
{
    if (code > ppUnknown && code < pp_Last) {
	program_paths[code] = isEmpty(path) ? 0 : path;
    }
}

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
PUBLIC void HTInitProgramPaths NOARGS
{
    int code;
    CONST char *path;
    CONST char *test;

    for (code = (int) ppUnknown + 1; code < (int) pp_Last; ++code) {
	switch (code) {
#ifdef BZIP2_PATH
	case ppBZIP2:
	    path = BZIP2_PATH;
	    break;
#endif
#ifdef CHMOD_PATH
	case ppCHMOD:
	    path = CHMOD_PATH;
	    break;
#endif
#ifdef COMPRESS_PATH
	case ppCOMPRESS:
	    path = COMPRESS_PATH;
	    break;
#endif
#ifdef COPY_PATH
	case ppCOPY:
	    path = COPY_PATH;
	    break;
#endif
#ifdef CSWING_PATH
	case ppCSWING:
	    path = CSWING_PATH;
	    break;
#endif
#ifdef GZIP_PATH
	case ppGZIP:
	    path = GZIP_PATH;
	    break;
#endif
#ifdef INSTALL_PATH
	case ppINSTALL:
	    path = INSTALL_PATH;
	    break;
#endif
#ifdef MKDIR_PATH
	case ppMKDIR:
	    path = MKDIR_PATH;
	    break;
#endif
#ifdef MV_PATH
	case ppMV:
	    path = MV_PATH;
	    break;
#endif
#ifdef RLOGIN_PATH
	case ppRLOGIN:
	    path = RLOGIN_PATH;
	    break;
#endif
#ifdef RM_PATH
	case ppRM:
	    path = RM_PATH;
	    break;
#endif
#ifdef TAR_PATH
	case ppTAR:
	    path = TAR_PATH;
	    break;
#endif
#ifdef TELNET_PATH
	case ppTELNET:
	    path = TELNET_PATH;
	    break;
#endif
#ifdef TN3270_PATH
	case ppTN3270:
	    path = TN3270_PATH;
	    break;
#endif
#ifdef TOUCH_PATH
	case ppTOUCH:
	    path = TOUCH_PATH;
	    break;
#endif
#ifdef UNCOMPRESS_PATH
	case ppUNCOMPRESS:
	    path = UNCOMPRESS_PATH;
	    break;
#endif
#ifdef UNZIP_PATH
	case ppUNZIP:
	    path = UNZIP_PATH;
	    break;
#endif
#ifdef UUDECODE_PATH
	case ppUUDECODE:
	    path = UUDECODE_PATH;
	    break;
#endif
#ifdef ZCAT_PATH
	case ppZCAT:
	    path = ZCAT_PATH;
	    break;
#endif
#ifdef ZIP_PATH
	case ppZIP:
	    path = ZIP_PATH;
	    break;
#endif
	default:
	    path = NULL;
	    break;
	}
	test = HTGetProgramPath(code);
	if (test != NULL && test != path) {
	    free((char *)test);
	}
	HTSetProgramPath(code, path);
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d282 1
a282 1
			    (len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
a2072 1
    char * ftp_newhost;
a2107 4
	ftp_newhost = HTParse(addr, "", PARSE_HOST);
	if (strcmp(ftp_lasthost, ftp_newhost))
	    ftp_local_passive = ftp_passive;

a2108 10

	if ( ftp_passive == ftp_local_passive ) {
	    if (( status >= 400 ) || ( status < 0 )) {
		ftp_local_passive = !ftp_passive;
		status = HTFTPLoad(addr, anchor, format_out, sink);
	    }
	}

	free(ftp_lasthost);
	ftp_lasthost = ftp_newhost;
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d49 1
a49 1
#if defined (USE_ZLIB) || defined (USE_BZLIB)
d2079 1
a2079 1
    int status = -1;
d2086 1
a2087 7
#ifdef USE_BZLIB
    BZFILE *bzfp = 0;
#endif /* USE_ZLIB */
#if defined(USE_ZLIB) || defined(USE_BZLIB)
    CompressFileType internal_decompress = cftNone;
    BOOL failed_decompress = NO;
#endif
d2260 1
a2260 1
		    internal_decompress = cftGzip;
a2262 14
#ifdef USE_BZLIB
		if (strcmp(format_out->name, "www/download") != 0 &&
		    (!strcmp(HTAtom_name(myEncoding), "bzip2") ||
		     !strcmp(HTAtom_name(myEncoding), "x-bzip2"))) {
		    fclose(fp);
		    if (semicolon != NULL)
			*semicolon = ';';
		    bzfp = BZ2_bzopen(vmsname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
				vmsname, (void*)bzfp));
		    use_zread = YES;
		} else
#endif	/* USE_BZLIB */
d2300 1
a2300 1
			internal_decompress = cftGzip;
a2307 12
#ifdef USE_BZLIB
		    if (strcmp(format_out->name, "www/download") != 0) {
			fclose(fp);
			if (semicolon != NULL)
			    *semicolon = ';';
			bzfp = BZ2_bzopen(vmsname, BIN_R);

			CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
				    vmsname, (void*)bzfp));
			internal_decompress = cfgBzip2;
		    }
#else  /* USE_BZLIB */
a2308 1
#endif	/* USE_BZLIB */
a2317 3
#if defined(USE_ZLIB) || defined(USE_BZLIB)
	    if (internal_decompress != cftNone) {
		switch (internal_decompress) {
d2319 2
a2320 19
		case cftCompress:
		case cftGzip:
		    failed_decompress = (gzfp == 0);
		    break;
#endif
#ifdef USE_BZLIB
		case cftBzip2:
		    failed_decompress = (bzfp == 0);
		    break;
#endif
		default:
		    failed_decompress = YES;
		    break;
		}
		if (failed_decompress) {
		    status = HTLoadError(NULL,
					 -(HT_ERROR),
					 FAILED_OPEN_COMPRESSED_FILE);
		} else {
d2341 7
a2347 12
#ifdef USE_BZLIB
		    if (bzfp)
			status = HTParseBzFile(format, format_out,
					       anchor,
					       bzfp, sink);
#endif
#ifdef USE_ZLIB
		    if (gzfp)
			status = HTParseGzFile(format, format_out,
					       anchor,
					       gzfp, sink);
#endif
d2350 1
a2350 1
#endif /* USE_ZLIB || USE_BZLIB */
d2368 1
a2368 1
    **	Not allowed in secure (HTClientHost) situations. TBL 921019
d2620 1
a2620 1
			internal_decompress = cftGzip;
a2622 12
#ifdef USE_BZLIB
		    if (strcmp(format_out->name, "www/download") != 0 &&
			(!strcmp(HTAtom_name(myEncoding), "bzip2") ||
			 !strcmp(HTAtom_name(myEncoding), "x-bzip2"))) {
			fclose(fp);
			bzfp = BZ2_bzopen(localname, BIN_R);

			CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
				    localname, (void*)bzfp));
			internal_decompress = cftBzip2;
		    } else
#endif	/* USE_BZLIB */
d2657 1
a2657 1
			    internal_decompress = cftGzip;
a2664 10
#ifdef USE_BZLIB
			if (strcmp(format_out->name, "www/download") != 0) {
			    fclose(fp);
			    bzfp = BZ2_bzopen(localname, BIN_R);

			    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
					localname, (void*)bzfp));
			    internal_decompress = cftBzip2;
			}
#else  /* USE_BZLIB */
a2665 1
#endif	/* USE_BZLIB */
a2672 3
#if defined(USE_ZLIB) || defined(USE_BZLIB)
		if (internal_decompress != cftNone) {
		    switch (internal_decompress) {
d2674 2
a2675 18
		    case cftGzip:
			failed_decompress = (gzfp == 0);
			break;
#endif
#ifdef USE_BZLIB
		    case cftBzip2:
			failed_decompress = (bzfp == 0);
			break;
#endif
		    default:
			failed_decompress = YES;
			break;
		    }
		    if (failed_decompress) {
			status = HTLoadError(NULL,
					     -(HT_ERROR),
					     FAILED_OPEN_COMPRESSED_FILE);
		    } else {
d2696 7
a2702 12
#ifdef USE_BZLIB
			if (bzfp)
			    status = HTParseBzFile(format, format_out,
						   anchor,
						   bzfp, sink);
#endif
#ifdef USE_ZLIB
			if (gzfp)
			    status = HTParseGzFile(format, format_out,
						   anchor,
						   gzfp, sink);
#endif
a2848 5
	    break;
#endif
#ifdef RMDIR_PATH
	case ppRMDIR:
	    path = RMDIR_PATH;
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d117 1
a117 1
	const HTStructuredClass *	isa;
d124 1
a124 1
int HTDirAccess = HT_DIR_OK;
d127 1
a127 1
int HTDirReadme = HT_DIR_README_NONE;
d129 1
a129 1
int HTDirReadme = HT_DIR_README_TOP;
d132 1
a132 1
static char *HTMountRoot = "/Net/";		/* Where to find mounts */
d134 1
a134 1
static char *HTCacheRoot = "/WWW$SCRATCH";	/* Where to cache things */
d136 1
a136 1
static char *HTCacheRoot = "/tmp/W3_Cache_";	/* Where to cache things */
d142 3
a144 3
static HTList * HTSuffixes = 0;
static HTSuffix no_suffix = { "*", NULL, NULL, NULL, 1.0 };
static HTSuffix unknown_suffix = { "*.*", NULL, NULL, NULL, 1.0};
d151 1
a151 1
static void free_suffixes (void);
d155 4
a158 4
static char *FormatStr (
    char **	bufp,
    char *	start,
    const char *	entry)
d172 4
a175 4
static char *FormatNum (
    char **	bufp,
    char *	start,
    int	entry)
d188 6
a193 6
static void LYListFmtParse (
	char *		fmtstr,
	DIRED *	data,
	char *		file,
	HTStructured * target,
	char *		tail)
d299 1
a299 1
			const char *cp2;
d454 6
a459 6
void HTSetSuffix5 (
	const char *	suffix,
	const char *	representation,
	const char *	encoding,
	const char *	desc,
	double		value)
d525 1
a525 1
static void free_suffixes (void)
d560 2
a561 2
char * HTCacheFileName (
	const char *	name)
d580 1
a580 1
static int HTCreatePath (const char * path)
d596 4
a599 4
char * HTURLPath_toFile (
	const char *	name,
	BOOL		expand_all,
	BOOL		is_remote GCC_UNUSED)
d636 4
a639 4
char * HTnameOfFile_WWW (
	const char *	name,
	BOOL		WWW_prefix,
	BOOL		expand_all)
d702 2
a703 2
char * WWW_nameOfFile (
	const char *	name)
d731 3
a733 3
const char * HTFileSuffix (
	HTAtom*	rep,
	const char *	enc)
d799 4
a802 4
HTFormat HTFileFormat (
	const char *	filename,
	HTAtom **	pencoding,
	const char**	pdesc)
d907 4
a910 4
HTFormat HTCharsetFormat (
	HTFormat		format,
	HTParentAnchor *	anchor,
	int			default_LYhndl)
d1091 8
a1098 8
void LYGetFileInfo (
	const char *		filename,
	HTParentAnchor **	pfile_anchor,
	HTFormat *		pformat,
	HTAtom **		pencoding,
	const char**		pdesc,
	const char**		pcharset,
	int *			pfile_cs)
d1105 1
a1105 1
	const char *file_csname;
d1152 2
a1153 2
float HTFileValue (
	const char *	filename)
d1182 4
a1185 4
CompressFileType HTCompressFileType (
	char *		filename,
	char *		dots,
	char **	suffix)
d1224 2
a1225 2
BOOL HTEditable (
	const char *	filename)
d1279 2
a1280 2
HTStream * HTFileSaveStream (
	HTParentAnchor *	anchor)
d1282 1
a1282 1
    const char * addr = anchor->address;
d1296 4
a1299 4
void HTDirEntry (
	HTStructured * target,
	const char *	tail,
	const char *	entry)
d1353 4
a1356 4
BOOL HTDirTitles (
	HTStructured * target,
	HTParentAnchor * anchor,
	BOOL		tildeIsTop)
d1358 1
a1358 1
    const char * logical = anchor->address;
d1581 1
a1581 1
static void do_readme (HTStructured *  target, const char *  localname)
d1612 1
a1612 1
static char *file_type (char *  path)
d1624 1
a1624 1
static int dired_cmp (void *  a, void *  b)
d1668 6
a1673 6
static int print_local_dir (
	DIR  *			dp,
	char *			localname,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink)
d2023 3
a2025 3
int HTStat (
	const char *	filename,
	struct stat *	data)
d2065 5
a2069 5
int HTLoadFile (
	const char *		addr,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink)
d2863 1
a2863 1
static const char *program_paths[pp_Last];
d2868 2
a2869 2
const char * HTGetProgramPath (
	ProgramPaths	code)
d2871 1
a2871 1
    const char *result = NULL;
d2881 3
a2883 3
void HTSetProgramPath (
	ProgramPaths	code,
	const char *	path)
d2893 1
a2893 1
void HTInitProgramPaths (void)
d2896 2
a2897 2
    const char *path;
    const char *test;
d3027 2
a3028 2
GLOBALDEF HTProtocol HTFTP  = { "ftp", HTLoadFile, 0 };
GLOBALDEF HTProtocol HTFile = { "file", HTLoadFile, HTFileSaveStream };
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 20
a21 20
 *			===========
 *
 *	This is unix-specific code in general, with some VMS bits.
 *	These are routines for file access used by browsers.
 *	Development of this module for Unix DIRED_SUPPORT in Lynx
 *	 regrettably has has been conducted in a manner with now
 *	 creates a major impediment for hopes of adapting Lynx to
 *	 a newer version of the library.
 *
 *  History:
 *	   Feb 91	Written Tim Berners-Lee CERN/CN
 *	   Apr 91	vms-vms access included using DECnet syntax
 *	26 Jun 92 (JFG) When running over DECnet, suppressed FTP.
 *			Fixed access bug for relative names on VMS.
 *	   Sep 93 (MD)	Access to VMS files allows sharing.
 *	15 Nov 93 (MD)	Moved HTVMSname to HTVMSUTILS.C
 *	27 Dec 93 (FM)	FTP now works with VMS hosts.
 *			FTP path must be Unix-style and cannot include
 *			the device or top directory.
 */
d28 2
a29 2
#define LONG_LIST		/* Define this for long style unix listings (ls -l),
				   the actual style is configurable from lynx.cfg */
d31 1
a31 1
/* #define NO_PARENT_DIR_REFERENCE *//* Define this for no parent links */
d80 5
a84 5
    char *suffix;
    HTAtom *rep;
    HTAtom *encoding;
    char *desc;
    float quality;
d90 1
a90 1
    char file_name[1];		/* on the end of the struct, since its length varies */
d117 2
a118 2
    const HTStructuredClass *isa;
    /* ... */
d122 2
a123 2
 *  Controlling globals.
 */
a127 1

d132 1
a132 2
static char *HTMountRoot = "/Net/";	/* Where to find mounts */

a134 1

d140 6
a145 7
 *  Suffix registration.
 */
static HTList *HTSuffixes = 0;
static HTSuffix no_suffix =
{"*", NULL, NULL, NULL, 1.0};
static HTSuffix unknown_suffix =
{"*.*", NULL, NULL, NULL, 1.0};
d148 2
a149 2
 *	----------------------------------------
 */
d151 1
a151 1
static void free_suffixes(void);
d155 4
a158 3
static char *FormatStr(char **bufp,
		       char *start,
		       const char *entry)
a160 1

d172 4
a175 3
static char *FormatNum(char **bufp,
		       char *start,
		       int entry)
a177 1

d188 15
a202 15
static void LYListFmtParse(char *fmtstr,
			   DIRED * data,
			   char *file,
			   HTStructured * target,
			   char *tail)
{
    char c;
    char *s;
    char *end;
    char *start;
    char *str = NULL;
    char *buf = NULL;
    char tmp[LY_MAXPATH];
    char type;

d204 1
a204 1
    char *name;
d206 2
a207 3
    time_t now;
    char *datestr;

d209 1
a209 1
    int len;
d213 5
a217 7
#ifdef _WINDOWS			/* 1998/01/06 (Tue) 21:20:53 */
    static char *pbits[] =
    {
	"---", "--x", "-w-", "-wx",
	"r--", "r-x", "rw-", "rwx",
	0};

d221 4
a224 7
    static char *pbits[] =
    {"---", "--x", "-w-", "-wx",
     "r--", "r-x", "rw-", "rwx", 0};
    static char *psbits[] =
    {"--S", "--s", "-wS", "-ws",
     "r-S", "r-s", "rwS", "rws", 0};

d229 2
a230 4
    static char *ptbits[] =
    {"--T", "--t", "-wT", "-wt",
     "r-T", "r-t", "rwT", "rwt", 0};

d236 2
a237 2
    if (data->file_info.st_mode == 0)
	fmtstr = "    %a";	/* can't stat so just do anchor */
d239 4
a242 6
    StrAllocCopy(str, fmtstr);
    s = str;
    end = str + strlen(str);
    START(HTML_PRE);
    while (*s) {
	start = s;
d244 36
a279 34
	    if (*s == '%') {
		if (*(s + 1) == '%')	/* literal % */
		    s++;
		else
		    break;
	    }
	    s++;
	}
	/* s is positioned either at a % or at \0 */
	*s = '\0';
	if (s > start) {	/* some literal chars. */
	    PUTS(start);
	}
	if (s == end)
	    break;
	start = ++s;
	while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
	       *s == '#' || *s == '+' || *s == '\'')
	    s++;
	c = *s;			/* the format char. or \0 */
	*s = '\0';

	switch (c) {
	case '\0':
	    PUTS(start);
	    continue;

	case 'A':
	case 'a':		/* anchor */
	    HTDirEntry(target, tail, data->file_name);
	    FormatStr(&buf, start, data->file_name);
	    PUTS(buf);
	    END(HTML_A);
	    *buf = '\0';
d281 6
a286 6
	    if (c != 'A' && S_ISLNK(data->file_info.st_mode) &&
		(len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
		PUTS(" -> ");
		tmp[len] = '\0';
		PUTS(tmp);
	    }
d288 1
a288 1
	    break;
d290 25
a314 21
	case 'T':		/* MIME type */
	case 't':		/* MIME type description */
	    if (S_ISDIR(data->file_info.st_mode)) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else {
		const char *cp2;
		HTFormat format;

		format = HTFileFormat(file, NULL, &cp2);

		if (c != 'T') {
		    if (cp2 == NULL) {
			if (!strncmp(HTAtom_name(format),
				     "application", 11)) {
			    cp2 = HTAtom_name(format) + 12;
			    if (!strncmp(cp2, "x-", 2))
				cp2 += 2;
d316 1
a316 1
			    cp2 = HTAtom_name(format);
d319 1
a319 6
		    FormatStr(&buf, start, cp2);
		} else {
		    FormatStr(&buf, start, HTAtom_name(format));
		}
	    }
	    break;
d321 16
a336 16
	case 'd':		/* date */
	    now = time(0);
	    datestr = ctime(&data->file_info.st_mtime);
	    if ((now - data->file_info.st_mtime) < SEC_PER_YEAR / 2)
		/*
		 * MMM DD HH:MM
		 */
		sprintf(tmp, "%.12s", datestr + 4);
	    else
		/*
		 * MMM DD YYYY
		 */
		sprintf(tmp, "%.7s %.4s ", datestr + 4,
			datestr + 20);
	    FormatStr(&buf, start, tmp);
	    break;
d338 3
a340 3
	case 's':		/* size in bytes */
	    FormatNum(&buf, start, (int) data->file_info.st_size);
	    break;
d342 11
a352 11
	case 'K':		/* size in Kilobytes but not for directories */
	    if (S_ISDIR(data->file_info.st_mode)) {
		FormatStr(&buf, start, "");
		StrAllocCat(buf, " ");
		break;
	    }
	    /* FALL THROUGH */
	case 'k':		/* size in Kilobytes */
	    FormatNum(&buf, start, (int) ((data->file_info.st_size + 1023) / 1024));
	    StrAllocCat(buf, "K");
	    break;
d354 2
a355 2
	case 'p':		/* unix-style permission bits */
	    switch (data->file_info.st_mode & S_IFMT) {
d357 1
a357 3
	    case _S_IFIFO:
		type = 'p';
		break;
d359 1
a359 3
	    case S_IFIFO:
		type = 'p';
		break;
d361 3
a363 9
	    case S_IFCHR:
		type = 'c';
		break;
	    case S_IFDIR:
		type = 'd';
		break;
	    case S_IFREG:
		type = '-';
		break;
d365 1
a365 3
	    case S_IFBLK:
		type = 'b';
		break;
d368 1
a368 3
	    case S_IFLNK:
		type = 'l';
		break;
d371 1
a371 1
# ifdef S_IFIFO			/* some older machines (e.g., apollo) have a conflict */
d373 1
a373 3
	    case S_IFSOCK:
		type = 's';
		break;
d376 1
a376 3
	    case S_IFSOCK:
		type = 's';
		break;
d379 2
a380 4
	    default:
		type = '?';
		break;
	    }
d382 2
a383 2
	    sprintf(tmp, "%c%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_IRWXU));
d385 4
a388 4
	    sprintf(tmp, "%c%s%s%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_ISUID),
		    PBIT(data->file_info.st_mode, 3, data->file_info.st_mode & S_ISGID),
		    PTBIT(data->file_info.st_mode, data->file_info.st_mode & S_ISVTX));
d390 2
a391 2
	    FormatStr(&buf, start, tmp);
	    break;
d393 1
a393 1
	case 'o':		/* owner */
d395 6
a400 6
	    name = HTAA_UidToName(data->file_info.st_uid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_uid);
	    }
d402 1
a402 1
	    break;
d404 1
a404 1
	case 'g':		/* group */
d406 6
a411 6
	    name = HTAA_GidToName(data->file_info.st_gid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_gid);
	    }
d413 5
a417 1
	    break;
d419 3
a421 3
	case 'l':		/* link count */
	    FormatNum(&buf, start, (int) data->file_info.st_nlink);
	    break;
d423 7
a429 3
	case '%':		/* literal % with flags/width */
	    FormatStr(&buf, start, "%");
	    break;
d431 1
a431 4
	default:
	    fprintf(stderr,
		    "Unknown format character `%c' in list format\n", c);
	    break;
d433 4
a436 9
	if (buf)
	    PUTS(buf);

	s++;
    }
    FREE(buf);
    END(HTML_PRE);
    PUTC('\n');
    FREE(str);
d441 19
a459 18
 *	--------------------------------------------------------
 *
 *	Calling this with suffix set to "*" will set the default
 *	representation.
 *	Calling this with suffix set to "*.*" will set the default
 *	representation for unknown suffix files which contain a ".".
 *
 *	The encoding parameter can give a trivial (8bit, 7bit, binary)
 *	or real (gzip, compress) encoding.
 *
 *	If filename suffix is already defined with the same encoding
 *	its previous definition is overridden.
 */
void HTSetSuffix5(const char *suffix,
		  const char *representation,
		  const char *encoding,
		  const char *desc,
		  double value)
d461 1
a461 1
    HTSuffix *suff;
d471 1
a471 1
	while (NULL != (suff = (HTSuffix *) HTList_nextObject(cur))) {
d475 1
a475 1
		  strcmp(encoding, HTAtom_name(suff->encoding)) == 0)))
d478 1
a478 1
	if (!suff) {		/* Not found -- create a new node */
d484 4
a487 4
	     * Memory leak fixed.
	     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	     */
	    if (!HTSuffixes) {
d504 4
a507 4
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     * Invariant code removed.
     */
d517 9
a525 9
 *	Purpose:	Free all added suffixes.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		To be used at program exit.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void free_suffixes(void)
d527 1
a527 1
    HTSuffix *suff = NULL;
d530 2
a531 2
     * Loop through all suffixes.
     */
d534 3
a536 3
	 * Free off each item and its members if need be.
	 */
	suff = (HTSuffix *) HTList_removeLastObject(HTSuffixes);
d542 2
a543 2
     * Free off the list itself.
     */
d549 1
d551 11
a561 10
 *	-------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	/tmp/WWW_Cache_news/1234@@cernvax.cern.ch
 *		/tmp/WWW_Cache_http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTCacheFileName(const char *name)
d563 4
a566 4
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *result = NULL;
d577 2
a578 2
 *	-----------------------------------------
 */
d580 1
a580 1
static int HTCreatePath(const char *path)
d587 13
a599 12
 *	----------------------------------------------------------
 *	Input name is assumed to be the URL-path of a local file
 *      URL, i.e. what comes after the "file://localhost".
 *      '#'-fragments to be treated as such must already be stripped.
 *      If expand_all is FALSE, unescape only escaped '/'. - kw
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTURLPath_toFile(const char *name,
		       BOOL expand_all,
		       BOOL is_remote GCC_UNUSED)
d601 2
a602 2
    char *path = NULL;
    char *result = NULL;
d606 1
a606 1
	HTUnEscape(path);	/* Interpret all % signs */
d622 9
a630 9
 *	------------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	$(HOME)/WWW/news/1234@@cernvax.cern.ch
 *		$(HOME)/WWW/http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
d636 10
a645 9
char *HTnameOfFile_WWW(const char *name,
		       BOOL WWW_prefix,
		       BOOL expand_all)
{
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    const char *home;
    char *result = NULL;
d648 1
a648 1
	HTUnEscape(path);	/* Interpret all % signs */
d652 2
a653 2
    if (0 == strcmp(acc_method, "file")		/* local file */
	||!*acc_method) {	/* implicitly local? */
d664 1
a664 1
    } else if (WWW_prefix) {	/* other access */
d671 2
a672 2
#if defined(_WINDOWS)		/* 1997/10/16 (Thu) 20:42:51 */
	home = Home_Dir();
d695 9
a703 8
 *	--------------------------------------------
 *
 *  Bugs:
 *	At present, only the names of two network root nodes are hand-coded
 *	in and valid for the NeXT only.  This should be configurable in
 *	the general case.
 */
char *WWW_nameOfFile(const char *name)
d705 1
a705 2
    char *result = NULL;

d708 1
a708 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 13);
d712 1
a712 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 5);
d721 13
a733 12
 *	------------------------------------------------------
 *
 *  On entry,
 *	rep	is the atomized MIME style representation
 *	enc	is an encoding, trivial (8bit, binary, etc.) or gzip etc.
 *
 *  On exit:
 *	Returns a pointer to a suitable suffix string if one has been
 *	found, else "".
 */
const char *HTFileSuffix(HTAtom *rep,
			 const char *enc)
d735 1
a735 2
    HTSuffix *suff;

d737 1
a737 1
    HTSuffix *first_found = NULL;
d743 1
a743 1
#define NO_INIT			/* don't init anymore since I do it in Lynx at startup */
d752 1
a752 1
	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
d755 3
a757 3
	/*  Don't return a suffix whose first char is a dot, and which
	   has more dots or asterisks after that, for
	   these systems - kw */
d768 3
a770 2
		 * If length of suffix (including dot) is 4 or smaller, return
		 * this one even if we found a longer one earlier - kw
d774 1
a774 1
		first_found = suff;	/* remember this one */
d777 1
a777 1
	    return suff->suffix;	/* OK -- found */
d785 1
a785 1
    return "";			/* Dunno */
d789 14
a802 13
 *	-------------------------------------
 *
 *	This version will return the representation and also set
 *	a variable for the encoding.
 *
 *	Encoding may be a unity encoding (binary, 8bit, etc.) or
 *	a content-coding like gzip, compress.
 *
 *	It will handle for example  x.txt, x.txt,Z, x.Z
 */
HTFormat HTFileFormat(const char *filename,
		      HTAtom **pencoding,
		      const char **pdesc)
d804 1
a804 1
    HTSuffix *suff;
a807 1

d821 1
d824 4
a827 3
     * Trim at semicolon if a version number was included, so it doesn't
     * interfere with the code for getting the MIME type.  - FM
     */
d836 1
a836 1
    lf = strlen(filename);
d840 1
a840 2

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
a843 1

d853 1
a853 1
		return suff->rep;	/* OK -- found */
d855 1
a855 1
	    for (j = 0; j < n; j++) {	/* Got encoding, need representation */
d857 1
a857 2

		suff = (HTSuffix *) HTList_objectAt(HTSuffixes, j);
d859 2
a860 3
		if ((ls + ls2 <= lf) &&
		    !strncasecomp(suff->suffix,
				  filename + lf - ls - ls2, ls2)) {
d883 2
a884 2
	(unknown_suffix.rep ? &unknown_suffix : &no_suffix)
	: &no_suffix;
d887 2
a888 2
     * Set default encoding unless found with suffix already.
     */
d891 1
a891 1
	    : HTAtom_for("binary");
d900 11
a910 10
 *	-------------------------------------------------------
 *
 *	This checks the format associated with an anchor for
 *	an extended MIME Content-Type, and if a charset is
 *	indicated, sets Lynx up for proper handling in relation
 *	to the currently selected character set. - FM
 */
HTFormat HTCharsetFormat(HTFormat format,
			 HTParentAnchor *anchor,
			 int default_LYhndl)
d922 1
a922 1
		format->name));
d926 1
a926 1
	StrAllocCopy(cp3, cp2);	/* copy to mutilate more */
d928 1
a928 1
			 *cp4 != ';' && *cp4 != ':' &&
d930 1
a930 1
	    ;			/* do nothing */
d945 2
a946 2
	     * Got something but we don't recognize it.
	     */
d949 5
a953 5
		/*
		 * UCLYhndl_for_unrec not defined :-( fallback to
		 * UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
a967 1

d970 2
a971 2
		 * Try again.
		 */
d1002 21
a1022 15
	     * Cannot translate.  If according to some heuristic the given
	     * charset and the current display character both are likely to be
	     * like ISO-8859 in structure, pretend we have some kind of match.
	     */
	    BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
					 isdigit(UCH(cp4[9])));
	    BOOL given_is_8859like = (BOOL) (given_is_8859 ||
					     !strncmp(cp4, "windows-", 8) ||
					     !strncmp(cp4, "cp12", 4) ||
					     !strncmp(cp4, "cp-12", 5));
	    BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
						      (strstr(LYchar_set_names[current_char_set],
							      "ISO-8859") ||
						       strstr(LYchar_set_names[current_char_set],
							      "windows-")));
d1044 4
a1047 3
	 * No charset parameter is present.  Ignore all other parameters, as we
	 * do when charset is present.  - FM
	 */
d1054 2
a1055 2
     * Set up defaults, if needed.  - FM
     */
d1062 3
a1064 3
			     UCT_STAGE_PARSER,
			     UCT_STAGE_MIME,
			     -1);
d1069 2
d1072 35
a1106 34
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
void LYGetFileInfo(const char *filename,
		   HTParentAnchor **pfile_anchor,
		   HTFormat *pformat,
		   HTAtom **pencoding,
		   const char **pdesc,
		   const char **pcharset,
		   int *pfile_cs)
{
    char *Afn;
    char *Aname = NULL;
    HTFormat format;
    HTAtom *myEnc = NULL;
    HTParentAnchor *file_anchor;
    const char *file_csname;
    int file_cs;
d1108 38
a1145 18
    /*
     * Convert filename to URL.  Note that it is always supposed to be a
     * filename, not maybe-filename-maybe-URL, so we don't use
     * LYFillLocalFileURL and LYEnsureAbsoluteURL.  - kw
     */
    Afn = HTEscape(filename, URL_PATH);
    LYLocalFileToURL(&Aname, Afn);
    file_anchor = HTAnchor_findSimpleAddress(Aname);

    file_csname = file_anchor->charset;
    format = HTFileFormat(filename, &myEnc, pdesc);
    format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
    file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
    if (!file_csname) {
	if (file_cs >= 0)
	    file_csname = LYCharSet_UC[file_cs].MIMEname;
	else
	    file_csname = "display character set";
a1146 21
    CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	    filename,
	    ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
	     *HTAtom_name(format) == 'a' ? "n" : ""),
	    myEnc ? HTAtom_name(myEnc) : "",
	    HTAtom_name(format),
	    file_csname,
	    file_cs));
    FREE(Afn);
    FREE(Aname);
    if (pfile_anchor)
	*pfile_anchor = file_anchor;
    if (pformat)
	*pformat = format;
    if (pencoding)
	*pencoding = myEnc;
    if (pcharset)
	*pcharset = file_csname;
    if (pfile_cs)
	*pfile_cs = file_cs;
}
d1149 5
a1153 4
 *	-------------------------------
 *
 */
float HTFileValue(const char *filename)
d1155 1
a1155 1
    HTSuffix *suff;
d1167 1
a1167 2

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
d1169 1
a1169 1
	if ((ls <= lf) && 0 == strcmp(suff->suffix, filename + lf - ls)) {
d1171 2
a1172 2
		    filename, suff->quality));
	    return suff->quality;	/* OK -- found */
d1175 1
a1175 1
    return (float) 0.3;		/* Dunno! */
d1179 7
a1185 6
 *  Determine compression type from file name, by looking at its suffix.
 *  Sets as side-effect a pointer to the "dot" that begins the suffix.
 */
CompressFileType HTCompressFileType(char *filename,
				    char *dots,
				    char **suffix)
d1192 2
a1193 2
	&& !strcasecomp((ftype - 3), "bz2")
	&& strchr(dots, ftype[-4]) != 0) {
d1197 2
a1198 2
	       && !strcasecomp((ftype - 2), "gz")
	       && strchr(dots, ftype[-3]) != 0) {
d1202 2
a1203 2
	       && !strcmp((ftype - 1), "Z")
	       && strchr(dots, ftype[-2]) != 0) {
d1210 1
a1210 1
	    filename, result, *suffix));
d1215 11
a1225 10
 *	---------------------------------
 *
 *  On exit:
 *	Returns YES if file can be accessed and can be written to.
 *
 *  Bugs:
 *	1.	No code for non-unix systems.
 *	2.	Isn't there a quicker way?
 */
BOOL HTEditable(const char *filename)
d1229 2
a1230 2
    uid_t myUid;
    int ngroups;		/* The number of groups  */
d1232 1
a1232 1
    int i;
d1234 2
a1235 2
    if (stat(filename, &fileStatus))	/* Get details of filename */
	return NO;		/* Can't even access file! */
d1238 1
a1238 1
    myUid = geteuid();		/* Get my user identifier */
a1241 1

d1243 6
a1248 6
		"File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",
		(unsigned int) fileStatus.st_mode,
		(int) fileStatus.st_uid,
		(int) fileStatus.st_gid,
		(int) myUid,
		(int) ngroups);
d1254 1
a1254 1
    if (fileStatus.st_mode & 0002)	/* I can write anyway? */
d1257 2
a1258 2
    if ((fileStatus.st_mode & 0200)	/* I can write my own file? */
	&&(fileStatus.st_uid == myUid))
d1261 1
a1261 1
    if (fileStatus.st_mode & 0020)	/* Group I am in can write? */
d1270 1
a1270 1
    return NO;			/* If no excuse, can't do */
d1274 7
a1280 6
 *	-------------------
 *
 *	The stream must be used for writing back the file.
 *	@@@@@@ no backup done
 */
HTStream *HTFileSaveStream(HTParentAnchor *anchor)
d1282 3
a1284 3
    const char *addr = anchor->address;
    char *localname = HTLocalName(addr);
    FILE *fp = fopen(localname, BIN_W);
d1294 10
a1303 8
 *	---------------------------
 */
void HTDirEntry(HTStructured * target, const char *tail,
		const char *entry)
{
    char *relative = NULL;
    char *stripped = NULL;
    char *escaped = NULL;
d1321 2
a1322 2
	 * Handle extra slash at end of path.
	 */
d1326 2
a1327 2
	 * If empty tail, gives absolute ref below.
	 */
d1330 3
a1332 3
		   tail,
		   (*escaped != '\0' ? "/" : ""),
		   escaped);
d1341 21
a1361 19
 *	------------------------------
 *
 *    This gives the TITLE and H1 header, and also a link
 *    to the parent directory if appropriate.
 *
 *  On exit:
 *	Returns TRUE if an "Up to <parent>" link was not created
 *	for a readable local directory because LONG_LIST is defined
 *	and NO_PARENT_DIR_REFERENCE is not defined, so that the
 *	calling function should use LYListFmtParse() to create a link
 *	to the parent directory.  Otherwise, it returns FALSE. - FM
 */
BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
		 BOOL tildeIsTop)
{
    const char *logical = anchor->address;
    char *path = HTParse(logical, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *current;
    char *cp = NULL;
a1363 1

d1366 2
a1367 2
		       && !strncasecomp(logical, "file://localhost/", 17)
		       && LYIsDosDrive(logical + 17));
a1368 1

d1374 3
a1376 3
     * Check tildeIsTop for treating home directory as Welcome (assume the
     * tilde is not followed by a username).  - FM
     */
d1389 2
a1390 2
     * Trim out the ;type= parameter, if present.  - FM
     */
d1392 4
a1395 4
	if (!strncasecomp((cp + 1), "type=", 5)) {
	    if (TOUPPER(*(cp + 6)) == 'D' ||
		TOUPPER(*(cp + 6)) == 'A' ||
		TOUPPER(*(cp + 6)) == 'I')
d1400 1
a1400 1
    current = LYPathLeaf(path);	/* last part or "" */
d1403 1
a1403 1
	char *printable = NULL;
d1406 12
a1417 11
	printable = HTURLPath_toFile(((!strncasecomp(path, "/%2F", 4))	/* "//" ? */
				      ? (path + 1)
				      : path),
				     TRUE,
				     is_remote);
	if (0 == strncasecomp(printable, "/vmsysu:", 8) ||
	    0 == strncasecomp(printable, "/anonymou.", 10)) {
	    StrAllocCopy(cp, (printable + 1));
	    StrAllocCopy(printable, cp);
	    FREE(cp);
	}
d1419 2
a1420 2
	StrAllocCopy(printable, current);
	HTUnEscape(printable);
d1423 9
a1431 9
	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(*printable ? printable : WELCOME_MSG);
	PUTS(SEGMENT_DIRECTORY);
	END(HTML_TITLE);
	PUTC('\n');
	END(HTML_HEAD);
	PUTC('\n');
d1434 5
a1438 5
	START(HTML_H2);
	PUTS(*printable ? SEGMENT_CURRENT_DIR : "");
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H2);
	PUTC('\n');
d1440 4
a1443 4
	START(HTML_H1);
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H1);
	PUTC('\n');
d1445 10
a1454 10
	if (((0 == strncasecomp(printable, "vmsysu:", 7)) &&
	     (cp = strchr(printable, '.')) != NULL &&
	     strchr(cp, '/') == NULL) ||
	    (0 == strncasecomp(printable, "anonymou.", 9) &&
	     strchr(printable, '/') == NULL)) {
	    FREE(printable);
	    FREE(path);
	    return (need_parent_link);
	}
	FREE(printable);
d1459 2
a1460 2
     * Make link back to parent directory.
     */
d1462 4
a1465 4
	&& LYIsPathSep(current[-1])
	&& current[0] != '\0') {	/* was a slash AND something else too */
	char *parent = NULL;
	char *relative = NULL;
d1468 1
a1468 1
	parent = strrchr(path, '/');	/* penultimate slash */
d1475 1
a1475 1
	    return (need_parent_link);
d1483 1
a1483 1
	    if (parent != 0 && strlen(parent) == 3) {
d1486 2
a1487 1
	} else
d1493 7
a1499 7
	     * On Unix, if it's not ftp and the directory cannot be read, don't
	     * put out a link.
	     *
	     * On VMS, this problem is dealt with internally by
	     * HTVMSBrowseDir().
	     */
	    DIR *dp = NULL;
d1503 8
a1510 7
		 * We need an absolute file path for the opendir.  We also need
		 * to unescape for this test.  Don't worry about %2F now, they
		 * presumably have been dealt with above, and shouldn't appear
		 * for local files anyway...  Assume OS / filesystem will just
		 * ignore superfluous slashes.  - KW
		 */
		char *fullparentpath = NULL;
d1513 2
a1514 2
		 * Path has been shortened above.
		 */
d1518 6
a1523 6
		 * Guard against weirdness.
		 */
		if (0 == strcmp(current, "..")) {
		    StrAllocCat(fullparentpath, "/../..");
		} else if (0 == strcmp(current, ".")) {
		    StrAllocCat(fullparentpath, "/..");
d1531 1
a1531 1
		    return (need_parent_link);
d1539 1
a1539 1
		return (need_parent_link);
d1549 2
a1550 2
	    if ((0 == strcmp(current, ".")) ||
		(0 == strcmp(current, ".."))) {
d1552 3
a1554 3
		 * Should not happen, but if it does, at least avoid giving
		 * misleading info.  - KW
		 */
d1557 1
a1557 2
		char *printable = NULL;

d1572 1
a1572 1
    return (need_parent_link);
d1577 5
a1581 5
 *	-----------------
 *
 *  If a README file exists, then it is inserted into the document here.
 */
static void do_readme(HTStructured * target, const char *localname)
d1583 2
a1584 2
    FILE *fp;
    char *readme_file_name = NULL;
d1594 1
a1594 1
	targetClass = *target->isa;	/* (Can't init agregate in K&R) */
d1597 1
a1597 1
	    PUTC((char) ch);
d1612 1
a1612 1
static char *file_type(char *path)
a1614 1

d1624 1
a1624 1
static int dired_cmp(void *a, void *b)
d1626 2
a1627 2
    DIRED *p = (DIRED *) a;
    DIRED *q = (DIRED *) b;
a1628 1

d1668 6
a1673 4
static int print_local_dir(DIR *dp, char *localname,
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
d1677 1
a1677 1
    STRUCT_DIRENT *dirbuf;
d1681 1
a1681 1
    char *tmpfilename = NULL;
d1691 1
a1691 1
    if (!strcmp(pathname, "/")) {
d1693 3
a1695 3
	 * Root path.
	 */
	StrAllocCopy(tail, "/foo/..");
d1697 1
a1697 1
	char *p = strrchr(pathname, '/');	/* find last slash */
d1701 4
a1704 4
	     * This probably should not happen, but be prepared if it does.  -
	     * KW
	     */
	    StrAllocCopy(tail, "/foo/..");
d1707 2
a1708 2
	     * Take slash off the beginning.
	     */
d1722 1
a1722 1
    targetClass = *target->isa;	/* Copy routine entry points */
d1728 7
a1734 5
     * The need_parent_link flag will be set if an "Up to <parent>" link was
     * not created for a readable parent in HTDirTitles() because LONG_LIST is
     * defined and NO_PARENT_DIR_REFERENCE is not defined so that need we to
     * create the link via an LYListFmtParse() call.  - FM
     */
d1747 2
a1748 2
	HTBTree *bt = HTBTree_new(dired_cmp);
	int num_of_entries = 0;	/* lines counter */
d1750 2
a1751 2
	_HTProgress(READING_DIRECTORY);
	status = HT_LOADED;	/* assume we don't get interrupted */
d1754 2
a1755 2
	     * While there are directory entries to be read...
	     */
d1761 2
a1762 2
		 * If the entry is not being used, skip it.
		 */
d1766 6
a1771 5
	     * Skip self, parent if handled in HTDirTitles() or if
	     * NO_PARENT_DIR_REFERENCE is not defined, and any dot files if
	     * no_dotfiles is set or show_dotfiles is not set.  - FM
	     */
	    if (!strcmp(dirbuf->d_name, ".") /* self       */ ||
d1781 2
a1782 2
	     * If filename is not root directory, add trailing separator.
	     */
d1786 1
a1786 1
	    data = (DIRED *) malloc(sizeof(DIRED) + strlen(dirbuf->d_name) + 4);
d1790 1
a1790 1
	    LYTrimPathSep(tmpfilename);
d1822 2
a1823 2
	     * Sort dirname in the tree bt.
	     */
d1828 1
a1828 1
	    if (num_of_entries % (partial_threshold > 0 ?
d1830 1
a1830 1
		== 0) {
d1839 1
a1839 1
	}			/* end while directory entries left to read */
d1842 1
a1842 1
	    _HTProgress(OPERATION_OK);
d1846 1
d1848 2
a1849 2
	 * Run through tree printing out in order.
	 */
d1851 3
a1853 4
	    HTBTElement *next_element = HTBTree_next(bt, NULL);

	    /* pick up the first element of the list */
	    int num_of_entries_output = 0;	/* lines counter */
d1856 3
a1858 4

	    /* I for initial (.. file),
	       D for directory file,
	       F for file */
d1869 1
a1869 1
		if (num_of_entries_output % HTMAX(display_lines, 10) == 0) {
d1871 1
a1871 1
			_HTProgress(TRANSFER_INTERRUPTED);
d1879 2
a1880 2
		 * If filename is not root directory.
		 */
d1883 1
a1883 1
		entry = (DIRED *) (HTBTree_object(next_element));
d1885 3
a1887 2
		 * Append the current entry's filename to the path.
		 */
d1891 2
a1892 2
		 * Output the directory entry.
		 */
d1911 2
a1912 2
			    (char) (DIRED_BLOK(HTBTree_object(next_element))
				    == 'D' ? 'D' : 'F');
d1915 5
a1919 5
			    START(HTML_EM);
			    PUTS(state == 'D'
				 ? LABEL_SUBDIRECTORIES
				 : LABEL_FILES);
			    END(HTML_EM);
d1937 2
a1938 2
			    (char) (DIRED_BLOK(HTBTree_object(next_element))
				    == 'D' ? 'D' : 'F');
d1942 2
a1943 2
			     ? LABEL_SUBDIRECTORIES
			     : LABEL_FILES);
d1957 1
d1969 2
a1970 2
		/* pick up the next element of the list;
		   if none, return NULL */
d1982 1
a1982 1
			_HTProgress(TRANSFER_INTERRUPTED);
d1990 1
a1990 1
	    }			/* end while next_element */
d2002 1
a2002 1
	}			/* end printing out the tree in order */
d2017 1
a2017 1
    return status;		/* document loaded, maybe partial */
d2021 1
d2023 3
a2025 2
int HTStat(const char *filename,
	   struct stat *data)
d2030 1
a2030 1
    if (len != 0 && LYIsPathSep(filename[len - 1])) {
a2031 1

d2043 1
a2043 1
	    && access(filename, 0) == 0) {
d2054 20
a2073 19
 *	----------------
 *
 *  On entry:
 *	addr		must point to the fully qualified hypertext reference.
 *			This is the physical address of the file
 *
 *  On exit:
 *	returns		<0		Error has occurred.
 *			HTLOADED	OK
 *
 */
int HTLoadFile(const char *addr,
	       HTParentAnchor *anchor,
	       HTFormat format_out,
	       HTStream *sink)
{
    char *filename = NULL;
    char *acc_method = NULL;
    char *ftp_newhost;
d2075 4
a2078 4
    char *nodename = NULL;
    char *newname = NULL;	/* Simplified name of file */
    HTAtom *encoding;		/* @@@@ not used yet */
    HTAtom *myEncoding = NULL;	/* enc of this file, may be gzip etc. */
a2080 1

d2096 2
a2097 2
     * Reduce the filename to a basic form (hopefully unique!).
     */
d2099 2
a2100 2
    filename = HTParse(newname, "", PARSE_PATH | PARSE_PUNCTUATION);
    nodename = HTParse(newname, "", PARSE_HOST);
d2103 2
a2104 2
     * If access is ftp, or file is on another host, invoke ftp now.
     */
d2107 2
a2108 2
	(!LYSameHostname("localhost", nodename) &&
	 !LYSameHostname(nodename, HTHostName()))) {
d2121 2
a2122 2
	if (ftp_passive == ftp_local_passive) {
	    if ((status >= 400) || (status < 0)) {
d2141 2
a2142 2
     * Determine the format and encoding mapped to any suffix.
     */
d2145 3
a2147 3
	 * If content_type and content_encoding are BOTH already set in the
	 * anchor object, we believe it and don't try to derive format and
	 * encoding from the filename.  - kw
d2161 7
a2167 7
	/*
	 * Check the format for an extended MIME charset value, and act on it
	 * if present.  Otherwise, assume what is indicated by the last
	 * parameter (fallback will effectively be UCLYhndl_for_unspec, by
	 * default ISO-8859-1).  - kw
	 */
	format = HTCharsetFormat(format, anchor, default_UCLYhndl);
d2172 5
a2176 5
     * Check to see if the 'filename' is in fact a directory.  If it is create
     * a new hypertext object containing a list of files and subdirectories
     * contained in the directory.  All of these are links to the directories
     * or files listed.
     */
d2188 1
a2188 1
		char *enable_file_name = NULL;
d2206 3
a2208 3
     * Assume that the file is in Unix-style syntax if it contains a '/' after
     * the leading one.  @@@@
     */
d2210 3
a2212 4
	FILE *fp;
	char *vmsname = strchr(filename + 1, '/') ?
	HTVMS_name(nodename, filename) : filename + 1;

d2216 2
a2217 2
	 * If the file wasn't VMS syntax, then perhaps it is Ultrix.
	 */
d2219 1
a2219 2
	    char *ultrixname = 0;

d2225 1
a2225 1
			ultrixname));
d2233 2
a2234 3
		HTAtom *put = HTAtom_for("PUT");
		HTList *methods = HTAnchor_methods(anchor);

d2240 4
a2243 3
	     * Trim vmsname at semicolon if a version number was included, so
	     * it doesn't interfere with the check for a compressed file.  - FM
	     */
d2247 2
a2248 2
	     * Fake a Content-Encoding for compressed files.  - FM
	     */
d2251 3
a2253 3
		 * We already know from the call to HTFileFormat above that
		 * this is a compressed file, no need to look at the filename
		 * again.  - kw
d2265 1
a2265 1
			    vmsname, (void *) gzfp));
d2268 1
a2268 1
#endif /* USE_ZLIB */
d2270 3
a2272 3
		    if (strcmp(format_out->name, "www/download") != 0 &&
			(!strcmp(HTAtom_name(myEncoding), "bzip2") ||
			 !strcmp(HTAtom_name(myEncoding), "x-bzip2"))) {
d2279 1
a2279 1
			    vmsname, (void *) bzfp));
d2282 1
a2282 1
#endif /* USE_BZLIB */
d2319 1
a2319 1
				vmsname, (void *) gzfp));
d2322 1
a2322 1
#else /* USE_ZLIB */
d2324 1
a2324 1
#endif /* USE_ZLIB */
d2336 1
a2336 1
				vmsname, (void *) bzfp));
d2339 1
a2339 1
#else /* USE_BZLIB */
d2341 1
a2341 1
#endif /* USE_BZLIB */
d2374 1
a2374 2
		    char *sugfname = NULL;

d2378 3
a2380 4
			char *anchor_path = HTParse(anchor->address, "",
						    PARSE_PATH + PARSE_PUNCTUATION);
			char *lastslash;

d2414 1
a2414 1
	}			/* If successful open */
d2423 5
a2427 5
     * For unix, we try to translate the name into the name of a transparently
     * mounted file.
     *
     * Not allowed in secure (HTClientHost) situations.  TBL 921019
     */
d2429 1
a2429 1
    /*  Need protection here for telnet server but not httpd server. */
d2432 1
a2432 1
	char *localname = HTLocalName(addr);
d2437 5
a2441 5
	 * Multiformat handling.
	 *
	 * If needed, scan directory to find a good file.  Bug:  We don't stat
	 * the file to find the length.
	 */
d2448 2
a2449 2
	    STRUCT_DIRENT *dirbuf;
	    float best = (float) NO_VALUE_FOUND;	/* So far best is bad */
d2451 2
a2452 2
	    HTAtom *best_enc = NULL;
	    char *best_name = NULL;	/* Best dir entry so far */
d2460 2
a2461 2
		*base++ = '\0';	/* Just got directory name */
		baselen = strlen(base) - strlen(MULTI_SUFFIX);
d2474 2
a2475 2
		 * While there are directory entries to be read...
		 */
d2480 1
a2480 1
		if ((int) strlen(dirbuf->d_name) > baselen &&	/* Match? */
d2482 1
a2482 1
		    HTAtom *enc;
d2486 2
a2487 3
					       filevalue,
					       0L /* @@@@@@@@@@@@ */ );

d2490 2
a2491 3
			CompressFileType cft =
			HTCompressFileType(dirbuf->d_name, ".", &dot);
			char *cp = NULL;
d2532 3
a2534 4
			CTRACE((tfp,
				"HTLoadFile: value of presenting %s is %f\n",
				HTAtom_name(rep), value));
			if (value > best) {
d2540 4
a2543 4
		    }		/* if best so far */
		}
		/* if match */
	    }			/* end while directory entries left to read */
d2549 1
a2549 1
		base[-1] = '/';	/* Restore directory name */
d2553 1
a2553 1
	    } else {		/* If not found suitable file */
d2558 3
a2560 3
	    /*NOTREACHED */
	}
	/* if multi suffix */
d2562 8
a2569 8
	 * Check to see if the 'localname' is in fact a directory.  If it is
	 * create a new hypertext object containing a list of files and
	 * subdirectories contained in the directory.  All of these are links
	 * to the directories or files listed.  NB This assumes the existence
	 * of a type 'STRUCT_DIRENT', which will hold the directory entry, and
	 * a type 'DIR' which is used to point to the current directory being
	 * read.
	 */
d2574 1
a2574 1
	if (HTStat(localname, &dir_info) == -1)		/* get file information */
d2576 1
a2576 1
	    /* if can't read file information */
d2579 1
a2579 1
	} else {		/* Stat was OK */
d2583 2
a2584 2
		 * If localname is a directory.
		 */
d2591 4
a2594 3
		 * Check directory access.  Selective access means only those
		 * directories containing a marker file can be browsed.
		 */
d2602 1
a2602 1
		    char *enable_file_name = NULL;
d2622 2
a2623 2
		 * Directory access is allowed and possible.
		 */
d2626 1
a2626 1
					 anchor, format_out, sink);
d2632 2
a2633 2
	    }
	    /* end if localname is a directory */
d2641 1
a2641 1
	}			/* end if file stat worked */
d2648 1
a2648 1
	    FILE *fp = fopen(localname, (bin ? BIN_R : "r"));
d2651 1
a2651 1
		    localname, (void *) fp));
d2654 2
a2655 3
		    HTAtom *put = HTAtom_for("PUT");
		    HTList *methods = HTAnchor_methods(anchor);

d2661 2
a2662 2
		 * Fake a Content-Encoding for compressed files.  - FM
		 */
d2665 3
a2667 3
		     * We already know from the call to HTFileFormat above that
		     * this is a compressed file, no need to look at the
		     * filename again.  - kw
d2677 1
a2677 1
				localname, (void *) gzfp));
d2680 1
a2680 1
#endif /* USE_ZLIB */
d2682 3
a2684 3
			if (strcmp(format_out->name, "www/download") != 0 &&
			    (!strcmp(HTAtom_name(myEncoding), "bzip2") ||
			     !strcmp(HTAtom_name(myEncoding), "x-bzip2"))) {
d2689 1
a2689 1
				localname, (void *) bzfp));
d2692 1
a2692 1
#endif /* USE_BZLIB */
d2725 2
a2726 3
			    CTRACE((tfp,
				    "HTLoadFile: gzopen of `%s' gives %p\n",
				    localname, (void *) gzfp));
d2729 1
a2729 1
#else /* USE_ZLIB */
d2731 1
a2731 1
#endif /* USE_ZLIB */
d2740 2
a2741 3
			    CTRACE((tfp,
				    "HTLoadFile: bzopen of `%s' gives %p\n",
				    localname, (void *) bzfp));
d2744 1
a2744 1
#else /* USE_BZLIB */
d2746 1
a2746 1
#endif /* USE_BZLIB */
d2776 1
a2776 2
			char *sugfname = NULL;

d2780 3
a2782 4
			    char *anchor_path = HTParse(anchor->address, "",
							PARSE_PATH + PARSE_PUNCTUATION);
			    char *lastslash;

d2816 1
a2816 1
	    }			/* If successful open */
d2818 2
a2819 2
	}			/* scope of fp */
    }				/* local unix file system */
d2825 2
a2826 2
     * Now, as transparently mounted access has failed, we try FTP.
     */
d2829 2
a2830 2
	 * Deal with case-sensitivity differences on VMS versus Unix.
	 */
d2854 2
a2855 2
     * All attempts have failed.
     */
d2868 2
a2869 1
const char *HTGetProgramPath(ProgramPaths code)
a2871 1

d2881 3
a2883 1
void HTSetProgramPath(ProgramPaths code, const char *path)
d2893 1
a2893 1
void HTInitProgramPaths(void)
d3012 1
a3012 1
	    free((char *) test);
d3019 2
a3020 2
 *	Protocol descriptors
 */
d3023 1
a3023 1
GLOBALDEF(HTProtocol, HTFTP, _HTFILE_C_1_INIT);
d3025 1
a3025 1
GLOBALDEF(HTProtocol, HTFile, _HTFILE_C_2_INIT);
d3027 2
a3028 4
GLOBALDEF HTProtocol HTFTP =
{"ftp", HTLoadFile, 0};
GLOBALDEF HTProtocol HTFile =
{"file", HTLoadFile, HTFileSaveStream};
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a1698 5
    struct stat *actual_info;

#ifdef S_IFLNK
    struct stat link_info;
#endif
d1799 1
a1799 2
		status = HT_PARTIAL_CONTENT;
		break;
d1802 2
a1803 16

	    actual_info = &(data->file_info);
#ifdef S_IFLNK
	    if (lstat(tmpfilename, actual_info) < 0) {
		actual_info->st_mode = 0;
	    } else {
		if (S_ISLNK(actual_info->st_mode)) {
		    actual_info = &link_info;
		    if (stat(tmpfilename, actual_info) < 0)
			actual_info->st_mode = 0;
		}
	    }
#else
	    if (stat(tmpfilename, actual_info) < 0)
		actual_info->st_mode = 0;
#endif
d1807 1
a1807 1
	    if (S_ISDIR(actual_info->st_mode)) {
d1814 1
a1814 1
	    if (S_ISDIR(actual_info->st_mode)) {
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a814 23
/*
 * Trim version from VMS filenames to avoid confusing comparisons.
 */
#ifdef VMS
static const char *VMS_trim_version(const char *filename)
{
    const char *result = filename;
    char *version = strchr(filename, ';');

    if (version != 0) {
	static char *stripped;

	StrAllocCopy(stripped, filename);
	stripped[(const char *) version - filename] = '\0';
	result = (const char *) stripped;
    }
    return result;
}
#define VMS_DEL_VERSION(name) name = VMS_trim_version(name)
#else
#define VMS_DEL_VERSION(name)	/* nothing */
#endif

d835 3
a837 1
    VMS_DEL_VERSION(filename);
d848 9
d876 4
d897 4
d918 7
a924 5
    if (pencoding && !*pencoding) {
	*pencoding = (suff->encoding
		      ? suff->encoding
		      : HTAtom_for("binary"));
    }
a1209 2
    VMS_DEL_VERSION(filename);

a1219 5
    } else if ((len > 3)
	       && !strcasecomp((ftype - 2), "zz")
	       && strchr(dots, ftype[-3]) != 0) {
	result = cftDeflate;
	ftype -= 3;
a1227 1

a1232 30
/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.  RFC 2068 (and cut/paste into RFC 2616) lists these:
 *	gzip
 *	compress
 *	deflate
 * as well as "identity" (but that does nothing).
 */
CompressFileType HTEncodingToCompressType(const char *coding)
{
    CompressFileType result = cftNone;

    if (coding == 0) {
	result = cftNone;
    } else if (!strcasecomp(coding, "gzip") ||
	       !strcasecomp(coding, "x-gzip")) {
	result = cftGzip;
    } else if (!strcasecomp(coding, "compress") ||
	       !strcasecomp(coding, "x-compress")) {
	result = cftCompress;
    } else if (!strcasecomp(coding, "bzip2") ||
	       !strcasecomp(coding, "x-bzip2")) {
	result = cftBzip2;
    } else if (!strcasecomp(coding, "deflate") ||
	       !strcasecomp(coding, "x-deflate")) {
	result = cftDeflate;
    }
    return result;
}

a2081 263
#ifdef VMS
#define FOPEN_MODE(bin) "r", "shr=put", "shr=upd"
#define DOT_STRING "._-"	/* FIXME: should we check if suffix is after ']' or ':' ? */
#else
#define FOPEN_MODE(bin) (bin ? BIN_R : "r")
#define DOT_STRING "."
#endif

static int decompressAndParse(HTParentAnchor *anchor,
			      HTFormat format_out,
			      HTStream *sink,
			      char *nodename GCC_UNUSED,
			      char *filename,
			      HTAtom *myEncoding,
			      HTFormat format,
			      int *statusp)
{
    HTAtom *encoding = 0;

#ifdef USE_ZLIB
    FILE *zzfp = 0;
    gzFile gzfp = 0;
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
    BZFILE *bzfp = 0;
#endif /* USE_ZLIB */
#if defined(USE_ZLIB) || defined(USE_BZLIB)
    CompressFileType internal_decompress = cftNone;
    BOOL failed_decompress = NO;
#endif
    char *dot = 0;
    char *localname = filename;
    int bin;
    FILE *fp;

#ifdef VMS
    /*
     * Assume that the file is in Unix-style syntax if it contains a '/' after
     * the leading one.  @@@@
     */
    localname = (strchr(localname + 1, '/')
		 ? HTVMS_name(nodename, localname)
		 : localname + 1);
#endif /* VMS */

    bin = HTCompressFileType(filename, ".", &dot) != cftNone;
    fp = fopen(localname, FOPEN_MODE(bin));

#ifdef VMS
    /*
     * If the file wasn't VMS syntax, then perhaps it is Ultrix.
     */
    if (!fp) {
	char *ultrixname = 0;

	CTRACE((tfp, "HTLoadFile: Can't open as %s\n", localname));
	HTSprintf0(&ultrixname, "%s::\"%s\"", nodename, filename);
	fp = fopen(ultrixname, FOPEN_MODE(bin));
	if (!fp) {
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", ultrixname));
	}
	FREE(ultrixname);
    }
#endif /* VMS */
    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n", localname, fp));
    if (fp) {			/* Good! */
	if (HTEditable(localname)) {
	    HTAtom *put = HTAtom_for("PUT");
	    HTList *methods = HTAnchor_methods(anchor);

	    if (HTList_indexOf(methods, put) == (-1)) {
		HTList_addObject(methods, put);
	    }
	}
	/*
	 * Fake a Content-Encoding for compressed files.  - FM
	 */
	if (!IsUnityEnc(myEncoding)) {
	    /*
	     * We already know from the call to HTFileFormat that
	     * this is a compressed file, no need to look at the filename
	     * again.  - kw
	     */
	    CompressFileType method = HTEncodingToCompressType(HTAtom_name(myEncoding));

#define isDOWNLOAD(m) (strcmp(format_out->name, "www/download") && (method == m))
#ifdef USE_ZLIB
	    if (isDOWNLOAD(cftGzip)) {
		fclose(fp);
		gzfp = gzopen(localname, BIN_R);

		CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			localname, gzfp));
		internal_decompress = cftGzip;
	    } else if (isDOWNLOAD(cftDeflate)) {
		zzfp = fp;
		fp = 0;

		CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			localname, zzfp));
		internal_decompress = cftDeflate;
	    } else
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
	    if (isDOWNLOAD(cftBzip2)) {
		fclose(fp);
		bzfp = BZ2_bzopen(localname, BIN_R);

		CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			localname, bzfp));
		internal_decompress = cftBzip2;
	    } else
#endif /* USE_BZLIB */
	    {
		StrAllocCopy(anchor->content_type, format->name);
		StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
		format = HTAtom_for("www/compressed");
	    }
	} else {
	    CompressFileType cft = HTCompressFileType(localname, DOT_STRING, &dot);

	    if (cft != cftNone) {
		char *cp = NULL;

		StrAllocCopy(cp, localname);
		cp[dot - localname] = '\0';
		format = HTFileFormat(cp, &encoding, NULL);
		FREE(cp);
		format = HTCharsetFormat(format, anchor,
					 UCLYhndl_HTFile_for_unspec);
		StrAllocCopy(anchor->content_type, format->name);
	    }

	    switch (cft) {
	    case cftCompress:
		StrAllocCopy(anchor->content_encoding, "x-compress");
		format = HTAtom_for("www/compressed");
		break;
	    case cftDeflate:
		StrAllocCopy(anchor->content_encoding, "x-deflate");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    zzfp = fp;
		    fp = 0;

		    CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			    localname, zzfp));
		    internal_decompress = cftDeflate;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftGzip:
		StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    fclose(fp);
		    gzfp = gzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			    localname, gzfp));
		    internal_decompress = cftGzip;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftBzip2:
		StrAllocCopy(anchor->content_encoding, "x-bzip2");
#ifdef USE_BZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    fclose(fp);
		    bzfp = BZ2_bzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			    localname, bzfp));
		    internal_decompress = cftBzip2;
		}
#else /* USE_BZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_BZLIB */
		break;
	    case cftNone:
		break;
	    }
	}
#if defined(USE_ZLIB) || defined(USE_BZLIB)
	if (internal_decompress != cftNone) {
	    switch (internal_decompress) {
#ifdef USE_ZLIB
	    case cftDeflate:
		failed_decompress = (zzfp == 0);
		break;
	    case cftCompress:
	    case cftGzip:
		failed_decompress = (gzfp == 0);
		break;
#endif
#ifdef USE_BZLIB
	    case cftBzip2:
		failed_decompress = (bzfp == 0);
		break;
#endif
	    default:
		failed_decompress = YES;
		break;
	    }
	    if (failed_decompress) {
		*statusp = HTLoadError(NULL,
				       -(HT_ERROR),
				       FAILED_OPEN_COMPRESSED_FILE);
	    } else {
		char *sugfname = NULL;

		if (anchor->SugFname) {
		    StrAllocCopy(sugfname, anchor->SugFname);
		} else {
		    char *anchor_path = HTParse(anchor->address, "",
						PARSE_PATH + PARSE_PUNCTUATION);
		    char *lastslash;

		    HTUnEscape(anchor_path);
		    lastslash = strrchr(anchor_path, '/');
		    if (lastslash)
			StrAllocCopy(sugfname, lastslash + 1);
		    FREE(anchor_path);
		}
		FREE(anchor->content_encoding);
		if (sugfname && *sugfname)
		    HTCheckFnameForCompression(&sugfname, anchor,
					       TRUE);
		if (sugfname && *sugfname)
		    StrAllocCopy(anchor->SugFname, sugfname);
		FREE(sugfname);
#ifdef USE_BZLIB
		if (bzfp)
		    *statusp = HTParseBzFile(format, format_out,
					     anchor,
					     bzfp, sink);
#endif
#ifdef USE_ZLIB
		if (gzfp)
		    *statusp = HTParseGzFile(format, format_out,
					     anchor,
					     gzfp, sink);
		else if (zzfp)
		    *statusp = HTParseZzFile(format, format_out,
					     anchor,
					     zzfp, sink);
#endif
	    }
	} else
#endif /* USE_ZLIB || USE_BZLIB */
	{
	    *statusp = HTParseFile(format, format_out, anchor, fp, sink);
	    fclose(fp);
	}
	return TRUE;
    }				/* If successful open */
    return FALSE;
}

d2105 1
d2113 10
d2234 214
a2447 9
    if (decompressAndParse(anchor,
			   format_out,
			   sink,
			   nodename,
			   filename,
			   myEncoding,
			   format,
			   &status)) {
	FREE(nodename);
a2448 1
	return status;
a2449 1
    FREE(filename);
a2542 3
			    case cftDeflate:
				atomname = "application/x-deflate";
				break;
d2681 176
a2856 9
	if (decompressAndParse(anchor,
			       format_out,
			       sink,
			       nodename,
			       localname,
			       myEncoding,
			       format,
			       &status)) {
	    FREE(nodename);
d2858 1
a2858 3
	    return status;
	}
	FREE(localname);
a2966 5
	    break;
#endif
#ifdef INFLATE_PATH
	case ppINFLATE:
	    path = INFLATE_PATH;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a26 1
#undef LONG_LIST
d29 1
d49 1
d124 1
d143 8
d168 2
a169 4
    } else if (*bufp && !(entry && *entry)) {
	**bufp = '\0';
    } else if (entry) {
	StrAllocCopy(*bufp, entry);
d185 1
a185 1
	StrAllocCopy(*bufp, fmt);
a205 1
#ifndef _WINDOWS
a206 1
#endif
a208 1
#ifdef S_IFLNK
a209 1
#endif
a210 9

#ifdef _WINDOWS	/* 1998/01/06 (Tue) 21:20:53 */
	static char *pbits[] = {
		"---", "--x", "-w-", "-wx",
		"r--", "r-x", "rw-", "rwx",
		0 };
#define PBIT(a, n, s)  pbits[((a) >> (n)) & 0x7]

#else
a216 1
#endif
d251 1
a251 1
		while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
a343 3
#if defined(_MSC_VER) && defined(_S_IFIFO)
			case _S_IFIFO: type = 'p'; break;
#else
a344 1
#endif
a364 4
#ifdef _WINDOWS
			sprintf(tmp, "%c%s", type,
				PBIT(st.st_mode, 6, st.st_mode & S_IRWXU));
#else
a368 1
#endif
a371 5
#ifdef _WINDOWS
		case 'o':	/* owner */
		case 'g':	/* group */
			break;
#else
a388 1
#endif
d434 1
a434 1
	double,		value)
d437 1
a437 1
    BOOL trivial_enc = (BOOL) IsUnityEncStr(encoding);
d454 1
a454 1
	    suff = typecalloc(HTSuffix);
d487 1
a487 1
    suff->quality = (float) value;
a560 44
/*	Convert filename from URL-path syntax to local path format
**	----------------------------------------------------------
**	Input name is assumed to be the URL-path of a local file
**      URL, i.e. what comes after the "file://localhost".
**      '#'-fragments to be treated as such must already be stripped.
**      If expand_all is FALSE, unescape only escaped '/'. - kw
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
PUBLIC char * HTURLPath_toFile ARGS2(
	CONST char *,	name,
	BOOL,		expand_all)
{
    char * path = NULL;
    char * result = NULL;

    StrAllocCopy(path, name);
    if (expand_all)
	HTUnEscape(path);		/* Interpret all % signs */
    else
	HTUnEscapeSome(path, "/");	/* Interpret % signs for path delims */

    CTRACE((tfp, "URLPath `%s' means path `%s'\n", name, path));
#ifdef DOSPATH
    StrAllocCopy(result, HTDOS_name(path));
#else
#ifdef __EMX__
    if (path[0] == '/'
	&& isalpha(path[1])
	&& path[2] == ':') /* pesky leading slash */
	StrAllocCopy(result, path+1);
    else
	StrAllocCopy(result, path);
    CTRACE((tfp, "EMX hack changed `%s' to `%s'\n", path, result));
#else
    StrAllocCopy(result, path);
#endif /* __EMX__ */
#endif /* DOSPATH */

    FREE(path);

    return result;
}
a570 5
/* NOTE: Don't use this function if you know that the input is a URL path
	 rather than a full URL, use HTURLPath_toFile instead.  Otherwise
	 this function will return the wrong thing for some unusual
	 paths (like ones containing "//", possibly escaped). - kw
*/
d582 1
a582 1
    if (expand_all) {
d584 1
a584 1
    } else
d591 1
a591 1
	    CTRACE((tfp, "Node `%s' means path `%s'\n", name, path));
d602 1
a602 1
	    CTRACE((tfp, "EMX hack changed `%s' to `%s'\n", path, result));
d609 1
a609 1
	    CTRACE((tfp, "Node `%s' means file `%s'\n", name, result));
d620 1
a620 6
#if defined(_WINDOWS)	/* 1997/10/16 (Thu) 20:42:51 */
	home =  (char *)Home_Dir();
#else
	home = getenv("HOME");
#endif
	if (home == 0)
a631 3
    CTRACE((tfp, "HTnameOfFile_WWW(%s,%d,%d) = %s\n",
	    name, WWW_prefix, expand_all, result));

d657 1
a657 1
    CTRACE((tfp, "File `%s'\n\tmeans node `%s'\n", name, result));
d690 1
a690 1
    trivial_enc = (BOOL) IsUnityEncStr(enc);
a804 4
			if (pencoding && IsUnityEnc(*pencoding) &&
			    *pencoding != WWW_ENC_7BIT &&
			    !IsUnityEnc(suff->encoding))
			    *pencoding = suff->encoding;
d858 2
a859 2
	CTRACE((tfp, "HTCharsetFormat: Extended MIME Content-Type is %s\n",
		    format->name));
d947 2
a948 2
		= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		   isdigit(UCH(cp4[9])));
d950 1
a950 1
		= (BOOL) (given_is_8859 ||
d955 1
a955 1
		= (BOOL) (given_is_8859like &&
d968 1
a968 1
		       isdigit(UCH(*cp1)))
a1005 79


/*	Get various pieces of meta info from file name.
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
PUBLIC void LYGetFileInfo ARGS7(
	CONST char *,		filename,
	HTParentAnchor **,	pfile_anchor,
	HTFormat *,		pformat,
	HTAtom **,		pencoding,
	CONST char**,		pdesc,
	CONST char**,		pcharset,
	int *,			pfile_cs)
{
	char *Afn;
	char *Aname = NULL;
	HTFormat format;
	HTAtom * myEnc = NULL;
	HTParentAnchor *file_anchor;
	CONST char *file_csname;
	int file_cs;

	/*
	 *  Convert filename to URL.  Note that it is always supposed to
	 *  be a filename, not maybe-filename-maybe-URL, so we don't
	 *  use LYFillLocalFileURL and LYEnsureAbsoluteURL. - kw
	 */
	Afn = HTEscape(filename, URL_PATH);
	LYLocalFileToURL(&Aname, Afn);
	file_anchor = HTAnchor_parent(HTAnchor_findSimpleAddress(Aname));

	file_csname = file_anchor->charset;
	format = HTFileFormat(filename, &myEnc, pdesc);
	format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
	file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
	if (!file_csname) {
	    if (file_cs >= 0)
		file_csname = LYCharSet_UC[file_cs].MIMEname;
	    else file_csname = "display character set";
	}
	CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	       filename,
	       ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
		*HTAtom_name(format) == 'a' ? "n" : ""),
	       myEnc ? HTAtom_name(myEnc) : "",
	       HTAtom_name(format),
	       file_csname,
	       file_cs));
	FREE(Afn);
	FREE(Aname);
	if (pfile_anchor)
	    *pfile_anchor = file_anchor;
	if (pformat)
	    *pformat = format;
	if (pencoding)
	    *pencoding = myEnc;
	if (pcharset)
	    *pcharset = file_csname;
	if (pfile_cs)
	    *pfile_cs = file_cs;
    }

d1028 2
a1029 2
	    CTRACE((tfp, "File: Value of %s is %.3f\n",
			filename, suff->quality));
d1033 1
a1033 37
    return (float)0.3;		/* Dunno! */
}

/*
**  Determine compression type from file name, by looking at its suffix.
**  Sets as side-effect a pointer to the "dot" that begins the suffix.
*/
PUBLIC CompressFileType HTCompressFileType ARGS3(
	char *,		filename,
	char *,		dots,
	char **,	suffix)
{
    CompressFileType result = cftNone;
    size_t len = strlen(filename);
    char *ftype = filename + len;

    if ((len > 4)
     && !strcasecomp((ftype - 3), "bz2")
     && strchr(dots, ftype[-4]) != 0) {
	result = cftBzip2;
	ftype -= 4;
    } else if ((len > 3)
     && !strcasecomp((ftype - 2), "gz")
     && strchr(dots, ftype[-3]) != 0) {
	result = cftGzip;
	ftype -= 3;
    } else if ((len > 2)
     && !strcmp((ftype - 1), "Z")
     && strchr(dots, ftype[-2]) != 0) {
	result = cftCompress;
	ftype -= 2;
    }

    *suffix = ftype;
    CTRACE((tfp, "HTCompressFileType(%s) returns %d:%s\n",
		 filename, result, *suffix));
    return result;
d1046 24
d1073 3
a1075 1
#ifndef NO_GROUPS
d1116 2
a1117 1
    CTRACE((tfp, "\tFile is not editable.\n"));
a1118 1
    return NO;					/* If no excuse, can't do */
d1133 1
a1133 1
    FILE* fp = fopen(localname, BIN_W);
d1196 3
a1198 3
**	and NO_PARENT_DIR_REFERENCE is not defined, so that the
**	calling function should use LYListFmtParse() to create a link
**	to the parent directory.  Otherwise, it returns FALSE. - FM
d1214 1
a1214 1
    if (strlen(logical) > 18 && logical[18] == ':') local_link = TRUE;
d1249 1
a1249 1
      printable = HTURLPath_toFile(
d1252 1
a1252 2
	    : path,
	    TRUE);
a1302 3
#ifdef DOSPATH
    if (current != path)	/* leave "/c:" alone */
#endif
d1323 2
a1324 2
	if (local_link) {
	    if (parent != 0 && strlen(parent) == 3 ) {
a1325 3
	    }
	}
	else
d1329 3
d1428 7
a1434 3
    char * readme_file_name = NULL;

    HTSprintf0(&readme_file_name, "%s/%s", localname, HT_DIR_README_FILE);
d1436 1
a1436 1
    fp = fopen(readme_file_name, "r");
d1444 2
a1445 2
	    int c = fgetc(fp);
	    if (c == EOF) break;
d1461 1
a1461 1
			PUTC((char)c);
d1464 1
a1464 1
	    PUTC((char)c);
a1491 1
    int i;
d1493 1
a1493 1
    CTRACE((tfp, "print_local_dir() started\n"));
d1532 4
a1535 2
    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
d1562 1
a1562 1
	_HTProgress (READING_DIRECTORY);
d1600 1
a1601 1
	    if (S_ISDIR(file_info.st_mode))
a1606 1
	    if (S_ISDIR(file_info.st_mode))
d1644 1
a1644 1
	    _HTProgress (OPERATION_OK);
d1646 1
a1646 1
	    CTRACE((tfp, "Reading the directory interrupted by user\n"));
d1655 1
a1655 1
	    int num_of_entries_output = 0; /* lines counter */
a1669 9
#ifndef DISP_PARTIAL
		if (num_of_entries_output % HTMAX(display_lines,10) == 0) {
		    if (HTCheckForInterrupt()) {
			_HTProgress (TRANSFER_INTERRUPTED);
			status = HT_PARTIAL_CONTENT;
			break;
		    }
		}
#endif
d1675 1
a1675 1
		    LYAddHtmlSep(&tmpfilename);
d1677 2
a1678 1
		entry = (char*)HTBTree_object(next_element)+1;
a1682 1
		StrAllocCat(tmpfilename, entry);
d1709 1
a1709 1
			   (char) (*(char *)(HTBTree_object(next_element))
d1736 1
a1736 1
			  (char) (*(char *)(HTBTree_object(next_element))
d1756 1
d1780 1
a1780 1
		if (num_of_entries_output %
d1783 1
a1783 1
		    /* num_of_entries, num_of_entries_output... */
d1793 1
a1793 1
		num_of_entries_output++;
d1810 1
a1829 34
#ifndef VMS
PUBLIC int HTStat ARGS2(
	CONST char *,	filename,
	struct stat *,	data)
{
    int result = -1;
    char *temp_name = NULL;
    size_t len = strlen(filename);

    if (len != 0 && LYIsPathSep(filename[len-1])) {
	HTSprintf0(&temp_name, "%s.", filename);
    } else {
	temp_name = (char *)filename;
    }
#ifdef _WINDOWS
    /*
     * Someone claims that stat() doesn't give the proper result for a
     * directory on Windows.
     */
    if (access(temp_name, 0) == 0) {
	if (stat(temp_name, data) == -1)
	    data->st_mode = S_IFDIR;
	result = 0;
    }
#else
    result = stat(temp_name, data);
#endif

    if (temp_name != filename) {
	FREE(temp_name);
    }
    return result;
}
#endif
a1857 1
    char *dot;
a1884 1
	status = -1;
d1890 1
a1890 1
	ftp_newhost = HTParse(addr, "", PARSE_HOST);
d1892 1
a1892 1
		ftp_local_passive = ftp_passive;
d1897 1
a1897 1
		if (( status >= 400 ) || ( status < 0 )) {
a1901 1
	
d1904 3
a1907 1
	return status;
d1912 1
a1912 1
#if defined(VMS) || defined(DOSPATH)
d1954 1
a1954 1
	CTRACE((tfp, "HTLoadFile: Can't stat %s\n", filename));
d1964 8
a1971 3
		char * enable_file_name = NULL;

		HTSprintf0(&enable_file_name, "%s/%s", filename, HT_DIR_ENABLE_FILE);
d2001 1
a2001 1
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", vmsname));
d2005 2
a2006 2
		CTRACE((tfp, "HTLoadFile: Can't open as %s\n",
			    ultrixname));
d2011 2
d2045 1
a2045 1
		    gzfp = gzopen(vmsname, BIN_R);
d2047 2
a2048 2
		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				vmsname, (void*)gzfp));
d2057 7
a2063 7
	    } else {
		/* FIXME: should we check if suffix is after ']' or ':' ? */
		CompressFileType cft = HTCompressFileType(vmsname, "._-", &dot);

		if (cft != cftNone) {
		    char *cp = NULL;

d2065 1
a2065 1
		    cp[dot - vmsname] = '\0';
a2070 4
		}

		switch (cft) {
		case cftCompress:
d2073 13
a2085 3
		    break;
		case cftGzip:
		    StrAllocCopy(anchor->content_encoding, "x-gzip");
d2087 5
a2091 5
		    if (strcmp(format_out->name, "www/download") != 0) {
			fclose(fp);
			if (semicolon != NULL)
			    *semicolon = ';';
			gzfp = gzopen(vmsname, BIN_R);
d2093 4
a2096 4
			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    vmsname, (void*)gzfp));
			use_gzread = YES;
		    }
d2098 1
a2098 1
		    format = HTAtom_for("www/compressed");
d2100 1
a2100 7
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    format = HTAtom_for("www/compressed");
		    break;
		case cftNone:
		    break;
d2149 1
a2149 1
#else /* not VMS: */
d2180 1
a2180 1
	    float best = (float) NO_VALUE_FOUND; /* So far best is bad */
a2219 2
			char *atomname = NULL;
			CompressFileType cft = HTCompressFileType(dirbuf->d_name, ".", &dot);
d2221 1
a2221 1

d2223 3
a2225 1
			if (cft != cftNone) {
d2227 1
a2227 1
			    cp[dot - dirbuf->d_name] = '\0';
d2232 9
a2240 12
			    switch (cft) {
			    case cftCompress:
				atomname = "application/x-compressed";
				break;
			    case cftGzip:
				atomname = "application/x-gzip";
				break;
			    case cftBzip2:
				atomname = "application/x-bzip2";
				break;
			    case cftNone:
				break;
d2242 8
a2249 3
			}

			if (atomname != NULL) {
d2253 1
a2253 1
				format = HTAtom_for(atomname);
d2265 2
a2266 2
			CTRACE((tfp, "HTLoadFile: value of presenting %s is %f\n",
				    HTAtom_name(rep), value));
d2303 5
a2307 1
	if (HTStat(localname,&dir_info) == -1)	   /* get file information */
d2310 1
a2310 1
	    CTRACE((tfp, "HTLoadFile: can't stat %s\n", localname));
d2314 4
d2325 1
a2325 1
		CTRACE((tfp, "%s is a directory\n", localname));
d2338 1
d2340 8
a2347 3
		    char * enable_file_name = NULL;

		    HTSprintf0(&enable_file_name, "%s/%s", localname, HT_DIR_ENABLE_FILE);
a2355 1
		CTRACE((tfp, "Opening directory %s\n", localname));
a2368 1
		closedir(dp);
d2373 1
a2373 8
	    } /* end if localname is a directory */

	    if (S_ISREG(dir_info.st_mode)) {
#ifdef INT_MAX
		if (dir_info.st_size <= INT_MAX)
#endif
		    anchor->content_length = dir_info.st_size;
	    }
d2381 7
a2387 2
	    int bin = HTCompressFileType(localname, ".", &dot) != cftNone;
	    FILE * fp = fopen(localname, (bin ? BIN_R : "r"));
d2389 2
a2390 2
	    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n",
				 localname, (void*)fp));
d2392 3
d2416 1
a2416 1
			gzfp = gzopen(localname, BIN_R);
d2418 2
a2419 2
			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    localname, (void*)gzfp));
d2428 3
a2430 6
		} else {
		    CompressFileType cft = HTCompressFileType(localname, ".", &dot);

		    if (cft != cftNone) {
			char *cp = NULL;

d2432 1
a2432 1
			cp[dot - localname] = '\0';
a2437 4
		    }

		    switch (cft) {
		    case cftCompress:
d2440 11
a2450 2
			break;
		    case cftGzip:
d2455 1
a2455 1
			    gzfp = gzopen(localname, BIN_R);
d2457 2
a2458 2
			    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					localname, (void*)gzfp));
a2463 7
			break;
		    case cftBzip2:
			StrAllocCopy(anchor->content_encoding, "x-bzip2");
			format = HTAtom_for("www/compressed");
			break;
		    case cftNone:
			break;
a2526 1
	    status = -1;
d2528 5
a2532 4
	    if (strncmp(addr, "file://localhost", 16)) {
		/* never go to ftp site when URL
		 * is file://localhost
		 */
d2534 3
a2536 1
		status = HTFTPLoad(addr, anchor, format_out, sink);
a2538 1
	    return status;
d2548 1
a2548 1
	CTRACE((tfp, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO));
@


1.1.1.3
log
@Sync MirBSD main source tree against OpenBSD-current,
which should be fairly stable after the Hackathon now.
@
text
@d277 1
a277 1
			    (len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
@


