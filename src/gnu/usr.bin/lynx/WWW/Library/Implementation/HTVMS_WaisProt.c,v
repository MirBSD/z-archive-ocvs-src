head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.8
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.6
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.07.15.18.16.40;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.28;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.50;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.04;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.10;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.01;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.52;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.48;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.23;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.09;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.46.18;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@automatic merge of lynx-current
@
text
@/*							HTVMS_WAISProt.c
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	31-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/

/*
 *	Routines originally from WProt.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.

 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris
 * -	removed chunk code from WAISSearchAPDU,
 * -	added makeWAISQueryType1Query() and readWAISType1Query() which replace
 * makeWAISQueryTerms() and makeWAISQueryDocs().
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 * - renamed makeWAISType1Query() to makeWAISTextQuery()
 * renamed readWAISType1Query() to readWAISTextQuery()
 * 5.29.90  TS - fixed bug in makeWAISQueryDocs
 * added CSTFreeWAISFoo functions
 */

#define _C_WAIS_protocol_

/*	This file implements the Z39.50 extensions required for WAIS
*/

#include <HTUtils.h>
#include <HTVMS_WaisUI.h>
#include <HTVMS_WaisProt.h>

#include <LYLeaks.h>

/* very rough estimates of the size of an object */
#define DefWAISInitResponseSize		(size_t)200
#define DefWAISSearchSize			(size_t)3000
#define DefWAISSearchResponseSize	(size_t)6000
#define DefWAISPresentSize			(size_t)1000
#define DefWAISPresentResponseSize	(size_t)6000
#define DefWAISDocHeaderSize		(size_t)500
#define DefWAISShortHeaderSize		(size_t)200
#define DefWAISLongHeaderSize		(size_t)800
#define DefWAISDocTextSize			(size_t)6000
#define DefWAISDocHeadlineSize		(size_t)500
#define DefWAISDocCodeSize			(size_t)500

#define RESERVE_SPACE_FOR_WAIS_HEADER(len)	\
     if (*len > 0)				\
	*len -= header_len;

#define S_MALLOC(type) (type*)s_malloc(sizeof(type))
#define S_MALLOC2(type) (type*)s_malloc(sizeof(type) * 2)

#define S_REALLOC2(type, ptr, num) (type*)s_realloc((char*)ptr, (sizeof(type) * (num + 2)))

/*----------------------------------------------------------------------*/

static unsigned long userInfoTagSize(data_tag tag,
				     unsigned long length)
/* return the number of bytes required to write the user info tag and
   length
 */
{
    unsigned long size;

    /* calculate bytes required to represent tag.  max tag is 16K */
    size = writtenCompressedIntSize(tag);
    size += writtenCompressedIntSize(length);

    return (size);
}

/*----------------------------------------------------------------------*/

static char *writeUserInfoHeader(data_tag tag,
				 long infoSize,
				 long estHeaderSize,
				 char *buffer,
				 long *len)
/* write the tag and size, making sure the info fits.  return the true end
   of the info (after adjustment) note that the argument infoSize includes
   estHeaderSize.  Note that the argument len is the number of bytes remaining
   in the buffer.  Since we write the tag and size at the begining of the
   buffer (in space that we reserved) we don't want to pass len the calls which
   do that writing.
 */
{
    long dummyLen = 100;	/* plenty of space for a tag and size */
    char *buf = buffer;
    long realSize = infoSize - estHeaderSize;
    long realHeaderSize = userInfoTagSize(tag, realSize);

    if (buffer == NULL || *len == 0)
	return (NULL);

    /* write the tag */
    buf = writeTag(tag, buf, &dummyLen);

    /* see if the if the header size was correct. if not,
       we have to shift the info to fit the real header size */
    if (estHeaderSize != realHeaderSize) {	/* make sure there is enough space */
	CHECK_FOR_SPACE_LEFT(realHeaderSize - estHeaderSize, len);
	memmove(buffer + realHeaderSize, buffer + estHeaderSize, (size_t) (realSize));
    }

    /* write the size */
    writeCompressedInteger(realSize, buf, &dummyLen);

    /* return the true end of buffer */
    return (buffer + realHeaderSize + realSize);
}

/*----------------------------------------------------------------------*/

static char *readUserInfoHeader(data_tag *tag,
				unsigned long *num,
				char *buffer)
/* read the tag and size */
{
    char *buf = buffer;

    buf = readTag(tag, buf);
    buf = readCompressedInteger(num, buf);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISInitResponse *makeWAISInitResponse(long chunkCode,
				       long chunkIDLen,
				       char *chunkMarker,
				       char *highlightMarker,
				       char *deHighlightMarker,
				       char *newLineChars)
/* create a WAIS init response object */
{
    WAISInitResponse *init = S_MALLOC(WAISInitResponse);

    init->ChunkCode = chunkCode;	/* note: none are copied! */
    init->ChunkIDLength = chunkIDLen;
    init->ChunkMarker = chunkMarker;
    init->HighlightMarker = highlightMarker;
    init->DeHighlightMarker = deHighlightMarker;
    init->NewlineCharacters = newLineChars;

    return (init);
}

/*----------------------------------------------------------------------*/

void freeWAISInitResponse(WAISInitResponse *init)
/* free an object made with makeWAISInitResponse */
{
    s_free(init->ChunkMarker);
    s_free(init->HighlightMarker);
    s_free(init->DeHighlightMarker);
    s_free(init->NewlineCharacters);
    s_free(init);
}

/*----------------------------------------------------------------------*/

char *writeInitResponseInfo(InitResponseAPDU *init,
			    char *buffer,
			    long *len)
/* write an init response object */
{
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISInitResponseSize);
    char *buf = buffer + header_len;
    WAISInitResponse *info = (WAISInitResponse *) init->UserInformationField;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeNum(info->ChunkCode, DT_ChunkCode, buf, len);
    buf = writeNum(info->ChunkIDLength, DT_ChunkIDLength, buf, len);
    buf = writeString(info->ChunkMarker, DT_ChunkMarker, buf, len);
    buf = writeString(info->HighlightMarker, DT_HighlightMarker, buf, len);
    buf = writeString(info->DeHighlightMarker, DT_DeHighlightMarker, buf, len);
    buf = writeString(info->NewlineCharacters, DT_NewlineCharacters, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readInitResponseInfo(void **info,
			   char *buffer)
/* read an init response object */
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    long chunkCode, chunkIDLen;
    data_tag tag1;
    char *chunkMarker = NULL;
    char *highlightMarker = NULL;
    char *deHighlightMarker = NULL;
    char *newLineChars = NULL;

    chunkCode = chunkIDLen = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_ChunkCode:
	    buf = readNum(&chunkCode, buf);
	    break;
	case DT_ChunkIDLength:
	    buf = readNum(&chunkIDLen, buf);
	    break;
	case DT_ChunkMarker:
	    buf = readString(&chunkMarker, buf);
	    break;
	case DT_HighlightMarker:
	    buf = readString(&highlightMarker, buf);
	    break;
	case DT_DeHighlightMarker:
	    buf = readString(&deHighlightMarker, buf);
	    break;
	case DT_NewlineCharacters:
	    buf = readString(&newLineChars, buf);
	    break;
	default:
	    s_free(highlightMarker);
	    s_free(deHighlightMarker);
	    s_free(newLineChars);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *info = (void *) makeWAISInitResponse(chunkCode, chunkIDLen, chunkMarker,
					  highlightMarker, deHighlightMarker,
					  newLineChars);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISSearch *makeWAISSearch(char *seedWords,
			   DocObj **docs,
			   char **textList,
			   long dateFactor,
			   char *beginDateRange,
			   char *endDateRange,
			   long maxDocsRetrieved)

/* create a type 3 query object */
{
    WAISSearch *query = S_MALLOC(WAISSearch);

    query->SeedWords = seedWords;	/* not copied! */
    query->Docs = docs;		/* not copied! */
    query->TextList = textList;	/* not copied! */
    query->DateFactor = dateFactor;
    query->BeginDateRange = beginDateRange;
    query->EndDateRange = endDateRange;
    query->MaxDocumentsRetrieved = maxDocsRetrieved;

    return (query);
}

/*----------------------------------------------------------------------*/

void freeWAISSearch(WAISSearch *query)

/* destroy an object made with makeWAISSearch() */
{
    void *ptr = NULL;
    long i;

    s_free(query->SeedWords);

    if (query->Docs != NULL)
	for (i = 0, ptr = (void *) query->Docs[i];
	     ptr != NULL;
	     ptr = (void *) query->Docs[++i])
	    freeDocObj((DocObj *) ptr);
    s_free(query->Docs);

    if (query->TextList != NULL)	/* XXX revisit when textlist is fully defined */
	for (i = 0, ptr = (void *) query->TextList[i];
	     ptr != NULL;
	     ptr = (void *) query->TextList[++i])
	    s_free(ptr);
    s_free(query->TextList);

    s_free(query->BeginDateRange);
    s_free(query->EndDateRange);
    s_free(query);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingWholeDocument(any *docID,
				     char *type)

/* construct a document object using byte chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->DocumentID = docID;	/* not copied! */
    doc->Type = type;		/* not copied! */
    doc->ChunkCode = CT_document;
    return (doc);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingLines(any *docID,
			     char *type,
			     long start,
			     long end)

/* construct a document object using line chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_line;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingBytes(any *docID,
			     char *type,
			     long start,
			     long end)

/* construct a document object using byte chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_byte;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingParagraphs(any *docID,
				  char *type,
				  any *start,
				  any *end)

/* construct a document object using byte chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_paragraph;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;
    doc->ChunkStart.ID = start;
    doc->ChunkEnd.ID = end;
    return (doc);
}

/*----------------------------------------------------------------------*/

void freeDocObj(DocObj *doc)

/* free a docObj */
{
    freeAny(doc->DocumentID);
    s_free(doc->Type);
    if (doc->ChunkCode == CT_paragraph) {
	freeAny(doc->ChunkStart.ID);
	freeAny(doc->ChunkEnd.ID);
    }
    s_free(doc);
}

/*----------------------------------------------------------------------*/

static char *writeDocObj(DocObj *doc,
			 char *buffer,
			 long *len)

/* write as little as we can about the doc obj */
{
    char *buf = buffer;

    /* we alwasy have to write the id, but its tag depends on if its a chunk */
    if (doc->ChunkCode == CT_document)
	buf = writeAny(doc->DocumentID, DT_DocumentID, buf, len);
    else
	buf = writeAny(doc->DocumentID, DT_DocumentIDChunk, buf, len);

    if (doc->Type != NULL)
	buf = writeString(doc->Type, DT_TYPE, buf, len);

    switch (doc->ChunkCode) {
    case CT_document:
	/* do nothing - there is no chunk data */
	break;
    case CT_byte:
    case CT_line:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeNum(doc->ChunkStart.Pos, DT_ChunkStartID, buf, len);
	buf = writeNum(doc->ChunkEnd.Pos, DT_ChunkEndID, buf, len);
	break;
    case CT_paragraph:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeAny(doc->ChunkStart.ID, DT_ChunkStartID, buf, len);
	buf = writeAny(doc->ChunkEnd.ID, DT_ChunkEndID, buf, len);
	break;
    default:
	panic("Implementation error: unknown chuck type %ld",
	      doc->ChunkCode);
	break;
    }

    return (buf);
}

/*----------------------------------------------------------------------*/

static char *readDocObj(DocObj **doc,
			char *buffer)

/* read whatever we have about the new document */
{
    char *buf = buffer;
    data_tag tag;

    *doc = S_MALLOC(DocObj);

    tag = peekTag(buf);
    buf = readAny(&((*doc)->DocumentID), buf);

    if (tag == DT_DocumentID) {
	(*doc)->ChunkCode = CT_document;
	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != what comes next */
	    buf = readString(&((*doc)->Type), buf);
	/* ChunkStart and ChunkEnd are undefined */
    } else if (tag == DT_DocumentIDChunk) {
	boolean readParagraphs = false;		/* for cleanup */

	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != CT_FOO */
	    buf = readString(&((*doc)->Type), buf);
	buf = readNum(&((*doc)->ChunkCode), buf);
	switch ((*doc)->ChunkCode) {
	case CT_byte:
	case CT_line:
	    buf = readNum(&((*doc)->ChunkStart.Pos), buf);
	    buf = readNum(&((*doc)->ChunkEnd.Pos), buf);
	    break;
	case CT_paragraph:
	    readParagraphs = true;
	    buf = readAny(&((*doc)->ChunkStart.ID), buf);
	    buf = readAny(&((*doc)->ChunkEnd.ID), buf);
	    break;
	default:
	    freeAny((*doc)->DocumentID);
	    if (readParagraphs) {
		freeAny((*doc)->ChunkStart.ID);
		freeAny((*doc)->ChunkEnd.ID);
	    }
	    s_free(doc);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    } else {
	freeAny((*doc)->DocumentID);
	s_free(*doc);
	REPORT_READ_ERROR(buf);
    }
    return (buf);
}

/*----------------------------------------------------------------------*/

char *writeSearchInfo(SearchAPDU *query,
		      char *buffer,
		      long *len)

/* write out a WAIS query (type 1 or 3) */
{
    if (strcmp(query->QueryType, QT_TextRetrievalQuery) == 0) {
	return (writeAny((any *) query->Query, DT_Query, buffer, len));
    } else {
	unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
						   DefWAISSearchSize);
	char *buf = buffer + header_len;
	WAISSearch *info = (WAISSearch *) query->Query;
	unsigned long size;
	long i;

	RESERVE_SPACE_FOR_WAIS_HEADER(len);

	buf = writeString(info->SeedWords, DT_SeedWords, buf, len);

	if (info->Docs != NULL) {
	    for (i = 0; info->Docs[i] != NULL; i++) {
		buf = writeDocObj(info->Docs[i], buf, len);
	    }
	}

	/* XXX text list */

	buf = writeNum(info->DateFactor,
		       DT_DateFactor,
		       buf,
		       len);
	buf = writeString(info->BeginDateRange,
			  DT_BeginDateRange,
			  buf,
			  len);
	buf = writeString(info->EndDateRange,
			  DT_EndDateRange,
			  buf,
			  len);
	buf = writeNum(info->MaxDocumentsRetrieved,
		       DT_MaxDocumentsRetrieved,
		       buf,
		       len);

	/* now write the header and size */
	size = buf - buffer;
	buf = writeUserInfoHeader(DT_UserInformationLength,
				  size,
				  header_len,
				  buffer,
				  len);

	return (buf);
    }
}

/*----------------------------------------------------------------------*/

char *readSearchInfo(void **info,
		     char *buffer)

/* read a WAIS query (type 1 or 3) */
{
    data_tag type = peekTag(buffer);

    if (type == DT_Query)	/* this is a type 1 query */
    {
	char *buf = buffer;
	any *query = NULL;

	buf = readAny(&query, buf);
	*info = (void *) query;
	return (buf);
    } else {			/* a type 3 query */
	char *buf = buffer;
	unsigned long size;
	unsigned long headerSize;
	data_tag tag1;
	char *seedWords = NULL;
	char *beginDateRange = NULL;
	char *endDateRange = NULL;
	long dateFactor, maxDocsRetrieved;
	char **textList = NULL;
	DocObj **docIDs = NULL;
	DocObj *doc = NULL;
	long docs = 0;
	long i;
	void *ptr = NULL;

	dateFactor = maxDocsRetrieved = UNUSED;

	buf = readUserInfoHeader(&tag1, &size, buf);
	headerSize = buf - buffer;

	while (buf < (buffer + size + headerSize)) {
	    data_tag tag = peekTag(buf);

	    switch (tag) {
	    case DT_SeedWords:
		buf = readString(&seedWords, buf);
		break;
	    case DT_DocumentID:
	    case DT_DocumentIDChunk:
		if (docIDs == NULL)	/* create a new doc list */
		{
		    docIDs = S_MALLOC2(DocObj *);
		} else {	/* grow the doc list */
		    docIDs = S_REALLOC2(DocObj *, docIDs, docs);
		}
		buf = readDocObj(&doc, buf);
		if (buf == NULL) {
		    s_free(seedWords);
		    s_free(beginDateRange);
		    s_free(endDateRange);
		    if (docIDs != NULL)
			for (i = 0, ptr = (void *) docIDs[i];
			     ptr != NULL;
			     ptr = (void *) docIDs[++i])
			    freeDocObj((DocObj *) ptr);
		    s_free(docIDs);
		    /* XXX should also free textlist when it is fully defined */
		}
		RETURN_ON_NULL(buf);
		docIDs[docs++] = doc;	/* put it in the list */
		docIDs[docs] = NULL;
		break;
	    case DT_TextList:
		/* XXX */
		break;
	    case DT_DateFactor:
		buf = readNum(&dateFactor, buf);
		break;
	    case DT_BeginDateRange:
		buf = readString(&beginDateRange, buf);
		break;
	    case DT_EndDateRange:
		buf = readString(&endDateRange, buf);
		break;
	    case DT_MaxDocumentsRetrieved:
		buf = readNum(&maxDocsRetrieved, buf);
		break;
	    default:
		s_free(seedWords);
		s_free(beginDateRange);
		s_free(endDateRange);
		if (docIDs != NULL)
		    for (i = 0, ptr = (void *) docIDs[i];
			 ptr != NULL;
			 ptr = (void *) docIDs[++i])
			freeDocObj((DocObj *) ptr);
		s_free(docIDs);
		/* XXX should also free textlist when it is fully defined */
		REPORT_READ_ERROR(buf);
		break;
	    }
	}

	*info = (void *) makeWAISSearch(seedWords, docIDs, textList,
					dateFactor, beginDateRange, endDateRange,
					maxDocsRetrieved);
	return (buf);
    }
}

/*----------------------------------------------------------------------*/

WAISDocumentHeader *makeWAISDocumentHeader(any *docID,
					   long versionNumber,
					   long score,
					   long bestMatch,
					   long docLen,
					   long lines,
					   char **types,
					   char *source,
					   char *date,
					   char *headline,
					   char *originCity)

/* construct a standard document header, note that no fields are copied!
   if the application needs to save these fields, it should copy them,
   or set the field in this object to NULL before freeing it.
 */
{
    WAISDocumentHeader *header = S_MALLOC(WAISDocumentHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeader(WAISDocumentHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here ! */
    s_free(header->Types);
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentHeader(WAISDocumentHeader *header, char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeaderGroup,
					       DefWAISDocHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
	}
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeader(WAISDocumentHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types = NULL;
    char *source = NULL;
    char *date = NULL;
    char *headline = NULL;
    char *originCity = NULL;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		buf = readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
		}
	    }
	    /* FALLTHRU */
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *header = makeWAISDocumentHeader(docID, versionNumber, score, bestMatch,
				     docLength, lines, types, source, date, headline,
				     originCity);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentShortHeader *makeWAISDocumentShortHeader(any *docID,
						     long versionNumber,
						     long score,
						     long bestMatch,
						     long docLen,
						     long lines)
/* construct a short document header, note that no fields are copied!
   if the application needs to save these fields, it should copy them,
   or set the field in this object to NULL before freeing it.
 */
{
    WAISDocumentShortHeader *header = S_MALLOC(WAISDocumentShortHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
{
    freeAny(header->DocumentID);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentShortHeader(WAISDocumentShortHeader *header, char *buffer,
				   long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentShortHeaderGroup,
					       DefWAISShortHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentShortHeaderGroup,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentShortHeader(WAISDocumentShortHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	default:
	    freeAny(docID);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *header = makeWAISDocumentShortHeader(docID, versionNumber, score, bestMatch,
					  docLength, lines);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentLongHeader *makeWAISDocumentLongHeader(any *docID,
						   long versionNumber,
						   long score,
						   long bestMatch,
						   long docLen,
						   long lines,
						   char **types,
						   char *source,
						   char *date,
						   char *headline,
						   char *originCity,
						   char *stockCodes,
						   char *companyCodes,
						   char *industryCodes)
/* construct a long document header, note that no fields are copied!
   if the application needs to save these fields, it should copy them,
   or set the field in this object to NULL before freeing it.
 */
{
    WAISDocumentLongHeader *header = S_MALLOC(WAISDocumentLongHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;
    header->StockCodes = stockCodes;
    header->CompanyCodes = companyCodes;
    header->IndustryCodes = industryCodes;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here! */
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header->StockCodes);
    s_free(header->CompanyCodes);
    s_free(header->IndustryCodes);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentLongHeader(WAISDocumentLongHeader *header, char *buffer,
				  long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentLongHeaderGroup,
					       DefWAISLongHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
	}
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);
    buf = writeString(header->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(header->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(header->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentLongHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentLongHeader(WAISDocumentLongHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types;
    char *source, *date, *headline, *originCity, *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber =
	score =
	bestMatch =
	docLength =
	lines = UNUSED;
    types = NULL;
    source =
	date =
	headline =
	originCity =
	stockCodes =
	companyCodes =
	industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
		}
	    }
	    /* FALLTHRU */
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
	    break;
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
	    break;
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    s_free(stockCodes);
	    s_free(companyCodes);
	    s_free(industryCodes);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *header = makeWAISDocumentLongHeader(docID,
					 versionNumber,
					 score,
					 bestMatch,
					 docLength,
					 lines,
					 types,
					 source,
					 date,
					 headline,
					 originCity,
					 stockCodes,
					 companyCodes,
					 industryCodes);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISSearchResponse *
  makeWAISSearchResponse(
			    char *seedWordsUsed,
			    WAISDocumentHeader **docHeaders,
			    WAISDocumentShortHeader **shortHeaders,
			    WAISDocumentLongHeader **longHeaders,
			    WAISDocumentText **text,
			    WAISDocumentHeadlines **headlines,
			    WAISDocumentCodes **codes,
			    diagnosticRecord ** diagnostics)
{
    WAISSearchResponse *response = S_MALLOC(WAISSearchResponse);

    response->SeedWordsUsed = seedWordsUsed;
    response->DocHeaders = docHeaders;
    response->ShortHeaders = shortHeaders;
    response->LongHeaders = longHeaders;
    response->Text = text;
    response->Headlines = headlines;
    response->Codes = codes;
    response->Diagnostics = diagnostics;

    return (response);
}

/*----------------------------------------------------------------------*/

void freeWAISSearchResponse(WAISSearchResponse * response)
{
    void *ptr = NULL;
    long i;

    s_free(response->SeedWordsUsed);

    if (response->DocHeaders != NULL)
	for (i = 0, ptr = (void *) response->DocHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->DocHeaders[++i])
	    freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
    s_free(response->DocHeaders);

    if (response->ShortHeaders != NULL)
	for (i = 0, ptr = (void *) response->ShortHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->ShortHeaders[++i])
	    freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
    s_free(response->ShortHeaders);

    if (response->LongHeaders != NULL)
	for (i = 0, ptr = (void *) response->LongHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->LongHeaders[++i])
	    freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
    s_free(response->LongHeaders);

    if (response->Text != NULL)
	for (i = 0, ptr = (void *) response->Text[i];
	     ptr != NULL;
	     ptr = (void *) response->Text[++i])
	    freeWAISDocumentText((WAISDocumentText *) ptr);
    s_free(response->Text);

    if (response->Headlines != NULL)
	for (i = 0, ptr = (void *) response->Headlines[i];
	     ptr != NULL;
	     ptr = (void *) response->Headlines[++i])
	    freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
    s_free(response->Headlines);

    if (response->Codes != NULL)
	for (i = 0, ptr = (void *) response->Codes[i];
	     ptr != NULL;
	     ptr = (void *) response->Codes[++i])
	    freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
    s_free(response->Codes);

    if (response->Diagnostics != NULL)
	for (i = 0, ptr = (void *) response->Diagnostics[i];
	     ptr != NULL;
	     ptr = (void *) response->Diagnostics[++i])
	    freeDiag((diagnosticRecord *) ptr);
    s_free(response->Diagnostics);

    s_free(response);
}

/*----------------------------------------------------------------------*/

char *writeSearchResponseInfo(SearchResponseAPDU *query,
			      char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISSearchResponseSize);
    char *buf = buffer + header_len;
    WAISSearchResponse *info = (WAISSearchResponse *) query->DatabaseDiagnosticRecords;
    unsigned long size;
    void *header = NULL;
    long i;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeString(info->SeedWordsUsed, DT_SeedWordsUsed, buf, len);

    /* write out all the headers */
    if (info->DocHeaders != NULL) {
	for (i = 0, header = (void *) info->DocHeaders[i];
	     header != NULL;
	     header = (void *) info->DocHeaders[++i])
	    buf = writeWAISDocumentHeader((WAISDocumentHeader *) header, buf, len);
    }

    if (info->ShortHeaders != NULL) {
	for (i = 0, header = (void *) info->ShortHeaders[i];
	     header != NULL;
	     header = (void *) info->ShortHeaders[++i])
	    buf = writeWAISDocumentShortHeader((WAISDocumentShortHeader *) header,
					       buf,
					       len);
    }

    if (info->LongHeaders != NULL) {
	for (i = 0, header = (void *) info->LongHeaders[i];
	     header != NULL;
	     header = (void *) info->LongHeaders[++i])
	    buf = writeWAISDocumentLongHeader((WAISDocumentLongHeader *) header,
					      buf,
					      len);
    }

    if (info->Text != NULL) {
	for (i = 0, header = (void *) info->Text[i];
	     header != NULL;
	     header = (void *) info->Text[++i])
	    buf = writeWAISDocumentText((WAISDocumentText *) header, buf, len);
    }

    if (info->Headlines != NULL) {
	for (i = 0, header = (void *) info->Headlines[i];
	     header != NULL;
	     header = (void *) info->Headlines[++i])
	    buf = writeWAISDocumentHeadlines((WAISDocumentHeadlines *) header,
					     buf,
					     len);
    }

    if (info->Codes != NULL) {
	for (i = 0, header = (void *) info->Codes[i];
	     header != NULL;
	     header = (void *) info->Codes[++i])
	    buf = writeWAISDocumentCodes((WAISDocumentCodes *) header, buf, len);
    }

    if (info->Diagnostics != NULL) {
	for (i = 0, header = (void *) info->Diagnostics[i];
	     header != NULL;
	     header = (void *) info->Diagnostics[++i])
	    buf = writeDiag((diagnosticRecord *) header, buf, len);
    }

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

static void cleanUpWaisSearchResponse(char *buf,
				      char *seedWordsUsed,
				      WAISDocumentHeader **docHeaders,
				      WAISDocumentShortHeader **shortHeaders,
				      WAISDocumentLongHeader **longHeaders,
				      WAISDocumentText **text,
				      WAISDocumentHeadlines **headlines,
				      WAISDocumentCodes **codes,
				      diagnosticRecord ** diags)
/* if buf is NULL, we have just gotten a read error, and need to clean up
   any state we have built.  If not, then everything is going fine, and
   we should just hang loose
 */
{
    void *ptr = NULL;
    long i;

    if (buf == NULL) {
	s_free(seedWordsUsed);
	if (docHeaders != NULL)
	    for (i = 0, ptr = (void *) docHeaders[i]; ptr != NULL;
		 ptr = (void *) docHeaders[++i])
		freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
	s_free(docHeaders);
	if (shortHeaders != NULL)
	    for (i = 0, ptr = (void *) shortHeaders[i]; ptr != NULL;
		 ptr = (void *) shortHeaders[++i])
		freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
	s_free(shortHeaders);
	if (longHeaders != NULL)
	    for (i = 0, ptr = (void *) longHeaders[i]; ptr != NULL;
		 ptr = (void *) longHeaders[++i])
		freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
	s_free(longHeaders);
	if (text != NULL)
	    for (i = 0, ptr = (void *) text[i];
		 ptr != NULL;
		 ptr = (void *) text[++i])
		freeWAISDocumentText((WAISDocumentText *) ptr);
	s_free(text);
	if (headlines != NULL)
	    for (i = 0, ptr = (void *) headlines[i]; ptr != NULL;
		 ptr = (void *) headlines[++i])
		freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
	s_free(headlines);
	if (codes != NULL)
	    for (i = 0, ptr = (void *) codes[i]; ptr != NULL;
		 ptr = (void *) codes[++i])
		freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
	s_free(codes);
	if (diags != NULL)
	    for (i = 0, ptr = (void *) diags[i]; ptr != NULL;
		 ptr = (void *) diags[++i])
		freeDiag((diagnosticRecord *) ptr);
	s_free(diags);
    }
}

/*----------------------------------------------------------------------*/

char *readSearchResponseInfo(void **info,
			     char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    void *header = NULL;
    WAISDocumentHeader **docHeaders = NULL;
    WAISDocumentShortHeader **shortHeaders = NULL;
    WAISDocumentLongHeader **longHeaders = NULL;
    WAISDocumentText **text = NULL;
    WAISDocumentHeadlines **headlines = NULL;
    WAISDocumentCodes **codes = NULL;
    long numDocHeaders, numLongHeaders, numShortHeaders, numText, numHeadlines;
    long numCodes;
    char *seedWordsUsed = NULL;
    diagnosticRecord **diags = NULL;
    diagnosticRecord *diag = NULL;
    long numDiags = 0;

    numDocHeaders =
	numLongHeaders =
	numShortHeaders =
	numText =
	numHeadlines =
	numCodes = 0;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_SeedWordsUsed:
	    buf = readString(&seedWordsUsed, buf);
	    break;
	case DT_DatabaseDiagnosticRecords:
	    if (diags == NULL)	/* create a new diag list */
	    {
		diags = S_MALLOC2(diagnosticRecord *);
	    } else {		/* grow the diag list */
		diags = S_REALLOC2(diagnosticRecord *, diags, numDiags);
	    }
	    buf = readDiag(&diag, buf);
	    diags[numDiags++] = diag;	/* put it in the list */
	    diags[numDiags] = NULL;
	    break;
	case DT_DocumentHeaderGroup:
	    if (docHeaders == NULL)	/* create a new header list */
	    {
		docHeaders = S_MALLOC2(WAISDocumentHeader *);
	    } else {		/* grow the doc list */
		docHeaders = S_REALLOC2(WAISDocumentHeader *, docHeaders, numDocHeaders);
	    }
	    buf = readWAISDocumentHeader((WAISDocumentHeader **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    docHeaders[numDocHeaders++] =
		(WAISDocumentHeader *) header;	/* put it in the list */
	    docHeaders[numDocHeaders] = NULL;
	    break;
	case DT_DocumentShortHeaderGroup:
	    if (shortHeaders == NULL)	/* create a new header list */
	    {
		shortHeaders = S_MALLOC2(WAISDocumentShortHeader *);
	    } else {		/* grow the doc list */
		shortHeaders = S_REALLOC2(WAISDocumentShortHeader *,
					  shortHeaders,
					  numShortHeaders);
	    }
	    buf = readWAISDocumentShortHeader((WAISDocumentShortHeader **) &header,
					      buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    shortHeaders[numShortHeaders++] =
		(WAISDocumentShortHeader *) header;	/* put it in the list */
	    shortHeaders[numShortHeaders] = NULL;
	    break;
	case DT_DocumentLongHeaderGroup:
	    if (longHeaders == NULL)	/* create a new header list */
	    {
		longHeaders = S_MALLOC2(WAISDocumentLongHeader *);
	    } else {		/* grow the doc list */
		longHeaders = S_REALLOC2(WAISDocumentLongHeader *,
					 longHeaders,
					 numLongHeaders);
	    }
	    buf = readWAISDocumentLongHeader((WAISDocumentLongHeader **) &header,
					     buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    longHeaders[numLongHeaders++] =
		(WAISDocumentLongHeader *) header;	/* put it in the list */
	    longHeaders[numLongHeaders] = NULL;
	    break;
	case DT_DocumentTextGroup:
	    if (text == NULL)	/* create a new list */
	    {
		text = S_MALLOC2(WAISDocumentText *);
	    } else {		/* grow the list */
		text = S_REALLOC2(WAISDocumentText *, text, numText);
	    }
	    buf = readWAISDocumentText((WAISDocumentText **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    text[numText++] =
		(WAISDocumentText *) header;	/* put it in the list */
	    text[numText] = NULL;
	    break;
	case DT_DocumentHeadlineGroup:
	    if (headlines == NULL)	/* create a new list */
	    {
		headlines = S_MALLOC2(WAISDocumentHeadlines *);
	    } else {		/* grow the list */
		headlines = S_REALLOC2(WAISDocumentHeadlines *, headlines, numHeadlines);
	    }
	    buf = readWAISDocumentHeadlines((WAISDocumentHeadlines **) &header,
					    buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    headlines[numHeadlines++] =
		(WAISDocumentHeadlines *) header;	/* put it in the list */
	    headlines[numHeadlines] = NULL;
	    break;
	case DT_DocumentCodeGroup:
	    if (codes == NULL)	/* create a new list */
	    {
		codes = S_MALLOC2(WAISDocumentCodes *);
	    } else {		/* grow the list */
		codes = S_REALLOC2(WAISDocumentCodes *, codes, numCodes);
	    }
	    buf = readWAISDocumentCodes((WAISDocumentCodes **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    codes[numCodes++] =
		(WAISDocumentCodes *) header;	/* put it in the list */
	    codes[numCodes] = NULL;
	    break;
	default:
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *info = (void *) makeWAISSearchResponse(seedWordsUsed,
					    docHeaders,
					    shortHeaders,
					    longHeaders,
					    text,
					    headlines,
					    codes,
					    diags);

    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentText *makeWAISDocumentText(any *docID,
				       long versionNumber,
				       any *documentText)
{
    WAISDocumentText *docText = S_MALLOC(WAISDocumentText);

    docText->DocumentID = docID;
    docText->VersionNumber = versionNumber;
    docText->DocumentText = documentText;

    return (docText);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentText(WAISDocumentText *docText)
{
    freeAny(docText->DocumentID);
    freeAny(docText->DocumentText);
    s_free(docText);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentText(WAISDocumentText *docText, char *buffer,
			    long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentTextGroup,
					       DefWAISDocTextSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docText->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docText->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeAny(docText->DocumentText, DT_DocumentText, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentTextGroup, size, header_len, buffer, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentText(WAISDocumentText **docText, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID, *documentText;
    long versionNumber;

    docID = documentText = NULL;
    versionNumber = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_DocumentText:
	    buf = readAny(&documentText, buf);
	    break;
	default:
	    freeAny(docID);
	    freeAny(documentText);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docText = makeWAISDocumentText(docID, versionNumber, documentText);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentHeadlines *makeWAISDocumentHeadlines(any *docID,
						 long versionNumber,
						 char *source,
						 char *date,
						 char *headline,
						 char *originCity)
{
    WAISDocumentHeadlines *docHeadline = S_MALLOC(WAISDocumentHeadlines);

    docHeadline->DocumentID = docID;
    docHeadline->VersionNumber = versionNumber;
    docHeadline->Source = source;
    docHeadline->Date = date;
    docHeadline->Headline = headline;
    docHeadline->OriginCity = originCity;

    return (docHeadline);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline)
{
    freeAny(docHeadline->DocumentID);
    s_free(docHeadline->Source);
    s_free(docHeadline->Date);
    s_free(docHeadline->Headline);
    s_free(docHeadline->OriginCity);
    s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline, char *buffer,
				 long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeadlineGroup,
					       DefWAISDocHeadlineSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docHeadline->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docHeadline->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docHeadline->Source, DT_Source, buf, len);
    buf = writeString(docHeadline->Date, DT_Date, buf, len);
    buf = writeString(docHeadline->Headline, DT_Headline, buf, len);
    buf = writeString(docHeadline->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeadlineGroup,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeadlines(WAISDocumentHeadlines **docHeadline, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *source, *date, *headline, *originCity;

    docID = NULL;
    versionNumber = UNUSED;
    source = date = headline = originCity = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docHeadline = makeWAISDocumentHeadlines(docID, versionNumber, source, date,
					     headline, originCity);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentCodes *makeWAISDocumentCodes(any *docID,
					 long versionNumber,
					 char *stockCodes,
					 char *companyCodes,
					 char *industryCodes)
{
    WAISDocumentCodes *docCodes = S_MALLOC(WAISDocumentCodes);

    docCodes->DocumentID = docID;
    docCodes->VersionNumber = versionNumber;
    docCodes->StockCodes = stockCodes;
    docCodes->CompanyCodes = companyCodes;
    docCodes->IndustryCodes = industryCodes;

    return (docCodes);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentCodes(WAISDocumentCodes *docCodes)
{
    freeAny(docCodes->DocumentID);
    s_free(docCodes->StockCodes);
    s_free(docCodes->CompanyCodes);
    s_free(docCodes->IndustryCodes);
    s_free(docCodes);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentCodes(WAISDocumentCodes *docCodes,
			     char *buffer,
			     long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentCodeGroup,
					       DefWAISDocCodeSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docCodes->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docCodes->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docCodes->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(docCodes->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(docCodes->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentCodeGroup, size, header_len, buffer, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentCodes(WAISDocumentCodes **docCodes,
			    char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber = UNUSED;
    stockCodes = companyCodes = industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
	    break;
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
	    break;
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(stockCodes);
	    s_free(companyCodes);
	    s_free(industryCodes);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docCodes = makeWAISDocumentCodes(docID, versionNumber, stockCodes,
				      companyCodes, industryCodes);
    return (buf);
}

/*----------------------------------------------------------------------*/

char *writePresentInfo(PresentAPDU * present GCC_UNUSED, char *buffer,
		       long *len GCC_UNUSED)
{
    /* The WAIS protocol doesn't use present info */
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *readPresentInfo(void **info,
		      char *buffer)
{
    /* The WAIS protocol doesn't use present info */
    *info = NULL;
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *writePresentResponseInfo(PresentResponseAPDU * response GCC_UNUSED, char *buffer,
			       long *len GCC_UNUSED)
{
    /* The WAIS protocol doesn't use presentResponse info */
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *readPresentResponseInfo(void **info,
			      char *buffer)
{
    /* The WAIS protocol doesn't use presentResponse info */
    *info = NULL;
    return (buffer);
}

/*----------------------------------------------------------------------*/

/* support for type 1 queries */

/* new use values (for the chunk types) */
#define	BYTE		"wb"
#define	LINE		"wl"
#define	PARAGRAPH	"wp"
#define DATA_TYPE	"wt"

/* WAIS supports the following semantics for type 1 queries:

     1.  retrieve the header/codes from a document:

	    System_Control_Number = docID
	    Data Type = type (optional)
	    And

     2.  retrieve a fragment of the text of a document:

	    System_Control_Number = docID
	    Data Type = type (optional)
	    And
		Chunk >= start
		And
		Chunk < end
		And

		Information from multiple documents may be requested by using
		groups of the above joined by:

	    OR

		( XXX does an OR come after every group but the first, or do they
	      all come at the end? )

	( XXX return type could be in the element set)
*/

static query_term **makeWAISQueryTerms(DocObj **docs)
/* given a null terminated list of docObjs, construct the appropriate
   query of the form given above
 */
{
    query_term **terms = NULL;
    long numTerms = 0;
    DocObj *doc = NULL;
    long i;

    if (docs == NULL)
	return ((query_term **) NULL);

    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 1));

    terms[numTerms] = NULL;

    /* loop through the docs making terms for them all */
    for (i = 0, doc = docs[i]; doc != NULL; doc = docs[++i]) {
	any *type = NULL;

	if (doc->Type != NULL)
	    type = stringToAny(doc->Type);

	if (doc->ChunkCode == CT_document)	/* a whole document */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms + 2);

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE, IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL,
						      IGNORE, IGNORE, IGNORE,
						      IGNORE, type);
		terms[numTerms++] = makeOperatorTerm(AND);
	    }
	    terms[numTerms] = NULL;
	} else {		/* a document fragment */
	    char chunk_att[ATTRIBUTE_SIZE];
	    any *startChunk = NULL;
	    any *endChunk = NULL;

	    terms = S_REALLOC2(query_term *, terms, numTerms + 6);

	    switch (doc->ChunkCode) {
	    case CT_byte:
	    case CT_line:
		{
		    char start[20], end[20];

		    (doc->ChunkCode == CT_byte) ?
			strncpy(chunk_att, BYTE, ATTRIBUTE_SIZE) :
			strncpy(chunk_att, LINE, ATTRIBUTE_SIZE);
		    sprintf(start, "%ld", doc->ChunkStart.Pos);
		    startChunk = stringToAny(start);
		    sprintf(end, "%ld", doc->ChunkEnd.Pos);
		    endChunk = stringToAny(end);
		}
		break;
	    case CT_paragraph:
		strncpy(chunk_att, PARAGRAPH, ATTRIBUTE_SIZE);
		startChunk = doc->ChunkStart.ID;
		endChunk = doc->ChunkEnd.ID;
		break;
	    default:
		/* error */
		break;
	    }

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE,
						  IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL, IGNORE,
						      IGNORE, IGNORE, IGNORE,
						      type);
		terms[numTerms++] = makeOperatorTerm(AND);
	    }
	    terms[numTerms++] = makeAttributeTerm(chunk_att,
						  GREATER_THAN_OR_EQUAL,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  startChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms++] = makeAttributeTerm(chunk_att, LESS_THAN,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  endChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms] = NULL;

	    if (doc->ChunkCode == CT_byte || doc->ChunkCode == CT_line) {
		freeAny(startChunk);
		freeAny(endChunk);
	    }
	}

	freeAny(type);

	if (i != 0)		/* multiple independent queries, need a disjunction */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms);

	    terms[numTerms++] = makeOperatorTerm(OR);
	    terms[numTerms] = NULL;
	}
    }

    return (terms);
}

/*----------------------------------------------------------------------*/

static DocObj **makeWAISQueryDocs(query_term **terms)
/* given a list of terms in the form given above, convert them to
   DocObjs.
 */
{
    query_term *docTerm = NULL;
    query_term *fragmentTerm = NULL;
    DocObj **docs = NULL;
    DocObj *doc = NULL;
    long docNum, termNum;

    docNum = termNum = 0;

    docs = S_MALLOC(DocObj *);

    docs[docNum] = NULL;

    /* translate the terms into DocObjs */
    while (true) {
	query_term *typeTerm = NULL;
	char *type = NULL;
	long startTermOffset;

	docTerm = terms[termNum];

	if (docTerm == NULL)
	    break;		/* we're done converting */

	typeTerm = terms[termNum + 1];	/* get the lead Term if it exists */

	if (strcmp(typeTerm->Use, DATA_TYPE) == 0)	/* we do have a type */
	{
	    startTermOffset = 3;
	    type = anyToString(typeTerm->Term);
	} else {		/* no type */
	    startTermOffset = 1;
	    typeTerm = NULL;
	    type = NULL;
	}

	/* grow the doc list */
	docs = S_REALLOC2(DocObj *, docs, docNum);

	/* figure out what kind of docObj to build - and build it */
	fragmentTerm = terms[termNum + startTermOffset];
	if (fragmentTerm != NULL && fragmentTerm->TermType == TT_Attribute) {	/* build a document fragment */
	    query_term *startTerm = fragmentTerm;
	    query_term *endTerm = terms[termNum + startTermOffset + 2];

	    if (strcmp(startTerm->Use, BYTE) == 0) {	/* a byte chunk */
		doc = makeDocObjUsingBytes(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("byte");
	    } else if (strcmp(startTerm->Use, LINE) == 0) {	/* a line chunk */
		doc = makeDocObjUsingLines(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("line");
	    } else {
		log_write("chunk");	/* a paragraph chunk */
		doc = makeDocObjUsingParagraphs(duplicateAny(docTerm->Term),
						type,
						duplicateAny(startTerm->Term),
						duplicateAny(endTerm->Term));
	    }
	    termNum += (startTermOffset + 4);	/* point to next term */
	} else {		/* build a full document */
	    doc = makeDocObjUsingWholeDocument(duplicateAny(docTerm->Term),
					       type);
	    log_write("whole doc");
	    termNum += startTermOffset;		/* point to next term */
	}

	docs[docNum++] = doc;	/* insert the new document */

	docs[docNum] = NULL;	/* keep the doc list terminated */

	if (terms[termNum] != NULL)
	    termNum++;		/* skip the OR operator it necessary */
	else
	    break;		/* we are done */
    }

    return (docs);
}

/*----------------------------------------------------------------------*/

any *makeWAISTextQuery(DocObj **docs)
/* given a list of DocObjs, return an any whose contents is the corresponding
   type 1 query
 */
{
    any *buf = NULL;
    query_term **terms = NULL;

    terms = makeWAISQueryTerms(docs);
    buf = writeQuery(terms);

    doList((void **) terms, freeTerm);
    s_free(terms);

    return (buf);
}

/*----------------------------------------------------------------------*/

DocObj **readWAISTextQuery(any *buf)
/* given an any whose contents are type 1 queries of the WAIS sort,
   construct a list of the corresponding DocObjs
 */
{
    query_term **terms = NULL;
    DocObj **docs = NULL;

    terms = readQuery(buf);
    docs = makeWAISQueryDocs(terms);

    doList((void **) terms, freeTerm);
    s_free(terms);

    return (docs);
}

/*----------------------------------------------------------------------*/
/* Customized free WAIS object routines:                                */
/*                                                                      */
/*   This set of procedures is for applications to free a WAIS object   */
/*   which was made with makeWAISFOO.                                   */
/*   Each procedure frees only the memory that was allocated in its     */
/*   associated makeWAISFOO routine, thus it's not necessary for the    */
/*   caller to assign nulls to the pointer fields of the WAIS object.  */
/*----------------------------------------------------------------------*/

void CSTFreeWAISInitResponse(WAISInitResponse *init)
/* free an object made with makeWAISInitResponse */
{
    s_free(init);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISSearch(WAISSearch *query)
/* destroy an object made with makeWAISSearch() */
{
    s_free(query);
}

/*----------------------------------------------------------------------*/

void CSTFreeDocObj(DocObj *doc)
/* free a docObj */
{
    s_free(doc);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentHeader(WAISDocumentHeader *header)
{
    s_free(header);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
{
    s_free(header);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
{
    s_free(header);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISSearchResponse(WAISSearchResponse * response)
{
    s_free(response);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentText(WAISDocumentText *docText)
{
    s_free(docText);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocHeadlines(WAISDocumentHeadlines *docHeadline)
{
    s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentCodes(WAISDocumentCodes *docCodes)
{
    s_free(docCodes);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISTextQuery(any *query)
{
    freeAny(query);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from WMessage.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 * 3.26.90
 */

/* This file is for reading and writing the wais packet header.
 * Morris@@think.com
 */

/* to do:
 *  add check sum
 *  what do you do when checksum is wrong?
 */

/*---------------------------------------------------------------------*/

void readWAISPacketHeader(char *msgBuffer,
			  WAISMessage * header_struct)
{
    /* msgBuffer is a string containing at least HEADER_LENGTH bytes. */

    memmove(header_struct->msg_len, msgBuffer, (size_t) 10);
    header_struct->msg_type = char_downcase((unsigned long) msgBuffer[10]);
    header_struct->hdr_vers = char_downcase((unsigned long) msgBuffer[11]);
    memmove(header_struct->server, (void *) (msgBuffer + 12), (size_t) 10);
    header_struct->compression = char_downcase((unsigned long) msgBuffer[22]);
    header_struct->encoding = char_downcase((unsigned long) msgBuffer[23]);
    header_struct->msg_checksum = char_downcase((unsigned long) msgBuffer[24]);
}

/*---------------------------------------------------------------------*/

/* this modifies the header argument.  See wais-message.h for the different
 * options for the arguments.
 */

void writeWAISPacketHeader(char *header,
			   long dataLen,
			   long type,
			   char *server,
			   long compression,
			   long encoding,
			   long version)
/* Puts together the new wais before-the-z39-packet header. */
{
    char lengthBuf[11];
    char serverBuf[11];

    long serverLen = strlen(server);

    if (serverLen > 10)
	serverLen = 10;

    sprintf(lengthBuf, "%010ld", dataLen);
    strncpy(header, lengthBuf, 10);

    header[10] = type & 0xFF;
    header[11] = version & 0xFF;

    strncpy(serverBuf, server, serverLen);
    strncpy((char *) (header + 12), serverBuf, serverLen);

    header[22] = compression & 0xFF;
    header[23] = encoding & 0xFF;
    header[24] = '0';		/* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */
}

/*---------------------------------------------------------------------*/
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 6
a7 6
**
**	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
**
**	31-May-1994 FM	Initial version.
**
**----------------------------------------------------------------------*/
d10 3
a12 3
**	Routines originally from WProt.c -- FM
**
**----------------------------------------------------------------------*/
d14 2
a15 2
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.
d17 11
a27 11
   3.26.90	Harry Morris, morris@@think.com
   3.30.90  Harry Morris
   -	removed chunk code from WAISSearchAPDU,
   -	added makeWAISQueryType1Query() and readWAISType1Query() which replace
   makeWAISQueryTerms() and makeWAISQueryDocs().
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
   - renamed makeWAISType1Query() to makeWAISTextQuery()
   renamed readWAISType1Query() to readWAISTextQuery()
   5.29.90  TS - fixed bug in makeWAISQueryDocs
   added CSTFreeWAISFoo functions
*/
a39 1

d57 5
d64 2
a65 7
static unsigned long userInfoTagSize (data_tag tag,
					  unsigned long length);

static unsigned long
userInfoTagSize(tag,length)
data_tag tag;
unsigned long length;
d70 1
a70 1
  unsigned long size;
d72 3
a74 3
  /* calculate bytes required to represent tag.  max tag is 16K */
  size = writtenCompressedIntSize(tag);
  size += writtenCompressedIntSize(length);
d76 1
a76 1
  return(size);
d81 5
a85 11
static char* writeUserInfoHeader PARAMS((data_tag tag,long infoSize,
				      long estHeaderSize,char* buffer,
				      long* len));

static char*
writeUserInfoHeader(tag,infoSize,estHeaderSize,buffer,len)
data_tag tag;
long infoSize;
long estHeaderSize;
char* buffer;
long* len;
d94 16
a109 17
  long dummyLen = 100;		/* plenty of space for a tag and size */
  char* buf = buffer;
  long realSize = infoSize - estHeaderSize;
  long realHeaderSize = userInfoTagSize(tag,realSize);

  if (buffer == NULL || *len == 0)
    return(NULL);

  /* write the tag */
  buf = writeTag(tag,buf,&dummyLen);

  /* see if the if the header size was correct. if not,
     we have to shift the info to fit the real header size */
  if (estHeaderSize != realHeaderSize)
    {				/* make sure there is enough space */
      CHECK_FOR_SPACE_LEFT(realHeaderSize - estHeaderSize,len);
      memmove(buffer + realHeaderSize,buffer + estHeaderSize,(size_t)(realSize));
d112 2
a113 2
  /* write the size */
  writeCompressedInteger(realSize,buf,&dummyLen);
d115 2
a116 2
  /* return the true end of buffer */
  return(buffer + realHeaderSize + realSize);
d121 3
a123 8
static char* readUserInfoHeader (data_tag* tag,unsigned long* num,
				     char* buffer);

static char*
readUserInfoHeader(tag,num,buffer)
data_tag* tag;
unsigned long* num;
char* buffer;
d126 5
a130 4
  char* buf = buffer;
  buf = readTag(tag,buf);
  buf = readCompressedInteger(num,buf);
  return(buf);
d135 6
a140 13
WAISInitResponse*
makeWAISInitResponse(chunkCode,
		     chunkIDLen,
		     chunkMarker,
		     highlightMarker,
		     deHighlightMarker,
		     newLineChars)
long chunkCode;
long chunkIDLen;
char* chunkMarker;
char* highlightMarker;
char* deHighlightMarker;
char* newLineChars;
d143 1
a143 1
  WAISInitResponse* init = (WAISInitResponse*)s_malloc((size_t)sizeof(WAISInitResponse));
d145 6
a150 6
  init->ChunkCode = chunkCode;	/* note: none are copied! */
  init->ChunkIDLength = chunkIDLen;
  init->ChunkMarker = chunkMarker;
  init->HighlightMarker = highlightMarker;
  init->DeHighlightMarker = deHighlightMarker;
  init->NewlineCharacters = newLineChars;
d152 1
a152 1
  return(init);
d157 1
a157 3
void
freeWAISInitResponse(init)
WAISInitResponse* init;
d160 5
a164 5
  s_free(init->ChunkMarker);
  s_free(init->HighlightMarker);
  s_free(init->DeHighlightMarker);
  s_free(init->NewlineCharacters);
  s_free(init);
d169 3
a171 5
char*
writeInitResponseInfo(init,buffer,len)
InitResponseAPDU* init;
char* buffer;
long* len;
d174 5
a178 5
  unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					     DefWAISInitResponseSize);
  char* buf = buffer + header_len;
  WAISInitResponse* info = (WAISInitResponse*)init->UserInformationField;
  unsigned long size;
d180 1
a180 1
  RESERVE_SPACE_FOR_WAIS_HEADER(len);
d182 6
a187 6
  buf = writeNum(info->ChunkCode,DT_ChunkCode,buf,len);
  buf = writeNum(info->ChunkIDLength,DT_ChunkIDLength,buf,len);
  buf = writeString(info->ChunkMarker,DT_ChunkMarker,buf,len);
  buf = writeString(info->HighlightMarker,DT_HighlightMarker,buf,len);
  buf = writeString(info->DeHighlightMarker,DT_DeHighlightMarker,buf,len);
  buf = writeString(info->NewlineCharacters,DT_NewlineCharacters,buf,len);
d189 7
a195 3
  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_UserInformationLength,size,header_len,buffer,len);
d197 1
a197 1
  return(buf);
d202 2
a203 4
char*
readInitResponseInfo(info,buffer)
void** info;
char* buffer;
d206 30
a235 29
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  long chunkCode,chunkIDLen;
  data_tag tag1;
  char* chunkMarker = NULL;
  char* highlightMarker = NULL;
  char* deHighlightMarker = NULL;
  char* newLineChars = NULL;

  chunkCode = chunkIDLen = UNUSED;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_ChunkCode:
	    buf = readNum(&chunkCode,buf);
	    break;
	  case DT_ChunkIDLength:
	    buf = readNum(&chunkIDLen,buf);
	    break;
	  case DT_ChunkMarker:
	    buf = readString(&chunkMarker,buf);
	    break;
	  case DT_HighlightMarker:
	    buf = readString(&highlightMarker,buf);
d237 2
a238 2
	  case DT_DeHighlightMarker:
	    buf = readString(&deHighlightMarker,buf);
d240 2
a241 2
	  case DT_NewlineCharacters:
	    buf = readString(&newLineChars,buf);
d243 1
a243 1
	  default:
d249 1
a249 1
	  }
d252 4
a255 4
  *info = (void *)makeWAISInitResponse(chunkCode,chunkIDLen,chunkMarker,
			       highlightMarker,deHighlightMarker,
			       newLineChars);
  return(buf);
d260 7
a266 15
WAISSearch*
makeWAISSearch(seedWords,
	       docs,
	       textList,
	       dateFactor,
	       beginDateRange,
	       endDateRange,
	       maxDocsRetrieved)
char* seedWords;
DocObj** docs;
char** textList;
long dateFactor;
char* beginDateRange;
char* endDateRange;
long maxDocsRetrieved;
d270 1
a270 1
  WAISSearch* query = (WAISSearch*)s_malloc((size_t)sizeof(WAISSearch));
d272 7
a278 7
  query->SeedWords = seedWords;	/* not copied! */
  query->Docs = docs;		/* not copied! */
  query->TextList = textList;	/* not copied! */
  query->DateFactor = dateFactor;
  query->BeginDateRange = beginDateRange;
  query->EndDateRange = endDateRange;
  query->MaxDocumentsRetrieved = maxDocsRetrieved;
d280 1
a280 1
  return(query);
d285 1
a285 3
void
freeWAISSearch(query)
WAISSearch* query;
d289 2
a290 2
  void* ptr = NULL;
  long i;
d292 1
a292 1
  s_free(query->SeedWords);
d294 6
a299 4
  if (query->Docs != NULL)
    for (i = 0,ptr = (void *)query->Docs[i]; ptr != NULL; ptr = (void *)query->Docs[++i])
      freeDocObj((DocObj*)ptr);
  s_free(query->Docs);
d301 6
a306 4
  if (query->TextList != NULL)	/* XXX revisit when textlist is fully defined */
    for (i = 0,ptr = (void *)query->TextList[i]; ptr != NULL; ptr = (void *)query->TextList[++i])
      s_free(ptr);
  s_free(query->TextList);
d308 3
a310 3
  s_free(query->BeginDateRange);
  s_free(query->EndDateRange);
  s_free(query);
d315 2
a316 4
DocObj*
makeDocObjUsingWholeDocument(docID,type)
any* docID;
char* type;
d321 6
a326 5
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->DocumentID = docID;		/* not copied! */
  doc->Type = type;		/* not copied! */
  doc->ChunkCode = CT_document;
  return(doc);
d331 4
a334 6
DocObj*
makeDocObjUsingLines(docID,type,start,end)
any* docID;
char* type;
long start;
long end;
d339 8
a346 7
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->ChunkCode = CT_line;
  doc->DocumentID = docID;		/* not copied */
  doc->Type = type;		/* not copied! */
  doc->ChunkStart.Pos = start;
  doc->ChunkEnd.Pos = end;
  return(doc);
d351 4
a354 6
DocObj*
makeDocObjUsingBytes(docID,type,start,end)
any* docID;
char* type;
long start;
long end;
d359 8
a366 7
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->ChunkCode = CT_byte;
  doc->DocumentID = docID;		/* not copied */
  doc->Type = type;		/* not copied! */
  doc->ChunkStart.Pos = start;
  doc->ChunkEnd.Pos = end;
  return(doc);
d371 4
a374 6
DocObj*
makeDocObjUsingParagraphs(docID,type,start,end)
any* docID;
char* type;
any* start;
any* end;
d379 8
a386 7
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->ChunkCode = CT_paragraph;
  doc->DocumentID = docID;		/* not copied */
  doc->Type = type;
  doc->ChunkStart.ID = start;
  doc->ChunkEnd.ID = end;
  return(doc);
d391 1
a391 3
void
freeDocObj(doc)
DocObj* doc;
d395 5
a399 5
  freeAny(doc->DocumentID);
  s_free(doc->Type);
  if (doc->ChunkCode == CT_paragraph)
    { freeAny(doc->ChunkStart.ID);
      freeAny(doc->ChunkEnd.ID);
d401 1
a401 1
  s_free(doc);
d406 3
a408 7
static char* writeDocObj (DocObj* doc,char* buffer,long* len);

static char*
writeDocObj(doc,buffer,len)
DocObj* doc;
char* buffer;
long* len;
d412 1
a412 1
  char* buf = buffer;
d414 5
a418 5
  /* we alwasy have to write the id, but its tag depends on if its a chunk */
  if (doc->ChunkCode == CT_document)
    buf = writeAny(doc->DocumentID,DT_DocumentID,buf,len);
  else
    buf = writeAny(doc->DocumentID,DT_DocumentIDChunk,buf,len);
d420 2
a421 2
  if (doc->Type != NULL)
    buf = writeString(doc->Type,DT_TYPE,buf,len);
d423 2
a424 2
  switch (doc->ChunkCode)
    { case CT_document:
d427 5
a431 5
      case CT_byte:
      case CT_line:
	buf = writeNum(doc->ChunkCode,DT_ChunkCode,buf,len);
	buf = writeNum(doc->ChunkStart.Pos,DT_ChunkStartID,buf,len);
	buf = writeNum(doc->ChunkEnd.Pos,DT_ChunkEndID,buf,len);
d433 4
a436 4
      case CT_paragraph:
	buf = writeNum(doc->ChunkCode,DT_ChunkCode,buf,len);
	buf = writeAny(doc->ChunkStart.ID,DT_ChunkStartID,buf,len);
	buf = writeAny(doc->ChunkEnd.ID,DT_ChunkEndID,buf,len);
d438 1
a438 1
      default:
d442 1
a442 1
      }
d444 1
a444 1
  return(buf);
d449 2
a450 6
static char* readDocObj (DocObj** doc,char* buffer);

static char*
readDocObj(doc,buffer)
DocObj** doc;
char* buffer;
d454 2
a455 2
  char* buf = buffer;
  data_tag tag;
d457 1
a457 1
  *doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
d459 2
a460 2
  tag = peekTag(buf);
  buf = readAny(&((*doc)->DocumentID),buf);
d462 18
a479 18
  if (tag == DT_DocumentID)
    { (*doc)->ChunkCode = CT_document;
      tag = peekTag(buf);
      if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != what comes next */
	buf = readString(&((*doc)->Type),buf);
      /* ChunkStart and ChunkEnd are undefined */
    }
  else if (tag == DT_DocumentIDChunk)
    { boolean readParagraphs = false; /* for cleanup */
      tag = peekTag(buf);
      if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != CT_FOO */
	buf = readString(&((*doc)->Type),buf);
      buf = readNum(&((*doc)->ChunkCode),buf);
      switch ((*doc)->ChunkCode)
	{ case CT_byte:
	  case CT_line:
	    buf = readNum(&((*doc)->ChunkStart.Pos),buf);
	    buf = readNum(&((*doc)->ChunkEnd.Pos),buf);
d481 1
a481 1
	  case CT_paragraph:
d483 2
a484 2
	    buf = readAny(&((*doc)->ChunkStart.ID),buf);
	    buf = readAny(&((*doc)->ChunkEnd.ID),buf);
d486 1
a486 1
	  default:
d488 2
a489 2
	    if (readParagraphs)
	      { freeAny((*doc)->ChunkStart.ID);
d491 1
a491 1
	      }
d495 5
a499 1
	  }
d501 1
a501 6
  else
    { freeAny((*doc)->DocumentID);
      s_free(*doc);
      REPORT_READ_ERROR(buf);
    }
  return(buf);
d506 3
a508 5
char*
writeSearchInfo(query,buffer,len)
SearchAPDU* query;
char* buffer;
long* len;
d512 18
a529 19
  if (strcmp(query->QueryType,QT_TextRetrievalQuery) == 0)
    { return(writeAny((any*)query->Query,DT_Query,buffer,len));
    }
  else
    { unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
						 DefWAISSearchSize);
      char* buf = buffer + header_len;
      WAISSearch* info = (WAISSearch*)query->Query;
      unsigned long size;
      long i;

      RESERVE_SPACE_FOR_WAIS_HEADER(len);

      buf = writeString(info->SeedWords,DT_SeedWords,buf,len);

      if (info->Docs != NULL)
      { for (i = 0; info->Docs[i] != NULL; i++)
	  { buf = writeDocObj(info->Docs[i],buf,len);
	  }
d532 1
a532 6
      /* XXX text list */

      buf = writeNum(info->DateFactor,DT_DateFactor,buf,len);
      buf = writeString(info->BeginDateRange,DT_BeginDateRange,buf,len);
      buf = writeString(info->EndDateRange,DT_EndDateRange,buf,len);
      buf = writeNum(info->MaxDocumentsRetrieved,DT_MaxDocumentsRetrieved,buf,len);
d534 24
a557 3
      /* now write the header and size */
      size = buf - buffer;
      buf = writeUserInfoHeader(DT_UserInformationLength,size,header_len,buffer,len);
d559 1
a559 1
      return(buf);
d565 2
a566 4
char*
readSearchInfo(info,buffer)
void** info;
char* buffer;
d570 37
a606 34
  data_tag type = peekTag(buffer);
  if (type == DT_Query)		/* this is a type 1 query */
    { char* buf = buffer;
      any* query = NULL;
      buf = readAny(&query,buf);
      *info = (void *)query;
      return(buf);
    }
  else				/* a type 3 query */
    { char* buf = buffer;
      unsigned long size;
      unsigned long headerSize;
      data_tag tag1;
      char* seedWords = NULL;
      char* beginDateRange = NULL;
      char* endDateRange = NULL;
      long dateFactor,maxDocsRetrieved;
      char** textList = NULL;
      DocObj** docIDs = NULL;
      DocObj* doc = NULL;
      long docs = 0;
      long i;
      void* ptr = NULL;

      dateFactor = maxDocsRetrieved = UNUSED;

      buf = readUserInfoHeader(&tag1,&size,buf);
      headerSize = buf - buffer;

      while (buf < (buffer + size + headerSize))
	{ data_tag tag = peekTag(buf);
	  switch (tag)
	    { case DT_SeedWords:
		buf = readString(&seedWords,buf);
d608 11
a618 11
	      case DT_DocumentID:
	      case DT_DocumentIDChunk:
		if (docIDs == NULL) /* create a new doc list */
		  { docIDs = (DocObj**)s_malloc((size_t)sizeof(DocObj*) * 2);
		  }
		else		/* grow the doc list */
		  { docIDs = (DocObj**)s_realloc((char*)docIDs,(size_t)(sizeof(DocObj*) * (docs + 2)));
		  }
		buf = readDocObj(&doc,buf);
		if (buf == NULL)
		  { s_free(seedWords);
d622 4
a625 2
		      for (i = 0,ptr = (void *)docIDs[i]; ptr != NULL; ptr = (void *)docIDs[++i])
			freeDocObj((DocObj*)ptr);
d628 1
a628 1
		  }
d630 1
a630 1
		docIDs[docs++] = doc; /* put it in the list */
d633 1
a633 1
	      case DT_TextList:
d636 2
a637 2
	      case DT_DateFactor:
		buf = readNum(&dateFactor,buf);
d639 2
a640 2
	      case DT_BeginDateRange:
		buf = readString(&beginDateRange,buf);
d642 2
a643 2
	      case DT_EndDateRange:
		buf = readString(&endDateRange,buf);
d645 2
a646 2
	      case DT_MaxDocumentsRetrieved:
		buf = readNum(&maxDocsRetrieved,buf);
d648 1
a648 1
	      default:
d653 4
a656 2
		  for (i = 0,ptr = (void *)docIDs[i]; ptr != NULL; ptr = (void *)docIDs[++i])
		    freeDocObj((DocObj*)ptr);
d661 1
a661 1
	      }
d664 4
a667 4
      *info = (void *)makeWAISSearch(seedWords,docIDs,textList,
				     dateFactor,beginDateRange,endDateRange,
				     maxDocsRetrieved);
      return(buf);
d673 11
a683 23
WAISDocumentHeader*
makeWAISDocumentHeader(docID,
		       versionNumber,
		       score,
		       bestMatch,
		       docLen,
		       lines,
		       types,
		       source,
		       date,
		       headline,
		       originCity)
any* docID;
long versionNumber;
long score;
long bestMatch;
long docLen;
long lines;
char** types;
char* source;
char* date;
char* headline;
char* originCity;
d690 30
a719 2
  WAISDocumentHeader* header =
    (WAISDocumentHeader*)s_malloc((size_t)sizeof(WAISDocumentHeader));
d721 32
a752 63
  header->DocumentID = docID;
  header->VersionNumber = versionNumber;
  header->Score = score;
  header->BestMatch = bestMatch;
  header->DocumentLength = docLen;
  header->Lines = lines;
  header->Types = types;
  header->Source = source;
  header->Date = date;
  header->Headline = headline;
  header->OriginCity = originCity;

  return(header);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentHeader(header)
WAISDocumentHeader* header;

{
  freeAny(header->DocumentID);
  doList((void**)header->Types,fs_free); /* can't use the macro here ! */
  s_free(header->Types);
  s_free(header->Source);
  s_free(header->Date);
  s_free(header->Headline);
  s_free(header->OriginCity);
  s_free(header);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentHeader(header,buffer,len)
WAISDocumentHeader* header;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentHeaderGroup ,
					     DefWAISDocHeaderSize);
  char* buf = buffer + header_len;
  unsigned long size1;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(header->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(header->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeNum(header->Score,DT_Score,buf,len);
  buf = writeNum(header->BestMatch,DT_BestMatch,buf,len);
  buf = writeNum(header->DocumentLength,DT_DocumentLength,buf,len);
  buf = writeNum(header->Lines,DT_Lines,buf,len);
  if (header->Types != NULL)
    { long size;
      char* ptr = NULL;
      long i;
      buf = writeTag(DT_TYPE_BLOCK,buf,len);
      for (i = 0,size = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	{ long typeSize = strlen(ptr);
	  size += writtenTagSize(DT_TYPE);
	  size += writtenCompressedIntSize(typeSize);
	  size += typeSize;
d754 80
a833 74
      buf = writeCompressedInteger((unsigned long)size,buf,len);
      for (i = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	buf = writeString(ptr,DT_TYPE,buf,len);
    }
  buf = writeString(header->Source,DT_Source,buf,len);
  buf = writeString(header->Date,DT_Date,buf,len);
  buf = writeString(header->Headline,DT_Headline,buf,len);
  buf = writeString(header->OriginCity,DT_OriginCity,buf,len);

  /* now write the header and size */
  size1 = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentHeaderGroup,size1,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentHeader(header,buffer)
WAISDocumentHeader** header;
char* buffer;
{
  char* buf = buffer;
  unsigned long size1;
  unsigned long headerSize;
  data_tag tag1;
  any* docID = NULL;
  long versionNumber,score,bestMatch,docLength,lines;
  char** types = NULL;
  char *source = NULL;
  char *date = NULL;
  char *headline = NULL;
  char *originCity = NULL;

  versionNumber = score = bestMatch = docLength = lines = UNUSED;

  buf = readUserInfoHeader(&tag1,&size1,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size1 + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_DocumentID:
	    buf = readAny(&docID,buf);
	    break;
	  case DT_VersionNumber:
	    buf = readNum(&versionNumber,buf);
	    break;
	  case DT_Score:
	    buf = readNum(&score,buf);
	    break;
	  case DT_BestMatch:
	    buf = readNum(&bestMatch,buf);
	    break;
	  case DT_DocumentLength:
	    buf = readNum(&docLength,buf);
	    break;
	  case DT_Lines:
	    buf = readNum(&lines,buf);
	    break;
	  case DT_TYPE_BLOCK:
	    { unsigned long size = -1;
	      long numTypes = 0;
	      buf = readTag(&tag,buf);
	      buf = readCompressedInteger(&size,buf);
	      while (size > 0)
		{ char* type = NULL;
		  char* originalBuf = buf;
		  buf = readString(&type,buf);
		  types = (char**)s_realloc(types,(size_t)(sizeof(char*) * (numTypes + 2)));
		  types[numTypes++] = type;
		  types[numTypes] = NULL;
		  size -= (buf - originalBuf);
d837 2
a838 2
	  case DT_Source:
	    buf = readString(&source,buf);
d840 2
a841 2
	  case DT_Date:
	    buf = readString(&date,buf);
d843 2
a844 2
	  case DT_Headline:
	    buf = readString(&headline,buf);
d846 2
a847 2
	  case DT_OriginCity:
	    buf = readString(&originCity,buf);
d849 1
a849 1
	  default:
d857 1
a857 1
	  }
d860 4
a863 4
  *header = makeWAISDocumentHeader(docID,versionNumber,score,bestMatch,
				   docLength,lines,types,source,date,headline,
				   originCity);
  return(buf);
d868 6
a873 13
WAISDocumentShortHeader*
makeWAISDocumentShortHeader(docID,
			    versionNumber,
			    score,
			    bestMatch,
			    docLen,
			    lines)
any* docID;
long versionNumber;
long score;
long bestMatch;
long docLen;
long lines;
d879 1
a879 2
  WAISDocumentShortHeader* header =
    (WAISDocumentShortHeader*)s_malloc((size_t)sizeof(WAISDocumentShortHeader));
d881 6
a886 6
  header->DocumentID = docID;
  header->VersionNumber = versionNumber;
  header->Score = score;
  header->BestMatch = bestMatch;
  header->DocumentLength = docLen;
  header->Lines = lines;
d888 1
a888 1
  return(header);
d893 1
a893 3
void
freeWAISDocumentShortHeader(header)
WAISDocumentShortHeader* header;
d895 2
a896 2
  freeAny(header->DocumentID);
  s_free(header);
d901 2
a902 5
char*
writeWAISDocumentShortHeader(header,buffer,len)
WAISDocumentShortHeader* header;
char* buffer;
long* len;
d904 4
a907 4
  unsigned long header_len = userInfoTagSize(DT_DocumentShortHeaderGroup ,
					     DefWAISShortHeaderSize);
  char* buf = buffer + header_len;
  unsigned long size;
d909 1
a909 1
  RESERVE_SPACE_FOR_WAIS_HEADER(len);
d911 6
a916 6
  buf = writeAny(header->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(header->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeNum(header->Score,DT_Score,buf,len);
  buf = writeNum(header->BestMatch,DT_BestMatch,buf,len);
  buf = writeNum(header->DocumentLength,DT_DocumentLength,buf,len);
  buf = writeNum(header->Lines,DT_Lines,buf,len);
d918 7
a924 3
  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentShortHeaderGroup,size,header_len,buffer,len);
d926 1
a926 1
  return(buf);
d931 1
a931 4
char*
readWAISDocumentShortHeader(header,buffer)
WAISDocumentShortHeader** header;
char* buffer;
d933 8
a940 6
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any* docID = NULL;
  long versionNumber,score,bestMatch,docLength,lines;
d942 2
a943 1
  versionNumber = score = bestMatch = docLength = lines = UNUSED;
d945 2
a946 2
  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;
d948 3
a950 5
  while (buf < (buffer + size + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_DocumentID:
	    buf = readAny(&docID,buf);
d952 2
a953 2
	  case DT_VersionNumber:
	    buf = readNum(&versionNumber,buf);
d955 2
a956 2
	  case DT_Score:
	    buf = readNum(&score,buf);
d958 2
a959 2
	  case DT_BestMatch:
	    buf = readNum(&bestMatch,buf);
d961 2
a962 2
	  case DT_DocumentLength:
	    buf = readNum(&docLength,buf);
d964 2
a965 2
	  case DT_Lines:
	    buf = readNum(&lines,buf);
d967 1
a967 1
	  default:
d971 1
a971 1
	  }
d974 3
a976 3
  *header = makeWAISDocumentShortHeader(docID,versionNumber,score,bestMatch,
					docLength,lines);
  return(buf);
d981 14
a994 29
WAISDocumentLongHeader*
makeWAISDocumentLongHeader(docID,
			   versionNumber,
			   score,
			   bestMatch,
			   docLen,
			   lines,
			   types,
			   source,
			   date,
			   headline,
			   originCity,
			   stockCodes,
			   companyCodes,
			   industryCodes)
any* docID;
long versionNumber;
long score;
long bestMatch;
long docLen;
long lines;
char** types;
char* source;
char* date;
char* headline;
char* originCity;
char* stockCodes;
char* companyCodes;
char* industryCodes;
d1000 21
a1020 2
  WAISDocumentLongHeader* header =
    (WAISDocumentLongHeader*)s_malloc((size_t)sizeof(WAISDocumentLongHeader));
d1022 46
a1067 67
  header->DocumentID = docID;
  header->VersionNumber = versionNumber;
  header->Score = score;
  header->BestMatch = bestMatch;
  header->DocumentLength = docLen;
  header->Lines = lines;
  header->Types = types;
  header->Source = source;
  header->Date = date;
  header->Headline = headline;
  header->OriginCity = originCity;
  header->StockCodes = stockCodes;
  header->CompanyCodes = companyCodes;
  header->IndustryCodes = industryCodes;

  return(header);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentLongHeader(header)
WAISDocumentLongHeader* header;
{
  freeAny(header->DocumentID);
  doList((void**)header->Types,fs_free); /* can't use the macro here! */
  s_free(header->Source);
  s_free(header->Date);
  s_free(header->Headline);
  s_free(header->OriginCity);
  s_free(header->StockCodes);
  s_free(header->CompanyCodes);
  s_free(header->IndustryCodes);
  s_free(header);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentLongHeader(header,buffer,len)
WAISDocumentLongHeader* header;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentLongHeaderGroup ,
					     DefWAISLongHeaderSize);
  char* buf = buffer + header_len;
  unsigned long size1;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(header->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(header->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeNum(header->Score,DT_Score,buf,len);
  buf = writeNum(header->BestMatch,DT_BestMatch,buf,len);
  buf = writeNum(header->DocumentLength,DT_DocumentLength,buf,len);
  buf = writeNum(header->Lines,DT_Lines,buf,len);
  if (header->Types != NULL)
    { long size;
      char* ptr = NULL;
      long i;
      buf = writeTag(DT_TYPE_BLOCK,buf,len);
      for (i = 0,size = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	{ long typeSize = strlen(ptr);
	  size += writtenTagSize(DT_TYPE);
	  size += writtenCompressedIntSize(typeSize);
	  size += typeSize;
d1069 93
a1161 77
      buf = writeCompressedInteger((unsigned long)size,buf,len);
      for (i = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	buf = writeString(ptr,DT_TYPE,buf,len);
    }
  buf = writeString(header->Source,DT_Source,buf,len);
  buf = writeString(header->Date,DT_Date,buf,len);
  buf = writeString(header->Headline,DT_Headline,buf,len);
  buf = writeString(header->OriginCity,DT_OriginCity,buf,len);
  buf = writeString(header->StockCodes,DT_StockCodes,buf,len);
  buf = writeString(header->CompanyCodes,DT_CompanyCodes,buf,len);
  buf = writeString(header->IndustryCodes,DT_IndustryCodes,buf,len);

  /* now write the header and size */
  size1 = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentLongHeaderGroup,size1,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentLongHeader(header,buffer)
WAISDocumentLongHeader** header;
char* buffer;
{
  char* buf = buffer;
  unsigned long size1;
  unsigned long headerSize;
  data_tag tag1;
  any* docID;
  long versionNumber,score,bestMatch,docLength,lines;
  char **types;
  char *source,*date,*headline,*originCity,*stockCodes,*companyCodes,*industryCodes;

  docID = NULL;
  versionNumber = score = bestMatch = docLength = lines = UNUSED;
  types = NULL;
  source = date = headline = originCity = stockCodes = companyCodes = industryCodes = NULL;

  buf = readUserInfoHeader(&tag1,&size1,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size1 + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_DocumentID:
	    buf = readAny(&docID,buf);
	    break;
	  case DT_VersionNumber:
	    buf = readNum(&versionNumber,buf);
	    break;
	  case DT_Score:
	    buf = readNum(&score,buf);
	    break;
	  case DT_BestMatch:
	    buf = readNum(&bestMatch,buf);
	    break;
	  case DT_DocumentLength:
	    buf = readNum(&docLength,buf);
	    break;
	  case DT_Lines:
	    buf = readNum(&lines,buf);
	    break;
	  case DT_TYPE_BLOCK:
	    { unsigned long size = -1;
	      long numTypes = 0;
	      buf = readTag(&tag,buf);
	      readCompressedInteger(&size,buf);
	      while (size > 0)
		{ char* type = NULL;
		  char* originalBuf = buf;
		  buf = readString(&type,buf);
		  types = (char**)s_realloc(types,(size_t)(sizeof(char*) * (numTypes + 2)));
		  types[numTypes++] = type;
		  types[numTypes] = NULL;
		  size -= (buf - originalBuf);
d1165 2
a1166 2
	  case DT_Source:
	    buf = readString(&source,buf);
d1168 2
a1169 2
	  case DT_Date:
	    buf = readString(&date,buf);
d1171 2
a1172 2
	  case DT_Headline:
	    buf = readString(&headline,buf);
d1174 2
a1175 2
	  case DT_OriginCity:
	    buf = readString(&originCity,buf);
d1177 2
a1178 2
	  case DT_StockCodes:
	    buf = readString(&stockCodes,buf);
d1180 2
a1181 2
	  case DT_CompanyCodes:
	    buf = readString(&companyCodes,buf);
d1183 2
a1184 2
	  case DT_IndustryCodes:
	    buf = readString(&industryCodes,buf);
d1186 1
a1186 1
	  default:
d1197 157
a1353 1
	  }
d1356 45
a1400 177
  *header = makeWAISDocumentLongHeader(docID,versionNumber,score,bestMatch,
				       docLength,lines,types,source,date,headline,
				       originCity,stockCodes,companyCodes,
				       industryCodes);
  return(buf);
}

/*----------------------------------------------------------------------*/

WAISSearchResponse*
makeWAISSearchResponse(seedWordsUsed,
		       docHeaders,
		       shortHeaders,
		       longHeaders,
		       text,
		       headlines,
		       codes,
		       diagnostics)
char* seedWordsUsed;
WAISDocumentHeader** docHeaders;
WAISDocumentShortHeader** shortHeaders;
WAISDocumentLongHeader** longHeaders;
WAISDocumentText** text;
WAISDocumentHeadlines** headlines;
WAISDocumentCodes** codes;
diagnosticRecord** diagnostics;
{
  WAISSearchResponse* response = (WAISSearchResponse*)s_malloc((size_t)sizeof(WAISSearchResponse));

  response->SeedWordsUsed = seedWordsUsed;
  response->DocHeaders = docHeaders;
  response->ShortHeaders = shortHeaders;
  response->LongHeaders = longHeaders;
  response->Text = text;
  response->Headlines = headlines;
  response->Codes = codes;
  response->Diagnostics = diagnostics;

  return(response);
}

/*----------------------------------------------------------------------*/

void
freeWAISSearchResponse(response)
WAISSearchResponse* response;
{
  void* ptr = NULL;
  long i;

  s_free(response->SeedWordsUsed);

  if (response->DocHeaders != NULL)
    for (i = 0,ptr = (void *)response->DocHeaders[i]; ptr != NULL; ptr = (void *)response->DocHeaders[++i])
      freeWAISDocumentHeader((WAISDocumentHeader*)ptr);
  s_free(response->DocHeaders);

  if (response->ShortHeaders != NULL)
    for (i = 0,ptr = (void *)response->ShortHeaders[i]; ptr != NULL; ptr = (void *)response->ShortHeaders[++i])
      freeWAISDocumentShortHeader((WAISDocumentShortHeader*)ptr);
  s_free(response->ShortHeaders);

  if (response->LongHeaders != NULL)
    for (i = 0,ptr = (void *)response->LongHeaders[i]; ptr != NULL; ptr = (void *)response->LongHeaders[++i])
      freeWAISDocumentLongHeader((WAISDocumentLongHeader*)ptr);
  s_free(response->LongHeaders);

  if (response->Text != NULL)
    for (i = 0,ptr = (void *)response->Text[i]; ptr != NULL; ptr = (void *)response->Text[++i])
      freeWAISDocumentText((WAISDocumentText*)ptr);
  s_free(response->Text);

  if (response->Headlines != NULL)
    for (i = 0,ptr = (void *)response->Headlines[i]; ptr != NULL; ptr = (void *)response->Headlines[++i])
      freeWAISDocumentHeadlines((WAISDocumentHeadlines*)ptr);
  s_free(response->Headlines);

  if (response->Codes != NULL)
    for (i = 0,ptr = (void *)response->Codes[i]; ptr != NULL; ptr = (void *)response->Codes[++i])
      freeWAISDocumentCodes((WAISDocumentCodes*)ptr);
  s_free(response->Codes);

  if (response->Diagnostics != NULL)
    for (i = 0,ptr = (void *)response->Diagnostics[i]; ptr != NULL; ptr = (void *)response->Diagnostics[++i])
      freeDiag((diagnosticRecord*)ptr);
  s_free(response->Diagnostics);

  s_free(response);
}

/*----------------------------------------------------------------------*/

char*
writeSearchResponseInfo(query,buffer,len)
SearchResponseAPDU* query;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					     DefWAISSearchResponseSize);
  char* buf = buffer + header_len;
  WAISSearchResponse* info = (WAISSearchResponse*)query->DatabaseDiagnosticRecords;
  unsigned long size;
  void* header = NULL;
  long i;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeString(info->SeedWordsUsed,DT_SeedWordsUsed,buf,len);

  /* write out all the headers */
  if (info->DocHeaders != NULL)
    { for (i = 0,header = (void *)info->DocHeaders[i]; header != NULL; header = (void *)info->DocHeaders[++i])
	buf = writeWAISDocumentHeader((WAISDocumentHeader*)header,buf,len);
      }

  if (info->ShortHeaders != NULL)
    { for (i = 0,header = (void *)info->ShortHeaders[i]; header != NULL; header = (void *)info->ShortHeaders[++i])
	buf = writeWAISDocumentShortHeader((WAISDocumentShortHeader*)header,buf,len);
      }

  if (info->LongHeaders != NULL)
    { for (i = 0,header = (void *)info->LongHeaders[i]; header != NULL; header = (void *)info->LongHeaders[++i])
	buf = writeWAISDocumentLongHeader((WAISDocumentLongHeader*)header,buf,len);
      }

  if (info->Text != NULL)
    { for (i = 0,header = (void *)info->Text[i]; header != NULL; header = (void *)info->Text[++i])
	buf = writeWAISDocumentText((WAISDocumentText*)header,buf,len);
      }

  if (info->Headlines != NULL)
    { for (i = 0,header = (void *)info->Headlines[i]; header != NULL; header = (void *)info->Headlines[++i])
	buf = writeWAISDocumentHeadlines((WAISDocumentHeadlines*)header,buf,len);
      }

  if (info->Codes != NULL)
    { for (i = 0,header = (void *)info->Codes[i]; header != NULL;header = (void *)info->Codes[++i])
	buf = writeWAISDocumentCodes((WAISDocumentCodes*)header,buf,len);
      }

  if (info->Diagnostics != NULL)
    { for (i = 0, header = (void *)info->Diagnostics[i]; header != NULL; header = (void *)info->Diagnostics[++i])
	buf = writeDiag((diagnosticRecord*)header,buf,len);
      }

  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_UserInformationLength,size,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

static void
cleanUpWaisSearchResponse (char* buf,char* seedWordsUsed,
			       WAISDocumentHeader** docHeaders,
			       WAISDocumentShortHeader** shortHeaders,
			       WAISDocumentLongHeader** longHeaders,
			       WAISDocumentText** text,
			       WAISDocumentHeadlines** headlines,
			       WAISDocumentCodes** codes,
			       diagnosticRecord**diags);

static void
cleanUpWaisSearchResponse (buf,seedWordsUsed,docHeaders,shortHeaders,
			   longHeaders,text,headlines,codes,diags)
char* buf;
char* seedWordsUsed;
WAISDocumentHeader** docHeaders;
WAISDocumentShortHeader** shortHeaders;
WAISDocumentLongHeader** longHeaders;
WAISDocumentText** text;
WAISDocumentHeadlines** headlines;
WAISDocumentCodes** codes;
diagnosticRecord** diags;
d1406 43
a1448 2
  void* ptr = NULL;
  long i;
d1450 40
a1489 75
  if (buf == NULL)
   { s_free(seedWordsUsed);
     if (docHeaders != NULL)
       for (i = 0,ptr = (void *)docHeaders[i]; ptr != NULL;
	    ptr = (void *)docHeaders[++i])
	 freeWAISDocumentHeader((WAISDocumentHeader*)ptr);
     s_free(docHeaders);
     if (shortHeaders != NULL)
       for (i = 0,ptr = (void *)shortHeaders[i]; ptr != NULL;
	    ptr = (void *)shortHeaders[++i])
	 freeWAISDocumentShortHeader((WAISDocumentShortHeader*)ptr);
     s_free(shortHeaders);
     if (longHeaders != NULL)
       for (i = 0,ptr = (void *)longHeaders[i]; ptr != NULL;
	    ptr = (void *)longHeaders[++i])
	 freeWAISDocumentLongHeader((WAISDocumentLongHeader*)ptr);
     s_free(longHeaders);
     if (text != NULL)
       for (i = 0,ptr = (void *)text[i]; ptr != NULL; ptr = (void *)text[++i])
	 freeWAISDocumentText((WAISDocumentText*)ptr);
     s_free(text);
     if (headlines != NULL)
       for (i = 0,ptr = (void *)headlines[i]; ptr != NULL;
	    ptr = (void *)headlines[++i])
	 freeWAISDocumentHeadlines((WAISDocumentHeadlines*)ptr);
     s_free(headlines);
     if (codes != NULL)
       for (i = 0,ptr = (void *)codes[i]; ptr != NULL;
	    ptr = (void *)codes[++i])
	 freeWAISDocumentCodes((WAISDocumentCodes*)ptr);
     s_free(codes);
     if (diags != NULL)
       for (i = 0,ptr = (void *)diags[i]; ptr != NULL;
	    ptr = (void *)diags[++i])
	 freeDiag((diagnosticRecord*)ptr);
     s_free(diags);
   }
}

/*----------------------------------------------------------------------*/

char*
readSearchResponseInfo(info,buffer)
void** info;
char* buffer;
{
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  void* header = NULL;
  WAISDocumentHeader** docHeaders = NULL;
  WAISDocumentShortHeader** shortHeaders = NULL;
  WAISDocumentLongHeader** longHeaders = NULL;
  WAISDocumentText** text = NULL;
  WAISDocumentHeadlines** headlines = NULL;
  WAISDocumentCodes** codes = NULL;
  long numDocHeaders,numLongHeaders,numShortHeaders,numText,numHeadlines;
  long numCodes;
  char* seedWordsUsed = NULL;
  diagnosticRecord** diags = NULL;
  diagnosticRecord* diag = NULL;
  long numDiags = 0;

  numDocHeaders = numLongHeaders = numShortHeaders = numText = numHeadlines = numCodes = 0;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_SeedWordsUsed:
	  buf = readString(&seedWordsUsed,buf);
	  break;
d1491 10
a1500 10
	  if (diags == NULL) /* create a new diag list */
	   { diags = (diagnosticRecord**)s_malloc((size_t)sizeof(diagnosticRecord*) * 2);
	   }
	  else /* grow the diag list */
	   { diags = (diagnosticRecord**)s_realloc((char*)diags,(size_t)(sizeof(diagnosticRecord*) * (numDiags + 2)));
	   }
	  buf = readDiag(&diag,buf);
	  diags[numDiags++] = diag; /* put it in the list */
	  diags[numDiags] = NULL;
	  break;
d1502 71
a1572 41
		  if (docHeaders == NULL) /* create a new header list */
		   { docHeaders = (WAISDocumentHeader**)s_malloc((size_t)sizeof(WAISDocumentHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { docHeaders = (WAISDocumentHeader**)s_realloc((char*)docHeaders,(size_t)(sizeof(WAISDocumentHeader*) * (numDocHeaders + 2)));
		   }
		  buf = readWAISDocumentHeader((WAISDocumentHeader**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  docHeaders[numDocHeaders++] =
		    (WAISDocumentHeader*)header; /* put it in the list */
		  docHeaders[numDocHeaders] = NULL;
		  break;
		case DT_DocumentShortHeaderGroup:
		  if (shortHeaders == NULL) /* create a new header list */
		   { shortHeaders = (WAISDocumentShortHeader**)s_malloc((size_t)sizeof(WAISDocumentShortHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { shortHeaders = (WAISDocumentShortHeader**)s_realloc((char*)shortHeaders,(size_t)(sizeof(WAISDocumentShortHeader*) * (numShortHeaders + 2)));
		   }
		  buf = readWAISDocumentShortHeader((WAISDocumentShortHeader**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  shortHeaders[numShortHeaders++] =
		    (WAISDocumentShortHeader*)header; /* put it in the list */
		  shortHeaders[numShortHeaders] = NULL;
		  break;
		case DT_DocumentLongHeaderGroup:
		  if (longHeaders == NULL) /* create a new header list */
		   { longHeaders = (WAISDocumentLongHeader**)s_malloc((size_t)sizeof(WAISDocumentLongHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { longHeaders = (WAISDocumentLongHeader**)s_realloc((char*)longHeaders,(size_t)(sizeof(WAISDocumentLongHeader*) * (numLongHeaders + 2)));
		   }
		  buf = readWAISDocumentLongHeader((WAISDocumentLongHeader**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  longHeaders[numLongHeaders++] =
		    (WAISDocumentLongHeader*)header; /* put it in the list */
		  longHeaders[numLongHeaders] = NULL;
		  break;
d1574 66
a1639 41
		  if (text == NULL) /* create a new list */
		   { text = (WAISDocumentText**)s_malloc((size_t)sizeof(WAISDocumentText*) * 2);
		   }
		  else /* grow the list */
		   { text = (WAISDocumentText**)s_realloc((char*)text,(size_t)(sizeof(WAISDocumentText*) * (numText + 2)));
		   }
		  buf = readWAISDocumentText((WAISDocumentText**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  text[numText++] =
		    (WAISDocumentText*)header; /* put it in the list */
		  text[numText] = NULL;
		  break;
		case DT_DocumentHeadlineGroup:
		  if (headlines == NULL) /* create a new list */
		   { headlines = (WAISDocumentHeadlines**)s_malloc((size_t)sizeof(WAISDocumentHeadlines*) * 2);
		   }
		  else /* grow the list */
		   { headlines = (WAISDocumentHeadlines**)s_realloc((char*)headlines,(size_t)(sizeof(WAISDocumentHeadlines*) * (numHeadlines + 2)));
		   }
		  buf = readWAISDocumentHeadlines((WAISDocumentHeadlines**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  headlines[numHeadlines++] =
		    (WAISDocumentHeadlines*)header; /* put it in the list */
		  headlines[numHeadlines] = NULL;
		  break;
		case DT_DocumentCodeGroup:
		  if (codes == NULL) /* create a new list */
		   { codes = (WAISDocumentCodes**)s_malloc((size_t)sizeof(WAISDocumentCodes*) * 2);
		   }
		  else /* grow the list */
		   { codes = (WAISDocumentCodes**)s_realloc((char*)codes,(size_t)(sizeof(WAISDocumentCodes*) * (numCodes + 2)));
		   }
		  buf = readWAISDocumentCodes((WAISDocumentCodes**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  codes[numCodes++] =
		    (WAISDocumentCodes*)header; /* put it in the list */
		  codes[numCodes] = NULL;
		  break;
d1641 13
a1653 5
	  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }
d1655 8
a1662 2
  *info = (void *)makeWAISSearchResponse(seedWordsUsed,docHeaders,shortHeaders,
				 longHeaders,text,headlines,codes,diags);
d1664 1
a1664 1
  return(buf);
d1669 3
a1671 5
WAISDocumentText*
makeWAISDocumentText(docID,versionNumber,documentText)
any* docID;
long versionNumber;
any* documentText;
d1673 1
a1673 1
  WAISDocumentText* docText = (WAISDocumentText*)s_malloc((size_t)sizeof(WAISDocumentText));
d1675 3
a1677 3
  docText->DocumentID = docID;
  docText->VersionNumber = versionNumber;
  docText->DocumentText = documentText;
d1679 1
a1679 1
  return(docText);
d1684 1
a1684 3
void
freeWAISDocumentText(docText)
WAISDocumentText* docText;
d1686 3
a1688 3
  freeAny(docText->DocumentID);
  freeAny(docText->DocumentText);
  s_free(docText);
d1693 2
a1694 5
char*
writeWAISDocumentText(docText,buffer,len)
WAISDocumentText* docText;
char* buffer;
long* len;
d1696 4
a1699 4
  unsigned long header_len = userInfoTagSize(DT_DocumentTextGroup,
											DefWAISDocTextSize);
  char* buf = buffer + header_len;
  unsigned long size;
d1701 1
a1701 1
  RESERVE_SPACE_FOR_WAIS_HEADER(len);
d1703 3
a1705 3
  buf = writeAny(docText->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(docText->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeAny(docText->DocumentText,DT_DocumentText,buf,len);
d1707 3
a1709 3
  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentTextGroup,size,header_len,buffer,len);
d1711 1
a1711 1
  return(buf);
d1716 1
a1716 4
char*
readWAISDocumentText(docText,buffer)
WAISDocumentText** docText;
char* buffer;
d1718 6
a1723 6
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any *docID,*documentText;
  long versionNumber;
d1725 2
a1726 2
  docID = documentText = NULL;
  versionNumber = UNUSED;
d1728 2
a1729 2
  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;
d1731 13
a1743 12
  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_DocumentID:
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_DocumentText:
		  buf = readAny(&documentText,buf);
		  break;
d1745 115
a1859 126
	  freeAny(docID);
	  freeAny(documentText);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }

  *docText = makeWAISDocumentText(docID,versionNumber,documentText);
  return(buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentHeadlines*
makeWAISDocumentHeadlines(docID,
			  versionNumber,
			  source,
			  date,
			  headline,
			  originCity)
any* docID;
long versionNumber;
char* source;
char* date;
char* headline;
char* originCity;
{
  WAISDocumentHeadlines* docHeadline =
    (WAISDocumentHeadlines*)s_malloc((size_t)sizeof(WAISDocumentHeadlines));

  docHeadline->DocumentID = docID;
  docHeadline->VersionNumber = versionNumber;
  docHeadline->Source = source;
  docHeadline->Date = date;
  docHeadline->Headline = headline;
  docHeadline->OriginCity = originCity;

  return(docHeadline);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentHeadlines(docHeadline)
WAISDocumentHeadlines* docHeadline;
{
  freeAny(docHeadline->DocumentID);
  s_free(docHeadline->Source);
  s_free(docHeadline->Date);
  s_free(docHeadline->Headline);
  s_free(docHeadline->OriginCity);
  s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentHeadlines(docHeadline,buffer,len)
WAISDocumentHeadlines* docHeadline;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentHeadlineGroup,
											DefWAISDocHeadlineSize);
  char* buf = buffer + header_len;
  unsigned long size;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(docHeadline->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(docHeadline->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeString(docHeadline->Source,DT_Source,buf,len);
  buf = writeString(docHeadline->Date,DT_Date,buf,len);
  buf = writeString(docHeadline->Headline,DT_Headline,buf,len);
  buf = writeString(docHeadline->OriginCity,DT_OriginCity,buf,len);

  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentHeadlineGroup,size,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentHeadlines(docHeadline,buffer)
WAISDocumentHeadlines** docHeadline;
char* buffer;
{
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any* docID;
  long versionNumber;
  char *source,*date,*headline,*originCity;

  docID = NULL;
  versionNumber = UNUSED;
  source = date = headline = originCity = NULL;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_DocumentID:
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_Source:
		  buf = readString(&source,buf);
		  break;
		case DT_Date:
		  buf = readString(&date,buf);
		  break;
		case DT_Headline:
		  buf = readString(&headline,buf);
		  break;
		case DT_OriginCity:
		  buf = readString(&originCity,buf);
		  break;
d1861 110
a1970 121
	  freeAny(docID);
	  s_free(source);
	  s_free(date);
	  s_free(headline);
	  s_free(originCity);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }

  *docHeadline = makeWAISDocumentHeadlines(docID,versionNumber,source,date,
									       headline,originCity);
  return(buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentCodes*
makeWAISDocumentCodes(docID,
		      versionNumber,
		      stockCodes,
		      companyCodes,
		      industryCodes)
any* docID;
long versionNumber;
char* stockCodes;
char* companyCodes;
char* industryCodes;
{
  WAISDocumentCodes* docCodes = (WAISDocumentCodes*)s_malloc((size_t)sizeof(WAISDocumentCodes));

  docCodes->DocumentID = docID;
  docCodes->VersionNumber = versionNumber;
  docCodes->StockCodes = stockCodes;
  docCodes->CompanyCodes = companyCodes;
  docCodes->IndustryCodes = industryCodes;

  return(docCodes);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentCodes(docCodes)
WAISDocumentCodes* docCodes;
{
  freeAny(docCodes->DocumentID);
  s_free(docCodes->StockCodes);
  s_free(docCodes->CompanyCodes);
  s_free(docCodes->IndustryCodes);
  s_free(docCodes);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentCodes(docCodes,buffer,len)
WAISDocumentCodes* docCodes;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentCodeGroup ,
											DefWAISDocCodeSize);
  char* buf = buffer + header_len;
  unsigned long size;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(docCodes->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(docCodes->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeString(docCodes->StockCodes,DT_StockCodes,buf,len);
  buf = writeString(docCodes->CompanyCodes,DT_CompanyCodes,buf,len);
  buf = writeString(docCodes->IndustryCodes,DT_IndustryCodes,buf,len);

  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentCodeGroup,size,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentCodes(docCodes,buffer)
WAISDocumentCodes** docCodes;
char* buffer;
{
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any* docID;
  long versionNumber;
  char *stockCodes,*companyCodes,*industryCodes;

  docID = NULL;
  versionNumber = UNUSED;
  stockCodes = companyCodes = industryCodes = NULL;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_DocumentID:
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_StockCodes:
		  buf = readString(&stockCodes,buf);
		  break;
		case DT_CompanyCodes:
		  buf = readString(&companyCodes,buf);
		  break;
		case DT_IndustryCodes:
		  buf = readString(&industryCodes,buf);
		  break;
d1972 8
a1979 8
	  freeAny(docID);
	  s_free(stockCodes);
	  s_free(companyCodes);
	  s_free(industryCodes);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }
d1981 3
a1983 3
  *docCodes = makeWAISDocumentCodes(docID,versionNumber,stockCodes,
									companyCodes,industryCodes);
  return(buf);
d1988 2
a1989 5
char*
writePresentInfo(present,buffer,len)
PresentAPDU* present GCC_UNUSED;
char* buffer;
long* len GCC_UNUSED;
d1991 2
a1992 2
  /* The WAIS protocol doesn't use present info */
  return(buffer);
d1997 2
a1998 4
char*
readPresentInfo(info,buffer)
void** info;
char* buffer;
d2000 3
a2002 3
  /* The WAIS protocol doesn't use present info */
  *info = NULL;
  return(buffer);
d2007 2
a2008 5
char*
writePresentResponseInfo(response,buffer,len)
PresentResponseAPDU* response GCC_UNUSED;
char* buffer;
long* len GCC_UNUSED;
d2010 2
a2011 2
  /* The WAIS protocol doesn't use presentResponse info */
  return(buffer);
d2016 2
a2017 4
char*
readPresentResponseInfo(info,buffer)
void** info;
char* buffer;
d2019 3
a2021 3
  /* The WAIS protocol doesn't use presentResponse info */
  *info = NULL;
  return(buffer);
d2063 1
a2063 5
static query_term** makeWAISQueryTerms (DocObj** docs);

static query_term**
makeWAISQueryTerms(docs)
DocObj** docs;
d2068 30
a2097 80
  query_term** terms = NULL;
  long numTerms = 0;
  DocObj* doc = NULL;
  long i;

  if (docs == NULL)
    return((query_term**)NULL);

  terms = (query_term**)s_malloc((size_t)(sizeof(query_term*) * 1));
  terms[numTerms] = NULL;

  /* loop through the docs making terms for them all */
  for (i = 0,doc = docs[i]; doc != NULL; doc = docs[++i])
    { any* type = NULL;

      if (doc->Type != NULL)
	type = stringToAny(doc->Type);

      if (doc->ChunkCode == CT_document) /* a whole document */
	{ terms = (query_term**)s_realloc((char*)terms,
					  (size_t)(sizeof(query_term*) *
						   (numTerms + 3 + 1)));
	  terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						EQUAL,IGNORE,IGNORE,
						IGNORE,IGNORE,doc->DocumentID);
	  if (type != NULL)
	   { terms[numTerms++] = makeAttributeTerm(DATA_TYPE,EQUAL,
						   IGNORE,IGNORE,IGNORE,
						   IGNORE,type);
	     terms[numTerms++] = makeOperatorTerm(AND);
	   }
	  terms[numTerms] = NULL;
	}
      else			/* a document fragment */
	{	char chunk_att[ATTRIBUTE_SIZE];
		any* startChunk = NULL;
		any* endChunk = NULL;

		terms = (query_term**)s_realloc((char*)terms,
						(size_t)(sizeof(query_term*) *
							 (numTerms + 7 + 1)));

		switch (doc->ChunkCode)
		  { case CT_byte:
		    case CT_line:
		      { char start[20],end[20];
			(doc->ChunkCode == CT_byte) ?
			  strncpy(chunk_att,BYTE,ATTRIBUTE_SIZE) :
			strncpy(chunk_att,LINE,ATTRIBUTE_SIZE);
			sprintf(start,"%ld",doc->ChunkStart.Pos);
			startChunk = stringToAny(start);
			sprintf(end,"%ld",doc->ChunkEnd.Pos);
			endChunk = stringToAny(end);
		      }
		      break;
		    case CT_paragraph:
		      strncpy(chunk_att,PARAGRAPH,ATTRIBUTE_SIZE);
		      startChunk = doc->ChunkStart.ID;
		      endChunk = doc->ChunkEnd.ID;
		      break;
		    default:
		      /* error */
		      break;
		    }

		terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						      EQUAL,IGNORE,IGNORE,
						      IGNORE,
						      IGNORE,doc->DocumentID);
		if (type != NULL)
		 { terms[numTerms++] = makeAttributeTerm(DATA_TYPE,EQUAL,IGNORE,
							 IGNORE,IGNORE,IGNORE,
							 type);
		   terms[numTerms++] = makeOperatorTerm(AND);
		 }
		terms[numTerms++] = makeAttributeTerm(chunk_att,
						      GREATER_THAN_OR_EQUAL,
						      IGNORE,IGNORE,IGNORE,
						      IGNORE,
						      startChunk);
d2099 42
a2140 4
		terms[numTerms++] = makeAttributeTerm(chunk_att,LESS_THAN,
						      IGNORE,IGNORE,IGNORE,
						      IGNORE,
						      endChunk);
d2142 21
a2162 1
		terms[numTerms] = NULL;
d2164 6
a2169 14
		if (doc->ChunkCode == CT_byte || doc->ChunkCode == CT_line)
		  { freeAny(startChunk);
		    freeAny(endChunk);
		  }
	      }

      freeAny(type);

     if (i != 0) /* multiple independent queries, need a disjunction */
	{ terms = (query_term**)s_realloc((char*)terms,
					  (size_t)(sizeof(query_term*) *
						   (numTerms + 1 + 1)));
	  terms[numTerms++] = makeOperatorTerm(OR);
	  terms[numTerms] = NULL;
d2173 1
a2173 1
  return(terms);
d2178 1
a2178 5
static DocObj** makeWAISQueryDocs (query_term** terms);

static DocObj**
makeWAISQueryDocs(terms)
query_term** terms;
d2183 19
a2201 5
  query_term* docTerm = NULL;
  query_term* fragmentTerm = NULL;
  DocObj** docs = NULL;
  DocObj* doc = NULL;
  long docNum,termNum;
d2203 2
a2204 1
  docNum = termNum = 0;
d2206 1
a2206 2
  docs = (DocObj**)s_malloc((size_t)(sizeof(DocObj*) * 1));
  docs[docNum] = NULL;
d2208 1
a2208 57
  /* translate the terms into DocObjs */
  while (true)
    {
      query_term* typeTerm = NULL;
      char* type = NULL;
      long startTermOffset;

      docTerm = terms[termNum];

      if (docTerm == NULL)
	break;			/* we're done converting */

      typeTerm = terms[termNum + 1]; /* get the lead Term if it exists */

      if (strcmp(typeTerm->Use,DATA_TYPE) == 0)	/* we do have a type */
       { startTermOffset = 3;
	 type = anyToString(typeTerm->Term);
       }
      else			/* no type */
       { startTermOffset = 1;
	 typeTerm = NULL;
	 type = NULL;
       }

      /* grow the doc list */
      docs = (DocObj**)s_realloc((char*)docs,(size_t)(sizeof(DocObj*) *
						      (docNum + 1 + 1)));

      /* figure out what kind of docObj to build - and build it */
      fragmentTerm = terms[termNum + startTermOffset];
      if (fragmentTerm != NULL && fragmentTerm->TermType == TT_Attribute)
	{			/* build a document fragment */
	  query_term* startTerm = fragmentTerm;
	  query_term* endTerm = terms[termNum + startTermOffset + 2];

	  if (strcmp(startTerm->Use,BYTE) == 0){ /* a byte chunk */
	    doc = makeDocObjUsingBytes(duplicateAny(docTerm->Term),
				       type,
				       anyToLong(startTerm->Term),
				       anyToLong(endTerm->Term));
	   log_write("byte");
	  }else if (strcmp(startTerm->Use,LINE) == 0){ /* a line chunk */
	    doc = makeDocObjUsingLines(duplicateAny(docTerm->Term),
				       type,
				       anyToLong(startTerm->Term),
				       anyToLong(endTerm->Term));
	    log_write("line");
	  }else{
	log_write("chunk");			/* a paragraph chunk */
	    doc = makeDocObjUsingParagraphs(duplicateAny(docTerm->Term),
					    type,
					    duplicateAny(startTerm->Term),
					    duplicateAny(endTerm->Term));
}
	  termNum += (startTermOffset + 4);	/* point to next term */
	}
      else			/* build a full document */
d2210 6
a2215 4
	  doc = makeDocObjUsingWholeDocument(duplicateAny(docTerm->Term),
					     type);
log_write("whole doc");
	  termNum += startTermOffset;	/* point to next term */
d2218 35
a2252 1
      docs[docNum++] = doc;	/* insert the new document */
d2254 1
a2254 1
      docs[docNum] = NULL;	/* keep the doc list terminated */
d2256 1
d2258 4
a2261 4
      if (terms[termNum] != NULL)
	termNum++; /* skip the OR operator it necessary */
      else
	break; /* we are done */
d2264 1
a2264 1
  return(docs);
d2269 1
a2269 3
any*
makeWAISTextQuery(docs)
DocObj** docs;
d2274 2
a2275 2
  any *buf = NULL;
  query_term** terms = NULL;
d2277 2
a2278 2
  terms = makeWAISQueryTerms(docs);
  buf = writeQuery(terms);
d2280 2
a2281 2
  doList((void**)terms,freeTerm);
  s_free(terms);
d2283 1
a2283 1
  return(buf);
d2288 1
a2288 3
DocObj**
readWAISTextQuery(buf)
any* buf;
d2293 2
a2294 2
  query_term** terms = NULL;
  DocObj** docs = NULL;
d2296 2
a2297 2
  terms = readQuery(buf);
  docs = makeWAISQueryDocs(terms);
d2299 2
a2300 2
  doList((void**)terms,freeTerm);
  s_free(terms);
d2302 1
a2302 1
  return(docs);
d2315 1
a2315 3
void
CSTFreeWAISInitResponse(init)
WAISInitResponse* init;
d2318 1
a2318 1
  s_free(init);
d2323 1
a2323 3
void
CSTFreeWAISSearch(query)
WAISSearch* query;
d2326 1
a2326 1
  s_free(query);
d2331 1
a2331 3
void
CSTFreeDocObj(doc)
DocObj* doc;
d2339 1
a2339 3
void
CSTFreeWAISDocumentHeader(header)
WAISDocumentHeader* header;
d2346 1
a2346 3
void
CSTFreeWAISDocumentShortHeader(header)
WAISDocumentShortHeader* header;
d2348 1
a2348 1
  s_free(header);
d2350 1
d2353 1
a2353 3
void
CSTFreeWAISDocumentLongHeader(header)
WAISDocumentLongHeader* header;
d2355 1
a2355 1
  s_free(header);
d2360 1
a2360 3
void
CSTFreeWAISSearchResponse(response)
WAISSearchResponse* response;
d2362 1
a2362 1
  s_free(response);
d2367 1
a2367 3
void
CSTFreeWAISDocumentText(docText)
WAISDocumentText* docText;
d2369 1
a2369 1
  s_free(docText);
d2374 1
a2374 3
void
CSTFreeWAISDocHeadlines(docHeadline)
WAISDocumentHeadlines* docHeadline;
d2376 1
a2376 1
  s_free(docHeadline);
d2381 1
a2381 3
void
CSTFreeWAISDocumentCodes(docCodes)
WAISDocumentCodes* docCodes;
d2383 1
a2383 1
  s_free(docCodes);
d2388 1
a2388 3
void
CSTFreeWAISTextQuery(query)
any* query;
d2390 1
a2390 1
   freeAny(query);
a2394 1

d2396 3
a2398 3
**	Routines originally from WMessage.c -- FM
**
**----------------------------------------------------------------------*/
d2400 4
a2403 4
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.
   3.26.90
*/
d2416 12
a2427 14
void
readWAISPacketHeader(msgBuffer,header_struct)
char* msgBuffer;
WAISMessage *header_struct;
{
  /* msgBuffer is a string containing at least HEADER_LENGTH bytes. */

  memmove(header_struct->msg_len,msgBuffer,(size_t)10);
  header_struct->msg_type = char_downcase((unsigned long)msgBuffer[10]);
  header_struct->hdr_vers = char_downcase((unsigned long)msgBuffer[11]);
  memmove(header_struct->server,(void*)(msgBuffer + 12),(size_t)10);
  header_struct->compression = char_downcase((unsigned long)msgBuffer[22]);
  header_struct->encoding = char_downcase((unsigned long)msgBuffer[23]);
  header_struct->msg_checksum = char_downcase((unsigned long)msgBuffer[24]);
d2436 7
a2442 15
void
writeWAISPacketHeader(header,
		      dataLen,
		      type,
		      server,
		      compression,
		      encoding,
		      version)
char* header;
long dataLen;
long type;
char* server;
long compression;
long encoding;
long version;
d2445 2
a2446 2
  char lengthBuf[11];
  char serverBuf[11];
d2448 1
a2448 3
  long serverLen = strlen(server);
  if (serverLen > 10)
    serverLen = 10;
d2450 2
a2451 2
  sprintf(lengthBuf, "%010ld", dataLen);
  strncpy(header,lengthBuf,10);
d2453 2
a2454 2
  header[10] = type & 0xFF;
  header[11] = version & 0xFF;
d2456 2
a2457 2
  strncpy(serverBuf,server,serverLen);
  strncpy((char*)(header + 12),serverBuf,serverLen);
d2459 6
a2464 3
  header[22] = compression & 0xFF;
  header[23] = encoding & 0xFF;
  header[24] = '0'; /* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */
a2467 1

@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d60 2
a61 2
static unsigned long userInfoTagSize PARAMS((data_tag tag,
					  unsigned long length));
d129 2
a130 2
static char* readUserInfoHeader PARAMS((data_tag* tag,unsigned long* num,
				     char* buffer));
d438 1
a438 1
static char* writeDocObj PARAMS((DocObj* doc,char* buffer,long* len));
d485 1
a485 1
static char* readDocObj PARAMS((DocObj** doc,char* buffer));
d1400 1
a1400 1
cleanUpWaisSearchResponse PARAMS((char* buf,char* seedWordsUsed,
d1407 1
a1407 1
			       diagnosticRecord**diags));
d2049 1
a2049 1
static query_term** makeWAISQueryTerms PARAMS((DocObj** docs));
d2168 1
a2168 1
static DocObj** makeWAISQueryDocs PARAMS((query_term** terms));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d15 2
a16 2
   disclaimer.	
  
d18 1
a18 1
   3.30.90  Harry Morris 
d31 1
a31 1
/*	This file implements the Z39.50 extensions required for WAIS 
d56 1
a56 1
     	*len -= header_len;
d68 1
a68 1
   length 
d76 1
a76 1
      
d78 1
a78 1
}   
d82 1
a82 1
static char* writeUserInfoHeader PARAMS((data_tag tag,long infoSize,	
d98 1
a98 1
   do that writing. 
d108 1
a108 1
  
d111 1
a111 1
  
d119 1
a119 1
   
d122 1
a122 1
  
d142 1
a142 1
  return(buf); 
d147 1
a147 1
WAISInitResponse* 
d170 1
a170 1
  
d176 1
a176 1
void 
d202 1
a202 1
  
d204 1
a204 1
    
d211 1
a211 1
  
d213 1
a213 1
  size = buf - buffer; 
d215 1
a215 1
  
d228 1
a228 1
  unsigned long size; 
d236 1
a236 1
  
d238 1
a238 1
  
d241 1
a241 1
    
d271 1
a271 1
  	  
d280 1
a280 1
WAISSearch* 
d297 1
a297 1
{ 
d307 1
a307 1
  
d313 1
a313 1
void 
d321 1
a321 1
  
d323 1
a323 1
  
d328 1
a328 1
   
d341 1
a341 1
DocObj* 
d358 1
a358 1
DocObj* 
d379 1
a379 1
DocObj* 
d400 1
a400 1
DocObj* 
d414 2
a415 2
  doc->ChunkStart.ID = start; 
  doc->ChunkEnd.ID = end; 
d449 1
a449 1
  
d455 1
a455 1
  
d458 1
a458 1
  
d479 1
a479 1
   
d496 1
a496 1
  
d498 1
a498 1
  
d501 1
a501 1
  
d542 1
a542 1
  return(buf);  
d547 1
a547 1
char* 
d560 1
a560 1
						 DefWAISSearchSize); 
d565 1
a565 1
  
d567 1
a567 1
       
d575 1
a575 1
   
d577 1
a577 1
 
d582 1
a582 1
  
d584 1
a584 1
      size = buf - buffer; 
d586 1
a586 1
   
d593 1
a593 1
char* 
d610 1
a610 1
      unsigned long size; 
d617 1
a617 1
      char** textList = NULL; 
d625 1
a625 1
  
d628 1
a628 1
  
d644 1
a644 1
		if (buf == NULL) 
d686 1
a686 1
  	  
d725 1
a725 1
  WAISDocumentHeader* header = 
d739 1
a739 1
  
d772 1
a772 1
  
d774 1
a774 1
   
d790 1
a790 1
	  size += typeSize; 
d800 1
a800 1
  
d802 1
a802 1
  size1 = buf - buffer; 
d816 1
a816 1
  unsigned long size1; 
d826 1
a826 1
  
d828 1
a828 1
  
d831 1
a831 1
    
d891 1
a891 1
  	  
d918 1
a918 1
  WAISDocumentShortHeader* header = 
d927 1
a927 1
  
d953 1
a953 1
  
d955 1
a955 1
   
d962 1
a962 1
  
d964 1
a964 1
  size = buf - buffer; 
d978 1
a978 1
  unsigned long size; 
d983 1
a983 1
  
d985 1
a985 1
  
d988 1
a988 1
    
d1016 1
a1016 1
  	  
d1058 1
a1058 1
  WAISDocumentLongHeader* header = 
d1075 1
a1075 1
  
d1109 1
a1109 1
  
d1111 1
a1111 1
   
d1127 1
a1127 1
	  size += typeSize; 
d1140 1
a1140 1
  
d1142 1
a1142 1
  size1 = buf - buffer; 
d1156 1
a1156 1
  unsigned long size1; 
d1163 1
a1163 1
  
d1168 1
a1168 1
  
d1171 1
a1171 1
    
d1243 1
a1243 1
  	  
d1272 1
a1272 1
  
d1281 1
a1281 1
  
d1300 1
a1300 1
   
d1305 1
a1305 1
   
d1310 1
a1310 1
   
d1315 1
a1315 1
   
d1320 1
a1320 1
   
d1325 1
a1325 1
   
d1330 1
a1330 1
  
d1336 1
a1336 1
char* 
d1349 1
a1349 1
  
d1351 1
a1351 1
  
d1353 1
a1353 1
  
d1359 1
a1359 1
   
d1389 1
a1389 1
   
d1391 1
a1391 1
  size = buf - buffer; 
d1393 1
a1393 1
  
d1421 1
a1421 1
/* if buf is NULL, we have just gotten a read error, and need to clean up 
d1429 8
a1436 8
  if (buf == NULL)						
   { s_free(seedWordsUsed);				
     if (docHeaders != NULL)				
       for (i = 0,ptr = (void *)docHeaders[i]; ptr != NULL; 
	    ptr = (void *)docHeaders[++i])		
	 freeWAISDocumentHeader((WAISDocumentHeader*)ptr);	
     s_free(docHeaders);				
     if (shortHeaders != NULL)	
d1438 1
a1438 1
	    ptr = (void *)shortHeaders[++i])	
d1440 4
a1443 4
     s_free(shortHeaders);						
     if (longHeaders != NULL)				
       for (i = 0,ptr = (void *)longHeaders[i]; ptr != NULL; 
	    ptr = (void *)longHeaders[++i])	
d1445 2
a1446 2
     s_free(longHeaders);				
     if (text != NULL)					
d1448 3
a1450 3
	 freeWAISDocumentText((WAISDocumentText*)ptr);	
     s_free(text);					
     if (headlines != NULL)					
d1452 12
a1463 12
	    ptr = (void *)headlines[++i])		
	 freeWAISDocumentHeadlines((WAISDocumentHeadlines*)ptr);	
     s_free(headlines);						
     if (codes != NULL)				     
       for (i = 0,ptr = (void *)codes[i]; ptr != NULL; 
	    ptr = (void *)codes[++i])				
	 freeWAISDocumentCodes((WAISDocumentCodes*)ptr);	 
     s_free(codes);					
     if (diags != NULL)				      	
       for (i = 0,ptr = (void *)diags[i]; ptr != NULL; 
	    ptr = (void *)diags[++i])	 
	 freeDiag((diagnosticRecord*)ptr);	     
d1476 1
a1476 1
  unsigned long size; 
d1492 1
a1492 1
  
d1494 1
a1494 1
  
d1497 1
a1497 1
    
d1502 21
a1522 21
      	  buf = readString(&seedWordsUsed,buf);
      	  break;
      	case DT_DatabaseDiagnosticRecords:
      	  if (diags == NULL) /* create a new diag list */
      	   { diags = (diagnosticRecord**)s_malloc((size_t)sizeof(diagnosticRecord*) * 2);
      	   }
      	  else /* grow the diag list */
      	   { diags = (diagnosticRecord**)s_realloc((char*)diags,(size_t)(sizeof(diagnosticRecord*) * (numDiags + 2)));
      	   }
      	  buf = readDiag(&diag,buf);
      	  diags[numDiags++] = diag; /* put it in the list */
      	  diags[numDiags] = NULL;
      	  break;
      	case DT_DocumentHeaderGroup:
  		  if (docHeaders == NULL) /* create a new header list */
  		   { docHeaders = (WAISDocumentHeader**)s_malloc((size_t)sizeof(WAISDocumentHeader*) * 2);
  		   }
  		  else /* grow the doc list */
  		   { docHeaders = (WAISDocumentHeader**)s_realloc((char*)docHeaders,(size_t)(sizeof(WAISDocumentHeader*) * (numDocHeaders + 2)));
  		   }
  		  buf = readWAISDocumentHeader((WAISDocumentHeader**)&header,buf);
d1524 2
a1525 2
  		  RETURN_ON_NULL(buf);
  		  docHeaders[numDocHeaders++] = 
d1527 10
a1536 10
  		  docHeaders[numDocHeaders] = NULL;
  		  break;
  		case DT_DocumentShortHeaderGroup:
  		  if (shortHeaders == NULL) /* create a new header list */
  		   { shortHeaders = (WAISDocumentShortHeader**)s_malloc((size_t)sizeof(WAISDocumentShortHeader*) * 2);
  		   }
  		  else /* grow the doc list */
  		   { shortHeaders = (WAISDocumentShortHeader**)s_realloc((char*)shortHeaders,(size_t)(sizeof(WAISDocumentShortHeader*) * (numShortHeaders + 2)));
  		   }
  		  buf = readWAISDocumentShortHeader((WAISDocumentShortHeader**)&header,buf);
d1538 2
a1539 2
  		  RETURN_ON_NULL(buf);
  		  shortHeaders[numShortHeaders++] = 
d1541 10
a1550 10
  		  shortHeaders[numShortHeaders] = NULL;
  		  break;
  		case DT_DocumentLongHeaderGroup:
  		  if (longHeaders == NULL) /* create a new header list */
  		   { longHeaders = (WAISDocumentLongHeader**)s_malloc((size_t)sizeof(WAISDocumentLongHeader*) * 2);
  		   }
  		  else /* grow the doc list */
  		   { longHeaders = (WAISDocumentLongHeader**)s_realloc((char*)longHeaders,(size_t)(sizeof(WAISDocumentLongHeader*) * (numLongHeaders + 2)));
  		   }
  		  buf = readWAISDocumentLongHeader((WAISDocumentLongHeader**)&header,buf);
d1552 2
a1553 2
  		  RETURN_ON_NULL(buf);
  		  longHeaders[numLongHeaders++] = 
d1555 10
a1564 10
  		  longHeaders[numLongHeaders] = NULL;
  		  break;
        case DT_DocumentTextGroup:
  		  if (text == NULL) /* create a new list */
  		   { text = (WAISDocumentText**)s_malloc((size_t)sizeof(WAISDocumentText*) * 2);
  		   }
  		  else /* grow the list */
  		   { text = (WAISDocumentText**)s_realloc((char*)text,(size_t)(sizeof(WAISDocumentText*) * (numText + 2)));
  		   }
  		  buf = readWAISDocumentText((WAISDocumentText**)&header,buf);
d1566 2
a1567 2
  		  RETURN_ON_NULL(buf);
  		  text[numText++] = 
d1569 10
a1578 10
  		  text[numText] = NULL;
  		  break;
  		case DT_DocumentHeadlineGroup:
  		  if (headlines == NULL) /* create a new list */
  		   { headlines = (WAISDocumentHeadlines**)s_malloc((size_t)sizeof(WAISDocumentHeadlines*) * 2);
  		   }
  		  else /* grow the list */
  		   { headlines = (WAISDocumentHeadlines**)s_realloc((char*)headlines,(size_t)(sizeof(WAISDocumentHeadlines*) * (numHeadlines + 2)));
  		   }
  		  buf = readWAISDocumentHeadlines((WAISDocumentHeadlines**)&header,buf);
d1580 2
a1581 2
  		  RETURN_ON_NULL(buf);
  		  headlines[numHeadlines++] = 
d1583 10
a1592 10
  		  headlines[numHeadlines] = NULL;
  		  break;
  		case DT_DocumentCodeGroup:
  		  if (codes == NULL) /* create a new list */
  		   { codes = (WAISDocumentCodes**)s_malloc((size_t)sizeof(WAISDocumentCodes*) * 2);
  		   }
  		  else /* grow the list */
  		   { codes = (WAISDocumentCodes**)s_realloc((char*)codes,(size_t)(sizeof(WAISDocumentCodes*) * (numCodes + 2)));
  		   }
  		  buf = readWAISDocumentCodes((WAISDocumentCodes**)&header,buf);
d1594 2
a1595 2
  		  RETURN_ON_NULL(buf);
  		  codes[numCodes++] = 
d1597 6
a1602 6
  		  codes[numCodes] = NULL;
  		  break;
        default:
          cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
          REPORT_READ_ERROR(buf);
          break;
d1605 1
a1605 1
  	  
d1608 1
a1608 1
  
d1625 1
a1625 1
  
d1631 1
a1631 1
void 
d1642 1
a1642 1
char* 
d1652 1
a1652 1
  
d1658 1
a1658 1
  
d1660 1
a1660 1
  size = buf - buffer; 
d1668 1
a1668 1
char* 
d1674 1
a1674 1
  unsigned long size; 
d1679 1
a1679 1
  
d1682 1
a1682 1
  
d1685 1
a1685 1
    
d1690 13
a1702 13
  		  buf = readAny(&docID,buf);
  		  break;
  		case DT_VersionNumber:
  		  buf = readNum(&versionNumber,buf);
  		  break;
  		case DT_DocumentText:
  		  buf = readAny(&documentText,buf);
  		  break;
        default:
          freeAny(docID);
          freeAny(documentText);
          REPORT_READ_ERROR(buf);
          break;
d1705 1
a1705 1
  	  
d1735 1
a1735 1
  
d1741 1
a1741 1
void 
d1755 1
a1755 1
char* 
d1765 1
a1765 1
  
d1774 1
a1774 1
  
d1776 1
a1776 1
  size = buf - buffer; 
d1784 1
a1784 1
char* 
d1790 1
a1790 1
  unsigned long size; 
d1796 1
a1796 1
  
d1800 1
a1800 1
  
d1803 1
a1803 1
    
d1808 25
a1832 25
  		  buf = readAny(&docID,buf);
  		  break;
  		case DT_VersionNumber:
  		  buf = readNum(&versionNumber,buf);
  		  break;
  		case DT_Source:
  		  buf = readString(&source,buf);
  		  break;
  		case DT_Date:
  		  buf = readString(&date,buf);
  		  break;
  		case DT_Headline:
  		  buf = readString(&headline,buf);
  		  break;
  		case DT_OriginCity:
  		  buf = readString(&originCity,buf);
  		  break;
        default:
          freeAny(docID);
          s_free(source);
          s_free(date);
          s_free(headline);
          s_free(originCity);
          REPORT_READ_ERROR(buf);
          break;
d1835 1
a1835 1
  	  
d1837 1
a1837 1
  									       headline,originCity);
d1862 1
a1862 1
  
d1868 1
a1868 1
void 
d1881 1
a1881 1
char* 
d1891 1
a1891 1
  
d1899 1
a1899 1
  
d1901 1
a1901 1
  size = buf - buffer; 
d1909 1
a1909 1
char* 
d1915 1
a1915 1
  unsigned long size; 
d1921 1
a1921 1
  
d1925 1
a1925 1
  
d1928 1
a1928 1
    
d1933 21
a1953 21
  		  buf = readAny(&docID,buf);
  		  break;
  		case DT_VersionNumber:
  		  buf = readNum(&versionNumber,buf);
  		  break;
  		case DT_StockCodes:
  		  buf = readString(&stockCodes,buf);
  		  break;
  		case DT_CompanyCodes:
  		  buf = readString(&companyCodes,buf);
  		  break;
  		case DT_IndustryCodes:
  		  buf = readString(&industryCodes,buf);
  		  break;
        default:
          freeAny(docID);
          s_free(stockCodes);
          s_free(companyCodes);
          s_free(industryCodes);
          REPORT_READ_ERROR(buf);
          break;
d1956 1
a1956 1
  	  
d1958 1
a1958 1
  									companyCodes,industryCodes);
d1964 1
a1964 1
char* 
d1976 1
a1976 1
char* 
d1988 1
a1988 1
char* 
d2000 1
a2000 1
char* 
d2021 1
a2021 1
       
d2024 3
a2026 3
            System_Control_Number = docID
            Data Type = type (optional)
            And
d2030 17
a2046 17
            System_Control_Number = docID
            Data Type = type (optional)
            And
	    	Chunk >= start
	    	And
	    	Chunk < end
	    	And

   		Information from multiple documents may be requested by using 
   		groups of the above joined by:

            OR

   		( XXX does an OR come after every group but the first, or do they
              all come at the end? )
              
        ( XXX return type could be in the element set)
d2050 1
a2050 1
   
d2078 1
a2078 1
					  (size_t)(sizeof(query_term*) * 
d2088 1
a2088 1
           }
d2095 1
a2095 1
 
d2097 1
a2097 1
						(size_t)(sizeof(query_term*) * 
d2106 1
a2106 1
			strncpy(chunk_att,LINE,ATTRIBUTE_SIZE);	
d2135 1
a2135 1
						      IGNORE,IGNORE,IGNORE, 
d2151 1
a2151 1
      
d2153 1
a2153 1
      
d2156 1
a2156 1
					  (size_t)(sizeof(query_term*) * 
d2170 1
a2170 1
static DocObj** 
d2173 1
a2173 1
/* given a list of terms in the form given above, convert them to 
d2184 1
a2184 1
  
d2190 1
a2190 1
    {	      
d2196 1
a2196 1
     
d2203 1
a2203 1
       { startTermOffset = 3;	
d2206 1
a2206 1
      else 				   	/* no type */
d2213 1
a2213 1
      docs = (DocObj**)s_realloc((char*)docs,(size_t)(sizeof(DocObj*) * 
d2221 1
a2221 1
	  query_term* endTerm = terms[termNum + startTermOffset + 2]; 
d2228 1
a2228 1
           log_write("byte");
d2234 1
a2234 1
            log_write("line");
d2245 1
a2245 1
	{ 
d2251 1
a2251 1
     
d2253 1
a2253 1
	 
d2256 1
a2256 1
	 
d2268 1
a2268 1
any* 
d2277 1
a2277 1
  
d2280 1
a2280 1
  
d2283 1
a2283 1
  
d2289 1
a2289 1
DocObj** 
d2292 1
a2292 1
/* given an any whose contents are type 1 queries of the WAIS sort, 
d2298 1
a2298 1
  
d2301 1
a2301 1
  
d2304 1
a2304 1
  
d2318 1
a2318 1
void 
d2328 1
a2328 1
void 
d2332 1
a2332 1
{ 
d2342 1
a2342 1
{ 
d2351 1
a2351 1
{ 
d2360 1
a2360 1
{ 
d2377 1
a2377 1
{ 
d2383 1
a2383 1
void 
d2386 1
a2386 1
{ 
d2392 1
a2392 1
void 
d2395 1
a2395 1
{ 
d2401 1
a2401 1
void 
d2410 1
a2410 1
void 
d2426 1
a2426 1
   disclaimer.    
d2441 1
a2441 1
void 
d2447 2
a2448 2
		    
  memmove(header_struct->msg_len,msgBuffer,(size_t)10); 
d2456 1
a2456 1
 
d2462 1
a2462 1
 
d2487 1
a2487 1
  sprintf(lengthBuf, "%010ld", dataLen);  
d2490 1
a2490 1
  header[10] = type & 0xFF; 
d2493 1
a2493 1
  strncpy(serverBuf,server,serverLen);       
d2496 5
a2500 5
  header[22] = compression & 0xFF;    
  header[23] = encoding & 0xFF;    
  header[24] = '0'; /* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */	
}              
              
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d868 1
d1208 1
d2198 1
a2198 1
	break;			/* we're done converting */;
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 6
a7 6
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	31-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/
d10 3
a12 3
 *	Routines originally from WProt.c -- FM
 *
 *----------------------------------------------------------------------*/
d14 14
a27 14
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.

 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris
 * -	removed chunk code from WAISSearchAPDU,
 * -	added makeWAISQueryType1Query() and readWAISType1Query() which replace
 * makeWAISQueryTerms() and makeWAISQueryDocs().
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 * - renamed makeWAISType1Query() to makeWAISTextQuery()
 * renamed readWAISType1Query() to readWAISTextQuery()
 * 5.29.90  TS - fixed bug in makeWAISQueryDocs
 * added CSTFreeWAISFoo functions
 */
d31 1
a31 1
/*	This file implements the Z39.50 extensions required for WAIS
d40 1
d56 1
a56 1
	*len -= header_len;
d58 1
a58 4
#define S_MALLOC(type) (type*)s_malloc(sizeof(type))
#define S_MALLOC2(type) (type*)s_malloc(sizeof(type) * 2)

#define S_REALLOC2(type, ptr, num) (type*)s_realloc((char*)ptr, (sizeof(type) * (num + 2)))
d60 2
a61 1
/*----------------------------------------------------------------------*/
d63 4
a66 2
static unsigned long userInfoTagSize(data_tag tag,
				     unsigned long length)
d68 1
a68 1
   length
d71 1
a71 5
    unsigned long size;

    /* calculate bytes required to represent tag.  max tag is 16K */
    size = writtenCompressedIntSize(tag);
    size += writtenCompressedIntSize(length);
d73 6
a78 2
    return (size);
}
d82 11
a92 5
static char *writeUserInfoHeader(data_tag tag,
				 long infoSize,
				 long estHeaderSize,
				 char *buffer,
				 long *len)
d98 1
a98 1
   do that writing.
d101 24
a124 23
    long dummyLen = 100;	/* plenty of space for a tag and size */
    char *buf = buffer;
    long realSize = infoSize - estHeaderSize;
    long realHeaderSize = userInfoTagSize(tag, realSize);

    if (buffer == NULL || *len == 0)
	return (NULL);

    /* write the tag */
    buf = writeTag(tag, buf, &dummyLen);

    /* see if the if the header size was correct. if not,
       we have to shift the info to fit the real header size */
    if (estHeaderSize != realHeaderSize) {	/* make sure there is enough space */
	CHECK_FOR_SPACE_LEFT(realHeaderSize - estHeaderSize, len);
	memmove(buffer + realHeaderSize, buffer + estHeaderSize, (size_t) (realSize));
    }

    /* write the size */
    writeCompressedInteger(realSize, buf, &dummyLen);

    /* return the true end of buffer */
    return (buffer + realHeaderSize + realSize);
d129 8
a136 3
static char *readUserInfoHeader(data_tag *tag,
				unsigned long *num,
				char *buffer)
d139 4
a142 5
    char *buf = buffer;

    buf = readTag(tag, buf);
    buf = readCompressedInteger(num, buf);
    return (buf);
d147 13
a159 6
WAISInitResponse *makeWAISInitResponse(long chunkCode,
				       long chunkIDLen,
				       char *chunkMarker,
				       char *highlightMarker,
				       char *deHighlightMarker,
				       char *newLineChars)
d162 1
a162 8
    WAISInitResponse *init = S_MALLOC(WAISInitResponse);

    init->ChunkCode = chunkCode;	/* note: none are copied! */
    init->ChunkIDLength = chunkIDLen;
    init->ChunkMarker = chunkMarker;
    init->HighlightMarker = highlightMarker;
    init->DeHighlightMarker = deHighlightMarker;
    init->NewlineCharacters = newLineChars;
d164 8
a171 1
    return (init);
d176 3
a178 1
void freeWAISInitResponse(WAISInitResponse *init)
d181 5
a185 5
    s_free(init->ChunkMarker);
    s_free(init->HighlightMarker);
    s_free(init->DeHighlightMarker);
    s_free(init->NewlineCharacters);
    s_free(init);
d190 5
a194 3
char *writeInitResponseInfo(InitResponseAPDU *init,
			    char *buffer,
			    long *len)
d197 20
a216 24
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISInitResponseSize);
    char *buf = buffer + header_len;
    WAISInitResponse *info = (WAISInitResponse *) init->UserInformationField;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeNum(info->ChunkCode, DT_ChunkCode, buf, len);
    buf = writeNum(info->ChunkIDLength, DT_ChunkIDLength, buf, len);
    buf = writeString(info->ChunkMarker, DT_ChunkMarker, buf, len);
    buf = writeString(info->HighlightMarker, DT_HighlightMarker, buf, len);
    buf = writeString(info->DeHighlightMarker, DT_DeHighlightMarker, buf, len);
    buf = writeString(info->NewlineCharacters, DT_NewlineCharacters, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
d221 4
a224 2
char *readInitResponseInfo(void **info,
			   char *buffer)
d227 29
a255 27
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    long chunkCode, chunkIDLen;
    data_tag tag1;
    char *chunkMarker = NULL;
    char *highlightMarker = NULL;
    char *deHighlightMarker = NULL;
    char *newLineChars = NULL;

    chunkCode = chunkIDLen = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_ChunkCode:
	    buf = readNum(&chunkCode, buf);
	    break;
	case DT_ChunkIDLength:
	    buf = readNum(&chunkIDLen, buf);
	    break;
	case DT_ChunkMarker:
	    buf = readString(&chunkMarker, buf);
d257 2
a258 2
	case DT_HighlightMarker:
	    buf = readString(&highlightMarker, buf);
d260 2
a261 2
	case DT_DeHighlightMarker:
	    buf = readString(&deHighlightMarker, buf);
d263 1
a263 4
	case DT_NewlineCharacters:
	    buf = readString(&newLineChars, buf);
	    break;
	default:
d269 1
a269 1
	}
d271 5
a275 5

    *info = (void *) makeWAISInitResponse(chunkCode, chunkIDLen, chunkMarker,
					  highlightMarker, deHighlightMarker,
					  newLineChars);
    return (buf);
d280 15
a294 7
WAISSearch *makeWAISSearch(char *seedWords,
			   DocObj **docs,
			   char **textList,
			   long dateFactor,
			   char *beginDateRange,
			   char *endDateRange,
			   long maxDocsRetrieved)
d297 2
a298 10
{
    WAISSearch *query = S_MALLOC(WAISSearch);

    query->SeedWords = seedWords;	/* not copied! */
    query->Docs = docs;		/* not copied! */
    query->TextList = textList;	/* not copied! */
    query->DateFactor = dateFactor;
    query->BeginDateRange = beginDateRange;
    query->EndDateRange = endDateRange;
    query->MaxDocumentsRetrieved = maxDocsRetrieved;
d300 9
a308 1
    return (query);
d313 3
a315 1
void freeWAISSearch(WAISSearch *query)
d319 18
a336 22
    void *ptr = NULL;
    long i;

    s_free(query->SeedWords);

    if (query->Docs != NULL)
	for (i = 0, ptr = (void *) query->Docs[i];
	     ptr != NULL;
	     ptr = (void *) query->Docs[++i])
	    freeDocObj((DocObj *) ptr);
    s_free(query->Docs);

    if (query->TextList != NULL)	/* XXX revisit when textlist is fully defined */
	for (i = 0, ptr = (void *) query->TextList[i];
	     ptr != NULL;
	     ptr = (void *) query->TextList[++i])
	    s_free(ptr);
    s_free(query->TextList);

    s_free(query->BeginDateRange);
    s_free(query->EndDateRange);
    s_free(query);
d341 4
a344 2
DocObj *makeDocObjUsingWholeDocument(any *docID,
				     char *type)
d349 5
a353 6
    DocObj *doc = S_MALLOC(DocObj);

    doc->DocumentID = docID;	/* not copied! */
    doc->Type = type;		/* not copied! */
    doc->ChunkCode = CT_document;
    return (doc);
d358 6
a363 4
DocObj *makeDocObjUsingLines(any *docID,
			     char *type,
			     long start,
			     long end)
d368 7
a374 8
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_line;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
d379 6
a384 4
DocObj *makeDocObjUsingBytes(any *docID,
			     char *type,
			     long start,
			     long end)
d389 7
a395 8
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_byte;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
d400 6
a405 4
DocObj *makeDocObjUsingParagraphs(any *docID,
				  char *type,
				  any *start,
				  any *end)
d410 7
a416 8
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_paragraph;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;
    doc->ChunkStart.ID = start;
    doc->ChunkEnd.ID = end;
    return (doc);
d421 3
a423 1
void freeDocObj(DocObj *doc)
d427 5
a431 5
    freeAny(doc->DocumentID);
    s_free(doc->Type);
    if (doc->ChunkCode == CT_paragraph) {
	freeAny(doc->ChunkStart.ID);
	freeAny(doc->ChunkEnd.ID);
d433 1
a433 1
    s_free(doc);
d438 7
a444 3
static char *writeDocObj(DocObj *doc,
			 char *buffer,
			 long *len)
d448 13
a460 13
    char *buf = buffer;

    /* we alwasy have to write the id, but its tag depends on if its a chunk */
    if (doc->ChunkCode == CT_document)
	buf = writeAny(doc->DocumentID, DT_DocumentID, buf, len);
    else
	buf = writeAny(doc->DocumentID, DT_DocumentIDChunk, buf, len);

    if (doc->Type != NULL)
	buf = writeString(doc->Type, DT_TYPE, buf, len);

    switch (doc->ChunkCode) {
    case CT_document:
d463 5
a467 5
    case CT_byte:
    case CT_line:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeNum(doc->ChunkStart.Pos, DT_ChunkStartID, buf, len);
	buf = writeNum(doc->ChunkEnd.Pos, DT_ChunkEndID, buf, len);
d469 4
a472 4
    case CT_paragraph:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeAny(doc->ChunkStart.ID, DT_ChunkStartID, buf, len);
	buf = writeAny(doc->ChunkEnd.ID, DT_ChunkEndID, buf, len);
d474 1
a474 1
    default:
d478 3
a480 3
    }

    return (buf);
d485 6
a490 2
static char *readDocObj(DocObj **doc,
			char *buffer)
d494 26
a519 26
    char *buf = buffer;
    data_tag tag;

    *doc = S_MALLOC(DocObj);

    tag = peekTag(buf);
    buf = readAny(&((*doc)->DocumentID), buf);

    if (tag == DT_DocumentID) {
	(*doc)->ChunkCode = CT_document;
	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != what comes next */
	    buf = readString(&((*doc)->Type), buf);
	/* ChunkStart and ChunkEnd are undefined */
    } else if (tag == DT_DocumentIDChunk) {
	boolean readParagraphs = false;		/* for cleanup */

	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != CT_FOO */
	    buf = readString(&((*doc)->Type), buf);
	buf = readNum(&((*doc)->ChunkCode), buf);
	switch ((*doc)->ChunkCode) {
	case CT_byte:
	case CT_line:
	    buf = readNum(&((*doc)->ChunkStart.Pos), buf);
	    buf = readNum(&((*doc)->ChunkEnd.Pos), buf);
d521 1
a521 1
	case CT_paragraph:
d523 2
a524 2
	    buf = readAny(&((*doc)->ChunkStart.ID), buf);
	    buf = readAny(&((*doc)->ChunkEnd.ID), buf);
d526 1
a526 1
	default:
d528 2
a529 2
	    if (readParagraphs) {
		freeAny((*doc)->ChunkStart.ID);
d531 1
a531 1
	    }
d535 6
a540 5
	}
    } else {
	freeAny((*doc)->DocumentID);
	s_free(*doc);
	REPORT_READ_ERROR(buf);
d542 1
a542 1
    return (buf);
d547 5
a551 3
char *writeSearchInfo(SearchAPDU *query,
		      char *buffer,
		      long *len)
d555 19
a573 18
    if (strcmp(query->QueryType, QT_TextRetrievalQuery) == 0) {
	return (writeAny((any *) query->Query, DT_Query, buffer, len));
    } else {
	unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
						   DefWAISSearchSize);
	char *buf = buffer + header_len;
	WAISSearch *info = (WAISSearch *) query->Query;
	unsigned long size;
	long i;

	RESERVE_SPACE_FOR_WAIS_HEADER(len);

	buf = writeString(info->SeedWords, DT_SeedWords, buf, len);

	if (info->Docs != NULL) {
	    for (i = 0; info->Docs[i] != NULL; i++) {
		buf = writeDocObj(info->Docs[i], buf, len);
	    }
d575 13
a587 29

	/* XXX text list */

	buf = writeNum(info->DateFactor,
		       DT_DateFactor,
		       buf,
		       len);
	buf = writeString(info->BeginDateRange,
			  DT_BeginDateRange,
			  buf,
			  len);
	buf = writeString(info->EndDateRange,
			  DT_EndDateRange,
			  buf,
			  len);
	buf = writeNum(info->MaxDocumentsRetrieved,
		       DT_MaxDocumentsRetrieved,
		       buf,
		       len);

	/* now write the header and size */
	size = buf - buffer;
	buf = writeUserInfoHeader(DT_UserInformationLength,
				  size,
				  header_len,
				  buffer,
				  len);

	return (buf);
d593 4
a596 2
char *readSearchInfo(void **info,
		     char *buffer)
d600 34
a633 37
    data_tag type = peekTag(buffer);

    if (type == DT_Query)	/* this is a type 1 query */
    {
	char *buf = buffer;
	any *query = NULL;

	buf = readAny(&query, buf);
	*info = (void *) query;
	return (buf);
    } else {			/* a type 3 query */
	char *buf = buffer;
	unsigned long size;
	unsigned long headerSize;
	data_tag tag1;
	char *seedWords = NULL;
	char *beginDateRange = NULL;
	char *endDateRange = NULL;
	long dateFactor, maxDocsRetrieved;
	char **textList = NULL;
	DocObj **docIDs = NULL;
	DocObj *doc = NULL;
	long docs = 0;
	long i;
	void *ptr = NULL;

	dateFactor = maxDocsRetrieved = UNUSED;

	buf = readUserInfoHeader(&tag1, &size, buf);
	headerSize = buf - buffer;

	while (buf < (buffer + size + headerSize)) {
	    data_tag tag = peekTag(buf);

	    switch (tag) {
	    case DT_SeedWords:
		buf = readString(&seedWords, buf);
d635 11
a645 11
	    case DT_DocumentID:
	    case DT_DocumentIDChunk:
		if (docIDs == NULL)	/* create a new doc list */
		{
		    docIDs = S_MALLOC2(DocObj *);
		} else {	/* grow the doc list */
		    docIDs = S_REALLOC2(DocObj *, docIDs, docs);
		}
		buf = readDocObj(&doc, buf);
		if (buf == NULL) {
		    s_free(seedWords);
d649 2
a650 4
			for (i = 0, ptr = (void *) docIDs[i];
			     ptr != NULL;
			     ptr = (void *) docIDs[++i])
			    freeDocObj((DocObj *) ptr);
d653 1
a653 1
		}
d655 1
a655 1
		docIDs[docs++] = doc;	/* put it in the list */
d658 1
a658 1
	    case DT_TextList:
d661 2
a662 2
	    case DT_DateFactor:
		buf = readNum(&dateFactor, buf);
d664 2
a665 2
	    case DT_BeginDateRange:
		buf = readString(&beginDateRange, buf);
d667 2
a668 2
	    case DT_EndDateRange:
		buf = readString(&endDateRange, buf);
d670 2
a671 2
	    case DT_MaxDocumentsRetrieved:
		buf = readNum(&maxDocsRetrieved, buf);
d673 1
a673 1
	    default:
d678 2
a679 4
		    for (i = 0, ptr = (void *) docIDs[i];
			 ptr != NULL;
			 ptr = (void *) docIDs[++i])
			freeDocObj((DocObj *) ptr);
d684 1
a684 1
	    }
d686 5
a690 5

	*info = (void *) makeWAISSearch(seedWords, docIDs, textList,
					dateFactor, beginDateRange, endDateRange,
					maxDocsRetrieved);
	return (buf);
d696 23
a718 11
WAISDocumentHeader *makeWAISDocumentHeader(any *docID,
					   long versionNumber,
					   long score,
					   long bestMatch,
					   long docLen,
					   long lines,
					   char **types,
					   char *source,
					   char *date,
					   char *headline,
					   char *originCity)
d725 2
a726 32
    WAISDocumentHeader *header = S_MALLOC(WAISDocumentHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeader(WAISDocumentHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here ! */
    s_free(header->Types);
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header);
}

/*----------------------------------------------------------------------*/
d728 63
a790 30
char *writeWAISDocumentHeader(WAISDocumentHeader *header, char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeaderGroup,
					       DefWAISDocHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
d792 74
a865 80
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeader(WAISDocumentHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types = NULL;
    char *source = NULL;
    char *date = NULL;
    char *headline = NULL;
    char *originCity = NULL;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		buf = readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
d868 2
a869 3
	    /* FALLTHRU */
	case DT_Source:
	    buf = readString(&source, buf);
d871 2
a872 2
	case DT_Date:
	    buf = readString(&date, buf);
d874 2
a875 2
	case DT_Headline:
	    buf = readString(&headline, buf);
d877 2
a878 2
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
d880 1
a880 1
	default:
d888 1
a888 1
	}
d890 5
a894 5

    *header = makeWAISDocumentHeader(docID, versionNumber, score, bestMatch,
				     docLength, lines, types, source, date, headline,
				     originCity);
    return (buf);
d899 13
a911 6
WAISDocumentShortHeader *makeWAISDocumentShortHeader(any *docID,
						     long versionNumber,
						     long score,
						     long bestMatch,
						     long docLen,
						     long lines)
d917 2
a918 8
    WAISDocumentShortHeader *header = S_MALLOC(WAISDocumentShortHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
d920 82
a1001 63
    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
{
    freeAny(header->DocumentID);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentShortHeader(WAISDocumentShortHeader *header, char *buffer,
				   long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentShortHeaderGroup,
					       DefWAISShortHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentShortHeaderGroup,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentShortHeader(WAISDocumentShortHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
d1003 2
a1004 2
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
d1006 2
a1007 2
	case DT_Score:
	    buf = readNum(&score, buf);
d1009 1
a1009 10
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	default:
d1013 1
a1013 1
	}
d1015 4
a1018 4

    *header = makeWAISDocumentShortHeader(docID, versionNumber, score, bestMatch,
					  docLength, lines);
    return (buf);
d1023 29
a1051 14
WAISDocumentLongHeader *makeWAISDocumentLongHeader(any *docID,
						   long versionNumber,
						   long score,
						   long bestMatch,
						   long docLen,
						   long lines,
						   char **types,
						   char *source,
						   char *date,
						   char *headline,
						   char *originCity,
						   char *stockCodes,
						   char *companyCodes,
						   char *industryCodes)
d1057 2
a1058 35
    WAISDocumentLongHeader *header = S_MALLOC(WAISDocumentLongHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;
    header->StockCodes = stockCodes;
    header->CompanyCodes = companyCodes;
    header->IndustryCodes = industryCodes;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here! */
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header->StockCodes);
    s_free(header->CompanyCodes);
    s_free(header->IndustryCodes);
    s_free(header);
}
d1060 67
a1126 32
/*----------------------------------------------------------------------*/

char *writeWAISDocumentLongHeader(WAISDocumentLongHeader *header, char *buffer,
				  long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentLongHeaderGroup,
					       DefWAISLongHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
d1128 77
a1204 93
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);
    buf = writeString(header->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(header->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(header->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentLongHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentLongHeader(WAISDocumentLongHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types;
    char *source, *date, *headline, *originCity, *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber =
	score =
	bestMatch =
	docLength =
	lines = UNUSED;
    types = NULL;
    source =
	date =
	headline =
	originCity =
	stockCodes =
	companyCodes =
	industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
d1207 2
a1208 3
	    /* FALLTHRU */
	case DT_Source:
	    buf = readString(&source, buf);
d1210 2
a1211 2
	case DT_Date:
	    buf = readString(&date, buf);
d1213 2
a1214 2
	case DT_Headline:
	    buf = readString(&headline, buf);
d1216 2
a1217 2
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
d1219 2
a1220 2
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
d1222 2
a1223 2
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
d1225 2
a1226 2
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
d1228 1
a1228 1
	default:
d1239 1
a1239 150
	}
    }

    *header = makeWAISDocumentLongHeader(docID,
					 versionNumber,
					 score,
					 bestMatch,
					 docLength,
					 lines,
					 types,
					 source,
					 date,
					 headline,
					 originCity,
					 stockCodes,
					 companyCodes,
					 industryCodes);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISSearchResponse *
  makeWAISSearchResponse(
			    char *seedWordsUsed,
			    WAISDocumentHeader **docHeaders,
			    WAISDocumentShortHeader **shortHeaders,
			    WAISDocumentLongHeader **longHeaders,
			    WAISDocumentText **text,
			    WAISDocumentHeadlines **headlines,
			    WAISDocumentCodes **codes,
			    diagnosticRecord ** diagnostics)
{
    WAISSearchResponse *response = S_MALLOC(WAISSearchResponse);

    response->SeedWordsUsed = seedWordsUsed;
    response->DocHeaders = docHeaders;
    response->ShortHeaders = shortHeaders;
    response->LongHeaders = longHeaders;
    response->Text = text;
    response->Headlines = headlines;
    response->Codes = codes;
    response->Diagnostics = diagnostics;

    return (response);
}

/*----------------------------------------------------------------------*/

void freeWAISSearchResponse(WAISSearchResponse * response)
{
    void *ptr = NULL;
    long i;

    s_free(response->SeedWordsUsed);

    if (response->DocHeaders != NULL)
	for (i = 0, ptr = (void *) response->DocHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->DocHeaders[++i])
	    freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
    s_free(response->DocHeaders);

    if (response->ShortHeaders != NULL)
	for (i = 0, ptr = (void *) response->ShortHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->ShortHeaders[++i])
	    freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
    s_free(response->ShortHeaders);

    if (response->LongHeaders != NULL)
	for (i = 0, ptr = (void *) response->LongHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->LongHeaders[++i])
	    freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
    s_free(response->LongHeaders);

    if (response->Text != NULL)
	for (i = 0, ptr = (void *) response->Text[i];
	     ptr != NULL;
	     ptr = (void *) response->Text[++i])
	    freeWAISDocumentText((WAISDocumentText *) ptr);
    s_free(response->Text);

    if (response->Headlines != NULL)
	for (i = 0, ptr = (void *) response->Headlines[i];
	     ptr != NULL;
	     ptr = (void *) response->Headlines[++i])
	    freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
    s_free(response->Headlines);

    if (response->Codes != NULL)
	for (i = 0, ptr = (void *) response->Codes[i];
	     ptr != NULL;
	     ptr = (void *) response->Codes[++i])
	    freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
    s_free(response->Codes);

    if (response->Diagnostics != NULL)
	for (i = 0, ptr = (void *) response->Diagnostics[i];
	     ptr != NULL;
	     ptr = (void *) response->Diagnostics[++i])
	    freeDiag((diagnosticRecord *) ptr);
    s_free(response->Diagnostics);

    s_free(response);
}

/*----------------------------------------------------------------------*/

char *writeSearchResponseInfo(SearchResponseAPDU *query,
			      char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISSearchResponseSize);
    char *buf = buffer + header_len;
    WAISSearchResponse *info = (WAISSearchResponse *) query->DatabaseDiagnosticRecords;
    unsigned long size;
    void *header = NULL;
    long i;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeString(info->SeedWordsUsed, DT_SeedWordsUsed, buf, len);

    /* write out all the headers */
    if (info->DocHeaders != NULL) {
	for (i = 0, header = (void *) info->DocHeaders[i];
	     header != NULL;
	     header = (void *) info->DocHeaders[++i])
	    buf = writeWAISDocumentHeader((WAISDocumentHeader *) header, buf, len);
    }

    if (info->ShortHeaders != NULL) {
	for (i = 0, header = (void *) info->ShortHeaders[i];
	     header != NULL;
	     header = (void *) info->ShortHeaders[++i])
	    buf = writeWAISDocumentShortHeader((WAISDocumentShortHeader *) header,
					       buf,
					       len);
    }

    if (info->LongHeaders != NULL) {
	for (i = 0, header = (void *) info->LongHeaders[i];
	     header != NULL;
	     header = (void *) info->LongHeaders[++i])
	    buf = writeWAISDocumentLongHeader((WAISDocumentLongHeader *) header,
					      buf,
					      len);
d1241 179
a1419 54

    if (info->Text != NULL) {
	for (i = 0, header = (void *) info->Text[i];
	     header != NULL;
	     header = (void *) info->Text[++i])
	    buf = writeWAISDocumentText((WAISDocumentText *) header, buf, len);
    }

    if (info->Headlines != NULL) {
	for (i = 0, header = (void *) info->Headlines[i];
	     header != NULL;
	     header = (void *) info->Headlines[++i])
	    buf = writeWAISDocumentHeadlines((WAISDocumentHeadlines *) header,
					     buf,
					     len);
    }

    if (info->Codes != NULL) {
	for (i = 0, header = (void *) info->Codes[i];
	     header != NULL;
	     header = (void *) info->Codes[++i])
	    buf = writeWAISDocumentCodes((WAISDocumentCodes *) header, buf, len);
    }

    if (info->Diagnostics != NULL) {
	for (i = 0, header = (void *) info->Diagnostics[i];
	     header != NULL;
	     header = (void *) info->Diagnostics[++i])
	    buf = writeDiag((diagnosticRecord *) header, buf, len);
    }

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

static void cleanUpWaisSearchResponse(char *buf,
				      char *seedWordsUsed,
				      WAISDocumentHeader **docHeaders,
				      WAISDocumentShortHeader **shortHeaders,
				      WAISDocumentLongHeader **longHeaders,
				      WAISDocumentText **text,
				      WAISDocumentHeadlines **headlines,
				      WAISDocumentCodes **codes,
				      diagnosticRecord ** diags)
/* if buf is NULL, we have just gotten a read error, and need to clean up
d1424 2
a1425 392
    void *ptr = NULL;
    long i;

    if (buf == NULL) {
	s_free(seedWordsUsed);
	if (docHeaders != NULL)
	    for (i = 0, ptr = (void *) docHeaders[i]; ptr != NULL;
		 ptr = (void *) docHeaders[++i])
		freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
	s_free(docHeaders);
	if (shortHeaders != NULL)
	    for (i = 0, ptr = (void *) shortHeaders[i]; ptr != NULL;
		 ptr = (void *) shortHeaders[++i])
		freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
	s_free(shortHeaders);
	if (longHeaders != NULL)
	    for (i = 0, ptr = (void *) longHeaders[i]; ptr != NULL;
		 ptr = (void *) longHeaders[++i])
		freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
	s_free(longHeaders);
	if (text != NULL)
	    for (i = 0, ptr = (void *) text[i];
		 ptr != NULL;
		 ptr = (void *) text[++i])
		freeWAISDocumentText((WAISDocumentText *) ptr);
	s_free(text);
	if (headlines != NULL)
	    for (i = 0, ptr = (void *) headlines[i]; ptr != NULL;
		 ptr = (void *) headlines[++i])
		freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
	s_free(headlines);
	if (codes != NULL)
	    for (i = 0, ptr = (void *) codes[i]; ptr != NULL;
		 ptr = (void *) codes[++i])
		freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
	s_free(codes);
	if (diags != NULL)
	    for (i = 0, ptr = (void *) diags[i]; ptr != NULL;
		 ptr = (void *) diags[++i])
		freeDiag((diagnosticRecord *) ptr);
	s_free(diags);
    }
}

/*----------------------------------------------------------------------*/

char *readSearchResponseInfo(void **info,
			     char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    void *header = NULL;
    WAISDocumentHeader **docHeaders = NULL;
    WAISDocumentShortHeader **shortHeaders = NULL;
    WAISDocumentLongHeader **longHeaders = NULL;
    WAISDocumentText **text = NULL;
    WAISDocumentHeadlines **headlines = NULL;
    WAISDocumentCodes **codes = NULL;
    long numDocHeaders, numLongHeaders, numShortHeaders, numText, numHeadlines;
    long numCodes;
    char *seedWordsUsed = NULL;
    diagnosticRecord **diags = NULL;
    diagnosticRecord *diag = NULL;
    long numDiags = 0;

    numDocHeaders =
	numLongHeaders =
	numShortHeaders =
	numText =
	numHeadlines =
	numCodes = 0;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_SeedWordsUsed:
	    buf = readString(&seedWordsUsed, buf);
	    break;
	case DT_DatabaseDiagnosticRecords:
	    if (diags == NULL)	/* create a new diag list */
	    {
		diags = S_MALLOC2(diagnosticRecord *);
	    } else {		/* grow the diag list */
		diags = S_REALLOC2(diagnosticRecord *, diags, numDiags);
	    }
	    buf = readDiag(&diag, buf);
	    diags[numDiags++] = diag;	/* put it in the list */
	    diags[numDiags] = NULL;
	    break;
	case DT_DocumentHeaderGroup:
	    if (docHeaders == NULL)	/* create a new header list */
	    {
		docHeaders = S_MALLOC2(WAISDocumentHeader *);
	    } else {		/* grow the doc list */
		docHeaders = S_REALLOC2(WAISDocumentHeader *, docHeaders, numDocHeaders);
	    }
	    buf = readWAISDocumentHeader((WAISDocumentHeader **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    docHeaders[numDocHeaders++] =
		(WAISDocumentHeader *) header;	/* put it in the list */
	    docHeaders[numDocHeaders] = NULL;
	    break;
	case DT_DocumentShortHeaderGroup:
	    if (shortHeaders == NULL)	/* create a new header list */
	    {
		shortHeaders = S_MALLOC2(WAISDocumentShortHeader *);
	    } else {		/* grow the doc list */
		shortHeaders = S_REALLOC2(WAISDocumentShortHeader *,
					  shortHeaders,
					  numShortHeaders);
	    }
	    buf = readWAISDocumentShortHeader((WAISDocumentShortHeader **) &header,
					      buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    shortHeaders[numShortHeaders++] =
		(WAISDocumentShortHeader *) header;	/* put it in the list */
	    shortHeaders[numShortHeaders] = NULL;
	    break;
	case DT_DocumentLongHeaderGroup:
	    if (longHeaders == NULL)	/* create a new header list */
	    {
		longHeaders = S_MALLOC2(WAISDocumentLongHeader *);
	    } else {		/* grow the doc list */
		longHeaders = S_REALLOC2(WAISDocumentLongHeader *,
					 longHeaders,
					 numLongHeaders);
	    }
	    buf = readWAISDocumentLongHeader((WAISDocumentLongHeader **) &header,
					     buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    longHeaders[numLongHeaders++] =
		(WAISDocumentLongHeader *) header;	/* put it in the list */
	    longHeaders[numLongHeaders] = NULL;
	    break;
	case DT_DocumentTextGroup:
	    if (text == NULL)	/* create a new list */
	    {
		text = S_MALLOC2(WAISDocumentText *);
	    } else {		/* grow the list */
		text = S_REALLOC2(WAISDocumentText *, text, numText);
	    }
	    buf = readWAISDocumentText((WAISDocumentText **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    text[numText++] =
		(WAISDocumentText *) header;	/* put it in the list */
	    text[numText] = NULL;
	    break;
	case DT_DocumentHeadlineGroup:
	    if (headlines == NULL)	/* create a new list */
	    {
		headlines = S_MALLOC2(WAISDocumentHeadlines *);
	    } else {		/* grow the list */
		headlines = S_REALLOC2(WAISDocumentHeadlines *, headlines, numHeadlines);
	    }
	    buf = readWAISDocumentHeadlines((WAISDocumentHeadlines **) &header,
					    buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    headlines[numHeadlines++] =
		(WAISDocumentHeadlines *) header;	/* put it in the list */
	    headlines[numHeadlines] = NULL;
	    break;
	case DT_DocumentCodeGroup:
	    if (codes == NULL)	/* create a new list */
	    {
		codes = S_MALLOC2(WAISDocumentCodes *);
	    } else {		/* grow the list */
		codes = S_REALLOC2(WAISDocumentCodes *, codes, numCodes);
	    }
	    buf = readWAISDocumentCodes((WAISDocumentCodes **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    codes[numCodes++] =
		(WAISDocumentCodes *) header;	/* put it in the list */
	    codes[numCodes] = NULL;
	    break;
	default:
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *info = (void *) makeWAISSearchResponse(seedWordsUsed,
					    docHeaders,
					    shortHeaders,
					    longHeaders,
					    text,
					    headlines,
					    codes,
					    diags);

    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentText *makeWAISDocumentText(any *docID,
				       long versionNumber,
				       any *documentText)
{
    WAISDocumentText *docText = S_MALLOC(WAISDocumentText);

    docText->DocumentID = docID;
    docText->VersionNumber = versionNumber;
    docText->DocumentText = documentText;

    return (docText);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentText(WAISDocumentText *docText)
{
    freeAny(docText->DocumentID);
    freeAny(docText->DocumentText);
    s_free(docText);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentText(WAISDocumentText *docText, char *buffer,
			    long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentTextGroup,
					       DefWAISDocTextSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docText->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docText->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeAny(docText->DocumentText, DT_DocumentText, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentTextGroup, size, header_len, buffer, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentText(WAISDocumentText **docText, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID, *documentText;
    long versionNumber;

    docID = documentText = NULL;
    versionNumber = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_DocumentText:
	    buf = readAny(&documentText, buf);
	    break;
	default:
	    freeAny(docID);
	    freeAny(documentText);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docText = makeWAISDocumentText(docID, versionNumber, documentText);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentHeadlines *makeWAISDocumentHeadlines(any *docID,
						 long versionNumber,
						 char *source,
						 char *date,
						 char *headline,
						 char *originCity)
{
    WAISDocumentHeadlines *docHeadline = S_MALLOC(WAISDocumentHeadlines);

    docHeadline->DocumentID = docID;
    docHeadline->VersionNumber = versionNumber;
    docHeadline->Source = source;
    docHeadline->Date = date;
    docHeadline->Headline = headline;
    docHeadline->OriginCity = originCity;

    return (docHeadline);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline)
{
    freeAny(docHeadline->DocumentID);
    s_free(docHeadline->Source);
    s_free(docHeadline->Date);
    s_free(docHeadline->Headline);
    s_free(docHeadline->OriginCity);
    s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline, char *buffer,
				 long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeadlineGroup,
					       DefWAISDocHeadlineSize);
    char *buf = buffer + header_len;
    unsigned long size;
d1427 579
a2005 223
    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docHeadline->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docHeadline->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docHeadline->Source, DT_Source, buf, len);
    buf = writeString(docHeadline->Date, DT_Date, buf, len);
    buf = writeString(docHeadline->Headline, DT_Headline, buf, len);
    buf = writeString(docHeadline->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeadlineGroup,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeadlines(WAISDocumentHeadlines **docHeadline, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *source, *date, *headline, *originCity;

    docID = NULL;
    versionNumber = UNUSED;
    source = date = headline = originCity = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docHeadline = makeWAISDocumentHeadlines(docID, versionNumber, source, date,
					     headline, originCity);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentCodes *makeWAISDocumentCodes(any *docID,
					 long versionNumber,
					 char *stockCodes,
					 char *companyCodes,
					 char *industryCodes)
{
    WAISDocumentCodes *docCodes = S_MALLOC(WAISDocumentCodes);

    docCodes->DocumentID = docID;
    docCodes->VersionNumber = versionNumber;
    docCodes->StockCodes = stockCodes;
    docCodes->CompanyCodes = companyCodes;
    docCodes->IndustryCodes = industryCodes;

    return (docCodes);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentCodes(WAISDocumentCodes *docCodes)
{
    freeAny(docCodes->DocumentID);
    s_free(docCodes->StockCodes);
    s_free(docCodes->CompanyCodes);
    s_free(docCodes->IndustryCodes);
    s_free(docCodes);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentCodes(WAISDocumentCodes *docCodes,
			     char *buffer,
			     long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentCodeGroup,
					       DefWAISDocCodeSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docCodes->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docCodes->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docCodes->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(docCodes->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(docCodes->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentCodeGroup, size, header_len, buffer, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentCodes(WAISDocumentCodes **docCodes,
			    char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber = UNUSED;
    stockCodes = companyCodes = industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
	    break;
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
	    break;
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(stockCodes);
	    s_free(companyCodes);
	    s_free(industryCodes);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docCodes = makeWAISDocumentCodes(docID, versionNumber, stockCodes,
				      companyCodes, industryCodes);
    return (buf);
}

/*----------------------------------------------------------------------*/

char *writePresentInfo(PresentAPDU * present GCC_UNUSED, char *buffer,
		       long *len GCC_UNUSED)
{
    /* The WAIS protocol doesn't use present info */
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *readPresentInfo(void **info,
		      char *buffer)
{
    /* The WAIS protocol doesn't use present info */
    *info = NULL;
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *writePresentResponseInfo(PresentResponseAPDU * response GCC_UNUSED, char *buffer,
			       long *len GCC_UNUSED)
{
    /* The WAIS protocol doesn't use presentResponse info */
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *readPresentResponseInfo(void **info,
			      char *buffer)
{
    /* The WAIS protocol doesn't use presentResponse info */
    *info = NULL;
    return (buffer);
d2019 1
a2019 1

d2022 3
a2024 3
	    System_Control_Number = docID
	    Data Type = type (optional)
	    And
d2028 17
a2044 17
	    System_Control_Number = docID
	    Data Type = type (optional)
	    And
		Chunk >= start
		And
		Chunk < end
		And

		Information from multiple documents may be requested by using
		groups of the above joined by:

	    OR

		( XXX does an OR come after every group but the first, or do they
	      all come at the end? )

	( XXX return type could be in the element set)
d2047 5
a2051 1
static query_term **makeWAISQueryTerms(DocObj **docs)
d2056 80
a2135 30
    query_term **terms = NULL;
    long numTerms = 0;
    DocObj *doc = NULL;
    long i;

    if (docs == NULL)
	return ((query_term **) NULL);

    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 1));

    terms[numTerms] = NULL;

    /* loop through the docs making terms for them all */
    for (i = 0, doc = docs[i]; doc != NULL; doc = docs[++i]) {
	any *type = NULL;

	if (doc->Type != NULL)
	    type = stringToAny(doc->Type);

	if (doc->ChunkCode == CT_document)	/* a whole document */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms + 2);

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE, IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL,
						      IGNORE, IGNORE, IGNORE,
						      IGNORE, type);
d2137 4
a2140 42
	    }
	    terms[numTerms] = NULL;
	} else {		/* a document fragment */
	    char chunk_att[ATTRIBUTE_SIZE];
	    any *startChunk = NULL;
	    any *endChunk = NULL;

	    terms = S_REALLOC2(query_term *, terms, numTerms + 6);

	    switch (doc->ChunkCode) {
	    case CT_byte:
	    case CT_line:
		{
		    char start[20], end[20];

		    (doc->ChunkCode == CT_byte) ?
			strncpy(chunk_att, BYTE, ATTRIBUTE_SIZE) :
			strncpy(chunk_att, LINE, ATTRIBUTE_SIZE);
		    sprintf(start, "%ld", doc->ChunkStart.Pos);
		    startChunk = stringToAny(start);
		    sprintf(end, "%ld", doc->ChunkEnd.Pos);
		    endChunk = stringToAny(end);
		}
		break;
	    case CT_paragraph:
		strncpy(chunk_att, PARAGRAPH, ATTRIBUTE_SIZE);
		startChunk = doc->ChunkStart.ID;
		endChunk = doc->ChunkEnd.ID;
		break;
	    default:
		/* error */
		break;
	    }

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE,
						  IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL, IGNORE,
						      IGNORE, IGNORE, IGNORE,
						      type);
d2142 1
a2142 25
	    }
	    terms[numTerms++] = makeAttributeTerm(chunk_att,
						  GREATER_THAN_OR_EQUAL,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  startChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms++] = makeAttributeTerm(chunk_att, LESS_THAN,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  endChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms] = NULL;

	    if (doc->ChunkCode == CT_byte || doc->ChunkCode == CT_line) {
		freeAny(startChunk);
		freeAny(endChunk);
	    }
	}

	freeAny(type);

	if (i != 0)		/* multiple independent queries, need a disjunction */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms);
d2144 14
a2157 2
	    terms[numTerms++] = makeOperatorTerm(OR);
	    terms[numTerms] = NULL;
d2161 1
a2161 1
    return (terms);
d2166 6
a2171 2
static DocObj **makeWAISQueryDocs(query_term **terms)
/* given a list of terms in the form given above, convert them to
d2175 66
a2240 33
    query_term *docTerm = NULL;
    query_term *fragmentTerm = NULL;
    DocObj **docs = NULL;
    DocObj *doc = NULL;
    long docNum, termNum;

    docNum = termNum = 0;

    docs = S_MALLOC(DocObj *);

    docs[docNum] = NULL;

    /* translate the terms into DocObjs */
    while (true) {
	query_term *typeTerm = NULL;
	char *type = NULL;
	long startTermOffset;

	docTerm = terms[termNum];

	if (docTerm == NULL)
	    break;		/* we're done converting */

	typeTerm = terms[termNum + 1];	/* get the lead Term if it exists */

	if (strcmp(typeTerm->Use, DATA_TYPE) == 0)	/* we do have a type */
	{
	    startTermOffset = 3;
	    type = anyToString(typeTerm->Term);
	} else {		/* no type */
	    startTermOffset = 1;
	    typeTerm = NULL;
	    type = NULL;
d2242 6
a2247 35

	/* grow the doc list */
	docs = S_REALLOC2(DocObj *, docs, docNum);

	/* figure out what kind of docObj to build - and build it */
	fragmentTerm = terms[termNum + startTermOffset];
	if (fragmentTerm != NULL && fragmentTerm->TermType == TT_Attribute) {	/* build a document fragment */
	    query_term *startTerm = fragmentTerm;
	    query_term *endTerm = terms[termNum + startTermOffset + 2];

	    if (strcmp(startTerm->Use, BYTE) == 0) {	/* a byte chunk */
		doc = makeDocObjUsingBytes(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("byte");
	    } else if (strcmp(startTerm->Use, LINE) == 0) {	/* a line chunk */
		doc = makeDocObjUsingLines(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("line");
	    } else {
		log_write("chunk");	/* a paragraph chunk */
		doc = makeDocObjUsingParagraphs(duplicateAny(docTerm->Term),
						type,
						duplicateAny(startTerm->Term),
						duplicateAny(endTerm->Term));
	    }
	    termNum += (startTermOffset + 4);	/* point to next term */
	} else {		/* build a full document */
	    doc = makeDocObjUsingWholeDocument(duplicateAny(docTerm->Term),
					       type);
	    log_write("whole doc");
	    termNum += startTermOffset;		/* point to next term */
d2249 4
d2254 5
a2258 8
	docs[docNum++] = doc;	/* insert the new document */

	docs[docNum] = NULL;	/* keep the doc list terminated */

	if (terms[termNum] != NULL)
	    termNum++;		/* skip the OR operator it necessary */
	else
	    break;		/* we are done */
d2261 1
a2261 1
    return (docs);
d2266 3
a2268 1
any *makeWAISTextQuery(DocObj **docs)
d2273 10
a2282 10
    any *buf = NULL;
    query_term **terms = NULL;

    terms = makeWAISQueryTerms(docs);
    buf = writeQuery(terms);

    doList((void **) terms, freeTerm);
    s_free(terms);

    return (buf);
d2287 4
a2290 2
DocObj **readWAISTextQuery(any *buf)
/* given an any whose contents are type 1 queries of the WAIS sort,
d2294 10
a2303 10
    query_term **terms = NULL;
    DocObj **docs = NULL;

    terms = readQuery(buf);
    docs = makeWAISQueryDocs(terms);

    doList((void **) terms, freeTerm);
    s_free(terms);

    return (docs);
d2316 3
a2318 1
void CSTFreeWAISInitResponse(WAISInitResponse *init)
d2321 1
a2321 1
    s_free(init);
d2326 3
a2328 1
void CSTFreeWAISSearch(WAISSearch *query)
d2330 2
a2331 2
{
    s_free(query);
d2336 3
a2338 1
void CSTFreeDocObj(DocObj *doc)
d2340 1
a2340 1
{
d2346 4
a2349 2
void CSTFreeWAISDocumentHeader(WAISDocumentHeader *header)
{
d2355 5
a2359 3
void CSTFreeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
{
    s_free(header);
a2360 1

d2363 3
a2365 1
void CSTFreeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
d2367 1
a2367 1
    s_free(header);
d2372 5
a2376 3
void CSTFreeWAISSearchResponse(WAISSearchResponse * response)
{
    s_free(response);
d2381 5
a2385 3
void CSTFreeWAISDocumentText(WAISDocumentText *docText)
{
    s_free(docText);
d2390 5
a2394 3
void CSTFreeWAISDocHeadlines(WAISDocumentHeadlines *docHeadline)
{
    s_free(docHeadline);
d2399 3
a2401 1
void CSTFreeWAISDocumentCodes(WAISDocumentCodes *docCodes)
d2403 1
a2403 1
    s_free(docCodes);
d2408 3
a2410 1
void CSTFreeWAISTextQuery(any *query)
d2412 1
a2412 1
    freeAny(query);
d2417 1
d2419 3
a2421 3
 *	Routines originally from WMessage.c -- FM
 *
 *----------------------------------------------------------------------*/
d2423 4
a2426 4
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 * 3.26.90
 */
d2439 14
a2452 12
void readWAISPacketHeader(char *msgBuffer,
			  WAISMessage * header_struct)
{
    /* msgBuffer is a string containing at least HEADER_LENGTH bytes. */

    memmove(header_struct->msg_len, msgBuffer, (size_t) 10);
    header_struct->msg_type = char_downcase((unsigned long) msgBuffer[10]);
    header_struct->hdr_vers = char_downcase((unsigned long) msgBuffer[11]);
    memmove(header_struct->server, (void *) (msgBuffer + 12), (size_t) 10);
    header_struct->compression = char_downcase((unsigned long) msgBuffer[22]);
    header_struct->encoding = char_downcase((unsigned long) msgBuffer[23]);
    header_struct->msg_checksum = char_downcase((unsigned long) msgBuffer[24]);
d2454 1
a2454 1

d2460 16
a2475 8

void writeWAISPacketHeader(char *header,
			   long dataLen,
			   long type,
			   char *server,
			   long compression,
			   long encoding,
			   long version)
d2478 2
a2479 2
    char lengthBuf[11];
    char serverBuf[11];
d2481 19
a2499 7
    long serverLen = strlen(server);

    if (serverLen > 10)
	serverLen = 10;

    sprintf(lengthBuf, "%010ld", dataLen);
    strncpy(header, lengthBuf, 10);
a2500 12
    header[10] = type & 0xFF;
    header[11] = version & 0xFF;

    strncpy(serverBuf, server, serverLen);
    strncpy((char *) (header + 12), serverBuf, serverLen);

    header[22] = compression & 0xFF;
    header[23] = encoding & 0xFF;
    header[24] = '0';		/* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */
}

/*---------------------------------------------------------------------*/
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a867 1
	    /* FALLTHRU */
a1206 1
	    /* FALLTHRU */
d2196 1
a2196 1
	break;			/* we're done converting */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d15 2
a16 2
   disclaimer.

d18 1
a18 1
   3.30.90  Harry Morris
d31 1
a31 1
/*	This file implements the Z39.50 extensions required for WAIS
d56 1
a56 1
	*len -= header_len;
d68 1
a68 1
   length
d76 1
a76 1

d78 1
a78 1
}
d82 1
a82 1
static char* writeUserInfoHeader PARAMS((data_tag tag,long infoSize,
d98 1
a98 1
   do that writing.
d108 1
a108 1

d111 1
a111 1

d119 1
a119 1

d122 1
a122 1

d142 1
a142 1
  return(buf);
d147 1
a147 1
WAISInitResponse*
d170 1
a170 1

d176 1
a176 1
void
d202 1
a202 1

d204 1
a204 1

d211 1
a211 1

d213 1
a213 1
  size = buf - buffer;
d215 1
a215 1

d228 1
a228 1
  unsigned long size;
d236 1
a236 1

d238 1
a238 1

d241 1
a241 1

d271 1
a271 1

d280 1
a280 1
WAISSearch*
d297 1
a297 1
{
d307 1
a307 1

d313 1
a313 1
void
d321 1
a321 1

d323 1
a323 1

d328 1
a328 1

d341 1
a341 1
DocObj*
d358 1
a358 1
DocObj*
d379 1
a379 1
DocObj*
d400 1
a400 1
DocObj*
d414 2
a415 2
  doc->ChunkStart.ID = start;
  doc->ChunkEnd.ID = end;
d449 1
a449 1

d455 1
a455 1

d458 1
a458 1

d479 1
a479 1

d496 1
a496 1

d498 1
a498 1

d501 1
a501 1

d542 1
a542 1
  return(buf);
d547 1
a547 1
char*
d560 1
a560 1
						 DefWAISSearchSize);
d565 1
a565 1

d567 1
a567 1

d575 1
a575 1

d577 1
a577 1

d582 1
a582 1

d584 1
a584 1
      size = buf - buffer;
d586 1
a586 1

d593 1
a593 1
char*
d610 1
a610 1
      unsigned long size;
d617 1
a617 1
      char** textList = NULL;
d625 1
a625 1

d628 1
a628 1

d644 1
a644 1
		if (buf == NULL)
d686 1
a686 1

d725 1
a725 1
  WAISDocumentHeader* header =
d739 1
a739 1

d772 1
a772 1

d774 1
a774 1

d790 1
a790 1
	  size += typeSize;
d800 1
a800 1

d802 1
a802 1
  size1 = buf - buffer;
d816 1
a816 1
  unsigned long size1;
d826 1
a826 1

d828 1
a828 1

d831 1
a831 1

d891 1
a891 1

d918 1
a918 1
  WAISDocumentShortHeader* header =
d927 1
a927 1

d953 1
a953 1

d955 1
a955 1

d962 1
a962 1

d964 1
a964 1
  size = buf - buffer;
d978 1
a978 1
  unsigned long size;
d983 1
a983 1

d985 1
a985 1

d988 1
a988 1

d1016 1
a1016 1

d1058 1
a1058 1
  WAISDocumentLongHeader* header =
d1075 1
a1075 1

d1109 1
a1109 1

d1111 1
a1111 1

d1127 1
a1127 1
	  size += typeSize;
d1140 1
a1140 1

d1142 1
a1142 1
  size1 = buf - buffer;
d1156 1
a1156 1
  unsigned long size1;
d1163 1
a1163 1

d1168 1
a1168 1

d1171 1
a1171 1

d1243 1
a1243 1

d1272 1
a1272 1

d1281 1
a1281 1

d1300 1
a1300 1

d1305 1
a1305 1

d1310 1
a1310 1

d1315 1
a1315 1

d1320 1
a1320 1

d1325 1
a1325 1

d1330 1
a1330 1

d1336 1
a1336 1
char*
d1349 1
a1349 1

d1351 1
a1351 1

d1353 1
a1353 1

d1359 1
a1359 1

d1389 1
a1389 1

d1391 1
a1391 1
  size = buf - buffer;
d1393 1
a1393 1

d1421 1
a1421 1
/* if buf is NULL, we have just gotten a read error, and need to clean up
d1429 8
a1436 8
  if (buf == NULL)
   { s_free(seedWordsUsed);
     if (docHeaders != NULL)
       for (i = 0,ptr = (void *)docHeaders[i]; ptr != NULL;
	    ptr = (void *)docHeaders[++i])
	 freeWAISDocumentHeader((WAISDocumentHeader*)ptr);
     s_free(docHeaders);
     if (shortHeaders != NULL)
d1438 1
a1438 1
	    ptr = (void *)shortHeaders[++i])
d1440 4
a1443 4
     s_free(shortHeaders);
     if (longHeaders != NULL)
       for (i = 0,ptr = (void *)longHeaders[i]; ptr != NULL;
	    ptr = (void *)longHeaders[++i])
d1445 2
a1446 2
     s_free(longHeaders);
     if (text != NULL)
d1448 3
a1450 3
	 freeWAISDocumentText((WAISDocumentText*)ptr);
     s_free(text);
     if (headlines != NULL)
d1452 12
a1463 12
	    ptr = (void *)headlines[++i])
	 freeWAISDocumentHeadlines((WAISDocumentHeadlines*)ptr);
     s_free(headlines);
     if (codes != NULL)
       for (i = 0,ptr = (void *)codes[i]; ptr != NULL;
	    ptr = (void *)codes[++i])
	 freeWAISDocumentCodes((WAISDocumentCodes*)ptr);
     s_free(codes);
     if (diags != NULL)
       for (i = 0,ptr = (void *)diags[i]; ptr != NULL;
	    ptr = (void *)diags[++i])
	 freeDiag((diagnosticRecord*)ptr);
d1476 1
a1476 1
  unsigned long size;
d1492 1
a1492 1

d1494 1
a1494 1

d1497 1
a1497 1

d1502 21
a1522 21
	  buf = readString(&seedWordsUsed,buf);
	  break;
	case DT_DatabaseDiagnosticRecords:
	  if (diags == NULL) /* create a new diag list */
	   { diags = (diagnosticRecord**)s_malloc((size_t)sizeof(diagnosticRecord*) * 2);
	   }
	  else /* grow the diag list */
	   { diags = (diagnosticRecord**)s_realloc((char*)diags,(size_t)(sizeof(diagnosticRecord*) * (numDiags + 2)));
	   }
	  buf = readDiag(&diag,buf);
	  diags[numDiags++] = diag; /* put it in the list */
	  diags[numDiags] = NULL;
	  break;
	case DT_DocumentHeaderGroup:
		  if (docHeaders == NULL) /* create a new header list */
		   { docHeaders = (WAISDocumentHeader**)s_malloc((size_t)sizeof(WAISDocumentHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { docHeaders = (WAISDocumentHeader**)s_realloc((char*)docHeaders,(size_t)(sizeof(WAISDocumentHeader*) * (numDocHeaders + 2)));
		   }
		  buf = readWAISDocumentHeader((WAISDocumentHeader**)&header,buf);
d1524 2
a1525 2
		  RETURN_ON_NULL(buf);
		  docHeaders[numDocHeaders++] =
d1527 10
a1536 10
		  docHeaders[numDocHeaders] = NULL;
		  break;
		case DT_DocumentShortHeaderGroup:
		  if (shortHeaders == NULL) /* create a new header list */
		   { shortHeaders = (WAISDocumentShortHeader**)s_malloc((size_t)sizeof(WAISDocumentShortHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { shortHeaders = (WAISDocumentShortHeader**)s_realloc((char*)shortHeaders,(size_t)(sizeof(WAISDocumentShortHeader*) * (numShortHeaders + 2)));
		   }
		  buf = readWAISDocumentShortHeader((WAISDocumentShortHeader**)&header,buf);
d1538 2
a1539 2
		  RETURN_ON_NULL(buf);
		  shortHeaders[numShortHeaders++] =
d1541 10
a1550 10
		  shortHeaders[numShortHeaders] = NULL;
		  break;
		case DT_DocumentLongHeaderGroup:
		  if (longHeaders == NULL) /* create a new header list */
		   { longHeaders = (WAISDocumentLongHeader**)s_malloc((size_t)sizeof(WAISDocumentLongHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { longHeaders = (WAISDocumentLongHeader**)s_realloc((char*)longHeaders,(size_t)(sizeof(WAISDocumentLongHeader*) * (numLongHeaders + 2)));
		   }
		  buf = readWAISDocumentLongHeader((WAISDocumentLongHeader**)&header,buf);
d1552 2
a1553 2
		  RETURN_ON_NULL(buf);
		  longHeaders[numLongHeaders++] =
d1555 10
a1564 10
		  longHeaders[numLongHeaders] = NULL;
		  break;
	case DT_DocumentTextGroup:
		  if (text == NULL) /* create a new list */
		   { text = (WAISDocumentText**)s_malloc((size_t)sizeof(WAISDocumentText*) * 2);
		   }
		  else /* grow the list */
		   { text = (WAISDocumentText**)s_realloc((char*)text,(size_t)(sizeof(WAISDocumentText*) * (numText + 2)));
		   }
		  buf = readWAISDocumentText((WAISDocumentText**)&header,buf);
d1566 2
a1567 2
		  RETURN_ON_NULL(buf);
		  text[numText++] =
d1569 10
a1578 10
		  text[numText] = NULL;
		  break;
		case DT_DocumentHeadlineGroup:
		  if (headlines == NULL) /* create a new list */
		   { headlines = (WAISDocumentHeadlines**)s_malloc((size_t)sizeof(WAISDocumentHeadlines*) * 2);
		   }
		  else /* grow the list */
		   { headlines = (WAISDocumentHeadlines**)s_realloc((char*)headlines,(size_t)(sizeof(WAISDocumentHeadlines*) * (numHeadlines + 2)));
		   }
		  buf = readWAISDocumentHeadlines((WAISDocumentHeadlines**)&header,buf);
d1580 2
a1581 2
		  RETURN_ON_NULL(buf);
		  headlines[numHeadlines++] =
d1583 10
a1592 10
		  headlines[numHeadlines] = NULL;
		  break;
		case DT_DocumentCodeGroup:
		  if (codes == NULL) /* create a new list */
		   { codes = (WAISDocumentCodes**)s_malloc((size_t)sizeof(WAISDocumentCodes*) * 2);
		   }
		  else /* grow the list */
		   { codes = (WAISDocumentCodes**)s_realloc((char*)codes,(size_t)(sizeof(WAISDocumentCodes*) * (numCodes + 2)));
		   }
		  buf = readWAISDocumentCodes((WAISDocumentCodes**)&header,buf);
d1594 2
a1595 2
		  RETURN_ON_NULL(buf);
		  codes[numCodes++] =
d1597 6
a1602 6
		  codes[numCodes] = NULL;
		  break;
	default:
	  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
	  REPORT_READ_ERROR(buf);
	  break;
d1605 1
a1605 1

d1608 1
a1608 1

d1625 1
a1625 1

d1631 1
a1631 1
void
d1642 1
a1642 1
char*
d1652 1
a1652 1

d1658 1
a1658 1

d1660 1
a1660 1
  size = buf - buffer;
d1668 1
a1668 1
char*
d1674 1
a1674 1
  unsigned long size;
d1679 1
a1679 1

d1682 1
a1682 1

d1685 1
a1685 1

d1690 13
a1702 13
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_DocumentText:
		  buf = readAny(&documentText,buf);
		  break;
	default:
	  freeAny(docID);
	  freeAny(documentText);
	  REPORT_READ_ERROR(buf);
	  break;
d1705 1
a1705 1

d1735 1
a1735 1

d1741 1
a1741 1
void
d1755 1
a1755 1
char*
d1765 1
a1765 1

d1774 1
a1774 1

d1776 1
a1776 1
  size = buf - buffer;
d1784 1
a1784 1
char*
d1790 1
a1790 1
  unsigned long size;
d1796 1
a1796 1

d1800 1
a1800 1

d1803 1
a1803 1

d1808 25
a1832 25
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_Source:
		  buf = readString(&source,buf);
		  break;
		case DT_Date:
		  buf = readString(&date,buf);
		  break;
		case DT_Headline:
		  buf = readString(&headline,buf);
		  break;
		case DT_OriginCity:
		  buf = readString(&originCity,buf);
		  break;
	default:
	  freeAny(docID);
	  s_free(source);
	  s_free(date);
	  s_free(headline);
	  s_free(originCity);
	  REPORT_READ_ERROR(buf);
	  break;
d1835 1
a1835 1

d1837 1
a1837 1
									       headline,originCity);
d1862 1
a1862 1

d1868 1
a1868 1
void
d1881 1
a1881 1
char*
d1891 1
a1891 1

d1899 1
a1899 1

d1901 1
a1901 1
  size = buf - buffer;
d1909 1
a1909 1
char*
d1915 1
a1915 1
  unsigned long size;
d1921 1
a1921 1

d1925 1
a1925 1

d1928 1
a1928 1

d1933 21
a1953 21
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_StockCodes:
		  buf = readString(&stockCodes,buf);
		  break;
		case DT_CompanyCodes:
		  buf = readString(&companyCodes,buf);
		  break;
		case DT_IndustryCodes:
		  buf = readString(&industryCodes,buf);
		  break;
	default:
	  freeAny(docID);
	  s_free(stockCodes);
	  s_free(companyCodes);
	  s_free(industryCodes);
	  REPORT_READ_ERROR(buf);
	  break;
d1956 1
a1956 1

d1958 1
a1958 1
									companyCodes,industryCodes);
d1964 1
a1964 1
char*
d1976 1
a1976 1
char*
d1988 1
a1988 1
char*
d2000 1
a2000 1
char*
d2021 1
a2021 1

d2024 3
a2026 3
	    System_Control_Number = docID
	    Data Type = type (optional)
	    And
d2030 17
a2046 17
	    System_Control_Number = docID
	    Data Type = type (optional)
	    And
		Chunk >= start
		And
		Chunk < end
		And

		Information from multiple documents may be requested by using
		groups of the above joined by:

	    OR

		( XXX does an OR come after every group but the first, or do they
	      all come at the end? )

	( XXX return type could be in the element set)
d2050 1
a2050 1

d2078 1
a2078 1
					  (size_t)(sizeof(query_term*) *
d2088 1
a2088 1
	   }
d2095 1
a2095 1

d2097 1
a2097 1
						(size_t)(sizeof(query_term*) *
d2106 1
a2106 1
			strncpy(chunk_att,LINE,ATTRIBUTE_SIZE);
d2135 1
a2135 1
						      IGNORE,IGNORE,IGNORE,
d2151 1
a2151 1

d2153 1
a2153 1

d2156 1
a2156 1
					  (size_t)(sizeof(query_term*) *
d2170 1
a2170 1
static DocObj**
d2173 1
a2173 1
/* given a list of terms in the form given above, convert them to
d2184 1
a2184 1

d2190 1
a2190 1
    {
d2196 1
a2196 1

d2203 1
a2203 1
       { startTermOffset = 3;
d2206 1
a2206 1
      else			/* no type */
d2213 1
a2213 1
      docs = (DocObj**)s_realloc((char*)docs,(size_t)(sizeof(DocObj*) *
d2221 1
a2221 1
	  query_term* endTerm = terms[termNum + startTermOffset + 2];
d2228 1
a2228 1
	   log_write("byte");
d2234 1
a2234 1
	    log_write("line");
d2245 1
a2245 1
	{
d2251 1
a2251 1

d2253 1
a2253 1

d2256 1
a2256 1

d2268 1
a2268 1
any*
d2277 1
a2277 1

d2280 1
a2280 1

d2283 1
a2283 1

d2289 1
a2289 1
DocObj**
d2292 1
a2292 1
/* given an any whose contents are type 1 queries of the WAIS sort,
d2298 1
a2298 1

d2301 1
a2301 1

d2304 1
a2304 1

d2318 1
a2318 1
void
d2328 1
a2328 1
void
d2332 1
a2332 1
{
d2342 1
a2342 1
{
d2351 1
a2351 1
{
d2360 1
a2360 1
{
d2377 1
a2377 1
{
d2383 1
a2383 1
void
d2386 1
a2386 1
{
d2392 1
a2392 1
void
d2395 1
a2395 1
{
d2401 1
a2401 1
void
d2410 1
a2410 1
void
d2426 1
a2426 1
   disclaimer.
d2441 1
a2441 1
void
d2447 2
a2448 2

  memmove(header_struct->msg_len,msgBuffer,(size_t)10);
d2456 1
a2456 1

d2462 1
a2462 1

d2487 1
a2487 1
  sprintf(lengthBuf, "%010ld", dataLen);
d2490 1
a2490 1
  header[10] = type & 0xFF;
d2493 1
a2493 1
  strncpy(serverBuf,server,serverLen);
d2496 5
a2500 5
  header[22] = compression & 0xFF;
  header[23] = encoding & 0xFF;
  header[24] = '0'; /* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */
}

@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d60 2
a61 2
static unsigned long userInfoTagSize (data_tag tag,
					  unsigned long length);
d129 2
a130 2
static char* readUserInfoHeader (data_tag* tag,unsigned long* num,
				     char* buffer);
d438 1
a438 1
static char* writeDocObj (DocObj* doc,char* buffer,long* len);
d485 1
a485 1
static char* readDocObj (DocObj** doc,char* buffer);
d1400 1
a1400 1
cleanUpWaisSearchResponse (char* buf,char* seedWordsUsed,
d1407 1
a1407 1
			       diagnosticRecord**diags);
d2049 1
a2049 1
static query_term** makeWAISQueryTerms (DocObj** docs);
d2168 1
a2168 1
static DocObj** makeWAISQueryDocs (query_term** terms);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 6
a7 6
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	31-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/
d10 3
a12 3
 *	Routines originally from WProt.c -- FM
 *
 *----------------------------------------------------------------------*/
d14 2
a15 2
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
d17 11
a27 11
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris
 * -	removed chunk code from WAISSearchAPDU,
 * -	added makeWAISQueryType1Query() and readWAISType1Query() which replace
 * makeWAISQueryTerms() and makeWAISQueryDocs().
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 * - renamed makeWAISType1Query() to makeWAISTextQuery()
 * renamed readWAISType1Query() to readWAISTextQuery()
 * 5.29.90  TS - fixed bug in makeWAISQueryDocs
 * added CSTFreeWAISFoo functions
 */
d40 1
d58 1
a58 2
#define S_MALLOC(type) (type*)s_malloc(sizeof(type))
#define S_MALLOC2(type) (type*)s_malloc(sizeof(type) * 2)
d60 2
a61 1
#define S_REALLOC2(type, ptr, num) (type*)s_realloc((char*)ptr, (sizeof(type) * (num + 2)))
d63 4
a66 4
/*----------------------------------------------------------------------*/

static unsigned long userInfoTagSize(data_tag tag,
				     unsigned long length)
d71 1
a71 1
    unsigned long size;
d73 3
a75 3
    /* calculate bytes required to represent tag.  max tag is 16K */
    size = writtenCompressedIntSize(tag);
    size += writtenCompressedIntSize(length);
d77 1
a77 1
    return (size);
d82 11
a92 5
static char *writeUserInfoHeader(data_tag tag,
				 long infoSize,
				 long estHeaderSize,
				 char *buffer,
				 long *len)
d101 17
a117 16
    long dummyLen = 100;	/* plenty of space for a tag and size */
    char *buf = buffer;
    long realSize = infoSize - estHeaderSize;
    long realHeaderSize = userInfoTagSize(tag, realSize);

    if (buffer == NULL || *len == 0)
	return (NULL);

    /* write the tag */
    buf = writeTag(tag, buf, &dummyLen);

    /* see if the if the header size was correct. if not,
       we have to shift the info to fit the real header size */
    if (estHeaderSize != realHeaderSize) {	/* make sure there is enough space */
	CHECK_FOR_SPACE_LEFT(realHeaderSize - estHeaderSize, len);
	memmove(buffer + realHeaderSize, buffer + estHeaderSize, (size_t) (realSize));
d120 2
a121 2
    /* write the size */
    writeCompressedInteger(realSize, buf, &dummyLen);
d123 2
a124 2
    /* return the true end of buffer */
    return (buffer + realHeaderSize + realSize);
d129 8
a136 3
static char *readUserInfoHeader(data_tag *tag,
				unsigned long *num,
				char *buffer)
d139 4
a142 5
    char *buf = buffer;

    buf = readTag(tag, buf);
    buf = readCompressedInteger(num, buf);
    return (buf);
d147 13
a159 6
WAISInitResponse *makeWAISInitResponse(long chunkCode,
				       long chunkIDLen,
				       char *chunkMarker,
				       char *highlightMarker,
				       char *deHighlightMarker,
				       char *newLineChars)
d162 1
a162 1
    WAISInitResponse *init = S_MALLOC(WAISInitResponse);
d164 6
a169 6
    init->ChunkCode = chunkCode;	/* note: none are copied! */
    init->ChunkIDLength = chunkIDLen;
    init->ChunkMarker = chunkMarker;
    init->HighlightMarker = highlightMarker;
    init->DeHighlightMarker = deHighlightMarker;
    init->NewlineCharacters = newLineChars;
d171 1
a171 1
    return (init);
d176 3
a178 1
void freeWAISInitResponse(WAISInitResponse *init)
d181 5
a185 5
    s_free(init->ChunkMarker);
    s_free(init->HighlightMarker);
    s_free(init->DeHighlightMarker);
    s_free(init->NewlineCharacters);
    s_free(init);
d190 5
a194 3
char *writeInitResponseInfo(InitResponseAPDU *init,
			    char *buffer,
			    long *len)
d197 5
a201 5
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISInitResponseSize);
    char *buf = buffer + header_len;
    WAISInitResponse *info = (WAISInitResponse *) init->UserInformationField;
    unsigned long size;
d203 1
a203 1
    RESERVE_SPACE_FOR_WAIS_HEADER(len);
d205 6
a210 6
    buf = writeNum(info->ChunkCode, DT_ChunkCode, buf, len);
    buf = writeNum(info->ChunkIDLength, DT_ChunkIDLength, buf, len);
    buf = writeString(info->ChunkMarker, DT_ChunkMarker, buf, len);
    buf = writeString(info->HighlightMarker, DT_HighlightMarker, buf, len);
    buf = writeString(info->DeHighlightMarker, DT_DeHighlightMarker, buf, len);
    buf = writeString(info->NewlineCharacters, DT_NewlineCharacters, buf, len);
d212 3
a214 7
    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);
d216 1
a216 1
    return (buf);
d221 4
a224 2
char *readInitResponseInfo(void **info,
			   char *buffer)
d227 29
a255 30
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    long chunkCode, chunkIDLen;
    data_tag tag1;
    char *chunkMarker = NULL;
    char *highlightMarker = NULL;
    char *deHighlightMarker = NULL;
    char *newLineChars = NULL;

    chunkCode = chunkIDLen = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_ChunkCode:
	    buf = readNum(&chunkCode, buf);
	    break;
	case DT_ChunkIDLength:
	    buf = readNum(&chunkIDLen, buf);
	    break;
	case DT_ChunkMarker:
	    buf = readString(&chunkMarker, buf);
	    break;
	case DT_HighlightMarker:
	    buf = readString(&highlightMarker, buf);
d257 2
a258 2
	case DT_DeHighlightMarker:
	    buf = readString(&deHighlightMarker, buf);
d260 2
a261 2
	case DT_NewlineCharacters:
	    buf = readString(&newLineChars, buf);
d263 1
a263 1
	default:
d269 1
a269 1
	}
d272 4
a275 4
    *info = (void *) makeWAISInitResponse(chunkCode, chunkIDLen, chunkMarker,
					  highlightMarker, deHighlightMarker,
					  newLineChars);
    return (buf);
d280 15
a294 7
WAISSearch *makeWAISSearch(char *seedWords,
			   DocObj **docs,
			   char **textList,
			   long dateFactor,
			   char *beginDateRange,
			   char *endDateRange,
			   long maxDocsRetrieved)
d298 1
a298 1
    WAISSearch *query = S_MALLOC(WAISSearch);
d300 7
a306 7
    query->SeedWords = seedWords;	/* not copied! */
    query->Docs = docs;		/* not copied! */
    query->TextList = textList;	/* not copied! */
    query->DateFactor = dateFactor;
    query->BeginDateRange = beginDateRange;
    query->EndDateRange = endDateRange;
    query->MaxDocumentsRetrieved = maxDocsRetrieved;
d308 1
a308 1
    return (query);
d313 3
a315 1
void freeWAISSearch(WAISSearch *query)
d319 2
a320 2
    void *ptr = NULL;
    long i;
d322 1
a322 1
    s_free(query->SeedWords);
d324 4
a327 6
    if (query->Docs != NULL)
	for (i = 0, ptr = (void *) query->Docs[i];
	     ptr != NULL;
	     ptr = (void *) query->Docs[++i])
	    freeDocObj((DocObj *) ptr);
    s_free(query->Docs);
d329 4
a332 6
    if (query->TextList != NULL)	/* XXX revisit when textlist is fully defined */
	for (i = 0, ptr = (void *) query->TextList[i];
	     ptr != NULL;
	     ptr = (void *) query->TextList[++i])
	    s_free(ptr);
    s_free(query->TextList);
d334 3
a336 3
    s_free(query->BeginDateRange);
    s_free(query->EndDateRange);
    s_free(query);
d341 4
a344 2
DocObj *makeDocObjUsingWholeDocument(any *docID,
				     char *type)
d349 5
a353 6
    DocObj *doc = S_MALLOC(DocObj);

    doc->DocumentID = docID;	/* not copied! */
    doc->Type = type;		/* not copied! */
    doc->ChunkCode = CT_document;
    return (doc);
d358 6
a363 4
DocObj *makeDocObjUsingLines(any *docID,
			     char *type,
			     long start,
			     long end)
d368 7
a374 8
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_line;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
d379 6
a384 4
DocObj *makeDocObjUsingBytes(any *docID,
			     char *type,
			     long start,
			     long end)
d389 7
a395 8
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_byte;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
d400 6
a405 4
DocObj *makeDocObjUsingParagraphs(any *docID,
				  char *type,
				  any *start,
				  any *end)
d410 7
a416 8
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_paragraph;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;
    doc->ChunkStart.ID = start;
    doc->ChunkEnd.ID = end;
    return (doc);
d421 3
a423 1
void freeDocObj(DocObj *doc)
d427 5
a431 5
    freeAny(doc->DocumentID);
    s_free(doc->Type);
    if (doc->ChunkCode == CT_paragraph) {
	freeAny(doc->ChunkStart.ID);
	freeAny(doc->ChunkEnd.ID);
d433 1
a433 1
    s_free(doc);
d438 7
a444 3
static char *writeDocObj(DocObj *doc,
			 char *buffer,
			 long *len)
d448 1
a448 1
    char *buf = buffer;
d450 5
a454 5
    /* we alwasy have to write the id, but its tag depends on if its a chunk */
    if (doc->ChunkCode == CT_document)
	buf = writeAny(doc->DocumentID, DT_DocumentID, buf, len);
    else
	buf = writeAny(doc->DocumentID, DT_DocumentIDChunk, buf, len);
d456 2
a457 2
    if (doc->Type != NULL)
	buf = writeString(doc->Type, DT_TYPE, buf, len);
d459 2
a460 2
    switch (doc->ChunkCode) {
    case CT_document:
d463 5
a467 5
    case CT_byte:
    case CT_line:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeNum(doc->ChunkStart.Pos, DT_ChunkStartID, buf, len);
	buf = writeNum(doc->ChunkEnd.Pos, DT_ChunkEndID, buf, len);
d469 4
a472 4
    case CT_paragraph:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeAny(doc->ChunkStart.ID, DT_ChunkStartID, buf, len);
	buf = writeAny(doc->ChunkEnd.ID, DT_ChunkEndID, buf, len);
d474 1
a474 1
    default:
d478 1
a478 1
    }
d480 1
a480 1
    return (buf);
d485 6
a490 2
static char *readDocObj(DocObj **doc,
			char *buffer)
d494 2
a495 2
    char *buf = buffer;
    data_tag tag;
d497 1
a497 1
    *doc = S_MALLOC(DocObj);
d499 2
a500 2
    tag = peekTag(buf);
    buf = readAny(&((*doc)->DocumentID), buf);
d502 18
a519 18
    if (tag == DT_DocumentID) {
	(*doc)->ChunkCode = CT_document;
	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != what comes next */
	    buf = readString(&((*doc)->Type), buf);
	/* ChunkStart and ChunkEnd are undefined */
    } else if (tag == DT_DocumentIDChunk) {
	boolean readParagraphs = false;		/* for cleanup */

	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != CT_FOO */
	    buf = readString(&((*doc)->Type), buf);
	buf = readNum(&((*doc)->ChunkCode), buf);
	switch ((*doc)->ChunkCode) {
	case CT_byte:
	case CT_line:
	    buf = readNum(&((*doc)->ChunkStart.Pos), buf);
	    buf = readNum(&((*doc)->ChunkEnd.Pos), buf);
d521 1
a521 1
	case CT_paragraph:
d523 2
a524 2
	    buf = readAny(&((*doc)->ChunkStart.ID), buf);
	    buf = readAny(&((*doc)->ChunkEnd.ID), buf);
d526 1
a526 1
	default:
d528 2
a529 2
	    if (readParagraphs) {
		freeAny((*doc)->ChunkStart.ID);
d531 1
a531 1
	    }
d535 6
a540 5
	}
    } else {
	freeAny((*doc)->DocumentID);
	s_free(*doc);
	REPORT_READ_ERROR(buf);
d542 1
a542 1
    return (buf);
d547 5
a551 3
char *writeSearchInfo(SearchAPDU *query,
		      char *buffer,
		      long *len)
d555 19
a573 18
    if (strcmp(query->QueryType, QT_TextRetrievalQuery) == 0) {
	return (writeAny((any *) query->Query, DT_Query, buffer, len));
    } else {
	unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
						   DefWAISSearchSize);
	char *buf = buffer + header_len;
	WAISSearch *info = (WAISSearch *) query->Query;
	unsigned long size;
	long i;

	RESERVE_SPACE_FOR_WAIS_HEADER(len);

	buf = writeString(info->SeedWords, DT_SeedWords, buf, len);

	if (info->Docs != NULL) {
	    for (i = 0; info->Docs[i] != NULL; i++) {
		buf = writeDocObj(info->Docs[i], buf, len);
	    }
d576 6
a581 1
	/* XXX text list */
d583 3
a585 24
	buf = writeNum(info->DateFactor,
		       DT_DateFactor,
		       buf,
		       len);
	buf = writeString(info->BeginDateRange,
			  DT_BeginDateRange,
			  buf,
			  len);
	buf = writeString(info->EndDateRange,
			  DT_EndDateRange,
			  buf,
			  len);
	buf = writeNum(info->MaxDocumentsRetrieved,
		       DT_MaxDocumentsRetrieved,
		       buf,
		       len);

	/* now write the header and size */
	size = buf - buffer;
	buf = writeUserInfoHeader(DT_UserInformationLength,
				  size,
				  header_len,
				  buffer,
				  len);
d587 1
a587 1
	return (buf);
d593 4
a596 2
char *readSearchInfo(void **info,
		     char *buffer)
d600 34
a633 37
    data_tag type = peekTag(buffer);

    if (type == DT_Query)	/* this is a type 1 query */
    {
	char *buf = buffer;
	any *query = NULL;

	buf = readAny(&query, buf);
	*info = (void *) query;
	return (buf);
    } else {			/* a type 3 query */
	char *buf = buffer;
	unsigned long size;
	unsigned long headerSize;
	data_tag tag1;
	char *seedWords = NULL;
	char *beginDateRange = NULL;
	char *endDateRange = NULL;
	long dateFactor, maxDocsRetrieved;
	char **textList = NULL;
	DocObj **docIDs = NULL;
	DocObj *doc = NULL;
	long docs = 0;
	long i;
	void *ptr = NULL;

	dateFactor = maxDocsRetrieved = UNUSED;

	buf = readUserInfoHeader(&tag1, &size, buf);
	headerSize = buf - buffer;

	while (buf < (buffer + size + headerSize)) {
	    data_tag tag = peekTag(buf);

	    switch (tag) {
	    case DT_SeedWords:
		buf = readString(&seedWords, buf);
d635 11
a645 11
	    case DT_DocumentID:
	    case DT_DocumentIDChunk:
		if (docIDs == NULL)	/* create a new doc list */
		{
		    docIDs = S_MALLOC2(DocObj *);
		} else {	/* grow the doc list */
		    docIDs = S_REALLOC2(DocObj *, docIDs, docs);
		}
		buf = readDocObj(&doc, buf);
		if (buf == NULL) {
		    s_free(seedWords);
d649 2
a650 4
			for (i = 0, ptr = (void *) docIDs[i];
			     ptr != NULL;
			     ptr = (void *) docIDs[++i])
			    freeDocObj((DocObj *) ptr);
d653 1
a653 1
		}
d655 1
a655 1
		docIDs[docs++] = doc;	/* put it in the list */
d658 1
a658 1
	    case DT_TextList:
d661 2
a662 2
	    case DT_DateFactor:
		buf = readNum(&dateFactor, buf);
d664 2
a665 2
	    case DT_BeginDateRange:
		buf = readString(&beginDateRange, buf);
d667 2
a668 2
	    case DT_EndDateRange:
		buf = readString(&endDateRange, buf);
d670 2
a671 2
	    case DT_MaxDocumentsRetrieved:
		buf = readNum(&maxDocsRetrieved, buf);
d673 1
a673 1
	    default:
d678 2
a679 4
		    for (i = 0, ptr = (void *) docIDs[i];
			 ptr != NULL;
			 ptr = (void *) docIDs[++i])
			freeDocObj((DocObj *) ptr);
d684 1
a684 1
	    }
d687 4
a690 4
	*info = (void *) makeWAISSearch(seedWords, docIDs, textList,
					dateFactor, beginDateRange, endDateRange,
					maxDocsRetrieved);
	return (buf);
d696 23
a718 11
WAISDocumentHeader *makeWAISDocumentHeader(any *docID,
					   long versionNumber,
					   long score,
					   long bestMatch,
					   long docLen,
					   long lines,
					   char **types,
					   char *source,
					   char *date,
					   char *headline,
					   char *originCity)
d725 2
a726 30
    WAISDocumentHeader *header = S_MALLOC(WAISDocumentHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeader(WAISDocumentHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here ! */
    s_free(header->Types);
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header);
}
d728 63
a790 32
/*----------------------------------------------------------------------*/

char *writeWAISDocumentHeader(WAISDocumentHeader *header, char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeaderGroup,
					       DefWAISDocHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
d792 74
a865 80
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeader(WAISDocumentHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types = NULL;
    char *source = NULL;
    char *date = NULL;
    char *headline = NULL;
    char *originCity = NULL;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		buf = readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
d869 2
a870 2
	case DT_Source:
	    buf = readString(&source, buf);
d872 2
a873 2
	case DT_Date:
	    buf = readString(&date, buf);
d875 2
a876 2
	case DT_Headline:
	    buf = readString(&headline, buf);
d878 2
a879 2
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
d881 1
a881 1
	default:
d889 1
a889 1
	}
d892 4
a895 4
    *header = makeWAISDocumentHeader(docID, versionNumber, score, bestMatch,
				     docLength, lines, types, source, date, headline,
				     originCity);
    return (buf);
d900 13
a912 6
WAISDocumentShortHeader *makeWAISDocumentShortHeader(any *docID,
						     long versionNumber,
						     long score,
						     long bestMatch,
						     long docLen,
						     long lines)
d918 2
a919 1
    WAISDocumentShortHeader *header = S_MALLOC(WAISDocumentShortHeader);
d921 6
a926 6
    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
d928 1
a928 1
    return (header);
d933 3
a935 1
void freeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
d937 2
a938 2
    freeAny(header->DocumentID);
    s_free(header);
d943 5
a947 2
char *writeWAISDocumentShortHeader(WAISDocumentShortHeader *header, char *buffer,
				   long *len)
d949 4
a952 4
    unsigned long header_len = userInfoTagSize(DT_DocumentShortHeaderGroup,
					       DefWAISShortHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size;
d954 1
a954 1
    RESERVE_SPACE_FOR_WAIS_HEADER(len);
d956 6
a961 6
    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
d963 3
a965 7
    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentShortHeaderGroup,
			      size,
			      header_len,
			      buffer,
			      len);
d967 1
a967 1
    return (buf);
d972 4
a975 1
char *readWAISDocumentShortHeader(WAISDocumentShortHeader **header, char *buffer)
d977 6
a982 8
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;
d984 1
a984 2
    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;
d986 2
a987 2
    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);
d989 5
a993 3
	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
d995 2
a996 2
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
d998 2
a999 2
	case DT_Score:
	    buf = readNum(&score, buf);
d1001 2
a1002 2
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
d1004 2
a1005 2
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
d1007 2
a1008 2
	case DT_Lines:
	    buf = readNum(&lines, buf);
d1010 1
a1010 1
	default:
d1014 1
a1014 1
	}
d1017 3
a1019 3
    *header = makeWAISDocumentShortHeader(docID, versionNumber, score, bestMatch,
					  docLength, lines);
    return (buf);
d1024 29
a1052 14
WAISDocumentLongHeader *makeWAISDocumentLongHeader(any *docID,
						   long versionNumber,
						   long score,
						   long bestMatch,
						   long docLen,
						   long lines,
						   char **types,
						   char *source,
						   char *date,
						   char *headline,
						   char *originCity,
						   char *stockCodes,
						   char *companyCodes,
						   char *industryCodes)
d1058 2
a1059 21
    WAISDocumentLongHeader *header = S_MALLOC(WAISDocumentLongHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;
    header->StockCodes = stockCodes;
    header->CompanyCodes = companyCodes;
    header->IndustryCodes = industryCodes;

    return (header);
}

/*----------------------------------------------------------------------*/
d1061 67
a1127 46
void freeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here! */
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header->StockCodes);
    s_free(header->CompanyCodes);
    s_free(header->IndustryCodes);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentLongHeader(WAISDocumentLongHeader *header, char *buffer,
				  long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentLongHeaderGroup,
					       DefWAISLongHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
d1129 77
a1205 93
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);
    buf = writeString(header->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(header->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(header->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentLongHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentLongHeader(WAISDocumentLongHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types;
    char *source, *date, *headline, *originCity, *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber =
	score =
	bestMatch =
	docLength =
	lines = UNUSED;
    types = NULL;
    source =
	date =
	headline =
	originCity =
	stockCodes =
	companyCodes =
	industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
d1209 2
a1210 2
	case DT_Source:
	    buf = readString(&source, buf);
d1212 2
a1213 2
	case DT_Date:
	    buf = readString(&date, buf);
d1215 2
a1216 2
	case DT_Headline:
	    buf = readString(&headline, buf);
d1218 2
a1219 2
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
d1221 2
a1222 2
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
d1224 2
a1225 2
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
d1227 2
a1228 2
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
d1230 1
a1230 1
	default:
d1241 1
a1241 157
	}
    }

    *header = makeWAISDocumentLongHeader(docID,
					 versionNumber,
					 score,
					 bestMatch,
					 docLength,
					 lines,
					 types,
					 source,
					 date,
					 headline,
					 originCity,
					 stockCodes,
					 companyCodes,
					 industryCodes);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISSearchResponse *
  makeWAISSearchResponse(
			    char *seedWordsUsed,
			    WAISDocumentHeader **docHeaders,
			    WAISDocumentShortHeader **shortHeaders,
			    WAISDocumentLongHeader **longHeaders,
			    WAISDocumentText **text,
			    WAISDocumentHeadlines **headlines,
			    WAISDocumentCodes **codes,
			    diagnosticRecord ** diagnostics)
{
    WAISSearchResponse *response = S_MALLOC(WAISSearchResponse);

    response->SeedWordsUsed = seedWordsUsed;
    response->DocHeaders = docHeaders;
    response->ShortHeaders = shortHeaders;
    response->LongHeaders = longHeaders;
    response->Text = text;
    response->Headlines = headlines;
    response->Codes = codes;
    response->Diagnostics = diagnostics;

    return (response);
}

/*----------------------------------------------------------------------*/

void freeWAISSearchResponse(WAISSearchResponse * response)
{
    void *ptr = NULL;
    long i;

    s_free(response->SeedWordsUsed);

    if (response->DocHeaders != NULL)
	for (i = 0, ptr = (void *) response->DocHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->DocHeaders[++i])
	    freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
    s_free(response->DocHeaders);

    if (response->ShortHeaders != NULL)
	for (i = 0, ptr = (void *) response->ShortHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->ShortHeaders[++i])
	    freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
    s_free(response->ShortHeaders);

    if (response->LongHeaders != NULL)
	for (i = 0, ptr = (void *) response->LongHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->LongHeaders[++i])
	    freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
    s_free(response->LongHeaders);

    if (response->Text != NULL)
	for (i = 0, ptr = (void *) response->Text[i];
	     ptr != NULL;
	     ptr = (void *) response->Text[++i])
	    freeWAISDocumentText((WAISDocumentText *) ptr);
    s_free(response->Text);

    if (response->Headlines != NULL)
	for (i = 0, ptr = (void *) response->Headlines[i];
	     ptr != NULL;
	     ptr = (void *) response->Headlines[++i])
	    freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
    s_free(response->Headlines);

    if (response->Codes != NULL)
	for (i = 0, ptr = (void *) response->Codes[i];
	     ptr != NULL;
	     ptr = (void *) response->Codes[++i])
	    freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
    s_free(response->Codes);

    if (response->Diagnostics != NULL)
	for (i = 0, ptr = (void *) response->Diagnostics[i];
	     ptr != NULL;
	     ptr = (void *) response->Diagnostics[++i])
	    freeDiag((diagnosticRecord *) ptr);
    s_free(response->Diagnostics);

    s_free(response);
}

/*----------------------------------------------------------------------*/

char *writeSearchResponseInfo(SearchResponseAPDU *query,
			      char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISSearchResponseSize);
    char *buf = buffer + header_len;
    WAISSearchResponse *info = (WAISSearchResponse *) query->DatabaseDiagnosticRecords;
    unsigned long size;
    void *header = NULL;
    long i;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeString(info->SeedWordsUsed, DT_SeedWordsUsed, buf, len);

    /* write out all the headers */
    if (info->DocHeaders != NULL) {
	for (i = 0, header = (void *) info->DocHeaders[i];
	     header != NULL;
	     header = (void *) info->DocHeaders[++i])
	    buf = writeWAISDocumentHeader((WAISDocumentHeader *) header, buf, len);
    }

    if (info->ShortHeaders != NULL) {
	for (i = 0, header = (void *) info->ShortHeaders[i];
	     header != NULL;
	     header = (void *) info->ShortHeaders[++i])
	    buf = writeWAISDocumentShortHeader((WAISDocumentShortHeader *) header,
					       buf,
					       len);
    }

    if (info->LongHeaders != NULL) {
	for (i = 0, header = (void *) info->LongHeaders[i];
	     header != NULL;
	     header = (void *) info->LongHeaders[++i])
	    buf = writeWAISDocumentLongHeader((WAISDocumentLongHeader *) header,
					      buf,
					      len);
    }

    if (info->Text != NULL) {
	for (i = 0, header = (void *) info->Text[i];
	     header != NULL;
	     header = (void *) info->Text[++i])
	    buf = writeWAISDocumentText((WAISDocumentText *) header, buf, len);
d1244 177
a1420 45
    if (info->Headlines != NULL) {
	for (i = 0, header = (void *) info->Headlines[i];
	     header != NULL;
	     header = (void *) info->Headlines[++i])
	    buf = writeWAISDocumentHeadlines((WAISDocumentHeadlines *) header,
					     buf,
					     len);
    }

    if (info->Codes != NULL) {
	for (i = 0, header = (void *) info->Codes[i];
	     header != NULL;
	     header = (void *) info->Codes[++i])
	    buf = writeWAISDocumentCodes((WAISDocumentCodes *) header, buf, len);
    }

    if (info->Diagnostics != NULL) {
	for (i = 0, header = (void *) info->Diagnostics[i];
	     header != NULL;
	     header = (void *) info->Diagnostics[++i])
	    buf = writeDiag((diagnosticRecord *) header, buf, len);
    }

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

static void cleanUpWaisSearchResponse(char *buf,
				      char *seedWordsUsed,
				      WAISDocumentHeader **docHeaders,
				      WAISDocumentShortHeader **shortHeaders,
				      WAISDocumentLongHeader **longHeaders,
				      WAISDocumentText **text,
				      WAISDocumentHeadlines **headlines,
				      WAISDocumentCodes **codes,
				      diagnosticRecord ** diags)
d1426 2
a1427 43
    void *ptr = NULL;
    long i;

    if (buf == NULL) {
	s_free(seedWordsUsed);
	if (docHeaders != NULL)
	    for (i = 0, ptr = (void *) docHeaders[i]; ptr != NULL;
		 ptr = (void *) docHeaders[++i])
		freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
	s_free(docHeaders);
	if (shortHeaders != NULL)
	    for (i = 0, ptr = (void *) shortHeaders[i]; ptr != NULL;
		 ptr = (void *) shortHeaders[++i])
		freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
	s_free(shortHeaders);
	if (longHeaders != NULL)
	    for (i = 0, ptr = (void *) longHeaders[i]; ptr != NULL;
		 ptr = (void *) longHeaders[++i])
		freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
	s_free(longHeaders);
	if (text != NULL)
	    for (i = 0, ptr = (void *) text[i];
		 ptr != NULL;
		 ptr = (void *) text[++i])
		freeWAISDocumentText((WAISDocumentText *) ptr);
	s_free(text);
	if (headlines != NULL)
	    for (i = 0, ptr = (void *) headlines[i]; ptr != NULL;
		 ptr = (void *) headlines[++i])
		freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
	s_free(headlines);
	if (codes != NULL)
	    for (i = 0, ptr = (void *) codes[i]; ptr != NULL;
		 ptr = (void *) codes[++i])
		freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
	s_free(codes);
	if (diags != NULL)
	    for (i = 0, ptr = (void *) diags[i]; ptr != NULL;
		 ptr = (void *) diags[++i])
		freeDiag((diagnosticRecord *) ptr);
	s_free(diags);
    }
}
d1429 75
a1503 40
/*----------------------------------------------------------------------*/

char *readSearchResponseInfo(void **info,
			     char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    void *header = NULL;
    WAISDocumentHeader **docHeaders = NULL;
    WAISDocumentShortHeader **shortHeaders = NULL;
    WAISDocumentLongHeader **longHeaders = NULL;
    WAISDocumentText **text = NULL;
    WAISDocumentHeadlines **headlines = NULL;
    WAISDocumentCodes **codes = NULL;
    long numDocHeaders, numLongHeaders, numShortHeaders, numText, numHeadlines;
    long numCodes;
    char *seedWordsUsed = NULL;
    diagnosticRecord **diags = NULL;
    diagnosticRecord *diag = NULL;
    long numDiags = 0;

    numDocHeaders =
	numLongHeaders =
	numShortHeaders =
	numText =
	numHeadlines =
	numCodes = 0;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_SeedWordsUsed:
	    buf = readString(&seedWordsUsed, buf);
	    break;
d1505 10
a1514 10
	    if (diags == NULL)	/* create a new diag list */
	    {
		diags = S_MALLOC2(diagnosticRecord *);
	    } else {		/* grow the diag list */
		diags = S_REALLOC2(diagnosticRecord *, diags, numDiags);
	    }
	    buf = readDiag(&diag, buf);
	    diags[numDiags++] = diag;	/* put it in the list */
	    diags[numDiags] = NULL;
	    break;
d1516 41
a1556 71
	    if (docHeaders == NULL)	/* create a new header list */
	    {
		docHeaders = S_MALLOC2(WAISDocumentHeader *);
	    } else {		/* grow the doc list */
		docHeaders = S_REALLOC2(WAISDocumentHeader *, docHeaders, numDocHeaders);
	    }
	    buf = readWAISDocumentHeader((WAISDocumentHeader **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    docHeaders[numDocHeaders++] =
		(WAISDocumentHeader *) header;	/* put it in the list */
	    docHeaders[numDocHeaders] = NULL;
	    break;
	case DT_DocumentShortHeaderGroup:
	    if (shortHeaders == NULL)	/* create a new header list */
	    {
		shortHeaders = S_MALLOC2(WAISDocumentShortHeader *);
	    } else {		/* grow the doc list */
		shortHeaders = S_REALLOC2(WAISDocumentShortHeader *,
					  shortHeaders,
					  numShortHeaders);
	    }
	    buf = readWAISDocumentShortHeader((WAISDocumentShortHeader **) &header,
					      buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    shortHeaders[numShortHeaders++] =
		(WAISDocumentShortHeader *) header;	/* put it in the list */
	    shortHeaders[numShortHeaders] = NULL;
	    break;
	case DT_DocumentLongHeaderGroup:
	    if (longHeaders == NULL)	/* create a new header list */
	    {
		longHeaders = S_MALLOC2(WAISDocumentLongHeader *);
	    } else {		/* grow the doc list */
		longHeaders = S_REALLOC2(WAISDocumentLongHeader *,
					 longHeaders,
					 numLongHeaders);
	    }
	    buf = readWAISDocumentLongHeader((WAISDocumentLongHeader **) &header,
					     buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    longHeaders[numLongHeaders++] =
		(WAISDocumentLongHeader *) header;	/* put it in the list */
	    longHeaders[numLongHeaders] = NULL;
	    break;
d1558 41
a1598 66
	    if (text == NULL)	/* create a new list */
	    {
		text = S_MALLOC2(WAISDocumentText *);
	    } else {		/* grow the list */
		text = S_REALLOC2(WAISDocumentText *, text, numText);
	    }
	    buf = readWAISDocumentText((WAISDocumentText **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    text[numText++] =
		(WAISDocumentText *) header;	/* put it in the list */
	    text[numText] = NULL;
	    break;
	case DT_DocumentHeadlineGroup:
	    if (headlines == NULL)	/* create a new list */
	    {
		headlines = S_MALLOC2(WAISDocumentHeadlines *);
	    } else {		/* grow the list */
		headlines = S_REALLOC2(WAISDocumentHeadlines *, headlines, numHeadlines);
	    }
	    buf = readWAISDocumentHeadlines((WAISDocumentHeadlines **) &header,
					    buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    headlines[numHeadlines++] =
		(WAISDocumentHeadlines *) header;	/* put it in the list */
	    headlines[numHeadlines] = NULL;
	    break;
	case DT_DocumentCodeGroup:
	    if (codes == NULL)	/* create a new list */
	    {
		codes = S_MALLOC2(WAISDocumentCodes *);
	    } else {		/* grow the list */
		codes = S_REALLOC2(WAISDocumentCodes *, codes, numCodes);
	    }
	    buf = readWAISDocumentCodes((WAISDocumentCodes **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    codes[numCodes++] =
		(WAISDocumentCodes *) header;	/* put it in the list */
	    codes[numCodes] = NULL;
	    break;
d1600 5
a1604 13
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }
d1606 2
a1607 8
    *info = (void *) makeWAISSearchResponse(seedWordsUsed,
					    docHeaders,
					    shortHeaders,
					    longHeaders,
					    text,
					    headlines,
					    codes,
					    diags);
d1609 1
a1609 1
    return (buf);
d1614 5
a1618 3
WAISDocumentText *makeWAISDocumentText(any *docID,
				       long versionNumber,
				       any *documentText)
d1620 1
a1620 1
    WAISDocumentText *docText = S_MALLOC(WAISDocumentText);
d1622 3
a1624 3
    docText->DocumentID = docID;
    docText->VersionNumber = versionNumber;
    docText->DocumentText = documentText;
d1626 1
a1626 1
    return (docText);
d1631 3
a1633 1
void freeWAISDocumentText(WAISDocumentText *docText)
d1635 3
a1637 3
    freeAny(docText->DocumentID);
    freeAny(docText->DocumentText);
    s_free(docText);
d1642 5
a1646 2
char *writeWAISDocumentText(WAISDocumentText *docText, char *buffer,
			    long *len)
d1648 4
a1651 4
    unsigned long header_len = userInfoTagSize(DT_DocumentTextGroup,
					       DefWAISDocTextSize);
    char *buf = buffer + header_len;
    unsigned long size;
d1653 1
a1653 1
    RESERVE_SPACE_FOR_WAIS_HEADER(len);
d1655 3
a1657 3
    buf = writeAny(docText->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docText->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeAny(docText->DocumentText, DT_DocumentText, buf, len);
d1659 3
a1661 3
    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentTextGroup, size, header_len, buffer, len);
d1663 1
a1663 1
    return (buf);
d1668 4
a1671 1
char *readWAISDocumentText(WAISDocumentText **docText, char *buffer)
d1673 6
a1678 6
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID, *documentText;
    long versionNumber;
d1680 2
a1681 2
    docID = documentText = NULL;
    versionNumber = UNUSED;
d1683 2
a1684 2
    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;
d1686 12
a1697 13
    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_DocumentText:
	    buf = readAny(&documentText, buf);
	    break;
d1699 126
a1824 115
	    freeAny(docID);
	    freeAny(documentText);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docText = makeWAISDocumentText(docID, versionNumber, documentText);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentHeadlines *makeWAISDocumentHeadlines(any *docID,
						 long versionNumber,
						 char *source,
						 char *date,
						 char *headline,
						 char *originCity)
{
    WAISDocumentHeadlines *docHeadline = S_MALLOC(WAISDocumentHeadlines);

    docHeadline->DocumentID = docID;
    docHeadline->VersionNumber = versionNumber;
    docHeadline->Source = source;
    docHeadline->Date = date;
    docHeadline->Headline = headline;
    docHeadline->OriginCity = originCity;

    return (docHeadline);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline)
{
    freeAny(docHeadline->DocumentID);
    s_free(docHeadline->Source);
    s_free(docHeadline->Date);
    s_free(docHeadline->Headline);
    s_free(docHeadline->OriginCity);
    s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline, char *buffer,
				 long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeadlineGroup,
					       DefWAISDocHeadlineSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docHeadline->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docHeadline->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docHeadline->Source, DT_Source, buf, len);
    buf = writeString(docHeadline->Date, DT_Date, buf, len);
    buf = writeString(docHeadline->Headline, DT_Headline, buf, len);
    buf = writeString(docHeadline->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeadlineGroup,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeadlines(WAISDocumentHeadlines **docHeadline, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *source, *date, *headline, *originCity;

    docID = NULL;
    versionNumber = UNUSED;
    source = date = headline = originCity = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
d1826 121
a1946 110
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docHeadline = makeWAISDocumentHeadlines(docID, versionNumber, source, date,
					     headline, originCity);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentCodes *makeWAISDocumentCodes(any *docID,
					 long versionNumber,
					 char *stockCodes,
					 char *companyCodes,
					 char *industryCodes)
{
    WAISDocumentCodes *docCodes = S_MALLOC(WAISDocumentCodes);

    docCodes->DocumentID = docID;
    docCodes->VersionNumber = versionNumber;
    docCodes->StockCodes = stockCodes;
    docCodes->CompanyCodes = companyCodes;
    docCodes->IndustryCodes = industryCodes;

    return (docCodes);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentCodes(WAISDocumentCodes *docCodes)
{
    freeAny(docCodes->DocumentID);
    s_free(docCodes->StockCodes);
    s_free(docCodes->CompanyCodes);
    s_free(docCodes->IndustryCodes);
    s_free(docCodes);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentCodes(WAISDocumentCodes *docCodes,
			     char *buffer,
			     long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentCodeGroup,
					       DefWAISDocCodeSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docCodes->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docCodes->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docCodes->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(docCodes->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(docCodes->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentCodeGroup, size, header_len, buffer, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentCodes(WAISDocumentCodes **docCodes,
			    char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber = UNUSED;
    stockCodes = companyCodes = industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
	    break;
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
	    break;
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
	    break;
d1948 8
a1955 8
	    freeAny(docID);
	    s_free(stockCodes);
	    s_free(companyCodes);
	    s_free(industryCodes);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }
d1957 3
a1959 3
    *docCodes = makeWAISDocumentCodes(docID, versionNumber, stockCodes,
				      companyCodes, industryCodes);
    return (buf);
d1964 5
a1968 2
char *writePresentInfo(PresentAPDU * present GCC_UNUSED, char *buffer,
		       long *len GCC_UNUSED)
d1970 2
a1971 2
    /* The WAIS protocol doesn't use present info */
    return (buffer);
d1976 4
a1979 2
char *readPresentInfo(void **info,
		      char *buffer)
d1981 3
a1983 3
    /* The WAIS protocol doesn't use present info */
    *info = NULL;
    return (buffer);
d1988 5
a1992 2
char *writePresentResponseInfo(PresentResponseAPDU * response GCC_UNUSED, char *buffer,
			       long *len GCC_UNUSED)
d1994 2
a1995 2
    /* The WAIS protocol doesn't use presentResponse info */
    return (buffer);
d2000 4
a2003 2
char *readPresentResponseInfo(void **info,
			      char *buffer)
d2005 3
a2007 3
    /* The WAIS protocol doesn't use presentResponse info */
    *info = NULL;
    return (buffer);
d2049 5
a2053 1
static query_term **makeWAISQueryTerms(DocObj **docs)
d2058 80
a2137 30
    query_term **terms = NULL;
    long numTerms = 0;
    DocObj *doc = NULL;
    long i;

    if (docs == NULL)
	return ((query_term **) NULL);

    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 1));

    terms[numTerms] = NULL;

    /* loop through the docs making terms for them all */
    for (i = 0, doc = docs[i]; doc != NULL; doc = docs[++i]) {
	any *type = NULL;

	if (doc->Type != NULL)
	    type = stringToAny(doc->Type);

	if (doc->ChunkCode == CT_document)	/* a whole document */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms + 2);

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE, IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL,
						      IGNORE, IGNORE, IGNORE,
						      IGNORE, type);
d2139 4
a2142 42
	    }
	    terms[numTerms] = NULL;
	} else {		/* a document fragment */
	    char chunk_att[ATTRIBUTE_SIZE];
	    any *startChunk = NULL;
	    any *endChunk = NULL;

	    terms = S_REALLOC2(query_term *, terms, numTerms + 6);

	    switch (doc->ChunkCode) {
	    case CT_byte:
	    case CT_line:
		{
		    char start[20], end[20];

		    (doc->ChunkCode == CT_byte) ?
			strncpy(chunk_att, BYTE, ATTRIBUTE_SIZE) :
			strncpy(chunk_att, LINE, ATTRIBUTE_SIZE);
		    sprintf(start, "%ld", doc->ChunkStart.Pos);
		    startChunk = stringToAny(start);
		    sprintf(end, "%ld", doc->ChunkEnd.Pos);
		    endChunk = stringToAny(end);
		}
		break;
	    case CT_paragraph:
		strncpy(chunk_att, PARAGRAPH, ATTRIBUTE_SIZE);
		startChunk = doc->ChunkStart.ID;
		endChunk = doc->ChunkEnd.ID;
		break;
	    default:
		/* error */
		break;
	    }

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE,
						  IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL, IGNORE,
						      IGNORE, IGNORE, IGNORE,
						      type);
d2144 1
a2144 21
	    }
	    terms[numTerms++] = makeAttributeTerm(chunk_att,
						  GREATER_THAN_OR_EQUAL,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  startChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms++] = makeAttributeTerm(chunk_att, LESS_THAN,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  endChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms] = NULL;

	    if (doc->ChunkCode == CT_byte || doc->ChunkCode == CT_line) {
		freeAny(startChunk);
		freeAny(endChunk);
	    }
	}

	freeAny(type);
d2146 14
a2159 6
	if (i != 0)		/* multiple independent queries, need a disjunction */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms);

	    terms[numTerms++] = makeOperatorTerm(OR);
	    terms[numTerms] = NULL;
d2163 1
a2163 1
    return (terms);
d2168 5
a2172 1
static DocObj **makeWAISQueryDocs(query_term **terms)
d2177 5
a2181 5
    query_term *docTerm = NULL;
    query_term *fragmentTerm = NULL;
    DocObj **docs = NULL;
    DocObj *doc = NULL;
    long docNum, termNum;
d2183 1
a2183 1
    docNum = termNum = 0;
d2185 2
a2186 1
    docs = S_MALLOC(DocObj *);
d2188 57
a2244 16
    docs[docNum] = NULL;

    /* translate the terms into DocObjs */
    while (true) {
	query_term *typeTerm = NULL;
	char *type = NULL;
	long startTermOffset;

	docTerm = terms[termNum];

	if (docTerm == NULL)
	    break;		/* we're done converting */

	typeTerm = terms[termNum + 1];	/* get the lead Term if it exists */

	if (strcmp(typeTerm->Use, DATA_TYPE) == 0)	/* we do have a type */
d2246 4
a2249 6
	    startTermOffset = 3;
	    type = anyToString(typeTerm->Term);
	} else {		/* no type */
	    startTermOffset = 1;
	    typeTerm = NULL;
	    type = NULL;
d2252 1
a2252 35
	/* grow the doc list */
	docs = S_REALLOC2(DocObj *, docs, docNum);

	/* figure out what kind of docObj to build - and build it */
	fragmentTerm = terms[termNum + startTermOffset];
	if (fragmentTerm != NULL && fragmentTerm->TermType == TT_Attribute) {	/* build a document fragment */
	    query_term *startTerm = fragmentTerm;
	    query_term *endTerm = terms[termNum + startTermOffset + 2];

	    if (strcmp(startTerm->Use, BYTE) == 0) {	/* a byte chunk */
		doc = makeDocObjUsingBytes(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("byte");
	    } else if (strcmp(startTerm->Use, LINE) == 0) {	/* a line chunk */
		doc = makeDocObjUsingLines(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("line");
	    } else {
		log_write("chunk");	/* a paragraph chunk */
		doc = makeDocObjUsingParagraphs(duplicateAny(docTerm->Term),
						type,
						duplicateAny(startTerm->Term),
						duplicateAny(endTerm->Term));
	    }
	    termNum += (startTermOffset + 4);	/* point to next term */
	} else {		/* build a full document */
	    doc = makeDocObjUsingWholeDocument(duplicateAny(docTerm->Term),
					       type);
	    log_write("whole doc");
	    termNum += startTermOffset;		/* point to next term */
	}
d2254 1
a2254 1
	docs[docNum++] = doc;	/* insert the new document */
a2255 1
	docs[docNum] = NULL;	/* keep the doc list terminated */
d2257 4
a2260 4
	if (terms[termNum] != NULL)
	    termNum++;		/* skip the OR operator it necessary */
	else
	    break;		/* we are done */
d2263 1
a2263 1
    return (docs);
d2268 3
a2270 1
any *makeWAISTextQuery(DocObj **docs)
d2275 2
a2276 2
    any *buf = NULL;
    query_term **terms = NULL;
d2278 2
a2279 2
    terms = makeWAISQueryTerms(docs);
    buf = writeQuery(terms);
d2281 2
a2282 2
    doList((void **) terms, freeTerm);
    s_free(terms);
d2284 1
a2284 1
    return (buf);
d2289 3
a2291 1
DocObj **readWAISTextQuery(any *buf)
d2296 2
a2297 2
    query_term **terms = NULL;
    DocObj **docs = NULL;
d2299 2
a2300 2
    terms = readQuery(buf);
    docs = makeWAISQueryDocs(terms);
d2302 2
a2303 2
    doList((void **) terms, freeTerm);
    s_free(terms);
d2305 1
a2305 1
    return (docs);
d2318 3
a2320 1
void CSTFreeWAISInitResponse(WAISInitResponse *init)
d2323 1
a2323 1
    s_free(init);
d2328 3
a2330 1
void CSTFreeWAISSearch(WAISSearch *query)
d2333 1
a2333 1
    s_free(query);
d2338 3
a2340 1
void CSTFreeDocObj(DocObj *doc)
d2348 3
a2350 1
void CSTFreeWAISDocumentHeader(WAISDocumentHeader *header)
d2357 3
a2359 1
void CSTFreeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
d2361 1
a2361 1
    s_free(header);
a2362 1

d2365 3
a2367 1
void CSTFreeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
d2369 1
a2369 1
    s_free(header);
d2374 3
a2376 1
void CSTFreeWAISSearchResponse(WAISSearchResponse * response)
d2378 1
a2378 1
    s_free(response);
d2383 3
a2385 1
void CSTFreeWAISDocumentText(WAISDocumentText *docText)
d2387 1
a2387 1
    s_free(docText);
d2392 3
a2394 1
void CSTFreeWAISDocHeadlines(WAISDocumentHeadlines *docHeadline)
d2396 1
a2396 1
    s_free(docHeadline);
d2401 3
a2403 1
void CSTFreeWAISDocumentCodes(WAISDocumentCodes *docCodes)
d2405 1
a2405 1
    s_free(docCodes);
d2410 3
a2412 1
void CSTFreeWAISTextQuery(any *query)
d2414 1
a2414 1
    freeAny(query);
d2419 1
d2421 3
a2423 3
 *	Routines originally from WMessage.c -- FM
 *
 *----------------------------------------------------------------------*/
d2425 4
a2428 4
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 * 3.26.90
 */
d2441 14
a2454 12
void readWAISPacketHeader(char *msgBuffer,
			  WAISMessage * header_struct)
{
    /* msgBuffer is a string containing at least HEADER_LENGTH bytes. */

    memmove(header_struct->msg_len, msgBuffer, (size_t) 10);
    header_struct->msg_type = char_downcase((unsigned long) msgBuffer[10]);
    header_struct->hdr_vers = char_downcase((unsigned long) msgBuffer[11]);
    memmove(header_struct->server, (void *) (msgBuffer + 12), (size_t) 10);
    header_struct->compression = char_downcase((unsigned long) msgBuffer[22]);
    header_struct->encoding = char_downcase((unsigned long) msgBuffer[23]);
    header_struct->msg_checksum = char_downcase((unsigned long) msgBuffer[24]);
d2463 15
a2477 7
void writeWAISPacketHeader(char *header,
			   long dataLen,
			   long type,
			   char *server,
			   long compression,
			   long encoding,
			   long version)
d2480 2
a2481 2
    char lengthBuf[11];
    char serverBuf[11];
d2483 3
a2485 1
    long serverLen = strlen(server);
d2487 2
a2488 2
    if (serverLen > 10)
	serverLen = 10;
d2490 2
a2491 2
    sprintf(lengthBuf, "%010ld", dataLen);
    strncpy(header, lengthBuf, 10);
d2493 2
a2494 2
    header[10] = type & 0xFF;
    header[11] = version & 0xFF;
d2496 3
a2498 6
    strncpy(serverBuf, server, serverLen);
    strncpy((char *) (header + 12), serverBuf, serverLen);

    header[22] = compression & 0xFF;
    header[23] = encoding & 0xFF;
    header[24] = '0';		/* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */
d2502 1
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a867 1
	    /* FALLTHRU */
a1206 1
	    /* FALLTHRU */
d2196 1
a2196 1
	break;			/* we're done converting */
@

