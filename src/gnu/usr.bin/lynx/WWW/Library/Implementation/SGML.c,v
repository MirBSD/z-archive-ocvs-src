head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.6
	tg-mergefixes-1-branch:1.1.3.6.0.8
	tg-mergefixes-1-base:1.1.3.6
	MIROS_X:1.1.3.6.0.6
	MIROS_X_BASE:1.1.3.6
	MIRBSD_XP_MIRPPC:1.1.3.6.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.6
	MIRBSD_XP_SPARC:1.1.3.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.6
	lynx-2_8_6dev_5:1.1.3.6
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.5
	lynx-2_8_5:1.1.3.4
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.45.51;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.18.16.55.53;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.13.12.36;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.04;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.11;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.02;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.27.03;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.52;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.05;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.25;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.02.08.13.05.49;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.04.30.16.15.15;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.07.15.15.47.17;	author tg;	state Stab;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/*			General SGML Parser code		SGML.c
 *			========================
 *
 *	This module implements an HTStream object.  To parse an
 *	SGML file, create this object which is a parser.  The object
 *	is (currently) created by being passed a DTD structure,
 *	and a target HTStructured object at which to throw the parsed stuff.
 *
 *	 6 Feb 93  Binary searches used. Interface modified.
 */

#include <HTUtils.h>

/* Remove the following to disable the experimental HTML DTD parsing.
   Currently only used in this source file. - kw */

#ifndef NO_EXTENDED_HTMLDTD
#define EXTENDED_HTMLDTD
#endif

#include <SGML.h>
#include <HTMLDTD.h>
#include <HTCJK.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <HTChunk.h>
#include <HTUtils.h>

#include <LYCharSets.h>
#include <LYCharVals.h>		/* S/390 -- gil -- 0635 */
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYLeaks.h>

#ifdef USE_COLOR_STYLE
# include <LYStyle.h>
#endif
#ifdef USE_PRETTYSRC
# include <LYPrettySrc.h>
#endif

#define INVALID (-1)

#ifdef USE_PRETTYSRC

static char *entity_string;	/* this is used for printing entity name.

				   Unconditionally added since redundant assigments don't hurt much */

static void fake_put_character(void *p GCC_UNUSED,
			       char c GCC_UNUSED)
{
}

#define START TRUE
#define STOP FALSE

#define PUTS_TR(x) psrc_convert_string = TRUE; PUTS(x)

#endif

/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
#define my_casecomp(a,b)  ((TOUPPER(*a) == TOUPPER(*b)) ? \
			AS_casecomp(a,b) : \
			(TOASCII(TOUPPER(*a)) - TOASCII(TOUPPER(*b))))

 /* will use partially inlined version */
#define orig_HTChunkPutUtf8Char HTChunkPutUtf8Char
#undef HTChunkPutUtf8Char

/* ...used for comments and attributes value like href... */
#define HTChunkPutUtf8Char(ch,x) \
    { \
    if ((TOASCII(x) < 128)  && (ch->size < ch->allocated)) \
	ch->data[ch->size++] = (char)x; \
    else \
	orig_HTChunkPutUtf8Char(ch,x); \
    }

#define PUTS(str) ((*context->actions->put_string)(context->target, str))
#define PUTC(ch)  ((*context->actions->put_character)(context->target, ch))
#define PUTUTF8(code) (UCPutUtf8_charstring((HTStream *)context->target, \
		      (putc_func_t*)(context->actions->put_character), code))

#define OPT 1

/*the following macros are used for pretty source view. */
#define IS_C(attr) (attr.type == HTMLA_CLASS)

HTCJKlang HTCJK = NOCJK;	/* CJK enum value.              */
BOOL HTPassEightBitRaw = FALSE;	/* Pass 161-172,174-255 raw.    */
BOOL HTPassEightBitNum = FALSE;	/* Pass ^ numeric entities raw. */
BOOL HTPassHighCtrlRaw = FALSE;	/* Pass 127-160,173,&#127; raw. */
BOOL HTPassHighCtrlNum = FALSE;	/* Pass &#128;-&#159; raw.      */

/*	The State (context) of the parser
 *
 *	This is passed with each call to make the parser reentrant
 *
 */

#define MAX_ATTRIBUTES 36	/* Max number of attributes per element */

/*		Element Stack
 *		-------------
 *	This allows us to return down the stack reselecting styles.
 *	As we return, attribute values will be garbage in general.
 */
typedef struct _HTElement HTElement;
struct _HTElement {
    HTElement *next;		/* Previously nested element or 0 */
    HTTag *tag;			/* The tag at this level  */
};

typedef enum {
    S_text = 0
    ,S_attr
    ,S_attr_gap
    ,S_comment
    ,S_cro
    ,S_doctype
    ,S_dollar
    ,S_dollar_dq
    ,S_dollar_paren
    ,S_dollar_paren_dq
    ,S_dollar_paren_sq
    ,S_dollar_sq
    ,S_dquoted
    ,S_end
    ,S_entity
    ,S_equals
    ,S_ero
    ,S_esc
    ,S_esc_dq
    ,S_esc_sq
    ,S_exclamation
    ,S_in_kanji
    ,S_incro
    ,S_junk_pi
    ,S_junk_tag
    ,S_litteral
    ,S_marked
    ,S_nonascii_text
    ,S_nonascii_text_dq
    ,S_nonascii_text_sq
    ,S_paren
    ,S_paren_dq
    ,S_paren_sq
    ,S_pcdata
    ,S_script
    ,S_sgmlatt
    ,S_sgmlele
    ,S_sgmlent
    ,S_squoted
    ,S_tag
    ,S_tag_gap
    ,S_tagname_slash
    ,S_value
} sgml_state;

/*	Internal Context Data Structure
 *	-------------------------------
 */
struct _HTStream {

    const HTStreamClass *isa;	/* inherited from HTStream */

    const SGML_dtd *dtd;
    const HTStructuredClass *actions;	/* target class  */
    HTStructured *target;	/* target object */

    HTTag *current_tag;
    HTTag *slashedtag;
    const HTTag *unknown_tag;
    BOOL inSELECT;
    BOOL no_lynx_specialcodes;
    int current_attribute_number;
    HTChunk *string;
    int leading_spaces;
    int trailing_spaces;
    HTElement *element_stack;
    sgml_state state;
    unsigned char kanji_buf;
#ifdef CALLERDATA
    void *callerData;
#endif				/* CALLERDATA */
    BOOL present[MAX_ATTRIBUTES];	/* Flags: attribute is present? */
    char *value[MAX_ATTRIBUTES];	/* NULL, or strings alloc'd with StrAllocCopy_extra() */

    BOOL lead_exclamation;
    BOOL first_dash;
    BOOL end_comment;
    BOOL doctype_bracket;
    BOOL first_bracket;
    BOOL second_bracket;
    BOOL isHex;

    HTParentAnchor *node_anchor;
    LYUCcharset *inUCI;		/* pointer to anchor UCInfo */
    int inUCLYhndl;		/* charset we are fed       */
    LYUCcharset *outUCI;	/* anchor UCInfo for target */
    int outUCLYhndl;		/* charset for target       */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
    UCTransParams T;
    int current_tag_charset;	/* charset to pass attributes */

    char *recover;
    int recover_index;
    char *include;
    char *active_include;
    int include_index;
    char *url;
    char *csi;
    int csi_index;
#ifdef USE_PRETTYSRC
    BOOL cur_attr_is_href;
    BOOL cur_attr_is_name;
    BOOL seen_nonwhite_in_junk_tag;
#endif
};

#ifndef NO_LYNX_TRACE
static const char *state_name(sgml_state n)
{
    const char *result = "?";
    /* *INDENT-OFF* */
    switch (n) {
    case S_attr:                result = "S_attr";              break;
    case S_attr_gap:            result = "S_attr_gap";          break;
    case S_comment:             result = "S_comment";           break;
    case S_cro:                 result = "S_cro";               break;
    case S_doctype:             result = "S_doctype";           break;
    case S_dollar:              result = "S_dollar";            break;
    case S_dollar_dq:           result = "S_dollar_dq";         break;
    case S_dollar_paren:        result = "S_dollar_paren";      break;
    case S_dollar_paren_dq:     result = "S_dollar_paren_dq";   break;
    case S_dollar_paren_sq:     result = "S_dollar_paren_sq";   break;
    case S_dollar_sq:           result = "S_dollar_sq";         break;
    case S_dquoted:             result = "S_dquoted";           break;
    case S_end:                 result = "S_end";               break;
    case S_entity:              result = "S_entity";            break;
    case S_equals:              result = "S_equals";            break;
    case S_ero:                 result = "S_ero";               break;
    case S_esc:                 result = "S_esc";               break;
    case S_esc_dq:              result = "S_esc_dq";            break;
    case S_esc_sq:              result = "S_esc_sq";            break;
    case S_exclamation:         result = "S_exclamation";       break;
    case S_in_kanji:            result = "S_in_kanji";          break;
    case S_incro:               result = "S_incro";             break;
    case S_junk_pi:             result = "S_junk_pi";           break;
    case S_junk_tag:            result = "S_junk_tag";          break;
    case S_litteral:            result = "S_litteral";          break;
    case S_marked:              result = "S_marked";            break;
    case S_nonascii_text:       result = "S_nonascii_text";     break;
    case S_nonascii_text_dq:    result = "S_nonascii_text_dq";  break;
    case S_nonascii_text_sq:    result = "S_nonascii_text_sq";  break;
    case S_paren:               result = "S_paren";             break;
    case S_paren_dq:            result = "S_paren_dq";          break;
    case S_paren_sq:            result = "S_paren_sq";          break;
    case S_pcdata:              result = "S_pcdata";            break;
    case S_script:              result = "S_script";            break;
    case S_sgmlatt:             result = "S_sgmlatt";           break;
    case S_sgmlele:             result = "S_sgmlele";           break;
    case S_sgmlent:             result = "S_sgmlent";           break;
    case S_squoted:             result = "S_squoted";           break;
    case S_tag:                 result = "S_tag";               break;
    case S_tag_gap:             result = "S_tag_gap";           break;
    case S_tagname_slash:       result = "S_tagname_slash";     break;
    case S_text:                result = "S_text";              break;
    case S_value:               result = "S_value";             break;
    }
    /* *INDENT-ON* */

    return result;
}
#endif

/* storage for Element Stack */
#define DEPTH 10
static HTElement pool[DEPTH];
static int depth = 0;

static HTElement *pool_alloc(void)
{
    depth++;
    if (depth > DEPTH)
	return (HTElement *) malloc(sizeof(HTElement));
    return (pool + depth - 1);
}

static void pool_free(HTElement * e)
{
    if (depth > DEPTH)
	FREE(e);
    depth--;
    return;
}

#ifdef USE_PRETTYSRC

static void HTMLSRC_apply_markup(HTStream *context, HTlexeme lexeme, BOOL start)
{
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);

    while (ts) {
#ifdef USE_COLOR_STYLE
	if (ts->start) {
	    current_tag_style = ts->style;
	    force_current_tag_style = TRUE;
	    forced_classname = ts->class_name;
	    force_classname = TRUE;
	}
#endif
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
	if (ts->start)
	    (*context->actions->start_element) (context->target,
						ts->element,
						ts->present,
						(const char **) ts->value,
						context->current_tag_charset,
						&context->include);
	else
	    (*context->actions->end_element) (context->target,
					      ts->element,
					      &context->include);
	ts = ts->next;
    }
}

#define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_##x,START)
#define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_##x,STOP)

#define attr_is_href context->cur_attr_is_href
#define attr_is_name context->cur_attr_is_name
#endif

static void set_chartrans_handling(HTStream *context, HTParentAnchor *anchor,
				   int chndl)
{
    if (chndl < 0) {
	/*
	 * Nothing was set for the parser in earlier stages, so the HTML
	 * parser's UCLYhndl should still be its default.  - FM
	 */
	chndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_STRUCTURED);
	if (chndl < 0)
	    /*
	     * That wasn't set either, so seek the HText default.  - FM
	     */
	    chndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
	if (chndl < 0)
	    /*
	     * That wasn't set either, so assume the current display character
	     * set.  - FM
	     */
	    chndl = current_char_set;
	/*
	 * Try to set the HText and HTML stages' chartrans info with the
	 * default lock level (will not be changed if it was set previously
	 * with a higher lock level).  - FM
	 */
	HTAnchor_setUCInfoStage(anchor, chndl,
				UCT_STAGE_HTEXT,
				UCT_SETBY_DEFAULT);
	HTAnchor_setUCInfoStage(anchor, chndl,
				UCT_STAGE_STRUCTURED,
				UCT_SETBY_DEFAULT);
	/*
	 * Get the chartrans info for output to the HTML parser.  - FM
	 */
	context->outUCI = HTAnchor_getUCInfoStage(anchor,
						  UCT_STAGE_STRUCTURED);
	context->outUCLYhndl = HTAnchor_getUCLYhndl(context->node_anchor,
						    UCT_STAGE_STRUCTURED);
    }
    /*
     * Set the in->out transformation parameters.  - FM
     */
    UCSetTransParams(&context->T,
		     context->inUCLYhndl, context->inUCI,
		     context->outUCLYhndl, context->outUCI);
    /*
     * This is intended for passing the SGML parser's input charset as an
     * argument in each call to the HTML parser's start tag function, but it
     * would be better to call a Lynx_HTML_parser function to set an element in
     * its HTStructured object, itself, if this were needed.  - FM
     */
#ifndef EXP_JAPANESEUTF8_SUPPORT
    if (HTCJK != NOCJK) {
	context->current_tag_charset = -1;
    } else
#endif
    if (context->T.transp) {
	context->current_tag_charset = context->inUCLYhndl;
    } else if (context->T.decode_utf8) {
	context->current_tag_charset = context->inUCLYhndl;
    } else if (context->T.do_8bitraw ||
	       context->T.use_raw_char_in) {
	context->current_tag_charset = context->inUCLYhndl;
    } else if (context->T.output_utf8 ||
	       context->T.trans_from_uni) {
	context->current_tag_charset = UCGetLYhndl_byMIME("utf-8");
    } else {
	context->current_tag_charset = LATIN1;
    }
}

static void change_chartrans_handling(HTStream *context)
{
    int new_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor,
					  UCT_STAGE_PARSER);

    if (new_LYhndl != context->inUCLYhndl &&
	new_LYhndl >= 0) {
	/*
	 * Something changed.  but ignore if a META wants an unknown charset.
	 */
	LYUCcharset *new_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
						       UCT_STAGE_PARSER);

	if (new_UCI) {
	    LYUCcharset *next_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
							    UCT_STAGE_STRUCTURED);
	    int next_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor, UCT_STAGE_STRUCTURED);

	    context->inUCI = new_UCI;
	    context->inUCLYhndl = new_LYhndl;
	    context->outUCI = next_UCI;
	    context->outUCLYhndl = next_LYhndl;
	    set_chartrans_handling(context,
				   context->node_anchor, next_LYhndl);
	}
    }
}

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
static int current_is_class = 0;
#endif

/*	Handle Attribute
 *	----------------
 */
/* PUBLIC const char * SGML_default = "";   ?? */

static void handle_attribute_name(HTStream *context, const char *s)
{
    HTTag *tag = context->current_tag;
    attr *attributes = tag->attributes;
    int high, low, i, diff;

#ifdef USE_PRETTYSRC
    if (psrc_view) {
	attr_is_href = FALSE;
	attr_is_name = FALSE;
    }
#endif
    /*
     * Ignore unknown tag.  - KW
     */
    if (tag == context->unknown_tag) {
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    context->current_attribute_number = 1;	/* anything !=INVALID */
#endif
	return;
    }

    /*
     * Binary search for attribute name.
     */
    for (low = 0, high = tag->number_of_attributes;
	 high > low;
	 diff < 0 ? (low = i + 1) : (high = i)) {
	i = (low + (high - low) / 2);
	diff = my_casecomp(attributes[i].name, s);
	if (diff == 0) {	/* success: found it */
	    context->current_attribute_number = i;
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		attr_is_name = (BOOL) (attributes[i].type == HTMLA_ANAME);
		attr_is_href = (BOOL) (attributes[i].type == HTMLA_HREF);
	    } else
#endif
	    {
		context->present[i] = YES;
		Clear_extra(context->value[i]);
#ifdef USE_COLOR_STYLE
#   ifdef USE_PRETTYSRC
		current_is_class = IS_C(attributes[i]);
#   else
		current_is_class = (!strcasecomp("class", s));
#   endif
		CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
#endif
	    }
	    return;
	}
	/* if */
    }				/* for */

    CTRACE((tfp, "SGML: Unknown attribute %s for tag %s\n",
	    s, context->current_tag->name));
    context->current_attribute_number = INVALID;	/* Invalid */
}

/*	Handle attribute value
 *	----------------------
 */
static void handle_attribute_value(HTStream *context, const char *s)
{
    if (context->current_attribute_number != INVALID) {
	StrAllocCopy_extra(context->value[context->current_attribute_number], s);
#ifdef USE_COLOR_STYLE
	if (current_is_class) {
	    strncpy(class_string, s, TEMPSTRINGSIZE);
	    CTRACE((tfp, "SGML: class is '%s'\n", s));
	} else {
	    CTRACE((tfp, "SGML: attribute value is '%s'\n", s));
	}
#endif
    } else {
	CTRACE((tfp, "SGML: Attribute value %s ***ignored\n", s));
    }
    context->current_attribute_number = INVALID;	/* can't have two assignments! */
}

/*
 *  Translate some Unicodes to Lynx special codes and output them.
 *  Special codes - ones those output depend on parsing.
 *
 *  Additional issue, like handling bidirectional text if necessary
 *  may be called from here:  zwnj (8204), zwj (8205), lrm (8206), rlm (8207)
 *  - currently they are ignored in SGML.c and LYCharUtils.c
 *  but also in UCdomap.c because they are non printable...
 *
 */
static BOOL put_special_unicodes(HTStream *context, UCode_t code)
{
    /* (Tgf_nolyspcl) */
    if (context->no_lynx_specialcodes) {
	/*
	 * We were asked by a "DTD" flag to not generate lynx specials.  - kw
	 */
	return NO;
    }

    if (code == CH_NBSP) {	/* S/390 -- gil -- 0657 */
	/*
	 * Use Lynx special character for nbsp.
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view)
#endif
	    PUTC(HT_NON_BREAK_SPACE);
    } else if (code == CH_SHY) {
	/*
	 * Use Lynx special character for shy.
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view)
#endif
	    PUTC(LY_SOFT_HYPHEN);
    } else if (code == 8194 || code == 8201) {
	/*
	 * Use Lynx special character for ensp or thinsp.
	 *
	 * Originally, Lynx use space '32' as word delimiter and omits this
	 * space at end of line if word is wrapped to the next line.  There are
	 * several other spaces in the Unicode repertoire and we should teach
	 * Lynx to understand them, not only as regular characters but in the
	 * context of line wrapping.  Unfortunately, if we use HT_EN_SPACE we
	 * override the chartrans tables for those spaces with a single '32'
	 * for all (but do line wrapping more fancy).
	 *
	 * We may treat emsp as one or two ensp (below).
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view)
#endif
	    PUTC(HT_EN_SPACE);
    } else if (code == 8195) {
	/*
	 * Use Lynx special character for emsp.
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view) {
#endif
	    /* PUTC(HT_EN_SPACE);  let's stay with a single space :) */
	    PUTC(HT_EN_SPACE);
#ifdef USE_PRETTYSRC
	}
#endif
    } else {
	/*
	 * Return NO if nothing done.
	 */
	return NO;
    }
    /*
     * We have handled it.
     */
    return YES;
}

#ifdef USE_PRETTYSRC
static void put_pretty_entity(HTStream *context, int term)
{
    PSRCSTART(entity);
    PUTC('&');
    PUTS(entity_string);
    if (term)
	PUTC((char) term);
    PSRCSTOP(entity);
}

static void put_pretty_number(HTStream *context)
{
    PSRCSTART(entity);
    PUTS((context->isHex ? "&#x" : "&#"));
    PUTS(entity_string);
    PUTC(';');
    PSRCSTOP(entity);
}
#endif /* USE_PRETTYSRC */

/*	Handle entity
 *	-------------
 *
 * On entry,
 *	s	contains the entity name zero terminated
 * Bugs:
 *	If the entity name is unknown, the terminator is treated as
 *	a printable non-special character in all cases, even if it is '<'
 * Bug-fix:
 *	Modified SGML_character() so we only come here with terminator
 *	as '\0' and check a FoundEntity flag. -- Foteos Macrides
 *
 * Modified more (for use with Lynx character translation code):
 */
static char replace_buf[64];	/* buffer for replacement strings */
static BOOL FoundEntity = FALSE;

static void handle_entity(HTStream *context, char term)
{
    UCode_t code;
    long uck = -1;
    const char *s = context->string->data;

    /*
     * Handle all entities normally.  - FM
     */
    FoundEntity = FALSE;
    if ((code = HTMLGetEntityUCValue(s)) != 0) {
	/*
	 * We got a Unicode value for the entity name.  Check for special
	 * Unicodes.  - FM
	 */
	if (put_special_unicodes(context, code)) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }
#endif
	    FoundEntity = TRUE;
	    return;
	}
	/*
	 * Seek a translation from the chartrans tables.
	 */
	if ((uck = UCTransUniChar(code, context->outUCLYhndl)) >= 32 &&
/* =============== work in ASCII below here ===============  S/390 -- gil -- 0672 */
	    uck < 256 &&
	    (uck < 127 ||
	     uck >= LYlowest_eightbit[context->outUCLYhndl])) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    } else
#endif
		PUTC(FROMASCII((char) uck));
	    FoundEntity = TRUE;
	    return;
	} else if ((uck == -4 ||
		    (context->T.repl_translated_C0 &&
		     uck > 0 && uck < 32)) &&
	    /*
	     * Not found; look for replacement string.
	     */
		   (uck = UCTransUniCharStr(replace_buf, 60, code,
					    context->outUCLYhndl, 0) >= 0)) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    } else
#endif
		PUTS(replace_buf);
	    FoundEntity = TRUE;
	    return;
	}
	/*
	 * If we're displaying UTF-8, try that now.  - FM
	 */
#ifndef USE_PRETTYSRC
	if (context->T.output_utf8 && PUTUTF8(code)) {
	    FoundEntity = TRUE;
	    return;
	}
#else
	if (context->T.output_utf8 && (psrc_view
				       ? (UCPutUtf8_charstring((HTStream *) context->target,
							       (putc_func_t *) (fake_put_character),
							       code))
				       : PUTUTF8(code))) {

	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }

	    FoundEntity = TRUE;
	    return;
	}
#endif
	/*
	 * If it's safe ASCII, use it.  - FM
	 */
	if (code >= 32 && code < 127) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    } else
#endif

		PUTC(FROMASCII((char) code));
	    FoundEntity = TRUE;
	    return;
	}
/* =============== work in ASCII above here ===============  S/390 -- gil -- 0682 */
	/*
	 * Ignore zwnj (8204) and zwj (8205), if we get to here.  Note that
	 * zwnj may have been handled as <WBR> by the calling function.  - FM
	 */
	if (!strcmp(s, "zwnj") ||
	    !strcmp(s, "zwj")) {
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }
#endif
	    FoundEntity = TRUE;
	    return;
	}
	/*
	 * Ignore lrm (8206), and rln (8207), if we get to here.  - FM
	 */
	if (!strcmp(s, "lrm") ||
	    !strcmp(s, "rlm")) {
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }
#endif
	    FoundEntity = TRUE;
	    return;
	}
    }

    /*
     * If entity string not found, display as text.
     */
#ifdef USE_PRETTYSRC
    if (psrc_view)
	PSRCSTART(badseq);
#endif
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long) code, uck));	/* S/390 -- gil -- 0695 */
    PUTC('&');
    PUTS(s);
    if (term != '\0')
	PUTC(term);
#ifdef USE_PRETTYSRC
    if (psrc_view)
	PSRCSTOP(badseq);
#endif
}

/*	Handle comment
 *	--------------
 */
static void handle_comment(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Comment:\n<%s>\n", s));

    if (context->csi == NULL &&
	strncmp(s, "!--#", 4) == 0 &&
	LYCheckForCSI(context->node_anchor, &context->url) == TRUE) {
	LYDoCSI(context->url, s, &context->csi);
    } else {
	LYCommentHacks(context->node_anchor, context->string->data);
    }

    return;
}

/*	Handle identifier
 *	-----------------
 */
static void handle_identifier(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Identifier:\n<%s>\n", s));

    return;
}

/*	Handle doctype
 *	--------------
 */
static void handle_doctype(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Doctype:\n<%s>\n", s));

    return;
}

static void SGML_write(HTStream *me, const char *s,
		       int l);

/*	Handle marked
 *	-------------
 */
static void handle_marked(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Marked Section:\n<%s>\n", s));

    if (!strncmp(context->string->data, "![INCLUDE[", 10)) {
	context->string->data[context->string->size - 3] = '\0';
	StrAllocCat(context->include, context->string->data + 10);
	/* @@@@@@ This needs to take charset into account! @@@@@@
	   the wrong assumptions will be made about the data's
	   charset once it is in include - kw */

    } else if (!strncmp(context->string->data, "![CDATA[", 8)) {
	(*context->actions->_write) (context->target,
				     context->string->data + 8,
				     context->string->size - 11);

    }
    return;
}

/*	Handle sgmlent
 *	--------------
 */
static void handle_sgmlent(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Entity Declaration:\n<%s>\n", s));

    return;
}

/*	Handle sgmlent
 *	--------------
 */
static void handle_sgmlele(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Element Declaration:\n<%s>\n", s));

    return;
}

/*	Handle sgmlatt
 *	--------------
 */
static void handle_sgmlatt(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Attribute Declaration:\n<%s>\n", s));

    return;
}

/*
 * Convenience macros - tags (elements) are identified sometimes by an int or
 * enum value ('TAGNUM'), sometimes by a pointer to HTTag ('TAGP').  - kw
 */
#define TAGNUM_OF_TAGP(t) (HTMLElement) (t - context->dtd->tags)
#define TAGP_OF_TAGNUM(e) (context->dtd->tags + e)

/*
 * The following implement special knowledge about OBJECT.  As long as
 * HTML_OBJECT is the only tag for which an alternative variant exist, they can
 * be simple macros.  - kw
 */
/* does 'TAGNUM' e have an alternative (variant) parsing mode? */
#define HAS_ALT_TAGNUM(e) (e == HTML_OBJECT)

/* return 'TAGNUM' of the alternative mode for 'TAGNUM' e, if any. */
#define ALT_TAGNUM(e) ((e == HTML_OBJECT) ? HTML_ALT_OBJECT : e)

/* return 'TAGNUM' of the normal mode for 'TAGNUM' e which may be alt. */
#define NORMAL_TAGNUM(e) (((int)(e) >= HTML_ELEMENTS) ? HTML_OBJECT : (HTMLElement)e)

/* More convenience stuff. - kw */
#define ALT_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(ALT_TAGNUM(e))
#define NORMAL_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(NORMAL_TAGNUM(e))

#define ALT_TAGP(t) ALT_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))
#define NORMAL_TAGP(t) NORMAL_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))

#ifdef EXTENDED_HTMLDTD

static BOOL element_valid_within(HTTag * new_tag, HTTag * stacked_tag, BOOL direct)
{
    TagClass usecontains, usecontained;

    if (!stacked_tag || !new_tag)
	return YES;
    usecontains = (direct ? stacked_tag->contains : stacked_tag->icontains);
    usecontained = (direct ? new_tag->contained : new_tag->icontained);
    if (new_tag == stacked_tag)
	return (BOOL) ((Tgc_same & usecontains) &&
		       (Tgc_same & usecontained));
    else
	return (BOOL) ((new_tag->tagclass & usecontains) &&
		       (stacked_tag->tagclass & usecontained));
}

typedef enum {
    close_NO = 0,
    close_error = 1,
    close_valid = 2
} canclose_t;

static canclose_t can_close(HTTag * new_tag, HTTag * stacked_tag)
{
    if (!stacked_tag)
	return close_NO;
    if (stacked_tag->flags & Tgf_endO)
	return close_valid;
    else if (new_tag == stacked_tag)
	return ((Tgc_same & new_tag->canclose) ? close_error : close_NO);
    else
	return ((stacked_tag->tagclass & new_tag->canclose) ?
		close_error : close_NO);
}

static void do_close_stacked(HTStream *context)
{
    HTElement *stacked = context->element_stack;
    HTMLElement e;

    if (!stacked)
	return;			/* stack was empty */
    if (context->inSELECT && !strcasecomp(stacked->tag->name, "SELECT")) {
	context->inSELECT = FALSE;
    }
    e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(stacked->tag));
#ifdef USE_PRETTYSRC
    if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
#endif
	(*context->actions->end_element) (context->target,
					  e,
					  &context->include);
    context->element_stack = stacked->next;
    pool_free(stacked);
    context->no_lynx_specialcodes = context->element_stack ?
	(context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
}

static int is_on_stack(HTStream *context, HTTag * old_tag)
{
    HTElement *stacked = context->element_stack;
    int i = 1;

    for (; stacked; stacked = stacked->next, i++) {
	if (stacked->tag == old_tag ||
	    stacked->tag == ALT_TAGP(old_tag))
	    return i;
    }
    return 0;
}
#endif /* EXTENDED_HTMLDTD */

/*	End element
 *	-----------
 */
static void end_element(HTStream *context, HTTag * old_tag)
{
#ifdef EXTENDED_HTMLDTD

    BOOL extra_action_taken = NO;
    canclose_t canclose_check = close_valid;
    int stackpos = is_on_stack(context, old_tag);

    if (!Old_DTD) {
	while (canclose_check != close_NO &&
	       context->element_stack &&
	       (stackpos > 1 || (!extra_action_taken && stackpos == 0))) {
	    if (stackpos == 0 && (old_tag->flags & Tgf_startO) &&
		element_valid_within(old_tag, context->element_stack->tag, YES)) {
		CTRACE((tfp, "SGML: </%s> ignored\n", old_tag->name));
		return;
	    }
	    canclose_check = can_close(old_tag, context->element_stack->tag);
	    if (canclose_check != close_NO) {
		CTRACE((tfp, "SGML: End </%s> \t<- %s end </%s>\n",
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			old_tag->name));
		do_close_stacked(context);
		extra_action_taken = YES;
		stackpos = is_on_stack(context, old_tag);
	    }
	}

	if (stackpos == 0 && old_tag->contents != SGML_EMPTY) {
	    CTRACE((tfp, "SGML: Still open %s, ***no open %s for </%s>\n",
		    context->element_stack ?
		    context->element_stack->tag->name : "none",
		    old_tag->name,
		    old_tag->name));
	    return;
	}
	if (stackpos > 1) {
	    CTRACE((tfp,
		    "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
		    old_tag->name,
		    context->element_stack->tag->name,
		    old_tag->name));
	    return;
	}
    }
    /* Now let the non-extended code deal with the rest. - kw */

#endif /* EXTENDED_HTMLDTD */

    /*
     * If we are in a SELECT block, ignore anything but a SELECT end tag.  - FM
     */
    if (context->inSELECT) {
	if (!strcasecomp(old_tag->name, "SELECT")) {
	    /*
	     * Turn off the inSELECT flag and fall through.  - FM
	     */
	    context->inSELECT = FALSE;
	} else {
	    /*
	     * Ignore the end tag.  - FM
	     */
	    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
		    old_tag->name));
	    return;
	}
    }
    /*
     * Handle the end tag.  - FM
     */
    CTRACE((tfp, "SGML: End </%s>\n", old_tag->name));
    if (old_tag->contents == SGML_EMPTY) {
	CTRACE((tfp, "SGML: ***Illegal end tag </%s> found.\n",
		old_tag->name));
	return;
    }
#ifdef WIND_DOWN_STACK
    while (context->element_stack)	/* Loop is error path only */
#else
    if (context->element_stack)	/* Substitute and remove one stack element */
#endif /* WIND_DOWN_STACK */
    {
	int status = HT_OK;
	HTMLElement e;
	HTElement *N = context->element_stack;
	HTTag *t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;

	if (old_tag != t) {	/* Mismatch: syntax error */
	    if (context->element_stack->next) {		/* This is not the last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			old_tag->name, t->name, t->name));
	    } else {		/* last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			old_tag->name, t->name, old_tag->name));
		return;		/* Ignore */
	    }
	}

	e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(t));
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", t, (int) e));
#ifdef USE_PRETTYSRC
	if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
#endif
	    status = (*context->actions->end_element) (context->target,
						       e, &context->include);
	if (status == HT_PARSER_REOPEN_ELT) {
	    CTRACE((tfp, "SGML: Restart <%s>\n", t->name));
	    (*context->actions->start_element) (context->target,
						e,
						NULL,
						NULL,
						context->current_tag_charset,
						&context->include);
	} else if (status == HT_PARSER_OTHER_CONTENT) {
	    CTRACE((tfp, "SGML: Continue with other content model for <%s>\n", t->name));
	    context->element_stack->tag = ALT_TAGP_OF_TAGNUM(e);
	} else {
	    context->element_stack = N->next;	/* Remove from stack */
	    pool_free(N);
	}
	context->no_lynx_specialcodes = context->element_stack ?
	    (context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
#ifdef WIND_DOWN_STACK
	if (old_tag == t)
	    return;		/* Correct sequence */
#else
	return;
#endif /* WIND_DOWN_STACK */

	/* Syntax error path only */

    }
    CTRACE((tfp, "SGML: Extra end tag </%s> found and ignored.\n",
	    old_tag->name));
}

/*	Start a element
*/
static void start_element(HTStream *context)
{
    int status;
    HTTag *new_tag = context->current_tag;
    HTMLElement e = TAGNUM_OF_TAGP(new_tag);
    BOOL ok = FALSE;

#ifdef EXTENDED_HTMLDTD

    BOOL valid = YES;
    BOOL direct_container = YES;
    BOOL extra_action_taken = NO;
    canclose_t canclose_check = close_valid;

    if (!Old_DTD) {
	while (context->element_stack &&
	       (canclose_check == close_valid ||
		(canclose_check == close_error &&
		 new_tag == context->element_stack->tag)) &&
	       !(valid = element_valid_within(new_tag, context->element_stack->tag,
					      direct_container))) {
	    canclose_check = can_close(new_tag, context->element_stack->tag);
	    if (canclose_check != close_NO) {
		CTRACE((tfp, "SGML: End </%s> \t<- %s start <%s>\n",
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			new_tag->name));
		do_close_stacked(context);
		extra_action_taken = YES;
		if (canclose_check == close_error)
		    direct_container = NO;
	    } else {
		CTRACE((tfp,
			"SGML: Still open %s \t<- ***invalid start <%s>\n",
			context->element_stack->tag->name,
			new_tag->name));
	    }
	}
	if (context->element_stack && !valid &&
	    (context->element_stack->tag->flags & Tgf_strict) &&
	    !(valid = element_valid_within(new_tag, context->element_stack->tag,
					   direct_container))) {
	    CTRACE((tfp, "SGML: Still open %s \t<- ***ignoring start <%s>\n",
		    context->element_stack->tag->name,
		    new_tag->name));
	    return;
	}

	if (context->element_stack &&
	    !extra_action_taken &&
	    (canclose_check == close_NO) &&
	    !valid && (new_tag->flags & Tgf_mafse)) {
	    BOOL has_attributes = NO;
	    int i = 0;

	    for (; i < new_tag->number_of_attributes && !has_attributes; i++)
		has_attributes = context->present[i];
	    if (!has_attributes) {
		CTRACE((tfp,
			"SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
			context->element_stack->tag->name,
			new_tag->name,
			new_tag->name));
		end_element(context, new_tag);
		return;
	    }
	}

	if (context->element_stack &&
	    (canclose_check == close_error) &&
	    !(valid = element_valid_within(new_tag,
					   context->element_stack->tag,
					   direct_container))) {
	    CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
		    context->element_stack->tag->name,
		    new_tag->name));
	}
    }
    /* Fall through to the non-extended code - kw */

#endif /* EXTENDED_HTMLDTD */

    /*
     * If we are not in a SELECT block, check if this is a SELECT start tag. 
     * Otherwise (i.e., we are in a SELECT block) accept only OPTION as valid,
     * terminate the SELECT block if it is any other form-related element, and
     * otherwise ignore it.  - FM
     */
    if (!context->inSELECT) {
	/*
	 * We are not in a SELECT block, so check if this starts one.  - FM
	 * (frequent case!)
	 */
	/* my_casecomp() - optimized by the first character */
	if (!my_casecomp(new_tag->name, "SELECT")) {
	    /*
	     * Set the inSELECT flag and fall through.  - FM
	     */
	    context->inSELECT = TRUE;
	}
    } else {
	/*
	 * We are in a SELECT block.  - FM
	 */
	if (strcasecomp(new_tag->name, "OPTION")) {
	    /*
	     * Ugh, it is not an OPTION.  - FM
	     */
	    switch (e) {
	    case HTML_INPUT:
	    case HTML_TEXTAREA:
	    case HTML_SELECT:
	    case HTML_BUTTON:
	    case HTML_FIELDSET:
	    case HTML_LABEL:
	    case HTML_LEGEND:
	    case HTML_FORM:
		ok = TRUE;
		break;
	    default:
		break;
	    }
	    if (ok) {
		/*
		 * It is another form-related start tag, so terminate the
		 * current SELECT block and fall through.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			new_tag->name));
		end_element(context, SGMLFindTag(context->dtd, "SELECT"));
	    } else {
		/*
		 * Ignore the start tag.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			new_tag->name));
		return;
	    }
	}
    }
    /*
     * Handle the start tag.  - FM
     */
    CTRACE((tfp, "SGML: Start <%s>\n", new_tag->name));
    status = (*context->actions->start_element) (context->target,
						 TAGNUM_OF_TAGP(new_tag),
						 context->present,
						 (const char **) context->value,	/* coerce type for think c */
						 context->current_tag_charset,
						 &context->include);
    if (status == HT_PARSER_OTHER_CONTENT)
	new_tag = ALT_TAGP(new_tag);	/* this is only returned for OBJECT */
    if (new_tag->contents != SGML_EMPTY) {	/* i.e., tag not empty */
	HTElement *N = pool_alloc();

	if (N == NULL)
	    outofmem(__FILE__, "start_element");
	N->next = context->element_stack;
	N->tag = new_tag;
	context->element_stack = N;
	context->no_lynx_specialcodes = (new_tag->flags & Tgf_nolyspcl);

    } else if (e == HTML_META) {
	/*
	 * Check for result of META tag.  - KW & FM
	 */
	change_chartrans_handling(context);
    }
}

/*		Find Tag in DTD tag list
 *		------------------------
 *
 * On entry,
 *	dtd	points to dtd structure including valid tag list
 *	string	points to name of tag in question
 *
 * On exit,
 *	returns:
 *		NULL		tag not found
 *		else		address of tag structure in dtd
 */
HTTag *SGMLFindTag(const SGML_dtd * dtd,
		   const char *s)
{
    int high, low, i, diff;
    static HTTag *last[64] =
    {NULL};			/*optimize using the previous results */
    HTTag **res = last + (UCH(*s) % 64);	/*pointer arithmetic */

    if (*res && !strcasecomp((*res)->name, s))
	return *res;

    for (low = 0, high = dtd->number_of_tags;
	 high > low;
	 diff < 0 ? (low = i + 1) : (high = i)) {	/* Binary search */
	i = (low + (high - low) / 2);
	/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
	diff = my_casecomp(dtd->tags[i].name, s);	/* Case insensitive */
	if (diff == 0) {	/* success: found it */
	    *res = &dtd->tags[i];
	    return *res;
	}
    }
    if (IsNmStart(*s)) {
	/*
	 * Unrecognized, but may be valid.  - KW
	 */
	return &HTTag_unrecognized;
    }
    return NULL;
}

/*________________________________________________________________________
 *			Public Methods
 */

/*	Could check that we are back to bottom of stack! @@@@  */
/*	Do check! - FM					     */
/*							     */
static void SGML_free(HTStream *context)
{
    int i;
    HTElement *cur;
    HTTag *t;

    /*
     * Free the buffers.  - FM
     */
    FREE(context->recover);
    FREE(context->url);
    FREE(context->csi);
    FREE(context->include);
    FREE(context->active_include);

    /*
     * Wind down stack if any elements are open.  - FM
     */
    while (context->element_stack) {
	cur = context->element_stack;
	t = cur->tag;
	context->element_stack = cur->next;	/* Remove from stack */
	pool_free(cur);
#ifdef USE_PRETTYSRC
	if (!psrc_view)		/* Don't actually call on target if viewing psrc - kw */
#endif
	    (*context->actions->end_element) (context->target,
					      NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
					      &context->include);
	FREE(context->include);
    }

    /*
     * Finish off the target.  - FM
     */
    (*context->actions->_free) (context->target);

    /*
     * Free the strings and context structure.  - FM
     */
    HTChunkFree(context->string);
    for (i = 0; i < MAX_ATTRIBUTES; i++)
	FREE_extra(context->value[i]);
    FREE(context);

#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
#endif
}

static void SGML_abort(HTStream *context, HTError e)
{
    int i;
    HTElement *cur;

    /*
     * Abort the target.  - FM
     */
    (*context->actions->_abort) (context->target, e);

    /*
     * Free the buffers.  - FM
     */
    FREE(context->recover);
    FREE(context->include);
    FREE(context->active_include);
    FREE(context->url);
    FREE(context->csi);

    /*
     * Free stack memory if any elements were left open.  - KW
     */
    while (context->element_stack) {
	cur = context->element_stack;
	context->element_stack = cur->next;	/* Remove from stack */
	pool_free(cur);
    }

    /*
     * Free the strings and context structure.  - FM
     */
    HTChunkFree(context->string);
    for (i = 0; i < MAX_ATTRIBUTES; i++)
	FREE_extra(context->value[i]);
    FREE(context);

#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
#endif
}

/*	Read and write user callback handle
 *	-----------------------------------
 *
 *   The callbacks from the SGML parser have an SGML context parameter.
 *   These calls allow the caller to associate his own context with a
 *   particular SGML context.
 */

#ifdef CALLERDATA
void *SGML_callerData(HTStream *context)
{
    return context->callerData;
}

void SGML_setCallerData(HTStream *context, void *data)
{
    context->callerData = data;
}
#endif /* CALLERDATA */

static void SGML_character(HTStream *context, char c_in)
{
    const SGML_dtd *dtd = context->dtd;
    HTChunk *string = context->string;
    const char *EntityName;
    HTTag *testtag = NULL;
    BOOLEAN chk;		/* Helps (?) walk through all the else ifs... */
    UCode_t clong, uck = 0;	/* Enough bits for UCS4 ... */
    int testlast;

#ifdef CJK_EX
    unsigned char c;

#else
    char c;
#endif
    char saved_char_in = '\0';

    /*
     * Now some fun with the preprocessor.  Use copies for c and unsign_c ==
     * clong, so that we can revert back to the unchanged c_in.  - KW
     */
#define unsign_c clong

    c = c_in;
    clong = UCH(c);		/* a.k.a. unsign_c */

    if (context->T.decode_utf8) {
	/*
	 * Combine UTF-8 into Unicode.  Incomplete characters silently ignored. 
	 * From Linux kernel's console.c.  - KW
	 */
	if (TOASCII(UCH(c)) > 127) {	/* S/390 -- gil -- 0710 */
	    /*
	     * We have an octet from a multibyte character.  - FM
	     */
	    if (context->utf_count > 0 && (TOASCII(c) & 0xc0) == 0x80) {
		context->utf_char = (context->utf_char << 6) | (TOASCII(c) & 0x3f);
		context->utf_count--;
		*(context->utf_buf_p) = c;
		(context->utf_buf_p)++;
		if (context->utf_count == 0) {
		    /*
		     * We have all of the bytes, so terminate the buffer and
		     * set 'clong' to the UCode_t value.  - FM
		     */
		    *(context->utf_buf_p) = '\0';
		    clong = context->utf_char;
		    if (clong < 256) {
			c = ((char) (clong & 0xff));
		    }
		    goto top1;
		} else {
		    /*
		     * Wait for more.  - KW
		     */
		    return;
		}
	    } else {
		/*
		 * Start handling a new multibyte character.  - FM
		 */
		context->utf_buf_p = context->utf_buf;
		*(context->utf_buf_p) = c;
		(context->utf_buf_p)++;
		if ((c & 0xe0) == 0xc0) {
		    context->utf_count = 1;
		    context->utf_char = (c & 0x1f);
		} else if ((c & 0xf0) == 0xe0) {
		    context->utf_count = 2;
		    context->utf_char = (c & 0x0f);
		} else if ((c & 0xf8) == 0xf0) {
		    context->utf_count = 3;
		    context->utf_char = (c & 0x07);
		} else if ((c & 0xfc) == 0xf8) {
		    context->utf_count = 4;
		    context->utf_char = (c & 0x03);
		} else if ((c & 0xfe) == 0xfc) {
		    context->utf_count = 5;
		    context->utf_char = (c & 0x01);
		} else {
		    /*
		     * Garbage.  - KW
		     */
		    context->utf_count = 0;
		    context->utf_buf_p = context->utf_buf;
		    *(context->utf_buf_p) = '\0';
		}
		/*
		 * Wait for more.  - KW
		 */
		return;
	    }
	} else {
	    /*
	     * Got an ASCII char.  - KW
	     */
	    context->utf_count = 0;
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	    /*  goto top;  */
	}
    }
    /* end of context->T.decode_utf8      S/390 -- gil -- 0726 */
#ifdef NOTDEFINED
    /*
     * If we have a koi8-r input and do not have koi8-r as the output, save the
     * raw input in saved_char_in before we potentially convert it to Unicode. 
     * - FM
     */
    if (context->T.strip_raw_char_in)
	saved_char_in = c;
#endif /* NOTDEFINED */

    /*
     * If we want the raw input converted to Unicode, try that now.  - FM
     */
    if (context->T.trans_to_uni &&
	((TOASCII(unsign_c) >= LYlowest_eightbit[context->inUCLYhndl]) ||	/* S/390 -- gil -- 0744 */
	 (unsign_c < ' ' && unsign_c != 0 &&
	  context->T.trans_C0_to_uni))) {
	/*
	 * Convert the octet to Unicode.  - FM
	 */
	clong = UCTransToUni(c, context->inUCLYhndl);
	if (clong > 0) {
	    saved_char_in = c;
	    if (clong < 256) {
		c = FROMASCII((char) clong);
	    }
	}
	goto top1;
    } else if (unsign_c < ' ' && unsign_c != 0 &&	/* S/390 -- gil -- 0768 */
	       context->T.trans_C0_to_uni) {
	/*
	 * This else if may be too ugly to keep.  - KW
	 */
	if (context->T.trans_from_uni &&
	    (((clong = UCTransToUni(c, context->inUCLYhndl)) >= ' ') ||
	     (context->T.transp &&
	      (clong = UCTransToUni(c, context->inUCLYhndl)) > 0))) {
	    saved_char_in = c;
	    if (clong < 256) {
		c = FROMASCII((char) clong);
	    }
	    goto top1;
	} else {
	    uck = -1;
	    if (context->T.transp) {
		uck = UCTransCharStr(replace_buf, 60, c,
				     context->inUCLYhndl,
				     context->inUCLYhndl, NO);
	    }
	    if (!context->T.transp || uck < 0) {
		uck = UCTransCharStr(replace_buf, 60, c,
				     context->inUCLYhndl,
				     context->outUCLYhndl, YES);
	    }
	    if (uck == 0) {
		return;
	    } else if (uck < 0) {
		goto top0a;
	    }
	    c = replace_buf[0];
	    if (c && replace_buf[1]) {
		if (context->state == S_text) {
		    PUTS(replace_buf);
		    return;
		}
		StrAllocCat(context->recover, replace_buf + 1);
	    }
	    goto top0a;
	}			/*  Next line end of ugly stuff for C0. - KW */
    } else {			/* end of context->T.trans_to_uni  S/390 -- gil -- 0791 */
	goto top0a;
    }

    /*
     * At this point we have either unsign_c a.k.a.  clong in Unicode (and c in
     * latin1 if clong is in the latin1 range), or unsign_c and c will have to
     * be passed raw.  - KW
     */
/*
 *  We jump up to here from below if we have
 *  stuff in the recover, insert, or csi buffers
 *  to process.	 We zero saved_char_in, in effect
 *  as a flag that the octet in not that of the
 *  actual call to this function.  This may be OK
 *  for now, for the stuff this function adds to
 *  its recover buffer, but it might not be for
 *  stuff other functions added to the insert or
 *  csi buffer, so bear that in mind. - FM
 *  Stuff from the recover buffer is now handled
 *  as UTF-8 if we can expect that's what it is,
 *  and in that case we don't come back up here. - kw
 */
  top:
    saved_char_in = '\0';
/*
 *  We jump to here from above when we don't have
 *  UTF-8 input, haven't converted to Unicode, and
 *  want clong set to the input octet (unsigned)
 *  without zeroing its saved_char_in copy (which
 *  is signed). - FM
 */
  top0a:
    *(context->utf_buf) = '\0';
    clong = UCH(c);
/*
 *  We jump to here from above if we have converted
 *  the input, or a multibyte sequence across calls,
 *  to a Unicode value and loaded it into clong (to
 *  which unsign_c has been defined), and from below
 *  when we are recycling a character (e.g., because
 *  it terminated an entity but is not the standard
 *  semi-colon).  The character will already have
 *  been put through the Unicode conversions. - FM
 */
  top1:
    /*
     * Ignore low ISO 646 7-bit control characters if HTCJK is not set.  - FM
     */
    /*
     * Works for both ASCII and EBCDIC. -- gil
 *//* S/390 -- gil -- 0811 */
    if (TOASCII(unsign_c) < 32 &&
	c != '\t' && c != '\n' && c != '\r' &&
	HTCJK == NOCJK)
	goto after_switch;

    /*
     * Ignore 127 if we don't have HTPassHighCtrlRaw or HTCJK set.  - FM
     */
#define PASSHICTRL (context->T.transp || \
		    unsign_c >= LYlowest_eightbit[context->inUCLYhndl])
    if (TOASCII(c) == 127 &&	/* S/390 -- gil -- 0830 */
	!(PASSHICTRL || HTCJK != NOCJK))
	goto after_switch;

    /*
     * Ignore 8-bit control characters 128 - 159 if neither HTPassHighCtrlRaw
     * nor HTCJK is set.  - FM
     */
    if (TOASCII(unsign_c) > 127 && TOASCII(unsign_c) < 160 &&	/* S/390 -- gil -- 0847 */
	!(PASSHICTRL || HTCJK != NOCJK))
	goto after_switch;

    /* Almost all CJK characters are double byte but only Japanese
     * JIS X0201 Kana is single byte. To prevent to fail SGML parsing
     * we have to care them here. -- TH
     */
    if ((HTCJK == JAPANESE) && (context->state == S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& !context->T.decode_utf8
#endif
	) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
	if (IS_SJIS_X0201KANA(context->kanji_buf)) {
	    unsigned char sjis_hi, sjis_lo;

	    JISx0201TO0208_SJIS(context->kanji_buf, &sjis_hi, &sjis_lo);
	    PUTC(sjis_hi);
	    PUTC(sjis_lo);
	} else
#endif
	    PUTC(context->kanji_buf);
	context->state = S_text;
    }

    /*
     * Handle character based on context->state.
     */
    CTRACE2(TRACE_SGML, (tfp, "SGML before %s|%.*s|%c|\n",
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));
    switch (context->state) {

    case S_in_kanji:
	/*
	 * Note that if we don't have a CJK input, then this is not the second
	 * byte of a CJK di-byte, and we're trashing the input.  That's why
	 * 8-bit characters followed by, for example, '<' can cause the tag to
	 * be treated as text, not markup.  We could try to deal with it by
	 * holding each first byte and then checking byte pairs, but that
	 * doesn't seem worth the overhead (see below).  - FM
	 */
	context->state = S_text;
	PUTC(context->kanji_buf);
	PUTC(c);
	break;

    case S_tagname_slash:
	/*
	 * We had something link "<name/" so far, set state to S_text but keep
	 * context->slashedtag as as a flag; except if we get '>' directly
	 * after the "<name/", and really have a tag for that name in
	 * context->slashedtag, in which case keep state as is and let code
	 * below deal with it.  - kw
	 */
	if (!(c == '>' && context->slashedtag && TOASCII(unsign_c) < 127)) {
	    context->state = S_text;
	}
	/* fall through in any case! */
    case S_text:
	if ((HTCJK != NOCJK) && ((TOASCII(c) & 0200) != 0)
#ifdef EXP_JAPANESEUTF8_SUPPORT
	    && !context->T.decode_utf8
#endif
	    ) {			/* S/390 -- gil -- 0864 */
	    /*
	     * Setting up for Kanji multibyte handling (based on Takuya ASADA's
	     * (asada@@three-a.co.jp) CJK Lynx).  Note that if the input is not
	     * in fact CJK, the next byte also will be mishandled, as explained
	     * above.  Toggle raw mode off in such cases, or select the "7 bit
	     * approximations" display character set, which is largely
	     * equivalent to having raw mode off with CJK.  - FM
	     */
	    context->state = S_in_kanji;
	    context->kanji_buf = c;
	    break;
	} else if (HTCJK != NOCJK && TOASCII(c) == '\033') {	/* S/390 -- gil -- 0881 */
	    /*
	     * Setting up for CJK escape sequence handling (based on Takuya
	     * ASADA's (asada@@three-a.co.jp) CJK Lynx).  - FM
	     */
	    context->state = S_esc;
	    PUTC(c);
	    break;
	}

	if (c == '&' || c == '<') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {	/*there is nothing useful in the element_stack */
		testtag = context->current_tag;
	    } else
#endif
	    {
		testtag = context->element_stack ?
		    context->element_stack->tag : NULL;
	    }
	}

	if (c == '&' && TOASCII(unsign_c) < 127 &&	/* S/390 -- gil -- 0898 */
	    (!testtag ||
	     (testtag->contents == SGML_MIXED ||
	      testtag->contents == SGML_ELEMENT ||
	      testtag->contents == SGML_PCDATA ||
#ifdef USE_PRETTYSRC
	      testtag->contents == SGML_EMPTY ||
#endif
	      testtag->contents == SGML_RCDATA))) {
	    /*
	     * Setting up for possible entity, without the leading '&'.  - FM
	     */
	    string->size = 0;
	    context->state = S_ero;
	} else if (c == '<' && TOASCII(unsign_c) < 127) {	/* S/390 -- gil -- 0915 */
	    /*
	     * Setting up for possible tag.  - FM
	     */
	    string->size = 0;
	    if (testtag && testtag->contents == SGML_PCDATA) {
		context->state = S_pcdata;
	    } else if (testtag && (testtag->contents == SGML_LITTERAL
				   || testtag->contents == SGML_CDATA)) {
		context->state = S_litteral;
	    } else if (testtag && (testtag->contents == SGML_SCRIPT)) {
		context->state = S_script;
	    } else {
		context->state = S_tag;
	    }
	    context->slashedtag = NULL;
	} else if (context->slashedtag &&
		   (c == '/' ||
		    (c == '>' && context->state == S_tagname_slash)) &&
		   TOASCII(unsign_c) < 127) {
	    /*
	     * We got either the second slash of a pending "<NAME/blah blah/"
	     * shortref construct, or the '>' of a mere "<NAME/>".  In both
	     * cases generate a "</NAME>" end tag in the recover buffer for
	     * reparsing unless NAME is really an empty element.  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC(c);
		PSRCSTOP(abracket);
	    } else
#endif
		if (context->slashedtag != context->unknown_tag &&
		    !ReallyEmptyTag(context->slashedtag)) {
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, "</");
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, "</");
		}
		StrAllocCat(context->recover, context->slashedtag->name);
		StrAllocCat(context->recover, ">");
	    }
	    context->slashedtag = NULL;

	} else if (context->element_stack &&
		   (context->element_stack->tag->flags & Tgf_frecyc)) {
	    /*
	     * The element stack says we are within the contents of an element
	     * that the next stage (HTML.c) may want to feed us back again (via
	     * the *include string).  So try to output text in UTF-8 if
	     * possible, using the same logic as for attribute values (which
	     * should be in line with what context->current_tag_charset
	     * indicates).  - kw
	     */
	    if (context->T.decode_utf8 &&
		*context->utf_buf) {
		PUTS(context->utf_buf);
		context->utf_buf_p = context->utf_buf;
		*(context->utf_buf_p) = '\0';
	    } else if (HTCJK == NOCJK &&
		       (context->T.output_utf8 ||
			context->T.trans_from_uni)) {
		if (LYIsASCII(clong)) {
		    PUTC(c);
		} else if (clong == 0xfffd && saved_char_in &&
			   HTPassEightBitRaw &&
			   UCH(saved_char_in) >=
			   LYlowest_eightbit[context->outUCLYhndl]) {
		    PUTUTF8((0xf000 | UCH(saved_char_in)));
		} else {
		    PUTUTF8(clong);
		}
	    } else if (saved_char_in && context->T.use_raw_char_in) {
		PUTC(saved_char_in);
	    } else {
		PUTC(c);
	    }

#define PASS8859SPECL context->T.pass_160_173_raw
	    /*
	     * Convert 160 (nbsp) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_NBSP &&	/* S/390 -- gil -- 0932 */
		   !context->no_lynx_specialcodes &&
		   !(PASS8859SPECL || HTCJK != NOCJK)) {
	    PUTC(HT_NON_BREAK_SPACE);
	    /*
	     * Convert 173 (shy) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_SHY &&	/* S/390 -- gil -- 0949 */
		   !context->no_lynx_specialcodes &&
		   !(PASS8859SPECL || HTCJK != NOCJK)) {
	    PUTC(LY_SOFT_HYPHEN);
	    /*
	     * Handle the case in which we think we have a character which
	     * doesn't need further processing (e.g., a koi8-r input for a
	     * koi8-r output).  - FM
	     */
	} else if (context->T.use_raw_char_in && saved_char_in) {
	    /*
	     * Only if the original character is still in saved_char_in,
	     * otherwise we may be iterating from a goto top.  - KW
	     */
	    PUTC(saved_char_in);
	    saved_char_in = '\0';
/******************************************************************
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
 ******************************************************************/
	} else if ((chk = (BOOL) (context->T.trans_from_uni &&
				  TOASCII(unsign_c) >= 160)) &&		/* S/390 -- gil -- 0968 */
		   (uck = UCTransUniChar(unsign_c,
					 context->outUCLYhndl)) >= ' ' &&
		   uck < 256) {
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
		    uck, FROMASCII((char) uck)));
	    /*
	     * We got one octet from the conversions, so use it.  - FM
	     */
	    PUTC(FROMASCII((char) uck));
	} else if ((chk &&
		    (uck == -4 ||
		     (context->T.repl_translated_C0 &&
		      uck > 0 && uck < 32))) &&
	    /*
	     * Not found; look for replacement string.  - KW
	     */
		   (uck = UCTransUniCharStr(replace_buf, 60, clong,
					    context->outUCLYhndl,
					    0) >= 0)) {
	    /*
	     * Got a replacement string.  No further tests for validity -
	     * assume that whoever defined replacement strings knew what she
	     * was doing.  - KW
	     */
	    PUTS(replace_buf);
	    /*
	     * If we're displaying UTF-8, try that now.  - FM
	     */
	} else if (context->T.output_utf8 && PUTUTF8(clong)) {
	    ;			/* do nothing more */
	    /*
	     * If it's any other (> 160) 8-bit character, and we have not set
	     * HTPassEightBitRaw nor HTCJK, nor have the "ISO Latin 1"
	     * character set selected, back translate for our character set.  -
	     * FM
	     */
#define IncludesLatin1Enc \
		(context->outUCLYhndl == LATIN1 || \
		 (context->outUCI && \
		  (context->outUCI->enc & (UCT_CP_SUPERSETOF_LAT1))))

#define PASSHI8BIT (HTPassEightBitRaw || \
		    (context->T.do_8bitraw && !context->T.trans_from_uni))

	} else if (unsign_c > 160 && unsign_c < 256 &&
		   !(PASSHI8BIT || HTCJK != NOCJK) &&
		   !IncludesLatin1Enc) {
#ifdef USE_PRETTYSRC
	    int psrc_view_backup = 0;
#endif

	    string->size = 0;
	    EntityName = HTMLGetEntityName((int) (unsign_c - 160));
	    HTChunkPuts(string, EntityName);
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    /* we need to disable it temporary */
	    if (psrc_view) {
		psrc_view_backup = 1;
		psrc_view = 0;
	    }
#endif
	    handle_entity(context, '\0');
#ifdef USE_PRETTYSRC
	    /* we need to disable it temporary */
	    if (psrc_view_backup)
		psrc_view = TRUE;
#endif

	    string->size = 0;
	    if (!FoundEntity)
		PUTC(';');
	    /*
	     * If we get to here and have an ASCII char, pass the character.  -
	     * KW
	     */
	} else if (TOASCII(unsign_c) < 127 && unsign_c > 0) {	/* S/390 -- gil -- 0987 */
	    PUTC(c);
	    /*
	     * If we get to here, and should have translated, translation has
	     * failed so far.  - KW
	     *
	     * We should have sent UTF-8 output to the parser already, but what
	     * the heck, try again.  - FM
	     */
	} else if (context->T.output_utf8 && *context->utf_buf) {
	    PUTS(context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
#ifdef NOTDEFINED
	    /*
	     * Check for a strippable koi8-r 8-bit character.  - FM
	     */
	} else if (context->T.strip_raw_char_in && saved_char_in &&
		   (UCH(saved_char_in) >= 0xc0) &&
		   (UCH(saved_char_in) < 255)) {
	    /*
	     * KOI8 special:  strip high bit, gives (somewhat) readable ASCII
	     * or KOI7 - it was constructed that way!  - KW
	     */
	    PUTC(((char) (saved_char_in & 0x7f)));
	    saved_char_in = '\0';
#endif /* NOTDEFINED */
	    /*
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
	} else if (TOASCII(UCH(c)) <	/* S/390 -- gil -- 0997 */
		   LYlowest_eightbit[context->outUCLYhndl] ||
		   (context->T.trans_from_uni && !HTPassEightBitRaw)) {
	    /*
	     * If we get to here, pass the character.  - FM
	     */
	} else {
	    PUTC(c);
	}
	break;

	/*
	 * Found '<' in SGML_PCDATA content; treat this mode nearly like
	 * S_litteral, but recognize '<!' and '<?' to filter out comments and
	 * processing instructions.  - kw
	 */
    case S_pcdata:
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
		/*
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    } else if (c == '?') {	/* <? - ignore as a PI until '>' - kw */
		CTRACE((tfp,
			"SGML: Found PI in PCDATA, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("<?");
		    PSRCSTOP(abracket);
		    context->seen_nonwhite_in_junk_tag = TRUE;	/* show all */
		}
#endif
		context->state = S_junk_pi;
		break;
	    }
	}
	goto case_S_litteral;

	/*
	 * Found '<' in SGML_SCRIPT content; treat this mode nearly like
	 * S_litteral, but recognize '<!' to allow the content to be treated as
	 * a comment by lynx.
	 */
    case S_script:
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
		/*
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    }
	}
	goto case_S_litteral;

	/*
	 * In litteral mode, waits only for specific end tag (for compatibility
	 * with old servers, and for Lynx).  - FM
	 */
      case_S_litteral:
    case S_litteral:		/*PSRC:this case not understood completely by HV, not done */
	HTChunkPutc(string, c);
#ifdef USE_PRETTYSRC
	if (psrc_view) {	/*there is nothing useful in the element_stack */
	    testtag = context->current_tag;
	} else
#endif
	    testtag = context->element_stack ?
		context->element_stack->tag : NULL;

	if (testtag == NULL) {
	    string->size--;
	    context->state = S_text;
	    goto top1;
	}

	/*
	 * Normally when we get the closing ">",
	 *      testtag contains something like "TITLE"
	 *      string contains something like "/title>"
	 * so we decrement by 2 to compare the final character of each.
	 */
	testlast = string->size - 2 - context->trailing_spaces - context->leading_spaces;

	if (TOUPPER(c) != ((testlast < 0)
			   ? '/'
			   : testtag->name[testlast])) {
	    int i;

	    /*
	     * If complete match, end litteral.
	     */
	    if ((c == '>') &&
		testlast >= 0 && !testtag->name[testlast]) {
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("</");
		    PSRCSTOP(abracket);
		    PSRCSTART(tag);
		    strcpy(string->data, context->current_tag->name);
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
		    PUTS(string->data);
		    PSRCSTOP(tag);
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);

		    context->current_tag = NULL;
		} else
#endif
		    end_element(context, context->element_stack->tag);

		string->size = 0;
		context->current_attribute_number = INVALID;
		context->state = S_text;
		context->leading_spaces = 0;
		context->trailing_spaces = 0;
		break;
	    }

	    /*
	     * Allow whitespace between the "<" or ">" and the keyword, for
	     * error-recovery.
	     */
	    if (isspace(UCH(c))) {
		if (testlast == -1) {
		    context->leading_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "leading spaces: %d\n", context->leading_spaces));
		    break;
		} else if (testlast > 0) {
		    context->trailing_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "trailing spaces: %d\n", context->trailing_spaces));
		    break;
		}
	    }

	    /*
	     * Mismatch - recover.
	     */
	    context->leading_spaces = 0;
	    context->trailing_spaces = 0;
	    if (((testtag->contents != SGML_LITTERAL &&
		  (testtag->flags & Tgf_strict)) ||
		 (context->state == S_pcdata &&
		  (testtag->flags & (Tgf_strict | Tgf_endO)))) &&
		(testlast > -1 &&
		 (c == '>' || testlast > 0 || IsNmStart(c)))) {
		context->state = S_end;
		string->size--;
		for (i = 0; i < string->size; i++)	/* remove '/' */
		    string->data[i] = string->data[i + 1];
		if ((string->size == 1) ? IsNmStart(c) : IsNmChar(c))
		    break;
		string->size--;
		goto top1;
	    }
	    if (context->state == S_pcdata &&
		(testtag->flags & (Tgf_strict | Tgf_endO)) &&
		(testlast < 0 && IsNmStart(c))) {
		context->state = S_tag;
		break;
	    }
	    /*
	     * If Mismatch:  recover string literally.
	     */
	    PUTC('<');
	    for (i = 0; i < string->size - 1; i++)	/* recover, except last c */
		PUTC(string->data[i]);
	    string->size = 0;
	    context->state = S_text;
	    goto top1;		/* to recover last c */
	}
	break;

	/*
	 * Character reference (numeric entity) or named entity.
	 */
    case S_ero:
	if (c == '#') {
	    /*
	     * Setting up for possible numeric entity.
	     */
	    context->state = S_cro;	/* &# is Char Ref Open */
	    break;
	}
	context->state = S_entity;	/* Fall through! */

	/*
	 * Handle possible named entity.
	 */
    case S_entity:
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1029 */
					isalnum(UCH(c)) : isalpha(UCH(c)))) {
	    /* Should probably use IsNmStart/IsNmChar above (is that right?),
	       but the world is not ready for that - there's &nbsp: (note
	       colon!) and stuff around. */
	    /*
	     * Accept valid ASCII character.  - FM
	     */
	    HTChunkPutc(string, c);
	} else if (string->size == 0) {
	    /*
	     * It was an ampersand that's just text, so output the ampersand
	     * and recycle this character.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTC('&');
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    context->state = S_text;
	    goto top1;
	} else {
	    /*
	     * Terminate entity name and try to handle it.  - FM
	     */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    entity_string = string->data;
#endif
	    /* S/390 -- gil -- 1039 */
	    /* CTRACE((tfp, "%s: %d: %s\n", __FILE__, __LINE__, string->data)); */
	    if (!strcmp(string->data, "zwnj") &&
		(!context->element_stack ||
		 (context->element_stack->tag &&
		  context->element_stack->tag->contents == SGML_MIXED))) {
		/*
		 * Handle zwnj (8204) as <WBR>.  - FM
		 */
		char temp[8];

		CTRACE((tfp,
			"SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));

		if (c != ';') {
		    sprintf(temp, "<WBR>%c", c);
		} else {
		    sprintf(temp, "<WBR>");
		}
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, temp);
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, temp);
		}
		string->size = 0;
		context->state = S_text;
		break;
	    } else {
		handle_entity(context, '\0');
	    }
	    string->size = 0;
	    context->state = S_text;
	    /*
	     * Don't eat the terminator if we didn't find the entity name and
	     * therefore sent the raw string via handle_entity(), or if the
	     * terminator is not the "standard" semi-colon for HTML.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view && FoundEntity && c == ';') {
		PSRCSTART(entity);
		PUTC(c);
		PSRCSTOP(entity);
	    }
#endif
	    if (!FoundEntity || c != ';')
		goto top1;
	}
	break;

	/*
	 * Check for a numeric entity.
	 */
    case S_cro:
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {	/* S/390 -- gil -- 1060 */
	    context->isHex = TRUE;
	    context->state = S_incro;
	} else if (TOASCII(unsign_c) < 127 && isdigit(UCH(c))) {
	    /*
	     * Accept only valid ASCII digits.  - FM
	     */
	    HTChunkPutc(string, c);	/* accumulate a character NUMBER */
	    context->isHex = FALSE;
	    context->state = S_incro;
	} else if (string->size == 0) {
	    /*
	     * No 'x' or digit following the "&#" so recover them and recycle
	     * the character.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTC('&');
	    PUTC('#');
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    context->state = S_text;
	    goto top1;
	}
	break;

	/*
	 * Handle a numeric entity.
	 */
    case S_incro:
/* S/390 -- gil -- 1075 *//* CTRACE((tfp, "%s: %d: numeric %d %d\n",
   __FILE__, __LINE__, unsign_c, c)); */
	if ((TOASCII(unsign_c) < 127) &&
	    (context->isHex ? isxdigit(UCH(c)) :
	     isdigit(UCH(c)))) {
	    /*
	     * Accept only valid hex or ASCII digits.  - FM
	     */
	    HTChunkPutc(string, c);	/* accumulate a character NUMBER */
	} else if (string->size == 0) {
	    /*
	     * No hex digit following the "&#x" so recover them and recycle the
	     * character.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTS("&#x");
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    context->isHex = FALSE;
	    context->state = S_text;
	    goto top1;
	} else {
	    /*
	     * Terminate the numeric entity and try to handle it.  - FM
	     */
	    UCode_t code;
	    int i;

	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    entity_string = string->data;
#endif
	    if ((context->isHex ? sscanf(string->data, "%lx", &code) :
		 sscanf(string->data, "%ld", &code)) == 1) {
/* =============== work in ASCII below here ===============  S/390 -- gil -- 1092 */
		if ((code == 1) ||
		    (code > 127 && code < 156)) {
		    /*
		     * Assume these are Microsoft code points, inflicted on us
		     * by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159 range
		     * and doesn't follow Unicode standards for this area. 
		     * Windows-1252 codepoints are assumed here.
		     */
		    switch (code) {
		    case 1:
			/*
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
			break;
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
			break;
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
			break;
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
			break;
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
			break;
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
			break;
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
			break;
		    }
		}
		/*
		 * Check for special values.  - FM
		 */
		if ((code == 8204) &&
		    (!context->element_stack ||
		     (context->element_stack->tag &&
		      context->element_stack->tag->contents == SGML_MIXED))) {
		    /*
		     * Handle zwnj (8204) as <WBR>.  - FM
		     */
		    char temp[8];

		    CTRACE((tfp,
			    "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));

		    /*
		     * Include the terminator if it is not the standard
		     * semi-colon.  - FM
		     */
		    if (c != ';') {
			sprintf(temp, "<WBR>%c", c);
		    } else {
			sprintf(temp, "<WBR>");
		    }
		    /*
		     * Add the replacement string to the recover buffer for
		     * processing.  - FM
		     */
		    if (context->recover == NULL) {
			StrAllocCopy(context->recover, temp);
			context->recover_index = 0;
		    } else {
			StrAllocCat(context->recover, temp);
		    }
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    break;
		} else if (put_special_unicodes(context, code)) {
		    /*
		     * We handled the value as a special character, so recycle
		     * the terminator or break.  - FM
		     */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(entity);
			PUTS((context->isHex ? "&#x" : "&#"));
			PUTS(entity_string);
			if (c == ';')
			    PUTC(';');
			PSRCSTOP(entity);
		    }
#endif
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    if (c != ';')
			goto top1;
		    break;
		}
		/*
		 * Seek a translation from the chartrans tables.
		 */
		if ((uck = UCTransUniChar(code,
					  context->outUCLYhndl)) >= 32 &&
		    uck < 256 &&
		    (uck < 127 ||
		     uck >= LYlowest_eightbit[context->outUCLYhndl])) {
#ifdef USE_PRETTYSRC
		    if (!psrc_view) {
#endif
			PUTC(FROMASCII((char) uck));
#ifdef USE_PRETTYSRC
		    } else {
			put_pretty_number(context);
		    }
#endif
		} else if ((uck == -4 ||
			    (context->T.repl_translated_C0 &&
			     uck > 0 && uck < 32)) &&
		    /*
		     * Not found; look for replacement string.
		     */
			   (uck = UCTransUniCharStr(replace_buf, 60, code,
						    context->outUCLYhndl,
						    0) >= 0)) {
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			put_pretty_number(context);
		    } else
#endif
			PUTS(replace_buf);
		    /*
		     * If we're displaying UTF-8, try that now.  - FM
		     */
		} else if (context->T.output_utf8 && PUTUTF8(code)) {
		    ;		/* do nothing more */
		    /*
		     * Ignore 8205 (zwj), 8206 (lrm), and 8207 (rln), if we get
		     * to here.  - FM
		     */
		} else if (code == 8205 ||
			   code == 8206 ||
			   code == 8207) {
		    if (TRACE) {
			string->size--;
			LYstrncpy(replace_buf,
				  string->data,
				  (string->size < 64 ? string->size : 63));
			fprintf(tfp,
				"SGML_character: Ignoring '%s%s'.\n",
				(context->isHex ? "&#x" : "&#"),
				replace_buf);
		    }
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(badseq);
			PUTS((context->isHex ? "&#x" : "&#"));
			PUTS(entity_string);
			if (c == ';')
			    PUTC(';');
			PSRCSTOP(badseq);
		    }
#endif
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    if (c != ';')
			goto top1;
		    break;
		    /*
		     * Show the numeric entity if we get to here and the value:
		     * (1) Is greater than 255 (but use ASCII characters for
		     * spaces or dashes).
		     * (2) Is less than 32, and not valid or we don't have
		     * HTCJK set.
		     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK
		     * set.
		     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum
		     * set.
		     * - FM
		     */
		} else if ((code > 255) ||
			   (code < ' ' &&	/* S/390 -- gil -- 1140 */
			    code != '\t' && code != '\n' && code != '\r' &&
			    HTCJK == NOCJK) ||
			   (TOASCII(code) == 127 &&
			    !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
			   (TOASCII(code) > 127 && code < 160 &&
			    !HTPassHighCtrlNum)) {
		    /*
		     * Unhandled or illegal value.  Recover the "&#" or "&#x"
		     * and digit(s), and recycle the terminator.  - FM
		     */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(badseq);
		    }
#endif
		    if (context->isHex) {
			PUTS("&#x");
			context->isHex = FALSE;
		    } else {
			PUTS("&#");
		    }
		    string->size--;
		    for (i = 0; i < string->size; i++)	/* recover */
			PUTC(string->data[i]);
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTOP(badseq);
		    }
#endif
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    goto top1;
		} else if (TOASCII(code) < 161 ||	/* S/390 -- gil -- 1162 */
			   HTPassEightBitNum ||
			   IncludesLatin1Enc) {
		    /*
		     * No conversion needed.  - FM
		     */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			put_pretty_number(context);
		    } else
#endif
			PUTC(FROMASCII((char) code));
		} else {
		    /*
		     * Handle as named entity.  - FM
		     */
		    code -= 160;
		    EntityName = HTMLGetEntityName(code);
		    if (EntityName && EntityName[0] != '\0') {
			string->size = 0;
			HTChunkPuts(string, EntityName);
			HTChunkTerminate(string);
			handle_entity(context, '\0');
			/*
			 * Add a semi-colon if something went wrong and
			 * handle_entity() sent the string.  - FM
			 */
			if (!FoundEntity) {
			    PUTC(';');
			}
		    } else {
			/*
			 * Our conversion failed, so recover the "&#" and
			 * digit(s), and recycle the terminator.  - FM
			 */
#ifdef USE_PRETTYSRC
			if (psrc_view)
			    PSRCSTART(badseq);
#endif
			if (context->isHex) {
			    PUTS("&#x");
			    context->isHex = FALSE;
			} else {
			    PUTS("&#");
			}
			string->size--;
			for (i = 0; i < string->size; i++)	/* recover */
			    PUTC(string->data[i]);
#ifdef USE_PRETTYSRC
			if (psrc_view)
			    PSRCSTOP(badseq);
#endif
			string->size = 0;
			context->isHex = FALSE;
			context->state = S_text;
			goto top1;
		    }
		}
		/*
		 * If we get to here, we succeeded.  Hoorah!!!  - FM
		 */
		string->size = 0;
		context->isHex = FALSE;
		context->state = S_text;
		/*
		 * Don't eat the terminator if it's not the "standard"
		 * semi-colon for HTML.  - FM
		 */
		if (c != ';') {
		    goto top1;
		}
	    } else {
		/*
		 * Not an entity, and don't know why not, so add the terminator
		 * to the string, output the "&#" or "&#x", and process the
		 * string via the recover element.  - FM
		 */
		string->size--;
		HTChunkPutc(string, c);
		HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTART(badseq);
#endif
		if (context->isHex) {
		    PUTS("&#x");
		    context->isHex = FALSE;
		} else {
		    PUTS("&#");
		}
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTOP(badseq);
#endif
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, string->data);
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, string->data);
		}
		string->size = 0;
		context->isHex = FALSE;
		context->state = S_text;
		break;
	    }
	}
	break;

	/*
	 * Tag
	 */
    case S_tag:		/* new tag */
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1179 */
					IsNmChar(c) : IsNmStart(c))) {
	    /*
	     * Add valid ASCII character.  - FM
	     */
	    HTChunkPutc(string, c);
	} else if (c == '!' && !string->size) {		/* <! */
	    /*
	     * Terminate and set up for possible comment, identifier,
	     * declaration, or marked section.  - FM
	     */
	    context->state = S_exclamation;
	    context->lead_exclamation = TRUE;
	    context->doctype_bracket = FALSE;
	    context->first_bracket = FALSE;
	    HTChunkPutc(string, c);
	    break;
	} else if (!string->size &&
		   (TOASCII(unsign_c) <= 160 &&		/* S/390 -- gil -- 1196 */
		    (c != '/' && c != '?' && c != '_' && c != ':'))) {
	    /*
	     * '<' must be followed by an ASCII letter to be a valid start tag. 
	     * Here it isn't, nor do we have a '/' for an end tag, nor one of
	     * some other characters with a special meaning for SGML or which
	     * are likely to be legal Name Start characters in XML or some
	     * other extension.  So recover the '<' and following character as
	     * data.  - FM & KW
	     */
	    context->state = S_text;
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTC('<');
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    goto top1;
	} else {		/* End of tag name */
	    /*
	     * Try to handle tag.  - FM
	     */
	    HTTag *t;

	    if (c == '/') {
		if (string->size == 0) {
		    context->state = S_end;
		    break;
		}
		CTRACE((tfp, "SGML: `<%.*s/' found!\n", string->size, string->data));
	    }
	    HTChunkTerminate(string);

	    t = SGMLFindTag(dtd, string->data);
	    if (t == context->unknown_tag &&
		((c == ':' &&
		  string->size == 4 && 0 == strcasecomp(string->data, "URL")) ||
		 (string->size > 4 && 0 == strncasecomp(string->data, "URL:", 4)))) {
		/*
		 * Treat <URL:  as text rather than a junk tag, so we display
		 * it and the URL (Lynxism 8-).  - FM
		 */
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTART(badseq);
#endif
		PUTC('<');
		PUTS(string->data);	/* recover */
		PUTC(c);
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTOP(badseq);
#endif
		CTRACE((tfp, "SGML: Treating <%s%c as text\n",
			string->data, c));
		string->size = 0;
		context->state = S_text;
		break;
	    }
	    if (c == '/' && t) {
		/*
		 * Element name was ended by '/'.  Remember the tag that ended
		 * thusly, we'll interpret this as either an indication of an
		 * empty element (if '>' follows directly) or do some
		 * SGMLshortref-ish treatment.  - kw
		 */
		context->slashedtag = t;
	    }
	    if (!t) {
		if (c == '?' && string->size <= 1) {
		    CTRACE((tfp, "SGML: Found PI, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(abracket);
			PUTS("<?");
			PSRCSTOP(abracket);
			context->seen_nonwhite_in_junk_tag = TRUE;	/*show all */
		    }
#endif
		    context->state = S_junk_pi;
		    break;
		}
		CTRACE((tfp, "SGML: *** Invalid element %s\n",
			string->data));

#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTC('<');
		    PSRCSTOP(abracket);
		    PSRCSTART(badtag);
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
		    PUTS(string->data);
		    if (c == '>') {
			PSRCSTOP(badtag);
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    } else {
			PUTC(c);
		    }
		}
#endif
		context->state = (c == '>') ? S_text : S_junk_tag;
		break;
	    } else if (t == context->unknown_tag) {
		CTRACE((tfp, "SGML: *** Unknown element %s\n",
			string->data));
		/*
		 * Fall through and treat like valid tag for attribute parsing. 
		 * - KW
		 */

	    }
	    context->current_tag = t;

#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC('<');
		PSRCSTOP(abracket);
		if (t != context->unknown_tag)
		    PSRCSTART(tag);
		else
		    PSRCSTART(badtag);
		if (tagname_transform != 1) {
		    if (tagname_transform == 0)
			LYLowerCase(string->data);
		    else
			LYUpperCase(string->data);
		}
		PUTS(string->data);
		if (t != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
	    }
	    if (!psrc_view)	/*don't waste time */
#endif
	    {
		/*
		 * Clear out attributes.
		 */
		memset((void *) context->present, 0, sizeof(BOOL) *
		       context->current_tag->number_of_attributes);
	    }

	    string->size = 0;
	    context->current_attribute_number = INVALID;
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
		    if (c != '<') {
			PSRCSTART(abracket);
			PUTC(c);
			PSRCSTOP(abracket);
			context->state = (c == '>') ? S_text : S_tagname_slash;
		    } else {
			context->state = S_tag;
		    }
		} else {
		    if (!WHITE(c))
			PUTC(c);
		    context->state = S_tag_gap;
		}
	    } else
#endif
	    if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
		if (context->current_tag->name)
		    start_element(context);
		context->state = (c == '>') ? S_text :
		    (c == '<') ? S_tag : S_tagname_slash;
	    } else {
		context->state = S_tag_gap;
	    }
	}
	break;

    case S_exclamation:
	if (context->lead_exclamation && c == '-') {
	    /*
	     * Set up for possible comment.  - FM
	     */
	    context->lead_exclamation = FALSE;
	    context->first_dash = TRUE;
	    HTChunkPutc(string, c);
	    break;
	}
	if (context->lead_exclamation && c == '[') {
	    /*
	     * Set up for possible marked section.  - FM
	     */
	    context->lead_exclamation = FALSE;
	    context->first_bracket = TRUE;
	    context->second_bracket = FALSE;
	    HTChunkPutc(string, c);
	    context->state = S_marked;
	    break;
	}
	if (context->first_dash && c == '-') {
	    /*
	     * Set up to handle comment.  - FM
	     */
	    context->lead_exclamation = FALSE;
	    context->first_dash = FALSE;
	    context->end_comment = FALSE;
	    HTChunkPutc(string, c);
	    context->state = S_comment;
	    break;
	}
	context->lead_exclamation = FALSE;
	context->first_dash = FALSE;
	if (c == '>') {
	    /*
	     * Try to handle identifier.  - FM
	     */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_identifier(context);
	    string->size = 0;
	    context->state = S_text;
	    break;
	}
	if (WHITE(c)) {
	    if (string->size == 8 &&
		!strncasecomp(string->data, "!DOCTYPE", 8)) {
		/*
		 * Set up for DOCTYPE declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->doctype_bracket = FALSE;
		context->state = S_doctype;
		break;
	    }
	    if (string->size == 7 &&
		!strncasecomp(string->data, "!ENTITY", 7)) {
		/*
		 * Set up for ENTITY declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->first_dash = FALSE;
		context->end_comment = TRUE;
		context->state = S_sgmlent;
		break;
	    }
	    if (string->size == 8 &&
		!strncasecomp(string->data, "!ELEMENT", 8)) {
		/*
		 * Set up for ELEMENT declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->first_dash = FALSE;
		context->end_comment = TRUE;
		context->state = S_sgmlele;
		break;
	    }
	    if (string->size == 8 &&
		!strncasecomp(string->data, "!ATTLIST", 8)) {
		/*
		 * Set up for ATTLIST declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->first_dash = FALSE;
		context->end_comment = TRUE;
		context->state = S_sgmlatt;
		break;
	    }
	}
	HTChunkPutc(string, c);
	break;

    case S_comment:		/* Expecting comment. - FM */
	if (historical_comments) {
	    /*
	     * Any '>' terminates.  - FM
	     */
	    if (c == '>') {
		HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(comm);
		    PUTC('<');
		    PUTS_TR(string->data);
		    PUTC('>');
		    PSRCSTOP(comm);
		} else
#endif
		    handle_comment(context);
		string->size = 0;
		context->end_comment = FALSE;
		context->first_dash = FALSE;
		context->state = S_text;
		break;
	    }
	    goto S_comment_put_c;
	}
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else if (!minimal_comments)
		/*
		 * Validly treat '--' pairs as successive comments (for
		 * minimal, any "--WHITE>" terminates).  - FM
		 */
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    /*
	     * Terminate and handle the comment.  - FM
	     */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(comm);
		PUTC('<');
		PUTS_TR(string->data);
		PUTC('>');
		PSRCSTOP(comm);
	    } else
#endif
		handle_comment(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	if (context->end_comment && !isspace(UCH(c)))
	    context->end_comment = FALSE;

      S_comment_put_c:
	if (context->T.decode_utf8 &&
	    *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (HTCJK == NOCJK &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		UCH(saved_char_in) >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (0xf000 | UCH(saved_char_in)));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_doctype:		/* Expecting DOCTYPE. - FM */
	if (context->doctype_bracket) {
	    HTChunkPutc(string, c);
	    if (c == ']')
		context->doctype_bracket = FALSE;
	    break;
	}
	if (c == '[' && WHITE(string->data[string->size - 1])) {
	    HTChunkPutc(string, c);
	    context->doctype_bracket = TRUE;
	    break;
	}
	if (c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_doctype(context);
	    string->size = 0;
	    context->state = S_text;
	    break;
	}
	HTChunkPutc(string, c);
	break;

    case S_marked:		/* Expecting marked section. - FM */
	if (context->first_bracket && c == '[') {
	    HTChunkPutc(string, c);
	    context->first_bracket = FALSE;
	    context->second_bracket = TRUE;
	    break;
	}
	if (context->second_bracket && c == ']' &&
	    string->data[string->size - 1] == ']') {
	    HTChunkPutc(string, c);
	    context->second_bracket = FALSE;
	    break;
	}
	if (!context->second_bracket && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_marked(context);
	    string->size = 0;
	    context->state = S_text;
	    break;
	}
	HTChunkPutc(string, c);
	break;

    case S_sgmlent:		/* Expecting ENTITY. - FM */
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_sgmlent(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	HTChunkPutc(string, c);
	break;

    case S_sgmlele:		/* Expecting ELEMENT. - FM */
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_sgmlele(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	HTChunkPutc(string, c);
	break;

    case S_sgmlatt:		/* Expecting ATTLIST. - FM */
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_sgmlatt(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	HTChunkPutc(string, c);
	break;

    case S_tag_gap:		/* Expecting attribute or '>' */
	if (WHITE(c))
	    break;		/* Gap between attributes */
	if (c == '>') {		/* End of tag */
#ifdef USE_PRETTYSRC
	    if (!psrc_view)
#endif
		if (context->current_tag->name)
		    start_element(context);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
	    }
#endif
	    context->state = S_text;
	    break;
	}
	HTChunkPutc(string, c);
	context->state = S_attr;	/* Get attribute */
	break;

	/* accumulating value */
    case S_attr:
	if (WHITE(c) || (c == '>') || (c == '=')) {	/* End of word */
	    HTChunkTerminate(string);
	    handle_attribute_name(context, string->data);
#ifdef USE_PRETTYSRC
	    if (!psrc_view) {
#endif
		string->size = 0;
		if (c == '>') {	/* End of tag */
		    if (context->current_tag->name)
			start_element(context);
		    context->state = S_text;
		    break;
		}
#ifdef USE_PRETTYSRC
	    } else {
		PUTC(' ');
		if (context->current_attribute_number == INVALID)
		    PSRCSTART(badattr);
		else
		    PSRCSTART(attrib);
		if (attrname_transform != 1) {
		    if (attrname_transform == 0)
			LYLowerCase(string->data);
		    else
			LYUpperCase(string->data);
		}
		PUTS(string->data);
		if (c == '=')
		    PUTC('=');
		if (c == '=' || c == '>') {
		    if (context->current_attribute_number == INVALID)
			PSRCSTOP(badattr);
		    else
			PSRCSTOP(attrib);
		}
		if (c == '>') {
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		    context->state = S_text;
		    break;
		}
		string->size = 0;
	    }
#endif
	    context->state = (c == '=' ? S_equals : S_attr_gap);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_attr_gap:		/* Expecting attribute or '=' or '>' */
	if (WHITE(c))
	    break;		/* Gap after attribute */
	if (c == '>') {		/* End of tag */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		if (context->current_attribute_number == INVALID) {
		    PSRCSTOP(badattr);
		} else {
		    PSRCSTOP(attrib);
		}
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
	    } else
#endif
	    if (context->current_tag->name)
		start_element(context);
	    context->state = S_text;
	    break;
	} else if (c == '=') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PUTC('=');
		if (context->current_attribute_number == INVALID) {
		    PSRCSTOP(badattr);
		} else {
		    PSRCSTOP(attrib);
		}
	    }
#endif
	    context->state = S_equals;
	    break;
	}
	HTChunkPutc(string, c);
	context->state = S_attr;	/* Get next attribute */
	break;

    case S_equals:		/* After attr = */
	if (WHITE(c))
	    break;		/* Before attribute value */
	if (c == '>') {		/* End of tag */
	    CTRACE((tfp, "SGML: found = but no value\n"));
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
	    } else
#endif
	    if (context->current_tag->name)
		start_element(context);
	    context->state = S_text;
	    break;

	} else if (c == '\'') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(attrval);
		PUTC(c);
	    }
#endif
	    context->state = S_squoted;
	    break;

	} else if (c == '"') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(attrval);
		PUTC(c);
	    }
#endif
	    context->state = S_dquoted;
	    break;
	}
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    PSRCSTART(attrval);
#endif
	context->state = S_value;
	/*  no break!  fall through to S_value and process current `c`   */

    case S_value:
	if (WHITE(c) || (c == '>')) {	/* End of word */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
		    PSRCSTART(href);
		    HTStartAnchor(context->target, NULL, string->data);
		}
		PUTS_TR(string->data);
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		    PSRCSTOP(href);
		}
		PSRCSTOP(attrval);
	    } else
#endif
#ifdef CJK_EX			/* Quick hack. - JH7AYN */
	    {
		char jis_buf[512];

		if (string->data[0] == '$') {
		    if (string->data[1] == 'B' || string->data[1] == '@@') {
			jis_buf[0] = '\033';
			strcpy(jis_buf + 1, string->data);
			TO_EUC((const unsigned char *) jis_buf,
			       (unsigned char *) string->data);
		    }
		}
	    }
#endif
	    handle_attribute_value(context, string->data);
	    string->size = 0;
	    if (c == '>') {	/* End of tag */
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		} else
#endif
		if (context->current_tag->name)
		    start_element(context);
		context->state = S_text;
		break;
	    } else
		context->state = S_tag_gap;
	} else if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (HTCJK == NOCJK &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		UCH(saved_char_in) >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (0xf000 | UCH(saved_char_in)));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_squoted:		/* Quoted attribute value */
	if (c == '\'') {	/* End of attribute value */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
		    PSRCSTART(href);
		    HTStartAnchor(context->target, NULL, string->data);
		}
		PUTS_TR(string->data);
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		    PSRCSTOP(href);
		}
		PUTC('\'');
		PSRCSTOP(attrval);
	    } else
#endif
		handle_attribute_value(context, string->data);
	    string->size = 0;
	    context->state = S_tag_gap;
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1213 */
	    /*
	     * Setting up for possible single quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
	    context->state = S_esc_sq;
	    HTChunkPutc(string, c);
	} else if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (HTCJK == NOCJK &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		UCH(saved_char_in) >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (0xf000 | UCH(saved_char_in)));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_dquoted:		/* Quoted attribute value */
	if (c == '"' ||		/* Valid end of attribute value */
	    (soft_dquotes &&	/*  If emulating old Netscape bug, treat '>' */
	     c == '>')) {	/*  as a co-terminator of dquoted and tag    */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
		    PSRCSTART(href);
		    HTStartAnchor(context->target, NULL, string->data);
		}
		PUTS_TR(string->data);
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		    PSRCSTOP(href);
		}
		PUTC(c);
		PSRCSTOP(attrval);
	    } else
#endif

		handle_attribute_value(context, string->data);
	    string->size = 0;
	    context->state = S_tag_gap;
	    if (c == '>')	/* We emulated the Netscape bug, so we go  */
		goto top1;	/* back and treat it as the tag terminator */
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1230 */
	    /*
	     * Setting up for possible double quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
	    context->state = S_esc_dq;
	    HTChunkPutc(string, c);
	} else if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (HTCJK == NOCJK &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		UCH(saved_char_in) >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (0xf000 | UCH(saved_char_in)));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_end:		/* </ */
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1247 */
					IsNmChar(c) : IsNmStart(c))) {
	    HTChunkPutc(string, c);
	} else {		/* End of end tag name */
	    HTTag *t = 0;

#ifdef USE_PRETTYSRC
	    BOOL psrc_tagname_processed = FALSE;
#endif

	    HTChunkTerminate(string);
	    if (!*string->data) {	/* Empty end tag */
		if (context->element_stack)
		    t = context->element_stack->tag;
	    } else {
		t = SGMLFindTag(dtd, string->data);
	    }
	    if (!t || t == context->unknown_tag) {
		CTRACE((tfp, "Unknown end tag </%s>\n", string->data));
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("</");
		    PSRCSTOP(abracket);
		    PSRCSTART(badtag);
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
		    PUTS(string->data);
		    if (c != '>') {
			PUTC(c);
		    } else {
			PSRCSTOP(badtag);
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    }
		    psrc_tagname_processed = TRUE;
		}
	    } else if (psrc_view) {
#endif
	    } else {
		BOOL tag_OK = (BOOL) (c == '>' || WHITE(c));

#if OPT
		HTMLElement e = TAGNUM_OF_TAGP(t);
		int branch = 2;	/* it can be 0,1,2 */
#endif
		context->current_tag = t;
		if (HAS_ALT_TAGNUM(TAGNUM_OF_TAGP(t)) &&
		    context->element_stack &&
		    ALT_TAGP(t) == context->element_stack->tag)
		    context->element_stack->tag = NORMAL_TAGP(context->element_stack->tag);
#if OPT
		if (tag_OK
#ifdef EXTENDED_HTMLDTD
		    && Old_DTD
#endif
		    ) {
		    switch (e) {
		    case HTML_DD:
		    case HTML_DT:
		    case HTML_LI:
		    case HTML_LH:
		    case HTML_TD:
		    case HTML_TH:
		    case HTML_TR:
		    case HTML_THEAD:
		    case HTML_TFOOT:
		    case HTML_TBODY:
		    case HTML_COLGROUP:
			branch = 0;
			break;

		    case HTML_A:
		    case HTML_B:
		    case HTML_BLINK:
		    case HTML_CITE:
		    case HTML_EM:
		    case HTML_FONT:
		    case HTML_FORM:
		    case HTML_I:
		    case HTML_P:
		    case HTML_STRONG:
		    case HTML_TT:
		    case HTML_U:
			branch = 1;
			break;
		    default:
			break;
		    }
		}
#endif

#ifdef EXTENDED_HTMLDTD
		/*
		 * Just handle ALL end tags normally :-) - kw
		 */
		if (!Old_DTD) {
		    end_element(context, context->current_tag);
		} else
#endif /* EXTENDED_HTMLDTD */

		    if (tag_OK &&
#if OPT
			(branch == 0)
#else
			(!strcasecomp(string->data, "DD") ||
			 !strcasecomp(string->data, "DT") ||
			 !strcasecomp(string->data, "LI") ||
			 !strcasecomp(string->data, "LH") ||
			 !strcasecomp(string->data, "TD") ||
			 !strcasecomp(string->data, "TH") ||
			 !strcasecomp(string->data, "TR") ||
			 !strcasecomp(string->data, "THEAD") ||
			 !strcasecomp(string->data, "TFOOT") ||
			 !strcasecomp(string->data, "TBODY") ||
			 !strcasecomp(string->data, "COLGROUP"))
#endif
		    ) {
		    /*
		     * Don't treat these end tags as invalid, nor act on them. 
		     * - FM
		     */
		    CTRACE((tfp, "SGML: `</%s%c' found!  Ignoring it.\n",
			    string->data, c));
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    if (c != '>') {
			context->state = S_junk_tag;
		    } else {
			context->current_tag = NULL;
			context->state = S_text;
		    }
		    break;
		} else if (tag_OK &&
#if OPT
			   (branch == 1)
#else
			   (!strcasecomp(string->data, "A") ||
			    !strcasecomp(string->data, "B") ||
			    !strcasecomp(string->data, "BLINK") ||
			    !strcasecomp(string->data, "CITE") ||
			    !strcasecomp(string->data, "EM") ||
			    !strcasecomp(string->data, "FONT") ||
			    !strcasecomp(string->data, "FORM") ||
			    !strcasecomp(string->data, "I") ||
			    !strcasecomp(string->data, "P") ||
			    !strcasecomp(string->data, "STRONG") ||
			    !strcasecomp(string->data, "TT") ||
			    !strcasecomp(string->data, "U"))
#endif
		    ) {
		    /*
		     * Handle end tags for container elements declared as
		     * SGML_EMPTY to prevent "expected tag substitution" but
		     * still processed via HTML_end_element() in HTML.c with
		     * checks there to avoid throwing the HTML.c stack out of
		     * whack (Ugh, what a hack!  8-).  - FM
		     */
		    if (context->inSELECT) {
			/*
			 * We are in a SELECT block.  - FM
			 */
			if (strcasecomp(string->data, "FORM")) {
			    /*
			     * It is not at FORM end tag, so ignore it.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
				    string->data));
			} else {
			    /*
			     * End the SELECT block and then handle the FORM
			     * end tag.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
				    string->data));
			    end_element(context,
					SGMLFindTag(context->dtd, "SELECT"));
			    CTRACE((tfp, "SGML: End </%s>\n", string->data));

#ifdef USE_PRETTYSRC
			    if (!psrc_view)	/* Don't actually call if viewing psrc - kw */
#endif
				(*context->actions->end_element)
				    (context->target,
				     TAGNUM_OF_TAGP(context->current_tag),
				     &context->include);
			}
		    } else if (!strcasecomp(string->data, "P")) {
			/*
			 * Treat a P end tag like a P start tag (Ugh, what a
			 * hack!  8-).  - FM
			 */
			CTRACE((tfp,
				"SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				string->data, c, string->data, c));
			{
			    int i;

			    for (i = 0;
				 i < context->current_tag->number_of_attributes;
				 i++) {
				context->present[i] = NO;
			    }
			}
			if (context->current_tag->name)
			    start_element(context);
		    } else {
			CTRACE((tfp, "SGML: End </%s>\n", string->data));

#ifdef USE_PRETTYSRC
			if (!psrc_view)		/* Don't actually call if viewing psrc - kw */
#endif
			    (*context->actions->end_element)
				(context->target,
				 TAGNUM_OF_TAGP(context->current_tag),
				 &context->include);
		    }
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    if (c != '>') {
			context->state = S_junk_tag;
		    } else {
			context->current_tag = NULL;
			context->state = S_text;
		    }
		    break;
		} else {
		    /*
		     * Handle all other end tags normally.  - FM
		     */
		    end_element(context, context->current_tag);
		}
	    }

#ifdef USE_PRETTYSRC
	    if (psrc_view && !psrc_tagname_processed) {
		PSRCSTART(abracket);
		PUTS("</");
		PSRCSTOP(abracket);
		PSRCSTART(tag);
		if (tagname_transform != 1) {
		    if (tagname_transform == 0)
			LYLowerCase(string->data);
		    else
			LYUpperCase(string->data);
		}
		PUTS(string->data);
		PSRCSTOP(tag);
		if (c != '>') {
		    PSRCSTART(badtag);
		    PUTC(c);
		} else {
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		}
	    }
#endif

	    string->size = 0;
	    context->current_attribute_number = INVALID;
	    if (c != '>') {
		if (!WHITE(c))
		    CTRACE((tfp, "SGML: `</%s%c' found!\n", string->data, c));
		context->state = S_junk_tag;
	    } else {
		context->current_tag = NULL;
		context->state = S_text;
	    }
	}
	break;

    case S_esc:		/* Expecting '$'or '(' following CJK ESC. */
	if (c == '$') {
	    context->state = S_dollar;
	} else if (c == '(') {
	    context->state = S_paren;
	} else {
	    context->state = S_text;
	}
	PUTC(c);
	break;

    case S_dollar:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
	if (c == '@@' || c == 'B' || c == 'A') {
	    context->state = S_nonascii_text;
	} else if (c == '(') {
	    context->state = S_dollar_paren;
	}
	PUTC(c);
	break;

    case S_dollar_paren:	/* Expecting 'C' after CJK "ESC$(". */
	if (c == 'C') {
	    context->state = S_nonascii_text;
	} else {
	    context->state = S_text;
	}
	PUTC(c);
	break;

    case S_paren:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
	if (c == 'B' || c == 'J' || c == 'T') {
	    context->state = S_text;
	} else if (c == 'I') {
	    context->state = S_nonascii_text;
	} else {
	    context->state = S_text;
	}
	PUTC(c);
	break;

    case S_nonascii_text:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1264 */
	    context->state = S_esc;
	}
	PUTC(c);
	if (c < 32)
	    context->state = S_text;
	break;

    case S_esc_sq:		/* Expecting '$'or '(' following CJK ESC. */
	if (c == '$') {
	    context->state = S_dollar_sq;
	} else if (c == '(') {
	    context->state = S_paren_sq;
	} else {
	    context->state = S_squoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_sq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
	if (c == '@@' || c == 'B' || c == 'A') {
	    context->state = S_nonascii_text_sq;
	} else if (c == '(') {
	    context->state = S_dollar_paren_sq;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_paren_sq:	/* Expecting 'C' after CJK "ESC$(". */
	if (c == 'C') {
	    context->state = S_nonascii_text_sq;
	} else {
	    context->state = S_squoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_paren_sq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
	if (c == 'B' || c == 'J' || c == 'T') {
	    context->state = S_squoted;
	} else if (c == 'I') {
	    context->state = S_nonascii_text_sq;
	} else {
	    context->state = S_squoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_nonascii_text_sq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1281 */
	    context->state = S_esc_sq;
	}
	HTChunkPutc(string, c);
	break;

    case S_esc_dq:		/* Expecting '$'or '(' following CJK ESC. */
	if (c == '$') {
	    context->state = S_dollar_dq;
	} else if (c == '(') {
	    context->state = S_paren_dq;
	} else {
	    context->state = S_dquoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_dq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
	if (c == '@@' || c == 'B' || c == 'A') {
	    context->state = S_nonascii_text_dq;
	} else if (c == '(') {
	    context->state = S_dollar_paren_dq;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_paren_dq:	/* Expecting 'C' after CJK "ESC$(". */
	if (c == 'C') {
	    context->state = S_nonascii_text_dq;
	} else {
	    context->state = S_dquoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_paren_dq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
	if (c == 'B' || c == 'J' || c == 'T') {
	    context->state = S_dquoted;
	} else if (c == 'I') {
	    context->state = S_nonascii_text_dq;
	} else {
	    context->state = S_dquoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_nonascii_text_dq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1298 */
	    context->state = S_esc_dq;
	}
	HTChunkPutc(string, c);
	break;

    case S_junk_tag:
    case S_junk_pi:
	if (c == '>') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		if (context->state == S_junk_tag) {
		    PSRCSTOP(badtag);
		}
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
		context->seen_nonwhite_in_junk_tag = FALSE;
	    }
#endif
	    context->current_tag = NULL;
	    context->state = S_text;
	}
#ifdef USE_PRETTYSRC
	else if (psrc_view) {
	    /*pack spaces until first non-space is seen */
	    if (!context->seen_nonwhite_in_junk_tag) {
		if (!WHITE(c)) {
		    context->seen_nonwhite_in_junk_tag = TRUE;
		    PUTC(c);
		}
	    } else
		PUTC(c);
	}
#endif

    }				/* switch on context->state */
    CTRACE2(TRACE_SGML, (tfp, "SGML after  %s|%.*s|%c|\n",
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));

  after_switch:
    /*
     * Check whether an external function has added anything to the include
     * buffer.  If so, move the new stuff to the beginning of active_include. 
     * - kw
     */
    if (context->include != NULL) {
	if (context->include[0] == '\0') {
	    FREE(context->include);
	} else {
	    if (context->active_include &&
		context->active_include[context->include_index] != '\0')
		StrAllocCat(context->include,
			    context->active_include + context->include_index);
	    FREE(context->active_include);
	    context->active_include = context->include;
	    context->include_index = 0;
	    context->include = NULL;
	}
    }

    /*
     * Check whether we've added anything to the recover buffer.  - FM
     */
    if (context->recover != NULL) {
	if (context->recover[context->recover_index] == '\0') {
	    FREE(context->recover);
	    context->recover_index = 0;
	} else {
	    c = context->recover[context->recover_index];
	    context->recover_index++;
	    goto top;
	}
    }

    /*
     * Check whether an external function had added anything to the include
     * buffer; it should now be in active_include.  - FM / kw
     */
    if (context->active_include != NULL) {
	if (context->active_include[context->include_index] == '\0') {
	    FREE(context->active_include);
	    context->include_index = 0;
	} else {
	    if (context->current_tag_charset == UTF8_handle ||
		context->T.trans_from_uni) {
		/*
		 * If it looks like we would have fed UTF-8 to the next
		 * processing stage, assume that whatever we were fed back is
		 * in UTF-8 form, too.  This won't be always true for all uses
		 * of the include buffer, but it's a start.  - kw
		 */
		char *puni = context->active_include + context->include_index;

		c = *puni;
		clong = UCGetUniFromUtf8String(&puni);
		if (clong < 256 && clong >= 0) {
		    c = ((char) (clong & 0xff));
		}
		saved_char_in = '\0';
		context->include_index = puni - context->active_include + 1;
		goto top1;
	    } else {
		/*
		 * Otherwise assume no UTF-8 - do charset-naive processing and
		 * hope for the best.  - kw
		 */
		c = context->active_include[context->include_index];
		context->include_index++;
		goto top;
	    }
	}
    }

    /*
     * Check whether an external function has added anything to the csi buffer. 
     * - FM
     */
    if (context->csi != NULL) {
	if (context->csi[context->csi_index] == '\0') {
	    FREE(context->csi);
	    context->csi_index = 0;
	} else {
	    c = context->csi[context->csi_index];
	    context->csi_index++;
	    goto top;
	}
    }
}				/* SGML_character */

static void SGML_string(HTStream *context, const char *str)
{
    const char *p;

    for (p = str; *p; p++)
	SGML_character(context, *p);
}

static void SGML_write(HTStream *context, const char *str,
		       int l)
{
    const char *p;
    const char *e = str + l;

    for (p = str; p < e; p++)
	SGML_character(context, *p);
}

/*_______________________________________________________________________
*/

/*	Structured Object Class
 *	-----------------------
 */
const HTStreamClass SGMLParser =
{
    "SGMLParser",
    SGML_free,
    SGML_abort,
    SGML_character,
    SGML_string,
    SGML_write,
};

/*	Create SGML Engine
 *	------------------
 *
 * On entry,
 *	dtd		represents the DTD, along with
 *	actions		is the sink for the data as a set of routines.
 *
 */

HTStream *SGML_new(const SGML_dtd * dtd,
		   HTParentAnchor *anchor,
		   HTStructured * target)
{
    int i;
    HTStream *context = (HTStream *) malloc(sizeof(*context));

    if (!context)
	outofmem(__FILE__, "SGML_begin");

    context->isa = &SGMLParser;
    context->string = HTChunkCreate(128);	/* Grow by this much */
    context->leading_spaces = 0;
    context->trailing_spaces = 0;
    context->dtd = dtd;
    context->target = target;
    context->actions = (const HTStructuredClass *) (((HTStream *) target)->isa);
    /* Ugh: no OO */
    context->unknown_tag = &HTTag_unrecognized;
    context->current_tag = context->slashedtag = NULL;
    context->state = S_text;
    context->kanji_buf = '\0';
    context->element_stack = 0;	/* empty */
    context->inSELECT = FALSE;
    context->no_lynx_specialcodes = NO;		/* special codes normally generated */
#ifdef CALLERDATA
    context->callerData = (void *) callerData;
#endif /* CALLERDATA */
    for (i = 0; i < MAX_ATTRIBUTES; i++)
	context->value[i] = 0;

    context->lead_exclamation = FALSE;
    context->first_dash = FALSE;
    context->end_comment = FALSE;
    context->doctype_bracket = FALSE;
    context->first_bracket = FALSE;
    context->second_bracket = FALSE;
    context->isHex = FALSE;

    context->node_anchor = anchor;	/* Could be NULL? */
    context->utf_count = 0;
    context->utf_char = 0;
    context->utf_buf[0] = context->utf_buf[6] = '\0';
    context->utf_buf_p = context->utf_buf;
    UCTransParams_clear(&context->T);
    context->inUCLYhndl = HTAnchor_getUCLYhndl(anchor,
					       UCT_STAGE_PARSER);
    if (context->inUCLYhndl < 0) {
	HTAnchor_copyUCInfoStage(anchor,
				 UCT_STAGE_PARSER,
				 UCT_STAGE_MIME,
				 -1);
	context->inUCLYhndl = HTAnchor_getUCLYhndl(anchor,
						   UCT_STAGE_PARSER);
    }
#ifdef CAN_SWITCH_DISPLAY_CHARSET	/* Allow a switch to a more suitable display charset */
    else if (anchor->UCStages
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl >= 0
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl != current_char_set) {
	int o = anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl;

	anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl = -1;	/* Force reset */
	HTAnchor_resetUCInfoStage(anchor, o, UCT_STAGE_PARSER,
	/* Preserve change this: */
				  anchor->UCStages->s[UCT_STAGE_PARSER].lock);
    }
#endif

    context->inUCI = HTAnchor_getUCInfoStage(anchor,
					     UCT_STAGE_PARSER);
    set_chartrans_handling(context, anchor, -1);

    context->recover = NULL;
    context->recover_index = 0;
    context->include = NULL;
    context->active_include = NULL;
    context->include_index = 0;
    context->url = NULL;
    context->csi = NULL;
    context->csi_index = 0;

#ifdef USE_PRETTYSRC
    if (psrc_view) {
	psrc_view = FALSE;
	mark_htext_as_source = TRUE;
	SGML_string(context,
		    "<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
	psrc_view = TRUE;
	psrc_convert_string = FALSE;
	sgml_in_psrc_was_initialized = TRUE;
	context->seen_nonwhite_in_junk_tag = FALSE;
    }
#endif

    return context;
}

/*		Asian character conversion functions
 *		====================================
 *
 *	Added 24-Mar-96 by FM, based on:
 *
 ////////////////////////////////////////////////////////////////////////
Copyright (c) 1993 Electrotechnical Laboratory (ETL)

Permission to use, copy, modify, and distribute this material
for any purpose and without fee is hereby granted, provided
that the above copyright notice and this permission notice
appear in all copies, and that the name of ETL not be
used in advertising or publicity pertaining to this
material without the specific, prior written permission
of an authorized representative of ETL.
ETL MAKES NO REPRESENTATIONS ABOUT THE ACCURACY OR SUITABILITY
OF THIS MATERIAL FOR ANY PURPOSE.  IT IS PROVIDED "AS IS",
WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.
/////////////////////////////////////////////////////////////////////////
Content-Type:	program/C; charset=US-ASCII
Program:	SJIS.c
Author:		Yutaka Sato <ysato@@etl.go.jp>
Description:
History:
	930923	extracted from codeconv.c of cosmos
///////////////////////////////////////////////////////////////////////
*/

static int TREAT_SJIS = 1;

void JISx0201TO0208_EUC(unsigned char IHI,
			unsigned char ILO,
			unsigned char *OHI,
			unsigned char *OLO)
{
    static const char *table[] =
    {
	"\241\243",		/* A1,A3 */
	"\241\326",		/* A1,D6 */
	"\241\327",		/* A1,D7 */
	"\241\242",		/* A1,A2 */
	"\241\246",		/* A1,A6 */
	"\245\362",		/* A5,F2 */
	"\245\241",		/* A5,A1 */
	"\245\243",		/* A5,A3 */
	"\245\245",		/* A5,A5 */
	"\245\247",		/* A5,A7 */
	"\245\251",		/* A5,A9 */
	"\245\343",		/* A5,E3 */
	"\245\345",		/* A5,E5 */
	"\245\347",		/* A5,E7 */
	"\245\303",		/* A5,C3 */
	"\241\274",		/* A1,BC */
	"\245\242",		/* A5,A2 */
	"\245\244",		/* A5,A4 */
	"\245\246",		/* A5,A6 */
	"\245\250",		/* A5,A8 */
	"\245\252",		/* A5,AA */
	"\245\253",		/* A5,AB */
	"\245\255",		/* A5,AD */
	"\245\257",		/* A5,AF */
	"\245\261",		/* A5,B1 */
	"\245\263",		/* A5,B3 */
	"\245\265",		/* A5,B5 */
	"\245\267",		/* A5,B7 */
	"\245\271",		/* A5,B9 */
	"\245\273",		/* A5,BB */
	"\245\275",		/* A5,BD */
	"\245\277",		/* A5,BF */
	"\245\301",		/* A5,C1 */
	"\245\304",		/* A5,C4 */
	"\245\306",		/* A5,C6 */
	"\245\310",		/* A5,C8 */
	"\245\312",		/* A5,CA */
	"\245\313",		/* A5,CB */
	"\245\314",		/* A5,CC */
	"\245\315",		/* A5,CD */
	"\245\316",		/* A5,CE */
	"\245\317",		/* A5,CF */
	"\245\322",		/* A5,D2 */
	"\245\325",		/* A5,D5 */
	"\245\330",		/* A5,D8 */
	"\245\333",		/* A5,DB */
	"\245\336",		/* A5,DE */
	"\245\337",		/* A5,DF */
	"\245\340",		/* A5,E0 */
	"\245\341",		/* A5,E1 */
	"\245\342",		/* A5,E2 */
	"\245\344",		/* A5,E4 */
	"\245\346",		/* A5,E6 */
	"\245\350",		/* A5,E8 */
	"\245\351",		/* A5,E9 */
	"\245\352",		/* A5,EA */
	"\245\353",		/* A5,EB */
	"\245\354",		/* A5,EC */
	"\245\355",		/* A5,ED */
	"\245\357",		/* A5,EF */
	"\245\363",		/* A5,F3 */
	"\241\253",		/* A1,AB */
	"\241\254"		/* A1,AC */
    };

    if ((IHI == 0x8E) && (ILO >= 0xA1) && (ILO <= 0xDF)) {
	*OHI = table[ILO - 0xA1][0];
	*OLO = table[ILO - 0xA1][1];
    } else {
	*OHI = IHI;
	*OLO = ILO;
    }
}

static int IS_SJIS_STR(const unsigned char *str)
{
    const unsigned char *s;
    unsigned char ch;
    int is_sjis = 0;

    s = str;
    while ((ch = *s++) != '\0') {
	if (ch & 0x80)
	    if (IS_SJIS(ch, *s, is_sjis))
		return 1;
    }
    return 0;
}

unsigned char *SJIS_TO_JIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *JCODE)
{
    HI -= UCH((HI <= 0x9F) ? 0x71 : 0xB1);
    HI = UCH((HI << 1) + 1);
    if (0x7F < LO)
	LO--;
    if (0x9E <= LO) {
	LO -= UCH(0x7D);
	HI++;
    } else {
	LO -= UCH(0x1F);
    }
    JCODE[0] = HI;
    JCODE[1] = LO;
    return JCODE;
}

unsigned char *JIS_TO_SJIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *SJCODE)
{
    if (HI & 1)
	LO += UCH(0x1F);
    else
	LO += UCH(0x7D);
    if (0x7F <= LO)
	LO++;

    HI = UCH(((HI - 0x21) >> 1) + 0x81);
    if (0x9F < HI)
	HI += UCH(0x40);
    SJCODE[0] = HI;
    SJCODE[1] = LO;
    return SJCODE;
}

unsigned char *EUC_TO_SJIS1(unsigned char HI,
			    unsigned char LO,
			    register unsigned char *SJCODE)
{
    if (HI == 0x8E)
	JISx0201TO0208_EUC(HI, LO, &HI, &LO);
    JIS_TO_SJIS1(UCH(HI & 0x7F), UCH(LO & 0x7F), SJCODE);
    return SJCODE;
}

void JISx0201TO0208_SJIS(register unsigned char I,
			 register unsigned char *OHI,
			 register unsigned char *OLO)
{
    unsigned char SJCODE[2];

    JISx0201TO0208_EUC(0x8E, I, OHI, OLO);
    JIS_TO_SJIS1(UCH(*OHI & 0x7F), UCH(*OLO & 0x7F), SJCODE);
    *OHI = SJCODE[0];
    *OLO = SJCODE[1];
}

unsigned char *SJIS_TO_EUC1(unsigned char HI,
			    unsigned char LO,
			    unsigned char *data)
{
    SJIS_TO_JIS1(HI, LO, data);
    data[0] |= 0x80;
    data[1] |= 0x80;
    return data;
}

unsigned char *SJIS_TO_EUC(unsigned char *src,
			   unsigned char *dst)
{
    register unsigned char hi, lo, *sp, *dp;
    register int in_sjis = 0;

    in_sjis = IS_SJIS_STR(src);
    for (sp = src, dp = dst; (hi = sp[0]) != '\0';) {
	lo = sp[1];
	if (TREAT_SJIS && IS_SJIS(hi, lo, in_sjis)) {
	    SJIS_TO_JIS1(hi, lo, dp);
	    dp[0] |= 0x80;
	    dp[1] |= 0x80;
	    dp += 2;
	    sp += 2;
	} else
	    *dp++ = *sp++;
    }
    *dp = 0;
    return dst;
}

unsigned char *EUC_TO_SJIS(unsigned char *src,
			   unsigned char *dst)
{
    register unsigned char *sp, *dp;

    for (sp = src, dp = dst; *sp;) {
	if (*sp & 0x80) {
	    if (sp[1] && (sp[1] & 0x80)) {
		JIS_TO_SJIS1(UCH(sp[0] & 0x7F), UCH(sp[1] & 0x7F), dp);
		dp += 2;
		sp += 2;
	    } else {
		sp++;
	    }
	} else {
	    *dp++ = *sp++;
	}
    }
    *dp = 0;
    return dst;
}

#define Strcpy(a,b)	(strcpy((char*)a,(const char*)b),&a[strlen((const char*)a)])

unsigned char *EUC_TO_JIS(unsigned char *src,
			  unsigned char *dst,
			  const char *toK,
			  const char *toA)
{
    register unsigned char kana_mode = 0;
    register unsigned char cch;
    register unsigned char *sp = src;
    register unsigned char *dp = dst;
    int is_JIS = 0;

    while ((cch = *sp++) != '\0') {
	if (cch & 0x80) {
	    if (!IS_EUC(cch, *sp)) {
		if (cch == 0xA0 && is_JIS)	/* ignore NBSP */
		    continue;
		is_JIS++;
		*dp++ = cch;
		continue;
	    }
	    if (!kana_mode) {
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toK);
	    }
	    if (*sp & 0x80) {
		*dp++ = UCH(cch & ~0x80);
		*dp++ = UCH(*sp++ & ~0x80);
	    }
	} else {
	    if (kana_mode) {
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toA);
	    }
	    *dp++ = cch;
	}
    }
    if (kana_mode)
	dp = Strcpy(dp, toA);

    if (dp)
	*dp = 0;
    return dst;
}

#define	IS_JIS7(c1,c2)	(0x20<(c1)&&(c1)<0x7F && 0x20<(c2)&&(c2)<0x7F)
#define SO		('N'-0x40)
#define SI		('O'-0x40)

static int repair_JIS = 0;

static const unsigned char *repairJIStoEUC(const unsigned char *src,
					   unsigned char **dstp)
{
    const unsigned char *s;
    unsigned char *d, ch1, ch2;

    d = *dstp;
    s = src;
    while ((ch1 = s[0]) && (ch2 = s[1])) {
	s += 2;
	if (ch1 == '(')
	    if (ch2 == 'B' || ch2 == 'J') {
		*dstp = d;
		return s;
	    }
	if (!IS_JIS7(ch1, ch2))
	    return 0;

	*d++ = UCH(0x80 | ch1);
	*d++ = UCH(0x80 | ch2);
    }
    return 0;
}

unsigned char *TO_EUC(const unsigned char *jis,
		      unsigned char *euc)
{
    register const unsigned char *s;
    register unsigned char c, jis_stat;
    unsigned char *d;
    register int to1B, to2B;
    register int in_sjis = 0;
    static int nje;
    int n8bits;
    int is_JIS;

    nje++;
    n8bits = 0;
    s = jis;
    d = euc;
    jis_stat = 0;
    to2B = TO_2BCODE;
    to1B = TO_1BCODE;
    in_sjis = IS_SJIS_STR(jis);
    is_JIS = 0;

    while ((c = *s++) != '\0') {
	if (c == 0x80)
	    continue;		/* ignore it */
	if (c == 0xA0 && is_JIS)
	    continue;		/* ignore Non-breaking space */

	if (c == to2B && jis_stat == 0 && repair_JIS) {
	    if (*s == 'B' || *s == '@@') {
		const unsigned char *ts;

		if ((ts = repairJIStoEUC(s + 1, &d)) != NULL) {
		    s = ts;
		    continue;
		}
	    }
	}
	if (c == ESC) {
	    if (*s == to2B) {
		if ((s[1] == 'B') || (s[1] == '@@')) {
		    jis_stat = 0x80;
		    s += 2;
		    is_JIS++;
		    continue;
		}
		jis_stat = 0;
	    } else if (*s == to1B) {
		jis_stat = 0;
		if ((s[1] == 'B') || (s[1] == 'J') || (s[1] == 'H')) {
		    s += 2;
		    continue;
		}
	    } else if (*s == ',') {	/* MULE */
		jis_stat = 0;
	    }
	}
	if (c & 0x80)
	    n8bits++;

	if (IS_SJIS(c, *s, in_sjis)) {
	    SJIS_TO_EUC1(c, *s, d);
	    d += 2;
	    s++;
	    is_JIS++;
	} else if (jis_stat) {
	    if (c <= 0x20 || 0x7F <= c) {
		*d++ = c;
		if (c == '\n')
		    jis_stat = 0;
	    } else {
		if (IS_JIS7(c, *s)) {
		    *d++ = jis_stat | c;
		    *d++ = jis_stat | *s++;
		} else
		    *d++ = c;
	    }
	} else {
	    if (n8bits == 0 && (c == SI || c == SO)) {
	    } else {
		*d++ = c;
	    }
	}
    }
    *d = 0;
    return euc;
}

#define non94(ch) ((ch) <= 0x20 || (ch) == 0x7F)

static int is_EUC_JP(unsigned char *euc)
{
    unsigned char *cp;
    int ch1, ch2;

    for (cp = euc; (ch1 = *cp) != '\0'; cp++) {
	if (ch1 & 0x80) {
	    ch2 = cp[1] & 0xFF;
	    if ((ch2 & 0x80) == 0) {
		/* sv1log("NOT_EUC1[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    if (non94(ch1 & 0x7F) || non94(ch2 & 0x7F)) {
		/* sv1log("NOT_EUC2[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    cp++;
	}
    }
    return 1;
}

void TO_SJIS(const unsigned char *arg,
	     unsigned char *sjis)
{
    unsigned char *euc;

    euc = typeMallocn(unsigned char, strlen((const char *) arg) + 1);

#ifdef CJK_EX
    if (!euc)
	outofmem(__FILE__, "TO_SJIS");
#endif
    TO_EUC(arg, euc);
    if (is_EUC_JP(euc))
	EUC_TO_SJIS(euc, sjis);
    else
	strcpy((char *) sjis, (const char *) arg);
    free(euc);
}

void TO_JIS(const unsigned char *arg,
	    unsigned char *jis)
{
    unsigned char *euc;

    if (arg[0] == 0) {
	jis[0] = 0;
	return;
    }
    euc = typeMallocn(unsigned char, strlen((const char *)arg) + 1);
#ifdef CJK_EX
    if (!euc)
	outofmem(__FILE__, "TO_JIS");
#endif
    TO_EUC(arg, euc);
    is_EUC_JP(euc);
    EUC_TO_JIS(euc, jis, TO_KANJI, TO_ASCII);

    free(euc);
}
@


1.5
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d2 9
a10 9
**			========================
**
**	This module implements an HTStream object.  To parse an
**	SGML file, create this object which is a parser.  The object
**	is (currently) created by being passed a DTD structure,
**	and a target HTStructured object at which to throw the parsed stuff.
**
**	 6 Feb 93  Binary searches used. Interface modified.
*/
d29 1
d32 1
a32 1
#include <LYCharVals.h>	 /* S/390 -- gil -- 0635 */
d48 3
a50 2
char* entity_string; /* this is used for printing entity name.
    Unconditionally added since redundant assigments don't hurt much*/
d52 2
a53 3
PRIVATE void fake_put_character ARGS2(
		    void*, p GCC_UNUSED,
		    char,  c GCC_UNUSED)
a81 18
#if 0
#define orig_HTChunkPutc HTChunkPutc
#undef HTChunkPutc

#define HTChunkPutc(ch,x) \
    { \
    if (ch->size < ch->allocated) \
	ch->data[ch->size++] = x; \
    else \
	orig_HTChunkPutc(ch,x); \
    }

#undef HTChunkTerminate

#define HTChunkTerminate(ch) \
    HTChunkPutc(ch, (char)0)
#endif /* */

a88 1

d92 5
a96 5
PUBLIC HTCJKlang HTCJK = NOCJK;		/* CJK enum value.		*/
PUBLIC BOOL HTPassEightBitRaw = FALSE;	/* Pass 161-172,174-255 raw.	*/
PUBLIC BOOL HTPassEightBitNum = FALSE;	/* Pass ^ numeric entities raw. */
PUBLIC BOOL HTPassHighCtrlRaw = FALSE;	/* Pass 127-160,173,&#127; raw. */
PUBLIC BOOL HTPassHighCtrlNum = FALSE;	/* Pass &#128;-&#159; raw.	*/
d99 4
a102 4
**
**	This is passed with each call to make the parser reentrant
**
*/
a105 1

d107 4
a110 4
**		-------------
**	This allows us to return down the stack reselecting styles.
**	As we return, attribute values will be garbage in general.
*/
d113 2
a114 2
	HTElement *	next;	/* Previously nested element or 0 */
	HTTag*		tag;	/* The tag at this level  */
d164 2
a165 2
**	-------------------------------
*/
d168 1
a168 1
    CONST HTStreamClass *	isa;		/* inherited from HTStream */
d170 15
a184 15
    CONST SGML_dtd		*dtd;
    CONST HTStructuredClass	*actions;	/* target class	 */
    HTStructured		*target;	/* target object */

    HTTag			*current_tag;
    HTTag			*slashedtag;
    CONST HTTag			*unknown_tag;
    BOOL			inSELECT;
    BOOL			no_lynx_specialcodes;
    int				current_attribute_number;
    HTChunk			*string;
    int				leading_spaces;
    int				trailing_spaces;
    HTElement			*element_stack;
    sgml_state			state;
d187 2
a188 2
    void *			callerData;
#endif /* CALLERDATA */
d190 1
a190 1
    char * value[MAX_ATTRIBUTES];	/* NULL, or strings alloc'd with StrAllocCopy_extra() */
d192 32
a223 32
    BOOL			lead_exclamation;
    BOOL			first_dash;
    BOOL			end_comment;
    BOOL			doctype_bracket;
    BOOL			first_bracket;
    BOOL			second_bracket;
    BOOL			isHex;

    HTParentAnchor *		node_anchor;
    LYUCcharset *		inUCI;		/* pointer to anchor UCInfo */
    int				inUCLYhndl;	/* charset we are fed	    */
    LYUCcharset *		outUCI;		/* anchor UCInfo for target */
    int				outUCLYhndl;	/* charset for target	    */
    char			utf_count;
    UCode_t			utf_char;
    char			utf_buf[8];
    char *			utf_buf_p;
    UCTransParams		T;
    int				current_tag_charset; /* charset to pass attributes */

    char *			recover;
    int				recover_index;
    char *			include;
    char *			active_include;
    int				include_index;
    char *			url;
    char *			csi;
    int				csi_index;
#ifdef USE_PRETTYSRC
    BOOL			cur_attr_is_href;
    BOOL			cur_attr_is_name;
    BOOL			seen_nonwhite_in_junk_tag;
d228 1
a228 1
PRIVATE char *state_name ARGS1(sgml_state, n)
d230 2
a231 1
    char *result = "?";
d277 2
d288 1
a288 1
PRIVATE HTElement* pool_alloc NOARGS
d292 1
a292 1
	return (HTElement*) malloc(sizeof(HTElement));
d296 1
a296 1
PRIVATE void pool_free ARGS1(HTElement*, e)
d306 1
a306 4
PRIVATE void HTMLSRC_apply_markup ARGS3(
	    HTStream *,	      context,
	    HTlexeme,	      lexeme,
	    BOOL,	      start)
d308 1
a308 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d319 1
a319 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
d321 6
a326 7
	    (*context->actions->start_element)(
		context->target,
		ts->element,
		ts->present,
		(CONST char **)ts->value,
		context->current_tag_charset,
		(char **)&context->include);
d328 3
a330 4
	    (*context->actions->end_element)(
		context->target,
		ts->element,
		(char **)&context->include);
d335 2
a336 7
#if ANSI_PREPRO
#  define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_##x,START)
#  define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_##x,STOP)
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_/**/x,START)
#  define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_/**/x,STOP)
#endif
d342 2
a343 4
PRIVATE void set_chartrans_handling ARGS3(
	HTStream *,		context,
	HTParentAnchor *,	anchor,
	int,			chndl)
d347 3
a349 4
	**  Nothing was set for the parser in earlier stages,
	**  so the HTML parser's UCLYhndl should still be its
	**  default. - FM
	*/
d353 2
a354 2
	    **	That wasn't set either, so seek the HText default. - FM
	    */
d358 3
a360 3
	    **	That wasn't set either, so assume the current display
	    **	character set. - FM
	    */
d363 4
a366 4
	**  Try to set the HText and HTML stages' chartrans info
	**  with the default lock level (will not be changed if
	**  it was set previously with a higher lock level). - FM
	*/
d374 2
a375 2
	**  Get the chartrans info for output to the HTML parser. - FM
	*/
d382 2
a383 2
    **	Set the in->out transformation parameters. - FM
    */
d388 6
a393 7
    **	This is intended for passing the SGML parser's input
    **	charset as an argument in each call to the HTML
    **	parser's start tag function, but it would be better
    **	to call a Lynx_HTML_parser function to set an element
    **	in its HTStructured object, itself, if this were
    **	needed. - FM
    */
d396 3
a398 1
    } else if (context->T.transp) {
d413 1
a413 2
PRIVATE void change_chartrans_handling ARGS1(
	HTStream *,		context)
d417 1
d421 1
a421 1
	 *  Something changed. but ignore if a META wants an unknown charset.
d423 3
a425 2
	LYUCcharset * new_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
							UCT_STAGE_PARSER);
d427 4
a430 6
	    LYUCcharset * next_UCI = HTAnchor_getUCInfoStage(
				    context->node_anchor, UCT_STAGE_STRUCTURED
							    );
	    int next_LYhndl = HTAnchor_getUCLYhndl(
				    context->node_anchor, UCT_STAGE_STRUCTURED
						  );
d447 3
a449 3
**	----------------
*/
/* PUBLIC CONST char * SGML_default = "";   ?? */
d451 1
a451 3
PRIVATE void handle_attribute_name ARGS2(
	HTStream *,	context,
	CONST char *,	s)
d453 2
a454 2
    HTTag * tag = context->current_tag;
    attr * attributes = tag->attributes;
d464 2
a465 2
    **	Ignore unknown tag. - KW
    */
d469 1
a469 1
	    context->current_attribute_number = 1; /* anything !=INVALID */
d475 2
a476 2
    **	Binary search for attribute name.
    */
d479 2
a480 2
	 diff < 0 ? (low = i+1) : (high = i)) {
	i = (low + (high-low)/2);
d482 1
a482 1
	if (diff == 0) {		/* success: found it */
d491 2
a492 2
	    context->present[i] = YES;
	    Clear_extra(context->value[i]);
d495 1
a495 1
	    current_is_class = IS_C(attributes[i]);
d497 1
a497 1
	    current_is_class = (!strcasecomp("class", s));
d499 1
a499 1
	    CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
d503 3
a505 3
	} /* if */

    } /* for */
d508 1
a508 1
		s, context->current_tag->name));
a511 1

d513 3
a515 5
**	----------------------
*/
PRIVATE void handle_attribute_value ARGS2(
	HTStream *,	context,
	CONST char *,	s)
d520 2
a521 3
	if (current_is_class)
	{
	    strncpy (class_string, s, TEMPSTRINGSIZE);
d523 1
a523 3
	}
	else
	{
d530 1
a530 1
    context->current_attribute_number = INVALID; /* can't have two assignments! */
a532 1

d534 10
a543 12
**  Translate some Unicodes to Lynx special codes and output them.
**  Special codes - ones those output depend on parsing.
**
**  Additional issue, like handling bidirectional text if necessary
**  may be called from here:  zwnj (8204), zwj (8205), lrm (8206), rlm (8207)
**  - currently they are ignored in SGML.c and LYCharUtils.c
**  but also in UCdomap.c because they are non printable...
**
*/
PRIVATE BOOL put_special_unicodes ARGS2(
	HTStream *,	context,
	UCode_t,	code)
d548 2
a549 2
	**  We were asked by a "DTD" flag to not generate lynx specials. - kw
	*/
d553 1
a553 1
    if (code == CH_NBSP) {  /* S/390 -- gil -- 0657 */
d555 2
a556 2
	**  Use Lynx special character for nbsp.
	*/
d560 2
a561 2
	PUTC(HT_NON_BREAK_SPACE);
    } else  if (code == CH_SHY) {
d563 2
a564 2
	**  Use Lynx special character for shy.
	*/
d568 1
a568 1
	PUTC(LY_SOFT_HYPHEN);
d571 12
a582 12
	**  Use Lynx special character for ensp or thinsp.
	**
	**  Originally, Lynx use space '32' as word delimiter and omits this
	**  space at end of line if word is wrapped to the next line.  There
	**  are several other spaces in the Unicode repertoire and we should
	**  teach Lynx to understand them, not only as regular characters but
	**  in the context of line wrapping.  Unfortunately, if we use
	**  HT_EN_SPACE we override the chartrans tables for those spaces
	**  with a single '32' for all (but do line wrapping more fancy).
	**
	**  We may treat emsp as one or two ensp (below).
	*/
d586 1
a586 1
	PUTC(HT_EN_SPACE);
d589 2
a590 2
	**  Use Lynx special character for emsp.
	*/
d594 2
a595 2
	/* PUTC(HT_EN_SPACE);  let's stay with a single space :) */
	PUTC(HT_EN_SPACE);
d601 2
a602 2
	**  Return NO if nothing done.
	*/
d606 2
a607 2
    **	We have handled it.
    */
d612 1
a612 1
PRIVATE void put_pretty_entity ARGS2(HTStream *, context, int, term)
d618 1
a618 1
	PUTC((char)term);
d622 1
a622 1
PRIVATE void put_pretty_number ARGS1(HTStream *, context)
d625 1
a625 1
    PUTS( (context->isHex ? "&#x" : "&#") );
d633 15
a647 15
**	-------------
**
** On entry,
**	s	contains the entity name zero terminated
** Bugs:
**	If the entity name is unknown, the terminator is treated as
**	a printable non-special character in all cases, even if it is '<'
** Bug-fix:
**	Modified SGML_character() so we only come here with terminator
**	as '\0' and check a FoundEntity flag. -- Foteos Macrides
**
** Modified more (for use with Lynx character translation code):
*/
PRIVATE char replace_buf [64];	      /* buffer for replacement strings */
PRIVATE BOOL FoundEntity = FALSE;
d649 1
a649 3
PRIVATE void handle_entity ARGS2(
	HTStream *,	context,
	char,		term)
d653 1
a653 1
    CONST char *s = context->string->data;
d656 2
a657 2
    **	Handle all entities normally. - FM
    */
d661 3
a663 3
	**  We got a Unicode value for the entity name.
	**  Check for special Unicodes. - FM
	*/
d674 2
a675 2
	**  Seek a translation from the chartrans tables.
	*/
d686 1
a686 1
	    PUTC(FROMASCII((char)uck));
d692 3
a694 3
		   /*
		   **  Not found; look for replacement string.
		   */
d702 1
a702 1
	    PUTS(replace_buf);
d707 2
a708 2
	**  If we're displaying UTF-8, try that now. - FM
	*/
d715 5
a719 3
	if (context->T.output_utf8 && (psrc_view ?
	      (UCPutUtf8_charstring((HTStream *)context->target,
	      (putc_func_t*)(fake_put_character), code)): PUTUTF8(code) ) ) {
d730 2
a731 2
	**  If it's safe ASCII, use it. - FM
	*/
d739 1
a739 1
	    PUTC(FROMASCII((char)code));
d745 3
a747 4
	**  Ignore zwnj (8204) and zwj (8205), if we get to here.
	**  Note that zwnj may have been handled as <WBR>
	**  by the calling function. - FM
	*/
d760 2
a761 2
	**  Ignore lrm (8206), and rln (8207), if we get to here. - FM
	*/
d776 2
a777 2
    **	If entity string not found, display as text.
    */
d782 1
a782 1
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long)code, uck)); /* S/390 -- gil -- 0695 */
a792 1

d794 3
a796 4
**	--------------
*/
PRIVATE void handle_comment ARGS1(
	HTStream *,		context)
d798 1
a798 1
    CONST char *s = context->string->data;
d804 2
a805 2
	LYCheckForCSI(context->node_anchor, (char **)&context->url) == TRUE) {
	LYDoCSI(context->url, s, (char **)&context->csi);
a812 1

d814 3
a816 4
**	-----------------
*/
PRIVATE void handle_identifier ARGS1(
	HTStream *,		context)
d818 1
a818 1
    CONST char *s = context->string->data;
a824 1

d826 3
a828 4
**	--------------
*/
PRIVATE void handle_doctype ARGS1(
	HTStream *,		context)
d830 1
a830 1
    CONST char *s = context->string->data;
d837 2
a838 4
PRIVATE void SGML_write PARAMS((
	HTStream *		me,
	CONST char *		s,
	int			l));
d841 3
a843 4
**	-------------
*/
PRIVATE void handle_marked ARGS1(
	HTStream *,		context)
d845 1
a845 1
    CONST char *s = context->string->data;
d857 3
a859 3
	(*context->actions->_write)(context->target,
		   context->string->data + 8,
		   context->string->size - 11);
a864 1

d866 3
a868 4
**	--------------
*/
PRIVATE void handle_sgmlent ARGS1(
	HTStream *,		context)
d870 1
a870 1
    CONST char *s = context->string->data;
a876 1

d878 3
a880 4
**	--------------
*/
PRIVATE void handle_sgmlele ARGS1(
	HTStream *,		context)
d882 1
a882 1
    CONST char *s = context->string->data;
a888 1

d890 3
a892 4
**	--------------
*/
PRIVATE void handle_sgmlatt ARGS1(
	HTStream *,		context)
d894 1
a894 1
    CONST char *s = context->string->data;
d902 2
a903 3
 *  Convenience macros - tags (elements) are identified sometimes
 *  by an int or enum value ('TAGNUM'), sometimes
 *  by a pointer to HTTag ('TAGP'). - kw
d905 1
a905 1
#define TAGNUM_OF_TAGP(t) (t - context->dtd->tags)
d909 3
a911 3
 *  The following implement special knowledge about OBJECT.
 *  As long as HTML_OBJECT is the only tag for which an alternative
 *  variant exist, they can be simple macros. - kw
d920 1
a920 1
#define NORMAL_TAGNUM(e) ((e >= HTML_ELEMENTS) ? HTML_OBJECT : e)
a928 1

d931 1
a931 4
PRIVATE BOOL element_valid_within ARGS3(
    HTTag *,	new_tag,
    HTTag *,	stacked_tag,
    BOOL,	direct)
d934 1
d941 1
a941 1
		(Tgc_same & usecontained));
d944 1
a944 1
		(stacked_tag->tagclass & usecontained));
d948 1
a948 1
    close_NO	= 0,
d953 1
a953 3
PRIVATE canclose_t can_close ARGS2(
    HTTag *,	new_tag,
    HTTag *,	stacked_tag)
d966 1
a966 2
PRIVATE void do_close_stacked ARGS1(
    HTStream *, context)
d968 1
a968 1
    HTElement * stacked = context->element_stack;
d970 1
d978 1
a978 1
    if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
d980 3
a982 4
    (*context->actions->end_element)(
	context->target,
	e,
	(char **)&context->include);
d989 1
a989 3
PRIVATE int is_on_stack ARGS2(
	HTStream *,	context,
	HTTag *,	old_tag)
d991 1
a991 1
   HTElement * stacked = context->element_stack;
d993 1
d1004 3
a1006 5
**	-----------
*/
PRIVATE void end_element ARGS2(
	HTStream *,	context,
	HTTag *,	old_tag)
d1026 5
a1030 3
			    context->element_stack->tag->name,
			    canclose_check == close_valid ? "supplied," : "***forced by",
			    old_tag->name));
d1039 4
a1042 4
			context->element_stack ?
			context->element_stack->tag->name : "none",
			old_tag->name,
			old_tag->name));
d1046 5
a1050 4
	    CTRACE((tfp, "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
			old_tag->name,
			context->element_stack->tag->name,
			old_tag->name));
d1059 2
a1060 3
    **	If we are in a SELECT block, ignore anything
    **	but a SELECT end tag. - FM
    */
d1064 2
a1065 2
	    **	Turn off the inSELECT flag and fall through. - FM
	    */
d1069 2
a1070 2
	    **	Ignore the end tag. - FM
	    */
d1072 1
a1072 1
			old_tag->name));
d1077 2
a1078 2
    **	Handle the end tag. - FM
    */
d1082 1
a1082 1
		    old_tag->name));
d1086 1
a1086 1
    while (context->element_stack) /* Loop is error path only */
d1088 1
a1088 1
    if (context->element_stack) /* Substitute and remove one stack element */
d1093 2
a1094 2
	HTElement * N = context->element_stack;
	HTTag * t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;
d1096 10
a1105 8
	if (old_tag != t) {		/* Mismatch: syntax error */
	    if (context->element_stack->next) { /* This is not the last level */
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			     old_tag->name, t->name, t->name));
	    } else {			/* last level */
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			    old_tag->name, t->name, old_tag->name));
		return;			/* Ignore */
d1110 1
a1110 1
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", t, e));
d1112 1
a1112 1
	if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
d1114 2
a1115 2
	    status = (*context->actions->end_element)(context->target,
						e, (char **)&context->include);
d1118 6
a1123 7
	    (*context->actions->start_element)(
		context->target,
		e,
		NULL,
		NULL,
		context->current_tag_charset,
		(char **)&context->include);
d1128 1
a1128 1
	    context->element_stack = N->next;		/* Remove from stack */
d1135 1
a1135 1
	    return;  /* Correct sequence */
d1144 1
a1144 1
		old_tag->name));
a1146 1

d1149 1
a1149 2
PRIVATE void start_element ARGS1(
	HTStream *,	context)
d1152 1
a1152 1
    HTTag * new_tag = context->current_tag;
d1173 5
a1177 3
			    context->element_stack->tag->name,
			    canclose_check == close_valid ? "supplied," : "***forced by",
			    new_tag->name));
d1180 1
a1180 1
		if (canclose_check  == close_error)
d1183 4
a1186 3
		CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
			    context->element_stack->tag->name,
			    new_tag->name));
d1194 2
a1195 2
			context->element_stack->tag->name,
			new_tag->name));
d1199 4
a1202 2
	if (context->element_stack && !extra_action_taken &&
	    canclose_check == close_NO && !valid && (new_tag->flags & Tgf_mafse)) {
d1205 2
a1206 1
	    for (; i< new_tag->number_of_attributes && !has_attributes; i++)
d1209 5
a1213 4
		CTRACE((tfp, "SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
			    context->element_stack->tag->name,
			    new_tag->name,
			    new_tag->name));
d1220 4
a1223 5
	    canclose_check == close_error && !(valid =
					       element_valid_within(
						   new_tag,
						   context->element_stack->tag,
						   direct_container))) {
d1225 2
a1226 2
			context->element_stack->tag->name,
			new_tag->name));
d1234 5
a1238 6
    **	If we are not in a SELECT block, check if this is
    **	a SELECT start tag.  Otherwise (i.e., we are in a
    **	SELECT block) accept only OPTION as valid, terminate
    **	the SELECT block if it is any other form-related
    **	element, and otherwise ignore it. - FM
    */
d1241 3
a1243 3
	**  We are not in a SELECT block, so check if this starts one. - FM
	**  (frequent case!)
	*/
d1247 2
a1248 2
	    **	Set the inSELECT flag and fall through. - FM
	    */
d1253 2
a1254 2
	**  We are in a SELECT block. - FM
	*/
d1257 2
a1258 2
	    **	Ugh, it is not an OPTION. - FM
	    */
d1260 12
a1271 7
		case HTML_INPUT:  case HTML_TEXTAREA: case HTML_SELECT:
		case HTML_BUTTON: case HTML_FIELDSET: case HTML_LABEL:
		case HTML_LEGEND: case HTML_FORM:
		    ok = TRUE;
		    break;
		default:
		    break;
d1273 1
a1273 2
	    if (ok)
	    {
d1275 6
a1280 5
		**  It is another form-related start tag, so terminate
		**  the current SELECT block and fall through. - FM
		*/
		CTRACE((tfp, "SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			    new_tag->name));
d1284 5
a1288 4
		**  Ignore the start tag. - FM
		*/
		CTRACE((tfp, "SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			    new_tag->name));
d1294 2
a1295 2
    **	Handle the start tag. - FM
    */
d1297 6
a1302 7
    status = (*context->actions->start_element)(
	context->target,
	TAGNUM_OF_TAGP(new_tag),
	context->present,
	(CONST char**) context->value,	/* coerce type for think c */
	context->current_tag_charset,
	(char **)&context->include);
d1305 3
a1307 2
    if (new_tag->contents != SGML_EMPTY) {		/* i.e., tag not empty */
	HTElement * N = pool_alloc();
d1315 1
a1315 1
    } else if (e == HTML_META ) {
d1317 2
a1318 2
	**  Check for result of META tag. - KW & FM
	*/
a1322 1

d1324 13
a1336 14
**		------------------------
**
** On entry,
**	dtd	points to dtd structure including valid tag list
**	string	points to name of tag in question
**
** On exit,
**	returns:
**		NULL		tag not found
**		else		address of tag structure in dtd
*/
PUBLIC HTTag * SGMLFindTag ARGS2(
	CONST SGML_dtd*,	dtd,
	CONST char *,		s)
d1339 3
a1341 2
    static HTTag* last[64] = {NULL};  /*optimize using the previous results*/
    HTTag** res = last + (UCH(*s) % 64);     /*pointer arithmetic*/
d1346 4
a1349 4
    for (low = 0, high=dtd->number_of_tags;
	  high > low;
	  diff < 0 ? (low = i+1) : (high = i)) {	/* Binary search */
	i = (low + (high-low)/2);
d1352 1
a1352 1
	if (diff == 0) {		/* success: found it */
d1359 2
a1360 2
	**  Unrecognized, but may be valid. - KW
	*/
d1367 2
a1368 3
**			Public Methods
*/

d1373 1
a1373 2
PRIVATE void SGML_free ARGS1(
	HTStream *,	context)
d1376 2
a1377 2
    HTElement * cur;
    HTTag * t;
d1380 2
a1381 2
    **	Free the buffers. - FM
    */
d1389 2
a1390 2
    **	Wind down stack if any elements are open. - FM
    */
d1397 1
a1397 1
	if (!psrc_view) /* Don't actually call on target if viewing psrc - kw */
d1399 3
a1401 3
	    (*context->actions->end_element)(context->target,
		    NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
		    (char **)&context->include);
d1406 3
a1408 3
    **	Finish off the target. - FM
    */
    (*context->actions->_free)(context->target);
d1411 2
a1412 2
    **	Free the strings and context structure. - FM
    */
d1423 1
a1423 3
PRIVATE void SGML_abort ARGS2(
	HTStream *,	context,
	HTError,	e)
d1426 1
a1426 1
    HTElement * cur;
d1429 3
a1431 3
    **	Abort the target. - FM
    */
    (*context->actions->_abort)(context->target, e);
d1434 2
a1435 2
    **	Free the buffers. - FM
    */
d1443 2
a1444 2
    **	Free stack memory if any elements were left open. - KW
    */
d1452 2
a1453 2
    **	Free the strings and context structure. - FM
    */
a1463 1

d1465 6
a1470 6
**	-----------------------------------
**
**   The callbacks from the SGML parser have an SGML context parameter.
**   These calls allow the caller to associate his own context with a
**   particular SGML context.
*/
d1473 1
a1473 2
PUBLIC void* SGML_callerData ARGS1(
	HTStream *,	context)
d1478 1
a1478 3
PUBLIC void SGML_setCallerData ARGS2(
	HTStream *,	context,
	void*,		data)
d1484 8
a1491 10
PRIVATE void SGML_character ARGS2(
	HTStream *,	context,
	char,		c_in)
{
    CONST SGML_dtd *dtd =	context->dtd;
    HTChunk	*string =	context->string;
    CONST char * EntityName;
    HTTag * testtag = NULL;
    BOOLEAN chk;	/* Helps (?) walk through all the else ifs... */
    UCode_t clong, uck = 0; /* Enough bits for UCS4 ... */
d1493 1
d1496 1
d1503 3
a1505 4
    **	Now some fun with the preprocessor.
    **	Use copies for c and unsign_c == clong, so that
    **	we can revert back to the unchanged c_in. - KW
    */
d1509 1
a1509 1
    clong = UCH(c);	/* a.k.a. unsign_c */
d1513 4
a1516 5
	**  Combine UTF-8 into Unicode.
	**  Incomplete characters silently ignored.
	**  From Linux kernel's console.c. - KW
	*/
	if (TOASCII(UCH(c)) > 127) { /* S/390 -- gil -- 0710 */
d1518 2
a1519 2
	    **	We have an octet from a multibyte character. - FM
	    */
d1527 3
a1529 4
		    **	We have all of the bytes, so terminate
		    **	the buffer and set 'clong' to the UCode_t
		    **	value. - FM
		    */
d1533 1
a1533 1
			c = ((char)(clong & 0xff));
d1538 2
a1539 2
		    **	Wait for more. - KW
		    */
d1544 2
a1545 2
		**  Start handling a new multibyte character. - FM
		*/
d1566 2
a1567 2
		    **	Garbage. - KW
		    */
d1573 2
a1574 2
		**  Wait for more. - KW
		*/
d1579 2
a1580 2
	    **	Got an ASCII char. - KW
	    */
d1584 1
a1584 1
		    /*	goto top;  */
d1586 2
a1587 2
    } /* end of context->T.decode_utf8	S/390 -- gil -- 0726 */

d1590 4
a1593 5
    **	If we have a koi8-r input and do not have
    **	koi8-r as the output, save the raw input
    **	in saved_char_in before we potentially
    **	convert it to Unicode. - FM
    */
d1599 2
a1600 3
    **	If we want the raw input converted
    **	to Unicode, try that now. - FM
    */
d1602 1
a1602 1
	((TOASCII(unsign_c) >= LYlowest_eightbit[context->inUCLYhndl]) ||  /* S/390 -- gil -- 0744 */
d1606 2
a1607 2
	**  Convert the octet to Unicode. - FM
	*/
d1612 1
a1612 1
		c = FROMASCII((char)clong);
d1616 1
a1616 1
    } else if (unsign_c < ' ' && unsign_c != 0 &&  /* S/390 -- gil -- 0768 */
d1619 2
a1620 2
	**  This else if may be too ugly to keep. - KW
	*/
d1627 1
a1627 1
		c = FROMASCII((char)clong);
d1656 2
a1657 2
	} /*  Next line end of ugly stuff for C0. - KW */
    } else {  /* end of context->T.trans_to_uni	 S/390 -- gil -- 0791 */
d1662 4
a1665 4
    **	At this point we have either unsign_c a.k.a. clong in
    **	Unicode (and c in latin1 if clong is in the latin1 range),
    **	or unsign_c and c will have to be passed raw. - KW
    */
d1667 14
a1680 14
**  We jump up to here from below if we have
**  stuff in the recover, insert, or csi buffers
**  to process.	 We zero saved_char_in, in effect
**  as a flag that the octet in not that of the
**  actual call to this function.  This may be OK
**  for now, for the stuff this function adds to
**  its recover buffer, but it might not be for
**  stuff other functions added to the insert or
**  csi buffer, so bear that in mind. - FM
**  Stuff from the recover buffer is now handled
**  as UTF-8 if we can expect that's what it is,
**  and in that case we don't come back up here. - kw
*/
top:
d1683 7
a1689 7
**  We jump to here from above when we don't have
**  UTF-8 input, haven't converted to Unicode, and
**  want clong set to the input octet (unsigned)
**  without zeroing its saved_char_in copy (which
**  is signed). - FM
*/
top0a:
d1693 10
a1702 10
**  We jump to here from above if we have converted
**  the input, or a multibyte sequence across calls,
**  to a Unicode value and loaded it into clong (to
**  which unsign_c has been defined), and from below
**  when we are recycling a character (e.g., because
**  it terminated an entity but is not the standard
**  semi-colon).  The character will already have
**  been put through the Unicode conversions. - FM
*/
top1:
d1704 2
a1705 3
    **	Ignore low ISO 646 7-bit control characters
    **	if HTCJK is not set. - FM
    */
d1707 2
a1708 2
    ** Works for both ASCII and EBCDIC. -- gil
    */	/* S/390 -- gil -- 0811 */
d1715 2
a1716 3
    **	Ignore 127 if we don't have HTPassHighCtrlRaw
    **	or HTCJK set. - FM
    */
d1719 1
a1719 1
    if (TOASCII(c) == 127 &&  /* S/390 -- gil -- 0830 */
d1724 4
a1727 4
    **	Ignore 8-bit control characters 128 - 159 if
    **	neither HTPassHighCtrlRaw nor HTCJK is set. - FM
    */
    if (TOASCII(unsign_c) > 127 && TOASCII(unsign_c) < 160 &&  /* S/390 -- gil -- 0847 */
d1735 6
a1740 2
    if ((HTCJK==JAPANESE) && (context->state==S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))) {
d1744 1
d1748 1
a1748 2
	}
	else
d1755 2
a1756 2
    **	Handle character based on context->state.
    */
d1758 5
a1762 5
	    state_name(context->state),
	    string->size,
	    NonNull(string->data),
	    UCH(c)));
    switch(context->state) {
d1766 7
a1772 9
	**  Note that if we don't have a CJK input, then this
	**  is not the second byte of a CJK di-byte, and we're
	**  trashing the input.	 That's why 8-bit characters
	**  followed by, for example, '<' can cause the tag to
	**  be treated as text, not markup.  We could try to deal
	**  with it by holding each first byte and then checking
	**  byte pairs, but that doesn't seem worth the overhead
	**  (see below). - FM
	*/
d1780 5
a1784 5
	 *  We had something link "<name/" so far, set state to S_text
	 *  but keep context->slashedtag as as a flag; except if we get
	 *  '>' directly after the "<name/", and really have a tag for
	 *  that name in context->slashedtag, in which case keep state as
	 *  is and let code below deal with it. - kw
d1788 2
a1789 2
	} /* fall through in any case! */

d1791 13
a1803 11
	if (HTCJK != NOCJK && (TOASCII(c) & 0200) != 0) {  /* S/390 -- gil -- 0864 */
	    /*
	    **	Setting up for Kanji multibyte handling (based on
	    **	Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx).
	    **	Note that if the input is not in fact CJK, the
	    **	next byte also will be mishandled, as explained
	    **	above.	Toggle raw mode off in such cases, or
	    **	select the "7 bit approximations" display
	    **	character set, which is largely equivalent
	    **	to having raw mode off with CJK. - FM
	    */
d1807 1
a1807 1
	} else if (HTCJK != NOCJK && TOASCII(c) == '\033') {  /* S/390 -- gil -- 0881 */
d1809 3
a1811 3
	    **	Setting up for CJK escape sequence handling (based on
	    **	Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx). - FM
	    */
d1819 1
a1819 1
	    if (psrc_view) { /*there is nothing useful in the element_stack*/
d1825 1
a1825 1
		     context->element_stack->tag : NULL;
d1829 1
a1829 1
	if (c == '&' && TOASCII(unsign_c) < 127	 &&  /* S/390 -- gil -- 0898 */
d1839 2
a1840 2
	    **	Setting up for possible entity, without the leading '&'. - FM
	    */
d1843 1
a1843 1
	} else if (c == '<' && TOASCII(unsign_c) < 127) {  /* S/390 -- gil -- 0915 */
d1845 2
a1846 2
	    **	Setting up for possible tag. - FM
	    */
d1851 1
a1851 1
				|| testtag->contents == SGML_CDATA)) {
d1864 5
a1868 5
	    **	We got either the second slash of a pending "<NAME/blah blah/"
	    **  shortref construct, or the '>' of a mere "<NAME/>".  In both
	    **  cases generate a "</NAME>" end tag in the recover buffer for
	    **  reparsing unless NAME is really an empty element. - kw
	    */
d1876 2
a1877 2
	    if (context->slashedtag != context->unknown_tag &&
		!ReallyEmptyTag(context->slashedtag)) {
d1892 6
a1897 6
	     *  The element stack says we are within the contents of an
	     *  element that the next stage (HTML.c) may want to feed
	     *  us back again (via the *include string).  So try to output
	     *  text in UTF-8 if possible, using the same logic as for
	     *  attribute values (which should be in line with what
	     *  context->current_tag_charset indicates). - kw
d1910 3
a1912 3
		    HTPassEightBitRaw &&
		    UCH(saved_char_in) >=
		    LYlowest_eightbit[context->outUCLYhndl]) {
d1924 5
a1928 5
	/*
	**  Convert 160 (nbsp) to Lynx special character if
	**  neither HTPassHighCtrlRaw nor HTCJK is set. - FM
	*/
	} else if (unsign_c == CH_NBSP &&  /* S/390 -- gil -- 0932 */
d1932 5
a1936 5
	/*
	**  Convert 173 (shy) to Lynx special character if
	**  neither HTPassHighCtrlRaw nor HTCJK is set. - FM
	*/
	} else if (unsign_c == CH_SHY &&  /* S/390 -- gil -- 0949 */
d1940 5
a1944 5
	/*
	**  Handle the case in which we think we have a character
	**  which doesn't need further processing (e.g., a koi8-r
	**  input for a koi8-r output). - FM
	*/
d1947 3
a1949 3
	    **	Only if the original character is still in saved_char_in,
	    **	otherwise we may be iterating from a goto top. - KW
	    */
d1953 1
a1953 1
 *   I. LATIN-1 OR UCS2	 TO  DISPLAY CHARSET
d1955 2
a1956 1
	} else if ((chk = (BOOL) (context->T.trans_from_uni && TOASCII(unsign_c) >= 160)) &&  /* S/390 -- gil -- 0968 */
d1961 1
a1961 1
			uck, FROMASCII((char)uck)));
d1963 3
a1965 3
	    **	We got one octet from the conversions, so use it. - FM
	    */
	    PUTC(FROMASCII((char)uck));
d1967 6
a1972 6
		   (uck == -4 ||
		    (context->T.repl_translated_C0 &&
		     uck > 0 && uck < 32))) &&
		   /*
		   **  Not found; look for replacement string. - KW
		   */
d1977 4
a1980 4
	    **	Got a replacement string.
	    **	No further tests for validity - assume that whoever
	    **	defined replacement strings knew what she was doing. - KW
	    */
d1982 3
a1984 3
	/*
	**  If we're displaying UTF-8, try that now. - FM
	*/
d1986 7
a1992 7
	    ; /* do nothing more */
	/*
	**  If it's any other (> 160) 8-bit character, and
	**  we have not set HTPassEightBitRaw nor HTCJK, nor
	**  have the "ISO Latin 1" character set selected,
	**  back translate for our character set. - FM
	*/
d2009 1
a2009 1
	    EntityName = HTMLGetEntityName((int)(unsign_c - 160));
d2013 1
a2013 1
	    /* we need to disable it temporary*/
d2015 2
a2016 1
		psrc_view_backup =1; psrc_view =0;
d2021 1
a2021 1
	    /* we need to disable it temporary*/
d2029 5
a2033 5
	/*
	**  If we get to here and have an ASCII char,
	**  pass the character. - KW
	*/
	} else if (TOASCII(unsign_c) < 127 && unsign_c > 0) {  /* S/390 -- gil -- 0987 */
d2035 7
a2041 7
	/*
	**  If we get to here, and should have translated,
	**  translation has failed so far. - KW
	**
	**  We should have sent UTF-8 output to the parser
	**  already, but what the heck, try again. - FM
	*/
d2047 3
a2049 3
	/*
	**  Check for a strippable koi8-r 8-bit character. - FM
	*/
d2054 4
a2057 4
	    **	KOI8 special: strip high bit, gives (somewhat) readable
	    **	ASCII or KOI7 - it was constructed that way! - KW
	    */
	    PUTC(((char)(saved_char_in & 0x7f)));
d2060 6
a2065 6
	/*
	**  If we don't actually want the character,
	**  make it safe and output that now. - FM
	*/
	} else if (TOASCII(UCH(c)) <	 /* S/390 -- gil -- 0997 */
			LYlowest_eightbit[context->outUCLYhndl] ||
d2067 3
a2069 3
	/*
	**  If we get to here, pass the character. - FM
	*/
d2075 5
a2079 5
    /*
    **	Found '<' in SGML_PCDATA content; treat this mode nearly like
    **  S_litteral, but recognize '<!' and '<?' to filter out comments
    **  and processing instructions. - kw
    */
d2081 2
a2082 2
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
d2084 3
a2086 4
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
d2093 1
a2093 1
	    } else if (c == '?') { /* <? - ignore as a PI until '>' - kw */
d2101 1
a2101 1
		    context->seen_nonwhite_in_junk_tag = TRUE; /* show all */
d2110 5
a2114 5
    /*
    **  Found '<' in SGML_SCRIPT content; treat this mode nearly like
    **  S_litteral, but recognize '<!' to allow the content to be treated
    **  as a comment by lynx.
    */
d2116 2
a2117 2
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
d2119 3
a2121 4
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
d2132 6
a2137 6
    /*
    **	In litteral mode, waits only for specific end tag (for
    **	compatibility with old servers, and for Lynx). - FM
    */
    case_S_litteral:
    case S_litteral: /*PSRC:this case not understood completely by HV, not done*/
d2140 1
a2140 1
	if (psrc_view) { /*there is nothing useful in the element_stack*/
d2155 2
a2156 2
	 *	testtag contains something like "TITLE"
	 *	string contains something like "/title>"
d2162 2
a2163 2
			    ? '/'
			    : testtag->name[testlast])) {
d2167 2
a2168 2
	    **	If complete match, end litteral.
	    */
d2177 1
a2177 1
		    strcpy(string->data,context->current_tag->name);
d2227 1
a2227 1
		  (testtag->flags & (Tgf_strict|Tgf_endO)))) &&
d2232 2
a2233 2
		for (i = 0; i < string->size; i++)  /* remove '/' */
		    string->data[i] = string->data[i+1];
d2240 1
a2240 1
		(testtag->flags & (Tgf_strict|Tgf_endO)) &&
d2246 2
a2247 2
	    **	If Mismatch: recover string literally.
	    */
d2249 2
a2250 2
	    for (i = 0; i < string->size-1; i++)  /* recover, except last c */
	       PUTC(string->data[i]);
d2257 3
a2259 3
    /*
    **	Character reference (numeric entity) or named entity.
    */
d2263 3
a2265 3
	    **	Setting up for possible numeric entity.
	    */
	    context->state = S_cro;  /* &# is Char Ref Open */
d2268 1
a2268 1
	context->state = S_entity;   /* Fall through! */
d2270 3
a2272 3
    /*
    **	Handle possible named entity.
    */
d2275 1
a2275 1
		  isalnum(UCH(c)) : isalpha(UCH(c)))) {
d2280 2
a2281 2
	    **	Accept valid ASCII character. - FM
	    */
d2285 3
a2287 3
	    **	It was an ampersand that's just text, so output
	    **	the ampersand and recycle this character. - FM
	    */
d2301 2
a2302 2
	    **	Terminate entity name and try to handle it. - FM
	    */
d2311 1
a2311 1
		 (context->element_stack->tag  &&
d2314 2
a2315 2
		**  Handle zwnj (8204) as <WBR>. - FM
		*/
d2318 2
a2319 1
		CTRACE((tfp, "SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));
d2341 4
a2344 5
	    **	Don't eat the terminator if we didn't find the
	    **	entity name and therefore sent the raw string
	    **	via handle_entity(), or if the terminator is
	    **	not the "standard" semi-colon for HTML. - FM
	    */
d2357 3
a2359 3
    /*
    **	Check for a numeric entity.
    */
d2361 1
a2361 1
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {  /* S/390 -- gil -- 1060 */
d2366 2
a2367 2
	    **	Accept only valid ASCII digits. - FM
	    */
d2373 3
a2375 3
	    **	No 'x' or digit following the "&#" so recover
	    **	them and recycle the character. - FM
	    */
d2391 3
a2393 3
    /*
    **	Handle a numeric entity.
    */
d2395 2
a2396 2
	/* S/390 -- gil -- 1075 */ /* CTRACE((tfp, "%s: %d: numeric %d %d\n",
			    __FILE__, __LINE__, unsign_c, c)); */
d2399 1
a2399 1
			      isdigit(UCH(c)))) {
d2401 2
a2402 2
	    **	Accept only valid hex or ASCII digits. - FM
	    */
d2406 3
a2408 3
	    **	No hex digit following the "&#x" so recover
	    **	them and recycle the character. - FM
	    */
d2423 2
a2424 2
	    **	Terminate the numeric entity and try to handle it. - FM
	    */
d2427 1
d2433 1
a2433 1
				  sscanf(string->data, "%ld", &code)) == 1) {
d2438 7
a2444 7
		    **	Assume these are Microsoft code points,
		    **	inflicted on us by FrontPage. - FM
		    **
		    **	MS FrontPage uses syntax like &#153; in 128-159 range
		    **	and doesn't follow Unicode standards for this area.
		    **	Windows-1252 codepoints are assumed here.
		    */
d2446 119
a2564 122
			case 1:
			    /*
			    **	WHITE SMILING FACE
			    */
			    code = 0x263a;
			    break;
			case 128:
			    /*
			    **	EURO currency sign
			    */
			    code = 0x20ac;
			    break;
			case 130:
			    /*
			    **	SINGLE LOW-9 QUOTATION MARK (sbquo)
			    */
			    code = 0x201a;
			    break;
			case 132:
			    /*
			    **	DOUBLE LOW-9 QUOTATION MARK (bdquo)
			    */
			    code = 0x201e;
			    break;
			case 133:
			    /*
			    **	HORIZONTAL ELLIPSIS (hellip)
			    */
			    code = 0x2026;
			    break;
			case 134:
			    /*
			    **	DAGGER (dagger)
			    */
			    code = 0x2020;
			    break;
			case 135:
			    /*
			    **	DOUBLE DAGGER (Dagger)
			    */
			    code = 0x2021;
			    break;
			case 137:
			    /*
			    **	PER MILLE SIGN (permil)
			    */
			    code = 0x2030;
			    break;
			case 139:
			    /*
			    **	SINGLE LEFT-POINTING ANGLE QUOTATION MARK
			    **	(lsaquo)
			    */
			    code = 0x2039;
			    break;
			case 145:
			    /*
			    **	LEFT SINGLE QUOTATION MARK (lsquo)
			    */
			    code = 0x2018;
			    break;
			case 146:
			    /*
			    **	RIGHT SINGLE QUOTATION MARK (rsquo)
			    */
			    code = 0x2019;
			    break;
			case 147:
			    /*
			    **	LEFT DOUBLE QUOTATION MARK (ldquo)
			    */
			    code = 0x201c;
			    break;
			case 148:
			    /*
			    **	RIGHT DOUBLE QUOTATION MARK (rdquo)
			    */
			    code = 0x201d;
			    break;
			case 149:
			    /*
			    **	BULLET (bull)
			    */
			    code = 0x2022;
			    break;
			case 150:
			    /*
			    **	EN DASH (ndash)
			    */
			    code = 0x2013;
			    break;
			case 151:
			    /*
			    **	EM DASH (mdash)
			    */
			    code = 0x2014;
			    break;
			case 152:
			    /*
			    **	SMALL TILDE (tilde)
			    */
			    code = 0x02dc;
			    break;
			case 153:
			    /*
			    **	TRADE MARK SIGN (trade)
			    */
			    code = 0x2122;
			    break;
			case 155:
			    /*
			    **	SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
			    **	(rsaquo)
			    */
			    code = 0x203a;
			    break;
			default:
			    /*
			    **	Do not attempt a conversion
			    **	to valid Unicode values.
			    */
			    break;
d2568 2
a2569 2
		**  Check for special values. - FM
		*/
d2572 1
a2572 1
		     (context->element_stack->tag  &&
d2575 2
a2576 2
		    **	Handle zwnj (8204) as <WBR>. - FM
		    */
d2579 2
a2580 1
		    CTRACE((tfp, "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));
d2583 3
a2585 3
		    **	Include the terminator if it is not
		    **	the standard semi-colon. - FM
		    */
d2592 3
a2594 3
		    **	Add the replacement string to the
		    **	recover buffer for processing. - FM
		    */
d2607 3
a2609 3
		    **	We handled the value as a special character,
		    **	so recycle the terminator or break. - FM
		    */
d2613 1
a2613 1
			PUTS( (context->isHex ? "&#x" : "&#") );
d2628 2
a2629 2
		**  Seek a translation from the chartrans tables.
		*/
d2638 1
a2638 1
		    PUTC(FROMASCII((char)uck));
d2647 3
a2649 3
			   /*
			   **  Not found; look for replacement string.
			   */
d2658 4
a2661 4
		    PUTS(replace_buf);
		/*
		**  If we're displaying UTF-8, try that now. - FM
		*/
d2663 5
a2667 5
		    ;  /* do nothing more */
		/*
		**  Ignore 8205 (zwj),
		**  8206 (lrm), and 8207 (rln), if we get to here. - FM
		*/
d2684 1
a2684 1
			PUTS( (context->isHex ? "&#x" : "&#") );
d2697 12
a2708 13
		/*
		**  Show the numeric entity if we get to here
		**  and the value:
		**   (1) Is greater than 255 (but use ASCII characters
		**	 for spaces or dashes).
		**   (2) Is less than 32, and not valid or we don't
		**	 have HTCJK set.
		**   (3) Is 127 and we don't have HTPassHighCtrlRaw or
		**	 HTCJK set.
		**   (4) Is 128 - 159 and we don't have HTPassHighCtrlNum
		**	 set.
		**  - FM
		*/
d2710 1
a2710 1
			   (code < ' ' &&  /* S/390 -- gil -- 1140 */
d2717 4
a2720 5
			/*
			**  Unhandled or illegal value.	 Recover the
			**  "&#" or "&#x" and digit(s), and recycle
			**  the terminator. - FM
			*/
d2722 3
a2724 3
			if (psrc_view) {
			    PSRCSTART(badseq);
			}
d2726 9
a2734 9
			if (context->isHex) {
			    PUTS("&#x");
			    context->isHex = FALSE;
			} else {
			    PUTS("&#");
			}
			string->size--;
			for (i = 0; i < string->size; i++)	/* recover */
			    PUTC(string->data[i]);
d2736 3
a2738 3
			if (psrc_view) {
			    PSRCSTOP(badseq);
			}
d2740 5
a2744 5
			string->size = 0;
			context->isHex = FALSE;
			context->state = S_text;
			goto top1;
		} else if (TOASCII(code) < 161 ||  /* S/390 -- gil -- 1162 */
d2748 2
a2749 2
		    **	No conversion needed. - FM
		    */
d2755 1
a2755 1
		    PUTC(FROMASCII((char)code));
d2758 2
a2759 2
		    **	Handle as named entity. - FM
		    */
d2768 3
a2770 3
			**  Add a semi-colon if something went wrong
			**  and handle_entity() sent the string. - FM
			*/
d2776 3
a2778 3
			**  Our conversion failed, so recover the "&#"
			**  and digit(s), and recycle the terminator. - FM
			*/
d2803 2
a2804 2
		**  If we get to here, we succeeded.  Hoorah!!! - FM
		*/
d2809 3
a2811 3
		**  Don't eat the terminator if it's not
		**  the "standard" semi-colon for HTML. - FM
		*/
d2817 4
a2820 5
		**  Not an entity, and don't know why not, so add
		**  the terminator to the string, output the "&#"
		**  or "&#x", and process the string via the recover
		**  element. - FM
		*/
d2852 4
a2855 4
    /*
    **	Tag
    */
    case S_tag:					/* new tag */
d2857 1
a2857 1
		  IsNmChar(c) : IsNmStart(c))) {
d2859 2
a2860 2
	    **	Add valid ASCII character. - FM
	    */
d2862 1
a2862 1
	} else if (c == '!' && !string->size) { /* <! */
d2864 3
a2866 3
	    **	Terminate and set up for possible comment,
	    **	identifier, declaration, or marked section. - FM
	    */
d2874 1
a2874 1
		   (TOASCII(unsign_c) <= 160 &&	 /* S/390 -- gil -- 1196 */
d2877 7
a2883 7
	    **	'<' must be followed by an ASCII letter to be a valid
	    **	start tag.  Here it isn't, nor do we have a '/' for an
	    **	end tag, nor one of some other characters with a
	    **	special meaning for SGML or which are likely to be legal
	    **	Name Start characters in XML or some other extension.
	    **	So recover the '<' and following character as data. - FM & KW
	    */
d2895 1
a2895 1
	} else {				/* End of tag name */
d2897 4
a2900 3
	    **	Try to handle tag. - FM
	    */
	    HTTag * t;
d2906 1
a2906 1
		CTRACE((tfp,"SGML: `<%.*s/' found!\n", string->size, string->data));
d2908 1
a2908 1
	    HTChunkTerminate(string) ;
d2916 3
a2918 3
		**  Treat <URL: as text rather than a junk tag,
		**  so we display it and the URL (Lynxism 8-). - FM
		*/
d2924 1
a2924 1
		PUTS(string->data); /* recover */
d2931 1
a2931 1
			    string->data, c));
d2938 4
a2941 4
		 *  Element name was ended by '/'.  Remember the tag that
		 *  ended thusly, we'll interpret this as either an indication
		 *  of an empty element (if '>' follows directly) or do
		 *  some SGMLshortref-ish treatment. - kw
d2953 1
a2953 1
			context->seen_nonwhite_in_junk_tag = TRUE; /*show all*/
d2960 1
a2960 1
			    string->data));
d2975 1
a2975 1
		    if (c == '>' ) {
d2989 1
a2989 1
			    string->data));
d2991 3
a2993 3
		**  Fall through and treat like valid
		**  tag for attribute parsing. - KW
		*/
d3019 1
a3019 1
	    if (!psrc_view) /*don't waste time */
d3022 5
a3026 5
	    /*
	    **	Clear out attributes.
	    */
		memset( (void*)context->present, 0 , sizeof(BOOL)*
				context->current_tag->number_of_attributes);
d3063 2
a3064 2
	    **	Set up for possible comment. - FM
	    */
d3072 2
a3073 2
	    **	Set up for possible marked section. - FM
	    */
d3083 2
a3084 2
	    **	Set up to handle comment. - FM
	    */
d3096 2
a3097 2
	    **	Try to handle identifier. - FM
	    */
d3108 1
a3108 1
	    handle_identifier(context);
d3117 2
a3118 2
		**  Set up for DOCTYPE declaration. - FM
		*/
d3127 2
a3128 2
		**  Set up for ENTITY declaration. - FM
		*/
d3138 2
a3139 2
		**  Set up for ELEMENT declaration. - FM
		*/
d3149 2
a3150 2
		**  Set up for ATTLIST declaration. - FM
		*/
d3164 2
a3165 2
	    **	Any '>' terminates. - FM
	    */
d3177 1
a3177 1
		handle_comment(context);
d3198 3
a3200 3
		**  Validly treat '--' pairs as successive comments
		**  (for minimal, any "--WHITE>" terminates). - FM
		*/
d3206 2
a3207 2
	    **	Terminate and handle the comment. - FM
	    */
d3229 1
a3229 1
    S_comment_put_c:
d3231 1
a3231 1
		   *context->utf_buf) {
d3277 1
a3277 1
	    handle_doctype(context);
d3309 1
a3309 1
	    handle_marked(context);
d3343 1
a3343 1
	    handle_sgmlent(context);
d3380 1
a3380 1
	    handle_sgmlele(context);
d3417 1
a3417 1
	    handle_sgmlatt(context);
d3435 2
a3436 2
	    if (context->current_tag->name)
		start_element(context);
d3448 1
a3448 1
	context->state = S_attr; /* Get attribute */
d3451 1
a3451 1
				/* accumulating value */
d3459 7
a3465 7
	    string->size = 0;
	    if (c == '>') {				/* End of tag */
		if (context->current_tag->name)
		    start_element(context);
		context->state = S_text;
		break;
	    }
d3480 2
a3481 1
		if (c == '=' ) PUTC('=');
d3498 1
a3498 1
	    context->state = (c == '=' ?  S_equals: S_attr_gap);
d3539 1
a3539 1
	context->state = S_attr; /* Get next attribute */
d3584 1
a3584 1
	/*  no break!  fall through to S_value and process current `c`	 */
d3587 2
a3588 2
	if (WHITE(c) || (c == '>')) {		/* End of word */
	    HTChunkTerminate(string) ;
d3591 1
a3591 1
		/*PSRCSTART(attrval);*/
d3594 3
a3596 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3599 1
a3599 1
		    HTStartAnchor(context->target,NULL,string->data);
d3603 3
a3605 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3611 4
a3614 2
#ifdef CJK_EX	/* Quick hack. - JH7AYN */
	    {   char jis_buf[512];
d3616 6
a3621 5
		  if (string->data[1] == 'B' || string->data[1] == '@@') {
		    jis_buf[0] = '\033';
		    strcpy(jis_buf + 1, string->data);
		    TO_EUC((CONST unsigned char *)jis_buf, (unsigned char *)string->data);
		  }
d3627 1
a3627 1
	    if (c == '>') {		/* End of tag */
d3639 2
a3640 2
	    }
	    else context->state = S_tag_gap;
d3667 1
a3667 1
	    HTChunkTerminate(string) ;
d3670 1
a3670 1
		/*PSRCSTART(attrval);*/
d3672 4
a3675 5
		    HTStartAnchor(context->target,string->data, NULL);
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3678 1
a3678 1
		    HTStartAnchor(context->target,NULL,string->data);
d3682 3
a3684 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3691 1
a3691 1
	    handle_attribute_value(context, string->data);
d3694 1
a3694 1
	} else if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1213 */
d3696 3
a3698 3
	    **	Setting up for possible single quotes in CJK escape
	    **	sequences. - Takuya ASADA (asada@@three-a.co.jp)
	    */
d3729 1
a3729 1
	    HTChunkTerminate(string) ;
d3732 1
a3732 1
		/*PSRCSTART(attrval);*/
d3734 4
a3737 5
		    HTStartAnchor(context->target,string->data, NULL);
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3740 1
a3740 1
		    HTStartAnchor(context->target,NULL,string->data);
d3744 3
a3746 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3754 1
a3754 1
	    handle_attribute_value(context, string->data);
d3759 1
a3759 1
	} else if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1230 */
d3761 3
a3763 3
	    **	Setting up for possible double quotes in CJK escape
	    **	sequences. - Takuya ASADA (asada@@three-a.co.jp)
	    */
d3790 1
a3790 1
    case S_end:					/* </ */
d3792 1
a3792 1
		  IsNmChar(c) : IsNmStart(c))) {
d3794 3
a3796 2
	} else {				/* End of end tag name */
	    HTTag * t = 0;
d3831 1
a3831 1
		    psrc_tagname_processed=TRUE;
d3837 1
d3840 1
a3840 1
		int branch = 2; /* it can be 0,1,2*/
d3850 1
a3850 1
		 && Old_DTD
d3852 13
a3864 5
		 ) {
		   switch (e) {
		     case HTML_DD: case HTML_DT: case HTML_LI: case HTML_LH :
		     case HTML_TD: case HTML_TH: case HTML_TR: case HTML_THEAD:
		     case HTML_TFOOT : case HTML_TBODY : case HTML_COLGROUP:
d3868 12
a3879 3
		     case HTML_A:  case HTML_B: case HTML_BLINK: case HTML_CITE:
		     case HTML_EM: case HTML_FONT: case HTML_FORM: case HTML_I:
		     case HTML_P:  case HTML_STRONG: case HTML_TT: case HTML_U:
d3890 2
a3891 2
		**  Just handle ALL end tags normally :-) - kw
		*/
d3893 1
a3893 1
		    end_element( context, context->current_tag);
d3897 1
a3897 1
		if (tag_OK &&
d3899 1
a3899 1
		    (branch == 0)
d3901 11
a3911 11
		    (!strcasecomp(string->data, "DD") ||
		     !strcasecomp(string->data, "DT") ||
		     !strcasecomp(string->data, "LI") ||
		     !strcasecomp(string->data, "LH") ||
		     !strcasecomp(string->data, "TD") ||
		     !strcasecomp(string->data, "TH") ||
		     !strcasecomp(string->data, "TR") ||
		     !strcasecomp(string->data, "THEAD") ||
		     !strcasecomp(string->data, "TFOOT") ||
		     !strcasecomp(string->data, "TBODY") ||
		     !strcasecomp(string->data, "COLGROUP"))
d3913 1
a3913 1
		 ) {
d3915 3
a3917 3
		    **	Don't treat these end tags as invalid,
		    **	nor act on them. - FM
		    */
d3919 1
a3919 1
				string->data, c));
d3946 1
a3946 1
		) {
d3948 6
a3953 6
		    **	Handle end tags for container elements declared
		    **	as SGML_EMPTY to prevent "expected tag substitution"
		    **	but still processed via HTML_end_element() in HTML.c
		    **	with checks there to avoid throwing the HTML.c stack
		    **	out of whack (Ugh, what a hack! 8-). - FM
		    */
d3956 2
a3957 2
			**  We are in a SELECT block. - FM
			*/
d3960 5
a3964 4
			    **	It is not at FORM end tag, so ignore it. - FM
			    */
			    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
					string->data));
d3967 6
a3972 5
			    **	End the SELECT block and then
			    **	handle the FORM end tag. - FM
			    */
			    CTRACE((tfp, "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
					string->data));
d3978 1
a3978 1
			    if (!psrc_view) /* Don't actually call if viewing psrc - kw */
d3980 4
a3983 4
			    (*context->actions->end_element)
				(context->target,
				 TAGNUM_OF_TAGP(context->current_tag),
				 (char **)&context->include);
d3987 6
a3992 5
			**  Treat a P end tag like a P start tag (Ugh,
			**  what a hack! 8-). - FM
			*/
			CTRACE((tfp, "SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				    string->data, c, string->data, c));
d3995 1
d4008 1
a4008 1
			if (!psrc_view) /* Don't actually call if viewing psrc - kw */
d4010 4
a4013 4
			(*context->actions->end_element)
			    (context->target,
			     TAGNUM_OF_TAGP(context->current_tag),
			     (char **)&context->include);
d4026 3
a4028 3
		    **	Handle all other end tags normally. - FM
		    */
		    end_element( context, context->current_tag);
d4046 1
a4046 1
		if ( c != '>' ) {
d4061 1
a4061 1
		    CTRACE((tfp,"SGML: `</%s%c' found!\n", string->data, c));
a4069 1

d4081 1
a4081 1
    case S_dollar:	/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4090 1
a4090 1
    case S_dollar_paren: /* Expecting 'C' after CJK "ESC$(". */
d4099 1
a4099 1
    case S_paren:	/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4110 2
a4111 2
    case S_nonascii_text: /* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1264 */
d4119 1
a4119 1
    case S_esc_sq:	/* Expecting '$'or '(' following CJK ESC. */
d4130 1
a4130 1
    case S_dollar_sq:	/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4139 1
a4139 1
    case S_dollar_paren_sq: /* Expecting 'C' after CJK "ESC$(". */
d4148 1
a4148 1
    case S_paren_sq:	/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4159 2
a4160 2
    case S_nonascii_text_sq: /* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1281 */
d4177 1
a4177 1
    case S_dollar_dq:	/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4186 1
a4186 1
    case S_dollar_paren_dq: /* Expecting 'C' after CJK "ESC$(". */
d4195 1
a4195 1
    case S_paren_dq:	/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4206 2
a4207 2
    case S_nonascii_text_dq: /* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1298 */
d4232 1
a4232 1
	    /*pack spaces until first non-space is seen*/
d4243 1
a4243 1
    } /* switch on context->state */
d4245 4
a4248 4
	    state_name(context->state),
	    string->size,
	    NonNull(string->data),
	    UCH(c)));
d4250 1
a4250 1
after_switch:
d4252 4
a4255 4
    **	Check whether an external function has added
    **	anything to the include buffer.  If so, move the
    **	new stuff to the beginning of active_include. - kw
    */
d4272 2
a4273 2
    **	Check whether we've added anything to the recover buffer. - FM
    */
d4286 3
a4288 4
    **	Check whether an external function had added
    **	anything to the include buffer; it should now be
    **  in active_include. - FM / kw
    */
d4297 4
a4300 5
		 *  If it looks like we would have fed UTF-8 to the
		 *  next processing stage, assume that whatever we were
		 *  fed back is in UTF-8 form, too.  This won't be always
		 *  true for all uses of the include buffer, but it's a
		 *  start. - kw
d4303 1
d4307 1
a4307 1
			c = ((char)(clong & 0xff));
d4314 2
a4315 2
		 *  Otherwise assume no UTF-8 - do charset-naive processing
		 *  and hope for the best. - kw
d4325 3
a4327 3
    **	Check whether an external function has added
    **	anything to the csi buffer. - FM
    */
d4338 1
a4338 1
}  /* SGML_character */
d4340 3
a4343 5
PRIVATE void SGML_string ARGS2(
	HTStream *,	context,
	CONST char*,	str)
{
    CONST char *p;
d4348 5
a4353 7
PRIVATE void SGML_write ARGS3(
	HTStream *,	context,
	CONST char*,	str,
	int,		l)
{
    CONST char *p;
    CONST char *e = str+l;
d4362 3
a4364 3
**	-----------------------
*/
PUBLIC CONST HTStreamClass SGMLParser =
d4366 6
a4371 6
	"SGMLParser",
	SGML_free,
	SGML_abort,
	SGML_character,
	SGML_string,
	SGML_write,
d4375 7
a4381 7
**	------------------
**
** On entry,
**	dtd		represents the DTD, along with
**	actions		is the sink for the data as a set of routines.
**
*/
d4383 3
a4385 4
PUBLIC HTStream* SGML_new  ARGS3(
	CONST SGML_dtd *,	dtd,
	HTParentAnchor *,	anchor,
	HTStructured *,		target)
d4388 2
a4389 1
    HTStream* context = (HTStream *) malloc(sizeof(*context));
d4399 2
a4400 2
    context->actions = (CONST HTStructuredClass*)(((HTStream*)target)->isa);
					/* Ugh: no OO */
d4405 1
a4405 1
    context->element_stack = 0;			/* empty */
d4407 1
a4407 1
    context->no_lynx_specialcodes = NO;	/* special codes normally generated */
d4409 1
a4409 1
    context->callerData = (void*) callerData;
d4422 1
a4422 1
    context->node_anchor = anchor; /* Could be NULL? */
d4438 1
a4438 1
#ifdef CAN_SWITCH_DISPLAY_CHARSET /* Allow a switch to a more suitable display charset */
d4441 1
a4441 1
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl != current_char_set ) {
d4444 1
a4444 1
	anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl = -1; /* Force reset */
d4446 1
a4446 1
				  /* Preserve change this: */
d4481 5
a4485 5
**		====================================
**
**	Added 24-Mar-96 by FM, based on:
**
////////////////////////////////////////////////////////////////////////
d4508 1
a4508 1
PUBLIC int TREAT_SJIS = 1;
d4510 70
a4579 70
PUBLIC void JISx0201TO0208_EUC ARGS4(
	register unsigned char,		IHI,
	register unsigned char,		ILO,
	register unsigned char *,	OHI,
	register unsigned char *,	OLO)
{
    static char *table[] = {
	"\241\243",	/* A1,A3 */
	"\241\326",	/* A1,D6 */
	"\241\327",	/* A1,D7 */
	"\241\242",	/* A1,A2 */
	"\241\246",	/* A1,A6 */
	"\245\362",	/* A5,F2 */
	"\245\241",	/* A5,A1 */
	"\245\243",	/* A5,A3 */
	"\245\245",	/* A5,A5 */
	"\245\247",	/* A5,A7 */
	"\245\251",	/* A5,A9 */
	"\245\343",	/* A5,E3 */
	"\245\345",	/* A5,E5 */
	"\245\347",	/* A5,E7 */
	"\245\303",	/* A5,C3 */
	"\241\274",	/* A1,BC */
	"\245\242",	/* A5,A2 */
	"\245\244",	/* A5,A4 */
	"\245\246",	/* A5,A6 */
	"\245\250",	/* A5,A8 */
	"\245\252",	/* A5,AA */
	"\245\253",	/* A5,AB */
	"\245\255",	/* A5,AD */
	"\245\257",	/* A5,AF */
	"\245\261",	/* A5,B1 */
	"\245\263",	/* A5,B3 */
	"\245\265",	/* A5,B5 */
	"\245\267",	/* A5,B7 */
	"\245\271",	/* A5,B9 */
	"\245\273",	/* A5,BB */
	"\245\275",	/* A5,BD */
	"\245\277",	/* A5,BF */
	"\245\301",	/* A5,C1 */
	"\245\304",	/* A5,C4 */
	"\245\306",	/* A5,C6 */
	"\245\310",	/* A5,C8 */
	"\245\312",	/* A5,CA */
	"\245\313",	/* A5,CB */
	"\245\314",	/* A5,CC */
	"\245\315",	/* A5,CD */
	"\245\316",	/* A5,CE */
	"\245\317",	/* A5,CF */
	"\245\322",	/* A5,D2 */
	"\245\325",	/* A5,D5 */
	"\245\330",	/* A5,D8 */
	"\245\333",	/* A5,DB */
	"\245\336",	/* A5,DE */
	"\245\337",	/* A5,DF */
	"\245\340",	/* A5,E0 */
	"\245\341",	/* A5,E1 */
	"\245\342",	/* A5,E2 */
	"\245\344",	/* A5,E4 */
	"\245\346",	/* A5,E6 */
	"\245\350",	/* A5,E8 */
	"\245\351",	/* A5,E9 */
	"\245\352",	/* A5,EA */
	"\245\353",	/* A5,EB */
	"\245\354",	/* A5,EC */
	"\245\355",	/* A5,ED */
	"\245\357",	/* A5,EF */
	"\245\363",	/* A5,F3 */
	"\241\253",	/* A1,AB */
	"\241\254"	/* A1,AC */
d4591 1
a4591 1
PRIVATE int IS_SJIS_STR ARGS1(CONST unsigned char *, str)
d4593 1
a4593 1
    CONST unsigned char *s;
d4606 3
a4608 4
PUBLIC unsigned char * SJIS_TO_JIS1 ARGS3(
	register unsigned char,		HI,
	register unsigned char,		LO,
	register unsigned char *,	JCODE)
d4625 3
a4627 4
PUBLIC unsigned char * JIS_TO_SJIS1 ARGS3(
	register unsigned char,		HI,
	register unsigned char,		LO,
	register unsigned char *,	SJCODE)
d4644 3
a4646 4
PUBLIC unsigned char * EUC_TO_SJIS1 ARGS3(
	unsigned char,			HI,
	unsigned char,			LO,
	register unsigned char *,	SJCODE)
d4654 3
a4656 4
PUBLIC void JISx0201TO0208_SJIS ARGS3(
	register unsigned char,		I,
	register unsigned char *,	OHI,
	register unsigned char *,	OLO)
d4666 3
a4668 4
PUBLIC unsigned char * SJIS_TO_EUC1 ARGS3(
	unsigned char,		HI,
	unsigned char,		LO,
	unsigned char *,	data)
d4676 2
a4677 3
PUBLIC unsigned char * SJIS_TO_EUC ARGS2(
	unsigned char *,	src,
	unsigned char *,	dst)
d4698 2
a4699 3
PUBLIC unsigned char * EUC_TO_SJIS ARGS2(
	unsigned char *,	src,
	unsigned char *,	dst)
d4720 1
a4720 1
#define Strcpy(a,b)	(strcpy((char*)a,(CONST char*)b),&a[strlen((CONST char*)a)])
d4722 4
a4725 5
PUBLIC unsigned char *EUC_TO_JIS ARGS4(
	unsigned char *,	src,
	unsigned char *,	dst,
	CONST char *,		toK,
	CONST char *,		toA)
d4770 1
a4770 1
PUBLIC int repair_JIS = 0;
d4772 2
a4773 3
PRIVATE CONST unsigned char *repairJIStoEUC ARGS2(
	CONST unsigned char *,	src,
	unsigned char **,	dstp)
d4775 1
a4775 1
    CONST unsigned char *s;
d4796 2
a4797 3
PUBLIC unsigned char *TO_EUC ARGS2(
	CONST unsigned char *,	jis,
	unsigned char *,	euc)
d4799 1
a4799 1
    register CONST unsigned char *s;
d4826 2
a4827 1
		CONST unsigned char *ts;
d4886 1
a4886 1
PRIVATE int is_EUC_JP ARGS1(unsigned char *, euc)
d4908 2
a4909 3
PUBLIC void TO_SJIS ARGS2(
	CONST unsigned char *,	any,
	unsigned char *,	sjis)
d4913 2
a4914 1
    euc = malloc(strlen((CONST char *) any) + 1);
d4919 1
a4919 1
    TO_EUC(any, euc);
d4923 1
a4923 1
	strcpy((char *) sjis, (CONST char *) any);
d4927 2
a4928 3
PUBLIC void TO_JIS ARGS2(
	CONST unsigned char *,	any,
	unsigned char *,	jis)
d4932 1
a4932 1
    if (any[0] == 0) {
d4936 1
a4936 1
    euc = malloc(strlen((CONST char *) any) + 1);
d4941 1
a4941 1
    TO_EUC(any, euc);
@


1.4
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d2257 1
a2257 5
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    context->state = S_text;
		    break;
		}
d2259 2
a2260 1
		end_element(context, context->element_stack->tag);
d2264 2
a4455 1
/*    context->extra_tags = dtd->tags + dtd->number_of_tags; */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d4345 1
a4345 1
	    if (context->current_tag_charset == UTF8 ||
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d32 1
d39 1
a39 1
#ifdef USE_PSRC
d45 1
a45 6
#ifdef USE_PSRC

#  define PSRC(x) if (psrc_view) { x };
#  define NPSRC(x) if (!psrc_view) { x };
#  define IFDEFPSRC(x) x
#  define IFNDEFPSRC(x)
a60 5
#else
#  define PSRC(x)
#  define NPSRC(x)
#  define IFDEFPSRC(x)
#  define IFNDEFPSRC(x) x
d63 20
a82 2
 /* will use an inlined version */
#ifdef USE_INLINE_PUTC
d84 14
a97 10
#define HTChunkPutc(ch,c)\
    if (ch->size >= ch->allocated) {\
	ch->allocated = ch->allocated + ch->growby;\
	ch->data = ch->data ? (char *)realloc(ch->data, ch->allocated)\
			    : (char *)calloc(1, ch->allocated);\
      if (!ch->data)\
	  outofmem(__FILE__, "HTChunkPutc");\
    }\
    ch->data[ch->size++] = c;
#endif
d100 3
d104 1
a105 3
#define OPT 0 /* don't make it 1 otherwise something wrong will be with
 TagSoup parser mode - I was unable to undestand why it works incorrectly -HV*/
#define OPT1 1 /* set to 1 for several optimizations */
a115 2
/*  extern int LYlowest_eightbit[];  for completeness here  */

d136 45
d194 1
d197 1
d200 2
d203 2
a204 13
    enum sgml_state { S_text, S_litteral,
		S_tag, S_tag_gap, S_attr, S_attr_gap, S_equals, S_value,
		S_ero, S_cro, S_incro,
		S_exclamation, S_comment, S_doctype, S_marked,
		S_sgmlent, S_sgmlele, S_sgmlatt,
		S_squoted, S_dquoted, S_end, S_entity,
		S_esc,	  S_dollar,    S_paren,	   S_nonascii_text,
		S_dollar_paren,
		S_esc_sq, S_dollar_sq, S_paren_sq, S_nonascii_text_sq,
		S_dollar_paren_sq,
		S_esc_dq, S_dollar_dq, S_paren_dq, S_nonascii_text_dq,
		S_dollar_paren_dq,
		S_in_kanji, S_junk_tag} state;
d209 1
a209 1
    char * value[MAX_ATTRIBUTES];	/* malloc'd strings or NULL if none */
d234 1
d239 6
a244 1
} ;
d246 75
a320 2
#ifdef USE_PSRC
static BOOL seen_letter_in_junk_tag;
d324 1
a324 1
	    HTlexem,	      lexem,
d327 1
a327 1
    HT_tagspec* ts = *( ( start ? lexem_start : lexem_end ) + lexem);
d338 1
a338 1
	CTRACE(tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexem);
d356 1
d358 5
a362 1
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(context,HTL_##x,STOP)
d364 2
a365 2
PRIVATE BOOL cur_attr_is_href;
PRIVATE BOOL cur_attr_is_name;
d376 1
a376 1
	**  so the HTML parser's UCLYhndl should still be it's
a469 8
#define PUTC(ch) ((*context->actions->put_character)(context->target, ch))
#define PUTUTF8(code) (UCPutUtf8_charstring((HTStream *)context->target, \
		      (putc_func_t*)(context->actions->put_character), code))

extern BOOL historical_comments;
extern BOOL minimal_comments;
extern BOOL soft_dquotes;

d472 1
a472 1
static int current_is_class=0;
a483 1

d488 1
a488 1
#ifdef USE_PSRC
d490 2
a491 2
	cur_attr_is_href = FALSE;
	cur_attr_is_name = FALSE;
d498 1
a498 1
#ifdef USE_PSRC
d512 1
a512 1
	diff = strcasecomp(attributes[i].name, s);
d515 5
a519 2
#ifdef USE_PSRC
	    if (!psrc_view) {
d521 1
d523 1
a523 1
	    FREE(context->value[i]);
d525 1
a525 4
#  ifdef USE_PSRC
#       if !OPT1
	    current_is_class = (!strcasecomp("class", s));
#       else
a526 1
#       endif
d530 1
a530 1
	    CTRACE(tfp, "SGML: found attribute %s, %d\n", s, current_is_class);
a531 5

#ifdef USE_PSRC
	    } else {
		 cur_attr_is_name = (attributes[i].type == HTMLA_ANAME);
		 cur_attr_is_href = (attributes[i].type == HTMLA_HREF);
a532 1
#endif
d538 2
a539 2
    CTRACE(tfp, "SGML: Unknown attribute %s for tag %s\n",
		s, context->current_tag->name);
d552 1
a552 1
	StrAllocCopy(context->value[context->current_attribute_number], s);
d557 1
a557 1
	    CTRACE(tfp, "SGML: class is '%s'\n", s);
d561 1
a561 1
	    CTRACE(tfp, "SGML: attribute value is '%s'\n", s);
d565 1
a565 1
	CTRACE(tfp, "SGML: Attribute value %s ***ignored\n", s);
d585 8
d597 1
a597 1
#ifdef USE_PSRC
d605 1
a605 1
#ifdef USE_PSRC
d620 2
a621 1
	**  Assume emsp as two ensp (below).
d623 1
a623 1
#ifdef USE_PSRC
d631 1
a631 1
#ifdef USE_PSRC
d636 1
a636 1
#ifdef USE_PSRC
d651 21
a694 1
    CONST char *p;
a696 1

d707 1
a707 1
#ifdef USE_PSRC
d709 1
a709 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d723 1
a723 1
#ifdef USE_PSRC
d725 1
a725 3
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&'); PUTS(entity_string); if (term) PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d739 1
a739 1
#ifdef USE_PSRC
d741 1
a741 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d744 1
a744 2
	    for (p = replace_buf; *p; p++)
		PUTC(*p);
d751 1
a751 1
#ifndef USE_PSRC
d759 1
a759 1
	      (putc_func_t*)(&fake_put_character), code)): PUTUTF8(code) ) ) {
d762 1
a762 3
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&'); PUTS(entity_string); if (term) PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d773 1
a773 1
#ifdef USE_PSRC
d775 1
a775 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d791 2
a792 2
	    CTRACE(tfp, "handle_entity: Ignoring '%s'.\n", s);
#ifdef USE_PSRC
d794 1
a794 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d805 2
a806 2
	    CTRACE(tfp, "handle_entity: Ignoring '%s'.\n", s);
#ifdef USE_PSRC
d808 1
a808 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d819 1
a819 1
#ifdef USE_PSRC
d823 1
a823 1
    CTRACE(tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long)code, uck); /* S/390 -- gil -- 0695 */
d825 1
a825 3
    for (p = s; *p; p++) {
	PUTC(*p);
    }
d828 1
a828 1
#ifdef USE_PSRC
d843 1
a843 1
    CTRACE(tfp, "SGML Comment:\n<%s>\n", s);
d865 1
a865 1
    CTRACE(tfp, "SGML Identifier:\n<%s>\n", s);
d879 1
a879 1
    CTRACE(tfp, "SGML Doctype:\n<%s>\n", s);
d884 4
d897 1
a897 1
    CTRACE(tfp, "SGML Marked Section:\n<%s>\n", s);
d899 13
d924 1
a924 1
    CTRACE(tfp, "SGML Entity Declaration:\n<%s>\n", s);
d938 1
a938 1
    CTRACE(tfp, "SGML Element Declaration:\n<%s>\n", s);
d952 1
a952 1
    CTRACE(tfp, "SGML Attribute Declaration:\n<%s>\n", s);
d957 30
d1000 1
a1000 1
	return ((Tgc_same & usecontains) &&
d1003 1
a1003 1
	return ((new_tag->tagclass & usecontains) &&
a1006 2
extern BOOL Old_DTD;

d1032 1
d1038 4
d1044 1
a1044 1
	stacked->tag - context->dtd->tags,
d1047 3
a1049 1
    FREE(stacked);
d1059 2
a1060 1
	if (stacked->tag == old_tag)
d1084 5
d1091 1
a1091 1
		CTRACE(tfp, "SGML: End </%s> \t<- %s end </%s>\n",
d1094 1
a1094 1
			    old_tag->name);
a1097 5
	    } else {
		CTRACE(tfp, "SGML: Still open %s \t<- ***invalid end </%s>\n",
			    context->element_stack->tag->name,
			    old_tag->name);
		return;
d1102 1
a1102 1
	    CTRACE(tfp, "SGML: Still open %s, ***no open %s for </%s>\n",
d1106 1
a1106 1
			old_tag->name);
d1110 1
a1110 1
	    CTRACE(tfp, "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
d1113 1
a1113 1
			old_tag->name);
d1135 2
a1136 2
	    CTRACE(tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
			old_tag->name);
d1143 1
a1143 1
    CTRACE(tfp, "SGML: End </%s>\n", old_tag->name);
d1145 2
a1146 2
	CTRACE(tfp, "SGML: ***Illegal end tag </%s> found.\n",
		    old_tag->name);
d1155 2
d1158 1
a1158 1
	HTTag * t = N->tag;
d1162 2
a1163 2
		CTRACE(tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			     old_tag->name, t->name, t->name);
d1165 2
a1166 2
		CTRACE(tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			    old_tag->name, t->name, old_tag->name);
d1171 25
a1195 4
	context->element_stack = N->next;		/* Remove from stack */
	FREE(N);
	(*context->actions->end_element)(context->target,
		 t - context->dtd->tags, (char **)&context->include);
d1206 2
a1207 2
    CTRACE(tfp, "SGML: Extra end tag </%s> found and ignored.\n",
		old_tag->name);
d1216 1
d1218 1
a1218 2
#if OPT1
    HTMLElement e = new_tag - context->dtd->tags;
a1219 1
#endif
d1237 1
a1237 1
		CTRACE(tfp, "SGML: End </%s> \t<- %s start <%s>\n",
d1240 1
a1240 1
			    new_tag->name);
d1246 1
a1246 1
		CTRACE(tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1248 1
a1248 1
			    new_tag->name);
d1255 1
a1255 1
	    CTRACE(tfp, "SGML: Still open %s \t<- ***ignoring start <%s>\n",
d1257 1
a1257 1
			new_tag->name);
d1268 1
a1268 1
		CTRACE(tfp, "SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
d1271 1
a1271 1
			    new_tag->name);
d1283 1
a1283 1
	    CTRACE(tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1285 1
a1285 1
			new_tag->name);
d1302 1
d1304 2
a1305 1
	if (!strcasecomp(new_tag->name, "SELECT")) {
a1318 10
#if !OPT1
	    if (!strcasecomp(new_tag->name, "INPUT") ||
		!strcasecomp(new_tag->name, "TEXTAREA") ||
		!strcasecomp(new_tag->name, "SELECT") ||
		!strcasecomp(new_tag->name, "BUTTON") ||
		!strcasecomp(new_tag->name, "FIELDSET") ||
		!strcasecomp(new_tag->name, "LABEL") ||
		!strcasecomp(new_tag->name, "LEGEND") ||
		!strcasecomp(new_tag->name, "FORM")) {
#else
d1328 2
a1329 2
	    if (ok) {
#endif
d1334 2
a1335 2
		CTRACE(tfp, "SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			    new_tag->name);
d1341 2
a1342 2
		CTRACE(tfp, "SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			    new_tag->name);
d1350 2
a1351 2
    CTRACE(tfp, "SGML: Start <%s>\n", new_tag->name);
    (*context->actions->start_element)(
d1353 1
a1353 1
	new_tag - context->dtd->tags,
d1358 2
d1361 1
a1361 1
	HTElement * N = (HTElement *)malloc(sizeof(HTElement));
d1367 2
a1368 3
#if !OPT
    } else if (!strcasecomp(new_tag->name, "META")) {
#else
a1369 1
#endif
d1392 1
a1392 1
	CONST char *,		string)
d1395 5
d1402 2
a1403 2
	 high > low;
	 diff < 0 ? (low = i+1) : (high = i)) {	 /* Binary search */
d1405 2
a1406 1
	diff = AS_casecomp(dtd->tags[i].name, string);	/* Case insensitive */
d1408 2
a1409 1
	    return &dtd->tags[i];
d1412 1
a1412 1
    if (isalpha((unsigned char)string[0])) {
d1443 1
d1452 7
a1458 3
	FREE(cur);
	(*context->actions->end_element)(context->target,
		 t - context->dtd->tags, (char **)&context->include);
d1472 1
a1472 1
	FREE(context->value[i]);
d1475 2
a1476 2
#ifdef USE_PSRC
    sgml_in_psrc_was_initialized =FALSE;
d1497 1
d1507 1
a1507 1
	FREE(cur);
d1515 1
a1515 1
	FREE(context->value[i]);
d1518 2
a1519 2
#ifdef USE_PSRC
    sgml_in_psrc_was_initialized =FALSE;
a1520 1

d1554 1
a1554 1
    char * p;
d1557 4
d1562 1
d1573 1
a1573 1
    clong = (unsigned char)c;	/* a.k.a. unsign_c */
d1581 1
a1581 1
	if (TOASCII((unsigned char)c) > 127) { /* S/390 -- gil -- 0710 */
d1718 1
a1718 2
		    for (p = replace_buf; *p; p++)
			PUTC(*p);
d1744 3
d1759 1
a1759 1
    clong = (unsigned char)c;
d1781 1
a1781 1
	return;
d1791 1
a1791 1
	return;
d1799 20
a1818 1
	return;
d1823 5
d1842 1
d1846 12
d1871 1
a1871 1
	    PUTC(c);
d1882 13
d1896 8
a1903 6
	    (!context->element_stack ||
	     (context->element_stack->tag  &&
	      (context->element_stack->tag->contents == SGML_MIXED ||
	       context->element_stack->tag->contents == SGML_ELEMENT ||
	       context->element_stack->tag->contents == SGML_PCDATA ||
	       context->element_stack->tag->contents == SGML_RCDATA)))) {
d1914 75
a1988 5
	    context->state = (context->element_stack &&
			context->element_stack->tag  &&
			context->element_stack->tag->contents == SGML_LITTERAL)
					 ?
			      S_litteral : S_tag;
d1995 1
d2003 1
d2021 1
a2021 1
	} else if ((chk = (context->T.trans_from_uni && TOASCII(unsign_c) >= 160)) &&  /* S/390 -- gil -- 0968 */
d2025 2
a2026 2
	    CTRACE(tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck));
d2046 1
a2046 2
	    for (p = replace_buf; *p; p++)
		PUTC(*p);
d2069 1
a2069 2
	    int i;
#ifdef USE_PSRC
d2075 1
a2075 2
	    for (i = 0; EntityName[i]; i++)
		HTChunkPutc(string, EntityName[i]);
d2077 1
a2077 1
#ifdef USE_PSRC
d2084 1
a2084 1
#ifdef USE_PSRC
d2107 1
a2107 2
	    for (p = context->utf_buf; *p; p++)
		PUTC(*p);
d2115 2
a2116 2
		   ((unsigned char)saved_char_in >= 0xc0) &&
		   ((unsigned char)saved_char_in < 255)) {
d2128 1
a2128 1
	} else if (TOASCII((unsigned char)c) <	 /* S/390 -- gil -- 0997 */
a2130 41
#ifdef NOTUSED_FOTEMODS
	    /*
	    **	If we do not have the "7-bit approximations" as our
	    **	output character set (in which case we did it already)
	    **	seek a translation for that.  Otherwise, or if the
	    **	translation fails, use UHHH notation. - FM
	    */
	    if ((chk = (context->outUCLYhndl !=
			UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(unsign_c,
				      UCGetLYhndl_byMIME("us-ascii")))
				      >= ' ' && TOASCII(uck) < 127) {  /* S/390 -- gil -- 1008 */
		/*
		**  Got an ASCII character (yippey). - FM
		*/
		PUTC(((char)FROMASCII(TOASCII(uck) & 0xff)));
	    } else if ((chk && uck == -4) &&
		       (uck = UCTransUniCharStr(replace_buf,
						60, clong,
						UCGetLYhndl_byMIME("us-ascii"),
						0) >= 0)) {
		/*
		**  Got a replacement string (yippey). - FM
		*/
		for (p = replace_buf; *p; p++)
		    PUTC(*p);
	    } else {
#endif /* NOTUSED_FOTEMODS */
		/*
		**  Out of luck, so use the UHHH notation (ugh). - FM
		*/
			/* S/390 -- gil -- 1018 */
			/* do not print UHHH for now
		sprintf(replace_buf, "U%.2lX", TOASCII(unsign_c));
		for (p = replace_buf; *p; p++) {
		    PUTC(*p);
		}
			 */
#ifdef NOTUSED_FOTEMODS
	    }
#endif /* NOTUSED_FOTEMODS */
d2140 59
d2202 1
d2205 25
a2229 3
	if (TOUPPER(c) != ((string->size == 1) ?
					   '/' :
			context->element_stack->tag->name[string->size-2])) {
d2236 27
a2262 1
		(!context->element_stack->tag->name[string->size-2])) {
d2269 43
d2313 1
a2313 1
	    **	If Mismatch: recover string.
d2342 4
a2345 1
		  isalnum((unsigned char)c) : isalpha((unsigned char)c))) {
d2355 1
a2355 1
#ifdef USE_PSRC
d2360 1
a2360 1
#ifdef USE_PSRC
d2371 1
a2371 1
#ifdef USE_PSRC
d2375 1
a2375 1
	    /* CTRACE(tfp, "%s: %d: %s\n", __FILE__, __LINE__, string->data); */
d2385 1
a2385 1
		CTRACE(tfp, "SGML_character: Handling 'zwnj' entity as 'WBR' element.\n");
d2412 1
a2412 1
#ifdef USE_PSRC
d2414 1
a2414 1
		HTMLSRC_apply_markup(context,HTL_entity, START);
d2416 1
a2416 1
		HTMLSRC_apply_markup(context,HTL_entity, STOP);
d2428 1
a2428 1
	if (TOASCII(unsign_c) < 127 && TOLOWER((unsigned char)c) == 'x') {  /* S/390 -- gil -- 1060 */
d2431 1
a2431 1
	} else if (TOASCII(unsign_c) < 127 && isdigit((unsigned char)c)) {
d2443 1
a2443 1
#ifdef USE_PSRC
d2449 1
a2449 1
#ifdef USE_PSRC
d2462 2
a2463 2
	/* S/390 -- gil -- 1075 */ /* CTRACE(tfp, "%s: %d: numeric %d %d\n",
			    __FILE__, __LINE__, unsign_c, c); */
d2465 2
a2466 2
	    (context->isHex ? isxdigit((unsigned char)c) :
			      isdigit((unsigned char)c))) {
d2476 1
a2476 1
#ifdef USE_PSRC
d2480 2
a2481 4
	    PUTC('&');
	    PUTC('#');
	    PUTC('x');
#ifdef USE_PSRC
d2495 1
a2495 1
#ifdef USE_PSRC
d2648 1
a2648 1
		    CTRACE(tfp, "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n");
d2678 1
a2678 1
#ifdef USE_PSRC
d2703 1
a2703 1
#ifdef USE_PSRC
d2707 1
a2707 1
#ifdef USE_PSRC
d2709 1
a2709 5
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
d2721 1
a2721 1
#ifdef USE_PSRC
d2723 1
a2723 5
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
d2726 1
a2726 3
		    for (p = replace_buf; *p; p++) {
			PUTC(*p);
		    }
a2731 47
#ifdef NOTUSED_FOTEMODS
		/*
		**  If the value is greater than 255 and we do not
		**  have the "7-bit approximations" as our output
		**  character set (in which case we did it already)
		**  seek a translation for that. - FM
		*/
		} else if ((chk = ((code > 255) &&
				   context->outUCLYhndl !=
				   UCGetLYhndl_byMIME("us-ascii"))) &&
			   (uck = UCTransUniChar(code,
				   UCGetLYhndl_byMIME("us-ascii")))
				  >= ' ' && uck < 127) {
		    /*
		    **	Got an ASCII character (yippey). - FM
		    */
#ifdef USE_PSRC
		    if (psrc_view) {
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
		    } else
#endif
		    PUTC(((char)FROMASCII(uck & 0xff)));
/* =============== work in ASCII above here ===============  S/390 -- gil -- 1118 */
		} else if ((chk && uck == -4) &&
			   (uck = UCTransUniCharStr(replace_buf,
						    60, code,
						UCGetLYhndl_byMIME("us-ascii"),
						    0) >= 0)) {
		    /*
		    **	Got a replacement string (yippey). - FM
		    */
#ifdef USE_PSRC
		    if (psrc_view) {
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
		    } else
#endif
		    for (p = replace_buf; *p; p++)
			PUTC(*p);
#endif /* NOTUSED_FOTEMODS */
d2749 1
a2749 1
#ifdef USE_PSRC
d2791 1
a2791 1
#ifdef USE_PSRC
a2795 2
			PUTC('&');
			PUTC('#');
d2797 1
a2797 1
			    PUTC('x');
d2799 2
d2805 1
a2805 1
#ifdef USE_PSRC
d2820 1
a2820 1
#ifdef USE_PSRC
d2822 1
a2822 5
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
d2834 1
a2834 2
			for (i = 0; EntityName[i]; i++)
			    HTChunkPutc(string, EntityName[i]);
d2849 1
a2849 1
#ifdef USE_PSRC
a2852 2
			PUTC('&');
			PUTC('#');
d2854 1
a2854 1
			    PUTC('x');
d2856 2
d2862 1
a2862 1
#ifdef USE_PSRC
d2895 1
a2895 1
#ifdef USE_PSRC
d2899 7
a2905 3
		PUTC('&');
		PUTC('#');
#ifdef USE_PSRC
a2908 4
		if (context->isHex) {
		    PUTC('x');
		    context->isHex = FALSE;
		}
d2928 1
a2928 1
		  isalnum((unsigned char)c) : isalpha((unsigned char)c))) {
d2956 1
a2956 1
#ifdef USE_PSRC
d2961 1
a2961 1
#ifdef USE_PSRC
d2972 5
a2976 4
		if (string->size != 0)
		    CTRACE(tfp,"SGML: `<%s/' found!\n", string->data);
		context->state = S_end;
		break;
d2981 4
a2984 2
	    if (t == context->unknown_tag && c == ':' &&
		0 == strcasecomp(string->data, "URL")) {
d2989 1
a2989 2
		int i;
#ifdef USE_PSRC
d2994 1
a2994 2
		for (i = 0; i < 3; i++) /* recover */
		    PUTC(string->data[i]);
d2996 1
a2996 1
#ifdef USE_PSRC
d3000 2
a3001 2
		CTRACE(tfp, "SGML: Treating <%s%c as text\n",
			    string->data, c);
d3005 26
a3030 3
	    } else if (!t) {
		CTRACE(tfp, "SGML: *** Invalid element %s\n",
			    string->data);
d3032 1
a3032 1
#ifdef USE_PSRC
d3034 3
a3036 1
		    PSRCSTART(abracket);PUTC('<');PSRCSTOP(abracket);
a3044 1

d3047 5
a3051 1
			PSRCSTART(abracket);PUTC('>');PSRCSTOP(abracket);
d3058 2
a3059 2
		CTRACE(tfp, "SGML: *** Unknown element %s\n",
			    string->data);
d3068 1
a3068 4
	    /*
	    **	Clear out attributes.
	    */
#ifdef USE_PSRC
d3070 3
a3072 1
		PSRCSTART(abracket);PUTC('<');PSRCSTOP(abracket);
d3084 4
d3092 3
a3094 5
#if !OPT1
		int i;
		for (i = 0; i < context->current_tag->number_of_attributes; i++)
		    context->present[i] = NO;
#else
a3096 1
#endif
d3101 1
a3101 1
#ifdef USE_PSRC
d3103 9
a3111 9
		if (c == '>') {
		    if (t != context->unknown_tag)
			PSRCSTOP(tag);
		    else
			PSRCSTOP(badtag);
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		    context->state = S_text;
d3113 2
d3119 1
a3119 1
	    if (c == '>') {
d3122 2
a3123 1
		context->state = S_text;
d3169 1
a3169 1
#ifdef USE_PSRC
d3238 1
a3238 1
#ifdef USE_PSRC
d3242 1
a3242 1
		    PUTS(string->data);
d3254 1
a3254 2
	    HTChunkPutc(string, c);
	    break;
d3279 8
a3286 8
#ifdef USE_PSRC
		if (psrc_view) {
		    PSRCSTART(comm);
		    PUTC('<');
		    PUTS(string->data);
		    PUTC('>');
		    PSRCSTOP(comm);
		} else
d3288 1
a3288 1
	    handle_comment(context);
d3296 1
a3296 1
	if (context->end_comment && !isspace(c))
d3298 24
a3321 1
	HTChunkPutc(string, c);
d3338 1
a3338 1
#ifdef USE_PSRC
d3370 1
a3370 1
#ifdef USE_PSRC
d3404 1
a3404 1
#ifdef USE_PSRC
d3441 1
a3441 1
#ifdef USE_PSRC
d3478 1
a3478 1
#ifdef USE_PSRC
d3502 1
a3502 1
#ifdef USE_PSRC
d3507 1
a3507 1
#ifdef USE_PSRC
a3508 4
		if (context->current_tag != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d3526 1
a3526 1
#ifdef USE_PSRC
d3536 2
a3537 2
#ifdef USE_PSRC
	    }  else {
d3550 1
a3551 1
		    if (c == '=' ) PUTC('=');
a3557 4
		    if (context->current_tag != context->unknown_tag)
			PSRCSTOP(tag);
		    else
			PSRCSTOP(badtag);
d3577 1
a3577 1
#ifdef USE_PSRC
d3579 1
a3579 1
		if (context->current_attribute_number == INVALID)
d3581 1
a3581 1
		else
d3583 1
a3583 4
		if (context->current_tag != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d3587 1
a3587 1
	} else
d3594 1
a3594 1
#ifdef USE_PSRC
d3597 1
a3597 1
		if (context->current_attribute_number == INVALID)
d3599 1
a3599 1
		else
d3601 1
a3606 7
#ifdef USE_PSRC
	/* we are here because this char seemed the beginning of attrname */
	if (psrc_view && context->current_attribute_number == INVALID) {
	    PSRCSTOP(badattr);
	    PUTC(' ');
	}
#endif
d3615 2
a3616 2
	    CTRACE(tfp, "SGML: found = but no value\n");
#ifdef USE_PSRC
a3617 4
		if (context->current_tag != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d3629 1
a3629 1
#ifdef USE_PSRC
d3639 1
a3639 1
#ifdef USE_PSRC
d3648 1
a3648 1
#ifdef USE_PSRC
d3653 1
a3653 1
	/*  no break!  fall through to S_value and proccess current `c`	 */
d3658 1
a3658 1
#ifdef USE_PSRC
d3661 1
a3661 1
		if (cur_attr_is_name) {
d3667 1
a3667 1
		} else if (cur_attr_is_href) {
d3672 1
a3672 1
		if (cur_attr_is_href) {
d3682 11
d3696 1
a3696 1
#ifdef USE_PSRC
a3697 4
		    if (context->current_tag != context->unknown_tag)
			PSRCSTOP(tag);
		    else
			PSRCSTOP(badtag);
d3719 1
a3719 1
		(unsigned char)saved_char_in >=
d3722 1
a3722 1
				   (0xf000 | (unsigned char)saved_char_in));
d3736 1
a3736 1
#ifdef USE_PSRC
d3739 2
a3740 2
		if (cur_attr_is_name) {
		    HTStartAnchor(context->target,string->data,NULL);
d3745 1
a3745 1
		} else if (cur_attr_is_href) {
d3750 1
a3750 1
		if (cur_attr_is_href) {
d3781 1
a3781 1
		(unsigned char)saved_char_in >=
d3784 1
a3784 1
				   (0xf000 | (unsigned char)saved_char_in));
d3800 1
a3800 1
#ifdef USE_PSRC
d3803 2
a3804 2
		if (cur_attr_is_name) {
		    HTStartAnchor(context->target,string->data,NULL);
d3809 1
a3809 1
		} else if (cur_attr_is_href) {
d3814 1
a3814 1
		if (cur_attr_is_href) {
d3848 1
a3848 1
		(unsigned char)saved_char_in >=
d3851 1
a3851 1
				   (0xf000 | (unsigned char)saved_char_in));
d3863 2
a3864 1
	if (TOASCII(unsign_c) < 127 && isalnum((unsigned char)c)) {  /* S/390 -- gil -- 1247 */
d3868 1
a3868 1
#ifdef USE_PSRC
d3880 2
a3881 2
		CTRACE(tfp, "Unknown end tag </%s>\n", string->data);
#ifdef USE_PSRC
d3884 1
a3884 2
		    PUTC('<');
		    PUTC('/');
d3893 9
a3901 2
		    PUTS(string->data); PSRCSTOP(badtag);
		    PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
d3907 1
a3907 1
		BOOL tag_OK = (c == '>' || WHITE(c));
d3909 1
a3909 1
		HTMLElement e = context->current_tag - context->dtd->tags;
d3913 4
d3918 1
d3920 1
a3920 3
		if (tag_OK && Old_DTD) {
#else
		if (tag_OK) {
d3922 1
d3935 2
a3949 2

#if !OPT
d3951 3
d3964 1
a3964 3
		     !strcasecomp(string->data, "COLGROUP"))) {
#else
		if (tag_OK && branch == 0) {
d3966 1
d3971 2
a3972 2
		    CTRACE(tfp, "SGML: `</%s%c' found!  ***Ignoring it.\n",
				string->data, c);
d3978 1
a3981 1
#if !OPT
d3983 3
d3997 1
a3997 3
			    !strcasecomp(string->data, "U"))) {
#else
		} else if (tag_OK && branch == 1) {
d3999 1
d4015 2
a4016 2
			    CTRACE(tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
					string->data);
d4022 2
a4023 2
			    CTRACE(tfp, "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
					string->data);
d4026 1
a4026 1
			    CTRACE(tfp, "SGML: End </%s>\n", string->data);
d4028 3
d4033 1
a4033 1
				 (context->current_tag - context->dtd->tags),
d4041 2
a4042 2
			CTRACE(tfp, "SGML: `</%s%c' found!  ***Treating as '<%s%c'.\n",
				    string->data, c, string->data, c);
d4054 1
a4054 1
			CTRACE(tfp, "SGML: End </%s>\n", string->data);
d4056 3
d4061 1
a4061 1
			     (context->current_tag - context->dtd->tags),
d4069 1
d4081 1
a4081 1
#ifdef USE_PSRC
d4084 1
a4084 2
		PUTC('<');
		PUTC('/');
d4093 3
a4095 2
		PUTS(string->data); PSRCSTOP(tag);
		if ( c != '>' )
d4097 2
a4098 1
		else {
d4110 1
a4110 1
		    CTRACE(tfp,"SGML: `</%s%c' found!\n", string->data, c);
d4113 1
d4165 2
d4264 1
d4266 1
a4266 1
#ifdef USE_PSRC
d4268 3
a4270 1
		PSRCSTOP(badtag);
d4274 1
a4274 1
		seen_letter_in_junk_tag = FALSE;
d4277 1
d4280 1
a4280 1
#ifdef USE_PSRC
d4283 1
a4283 1
	    if (!seen_letter_in_junk_tag) {
d4285 1
a4285 1
		    seen_letter_in_junk_tag = TRUE;
d4287 1
a4287 1
		};
d4290 1
a4290 1
	};
d4294 26
d4336 3
a4338 2
    **	Check whether an external function has added
    **	anything to the include buffer. - FM
d4340 3
a4342 3
    if (context->include != NULL) {
	if (context->include[context->include_index] == '\0') {
	    FREE(context->include);
d4345 27
a4371 3
	    c = context->include[context->include_index];
	    context->include_index++;
	    goto top;
d4450 2
d4457 2
d4460 1
d4463 1
d4494 13
d4514 1
d4520 1
a4520 1
#ifdef USE_PSRC
d4523 3
a4525 2
	SGML_string(context, "<HTML><HEAD><TITLE>source</TITLE></HEAD>"
			     "<BODY><PRE>") ;
d4529 1
a4529 1
	seen_letter_in_junk_tag = FALSE;
d4647 15
d4667 2
a4668 2
    HI -= (HI <= 0x9F) ? 0x71 : 0xB1;
    HI = (HI << 1) + 1;
d4672 1
a4672 1
	LO -= 0x7D;
d4675 1
a4675 1
	LO -= 0x1F;
d4688 1
a4688 1
	LO += 0x1F;
d4690 1
a4690 1
	LO += 0x7D;
d4694 1
a4694 1
    HI = ((HI - 0x21) >> 1) + 0x81;
d4696 1
a4696 1
	HI += 0x40;
d4707 3
a4709 2
    if (HI == 0x8E) JISx0201TO0208_EUC(HI, LO, &HI, &LO);
    JIS_TO_SJIS1(HI&0x7F, LO&0x7F, SJCODE);
d4720 2
a4721 2
    JISx0201TO0208_EUC(216, I, OHI, OLO);
    JIS_TO_SJIS1(*OHI&0x7F, *OLO&0x7F, SJCODE);
d4744 2
a4745 1
    for (sp = src, dp = dst; (0 != (hi = sp[0]));) {
d4748 1
a4748 1
	    SJIS_TO_JIS1(hi,lo,dp);
d4753 1
a4753 1
	} else {
a4754 1
	}
d4769 1
a4769 1
		JIS_TO_SJIS1(sp[0]&0x7F, sp[1]&0x7F, dp);
d4783 3
a4785 1
PUBLIC unsigned char * EUC_TO_JIS ARGS4(
d4795 1
a4795 1
    register int i;
d4797 1
a4797 1
    while (0 != (cch = *sp++)) {
d4799 7
d4807 2
a4808 4
		kana_mode = ~kana_mode;
		for (i = 0; toK[i]; i++) {
		    *dp++ = (unsigned char)toK[i];
		}
d4811 2
a4812 2
		*dp++ = cch & ~0x80;
		*dp++ = *sp++ & ~0x80;
d4816 2
a4817 5
		kana_mode = ~kana_mode;
		for (i = 0; toA[i]; i++) {
		    *dp++ = (unsigned char)toA[i];
		    *dp = '\0';
		}
d4822 2
a4823 5
    if (kana_mode) {
	for (i = 0; toA[i]; i++) {
	    *dp++ = (unsigned char)toA[i];
	}
    }
d4830 32
a4861 1
PUBLIC unsigned char * TO_EUC ARGS2(
d4866 2
a4867 1
    register unsigned char *d, c, jis_stat;
d4870 3
d4874 2
d4881 2
d4884 15
a4898 1
    while (0 != (c = *s++)) {
d4901 1
a4901 1
		if ((s[1] == 'B') || (s[1] == '@@') || (s[1] == 'A')) {
d4904 1
d4906 6
a4911 3
		} else if ((s[1] == '(') && s[2] && (s[2] == 'C')) {
		    jis_stat = 0x80;
		    s += 3;
d4914 2
a4915 9
	    } else {
		if (*s == to1B) {
		    if ((s[1]=='B') || (s[1]=='J') ||
			(s[1]=='H') || (s[1]=='T')) {
			jis_stat = 0;
			s += 2;
			continue;
		    }
		}
d4918 4
a4921 1
	if (IS_SJIS(c,*s,in_sjis)) {
d4925 13
d4939 1
a4939 2
	    if (jis_stat && (0x20 < c)) {
		*d++ = jis_stat | c;
d4949 24
d4979 3
a4981 5
    if (!any || !sjis)
	return;

    euc = (unsigned char*)malloc(strlen((CONST char *)any)+1);
    if (euc == NULL)
d4983 1
a4983 1

d4985 5
a4989 2
    EUC_TO_SJIS(euc, sjis);
    FREE(euc);
d4998 2
a4999 1
    if (!any || !jis)
d5001 4
a5004 3

    euc = (unsigned char*)malloc(strlen((CONST char *)any)+1);
    if (euc == NULL)
d5006 1
a5006 1

d5008 1
d5010 2
a5011 1
    FREE(euc);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 9
a10 9
 *			========================
 *
 *	This module implements an HTStream object.  To parse an
 *	SGML file, create this object which is a parser.  The object
 *	is (currently) created by being passed a DTD structure,
 *	and a target HTStructured object at which to throw the parsed stuff.
 *
 *	 6 Feb 93  Binary searches used. Interface modified.
 */
a28 1
#include <HTUtils.h>
d31 1
a31 2
#include <LYCharVals.h>		/* S/390 -- gil -- 0635 */
#include <LYGlobalDefs.h>
d38 1
a38 1
#ifdef USE_PRETTYSRC
d44 1
a44 5
#ifdef USE_PRETTYSRC

static char *entity_string;	/* this is used for printing entity name.

				   Unconditionally added since redundant assigments don't hurt much */
d46 11
a56 2
static void fake_put_character(void *p GCC_UNUSED,
			       char c GCC_UNUSED)
d65 19
d86 1
a86 17
/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
#define my_casecomp(a,b)  ((TOUPPER(*a) == TOUPPER(*b)) ? \
			AS_casecomp(a,b) : \
			(TOASCII(TOUPPER(*a)) - TOASCII(TOUPPER(*b))))

 /* will use partially inlined version */
#define orig_HTChunkPutUtf8Char HTChunkPutUtf8Char
#undef HTChunkPutUtf8Char

/* ...used for comments and attributes value like href... */
#define HTChunkPutUtf8Char(ch,x) \
    { \
    if ((TOASCII(x) < 128)  && (ch->size < ch->allocated)) \
	ch->data[ch->size++] = (char)x; \
    else \
	orig_HTChunkPutUtf8Char(ch,x); \
    }
a87 4
#define PUTS(str) ((*context->actions->put_string)(context->target, str))
#define PUTC(ch)  ((*context->actions->put_character)(context->target, ch))
#define PUTUTF8(code) (UCPutUtf8_charstring((HTStream *)context->target, \
		      (putc_func_t*)(context->actions->put_character), code))
d89 3
a91 1
#define OPT 1
d96 7
a102 5
HTCJKlang HTCJK = NOCJK;	/* CJK enum value.              */
BOOL HTPassEightBitRaw = FALSE;	/* Pass 161-172,174-255 raw.    */
BOOL HTPassEightBitNum = FALSE;	/* Pass ^ numeric entities raw. */
BOOL HTPassHighCtrlRaw = FALSE;	/* Pass 127-160,173,&#127; raw. */
BOOL HTPassHighCtrlNum = FALSE;	/* Pass &#128;-&#159; raw.      */
d105 4
a108 4
 *
 *	This is passed with each call to make the parser reentrant
 *
 */
d112 1
d114 4
a117 4
 *		-------------
 *	This allows us to return down the stack reselecting styles.
 *	As we return, attribute values will be garbage in general.
 */
d120 2
a121 2
    HTElement *next;		/* Previously nested element or 0 */
    HTTag *tag;			/* The tag at this level  */
a123 45
typedef enum {
    S_text = 0
    ,S_attr
    ,S_attr_gap
    ,S_comment
    ,S_cro
    ,S_doctype
    ,S_dollar
    ,S_dollar_dq
    ,S_dollar_paren
    ,S_dollar_paren_dq
    ,S_dollar_paren_sq
    ,S_dollar_sq
    ,S_dquoted
    ,S_end
    ,S_entity
    ,S_equals
    ,S_ero
    ,S_esc
    ,S_esc_dq
    ,S_esc_sq
    ,S_exclamation
    ,S_in_kanji
    ,S_incro
    ,S_junk_pi
    ,S_junk_tag
    ,S_litteral
    ,S_marked
    ,S_nonascii_text
    ,S_nonascii_text_dq
    ,S_nonascii_text_sq
    ,S_paren
    ,S_paren_dq
    ,S_paren_sq
    ,S_pcdata
    ,S_script
    ,S_sgmlatt
    ,S_sgmlele
    ,S_sgmlent
    ,S_squoted
    ,S_tag
    ,S_tag_gap
    ,S_tagname_slash
    ,S_value
} sgml_state;
d126 2
a127 2
 *	-------------------------------
 */
d130 1
a130 1
    const HTStreamClass *isa;	/* inherited from HTStream */
d132 23
a154 16
    const SGML_dtd *dtd;
    const HTStructuredClass *actions;	/* target class  */
    HTStructured *target;	/* target object */

    HTTag *current_tag;
    HTTag *slashedtag;
    const HTTag *unknown_tag;
    BOOL inSELECT;
    BOOL no_lynx_specialcodes;
    int current_attribute_number;
    HTChunk *string;
    int leading_spaces;
    int trailing_spaces;
    HTElement *element_stack;
    sgml_state state;
    unsigned char kanji_buf;
d156 2
a157 2
    void *callerData;
#endif				/* CALLERDATA */
d159 1
a159 36
    char *value[MAX_ATTRIBUTES];	/* NULL, or strings alloc'd with StrAllocCopy_extra() */

    BOOL lead_exclamation;
    BOOL first_dash;
    BOOL end_comment;
    BOOL doctype_bracket;
    BOOL first_bracket;
    BOOL second_bracket;
    BOOL isHex;

    HTParentAnchor *node_anchor;
    LYUCcharset *inUCI;		/* pointer to anchor UCInfo */
    int inUCLYhndl;		/* charset we are fed       */
    LYUCcharset *outUCI;	/* anchor UCInfo for target */
    int outUCLYhndl;		/* charset for target       */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
    UCTransParams T;
    int current_tag_charset;	/* charset to pass attributes */

    char *recover;
    int recover_index;
    char *include;
    char *active_include;
    int include_index;
    char *url;
    char *csi;
    int csi_index;
#ifdef USE_PRETTYSRC
    BOOL cur_attr_is_href;
    BOOL cur_attr_is_name;
    BOOL seen_nonwhite_in_junk_tag;
#endif
};
d161 36
a196 2
#ifndef NO_LYNX_TRACE
static const char *state_name(sgml_state n)
d198 1
a198 79
    const char *result = "?";
    /* *INDENT-OFF* */
    switch (n) {
    case S_attr:                result = "S_attr";              break;
    case S_attr_gap:            result = "S_attr_gap";          break;
    case S_comment:             result = "S_comment";           break;
    case S_cro:                 result = "S_cro";               break;
    case S_doctype:             result = "S_doctype";           break;
    case S_dollar:              result = "S_dollar";            break;
    case S_dollar_dq:           result = "S_dollar_dq";         break;
    case S_dollar_paren:        result = "S_dollar_paren";      break;
    case S_dollar_paren_dq:     result = "S_dollar_paren_dq";   break;
    case S_dollar_paren_sq:     result = "S_dollar_paren_sq";   break;
    case S_dollar_sq:           result = "S_dollar_sq";         break;
    case S_dquoted:             result = "S_dquoted";           break;
    case S_end:                 result = "S_end";               break;
    case S_entity:              result = "S_entity";            break;
    case S_equals:              result = "S_equals";            break;
    case S_ero:                 result = "S_ero";               break;
    case S_esc:                 result = "S_esc";               break;
    case S_esc_dq:              result = "S_esc_dq";            break;
    case S_esc_sq:              result = "S_esc_sq";            break;
    case S_exclamation:         result = "S_exclamation";       break;
    case S_in_kanji:            result = "S_in_kanji";          break;
    case S_incro:               result = "S_incro";             break;
    case S_junk_pi:             result = "S_junk_pi";           break;
    case S_junk_tag:            result = "S_junk_tag";          break;
    case S_litteral:            result = "S_litteral";          break;
    case S_marked:              result = "S_marked";            break;
    case S_nonascii_text:       result = "S_nonascii_text";     break;
    case S_nonascii_text_dq:    result = "S_nonascii_text_dq";  break;
    case S_nonascii_text_sq:    result = "S_nonascii_text_sq";  break;
    case S_paren:               result = "S_paren";             break;
    case S_paren_dq:            result = "S_paren_dq";          break;
    case S_paren_sq:            result = "S_paren_sq";          break;
    case S_pcdata:              result = "S_pcdata";            break;
    case S_script:              result = "S_script";            break;
    case S_sgmlatt:             result = "S_sgmlatt";           break;
    case S_sgmlele:             result = "S_sgmlele";           break;
    case S_sgmlent:             result = "S_sgmlent";           break;
    case S_squoted:             result = "S_squoted";           break;
    case S_tag:                 result = "S_tag";               break;
    case S_tag_gap:             result = "S_tag_gap";           break;
    case S_tagname_slash:       result = "S_tagname_slash";     break;
    case S_text:                result = "S_text";              break;
    case S_value:               result = "S_value";             break;
    }
    /* *INDENT-ON* */

    return result;
}
#endif

/* storage for Element Stack */
#define DEPTH 10
static HTElement pool[DEPTH];
static int depth = 0;

static HTElement *pool_alloc(void)
{
    depth++;
    if (depth > DEPTH)
	return (HTElement *) malloc(sizeof(HTElement));
    return (pool + depth - 1);
}

static void pool_free(HTElement * e)
{
    if (depth > DEPTH)
	FREE(e);
    depth--;
    return;
}

#ifdef USE_PRETTYSRC

static void HTMLSRC_apply_markup(HTStream *context, HTlexeme lexeme, BOOL start)
{
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);
d209 1
a209 1
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
d211 7
a217 6
	    (*context->actions->start_element) (context->target,
						ts->element,
						ts->present,
						(const char **) ts->value,
						context->current_tag_charset,
						&context->include);
d219 4
a222 3
	    (*context->actions->end_element) (context->target,
					      ts->element,
					      &context->include);
d227 2
a228 2
#define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_##x,START)
#define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_##x,STOP)
d230 2
a231 2
#define attr_is_href context->cur_attr_is_href
#define attr_is_name context->cur_attr_is_name
d234 4
a237 2
static void set_chartrans_handling(HTStream *context, HTParentAnchor *anchor,
				   int chndl)
d241 4
a244 3
	 * Nothing was set for the parser in earlier stages, so the HTML
	 * parser's UCLYhndl should still be its default.  - FM
	 */
d248 2
a249 2
	     * That wasn't set either, so seek the HText default.  - FM
	     */
d253 3
a255 3
	     * That wasn't set either, so assume the current display character
	     * set.  - FM
	     */
d258 4
a261 4
	 * Try to set the HText and HTML stages' chartrans info with the
	 * default lock level (will not be changed if it was set previously
	 * with a higher lock level).  - FM
	 */
d269 2
a270 2
	 * Get the chartrans info for output to the HTML parser.  - FM
	 */
d277 2
a278 2
     * Set the in->out transformation parameters.  - FM
     */
d283 7
a289 6
     * This is intended for passing the SGML parser's input charset as an
     * argument in each call to the HTML parser's start tag function, but it
     * would be better to call a Lynx_HTML_parser function to set an element in
     * its HTStructured object, itself, if this were needed.  - FM
     */
#ifndef EXP_JAPANESEUTF8_SUPPORT
d292 1
a292 3
    } else
#endif
    if (context->T.transp) {
d307 2
a308 1
static void change_chartrans_handling(HTStream *context)
a311 1

d315 1
a315 1
	 * Something changed.  but ignore if a META wants an unknown charset.
d317 2
a318 3
	LYUCcharset *new_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
						       UCT_STAGE_PARSER);

d320 6
a325 4
	    LYUCcharset *next_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
							    UCT_STAGE_STRUCTURED);
	    int next_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor, UCT_STAGE_STRUCTURED);

d336 8
d346 1
a346 1
static int current_is_class = 0;
d350 3
a352 3
 *	----------------
 */
/* PUBLIC const char * SGML_default = "";   ?? */
d354 3
a356 1
static void handle_attribute_name(HTStream *context, const char *s)
d358 3
a360 2
    HTTag *tag = context->current_tag;
    attr *attributes = tag->attributes;
d363 1
a363 1
#ifdef USE_PRETTYSRC
d365 2
a366 2
	attr_is_href = FALSE;
	attr_is_name = FALSE;
d370 2
a371 2
     * Ignore unknown tag.  - KW
     */
d373 1
a373 1
#ifdef USE_PRETTYSRC
d375 1
a375 1
	    context->current_attribute_number = 1;	/* anything !=INVALID */
d381 2
a382 2
     * Binary search for attribute name.
     */
d385 4
a388 4
	 diff < 0 ? (low = i + 1) : (high = i)) {
	i = (low + (high - low) / 2);
	diff = my_casecomp(attributes[i].name, s);
	if (diff == 0) {	/* success: found it */
d390 2
a391 5
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		attr_is_name = (BOOL) (attributes[i].type == HTMLA_ANAME);
		attr_is_href = (BOOL) (attributes[i].type == HTMLA_HREF);
	    } else
d393 2
a394 3
	    {
		context->present[i] = YES;
		Clear_extra(context->value[i]);
d396 6
a401 2
#   ifdef USE_PRETTYSRC
		current_is_class = IS_C(attributes[i]);
d403 1
a403 1
		current_is_class = (!strcasecomp("class", s));
d405 1
a405 1
		CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
d407 5
d413 1
d415 3
a417 3
	}
	/* if */
    }				/* for */
d419 2
a420 2
    CTRACE((tfp, "SGML: Unknown attribute %s for tag %s\n",
	    s, context->current_tag->name));
d424 1
d426 5
a430 3
 *	----------------------
 */
static void handle_attribute_value(HTStream *context, const char *s)
d433 1
a433 1
	StrAllocCopy_extra(context->value[context->current_attribute_number], s);
d435 8
a442 5
	if (current_is_class) {
	    strncpy(class_string, s, TEMPSTRINGSIZE);
	    CTRACE((tfp, "SGML: class is '%s'\n", s));
	} else {
	    CTRACE((tfp, "SGML: attribute value is '%s'\n", s));
d446 1
a446 1
	CTRACE((tfp, "SGML: Attribute value %s ***ignored\n", s));
d448 1
a448 1
    context->current_attribute_number = INVALID;	/* can't have two assignments! */
d451 1
d453 12
a464 10
 *  Translate some Unicodes to Lynx special codes and output them.
 *  Special codes - ones those output depend on parsing.
 *
 *  Additional issue, like handling bidirectional text if necessary
 *  may be called from here:  zwnj (8204), zwj (8205), lrm (8206), rlm (8207)
 *  - currently they are ignored in SGML.c and LYCharUtils.c
 *  but also in UCdomap.c because they are non printable...
 *
 */
static BOOL put_special_unicodes(HTStream *context, UCode_t code)
d466 1
a466 9
    /* (Tgf_nolyspcl) */
    if (context->no_lynx_specialcodes) {
	/*
	 * We were asked by a "DTD" flag to not generate lynx specials.  - kw
	 */
	return NO;
    }

    if (code == CH_NBSP) {	/* S/390 -- gil -- 0657 */
d468 3
a470 3
	 * Use Lynx special character for nbsp.
	 */
#ifdef USE_PRETTYSRC
d473 2
a474 2
	    PUTC(HT_NON_BREAK_SPACE);
    } else if (code == CH_SHY) {
d476 3
a478 3
	 * Use Lynx special character for shy.
	 */
#ifdef USE_PRETTYSRC
d481 1
a481 1
	    PUTC(LY_SOFT_HYPHEN);
d484 12
a495 13
	 * Use Lynx special character for ensp or thinsp.
	 *
	 * Originally, Lynx use space '32' as word delimiter and omits this
	 * space at end of line if word is wrapped to the next line.  There are
	 * several other spaces in the Unicode repertoire and we should teach
	 * Lynx to understand them, not only as regular characters but in the
	 * context of line wrapping.  Unfortunately, if we use HT_EN_SPACE we
	 * override the chartrans tables for those spaces with a single '32'
	 * for all (but do line wrapping more fancy).
	 *
	 * We may treat emsp as one or two ensp (below).
	 */
#ifdef USE_PRETTYSRC
d498 1
a498 1
	    PUTC(HT_EN_SPACE);
d501 3
a503 3
	 * Use Lynx special character for emsp.
	 */
#ifdef USE_PRETTYSRC
d506 3
a508 3
	    /* PUTC(HT_EN_SPACE);  let's stay with a single space :) */
	    PUTC(HT_EN_SPACE);
#ifdef USE_PRETTYSRC
d513 2
a514 2
	 * Return NO if nothing done.
	 */
d518 2
a519 2
     * We have handled it.
     */
a522 21
#ifdef USE_PRETTYSRC
static void put_pretty_entity(HTStream *context, int term)
{
    PSRCSTART(entity);
    PUTC('&');
    PUTS(entity_string);
    if (term)
	PUTC((char) term);
    PSRCSTOP(entity);
}

static void put_pretty_number(HTStream *context)
{
    PSRCSTART(entity);
    PUTS((context->isHex ? "&#x" : "&#"));
    PUTS(entity_string);
    PUTC(';');
    PSRCSTOP(entity);
}
#endif /* USE_PRETTYSRC */

d524 15
a538 15
 *	-------------
 *
 * On entry,
 *	s	contains the entity name zero terminated
 * Bugs:
 *	If the entity name is unknown, the terminator is treated as
 *	a printable non-special character in all cases, even if it is '<'
 * Bug-fix:
 *	Modified SGML_character() so we only come here with terminator
 *	as '\0' and check a FoundEntity flag. -- Foteos Macrides
 *
 * Modified more (for use with Lynx character translation code):
 */
static char replace_buf[64];	/* buffer for replacement strings */
static BOOL FoundEntity = FALSE;
d540 3
a542 1
static void handle_entity(HTStream *context, char term)
d546 3
a548 1
    const char *s = context->string->data;
d551 2
a552 2
     * Handle all entities normally.  - FM
     */
d556 3
a558 3
	 * We got a Unicode value for the entity name.  Check for special
	 * Unicodes.  - FM
	 */
d560 1
a560 1
#ifdef USE_PRETTYSRC
d562 6
a567 1
		put_pretty_entity(context, term);
d574 2
a575 2
	 * Seek a translation from the chartrans tables.
	 */
d581 1
a581 1
#ifdef USE_PRETTYSRC
d583 3
a585 1
		put_pretty_entity(context, term);
d588 1
a588 1
		PUTC(FROMASCII((char) uck));
d594 3
a596 3
	    /*
	     * Not found; look for replacement string.
	     */
d599 1
a599 1
#ifdef USE_PRETTYSRC
d601 6
a606 1
		put_pretty_entity(context, term);
d609 2
a610 1
		PUTS(replace_buf);
d615 3
a617 3
	 * If we're displaying UTF-8, try that now.  - FM
	 */
#ifndef USE_PRETTYSRC
d623 3
a625 5
	if (context->T.output_utf8 && (psrc_view
				       ? (UCPutUtf8_charstring((HTStream *) context->target,
							       (putc_func_t *) (fake_put_character),
							       code))
				       : PUTUTF8(code))) {
d628 3
a630 1
		put_pretty_entity(context, term);
d638 2
a639 2
	 * If it's safe ASCII, use it.  - FM
	 */
d641 1
a641 1
#ifdef USE_PRETTYSRC
d643 6
a648 1
		put_pretty_entity(context, term);
d652 1
a652 1
		PUTC(FROMASCII((char) code));
d658 4
a661 3
	 * Ignore zwnj (8204) and zwj (8205), if we get to here.  Note that
	 * zwnj may have been handled as <WBR> by the calling function.  - FM
	 */
d664 2
a665 2
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
d667 6
a672 1
		put_pretty_entity(context, term);
d679 2
a680 2
	 * Ignore lrm (8206), and rln (8207), if we get to here.  - FM
	 */
d683 2
a684 2
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
d686 6
a691 1
		put_pretty_entity(context, term);
d700 3
a702 3
     * If entity string not found, display as text.
     */
#ifdef USE_PRETTYSRC
d706 1
a706 1
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long) code, uck));	/* S/390 -- gil -- 0695 */
d708 3
a710 1
    PUTS(s);
d713 1
a713 1
#ifdef USE_PRETTYSRC
d719 1
d721 4
a724 3
 *	--------------
 */
static void handle_comment(HTStream *context)
d726 1
a726 1
    const char *s = context->string->data;
d728 1
a728 1
    CTRACE((tfp, "SGML Comment:\n<%s>\n", s));
d732 2
a733 2
	LYCheckForCSI(context->node_anchor, &context->url) == TRUE) {
	LYDoCSI(context->url, s, &context->csi);
d741 1
d743 4
a746 3
 *	-----------------
 */
static void handle_identifier(HTStream *context)
d748 1
a748 1
    const char *s = context->string->data;
d750 1
a750 1
    CTRACE((tfp, "SGML Identifier:\n<%s>\n", s));
d755 1
d757 4
a760 3
 *	--------------
 */
static void handle_doctype(HTStream *context)
d762 1
a762 1
    const char *s = context->string->data;
d764 1
a764 1
    CTRACE((tfp, "SGML Doctype:\n<%s>\n", s));
a768 2
static void SGML_write(HTStream *me, const char *s,
		       int l);
d771 8
a778 19
 *	-------------
 */
static void handle_marked(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Marked Section:\n<%s>\n", s));

    if (!strncmp(context->string->data, "![INCLUDE[", 10)) {
	context->string->data[context->string->size - 3] = '\0';
	StrAllocCat(context->include, context->string->data + 10);
	/* @@@@@@ This needs to take charset into account! @@@@@@
	   the wrong assumptions will be made about the data's
	   charset once it is in include - kw */

    } else if (!strncmp(context->string->data, "![CDATA[", 8)) {
	(*context->actions->_write) (context->target,
				     context->string->data + 8,
				     context->string->size - 11);
a779 1
    }
d783 1
d785 4
a788 3
 *	--------------
 */
static void handle_sgmlent(HTStream *context)
d790 1
a790 1
    const char *s = context->string->data;
d792 1
a792 1
    CTRACE((tfp, "SGML Entity Declaration:\n<%s>\n", s));
d797 1
d799 4
a802 3
 *	--------------
 */
static void handle_sgmlele(HTStream *context)
d804 1
a804 1
    const char *s = context->string->data;
d806 1
a806 1
    CTRACE((tfp, "SGML Element Declaration:\n<%s>\n", s));
d811 1
d813 4
a816 3
 *	--------------
 */
static void handle_sgmlatt(HTStream *context)
d818 1
a818 1
    const char *s = context->string->data;
d820 1
a820 1
    CTRACE((tfp, "SGML Attribute Declaration:\n<%s>\n", s));
a824 28
/*
 * Convenience macros - tags (elements) are identified sometimes by an int or
 * enum value ('TAGNUM'), sometimes by a pointer to HTTag ('TAGP').  - kw
 */
#define TAGNUM_OF_TAGP(t) (HTMLElement) (t - context->dtd->tags)
#define TAGP_OF_TAGNUM(e) (context->dtd->tags + e)

/*
 * The following implement special knowledge about OBJECT.  As long as
 * HTML_OBJECT is the only tag for which an alternative variant exist, they can
 * be simple macros.  - kw
 */
/* does 'TAGNUM' e have an alternative (variant) parsing mode? */
#define HAS_ALT_TAGNUM(e) (e == HTML_OBJECT)

/* return 'TAGNUM' of the alternative mode for 'TAGNUM' e, if any. */
#define ALT_TAGNUM(e) ((e == HTML_OBJECT) ? HTML_ALT_OBJECT : e)

/* return 'TAGNUM' of the normal mode for 'TAGNUM' e which may be alt. */
#define NORMAL_TAGNUM(e) (((int)(e) >= HTML_ELEMENTS) ? HTML_OBJECT : (HTMLElement)e)

/* More convenience stuff. - kw */
#define ALT_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(ALT_TAGNUM(e))
#define NORMAL_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(NORMAL_TAGNUM(e))

#define ALT_TAGP(t) ALT_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))
#define NORMAL_TAGP(t) NORMAL_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))

d827 4
a830 1
static BOOL element_valid_within(HTTag * new_tag, HTTag * stacked_tag, BOOL direct)
a832 1

d838 2
a839 2
	return (BOOL) ((Tgc_same & usecontains) &&
		       (Tgc_same & usecontained));
d841 2
a842 2
	return (BOOL) ((new_tag->tagclass & usecontains) &&
		       (stacked_tag->tagclass & usecontained));
d845 2
d848 1
a848 1
    close_NO = 0,
d853 3
a855 1
static canclose_t can_close(HTTag * new_tag, HTTag * stacked_tag)
d868 2
a869 1
static void do_close_stacked(HTStream *context)
d871 1
a871 3
    HTElement *stacked = context->element_stack;
    HTMLElement e;

d877 4
a880 7
    e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(stacked->tag));
#ifdef USE_PRETTYSRC
    if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
#endif
	(*context->actions->end_element) (context->target,
					  e,
					  &context->include);
d882 1
a882 3
    pool_free(stacked);
    context->no_lynx_specialcodes = context->element_stack ?
	(context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
d885 3
a887 1
static int is_on_stack(HTStream *context, HTTag * old_tag)
d889 1
a889 1
    HTElement *stacked = context->element_stack;
a890 1

d892 1
a892 2
	if (stacked->tag == old_tag ||
	    stacked->tag == ALT_TAGP(old_tag))
d900 5
a904 3
 *	-----------
 */
static void end_element(HTStream *context, HTTag * old_tag)
a915 5
	    if (stackpos == 0 && (old_tag->flags & Tgf_startO) &&
		element_valid_within(old_tag, context->element_stack->tag, YES)) {
		CTRACE((tfp, "SGML: </%s> ignored\n", old_tag->name));
		return;
	    }
d918 4
a921 6
		CTRACE((tfp, "SGML: End </%s> \t<- %s end </%s>\n",
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			old_tag->name));
d925 5
d934 5
a938 5
	    CTRACE((tfp, "SGML: Still open %s, ***no open %s for </%s>\n",
		    context->element_stack ?
		    context->element_stack->tag->name : "none",
		    old_tag->name,
		    old_tag->name));
d942 4
a945 5
	    CTRACE((tfp,
		    "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
		    old_tag->name,
		    context->element_stack->tag->name,
		    old_tag->name));
d954 3
a956 2
     * If we are in a SELECT block, ignore anything but a SELECT end tag.  - FM
     */
d960 2
a961 2
	     * Turn off the inSELECT flag and fall through.  - FM
	     */
d965 4
a968 4
	     * Ignore the end tag.  - FM
	     */
	    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
		    old_tag->name));
d973 3
a975 3
     * Handle the end tag.  - FM
     */
    CTRACE((tfp, "SGML: End </%s>\n", old_tag->name));
d977 2
a978 2
	CTRACE((tfp, "SGML: ***Illegal end tag </%s> found.\n",
		old_tag->name));
d982 1
a982 1
    while (context->element_stack)	/* Loop is error path only */
d984 1
a984 1
    if (context->element_stack)	/* Substitute and remove one stack element */
d987 11
a997 15
	int status = HT_OK;
	HTMLElement e;
	HTElement *N = context->element_stack;
	HTTag *t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;

	if (old_tag != t) {	/* Mismatch: syntax error */
	    if (context->element_stack->next) {		/* This is not the last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			old_tag->name, t->name, t->name));
	    } else {		/* last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			old_tag->name, t->name, old_tag->name));
		return;		/* Ignore */
d1001 4
a1004 24
	e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(t));
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", t, (int) e));
#ifdef USE_PRETTYSRC
	if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
#endif
	    status = (*context->actions->end_element) (context->target,
						       e, &context->include);
	if (status == HT_PARSER_REOPEN_ELT) {
	    CTRACE((tfp, "SGML: Restart <%s>\n", t->name));
	    (*context->actions->start_element) (context->target,
						e,
						NULL,
						NULL,
						context->current_tag_charset,
						&context->include);
	} else if (status == HT_PARSER_OTHER_CONTENT) {
	    CTRACE((tfp, "SGML: Continue with other content model for <%s>\n", t->name));
	    context->element_stack->tag = ALT_TAGP_OF_TAGNUM(e);
	} else {
	    context->element_stack = N->next;	/* Remove from stack */
	    pool_free(N);
	}
	context->no_lynx_specialcodes = context->element_stack ?
	    (context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
d1007 1
a1007 1
	    return;		/* Correct sequence */
d1015 2
a1016 2
    CTRACE((tfp, "SGML: Extra end tag </%s> found and ignored.\n",
	    old_tag->name));
d1019 1
d1022 2
a1023 1
static void start_element(HTStream *context)
d1025 3
a1027 3
    int status;
    HTTag *new_tag = context->current_tag;
    HTMLElement e = TAGNUM_OF_TAGP(new_tag);
d1029 1
d1047 4
a1050 6
		CTRACE((tfp, "SGML: End </%s> \t<- %s start <%s>\n",
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			new_tag->name));
d1053 1
a1053 1
		if (canclose_check == close_error)
d1056 3
a1058 4
		CTRACE((tfp,
			"SGML: Still open %s \t<- ***invalid start <%s>\n",
			context->element_stack->tag->name,
			new_tag->name));
d1065 3
a1067 3
	    CTRACE((tfp, "SGML: Still open %s \t<- ***ignoring start <%s>\n",
		    context->element_stack->tag->name,
		    new_tag->name));
d1071 2
a1072 4
	if (context->element_stack &&
	    !extra_action_taken &&
	    (canclose_check == close_NO) &&
	    !valid && (new_tag->flags & Tgf_mafse)) {
d1075 1
a1075 2

	    for (; i < new_tag->number_of_attributes && !has_attributes; i++)
d1078 4
a1081 5
		CTRACE((tfp,
			"SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
			context->element_stack->tag->name,
			new_tag->name,
			new_tag->name));
d1088 8
a1095 7
	    (canclose_check == close_error) &&
	    !(valid = element_valid_within(new_tag,
					   context->element_stack->tag,
					   direct_container))) {
	    CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
		    context->element_stack->tag->name,
		    new_tag->name));
d1103 6
a1108 5
     * If we are not in a SELECT block, check if this is a SELECT start tag. 
     * Otherwise (i.e., we are in a SELECT block) accept only OPTION as valid,
     * terminate the SELECT block if it is any other form-related element, and
     * otherwise ignore it.  - FM
     */
d1111 3
a1113 5
	 * We are not in a SELECT block, so check if this starts one.  - FM
	 * (frequent case!)
	 */
	/* my_casecomp() - optimized by the first character */
	if (!my_casecomp(new_tag->name, "SELECT")) {
d1115 2
a1116 2
	     * Set the inSELECT flag and fall through.  - FM
	     */
d1121 2
a1122 2
	 * We are in a SELECT block.  - FM
	 */
d1125 12
a1136 2
	     * Ugh, it is not an OPTION.  - FM
	     */
d1138 7
a1144 12
	    case HTML_INPUT:
	    case HTML_TEXTAREA:
	    case HTML_SELECT:
	    case HTML_BUTTON:
	    case HTML_FIELDSET:
	    case HTML_LABEL:
	    case HTML_LEGEND:
	    case HTML_FORM:
		ok = TRUE;
		break;
	    default:
		break;
d1147 1
d1149 5
a1153 6
		 * It is another form-related start tag, so terminate the
		 * current SELECT block and fall through.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			new_tag->name));
d1157 4
a1160 5
		 * Ignore the start tag.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			new_tag->name));
d1166 12
a1177 14
     * Handle the start tag.  - FM
     */
    CTRACE((tfp, "SGML: Start <%s>\n", new_tag->name));
    status = (*context->actions->start_element) (context->target,
						 TAGNUM_OF_TAGP(new_tag),
						 context->present,
						 (const char **) context->value,	/* coerce type for think c */
						 context->current_tag_charset,
						 &context->include);
    if (status == HT_PARSER_OTHER_CONTENT)
	new_tag = ALT_TAGP(new_tag);	/* this is only returned for OBJECT */
    if (new_tag->contents != SGML_EMPTY) {	/* i.e., tag not empty */
	HTElement *N = pool_alloc();

d1183 5
a1187 3
	context->no_lynx_specialcodes = (new_tag->flags & Tgf_nolyspcl);

    } else if (e == HTML_META) {
d1189 2
a1190 2
	 * Check for result of META tag.  - KW & FM
	 */
d1195 1
d1197 14
a1210 13
 *		------------------------
 *
 * On entry,
 *	dtd	points to dtd structure including valid tag list
 *	string	points to name of tag in question
 *
 * On exit,
 *	returns:
 *		NULL		tag not found
 *		else		address of tag structure in dtd
 */
HTTag *SGMLFindTag(const SGML_dtd * dtd,
		   const char *s)
a1212 3
    static HTTag *last[64] =
    {NULL};			/*optimize using the previous results */
    HTTag **res = last + (UCH(*s) % 64);	/*pointer arithmetic */
d1214 1
a1214 4
    if (*res && !strcasecomp((*res)->name, s))
	return *res;

    for (low = 0, high = dtd->number_of_tags;
d1216 5
a1220 7
	 diff < 0 ? (low = i + 1) : (high = i)) {	/* Binary search */
	i = (low + (high - low) / 2);
	/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
	diff = my_casecomp(dtd->tags[i].name, s);	/* Case insensitive */
	if (diff == 0) {	/* success: found it */
	    *res = &dtd->tags[i];
	    return *res;
d1223 1
a1223 1
    if (IsNmStart(*s)) {
d1225 2
a1226 2
	 * Unrecognized, but may be valid.  - KW
	 */
d1233 3
a1235 2
 *			Public Methods
 */
d1240 2
a1241 1
static void SGML_free(HTStream *context)
d1244 2
a1245 2
    HTElement *cur;
    HTTag *t;
d1248 2
a1249 2
     * Free the buffers.  - FM
     */
a1253 1
    FREE(context->active_include);
d1256 2
a1257 2
     * Wind down stack if any elements are open.  - FM
     */
d1262 3
a1264 7
	pool_free(cur);
#ifdef USE_PRETTYSRC
	if (!psrc_view)		/* Don't actually call on target if viewing psrc - kw */
#endif
	    (*context->actions->end_element) (context->target,
					      NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
					      &context->include);
d1269 3
a1271 3
     * Finish off the target.  - FM
     */
    (*context->actions->_free) (context->target);
d1274 2
a1275 2
     * Free the strings and context structure.  - FM
     */
d1278 1
a1278 1
	FREE_extra(context->value[i]);
d1281 2
a1282 2
#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
d1286 3
a1288 1
static void SGML_abort(HTStream *context, HTError e)
d1291 1
a1291 1
    HTElement *cur;
d1294 3
a1296 3
     * Abort the target.  - FM
     */
    (*context->actions->_abort) (context->target, e);
d1299 2
a1300 2
     * Free the buffers.  - FM
     */
a1302 1
    FREE(context->active_include);
d1307 2
a1308 2
     * Free stack memory if any elements were left open.  - KW
     */
d1312 1
a1312 1
	pool_free(cur);
d1316 2
a1317 2
     * Free the strings and context structure.  - FM
     */
d1320 1
a1320 1
	FREE_extra(context->value[i]);
d1323 2
a1324 2
#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
d1326 1
d1329 1
d1331 6
a1336 6
 *	-----------------------------------
 *
 *   The callbacks from the SGML parser have an SGML context parameter.
 *   These calls allow the caller to associate his own context with a
 *   particular SGML context.
 */
d1339 2
a1340 1
void *SGML_callerData(HTStream *context)
d1345 3
a1347 1
void SGML_setCallerData(HTStream *context, void *data)
d1353 10
a1362 14
static void SGML_character(HTStream *context, char c_in)
{
    const SGML_dtd *dtd = context->dtd;
    HTChunk *string = context->string;
    const char *EntityName;
    HTTag *testtag = NULL;
    BOOLEAN chk;		/* Helps (?) walk through all the else ifs... */
    UCode_t clong, uck = 0;	/* Enough bits for UCS4 ... */
    int testlast;

#ifdef CJK_EX
    unsigned char c;

#else
a1363 1
#endif
d1367 4
a1370 3
     * Now some fun with the preprocessor.  Use copies for c and unsign_c ==
     * clong, so that we can revert back to the unchanged c_in.  - KW
     */
d1374 1
a1374 1
    clong = UCH(c);		/* a.k.a. unsign_c */
d1378 5
a1382 4
	 * Combine UTF-8 into Unicode.  Incomplete characters silently ignored. 
	 * From Linux kernel's console.c.  - KW
	 */
	if (TOASCII(UCH(c)) > 127) {	/* S/390 -- gil -- 0710 */
d1384 2
a1385 2
	     * We have an octet from a multibyte character.  - FM
	     */
d1393 4
a1396 3
		     * We have all of the bytes, so terminate the buffer and
		     * set 'clong' to the UCode_t value.  - FM
		     */
d1400 1
a1400 1
			c = ((char) (clong & 0xff));
d1405 2
a1406 2
		     * Wait for more.  - KW
		     */
d1411 2
a1412 2
		 * Start handling a new multibyte character.  - FM
		 */
d1433 2
a1434 2
		     * Garbage.  - KW
		     */
d1440 2
a1441 2
		 * Wait for more.  - KW
		 */
d1446 2
a1447 2
	     * Got an ASCII char.  - KW
	     */
d1451 1
a1451 1
	    /*  goto top;  */
d1453 2
a1454 2
    }
    /* end of context->T.decode_utf8      S/390 -- gil -- 0726 */
d1457 5
a1461 4
     * If we have a koi8-r input and do not have koi8-r as the output, save the
     * raw input in saved_char_in before we potentially convert it to Unicode. 
     * - FM
     */
d1467 3
a1469 2
     * If we want the raw input converted to Unicode, try that now.  - FM
     */
d1471 1
a1471 1
	((TOASCII(unsign_c) >= LYlowest_eightbit[context->inUCLYhndl]) ||	/* S/390 -- gil -- 0744 */
d1475 2
a1476 2
	 * Convert the octet to Unicode.  - FM
	 */
d1481 1
a1481 1
		c = FROMASCII((char) clong);
d1485 1
a1485 1
    } else if (unsign_c < ' ' && unsign_c != 0 &&	/* S/390 -- gil -- 0768 */
d1488 2
a1489 2
	 * This else if may be too ugly to keep.  - KW
	 */
d1496 1
a1496 1
		c = FROMASCII((char) clong);
d1519 2
a1520 1
		    PUTS(replace_buf);
d1526 2
a1527 2
	}			/*  Next line end of ugly stuff for C0. - KW */
    } else {			/* end of context->T.trans_to_uni  S/390 -- gil -- 0791 */
d1532 4
a1535 4
     * At this point we have either unsign_c a.k.a.  clong in Unicode (and c in
     * latin1 if clong is in the latin1 range), or unsign_c and c will have to
     * be passed raw.  - KW
     */
d1537 11
a1547 14
 *  We jump up to here from below if we have
 *  stuff in the recover, insert, or csi buffers
 *  to process.	 We zero saved_char_in, in effect
 *  as a flag that the octet in not that of the
 *  actual call to this function.  This may be OK
 *  for now, for the stuff this function adds to
 *  its recover buffer, but it might not be for
 *  stuff other functions added to the insert or
 *  csi buffer, so bear that in mind. - FM
 *  Stuff from the recover buffer is now handled
 *  as UTF-8 if we can expect that's what it is,
 *  and in that case we don't come back up here. - kw
 */
  top:
d1550 7
a1556 7
 *  We jump to here from above when we don't have
 *  UTF-8 input, haven't converted to Unicode, and
 *  want clong set to the input octet (unsigned)
 *  without zeroing its saved_char_in copy (which
 *  is signed). - FM
 */
  top0a:
d1558 1
a1558 1
    clong = UCH(c);
d1560 10
a1569 10
 *  We jump to here from above if we have converted
 *  the input, or a multibyte sequence across calls,
 *  to a Unicode value and loaded it into clong (to
 *  which unsign_c has been defined), and from below
 *  when we are recycling a character (e.g., because
 *  it terminated an entity but is not the standard
 *  semi-colon).  The character will already have
 *  been put through the Unicode conversions. - FM
 */
  top1:
d1571 3
a1573 2
     * Ignore low ISO 646 7-bit control characters if HTCJK is not set.  - FM
     */
d1575 2
a1576 2
     * Works for both ASCII and EBCDIC. -- gil
 *//* S/390 -- gil -- 0811 */
d1580 1
a1580 1
	goto after_switch;
d1583 3
a1585 2
     * Ignore 127 if we don't have HTPassHighCtrlRaw or HTCJK set.  - FM
     */
d1588 1
a1588 1
    if (TOASCII(c) == 127 &&	/* S/390 -- gil -- 0830 */
d1590 1
a1590 1
	goto after_switch;
d1593 4
a1596 4
     * Ignore 8-bit control characters 128 - 159 if neither HTPassHighCtrlRaw
     * nor HTCJK is set.  - FM
     */
    if (TOASCII(unsign_c) > 127 && TOASCII(unsign_c) < 160 &&	/* S/390 -- gil -- 0847 */
d1598 1
a1598 24
	goto after_switch;

    /* Almost all CJK characters are double byte but only Japanese
     * JIS X0201 Kana is single byte. To prevent to fail SGML parsing
     * we have to care them here. -- TH
     */
    if ((HTCJK == JAPANESE) && (context->state == S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& !context->T.decode_utf8
#endif
	) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
	if (IS_SJIS_X0201KANA(context->kanji_buf)) {
	    unsigned char sjis_hi, sjis_lo;

	    JISx0201TO0208_SJIS(context->kanji_buf, &sjis_hi, &sjis_lo);
	    PUTC(sjis_hi);
	    PUTC(sjis_lo);
	} else
#endif
	    PUTC(context->kanji_buf);
	context->state = S_text;
    }
d1601 3
a1603 8
     * Handle character based on context->state.
     */
    CTRACE2(TRACE_SGML, (tfp, "SGML before %s|%.*s|%c|\n",
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));
    switch (context->state) {
d1607 9
a1615 7
	 * Note that if we don't have a CJK input, then this is not the second
	 * byte of a CJK di-byte, and we're trashing the input.  That's why
	 * 8-bit characters followed by, for example, '<' can cause the tag to
	 * be treated as text, not markup.  We could try to deal with it by
	 * holding each first byte and then checking byte pairs, but that
	 * doesn't seem worth the overhead (see below).  - FM
	 */
a1616 1
	PUTC(context->kanji_buf);
a1619 12
    case S_tagname_slash:
	/*
	 * We had something link "<name/" so far, set state to S_text but keep
	 * context->slashedtag as as a flag; except if we get '>' directly
	 * after the "<name/", and really have a tag for that name in
	 * context->slashedtag, in which case keep state as is and let code
	 * below deal with it.  - kw
	 */
	if (!(c == '>' && context->slashedtag && TOASCII(unsign_c) < 127)) {
	    context->state = S_text;
	}
	/* fall through in any case! */
d1621 11
a1631 13
	if ((HTCJK != NOCJK) && ((TOASCII(c) & 0200) != 0)
#ifdef EXP_JAPANESEUTF8_SUPPORT
	    && !context->T.decode_utf8
#endif
	    ) {			/* S/390 -- gil -- 0864 */
	    /*
	     * Setting up for Kanji multibyte handling (based on Takuya ASADA's
	     * (asada@@three-a.co.jp) CJK Lynx).  Note that if the input is not
	     * in fact CJK, the next byte also will be mishandled, as explained
	     * above.  Toggle raw mode off in such cases, or select the "7 bit
	     * approximations" display character set, which is largely
	     * equivalent to having raw mode off with CJK.  - FM
	     */
d1633 1
a1633 1
	    context->kanji_buf = c;
d1635 1
a1635 1
	} else if (HTCJK != NOCJK && TOASCII(c) == '\033') {	/* S/390 -- gil -- 0881 */
d1637 3
a1639 3
	     * Setting up for CJK escape sequence handling (based on Takuya
	     * ASADA's (asada@@three-a.co.jp) CJK Lynx).  - FM
	     */
d1644 7
a1650 22

	if (c == '&' || c == '<') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {	/*there is nothing useful in the element_stack */
		testtag = context->current_tag;
	    } else
#endif
	    {
		testtag = context->element_stack ?
		    context->element_stack->tag : NULL;
	    }
	}

	if (c == '&' && TOASCII(unsign_c) < 127 &&	/* S/390 -- gil -- 0898 */
	    (!testtag ||
	     (testtag->contents == SGML_MIXED ||
	      testtag->contents == SGML_ELEMENT ||
	      testtag->contents == SGML_PCDATA ||
#ifdef USE_PRETTYSRC
	      testtag->contents == SGML_EMPTY ||
#endif
	      testtag->contents == SGML_RCDATA))) {
d1652 2
a1653 2
	     * Setting up for possible entity, without the leading '&'.  - FM
	     */
d1656 1
a1656 1
	} else if (c == '<' && TOASCII(unsign_c) < 127) {	/* S/390 -- gil -- 0915 */
d1658 2
a1659 2
	     * Setting up for possible tag.  - FM
	     */
d1661 5
a1665 75
	    if (testtag && testtag->contents == SGML_PCDATA) {
		context->state = S_pcdata;
	    } else if (testtag && (testtag->contents == SGML_LITTERAL
				   || testtag->contents == SGML_CDATA)) {
		context->state = S_litteral;
	    } else if (testtag && (testtag->contents == SGML_SCRIPT)) {
		context->state = S_script;
	    } else {
		context->state = S_tag;
	    }
	    context->slashedtag = NULL;
	} else if (context->slashedtag &&
		   (c == '/' ||
		    (c == '>' && context->state == S_tagname_slash)) &&
		   TOASCII(unsign_c) < 127) {
	    /*
	     * We got either the second slash of a pending "<NAME/blah blah/"
	     * shortref construct, or the '>' of a mere "<NAME/>".  In both
	     * cases generate a "</NAME>" end tag in the recover buffer for
	     * reparsing unless NAME is really an empty element.  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC(c);
		PSRCSTOP(abracket);
	    } else
#endif
		if (context->slashedtag != context->unknown_tag &&
		    !ReallyEmptyTag(context->slashedtag)) {
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, "</");
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, "</");
		}
		StrAllocCat(context->recover, context->slashedtag->name);
		StrAllocCat(context->recover, ">");
	    }
	    context->slashedtag = NULL;

	} else if (context->element_stack &&
		   (context->element_stack->tag->flags & Tgf_frecyc)) {
	    /*
	     * The element stack says we are within the contents of an element
	     * that the next stage (HTML.c) may want to feed us back again (via
	     * the *include string).  So try to output text in UTF-8 if
	     * possible, using the same logic as for attribute values (which
	     * should be in line with what context->current_tag_charset
	     * indicates).  - kw
	     */
	    if (context->T.decode_utf8 &&
		*context->utf_buf) {
		PUTS(context->utf_buf);
		context->utf_buf_p = context->utf_buf;
		*(context->utf_buf_p) = '\0';
	    } else if (HTCJK == NOCJK &&
		       (context->T.output_utf8 ||
			context->T.trans_from_uni)) {
		if (LYIsASCII(clong)) {
		    PUTC(c);
		} else if (clong == 0xfffd && saved_char_in &&
			   HTPassEightBitRaw &&
			   UCH(saved_char_in) >=
			   LYlowest_eightbit[context->outUCLYhndl]) {
		    PUTUTF8((0xf000 | UCH(saved_char_in)));
		} else {
		    PUTUTF8(clong);
		}
	    } else if (saved_char_in && context->T.use_raw_char_in) {
		PUTC(saved_char_in);
	    } else {
		PUTC(c);
	    }

d1667 5
a1671 6
	    /*
	     * Convert 160 (nbsp) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_NBSP &&	/* S/390 -- gil -- 0932 */
		   !context->no_lynx_specialcodes &&
d1674 5
a1678 6
	    /*
	     * Convert 173 (shy) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_SHY &&	/* S/390 -- gil -- 0949 */
		   !context->no_lynx_specialcodes &&
d1681 5
a1685 5
	    /*
	     * Handle the case in which we think we have a character which
	     * doesn't need further processing (e.g., a koi8-r input for a
	     * koi8-r output).  - FM
	     */
d1688 3
a1690 3
	     * Only if the original character is still in saved_char_in,
	     * otherwise we may be iterating from a goto top.  - KW
	     */
d1694 1
a1694 1
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
d1696 1
a1696 2
	} else if ((chk = (BOOL) (context->T.trans_from_uni &&
				  TOASCII(unsign_c) >= 160)) &&		/* S/390 -- gil -- 0968 */
d1700 2
a1701 2
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
		    uck, FROMASCII((char) uck)));
d1703 3
a1705 3
	     * We got one octet from the conversions, so use it.  - FM
	     */
	    PUTC(FROMASCII((char) uck));
d1707 6
a1712 6
		    (uck == -4 ||
		     (context->T.repl_translated_C0 &&
		      uck > 0 && uck < 32))) &&
	    /*
	     * Not found; look for replacement string.  - KW
	     */
d1717 9
a1725 8
	     * Got a replacement string.  No further tests for validity -
	     * assume that whoever defined replacement strings knew what she
	     * was doing.  - KW
	     */
	    PUTS(replace_buf);
	    /*
	     * If we're displaying UTF-8, try that now.  - FM
	     */
d1727 7
a1733 7
	    ;			/* do nothing more */
	    /*
	     * If it's any other (> 160) 8-bit character, and we have not set
	     * HTPassEightBitRaw nor HTCJK, nor have the "ISO Latin 1"
	     * character set selected, back translate for our character set.  -
	     * FM
	     */
d1745 2
a1746 1
#ifdef USE_PRETTYSRC
d1751 3
a1753 2
	    EntityName = HTMLGetEntityName((int) (unsign_c - 160));
	    HTChunkPuts(string, EntityName);
d1755 2
a1756 2
#ifdef USE_PRETTYSRC
	    /* we need to disable it temporary */
d1758 1
a1758 2
		psrc_view_backup = 1;
		psrc_view = 0;
d1762 2
a1763 2
#ifdef USE_PRETTYSRC
	    /* we need to disable it temporary */
d1771 5
a1775 5
	    /*
	     * If we get to here and have an ASCII char, pass the character.  -
	     * KW
	     */
	} else if (TOASCII(unsign_c) < 127 && unsign_c > 0) {	/* S/390 -- gil -- 0987 */
d1777 7
a1783 7
	    /*
	     * If we get to here, and should have translated, translation has
	     * failed so far.  - KW
	     *
	     * We should have sent UTF-8 output to the parser already, but what
	     * the heck, try again.  - FM
	     */
d1785 2
a1786 1
	    PUTS(context->utf_buf);
d1790 3
a1792 3
	    /*
	     * Check for a strippable koi8-r 8-bit character.  - FM
	     */
d1794 2
a1795 2
		   (UCH(saved_char_in) >= 0xc0) &&
		   (UCH(saved_char_in) < 255)) {
d1797 4
a1800 4
	     * KOI8 special:  strip high bit, gives (somewhat) readable ASCII
	     * or KOI7 - it was constructed that way!  - KW
	     */
	    PUTC(((char) (saved_char_in & 0x7f)));
d1803 6
a1808 6
	    /*
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
	} else if (TOASCII(UCH(c)) <	/* S/390 -- gil -- 0997 */
		   LYlowest_eightbit[context->outUCLYhndl] ||
d1810 1
d1812 26
a1837 15
	     * If we get to here, pass the character.  - FM
	     */
	} else {
	    PUTC(c);
	}
	break;

	/*
	 * Found '<' in SGML_PCDATA content; treat this mode nearly like
	 * S_litteral, but recognize '<!' and '<?' to filter out comments and
	 * processing instructions.  - kw
	 */
    case S_pcdata:
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
d1839 7
a1845 18
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    } else if (c == '?') {	/* <? - ignore as a PI until '>' - kw */
		CTRACE((tfp,
			"SGML: Found PI in PCDATA, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("<?");
		    PSRCSTOP(abracket);
		    context->seen_nonwhite_in_junk_tag = TRUE;	/* show all */
d1847 2
a1848 3
#endif
		context->state = S_junk_pi;
		break;
d1850 1
a1850 3
	}
	goto case_S_litteral;

d1852 4
a1855 18
	 * Found '<' in SGML_SCRIPT content; treat this mode nearly like
	 * S_litteral, but recognize '<!' to allow the content to be treated as
	 * a comment by lynx.
	 */
    case S_script:
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
		/*
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    }
d1857 1
a1857 1
	goto case_S_litteral;
d1859 5
a1863 6
	/*
	 * In litteral mode, waits only for specific end tag (for compatibility
	 * with old servers, and for Lynx).  - FM
	 */
      case_S_litteral:
    case S_litteral:		/*PSRC:this case not understood completely by HV, not done */
d1865 3
a1867 25
#ifdef USE_PRETTYSRC
	if (psrc_view) {	/*there is nothing useful in the element_stack */
	    testtag = context->current_tag;
	} else
#endif
	    testtag = context->element_stack ?
		context->element_stack->tag : NULL;

	if (testtag == NULL) {
	    string->size--;
	    context->state = S_text;
	    goto top1;
	}

	/*
	 * Normally when we get the closing ">",
	 *      testtag contains something like "TITLE"
	 *      string contains something like "/title>"
	 * so we decrement by 2 to compare the final character of each.
	 */
	testlast = string->size - 2 - context->trailing_spaces - context->leading_spaces;

	if (TOUPPER(c) != ((testlast < 0)
			   ? '/'
			   : testtag->name[testlast])) {
d1871 2
a1872 2
	     * If complete match, end litteral.
	     */
d1874 2
a1875 25
		testlast >= 0 && !testtag->name[testlast]) {
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("</");
		    PSRCSTOP(abracket);
		    PSRCSTART(tag);
		    strcpy(string->data, context->current_tag->name);
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
		    PUTS(string->data);
		    PSRCSTOP(tag);
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);

		    context->current_tag = NULL;
		} else
#endif
		    end_element(context, context->element_stack->tag);

a1878 2
		context->leading_spaces = 0;
		context->trailing_spaces = 0;
a1880 1

d1882 2
a1883 44
	     * Allow whitespace between the "<" or ">" and the keyword, for
	     * error-recovery.
	     */
	    if (isspace(UCH(c))) {
		if (testlast == -1) {
		    context->leading_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "leading spaces: %d\n", context->leading_spaces));
		    break;
		} else if (testlast > 0) {
		    context->trailing_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "trailing spaces: %d\n", context->trailing_spaces));
		    break;
		}
	    }

	    /*
	     * Mismatch - recover.
	     */
	    context->leading_spaces = 0;
	    context->trailing_spaces = 0;
	    if (((testtag->contents != SGML_LITTERAL &&
		  (testtag->flags & Tgf_strict)) ||
		 (context->state == S_pcdata &&
		  (testtag->flags & (Tgf_strict | Tgf_endO)))) &&
		(testlast > -1 &&
		 (c == '>' || testlast > 0 || IsNmStart(c)))) {
		context->state = S_end;
		string->size--;
		for (i = 0; i < string->size; i++)	/* remove '/' */
		    string->data[i] = string->data[i + 1];
		if ((string->size == 1) ? IsNmStart(c) : IsNmChar(c))
		    break;
		string->size--;
		goto top1;
	    }
	    if (context->state == S_pcdata &&
		(testtag->flags & (Tgf_strict | Tgf_endO)) &&
		(testlast < 0 && IsNmStart(c))) {
		context->state = S_tag;
		break;
	    }
	    /*
	     * If Mismatch:  recover string literally.
	     */
d1885 2
a1886 2
	    for (i = 0; i < string->size - 1; i++)	/* recover, except last c */
		PUTC(string->data[i]);
d1893 3
a1895 3
	/*
	 * Character reference (numeric entity) or named entity.
	 */
d1899 3
a1901 3
	     * Setting up for possible numeric entity.
	     */
	    context->state = S_cro;	/* &# is Char Ref Open */
d1904 1
a1904 1
	context->state = S_entity;	/* Fall through! */
d1906 3
a1908 3
	/*
	 * Handle possible named entity.
	 */
d1911 1
a1911 4
					isalnum(UCH(c)) : isalpha(UCH(c)))) {
	    /* Should probably use IsNmStart/IsNmChar above (is that right?),
	       but the world is not ready for that - there's &nbsp: (note
	       colon!) and stuff around. */
d1913 2
a1914 2
	     * Accept valid ASCII character.  - FM
	     */
d1918 4
a1921 4
	     * It was an ampersand that's just text, so output the ampersand
	     * and recycle this character.  - FM
	     */
#ifdef USE_PRETTYSRC
d1926 1
a1926 1
#ifdef USE_PRETTYSRC
d1934 2
a1935 2
	     * Terminate entity name and try to handle it.  - FM
	     */
d1937 1
a1937 1
#ifdef USE_PRETTYSRC
d1941 1
a1941 1
	    /* CTRACE((tfp, "%s: %d: %s\n", __FILE__, __LINE__, string->data)); */
d1944 1
a1944 1
		 (context->element_stack->tag &&
d1947 2
a1948 2
		 * Handle zwnj (8204) as <WBR>.  - FM
		 */
d1951 1
a1951 2
		CTRACE((tfp,
			"SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));
d1973 6
a1978 5
	     * Don't eat the terminator if we didn't find the entity name and
	     * therefore sent the raw string via handle_entity(), or if the
	     * terminator is not the "standard" semi-colon for HTML.  - FM
	     */
#ifdef USE_PRETTYSRC
d1980 1
a1980 1
		PSRCSTART(entity);
d1982 1
a1982 1
		PSRCSTOP(entity);
d1990 3
a1992 3
	/*
	 * Check for a numeric entity.
	 */
d1994 1
a1994 1
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {	/* S/390 -- gil -- 1060 */
d1997 1
a1997 1
	} else if (TOASCII(unsign_c) < 127 && isdigit(UCH(c))) {
d1999 2
a2000 2
	     * Accept only valid ASCII digits.  - FM
	     */
d2006 4
a2009 4
	     * No 'x' or digit following the "&#" so recover them and recycle
	     * the character.  - FM
	     */
#ifdef USE_PRETTYSRC
d2015 1
a2015 1
#ifdef USE_PRETTYSRC
d2024 3
a2026 3
	/*
	 * Handle a numeric entity.
	 */
d2028 2
a2029 2
/* S/390 -- gil -- 1075 *//* CTRACE((tfp, "%s: %d: numeric %d %d\n",
   __FILE__, __LINE__, unsign_c, c)); */
d2031 2
a2032 2
	    (context->isHex ? isxdigit(UCH(c)) :
	     isdigit(UCH(c)))) {
d2034 2
a2035 2
	     * Accept only valid hex or ASCII digits.  - FM
	     */
d2039 4
a2042 4
	     * No hex digit following the "&#x" so recover them and recycle the
	     * character.  - FM
	     */
#ifdef USE_PRETTYSRC
d2046 4
a2049 2
	    PUTS("&#x");
#ifdef USE_PRETTYSRC
d2058 2
a2059 2
	     * Terminate the numeric entity and try to handle it.  - FM
	     */
a2061 1

d2063 1
a2063 1
#ifdef USE_PRETTYSRC
d2067 1
a2067 1
		 sscanf(string->data, "%ld", &code)) == 1) {
d2072 7
a2078 7
		     * Assume these are Microsoft code points, inflicted on us
		     * by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159 range
		     * and doesn't follow Unicode standards for this area. 
		     * Windows-1252 codepoints are assumed here.
		     */
d2080 122
a2201 119
		    case 1:
			/*
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
			break;
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
			break;
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
			break;
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
			break;
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
			break;
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
			break;
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
			break;
d2205 2
a2206 2
		 * Check for special values.  - FM
		 */
d2209 1
a2209 1
		     (context->element_stack->tag &&
d2212 2
a2213 2
		     * Handle zwnj (8204) as <WBR>.  - FM
		     */
d2216 1
a2216 2
		    CTRACE((tfp,
			    "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));
d2219 3
a2221 3
		     * Include the terminator if it is not the standard
		     * semi-colon.  - FM
		     */
d2228 3
a2230 3
		     * Add the replacement string to the recover buffer for
		     * processing.  - FM
		     */
d2243 4
a2246 4
		     * We handled the value as a special character, so recycle
		     * the terminator or break.  - FM
		     */
#ifdef USE_PRETTYSRC
d2249 1
a2249 1
			PUTS((context->isHex ? "&#x" : "&#"));
d2264 2
a2265 2
		 * Seek a translation from the chartrans tables.
		 */
d2271 1
a2271 1
#ifdef USE_PRETTYSRC
d2274 2
a2275 2
			PUTC(FROMASCII((char) uck));
#ifdef USE_PRETTYSRC
d2277 5
a2281 1
			put_pretty_number(context);
d2287 3
a2289 3
		    /*
		     * Not found; look for replacement string.
		     */
d2293 1
a2293 1
#ifdef USE_PRETTYSRC
d2295 5
a2299 1
			put_pretty_number(context);
d2302 21
a2322 1
			PUTS(replace_buf);
d2324 18
a2341 4
		     * If we're displaying UTF-8, try that now.  - FM
		     */
		} else if (context->T.output_utf8 && PUTUTF8(code)) {
		    ;		/* do nothing more */
d2343 18
a2360 3
		     * Ignore 8205 (zwj), 8206 (lrm), and 8207 (rln), if we get
		     * to here.  - FM
		     */
d2374 1
a2374 1
#ifdef USE_PRETTYSRC
d2377 1
a2377 1
			PUTS((context->isHex ? "&#x" : "&#"));
d2390 13
a2402 12
		    /*
		     * Show the numeric entity if we get to here and the value:
		     * (1) Is greater than 255 (but use ASCII characters for
		     * spaces or dashes).
		     * (2) Is less than 32, and not valid or we don't have
		     * HTCJK set.
		     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK
		     * set.
		     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum
		     * set.
		     * - FM
		     */
d2404 1
a2404 1
			   (code < ' ' &&	/* S/390 -- gil -- 1140 */
d2411 23
a2433 8
		    /*
		     * Unhandled or illegal value.  Recover the "&#" or "&#x"
		     * and digit(s), and recycle the terminator.  - FM
		     */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(badseq);
		    }
d2435 1
a2435 2
		    if (context->isHex) {
			PUTS("&#x");
d2437 3
a2439 16
		    } else {
			PUTS("&#");
		    }
		    string->size--;
		    for (i = 0; i < string->size; i++)	/* recover */
			PUTC(string->data[i]);
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTOP(badseq);
		    }
#endif
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    goto top1;
		} else if (TOASCII(code) < 161 ||	/* S/390 -- gil -- 1162 */
d2443 3
a2445 3
		     * No conversion needed.  - FM
		     */
#ifdef USE_PRETTYSRC
d2447 5
a2451 1
			put_pretty_number(context);
d2454 1
a2454 1
			PUTC(FROMASCII((char) code));
d2457 2
a2458 2
		     * Handle as named entity.  - FM
		     */
d2463 2
a2464 1
			HTChunkPuts(string, EntityName);
d2468 3
a2470 3
			 * Add a semi-colon if something went wrong and
			 * handle_entity() sent the string.  - FM
			 */
d2476 4
a2479 4
			 * Our conversion failed, so recover the "&#" and
			 * digit(s), and recycle the terminator.  - FM
			 */
#ifdef USE_PRETTYSRC
d2483 2
d2486 1
a2486 1
			    PUTS("&#x");
a2487 2
			} else {
			    PUTS("&#");
d2492 1
a2492 1
#ifdef USE_PRETTYSRC
d2503 2
a2504 2
		 * If we get to here, we succeeded.  Hoorah!!!  - FM
		 */
d2509 3
a2511 3
		 * Don't eat the terminator if it's not the "standard"
		 * semi-colon for HTML.  - FM
		 */
d2517 5
a2521 4
		 * Not an entity, and don't know why not, so add the terminator
		 * to the string, output the "&#" or "&#x", and process the
		 * string via the recover element.  - FM
		 */
d2525 1
a2525 1
#ifdef USE_PRETTYSRC
d2529 6
d2536 1
a2536 1
		    PUTS("&#x");
a2537 2
		} else {
		    PUTS("&#");
a2538 4
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTOP(badseq);
#endif
d2553 4
a2556 4
	/*
	 * Tag
	 */
    case S_tag:		/* new tag */
d2558 1
a2558 1
					IsNmChar(c) : IsNmStart(c))) {
d2560 2
a2561 2
	     * Add valid ASCII character.  - FM
	     */
d2563 1
a2563 1
	} else if (c == '!' && !string->size) {		/* <! */
d2565 3
a2567 3
	     * Terminate and set up for possible comment, identifier,
	     * declaration, or marked section.  - FM
	     */
d2575 1
a2575 1
		   (TOASCII(unsign_c) <= 160 &&		/* S/390 -- gil -- 1196 */
d2578 7
a2584 7
	     * '<' must be followed by an ASCII letter to be a valid start tag. 
	     * Here it isn't, nor do we have a '/' for an end tag, nor one of
	     * some other characters with a special meaning for SGML or which
	     * are likely to be legal Name Start characters in XML or some
	     * other extension.  So recover the '<' and following character as
	     * data.  - FM & KW
	     */
d2586 1
a2586 1
#ifdef USE_PRETTYSRC
d2591 1
a2591 1
#ifdef USE_PRETTYSRC
d2596 1
a2596 1
	} else {		/* End of tag name */
d2598 3
a2600 4
	     * Try to handle tag.  - FM
	     */
	    HTTag *t;

d2602 4
a2605 5
		if (string->size == 0) {
		    context->state = S_end;
		    break;
		}
		CTRACE((tfp, "SGML: `<%.*s/' found!\n", string->size, string->data));
d2607 1
a2607 1
	    HTChunkTerminate(string);
d2610 2
a2611 4
	    if (t == context->unknown_tag &&
		((c == ':' &&
		  string->size == 4 && 0 == strcasecomp(string->data, "URL")) ||
		 (string->size > 4 && 0 == strncasecomp(string->data, "URL:", 4)))) {
d2613 5
a2617 4
		 * Treat <URL:  as text rather than a junk tag, so we display
		 * it and the URL (Lynxism 8-).  - FM
		 */
#ifdef USE_PRETTYSRC
d2622 2
a2623 1
		PUTS(string->data);	/* recover */
d2625 1
a2625 1
#ifdef USE_PRETTYSRC
d2629 2
a2630 2
		CTRACE((tfp, "SGML: Treating <%s%c as text\n",
			string->data, c));
d2634 3
a2636 26
	    }
	    if (c == '/' && t) {
		/*
		 * Element name was ended by '/'.  Remember the tag that ended
		 * thusly, we'll interpret this as either an indication of an
		 * empty element (if '>' follows directly) or do some
		 * SGMLshortref-ish treatment.  - kw
		 */
		context->slashedtag = t;
	    }
	    if (!t) {
		if (c == '?' && string->size <= 1) {
		    CTRACE((tfp, "SGML: Found PI, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(abracket);
			PUTS("<?");
			PSRCSTOP(abracket);
			context->seen_nonwhite_in_junk_tag = TRUE;	/*show all */
		    }
#endif
		    context->state = S_junk_pi;
		    break;
		}
		CTRACE((tfp, "SGML: *** Invalid element %s\n",
			string->data));
d2638 1
a2638 1
#ifdef USE_PRETTYSRC
d2640 1
a2640 3
		    PSRCSTART(abracket);
		    PUTC('<');
		    PSRCSTOP(abracket);
d2649 2
a2650 1
		    if (c == '>') {
d2652 1
a2652 5
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    } else {
			PUTC(c);
d2659 2
a2660 2
		CTRACE((tfp, "SGML: *** Unknown element %s\n",
			string->data));
d2662 3
a2664 3
		 * Fall through and treat like valid tag for attribute parsing. 
		 * - KW
		 */
d2669 4
a2672 1
#ifdef USE_PRETTYSRC
d2674 1
a2674 3
		PSRCSTART(abracket);
		PUTC('<');
		PSRCSTOP(abracket);
a2685 4
		if (t != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d2687 1
a2687 1
	    if (!psrc_view)	/*don't waste time */
d2690 8
a2697 5
		/*
		 * Clear out attributes.
		 */
		memset((void *) context->present, 0, sizeof(BOOL) *
		       context->current_tag->number_of_attributes);
d2702 1
a2702 1
#ifdef USE_PRETTYSRC
d2704 9
a2712 9
		if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
		    if (c != '<') {
			PSRCSTART(abracket);
			PUTC(c);
			PSRCSTOP(abracket);
			context->state = (c == '>') ? S_text : S_tagname_slash;
		    } else {
			context->state = S_tag;
		    }
a2713 2
		    if (!WHITE(c))
			PUTC(c);
d2718 1
a2718 1
	    if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
d2721 1
a2721 2
		context->state = (c == '>') ? S_text :
		    (c == '<') ? S_tag : S_tagname_slash;
d2731 2
a2732 2
	     * Set up for possible comment.  - FM
	     */
d2740 2
a2741 2
	     * Set up for possible marked section.  - FM
	     */
d2751 2
a2752 2
	     * Set up to handle comment.  - FM
	     */
d2764 2
a2765 2
	     * Try to handle identifier.  - FM
	     */
d2767 1
a2767 1
#ifdef USE_PRETTYSRC
d2776 1
a2776 1
		handle_identifier(context);
d2785 2
a2786 2
		 * Set up for DOCTYPE declaration.  - FM
		 */
d2795 2
a2796 2
		 * Set up for ENTITY declaration.  - FM
		 */
d2806 2
a2807 2
		 * Set up for ELEMENT declaration.  - FM
		 */
d2817 2
a2818 2
		 * Set up for ATTLIST declaration.  - FM
		 */
d2832 2
a2833 2
	     * Any '>' terminates.  - FM
	     */
d2836 1
a2836 1
#ifdef USE_PRETTYSRC
d2840 1
a2840 1
		    PUTS_TR(string->data);
d2845 1
a2845 1
		    handle_comment(context);
d2852 2
a2853 1
	    goto S_comment_put_c;
d2867 3
a2869 3
		 * Validly treat '--' pairs as successive comments (for
		 * minimal, any "--WHITE>" terminates).  - FM
		 */
d2875 2
a2876 2
	     * Terminate and handle the comment.  - FM
	     */
d2878 8
a2885 8
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(comm);
		PUTC('<');
		PUTS_TR(string->data);
		PUTC('>');
		PSRCSTOP(comm);
	    } else
d2887 1
a2887 1
		handle_comment(context);
d2895 1
a2895 1
	if (context->end_comment && !isspace(UCH(c)))
d2897 1
a2897 24

      S_comment_put_c:
	if (context->T.decode_utf8 &&
	    *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (HTCJK == NOCJK &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		UCH(saved_char_in) >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (0xf000 | UCH(saved_char_in)));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
d2914 1
a2914 1
#ifdef USE_PRETTYSRC
d2923 1
a2923 1
		handle_doctype(context);
d2946 1
a2946 1
#ifdef USE_PRETTYSRC
d2955 1
a2955 1
		handle_marked(context);
d2980 1
a2980 1
#ifdef USE_PRETTYSRC
d2989 1
a2989 1
		handle_sgmlent(context);
d3017 1
a3017 1
#ifdef USE_PRETTYSRC
d3026 1
a3026 1
		handle_sgmlele(context);
d3054 1
a3054 1
#ifdef USE_PRETTYSRC
d3063 1
a3063 1
		handle_sgmlatt(context);
d3078 1
a3078 1
#ifdef USE_PRETTYSRC
d3081 3
a3083 3
		if (context->current_tag->name)
		    start_element(context);
#ifdef USE_PRETTYSRC
d3085 4
d3098 1
a3098 1
	context->state = S_attr;	/* Get attribute */
d3101 1
a3101 1
	/* accumulating value */
d3106 1
a3106 1
#ifdef USE_PRETTYSRC
d3109 9
a3117 9
		string->size = 0;
		if (c == '>') {	/* End of tag */
		    if (context->current_tag->name)
			start_element(context);
		    context->state = S_text;
		    break;
		}
#ifdef USE_PRETTYSRC
	    } else {
a3129 2
		if (c == '=')
		    PUTC('=');
d3131 1
d3138 4
d3151 1
a3151 1
	    context->state = (c == '=' ? S_equals : S_attr_gap);
d3161 1
a3161 1
#ifdef USE_PRETTYSRC
d3163 1
a3163 1
		if (context->current_attribute_number == INVALID) {
d3165 1
a3165 1
		} else {
d3167 4
a3170 1
		}
d3174 1
a3174 1
	    } else
d3181 1
a3181 1
#ifdef USE_PRETTYSRC
d3184 1
a3184 1
		if (context->current_attribute_number == INVALID) {
d3186 1
a3186 1
		} else {
a3187 1
		}
d3193 7
d3201 1
a3201 1
	context->state = S_attr;	/* Get next attribute */
d3208 2
a3209 2
	    CTRACE((tfp, "SGML: found = but no value\n"));
#ifdef USE_PRETTYSRC
d3211 4
d3226 1
a3226 1
#ifdef USE_PRETTYSRC
d3236 1
a3236 1
#ifdef USE_PRETTYSRC
d3245 1
a3245 1
#ifdef USE_PRETTYSRC
d3250 1
a3250 1
	/*  no break!  fall through to S_value and process current `c`   */
d3253 3
a3255 3
	if (WHITE(c) || (c == '>')) {	/* End of word */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
d3257 2
a3258 2
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
d3260 5
a3264 4
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
d3266 1
a3266 1
		    HTStartAnchor(context->target, NULL, string->data);
d3269 5
a3273 4
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
a3278 14
#ifdef CJK_EX			/* Quick hack. - JH7AYN */
	    {
		char jis_buf[512];

		if (string->data[0] == '$') {
		    if (string->data[1] == 'B' || string->data[1] == '@@') {
			jis_buf[0] = '\033';
			strcpy(jis_buf + 1, string->data);
			TO_EUC((const unsigned char *) jis_buf,
			       (unsigned char *) string->data);
		    }
		}
	    }
#endif
d3281 2
a3282 2
	    if (c == '>') {	/* End of tag */
#ifdef USE_PRETTYSRC
d3284 4
d3297 2
a3298 2
	    } else
		context->state = S_tag_gap;
d3309 1
a3309 1
		UCH(saved_char_in) >=
d3312 1
a3312 1
				   (0xf000 | UCH(saved_char_in)));
d3325 2
a3326 2
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
d3328 8
a3335 7
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
d3337 1
a3337 1
		    HTStartAnchor(context->target, NULL, string->data);
d3340 5
a3344 4
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3351 1
a3351 1
		handle_attribute_value(context, string->data);
d3354 1
a3354 1
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1213 */
d3356 3
a3358 3
	     * Setting up for possible single quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
d3371 1
a3371 1
		UCH(saved_char_in) >=
d3374 1
a3374 1
				   (0xf000 | UCH(saved_char_in)));
d3389 2
a3390 2
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
d3392 8
a3399 7
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
d3401 1
a3401 1
		    HTStartAnchor(context->target, NULL, string->data);
d3404 5
a3408 4
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3416 1
a3416 1
		handle_attribute_value(context, string->data);
d3421 1
a3421 1
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1230 */
d3423 3
a3425 3
	     * Setting up for possible double quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
d3438 1
a3438 1
		UCH(saved_char_in) >=
d3441 1
a3441 1
				   (0xf000 | UCH(saved_char_in)));
d3452 2
a3453 3
    case S_end:		/* </ */
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1247 */
					IsNmChar(c) : IsNmStart(c))) {
d3455 3
a3457 4
	} else {		/* End of end tag name */
	    HTTag *t = 0;

#ifdef USE_PRETTYSRC
d3469 2
a3470 2
		CTRACE((tfp, "Unknown end tag </%s>\n", string->data));
#ifdef USE_PRETTYSRC
d3473 2
a3474 1
		    PUTS("</");
d3483 3
a3485 10
		    PUTS(string->data);
		    if (c != '>') {
			PUTC(c);
		    } else {
			PSRCSTOP(badtag);
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    }
		    psrc_tagname_processed = TRUE;
d3490 1
a3490 2
		BOOL tag_OK = (BOOL) (c == '>' || WHITE(c));

d3492 2
a3493 2
		HTMLElement e = TAGNUM_OF_TAGP(t);
		int branch = 2;	/* it can be 0,1,2 */
a3495 4
		if (HAS_ALT_TAGNUM(TAGNUM_OF_TAGP(t)) &&
		    context->element_stack &&
		    ALT_TAGP(t) == context->element_stack->tag)
		    context->element_stack->tag = NORMAL_TAGP(context->element_stack->tag);
a3496 1
		if (tag_OK
d3498 3
a3500 1
		    && Old_DTD
d3502 4
a3505 13
		    ) {
		    switch (e) {
		    case HTML_DD:
		    case HTML_DT:
		    case HTML_LI:
		    case HTML_LH:
		    case HTML_TD:
		    case HTML_TH:
		    case HTML_TR:
		    case HTML_THEAD:
		    case HTML_TFOOT:
		    case HTML_TBODY:
		    case HTML_COLGROUP:
d3509 3
a3511 12
		    case HTML_A:
		    case HTML_B:
		    case HTML_BLINK:
		    case HTML_CITE:
		    case HTML_EM:
		    case HTML_FONT:
		    case HTML_FORM:
		    case HTML_I:
		    case HTML_P:
		    case HTML_STRONG:
		    case HTML_TT:
		    case HTML_U:
a3513 2
		    default:
			break;
d3520 2
a3521 2
		 * Just handle ALL end tags normally :-) - kw
		 */
d3523 1
a3523 1
		    end_element(context, context->current_tag);
d3527 14
a3540 3
		    if (tag_OK &&
#if OPT
			(branch == 0)
d3542 1
a3542 11
			(!strcasecomp(string->data, "DD") ||
			 !strcasecomp(string->data, "DT") ||
			 !strcasecomp(string->data, "LI") ||
			 !strcasecomp(string->data, "LH") ||
			 !strcasecomp(string->data, "TD") ||
			 !strcasecomp(string->data, "TH") ||
			 !strcasecomp(string->data, "TR") ||
			 !strcasecomp(string->data, "THEAD") ||
			 !strcasecomp(string->data, "TFOOT") ||
			 !strcasecomp(string->data, "TBODY") ||
			 !strcasecomp(string->data, "COLGROUP"))
a3543 1
		    ) {
d3545 5
a3549 5
		     * Don't treat these end tags as invalid, nor act on them. 
		     * - FM
		     */
		    CTRACE((tfp, "SGML: `</%s%c' found!  Ignoring it.\n",
			    string->data, c));
a3554 1
			context->current_tag = NULL;
d3558 1
a3559 3
#if OPT
			   (branch == 1)
#else
d3571 3
a3573 1
			    !strcasecomp(string->data, "U"))
a3574 1
		    ) {
d3576 6
a3581 6
		     * Handle end tags for container elements declared as
		     * SGML_EMPTY to prevent "expected tag substitution" but
		     * still processed via HTML_end_element() in HTML.c with
		     * checks there to avoid throwing the HTML.c stack out of
		     * whack (Ugh, what a hack!  8-).  - FM
		     */
d3584 2
a3585 2
			 * We are in a SELECT block.  - FM
			 */
d3588 4
a3591 5
			     * It is not at FORM end tag, so ignore it.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
				    string->data));
d3594 5
a3598 6
			     * End the SELECT block and then handle the FORM
			     * end tag.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
				    string->data));
d3601 1
a3601 1
			    CTRACE((tfp, "SGML: End </%s>\n", string->data));
d3603 4
a3606 7
#ifdef USE_PRETTYSRC
			    if (!psrc_view)	/* Don't actually call if viewing psrc - kw */
#endif
				(*context->actions->end_element)
				    (context->target,
				     TAGNUM_OF_TAGP(context->current_tag),
				     &context->include);
d3610 5
a3614 6
			 * Treat a P end tag like a P start tag (Ugh, what a
			 * hack!  8-).  - FM
			 */
			CTRACE((tfp,
				"SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				string->data, c, string->data, c));
a3616 1

d3626 1
a3626 1
			CTRACE((tfp, "SGML: End </%s>\n", string->data));
d3628 4
a3631 7
#ifdef USE_PRETTYSRC
			if (!psrc_view)		/* Don't actually call if viewing psrc - kw */
#endif
			    (*context->actions->end_element)
				(context->target,
				 TAGNUM_OF_TAGP(context->current_tag),
				 &context->include);
a3637 1
			context->current_tag = NULL;
d3643 3
a3645 3
		     * Handle all other end tags normally.  - FM
		     */
		    end_element(context, context->current_tag);
d3649 1
a3649 1
#ifdef USE_PRETTYSRC
d3652 2
a3653 1
		PUTS("</");
d3662 2
a3663 3
		PUTS(string->data);
		PSRCSTOP(tag);
		if (c != '>') {
d3665 1
a3665 2
		    PUTC(c);
		} else {
d3677 1
a3677 1
		    CTRACE((tfp, "SGML: `</%s%c' found!\n", string->data, c));
a3679 1
		context->current_tag = NULL;
d3685 1
d3697 1
a3697 1
    case S_dollar:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d3706 1
a3706 1
    case S_dollar_paren:	/* Expecting 'C' after CJK "ESC$(". */
d3715 1
a3715 1
    case S_paren:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d3726 2
a3727 2
    case S_nonascii_text:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1264 */
a3730 2
	if (c < 32)
	    context->state = S_text;
d3733 1
a3733 1
    case S_esc_sq:		/* Expecting '$'or '(' following CJK ESC. */
d3744 1
a3744 1
    case S_dollar_sq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d3753 1
a3753 1
    case S_dollar_paren_sq:	/* Expecting 'C' after CJK "ESC$(". */
d3762 1
a3762 1
    case S_paren_sq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d3773 2
a3774 2
    case S_nonascii_text_sq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1281 */
d3791 1
a3791 1
    case S_dollar_dq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d3800 1
a3800 1
    case S_dollar_paren_dq:	/* Expecting 'C' after CJK "ESC$(". */
d3809 1
a3809 1
    case S_paren_dq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d3820 2
a3821 2
    case S_nonascii_text_dq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1298 */
a3827 1
    case S_junk_pi:
d3829 1
a3829 1
#ifdef USE_PRETTYSRC
d3831 1
a3831 3
		if (context->state == S_junk_tag) {
		    PSRCSTOP(badtag);
		}
d3835 1
a3835 1
		context->seen_nonwhite_in_junk_tag = FALSE;
a3837 1
	    context->current_tag = NULL;
d3840 1
a3840 1
#ifdef USE_PRETTYSRC
d3842 2
a3843 2
	    /*pack spaces until first non-space is seen */
	    if (!context->seen_nonwhite_in_junk_tag) {
d3845 1
a3845 1
		    context->seen_nonwhite_in_junk_tag = TRUE;
d3847 1
a3847 1
		}
d3850 1
a3850 1
	}
d3853 1
a3853 27
    }				/* switch on context->state */
    CTRACE2(TRACE_SGML, (tfp, "SGML after  %s|%.*s|%c|\n",
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));

  after_switch:
    /*
     * Check whether an external function has added anything to the include
     * buffer.  If so, move the new stuff to the beginning of active_include. 
     * - kw
     */
    if (context->include != NULL) {
	if (context->include[0] == '\0') {
	    FREE(context->include);
	} else {
	    if (context->active_include &&
		context->active_include[context->include_index] != '\0')
		StrAllocCat(context->include,
			    context->active_include + context->include_index);
	    FREE(context->active_include);
	    context->active_include = context->include;
	    context->include_index = 0;
	    context->include = NULL;
	}
    }
d3856 2
a3857 2
     * Check whether we've added anything to the recover buffer.  - FM
     */
d3870 6
a3875 6
     * Check whether an external function had added anything to the include
     * buffer; it should now be in active_include.  - FM / kw
     */
    if (context->active_include != NULL) {
	if (context->active_include[context->include_index] == '\0') {
	    FREE(context->active_include);
d3878 3
a3880 27
	    if (context->current_tag_charset == UTF8_handle ||
		context->T.trans_from_uni) {
		/*
		 * If it looks like we would have fed UTF-8 to the next
		 * processing stage, assume that whatever we were fed back is
		 * in UTF-8 form, too.  This won't be always true for all uses
		 * of the include buffer, but it's a start.  - kw
		 */
		char *puni = context->active_include + context->include_index;

		c = *puni;
		clong = UCGetUniFromUtf8String(&puni);
		if (clong < 256 && clong >= 0) {
		    c = ((char) (clong & 0xff));
		}
		saved_char_in = '\0';
		context->include_index = puni - context->active_include + 1;
		goto top1;
	    } else {
		/*
		 * Otherwise assume no UTF-8 - do charset-naive processing and
		 * hope for the best.  - kw
		 */
		c = context->active_include[context->include_index];
		context->include_index++;
		goto top;
	    }
d3885 3
a3887 3
     * Check whether an external function has added anything to the csi buffer. 
     * - FM
     */
d3898 1
a3898 1
}				/* SGML_character */
d3900 4
a3903 1
static void SGML_string(HTStream *context, const char *str)
d3905 1
a3905 2
    const char *p;

d3910 5
a3914 2
static void SGML_write(HTStream *context, const char *str,
		       int l)
d3916 2
a3917 3
    const char *p;
    const char *e = str + l;

d3926 10
a3935 10
 *	-----------------------
 */
const HTStreamClass SGMLParser =
{
    "SGMLParser",
    SGML_free,
    SGML_abort,
    SGML_character,
    SGML_string,
    SGML_write,
d3939 12
a3950 11
 *	------------------
 *
 * On entry,
 *	dtd		represents the DTD, along with
 *	actions		is the sink for the data as a set of routines.
 *
 */

HTStream *SGML_new(const SGML_dtd * dtd,
		   HTParentAnchor *anchor,
		   HTStructured * target)
d3953 1
a3953 2
    HTStream *context = (HTStream *) malloc(sizeof(*context));

a3958 2
    context->leading_spaces = 0;
    context->trailing_spaces = 0;
d3961 2
a3962 2
    context->actions = (const HTStructuredClass *) (((HTStream *) target)->isa);
    /* Ugh: no OO */
a3963 1
    context->current_tag = context->slashedtag = NULL;
d3965 1
a3965 2
    context->kanji_buf = '\0';
    context->element_stack = 0;	/* empty */
a3966 1
    context->no_lynx_specialcodes = NO;		/* special codes normally generated */
d3968 1
a3968 1
    context->callerData = (void *) callerData;
d3981 1
a3981 1
    context->node_anchor = anchor;	/* Could be NULL? */
a3996 13
#ifdef CAN_SWITCH_DISPLAY_CHARSET	/* Allow a switch to a more suitable display charset */
    else if (anchor->UCStages
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl >= 0
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl != current_char_set) {
	int o = anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl;

	anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl = -1;	/* Force reset */
	HTAnchor_resetUCInfoStage(anchor, o, UCT_STAGE_PARSER,
	/* Preserve change this: */
				  anchor->UCStages->s[UCT_STAGE_PARSER].lock);
    }
#endif

a4003 1
    context->active_include = NULL;
d4009 1
a4009 1
#ifdef USE_PRETTYSRC
d4012 2
a4013 3
	mark_htext_as_source = TRUE;
	SGML_string(context,
		    "<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
d4017 1
a4017 1
	context->seen_nonwhite_in_junk_tag = FALSE;
d4025 5
a4029 5
 *		====================================
 *
 *	Added 24-Mar-96 by FM, based on:
 *
 ////////////////////////////////////////////////////////////////////////
d4052 1
a4052 1
static int TREAT_SJIS = 1;
d4054 70
a4123 70
void JISx0201TO0208_EUC(unsigned char IHI,
			unsigned char ILO,
			unsigned char *OHI,
			unsigned char *OLO)
{
    static const char *table[] =
    {
	"\241\243",		/* A1,A3 */
	"\241\326",		/* A1,D6 */
	"\241\327",		/* A1,D7 */
	"\241\242",		/* A1,A2 */
	"\241\246",		/* A1,A6 */
	"\245\362",		/* A5,F2 */
	"\245\241",		/* A5,A1 */
	"\245\243",		/* A5,A3 */
	"\245\245",		/* A5,A5 */
	"\245\247",		/* A5,A7 */
	"\245\251",		/* A5,A9 */
	"\245\343",		/* A5,E3 */
	"\245\345",		/* A5,E5 */
	"\245\347",		/* A5,E7 */
	"\245\303",		/* A5,C3 */
	"\241\274",		/* A1,BC */
	"\245\242",		/* A5,A2 */
	"\245\244",		/* A5,A4 */
	"\245\246",		/* A5,A6 */
	"\245\250",		/* A5,A8 */
	"\245\252",		/* A5,AA */
	"\245\253",		/* A5,AB */
	"\245\255",		/* A5,AD */
	"\245\257",		/* A5,AF */
	"\245\261",		/* A5,B1 */
	"\245\263",		/* A5,B3 */
	"\245\265",		/* A5,B5 */
	"\245\267",		/* A5,B7 */
	"\245\271",		/* A5,B9 */
	"\245\273",		/* A5,BB */
	"\245\275",		/* A5,BD */
	"\245\277",		/* A5,BF */
	"\245\301",		/* A5,C1 */
	"\245\304",		/* A5,C4 */
	"\245\306",		/* A5,C6 */
	"\245\310",		/* A5,C8 */
	"\245\312",		/* A5,CA */
	"\245\313",		/* A5,CB */
	"\245\314",		/* A5,CC */
	"\245\315",		/* A5,CD */
	"\245\316",		/* A5,CE */
	"\245\317",		/* A5,CF */
	"\245\322",		/* A5,D2 */
	"\245\325",		/* A5,D5 */
	"\245\330",		/* A5,D8 */
	"\245\333",		/* A5,DB */
	"\245\336",		/* A5,DE */
	"\245\337",		/* A5,DF */
	"\245\340",		/* A5,E0 */
	"\245\341",		/* A5,E1 */
	"\245\342",		/* A5,E2 */
	"\245\344",		/* A5,E4 */
	"\245\346",		/* A5,E6 */
	"\245\350",		/* A5,E8 */
	"\245\351",		/* A5,E9 */
	"\245\352",		/* A5,EA */
	"\245\353",		/* A5,EB */
	"\245\354",		/* A5,EC */
	"\245\355",		/* A5,ED */
	"\245\357",		/* A5,EF */
	"\245\363",		/* A5,F3 */
	"\241\253",		/* A1,AB */
	"\241\254"		/* A1,AC */
d4135 4
a4138 1
static int IS_SJIS_STR(const unsigned char *str)
d4140 2
a4141 19
    const unsigned char *s;
    unsigned char ch;
    int is_sjis = 0;

    s = str;
    while ((ch = *s++) != '\0') {
	if (ch & 0x80)
	    if (IS_SJIS(ch, *s, is_sjis))
		return 1;
    }
    return 0;
}

unsigned char *SJIS_TO_JIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *JCODE)
{
    HI -= UCH((HI <= 0x9F) ? 0x71 : 0xB1);
    HI = UCH((HI << 1) + 1);
d4145 1
a4145 1
	LO -= UCH(0x7D);
d4148 1
a4148 1
	LO -= UCH(0x1F);
d4155 4
a4158 3
unsigned char *JIS_TO_SJIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *SJCODE)
d4161 1
a4161 1
	LO += UCH(0x1F);
d4163 1
a4163 1
	LO += UCH(0x7D);
d4167 1
a4167 1
    HI = UCH(((HI - 0x21) >> 1) + 0x81);
d4169 1
a4169 1
	HI += UCH(0x40);
d4175 7
a4181 7
unsigned char *EUC_TO_SJIS1(unsigned char HI,
			    unsigned char LO,
			    register unsigned char *SJCODE)
{
    if (HI == 0x8E)
	JISx0201TO0208_EUC(HI, LO, &HI, &LO);
    JIS_TO_SJIS1(UCH(HI & 0x7F), UCH(LO & 0x7F), SJCODE);
d4185 4
a4188 3
void JISx0201TO0208_SJIS(register unsigned char I,
			 register unsigned char *OHI,
			 register unsigned char *OLO)
d4192 2
a4193 2
    JISx0201TO0208_EUC(0x8E, I, OHI, OLO);
    JIS_TO_SJIS1(UCH(*OHI & 0x7F), UCH(*OLO & 0x7F), SJCODE);
d4198 4
a4201 3
unsigned char *SJIS_TO_EUC1(unsigned char HI,
			    unsigned char LO,
			    unsigned char *data)
d4209 3
a4211 2
unsigned char *SJIS_TO_EUC(unsigned char *src,
			   unsigned char *dst)
d4216 1
a4216 2
    in_sjis = IS_SJIS_STR(src);
    for (sp = src, dp = dst; (hi = sp[0]) != '\0';) {
d4219 1
a4219 1
	    SJIS_TO_JIS1(hi, lo, dp);
d4224 1
a4224 1
	} else
d4226 1
d4232 3
a4234 2
unsigned char *EUC_TO_SJIS(unsigned char *src,
			   unsigned char *dst)
d4241 1
a4241 1
		JIS_TO_SJIS1(UCH(sp[0] & 0x7F), UCH(sp[1] & 0x7F), dp);
d4255 5
a4259 6
#define Strcpy(a,b)	(strcpy((char*)a,(const char*)b),&a[strlen((const char*)a)])

unsigned char *EUC_TO_JIS(unsigned char *src,
			  unsigned char *dst,
			  const char *toK,
			  const char *toA)
d4265 1
a4265 1
    int is_JIS = 0;
d4267 1
a4267 1
    while ((cch = *sp++) != '\0') {
a4268 7
	    if (!IS_EUC(cch, *sp)) {
		if (cch == 0xA0 && is_JIS)	/* ignore NBSP */
		    continue;
		is_JIS++;
		*dp++ = cch;
		continue;
	    }
d4270 4
a4273 2
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toK);
d4276 2
a4277 2
		*dp++ = UCH(cch & ~0x80);
		*dp++ = UCH(*sp++ & ~0x80);
d4281 5
a4285 2
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toA);
d4290 5
a4294 2
    if (kana_mode)
	dp = Strcpy(dp, toA);
d4301 3
a4303 32
#define	IS_JIS7(c1,c2)	(0x20<(c1)&&(c1)<0x7F && 0x20<(c2)&&(c2)<0x7F)
#define SO		('N'-0x40)
#define SI		('O'-0x40)

static int repair_JIS = 0;

static const unsigned char *repairJIStoEUC(const unsigned char *src,
					   unsigned char **dstp)
{
    const unsigned char *s;
    unsigned char *d, ch1, ch2;

    d = *dstp;
    s = src;
    while ((ch1 = s[0]) && (ch2 = s[1])) {
	s += 2;
	if (ch1 == '(')
	    if (ch2 == 'B' || ch2 == 'J') {
		*dstp = d;
		return s;
	    }
	if (!IS_JIS7(ch1, ch2))
	    return 0;

	*d++ = UCH(0x80 | ch1);
	*d++ = UCH(0x80 | ch2);
    }
    return 0;
}

unsigned char *TO_EUC(const unsigned char *jis,
		      unsigned char *euc)
d4305 2
a4306 3
    register const unsigned char *s;
    register unsigned char c, jis_stat;
    unsigned char *d;
a4308 3
    static int nje;
    int n8bits;
    int is_JIS;
a4309 2
    nje++;
    n8bits = 0;
a4314 2
    in_sjis = IS_SJIS_STR(jis);
    is_JIS = 0;
d4316 1
a4316 16
    while ((c = *s++) != '\0') {
	if (c == 0x80)
	    continue;		/* ignore it */
	if (c == 0xA0 && is_JIS)
	    continue;		/* ignore Non-breaking space */

	if (c == to2B && jis_stat == 0 && repair_JIS) {
	    if (*s == 'B' || *s == '@@') {
		const unsigned char *ts;

		if ((ts = repairJIStoEUC(s + 1, &d)) != NULL) {
		    s = ts;
		    continue;
		}
	    }
	}
d4319 1
a4319 1
		if ((s[1] == 'B') || (s[1] == '@@')) {
d4322 4
a4325 1
		    is_JIS++;
d4328 8
a4335 6
		jis_stat = 0;
	    } else if (*s == to1B) {
		jis_stat = 0;
		if ((s[1] == 'B') || (s[1] == 'J') || (s[1] == 'H')) {
		    s += 2;
		    continue;
a4336 2
	    } else if (*s == ',') {	/* MULE */
		jis_stat = 0;
d4339 1
a4339 4
	if (c & 0x80)
	    n8bits++;

	if (IS_SJIS(c, *s, in_sjis)) {
a4342 13
	    is_JIS++;
	} else if (jis_stat) {
	    if (c <= 0x20 || 0x7F <= c) {
		*d++ = c;
		if (c == '\n')
		    jis_stat = 0;
	    } else {
		if (IS_JIS7(c, *s)) {
		    *d++ = jis_stat | c;
		    *d++ = jis_stat | *s++;
		} else
		    *d++ = c;
	    }
d4344 2
a4345 1
	    if (n8bits == 0 && (c == SI || c == SO)) {
d4355 3
a4357 26
#define non94(ch) ((ch) <= 0x20 || (ch) == 0x7F)

static int is_EUC_JP(unsigned char *euc)
{
    unsigned char *cp;
    int ch1, ch2;

    for (cp = euc; (ch1 = *cp) != '\0'; cp++) {
	if (ch1 & 0x80) {
	    ch2 = cp[1] & 0xFF;
	    if ((ch2 & 0x80) == 0) {
		/* sv1log("NOT_EUC1[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    if (non94(ch1 & 0x7F) || non94(ch2 & 0x7F)) {
		/* sv1log("NOT_EUC2[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    cp++;
	}
    }
    return 1;
}

void TO_SJIS(const unsigned char *arg,
	     unsigned char *sjis)
d4361 2
a4362 1
    euc = typeMallocn(unsigned char, strlen((const char *) arg) + 1);
d4364 2
a4365 2
#ifdef CJK_EX
    if (!euc)
d4367 4
a4370 7
#endif
    TO_EUC(arg, euc);
    if (is_EUC_JP(euc))
	EUC_TO_SJIS(euc, sjis);
    else
	strcpy((char *) sjis, (const char *) arg);
    free(euc);
d4373 3
a4375 2
void TO_JIS(const unsigned char *arg,
	    unsigned char *jis)
d4379 1
a4379 2
    if (arg[0] == 0) {
	jis[0] = 0;
d4381 3
a4383 4
    }
    euc = typeMallocn(unsigned char, strlen((const char *)arg) + 1);
#ifdef CJK_EX
    if (!euc)
d4385 2
a4386 3
#endif
    TO_EUC(arg, euc);
    is_EUC_JP(euc);
d4388 1
a4388 2

    free(euc);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a31 1
#include <LYGlobalDefs.h>
d38 1
a38 1
#ifdef USE_PRETTYSRC
d44 6
a49 1
#ifdef USE_PRETTYSRC
d65 5
d72 2
a73 20
/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
#define my_casecomp(a,b)  ((TOUPPER(*a) == TOUPPER(*b)) ? \
			AS_casecomp(a,b) : \
			(TOASCII(TOUPPER(*a)) - TOASCII(TOUPPER(*b))))

 /* will use partially inlined version */
#define orig_HTChunkPutUtf8Char HTChunkPutUtf8Char
#undef HTChunkPutUtf8Char

/* ...used for comments and attributes value like href... */
#define HTChunkPutUtf8Char(ch,x) \
    { \
    if ((TOASCII(x) < 128)  && (ch->size < ch->allocated)) \
	ch->data[ch->size++] = (char)x; \
    else \
	orig_HTChunkPutUtf8Char(ch,x); \
    }

#if 0
#define orig_HTChunkPutc HTChunkPutc
d75 10
a84 14

#define HTChunkPutc(ch,x) \
    { \
    if (ch->size < ch->allocated) \
	ch->data[ch->size++] = x; \
    else \
	orig_HTChunkPutc(ch,x); \
    }

#undef HTChunkTerminate

#define HTChunkTerminate(ch) \
    HTChunkPutc(ch, (char)0)
#endif /* */
a86 3
#define PUTC(ch)  ((*context->actions->put_character)(context->target, ch))
#define PUTUTF8(code) (UCPutUtf8_charstring((HTStream *)context->target, \
		      (putc_func_t*)(context->actions->put_character), code))
a87 1
#define OPT 1
d89 3
d102 2
a123 45
typedef enum {
    S_text = 0
    ,S_attr
    ,S_attr_gap
    ,S_comment
    ,S_cro
    ,S_doctype
    ,S_dollar
    ,S_dollar_dq
    ,S_dollar_paren
    ,S_dollar_paren_dq
    ,S_dollar_paren_sq
    ,S_dollar_sq
    ,S_dquoted
    ,S_end
    ,S_entity
    ,S_equals
    ,S_ero
    ,S_esc
    ,S_esc_dq
    ,S_esc_sq
    ,S_exclamation
    ,S_in_kanji
    ,S_incro
    ,S_junk_pi
    ,S_junk_tag
    ,S_litteral
    ,S_marked
    ,S_nonascii_text
    ,S_nonascii_text_dq
    ,S_nonascii_text_sq
    ,S_paren
    ,S_paren_dq
    ,S_paren_sq
    ,S_pcdata
    ,S_script
    ,S_sgmlatt
    ,S_sgmlele
    ,S_sgmlent
    ,S_squoted
    ,S_tag
    ,S_tag_gap
    ,S_tagname_slash
    ,S_value
} sgml_state;
a136 1
    HTTag			*slashedtag;
a138 1
    BOOL			no_lynx_specialcodes;
a140 2
    int				leading_spaces;
    int				trailing_spaces;
d142 13
a154 2
    sgml_state			state;
    unsigned char kanji_buf;
d159 1
a159 1
    char * value[MAX_ATTRIBUTES];	/* NULL, or strings alloc'd with StrAllocCopy_extra() */
a183 1
    char *			active_include;
d188 1
a188 6
#ifdef USE_PRETTYSRC
    BOOL			cur_attr_is_href;
    BOOL			cur_attr_is_name;
    BOOL			seen_nonwhite_in_junk_tag;
#endif
};
d190 2
a191 75
#ifndef NO_LYNX_TRACE
PRIVATE char *state_name ARGS1(sgml_state, n)
{
    char *result = "?";
    switch (n) {
    case S_attr:                result = "S_attr";              break;
    case S_attr_gap:            result = "S_attr_gap";          break;
    case S_comment:             result = "S_comment";           break;
    case S_cro:                 result = "S_cro";               break;
    case S_doctype:             result = "S_doctype";           break;
    case S_dollar:              result = "S_dollar";            break;
    case S_dollar_dq:           result = "S_dollar_dq";         break;
    case S_dollar_paren:        result = "S_dollar_paren";      break;
    case S_dollar_paren_dq:     result = "S_dollar_paren_dq";   break;
    case S_dollar_paren_sq:     result = "S_dollar_paren_sq";   break;
    case S_dollar_sq:           result = "S_dollar_sq";         break;
    case S_dquoted:             result = "S_dquoted";           break;
    case S_end:                 result = "S_end";               break;
    case S_entity:              result = "S_entity";            break;
    case S_equals:              result = "S_equals";            break;
    case S_ero:                 result = "S_ero";               break;
    case S_esc:                 result = "S_esc";               break;
    case S_esc_dq:              result = "S_esc_dq";            break;
    case S_esc_sq:              result = "S_esc_sq";            break;
    case S_exclamation:         result = "S_exclamation";       break;
    case S_in_kanji:            result = "S_in_kanji";          break;
    case S_incro:               result = "S_incro";             break;
    case S_junk_pi:             result = "S_junk_pi";           break;
    case S_junk_tag:            result = "S_junk_tag";          break;
    case S_litteral:            result = "S_litteral";          break;
    case S_marked:              result = "S_marked";            break;
    case S_nonascii_text:       result = "S_nonascii_text";     break;
    case S_nonascii_text_dq:    result = "S_nonascii_text_dq";  break;
    case S_nonascii_text_sq:    result = "S_nonascii_text_sq";  break;
    case S_paren:               result = "S_paren";             break;
    case S_paren_dq:            result = "S_paren_dq";          break;
    case S_paren_sq:            result = "S_paren_sq";          break;
    case S_pcdata:              result = "S_pcdata";            break;
    case S_script:              result = "S_script";            break;
    case S_sgmlatt:             result = "S_sgmlatt";           break;
    case S_sgmlele:             result = "S_sgmlele";           break;
    case S_sgmlent:             result = "S_sgmlent";           break;
    case S_squoted:             result = "S_squoted";           break;
    case S_tag:                 result = "S_tag";               break;
    case S_tag_gap:             result = "S_tag_gap";           break;
    case S_tagname_slash:       result = "S_tagname_slash";     break;
    case S_text:                result = "S_text";              break;
    case S_value:               result = "S_value";             break;
    }
    return result;
}
#endif

/* storage for Element Stack */
#define DEPTH 10
static HTElement pool[DEPTH];
static int depth = 0;

PRIVATE HTElement* pool_alloc NOARGS
{
    depth++;
    if (depth > DEPTH)
	return (HTElement*) malloc(sizeof(HTElement));
    return (pool + depth - 1);
}

PRIVATE void pool_free ARGS1(HTElement*, e)
{
    if (depth > DEPTH)
	FREE(e);
    depth--;
    return;
}

#ifdef USE_PRETTYSRC
d195 1
a195 1
	    HTlexeme,	      lexeme,
d198 1
a198 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d209 1
a209 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
a226 1
#if ANSI_PREPRO
d228 1
a228 5
#  define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_##x,STOP)
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_/**/x,START)
#  define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_/**/x,STOP)
#endif
d230 2
a231 2
#define attr_is_href context->cur_attr_is_href
#define attr_is_name context->cur_attr_is_name
d242 1
a242 1
	**  so the HTML parser's UCLYhndl should still be its
d336 8
d346 1
a346 1
static int current_is_class = 0;
d358 1
d363 1
a363 1
#ifdef USE_PRETTYSRC
d365 2
a366 2
	attr_is_href = FALSE;
	attr_is_name = FALSE;
d373 1
a373 1
#ifdef USE_PRETTYSRC
d387 1
a387 1
	diff = my_casecomp(attributes[i].name, s);
d390 2
a391 5
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		attr_is_name = (BOOL) (attributes[i].type == HTMLA_ANAME);
		attr_is_href = (BOOL) (attributes[i].type == HTMLA_HREF);
	    } else
a392 1
	    {
d394 1
a394 1
	    Clear_extra(context->value[i]);
d396 4
a399 1
#   ifdef USE_PRETTYSRC
d401 1
d405 1
a405 1
	    CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
d407 5
d413 1
d419 2
a420 2
    CTRACE((tfp, "SGML: Unknown attribute %s for tag %s\n",
		s, context->current_tag->name));
d433 1
a433 1
	StrAllocCopy_extra(context->value[context->current_attribute_number], s);
d438 1
a438 1
	    CTRACE((tfp, "SGML: class is '%s'\n", s));
d442 1
a442 1
	    CTRACE((tfp, "SGML: attribute value is '%s'\n", s));
d446 1
a446 1
	CTRACE((tfp, "SGML: Attribute value %s ***ignored\n", s));
a465 8
    /* (Tgf_nolyspcl) */
    if (context->no_lynx_specialcodes) {
	/*
	**  We were asked by a "DTD" flag to not generate lynx specials. - kw
	*/
	return NO;
    }

d470 1
a470 1
#ifdef USE_PRETTYSRC
d478 1
a478 1
#ifdef USE_PRETTYSRC
d493 1
a493 2
	**
	**  We may treat emsp as one or two ensp (below).
d495 1
a495 1
#ifdef USE_PRETTYSRC
d503 1
a503 1
#ifdef USE_PRETTYSRC
d508 1
a508 1
#ifdef USE_PRETTYSRC
a522 21
#ifdef USE_PRETTYSRC
PRIVATE void put_pretty_entity ARGS2(HTStream *, context, int, term)
{
    PSRCSTART(entity);
    PUTC('&');
    PUTS(entity_string);
    if (term)
	PUTC((char)term);
    PSRCSTOP(entity);
}

PRIVATE void put_pretty_number ARGS1(HTStream *, context)
{
    PSRCSTART(entity);
    PUTS( (context->isHex ? "&#x" : "&#") );
    PUTS(entity_string);
    PUTC(';');
    PSRCSTOP(entity);
}
#endif /* USE_PRETTYSRC */

d546 1
d549 1
d560 1
a560 1
#ifdef USE_PRETTYSRC
d562 6
a567 1
		put_pretty_entity(context, term);
d581 1
a581 1
#ifdef USE_PRETTYSRC
d583 3
a585 1
		put_pretty_entity(context, term);
d599 1
a599 1
#ifdef USE_PRETTYSRC
d601 6
a606 1
		put_pretty_entity(context, term);
d609 2
a610 1
	    PUTS(replace_buf);
d617 1
a617 1
#ifndef USE_PRETTYSRC
d625 1
a625 1
	      (putc_func_t*)(fake_put_character), code)): PUTUTF8(code) ) ) {
d628 3
a630 1
		put_pretty_entity(context, term);
d641 1
a641 1
#ifdef USE_PRETTYSRC
d643 6
a648 1
		put_pretty_entity(context, term);
d664 2
a665 2
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
d667 6
a672 1
		put_pretty_entity(context, term);
d683 2
a684 2
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
d686 6
a691 1
		put_pretty_entity(context, term);
d702 1
a702 1
#ifdef USE_PRETTYSRC
d706 1
a706 1
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long)code, uck)); /* S/390 -- gil -- 0695 */
d708 3
a710 1
    PUTS(s);
d713 1
a713 1
#ifdef USE_PRETTYSRC
d728 1
a728 1
    CTRACE((tfp, "SGML Comment:\n<%s>\n", s));
d750 1
a750 1
    CTRACE((tfp, "SGML Identifier:\n<%s>\n", s));
d764 1
a764 1
    CTRACE((tfp, "SGML Doctype:\n<%s>\n", s));
a768 4
PRIVATE void SGML_write PARAMS((
	HTStream *		me,
	CONST char *		s,
	int			l));
d778 1
a778 1
    CTRACE((tfp, "SGML Marked Section:\n<%s>\n", s));
a779 13
    if (!strncmp(context->string->data, "![INCLUDE[", 10)) {
	context->string->data[context->string->size - 3] = '\0';
	StrAllocCat(context->include, context->string->data + 10);
	/* @@@@@@ This needs to take charset into account! @@@@@@
	   the wrong assumptions will be made about the data's
	   charset once it is in include - kw */

    } else if (!strncmp(context->string->data, "![CDATA[", 8)) {
	(*context->actions->_write)(context->target,
		   context->string->data + 8,
		   context->string->size - 11);

    }
d792 1
a792 1
    CTRACE((tfp, "SGML Entity Declaration:\n<%s>\n", s));
d806 1
a806 1
    CTRACE((tfp, "SGML Element Declaration:\n<%s>\n", s));
d820 1
a820 1
    CTRACE((tfp, "SGML Attribute Declaration:\n<%s>\n", s));
a824 30
/*
 *  Convenience macros - tags (elements) are identified sometimes
 *  by an int or enum value ('TAGNUM'), sometimes
 *  by a pointer to HTTag ('TAGP'). - kw
 */
#define TAGNUM_OF_TAGP(t) (t - context->dtd->tags)
#define TAGP_OF_TAGNUM(e) (context->dtd->tags + e)

/*
 *  The following implement special knowledge about OBJECT.
 *  As long as HTML_OBJECT is the only tag for which an alternative
 *  variant exist, they can be simple macros. - kw
 */
/* does 'TAGNUM' e have an alternative (variant) parsing mode? */
#define HAS_ALT_TAGNUM(e) (e == HTML_OBJECT)

/* return 'TAGNUM' of the alternative mode for 'TAGNUM' e, if any. */
#define ALT_TAGNUM(e) ((e == HTML_OBJECT) ? HTML_ALT_OBJECT : e)

/* return 'TAGNUM' of the normal mode for 'TAGNUM' e which may be alt. */
#define NORMAL_TAGNUM(e) ((e >= HTML_ELEMENTS) ? HTML_OBJECT : e)

/* More convenience stuff. - kw */
#define ALT_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(ALT_TAGNUM(e))
#define NORMAL_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(NORMAL_TAGNUM(e))

#define ALT_TAGP(t) ALT_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))
#define NORMAL_TAGP(t) NORMAL_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))


d838 1
a838 1
	return (BOOL) ((Tgc_same & usecontains) &&
d841 1
a841 1
	return (BOOL) ((new_tag->tagclass & usecontains) &&
d845 2
a871 1
    HTMLElement e;
a876 4
    e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(stacked->tag));
#ifdef USE_PRETTYSRC
    if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
#endif
d879 1
a879 1
	e,
d882 1
a882 3
    pool_free(stacked);
    context->no_lynx_specialcodes = context->element_stack ?
	(context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
d892 1
a892 2
	if (stacked->tag == old_tag ||
	    stacked->tag == ALT_TAGP(old_tag))
a915 5
	    if (stackpos == 0 && (old_tag->flags & Tgf_startO) &&
		element_valid_within(old_tag, context->element_stack->tag, YES)) {
		CTRACE((tfp, "SGML: </%s> ignored\n", old_tag->name));
		return;
	    }
d918 1
a918 1
		CTRACE((tfp, "SGML: End </%s> \t<- %s end </%s>\n",
d921 1
a921 1
			    old_tag->name));
d925 5
d934 1
a934 1
	    CTRACE((tfp, "SGML: Still open %s, ***no open %s for </%s>\n",
d938 1
a938 1
			old_tag->name));
d942 1
a942 1
	    CTRACE((tfp, "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
d945 1
a945 1
			old_tag->name));
d967 2
a968 2
	    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
			old_tag->name));
d975 1
a975 1
    CTRACE((tfp, "SGML: End </%s>\n", old_tag->name));
d977 2
a978 2
	CTRACE((tfp, "SGML: ***Illegal end tag </%s> found.\n",
		    old_tag->name));
a986 2
	int status = HT_OK;
	HTMLElement e;
d988 1
a988 1
	HTTag * t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;
d992 2
a993 2
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			     old_tag->name, t->name, t->name));
d995 2
a996 2
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			    old_tag->name, t->name, old_tag->name));
d1001 4
a1004 25
	e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(t));
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", t, e));
#ifdef USE_PRETTYSRC
	if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
#endif
	    status = (*context->actions->end_element)(context->target,
						e, (char **)&context->include);
	if (status == HT_PARSER_REOPEN_ELT) {
	    CTRACE((tfp, "SGML: Restart <%s>\n", t->name));
	    (*context->actions->start_element)(
		context->target,
		e,
		NULL,
		NULL,
		context->current_tag_charset,
		(char **)&context->include);
	} else if (status == HT_PARSER_OTHER_CONTENT) {
	    CTRACE((tfp, "SGML: Continue with other content model for <%s>\n", t->name));
	    context->element_stack->tag = ALT_TAGP_OF_TAGNUM(e);
	} else {
	    context->element_stack = N->next;		/* Remove from stack */
	    pool_free(N);
	}
	context->no_lynx_specialcodes = context->element_stack ?
	    (context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
d1015 2
a1016 2
    CTRACE((tfp, "SGML: Extra end tag </%s> found and ignored.\n",
		old_tag->name));
a1024 1
    int status;
d1026 2
a1027 1
    HTMLElement e = TAGNUM_OF_TAGP(new_tag);
d1029 1
d1047 1
a1047 1
		CTRACE((tfp, "SGML: End </%s> \t<- %s start <%s>\n",
d1050 1
a1050 1
			    new_tag->name));
d1056 1
a1056 1
		CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1058 1
a1058 1
			    new_tag->name));
d1065 1
a1065 1
	    CTRACE((tfp, "SGML: Still open %s \t<- ***ignoring start <%s>\n",
d1067 1
a1067 1
			new_tag->name));
d1078 1
a1078 1
		CTRACE((tfp, "SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
d1081 1
a1081 1
			    new_tag->name));
d1093 1
a1093 1
	    CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1095 1
a1095 1
			new_tag->name));
a1111 1
	**  (frequent case!)
d1113 1
a1113 2
	/* my_casecomp() - optimized by the first character */
	if (!my_casecomp(new_tag->name, "SELECT")) {
d1127 10
d1146 2
a1147 2
	    if (ok)
	    {
d1152 2
a1153 2
		CTRACE((tfp, "SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			    new_tag->name));
d1159 2
a1160 2
		CTRACE((tfp, "SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			    new_tag->name));
d1168 2
a1169 2
    CTRACE((tfp, "SGML: Start <%s>\n", new_tag->name));
    status = (*context->actions->start_element)(
d1171 1
a1171 1
	TAGNUM_OF_TAGP(new_tag),
a1175 2
    if (status == HT_PARSER_OTHER_CONTENT)
	new_tag = ALT_TAGP(new_tag);	/* this is only returned for OBJECT */
d1177 1
a1177 1
	HTElement * N = pool_alloc();
d1183 3
a1185 2
	context->no_lynx_specialcodes = (new_tag->flags & Tgf_nolyspcl);

d1187 1
d1210 1
a1210 1
	CONST char *,		s)
a1212 5
    static HTTag* last[64] = {NULL};  /*optimize using the previous results*/
    HTTag** res = last + (UCH(*s) % 64);     /*pointer arithmetic*/

    if (*res && !strcasecomp((*res)->name, s))
	return *res;
d1215 2
a1216 2
	  high > low;
	  diff < 0 ? (low = i+1) : (high = i)) {	/* Binary search */
d1218 1
a1218 2
	/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
	diff = my_casecomp(dtd->tags[i].name, s);	/* Case insensitive */
d1220 1
a1220 2
	    *res = &dtd->tags[i];
	    return *res;
d1223 1
a1223 1
    if (IsNmStart(*s)) {
a1253 1
    FREE(context->active_include);
d1262 3
a1264 7
	pool_free(cur);
#ifdef USE_PRETTYSRC
	if (!psrc_view) /* Don't actually call on target if viewing psrc - kw */
#endif
	    (*context->actions->end_element)(context->target,
		    NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
		    (char **)&context->include);
d1278 1
a1278 1
	FREE_extra(context->value[i]);
d1281 2
a1282 2
#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
a1302 1
    FREE(context->active_include);
d1312 1
a1312 1
	pool_free(cur);
d1320 1
a1320 1
	FREE_extra(context->value[i]);
d1323 2
a1324 2
#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
d1326 1
d1360 1
a1360 1
    HTTag * testtag = NULL;
a1362 4
    int testlast;
#ifdef CJK_EX
    unsigned char c;
#else
a1363 1
#endif
d1374 1
a1374 1
    clong = UCH(c);	/* a.k.a. unsign_c */
d1382 1
a1382 1
	if (TOASCII(UCH(c)) > 127) { /* S/390 -- gil -- 0710 */
d1519 2
a1520 1
		    PUTS(replace_buf);
a1545 3
**  Stuff from the recover buffer is now handled
**  as UTF-8 if we can expect that's what it is,
**  and in that case we don't come back up here. - kw
d1558 1
a1558 1
    clong = UCH(c);
d1580 1
a1580 1
	goto after_switch;
d1590 1
a1590 1
	goto after_switch;
d1598 1
a1598 20
	goto after_switch;

    /* Almost all CJK characters are double byte but only Japanese
     * JIS X0201 Kana is single byte. To prevent to fail SGML parsing
     * we have to care them here. -- TH
     */
    if ((HTCJK==JAPANESE) && (context->state==S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
	if (IS_SJIS_X0201KANA(context->kanji_buf)) {
	    unsigned char sjis_hi, sjis_lo;
	    JISx0201TO0208_SJIS(context->kanji_buf, &sjis_hi, &sjis_lo);
	    PUTC(sjis_hi);
	    PUTC(sjis_lo);
	}
	else
#endif
	    PUTC(context->kanji_buf);
	context->state = S_text;
    }
a1602 5
    CTRACE2(TRACE_SGML, (tfp, "SGML before %s|%.*s|%c|\n",
	    state_name(context->state),
	    string->size,
	    NonNull(string->data),
	    UCH(c)));
a1616 1
	PUTC(context->kanji_buf);
a1619 12
    case S_tagname_slash:
	/*
	 *  We had something link "<name/" so far, set state to S_text
	 *  but keep context->slashedtag as as a flag; except if we get
	 *  '>' directly after the "<name/", and really have a tag for
	 *  that name in context->slashedtag, in which case keep state as
	 *  is and let code below deal with it. - kw
	 */
	if (!(c == '>' && context->slashedtag && TOASCII(unsign_c) < 127)) {
	    context->state = S_text;
	} /* fall through in any case! */

d1633 1
a1633 1
	    context->kanji_buf = c;
a1643 13

	if (c == '&' || c == '<') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) { /*there is nothing useful in the element_stack*/
		testtag = context->current_tag;
	    } else
#endif
	    {
		testtag = context->element_stack ?
		     context->element_stack->tag : NULL;
	    }
	}

d1645 6
a1650 8
	    (!testtag ||
	     (testtag->contents == SGML_MIXED ||
	      testtag->contents == SGML_ELEMENT ||
	      testtag->contents == SGML_PCDATA ||
#ifdef USE_PRETTYSRC
	      testtag->contents == SGML_EMPTY ||
#endif
	      testtag->contents == SGML_RCDATA))) {
d1661 5
a1665 75
	    if (testtag && testtag->contents == SGML_PCDATA) {
		context->state = S_pcdata;
	    } else if (testtag && (testtag->contents == SGML_LITTERAL
				|| testtag->contents == SGML_CDATA)) {
		context->state = S_litteral;
	    } else if (testtag && (testtag->contents == SGML_SCRIPT)) {
		context->state = S_script;
	    } else {
		context->state = S_tag;
	    }
	    context->slashedtag = NULL;
	} else if (context->slashedtag &&
		   (c == '/' ||
		    (c == '>' && context->state == S_tagname_slash)) &&
		   TOASCII(unsign_c) < 127) {
	    /*
	    **	We got either the second slash of a pending "<NAME/blah blah/"
	    **  shortref construct, or the '>' of a mere "<NAME/>".  In both
	    **  cases generate a "</NAME>" end tag in the recover buffer for
	    **  reparsing unless NAME is really an empty element. - kw
	    */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC(c);
		PSRCSTOP(abracket);
	    } else
#endif
	    if (context->slashedtag != context->unknown_tag &&
		!ReallyEmptyTag(context->slashedtag)) {
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, "</");
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, "</");
		}
		StrAllocCat(context->recover, context->slashedtag->name);
		StrAllocCat(context->recover, ">");
	    }
	    context->slashedtag = NULL;

	} else if (context->element_stack &&
		   (context->element_stack->tag->flags & Tgf_frecyc)) {
	    /*
	     *  The element stack says we are within the contents of an
	     *  element that the next stage (HTML.c) may want to feed
	     *  us back again (via the *include string).  So try to output
	     *  text in UTF-8 if possible, using the same logic as for
	     *  attribute values (which should be in line with what
	     *  context->current_tag_charset indicates). - kw
	     */
	    if (context->T.decode_utf8 &&
		*context->utf_buf) {
		PUTS(context->utf_buf);
		context->utf_buf_p = context->utf_buf;
		*(context->utf_buf_p) = '\0';
	    } else if (HTCJK == NOCJK &&
		       (context->T.output_utf8 ||
			context->T.trans_from_uni)) {
		if (LYIsASCII(clong)) {
		    PUTC(c);
		} else if (clong == 0xfffd && saved_char_in &&
		    HTPassEightBitRaw &&
		    UCH(saved_char_in) >=
		    LYlowest_eightbit[context->outUCLYhndl]) {
		    PUTUTF8((0xf000 | UCH(saved_char_in)));
		} else {
		    PUTUTF8(clong);
		}
	    } else if (saved_char_in && context->T.use_raw_char_in) {
		PUTC(saved_char_in);
	    } else {
		PUTC(c);
	    }

a1671 1
		   !context->no_lynx_specialcodes &&
a1678 1
		   !context->no_lynx_specialcodes &&
d1696 1
a1696 1
	} else if ((chk = (BOOL) (context->T.trans_from_uni && TOASCII(unsign_c) >= 160)) &&  /* S/390 -- gil -- 0968 */
d1700 2
a1701 2
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck)));
d1721 2
a1722 1
	    PUTS(replace_buf);
d1745 2
a1746 1
#ifdef USE_PRETTYSRC
d1752 2
a1753 1
	    HTChunkPuts(string, EntityName);
d1755 1
a1755 1
#ifdef USE_PRETTYSRC
d1762 1
a1762 1
#ifdef USE_PRETTYSRC
d1785 2
a1786 1
	    PUTS(context->utf_buf);
d1794 2
a1795 2
		   (UCH(saved_char_in) >= 0xc0) &&
		   (UCH(saved_char_in) < 255)) {
d1807 1
a1807 1
	} else if (TOASCII(UCH(c)) <	 /* S/390 -- gil -- 0997 */
d1810 41
a1859 59
    **	Found '<' in SGML_PCDATA content; treat this mode nearly like
    **  S_litteral, but recognize '<!' and '<?' to filter out comments
    **  and processing instructions. - kw
    */
    case S_pcdata:
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
		/*
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    } else if (c == '?') { /* <? - ignore as a PI until '>' - kw */
		CTRACE((tfp,
			"SGML: Found PI in PCDATA, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("<?");
		    PSRCSTOP(abracket);
		    context->seen_nonwhite_in_junk_tag = TRUE; /* show all */
		}
#endif
		context->state = S_junk_pi;
		break;
	    }
	}
	goto case_S_litteral;

    /*
    **  Found '<' in SGML_SCRIPT content; treat this mode nearly like
    **  S_litteral, but recognize '<!' to allow the content to be treated
    **  as a comment by lynx.
    */
    case S_script:
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
		/*
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    }
	}
	goto case_S_litteral;

    /*
a1862 1
    case_S_litteral:
d1865 3
a1867 25
#ifdef USE_PRETTYSRC
	if (psrc_view) { /*there is nothing useful in the element_stack*/
	    testtag = context->current_tag;
	} else
#endif
	    testtag = context->element_stack ?
		context->element_stack->tag : NULL;

	if (testtag == NULL) {
	    string->size--;
	    context->state = S_text;
	    goto top1;
	}

	/*
	 * Normally when we get the closing ">",
	 *	testtag contains something like "TITLE"
	 *	string contains something like "/title>"
	 * so we decrement by 2 to compare the final character of each.
	 */
	testlast = string->size - 2 - context->trailing_spaces - context->leading_spaces;

	if (TOUPPER(c) != ((testlast < 0)
			    ? '/'
			    : testtag->name[testlast])) {
d1874 1
a1874 27
		testlast >= 0 && !testtag->name[testlast]) {
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("</");
		    PSRCSTOP(abracket);
		    PSRCSTART(tag);
		    strcpy(string->data,context->current_tag->name);
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
		    PUTS(string->data);
		    PSRCSTOP(tag);
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);

		    context->current_tag = NULL;
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    context->state = S_text;
		    break;
		}
#endif
a1880 43

	    /*
	     * Allow whitespace between the "<" or ">" and the keyword, for
	     * error-recovery.
	     */
	    if (isspace(UCH(c))) {
		if (testlast == -1) {
		    context->leading_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "leading spaces: %d\n", context->leading_spaces));
		    break;
		} else if (testlast > 0) {
		    context->trailing_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "trailing spaces: %d\n", context->trailing_spaces));
		    break;
		}
	    }

	    /*
	     * Mismatch - recover.
	     */
	    context->leading_spaces = 0;
	    context->trailing_spaces = 0;
	    if (((testtag->contents != SGML_LITTERAL &&
		  (testtag->flags & Tgf_strict)) ||
		 (context->state == S_pcdata &&
		  (testtag->flags & (Tgf_strict|Tgf_endO)))) &&
		(testlast > -1 &&
		 (c == '>' || testlast > 0 || IsNmStart(c)))) {
		context->state = S_end;
		string->size--;
		for (i = 0; i < string->size; i++)  /* remove '/' */
		    string->data[i] = string->data[i+1];
		if ((string->size == 1) ? IsNmStart(c) : IsNmChar(c))
		    break;
		string->size--;
		goto top1;
	    }
	    if (context->state == S_pcdata &&
		(testtag->flags & (Tgf_strict|Tgf_endO)) &&
		(testlast < 0 && IsNmStart(c))) {
		context->state = S_tag;
		break;
	    }
d1882 1
a1882 1
	    **	If Mismatch: recover string literally.
d1911 1
a1911 4
		  isalnum(UCH(c)) : isalpha(UCH(c)))) {
	    /* Should probably use IsNmStart/IsNmChar above (is that right?),
	       but the world is not ready for that - there's &nbsp: (note
	       colon!) and stuff around. */
d1921 1
a1921 1
#ifdef USE_PRETTYSRC
d1926 1
a1926 1
#ifdef USE_PRETTYSRC
d1937 1
a1937 1
#ifdef USE_PRETTYSRC
d1941 1
a1941 1
	    /* CTRACE((tfp, "%s: %d: %s\n", __FILE__, __LINE__, string->data)); */
d1951 1
a1951 1
		CTRACE((tfp, "SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));
d1978 1
a1978 1
#ifdef USE_PRETTYSRC
d1980 1
a1980 1
		PSRCSTART(entity);
d1982 1
a1982 1
		PSRCSTOP(entity);
d1994 1
a1994 1
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {  /* S/390 -- gil -- 1060 */
d1997 1
a1997 1
	} else if (TOASCII(unsign_c) < 127 && isdigit(UCH(c))) {
d2009 1
a2009 1
#ifdef USE_PRETTYSRC
d2015 1
a2015 1
#ifdef USE_PRETTYSRC
d2028 2
a2029 2
	/* S/390 -- gil -- 1075 */ /* CTRACE((tfp, "%s: %d: numeric %d %d\n",
			    __FILE__, __LINE__, unsign_c, c)); */
d2031 2
a2032 2
	    (context->isHex ? isxdigit(UCH(c)) :
			      isdigit(UCH(c)))) {
d2042 1
a2042 1
#ifdef USE_PRETTYSRC
d2046 4
a2049 2
	    PUTS("&#x");
#ifdef USE_PRETTYSRC
d2063 1
a2063 1
#ifdef USE_PRETTYSRC
d2216 1
a2216 1
		    CTRACE((tfp, "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));
d2246 1
a2246 1
#ifdef USE_PRETTYSRC
d2271 1
a2271 1
#ifdef USE_PRETTYSRC
d2275 1
a2275 1
#ifdef USE_PRETTYSRC
d2277 5
a2281 1
			put_pretty_number(context);
d2293 1
a2293 1
#ifdef USE_PRETTYSRC
d2295 5
a2299 1
			put_pretty_number(context);
d2302 3
a2304 1
		    PUTS(replace_buf);
d2310 47
d2374 1
a2374 1
#ifdef USE_PRETTYSRC
d2416 1
a2416 1
#ifdef USE_PRETTYSRC
d2421 2
d2424 1
a2424 1
			    PUTS("&#x");
a2425 2
			} else {
			    PUTS("&#");
d2430 1
a2430 1
#ifdef USE_PRETTYSRC
d2445 1
a2445 1
#ifdef USE_PRETTYSRC
d2447 5
a2451 1
			put_pretty_number(context);
d2463 2
a2464 1
			HTChunkPuts(string, EntityName);
d2479 1
a2479 1
#ifdef USE_PRETTYSRC
d2483 2
d2486 1
a2486 1
			    PUTS("&#x");
a2487 2
			} else {
			    PUTS("&#");
d2492 1
a2492 1
#ifdef USE_PRETTYSRC
d2525 1
a2525 1
#ifdef USE_PRETTYSRC
d2529 6
d2536 1
a2536 1
		    PUTS("&#x");
a2537 2
		} else {
		    PUTS("&#");
a2538 4
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTOP(badseq);
#endif
d2558 1
a2558 1
		  IsNmChar(c) : IsNmStart(c))) {
d2586 1
a2586 1
#ifdef USE_PRETTYSRC
d2591 1
a2591 1
#ifdef USE_PRETTYSRC
d2602 4
a2605 5
		if (string->size == 0) {
		    context->state = S_end;
		    break;
		}
		CTRACE((tfp,"SGML: `<%.*s/' found!\n", string->size, string->data));
d2610 2
a2611 4
	    if (t == context->unknown_tag &&
		((c == ':' &&
		  string->size == 4 && 0 == strcasecomp(string->data, "URL")) ||
		 (string->size > 4 && 0 == strncasecomp(string->data, "URL:", 4)))) {
d2616 2
a2617 1
#ifdef USE_PRETTYSRC
d2622 2
a2623 1
		PUTS(string->data); /* recover */
d2625 1
a2625 1
#ifdef USE_PRETTYSRC
d2629 2
a2630 2
		CTRACE((tfp, "SGML: Treating <%s%c as text\n",
			    string->data, c));
d2634 3
a2636 26
	    }
	    if (c == '/' && t) {
		/*
		 *  Element name was ended by '/'.  Remember the tag that
		 *  ended thusly, we'll interpret this as either an indication
		 *  of an empty element (if '>' follows directly) or do
		 *  some SGMLshortref-ish treatment. - kw
		 */
		context->slashedtag = t;
	    }
	    if (!t) {
		if (c == '?' && string->size <= 1) {
		    CTRACE((tfp, "SGML: Found PI, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(abracket);
			PUTS("<?");
			PSRCSTOP(abracket);
			context->seen_nonwhite_in_junk_tag = TRUE; /*show all*/
		    }
#endif
		    context->state = S_junk_pi;
		    break;
		}
		CTRACE((tfp, "SGML: *** Invalid element %s\n",
			    string->data));
d2638 1
a2638 1
#ifdef USE_PRETTYSRC
d2640 1
a2640 3
		    PSRCSTART(abracket);
		    PUTC('<');
		    PSRCSTOP(abracket);
d2649 1
d2652 1
a2652 5
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    } else {
			PUTC(c);
d2659 2
a2660 2
		CTRACE((tfp, "SGML: *** Unknown element %s\n",
			    string->data));
d2669 4
a2672 1
#ifdef USE_PRETTYSRC
d2674 1
a2674 3
		PSRCSTART(abracket);
		PUTC('<');
		PSRCSTOP(abracket);
a2685 4
		if (t != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d2690 5
a2694 3
	    /*
	    **	Clear out attributes.
	    */
d2697 1
d2702 1
a2702 1
#ifdef USE_PRETTYSRC
d2704 9
a2712 9
		if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
		    if (c != '<') {
			PSRCSTART(abracket);
			PUTC(c);
			PSRCSTOP(abracket);
			context->state = (c == '>') ? S_text : S_tagname_slash;
		    } else {
			context->state = S_tag;
		    }
a2713 2
		    if (!WHITE(c))
			PUTC(c);
d2718 1
a2718 1
	    if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
d2721 1
a2721 2
		context->state = (c == '>') ? S_text :
		    (c == '<') ? S_tag : S_tagname_slash;
d2767 1
a2767 1
#ifdef USE_PRETTYSRC
d2836 1
a2836 1
#ifdef USE_PRETTYSRC
d2840 1
a2840 1
		    PUTS_TR(string->data);
d2852 2
a2853 1
	    goto S_comment_put_c;
d2878 8
a2885 8
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(comm);
		PUTC('<');
		PUTS_TR(string->data);
		PUTC('>');
		PSRCSTOP(comm);
	    } else
d2887 1
a2887 1
		handle_comment(context);
d2895 1
a2895 1
	if (context->end_comment && !isspace(UCH(c)))
d2897 1
a2897 24

    S_comment_put_c:
	if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (HTCJK == NOCJK &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		UCH(saved_char_in) >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (0xf000 | UCH(saved_char_in)));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
d2914 1
a2914 1
#ifdef USE_PRETTYSRC
d2946 1
a2946 1
#ifdef USE_PRETTYSRC
d2980 1
a2980 1
#ifdef USE_PRETTYSRC
d3017 1
a3017 1
#ifdef USE_PRETTYSRC
d3054 1
a3054 1
#ifdef USE_PRETTYSRC
d3078 1
a3078 1
#ifdef USE_PRETTYSRC
d3083 1
a3083 1
#ifdef USE_PRETTYSRC
d3085 4
d3106 1
a3106 1
#ifdef USE_PRETTYSRC
d3116 2
a3117 2
#ifdef USE_PRETTYSRC
	    } else {
a3129 1
		if (c == '=' ) PUTC('=');
d3131 1
d3138 4
d3161 1
a3161 1
#ifdef USE_PRETTYSRC
d3163 1
a3163 1
		if (context->current_attribute_number == INVALID) {
d3165 1
a3165 1
		} else {
d3167 4
a3170 1
		}
d3174 1
a3174 1
	    } else
d3181 1
a3181 1
#ifdef USE_PRETTYSRC
d3184 1
a3184 1
		if (context->current_attribute_number == INVALID) {
d3186 1
a3186 1
		} else {
a3187 1
		}
d3193 7
d3208 2
a3209 2
	    CTRACE((tfp, "SGML: found = but no value\n"));
#ifdef USE_PRETTYSRC
d3211 4
d3226 1
a3226 1
#ifdef USE_PRETTYSRC
d3236 1
a3236 1
#ifdef USE_PRETTYSRC
d3245 1
a3245 1
#ifdef USE_PRETTYSRC
d3250 1
a3250 1
	/*  no break!  fall through to S_value and process current `c`	 */
d3255 1
a3255 1
#ifdef USE_PRETTYSRC
d3258 1
a3258 1
		if (attr_is_name) {
d3264 1
a3264 1
		} else if (attr_is_href) {
d3269 1
a3269 1
		if (attr_is_href) {
a3278 11
#ifdef CJK_EX	/* Quick hack. - JH7AYN */
	    {   char jis_buf[512];
		if (string->data[0] == '$') {
		  if (string->data[1] == 'B' || string->data[1] == '@@') {
		    jis_buf[0] = '\033';
		    strcpy(jis_buf + 1, string->data);
		    TO_EUC((CONST unsigned char *)jis_buf, (unsigned char *)string->data);
		  }
		}
	    }
#endif
d3282 1
a3282 1
#ifdef USE_PRETTYSRC
d3284 4
d3309 1
a3309 1
		UCH(saved_char_in) >=
d3312 1
a3312 1
				   (0xf000 | UCH(saved_char_in)));
d3326 1
a3326 1
#ifdef USE_PRETTYSRC
d3329 2
a3330 2
		if (attr_is_name) {
		    HTStartAnchor(context->target,string->data, NULL);
d3335 1
a3335 1
		} else if (attr_is_href) {
d3340 1
a3340 1
		if (attr_is_href) {
d3371 1
a3371 1
		UCH(saved_char_in) >=
d3374 1
a3374 1
				   (0xf000 | UCH(saved_char_in)));
d3390 1
a3390 1
#ifdef USE_PRETTYSRC
d3393 2
a3394 2
		if (attr_is_name) {
		    HTStartAnchor(context->target,string->data, NULL);
d3399 1
a3399 1
		} else if (attr_is_href) {
d3404 1
a3404 1
		if (attr_is_href) {
d3438 1
a3438 1
		UCH(saved_char_in) >=
d3441 1
a3441 1
				   (0xf000 | UCH(saved_char_in)));
d3453 1
a3453 2
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1247 */
		  IsNmChar(c) : IsNmStart(c))) {
d3457 1
a3457 1
#ifdef USE_PRETTYSRC
d3469 2
a3470 2
		CTRACE((tfp, "Unknown end tag </%s>\n", string->data));
#ifdef USE_PRETTYSRC
d3473 2
a3474 1
		    PUTS("</");
d3483 2
a3484 9
		    PUTS(string->data);
		    if (c != '>') {
			PUTC(c);
		    } else {
			PSRCSTOP(badtag);
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    }
d3490 1
a3490 1
		BOOL tag_OK = (BOOL) (c == '>' || WHITE(c));
d3492 1
a3492 1
		HTMLElement e = TAGNUM_OF_TAGP(t);
a3495 4
		if (HAS_ALT_TAGNUM(TAGNUM_OF_TAGP(t)) &&
		    context->element_stack &&
		    ALT_TAGP(t) == context->element_stack->tag)
		    context->element_stack->tag = NORMAL_TAGP(context->element_stack->tag);
a3496 1
		if (tag_OK
d3498 3
a3500 1
		 && Old_DTD
a3501 1
		 ) {
a3513 2
		    default:
			break;
d3527 2
a3529 3
#if OPT
		    (branch == 0)
#else
d3540 3
a3542 1
		     !strcasecomp(string->data, "COLGROUP"))
a3543 1
		 ) {
d3548 2
a3549 2
		    CTRACE((tfp, "SGML: `</%s%c' found!  Ignoring it.\n",
				string->data, c));
a3554 1
			context->current_tag = NULL;
d3558 1
a3559 3
#if OPT
			   (branch == 1)
#else
d3571 3
a3573 1
			    !strcasecomp(string->data, "U"))
a3574 1
		) {
d3590 2
a3591 2
			    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
					string->data));
d3597 2
a3598 2
			    CTRACE((tfp, "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
					string->data));
d3601 1
a3601 1
			    CTRACE((tfp, "SGML: End </%s>\n", string->data));
a3602 3
#ifdef USE_PRETTYSRC
			    if (!psrc_view) /* Don't actually call if viewing psrc - kw */
#endif
d3605 1
a3605 1
				 TAGNUM_OF_TAGP(context->current_tag),
d3613 2
a3614 2
			CTRACE((tfp, "SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				    string->data, c, string->data, c));
d3626 1
a3626 1
			CTRACE((tfp, "SGML: End </%s>\n", string->data));
a3627 3
#ifdef USE_PRETTYSRC
			if (!psrc_view) /* Don't actually call if viewing psrc - kw */
#endif
d3630 1
a3630 1
			     TAGNUM_OF_TAGP(context->current_tag),
a3637 1
			context->current_tag = NULL;
d3649 1
a3649 1
#ifdef USE_PRETTYSRC
d3652 2
a3653 1
		PUTS("</");
d3662 2
a3663 3
		PUTS(string->data);
		PSRCSTOP(tag);
		if ( c != '>' ) {
d3665 1
a3665 2
		    PUTC(c);
		} else {
d3677 1
a3677 1
		    CTRACE((tfp,"SGML: `</%s%c' found!\n", string->data, c));
a3679 1
		context->current_tag = NULL;
a3730 2
	if (c < 32)
	    context->state = S_text;
a3827 1
    case S_junk_pi:
d3829 1
a3829 1
#ifdef USE_PRETTYSRC
d3831 1
a3831 3
		if (context->state == S_junk_tag) {
		    PSRCSTOP(badtag);
		}
d3835 1
a3835 1
		context->seen_nonwhite_in_junk_tag = FALSE;
a3837 1
	    context->current_tag = NULL;
d3840 1
a3840 1
#ifdef USE_PRETTYSRC
d3843 1
a3843 1
	    if (!context->seen_nonwhite_in_junk_tag) {
d3845 1
a3845 1
		    context->seen_nonwhite_in_junk_tag = TRUE;
d3847 1
a3847 1
		}
d3850 1
a3850 1
	}
a3853 26
    CTRACE2(TRACE_SGML, (tfp, "SGML after  %s|%.*s|%c|\n",
	    state_name(context->state),
	    string->size,
	    NonNull(string->data),
	    UCH(c)));

after_switch:
    /*
    **	Check whether an external function has added
    **	anything to the include buffer.  If so, move the
    **	new stuff to the beginning of active_include. - kw
    */
    if (context->include != NULL) {
	if (context->include[0] == '\0') {
	    FREE(context->include);
	} else {
	    if (context->active_include &&
		context->active_include[context->include_index] != '\0')
		StrAllocCat(context->include,
			    context->active_include + context->include_index);
	    FREE(context->active_include);
	    context->active_include = context->include;
	    context->include_index = 0;
	    context->include = NULL;
	}
    }
d3870 2
a3871 3
    **	Check whether an external function had added
    **	anything to the include buffer; it should now be
    **  in active_include. - FM / kw
d3873 3
a3875 3
    if (context->active_include != NULL) {
	if (context->active_include[context->include_index] == '\0') {
	    FREE(context->active_include);
d3878 3
a3880 27
	    if (context->current_tag_charset == UTF8 ||
		context->T.trans_from_uni) {
		/*
		 *  If it looks like we would have fed UTF-8 to the
		 *  next processing stage, assume that whatever we were
		 *  fed back is in UTF-8 form, too.  This won't be always
		 *  true for all uses of the include buffer, but it's a
		 *  start. - kw
		 */
		char *puni = context->active_include + context->include_index;
		c = *puni;
		clong = UCGetUniFromUtf8String(&puni);
		if (clong < 256 && clong >= 0) {
			c = ((char)(clong & 0xff));
		}
		saved_char_in = '\0';
		context->include_index = puni - context->active_include + 1;
		goto top1;
	    } else {
		/*
		 *  Otherwise assume no UTF-8 - do charset-naive processing
		 *  and hope for the best. - kw
		 */
		c = context->active_include[context->include_index];
		context->include_index++;
		goto top;
	    }
a3958 2
    context->leading_spaces = 0;
    context->trailing_spaces = 0;
a3963 2
/*    context->extra_tags = dtd->tags + dtd->number_of_tags; */
    context->current_tag = context->slashedtag = NULL;
a3964 1
    context->kanji_buf = '\0';
a3966 1
    context->no_lynx_specialcodes = NO;	/* special codes normally generated */
a3996 13
#ifdef CAN_SWITCH_DISPLAY_CHARSET /* Allow a switch to a more suitable display charset */
    else if (anchor->UCStages
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl >= 0
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl != current_char_set ) {
	int o = anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl;

	anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl = -1; /* Force reset */
	HTAnchor_resetUCInfoStage(anchor, o, UCT_STAGE_PARSER,
				  /* Preserve change this: */
				  anchor->UCStages->s[UCT_STAGE_PARSER].lock);
    }
#endif

a4003 1
    context->active_include = NULL;
d4009 1
a4009 1
#ifdef USE_PRETTYSRC
d4012 2
a4013 3
	mark_htext_as_source = TRUE;
	SGML_string(context,
		    "<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
d4017 1
a4017 1
	context->seen_nonwhite_in_junk_tag = FALSE;
a4134 15
PRIVATE int IS_SJIS_STR ARGS1(CONST unsigned char *, str)
{
    CONST unsigned char *s;
    unsigned char ch;
    int is_sjis = 0;

    s = str;
    while ((ch = *s++) != '\0') {
	if (ch & 0x80)
	    if (IS_SJIS(ch, *s, is_sjis))
		return 1;
    }
    return 0;
}

d4140 2
a4141 2
    HI -= UCH((HI <= 0x9F) ? 0x71 : 0xB1);
    HI = UCH((HI << 1) + 1);
d4145 1
a4145 1
	LO -= UCH(0x7D);
d4148 1
a4148 1
	LO -= UCH(0x1F);
d4161 1
a4161 1
	LO += UCH(0x1F);
d4163 1
a4163 1
	LO += UCH(0x7D);
d4167 1
a4167 1
    HI = UCH(((HI - 0x21) >> 1) + 0x81);
d4169 1
a4169 1
	HI += UCH(0x40);
d4180 2
a4181 3
    if (HI == 0x8E)
	JISx0201TO0208_EUC(HI, LO, &HI, &LO);
    JIS_TO_SJIS1(UCH(HI & 0x7F), UCH(LO & 0x7F), SJCODE);
d4192 2
a4193 2
    JISx0201TO0208_EUC(0x8E, I, OHI, OLO);
    JIS_TO_SJIS1(UCH(*OHI & 0x7F), UCH(*OLO & 0x7F), SJCODE);
d4216 1
a4216 2
    in_sjis = IS_SJIS_STR(src);
    for (sp = src, dp = dst; (hi = sp[0]) != '\0';) {
d4219 1
a4219 1
	    SJIS_TO_JIS1(hi, lo, dp);
d4224 1
a4224 1
	} else
d4226 1
d4241 1
a4241 1
		JIS_TO_SJIS1(UCH(sp[0] & 0x7F), UCH(sp[1] & 0x7F), dp);
d4255 1
a4255 3
#define Strcpy(a,b)	(strcpy((char*)a,(CONST char*)b),&a[strlen((CONST char*)a)])

PUBLIC unsigned char *EUC_TO_JIS ARGS4(
d4265 1
a4265 1
    int is_JIS = 0;
d4267 1
a4267 1
    while ((cch = *sp++) != '\0') {
a4268 7
	    if (!IS_EUC(cch, *sp)) {
		if (cch == 0xA0 && is_JIS)	/* ignore NBSP */
		    continue;
		is_JIS++;
		*dp++ = cch;
		continue;
	    }
d4270 4
a4273 2
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toK);
d4276 2
a4277 2
		*dp++ = UCH(cch & ~0x80);
		*dp++ = UCH(*sp++ & ~0x80);
d4281 5
a4285 2
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toA);
d4290 5
a4294 2
    if (kana_mode)
	dp = Strcpy(dp, toA);
d4301 1
a4301 32
#define	IS_JIS7(c1,c2)	(0x20<(c1)&&(c1)<0x7F && 0x20<(c2)&&(c2)<0x7F)
#define SO		('N'-0x40)
#define SI		('O'-0x40)

PUBLIC int repair_JIS = 0;

PRIVATE CONST unsigned char *repairJIStoEUC ARGS2(
	CONST unsigned char *,	src,
	unsigned char **,	dstp)
{
    CONST unsigned char *s;
    unsigned char *d, ch1, ch2;

    d = *dstp;
    s = src;
    while ((ch1 = s[0]) && (ch2 = s[1])) {
	s += 2;
	if (ch1 == '(')
	    if (ch2 == 'B' || ch2 == 'J') {
		*dstp = d;
		return s;
	    }
	if (!IS_JIS7(ch1, ch2))
	    return 0;

	*d++ = UCH(0x80 | ch1);
	*d++ = UCH(0x80 | ch2);
    }
    return 0;
}

PUBLIC unsigned char *TO_EUC ARGS2(
d4306 1
a4306 2
    register unsigned char c, jis_stat;
    unsigned char *d;
a4308 3
    static int nje;
    int n8bits;
    int is_JIS;
a4309 2
    nje++;
    n8bits = 0;
a4314 2
    in_sjis = IS_SJIS_STR(jis);
    is_JIS = 0;
d4316 1
a4316 15
    while ((c = *s++) != '\0') {
	if (c == 0x80)
	    continue;		/* ignore it */
	if (c == 0xA0 && is_JIS)
	    continue;		/* ignore Non-breaking space */

	if (c == to2B && jis_stat == 0 && repair_JIS) {
	    if (*s == 'B' || *s == '@@') {
		CONST unsigned char *ts;
		if ((ts = repairJIStoEUC(s + 1, &d)) != NULL) {
		    s = ts;
		    continue;
		}
	    }
	}
d4319 1
a4319 1
		if ((s[1] == 'B') || (s[1] == '@@')) {
d4322 4
a4325 1
		    is_JIS++;
d4328 8
a4335 6
		jis_stat = 0;
	    } else if (*s == to1B) {
		jis_stat = 0;
		if ((s[1] == 'B') || (s[1] == 'J') || (s[1] == 'H')) {
		    s += 2;
		    continue;
a4336 2
	    } else if (*s == ',') {	/* MULE */
		jis_stat = 0;
d4339 1
a4339 4
	if (c & 0x80)
	    n8bits++;

	if (IS_SJIS(c, *s, in_sjis)) {
a4342 13
	    is_JIS++;
	} else if (jis_stat) {
	    if (c <= 0x20 || 0x7F <= c) {
		*d++ = c;
		if (c == '\n')
		    jis_stat = 0;
	    } else {
		if (IS_JIS7(c, *s)) {
		    *d++ = jis_stat | c;
		    *d++ = jis_stat | *s++;
		} else
		    *d++ = c;
	    }
d4344 2
a4345 1
	    if (n8bits == 0 && (c == SI || c == SO)) {
a4354 24
#define non94(ch) ((ch) <= 0x20 || (ch) == 0x7F)

PRIVATE int is_EUC_JP ARGS1(unsigned char *, euc)
{
    unsigned char *cp;
    int ch1, ch2;

    for (cp = euc; (ch1 = *cp) != '\0'; cp++) {
	if (ch1 & 0x80) {
	    ch2 = cp[1] & 0xFF;
	    if ((ch2 & 0x80) == 0) {
		/* sv1log("NOT_EUC1[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    if (non94(ch1 & 0x7F) || non94(ch2 & 0x7F)) {
		/* sv1log("NOT_EUC2[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    cp++;
	}
    }
    return 1;
}

d4361 5
a4365 3
    euc = malloc(strlen((CONST char *) any) + 1);
#ifdef CJK_EX
    if (!euc)
d4367 1
a4367 1
#endif
d4369 2
a4370 5
    if (is_EUC_JP(euc))
	EUC_TO_SJIS(euc, sjis);
    else
	strcpy((char *) sjis, (CONST char *) any);
    free(euc);
d4379 1
a4379 2
    if (any[0] == 0) {
	jis[0] = 0;
d4381 3
a4383 4
    }
    euc = malloc(strlen((CONST char *) any) + 1);
#ifdef CJK_EX
    if (!euc)
d4385 1
a4385 1
#endif
a4386 1
    is_EUC_JP(euc);
d4388 1
a4388 2

    free(euc);
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d4345 1
a4345 1
	    if (context->current_tag_charset == UTF8_handle ||
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d2257 5
a2261 1
		} else
d2263 1
a2263 2
		    end_element(context, context->element_stack->tag);

a2266 2
		context->leading_spaces = 0;
		context->trailing_spaces = 0;
d4457 1
@


1.1.3.4
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a67 1
#if ANSI_PREPRO
a97 1
#endif	/* ANSI_PREPRO */
@


1.1.3.5
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d50 3
a52 3
static void fake_put_character (
		    void* p GCC_UNUSED,
		    char  c GCC_UNUSED)
d112 5
a116 5
HTCJKlang HTCJK = NOCJK;		/* CJK enum value.		*/
BOOL HTPassEightBitRaw = FALSE;	/* Pass 161-172,174-255 raw.	*/
BOOL HTPassEightBitNum = FALSE;	/* Pass ^ numeric entities raw. */
BOOL HTPassHighCtrlRaw = FALSE;	/* Pass 127-160,173,&#127; raw. */
BOOL HTPassHighCtrlNum = FALSE;	/* Pass &#128;-&#159; raw.	*/
d189 1
a189 1
    const HTStreamClass *	isa;		/* inherited from HTStream */
d191 2
a192 2
    const SGML_dtd		*dtd;
    const HTStructuredClass	*actions;	/* target class	 */
d197 1
a197 1
    const HTTag			*unknown_tag;
d249 1
a249 1
static char *state_name (sgml_state  n)
d306 1
a306 1
static HTElement* pool_alloc (void)
d314 1
a314 1
static void pool_free (HTElement*  e)
d324 4
a327 4
static void HTMLSRC_apply_markup (
	    HTStream *	      context,
	    HTlexeme	      lexeme,
	    BOOL	      start)
d346 1
a346 1
		(const char **)ts->value,
d370 4
a373 4
static void set_chartrans_handling (
	HTStream *		context,
	HTParentAnchor *	anchor,
	int			chndl)
d443 2
a444 2
static void change_chartrans_handling (
	HTStream *		context)
d480 1
a480 1
/* PUBLIC const char * SGML_default = "";   ?? */
d482 3
a484 3
static void handle_attribute_name (
	HTStream *	context,
	const char *	s)
d549 3
a551 3
static void handle_attribute_value (
	HTStream *	context,
	const char *	s)
d583 3
a585 3
static BOOL put_special_unicodes (
	HTStream *	context,
	UCode_t	code)
d654 1
a654 1
static void put_pretty_entity (HTStream *  context, int  term)
d664 1
a664 1
static void put_pretty_number (HTStream *  context)
d688 2
a689 2
static char replace_buf [64];	      /* buffer for replacement strings */
static BOOL FoundEntity = FALSE;
d691 3
a693 3
static void handle_entity (
	HTStream *	context,
	char		term)
d697 1
a697 1
    const char *s = context->string->data;
d840 2
a841 2
static void handle_comment (
	HTStream *		context)
d843 1
a843 1
    const char *s = context->string->data;
d862 2
a863 2
static void handle_identifier (
	HTStream *		context)
d865 1
a865 1
    const char *s = context->string->data;
d876 2
a877 2
static void handle_doctype (
	HTStream *		context)
d879 1
a879 1
    const char *s = context->string->data;
d886 1
a886 1
static void SGML_write (
d888 2
a889 2
	const char *		s,
	int			l);
d894 2
a895 2
static void handle_marked (
	HTStream *		context)
d897 1
a897 1
    const char *s = context->string->data;
d921 2
a922 2
static void handle_sgmlent (
	HTStream *		context)
d924 1
a924 1
    const char *s = context->string->data;
d935 2
a936 2
static void handle_sgmlele (
	HTStream *		context)
d938 1
a938 1
    const char *s = context->string->data;
d949 2
a950 2
static void handle_sgmlatt (
	HTStream *		context)
d952 1
a952 1
    const char *s = context->string->data;
d991 4
a994 4
static BOOL element_valid_within (
    HTTag *	new_tag,
    HTTag *	stacked_tag,
    BOOL	direct)
d1015 3
a1017 3
static canclose_t can_close (
    HTTag *	new_tag,
    HTTag *	stacked_tag)
d1030 2
a1031 2
static void do_close_stacked (
    HTStream * context)
d1054 3
a1056 3
static int is_on_stack (
	HTStream *	context,
	HTTag *	old_tag)
d1072 3
a1074 3
static void end_element (
	HTStream *	context,
	HTTag *	old_tag)
d1215 2
a1216 2
static void start_element (
	HTStream *	context)
d1357 1
a1357 1
	(const char**) context->value,	/* coerce type for think c */
d1392 3
a1394 3
HTTag * SGMLFindTag (
	const SGML_dtd*	dtd,
	const char *		s)
d1431 2
a1432 2
static void SGML_free (
	HTStream *	context)
d1482 3
a1484 3
static void SGML_abort (
	HTStream *	context,
	HTError	e)
d1535 2
a1536 2
void* SGML_callerData (
	HTStream *	context)
d1541 3
a1543 3
void SGML_setCallerData (
	HTStream *	context,
	void*		data)
d1549 3
a1551 3
static void SGML_character (
	HTStream *	context,
	char		c_in)
d1553 1
a1553 1
    const SGML_dtd *dtd =	context->dtd;
d1555 1
a1555 1
    const char * EntityName;
d3689 1
a3689 1
		    TO_EUC((const unsigned char *)jis_buf, (unsigned char *)string->data);
d4393 3
a4395 3
static void SGML_string (
	HTStream *	context,
	const char*	str)
d4397 1
a4397 1
    const char *p;
d4403 4
a4406 4
static void SGML_write (
	HTStream *	context,
	const char*	str,
	int		l)
d4408 2
a4409 2
    const char *p;
    const char *e = str+l;
d4420 1
a4420 1
const HTStreamClass SGMLParser =
d4439 4
a4442 4
HTStream* SGML_new  (
	const SGML_dtd *	dtd,
	HTParentAnchor *	anchor,
	HTStructured *		target)
d4455 1
a4455 1
    context->actions = (const HTStructuredClass*)(((HTStream*)target)->isa);
d4564 1
a4564 1
int TREAT_SJIS = 1;
d4566 5
a4570 5
void JISx0201TO0208_EUC (
	register unsigned char		IHI,
	register unsigned char		ILO,
	register unsigned char *	OHI,
	register unsigned char *	OLO)
d4647 1
a4647 1
static int IS_SJIS_STR (const unsigned char *  str)
d4649 1
a4649 1
    const unsigned char *s;
d4662 4
a4665 4
unsigned char * SJIS_TO_JIS1 (
	register unsigned char		HI,
	register unsigned char		LO,
	register unsigned char *	JCODE)
d4682 4
a4685 4
unsigned char * JIS_TO_SJIS1 (
	register unsigned char		HI,
	register unsigned char		LO,
	register unsigned char *	SJCODE)
d4702 4
a4705 4
unsigned char * EUC_TO_SJIS1 (
	unsigned char			HI,
	unsigned char			LO,
	register unsigned char *	SJCODE)
d4713 4
a4716 4
void JISx0201TO0208_SJIS (
	register unsigned char		I,
	register unsigned char *	OHI,
	register unsigned char *	OLO)
d4726 4
a4729 4
unsigned char * SJIS_TO_EUC1 (
	unsigned char		HI,
	unsigned char		LO,
	unsigned char *	data)
d4737 3
a4739 3
unsigned char * SJIS_TO_EUC (
	unsigned char *	src,
	unsigned char *	dst)
d4760 3
a4762 3
unsigned char * EUC_TO_SJIS (
	unsigned char *	src,
	unsigned char *	dst)
d4783 1
a4783 1
#define Strcpy(a,b)	(strcpy((char*)a,(const char*)b),&a[strlen((const char*)a)])
d4785 5
a4789 5
unsigned char *EUC_TO_JIS (
	unsigned char *	src,
	unsigned char *	dst,
	const char *		toK,
	const char *		toA)
d4834 1
a4834 1
int repair_JIS = 0;
d4836 3
a4838 3
static const unsigned char *repairJIStoEUC (
	const unsigned char *	src,
	unsigned char **	dstp)
d4840 1
a4840 1
    const unsigned char *s;
d4861 3
a4863 3
unsigned char *TO_EUC (
	const unsigned char *	jis,
	unsigned char *	euc)
d4865 1
a4865 1
    register const unsigned char *s;
d4892 1
a4892 1
		const unsigned char *ts;
d4951 1
a4951 1
static int is_EUC_JP (unsigned char *  euc)
d4973 3
a4975 3
void TO_SJIS (
	const unsigned char *	any,
	unsigned char *	sjis)
d4979 1
a4979 1
    euc = malloc(strlen((const char *) any) + 1);
d4988 1
a4988 1
	strcpy((char *) sjis, (const char *) any);
d4992 3
a4994 3
void TO_JIS (
	const unsigned char *	any,
	unsigned char *	jis)
d5002 1
a5002 1
    euc = malloc(strlen((const char *) any) + 1);
@


1.1.3.6
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 9
a10 9
 *			========================
 *
 *	This module implements an HTStream object.  To parse an
 *	SGML file, create this object which is a parser.  The object
 *	is (currently) created by being passed a DTD structure,
 *	and a target HTStructured object at which to throw the parsed stuff.
 *
 *	 6 Feb 93  Binary searches used. Interface modified.
 */
d31 1
a31 1
#include <LYCharVals.h>		/* S/390 -- gil -- 0635 */
d47 2
a48 1
char *entity_string;		/* this is used for printing entity name.
d50 3
a52 4
				   Unconditionally added since redundant assigments don't hurt much */

static void fake_put_character(void *p GCC_UNUSED,
			       char c GCC_UNUSED)
d68 1
d82 19
d108 1
d112 2
a113 2
HTCJKlang HTCJK = NOCJK;	/* CJK enum value.              */
BOOL HTPassEightBitRaw = FALSE;	/* Pass 161-172,174-255 raw.    */
d116 1
a116 1
BOOL HTPassHighCtrlNum = FALSE;	/* Pass &#128;-&#159; raw.      */
d119 4
a122 4
 *
 *	This is passed with each call to make the parser reentrant
 *
 */
d126 1
d128 4
a131 4
 *		-------------
 *	This allows us to return down the stack reselecting styles.
 *	As we return, attribute values will be garbage in general.
 */
d134 2
a135 2
    HTElement *next;		/* Previously nested element or 0 */
    HTTag *tag;			/* The tag at this level  */
d185 2
a186 2
 *	-------------------------------
 */
d189 1
a189 1
    const HTStreamClass *isa;	/* inherited from HTStream */
d191 15
a205 15
    const SGML_dtd *dtd;
    const HTStructuredClass *actions;	/* target class  */
    HTStructured *target;	/* target object */

    HTTag *current_tag;
    HTTag *slashedtag;
    const HTTag *unknown_tag;
    BOOL inSELECT;
    BOOL no_lynx_specialcodes;
    int current_attribute_number;
    HTChunk *string;
    int leading_spaces;
    int trailing_spaces;
    HTElement *element_stack;
    sgml_state state;
d208 2
a209 2
    void *callerData;
#endif				/* CALLERDATA */
d211 1
a211 1
    char *value[MAX_ATTRIBUTES];	/* NULL, or strings alloc'd with StrAllocCopy_extra() */
d213 32
a244 32
    BOOL lead_exclamation;
    BOOL first_dash;
    BOOL end_comment;
    BOOL doctype_bracket;
    BOOL first_bracket;
    BOOL second_bracket;
    BOOL isHex;

    HTParentAnchor *node_anchor;
    LYUCcharset *inUCI;		/* pointer to anchor UCInfo */
    int inUCLYhndl;		/* charset we are fed       */
    LYUCcharset *outUCI;	/* anchor UCInfo for target */
    int outUCLYhndl;		/* charset for target       */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
    UCTransParams T;
    int current_tag_charset;	/* charset to pass attributes */

    char *recover;
    int recover_index;
    char *include;
    char *active_include;
    int include_index;
    char *url;
    char *csi;
    int csi_index;
#ifdef USE_PRETTYSRC
    BOOL cur_attr_is_href;
    BOOL cur_attr_is_name;
    BOOL seen_nonwhite_in_junk_tag;
d249 1
a249 1
static char *state_name(sgml_state n)
a251 1
    /* *INDENT-OFF* */
a296 2
    /* *INDENT-ON* */

d306 1
a306 1
static HTElement *pool_alloc(void)
d310 1
a310 1
	return (HTElement *) malloc(sizeof(HTElement));
d314 1
a314 1
static void pool_free(HTElement * e)
d324 4
a327 1
static void HTMLSRC_apply_markup(HTStream *context, HTlexeme lexeme, BOOL start)
d329 1
a329 1
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);
d340 1
a340 1
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
d342 7
a348 6
	    (*context->actions->start_element) (context->target,
						ts->element,
						ts->present,
						(const char **) ts->value,
						context->current_tag_charset,
						&context->include);
d350 4
a353 3
	    (*context->actions->end_element) (context->target,
					      ts->element,
					      &context->include);
d358 7
a364 2
#define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_##x,START)
#define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_##x,STOP)
d370 4
a373 2
static void set_chartrans_handling(HTStream *context, HTParentAnchor *anchor,
				   int chndl)
d377 4
a380 3
	 * Nothing was set for the parser in earlier stages, so the HTML
	 * parser's UCLYhndl should still be its default.  - FM
	 */
d384 2
a385 2
	     * That wasn't set either, so seek the HText default.  - FM
	     */
d389 3
a391 3
	     * That wasn't set either, so assume the current display character
	     * set.  - FM
	     */
d394 4
a397 4
	 * Try to set the HText and HTML stages' chartrans info with the
	 * default lock level (will not be changed if it was set previously
	 * with a higher lock level).  - FM
	 */
d405 2
a406 2
	 * Get the chartrans info for output to the HTML parser.  - FM
	 */
d413 2
a414 2
     * Set the in->out transformation parameters.  - FM
     */
d419 7
a425 6
     * This is intended for passing the SGML parser's input charset as an
     * argument in each call to the HTML parser's start tag function, but it
     * would be better to call a Lynx_HTML_parser function to set an element in
     * its HTStructured object, itself, if this were needed.  - FM
     */
#ifndef EXP_JAPANESEUTF8_SUPPORT
d428 1
a428 3
    } else
#endif
    if (context->T.transp) {
d443 2
a444 1
static void change_chartrans_handling(HTStream *context)
a447 1

d451 1
a451 1
	 * Something changed.  but ignore if a META wants an unknown charset.
d453 2
a454 3
	LYUCcharset *new_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
						       UCT_STAGE_PARSER);

d456 6
a461 4
	    LYUCcharset *next_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
							    UCT_STAGE_STRUCTURED);
	    int next_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor, UCT_STAGE_STRUCTURED);

d478 2
a479 2
 *	----------------
 */
d482 3
a484 1
static void handle_attribute_name(HTStream *context, const char *s)
d486 2
a487 2
    HTTag *tag = context->current_tag;
    attr *attributes = tag->attributes;
d497 2
a498 2
     * Ignore unknown tag.  - KW
     */
d502 1
a502 1
	    context->current_attribute_number = 1;	/* anything !=INVALID */
d508 2
a509 2
     * Binary search for attribute name.
     */
d512 2
a513 2
	 diff < 0 ? (low = i + 1) : (high = i)) {
	i = (low + (high - low) / 2);
d515 1
a515 1
	if (diff == 0) {	/* success: found it */
d524 2
a525 2
		context->present[i] = YES;
		Clear_extra(context->value[i]);
d528 1
a528 1
		current_is_class = IS_C(attributes[i]);
d530 1
a530 1
		current_is_class = (!strcasecomp("class", s));
d532 1
a532 1
		CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
d536 3
a538 3
	}
	/* if */
    }				/* for */
d541 1
a541 1
	    s, context->current_tag->name));
d545 1
d547 5
a551 3
 *	----------------------
 */
static void handle_attribute_value(HTStream *context, const char *s)
d556 3
a558 2
	if (current_is_class) {
	    strncpy(class_string, s, TEMPSTRINGSIZE);
d560 3
a562 1
	} else {
d569 1
a569 1
    context->current_attribute_number = INVALID;	/* can't have two assignments! */
d572 1
d574 12
a585 10
 *  Translate some Unicodes to Lynx special codes and output them.
 *  Special codes - ones those output depend on parsing.
 *
 *  Additional issue, like handling bidirectional text if necessary
 *  may be called from here:  zwnj (8204), zwj (8205), lrm (8206), rlm (8207)
 *  - currently they are ignored in SGML.c and LYCharUtils.c
 *  but also in UCdomap.c because they are non printable...
 *
 */
static BOOL put_special_unicodes(HTStream *context, UCode_t code)
d590 2
a591 2
	 * We were asked by a "DTD" flag to not generate lynx specials.  - kw
	 */
d595 1
a595 1
    if (code == CH_NBSP) {	/* S/390 -- gil -- 0657 */
d597 2
a598 2
	 * Use Lynx special character for nbsp.
	 */
d602 2
a603 2
	    PUTC(HT_NON_BREAK_SPACE);
    } else if (code == CH_SHY) {
d605 2
a606 2
	 * Use Lynx special character for shy.
	 */
d610 1
a610 1
	    PUTC(LY_SOFT_HYPHEN);
d613 12
a624 12
	 * Use Lynx special character for ensp or thinsp.
	 *
	 * Originally, Lynx use space '32' as word delimiter and omits this
	 * space at end of line if word is wrapped to the next line.  There are
	 * several other spaces in the Unicode repertoire and we should teach
	 * Lynx to understand them, not only as regular characters but in the
	 * context of line wrapping.  Unfortunately, if we use HT_EN_SPACE we
	 * override the chartrans tables for those spaces with a single '32'
	 * for all (but do line wrapping more fancy).
	 *
	 * We may treat emsp as one or two ensp (below).
	 */
d628 1
a628 1
	    PUTC(HT_EN_SPACE);
d631 2
a632 2
	 * Use Lynx special character for emsp.
	 */
d636 2
a637 2
	    /* PUTC(HT_EN_SPACE);  let's stay with a single space :) */
	    PUTC(HT_EN_SPACE);
d643 2
a644 2
	 * Return NO if nothing done.
	 */
d648 2
a649 2
     * We have handled it.
     */
d654 1
a654 1
static void put_pretty_entity(HTStream *context, int term)
d660 1
a660 1
	PUTC((char) term);
d664 1
a664 1
static void put_pretty_number(HTStream *context)
d667 1
a667 1
    PUTS((context->isHex ? "&#x" : "&#"));
d675 14
a688 14
 *	-------------
 *
 * On entry,
 *	s	contains the entity name zero terminated
 * Bugs:
 *	If the entity name is unknown, the terminator is treated as
 *	a printable non-special character in all cases, even if it is '<'
 * Bug-fix:
 *	Modified SGML_character() so we only come here with terminator
 *	as '\0' and check a FoundEntity flag. -- Foteos Macrides
 *
 * Modified more (for use with Lynx character translation code):
 */
static char replace_buf[64];	/* buffer for replacement strings */
d691 3
a693 1
static void handle_entity(HTStream *context, char term)
d700 2
a701 2
     * Handle all entities normally.  - FM
     */
d705 3
a707 3
	 * We got a Unicode value for the entity name.  Check for special
	 * Unicodes.  - FM
	 */
d718 2
a719 2
	 * Seek a translation from the chartrans tables.
	 */
d730 1
a730 1
		PUTC(FROMASCII((char) uck));
d736 3
a738 3
	    /*
	     * Not found; look for replacement string.
	     */
d746 1
a746 1
		PUTS(replace_buf);
d751 2
a752 2
	 * If we're displaying UTF-8, try that now.  - FM
	 */
d759 3
a761 5
	if (context->T.output_utf8 && (psrc_view
				       ? (UCPutUtf8_charstring((HTStream *) context->target,
							       (putc_func_t *) (fake_put_character),
							       code))
				       : PUTUTF8(code))) {
d772 2
a773 2
	 * If it's safe ASCII, use it.  - FM
	 */
d781 1
a781 1
		PUTC(FROMASCII((char) code));
d787 4
a790 3
	 * Ignore zwnj (8204) and zwj (8205), if we get to here.  Note that
	 * zwnj may have been handled as <WBR> by the calling function.  - FM
	 */
d803 2
a804 2
	 * Ignore lrm (8206), and rln (8207), if we get to here.  - FM
	 */
d819 2
a820 2
     * If entity string not found, display as text.
     */
d825 1
a825 1
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long) code, uck));	/* S/390 -- gil -- 0695 */
d836 1
d838 4
a841 3
 *	--------------
 */
static void handle_comment(HTStream *context)
d849 2
a850 2
	LYCheckForCSI(context->node_anchor, &context->url) == TRUE) {
	LYDoCSI(context->url, s, &context->csi);
d858 1
d860 4
a863 3
 *	-----------------
 */
static void handle_identifier(HTStream *context)
d872 1
d874 4
a877 3
 *	--------------
 */
static void handle_doctype(HTStream *context)
d886 4
a889 2
static void SGML_write(HTStream *me, const char *s,
		       int l);
d892 4
a895 3
 *	-------------
 */
static void handle_marked(HTStream *context)
d909 3
a911 3
	(*context->actions->_write) (context->target,
				     context->string->data + 8,
				     context->string->size - 11);
d917 1
d919 4
a922 3
 *	--------------
 */
static void handle_sgmlent(HTStream *context)
d931 1
d933 4
a936 3
 *	--------------
 */
static void handle_sgmlele(HTStream *context)
d945 1
d947 4
a950 3
 *	--------------
 */
static void handle_sgmlatt(HTStream *context)
d960 3
a962 2
 * Convenience macros - tags (elements) are identified sometimes by an int or
 * enum value ('TAGNUM'), sometimes by a pointer to HTTag ('TAGP').  - kw
d968 3
a970 3
 * The following implement special knowledge about OBJECT.  As long as
 * HTML_OBJECT is the only tag for which an alternative variant exist, they can
 * be simple macros.  - kw
d988 1
d991 4
a994 1
static BOOL element_valid_within(HTTag * new_tag, HTTag * stacked_tag, BOOL direct)
a996 1

d1003 1
a1003 1
		       (Tgc_same & usecontained));
d1006 1
a1006 1
		       (stacked_tag->tagclass & usecontained));
d1010 1
a1010 1
    close_NO = 0,
d1015 3
a1017 1
static canclose_t can_close(HTTag * new_tag, HTTag * stacked_tag)
d1030 2
a1031 1
static void do_close_stacked(HTStream *context)
d1033 1
a1033 1
    HTElement *stacked = context->element_stack;
a1034 1

d1042 1
a1042 1
    if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
d1044 4
a1047 3
	(*context->actions->end_element) (context->target,
					  e,
					  &context->include);
d1054 3
a1056 1
static int is_on_stack(HTStream *context, HTTag * old_tag)
d1058 1
a1058 1
    HTElement *stacked = context->element_stack;
a1059 1

d1070 5
a1074 3
 *	-----------
 */
static void end_element(HTStream *context, HTTag * old_tag)
d1094 3
a1096 5
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			old_tag->name));
d1105 4
a1108 4
		    context->element_stack ?
		    context->element_stack->tag->name : "none",
		    old_tag->name,
		    old_tag->name));
d1112 4
a1115 5
	    CTRACE((tfp,
		    "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
		    old_tag->name,
		    context->element_stack->tag->name,
		    old_tag->name));
d1124 3
a1126 2
     * If we are in a SELECT block, ignore anything but a SELECT end tag.  - FM
     */
d1130 2
a1131 2
	     * Turn off the inSELECT flag and fall through.  - FM
	     */
d1135 2
a1136 2
	     * Ignore the end tag.  - FM
	     */
d1138 1
a1138 1
		    old_tag->name));
d1143 2
a1144 2
     * Handle the end tag.  - FM
     */
d1148 1
a1148 1
		old_tag->name));
d1152 1
a1152 1
    while (context->element_stack)	/* Loop is error path only */
d1154 1
a1154 1
    if (context->element_stack)	/* Substitute and remove one stack element */
d1159 2
a1160 2
	HTElement *N = context->element_stack;
	HTTag *t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;
d1162 8
a1169 10
	if (old_tag != t) {	/* Mismatch: syntax error */
	    if (context->element_stack->next) {		/* This is not the last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			old_tag->name, t->name, t->name));
	    } else {		/* last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			old_tag->name, t->name, old_tag->name));
		return;		/* Ignore */
d1176 1
a1176 1
	if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
d1178 2
a1179 2
	    status = (*context->actions->end_element) (context->target,
						       e, &context->include);
d1182 7
a1188 6
	    (*context->actions->start_element) (context->target,
						e,
						NULL,
						NULL,
						context->current_tag_charset,
						&context->include);
d1193 1
a1193 1
	    context->element_stack = N->next;	/* Remove from stack */
d1200 1
a1200 1
	    return;		/* Correct sequence */
d1209 1
a1209 1
	    old_tag->name));
d1212 1
d1215 2
a1216 1
static void start_element(HTStream *context)
d1219 1
a1219 1
    HTTag *new_tag = context->current_tag;
d1240 3
a1242 5
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			new_tag->name));
d1245 1
a1245 1
		if (canclose_check == close_error)
d1248 3
a1250 4
		CTRACE((tfp,
			"SGML: Still open %s \t<- ***invalid start <%s>\n",
			context->element_stack->tag->name,
			new_tag->name));
d1258 2
a1259 2
		    context->element_stack->tag->name,
		    new_tag->name));
d1263 2
a1264 4
	if (context->element_stack &&
	    !extra_action_taken &&
	    (canclose_check == close_NO) &&
	    !valid && (new_tag->flags & Tgf_mafse)) {
d1267 1
a1267 2

	    for (; i < new_tag->number_of_attributes && !has_attributes; i++)
d1270 4
a1273 5
		CTRACE((tfp,
			"SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
			context->element_stack->tag->name,
			new_tag->name,
			new_tag->name));
d1280 5
a1284 4
	    (canclose_check == close_error) &&
	    !(valid = element_valid_within(new_tag,
					   context->element_stack->tag,
					   direct_container))) {
d1286 2
a1287 2
		    context->element_stack->tag->name,
		    new_tag->name));
d1295 6
a1300 5
     * If we are not in a SELECT block, check if this is a SELECT start tag. 
     * Otherwise (i.e., we are in a SELECT block) accept only OPTION as valid,
     * terminate the SELECT block if it is any other form-related element, and
     * otherwise ignore it.  - FM
     */
d1303 3
a1305 3
	 * We are not in a SELECT block, so check if this starts one.  - FM
	 * (frequent case!)
	 */
d1309 2
a1310 2
	     * Set the inSELECT flag and fall through.  - FM
	     */
d1315 2
a1316 2
	 * We are in a SELECT block.  - FM
	 */
d1319 2
a1320 2
	     * Ugh, it is not an OPTION.  - FM
	     */
d1322 7
a1328 12
	    case HTML_INPUT:
	    case HTML_TEXTAREA:
	    case HTML_SELECT:
	    case HTML_BUTTON:
	    case HTML_FIELDSET:
	    case HTML_LABEL:
	    case HTML_LEGEND:
	    case HTML_FORM:
		ok = TRUE;
		break;
	    default:
		break;
d1330 2
a1331 1
	    if (ok) {
d1333 5
a1337 6
		 * It is another form-related start tag, so terminate the
		 * current SELECT block and fall through.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			new_tag->name));
d1341 4
a1344 5
		 * Ignore the start tag.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			new_tag->name));
d1350 2
a1351 2
     * Handle the start tag.  - FM
     */
d1353 7
a1359 6
    status = (*context->actions->start_element) (context->target,
						 TAGNUM_OF_TAGP(new_tag),
						 context->present,
						 (const char **) context->value,	/* coerce type for think c */
						 context->current_tag_charset,
						 &context->include);
d1362 2
a1363 3
    if (new_tag->contents != SGML_EMPTY) {	/* i.e., tag not empty */
	HTElement *N = pool_alloc();

d1371 1
a1371 1
    } else if (e == HTML_META) {
d1373 2
a1374 2
	 * Check for result of META tag.  - KW & FM
	 */
d1379 1
d1381 14
a1394 13
 *		------------------------
 *
 * On entry,
 *	dtd	points to dtd structure including valid tag list
 *	string	points to name of tag in question
 *
 * On exit,
 *	returns:
 *		NULL		tag not found
 *		else		address of tag structure in dtd
 */
HTTag *SGMLFindTag(const SGML_dtd * dtd,
		   const char *s)
d1397 2
a1398 3
    static HTTag *last[64] =
    {NULL};			/*optimize using the previous results */
    HTTag **res = last + (UCH(*s) % 64);	/*pointer arithmetic */
d1403 4
a1406 4
    for (low = 0, high = dtd->number_of_tags;
	 high > low;
	 diff < 0 ? (low = i + 1) : (high = i)) {	/* Binary search */
	i = (low + (high - low) / 2);
d1409 1
a1409 1
	if (diff == 0) {	/* success: found it */
d1416 2
a1417 2
	 * Unrecognized, but may be valid.  - KW
	 */
d1424 3
a1426 2
 *			Public Methods
 */
d1431 2
a1432 1
static void SGML_free(HTStream *context)
d1435 2
a1436 2
    HTElement *cur;
    HTTag *t;
d1439 2
a1440 2
     * Free the buffers.  - FM
     */
d1448 2
a1449 2
     * Wind down stack if any elements are open.  - FM
     */
d1456 1
a1456 1
	if (!psrc_view)		/* Don't actually call on target if viewing psrc - kw */
d1458 3
a1460 3
	    (*context->actions->end_element) (context->target,
					      NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
					      &context->include);
d1465 3
a1467 3
     * Finish off the target.  - FM
     */
    (*context->actions->_free) (context->target);
d1470 2
a1471 2
     * Free the strings and context structure.  - FM
     */
d1482 3
a1484 1
static void SGML_abort(HTStream *context, HTError e)
d1487 1
a1487 1
    HTElement *cur;
d1490 3
a1492 3
     * Abort the target.  - FM
     */
    (*context->actions->_abort) (context->target, e);
d1495 2
a1496 2
     * Free the buffers.  - FM
     */
d1504 2
a1505 2
     * Free stack memory if any elements were left open.  - KW
     */
d1513 2
a1514 2
     * Free the strings and context structure.  - FM
     */
d1525 1
d1527 6
a1532 6
 *	-----------------------------------
 *
 *   The callbacks from the SGML parser have an SGML context parameter.
 *   These calls allow the caller to associate his own context with a
 *   particular SGML context.
 */
d1535 2
a1536 1
void *SGML_callerData(HTStream *context)
d1541 3
a1543 1
void SGML_setCallerData(HTStream *context, void *data)
d1549 10
a1558 8
static void SGML_character(HTStream *context, char c_in)
{
    const SGML_dtd *dtd = context->dtd;
    HTChunk *string = context->string;
    const char *EntityName;
    HTTag *testtag = NULL;
    BOOLEAN chk;		/* Helps (?) walk through all the else ifs... */
    UCode_t clong, uck = 0;	/* Enough bits for UCS4 ... */
a1559 1

a1561 1

d1568 4
a1571 3
     * Now some fun with the preprocessor.  Use copies for c and unsign_c ==
     * clong, so that we can revert back to the unchanged c_in.  - KW
     */
d1575 1
a1575 1
    clong = UCH(c);		/* a.k.a. unsign_c */
d1579 5
a1583 4
	 * Combine UTF-8 into Unicode.  Incomplete characters silently ignored. 
	 * From Linux kernel's console.c.  - KW
	 */
	if (TOASCII(UCH(c)) > 127) {	/* S/390 -- gil -- 0710 */
d1585 2
a1586 2
	     * We have an octet from a multibyte character.  - FM
	     */
d1594 4
a1597 3
		     * We have all of the bytes, so terminate the buffer and
		     * set 'clong' to the UCode_t value.  - FM
		     */
d1601 1
a1601 1
			c = ((char) (clong & 0xff));
d1606 2
a1607 2
		     * Wait for more.  - KW
		     */
d1612 2
a1613 2
		 * Start handling a new multibyte character.  - FM
		 */
d1634 2
a1635 2
		     * Garbage.  - KW
		     */
d1641 2
a1642 2
		 * Wait for more.  - KW
		 */
d1647 2
a1648 2
	     * Got an ASCII char.  - KW
	     */
d1652 1
a1652 1
	    /*  goto top;  */
d1654 2
a1655 2
    }
    /* end of context->T.decode_utf8      S/390 -- gil -- 0726 */
d1658 5
a1662 4
     * If we have a koi8-r input and do not have koi8-r as the output, save the
     * raw input in saved_char_in before we potentially convert it to Unicode. 
     * - FM
     */
d1668 3
a1670 2
     * If we want the raw input converted to Unicode, try that now.  - FM
     */
d1672 1
a1672 1
	((TOASCII(unsign_c) >= LYlowest_eightbit[context->inUCLYhndl]) ||	/* S/390 -- gil -- 0744 */
d1676 2
a1677 2
	 * Convert the octet to Unicode.  - FM
	 */
d1682 1
a1682 1
		c = FROMASCII((char) clong);
d1686 1
a1686 1
    } else if (unsign_c < ' ' && unsign_c != 0 &&	/* S/390 -- gil -- 0768 */
d1689 2
a1690 2
	 * This else if may be too ugly to keep.  - KW
	 */
d1697 1
a1697 1
		c = FROMASCII((char) clong);
d1726 2
a1727 2
	}			/*  Next line end of ugly stuff for C0. - KW */
    } else {			/* end of context->T.trans_to_uni  S/390 -- gil -- 0791 */
d1732 4
a1735 4
     * At this point we have either unsign_c a.k.a.  clong in Unicode (and c in
     * latin1 if clong is in the latin1 range), or unsign_c and c will have to
     * be passed raw.  - KW
     */
d1737 14
a1750 14
 *  We jump up to here from below if we have
 *  stuff in the recover, insert, or csi buffers
 *  to process.	 We zero saved_char_in, in effect
 *  as a flag that the octet in not that of the
 *  actual call to this function.  This may be OK
 *  for now, for the stuff this function adds to
 *  its recover buffer, but it might not be for
 *  stuff other functions added to the insert or
 *  csi buffer, so bear that in mind. - FM
 *  Stuff from the recover buffer is now handled
 *  as UTF-8 if we can expect that's what it is,
 *  and in that case we don't come back up here. - kw
 */
  top:
d1753 7
a1759 7
 *  We jump to here from above when we don't have
 *  UTF-8 input, haven't converted to Unicode, and
 *  want clong set to the input octet (unsigned)
 *  without zeroing its saved_char_in copy (which
 *  is signed). - FM
 */
  top0a:
d1763 10
a1772 10
 *  We jump to here from above if we have converted
 *  the input, or a multibyte sequence across calls,
 *  to a Unicode value and loaded it into clong (to
 *  which unsign_c has been defined), and from below
 *  when we are recycling a character (e.g., because
 *  it terminated an entity but is not the standard
 *  semi-colon).  The character will already have
 *  been put through the Unicode conversions. - FM
 */
  top1:
d1774 3
a1776 2
     * Ignore low ISO 646 7-bit control characters if HTCJK is not set.  - FM
     */
d1778 2
a1779 2
     * Works for both ASCII and EBCDIC. -- gil
 *//* S/390 -- gil -- 0811 */
d1786 3
a1788 2
     * Ignore 127 if we don't have HTPassHighCtrlRaw or HTCJK set.  - FM
     */
d1791 1
a1791 1
    if (TOASCII(c) == 127 &&	/* S/390 -- gil -- 0830 */
d1796 4
a1799 4
     * Ignore 8-bit control characters 128 - 159 if neither HTPassHighCtrlRaw
     * nor HTCJK is set.  - FM
     */
    if (TOASCII(unsign_c) > 127 && TOASCII(unsign_c) < 160 &&	/* S/390 -- gil -- 0847 */
d1807 2
a1808 6
    if ((HTCJK == JAPANESE) && (context->state == S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& !context->T.decode_utf8
#endif
	) {
a1811 1

d1815 2
a1816 1
	} else
d1823 2
a1824 2
     * Handle character based on context->state.
     */
d1826 5
a1830 5
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));
    switch (context->state) {
d1834 9
a1842 7
	 * Note that if we don't have a CJK input, then this is not the second
	 * byte of a CJK di-byte, and we're trashing the input.  That's why
	 * 8-bit characters followed by, for example, '<' can cause the tag to
	 * be treated as text, not markup.  We could try to deal with it by
	 * holding each first byte and then checking byte pairs, but that
	 * doesn't seem worth the overhead (see below).  - FM
	 */
d1850 5
a1854 5
	 * We had something link "<name/" so far, set state to S_text but keep
	 * context->slashedtag as as a flag; except if we get '>' directly
	 * after the "<name/", and really have a tag for that name in
	 * context->slashedtag, in which case keep state as is and let code
	 * below deal with it.  - kw
d1858 2
a1859 2
	}
	/* fall through in any case! */
d1861 11
a1871 13
	if ((HTCJK != NOCJK) && ((TOASCII(c) & 0200) != 0)
#ifdef EXP_JAPANESEUTF8_SUPPORT
	    && !context->T.decode_utf8
#endif
	    ) {			/* S/390 -- gil -- 0864 */
	    /*
	     * Setting up for Kanji multibyte handling (based on Takuya ASADA's
	     * (asada@@three-a.co.jp) CJK Lynx).  Note that if the input is not
	     * in fact CJK, the next byte also will be mishandled, as explained
	     * above.  Toggle raw mode off in such cases, or select the "7 bit
	     * approximations" display character set, which is largely
	     * equivalent to having raw mode off with CJK.  - FM
	     */
d1875 1
a1875 1
	} else if (HTCJK != NOCJK && TOASCII(c) == '\033') {	/* S/390 -- gil -- 0881 */
d1877 3
a1879 3
	     * Setting up for CJK escape sequence handling (based on Takuya
	     * ASADA's (asada@@three-a.co.jp) CJK Lynx).  - FM
	     */
d1887 1
a1887 1
	    if (psrc_view) {	/*there is nothing useful in the element_stack */
d1893 1
a1893 1
		    context->element_stack->tag : NULL;
d1897 1
a1897 1
	if (c == '&' && TOASCII(unsign_c) < 127 &&	/* S/390 -- gil -- 0898 */
d1907 2
a1908 2
	     * Setting up for possible entity, without the leading '&'.  - FM
	     */
d1911 1
a1911 1
	} else if (c == '<' && TOASCII(unsign_c) < 127) {	/* S/390 -- gil -- 0915 */
d1913 2
a1914 2
	     * Setting up for possible tag.  - FM
	     */
d1919 1
a1919 1
				   || testtag->contents == SGML_CDATA)) {
d1932 5
a1936 5
	     * We got either the second slash of a pending "<NAME/blah blah/"
	     * shortref construct, or the '>' of a mere "<NAME/>".  In both
	     * cases generate a "</NAME>" end tag in the recover buffer for
	     * reparsing unless NAME is really an empty element.  - kw
	     */
d1944 2
a1945 2
		if (context->slashedtag != context->unknown_tag &&
		    !ReallyEmptyTag(context->slashedtag)) {
d1960 6
a1965 6
	     * The element stack says we are within the contents of an element
	     * that the next stage (HTML.c) may want to feed us back again (via
	     * the *include string).  So try to output text in UTF-8 if
	     * possible, using the same logic as for attribute values (which
	     * should be in line with what context->current_tag_charset
	     * indicates).  - kw
d1978 3
a1980 3
			   HTPassEightBitRaw &&
			   UCH(saved_char_in) >=
			   LYlowest_eightbit[context->outUCLYhndl]) {
d1992 5
a1996 5
	    /*
	     * Convert 160 (nbsp) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_NBSP &&	/* S/390 -- gil -- 0932 */
d2000 5
a2004 5
	    /*
	     * Convert 173 (shy) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_SHY &&	/* S/390 -- gil -- 0949 */
d2008 5
a2012 5
	    /*
	     * Handle the case in which we think we have a character which
	     * doesn't need further processing (e.g., a koi8-r input for a
	     * koi8-r output).  - FM
	     */
d2015 3
a2017 3
	     * Only if the original character is still in saved_char_in,
	     * otherwise we may be iterating from a goto top.  - KW
	     */
d2021 1
a2021 1
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
d2023 1
a2023 2
	} else if ((chk = (BOOL) (context->T.trans_from_uni &&
				  TOASCII(unsign_c) >= 160)) &&		/* S/390 -- gil -- 0968 */
d2028 1
a2028 1
		    uck, FROMASCII((char) uck)));
d2030 3
a2032 3
	     * We got one octet from the conversions, so use it.  - FM
	     */
	    PUTC(FROMASCII((char) uck));
d2034 6
a2039 6
		    (uck == -4 ||
		     (context->T.repl_translated_C0 &&
		      uck > 0 && uck < 32))) &&
	    /*
	     * Not found; look for replacement string.  - KW
	     */
d2044 4
a2047 4
	     * Got a replacement string.  No further tests for validity -
	     * assume that whoever defined replacement strings knew what she
	     * was doing.  - KW
	     */
d2049 3
a2051 3
	    /*
	     * If we're displaying UTF-8, try that now.  - FM
	     */
d2053 7
a2059 7
	    ;			/* do nothing more */
	    /*
	     * If it's any other (> 160) 8-bit character, and we have not set
	     * HTPassEightBitRaw nor HTCJK, nor have the "ISO Latin 1"
	     * character set selected, back translate for our character set.  -
	     * FM
	     */
d2076 1
a2076 1
	    EntityName = HTMLGetEntityName((int) (unsign_c - 160));
d2080 1
a2080 1
	    /* we need to disable it temporary */
d2082 1
a2082 2
		psrc_view_backup = 1;
		psrc_view = 0;
d2087 1
a2087 1
	    /* we need to disable it temporary */
d2095 5
a2099 5
	    /*
	     * If we get to here and have an ASCII char, pass the character.  -
	     * KW
	     */
	} else if (TOASCII(unsign_c) < 127 && unsign_c > 0) {	/* S/390 -- gil -- 0987 */
d2101 7
a2107 7
	    /*
	     * If we get to here, and should have translated, translation has
	     * failed so far.  - KW
	     *
	     * We should have sent UTF-8 output to the parser already, but what
	     * the heck, try again.  - FM
	     */
d2113 3
a2115 3
	    /*
	     * Check for a strippable koi8-r 8-bit character.  - FM
	     */
d2120 4
a2123 4
	     * KOI8 special:  strip high bit, gives (somewhat) readable ASCII
	     * or KOI7 - it was constructed that way!  - KW
	     */
	    PUTC(((char) (saved_char_in & 0x7f)));
d2126 6
a2131 6
	    /*
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
	} else if (TOASCII(UCH(c)) <	/* S/390 -- gil -- 0997 */
		   LYlowest_eightbit[context->outUCLYhndl] ||
d2133 3
a2135 3
	    /*
	     * If we get to here, pass the character.  - FM
	     */
d2141 5
a2145 5
	/*
	 * Found '<' in SGML_PCDATA content; treat this mode nearly like
	 * S_litteral, but recognize '<!' and '<?' to filter out comments and
	 * processing instructions.  - kw
	 */
d2147 2
a2148 2
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
d2150 4
a2153 3
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
d2160 1
a2160 1
	    } else if (c == '?') {	/* <? - ignore as a PI until '>' - kw */
d2168 1
a2168 1
		    context->seen_nonwhite_in_junk_tag = TRUE;	/* show all */
d2177 5
a2181 5
	/*
	 * Found '<' in SGML_SCRIPT content; treat this mode nearly like
	 * S_litteral, but recognize '<!' to allow the content to be treated as
	 * a comment by lynx.
	 */
d2183 2
a2184 2
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
d2186 4
a2189 3
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
d2200 6
a2205 6
	/*
	 * In litteral mode, waits only for specific end tag (for compatibility
	 * with old servers, and for Lynx).  - FM
	 */
      case_S_litteral:
    case S_litteral:		/*PSRC:this case not understood completely by HV, not done */
d2208 1
a2208 1
	if (psrc_view) {	/*there is nothing useful in the element_stack */
d2223 2
a2224 2
	 *      testtag contains something like "TITLE"
	 *      string contains something like "/title>"
d2230 2
a2231 2
			   ? '/'
			   : testtag->name[testlast])) {
d2235 2
a2236 2
	     * If complete match, end litteral.
	     */
d2245 1
a2245 1
		    strcpy(string->data, context->current_tag->name);
d2295 1
a2295 1
		  (testtag->flags & (Tgf_strict | Tgf_endO)))) &&
d2300 2
a2301 2
		for (i = 0; i < string->size; i++)	/* remove '/' */
		    string->data[i] = string->data[i + 1];
d2308 1
a2308 1
		(testtag->flags & (Tgf_strict | Tgf_endO)) &&
d2314 2
a2315 2
	     * If Mismatch:  recover string literally.
	     */
d2317 2
a2318 2
	    for (i = 0; i < string->size - 1; i++)	/* recover, except last c */
		PUTC(string->data[i]);
d2325 3
a2327 3
	/*
	 * Character reference (numeric entity) or named entity.
	 */
d2331 3
a2333 3
	     * Setting up for possible numeric entity.
	     */
	    context->state = S_cro;	/* &# is Char Ref Open */
d2336 1
a2336 1
	context->state = S_entity;	/* Fall through! */
d2338 3
a2340 3
	/*
	 * Handle possible named entity.
	 */
d2343 1
a2343 1
					isalnum(UCH(c)) : isalpha(UCH(c)))) {
d2348 2
a2349 2
	     * Accept valid ASCII character.  - FM
	     */
d2353 3
a2355 3
	     * It was an ampersand that's just text, so output the ampersand
	     * and recycle this character.  - FM
	     */
d2369 2
a2370 2
	     * Terminate entity name and try to handle it.  - FM
	     */
d2379 1
a2379 1
		 (context->element_stack->tag &&
d2382 2
a2383 2
		 * Handle zwnj (8204) as <WBR>.  - FM
		 */
d2386 1
a2386 2
		CTRACE((tfp,
			"SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));
d2408 5
a2412 4
	     * Don't eat the terminator if we didn't find the entity name and
	     * therefore sent the raw string via handle_entity(), or if the
	     * terminator is not the "standard" semi-colon for HTML.  - FM
	     */
d2425 3
a2427 3
	/*
	 * Check for a numeric entity.
	 */
d2429 1
a2429 1
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {	/* S/390 -- gil -- 1060 */
d2434 2
a2435 2
	     * Accept only valid ASCII digits.  - FM
	     */
d2441 3
a2443 3
	     * No 'x' or digit following the "&#" so recover them and recycle
	     * the character.  - FM
	     */
d2459 3
a2461 3
	/*
	 * Handle a numeric entity.
	 */
d2463 2
a2464 2
/* S/390 -- gil -- 1075 *//* CTRACE((tfp, "%s: %d: numeric %d %d\n",
   __FILE__, __LINE__, unsign_c, c)); */
d2467 1
a2467 1
	     isdigit(UCH(c)))) {
d2469 2
a2470 2
	     * Accept only valid hex or ASCII digits.  - FM
	     */
d2474 3
a2476 3
	     * No hex digit following the "&#x" so recover them and recycle the
	     * character.  - FM
	     */
d2491 2
a2492 2
	     * Terminate the numeric entity and try to handle it.  - FM
	     */
a2494 1

d2500 1
a2500 1
		 sscanf(string->data, "%ld", &code)) == 1) {
d2505 7
a2511 7
		     * Assume these are Microsoft code points, inflicted on us
		     * by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159 range
		     * and doesn't follow Unicode standards for this area. 
		     * Windows-1252 codepoints are assumed here.
		     */
d2513 122
a2634 119
		    case 1:
			/*
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
			break;
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
			break;
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
			break;
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
			break;
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
			break;
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
			break;
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
			break;
d2638 2
a2639 2
		 * Check for special values.  - FM
		 */
d2642 1
a2642 1
		     (context->element_stack->tag &&
d2645 2
a2646 2
		     * Handle zwnj (8204) as <WBR>.  - FM
		     */
d2649 1
a2649 2
		    CTRACE((tfp,
			    "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));
d2652 3
a2654 3
		     * Include the terminator if it is not the standard
		     * semi-colon.  - FM
		     */
d2661 3
a2663 3
		     * Add the replacement string to the recover buffer for
		     * processing.  - FM
		     */
d2676 3
a2678 3
		     * We handled the value as a special character, so recycle
		     * the terminator or break.  - FM
		     */
d2682 1
a2682 1
			PUTS((context->isHex ? "&#x" : "&#"));
d2697 2
a2698 2
		 * Seek a translation from the chartrans tables.
		 */
d2707 1
a2707 1
			PUTC(FROMASCII((char) uck));
d2716 3
a2718 3
		    /*
		     * Not found; look for replacement string.
		     */
d2727 4
a2730 4
			PUTS(replace_buf);
		    /*
		     * If we're displaying UTF-8, try that now.  - FM
		     */
d2732 5
a2736 5
		    ;		/* do nothing more */
		    /*
		     * Ignore 8205 (zwj), 8206 (lrm), and 8207 (rln), if we get
		     * to here.  - FM
		     */
d2753 1
a2753 1
			PUTS((context->isHex ? "&#x" : "&#"));
d2766 13
a2778 12
		    /*
		     * Show the numeric entity if we get to here and the value:
		     * (1) Is greater than 255 (but use ASCII characters for
		     * spaces or dashes).
		     * (2) Is less than 32, and not valid or we don't have
		     * HTCJK set.
		     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK
		     * set.
		     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum
		     * set.
		     * - FM
		     */
d2780 1
a2780 1
			   (code < ' ' &&	/* S/390 -- gil -- 1140 */
d2787 5
a2791 4
		    /*
		     * Unhandled or illegal value.  Recover the "&#" or "&#x"
		     * and digit(s), and recycle the terminator.  - FM
		     */
d2793 3
a2795 3
		    if (psrc_view) {
			PSRCSTART(badseq);
		    }
d2797 9
a2805 9
		    if (context->isHex) {
			PUTS("&#x");
			context->isHex = FALSE;
		    } else {
			PUTS("&#");
		    }
		    string->size--;
		    for (i = 0; i < string->size; i++)	/* recover */
			PUTC(string->data[i]);
d2807 3
a2809 3
		    if (psrc_view) {
			PSRCSTOP(badseq);
		    }
d2811 5
a2815 5
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    goto top1;
		} else if (TOASCII(code) < 161 ||	/* S/390 -- gil -- 1162 */
d2819 2
a2820 2
		     * No conversion needed.  - FM
		     */
d2826 1
a2826 1
			PUTC(FROMASCII((char) code));
d2829 2
a2830 2
		     * Handle as named entity.  - FM
		     */
d2839 3
a2841 3
			 * Add a semi-colon if something went wrong and
			 * handle_entity() sent the string.  - FM
			 */
d2847 3
a2849 3
			 * Our conversion failed, so recover the "&#" and
			 * digit(s), and recycle the terminator.  - FM
			 */
d2874 2
a2875 2
		 * If we get to here, we succeeded.  Hoorah!!!  - FM
		 */
d2880 3
a2882 3
		 * Don't eat the terminator if it's not the "standard"
		 * semi-colon for HTML.  - FM
		 */
d2888 5
a2892 4
		 * Not an entity, and don't know why not, so add the terminator
		 * to the string, output the "&#" or "&#x", and process the
		 * string via the recover element.  - FM
		 */
d2924 4
a2927 4
	/*
	 * Tag
	 */
    case S_tag:		/* new tag */
d2929 1
a2929 1
					IsNmChar(c) : IsNmStart(c))) {
d2931 2
a2932 2
	     * Add valid ASCII character.  - FM
	     */
d2934 1
a2934 1
	} else if (c == '!' && !string->size) {		/* <! */
d2936 3
a2938 3
	     * Terminate and set up for possible comment, identifier,
	     * declaration, or marked section.  - FM
	     */
d2946 1
a2946 1
		   (TOASCII(unsign_c) <= 160 &&		/* S/390 -- gil -- 1196 */
d2949 7
a2955 7
	     * '<' must be followed by an ASCII letter to be a valid start tag. 
	     * Here it isn't, nor do we have a '/' for an end tag, nor one of
	     * some other characters with a special meaning for SGML or which
	     * are likely to be legal Name Start characters in XML or some
	     * other extension.  So recover the '<' and following character as
	     * data.  - FM & KW
	     */
d2967 1
a2967 1
	} else {		/* End of tag name */
d2969 3
a2971 4
	     * Try to handle tag.  - FM
	     */
	    HTTag *t;

d2977 1
a2977 1
		CTRACE((tfp, "SGML: `<%.*s/' found!\n", string->size, string->data));
d2979 1
a2979 1
	    HTChunkTerminate(string);
d2987 3
a2989 3
		 * Treat <URL:  as text rather than a junk tag, so we display
		 * it and the URL (Lynxism 8-).  - FM
		 */
d2995 1
a2995 1
		PUTS(string->data);	/* recover */
d3002 1
a3002 1
			string->data, c));
d3009 4
a3012 4
		 * Element name was ended by '/'.  Remember the tag that ended
		 * thusly, we'll interpret this as either an indication of an
		 * empty element (if '>' follows directly) or do some
		 * SGMLshortref-ish treatment.  - kw
d3024 1
a3024 1
			context->seen_nonwhite_in_junk_tag = TRUE;	/*show all */
d3031 1
a3031 1
			string->data));
d3046 1
a3046 1
		    if (c == '>') {
d3060 1
a3060 1
			string->data));
d3062 3
a3064 3
		 * Fall through and treat like valid tag for attribute parsing. 
		 * - KW
		 */
d3090 1
a3090 1
	    if (!psrc_view)	/*don't waste time */
d3093 5
a3097 5
		/*
		 * Clear out attributes.
		 */
		memset((void *) context->present, 0, sizeof(BOOL) *
		       context->current_tag->number_of_attributes);
d3134 2
a3135 2
	     * Set up for possible comment.  - FM
	     */
d3143 2
a3144 2
	     * Set up for possible marked section.  - FM
	     */
d3154 2
a3155 2
	     * Set up to handle comment.  - FM
	     */
d3167 2
a3168 2
	     * Try to handle identifier.  - FM
	     */
d3179 1
a3179 1
		handle_identifier(context);
d3188 2
a3189 2
		 * Set up for DOCTYPE declaration.  - FM
		 */
d3198 2
a3199 2
		 * Set up for ENTITY declaration.  - FM
		 */
d3209 2
a3210 2
		 * Set up for ELEMENT declaration.  - FM
		 */
d3220 2
a3221 2
		 * Set up for ATTLIST declaration.  - FM
		 */
d3235 2
a3236 2
	     * Any '>' terminates.  - FM
	     */
d3248 1
a3248 1
		    handle_comment(context);
d3269 3
a3271 3
		 * Validly treat '--' pairs as successive comments (for
		 * minimal, any "--WHITE>" terminates).  - FM
		 */
d3277 2
a3278 2
	     * Terminate and handle the comment.  - FM
	     */
d3300 1
a3300 1
      S_comment_put_c:
d3302 1
a3302 1
	    *context->utf_buf) {
d3348 1
a3348 1
		handle_doctype(context);
d3380 1
a3380 1
		handle_marked(context);
d3414 1
a3414 1
		handle_sgmlent(context);
d3451 1
a3451 1
		handle_sgmlele(context);
d3488 1
a3488 1
		handle_sgmlatt(context);
d3506 2
a3507 2
		if (context->current_tag->name)
		    start_element(context);
d3519 1
a3519 1
	context->state = S_attr;	/* Get attribute */
d3522 1
a3522 1
	/* accumulating value */
d3530 7
a3536 7
		string->size = 0;
		if (c == '>') {	/* End of tag */
		    if (context->current_tag->name)
			start_element(context);
		    context->state = S_text;
		    break;
		}
d3551 1
a3551 2
		if (c == '=')
		    PUTC('=');
d3568 1
a3568 1
	    context->state = (c == '=' ? S_equals : S_attr_gap);
d3609 1
a3609 1
	context->state = S_attr;	/* Get next attribute */
d3654 1
a3654 1
	/*  no break!  fall through to S_value and process current `c`   */
d3657 2
a3658 2
	if (WHITE(c) || (c == '>')) {	/* End of word */
	    HTChunkTerminate(string);
d3661 1
a3661 1
		/*PSRCSTART(attrval); */
d3664 4
a3667 3
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3670 1
a3670 1
		    HTStartAnchor(context->target, NULL, string->data);
d3674 4
a3677 3
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3683 2
a3684 4
#ifdef CJK_EX			/* Quick hack. - JH7AYN */
	    {
		char jis_buf[512];

d3686 5
a3690 6
		    if (string->data[1] == 'B' || string->data[1] == '@@') {
			jis_buf[0] = '\033';
			strcpy(jis_buf + 1, string->data);
			TO_EUC((const unsigned char *) jis_buf,
			       (unsigned char *) string->data);
		    }
d3696 1
a3696 1
	    if (c == '>') {	/* End of tag */
d3708 2
a3709 2
	    } else
		context->state = S_tag_gap;
d3736 1
a3736 1
	    HTChunkTerminate(string);
d3739 1
a3739 1
		/*PSRCSTART(attrval); */
d3741 5
a3745 4
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3748 1
a3748 1
		    HTStartAnchor(context->target, NULL, string->data);
d3752 4
a3755 3
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3762 1
a3762 1
		handle_attribute_value(context, string->data);
d3765 1
a3765 1
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1213 */
d3767 3
a3769 3
	     * Setting up for possible single quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
d3800 1
a3800 1
	    HTChunkTerminate(string);
d3803 1
a3803 1
		/*PSRCSTART(attrval); */
d3805 5
a3809 4
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3812 1
a3812 1
		    HTStartAnchor(context->target, NULL, string->data);
d3816 4
a3819 3
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
d3827 1
a3827 1
		handle_attribute_value(context, string->data);
d3832 1
a3832 1
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1230 */
d3834 3
a3836 3
	     * Setting up for possible double quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
d3863 1
a3863 1
    case S_end:		/* </ */
d3865 1
a3865 1
					IsNmChar(c) : IsNmStart(c))) {
d3867 2
a3868 3
	} else {		/* End of end tag name */
	    HTTag *t = 0;

d3903 1
a3903 1
		    psrc_tagname_processed = TRUE;
a3908 1

d3911 1
a3911 1
		int branch = 2;	/* it can be 0,1,2 */
d3921 1
a3921 1
		    && Old_DTD
d3923 5
a3927 13
		    ) {
		    switch (e) {
		    case HTML_DD:
		    case HTML_DT:
		    case HTML_LI:
		    case HTML_LH:
		    case HTML_TD:
		    case HTML_TH:
		    case HTML_TR:
		    case HTML_THEAD:
		    case HTML_TFOOT:
		    case HTML_TBODY:
		    case HTML_COLGROUP:
d3931 3
a3933 12
		    case HTML_A:
		    case HTML_B:
		    case HTML_BLINK:
		    case HTML_CITE:
		    case HTML_EM:
		    case HTML_FONT:
		    case HTML_FORM:
		    case HTML_I:
		    case HTML_P:
		    case HTML_STRONG:
		    case HTML_TT:
		    case HTML_U:
d3944 2
a3945 2
		 * Just handle ALL end tags normally :-) - kw
		 */
d3947 1
a3947 1
		    end_element(context, context->current_tag);
d3951 1
a3951 1
		    if (tag_OK &&
d3953 1
a3953 1
			(branch == 0)
d3955 11
a3965 11
			(!strcasecomp(string->data, "DD") ||
			 !strcasecomp(string->data, "DT") ||
			 !strcasecomp(string->data, "LI") ||
			 !strcasecomp(string->data, "LH") ||
			 !strcasecomp(string->data, "TD") ||
			 !strcasecomp(string->data, "TH") ||
			 !strcasecomp(string->data, "TR") ||
			 !strcasecomp(string->data, "THEAD") ||
			 !strcasecomp(string->data, "TFOOT") ||
			 !strcasecomp(string->data, "TBODY") ||
			 !strcasecomp(string->data, "COLGROUP"))
d3967 1
a3967 1
		    ) {
d3969 3
a3971 3
		     * Don't treat these end tags as invalid, nor act on them. 
		     * - FM
		     */
d3973 1
a3973 1
			    string->data, c));
d4000 1
a4000 1
		    ) {
d4002 6
a4007 6
		     * Handle end tags for container elements declared as
		     * SGML_EMPTY to prevent "expected tag substitution" but
		     * still processed via HTML_end_element() in HTML.c with
		     * checks there to avoid throwing the HTML.c stack out of
		     * whack (Ugh, what a hack!  8-).  - FM
		     */
d4010 2
a4011 2
			 * We are in a SELECT block.  - FM
			 */
d4014 4
a4017 5
			     * It is not at FORM end tag, so ignore it.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
				    string->data));
d4020 5
a4024 6
			     * End the SELECT block and then handle the FORM
			     * end tag.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
				    string->data));
d4030 1
a4030 1
			    if (!psrc_view)	/* Don't actually call if viewing psrc - kw */
d4032 4
a4035 4
				(*context->actions->end_element)
				    (context->target,
				     TAGNUM_OF_TAGP(context->current_tag),
				     &context->include);
d4039 5
a4043 6
			 * Treat a P end tag like a P start tag (Ugh, what a
			 * hack!  8-).  - FM
			 */
			CTRACE((tfp,
				"SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				string->data, c, string->data, c));
a4045 1

d4058 1
a4058 1
			if (!psrc_view)		/* Don't actually call if viewing psrc - kw */
d4060 4
a4063 4
			    (*context->actions->end_element)
				(context->target,
				 TAGNUM_OF_TAGP(context->current_tag),
				 &context->include);
d4076 3
a4078 3
		     * Handle all other end tags normally.  - FM
		     */
		    end_element(context, context->current_tag);
d4096 1
a4096 1
		if (c != '>') {
d4111 1
a4111 1
		    CTRACE((tfp, "SGML: `</%s%c' found!\n", string->data, c));
d4120 1
d4132 1
a4132 1
    case S_dollar:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4141 1
a4141 1
    case S_dollar_paren:	/* Expecting 'C' after CJK "ESC$(". */
d4150 1
a4150 1
    case S_paren:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4161 2
a4162 2
    case S_nonascii_text:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1264 */
d4170 1
a4170 1
    case S_esc_sq:		/* Expecting '$'or '(' following CJK ESC. */
d4181 1
a4181 1
    case S_dollar_sq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4190 1
a4190 1
    case S_dollar_paren_sq:	/* Expecting 'C' after CJK "ESC$(". */
d4199 1
a4199 1
    case S_paren_sq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4210 2
a4211 2
    case S_nonascii_text_sq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1281 */
d4228 1
a4228 1
    case S_dollar_dq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4237 1
a4237 1
    case S_dollar_paren_dq:	/* Expecting 'C' after CJK "ESC$(". */
d4246 1
a4246 1
    case S_paren_dq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4257 2
a4258 2
    case S_nonascii_text_dq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1298 */
d4283 1
a4283 1
	    /*pack spaces until first non-space is seen */
d4294 1
a4294 1
    }				/* switch on context->state */
d4296 4
a4299 4
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));
d4301 1
a4301 1
  after_switch:
d4303 4
a4306 4
     * Check whether an external function has added anything to the include
     * buffer.  If so, move the new stuff to the beginning of active_include. 
     * - kw
     */
d4323 2
a4324 2
     * Check whether we've added anything to the recover buffer.  - FM
     */
d4337 4
a4340 3
     * Check whether an external function had added anything to the include
     * buffer; it should now be in active_include.  - FM / kw
     */
d4349 5
a4353 4
		 * If it looks like we would have fed UTF-8 to the next
		 * processing stage, assume that whatever we were fed back is
		 * in UTF-8 form, too.  This won't be always true for all uses
		 * of the include buffer, but it's a start.  - kw
a4355 1

d4359 1
a4359 1
		    c = ((char) (clong & 0xff));
d4366 2
a4367 2
		 * Otherwise assume no UTF-8 - do charset-naive processing and
		 * hope for the best.  - kw
d4377 3
a4379 3
     * Check whether an external function has added anything to the csi buffer. 
     * - FM
     */
d4390 1
a4390 1
}				/* SGML_character */
d4392 4
a4395 1
static void SGML_string(HTStream *context, const char *str)
a4397 1

d4402 5
a4406 2
static void SGML_write(HTStream *context, const char *str,
		       int l)
d4409 1
a4409 2
    const char *e = str + l;

d4418 2
a4419 2
 *	-----------------------
 */
d4422 6
a4427 6
    "SGMLParser",
    SGML_free,
    SGML_abort,
    SGML_character,
    SGML_string,
    SGML_write,
d4431 7
a4437 7
 *	------------------
 *
 * On entry,
 *	dtd		represents the DTD, along with
 *	actions		is the sink for the data as a set of routines.
 *
 */
d4439 4
a4442 3
HTStream *SGML_new(const SGML_dtd * dtd,
		   HTParentAnchor *anchor,
		   HTStructured * target)
d4445 1
a4445 2
    HTStream *context = (HTStream *) malloc(sizeof(*context));

d4455 2
a4456 2
    context->actions = (const HTStructuredClass *) (((HTStream *) target)->isa);
    /* Ugh: no OO */
d4461 1
a4461 1
    context->element_stack = 0;	/* empty */
d4463 1
a4463 1
    context->no_lynx_specialcodes = NO;		/* special codes normally generated */
d4465 1
a4465 1
    context->callerData = (void *) callerData;
d4478 1
a4478 1
    context->node_anchor = anchor;	/* Could be NULL? */
d4494 1
a4494 1
#ifdef CAN_SWITCH_DISPLAY_CHARSET	/* Allow a switch to a more suitable display charset */
d4497 1
a4497 1
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl != current_char_set) {
d4500 1
a4500 1
	anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl = -1;	/* Force reset */
d4502 1
a4502 1
	/* Preserve change this: */
d4537 5
a4541 5
 *		====================================
 *
 *	Added 24-Mar-96 by FM, based on:
 *
 ////////////////////////////////////////////////////////////////////////
d4566 70
a4635 70
void JISx0201TO0208_EUC(register unsigned char IHI,
			register unsigned char ILO,
			register unsigned char *OHI,
			register unsigned char *OLO)
{
    static char *table[] =
    {
	"\241\243",		/* A1,A3 */
	"\241\326",		/* A1,D6 */
	"\241\327",		/* A1,D7 */
	"\241\242",		/* A1,A2 */
	"\241\246",		/* A1,A6 */
	"\245\362",		/* A5,F2 */
	"\245\241",		/* A5,A1 */
	"\245\243",		/* A5,A3 */
	"\245\245",		/* A5,A5 */
	"\245\247",		/* A5,A7 */
	"\245\251",		/* A5,A9 */
	"\245\343",		/* A5,E3 */
	"\245\345",		/* A5,E5 */
	"\245\347",		/* A5,E7 */
	"\245\303",		/* A5,C3 */
	"\241\274",		/* A1,BC */
	"\245\242",		/* A5,A2 */
	"\245\244",		/* A5,A4 */
	"\245\246",		/* A5,A6 */
	"\245\250",		/* A5,A8 */
	"\245\252",		/* A5,AA */
	"\245\253",		/* A5,AB */
	"\245\255",		/* A5,AD */
	"\245\257",		/* A5,AF */
	"\245\261",		/* A5,B1 */
	"\245\263",		/* A5,B3 */
	"\245\265",		/* A5,B5 */
	"\245\267",		/* A5,B7 */
	"\245\271",		/* A5,B9 */
	"\245\273",		/* A5,BB */
	"\245\275",		/* A5,BD */
	"\245\277",		/* A5,BF */
	"\245\301",		/* A5,C1 */
	"\245\304",		/* A5,C4 */
	"\245\306",		/* A5,C6 */
	"\245\310",		/* A5,C8 */
	"\245\312",		/* A5,CA */
	"\245\313",		/* A5,CB */
	"\245\314",		/* A5,CC */
	"\245\315",		/* A5,CD */
	"\245\316",		/* A5,CE */
	"\245\317",		/* A5,CF */
	"\245\322",		/* A5,D2 */
	"\245\325",		/* A5,D5 */
	"\245\330",		/* A5,D8 */
	"\245\333",		/* A5,DB */
	"\245\336",		/* A5,DE */
	"\245\337",		/* A5,DF */
	"\245\340",		/* A5,E0 */
	"\245\341",		/* A5,E1 */
	"\245\342",		/* A5,E2 */
	"\245\344",		/* A5,E4 */
	"\245\346",		/* A5,E6 */
	"\245\350",		/* A5,E8 */
	"\245\351",		/* A5,E9 */
	"\245\352",		/* A5,EA */
	"\245\353",		/* A5,EB */
	"\245\354",		/* A5,EC */
	"\245\355",		/* A5,ED */
	"\245\357",		/* A5,EF */
	"\245\363",		/* A5,F3 */
	"\241\253",		/* A1,AB */
	"\241\254"		/* A1,AC */
d4647 1
a4647 1
static int IS_SJIS_STR(const unsigned char *str)
d4662 4
a4665 3
unsigned char *SJIS_TO_JIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *JCODE)
d4682 4
a4685 3
unsigned char *JIS_TO_SJIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *SJCODE)
d4702 4
a4705 3
unsigned char *EUC_TO_SJIS1(unsigned char HI,
			    unsigned char LO,
			    register unsigned char *SJCODE)
d4713 4
a4716 3
void JISx0201TO0208_SJIS(register unsigned char I,
			 register unsigned char *OHI,
			 register unsigned char *OLO)
d4726 4
a4729 3
unsigned char *SJIS_TO_EUC1(unsigned char HI,
			    unsigned char LO,
			    unsigned char *data)
d4737 3
a4739 2
unsigned char *SJIS_TO_EUC(unsigned char *src,
			   unsigned char *dst)
d4760 3
a4762 2
unsigned char *EUC_TO_SJIS(unsigned char *src,
			   unsigned char *dst)
d4785 5
a4789 4
unsigned char *EUC_TO_JIS(unsigned char *src,
			  unsigned char *dst,
			  const char *toK,
			  const char *toA)
d4836 3
a4838 2
static const unsigned char *repairJIStoEUC(const unsigned char *src,
					   unsigned char **dstp)
d4861 3
a4863 2
unsigned char *TO_EUC(const unsigned char *jis,
		      unsigned char *euc)
a4892 1

d4951 1
a4951 1
static int is_EUC_JP(unsigned char *euc)
d4973 3
a4975 2
void TO_SJIS(const unsigned char *arg,
	     unsigned char *sjis)
d4979 1
a4979 1
    euc = malloc(strlen((const char *) arg) + 1);
d4984 1
a4984 1
    TO_EUC(arg, euc);
d4988 1
a4988 1
	strcpy((char *) sjis, (const char *) arg);
d4992 3
a4994 2
void TO_JIS(const unsigned char *arg,
	    unsigned char *jis)
d4998 1
a4998 1
    if (arg[0] == 0) {
d5002 1
a5002 1
    euc = malloc(strlen((const char *) arg) + 1);
d5007 1
a5007 1
    TO_EUC(arg, euc);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d38 1
a38 1
#ifdef USE_PRETTYSRC
d44 1
a44 1
#ifdef USE_PRETTYSRC
d79 1
a79 1
			    : typecallocn(char, ch->allocated);\
d89 3
a91 2
#define OPT 1

a123 45
typedef enum {
    S_text = 0
    ,S_attr
    ,S_attr_gap
    ,S_comment
    ,S_cro
    ,S_doctype
    ,S_dollar
    ,S_dollar_dq
    ,S_dollar_paren
    ,S_dollar_paren_dq
    ,S_dollar_paren_sq
    ,S_dollar_sq
    ,S_dquoted
    ,S_end
    ,S_entity
    ,S_equals
    ,S_ero
    ,S_esc
    ,S_esc_dq
    ,S_esc_sq
    ,S_exclamation
    ,S_in_kanji
    ,S_incro
    ,S_junk_pi
    ,S_junk_tag
    ,S_litteral
    ,S_marked
    ,S_nonascii_text
    ,S_nonascii_text_dq
    ,S_nonascii_text_sq
    ,S_paren
    ,S_paren_dq
    ,S_paren_sq
    ,S_pcdata
    ,S_script
    ,S_sgmlatt
    ,S_sgmlele
    ,S_sgmlent
    ,S_squoted
    ,S_tag
    ,S_tag_gap
    ,S_tagname_slash
    ,S_value
} sgml_state;
a136 1
    HTTag			*slashedtag;
a138 1
    BOOL			no_lynx_specialcodes;
d142 13
a154 2
    sgml_state			state;
    unsigned char kanji_buf;
a183 1
    char *			active_include;
d188 1
a188 59
#ifdef USE_PRETTYSRC
    BOOL			cur_attr_is_href;
    BOOL			cur_attr_is_name;
    BOOL			seen_nonwhite_in_junk_tag;
#endif
};

#ifndef NO_LYNX_TRACE
PRIVATE char *state_name ARGS1(sgml_state, n)
{
    char *result = "?";
    switch (n) {
    case S_attr:                result = "S_attr";              break;
    case S_attr_gap:            result = "S_attr_gap";          break;
    case S_comment:             result = "S_comment";           break;
    case S_cro:                 result = "S_cro";               break;
    case S_doctype:             result = "S_doctype";           break;
    case S_dollar:              result = "S_dollar";            break;
    case S_dollar_dq:           result = "S_dollar_dq";         break;
    case S_dollar_paren:        result = "S_dollar_paren";      break;
    case S_dollar_paren_dq:     result = "S_dollar_paren_dq";   break;
    case S_dollar_paren_sq:     result = "S_dollar_paren_sq";   break;
    case S_dollar_sq:           result = "S_dollar_sq";         break;
    case S_dquoted:             result = "S_dquoted";           break;
    case S_end:                 result = "S_end";               break;
    case S_entity:              result = "S_entity";            break;
    case S_equals:              result = "S_equals";            break;
    case S_ero:                 result = "S_ero";               break;
    case S_esc:                 result = "S_esc";               break;
    case S_esc_dq:              result = "S_esc_dq";            break;
    case S_esc_sq:              result = "S_esc_sq";            break;
    case S_exclamation:         result = "S_exclamation";       break;
    case S_in_kanji:            result = "S_in_kanji";          break;
    case S_incro:               result = "S_incro";             break;
    case S_junk_pi:             result = "S_junk_pi";           break;
    case S_junk_tag:            result = "S_junk_tag";          break;
    case S_litteral:            result = "S_litteral";          break;
    case S_marked:              result = "S_marked";            break;
    case S_nonascii_text:       result = "S_nonascii_text";     break;
    case S_nonascii_text_dq:    result = "S_nonascii_text_dq";  break;
    case S_nonascii_text_sq:    result = "S_nonascii_text_sq";  break;
    case S_paren:               result = "S_paren";             break;
    case S_paren_dq:            result = "S_paren_dq";          break;
    case S_paren_sq:            result = "S_paren_sq";          break;
    case S_pcdata:              result = "S_pcdata";            break;
    case S_script:              result = "S_script";            break;
    case S_sgmlatt:             result = "S_sgmlatt";           break;
    case S_sgmlele:             result = "S_sgmlele";           break;
    case S_sgmlent:             result = "S_sgmlent";           break;
    case S_squoted:             result = "S_squoted";           break;
    case S_tag:                 result = "S_tag";               break;
    case S_tag_gap:             result = "S_tag_gap";           break;
    case S_tagname_slash:       result = "S_tagname_slash";     break;
    case S_text:                result = "S_text";              break;
    case S_value:               result = "S_value";             break;
    }
    return result;
}
#endif
d190 2
a191 1
#ifdef USE_PRETTYSRC
d195 1
a195 1
	    HTlexeme,	      lexeme,
d198 1
a198 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d209 1
a209 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
a226 1
#if ANSI_PREPRO
a228 4
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_/**/x,START)
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(context,HTL_/**/x,STOP)
#endif
d230 2
a231 2
#define attr_is_href context->cur_attr_is_href
#define attr_is_name context->cur_attr_is_name
d242 1
a242 1
	**  so the HTML parser's UCLYhndl should still be its
d363 1
a363 1
#ifdef USE_PRETTYSRC
d365 2
a366 2
	attr_is_href = FALSE;
	attr_is_name = FALSE;
d373 1
a373 1
#ifdef USE_PRETTYSRC
d390 1
a390 1
#ifdef USE_PRETTYSRC
d396 4
a399 1
#  ifdef USE_PRETTYSRC
d401 1
d405 1
a405 1
	    CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
d408 1
a408 1
#ifdef USE_PRETTYSRC
d410 2
a411 2
		 attr_is_name = (BOOL) (attributes[i].type == HTMLA_ANAME);
		 attr_is_href = (BOOL) (attributes[i].type == HTMLA_HREF);
d419 2
a420 2
    CTRACE((tfp, "SGML: Unknown attribute %s for tag %s\n",
		s, context->current_tag->name));
d438 1
a438 1
	    CTRACE((tfp, "SGML: class is '%s'\n", s));
d442 1
a442 1
	    CTRACE((tfp, "SGML: attribute value is '%s'\n", s));
d446 1
a446 1
	CTRACE((tfp, "SGML: Attribute value %s ***ignored\n", s));
a465 8
    /* (Tgf_nolyspcl) */
    if (context->no_lynx_specialcodes) {
	/*
	**  We were asked by a "DTD" flag to not generate lynx specials. - kw
	*/
	return NO;
    }

d470 1
a470 1
#ifdef USE_PRETTYSRC
d478 1
a478 1
#ifdef USE_PRETTYSRC
d493 1
a493 2
	**
	**  We may treat emsp as one or two ensp (below).
d495 1
a495 1
#ifdef USE_PRETTYSRC
d503 1
a503 1
#ifdef USE_PRETTYSRC
d508 1
a508 1
#ifdef USE_PRETTYSRC
d560 1
a560 1
#ifdef USE_PRETTYSRC
d581 1
a581 1
#ifdef USE_PRETTYSRC
d599 1
a599 1
#ifdef USE_PRETTYSRC
d617 1
a617 1
#ifndef USE_PRETTYSRC
d625 1
a625 1
	      (putc_func_t*)(fake_put_character), code)): PUTUTF8(code) ) ) {
d641 1
a641 1
#ifdef USE_PRETTYSRC
d664 2
a665 2
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
d683 2
a684 2
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
d702 1
a702 1
#ifdef USE_PRETTYSRC
d706 1
a706 1
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long)code, uck)); /* S/390 -- gil -- 0695 */
d713 1
a713 1
#ifdef USE_PRETTYSRC
d728 1
a728 1
    CTRACE((tfp, "SGML Comment:\n<%s>\n", s));
d750 1
a750 1
    CTRACE((tfp, "SGML Identifier:\n<%s>\n", s));
d764 1
a764 1
    CTRACE((tfp, "SGML Doctype:\n<%s>\n", s));
a768 4
PRIVATE void SGML_write PARAMS((
	HTStream *		me,
	CONST char *		s,
	int			l));
d778 1
a778 1
    CTRACE((tfp, "SGML Marked Section:\n<%s>\n", s));
a779 13
    if (!strncmp(context->string->data, "![INCLUDE[", 10)) {
	context->string->data[context->string->size - 3] = '\0';
	StrAllocCat(context->include, context->string->data + 10);
	/* @@@@@@ This needs to take charset into account! @@@@@@
	   the wrong assumptions will be made about the data's
	   charset once it is in include - kw */

    } else if (!strncmp(context->string->data, "![CDATA[", 8)) {
	(*context->actions->_write)(context->target,
		   context->string->data + 8,
		   context->string->size - 11);

    }
d792 1
a792 1
    CTRACE((tfp, "SGML Entity Declaration:\n<%s>\n", s));
d806 1
a806 1
    CTRACE((tfp, "SGML Element Declaration:\n<%s>\n", s));
d820 1
a820 1
    CTRACE((tfp, "SGML Attribute Declaration:\n<%s>\n", s));
a824 30
/*
 *  Convenience macros - tags (elements) are identified sometimes
 *  by an int or enum value ('TAGNUM'), sometimes
 *  by a pointer to HTTag ('TAGP'). - kw
 */
#define TAGNUM_OF_TAGP(t) (t - context->dtd->tags)
#define TAGP_OF_TAGNUM(e) (context->dtd->tags + e)

/*
 *  The following implement special knowledge about OBJECT.
 *  As long as HTML_OBJECT is the only tag for which an alternative
 *  variant exist, they can be simple macros. - kw
 */
/* does 'TAGNUM' e have an alternative (variant) parsing mode? */
#define HAS_ALT_TAGNUM(e) (e == HTML_OBJECT)

/* return 'TAGNUM' of the alternative mode for 'TAGNUM' e, if any. */
#define ALT_TAGNUM(e) ((e == HTML_OBJECT) ? HTML_ALT_OBJECT : e)

/* return 'TAGNUM' of the normal mode for 'TAGNUM' e which may be alt. */
#define NORMAL_TAGNUM(e) ((e >= HTML_ELEMENTS) ? HTML_OBJECT : e)

/* More convenience stuff. - kw */
#define ALT_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(ALT_TAGNUM(e))
#define NORMAL_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(NORMAL_TAGNUM(e))

#define ALT_TAGP(t) ALT_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))
#define NORMAL_TAGP(t) NORMAL_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))


d838 1
a838 1
	return (BOOL) ((Tgc_same & usecontains) &&
d841 1
a841 1
	return (BOOL) ((new_tag->tagclass & usecontains) &&
a871 1
    HTMLElement e;
a876 4
    e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(stacked->tag));
#ifdef USE_PRETTYSRC
    if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
#endif
d879 1
a879 1
	e,
a882 2
    context->no_lynx_specialcodes = context->element_stack ?
	(context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
d892 1
a892 2
	if (stacked->tag == old_tag ||
	    stacked->tag == ALT_TAGP(old_tag))
a915 5
	    if (stackpos == 0 && (old_tag->flags & Tgf_startO) &&
		element_valid_within(old_tag, context->element_stack->tag, YES)) {
		CTRACE((tfp, "SGML: </%s> ignored\n", old_tag->name));
		return;
	    }
d918 1
a918 1
		CTRACE((tfp, "SGML: End </%s> \t<- %s end </%s>\n",
d921 1
a921 1
			    old_tag->name));
d925 5
d934 1
a934 1
	    CTRACE((tfp, "SGML: Still open %s, ***no open %s for </%s>\n",
d938 1
a938 1
			old_tag->name));
d942 1
a942 1
	    CTRACE((tfp, "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
d945 1
a945 1
			old_tag->name));
d967 2
a968 2
	    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
			old_tag->name));
d975 1
a975 1
    CTRACE((tfp, "SGML: End </%s>\n", old_tag->name));
d977 2
a978 2
	CTRACE((tfp, "SGML: ***Illegal end tag </%s> found.\n",
		    old_tag->name));
a986 2
	int status = HT_OK;
	HTMLElement e;
d988 1
a988 1
	HTTag * t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;
d992 2
a993 2
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			     old_tag->name, t->name, t->name));
d995 2
a996 2
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			    old_tag->name, t->name, old_tag->name));
d1001 4
a1004 25
	e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(t));
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", t, e));
#ifdef USE_PRETTYSRC
	if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
#endif
	    status = (*context->actions->end_element)(context->target,
						e, (char **)&context->include);
	if (status == HT_PARSER_REOPEN_ELT) {
	    CTRACE((tfp, "SGML: Restart <%s>\n", t->name));
	    (*context->actions->start_element)(
		context->target,
		e,
		NULL,
		NULL,
		context->current_tag_charset,
		(char **)&context->include);
	} else if (status == HT_PARSER_OTHER_CONTENT) {
	    CTRACE((tfp, "SGML: Continue with other content model for <%s>\n", t->name));
	    context->element_stack->tag = ALT_TAGP_OF_TAGNUM(e);
	} else {
	    context->element_stack = N->next;		/* Remove from stack */
	    FREE(N);
	}
	context->no_lynx_specialcodes = context->element_stack ?
	    (context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
d1015 2
a1016 2
    CTRACE((tfp, "SGML: Extra end tag </%s> found and ignored.\n",
		old_tag->name));
a1024 1
    int status;
d1026 2
a1027 1
    HTMLElement e = TAGNUM_OF_TAGP(new_tag);
d1029 1
d1047 1
a1047 1
		CTRACE((tfp, "SGML: End </%s> \t<- %s start <%s>\n",
d1050 1
a1050 1
			    new_tag->name));
d1056 1
a1056 1
		CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1058 1
a1058 1
			    new_tag->name));
d1065 1
a1065 1
	    CTRACE((tfp, "SGML: Still open %s \t<- ***ignoring start <%s>\n",
d1067 1
a1067 1
			new_tag->name));
d1078 1
a1078 1
		CTRACE((tfp, "SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
d1081 1
a1081 1
			    new_tag->name));
d1093 1
a1093 1
	    CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1095 1
a1095 1
			new_tag->name));
d1127 10
d1146 2
a1147 2
	    if (ok)
	    {
d1152 2
a1153 2
		CTRACE((tfp, "SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			    new_tag->name));
d1159 2
a1160 2
		CTRACE((tfp, "SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			    new_tag->name));
d1168 2
a1169 2
    CTRACE((tfp, "SGML: Start <%s>\n", new_tag->name));
    status = (*context->actions->start_element)(
d1171 1
a1171 1
	TAGNUM_OF_TAGP(new_tag),
a1175 2
    if (status == HT_PARSER_OTHER_CONTENT)
	new_tag = ALT_TAGP(new_tag);	/* this is only returned for OBJECT */
d1183 3
a1185 2
	context->no_lynx_specialcodes = (new_tag->flags & Tgf_nolyspcl);

d1187 1
d1223 1
a1223 1
    if (IsNmStart(string[0])) {
a1253 1
    FREE(context->active_include);
d1263 2
a1264 6
#ifdef USE_PRETTYSRC
	if (!psrc_view) /* Don't actually call on target if viewing psrc - kw */
#endif
	    (*context->actions->end_element)(context->target,
		    NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
		    (char **)&context->include);
d1281 1
a1281 1
#ifdef USE_PRETTYSRC
a1302 1
    FREE(context->active_include);
d1323 1
a1323 1
#ifdef USE_PRETTYSRC
a1360 1
    HTTag * testtag = NULL;
a1362 3
#ifdef CJK_EX
    unsigned char c;
#else
a1363 1
#endif
d1374 1
a1374 1
    clong = UCH(c);	/* a.k.a. unsign_c */
d1382 1
a1382 1
	if (TOASCII(UCH(c)) > 127) { /* S/390 -- gil -- 0710 */
a1545 3
**  Stuff from the recover buffer is now handled
**  as UTF-8 if we can expect that's what it is,
**  and in that case we don't come back up here. - kw
d1558 1
a1558 1
    clong = UCH(c);
d1580 1
a1580 1
	goto after_switch;
d1590 1
a1590 1
	goto after_switch;
d1598 1
a1598 20
	goto after_switch;

    /* Almost all CJK characters are double byte but only Japanese
     * JIS X0201 Kana is single byte. To prevent to fail SGML parsing
     * we have to care them here. -- TH
     */
    if ((HTCJK==JAPANESE) && (context->state==S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
	if (IS_SJIS_X0201KANA(context->kanji_buf)) {
	    unsigned char sjis_hi, sjis_lo;
	    JISx0201TO0208_SJIS(context->kanji_buf, &sjis_hi, &sjis_lo);
	    PUTC(sjis_hi);
	    PUTC(sjis_lo);
	}
	else
#endif
	    PUTC(context->kanji_buf);
	context->state = S_text;
    }
a1602 4
    CTRACE2(TRACE_SGML, (tfp, "SGML before %s|%.*s|%c\n",
	    state_name(context->state),
	    string->size,
	    string->data != NULL ? string->data : "", UCH(c)));
a1616 1
	PUTC(context->kanji_buf);
a1619 12
    case S_tagname_slash:
	/*
	 *  We had something link "<name/" so far, set state to S_text
	 *  but keep context->slashedtag as as a flag; except if we get
	 *  '>' directly after the "<name/", and really have a tag for
	 *  that name in context->slashedtag, in which case keep state as
	 *  is and let code below deal with it. - kw
	 */
	if (!(c == '>' && context->slashedtag && TOASCII(unsign_c) < 127)) {
	    context->state = S_text;
	} /* fall through in any case! */

d1633 1
a1633 1
	    context->kanji_buf = c;
a1643 13

	if (c == '&' || c == '<') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) { /*there is nothing useful in the element_stack*/
		testtag = context->current_tag;
	    } else
#endif
	    {
		testtag = context->element_stack ?
		     context->element_stack->tag : NULL;
	    }
	}

d1645 6
a1650 8
	    (!testtag ||
	     (testtag->contents == SGML_MIXED ||
	      testtag->contents == SGML_ELEMENT ||
	      testtag->contents == SGML_PCDATA ||
#ifdef USE_PRETTYSRC
	      testtag->contents == SGML_EMPTY ||
#endif
	      testtag->contents == SGML_RCDATA))) {
d1661 5
a1665 75
	    if (testtag && testtag->contents == SGML_PCDATA) {
		context->state = S_pcdata;
	    } else if (testtag && (testtag->contents == SGML_LITTERAL
	    			|| testtag->contents == SGML_CDATA)) {
		context->state = S_litteral;
	    } else if (testtag && (testtag->contents == SGML_SCRIPT)) {
		context->state = S_script;
	    } else {
		context->state = S_tag;
	    }
	    context->slashedtag = NULL;
	} else if (context->slashedtag &&
		   (c == '/' ||
		    (c == '>' && context->state == S_tagname_slash)) &&
		   TOASCII(unsign_c) < 127) {
	    /*
	    **	We got either the second slash of a pending "<NAME/blah blah/"
	    **  shortref construct, or the '>' of a mere "<NAME/>".  In both
	    **  cases generate a "</NAME>" end tag in the recover buffer for
	    **  reparsing unless NAME is really an empty element. - kw
	    */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC(c);
		PSRCSTOP(abracket);
	    } else
#endif
	    if (context->slashedtag != context->unknown_tag &&
		!ReallyEmptyTag(context->slashedtag)) {
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, "</");
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, "</");
		}
		StrAllocCat(context->recover, context->slashedtag->name);
		StrAllocCat(context->recover, ">");
	    }
	    context->slashedtag = NULL;

	} else if (context->element_stack &&
		   (context->element_stack->tag->flags & Tgf_frecyc)) {
	    /*
	     *  The element stack says we are within the contents of an
	     *  element that the next stage (HTML.c) may want to feed
	     *  us back again (via the *include string).  So try to output
	     *  text in UTF-8 if possible, using the same logic as for
	     *  attribute values (which should be in line with what
	     *  context->current_tag_charset indicates). - kw
	     */
	    if (context->T.decode_utf8 &&
		*context->utf_buf) {
		PUTS(context->utf_buf);
		context->utf_buf_p = context->utf_buf;
		*(context->utf_buf_p) = '\0';
	    } else if (HTCJK == NOCJK &&
		       (context->T.output_utf8 ||
			context->T.trans_from_uni)) {
		if (LYIsASCII(clong)) {
		    PUTC(c);
		} else if (clong == 0xfffd && saved_char_in &&
		    HTPassEightBitRaw &&
		    UCH(saved_char_in) >=
		    LYlowest_eightbit[context->outUCLYhndl]) {
		    PUTUTF8((0xf000 | UCH(saved_char_in)));
		} else {
		    PUTUTF8(clong);
		}
	    } else if (saved_char_in && context->T.use_raw_char_in) {
		PUTC(saved_char_in);
	    } else {
		PUTC(c);
	    }

a1671 1
		   !context->no_lynx_specialcodes &&
a1678 1
		   !context->no_lynx_specialcodes &&
d1696 1
a1696 1
	} else if ((chk = (BOOL) (context->T.trans_from_uni && TOASCII(unsign_c) >= 160)) &&  /* S/390 -- gil -- 0968 */
d1700 2
a1701 2
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck)));
d1746 1
a1746 1
#ifdef USE_PRETTYSRC
d1755 1
a1755 1
#ifdef USE_PRETTYSRC
d1762 1
a1762 1
#ifdef USE_PRETTYSRC
d1794 2
a1795 2
		   (UCH(saved_char_in) >= 0xc0) &&
		   (UCH(saved_char_in) < 255)) {
d1807 1
a1807 1
	} else if (TOASCII(UCH(c)) <	 /* S/390 -- gil -- 0997 */
a1859 57
    **	Found '<' in SGML_PCDATA content; treat this mode nearly like
    **  S_litteral, but recognize '<!' and '<?' to filter out comments
    **  and processing instructions. - kw
    */
    case S_pcdata:
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
		/*
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    } else if (c == '?') { /* <? - ignore as a PI until '>' - kw */
		CTRACE((tfp,
			"SGML: Found PI in PCDATA, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);PUTS("<?");PSRCSTOP(abracket);
		    context->seen_nonwhite_in_junk_tag = TRUE; /* show all */
		}
#endif
		context->state = S_junk_pi;
		break;
	    }
	}
	goto case_S_litteral;

    /*
    **  Found '<' in SGML_SCRIPT content; treat this mode nearly like
    **  S_litteral, but recognize '<!' to allow the content to be treated
    **  as a comment by lynx.
    */
    case S_script:
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
		/*
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    }
	}
	goto case_S_litteral;

    /*
a1862 1
    case_S_litteral:
a1864 8
#ifdef USE_PRETTYSRC
	if (psrc_view) { /*there is nothing useful in the element_stack*/
	    testtag = context->current_tag;
	} else
#endif
	    testtag = context->element_stack ?
		context->element_stack->tag : NULL;

d1867 1
a1867 1
			   testtag->name[string->size-2])) {
d1873 2
a1874 24
	    if ((c == '>') && testtag &&
		string->size > 1 && !testtag->name[string->size-2]) {
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);PUTC('<');PUTC('/');PSRCSTOP(abracket);
		    PSRCSTART(tag);
		    strcpy(string->data,context->current_tag->name);
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
		    PUTS(string->data);
		    PSRCSTOP(tag);
		    PSRCSTART(abracket);PUTC('>');PSRCSTOP(abracket);

		    context->current_tag = NULL;
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    context->state = S_text;
		    break;
		}
#endif
a1880 22

	    if (((testtag->contents != SGML_LITTERAL &&
		  (testtag->flags & Tgf_strict)) ||
		 (context->state == S_pcdata &&
		  (testtag->flags & (Tgf_strict|Tgf_endO)))) &&
		(string->size > 1 &&
		 (c == '>' || string->size > 2 || IsNmStart(c)))) {
		context->state = S_end;
		string->size--;
		for (i = 0; i < string->size; i++)  /* remove '/' */
		    string->data[i] = string->data[i+1];
		if ((string->size == 1) ? IsNmStart(c) : IsNmChar(c))
		    break;
		string->size--;
		goto top1;
	    }
	    if (context->state == S_pcdata &&
		(testtag->flags & (Tgf_strict|Tgf_endO)) &&
		(string->size == 1 && IsNmStart(c))) {
		context->state = S_tag;
		break;
	    }
d1882 1
a1882 1
	    **	If Mismatch: recover string literally.
d1911 1
a1911 4
		  isalnum(UCH(c)) : isalpha(UCH(c)))) {
	    /* Should probably use IsNmStart/IsNmChar above (is that right?),
	       but the world is not ready for that - there's &nbsp: (note
	       colon!) and stuff around. */
d1921 1
a1921 1
#ifdef USE_PRETTYSRC
d1926 1
a1926 1
#ifdef USE_PRETTYSRC
d1937 1
a1937 1
#ifdef USE_PRETTYSRC
d1941 1
a1941 1
	    /* CTRACE((tfp, "%s: %d: %s\n", __FILE__, __LINE__, string->data)); */
d1951 1
a1951 1
		CTRACE((tfp, "SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));
d1978 1
a1978 1
#ifdef USE_PRETTYSRC
d1994 1
a1994 1
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {  /* S/390 -- gil -- 1060 */
d1997 1
a1997 1
	} else if (TOASCII(unsign_c) < 127 && isdigit(UCH(c))) {
d2009 1
a2009 1
#ifdef USE_PRETTYSRC
d2015 1
a2015 1
#ifdef USE_PRETTYSRC
d2028 2
a2029 2
	/* S/390 -- gil -- 1075 */ /* CTRACE((tfp, "%s: %d: numeric %d %d\n",
			    __FILE__, __LINE__, unsign_c, c)); */
d2031 2
a2032 2
	    (context->isHex ? isxdigit(UCH(c)) :
			      isdigit(UCH(c)))) {
d2042 1
a2042 1
#ifdef USE_PRETTYSRC
d2049 1
a2049 1
#ifdef USE_PRETTYSRC
d2063 1
a2063 1
#ifdef USE_PRETTYSRC
d2216 1
a2216 1
		    CTRACE((tfp, "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));
d2246 1
a2246 1
#ifdef USE_PRETTYSRC
d2271 1
a2271 1
#ifdef USE_PRETTYSRC
d2275 1
a2275 1
#ifdef USE_PRETTYSRC
d2293 1
a2293 1
#ifdef USE_PRETTYSRC
d2326 1
a2326 1
#ifdef USE_PRETTYSRC
d2345 1
a2345 1
#ifdef USE_PRETTYSRC
d2374 1
a2374 1
#ifdef USE_PRETTYSRC
d2416 1
a2416 1
#ifdef USE_PRETTYSRC
d2430 1
a2430 1
#ifdef USE_PRETTYSRC
d2445 1
a2445 1
#ifdef USE_PRETTYSRC
d2479 1
a2479 1
#ifdef USE_PRETTYSRC
d2492 1
a2492 1
#ifdef USE_PRETTYSRC
d2525 1
a2525 1
#ifdef USE_PRETTYSRC
d2531 1
a2531 1
#ifdef USE_PRETTYSRC
d2558 1
a2558 1
		  IsNmChar(c) : IsNmStart(c))) {
d2586 1
a2586 1
#ifdef USE_PRETTYSRC
d2591 1
a2591 1
#ifdef USE_PRETTYSRC
d2602 4
a2605 5
		if (string->size == 0) {
		    context->state = S_end;
		    break;
		}
		CTRACE((tfp,"SGML: `<%.*s/' found!\n", string->size, string->data));
d2610 2
a2611 4
	    if (t == context->unknown_tag &&
		((c == ':' &&
		  string->size == 4 && 0 == strcasecomp(string->data, "URL")) ||
		 (string->size > 4 && 0 == strncasecomp(string->data, "URL:", 4)))) {
d2616 2
a2617 1
#ifdef USE_PRETTYSRC
d2622 2
a2623 1
		PUTS(string->data); /* recover */
d2625 1
a2625 1
#ifdef USE_PRETTYSRC
d2629 2
a2630 2
		CTRACE((tfp, "SGML: Treating <%s%c as text\n",
			    string->data, c));
d2634 3
a2636 24
	    }
	    if (c == '/' && t) {
		/*
		 *  Element name was ended by '/'.  Remember the tag that
		 *  ended thusly, we'll interpret this as either an indication
		 *  of an empty element (if '>' follows directly) or do
		 *  some SGMLshortref-ish treatment. - kw
		 */
		context->slashedtag = t;
	    }
	    if (!t) {
		if (c == '?' && string->size <= 1) {
		    CTRACE((tfp, "SGML: Found PI, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(abracket);PUTS("<?");PSRCSTOP(abracket);
			context->seen_nonwhite_in_junk_tag = TRUE; /*show all*/
		    }
#endif
		    context->state = S_junk_pi;
		    break;
		}
		CTRACE((tfp, "SGML: *** Invalid element %s\n",
			    string->data));
d2638 1
a2638 1
#ifdef USE_PRETTYSRC
d2649 1
a2652 2
		    } else {
			PUTC(c);
d2659 2
a2660 2
		CTRACE((tfp, "SGML: *** Unknown element %s\n",
			    string->data));
d2669 4
a2672 1
#ifdef USE_PRETTYSRC
a2685 4
		if (t != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d2690 5
a2694 3
	    /*
	    **	Clear out attributes.
	    */
d2697 1
d2702 1
a2702 1
#ifdef USE_PRETTYSRC
d2704 9
a2712 9
		if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
		    if (c != '<') {
			PSRCSTART(abracket);
			PUTC(c);
			PSRCSTOP(abracket);
			context->state = (c == '>') ? S_text : S_tagname_slash;
		    } else {
			context->state = S_tag;
		    }
a2713 2
		    if (!WHITE(c))
			PUTC(c);
d2718 1
a2718 1
	    if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
d2721 1
a2721 2
		context->state = (c == '>') ? S_text :
		    (c == '<') ? S_tag : S_tagname_slash;
d2767 1
a2767 1
#ifdef USE_PRETTYSRC
d2836 1
a2836 1
#ifdef USE_PRETTYSRC
d2840 1
a2840 1
		    PUTS_TR(string->data);
d2852 2
a2853 1
	    goto S_comment_put_c;
d2878 8
a2885 8
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(comm);
		PUTC('<');
		PUTS_TR(string->data);
		PUTC('>');
		PSRCSTOP(comm);
	    } else
d2887 1
a2887 1
		handle_comment(context);
d2895 1
a2895 1
	if (context->end_comment && !isspace(UCH(c)))
d2897 1
a2897 24

    S_comment_put_c:
	if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (HTCJK == NOCJK &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		UCH(saved_char_in) >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (0xf000 | UCH(saved_char_in)));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
d2914 1
a2914 1
#ifdef USE_PRETTYSRC
d2946 1
a2946 1
#ifdef USE_PRETTYSRC
d2980 1
a2980 1
#ifdef USE_PRETTYSRC
d3017 1
a3017 1
#ifdef USE_PRETTYSRC
d3054 1
a3054 1
#ifdef USE_PRETTYSRC
d3078 1
a3078 1
#ifdef USE_PRETTYSRC
d3083 1
a3083 1
#ifdef USE_PRETTYSRC
d3085 4
d3106 1
a3106 1
#ifdef USE_PRETTYSRC
d3116 2
a3117 2
#ifdef USE_PRETTYSRC
	    } else {
d3130 7
a3136 5
		if (c == '=' ) PUTC('=');
		if (context->current_attribute_number == INVALID)
		    PSRCSTOP(badattr);
		else
		    PSRCSTOP(attrib);
d3138 4
d3161 1
a3161 1
#ifdef USE_PRETTYSRC
d3163 1
a3163 1
		if (context->current_attribute_number == INVALID) {
d3165 1
a3165 1
		} else {
d3167 4
a3170 1
		}
d3174 1
a3174 1
	    } else
d3181 1
a3181 1
#ifdef USE_PRETTYSRC
d3184 1
a3184 1
		if (context->current_attribute_number == INVALID) {
d3186 1
a3186 1
		} else {
a3187 1
		}
d3193 7
d3208 2
a3209 2
	    CTRACE((tfp, "SGML: found = but no value\n"));
#ifdef USE_PRETTYSRC
d3211 4
d3226 1
a3226 1
#ifdef USE_PRETTYSRC
d3236 1
a3236 1
#ifdef USE_PRETTYSRC
d3245 1
a3245 1
#ifdef USE_PRETTYSRC
d3250 1
a3250 1
	/*  no break!  fall through to S_value and process current `c`	 */
d3255 1
a3255 1
#ifdef USE_PRETTYSRC
d3258 1
a3258 1
		if (attr_is_name) {
d3264 1
a3264 1
		} else if (attr_is_href) {
d3269 1
a3269 1
		if (attr_is_href) {
a3278 11
#ifdef CJK_EX	/* Quick hack. - JH7AYN */
	    {   char jis_buf[512];
		if (string->data[0] == '$') {
		  if (string->data[1] == 'B' || string->data[1] == '@@') {
		    jis_buf[0] = '\033';
		    strcpy(jis_buf + 1, string->data);
		    TO_EUC((CONST unsigned char *)jis_buf, (unsigned char *)string->data);
		  }
		}
	    }
#endif
d3282 1
a3282 1
#ifdef USE_PRETTYSRC
d3284 4
d3309 1
a3309 1
		UCH(saved_char_in) >=
d3312 1
a3312 1
				   (0xf000 | UCH(saved_char_in)));
d3326 1
a3326 1
#ifdef USE_PRETTYSRC
d3329 1
a3329 1
		if (attr_is_name) {
d3335 1
a3335 1
		} else if (attr_is_href) {
d3340 1
a3340 1
		if (attr_is_href) {
d3371 1
a3371 1
		UCH(saved_char_in) >=
d3374 1
a3374 1
				   (0xf000 | UCH(saved_char_in)));
d3390 1
a3390 1
#ifdef USE_PRETTYSRC
d3393 1
a3393 1
		if (attr_is_name) {
d3399 1
a3399 1
		} else if (attr_is_href) {
d3404 1
a3404 1
		if (attr_is_href) {
d3438 1
a3438 1
		UCH(saved_char_in) >=
d3441 1
a3441 1
				   (0xf000 | UCH(saved_char_in)));
d3453 1
a3453 2
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1247 */
		  IsNmChar(c) : IsNmStart(c))) {
d3457 1
a3457 1
#ifdef USE_PRETTYSRC
d3469 2
a3470 2
		CTRACE((tfp, "Unknown end tag </%s>\n", string->data));
#ifdef USE_PRETTYSRC
d3483 2
a3484 7
		    PUTS(string->data);
		    if (c != '>') {
			PUTC(c);
		    } else {
			PSRCSTOP(badtag);
			PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
		    }
d3490 1
a3490 1
		BOOL tag_OK = (BOOL) (c == '>' || WHITE(c));
d3492 1
a3492 1
		HTMLElement e = TAGNUM_OF_TAGP(t);
a3495 4
		if (HAS_ALT_TAGNUM(TAGNUM_OF_TAGP(t)) &&
		    context->element_stack &&
		    ALT_TAGP(t) == context->element_stack->tag)
		    context->element_stack->tag = NORMAL_TAGP(context->element_stack->tag);
a3496 1
		if (tag_OK
d3498 3
a3500 1
		 && Old_DTD
a3501 1
		 ) {
a3513 2
		    default:
			break;
d3527 2
a3529 3
#if OPT
		    (branch == 0)
#else
d3540 3
a3542 1
		     !strcasecomp(string->data, "COLGROUP"))
a3543 1
		 ) {
d3548 2
a3549 2
		    CTRACE((tfp, "SGML: `</%s%c' found!  Ignoring it.\n",
				string->data, c));
a3554 1
			context->current_tag = NULL;
d3558 1
a3559 3
#if OPT
			   (branch == 1)
#else
d3571 3
a3573 1
			    !strcasecomp(string->data, "U"))
a3574 1
		) {
d3590 2
a3591 2
			    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
					string->data));
d3597 2
a3598 2
			    CTRACE((tfp, "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
					string->data));
d3601 1
a3601 1
			    CTRACE((tfp, "SGML: End </%s>\n", string->data));
a3602 3
#ifdef USE_PRETTYSRC
			    if (!psrc_view) /* Don't actually call if viewing psrc - kw */
#endif
d3605 1
a3605 1
				 TAGNUM_OF_TAGP(context->current_tag),
d3613 2
a3614 2
			CTRACE((tfp, "SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				    string->data, c, string->data, c));
d3626 1
a3626 1
			CTRACE((tfp, "SGML: End </%s>\n", string->data));
a3627 3
#ifdef USE_PRETTYSRC
			if (!psrc_view) /* Don't actually call if viewing psrc - kw */
#endif
d3630 1
a3630 1
			     TAGNUM_OF_TAGP(context->current_tag),
a3637 1
			context->current_tag = NULL;
d3649 1
a3649 1
#ifdef USE_PRETTYSRC
d3663 1
a3663 1
		if ( c != '>' ) {
d3665 1
a3665 2
		    PUTC(c);
		} else {
d3677 1
a3677 1
		    CTRACE((tfp,"SGML: `</%s%c' found!\n", string->data, c));
a3679 1
		context->current_tag = NULL;
a3730 2
	if (c < 32)
	    context->state = S_text;
a3827 1
    case S_junk_pi:
d3829 1
a3829 1
#ifdef USE_PRETTYSRC
d3831 1
a3831 3
		if (context->state == S_junk_tag) {
		    PSRCSTOP(badtag);
		}
d3835 1
a3835 1
		context->seen_nonwhite_in_junk_tag = FALSE;
a3837 1
	    context->current_tag = NULL;
d3840 1
a3840 1
#ifdef USE_PRETTYSRC
d3843 1
a3843 1
	    if (!context->seen_nonwhite_in_junk_tag) {
d3845 1
a3845 1
		    context->seen_nonwhite_in_junk_tag = TRUE;
d3847 1
a3847 1
		}
d3850 1
a3850 1
	}
a3853 25
    CTRACE2(TRACE_SGML, (tfp, "SGML after  %s|%.*s|%c\n",
	    state_name(context->state),
	    string->size,
	    string->data != NULL ? string->data : "", UCH(c)));

after_switch:
    /*
    **	Check whether an external function has added
    **	anything to the include buffer.  If so, move the
    **	new stuff to the beginning of active_include. - kw
    */
    if (context->include != NULL) {
	if (context->include[0] == '\0') {
	    FREE(context->include);
	} else {
	    if (context->active_include &&
		context->active_include[context->include_index] != '\0')
		StrAllocCat(context->include,
			    context->active_include + context->include_index);
	    FREE(context->active_include);
	    context->active_include = context->include;
	    context->include_index = 0;
	    context->include = NULL;
	}
    }
d3870 2
a3871 3
    **	Check whether an external function had added
    **	anything to the include buffer; it should now be
    **  in active_include. - FM / kw
d3873 3
a3875 3
    if (context->active_include != NULL) {
	if (context->active_include[context->include_index] == '\0') {
	    FREE(context->active_include);
d3878 3
a3880 27
	    if (context->current_tag_charset == UTF8 ||
		context->T.trans_from_uni) {
		/*
		 *  If it looks like we would have fed UTF-8 to the
		 *  next processing stage, assume that whatever we were
		 *  fed back is in UTF-8 form, too.  This won't be always
		 *  true for all uses of the include buffer, but it's a
		 *  start. - kw
		 */
		char *puni = context->active_include + context->include_index;
		c = *puni;
		clong = UCGetUniFromUtf8String(&puni);
		if (clong < 256 && clong >= 0) {
			c = ((char)(clong & 0xff));
		}
		saved_char_in = '\0';
		context->include_index = puni - context->active_include + 1;
		goto top1;
	    } else {
		/*
		 *  Otherwise assume no UTF-8 - do charset-naive processing
		 *  and hope for the best. - kw
		 */
		c = context->active_include[context->include_index];
		context->include_index++;
		goto top;
	    }
a3963 2
/*    context->extra_tags = dtd->tags + dtd->number_of_tags; */
    context->current_tag = context->slashedtag = NULL;
a3964 1
    context->kanji_buf = '\0';
a3966 1
    context->no_lynx_specialcodes = NO;	/* special codes normally generated */
a4003 1
    context->active_include = NULL;
d4009 1
a4009 1
#ifdef USE_PRETTYSRC
d4012 2
a4013 3
	mark_htext_as_source = TRUE;
	SGML_string(context,
		    "<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
d4017 1
a4017 1
	context->seen_nonwhite_in_junk_tag = FALSE;
a4134 15
PRIVATE int IS_SJIS_STR ARGS1(CONST unsigned char *, str)
{
    CONST unsigned char *s;
    unsigned char ch;
    int is_sjis = 0;

    s = str;
    while ((ch = *s++) != '\0') {
	if (ch & 0x80)
	    if (IS_SJIS(ch, *s, is_sjis))
		return 1;
    }
    return 0;
}

d4140 2
a4141 2
    HI -= UCH((HI <= 0x9F) ? 0x71 : 0xB1);
    HI = UCH((HI << 1) + 1);
d4145 1
a4145 1
	LO -= UCH(0x7D);
d4148 1
a4148 1
	LO -= UCH(0x1F);
d4161 1
a4161 1
	LO += UCH(0x1F);
d4163 1
a4163 1
	LO += UCH(0x7D);
d4167 1
a4167 1
    HI = UCH(((HI - 0x21) >> 1) + 0x81);
d4169 1
a4169 1
	HI += UCH(0x40);
d4180 2
a4181 3
    if (HI == 0x8E)
	JISx0201TO0208_EUC(HI, LO, &HI, &LO);
    JIS_TO_SJIS1(UCH(HI & 0x7F), UCH(LO & 0x7F), SJCODE);
d4192 2
a4193 2
    JISx0201TO0208_EUC(0x8E, I, OHI, OLO);
    JIS_TO_SJIS1(UCH(*OHI & 0x7F), UCH(*OLO & 0x7F), SJCODE);
d4216 1
a4216 2
    in_sjis = IS_SJIS_STR(src);
    for (sp = src, dp = dst; (hi = sp[0]) != '\0';) {
d4219 1
a4219 1
	    SJIS_TO_JIS1(hi, lo, dp);
d4224 1
a4224 1
	} else
d4226 1
d4241 1
a4241 1
		JIS_TO_SJIS1(UCH(sp[0] & 0x7F), UCH(sp[1] & 0x7F), dp);
d4255 1
a4255 3
#define Strcpy(a,b)	(strcpy((char*)a,(CONST char*)b),&a[strlen((CONST char*)a)])

PUBLIC unsigned char *EUC_TO_JIS ARGS4(
d4265 1
a4265 1
    int is_JIS = 0;
d4267 1
a4267 1
    while ((cch = *sp++) != '\0') {
a4268 7
	    if (!IS_EUC(cch, *sp)) {
		if (cch == 0xA0 && is_JIS)	/* ignore NBSP */
		    continue;
		is_JIS++;
		*dp++ = cch;
		continue;
	    }
d4270 4
a4273 2
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toK);
d4276 2
a4277 2
		*dp++ = UCH(cch & ~0x80);
		*dp++ = UCH(*sp++ & ~0x80);
d4281 5
a4285 2
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toA);
d4290 5
a4294 2
    if (kana_mode)
	dp = Strcpy(dp, toA);
d4301 1
a4301 32
#define	IS_JIS7(c1,c2)	(0x20<(c1)&&(c1)<0x7F && 0x20<(c2)&&(c2)<0x7F)
#define SO		('N'-0x40)
#define SI		('O'-0x40)

PUBLIC int repair_JIS = 0;

PRIVATE CONST unsigned char *repairJIStoEUC ARGS2(
	CONST unsigned char *,	src,
	unsigned char **,	dstp)
{
    CONST unsigned char *s;
    unsigned char *d, ch1, ch2;

    d = *dstp;
    s = src;
    while ((ch1 = s[0]) && (ch2 = s[1])) {
	s += 2;
	if (ch1 == '(')
	    if (ch2 == 'B' || ch2 == 'J') {
		*dstp = d;
		return s;
	    }
	if (!IS_JIS7(ch1, ch2))
	    return 0;

	*d++ = UCH(0x80 | ch1);
	*d++ = UCH(0x80 | ch2);
    }
    return 0;
}

PUBLIC unsigned char *TO_EUC ARGS2(
d4306 1
a4306 2
    register unsigned char c, jis_stat;
    unsigned char *d;
a4308 3
    static int nje;
    int n8bits;
    int is_JIS;
a4309 2
    nje++;
    n8bits = 0;
a4314 2
    in_sjis = IS_SJIS_STR(jis);
    is_JIS = 0;
d4316 1
a4316 15
    while ((c = *s++) != '\0') {
	if (c == 0x80)
	    continue;		/* ignore it */
	if (c == 0xA0 && is_JIS)
	    continue;		/* ignore Non-breaking space */

	if (c == to2B && jis_stat == 0 && repair_JIS) {
	    if (*s == 'B' || *s == '@@') {
		CONST unsigned char *ts;
		if ((ts = repairJIStoEUC(s + 1, &d)) != NULL) {
		    s = ts;
		    continue;
		}
	    }
	}
d4319 1
a4319 1
		if ((s[1] == 'B') || (s[1] == '@@')) {
d4322 4
a4325 1
		    is_JIS++;
d4328 8
a4335 6
		jis_stat = 0;
	    } else if (*s == to1B) {
		jis_stat = 0;
		if ((s[1] == 'B') || (s[1] == 'J') || (s[1] == 'H')) {
		    s += 2;
		    continue;
a4336 2
	    } else if (*s == ',') {	/* MULE */
		jis_stat = 0;
d4339 1
a4339 4
	if (c & 0x80)
	    n8bits++;

	if (IS_SJIS(c, *s, in_sjis)) {
a4342 13
	    is_JIS++;
	} else if (jis_stat) {
	    if (c <= 0x20 || 0x7F <= c) {
		*d++ = c;
		if (c == '\n')
		    jis_stat = 0;
	    } else {
		if (IS_JIS7(c, *s)) {
		    *d++ = jis_stat | c;
		    *d++ = jis_stat | *s++;
		} else
		    *d++ = c;
	    }
d4344 2
a4345 1
	    if (n8bits == 0 && (c == SI || c == SO)) {
a4354 24
#define non94(ch) ((ch) <= 0x20 || (ch) == 0x7F)

PRIVATE int is_EUC_JP ARGS1(unsigned char *, euc)
{
    unsigned char *cp;
    int ch1, ch2;

    for (cp = euc; (ch1 = *cp) != '\0'; cp++) {
	if (ch1 & 0x80) {
	    ch2 = cp[1] & 0xFF;
	    if ((ch2 & 0x80) == 0) {
		/* sv1log("NOT_EUC1[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    if (non94(ch1 & 0x7F) || non94(ch2 & 0x7F)) {
		/* sv1log("NOT_EUC2[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    cp++;
	}
    }
    return 1;
}

d4361 5
a4365 3
    euc = malloc(strlen((CONST char *) any) + 1);
#ifdef CJK_EX
    if (!euc)
d4367 1
a4367 1
#endif
d4369 2
a4370 5
    if (is_EUC_JP(euc))
	EUC_TO_SJIS(euc, sjis);
    else
	strcpy((char *) sjis, (CONST char *) any);
    free(euc);
d4379 1
a4379 2
    if (any[0] == 0) {
	jis[0] = 0;
d4381 3
a4383 4
    }
    euc = malloc(strlen((CONST char *) any) + 1);
#ifdef CJK_EX
    if (!euc)
d4385 1
a4385 1
#endif
a4386 1
    is_EUC_JP(euc);
d4388 1
a4388 2

    free(euc);
@

