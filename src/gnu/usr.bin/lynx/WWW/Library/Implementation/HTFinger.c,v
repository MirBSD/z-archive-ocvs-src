head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.07.15.18.16.33;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.26;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.55;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.19;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.47;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.09;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.46.11;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@automatic merge of lynx-current
@
text
@/*			FINGER ACCESS				HTFinger.c
 *			=============
 * Authors:
 *  ARB  Andrew Brooks
 *
 * History:
 *	21 Apr 94   First version (ARB, from HTNews.c by TBL)
 *	12 Mar 96   Made the URL and command buffering secure from
 *		     stack modifications, beautified the HTLoadFinger()
 *		     and response() functions, and added support for the
 *		     following URL formats for sending a "", "/w",
 *		     "username[@@host]", or "/w username[@@host]" command
 *		     to the server:
 *			finger://host
 *			finger://host/
 *			finger://host/%2fw
 *			finger://host/%2fw%20username[@@host]
 *			finger://host/w/username[@@host]
 *			finger://host/username[@@host]
 *			finger://host/username[@@host]/w
 *			finger://username@@host
 *			finger://username@@host/
 *			finger://username@@host/w
 *	15 Mar 96   Added support for port 79 gtype 0 gopher URLs
 *		     relayed from HTLoadGopher. - FM
 */

#include <HTUtils.h>

#ifndef DISABLE_FINGER

#include <HTAlert.h>
#include <HTML.h>
#include <HTParse.h>
#include <HTFormat.h>
#include <HTTCP.h>
#include <HTString.h>
#include <HTFinger.h>

#include <LYUtils.h>
#include <LYLeaks.h>

#define FINGER_PORT 79		/* See rfc742 */
#define BIG 1024		/* Bug */

#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)
#define NEXT_CHAR HTGetCharacter()

/*	Module-wide variables
*/
static int finger_fd;		/* Socket for FingerHost */

struct _HTStructured {
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
};

static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */

/*	Initialisation for this module
 *	------------------------------
 */
static BOOL initialized = NO;
static BOOL initialize(void)
{
    finger_fd = -1;		/* Disconnected */
    return YES;
}

/*	Start anchor element
 *	--------------------
 */
static void start_anchor(const char *href)
{
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];

    {
	int i;

	for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	    present[i] = (BOOL) (i == HTML_A_HREF);
    }
    ((const char **) value)[HTML_A_HREF] = href;
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);

}

/*	Send Finger Command line to remote host & Check Response
 *	--------------------------------------------------------
 *
 * On entry,
 *	command	points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is a Finger status.
 */

static int response(char *command,
		    char *sitename,
		    HTParentAnchor *anAnchor,
		    HTFormat format_out,
		    HTStream *sink)
{
    int status;
    int length = strlen(command);
    int ch, i;
    char line[BIG], *l, *cmd = NULL;
    char *p = line, *href = NULL;

    if (length == 0)
	return (-1);

    /* Set up buffering.
     */
    HTInitInput(finger_fd);

    /* Send the command.
     */
    CTRACE((tfp, "HTFinger command to be sent: %s", command));
    status = NETWRITE(finger_fd, (char *) command, length);
    if (status < 0) {
	CTRACE((tfp, "HTFinger: Unable to send command. Disconnecting.\n"));
	NETCLOSE(finger_fd);
	finger_fd = -1;
	return status;
    }
    /* if bad status */
    /* Make a hypertext object with an anchor list.
     */
    target = HTML_new(anAnchor, format_out, sink);
    targetClass = *target->isa;	/* Copy routine entry points */

    /* Create the results report.
     */
    CTRACE((tfp, "HTFinger: Reading finger information\n"));
    START(HTML_HTML);
    PUTC('\n');
    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    PUTS("Finger server on ");
    PUTS(sitename);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_BODY);
    PUTC('\n');
    START(HTML_H1);
    PUTS("Finger server on ");
    START(HTML_EM);
    PUTS(sitename);
    END(HTML_EM);
    PUTS(": ");
    if (command) {
	StrAllocCopy(cmd, command);
    } else {
	StrAllocCopy(cmd, "");
    }
    for (i = (strlen(cmd) - 1); i >= 0; i--) {
	if (cmd[i] == LF || cmd[i] == CR) {
	    cmd[i] = '\0';
	} else {
	    break;
	}
    }
    PUTS(cmd);
    FREE(cmd);
    END(HTML_H1);
    PUTC('\n');
    START(HTML_PRE);

    while ((ch = NEXT_CHAR) != EOF) {

	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    goto end_html;
	}

	if (ch != LF) {
	    *p = (char) ch;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
		p++;
	    }
	} else {
	    *p = '\0';		/* Terminate line */
	    /*
	     * OK we now have a line.
	     * Load it as 'l' and parse it.
	     */
	    p = l = line;
	    while (*l) {
		if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
		    strncmp(l, "snews://", 8) &&
		    strncmp(l, "nntp://", 7) &&
		    strncmp(l, "snewspost:", 10) &&
		    strncmp(l, "snewsreply:", 11) &&
		    strncmp(l, "newspost:", 9) &&
		    strncmp(l, "newsreply:", 10) &&
		    strncmp(l, "ftp://", 6) &&
		    strncmp(l, "file:/", 6) &&
		    strncmp(l, "finger://", 9) &&
		    strncmp(l, "http://", 7) &&
		    strncmp(l, "https://", 8) &&
		    strncmp(l, "wais://", 7) &&
		    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
		    strncmp(l, "cso://", 6) &&
		    strncmp(l, "gopher://", 9))
		    PUTC(*l++);
		else {
		    StrAllocCopy(href, l);
		    start_anchor(strtok(href, " \r\n\t,>)\""));
		    while (*l && !strchr(" \r\n\t,>)\"", *l))
			PUTC(*l++);
		    END(HTML_A);
		    FREE(href);
		}
	    }
	    PUTC('\n');
	}
    }
    NETCLOSE(finger_fd);
    finger_fd = -1;

  end_html:
    END(HTML_PRE);
    PUTC('\n');
    END(HTML_BODY);
    PUTC('\n');
    END(HTML_HTML);
    PUTC('\n');
    FREE_TARGET;
    return (0);
}

/*		Load by name					HTLoadFinger
 *		============
 */
int HTLoadFinger(const char *arg,
		 HTParentAnchor *anAnchor,
		 HTFormat format_out,
		 HTStream *stream)
{
    char *username, *sitename, *colon;	/* Fields extracted from URL */
    char *slash, *at_sign;	/* Fields extracted from URL */
    char *command, *str, *param;	/* Buffers */
    int port;			/* Port number from URL */
    int status;			/* tcp return */
    int result = HT_LOADED;
    BOOL IsGopherURL = FALSE;
    const char *p1 = arg;

    CTRACE((tfp, "HTFinger: Looking for %s\n", (arg ? arg : "NULL")));

    if (!(arg && *arg)) {
	HTAlert(COULD_NOT_LOAD_DATA);
	return HT_NOT_LOADED;	/* Ignore if no name */
    }

    if (!initialized)
	initialized = initialize();
    if (!initialized) {
	HTAlert(gettext("Could not set up finger connection."));
	return HT_NOT_LOADED;	/* FAIL */
    }

    /*  Set up the host and command fields.
     */
    if (!strncasecomp(arg, "finger://", 9)) {
	p1 = arg + 9;		/* Skip "finger://" prefix */
    } else if (!strncasecomp(arg, "gopher://", 9)) {
	p1 = arg + 9;		/* Skip "gopher://" prefix */
	IsGopherURL = TRUE;
    }

    param = 0;
    sitename = StrAllocCopy(param, p1);
    if (param == 0) {
	HTAlert(COULD_NOT_LOAD_DATA);
	return HT_NOT_LOADED;
    } else if ((slash = strchr(sitename, '/')) != NULL) {
	*slash++ = '\0';
	HTUnEscape(slash);
	if (IsGopherURL) {
	    if (*slash != '0') {
		HTAlert(COULD_NOT_LOAD_DATA);
		return HT_NOT_LOADED;	/* FAIL */
	    }
	    *slash++ = '\0';
	}
    }

    if ((at_sign = strchr(sitename, '@@')) != NULL) {
	if (IsGopherURL) {
	    HTAlert(COULD_NOT_LOAD_DATA);
	    return HT_NOT_LOADED;	/* FAIL */
	} else {
	    *at_sign++ = '\0';
	    username = sitename;
	    sitename = at_sign;
	    HTUnEscape(username);
	}
    } else if (slash) {
	username = slash;
    } else {
	username = "";
    }

    if (*sitename == '\0') {
	HTAlert(gettext("Could not load data (no sitename in finger URL)"));
	result = HT_NOT_LOADED;	/* Ignore if no name */
    } else if ((colon = strchr(sitename, ':')) != NULL) {
	*colon++ = '\0';
	port = atoi(colon);
	if (port != 79) {
	    HTAlert(gettext("Invalid port number - will only use port 79!"));
	    result = HT_NOT_LOADED;	/* Ignore if wrong port */
	}
    }

    if (result == HT_LOADED) {
	/* Load the string for making a connection/
	 */
	str = 0;
	HTSprintf0(&str, "lose://%s/", sitename);

	/* Load the command for the finger server.
	 */
	command = 0;
	if (at_sign && slash) {
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
	} else if (at_sign) {
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	} else if (*username == '/') {
	    if ((slash = strchr((username + 1), '/')) != NULL) {
		*slash = ' ';
	    }
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username + 1) == '/') {
	    if (*username + 2 != '\0') {
		*(username + 1) = ' ';
	    } else {
		*(username + 1) = '\0';
	    }
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username + 1) == '\0') {
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((slash = strchr(username, '/')) != NULL) {
	    *slash++ = '\0';
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
	} else {
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	}

	/* Now, let's get a stream setup up from the FingerHost:
	 * CONNECTING to finger host
	 */
	CTRACE((tfp, "HTFinger: doing HTDoConnect on '%s'\n", str));
	status = HTDoConnect(str, "finger", FINGER_PORT, &finger_fd);
	CTRACE((tfp, "HTFinger: Done DoConnect; status %d\n", status));

	if (status == HT_INTERRUPTED) {
	    /* Interrupt cleanly */
	    CTRACE((tfp,
		    "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	    HTProgress(CONNECTION_INTERRUPTED);
	    result = HT_NOT_LOADED;
	} else if (status < 0) {
	    NETCLOSE(finger_fd);
	    finger_fd = -1;
	    CTRACE((tfp, "HTFinger: Unable to connect to finger host.\n"));
	    HTAlert(gettext("Could not access finger host."));
	    result = HT_NOT_LOADED;	/* FAIL */
	} else {
	    CTRACE((tfp, "HTFinger: Connected to finger host '%s'.\n", str));

	    /* Send the command, and process response if successful.
	     */
	    if (response(command, sitename, anAnchor, format_out, stream) != 0) {
		HTAlert(gettext("No response from finger server."));
		result = HT_NOT_LOADED;
	    }
	}
	FREE(str);
	FREE(command);
    }
    FREE(param);
    return result;
}

#ifdef GLOBALDEF_IS_MACRO
#define _HTFINGER_C_1_INIT { "finger", HTLoadFinger, NULL }
GLOBALDEF(HTProtocol, HTFinger, _HTFINGER_C_1_INIT);
#else
GLOBALDEF HTProtocol HTFinger =
{"finger", HTLoadFinger, NULL};
#endif /* GLOBALDEF_IS_MACRO */

#endif /* not DISABLE_FINGER */
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 25
a26 25
**			=============
** Authors:
**  ARB  Andrew Brooks
**
** History:
**	21 Apr 94   First version (ARB, from HTNews.c by TBL)
**	12 Mar 96   Made the URL and command buffering secure from
**		     stack modifications, beautified the HTLoadFinger()
**		     and response() functions, and added support for the
**		     following URL formats for sending a "", "/w",
**		     "username[@@host]", or "/w username[@@host]" command
**		     to the server:
**			finger://host
**			finger://host/
**			finger://host/%2fw
**			finger://host/%2fw%20username[@@host]
**			finger://host/w/username[@@host]
**			finger://host/username[@@host]
**			finger://host/username[@@host]/w
**			finger://username@@host
**			finger://username@@host/
**			finger://username@@host/w
**	15 Mar 96   Added support for port 79 gtype 0 gopher URLs
**		     relayed from HTLoadGopher. - FM
*/
a52 1

d55 1
a55 1
static int finger_fd;				/* Socket for FingerHost */
d58 2
a59 2
	const HTStructuredClass * isa;		/* For gopher streams */
	/* ... */
d62 2
a63 2
static HTStructured * target;			/* The output sink */
static HTStructuredClass targetClass;		/* Copy of fn addresses */
d66 2
a67 2
**	------------------------------
*/
d69 1
a69 1
static BOOL initialize (void)
d71 2
a72 2
  finger_fd = -1;		/* Disconnected */
  return YES;
a74 2


d76 3
a78 3
**	--------------------
*/
static void start_anchor (const char *   href)
d80 2
a81 2
    BOOL		present[HTML_A_ATTRIBUTES];
    const char*		value[HTML_A_ATTRIBUTES];
d85 3
a87 2
	for(i=0; i<HTML_A_ATTRIBUTES; i++)
	    present[i] = (BOOL) (i==HTML_A_HREF);
d89 3
a91 3
    ((const char **)value)[HTML_A_HREF] = href;
    (*targetClass.start_element)(target, HTML_A, present,
				 (const char **)value, -1, 0);
d96 15
a110 17
**	--------------------------------------------------------
**
** On entry,
**	command	points to the command to be sent, including CRLF, or is null
**		pointer if no command to be sent.
** On exit,
**	Negative status indicates transmission error, socket closed.
**	Positive status is a Finger status.
*/


static int response (
	char *			command,
	char *			sitename,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d115 2
a116 2
    char line[BIG], *l, *cmd=NULL;
    char *p = line, *href=NULL;
d119 1
a119 1
	return(-1);
d122 1
a122 1
    */
d126 1
a126 1
    */
d128 1
a128 1
    status = NETWRITE(finger_fd, (char *)command, length);
d134 2
a135 2
    } /* if bad status */

d137 1
a137 1
    */
d142 2
a143 2
    */
    CTRACE((tfp,"HTFinger: Reading finger information\n"));
d181 1
a181 1
    while ((ch=NEXT_CHAR) != EOF) {
d184 3
a186 2
	    CTRACE((tfp, "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress (CONNECTION_INTERRUPTED);
d191 2
a192 2
	    *p = (char) ch;      /* Put character in line */
	    if (p < &line[BIG-1]) {
d235 1
a235 1
end_html:
d243 1
a243 1
    return(0);
a245 1

d247 6
a252 7
**		============
*/
int HTLoadFinger (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		stream)
d255 1
a255 1
    char *slash, *at_sign;		/* Fields extracted from URL */
d257 2
a258 2
    int port;				/* Port number from URL */
    int status;				/* tcp return */
d261 1
a261 1
    const char * p1 = arg;
d267 1
a267 1
	return HT_NOT_LOADED;			/* Ignore if no name */
d273 1
a273 1
	HTAlert (gettext("Could not set up finger connection."));
d278 1
a278 1
    */
d280 1
a280 1
	p1 = arg + 9;  /* Skip "finger://" prefix */
d282 1
a282 1
	p1 = arg + 9;  /* Skip "gopher://" prefix */
d321 1
a321 1
	result = HT_NOT_LOADED;		/* Ignore if no name */
d333 1
a333 1
	*/
d338 1
a338 1
	*/
d349 1
a349 1
	    if ((slash = strchr((username+1), '/')) != NULL) {
d354 3
a356 3
		   *(username+1) == '/') {
	    if (*username+2 != '\0') {
		*(username+1) = ' ';
d358 1
a358 1
		*(username+1) = '\0';
d362 1
a362 1
		   *(username+1) == '\0') {
d376 2
a377 2
	** CONNECTING to finger host
	*/
d384 3
a386 2
	    CTRACE((tfp, "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	    HTProgress (CONNECTION_INTERRUPTED);
d398 1
a398 1
	    */
d413 1
a413 1
GLOBALDEF (HTProtocol, HTFinger, _HTFINGER_C_1_INIT);
d415 2
a416 1
GLOBALDEF HTProtocol HTFinger = { "finger", HTLoadFinger, NULL };
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d56 1
a56 1
PRIVATE int finger_fd;				/* Socket for FingerHost */
d59 1
a59 1
	CONST HTStructuredClass * isa;		/* For gopher streams */
d63 2
a64 2
PRIVATE HTStructured * target;			/* The output sink */
PRIVATE HTStructuredClass targetClass;		/* Copy of fn addresses */
d69 2
a70 2
PRIVATE BOOL initialized = NO;
PRIVATE BOOL initialize NOARGS
d81 1
a81 1
PRIVATE void start_anchor ARGS1(CONST char *,  href)
d84 1
a84 1
    CONST char*		value[HTML_A_ATTRIBUTES];
d91 1
a91 1
    ((CONST char **)value)[HTML_A_HREF] = href;
d93 1
a93 1
				 (CONST char **)value, -1, 0);
d109 6
a114 6
PRIVATE int response ARGS5(
	char *,			command,
	char *,			sitename,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d253 5
a257 5
PUBLIC int HTLoadFinger ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		stream)
d266 1
a266 1
    CONST char * p1 = arg;
d419 1
a419 1
GLOBALDEF PUBLIC HTProtocol HTFinger = { "finger", HTLoadFinger, NULL };
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d56 1
a56 1
PRIVATE int s;					/* Socket for FingerHost */
d72 1
a72 1
  s = -1;		/* Disconnected */
d89 1
a89 1
	    present[i] = (i==HTML_A_HREF);
d110 1
a110 1
	CONST char *,		command,
d127 1
a127 1
    HTInitInput(s);
d131 2
a132 2
    CTRACE(tfp, "HTFinger command to be sent: %s", command);
    status = NETWRITE(s, (char *)command, length);
d134 3
a136 3
	CTRACE(tfp, "HTFinger: Unable to send command. Disconnecting.\n");
	NETCLOSE(s);
	s = -1;
d147 1
a147 1
    CTRACE(tfp,"HTFinger: Reading finger information\n");
d188 1
a188 1
	    CTRACE(tfp, "HTFinger: Interrupted in HTGetCharacter, apparently.\n");
d194 1
a194 1
	    *p = ch;		/* Put character in line */
d206 1
a206 1
		if (strncmp(l, "news:", 5) &&
d219 1
a219 1
		    strncmp(l, "mailto:", 7) &&
d235 2
a236 2
    NETCLOSE(s);
    s = -1;
d261 1
a261 1
    char *command, *str;		/* Buffers */
d264 3
d268 1
a268 1
    CTRACE(tfp, "HTFinger: Looking for %s\n", (arg ? arg : "NULL"));
a281 4
  {
    CONST char * p1=arg;
    BOOL IsGopherURL = FALSE;

a289 1
    sitename = (char *)p1;
d291 6
a296 1
    if ((slash = strchr(sitename, '/')) != NULL) {
d307 1
d312 5
a317 4
	*at_sign++ = '\0';
	username = sitename;
	sitename = at_sign;
	HTUnEscape(username);
d326 2
a327 4
	return HT_NOT_LOADED;		/* Ignore if no name */
    }

    if ((colon = strchr(sitename, ':')) != NULL) {
d332 1
a332 1
	    return HT_NOT_LOADED;	/* Ignore if wrong port */
d336 40
a375 11
    /* Load the string for making a connection/
    */
    str = 0;
    HTSprintf0(&str, "lose://%s/", sitename);

    /* Load the command for the finger server.
    */
    command = 0;
    if (at_sign && slash) {
	if (*slash == 'w' || *slash == 'W') {
	    HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
d379 19
a397 11
    } else if (at_sign) {
	HTSprintf0(&command, "%s%c%c", username, CR, LF);
    } else if (*username == '/') {
	if ((slash = strchr((username+1), '/')) != NULL) {
	    *slash = ' ';
	}
	HTSprintf0(&command, "%s%c%c", username, CR, LF);
    } else if ((*username == 'w' || *username == 'W') &&
	       *(username+1) == '/') {
	if (*username+2 != '\0') {
	    *(username+1) = ' ';
d399 8
a406 12
	    *(username+1) = '\0';
	}
	HTSprintf0(&command, "/%s%c%c", username, CR, LF);
    } else if ((*username == 'w' || *username == 'W') &&
	       *(username+1) == '\0') {
	HTSprintf0(&command, "/%s%c%c", username, CR, LF);
    } else if ((slash = strchr(username, '/')) != NULL) {
	*slash++ = '\0';
	if (*slash == 'w' || *slash == 'W') {
	    HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	} else {
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
a407 16
    } else {
	HTSprintf0(&command, "%s%c%c", username, CR, LF);
    }
  } /* scope of p1 */

    /* Now, let's get a stream setup up from the FingerHost:
    ** CONNECTING to finger host
    */
    CTRACE(tfp, "HTFinger: doing HTDoConnect on '%s'\n", str);
    status = HTDoConnect(str, "finger", FINGER_PORT, &s);
    CTRACE(tfp, "HTFinger: Done DoConnect; status %d\n", status);

    if (status == HT_INTERRUPTED) {
	/* Interrupt cleanly */
	CTRACE(tfp, "HTFinger: Interrupted on connect; recovering cleanly.\n");
	HTProgress (CONNECTION_INTERRUPTED);
a409 1
	return HT_NOT_LOADED;
d411 2
a412 22
    if (status < 0) {
	NETCLOSE(s);
	s = -1;
	CTRACE(tfp, "HTFinger: Unable to connect to finger host.\n");
	HTAlert(gettext("Could not access finger host."));
	FREE(str);
	FREE(command);
	return HT_NOT_LOADED;	/* FAIL */
    }
    CTRACE(tfp, "HTFinger: Connected to finger host '%s'.\n", str);
    FREE(str);

    /* Send the command, and process response if successful.
    */
    if (response(command, sitename, anAnchor, format_out, stream) != 0) {
	HTAlert(gettext("No response from finger server."));
	FREE(command);
	return HT_NOT_LOADED;
    }

    FREE(command);
    return HT_LOADED;
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 25
a26 25
 *			=============
 * Authors:
 *  ARB  Andrew Brooks
 *
 * History:
 *	21 Apr 94   First version (ARB, from HTNews.c by TBL)
 *	12 Mar 96   Made the URL and command buffering secure from
 *		     stack modifications, beautified the HTLoadFinger()
 *		     and response() functions, and added support for the
 *		     following URL formats for sending a "", "/w",
 *		     "username[@@host]", or "/w username[@@host]" command
 *		     to the server:
 *			finger://host
 *			finger://host/
 *			finger://host/%2fw
 *			finger://host/%2fw%20username[@@host]
 *			finger://host/w/username[@@host]
 *			finger://host/username[@@host]
 *			finger://host/username[@@host]/w
 *			finger://username@@host
 *			finger://username@@host/
 *			finger://username@@host/w
 *	15 Mar 96   Added support for port 79 gtype 0 gopher URLs
 *		     relayed from HTLoadGopher. - FM
 */
d53 1
d56 1
a56 1
static int finger_fd;		/* Socket for FingerHost */
d59 2
a60 2
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
d63 2
a64 2
static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */
d67 4
a70 4
 *	------------------------------
 */
static BOOL initialized = NO;
static BOOL initialize(void)
d72 2
a73 2
    finger_fd = -1;		/* Disconnected */
    return YES;
d76 2
d79 3
a81 3
 *	--------------------
 */
static void start_anchor(const char *href)
d83 2
a84 2
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];
d88 2
a89 3

	for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	    present[i] = (BOOL) (i == HTML_A_HREF);
d91 3
a93 3
    ((const char **) value)[HTML_A_HREF] = href;
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);
d98 17
a114 15
 *	--------------------------------------------------------
 *
 * On entry,
 *	command	points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is a Finger status.
 */

static int response(char *command,
		    char *sitename,
		    HTParentAnchor *anAnchor,
		    HTFormat format_out,
		    HTStream *sink)
d119 2
a120 2
    char line[BIG], *l, *cmd = NULL;
    char *p = line, *href = NULL;
d123 1
a123 1
	return (-1);
d126 2
a127 2
     */
    HTInitInput(finger_fd);
d130 3
a132 3
     */
    CTRACE((tfp, "HTFinger command to be sent: %s", command));
    status = NETWRITE(finger_fd, (char *) command, length);
d134 3
a136 3
	CTRACE((tfp, "HTFinger: Unable to send command. Disconnecting.\n"));
	NETCLOSE(finger_fd);
	finger_fd = -1;
d138 2
a139 2
    }
    /* if bad status */
d141 1
a141 1
     */
d146 2
a147 2
     */
    CTRACE((tfp, "HTFinger: Reading finger information\n"));
d185 1
a185 1
    while ((ch = NEXT_CHAR) != EOF) {
d188 2
a189 3
	    CTRACE((tfp,
		    "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
d194 2
a195 2
	    *p = (char) ch;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
d206 1
a206 1
		if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d219 1
a219 1
		    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d235 2
a236 2
    NETCLOSE(finger_fd);
    finger_fd = -1;
d238 1
a238 1
  end_html:
d246 1
a246 1
    return (0);
d249 1
d251 7
a257 6
 *		============
 */
int HTLoadFinger(const char *arg,
		 HTParentAnchor *anAnchor,
		 HTFormat format_out,
		 HTStream *stream)
d260 4
a263 7
    char *slash, *at_sign;	/* Fields extracted from URL */
    char *command, *str, *param;	/* Buffers */
    int port;			/* Port number from URL */
    int status;			/* tcp return */
    int result = HT_LOADED;
    BOOL IsGopherURL = FALSE;
    const char *p1 = arg;
d265 1
a265 1
    CTRACE((tfp, "HTFinger: Looking for %s\n", (arg ? arg : "NULL")));
d269 1
a269 1
	return HT_NOT_LOADED;	/* Ignore if no name */
d275 1
a275 1
	HTAlert(gettext("Could not set up finger connection."));
d279 4
d284 1
a284 1
     */
d286 1
a286 1
	p1 = arg + 9;		/* Skip "finger://" prefix */
d288 1
a288 1
	p1 = arg + 9;		/* Skip "gopher://" prefix */
d291 1
d293 1
a293 6
    param = 0;
    sitename = StrAllocCopy(param, p1);
    if (param == 0) {
	HTAlert(COULD_NOT_LOAD_DATA);
	return HT_NOT_LOADED;
    } else if ((slash = strchr(sitename, '/')) != NULL) {
a303 1

a307 5
	} else {
	    *at_sign++ = '\0';
	    username = sitename;
	    sitename = at_sign;
	    HTUnEscape(username);
d309 4
d321 4
a324 2
	result = HT_NOT_LOADED;	/* Ignore if no name */
    } else if ((colon = strchr(sitename, ':')) != NULL) {
d329 1
a329 1
	    result = HT_NOT_LOADED;	/* Ignore if wrong port */
d333 12
a344 16
    if (result == HT_LOADED) {
	/* Load the string for making a connection/
	 */
	str = 0;
	HTSprintf0(&str, "lose://%s/", sitename);

	/* Load the command for the finger server.
	 */
	command = 0;
	if (at_sign && slash) {
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
	} else if (at_sign) {
d346 23
a368 23
	} else if (*username == '/') {
	    if ((slash = strchr((username + 1), '/')) != NULL) {
		*slash = ' ';
	    }
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username + 1) == '/') {
	    if (*username + 2 != '\0') {
		*(username + 1) = ' ';
	    } else {
		*(username + 1) = '\0';
	    }
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username + 1) == '\0') {
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((slash = strchr(username, '/')) != NULL) {
	    *slash++ = '\0';
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
d372 4
d377 26
a402 21
	/* Now, let's get a stream setup up from the FingerHost:
	 * CONNECTING to finger host
	 */
	CTRACE((tfp, "HTFinger: doing HTDoConnect on '%s'\n", str));
	status = HTDoConnect(str, "finger", FINGER_PORT, &finger_fd);
	CTRACE((tfp, "HTFinger: Done DoConnect; status %d\n", status));

	if (status == HT_INTERRUPTED) {
	    /* Interrupt cleanly */
	    CTRACE((tfp,
		    "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	    HTProgress(CONNECTION_INTERRUPTED);
	    result = HT_NOT_LOADED;
	} else if (status < 0) {
	    NETCLOSE(finger_fd);
	    finger_fd = -1;
	    CTRACE((tfp, "HTFinger: Unable to connect to finger host.\n"));
	    HTAlert(gettext("Could not access finger host."));
	    result = HT_NOT_LOADED;	/* FAIL */
	} else {
	    CTRACE((tfp, "HTFinger: Connected to finger host '%s'.\n", str));
d404 4
a407 8
	    /* Send the command, and process response if successful.
	     */
	    if (response(command, sitename, anAnchor, format_out, stream) != 0) {
		HTAlert(gettext("No response from finger server."));
		result = HT_NOT_LOADED;
	    }
	}
	FREE(str);
d409 1
d411 3
a413 2
    FREE(param);
    return result;
d418 1
a418 1
GLOBALDEF(HTProtocol, HTFinger, _HTFINGER_C_1_INIT);
d420 1
a420 2
GLOBALDEF HTProtocol HTFinger =
{"finger", HTLoadFinger, NULL};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d56 1
a56 1
PRIVATE int finger_fd;				/* Socket for FingerHost */
d72 1
a72 1
  finger_fd = -1;		/* Disconnected */
d89 1
a89 1
	    present[i] = (BOOL) (i==HTML_A_HREF);
d110 1
a110 1
	char *,			command,
d127 1
a127 1
    HTInitInput(finger_fd);
d131 2
a132 2
    CTRACE((tfp, "HTFinger command to be sent: %s", command));
    status = NETWRITE(finger_fd, (char *)command, length);
d134 3
a136 3
	CTRACE((tfp, "HTFinger: Unable to send command. Disconnecting.\n"));
	NETCLOSE(finger_fd);
	finger_fd = -1;
d147 1
a147 1
    CTRACE((tfp,"HTFinger: Reading finger information\n"));
d188 1
a188 1
	    CTRACE((tfp, "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
d194 1
a194 1
	    *p = (char) ch;      /* Put character in line */
d206 1
a206 1
		if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
d219 1
a219 1
		    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d235 2
a236 2
    NETCLOSE(finger_fd);
    finger_fd = -1;
d261 1
a261 1
    char *command, *str, *param;	/* Buffers */
a263 3
    int result = HT_LOADED;
    BOOL IsGopherURL = FALSE;
    CONST char * p1 = arg;
d265 1
a265 1
    CTRACE((tfp, "HTFinger: Looking for %s\n", (arg ? arg : "NULL")));
d279 4
d291 1
d293 1
a293 6
    param = 0;
    sitename = StrAllocCopy(param, p1);
    if (param == 0) {
	HTAlert(COULD_NOT_LOAD_DATA);
	return HT_NOT_LOADED;
    } else if ((slash = strchr(sitename, '/')) != NULL) {
a303 1

a307 5
	} else {
	    *at_sign++ = '\0';
	    username = sitename;
	    sitename = at_sign;
	    HTUnEscape(username);
d309 4
d321 4
a324 2
	result = HT_NOT_LOADED;		/* Ignore if no name */
    } else if ((colon = strchr(sitename, ':')) != NULL) {
d329 1
a329 1
	    result = HT_NOT_LOADED;	/* Ignore if wrong port */
d333 12
a344 16
    if (result == HT_LOADED) {
	/* Load the string for making a connection/
	*/
	str = 0;
	HTSprintf0(&str, "lose://%s/", sitename);

	/* Load the command for the finger server.
	*/
	command = 0;
	if (at_sign && slash) {
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
	} else if (at_sign) {
d346 23
a368 23
	} else if (*username == '/') {
	    if ((slash = strchr((username+1), '/')) != NULL) {
		*slash = ' ';
	    }
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username+1) == '/') {
	    if (*username+2 != '\0') {
		*(username+1) = ' ';
	    } else {
		*(username+1) = '\0';
	    }
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username+1) == '\0') {
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((slash = strchr(username, '/')) != NULL) {
	    *slash++ = '\0';
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
d372 4
d377 26
a402 20
	/* Now, let's get a stream setup up from the FingerHost:
	** CONNECTING to finger host
	*/
	CTRACE((tfp, "HTFinger: doing HTDoConnect on '%s'\n", str));
	status = HTDoConnect(str, "finger", FINGER_PORT, &finger_fd);
	CTRACE((tfp, "HTFinger: Done DoConnect; status %d\n", status));

	if (status == HT_INTERRUPTED) {
	    /* Interrupt cleanly */
	    CTRACE((tfp, "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	    HTProgress (CONNECTION_INTERRUPTED);
	    result = HT_NOT_LOADED;
	} else if (status < 0) {
	    NETCLOSE(finger_fd);
	    finger_fd = -1;
	    CTRACE((tfp, "HTFinger: Unable to connect to finger host.\n"));
	    HTAlert(gettext("Could not access finger host."));
	    result = HT_NOT_LOADED;	/* FAIL */
	} else {
	    CTRACE((tfp, "HTFinger: Connected to finger host '%s'.\n", str));
d404 4
a407 8
	    /* Send the command, and process response if successful.
	    */
	    if (response(command, sitename, anAnchor, format_out, stream) != 0) {
		HTAlert(gettext("No response from finger server."));
		result = HT_NOT_LOADED;
	    }
	}
	FREE(str);
d409 1
d411 3
a413 2
    FREE(param);
    return result;
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d56 1
a56 1
static int finger_fd;				/* Socket for FingerHost */
d59 1
a59 1
	const HTStructuredClass * isa;		/* For gopher streams */
d63 2
a64 2
static HTStructured * target;			/* The output sink */
static HTStructuredClass targetClass;		/* Copy of fn addresses */
d69 2
a70 2
static BOOL initialized = NO;
static BOOL initialize (void)
d81 1
a81 1
static void start_anchor (const char *   href)
d84 1
a84 1
    const char*		value[HTML_A_ATTRIBUTES];
d91 1
a91 1
    ((const char **)value)[HTML_A_HREF] = href;
d93 1
a93 1
				 (const char **)value, -1, 0);
d109 6
a114 6
static int response (
	char *			command,
	char *			sitename,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d253 5
a257 5
int HTLoadFinger (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		stream)
d266 1
a266 1
    const char * p1 = arg;
d419 1
a419 1
GLOBALDEF HTProtocol HTFinger = { "finger", HTLoadFinger, NULL };
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 25
a26 25
 *			=============
 * Authors:
 *  ARB  Andrew Brooks
 *
 * History:
 *	21 Apr 94   First version (ARB, from HTNews.c by TBL)
 *	12 Mar 96   Made the URL and command buffering secure from
 *		     stack modifications, beautified the HTLoadFinger()
 *		     and response() functions, and added support for the
 *		     following URL formats for sending a "", "/w",
 *		     "username[@@host]", or "/w username[@@host]" command
 *		     to the server:
 *			finger://host
 *			finger://host/
 *			finger://host/%2fw
 *			finger://host/%2fw%20username[@@host]
 *			finger://host/w/username[@@host]
 *			finger://host/username[@@host]
 *			finger://host/username[@@host]/w
 *			finger://username@@host
 *			finger://username@@host/
 *			finger://username@@host/w
 *	15 Mar 96   Added support for port 79 gtype 0 gopher URLs
 *		     relayed from HTLoadGopher. - FM
 */
d53 1
d56 1
a56 1
static int finger_fd;		/* Socket for FingerHost */
d59 2
a60 2
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
d63 2
a64 2
static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */
d67 2
a68 2
 *	------------------------------
 */
d70 1
a70 1
static BOOL initialize(void)
d72 2
a73 2
    finger_fd = -1;		/* Disconnected */
    return YES;
d76 2
d79 3
a81 3
 *	--------------------
 */
static void start_anchor(const char *href)
d83 2
a84 2
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];
d88 2
a89 3

	for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	    present[i] = (BOOL) (i == HTML_A_HREF);
d91 3
a93 3
    ((const char **) value)[HTML_A_HREF] = href;
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);
d98 17
a114 15
 *	--------------------------------------------------------
 *
 * On entry,
 *	command	points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is a Finger status.
 */

static int response(char *command,
		    char *sitename,
		    HTParentAnchor *anAnchor,
		    HTFormat format_out,
		    HTStream *sink)
d119 2
a120 2
    char line[BIG], *l, *cmd = NULL;
    char *p = line, *href = NULL;
d123 1
a123 1
	return (-1);
d126 1
a126 1
     */
d130 1
a130 1
     */
d132 1
a132 1
    status = NETWRITE(finger_fd, (char *) command, length);
d138 2
a139 2
    }
    /* if bad status */
d141 1
a141 1
     */
d146 2
a147 2
     */
    CTRACE((tfp, "HTFinger: Reading finger information\n"));
d185 1
a185 1
    while ((ch = NEXT_CHAR) != EOF) {
d188 2
a189 3
	    CTRACE((tfp,
		    "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
d194 2
a195 2
	    *p = (char) ch;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
d238 1
a238 1
  end_html:
d246 1
a246 1
    return (0);
d249 1
d251 7
a257 6
 *		============
 */
int HTLoadFinger(const char *arg,
		 HTParentAnchor *anAnchor,
		 HTFormat format_out,
		 HTStream *stream)
d260 1
a260 1
    char *slash, *at_sign;	/* Fields extracted from URL */
d262 2
a263 2
    int port;			/* Port number from URL */
    int status;			/* tcp return */
d266 1
a266 1
    const char *p1 = arg;
d272 1
a272 1
	return HT_NOT_LOADED;	/* Ignore if no name */
d278 1
a278 1
	HTAlert(gettext("Could not set up finger connection."));
d283 1
a283 1
     */
d285 1
a285 1
	p1 = arg + 9;		/* Skip "finger://" prefix */
d287 1
a287 1
	p1 = arg + 9;		/* Skip "gopher://" prefix */
d326 1
a326 1
	result = HT_NOT_LOADED;	/* Ignore if no name */
d338 1
a338 1
	 */
d343 1
a343 1
	 */
d354 1
a354 1
	    if ((slash = strchr((username + 1), '/')) != NULL) {
d359 3
a361 3
		   *(username + 1) == '/') {
	    if (*username + 2 != '\0') {
		*(username + 1) = ' ';
d363 1
a363 1
		*(username + 1) = '\0';
d367 1
a367 1
		   *(username + 1) == '\0') {
d381 2
a382 2
	 * CONNECTING to finger host
	 */
d389 2
a390 3
	    CTRACE((tfp,
		    "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	    HTProgress(CONNECTION_INTERRUPTED);
d402 1
a402 1
	     */
d417 1
a417 1
GLOBALDEF(HTProtocol, HTFinger, _HTFINGER_C_1_INIT);
d419 1
a419 2
GLOBALDEF HTProtocol HTFinger =
{"finger", HTLoadFinger, NULL};
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d89 1
a89 1
	    present[i] = (BOOL) (i==HTML_A_HREF);
d110 1
a110 1
	char *,			command,
d131 1
a131 1
    CTRACE((tfp, "HTFinger command to be sent: %s", command));
d134 1
a134 1
	CTRACE((tfp, "HTFinger: Unable to send command. Disconnecting.\n"));
d147 1
a147 1
    CTRACE((tfp,"HTFinger: Reading finger information\n"));
d188 1
a188 1
	    CTRACE((tfp, "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
d194 1
a194 1
	    *p = (char) ch;      /* Put character in line */
d265 1
a265 1
    CTRACE((tfp, "HTFinger: Looking for %s\n", (arg ? arg : "NULL")));
d380 1
a380 1
    CTRACE((tfp, "HTFinger: doing HTDoConnect on '%s'\n", str));
d382 1
a382 1
    CTRACE((tfp, "HTFinger: Done DoConnect; status %d\n", status));
d386 1
a386 1
	CTRACE((tfp, "HTFinger: Interrupted on connect; recovering cleanly.\n"));
d395 1
a395 1
	CTRACE((tfp, "HTFinger: Unable to connect to finger host.\n"));
d401 1
a401 1
    CTRACE((tfp, "HTFinger: Connected to finger host '%s'.\n", str));
@

