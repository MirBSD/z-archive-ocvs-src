head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.47;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.10.26.20;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.33;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.26;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.55.42;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.06;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.29.55;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.26.21;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.19.50;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.24;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.14;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.47.01;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.32;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@/*		Manage different file formats			HTFormat.c
 *		=============================
 *
 * Bugs:
 *	Not reentrant.
 *
 *	Assumes the incoming stream is ASCII, rather than a local file
 *	format, and so ALWAYS converts from ASCII on non-ASCII machines.
 *	Therefore, non-ASCII machines can't read local files.
 *
 */

#include <HTUtils.h>

/* Implements:
*/
#include <HTFormat.h>

static float HTMaxSecs = 1e10;	/* No effective limit */

#ifdef UNIX
#ifdef NeXT
#define PRESENT_POSTSCRIPT "open %s; /bin/rm -f %s\n"
#else
#define PRESENT_POSTSCRIPT "(ghostview %s ; /bin/rm -f %s)&\n"
			   /* Full pathname would be better! */
#endif /* NeXT */
#endif /* UNIX */

#include <HTML.h>
#include <HTMLDTD.h>
#include <HText.h>
#include <HTAlert.h>
#include <HTList.h>
#include <HTInit.h>
#include <HTTCP.h>
#include <HTTP.h>
/*	Streams and structured streams which we use:
*/
#include <HTFWriter.h>
#include <HTPlain.h>
#include <SGML.h>
#include <HTMLGen.h>

#include <LYexit.h>
#include <LYUtils.h>
#include <GridText.h>
#include <LYGlobalDefs.h>
#include <LYLeaks.h>

#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif

BOOL HTOutputSource = NO;	/* Flag: shortcut parser to stdout */

#ifdef ORIGINAL
struct _HTStream {
    const HTStreamClass *isa;
    /* ... */
};
#endif /* ORIGINAL */

/* this version used by the NetToText stream */
struct _HTStream {
    const HTStreamClass *isa;
    BOOL had_cr;
    HTStream *sink;
};

/*	Presentation methods
 *	--------------------
 */
HTList *HTPresentations = NULL;
HTPresentation *default_presentation = NULL;

/*
 *	To free off the presentation list.
 */
#ifdef LY_FIND_LEAKS
static void HTFreePresentations(void);
#endif

/*	Define a presentation system command for a content-type
 *	-------------------------------------------------------
 */
void HTSetPresentation(const char *representation,
		       const char *command,
		       const char *testcommand,
		       double quality,
		       double secs,
		       double secs_per_byte,
		       long int maxbytes,
		       AcceptMedia media)
{
    HTPresentation *pres = typecalloc(HTPresentation);

    if (pres == NULL)
	outofmem(__FILE__, "HTSetPresentation");

    pres->rep = HTAtom_for(representation);
    pres->rep_out = WWW_PRESENT;	/* Fixed for now ... :-) */
    pres->converter = HTSaveAndExecute;		/* Fixed for now ...     */
    pres->quality = (float) quality;
    pres->secs = (float) secs;
    pres->secs_per_byte = (float) secs_per_byte;
    pres->maxbytes = maxbytes;
    pres->get_accept = 0;
    pres->accept_opt = media;

    pres->command = NULL;
    StrAllocCopy(pres->command, command);

    pres->testcommand = NULL;
    StrAllocCopy(pres->testcommand, testcommand);

    /*
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     */
    if (!HTPresentations) {
	HTPresentations = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTFreePresentations);
#endif
    }

    if (strcmp(representation, "*") == 0) {
	FREE(default_presentation);
	default_presentation = pres;
    } else {
	HTList_addObject(HTPresentations, pres);
    }
}

/*	Define a built-in function for a content-type
 *	---------------------------------------------
 */
void HTSetConversion(const char *representation_in,
		     const char *representation_out,
		     HTConverter *converter,
		     float quality,
		     float secs,
		     float secs_per_byte,
		     long int maxbytes,
		     AcceptMedia media)
{
    HTPresentation *pres = typecalloc(HTPresentation);

    if (pres == NULL)
	outofmem(__FILE__, "HTSetConversion");

    pres->rep = HTAtom_for(representation_in);
    pres->rep_out = HTAtom_for(representation_out);
    pres->converter = converter;
    pres->command = NULL;
    pres->testcommand = NULL;
    pres->quality = quality;
    pres->secs = secs;
    pres->secs_per_byte = secs_per_byte;
    pres->maxbytes = maxbytes;
    pres->get_accept = TRUE;
    pres->accept_opt = media;

    /*
     * Memory Leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     */
    if (!HTPresentations) {
	HTPresentations = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTFreePresentations);
#endif
    }

    HTList_addObject(HTPresentations, pres);
}

#ifdef LY_FIND_LEAKS
/*
 *	Purpose:	Free the presentation list.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		Made to clean up Lynx's bad leakage.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void HTFreePresentations(void)
{
    HTPresentation *pres = NULL;

    /*
     * Loop through the list.
     */
    while (!HTList_isEmpty(HTPresentations)) {
	/*
	 * Free off each item.  May also need to free off it's items, but not
	 * sure as of yet.
	 */
	pres = (HTPresentation *) HTList_removeLastObject(HTPresentations);
	FREE(pres->command);
	FREE(pres->testcommand);
	FREE(pres);
    }
    /*
     * Free the list itself.
     */
    HTList_delete(HTPresentations);
    HTPresentations = NULL;
}
#endif /* LY_FIND_LEAKS */

/*	File buffering
 *	--------------
 *
 *	The input file is read using the macro which can read from
 *	a socket or a file.
 *	The input buffer size, if large will give greater efficiency and
 *	release the server faster, and if small will save space on PCs etc.
 */
#define INPUT_BUFFER_SIZE 4096	/* Tradeoff */
static char input_buffer[INPUT_BUFFER_SIZE];
static char *input_pointer;
static char *input_limit;
static int input_file_number;

/*	Set up the buffering
 *
 *	These routines are public because they are in fact needed by
 *	many parsers, and on PCs and Macs we should not duplicate
 *	the static buffer area.
 */
void HTInitInput(int file_number)
{
    input_file_number = file_number;
    input_pointer = input_limit = input_buffer;
}

int interrupted_in_htgetcharacter = 0;
int HTGetCharacter(void)
{
    char ch;

    interrupted_in_htgetcharacter = 0;
    do {
	if (input_pointer >= input_limit) {
	    int status = NETREAD(input_file_number,
				 input_buffer, INPUT_BUFFER_SIZE);

	    if (status <= 0) {
		if (status == 0)
		    return EOF;
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetCharacter\n"));
		    interrupted_in_htgetcharacter = 1;
		    return EOF;
		}
		CTRACE((tfp, "HTFormat: File read error %d\n", status));
		return EOF;	/* -1 is returned by UCX
				   at end of HTTP link */
	    }
	    input_pointer = input_buffer;
	    input_limit = input_buffer + status;
	}
	ch = *input_pointer++;
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */

    return FROMASCII(UCH(ch));
}

#ifdef USE_SSL
char HTGetSSLCharacter(void *handle)
{
    char ch;

    interrupted_in_htgetcharacter = 0;
    if (!handle)
	return (char) EOF;
    do {
	if (input_pointer >= input_limit) {
	    int status = SSL_read((SSL *) handle,
				  input_buffer, INPUT_BUFFER_SIZE);

	    if (status <= 0) {
		if (status == 0)
		    return (char) EOF;
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp,
			    "HTFormat: Interrupted in HTGetSSLCharacter\n"));
		    interrupted_in_htgetcharacter = 1;
		    return (char) EOF;
		}
		CTRACE((tfp, "HTFormat: SSL_read error %d\n", status));
		return (char) EOF;	/* -1 is returned by UCX
					   at end of HTTP link */
	    }
	    input_pointer = input_buffer;
	    input_limit = input_buffer + status;
	}
	ch = *input_pointer++;
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */

    return FROMASCII(ch);
}
#endif /* USE_SSL */

/* Match maintype to any MIME type starting with maintype, for example: 
 * image/gif should match image
 */
static int half_match(char *trial_type, char *target)
{
    char *cp = strchr(trial_type, '/');

    /* if no '/' or no '*' */
    if (!cp || *(cp + 1) != '*')
	return 0;

    CTRACE((tfp, "HTFormat: comparing %s and %s for half match\n",
	    trial_type, target));

    /* main type matches */
    if (!strncmp(trial_type, target, (cp - trial_type) - 1))
	return 1;

    return 0;
}

/*
 * Evaluate a deferred mailcap test command, i.e.,. one that substitutes the
 * document's charset or other values in %{name} format.
 */
static BOOL failsMailcap(HTPresentation *pres, HTParentAnchor *anchor)
{
    if (pres->testcommand != 0) {
	if (LYTestMailcapCommand(pres->testcommand,
				 anchor->content_type_params) != 0)
	    return TRUE;
    }
    return FALSE;
}

#define WWW_WILDCARD_REP_OUT HTAtom_for("*")

/*		Look up a presentation
 *		----------------------
 *
 *	If fill_in is NULL, only look for an exact match.
 *	If a wildcard match is made, *fill_in is used to store
 *	a possibly modified presentation, and a pointer to it is
 *	returned.  For an exact match, a pointer to the presentation
 *	in the HTPresentations list is returned.  Returns NULL if
 *	nothing found. - kw
 *
 */
static HTPresentation *HTFindPresentation(HTFormat rep_in,
					  HTFormat rep_out,
					  HTPresentation *fill_in,
					  HTParentAnchor *anchor)
{
    HTAtom *wildcard = NULL;	/* = HTAtom_for("*"); lookup when needed - kw */
    int n;
    int i;
    HTPresentation *pres;
    HTPresentation *match;
    HTPresentation *strong_wildcard_match = 0;
    HTPresentation *weak_wildcard_match = 0;
    HTPresentation *last_default_match = 0;
    HTPresentation *strong_subtype_wildcard_match = 0;

    CTRACE((tfp, "HTFormat: Looking up presentation for %s to %s\n",
	    HTAtom_name(rep_in), HTAtom_name(rep_out)));

    n = HTList_count(HTPresentations);
    for (i = 0; i < n; i++) {
	pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (pres->rep == rep_in) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		CTRACE((tfp, "FindPresentation: found exact match: %s\n",
			HTAtom_name(pres->rep)));
		return pres;

	    } else if (!fill_in) {
		continue;
	    } else {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
		if (pres->rep_out == wildcard) {
		    if (failsMailcap(pres, anchor))
			continue;
		    if (!strong_wildcard_match)
			strong_wildcard_match = pres;
		    /* otherwise use the first one */
		    CTRACE((tfp,
			    "StreamStack: found strong wildcard match: %s\n",
			    HTAtom_name(pres->rep)));
		}
	    }

	} else if (!fill_in) {
	    continue;

	} else if (half_match(HTAtom_name(pres->rep),
			      HTAtom_name(rep_in))) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!strong_subtype_wildcard_match)
		    strong_subtype_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found strong subtype wildcard match: %s\n",
			HTAtom_name(pres->rep)));
	    }
	}

	if (pres->rep == WWW_SOURCE) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!weak_wildcard_match)
		    weak_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found weak wildcard match: %s\n",
			HTAtom_name(pres->rep_out)));

	    } else if (!last_default_match) {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
		if (pres->rep_out == wildcard) {
		    if (failsMailcap(pres, anchor))
			continue;
		    last_default_match = pres;
		    /* otherwise use the first one */
		}
	    }
	}
    }

    match = (strong_subtype_wildcard_match
	     ? strong_subtype_wildcard_match
	     : (strong_wildcard_match
		? strong_wildcard_match
		: (weak_wildcard_match
		   ? weak_wildcard_match
		   : last_default_match)));

    if (match) {
	*fill_in = *match;	/* Specific instance */
	fill_in->rep = rep_in;	/* yuk */
	fill_in->rep_out = rep_out;	/* yuk */
	return fill_in;
    }

    return NULL;
}

/*		Create a filter stack
 *		---------------------
 *
 *	If a wildcard match is made, a temporary HTPresentation
 *	structure is made to hold the destination format while the
 *	new stack is generated. This is just to pass the out format to
 *	MIME so far.  Storing the format of a stream in the stream might
 *	be a lot neater.
 *
 */
HTStream *HTStreamStack(HTFormat rep_in,
			HTFormat rep_out,
			HTStream *sink,
			HTParentAnchor *anchor)
{
    HTPresentation temp;
    HTPresentation *match;
    HTStream *result;

    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s (%s)\n",
	    HTAtom_name(rep_in),
	    HTAtom_name(rep_out),
	    NONNULL(anchor->content_type_params)));

    /* don't return on WWW_SOURCE some people might like
     * to make use of the source!!!!  LJM
     */
#if 0
    if (rep_out == WWW_SOURCE || rep_out == rep_in)
	return sink;		/*  LJM */
#endif

    if (rep_out == rep_in) {
	result = sink;

    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp, anchor))) {
	if (match == &temp) {
	    CTRACE((tfp, "StreamStack: Using %s\n", HTAtom_name(temp.rep_out)));
	} else {
	    CTRACE((tfp, "StreamStack: found exact match: %s\n",
		    HTAtom_name(match->rep)));
	}
	result = (*match->converter) (match, anchor, sink);
    } else {
	result = NULL;
    }
    if (TRACE) {
	if (result && result->isa && result->isa->name) {
	    CTRACE((tfp, "StreamStack: Returning \"%s\"\n", result->isa->name));
	} else if (result) {
	    CTRACE((tfp, "StreamStack: Returning *unknown* stream!\n"));
	} else {
	    CTRACE((tfp, "StreamStack: Returning NULL!\n"));
	    CTRACE_FLUSH(tfp);	/* a crash may be imminent... - kw */
	}
    }
    return result;
}

/*		Put a presentation near start of list
 *		-------------------------------------
 *
 *	Look up a presentation (exact match only) and, if found, reorder
 *	it to the start of the HTPresentations list. - kw
 */
void HTReorderPresentation(HTFormat rep_in,
			   HTFormat rep_out)
{
    HTPresentation *match;

    if ((match = HTFindPresentation(rep_in, rep_out, NULL, NULL))) {
	HTList_removeObject(HTPresentations, match);
	HTList_addObject(HTPresentations, match);
    }
}

/*
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
void HTFilterPresentations(void)
{
    int i, j;
    int n = HTList_count(HTPresentations);
    HTPresentation *p, *q;
    BOOL matched;
    char *s, *t;

    CTRACE((tfp, "HTFilterPresentations (AcceptMedia %#x)\n", LYAcceptMedia));
    for (i = 0; i < n; i++) {
	p = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	s = HTAtom_name(p->rep);

	p->get_accept = FALSE;
	if ((LYAcceptMedia & p->accept_opt) != 0
	    && p->rep_out == WWW_PRESENT
	    && p->rep != WWW_SOURCE
	    && strcasecomp(s, "www/mime")
	    && strcasecomp(s, "www/compressed")
	    && p->quality <= 1.0 && p->quality >= 0.0) {
	    matched = TRUE;
	    for (j = 0; j < i; j++) {
		q = (HTPresentation *) HTList_objectAt(HTPresentations, j);
		t = HTAtom_name(q->rep);

		if (!strcasecomp(s, t)) {
		    matched = FALSE;
		    CTRACE((tfp, "  match %s %s\n", s, t));
		    break;
		}
	    }
	    p->get_accept = matched;
	}
    }
}

/*		Find the cost of a filter stack
 *		-------------------------------
 *
 *	Must return the cost of the same stack which StreamStack would set up.
 *
 * On entry,
 *	length	The size of the data to be converted
 */
float HTStackValue(HTFormat rep_in,
		   HTFormat rep_out,
		   float initial_value,
		   long int length)
{
    HTAtom *wildcard = WWW_WILDCARD_REP_OUT;

    CTRACE((tfp, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
	    HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));

    if (rep_out == WWW_SOURCE || rep_out == rep_in)
	return 0.0;

    {
	int n = HTList_count(HTPresentations);
	int i;
	HTPresentation *pres;

	for (i = 0; i < n; i++) {
	    pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	    if (pres->rep == rep_in &&
		(pres->rep_out == rep_out || pres->rep_out == wildcard)) {
		float value = initial_value * pres->quality;

		if (HTMaxSecs != 0.0)
		    value = value - (length * pres->secs_per_byte + pres->secs)
			/ HTMaxSecs;
		return value;
	    }
	}
    }

    return (float) -1e30;	/* Really bad */

}

/*	Display the page while transfer in progress
 *	-------------------------------------------
 *
 *   Repaint the page only when necessary.
 *   This is a traverse call for HText_pageDisplay() - it works!.
 *
 */
void HTDisplayPartial(void)
{
#ifdef DISP_PARTIAL
    if (display_partial) {
	/*
	 * HText_getNumOfLines() = "current" number of complete lines received
	 * NumOfLines_partial = number of lines at the moment of last repaint. 
	 * (we update NumOfLines_partial only when we repaint the display.)
	 *
	 * display_partial could only be enabled in HText_new() so a new
	 * HTMainText object available - all HText_ functions use it, lines
	 * counter HText_getNumOfLines() in particular.
	 *
	 * Otherwise HTMainText holds info from the previous document and we
	 * may repaint it instead of the new one:  prev doc scrolled to the
	 * first line (=Newline_partial) is not good looking :-) 23 Aug 1998
	 * Leonid Pauzner
	 *
	 * So repaint the page only when necessary:
	 */
	int Newline_partial = LYGetNewline();

	if (((Newline_partial + display_lines) - 1 > NumOfLines_partial)
	/* current page not complete... */
	    && (partial_threshold > 0 ?
		((Newline_partial + partial_threshold) - 1 <=
		 HText_getNumOfLines()) :
		((Newline_partial + display_lines) - 1 <= HText_getNumOfLines()))
	/*
	 * Originally we rendered by increments of 2 lines,
	 * but that got annoying on slow network connections.
	 * Then we switched to full-pages.  Now it's configurable.
	 * If partial_threshold <= 0, then it's a full page
	 */
	    ) {
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
	}
    }
#else /* nothing */
#endif /* DISP_PARTIAL */
}

/* Put this as early as possible, OK just after HTDisplayPartial() */
void HTFinishDisplayPartial(void)
{
#ifdef DISP_PARTIAL
    /*
     * End of incremental rendering stage here.
     */
    display_partial = FALSE;
#endif /* DISP_PARTIAL */
}

/*	Push data from a socket down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream, i.e., containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-2		Unexpected disconnect before any data received.
 *	-1		Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-2		socket still open, target stream still valid.
 *	-1		socket still open, target aborted.
 *	otherwise	socket closed,	target stream still valid.
 */
int HTCopy(HTParentAnchor *anchor,
	   int file_number,
	   void *handle GCC_UNUSED,
	   HTStream *sink)
{
    HTStreamClass targetClass;
    BOOL suppress_readprogress = NO;
    int bytes;
    int rv = 0;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*
     * Push binary from socket down sink
     *
     * This operation could be put into a main event loop
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	int status;

	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    (*targetClass._abort) (sink, NULL);
	    rv = -1;
	    goto finished;
	}

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    (*targetClass._abort) (sink, NULL);
	    if (bytes)
		rv = HT_INTERRUPTED;
	    else
		rv = -1;
	    goto finished;
	}
#ifdef USE_SSL
	if (handle)
	    status = SSL_read((SSL *) handle, input_buffer, INPUT_BUFFER_SIZE);
	else
	    status = NETREAD(file_number, input_buffer, INPUT_BUFFER_SIZE);
#else
	status = NETREAD(file_number, input_buffer, INPUT_BUFFER_SIZE);
#endif /* USE_SSL */

	if (status <= 0) {
	    if (status == 0) {
		break;
	    } else if (status == HT_INTERRUPTED) {
		_HTProgress(TRANSFER_INTERRUPTED);
		(*targetClass._abort) (sink, NULL);
		if (bytes)
		    rv = HT_INTERRUPTED;
		else
		    rv = -1;
		goto finished;
	    } else if (SOCKET_ERRNO == ENOTCONN ||
#ifdef _WINDOWS			/* 1997/11/10 (Mon) 16:57:18 */
		       SOCKET_ERRNO == ETIMEDOUT ||
#endif
		       SOCKET_ERRNO == ECONNRESET ||
		       SOCKET_ERRNO == EPIPE) {
		/*
		 * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
		 */
		if (bytes <= 0) {
		    /*
		     * Don't have any data, so let the calling function decide
		     * what to do about it.  - FM
		     */
		    rv = -2;
		    goto finished;
		} else {
#ifdef UNIX
		    /*
		     * Treat what we've received already as the complete
		     * transmission, but not without giving the user an alert. 
		     * I don't know about all the different TCP stacks for VMS
		     * etc., so this is currently only for UNIX.  - kw
		     */
		    HTInetStatus("NETREAD");
		    HTAlert("Unexpected server disconnect.");
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
		    status = 0;
		    break;
#else /* !UNIX */
		    /*
		     * Treat what we've gotten already as the complete
		     * transmission.  - FM
		     */
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
		    status = 0;
		    break;
#endif /* UNIX */
		}
#ifdef UNIX
	    } else {		/* status < 0 and other errno */
		/*
		 * Treat what we've received already as the complete
		 * transmission, but not without giving the user an alert.  I
		 * don't know about all the different TCP stacks for VMS etc.,
		 * so this is currently only for UNIX.  - kw
		 */
		HTInetStatus("NETREAD");
		HTAlert("Unexpected read error.");
		if (bytes) {
		    (void) NETCLOSE(file_number);
		    rv = HT_LOADED;
		} else {
		    (*targetClass._abort) (sink, NULL);
		    rv = -1;
		}
		goto finished;
#endif
	    }
	    break;
	}

	/*
	 * Suppress ReadProgress messages when collecting a redirection
	 * message, at least initially (unless/until anchor->content_type gets
	 * changed, probably by the MIME message parser).  That way messages
	 * put up by the HTTP module or elsewhere can linger in the statusline
	 * for a while.  - kw
	 */
	suppress_readprogress = (anchor && anchor->content_type &&
				 !strcmp(anchor->content_type,
					 "message/x-http-redirection"));
#ifdef NOT_ASCII
	{
	    char *p;

	    for (p = input_buffer; p < input_buffer + status; p++) {
		*p = FROMASCII(*p);
	    }
	}
#endif /* NOT_ASCII */

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	if (!suppress_readprogress)
	    HTReadProgress(bytes, anchor ? anchor->content_length : 0);
	HTDisplayPartial();

    }				/* next bufferload */

    _HTProgress(TRANSFER_COMPLETE);
    (void) NETCLOSE(file_number);
    rv = HT_LOADED;

  finished:
    HTFinishDisplayPartial();
    return (rv);
}

/*	Push data from a file pointer down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open, target stream still valid.
 */
int HTFileCopy(FILE *fp, HTStream *sink)
{
    HTStreamClass targetClass;
    int status, bytes;
    int rv = HT_OK;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*  Push binary from socket down sink
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	status = fread(input_buffer, 1, INPUT_BUFFER_SIZE, fp);
	if (status == 0) {	/* EOF or error */
	    if (ferror(fp) == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTFormat: Read error, read returns %d\n",
		    ferror(fp)));
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, 0);
	/* Suppress last screen update in partial mode - a regular update under
	 * control of mainloop() should follow anyway.  - kw
	 */
#ifdef DISP_PARTIAL
	if (display_partial && bytes != HTMainAnchor->content_length)
	    HTDisplayPartial();
#endif

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    }				/* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}

#ifdef USE_SOURCE_CACHE
/*	Push data from an HTChunk down a stream
 *	---------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) and target (sink) assumed valid.
 *
 *  Return values:
 *	HT_LOADED	All data sent.
 *	HT_INTERRUPTED  Interruption after some data read.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged, target stream still valid.
 */
int HTMemCopy(HTChunk *chunk, HTStream *sink)
{
    HTStreamClass targetClass;
    int bytes = 0;
    const char *data = chunk->data;
    int rv = HT_OK;

    targetClass = *(sink->isa);
    HTReadProgress(0, 0);
    for (;;) {
	/* Push the data down the stream a piece at a time, in case we're
	 * running a large document on a slow machine.
	 */
	int n = INPUT_BUFFER_SIZE;

	if (n > chunk->size - bytes)
	    n = chunk->size - bytes;
	if (n == 0)
	    break;
	(*targetClass.put_block) (sink, data, n);
	bytes += n;
	data += n;
	HTReadProgress(bytes, 0);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    }

    HTFinishDisplayPartial();
    return rv;
}
#endif

#ifdef USE_ZLIB
/*	Push data from a gzip file pointer down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      gzFile (gzfp) assumed open (should have gzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp still open, target stream still valid.
 */
static int HTGzFileCopy(gzFile gzfp, HTStream *sink)
{
    HTStreamClass targetClass;
    int status, bytes;
    int gzerrnum;
    int rv = HT_OK;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*  read and inflate gzip'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	status = gzread(gzfp, input_buffer, INPUT_BUFFER_SIZE);
	if (status <= 0) {	/* EOF or error */
	    if (status == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTGzFileCopy: Read error, gzread returns %d\n",
		    status));
	    CTRACE((tfp, "gzerror   : %s\n",
		    gzerror(gzfp, &gzerrnum)));
	    if (TRACE) {
		if (gzerrnum == Z_ERRNO)
		    perror("gzerror   ");
	    }
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, -1);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    }				/* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}

/*	Push data from a deflate file pointer down a stream
 *	-------------------------------------
 *
 *  This routine is responsible for creating and PRESENTING any
 *  graphic (or other) objects described by the file.  The code is
 *  loosely based on the inflate.c file from w3m.
 *
 *
 *  State of file and target stream on entry:
 *		      FILE (zzfp) assumed open (should have deflated content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp still open, target stream still valid.
 */
static int HTZzFileCopy(FILE *zzfp, HTStream *sink)
{
    static char dummy_head[1 + 1] =
    {
	0x8 + 0x7 * 0x10,
	(((0x8 + 0x7 * 0x10) * 0x100 + 30) / 31 * 31) & 0xFF,
    };

    z_stream s;
    HTStreamClass targetClass;
    int bytes;
    int rv = HT_OK;
    char output_buffer[INPUT_BUFFER_SIZE];
    int status;
    int flush;
    int retry = 0;
    int len = 0;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    s.zalloc = Z_NULL;
    s.zfree = Z_NULL;
    s.opaque = Z_NULL;
    status = inflateInit(&s);
    if (status != Z_OK) {
	CTRACE((tfp, "HTZzFileCopy inflateInit() %s\n", zError(status)));
	exit_immediately(1);
    }
    s.avail_in = 0;
    s.next_out = (Bytef *) output_buffer;
    s.avail_out = sizeof(output_buffer);
    flush = Z_NO_FLUSH;

    /*  read and inflate deflate'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	if (s.avail_in == 0) {
	    s.next_in = (Bytef *) input_buffer;
	    len = s.avail_in = fread(input_buffer, 1, INPUT_BUFFER_SIZE, zzfp);
	}
	status = inflate(&s, flush);
	if (status == Z_STREAM_END || status == Z_BUF_ERROR) {
	    len = sizeof(output_buffer) - s.avail_out;
	    if (len > 0) {
		(*targetClass.put_block) (sink, output_buffer, len);
		bytes += len;
		HTReadProgress(bytes, -1);
		HTDisplayPartial();
	    }
	    rv = HT_LOADED;
	    break;
	} else if (status == Z_DATA_ERROR && !retry++) {
	    status = inflateReset(&s);
	    if (status != Z_OK) {
		CTRACE((tfp, "HTZzFileCopy inflateReset() %s\n", zError(status)));
		rv = bytes ? HT_PARTIAL_CONTENT : -1;
		break;
	    }
	    s.next_in = (Bytef *) dummy_head;
	    s.avail_in = sizeof(dummy_head);
	    status = inflate(&s, flush);
	    s.next_in = (Bytef *) input_buffer;
	    s.avail_in = len;
	    continue;
	} else if (status != Z_OK) {
	    CTRACE((tfp, "HTZzFileCopy inflate() %s\n", zError(status)));
	    rv = bytes ? HT_PARTIAL_CONTENT : -1;
	    break;
	} else if (s.avail_out == 0) {
	    len = sizeof(output_buffer);
	    s.next_out = (Bytef *) output_buffer;
	    s.avail_out = sizeof(output_buffer);

	    (*targetClass.put_block) (sink, output_buffer, len);
	    bytes += len;
	    HTReadProgress(bytes, -1);
	    HTDisplayPartial();

	    if (HTCheckForInterrupt()) {
		_HTProgress(TRANSFER_INTERRUPTED);
		rv = bytes ? HT_INTERRUPTED : -1;
		break;
	    }
	}
	retry = 1;
    }				/* next bufferload */

    inflateEnd(&s);
    HTFinishDisplayPartial();
    return rv;
}
#endif /* USE_ZLIB */

#ifdef USE_BZLIB
/*	Push data from a bzip file pointer down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      BZFILE (bzfp) assumed open (should have bzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp still open, target stream still valid.
 */
static int HTBzFileCopy(BZFILE * bzfp, HTStream *sink)
{
    HTStreamClass targetClass;
    int status, bytes;
    int bzerrnum;
    int rv = HT_OK;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*  read and inflate bzip'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	status = BZ2_bzread(bzfp, input_buffer, INPUT_BUFFER_SIZE);
	if (status <= 0) {	/* EOF or error */
	    if (status == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTBzFileCopy: Read error, bzread returns %d\n",
		    status));
	    CTRACE((tfp, "bzerror   : %s\n",
		    BZ2_bzerror(bzfp, &bzerrnum)));
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, -1);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    }				/* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}
#endif /* USE_BZLIB */

/*	Push data from a socket down a stream STRIPPING CR
 *	--------------------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the socket.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 */
void HTCopyNoCR(HTParentAnchor *anchor GCC_UNUSED,
		int file_number,
		HTStream *sink)
{
    HTStreamClass targetClass;
    int character;

    /*  Push the data, ignoring CRLF, down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*
     * Push text from telnet socket down sink
     *
     * @@@@@@@@@@ To push strings could be faster?  (especially is we cheat and
     * don't ignore CR!  :-}
     */
    HTInitInput(file_number);
    for (;;) {
	character = HTGetCharacter();
	if (character == EOF)
	    break;
	(*targetClass.put_character) (sink, UCH(character));
    }
}

/*	Parse a socket given format and file number
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-501		Stream stack failed (cannot present or convert).
 *	-2		Unexpected disconnect before any data received.
 *	-1		Stream stack failed (cannot present or convert), or
 *			Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-501		socket still open, target stream NULL.
 *	-2		socket still open, target freed.
 *	-1		socket still open, target stream aborted or NULL.
 *	otherwise	socket closed,	target stream freed.
 */
int HTParseSocket(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  int file_number,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat: %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);	/* returns -501 */
	FREE(buffer);
    } else {
	/*
	 * Push the data, don't worry about CRLF we can strip them later.
	 */
	targetClass = *(stream->isa);	/* Copy pointers to procedures */
	rv = HTCopy(anchor, file_number, NULL, stream);
	if (rv != -1 && rv != HT_INTERRUPTED)
	    (*targetClass._free) (stream);
    }
    return rv;
    /* Originally:  full: HT_LOADED;  partial: HT_INTERRUPTED;  no bytes: -1 */
}

/*	Parse a file given format and file pointer
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to \n for unix
 *   when the format is textual.
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open; target freed, aborted, or NULL.
 */
int HTParseFile(HTFormat rep_in,
		HTFormat format_out,
		HTParentAnchor *anchor,
		FILE *fp,
		HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

#ifdef SH_EX			/* 1998/01/04 (Sun) 16:04:09 */
    if (fp == NULL)
	return HT_LOADED;
#endif

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTFileCopy(fp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}

#ifdef USE_SOURCE_CACHE
/*	Parse a document in memory given format and memory block pointer
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) assumed valid,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	HT_LOADED	All data sent.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged; target freed, aborted, or NULL.
 */
int HTParseMem(HTFormat rep_in,
	       HTFormat format_out,
	       HTParentAnchor *anchor,
	       HTChunk *chunk,
	       HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);
    if (!stream) {
	char *buffer = 0;

	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseMem): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /* Push the data down the stream
     */
    targetClass = *(stream->isa);
    rv = HTMemCopy(chunk, stream);
    (*targetClass._free) (stream);
    return HT_LOADED;
}
#endif

#ifdef USE_ZLIB
static int HTCloseGzFile(gzFile gzfp)
{
    int gzres;

    if (gzfp == NULL)
	return 0;
    gzres = gzclose(gzfp);
    if (TRACE) {
	if (gzres == Z_ERRNO) {
	    perror("gzclose   ");
	} else if (gzres != Z_OK) {
	    CTRACE((tfp, "gzclose   : error number %d\n", gzres));
	}
    }
    return (gzres);
}

/*	HTParseGzFile
 *
 *  State of file and target stream on entry:
 *			gzFile (gzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp closed; target freed, aborted, or NULL.
 */
int HTParseGzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  gzFile gzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	HTCloseGzFile(gzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTGzFileCopy(gzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    HTCloseGzFile(gzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}

/*	HTParseZzFile
 *
 *  State of file and target stream on entry:
 *			FILE (zzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp closed; target freed, aborted, or NULL.
 */
int HTParseZzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  FILE *zzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	fclose(zzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTZzFileCopy(zzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    fclose(zzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}
#endif /* USE_ZLIB */

#ifdef USE_BZLIB
static void HTCloseBzFile(BZFILE * bzfp)
{
    if (bzfp)
	BZ2_bzclose(bzfp);
}

/*	HTParseBzFile
 *
 *  State of file and target stream on entry:
 *			bzFile (bzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp closed; target freed, aborted, or NULL.
 */
int HTParseBzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  BZFILE * bzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	HTCloseBzFile(bzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseBzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTBzFileCopy(bzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    HTCloseBzFile(bzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}
#endif /* USE_BZLIB */

/*	Converter stream: Network Telnet to internal character text
 *	-----------------------------------------------------------
 *
 *	The input is assumed to be in ASCII, with lines delimited
 *	by (13,10) pairs, These pairs are converted into (CR,LF)
 *	pairs in the local representation.  The (CR,LF) sequence
 *	when found is changed to a '\n' character, the internal
 *	C representation of a new line.
 */

static void NetToText_put_character(HTStream *me, char net_char)
{
    char c = FROMASCII(net_char);

    if (me->had_cr) {
	if (c == LF) {
	    me->sink->isa->put_character(me->sink, '\n');	/* Newline */
	    me->had_cr = NO;
	    return;
	} else {
	    me->sink->isa->put_character(me->sink, CR);		/* leftover */
	}
    }
    me->had_cr = (BOOL) (c == CR);
    if (!me->had_cr)
	me->sink->isa->put_character(me->sink, c);	/* normal */
}

static void NetToText_put_string(HTStream *me, const char *s)
{
    const char *p;

    for (p = s; *p; p++)
	NetToText_put_character(me, *p);
}

static void NetToText_put_block(HTStream *me, const char *s, int l)
{
    const char *p;

    for (p = s; p < (s + l); p++)
	NetToText_put_character(me, *p);
}

static void NetToText_free(HTStream *me)
{
    (me->sink->isa->_free) (me->sink);	/* Close rest of pipe */
    FREE(me);
}

static void NetToText_abort(HTStream *me, HTError e)
{
    me->sink->isa->_abort(me->sink, e);		/* Abort rest of pipe */
    FREE(me);
}

/*	The class structure
*/
static HTStreamClass NetToTextClass =
{
    "NetToText",
    NetToText_free,
    NetToText_abort,
    NetToText_put_character,
    NetToText_put_string,
    NetToText_put_block
};

/*	The creation method
*/
HTStream *HTNetToText(HTStream *sink)
{
    HTStream *me = typecalloc(HTStream);

    if (me == NULL)
	outofmem(__FILE__, "NetToText");
    me->isa = &NetToTextClass;

    me->had_cr = NO;
    me->sink = sink;
    return me;
}

static HTStream HTBaseStreamInstance;	/* Made static */

/*
 *	ERROR STREAM
 *	------------
 *	There is only one error stream shared by anyone who wants a
 *	generic error returned from all stream methods.
 */
static void HTErrorStream_put_character(HTStream *me GCC_UNUSED, char c GCC_UNUSED)
{
    LYCancelDownload = TRUE;
}

static void HTErrorStream_put_string(HTStream *me GCC_UNUSED, const char *s)
{
    if (s && *s)
	LYCancelDownload = TRUE;
}

static void HTErrorStream_write(HTStream *me GCC_UNUSED, const char *s, int l)
{
    if (l && s)
	LYCancelDownload = TRUE;
}

static void HTErrorStream_free(HTStream *me GCC_UNUSED)
{
    return;
}

static void HTErrorStream_abort(HTStream *me GCC_UNUSED, HTError e GCC_UNUSED)
{
    return;
}

static const HTStreamClass HTErrorStreamClass =
{
    "ErrorStream",
    HTErrorStream_free,
    HTErrorStream_abort,
    HTErrorStream_put_character,
    HTErrorStream_put_string,
    HTErrorStream_write
};

HTStream *HTErrorStream(void)
{
    CTRACE((tfp, "ErrorStream. Created\n"));
    HTBaseStreamInstance.isa = &HTErrorStreamClass;	/* The rest is random */
    return &HTBaseStreamInstance;
}
@


1.7
log
@automatic merge
@
text
@d19 1
a19 3
float HTMaxSecs = 1e10;		/* No effective limit */
float HTMaxLength = 1e10;	/* No effective limit */
long int HTMaxBytes = 0;	/* No effective limit */
d555 1
a555 1
	if (LYAcceptMedia & p->accept_opt
d1135 1
a1135 1
	exit(1);
@


1.6
log
@automatic merge of lynx-current
@
text
@d439 1
a439 1
		/* otherwise use the first one */
d1087 116
d1592 68
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 10
a11 10
**		=============================
**
** Bugs:
**	Not reentrant.
**
**	Assumes the incoming stream is ASCII, rather than a local file
**	format, and so ALWAYS converts from ASCII on non-ASCII machines.
**	Therefore, non-ASCII machines can't read local files.
**
*/
d21 1
a21 1
long int HTMaxBytes  = 0;	/* No effective limit */
d61 2
a62 2
      const HTStreamClass*	isa;
      /* ... */
d68 3
a70 3
	const HTStreamClass *	isa;
	BOOL			had_cr;
	HTStream *		sink;
d74 4
a77 4
**	--------------------
*/
HTList * HTPresentations = NULL;
HTPresentation * default_presentation = NULL;
d83 1
a83 1
static void HTFreePresentations (void);
d87 10
a96 9
**	-------------------------------------------------------
*/
void HTSetPresentation (
	const char *	representation,
	const char *	command,
	double		quality,
	double		secs,
	double		secs_per_byte,
	long int	maxbytes)
d98 2
a99 1
    HTPresentation * pres = typecalloc(HTPresentation);
d104 2
a105 2
    pres->rep_out = WWW_PRESENT;		/* Fixed for now ... :-) */
    pres->converter = HTSaveAndExecute;		/* Fixed for now ...	 */
d110 3
d116 3
d120 2
a121 2
     *	Memory leak fixed.
     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d123 1
a123 1
    if (!HTPresentations)	{
d130 1
a130 1
    if (strcmp(representation, "*")==0) {
d139 10
a148 10
**	---------------------------------------------
*/
void HTSetConversion (
	const char *	representation_in,
	const char *	representation_out,
	HTConverter*	converter,
	float		quality,
	float		secs,
	float		secs_per_byte,
	long int	maxbytes)
d150 2
a151 1
    HTPresentation * pres = typecalloc(HTPresentation);
d158 2
a159 1
    pres->command = NULL;		/* Fixed */
d164 2
a165 1
    pres->command = NULL;
d168 2
a169 2
     *	Memory Leak fixed.
     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d171 1
a171 1
    if (!HTPresentations)	{
d183 9
a191 9
**	Purpose:	Free the presentation list.
**	Arguments:	void
**	Return Value:	void
**	Remarks/Portability/Dependencies/Restrictions:
**		Made to clean up Lynx's bad leakage.
**	Revision History:
**		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
static void HTFreePresentations (void)
d193 1
a193 1
    HTPresentation * pres = NULL;
d196 1
a196 1
     *	Loop through the list.
d200 2
a201 3
	 *  Free off each item.
	 *  May also need to free off it's items, but not sure
	 *  as of yet.
d203 1
a203 1
	pres = (HTPresentation *)HTList_removeLastObject(HTPresentations);
d205 1
d209 1
a209 1
     *	Free the list itself.
d217 8
a224 8
**	--------------
**
**	The input file is read using the macro which can read from
**	a socket or a file.
**	The input buffer size, if large will give greater efficiency and
**	release the server faster, and if small will save space on PCs etc.
*/
#define INPUT_BUFFER_SIZE 4096		/* Tradeoff */
d226 2
a227 2
static char * input_pointer;
static char * input_limit;
d231 6
a236 6
**
**	These routines are public because they are in fact needed by
**	many parsers, and on PCs and Macs we should not duplicate
**	the static buffer area.
*/
void HTInitInput (int file_number)
d243 1
a243 1
int HTGetCharacter (void)
d246 1
d252 1
d262 2
a263 2
		return EOF; /* -1 is returned by UCX
			       at end of HTTP link */
d269 1
a269 1
    } while (ch == (char) 13); /* Ignore ASCII carriage return */
d275 1
a275 1
char HTGetSSLCharacter (void *  handle)
d278 1
d280 2
a281 2
    if(!handle)
	return (char)EOF;
d284 3
a286 2
	    int status = SSL_read((SSL *)handle,
				 input_buffer, INPUT_BUFFER_SIZE);
d289 1
a289 1
		    return (char)EOF;
d291 2
a292 1
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetSSLCharacter\n"));
d294 1
a294 1
		    return (char)EOF;
d297 2
a298 2
		return (char)EOF; /* -1 is returned by UCX
				     at end of HTTP link */
d304 1
a304 1
    } while (ch == (char) 13); /* Ignore ASCII carriage return */
d310 2
a311 2
/*  Match maintype to any MIME type starting with maintype,
 *  for example:  image/gif should match image
d313 1
a313 1
static int half_match (char * trial_type, char * target)
d318 1
a318 1
    if (!cp || *(cp+1) != '*')
d322 1
a322 1
		trial_type, target));
d324 2
a325 2
	/* main type matches */
    if (!strncmp(trial_type, target, (cp-trial_type)-1))
d331 14
d348 24
a371 16
**		----------------------
**
**	If fill_in is NULL, only look for an exact match.
**	If a wildcard match is made, *fill_in is used to store
**	a possibly modified presentation, and a pointer to it is
**	returned.  For an exact match, a pointer to the presentation
**	in the HTPresentations list is returned.  Returns NULL if
**	nothing found. - kw
**
*/
static HTPresentation * HTFindPresentation (
	HTFormat		rep_in,
	HTFormat		rep_out,
	HTPresentation*	fill_in)
{
    HTAtom * wildcard = NULL; /* = HTAtom_for("*"); lookup when needed - kw */
d374 1
a374 1
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d376 6
a381 21
    /* don't do anymore do it in the Lynx code at startup LJM */
    /* if (!HTPresentations) HTFormatInit(); */ /* set up the list */

    {
	int n = HTList_count(HTPresentations);
	int i;
	HTPresentation * pres, *match,
			*strong_wildcard_match=0,
			*weak_wildcard_match=0,
			*last_default_match=0,
			*strong_subtype_wildcard_match=0;

	for (i = 0; i < n; i++) {
	    pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
	    if (pres->rep == rep_in) {
		if (pres->rep_out == rep_out) {
		    CTRACE((tfp, "FindPresentation: found exact match: %s\n",
				HTAtom_name(pres->rep)));
		    return pres;

		} else if (!fill_in) {
d383 3
a385 10
		} else {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard) {
			if (!strong_wildcard_match)
			    strong_wildcard_match = pres;
			/* otherwise use the first one */
			CTRACE((tfp, "StreamStack: found strong wildcard match: %s\n",
				    HTAtom_name(pres->rep)));
		    }
		}
d389 8
a396 6

	    } else if (half_match(HTAtom_name(pres->rep),
					      HTAtom_name(rep_in))) {
		if (pres->rep_out == rep_out) {
		    if (!strong_subtype_wildcard_match)
			strong_subtype_wildcard_match = pres;
d398 3
a400 2
		    CTRACE((tfp, "StreamStack: found strong subtype wildcard match: %s\n",
				HTAtom_name(pres->rep)));
d404 16
a419 7
	    if (pres->rep == WWW_SOURCE) {
		if (pres->rep_out == rep_out) {
		    if (!weak_wildcard_match)
			weak_wildcard_match = pres;
		    /* otherwise use the first one */
		    CTRACE((tfp, "StreamStack: found weak wildcard match: %s\n",
				HTAtom_name(pres->rep_out)));
d421 19
a439 5
		} else if (!last_default_match) {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard)
			 last_default_match = pres;
		    /* otherwise use the first one */
d443 1
d445 13
a457 11
	match = strong_subtype_wildcard_match ? strong_subtype_wildcard_match :
		strong_wildcard_match ? strong_wildcard_match :
		weak_wildcard_match ? weak_wildcard_match :
		last_default_match;

	if (match) {
	    *fill_in = *match;		/* Specific instance */
	    fill_in->rep = rep_in;		/* yuk */
	    fill_in->rep_out = rep_out; /* yuk */
	    return fill_in;
	}
d464 13
a476 14
**		---------------------
**
**	If a wildcard match is made, a temporary HTPresentation
**	structure is made to hold the destination format while the
**	new stack is generated. This is just to pass the out format to
**	MIME so far.  Storing the format of a stream in the stream might
**	be a lot neater.
**
*/
HTStream * HTStreamStack (
	HTFormat		rep_in,
	HTFormat		rep_out,
	HTStream*		sink,
	HTParentAnchor*	anchor)
d482 4
a485 2
    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d492 1
a492 1
	return sink;	/*  LJM */
d498 1
a498 1
    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp))) {
d503 1
a503 1
			HTAtom_name(match->rep)));
d505 1
a505 1
	result = (*match->converter)(match, anchor, sink);
d523 7
a529 8
**		-------------------------------------
**
**	Look up a presentation (exact match only) and, if found, reorder
**	it to the start of the HTPresentations list. - kw
*/
void HTReorderPresentation (
	HTFormat		rep_in,
	HTFormat		rep_out)
d532 2
a533 1
    if ((match = HTFindPresentation(rep_in, rep_out, NULL))) {
d543 1
a543 1
void HTFilterPresentations (void)
d549 1
a549 1
    char *s, *t, *x, *y;
d551 1
d553 1
a553 1
	p = (HTPresentation *)HTList_objectAt(HTPresentations, i);
d556 16
a571 25
	if (p->rep_out == WWW_PRESENT) {
	    if (p->rep != WWW_SOURCE
	     && strcasecomp(s, "www/mime")
	     && strcasecomp(s, "www/compressed")
	     && p->quality <= 1.0 && p->quality >= 0.0) {
		for (j = 0, matched = FALSE; j < i; j++) {
		    q = (HTPresentation *)HTList_objectAt(HTPresentations, j);
		    t = HTAtom_name(q->rep);

		    if (!strcasecomp(s, t)) {
			matched = TRUE;
			break;
		    }
		    if ((x = strchr(s, '/')) != 0
		     && (y = strchr(t, '/')) != 0) {
			int len1 = x++ - s;
			int len2 = y++ - t;
			int lens = (len1 > len2) ? len1 : len2;

			if ((*t == '*' || !strncasecomp(s, t, lens))
			 && (*y == '*' || !strcasecomp(x, y))) {
			    matched = TRUE;
			    break;
			}
		    }
a572 2
		if (!matched)
		    p->get_accept = TRUE;
d574 1
d580 11
a590 12
**		-------------------------------
**
**	Must return the cost of the same stack which StreamStack would set up.
**
** On entry,
**	length	The size of the data to be converted
*/
float HTStackValue (
	HTFormat		rep_in,
	HTFormat		rep_out,
	float			initial_value,
	long int		length)
d592 1
a592 1
    HTAtom * wildcard = WWW_WILDCARD_REP_OUT;
d595 1
a595 1
		HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));
a599 3
    /* don't do anymore do it in the Lynx code at startup LJM */
    /* if (!HTPresentations) HTFormatInit(); */ /* set up the list */

d603 2
a604 1
	HTPresentation * pres;
d606 1
a606 1
	    pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
d610 1
d612 2
a613 2
		    value = value - (length*pres->secs_per_byte + pres->secs)
					 /HTMaxSecs;
d624 7
a630 7
**	-------------------------------------------
**
**   Repaint the page only when necessary.
**   This is a traverse call for HText_pageDisplay() - it works!.
**
*/
void HTDisplayPartial (void)
d635 15
a649 15
	**  HText_getNumOfLines() = "current" number of complete lines received
	**  NumOfLines_partial = number of lines at the moment of last repaint.
	**  (we update NumOfLines_partial only when we repaint the display.)
	**
	**  display_partial could only be enabled in HText_new()
	**  so a new HTMainText object available - all HText_ functions use it,
	**  lines counter HText_getNumOfLines() in particular.
	**
	**  Otherwise HTMainText holds info from the previous document
	**  and we may repaint it instead of the new one:
	**  prev doc scrolled to the first line (=Newline_partial)
	**  is not good looking :-)	  23 Aug 1998 Leonid Pauzner
	**
	**  So repaint the page only when necessary:
	*/
d653 4
a656 3
		/* current page not complete... */
	&& (partial_threshold > 0 ?
		((Newline_partial + partial_threshold) -1 <= HText_getNumOfLines()) :
d658 7
a664 7
		/*
		 * Originally we rendered by increments of 2 lines,
		 * but that got annoying on slow network connections.
		 * Then we switched to full-pages.  Now it's configurable.
		 * If partial_threshold <= 0, then it's a full page
		 */
	) {
d670 1
a670 1
#endif  /* DISP_PARTIAL */
d674 1
a674 1
void HTFinishDisplayPartial (void)
d677 4
a680 4
		    /*
		     *  End of incremental rendering stage here.
		     */
		    display_partial = FALSE;
d685 35
a719 36
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**   The file number given is assumed to be a TELNET stream, i.e., containing
**   CRLF at the end of lines which need to be stripped to LF for unix
**   when the format is textual.
**
**  State of socket and target stream on entry:
**			socket (file_number) assumed open,
**			target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption or error after some data received.
**	-2		Unexpected disconnect before any data received.
**	-1		Interruption or error before any data received, or
**			(UNIX) other read error before any data received, or
**			download cancelled.
**	HT_LOADED	Normal close of socket (end of file indication
**			received), or
**			unexpected disconnect after some data received, or
**			other read error after some data received, or
**			(not UNIX) other read error before any data received.
**
**  State of socket and target stream on return depends on return value:
**	HT_INTERRUPTED	socket still open, target aborted.
**	-2		socket still open, target stream still valid.
**	-1		socket still open, target aborted.
**	otherwise	socket closed,	target stream still valid.
*/
int HTCopy (
	HTParentAnchor *	anchor,
	int			file_number,
	void*			handle GCC_UNUSED,
	HTStream*		sink)
d726 9
a734 8
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */

    /*	Push binary from socket down sink
    **
    **	This operation could be put into a main event loop
    */
d741 1
a741 1
	    (*targetClass._abort)(sink, NULL);
d747 2
a748 2
	    _HTProgress (TRANSFER_INTERRUPTED);
	    (*targetClass._abort)(sink, NULL);
a754 1

d757 1
a757 1
	    status = SSL_read((SSL *)handle, input_buffer, INPUT_BUFFER_SIZE);
d768 2
a769 2
		_HTProgress (TRANSFER_INTERRUPTED);
		(*targetClass._abort)(sink, NULL);
d776 1
a776 1
#ifdef _WINDOWS	/* 1997/11/10 (Mon) 16:57:18 */
d782 1
a782 1
		 *  Arrrrgh, HTTP 0/1 compatibility problem, maybe.
d786 2
a787 2
		     *	Don't have any data, so let the calling
		     *	function decide what to do about it. - FM
d793 21
a813 22
		   /*
		    *  Treat what we've received already as the complete
		    *  transmission, but not without giving the user
		    *  an alert.  I don't know about all the different
		    *  TCP stacks for VMS etc., so this is currently
		    *  only for UNIX. - kw
		    */
		   HTInetStatus("NETREAD");
		   HTAlert("Unexpected server disconnect.");
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
		   status = 0;
		   break;
#else  /* !UNIX */
		   /*
		    *  Treat what we've gotten already
		    *  as the complete transmission. - FM
		    */
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
		   status = 0;
		   break;
d819 4
a822 5
		 *  Treat what we've received already as the complete
		 *  transmission, but not without giving the user
		 *  an alert.  I don't know about all the different
		 *  TCP stacks for VMS etc., so this is currently
		 *  only for UNIX. - kw
d827 1
a827 1
		    (void)NETCLOSE(file_number);
d830 1
a830 1
		    (*targetClass._abort)(sink, NULL);
d840 5
a844 5
	 *  Suppress ReadProgress messages when collecting a redirection
	 *  message, at least initially (unless/until anchor->content_type
	 *  gets changed, probably by the MIME message parser).  That way
	 *  messages put up by the HTTP module or elsewhere can linger in
	 *  the statusline for a while. - kw
d851 3
a853 2
	    char * p;
	    for (p = input_buffer; p < input_buffer+status; p++) {
d859 1
a859 1
	(*targetClass.put_block)(sink, input_buffer, status);
d865 1
a865 1
    } /* next bufferload */
d868 1
a868 1
    (void)NETCLOSE(file_number);
d871 1
a871 1
finished:
d873 1
a873 1
    return(rv);
d877 20
a896 22
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**
**  State of file and target stream on entry:
**			FILE* (fp) assumed open,
**			target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption after some data read.
**	HT_PARTIAL_CONTENT	Error after some data read.
**	-1		Error before any data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		fp still open, target stream still valid.
*/
int HTFileCopy (
	FILE *			fp,
	HTStream*		sink)
d902 3
a904 3
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */
d906 2
a907 2
    /*	Push binary from socket down sink
    */
d911 1
a911 1
	if (status == 0) { /* EOF or error */
d917 1
a917 1
			ferror(fp)));
d926 1
a926 1
	(*targetClass.put_block)(sink, input_buffer, status);
d929 2
a930 2
	/*  Suppress last screen update in partial mode - a regular update
	 *  under control of mainloop() should follow anyway. - kw
d938 1
a938 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d946 1
a946 1
    } /* next bufferload */
d954 16
a969 18
**	---------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**  State of memory and target stream on entry:
**			HTChunk* (chunk) and target (sink) assumed valid.
**
**  Return values:
**	HT_LOADED	All data sent.
**	HT_INTERRUPTED  Interruption after some data read.
**
**  State of memory and target stream on return:
**	always		chunk unchanged, target stream still valid.
*/
int HTMemCopy (
	HTChunk *		chunk,
	HTStream *		sink)
d980 2
a981 2
	** running a large document on a slow machine.
	*/
d983 1
d988 1
a988 1
	(*targetClass.put_block)(sink, data, n);
d995 1
a995 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d1012 20
a1031 22
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**
**  State of file and target stream on entry:
**		      gzFile (gzfp) assumed open (should have gzipped content),
**		      target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption after some data read.
**	HT_PARTIAL_CONTENT	Error after some data read.
**	-1		Error before any data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		gzfp still open, target stream still valid.
*/
static int HTGzFileCopy (
	gzFile			gzfp,
	HTStream*		sink)
d1038 3
a1040 3
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */
d1042 2
a1043 2
    /*	read and inflate gzip'd file, and push binary down sink
    */
d1047 1
a1047 1
	if (status <= 0) { /* EOF or error */
d1053 1
a1053 1
			status));
d1055 1
a1055 1
			gzerror(gzfp, &gzerrnum)));
d1068 1
a1068 1
	(*targetClass.put_block)(sink, input_buffer, status);
d1074 1
a1074 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d1082 1
a1082 1
    } /* next bufferload */
d1091 20
a1110 22
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**
**  State of file and target stream on entry:
**		      BZFILE (bzfp) assumed open (should have bzipped content),
**		      target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption after some data read.
**	HT_PARTIAL_CONTENT	Error after some data read.
**	-1		Error before any data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		bzfp still open, target stream still valid.
*/
static int HTBzFileCopy (
	BZFILE *		bzfp,
	HTStream*		sink)
d1117 3
a1119 3
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */
d1121 2
a1122 2
    /*	read and inflate bzip'd file, and push binary down sink
    */
d1126 1
a1126 1
	if (status <= 0) { /* EOF or error */
d1132 1
a1132 1
			status));
d1134 1
a1134 1
			BZ2_bzerror(bzfp, &bzerrnum)));
d1143 1
a1143 1
	(*targetClass.put_block)(sink, input_buffer, status);
d1149 1
a1149 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d1157 1
a1157 1
    } /* next bufferload */
d1165 13
a1177 14
**	--------------------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the socket.
**
**   The file number given is assumed to be a TELNET stream ie containing
**   CRLF at the end of lines which need to be stripped to LF for unix
**   when the format is textual.
**
*/
void HTCopyNoCR (
	HTParentAnchor *	anchor GCC_UNUSED,
	int			file_number,
	HTStream*		sink)
d1182 10
a1191 9
    /*	Push the data, ignoring CRLF, down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */

    /*	Push text from telnet socket down sink
    **
    **	@@@@@@@@@@ To push strings could be faster? (especially is we
    **	cheat and don't ignore CR! :-}
    */
d1197 1
a1197 1
	(*targetClass.put_character)(sink, UCH(character));
d1202 38
a1239 39
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**   The file number given is assumed to be a TELNET stream ie containing
**   CRLF at the end of lines which need to be stripped to LF for unix
**   when the format is textual.
**
**  State of socket and target stream on entry:
**			socket (file_number) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	HT_INTERRUPTED  Interruption or error after some data received.
**	-501		Stream stack failed (cannot present or convert).
**	-2		Unexpected disconnect before any data received.
**	-1		Stream stack failed (cannot present or convert), or
**			Interruption or error before any data received, or
**			(UNIX) other read error before any data received, or
**			download cancelled.
**	HT_LOADED	Normal close of socket (end of file indication
**			received), or
**			unexpected disconnect after some data received, or
**			other read error after some data received, or
**			(not UNIX) other read error before any data received.
**
**  State of socket and target stream on return depends on return value:
**	HT_INTERRUPTED	socket still open, target aborted.
**	-501		socket still open, target stream NULL.
**	-2		socket still open, target freed.
**	-1		socket still open, target stream aborted or NULL.
**	otherwise	socket closed,	target stream freed.
*/
int HTParseSocket (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	int			file_number,
	HTStream*		sink)
d1241 1
a1241 1
    HTStream * stream;
d1249 1
d1255 1
a1255 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1257 1
a1257 1
	rv = HTLoadError(sink, 501, buffer); /* returns -501 */
d1261 2
a1262 2
	** Push the data, don't worry about CRLF we can strip them later.
	*/
d1266 1
a1266 1
	    (*targetClass._free)(stream);
d1273 27
a1299 28
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**   The file number given is assumed to be a TELNET stream ie containing
**   CRLF at the end of lines which need to be stripped to \n for unix
**   when the format is textual.
**
**  State of file and target stream on entry:
**			FILE* (fp) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	-1		Download cancelled.
**	HT_NO_DATA	Error before any data read.
**	HT_PARTIAL_CONTENT	Interruption or error after some data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		fp still open; target freed, aborted, or NULL.
*/
int HTParseFile (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	FILE *			fp,
	HTStream*		sink)
d1301 1
a1301 1
    HTStream * stream;
d1305 1
a1305 1
#ifdef SH_EX		/* 1998/01/04 (Sun) 16:04:09 */
d1314 1
d1320 1
a1320 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1327 7
a1333 6
    /*	Push the data down the stream
    **
    **	@@@@  Bug:  This decision ought to be made based on "encoding"
    **	rather than on content-type.  @@@@@@  When we handle encoding.
    **	The current method smells anyway.
    */
d1337 1
a1337 1
	(*targetClass._abort)(stream, NULL);
d1339 1
a1339 1
	(*targetClass._free)(stream);
d1352 20
a1371 21
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**  State of memory and target stream on entry:
**			HTChunk* (chunk) assumed valid,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	HT_LOADED	All data sent.
**
**  State of memory and target stream on return:
**	always		chunk unchanged; target freed, aborted, or NULL.
*/
int HTParseMem (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	HTChunk *		chunk,
	HTStream *		sink)
d1373 1
a1373 1
    HTStream * stream;
d1380 1
d1390 1
a1390 1
    */
d1393 1
a1393 1
    (*targetClass._free)(stream);
d1399 1
a1399 2
static int HTCloseGzFile (
	gzFile			gzfp)
d1402 1
d1413 1
a1413 1
    return(gzres);
d1417 20
a1436 21
**
**  State of file and target stream on entry:
**			gzFile (gzfp) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	-1		Download cancelled.
**	HT_NO_DATA	Error before any data read.
**	HT_PARTIAL_CONTENT	Interruption or error after some data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		gzfp closed; target freed, aborted, or NULL.
*/
int HTParseGzFile (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	gzFile			gzfp,
	HTStream*		sink)
d1438 1
a1438 1
    HTStream * stream;
d1446 1
d1453 1
a1453 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1460 7
a1466 6
    /*	Push the data down the stream
    **
    **	@@@@  Bug:  This decision ought to be made based on "encoding"
    **	rather than on content-type.  @@@@@@  When we handle encoding.
    **	The current method smells anyway.
    */
d1470 1
a1470 1
	(*targetClass._abort)(stream, NULL);
d1472 1
a1472 1
	(*targetClass._free)(stream);
d1486 1
a1486 2
static void HTCloseBzFile (
	BZFILE *		bzfp)
d1493 20
a1512 21
**
**  State of file and target stream on entry:
**			bzFile (bzfp) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	-1		Download cancelled.
**	HT_NO_DATA	Error before any data read.
**	HT_PARTIAL_CONTENT	Interruption or error after some data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		bzfp closed; target freed, aborted, or NULL.
*/
int HTParseBzFile (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	BZFILE*		bzfp,
	HTStream*		sink)
d1514 1
a1514 1
    HTStream * stream;
d1522 1
d1529 1
a1529 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1536 7
a1542 6
    /*	Push the data down the stream
    **
    **	@@@@  Bug:  This decision ought to be made based on "encoding"
    **	rather than on content-type.  @@@@@@  When we handle encoding.
    **	The current method smells anyway.
    */
d1546 1
a1546 1
	(*targetClass._abort)(stream, NULL);
d1548 1
a1548 1
	(*targetClass._free)(stream);
d1562 8
a1569 8
**	-----------------------------------------------------------
**
**	The input is assumed to be in ASCII, with lines delimited
**	by (13,10) pairs, These pairs are converted into (CR,LF)
**	pairs in the local representation.  The (CR,LF) sequence
**	when found is changed to a '\n' character, the internal
**	C representation of a new line.
*/
d1571 1
a1571 1
static void NetToText_put_character (HTStream *  me, char  net_char)
d1574 1
d1581 1
a1581 1
	    me->sink->isa->put_character(me->sink, CR); /* leftover */
d1586 1
a1586 1
	me->sink->isa->put_character(me->sink, c);		/* normal */
d1589 1
a1589 1
static void NetToText_put_string (HTStream *  me, const char *  s)
d1591 1
a1591 1
    const char * p;
d1597 1
a1597 1
static void NetToText_put_block (HTStream * me, const char* s, int l)
d1599 1
a1599 1
    const char * p;
d1601 1
a1601 1
    for (p = s; p < (s+l); p++)
d1605 1
a1605 1
static void NetToText_free (HTStream *  me)
d1607 1
a1607 1
    (me->sink->isa->_free)(me->sink);		/* Close rest of pipe */
d1611 1
a1611 1
static void NetToText_abort (HTStream *  me, HTError  e)
d1613 1
a1613 1
    me->sink->isa->_abort(me->sink,e);		/* Abort rest of pipe */
d1619 2
a1620 1
static HTStreamClass NetToTextClass = {
d1631 1
a1631 1
HTStream * HTNetToText (HTStream *  sink)
d1633 1
a1633 1
    HTStream* me = typecalloc(HTStream);
d1644 2
a1645 1
static HTStream	HTBaseStreamInstance;		      /* Made static */
d1647 6
a1652 6
**	ERROR STREAM
**	------------
**	There is only one error stream shared by anyone who wants a
**	generic error returned from all stream methods.
*/
static void HTErrorStream_put_character (HTStream *  me GCC_UNUSED, char  c GCC_UNUSED)
d1657 1
a1657 1
static void HTErrorStream_put_string (HTStream *  me GCC_UNUSED, const char *  s)
d1663 1
a1663 1
static void HTErrorStream_write (HTStream * me GCC_UNUSED, const char * s, int l)
d1669 1
a1669 1
static void HTErrorStream_free (HTStream *  me GCC_UNUSED)
d1674 1
a1674 1
static void HTErrorStream_abort (HTStream *  me GCC_UNUSED, HTError  e GCC_UNUSED)
d1689 1
a1689 1
HTStream * HTErrorStream (void)
d1692 1
a1692 1
    HTBaseStreamInstance.isa = &HTErrorStreamClass;    /* The rest is random */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d19 3
a21 3
PUBLIC float HTMaxSecs = 1e10;		/* No effective limit */
PUBLIC float HTMaxLength = 1e10;	/* No effective limit */
PUBLIC long int HTMaxBytes  = 0;	/* No effective limit */
d57 1
a57 1
PUBLIC	BOOL HTOutputSource = NO;	/* Flag: shortcut parser to stdout */
d61 1
a61 1
      CONST HTStreamClass*	isa;
d68 1
a68 1
	CONST HTStreamClass *	isa;
d76 2
a77 2
PUBLIC	HTList * HTPresentations = NULL;
PUBLIC	HTPresentation * default_presentation = NULL;
d83 1
a83 1
PRIVATE void HTFreePresentations NOPARAMS;
d89 7
a95 7
PUBLIC void HTSetPresentation ARGS6(
	CONST char *,	representation,
	CONST char *,	command,
	double,		quality,
	double,		secs,
	double,		secs_per_byte,
	long int,	maxbytes)
d133 8
a140 8
PUBLIC void HTSetConversion ARGS7(
	CONST char *,	representation_in,
	CONST char *,	representation_out,
	HTConverter*,	converter,
	float,		quality,
	float,		secs,
	float,		secs_per_byte,
	long int,	maxbytes)
d180 1
a180 1
PRIVATE void HTFreePresentations NOARGS
d214 4
a217 4
PRIVATE char input_buffer[INPUT_BUFFER_SIZE];
PRIVATE char * input_pointer;
PRIVATE char * input_limit;
PRIVATE int input_file_number;
d225 1
a225 1
PUBLIC void HTInitInput ARGS1 (int,file_number)
d231 2
a232 2
PUBLIC int interrupted_in_htgetcharacter = 0;
PUBLIC int HTGetCharacter NOARGS
d262 1
a262 1
PUBLIC char HTGetSSLCharacter ARGS1(void *, handle)
d297 1
a297 1
PRIVATE int half_match ARGS2(char *,trial_type, char *,target)
d328 4
a331 4
PRIVATE HTPresentation * HTFindPresentation ARGS3(
	HTFormat,		rep_in,
	HTFormat,		rep_out,
	HTPresentation*,	fill_in)
d428 5
a432 5
PUBLIC HTStream * HTStreamStack ARGS4(
	HTFormat,		rep_in,
	HTFormat,		rep_out,
	HTStream*,		sink,
	HTParentAnchor*,	anchor)
d482 3
a484 3
PUBLIC void HTReorderPresentation ARGS2(
	HTFormat,		rep_in,
	HTFormat,		rep_out)
d497 1
a497 1
PUBLIC void HTFilterPresentations NOARGS
d550 5
a554 5
PUBLIC float HTStackValue ARGS4(
	HTFormat,		rep_in,
	HTFormat,		rep_out,
	float,			initial_value,
	long int,		length)
d595 1
a595 1
PUBLIC void HTDisplayPartial NOARGS
d638 1
a638 1
PUBLIC void HTFinishDisplayPartial NOARGS
d680 5
a684 5
PUBLIC int HTCopy ARGS4(
	HTParentAnchor *,	anchor,
	int,			file_number,
	void*,			handle GCC_UNUSED,
	HTStream*,		sink)
d862 3
a864 3
PUBLIC int HTFileCopy ARGS2(
	FILE *,			fp,
	HTStream*,		sink)
d937 3
a939 3
PUBLIC int HTMemCopy ARGS2(
	HTChunk *,		chunk,
	HTStream *,		sink)
d943 1
a943 1
    CONST char *data = chunk->data;
d1000 3
a1002 3
PRIVATE int HTGzFileCopy ARGS2(
	gzFile,			gzfp,
	HTStream*,		sink)
d1081 3
a1083 3
PRIVATE int HTBzFileCopy ARGS2(
	BZFILE *,		bzfp,
	HTStream*,		sink)
d1148 4
a1151 4
PUBLIC void HTCopyNoCR ARGS3(
	HTParentAnchor *,	anchor GCC_UNUSED,
	int,			file_number,
	HTStream*,		sink)
d1208 6
a1213 6
PUBLIC int HTParseSocket ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	int,			file_number,
	HTStream*,		sink)
d1268 6
a1273 6
PUBLIC int HTParseFile ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	FILE *,			fp,
	HTStream*,		sink)
d1339 6
a1344 6
PUBLIC int HTParseMem ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	HTChunk *,		chunk,
	HTStream *,		sink)
d1371 2
a1372 2
PRIVATE int HTCloseGzFile ARGS1(
	gzFile,			gzfp)
d1404 6
a1409 6
PUBLIC int HTParseGzFile ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	gzFile,			gzfp,
	HTStream*,		sink)
d1457 2
a1458 2
PRIVATE void HTCloseBzFile ARGS1(
	BZFILE *,		bzfp)
d1480 6
a1485 6
PUBLIC int HTParseBzFile ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	BZFILE*,		bzfp,
	HTStream*,		sink)
d1542 1
a1542 1
PRIVATE void NetToText_put_character ARGS2(HTStream *, me, char, net_char)
d1559 1
a1559 1
PRIVATE void NetToText_put_string ARGS2(HTStream *, me, CONST char *, s)
d1561 1
a1561 1
    CONST char * p;
d1567 1
a1567 1
PRIVATE void NetToText_put_block ARGS3(HTStream *, me, CONST char*, s, int, l)
d1569 1
a1569 1
    CONST char * p;
d1575 1
a1575 1
PRIVATE void NetToText_free ARGS1(HTStream *, me)
d1581 1
a1581 1
PRIVATE void NetToText_abort ARGS2(HTStream *, me, HTError, e)
d1589 1
a1589 1
PRIVATE HTStreamClass NetToTextClass = {
d1600 1
a1600 1
PUBLIC HTStream * HTNetToText ARGS1(HTStream *, sink)
d1613 1
a1613 1
PRIVATE HTStream	HTBaseStreamInstance;		      /* Made static */
d1620 1
a1620 1
PRIVATE void HTErrorStream_put_character ARGS2(HTStream *, me GCC_UNUSED, char, c GCC_UNUSED)
d1625 1
a1625 1
PRIVATE void HTErrorStream_put_string ARGS2(HTStream *, me GCC_UNUSED, CONST char *, s)
d1631 1
a1631 1
PRIVATE void HTErrorStream_write ARGS3(HTStream *, me GCC_UNUSED, CONST char *, s, int, l)
d1637 1
a1637 1
PRIVATE void HTErrorStream_free ARGS1(HTStream *, me GCC_UNUSED)
d1642 1
a1642 1
PRIVATE void HTErrorStream_abort ARGS2(HTStream *, me GCC_UNUSED, HTError, e GCC_UNUSED)
d1647 1
a1647 1
PRIVATE CONST HTStreamClass HTErrorStreamClass =
d1657 1
a1657 1
PUBLIC HTStream * HTErrorStream NOARGS
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d920 1
a920 1
#ifdef SOURCE_CACHE
d1060 77
d1322 1
a1322 1
#ifdef SOURCE_CACHE
d1455 76
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a18 6
#ifdef USE_SSL
#define free_func free__func
#include <openssl/ssl.h>
#undef free_func
#endif /* USE_SSL */

d23 1
a23 1
#ifdef unix
d30 1
a30 1
#endif /* unix */
d39 1
d53 4
a57 1
/* extern  BOOL interactive; LJM */
d92 3
a94 3
	float,		quality,
	float,		secs,
	float,		secs_per_byte,
d97 1
a97 1
    HTPresentation * pres = (HTPresentation *)malloc(sizeof(HTPresentation));
d104 3
a106 3
    pres->quality = quality;
    pres->secs = secs;
    pres->secs_per_byte = secs_per_byte;
d142 1
a142 1
    HTPresentation * pres = (HTPresentation *)malloc(sizeof(HTPresentation));
d244 1
a244 1
		    CTRACE(tfp, "HTFormat: Interrupted in HTGetCharacter\n");
d248 1
a248 1
		CTRACE(tfp, "HTFormat: File read error %d\n", status);
d258 1
a258 1
    return FROMASCII((unsigned char)ch);
d276 1
a276 1
		    CTRACE(tfp, "HTFormat: Interrupted in HTGetSSLCharacter\n");
d280 1
a280 1
		CTRACE(tfp, "HTFormat: SSL_read error %d\n", status);
d299 1
a299 1
    char *cp=strchr(trial_type,'/');
d305 2
a306 2
    CTRACE(tfp, "HTFormat: comparing %s and %s for half match\n",
		trial_type, target);
d315 2
d333 1
a333 1
    HTAtom * wildcard = HTAtom_for("*");
d335 2
a336 2
    CTRACE(tfp, "HTFormat: Looking up presentation for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out));
d354 2
a355 2
		    CTRACE(tfp, "FindPresentation: found exact match: %s\n",
				HTAtom_name(pres->rep));
d360 9
a368 6
		} else if (pres->rep_out == wildcard) {
		    if (!strong_wildcard_match)
			strong_wildcard_match = pres;
		    /* otherwise use the first one */
		    CTRACE(tfp, "StreamStack: found strong wildcard match: %s\n",
				HTAtom_name(pres->rep));
d380 2
a381 2
		    CTRACE(tfp, "StreamStack: found strong subtype wildcard match: %s\n",
				HTAtom_name(pres->rep));
d390 6
a395 5
		    CTRACE(tfp, "StreamStack: found weak wildcard match: %s\n",
				HTAtom_name(pres->rep_out));
		}
		if (pres->rep_out == wildcard) {
		    if (!last_default_match)
d436 1
d438 2
a439 2
    CTRACE(tfp, "HTFormat: Constructing stream stack for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out));
d443 2
a444 1
     *//*
d446 2
a447 1
	return sink;  LJM */
d449 2
a450 2
    if (rep_out == rep_in)
	return sink;
d452 1
a452 1
    if ((match = HTFindPresentation(rep_in, rep_out, &temp))) {
d454 1
a454 1
	    CTRACE(tfp, "StreamStack: Using %s\n", HTAtom_name(temp.rep_out));
d456 2
a457 2
	    CTRACE(tfp, "StreamStack: found exact match: %s\n",
			HTAtom_name(match->rep));
d459 1
a459 1
	return (*match->converter)(match, anchor, sink);
d461 11
a471 1
	return NULL;
d473 1
d492 50
d556 1
a556 1
    HTAtom * wildcard = HTAtom_for("*");
d558 2
a559 2
    CTRACE(tfp, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
		HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out));
d584 1
a584 1
    return -1e30;		/* Really bad */
d600 1
a600 1
	**  HText_getNumOfLines() = "current" number of lines received
d602 1
d604 3
a606 5
	**  We update NumOfLines_partial only when we repaint the display.
	**  -1 is the special value:
	**  This is a synchronization flag switched to 0 when HText_new()
	**  starts a new HTMainText object - all HText_ functions use it,
	**  lines counter in particular [we call it from HText_getNumOfLines()].
d615 3
a617 3
	if ((NumOfLines_partial != -1)
		/* new HText object available  */
	&& ((Newline_partial + display_lines) > NumOfLines_partial)
d620 2
a621 2
		((Newline_partial + partial_threshold) < HText_getNumOfLines()) :
		((Newline_partial + display_lines) < HText_getNumOfLines()))
d629 2
a630 2
	    NumOfLines_partial = HText_getNumOfLines();
	    HText_pageDisplay(Newline_partial, "");
a640 10
		    if (display_partial) {
			/*
			 *  Override Newline with a new value if user
			 *  scrolled the document while downloading.
			 */
			if (Newline_partial != Newline
			 && NumOfLines_partial > 0)
			    Newline = Newline_partial;
		    }

a644 4
		    NumOfLines_partial = -1;       /* initialize to -1 */
				/* -1 restrict HTDisplayPartial()   */
				/* until HText_new() start next HTMainText */
				/* and set the flag to 0  */
d687 1
d741 3
d765 4
a768 4
		    HTInetStatus("NETREAD");
		    HTAlert("Unexpected server disconnect.");
		   CTRACE(tfp,
	    "HTCopy: Unexpected server disconnect. Treating as completed.\n");
d776 2
a777 2
		   CTRACE(tfp,
	    "HTCopy: Unexpected server disconnect.  Treating as completed.\n");
d806 10
d827 2
a828 1
	HTReadProgress(bytes, anchor ? anchor->content_length : 0);
d884 2
a885 2
	    CTRACE(tfp, "HTFormat: Read error, read returns %d\n",
			ferror(fp));
d897 7
a903 1
	HTDisplayPartial();
d941 1
a941 1
    HTStreamClass targetClass = *(sink->isa);
d946 1
d1023 4
a1026 4
	    CTRACE(tfp, "HTGzFileCopy: Read error, gzread returns %d\n",
			status);
	    CTRACE(tfp, "gzerror   : %s\n",
			gzerror(gzfp, &gzerrnum));
d1077 1
a1077 1
    char character;
d1091 1
a1091 1
	if (character == (char)EOF)
d1093 1
a1093 1
	(*targetClass.put_character)(sink, character);
d1152 1
a1152 1
	CTRACE(tfp, "HTFormat: %s\n", buffer);
d1202 6
a1207 3
    stream = HTStreamStack(rep_in,
			format_out,
			sink , anchor);
d1217 1
a1217 1
	CTRACE(tfp, "HTFormat(in HTParseFile): %s\n", buffer);
d1259 1
a1259 1
**  Stat of memory and target stream on return:
d1278 1
a1278 1
	CTRACE(tfp, "HTFormat(in HTParseMem): %s\n", buffer);
d1305 1
a1305 1
	    CTRACE(tfp, "gzclose   : error number %d\n", gzres);
d1338 1
a1338 3
    stream = HTStreamStack(rep_in,
			format_out,
			sink , anchor);
d1349 1
a1349 1
	CTRACE(tfp, "HTFormat(in HTParseGzFile): %s\n", buffer);
d1401 1
a1401 1
    me->had_cr = (c == CR);
d1449 1
a1449 1
    HTStream* me = (HTStream*)malloc(sizeof(*me));
d1460 50
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 10
a11 10
 *		=============================
 *
 * Bugs:
 *	Not reentrant.
 *
 *	Assumes the incoming stream is ASCII, rather than a local file
 *	format, and so ALWAYS converts from ASCII on non-ASCII machines.
 *	Therefore, non-ASCII machines can't read local files.
 *
 */
d19 9
a27 1
static float HTMaxSecs = 1e10;	/* No effective limit */
d29 1
a29 1
#ifdef UNIX
d36 1
a36 1
#endif /* UNIX */
a44 1
#include <HTTP.h>
d58 2
a59 5
#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif

BOOL HTOutputSource = NO;	/* Flag: shortcut parser to stdout */
d63 2
a64 2
    const HTStreamClass *isa;
    /* ... */
d70 3
a72 3
    const HTStreamClass *isa;
    BOOL had_cr;
    HTStream *sink;
d76 4
a79 4
 *	--------------------
 */
HTList *HTPresentations = NULL;
HTPresentation *default_presentation = NULL;
d85 1
a85 1
static void HTFreePresentations(void);
d89 9
a97 10
 *	-------------------------------------------------------
 */
void HTSetPresentation(const char *representation,
		       const char *command,
		       const char *testcommand,
		       double quality,
		       double secs,
		       double secs_per_byte,
		       long int maxbytes,
		       AcceptMedia media)
d99 1
a99 2
    HTPresentation *pres = typecalloc(HTPresentation);

d104 5
a108 5
    pres->rep_out = WWW_PRESENT;	/* Fixed for now ... :-) */
    pres->converter = HTSaveAndExecute;		/* Fixed for now ...     */
    pres->quality = (float) quality;
    pres->secs = (float) secs;
    pres->secs_per_byte = (float) secs_per_byte;
a109 3
    pres->get_accept = 0;
    pres->accept_opt = media;

a112 3
    pres->testcommand = NULL;
    StrAllocCopy(pres->testcommand, testcommand);

d114 2
a115 2
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d117 1
a117 1
    if (!HTPresentations) {
d124 1
a124 1
    if (strcmp(representation, "*") == 0) {
d133 10
a142 10
 *	---------------------------------------------
 */
void HTSetConversion(const char *representation_in,
		     const char *representation_out,
		     HTConverter *converter,
		     float quality,
		     float secs,
		     float secs_per_byte,
		     long int maxbytes,
		     AcceptMedia media)
d144 1
a144 2
    HTPresentation *pres = typecalloc(HTPresentation);

d151 1
a151 2
    pres->command = NULL;
    pres->testcommand = NULL;
d156 1
a156 2
    pres->get_accept = TRUE;
    pres->accept_opt = media;
d159 2
a160 2
     * Memory Leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d162 1
a162 1
    if (!HTPresentations) {
d174 9
a182 9
 *	Purpose:	Free the presentation list.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		Made to clean up Lynx's bad leakage.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void HTFreePresentations(void)
d184 1
a184 1
    HTPresentation *pres = NULL;
d187 1
a187 1
     * Loop through the list.
d191 3
a193 2
	 * Free off each item.  May also need to free off it's items, but not
	 * sure as of yet.
d195 1
a195 1
	pres = (HTPresentation *) HTList_removeLastObject(HTPresentations);
a196 1
	FREE(pres->testcommand);
d200 1
a200 1
     * Free the list itself.
d208 12
a219 12
 *	--------------
 *
 *	The input file is read using the macro which can read from
 *	a socket or a file.
 *	The input buffer size, if large will give greater efficiency and
 *	release the server faster, and if small will save space on PCs etc.
 */
#define INPUT_BUFFER_SIZE 4096	/* Tradeoff */
static char input_buffer[INPUT_BUFFER_SIZE];
static char *input_pointer;
static char *input_limit;
static int input_file_number;
d222 6
a227 6
 *
 *	These routines are public because they are in fact needed by
 *	many parsers, and on PCs and Macs we should not duplicate
 *	the static buffer area.
 */
void HTInitInput(int file_number)
d233 2
a234 2
int interrupted_in_htgetcharacter = 0;
int HTGetCharacter(void)
a236 1

a241 1

d246 1
a246 1
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetCharacter\n"));
d250 3
a252 3
		CTRACE((tfp, "HTFormat: File read error %d\n", status));
		return EOF;	/* -1 is returned by UCX
				   at end of HTTP link */
d258 1
a258 1
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */
d260 1
a260 1
    return FROMASCII(UCH(ch));
d264 1
a264 1
char HTGetSSLCharacter(void *handle)
a266 1

d268 2
a269 2
    if (!handle)
	return (char) EOF;
d272 2
a273 3
	    int status = SSL_read((SSL *) handle,
				  input_buffer, INPUT_BUFFER_SIZE);

d276 1
a276 1
		    return (char) EOF;
d278 1
a278 2
		    CTRACE((tfp,
			    "HTFormat: Interrupted in HTGetSSLCharacter\n"));
d280 1
a280 1
		    return (char) EOF;
d282 3
a284 3
		CTRACE((tfp, "HTFormat: SSL_read error %d\n", status));
		return (char) EOF;	/* -1 is returned by UCX
					   at end of HTTP link */
d290 1
a290 1
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */
d296 2
a297 2
/* Match maintype to any MIME type starting with maintype, for example: 
 * image/gif should match image
d299 1
a299 1
static int half_match(char *trial_type, char *target)
d301 1
a301 1
    char *cp = strchr(trial_type, '/');
d304 1
a304 1
    if (!cp || *(cp + 1) != '*')
d307 2
a308 2
    CTRACE((tfp, "HTFormat: comparing %s and %s for half match\n",
	    trial_type, target));
d310 2
a311 2
    /* main type matches */
    if (!strncmp(trial_type, target, (cp - trial_type) - 1))
d317 15
a331 5
/*
 * Evaluate a deferred mailcap test command, i.e.,. one that substitutes the
 * document's charset or other values in %{name} format.
 */
static BOOL failsMailcap(HTPresentation *pres, HTParentAnchor *anchor)
d333 16
a348 7
    if (pres->testcommand != 0) {
	if (LYTestMailcapCommand(pres->testcommand,
				 anchor->content_type_params) != 0)
	    return TRUE;
    }
    return FALSE;
}
d350 7
a356 1
#define WWW_WILDCARD_REP_OUT HTAtom_for("*")
d358 1
a358 35
/*		Look up a presentation
 *		----------------------
 *
 *	If fill_in is NULL, only look for an exact match.
 *	If a wildcard match is made, *fill_in is used to store
 *	a possibly modified presentation, and a pointer to it is
 *	returned.  For an exact match, a pointer to the presentation
 *	in the HTPresentations list is returned.  Returns NULL if
 *	nothing found. - kw
 *
 */
static HTPresentation *HTFindPresentation(HTFormat rep_in,
					  HTFormat rep_out,
					  HTPresentation *fill_in,
					  HTParentAnchor *anchor)
{
    HTAtom *wildcard = NULL;	/* = HTAtom_for("*"); lookup when needed - kw */
    int n;
    int i;
    HTPresentation *pres;
    HTPresentation *match;
    HTPresentation *strong_wildcard_match = 0;
    HTPresentation *weak_wildcard_match = 0;
    HTPresentation *last_default_match = 0;
    HTPresentation *strong_subtype_wildcard_match = 0;

    CTRACE((tfp, "HTFormat: Looking up presentation for %s to %s\n",
	    HTAtom_name(rep_in), HTAtom_name(rep_out)));

    n = HTList_count(HTPresentations);
    for (i = 0; i < n; i++) {
	pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (pres->rep == rep_in) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
d360 1
a360 12
		CTRACE((tfp, "FindPresentation: found exact match: %s\n",
			HTAtom_name(pres->rep)));
		return pres;

	    } else if (!fill_in) {
		continue;
	    } else {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
		if (pres->rep_out == wildcard) {
		    if (failsMailcap(pres, anchor))
			continue;
d364 2
a365 3
		    CTRACE((tfp,
			    "StreamStack: found strong wildcard match: %s\n",
			    HTAtom_name(pres->rep)));
a366 1
	    }
d368 2
a369 2
	} else if (!fill_in) {
	    continue;
d371 9
a379 11
	} else if (half_match(HTAtom_name(pres->rep),
			      HTAtom_name(rep_in))) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!strong_subtype_wildcard_match)
		    strong_subtype_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found strong subtype wildcard match: %s\n",
			HTAtom_name(pres->rep)));
a380 1
	}
d382 8
a389 14
	if (pres->rep == WWW_SOURCE) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!weak_wildcard_match)
		    weak_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found weak wildcard match: %s\n",
			HTAtom_name(pres->rep_out)));

	    } else if (!last_default_match) {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
d391 2
a392 3
		    if (failsMailcap(pres, anchor))
			continue;
		    last_default_match = pres;
a396 1
    }
d398 11
a408 13
    match = (strong_subtype_wildcard_match
	     ? strong_subtype_wildcard_match
	     : (strong_wildcard_match
		? strong_wildcard_match
		: (weak_wildcard_match
		   ? weak_wildcard_match
		   : last_default_match)));

    if (match) {
	*fill_in = *match;	/* Specific instance */
	fill_in->rep = rep_in;	/* yuk */
	fill_in->rep_out = rep_out;	/* yuk */
	return fill_in;
d415 14
a428 13
 *		---------------------
 *
 *	If a wildcard match is made, a temporary HTPresentation
 *	structure is made to hold the destination format while the
 *	new stack is generated. This is just to pass the out format to
 *	MIME so far.  Storing the format of a stream in the stream might
 *	be a lot neater.
 *
 */
HTStream *HTStreamStack(HTFormat rep_in,
			HTFormat rep_out,
			HTStream *sink,
			HTParentAnchor *anchor)
a431 1
    HTStream *result;
d433 2
a434 4
    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s (%s)\n",
	    HTAtom_name(rep_in),
	    HTAtom_name(rep_out),
	    NONNULL(anchor->content_type_params)));
d438 1
a438 2
     */
#if 0
d440 1
a440 2
	return sink;		/*  LJM */
#endif
d442 2
a443 2
    if (rep_out == rep_in) {
	result = sink;
d445 1
a445 1
    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp, anchor))) {
d447 1
a447 1
	    CTRACE((tfp, "StreamStack: Using %s\n", HTAtom_name(temp.rep_out)));
d449 2
a450 2
	    CTRACE((tfp, "StreamStack: found exact match: %s\n",
		    HTAtom_name(match->rep)));
d452 1
a452 1
	result = (*match->converter) (match, anchor, sink);
d454 1
a454 1
	result = NULL;
a455 11
    if (TRACE) {
	if (result && result->isa && result->isa->name) {
	    CTRACE((tfp, "StreamStack: Returning \"%s\"\n", result->isa->name));
	} else if (result) {
	    CTRACE((tfp, "StreamStack: Returning *unknown* stream!\n"));
	} else {
	    CTRACE((tfp, "StreamStack: Returning NULL!\n"));
	    CTRACE_FLUSH(tfp);	/* a crash may be imminent... - kw */
	}
    }
    return result;
d459 8
a466 7
 *		-------------------------------------
 *
 *	Look up a presentation (exact match only) and, if found, reorder
 *	it to the start of the HTPresentations list. - kw
 */
void HTReorderPresentation(HTFormat rep_in,
			   HTFormat rep_out)
d469 1
a469 2

    if ((match = HTFindPresentation(rep_in, rep_out, NULL, NULL))) {
a473 41

/*
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
void HTFilterPresentations(void)
{
    int i, j;
    int n = HTList_count(HTPresentations);
    HTPresentation *p, *q;
    BOOL matched;
    char *s, *t;

    CTRACE((tfp, "HTFilterPresentations (AcceptMedia %#x)\n", LYAcceptMedia));
    for (i = 0; i < n; i++) {
	p = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	s = HTAtom_name(p->rep);

	p->get_accept = FALSE;
	if ((LYAcceptMedia & p->accept_opt) != 0
	    && p->rep_out == WWW_PRESENT
	    && p->rep != WWW_SOURCE
	    && strcasecomp(s, "www/mime")
	    && strcasecomp(s, "www/compressed")
	    && p->quality <= 1.0 && p->quality >= 0.0) {
	    matched = TRUE;
	    for (j = 0; j < i; j++) {
		q = (HTPresentation *) HTList_objectAt(HTPresentations, j);
		t = HTAtom_name(q->rep);

		if (!strcasecomp(s, t)) {
		    matched = FALSE;
		    CTRACE((tfp, "  match %s %s\n", s, t));
		    break;
		}
	    }
	    p->get_accept = matched;
	}
    }
}

d475 12
a486 11
 *		-------------------------------
 *
 *	Must return the cost of the same stack which StreamStack would set up.
 *
 * On entry,
 *	length	The size of the data to be converted
 */
float HTStackValue(HTFormat rep_in,
		   HTFormat rep_out,
		   float initial_value,
		   long int length)
d488 1
a488 1
    HTAtom *wildcard = WWW_WILDCARD_REP_OUT;
d490 2
a491 2
    CTRACE((tfp, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
	    HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));
d496 3
d502 1
a502 2
	HTPresentation *pres;

d504 1
a504 1
	    pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
a507 1

d509 2
a510 2
		    value = value - (length * pres->secs_per_byte + pres->secs)
			/ HTMaxSecs;
d516 1
a516 1
    return (float) -1e30;	/* Really bad */
d521 7
a527 7
 *	-------------------------------------------
 *
 *   Repaint the page only when necessary.
 *   This is a traverse call for HText_pageDisplay() - it works!.
 *
 */
void HTDisplayPartial(void)
d532 32
a563 32
	 * HText_getNumOfLines() = "current" number of complete lines received
	 * NumOfLines_partial = number of lines at the moment of last repaint. 
	 * (we update NumOfLines_partial only when we repaint the display.)
	 *
	 * display_partial could only be enabled in HText_new() so a new
	 * HTMainText object available - all HText_ functions use it, lines
	 * counter HText_getNumOfLines() in particular.
	 *
	 * Otherwise HTMainText holds info from the previous document and we
	 * may repaint it instead of the new one:  prev doc scrolled to the
	 * first line (=Newline_partial) is not good looking :-) 23 Aug 1998
	 * Leonid Pauzner
	 *
	 * So repaint the page only when necessary:
	 */
	int Newline_partial = LYGetNewline();

	if (((Newline_partial + display_lines) - 1 > NumOfLines_partial)
	/* current page not complete... */
	    && (partial_threshold > 0 ?
		((Newline_partial + partial_threshold) - 1 <=
		 HText_getNumOfLines()) :
		((Newline_partial + display_lines) - 1 <= HText_getNumOfLines()))
	/*
	 * Originally we rendered by increments of 2 lines,
	 * but that got annoying on slow network connections.
	 * Then we switched to full-pages.  Now it's configurable.
	 * If partial_threshold <= 0, then it's a full page
	 */
	    ) {
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
d567 1
a567 1
#endif /* DISP_PARTIAL */
d571 1
a571 1
void HTFinishDisplayPartial(void)
d574 18
a591 4
    /*
     * End of incremental rendering stage here.
     */
    display_partial = FALSE;
d596 36
a631 35
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream, i.e., containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-2		Unexpected disconnect before any data received.
 *	-1		Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-2		socket still open, target stream still valid.
 *	-1		socket still open, target aborted.
 *	otherwise	socket closed,	target stream still valid.
 */
int HTCopy(HTParentAnchor *anchor,
	   int file_number,
	   void *handle GCC_UNUSED,
	   HTStream *sink)
a633 1
    BOOL suppress_readprogress = NO;
d637 8
a644 9
    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*
     * Push binary from socket down sink
     *
     * This operation could be put into a main event loop
     */
d651 1
a651 1
	    (*targetClass._abort) (sink, NULL);
d657 2
a658 2
	    _HTProgress(TRANSFER_INTERRUPTED);
	    (*targetClass._abort) (sink, NULL);
d665 1
d668 1
a668 1
	    status = SSL_read((SSL *) handle, input_buffer, INPUT_BUFFER_SIZE);
d679 2
a680 2
		_HTProgress(TRANSFER_INTERRUPTED);
		(*targetClass._abort) (sink, NULL);
a686 3
#ifdef _WINDOWS			/* 1997/11/10 (Mon) 16:57:18 */
		       SOCKET_ERRNO == ETIMEDOUT ||
#endif
d690 1
a690 1
		 * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
d694 2
a695 2
		     * Don't have any data, so let the calling function decide
		     * what to do about it.  - FM
d701 7
a707 6
		    /*
		     * Treat what we've received already as the complete
		     * transmission, but not without giving the user an alert. 
		     * I don't know about all the different TCP stacks for VMS
		     * etc., so this is currently only for UNIX.  - kw
		     */
d710 13
a722 13
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
		    status = 0;
		    break;
#else /* !UNIX */
		    /*
		     * Treat what we've gotten already as the complete
		     * transmission.  - FM
		     */
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
		    status = 0;
		    break;
d728 5
a732 4
		 * Treat what we've received already as the complete
		 * transmission, but not without giving the user an alert.  I
		 * don't know about all the different TCP stacks for VMS etc.,
		 * so this is currently only for UNIX.  - kw
d737 1
a737 1
		    (void) NETCLOSE(file_number);
d740 1
a740 1
		    (*targetClass._abort) (sink, NULL);
a748 10
	/*
	 * Suppress ReadProgress messages when collecting a redirection
	 * message, at least initially (unless/until anchor->content_type gets
	 * changed, probably by the MIME message parser).  That way messages
	 * put up by the HTTP module or elsewhere can linger in the statusline
	 * for a while.  - kw
	 */
	suppress_readprogress = (anchor && anchor->content_type &&
				 !strcmp(anchor->content_type,
					 "message/x-http-redirection"));
d751 2
a752 3
	    char *p;

	    for (p = input_buffer; p < input_buffer + status; p++) {
d758 1
a758 1
	(*targetClass.put_block) (sink, input_buffer, status);
d760 1
a760 2
	if (!suppress_readprogress)
	    HTReadProgress(bytes, anchor ? anchor->content_length : 0);
d763 1
a763 1
    }				/* next bufferload */
d766 1
a766 1
    (void) NETCLOSE(file_number);
d769 1
a769 1
  finished:
d771 1
a771 1
    return (rv);
d775 22
a796 20
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open, target stream still valid.
 */
int HTFileCopy(FILE *fp, HTStream *sink)
d802 3
a804 3
    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */
d806 2
a807 2
    /*  Push binary from socket down sink
     */
d811 1
a811 1
	if (status == 0) {	/* EOF or error */
d816 2
a817 2
	    CTRACE((tfp, "HTFormat: Read error, read returns %d\n",
		    ferror(fp)));
d826 1
a826 1
	(*targetClass.put_block) (sink, input_buffer, status);
d829 1
a829 7
	/* Suppress last screen update in partial mode - a regular update under
	 * control of mainloop() should follow anyway.  - kw
	 */
#ifdef DISP_PARTIAL
	if (display_partial && bytes != HTMainAnchor->content_length)
	    HTDisplayPartial();
#endif
d832 1
a832 1
	    _HTProgress(TRANSFER_INTERRUPTED);
d840 1
a840 1
    }				/* next bufferload */
d846 1
a846 1
#ifdef USE_SOURCE_CACHE
d848 18
a865 16
 *	---------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) and target (sink) assumed valid.
 *
 *  Return values:
 *	HT_LOADED	All data sent.
 *	HT_INTERRUPTED  Interruption after some data read.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged, target stream still valid.
 */
int HTMemCopy(HTChunk *chunk, HTStream *sink)
d867 1
a867 1
    HTStreamClass targetClass;
d869 1
a869 1
    const char *data = chunk->data;
a871 1
    targetClass = *(sink->isa);
d875 2
a876 2
	 * running a large document on a slow machine.
	 */
a877 1

d882 1
a882 1
	(*targetClass.put_block) (sink, data, n);
d889 1
a889 1
	    _HTProgress(TRANSFER_INTERRUPTED);
d906 22
a927 20
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      gzFile (gzfp) assumed open (should have gzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp still open, target stream still valid.
 */
static int HTGzFileCopy(gzFile gzfp, HTStream *sink)
d934 3
a936 3
    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */
d938 2
a939 2
    /*  read and inflate gzip'd file, and push binary down sink
     */
d943 1
a943 1
	if (status <= 0) {	/* EOF or error */
d948 4
a951 4
	    CTRACE((tfp, "HTGzFileCopy: Read error, gzread returns %d\n",
		    status));
	    CTRACE((tfp, "gzerror   : %s\n",
		    gzerror(gzfp, &gzerrnum)));
d964 1
a964 1
	(*targetClass.put_block) (sink, input_buffer, status);
d970 1
a970 1
	    _HTProgress(TRANSFER_INTERRUPTED);
d978 1
a978 1
    }				/* next bufferload */
a982 116

/*	Push data from a deflate file pointer down a stream
 *	-------------------------------------
 *
 *  This routine is responsible for creating and PRESENTING any
 *  graphic (or other) objects described by the file.  The code is
 *  loosely based on the inflate.c file from w3m.
 *
 *
 *  State of file and target stream on entry:
 *		      FILE (zzfp) assumed open (should have deflated content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp still open, target stream still valid.
 */
static int HTZzFileCopy(FILE *zzfp, HTStream *sink)
{
    static char dummy_head[1 + 1] =
    {
	0x8 + 0x7 * 0x10,
	(((0x8 + 0x7 * 0x10) * 0x100 + 30) / 31 * 31) & 0xFF,
    };

    z_stream s;
    HTStreamClass targetClass;
    int bytes;
    int rv = HT_OK;
    char output_buffer[INPUT_BUFFER_SIZE];
    int status;
    int flush;
    int retry = 0;
    int len = 0;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    s.zalloc = Z_NULL;
    s.zfree = Z_NULL;
    s.opaque = Z_NULL;
    status = inflateInit(&s);
    if (status != Z_OK) {
	CTRACE((tfp, "HTZzFileCopy inflateInit() %s\n", zError(status)));
	exit_immediately(1);
    }
    s.avail_in = 0;
    s.next_out = (Bytef *) output_buffer;
    s.avail_out = sizeof(output_buffer);
    flush = Z_NO_FLUSH;

    /*  read and inflate deflate'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	if (s.avail_in == 0) {
	    s.next_in = (Bytef *) input_buffer;
	    len = s.avail_in = fread(input_buffer, 1, INPUT_BUFFER_SIZE, zzfp);
	}
	status = inflate(&s, flush);
	if (status == Z_STREAM_END || status == Z_BUF_ERROR) {
	    len = sizeof(output_buffer) - s.avail_out;
	    if (len > 0) {
		(*targetClass.put_block) (sink, output_buffer, len);
		bytes += len;
		HTReadProgress(bytes, -1);
		HTDisplayPartial();
	    }
	    rv = HT_LOADED;
	    break;
	} else if (status == Z_DATA_ERROR && !retry++) {
	    status = inflateReset(&s);
	    if (status != Z_OK) {
		CTRACE((tfp, "HTZzFileCopy inflateReset() %s\n", zError(status)));
		rv = bytes ? HT_PARTIAL_CONTENT : -1;
		break;
	    }
	    s.next_in = (Bytef *) dummy_head;
	    s.avail_in = sizeof(dummy_head);
	    status = inflate(&s, flush);
	    s.next_in = (Bytef *) input_buffer;
	    s.avail_in = len;
	    continue;
	} else if (status != Z_OK) {
	    CTRACE((tfp, "HTZzFileCopy inflate() %s\n", zError(status)));
	    rv = bytes ? HT_PARTIAL_CONTENT : -1;
	    break;
	} else if (s.avail_out == 0) {
	    len = sizeof(output_buffer);
	    s.next_out = (Bytef *) output_buffer;
	    s.avail_out = sizeof(output_buffer);

	    (*targetClass.put_block) (sink, output_buffer, len);
	    bytes += len;
	    HTReadProgress(bytes, -1);
	    HTDisplayPartial();

	    if (HTCheckForInterrupt()) {
		_HTProgress(TRANSFER_INTERRUPTED);
		rv = bytes ? HT_INTERRUPTED : -1;
		break;
	    }
	}
	retry = 1;
    }				/* next bufferload */

    inflateEnd(&s);
    HTFinishDisplayPartial();
    return rv;
}
a984 75
#ifdef USE_BZLIB
/*	Push data from a bzip file pointer down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      BZFILE (bzfp) assumed open (should have bzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp still open, target stream still valid.
 */
static int HTBzFileCopy(BZFILE * bzfp, HTStream *sink)
{
    HTStreamClass targetClass;
    int status, bytes;
    int bzerrnum;
    int rv = HT_OK;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*  read and inflate bzip'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	status = BZ2_bzread(bzfp, input_buffer, INPUT_BUFFER_SIZE);
	if (status <= 0) {	/* EOF or error */
	    if (status == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTBzFileCopy: Read error, bzread returns %d\n",
		    status));
	    CTRACE((tfp, "bzerror   : %s\n",
		    BZ2_bzerror(bzfp, &bzerrnum)));
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, -1);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    }				/* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}
#endif /* USE_BZLIB */

d986 14
a999 13
 *	--------------------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the socket.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 */
void HTCopyNoCR(HTParentAnchor *anchor GCC_UNUSED,
		int file_number,
		HTStream *sink)
d1002 1
a1002 5
    int character;

    /*  Push the data, ignoring CRLF, down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */
d1004 9
a1012 6
    /*
     * Push text from telnet socket down sink
     *
     * @@@@@@@@@@ To push strings could be faster?  (especially is we cheat and
     * don't ignore CR!  :-}
     */
d1016 1
a1016 1
	if (character == EOF)
d1018 1
a1018 1
	(*targetClass.put_character) (sink, UCH(character));
d1023 39
a1061 38
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-501		Stream stack failed (cannot present or convert).
 *	-2		Unexpected disconnect before any data received.
 *	-1		Stream stack failed (cannot present or convert), or
 *			Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-501		socket still open, target stream NULL.
 *	-2		socket still open, target freed.
 *	-1		socket still open, target stream aborted or NULL.
 *	otherwise	socket closed,	target stream freed.
 */
int HTParseSocket(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  int file_number,
		  HTStream *sink)
d1063 1
a1063 1
    HTStream *stream;
a1070 1

d1076 3
a1078 3
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat: %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);	/* returns -501 */
d1082 2
a1083 2
	 * Push the data, don't worry about CRLF we can strip them later.
	 */
d1087 1
a1087 1
	    (*targetClass._free) (stream);
d1094 28
a1121 27
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to \n for unix
 *   when the format is textual.
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open; target freed, aborted, or NULL.
 */
int HTParseFile(HTFormat rep_in,
		HTFormat format_out,
		HTParentAnchor *anchor,
		FILE *fp,
		HTStream *sink)
d1123 1
a1123 1
    HTStream *stream;
d1127 3
a1129 6
#ifdef SH_EX			/* 1998/01/04 (Sun) 16:04:09 */
    if (fp == NULL)
	return HT_LOADED;
#endif

    stream = HTStreamStack(rep_in, format_out, sink, anchor);
a1132 1

d1138 2
a1139 2
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseFile): %s\n", buffer));
d1145 6
a1150 7
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
d1154 1
a1154 1
	(*targetClass._abort) (stream, NULL);
d1156 1
a1156 1
	(*targetClass._free) (stream);
d1167 1
a1167 1
#ifdef USE_SOURCE_CACHE
d1169 21
a1189 20
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) assumed valid,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	HT_LOADED	All data sent.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged; target freed, aborted, or NULL.
 */
int HTParseMem(HTFormat rep_in,
	       HTFormat format_out,
	       HTParentAnchor *anchor,
	       HTChunk *chunk,
	       HTStream *sink)
d1191 1
a1191 1
    HTStream *stream;
a1197 1

d1200 1
a1200 1
	CTRACE((tfp, "HTFormat(in HTParseMem): %s\n", buffer));
d1207 1
a1207 1
     */
d1210 1
a1210 1
    (*targetClass._free) (stream);
d1216 2
a1217 1
static int HTCloseGzFile(gzFile gzfp)
a1219 1

d1227 1
a1227 1
	    CTRACE((tfp, "gzclose   : error number %d\n", gzres));
d1230 1
a1230 1
    return (gzres);
d1234 21
a1254 20
 *
 *  State of file and target stream on entry:
 *			gzFile (gzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp closed; target freed, aborted, or NULL.
 */
int HTParseGzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  gzFile gzfp,
		  HTStream *sink)
d1256 1
a1256 1
    HTStream *stream;
d1260 3
a1262 1
    stream = HTStreamStack(rep_in, format_out, sink, anchor);
a1265 1

d1272 2
a1273 2
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
d1279 6
a1284 7
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
d1288 1
a1288 1
	(*targetClass._abort) (stream, NULL);
d1290 1
a1290 1
	(*targetClass._free) (stream);
a1300 68

/*	HTParseZzFile
 *
 *  State of file and target stream on entry:
 *			FILE (zzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp closed; target freed, aborted, or NULL.
 */
int HTParseZzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  FILE *zzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	fclose(zzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTZzFileCopy(zzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    fclose(zzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}
a1302 76
#ifdef USE_BZLIB
static void HTCloseBzFile(BZFILE * bzfp)
{
    if (bzfp)
	BZ2_bzclose(bzfp);
}

/*	HTParseBzFile
 *
 *  State of file and target stream on entry:
 *			bzFile (bzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp closed; target freed, aborted, or NULL.
 */
int HTParseBzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  BZFILE * bzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	HTCloseBzFile(bzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseBzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTBzFileCopy(bzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    HTCloseBzFile(bzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}
#endif /* USE_BZLIB */

d1304 8
a1311 8
 *	-----------------------------------------------------------
 *
 *	The input is assumed to be in ASCII, with lines delimited
 *	by (13,10) pairs, These pairs are converted into (CR,LF)
 *	pairs in the local representation.  The (CR,LF) sequence
 *	when found is changed to a '\n' character, the internal
 *	C representation of a new line.
 */
d1313 1
a1313 1
static void NetToText_put_character(HTStream *me, char net_char)
a1315 1

d1322 1
a1322 1
	    me->sink->isa->put_character(me->sink, CR);		/* leftover */
d1325 1
a1325 1
    me->had_cr = (BOOL) (c == CR);
d1327 1
a1327 1
	me->sink->isa->put_character(me->sink, c);	/* normal */
d1330 1
a1330 1
static void NetToText_put_string(HTStream *me, const char *s)
d1332 1
a1332 1
    const char *p;
d1338 1
a1338 1
static void NetToText_put_block(HTStream *me, const char *s, int l)
d1340 1
a1340 1
    const char *p;
d1342 1
a1342 1
    for (p = s; p < (s + l); p++)
d1346 1
a1346 1
static void NetToText_free(HTStream *me)
d1348 1
a1348 1
    (me->sink->isa->_free) (me->sink);	/* Close rest of pipe */
d1352 1
a1352 1
static void NetToText_abort(HTStream *me, HTError e)
d1354 1
a1354 1
    me->sink->isa->_abort(me->sink, e);		/* Abort rest of pipe */
d1360 1
a1360 2
static HTStreamClass NetToTextClass =
{
d1371 1
a1371 1
HTStream *HTNetToText(HTStream *sink)
d1373 1
a1373 1
    HTStream *me = typecalloc(HTStream);
a1383 51
static HTStream HTBaseStreamInstance;	/* Made static */

/*
 *	ERROR STREAM
 *	------------
 *	There is only one error stream shared by anyone who wants a
 *	generic error returned from all stream methods.
 */
static void HTErrorStream_put_character(HTStream *me GCC_UNUSED, char c GCC_UNUSED)
{
    LYCancelDownload = TRUE;
}

static void HTErrorStream_put_string(HTStream *me GCC_UNUSED, const char *s)
{
    if (s && *s)
	LYCancelDownload = TRUE;
}

static void HTErrorStream_write(HTStream *me GCC_UNUSED, const char *s, int l)
{
    if (l && s)
	LYCancelDownload = TRUE;
}

static void HTErrorStream_free(HTStream *me GCC_UNUSED)
{
    return;
}

static void HTErrorStream_abort(HTStream *me GCC_UNUSED, HTError e GCC_UNUSED)
{
    return;
}

static const HTStreamClass HTErrorStreamClass =
{
    "ErrorStream",
    HTErrorStream_free,
    HTErrorStream_abort,
    HTErrorStream_put_character,
    HTErrorStream_put_string,
    HTErrorStream_write
};

HTStream *HTErrorStream(void)
{
    CTRACE((tfp, "ErrorStream. Created\n"));
    HTBaseStreamInstance.isa = &HTErrorStreamClass;	/* The rest is random */
    return &HTBaseStreamInstance;
}
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d19 6
d29 1
a29 1
#ifdef UNIX
d36 1
a36 1
#endif /* UNIX */
a44 1
#include <HTTP.h>
a57 4
#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif

d59 1
d94 3
a96 3
	double,		quality,
	double,		secs,
	double,		secs_per_byte,
d99 1
a99 1
    HTPresentation * pres = typecalloc(HTPresentation);
d106 3
a108 3
    pres->quality = (float) quality;
    pres->secs = (float) secs;
    pres->secs_per_byte = (float) secs_per_byte;
d144 1
a144 1
    HTPresentation * pres = typecalloc(HTPresentation);
d246 1
a246 1
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetCharacter\n"));
d250 1
a250 1
		CTRACE((tfp, "HTFormat: File read error %d\n", status));
d260 1
a260 1
    return FROMASCII(UCH(ch));
d278 1
a278 1
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetSSLCharacter\n"));
d282 1
a282 1
		CTRACE((tfp, "HTFormat: SSL_read error %d\n", status));
d301 1
a301 1
    char *cp = strchr(trial_type, '/');
d307 2
a308 2
    CTRACE((tfp, "HTFormat: comparing %s and %s for half match\n",
		trial_type, target));
a316 2
#define WWW_WILDCARD_REP_OUT HTAtom_for("*")

d333 1
a333 1
    HTAtom * wildcard = NULL; /* = HTAtom_for("*"); lookup when needed - kw */
d335 2
a336 2
    CTRACE((tfp, "HTFormat: Looking up presentation for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d354 2
a355 2
		    CTRACE((tfp, "FindPresentation: found exact match: %s\n",
				HTAtom_name(pres->rep)));
d360 6
a365 9
		} else {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard) {
			if (!strong_wildcard_match)
			    strong_wildcard_match = pres;
			/* otherwise use the first one */
			CTRACE((tfp, "StreamStack: found strong wildcard match: %s\n",
				    HTAtom_name(pres->rep)));
		    }
d377 2
a378 2
		    CTRACE((tfp, "StreamStack: found strong subtype wildcard match: %s\n",
				HTAtom_name(pres->rep)));
d387 5
a391 6
		    CTRACE((tfp, "StreamStack: found weak wildcard match: %s\n",
				HTAtom_name(pres->rep_out)));

		} else if (!last_default_match) {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard)
a431 1
    HTStream *result;
d433 2
a434 2
    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d438 1
a438 2
     */
#if 0
d440 1
a440 2
	return sink;	/*  LJM */
#endif
d442 2
a443 2
    if (rep_out == rep_in) {
	result = sink;
d445 1
a445 1
    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp))) {
d447 1
a447 1
	    CTRACE((tfp, "StreamStack: Using %s\n", HTAtom_name(temp.rep_out)));
d449 2
a450 2
	    CTRACE((tfp, "StreamStack: found exact match: %s\n",
			HTAtom_name(match->rep)));
d452 1
a452 1
	result = (*match->converter)(match, anchor, sink);
d454 1
a454 11
	result = NULL;
    }
    if (TRACE) {
	if (result && result->isa && result->isa->name) {
	    CTRACE((tfp, "StreamStack: Returning \"%s\"\n", result->isa->name));
	} else if (result) {
	    CTRACE((tfp, "StreamStack: Returning *unknown* stream!\n"));
	} else {
	    CTRACE((tfp, "StreamStack: Returning NULL!\n"));
	    CTRACE_FLUSH(tfp);	/* a crash may be imminent... - kw */
	}
a455 1
    return result;
a473 50

/*
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
PUBLIC void HTFilterPresentations NOARGS
{
    int i, j;
    int n = HTList_count(HTPresentations);
    HTPresentation *p, *q;
    BOOL matched;
    char *s, *t, *x, *y;

    for (i = 0; i < n; i++) {
	p = (HTPresentation *)HTList_objectAt(HTPresentations, i);
	s = HTAtom_name(p->rep);

	if (p->rep_out == WWW_PRESENT) {
	    if (p->rep != WWW_SOURCE
	     && strcasecomp(s, "www/mime")
	     && strcasecomp(s, "www/compressed")
	     && p->quality <= 1.0 && p->quality >= 0.0) {
		for (j = 0, matched = FALSE; j < i; j++) {
		    q = (HTPresentation *)HTList_objectAt(HTPresentations, j);
		    t = HTAtom_name(q->rep);

		    if (!strcasecomp(s, t)) {
			matched = TRUE;
			break;
		    }
		    if ((x = strchr(s, '/')) != 0
		     && (y = strchr(t, '/')) != 0) {
			int len1 = x++ - s;
			int len2 = y++ - t;
			int lens = (len1 > len2) ? len1 : len2;

			if ((*t == '*' || !strncasecomp(s, t, lens))
			 && (*y == '*' || !strcasecomp(x, y))) {
			    matched = TRUE;
			    break;
			}
		    }
		}
		if (!matched)
		    p->get_accept = TRUE;
	    }
	}
    }
}

d488 1
a488 1
    HTAtom * wildcard = WWW_WILDCARD_REP_OUT;
d490 2
a491 2
    CTRACE((tfp, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
		HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));
d516 1
a516 1
    return (float) -1e30;	/* Really bad */
d532 1
a532 1
	**  HText_getNumOfLines() = "current" number of complete lines received
a533 1
	**  (we update NumOfLines_partial only when we repaint the display.)
d535 5
a539 3
	**  display_partial could only be enabled in HText_new()
	**  so a new HTMainText object available - all HText_ functions use it,
	**  lines counter HText_getNumOfLines() in particular.
d548 3
a550 3
	int Newline_partial = LYGetNewline();

	if (((Newline_partial + display_lines) - 1 > NumOfLines_partial)
d553 2
a554 2
		((Newline_partial + partial_threshold) -1 <= HText_getNumOfLines()) :
		((Newline_partial + display_lines) - 1 <= HText_getNumOfLines()))
d562 2
a563 2
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
d574 10
d588 4
a633 1
    BOOL suppress_readprogress = NO;
a686 3
#ifdef _WINDOWS	/* 1997/11/10 (Mon) 16:57:18 */
		       SOCKET_ERRNO == ETIMEDOUT ||
#endif
d708 4
a711 4
		   HTInetStatus("NETREAD");
		   HTAlert("Unexpected server disconnect.");
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
d719 2
a720 2
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
a748 10
	/*
	 *  Suppress ReadProgress messages when collecting a redirection
	 *  message, at least initially (unless/until anchor->content_type
	 *  gets changed, probably by the MIME message parser).  That way
	 *  messages put up by the HTTP module or elsewhere can linger in
	 *  the statusline for a while. - kw
	 */
	suppress_readprogress = (anchor && anchor->content_type &&
				 !strcmp(anchor->content_type,
					 "message/x-http-redirection"));
d760 1
a760 2
	if (!suppress_readprogress)
	    HTReadProgress(bytes, anchor ? anchor->content_length : 0);
d816 2
a817 2
	    CTRACE((tfp, "HTFormat: Read error, read returns %d\n",
			ferror(fp)));
d829 1
a829 7
	/*  Suppress last screen update in partial mode - a regular update
	 *  under control of mainloop() should follow anyway. - kw
	 */
#ifdef DISP_PARTIAL
	if (display_partial && bytes != HTMainAnchor->content_length)
	    HTDisplayPartial();
#endif
d867 1
a867 1
    HTStreamClass targetClass;
a871 1
    targetClass = *(sink->isa);
d948 4
a951 4
	    CTRACE((tfp, "HTGzFileCopy: Read error, gzread returns %d\n",
			status));
	    CTRACE((tfp, "gzerror   : %s\n",
			gzerror(gzfp, &gzerrnum)));
d1002 1
a1002 1
    int character;
d1016 1
a1016 1
	if (character == EOF)
d1018 1
a1018 1
	(*targetClass.put_character)(sink, UCH(character));
d1077 1
a1077 1
	CTRACE((tfp, "HTFormat: %s\n", buffer));
d1127 3
a1129 6
#ifdef SH_EX		/* 1998/01/04 (Sun) 16:04:09 */
    if (fp == NULL)
	return HT_LOADED;
#endif

    stream = HTStreamStack(rep_in, format_out, sink, anchor);
d1139 1
a1139 1
	CTRACE((tfp, "HTFormat(in HTParseFile): %s\n", buffer));
d1181 1
a1181 1
**  State of memory and target stream on return:
d1200 1
a1200 1
	CTRACE((tfp, "HTFormat(in HTParseMem): %s\n", buffer));
d1227 1
a1227 1
	    CTRACE((tfp, "gzclose   : error number %d\n", gzres));
d1260 3
a1262 1
    stream = HTStreamStack(rep_in, format_out, sink, anchor);
d1273 1
a1273 1
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
d1325 1
a1325 1
    me->had_cr = (BOOL) (c == CR);
d1373 1
a1373 1
    HTStream* me = typecalloc(HTStream);
a1383 50
PRIVATE HTStream	HTBaseStreamInstance;		      /* Made static */
/*
**	ERROR STREAM
**	------------
**	There is only one error stream shared by anyone who wants a
**	generic error returned from all stream methods.
*/
PRIVATE void HTErrorStream_put_character ARGS2(HTStream *, me GCC_UNUSED, char, c GCC_UNUSED)
{
    LYCancelDownload = TRUE;
}

PRIVATE void HTErrorStream_put_string ARGS2(HTStream *, me GCC_UNUSED, CONST char *, s)
{
    if (s && *s)
	LYCancelDownload = TRUE;
}

PRIVATE void HTErrorStream_write ARGS3(HTStream *, me GCC_UNUSED, CONST char *, s, int, l)
{
    if (l && s)
	LYCancelDownload = TRUE;
}

PRIVATE void HTErrorStream_free ARGS1(HTStream *, me GCC_UNUSED)
{
    return;
}

PRIVATE void HTErrorStream_abort ARGS2(HTStream *, me GCC_UNUSED, HTError, e GCC_UNUSED)
{
    return;
}

PRIVATE CONST HTStreamClass HTErrorStreamClass =
{
    "ErrorStream",
    HTErrorStream_free,
    HTErrorStream_abort,
    HTErrorStream_put_character,
    HTErrorStream_put_string,
    HTErrorStream_write
};

PUBLIC HTStream * HTErrorStream NOARGS
{
    CTRACE((tfp, "ErrorStream. Created\n"));
    HTBaseStreamInstance.isa = &HTErrorStreamClass;    /* The rest is random */
    return &HTBaseStreamInstance;
}
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d920 1
a920 1
#ifdef USE_SOURCE_CACHE
a1059 77
#ifdef USE_BZLIB
/*	Push data from a bzip file pointer down a stream
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**
**  State of file and target stream on entry:
**		      BZFILE (bzfp) assumed open (should have bzipped content),
**		      target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption after some data read.
**	HT_PARTIAL_CONTENT	Error after some data read.
**	-1		Error before any data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		bzfp still open, target stream still valid.
*/
PRIVATE int HTBzFileCopy ARGS2(
	BZFILE *,		bzfp,
	HTStream*,		sink)
{
    HTStreamClass targetClass;
    int status, bytes;
    int bzerrnum;
    int rv = HT_OK;

    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */

    /*	read and inflate bzip'd file, and push binary down sink
    */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	status = BZ2_bzread(bzfp, input_buffer, INPUT_BUFFER_SIZE);
	if (status <= 0) { /* EOF or error */
	    if (status == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTBzFileCopy: Read error, bzread returns %d\n",
			status));
	    CTRACE((tfp, "bzerror   : %s\n",
			BZ2_bzerror(bzfp, &bzerrnum)));
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block)(sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, -1);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress (TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    } /* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}
#endif /* USE_BZLIB */

d1245 1
a1245 1
#ifdef USE_SOURCE_CACHE
a1377 76

#ifdef USE_BZLIB
PRIVATE void HTCloseBzFile ARGS1(
	BZFILE *,		bzfp)
{
    if (bzfp)
	BZ2_bzclose(bzfp);
}

/*	HTParseBzFile
**
**  State of file and target stream on entry:
**			bzFile (bzfp) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	-1		Download cancelled.
**	HT_NO_DATA	Error before any data read.
**	HT_PARTIAL_CONTENT	Interruption or error after some data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		bzfp closed; target freed, aborted, or NULL.
*/
PUBLIC int HTParseBzFile ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	BZFILE*,		bzfp,
	HTStream*,		sink)
{
    HTStream * stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;
	HTCloseBzFile(bzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseBzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*	Push the data down the stream
    **
    **	@@@@  Bug:  This decision ought to be made based on "encoding"
    **	rather than on content-type.  @@@@@@  When we handle encoding.
    **	The current method smells anyway.
    */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTBzFileCopy(bzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort)(stream, NULL);
    } else {
	(*targetClass._free)(stream);
    }

    HTCloseBzFile(bzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}
#endif /* USE_BZLIB */
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d19 3
a21 3
float HTMaxSecs = 1e10;		/* No effective limit */
float HTMaxLength = 1e10;	/* No effective limit */
long int HTMaxBytes  = 0;	/* No effective limit */
d57 1
a57 1
BOOL HTOutputSource = NO;	/* Flag: shortcut parser to stdout */
d61 1
a61 1
      const HTStreamClass*	isa;
d68 1
a68 1
	const HTStreamClass *	isa;
d76 2
a77 2
HTList * HTPresentations = NULL;
HTPresentation * default_presentation = NULL;
d83 1
a83 1
static void HTFreePresentations (void);
d89 7
a95 7
void HTSetPresentation (
	const char *	representation,
	const char *	command,
	double		quality,
	double		secs,
	double		secs_per_byte,
	long int	maxbytes)
d133 8
a140 8
void HTSetConversion (
	const char *	representation_in,
	const char *	representation_out,
	HTConverter*	converter,
	float		quality,
	float		secs,
	float		secs_per_byte,
	long int	maxbytes)
d180 1
a180 1
static void HTFreePresentations (void)
d214 4
a217 4
static char input_buffer[INPUT_BUFFER_SIZE];
static char * input_pointer;
static char * input_limit;
static int input_file_number;
d225 1
a225 1
void HTInitInput (int file_number)
d231 2
a232 2
int interrupted_in_htgetcharacter = 0;
int HTGetCharacter (void)
d262 1
a262 1
char HTGetSSLCharacter (void *  handle)
d297 1
a297 1
static int half_match (char * trial_type, char * target)
d328 4
a331 4
static HTPresentation * HTFindPresentation (
	HTFormat		rep_in,
	HTFormat		rep_out,
	HTPresentation*	fill_in)
d428 5
a432 5
HTStream * HTStreamStack (
	HTFormat		rep_in,
	HTFormat		rep_out,
	HTStream*		sink,
	HTParentAnchor*	anchor)
d482 3
a484 3
void HTReorderPresentation (
	HTFormat		rep_in,
	HTFormat		rep_out)
d497 1
a497 1
void HTFilterPresentations (void)
d550 5
a554 5
float HTStackValue (
	HTFormat		rep_in,
	HTFormat		rep_out,
	float			initial_value,
	long int		length)
d595 1
a595 1
void HTDisplayPartial (void)
d638 1
a638 1
void HTFinishDisplayPartial (void)
d680 5
a684 5
int HTCopy (
	HTParentAnchor *	anchor,
	int			file_number,
	void*			handle GCC_UNUSED,
	HTStream*		sink)
d862 3
a864 3
int HTFileCopy (
	FILE *			fp,
	HTStream*		sink)
d937 3
a939 3
int HTMemCopy (
	HTChunk *		chunk,
	HTStream *		sink)
d943 1
a943 1
    const char *data = chunk->data;
d1000 3
a1002 3
static int HTGzFileCopy (
	gzFile			gzfp,
	HTStream*		sink)
d1081 3
a1083 3
static int HTBzFileCopy (
	BZFILE *		bzfp,
	HTStream*		sink)
d1148 4
a1151 4
void HTCopyNoCR (
	HTParentAnchor *	anchor GCC_UNUSED,
	int			file_number,
	HTStream*		sink)
d1208 6
a1213 6
int HTParseSocket (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	int			file_number,
	HTStream*		sink)
d1268 6
a1273 6
int HTParseFile (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	FILE *			fp,
	HTStream*		sink)
d1339 6
a1344 6
int HTParseMem (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	HTChunk *		chunk,
	HTStream *		sink)
d1371 2
a1372 2
static int HTCloseGzFile (
	gzFile			gzfp)
d1404 6
a1409 6
int HTParseGzFile (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	gzFile			gzfp,
	HTStream*		sink)
d1457 2
a1458 2
static void HTCloseBzFile (
	BZFILE *		bzfp)
d1480 6
a1485 6
int HTParseBzFile (
	HTFormat		rep_in,
	HTFormat		format_out,
	HTParentAnchor *	anchor,
	BZFILE*		bzfp,
	HTStream*		sink)
d1542 1
a1542 1
static void NetToText_put_character (HTStream *  me, char  net_char)
d1559 1
a1559 1
static void NetToText_put_string (HTStream *  me, const char *  s)
d1561 1
a1561 1
    const char * p;
d1567 1
a1567 1
static void NetToText_put_block (HTStream * me, const char* s, int l)
d1569 1
a1569 1
    const char * p;
d1575 1
a1575 1
static void NetToText_free (HTStream *  me)
d1581 1
a1581 1
static void NetToText_abort (HTStream *  me, HTError  e)
d1589 1
a1589 1
static HTStreamClass NetToTextClass = {
d1600 1
a1600 1
HTStream * HTNetToText (HTStream *  sink)
d1613 1
a1613 1
static HTStream	HTBaseStreamInstance;		      /* Made static */
d1620 1
a1620 1
static void HTErrorStream_put_character (HTStream *  me GCC_UNUSED, char  c GCC_UNUSED)
d1625 1
a1625 1
static void HTErrorStream_put_string (HTStream *  me GCC_UNUSED, const char *  s)
d1631 1
a1631 1
static void HTErrorStream_write (HTStream * me GCC_UNUSED, const char * s, int l)
d1637 1
a1637 1
static void HTErrorStream_free (HTStream *  me GCC_UNUSED)
d1642 1
a1642 1
static void HTErrorStream_abort (HTStream *  me GCC_UNUSED, HTError  e GCC_UNUSED)
d1647 1
a1647 1
static const HTStreamClass HTErrorStreamClass =
d1657 1
a1657 1
HTStream * HTErrorStream (void)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 10
a11 10
 *		=============================
 *
 * Bugs:
 *	Not reentrant.
 *
 *	Assumes the incoming stream is ASCII, rather than a local file
 *	format, and so ALWAYS converts from ASCII on non-ASCII machines.
 *	Therefore, non-ASCII machines can't read local files.
 *
 */
d21 1
a21 1
long int HTMaxBytes = 0;	/* No effective limit */
d61 2
a62 2
    const HTStreamClass *isa;
    /* ... */
d68 3
a70 3
    const HTStreamClass *isa;
    BOOL had_cr;
    HTStream *sink;
d74 4
a77 4
 *	--------------------
 */
HTList *HTPresentations = NULL;
HTPresentation *default_presentation = NULL;
d83 1
a83 1
static void HTFreePresentations(void);
d87 9
a95 10
 *	-------------------------------------------------------
 */
void HTSetPresentation(const char *representation,
		       const char *command,
		       const char *testcommand,
		       double quality,
		       double secs,
		       double secs_per_byte,
		       long int maxbytes,
		       AcceptMedia media)
d97 1
a97 2
    HTPresentation *pres = typecalloc(HTPresentation);

d102 2
a103 2
    pres->rep_out = WWW_PRESENT;	/* Fixed for now ... :-) */
    pres->converter = HTSaveAndExecute;		/* Fixed for now ...     */
a107 3
    pres->get_accept = 0;
    pres->accept_opt = media;

a110 3
    pres->testcommand = NULL;
    StrAllocCopy(pres->testcommand, testcommand);

d112 2
a113 2
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d115 1
a115 1
    if (!HTPresentations) {
d122 1
a122 1
    if (strcmp(representation, "*") == 0) {
d131 10
a140 10
 *	---------------------------------------------
 */
void HTSetConversion(const char *representation_in,
		     const char *representation_out,
		     HTConverter *converter,
		     float quality,
		     float secs,
		     float secs_per_byte,
		     long int maxbytes,
		     AcceptMedia media)
d142 1
a142 2
    HTPresentation *pres = typecalloc(HTPresentation);

d149 1
a149 2
    pres->command = NULL;
    pres->testcommand = NULL;
d154 1
a154 2
    pres->get_accept = TRUE;
    pres->accept_opt = media;
d157 2
a158 2
     * Memory Leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d160 1
a160 1
    if (!HTPresentations) {
d172 9
a180 9
 *	Purpose:	Free the presentation list.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		Made to clean up Lynx's bad leakage.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void HTFreePresentations(void)
d182 1
a182 1
    HTPresentation *pres = NULL;
d185 1
a185 1
     * Loop through the list.
d189 3
a191 2
	 * Free off each item.  May also need to free off it's items, but not
	 * sure as of yet.
d193 1
a193 1
	pres = (HTPresentation *) HTList_removeLastObject(HTPresentations);
a194 1
	FREE(pres->testcommand);
d198 1
a198 1
     * Free the list itself.
d206 8
a213 8
 *	--------------
 *
 *	The input file is read using the macro which can read from
 *	a socket or a file.
 *	The input buffer size, if large will give greater efficiency and
 *	release the server faster, and if small will save space on PCs etc.
 */
#define INPUT_BUFFER_SIZE 4096	/* Tradeoff */
d215 2
a216 2
static char *input_pointer;
static char *input_limit;
d220 6
a225 6
 *
 *	These routines are public because they are in fact needed by
 *	many parsers, and on PCs and Macs we should not duplicate
 *	the static buffer area.
 */
void HTInitInput(int file_number)
d232 1
a232 1
int HTGetCharacter(void)
a234 1

a239 1

d249 2
a250 2
		return EOF;	/* -1 is returned by UCX
				   at end of HTTP link */
d256 1
a256 1
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */
d262 1
a262 1
char HTGetSSLCharacter(void *handle)
a264 1

d266 2
a267 2
    if (!handle)
	return (char) EOF;
d270 2
a271 3
	    int status = SSL_read((SSL *) handle,
				  input_buffer, INPUT_BUFFER_SIZE);

d274 1
a274 1
		    return (char) EOF;
d276 1
a276 2
		    CTRACE((tfp,
			    "HTFormat: Interrupted in HTGetSSLCharacter\n"));
d278 1
a278 1
		    return (char) EOF;
d281 2
a282 2
		return (char) EOF;	/* -1 is returned by UCX
					   at end of HTTP link */
d288 1
a288 1
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */
d294 2
a295 2
/* Match maintype to any MIME type starting with maintype, for example: 
 * image/gif should match image
d297 1
a297 1
static int half_match(char *trial_type, char *target)
d302 1
a302 1
    if (!cp || *(cp + 1) != '*')
d306 1
a306 1
	    trial_type, target));
d308 2
a309 2
    /* main type matches */
    if (!strncmp(trial_type, target, (cp - trial_type) - 1))
a314 14
/*
 * Evaluate a deferred mailcap test command, i.e.,. one that substitutes the
 * document's charset or other values in %{name} format.
 */
static BOOL failsMailcap(HTPresentation *pres, HTParentAnchor *anchor)
{
    if (pres->testcommand != 0) {
	if (LYTestMailcapCommand(pres->testcommand,
				 anchor->content_type_params) != 0)
	    return TRUE;
    }
    return FALSE;
}

d318 16
a333 24
 *		----------------------
 *
 *	If fill_in is NULL, only look for an exact match.
 *	If a wildcard match is made, *fill_in is used to store
 *	a possibly modified presentation, and a pointer to it is
 *	returned.  For an exact match, a pointer to the presentation
 *	in the HTPresentations list is returned.  Returns NULL if
 *	nothing found. - kw
 *
 */
static HTPresentation *HTFindPresentation(HTFormat rep_in,
					  HTFormat rep_out,
					  HTPresentation *fill_in,
					  HTParentAnchor *anchor)
{
    HTAtom *wildcard = NULL;	/* = HTAtom_for("*"); lookup when needed - kw */
    int n;
    int i;
    HTPresentation *pres;
    HTPresentation *match;
    HTPresentation *strong_wildcard_match = 0;
    HTPresentation *weak_wildcard_match = 0;
    HTPresentation *last_default_match = 0;
    HTPresentation *strong_subtype_wildcard_match = 0;
d336 21
a356 1
	    HTAtom_name(rep_in), HTAtom_name(rep_out)));
d358 1
a358 6
    n = HTList_count(HTPresentations);
    for (i = 0; i < n; i++) {
	pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (pres->rep == rep_in) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
d360 10
a369 3
		CTRACE((tfp, "FindPresentation: found exact match: %s\n",
			HTAtom_name(pres->rep)));
		return pres;
d373 6
a378 8
	    } else {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
		if (pres->rep_out == wildcard) {
		    if (failsMailcap(pres, anchor))
			continue;
		    if (!strong_wildcard_match)
			strong_wildcard_match = pres;
d380 2
a381 3
		    CTRACE((tfp,
			    "StreamStack: found strong wildcard match: %s\n",
			    HTAtom_name(pres->rep)));
d385 7
a391 2
	} else if (!fill_in) {
	    continue;
d393 6
a398 11
	} else if (half_match(HTAtom_name(pres->rep),
			      HTAtom_name(rep_in))) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!strong_subtype_wildcard_match)
		    strong_subtype_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found strong subtype wildcard match: %s\n",
			HTAtom_name(pres->rep)));
d402 10
a411 21
	if (pres->rep == WWW_SOURCE) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!weak_wildcard_match)
		    weak_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found weak wildcard match: %s\n",
			HTAtom_name(pres->rep_out)));

	    } else if (!last_default_match) {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
		if (pres->rep_out == wildcard) {
		    if (failsMailcap(pres, anchor))
			continue;
		    last_default_match = pres;
		/* otherwise use the first one */
		}
	    }
a414 15
    match = (strong_subtype_wildcard_match
	     ? strong_subtype_wildcard_match
	     : (strong_wildcard_match
		? strong_wildcard_match
		: (weak_wildcard_match
		   ? weak_wildcard_match
		   : last_default_match)));

    if (match) {
	*fill_in = *match;	/* Specific instance */
	fill_in->rep = rep_in;	/* yuk */
	fill_in->rep_out = rep_out;	/* yuk */
	return fill_in;
    }

d419 14
a432 13
 *		---------------------
 *
 *	If a wildcard match is made, a temporary HTPresentation
 *	structure is made to hold the destination format while the
 *	new stack is generated. This is just to pass the out format to
 *	MIME so far.  Storing the format of a stream in the stream might
 *	be a lot neater.
 *
 */
HTStream *HTStreamStack(HTFormat rep_in,
			HTFormat rep_out,
			HTStream *sink,
			HTParentAnchor *anchor)
d438 2
a439 4
    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s (%s)\n",
	    HTAtom_name(rep_in),
	    HTAtom_name(rep_out),
	    NONNULL(anchor->content_type_params)));
d446 1
a446 1
	return sink;		/*  LJM */
d452 1
a452 1
    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp, anchor))) {
d457 1
a457 1
		    HTAtom_name(match->rep)));
d459 1
a459 1
	result = (*match->converter) (match, anchor, sink);
d477 8
a484 7
 *		-------------------------------------
 *
 *	Look up a presentation (exact match only) and, if found, reorder
 *	it to the start of the HTPresentations list. - kw
 */
void HTReorderPresentation(HTFormat rep_in,
			   HTFormat rep_out)
d487 1
a487 2

    if ((match = HTFindPresentation(rep_in, rep_out, NULL, NULL))) {
d497 1
a497 1
void HTFilterPresentations(void)
d503 1
a503 1
    char *s, *t;
a504 1
    CTRACE((tfp, "HTFilterPresentations (AcceptMedia %#x)\n", LYAcceptMedia));
d506 1
a506 1
	p = (HTPresentation *) HTList_objectAt(HTPresentations, i);
d509 25
a533 16
	p->get_accept = FALSE;
	if (LYAcceptMedia & p->accept_opt
	    && p->rep_out == WWW_PRESENT
	    && p->rep != WWW_SOURCE
	    && strcasecomp(s, "www/mime")
	    && strcasecomp(s, "www/compressed")
	    && p->quality <= 1.0 && p->quality >= 0.0) {
	    matched = TRUE;
	    for (j = 0; j < i; j++) {
		q = (HTPresentation *) HTList_objectAt(HTPresentations, j);
		t = HTAtom_name(q->rep);

		if (!strcasecomp(s, t)) {
		    matched = FALSE;
		    CTRACE((tfp, "  match %s %s\n", s, t));
		    break;
d535 2
a537 1
	    p->get_accept = matched;
d543 12
a554 11
 *		-------------------------------
 *
 *	Must return the cost of the same stack which StreamStack would set up.
 *
 * On entry,
 *	length	The size of the data to be converted
 */
float HTStackValue(HTFormat rep_in,
		   HTFormat rep_out,
		   float initial_value,
		   long int length)
d556 1
a556 1
    HTAtom *wildcard = WWW_WILDCARD_REP_OUT;
d559 1
a559 1
	    HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));
d564 3
d570 1
a570 2
	HTPresentation *pres;

d572 1
a572 1
	    pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
a575 1

d577 2
a578 2
		    value = value - (length * pres->secs_per_byte + pres->secs)
			/ HTMaxSecs;
d589 7
a595 7
 *	-------------------------------------------
 *
 *   Repaint the page only when necessary.
 *   This is a traverse call for HText_pageDisplay() - it works!.
 *
 */
void HTDisplayPartial(void)
d600 15
a614 15
	 * HText_getNumOfLines() = "current" number of complete lines received
	 * NumOfLines_partial = number of lines at the moment of last repaint. 
	 * (we update NumOfLines_partial only when we repaint the display.)
	 *
	 * display_partial could only be enabled in HText_new() so a new
	 * HTMainText object available - all HText_ functions use it, lines
	 * counter HText_getNumOfLines() in particular.
	 *
	 * Otherwise HTMainText holds info from the previous document and we
	 * may repaint it instead of the new one:  prev doc scrolled to the
	 * first line (=Newline_partial) is not good looking :-) 23 Aug 1998
	 * Leonid Pauzner
	 *
	 * So repaint the page only when necessary:
	 */
d618 3
a620 4
	/* current page not complete... */
	    && (partial_threshold > 0 ?
		((Newline_partial + partial_threshold) - 1 <=
		 HText_getNumOfLines()) :
d622 7
a628 7
	/*
	 * Originally we rendered by increments of 2 lines,
	 * but that got annoying on slow network connections.
	 * Then we switched to full-pages.  Now it's configurable.
	 * If partial_threshold <= 0, then it's a full page
	 */
	    ) {
d634 1
a634 1
#endif /* DISP_PARTIAL */
d638 1
a638 1
void HTFinishDisplayPartial(void)
d641 4
a644 4
    /*
     * End of incremental rendering stage here.
     */
    display_partial = FALSE;
d649 36
a684 35
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream, i.e., containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-2		Unexpected disconnect before any data received.
 *	-1		Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-2		socket still open, target stream still valid.
 *	-1		socket still open, target aborted.
 *	otherwise	socket closed,	target stream still valid.
 */
int HTCopy(HTParentAnchor *anchor,
	   int file_number,
	   void *handle GCC_UNUSED,
	   HTStream *sink)
d691 8
a698 9
    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*
     * Push binary from socket down sink
     *
     * This operation could be put into a main event loop
     */
d705 1
a705 1
	    (*targetClass._abort) (sink, NULL);
d711 2
a712 2
	    _HTProgress(TRANSFER_INTERRUPTED);
	    (*targetClass._abort) (sink, NULL);
d719 1
d722 1
a722 1
	    status = SSL_read((SSL *) handle, input_buffer, INPUT_BUFFER_SIZE);
d733 2
a734 2
		_HTProgress(TRANSFER_INTERRUPTED);
		(*targetClass._abort) (sink, NULL);
d741 1
a741 1
#ifdef _WINDOWS			/* 1997/11/10 (Mon) 16:57:18 */
d747 1
a747 1
		 * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
d751 2
a752 2
		     * Don't have any data, so let the calling function decide
		     * what to do about it.  - FM
d758 22
a779 21
		    /*
		     * Treat what we've received already as the complete
		     * transmission, but not without giving the user an alert. 
		     * I don't know about all the different TCP stacks for VMS
		     * etc., so this is currently only for UNIX.  - kw
		     */
		    HTInetStatus("NETREAD");
		    HTAlert("Unexpected server disconnect.");
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
		    status = 0;
		    break;
#else /* !UNIX */
		    /*
		     * Treat what we've gotten already as the complete
		     * transmission.  - FM
		     */
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
		    status = 0;
		    break;
d785 5
a789 4
		 * Treat what we've received already as the complete
		 * transmission, but not without giving the user an alert.  I
		 * don't know about all the different TCP stacks for VMS etc.,
		 * so this is currently only for UNIX.  - kw
d794 1
a794 1
		    (void) NETCLOSE(file_number);
d797 1
a797 1
		    (*targetClass._abort) (sink, NULL);
d807 5
a811 5
	 * Suppress ReadProgress messages when collecting a redirection
	 * message, at least initially (unless/until anchor->content_type gets
	 * changed, probably by the MIME message parser).  That way messages
	 * put up by the HTTP module or elsewhere can linger in the statusline
	 * for a while.  - kw
d818 2
a819 3
	    char *p;

	    for (p = input_buffer; p < input_buffer + status; p++) {
d825 1
a825 1
	(*targetClass.put_block) (sink, input_buffer, status);
d831 1
a831 1
    }				/* next bufferload */
d834 1
a834 1
    (void) NETCLOSE(file_number);
d837 1
a837 1
  finished:
d839 1
a839 1
    return (rv);
d843 22
a864 20
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open, target stream still valid.
 */
int HTFileCopy(FILE *fp, HTStream *sink)
d870 3
a872 3
    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */
d874 2
a875 2
    /*  Push binary from socket down sink
     */
d879 1
a879 1
	if (status == 0) {	/* EOF or error */
d885 1
a885 1
		    ferror(fp)));
d894 1
a894 1
	(*targetClass.put_block) (sink, input_buffer, status);
d897 2
a898 2
	/* Suppress last screen update in partial mode - a regular update under
	 * control of mainloop() should follow anyway.  - kw
d906 1
a906 1
	    _HTProgress(TRANSFER_INTERRUPTED);
d914 1
a914 1
    }				/* next bufferload */
d922 18
a939 16
 *	---------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) and target (sink) assumed valid.
 *
 *  Return values:
 *	HT_LOADED	All data sent.
 *	HT_INTERRUPTED  Interruption after some data read.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged, target stream still valid.
 */
int HTMemCopy(HTChunk *chunk, HTStream *sink)
d950 2
a951 2
	 * running a large document on a slow machine.
	 */
a952 1

d957 1
a957 1
	(*targetClass.put_block) (sink, data, n);
d964 1
a964 1
	    _HTProgress(TRANSFER_INTERRUPTED);
d981 22
a1002 20
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      gzFile (gzfp) assumed open (should have gzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp still open, target stream still valid.
 */
static int HTGzFileCopy(gzFile gzfp, HTStream *sink)
d1009 3
a1011 3
    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */
d1013 2
a1014 2
    /*  read and inflate gzip'd file, and push binary down sink
     */
d1018 1
a1018 1
	if (status <= 0) {	/* EOF or error */
d1024 1
a1024 1
		    status));
d1026 1
a1026 1
		    gzerror(gzfp, &gzerrnum)));
d1039 1
a1039 1
	(*targetClass.put_block) (sink, input_buffer, status);
d1045 1
a1045 1
	    _HTProgress(TRANSFER_INTERRUPTED);
d1053 1
a1053 1
    }				/* next bufferload */
d1062 22
a1083 20
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      BZFILE (bzfp) assumed open (should have bzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp still open, target stream still valid.
 */
static int HTBzFileCopy(BZFILE * bzfp, HTStream *sink)
d1090 3
a1092 3
    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */
d1094 2
a1095 2
    /*  read and inflate bzip'd file, and push binary down sink
     */
d1099 1
a1099 1
	if (status <= 0) {	/* EOF or error */
d1105 1
a1105 1
		    status));
d1107 1
a1107 1
		    BZ2_bzerror(bzfp, &bzerrnum)));
d1116 1
a1116 1
	(*targetClass.put_block) (sink, input_buffer, status);
d1122 1
a1122 1
	    _HTProgress(TRANSFER_INTERRUPTED);
d1130 1
a1130 1
    }				/* next bufferload */
d1138 14
a1151 13
 *	--------------------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the socket.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 */
void HTCopyNoCR(HTParentAnchor *anchor GCC_UNUSED,
		int file_number,
		HTStream *sink)
d1156 9
a1164 10
    /*  Push the data, ignoring CRLF, down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*
     * Push text from telnet socket down sink
     *
     * @@@@@@@@@@ To push strings could be faster?  (especially is we cheat and
     * don't ignore CR!  :-}
     */
d1170 1
a1170 1
	(*targetClass.put_character) (sink, UCH(character));
d1175 39
a1213 38
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-501		Stream stack failed (cannot present or convert).
 *	-2		Unexpected disconnect before any data received.
 *	-1		Stream stack failed (cannot present or convert), or
 *			Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-501		socket still open, target stream NULL.
 *	-2		socket still open, target freed.
 *	-1		socket still open, target stream aborted or NULL.
 *	otherwise	socket closed,	target stream freed.
 */
int HTParseSocket(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  int file_number,
		  HTStream *sink)
d1215 1
a1215 1
    HTStream *stream;
a1222 1

d1228 1
a1228 1
		   HTAtom_name(rep_in), HTAtom_name(format_out));
d1230 1
a1230 1
	rv = HTLoadError(sink, 501, buffer);	/* returns -501 */
d1234 2
a1235 2
	 * Push the data, don't worry about CRLF we can strip them later.
	 */
d1239 1
a1239 1
	    (*targetClass._free) (stream);
d1246 28
a1273 27
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to \n for unix
 *   when the format is textual.
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open; target freed, aborted, or NULL.
 */
int HTParseFile(HTFormat rep_in,
		HTFormat format_out,
		HTParentAnchor *anchor,
		FILE *fp,
		HTStream *sink)
d1275 1
a1275 1
    HTStream *stream;
d1279 1
a1279 1
#ifdef SH_EX			/* 1998/01/04 (Sun) 16:04:09 */
a1287 1

d1293 1
a1293 1
		   HTAtom_name(rep_in), HTAtom_name(format_out));
d1300 6
a1305 7
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
d1309 1
a1309 1
	(*targetClass._abort) (stream, NULL);
d1311 1
a1311 1
	(*targetClass._free) (stream);
d1324 21
a1344 20
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) assumed valid,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	HT_LOADED	All data sent.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged; target freed, aborted, or NULL.
 */
int HTParseMem(HTFormat rep_in,
	       HTFormat format_out,
	       HTParentAnchor *anchor,
	       HTChunk *chunk,
	       HTStream *sink)
d1346 1
a1346 1
    HTStream *stream;
a1352 1

d1362 1
a1362 1
     */
d1365 1
a1365 1
    (*targetClass._free) (stream);
d1371 2
a1372 1
static int HTCloseGzFile(gzFile gzfp)
a1374 1

d1385 1
a1385 1
    return (gzres);
d1389 21
a1409 20
 *
 *  State of file and target stream on entry:
 *			gzFile (gzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp closed; target freed, aborted, or NULL.
 */
int HTParseGzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  gzFile gzfp,
		  HTStream *sink)
d1411 1
a1411 1
    HTStream *stream;
a1418 1

d1425 1
a1425 1
		   HTAtom_name(rep_in), HTAtom_name(format_out));
d1432 6
a1437 7
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
d1441 1
a1441 1
	(*targetClass._abort) (stream, NULL);
d1443 1
a1443 1
	(*targetClass._free) (stream);
d1457 2
a1458 1
static void HTCloseBzFile(BZFILE * bzfp)
d1465 21
a1485 20
 *
 *  State of file and target stream on entry:
 *			bzFile (bzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp closed; target freed, aborted, or NULL.
 */
int HTParseBzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  BZFILE * bzfp,
		  HTStream *sink)
d1487 1
a1487 1
    HTStream *stream;
a1494 1

d1501 1
a1501 1
		   HTAtom_name(rep_in), HTAtom_name(format_out));
d1508 6
a1513 7
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
d1517 1
a1517 1
	(*targetClass._abort) (stream, NULL);
d1519 1
a1519 1
	(*targetClass._free) (stream);
d1533 8
a1540 8
 *	-----------------------------------------------------------
 *
 *	The input is assumed to be in ASCII, with lines delimited
 *	by (13,10) pairs, These pairs are converted into (CR,LF)
 *	pairs in the local representation.  The (CR,LF) sequence
 *	when found is changed to a '\n' character, the internal
 *	C representation of a new line.
 */
d1542 1
a1542 1
static void NetToText_put_character(HTStream *me, char net_char)
a1544 1

d1551 1
a1551 1
	    me->sink->isa->put_character(me->sink, CR);		/* leftover */
d1556 1
a1556 1
	me->sink->isa->put_character(me->sink, c);	/* normal */
d1559 1
a1559 1
static void NetToText_put_string(HTStream *me, const char *s)
d1561 1
a1561 1
    const char *p;
d1567 1
a1567 1
static void NetToText_put_block(HTStream *me, const char *s, int l)
d1569 1
a1569 1
    const char *p;
d1571 1
a1571 1
    for (p = s; p < (s + l); p++)
d1575 1
a1575 1
static void NetToText_free(HTStream *me)
d1577 1
a1577 1
    (me->sink->isa->_free) (me->sink);	/* Close rest of pipe */
d1581 1
a1581 1
static void NetToText_abort(HTStream *me, HTError e)
d1583 1
a1583 1
    me->sink->isa->_abort(me->sink, e);		/* Abort rest of pipe */
d1589 1
a1589 2
static HTStreamClass NetToTextClass =
{
d1600 1
a1600 1
HTStream *HTNetToText(HTStream *sink)
d1602 1
a1602 1
    HTStream *me = typecalloc(HTStream);
d1613 1
a1613 2
static HTStream HTBaseStreamInstance;	/* Made static */

d1615 6
a1620 6
 *	ERROR STREAM
 *	------------
 *	There is only one error stream shared by anyone who wants a
 *	generic error returned from all stream methods.
 */
static void HTErrorStream_put_character(HTStream *me GCC_UNUSED, char c GCC_UNUSED)
d1625 1
a1625 1
static void HTErrorStream_put_string(HTStream *me GCC_UNUSED, const char *s)
d1631 1
a1631 1
static void HTErrorStream_write(HTStream *me GCC_UNUSED, const char *s, int l)
d1637 1
a1637 1
static void HTErrorStream_free(HTStream *me GCC_UNUSED)
d1642 1
a1642 1
static void HTErrorStream_abort(HTStream *me GCC_UNUSED, HTError e GCC_UNUSED)
d1657 1
a1657 1
HTStream *HTErrorStream(void)
d1660 1
a1660 1
    HTBaseStreamInstance.isa = &HTErrorStreamClass;	/* The rest is random */
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d439 1
a439 1
		    /* otherwise use the first one */
a1086 116

/*	Push data from a deflate file pointer down a stream
 *	-------------------------------------
 *
 *  This routine is responsible for creating and PRESENTING any
 *  graphic (or other) objects described by the file.  The code is
 *  loosely based on the inflate.c file from w3m.
 *
 *
 *  State of file and target stream on entry:
 *		      FILE (zzfp) assumed open (should have deflated content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp still open, target stream still valid.
 */
static int HTZzFileCopy(FILE *zzfp, HTStream *sink)
{
    static char dummy_head[1 + 1] =
    {
	0x8 + 0x7 * 0x10,
	(((0x8 + 0x7 * 0x10) * 0x100 + 30) / 31 * 31) & 0xFF,
    };

    z_stream s;
    HTStreamClass targetClass;
    int bytes;
    int rv = HT_OK;
    char output_buffer[INPUT_BUFFER_SIZE];
    int status;
    int flush;
    int retry = 0;
    int len = 0;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    s.zalloc = Z_NULL;
    s.zfree = Z_NULL;
    s.opaque = Z_NULL;
    status = inflateInit(&s);
    if (status != Z_OK) {
	CTRACE((tfp, "HTZzFileCopy inflateInit() %s\n", zError(status)));
	exit(1);
    }
    s.avail_in = 0;
    s.next_out = (Bytef *) output_buffer;
    s.avail_out = sizeof(output_buffer);
    flush = Z_NO_FLUSH;

    /*  read and inflate deflate'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, 0);
    for (;;) {
	if (s.avail_in == 0) {
	    s.next_in = (Bytef *) input_buffer;
	    len = s.avail_in = fread(input_buffer, 1, INPUT_BUFFER_SIZE, zzfp);
	}
	status = inflate(&s, flush);
	if (status == Z_STREAM_END || status == Z_BUF_ERROR) {
	    len = sizeof(output_buffer) - s.avail_out;
	    if (len > 0) {
		(*targetClass.put_block) (sink, output_buffer, len);
		bytes += len;
		HTReadProgress(bytes, -1);
		HTDisplayPartial();
	    }
	    rv = HT_LOADED;
	    break;
	} else if (status == Z_DATA_ERROR && !retry++) {
	    status = inflateReset(&s);
	    if (status != Z_OK) {
		CTRACE((tfp, "HTZzFileCopy inflateReset() %s\n", zError(status)));
		rv = bytes ? HT_PARTIAL_CONTENT : -1;
		break;
	    }
	    s.next_in = (Bytef *) dummy_head;
	    s.avail_in = sizeof(dummy_head);
	    status = inflate(&s, flush);
	    s.next_in = (Bytef *) input_buffer;
	    s.avail_in = len;
	    continue;
	} else if (status != Z_OK) {
	    CTRACE((tfp, "HTZzFileCopy inflate() %s\n", zError(status)));
	    rv = bytes ? HT_PARTIAL_CONTENT : -1;
	    break;
	} else if (s.avail_out == 0) {
	    len = sizeof(output_buffer);
	    s.next_out = (Bytef *) output_buffer;
	    s.avail_out = sizeof(output_buffer);

	    (*targetClass.put_block) (sink, output_buffer, len);
	    bytes += len;
	    HTReadProgress(bytes, -1);
	    HTDisplayPartial();

	    if (HTCheckForInterrupt()) {
		_HTProgress(TRANSFER_INTERRUPTED);
		rv = bytes ? HT_INTERRUPTED : -1;
		break;
	    }
	}
	retry = 1;
    }				/* next bufferload */

    inflateEnd(&s);
    HTFinishDisplayPartial();
    return rv;
}
a1475 68
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
}

/*	HTParseZzFile
 *
 *  State of file and target stream on entry:
 *			FILE (zzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp closed; target freed, aborted, or NULL.
 */
int HTParseZzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  FILE *zzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	fclose(zzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTZzFileCopy(zzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    fclose(zzfp);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d19 6
d29 1
a29 1
#ifdef UNIX
d36 1
a36 1
#endif /* UNIX */
a44 1
#include <HTTP.h>
a57 4
#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif

d94 3
a96 3
	double,		quality,
	double,		secs,
	double,		secs_per_byte,
d99 1
a99 1
    HTPresentation * pres = typecalloc(HTPresentation);
d106 3
a108 3
    pres->quality = (float) quality;
    pres->secs = (float) secs;
    pres->secs_per_byte = (float) secs_per_byte;
d144 1
a144 1
    HTPresentation * pres = typecalloc(HTPresentation);
d246 1
a246 1
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetCharacter\n"));
d250 1
a250 1
		CTRACE((tfp, "HTFormat: File read error %d\n", status));
d260 1
a260 1
    return FROMASCII(UCH(ch));
d278 1
a278 1
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetSSLCharacter\n"));
d282 1
a282 1
		CTRACE((tfp, "HTFormat: SSL_read error %d\n", status));
d301 1
a301 1
    char *cp = strchr(trial_type, '/');
d307 2
a308 2
    CTRACE((tfp, "HTFormat: comparing %s and %s for half match\n",
		trial_type, target));
a316 2
#define WWW_WILDCARD_REP_OUT HTAtom_for("*")

d333 1
a333 1
    HTAtom * wildcard = NULL; /* = HTAtom_for("*"); lookup when needed - kw */
d335 2
a336 2
    CTRACE((tfp, "HTFormat: Looking up presentation for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d354 2
a355 2
		    CTRACE((tfp, "FindPresentation: found exact match: %s\n",
				HTAtom_name(pres->rep)));
d360 6
a365 9
		} else {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard) {
			if (!strong_wildcard_match)
			    strong_wildcard_match = pres;
			/* otherwise use the first one */
			CTRACE((tfp, "StreamStack: found strong wildcard match: %s\n",
				    HTAtom_name(pres->rep)));
		    }
d377 2
a378 2
		    CTRACE((tfp, "StreamStack: found strong subtype wildcard match: %s\n",
				HTAtom_name(pres->rep)));
d387 5
a391 6
		    CTRACE((tfp, "StreamStack: found weak wildcard match: %s\n",
				HTAtom_name(pres->rep_out)));

		} else if (!last_default_match) {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard)
a431 1
    HTStream *result;
d433 2
a434 2
    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d438 1
a438 2
     */
#if 0
d440 1
a440 2
	return sink;	/*  LJM */
#endif
d442 2
a443 2
    if (rep_out == rep_in) {
	result = sink;
d445 1
a445 1
    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp))) {
d447 1
a447 1
	    CTRACE((tfp, "StreamStack: Using %s\n", HTAtom_name(temp.rep_out)));
d449 2
a450 2
	    CTRACE((tfp, "StreamStack: found exact match: %s\n",
			HTAtom_name(match->rep)));
d452 1
a452 1
	result = (*match->converter)(match, anchor, sink);
d454 1
a454 11
	result = NULL;
    }
    if (TRACE) {
	if (result && result->isa && result->isa->name) {
	    CTRACE((tfp, "StreamStack: Returning \"%s\"\n", result->isa->name));
	} else if (result) {
	    CTRACE((tfp, "StreamStack: Returning *unknown* stream!\n"));
	} else {
	    CTRACE((tfp, "StreamStack: Returning NULL!\n"));
	    CTRACE_FLUSH(tfp);	/* a crash may be imminent... - kw */
	}
a455 1
    return result;
a473 50

/*
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
PUBLIC void HTFilterPresentations NOARGS
{
    int i, j;
    int n = HTList_count(HTPresentations);
    HTPresentation *p, *q;
    BOOL matched;
    char *s, *t, *x, *y;

    for (i = 0; i < n; i++) {
	p = (HTPresentation *)HTList_objectAt(HTPresentations, i);
	s = HTAtom_name(p->rep);

	if (p->rep_out == WWW_PRESENT) {
	    if (p->rep != WWW_SOURCE
	     && strcasecomp(s, "www/mime")
	     && strcasecomp(s, "www/compressed")
	     && p->quality <= 1.0 && p->quality >= 0.0) {
		for (j = 0, matched = FALSE; j < i; j++) {
		    q = (HTPresentation *)HTList_objectAt(HTPresentations, j);
		    t = HTAtom_name(q->rep);

		    if (!strcasecomp(s, t)) {
			matched = TRUE;
			break;
		    }
		    if ((x = strchr(s, '/')) != 0
		     && (y = strchr(t, '/')) != 0) {
			int len1 = x++ - s;
			int len2 = y++ - t;
			int lens = (len1 > len2) ? len1 : len2;

			if ((*t == '*' || !strncasecomp(s, t, lens))
			 && (*y == '*' || !strcasecomp(x, y))) {
			    matched = TRUE;
			    break;
			}
		    }
		}
		if (!matched)
		    p->get_accept = TRUE;
	    }
	}
    }
}

d488 1
a488 1
    HTAtom * wildcard = WWW_WILDCARD_REP_OUT;
d490 2
a491 2
    CTRACE((tfp, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
		HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));
d516 1
a516 1
    return (float) -1e30;	/* Really bad */
d532 1
a532 1
	**  HText_getNumOfLines() = "current" number of complete lines received
a533 1
	**  (we update NumOfLines_partial only when we repaint the display.)
d535 5
a539 3
	**  display_partial could only be enabled in HText_new()
	**  so a new HTMainText object available - all HText_ functions use it,
	**  lines counter HText_getNumOfLines() in particular.
d548 3
a550 3
	int Newline_partial = LYGetNewline();

	if (((Newline_partial + display_lines) - 1 > NumOfLines_partial)
d553 2
a554 2
		((Newline_partial + partial_threshold) -1 <= HText_getNumOfLines()) :
		((Newline_partial + display_lines) - 1 <= HText_getNumOfLines()))
d563 1
a563 1
	    LYMainLoop_pageDisplay(Newline_partial);
d574 10
d588 4
a633 1
    BOOL suppress_readprogress = NO;
a635 6
#ifdef _WINDOWS	/* 1997/11/11 (Tue) 15:18:16 */
    long file_length;
    extern int bytes_already_read;

    file_length = anchor->content_length;
#endif
a686 3
#ifdef _WINDOWS	/* 1997/11/10 (Mon) 16:57:18 */
		       SOCKET_ERRNO == ETIMEDOUT ||
#endif
d708 4
a711 4
		   HTInetStatus("NETREAD");
		   HTAlert("Unexpected server disconnect.");
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
d719 2
a720 2
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
a748 10
	/*
	 *  Suppress ReadProgress messages when collecting a redirection
	 *  message, at least initially (unless/until anchor->content_type
	 *  gets changed, probably by the MIME message parser).  That way
	 *  messages put up by the HTTP module or elsewhere can linger in
	 *  the statusline for a while. - kw
	 */
	suppress_readprogress = (anchor && anchor->content_type &&
				 !strcmp(anchor->content_type,
					 "message/x-http-redirection"));
d760 1
a760 2
	if (!suppress_readprogress)
	    HTReadProgress(bytes, anchor ? anchor->content_length : 0);
d816 2
a817 2
	    CTRACE((tfp, "HTFormat: Read error, read returns %d\n",
			ferror(fp)));
d829 1
a829 7
	/*  Suppress last screen update in partial mode - a regular update
	 *  under control of mainloop() should follow anyway. - kw
	 */
#ifdef DISP_PARTIAL
	if (display_partial && bytes != HTMainAnchor->content_length)
	    HTDisplayPartial();
#endif
d867 1
a867 1
    HTStreamClass targetClass;
a871 1
    targetClass = *(sink->isa);
d948 4
a951 4
	    CTRACE((tfp, "HTGzFileCopy: Read error, gzread returns %d\n",
			status));
	    CTRACE((tfp, "gzerror   : %s\n",
			gzerror(gzfp, &gzerrnum)));
d1002 1
a1002 1
    int character;
d1016 1
a1016 1
	if (character == EOF)
d1018 1
a1018 1
	(*targetClass.put_character)(sink, UCH(character));
d1077 1
a1077 1
	CTRACE((tfp, "HTFormat: %s\n", buffer));
d1127 3
a1129 6
#ifdef SH_EX		/* 1998/01/04 (Sun) 16:04:09 */
    if (fp == NULL)
	return HT_LOADED;
#endif

    stream = HTStreamStack(rep_in, format_out, sink, anchor);
d1139 1
a1139 1
	CTRACE((tfp, "HTFormat(in HTParseFile): %s\n", buffer));
d1181 1
a1181 1
**  State of memory and target stream on return:
d1200 1
a1200 1
	CTRACE((tfp, "HTFormat(in HTParseMem): %s\n", buffer));
d1227 1
a1227 1
	    CTRACE((tfp, "gzclose   : error number %d\n", gzres));
d1260 3
a1262 1
    stream = HTStreamStack(rep_in, format_out, sink, anchor);
d1273 1
a1273 1
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
d1325 1
a1325 1
    me->had_cr = (BOOL) (c == CR);
d1373 1
a1373 1
    HTStream* me = typecalloc(HTStream);
a1383 50
PRIVATE HTStream	HTBaseStreamInstance;		      /* Made static */
/*
**	ERROR STREAM
**	------------
**	There is only one error stream shared by anyone who wants a
**	generic error returned from all stream methods.
*/
PRIVATE void HTErrorStream_put_character ARGS2(HTStream *, me GCC_UNUSED, char, c GCC_UNUSED)
{
    LYCancelDownload = TRUE;
}

PRIVATE void HTErrorStream_put_string ARGS2(HTStream *, me GCC_UNUSED, CONST char *, s)
{
    if (s && *s)
	LYCancelDownload = TRUE;
}

PRIVATE void HTErrorStream_write ARGS3(HTStream *, me GCC_UNUSED, CONST char *, s, int, l)
{
    if (l && s)
	LYCancelDownload = TRUE;
}

PRIVATE void HTErrorStream_free ARGS1(HTStream *, me GCC_UNUSED)
{
    return;
}

PRIVATE void HTErrorStream_abort ARGS2(HTStream *, me GCC_UNUSED, HTError, e GCC_UNUSED)
{
    return;
}

PRIVATE CONST HTStreamClass HTErrorStreamClass =
{
    "ErrorStream",
    HTErrorStream_free,
    HTErrorStream_abort,
    HTErrorStream_put_character,
    HTErrorStream_put_string,
    HTErrorStream_write
};

PUBLIC HTStream * HTErrorStream NOARGS
{
    CTRACE((tfp, "ErrorStream. Created\n"));
    HTBaseStreamInstance.isa = &HTErrorStreamClass;    /* The rest is random */
    return &HTBaseStreamInstance;
}
@

