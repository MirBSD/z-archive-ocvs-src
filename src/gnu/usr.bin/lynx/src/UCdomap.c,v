head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.5
	tg-mergefixes-1-branch:1.1.3.5.0.8
	tg-mergefixes-1-base:1.1.3.5
	MIROS_X:1.1.3.5.0.6
	MIROS_X_BASE:1.1.3.5
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.46.09;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.13.12.52;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.40;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.36;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.29;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.53;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.23;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.46.15;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.11.38;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.16.06;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.54.02;	author tg;	state Stab;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/*
 *  UCdomap.c
 *  =========
 *
 * This is a Lynx chartrans engine, its external calls are in UCMap.h
 *
 * Derived from code in the Linux kernel console driver.
 * The GNU Public Licence therefore applies, see
 * the file COPYING in the top-level directory
 * which should come with every Lynx distribution.
 *
 *  [ original comment: - KW ]
 *
 * Mapping from internal code (such as Latin-1 or Unicode or IBM PC code)
 * to font positions.
 *
 * aeb, 950210
 */
#include <HTUtils.h>
#include <HTMLDTD.h>

#include <LYGlobalDefs.h>
#include <UCdomap.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <LYCharSets.h>

#if defined(EXP_LOCALE_CHARSET) && defined(HAVE_LANGINFO_CODESET)
#include <langinfo.h>
#endif

#ifdef EXP_JAPANESEUTF8_SUPPORT
#include <iconv.h>
#endif

#include <LYLeaks.h>

/*
 * Include chartrans tables:
 */
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)   */
#include <cp1251_uni.h>		/* WinCyrillic (cp1251) */
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)   */
#include <cp1253_uni.h>		/* WinGreek (cp1253)    */
#include <cp1255_uni.h>		/* WinHebrew (cp1255)   */
#include <cp1256_uni.h>		/* WinArabic (cp1256)   */
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)  */
#include <cp437_uni.h>		/* DosLatinUS (cp437)   */
#include <cp737_uni.h>		/* DosGreek (cp737)     */
#include <cp775_uni.h>		/* DosBaltRim (cp775)   */
#include <cp850_uni.h>		/* DosLatin1 (cp850)    */
#include <cp852_uni.h>		/* DosLatin2 (cp852)    */
#include <cp862_uni.h>		/* DosHebrew (cp862)    */
#include <cp864_uni.h>		/* DosArabic (cp864)    */
#include <cp866_uni.h>		/* DosCyrillic (cp866)  */
#include <cp869_uni.h>		/* DosGreek2 (cp869)    */
#include <def7_uni.h>		/* 7 bit approximations */
#include <dmcs_uni.h>		/* DEC Multinational    */
#include <hp_uni.h>		/* HP Roman8            */
#include <iso01_uni.h>		/* ISO Latin 1          */
#include <iso02_uni.h>		/* ISO Latin 2          */
#include <iso03_uni.h>		/* ISO Latin 3          */
#include <iso04_uni.h>		/* ISO Latin 4          */
#include <iso05_uni.h>		/* ISO 8859-5 Cyrillic  */
#include <iso06_uni.h>		/* ISO 8859-6 Arabic    */
#include <iso07_uni.h>		/* ISO 8859-7 Greek     */
#include <iso08_uni.h>		/* ISO 8859-8 Hebrew    */
#include <iso09_uni.h>		/* ISO 8859-9 (Latin 5) */
#include <iso10_uni.h>		/* ISO 8859-10          */
#include <iso15_uni.h>		/* ISO 8859-15 (Latin 9) */
#include <koi8r_uni.h>		/* KOI8-R Cyrillic      */
#include <mac_uni.h>		/* Macintosh (8 bit)    */
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic    */
#include <next_uni.h>		/* NeXT character set   */
#include <rfc_suni.h>		/* RFC 1345 w/o Intro   */
/* #include <utf8_uni.h> *//* UNICODE UTF 8        */
#include <viscii_uni.h>		/* Vietnamese (VISCII)  */
#include <cp866u_uni.h>		/* Ukrainian Cyrillic (866) */
#include <koi8u_uni.h>		/* Ukrainian Cyrillic (koi8-u */
#include <pt154_uni.h>		/* Cyrillic-Asian (PT154) */

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
int auto_display_charset = -1;
#endif

static const char *UC_GNsetMIMEnames[4] =
{"iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"};

static int UC_GNhandles[4] =
{-1, -1, -1, -1};

/*
 * Some of the code below, and some of the comments, are left in for
 * historical reasons.  Not all those tables below are currently
 * really needed (and what with all those hardwired codepoints),
 * but let's keep them around for now.  They may come in handy if we
 * decide to make more extended use of the mechanisms (including e.g.
 * for chars < 127...).  - KW
 */

static u16 translations[][256] =
{
    /*
     * 8-bit Latin-1 mapped to Unicode -- trivial mapping.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * VT100 graphics mapped to Unicode.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,
	0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
	0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0xf800,
	0xf801, 0x2500, 0xf803, 0xf804, 0x251c, 0x2524, 0x2534, 0x252c,
	0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * IBM Codepage 437 mapped to Unicode.
     */
    {
	0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
	0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
	0x25ba, 0x25c4, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
	0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
	0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
	0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
	0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
	0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
	0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
	0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
	0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
	0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
	0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
	0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
	0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
	0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
	0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
	0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
    },
    /*
     * User mapping -- default to codes for direct font mapping.
     */
    {
	0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,
	0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,
	0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,
	0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,
	0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,
	0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,
	0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,
	0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,
	0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,
	0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,
	0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,
	0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,
	0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,
	0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,
	0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,
	0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,
	0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,
	0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,
	0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,
	0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,
	0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,
	0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,
	0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,
	0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,
	0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,
	0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,
	0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,
	0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,
	0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,
	0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,
	0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,
	0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff
    }
};
static u16 *UC_translate = NULL;

static struct UC_charset UCInfo[MAXCHARSETS];

/*
 * The standard kernel character-to-font mappings are not invertible
 * -- this is just a best effort.
 */
#define MAX_GLYPH 512		/* Max possible glyph value */

static unsigned char *inv_translate = NULL;
static unsigned char inv_norm_transl[MAX_GLYPH];
static unsigned char *inverse_translations[4] =
{NULL, NULL, NULL, NULL};

static void set_inverse_transl(int i);
static u16 *set_translate(int m);
static int UC_valid_UC_charset(int UC_charset_hndl);
static void UC_con_set_trans(int UC_charset_in_hndl, int Gn, int update_flag);
static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault);
static int con_insert_unipair_str(u16 unicode, const char *replace_str, int fordefault);
static void con_clear_unimap(int fordefault);
static void con_clear_unimap_str(int fordefault);
static void con_set_default_unimap(void);
static int UC_con_set_unimap(int UC_charset_out_hndl, int update_flag);
static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list, int fordefault);
static int conv_uni_to_pc(long ucs, int usedefault);
static int conv_uni_to_str(char *outbuf, int buflen, long ucs, int usedefault);
static void UCconsole_map_init(void);
static int UC_MapGN(int UChndl, int update_flag);
static int UC_FindGN_byMIME(const char *UC_MIMEcharset);
static void UCreset_allocated_LYCharSets(void);
static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl, unsigned lowest8);
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit);

#ifdef LY_FIND_LEAKS
static void UCfree_allocated_LYCharSets(void);
static void UCcleanup_mem(void);
#endif

static int default_UChndl = -1;

static void set_inverse_transl(int i)
{
    int j, glyph;
    u16 *p = translations[i];
    unsigned char *q = inverse_translations[i];

    if (!q) {
	/*
	 * Slightly messy to avoid calling kmalloc too early.
	 */
	q = inverse_translations[i] = ((i == LAT1_MAP) ?
				       inv_norm_transl :
				       (unsigned char *) malloc(MAX_GLYPH));
	if (!q)
	    return;
    }
    for (j = 0; j < MAX_GLYPH; j++)
	q[j] = 0;

    for (j = 0; j < E_TABSZ; j++) {
	glyph = conv_uni_to_pc(p[j], 0);
	if (glyph >= 0 && glyph < MAX_GLYPH && q[glyph] < 32) {
	    /*
	     * Prefer '-' above SHY etc.
	     */
	    q[glyph] = UCH(j);
	}
    }
}

static u16 *set_translate(int m)
{
    if (!inverse_translations[m])
	set_inverse_transl(m);
    inv_translate = inverse_translations[m];
    return translations[m];
}

static int UC_valid_UC_charset(int UC_charset_hndl)
{
    return (UC_charset_hndl >= 0 && UC_charset_hndl < UCNumCharsets);
}

static void UC_con_set_trans(int UC_charset_in_hndl,
			     int Gn,
			     int update_flag)
{
    int i, j;
    const u16 *p;
    u16 *ptrans;

    if (!UC_valid_UC_charset(UC_charset_in_hndl)) {
	CTRACE((tfp, "UC_con_set_trans: Invalid charset handle %d.\n",
		UC_charset_in_hndl));
	return;
    }
    ptrans = translations[Gn];
    p = UCInfo[UC_charset_in_hndl].unitable;
#if(0)
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
	return;			/* nothing to be done */
    }
    /*
     * The font is always 256 characters - so far.
     */
    con_clear_unimap();
#endif
    for (i = 0; i < 256; i++) {
	if ((j = UCInfo[UC_charset_in_hndl].unicount[i])) {
	    ptrans[i] = *p;
	    for (; j; j--) {
		p++;
	    }
	} else {
	    ptrans[i] = 0xfffd;
	}
    }
    if (update_flag) {
	set_inverse_transl(Gn);	/* Update inverse translation for this one */
    }
}

/*
 * Unicode -> current font conversion
 *
 * A font has at most 512 chars, usually 256.
 * But one font position may represent several Unicode chars.
 * A hashtable is somewhat of a pain to deal with, so use a
 * "paged table" instead.  Simulation has shown the memory cost of
 * this 3-level paged table scheme to be comparable to a hash table.
 */
static int hashtable_contents_valid = 0;	/* Use ASCII-only mode for bootup */
static int hashtable_str_contents_valid = 0;

static u16 **uni_pagedir[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

static char ***uni_pagedir_str[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

static const u16 *UC_current_unitable = NULL;
static struct unimapdesc_str *UC_current_unitable_str = NULL;

/*
 * Keep a second set of structures for the translation designated
 * as "default" - kw
 */
static int unidefault_contents_valid = 0;	/* Use ASCII-only mode for bootup */
static int unidefault_str_contents_valid = 0;

static u16 **unidefault_pagedir[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};
static char ***unidefault_pagedir_str[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

static const u16 *UC_default_unitable = 0;
static const struct unimapdesc_str *UC_default_unitable_str = 0;

static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault)
{
    int i, n;
    u16 **p1, *p2;

    if (fordefault)
	p1 = unidefault_pagedir[n = unicode >> 11];
    else
	p1 = uni_pagedir[n = unicode >> 11];
    if (!p1) {
	p1 = (u16 * *)malloc(32 * sizeof(u16 *));
	if (fordefault)
	    unidefault_pagedir[n] = p1;
	else
	    uni_pagedir[n] = p1;
	if (!p1)
	    return -1;

	for (i = 0; i < 32; i++) {
	    p1[i] = NULL;
	}
    }

    if (!(p2 = p1[n = (unicode >> 6) & 0x1f])) {
	p2 = p1[n] = (u16 *) malloc(64 * sizeof(u16));
	if (!p2)
	    return -1;

	for (i = 0; i < 64; i++) {
	    p2[i] = 0xffff;	/* No glyph for this character (yet) */
	}
    }

    p2[unicode & 0x3f] = fontpos;

    return 0;
}

static int con_insert_unipair_str(u16 unicode, const char *replace_str,
				  int fordefault)
{
    int i, n;
    char ***p1;
    const char **p2;

    if (fordefault)
	p1 = unidefault_pagedir_str[n = unicode >> 11];
    else
	p1 = uni_pagedir_str[n = unicode >> 11];
    if (!p1) {
	p1 = (char ***) malloc(32 * sizeof(char **));

	if (fordefault)
	    unidefault_pagedir_str[n] = p1;
	else
	    uni_pagedir_str[n] = p1;
	if (!p1)
	    return -1;

	for (i = 0; i < 32; i++) {
	    p1[i] = NULL;
	}
    }

    n = ((unicode >> 6) & 0x1f);
    if (!p1[n]) {
	p1[n] = (char **) malloc(64 * sizeof(char *));

	if (!p1[n])
	    return -1;

	p2 = (const char **) p1[n];
	for (i = 0; i < 64; i++) {
	    p2[i] = NULL;	/* No replace string this character (yet) */
	}
    }
    p2 = (const char **) p1[n];

    p2[unicode & 0x3f] = replace_str;

    return 0;
}

/*
 * ui arg was a leftover, deleted.  - KW
 */
static void con_clear_unimap(int fordefault)
{
    int i, j;
    u16 **p1;

    if (fordefault) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = unidefault_pagedir[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    unidefault_pagedir[i] = NULL;
	}

	unidefault_contents_valid = 1;
    } else {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    uni_pagedir[i] = NULL;
	}

	hashtable_contents_valid = 1;
    }
}

static void con_clear_unimap_str(int fordefault)
{
    int i, j;
    char ***p1;

    if (fordefault) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = unidefault_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    unidefault_pagedir_str[i] = NULL;
	}

	unidefault_str_contents_valid = 1;	/* ??? probably no use... */
    } else {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    uni_pagedir_str[i] = NULL;
	}

	hashtable_str_contents_valid = 1;	/* ??? probably no use... */
    }
}

/*
 * Loads the unimap for the hardware font, as defined in uni_hash.tbl.
 * The representation used was the most compact I could come up
 * with.  This routine is executed at sys_setup time, and when the
 * PIO_FONTRESET ioctl is called.
 */
static void con_set_default_unimap(void)
{
    int i, j;
    const u16 *p;

    /*
     * The default font is always 256 characters.
     */
    con_clear_unimap(1);

    p = dfont_unitable;
    for (i = 0; i < 256; i++) {
	for (j = dfont_unicount[i]; j; j--) {
	    con_insert_unipair(*(p++), (u16) i, 1);
	}
    }

    UC_default_unitable = dfont_unitable;

    con_clear_unimap_str(1);
    UC_con_set_unimap_str(dfont_replacedesc.entry_ct, repl_map, 1);
    UC_default_unitable_str = &dfont_replacedesc;
}

int UCNumCharsets = 0;

int UCLYhndl_HTFile_for_unspec = -1;
int UCLYhndl_HTFile_for_unrec = -1;
int UCLYhndl_for_unspec = -1;
int UCLYhndl_for_unrec = -1;

/* easy to type, will initialize later */
int LATIN1 = -1;		/* UCGetLYhndl_byMIME("iso-8859-1") */
int US_ASCII = -1;		/* UCGetLYhndl_byMIME("us-ascii")   */
int UTF8_handle = -1;		/* UCGetLYhndl_byMIME("utf-8")      */
int TRANSPARENT = -1;		/* UCGetLYhndl_byMIME("x-transparent")  */

static int UC_con_set_unimap(int UC_charset_out_hndl,
			     int update_flag)
{
    int i, j;
    const u16 *p;

    if (!UC_valid_UC_charset(UC_charset_out_hndl)) {
	CTRACE((tfp, "UC_con_set_unimap: Invalid charset handle %d.\n",
		UC_charset_out_hndl));
	return -1;
    }

    p = UCInfo[UC_charset_out_hndl].unitable;
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
	return update_flag;	/* nothing to be done */
    }
    UC_current_unitable = p;

    /*
     * The font is always 256 characters - so far.
     */
    con_clear_unimap(0);

    for (i = 0; i < 256; i++) {
	for (j = UCInfo[UC_charset_out_hndl].unicount[i]; j; j--) {
	    con_insert_unipair(*(p++), (u16) i, 0);
	}
    }

    if (update_flag) {
	for (i = 0; i <= 3; i++) {
	    set_inverse_transl(i);	/* Update all inverse translations */
	}
    }

    return 0;
}

static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list,
				 int fordefault)
{
    int err = 0, err1;

    while (ct--) {
	if ((err1 = con_insert_unipair_str(list->unicode,
					   list->replace_str,
					   fordefault)) != 0) {
	    err = err1;
	}
	list++;
    }

    /*
     * No inverse translations for replacement strings!
     */
    if (!err) {
	if (fordefault)
	    unidefault_str_contents_valid = 1;
	else
	    hashtable_str_contents_valid = 1;
    }

    return err;
}

static int conv_uni_to_pc(long ucs,
			  int usedefault)
{
    int h;
    u16 **p1, *p2;

    /*
     * Only 16-bit codes supported at this time.
     */
    if (ucs > 0xffff) {
	/*
	 * U+FFFD:  REPLACEMENT CHARACTER.
	 */
	ucs = 0xfffd;
    } else if (ucs < 0x20 || ucs >= 0xfffe) {
	/*
	 * Not a printable character.
	 */
	return -1;
    } else if (ucs == 0xfeff || (ucs >= 0x200b && ucs <= 0x200f)) {
	/*
	 * Zero-width space.
	 */
	return -2;
    } else if ((ucs & ~UNI_DIRECT_MASK) == UNI_DIRECT_BASE) {
	/*
	 * UNI_DIRECT_BASE indicates the start of the region in the
	 * User Zone which always has a 1:1 mapping to the currently
	 * loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 * of the region.
	 */
	return (ucs & UNI_DIRECT_MASK);
    }

    if (usedefault) {
	if (!unidefault_contents_valid)
	    return -3;
	p1 = unidefault_pagedir[ucs >> 11];
    } else {
	if (!hashtable_contents_valid)
	    return -3;
	p1 = uni_pagedir[ucs >> 11];
    }

    if (p1 &&
	(p2 = p1[(ucs >> 6) & 0x1f]) &&
	(h = p2[ucs & 0x3f]) < MAX_GLYPH) {
	return h;
    }

    /*
     * Not found.
     */
    return -4;
}

/*
 * Note:  contents of outbuf is not changes for negative return value!
 */
static int conv_uni_to_str(char *outbuf,
			   int buflen,
			   long ucs,
			   int usedefault)
{
    char *h;
    char ***p1, **p2;

    /*
     * Only 16-bit codes supported at this time.
     */
    if (ucs > 0xffff) {
	/*
	 * U+FFFD:  REPLACEMENT CHARACTER.
	 */
	ucs = 0xfffd;
	/*
	 * Maybe the following two cases should be allowed here??  - KW
	 */
    } else if (ucs < 0x20 || ucs >= 0xfffe) {
	/*
	 * Not a printable character.
	 */
	return -1;
    } else if (ucs == 0xfeff || (ucs >= 0x200b && ucs <= 0x200f)) {
	/*
	 * Zero-width space.
	 */
	return -2;
    }

    if (usedefault) {
	if (!unidefault_str_contents_valid)
	    return -3;
	p1 = unidefault_pagedir_str[ucs >> 11];
    } else {
	if (!hashtable_str_contents_valid)
	    return -3;
	p1 = uni_pagedir_str[ucs >> 11];
    }

    if (p1 &&
	(p2 = p1[(ucs >> 6) & 0x1f]) &&
	(h = p2[ucs & 0x3f])) {
	strncpy(outbuf, h, (size_t) (buflen - 1));
	return 1;		/* ok ! */
    }

    /*
     * Not found.
     */
    return -4;
}

int UCInitialized = 0;

/*
 * [ original comment:  - KW ]
 * This is called at sys_setup time, after memory and the console are
 * initialized.  It must be possible to call kmalloc(..., GFP_KERNEL)
 * from this function, hence the call from sys_setup.
 */
static void UCconsole_map_init(void)
{
    con_set_default_unimap();
    UCInitialized = 1;
}

/*
 * OK now, finally, some stuff that is more specifically for Lynx:  - KW
 */
int UCTransUniChar(long unicode,
		   int charset_out)
{
    int rc = 0;
    int UChndl_out;
    int isdefault, trydefault = 0;
    const u16 *ut;

    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return (unicode < 128) ? (int) unicode : LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return -12;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }

    if (!isdefault) {
	ut = UCInfo[UChndl_out].unitable;
	if (ut != UC_current_unitable) {
	    rc = UC_con_set_unimap(UChndl_out, 1);
	    if (rc < 0) {
		return rc;
	    }
	}
	rc = conv_uni_to_pc(unicode, 0);
	if (rc >= 0)
	    return rc;
    }
    if (isdefault || trydefault) {
	rc = conv_uni_to_pc(unicode, 1);
	if (rc >= 0)
	    return rc;
    }
    if (!isdefault && (rc == -4)) {
	rc = conv_uni_to_pc(0xfffd, 0);
    }
    if ((isdefault || trydefault) && (rc == -4)) {
	rc = conv_uni_to_pc(0xfffd, 1);
    }
    return rc;
}

/*
 * Returns string length, or negative value for error.
 */
int UCTransUniCharStr(char *outbuf,
		      int buflen,
		      long unicode,
		      int charset_out,
		      int chk_single_flag)
{
    int rc = -14, src = 0, ignore_err;
    int UChndl_out;
    int isdefault, trydefault = 0;
    struct unimapdesc_str *repl;
    const u16 *ut;

    if (buflen < 2)
	return -13;

    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return -12;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }

    if (chk_single_flag) {
	if (!isdefault) {
	    ut = UCInfo[UChndl_out].unitable;
	    if (ut != UC_current_unitable) {
		src = UC_con_set_unimap(UChndl_out, 1);
		if (src < 0) {
		    return src;
		}
	    }
	}
	src = conv_uni_to_pc(unicode, isdefault);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }

    repl = &(UCInfo[UChndl_out].replacedesc);
    if (!isdefault) {
	if (repl != UC_current_unitable_str) {
	    con_clear_unimap_str(0);
	    ignore_err = UC_con_set_unimap_str(repl->entry_ct, repl->entries, 0);
	    UC_current_unitable_str = repl;
	}
	rc = conv_uni_to_str(outbuf, buflen, unicode, 0);
	if (rc >= 0)
	    return (strlen(outbuf));
    }
    if (trydefault && chk_single_flag) {
	src = conv_uni_to_pc(unicode, 1);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }
    if (isdefault || trydefault) {
#ifdef EXP_JAPANESEUTF8_SUPPORT
	if ((strcmp(LYCharSet_UC[charset_out].MIMEname, "shift_jis") == 0) ||
	    (strcmp(LYCharSet_UC[charset_out].MIMEname, "euc-jp") == 0)) {
	    iconv_t cd;
	    char str[3], *pin, *pout;
	    size_t inleft, outleft;

	    str[0] = unicode >> 8;
	    str[1] = unicode & 0xFF;
	    str[2] = 0;
	    pin = str;
	    inleft = 2;
	    pout = outbuf, outleft = buflen;
	    cd = iconv_open(LYCharSet_UC[charset_out].MIMEname,
			    "UTF-16BE//TRANSLIT");
	    rc = iconv(cd, &pin, &inleft, &pout, &outleft);
	    iconv_close(cd);
	    if ((pout - outbuf) == 3) {
		CTRACE((tfp,
			"It seems to be a JIS X 0201 code(%ld). Not supported.\n", unicode));
		pin = str;
		inleft = 2;
		pout = outbuf, outleft = buflen;
	    } else if (rc >= 0) {
		*pout = '\0';
		return (strlen(outbuf));
	    }
	}
#endif
	rc = conv_uni_to_str(outbuf, buflen, unicode, 1);
	if (rc >= 0)
	    return (strlen(outbuf));
    }
    if (rc == -4) {
	if (!isdefault)
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 0);
	if ((rc == -4) && (isdefault || trydefault))
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 1);
	if (rc >= 0)
	    return (strlen(outbuf));
    }
    if (chk_single_flag && src == -4) {
	if (!isdefault)
	    rc = conv_uni_to_pc(0xfffd, 0);
	if ((rc == -4) && (isdefault || trydefault))
	    rc = conv_uni_to_pc(0xfffd, 1);
	if (rc >= 32) {
	    outbuf[0] = (char) rc;
	    outbuf[1] = '\0';
	    return 1;
	}
	return rc;
    }
    return -4;
}

static int UC_lastautoGN = 0;

static int UC_MapGN(int UChndl,
		    int update_flag)
{
    int i, Gn, found, lasthndl;

    found = 0;
    Gn = -1;
    for (i = 0; i < 4 && Gn < 0; i++) {
	if (UC_GNhandles[i] < 0) {
	    Gn = i;
	} else if (UC_GNhandles[i] == UChndl) {
	    Gn = i;
	    found = 1;
	}
    }
    if (found)
	return Gn;
    if (Gn >= 0) {
	UCInfo[UChndl].GN = Gn;
	UC_GNhandles[Gn] = UChndl;
    } else {
	if (UC_lastautoGN == GRAF_MAP) {
	    Gn = IBMPC_MAP;
	} else {
	    Gn = GRAF_MAP;
	}
	UC_lastautoGN = Gn;
	lasthndl = UC_GNhandles[Gn];
	UCInfo[lasthndl].GN = -1;
	UCInfo[UChndl].GN = Gn;
	UC_GNhandles[Gn] = UChndl;
    }
    CTRACE((tfp, "UC_MapGN: Using %d <- %d (%s)\n",
	    Gn, UChndl, UCInfo[UChndl].MIMEname));
    UC_con_set_trans(UChndl, Gn, update_flag);
    return Gn;
}

int UCTransChar(char ch_in,
		int charset_in,
		int charset_out)
{
    int unicode, Gn;
    int rc = -4;
    int UChndl_in, UChndl_out;
    int isdefault, trydefault = 0;
    const u16 *ut;
    int upd = 0;

#ifndef UC_NO_SHORTCUTS
    if (charset_in == charset_out)
	return UCH(ch_in);
#endif /* UC_NO_SHORTCUTS */
    if (charset_in < 0)
	return -11;
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return -11;
    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return -12;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }
    if (!UCInfo[UChndl_in].num_uni)
	return -11;
    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
	Gn = UC_MapGN(UChndl_in, 0);
	upd = 1;
    }

    ut = UCInfo[UChndl_out].unitable;
    if (!isdefault) {
	if (ut == UC_current_unitable) {
	    if (upd) {
		set_inverse_transl(Gn);
	    }
	} else {
	    rc = UC_con_set_unimap(UChndl_out, 1);
	    if (rc > 0) {
		set_inverse_transl(Gn);
	    } else if (rc < 0) {
		return rc;
	    }
	}
    }
    UC_translate = set_translate(Gn);
    unicode = UC_translate[UCH(ch_in)];
    if (!isdefault) {
	rc = conv_uni_to_pc(unicode, 0);
	if (rc >= 0)
	    return rc;
    }
    if ((rc == -4) && (isdefault || trydefault)) {
	rc = conv_uni_to_pc(unicode, 1);
    }
    if ((rc == -4) && !isdefault) {
	rc = conv_uni_to_pc(0xfffd, 0);
    }
    if ((rc == -4) && (isdefault || trydefault)) {
	rc = conv_uni_to_pc(0xfffd, 1);
    }
    return rc;
}

long int UCTransToUni(char ch_in,
		      int charset_in)
{
    int unicode, Gn;
    unsigned char ch_iu;
    int UChndl_in;

    ch_iu = UCH(ch_in);
#ifndef UC_NO_SHORTCUTS
    if (charset_in == LATIN1)
	return ch_iu;
    if (UCH(ch_in) < 128 && UCH(ch_in) >= 32)
	return ch_iu;
#endif /* UC_NO_SHORTCUTS */
    if (charset_in < 0)
	return -11;
    if (UCH(ch_in) < 32 &&
	LYCharSet_UC[charset_in].enc != UCT_ENC_8BIT_C0)
	/*
	 * Don't translate C0 chars except for specific charsets.
	 */
	return ch_iu;
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return -11;
    if (!UCInfo[UChndl_in].num_uni)
	return -11;
    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
	Gn = UC_MapGN(UChndl_in, 1);
    }

    UC_translate = set_translate(Gn);
    unicode = UC_translate[UCH(ch_in)];

    return unicode;
}

int UCReverseTransChar(char ch_out,
		       int charset_in,
		       int charset_out)
{
    int Gn;
    int rc = -1;
    int UChndl_in, UChndl_out;
    int isdefault;
    int i_ch = UCH(ch_out);
    const u16 *ut;

#ifndef UC_NO_SHORTCUTS
    if (charset_in == charset_out)
	return UCH(ch_out);
#endif /* UC_NO_SHORTCUTS */
    if (charset_in < 0)
	return -11;
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return -11;
    if (!UCInfo[UChndl_in].num_uni)
	return -11;
    if (charset_out < 0)
	return -12;
    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return -12;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    }

    if (!isdefault) {
	/*
	 * Try to use the inverse table if charset_out is not equivalent
	 * to using just the default table.  If it is, it should have
	 * just ASCII chars and trying to back-translate those should
	 * not give anything but themselves.  - kw
	 */
	ut = UCInfo[UChndl_out].unitable;
	if (ut == UC_current_unitable) {
	    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
		Gn = UC_MapGN(UChndl_in, 1);
	    }
	    UC_translate = set_translate(Gn);
	    if (inv_translate)
		rc = inv_translate[i_ch];
	    if (rc >= 32) {
		return rc;
	    }
	}
    }
    return UCTransChar(ch_out, charset_out, charset_in);
}

/*
 * Returns string length, or negative value for error.
 */
int UCTransCharStr(char *outbuf,
		   int buflen,
		   char ch_in,
		   int charset_in,
		   int charset_out,
		   int chk_single_flag)
{
    int unicode, Gn;
    int rc = -14, src = 0, ignore_err;
    int UChndl_in, UChndl_out;
    int isdefault, trydefault = 0;
    struct unimapdesc_str *repl;
    const u16 *ut;
    int upd = 0;

    if (buflen < 2)
	return -13;
#ifndef UC_NO_SHORTCUTS
    if (chk_single_flag && charset_in == charset_out) {
	outbuf[0] = ch_in;
	outbuf[1] = '\0';
	return 1;
    }
#endif /* UC_NO_SHORTCUTS */
    if (charset_in < 0)
	return -11;
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return -11;
    if (!UCInfo[UChndl_in].num_uni)
	return -11;
    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return -12;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }
    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
	Gn = UC_MapGN(UChndl_in, !chk_single_flag);
	upd = chk_single_flag;
    }

    UC_translate = set_translate(Gn);
    unicode = UC_translate[UCH(ch_in)];

    if (chk_single_flag) {
	if (!isdefault) {
	    ut = UCInfo[UChndl_out].unitable;
	    if (ut == UC_current_unitable) {
		if (upd)
		    set_inverse_transl(Gn);
	    } else {
		src = UC_con_set_unimap(UChndl_out, 1);
		if (src > 0) {
		    set_inverse_transl(Gn);
		} else if (src < 0) {
		    return src;
		}
	    }
	}
	src = conv_uni_to_pc(unicode, isdefault);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }

    repl = &(UCInfo[UChndl_out].replacedesc);
    if (!isdefault) {
	if (repl != UC_current_unitable_str) {
	    con_clear_unimap_str(0);
	    ignore_err = UC_con_set_unimap_str(repl->entry_ct, repl->entries, 0);
	    UC_current_unitable_str = repl;
	}
	rc = conv_uni_to_str(outbuf, buflen, unicode, 0);
	if (rc >= 0)
	    return (strlen(outbuf));
    }
    if (trydefault && chk_single_flag) {
	src = conv_uni_to_pc(unicode, 1);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }
    if (isdefault || trydefault) {
	rc = conv_uni_to_str(outbuf, buflen, unicode, 1);
	if (rc >= 0)
	    return (strlen(outbuf));
    }
    if (rc == -4) {
	if (!isdefault)
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 0);
	if ((rc == -4) && (isdefault || trydefault))
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 1);
	if (rc >= 0)
	    return (strlen(outbuf));
    }
    if (chk_single_flag && src == -4) {
	if (!isdefault)
	    rc = conv_uni_to_pc(0xfffd, 0);
	if ((rc == -4) && (isdefault || trydefault))
	    rc = conv_uni_to_pc(0xfffd, 1);
	if (rc >= 32) {
	    outbuf[0] = (char) rc;
	    outbuf[1] = '\0';
	    return 1;
	} else if (rc <= 0) {
	    outbuf[0] = '\0';
	    return rc;
	}
	return rc;
    }
    return -4;
}

static int UC_FindGN_byMIME(const char *UC_MIMEcharset)
{
    int i;

    for (i = 0; i < 4; i++) {
	if (!strcmp(UC_MIMEcharset, UC_GNsetMIMEnames[i])) {
	    return i;
	}
    }
    return -1;
}

int UCGetRawUniMode_byLYhndl(int i)
{
    if (i < 0)
	return 0;
    return LYCharSet_UC[i].enc;
}

/*
 * Construct a new charset name, given prefix and codepage.  This introduces
 * potentially unchecked recursion into UCGetLYhntl_byMIME if neither the "cp"
 * nor "windows-" prefixes are configured, so we check it here.
 */
static int getLYhndl_byCP(const char *prefix,
			  const char *codepage)
{
    static int nested;
    int result = -1;

    if (!nested++) {
	char *cptmp = NULL;

	StrAllocCopy(cptmp, prefix);
	StrAllocCat(cptmp, codepage);
	result = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
    }
    nested--;
    return result;
}

/*
 * Get Lynx internal charset handler from MIME name,
 * return -1 if we got NULL or did not recognize value.
 * According to RFC, MIME headers should match case-insensitively.
 */
int UCGetLYhndl_byMIME(const char *value)
{
    int i;
    int LYhndl = -1;

    if (!value || !(*value)) {
	CTRACE((tfp,
		"UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
	return -1;
    }

    for (i = 0;
	 (i < MAXCHARSETS && i < LYNumCharsets &&
	  LYchar_set_names[i]); i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
	    return i;
	}
    }

    /*
     * Not yet found, try synonyms.  - FM
     */
#if !NO_CHARSET_utf_8
    if (!strcasecomp(value, "unicode-1-1-utf-8") ||
	!strcasecomp(value, "utf8")) {
	/*
	 * Treat these as synonyms for the IANA registered name.  - FM
	 */
	return UCGetLYhndl_byMIME("utf-8");
    }
#endif
#if !NO_CHARSET_euc_jp
    if (!strcasecomp(value, "x-euc-jp")) {
	return UCGetLYhndl_byMIME("euc-jp");
    }
#endif
#if !NO_CHARSET_shift_jis
    if ((!strcasecomp(value, "x-shift-jis")) ||
	(!strcasecomp(value, "x-sjis"))) {
	return UCGetLYhndl_byMIME("shift_jis");
    }
#endif
#if !NO_CHARSET_euc_kr
    if (!strcasecomp(value, "iso-2022-kr")) {
	return UCGetLYhndl_byMIME("euc-kr");
    }
#endif
#if !NO_CHARSET_euc_cn
    if (!strcasecomp(value, "gb2312") ||
	!strncasecomp(value, "cn-gb", 5) ||
	!strcasecomp(value, "iso-2022-cn")) {
	return UCGetLYhndl_byMIME("euc-cn");
    }
#endif
#if !NO_CHARSET_big5
    if (!strcasecomp(value, "cn-big5")) {
	return UCGetLYhndl_byMIME("big5");
    }
#endif
#if !NO_CHARSET_macintosh
    if (!strcasecomp(value, "x-mac-roman") ||
	!strcasecomp(value, "mac-roman")) {
	return UCGetLYhndl_byMIME("macintosh");
    }
#endif
#if !NO_CHARSET_next
    if (!strcasecomp(value, "x-next") ||
	!strcasecomp(value, "nextstep") ||
	!strcasecomp(value, "x-nextstep")) {
	return UCGetLYhndl_byMIME("next");
    }
#endif
#if !NO_CHARSET_windows_1252
    if (!strcasecomp(value, "iso-8859-1-windows-3.1-latin-1") ||
	!strcasecomp(value, "cp1252") ||
	!strcasecomp(value, "cp-1252") ||
	!strcasecomp(value, "ibm1252") ||
	!strcasecomp(value, "iso-8859-1-windows-3.0-latin-1")) {
	/*
	 * Treat these as synonyms for windows-1252, which is more
	 * commonly used than the IANA registered name.  - FM
	 */
	return UCGetLYhndl_byMIME("windows-1252");
    }
#endif
#if !NO_CHARSET_windows_1250
    if (!strcasecomp(value, "iso-8859-2-windows-latin-2") ||
	!strcasecomp(value, "cp1250") ||
	!strcasecomp(value, "cp-1250") ||
	!strcasecomp(value, "ibm1250")) {
	/*
	 * Treat these as synonyms for windows-1250.  - FM
	 */
	return UCGetLYhndl_byMIME("windows-1250");
    }
#endif
    if ((!strncasecomp(value, "ibm", 3) ||
	 !strncasecomp(value, "cp-", 3)) &&
	isdigit(UCH(value[3])) &&
	isdigit(UCH(value[4])) &&
	isdigit(UCH(value[5]))) {
	/*
	 * For "ibmNNN<...>" or "cp-NNN", try "cpNNN<...>"
	 * if not yet found.  - KW & FM
	 */
	if ((LYhndl = getLYhndl_byCP("cp", value + 3)) >= 0)
	    return LYhndl;
	/*
	 * Try windows-NNN<...> if not yet found.  - FM
	 */
	return getLYhndl_byCP("windows-", value + 3);
    }
    if (!strncasecomp(value, "windows-", 8) &&
	isdigit(UCH(value[8])) &&
	isdigit(UCH(value[9])) &&
	isdigit(UCH(value[10]))) {
	/*
	 * For "windows-NNN<...>", try "cpNNN<...>" - FM
	 */
	return getLYhndl_byCP("cp", value + 8);
    }
#if !NO_CHARSET_koi8_r
    if (!strcasecomp(value, "koi-8")) {		/* accentsoft bugosity */
	return UCGetLYhndl_byMIME("koi8-r");
    }
#endif
    /* no more synonyms if come here... */

    CTRACE((tfp, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value));
    return -1;			/* returns -1 if no charset found by that MIME name */
}

/*
 * Function UC_setup_LYCharSets_repl() tries to set up a subtable in
 * LYCharSets[] appropriate for this new charset, for compatibility with the
 * "old method".  Maybe not nice (maybe not even necessary any more), but it
 * works (as far as it goes..).
 *
 * We try to be conservative and only allocate new memory for this if needed. 
 * If not needed, just point to SevenBitApproximations[i].  [Could do the same
 * for ISO_Latin1[] if it's identical to that, but would make it even *more*
 * messy than it already is...] This the only function in this file that knows,
 * or cares, about the HTMLDTD or details of LYCharSets[] subtables (and
 * therefore somewhat violates the idea that this file should be independent of
 * those).  As in other places, we rely on ISO_Latin1 being the *first* table
 * in LYCharSets.  - KW
 */

/*
 * We need to remember which ones were allocated and which are static.
 */
static const char **remember_allocated_LYCharSets[MAXCHARSETS];

static void UCreset_allocated_LYCharSets(void)
{
    int i = 0;

    for (; i < MAXCHARSETS; i++) {
	remember_allocated_LYCharSets[i] = NULL;
    }
}

#ifdef LY_FIND_LEAKS
static void UCfree_allocated_LYCharSets(void)
{
    int i = 0;

    for (; i < MAXCHARSETS; i++) {
	if (remember_allocated_LYCharSets[i] != NULL) {
	    FREE(remember_allocated_LYCharSets[i]);
	}
    }
}
#endif

static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl,
					     unsigned lowest8)
{
    const char **ISO_Latin1 = LYCharSets[0];
    const char **p;
    char **prepl;
    const u16 *pp;
    char **tp;
    const char *s7;
    const char *s8;
    size_t i;
    int j, changed;
    u16 k;
    u8 *ti;

    /*
     * Create a temporary table for reverse lookup of latin1 codes:
     */
    tp = (char **) malloc(96 * sizeof(char *));

    if (!tp)
	return NULL;
    for (i = 0; i < 96; i++)
	tp[i] = NULL;
    ti = (u8 *) malloc(96 * sizeof(u8));
    if (!ti) {
	FREE(tp);
	return NULL;
    }
    for (i = 0; i < 96; i++)
	ti[i] = 0;

    pp = UCInfo[UC_charset_in_hndl].unitable;

    /*
     * Determine if we have any mapping of a Unicode in the range 160-255
     * to an allowed code point > 0x80 in our new charset...
     * Store any mappings found in ti[].
     */
    if (UCInfo[UC_charset_in_hndl].num_uni > 0) {
	for (i = 0; i < 256; i++) {
	    if ((j = UCInfo[UC_charset_in_hndl].unicount[i])) {
		if ((k = *pp) >= 160 && k < 256 && i >= lowest8) {
		    ti[k - 160] = UCH(i);
		}
		for (; j; j--) {
		    pp++;
		}
	    }
	}
    } {
	u16 ct;
	struct unipair_str *list;

	/*
	 * Determine if we have any mapping of a Unicode in the range
	 * 160-255 to a replacement string for our new charset...
	 * Store any mappings found in tp[].
	 */
	ct = UCInfo[UC_charset_in_hndl].replacedesc.entry_ct;
	list = UCInfo[UC_charset_in_hndl].replacedesc.entries;
	while (ct--) {
	    if ((k = list->unicode) >= 160 && k < 256) {
		tp[k - 160] = (char *) list->replace_str;
	    }
	    list++;
	}
    }
    /*
     * Now allocate a new table compatible with LYCharSets[]
     * and with the HTMLDTD for entities.
     * We don't know yet whether we'll keep it around.
     */
    prepl = (char **) malloc(HTML_dtd.number_of_entities * sizeof(char *));

    if (!prepl) {
	FREE(tp);
	FREE(ti);
	return 0;
    }

    p = (const char **) prepl;
    changed = 0;
    for (i = 0; i < HTML_dtd.number_of_entities; i++, p++) {
	/*
	 * For each of those entities, we check what the "old method"
	 * ISO_Latin1[] mapping does with them.  If it is nothing we
	 * want to use, just point to the SevenBitApproximations[] string.
	 */
	s7 = SevenBitApproximations[i];
	s8 = ISO_Latin1[i];
	*p = s7;
	if (s8 && UCH(*s8) >= 160 && s8[1] == '\0') {
	    /*
	     * We have an entity that is mapped to
	     * one valid eightbit latin1 char.
	     */
	    if (ti[UCH(*s8) - 160] >= UCH(lowest8) &&
		!(s7[0] == ti[UCH(*s8) - 160] &&
		  s7[1] == '\0')) {
		/*
		 * ...which in turn is mapped, by our "new method",
		 * to another valid eightbit char for this new
		 * charset:  either to itself...
		 */
		if (ti[UCH(*s8) - 160] == UCH(*s8)) {
		    *p = s8;
		} else {
		    /*
		     * make those 1-char strings
		     * into HTAtoms, so they will be cleaned up
		     * at exit...  all for the sake of preventing
		     * memory leaks, sigh.
		     */
		    static char dummy[2];	/* one char dummy string */

		    dummy[0] = ti[UCH(*s8) - 160];
		    *p = HTAtom_name(HTAtom_for(dummy));
		}
		changed = 1;
	    } else if (tp[UCH(*s8) - 160] &&
		       strcmp(s7, tp[UCH(*s8) - 160])) {
		/*
		 * ...or which is mapped, by our "new method",
		 * to a replacement string for this new charset.
		 */
		*p = tp[UCH(*s8) - 160];
		changed = 1;
	    }
	}
    }
    FREE(tp);
    FREE(ti);
    if (!changed) {
	FREE(prepl);
	return NULL;
    }
    return (const char **) prepl;
}

/*
 * "New method" meets "Old method" ...
 */
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit)
{
    int i, LYhndl, found;
    const char **repl;

    LYhndl = -1;
    if (LYNumCharsets == 0) {
	/*
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
	 */
	for (i = 0; (i < MAXCHARSETS) && LYchar_set_names[i]; i++) {
	    LYNumCharsets = i + 1;
	}
    }

    /*
     * Search by MIME name, (LYchar_set_names may differ...)
     */
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    LYhndl = i;
	}
    }

    if (LYhndl < 0) {		/* not found */
	found = 0;
	if (LYNumCharsets >= MAXCHARSETS) {
	    CTRACE((tfp,
		    "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		    UC_MIMEcharset, UC_LYNXcharset));
	    return -1;
	}
	/*
	 * Add to LYCharSets.c lists.
	 */
	LYhndl = LYNumCharsets;
	LYNumCharsets++;
	LYlowest_eightbit[LYhndl] = 999;
	LYCharSets[LYhndl] = SevenBitApproximations;
	/*
	 * Hmm, try to be conservative here.
	 */
	LYchar_set_names[LYhndl] = UC_LYNXcharset;
	LYchar_set_names[LYhndl + 1] = NULL;
	/*
	 * Terminating NULL may be looked for by Lynx code.
	 */
    } else {
	found = 1;
    }
    LYCharSet_UC[LYhndl].UChndl = s;
    /*
     * Can we just copy the pointer?  Hope so...
     */
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UCInfo[s].enc;
    LYCharSet_UC[LYhndl].codepage = UCInfo[s].codepage;

    /*
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
     */
    if (lowest_eightbit < LYlowest_eightbit[LYhndl]) {
	LYlowest_eightbit[LYhndl] = lowest_eightbit;
    } else if (lowest_eightbit > LYlowest_eightbit[LYhndl]) {
	UCInfo[s].lowest_eight = LYlowest_eightbit[LYhndl];
    }

    if (!found && LYhndl > 0) {
	repl = UC_setup_LYCharSets_repl(s, UCInfo[s].lowest_eight);
	if (repl) {
	    LYCharSets[LYhndl] = repl;
	    /*
	     * Remember to FREE at exit.
	     */
	    remember_allocated_LYCharSets[LYhndl] = repl;
	}
    }
    return LYhndl;
}

/*
 * This only sets up the structure - no initialization of the tables
 * is done here yet.
 */
void UC_Charset_Setup(const char *UC_MIMEcharset,
		      const char *UC_LYNXcharset,
		      const u8 * unicount,
		      const u16 * unitable,
		      int nnuni,
		      struct unimapdesc_str replacedesc,
		      int lowest_eight,
		      int UC_rawuni,
		      int codepage)
{
    int s, Gn;
    int i, status = 0, found;

    /*
     * Get (new?) slot.
     */
    found = -1;
    for (i = 0; i < UCNumCharsets && found < 0; i++) {
	if (!strcmp(UCInfo[i].MIMEname, UC_MIMEcharset)) {
	    found = i;
	}
    }
    if (found >= 0) {
	s = found;
    } else {
	if (UCNumCharsets >= MAXCHARSETS) {
	    CTRACE((tfp, "UC_Charset_Setup: Too many.  Ignoring %s/%s.",
		    UC_MIMEcharset, UC_LYNXcharset));
	    return;
	}
	s = UCNumCharsets;
	UCInfo[s].MIMEname = UC_MIMEcharset;
    }
    UCInfo[s].LYNXname = UC_LYNXcharset;
    UCInfo[s].unicount = unicount;
    UCInfo[s].unitable = unitable;
    UCInfo[s].num_uni = nnuni;
    UCInfo[s].replacedesc = replacedesc;
    if (replacedesc.isdefault) {
	default_UChndl = s;
    }
    Gn = UC_FindGN_byMIME(UC_MIMEcharset);
    if (Gn >= 0)
	UC_GNhandles[Gn] = s;
    UCInfo[s].GN = Gn;
    if (UC_rawuni == UCT_ENC_UTF8)
	lowest_eight = 128;	/* cheat here */
    UCInfo[s].lowest_eight = lowest_eight;
    UCInfo[s].enc = UC_rawuni;
    UCInfo[s].codepage = codepage;
    UCInfo[s].LYhndl = UC_Register_with_LYCharSets(s,
						   UC_MIMEcharset,
						   UC_LYNXcharset,
						   lowest_eight);
    UCInfo[s].uc_status = status;
    if (found < 0)
	UCNumCharsets++;
    return;
}

/*
 * UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 * Alternative functions for adding character set info to the lists
 * kept in LYCharSets.c.
 *
 * These are for character sets without any real tables of their own.
 * We don't keep an entry in UCinfo[] for them.
 */
static int UC_NoUctb_Register_with_LYCharSets(const char *UC_MIMEcharset,
					      const char *UC_LYNXcharset,
					      int lowest_eightbit,
					      int UC_rawuni,
					      int codepage)
{
    int i, LYhndl = -1;

    if (LYNumCharsets == 0) {
	/*
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
	 */
	for (i = 0; (i < MAXCHARSETS) && LYchar_set_names[i]; i++) {
	    LYNumCharsets = i + 1;
	}
    }

    /*
     * Search by MIME name, (LYchar_set_names may differ...)
     * ignore if already present!
     */
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    return -1;
	}
    }

    /* not found */
    if (LYNumCharsets >= MAXCHARSETS) {
	CTRACE((tfp,
		"UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		UC_MIMEcharset, UC_LYNXcharset));
	return -1;
    }
    /*
     * Add to LYCharSets.c lists.
     */
    LYhndl = LYNumCharsets;
    LYNumCharsets++;
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
    LYCharSets[LYhndl] = SevenBitApproximations;
    LYchar_set_names[LYhndl] = UC_LYNXcharset;
    LYchar_set_names[LYhndl + 1] = NULL;
    /*
     * Terminating NULL may be looked for by Lynx code.
     */

    LYCharSet_UC[LYhndl].UChndl = -1;	/* no corresponding UChndl ! */
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UC_rawuni;
    LYCharSet_UC[LYhndl].codepage = codepage;

    /*
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
     */

    return LYhndl;
}

/*
 * A wrapper for the previous function.
 */
static void UC_Charset_NoUctb_Setup(const char *UC_MIMEcharset,
				    const char *UC_LYNXcharset,
				    int trydefault,
				    int lowest_eight,
				    int UC_rawuni,
				    int codepage)
{
    int i;

    /*
     * Ignore completely if already in slot.
     */
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].MIMEname, UC_MIMEcharset)) {
	    return;
	}
    }
    if (UC_rawuni == UCT_ENC_UTF8)
	lowest_eight = 128;	/* cheat here */
    /* 'codepage' doubles as a flag for 'do not try any table
     * lookup, not even default' when negative.  The value will
     * be returned immediately by UCTrans* functions.
     */
    if (!trydefault && codepage == 0)
	codepage = -12;		/* if not already set; any negative should do. */
    UC_NoUctb_Register_with_LYCharSets(UC_MIMEcharset,
				       UC_LYNXcharset,
				       lowest_eight,
				       UC_rawuni,
				       codepage);
    return;
}

#ifdef LY_FIND_LEAKS
static void UCcleanup_mem(void)
{
    int i;

    UCfree_allocated_LYCharSets();
    con_clear_unimap_str(0);
    con_clear_unimap_str(1);
    con_clear_unimap(0);
    con_clear_unimap(1);
    for (i = 1; i < 4; i++) {	/* first one is static! */
	FREE(inverse_translations[i]);
    }
}
#endif /* LY_FIND_LEAKS */

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
static int CpOrdinal(const unsigned long cp, const int other)
{
    char lyName[80];
    char myMimeName[80];
    char *mimeName, *mName = NULL, *lName = NULL;
    int s, i, exists = 0, ret;

    CTRACE((tfp, "CpOrdinal(cp=%ul, other=%d).\n", cp, other));
    sprintf(myMimeName, "auto%s-cp%lu", (other ? "2" : ""), cp);
    mimeName = myMimeName + 5 + (other != 0);
    sprintf(lyName, "AutoDetect%s (cp%lu)",
	    (other ? "-2" : ""), cp);
    /* Find slot. */
    s = -1;
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].LYNXname, lyName))
	    return UCGetLYhndl_byMIME(myMimeName);
	else if (!strcasecomp(UCInfo[i].MIMEname, mimeName))
	    s = i;
    }
    if (s < 0)
	return -1;
    /* Store the "real" charset info */
    real_charsets[other != 0] = UCGetLYhndl_byMIME(mimeName);
    /* Duplicate the record. */
    StrAllocCopy(mName, myMimeName);
    StrAllocCopy(lName, lyName);
    UC_Charset_Setup(mName, lName,
		     UCInfo[s].unicount, UCInfo[s].unitable,
		     UCInfo[s].num_uni, UCInfo[s].replacedesc,
		     UCInfo[s].lowest_eight, UCInfo[s].enc,
		     UCInfo[s].codepage);
    ret = UCGetLYhndl_byMIME(myMimeName);
    CTRACE((tfp, "Found %i.\n", ret));
    return ret;
}
#  endif			/* __EMX__ */
#endif /* CAN_AUTODETECT_DISPLAY_CHARSET */

void UCInit(void)
{

    UCreset_allocated_LYCharSets();
#ifdef LY_FIND_LEAKS
    atexit(UCcleanup_mem);
#endif
    UCconsole_map_init();

    /*
     * The order of charset names visible in Lynx Options menu correspond to
     * the order of lines below, except the first two described in LYCharSet.c
     *
     * Entries whose comment is marked with *** are declared in UCdomap.h,
     * others are based on the included tables - UCdomap.c, near the top.
     */

    UC_CHARSET_SETUP_iso_8859_1;	/* ISO Latin 1          */
    UC_CHARSET_SETUP_iso_8859_15;	/* ISO 8859-15 (Latin 9) */
    UC_CHARSET_SETUP_cp850;	/* DosLatin1 (cp850)    */
    UC_CHARSET_SETUP_windows_1252;	/* WinLatin1 (cp1252)   */
    UC_CHARSET_SETUP_cp437;	/* DosLatinUS (cp437)   */

    UC_CHARSET_SETUP_dec_mcs;	/* DEC Multinational    */
    UC_CHARSET_SETUP_macintosh;	/* Macintosh (8 bit)    */
    UC_CHARSET_SETUP_next;	/* NeXT character set   */
    UC_CHARSET_SETUP_hp_roman8;	/* HP Roman8            */

    UC_CHARSET_SETUP_euc_cn;		  /*** Chinese		    */
    UC_CHARSET_SETUP_euc_jp;		  /*** Japanese (EUC_JP)    */
    UC_CHARSET_SETUP_shift_jis;		  /*** Japanese (Shift_JIS) */
    UC_CHARSET_SETUP_euc_kr;		  /*** Korean		    */
    UC_CHARSET_SETUP_big5;		  /*** Taipei (Big5)	    */

    UC_CHARSET_SETUP_viscii;	/* Vietnamese (VISCII)  */
    UC_CHARSET_SETUP;		/* us-ascii *//* 7 bit approximations */

    UC_CHARSET_SETUP_x_transparent;	  /*** Transparent	  */

    UC_CHARSET_SETUP_iso_8859_2;	/* ISO Latin 2          */
    UC_CHARSET_SETUP_cp852;	/* DosLatin2 (cp852)    */
    UC_CHARSET_SETUP_windows_1250;	/* WinLatin2 (cp1250)   */
    UC_CHARSET_SETUP_iso_8859_3;	/* ISO Latin 3          */
    UC_CHARSET_SETUP_iso_8859_4;	/* ISO Latin 4          */
    UC_CHARSET_SETUP_cp775;	/* DosBaltRim (cp775)   */
    UC_CHARSET_SETUP_windows_1257;	/* WinBaltRim (cp1257)  */
    UC_CHARSET_SETUP_iso_8859_5;	/* ISO 8859-5 Cyrillic  */
    UC_CHARSET_SETUP_cp866;	/* DosCyrillic (cp866)  */
    UC_CHARSET_SETUP_windows_1251;	/* WinCyrillic (cp1251) */
    UC_CHARSET_SETUP_koi8_r;	/* KOI8-R Cyrillic      */
    UC_CHARSET_SETUP_iso_8859_6;	/* ISO 8869-6 Arabic    */
    UC_CHARSET_SETUP_cp864;	/* DosArabic (cp864)    */
    UC_CHARSET_SETUP_windows_1256;	/* WinArabic (cp1256)   */
    UC_CHARSET_SETUP_iso_8859_7;	/* ISO 8859-7 Greek     */
    UC_CHARSET_SETUP_cp737;	/* DosGreek (cp737)     */
    UC_CHARSET_SETUP_cp869;	/* DosGreek2 (cp869)    */
    UC_CHARSET_SETUP_windows_1253;	/* WinGreek (cp1253)    */
    UC_CHARSET_SETUP_iso_8859_8;	/* ISO 8859-8 Hebrew    */
    UC_CHARSET_SETUP_cp862;	/* DosHebrew (cp862)    */
    UC_CHARSET_SETUP_windows_1255;	/* WinHebrew (cp1255)   */
    UC_CHARSET_SETUP_iso_8859_9;	/* ISO 8859-9 (Latin 5) */
    UC_CHARSET_SETUP_iso_8859_10;	/* ISO 8859-10          */

    UC_CHARSET_SETUP_utf_8;		  /*** UNICODE UTF-8	  */
    UC_CHARSET_SETUP_mnemonic_ascii_0;	/* RFC 1345 w/o Intro   */
    UC_CHARSET_SETUP_mnemonic;	/* RFC 1345 Mnemonic    */
    UC_CHARSET_SETUP_cp866u;	/* Ukrainian Cyrillic (866) */
    UC_CHARSET_SETUP_koi8_u;	/* Ukrainian Cyrillic (koi8-u) */
    UC_CHARSET_SETUP_ptcp154;	/* Cyrillic-Asian (PT154) */

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
    {
	unsigned long lst[3];
	unsigned long len, rc;

	rc = DosQueryCp(sizeof(lst), lst, &len);
	if (rc == 0) {
	    if (len >= 1)
		auto_display_charset = CpOrdinal(lst[0], 0);
#    ifdef CAN_SWITCH_DISPLAY_CHARSET
	    if (len >= 3) {
		codepages[0] = lst[0];
		codepages[1] = (lst[0] == lst[1] ? lst[2] : lst[1]);
		auto_other_display_charset = CpOrdinal(codepages[1], 1);
	    }
#    endif
	} else {
	    CTRACE((tfp, "DosQueryCp() returned %#lx=%lu.\n", rc, rc));
	}
    }
#  endif
#endif

/*
 * To add synonyms for any charset name check function UCGetLYhndl_byMIME in
 * this file.
 */

/* for coding/performance - easy to type: */
    LATIN1 = UCGetLYhndl_byMIME("iso-8859-1");
    US_ASCII = UCGetLYhndl_byMIME("us-ascii");
    UTF8_handle = UCGetLYhndl_byMIME("utf-8");
    TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
}

/*
 * Safe variant of UCGetLYhndl_byMIME, with blind recovery from typo in user
 * input:  lynx.cfg, userdefs.h, command line switches.
 */
int safeUCGetLYhndl_byMIME(const char *value)
{
    int i = UCGetLYhndl_byMIME(value);

    if (i == -1) {		/* was user's typo or not yet recognized value */
	i = LATIN1;		/* error recovery? */
	CTRACE((tfp, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n"));
    }

    return (i);
}

#ifdef EXP_LOCALE_CHARSET

#if defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET)
/*
 * This is a quick-and-dirty emulator of the nl_langinfo(CODESET)
 * function defined in the Single Unix Specification for those systems
 * (FreeBSD, etc.) that don't have one yet. It behaves as if it had
 * been called after setlocale(LC_CTYPE, ""), that is it looks at
 * the locale environment variables.
 *
 * http://www.opengroup.org/onlinepubs/7908799/xsh/langinfo.h.html
 *
 * Please extend it as needed and suggest improvements to the author.
 * This emulator will hopefully become redundant soon as
 * nl_langinfo(CODESET) becomes more widely implemented.
 *
 * Since the proposed Li18nux encoding name registry is still not mature,
 * the output follows the MIME registry where possible:
 *
 *   http://www.iana.org/assignments/character-sets
 *
 * A possible autoconf test for the availability of nl_langinfo(CODESET)
 * can be found in
 *
 *   http://www.cl.cam.ac.uk/~mgk25/unicode.html#activate
 *
 * Markus.Kuhn@@cl.cam.ac.uk -- 2002-03-11
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 *
 * Latest version:
 *
 *   http://www.cl.cam.ac.uk/~mgk25/ucs/langinfo.c
 */

/*
#include "langinfo.h"
*/
typedef int nl_item;

#define CODESET 1

#define C_CODESET "US-ASCII"	/* Return this as the encoding of the
				 * C/POSIX locale. Could as well one day
				 * become "UTF-8". */

#define digit(x) ((x) >= '0' && (x) <= '9')

static char buf[16];

static char *nl_langinfo(nl_item item)
{
    char *l, *p;

    if (item != CODESET)
	return NULL;

    if (((l = getenv("LC_ALL")) && *l) ||
	((l = getenv("LC_CTYPE")) && *l) ||
	((l = getenv("LANG")) && *l)) {
	/* check standardized locales */
	if (!strcmp(l, "C") || !strcmp(l, "POSIX"))
	    return C_CODESET;
	/* check for encoding name fragment */
	if (strstr(l, "UTF") || strstr(l, "utf"))
	    return "UTF-8";
	if ((p = strstr(l, "8859-"))) {
	    memcpy(buf, "ISO-8859-\0\0", 12);
	    p += 5;
	    if (digit(*p)) {
		buf[9] = *p++;
		if (digit(*p))
		    buf[10] = *p++;
		return buf;
	    }
	}
	if (strstr(l, "KOI8-R"))
	    return "KOI8-R";
	if (strstr(l, "KOI8-U"))
	    return "KOI8-U";
	if (strstr(l, "620"))
	    return "TIS-620";
	if (strstr(l, "2312"))
	    return "GB2312";
	if (strstr(l, "HKSCS"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "Big5") || strstr(l, "BIG5"))
	    return "Big5";
	if (strstr(l, "GBK"))
	    return "GBK";	/* no MIME charset */
	if (strstr(l, "18030"))
	    return "GB18030";	/* no MIME charset */
	if (strstr(l, "Shift_JIS") || strstr(l, "SJIS"))
	    return "Shift_JIS";
	/* check for conclusive modifier */
	if (strstr(l, "euro"))
	    return "ISO-8859-15";
	/* check for language (and perhaps country) codes */
	if (strstr(l, "zh_TW"))
	    return "Big5";
	if (strstr(l, "zh_HK"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "zh"))
	    return "GB2312";
	if (strstr(l, "ja"))
	    return "EUC-JP";
	if (strstr(l, "ko"))
	    return "EUC-KR";
	if (strstr(l, "ru"))
	    return "KOI8-R";
	if (strstr(l, "uk"))
	    return "KOI8-U";
	if (strstr(l, "pl") || strstr(l, "hr") ||
	    strstr(l, "hu") || strstr(l, "cs") ||
	    strstr(l, "sk") || strstr(l, "sl"))
	    return "ISO-8859-2";
	if (strstr(l, "eo") || strstr(l, "mt"))
	    return "ISO-8859-3";
	if (strstr(l, "el"))
	    return "ISO-8859-7";
	if (strstr(l, "he"))
	    return "ISO-8859-8";
	if (strstr(l, "tr"))
	    return "ISO-8859-9";
	if (strstr(l, "th"))
	    return "TIS-620";	/* or ISO-8859-11 */
	if (strstr(l, "lt"))
	    return "ISO-8859-13";
	if (strstr(l, "cy"))
	    return "ISO-8859-14";
	if (strstr(l, "ro"))
	    return "ISO-8859-2";	/* or ISO-8859-16 */
	if (strstr(l, "am") || strstr(l, "vi"))
	    return "UTF-8";
	/* Send me further rules if you like, but don't forget that we are
	 * *only* interested in locale naming conventions on platforms
	 * that do not already provide an nl_langinfo(CODESET) implementation. */
	return "ISO-8859-1";	/* should perhaps be "UTF-8" instead */
    }
    return C_CODESET;
}
#endif /* defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET) */

/*
 * If LYLocaleCharset is true, use the current locale to lookup a MIME name
 * that corresponds, and use that as the display charset.  This feature is
 * experimental because while nl_langinfo(CODESET) itself is standardized,
 * the return values and their relationship to the locale value is not.
 * GNU libiconv happens to give useful values, but other implementations are
 * not guaranteed to do this.
 *
 * Not all Linux versions provide useful information.  GNU libc 2.2 returns
 *	"ANSI_X3.4-1968"
 * whether locale is POSIX or en_US.UTF-8.
 *
 * Another possible thing to investigate is the locale_charset() function
 * provided in libiconv 1.5.1.
 */
void LYFindLocaleCharset(void)
{
    CTRACE((tfp, "LYFindLocaleCharset(%d)\n", LYLocaleCharset));
    if (LYLocaleCharset) {
	char *name = nl_langinfo(CODESET);

	if (name != 0) {
	    int value = UCGetLYhndl_byMIME(name);

	    if (value >= 0) {
		current_char_set = value;
	    } else {
		CTRACE((tfp, "Cannot find a handle for MIME name \"%s\"\n", name));
		LYLocaleCharset = FALSE;
	    }
	} else {
	    CTRACE((tfp, "Cannot find a MIME name for locale\n"));
	    LYLocaleCharset = FALSE;
	}
    }
}
#endif /* EXP_LOCALE_CHARSET */
@


1.4
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d28 8
d39 1
a39 1
 *  Include chartrans tables:
d41 1
a41 1
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)	*/
d43 14
a56 14
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)	*/
#include <cp1253_uni.h>		/* WinGreek (cp1253)	*/
#include <cp1255_uni.h>		/* WinHebrew (cp1255)	*/
#include <cp1256_uni.h>		/* WinArabic (cp1256)	*/
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)	*/
#include <cp437_uni.h>		/* DosLatinUS (cp437)	*/
#include <cp737_uni.h>		/* DosGreek (cp737)	*/
#include <cp775_uni.h>		/* DosBaltRim (cp775)	*/
#include <cp850_uni.h>		/* DosLatin1 (cp850)	*/
#include <cp852_uni.h>		/* DosLatin2 (cp852)	*/
#include <cp862_uni.h>		/* DosHebrew (cp862)	*/
#include <cp864_uni.h>		/* DosArabic (cp864)	*/
#include <cp866_uni.h>		/* DosCyrillic (cp866)	*/
#include <cp869_uni.h>		/* DosGreek2 (cp869)	*/
d58 10
a67 10
#include <dmcs_uni.h>		/* DEC Multinational	*/
#include <hp_uni.h>		/* HP Roman8		*/
#include <iso01_uni.h>		/* ISO Latin 1		*/
#include <iso02_uni.h>		/* ISO Latin 2		*/
#include <iso03_uni.h>		/* ISO Latin 3		*/
#include <iso04_uni.h>		/* ISO Latin 4		*/
#include <iso05_uni.h>		/* ISO 8859-5 Cyrillic	*/
#include <iso06_uni.h>		/* ISO 8859-6 Arabic	*/
#include <iso07_uni.h>		/* ISO 8859-7 Greek	*/
#include <iso08_uni.h>		/* ISO 8859-8 Hebrew	*/
d69 9
a77 9
#include <iso10_uni.h>		/* ISO 8859-10		*/
#include <iso15_uni.h>		/* ISO 8859-15 (Latin 9)*/
#include <koi8r_uni.h>		/* KOI8-R Cyrillic	*/
#include <mac_uni.h>		/* Macintosh (8 bit)	*/
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic	*/
#include <next_uni.h>		/* NeXT character set	*/
#include <rfc_suni.h>		/* RFC 1345 w/o Intro	*/
/* #include <utf8_uni.h> */     /* UNICODE UTF 8        */
#include <viscii_uni.h>		/* Vietnamese (VISCII)	*/
d86 2
a87 2
CONST char *UC_GNsetMIMEnames[4] =
	{"iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"};
d89 2
a90 1
int UC_GNhandles[4] = {-1, -1, -1, -1};
d93 158
a250 157
 *  Some of the code below, and some of the comments, are left in for
 *  historical reasons.  Not all those tables below are currently
 *  really needed (and what with all those hardwired codepoints),
 *  but let's keep them around for now.  They may come in handy if we
 *  decide to make more extended use of the mechanisms (including e.g.
 *  for chars < 127...).  - KW
 */

PRIVATE u16 translations[][256] = {
  /*
   *  8-bit Latin-1 mapped to Unicode -- trivial mapping.
   */
  {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
  },
  /*
   *  VT100 graphics mapped to Unicode.
   */
  {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,
    0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
    0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0xf800,
    0xf801, 0x2500, 0xf803, 0xf804, 0x251c, 0x2524, 0x2534, 0x252c,
    0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
  },
  /*
   *  IBM Codepage 437 mapped to Unicode.
   */
  {
    0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
    0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
    0x25ba, 0x25c4, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
    0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
    0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
    0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
    0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
    0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
    0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
    0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
    0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
    0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
    0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
    0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
    0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
    0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
    0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
    0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
    0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
  },
  /*
   *  User mapping -- default to codes for direct font mapping.
   */
  {
    0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,
    0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,
    0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,
    0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,
    0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,
    0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,
    0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,
    0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,
    0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,
    0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,
    0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,
    0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,
    0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,
    0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,
    0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,
    0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,
    0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,
    0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,
    0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,
    0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,
    0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,
    0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,
    0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,
    0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,
    0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,
    0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,
    0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,
    0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,
    0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,
    0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,
    0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,
    0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff
  }
d252 1
a252 1
PRIVATE u16 *UC_translate = NULL;
d254 1
a254 1
PRIVATE struct UC_charset UCInfo[MAXCHARSETS];
d257 2
a258 2
 *  The standard kernel character-to-font mappings are not invertible
 *  -- this is just a best effort.
d262 28
a289 57
PRIVATE unsigned char * inv_translate = NULL;
PRIVATE unsigned char inv_norm_transl[MAX_GLYPH];
PRIVATE unsigned char * inverse_translations[4] = { NULL, NULL, NULL, NULL };

PRIVATE void set_inverse_transl PARAMS((
	int		i));
PRIVATE u16 *set_translate PARAMS((
	int		m));
PRIVATE int UC_valid_UC_charset PARAMS((
	int		UC_charset_hndl));
PRIVATE void UC_con_set_trans PARAMS((
	int		UC_charset_in_hndl,
	int		Gn,
	int		update_flag));
PRIVATE int con_insert_unipair PARAMS((
	u16		unicode,
	u16		fontpos,
	int		fordefault));
PRIVATE int con_insert_unipair_str PARAMS((
	u16		unicode,
	CONST char *	replace_str,
	int		fordefault));
PRIVATE void con_clear_unimap PARAMS((
	int		fordefault));
PRIVATE void con_clear_unimap_str PARAMS((
	int		fordefault));
PRIVATE void con_set_default_unimap NOPARAMS;
PRIVATE int UC_con_set_unimap PARAMS((
	int		UC_charset_out_hndl,
	int		update_flag));
PRIVATE int UC_con_set_unimap_str PARAMS((
	u16			ct,
	struct unipair_str *	list,
	int			fordefault));
PRIVATE int conv_uni_to_pc PARAMS((
	long			ucs,
	int			usedefault));
PRIVATE int conv_uni_to_str PARAMS((
	char*		outbuf,
	int		buflen,
	long		ucs,
	int		usedefault));
PRIVATE void UCconsole_map_init NOPARAMS;
PRIVATE int UC_MapGN PARAMS((
	int		UChndl,
	int		update_flag));
PRIVATE int UC_FindGN_byMIME PARAMS((
	CONST char *	UC_MIMEcharset));
PRIVATE void UCreset_allocated_LYCharSets NOPARAMS;
PRIVATE CONST char ** UC_setup_LYCharSets_repl PARAMS((
	int		UC_charset_in_hndl,
	unsigned	lowest8));
PRIVATE int UC_Register_with_LYCharSets PARAMS((
	int		s,
	CONST char *	UC_MIMEcharset,
	CONST char *	UC_LYNXcharset,
	int		lowest_eightbit));
d291 2
a292 2
PRIVATE void UCfree_allocated_LYCharSets NOPARAMS;
PRIVATE void UCcleanup_mem NOPARAMS;
d295 1
a295 1
PRIVATE int default_UChndl = -1;
d297 1
a297 2
PRIVATE void set_inverse_transl ARGS1(
	int,		i)
d305 1
a305 1
	 *  Slightly messy to avoid calling kmalloc too early.
d309 1
a309 1
				       (unsigned char *)malloc(MAX_GLYPH));
d320 1
a320 1
	     *	Prefer '-' above SHY etc.
d327 1
a327 2
PRIVATE u16 *set_translate ARGS1(
	int,		m)
d329 4
a332 4
	if (!inverse_translations[m])
		set_inverse_transl(m);
	inv_translate = inverse_translations[m];
	return translations[m];
d335 1
a335 2
PRIVATE int UC_valid_UC_charset ARGS1(
	int,		UC_charset_hndl)
d337 1
a337 1
  return (UC_charset_hndl >= 0 && UC_charset_hndl < UCNumCharsets);
d340 3
a342 4
PRIVATE void UC_con_set_trans ARGS3(
	int,		UC_charset_in_hndl,
	int,		Gn,
	int,		update_flag)
d345 1
a345 1
    CONST u16 *p;
d350 1
a350 1
		    UC_charset_in_hndl));
d356 1
a356 1
    if (p == UC_current_unitable) {    /* test whether pointers are equal */
d360 1
a360 1
     *	The font is always 256 characters - so far.
d375 1
a375 1
	set_inverse_transl(Gn); /* Update inverse translation for this one */
d388 2
a389 2
PRIVATE int hashtable_contents_valid = 0; /* Use ASCII-only mode for bootup*/
PRIVATE int hashtable_str_contents_valid = 0;
d391 1
a391 1
PRIVATE u16 **uni_pagedir[32] =
d393 4
a396 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d399 1
a399 1
PRIVATE char* **uni_pagedir_str[32] =
d401 4
a404 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d407 2
a408 2
PRIVATE CONST u16 * UC_current_unitable = NULL;
PRIVATE struct unimapdesc_str *UC_current_unitable_str = NULL;
d411 2
a412 2
 *  Keep a second set of structures for the translation designated
 *  as "default" - kw
d414 2
a415 2
PRIVATE int unidefault_contents_valid = 0; /* Use ASCII-only mode for bootup*/
PRIVATE int unidefault_str_contents_valid = 0;
d419 4
a422 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d424 1
a424 1
static char* **unidefault_pagedir_str[32] =
d426 4
a429 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d432 2
a433 2
PRIVATE CONST u16 * UC_default_unitable = 0;
PRIVATE CONST struct unimapdesc_str *UC_default_unitable_str = 0;
d435 1
a435 4
PRIVATE int con_insert_unipair ARGS3(
	u16,		unicode,
	u16,		fontpos,
	int,		fordefault)
d440 1
a440 1
    if(fordefault)
d445 1
a445 1
	p1 = (u16* *)malloc(32*sizeof(u16 *));
d450 1
a450 1
	if ( !p1 )
d459 1
a459 1
	p2 = p1[n] = (u16 *)malloc(64*sizeof(u16));
d464 1
a464 1
	    p2[i] = 0xffff;		/* No glyph for this character (yet) */
d473 2
a474 4
PRIVATE int con_insert_unipair_str ARGS3(
	u16,		unicode,
	CONST char *,	replace_str,
	int,		fordefault)
d478 1
a478 1
    CONST char **p2;
d480 1
a480 1
    if(fordefault)
d485 2
a486 1
	p1 = (char** *)malloc(32*sizeof(char **));
d491 1
a491 1
	if ( !p1 )
d501 2
a502 1
	p1[n] = (char **)malloc(64*sizeof(char *));
d506 1
a506 1
	p2 = (CONST char **)p1[n];
d511 1
a511 1
    p2 = (CONST char **)p1[n];
d519 1
a519 1
 *  ui arg was a leftover, deleted. - KW
d521 1
a521 2
PRIVATE void con_clear_unimap ARGS1(
	int,		fordefault)
d553 1
a553 1
PRIVATE void con_clear_unimap_str ARGS1(int, fordefault)
d555 2
a556 2
  int i, j;
  char ***p1;
d558 7
a564 5
  if (fordefault) {
    for (i = 0; i < 32; i++) {
	if ((p1 = unidefault_pagedir_str[i]) != NULL) {
	    for (j = 0; j < 32; j++) {
		FREE(p1[j]);
d566 1
a566 1
	    FREE(p1);
a567 2
      unidefault_pagedir_str[i] = NULL;
    }
d569 8
a576 6
    unidefault_str_contents_valid = 1;	/* ??? probably no use... */
  } else {
    for (i = 0; i < 32; i++) {
	if ((p1 = uni_pagedir_str[i]) != NULL) {
	    for (j = 0; j < 32; j++) {
		FREE(p1[j]);
d578 1
a578 1
	    FREE(p1);
d580 2
a581 1
      uni_pagedir_str[i] = NULL;
a582 3

    hashtable_str_contents_valid = 1;  /* ??? probably no use... */
  }
d586 4
a589 4
 *  Loads the unimap for the hardware font, as defined in uni_hash.tbl.
 *  The representation used was the most compact I could come up
 *  with.  This routine is executed at sys_setup time, and when the
 *  PIO_FONTRESET ioctl is called.
d591 1
a591 1
PRIVATE void con_set_default_unimap NOARGS
d594 1
a594 1
    CONST u16 *p;
d597 1
a597 1
     *	The default font is always 256 characters.
d604 1
a604 1
	    con_insert_unipair(*(p++), (u16)i, 1);
d615 12
a626 1
PUBLIC int UCNumCharsets = 0;
d628 2
a629 15
PUBLIC int UCLYhndl_HTFile_for_unspec = -1;
PUBLIC int UCLYhndl_HTFile_for_unrec = -1;
PUBLIC int UCLYhndl_for_unspec = -1;
PUBLIC int UCLYhndl_for_unrec = -1;

 /* easy to type, will initialize later */
PUBLIC int LATIN1 = -1;        /* UCGetLYhndl_byMIME("iso-8859-1") */
PUBLIC int US_ASCII = -1;      /* UCGetLYhndl_byMIME("us-ascii")   */
PUBLIC int UTF8_handle = -1;   /* UCGetLYhndl_byMIME("utf-8")      */
PUBLIC int TRANSPARENT = -1;   /* UCGetLYhndl_byMIME("x-transparent")  */


PRIVATE int UC_con_set_unimap ARGS2(
	int,		UC_charset_out_hndl,
	int,		update_flag)
d632 1
a632 1
    CONST u16 *p;
d636 1
a636 1
		    UC_charset_out_hndl));
d641 2
a642 2
    if (p == UC_current_unitable) {    /* test whether pointers are equal */
	return update_flag;			/* nothing to be done */
d647 1
a647 1
     *	The font is always 256 characters - so far.
d653 1
a653 1
	    con_insert_unipair(*(p++), (u16)i, 0);
d666 2
a667 4
PRIVATE int UC_con_set_unimap_str ARGS3(
	u16,		ct,
	struct unipair_str *, list,
	int,		fordefault)
d681 1
a681 1
     *	No inverse translations for replacement strings!
d693 2
a694 3
PRIVATE int conv_uni_to_pc ARGS2(
	long,		ucs,
	int,		usedefault)
d700 1
a700 1
     *	Only 16-bit codes supported at this time.
d704 1
a704 1
	 *  U+FFFD: REPLACEMENT CHARACTER.
d709 1
a709 1
	 *  Not a printable character.
d714 1
a714 1
	 *  Zero-width space.
d719 4
a722 4
	 *  UNI_DIRECT_BASE indicates the start of the region in the
	 *  User Zone which always has a 1:1 mapping to the currently
	 *  loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 *  of the region.
d744 1
a744 1
     *	Not found.
d750 1
a750 1
 *  Note: contents of outbuf is not changes for negative return value!
d752 4
a755 5
PRIVATE int conv_uni_to_str ARGS4(
	char*,		outbuf,
	int,		buflen,
	long,		ucs,
	int,		usedefault)
d761 1
a761 1
     *	Only 16-bit codes supported at this time.
d765 1
a765 1
	 *  U+FFFD: REPLACEMENT CHARACTER.
d768 3
a770 3
    /*
     *	Maybe the following two cases should be allowed here?? - KW
     */
d773 1
a773 1
	 *  Not a printable character.
d778 1
a778 1
	 *  Zero-width space.
d796 2
a797 2
	strncpy (outbuf,h,(size_t) (buflen-1));
	return 1;     /* ok ! */
d801 1
a801 1
     *	Not found.
d806 1
a806 1
PUBLIC int UCInitialized = 0;
d809 1
a809 1
 *  [ original comment: - KW ]
d814 1
a814 1
PRIVATE void UCconsole_map_init NOARGS
d821 1
a821 1
 *  OK now, finally, some stuff that is more specifically for Lynx: - KW
d823 2
a824 3
PUBLIC int UCTransUniChar ARGS2(
	long,		unicode,
	int,		charset_out)
d829 1
a829 1
    CONST u16 * ut;
d833 1
a833 1
	    return (unicode < 128) ? (int)unicode : LYCharSet_UC[charset_out].codepage;
d869 1
a869 1
 *  Returns string length, or negative value for error.
d871 5
a875 6
PUBLIC int UCTransUniCharStr ARGS5(
	char *,		outbuf,
	int,		buflen,
	long,		unicode,
	int,		charset_out,
	int,		chk_single_flag)
d880 2
a881 2
    struct unimapdesc_str * repl;
    CONST u16 * ut;
d909 1
a909 1
	    outbuf[0] = (char)src;
d917 1
a917 1
	if (repl != UC_current_unitable_str)  {
d929 1
a929 1
	    outbuf[0] = (char)src;
d935 29
d982 1
a982 1
	    outbuf[0] = (char)rc;
d991 1
a991 1
PRIVATE int UC_lastautoGN = 0;
d993 2
a994 3
PRIVATE int UC_MapGN ARGS2(
	int,		UChndl,
	int,		update_flag)
d997 1
d1026 2
a1027 2
		Gn, UChndl, UCInfo[UChndl].MIMEname));
    UC_con_set_trans(UChndl,Gn,update_flag);
d1031 3
a1033 4
PUBLIC int UCTransChar ARGS3(
	char,		ch_in,
	int,		charset_in,
	int,		charset_out)
d1039 1
a1039 1
    CONST u16 * ut;
d1063 1
a1063 1
	Gn = UC_MapGN(UChndl_in,0);
d1101 6
a1106 7
PUBLIC long int UCTransToUni ARGS2(
	char,		ch_in,
	int,		charset_in)
{
  int unicode, Gn;
  unsigned char ch_iu;
  int UChndl_in;
d1108 1
a1108 1
  ch_iu = UCH(ch_in);
d1120 1
a1120 1
	 *  Don't translate C0 chars except for specific charsets.
d1128 1
a1128 1
	Gn = UC_MapGN(UChndl_in,1);
d1131 2
a1132 2
  UC_translate = set_translate(Gn);
  unicode = UC_translate[UCH(ch_in)];
d1134 1
a1134 1
  return unicode;
d1137 3
a1139 4
PUBLIC int UCReverseTransChar ARGS3(
	char,		ch_out,
	int,		charset_in,
	int,		charset_out)
d1146 1
a1146 1
    CONST u16 * ut;
d1172 4
a1175 4
	 *  Try to use the inverse table if charset_out is not equivalent
	 *  to using just the default table.  If it is, it should have
	 *  just ASCII chars and trying to back-translate those should
	 *  not give anything but themselves. - kw
d1180 1
a1180 1
		Gn = UC_MapGN(UChndl_in,1);
d1194 1
a1194 1
 *  Returns string length, or negative value for error.
d1196 6
a1201 7
PUBLIC int UCTransCharStr ARGS6(
	char *,		outbuf,
	int,		buflen,
	char,		ch_in,
	int,		charset_in,
	int,		charset_out,
	int,		chk_single_flag)
d1207 2
a1208 2
    struct unimapdesc_str * repl;
    CONST u16 * ut;
d1248 2
a1249 1
		if (upd) set_inverse_transl(Gn);
d1261 1
a1261 1
	    outbuf[0] = (char)src;
d1281 1
a1281 1
	    outbuf[0] = (char)src;
d1305 1
a1305 1
	    outbuf[0] = (char)rc;
d1317 1
a1317 2
PRIVATE int UC_FindGN_byMIME ARGS1(
	CONST char *,	UC_MIMEcharset)
d1319 1
a1319 1
  int i;
d1322 2
a1323 2
	if (!strcmp(UC_MIMEcharset,UC_GNsetMIMEnames[i])) {
      return i;
d1326 1
a1326 1
  return -1;
d1329 1
a1329 2
PUBLIC int UCGetRawUniMode_byLYhndl ARGS1(
	int,		i)
d1333 1
a1333 1
  return LYCharSet_UC[i].enc;
d1341 2
a1342 3
PRIVATE int getLYhndl_byCP ARGS2(
	CONST char *,	prefix,
	CONST char *,	codepage)
d1349 1
d1360 3
a1362 3
 *  Get Lynx internal charset handler from MIME name,
 *  return -1 if we got NULL or did not recognize value.
 *  According to RFC, MIME headers should match case-insensitively.
d1364 1
a1364 2
PUBLIC int UCGetLYhndl_byMIME ARGS1(
	CONST char *,	value)
d1370 2
a1371 1
	CTRACE((tfp, "UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
d1379 1
a1379 1
	   !strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
d1470 1
a1470 1
	if ((LYhndl = getLYhndl_byCP("cp", value+3)) >= 0)
d1487 2
a1488 2
    if (!strcasecomp(value, "koi-8")) { /* accentsoft bugosity */
      return UCGetLYhndl_byMIME("koi8-r");
d1494 1
a1494 1
    return -1;	/* returns -1 if no charset found by that MIME name */
d1498 4
a1501 4
 *  Function UC_setup_LYCharSets_repl() tries to set up a subtable in
 *  LYCharSets[] appropriate for this new charset, for compatibility
 *  with the "old method".  Maybe not nice (maybe not even necessary
 *  any more), but it works (as far as it goes..).
d1503 8
a1510 9
 *  We try to be conservative and only allocate new memory for this
 *  if needed.	If not needed, just point to SevenBitApproximations[i].
 *  [Could do the same for ISO_Latin1[] if it's identical to that, but
 *   would make it even *more* messy than it already is...]
 *  This the only function in this file that knows, or cares, about the
 *  HTMLDTD or details of LYCharSets[] subtables (and therefore somewhat
 *  violates the idea that this file should be independent of those).
 *  As in other places, we rely on ISO_Latin1 being the *first* table
 *  in LYCharSets. - KW
d1514 1
a1514 1
 *  We need to remember which ones were allocated and which are static.
d1516 1
a1516 1
PRIVATE CONST char ** remember_allocated_LYCharSets[MAXCHARSETS];
d1518 1
a1518 1
PRIVATE void UCreset_allocated_LYCharSets NOARGS
d1528 1
a1528 1
PRIVATE void UCfree_allocated_LYCharSets NOARGS
d1540 2
a1541 3
PRIVATE CONST char ** UC_setup_LYCharSets_repl ARGS2(
	int,		UC_charset_in_hndl,
	unsigned,	lowest8)
d1543 2
a1544 2
    CONST char **ISO_Latin1 = LYCharSets[0];
    CONST char **p;
d1546 1
a1546 1
    CONST u16 *pp;
d1548 2
a1549 2
    CONST char *s7;
    CONST char *s8;
d1556 1
a1556 1
     *	Create a temporary table for reverse lookup of latin1 codes:
d1558 2
a1559 1
    tp = (char **)malloc(96 * sizeof(char *));
d1564 1
a1564 1
    ti = (u8 *)malloc(96 * sizeof(u8));
d1575 3
a1577 3
     *	Determine if we have any mapping of a Unicode in the range 160-255
     *	to an allowed code point > 0x80 in our new charset...
     *	Store any mappings found in ti[].
d1583 1
a1583 1
		   ti[k-160] = UCH(i);
d1590 1
a1590 2
    }
    {
d1595 3
a1597 3
	 *  Determine if we have any mapping of a Unicode in the range
	 *  160-255 to a replacement string for our new charset...
	 *  Store any mappings found in tp[].
d1603 1
a1603 1
		tp[k-160] = (char *)list->replace_str;
d1609 6
a1614 4
     *	Now allocate a new table compatible with LYCharSets[]
     *	and with the HTMLDTD for entities.
     *	We don't know yet whether we'll keep it around. */
    prepl = (char **)malloc(HTML_dtd.number_of_entities * sizeof(char *));
d1621 1
a1621 1
    p = (CONST char **)prepl;
d1625 3
a1627 3
	 *  For each of those entities, we check what the "old method"
	 *  ISO_Latin1[] mapping does with them.  If it is nothing we
	 *  want to use, just point to the SevenBitApproximations[] string.
d1634 2
a1635 2
	     *	We have an entity that is mapped to
	     *	one valid eightbit latin1 char.
d1639 1
a1639 1
		s7[1] == '\0')) {
d1641 3
a1643 3
		 *  ...which in turn is mapped, by our "new method",
		 *   to another valid eightbit char for this new
		 *   charset: either to itself...
d1649 4
a1652 4
		     *	make those 1-char strings
		     *	into HTAtoms, so they will be cleaned up
		     *	at exit... all for the sake of preventing
		     *	memory leaks, sigh.
d1663 2
a1664 2
		 *  ...or which is mapped, by our "new method",
		 *  to a replacement string for this new charset.
d1677 1
a1677 1
    return (CONST char **)prepl;
d1681 1
a1681 1
 *  "New method" meets "Old method" ...
d1683 4
a1686 5
PRIVATE int UC_Register_with_LYCharSets ARGS4(
	int,		s,
	CONST char *,	UC_MIMEcharset,
	CONST char *,	UC_LYNXcharset,
	int,		lowest_eightbit)
d1689 1
a1689 1
    CONST char **repl;
d1694 2
a1695 2
	 *  Initialize here; so whoever changes
	 *  LYCharSets.c doesn't have to count...
d1698 1
a1698 1
	    LYNumCharsets = i+1;
d1703 1
a1703 1
     *	Search by MIME name, (LYchar_set_names may differ...)
d1715 3
a1717 2
	    CTRACE((tfp, "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset));
d1721 1
a1721 1
	 *  Add to LYCharSets.c lists.
d1724 1
a1724 1
	LYNumCharsets ++;
d1728 1
a1728 1
	 *  Hmm, try to be conservative here.
d1731 1
a1731 1
	LYchar_set_names[LYhndl+1] = NULL;
d1733 2
a1734 2
	*  Terminating NULL may be looked for by Lynx code.
	*/
d1740 1
a1740 1
     *	Can we just copy the pointer?  Hope so...
d1747 3
a1749 3
     *	@@@@@@ We really SHOULD get more info from the table files,
     *	and set relevant flags in the LYCharSet_UC[] entry with
     *	that info...  For now, let's try it without. - KW
d1758 1
a1758 1
	repl = UC_setup_LYCharSets_repl(s,UCInfo[s].lowest_eight);
d1762 1
a1762 1
	     *	Remember to FREE at exit.
d1771 1
a1771 1
 *  This only sets up the structure - no initialization of the tables
d1774 9
a1782 10
PUBLIC void UC_Charset_Setup ARGS9(
	CONST char *,		UC_MIMEcharset,
	CONST char *,		UC_LYNXcharset,
	CONST u8 *,		unicount,
	CONST u16 *,		unitable,
	int,			nnuni,
	struct unimapdesc_str,	replacedesc,
	int,			lowest_eight,
	int,			UC_rawuni,
	int,			codepage)
d1788 1
a1788 1
     *	Get (new?) slot.
d1801 1
a1801 1
			UC_MIMEcharset, UC_LYNXcharset));
d1820 1
a1820 1
	lowest_eight = 128;  /* cheat here */
d1835 12
a1846 12
 *  UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 *  Alternative functions for adding character set info to the lists
 *  kept in LYCharSets.c.
 *  These are for character sets without any real tables of their own.
 *  We don't keep an entry in UCinfo[] for them.
 */
PRIVATE int UC_NoUctb_Register_with_LYCharSets ARGS5(
	CONST char *,	UC_MIMEcharset,
	CONST char *,	UC_LYNXcharset,
	int,		lowest_eightbit,
	int,			UC_rawuni,
	int,			codepage)
d1852 2
a1853 2
	 *  Initialize here; so whoever changes
	 *  LYCharSets.c doesn't have to count...
d1856 1
a1856 1
	    LYNumCharsets = i+1;
d1861 2
a1862 2
     *	Search by MIME name, (LYchar_set_names may differ...)
     *  ignore if already present!
d1873 3
a1875 2
	CTRACE((tfp, "UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
	       UC_MIMEcharset, UC_LYNXcharset));
d1879 2
a1880 2
	 *  Add to LYCharSets.c lists.
	 */
d1882 1
a1882 1
    LYNumCharsets ++;
d1886 1
a1886 1
    LYchar_set_names[LYhndl+1] = NULL;
d1888 1
a1888 1
     *  Terminating NULL may be looked for by Lynx code.
d1891 1
a1891 1
    LYCharSet_UC[LYhndl].UChndl = -1; /* no corresponding UChndl ! */
d1897 3
a1899 3
     *	@@@@@@ We really SHOULD get more info from the table files,
     *	and set relevant flags in the LYCharSet_UC[] entry with
     *	that info...  For now, let's try it without. - KW
d1906 1
a1906 1
 *  A wrapper for the previous function.
d1908 6
a1913 7
PRIVATE void UC_Charset_NoUctb_Setup ARGS6(
	CONST char *,		UC_MIMEcharset,
	CONST char *,		UC_LYNXcharset,
	int,			trydefault,
	int,			lowest_eight,
	int,			UC_rawuni,
	int,			codepage)
d1918 1
a1918 1
     *	Ignore completely if already in slot.
d1926 1
a1926 1
	lowest_eight = 128;  /* cheat here */
d1928 3
a1930 3
    ** lookup, not even default' when negative.  The value will
    ** be returned immediately by UCTrans* functions.
    */
d1932 1
a1932 1
	codepage = -12;	/* if not already set; any negative should do. */
d1942 1
a1942 1
PRIVATE void UCcleanup_mem NOARGS
d1959 1
a1959 1
PRIVATE int CpOrdinal ARGS2 (CONST unsigned long, cp, CONST int, other)
d1995 1
a1995 1
#  endif /* __EMX__ */
d1998 1
a1998 1
PUBLIC void UCInit NOARGS
d2007 7
a2013 8
/*
 *  The order of charset names visible in Lynx Options menu
 *  correspond to the order of lines below,
 *  except the first two described in LYCharSet.c
 *
 *  Entries whose comment is marked with *** are declared in UCdomap.h,
 *  others are based on the included tables - UCdomap.c, near the top.
 */
d2015 10
a2024 10
    UC_CHARSET_SETUP_iso_8859_1;	  /* ISO Latin 1	  */
    UC_CHARSET_SETUP_iso_8859_15;	  /* ISO 8859-15 (Latin 9)*/
    UC_CHARSET_SETUP_cp850;		  /* DosLatin1 (cp850)	  */
    UC_CHARSET_SETUP_windows_1252;	  /* WinLatin1 (cp1252)   */
    UC_CHARSET_SETUP_cp437;		  /* DosLatinUS (cp437)   */

    UC_CHARSET_SETUP_dec_mcs;		  /* DEC Multinational	  */
    UC_CHARSET_SETUP_macintosh;		  /* Macintosh (8 bit)	  */
    UC_CHARSET_SETUP_next;		  /* NeXT character set   */
    UC_CHARSET_SETUP_hp_roman8;		  /* HP Roman8		  */
d2032 2
a2033 2
    UC_CHARSET_SETUP_viscii;		  /* Vietnamese (VISCII)  */
    UC_CHARSET_SETUP;	/* us-ascii */	  /* 7 bit approximations */
d2037 23
a2059 23
    UC_CHARSET_SETUP_iso_8859_2;	  /* ISO Latin 2	  */
    UC_CHARSET_SETUP_cp852;		  /* DosLatin2 (cp852)	  */
    UC_CHARSET_SETUP_windows_1250;	  /* WinLatin2 (cp1250)   */
    UC_CHARSET_SETUP_iso_8859_3;	  /* ISO Latin 3	  */
    UC_CHARSET_SETUP_iso_8859_4;	  /* ISO Latin 4	  */
    UC_CHARSET_SETUP_cp775;		  /* DosBaltRim (cp775)   */
    UC_CHARSET_SETUP_windows_1257;	  /* WinBaltRim (cp1257)  */
    UC_CHARSET_SETUP_iso_8859_5;	  /* ISO 8859-5 Cyrillic  */
    UC_CHARSET_SETUP_cp866;		  /* DosCyrillic (cp866)  */
    UC_CHARSET_SETUP_windows_1251;	  /* WinCyrillic (cp1251) */
    UC_CHARSET_SETUP_koi8_r;		  /* KOI8-R Cyrillic	  */
    UC_CHARSET_SETUP_iso_8859_6;	  /* ISO 8869-6 Arabic	  */
    UC_CHARSET_SETUP_cp864;		  /* DosArabic (cp864)	  */
    UC_CHARSET_SETUP_windows_1256;	  /* WinArabic (cp1256)   */
    UC_CHARSET_SETUP_iso_8859_7;	  /* ISO 8859-7 Greek	  */
    UC_CHARSET_SETUP_cp737;		  /* DosGreek (cp737)	  */
    UC_CHARSET_SETUP_cp869;		  /* DosGreek2 (cp869)	  */
    UC_CHARSET_SETUP_windows_1253;	  /* WinGreek (cp1253)	  */
    UC_CHARSET_SETUP_iso_8859_8;	  /* ISO 8859-8 Hebrew	  */
    UC_CHARSET_SETUP_cp862;		  /* DosHebrew (cp862)	  */
    UC_CHARSET_SETUP_windows_1255;	  /* WinHebrew (cp1255)   */
    UC_CHARSET_SETUP_iso_8859_9;	  /* ISO 8859-9 (Latin 5) */
    UC_CHARSET_SETUP_iso_8859_10;	  /* ISO 8859-10	  */
d2062 5
a2066 5
    UC_CHARSET_SETUP_mnemonic_ascii_0;	  /* RFC 1345 w/o Intro   */
    UC_CHARSET_SETUP_mnemonic;		  /* RFC 1345 Mnemonic	  */
    UC_CHARSET_SETUP_cp866u;		  /* Ukrainian Cyrillic (866) */
    UC_CHARSET_SETUP_koi8_u;		  /* Ukrainian Cyrillic (koi8-u) */
    UC_CHARSET_SETUP_ptcp154;		  /* Cyrillic-Asian (PT154) */
d2093 2
a2094 2
 *  To add synonyms for any charset name
 *  check function UCGetLYhndl_byMIME in this file.
d2098 1
a2098 1
    LATIN1   = UCGetLYhndl_byMIME("iso-8859-1");
d2105 2
a2106 2
 *  Safe variant of UCGetLYhndl_byMIME, with blind recovery from typo
 *  in user input: lynx.cfg, userdefs.h, command line switches.
d2108 1
a2108 1
PUBLIC int safeUCGetLYhndl_byMIME ARGS1 (CONST char *, value)
d2112 2
a2113 2
    if (i == -1) {	/* was user's typo or not yet recognized value */
	i = LATIN1;	/* error recovery? */
d2117 182
a2298 1
    return(i);
d2300 1
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d72 1
d652 1
a652 1
PUBLIC int UTF8 = -1;          /* UCGetLYhndl_byMIME("utf-8")      */
d2079 1
d2113 1
a2113 1
    UTF8     = UCGetLYhndl_byMIME("utf-8");
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a22 1
#include <UCkd.h>
d33 7
a39 7
#include <cp1250_uni.h> 	/* WinLatin2 (cp1250)	*/
#include <cp1251_uni.h> 	/* WinCyrillic (cp1251) */
#include <cp1252_uni.h> 	/* WinLatin1 (cp1252)	*/
#include <cp1253_uni.h> 	/* WinGreek (cp1253)	*/
#include <cp1255_uni.h> 	/* WinHebrew (cp1255)	*/
#include <cp1256_uni.h> 	/* WinArabic (cp1256)	*/
#include <cp1257_uni.h> 	/* WinBaltRim (cp1257)	*/
d65 1
a65 1
#include <mnem2_suni.h> 	/* RFC 1345 Mnemonic	*/
d69 1
a69 1
#include <viscii_uni.h> 	/* Vietnamese (VISCII)	*/
d72 9
a80 3
#ifdef NOTDEFINED
#include <mnem_suni.h>
#endif /* NOTDEFINED */
a258 7
#ifdef NOTDEFINED
PRIVATE unsigned char inverse_translate PARAMS((int glyph));
PRIVATE int con_set_trans_old PARAMS((unsigned char *arg));
PRIVATE int con_get_trans_old PARAMS((unsigned char *arg));
PRIVATE int con_set_trans_new PARAMS((u16 *arg));
PRIVATE int con_get_trans_new PARAMS((u16 *arg));
#endif /* NOTDEFINED */
a276 5
#ifdef NOTDEFINED
PRIVATE int con_set_unimap PARAMS((
	u16			ct,
	struct unipair *	list));
#endif /* NOTDEFINED */
a284 6
#ifdef NOTDEFINED
PRIVATE int con_get_unimap PARAMS((
	u16			ct,
	u16 *			uct,
	struct unipair *	list));
#endif /* NOTDEFINED */
d341 1
a341 1
	    q[glyph] = j;
a354 99
#ifdef NOTDEFINED
/*
 * Inverse translation is impossible for several reasons:
 * 1. The font<->character maps are not 1-1.
 * 2. The text may have been written while a different translation map
 *    was active, or using Unicode.
 * Still, it is now possible to a certain extent to cut and paste non-ASCII.
 */
PRIVATE unsigned char inverse_translate ARGS1(
	int,		glyph)
{
    if (glyph < 0 || glyph >= MAX_GLYPH) {
		return 0;
    } else {
	return ((inv_translate && inv_translate[glyph]) ?
				   inv_translate[glyph] :
				   (unsigned char)(glyph & 0xff));
    }
}

/*
 *  Load customizable translation table.
 *  'arg' points to a 256 byte translation table.
 *
 *  The "old" variants are for translation directly to font (using the
 *  0xf000-0xf0ff "transparent" Unicodes) whereas the "new" variants set
 *  Unicodes explicitly.
 */
PRIVATE int con_set_trans_old ARGS1(
	unsigned char *,	arg)
{
    int i;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_READ, (void *)arg, E_TABSZ);
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++)
	p[i] = UNI_DIRECT_BASE | (u16)arg[i];

    set_inverse_transl(USER_MAP);
    return 0;
}

PRIVATE int con_get_trans_old ARGS1(
	unsigned char *,	arg)
{
    int i, ch;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_WRITE, (void *)arg, E_TABSZ);
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++) {
	ch = conv_uni_to_pc(p[i]);
#ifdef NOTDEFINED
	put_user((ch & ~0xff) ? 0 : ch, arg+i);
#endif /* NOTDEFINED */
	arg[i] = (unsigned char)((ch & ~0xff) ? 0 : ch);
    }
    return 0;
}

PRIVATE int con_set_trans_new ARGS1(
	u16 *,		arg)
{
    int i;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_READ, (void *)arg, E_TABSZ*sizeof(u16));
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++)
	p[i] = arg[i];

    set_inverse_transl(USER_MAP);
    return 0;
}

PRIVATE int con_get_trans_new ARGS1(
	u16 *		arg)
{
    int i;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_WRITE, (void *)arg, E_TABSZ*sizeof(u16));
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++)
	arg[i] = p[i];

    return 0;
}
#endif /* NOTDEFINED */

d371 2
a372 2
	CTRACE(tfp, "UC_con_set_trans: Invalid charset handle %d.\n",
		    UC_charset_in_hndl);
a382 2
     *  (this function preserved by num_uni==0 so unicount=NULL for built-in
     *  charsets like CJK or x-transparent should not be a problem?)
d476 1
a476 1
	    return -ENOMEM;
d486 1
a486 1
	    return -ENOMEM;
d500 1
a500 1
	CONST char *, 	replace_str,
d518 1
a518 1
	    return -ENOMEM;
d529 1
a529 1
	    return -ENOMEM;
a610 21
#ifdef NOTDEFINED
PRIVATE int con_set_unimap ARGS2(
	u16,			ct,
	struct unipair *,	list)
{
    int err = 0, err1, i;

    while (ct--) {
	if ((err1 = con_insert_unipair(list->unicode, list->fontpos)) != 0) {
	    err = err1;
	}
	list++;
    }

    for (i = 0; i <= 3; i++) {
	set_inverse_transl(i); /* Update all inverse translations */
    }
    return err;
}
#endif /* NOTDEFINED */

a623 1
     *  (default font can not be a fake one, so unicout!=NULL for sure.)
d630 1
a630 1
	    con_insert_unipair(*(p++), i, 1);
a633 6
#if 0
    for (i = 0; i <= 3; i++) {
	set_inverse_transl(i);	/* Update all inverse translations */
    }
#endif

d652 1
d663 2
a664 2
	CTRACE(tfp, "UC_con_set_unimap: Invalid charset handle %d.\n",
		    UC_charset_out_hndl);
a675 1
     *  (fake 0 for built-in charsets like CJK or x-transparent, add a check)
d679 1
a679 1
    for (i = 0; i < 256 && UCInfo[UC_charset_out_hndl].unicount != NULL; i++) {
d681 1
a681 1
	    con_insert_unipair(*(p++), i, 0);
a722 33
#ifdef NOTDEFINED
PRIVATE int con_get_unimap ARGS3(
	u16,			ct,
	u16 *,			uct,
	struct unipair *,	list)
{
    int i, j, k, ect;
    u16 **p1, *p2;

    ect = 0;
    if (hashtable_contents_valid) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    if ((p2 = *(p1++)) != NULL) {
			for (k = 0; k < 64; k++) {
			    if (*p2 < MAX_GLYPH && ect++ < ct) {
				list->unicode = (u16) ((i<<11)+(j<<6)+k);
				list->fontpos = (u16) *p2;
				list++;
			    }
			    p2++;
			}
		    }
		}
	    }
	}
    }
    *uct = ect;
    return ((ect <= ct) ? 0 : -ENOMEM);
}
#endif /* NOTDEFINED */

a812 10
#ifdef NOTDEFINED	/* We don't handle the following here: */
    } else if ((ucs & ~UNI_DIRECT_MASK) == UNI_DIRECT_BASE) {
	/*
	 *  UNI_DIRECT_BASE indicates the start of the region in the
	 *  User Zone which always has a 1:1 mapping to the currently
	 *  loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 *  of the region.
	 */
	return ucs & UNI_DIRECT_MASK;
#endif /* NOTDEFINED */
d839 1
d865 2
d905 1
a905 1
	char *, 	outbuf,
d921 2
d943 2
a944 1
	    outbuf[0] = src; outbuf[1] = '\0';
d963 2
a964 1
	    outbuf[0] = src; outbuf[1] = '\0';
d987 2
a988 1
	    outbuf[0] = rc; outbuf[1] = '\0';
d1030 2
a1031 2
    CTRACE(tfp, "UC_MapGN: Using %d <- %d (%s)\n",
		Gn, UChndl, UCInfo[UChndl].MIMEname);
d1050 1
a1050 1
	return (unsigned char)ch_in;
d1057 2
d1089 1
a1089 1
    unicode = UC_translate[(unsigned char)ch_in];
d1115 1
a1115 1
  ch_iu = (unsigned char)ch_in;
d1119 1
a1119 1
    if ((unsigned char)ch_in < 128 && (unsigned char)ch_in >= 32)
d1124 1
a1124 1
    if ((unsigned char)ch_in < 32 &&
d1139 1
a1139 1
  unicode = UC_translate[(unsigned char)ch_in];
d1150 1
a1150 1
    int rc;
d1153 1
a1153 1
    int i_ch = (unsigned char)ch_out;
d1158 1
a1158 1
	return ch_out;
d1169 2
d1187 1
a1187 7
	    if ((Gn = UCInfo[UChndl_in].GN) >= 0) {
		UC_translate = set_translate(Gn);
		rc = inv_translate[i_ch];
		if (rc >= 32) {
		    return rc;
		}
	    } else {
d1189 3
a1191 1
		UC_translate = set_translate(Gn);
d1193 2
a1194 3
		if (rc >= 32) {
		    return rc;
		}
d1205 1
a1205 1
	char *, 	outbuf,
d1236 2
d1251 1
a1251 1
    unicode = UC_translate[(unsigned char)ch_in];
d1269 2
a1270 1
	    outbuf[0] = src; outbuf[1] = '\0';
d1289 2
a1290 1
	    outbuf[0] = src; outbuf[1] = '\0';
d1313 2
a1314 1
	    outbuf[0] = rc; outbuf[1] = '\0';
d1347 23
d1381 1
a1381 1
	CTRACE(tfp, "UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n");
d1397 1
d1405 3
a1407 2
    if (!strncasecomp(value, "iso-2022-jp", 11) ||
	!strcasecomp(value, "x-euc-jp")) {
d1410 4
a1413 1
    if (!strcasecomp(value, "x-shift-jis")) {
d1416 2
d1421 2
d1428 2
d1433 2
d1439 2
d1446 2
d1459 2
d1470 1
d1473 3
a1475 3
	isdigit((unsigned char)value[3]) &&
	isdigit((unsigned char)value[4]) &&
	isdigit((unsigned char)value[5])) {
d1480 1
a1480 7
	char * cptmp = NULL;

	StrAllocCopy(cptmp, (value + 1));
	cptmp[0] = 'c';
	cptmp[1] = 'p';
	if ((LYhndl = UCGetLYhndl_byMIME(cptmp)) >= 0) {
	    FREE(cptmp);
a1481 1
	}
d1485 1
a1485 5
	StrAllocCopy(cptmp, "windows-");
	StrAllocCat(cptmp, (value + 3));
	LYhndl = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
	return LYhndl;
d1488 3
a1490 3
	isdigit((unsigned char)value[8]) &&
	isdigit((unsigned char)value[9]) &&
	isdigit((unsigned char)value[10])) {
d1494 1
a1494 8
	char * cptmp = NULL;

	StrAllocCopy(cptmp, (value + 6));
	cptmp[0] = 'c';
	cptmp[1] = 'p';
	LYhndl = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
	return LYhndl;
d1496 1
d1500 1
d1503 1
a1503 1
    CTRACE(tfp, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value);
d1559 1
a1559 1
    CONST char **tp;
d1570 1
a1570 1
    tp = (CONST char **)malloc(96 * sizeof(CONST char *));
d1594 1
a1594 1
		   ti[k-160] = i;
d1615 1
a1615 1
		tp[k-160] = list->replace_str;
d1642 1
a1642 1
	if (s8 && (unsigned char)(*s8) >= 160 && strlen(s8) == 1) {
d1647 2
a1648 2
	    if (ti[(unsigned char)(*s8) - 160] >= lowest8 &&
		!(s7[0] == ti[(unsigned char)(*s8) - 160] &&
d1655 1
a1655 1
		if (ti[(unsigned char)(*s8) - 160] == (unsigned char)(*s8)) {
d1659 1
a1659 15
		     *			      ...or another byte...
		     */
#ifdef NOTDEFINED
		    *p = (char *)malloc(2*sizeof(char));
		    if (!*p) {
			FREE(tp);
			FREE(ti);
			FREE(prepl);
			return NULL;
		    }
		    (*p)[0] = ti[(unsigned char)(*s8) - 160];
		    (*p)[1] = '\0';
#else
		    /*
		     *	Use this instead... make those 1-char strings
d1666 1
a1666 1
		    dummy[0] = ti[(unsigned char)(*s8) - 160];
a1667 1
#endif /* NOTDEFINED */
d1670 2
a1671 2
	    } else if (tp[(unsigned char)(*s8) - 160] &&
		       strcmp(s7, tp[(unsigned char)(*s8) - 160])) {
d1676 1
a1676 1
		*p = tp[(unsigned char)(*s8) - 160];
d1726 2
a1727 2
	    CTRACE(tfp, "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset);
d1811 2
a1812 2
	    CTRACE(tfp, "UC_Charset_Setup: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset);
d1845 107
d1968 41
d2034 1
a2034 1
    UC_CHARSET_SETUP_macintosh; 	  /* Macintosh (8 bit)	  */
d2040 1
a2040 1
    UC_CHARSET_SETUP_shift_jis; 	  /*** Japanese (Shift_JIS) */
d2078 24
a2101 3
#ifdef NOTDEFINED
    UC_CHARSET_SETUP_mnem;
#endif /* NOTDEFINED */
d2108 1
a2108 1
/* easy to type: */
d2112 1
d2117 1
a2117 1
 *  in user input: lynx.cfg, userdefs.h, switches from command line.
d2125 1
a2125 1
	CTRACE(tfp, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n");
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d23 1
a28 8
#if defined(EXP_LOCALE_CHARSET) && defined(HAVE_LANGINFO_CODESET)
#include <langinfo.h>
#endif

#ifdef EXP_JAPANESEUTF8_SUPPORT
#include <iconv.h>
#endif

d32 1
a32 1
 * Include chartrans tables:
d34 16
a49 16
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)   */
#include <cp1251_uni.h>		/* WinCyrillic (cp1251) */
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)   */
#include <cp1253_uni.h>		/* WinGreek (cp1253)    */
#include <cp1255_uni.h>		/* WinHebrew (cp1255)   */
#include <cp1256_uni.h>		/* WinArabic (cp1256)   */
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)  */
#include <cp437_uni.h>		/* DosLatinUS (cp437)   */
#include <cp737_uni.h>		/* DosGreek (cp737)     */
#include <cp775_uni.h>		/* DosBaltRim (cp775)   */
#include <cp850_uni.h>		/* DosLatin1 (cp850)    */
#include <cp852_uni.h>		/* DosLatin2 (cp852)    */
#include <cp862_uni.h>		/* DosHebrew (cp862)    */
#include <cp864_uni.h>		/* DosArabic (cp864)    */
#include <cp866_uni.h>		/* DosCyrillic (cp866)  */
#include <cp869_uni.h>		/* DosGreek2 (cp869)    */
d51 10
a60 10
#include <dmcs_uni.h>		/* DEC Multinational    */
#include <hp_uni.h>		/* HP Roman8            */
#include <iso01_uni.h>		/* ISO Latin 1          */
#include <iso02_uni.h>		/* ISO Latin 2          */
#include <iso03_uni.h>		/* ISO Latin 3          */
#include <iso04_uni.h>		/* ISO Latin 4          */
#include <iso05_uni.h>		/* ISO 8859-5 Cyrillic  */
#include <iso06_uni.h>		/* ISO 8859-6 Arabic    */
#include <iso07_uni.h>		/* ISO 8859-7 Greek     */
#include <iso08_uni.h>		/* ISO 8859-8 Hebrew    */
d62 9
a70 9
#include <iso10_uni.h>		/* ISO 8859-10          */
#include <iso15_uni.h>		/* ISO 8859-15 (Latin 9) */
#include <koi8r_uni.h>		/* KOI8-R Cyrillic      */
#include <mac_uni.h>		/* Macintosh (8 bit)    */
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic    */
#include <next_uni.h>		/* NeXT character set   */
#include <rfc_suni.h>		/* RFC 1345 w/o Intro   */
/* #include <utf8_uni.h> *//* UNICODE UTF 8        */
#include <viscii_uni.h>		/* Vietnamese (VISCII)  */
d73 162
a234 171
#include <pt154_uni.h>		/* Cyrillic-Asian (PT154) */

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
int auto_display_charset = -1;
#endif

static const char *UC_GNsetMIMEnames[4] =
{"iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"};

static int UC_GNhandles[4] =
{-1, -1, -1, -1};

/*
 * Some of the code below, and some of the comments, are left in for
 * historical reasons.  Not all those tables below are currently
 * really needed (and what with all those hardwired codepoints),
 * but let's keep them around for now.  They may come in handy if we
 * decide to make more extended use of the mechanisms (including e.g.
 * for chars < 127...).  - KW
 */

static u16 translations[][256] =
{
    /*
     * 8-bit Latin-1 mapped to Unicode -- trivial mapping.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * VT100 graphics mapped to Unicode.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,
	0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
	0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0xf800,
	0xf801, 0x2500, 0xf803, 0xf804, 0x251c, 0x2524, 0x2534, 0x252c,
	0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * IBM Codepage 437 mapped to Unicode.
     */
    {
	0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
	0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
	0x25ba, 0x25c4, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
	0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
	0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
	0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
	0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
	0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
	0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
	0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
	0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
	0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
	0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
	0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
	0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
	0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
	0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
	0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
    },
    /*
     * User mapping -- default to codes for direct font mapping.
     */
    {
	0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,
	0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,
	0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,
	0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,
	0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,
	0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,
	0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,
	0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,
	0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,
	0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,
	0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,
	0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,
	0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,
	0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,
	0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,
	0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,
	0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,
	0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,
	0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,
	0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,
	0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,
	0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,
	0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,
	0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,
	0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,
	0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,
	0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,
	0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,
	0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,
	0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,
	0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,
	0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff
    }
d236 1
a236 1
static u16 *UC_translate = NULL;
d238 1
a238 1
static struct UC_charset UCInfo[MAXCHARSETS];
d241 2
a242 2
 * The standard kernel character-to-font mappings are not invertible
 * -- this is just a best effort.
d246 75
a320 28
static unsigned char *inv_translate = NULL;
static unsigned char inv_norm_transl[MAX_GLYPH];
static unsigned char *inverse_translations[4] =
{NULL, NULL, NULL, NULL};

static void set_inverse_transl(int i);
static u16 *set_translate(int m);
static int UC_valid_UC_charset(int UC_charset_hndl);
static void UC_con_set_trans(int UC_charset_in_hndl, int Gn, int update_flag);
static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault);
static int con_insert_unipair_str(u16 unicode, const char *replace_str, int fordefault);
static void con_clear_unimap(int fordefault);
static void con_clear_unimap_str(int fordefault);
static void con_set_default_unimap(void);
static int UC_con_set_unimap(int UC_charset_out_hndl, int update_flag);
static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list, int fordefault);
static int conv_uni_to_pc(long ucs, int usedefault);
static int conv_uni_to_str(char *outbuf, int buflen, long ucs, int usedefault);
static void UCconsole_map_init(void);
static int UC_MapGN(int UChndl, int update_flag);
static int UC_FindGN_byMIME(const char *UC_MIMEcharset);
static void UCreset_allocated_LYCharSets(void);
static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl, unsigned lowest8);
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit);

d322 2
a323 2
static void UCfree_allocated_LYCharSets(void);
static void UCcleanup_mem(void);
d326 1
a326 1
static int default_UChndl = -1;
d328 2
a329 1
static void set_inverse_transl(int i)
d337 1
a337 1
	 * Slightly messy to avoid calling kmalloc too early.
d341 1
a341 1
				       (unsigned char *) malloc(MAX_GLYPH));
d352 1
a352 1
	     * Prefer '-' above SHY etc.
d354 1
a354 1
	    q[glyph] = UCH(j);
d359 2
a360 1
static u16 *set_translate(int m)
d362 4
a365 4
    if (!inverse_translations[m])
	set_inverse_transl(m);
    inv_translate = inverse_translations[m];
    return translations[m];
d368 10
a377 1
static int UC_valid_UC_charset(int UC_charset_hndl)
d379 7
a385 1
    return (UC_charset_hndl >= 0 && UC_charset_hndl < UCNumCharsets);
d388 89
a476 3
static void UC_con_set_trans(int UC_charset_in_hndl,
			     int Gn,
			     int update_flag)
d479 1
a479 1
    const u16 *p;
d483 2
a484 2
	CTRACE((tfp, "UC_con_set_trans: Invalid charset handle %d.\n",
		UC_charset_in_hndl));
d490 1
a490 1
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
d494 3
a496 1
     * The font is always 256 characters - so far.
d511 1
a511 1
	set_inverse_transl(Gn);	/* Update inverse translation for this one */
d524 2
a525 2
static int hashtable_contents_valid = 0;	/* Use ASCII-only mode for bootup */
static int hashtable_str_contents_valid = 0;
d527 1
a527 1
static u16 **uni_pagedir[32] =
d529 4
a532 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d535 1
a535 1
static char ***uni_pagedir_str[32] =
d537 4
a540 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d543 2
a544 2
static const u16 *UC_current_unitable = NULL;
static struct unimapdesc_str *UC_current_unitable_str = NULL;
d547 2
a548 2
 * Keep a second set of structures for the translation designated
 * as "default" - kw
d550 2
a551 2
static int unidefault_contents_valid = 0;	/* Use ASCII-only mode for bootup */
static int unidefault_str_contents_valid = 0;
d555 4
a558 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d560 1
a560 1
static char ***unidefault_pagedir_str[32] =
d562 4
a565 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d568 2
a569 2
static const u16 *UC_default_unitable = 0;
static const struct unimapdesc_str *UC_default_unitable_str = 0;
d571 4
a574 1
static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault)
d579 1
a579 1
    if (fordefault)
d584 1
a584 1
	p1 = (u16 * *)malloc(32 * sizeof(u16 *));
d589 2
a590 2
	if (!p1)
	    return -1;
d598 1
a598 1
	p2 = p1[n] = (u16 *) malloc(64 * sizeof(u16));
d600 1
a600 1
	    return -1;
d603 1
a603 1
	    p2[i] = 0xffff;	/* No glyph for this character (yet) */
d612 4
a615 2
static int con_insert_unipair_str(u16 unicode, const char *replace_str,
				  int fordefault)
d619 1
a619 1
    const char **p2;
d621 1
a621 1
    if (fordefault)
d626 1
a626 2
	p1 = (char ***) malloc(32 * sizeof(char **));

d631 2
a632 2
	if (!p1)
	    return -1;
d641 1
a641 2
	p1[n] = (char **) malloc(64 * sizeof(char *));

d643 1
a643 1
	    return -1;
d645 1
a645 1
	p2 = (const char **) p1[n];
d650 1
a650 1
    p2 = (const char **) p1[n];
d658 1
a658 1
 * ui arg was a leftover, deleted.  - KW
d660 2
a661 1
static void con_clear_unimap(int fordefault)
d693 1
a693 1
static void con_clear_unimap_str(int fordefault)
d695 2
a696 2
    int i, j;
    char ***p1;
d698 5
a702 7
    if (fordefault) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = unidefault_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
d704 1
a704 1
	    unidefault_pagedir_str[i] = NULL;
d706 2
d709 6
a714 8
	unidefault_str_contents_valid = 1;	/* ??? probably no use... */
    } else {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
d716 1
a716 1
	    uni_pagedir_str[i] = NULL;
d718 20
d739 2
a740 1
	hashtable_str_contents_valid = 1;	/* ??? probably no use... */
d742 1
d744 1
d747 4
a750 4
 * Loads the unimap for the hardware font, as defined in uni_hash.tbl.
 * The representation used was the most compact I could come up
 * with.  This routine is executed at sys_setup time, and when the
 * PIO_FONTRESET ioctl is called.
d752 1
a752 1
static void con_set_default_unimap(void)
d755 1
a755 1
    const u16 *p;
d758 2
a759 1
     * The default font is always 256 characters.
d766 1
a766 1
	    con_insert_unipair(*(p++), (u16) i, 1);
d770 6
d783 1
a783 12
int UCNumCharsets = 0;

int UCLYhndl_HTFile_for_unspec = -1;
int UCLYhndl_HTFile_for_unrec = -1;
int UCLYhndl_for_unspec = -1;
int UCLYhndl_for_unrec = -1;

/* easy to type, will initialize later */
int LATIN1 = -1;		/* UCGetLYhndl_byMIME("iso-8859-1") */
int US_ASCII = -1;		/* UCGetLYhndl_byMIME("us-ascii")   */
int UTF8_handle = -1;		/* UCGetLYhndl_byMIME("utf-8")      */
int TRANSPARENT = -1;		/* UCGetLYhndl_byMIME("x-transparent")  */
d785 14
a798 2
static int UC_con_set_unimap(int UC_charset_out_hndl,
			     int update_flag)
d801 1
a801 1
    const u16 *p;
d804 2
a805 2
	CTRACE((tfp, "UC_con_set_unimap: Invalid charset handle %d.\n",
		UC_charset_out_hndl));
d810 2
a811 2
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
	return update_flag;	/* nothing to be done */
d816 2
a817 1
     * The font is always 256 characters - so far.
d821 1
a821 1
    for (i = 0; i < 256; i++) {
d823 1
a823 1
	    con_insert_unipair(*(p++), (u16) i, 0);
d836 4
a839 2
static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list,
				 int fordefault)
d853 1
a853 1
     * No inverse translations for replacement strings!
d865 36
a900 2
static int conv_uni_to_pc(long ucs,
			  int usedefault)
d906 1
a906 1
     * Only 16-bit codes supported at this time.
d910 1
a910 1
	 * U+FFFD:  REPLACEMENT CHARACTER.
d915 1
a915 1
	 * Not a printable character.
d920 1
a920 1
	 * Zero-width space.
d925 4
a928 4
	 * UNI_DIRECT_BASE indicates the start of the region in the
	 * User Zone which always has a 1:1 mapping to the currently
	 * loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 * of the region.
d950 1
a950 1
     * Not found.
d956 1
a956 1
 * Note:  contents of outbuf is not changes for negative return value!
d958 5
a962 4
static int conv_uni_to_str(char *outbuf,
			   int buflen,
			   long ucs,
			   int usedefault)
d968 1
a968 1
     * Only 16-bit codes supported at this time.
d972 1
a972 1
	 * U+FFFD:  REPLACEMENT CHARACTER.
d975 3
a977 3
	/*
	 * Maybe the following two cases should be allowed here??  - KW
	 */
d980 1
a980 1
	 * Not a printable character.
d985 1
a985 1
	 * Zero-width space.
d988 10
d1013 2
a1014 2
	strncpy(outbuf, h, (size_t) (buflen - 1));
	return 1;		/* ok ! */
d1018 1
a1018 1
     * Not found.
d1023 1
a1023 2
int UCInitialized = 0;

d1025 1
a1025 1
 * [ original comment:  - KW ]
d1030 1
a1030 1
static void UCconsole_map_init(void)
d1037 1
a1037 1
 * OK now, finally, some stuff that is more specifically for Lynx:  - KW
d1039 3
a1041 2
int UCTransUniChar(long unicode,
		   int charset_out)
d1046 1
a1046 1
    const u16 *ut;
a1048 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return (unicode < 128) ? (int) unicode : LYCharSet_UC[charset_out].codepage;
d1084 1
a1084 1
 * Returns string length, or negative value for error.
d1086 6
a1091 5
int UCTransUniCharStr(char *outbuf,
		      int buflen,
		      long unicode,
		      int charset_out,
		      int chk_single_flag)
d1096 2
a1097 2
    struct unimapdesc_str *repl;
    const u16 *ut;
a1102 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1123 1
a1123 2
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
d1130 1
a1130 1
	if (repl != UC_current_unitable_str) {
d1142 1
a1142 2
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
a1146 29
#ifdef EXP_JAPANESEUTF8_SUPPORT
	if ((strcmp(LYCharSet_UC[charset_out].MIMEname, "shift_jis") == 0) ||
	    (strcmp(LYCharSet_UC[charset_out].MIMEname, "euc-jp") == 0)) {
	    iconv_t cd;
	    char str[3], *pin, *pout;
	    size_t inleft, outleft;

	    str[0] = unicode >> 8;
	    str[1] = unicode & 0xFF;
	    str[2] = 0;
	    pin = str;
	    inleft = 2;
	    pout = outbuf, outleft = buflen;
	    cd = iconv_open(LYCharSet_UC[charset_out].MIMEname,
			    "UTF-16BE//TRANSLIT");
	    rc = iconv(cd, &pin, &inleft, &pout, &outleft);
	    iconv_close(cd);
	    if ((pout - outbuf) == 3) {
		CTRACE((tfp,
			"It seems to be a JIS X 0201 code(%ld). Not supported.\n", unicode));
		pin = str;
		inleft = 2;
		pout = outbuf, outleft = buflen;
	    } else if (rc >= 0) {
		*pout = '\0';
		return (strlen(outbuf));
	    }
	}
#endif
d1165 1
a1165 2
	    outbuf[0] = (char) rc;
	    outbuf[1] = '\0';
d1173 1
a1173 1
static int UC_lastautoGN = 0;
d1175 3
a1177 2
static int UC_MapGN(int UChndl,
		    int update_flag)
a1179 1

d1207 3
a1209 3
    CTRACE((tfp, "UC_MapGN: Using %d <- %d (%s)\n",
	    Gn, UChndl, UCInfo[UChndl].MIMEname));
    UC_con_set_trans(UChndl, Gn, update_flag);
d1213 4
a1216 3
int UCTransChar(char ch_in,
		int charset_in,
		int charset_out)
d1222 1
a1222 1
    const u16 *ut;
d1227 1
a1227 1
	return UCH(ch_in);
a1233 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1244 1
a1244 1
	Gn = UC_MapGN(UChndl_in, 0);
d1264 1
a1264 1
    unicode = UC_translate[UCH(ch_in)];
d1282 7
a1288 6
long int UCTransToUni(char ch_in,
		      int charset_in)
{
    int unicode, Gn;
    unsigned char ch_iu;
    int UChndl_in;
d1290 1
a1290 1
    ch_iu = UCH(ch_in);
d1294 1
a1294 1
    if (UCH(ch_in) < 128 && UCH(ch_in) >= 32)
d1299 1
a1299 1
    if (UCH(ch_in) < 32 &&
d1302 1
a1302 1
	 * Don't translate C0 chars except for specific charsets.
d1310 1
a1310 1
	Gn = UC_MapGN(UChndl_in, 1);
d1313 2
a1314 2
    UC_translate = set_translate(Gn);
    unicode = UC_translate[UCH(ch_in)];
d1316 1
a1316 1
    return unicode;
d1319 4
a1322 3
int UCReverseTransChar(char ch_out,
		       int charset_in,
		       int charset_out)
d1325 1
a1325 1
    int rc = -1;
d1328 2
a1329 2
    int i_ch = UCH(ch_out);
    const u16 *ut;
d1333 1
a1333 1
	return UCH(ch_out);
a1343 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1353 4
a1356 4
	 * Try to use the inverse table if charset_out is not equivalent
	 * to using just the default table.  If it is, it should have
	 * just ASCII chars and trying to back-translate those should
	 * not give anything but themselves.  - kw
d1360 9
a1368 5
	    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
		Gn = UC_MapGN(UChndl_in, 1);
	    }
	    UC_translate = set_translate(Gn);
	    if (inv_translate)
d1370 3
a1372 2
	    if (rc >= 32) {
		return rc;
d1380 1
a1380 1
 * Returns string length, or negative value for error.
d1382 7
a1388 6
int UCTransCharStr(char *outbuf,
		   int buflen,
		   char ch_in,
		   int charset_in,
		   int charset_out,
		   int chk_single_flag)
d1394 2
a1395 2
    struct unimapdesc_str *repl;
    const u16 *ut;
a1413 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1427 1
a1427 1
    unicode = UC_translate[UCH(ch_in)];
d1433 1
a1433 2
		if (upd)
		    set_inverse_transl(Gn);
d1445 1
a1445 2
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
d1464 1
a1464 2
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
d1487 1
a1487 2
	    outbuf[0] = (char) rc;
	    outbuf[1] = '\0';
d1498 2
a1499 1
static int UC_FindGN_byMIME(const char *UC_MIMEcharset)
d1501 1
a1501 1
    int i;
d1504 2
a1505 2
	if (!strcmp(UC_MIMEcharset, UC_GNsetMIMEnames[i])) {
	    return i;
d1508 1
a1508 1
    return -1;
d1511 2
a1512 1
int UCGetRawUniMode_byLYhndl(int i)
d1516 1
a1516 24
    return LYCharSet_UC[i].enc;
}

/*
 * Construct a new charset name, given prefix and codepage.  This introduces
 * potentially unchecked recursion into UCGetLYhntl_byMIME if neither the "cp"
 * nor "windows-" prefixes are configured, so we check it here.
 */
static int getLYhndl_byCP(const char *prefix,
			  const char *codepage)
{
    static int nested;
    int result = -1;

    if (!nested++) {
	char *cptmp = NULL;

	StrAllocCopy(cptmp, prefix);
	StrAllocCat(cptmp, codepage);
	result = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
    }
    nested--;
    return result;
d1520 3
a1522 3
 * Get Lynx internal charset handler from MIME name,
 * return -1 if we got NULL or did not recognize value.
 * According to RFC, MIME headers should match case-insensitively.
d1524 2
a1525 1
int UCGetLYhndl_byMIME(const char *value)
d1531 1
a1531 2
	CTRACE((tfp,
		"UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
d1539 1
a1539 1
	    !strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
a1546 1
#if !NO_CHARSET_utf_8
d1554 2
a1555 3
#endif
#if !NO_CHARSET_euc_jp
    if (!strcasecomp(value, "x-euc-jp")) {
d1558 1
a1558 4
#endif
#if !NO_CHARSET_shift_jis
    if ((!strcasecomp(value, "x-shift-jis")) ||
	(!strcasecomp(value, "x-sjis"))) {
a1560 2
#endif
#if !NO_CHARSET_euc_kr
a1563 2
#endif
#if !NO_CHARSET_euc_cn
a1568 2
#endif
#if !NO_CHARSET_big5
a1571 2
#endif
#if !NO_CHARSET_macintosh
a1575 2
#endif
#if !NO_CHARSET_next
a1580 2
#endif
#if !NO_CHARSET_windows_1252
a1591 2
#endif
#if !NO_CHARSET_windows_1250
a1600 1
#endif
d1603 3
a1605 3
	isdigit(UCH(value[3])) &&
	isdigit(UCH(value[4])) &&
	isdigit(UCH(value[5]))) {
d1610 7
a1616 1
	if ((LYhndl = getLYhndl_byCP("cp", value + 3)) >= 0)
d1618 1
d1622 5
a1626 1
	return getLYhndl_byCP("windows-", value + 3);
d1629 3
a1631 3
	isdigit(UCH(value[8])) &&
	isdigit(UCH(value[9])) &&
	isdigit(UCH(value[10]))) {
d1635 8
a1642 1
	return getLYhndl_byCP("cp", value + 8);
d1644 2
a1645 3
#if !NO_CHARSET_koi8_r
    if (!strcasecomp(value, "koi-8")) {		/* accentsoft bugosity */
	return UCGetLYhndl_byMIME("koi8-r");
a1646 1
#endif
d1649 2
a1650 2
    CTRACE((tfp, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value));
    return -1;			/* returns -1 if no charset found by that MIME name */
d1654 4
a1657 4
 * Function UC_setup_LYCharSets_repl() tries to set up a subtable in
 * LYCharSets[] appropriate for this new charset, for compatibility with the
 * "old method".  Maybe not nice (maybe not even necessary any more), but it
 * works (as far as it goes..).
d1659 9
a1667 8
 * We try to be conservative and only allocate new memory for this if needed. 
 * If not needed, just point to SevenBitApproximations[i].  [Could do the same
 * for ISO_Latin1[] if it's identical to that, but would make it even *more*
 * messy than it already is...] This the only function in this file that knows,
 * or cares, about the HTMLDTD or details of LYCharSets[] subtables (and
 * therefore somewhat violates the idea that this file should be independent of
 * those).  As in other places, we rely on ISO_Latin1 being the *first* table
 * in LYCharSets.  - KW
d1671 1
a1671 1
 * We need to remember which ones were allocated and which are static.
d1673 1
a1673 1
static const char **remember_allocated_LYCharSets[MAXCHARSETS];
d1675 1
a1675 1
static void UCreset_allocated_LYCharSets(void)
d1685 1
a1685 1
static void UCfree_allocated_LYCharSets(void)
d1697 3
a1699 2
static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl,
					     unsigned lowest8)
d1701 2
a1702 2
    const char **ISO_Latin1 = LYCharSets[0];
    const char **p;
d1704 4
a1707 4
    const u16 *pp;
    char **tp;
    const char *s7;
    const char *s8;
d1714 1
a1714 1
     * Create a temporary table for reverse lookup of latin1 codes:
d1716 1
a1716 2
    tp = (char **) malloc(96 * sizeof(char *));

d1721 1
a1721 1
    ti = (u8 *) malloc(96 * sizeof(u8));
d1732 3
a1734 3
     * Determine if we have any mapping of a Unicode in the range 160-255
     * to an allowed code point > 0x80 in our new charset...
     * Store any mappings found in ti[].
d1740 1
a1740 1
		    ti[k - 160] = UCH(i);
d1747 2
a1748 1
    } {
d1753 3
a1755 3
	 * Determine if we have any mapping of a Unicode in the range
	 * 160-255 to a replacement string for our new charset...
	 * Store any mappings found in tp[].
d1761 1
a1761 1
		tp[k - 160] = (char *) list->replace_str;
d1767 4
a1770 6
     * Now allocate a new table compatible with LYCharSets[]
     * and with the HTMLDTD for entities.
     * We don't know yet whether we'll keep it around.
     */
    prepl = (char **) malloc(HTML_dtd.number_of_entities * sizeof(char *));

d1777 1
a1777 1
    p = (const char **) prepl;
d1781 3
a1783 3
	 * For each of those entities, we check what the "old method"
	 * ISO_Latin1[] mapping does with them.  If it is nothing we
	 * want to use, just point to the SevenBitApproximations[] string.
d1788 1
a1788 1
	if (s8 && UCH(*s8) >= 160 && s8[1] == '\0') {
d1790 2
a1791 2
	     * We have an entity that is mapped to
	     * one valid eightbit latin1 char.
d1793 3
a1795 3
	    if (ti[UCH(*s8) - 160] >= UCH(lowest8) &&
		!(s7[0] == ti[UCH(*s8) - 160] &&
		  s7[1] == '\0')) {
d1797 3
a1799 3
		 * ...which in turn is mapped, by our "new method",
		 * to another valid eightbit char for this new
		 * charset:  either to itself...
d1801 1
a1801 1
		if (ti[UCH(*s8) - 160] == UCH(*s8)) {
d1805 18
a1822 4
		     * make those 1-char strings
		     * into HTAtoms, so they will be cleaned up
		     * at exit...  all for the sake of preventing
		     * memory leaks, sigh.
d1826 1
a1826 1
		    dummy[0] = ti[UCH(*s8) - 160];
d1828 1
d1831 2
a1832 2
	    } else if (tp[UCH(*s8) - 160] &&
		       strcmp(s7, tp[UCH(*s8) - 160])) {
d1834 2
a1835 2
		 * ...or which is mapped, by our "new method",
		 * to a replacement string for this new charset.
d1837 1
a1837 1
		*p = tp[UCH(*s8) - 160];
d1848 1
a1848 1
    return (const char **) prepl;
d1852 1
a1852 1
 * "New method" meets "Old method" ...
d1854 5
a1858 4
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit)
d1861 1
a1861 1
    const char **repl;
d1866 2
a1867 2
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
d1870 1
a1870 1
	    LYNumCharsets = i + 1;
d1875 1
a1875 1
     * Search by MIME name, (LYchar_set_names may differ...)
d1887 2
a1888 3
	    CTRACE((tfp,
		    "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		    UC_MIMEcharset, UC_LYNXcharset));
d1892 1
a1892 1
	 * Add to LYCharSets.c lists.
d1895 1
a1895 1
	LYNumCharsets++;
d1899 1
a1899 1
	 * Hmm, try to be conservative here.
d1902 1
a1902 1
	LYchar_set_names[LYhndl + 1] = NULL;
d1904 2
a1905 2
	 * Terminating NULL may be looked for by Lynx code.
	 */
d1911 1
a1911 1
     * Can we just copy the pointer?  Hope so...
d1918 3
a1920 3
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
d1929 1
a1929 1
	repl = UC_setup_LYCharSets_repl(s, UCInfo[s].lowest_eight);
d1933 1
a1933 1
	     * Remember to FREE at exit.
d1942 1
a1942 1
 * This only sets up the structure - no initialization of the tables
d1945 10
a1954 9
void UC_Charset_Setup(const char *UC_MIMEcharset,
		      const char *UC_LYNXcharset,
		      const u8 * unicount,
		      const u16 * unitable,
		      int nnuni,
		      struct unimapdesc_str replacedesc,
		      int lowest_eight,
		      int UC_rawuni,
		      int codepage)
d1960 1
a1960 1
     * Get (new?) slot.
d1972 2
a1973 2
	    CTRACE((tfp, "UC_Charset_Setup: Too many.  Ignoring %s/%s.",
		    UC_MIMEcharset, UC_LYNXcharset));
d1992 1
a1992 1
	lowest_eight = 128;	/* cheat here */
a2005 107
/*
 * UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 * Alternative functions for adding character set info to the lists
 * kept in LYCharSets.c.
 *
 * These are for character sets without any real tables of their own.
 * We don't keep an entry in UCinfo[] for them.
 */
static int UC_NoUctb_Register_with_LYCharSets(const char *UC_MIMEcharset,
					      const char *UC_LYNXcharset,
					      int lowest_eightbit,
					      int UC_rawuni,
					      int codepage)
{
    int i, LYhndl = -1;

    if (LYNumCharsets == 0) {
	/*
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
	 */
	for (i = 0; (i < MAXCHARSETS) && LYchar_set_names[i]; i++) {
	    LYNumCharsets = i + 1;
	}
    }

    /*
     * Search by MIME name, (LYchar_set_names may differ...)
     * ignore if already present!
     */
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    return -1;
	}
    }

    /* not found */
    if (LYNumCharsets >= MAXCHARSETS) {
	CTRACE((tfp,
		"UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		UC_MIMEcharset, UC_LYNXcharset));
	return -1;
    }
    /*
     * Add to LYCharSets.c lists.
     */
    LYhndl = LYNumCharsets;
    LYNumCharsets++;
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
    LYCharSets[LYhndl] = SevenBitApproximations;
    LYchar_set_names[LYhndl] = UC_LYNXcharset;
    LYchar_set_names[LYhndl + 1] = NULL;
    /*
     * Terminating NULL may be looked for by Lynx code.
     */

    LYCharSet_UC[LYhndl].UChndl = -1;	/* no corresponding UChndl ! */
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UC_rawuni;
    LYCharSet_UC[LYhndl].codepage = codepage;

    /*
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
     */

    return LYhndl;
}

/*
 * A wrapper for the previous function.
 */
static void UC_Charset_NoUctb_Setup(const char *UC_MIMEcharset,
				    const char *UC_LYNXcharset,
				    int trydefault,
				    int lowest_eight,
				    int UC_rawuni,
				    int codepage)
{
    int i;

    /*
     * Ignore completely if already in slot.
     */
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].MIMEname, UC_MIMEcharset)) {
	    return;
	}
    }
    if (UC_rawuni == UCT_ENC_UTF8)
	lowest_eight = 128;	/* cheat here */
    /* 'codepage' doubles as a flag for 'do not try any table
     * lookup, not even default' when negative.  The value will
     * be returned immediately by UCTrans* functions.
     */
    if (!trydefault && codepage == 0)
	codepage = -12;		/* if not already set; any negative should do. */
    UC_NoUctb_Register_with_LYCharSets(UC_MIMEcharset,
				       UC_LYNXcharset,
				       lowest_eight,
				       UC_rawuni,
				       codepage);
    return;
}

d2007 1
a2007 1
static void UCcleanup_mem(void)
d2022 1
a2022 42
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
static int CpOrdinal(const unsigned long cp, const int other)
{
    char lyName[80];
    char myMimeName[80];
    char *mimeName, *mName = NULL, *lName = NULL;
    int s, i, exists = 0, ret;

    CTRACE((tfp, "CpOrdinal(cp=%ul, other=%d).\n", cp, other));
    sprintf(myMimeName, "auto%s-cp%lu", (other ? "2" : ""), cp);
    mimeName = myMimeName + 5 + (other != 0);
    sprintf(lyName, "AutoDetect%s (cp%lu)",
	    (other ? "-2" : ""), cp);
    /* Find slot. */
    s = -1;
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].LYNXname, lyName))
	    return UCGetLYhndl_byMIME(myMimeName);
	else if (!strcasecomp(UCInfo[i].MIMEname, mimeName))
	    s = i;
    }
    if (s < 0)
	return -1;
    /* Store the "real" charset info */
    real_charsets[other != 0] = UCGetLYhndl_byMIME(mimeName);
    /* Duplicate the record. */
    StrAllocCopy(mName, myMimeName);
    StrAllocCopy(lName, lyName);
    UC_Charset_Setup(mName, lName,
		     UCInfo[s].unicount, UCInfo[s].unitable,
		     UCInfo[s].num_uni, UCInfo[s].replacedesc,
		     UCInfo[s].lowest_eight, UCInfo[s].enc,
		     UCInfo[s].codepage);
    ret = UCGetLYhndl_byMIME(myMimeName);
    CTRACE((tfp, "Found %i.\n", ret));
    return ret;
}
#  endif			/* __EMX__ */
#endif /* CAN_AUTODETECT_DISPLAY_CHARSET */

void UCInit(void)
d2031 8
a2038 7
    /*
     * The order of charset names visible in Lynx Options menu correspond to
     * the order of lines below, except the first two described in LYCharSet.c
     *
     * Entries whose comment is marked with *** are declared in UCdomap.h,
     * others are based on the included tables - UCdomap.c, near the top.
     */
d2040 10
a2049 10
    UC_CHARSET_SETUP_iso_8859_1;	/* ISO Latin 1          */
    UC_CHARSET_SETUP_iso_8859_15;	/* ISO 8859-15 (Latin 9) */
    UC_CHARSET_SETUP_cp850;	/* DosLatin1 (cp850)    */
    UC_CHARSET_SETUP_windows_1252;	/* WinLatin1 (cp1252)   */
    UC_CHARSET_SETUP_cp437;	/* DosLatinUS (cp437)   */

    UC_CHARSET_SETUP_dec_mcs;	/* DEC Multinational    */
    UC_CHARSET_SETUP_macintosh;	/* Macintosh (8 bit)    */
    UC_CHARSET_SETUP_next;	/* NeXT character set   */
    UC_CHARSET_SETUP_hp_roman8;	/* HP Roman8            */
d2053 1
a2053 1
    UC_CHARSET_SETUP_shift_jis;		  /*** Japanese (Shift_JIS) */
d2057 2
a2058 2
    UC_CHARSET_SETUP_viscii;	/* Vietnamese (VISCII)  */
    UC_CHARSET_SETUP;		/* us-ascii *//* 7 bit approximations */
d2062 23
a2084 23
    UC_CHARSET_SETUP_iso_8859_2;	/* ISO Latin 2          */
    UC_CHARSET_SETUP_cp852;	/* DosLatin2 (cp852)    */
    UC_CHARSET_SETUP_windows_1250;	/* WinLatin2 (cp1250)   */
    UC_CHARSET_SETUP_iso_8859_3;	/* ISO Latin 3          */
    UC_CHARSET_SETUP_iso_8859_4;	/* ISO Latin 4          */
    UC_CHARSET_SETUP_cp775;	/* DosBaltRim (cp775)   */
    UC_CHARSET_SETUP_windows_1257;	/* WinBaltRim (cp1257)  */
    UC_CHARSET_SETUP_iso_8859_5;	/* ISO 8859-5 Cyrillic  */
    UC_CHARSET_SETUP_cp866;	/* DosCyrillic (cp866)  */
    UC_CHARSET_SETUP_windows_1251;	/* WinCyrillic (cp1251) */
    UC_CHARSET_SETUP_koi8_r;	/* KOI8-R Cyrillic      */
    UC_CHARSET_SETUP_iso_8859_6;	/* ISO 8869-6 Arabic    */
    UC_CHARSET_SETUP_cp864;	/* DosArabic (cp864)    */
    UC_CHARSET_SETUP_windows_1256;	/* WinArabic (cp1256)   */
    UC_CHARSET_SETUP_iso_8859_7;	/* ISO 8859-7 Greek     */
    UC_CHARSET_SETUP_cp737;	/* DosGreek (cp737)     */
    UC_CHARSET_SETUP_cp869;	/* DosGreek2 (cp869)    */
    UC_CHARSET_SETUP_windows_1253;	/* WinGreek (cp1253)    */
    UC_CHARSET_SETUP_iso_8859_8;	/* ISO 8859-8 Hebrew    */
    UC_CHARSET_SETUP_cp862;	/* DosHebrew (cp862)    */
    UC_CHARSET_SETUP_windows_1255;	/* WinHebrew (cp1255)   */
    UC_CHARSET_SETUP_iso_8859_9;	/* ISO 8859-9 (Latin 5) */
    UC_CHARSET_SETUP_iso_8859_10;	/* ISO 8859-10          */
d2087 7
a2093 29
    UC_CHARSET_SETUP_mnemonic_ascii_0;	/* RFC 1345 w/o Intro   */
    UC_CHARSET_SETUP_mnemonic;	/* RFC 1345 Mnemonic    */
    UC_CHARSET_SETUP_cp866u;	/* Ukrainian Cyrillic (866) */
    UC_CHARSET_SETUP_koi8_u;	/* Ukrainian Cyrillic (koi8-u) */
    UC_CHARSET_SETUP_ptcp154;	/* Cyrillic-Asian (PT154) */

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
    {
	unsigned long lst[3];
	unsigned long len, rc;

	rc = DosQueryCp(sizeof(lst), lst, &len);
	if (rc == 0) {
	    if (len >= 1)
		auto_display_charset = CpOrdinal(lst[0], 0);
#    ifdef CAN_SWITCH_DISPLAY_CHARSET
	    if (len >= 3) {
		codepages[0] = lst[0];
		codepages[1] = (lst[0] == lst[1] ? lst[2] : lst[1]);
		auto_other_display_charset = CpOrdinal(codepages[1], 1);
	    }
#    endif
	} else {
	    CTRACE((tfp, "DosQueryCp() returned %#lx=%lu.\n", rc, rc));
	}
    }
#  endif
#endif
d2096 2
a2097 2
 * To add synonyms for any charset name check function UCGetLYhndl_byMIME in
 * this file.
d2100 2
a2101 2
/* for coding/performance - easy to type: */
    LATIN1 = UCGetLYhndl_byMIME("iso-8859-1");
d2103 1
a2103 2
    UTF8_handle = UCGetLYhndl_byMIME("utf-8");
    TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
d2107 2
a2108 2
 * Safe variant of UCGetLYhndl_byMIME, with blind recovery from typo in user
 * input:  lynx.cfg, userdefs.h, command line switches.
d2110 1
a2110 1
int safeUCGetLYhndl_byMIME(const char *value)
d2114 3
a2116 3
    if (i == -1) {		/* was user's typo or not yet recognized value */
	i = LATIN1;		/* error recovery? */
	CTRACE((tfp, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n"));
d2119 1
a2119 182
    return (i);
}

#ifdef EXP_LOCALE_CHARSET

#if defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET)
/*
 * This is a quick-and-dirty emulator of the nl_langinfo(CODESET)
 * function defined in the Single Unix Specification for those systems
 * (FreeBSD, etc.) that don't have one yet. It behaves as if it had
 * been called after setlocale(LC_CTYPE, ""), that is it looks at
 * the locale environment variables.
 *
 * http://www.opengroup.org/onlinepubs/7908799/xsh/langinfo.h.html
 *
 * Please extend it as needed and suggest improvements to the author.
 * This emulator will hopefully become redundant soon as
 * nl_langinfo(CODESET) becomes more widely implemented.
 *
 * Since the proposed Li18nux encoding name registry is still not mature,
 * the output follows the MIME registry where possible:
 *
 *   http://www.iana.org/assignments/character-sets
 *
 * A possible autoconf test for the availability of nl_langinfo(CODESET)
 * can be found in
 *
 *   http://www.cl.cam.ac.uk/~mgk25/unicode.html#activate
 *
 * Markus.Kuhn@@cl.cam.ac.uk -- 2002-03-11
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 *
 * Latest version:
 *
 *   http://www.cl.cam.ac.uk/~mgk25/ucs/langinfo.c
 */

/*
#include "langinfo.h"
*/
typedef int nl_item;

#define CODESET 1

#define C_CODESET "US-ASCII"	/* Return this as the encoding of the
				 * C/POSIX locale. Could as well one day
				 * become "UTF-8". */

#define digit(x) ((x) >= '0' && (x) <= '9')

static char buf[16];

static char *nl_langinfo(nl_item item)
{
    char *l, *p;

    if (item != CODESET)
	return NULL;

    if (((l = getenv("LC_ALL")) && *l) ||
	((l = getenv("LC_CTYPE")) && *l) ||
	((l = getenv("LANG")) && *l)) {
	/* check standardized locales */
	if (!strcmp(l, "C") || !strcmp(l, "POSIX"))
	    return C_CODESET;
	/* check for encoding name fragment */
	if (strstr(l, "UTF") || strstr(l, "utf"))
	    return "UTF-8";
	if ((p = strstr(l, "8859-"))) {
	    memcpy(buf, "ISO-8859-\0\0", 12);
	    p += 5;
	    if (digit(*p)) {
		buf[9] = *p++;
		if (digit(*p))
		    buf[10] = *p++;
		return buf;
	    }
	}
	if (strstr(l, "KOI8-R"))
	    return "KOI8-R";
	if (strstr(l, "KOI8-U"))
	    return "KOI8-U";
	if (strstr(l, "620"))
	    return "TIS-620";
	if (strstr(l, "2312"))
	    return "GB2312";
	if (strstr(l, "HKSCS"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "Big5") || strstr(l, "BIG5"))
	    return "Big5";
	if (strstr(l, "GBK"))
	    return "GBK";	/* no MIME charset */
	if (strstr(l, "18030"))
	    return "GB18030";	/* no MIME charset */
	if (strstr(l, "Shift_JIS") || strstr(l, "SJIS"))
	    return "Shift_JIS";
	/* check for conclusive modifier */
	if (strstr(l, "euro"))
	    return "ISO-8859-15";
	/* check for language (and perhaps country) codes */
	if (strstr(l, "zh_TW"))
	    return "Big5";
	if (strstr(l, "zh_HK"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "zh"))
	    return "GB2312";
	if (strstr(l, "ja"))
	    return "EUC-JP";
	if (strstr(l, "ko"))
	    return "EUC-KR";
	if (strstr(l, "ru"))
	    return "KOI8-R";
	if (strstr(l, "uk"))
	    return "KOI8-U";
	if (strstr(l, "pl") || strstr(l, "hr") ||
	    strstr(l, "hu") || strstr(l, "cs") ||
	    strstr(l, "sk") || strstr(l, "sl"))
	    return "ISO-8859-2";
	if (strstr(l, "eo") || strstr(l, "mt"))
	    return "ISO-8859-3";
	if (strstr(l, "el"))
	    return "ISO-8859-7";
	if (strstr(l, "he"))
	    return "ISO-8859-8";
	if (strstr(l, "tr"))
	    return "ISO-8859-9";
	if (strstr(l, "th"))
	    return "TIS-620";	/* or ISO-8859-11 */
	if (strstr(l, "lt"))
	    return "ISO-8859-13";
	if (strstr(l, "cy"))
	    return "ISO-8859-14";
	if (strstr(l, "ro"))
	    return "ISO-8859-2";	/* or ISO-8859-16 */
	if (strstr(l, "am") || strstr(l, "vi"))
	    return "UTF-8";
	/* Send me further rules if you like, but don't forget that we are
	 * *only* interested in locale naming conventions on platforms
	 * that do not already provide an nl_langinfo(CODESET) implementation. */
	return "ISO-8859-1";	/* should perhaps be "UTF-8" instead */
    }
    return C_CODESET;
}
#endif /* defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET) */

/*
 * If LYLocaleCharset is true, use the current locale to lookup a MIME name
 * that corresponds, and use that as the display charset.  This feature is
 * experimental because while nl_langinfo(CODESET) itself is standardized,
 * the return values and their relationship to the locale value is not.
 * GNU libiconv happens to give useful values, but other implementations are
 * not guaranteed to do this.
 *
 * Not all Linux versions provide useful information.  GNU libc 2.2 returns
 *	"ANSI_X3.4-1968"
 * whether locale is POSIX or en_US.UTF-8.
 *
 * Another possible thing to investigate is the locale_charset() function
 * provided in libiconv 1.5.1.
 */
void LYFindLocaleCharset(void)
{
    CTRACE((tfp, "LYFindLocaleCharset(%d)\n", LYLocaleCharset));
    if (LYLocaleCharset) {
	char *name = nl_langinfo(CODESET);

	if (name != 0) {
	    int value = UCGetLYhndl_byMIME(name);

	    if (value >= 0) {
		current_char_set = value;
	    } else {
		CTRACE((tfp, "Cannot find a handle for MIME name \"%s\"\n", name));
		LYLocaleCharset = FALSE;
	    }
	} else {
	    CTRACE((tfp, "Cannot find a MIME name for locale\n"));
	    LYLocaleCharset = FALSE;
	}
    }
a2120 1
#endif /* EXP_LOCALE_CHARSET */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d23 1
d34 7
a40 7
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)	*/
#include <cp1251_uni.h>		/* WinCyrillic (cp1251) */
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)	*/
#include <cp1253_uni.h>		/* WinGreek (cp1253)	*/
#include <cp1255_uni.h>		/* WinHebrew (cp1255)	*/
#include <cp1256_uni.h>		/* WinArabic (cp1256)	*/
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)	*/
d66 1
a66 1
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic	*/
d70 1
a70 1
#include <viscii_uni.h>		/* Vietnamese (VISCII)	*/
d73 3
a75 9

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
int auto_display_charset = -1;
#endif

CONST char *UC_GNsetMIMEnames[4] =
	{"iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"};

int UC_GNhandles[4] = {-1, -1, -1, -1};
d254 7
d279 5
d292 6
d354 1
a354 1
	    q[glyph] = UCH(j);
d368 99
d483 2
a484 2
	CTRACE((tfp, "UC_con_set_trans: Invalid charset handle %d.\n",
		    UC_charset_in_hndl));
d495 2
d590 1
a590 1
	    return -1;
d600 1
a600 1
	    return -1;
d614 1
a614 1
	CONST char *,	replace_str,
d632 1
a632 1
	    return -1;
d643 1
a643 1
	    return -1;
d725 21
d759 1
d766 1
a766 1
	    con_insert_unipair(*(p++), (u16)i, 1);
d770 6
a793 1
PUBLIC int TRANSPARENT = -1;   /* UCGetLYhndl_byMIME("x-transparent")  */
d804 2
a805 2
	CTRACE((tfp, "UC_con_set_unimap: Invalid charset handle %d.\n",
		    UC_charset_out_hndl));
d817 1
d821 1
a821 1
    for (i = 0; i < 256; i++) {
d823 1
a823 1
	    con_insert_unipair(*(p++), (u16)i, 0);
d865 33
d988 10
a1023 1

a1048 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return (unicode < 128) ? (int)unicode : LYCharSet_UC[charset_out].codepage;
d1087 1
a1087 1
	char *,		outbuf,
a1102 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1123 1
a1123 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1142 1
a1142 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1165 1
a1165 2
	    outbuf[0] = (char)rc;
	    outbuf[1] = '\0';
d1207 2
a1208 2
    CTRACE((tfp, "UC_MapGN: Using %d <- %d (%s)\n",
		Gn, UChndl, UCInfo[UChndl].MIMEname));
d1227 1
a1227 1
	return UCH(ch_in);
a1233 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1264 1
a1264 1
    unicode = UC_translate[UCH(ch_in)];
d1290 1
a1290 1
  ch_iu = UCH(ch_in);
d1294 1
a1294 1
    if (UCH(ch_in) < 128 && UCH(ch_in) >= 32)
d1299 1
a1299 1
    if (UCH(ch_in) < 32 &&
d1314 1
a1314 1
  unicode = UC_translate[UCH(ch_in)];
d1325 1
a1325 1
    int rc = -1;
d1328 1
a1328 1
    int i_ch = UCH(ch_out);
d1333 1
a1333 1
	return UCH(ch_out);
a1343 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1360 7
a1366 1
	    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
d1368 1
a1368 3
	    }
	    UC_translate = set_translate(Gn);
	    if (inv_translate)
d1370 3
a1372 2
	    if (rc >= 32) {
		return rc;
d1383 1
a1383 1
	char *,		outbuf,
a1413 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1427 1
a1427 1
    unicode = UC_translate[UCH(ch_in)];
d1445 1
a1445 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1464 1
a1464 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1487 1
a1487 2
	    outbuf[0] = (char)rc;
	    outbuf[1] = '\0';
a1519 23
 * Construct a new charset name, given prefix and codepage.  This introduces
 * potentially unchecked recursion into UCGetLYhntl_byMIME if neither the "cp"
 * nor "windows-" prefixes are configured, so we check it here.
 */
PRIVATE int getLYhndl_byCP ARGS2(
	CONST char *,	prefix,
	CONST char *,	codepage)
{
    static int nested;
    int result = -1;

    if (!nested++) {
	char *cptmp = NULL;
	StrAllocCopy(cptmp, prefix);
	StrAllocCat(cptmp, codepage);
	result = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
    }
    nested--;
    return result;
}

/*
d1531 1
a1531 1
	CTRACE((tfp, "UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
a1546 1
#if !NO_CHARSET_utf_8
d1554 2
a1555 3
#endif
#if !NO_CHARSET_euc_jp
    if (!strcasecomp(value, "x-euc-jp")) {
d1558 1
a1558 4
#endif
#if !NO_CHARSET_shift_jis
    if ((!strcasecomp(value, "x-shift-jis")) ||
	(!strcasecomp(value, "x-sjis"))) {
a1560 2
#endif
#if !NO_CHARSET_euc_kr
a1563 2
#endif
#if !NO_CHARSET_euc_cn
a1568 2
#endif
#if !NO_CHARSET_big5
a1571 2
#endif
#if !NO_CHARSET_macintosh
a1575 2
#endif
#if !NO_CHARSET_next
a1580 2
#endif
#if !NO_CHARSET_windows_1252
a1591 2
#endif
#if !NO_CHARSET_windows_1250
a1600 1
#endif
d1603 3
a1605 3
	isdigit(UCH(value[3])) &&
	isdigit(UCH(value[4])) &&
	isdigit(UCH(value[5]))) {
d1610 7
a1616 1
	if ((LYhndl = getLYhndl_byCP("cp", value+3)) >= 0)
d1618 1
d1622 5
a1626 1
	return getLYhndl_byCP("windows-", value + 3);
d1629 3
a1631 3
	isdigit(UCH(value[8])) &&
	isdigit(UCH(value[9])) &&
	isdigit(UCH(value[10]))) {
d1635 8
a1642 1
	return getLYhndl_byCP("cp", value + 8);
a1643 1
#if !NO_CHARSET_koi8_r
a1646 1
#endif
d1649 1
a1649 1
    CTRACE((tfp, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value));
d1705 1
a1705 1
    char **tp;
d1716 1
a1716 1
    tp = (char **)malloc(96 * sizeof(char *));
d1740 1
a1740 1
		   ti[k-160] = UCH(i);
d1761 1
a1761 1
		tp[k-160] = (char *)list->replace_str;
d1788 1
a1788 1
	if (s8 && UCH(*s8) >= 160 && s8[1] == '\0') {
d1793 2
a1794 2
	    if (ti[UCH(*s8) - 160] >= UCH(lowest8) &&
		!(s7[0] == ti[UCH(*s8) - 160] &&
d1801 1
a1801 1
		if (ti[UCH(*s8) - 160] == UCH(*s8)) {
d1805 15
a1819 1
		     *	make those 1-char strings
d1826 1
a1826 1
		    dummy[0] = ti[UCH(*s8) - 160];
d1828 1
d1831 2
a1832 2
	    } else if (tp[UCH(*s8) - 160] &&
		       strcmp(s7, tp[UCH(*s8) - 160])) {
d1837 1
a1837 1
		*p = tp[UCH(*s8) - 160];
d1887 2
a1888 2
	    CTRACE((tfp, "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset));
d1972 2
a1973 2
	    CTRACE((tfp, "UC_Charset_Setup: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset));
a2005 107
/*
 *  UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 *  Alternative functions for adding character set info to the lists
 *  kept in LYCharSets.c.
 *  These are for character sets without any real tables of their own.
 *  We don't keep an entry in UCinfo[] for them.
 */
PRIVATE int UC_NoUctb_Register_with_LYCharSets ARGS5(
	CONST char *,	UC_MIMEcharset,
	CONST char *,	UC_LYNXcharset,
	int,		lowest_eightbit,
	int,			UC_rawuni,
	int,			codepage)
{
    int i, LYhndl = -1;

    if (LYNumCharsets == 0) {
	/*
	 *  Initialize here; so whoever changes
	 *  LYCharSets.c doesn't have to count...
	 */
	for (i = 0; (i < MAXCHARSETS) && LYchar_set_names[i]; i++) {
	    LYNumCharsets = i+1;
	}
    }

    /*
     *	Search by MIME name, (LYchar_set_names may differ...)
     *  ignore if already present!
     */
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    return -1;
	}
    }

    /* not found */
    if (LYNumCharsets >= MAXCHARSETS) {
	CTRACE((tfp, "UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
	       UC_MIMEcharset, UC_LYNXcharset));
	return -1;
    }
    /*
	 *  Add to LYCharSets.c lists.
	 */
    LYhndl = LYNumCharsets;
    LYNumCharsets ++;
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
    LYCharSets[LYhndl] = SevenBitApproximations;
    LYchar_set_names[LYhndl] = UC_LYNXcharset;
    LYchar_set_names[LYhndl+1] = NULL;
    /*
     *  Terminating NULL may be looked for by Lynx code.
     */

    LYCharSet_UC[LYhndl].UChndl = -1; /* no corresponding UChndl ! */
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UC_rawuni;
    LYCharSet_UC[LYhndl].codepage = codepage;

    /*
     *	@@@@@@ We really SHOULD get more info from the table files,
     *	and set relevant flags in the LYCharSet_UC[] entry with
     *	that info...  For now, let's try it without. - KW
     */

    return LYhndl;
}

/*
 *  A wrapper for the previous function.
 */
PRIVATE void UC_Charset_NoUctb_Setup ARGS6(
	CONST char *,		UC_MIMEcharset,
	CONST char *,		UC_LYNXcharset,
	int,			trydefault,
	int,			lowest_eight,
	int,			UC_rawuni,
	int,			codepage)
{
    int i;

    /*
     *	Ignore completely if already in slot.
     */
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].MIMEname, UC_MIMEcharset)) {
	    return;
	}
    }
    if (UC_rawuni == UCT_ENC_UTF8)
	lowest_eight = 128;  /* cheat here */
    /* 'codepage' doubles as a flag for 'do not try any table
    ** lookup, not even default' when negative.  The value will
    ** be returned immediately by UCTrans* functions.
    */
    if (!trydefault && codepage == 0)
	codepage = -12;	/* if not already set; any negative should do. */
    UC_NoUctb_Register_with_LYCharSets(UC_MIMEcharset,
				       UC_LYNXcharset,
				       lowest_eight,
				       UC_rawuni,
				       codepage);
    return;
}

a2021 41
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
PRIVATE int CpOrdinal ARGS2 (CONST unsigned long, cp, CONST int, other)
{
    char lyName[80];
    char myMimeName[80];
    char *mimeName, *mName = NULL, *lName = NULL;
    int s, i, exists = 0, ret;

    CTRACE((tfp, "CpOrdinal(cp=%ul, other=%d).\n", cp, other));
    sprintf(myMimeName, "auto%s-cp%lu", (other ? "2" : ""), cp);
    mimeName = myMimeName + 5 + (other != 0);
    sprintf(lyName, "AutoDetect%s (cp%lu)",
	    (other ? "-2" : ""), cp);
    /* Find slot. */
    s = -1;
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].LYNXname, lyName))
	    return UCGetLYhndl_byMIME(myMimeName);
	else if (!strcasecomp(UCInfo[i].MIMEname, mimeName))
	    s = i;
    }
    if (s < 0)
	return -1;
    /* Store the "real" charset info */
    real_charsets[other != 0] = UCGetLYhndl_byMIME(mimeName);
    /* Duplicate the record. */
    StrAllocCopy(mName, myMimeName);
    StrAllocCopy(lName, lyName);
    UC_Charset_Setup(mName, lName,
		     UCInfo[s].unicount, UCInfo[s].unitable,
		     UCInfo[s].num_uni, UCInfo[s].replacedesc,
		     UCInfo[s].lowest_eight, UCInfo[s].enc,
		     UCInfo[s].codepage);
    ret = UCGetLYhndl_byMIME(myMimeName);
    CTRACE((tfp, "Found %i.\n", ret));
    return ret;
}
#  endif /* __EMX__ */
#endif /* CAN_AUTODETECT_DISPLAY_CHARSET */

d2047 1
a2047 1
    UC_CHARSET_SETUP_macintosh;		  /* Macintosh (8 bit)	  */
d2053 1
a2053 1
    UC_CHARSET_SETUP_shift_jis;		  /*** Japanese (Shift_JIS) */
d2091 3
a2093 24

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
    {
	unsigned long lst[3];
	unsigned long len, rc;

	rc = DosQueryCp(sizeof(lst), lst, &len);
	if (rc == 0) {
	    if (len >= 1)
		auto_display_charset = CpOrdinal(lst[0], 0);
#    ifdef CAN_SWITCH_DISPLAY_CHARSET
	    if (len >= 3) {
		codepages[0] = lst[0];
		codepages[1] = (lst[0] == lst[1] ? lst[2] : lst[1]);
		auto_other_display_charset = CpOrdinal(codepages[1], 1);
	    }
#    endif
	} else {
	    CTRACE((tfp, "DosQueryCp() returned %#lx=%lu.\n", rc, rc));
	}
    }
#  endif
#endif
d2100 1
a2100 1
/* for coding/performance - easy to type: */
a2103 1
    TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
d2108 1
a2108 1
 *  in user input: lynx.cfg, userdefs.h, command line switches.
d2116 1
a2116 1
	CTRACE((tfp, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n"));
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@a71 1
#include <pt154_uni.h>		/* Cyrillic-Asian (PT154) */
d651 1
a651 1
PUBLIC int UTF8_handle = -1;   /* UCGetLYhndl_byMIME("utf-8")      */
a2077 1
    UC_CHARSET_SETUP_ptcp154;		  /* Cyrillic-Asian (PT154) */
d2111 1
a2111 1
    UTF8_handle = UCGetLYhndl_byMIME("utf-8");
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a27 4
#if defined(EXP_LOCALE_CHARSET) && defined(HAVE_LANGINFO_CODESET)
#include <langinfo.h>
#endif

a2131 151

#ifdef EXP_LOCALE_CHARSET

#if defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET)
/*
 * This is a quick-and-dirty emulator of the nl_langinfo(CODESET)
 * function defined in the Single Unix Specification for those systems
 * (FreeBSD, etc.) that don't have one yet. It behaves as if it had
 * been called after setlocale(LC_CTYPE, ""), that is it looks at
 * the locale environment variables.
 *
 * http://www.opengroup.org/onlinepubs/7908799/xsh/langinfo.h.html
 *
 * Please extend it as needed and suggest improvements to the author.
 * This emulator will hopefully become redundant soon as
 * nl_langinfo(CODESET) becomes more widely implemented.
 *
 * Since the proposed Li18nux encoding name registry is still not mature,
 * the output follows the MIME registry where possible:
 *
 *   http://www.iana.org/assignments/character-sets
 *
 * A possible autoconf test for the availability of nl_langinfo(CODESET)
 * can be found in
 *
 *   http://www.cl.cam.ac.uk/~mgk25/unicode.html#activate
 *
 * Markus.Kuhn@@cl.cam.ac.uk -- 2002-03-11
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 *
 * Latest version:
 *
 *   http://www.cl.cam.ac.uk/~mgk25/ucs/langinfo.c
 */

/*
#include "langinfo.h"
*/
typedef int nl_item;
#define CODESET 1

#define C_CODESET "US-ASCII"     /* Return this as the encoding of the
				  * C/POSIX locale. Could as well one day
				  * become "UTF-8". */

#define digit(x) ((x) >= '0' && (x) <= '9')

static char buf[16];

PRIVATE char *nl_langinfo(nl_item item)
{
  char *l, *p;

  if (item != CODESET)
    return NULL;

  if (((l = getenv("LC_ALL"))   && *l) ||
      ((l = getenv("LC_CTYPE")) && *l) ||
      ((l = getenv("LANG"))     && *l)) {
    /* check standardized locales */
    if (!strcmp(l, "C") || !strcmp(l, "POSIX"))
      return C_CODESET;
    /* check for encoding name fragment */
    if (strstr(l, "UTF") || strstr(l, "utf"))
      return "UTF-8";
    if ((p = strstr(l, "8859-"))) {
      memcpy(buf, "ISO-8859-\0\0", 12);
      p += 5;
      if (digit(*p)) {
	buf[9] = *p++;
	if (digit(*p)) buf[10] = *p++;
	return buf;
      }
    }
    if (strstr(l, "KOI8-R")) return "KOI8-R";
    if (strstr(l, "KOI8-U")) return "KOI8-U";
    if (strstr(l, "620")) return "TIS-620";
    if (strstr(l, "2312")) return "GB2312";
    if (strstr(l, "HKSCS")) return "Big5HKSCS";   /* no MIME charset */
    if (strstr(l, "Big5") || strstr(l, "BIG5")) return "Big5";
    if (strstr(l, "GBK")) return "GBK";           /* no MIME charset */
    if (strstr(l, "18030")) return "GB18030";     /* no MIME charset */
    if (strstr(l, "Shift_JIS") || strstr(l, "SJIS")) return "Shift_JIS";
    /* check for conclusive modifier */
    if (strstr(l, "euro")) return "ISO-8859-15";
    /* check for language (and perhaps country) codes */
    if (strstr(l, "zh_TW")) return "Big5";
    if (strstr(l, "zh_HK")) return "Big5HKSCS";   /* no MIME charset */
    if (strstr(l, "zh")) return "GB2312";
    if (strstr(l, "ja")) return "EUC-JP";
    if (strstr(l, "ko")) return "EUC-KR";
    if (strstr(l, "ru")) return "KOI8-R";
    if (strstr(l, "uk")) return "KOI8-U";
    if (strstr(l, "pl") || strstr(l, "hr") ||
	strstr(l, "hu") || strstr(l, "cs") ||
	strstr(l, "sk") || strstr(l, "sl")) return "ISO-8859-2";
    if (strstr(l, "eo") || strstr(l, "mt")) return "ISO-8859-3";
    if (strstr(l, "el")) return "ISO-8859-7";
    if (strstr(l, "he")) return "ISO-8859-8";
    if (strstr(l, "tr")) return "ISO-8859-9";
    if (strstr(l, "th")) return "TIS-620";      /* or ISO-8859-11 */
    if (strstr(l, "lt")) return "ISO-8859-13";
    if (strstr(l, "cy")) return "ISO-8859-14";
    if (strstr(l, "ro")) return "ISO-8859-2";   /* or ISO-8859-16 */
    if (strstr(l, "am") || strstr(l, "vi")) return "UTF-8";
    /* Send me further rules if you like, but don't forget that we are
     * *only* interested in locale naming conventions on platforms
     * that do not already provide an nl_langinfo(CODESET) implementation. */
    return "ISO-8859-1"; /* should perhaps be "UTF-8" instead */
  }
  return C_CODESET;
}
#endif /* defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET) */

/*
 * If LYLocaleCharset is true, use the current locale to lookup a MIME name
 * that corresponds, and use that as the display charset.  This feature is
 * experimental because while nl_langinfo(CODESET) itself is standardized,
 * the return values and their relationship to the locale value is not.
 * GNU libiconv happens to give useful values, but other implementations are
 * not guaranteed to do this.
 *
 * Not all Linux versions provide useful information.  GNU libc 2.2 returns
 *	"ANSI_X3.4-1968"
 * whether locale is POSIX or en_US.UTF-8.
 *
 * Another possible thing to investigate is the locale_charset() function
 * provided in libiconv 1.5.1.
 */
PUBLIC void LYFindLocaleCharset NOARGS
{
    CTRACE((tfp, "LYFindLocaleCharset(%d)\n", LYLocaleCharset));
    if (LYLocaleCharset) {
	char *name = nl_langinfo(CODESET);
	if (name != 0) {
	    int value = UCGetLYhndl_byMIME(name);
	    if (value >= 0) {
		current_char_set = value;
	    } else {
		CTRACE((tfp, "Cannot find a handle for MIME name \"%s\"\n", name));
		LYLocaleCharset = FALSE;
	    }
	} else {
	    CTRACE((tfp, "Cannot find a MIME name for locale\n"));
	    LYLocaleCharset = FALSE;
	}
    }
}
#endif /* EXP_LOCALE_CHARSET */
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d82 1
a82 1
const char *UC_GNsetMIMEnames[4] =
d96 1
a96 1
static u16 translations[][256] = {
d246 1
a246 1
static u16 *UC_translate = NULL;
d248 1
a248 1
static struct UC_charset UCInfo[MAXCHARSETS];
d256 11
a266 11
static unsigned char * inv_translate = NULL;
static unsigned char inv_norm_transl[MAX_GLYPH];
static unsigned char * inverse_translations[4] = { NULL, NULL, NULL, NULL };

static void set_inverse_transl (
	int		i);
static u16 *set_translate (
	int		m);
static int UC_valid_UC_charset (
	int		UC_charset_hndl);
static void UC_con_set_trans (
d269 2
a270 2
	int		update_flag);
static int con_insert_unipair (
d273 2
a274 2
	int		fordefault);
static int con_insert_unipair_str (
d276 8
a283 8
	const char *	replace_str,
	int		fordefault);
static void con_clear_unimap (
	int		fordefault);
static void con_clear_unimap_str (
	int		fordefault);
static void con_set_default_unimap (void);
static int UC_con_set_unimap (
d285 2
a286 2
	int		update_flag);
static int UC_con_set_unimap_str (
d289 2
a290 2
	int			fordefault);
static int conv_uni_to_pc (
d292 2
a293 2
	int			usedefault);
static int conv_uni_to_str (
d297 3
a299 3
	int		usedefault);
static void UCconsole_map_init (void);
static int UC_MapGN (
d301 5
a305 5
	int		update_flag);
static int UC_FindGN_byMIME (
	const char *	UC_MIMEcharset);
static void UCreset_allocated_LYCharSets (void);
static const char ** UC_setup_LYCharSets_repl (
d307 2
a308 2
	unsigned	lowest8);
static int UC_Register_with_LYCharSets (
d310 3
a312 3
	const char *	UC_MIMEcharset,
	const char *	UC_LYNXcharset,
	int		lowest_eightbit);
d314 2
a315 2
static void UCfree_allocated_LYCharSets (void);
static void UCcleanup_mem (void);
d318 1
a318 1
static int default_UChndl = -1;
d320 2
a321 2
static void set_inverse_transl (
	int		i)
d351 2
a352 2
static u16 *set_translate (
	int		m)
d360 2
a361 2
static int UC_valid_UC_charset (
	int		UC_charset_hndl)
d366 4
a369 4
static void UC_con_set_trans (
	int		UC_charset_in_hndl,
	int		Gn,
	int		update_flag)
d372 1
a372 1
    const u16 *p;
d415 2
a416 2
static int hashtable_contents_valid = 0; /* Use ASCII-only mode for bootup*/
static int hashtable_str_contents_valid = 0;
d418 1
a418 1
static u16 **uni_pagedir[32] =
d426 1
a426 1
static char* **uni_pagedir_str[32] =
d434 2
a435 2
static const u16 * UC_current_unitable = NULL;
static struct unimapdesc_str *UC_current_unitable_str = NULL;
d441 2
a442 2
static int unidefault_contents_valid = 0; /* Use ASCII-only mode for bootup*/
static int unidefault_str_contents_valid = 0;
d459 2
a460 2
static const u16 * UC_default_unitable = 0;
static const struct unimapdesc_str *UC_default_unitable_str = 0;
d462 4
a465 4
static int con_insert_unipair (
	u16		unicode,
	u16		fontpos,
	int		fordefault)
d503 4
a506 4
static int con_insert_unipair_str (
	u16		unicode,
	const char *	replace_str,
	int		fordefault)
d510 1
a510 1
    const char **p2;
d536 1
a536 1
	p2 = (const char **)p1[n];
d541 1
a541 1
    p2 = (const char **)p1[n];
d551 2
a552 2
static void con_clear_unimap (
	int		fordefault)
d584 1
a584 1
static void con_clear_unimap_str (int fordefault)
d622 1
a622 1
static void con_set_default_unimap (void)
d625 1
a625 1
    const u16 *p;
d646 1
a646 1
int UCNumCharsets = 0;
d648 4
a651 4
int UCLYhndl_HTFile_for_unspec = -1;
int UCLYhndl_HTFile_for_unrec = -1;
int UCLYhndl_for_unspec = -1;
int UCLYhndl_for_unrec = -1;
d654 4
a657 4
int LATIN1 = -1;        /* UCGetLYhndl_byMIME("iso-8859-1") */
int US_ASCII = -1;      /* UCGetLYhndl_byMIME("us-ascii")   */
int UTF8_handle = -1;   /* UCGetLYhndl_byMIME("utf-8")      */
int TRANSPARENT = -1;   /* UCGetLYhndl_byMIME("x-transparent")  */
d660 3
a662 3
static int UC_con_set_unimap (
	int		UC_charset_out_hndl,
	int		update_flag)
d665 1
a665 1
    const u16 *p;
d699 4
a702 4
static int UC_con_set_unimap_str (
	u16		ct,
	struct unipair_str * list,
	int		fordefault)
d728 3
a730 3
static int conv_uni_to_pc (
	long		ucs,
	int		usedefault)
d788 5
a792 5
static int conv_uni_to_str (
	char*		outbuf,
	int		buflen,
	long		ucs,
	int		usedefault)
d843 1
a843 1
int UCInitialized = 0;
d851 1
a851 1
static void UCconsole_map_init (void)
d860 3
a862 3
int UCTransUniChar (
	long		unicode,
	int		charset_out)
d867 1
a867 1
    const u16 * ut;
d909 6
a914 6
int UCTransUniCharStr (
	char *		outbuf,
	int		buflen,
	long		unicode,
	int		charset_out,
	int		chk_single_flag)
d920 1
a920 1
    const u16 * ut;
d1001 1
a1001 1
static int UC_lastautoGN = 0;
d1003 3
a1005 3
static int UC_MapGN (
	int		UChndl,
	int		update_flag)
d1041 4
a1044 4
int UCTransChar (
	char		ch_in,
	int		charset_in,
	int		charset_out)
d1050 1
a1050 1
    const u16 * ut;
d1112 3
a1114 3
long int UCTransToUni (
	char		ch_in,
	int		charset_in)
d1149 4
a1152 4
int UCReverseTransChar (
	char		ch_out,
	int		charset_in,
	int		charset_out)
d1159 1
a1159 1
    const u16 * ut;
d1209 7
a1215 7
int UCTransCharStr (
	char *		outbuf,
	int		buflen,
	char		ch_in,
	int		charset_in,
	int		charset_out,
	int		chk_single_flag)
d1222 1
a1222 1
    const u16 * ut;
d1330 2
a1331 2
static int UC_FindGN_byMIME (
	const char *	UC_MIMEcharset)
d1343 2
a1344 2
int UCGetRawUniMode_byLYhndl (
	int		i)
d1356 3
a1358 3
static int getLYhndl_byCP (
	const char *	prefix,
	const char *	codepage)
d1379 2
a1380 2
int UCGetLYhndl_byMIME (
	const char *	value)
d1532 1
a1532 1
static const char ** remember_allocated_LYCharSets[MAXCHARSETS];
d1534 1
a1534 1
static void UCreset_allocated_LYCharSets (void)
d1544 1
a1544 1
static void UCfree_allocated_LYCharSets (void)
d1556 3
a1558 3
static const char ** UC_setup_LYCharSets_repl (
	int		UC_charset_in_hndl,
	unsigned	lowest8)
d1560 2
a1561 2
    const char **ISO_Latin1 = LYCharSets[0];
    const char **p;
d1563 1
a1563 1
    const u16 *pp;
d1565 2
a1566 2
    const char *s7;
    const char *s8;
d1636 1
a1636 1
    p = (const char **)prepl;
d1692 1
a1692 1
    return (const char **)prepl;
d1698 5
a1702 5
static int UC_Register_with_LYCharSets (
	int		s,
	const char *	UC_MIMEcharset,
	const char *	UC_LYNXcharset,
	int		lowest_eightbit)
d1705 1
a1705 1
    const char **repl;
d1789 10
a1798 10
void UC_Charset_Setup (
	const char *		UC_MIMEcharset,
	const char *		UC_LYNXcharset,
	const u8 *		unicount,
	const u16 *		unitable,
	int			nnuni,
	struct unimapdesc_str	replacedesc,
	int			lowest_eight,
	int			UC_rawuni,
	int			codepage)
d1857 6
a1862 6
static int UC_NoUctb_Register_with_LYCharSets (
	const char *	UC_MIMEcharset,
	const char *	UC_LYNXcharset,
	int		lowest_eightbit,
	int			UC_rawuni,
	int			codepage)
d1923 7
a1929 7
static void UC_Charset_NoUctb_Setup (
	const char *		UC_MIMEcharset,
	const char *		UC_LYNXcharset,
	int			trydefault,
	int			lowest_eight,
	int			UC_rawuni,
	int			codepage)
d1958 1
a1958 1
static void UCcleanup_mem (void)
d1975 1
a1975 1
static int CpOrdinal (const unsigned long cp, const int other)
d2014 1
a2014 1
void UCInit (void)
d2125 1
a2125 1
int safeUCGetLYhndl_byMIME (const char * value)
d2187 1
a2187 1
static char *nl_langinfo(nl_item item)
d2267 1
a2267 1
void LYFindLocaleCharset (void)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@a31 4
#ifdef EXP_JAPANESEUTF8_SUPPORT
#include <iconv.h>
#endif

d35 1
a35 1
 * Include chartrans tables:
d37 1
a37 1
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)   */
d39 14
a52 14
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)   */
#include <cp1253_uni.h>		/* WinGreek (cp1253)    */
#include <cp1255_uni.h>		/* WinHebrew (cp1255)   */
#include <cp1256_uni.h>		/* WinArabic (cp1256)   */
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)  */
#include <cp437_uni.h>		/* DosLatinUS (cp437)   */
#include <cp737_uni.h>		/* DosGreek (cp737)     */
#include <cp775_uni.h>		/* DosBaltRim (cp775)   */
#include <cp850_uni.h>		/* DosLatin1 (cp850)    */
#include <cp852_uni.h>		/* DosLatin2 (cp852)    */
#include <cp862_uni.h>		/* DosHebrew (cp862)    */
#include <cp864_uni.h>		/* DosArabic (cp864)    */
#include <cp866_uni.h>		/* DosCyrillic (cp866)  */
#include <cp869_uni.h>		/* DosGreek2 (cp869)    */
d54 10
a63 10
#include <dmcs_uni.h>		/* DEC Multinational    */
#include <hp_uni.h>		/* HP Roman8            */
#include <iso01_uni.h>		/* ISO Latin 1          */
#include <iso02_uni.h>		/* ISO Latin 2          */
#include <iso03_uni.h>		/* ISO Latin 3          */
#include <iso04_uni.h>		/* ISO Latin 4          */
#include <iso05_uni.h>		/* ISO 8859-5 Cyrillic  */
#include <iso06_uni.h>		/* ISO 8859-6 Arabic    */
#include <iso07_uni.h>		/* ISO 8859-7 Greek     */
#include <iso08_uni.h>		/* ISO 8859-8 Hebrew    */
d65 9
a73 9
#include <iso10_uni.h>		/* ISO 8859-10          */
#include <iso15_uni.h>		/* ISO 8859-15 (Latin 9) */
#include <koi8r_uni.h>		/* KOI8-R Cyrillic      */
#include <mac_uni.h>		/* Macintosh (8 bit)    */
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic    */
#include <next_uni.h>		/* NeXT character set   */
#include <rfc_suni.h>		/* RFC 1345 w/o Intro   */
/* #include <utf8_uni.h> *//* UNICODE UTF 8        */
#include <viscii_uni.h>		/* Vietnamese (VISCII)  */
d83 1
a83 1
{"iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"};
d85 1
a85 2
int UC_GNhandles[4] =
{-1, -1, -1, -1};
d88 157
a244 158
 * Some of the code below, and some of the comments, are left in for
 * historical reasons.  Not all those tables below are currently
 * really needed (and what with all those hardwired codepoints),
 * but let's keep them around for now.  They may come in handy if we
 * decide to make more extended use of the mechanisms (including e.g.
 * for chars < 127...).  - KW
 */

static u16 translations[][256] =
{
    /*
     * 8-bit Latin-1 mapped to Unicode -- trivial mapping.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * VT100 graphics mapped to Unicode.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,
	0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
	0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0xf800,
	0xf801, 0x2500, 0xf803, 0xf804, 0x251c, 0x2524, 0x2534, 0x252c,
	0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * IBM Codepage 437 mapped to Unicode.
     */
    {
	0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
	0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
	0x25ba, 0x25c4, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
	0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
	0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
	0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
	0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
	0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
	0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
	0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
	0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
	0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
	0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
	0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
	0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
	0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
	0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
	0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
    },
    /*
     * User mapping -- default to codes for direct font mapping.
     */
    {
	0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,
	0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,
	0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,
	0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,
	0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,
	0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,
	0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,
	0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,
	0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,
	0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,
	0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,
	0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,
	0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,
	0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,
	0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,
	0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,
	0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,
	0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,
	0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,
	0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,
	0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,
	0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,
	0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,
	0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,
	0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,
	0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,
	0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,
	0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,
	0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,
	0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,
	0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,
	0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff
    }
d251 2
a252 2
 * The standard kernel character-to-font mappings are not invertible
 * -- this is just a best effort.
d256 1
a256 1
static unsigned char *inv_translate = NULL;
d258 1
a258 25
static unsigned char *inverse_translations[4] =
{NULL, NULL, NULL, NULL};

static void set_inverse_transl(int i);
static u16 *set_translate(int m);
static int UC_valid_UC_charset(int UC_charset_hndl);
static void UC_con_set_trans(int UC_charset_in_hndl, int Gn, int update_flag);
static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault);
static int con_insert_unipair_str(u16 unicode, const char *replace_str, int fordefault);
static void con_clear_unimap(int fordefault);
static void con_clear_unimap_str(int fordefault);
static void con_set_default_unimap(void);
static int UC_con_set_unimap(int UC_charset_out_hndl, int update_flag);
static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list, int fordefault);
static int conv_uni_to_pc(long ucs, int usedefault);
static int conv_uni_to_str(char *outbuf, int buflen, long ucs, int usedefault);
static void UCconsole_map_init(void);
static int UC_MapGN(int UChndl, int update_flag);
static int UC_FindGN_byMIME(const char *UC_MIMEcharset);
static void UCreset_allocated_LYCharSets(void);
static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl, unsigned lowest8);
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit);
d260 53
d314 2
a315 2
static void UCfree_allocated_LYCharSets(void);
static void UCcleanup_mem(void);
d320 2
a321 1
static void set_inverse_transl(int i)
d329 1
a329 1
	 * Slightly messy to avoid calling kmalloc too early.
d333 1
a333 1
				       (unsigned char *) malloc(MAX_GLYPH));
d344 1
a344 1
	     * Prefer '-' above SHY etc.
d351 2
a352 1
static u16 *set_translate(int m)
d354 4
a357 4
    if (!inverse_translations[m])
	set_inverse_transl(m);
    inv_translate = inverse_translations[m];
    return translations[m];
d360 2
a361 1
static int UC_valid_UC_charset(int UC_charset_hndl)
d363 1
a363 1
    return (UC_charset_hndl >= 0 && UC_charset_hndl < UCNumCharsets);
d366 4
a369 3
static void UC_con_set_trans(int UC_charset_in_hndl,
			     int Gn,
			     int update_flag)
d377 1
a377 1
		UC_charset_in_hndl));
d383 1
a383 1
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
d387 1
a387 1
     * The font is always 256 characters - so far.
d402 1
a402 1
	set_inverse_transl(Gn);	/* Update inverse translation for this one */
d415 1
a415 1
static int hashtable_contents_valid = 0;	/* Use ASCII-only mode for bootup */
d420 4
a423 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d426 1
a426 1
static char ***uni_pagedir_str[32] =
d428 4
a431 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d434 1
a434 1
static const u16 *UC_current_unitable = NULL;
d438 2
a439 2
 * Keep a second set of structures for the translation designated
 * as "default" - kw
d441 1
a441 1
static int unidefault_contents_valid = 0;	/* Use ASCII-only mode for bootup */
d446 4
a449 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d451 1
a451 1
static char ***unidefault_pagedir_str[32] =
d453 4
a456 4
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d459 1
a459 1
static const u16 *UC_default_unitable = 0;
d462 4
a465 1
static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault)
d470 1
a470 1
    if (fordefault)
d475 1
a475 1
	p1 = (u16 * *)malloc(32 * sizeof(u16 *));
d480 1
a480 1
	if (!p1)
d489 1
a489 1
	p2 = p1[n] = (u16 *) malloc(64 * sizeof(u16));
d494 1
a494 1
	    p2[i] = 0xffff;	/* No glyph for this character (yet) */
d503 4
a506 2
static int con_insert_unipair_str(u16 unicode, const char *replace_str,
				  int fordefault)
d512 1
a512 1
    if (fordefault)
d517 1
a517 2
	p1 = (char ***) malloc(32 * sizeof(char **));

d522 1
a522 1
	if (!p1)
d532 1
a532 2
	p1[n] = (char **) malloc(64 * sizeof(char *));

d536 1
a536 1
	p2 = (const char **) p1[n];
d541 1
a541 1
    p2 = (const char **) p1[n];
d549 1
a549 1
 * ui arg was a leftover, deleted.  - KW
d551 2
a552 1
static void con_clear_unimap(int fordefault)
d584 1
a584 1
static void con_clear_unimap_str(int fordefault)
d586 2
a587 2
    int i, j;
    char ***p1;
d589 5
a593 7
    if (fordefault) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = unidefault_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
d595 1
a595 1
	    unidefault_pagedir_str[i] = NULL;
d597 2
d600 6
a605 8
	unidefault_str_contents_valid = 1;	/* ??? probably no use... */
    } else {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
d607 1
a607 1
	    uni_pagedir_str[i] = NULL;
d609 2
d612 2
a613 2
	hashtable_str_contents_valid = 1;	/* ??? probably no use... */
    }
d617 4
a620 4
 * Loads the unimap for the hardware font, as defined in uni_hash.tbl.
 * The representation used was the most compact I could come up
 * with.  This routine is executed at sys_setup time, and when the
 * PIO_FONTRESET ioctl is called.
d622 1
a622 1
static void con_set_default_unimap(void)
d628 1
a628 1
     * The default font is always 256 characters.
d635 1
a635 1
	    con_insert_unipair(*(p++), (u16) i, 1);
d653 5
a657 5
/* easy to type, will initialize later */
int LATIN1 = -1;		/* UCGetLYhndl_byMIME("iso-8859-1") */
int US_ASCII = -1;		/* UCGetLYhndl_byMIME("us-ascii")   */
int UTF8_handle = -1;		/* UCGetLYhndl_byMIME("utf-8")      */
int TRANSPARENT = -1;		/* UCGetLYhndl_byMIME("x-transparent")  */
d659 4
a662 2
static int UC_con_set_unimap(int UC_charset_out_hndl,
			     int update_flag)
d669 1
a669 1
		UC_charset_out_hndl));
d674 2
a675 2
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
	return update_flag;	/* nothing to be done */
d680 1
a680 1
     * The font is always 256 characters - so far.
d686 1
a686 1
	    con_insert_unipair(*(p++), (u16) i, 0);
d699 4
a702 2
static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list,
				 int fordefault)
d716 1
a716 1
     * No inverse translations for replacement strings!
d728 3
a730 2
static int conv_uni_to_pc(long ucs,
			  int usedefault)
d736 1
a736 1
     * Only 16-bit codes supported at this time.
d740 1
a740 1
	 * U+FFFD:  REPLACEMENT CHARACTER.
d745 1
a745 1
	 * Not a printable character.
d750 1
a750 1
	 * Zero-width space.
d755 4
a758 4
	 * UNI_DIRECT_BASE indicates the start of the region in the
	 * User Zone which always has a 1:1 mapping to the currently
	 * loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 * of the region.
d780 1
a780 1
     * Not found.
d786 1
a786 1
 * Note:  contents of outbuf is not changes for negative return value!
d788 5
a792 4
static int conv_uni_to_str(char *outbuf,
			   int buflen,
			   long ucs,
			   int usedefault)
d798 1
a798 1
     * Only 16-bit codes supported at this time.
d802 1
a802 1
	 * U+FFFD:  REPLACEMENT CHARACTER.
d805 3
a807 3
	/*
	 * Maybe the following two cases should be allowed here??  - KW
	 */
d810 1
a810 1
	 * Not a printable character.
d815 1
a815 1
	 * Zero-width space.
d833 2
a834 2
	strncpy(outbuf, h, (size_t) (buflen - 1));
	return 1;		/* ok ! */
d838 1
a838 1
     * Not found.
d846 1
a846 1
 * [ original comment:  - KW ]
d851 1
a851 1
static void UCconsole_map_init(void)
d858 1
a858 1
 * OK now, finally, some stuff that is more specifically for Lynx:  - KW
d860 3
a862 2
int UCTransUniChar(long unicode,
		   int charset_out)
d867 1
a867 1
    const u16 *ut;
d871 1
a871 1
	    return (unicode < 128) ? (int) unicode : LYCharSet_UC[charset_out].codepage;
d907 1
a907 1
 * Returns string length, or negative value for error.
d909 6
a914 5
int UCTransUniCharStr(char *outbuf,
		      int buflen,
		      long unicode,
		      int charset_out,
		      int chk_single_flag)
d919 2
a920 2
    struct unimapdesc_str *repl;
    const u16 *ut;
d948 1
a948 1
	    outbuf[0] = (char) src;
d956 1
a956 1
	if (repl != UC_current_unitable_str) {
d968 1
a968 1
	    outbuf[0] = (char) src;
a973 29
#ifdef EXP_JAPANESEUTF8_SUPPORT
	if ((strcmp(LYCharSet_UC[charset_out].MIMEname, "shift_jis") == 0) ||
	    (strcmp(LYCharSet_UC[charset_out].MIMEname, "euc-jp") == 0)) {
	    iconv_t cd;
	    char str[3], *pin, *pout;
	    size_t inleft, outleft;

	    str[0] = unicode >> 8;
	    str[1] = unicode & 0xFF;
	    str[2] = 0;
	    pin = str;
	    inleft = 2;
	    pout = outbuf, outleft = buflen;
	    cd = iconv_open(LYCharSet_UC[charset_out].MIMEname,
			    "UTF-16BE//TRANSLIT");
	    rc = iconv(cd, &pin, &inleft, &pout, &outleft);
	    iconv_close(cd);
	    if ((pout - outbuf) == 3) {
		CTRACE((tfp,
			"It seems to be a JIS X 0201 code(%ld). Not supported.\n", unicode));
		pin = str;
		inleft = 2;
		pout = outbuf, outleft = buflen;
	    } else if (rc >= 0) {
		*pout = '\0';
		return (strlen(outbuf));
	    }
	}
#endif
d992 1
a992 1
	    outbuf[0] = (char) rc;
d1003 3
a1005 2
static int UC_MapGN(int UChndl,
		    int update_flag)
a1007 1

d1036 2
a1037 2
	    Gn, UChndl, UCInfo[UChndl].MIMEname));
    UC_con_set_trans(UChndl, Gn, update_flag);
d1041 4
a1044 3
int UCTransChar(char ch_in,
		int charset_in,
		int charset_out)
d1050 1
a1050 1
    const u16 *ut;
d1074 1
a1074 1
	Gn = UC_MapGN(UChndl_in, 0);
d1112 7
a1118 6
long int UCTransToUni(char ch_in,
		      int charset_in)
{
    int unicode, Gn;
    unsigned char ch_iu;
    int UChndl_in;
d1120 1
a1120 1
    ch_iu = UCH(ch_in);
d1132 1
a1132 1
	 * Don't translate C0 chars except for specific charsets.
d1140 1
a1140 1
	Gn = UC_MapGN(UChndl_in, 1);
d1143 2
a1144 2
    UC_translate = set_translate(Gn);
    unicode = UC_translate[UCH(ch_in)];
d1146 1
a1146 1
    return unicode;
d1149 4
a1152 3
int UCReverseTransChar(char ch_out,
		       int charset_in,
		       int charset_out)
d1159 1
a1159 1
    const u16 *ut;
d1185 4
a1188 4
	 * Try to use the inverse table if charset_out is not equivalent
	 * to using just the default table.  If it is, it should have
	 * just ASCII chars and trying to back-translate those should
	 * not give anything but themselves.  - kw
d1193 1
a1193 1
		Gn = UC_MapGN(UChndl_in, 1);
d1207 1
a1207 1
 * Returns string length, or negative value for error.
d1209 7
a1215 6
int UCTransCharStr(char *outbuf,
		   int buflen,
		   char ch_in,
		   int charset_in,
		   int charset_out,
		   int chk_single_flag)
d1221 2
a1222 2
    struct unimapdesc_str *repl;
    const u16 *ut;
d1262 1
a1262 2
		if (upd)
		    set_inverse_transl(Gn);
d1274 1
a1274 1
	    outbuf[0] = (char) src;
d1294 1
a1294 1
	    outbuf[0] = (char) src;
d1318 1
a1318 1
	    outbuf[0] = (char) rc;
d1330 2
a1331 1
static int UC_FindGN_byMIME(const char *UC_MIMEcharset)
d1333 1
a1333 1
    int i;
d1336 2
a1337 2
	if (!strcmp(UC_MIMEcharset, UC_GNsetMIMEnames[i])) {
	    return i;
d1340 1
a1340 1
    return -1;
d1343 2
a1344 1
int UCGetRawUniMode_byLYhndl(int i)
d1348 1
a1348 1
    return LYCharSet_UC[i].enc;
d1356 3
a1358 2
static int getLYhndl_byCP(const char *prefix,
			  const char *codepage)
a1364 1

d1375 3
a1377 3
 * Get Lynx internal charset handler from MIME name,
 * return -1 if we got NULL or did not recognize value.
 * According to RFC, MIME headers should match case-insensitively.
d1379 2
a1380 1
int UCGetLYhndl_byMIME(const char *value)
d1386 1
a1386 2
	CTRACE((tfp,
		"UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
d1394 1
a1394 1
	    !strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
d1485 1
a1485 1
	if ((LYhndl = getLYhndl_byCP("cp", value + 3)) >= 0)
d1502 2
a1503 2
    if (!strcasecomp(value, "koi-8")) {		/* accentsoft bugosity */
	return UCGetLYhndl_byMIME("koi8-r");
d1509 1
a1509 1
    return -1;			/* returns -1 if no charset found by that MIME name */
d1513 4
a1516 4
 * Function UC_setup_LYCharSets_repl() tries to set up a subtable in
 * LYCharSets[] appropriate for this new charset, for compatibility with the
 * "old method".  Maybe not nice (maybe not even necessary any more), but it
 * works (as far as it goes..).
d1518 9
a1526 8
 * We try to be conservative and only allocate new memory for this if needed. 
 * If not needed, just point to SevenBitApproximations[i].  [Could do the same
 * for ISO_Latin1[] if it's identical to that, but would make it even *more*
 * messy than it already is...] This the only function in this file that knows,
 * or cares, about the HTMLDTD or details of LYCharSets[] subtables (and
 * therefore somewhat violates the idea that this file should be independent of
 * those).  As in other places, we rely on ISO_Latin1 being the *first* table
 * in LYCharSets.  - KW
d1530 1
a1530 1
 * We need to remember which ones were allocated and which are static.
d1532 1
a1532 1
static const char **remember_allocated_LYCharSets[MAXCHARSETS];
d1534 1
a1534 1
static void UCreset_allocated_LYCharSets(void)
d1544 1
a1544 1
static void UCfree_allocated_LYCharSets(void)
d1556 3
a1558 2
static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl,
					     unsigned lowest8)
d1573 1
a1573 1
     * Create a temporary table for reverse lookup of latin1 codes:
d1575 1
a1575 2
    tp = (char **) malloc(96 * sizeof(char *));

d1580 1
a1580 1
    ti = (u8 *) malloc(96 * sizeof(u8));
d1591 3
a1593 3
     * Determine if we have any mapping of a Unicode in the range 160-255
     * to an allowed code point > 0x80 in our new charset...
     * Store any mappings found in ti[].
d1599 1
a1599 1
		    ti[k - 160] = UCH(i);
d1606 2
a1607 1
    } {
d1612 3
a1614 3
	 * Determine if we have any mapping of a Unicode in the range
	 * 160-255 to a replacement string for our new charset...
	 * Store any mappings found in tp[].
d1620 1
a1620 1
		tp[k - 160] = (char *) list->replace_str;
d1626 4
a1629 6
     * Now allocate a new table compatible with LYCharSets[]
     * and with the HTMLDTD for entities.
     * We don't know yet whether we'll keep it around.
     */
    prepl = (char **) malloc(HTML_dtd.number_of_entities * sizeof(char *));

d1636 1
a1636 1
    p = (const char **) prepl;
d1640 3
a1642 3
	 * For each of those entities, we check what the "old method"
	 * ISO_Latin1[] mapping does with them.  If it is nothing we
	 * want to use, just point to the SevenBitApproximations[] string.
d1649 2
a1650 2
	     * We have an entity that is mapped to
	     * one valid eightbit latin1 char.
d1654 1
a1654 1
		  s7[1] == '\0')) {
d1656 3
a1658 3
		 * ...which in turn is mapped, by our "new method",
		 * to another valid eightbit char for this new
		 * charset:  either to itself...
d1664 4
a1667 4
		     * make those 1-char strings
		     * into HTAtoms, so they will be cleaned up
		     * at exit...  all for the sake of preventing
		     * memory leaks, sigh.
d1678 2
a1679 2
		 * ...or which is mapped, by our "new method",
		 * to a replacement string for this new charset.
d1692 1
a1692 1
    return (const char **) prepl;
d1696 1
a1696 1
 * "New method" meets "Old method" ...
d1698 5
a1702 4
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit)
d1710 2
a1711 2
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
d1714 1
a1714 1
	    LYNumCharsets = i + 1;
d1719 1
a1719 1
     * Search by MIME name, (LYchar_set_names may differ...)
d1731 2
a1732 3
	    CTRACE((tfp,
		    "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		    UC_MIMEcharset, UC_LYNXcharset));
d1736 1
a1736 1
	 * Add to LYCharSets.c lists.
d1739 1
a1739 1
	LYNumCharsets++;
d1743 1
a1743 1
	 * Hmm, try to be conservative here.
d1746 1
a1746 1
	LYchar_set_names[LYhndl + 1] = NULL;
d1748 2
a1749 2
	 * Terminating NULL may be looked for by Lynx code.
	 */
d1755 1
a1755 1
     * Can we just copy the pointer?  Hope so...
d1762 3
a1764 3
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
d1773 1
a1773 1
	repl = UC_setup_LYCharSets_repl(s, UCInfo[s].lowest_eight);
d1777 1
a1777 1
	     * Remember to FREE at exit.
d1786 1
a1786 1
 * This only sets up the structure - no initialization of the tables
d1789 10
a1798 9
void UC_Charset_Setup(const char *UC_MIMEcharset,
		      const char *UC_LYNXcharset,
		      const u8 * unicount,
		      const u16 * unitable,
		      int nnuni,
		      struct unimapdesc_str replacedesc,
		      int lowest_eight,
		      int UC_rawuni,
		      int codepage)
d1804 1
a1804 1
     * Get (new?) slot.
d1817 1
a1817 1
		    UC_MIMEcharset, UC_LYNXcharset));
d1836 1
a1836 1
	lowest_eight = 128;	/* cheat here */
d1851 12
a1862 12
 * UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 * Alternative functions for adding character set info to the lists
 * kept in LYCharSets.c.
 *
 * These are for character sets without any real tables of their own.
 * We don't keep an entry in UCinfo[] for them.
 */
static int UC_NoUctb_Register_with_LYCharSets(const char *UC_MIMEcharset,
					      const char *UC_LYNXcharset,
					      int lowest_eightbit,
					      int UC_rawuni,
					      int codepage)
d1868 2
a1869 2
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
d1872 1
a1872 1
	    LYNumCharsets = i + 1;
d1877 2
a1878 2
     * Search by MIME name, (LYchar_set_names may differ...)
     * ignore if already present!
d1889 2
a1890 3
	CTRACE((tfp,
		"UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		UC_MIMEcharset, UC_LYNXcharset));
d1894 2
a1895 2
     * Add to LYCharSets.c lists.
     */
d1897 1
a1897 1
    LYNumCharsets++;
d1901 1
a1901 1
    LYchar_set_names[LYhndl + 1] = NULL;
d1903 1
a1903 1
     * Terminating NULL may be looked for by Lynx code.
d1906 1
a1906 1
    LYCharSet_UC[LYhndl].UChndl = -1;	/* no corresponding UChndl ! */
d1912 3
a1914 3
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
d1921 1
a1921 1
 * A wrapper for the previous function.
d1923 7
a1929 6
static void UC_Charset_NoUctb_Setup(const char *UC_MIMEcharset,
				    const char *UC_LYNXcharset,
				    int trydefault,
				    int lowest_eight,
				    int UC_rawuni,
				    int codepage)
d1934 1
a1934 1
     * Ignore completely if already in slot.
d1942 1
a1942 1
	lowest_eight = 128;	/* cheat here */
d1944 3
a1946 3
     * lookup, not even default' when negative.  The value will
     * be returned immediately by UCTrans* functions.
     */
d1948 1
a1948 1
	codepage = -12;		/* if not already set; any negative should do. */
d1958 1
a1958 1
static void UCcleanup_mem(void)
d1975 1
a1975 1
static int CpOrdinal(const unsigned long cp, const int other)
d2011 1
a2011 1
#  endif			/* __EMX__ */
d2014 1
a2014 1
void UCInit(void)
d2023 8
a2030 7
    /*
     * The order of charset names visible in Lynx Options menu correspond to
     * the order of lines below, except the first two described in LYCharSet.c
     *
     * Entries whose comment is marked with *** are declared in UCdomap.h,
     * others are based on the included tables - UCdomap.c, near the top.
     */
d2032 10
a2041 10
    UC_CHARSET_SETUP_iso_8859_1;	/* ISO Latin 1          */
    UC_CHARSET_SETUP_iso_8859_15;	/* ISO 8859-15 (Latin 9) */
    UC_CHARSET_SETUP_cp850;	/* DosLatin1 (cp850)    */
    UC_CHARSET_SETUP_windows_1252;	/* WinLatin1 (cp1252)   */
    UC_CHARSET_SETUP_cp437;	/* DosLatinUS (cp437)   */

    UC_CHARSET_SETUP_dec_mcs;	/* DEC Multinational    */
    UC_CHARSET_SETUP_macintosh;	/* Macintosh (8 bit)    */
    UC_CHARSET_SETUP_next;	/* NeXT character set   */
    UC_CHARSET_SETUP_hp_roman8;	/* HP Roman8            */
d2049 2
a2050 2
    UC_CHARSET_SETUP_viscii;	/* Vietnamese (VISCII)  */
    UC_CHARSET_SETUP;		/* us-ascii *//* 7 bit approximations */
d2054 23
a2076 23
    UC_CHARSET_SETUP_iso_8859_2;	/* ISO Latin 2          */
    UC_CHARSET_SETUP_cp852;	/* DosLatin2 (cp852)    */
    UC_CHARSET_SETUP_windows_1250;	/* WinLatin2 (cp1250)   */
    UC_CHARSET_SETUP_iso_8859_3;	/* ISO Latin 3          */
    UC_CHARSET_SETUP_iso_8859_4;	/* ISO Latin 4          */
    UC_CHARSET_SETUP_cp775;	/* DosBaltRim (cp775)   */
    UC_CHARSET_SETUP_windows_1257;	/* WinBaltRim (cp1257)  */
    UC_CHARSET_SETUP_iso_8859_5;	/* ISO 8859-5 Cyrillic  */
    UC_CHARSET_SETUP_cp866;	/* DosCyrillic (cp866)  */
    UC_CHARSET_SETUP_windows_1251;	/* WinCyrillic (cp1251) */
    UC_CHARSET_SETUP_koi8_r;	/* KOI8-R Cyrillic      */
    UC_CHARSET_SETUP_iso_8859_6;	/* ISO 8869-6 Arabic    */
    UC_CHARSET_SETUP_cp864;	/* DosArabic (cp864)    */
    UC_CHARSET_SETUP_windows_1256;	/* WinArabic (cp1256)   */
    UC_CHARSET_SETUP_iso_8859_7;	/* ISO 8859-7 Greek     */
    UC_CHARSET_SETUP_cp737;	/* DosGreek (cp737)     */
    UC_CHARSET_SETUP_cp869;	/* DosGreek2 (cp869)    */
    UC_CHARSET_SETUP_windows_1253;	/* WinGreek (cp1253)    */
    UC_CHARSET_SETUP_iso_8859_8;	/* ISO 8859-8 Hebrew    */
    UC_CHARSET_SETUP_cp862;	/* DosHebrew (cp862)    */
    UC_CHARSET_SETUP_windows_1255;	/* WinHebrew (cp1255)   */
    UC_CHARSET_SETUP_iso_8859_9;	/* ISO 8859-9 (Latin 5) */
    UC_CHARSET_SETUP_iso_8859_10;	/* ISO 8859-10          */
d2079 5
a2083 5
    UC_CHARSET_SETUP_mnemonic_ascii_0;	/* RFC 1345 w/o Intro   */
    UC_CHARSET_SETUP_mnemonic;	/* RFC 1345 Mnemonic    */
    UC_CHARSET_SETUP_cp866u;	/* Ukrainian Cyrillic (866) */
    UC_CHARSET_SETUP_koi8_u;	/* Ukrainian Cyrillic (koi8-u) */
    UC_CHARSET_SETUP_ptcp154;	/* Cyrillic-Asian (PT154) */
d2110 2
a2111 2
 * To add synonyms for any charset name check function UCGetLYhndl_byMIME in
 * this file.
d2115 1
a2115 1
    LATIN1 = UCGetLYhndl_byMIME("iso-8859-1");
d2122 2
a2123 2
 * Safe variant of UCGetLYhndl_byMIME, with blind recovery from typo in user
 * input:  lynx.cfg, userdefs.h, command line switches.
d2125 1
a2125 1
int safeUCGetLYhndl_byMIME(const char *value)
d2129 2
a2130 2
    if (i == -1) {		/* was user's typo or not yet recognized value */
	i = LATIN1;		/* error recovery? */
d2134 1
a2134 1
    return (i);
a2176 1

d2179 3
a2181 3
#define C_CODESET "US-ASCII"	/* Return this as the encoding of the
				 * C/POSIX locale. Could as well one day
				 * become "UTF-8". */
d2189 1
a2189 1
    char *l, *p;
d2191 2
a2192 2
    if (item != CODESET)
	return NULL;
d2194 55
a2248 83
    if (((l = getenv("LC_ALL")) && *l) ||
	((l = getenv("LC_CTYPE")) && *l) ||
	((l = getenv("LANG")) && *l)) {
	/* check standardized locales */
	if (!strcmp(l, "C") || !strcmp(l, "POSIX"))
	    return C_CODESET;
	/* check for encoding name fragment */
	if (strstr(l, "UTF") || strstr(l, "utf"))
	    return "UTF-8";
	if ((p = strstr(l, "8859-"))) {
	    memcpy(buf, "ISO-8859-\0\0", 12);
	    p += 5;
	    if (digit(*p)) {
		buf[9] = *p++;
		if (digit(*p))
		    buf[10] = *p++;
		return buf;
	    }
	}
	if (strstr(l, "KOI8-R"))
	    return "KOI8-R";
	if (strstr(l, "KOI8-U"))
	    return "KOI8-U";
	if (strstr(l, "620"))
	    return "TIS-620";
	if (strstr(l, "2312"))
	    return "GB2312";
	if (strstr(l, "HKSCS"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "Big5") || strstr(l, "BIG5"))
	    return "Big5";
	if (strstr(l, "GBK"))
	    return "GBK";	/* no MIME charset */
	if (strstr(l, "18030"))
	    return "GB18030";	/* no MIME charset */
	if (strstr(l, "Shift_JIS") || strstr(l, "SJIS"))
	    return "Shift_JIS";
	/* check for conclusive modifier */
	if (strstr(l, "euro"))
	    return "ISO-8859-15";
	/* check for language (and perhaps country) codes */
	if (strstr(l, "zh_TW"))
	    return "Big5";
	if (strstr(l, "zh_HK"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "zh"))
	    return "GB2312";
	if (strstr(l, "ja"))
	    return "EUC-JP";
	if (strstr(l, "ko"))
	    return "EUC-KR";
	if (strstr(l, "ru"))
	    return "KOI8-R";
	if (strstr(l, "uk"))
	    return "KOI8-U";
	if (strstr(l, "pl") || strstr(l, "hr") ||
	    strstr(l, "hu") || strstr(l, "cs") ||
	    strstr(l, "sk") || strstr(l, "sl"))
	    return "ISO-8859-2";
	if (strstr(l, "eo") || strstr(l, "mt"))
	    return "ISO-8859-3";
	if (strstr(l, "el"))
	    return "ISO-8859-7";
	if (strstr(l, "he"))
	    return "ISO-8859-8";
	if (strstr(l, "tr"))
	    return "ISO-8859-9";
	if (strstr(l, "th"))
	    return "TIS-620";	/* or ISO-8859-11 */
	if (strstr(l, "lt"))
	    return "ISO-8859-13";
	if (strstr(l, "cy"))
	    return "ISO-8859-14";
	if (strstr(l, "ro"))
	    return "ISO-8859-2";	/* or ISO-8859-16 */
	if (strstr(l, "am") || strstr(l, "vi"))
	    return "UTF-8";
	/* Send me further rules if you like, but don't forget that we are
	 * *only* interested in locale naming conventions on platforms
	 * that do not already provide an nl_langinfo(CODESET) implementation. */
	return "ISO-8859-1";	/* should perhaps be "UTF-8" instead */
    }
    return C_CODESET;
d2267 1
a2267 1
void LYFindLocaleCharset(void)
a2271 1

a2273 1

@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d23 1
d34 7
a40 7
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)	*/
#include <cp1251_uni.h>		/* WinCyrillic (cp1251) */
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)	*/
#include <cp1253_uni.h>		/* WinGreek (cp1253)	*/
#include <cp1255_uni.h>		/* WinHebrew (cp1255)	*/
#include <cp1256_uni.h>		/* WinArabic (cp1256)	*/
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)	*/
d66 1
a66 1
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic	*/
d70 1
a70 1
#include <viscii_uni.h>		/* Vietnamese (VISCII)	*/
d73 3
a75 4

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
int auto_display_charset = -1;
#endif
d254 7
d279 5
d292 6
d354 1
a354 1
	    q[glyph] = UCH(j);
d368 99
d483 2
a484 2
	CTRACE((tfp, "UC_con_set_trans: Invalid charset handle %d.\n",
		    UC_charset_in_hndl));
d495 2
d590 1
a590 1
	    return -1;
d600 1
a600 1
	    return -1;
d614 1
a614 1
	CONST char *,	replace_str,
d632 1
a632 1
	    return -1;
d643 1
a643 1
	    return -1;
d725 21
d759 1
d766 1
a766 1
	    con_insert_unipair(*(p++), (u16)i, 1);
d770 6
a793 1
PUBLIC int TRANSPARENT = -1;   /* UCGetLYhndl_byMIME("x-transparent")  */
d804 2
a805 2
	CTRACE((tfp, "UC_con_set_unimap: Invalid charset handle %d.\n",
		    UC_charset_out_hndl));
d817 1
d821 1
a821 1
    for (i = 0; i < 256; i++) {
d823 1
a823 1
	    con_insert_unipair(*(p++), (u16)i, 0);
d865 33
d988 10
a1048 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return (unicode < 128) ? (int)unicode : LYCharSet_UC[charset_out].codepage;
d1087 1
a1087 1
	char *,		outbuf,
a1102 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1123 1
a1123 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1142 1
a1142 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1165 1
a1165 2
	    outbuf[0] = (char)rc;
	    outbuf[1] = '\0';
d1207 2
a1208 2
    CTRACE((tfp, "UC_MapGN: Using %d <- %d (%s)\n",
		Gn, UChndl, UCInfo[UChndl].MIMEname));
d1227 1
a1227 1
	return UCH(ch_in);
a1233 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1264 1
a1264 1
    unicode = UC_translate[UCH(ch_in)];
d1290 1
a1290 1
  ch_iu = UCH(ch_in);
d1294 1
a1294 1
    if (UCH(ch_in) < 128 && UCH(ch_in) >= 32)
d1299 1
a1299 1
    if (UCH(ch_in) < 32 &&
d1314 1
a1314 1
  unicode = UC_translate[UCH(ch_in)];
d1325 1
a1325 1
    int rc = -1;
d1328 1
a1328 1
    int i_ch = UCH(ch_out);
d1333 1
a1333 1
	return UCH(ch_out);
a1343 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1360 7
a1366 1
	    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
d1368 1
a1368 3
	    }
	    UC_translate = set_translate(Gn);
	    if (inv_translate)
d1370 3
a1372 2
	    if (rc >= 32) {
		return rc;
d1383 1
a1383 1
	char *,		outbuf,
a1413 2
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
d1427 1
a1427 1
    unicode = UC_translate[UCH(ch_in)];
d1445 1
a1445 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1464 1
a1464 2
	    outbuf[0] = (char)src;
	    outbuf[1] = '\0';
d1487 1
a1487 2
	    outbuf[0] = (char)rc;
	    outbuf[1] = '\0';
a1519 23
 * Construct a new charset name, given prefix and codepage.  This introduces
 * potentially unchecked recursion into UCGetLYhntl_byMIME if neither the "cp"
 * nor "windows-" prefixes are configured, so we check it here.
 */
PRIVATE int getLYhndl_byCP ARGS2(
	CONST char *,	prefix,
	CONST char *,	codepage)
{
    static int nested;
    int result = -1;

    if (!nested++) {
	char *cptmp = NULL;
	StrAllocCopy(cptmp, prefix);
	StrAllocCat(cptmp, codepage);
	result = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
    }
    nested--;
    return result;
}

/*
d1531 1
a1531 1
	CTRACE((tfp, "UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
a1546 1
#if !NO_CHARSET_utf_8
d1554 2
a1555 3
#endif
#if !NO_CHARSET_euc_jp
    if (!strcasecomp(value, "x-euc-jp")) {
d1558 1
a1558 4
#endif
#if !NO_CHARSET_shift_jis
    if ((!strcasecomp(value, "x-shift-jis")) ||
	(!strcasecomp(value, "x-sjis"))) {
a1560 2
#endif
#if !NO_CHARSET_euc_kr
a1563 2
#endif
#if !NO_CHARSET_euc_cn
a1568 2
#endif
#if !NO_CHARSET_big5
a1571 2
#endif
#if !NO_CHARSET_macintosh
a1575 2
#endif
#if !NO_CHARSET_next
a1580 2
#endif
#if !NO_CHARSET_windows_1252
a1591 2
#endif
#if !NO_CHARSET_windows_1250
a1600 1
#endif
d1603 3
a1605 3
	isdigit(UCH(value[3])) &&
	isdigit(UCH(value[4])) &&
	isdigit(UCH(value[5]))) {
d1610 7
a1616 1
	if ((LYhndl = getLYhndl_byCP("cp", value+3)) >= 0)
d1618 1
d1622 5
a1626 1
	return getLYhndl_byCP("windows-", value + 3);
d1629 3
a1631 3
	isdigit(UCH(value[8])) &&
	isdigit(UCH(value[9])) &&
	isdigit(UCH(value[10]))) {
d1635 8
a1642 1
	return getLYhndl_byCP("cp", value + 8);
a1643 1
#if !NO_CHARSET_koi8_r
a1646 1
#endif
d1649 1
a1649 1
    CTRACE((tfp, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value));
d1705 1
a1705 1
    char **tp;
d1716 1
a1716 1
    tp = (char **)malloc(96 * sizeof(char *));
d1740 1
a1740 1
		   ti[k-160] = UCH(i);
d1761 1
a1761 1
		tp[k-160] = (char *)list->replace_str;
d1788 1
a1788 1
	if (s8 && UCH(*s8) >= 160 && strlen(s8) == 1) {
d1793 2
a1794 2
	    if (ti[UCH(*s8) - 160] >= UCH(lowest8) &&
		!(s7[0] == ti[UCH(*s8) - 160] &&
d1801 1
a1801 1
		if (ti[UCH(*s8) - 160] == UCH(*s8)) {
d1805 15
a1819 1
		     *	make those 1-char strings
d1826 1
a1826 1
		    dummy[0] = ti[UCH(*s8) - 160];
d1828 1
d1831 2
a1832 2
	    } else if (tp[UCH(*s8) - 160] &&
		       strcmp(s7, tp[UCH(*s8) - 160])) {
d1837 1
a1837 1
		*p = tp[UCH(*s8) - 160];
d1887 2
a1888 2
	    CTRACE((tfp, "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset));
d1972 2
a1973 2
	    CTRACE((tfp, "UC_Charset_Setup: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset));
a2005 107
/*
 *  UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 *  Alternative functions for adding character set info to the lists
 *  kept in LYCharSets.c.
 *  These are for character sets without any real tables of their own.
 *  We don't keep an entry in UCinfo[] for them.
 */
PRIVATE int UC_NoUctb_Register_with_LYCharSets ARGS5(
	CONST char *,	UC_MIMEcharset,
	CONST char *,	UC_LYNXcharset,
	int,		lowest_eightbit,
	int,			UC_rawuni,
	int,			codepage)
{
    int i, LYhndl = -1;

    if (LYNumCharsets == 0) {
	/*
	 *  Initialize here; so whoever changes
	 *  LYCharSets.c doesn't have to count...
	 */
	for (i = 0; (i < MAXCHARSETS) && LYchar_set_names[i]; i++) {
	    LYNumCharsets = i+1;
	}
    }

    /*
     *	Search by MIME name, (LYchar_set_names may differ...)
     *  ignore if already present!
     */
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    return -1;
	}
    }

    /* not found */
    if (LYNumCharsets >= MAXCHARSETS) {
	CTRACE((tfp, "UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
	       UC_MIMEcharset, UC_LYNXcharset));
	return -1;
    }
    /*
	 *  Add to LYCharSets.c lists.
	 */
    LYhndl = LYNumCharsets;
    LYNumCharsets ++;
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
    LYCharSets[LYhndl] = SevenBitApproximations;
    LYchar_set_names[LYhndl] = UC_LYNXcharset;
    LYchar_set_names[LYhndl+1] = NULL;
    /*
     *  Terminating NULL may be looked for by Lynx code.
     */

    LYCharSet_UC[LYhndl].UChndl = -1; /* no corresponding UChndl ! */
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UC_rawuni;
    LYCharSet_UC[LYhndl].codepage = codepage;

    /*
     *	@@@@@@ We really SHOULD get more info from the table files,
     *	and set relevant flags in the LYCharSet_UC[] entry with
     *	that info...  For now, let's try it without. - KW
     */

    return LYhndl;
}

/*
 *  A wrapper for the previous function.
 */
PRIVATE void UC_Charset_NoUctb_Setup ARGS6(
	CONST char *,		UC_MIMEcharset,
	CONST char *,		UC_LYNXcharset,
	int,			trydefault,
	int,			lowest_eight,
	int,			UC_rawuni,
	int,			codepage)
{
    int i;

    /*
     *	Ignore completely if already in slot.
     */
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].MIMEname, UC_MIMEcharset)) {
	    return;
	}
    }
    if (UC_rawuni == UCT_ENC_UTF8)
	lowest_eight = 128;  /* cheat here */
    /* 'codepage' doubles as a flag for 'do not try any table
    ** lookup, not even default' when negative.  The value will
    ** be returned immediately by UCTrans* functions.
    */
    if (!trydefault && codepage == 0)
	codepage = -12;	/* if not already set; any negative should do. */
    UC_NoUctb_Register_with_LYCharSets(UC_MIMEcharset,
				       UC_LYNXcharset,
				       lowest_eight,
				       UC_rawuni,
				       codepage);
    return;
}

a2021 41
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
PRIVATE int CpOrdinal ARGS2 (CONST unsigned long, cp, CONST int, other)
{
    char lyName[80];
    char myMimeName[80];
    char *mimeName, *mName = NULL, *lName = NULL;
    int s, i, exists = 0, ret;

    CTRACE((tfp, "CpOrdinal(cp=%ul, other=%d).\n", cp, other));
    sprintf(myMimeName, "auto%s-cp%lu", (other ? "2" : ""), cp);
    mimeName = myMimeName + 5 + (other != 0);
    sprintf(lyName, "AutoDetect%s (cp%lu)",
	    (other ? "-2" : ""), cp);
    /* Find slot. */
    s = -1;
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].LYNXname, lyName))
	    return UCGetLYhndl_byMIME(myMimeName);
	else if (!strcasecomp(UCInfo[i].MIMEname, mimeName))
	    s = i;
    }
    if (s < 0)
	return -1;
    /* Store the "real" charset info */
    real_charsets[other != 0] = UCGetLYhndl_byMIME(mimeName);
    /* Duplicate the record. */
    StrAllocCopy(mName, myMimeName);
    StrAllocCopy(lName, lyName);
    UC_Charset_Setup(mName, lName,
		     UCInfo[s].unicount, UCInfo[s].unitable,
		     UCInfo[s].num_uni, UCInfo[s].replacedesc,
		     UCInfo[s].lowest_eight, UCInfo[s].enc,
		     UCInfo[s].codepage);
    ret = UCGetLYhndl_byMIME(myMimeName);
    CTRACE((tfp, "Found %i.\n", ret));
    return ret;
}
#  endif /* __EMX__ */
#endif /* CAN_AUTODETECT_DISPLAY_CHARSET */

d2047 1
a2047 1
    UC_CHARSET_SETUP_macintosh;		  /* Macintosh (8 bit)	  */
d2053 1
a2053 1
    UC_CHARSET_SETUP_shift_jis;		  /*** Japanese (Shift_JIS) */
d2091 3
a2093 24

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
    {
	unsigned long lst[3];
	unsigned long len, rc;

	rc = DosQueryCp(sizeof(lst), lst, &len);
	if (rc == 0) {
	    if (len >= 1)
		auto_display_charset = CpOrdinal(lst[0], 0);
#    ifdef CAN_SWITCH_DISPLAY_CHARSET
	    if (len >= 3) {
		codepages[0] = lst[0];
		codepages[1] = (lst[0] == lst[1] ? lst[2] : lst[1]);
		auto_other_display_charset = CpOrdinal(codepages[1], 1);
	    }
#    endif
	} else {
	    CTRACE((tfp, "DosQueryCp() returned %#lx=%lu.\n", rc, rc));
	}
    }
#  endif
#endif
d2100 1
a2100 1
/* for coding/performance - easy to type: */
a2103 1
    TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
d2108 1
a2108 1
 *  in user input: lynx.cfg, userdefs.h, command line switches.
d2116 1
a2116 1
	CTRACE((tfp, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n"));
@

