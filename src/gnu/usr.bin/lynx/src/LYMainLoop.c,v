head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.7
	tg-mergefixes-1-branch:1.1.3.7.0.4
	tg-mergefixes-1-base:1.1.3.7
	MIROS_X:1.1.3.7.0.2
	MIROS_X_BASE:1.1.3.7
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.46.01;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.19;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.36;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.33;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.25;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.16;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.18;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.41;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.10.40;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.57;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.52.19;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.25;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTAccess.h>
#include <HTParse.h>
#include <HTList.h>
#include <HTML.h>
#include <HTFTP.h>
#include <HTFile.h>
#include <HTTP.h>
#include <HTAABrow.h>
#include <HTNews.h>
#include <LYCurses.h>
#include <LYStyle.h>
#include <LYGlobalDefs.h>
#include <HTAlert.h>
#include <LYUtils.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYOptions.h>
#include <LYSignal.h>
#include <LYGetFile.h>
#include <HTForms.h>
#include <LYSearch.h>
#include <LYClean.h>
#include <LYHistory.h>
#include <LYPrint.h>
#include <LYMail.h>
#include <LYEdit.h>
#include <LYShowInfo.h>
#include <LYBookmark.h>
#include <LYKeymap.h>
#include <LYJump.h>
#include <LYDownload.h>
#include <LYList.h>
#include <LYMap.h>
#include <LYTraversal.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYCookie.h>
#include <LYMainLoop.h>
#include <LYPrettySrc.h>

#ifdef KANJI_CODE_OVERRIDE
#include <HTCJK.h>
#endif

#ifdef KANJI_CODE_OVERRIDE
char *str_kcode(HTkcode code)
{
    char *p;
    static char buff[8];

    if (current_char_set == TRANSPARENT) {
	p = "THRU";
    } else if (!LYRawMode) {
	p = "RAW";
    } else {
	switch (code) {
	case NOKANJI:
	    p = "AUTO";
	    break;

	case EUC:
	    p = "EUC+";
	    break;

	case SJIS:
	    p = "SJIS";
	    break;

	case JIS:
	    p = " JIS";
	    break;

	default:
	    p = " ???";
	    break;
	}
    }

    if (no_table_center) {
	buff[0] = '!';
	strcpy(buff + 1, p);
    } else {
	strcpy(buff, p);
    }

    return buff;
}
#endif

#ifdef WIN_EX

static char *str_sjis(char *to, char *from)
{
    if (!LYRawMode) {
	strcpy(to, from);
#ifdef KANJI_CODE_OVERRIDE
    } else if (last_kcode == EUC) {
	EUC_TO_SJIS(from, to);
    } else if (last_kcode == SJIS) {
	strcpy(to, from);
#endif
    } else {
	TO_SJIS(from, to);
    }
    return to;
}

static void set_ws_title(char *str)
{
    SetConsoleTitle(str);
}

#endif /* WIN_EX */

#ifdef SH_EX			/* 1998/10/30 (Fri) 10:06:47 */

#define NOT_EQU	1

static int str_n_cmp(const char *p, const char *q, int n)
{
    if (n == 0)
	return 0;

    if (p == NULL)
	return NOT_EQU;

    if (q == NULL)
	return NOT_EQU;

    return strncmp(p, q, n);
}

#undef strncmp
#define	strncmp(p, q, r)	str_n_cmp(p, q, r)

#endif /* SH_EX */

#if defined(USE_EXTERNALS) || defined(WIN_EX)
#include <LYExtern.h>
#endif

#ifdef __EMX__
#include <io.h>
#endif

#ifdef DIRED_SUPPORT
#include <LYLocal.h>
#include <LYUpload.h>
#endif /* DIRED_SUPPORT */

#include <LYexit.h>
#include <LYLeaks.h>

/* two constants: */
HTLinkType *HTInternalLink = 0;
HTAtom *WWW_SOURCE = 0;

#ifndef DONT_TRACK_INTERNAL_LINKS
#define NO_INTERNAL_OR_DIFFERENT(c,n) TRUE
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) (!curdoc.internal_link || \
			   are_phys_different(p,n))
#else /* TRACK_INTERNAL_LINKS */
#define NO_INTERNAL_OR_DIFFERENT(c,n) are_different(c,n)
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) are_different(p,n)
#endif /* TRACK_INTERNAL_LINKS */

static void exit_immediately_with_error_message(int state, BOOLEAN first_file);
static void status_link(char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx);
static void show_main_statusline(const LinkInfo curlink, int for_what);
static void form_noviceline(int);
static int are_different(DocInfo *doc1, DocInfo *doc2);

#ifndef DONT_TRACK_INTERNAL_LINKS
static int are_phys_different(DocInfo *doc1, DocInfo *doc2);
#endif

#define FASTTAB

static int sametext(char *een,
		    char *twee)
{
    if (een && twee)
	return (strcmp(een, twee) == 0);
    return TRUE;
}

HTList *Goto_URLs = NULL;	/* List of Goto URLs */

char *LYRequestTitle = NULL;	/* newdoc.title in calls to getfile() */
char *LYRequestReferer = NULL;	/* Referer, may be set in getfile() */

static char prev_target[512];

#ifdef DISP_PARTIAL
BOOLEAN display_partial = FALSE;	/* could be enabled in HText_new() */
int NumOfLines_partial = 0;	/* number of lines displayed in partial mode */
#endif

static int Newline = 0;
static DocInfo newdoc;
static DocInfo curdoc;
static char *traversal_host = NULL;
static char *traversal_link_to_add = NULL;
static char *owner_address = NULL;	/* Holds the responsible owner's address     */
static char *ownerS_address = NULL;	/* Holds owner's address during source fetch */

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
static BOOL textinput_activated = FALSE;

#else
#define textinput_activated TRUE	/* a current text input is always active */
#endif
#ifdef INACTIVE_INPUT_STYLE_VH
BOOL textinput_redrawn = FALSE;

    /*must be public since used in LYhighlight(..) */
#endif

#ifdef LY_FIND_LEAKS
/*
 * Function for freeing allocated mainloop() variables.  - FM
 */
static void free_mainloop_variables(void)
{
    LYFreeDocInfo(&newdoc);
    LYFreeDocInfo(&curdoc);

#ifdef USE_COLOR_STYLE
    FREE(curdoc.style);
    FREE(newdoc.style);
#endif
    FREE(traversal_host);
    FREE(traversal_link_to_add);
    FREE(owner_address);
    FREE(ownerS_address);
#ifdef DIRED_SUPPORT
    clear_tags();
    reset_dired_menu();
#endif /* DIRED_SUPPORT */
    FREE(WWW_Download_File);	/* LYGetFile.c/HTFWriter.c */
    FREE(LYRequestReferer);

    return;
}
#endif /* LY_FIND_LEAKS */

#ifndef NO_LYNX_TRACE
static void TracelogOpenFailed(void)
{
    WWW_TraceFlag = FALSE;
    if (LYCursesON) {
	HTUserMsg(TRACELOG_OPEN_FAILED);
    } else {
	fprintf(stderr, "%s\n", TRACELOG_OPEN_FAILED);
	exit_immediately(EXIT_FAILURE);
    }
}

static BOOLEAN LYReopenTracelog(BOOLEAN *trace_flag_ptr)
{
    CTRACE((tfp, "\nTurning off TRACE for fetch of log.\n"));
    LYCloseTracelog();
    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
	TracelogOpenFailed();
	return FALSE;
    }
    if (TRACE) {
	WWW_TraceFlag = FALSE;
	*trace_flag_ptr = TRUE;
    }
    return TRUE;
}

static void turn_trace_back_on(BOOLEAN *trace_flag_ptr)
{
    if (*trace_flag_ptr == TRUE) {
	WWW_TraceFlag = TRUE;
	*trace_flag_ptr = FALSE;
	fprintf(tfp, "Turning TRACE back on.\n\n");
    }
}
#else
#define LYReopenTracelog(flag) TRUE
#define turn_trace_back_on(flag)	/*nothing */
#endif /* NO_LYNX_TRACE */

FILE *TraceFP(void)
{
#ifndef NO_LYNX_TRACE
    if (LYTraceLogFP != 0) {
	return LYTraceLogFP;
    }
#endif /* NO_LYNX_TRACE */
    return stderr;
}

BOOLEAN LYOpenTraceLog(void)
{
#ifndef NO_LYNX_TRACE
    if (TRACE && LYUseTraceLog && LYTraceLogFP == NULL) {
	/*
	 * If we can't open it for writing, give up.  Otherwise, on VMS close
	 * it, delete it and any versions from previous sessions so they don't
	 * accumulate, and open it again.  - FM
	 */
	if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
	    TracelogOpenFailed();
	    return FALSE;
	}
#ifdef VMS
	LYCloseTracelog();
	HTSYS_remove(LYTraceLogPath);
	if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
	    TracelogOpenFailed();
	    return FALSE;
	}
#endif /* VMS */
	fflush(stdout);
	fflush(stderr);
	fprintf(tfp, "\t\t%s (%s)\n\n", LYNX_TRACELOG_TITLE, LYNX_VERSION);
	/*
	 * If TRACE is on, indicate whether the anonymous restrictions are set. 
	 * - FM, LP, kw
	 *
	 * This is only a summary for convenience - it doesn't take the case of
	 * individual -restrictions= options into account.  - kw
	 */
	if (LYValidate) {
	    if (LYRestricted && had_restrictions_default) {
		CTRACE((tfp,
			"Validate and some anonymous restrictions are set.\n"));
	    } else if (had_restrictions_default) {
		CTRACE((tfp,
			"Validate restrictions set, restriction \"default\" was given.\n"));
	    } else if (LYRestricted) {
		CTRACE((tfp,
			"Validate restrictions set, additional anonymous restrictions ignored.\n"));
	    } else {
		CTRACE((tfp, "Validate restrictions are set.\n"));
	    }
	    /* But none of the above can actually happen, since there should
	     * never be a Trace Log with -validate.  If it appears in a log
	     * file something went wrong! */
	} else if (LYRestricted) {
	    if (had_restrictions_all) {
		CTRACE((tfp,
			"Anonymous restrictions set, restriction \"all\" was given.\n"));
	    } else {
		CTRACE((tfp, "Anonymous restrictions are set.\n"));
	    }
	} else if (had_restrictions_all && had_restrictions_default) {
	    CTRACE((tfp, "Restrictions \"all\" and \"default\" were given.\n"));
	} else if (had_restrictions_default) {
	    CTRACE((tfp, "Restriction \"default\" was given.\n"));
	} else if (had_restrictions_all) {
	    CTRACE((tfp, "\"all\" restrictions are set.\n"));
	}
    }
#endif /* NO_LYNX_TRACE */
    return TRUE;
}

void LYCloseTracelog(void)
{
#ifndef NO_LYNX_TRACE
    if (LYTraceLogFP != 0) {
	fflush(stdout);
	fflush(stderr);
	fclose(LYTraceLogFP);
	LYTraceLogFP = 0;
    }
#endif /* NO_LYNX_TRACE */
}

void handle_LYK_TRACE_TOGGLE(void)
{
#ifndef NO_LYNX_TRACE
    WWW_TraceFlag = !WWW_TraceFlag;
    if (LYOpenTraceLog())
	HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

void LYSetNewline(int value)
{
    Newline = value;
}

int LYGetNewline(void)
{
    return Newline;
}

#ifdef USE_SOURCE_CACHE
static BOOLEAN from_source_cache = FALSE;

/*
 * Like HTreparse_document(), but also set the flag.
 */
static BOOLEAN reparse_document(void)
{
    BOOLEAN ok;

    from_source_cache = TRUE;	/* set for LYMainLoop_pageDisplay() */
    if ((ok = HTreparse_document()) != FALSE) {
	from_source_cache = TRUE;	/* set for mainloop refresh */
	return ok;
    }
    from_source_cache = FALSE;
    return ok;
}
#endif /* USE_SOURCE_CACHE */

/*
 * Prefer reparsing if we can, but reload if we must - to force regeneration
 * of the display.
 */
static BOOLEAN reparse_or_reload(int *cmd)
{
#ifdef USE_SOURCE_CACHE
    if (reparse_document()) {
	return FALSE;
    }
#endif
    *cmd = LYK_RELOAD;
    return TRUE;
}

/*
 * Functions for setting the current address
 */
static void set_address(DocInfo *doc, const char *address)
{
    StrAllocCopy(doc->address, address);
}

static void copy_address(DocInfo *dst, DocInfo *src)
{
    StrAllocCopy(dst->address, src->address);
}

static void free_address(DocInfo *doc)
{
    FREE(doc->address);
}

static void move_address(DocInfo *dst, DocInfo *src)
{
    copy_address(dst, src);
    free_address(src);
}

#ifdef DISP_PARTIAL
/*
 * This is for traversal call from within partial mode in LYUtils.c
 * and HTFormat.c  It simply calls HText_pageDisplay() but utilizes
 * LYMainLoop.c static variables to manage proper newline position
 * in case of #fragment
 */
BOOL LYMainLoop_pageDisplay(int line_num)
{
    const char *pound;
    int prev_newline = Newline;

    /*
     * Override Newline with a new value if user scrolled the document while
     * loading (in LYUtils.c).
     */
    Newline = line_num;

#ifdef USE_SOURCE_CACHE
    /*
     * reparse_document() acts on 'curdoc' which always on top of the
     * history stack: no need to resolve #fragment position since
     * we already know it (curdoc.line).
     * So bypass here. Sorry for possible confusion...
     */
    if (!from_source_cache)
#endif
	/*
	 * If the requested URL has the #fragment, and we are not popped
	 * from the history stack, and have not scrolled the document yet -
	 * we should calculate correct newline position for the fragment.
	 * (This is a bit suboptimal since HTFindPoundSelector() traverse
	 * anchors list each time, so we have a quadratic complexity
	 * and may load CPU in a worst case).
	 */
	if (display_partial
	    && newdoc.line == 1 && line_num == 1 && prev_newline == 1
	    && (pound = findPoundSelector(newdoc.address))
	    && *pound && *(pound + 1)) {
	    if (HTFindPoundSelector(pound + 1)) {
		/* HTFindPoundSelector will initialize www_search_result */
		Newline = www_search_result;
	    } else {
		Newline = prev_newline;		/* restore ??? */
		return NO;	/* no repaint */
	    }
	}

    HText_pageDisplay(Newline, prev_target);
    return YES;
}
#endif /* DISP_PARTIAL */

static BOOL set_curdoc_link(int nextlink)
{
    BOOL result = FALSE;

    if (curdoc.link != nextlink
	&& nextlink >= 0
	&& nextlink < nlinks) {
	if (curdoc.link >= 0 && curdoc.link < nlinks) {
	    LYhighlight(OFF, curdoc.link, prev_target);
	    result = TRUE;
	}
	curdoc.link = nextlink;
    }
    return result;
}

/*
 * Setup newdoc to jump to the given line.
 *
 * FIXME: prefer to also jump to the link given in a URL fragment, but the
 * interface of getfile() does not provide that ability yet.
 */
static void goto_line(int nextline)
{
    int n;
    int old_link = newdoc.link;

    newdoc.link = 0;
    for (n = 0; n < nlinks; ++n) {
	if (nextline == links[n].anchor_line_num + 1) {
	    CTRACE((tfp, "top_of_screen %d\n", HText_getTopOfScreen() + 1));
	    CTRACE((tfp, "goto_line(%d) -> link %d -> %d\n", nextline,
		    old_link, n));
	    newdoc.link = n;
	    break;
	}
    }
}

#ifdef USE_MOUSE
static void set_curdoc_link_by_mouse(int nextlink)
{
    if (set_curdoc_link(nextlink)) {
	LYhighlight(ON, nextlink, prev_target);
	LYmsec_delay(20);
    }
}
#else
#define set_curdoc_link_by_mouse(nextlink) set_curdoc_link(nextlink)
#endif

static int do_change_link(void)
{
#ifdef USE_MOUSE
    /* Is there a mouse-clicked link waiting? */
    int mouse_tmp = get_mouse_link();

    /* If yes, use it as the link */
    if (mouse_tmp != -1) {
	if (mouse_tmp < 0 || mouse_tmp >= nlinks) {
	    char *msgtmp = NULL;

	    HTSprintf0(&msgtmp,
		       gettext("Internal error: Invalid mouse link %d!"),
		       mouse_tmp);
	    HTAlert(msgtmp);
	    FREE(msgtmp);
	    return (-1);	/* indicates unexpected error */
	}
	set_curdoc_link_by_mouse(mouse_tmp);
    }
#endif /* USE_MOUSE */
    return (0);			/* indicates OK */
}

#ifdef DIRED_SUPPORT
#define DIRED_UNCACHE_1 if (LYAutoUncacheDirLists < 1) /*nothing*/ ;\
			else HTuncache_current_document()
#define DIRED_UNCACHE_2 if (LYAutoUncacheDirLists < 2) /*nothing*/ ;\
			else HTuncache_current_document()
#endif /* DIRED_SUPPORT */

static void do_check_goto_URL(char *user_input_buffer,
			      char **old_user_input,
			      BOOLEAN *force_load)
{
    static BOOLEAN always = TRUE;
    /* *INDENT-OFF* */
    static struct {
	const char *name;
	BOOLEAN *flag;
    } table[] = {
	{ STR_FILE_URL,		&no_file_url },
	{ STR_FILE_URL,		&no_goto_file },
	{ STR_LYNXEXEC,		&no_goto_lynxexec },
	{ STR_LYNXPROG,		&no_goto_lynxprog },
	{ STR_LYNXCGI,		&no_goto_lynxcgi },
	{ STR_CSO_URL,		&no_goto_cso },
	{ STR_FINGER_URL,	&no_goto_finger },
	{ STR_FTP_URL,		&no_goto_ftp },
	{ STR_GOPHER_URL,	&no_goto_gopher },
	{ STR_HTTP_URL,		&no_goto_http },
	{ STR_HTTPS_URL,	&no_goto_https },
	{ STR_MAILTO_URL,	&no_goto_mailto },
	{ STR_RLOGIN_URL,	&no_goto_rlogin },
	{ STR_TELNET_URL,	&no_goto_telnet },
	{ STR_TN3270_URL,	&no_goto_tn3270 },
	{ STR_WAIS_URL,		&no_goto_wais },
#ifndef DISABLE_BIBP
	{ STR_BIBP_URL,		&no_goto_bibp },
#endif
#ifndef DISABLE_NEWS
	{ STR_NEWS_URL,		&no_goto_news },
	{ STR_NNTP_URL,		&no_goto_nntp },
	{ STR_SNEWS_URL,	&no_goto_snews },
#endif
#ifdef EXEC_LINKS
	{ STR_LYNXEXEC,		&local_exec_on_local_files },
	{ STR_LYNXPROG,		&local_exec_on_local_files },
#endif /* EXEC_LINKS */
	{ STR_LYNXCFG,		&no_goto_configinfo },
	{ STR_LYNXCFLAGS,	&no_goto_configinfo },
	{ STR_LYNXCOOKIE,	&always },
	{ STR_LYNXDIRED,	&always },
	{ STR_LYNXDOWNLOAD,	&always },
	{ STR_LYNXOPTIONS,	&always },
	{ STR_LYNXPRINT,	&always },
    };
    /* *INDENT-ON* */

    unsigned n;
    BOOLEAN found = FALSE;

    /* allow going to anchors */
    if (*user_input_buffer == '#') {
	if (user_input_buffer[1] &&
	    HTFindPoundSelector(user_input_buffer + 1)) {
	    /* HTFindPoundSelector will initialize www_search_result,
	       so we do nothing else. */
	    HTAddGotoURL(user_input_buffer);
	    trimPoundSelector(curdoc.address);
	    StrAllocCat(curdoc.address, user_input_buffer);
	}
    } else {
	/*
	 * If it's not a URL then make it one.
	 */
	StrAllocCopy(*old_user_input, user_input_buffer);
	LYEnsureAbsoluteURL(old_user_input, "", TRUE);
	sprintf(user_input_buffer, "%.*s",
		(int) (MAX_LINE - 1), *old_user_input);
	FREE(*old_user_input);

	for (n = 0; n < TABLESIZE(table); n++) {
	    if (*(table[n].flag)
		&& !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
		found = TRUE;
		HTUserMsg2(GOTO_XXXX_DISALLOWED, table[n].name);
		break;
	    }
	}
	if (found) {
	    ;
	} else if (LYValidate &&
		   !isHTTP_URL(user_input_buffer) &&
		   !isHTTPS_URL(user_input_buffer)) {
	    HTUserMsg(GOTO_NON_HTTP_DISALLOWED);

	} else {
	    set_address(&newdoc, user_input_buffer);
	    newdoc.isHEAD = FALSE;
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * dont't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		/*
		 * Make a name for this new URL.
		 */
		StrAllocCopy(newdoc.title,
			     gettext("A URL specified by the user"));
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		*force_load = TRUE;
#ifdef DIRED_SUPPORT
		if (lynx_edit_mode) {
		    DIRED_UNCACHE_2;
		}
#endif /* DIRED_SUPPORT */
	    }
	    LYUserSpecifiedURL = TRUE;
	    HTAddGotoURL(newdoc.address);
	}
    }
}

/* returns FALSE if user cancelled input or URL was invalid, TRUE otherwise */
static BOOL do_check_recall(int ch,
			    char *user_input_buffer,
			    char **old_user_input,
			    int URLTotal,
			    int *URLNum,
			    RecallType recall,
			    BOOLEAN *FirstURLRecall)
{
    char *cp;
    BOOL ret = FALSE;

    if (*old_user_input == 0)
	StrAllocCopy(*old_user_input, "");

    for (;;) {
#ifdef WIN_EX			/* 1998/10/11 (Sun) 10:41:05 */
	int len = strlen(user_input_buffer);

	if (len >= 3) {
	    if (len < MAX_LINE - 1
		&& LYIsHtmlSep(user_input_buffer[len - 3])
		&& LYIsDosDrive(user_input_buffer + len - 2))
		LYAddPathSep0(user_input_buffer);

	} else if (len == 2 && user_input_buffer[1] == ':') {
	    if (LYIsDosDrive(user_input_buffer)) {
		LYAddPathSep0(user_input_buffer);
	    } else {
		HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
		LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		FREE(*old_user_input);
		ret = FALSE;
		break;
	    }
	}
#endif
	/*
	 * Get rid of leading spaces (and any other spaces).
	 */
	LYTrimAllStartfile(user_input_buffer);
	if (*user_input_buffer == '\0' &&
	    !(recall && (ch == UPARROW || ch == DNARROW))) {
	    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	    FREE(*old_user_input);
	    HTInfoMsg(CANCELLED);
	    ret = FALSE;
	    break;
	}
	if (recall && ch == UPARROW) {
	    if (*FirstURLRecall) {
		/*
		 * Use last URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = 0;
	    } else {
		/*
		 * Go back to the previous URL in the list.  - FM
		 */
		*URLNum += 1;
	    }
	    if (*URLNum >= URLTotal)
		/*
		 * Roll around to the last URL in the list.  - FM
		 */
		*URLNum = 0;
	    if ((cp = (char *) HTList_objectAt(Goto_URLs,
					       *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer
		    && **old_user_input
		    && !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
		    /*
		     * User cancelled the Goto via ^G.  Restore
		     * user_input_buffer and break.  - FM
		     */
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else if (recall && ch == DNARROW) {
	    if (*FirstURLRecall) {
		/*
		 * Use the first URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = URLTotal - 1;
	    } else {
		/*
		 * Advance to the next URL in the list.  - FM
		 */
		*URLNum -= 1;
	    }
	    if (*URLNum < 0)
		/*
		 * Roll around to the first URL in the list.  - FM
		 */
		*URLNum = URLTotal - 1;
	    if ((cp = (char *) HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer && **old_user_input &&
		    !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
		    /*
		     * User cancelled the Goto via ^G.  Restore
		     * user_input_buffer and break.  - FM
		     */
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else {
	    ret = TRUE;
	    break;
	}
    }
    return ret;
}

static void do_cleanup_after_delete(void)
{
    HTuncache_current_document();
    move_address(&newdoc, &curdoc);
    newdoc.line = curdoc.line;
    if (curdoc.link == nlinks - 1) {
	/*
	 * We deleted the last link on the page.  - FM
	 */
	newdoc.link = curdoc.link - 1;
    } else {
	newdoc.link = curdoc.link;
    }
}

static int find_link_near_col(int col,
			      int delta)
{
    int i;

    for (i = curdoc.link; delta > 0 ? (i < nlinks) : (i >= 0); i += delta) {
	if ((links[i].ly - links[curdoc.link].ly) * delta > 0) {
	    int cy = links[i].ly, best = -1, dist = 1000000;

	    while ((delta > 0 ? (i < nlinks) : (i >= 0)) && cy == links[i].ly) {
		int cx = links[i].lx;
		const char *text = LYGetHiliteStr(i, 0);

		if (text != NULL)
		    cx += strlen(text) / 2;
		cx -= col;
		if (cx < 0)
		    cx = -cx;
		if (cx < dist) {
		    dist = cx;
		    best = i;
		}
		i += delta;
	    }
	    return (best);
	}
    }
    return (-1);
}

/*
 * This is a special feature to traverse every http link derived from startfile
 * and check for errors or create crawl output files.  Only URL's that begin
 * with "traversal_host" are searched - this keeps the search from crossing to
 * other servers (a feature, not a bug!).
 */
static int DoTraversal(int c,
		       BOOLEAN *crawl_ok)
{
    BOOLEAN rlink_rejected = FALSE;
    BOOLEAN rlink_exists;
    BOOLEAN rlink_allowed;

    rlink_exists = (BOOL) (nlinks > 0 &&
			   links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
			   links[curdoc.link].lname != NULL);

    if (rlink_exists) {
	rlink_rejected = lookup_reject(links[curdoc.link].lname);
	if (!rlink_rejected &&
	    traversal_host &&
	    links[curdoc.link].lname) {
	    if (!isLYNXIMGMAP(links[curdoc.link].lname)) {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
						links[curdoc.link].lname,
						strlen(traversal_host));
	    } else {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
						links[curdoc.link].lname + LEN_LYNXIMGMAP,
						strlen(traversal_host));
	    }
	} else {
	    rlink_allowed = FALSE;
	}
    } else {
	rlink_allowed = FALSE;
    }
    if (rlink_exists && rlink_allowed) {
	if (lookup_link(links[curdoc.link].lname)) {
	    if (more_links ||
		(curdoc.link > -1 && curdoc.link < nlinks - 1)) {
		c = DNARROW;
	    } else {
		if (STREQ(curdoc.title, "Entry into main screen") ||
		    (nhist <= 0)) {
		    if (!dump_output_immediately) {
			cleanup();
			exit_immediately(EXIT_FAILURE);
		    }
		    c = -1;
		} else {
		    c = LTARROW;
		}
	    }
	} else {
	    StrAllocCopy(traversal_link_to_add,
			 links[curdoc.link].lname);
	    if (!isLYNXIMGMAP(traversal_link_to_add))
		*crawl_ok = TRUE;
	    c = RTARROW;
	}
    } else {			/* no good right link, so only down and left arrow ok */
	if (rlink_exists /* && !rlink_rejected */ )
	    /* uncomment in previous line to avoid duplicates - kw */
	    add_to_reject_list(links[curdoc.link].lname);
	if (more_links ||
	    (curdoc.link > -1 && curdoc.link < nlinks - 1)) {
	    c = DNARROW;
	} else {
	    /*
	     * curdoc.title doesn't always work, so bail out if the history
	     * list is empty.
	     */
	    if (STREQ(curdoc.title, "Entry into main screen") ||
		(nhist <= 0)) {
		if (!dump_output_immediately) {
		    cleanup();
		    exit_immediately(EXIT_FAILURE);
		}
		c = -1;
	    } else {
		c = LTARROW;
	    }
	}
    }
    CTRACE((tfp, "DoTraversal(%d:%d) -> %s\n",
	    nlinks > 0 ? curdoc.link : 0,
	    nlinks,
	    LYKeycodeToString(c, FALSE)));
    return c;
}

#ifndef DONT_TRACK_INTERNAL_LINKS
static BOOLEAN check_history(void)
{
    const char *base;

    if (!curdoc.post_data)
	/*
	 * Normal case - List Page is not associated with post data.  - kw
	 */
	return TRUE;

    if (nhist > 0
	&& !LYresubmit_posts
	&& HDOC(nhist - 1).post_data
	&& BINEQ(curdoc.post_data, HDOC(nhist - 1).post_data)
	&& (base = HText_getContentBase()) != 0) {
	char *text = !isLYNXIMGMAP(HDOC(nhist - 1).address)
	? HDOC(nhist - 1).address
	: HDOC(nhist - 1).address + LEN_LYNXIMGMAP;

	if (!strncmp(base, text, strlen(base))) {
	    /*
	     * Normal case - as best as we can check, the document at the top
	     * of the history stack seems to be the document the List Page is
	     * about (or a LYNXIMGMAP derived from it), and LYresubmit_posts is
	     * not set, so don't prompt here.  If we actually have to repeat a
	     * POST because, against expectations, the underlying document
	     * isn't cached any more, HTAccess will prompt for confirmation,
	     * unless we had LYK_NOCACHE -kw
	     */
	    return TRUE;
	}
    }
    return FALSE;
}
#endif

static int handle_LYK_ACTIVATE(int *c,
			       int cmd GCC_UNUSED,
			       BOOLEAN *try_internal GCC_UNUSED,
			       BOOLEAN *refresh_screen,
			       BOOLEAN *force_load,
			       int real_cmd)
{
    if (do_change_link() == -1) {
	LYforce_no_cache = FALSE;
	reloading = FALSE;
	return 1;		/* mouse stuff was confused, ignore - kw */
    }
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (real_cmd == LYK_ACTIVATE && textfields_need_activation &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {

		textinput_activated = TRUE;
		show_main_statusline(links[curdoc.link], FOR_INPUT);
		textfields_need_activation = textfields_activation_option;

		return 0;
	    }
#endif
	    /*
	     * Don't try to submit forms with bad actions.  - FM
	     */
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type ==
		F_TEXT_SUBMIT_TYPE) {
		/*
		 * Do nothing if it's disabled.  - FM
		 */
		if (links[curdoc.link].l_form->disabled == YES) {
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure we have an action.  - FM
		 */
		if (!links[curdoc.link].l_form->submit_action ||
		    *links[curdoc.link].l_form->submit_action
		    == '\0') {
		    HTUserMsg(NO_FORM_ACTION);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Check for no_mail if the form action is a mailto URL.  - FM
		 */
		if (links[curdoc.link].l_form->submit_method
		    == URL_MAIL_METHOD && no_mail) {
		    HTAlert(FORM_MAILTO_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure this isn't a spoof in an account with restrictions
		 * on file URLs.  - FM
		 */
		if (no_file_url &&
		    isFILE_URL(links[curdoc.link].l_form->submit_action)) {
		    HTAlert(FILE_ACTIONS_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure this isn't a spoof attempt via an internal URL.  -
		 * FM
		 */
		if (isLYNXCOOKIE(links[curdoc.link].l_form->submit_action) ||
#ifdef DIRED_SUPPORT
#ifdef OK_PERMIT
		    (isLYNXDIRED(links[curdoc.link].l_form->submit_action) &&
		     (no_dired_support ||
		      strncasecomp((links[curdoc.link].l_form->submit_action
				    + 10),
				   "//PERMIT_LOCATION", 17) ||
		      !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS))) ||
#else
		    isLYNXDIRED(links[curdoc.link].l_form->submit_action) ||
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
		    isLYNXDOWNLOAD(links[curdoc.link].l_form->submit_action) ||
		    isLYNXHIST(links[curdoc.link].l_form->submit_action) ||
		    isLYNXKEYMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXIMGMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPRINT(links[curdoc.link].l_form->submit_action) ||
		    isLYNXEXEC(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPROG(links[curdoc.link].l_form->submit_action)) {

		    HTAlert(SPECIAL_ACTION_DISALLOWED);
		    CTRACE((tfp, "LYMainLoop: Rejected '%s'\n",
			    links[curdoc.link].l_form->submit_action));
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
#ifdef NOTDEFINED		/* We're disabling form inputs instead of using this. - FM */
		/*
		 * Check for enctype and let user know we don't yet support
		 * multipart/form-data - FM
		 */
		if (links[curdoc.link].l_form->submit_enctype) {
		    if (!strcmp(links[curdoc.link].l_form->submit_enctype,
				"multipart/form-data")) {
			HTAlert(gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			reloading = FALSE;
			return 0;
		    }
		}
#endif /* NOTDEFINED */
		if (check_realm) {
		    LYPermitURL = TRUE;
		}
		if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
		    LYNoRefererForThis = TRUE;
		}
		if (links[curdoc.link].l_form->submit_method != URL_MAIL_METHOD) {
		    StrAllocCopy(newdoc.title,
				 LYGetHiliteStr(curdoc.link, 0));
		}
	    }

	    /*
	     * Normally we don't get here for text input fields, but it can
	     * happen as a result of mouse positioning.  In that case the
	     * statusline will not have updated info, so update it now.  - kw
	     */
	    if (F_TEXTLIKE(links[curdoc.link].l_form->type)) {
		show_formlink_statusline(links[curdoc.link].l_form,
					 (real_cmd == LYK_NOCACHE ||
					  real_cmd == LYK_DOWNLOAD ||
					  real_cmd == LYK_HEAD ||
					  (real_cmd == LYK_SUBMIT &&
					   !textinput_activated)) ?
					 FOR_PANEL : FOR_INPUT);
		if (user_mode == NOVICE_MODE &&
		    textinput_activated &&
		    (real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT)) {
		    form_noviceline(links[curdoc.link].l_form->disabled);
		}
	    }

	    *c = change_form_link(curdoc.link,
				  &newdoc, refresh_screen,
				  FALSE,
				  (BOOLEAN) (real_cmd == LYK_SUBMIT ||
					     real_cmd == LYK_NOCACHE ||
					     real_cmd == LYK_DOWNLOAD ||
					     real_cmd == LYK_HEAD));
	    if (*c != LKC_DONE || *refresh_screen) {
		/*
		 * Cannot have been a submit field for which newdoc was filled
		 * in.  - kw
		 */
		if ((links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) &&
		    links[curdoc.link].l_form->submit_method
		    != URL_MAIL_METHOD) {
		    /*
		     * Try to undo change of newdoc.title done above.
		     */
		    if (HText_getTitle()) {
			StrAllocCopy(newdoc.title, HText_getTitle());
		    } else if (curdoc.title) {
			StrAllocCopy(newdoc.title, curdoc.title);
		    }
		}
	    } else {
		if (HTOutputFormat == HTAtom_for("www/download") &&
		    newdoc.post_data != NULL &&
		    newdoc.safe == FALSE) {

		    if ((HText_POSTReplyLoaded(&newdoc) == TRUE) &&
			HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			HTInfoMsg(CANCELLED);
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			return 0;
		    }
		}
		/*
		 * Moved here from earlier to only apply when it should. 
		 * Anyway, why should realm checking be overridden for form
		 * submissions, this seems to be an unnecessary loophole??  But
		 * that's the way it was, maybe there is some reason.  However,
		 * at least make sure this doesn't weaken restrictions implied
		 * by -validate!
		 * - kw 1999-05-25
		 */
		if (check_realm && !LYValidate) {
		    LYPermitURL = TRUE;
		}
	    }
	    if (*c == LKC_DONE) {
		*c = DO_NOTHING;
	    } else if (*c == 23) {
		*c = DO_NOTHING;
		*refresh_screen = TRUE;
	    } else {
		/* Avoid getting stuck with repeatedly calling
		 * handle_LYK_ACTIVATE(), instead of calling change_form_link()
		 * directly from mainloop(), for text input fields.  - kw
		 */
		switch (LKC_TO_C(*c)) {
		case '\n':
		case '\r':
		default:
		    if ((real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT) &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
			textinput_activated) {
			return 3;
		    }
		    break;
		}
	    }
	    return 2;
	} else {
	    /*
	     * Not a forms link.
	     *
	     * Make sure this isn't a spoof in an account with restrictions on
	     * file URLs.  - FM
	     */
	    if (no_file_url && isFILE_URL(links[curdoc.link].lname)) {
		if (!isFILE_URL(curdoc.address) &&
		    !((isLYNXKEYMAP(curdoc.address) ||
		       isLYNXCOOKIE(curdoc.address)) &&
		      !strncmp(links[curdoc.link].lname,
			       helpfilepath,
			       strlen(helpfilepath)))) {
		    HTAlert(FILE_SERVED_LINKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		} else if (curdoc.bookmark != NULL) {
		    HTAlert(FILE_BOOKMARKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		}
	    }
	    /*
	     * Make sure this isn't a spoof attempt via an internal URL in a
	     * non-internal document.  - FM
	     */
	    if ((isLYNXCOOKIE(links[curdoc.link].lname) &&
		 (strcmp(NonNull(curdoc.title), COOKIE_JAR_TITLE) ||
		  !isLYNXCOOKIE(curdoc.address))) ||
#ifdef DIRED_SUPPORT
		(isLYNXDIRED(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
		 !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
#ifdef OK_INSTALL
		 !LYIsUIPage(curdoc.address, UIP_INSTALL) &&
#endif /* OK_INSTALL */
		 !LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) ||
#endif /* DIRED_SUPPORT */
		(isLYNXDOWNLOAD(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS)) ||
		(isLYNXHIST(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		 !LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		 !LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) ||
		(isLYNXPRINT(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS))) {
		HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		HTOutputFormat = WWW_PRESENT;
		LYforce_no_cache = FALSE;
		reloading = FALSE;
		return 0;
	    }
#ifdef USE_EXTERNALS
	    if (run_external(links[curdoc.link].lname, TRUE)) {
		*refresh_screen = TRUE;
		return 0;
	    }
#endif /* USE_EXTERNALS */

	    /*
	     * Follow a normal link or anchor.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /*
	     * For internal links, retain POST content if present.  If we are
	     * on the List Page, prevent pushing it on the history stack. 
	     * Otherwise set try_internal to signal that the top of the loop
	     * should attempt to reposition directly, without calling getfile. 
	     * - kw
	     */
	    /*
	     * Might be an internal link anchor in the same doc.  If so, take
	     * the try_internal shortcut if we didn't fall through from
	     * LYK_NOCACHE.  - kw
	     */
	    newdoc.internal_link =
		(links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
	    if (newdoc.internal_link) {
		/*
		 * Special case of List Page document with an internal link
		 * indication, which may really stand for an internal link
		 * within the document the List Page is about.  - kw
		 */
		if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		    (LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		     LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		    if (check_history()) {
			LYinternal_flag = TRUE;
		    } else {
			HTLastConfirmCancelled();	/* reset flag */
			if (!confirm_post_resub(newdoc.address,
						newdoc.title,
						((LYresubmit_posts &&
						  HText_POSTReplyLoaded(&newdoc))
						 ? 1
						 : 2),
						2)) {
			    if (HTLastConfirmCancelled() ||
				(LYresubmit_posts &&
				 cmd != LYK_NOCACHE &&
				 !HText_POSTReplyLoaded(&newdoc))) {
				/* cancel the whole thing */
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				copy_address(&newdoc, &curdoc);
				StrAllocCopy(newdoc.title, curdoc.title);
				newdoc.internal_link = curdoc.internal_link;
				HTInfoMsg(CANCELLED);
				return 1;
			    } else if (LYresubmit_posts &&
				       cmd != LYK_NOCACHE) {
				/* If LYresubmit_posts is set, and the
				   answer was No, and the key wasn't
				   NOCACHE, and we have a cached copy,
				   then use it. - kw */
				LYforce_no_cache = FALSE;
			    } else {
				/* if No, but not ^C or ^G, drop
				 * the post data.  Maybe the link
				 * wasn't meant to be internal after
				 * all, here we can recover from that
				 * assumption. - kw */
				LYFreePostData(&newdoc);
				newdoc.internal_link = FALSE;
				HTAlert(DISCARDING_POST_DATA);
			    }
			}
		    }
		    /*
		     * Don't push the List Page if we follow an internal link
		     * given by it.  - kw
		     */
		    free_address(&curdoc);
		} else if (cmd != LYK_NOCACHE) {
		    *try_internal = TRUE;
		}
		if (!(LYresubmit_posts && newdoc.post_data))
		    LYinternal_flag = TRUE;
		/* We still set force_load so that history pushing
		 * etc. will be done.  - kw
		 */
		*force_load = TRUE;
		return 1;
	    } else {
		/*
		 * Free POST content if not an internal link.  - kw
		 */
		LYFreePostData(&newdoc);
	    }
#endif /* TRACK_INTERNAL_LINKS */
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		if (isLYNXMESSAGES(newdoc.address))
		    LYforce_no_cache = TRUE;
	    }
	    if (!no_jump && lynxjumpfile && curdoc.address &&
		!strcmp(lynxjumpfile, curdoc.address)) {
		LYJumpFileURL = TRUE;
		LYUserSpecifiedURL = TRUE;
	    } else if ((curdoc.title &&
			(LYIsUIPage(curdoc.address, UIP_HISTORY) ||
			 !strcmp(curdoc.title, HISTORY_PAGE_TITLE))) ||
		       curdoc.bookmark != NULL ||
		       (lynxjumpfile &&
			!strcmp(lynxjumpfile, curdoc.address))) {
		LYUserSpecifiedURL = TRUE;
	    } else if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
		LYNoRefererForThis = TRUE;
	    }
	    newdoc.link = 0;
	    *force_load = TRUE;	/* force MainLoop to reload */
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;	/* we get here if link is not internal */
#endif

#if defined(DIRED_SUPPORT) && !defined(__DJGPP__)
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
		/*
		 * Unescaping any slash chars in the URL, but avoid double
		 * unescaping and too-early unescaping of other chars.  - KW
		 */
		HTUnEscapeSome(newdoc.address, "/");
		/* avoid stripping final slash for root dir - kw */
		if (strcasecomp(newdoc.address, "file://localhost/"))
		    strip_trailing_slash(newdoc.address);
	    }
#endif /* DIRED_SUPPORT  && !__DJGPP__ */
	    if (isLYNXCOOKIE(curdoc.address)) {
		HTuncache_current_document();
	    }
	}
    }
    return 0;
}

#ifdef EXP_ADDRLIST_PAGE
static BOOLEAN handle_LYK_ADDRLIST(int *cmd)
{
    /*
     * Don't do if already viewing list addresses page.
     */
    if (LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) {
	/*
	 * Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print address list page to file.
     */
    if (showlist(&newdoc, FALSE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, ADDRLIST_PAGE_TITLE);
    /*
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}
#endif /* EXP_ADDRLIST_PAGE */

static void handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
{
    int c;

    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    if (!LYIsUIPage(curdoc.address, UIP_HISTORY) &&
	!LYIsUIPage(curdoc.address, UIP_SHOWINFO) &&
	!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS) &&
#ifdef DIRED_SUPPORT
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	!LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
	!LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS) &&
#endif /* DIRED_SUPPORT */
	!LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS) &&
	!isLYNXCOOKIE(curdoc.address) &&
	!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU) &&
	((nlinks <= 0) ||
	 (links[curdoc.link].lname != NULL &&
	  !isLYNXHIST(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname) &&
	  !isLYNXDIRED(links[curdoc.link].lname) &&
	  !isLYNXDOWNLOAD(links[curdoc.link].lname) &&
	  !isLYNXCOOKIE(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname)))) {
	if (nlinks > 0) {
	    if (curdoc.post_data == NULL &&
		curdoc.bookmark == NULL &&
		!LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_VLINKS)) {
		/*
		 * The document doesn't have POST content, and is not a
		 * bookmark file, nor is the list or visited links page, so we
		 * can save either that or the link.  - FM
		 */
		_statusline(BOOK_D_L_OR_CANCEL);
		if ((c = LYgetch_single()) == 'D') {
		    save_bookmark_link(curdoc.address, curdoc.title);
		    *refresh_screen = TRUE;	/* MultiBookmark support */
		    goto check_add_bookmark_to_self;
		}
	    } else {
		if (LYMultiBookmarks == MBM_OFF &&
		    curdoc.bookmark != NULL &&
		    strstr(curdoc.address,
			   (*bookmark_page == '.'
			    ? (bookmark_page + 1)
			    : bookmark_page)) != NULL) {
		    /*
		     * If multiple bookmarks are disabled, offer the L)ink or
		     * C)ancel, but with wording which indicates that the link
		     * already exists in this bookmark file.  - FM
		     */
		    _statusline(MULTIBOOKMARKS_SELF);
		} else if (curdoc.post_data != NULL &&
			   links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
		    /*
		     * Internal link, and document has POST content.
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		} else {
		    /*
		     * Only offer the link in a document with POST content, or
		     * if the current document is a bookmark file and multiple
		     * bookmarks are enabled.  - FM
		     */
		    _statusline(BOOK_L_OR_CANCEL);
		}
		c = LYgetch_single();
	    }
	    if (c == 'L') {
		if (curdoc.post_data != NULL &&
		    links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
		    /*
		     * Internal link, and document has POST content.
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		}
		/*
		 * User does want to save the link.  - FM
		 */
		if (links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    save_bookmark_link(links[curdoc.link].lname,
				       LYGetHiliteStr(curdoc.link, 0));
		    *refresh_screen = TRUE;	/* MultiBookmark support */
		} else {
		    HTUserMsg(NOBOOK_FORM_FIELD);
		    return;
		}
	    } else {
		return;
	    }
	} else if (curdoc.post_data != NULL) {
	    /*
	     * No links, and document has POST content.  - FM
	     */
	    HTUserMsg(NOBOOK_POST_FORM);
	    return;
	} else if (curdoc.bookmark != NULL) {
	    /*
	     * It's a bookmark file from which all of the links were deleted. 
	     * - FM
	     */
	    HTUserMsg(BOOKMARKS_NOLINKS);
	    return;
	} else {
	    _statusline(BOOK_D_OR_CANCEL);
	    if (LYgetch_single() == 'D') {
		save_bookmark_link(curdoc.address, curdoc.title);
		*refresh_screen = TRUE;		/* MultiBookmark support */
	    } else {
		return;
	    }
	}
      check_add_bookmark_to_self:
	if (curdoc.bookmark && BookmarkPage &&
	    !strcmp(curdoc.bookmark, BookmarkPage)) {
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    newdoc.internal_link = FALSE;
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOBOOK_HSML);
	}
    }
}

static void handle_LYK_CLEAR_AUTH(int *old_c,
				  int real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	if (HTConfirm(CLEAR_ALL_AUTH_INFO)) {
	    FREE(authentication_info[0]);
	    FREE(authentication_info[1]);
	    FREE(proxyauth_info[0]);
	    FREE(proxyauth_info[1]);
	    HTClearHTTPAuthInfo();
#ifndef DISABLE_NEWS
	    HTClearNNTPAuthInfo();
#endif
#ifndef DISABLE_FTP
	    HTClearFTPPassword();
#endif
	    HTUserMsg(AUTH_INFO_CLEARED);
	} else {
	    HTUserMsg(CANCELLED);
	}
    }
}

static int handle_LYK_COMMAND(char *user_input_buffer)
{
    int ch;
    Kcmd *mp;
    char *src, *tmp;

    *user_input_buffer = 0;
    _statusline(": ");
    if (LYgetstr(user_input_buffer, VISIBLE, MAX_LINE, RECALL_CMD) >= 0) {
	src = LYSkipBlanks(user_input_buffer);
	tmp = LYSkipNonBlanks(src);
	*tmp = 0;
	ch = ((mp = LYStringToKcmd(src)) != 0) ? mp->code : 0;
	CTRACE((tfp, "LYK_COMMAND(%s.%s) = %d\n", src, tmp, ch));
	if (ch == 0) {
	    return *src ? -1 : 0;
	}
	/* FIXME: reuse the rest of the buffer for parameters */
	return ch;
    }
    return 0;
}

static void handle_LYK_COMMENT(BOOLEAN *refresh_screen,
			       char **owner_address_p,
			       int *old_c,
			       int real_c)
{
    int c;

    if (!*owner_address_p &&
	strncasecomp(curdoc.address, "http", 4)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_OWNER);
	}
    } else if (no_mail) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(MAIL_DISALLOWED);
	}
    } else {
	if (HTConfirmDefault(CONFIRM_COMMENT, NO)) {
	    if (!*owner_address_p) {
		/*
		 * No owner defined, so make a guess and and offer it to the
		 * user.  - FM
		 */
		char *address = NULL;
		char *temp = HTParse(curdoc.address, "", PARSE_PATH);
		char *cp;

		if (temp != NULL) {
		    HTUnEscape(temp);
		    if (*temp == '~' && strlen(temp) > 1) {
			/*
			 * It's a ~user URL so guess user@@host.  - FM
			 */
			if ((cp = strchr((temp + 1), '/')) != NULL)
			    *cp = '\0';
			StrAllocCopy(address, STR_MAILTO_URL);
			StrAllocCat(address, (temp + 1));
			StrAllocCat(address, "@@");
		    }
		    FREE(temp);
		}
		if (address == NULL)
		    /*
		     * Wasn't a ~user URL so guess WebMaster@@host.  - FM
		     */
		    StrAllocCopy(address, "mailto:WebMaster@@");
		temp = HTParse(curdoc.address, "", PARSE_HOST);
		StrAllocCat(address, temp);
		HTSprintf0(&temp, NO_OWNER_USE, address);
		c = HTConfirmDefault(temp, NO);
		FREE(temp);
		if (c == YES) {
		    StrAllocCopy(*owner_address_p, address);
		    FREE(address);
		} else {
		    FREE(address);
		    return;
		}
	    }
	    if (is_url(*owner_address_p) != MAILTO_URL_TYPE) {
		/*
		 * The address is a URL.  Just follow the link.
		 */
		set_address(&newdoc, *owner_address_p);
		newdoc.internal_link = FALSE;
	    } else {
		/*
		 * The owner_address is a mailto:  URL.
		 */
		const char *kp = HText_getRevTitle();
		const char *id = HText_getMessageID();
		char *tmptitle = NULL;

		if (!kp && HTMainAnchor) {
		    kp = HTAnchor_subject(HTMainAnchor);
		    if (non_empty(kp)) {
			if (strncasecomp(kp, "Re: ", 4)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, kp);
			    kp = tmptitle;
			}
		    }
		}

		if (strchr(*owner_address_p, ':') != NULL)
		    /*
		     * Send a reply.  The address is after the colon.
		     */
		    reply_by_mail(strchr(*owner_address_p, ':') + 1,
				  curdoc.address,
				  NonNull(kp), id);
		else
		    reply_by_mail(*owner_address_p, curdoc.address,
				  NonNull(kp), id);

		FREE(tmptitle);
		*refresh_screen = TRUE;		/* to force a showpage */
	    }
	}
    }
}

static BOOLEAN handle_LYK_COOKIE_JAR(int *cmd)
{
    /*
     * Don't do if already viewing the cookie jar.
     */
    if (!isLYNXCOOKIE(curdoc.address)) {
	set_address(&newdoc, "LYNXCOOKIE:/");
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in the cookie jar, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

#if defined(DIRED_SUPPORT)
static void handle_LYK_CREATE(void)
{
    if (lynx_edit_mode && !no_dired_support) {
	if (local_create(&curdoc) > 0) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link > -1 ? curdoc.link : 0;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
{
    if (curdoc.bookmark != NULL) {
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE, NO) != YES)
	    return;
	remove_bookmark_link(links[curdoc.link].anchor_number - 1,
			     curdoc.bookmark);
    } else {			/* behave like REFRESH for backward compatibility */
	*refresh_screen = TRUE;
	if (*old_c != real_c) {
	    *old_c = real_c;
	    lynx_force_repaint();
	}
	return;
    }
    do_cleanup_after_delete();
}

#if defined(DIRED_SUPPORT) || defined(VMS)
static void handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen,
				  int *old_c GCC_UNUSED,
				  int real_c GCC_UNUSED)
{
#ifdef VMS
    char *cp, *temp = 0;
    const char *test = HTGetProgramPath(ppCSWING);

    /*
     * Check if the CSwing Directory/File Manager is available.  Will be
     * disabled if CSWING path is NULL, zero-length, or "none" (case
     * insensitive), if no_file_url was set via the file_url restriction, if
     * no_goto_file was set for the anonymous account, or if HTDirAccess was
     * set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse or -selective
     * switches.  - FM
     */
    if (isEmpty(test) ||
	!strcasecomp(test, "none") ||
	no_file_url || no_goto_file ||
	HTDirAccess == HT_DIR_FORBID ||
	HTDirAccess == HT_DIR_SELECTIVE) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(DFM_NOT_AVAILABLE);
	}
	return;
    }

    /*
     * If we are viewing a local directory listing or a local file which is not
     * temporary, invoke CSwing with the URL's directory converted to VMS path
     * specs and passed as the argument, so we start up CSwing positioned on
     * that node of the directory tree.  Otherwise, pass the current default
     * directory as the argument.  - FM
     */
    if (LYisLocalFile(curdoc.address) &&
	strncasecomp(curdoc.address,
		     lynx_temp_space, strlen(lynx_temp_space))) {
	/*
	 * We are viewing a local directory or a local file which is not
	 * temporary.  - FM
	 */
	struct stat stat_info;

	cp = HTParse(curdoc.address, "", PARSE_PATH | PARSE_PUNCTUATION);
	HTUnEscape(cp);
	if (HTStat(cp, &stat_info) == -1) {
	    CTRACE((tfp, "mainloop: Can't stat %s\n", cp));
	    FREE(cp);
	    HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	    *refresh_screen = TRUE;	/* redisplay */
	} else {
	    char *VMSdir = NULL;

	    if (S_ISDIR(stat_info.st_mode)) {
		/*
		 * We're viewing a local directory.  Make that the CSwing
		 * argument.  - FM
		 */
		LYAddPathSep(&cp);
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
	    } else {
		/*
		 * We're viewing a local file.  Make its directory the CSwing
		 * argument.  - FM
		 */
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
		if ((cp = strrchr(VMSdir, ']')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		} else if ((cp = strrchr(VMSdir, ':')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		}
	    }
	    HTSprintf0(&temp, "%s %s", HTGetProgramPath(ppCSWING), VMSdir);
	    FREE(VMSdir);
	    /*
	     * Uncache the current document in case we change, move, or delete
	     * it during the CSwing session.  - FM
	     */
	    /* could use DIRED_UNCACHE_1 but it's currently only defined
	       for dired - kw */
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.title, NonNull(curdoc.title));
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
    } else {
	/*
	 * We're not viewing a local directory or file.  Pass CSwing the
	 * current default directory as an argument and don't uncache the
	 * current document.  - FM
	 */
	HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	*refresh_screen = TRUE;	/* redisplay */
    }
    stop_curses();
    LYSystem(temp);
    start_curses();
    FREE(temp);
#else
    /*
     * Don't do if not allowed or already viewing the menu.
     */
    if (lynx_edit_mode && !no_dired_support &&
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	strcmp(NonNull(curdoc.title), DIRED_MENU_TITLE)) {
	dired_options(&curdoc, &newdoc.address);
	*refresh_screen = TRUE;	/* redisplay */
    }
#endif /* VMS */
}
#endif /* defined(DIRED_SUPPORT) || defined(VMS) */

static int handle_LYK_DOWNLOAD(int *cmd,
			       int *old_c,
			       int real_c)
{

    /*
     * Don't do if both download and disk_save are restricted.
     */
    if (LYValidate ||
	(no_download && !override_no_download && no_disk_save)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(DOWNLOAD_DISABLED);
	}
	return 0;
    }

    /*
     * Don't do if already viewing download options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS))
	return 0;

    if (do_change_link() == -1)
	return 1;		/* mouse stuff was confused, ignore - kw */
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) {
		if (links[curdoc.link].l_form->submit_method ==
		    URL_MAIL_METHOD) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_MAILTO_ACTION);
		    }
		    return 0;
		}
		if (isLYNXOPTIONS(links[curdoc.link].l_form->submit_action)) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_SPECIAL);
		    }
		    return 0;
		}
		HTOutputFormat = HTAtom_for("www/download");
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return 2;
	    }
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_INPUT);
	    }

	} else if (isLYNXCOOKIE(curdoc.address)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_COOKIES);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PRINT_OP);
	    }
#ifdef DIRED_SUPPORT
	} else if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_UPLOAD_OP);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PERMIT_OP);
	    }

	} else if (lynx_edit_mode && !no_dired_support &&
		   !strstr(links[curdoc.link].lname, "/SugFile=")) {
	    /*
	     * Don't bother making a /tmp copy of the local file.
	     */
	    static DocInfo temp;

	    copy_address(&temp, &newdoc);
	    set_address(&newdoc, links[curdoc.link].lname);
	    if (LYdownload_options(&newdoc.address,
				   links[curdoc.link].lname) < 0)
		copy_address(&newdoc, &temp);
	    else
		newdoc.internal_link = FALSE;
	    LYFreeDocInfo(&temp);
#endif /* DIRED_SUPPORT */

	} else if (LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		   isLYNXHIST(links[curdoc.link].lname)) {
	    int number = atoi(links[curdoc.link].lname + LEN_LYNXHIST);

	    if (number >= nhist || number < 0) {
		HTUserMsg(NO_DOWNLOAD_SPECIAL);
		return 0;
	    }
	    if ((HDOC(number).post_data != NULL &&
		 HDOC(number).safe != TRUE) &&
		HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
		HTInfoMsg(CANCELLED);
		return 0;
	    }
	    /*
	     * OK, we download from history page, restore URL from stack.
	     */
	    copy_address(&newdoc, &HDOC(number));
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
	    StrAllocCopy(newdoc.bookmark, HDOC(number).bookmark);
	    LYFreePostData(&newdoc);
	    if (HDOC(number).post_data)
		BStrCopy(newdoc.post_data,
			 HDOC(number).post_data);
	    if (HDOC(number).post_content_type)
		StrAllocCopy(newdoc.post_content_type,
			     HDOC(number).post_content_type);
	    newdoc.isHEAD = HDOC(number).isHEAD;
	    newdoc.safe = HDOC(number).safe;
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    LYUserSpecifiedURL = TRUE;
	    /*
	     * Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;

	} else if (!strncmp(links[curdoc.link].lname, "data:", 5)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTAlert(UNSUPPORTED_DATA_URL);
	    }

	} else if (isLYNXCOOKIE(links[curdoc.link].lname) ||
		   isLYNXDIRED(links[curdoc.link].lname) ||
		   isLYNXDOWNLOAD(links[curdoc.link].lname) ||
		   isLYNXPRINT(links[curdoc.link].lname) ||
		   isLYNXOPTIONS(links[curdoc.link].lname) ||
		   isLYNXHIST(links[curdoc.link].lname) ||
	    /* handled above if valid - kw */
/* @@@@@@ should next two be downloadable? - kw */
		   isLYNXHIST(links[curdoc.link].lname) ||
		   isLYNXCFLAGS(links[curdoc.link].lname) ||
		   isLYNXEXEC(links[curdoc.link].lname) ||
		   isLYNXPROG(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_SPECIAL);

	} else if (isMAILTO_URL(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_MAILTO_LINK);

	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     *
	     * We copy all these checks from getfile() to LYK_DOWNLOAD here
	     * because LYNXDOWNLOAD:// will NOT be pushing the previous
	     * document into the history stack so preserve getfile() from
	     * returning a wrong status (NULLFILE).
	     */
	} else if (local_host_only &&
		   !(LYisLocalHost(links[curdoc.link].lname) ||
		     LYisLocalAlias(links[curdoc.link].lname))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	} else {		/* Not a forms, options or history link */
	    /*
	     * Follow a normal link or anchor.  Note that if it's an anchor
	     * within the same document, entire document will be downloaded.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /*
	     * Might be an internal link in the same doc from a POST form.  If
	     * so, don't free the content.  - kw
	     */
	    if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE)
#else
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc))
#endif /* TRACK_INTERNAL_LINKS */
	    {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
	    }
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    /*
	     * Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NO_DOWNLOAD_CHOICE);
    }
    return 0;
}

static void handle_LYK_DOWN_HALF(int *old_c,
				 int real_c)
{
    int i;

    if (more) {
	Newline += (display_lines / 2);
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > display_lines / 2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= (display_lines / 2); i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_DOWN_LINK(int *follow_col,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link < (nlinks - 1)) {	/* more links? */
	int newlink;

	if (*follow_col == -1) {
	    const char *text = LYGetHiliteStr(curdoc.link, 0);

	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, 1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (more) {	/* next page */
	    Newline += (display_lines);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_BELOW);
	    return;
	}
    } else if (more) {		/* next page */
	Newline += (display_lines);

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_DOWN_TWO(int *old_c,
				int real_c)
{
    int i;

    if (more) {
	Newline += 2;
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > 2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= 2; i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static int handle_LYK_DWIMEDIT(int *cmd,
			       int *old_c,
			       int real_c)
{
#ifdef TEXTAREA_AUTOEXTEDIT
    /*
     * If we're in a forms TEXTAREA, invoke the editor on *its* contents,
     * rather than attempting to edit the html source document.  KED
     */
    if (nlinks > 0 &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	*cmd = LYK_EDIT_TEXTAREA;
	return 2;
    }

    /*
     * If we're in a forms TEXT type, tell user the request is bogus (though in
     * reality, without this trap, if the document with the TEXT field is
     * local, the editor *would* be invoked on the source .html file; eg, the
     * o(ptions) form tempfile).
     *
     * [This is done to avoid possible user confusion, due to auto invocation
     * of the editor on the TEXTAREA's contents via the above if() statement.]
     */
    if (nlinks > 0 &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXT_TYPE) {
	HTUserMsg(CANNOT_EDIT_FIELD);
	return 1;
    }

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
	return 1;
    }
#endif /* TEXTAREA_AUTOEXTEDIT */
    return 0;
}

static int handle_LYK_ECGOTO(int *ch,
			     char *user_input_buffer,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 * Go to not allowed.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 * Disallow editing of File Management URLs.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */

    /*
     * Save the current user_input_buffer string, and load the current
     * document's address.
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      curdoc.address,
	      (MAX_LINE - 1));

    /*
     * Warn the user if the current document has POST data associated with it. 
     * - FM
     */
    if (curdoc.post_data)
	HTAlert(CURRENT_DOC_HAS_POST_DATA);

    /*
     * Offer the current document's URL for editing.  - FM
     */
    _statusline(EDIT_CURDOC_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			 MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer, curdoc.address)) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}

static void handle_LYK_EDIT(int *old_c,
			    int real_c)
{
#ifdef DIRED_SUPPORT
    char *cp;
    char *tp = NULL;
    struct stat dir_info;
#endif /* DIRED_SUPPORT */

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_DISABLED);
	}
    } else
#ifdef DIRED_SUPPORT
	/*
	 * Allow the user to edit the link rather than curdoc in edit mode.
	 */
	if (lynx_edit_mode &&
	    non_empty(editor) && !no_dired_support) {
	if (nlinks > 0) {
	    cp = links[curdoc.link].lname;
	    if (is_url(cp) == FILE_URL_TYPE) {
		cp = HTfullURL_toFile(cp);
		StrAllocCopy(tp, cp);
		FREE(cp);

		if (stat(tp, &dir_info) == -1) {
		    HTAlert(NO_STATUS);
		} else {
		    if (S_ISREG(dir_info.st_mode)) {
			StrAllocCopy(tp, links[curdoc.link].lname);
			HTUnEscapeSome(tp, "/");
			if (edit_current_file(tp, curdoc.link, Newline)) {
			    DIRED_UNCACHE_1;
			    move_address(&newdoc, &curdoc);
#ifdef NO_SEEK_OLD_POSITION
			    /*
			     * Go to top of file.
			     */
			    newdoc.line = 1;
			    newdoc.link = 0;
#else
			    /*
			     * Seek old position, which probably changed.
			     */
			    newdoc.line = curdoc.line;
			    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
			    LYclear();	/* clear the screen */
			}
		    }
		}
		FREE(tp);
	    }
	}
    } else
#endif /* DIRED_SUPPORT */
    if (non_empty(editor)) {
	if (edit_current_file(newdoc.address, curdoc.link, Newline)) {
	    HTuncache_current_document();
	    LYforce_no_cache = TRUE;	/*force reload of document */
	    free_address(&curdoc);	/* so it doesn't get pushed */
#ifdef NO_SEEK_OLD_POSITION
	    /*
	     * Go to top of file.
	     */
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    /*
	     * Seek old position, which probably changed.
	     */
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
	    LYclear();		/* clear the screen */
	}

    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
}

static void handle_LYK_DWIMHELP(const char **cshelpfile)
{
    /*
     * Currently a help file different from the main 'helpfile' is shown only
     * if current link is a text input form field.  - kw
     */
    if (curdoc.link >= 0 && curdoc.link < nlinks &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	!links[curdoc.link].l_form->disabled &&
	F_TEXTLIKE(links[curdoc.link].l_form->type)) {
	*cshelpfile = LYLineeditHelpURL();
    }
}

static void handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
{
    int n;

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
    } else if (!editor || *editor == '\0') {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
    /*
     * See if the current link is in a form TEXTAREA.
     */
    else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {

	/* stop screen */
	stop_curses();

	n = HText_ExtEditForm(&links[curdoc.link]);

	/*
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st trailing blank line in the now edited TEXTAREA.  If the target
	 * line/ anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
	 */

/* curdoc.link += n; *//* works, except for page crossing, */
	/* damnit; why is nothing ever easy */

	/* start screen */
	start_curses();
	*refresh_screen = TRUE;

    } else {

	HTInfoMsg(NOT_IN_TEXTAREA_NOEDIT);
    }
}

static int handle_LYK_ELGOTO(int *ch,
			     char *user_input_buffer,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 * Go to not allowed.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
    if (!(nlinks > 0 && curdoc.link > -1) ||
	(links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	 links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE)) {
	/*
	 * No links on page, or not a normal link or form submit button.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	}
	return 0;
    }
    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
	(!links[curdoc.link].l_form->submit_action ||
	 *links[curdoc.link].l_form->submit_action == '\0')) {
	/*
	 * Form submit button with no ACTION defined.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_FORM_ACTION);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (isLYNXDIRED(links[curdoc.link].lname) ||
	LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 * Disallow editing of File Management URLs.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */

    /*
     * Save the current user_input_buffer string, and load the current link's
     * address.  - FM
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
	       ?
	       links[curdoc.link].l_form->submit_action : links[curdoc.link].lname),
	      (MAX_LINE - 1));

    /*
     * Offer the current link's URL for editing.  - FM
     */
    _statusline(EDIT_CURLINK_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			 MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer,
	       ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
		? links[curdoc.link].l_form->submit_action
		: links[curdoc.link].lname))) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}

#ifdef USE_EXTERNALS
static void handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen)
{
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL)) {
	run_external(links[curdoc.link].lname, FALSE);
	*refresh_screen = TRUE;
    }
}

static void handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen)
{
    if (curdoc.address != NULL) {
	run_external(curdoc.address, FALSE);
	*refresh_screen = TRUE;
    }
}
#endif

static BOOLEAN handle_LYK_FASTBACKW_LINK(int *cmd,
					 int *old_c,
					 int real_c)
{
    int samepage = 0, nextlink = curdoc.link;
    int res;

    if (nlinks > 1) {

	/*
	 * If in textarea, move to first link or textarea group before it if
	 * there is one on this screen.  - kw
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link > 0 &&
		!(links[0].type == WWW_FORM_LINK_TYPE &&
		  links[0].l_form->type == F_TEXTAREA_TYPE &&
		  links[0].l_form->number == thisgroup &&
		  sametext(links[0].l_form->name, thisname))) {
		do
		    nextlink--;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;

	    } else if (!more && Newline == 1 &&
		       (links[0].type == WWW_FORM_LINK_TYPE &&
			links[0].l_form->type == F_TEXTAREA_TYPE &&
			links[0].l_form->number == thisgroup &&
			sametext(links[0].l_form->name, thisname)) &&
		       !(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
			 links[nlinks - 1].l_form->number == thisgroup &&
			 sametext(links[nlinks - 1].l_form->name, thisname))) {
		nextlink = nlinks - 1;
		samepage = 1;

	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link > 0) {
	    nextlink--;
	    samepage = 1;
	} else if (!more && Newline == 1) {
	    nextlink = nlinks - 1;
	    samepage = 1;
	}
    }
    if (samepage) {
	/*
	 * If the link as determined so far is part of a group of textarea
	 * fields, try to use the first of them that's on the screen instead. 
	 * - kw
	 */
	if (nextlink > 0 &&
	    links[nextlink].type == WWW_FORM_LINK_TYPE &&
	    links[nextlink].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[nextlink].l_form->number;
	    char *thisname = links[nextlink].l_form->name;

	    if (links[0].type == WWW_FORM_LINK_TYPE &&
		links[0].l_form->type == F_TEXTAREA_TYPE &&
		links[0].l_form->number == thisgroup &&
		sametext(links[0].l_form->name, thisname)) {
		nextlink = 0;
	    } else
		while
		    (nextlink > 1 &&
		     links[nextlink - 1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink - 1].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink - 1].l_form->number == thisgroup &&
		     sametext(links[nextlink - 1].l_form->name, thisname)) {
		    nextlink--;
		}
	}
	set_curdoc_link(nextlink);
	return FALSE;		/* and we are done. */

    } else if (Newline > 1 &&	/* need a previous page */
	       (res = HTGetLinkOrFieldStart(curdoc.link,
					    &Newline, &newdoc.link,
					    -1, TRUE)) != NO) {
	if (res == LINK_DO_ARROWUP) {
	    /*
	     * It says we should use the normal PREV_LINK mechanism, so we'll
	     * do that.  - kw
	     */
	    if (nlinks > 0)
		curdoc.link = 0;
	    *cmd = LYK_PREV_LINK;
	    return TRUE;
	}
	Newline++;		/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_ABOVE);
    }
    return FALSE;
}

static void handle_LYK_FASTFORW_LINK(int *old_c,
				     int real_c)
{
    int samepage = 0, nextlink = curdoc.link;

    if (nlinks > 1) {

	/*
	 * If in textarea, move to first link or field after it if there is one
	 * on this screen.  - kw
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link < nlinks - 1 &&
		!(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
		  links[nlinks - 1].l_form->number == thisgroup &&
		  sametext(links[nlinks - 1].l_form->name, thisname))) {
		do
		    nextlink++;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;
	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link < nlinks - 1) {
	    nextlink++;
	    samepage = 1;
	} else if (!more && Newline == 1 && curdoc.link > 0) {
	    nextlink = 0;
	    samepage = 1;
	}
    }
    if (samepage) {
	set_curdoc_link(nextlink);
	return;			/* and we are done. */

	/*
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
	 */
    } else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
	set_curdoc_link(0);

    } else if (more &&		/* need a later page */
	       HTGetLinkOrFieldStart(curdoc.link,
				     &Newline, &newdoc.link,
				     1, TRUE) != NO) {
	Newline++;		/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_BELOW);
    }
    return;
}

static void handle_LYK_FIRST_LINK(void)
{
    int i = curdoc.link;

    for (;;) {
	if (--i < 0
	    || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i + 1);
	    break;
	}
    }
}

static BOOLEAN handle_LYK_GOTO(int *ch,
			       char *user_input_buffer,
			       char **old_user_input,
			       RecallType * recall,
			       int *URLTotal,
			       int *URLNum,
			       BOOLEAN *FirstURLRecall,
			       int *old_c,
			       int real_c)
{

    if (no_goto && !LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return FALSE;
    }

    StrAllocCopy(*old_user_input, user_input_buffer);
    if (!goto_buffer)
	*user_input_buffer = '\0';

    *URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
    if (goto_buffer && *user_input_buffer) {
	*recall = ((*URLTotal > 1) ? RECALL_URL : NORECALL);
	*URLNum = 0;
	*FirstURLRecall = FALSE;
    } else {
	*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
	*URLNum = *URLTotal;
	*FirstURLRecall = TRUE;
    }

    /*
     * Ask the user.
     */
    _statusline(URL_TO_OPEN);
    if ((*ch = LYgetstr(user_input_buffer, VISIBLE,
			MAX_LINE, *recall)) < 0) {
	/*
	 * User cancelled the Goto via ^G.  Restore user_input_buffer and
	 * break.  - FM
	 */
	LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	FREE(*old_user_input);
	HTInfoMsg(CANCELLED);
	return FALSE;
    }
    return TRUE;
}

static void handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen)
{
    /*
     * See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {

	HText_ExpandTextarea(&links[curdoc.link], TEXTAREA_EXPAND_SIZE);

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg(NOT_IN_TEXTAREA);
    }
}

static BOOLEAN handle_LYK_HEAD(int *cmd)
{
    int c;

    if (nlinks > 0 &&
	(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
	 links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE)) {
	/*
	 * We have links, and the current link is a normal link or a form's
	 * submit button.  - FM
	 */
	_statusline(HEAD_D_L_OR_CANCEL);
	c = LYgetch_single();
	if (c == 'D') {
	    char *scheme = !isLYNXIMGMAP(curdoc.address)
	    ? curdoc.address
	    : curdoc.address + LEN_LYNXIMGMAP;

	    if (LYCanDoHEAD(scheme) != TRUE) {
		HTUserMsg(DOC_NOT_HTTP_URL);
	    } else {
		/*
		 * Check if this is a reply from a POST, and if so, seek
		 * confirmation if the safe element is not set.  - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
		    HTInfoMsg(CANCELLED);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HText_setNoCache(HTMainText);
			free_address(&curdoc);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
		    }
		}
	    }
	} else if (c == 'L') {
	    if (links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		strncmp(links[curdoc.link].lname, "http", 4) &&
		strncmp(links[curdoc.link].lname,
			"LYNXIMGMAP:http", 15) &&
		LYCanDoHEAD(links[curdoc.link].lname) != TRUE &&
		(links[curdoc.link].type != WWW_INTERN_LINK_TYPE ||
		 !curdoc.address ||
		 strncmp(curdoc.address, "http", 4))) {
		HTUserMsg(LINK_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->disabled) {
		HTUserMsg(FORM_ACTION_DISABLED);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       !isLYNXCGI(links[curdoc.link].l_form->submit_action) &&
		       strncmp(links[curdoc.link].l_form->submit_action,
			       "http", 4)) {
		HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->submit_method ==
		       URL_POST_METHOD &&
		       HTConfirm(CONFIRM_POST_LINK_HEAD) == FALSE) {
		HTInfoMsg(CANCELLED);
	    } else {
		HEAD_request = TRUE;
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return TRUE;
	    }
	}
    } else {
	/*
	 * We can offer only this document for a HEAD request.  Check if this
	 * is a reply from a POST, and if so, seek confirmation if the safe
	 * element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
	    HTInfoMsg(CANCELLED);
	} else {
	    if (nlinks > 0) {
		/*
		 * The current link is a non-submittable form link, so prompt
		 * the user to make it clear that the HEAD request would be for
		 * the current document, not the form link.  - FM
		 */
		_statusline(HEAD_D_OR_CANCEL);
		c = LYgetch_single();
	    } else {
		/*
		 * No links, so we can just assume that the user wants a HEAD
		 * request for the current document.  - FM
		 */
		c = 'D';
	    }
	    if (c == 'D') {
		char *scheme = !isLYNXIMGMAP(curdoc.address)
		? curdoc.address
		: curdoc.address + LEN_LYNXIMGMAP;

		/*
		 * The user didn't cancel, so check if a HEAD request is
		 * appropriate for the current document.  - FM
		 */
		if (LYCanDoHEAD(scheme) != TRUE) {
		    HTUserMsg(DOC_NOT_HTTP_URL);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HText_setNoCache(HTMainText);
			free_address(&curdoc);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
		    }
		}
	    }
	}
    }
    return FALSE;
}

static void handle_LYK_HELP(const char **cshelpfile)
{
    char *my_value = NULL;

    if (*cshelpfile == NULL)
	*cshelpfile = helpfile;
    StrAllocCopy(my_value, *cshelpfile);
    LYEnsureAbsoluteURL(&my_value, *cshelpfile, FALSE);
    if (!STREQ(curdoc.address, my_value)) {
	/*
	 * Set the filename.
	 */
	set_address(&newdoc, my_value);
	/*
	 * Make a name for this help file.
	 */
	StrAllocCopy(newdoc.title, gettext("Help Screen"));
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    }
    FREE(my_value);
    *cshelpfile = NULL;		/* reset pointer - kw */
}

static void handle_LYK_HISTORICAL(void)
{
#ifdef USE_SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
#endif
    historical_comments = !historical_comments;
    if (minimal_comments) {
	HTAlert(historical_comments ?
		HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
    } else {
	HTAlert(historical_comments ?
		HISTORICAL_ON_VALID_OFF : HISTORICAL_OFF_VALID_ON);
    }
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}

static BOOLEAN handle_LYK_HISTORY(BOOLEAN ForcePush)
{
    if (curdoc.title && !LYIsUIPage(curdoc.address, UIP_HISTORY)) {
	/*
	 * Don't do this if already viewing history page.
	 *
	 * Push the current file so that the history list contains the current
	 * file for printing purposes.  Pop the file afterwards to prevent
	 * multiple copies.
	 */
	if (TRACE && !LYUseTraceLog && LYCursesON) {
	    LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
	    LYaddstr("\n");
#endif /* USE_SLANG */
	    LYrefresh();
	}
	LYpush(&curdoc, ForcePush);

	/*
	 * Print history options to file.
	 */
	if (showhistory(&newdoc.address) < 0) {
	    LYpop(&curdoc);
	    return TRUE;
	}
	LYRegisterUIPage(newdoc.address, UIP_HISTORY);
	StrAllocCopy(newdoc.title, HISTORY_PAGE_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	newdoc.link = 1;	/*@@@@@@ bypass "recent statusline messages" link */
	free_address(&curdoc);	/* so it doesn't get pushed */

	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
	return TRUE;
    }				/* end if strncmp */
    return FALSE;
}

static BOOLEAN handle_LYK_IMAGE_TOGGLE(int *cmd)
{
    clickable_images = !clickable_images;

    HTUserMsg(clickable_images ?
	      CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
    return reparse_or_reload(cmd);
}

static void handle_LYK_INDEX(int *old_c,
			     int real_c)
{
    /*
     * Make sure we are not in the index already.
     */
    if (!STREQ(curdoc.address, indexfile)) {

	if (indexfile[0] == '\0') {	/* no defined index */
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_INDEX_FILE);
	    }

	} else {
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE) {
		last_kcode = NOKANJI;	/* AUTO */
	    }
#endif
	    set_address(&newdoc, indexfile);
	    StrAllocCopy(newdoc.title, gettext("System Index"));	/* name it */
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	}			/* end else */
    }				/* end if */
}

static void handle_LYK_INDEX_SEARCH(BOOLEAN *force_load,
				    BOOLEAN ForcePush,
				    int *old_c,
				    int real_c)
{
    if (is_www_index) {
	/*
	 * Perform a database search.
	 *
	 * do_www_search will try to go out and get the document.  If it
	 * returns TRUE, a new document was returned and is named in the
	 * newdoc.address.
	 */
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	if (do_www_search(&newdoc) == NORMAL) {
	    /*
	     * Yah, the search succeeded.
	     */
	    if (TRACE && !LYUseTraceLog && LYCursesON) {
		/*
		 * Make sure cursor is down.
		 */
		LYHideCursor();
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
	    }
	    LYpush(&curdoc, ForcePush);
	    /*
	     * Make the curdoc.address the newdoc.address so that getfile
	     * doesn't try to get the newdoc.address.  Since we have already
	     * gotten it.
	     */
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type, curdoc.post_content_type);
	    newdoc.internal_link = FALSE;
	    curdoc.line = -1;
	    Newline = 0;
	} else if (use_this_url_instead != NULL) {
	    /*
	     * Got back a redirecting URL.  Check it out.
	     */
	    HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);

	    /*
	     * Make a name for this URL.
	     */
	    StrAllocCopy(newdoc.title,
			 "A URL specified by redirection");
	    set_address(&newdoc, use_this_url_instead);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(use_this_url_instead);
	    *force_load = TRUE;
	} else {
	    /*
	     * Yuk, the search failed.  Restore the old file.
	     */
	    copy_address(&newdoc, &curdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type,
			 curdoc.post_content_type);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.isHEAD = curdoc.isHEAD;
	    newdoc.safe = curdoc.safe;
	    newdoc.internal_link = curdoc.internal_link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NOT_ISINDEX);
    }
}

static BOOLEAN handle_LYK_INFO(int *cmd)
{
    /*
     * Don't do if already viewing info page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_SHOWINFO)) {
	if (do_change_link() != -1
	    && LYShowInfo(&curdoc, &newdoc, owner_address) >= 0) {
	    LYRegisterUIPage(newdoc.address, UIP_SHOWINFO);
	    StrAllocCopy(newdoc.title, SHOWINFO_TITLE);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYforce_no_cache = TRUE;
	    if (LYValidate || check_realm)
		LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in info page, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

static BOOLEAN handle_LYK_INLINE_TOGGLE(int *cmd)
{
    pseudo_inline_alts = !pseudo_inline_alts;

    HTUserMsg(pseudo_inline_alts ?
	      PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
    return reparse_or_reload(cmd);
}

static void handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen,
				   int *old_c,
				   int real_c)
{
    int n;

    /*
     * See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {

	/*
	 * Reject attempts to use this for gaining access to local files when
	 * such access is restricted:  if no_file_url was set via the file_url
	 * restriction, if no_goto_file was set for the anonymous account, or
	 * if HTDirAccess was set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the
	 * -nobrowse or -selective switches, it is assumed that inserting files
	 * or checking for existence of files needs to be denied.  - kw
	 */
	if (no_file_url || no_goto_file ||
	    HTDirAccess == HT_DIR_FORBID ||
	    HTDirAccess == HT_DIR_SELECTIVE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		if (no_goto_file)
		    HTUserMsg2(GOTO_XXXX_DISALLOWED, STR_FILE_URL);
		else
		    HTUserMsg(NOAUTH_TO_ACCESS_FILES);
		HTInfoMsg(FILE_INSERT_CANCELLED);
	    }
	    return;
	}

	n = HText_InsertFile(&links[curdoc.link]);

	/*
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st line following the text that was inserted.  If the target
	 * line/anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
	 *
	 * [Current behavior leaves cursor on the same line relative to the
	 * start of the TEXTAREA that it was on before the insertion.  This is
	 * the same behavior that occurs with (my) editor, so this TODO will
	 * stay unimplemented.]
	 */

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg(NOT_IN_TEXTAREA);
    }
}

#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
static void handle_LYK_INSTALL(void)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support)
	local_install(NULL, links[curdoc.link].lname, &newdoc.address);
}
#endif

static BOOLEAN handle_LYK_JUMP(int c,
			       char *user_input_buffer,
			       char **old_user_input GCC_UNUSED,
			       RecallType * recall GCC_UNUSED,
			       BOOLEAN *FirstURLRecall GCC_UNUSED,
			       int *URLNum GCC_UNUSED,
			       int *URLTotal GCC_UNUSED,
			       int *ch GCC_UNUSED,
			       int *old_c,
			       int real_c)
{
    char *ret;

    if (no_jump || JThead == NULL) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    if (no_jump)
		HTUserMsg(JUMP_DISALLOWED);
	    else
		HTUserMsg(NO_JUMPFILE);
	}
    } else {
	LYJumpFileURL = TRUE;
	if ((ret = LYJump(c)) != NULL) {
#ifdef PERMIT_GOTO_FROM_JUMP
	    if (!strncasecomp(ret, "Go ", 3)) {
		LYJumpFileURL = FALSE;
		StrAllocCopy(*old_user_input, user_input_buffer);
		*URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
		*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
		*URLNum = *URLTotal;
		*FirstURLRecall = TRUE;
		if (!strcasecomp(ret, "Go :")) {
		    if (recall) {
			*ch = UPARROW;
			return TRUE;
		    }
		    FREE(*old_user_input);
		    HTUserMsg(NO_RANDOM_URLS_YET);
		    return FALSE;
		}
		ret = HTParse((ret + 3), startfile, PARSE_ALL);
		LYstrncpy(user_input_buffer, ret, MAX_LINE - 1);
		FREE(ret);
		return TRUE;
	    }
#endif /* PERMIT_GOTO_FROM_JUMP */
	    ret = HTParse(ret, startfile, PARSE_ALL);
	    if (!LYTrimStartfile(ret)) {
		LYRemoveBlanks(user_input_buffer);
	    }
	    set_address(&newdoc, ret);
	    StrAllocCopy(lynxjumpfile, ret);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(ret);
	    LYUserSpecifiedURL = TRUE;
	} else {
	    LYJumpFileURL = FALSE;
	}
    }
    return FALSE;
}

static void handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag,
			      BOOLEAN *emacs_keys_flag,
			      int *old_c,
			      int real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	set_address(&newdoc, STR_LYNXKEYMAP);
	StrAllocCopy(newdoc.title, CURRENT_KEYMAP_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 * If vi_keys changed, the keymap did too, so force no cache, and reset
	 * the flag.  - FM
	 */
	if (*vi_keys_flag != vi_keys ||
	    *emacs_keys_flag != emacs_keys) {
	    LYforce_no_cache = TRUE;
	    *vi_keys_flag = vi_keys;
	    *emacs_keys_flag = emacs_keys;
	}
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	/*
	 * Remember whether we are in dired menu so we can display the right
	 * keymap.
	 */
	if (!no_dired_support) {
	    prev_lynx_edit_mode = lynx_edit_mode;
	}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	LYforce_no_cache = TRUE;
    }
}

static void handle_LYK_LAST_LINK(void)
{
    int i = curdoc.link;

    for (;;) {
	if (++i >= nlinks
	    || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i - 1);
	    break;
	}
    }
}

static void handle_LYK_LEFT_LINK(void)
{
    if (curdoc.link > 0 &&
	links[curdoc.link].ly == links[curdoc.link - 1].ly) {
	set_curdoc_link(curdoc.link - 1);
    }
}

static BOOLEAN handle_LYK_LIST(int *cmd)
{
    /*
     * Don't do if already viewing list page.
     */
    if (!strcmp(NonNull(curdoc.title), LIST_PAGE_TITLE) &&
	LYIsUIPage(curdoc.address, UIP_LIST_PAGE)) {
	/*
	 * Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print list page to file.
     */
    if (showlist(&newdoc, TRUE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, LIST_PAGE_TITLE);
    /*
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}

static void handle_LYK_MAIN_MENU(int *old_c,
				 int real_c)
{
    /*
     * If its already the homepage then don't reload it.
     */
    if (!STREQ(curdoc.address, homepage)) {

	if (HTConfirmDefault(CONFIRM_MAIN_SCREEN, NO) == YES) {
	    set_address(&newdoc, homepage);
	    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYhighlight(OFF, curdoc.link, prev_target);
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
	    }
#endif /* DIRED_SUPPORT */
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(IN_MAIN_SCREEN);
	}
    }
}

static void handle_LYK_MINIMAL(void)
{
    if (!historical_comments) {
#ifdef USE_SOURCE_CACHE
	if (!HTcan_reparse_document()) {
#endif
	    /*
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HText_setNoCache(HTMainText);
		move_address(&newdoc, &curdoc);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
#ifdef USE_SOURCE_CACHE
	}			/* end if no bypass */
#endif
    }
    minimal_comments = !minimal_comments;
    if (!historical_comments) {
	HTAlert(minimal_comments ?
		MINIMAL_ON_IN_EFFECT : MINIMAL_OFF_VALID_ON);
    } else {
	HTAlert(minimal_comments ?
		MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
    }
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}

#if defined(DIRED_SUPPORT)
static void handle_LYK_MODIFY(BOOLEAN *refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int ret;

	ret = local_modify(&curdoc, &newdoc.address);
	if (ret == PERMIT_FORM_RESULT) {	/* Permit form thrown up */
	    *refresh_screen = TRUE;
	} else if (ret) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

#ifdef EXP_NESTED_TABLES
static BOOLEAN handle_LYK_NESTED_TABLES(int *cmd)
{
    nested_tables = !nested_tables;
    HTUserMsg(nested_tables ? NESTED_TABLES_ON : NESTED_TABLES_OFF);
    return reparse_or_reload(cmd);
}
#endif

static BOOLEAN handle_LYK_OPTIONS(int *cmd,
				  BOOLEAN *refresh_screen)
{
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions) {
	BOOLEAN LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
	BOOLEAN LYSelectPopups_flag = LYSelectPopups;
	BOOLEAN verbose_img_flag = verbose_img;
	BOOLEAN keypad_mode_flag = (BOOL) keypad_mode;
	BOOLEAN show_dotfiles_flag = show_dotfiles;
	BOOLEAN user_mode_flag = (BOOL) user_mode;
	int CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
	int CurrentCharSet_flag = current_char_set;
	int HTfileSortMethod_flag = HTfileSortMethod;
	char *CurrentUserAgent = NULL;
	char *CurrentNegoLanguage = NULL;
	char *CurrentNegoCharset = NULL;

	StrAllocCopy(CurrentUserAgent, NonNull(LYUserAgent));
	StrAllocCopy(CurrentNegoLanguage, NonNull(language));
	StrAllocCopy(CurrentNegoCharset, NonNull(pref_charset));

	LYoptions(); /** do the old-style options stuff **/

	if (keypad_mode_flag != keypad_mode ||
	    (user_mode_flag != user_mode &&
	     (user_mode_flag == NOVICE_MODE ||
	      user_mode == NOVICE_MODE)) ||
	    (((HTfileSortMethod_flag != HTfileSortMethod) ||
	      (show_dotfiles_flag != show_dotfiles)) &&
	     (isFILE_URL(curdoc.address) ||
	      isFTP_URL(curdoc.address))) ||
	    CurrentCharSet_flag != current_char_set ||
	    CurrentAssumeCharSet_flag != UCLYhndl_for_unspec ||
	    verbose_img_flag != verbose_img ||
	    LYUseDefaultRawMode_flag != LYUseDefaultRawMode ||
	    LYSelectPopups_flag != LYSelectPopups ||
	    ((strcmp(CurrentUserAgent, NonNull(LYUserAgent)) ||
	      strcmp(CurrentNegoLanguage, NonNull(language)) ||
	      strcmp(CurrentNegoCharset, NonNull(pref_charset))) &&
	     (!strncmp(curdoc.address, "http", 4) ||
	      isLYNXCGI(curdoc.address)))) {

	    BOOLEAN canreparse_post = FALSE;

	    /*
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
#ifdef USE_SOURCE_CACHE
		(!(canreparse_post = HTcan_reparse_document())) &&
#endif
		confirm_post_resub(curdoc.address, curdoc.title,
				   2, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		copy_address(&newdoc, &curdoc);
		if (((strcmp(CurrentUserAgent, NonNull(LYUserAgent)) ||
		      strcmp(CurrentNegoLanguage, NonNull(language)) ||
		      strcmp(CurrentNegoCharset, NonNull(pref_charset))) &&
		     (strncmp(curdoc.address, "http", 4) == 0 ||
		      !isLYNXCGI(curdoc.address) == 0))) {
		    /*
		     * An option has changed which may influence content
		     * negotiation, and the resource is from a http or https or
		     * lynxcgi URL (the only protocols which currently do
		     * anything with this information).  Set reloading = TRUE
		     * so that proxy caches will be flushed, which is necessary
		     * until the time when all proxies understand HTTP 1.1
		     * Vary:  and all Servers properly use it...  Treat like
		     * case LYK_RELOAD (see comments there).  - KW
		     */
		    reloading = TRUE;
		}
		if (HTisDocumentSource()) {
		    srcmode_for_next_retrieval(1);
		}
#ifdef USE_SOURCE_CACHE
		if (reloading == FALSE) {
		    /* one more attempt to be smart enough: */
		    if (reparse_document()) {
			FREE(CurrentUserAgent);
			FREE(CurrentNegoLanguage);
			FREE(CurrentNegoCharset);
			return FALSE;
		    }
		}
#endif
		if (canreparse_post &&
		    confirm_post_resub(curdoc.address, curdoc.title,
				       2, 1) == FALSE) {
		    if (HTisDocumentSource()) {
			srcmode_for_next_retrieval(0);
		    }
		    FREE(CurrentUserAgent);
		    FREE(CurrentNegoLanguage);
		    FREE(CurrentNegoCharset);
		    return FALSE;
		}

		HEAD_request = HTLoadedDocumentIsHEAD();
		HText_setNoCache(HTMainText);
#ifdef NO_ASSUME_SAME_DOC
		newdoc.line = 1;
		newdoc.link = 0;
#else
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
		LYforce_no_cache = TRUE;
		free_address(&curdoc);	/* So it doesn't get pushed. */
	    }
	}
	FREE(CurrentUserAgent);
	FREE(CurrentNegoLanguage);
	FREE(CurrentNegoCharset);
	*refresh_screen = TRUE;	/* to repaint screen */
	return FALSE;
    }				/* end if !LYUseFormsOptions */
#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS
    /*
     * Generally stolen from LYK_COOKIE_JAR.  Options menu handling is
     * done in postoptions(), called from getfile() currently.
     *
     * postoptions() is also responsible for reloading the document
     * before the 'options menu' but only when (a few) important
     * options were changed.
     *
     * It is critical that post_data is freed here since the
     * submission of changed options is done via the same protocol as
     * LYNXOPTIONS:
     */
    /*
     * Don't do if already viewing options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU)) {

	set_address(&newdoc, LYNXOPTIONS_PAGE("/"));
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	/* change to 'if (check_realm && !LYValidate)' and
	   make change near top of getfile to forbid
	   using forms options menu with -validate:  - kw */
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in the options menu, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
#endif /* !NO_OPTION_FORMS */
    return FALSE;
}

static void handle_NEXT_DOC(void)
{
    if (LYhist_next(&curdoc, &newdoc)) {
	free_address(&curdoc);	/* avoid push */
	return;
    }
    HTUserMsg(gettext("No next document present"));
}

static void handle_LYK_NEXT_LINK(int c,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link < nlinks - 1) {	/* next link */
	LYhighlight(OFF, curdoc.link, prev_target);
#ifdef FASTTAB
	/*
	 * Move to different textarea if TAB in textarea.
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
	    c == '\t') {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    do
		curdoc.link++;
	    while ((curdoc.link < nlinks - 1) &&
		   links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		   links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
		   links[curdoc.link].l_form->number == thisgroup &&
		   sametext(links[curdoc.link].l_form->name, thisname));
	} else {
	    curdoc.link++;
	}
#else
	curdoc.link++;
#endif /* FASTTAB */
	/*
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
	 */
    } else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
	set_curdoc_link(0);

    } else if (more) {		/* next page */
	Newline += (display_lines);

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_NEXT_PAGE(int *old_c,
				 int real_c)
{
    if (more) {
	Newline += display_lines;
    } else if (curdoc.link < nlinks - 1) {
	set_curdoc_link(nlinks - 1);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static BOOLEAN handle_LYK_NOCACHE(int *old_c,
				  int real_c)
{
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	    }
	    return FALSE;
	} else {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
    }
    return TRUE;
}

static void handle_LYK_PREV_LINK(int *arrowup,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link > 0) {	/* previous link */
	set_curdoc_link(curdoc.link - 1);

    } else if (!more &&
	       curdoc.link == 0 && Newline == 1) {	/* at the top of list */
	/*
	 * If there is only one page of data and the user goes off the top,
	 * just move the cursor to last link on the page.
	 */
	set_curdoc_link(nlinks - 1);

    } else if (curdoc.line > 1) {	/* previous page */
	/*
	 * Go back to the previous page.
	 */
	int scrollamount = (Newline > display_lines ?
			    display_lines : Newline - 1);

	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link == 0 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

#define nhist_1 (nhist - 1)	/* workaround for indent */

static int handle_PREV_DOC(int *cmd,
			   int *old_c,
			   int real_c)
{
    if (nhist > 0) {		/* if there is anything to go back to */
	/*
	 * Check if the previous document is a reply from a POST, and if so,
	 * seek confirmation of resubmission if the safe element is not set and
	 * the document is not still in the cache or LYresubmit_posts is set. 
	 * If not confirmed and it is not the startfile, pop it so we go to the
	 * yet previous document, until we're OK or reach the startfile.  If we
	 * reach the startfile and its not OK or we don't get confirmation,
	 * cancel.  - FM
	 */
	DocAddress WWWDoc;
	HTParentAnchor *tmpanchor;
	HText *text;
	BOOLEAN conf = FALSE, first = TRUE;

	HTLastConfirmCancelled();	/* reset flag */
	while (nhist > 0) {
	    conf = FALSE;
	    if (HDOC(nhist_1).post_data == NULL) {
		break;
	    }
	    WWWDoc.address = HDOC(nhist_1).address;
	    WWWDoc.post_data = HDOC(nhist_1).post_data;
	    WWWDoc.post_content_type =
		HDOC(nhist_1).post_content_type;
	    WWWDoc.bookmark = HDOC(nhist_1).bookmark;
	    WWWDoc.isHEAD = HDOC(nhist_1).isHEAD;
	    WWWDoc.safe = HDOC(nhist_1).safe;
	    tmpanchor = HTAnchor_findAddress(&WWWDoc);
	    if (HTAnchor_safe(tmpanchor)) {
		break;
	    }
	    if (((text = (HText *) HTAnchor_document(tmpanchor)) == NULL &&
		 (isLYNXIMGMAP(WWWDoc.address) ||
		  (conf = confirm_post_resub(WWWDoc.address,
					     HDOC(nhist_1).title,
					     0, 0))
		  == FALSE)) ||
		((LYresubmit_posts && !conf &&
		  (NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &newdoc))) &&
		 !confirm_post_resub(WWWDoc.address,
				     HDOC(nhist_1).title,
				     2, 2))) {
		if (HTLastConfirmCancelled()) {
		    if (!first && curdoc.internal_link)
			free_address(&curdoc);
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		}
		if (nhist == 1) {
		    HTInfoMsg(CANCELLED);
		    *old_c = 0;
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		} else {
		    HTUserMsg2(WWW_SKIP_MESSAGE, WWWDoc.address);
		    do {	/* Should be LYhist_prev when _next supports */
			LYpop(&curdoc);		/* skipping of forms */
		    } while (nhist > 1
			     && !are_different((DocInfo *) &history[nhist_1],
					       &curdoc));
		    first = FALSE;	/* have popped at least one */
		    continue;
		}
	    } else {
		/*
		 * Break from loop; if user just confirmed to load again
		 * because document wasn't in cache, set LYforce_no_cache to
		 * avoid unnecessary repeat question down the road.  - kw
		 */
		if (conf)
		    LYforce_no_cache = TRUE;
		break;
	    }
	}

	if (!first)
	    curdoc.internal_link = FALSE;

	/*
	 * Set newdoc.address to empty to pop a file.
	 */
	LYhist_prev_register(&curdoc);	/* Why not call _prev instead of zeroing address?  */
	free_address(&newdoc);
#ifdef DIRED_SUPPORT
	if (lynx_edit_mode) {
	    DIRED_UNCACHE_2;
	}
#endif /* DIRED_SUPPORT */
    } else if (child_lynx == TRUE) {
	return (1);		/* exit on left arrow in main screen */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(ALREADY_AT_FIRST);
    }
    return 0;
}

static void handle_LYK_PREV_PAGE(int *old_c,
				 int real_c)
{
    if (Newline > 1) {
	Newline -= display_lines;
    } else if (curdoc.link > 0) {
	set_curdoc_link(0);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_PRINT(BOOLEAN *ForcePush,
			     int *old_c,
			     int real_c)
{
    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(PRINT_DISABLED);
	}
	return;
    }

    /*
     * Don't do if already viewing print options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)
	&& print_options(&newdoc.address,
			 curdoc.address, HText_getNumOfLines()) >= 0) {
	LYRegisterUIPage(newdoc.address, UIP_PRINT_OPTIONS);
	StrAllocCopy(newdoc.title, PRINT_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	*ForcePush = TRUE;	/* see LYpush() and print_options() */
	if (check_realm)
	    LYPermitURL = TRUE;
    }
}

static BOOLEAN handle_LYK_QUIT(void)
{
    int c;

    if (LYQuitDefaultYes == TRUE) {
	c = HTConfirmDefault(REALLY_QUIT, YES);
    } else {
	c = HTConfirmDefault(REALLY_QUIT, NO);
    }
    if (LYQuitDefaultYes == TRUE) {
	if (c != NO) {
	    return (TRUE);
	} else {
	    HTInfoMsg(NO_CANCEL);
	}
    } else if (c == YES) {
	return (TRUE);
    } else {
	HTInfoMsg(NO_CANCEL);
    }
    return FALSE;
}

static BOOLEAN handle_LYK_RAW_TOGGLE(int *cmd)
{
    if (HTLoadedDocumentCharset()) {
	HTUserMsg(gettext("charset for this document specified explicitly, sorry..."));
	return FALSE;
    } else {
	LYUseDefaultRawMode = (BOOL) !LYUseDefaultRawMode;
	HTUserMsg(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
	HTMLSetCharacterHandling(current_char_set);
	return reparse_or_reload(cmd);
    }
}

static void handle_LYK_RELOAD(int real_cmd)
{
    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    /*
     * Check to see if should reload source, or load html
     */

    if (HTisDocumentSource()) {
	if ((forced_UCLYhdnl = HTMainText_Get_UCLYhndl()) >= 0)
	    force_old_UCLYhndl_on_reload = TRUE;
	srcmode_for_next_retrieval(1);
    }

    HEAD_request = HTLoadedDocumentIsHEAD();
    HText_setNoCache(HTMainText);
#ifdef NO_ASSUME_SAME_DOC
    /*
     * Don't assume the reloaded document will be the same.  - FM
     */
    newdoc.line = 1;
    newdoc.link = 0;
#else
    /*
     * Do assume the reloaded document will be the same.  - FM
     *
     * (I don't remember all the reasons why we couldn't assume this.  As the
     * problems show up, we'll try to fix them, or add warnings.  - FM)
     */
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
    free_address(&curdoc);	/* so it doesn't get pushed */
#ifdef VMS
    lynx_force_repaint();
#endif /* VMS */
    /*
     * Reload should force a cache refresh on a proxy.  -- Ari L. 
     * <luotonen@@dxcern.cern.ch>
     *
     * -- but only if this was really a reload requested by the user, not if we
     * jumped here to handle reloading for INLINE_TOGGLE, IMAGE_TOGGLE,
     * RAW_TOGGLE, etc.  - KW
     */
    if (real_cmd == LYK_RELOAD)
	reloading = TRUE;

    return;
}

#ifdef DIRED_SUPPORT
static void handle_LYK_REMOVE(BOOLEAN *refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int linkno = curdoc.link;	/* may be changed in local_remove - kw */

	local_remove(&curdoc);
	if (LYAutoUncacheDirLists >= 1)
	    do_cleanup_after_delete();
	else if (curdoc.link != linkno)
	    *refresh_screen = TRUE;
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_RIGHT_LINK(void)
{
    if (curdoc.link < nlinks - 1 &&
	links[curdoc.link].ly == links[curdoc.link + 1].ly) {
	set_curdoc_link(curdoc.link + 1);
    }
}

static void handle_LYK_SHELL(BOOLEAN *refresh_screen,
			     int *old_c,
			     int real_c)
{
    if (!no_shell) {
	stop_curses();
	printf("%s\r\n", SPAWNING_MSG);
#if defined(__CYGWIN__)
	/* handling "exec $SHELL" does not work if $SHELL is null */
	if (LYGetEnv("SHELL") == NULL) {
	    Cygwin_Shell();
	} else
#endif
	{
	    static char *shell = NULL;

	    if (shell == 0)
		StrAllocCopy(shell, LYSysShell());
	    LYSystem(shell);
	}
	start_curses();
	*refresh_screen = TRUE;	/* for an HText_pageDisplay() */
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(SPAWNING_DISABLED);
	}
    }
}

static void handle_LYK_SOFT_DQUOTES(void)
{
#ifdef USE_SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
#endif
    soft_dquotes = !soft_dquotes;
    HTUserMsg(soft_dquotes ?
	      SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}

static void handle_LYK_SOURCE(char **ownerS_address_p)
{
    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
#ifdef USE_SOURCE_CACHE
    BOOLEAN canreparse_post = FALSE;
#endif
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
#ifdef USE_SOURCE_CACHE
	(!(canreparse_post = HTcan_reparse_document())) &&
#endif
	(curdoc.isHEAD ? HTConfirm(CONFIRM_POST_RESUBMISSION) :
	 confirm_post_resub(curdoc.address, curdoc.title, 1, 1)) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (HTisDocumentSource()) {
	srcmode_for_next_retrieval(-1);
    } else {
	if (HText_getOwner())
	    StrAllocCopy(*ownerS_address_p, HText_getOwner());
	LYUCPushAssumed(HTMainAnchor);
	srcmode_for_next_retrieval(1);
    }

#ifdef USE_SOURCE_CACHE
    if (reparse_document()) {
	/*
	 * These normally get cleaned up after getfile() returns;
	 * since we're not calling getfile(), we have to clean them
	 * up ourselves.  -dsb
	 */
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    HTMark_asSource();
	psrc_view = FALSE;
#endif
	FREE(*ownerS_address_p);	/* not used with source_cache */
	LYUCPopAssumed();	/* probably a right place here */
	HTMLSetCharacterHandling(current_char_set);	/* restore now */

	return;
    } else if (canreparse_post) {
	srcmode_for_next_retrieval(0);
	LYUCPopAssumed();	/* probably a right place here */
	return;
    }
#endif

    if (curdoc.title)
	StrAllocCopy(newdoc.title, curdoc.title);
    free_address(&curdoc);	/* so it doesn't get pushed */
    LYforce_no_cache = TRUE;
}

static void handle_LYK_SWITCH_DTD(void)
{
#ifdef USE_SOURCE_CACHE
    BOOLEAN canreparse = FALSE;

    if (!(canreparse = HTcan_reparse_document())) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so,
	 * seek confirmation of reload if the safe element
	 * is not set.  - FM, kw
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    /*
	     * If currently viewing preparsed source, switching to the other
	     * DTD parsing may show source differences, so stay in source view
	     * - kw
	     */

	    /* NOTE: this conditional can be considered incorrect -
	       current behaviour - when viewing source and
	       LYPreparsedSource==TRUE, pressing ^V will toggle parser mode
	       AND switch back from the source view to presentation view.-HV
	     */
	    if (HTisDocumentSource() && LYPreparsedSource) {
		srcmode_for_next_retrieval(1);
	    }
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
#ifdef NO_ASSUME_SAME_DOC
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
#endif
    Old_DTD = !Old_DTD;
    HTSwitchDTD(!Old_DTD);
    HTUserMsg(Old_DTD ? USING_DTD_0 : USING_DTD_1);
#ifdef USE_SOURCE_CACHE
    if (canreparse) {
	if (HTisDocumentSource() && LYPreparsedSource) {
	    srcmode_for_next_retrieval(1);
	}
	if (!reparse_document()) {
	    srcmode_for_next_retrieval(0);
	}
    }
#endif
    return;
}

#ifdef DIRED_SUPPORT
static void handle_LYK_TAG_LINK(void)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	if (!strcmp(LYGetHiliteStr(curdoc.link, 0), ".."))
	    return;		/* Never tag the parent directory */
	if (dir_list_style == MIXED_STYLE) {
	    if (!strcmp(LYGetHiliteStr(curdoc.link, 0), "../"))
		return;
	} else if (!strncmp(LYGetHiliteStr(curdoc.link, 0), "Up to ", 6))
	    return;
	{
	    /*
	     * HTList-based management of tag list, see LYLocal.c - KW
	     */
	    HTList *t1 = tagged;
	    char *tagname = NULL;
	    BOOLEAN found = FALSE;

	    while ((tagname = (char *) HTList_nextObject(t1)) != NULL) {
		if (!strcmp(links[curdoc.link].lname, tagname)) {
		    found = TRUE;
		    HTList_removeObject(tagged, tagname);
		    FREE(tagname);
		    tagflag(OFF, curdoc.link);
		    break;
		}
	    }
	    if (!found) {
		if (tagged == NULL)
		    tagged = HTList_new();
		tagname = NULL;
		StrAllocCopy(tagname, links[curdoc.link].lname);
		HTList_addObject(tagged, tagname);
		tagflag(ON, curdoc.link);
	    }
	}
	if (curdoc.link < nlinks - 1) {
	    set_curdoc_link(curdoc.link + 1);
	} else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
	    set_curdoc_link(0);
	} else if (more) {	/* next page */
	    Newline += (display_lines);
	}
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_TOGGLE_HELP(void)
{
    if (user_mode == NOVICE_MODE) {
	toggle_novice_line();
	noviceline(more);
    }
}

static void handle_LYK_TOOLBAR(BOOLEAN *try_internal,
			       BOOLEAN *force_load,
			       int *old_c,
			       int real_c)
{
    char *cp;
    char *toolbar = NULL;

    if (!HText_hasToolbar(HTMainText)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_TOOLBAR);
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	cp = trimPoundSelector(curdoc.address);
	HTSprintf0(&toolbar, "%s#%s", curdoc.address, LYToolbarName);
	restorePoundSelector(cp);
	set_address(&newdoc, toolbar);
	FREE(toolbar);
	*try_internal = TRUE;
	*force_load = TRUE;	/* force MainLoop to reload */
    }
}

static void handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr)
{
#ifndef NO_LYNX_TRACE
    /*
     * Check whether we've started a TRACE log in this session.  - FM
     */
    if (LYTraceLogFP == NULL) {
	HTUserMsg(NO_TRACELOG_STARTED);
	return;
    }

    /*
     * Don't do if already viewing the TRACE log.  - FM
     */
    if (LYIsUIPage(curdoc.address, UIP_TRACELOG))
	return;

    /*
     * If TRACE mode is on, turn it off during this fetch of the TRACE log, so
     * we don't enter stuff about this fetch, and set a flag for turning it
     * back on when we return to this loop.  Note that we'll miss any messages
     * about memory exhaustion if it should occur.  It seems unlikely that
     * anything else bad might happen, but if it does, we'll miss messages
     * about that too.  We also fflush(), close, and open it again, to make
     * sure all stderr messages thus far will be in the log.  - FM
     */
    if (!LYReopenTracelog(trace_flag_ptr))
	return;

    LYLocalFileToURL(&(newdoc.address), LYTraceLogPath);
    LYRegisterUIPage(newdoc.address, UIP_TRACELOG);
    StrAllocCopy(newdoc.title, LYNX_TRACELOG_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
    }
    LYforce_no_cache = TRUE;
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

#ifdef DIRED_SUPPORT
static void handle_LYK_UPLOAD(void)
{
    /*
     * Don't do if already viewing upload options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS))
	return;

    if (lynx_edit_mode && !no_dired_support) {
	LYUpload_options(&(newdoc.address), curdoc.address);
	StrAllocCopy(newdoc.title, UPLOAD_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 * Uncache the current listing so that it will be updated to included
	 * the uploaded file if placed in the current directory.  - FM
	 */
	DIRED_UNCACHE_1;
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_UP_HALF(int *arrowup,
			       int *old_c,
			       int real_c)
{
    if (Newline > 1) {
	int scrollamount = display_lines / 2;

	if (Newline - scrollamount < 1)
	    scrollamount = Newline - 1;
	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
		    HText_LinksInLines(HTMainText,
				       Newline,
				       scrollamount);
	    } else {
		*arrowup = TRUE;
	    }
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_UP_LINK(int *follow_col,
			       int *arrowup,
			       int *old_c,
			       int real_c)
{
    if (curdoc.link > 0 &&
	(links[0].ly != links[curdoc.link].ly ||
	 !HText_LinksInLines(HTMainText, 1, Newline - 1))) {
	/* more links before this on screen, and first of them on
	   a different line or no previous links before this screen? */
	int newlink;

	if (*follow_col == -1) {
	    const char *text = LYGetHiliteStr(curdoc.link, 0);

	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, -1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_ABOVE);
	}

    } else if (curdoc.line > 1 && Newline > 1) {	/* previous page */
	int scrollamount = (Newline > display_lines ?
			    display_lines : Newline - 1);

	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link > -1 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_UP_TWO(int *arrowup,
			      int *old_c,
			      int real_c)
{
    if (Newline > 1) {
	int scrollamount = (Newline > 2 ? 2 : 1);

	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
		    HText_LinksInLines(HTMainText,
				       Newline, scrollamount);
	    } else {
		*arrowup = TRUE;
	    }
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
{
    const char *cp;

    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    /*
     * See if a bookmark exists.  If it does replace newdoc.address with its
     * name.
     */
    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL) {
	if (*cp == '\0' || !strcmp(cp, " ") ||
	    !strcmp(curdoc.address, newdoc.address)) {
	    if (LYMultiBookmarks != MBM_OFF)
		*refresh_screen = TRUE;
	    return;
	}
#ifdef KANJI_CODE_OVERRIDE
	if (HTCJK == JAPANESE) {
	    last_kcode = NOKANJI;	/* AUTO */
	}
#endif
	LYforce_no_cache = TRUE;	/*force the document to be reloaded */
	StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
	StrAllocCopy(newdoc.bookmark, BookmarkPage);
	LYFreePostData(&newdoc);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    LYMBM_statusline(BOOKMARKS_NOT_OPEN);
	    LYSleepAlert();
	    if (LYMultiBookmarks != MBM_OFF) {
		*refresh_screen = TRUE;
	    }
	}
    }
}

static BOOLEAN handle_LYK_VLINKS(int *cmd,
				 BOOLEAN *newdoc_link_is_absolute)
{
    int c;

    if (LYIsUIPage(curdoc.address, UIP_VLINKS)) {
	/*
	 * Already viewing visited links page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print visited links page to file.
     */
    c = LYShowVisitedLinks(&newdoc.address);
    if (c < 0) {
	HTUserMsg(VISITED_LINKS_EMPTY);
	return FALSE;
    }
    StrAllocCopy(newdoc.title, VISITED_LINKS_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (c > 0) {
	/* Select a correct link. */
	*newdoc_link_is_absolute = TRUE;
	newdoc.link = c - 1;
    }
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlinksfile, newdoc.address);
    }
    return FALSE;
}

void handle_LYK_WHEREIS(int cmd,
			BOOLEAN *refresh_screen)
{
    BOOLEAN have_target_onscreen = (BOOLEAN) (*prev_target != '\0' &&
					      HText_pageHasPrevTarget());
    BOOL found;
    int oldcur = curdoc.link;	/* temporarily remember */
    char *remember_old_target = NULL;

    if (have_target_onscreen)
	StrAllocCopy(remember_old_target, prev_target);
    else
	StrAllocCopy(remember_old_target, "");

    if (cmd == LYK_WHEREIS) {
	/*
	 * Reset prev_target to force prompting for a new search string and to
	 * turn off highlighting if no search string is entered by the user.
	 */
	*prev_target = '\0';
    }
    found = textsearch(&curdoc, prev_target, sizeof(prev_target) - 1,
		       (cmd == LYK_WHEREIS)
		       ? 0
		       : ((cmd == LYK_NEXT)
			  ? 1
			  : -1));

    /*
     * Force a redraw to ensure highlighting of hits even when found on the
     * same page, or clearing of highlighting if the default search string was
     * erased without replacement.  - FM
     */
    /*
     * Well let's try to avoid it at least in a few cases
     * where it is not needed. - kw
     */
    if (www_search_result >= 0 && www_search_result != curdoc.line) {
	*refresh_screen = TRUE;	/* doesn't really matter */
    } else if (!found) {
	*refresh_screen = have_target_onscreen;
    } else if (!have_target_onscreen && found) {
	*refresh_screen = TRUE;
    } else if (www_search_result == curdoc.line &&
	       curdoc.link == oldcur &&
	       curdoc.link >= 0 && nlinks > 0 &&
	       links[curdoc.link].ly >= (display_lines / 3)) {
	*refresh_screen = TRUE;
    } else if ((case_sensitive && 0 != strcmp(prev_target,
					      remember_old_target)) ||
	       (!case_sensitive && 0 != strcasecomp8(prev_target,
						     remember_old_target))) {
	*refresh_screen = TRUE;
    }
    FREE(remember_old_target);
}

/*
 * Get a number from the user and follow that link number.
 */
static void handle_LYK_digit(int c,
			     BOOLEAN *force_load,
			     char *user_input_buffer,
			     int *old_c,
			     int real_c,
			     BOOLEAN *try_internal GCC_UNUSED)
{
    int lindx = ((nlinks > 0) ? curdoc.link : 0);
    int number;
    char *temp = NULL;

    /* pass cur line num for use in follow_link_number()
     * Note: Current line may not equal links[cur].line
     */
    number = curdoc.line;
    switch (follow_link_number(c, lindx, &newdoc, &number)) {
    case DO_LINK_STUFF:
	/*
	 * Follow a normal link.
	 */
	set_address(&newdoc, links[lindx].lname);
	StrAllocCopy(newdoc.title, LYGetHiliteStr(lindx, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	/*
	 * For internal links, retain POST content if present.  If we are on
	 * the List Page, prevent pushing it on the history stack.  Otherwise
	 * set try_internal to signal that the top of the loop should attempt
	 * to reposition directly, without calling getfile.  - kw
	 */
	if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
	    LYinternal_flag = TRUE;
	    newdoc.internal_link = TRUE;
	    if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		(LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		 LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		if (check_history()) {
		    LYinternal_flag = TRUE;
		} else {
		    HTLastConfirmCancelled();	/* reset flag */
		    if (!confirm_post_resub(newdoc.address,
					    newdoc.title,
					    ((LYresubmit_posts &&
					      HText_POSTReplyLoaded(&newdoc))
					     ? 1
					     : 2),
					    2)) {
			if (HTLastConfirmCancelled() ||
			    (LYresubmit_posts &&
			     !HText_POSTReplyLoaded(&newdoc))) {
			    /* cancel the whole thing */
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    copy_address(&newdoc, &curdoc);
			    StrAllocCopy(newdoc.title, curdoc.title);
			    newdoc.internal_link = curdoc.internal_link;
			    HTInfoMsg(CANCELLED);
			    if (nlinks > 0)
				HText_pageDisplay(curdoc.line, prev_target);
			    break;
			} else if (LYresubmit_posts) {
			    /* If LYresubmit_posts is set, and the
			       answer was No, and we have a cached
			       copy, then use it. - kw */
			    LYforce_no_cache = FALSE;
			} else {
			    /* if No, but not ^C or ^G, drop
			     * the post data.  Maybe the link
			     * wasn't meant to be internal after
			     * all, here we can recover from that
			     * assumption. - kw */
			    LYFreePostData(&newdoc);
			    newdoc.internal_link = FALSE;
			    HTAlert(DISCARDING_POST_DATA);
			}
		    }
		}
		/*
		 * Don't push the List Page if we follow an internal link given
		 * by it.  - kw
		 */
		free_address(&curdoc);
	    } else
		*try_internal = TRUE;
	    if (!(LYresubmit_posts && newdoc.post_data))
		LYinternal_flag = TRUE;
	    *force_load = TRUE;
	    break;
	} else {
	    /*
	     * Free POST content if not an internal link.  - kw
	     */
	    LYFreePostData(&newdoc);
	}
#endif /* DONT_TRACK_INTERNAL_LINKS */
	/*
	 * Might be an anchor in the same doc from a POST form.  If so, don't
	 * free the content.  -- FM
	 */
	if (are_different(&curdoc, &newdoc)) {
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    if (isLYNXMESSAGES(newdoc.address))
		LYforce_no_cache = TRUE;
	}
	newdoc.internal_link = FALSE;
	*force_load = TRUE;	/* force MainLoop to reload */
	break;

    case DO_GOTOLINK_STUFF:
	/*
	 * Position on a normal link, don't follow it.  - KW
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
	    /*
	     * It's a link in the current page.  - FM
	     */
	    if (nlinks > 0 && curdoc.link > -1) {
		if (curdoc.link == newdoc.link) {
		    /*
		     * It's the current link, and presumably reflects a typo in
		     * the statusline entry, so issue a statusline message for
		     * the typo-prone users (like me 8-).  - FM
		     */
		    StrAllocCopy(temp, user_input_buffer);
		    sprintf(user_input_buffer,
			    LINK_ALREADY_CURRENT, number);
		    HTUserMsg(user_input_buffer);
		    LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		    FREE(temp);
		} else {
		    /*
		     * It's a different link on this page,
		     */
		    set_curdoc_link(newdoc.link);
		    newdoc.link = 0;
		}
	    }
	}
	break;			/* nothing more to do */

    case DO_GOTOPAGE_STUFF:
	/*
	 * Position on a page in this document.  - FM
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
	    /*
	     * It's the current page, so issue a statusline message for the
	     * typo-prone users (like me 8-).  - FM
	     */
	    if (Newline <= 1) {
		HTInfoMsg(ALREADY_AT_BEGIN);
	    } else if (!more) {
		HTInfoMsg(ALREADY_AT_END);
	    } else {
		StrAllocCopy(temp, user_input_buffer);
		sprintf(user_input_buffer,
			ALREADY_AT_PAGE, number);
		HTUserMsg(user_input_buffer);
		LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		FREE(temp);
	    }
	}
	break;

    case PRINT_ERROR:
	*old_c = real_c;
	HTUserMsg(BAD_LINK_NUM_ENTERED);
	break;
    }
    return;
}

#ifdef SUPPORT_CHDIR

/* original implementation by VH */
void handle_LYK_CHDIR(void)
{
    static char buf[LY_MAXPATH];
    char *p = NULL;

    if (no_chdir) {
	HTUserMsg(CHDIR_DISABLED);
	return;
    }

    _statusline(gettext("cd to:"));
    /* some people may prefer automatic clearing of the previous user input,
       here, to do this, just uncomment next line - VH */
    /* buf[0]='\0'; */
    if (LYgetstr(buf, VISIBLE, sizeof(buf) - 1, NORECALL) < 0 || !*buf) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (*buf == '~' && !buf[1]) {
	StrAllocCopy(p, Home_Dir());
    } else if (*buf == '~') {
	HTSprintf0(&p, "%s%s", Home_Dir(), buf + 1);
    } else {
	StrAllocCopy(p, buf);
    }

    CTRACE((tfp, "changing directory to '%s'\n", p));
    if (chdir(p)) {
	switch (errno) {
	case EACCES:
	    HTInfoMsg(COULD_NOT_ACCESS_DIR);
	    break;
	case ENOENT:
	    HTInfoMsg(gettext("No such directory"));
	    break;
	case ENOTDIR:
	    HTInfoMsg(gettext("A component of path is not a directory"));
	    break;
	default:
	    HTInfoMsg(gettext("failed to change directory"));
	    break;
	}
    } else {
#ifdef DIRED_SUPPORT
	/*if in dired, load content of other directory */
	if (!no_dired_support
	    && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
	    char buf2[LY_MAXPATH];
	    char *addr = NULL;

	    Current_Dir(buf2);
	    LYLocalFileToURL(&addr, buf2);

	    newdoc.address = addr;
	    newdoc.isHEAD = FALSE;
	    StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    /**force_load = TRUE;*/
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
	    }
	} else
#endif
	    HTInfoMsg(OPERATION_DONE);
    }
    FREE(p);
}
#endif

#ifdef USE_CURSES_PADS
/*
 * Having jumps larger than this is counter-productive.  Indeed, it is natural
 * to expect that when the relevant text appears, one would "overshoot" and
 * would scroll 3-4 extra full screens.  When going back, the "accumulation"
 * logic would again start moving in full screens, so one would overshoot
 * again, etc.
 *
 * Going back, one can fix it in 28 keypresses. The relevant text will appear
 * on the screen soon enough for the key-repeat to become not that important,
 * and we are still moving in smaller steps than when we overshot.  Since key
 * repeat is not important, even if we overshoot again, it is going to be by 30
 * steps, which is easy to fix by reversing the direction again.
 */
static int repeat_to_delta(int n)
{
    int threshold = LYcols / 3;

    while (threshold > 0) {
	if (n >= threshold) {
	    n = threshold;
	    break;
	}
	threshold = (threshold * 2) / 3;
    }
    return n;
}

static void handle_LYK_SHIFT_LEFT(BOOLEAN *flag, int count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    if (LYshiftWin > 0) {
	LYshiftWin -= repeat_to_delta(count);
	*flag = TRUE;
    }
    if (LYshiftWin < 0)
	LYshiftWin = 0;
}

static void handle_LYK_SHIFT_RIGHT(BOOLEAN *flag, int count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    LYshiftWin += repeat_to_delta(count);
    *flag = TRUE;
}

static BOOLEAN handle_LYK_LINEWRAP_TOGGLE(int *cmd,
					  BOOLEAN *flag)
{
    static const char *choices[] =
    {
	"Try to fit screen width",
	"No line wrap in columns",
	"Wrap columns at screen width",
	"Wrap columns at 3/4 screen width",
	"Wrap columns at 2/3 screen width",
	"Wrap columns at 1/2 screen width",
	"Wrap columns at 1/3 screen width",
	"Wrap columns at 1/4 screen width",
	NULL
    };
    static int wrap[] =
    {
	0,
	0,
	12,			/* In units of 1/12 */
	9,
	8,
	6,
	4,
	3
    };
    int c;

    if (LYwin == stdscr)
	return FALSE;

    /* Somehow the mouse is over the number instead of being over the
       name, so we decrease x. */
    c = LYChoosePopup(!LYwideLines, LYlines / 2 - 2, LYcolLimit / 2 - 6,
		      choices, TABLESIZE(choices) - 1, FALSE, TRUE);
    /*
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
     */
    if (term_options)
	return FALSE;
    LYwideLines = c;
    LYtableCols = wrap[c];

    if (LYwideLines == 0)
	LYshiftWin = 0;
    *flag = TRUE;
    HTUserMsg(LYwideLines ? LINEWRAP_OFF : LINEWRAP_ON);
    return reparse_or_reload(cmd);
}
#endif

/*
 * Here's where we do all the work.
 * mainloop is basically just a big switch dependent on the users input.  I
 * have tried to offload most of the work done here to procedures to make it
 * more modular, but this procedure still does a lot of variable manipulation. 
 * This needs some work to make it neater.  - Lou Moutilli
 *					(memoir from the original Lynx - FM)
 */

int mainloop(void)
{
#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
#undef	STRING_MAX
#define	STRING_MAX	4096
    char temp_buff[STRING_MAX];

#define	BUFF_MAX	1024
    char sjis_buff[BUFF_MAX];
#endif
    int c = 0;
    int real_c = 0;
    int old_c = 0;
    int pending_form_c = -1;
    int cmd = LYK_DO_NOTHING, real_cmd = LYK_DO_NOTHING;
    int getresult;
    int arrowup = FALSE, show_help = FALSE;
    char user_input_buffer[MAX_LINE];
    const char *cshelpfile = NULL;
    BOOLEAN first_file = TRUE;
    BOOLEAN popped_doc = FALSE;
    BOOLEAN refresh_screen = FALSE;
    BOOLEAN force_load = FALSE;
    BOOLEAN try_internal = FALSE;
    BOOLEAN crawl_ok = FALSE;
    BOOLEAN vi_keys_flag = vi_keys;
    BOOLEAN emacs_keys_flag = emacs_keys;
    BOOLEAN trace_mode_flag = FALSE;
    BOOLEAN forced_HTML_mode = LYforce_HTML_mode;
    char cfile[128];
    FILE *cfp;
    char *cp;
    int ch;
    RecallType recall;
    int URLTotal;
    int URLNum;
    BOOLEAN FirstURLRecall = TRUE;
    char *temp = NULL;
    BOOLEAN ForcePush = FALSE;
    BOOLEAN override_LYresubmit_posts = FALSE;
    BOOLEAN newdoc_link_is_absolute = FALSE;
    BOOLEAN curlink_is_editable;
    BOOLEAN use_last_tfpos;
    unsigned int len;
    int i;
    int follow_col = -1, key_count = 0, last_key = 0;

    /* "internal" means "within the same document, with certainty".  It includes a
     * space so it cannot conflict with any (valid) "TYPE" attributes on A
     * elements.  [According to which DTD, anyway??] - kw
     */
    HTInternalLink = HTAtom_for("internal link");	/* init, used as const */

#ifndef WWW_SOURCE
    WWW_SOURCE = HTAtom_for("www/source");	/* init, used as const */
#endif

    /*
     * curdoc.address contains the name of the file that is currently open.
     * newdoc.address contains the name of the file that will soon be
     *                opened if it exits.
     * prev_target    contains the last search string the user searched for.
     * newdoc.title   contains the link name that the user last chose to get
     *                into the current link (file).
     */
    /* initialize some variables */
    newdoc.address = NULL;
    newdoc.title = NULL;
    newdoc.post_data = NULL;
    newdoc.post_content_type = NULL;
    newdoc.bookmark = NULL;
    newdoc.internal_link = FALSE;
    curdoc.address = NULL;
    curdoc.title = NULL;
    curdoc.post_data = NULL;
    curdoc.post_content_type = NULL;
    curdoc.bookmark = NULL;
    curdoc.internal_link = FALSE;
#ifdef USE_COLOR_STYLE
    curdoc.style = NULL;
    newdoc.style = NULL;
#endif
    nhist = 0;
    user_input_buffer[(sizeof(user_input_buffer) - 1)] = '\0';
    *prev_target = '\0';
    *user_input_buffer = '\0';
#ifdef LY_FIND_LEAKS
    atexit(free_mainloop_variables);
#endif
  initialize:
    set_address(&newdoc, startfile);
    StrAllocCopy(startrealm, startfile);
    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.line = 1;
    newdoc.link = 0;

#ifdef USE_SLANG
    if (TRACE && LYCursesON) {
	LYaddstr("\n");
	LYrefresh();
    }
#endif /* USE_SLANG */
    CTRACE((tfp, "Entering mainloop, startfile=%s\n", startfile));

    if (form_post_data) {
	BStrCopy0(newdoc.post_data, form_post_data);
	StrAllocCopy(newdoc.post_content_type,
		     "application/x-www-form-urlencoded");
    } else if (form_get_data) {
	StrAllocCat(newdoc.address, form_get_data);
    }

    if (bookmark_start) {
	if (LYValidate) {
	    HTAlert(BOOKMARKS_DISABLED);
	    bookmark_start = FALSE;
	    goto initialize;
	} else if (traversal) {
	    HTAlert(BOOKMARKS_NOT_TRAVERSED);
	    traversal = FALSE;
	    crawl = FALSE;
	    bookmark_start = FALSE;
	    goto initialize;
	} else {
	    const char *cp1;

	    /*
	     * See if a bookmark page exists.  If it does, replace
	     * newdoc.address with its name
	     */
	    if ((cp1 = get_bookmark_filename(&newdoc.address)) != NULL &&
		*cp1 != '\0' && strcmp(cp1, " ")) {
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		StrAllocCopy(startrealm, newdoc.address);
		LYFreePostData(&newdoc);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		CTRACE((tfp, "Using bookmarks=%s\n", newdoc.address));
	    } else {
		HTUserMsg(BOOKMARKS_NOT_OPEN);
		bookmark_start = FALSE;
		goto initialize;
	    }
	}
    }

    FREE(form_post_data);
    FREE(form_get_data);

    if (user_mode == NOVICE_MODE)
	display_lines = LYlines - 4;
    else
	display_lines = LYlines - 2;

    while (TRUE) {
#ifdef USE_COLOR_STYLE
	if (curdoc.style != NULL)
	    force_load = TRUE;
#endif
	/*
	 * If newdoc.address is different from curdoc.address then we need to
	 * go out and find and load newdoc.address.
	 */
	if (LYforce_no_cache || force_load ||
	    are_different(&curdoc, &newdoc)) {

	    force_load = FALSE;	/* done */
	    if (TRACE && LYCursesON) {
		LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
	    }
	  try_again:
	    /*
	     * Push the old file onto the history stack if we have a current
	     * doc and a new address.  - FM
	     */
	    if (curdoc.address && newdoc.address) {
		/*
		 * Don't actually push if this is a LYNXDOWNLOAD URL, because
		 * that returns NORMAL even if it fails due to a spoof attempt
		 * or file access problem, and we set the newdoc structure
		 * elements to the curdoc structure elements under case NORMAL. 
		 * - FM
		 */
		if (!isLYNXDOWNLOAD(newdoc.address)) {
		    LYpush(&curdoc, ForcePush);
		}
	    } else if (!newdoc.address) {
		/*
		 * If newdoc.address is empty then pop a file and load it.  -
		 * FM
		 */
		LYhist_prev(&newdoc);
		popped_doc = TRUE;

#ifndef DONT_TRACK_INTERNAL_LINKS
		/*
		 * If curdoc had been reached via an internal
		 * (fragment) link from what we now have just
		 * popped into newdoc, then override non-caching in
		 * all cases. - kw
		 */
		if (curdoc.internal_link &&
		    !are_phys_different(&curdoc, &newdoc)) {
		    LYinternal_flag = TRUE;
		    LYoverride_no_cache = TRUE;
		    LYforce_no_cache = FALSE;
		    try_internal = TRUE;
		} else
#endif /* TRACK_INTERNAL_LINKS */
		{
		    /*
		     * Force a no_cache override unless it's a bookmark file,
		     * or it has POST content and LYresubmit_posts is set
		     * without safe also set, and we are not going to another
		     * position in the current document or restoring the
		     * previous document due to a NOT_FOUND or NULLFILE return
		     * value from getfile().  - FM
		     */
		    if ((newdoc.bookmark != NULL) ||
			(newdoc.post_data != NULL &&
			 !newdoc.safe &&
			 LYresubmit_posts &&
			 !override_LYresubmit_posts &&
			 NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			LYoverride_no_cache = FALSE;
		    } else {
			LYoverride_no_cache = TRUE;
		    }
		}
	    }
	    override_LYresubmit_posts = FALSE;

	    if (HEAD_request) {
		/*
		 * Make SURE this is an appropriate request.  - FM
		 */
		if (newdoc.address) {
		    if (LYCanDoHEAD(newdoc.address) == TRUE) {
			newdoc.isHEAD = TRUE;
		    } else if (isLYNXIMGMAP(newdoc.address)) {
			if (LYCanDoHEAD(newdoc.address + LEN_LYNXIMGMAP) == TRUE) {
			    StrAllocCopy(temp, newdoc.address + LEN_LYNXIMGMAP);
			    free_address(&newdoc);
			    newdoc.address = temp;
			    newdoc.isHEAD = TRUE;
			    temp = NULL;
			}
		    }
		}
		try_internal = FALSE;
		HEAD_request = FALSE;
	    }

	    /*
	     * If we're getting the TRACE log and it's not new, check whether
	     * its HText structure has been dumped, and if so, fflush() and
	     * fclose() it to ensure it's fully updated, and then fopen() it
	     * again.  - FM
	     */
	    if (LYUseTraceLog == TRUE &&
		trace_mode_flag == FALSE &&
		LYTraceLogFP != NULL &&
		LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
		DocAddress WWWDoc;
		HTParentAnchor *tmpanchor;

		WWWDoc.address = newdoc.address;
		WWWDoc.post_data = newdoc.post_data;
		WWWDoc.post_content_type = newdoc.post_content_type;
		WWWDoc.bookmark = newdoc.bookmark;
		WWWDoc.isHEAD = newdoc.isHEAD;
		WWWDoc.safe = newdoc.safe;
		tmpanchor = HTAnchor_findAddress(&WWWDoc);
		if ((HText *) HTAnchor_document(tmpanchor) == NULL) {
		    if (!LYReopenTracelog(&trace_mode_flag)) {
			old_c = 0;
			cmd = LYK_PREV_DOC;
			goto new_cmd;
		    }
		}
	    }

	    LYRequestTitle = newdoc.title;
	    if (newdoc.bookmark)
		LYforce_HTML_mode = TRUE;
	    if (LYValidate &&
		startfile_ok &&
		newdoc.address && startfile && homepage &&
		(!strcmp(newdoc.address, startfile) ||
		 !strcmp(newdoc.address, homepage))) {
		LYPermitURL = TRUE;
	    }

	    /* reset these two variables here before getfile()
	     * so they will be available in partial mode
	     * (was previously implemented in case NORMAL).
	     */
	    *prev_target = '\0';	/* Reset for new coming document */
	    Newline = newdoc.line;	/* set for LYGetNewline() */

#ifdef USE_PRETTYSRC
	    psrc_first_tag = TRUE;
#endif
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = textfields_activation_option;
#endif
	    FREE(LYRequestReferer);
	    /*
	     * Don't send Referer if we have to load a document again that we
	     * got from the history stack.  We don't know any more how we
	     * originally got to that page.  Using a Referer based on the
	     * current HTMainText could only be right by coincidence.  - kw
	     * 1999-11-01
	     */
	    if (popped_doc)
		LYNoRefererForThis = TRUE;

#ifndef DONT_TRACK_INTERNAL_LINKS
	    if (try_internal) {
		if (newdoc.address &&
		    isLYNXIMGMAP(newdoc.address)) {
		    try_internal = FALSE;
		} else if (curdoc.address &&
			   isLYNXIMGMAP(curdoc.address)) {
		    try_internal = FALSE;
		}
	    }
	    if (try_internal) {
		char *hashp = findPoundSelector(newdoc.address);

		if (hashp) {
		    HTFindPoundSelector(hashp + 1);
		}
		getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		try_internal = FALSE;	/* done */
		/* fix up newdoc.address which may have been fragment-only */
		if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
		    if (!hashp) {
			set_address(&newdoc, HTLoadedDocumentURL());
		    } else {
			StrAllocCopy(temp, HTLoadedDocumentURL());
			StrAllocCat(temp, hashp);	/* append fragment */
			set_address(&newdoc, temp);
			FREE(temp);
		    }
		}
	    } else {
		if (newdoc.internal_link && newdoc.address &&
		    *newdoc.address == '#' && nhist > 0) {
		    char *cp0;

		    if (isLYNXIMGMAP(HDOC(nhist_1).address))
			cp0 = HDOC(nhist_1).address + LEN_LYNXIMGMAP;
		    else
			cp0 = HDOC(nhist_1).address;
		    StrAllocCopy(temp, cp0);
		    (void) trimPoundSelector(temp);
		    StrAllocCat(temp, newdoc.address);
		    free_address(&newdoc);
		    newdoc.address = temp;
		    temp = NULL;
		}
		getresult = getfile(&newdoc, &Newline);
	    }
#else /* TRACK_INTERNAL_LINKS */
	    getresult = getfile(&newdoc, &Newline);
#endif /* TRACK_INTERNAL_LINKS */

#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;	/* for sure */
#endif

	    switch (getresult) {

	    case NOT_FOUND:
		/*
		 * OK!  can't find the file, so it must not be around now.  Do
		 * any error logging, if appropriate.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		if (!first_file && !LYCancelledFetch) {
		    /*
		     * Do error mail sending and/or traversal stuff.  Note that
		     * the links[] elements may not be valid at this point, if
		     * we did call HTuncache_current_document!  This should not
		     * have happened for traversal, but for sending error mail
		     * check that HTMainText exists for this reason.  - kw
		     */
		    if (error_logging && nhist > 0 && !popped_doc &&
			!LYUserSpecifiedURL &&
			HTMainText &&
			nlinks > 0 && curdoc.link < nlinks &&
			!isLYNXHIST(NonNull(newdoc.address)) &&
			!isLYNXCOOKIE(NonNull(newdoc.address))) {
			char *mail_owner = NULL;

			if (owner_address && isMAILTO_URL(owner_address)) {
			    mail_owner = owner_address + LEN_MAILTO_URL;
			}
			/*
			 * Email a bad link message to the owner of the
			 * document, or to ALERTMAIL if defined, but NOT to
			 * lynx-dev (it is rejected in mailmsg).  - FM, kw
			 */
#ifndef ALERTMAIL
			if (mail_owner)
#endif
			    mailmsg(curdoc.link,
				    mail_owner,
				    HDOC(nhist_1).address,
				    HDOC(nhist_1).title);
		    }
		    if (traversal) {
			FILE *ofp;

			if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
			    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				perror(NOOPEN_TRAV_ERR_FILE);
				exit_immediately(EXIT_FAILURE);
			    }
			}
			if (nhist > 0) {
			    fprintf(ofp,
				    "%s %s\tin %s\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target,
				    HDOC(nhist_1).address);
			} else {
			    fprintf(ofp,
				    "%s %s\t\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target);
			}
			LYCloseOutput(ofp);
		    }
		}

		/*
		 * Fall through to do the NULL stuff and reload the old file,
		 * unless the first file wasn't found or has gone missing.
		 */
		if (!nhist) {
		    /*
		     * If nhist = 0 then it must be the first file.
		     */
		    exit_immediately_with_error_message(NOT_FOUND, first_file);
		    return (EXIT_FAILURE);
		}
		/* FALLTHRU */

	    case NULLFILE:
		/*
		 * Not supposed to return any file.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		popped_doc = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		free_address(&newdoc);	/* to pop last doc */
		FREE(newdoc.bookmark);
		LYJumpFileURL = FALSE;
		reloading = FALSE;
		LYPermitURL = FALSE;
		LYCancelledFetch = FALSE;
		ForcePush = FALSE;
		LYforce_HTML_mode = FALSE;
		force_old_UCLYhndl_on_reload = FALSE;
		if (traversal) {
		    crawl_ok = FALSE;
		    if (traversal_link_to_add) {
			/*
			 * It's a binary file, or the fetch attempt failed. 
			 * Add it to TRAVERSE_REJECT_FILE so we don't try again
			 * in this run.
			 */
			if (!lookup_reject(traversal_link_to_add)) {
			    add_to_reject_list(traversal_link_to_add);
			}
			FREE(traversal_link_to_add);
		    }
		}
		/*
		 * Make sure the first file was found and has not gone missing.
		 */
		if (!nhist) {
		    /*
		     * If nhist = 0 then it must be the first file.
		     */
		    if (first_file && homepage &&
			!LYSameFilename(homepage, startfile)) {
			/*
			 * Couldn't return to the first file but there is a
			 * homepage we can use instead.  Useful for when the
			 * first URL causes a program to be invoked.  - GL
			 *
			 * But first make sure homepage is different from
			 * startfile (above), then make it the same (below) so
			 * we don't enter an infinite getfile() loop on on
			 * failures to find the files.  - FM
			 */
			set_address(&newdoc, homepage);
			LYFreePostData(&newdoc);
			FREE(newdoc.bookmark);
			StrAllocCopy(startfile, homepage);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
			newdoc.internal_link = FALSE;
			goto try_again;
		    } else {
			exit_immediately_with_error_message(NULLFILE, first_file);
			return (EXIT_FAILURE);
		    }
		}

		/*
		 * If we're going to pop from history because getfile didn't
		 * succeed, reset LYforce_no_cache first.  This would have been
		 * done in HTAccess.c if the request got that far, but the URL
		 * may have been handled or rejected in getfile without taking
		 * care of that.  - kw
		 */
		LYforce_no_cache = FALSE;
		/*
		 * Retrieval of a newdoc just failed, and just going to
		 * try_again would pop the next doc from history and try to get
		 * it without further questions.  This may not be the right
		 * thing to do if we have POST data, so fake a PREV_DOC key if
		 * it seems that some prompting should be done.  This doesn't
		 * affect the traversal logic, since with traversal POST data
		 * can never occur.  - kw
		 */
		if (HDOC(nhist - 1).post_data &&
		    !HDOC(nhist - 1).safe) {
		    if (HText_POSTReplyLoaded((DocInfo *) &history[(nhist_1)])) {
			override_LYresubmit_posts = TRUE;
			goto try_again;
		    }
		    /* Set newdoc fields, just in case the PREV_DOC gets
		     * cancelled.  - kw
		     */
		    if (!curdoc.address) {
			set_address(&newdoc, HTLoadedDocumentURL());
			StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			if (HTMainAnchor
			    && HTMainAnchor->post_data) {
			    BStrCopy(newdoc.post_data,
				     HTMainAnchor->post_data);
			    StrAllocCopy(newdoc.post_content_type,
					 HTMainAnchor->post_content_type);
			} else {
			    BStrFree(newdoc.post_data);
			}
			newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			newdoc.safe = HTLoadedDocumentIsSafe();
			newdoc.internal_link = FALSE;
		    } else {
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
		    }
		    cmd = LYK_PREV_DOC;
		    goto new_cmd;
		}
		override_LYresubmit_posts = TRUE;
		goto try_again;

	    case NORMAL:
		/*
		 * Marvelously, we got the document!
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);

		/*
		 * If it's the first file and we're interactive, check whether
		 * it's a bookmark file which was not accessed via the -book
		 * switch.  - FM
		 */
		if (((first_file == TRUE) &&
		     (dump_output_immediately == FALSE) &&
		     isEmpty(newdoc.bookmark)) &&
		    ((LYisLocalFile(newdoc.address) == TRUE) &&
		     !(strcmp(NonNull(HText_getTitle()),
			      BOOKMARK_TITLE))) &&
		    (temp = HTParse(newdoc.address, "",
				    PARSE_PATH + PARSE_PUNCTUATION)) != NULL) {
		    const char *name = wwwName(Home_Dir());

		    len = strlen(name);
#ifdef VMS
		    if (!strncasecomp(temp, name, len) &&
			strlen(temp) > len)
#else
		    if (!strncmp(temp, name, len) &&
			strlen(temp) > len)
#endif /* VMS */
		    {
			/*
			 * We're interactive and this might be a bookmark file
			 * entered as a startfile rather than invoked via
			 * -book.  Check if it's in our bookmark file list, and
			 * if so, reload if with the relevant bookmark elements
			 * set.  - FM
			 */
			cp = NULL;
			if (temp[len] == '/') {
			    if (strchr(&temp[(len + 1)], '/')) {
				HTSprintf0(&cp, ".%s", &temp[len]);
			    } else {
				StrAllocCopy(cp, &temp[(len + 1)]);
			    }
			} else {
			    StrAllocCopy(cp, &temp[len]);
			}
			for (i = 0; i <= MBM_V_MAXFILES; i++) {
			    if (MBM_A_subbookmark[i] &&
				LYSameFilename(cp, MBM_A_subbookmark[i])) {
				StrAllocCopy(BookmarkPage,
					     MBM_A_subbookmark[i]);
				break;
			    }
			}
			FREE(cp);
			if (i <= MBM_V_MAXFILES) {
			    FREE(temp);
			    if (LYValidate) {
				HTAlert(BOOKMARKS_DISABLED);
				return (EXIT_FAILURE);
			    }
			    if ((temp = HTParse(newdoc.address, "",
						PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION))) {
				set_address(&newdoc, temp);
				HTuncache_current_document();
				free_address(&curdoc);
				StrAllocCat(newdoc.address,
					    wwwName(Home_Dir()));
				StrAllocCat(newdoc.address, "/");
				StrAllocCat(newdoc.address,
					    (strncmp(BookmarkPage, "./", 2) ?
					     BookmarkPage :
					     (BookmarkPage + 2)));
				StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				StrAllocCopy(newdoc.bookmark, BookmarkPage);
#ifdef USE_COLOR_STYLE
				if (curdoc.style)
				    StrAllocCopy(newdoc.style, curdoc.style);
#endif
				StrAllocCopy(startrealm, newdoc.address);
				LYFreePostData(&newdoc);
				newdoc.isHEAD = FALSE;
				newdoc.safe = FALSE;
				FREE(temp);
				if (!strcmp(homepage, startfile))
				    StrAllocCopy(homepage, newdoc.address);
				StrAllocCopy(startfile, newdoc.address);
				CTRACE((tfp, "Reloading as bookmarks=%s\n",
					newdoc.address));
				goto try_again;
			    }
			}
		    }
		    cp = NULL;
		}
		FREE(temp);

		if (traversal) {
		    /*
		     * During traversal build up lists of all links traversed. 
		     * Traversal mode is a special feature for traversing http
		     * links in the web.
		     */
		    if (traversal_link_to_add) {
			/*
			 * Add the address we sought to TRAVERSE_FILE.
			 */
			if (!lookup_link(traversal_link_to_add))
			    add_to_table(traversal_link_to_add);
			FREE(traversal_link_to_add);
		    }
		    if (curdoc.address && curdoc.title &&
			!isLYNXIMGMAP(curdoc.address))
			/*
			 * Add the address we got to TRAVERSE_FOUND_FILE.
			 */
			add_to_traverse_list(curdoc.address, curdoc.title);
		}

		/*
		 * If this was a LYNXDOWNLOAD, we still have curdoc, not a
		 * newdoc, so reset the address, title and positioning
		 * elements.  - FM
		 */
		if (newdoc.address && curdoc.address &&
		    isLYNXDOWNLOAD(newdoc.address)) {
		    copy_address(&newdoc, &curdoc);
		    StrAllocCopy(newdoc.title, NonNull(curdoc.title));
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    newdoc.internal_link = FALSE;	/* can't be true. - kw */
		}

		/*
		 * Set Newline to the saved line.  It contains the line the
		 * user was on if s/he has been in the file before, or it is 1
		 * if this is a new file.
		 *
		 * We already set Newline before getfile() and probably update
		 * it explicitly if popping from the history stack via LYpop()
		 * or LYpop_num() within getfile() cycle.
		 *
		 * In partial mode, Newline was probably updated in
		 * LYMainLoop_pageDisplay() if user scrolled the document while
		 * loading.  Incremental loading stage already closed in
		 * HT*Copy().
		 */
#ifdef DISP_PARTIAL
		/* Newline = newdoc.line; */
		display_partial = FALSE;	/* for sure, LYNXfoo:/ may be a problem */
#else
		/* Should not be needed either if we remove "DISP_PARTIAL" from
		 * LYHistory.c, but lets leave it as an important comment for
		 * now.
		 */
		/* Newline = newdoc.line; */
#endif

		/*
		 * If we are going to a target line or the first page of a
		 * popped document, override any www_search line result.
		 */
		if (Newline > 1 || popped_doc == TRUE)
		    www_search_result = -1;

		/*
		 * Make sure curdoc.line will not be equal to Newline, so we
		 * get a redraw.
		 */
		curdoc.line = -1;
		break;
	    }			/* end switch */

	    if (TRACE) {
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();	/* allow me to look at the results */
		}
	    }

	    /*
	     * Set the files the same.
	     */
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(curdoc.post_data, newdoc.post_data);
	    StrAllocCopy(curdoc.post_content_type, newdoc.post_content_type);
	    StrAllocCopy(curdoc.bookmark, newdoc.bookmark);
#ifdef USE_COLOR_STYLE
	    StrAllocCopy(curdoc.style, HText_getStyle());
	    if (curdoc.style != NULL)
		style_readFromFile(curdoc.style);
#endif
	    curdoc.isHEAD = newdoc.isHEAD;
	    curdoc.internal_link = newdoc.internal_link;

	    /*
	     * Set the remaining document elements and add to the visited links
	     * list.  - FM
	     */
	    if (ownerS_address != NULL) {
#ifndef USE_PRETTYSRC
		if (HTOutputFormat == WWW_SOURCE && !HText_getOwner())
#else
		if ((LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
		    && !HText_getOwner())
#endif
		    HText_setMainTextOwner(ownerS_address);
		FREE(ownerS_address);
	    }
	    if (HText_getTitle()) {
		StrAllocCopy(curdoc.title, HText_getTitle());
	    } else if (!dump_output_immediately) {
		StrAllocCopy(curdoc.title, newdoc.title);
	    }
	    StrAllocCopy(owner_address, HText_getOwner());
	    curdoc.safe = HTLoadedDocumentIsSafe();
	    if (!dump_output_immediately) {
		LYAddVisitedLink(&curdoc);
	    }

	    /*
	     * Reset WWW present mode so that if we were getting the source, we
	     * get rendered HTML from now on.
	     */
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;
#endif

	    HTMLSetCharacterHandling(current_char_set);		/* restore, for sure? */

	    /*
	     * Reset all of the other relevant flags.  - FM
	     */
	    LYUserSpecifiedURL = FALSE;		/* only set for goto's and jumps's */
	    LYJumpFileURL = FALSE;	/* only set for jump's */
	    LYNoRefererForThis = FALSE;		/* always reset on return here */
	    reloading = FALSE;	/* set for RELOAD and NOCACHE keys */
	    HEAD_request = FALSE;	/* only set for HEAD requests */
	    LYPermitURL = FALSE;	/* only for LYValidate or check_realm */
	    ForcePush = FALSE;	/* only set for some PRINT requests. */
	    LYforce_HTML_mode = FALSE;
	    force_old_UCLYhndl_on_reload = FALSE;
	    popped_doc = FALSE;
	    pending_form_c = -1;

	}
	/* end if (LYforce_no_cache || force_load || are_different(...)) */
	if (dump_output_immediately) {
	    if (crawl) {
		print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
	    } else if (!dump_links_only) {
		print_wwwfile_to_fd(stdout, FALSE, FALSE);
	    }
	    return (EXIT_SUCCESS);
	}

	/*
	 * If the recent_sizechange variable is set to TRUE then the window
	 * size changed recently.
	 */
	if (recent_sizechange) {
	    /*
	     * First we need to make sure the display library - curses, slang,
	     * whatever - gets notified about the change, and gets a chance to
	     * update external structures appropriately.  Hopefully the
	     * stop_curses()/start_curses() sequence achieves this, at least if
	     * the display library has a way to get the new screen size from
	     * the OS.
	     *
	     * However, at least for ncurses, the update of the internal
	     * structures will come still too late - the changed screen size is
	     * detected in doupdate(), which would only be called (indirectly
	     * through the HText_pageDisplay below) after the WINDOW structures
	     * are already filled based on the old size.  So we notify the
	     * ncurses library directly here.  - kw
	     */
#if defined(NCURSES) && defined(HAVE_RESIZETERM) && defined(HAVE_WRESIZE)
	    resizeterm(LYlines, LYcols);
	    wresize(LYwin, LYlines, LYcols);
#else
#if 0				/* defined(PDCURSES) && defined(HAVE_XCURSES) */
	    resize_term(LYlines, LYcols);
	    if (LYwin != 0)
		LYwin = resize_window(LYwin, LYlines, LYcols);
	    refresh();
#else
	    stop_curses();
	    start_curses();
	    LYclear();
#endif
#endif
	    refresh_screen = TRUE;	/* to force a redraw */
	    if (HTMainText)	/* to REALLY force it... - kw */
		HText_setStale(HTMainText);
	    recent_sizechange = FALSE;
	    if (user_mode == NOVICE_MODE) {
		display_lines = LYlines - 4;
	    } else {
		display_lines = LYlines - 2;
	    }
	}

	if (www_search_result != -1) {
	    /*
	     * This was a WWW search, set the line to the result of the search.
	     */
	    Newline = www_search_result;
	    www_search_result = -1;	/* reset */
	}

	if (first_file == TRUE) {
	    /*
	     * We can never again have the first file.
	     */
	    first_file = FALSE;

	    /*
	     * Set the startrealm, and deal as best we can with preserving
	     * forced HTML mode for a local startfile.  - FM
	     */
	    temp = HTParse(curdoc.address, "",
			   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
	    if (!temp || *temp == '\0') {
		StrAllocCopy(startrealm, NO_NOTHING);
	    } else {
		StrAllocCopy(startrealm, temp);
		FREE(temp);
		if (!(temp = HTParse(curdoc.address, "",
				     PARSE_PATH + PARSE_PUNCTUATION))) {
		    LYAddHtmlSep(&startrealm);
		} else {
		    if (forced_HTML_mode &&
			!dump_output_immediately &&
			!curdoc.bookmark &&
			isFILE_URL(curdoc.address) &&
			strlen(temp) > 1) {
			/*
			 * We forced HTML for a local startfile which is not a
			 * bookmark file and has a path of at least two
			 * letters.  If it doesn't have a suffix mapped to
			 * text/html, we'll set the entire path (including the
			 * lead slash) as a "suffix" mapped to text/html to
			 * ensure it is always treated as an HTML source file. 
			 * We are counting on a tail match to this full path
			 * for some other URL fetched during the session having
			 * too low a probability to worry about, but it could
			 * happen.  - FM
			 */
			HTAtom *encoding;

			if (HTFileFormat(temp, &encoding, NULL) != WWW_HTML) {
			    HTSetSuffix(temp, "text/html", "8bit", 1.0);
			}
		    }
		    if ((cp = strrchr(temp, '/')) != NULL) {
			*(cp + 1) = '\0';
			StrAllocCat(startrealm, temp);
		    }
		}
	    }
	    FREE(temp);
	    CTRACE((tfp, "Starting realm is '%s'\n\n", startrealm));
	    if (traversal) {
		/*
		 * Set up the crawl output stuff.
		 */
		if (curdoc.address && !lookup_link(curdoc.address)) {
		    if (!isLYNXIMGMAP(curdoc.address))
			crawl_ok = TRUE;
		    add_to_table(curdoc.address);
		}
		/*
		 * Set up the traversal_host comparison string.
		 */
		if (strncmp((curdoc.address ? curdoc.address : "NULL"),
			    "http", 4)) {
		    StrAllocCopy(traversal_host, NO_NOTHING);
		} else if (check_realm) {
		    StrAllocCopy(traversal_host, startrealm);
		} else {
		    temp = HTParse(curdoc.address, "",
				   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
		    if (!temp || *temp == '\0') {
			StrAllocCopy(traversal_host, NO_NOTHING);
		    } else {
			StrAllocCopy(traversal_host, temp);
			LYAddHtmlSep(&traversal_host);
		    }
		    FREE(temp);
		}
		CTRACE((tfp, "Traversal host is '%s'\n\n", traversal_host));
	    }
	    if (startfile) {
		/*
		 * If homepage was not equated to startfile, make the homepage
		 * URL the first goto entry.  - FM
		 */
		if (homepage && strcmp(startfile, homepage))
		    HTAddGotoURL(homepage);
		/*
		 * If we are not starting up with startfile (e.g., had -book),
		 * or if we are using the startfile and it has no POST content,
		 * make the startfile URL a goto entry.  - FM
		 */
		if (strcmp(startfile, newdoc.address) ||
		    newdoc.post_data == NULL)
		    HTAddGotoURL(startfile);
	    }
	    if (TRACE) {
		refresh_screen = TRUE;
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();
		}
	    }
	}
#ifdef USE_SOURCE_CACHE
	/*
	 * If the parse settings have changed since this HText was
	 * generated, we need to reparse and redraw it.  -dsb
	 *
	 * Should be configured to avoid shock for experienced lynx users.
	 * Currently enabled for cached sources only.
	 */
	if (HTdocument_settings_changed()) {
	    if (HTcan_reparse_document()) {
		HTInfoMsg(gettext("Reparsing document under current settings..."));
		reparse_document();
	    } else {
		/*
		 * Urk.  I have no idea how to recover from a failure here.
		 * At a guess, I'll try reloading.  -dsb
		 */
		/*  currently disabled ***
		   HTUserMsg(gettext("Reparsing document under current settings..."));
		   cmd = LYK_RELOAD;
		   goto new_cmd;
		 */
	    }
	}

	if (from_source_cache) {
	    from_source_cache = FALSE;	/* reset */
	    curdoc.line = -1;	/* so curdoc.line != Newline, see below */
	}
#endif

	/*
	 * If the curdoc.line is different than Newline then there must have
	 * been a change since last update.  Run HText_pageDisplay() create a
	 * fresh screen of text out.
	 *
	 * If we got new HTMainText go this way.  All display_partial calls
	 * ends here for final redraw.
	 */
	if (curdoc.line != Newline) {
#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;
#endif

	    refresh_screen = FALSE;

	    HText_pageDisplay(Newline, prev_target);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
#endif /* DIRED_SUPPORT */

	    /*
	     * If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();
	    if (newdoc.link < 0)
		goto_line(Newline);
	    curdoc.line = Newline = HText_getTopOfScreen() + 1;

	    if (curdoc.title == NULL) {
		/*
		 * If we don't yet have a title, try to get it, or set to that
		 * for newdoc.title.  - FM
		 */
		if (HText_getTitle()) {
		    StrAllocCopy(curdoc.title, HText_getTitle());
		} else {
		    StrAllocCopy(curdoc.title, newdoc.title);
		}
	    }

	    /*
	     * If the request is to highlight a link which is counted from the
	     * start of document, correct the link number:
	     */
	    if (newdoc_link_is_absolute) {
		newdoc_link_is_absolute = FALSE;
		if (curdoc.line > 1)
		    newdoc.link -= HText_LinksInLines(HTMainText, 1,
						      curdoc.line - 1);
	    }

	    if (arrowup) {
		/*
		 * arrowup is set if we just came up from a page below.
		 */
		curdoc.link = nlinks - 1;
		arrowup = FALSE;
	    } else {
		curdoc.link = newdoc.link;
		if (curdoc.link >= nlinks) {
		    curdoc.link = nlinks - 1;
		} else if (curdoc.link < 0 && nlinks > 0) {
		    /*
		     * We may have popped a doc (possibly in local_dired) which
		     * didn't have any links when it was pushed, but does have
		     * links now (e.g., a file was created).  Code below
		     * assumes that curdoc.link is valid and that
		     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  -
		     * KW
		     */
		    curdoc.link = 0;
		}
	    }

	    show_help = FALSE;	/* reset */
	    newdoc.line = 1;
	    newdoc.link = 0;
	    curdoc.line = Newline;	/* set */
	} else if (newdoc.link < 0) {
	    newdoc.link = 0;	/* ...just in case getfile set this */
	}

	/*
	 * Refresh the screen if necessary.
	 */
	if (refresh_screen) {
#if defined(FANCY_CURSES) || defined (USE_SLANG)
	    if (enable_scrollback) {
		LYclear();
	    } else {
		LYerase();
	    }
#else
	    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
	    HText_pageDisplay(Newline, prev_target);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
#endif /* DIRED_SUPPORT */

	    /*
	     * If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();

	    /*
	     * Adjust curdoc.link as above; nlinks may have changed, if the
	     * refresh_screen flag was set as a result of a size change.  Code
	     * below assumes that curdoc.link is valid and that
	     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  - kw
	     */
	    if (curdoc.link >= nlinks) {
		curdoc.link = nlinks - 1;
	    } else if (curdoc.link < 0 && nlinks > 0) {
		curdoc.link = 0;
	    }

	    if (user_mode == NOVICE_MODE)
		noviceline(more);	/* print help message */
	    refresh_screen = FALSE;

	}

	curlink_is_editable =
	    (nlinks > 0 &&
	     links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     F_TEXTLIKE(links[curdoc.link].l_form->type));

	use_last_tfpos = (curlink_is_editable &&
			  (real_cmd == LYK_LPOS_PREV_LINK ||
			   real_cmd == LYK_LPOS_NEXT_LINK));

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (!textfields_need_activation)
	    textinput_activated = TRUE;
#endif

#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
	if (nlinks > 0) {
	    char *p = "LYNX (unknown link type)";

	    /* Show the URL & kanji code . */
	    if (strlen(links[curdoc.link].lname) == 0) {

		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {

		    switch (links[curdoc.link].l_form->type) {
		    case F_TEXT_SUBMIT_TYPE:
		    case F_SUBMIT_TYPE:
		    case F_IMAGE_SUBMIT_TYPE:
			p = "[SUBMIT]";
			break;
		    case F_PASSWORD_TYPE:
			p = "Password";
			break;
		    case F_OPTION_LIST_TYPE:
			p = "Option list";
			break;
		    case F_CHECKBOX_TYPE:
			p = "Check box";
			break;
		    case F_RADIO_TYPE:
			p = "[Radio]";
			break;
		    case F_RESET_TYPE:
			p = "[Reset]";
			break;
		    case F_TEXT_TYPE:
			p = "Text input";
			break;
		    case F_TEXTAREA_TYPE:
			p = "Text input lines";
			break;
		    default:
			break;
		    }
		    set_ws_title(p);
		}
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    p = curdoc.title;
		} else {
		    p = links[curdoc.link].lname;
		}

		if (strlen(p) < 500) {
		    strcpy(temp_buff, p);
		    if (strchr(temp_buff, '%')) {
			HTUnEscape(temp_buff);
		    }
		    str_sjis(sjis_buff, temp_buff);
		    set_ws_title(LYElideString(sjis_buff, 10));
		}
	    }
	} else {
	    if (strlen(curdoc.address) < sizeof(temp_buff) - 1) {
		if (user_mode == ADVANCED_MODE) {
		    str_sjis(temp_buff, curdoc.title);
		} else {
		    strcpy(temp_buff, curdoc.address);
		}
		set_ws_title(HTUnEscape(temp_buff));
	    }
	}
#endif /* WIN_EX */

	/*
	 * Report unread or new mail, if appropriate.
	 */
	if (check_mail && !no_mail)
	    LYCheckMail();

	/*
	 * If help is not on the screen, then put a message on the screen to
	 * tell the user other misc info.
	 */
	if (!show_help) {
	    show_main_statusline(links[curdoc.link],
				 (curlink_is_editable && textinput_activated) ?
				 FOR_INPUT : FOR_PANEL);
	} else {
	    show_help = FALSE;
	}

	if (nlinks > 0) {
	    /*
	     * Highlight current link, unless it is an active text input field.
	     */
	    if (!curlink_is_editable) {
		LYhighlight(ON, curdoc.link, prev_target);
#ifndef INACTIVE_INPUT_STYLE_VH
	    } else if (!textinput_activated) {
		LYhighlight(ON, curdoc.link, prev_target);
#endif
	    }
	}

	if (traversal) {
	    /*
	     * Don't go interactively into forms, or accept keystrokes from the
	     * user
	     */
	    if (crawl && crawl_ok) {
		crawl_ok = FALSE;
#ifdef FNAMES_8_3
		sprintf(cfile, "lnk%05d.dat", crawl_count);
#else
		sprintf(cfile, "lnk%08d.dat", crawl_count);
#endif /* FNAMES_8_3 */
		crawl_count = crawl_count + 1;
		if ((cfp = LYNewTxtFile(cfile)) != NULL) {
		    print_crawl_to_fd(cfp, curdoc.address, curdoc.title);
		    LYCloseOutput(cfp);
		} else {
		    if (!dump_output_immediately)
			cleanup();
		    fprintf(
#ifdef UNIX
			       (dump_output_immediately
				? stderr
				: stdout),
#else
			       stdout,
#endif
			       gettext("Fatal error - could not open output file %s\n"), cfile);
		    if (!dump_output_immediately) {
			exit_immediately(EXIT_FAILURE);
		    }
		    return (EXIT_FAILURE);
		}
	    }
	} else {
	    /*
	     * Normal, non-traversal handling.
	     */
	    if (curlink_is_editable &&
		(textinput_activated || pending_form_c != -1)) {
		if (pending_form_c != -1) {
		    real_c = pending_form_c;
		    pending_form_c = -1;
		} else {
		    /*
		     * Replace novice lines if in NOVICE_MODE.
		     */
		    if (user_mode == NOVICE_MODE) {
			form_noviceline(links[curdoc.link].l_form->disabled);
		    }
		    real_c = change_form_link(curdoc.link,
					      &newdoc, &refresh_screen,
					      use_last_tfpos, FALSE);
		}
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation)
		    textinput_activated = FALSE;
#ifdef INACTIVE_INPUT_STYLE_VH
		textinput_redrawn = FALSE;
#endif
#endif

		c = (real_c == LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
		if (c != DO_NOTHING &&
		    peek_mouse_link() != -1 && peek_mouse_link() != -2)
		    old_c = 0;
		if (peek_mouse_link() >= 0 &&
		    LKC_TO_LAC(keymap, real_c) != LYK_CHANGE_LINK) {
		    do_change_link();
		    if ((c == '\n' || c == '\r') &&
			links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
			!textfields_need_activation) {
			c = DO_NOTHING;
		    }
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		} else if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
			   && textfields_need_activation
			   && !links[curdoc.link].l_form->disabled
			   && peek_mouse_link() < 0 &&
			   (((LKC_TO_LAC(keymap, real_c) == LYK_NEXT_LINK ||
#ifdef TEXTAREA_AUTOGROW
			      LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE ||
#endif
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks - 1 &&
			       links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link + 1].l_form->number)
			       && strcmp(links[curdoc.link].l_form->name,
					 links[curdoc.link + 1].l_form->name)
			       == 0) ||
			      (curdoc.link == nlinks - 1 && more &&
			       HText_TAHasMoreLines(curdoc.link, 1)))) ||
			    ((LKC_TO_LAC(keymap, real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_UP_LINK) &&
			     ((curdoc.link > 0 &&
			       links[curdoc.link - 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link - 1].l_form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link - 1].l_form->number) &&
			       strcmp(links[curdoc.link].l_form->name,
				      links[curdoc.link - 1].l_form->name) == 0)
			      || (curdoc.link == 0 && curdoc.line > 1 &&
				  HText_TAHasMoreLines(curdoc.link, -1)))))) {
		    textinput_activated = TRUE;
#ifdef TEXTAREA_AUTOGROW
		    if ((c == '\n' || c == '\r') &&
			LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE)
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
#endif /* TEXTAREA_AUTOGROW */
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION */
		} else
		    switch (c) {
		    case '\n':
		    case '\r':
#ifdef TEXTAREA_AUTOGROW
			/*
			 * If on the bottom line of a TEXTAREA, and the user
			 * hit the ENTER key, we add a new line/anchor
			 * automatically, positioning the cursor on it.
			 *
			 * If at the bottom of the screen, we effectively
			 * perform an LYK_DOWN_HALF-like operation, then move
			 * down to the new line we just added.  --KED 02/14/99
			 *
			 * [There is some redundancy and non-standard
			 * indentation in the monster-if() below.  This is
			 * intentional ...  to try and improve the
			 * "readability" (such as it is).  Caveat emptor to
			 * anyone trying to change it.]
			 */
			if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
			    && ((curdoc.link == nlinks - 1 &&
				 !(more && HText_TAHasMoreLines(curdoc.link, 1)))
				||
				((curdoc.link < nlinks - 1) &&
				 !(links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE))
				||
				((curdoc.link < nlinks - 1) &&
				 ((links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE)
				  && ((links[curdoc.link].l_form->number !=
				       links[curdoc.link + 1].l_form->number) ||
				      (strcmp(links[curdoc.link].l_form->name,
					      links[curdoc.link + 1].l_form->name)
				       != 0)))))) {

			    HText_ExpandTextarea(&links[curdoc.link], 1);

			    if (links[curdoc.link].ly < display_lines) {
				refresh_screen = TRUE;

			    } else {

				Newline += (display_lines / 2);
				if (nlinks > 0 && curdoc.link > -1 &&
				    links[curdoc.link].ly > display_lines / 2) {
				    newdoc.link = curdoc.link;
				    for (i = 0;
					 links[i].ly <= (display_lines / 2);
					 i++)
					--newdoc.link;
				    newdoc.link++;
				}
			    }
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			    if (textfields_need_activation) {
				textinput_activated = TRUE;
				textfields_need_activation = textfields_activation_option;
#ifdef INACTIVE_INPUT_STYLE_VH
				textinput_redrawn = TRUE;
#endif
			    };
#endif

			}
#endif /* TEXTAREA_AUTOGROW */

			/*
			 * Make return in input field (if it was returned by
			 * change_form_link) act as LYK_NEXT_LINK, independent
			 * of what key (if any) is mapped to LYK_NEXT_LINK.  -
			 * kw
			 */
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
			break;
		    default:

			if (old_c != c && old_c != real_c && c != real_c)
			    real_c = c;
		    }
	    } else {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
		if (curlink_is_editable && !textinput_redrawn) {
		    /*draw the text entry, but don't activate it */
		    textinput_redrawn = TRUE;
		    change_form_link_ex(curdoc.link,
					&newdoc, &refresh_screen,
					use_last_tfpos, FALSE, TRUE);
		    if (LYShowCursor) {
			LYmove(links[curdoc.link].ly,
			       ((links[curdoc.link].lx > 0) ?
				(links[curdoc.link].lx - 1) : 0));
		    } else {
			LYHideCursor();
		    }
		}
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
		/*
		 * Get a keystroke from the user.  Save the last keystroke to
		 * avoid redundant error reporting.
		 */
		real_c = c = LYgetch();		/* get user input */

		if (c != last_key)
		    key_count = 0;
		key_count++;
		last_key = c;
#ifndef VMS
		if (c == 3) {	/* ^C */
		    /*
		     * This shouldn't happen.  We'll try to deal with whatever
		     * bug caused it.  - FM
		     */
		    signal(SIGINT, cleanup_sig);
		    old_c = 0;
		    cmd = LYK_QUIT;
		    goto new_cmd;
		}
#endif /* !VMS */
		if (LKC_HAS_ESC_MOD(c) && EditBinding(c) != LYE_FORM_PASS) {
		    /*
		     * If ESC + <key> was read (and not recognized as a
		     * terminal escape sequence for another key), ignore the
		     * ESC modifier and act on <key> only if the line editor
		     * binding would have passed the same ESC-modified
		     * lynxkeycode back to us if it had been pressed in a text
		     * input field.  Otherwise set interesting part so that it
		     * will map to 0, to prevent that ESC + <key> acts like
		     * <key>, which might be unexpected.  - kw
		     */
		    c = (c & ~LKC_MASK) | LAC_TO_LKC(0);
		}
		if (old_c != real_c) {
		    old_c = 0;
		}
	    }
	}

#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = DO_NOTHING;
	}
#else
	if (recent_sizechange) {
	    if (c <= 0)
		c = DO_NOTHING;
	}
#endif /* VMS */

      new_keyboard_input:
	/*
	 * A goto point for new input without going back through the getch()
	 * loop.
	 */
	if (traversal) {
	    if ((c = DoTraversal(c, &crawl_ok)) < 0)
		return (EXIT_FAILURE);
	}
	/* traversal */
#ifdef WIN_EX
	if (c == DO_NOTHING)
	    cmd = LYK_DO_NOTHING;
	else
#endif
	    cmd = LKC_TO_LAC(keymap, c);	/* adds 1 to map EOF to 0 */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override, c))
	    cmd = LKC_TO_LAC(key_override, c);
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

	real_cmd = cmd;

	/*
	 * A goto point for new input without going back through the getch()
	 * loop.
	 */
      new_cmd:

	force_old_UCLYhndl_on_reload = FALSE;
	CTRACE_FLUSH(tfp);

	if (cmd != LYK_UP_LINK && cmd != LYK_DOWN_LINK)
	    follow_col = -1;

	switch (cmd) {
	case -1:
	    HTUserMsg(COMMAND_UNKNOWN);
	    break;
	case 0:		/* unmapped character */
	default:
	    if (curdoc.link >= 0 && curdoc.link < nlinks &&
		links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation) {
		    show_main_statusline(links[curdoc.link], FOR_PANEL);
#ifdef INACTIVE_INPUT_STYLE_VH
		    textinput_redrawn = FALSE;
#endif
		} else
#endif
		    show_main_statusline(links[curdoc.link], FOR_INPUT);
	    } else if (more) {
		HTInfoMsg(MOREHELP);
	    } else {
		HTInfoMsg(HELP);
	    }
	    show_help = TRUE;

	    if (TRACE) {
		sprintf(cfile, "%d", c);
		LYaddstr(cfile);	/* show the user input */
		cfile[0] = '\0';
	    }
	    break;

	case LYK_COMMAND:
	    cmd = handle_LYK_COMMAND(user_input_buffer);
	    goto new_cmd;

	case LYK_INTERRUPT:
	    /*
	     * No network transmission to interrupt - 'til we multithread.
	     */
	    break;

	case LYK_F_LINK_NUM:
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
	case LYK_9:
	    handle_LYK_digit(c, &force_load, user_input_buffer,
			     &old_c, real_c, &try_internal);
	    break;

	case LYK_SOURCE:	/* toggle view source mode */
	    handle_LYK_SOURCE(&ownerS_address);
	    break;

	case LYK_CHG_CENTER:	/* ^Q */

	    if (no_table_center) {
		no_table_center = FALSE;
		HTInfoMsg(gettext("TABLE center enable."));
	    } else {
		no_table_center = TRUE;
		HTInfoMsg(gettext("TABLE center disable."));
	    }
	    /* FALLTHRU */

	case LYK_RELOAD:	/* control-R to reload and refresh */
	    handle_LYK_RELOAD(real_cmd);
	    break;

	case LYK_HISTORICAL:	/* toggle 'historical' comments parsing */
	    handle_LYK_HISTORICAL();
	    break;

	case LYK_MINIMAL:	/* toggle 'minimal' comments parsing */
	    handle_LYK_MINIMAL();
	    break;

	case LYK_SOFT_DQUOTES:
	    handle_LYK_SOFT_DQUOTES();
	    break;

	case LYK_SWITCH_DTD:
	    handle_LYK_SWITCH_DTD();
	    break;

	case LYK_QUIT:		/* quit */
	    if (handle_LYK_QUIT())
		return (EXIT_SUCCESS);
	    break;

	case LYK_ABORT:	/* don't ask the user about quitting */
	    return (EXIT_SUCCESS);

	case LYK_NEXT_PAGE:	/* next page */
	    handle_LYK_NEXT_PAGE(&old_c, real_c);
	    break;

	case LYK_PREV_PAGE:	/* page up */
	    handle_LYK_PREV_PAGE(&old_c, real_c);
	    break;

	case LYK_UP_TWO:
	    handle_LYK_UP_TWO(&arrowup, &old_c, real_c);
	    break;

	case LYK_DOWN_TWO:
	    handle_LYK_DOWN_TWO(&old_c, real_c);
	    break;

	case LYK_UP_HALF:
	    handle_LYK_UP_HALF(&arrowup, &old_c, real_c);
	    break;

	case LYK_DOWN_HALF:
	    handle_LYK_DOWN_HALF(&old_c, real_c);
	    break;

#ifdef CAN_CUT_AND_PASTE
	case LYK_TO_CLIPBOARD:	/* ^S */
	    {
		char *s;
		int ch2;

		/* The logic resembles one of ADD_BOOKMARK */
		if (nlinks > 0 && links[curdoc.link].lname
		    && links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    /* Makes sense to copy a link */
		    _statusline("Copy D)ocument's or L)ink's URL to clipboard or C)ancel?");
		    ch2 = LYgetch_single();
		    if (ch2 == 'D')
			s = curdoc.address;
		    else if (ch2 == 'C')
			break;
		    else
			s = links[curdoc.link].lname;
		} else
		    s = curdoc.address;
		if (isEmpty(s))
		    HTInfoMsg(gettext("Current URL is empty."));
		if (put_clip(s))
		    HTInfoMsg(gettext("Copy to clipboard failed."));
		else if (s == curdoc.address)
		    HTInfoMsg(gettext("Document URL put to clipboard."));
		else
		    HTInfoMsg(gettext("Link URL put to clipboard."));
	    }
	    break;

	case LYK_PASTE_URL:
	    if (no_goto && !LYValidate) {	/*  Go to not allowed. - FM */
		HTUserMsg(GOTO_DISALLOWED);
	    } else {
		unsigned char *s = (unsigned char *) get_clip_grab(), *e, *t;
		char *buf;
		int len2;

		if (!s)
		    break;
		len2 = strlen((const char *) s);
		e = s + len2;
		while (s < e && strchr(" \t\n\r", *s))
		    s++;
		while (s < e && strchr(" \t\n\r", e[-1]))
		    e--;
		if (s[0] == '<' && e > s && e[-1] == '>') {
		    s++;
		    e--;
		    if (!strncasecomp((const char *) s, "URL:", 4))
			s += 4;
		}
		if (s >= e) {
		    HTInfoMsg(gettext("No URL in the clipboard."));
		    break;
		}
		len = e - s + 1;
		if (len < MAX_LINE)
		    len = MAX_LINE;	/* Required for do_check_goto_URL() */
		buf = (char *) malloc(len);
		strncpy(buf, (const char *) s, e - s);
		buf[e - s] = '\0';
		t = (unsigned char *) buf;

		while (s < e) {
		    if (strchr(" \t\n\r", *s)) {
			int nl2 = 0;	/* Keep whitespace without NL - file names! */
			unsigned char *s1 = s;

			while (strchr(" \t\n\r", *s)) {
			    if (!nl2 && *s == '\n')
				nl2 = 1;
			    s++;
			}
			if (!nl2) {
			    while (s1 < s) {
				if (*s1 != '\r' && *s1 != '\r')
				    *t = *s1;
				t++, s1++;
			    }
			}
		    } else
			*t++ = *s++;
		}
		*t = '\0';
		get_clip_release();
		do_check_goto_URL(buf, &temp, &force_load);
		free(buf);
	    }
	    break;
#endif

#ifdef KANJI_CODE_OVERRIDE
	case LYK_CHG_KCODE:	/* ^L */
	    if (LYRawMode && (HTCJK == JAPANESE)) {
		switch (last_kcode) {
		case NOKANJI:
		    last_kcode = SJIS;
		    break;
		case SJIS:
		    last_kcode = EUC;
		    break;
		case EUC:
		    last_kcode = NOKANJI;
		    break;
		default:
		    break;
		}
	    }
	    LYmove(0, 0);
	    lynx_start_title_color();
	    LYaddstr(str_kcode(last_kcode));
	    lynx_stop_title_color();

	    break;
#endif

	case LYK_REFRESH:
	    refresh_screen = TRUE;
	    lynx_force_repaint();
	    break;

	case LYK_HOME:
	    if (curdoc.line > 1)
		Newline = 1;
	    else {
		cmd = LYK_PREV_PAGE;
		goto new_cmd;
	    }
	    break;

	case LYK_END:
	    i = HText_getNumOfLines() - display_lines + 2;
	    if (i >= 1 && Newline != i) {
		Newline = i;	/* go to end of file */
		arrowup = TRUE;	/* position on last link */
	    } else {
		cmd = LYK_NEXT_PAGE;
		goto new_cmd;
	    }
	    break;

	case LYK_FIRST_LINK:
	    handle_LYK_FIRST_LINK();
	    break;

	case LYK_LAST_LINK:
	    handle_LYK_LAST_LINK();
	    break;

	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	    handle_LYK_PREV_LINK(&arrowup, &old_c, real_c);
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	    handle_LYK_NEXT_LINK(c, &old_c, real_c);
	    break;

	case LYK_FASTFORW_LINK:
	    handle_LYK_FASTFORW_LINK(&old_c, real_c);
	    break;

	case LYK_FASTBACKW_LINK:
	    if (handle_LYK_FASTBACKW_LINK(&cmd, &old_c, real_c))
		goto new_cmd;
	    break;

	case LYK_UP_LINK:
	    handle_LYK_UP_LINK(&follow_col, &arrowup, &old_c, real_c);
	    break;

	case LYK_DOWN_LINK:
	    handle_LYK_DOWN_LINK(&follow_col, &old_c, real_c);
	    break;

	case LYK_CHANGE_LINK:
	    do_change_link();
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	    if (textfields_need_activation)
		textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    break;

	case LYK_RIGHT_LINK:
	    handle_LYK_RIGHT_LINK();
	    break;

	case LYK_LEFT_LINK:
	    handle_LYK_LEFT_LINK();
	    break;

	case LYK_COOKIE_JAR:	/* show the cookie jar */
	    if (handle_LYK_COOKIE_JAR(&cmd))
		goto new_cmd;
	    break;

	case LYK_HISTORY:	/* show the history page */
	    if (handle_LYK_HISTORY(ForcePush))
		break;

	    /* FALLTHRU */
	case LYK_PREV_DOC:	/* back up a level */
	    switch (handle_PREV_DOC(&cmd, &old_c, real_c)) {
	    case 1:
		return (EXIT_SUCCESS);
	    case 2:
		goto new_cmd;
	    }
	    break;

	case LYK_NEXT_DOC:	/* undo back up a level */
	    handle_NEXT_DOC();
	    break;

	case LYK_NOCACHE:	/* Force submission of form or link with no-cache */
	    if (!handle_LYK_NOCACHE(&old_c, real_c))
		break;

	    /* FALLTHRU */
	case LYK_ACTIVATE:	/* follow a link */
	case LYK_SUBMIT:	/* follow a link, submit TEXT_SUBMIT input */
	    switch (handle_LYK_ACTIVATE(&c,
					cmd,
					&try_internal,
					&refresh_screen,
					&force_load,
					real_cmd)) {
	    case 1:
		continue;
	    case 2:
		goto new_keyboard_input;
	    case 3:
		pending_form_c = c;
		break;
	    }
	    break;

	case LYK_ELGOTO:	/* edit URL of current link and go to it  */
	    if (handle_LYK_ELGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    break;

	case LYK_ECGOTO:	/* edit current URL and go to to it     */
	    if (handle_LYK_ECGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    break;

	case LYK_GOTO:		/* 'g' to goto a random URL  */
	    if (handle_LYK_GOTO(&ch, user_input_buffer, &temp, &recall,
				&URLTotal, &URLNum, &FirstURLRecall, &old_c,
				real_c)) {
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    }
	    break;

	case LYK_DWIMHELP:	/* show context-dependent help file */
	    handle_LYK_DWIMHELP(&cshelpfile);
	    /* FALLTHRU */

	case LYK_HELP:		/* show help file */
	    handle_LYK_HELP(&cshelpfile);
	    break;

	case LYK_INDEX:	/* index file */
	    handle_LYK_INDEX(&old_c, real_c);
	    break;

	case LYK_MAIN_MENU:	/* return to main screen */
	    handle_LYK_MAIN_MENU(&old_c, real_c);
	    break;

#ifdef EXP_NESTED_TABLES
	case LYK_NESTED_TABLES:
	    if (handle_LYK_NESTED_TABLES(&cmd))
		goto new_cmd;
	    break;
#endif
	case LYK_OPTIONS:	/* options screen */
	    if (handle_LYK_OPTIONS(&cmd, &refresh_screen))
		goto new_cmd;
	    break;

	case LYK_INDEX_SEARCH:	/* search for a user string */
	    handle_LYK_INDEX_SEARCH(&force_load, ForcePush, &old_c, real_c);
	    break;

	case LYK_WHEREIS:	/* search within the document */
	case LYK_NEXT:		/* find the next occurrence in the document */
	case LYK_PREV:		/* find the previous occurrence in the document */
	    handle_LYK_WHEREIS(cmd, &refresh_screen);
	    break;

	case LYK_COMMENT:	/* reply by mail */
	    handle_LYK_COMMENT(&refresh_screen, &owner_address, &old_c, real_c);
	    break;

#ifdef DIRED_SUPPORT
	case LYK_TAG_LINK:	/* tag or untag the current link */
	    handle_LYK_TAG_LINK();
	    break;

	case LYK_MODIFY:	/* rename a file or directory */
	    handle_LYK_MODIFY(&refresh_screen);
	    break;

	case LYK_CREATE:	/* create a new file or directory */
	    handle_LYK_CREATE();
	    break;
#endif /* DIRED_SUPPORT */

	case LYK_DWIMEDIT:	/* context-dependent edit */
	    switch (handle_LYK_DWIMEDIT(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
	    }
	    /* FALLTHRU */

	case LYK_EDIT:		/* edit */
	    handle_LYK_EDIT(&old_c, real_c);
	    break;

	case LYK_DEL_BOOKMARK:	/* remove a bookmark file link */
	    handle_LYK_DEL_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

#ifdef DIRED_SUPPORT
	case LYK_REMOVE:	/* remove files and directories */
	    handle_LYK_REMOVE(&refresh_screen);
	    break;
#endif /* DIRED_SUPPORT */

#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
	case LYK_INSTALL:	/* install a file into system area */
	    handle_LYK_INSTALL();
	    break;
#endif /* DIRED_SUPPORT && OK_INSTALL */

	case LYK_INFO:		/* show document info */
	    if (handle_LYK_INFO(&cmd))
		goto new_cmd;
	    break;

	case LYK_EDIT_TEXTAREA:	/* use external editor on a TEXTAREA - KED */
	    handle_LYK_EDIT_TEXTAREA(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_GROW_TEXTAREA:	/* add new lines to bottom of TEXTAREA - KED */
	    handle_LYK_GROW_TEXTAREA(&refresh_screen);
	    break;

	case LYK_INSERT_FILE:	/* insert file in TEXTAREA, above cursor - KED */
	    handle_LYK_INSERT_FILE(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_PRINT:	/* print the file */
	    handle_LYK_PRINT(&ForcePush, &old_c, real_c);
	    break;

	case LYK_LIST:		/* list links in the current document */
	    if (handle_LYK_LIST(&cmd))
		goto new_cmd;
	    break;

#ifdef EXP_ADDRLIST_PAGE
	case LYK_ADDRLIST:	/* always list URL's (only) */
	    if (handle_LYK_ADDRLIST(&cmd))
		goto new_cmd;
	    break;
#endif /* EXP_ADDRLIST_PAGE */

	case LYK_VLINKS:	/* list links visited during the current session */
	    if (handle_LYK_VLINKS(&cmd, &newdoc_link_is_absolute))
		goto new_cmd;
	    break;

	case LYK_TOOLBAR:	/* go to Toolbar or Banner in current document */
	    handle_LYK_TOOLBAR(&try_internal, &force_load, &old_c, real_c);
	    break;

#if defined(DIRED_SUPPORT) || defined(VMS)
	case LYK_DIRED_MENU:	/* provide full file management menu */
	    handle_LYK_DIRED_MENU(&refresh_screen, &old_c, real_c);
	    break;
#endif /* DIRED_SUPPORT || VMS */

#ifdef USE_EXTERNALS
	case LYK_EXTERN_LINK:	/* use external program on url */
	    handle_LYK_EXTERN_LINK(&refresh_screen);
	    break;
	case LYK_EXTERN_PAGE:	/* use external program on current page */
	    handle_LYK_EXTERN_PAGE(&refresh_screen);
	    break;
#endif /* USE_EXTERNALS */

	case LYK_ADD_BOOKMARK:	/* add link to bookmark file */
	    handle_LYK_ADD_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_VIEW_BOOKMARK:	/* v to view home page */
	    handle_LYK_VIEW_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_SHELL:	/* (!) shell escape */
	    handle_LYK_SHELL(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_DOWNLOAD:
	    switch (handle_LYK_DOWNLOAD(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
	    }
	    break;

#ifdef DIRED_SUPPORT
	case LYK_UPLOAD:
	    handle_LYK_UPLOAD();
	    break;
#endif /* DIRED_SUPPORT */

	case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	    handle_LYK_TRACE_TOGGLE();
	    break;

	case LYK_TRACE_LOG:	/*  View TRACE log. */
	    handle_LYK_TRACE_LOG(&trace_mode_flag);
	    break;

	case LYK_IMAGE_TOGGLE:
	    if (handle_LYK_IMAGE_TOGGLE(&cmd))
		goto new_cmd;
	    break;

	case LYK_INLINE_TOGGLE:
	    if (handle_LYK_INLINE_TOGGLE(&cmd))
		goto new_cmd;
	    break;

	case LYK_RAW_TOGGLE:
	    if (handle_LYK_RAW_TOGGLE(&cmd))
		goto new_cmd;
	    break;

	case LYK_HEAD:
	    if (handle_LYK_HEAD(&cmd))
		goto new_cmd;
	    break;

	case LYK_TOGGLE_HELP:
	    handle_LYK_TOGGLE_HELP();
	    break;

	case LYK_KEYMAP:
	    handle_LYK_KEYMAP(&vi_keys_flag, &emacs_keys_flag, &old_c, real_c);
	    break;

	case LYK_JUMP:
	    if (handle_LYK_JUMP(c, user_input_buffer, &temp, &recall,
				&FirstURLRecall, &URLNum, &URLTotal, &ch,
				&old_c, real_c)) {
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    }
	    break;

	case LYK_CLEAR_AUTH:
	    handle_LYK_CLEAR_AUTH(&old_c, real_c);
	    break;

	case LYK_DO_NOTHING:	/* pretty self explanatory */
	    break;
#ifdef SUPPORT_CHDIR
	case LYK_CHDIR:
	    handle_LYK_CHDIR();
	    break;
#endif
#ifdef USE_CURSES_PADS
	case LYK_SHIFT_LEFT:
	    handle_LYK_SHIFT_LEFT(&refresh_screen, key_count);
	    break;
	case LYK_SHIFT_RIGHT:
	    handle_LYK_SHIFT_RIGHT(&refresh_screen, key_count);
	    break;
	case LYK_LINEWRAP_TOGGLE:
	    if (handle_LYK_LINEWRAP_TOGGLE(&cmd, &refresh_screen))
		goto new_cmd;
	    break;
#endif
	}			/* end of BIG switch */
    }
}

static int are_different(DocInfo *doc1, DocInfo *doc2)
{
    char *cp1, *cp2;

    /*
     * Do we have two addresses?
     */
    if (!doc1->address || !doc2->address)
	return (TRUE);

    /*
     * Do they differ in the type of request?
     */
    if (doc1->isHEAD != doc2->isHEAD)
	return (TRUE);

    /*
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
     */
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
    /*
     * Are the base addresses different?
     */
    if (strcmp(doc1->address, doc2->address)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
	return (TRUE);
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);

    /*
     * Do the docs have different contents?
     */
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
		return (TRUE);
	} else
	    return (TRUE);
    } else if (doc2->post_data)
	return (TRUE);

    /*
     * We'll assume the two documents in fact are the same.
     */
    return (FALSE);
}

/* This determines whether two docs are _physically_ different,
 * meaning they are "from different files". - kw
 */
#ifndef DONT_TRACK_INTERNAL_LINKS
static int are_phys_different(DocInfo *doc1, DocInfo *doc2)
{
    char *cp1, *cp2, *ap1 = doc1->address, *ap2 = doc2->address;

    /*
     * Do we have two addresses?
     */
    if (!doc1->address || !doc2->address)
	return (TRUE);

    /*
     * Do they differ in the type of request?
     */
    if (doc1->isHEAD != doc2->isHEAD)
	return (TRUE);

    /*
     * Skip over possible LYNXIMGMAP parts. - kw
     */
    if (isLYNXIMGMAP(doc1->address))
	ap1 += LEN_LYNXIMGMAP;
    if (isLYNXIMGMAP(doc2->address))
	ap2 += LEN_LYNXIMGMAP;
    /*
     * If there isn't any real URL in doc2->address, but maybe just
     * a fragment, doc2 is assumed to be an internal reference in
     * the same physical document, so return FALSE. - kw
     */
    if (*ap2 == '\0' || *ap2 == '#')
	return (FALSE);

    /*
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
     */
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
    /*
     * Are the base addresses different?
     */
    if (strcmp(ap1, ap2)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
	return (TRUE);
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);

    /*
     * Do the docs have different contents?
     */
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
		return (TRUE);
	} else
	    return (TRUE);
    } else if (doc2->post_data)
	return (TRUE);

    /*
     * We'll assume the two documents in fact are the same.
     */
    return (FALSE);
}
#endif

/*
 * Utility for freeing the list of goto URLs.  - FM
 */
#ifdef LY_FIND_LEAKS
static void HTGotoURLs_free(void)
{
    LYFreeStringList(Goto_URLs);
    Goto_URLs = NULL;
}
#endif

/*
 * Utility for listing Goto URLs, making any repeated URLs the most current in
 * the list.  - FM
 */
void HTAddGotoURL(char *url)
{
    char *copy = NULL;
    char *old;
    HTList *cur;

    if (isEmpty(url))
	return;

    CTRACE((tfp, "HTAddGotoURL %s\n", url));
    StrAllocCopy(copy, url);

    if (!Goto_URLs) {
	Goto_URLs = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTGotoURLs_free);
#endif
	HTList_addObject(Goto_URLs, copy);
	return;
    }

    cur = Goto_URLs;
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, copy)) {
	    HTList_removeObject(Goto_URLs, old);
	    FREE(old);
	    break;
	}
    }
    HTList_addObject(Goto_URLs, copy);

    return;
}

/*
 * When help is not on the screen, put a message on the screen to tell the user
 * other misc info.
 */
static void show_main_statusline(const LinkInfo curlink,
				 int for_what)
{
    /*
     * Make sure form novice lines are replaced.
     */
    if (user_mode == NOVICE_MODE && for_what != FOR_INPUT) {
	noviceline(more);
    }

    if (HTisDocumentSource()) {
	/*
	 * Currently displaying HTML source.
	 */
	_statusline(SOURCE_HELP);

	/*
	 * If we are in forms mode then explicitly tell the user what each kind
	 * of link is.
	 */
#ifdef INDICATE_FORMS_MODE_FOR_ALL_LINKS_ON_PAGE
    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0) {
#else
#ifdef NORMAL_NON_FORM_LINK_STATUSLINES_FOR_ALL_USER_MODES
    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0 &&
	       !(curlink.type & WWW_LINK_TYPE)) {
#else
    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0 &&
	       !(user_mode == ADVANCED_MODE &&
		 (curlink.type & WWW_LINK_TYPE))) {
#endif /* NORMAL_NON_FORM_LINK_STATUSLINES_FOR_ALL_USER_MODES */
#endif /* INDICATE_FORMS_MODE_FOR_ALL_LINKS_ON_PAGE */
	if (curlink.type == WWW_FORM_LINK_TYPE) {
	    show_formlink_statusline(curlink.l_form, for_what);
	} else {
	    statusline(NORMAL_LINK_MESSAGE);
	}

	/*
	 * Let them know if it's an index -- very rare.
	 */
	if (is_www_index) {
	    const char *indx = gettext("-index-");

	    LYmove(LYlines - 1, LYcolLimit - strlen(indx));
	    lynx_start_reverse();
	    LYaddstr(indx);
	    lynx_stop_reverse();
	}

    } else if (user_mode == ADVANCED_MODE && nlinks > 0) {
	/*
	 * Show the URL or, for some internal links, the fragment
	 */
	char *cp = NULL;

	if (curlink.type == WWW_INTERN_LINK_TYPE &&
	    !isLYNXIMGMAP(curlink.lname)) {
	    cp = findPoundSelector(curlink.lname);
	}
	if (!cp)
	    cp = curlink.lname;
	status_link(cp, more, is_www_index);
    } else if (is_www_index && more) {
	char buf[128];

	sprintf(buf, WWW_INDEX_MORE_MESSAGE, key_for_func(LYK_INDEX_SEARCH));
	_statusline(buf);
    } else if (is_www_index) {
	char buf[128];

	sprintf(buf, WWW_INDEX_MESSAGE, key_for_func(LYK_INDEX_SEARCH));
	_statusline(buf);
    } else if (more) {
	if (user_mode == NOVICE_MODE)
	    _statusline(MORE);
	else
	    _statusline(MOREHELP);
    } else {
	_statusline(HELP);
    }

    /* turn off cursor since now it's probably on statusline -HV */
    /* But not if LYShowCursor is on.  -show_cursor may be used as a
     * workaround to avoid putting the cursor in the last position, for
     * curses implementations or terminals that cannot deal with that
     * correctly. - kw */
    if (!LYShowCursor) {
	LYHideCursor();
    }
}

/*
 * Public function for redrawing the statusline appropriate for the selected
 * link.  It should only be called at times when curdoc.link, nlinks, and the
 * links[] array are valid.  - kw
 */
void repaint_main_statusline(int for_what)
{
    if (curdoc.link >= 0 && curdoc.link < nlinks)
	show_main_statusline(links[curdoc.link], for_what);
}

static void form_noviceline(int disabled)
{
    LYmove(LYlines - 2, 0);
    LYclrtoeol();
    if (!disabled) {
	LYaddstr(FORM_NOVICELINE_ONE);
    }
    LYmove(LYlines - 1, 0);
    LYclrtoeol();
    if (disabled)
	return;
    if (EditBinding(FROMASCII('\025')) == LYE_ERASE) {
	LYaddstr(FORM_NOVICELINE_TWO);
    } else if (EditBinding(FROMASCII('\025')) == LYE_DELBL) {
	LYaddstr(FORM_NOVICELINE_TWO_DELBL);
    } else {
	char *temp = NULL;
	char *erasekey = fmt_keys(LYKeyForEditAction(LYE_ERASE), -1);

	if (erasekey) {
	    HTSprintf0(&temp, FORM_NOVICELINE_TWO_VAR, erasekey);
	} else {
	    erasekey = fmt_keys(LYKeyForEditAction(LYE_DELBL), -1);
	    if (erasekey)
		HTSprintf0(&temp,
			   FORM_NOVICELINE_TWO_DELBL_VAR, erasekey);
	}
	if (temp) {
	    LYaddstr(temp);
	    FREE(temp);
	}
	FREE(erasekey);
    }
}

static void exit_immediately_with_error_message(int state,
						BOOLEAN first_file)
{
    char *buf = 0;
    char *buf2 = 0;

    if (first_file) {
	/* print statusline messages as a hint, if any */
	LYstatusline_messages_on_exit(&buf2);
    }

    if (state == NOT_FOUND) {
	HTSprintf0(&buf, "%s\n%s %s\n",
		   NonNull(buf2),
		   gettext("lynx: Can't access startfile"),
	/*
	 * hack: if we fail in HTAccess.c
	 * avoid duplicating URL, oh.
	 */
		   (buf2 && strstr(buf2, gettext("Can't Access"))) ?
		   "" : startfile);
    }

    if (state == NULLFILE) {
	HTSprintf0(&buf, "%s\n%s\n%s\n",
		   NonNull(buf2),
		   gettext("lynx: Start file could not be found or is not text/html or text/plain"),
		   gettext("      Exiting..."));
    }

    FREE(buf2);

    if (!dump_output_immediately)
	cleanup();

#ifdef UNIX
    if (dump_output_immediately) {
	fputs(buf, stderr);
    } else
#endif /* UNIX */
    {
	SetOutputMode(O_TEXT);
	fputs(buf, stdout);
	SetOutputMode(O_BINARY);
    }

    FREE(buf);

    if (!dump_output_immediately) {
	exit_immediately(EXIT_FAILURE);
    }
    /* else: return(EXIT_FAILURE) in mainloop */
}

static void status_link(char *curlink_name,
			BOOLEAN show_more,
			BOOLEAN show_indx)
{
#define MAX_STATUS (LYcolLimit - 1)
#define MIN_STATUS 0
    char format[MAX_LINE];
    int prefix = 0;
    int length;

    *format = 0;
    if (show_more) {
	sprintf(format, "%.*s ",
		(int) (sizeof(format) - 2),
		gettext("-more-"));
	prefix = strlen(format);
    }
    if (show_indx) {
	sprintf(format + prefix, "%.*s ",
		(int) (sizeof(format) - prefix - 2),
		gettext("-index-"));
    }
    prefix = strlen(format);
    length = strlen(curlink_name);

    if (prefix > MAX_STATUS || prefix >= MAX_LINE - 1) {
	_user_message("%s", format);	/* no room for url */
    } else {
	sprintf(format + prefix, "%%.%ds", MAX_STATUS - prefix);

	if ((length + prefix > MAX_STATUS) && long_url_ok) {
	    char *buf = NULL;
	    int cut_from_pos;
	    int cut_to_pos;
	    int n;

	    StrAllocCopy(buf, curlink_name);
	    /*
	     * Scan to find the final leaf of the URL.  Ignore trailing '/'.
	     */
	    for (cut_to_pos = length - 2;
		 (cut_to_pos > 0) && (buf[cut_to_pos] != '/');
		 cut_to_pos--) ;
	    /*
	     * Jump back to the next leaf to remove.
	     */
	    for (cut_from_pos = cut_to_pos - 4;
		 (cut_from_pos > 0) && ((buf[cut_from_pos] != '/')
					|| ((prefix + cut_from_pos
					     + 4
					     + (length - cut_to_pos)) >= MAX_STATUS));
		 cut_from_pos--) ;
	    /*
	     * Replace some leaves to '...', if possible, and put the final
	     * leaf at the end.  We assume that one can recognize the link from
	     * at least MIN_STATUS characters.
	     */
	    if (cut_from_pos > MIN_STATUS) {
		for (n = 1; n <= 3; n++)
		    buf[cut_from_pos + n] = '.';
		for (n = 0; cut_to_pos + n <= length; n++)
		    buf[cut_from_pos + 4 + n] = buf[cut_to_pos + n];
	    }
	    _user_message(format, buf);
	    CTRACE((tfp, "lastline = %s\n", buf));	/* don't forget to erase me */
	    FREE(buf);
	} else {		/* show (possibly truncated) url */
	    _user_message(format, curlink_name);
	}
    }
}

const char *LYDownLoadAddress(void)
{
    return NonNull(newdoc.address);
}
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@a40 1
#include <GridText.h>
d47 1
a47 1
PUBLIC char *str_kcode(HTkcode code)
d93 1
a93 1
PRIVATE char *str_sjis(char *to, char *from)
d109 1
a109 1
PRIVATE void set_ws_title(char * str)
d116 1
a116 2

#ifdef SH_EX  /* 1998/10/30 (Fri) 10:06:47 */
d120 1
a120 1
PRIVATE int str_n_cmp(const char *p, const char *q, int n)
d137 1
a137 1
#endif	/* SH_EX */
d156 2
a157 2
PUBLIC HTLinkType * HTInternalLink = 0;
PUBLIC HTAtom * WWW_SOURCE = 0;
d168 5
a172 6

PRIVATE void exit_immediately_with_error_message PARAMS((int state, BOOLEAN first_file));
PRIVATE void status_link PARAMS((char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx));
PRIVATE void show_main_statusline PARAMS((CONST LinkInfo curlink, int for_what));
PRIVATE void form_noviceline PARAMS((int));
PRIVATE int are_different PARAMS((DocInfo *doc1, DocInfo *doc2));
d175 1
a175 1
PRIVATE int are_phys_different PARAMS((DocInfo *doc1, DocInfo *doc2));
d180 2
a181 3
PRIVATE int sametext ARGS2(
	char *,		een,
	char *,		twee)
d188 1
a188 1
PUBLIC	HTList * Goto_URLs = NULL;  /* List of Goto URLs */
d190 2
a191 2
PUBLIC char * LYRequestTitle = NULL; /* newdoc.title in calls to getfile() */
PUBLIC char * LYRequestReferer = NULL; /* Referer, may be set in getfile() */
d193 1
a193 1
PRIVATE char prev_target[512];
d196 2
a197 2
PUBLIC BOOLEAN display_partial = FALSE; /* could be enabled in HText_new() */
PUBLIC int NumOfLines_partial = 0;  /* number of lines displayed in partial mode */
d200 7
a206 7
PRIVATE int Newline = 0;
PRIVATE DocInfo newdoc;
PRIVATE DocInfo curdoc;
PRIVATE char *traversal_host = NULL;
PRIVATE char *traversal_link_to_add = NULL;
PRIVATE char *owner_address = NULL;  /* Holds the responsible owner's address     */
PRIVATE char *ownerS_address = NULL; /* Holds owner's address during source fetch */
d209 2
a210 1
PRIVATE BOOL textinput_activated = FALSE;
d212 1
a212 1
#define textinput_activated TRUE /* a current text input is always active */
d215 3
a217 2
PUBLIC BOOL textinput_redrawn = FALSE;
    /*must be public since used in LYhighlight(..)*/
d222 1
a222 1
 *  Function for freeing allocated mainloop() variables. - FM
d224 1
a224 1
PRIVATE void free_mainloop_variables NOARGS
d249 1
a249 1
PRIVATE void TracelogOpenFailed NOARGS
d256 1
a256 1
	exit(EXIT_FAILURE);
d260 1
a260 1
PRIVATE BOOLEAN LYReopenTracelog ARGS1(BOOLEAN *, trace_flag_ptr)
d275 1
a275 1
PRIVATE void turn_trace_back_on ARGS1(BOOLEAN *, trace_flag_ptr)
d285 1
a285 1
#define turn_trace_back_on(flag) /*nothing*/
d288 1
a288 1
PUBLIC FILE *TraceFP NOARGS
d298 1
a298 1
PUBLIC BOOLEAN LYOpenTraceLog NOARGS
d323 5
a327 5
	 *  If TRACE is on, indicate whether the
	 *  anonymous restrictions are set. - FM, LP, kw
	 *  This is only a summary for convenience - it doesn't
	 *  take the case of individual -restrictions= options
	 *  into account. - kw
d331 2
a332 1
		CTRACE((tfp, "Validate and some anonymous restrictions are set.\n"));
d334 2
a335 1
		CTRACE((tfp, "Validate restrictions set, restriction \"default\" was given.\n"));
d337 2
a338 1
		CTRACE((tfp, "Validate restrictions set, additional anonymous restrictions ignored.\n"));
d347 2
a348 1
		CTRACE((tfp, "Anonymous restrictions set, restriction \"all\" was given.\n"));
d364 1
a364 1
PUBLIC void LYCloseTracelog NOARGS
d376 1
a376 1
PUBLIC void handle_LYK_TRACE_TOGGLE NOARGS
d379 1
a379 1
    WWW_TraceFlag = ! WWW_TraceFlag;
d387 1
a387 2
PUBLIC void LYSetNewline ARGS1(
	int,		value)
d392 1
a392 1
PUBLIC int LYGetNewline NOARGS
d398 1
a398 1
PRIVATE BOOLEAN from_source_cache = FALSE;
d403 1
a403 1
PRIVATE BOOLEAN reparse_document NOARGS
d406 1
d421 1
a421 2
PRIVATE BOOLEAN reparse_or_reload ARGS1(
    int *,	cmd)
d435 1
a435 3
PRIVATE void set_address ARGS2(
	DocInfo *,	doc,
	CONST char *,	address)
d440 1
a440 3
PRIVATE void copy_address ARGS2(
	DocInfo *,	dst,
	DocInfo *,	src)
d445 1
a445 2
PRIVATE void free_address ARGS1(
	DocInfo *,	doc)
d450 1
a450 3
PRIVATE void move_address ARGS2(
	DocInfo *,	dst,
	DocInfo *,	src)
d460 1
a460 1
 * LYMainLoop.c PRIVATE variables to manage proper newline position
d463 1
a463 2
PUBLIC BOOL LYMainLoop_pageDisplay ARGS1(
	int,		line_num)
d465 1
a465 1
    CONST char * pound;
d469 2
a470 2
     *  Override Newline with a new value if user
     *  scrolled the document while loading (in LYUtils.c).
d494 2
a495 2
	    && *pound && *(pound+1)) {
	    if (HTFindPoundSelector(pound+1)) {
d499 1
a499 1
		Newline = prev_newline; /* restore ??? */
d509 3
a512 3
PRIVATE void set_curdoc_link ARGS1(
    int,	nextlink)
{
d514 3
a516 3
     && nextlink >= 0
     && nextlink < nlinks) {
	if (curdoc.link >= 0 && curdoc.link < nlinks)
d518 2
d522 33
d556 3
d560 1
a560 1
PRIVATE int do_change_link NOARGS
d565 1
d570 1
d576 1
a576 1
	    return(-1);		/* indicates unexpected error */
d578 1
a578 1
	set_curdoc_link(mouse_tmp);
d581 1
a581 1
    return(0);			/* indicates OK */
d591 3
a593 4
PRIVATE void do_check_goto_URL ARGS3(
    char *,	user_input_buffer,
    char **,	old_user_input,
    BOOLEAN *,	force_load)
d596 1
d598 1
a598 1
	CONST char *name;
d637 2
d642 6
a647 6
    /* allow going to anchors*/
    if (*user_input_buffer == '#' ) {
	if ( user_input_buffer[1] &&
	     HTFindPoundSelector(user_input_buffer+1) ) {
	     /* HTFindPoundSelector will initialize www_search_result,
		so we do nothing else. */
d659 1
a659 1
		(int)(MAX_LINE - 1), *old_user_input);
d664 1
a664 1
	     && !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
d681 2
a682 2
	     *  Might be an anchor in the same doc from a POST
	     *  form.  If so, dont't free the content. -- FM
d688 2
a689 1
		StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
d708 7
a714 8
PRIVATE BOOL do_check_recall ARGS7(
    int,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int,	URLTotal,
    int *,	URLNum,
    int,	recall,
    BOOLEAN *,	FirstURLRecall)
d723 1
a723 1
#ifdef WIN_EX	/* 1998/10/11 (Sun) 10:41:05 */
d728 2
a729 2
	     && LYIsHtmlSep(user_input_buffer[len - 3])
	     && LYIsDosDrive(user_input_buffer + len - 2))
d733 9
a741 9
		if (LYIsDosDrive(user_input_buffer)) {
			LYAddPathSep0(user_input_buffer);
		} else {
			HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
			LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
			FREE(*old_user_input);
			ret = FALSE;
			break;
		}
d774 2
a775 2
	    if ((cp = (char *)HTList_objectAt(Goto_URLs,
					      *URLNum)) != NULL) {
d778 2
a779 2
		 && **old_user_input
		 && !strcmp(*old_user_input, user_input_buffer)) {
d788 2
a789 2
				  MAX_LINE,
				  recall)) < 0) {
d791 2
a792 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d820 1
a820 1
	    if ((cp=(char *)HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
d835 2
a836 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d854 1
a854 1
PRIVATE void do_cleanup_after_delete NOARGS
d859 1
a859 1
    if (curdoc.link == nlinks-1) {
d863 1
a863 1
	newdoc.link = curdoc.link-1;
d869 2
a870 3
PRIVATE int find_link_near_col ARGS2(
	int,	col,
	int,	delta)
d875 1
a875 1
	if ( (links[i].ly - links[curdoc.link].ly) * delta > 0 ) {
d880 1
a880 1
		char *text = LYGetHiliteStr(i, 0);
d893 1
a893 1
	    return(best);
d896 1
a896 1
    return(-1);
d905 2
a906 3
PRIVATE int DoTraversal ARGS2(
    int,	c,
    BOOLEAN *,	crawl_ok)
d913 2
a914 2
		    links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].lname != NULL);
d919 2
a920 2
	     traversal_host &&
	     links[curdoc.link].lname) {
d923 2
a924 2
					 links[curdoc.link].lname,
					 strlen(traversal_host));
d927 2
a928 2
					 links[curdoc.link].lname + LEN_LYNXIMGMAP,
					 strlen(traversal_host));
d937 1
a937 1
	if (lookup(links[curdoc.link].lname)) {
d939 5
a943 5
		(curdoc.link > -1 && curdoc.link < nlinks -1))
		 c= DNARROW;
	    else {
		if (STREQ(curdoc.title,"Entry into main screen") ||
		    (nhist <= 0 )) {
d948 3
a950 1
		    return(-1);
a951 1
		c = LTARROW;
d960 2
a961 2
    } else { /* no good right link, so only down and left arrow ok*/
	if (rlink_exists /* && !rlink_rejected */)
d965 1
a965 1
	    (curdoc.link > -1 && curdoc.link < nlinks-1))
d967 1
a967 1
	else {
d969 2
a970 2
	     *	curdoc.title doesn't always work, so
	     *	bail out if the history list is empty.
d972 2
a973 2
	    if (STREQ(curdoc.title,"Entry into main screen") ||
		(nhist <= 0 )) {
d978 3
a980 1
		return(-1);
a981 1
	    c = LTARROW;
d983 5
a987 1
    } /* right link not NULL or link to another site*/
d992 1
a992 1
PRIVATE BOOLEAN check_history NOARGS
d994 1
a994 1
    CONST char *base;
d998 1
a998 2
	 *  Normal case - List Page is not associated
	 *  with post data. - kw
d1003 8
a1010 7
     && !LYresubmit_posts
     && HDOC(nhist - 1).post_data
     && BINEQ(curdoc.post_data, HDOC(nhist - 1).post_data)
     && (base = HText_getContentBase()) != 0) {
	 char *text = !isLYNXIMGMAP(HDOC(nhist - 1).address)
		     ? HDOC(nhist - 1).address
		     : HDOC(nhist - 1).address + LEN_LYNXIMGMAP;
d1028 6
a1033 7
PRIVATE int handle_LYK_ACTIVATE ARGS6(
    int *,	c,
    int,	cmd GCC_UNUSED,
    BOOLEAN *,	try_internal GCC_UNUSED,
    BOOLEAN *,	refresh_screen,
    BOOLEAN *,	force_load,
    int,	real_cmd)
d1038 1
a1038 1
	return 1;	/* mouse stuff was confused, ignore - kw */
d1054 1
a1054 1
	     *	Don't try to submit forms with bad actions. - FM
d1059 1
a1059 1
					    F_TEXT_SUBMIT_TYPE) {
d1061 1
a1061 1
		 *  Do nothing if it's disabled. - FM
d1070 1
a1070 1
		 *  Make sure we have an action. - FM
d1074 1
a1074 1
							== '\0') {
d1082 1
a1082 2
		 *  Check for no_mail if the form action
		 *  is a mailto URL. - FM
d1085 1
a1085 1
			     == URL_MAIL_METHOD && no_mail) {
d1093 2
a1094 2
		 *  Make sure this isn't a spoof in an account
		 *  with restrictions on file URLs. - FM
d1105 2
a1106 2
		 *  Make sure this isn't a spoof attempt
		 *  via an internal URL. - FM
d1113 2
a1114 2
		      strncasecomp(
			(links[curdoc.link].l_form->submit_action + 10),
d1131 1
a1131 1
				links[curdoc.link].l_form->submit_action));
d1137 1
a1137 1
#ifdef NOTDEFINED /* We're disabling form inputs instead of using this. - FM */
d1139 2
a1140 2
		 *  Check for enctype and let user know we
		 *  don't yet support multipart/form-data - FM
d1143 1
a1143 2
		    if (!strcmp(
			     links[curdoc.link].l_form->submit_enctype,
d1145 1
a1145 2
			HTAlert(
gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
d1166 3
a1168 4
	     *	Normally we don't get here for text input fields,
	     *  but it can happen as a result of mouse positioning.
	     *  In that case the statusline will not have updated
	     *  info, so update it now. - kw
d1181 1
a1181 1
			form_noviceline(links[curdoc.link].l_form->disabled);
d1186 6
a1191 6
				 &newdoc, refresh_screen,
				 FALSE,
				 (BOOLEAN)(real_cmd == LYK_SUBMIT ||
				  real_cmd == LYK_NOCACHE ||
				  real_cmd == LYK_DOWNLOAD ||
				  real_cmd == LYK_HEAD));
d1194 2
a1195 2
		 *  Cannot have been a submit field for which
		 *  newdoc was filled in. - kw
d1201 1
a1201 1
			     != URL_MAIL_METHOD) {
d1203 1
a1203 1
		     *  Try to undo change of newdoc.title done above.
d1234 7
a1240 8
		 *  Moved here from earlier to only apply when it
		 *  should.   Anyway, why should realm checking be
		 *  overridden for form submissions, this seems to
		 *  be an unnecessary loophole??  But that's the way
		 *  it was, maybe there is some reason.
		 *  However, at least make sure this doesn't weaken
		 *  restrictions implied by -validate!
		 *  - kw 1999-05-25
d1252 4
a1255 5
		/*  Avoid getting stuck with repeatedly calling
		**  handle_LYK_ACTIVATE(), instead of calling
		**  change_form_link() directly from mainloop(),
		**  for text input fields. - kw
		*/
d1262 1
a1262 1
			textinput_activated)
d1264 1
d1271 1
a1271 1
	     *	Not a forms link.
d1273 2
a1274 2
	     *	Make sure this isn't a spoof in an account
	     *	with restrictions on file URLs. - FM
d1293 2
a1294 3
	     *	Make sure this isn't a spoof attempt
	     *	via an internal URL in a non-internal
	     *	document. - FM
d1316 6
a1321 7
		    HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}

d1323 1
a1323 2
	    if (run_external(links[curdoc.link].lname, TRUE))
	    {
d1330 1
a1330 1
	     *	Follow a normal link or anchor.
a1334 7
	/*
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
	 */
d1336 10
a1345 3
	     *	Might be an internal link anchor in the same doc.
	     *	If so, take the try_internal shortcut if we didn't
	     *	fall through from LYK_NOCACHE. - kw
d1351 3
a1353 4
		 *  Special case of List Page document with an
		 *  internal link indication, which may really stand
		 *  for an internal link within the document the
		 *  List Page is about. - kw
d1361 1
a1361 1
			HTLastConfirmCancelled(); /* reset flag */
d1364 4
a1367 2
					(LYresubmit_posts &&
			       HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
d1401 2
a1402 2
		     *	Don't push the List Page if we follow an
		     *	internal link given by it. - kw
d1411 2
a1412 1
		** etc. will be done.  - kw */
d1417 1
a1417 1
		 *  Free POST content if not an internal link. - kw
d1423 2
a1424 2
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
d1454 9
a1462 10
		  DIRED_UNCACHE_2;
		  /*
		   *  Unescaping any slash chars in the URL,
		   *  but avoid double unescaping and too-early
		   *  unescaping of other chars. - KW
		   */
		  HTUnEscapeSome(newdoc.address,"/");
		  /* avoid stripping final slash for root dir - kw */
		  if (strcasecomp(newdoc.address, "file://localhost/"))
		      strip_trailing_slash(newdoc.address);
d1474 1
a1474 2
PRIVATE BOOLEAN handle_LYK_ADDRLIST ARGS1(
    int *,     cmd)
d1477 1
a1477 1
     *	Don't do if already viewing list addresses page.
d1481 1
a1481 1
	 *  Already viewing list page, so get out.
d1488 1
a1488 1
     *	Print address list page to file.
d1494 3
a1496 4
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
d1507 3
a1509 4
PRIVATE void handle_LYK_ADD_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d1514 1
a1514 1
	if (*old_c != real_c)	{
d1547 3
a1549 4
		 *  The document doesn't have POST content,
		 *  and is not a bookmark file, nor is the
		 *  list or visited links page, so we can
		 *  save either that or the link. - FM
d1554 1
a1554 1
		    *refresh_screen = TRUE; /* MultiBookmark support */
d1562 2
a1563 2
					  ? (bookmark_page+1)
					  : bookmark_page)) != NULL) {
d1565 3
a1567 4
		     *	If multiple bookmarks are disabled, offer
		     *	the L)ink or C)ancel, but with wording
		     *	which indicates that the link already
		     *	exists in this bookmark file. - FM
d1573 1
a1573 1
		     *	Internal link, and document has POST content.
d1579 3
a1581 4
		     *	Only offer the link in a document with
		     *	POST content, or if the current document
		     *	is a bookmark file and multiple bookmarks
		     *	are enabled. - FM
d1591 1
a1591 1
		     *	Internal link, and document has POST content.
d1597 1
a1597 1
		 *  User does want to save the link. - FM
d1602 1
a1602 1
		    *refresh_screen = TRUE; /* MultiBookmark support */
d1612 1
a1612 1
	     *	No links, and document has POST content. - FM
d1618 2
a1619 2
	     *	It's a bookmark file from which all
	     *	of the links were deleted. - FM
d1627 1
a1627 1
		*refresh_screen = TRUE; /* MultiBookmark support */
d1632 1
a1632 1
check_add_bookmark_to_self:
d1643 1
a1643 1
	if (*old_c != real_c)	{
d1650 2
a1651 3
PRIVATE void handle_LYK_CLEAR_AUTH ARGS2(
    int *,	old_c,
    int,	real_c)
d1674 1
a1674 2
PRIVATE int handle_LYK_COMMAND ARGS1(
    char *,	user_input_buffer)
d1697 4
a1700 5
PRIVATE void handle_LYK_COMMENT ARGS4(
    BOOLEAN *,	refresh_screen,
    char **,	owner_address_p,
    int *,	old_c,
    int,	real_c)
d1702 1
a1702 1
    int	c;
d1706 1
a1706 1
	if (*old_c != real_c)	{
d1719 2
a1720 2
		 *  No owner defined, so make a guess and
		 *  and offer it to the user. - FM
d1730 1
a1730 1
			 *  It's a ~user URL so guess user@@host. - FM
d1732 1
a1732 1
			if ((cp = strchr((temp+1), '/')) != NULL)
d1735 1
a1735 1
			StrAllocCat(address, (temp+1));
d1742 1
a1742 1
		     *	Wasn't a ~user URL so guess WebMaster@@host. - FM
d1760 1
a1760 1
		 *  The address is a URL.  Just follow the link.
d1766 1
a1766 1
		 *  The owner_address is a mailto: URL.
d1768 2
a1769 2
		CONST char *kp = HText_getRevTitle();
		CONST char *id = HText_getMessageID();
d1771 1
d1774 1
a1774 1
		    if (kp && *kp) {
d1784 6
a1789 6
		     /*
		      *  Send a reply.	The address is after the colon.
		      */
		     reply_by_mail(strchr(*owner_address_p, ':') + 1,
				   curdoc.address,
				   NonNull(kp), id);
d1795 1
a1795 1
		*refresh_screen = TRUE;	/* to force a showpage */
d1801 1
a1801 2
PRIVATE BOOLEAN handle_LYK_COOKIE_JAR ARGS1(
    int *,	cmd)
d1804 1
a1804 1
     *	Don't do if already viewing the cookie jar.
d1819 1
a1819 1
	 *  If already in the cookie jar, get out.
d1828 1
a1828 1
PRIVATE void handle_LYK_CREATE NOARGS
d1846 3
a1848 4
PRIVATE void handle_LYK_DEL_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d1851 1
a1851 1
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE,NO) != YES)
d1853 1
a1853 1
	remove_bookmark_link(links[curdoc.link].anchor_number-1,
d1855 1
a1855 1
    } else {	/* behave like REFRESH for backward compatibility */
d1867 3
a1869 4
PRIVATE void handle_LYK_DIRED_MENU ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c GCC_UNUSED,
    int,	real_c GCC_UNUSED)
d1876 6
a1881 7
     *	Check if the CSwing Directory/File Manager is available.
     *	Will be disabled if CSWING path is NULL, zero-length,
     *	or "none" (case insensitive), if no_file_url was set via
     *	the file_url restriction, if no_goto_file was set for
     *	the anonymous account, or if HTDirAccess was set to
     *	HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse
     *	or -selective switches. - FM
d1888 1
a1888 1
	if (*old_c != real_c)	{
d1896 5
a1900 7
     *	If we are viewing a local directory listing or a
     *	local file which is not temporary, invoke CSwing
     *	with the URL's directory converted to VMS path specs
     *	and passed as the argument, so we start up CSwing
     *	positioned on that node of the directory tree.
     *	Otherwise, pass the current default directory as
     *	the argument. - FM
d1906 2
a1907 2
	 *  We are viewing a local directory or a local file
	 *  which is not temporary. - FM
d1911 1
a1911 1
	cp = HTParse(curdoc.address, "", PARSE_PATH|PARSE_PUNCTUATION);
d1917 1
a1917 1
	    *refresh_screen = TRUE;  /* redisplay */
d1923 2
a1924 2
		 *  We're viewing a local directory.  Make
		 *  that the CSwing argument. - FM
d1931 2
a1932 2
		 *  We're viewing a local file.  Make its
		 *  directory the CSwing argument. - FM
d1947 2
a1948 3
	     *	Uncache the current document in case we
	     *	change, move, or delete it during the
	     *	CSwing session. - FM
d1961 3
a1963 4
	 *  We're not viewing a local directory or file.
	 *  Pass CSwing the current default directory as
	 *  an argument and don't uncache the current
	 *  document. - FM
d1974 1
a1974 1
     *	Don't do if not allowed or already viewing the menu.
d1979 1
a1979 1
	dired_options(&curdoc,&newdoc.address);
d1986 3
a1988 4
PRIVATE int handle_LYK_DOWNLOAD ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
d1992 1
a1992 1
     *	Don't do if both download and disk_save are restricted.
d1996 1
a1996 1
	if (*old_c != real_c)	{
d2004 1
a2004 1
     *	Don't do if already viewing download options page.
d2010 1
a2010 1
	return 1;	/* mouse stuff was confused, ignore - kw */
d2017 1
a2017 1
			 URL_MAIL_METHOD) {
d2042 1
a2042 1
	    if (*old_c != real_c)	{
d2048 1
a2048 1
	    if (*old_c != real_c)	{
a2051 1

d2054 1
a2054 1
	    if (*old_c != real_c)	{
d2060 1
a2060 1
	    if (*old_c != real_c)	{
d2068 1
a2068 1
	     *	Don't bother making a /tmp copy of the local file.
d2071 1
d2083 1
a2083 1
	    isLYNXHIST(links[curdoc.link].lname)) {
d2085 1
d2097 1
a2097 1
	     *  OK, we download from history page, restore URL from stack.
d2116 1
a2116 1
	     *	Force the document to be reloaded.
d2132 1
a2132 1
		   /* handled above if valid - kw */
d2143 9
a2151 9
	/*
	 *  From here on we could have a remote host, so check if
	 *  that's allowed.
	 *
	 *  We copy all these checks from getfile() to LYK_DOWNLOAD
	 *  here because LYNXDOWNLOAD:// will NOT be pushing the
	 *  previous document into the history stack so preserve
	 *  getfile() from returning a wrong status (NULLFILE).
	 */
d2156 1
a2156 1
	} else {   /* Not a forms, options or history link */
d2158 2
a2159 3
	     *	Follow a normal link or anchor.  Note that
	     *	if it's an anchor within the same document,
	     *	entire document will be downloaded.
d2165 2
a2166 2
	     *	Might be an internal link in the same doc from a
	     *	POST form.  If so, don't free the content. - kw
d2171 2
a2172 2
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
d2186 1
a2186 1
	     *	Force the document to be reloaded.
d2197 2
a2198 3
PRIVATE void handle_LYK_DOWN_HALF ARGS2(
    int *,	old_c,
    int,	real_c)
d2203 1
a2203 1
	Newline += (display_lines/2);
d2205 1
a2205 1
	    links[curdoc.link].ly > display_lines/2) {
d2207 1
a2207 1
	    for (i = 0; links[i].ly <= (display_lines/2); i++)
d2216 3
a2218 4
PRIVATE void handle_LYK_DOWN_LINK ARGS3(
    int *,	follow_col,
    int *,	old_c,
    int,	real_c)
d2220 1
a2220 1
    if (curdoc.link < (nlinks-1)) {	/* more links? */
d2224 2
a2225 1
	    char *text = LYGetHiliteStr(curdoc.link, 0);
d2235 1
a2235 1
	} else if (more) {  /* next page */
d2242 2
a2243 2
    } else if (more) {	/* next page */
	    Newline += (display_lines);
d2251 2
a2252 3
PRIVATE void handle_LYK_DOWN_TWO ARGS2(
    int *,	old_c,
    int,	real_c)
d2270 3
a2272 4
PRIVATE int handle_LYK_DWIMEDIT ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
d2276 6
a2281 7
     *  If we're in a forms TEXTAREA, invoke the editor on *its*
     *  contents, rather than attempting to edit the html source
     *  document.  KED
     */
    if (nlinks > 0  &&
	links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d2287 4
a2290 5
     *  If we're in a forms TEXT type, tell user the request
     *  is bogus (though in reality, without this trap, if the
     *  document with the TEXT field is local, the editor *would*
     *  be invoked on the source .html file; eg, the o(ptions)
     *  form tempfile).
d2292 2
a2293 3
     *  [This is done to avoid possible user confusion, due to
     *   auto invocation of the editor on the TEXTAREA's contents
     *   via the above if() statement.]
d2296 3
a2298 3
	links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXT_TYPE)       {
	HTUserMsg (CANNOT_EDIT_FIELD);
d2313 5
a2317 6
PRIVATE int handle_LYK_ECGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
d2321 1
a2321 1
	 *  Go to not allowed. - FM
d2334 1
a2334 1
	 *  Disallow editing of File Management URLs. - FM
d2345 2
a2346 2
     *	Save the current user_input_buffer string,
     *	and load the current document's address.
d2354 2
a2355 2
     *	Warn the user if the current document has POST
     *	data associated with it. - FM
d2361 1
a2361 1
     *	Offer the current document's URL for editing. - FM
d2365 1
a2365 1
			MAX_LINE, RECALL_URL)) >= 0) &&
d2374 1
a2374 2
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
d2382 2
a2383 3
PRIVATE void handle_LYK_EDIT ARGS2(
    int *,	old_c,
    int,	real_c)
a2396 1

d2398 5
a2402 6
    /*
     *	Allow the user to edit the link rather
     *	than curdoc in edit mode.
     */
    if (lynx_edit_mode &&
	editor && *editor != '\0' && !no_dired_support) {
d2421 1
a2421 1
			     *	Go to top of file.
d2427 1
a2427 2
			     *	Seek old position,
			     *	which probably changed.
d2432 1
a2432 1
			    LYclear();  /* clear the screen */
d2441 1
a2441 1
    if (editor && *editor != '\0') {
d2444 2
a2445 2
	    LYforce_no_cache = TRUE;  /*force reload of document */
	    free_address(&curdoc); /* so it doesn't get pushed */
d2448 1
a2448 1
	     *	Go to top of file.
d2454 1
a2454 1
	     *	Seek old position, which probably changed.
d2459 1
a2459 1
	    LYclear();  /* clear the screen */
d2470 1
a2470 2
PRIVATE void handle_LYK_DWIMHELP ARGS1(
    CONST char **,	cshelpfile)
d2473 2
a2474 3
     *  Currently a help file different from the main
     *  'helpfile' is shown only if current link is a
     *  text input form field. - kw
d2484 3
a2486 4
PRIVATE void handle_LYK_EDIT_TEXTAREA ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d2502 1
a2502 1
     *  See if the current link is in a form TEXTAREA.
d2504 2
a2505 2
    else if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d2510 1
a2510 1
	n = HText_ExtEditForm (&links[curdoc.link]);
d2513 5
a2517 6
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st trailing blank line in
	 *	  the now edited TEXTAREA.  If the target line/
	 *	  anchor requires us to scroll up/down, position
	 *	  the target in the approximate center of the
	 *	  screen.
d2520 2
a2521 2
	/* curdoc.link += n;*/	/* works, except for page crossing, */
				/* damnit; why is nothing ever easy */
d2529 1
a2529 1
	HTInfoMsg (NOT_IN_TEXTAREA_NOEDIT);
d2533 5
a2537 6
PRIVATE int handle_LYK_ELGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
d2541 1
a2541 1
	 *  Go to not allowed. - FM
d2555 1
a2555 2
	 *  No links on page, or not a normal link
	 *  or form submit button. - FM
d2567 1
a2567 1
	 *  Form submit button with no ACTION defined. - FM
d2581 1
a2581 1
	 *  Disallow editing of File Management URLs. - FM
d2592 2
a2593 2
     *	Save the current user_input_buffer string,
     *	and load the current link's address. - FM
d2598 2
a2599 2
					?
    links[curdoc.link].l_form->submit_action : links[curdoc.link].lname),
d2603 1
a2603 1
     *	Offer the current link's URL for editing. - FM
d2607 1
a2607 1
			MAX_LINE, RECALL_URL)) >= 0) &&
d2611 2
a2612 2
			? links[curdoc.link].l_form->submit_action
			: links[curdoc.link].lname))) {
d2619 1
a2619 2
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
d2628 1
a2628 2
PRIVATE void handle_LYK_EXTERN_LINK ARGS1(
    BOOLEAN *,	refresh_screen)
d2630 1
a2630 2
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL))
    {
d2636 1
a2636 2
PRIVATE void handle_LYK_EXTERN_PAGE ARGS1(
    BOOLEAN *,	refresh_screen)
d2638 1
a2638 2
    if (curdoc.address != NULL)
    {
d2645 3
a2647 4
PRIVATE BOOLEAN handle_LYK_FASTBACKW_LINK ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
d2655 2
a2656 2
	 *  If in textarea, move to first link or textarea group
	 *  before it if there is one on this screen. - kw
d2668 2
a2669 1
		do nextlink--;
d2682 4
a2685 4
		       !(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks-1].l_form->type == F_TEXTAREA_TYPE &&
			 links[nlinks-1].l_form->number == thisgroup &&
			 sametext(links[nlinks-1].l_form->name, thisname))) {
d2703 3
a2705 3
	 *  If the link as determined so far is part of a
	 *  group of textarea fields, try to use the first
	 *  of them that's on the screen instead. - kw
d2712 1
d2721 4
a2724 4
		     links[nextlink-1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink-1].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink-1].l_form->number == thisgroup &&
		     sametext(links[nextlink-1].l_form->name, thisname)) {
d2737 2
a2738 2
	     *  It says we should use the normal PREV_LINK
	     *  mechanism, so we'll do that. - kw
d2745 1
a2745 1
	Newline++;	/* our line counting starts with 1 not 0 */
d2755 2
a2756 3
PRIVATE void handle_LYK_FASTFORW_LINK ARGS2(
    int *,	old_c,
    int,	real_c)
d2763 2
a2764 2
	 *  If in textarea, move to first link or field
	 *  after it if there is one on this screen. - kw
d2771 7
a2777 6
	    if (curdoc.link < nlinks-1 &&
		!(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks-1].l_form->type == F_TEXTAREA_TYPE &&
		  links[nlinks-1].l_form->number == thisgroup &&
		  sametext(links[nlinks-1].l_form->name, thisname))) {
		do nextlink++;
d2788 1
a2788 1
	} else if (curdoc.link < nlinks-1) {
d2798 1
a2798 1
	return;		/* and we are done. */
d2800 5
a2804 5
    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
d2807 1
a2807 1
    } else if (more &&	/* need a later page */
d2811 1
a2811 1
	Newline++;	/* our line counting starts with 1 not 0 */
d2821 1
a2821 1
PRIVATE void handle_LYK_FIRST_LINK NOARGS
d2827 1
a2827 1
	 || links[i].ly != links[curdoc.link].ly) {
d2834 9
a2842 10
PRIVATE BOOLEAN handle_LYK_GOTO ARGS9(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	recall,
    int *,	URLTotal,
    int *,	URLNum,
    BOOLEAN *,	FirstURLRecall,
    int *,	old_c,
    int,	real_c)
d2869 1
a2869 1
     *	Ask the user.
d2873 1
a2873 1
		       MAX_LINE, *recall)) < 0 ) {
d2875 2
a2876 2
	 *  User cancelled the Goto via ^G.
	 *  Restore user_input_buffer and break. - FM
d2886 1
a2886 2
PRIVATE void handle_LYK_GROW_TEXTAREA ARGS1(
    BOOLEAN *,	refresh_screen)
d2889 1
a2889 1
     *  See if the current link is in a form TEXTAREA.
d2891 2
a2892 2
    if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d2894 1
a2894 1
	HText_ExpandTextarea (&links[curdoc.link], TEXTAREA_EXPAND_SIZE);
d2900 1
a2900 1
	HTInfoMsg (NOT_IN_TEXTAREA);
d2904 1
a2904 2
PRIVATE BOOLEAN handle_LYK_HEAD ARGS1(
    int *,	cmd)
d2909 1
a2909 1
	(links[curdoc.link].type         != WWW_FORM_LINK_TYPE ||
d2921 3
a2923 2
			 ? curdoc.address
			 : curdoc.address + LEN_LYNXIMGMAP;
d2963 1
a2963 1
							 "http", 4)) {
d2967 1
a2967 1
						  URL_POST_METHOD &&
d3005 3
a3007 2
			     ? curdoc.address
			     : curdoc.address + LEN_LYNXIMGMAP;
d3031 1
a3031 2
PRIVATE void handle_LYK_HELP ARGS1(
    CONST char **,	cshelpfile)
d3033 2
d3037 3
a3039 1
    if (!STREQ(curdoc.address, *cshelpfile)) {
d3041 1
a3041 1
	 *  Set the filename.
d3043 1
a3043 1
	set_address(&newdoc, *cshelpfile);
d3045 1
a3045 1
	 *  Make a name for this help file.
d3054 1
d3058 1
a3058 1
PRIVATE void handle_LYK_HISTORICAL NOARGS
d3063 14
a3076 15
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HText_setNoCache(HTMainText);
	move_address(&newdoc, &curdoc);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
d3078 1
a3078 1
    } /* end if no bypass */
d3094 1
a3094 2
PRIVATE BOOLEAN handle_LYK_HISTORY ARGS1(
    BOOLEAN,	ForcePush)
d3098 1
a3098 1
	 *  Don't do this if already viewing history page.
d3100 3
a3102 3
	 *  Push the current file so that the history list
	 *  contains the current file for printing purposes.
	 *  Pop the file afterwards to prevent multiple copies.
d3114 1
a3114 1
	 *  Print history options to file.
d3127 2
a3128 2
	newdoc.link = 1; /*@@@@@@ bypass "recent statusline messages" link */
	free_address(&curdoc);  /* so it doesn't get pushed */
d3134 1
a3134 1
    } /* end if strncmp */
d3138 1
a3138 2
PRIVATE BOOLEAN handle_LYK_IMAGE_TOGGLE ARGS1(
    int *,	cmd)
d3143 1
a3143 1
	     CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
d3147 2
a3148 3
PRIVATE void handle_LYK_INDEX ARGS2(
    int *,	old_c,
    int,	real_c)
d3151 1
a3151 1
     *	Make sure we are not in the index already.
d3155 5
a3159 5
	if (indexfile[0]=='\0') { /* no defined index */
		if (*old_c != real_c)	{
		    *old_c = real_c;
		    HTUserMsg(NO_INDEX_FILE);
		}
d3168 1
a3168 1
	    StrAllocCopy(newdoc.title, gettext("System Index")); /* name it */
d3174 2
a3175 2
	} /* end else */
    }  /* end if */
d3178 4
a3181 5
PRIVATE void handle_LYK_INDEX_SEARCH ARGS4(
    BOOLEAN *,	force_load,
    BOOLEAN,	ForcePush,
    int *,	old_c,
    int,	real_c)
d3185 1
a3185 1
	 *  Perform a database search.
d3187 3
a3189 3
	 *  do_www_search will try to go out and get the document.
	 *  If it returns TRUE, a new document was returned and is
	 *  named in the newdoc.address.
d3195 1
a3195 1
	     *	Yah, the search succeeded.
d3199 1
a3199 1
		 *  Make sure cursor is down.
d3209 3
a3211 3
	     *	Make the curdoc.address the newdoc.address so that
	     *	getfile doesn't try to get the newdoc.address.
	     *	Since we have already gotten it.
d3221 1
a3221 1
	     *	Got back a redirecting URL.  Check it out.
d3223 1
a3223 1
	    HTUserMsg2 (WWW_USING_MESSAGE, use_this_url_instead);
d3226 1
a3226 1
	     *	Make a name for this URL.
d3240 1
a3240 1
	     *	Yuk, the search failed.  Restore the old file.
d3257 1
a3257 2
PRIVATE BOOLEAN handle_LYK_INFO ARGS1(
    int *,	cmd)
d3260 1
a3260 1
     *	Don't do if already viewing info page.
d3264 1
a3264 2
	 && LYShowInfo(&curdoc, HText_getNumOfLines(),
		       &newdoc, owner_address) >= 0) {
d3278 1
a3278 1
	 *  If already in info page, get out.
d3286 1
a3286 2
PRIVATE BOOLEAN handle_LYK_INLINE_TOGGLE ARGS1(
    int *,	cmd)
d3295 3
a3297 4
PRIVATE void handle_LYK_INSERT_FILE ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d3302 1
a3302 1
     *  See if the current link is in a form TEXTAREA.
d3304 2
a3305 2
    if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d3308 6
a3313 8
	 *  Reject attempts to use this for gaining access to
	 *  local files when such access is restricted:
	 *  if no_file_url was set via the file_url restriction,
	 *  if no_goto_file was set for the anonymous account,
	 *  or if HTDirAccess was set to HT_DIR_FORBID or
	 *  HT_DIR_SELECTIVE via the -nobrowse or -selective
	 *  switches, it is assumed that inserting files or
	 *  checking for existence of files needs to be denied. - kw
d3329 1
a3329 1
	n = HText_InsertFile (&links[curdoc.link]);
d3332 5
a3336 5
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st line following the text
	 *	  that was inserted.  If the target line/anchor
	 *	  requires us to scroll up/down, position the
	 *	  target in the approximate center of the screen.
d3338 4
a3341 4
	 *  [Current behavior leaves cursor on the same line relative
	 *   to the start of the TEXTAREA that it was on before the
	 *   insertion.  This is the same behavior that occurs with
	 *   (my) editor, so this TODO will stay unimplemented.]
d3348 1
a3348 1
	HTInfoMsg (NOT_IN_TEXTAREA);
d3353 1
a3353 1
PRIVATE void handle_LYK_INSTALL NOARGS
d3360 10
a3369 11
PRIVATE BOOLEAN handle_LYK_JUMP ARGS10(
    int,	c,
    char *,	user_input_buffer,
    char **,	old_user_input GCC_UNUSED,
    int *,	recall GCC_UNUSED,
    BOOLEAN *,	FirstURLRecall GCC_UNUSED,
    int *,	URLNum GCC_UNUSED,
    int *,	URLTotal GCC_UNUSED,
    int *,	ch GCC_UNUSED,
    int *,	old_c,
    int,	real_c)
d3401 1
a3401 1
		ret = HTParse((ret+3), startfile, PARSE_ALL);
d3427 4
a3430 5
PRIVATE void handle_LYK_KEYMAP ARGS4(
    BOOLEAN *,	vi_keys_flag,
    BOOLEAN *,	emacs_keys_flag,
    int *,	old_c,
    int,	real_c)
d3442 2
a3443 2
	 *  If vi_keys changed, the keymap did too,
	 *  so force no cache, and reset the flag. - FM
d3453 2
a3454 2
	 *  Remember whether we are in dired menu
	 *  so we can display the right keymap.
d3464 1
a3464 1
PRIVATE void handle_LYK_LAST_LINK NOARGS
d3470 1
a3470 1
	 || links[i].ly != links[curdoc.link].ly) {
d3477 1
a3477 1
PRIVATE void handle_LYK_LEFT_LINK NOARGS
d3479 3
a3481 3
    if (curdoc.link>0 &&
		links[curdoc.link].ly == links[curdoc.link-1].ly) {
	set_curdoc_link(curdoc.link-1);
d3485 1
a3485 2
PRIVATE BOOLEAN handle_LYK_LIST ARGS1(
    int *,     cmd)
d3488 1
a3488 1
     *	Don't do if already viewing list page.
d3493 1
a3493 1
	 *  Already viewing list page, so get out.
d3500 1
a3500 1
     *	Print list page to file.
d3506 3
a3508 4
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
d3518 2
a3519 3
PRIVATE void handle_LYK_MAIN_MENU ARGS2(
    int *,	old_c,
    int,	real_c)
d3522 1
a3522 1
     *	If its already the homepage then don't reload it.
d3524 1
a3524 1
    if (!STREQ(curdoc.address,homepage)) {
d3549 1
a3549 1
PRIVATE void handle_LYK_MINIMAL NOARGS
d3553 1
a3553 1
    if (!HTcan_reparse_document()) {
d3555 14
a3568 15
	/*
	 *  Check if this is a reply from a POST, and if so,
	 *  seek confirmation of reload if the safe element
	 *  is not set. - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
d3570 1
a3570 1
    } /* end if no bypass */
d3582 1
a3582 1
    (void)reparse_document();
d3588 1
a3588 2
PRIVATE void handle_LYK_MODIFY ARGS1(
    BOOLEAN *,	refresh_screen)
d3594 1
a3594 1
	if (ret == PERMIT_FORM_RESULT) { /* Permit form thrown up */
d3613 1
a3613 2
PRIVATE BOOLEAN handle_LYK_NESTED_TABLES ARGS1(
    int *,	cmd)
d3621 2
a3622 3
PRIVATE BOOLEAN handle_LYK_OPTIONS ARGS2(
    int *,	cmd,
    BOOLEAN *,	refresh_screen)
d3638 4
a3641 6
	StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : ""));
	StrAllocCopy(CurrentNegoLanguage, (language ?
					   language : ""));
	StrAllocCopy(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""));
d3658 3
a3660 6
	    ((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
	      strcmp(CurrentNegoLanguage, (language ?
					   language : "")) ||
	      strcmp(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""))) &&
d3667 2
a3668 3
	     *  Check if this is a reply from a POST, and if so,
	     *  seek confirmation of reload if the safe element
	     *  is not set. - FM
d3680 1
a3680 2
		if (((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
d3686 8
a3693 9
		     *  An option has changed which may influence
		     *  content negotiation, and the resource is from
		     *  a http or https or lynxcgi URL (the only protocols
		     *  which currently do anything with this information).
		     *  Set reloading = TRUE so that proxy caches will be
		     *  flushed, which is necessary until the time when
		     *  all proxies understand HTTP 1.1 Vary: and all
		     *  Servers properly use it...	Treat like
		     *  case LYK_RELOAD (see comments there). - KW
d3733 1
a3733 1
		free_address(&curdoc); /* So it doesn't get pushed. */
d3739 1
a3739 1
	*refresh_screen = TRUE; /* to repaint screen */
d3741 1
a3741 1
    } /* end if !LYUseFormsOptions */
d3757 1
a3757 1
     *	Don't do if already viewing options page.
d3761 1
a3761 1
	set_address(&newdoc, "LYNXOPTIONS:/");
d3774 1
a3774 1
   } else {
d3776 1
a3776 1
	 *  If already in the options menu, get out.
d3785 1
a3785 1
PRIVATE void handle_NEXT_DOC NOARGS
d3794 3
a3796 4
PRIVATE void handle_LYK_NEXT_LINK ARGS3(
    int,	c,
    int *,	old_c,
    int,	real_c)
d3798 1
a3798 1
    if (curdoc.link < nlinks-1) {	/* next link */
d3802 1
a3802 1
	 *  Move to different textarea if TAB in textarea.
d3804 1
a3804 1
	if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
d3806 1
a3806 1
	    c=='\t') {
d3810 3
a3812 2
	    do curdoc.link++;
	    while ((curdoc.link < nlinks-1) &&
d3823 5
a3827 5
    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
d3830 1
a3830 1
    } else if (more) {	/* next page */
d3839 2
a3840 3
PRIVATE void handle_LYK_NEXT_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
d3844 1
a3844 1
    } else if (curdoc.link < nlinks-1) {
d3852 2
a3853 3
PRIVATE BOOLEAN handle_LYK_NOCACHE ARGS2(
    int *,	old_c,
    int,	real_c)
d3873 3
a3875 4
PRIVATE void handle_LYK_PREV_LINK ARGS3(
    int *,	arrowup,
    int	*,	old_c,
    int,	real_c)
d3877 1
a3877 1
    if (curdoc.link > 0) {	     /* previous link */
d3881 1
a3881 1
	       curdoc.link==0 && Newline==1) { /* at the top of list */
d3883 2
a3884 3
	 *  If there is only one page of data and the user
	 *  goes off the top, just move the cursor to last link on
	 *  the page.
d3890 1
a3890 1
	 *  Go back to the previous page.
d3893 2
a3894 1
				      display_lines : Newline - 1);
d3899 3
a3901 3
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
d3912 15
a3926 15
PRIVATE int handle_PREV_DOC ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
    if (nhist > 0) {  /* if there is anything to go back to */
	/*
	 *  Check if the previous document is a reply from a POST,
	 *  and if so, seek confirmation of resubmission if the safe
	 *  element is not set and the document is not still in the
	 *  cache or LYresubmit_posts is set.  If not confirmed and
	 *  it is not the startfile, pop it so we go to the yet
	 *  previous document, until we're OK or reach the startfile.
	 *  If we reach the startfile and its not OK or we don't get
	 *  confirmation, cancel. - FM
d3933 1
a3933 1
	HTLastConfirmCancelled(); /* reset flag */
d3936 1
a3936 1
	    if (HDOC(nhist - 1).post_data == NULL) {
d3939 2
a3940 2
	    WWWDoc.address = HDOC(nhist - 1).address;
	    WWWDoc.post_data = HDOC(nhist - 1).post_data;
d3942 4
a3945 4
			       HDOC(nhist - 1).post_content_type;
	    WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
	    WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
	    WWWDoc.safe = HDOC(nhist - 1).safe;
d3950 1
a3950 1
	    if (((text = (HText *)HTAnchor_document(tmpanchor)) == NULL &&
d3952 3
a3954 3
		 (conf = confirm_post_resub(WWWDoc.address,
					    HDOC(nhist - 1).title,
					    0, 0))
d3957 4
a3960 6
		  (NONINTERNAL_OR_PHYS_DIFFERENT(
		      (DocInfo *)&history[(nhist - 1)],
		      &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT(
		       (DocInfo *)&history[(nhist - 1)],
		       &newdoc))) &&
d3962 1
a3962 1
				     HDOC(nhist - 1).title,
d3979 4
a3982 4
		    } while (nhist > 1 && !are_different(
			(DocInfo *)&history[(nhist - 1)],
			&curdoc));
		    first = FALSE; /* have popped at least one */
d3987 3
a3989 4
		 *  Break from loop; if user just confirmed to
		 *  load again because document wasn't in cache,
		 *  set LYforce_no_cache to avoid unnecessary
		 *  repeat question down the road. - kw
d4001 1
a4001 1
	 *  Set newdoc.address to empty to pop a file.
d4011 1
a4011 1
	return(1); /* exit on left arrow in main screen */
d4020 2
a4021 3
PRIVATE void handle_LYK_PREV_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
d4033 3
a4035 4
PRIVATE void handle_LYK_PRINT ARGS3(
    BOOLEAN *,	ForcePush,
    int *,	old_c,
    int,	real_c)
d4038 1
a4038 1
	if (*old_c != real_c)	{
d4046 1
a4046 1
     *	Don't do if already viewing print options page.
d4049 2
a4050 2
     && print_options(&newdoc.address,
		      curdoc.address, HText_getNumOfLines()) >= 0) {
d4057 1
a4057 1
	*ForcePush = TRUE;  /* see LYpush() and print_options() */
d4063 1
a4063 1
PRIVATE BOOLEAN handle_LYK_QUIT NOARGS
d4074 1
a4074 1
	    return(TRUE);
d4079 1
a4079 1
	return(TRUE);
d4086 1
a4086 2
PRIVATE BOOLEAN handle_LYK_RAW_TOGGLE ARGS1(
    int *,	cmd)
d4099 1
a4099 2
PRIVATE void handle_LYK_RELOAD ARGS1(
    int,	real_cmd)
d4113 1
a4113 1
     *	Check to see if should reload source, or load html
d4126 1
a4126 1
     *	Don't assume the reloaded document will be the same. - FM
d4132 4
a4135 4
     *	Do assume the reloaded document will be the same. - FM
     *	(I don't remember all the reasons why we couldn't assume
     *	 this.	As the problems show up, we'll try to fix them,
     *	 or add warnings.  - FM)
d4140 1
a4140 1
    free_address(&curdoc); /* so it doesn't get pushed */
d4145 2
a4146 2
     *	Reload should force a cache refresh on a proxy.
     *	      -- Ari L. <luotonen@@dxcern.cern.ch>
d4148 3
a4150 3
     *	-- but only if this was really a reload requested by
     *	the user, not if we jumped here to handle reloading for
     *	INLINE_TOGGLE, IMAGE_TOGGLE, RAW_TOGGLE, etc. - KW
d4159 1
a4159 2
PRIVATE void handle_LYK_REMOVE ARGS1(
    BOOLEAN *,	refresh_screen)
d4162 2
a4163 1
	int linkno = curdoc.link; /* may be changed in local_remove - kw */
d4173 1
a4173 1
PRIVATE void handle_LYK_RIGHT_LINK NOARGS
d4175 2
a4176 2
    if (curdoc.link<nlinks-1 &&
		links[curdoc.link].ly == links[curdoc.link+1].ly) {
d4181 3
a4183 4
PRIVATE void handle_LYK_SHELL ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d4194 7
a4200 1
	LYSystem(LYSysShell());
d4204 1
a4204 1
	if (*old_c != real_c)	{
d4211 1
a4211 1
PRIVATE void handle_LYK_SOFT_DQUOTES NOARGS
d4216 14
a4229 15
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HText_setNoCache(HTMainText);
	move_address(&newdoc, &curdoc);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
d4231 1
a4231 1
    } /* end if no bypass */
d4237 1
a4237 1
    (void)reparse_document();
d4242 1
a4242 2
PRIVATE void handle_LYK_SOURCE ARGS1(
    char **,	ownerS_address_p)
d4284 1
a4284 1
	FREE(*ownerS_address_p);  /* not used with source_cache */
d4286 1
a4286 1
	HTMLSetCharacterHandling(current_char_set);  /* restore now */
d4298 1
a4298 1
    free_address(&curdoc); /* so it doesn't get pushed */
d4302 1
a4302 1
PRIVATE void handle_LYK_SWITCH_DTD NOARGS
d4306 1
d4320 3
a4322 3
	     *  If currently viewing preparsed source, switching
	     *  to the other DTD parsing may show source differences,
	     *  so stay in source view - kw
d4329 1
a4329 1
	    */
d4344 1
a4344 1
    } /* end if no bypass */
d4363 1
a4363 1
PRIVATE void handle_LYK_TAG_LINK NOARGS
d4367 1
a4367 1
	    return;	/* Never tag the parent directory */
d4375 1
a4375 1
	     *	HTList-based management of tag list, see LYLocal.c - KW
d4377 2
a4378 2
	    HTList * t1 = tagged;
	    char * tagname = NULL;
d4381 1
a4381 1
	    while ((tagname = (char *)HTList_nextObject(t1)) != NULL) {
d4386 1
a4386 1
		    tagflag(OFF,curdoc.link);
d4394 3
a4396 3
		StrAllocCopy(tagname,links[curdoc.link].lname);
		HTList_addObject(tagged,tagname);
		tagflag(ON,curdoc.link);
d4399 1
a4399 1
	if (curdoc.link < nlinks-1) {
d4401 1
a4401 1
	} else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
d4403 1
a4403 1
	} else if (more) {  /* next page */
d4410 1
a4410 1
PRIVATE void handle_LYK_TOGGLE_HELP NOARGS
d4418 4
a4421 5
PRIVATE void handle_LYK_TOOLBAR ARGS4(
    BOOLEAN *,	try_internal,
    BOOLEAN *,	force_load,
    int *,	old_c,
    int,	real_c)
d4439 1
a4439 1
	*force_load = TRUE;  /* force MainLoop to reload */
d4443 1
a4443 2
PRIVATE void handle_LYK_TRACE_LOG ARGS1(
    BOOLEAN *,	trace_flag_ptr)
d4447 1
a4447 2
     *	Check whether we've started a TRACE log
     *	in this session. - FM
d4455 1
a4455 1
     *	Don't do if already viewing the TRACE log. - FM
d4461 7
a4467 9
     *	If TRACE mode is on, turn it off during this fetch of the
     *	TRACE log, so we don't enter stuff about this fetch, and
     *	set a flag for turning it back on when we return to this
     *	loop.  Note that we'll miss any messages about memory
     *	exhaustion if it should occur.	It seems unlikely that
     *	anything else bad might happen, but if it does, we'll
     *	miss messages about that too.  We also fflush(), close,
     *	and open it again, to make sure all stderr messages thus
     *	far will be in the log. - FM
d4472 1
a4472 1
    LYLocalFileToURL (&(newdoc.address), LYTraceLogPath);
d4490 1
a4490 1
PRIVATE void handle_LYK_UPLOAD NOARGS
d4493 1
a4493 1
     *	Don't do if already viewing upload options page.
d4507 2
a4508 3
	 *  Uncache the current listing so that it will
	 *  be updated to included the uploaded file if
	 *  placed in the current directory. - FM
d4511 1
a4511 1
     }
d4515 3
a4517 4
PRIVATE void handle_LYK_UP_HALF ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
d4520 2
a4521 1
	int scrollamount = display_lines/2;
d4528 3
a4530 3
			      HText_LinksInLines(HTMainText,
						 Newline,
						 scrollamount);
d4541 4
a4544 5
PRIVATE void handle_LYK_UP_LINK ARGS4(
    int *,	follow_col,
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
d4554 2
a4555 1
	    char *text = LYGetHiliteStr(curdoc.link, 0);
d4570 1
a4570 1
    } else if (curdoc.line > 1 && Newline > 1) {  /* previous page */
d4572 2
a4573 1
				      display_lines : Newline - 1);
d4577 4
a4580 4
	    links[0].ly -1 + scrollamount <= display_lines) {
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
d4591 3
a4593 4
PRIVATE void handle_LYK_UP_TWO ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
d4597 1
d4602 2
a4603 2
			      HText_LinksInLines(HTMainText,
						 Newline, scrollamount);
d4614 3
a4616 4
PRIVATE void handle_LYK_VIEW_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d4618 1
a4618 1
    char *cp;
d4621 1
a4621 1
	if (*old_c != real_c)	{
d4629 2
a4630 2
     *	See if a bookmark exists.
     *	If it does replace newdoc.address with its name.
d4644 1
a4644 1
	LYforce_no_cache = TRUE;  /*force the document to be reloaded*/
d4663 2
a4664 3
PRIVATE BOOLEAN handle_LYK_VLINKS ARGS2(
    int *,	cmd,
    BOOLEAN *,	newdoc_link_is_absolute)
d4670 1
a4670 1
	 *  Already viewing visited links page, so get out.
d4677 1
a4677 1
     *	Print visited links page to file.
d4702 2
a4703 3
PUBLIC void handle_LYK_WHEREIS ARGS2(
    int,	cmd,
    BOOLEAN *,	refresh_screen)
d4706 1
a4706 1
				    HText_pageHasPrevTarget());
d4708 1
a4708 1
    int oldcur = curdoc.link; /* temporarily remember */
d4710 1
d4718 2
a4719 4
	 *  Reset prev_target to force prompting
	 *  for a new search string and to turn
	 *  off highlighting if no search string
	 *  is entered by the user.
d4723 1
a4723 1
    found = textsearch(&curdoc, prev_target, sizeof(prev_target)-1,
d4727 2
a4728 2
			 ? 1
			 : -1));
d4731 3
a4733 4
     *	Force a redraw to ensure highlighting of hits
     *	even when found on the same page, or clearing
     *	of highlighting if the default search string
     *	was erased without replacement. - FM
d4736 3
a4738 3
    ** Well let's try to avoid it at least in a few cases
    ** where it is not needed. - kw
    */
d4740 1
a4740 1
	*refresh_screen = TRUE; /* doesn't really matter */
d4748 1
a4748 1
	       links[curdoc.link].ly >= (display_lines/3)) {
d4750 4
a4753 4
    } else if ((case_sensitive && 0!=strcmp(prev_target,
					    remember_old_target)) ||
	     (!case_sensitive && 0!=strcasecomp8(prev_target,
					    remember_old_target))) {
d4762 6
a4767 7
PRIVATE void handle_LYK_digit ARGS6(
    int,	c,
    BOOLEAN *,	force_load,
    char *,	user_input_buffer,
    int *,	old_c,
    int,	real_c,
    BOOLEAN *,	try_internal GCC_UNUSED)
d4780 1
a4780 1
	 *  Follow a normal link.
d4786 4
a4789 5
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
d4800 1
a4800 1
		    HTLastConfirmCancelled(); /* reset flag */
d4803 4
a4806 2
					    (LYresubmit_posts &&
					     HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
d4839 2
a4840 2
		 *  Don't push the List Page if we follow an
		 *  internal link given by it. - kw
d4851 1
a4851 1
	     *	Free POST content if not an internal link. - kw
d4857 2
a4858 2
	 *  Might be an anchor in the same doc from a POST
	 *  form.  If so, don't free the content. -- FM
d4869 1
a4869 1
	*force_load = TRUE;  /* force MainLoop to reload */
d4874 1
a4874 1
	 *  Position on a normal link, don't follow it. - KW
d4880 1
a4880 1
	     *	It's a link in the current page. - FM
d4885 3
a4887 4
		     *	It's the current link, and presumably
		     *	reflects a typo in the statusline entry,
		     *	so issue a statusline message for the
		     *	typo-prone users (like me 8-). - FM
d4897 1
a4897 1
		     *	It's a different link on this page,
d4904 1
a4904 1
	break;		/* nothing more to do */
d4908 1
a4908 1
	 *  Position on a page in this document. - FM
d4914 2
a4915 3
	     *	It's the current page, so issue a
	     *	statusline message for the typo-prone
	     *	users (like me 8-). - FM
d4943 1
a4943 1
PUBLIC void handle_LYK_CHDIR NOARGS
d4957 1
a4957 1
    if (LYgetstr(buf, VISIBLE, sizeof(buf)-1, 0) < 0 || !*buf) {
d4965 1
a4965 1
	HTSprintf0(&p, "%s%s", Home_Dir(), buf+1);
d4988 1
a4988 1
	/*if in dired, load content of other directory*/
d4990 1
a4990 1
	 && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
d4992 1
a4992 1
	    char* addr = NULL;
d5030 1
a5030 1
PRIVATE int repeat_to_delta ARGS1(int, n)
d5044 1
a5044 1
PRIVATE void handle_LYK_SHIFT_LEFT ARGS2(BOOLEAN *, flag, int, count)
d5058 1
a5058 1
PRIVATE void handle_LYK_SHIFT_RIGHT ARGS2(BOOLEAN *, flag, int, count)
d5068 2
a5069 3
PRIVATE BOOLEAN handle_LYK_LINEWRAP_TOGGLE ARGS2(
    int *,	cmd,
    BOOLEAN *,	flag)
d5071 2
a5072 1
    static char *choices[] = {
d5083 2
a5084 1
    static int wrap[] = {
d5087 1
a5087 1
	12,				/* In units of 1/12 */
d5101 1
a5101 1
    c = LYChoosePopup(!LYwideLines, LYlines /2 - 2, LYcols/2-6,
d5104 4
a5107 5
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
d5123 5
a5127 5
 *  Here's where we do all the work.
 *  mainloop is basically just a big switch dependent on the users input.
 *  I have tried to offload most of the work done here to procedures to
 *  make it more modular, but this procedure still does a lot of variable
 *  manipulation.  This needs some work to make it neater. - Lou Moutilli
d5131 1
a5131 1
int mainloop NOARGS
d5133 1
a5133 1
#if defined(WIN_EX)	/* 1997/10/08 (Wed) 14:52:06 */
d5141 4
a5144 1
    int c = 0, real_c = 0, old_c = 0, pending_form_c = -1;
d5149 1
a5149 1
    CONST char *cshelpfile = NULL;
d5163 2
a5164 1
    int ch, recall;
d5178 5
a5182 5
/*  "internal" means "within the same document, with certainty".
 *  It includes a space so it cannot conflict with any (valid) "TYPE"
 *  attributes on A elements. [According to which DTD, anyway??] - kw
 */
    HTInternalLink = HTAtom_for("internal link");  /* init, used as const */
d5185 1
a5185 1
    WWW_SOURCE = HTAtom_for("www/source");  /* init, used as const */
d5188 9
a5196 9
/*
 *  curdoc.address contains the name of the file that is currently open.
 *  newdoc.address contains the name of the file that will soon be
 *		     opened if it exits.
 *  prev_target    contains the last search string the user searched for.
 *  newdoc.title   contains the link name that the user last chose to get
 *		     into the current link (file).
 */
    /* initialize some variables*/
d5220 1
a5220 1
initialize:
d5257 2
d5260 2
a5261 2
	     *	See if a bookmark page exists.	If it does,
	     *	replace newdoc.address with its name
d5263 2
a5264 2
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL &&
		 *cp != '\0' && strcmp(cp, " ")) {
d5284 1
a5284 1
	display_lines = LYlines-4;
d5286 1
a5286 1
	display_lines = LYlines-2;
d5290 2
a5291 1
	if (curdoc.style != NULL) force_load = TRUE;
d5294 2
a5295 2
	 *  If newdoc.address is different then curdoc.address then
	 *  we need to go out and find and load newdoc.address.
d5300 3
a5302 3
		force_load = FALSE;  /* done */
		if (TRACE && LYCursesON) {
		    LYHideCursor();	/* make sure cursor is down */
d5304 1
a5304 1
		    LYaddstr("\n");
d5306 17
a5322 1
		    LYrefresh();
d5324 1
a5324 1
try_again:
d5326 2
a5327 2
		 *  Push the old file onto the history stack if we
		 *  have a current doc and a new address. - FM
d5329 2
a5330 22
		if (curdoc.address && newdoc.address) {
		    /*
		     *	Don't actually push if this is a LYNXDOWNLOAD
		     *	URL, because that returns NORMAL even if it
		     *	fails due to a spoof attempt or file access
		     *	problem, and we set the newdoc structure
		     *	elements to the curdoc structure elements
		     *	under case NORMAL.  - FM
		     */
		    if (!isLYNXDOWNLOAD(newdoc.address))
		    {
			LYpush(&curdoc, ForcePush);
		    }
		} else if (!newdoc.address) {
		    /*
		     *	If newdoc.address is empty then pop a file
		     *	and load it.  - FM
		     */
		    LYhist_prev(&newdoc);
		    popped_doc = TRUE;


d5333 15
d5349 15
a5363 8
		    ** If curdoc had been reached via an internal
		    ** (fragment) link from what we now have just
		    ** popped into newdoc, then override non-caching in
		    ** all cases. - kw
		    */
		    if (curdoc.internal_link &&
			!are_phys_different(&curdoc, &newdoc)) {
			LYinternal_flag = TRUE;
a5364 24
			LYforce_no_cache = FALSE;
			try_internal = TRUE;
		    } else
#endif /* TRACK_INTERNAL_LINKS */
		    {
			/*
			 * Force a no_cache override unless
			 *  it's a bookmark file, or it has POST content
			 *  and LYresubmit_posts is set without safe also
			 *  set, and we are not going to another position
			 *  in the current document or restoring the previous
			 *  document due to a NOT_FOUND or NULLFILE return
			 *  value from getfile(). - FM
			 */
			if ((newdoc.bookmark != NULL) ||
			    (newdoc.post_data != NULL &&
			     !newdoc.safe &&
			     LYresubmit_posts &&
			     !override_LYresubmit_posts &&
				NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			    LYoverride_no_cache = FALSE;
			} else {
			    LYoverride_no_cache = TRUE;
			}
d5367 2
a5368 1
		override_LYresubmit_posts = FALSE;
d5370 12
a5381 6
		if (HEAD_request) {
		    /*
		     *	Make SURE this is an appropriate request. - FM
		     */
		    if (newdoc.address) {
			if (LYCanDoHEAD(newdoc.address) == TRUE) {
d5383 1
a5383 8
			} else if (isLYNXIMGMAP(newdoc.address)) {
			    if (LYCanDoHEAD(newdoc.address + LEN_LYNXIMGMAP) == TRUE) {
				StrAllocCopy(temp, newdoc.address + LEN_LYNXIMGMAP);
				free_address(&newdoc);
				newdoc.address = temp;
				newdoc.isHEAD = TRUE;
				temp = NULL;
			    }
a5385 2
		    try_internal = FALSE;
		    HEAD_request = FALSE;
d5387 3
d5391 25
a5415 26
		/*
		 *  If we're getting the TRACE log and it's not new,
		 *  check whether its HText structure has been dumped,
		 *  and if so, fflush() and fclose() it to ensure it's
		 *  fully updated, and then fopen() it again. - FM
		 */
		if (LYUseTraceLog == TRUE &&
		    trace_mode_flag == FALSE &&
		    LYTraceLogFP != NULL &&
		    LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
		    DocAddress WWWDoc;
		    HTParentAnchor *tmpanchor;

		    WWWDoc.address = newdoc.address;
		    WWWDoc.post_data = newdoc.post_data;
		    WWWDoc.post_content_type = newdoc.post_content_type;
		    WWWDoc.bookmark = newdoc.bookmark;
		    WWWDoc.isHEAD = newdoc.isHEAD;
		    WWWDoc.safe = newdoc.safe;
		    tmpanchor = HTAnchor_findAddress(&WWWDoc);
		    if ((HText *)HTAnchor_document(tmpanchor) == NULL) {
			if (!LYReopenTracelog(&trace_mode_flag)) {
			    old_c = 0;
			    cmd = LYK_PREV_DOC;
			    goto new_cmd;
			}
d5418 1
d5420 10
a5429 10
		LYRequestTitle = newdoc.title;
		if (newdoc.bookmark)
		    LYforce_HTML_mode = TRUE;
		if (LYValidate &&
		    startfile_ok &&
		    newdoc.address && startfile && homepage &&
		    (!strcmp(newdoc.address, startfile) ||
		     !strcmp(newdoc.address, homepage))) {
		    LYPermitURL = TRUE;
		}
d5431 6
a5436 6
		/* reset these two variables here before getfile()
		 * so they will be available in partial mode
		 * (was previously implemented in case NORMAL).
		 */
		*prev_target = '\0';	/* Reset for new coming document */
		Newline = newdoc.line;	/* set for LYGetNewline() */
d5439 1
a5439 1
		psrc_first_tag = TRUE;
d5442 1
a5442 1
		textfields_need_activation = textfields_activation_option;
d5444 10
a5453 10
		FREE(LYRequestReferer);
		/*
		 *  Don't send Referer if we have to load a document again
		 *  that we got from the history stack.  We don't know
		 *  any more how we originally got to that page.  Using
		 *  a Referer based on the current HTMainText could only
		 *  be right by coincidence. - kw 1999-11-01
		 */
		if (popped_doc)
		    LYNoRefererForThis = TRUE;
d5456 26
a5481 7
		if (try_internal) {
		    if (newdoc.address &&
			isLYNXIMGMAP(newdoc.address)) {
			try_internal = FALSE;
		    } else if (curdoc.address &&
			isLYNXIMGMAP(curdoc.address)) {
			try_internal = FALSE;
d5484 15
a5498 34
		if (try_internal) {
		    char *hashp = findPoundSelector(newdoc.address);
		    if (hashp) {
			HTFindPoundSelector(hashp+1);
		    }
		    getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		    try_internal = FALSE; /* done */
		    /* fix up newdoc.address which may have been fragment-only */
		    if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
			if (!hashp) {
			    set_address(&newdoc, HTLoadedDocumentURL());
			} else {
			    StrAllocCopy(temp, HTLoadedDocumentURL());
			    StrAllocCat(temp, hashp); /* append fragment */
			    set_address(&newdoc, temp);
			    FREE(temp);
			}
		    }
		} else {
		    if (newdoc.internal_link && newdoc.address &&
			*newdoc.address == '#' && nhist > 0) {
			char *cp0;
			if (isLYNXIMGMAP(HDOC(nhist-1).address))
			    cp0 = HDOC(nhist-1).address + LEN_LYNXIMGMAP;
			else
			    cp0 = HDOC(nhist-1).address;
			StrAllocCopy(temp, cp0);
			(void) trimPoundSelector(temp);
			StrAllocCat(temp, newdoc.address);
			free_address(&newdoc);
			newdoc.address = temp;
			temp = NULL;
		    }
		    getresult = getfile(&newdoc);
d5500 4
a5503 2
#else  /* TRACK_INTERNAL_LINKS */
		getresult = getfile(&newdoc);
d5507 1
a5507 1
		textinput_redrawn = FALSE; /* for sure */
d5510 1
a5510 1
		switch(getresult) {
d5512 9
a5520 1
		case NOT_FOUND:
d5522 5
a5526 2
		     *	OK! can't find the file, so it must not be around now.
		     *	Do any error logging, if appropriate.
d5528 11
a5538 4
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    if (!first_file && !LYCancelledFetch) {
d5540 3
a5542 7
			 *  Do error mail sending and/or traversal
			 *  stuff.  Note that the links[] elements may
			 *  not be valid at this point, if we did call
			 *  HTuncache_current_document!   This should
			 *  not have happened for traversal, but for
			 *  sending error mail check that HTMainText
			 *  exists for this reason. - kw
a5543 16
			if (error_logging && nhist > 0 && !popped_doc &&
			    !LYUserSpecifiedURL &&
			    HTMainText &&
			    nlinks > 0 && curdoc.link < nlinks &&
			    !isLYNXHIST(NonNull(newdoc.address)) &&
			    !isLYNXCOOKIE(NonNull(newdoc.address))) {
			    char *mail_owner = NULL;
			    if (owner_address && isMAILTO_URL(owner_address)) {
				mail_owner = owner_address + LEN_MAILTO_URL;
			    }
			    /*
			     *  Email a bad link message to the owner of
			     *  the document, or to ALERTMAIL if defined,
			     *  but NOT to lynx-dev (it is rejected in
			     *  mailmsg). - FM, kw
			     */
d5545 1
a5545 1
			    if (mail_owner)
d5547 7
a5553 7
				mailmsg(curdoc.link,
					mail_owner,
					HDOC(nhist-1).address,
					HDOC(nhist-1).title);
			}
			if (traversal) {
			    FILE *ofp;
d5555 4
a5558 5
			    if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
				if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				    perror(NOOPEN_TRAV_ERR_FILE);
				    exit_immediately(EXIT_FAILURE);
				}
a5559 15
			    if (nhist > 0) {
				fprintf(ofp,
					"%s %s\tin %s\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target,
					HDOC(nhist-1).address);
			    } else {
				fprintf(ofp,
					"%s %s\t\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target);
			    }
			    LYCloseOutput(ofp);
d5561 15
d5577 1
d5579 5
d5585 1
a5585 3
		     *	Fall through to do the NULL stuff and reload the
		     *	old file, unless the first file wasn't found or
		     *	has gone missing.
d5587 25
a5611 1
		    if (!nhist) {
d5613 3
a5615 1
			 *  If nhist = 0 then it must be the first file.
d5617 2
a5618 34
			exit_immediately_with_error_message(NOT_FOUND, first_file);
			return(EXIT_FAILURE);
		    }
		    /* FALLTHRU */

		case NULLFILE:
		    /*
		     *	Not supposed to return any file.
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    free_address(&newdoc); /* to pop last doc */
		    FREE(newdoc.bookmark);
		    LYJumpFileURL = FALSE;
		    reloading = FALSE;
		    LYPermitURL = FALSE;
		    LYCancelledFetch = FALSE;
		    ForcePush = FALSE;
		    LYforce_HTML_mode = FALSE;
		    force_old_UCLYhndl_on_reload = FALSE;
		    if (traversal) {
			crawl_ok = FALSE;
			if (traversal_link_to_add) {
			    /*
			     *	It's a binary file, or the fetch attempt
			     *	failed.  Add it to TRAVERSE_REJECT_FILE
			     *	so we don't try again in this run.
			     */
			    if (!lookup_reject(traversal_link_to_add)) {
				add_to_reject_list(traversal_link_to_add);
			    }
			    FREE(traversal_link_to_add);
d5620 1
d5622 5
d5628 1
a5628 2
		     *  Make sure the first file was found and
		     *  has not gone missing.
d5630 2
a5631 1
		    if (!nhist) {
d5633 8
a5640 1
			 *  If nhist = 0 then it must be the first file.
d5642 49
a5690 20
			if (first_file && homepage &&
			   !LYSameFilename(homepage, startfile)) {
			   /*
			    *  Couldn't return to the first file but there is a
			    *  homepage we can use instead. Useful for when the
			    *  first URL causes a program to be invoked. - GL
			    *
			    *  But first make sure homepage is different from
			    *  startfile (above), then make it the same (below)
			    *  so we don't enter an infinite getfile() loop on
			    *  on failures to find the files. - FM
			    */
			   set_address(&newdoc, homepage);
			   LYFreePostData(&newdoc);
			   FREE(newdoc.bookmark);
			   StrAllocCopy(startfile, homepage);
			   newdoc.isHEAD = FALSE;
			   newdoc.safe = FALSE;
			   newdoc.internal_link = FALSE;
			   goto try_again;
d5692 1
a5692 2
			   exit_immediately_with_error_message(NULLFILE, first_file);
			   return(EXIT_FAILURE);
d5694 14
d5709 5
d5715 7
a5721 59
		   /*
		    *  If we're going to pop from history because
		    *  getfile didn't succeed, reset LYforce_no_cache
		    *  first.  This would have been done in HTAccess.c
		    *  if the request got that far, but the URL may
		    *  have been handled or rejected in getfile without
		    *  taking care of that. - kw
		    */
		    LYforce_no_cache = FALSE;
		   /*
		    *  Retrieval of a newdoc just failed, and just
		    *  going to try_again would pop the next doc
		    *  from history and try to get it without further
		    *  questions.  This may not be the right thing to do if
		    *  we have POST data, so fake a PREV_DOC key if it seems
		    *  that some prompting should be done.  This doesn't
		    *  affect the traversal logic, since with traversal
		    *  POST data can never occur. - kw
		    */
		   if (HDOC(nhist - 1).post_data &&
		       !HDOC(nhist - 1).safe) {
		       if (HText_POSTReplyLoaded((DocInfo *)&history[(nhist - 1)])) {
			   override_LYresubmit_posts = TRUE;
			   goto try_again;
		       }
		       /*  Set newdoc fields, just in case the PREV_DOC
			*  gets cancelled. - kw */
		       if (!curdoc.address) {
			   set_address(&newdoc, HTLoadedDocumentURL());
			   StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			   if (HTMainAnchor
			    && HTMainAnchor->post_data) {
			       BStrCopy(newdoc.post_data,
					HTMainAnchor->post_data);
			       StrAllocCopy(newdoc.post_content_type,
					    HTMainAnchor->post_content_type);
			   } else {
			       BStrFree(newdoc.post_data);
			   }
			   newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			   newdoc.safe = HTLoadedDocumentIsSafe();
			   newdoc.internal_link = FALSE;
		       } else {
			   copy_address(&newdoc, &curdoc);
			   StrAllocCopy(newdoc.title, curdoc.title);
			   BStrCopy(newdoc.post_data, curdoc.post_data);
			   StrAllocCopy(newdoc.post_content_type,
					curdoc.post_content_type);
			   newdoc.isHEAD = curdoc.isHEAD;
			   newdoc.safe = curdoc.safe;
			   newdoc.internal_link = curdoc.internal_link;
			   newdoc.line = curdoc.line;
			   newdoc.link = curdoc.link;
		       }
		       cmd = LYK_PREV_DOC;
		       goto new_cmd;
		    }
		    override_LYresubmit_posts = TRUE;
		    goto try_again;
d5723 14
a5736 7
		case NORMAL:
		    /*
		     *	Marvelously, we got the document!
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
d5738 1
a5738 15
		    /*
		     *	If it's the first file and we're interactive,
		     *	check whether it's a bookmark file which was
		     *	not accessed via the -book switch. - FM
		     */
		    if (((first_file == TRUE) &&
			 (dump_output_immediately == FALSE) &&
			 !(newdoc.bookmark && *newdoc.bookmark)) &&
			((LYisLocalFile(newdoc.address) == TRUE) &&
			 !(strcmp(NonNull(HText_getTitle()),
				  BOOKMARK_TITLE))) &&
			(temp = HTParse(newdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION)) != NULL) {
			CONST char *name = wwwName(Home_Dir());
			len = strlen(name);
d5740 2
a5741 2
			if (!strncasecomp(temp, name, len) &&
			    strlen(temp) > len)
d5743 2
a5744 2
			if (!strncmp(temp, name, len) &&
			    strlen(temp) > len)
d5746 12
a5757 16
			{
			    /*
			     *	We're interactive and this might be a
			     *	bookmark file entered as a startfile
			     *	rather than invoked via -book.	Check
			     *	if it's in our bookmark file list, and
			     *	if so, reload if with the relevant
			     *	bookmark elements set. - FM
			     */
			    cp = NULL;
			    if (temp[len] == '/') {
				if (strchr(&temp[(len + 1)], '/')) {
				    HTSprintf0(&cp, ".%s", &temp[len]);
				} else {
				    StrAllocCopy(cp, &temp[(len + 1)]);
				}
d5759 11
a5769 1
				StrAllocCopy(cp, &temp[len]);
d5771 7
a5777 7
			    for (i = 0; i <= MBM_V_MAXFILES; i++) {
				if (MBM_A_subbookmark[i] &&
				    LYSameFilename(cp, MBM_A_subbookmark[i])) {
				    StrAllocCopy(BookmarkPage,
						 MBM_A_subbookmark[i]);
				    break;
				}
d5779 6
a5784 13
			    FREE(cp);
			    if (i <= MBM_V_MAXFILES) {
				FREE(temp);
				if (LYValidate) {
				    HTAlert(BOOKMARKS_DISABLED);
				    return(EXIT_FAILURE);
				}
				if ((temp = HTParse(newdoc.address, "",
				 PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION))) {
				    set_address(&newdoc, temp);
				    HTuncache_current_document();
				    free_address(&curdoc);
				    StrAllocCat(newdoc.address,
d5786 7
a5792 7
				    StrAllocCat(newdoc.address, "/");
				    StrAllocCat(newdoc.address,
					(strncmp(BookmarkPage, "./", 2) ?
							   BookmarkPage :
							(BookmarkPage + 2)));
				    StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				    StrAllocCopy(newdoc.bookmark, BookmarkPage);
d5794 2
a5795 2
				    if (curdoc.style)
					StrAllocCopy(newdoc.style, curdoc.style);
d5797 11
a5807 12
				    StrAllocCopy(startrealm, newdoc.address);
				    LYFreePostData(&newdoc);
				    newdoc.isHEAD = FALSE;
				    newdoc.safe = FALSE;
				    FREE(temp);
				    if (!strcmp(homepage, startfile))
					StrAllocCopy(homepage, newdoc.address);
				    StrAllocCopy(startfile, newdoc.address);
				    CTRACE((tfp, "Reloading as bookmarks=%s\n",
						newdoc.address));
				    goto try_again;
				}
a5809 1
			cp = NULL;
d5811 3
a5813 1
		    FREE(temp);
d5815 7
a5821 1
		    if (traversal) {
d5823 1
a5823 3
			 *  During traversal build up lists of all links
			 *  traversed.	Traversal mode is a special
			 *  feature for traversing http links in the web.
d5825 3
a5827 14
			if (traversal_link_to_add) {
			    /*
			     *	Add the address we sought to TRAVERSE_FILE.
			     */
			    if (!lookup(traversal_link_to_add))
				add_to_table(traversal_link_to_add);
			    FREE(traversal_link_to_add);
			}
			if (curdoc.address && curdoc.title &&
			    !isLYNXIMGMAP(curdoc.address))
			    /*
			     *	Add the address we got to TRAVERSE_FOUND_FILE.
			     */
			    add_to_traverse_list(curdoc.address, curdoc.title);
d5829 7
d5837 14
a5850 15
		    /*
		     *	If this was a LYNXDOWNLOAD, we still have curdoc,
		     *	not a newdoc, so reset the address, title and
		     *	positioning elements. - FM
		     */
		    if (newdoc.address && curdoc.address &&
			isLYNXDOWNLOAD(newdoc.address)) {
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, (curdoc.title ?
						    curdoc.title : ""));
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
			newdoc.internal_link = FALSE; /* can't be true. - kw */
		    }
d5852 14
a5865 14
		    /*
		     *	Set Newline to the saved line.	It contains the
		     *	line the user was on if s/he has been in the file
		     *	before, or it is 1 if this is a new file.
		     *
		     * We already set Newline before getfile() and probably
		     * update it explicitly if popping from the history stack
		     * via LYpop() or LYpop_num() within getfile() cycle.
		     *
		     * In partial mode, Newline was probably updated in
		     * LYMainLoop_pageDisplay() if user scrolled
		     * the document while loading.
		     * Incremental loading stage already closed in HT*Copy().
		     */
d5867 2
a5868 2
		    /* Newline = newdoc.line; */
		    display_partial = FALSE; /* for sure, LYNXfoo:/ may be a problem */
d5870 5
a5874 5
		    /* Should not be needed either if we remove
		     * "DISP_PARTIAL" from LYHistory.c, but lets leave it
		     * as an important comment for now.
		     */
		    Newline = newdoc.line;
d5877 6
a5882 7
		    /*
		     *	If we are going to a target line or
		     *	the first page of a popped document,
		     *	override any www_search line result.
		     */
		    if (Newline > 1 || popped_doc == TRUE)
			 www_search_result = -1;
d5884 7
a5890 7
		    /*
		     *	Make sure curdoc.line will not be equal
		     *	to Newline, so we get a redraw.
		     */
		    curdoc.line = -1;
		    break;
		}  /* end switch */
d5894 1
a5894 1
		    LYSleepAlert(); /* allow me to look at the results */
d5899 1
a5899 1
	     *	Set the files the same.
d5908 1
a5908 1
		style_readFromFile (curdoc.style);
d5914 2
a5915 2
	     *	Set the remaining document elements and add to
	     *	the visited links list. - FM
d5921 2
a5922 2
		if ( (LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
			&& !HText_getOwner() )
d5938 5
a5942 6

	   /*
	    *  Reset WWW present mode so that if we were getting
	    *  the source, we get rendered HTML from now on.
	    */
	   HTOutputFormat = WWW_PRESENT;
d5944 1
a5944 1
	   psrc_view = FALSE;
d5947 1
a5947 1
	   HTMLSetCharacterHandling(current_char_set);	/* restore, for sure? */
d5949 14
a5962 16
	   /*
	    *  Reset all of the other relevant flags. - FM
	    */
	   LYUserSpecifiedURL = FALSE;	/* only set for goto's and jumps's */
	   LYJumpFileURL = FALSE;	/* only set for jump's */
	   LYNoRefererForThis = FALSE;	/* always reset on return here */
	   reloading = FALSE;		/* set for RELOAD and NOCACHE keys */
	   HEAD_request = FALSE;	/* only set for HEAD requests */
	   LYPermitURL = FALSE;		/* only for LYValidate or check_realm */
	   ForcePush = FALSE;		/* only set for some PRINT requests. */
	   LYforce_HTML_mode = FALSE;
	   force_old_UCLYhndl_on_reload = FALSE;
	   popped_doc = FALSE;
	   pending_form_c = -1;

	} /* end if (LYforce_no_cache || force_load || are_different(...)) */
d5964 2
d5969 2
a5970 2
	    } else {
		print_wwwfile_to_fd(stdout, FALSE);
d5972 1
a5972 1
	    return(EXIT_SUCCESS);
d5976 2
a5977 2
	 *  If the recent_sizechange variable is set to TRUE
	 *  then the window size changed recently.
d5981 13
a5993 12
	     *  First we need to make sure the display library - curses, slang,
	     *  whatever - gets notified about the change, and gets a chance
	     *  to update external structures appropriately.  Hopefully the
	     *  stop_curses()/start_curses() sequence achieves this, at least
	     *  if the display library has a way to get the new screen size
	     *  from the OS.
	     *  However, at least for ncurses, the update of the internal
	     *  structures will come still too late - the changed screen
	     *  size is detected in doupdate(), which would only be called
	     *  (indirectly through the HText_pageDisplay below) after the
	     *  WINDOW structures are already filled based on the old size.
	     *  So we notify the ncurses library directly here. - kw
d5999 1
a5999 1
#if 0 /* defined(PDCURSES) && defined(HAVE_XCURSES) */
d6010 1
a6010 1
	    refresh_screen = TRUE; /* to force a redraw */
d6015 1
a6015 1
		display_lines = LYlines-4;
d6017 1
a6017 1
		display_lines = LYlines-2;
d6022 5
a6026 6
	     /*
	      *  This was a WWW search, set the line
	      *  to the result of the search.
	      */
	     Newline = www_search_result;
	     www_search_result = -1;  /* reset */
d6031 1
a6031 1
	     *	We can never again have the first file.
d6036 2
a6037 3
	     *	Set the startrealm, and deal as best we can
	     *	with preserving forced HTML mode for a local
	     *	startfile. - FM
d6040 1
a6040 1
			   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
d6047 1
a6047 1
				     PARSE_PATH+PARSE_PUNCTUATION))) {
d6056 10
a6065 11
			 *  We forced HTML for a local startfile which
			 *  is not a bookmark file and has a path of at
			 *  least two letters.	If it doesn't have a
			 *  suffix mapped to text/html, we'll set the
			 *  entire path (including the lead slash) as a
			 *  "suffix" mapped to text/html to ensure it is
			 *  always treated as an HTML source file.  We
			 *  are counting on a tail match to this full path
			 *  for some other URL fetched during the session
			 *  having too low a probability to worry about,
			 *  but it could happen. - FM
d6074 1
a6074 1
			*(cp+1) = '\0';
d6083 1
a6083 1
		 *  Set up the crawl output stuff.
d6085 1
a6085 1
		if (curdoc.address && !lookup(curdoc.address)) {
d6091 1
a6091 1
		 *  Set up the traversal_host comparison string.
d6100 1
a6100 1
				   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
d6113 2
a6114 3
		 *  If homepage was not equated to startfile,
		 *  make the homepage URL the first goto
		 *  entry. - FM
d6119 3
a6121 4
		 *  If we are not starting up with startfile
		 *  (e.g., had -book), or if we are using the
		 *  startfile and it has no POST content, make
		 *  the startfile URL a goto entry. - FM
a6133 1

d6143 1
a6143 1
	   if (HTcan_reparse_document()) {
d6146 1
a6146 1
	   } else {
d6151 5
a6155 5
			/*  currently disabled ***
		HTUserMsg(gettext("Reparsing document under current settings..."));
		cmd = LYK_RELOAD;
		goto new_cmd;
			*/
d6160 2
a6161 2
	    from_source_cache = FALSE; /* reset */
	    curdoc.line = -1 ;  /* so curdoc.line != Newline, see below */
d6166 3
a6168 3
	 *  If the curdoc.line is different than Newline then there must
	 *  have been a change since last update.  Run HText_pageDisplay()
	 *  create a fresh screen of text out.
d6170 2
a6171 2
	 *  If we got new HTMainText go this way.
	 *  All display_partial calls ends here for final redraw.
d6184 1
a6184 1
	      showtags(tagged);
d6188 1
a6188 1
	     *  If more equals TRUE, then there is more info below this page.
d6191 3
a6193 1
	    curdoc.line = Newline = HText_getTopOfScreen()+1;
d6197 2
a6198 2
		 *  If we don't yet have a title, try to get it,
		 *  or set to that for newdoc.title. - FM
d6208 2
a6209 2
	     *	If the request is to highlight a link which is counted
	     *  from the start of document, correct the link number:
d6220 1
a6220 2
		 *  arrowup is set if we just came up from
		 *  a page below.
d6230 6
a6235 6
		     *	We may have popped a doc (possibly in local_dired)
		     *	which didn't have any links when it was pushed, but
		     *	does have links now (e.g., a file was created).
		     *  Code below assumes that curdoc.link is valid and
		     *  that (curdoc.link==-1) only occurs if (nlinks==0)
		     *  is true. - KW
d6241 1
a6241 1
	    show_help = FALSE; /* reset */
d6244 3
a6246 1
	    curdoc.line = Newline; /* set */
d6250 1
a6250 1
	 *  Refresh the screen if necessary.
d6262 1
a6262 1
	   HText_pageDisplay(Newline, prev_target);
d6270 1
a6270 1
	     *  If more equals TRUE, then there is more info below this page.
d6275 4
a6278 6
	     *  Adjust curdoc.link as above; nlinks may have changed,
	     *  if the refresh_screen flag was set as a result of
	     *  a size change.
	     *  Code below assumes that curdoc.link is valid and
	     *  that (curdoc.link==-1) only occurs if (nlinks==0)
	     *  is true. - kw
d6287 1
a6287 1
		noviceline(more);  /* print help message */
d6306 1
a6306 1
#if defined(WIN_EX)			/* 1997/10/08 (Wed) 14:52:06 */
d6313 1
a6313 1
	       if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
d6315 1
a6315 1
		    switch(links[curdoc.link].l_form->type) {
d6346 1
a6346 1
	       }
d6364 1
a6364 1
	    if (strlen(curdoc.address) < sizeof(temp_buff)-1) {
d6376 1
a6376 1
	 *  Report unread or new mail, if appropriate.
d6382 2
a6383 3
	 *  If help is not on the screen,
	 *  then put a message on the screen
	 *  to tell the user other misc info.
d6386 3
a6388 3
	   show_main_statusline(links[curdoc.link],
				(curlink_is_editable && textinput_activated) ?
				FOR_INPUT : FOR_PANEL);
d6390 1
a6390 1
	   show_help = FALSE;
d6394 3
a6396 4
	     /*
	      *  Highlight current link, unless it is an active
	      *  text input field.
	      */
d6408 2
a6409 2
	     *	Don't go interactively into forms,
	     *	or accept keystrokes from the user
d6414 1
a6414 1
		sprintf(cfile,"lnk%05d.dat",ccount);
d6416 1
a6416 1
		sprintf(cfile,"lnk%08d.dat",ccount);
d6418 3
a6420 3
		ccount = ccount + 1;
		if ((cfp = LYNewTxtFile(cfile))  != NULL) {
		    print_crawl_to_fd(cfp,curdoc.address,curdoc.title);
d6425 1
d6427 5
a6431 4
		    if (dump_output_immediately)
			fprintf(stderr,
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    else
d6433 1
a6433 2
			printf(
			gettext("Fatal error - could not open output file %s\n"),cfile);
d6437 1
a6437 1
		    return(EXIT_FAILURE);
d6442 1
a6442 1
	     *	Normal, non-traversal handling.
a6443 1

d6451 1
a6451 1
		     *  Replace novice lines if in NOVICE_MODE.
d6453 1
a6453 1
		    if (user_mode==NOVICE_MODE) {
d6457 2
a6458 2
				     &newdoc, &refresh_screen,
				     use_last_tfpos, FALSE);
d6468 1
a6468 1
		c = (real_c==LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
d6473 1
a6473 1
		    LKC_TO_LAC(keymap,real_c) != LYK_CHANGE_LINK) {
d6487 1
a6487 1
			   (((LKC_TO_LAC(keymap,real_c) == LYK_NEXT_LINK ||
d6489 1
a6489 1
			      LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE ||
d6491 5
a6495 5
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks-1 &&
			       links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE
d6497 5
a6501 4
				   links[curdoc.link+1].l_form->number) &&
			       strcmp(links[curdoc.link].l_form->name,
				      links[curdoc.link+1].l_form->name) == 0) ||
			      (curdoc.link == nlinks-1 && more &&
d6503 3
a6505 3
			    ((LKC_TO_LAC(keymap,real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_UP_LINK) &&
d6507 2
a6508 2
			       links[curdoc.link-1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link-1].l_form->type == F_TEXTAREA_TYPE
d6510 1
a6510 1
				   links[curdoc.link-1].l_form->number) &&
d6512 3
a6514 3
				      links[curdoc.link-1].l_form->name) == 0) ||
			      (curdoc.link == 0 && curdoc.line > 1 &&
			       HText_TAHasMoreLines(curdoc.link, -1)))))) {
d6518 1
a6518 1
			LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE)
d6527 32
a6558 31
		    /*
		     *  If on the bottom line of a TEXTAREA, and the user hit
		     *  the ENTER key, we add a new line/anchor automatically,
		     *  positioning the cursor on it.
		     *
		     *  If at the bottom of the screen, we effectively perform
		     *  an LYK_DOWN_HALF-like operation, then move down to the
		     *  new line we just added.  --KED  02/14/99
		     *
		     *  [There is some redundancy and non-standard indentation
		     *   in the monster-if() below.  This is intentional ... to
		     *   try and improve the "readability" (such as it is).
		     *   Caveat emptor to anyone trying to change it.]
		     */
		    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			 links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) &&
			((curdoc.link == nlinks-1 &&
			  !(more && HText_TAHasMoreLines(curdoc.link, 1)))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  !(links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  ((links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE)
			    &&
			    ((links[curdoc.link].l_form->number	       !=
				      links[curdoc.link+1].l_form->number) ||
			     (strcmp (links[curdoc.link].l_form->name,
				      links[curdoc.link+1].l_form->name) != 0)))))) {
d6560 1
a6560 1
			HText_ExpandTextarea (&links[curdoc.link], 1);
d6562 2
a6563 2
			if (links[curdoc.link].ly < display_lines) {
			    refresh_screen = TRUE;
d6565 1
a6565 1
			} else {
d6567 3
a6569 3
			    Newline += (display_lines/2);
			    if (nlinks > 0 && curdoc.link > -1 &&
				links[curdoc.link].ly > display_lines/2) {
d6571 3
a6573 1
				    for (i = 0; links[i].ly <= (display_lines/2); i++)
d6576 1
a6577 1
			}
d6579 3
a6581 3
			if (textfields_need_activation) {
			    textinput_activated = TRUE;
			    textfields_need_activation = textfields_activation_option;
d6583 1
a6583 1
			    textinput_redrawn = TRUE;
d6585 1
a6585 1
			};
d6588 1
a6588 1
		   }
d6591 9
a6599 9
		    /*
		     *	Make return in input field (if it was returned
		     *  by change_form_link) act as LYK_NEXT_LINK,
		     *  independent of what key (if any) is mapped to
		     *  LYK_NEXT_LINK. - kw
		     */
		    c = LAC_TO_LKC0(LYK_NEXT_LINK);
		    break;
		default:
d6601 3
a6603 3
		    if (old_c != c && old_c != real_c && c != real_c)
			real_c = c;
		}
d6607 1
a6607 1
		/*draw the text entry, but don't activate it*/
d6610 2
a6611 2
				    &newdoc, &refresh_screen,
				    use_last_tfpos, FALSE, TRUE);
d6614 2
a6615 2
			     ((links[curdoc.link].lx > 0) ?
			      (links[curdoc.link].lx - 1) : 0));
d6622 2
a6623 3
		 *  Get a keystroke from the user.
		 *  Save the last keystroke to avoid
		 *  redundant error reporting.
d6625 1
a6625 1
		real_c = c = LYgetch(); /* get user input */
d6632 1
a6632 1
		if (c == 3) {		/* ^C */
d6634 2
a6635 2
		     *	This shouldn't happen.	We'll try to
		     *	deal with whatever bug caused it. - FM
d6645 8
a6652 8
		     *  If ESC + <key> was read (and not recognized as a
		     *  terminal escape sequence for another key), ignore
		     *  the ESC modifier and act on <key> only if the line
		     *  editor binding would have passed the same ESC-modified
		     *  lynxkeycode back to us if it had been pressed in a
		     *  text input field.  Otherwise set interesting part
		     *  so that it will map to 0, to prevent that ESC + <key>
		     *  acts like <key>, which might be unexpected. - kw
d6674 1
a6674 1
new_keyboard_input:
d6676 2
a6677 2
	 *  A goto point for new input without going
	 *  back through the getch() loop.
d6682 2
a6683 2
	} /* traversal */

d6689 1
a6689 1
	cmd = LKC_TO_LAC(keymap,c);  /* adds 1 to map EOF to 0 */
d6692 2
a6693 2
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override,c))
	  cmd = LKC_TO_LAC(key_override,c);
d6698 5
a6702 4
new_cmd:  /*
	   *  A goto point for new input without going
	   *  back through the getch() loop.
	   */
d6710 1
a6710 1
	switch(cmd) {
d6714 1
a6714 1
	case 0: /* unmapped character */
d6749 1
a6749 1
	     *	No network transmission to interrupt - 'til we multithread.
d6754 10
a6763 10
	     c = '\0';
	     /* FALLTHRU */
	case LYK_1: /* FALLTHRU */
	case LYK_2: /* FALLTHRU */
	case LYK_3: /* FALLTHRU */
	case LYK_4: /* FALLTHRU */
	case LYK_5: /* FALLTHRU */
	case LYK_6: /* FALLTHRU */
	case LYK_7: /* FALLTHRU */
	case LYK_8: /* FALLTHRU */
d6769 1
a6769 1
	case LYK_SOURCE:  /* toggle view source mode */
d6784 1
a6784 1
	case LYK_RELOAD:  /* control-R to reload and refresh */
d6806 1
a6806 1
		return(EXIT_SUCCESS);
d6809 2
a6810 2
	case LYK_ABORT:		/* don't ask the user about quitting */
	    return(EXIT_SUCCESS);
d6820 1
a6820 1
	case  LYK_UP_TWO:
d6824 1
a6824 1
	case  LYK_DOWN_TWO:
d6828 1
a6828 1
	case  LYK_UP_HALF:
d6832 1
a6832 1
	case  LYK_DOWN_HALF:
d6868 1
a6868 1
	    if (no_goto && !LYValidate) { /*  Go to not allowed. - FM */
d6871 1
a6871 1
		unsigned char *s = get_clip_grab(), *e, *t;
d6877 1
a6877 1
		len2 = strlen(s);
d6884 3
a6886 2
		    s++; e--;
		    if (!strncasecomp(s,"URL:", 4))
d6896 2
a6897 2
		buf = (char*)malloc(len);
		strncpy(buf, s, e - s);
d6899 1
a6899 1
		t = buf;
d6932 1
a6932 1
		switch(last_kcode) {
d6947 1
a6947 1
	    lynx_start_title_color ();
d6949 1
a6949 1
	    lynx_stop_title_color ();
d6971 2
a6972 2
		Newline = i;		/* go to end of file */
		arrowup = TRUE;		/* position on last link */
d7043 1
a7043 1
		return(EXIT_SUCCESS);
d7053 1
a7053 1
	case LYK_NOCACHE: /* Force submission of form or link with no-cache */
d7060 6
a7065 1
	    switch (handle_LYK_ACTIVATE(&c, cmd, &try_internal, &refresh_screen, &force_load, real_cmd)) {
d7072 1
d7081 1
a7081 1
	case LYK_ECGOTO:	/* edit current URL and go to to it	*/
d7090 2
a7091 2
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
d7104 1
a7104 1
	case LYK_INDEX:		/* index file */
d7185 1
a7185 1
	case LYK_EDIT_TEXTAREA: /* use external editor on a TEXTAREA - KED */
d7197 1
a7197 1
	case LYK_PRINT:		/* print the file */
d7213 1
a7213 1
	case LYK_VLINKS:  /* list links visited during the current session */
d7218 1
a7218 1
	case LYK_TOOLBAR:  /* go to Toolbar or Banner in current document */
d7223 1
a7223 1
	case LYK_DIRED_MENU:  /* provide full file management menu */
d7226 1
a7226 1
#endif /* DIRED_SUPPORT || VMS*/
d7245 1
a7245 1
	case LYK_SHELL:		/* (!) shell escape */
d7259 1
a7259 1
	  case LYK_UPLOAD:
d7302 4
a7305 4
				    &FirstURLRecall, &URLNum, &URLTotal, &ch,
				    &old_c, real_c)) {
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
d7333 1
a7333 1
	} /* end of BIG switch */
d7337 1
a7337 3
PRIVATE int are_different ARGS2(
	DocInfo *,	doc1,
	DocInfo *,	doc2)
d7342 1
a7342 1
     *	Do we have two addresses?
d7348 1
a7348 1
     *	Do they differ in the type of request?
d7354 2
a7355 3
     *	See if the addresses are different, making sure
     *	we're not tripped up by multiple anchors in the
     *	the same document from a POST form. -- FM
d7360 1
a7360 1
     *	Are the base addresses different?
d7365 1
a7365 1
	return(TRUE);
d7371 1
a7371 1
     *	Do the docs have different contents?
d7376 1
a7376 1
		return(TRUE);
d7378 1
a7378 1
	    return(TRUE);
d7380 1
a7380 1
	return(TRUE);
d7383 1
a7383 1
     *	We'll assume the two documents in fact are the same.
d7385 1
a7385 1
    return(FALSE);
d7392 1
a7392 3
PRIVATE int are_phys_different ARGS2(
	DocInfo *,	doc1,
	DocInfo *,	doc2)
d7397 1
a7397 1
     *	Do we have two addresses?
d7403 1
a7403 1
     *	Do they differ in the type of request?
d7421 1
a7421 1
	return(FALSE);
d7424 2
a7425 3
     *	See if the addresses are different, making sure
     *	we're not tripped up by multiple anchors in the
     *	the same document from a POST form. -- FM
d7430 1
a7430 1
     *	Are the base addresses different?
d7435 1
a7435 1
	return(TRUE);
d7441 1
a7441 1
     *	Do the docs have different contents?
d7446 1
a7446 1
		return(TRUE);
d7448 1
a7448 1
	    return(TRUE);
d7450 1
a7450 1
	return(TRUE);
d7453 1
a7453 1
     *	We'll assume the two documents in fact are the same.
d7455 1
a7455 1
    return(FALSE);
d7460 1
a7460 1
 *  Utility for freeing the list of goto URLs. - FM
d7463 1
a7463 1
PRIVATE void HTGotoURLs_free NOARGS
d7465 2
a7466 10
    char *url;
    HTList *cur = Goto_URLs;

    if (cur != 0) {
	while (NULL != (url = (char *)HTList_nextObject(cur))) {
	    FREE(url);
	}
	HTList_delete(Goto_URLs);
	Goto_URLs = NULL;
    }
d7471 2
a7472 2
 *  Utility for listing Goto URLs, making any
 *  repeated URLs the most current in the list. - FM
d7474 1
a7474 2
PUBLIC void HTAddGotoURL ARGS1(
	char *,		url)
d7476 1
a7476 1
    char *new = NULL;
d7480 1
a7480 1
    if (!(url && *url))
d7484 1
a7484 1
    StrAllocCopy(new, url);
d7491 1
a7491 1
	HTList_addObject(Goto_URLs, new);
d7496 2
a7497 2
    while (NULL != (old = (char *)HTList_nextObject(cur))) {
	if (!strcmp(old, new)) {
d7503 1
a7503 1
    HTList_addObject(Goto_URLs, new);
d7509 2
a7510 3
 *  When help is not on the screen,
 *  put a message on the screen
 *  to tell the user other misc info.
d7512 2
a7513 3
PRIVATE void show_main_statusline ARGS2(
    CONST LinkInfo,	curlink,
    int,		for_what)
d7516 1
a7516 1
     *	Make sure form novice lines are replaced.
d7524 1
a7524 1
	 *  Currently displaying HTML source.
d7528 4
a7531 4
    /*
     *	If we are in forms mode then explicitly
     *	tell the user what each kind of link is.
     */
d7551 1
a7551 1
	 *  Let them know if it's an index -- very rare.
d7554 4
a7557 3
	    char *indx = gettext("-index-");
	    LYmove(LYlines-1, LYcols - strlen(indx) - 1);
	    start_reverse();
d7559 1
a7559 1
	    stop_reverse();
d7564 1
a7564 1
	 *  Show the URL or, for some internal links, the fragment
d7605 3
a7607 3
 *  Public function for redrawing the statusline appropriate for the
 *  selected link.  It should only be called at times when curdoc.link,
 *  nlinks, and the links[] array are valid. - kw
d7609 1
a7609 2
PUBLIC void repaint_main_statusline ARGS1(
    int,	for_what)
d7615 1
a7615 2
PRIVATE void form_noviceline ARGS1(
    int,	disabled)
d7617 2
a7618 1
    LYmove(LYlines-2,0); LYclrtoeol();
d7622 2
a7623 1
    LYmove(LYlines-1,0); LYclrtoeol();
d7633 1
d7650 2
a7651 3
PRIVATE void exit_immediately_with_error_message ARGS2(
	int,		state,
	BOOLEAN,	first_file)
d7661 1
a7661 2
    if (state == NOT_FOUND)
    {
d7665 4
a7668 4
		   /*
		    * hack: if we fail in HTAccess.c
		    * avoid duplicating URL, oh.
		    */
d7670 1
a7670 1
							       "" : startfile);
d7673 1
a7673 2
    if (state == NULLFILE)
    {
d7691 1
a7691 1
	SetOutputMode( O_TEXT );
d7693 1
a7693 1
	SetOutputMode( O_BINARY );
d7704 3
a7706 5

PRIVATE void status_link ARGS3(
	char *,		curlink_name,
	BOOLEAN,	show_more,
	BOOLEAN,	show_indx)
d7708 1
a7708 1
#define MAX_STATUS (LYcols - 2)
d7717 1
a7717 1
		(int)(sizeof(format) - 2),
d7723 1
a7723 1
		(int)(sizeof(format) - prefix - 2),
d7742 1
a7742 2
	     *  Scan to find the final leaf of the URL.
	     *  Ignore trailing '/'.
d7746 1
a7746 2
		 cut_to_pos--)
		 ;
d7748 1
a7748 1
	     *  Jump back to the next leaf to remove.
d7752 8
a7759 7
		 || (prefix + cut_from_pos + 4 + (length - cut_to_pos) >= MAX_STATUS));
		 cut_from_pos--)
		 ;
	    /*
	     *  Replace some leaves to '...', if possible, and put the
	     *  final leaf at the end. We assume that one can recognize
	     *  the link from at least MIN_STATUS characters.
d7768 1
a7768 1
	    CTRACE((tfp,"lastline = %s\n",buf)); /* don't forget to erase me */
d7770 1
a7770 1
	} else {	/* show (possibly truncated) url */
d7776 1
a7776 2
PUBLIC char*
LYDownLoadAddress NOARGS
d7778 1
a7778 2
    char *s = newdoc.address ? newdoc.address : "";
    return s;
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d396 1
a396 1
#ifdef SOURCE_CACHE
d413 1
a413 1
#endif /* SOURCE_CACHE */
d422 1
a422 1
#ifdef SOURCE_CACHE
d481 1
a481 1
#ifdef SOURCE_CACHE
d1853 1
a1853 1
    char *test = HTGetProgramPath(ppCSWING);
d2950 1
a2950 1
			HTuncache_current_document();
d3028 1
a3028 1
			HTuncache_current_document();
d3065 1
a3065 1
#ifdef SOURCE_CACHE
d3078 1
a3078 1
	HTuncache_current_document();
d3083 1
a3083 1
#ifdef SOURCE_CACHE
d3094 1
a3094 1
#ifdef SOURCE_CACHE
d3573 1
a3573 1
#ifdef SOURCE_CACHE
d3586 1
a3586 1
	    HTuncache_current_document();
d3591 1
a3591 1
#ifdef SOURCE_CACHE
d3603 1
a3603 1
#ifdef SOURCE_CACHE
d3703 1
a3703 1
#ifdef SOURCE_CACHE
d3733 1
a3733 1
#ifdef SOURCE_CACHE
d3757 1
a3757 1
		HTuncache_current_document();
a4140 4
/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
d4144 4
d4166 1
a4166 1
    HTuncache_current_document();
d4251 1
a4251 1
#ifdef SOURCE_CACHE
d4264 1
a4264 1
	HTuncache_current_document();
d4269 1
a4269 1
#ifdef SOURCE_CACHE
d4275 1
a4275 1
#ifdef SOURCE_CACHE
a4280 4
/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
d4284 5
a4288 1
#ifdef SOURCE_CACHE
d4293 1
a4293 1
#ifdef SOURCE_CACHE
d4311 1
a4311 1
#ifdef SOURCE_CACHE
d4344 1
a4344 1
#ifdef SOURCE_CACHE
d4372 1
a4372 1
	    HTuncache_current_document();
d4382 1
a4382 1
#ifdef SOURCE_CACHE
d4388 1
a4388 1
#ifdef SOURCE_CACHE
d6194 1
a6194 1
#ifdef SOURCE_CACHE
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d3 1
d41 68
d110 32
a141 1
#ifdef USE_EXTERNALS
d157 13
d172 4
a175 9
PRIVATE void print_status_message PARAMS((CONST linkstruct curlink, char **cp));
PRIVATE BOOL confirm_post_resub PARAMS((
    CONST char*		address,
    CONST char*		title,
    int			if_imgmap,
    int			if_file));
PRIVATE int are_different PARAMS((document *doc1, document *doc2));
PUBLIC void HTGotoURLs_free NOPARAMS;
PUBLIC void HTAddGotoURL PARAMS((char *url));
d178 1
a178 1
PRIVATE int are_phys_different PARAMS((document *doc1, document *doc2));
d195 3
d200 2
a201 6
PUBLIC int Newline_partial = 0;     /* required for display_partial mode */
PUBLIC int NumOfLines_partial = -1; /* initialize to -1 the very first time */
PUBLIC BOOLEAN display_partial = FALSE;
PUBLIC int Newline = 0;
#else
PRIVATE int Newline = 0;
d204 3
a206 2
PRIVATE document newdoc;
PRIVATE document curdoc;
d209 12
d228 4
a231 11
    FREE(newdoc.title);
    FREE(newdoc.address);
    FREE(newdoc.post_data);
    FREE(newdoc.post_content_type);
    FREE(newdoc.bookmark);
    FREE(curdoc.title);
    FREE(curdoc.address);
    FREE(curdoc.post_data);
    FREE(curdoc.post_content_type);
    FREE(curdoc.bookmark);
#ifdef USE_HASH
d237 2
d241 1
d243 2
d250 1
a250 8
PUBLIC FILE *TraceFP NOARGS
{
    if (LYTraceLogFP != 0) {
	return LYTraceLogFP;
    }
    return stderr;
}

d258 37
a294 1
	exit(-1);
d296 2
d302 1
d326 4
a329 1
	 *  anonymous restrictions are set. - FM
d331 25
a355 2
	if (LYRestricted) {
	    CTRACE(tfp, "Anonymous restrictions are set.\n");
d358 1
d364 1
d371 12
d385 18
a402 1
PRIVATE BOOLEAN LYReopenTracelog ARGS1(BOOLEAN *, trace_flag_ptr)
d404 5
a408 9
    CTRACE(tfp, "\nTurning off TRACE for fetch of log.\n");
    LYCloseTracelog();
    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
	TracelogOpenFailed();
	return FALSE;
    }
    if (TRACE) {
	WWW_TraceFlag = FALSE;
	*trace_flag_ptr = TRUE;
d410 2
a411 1
    return TRUE;
d413 1
d415 6
a420 2
PRIVATE void do_change_link ARGS1(
	char *,		prev_target)
d422 3
a424 6
    /* Is there a mouse-clicked link waiting? */
    int mouse_tmp = get_mouse_link();
    /* If yes, use it as the link */
    if (mouse_tmp != -1) {
	highlight(OFF, curdoc.link, prev_target);
	curdoc.link = mouse_tmp;
d426 3
d432 1
a432 6
 *  Here's where we do all the work.
 *  mainloop is basically just a big switch dependent on the users input.
 *  I have tried to offload most of the work done here to procedures to
 *  make it more modular, but this procedure still does a lot of variable
 *  manipulation.  This needs some work to make it neater. - Lou Moutilli
 *					(memoir from the original Lynx - FM)
d434 13
d448 2
a449 1
int mainloop NOARGS
d451 2
a452 33
    int c = 0, real_c = 0, old_c = 0;
    int cmd = LYK_DO_NOTHING, real_cmd = LYK_DO_NOTHING;
    int getresult;
    int arrowup = FALSE, show_help = FALSE;
    char prev_target[512];
    char user_input_buffer[1024];
    char *owner_address = NULL;  /* Holds the responsible owner's address     */
    char *ownerS_address = NULL; /* Holds owner's address during source fetch */
    BOOLEAN first_file = TRUE;
    BOOLEAN popped_doc = FALSE;
    BOOLEAN refresh_screen = FALSE;
    BOOLEAN force_load = FALSE;
    BOOLEAN try_internal = FALSE;
    BOOLEAN crawl_ok = FALSE;
    BOOLEAN rlink_exists;
    BOOLEAN rlink_allowed;
    BOOLEAN vi_keys_flag = vi_keys;
    BOOLEAN emacs_keys_flag = emacs_keys;
    BOOLEAN trace_mode_flag = FALSE;
    BOOLEAN forced_HTML_mode = LYforce_HTML_mode;
    char cfile[128];
    FILE *cfp;
    char *cp, *toolbar;
    int ch, recall;
    int URLTotal;
    int URLNum;
    BOOLEAN FirstURLRecall = TRUE;
    char *temp = NULL;
    BOOLEAN ForcePush = FALSE;
    BOOLEAN override_LYresubmit_posts = FALSE;
    unsigned int len;
    int i;
    int n;
d454 7
a460 4
#ifdef DIRED_SUPPORT
    char *tp = NULL;
    struct stat dir_info;
#endif /* DIRED_SUPPORT */
d462 1
d464 4
a467 6
 *  curdoc.address contains the name of the file that is currently open.
 *  newdoc.address contains the name of the file that will soon be
 *		     opened if it exits.
 *  prev_target    contains the last search string the user searched for.
 *  newdoc.title   contains the link name that the user last chose to get
 *		     into the current link (file).
d469 20
a488 14
    /* initialize some variables*/
    newdoc.address = NULL;
    newdoc.title = NULL;
    newdoc.post_data = NULL;
    newdoc.post_content_type = NULL;
    newdoc.bookmark = NULL;
    curdoc.address = NULL;
    curdoc.title = NULL;
    curdoc.post_data = NULL;
    curdoc.post_content_type = NULL;
    curdoc.bookmark = NULL;
#ifdef USE_HASH
    curdoc.style = NULL;
    newdoc.style = NULL;
d490 26
a515 16
    nhist = 0;
    user_input_buffer[(sizeof(user_input_buffer) - 1)] = '\0';
    *prev_target = '\0';
    *user_input_buffer = '\0';
#ifdef LY_FIND_LEAKS
    atexit(free_mainloop_variables);
#endif
initialize:
    StrAllocCopy(newdoc.address, startfile);
    StrAllocCopy(startrealm, startfile);
    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    newdoc.line = 1;
    newdoc.link = 0;
d517 9
a525 4
#ifdef USE_SLANG
    if (TRACE && LYCursesON) {
	addstr("\n");
	refresh();
d527 1
a527 2
#endif /* USE_SLANG */
    CTRACE(tfp,"Entering mainloop, startfile=%s\n",startfile);
d529 17
a545 6
    if (form_post_data) {
	StrAllocCopy(newdoc.post_data, form_post_data);
	StrAllocCopy(newdoc.post_content_type,
		     "application/x-www-form-urlencoded");
    } else if (form_get_data) {
	StrAllocCat(newdoc.address, form_get_data);
d547 94
a641 11
    if (bookmark_start) {
	if (LYValidate) {
	    HTAlert(BOOKMARKS_DISABLED);
	    bookmark_start = FALSE;
	    goto initialize;
	} else if (traversal) {
	    HTAlert(BOOKMARKS_NOT_TRAVERSED);
	    traversal = FALSE;
	    crawl = FALSE;
	    bookmark_start = FALSE;
	    goto initialize;
d643 2
d646 2
a647 2
	     *	See if a bookmark page exists.	If it does,
	     *	replace newdoc.address with it's name
d649 7
a655 8
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL &&
		 *cp != '\0' && strcmp(cp, " ")) {
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		StrAllocCopy(startrealm, newdoc.address);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		newdoc.isHEAD = FALSE;
d657 7
a663 5
		CTRACE(tfp, "Using bookmarks=%s\n", newdoc.address);
	    } else {
		HTUserMsg(BOOKMARKS_NOT_OPEN);
		bookmark_start = FALSE;
		goto initialize;
d665 2
d669 1
d671 12
a682 2
    FREE(form_post_data);
    FREE(form_get_data);
d684 2
a685 4
    if (user_mode == NOVICE_MODE)
	display_lines = LYlines-4;
    else
	display_lines = LYlines-2;
d687 21
a707 3
    while (TRUE) {
#ifdef USE_HASH
	if (curdoc.style != NULL) force_load = TRUE;
d710 1
a710 2
	 *  If newdoc.address is different then curdoc.address then
	 *  we need to go out and find and load newdoc.address.
d712 23
a734 12
	if (LYforce_no_cache || force_load ||
	    are_different(&curdoc, &newdoc)) {

		force_load = FALSE;  /* done */
		if (TRACE && LYCursesON) {
		    move(LYlines-1, LYcols-1);	/* make sure cursor is down */
#ifdef USE_SLANG
		    addstr("\n");
#endif /* USE_SLANG */
		    refresh();
		}
try_again:
d736 1
a736 2
		 *  Push the old file onto the history stack if we
		 *  have a current doc and a new address. - FM
d738 17
a754 1
		if (curdoc.address && newdoc.address) {
d756 2
a757 6
		     *	Don't actually push if this is a LYNXDOWNLOAD
		     *	URL, because that returns NORMAL even if it
		     *	fails due to a spoof attempt or file access
		     *	problem, and we set the newdoc structure
		     *	elements to the curdoc structure elements
		     *	under case NORMAL.  - FM
d759 40
a798 5
		    if (strncmp(newdoc.address, "LYNXDOWNLOAD:", 13))
		    {
			LYpush(&curdoc, ForcePush);
		    }
		} else if (!newdoc.address) {
d800 2
a801 2
		     *	If newdoc.address is empty then pop a file
		     *	and load it.  - FM
d803 30
a832 2
		    LYpop(&newdoc);
		    popped_doc = TRUE;
d834 5
d840 24
a863 8
#ifndef DONT_TRACK_INTERNAL_LINKS
#define NO_INTERNAL_OR_DIFFERENT(c,n) TRUE
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) (!curdoc.internal_link || \
			   are_phys_different(p,n))
#else /* TRACK_INTERNAL_LINKS */
#define NO_INTERNAL_OR_DIFFERENT(c,n) are_different(c,n)
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) are_different(p,n)
#endif /* TRACK_INTERNAL_LINKS */
d865 13
d879 35
a913 33
#ifndef DONT_TRACK_INTERNAL_LINKS
		    /*
		    ** If curdoc had been reached via an internal
		    ** (fragment) link from what we now have just
		    ** popped into newdoc, then override non-caching in
		    ** all cases. - kw
		    */
		    if (curdoc.internal_link &&
			!are_phys_different(&curdoc, &newdoc)) {
			LYinternal_flag = TRUE;
			LYoverride_no_cache = TRUE;
			LYforce_no_cache = FALSE;
			try_internal = TRUE;
		    } else
#endif /* TRACK_INTERNAL_LINKS */
			/*
			 * Force a no_cache override unless
			 *  it's a bookmark file, or it has POST content
			 *  and LYresubmit_posts is set without safe also
			 *  set, and we are not going to another position
			 *  in the current document or restoring the previous
			 *  document due to a NOT_FOUND or NULLFILE return
			 *  value from getfile(). - FM
			 */
			if ((newdoc.bookmark != NULL) ||
			(newdoc.post_data != NULL &&
			 !newdoc.safe &&
			 LYresubmit_posts &&
			 !override_LYresubmit_posts &&
			    NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			LYoverride_no_cache = FALSE;
		    } else {
			LYoverride_no_cache = TRUE;
d915 28
d944 63
a1006 1
		override_LYresubmit_posts = FALSE;
d1008 3
a1010 20
		if (HEAD_request) {
		    /*
		     *	Make SURE this is an appropriate request. - FM
		     */
		    if (newdoc.address) {
			if (LYCanDoHEAD(newdoc.address) == TRUE) {
			    newdoc.isHEAD = TRUE;
			} else if (!strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
			    if (LYCanDoHEAD(newdoc.address + 11) == TRUE) {
				StrAllocCopy(temp, newdoc.address + 11);
				FREE(newdoc.address);
				newdoc.address = temp;
				newdoc.isHEAD = TRUE;
				temp = NULL;
			    }
			}
		    }
		    try_internal = FALSE;
		    HEAD_request = FALSE;
		}
d1012 10
d1023 1
a1023 4
		 *  If we're getting the TRACE log and it's not new,
		 *  check whether its HText structure has been dumped,
		 *  and if so, fflush() and fclose() it to ensure it's
		 *  fully updated, and then fopen() it again. - FM
d1025 5
a1029 22
		if (LYUseTraceLog == TRUE &&
		    trace_mode_flag == FALSE &&
		    LYTraceLogFP != NULL &&
		    !strcmp((newdoc.title ? newdoc.title : ""),
			     LYNX_TRACELOG_TITLE)) {
		    DocAddress WWWDoc;
		    HTParentAnchor *tmpanchor;

		    WWWDoc.address = newdoc.address;
		    WWWDoc.post_data = newdoc.post_data;
		    WWWDoc.post_content_type = newdoc.post_content_type;
		    WWWDoc.bookmark = newdoc.bookmark;
		    WWWDoc.isHEAD = newdoc.isHEAD;
		    WWWDoc.safe = newdoc.safe;
		    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
		    if ((HText *)HTAnchor_document(tmpanchor) == NULL) {
			if (!LYReopenTracelog(&trace_mode_flag)) {
			    old_c = 0;
			    cmd = LYK_PREV_DOC;
			    goto new_cmd;
			}
		    }
d1031 68
a1098 10

		LYRequestTitle = newdoc.title;
		if (newdoc.bookmark)
		    LYforce_HTML_mode = TRUE;
		if (LYValidate &&
		    startfile_ok &&
		    newdoc.address && startfile && homepage &&
		    (!strcmp(newdoc.address, startfile) ||
		     !strcmp(newdoc.address, homepage))) {
		    LYPermitURL = TRUE;
d1100 1
a1100 5

		Newline = newdoc.line; /* bypass for partial mode */
#ifdef DISP_PARTIAL
		display_partial = display_partial_flag; /* restore */
		Newline_partial = Newline;  /* initialize */
d1102 2
a1103 7
		 * Disable display_partial if requested URL has #fragment
		 * and we are not popped from the history stack
		 * so can't calculate correct newline position for fragment.
		 * Otherwise user got the new document from the first page
		 * and be moved to #fragment later after download
		 * completed, but only if s/he did not mess screen up by
		 * scrolling before...  So fall down to old behavior here.
d1105 10
a1114 14
		if (Newline_partial == 1 && strchr(newdoc.address, '#'))
		    display_partial = FALSE;
#endif /* DISP_PARTIAL */
#ifdef USE_PSRC
		psrc_first_tag = TRUE;
#endif
#ifndef DONT_TRACK_INTERNAL_LINKS
		if (try_internal) {
		    if (newdoc.address &&
			0==strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
			try_internal = FALSE;
		    } else if (curdoc.address &&
			0==strncmp(curdoc.address, "LYNXIMGMAP:", 11)) {
			try_internal = FALSE;
d1117 58
a1174 4
		if (try_internal) {
		    char *hashp = strchr(newdoc.address,'#');
		    if (hashp) {
			HTFindPoundSelector(hashp+1);
d1176 21
a1196 12
		    getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		    try_internal = FALSE; /* done */
		    /* fix up newdoc.address which may have been fragment-only */
		    if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
			if (!hashp) {
			    StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
			} else {
			    StrAllocCopy(temp, HTLoadedDocumentURL());
			    StrAllocCat(temp, hashp); /* append fragment */
			    StrAllocCopy(newdoc.address, temp);
			    FREE(temp);
			}
a1197 18
		} else {
		    if (newdoc.internal_link && newdoc.address &&
			*newdoc.address == '#' && nhist > 0) {
			char *cp0;
			if (0==strncmp(history[nhist-1].address, "LYNXIMGMAP:", 11))
			    cp0 = history[nhist-1].address + 11;
			else
			    cp0 = history[nhist-1].address;
			StrAllocCopy(temp, cp0);
			cp0 = strchr(temp, '#');
			if (cp0)
			    *cp0 = '\0';
			StrAllocCat(temp, newdoc.address);
			FREE(newdoc.address);
			newdoc.address = temp;
			temp = NULL;
		    }
		    getresult = getfile(&newdoc);
d1199 91
a1289 3
#else  /* TRACK_INTERNAL_LINKS */
		getresult = getfile(&newdoc);
#endif /* TRACK_INTERNAL_LINKS */
d1291 7
a1297 1
		switch(getresult) {
d1299 67
a1365 26
		case NOT_FOUND:
		    /*
		     *	OK! can't find the file, so it must not be around now.
		     *	Do any error logging, if appropriate.
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    if (trace_mode_flag == TRUE) {
			WWW_TraceFlag = TRUE;
			trace_mode_flag = FALSE;
			fprintf(tfp, "Turning TRACE back on.\n\n");
		    }
		    if (error_logging &&
			first_file && owner_address && !LYCancelledFetch) {
			/*
			 *  Email a bad link message to the owner of
			 *  the document (but NOT to lynx-dev). - FM
			 */
			if (strncasecomp(owner_address, "mailto:", 7)) {
			    if (strncasecomp((owner_address + 7),
					     "lynx-dev@@", 9)) {
				mailmsg(curdoc.link,
					(owner_address+7),
					history[nhist-1].address,
					history[nhist-1].title);
d1369 115
a1483 2
		    if (traversal && !first_file && !LYCancelledFetch) {
			FILE *ofp;
d1485 7
a1491 12
			if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
			    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				perror(NOOPEN_TRAV_ERR_FILE);
				exit_immediately(-1);
			    }
			}
			fprintf(ofp, "%s %s\tin %s\n",
				     links[curdoc.link].lname,
				     links[curdoc.link].target,
				     history[nhist-1].address);
			fclose(ofp);
		    }
d1493 53
d1547 1
a1547 3
		     *	Fall through to do the NULL stuff and reload the
		     *	old file, unless the first file wasn't found or
		     *	has gone missing.
d1549 3
a1551 9
		    if (!nhist) {
			/*
			 *  If nhist = 0 then it must be the first file.
			 */
			exit_immediately_with_error_message(NOT_FOUND, first_file);
			return(-1);
		    }

		case NULLFILE:
d1553 4
a1556 1
		     *	Not supposed to return any file.
d1558 7
a1564 30
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    if (trace_mode_flag == TRUE) {
			WWW_TraceFlag = TRUE;
			trace_mode_flag = FALSE;
			fprintf(tfp, "Turning TRACE back on.\n\n");
		    }
		    FREE(newdoc.address); /* to pop last doc */
		    FREE(newdoc.bookmark);
		    LYJumpFileURL = FALSE;
		    reloading = FALSE;
		    LYPermitURL = FALSE;
		    LYCancelledFetch = FALSE;
		    ForcePush = FALSE;
		    LYforce_HTML_mode = FALSE;
		    if (traversal) {
			crawl_ok = FALSE;
			if (traversal_link_to_add) {
			    /*
			     *	It's a binary file, or the fetch attempt
			     *	failed.  Add it to TRAVERSE_REJECT_FILE
			     *	so we don't try again in this run.
			     */
			    if (!lookup_reject(traversal_link_to_add)) {
				add_to_reject_list(traversal_link_to_add);
			    }
			    FREE(traversal_link_to_add);
			}
		    }
d1566 1
a1566 2
		     *  Make sure the first file was found and
		     *  has not gone missing.
d1568 139
a1706 1
		    if (!nhist) {
d1708 1
a1708 1
			 *  If nhist = 0 then it must be the first file.
d1710 46
a1755 29
			if (first_file && homepage &&
#ifdef VMS
			   strcasecomp(homepage, startfile) != 0
#else
			   strcmp(homepage, startfile) != 0
#endif /* VMS */
			   ) {
			   /*
			    *  Couldn't return to the first file but there is a
			    *  homepage we can use instead. Useful for when the
			    *  first URL causes a program to be invoked. - GL
			    *
			    *  But first make sure homepage is different from
			    *  startfile (above), then make it the same (below)
			    *  so we don't enter an infinite getfile() loop on
			    *  on failures to find the files. - FM
			    */
			   StrAllocCopy(newdoc.address, homepage);
			   FREE(newdoc.post_data);
			   FREE(newdoc.post_content_type);
			   FREE(newdoc.bookmark);
			   StrAllocCopy(startfile, homepage);
			   newdoc.isHEAD = FALSE;
			   newdoc.safe = FALSE;
			   newdoc.internal_link = FALSE;
			   goto try_again;
			} else {
			   exit_immediately_with_error_message(NULLFILE, first_file);
			   return(-1);
d1758 12
d1771 52
a1822 48
		   /*
		    *  Retrieval of a newdoc just failed, and just
		    *  going to try_again would pop the next doc
		    *  from history and try to get it without further
		    *  questions.  This may not be the right thing to do if
		    *  we have POST data, so fake a PREV_DOC key if it seems
		    *  that some prompting should be done.  Dunno about the
		    *  traversal logic, so I leave that case alone.
		    */
		   if (history[nhist - 1].post_data &&
		       !history[nhist - 1].safe) {
		       if (HText_POSTReplyLoaded((document *)&history[(nhist - 1)])) {
			   override_LYresubmit_posts = TRUE;
			   goto try_again;
		       }
		       /*  Set newdoc fields, just in case the PREV_DOC
			*  gets cancelled. - kw */
		       if (!curdoc.address) {
			   StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
			   StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			   if (HTMainAnchor && HTMainAnchor->post_data) {
			       StrAllocCopy(newdoc.post_data,
					    HTMainAnchor->post_data);
			       StrAllocCopy(newdoc.post_content_type,
					    HTMainAnchor->post_content_type);
			   } else {
			       FREE(newdoc.post_data);
			   }
			   newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			   newdoc.safe = HTLoadedDocumentIsSafe();
			   newdoc.internal_link = FALSE;
		       } else {
			   StrAllocCopy(newdoc.address, curdoc.address);
			   StrAllocCopy(newdoc.title, curdoc.title);
			   StrAllocCopy(newdoc.post_data, curdoc.post_data);
			   StrAllocCopy(newdoc.post_content_type,
					curdoc.post_content_type);
			   newdoc.isHEAD = curdoc.isHEAD;
			   newdoc.safe = curdoc.safe;
			   newdoc.internal_link = curdoc.internal_link;
			   newdoc.line = curdoc.line;
			   newdoc.link = curdoc.link;
		       }
		       cmd = LYK_PREV_DOC;
		       goto new_cmd;
		    }
		    override_LYresubmit_posts = TRUE;
		    goto try_again;
d1824 20
a1843 12
		case NORMAL:
		    /*
		     *	Marvelously, we got the document!
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    if (trace_mode_flag == TRUE) {
			WWW_TraceFlag = TRUE;
			trace_mode_flag = FALSE;
			fprintf(tfp, "Turning TRACE back on.\n\n");
		    }
		    *prev_target = '\0';    /* Reset for this document. - FM */
d1845 6
a1850 15
		    /*
		     *	If it's the first file and we're interactive,
		     *	check whether it's a bookmark file which was
		     *	not accessed via the -book switch. - FM
		     */
		    if (((first_file == TRUE) &&
			 (dump_output_immediately == FALSE) &&
			 !(newdoc.bookmark && *newdoc.bookmark)) &&
			((LYisLocalFile(newdoc.address) == TRUE) &&
			 !(strcmp((HText_getTitle() ? HText_getTitle() : ""),
				  BOOKMARK_TITLE))) &&
			(temp = HTParse(newdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION)) != NULL) {
			cp = wwwName(Home_Dir());
			len = strlen(cp);
d1852 105
a1956 2
			if (!strncasecomp(temp, cp, len) &&
			    strlen(temp) > len)
d1958 9
a1966 2
			if (!strncmp(temp, cp, len) &&
			    strlen(temp) > len)
d1968 449
a2416 1
			{
d2418 1
a2418 6
			     *	We're interactive and this might be a
			     *	bookmark file entered as a startfile
			     *	rather than invoked via -book.	Check
			     *	if it's in our bookmark file list, and
			     *	if so, reload if with the relevant
			     *	bookmark elements set. - FM
d2420 2
a2421 16
			    if ((cp = (char *)calloc(1,
				  (strlen((char *)&temp[len]) + 2))) == NULL)
				outofmem(__FILE__, "mainloop");
			    if (temp[len] == '/') {
				if (strchr((char *)&temp[(len + 1)], '/')) {
				    sprintf(cp, ".%s", (char *)&temp[len]);
				} else {
				    strcpy(cp, (char *)&temp[(len + 1)]);
				}
			    } else {
				strcpy(cp, (char *)&temp[len]);
			    }
			    for (i = 0; i <= MBM_V_MAXFILES; i++) {
				if (MBM_A_subbookmark[i] &&
#ifdef VMS
				    !strcasecomp(cp, MBM_A_subbookmark[i])
a2422 59
				    !strcmp(cp, MBM_A_subbookmark[i])
#endif /* VMS */
				    ) {
				    StrAllocCopy(BookmarkPage,
						 MBM_A_subbookmark[i]);
				    break;
				}
			    }
			    FREE(cp);
			    if (i <= MBM_V_MAXFILES) {
				FREE(temp);
				if (LYValidate) {
				    HTAlert(BOOKMARKS_DISABLED);
				    return(-1);
				}
				if ((temp = HTParse(newdoc.address, "",
				 PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION))) {
				    StrAllocCopy(newdoc.address, temp);
				    HTuncache_current_document();
				    FREE(curdoc.address);
				    StrAllocCat(newdoc.address,
					    wwwName(Home_Dir()));
				    StrAllocCat(newdoc.address, "/");
				    StrAllocCat(newdoc.address,
					(strncmp(BookmarkPage, "./", 2) ?
							   BookmarkPage :
							(BookmarkPage + 2)));
				    StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				    StrAllocCopy(newdoc.bookmark, BookmarkPage);
#ifdef USE_HASH
				    if (curdoc.style)
					StrAllocCopy(newdoc.style, curdoc.style);
#endif
				    StrAllocCopy(startrealm, newdoc.address);
				    FREE(newdoc.post_data);
				    FREE(newdoc.post_content_type);
				    newdoc.isHEAD = FALSE;
				    newdoc.safe = FALSE;
				    FREE(temp);
				    if (!strcmp(homepage, startfile))
					StrAllocCopy(homepage, newdoc.address);
				    StrAllocCopy(startfile, newdoc.address);
				    CTRACE(tfp, "Reloading as bookmarks=%s\n",
						newdoc.address);
				    goto try_again;
				}
			    }
			}
			cp = NULL;
		    }
		    FREE(temp);

		    if (traversal) {
			/*
			 *  During traversal build up lists of all links
			 *  traversed.	Traversal mode is a special
			 *  feature for traversing http links in the web.
			 */
			if (traversal_link_to_add) {
d2424 2
a2425 1
			     *	Add the address we sought to TRAVERSE_FILE.
d2427 4
a2430 3
			    if (!lookup(traversal_link_to_add))
				add_to_table(traversal_link_to_add);
			    FREE(traversal_link_to_add);
a2431 6
			if (curdoc.address && curdoc.title &&
			    strncmp(curdoc.address, "LYNXIMGMAP:", 11))
			    /*
			     *	Add the address we got to TRAVERSE_FOUND_FILE.
			     */
			    add_to_traverse_list(curdoc.address, curdoc.title);
d2433 198
d2632 1970
a4601 15
		    /*
		     *	If this was a LYNXDOWNLOAD, we still have curdoc,
		     *	not a newdoc, so reset the address, title and
		     *	positioning elements. - FM
		     */
		    if (newdoc.address && curdoc.address &&
			!strncmp(newdoc.address, "LYNXDOWNLOAD:", 13)) {
			StrAllocCopy(newdoc.address, curdoc.address);
			StrAllocCopy(newdoc.title, (curdoc.title ?
						    curdoc.title : ""));
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
			newdoc.internal_link = FALSE; /* can't be true. - kw */
		    }
d4603 3
a4605 9
		    /*
		     *	Set Newline to the saved line.	It contains the
		     *	line the user was on if s/he has been in the file
		     *	before, or it is 1 if this is a new file.
		     */
#ifdef DISP_PARTIAL
		    /* Newline = newdoc.line; */
		    /* - alreary set and probably updated in partial mode */
		    /* incremental rendering stage already closed (but see below) */
d4607 7
a4613 11
		    if (Newline != Newline_partial || display_partial == TRUE) {
		       /* This is the case when we came from the history stack
			* _and_ cached HText was used instead of HT*Copy() call.
			* Set Newline and close partial mode here.
			*/
		       Newline = Newline_partial;
		       display_partial = FALSE;
		    }
#else
		    Newline = newdoc.line; /* now here, no partial mode */
#endif
d4615 13
a4627 7
		    /*
		     *	If we are going to a target line or
		     *	the first page of a popped document,
		     *	override any www_search line result.
		     */
		    if (Newline > 1 || popped_doc == TRUE)
			 www_search_result = -1;
d4629 5
a4633 14
		    /*
		     *	Make sure curdoc.line will not be equal
		     *	to Newline, so we get a redraw.
		     */
		    curdoc.line = -1;
#ifdef USE_PSRC
		    if (psrc_view)
			HTMark_asSource(); /* this flag is not set, since when
			displaying source, psrc_view is temporary unset when
			writing the HTML header - and HTMainText is created
			at that time.*/
#endif
		    break;
		}  /* end switch */
d4635 15
a4649 4
	    if (TRACE) {
		if (!LYTraceLogFP || trace_mode_flag) {
		    sleep(AlertSecs); /* allow me to look at the results */
		}
d4651 13
d4665 7
a4671 14
	    /*
	     *	Set the files the same.
	     */
	    StrAllocCopy(curdoc.address, newdoc.address);
	    StrAllocCopy(curdoc.post_data, newdoc.post_data);
	    StrAllocCopy(curdoc.post_content_type, newdoc.post_content_type);
	    StrAllocCopy(curdoc.bookmark, newdoc.bookmark);
#ifdef USE_HASH
	    StrAllocCopy(curdoc.style, HText_getStyle());
	    if (curdoc.style != NULL)
		style_readFromFile (curdoc.style);
#endif
	    curdoc.isHEAD = newdoc.isHEAD;
	    curdoc.internal_link = newdoc.internal_link;
d4673 15
a4687 10
	    /*
	     *	Set the remaining document elements and add to
	     *	the visited links list. - FM
	     */
	    if (ownerS_address != NULL) {
#ifndef USE_PSRC
		if (HTOutputFormat == WWW_SOURCE && !HText_getOwner())
#else
		if ( (LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
			&& !HText_getOwner() )
d4689 14
a4702 12
		    HText_setMainTextOwner(ownerS_address);
		FREE(ownerS_address);
	    }
	    if (HText_getTitle()) {
		StrAllocCopy(curdoc.title, HText_getTitle());
	    } else if (!dump_output_immediately) {
		StrAllocCopy(curdoc.title, newdoc.title);
	    }
	    StrAllocCopy(owner_address, HText_getOwner());
	    curdoc.safe = HTLoadedDocumentIsSafe();
	    if (!dump_output_immediately) {
		LYAddVisitedLink(&curdoc);
d4704 3
d4708 5
d4714 7
a4720 8
	   /*
	    *  Reset WWW present mode so that if we were getting
	    *  the source, we get rendered HTML from now on.
	    */
	   HTOutputFormat = WWW_PRESENT;
#ifdef USE_PSRC
	   psrc_view = FALSE;
#endif
d4722 25
a4746 1
	   HTMLSetCharacterHandling(current_char_set);	/* restore, for sure? */
d4748 13
a4760 23
	   /*
	    *  Reset all of the other relevant flags. - FM
	    */
	   LYUserSpecifiedURL = FALSE;	/* only set for goto's and jumps's */
	   LYJumpFileURL = FALSE;	/* only set for jump's */
	   LYNoRefererForThis = FALSE;	/* always reset on return here */
	   reloading = FALSE;		/* only set for RELOAD and RESUBMIT */
	   HEAD_request = FALSE;	/* only set for HEAD requests */
	   LYPermitURL = FALSE;		/* only set for LYValidate */
	   ForcePush = FALSE;		/* only set for some PRINT requests. */
	   LYforce_HTML_mode = FALSE;
	   popped_doc = FALSE;

	} /* end if (LYforce_no_cache || force_load || are_different(...)) */

	if (dump_output_immediately) {
	    if (crawl) {
		print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
	    } else {
		print_wwwfile_to_fd(stdout,0);
	    }
	    return(0);
	}
d4762 1
d4764 4
a4767 2
	 *  If the recent_sizechange variable is set to TRUE
	 *  then the window size changed recently.
d4769 8
a4776 14
	if (recent_sizechange) {
		stop_curses();
		start_curses();
		clear();
		refresh_screen = TRUE; /* to force a redraw */
		if (HTMainText)	/* to REALLY force it... - kw */
		    HText_setStale(HTMainText);
		recent_sizechange = FALSE;
		if (user_mode == NOVICE_MODE) {
		    display_lines = LYlines-4;
		} else {
		    display_lines = LYlines-2;
		}
	}
d4778 29
a4806 8
	if (www_search_result != -1) {
	     /*
	      *  This was a WWW search, set the line
	      *  to the result of the search.
	      */
	     Newline = www_search_result;
	     www_search_result = -1;  /* reset */
	}
d4808 14
a4821 5
	if (first_file == TRUE) {
	    /*
	     *	We can never again have the first file.
	     */
	    first_file = FALSE;
d4823 27
a4849 15
	    /*
	     *	Set the startrealm, and deal as best we can
	     *	with preserving forced HTML mode for a local
	     *	startfile. - FM
	     */
	    temp = HTParse(curdoc.address, "",
			   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
	    if (!temp || *temp == '\0') {
		StrAllocCopy(startrealm, NO_NOTHING);
	    } else {
		StrAllocCopy(startrealm, temp);
		FREE(temp);
		if (!(temp = HTParse(curdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION))) {
		    LYAddHtmlSep(&startrealm);
d4851 33
a4883 22
		    if (forced_HTML_mode &&
			!dump_output_immediately &&
			!curdoc.bookmark &&
			!strncasecomp(curdoc.address, "file:", 5) &&
			strlen(temp) > 1) {
			/*
			 *  We forced HTML for a local startfile which
			 *  is not a bookmark file and has a path of at
			 *  least two letters.	If it doesn't have a
			 *  suffix mapped to text/html, we'll set the
			 *  entire path (including the lead slash) as a
			 *  "suffix" mapped to text/html to ensure it is
			 *  always treated as an HTML source file.  We
			 *  are counting on a tail match to this full path
			 *  for some other URL fetched during the session
			 *  having too low a probability to worry about,
			 *  but it could happen. - FM
			 */
			HTAtom *encoding;

			if (HTFileFormat(temp, &encoding, NULL) != WWW_HTML) {
			    HTSetSuffix(temp, "text/html", "8bit", 1.0);
a4885 4
		    if ((cp = strrchr(temp, '/')) != NULL) {
			*(cp+1) = '\0';
			StrAllocCat(startrealm, temp);
		    }
a4886 4
	    }
	    FREE(temp);
	    CTRACE(tfp, "Starting realm is '%s'\n\n", startrealm);
	    if (traversal) {
d4888 2
a4889 1
		 *  Set up the crawl output stuff.
d4891 53
a4943 22
		if (curdoc.address && !lookup(curdoc.address)) {
		    if (strncmp(curdoc.address, "LYNXIMGMAP:", 11))
			crawl_ok = TRUE;
		    add_to_table(curdoc.address);
		}
		/*
		 *  Set up the traversal_host comparison string.
		 */
		if (strncmp((curdoc.address ? curdoc.address : "NULL"),
			    "http", 4)) {
		    StrAllocCopy(traversal_host, NO_NOTHING);
		} else if (check_realm) {
		    StrAllocCopy(traversal_host, startrealm);
		} else {
		    temp = HTParse(curdoc.address, "",
				   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
		    if (!temp || *temp == '\0') {
			StrAllocCopy(traversal_host, NO_NOTHING);
		    } else {
			StrAllocCopy(traversal_host, temp);
			LYAddHtmlSep(&traversal_host);
		    }
d4945 6
a4950 25
		}
		CTRACE(tfp, "Traversal host is '%s'\n\n", traversal_host);
	    }
	    if (startfile) {
		/*
		 *  If homepage was not equated to startfile,
		 *  make the homepage URL the first goto
		 *  entry. - FM
		 */
		if (homepage && strcmp(startfile, homepage))
		    HTAddGotoURL(homepage);
		/*
		 *  If we are not starting up with startfile
		 *  (e.g., had -book), or if we are using the
		 *  startfile and it has no POST content, make
		 *  the startfile URL a goto entry. - FM
		 */
		if (strcmp(startfile, newdoc.address) ||
		    newdoc.post_data == NULL)
		    HTAddGotoURL(startfile);
	    }
	    if (TRACE) {
		refresh_screen = TRUE;
		if (!LYTraceLogFP || trace_mode_flag) {
		    sleep(AlertSecs);
d4954 1
d4956 1
a4956 1
#ifdef SOURCE_CACHE
d4958 1
a4958 5
	 * If the parse settings have changed since this HText was
	 * generated, we need to reparse and redraw it.  -dsb
	 *
	 * Should be configured to avoid shock for experienced lynx users.
	 * Currently enabled for cached sources only.
d4960 19
a4978 14
	if (HTdocument_settings_changed()) {
	   if (HTcan_reparse_document()) {
	       HTUserMsg(gettext("Reparsing document under current settings..."));
	       if (HTreparse_document()) {}
	   } else {
		/*
		 * Urk.  I have no idea how to recover from a failure here.
		 * At a guess, I'll try reloading.  -dsb
		 */
			/*  currently disabled ***
		HTUserMsg(gettext("Reparsing document under current settings..."));
		cmd = LYK_RELOAD;
		goto new_cmd;
			*/
d4981 63
d5045 21
a5065 8
	/*
	 *  Trying to accomodate HTreparse_document() logic
	 *  with mainloop events.  Working out of force_load cycle
	 *  set all the necessary flags here, from case NORMAL
	 *  (see also LYK_SOURCE, some staff implemented directly there).
	 */
	if (from_source_cache) {
	    from_source_cache = FALSE; /* done */
d5067 17
a5083 5
	    /*
	     *	Make sure curdoc.line will not be equal
	     *	to Newline, so we get a redraw.
	     */
	    curdoc.line = -1;
d5085 4
d5090 176
d5267 8
d5276 7
d5284 7
a5290 7
	/*
	 *  If the curdoc.line is different than Newline then there must
	 *  have been a change since last update.  Run HText_pageDisplay()
	 *  create a fresh screen of text out.
	 *  All display_partial calls ends here for final redraw.
	 */
	if (curdoc.line != Newline) {
d5292 32
a5323 1
	    refresh_screen = FALSE;
d5325 2
a5326 1
	    HText_pageDisplay(Newline, prev_target);
d5328 4
a5331 4
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
	      showtags(tagged);
#endif /* DIRED_SUPPORT */
d5333 10
a5342 5
	    /*
	     *  If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();
	    curdoc.line = Newline = HText_getTopOfScreen()+1;
d5344 7
a5350 9
	    if (curdoc.title == NULL) {
		/*
		 *  If we don't yet have a title, try to get it,
		 *  or set to that for newdoc.title. - FM
		 */
		if (HText_getTitle()) {
		    StrAllocCopy(curdoc.title, HText_getTitle());
		} else {
		    StrAllocCopy(curdoc.title, newdoc.title);
d5352 1
a5352 3
	    }

	    if (arrowup) {
d5354 2
a5355 2
		 *  arrowup is set if we just came up from
		 *  a page below.
d5357 14
a5370 7
		curdoc.link = nlinks - 1;
		arrowup = FALSE;
	    } else {
		curdoc.link = newdoc.link;
		if (curdoc.link >= nlinks) {
		    curdoc.link = nlinks - 1;
		} else if (curdoc.link < 0 && nlinks > 0) {
d5372 2
a5373 3
		     *	We may have popped a doc (possibly in local_dired)
		     *	which didn't have any links when it was pushed, but
		     *	does have links now (e.g., a file was created) - KW
d5375 2
a5376 3
		    curdoc.link = 0;
		}
	    }
a5377 5
	    show_help = FALSE; /* reset */
	    newdoc.line = 1;
	    newdoc.link = 0;
	    curdoc.line = Newline; /* set */
	}
a5378 14
	/*
	 *  Refresh the screen if necessary.
	 */
	if (refresh_screen) {
#if defined(FANCY_CURSES) || defined (USE_SLANG)
	    if (enable_scrollback) {
		clear();
	    } else {
		erase();
	    }
#else
	    clear();
#endif /* FANCY_CURSES || USE_SLANG */
	    HText_pageDisplay(Newline, prev_target);
d5380 38
a5417 4
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
#endif /* DIRED_SUPPORT */
d5419 20
a5438 4
	    /*
	     *  If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();
d5440 12
a5451 3
	    if (user_mode == NOVICE_MODE)
		noviceline(more);  /* print help message */
	    refresh_screen = FALSE;
d5453 15
a5467 1
	}
d5469 10
a5478 5
	/*
	 *  Report unread or new mail, if appropriate.
	 */
	if (check_mail && !no_mail)
	    LYCheckMail();
d5480 6
a5485 10
	/*
	 *  If help is not on the screen,
	 *  then put a message on the screen
	 *  to tell the user other misc info.
	 */
	if (!show_help) {
	   print_status_message(links[curdoc.link], &cp);
	} else {
	   show_help = FALSE;
	}
d5487 16
a5502 8
	if (!(nlinks > 0 &&
	      links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	      (links[curdoc.link].form->type == F_TEXT_TYPE ||
	       links[curdoc.link].form->type == F_TEXTAREA_TYPE)))
	     /*
	      *  Highlight current link.
	      */
	    highlight(ON, curdoc.link, prev_target);
d5504 28
a5531 16
	if (traversal) {
	    /*
	     *	Don't go interactively into forms,
	     *	or accept keystrokes from the user
	     */
	    if (crawl && crawl_ok) {
		crawl_ok = FALSE;
#ifdef FNAMES_8_3
		sprintf(cfile,"lnk%05d.dat",ccount);
#else
		sprintf(cfile,"lnk%08d.dat",ccount);
#endif /* FNAMES_8_3 */
		ccount = ccount + 1;
		if ((cfp = LYNewTxtFile(cfile))  != NULL) {
		    print_crawl_to_fd(cfp,curdoc.address,curdoc.title);
		    fclose(cfp);
d5533 13
a5545 12
		    if (!dump_output_immediately)
			cleanup();
#ifdef UNIX
		    if (dump_output_immediately)
			fprintf(stderr,
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    else
#endif
			printf(
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    if (!dump_output_immediately) {
			exit_immediately(-1);
d5547 1
a5547 21
		    return(-1);
		}
	    }
	} else {
	    /*
	     *	Normal, non-traversal handling.
	     */
	    if (nlinks > 0 &&
		links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		(links[curdoc.link].form->type == F_TEXT_TYPE ||
		 links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE ||
		 links[curdoc.link].form->type == F_PASSWORD_TYPE ||
		 links[curdoc.link].form->type == F_TEXTAREA_TYPE)) {
		/*
		 *  Replace novice lines if in NOVICE_MODE.
		 */
		if (user_mode==NOVICE_MODE) {
		    move(LYlines-2,0); clrtoeol();
		    addstr(FORM_NOVICELINE_ONE);
		    move(LYlines-1,0); clrtoeol();
		    addstr(FORM_NOVICELINE_TWO);
d5549 9
a5557 4
		c = change_form_link(&links[curdoc.link],
				     &newdoc, &refresh_screen,
				     links[curdoc.link].form->name,
				     links[curdoc.link].form->value);
d5559 1
a5559 2
		if (c == '\n' || c == '\r') {
#ifdef AUTOGROW
d5561 2
a5562 12
		     *  If on the bottom line of a TEXTAREA, and the user hit
		     *  the ENTER key, we add a new line/anchor automatically,
		     *  positioning the cursor on it.
		     *
		     *  If at the bottom of the screen, we effectively perform
		     *  an LYK_DOWN_HALF-like operation, then move down to the
		     *  new line we just added.  --KED  02/14/99
		     *
		     *  [There is some redundancy and non-standard indentation
		     *   in the monster-if() below.  This is intentional ... to
		     *   try and improve the "readability" (such as it is).
		     *   Caveat emptor to anyone trying to change it.]
d5564 59
a5622 32
		    if ((links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
			 links[curdoc.link].form->type == F_TEXTAREA_TYPE)
			&&
			 ((curdoc.link == nlinks-1)
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  !(links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  ((links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE)
			    &&
			    ((links[curdoc.link].form->number	       !=
				      links[curdoc.link+1].form->number)     ||
			     (strcmp (links[curdoc.link].form->name,
				      links[curdoc.link+1].form->name) != 0)))))) {

			HText_ExpandTextarea (&links[curdoc.link], 1);

			if (links[curdoc.link].ly < display_lines) {
			    refresh_screen = TRUE;

			} else {

			    Newline += (display_lines/2);
			    if (nlinks > 0 && curdoc.link > -1 &&
				links[curdoc.link].ly > display_lines/2) {
				    newdoc.link = curdoc.link;
				    for (i = 0; links[i].ly <= (display_lines/2); i++)
					--newdoc.link;
				    newdoc.link++;
d5624 1
d5626 1
a5626 2
		   }
#endif /* AUTOGROW */
a5627 1
#ifdef FASTTAB
d5629 3
a5631 1
		     *	Make return act like down-arrow.
d5633 8
a5640 15
		    c = DNARROW;
#else
		    /*
		     *	Make return act like tab.
		     */
		    c = '\t';
#endif /* FASTTAB */
		}
	    } else {
		/*
		 *  Get a keystroke from the user.
		 *  Save the last keystroke to avoid
		 *  redundant error reporting.
		 */
		real_c = c = LYgetch(); /* get user input */
d5642 1
a5642 2
#ifndef VMS
		if (c == 3) {		/* ^C */
d5644 1
a5644 2
		     *	This shouldn't happen.	We'll try to
		     *	deal with whatever bug caused it. - FM
d5646 23
a5668 62
		    signal(SIGINT, cleanup_sig);
		    old_c = 0;
		    cmd = LYK_QUIT;
		    goto new_cmd;
		}
#endif /* !VMS */
		if (old_c != real_c) {
		    old_c = 0;
		}
	    }
	}

#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = DO_NOTHING;
	}
#else
	if (recent_sizechange) {
	    if (c <= 0)
		c = DO_NOTHING;
	}
#endif /* VMS */

new_keyboard_input:
	/*
	 *  A goto point for new input without going
	 *  back through the getch() loop.
	 */
	if (traversal) {
	    /*
	     *	This is a special feature to traverse every http link
	     *	derived from startfile and check for errors or create
	     *	crawl output files.  Only URL's that begin with
	     *	"traversal_host" are searched - this keeps the search
	     *	from crossing to other servers (a feature, not a bug!).
	     */
	    rlink_exists = (nlinks > 0 && links[curdoc.link].lname != NULL);
	    if (rlink_exists) {
		rlink_allowed =
		    (!lookup_reject(links[curdoc.link].lname) &&
		     traversal_host && links[curdoc.link].lname &&
		     !strncmp(traversal_host,
			      (strncmp(links[curdoc.link].lname,
				       "LYNXIMGMAP:", 11)
					 ?
		links[curdoc.link].lname : (links[curdoc.link].lname + 11)),
			      strlen(traversal_host)));
	    } else {
		rlink_allowed = FALSE;
	    }
	    if (rlink_exists && rlink_allowed) {
		if (lookup(links[curdoc.link].lname)) {
		    if (more_links ||
			(curdoc.link > -1 && curdoc.link < nlinks -1))
			 c= DNARROW;
		    else {
			if (STREQ(curdoc.title,"Entry into main screen") ||
			    (nhist <= 0 )) {
			    if (!dump_output_immediately) {
				cleanup();
				exit_immediately(-1);
d5670 1
a5670 1
			    return(-1);
a5671 1
			c = LTARROW;
a5672 14
		} else {
		    StrAllocCopy(traversal_link_to_add,
				 links[curdoc.link].lname);
		    if (strncmp(traversal_link_to_add, "LYNXIMGMAP:", 11))
			crawl_ok = TRUE;
		    c = RTARROW;
		}
	    } else { /* no good right link, so only down and left arrow ok*/
		if (rlink_exists)
		    add_to_reject_list(links[curdoc.link].lname);
		if (more_links ||
		    (curdoc.link > -1 && curdoc.link < nlinks-1))
		    c = DNARROW;
		else {
d5674 2
a5675 2
		     *	curdoc.title doesn't always work, so
		     *	bail out if the history list is empty.
d5677 27
a5703 5
		    if (STREQ(curdoc.title,"Entry into main screen") ||
			(nhist <= 0 )) {
			if (!dump_output_immediately) {
			    cleanup();
			    exit_immediately(-1);
a5704 1
			return(-1);
a5705 4
		    c = LTARROW;
		}
	    } /* right link not NULL or link to another site*/
	} /* traversal */
d5707 59
a5765 1
	cmd = keymap[c+1];  /* add 1 to map EOF to 0 */
d5767 7
a5773 53
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && key_override[c+1] && !no_dired_support)
	  cmd = key_override[c+1];
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

	real_cmd = cmd;

new_cmd:  /*
	   *  A goto point for new input without going
	   *  back through the getch() loop.
	   */

	CTRACE_FLUSH(tfp);

	switch(cmd) {
	case 0: /* unmapped character */
	default:
	    if (more)
		_statusline(MOREHELP);
	    else
		_statusline(HELP);
	    show_help = TRUE;

	    if (TRACE) {
		sprintf(cfile, "%d", c);
		addstr(cfile);	/* show the user input */
		cfile[0] = '\0';
	    }
	    break;

	case LYK_INTERRUPT:
	    /*
	     *	No network transmission to interrupt - 'til we multithread.
	     */
	    break;

	case LYK_F_LINK_NUM:
	     c = '\0';
	case LYK_1:
	case LYK_2:
	case LYK_3:
	case LYK_4:
	case LYK_5:
	case LYK_6:
	case LYK_7:
	case LYK_8:
	case LYK_9:
	{
	    /*
	     *	Get a number from the user and follow that link number.
	     */
	    int lindx = ((nlinks > 0) ? curdoc.link : 0);
	    int number;
d5775 23
a5797 25
	    /* pass cur line num for use in follow_link_number()
	     * Note: Current line may not equal links[cur].line
	     */
	    number = curdoc.line;
	    switch (follow_link_number(c, lindx, &newdoc, &number)) {
	    case DO_LINK_STUFF:
		/*
		 *  Follow a normal link.
		 */
		StrAllocCopy(newdoc.address, links[lindx].lname);
		StrAllocCopy(newdoc.title, links[lindx].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
		/*
		 *  For internal links, retain POST content if present.
		 *  If we are on the List Page, prevent pushing it on
		 *  the history stack.	Otherwise set try_internal to
		 *  signal that the top of the loop should attempt to
		 *  reposition directly, without calling getfile. - kw
		 */
		if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
		    LYinternal_flag = TRUE;
		    newdoc.internal_link = TRUE;
		    if (LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
			0==strcmp(HTLoadedDocumentURL(), LYlist_temp_url())) {
			if (!curdoc.post_data ||
d5799 6
a5804 2
			     *	Normal case - List Page is not associated
			     *	with post data. - kw
d5806 15
a5820 43
			    (!LYresubmit_posts && curdoc.post_data &&
			     history[nhist - 1].post_data &&
			     !strcmp(curdoc.post_data,
				     history[nhist - 1].post_data) &&
			     HText_getContentBase() &&
			     !strncmp(HText_getContentBase(),
				      strncmp(history[nhist - 1].address,
					      "LYNXIMGMAP:", 11) ?
				      history[nhist - 1].address :
				      history[nhist - 1].address + 11,
				      strlen(HText_getContentBase())))) {
			    /*
			     *	Normal case - as best as we can check, the
			     *	document at the top of the history stack
			     *	seems to be the document the List Page is
			     *	about (or a LYNXIMGMAP derived from it),
			     *	and LYresubmit_posts is not set, so don't
			     *	prompt here.  If we actually have to repeat
			     *	a POST because, against expectations, the
			     *	underlying document isn't cached any more,
			     *	HTAccess will prompt for confirmation,
			     *	unless we had LYK_NOCACHE. - kw
			     */
			    LYinternal_flag = TRUE;
			} else {
			    HTLastConfirmCancelled(); /* reset flag */
			    if (!confirm_post_resub(newdoc.address,
						    newdoc.title,
						    (LYresubmit_posts &&
						     HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
						    2)) {
				if (HTLastConfirmCancelled() ||
				    (LYresubmit_posts &&
				     !HText_POSTReplyLoaded(&newdoc))) {
				    /* cancel the whole thing */
				    LYforce_no_cache = FALSE;
				    reloading = FALSE;
				    StrAllocCopy(newdoc.address, curdoc.address);
				    StrAllocCopy(newdoc.title, curdoc.title);
				    newdoc.internal_link = curdoc.internal_link;
				    HTInfoMsg(CANCELLED);
				    if (nlinks > 0)
					HText_pageDisplay(curdoc.line, prev_target);
d5822 38
a5859 15
				} else if (LYresubmit_posts) {
				    /* If LYresubmit_posts is set, and the
				       answer was No, and we have a cached
				       copy, then use it. - kw */
				    LYforce_no_cache = FALSE;
				} else {
				    /* if No, but not ^C or ^G, drop
				     * the post data.  Maybe the link
				     * wasn't meant to be internal after
				     * all, here we can recover from that
				     * assumption. - kw */
				    FREE(newdoc.post_data);
				    FREE(newdoc.post_content_type);
				    newdoc.internal_link = FALSE;
				    HTAlert(DISCARDING_POST_DATA);
d5863 5
d5869 3
a5871 2
			 *  Don't push the List Page if we follow an
			 *  internal link given by it. - kw
d5873 1
a5873 42
			FREE(curdoc.address);
		    } else
			try_internal = TRUE;
		    if (!(LYresubmit_posts && newdoc.post_data))
			LYinternal_flag = TRUE;
		    force_load = TRUE;
		    break;
		} else {
		    /*
		     *	Free POST content if not an internal link. - kw
		     */
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		}
#endif /* DONT_TRACK_INTERNAL_LINKS */
		/*
		 *  Might be an anchor in the same doc from a POST
		 *  form.  If so, don't free the content. -- FM
		 */
		if (are_different(&curdoc, &newdoc)) {
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		}
		newdoc.internal_link = FALSE;
		force_load = TRUE;  /* force MainLoop to reload */
		break;

	    case DO_GOTOLINK_STUFF:
		/*
		 *  Position on a normal link, don't follow it. - KW
		 */
		Newline = newdoc.line;
		newdoc.line = 1;
		if (Newline == curdoc.line) {
		    /*
		     *	It's a link in the current page. - FM
		     */
		    if (nlinks > 0 && curdoc.link > -1) {
			if (curdoc.link == newdoc.link) {
d5875 1
a5875 4
			     *	It's the current link, and presumably
			     *	reflects a typo in the statusline entry,
			     *	so issue a statusline message for the
			     *	typo-prone users (like me 8-). - FM
d5877 6
a5882 7
			    StrAllocCopy(temp, user_input_buffer);
			    sprintf(user_input_buffer,
				    LINK_ALREADY_CURRENT, number);
			    HTUserMsg(user_input_buffer);
			    strcpy(user_input_buffer, temp);
			    FREE(temp);
			} else {
d5884 1
a5884 5
			     *	It's a different link on this page,
			     *	so turn the highlighting off, set the
			     *	current link to the new link value from
			     *	follow_link_number(), and re-initialize
			     *	the new link value. - FM
d5886 1
a5886 4
			    highlight(OFF, curdoc.link, prev_target);
			    curdoc.link = newdoc.link;
			    newdoc.link = 0;
			}
a5887 2
		}
		break;		/* nothing more to do */
a5888 7
	    case DO_GOTOPAGE_STUFF:
		/*
		 *  Position on a page in this document. - FM
		 */
		Newline = newdoc.line;
		newdoc.line = 1;
		if (Newline == curdoc.line) {
d5890 3
a5892 3
		     *	It's the current page, so issue a
		     *	statusline message for the typo-prone
		     *	users (like me 8-). - FM
d5894 9
a5902 11
		    if (Newline <= 1) {
			HTInfoMsg(ALREADY_AT_BEGIN);
		    } else if (!more) {
			HTInfoMsg(ALREADY_AT_END);
		    } else {
			StrAllocCopy(temp, user_input_buffer);
			sprintf(user_input_buffer,
				ALREADY_AT_PAGE, number);
			HTUserMsg(user_input_buffer);
			strcpy(user_input_buffer, temp);
			FREE(temp);
a5903 2
		}
		break;
d5905 17
a5921 35
	    case PRINT_ERROR:
		old_c = real_c;
		HTUserMsg(BAD_LINK_NUM_ENTERED);
		break;
	    }
	    break;
	}

	case LYK_SOURCE:  /* toggle view source mode */
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation if the safe element is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, curdoc.title,
				   1, 1) == FALSE) {
		HTInfoMsg(CANCELLED);
		break;
	    }

	    if (HTisDocumentSource()) {
		HTOutputFormat = WWW_PRESENT;
#ifdef USE_PSRC
		psrc_view = FALSE;
#endif
	    } else {
		if (HText_getOwner())
		    StrAllocCopy(ownerS_address, HText_getOwner());
		LYUCPushAssumed(HTMainAnchor);
#ifdef USE_PSRC
		if (LYpsrc)
		    psrc_view = TRUE;
		else
		    HTOutputFormat = WWW_SOURCE;
d5923 5
a5927 1
		HTOutputFormat = WWW_SOURCE;
a5928 1
	    }
d5930 7
a5936 16
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
			/*
			 * These normally get cleaned up after getfile() returns;
			 * since we're not calling getfile(), we have to clean them
			 * up ourselves.  -dsb
			 */
			HTOutputFormat = WWW_PRESENT;
#ifdef USE_PSRC
			if (psrc_view)
				HTMark_asSource();
			psrc_view = FALSE;
#endif
			FREE(ownerS_address);   /* not used with source_cache */
			LYUCPopAssumed();  		/* probably a right place here */
			HTMLSetCharacterHandling(current_char_set);  /* restore now */
d5938 7
a5944 3
			break;
	    }
#endif
d5946 3
a5948 130
	    FREE(curdoc.address); /* so it doesn't get pushed */
	    LYforce_no_cache = TRUE;
	    break;

	case LYK_RELOAD:  /* control-R to reload and refresh */
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation if the safe element is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
		HTInfoMsg(CANCELLED);
		break;
	    }

	    /*
	     *	Check to see if should reload source, or load html
	     */

	    if (HTisDocumentSource()) {
		force_old_UCLYhndl_on_reload = TRUE;
		forced_UCLYhdnl = HTMainText_Get_UCLYhndl();
#ifndef USE_PSRC
		HTOutputFormat = WWW_SOURCE;
#else
		if (LYpsrc)
		    psrc_view = TRUE;
		else
		    HTOutputFormat = WWW_SOURCE;
#endif
	    }

	    HEAD_request = HTLoadedDocumentIsHEAD();
	    HTuncache_current_document();
#ifdef NO_ASSUME_SAME_DOC
	    /*
	     *	Don't assume the reloaded document will be the same. - FM
	     */
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    /*
	     *	Do assume the reloaded document will be the same. - FM
	     *	(I don't remember all the reasons why we couldn't assume
	     *	 this.	As the problems show up, we'll try to fix them,
	     *	 or add warnings.  - FM)
	     */
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
	    FREE(curdoc.address); /* so it doesn't get pushed */
#ifdef VMS
	    lynx_force_repaint();
#endif /* VMS */
	    /*
	     *	Reload should force a cache refresh on a proxy.
	     *	      -- Ari L. <luotonen@@dxcern.cern.ch>
	     *
	     *	-- but only if this was really a reload requested by
	     *	the user, not if we jumped here to handle reloading for
	     *	INLINE_TOGGLE, IMAGE_TOGGLE, RAW_TOGGLE, etc. - KW
	     */
	    if (real_cmd == LYK_RELOAD)
		reloading = TRUE;
	    break;

	case LYK_HISTORICAL:	/* toggle 'historical' comments parsing */
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation of reload if the safe element
	     *	is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL,
				   0, 0) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
#endif
	    if (historical_comments)
		historical_comments = FALSE;
	    else
		historical_comments = TRUE;
	    if (minimal_comments) {
		HTAlert(historical_comments ?
			HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
	    } else {
		HTAlert(historical_comments ?
			HISTORICAL_ON_VALID_OFF : HISTORICAL_OFF_VALID_ON);
	    }
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break; /* OK */
	    }
#endif
	    break;

	case LYK_MINIMAL:	/* toggle 'minimal' comments parsing */
	    if (!historical_comments) {
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
		/*
		 *  Check if this is a reply from a POST, and if so,
		 *  seek confirmation of reload if the safe element
		 *  is not set. - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    confirm_post_resub(curdoc.address, NULL,
				       0, 0) == FALSE) {
		    HTInfoMsg(WILL_NOT_RELOAD_DOC);
		} else {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    FREE(curdoc.address);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
a5950 20
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
#endif
	    if (minimal_comments)
		minimal_comments = FALSE;
	    else
		minimal_comments = TRUE;
	    if (!historical_comments) {
		HTAlert(minimal_comments ?
			MINIMAL_ON_IN_EFFECT : MINIMAL_OFF_VALID_ON);
	    } else {
		HTAlert(minimal_comments ?
			MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
	    }
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break; /* OK */
	    }
#endif
	    break;
a5951 4
	case LYK_SOFT_DQUOTES:
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
d5953 1
a5953 3
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation of reload if the safe element
	     *	is not set. - FM
d5955 8
a5962 14
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL,
				   1, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
d5964 2
a5965 12
	    if (soft_dquotes)
		soft_dquotes = FALSE;
	    else
		soft_dquotes = TRUE;
	    HTUserMsg(soft_dquotes ?
		      SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break; /* OK */
	    }
#endif
	    break;
a5966 4
	case LYK_SWITCH_DTD:
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
d5968 2
a5969 3
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation of reload if the safe element
	     *	is not set. - FM, kw
d5971 3
a5973 31
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL,
				   1, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		/*
		 *  If currently viewing preparsed source, switching
		 *  to the other DTD parsing may show source differences,
		 *  so stay in source view - kw
		 */

		/* NOTE: this conditional can be considered incorrect -
		   current behaviour - when viewing source and
		   LYPreparsedSource==TRUE, pressing ^V will toggle parser mode
		   AND switch back from the source view to presentation view.-HV
		*/
		if (HTisDocumentSource() && LYPreparsedSource) {
#ifdef USE_PSRC
		    if (LYpsrc)
			psrc_view = TRUE;
		    else
#endif
		    HTOutputFormat = WWW_SOURCE;
		}
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
#ifdef NO_ASSUME_SAME_DOC
		newdoc.line = 1;
		newdoc.link = 0;
d5975 2
a5976 6
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
	    }
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
d5978 2
a5979 12
	    Old_DTD = !Old_DTD;
	    HTSwitchDTD(!Old_DTD);
	    HTUserMsg(Old_DTD ? USING_DTD_0 : USING_DTD_1);
#ifdef SOURCE_CACHE
	    if (HTcan_reparse_document()) {
	    if (HTisDocumentSource() && LYPreparsedSource) {
#ifdef USE_PSRC
		if (LYpsrc)
		    psrc_view = TRUE;
		else
#endif
		HTOutputFormat = WWW_SOURCE;
d5981 4
a5984 2
	    if (HTreparse_document()) {
		break;
d5986 4
a5989 26
	    } /* end if no bypass */
#endif
	    break;

#ifdef NOT_DONE_YET
	case LYK_PIPE:
	    /* ignore for now */
	    break;
#endif /* NOT_DONE_YET */

	case LYK_QUIT:	/* quit */
	    if (LYQuitDefaultYes == TRUE) {
		c = HTConfirmDefault(REALLY_QUIT_Y, YES);
	    } else {
		c = HTConfirmDefault(REALLY_QUIT_N, NO);
	    }
	    if (LYQuitDefaultYes == TRUE) {
		if (c != NO) {
		    return(0);
		} else {
		    HTInfoMsg(NO_CANCEL);
		}
	    } else if (c == YES) {
		return(0);
	    } else {
		HTInfoMsg(NO_CANCEL);
a5990 1
	    break;
a5991 2
	case LYK_ABORT:		/* don't ask the user about quitting */
	    return(0);
d5993 8
a6000 11
	case LYK_NEXT_PAGE:	/* next page */
	    if (more) {
		Newline += display_lines;
	    } else if (curdoc.link < nlinks-1) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nlinks-1;  /* put on last link */
	    } else if (old_c != real_c) {
		   old_c = real_c;
		   HTInfoMsg(ALREADY_AT_END);
	    }
	    break;
d6002 1
a6002 11
	case LYK_PREV_PAGE:  /* page up */
	    if (Newline > 1) {
		Newline -= display_lines;
	    } else if (curdoc.link > 0) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;  /* put on first link */
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;
d6004 14
a6017 18
	case  LYK_UP_TWO:
	    if (Newline > 1) {
		int scrollamount = (Newline > 2 ? 2 : 1);
		Newline -= scrollamount;
		if (nlinks > 0 && curdoc.link > -1) {
		    if (links[curdoc.link].ly + scrollamount <= display_lines) {
			newdoc.link = curdoc.link +
				      HText_LinksInLines(HTMainText,
							 Newline, scrollamount);
		    } else {
			arrowup = TRUE;
		    }
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;
d6019 1
a6019 14
	case  LYK_DOWN_TWO:
	    if (more) {
		Newline += 2;
		if (nlinks > 0 && curdoc.link > -1 &&
		    links[curdoc.link].ly > 2) {
		    newdoc.link = curdoc.link;
		    for (i = 0; links[i].ly <= 2; i++)
			--newdoc.link;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
	    }
	    break;
d6021 3
a6023 55
	case  LYK_UP_HALF:
	    if (Newline > 1) {
		int scrollamount = display_lines/2;
		if (Newline - scrollamount < 1)
		    scrollamount = Newline - 1;
		Newline -= scrollamount;
		if (nlinks > 0 && curdoc.link > -1) {
		    if (links[curdoc.link].ly + scrollamount <= display_lines) {
			newdoc.link = curdoc.link +
				      HText_LinksInLines(HTMainText,
							 Newline,
							 scrollamount);
		    } else {
			arrowup = TRUE;
		    }
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;

	case  LYK_DOWN_HALF:
	    if (more) {
		Newline += (display_lines/2);
		if (nlinks > 0 && curdoc.link > -1 &&
		    links[curdoc.link].ly > display_lines/2) {
		    newdoc.link = curdoc.link;
		    for (i = 0; links[i].ly <= (display_lines/2); i++)
			--newdoc.link;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
	    }
	    break;

	case LYK_REFRESH:
	   refresh_screen = TRUE;
	   lynx_force_repaint();
	   break;

	case LYK_HOME:
	    if (curdoc.line > 1)
		Newline = 1;
	    else {
		cmd = LYK_PREV_PAGE;
		goto new_cmd;
	    }
	    break;

	case LYK_END:
	    if (more) {
	       Newline = HText_getNumOfLines() - display_lines + 3;  /* go to end of file */
	       arrowup = TRUE;	 /* position on last link */
d6025 1
a6025 2
		cmd = LYK_NEXT_PAGE;
		goto new_cmd;
d6027 2
a6028 1
	    break;
d6030 28
a6057 64
	case LYK_PREV_LINK:
	    if (curdoc.link > 0) {	     /* previous link */
		/*
		 *  Unhighlight current link.
		 */
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link--;

	    } else if (!more &&
		       curdoc.link==0 && Newline==1) { /* at the top of list */
		/*
		 *  If there is only one page of data and the user
		 *  goes off the top, then unhighlight the current
		 *  link and just move the cursor to last link on
		 *  the page.
		 */
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nlinks-1;  /* the last link */

	    } else if (curdoc.line > 1) {	/* previous page */
		/*
		 *  Go back to the previous page.
		 */
		int scrollamount = (Newline > display_lines ?
					      display_lines : Newline - 1);
		Newline -= scrollamount;
		if (scrollamount < display_lines &&
		    nlinks > 0 && curdoc.link == 0 &&
		    links[0].ly - 1 + scrollamount <= display_lines) {
			newdoc.link = HText_LinksInLines(HTMainText,
							 1,
							 scrollamount) - 1;
		} else {
		    arrowup = TRUE;
		}

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;

	case LYK_NEXT_LINK:
	    if (curdoc.link < nlinks-1) {	/* next link */
		highlight(OFF, curdoc.link, prev_target);
#ifdef FASTTAB
		/*
		 *  Move to different textarea if TAB in textarea.
		 */
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
		    c=='\t') {
		    int thisgroup = links[curdoc.link].form->number;
		    char *thisname = links[curdoc.link].form->name;

		    do curdoc.link++;
		    while ((curdoc.link < nlinks-1) &&
			   links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			   links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
			   links[curdoc.link].form->number == thisgroup &&
			   sametext(links[curdoc.link].form->name, thisname));
		} else {
		    curdoc.link++;
		}
d6059 13
a6071 80
		curdoc.link++;
#endif /* FASTTAB */
	    /*
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
	     */
	    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;

	    } else if (more) {	/* next page */
		 Newline += (display_lines);

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
	    }
	    break;

	case LYK_FASTFORW_LINK:
	{
	    int samepage = 0, nextlink = curdoc.link;
	    if (nlinks > 1) {

		/*
		 *  If in textarea, move to first link or field
		 *  after it if there is one on this screen. - kw
		 */
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
		    int thisgroup = links[curdoc.link].form->number;
		    char *thisname = links[curdoc.link].form->name;

		    if (curdoc.link < nlinks-1 &&
			!(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
			  links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
			  links[nlinks-1].form->number == thisgroup &&
			  sametext(links[nlinks-1].form->name, thisname))) {
			do nextlink++;
			while
			    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
			     links[nextlink].form->type == F_TEXTAREA_TYPE &&
			     links[nextlink].form->number == thisgroup &&
			     sametext(links[nextlink].form->name, thisname));
			samepage = 1;
		    } else if (!more && Newline == 1 && curdoc.link > 0) {
			nextlink = 0;
			samepage = 1;
		    }
		} else if (curdoc.link < nlinks-1) {
		    nextlink++;
		    samepage = 1;
		} else if (!more && Newline == 1 && curdoc.link > 0) {
		    nextlink = 0;
		    samepage = 1;
		}
	    }
	    if (samepage) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nextlink;
		break;		/* and we are done. */

	    /*
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
	     */
	    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;

	    } else if (more &&	/* need a later page */
		       HTGetLinkOrFieldStart(curdoc.link,
					     &Newline, &newdoc.link,
					     1, TRUE) != NO) {
		Newline++;	/* our line counting starts with 1 not 0 */
		/* nothing more to do here */

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(NO_LINKS_BELOW);
a6072 1
	    break;
a6073 98
	case LYK_FASTBACKW_LINK:
	{
	    int samepage = 0, nextlink = curdoc.link;
	    int res;
	    if (nlinks > 1) {

		/*
		 *  If in textarea, move to first link or textarea group
		 *  before it if there is one on this screen. - kw
		 */
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
		    int thisgroup = links[curdoc.link].form->number;
		    char *thisname = links[curdoc.link].form->name;

		    if (curdoc.link > 0 &&
			!(links[0].type == WWW_FORM_LINK_TYPE &&
			  links[0].form->type == F_TEXTAREA_TYPE &&
			  links[0].form->number == thisgroup &&
			  sametext(links[0].form->name, thisname))) {
			do nextlink--;
			while
			    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
			     links[nextlink].form->type == F_TEXTAREA_TYPE &&
			     links[nextlink].form->number == thisgroup &&
			     sametext(links[nextlink].form->name, thisname));
			samepage = 1;

		    } else if (!more && Newline == 1 &&
			       (links[0].type == WWW_FORM_LINK_TYPE &&
				links[0].form->type == F_TEXTAREA_TYPE &&
				links[0].form->number == thisgroup &&
				sametext(links[0].form->name, thisname)) &&
			       !(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
				 links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
				 links[nlinks-1].form->number == thisgroup &&
				 sametext(links[nlinks-1].form->name, thisname))) {
			nextlink = nlinks - 1;
			samepage = 1;

		    } else if (!more && Newline == 1 && curdoc.link > 0) {
			nextlink = 0;
			samepage = 1;
		    }
		} else if (curdoc.link > 0) {
		    nextlink--;
		    samepage = 1;
		} else if (!more && Newline == 1) {
		    nextlink = nlinks - 1;
		    samepage = 1;
		}
	    }
	    if (samepage) {
		/*
		 *  If the link as determined so far is part of a
		 *  group of textarea fields, try to use the first
		 *  of them that's on the screen instead. - kw
		 */
		if (nextlink > 0 &&
		    links[nextlink].type == WWW_FORM_LINK_TYPE &&
		    links[nextlink].form->type == F_TEXTAREA_TYPE) {
		    int thisgroup = links[nextlink].form->number;
		    char *thisname = links[nextlink].form->name;
		    if (links[0].type == WWW_FORM_LINK_TYPE &&
			links[0].form->type == F_TEXTAREA_TYPE &&
			links[0].form->number == thisgroup &&
			sametext(links[0].form->name, thisname)) {
			nextlink = 0;
		    } else
			while
			    (nextlink > 1 &&
			     links[nextlink-1].type == WWW_FORM_LINK_TYPE &&
			     links[nextlink-1].form->type == F_TEXTAREA_TYPE &&
			     links[nextlink-1].form->number == thisgroup &&
			     sametext(links[nextlink-1].form->name, thisname)) {
			    nextlink--;
			}
		}
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nextlink;
		break;		/* and we are done. */

	    } else if (Newline > 1 &&	/* need a previous page */
		       (res = HTGetLinkOrFieldStart(curdoc.link,
						    &Newline, &newdoc.link,
						    -1, TRUE)) != NO) {
		if (res == LINK_DO_ARROWUP) {
		    /*
		     *  It says we should use the normal PREV_LINK
		     *  mechanism, so we'll do that. - kw
		     */
		    if (nlinks > 0)
			curdoc.link = 0;
		    cmd = LYK_PREV_LINK;
		    goto new_cmd;
		}
		Newline++;	/* our line counting starts with 1 not 0 */
		/* nothing more to do here */
d6075 7
a6081 5
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(NO_LINKS_ABOVE);
	    }
	    break;
d6084 1
a6084 85
	case LYK_UP_LINK:
	    if (curdoc.link > 0 &&
		(links[0].ly != links[curdoc.link].ly ||
		 !HText_LinksInLines(HTMainText, 1, Newline - 1))) {
		/* more links before this on screen, and first of them on
		   a different line or no previous links before this screen? */
		int newlink = -1;
		for (i = curdoc.link; i >= 0; i--) {
		    if (links[i].ly < links[curdoc.link].ly) {
			newlink = i;
			break;
		    }
		}
		if (newlink > -1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = newlink;
#ifdef NOTDEFINED
		} else if (!more && Newline == 1 && curdoc.link == 0) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = (nlinks-1);
		} else if (more) {  /* next page */
			Newline += (display_lines);
#else
		} else if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_LINKS_ABOVE);
#endif /* NOTDEFINED */
		}

#ifdef NOTDEFINED
	    /*
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
	     */
	    } else if (!more && Newline == 1 && curdoc.link == (nlinks-1)) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;
#endif /* NOTDEFINED */

	    } else if (curdoc.line > 1 && Newline > 1) {  /* previous page */
		int scrollamount = (Newline > display_lines ?
					      display_lines : Newline - 1);
		Newline -= scrollamount;
		if (scrollamount < display_lines &&
		    nlinks > 0 && curdoc.link > -1 &&
		    links[0].ly -1 + scrollamount <= display_lines) {
			newdoc.link = HText_LinksInLines(HTMainText,
							 1,
							 scrollamount) - 1;
		} else {
		    arrowup = TRUE;
		}

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;

	case LYK_DOWN_LINK:
	    if (curdoc.link < (nlinks-1)) {	/* more links? */
		int newlink = -1;
		for (i = curdoc.link; i < nlinks; i++)
		   if (links[i].ly > links[curdoc.link].ly) {
			newlink = i;
			break;
		   }

		if (newlink > -1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = newlink;
#ifdef NOTDEFINED
		} else if (!more &&
			   Newline == 1 && curdoc.link == (nlinks-1)) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = 0;
#endif /* NOTDEFINED */
		} else if (more) {  /* next page */
			Newline += (display_lines);
		} else if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_LINKS_BELOW);
		    break;
		}
#ifdef NOTDEFINED
d6086 1
a6086 2
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
d6088 1
a6088 32
	    } else if (!more && Newline == 1 && curdoc.link == (nlinks-1)) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;
#endif /* NOTDEFINED */
	    } else if (more) {	/* next page */
		    Newline += (display_lines);

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
	    }
	    break;

	case LYK_CHANGE_LINK:
	    do_change_link(prev_target);
	    break;

	case LYK_RIGHT_LINK:
	    if (curdoc.link<nlinks-1 &&
			links[curdoc.link].ly == links[curdoc.link+1].ly) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link++;
	    }
	    break;

	case LYK_LEFT_LINK:
	    if (curdoc.link>0 &&
			links[curdoc.link].ly == links[curdoc.link-1].ly) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link--;
	    }
	    break;
a6089 1
	case LYK_COOKIE_JAR:	   /* show the cookie jar */
d6091 3
a6093 1
	     *	Don't do if already viewing the cookie jar.
d6095 39
a6133 12
	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       COOKIE_JAR_TITLE)) {
		StrAllocCopy(newdoc.address, "LYNXCOOKIE:/");
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		LYforce_no_cache = TRUE;
		if (LYValidate || check_realm) {
		    LYPermitURL = TRUE;
a6134 6
	    } else {
		/*
		 *  If already in the cookie jar, get out.
		 */
		cmd = LYK_PREV_DOC;
		goto new_cmd;
d6136 3
a6138 4
	    break;

	case LYK_HISTORY:	/* show the history page */
	    if (curdoc.title && strcmp(curdoc.title, HISTORY_PAGE_TITLE)) {
d6140 1
a6140 5
		 *  Don't do this if already viewing history page.
		 *
		 *  Push the current file so that the history list
		 *  contains the current file for printing purposes.
		 *  Pop the file afterwards to prevent multiple copies.
d6142 4
a6145 6
		if (TRACE && !LYUseTraceLog && LYCursesON) {
		    move(LYlines-1, LYcols-1);	/* make sure cursor is down */
#ifdef USE_SLANG
		    addstr("\n");
#endif /* USE_SLANG */
		    refresh();
a6146 2
		LYpush(&curdoc, ForcePush);

d6148 1
a6148 1
		 *  Print history options to file.
d6150 10
a6159 98
		if (showhistory(&newdoc.address) < 0) {
		    LYpop(&curdoc);
		    break;
		}
		StrAllocCopy(newdoc.title, HISTORY_PAGE_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		newdoc.link = 1; /*@@@@@@ bypass "recent statusline messages" link */
		FREE(curdoc.address);  /* so it doesn't get pushed */

		refresh_screen = TRUE;
		if (LYValidate || check_realm) {
		    LYPermitURL = TRUE;
		}
		break;
	    } /* end if strncmp */
	    /*
	     *	Don't put break here so that if the backspace key
	     *	is pressed in the history page, we fall though,
	     *	i.e., it acts like a left arrow.
	     */

	case LYK_PREV_DOC:			 /* back up a level */
	    if (nhist > 0) {  /* if there is anything to go back to */
		/*
		 *  Check if the previous document is a reply from a POST,
		 *  and if so, seek confirmation of resubmission if the safe
		 *  element is not set and the document is not still in the
		 *  cache or LYresubmit_posts is set.  If not confirmed and
		 *  it is not the startfile, pop it so we go to the yet
		 *  previous document, until we're OK or reach the startfile.
		 *  If we reach the startfile and its not OK or we don't get
		 *  confirmation, cancel. - FM
		 */
		DocAddress WWWDoc;
		HTParentAnchor *tmpanchor;
		HText *text;
		BOOLEAN conf = FALSE, first = TRUE;

		HTLastConfirmCancelled(); /* reset flag */
		while (nhist > 0) {
		    conf = FALSE;
		    if (history[(nhist - 1)].post_data == NULL) {
			break;
		    }
		    WWWDoc.address = history[(nhist - 1)].address;
		    WWWDoc.post_data = history[(nhist - 1)].post_data;
		    WWWDoc.post_content_type =
				       history[(nhist - 1)].post_content_type;
		    WWWDoc.bookmark = history[(nhist - 1)].bookmark;
		    WWWDoc.isHEAD = history[(nhist - 1)].isHEAD;
		    WWWDoc.safe = history[(nhist - 1)].safe;
		    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
		    if (HTAnchor_safe(tmpanchor)) {
			break;
		    }
		    if (((text =
			  (HText *)HTAnchor_document(tmpanchor)) == NULL &&
			 (!strncmp(WWWDoc.address, "LYNXIMGMAP:", 11) ||
			 (conf = confirm_post_resub(WWWDoc.address,
						    history[(nhist - 1)].title,
						    0, 0))
			  == FALSE)) ||
			((LYresubmit_posts && !conf &&
			  (NONINTERNAL_OR_PHYS_DIFFERENT(
			      (document *)&history[(nhist - 1)],
			      &curdoc) ||
			   NONINTERNAL_OR_PHYS_DIFFERENT(
			       (document *)&history[(nhist - 1)],
			       &newdoc))) &&
			 !confirm_post_resub(WWWDoc.address,
					     history[(nhist - 1)].title,
					     2, 2))) {
			if (HTLastConfirmCancelled()) {
			    if (!first && curdoc.internal_link)
				FREE(curdoc.address);
			    cmd = LYK_DO_NOTHING;
			    goto new_cmd;
			}
			if (nhist == 1) {
			    HTInfoMsg(CANCELLED);
			    old_c = 0;
			    cmd = LYK_DO_NOTHING;
			    goto new_cmd;
			} else {
			    HTUserMsg2(WWW_SKIP_MESSAGE, WWWDoc.address);
			    do {
				LYpop(&curdoc);
			    } while (nhist > 1 && !are_different(
				(document *)&history[(nhist - 1)],
				&curdoc));
			    first = FALSE; /* have popped at least one */
			    continue;
			}
d6161 2
a6162 9
			/*
			 *  Break from loop; if user just confirmed to
			 *  load again because document wasn't in cache,
			 *  set LYforce_no_cache to avoid unnecessary
			 *  repeat question down the road. - kw
			 */
			if (conf)
			    LYforce_no_cache = TRUE;
			break;
d6164 1
d6166 10
a6175 4

		if (!first)
		    curdoc.internal_link = FALSE;

d6177 4
a6180 1
		 *  Set newdoc.address to empty to pop a file.
d6182 3
a6184 11
		FREE(newdoc.address);
#ifdef DIRED_SUPPORT
		if (lynx_edit_mode)
		    HTuncache_current_document();
#endif /* DIRED_SUPPORT */
	    } else if (child_lynx == TRUE) {
		return(0); /* exit on left arrow in main screen */

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTUserMsg(ALREADY_AT_FIRST);
d6186 4
a6189 15
	    break;

	case LYK_NOCACHE: /* Force submission of form or link with no-cache */
	    if (nlinks > 0) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type != F_SUBMIT_TYPE &&
		    links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE) {
		    if (old_c == real_c)
			break;
		    old_c = real_c;
		    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
		    break;
		} else {
		    LYforce_no_cache = TRUE;
		    reloading = TRUE;
d6191 2
a6192 1
	    } /* fall through to LYK_ACTIVATE */
d6194 13
a6206 240
	case LYK_ACTIVATE:			/* follow a link */
	    {
	     /* Is there a mouse-clicked link waiting? */
	     int mouse_tmp = get_mouse_link();
	     /* If yes, use it as the link */
	     if (mouse_tmp != -1) curdoc.link = mouse_tmp;
	    }
	     if (nlinks > 0) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
		    /*
		     *	Don't try to submit forms with bad actions. - FM
		     */
		    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
			links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
			links[curdoc.link].form->type ==
						    F_TEXT_SUBMIT_TYPE) {
			/*
			 *  Do nothing if it's disabled. - FM
			 */
			if (links[curdoc.link].form->disabled == YES) {
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Make sure we have an action. - FM
			 */
			if (!links[curdoc.link].form->submit_action ||
			    *links[curdoc.link].form->submit_action
								== '\0') {
			    HTUserMsg(NO_FORM_ACTION);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Check for no_mail if the form action
			 *  is a mailto URL. - FM
			 */
			if (links[curdoc.link].form->submit_method
				     == URL_MAIL_METHOD && no_mail) {
			    HTAlert(FORM_MAILTO_DISALLOWED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Make sure this isn't a spoof in an account
			 *  with restrictions on file URLs. - FM
			 */
			if (no_file_url &&
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "file:", 5)) {
			    HTAlert(FILE_ACTIONS_DISALLOWED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Make sure this isn't a spoof attempt
			 *  via an internal URL. - FM
			 */
			if (!strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXCOOKIE:", 11) ||
#ifdef DIRED_SUPPORT
#ifdef OK_PERMIT
			    (!(strncasecomp(
				    links[curdoc.link].form->submit_action,
					   "LYNXDIRED:", 10)) &&
			     (no_dired_support ||
			      strncasecomp(
				(links[curdoc.link].form->submit_action + 10),
					   "//PERMIT_LOCATION", 17) ||
			      strcmp(curdoc.address, LYPermitFileURL) ||
			      strcmp((curdoc.title ? curdoc.title : ""),
				     PERMIT_OPTIONS_TITLE)))  ||
#else
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXDIRED:", 10) ||
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXDOWNLOAD:", 13) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXHIST:", 9) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXKEYMAP:", 11) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXIMGMAP:", 11) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXPRINT:", 10) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "lynxexec:", 9) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "lynxprog:", 9)) {
			    HTAlert(SPECIAL_ACTION_DISALLOWED);
			    CTRACE(tfp, "LYMainLoop: Rejected '%s'\n",
					links[curdoc.link].form->submit_action);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
#ifdef NOTDEFINED /* We're disabling form inputs instead of using this. - FM */
			/*
			 *  Check for enctype and let user know we
			 *  don't yet support multipart/form-data - FM
			 */
			if (links[curdoc.link].form->submit_enctype) {
			    if (!strcmp(
				     links[curdoc.link].form->submit_enctype,
					"multipart/form-data")) {
				HTAlert(
	gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
				HTOutputFormat = WWW_PRESENT;
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				break;
			    }
			}
#endif /* NOTDEFINED */
			if (check_realm) {
			    LYPermitURL = TRUE;
			}
			if (no_filereferer == TRUE &&
			    !strncmp(curdoc.address, "file:", 5)) {
			    LYNoRefererForThis = TRUE;
			}
			StrAllocCopy(newdoc.title,
				     links[curdoc.link].hightext);
		    }
		    c = change_form_link(&links[curdoc.link],
					 &newdoc, &refresh_screen,
					 links[curdoc.link].form->name,
					 links[curdoc.link].form->value);
		    if (HTOutputFormat == HTAtom_for("www/download") &&
			newdoc.post_data != NULL &&
			newdoc.safe == FALSE) {
			if ((HText_POSTReplyLoaded(&newdoc) == TRUE) &&
			    HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			    HTInfoMsg(CANCELLED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    StrAllocCopy(newdoc.address, curdoc.address);
			    StrAllocCopy(newdoc.title, curdoc.title);
			    StrAllocCopy(newdoc.post_data, curdoc.post_data);
			    StrAllocCopy(newdoc.post_content_type,
					 curdoc.post_content_type);
			    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			    newdoc.isHEAD = curdoc.isHEAD;
			    newdoc.safe = curdoc.safe;
			    newdoc.internal_link = curdoc.internal_link;
			    break;
			}
		    }
		    if (c == 23) {
			c = DO_NOTHING;
			refresh_screen = TRUE;
		    }
		    goto new_keyboard_input;
		} else {
		    /*
		     *	Not a forms link.
		     *
		     *	Make sure this isn't a spoof in an account
		     *	with restrictions on file URLs. - FM
		     */
		    if (no_file_url &&
			!strncmp(links[curdoc.link].lname, "file:", 5)) {
			if (strncmp(curdoc.address, "file:", 5)) {
			    HTAlert(FILE_SERVED_LINKS_DISALLOWED);
			    reloading = FALSE;
			    break;
			} else if (curdoc.bookmark != NULL) {
			    HTAlert(FILE_BOOKMARKS_DISALLOWED);
			    reloading = FALSE;
			    break;
			}
		    }
		    /*
		     *	Make sure this isn't a spoof attempt
		     *	via an internal URL in a non-internal
		     *	document. - FM
		     */
		    if ((!strncmp(links[curdoc.link].lname,
				  "LYNXCOOKIE:", 11) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				COOKIE_JAR_TITLE)) ||
#ifdef DIRED_SUPPORT
			(!strncmp(links[curdoc.link].lname,
				  "LYNXDIRED:", 10) &&
			 (strcmp(curdoc.address, LYDiredFileURL) ||
			  strcmp((curdoc.title ? curdoc.title : ""),
				DIRED_MENU_TITLE)) &&
			 (strcmp(curdoc.address, LYPermitFileURL) ||
			  strcmp((curdoc.title ? curdoc.title : ""),
				PERMIT_OPTIONS_TITLE)) &&
			 (strcmp(curdoc.address, LYUploadFileURL) ||
			  strcmp((curdoc.title ? curdoc.title : ""),
				UPLOAD_OPTIONS_TITLE))) ||
#endif /* DIRED_SUPPORT */
			(!strncmp(links[curdoc.link].lname,
				 "LYNXDOWNLOAD:", 13) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				DOWNLOAD_OPTIONS_TITLE)) ||
			(!strncmp(links[curdoc.link].lname,
				  "LYNXHIST:", 9) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				HISTORY_PAGE_TITLE) &&
			 strcmp(curdoc.address, LYlist_temp_url())) ||
			(!strncmp(links[curdoc.link].lname,
				  "LYNXPRINT:", 10) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				PRINT_OPTIONS_TITLE))) {
			    HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
		    /*
		     *	Follow a normal link or anchor.
		     */
		    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
		    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
d6208 2
a6209 5
		 *  For internal links, retain POST content if present.
		 *  If we are on the List Page, prevent pushing it on
		 *  the history stack.	Otherwise set try_internal to
		 *  signal that the top of the loop should attempt to
		 *  reposition directly, without calling getfile. - kw
d6211 25
a6235 133
		    /*
		     *	Might be an internal link anchor in the same doc.
		     *	If so, take the try_internal shortcut if we didn't
		     *	fall through from LYK_NOCACHE. - kw
		     */
		    newdoc.internal_link =
			(links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
		    if (newdoc.internal_link) {
			/*
			 *  Special case of List Page document with an
			 *  internal link indication, which may really stand
			 *  for an internal link within the document the
			 *  List Page is about. - kw
			 */
			if ( 0==strcmp(curdoc.address, LYlist_temp_url()) &&
			    (LYIsListpageTitle(curdoc.title ? curdoc.title : ""))) {
			    if (!curdoc.post_data ||
				/*
				 *  Normal case - List Page is not associated
				 *  with post data. - kw
				 */
				(!LYresubmit_posts && curdoc.post_data &&
				history[nhist - 1].post_data &&
				!strcmp(curdoc.post_data,
					 history[nhist - 1].post_data) &&
				HText_getContentBase() &&
				!strncmp(HText_getContentBase(),
					 strncmp(history[nhist - 1].address,
						 "LYNXIMGMAP:", 11) ?
					 history[nhist - 1].address :
					 history[nhist - 1].address + 11,
					 strlen(HText_getContentBase())))) {
				/*
				 *  Normal case - as best as we can check, the
				 *  document at the top of the history stack
				 *  seems to be the document the List Page is
				 *  about (or a LYNXIMGMAP derived from it),
				 *  and LYresubmit_posts is not set, so don't
				 *  prompt here.  If we actually have to repeat
				 *  a POST because, against expectations, the
				 *  underlying document isn't cached any more,
				 *  HTAccess will prompt for confirmation,
				 *  unless we had LYK_NOCACHE. - kw
				 */
				LYinternal_flag = TRUE;
			    } else {
				HTLastConfirmCancelled(); /* reset flag */
				if (!confirm_post_resub(newdoc.address,
							newdoc.title,
						(LYresubmit_posts &&
				       HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
							2)) {
				    if (HTLastConfirmCancelled() ||
					(LYresubmit_posts &&
					 cmd != LYK_NOCACHE &&
					 !HText_POSTReplyLoaded(&newdoc))) {
					/* cancel the whole thing */
					LYforce_no_cache = FALSE;
					reloading = FALSE;
					StrAllocCopy(newdoc.address, curdoc.address);
					StrAllocCopy(newdoc.title, curdoc.title);
					newdoc.internal_link = curdoc.internal_link;
					HTInfoMsg(CANCELLED);
					break;
				    } else if (LYresubmit_posts &&
					       cmd != LYK_NOCACHE) {
					/* If LYresubmit_posts is set, and the
					   answer was No, and the key wasn't
					   NOCACHE, and we have a cached copy,
					   then use it. - kw */
					LYforce_no_cache = FALSE;
				    } else {
					/* if No, but not ^C or ^G, drop
					 * the post data.  Maybe the link
					 * wasn't meant to be internal after
					 * all, here we can recover from that
					 * assumption. - kw */
					FREE(newdoc.post_data);
					FREE(newdoc.post_content_type);
					newdoc.internal_link = FALSE;
					HTAlert(DISCARDING_POST_DATA);
				    }
				}
			    }
			    /*
			     *	Don't push the List Page if we follow an
			     *	internal link given by it. - kw
			     */
			    FREE(curdoc.address);
			} else if (cmd != LYK_NOCACHE) {
			    try_internal = TRUE;
			}
			if (!(LYresubmit_posts && newdoc.post_data))
			    LYinternal_flag = TRUE;
			/* We still set force_load so that history pushing
			** etc. will be done.  - kw */
			force_load = TRUE;
			break;
		    } else {
			/*
			 *  Free POST content if not an internal link. - kw
			 */
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
		    }
#endif /* TRACK_INTERNAL_LINKS */
		    /*
		     *	Might be an anchor in the same doc from a POST
		     *	form.  If so, dont't free the content. -- FM
		     */
		    if (are_different(&curdoc, &newdoc)) {
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
			FREE(newdoc.bookmark);
		    }
		    if (!no_jump && lynxjumpfile && curdoc.address &&
			!strcmp(lynxjumpfile, curdoc.address)) {
			LYJumpFileURL = TRUE;
			LYUserSpecifiedURL = TRUE;
		    } else if ((curdoc.title &&
			       !strcmp(curdoc.title, HISTORY_PAGE_TITLE)) ||
			       curdoc.bookmark != NULL ||
			       (lynxjumpfile &&
				!strcmp(lynxjumpfile, curdoc.address))) {
			LYUserSpecifiedURL = TRUE;
		    } else if (no_filereferer == TRUE &&
			       !strncmp(curdoc.address, "file:", 5)) {
			LYNoRefererForThis = TRUE;
		    }
		    newdoc.link = 0;
		    force_load = TRUE;	/* force MainLoop to reload */
#ifdef USE_PSRC
		    psrc_view = FALSE;	/* we get here if link is not internal */
d6238 4
d6243 2
a6244 10
		    if (lynx_edit_mode) {
			  HTuncache_current_document();
			  /*
			   *  Unescaping any slash chars in the URL,
			   *  but avoid double unescaping and too-early
			   *  unescaping of other chars. - KW
			   */
			  HTUnEscapeSome(newdoc.address,"/");
			  strip_trailing_slash(newdoc.address);
		    }
a6245 6
		    if (!strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
			HTuncache_current_document();
		    }
		}
	    }
	    break;
d6247 7
a6253 2
	case LYK_ELGOTO:   /* edit URL of current link and go to it  */
	    if (no_goto && !LYValidate) {
d6255 2
a6256 1
		 *  Go to not allowed. - FM
d6258 4
a6261 3
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(GOTO_DISALLOWED);
a6262 1
		break;
d6264 13
a6276 5
	    if (!(nlinks > 0 && curdoc.link > -1) ||
		(links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		 links[curdoc.link].form->type != F_SUBMIT_TYPE &&
		 links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE &&
		 links[curdoc.link].form->type != F_TEXT_SUBMIT_TYPE)) {
d6278 2
a6279 2
		 *  No links on page, or not a normal link
		 *  or form submit button. - FM
d6281 16
a6296 3
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
a6297 1
		break;
d6299 121
a6419 9
	    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
		(!links[curdoc.link].form->submit_action ||
		 *links[curdoc.link].form->submit_action == '\0')) {
		/*
		 *  Form submit button with no ACTION defined. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_FORM_ACTION);
a6420 1
		break;
d6422 6
a6427 18
#ifdef DIRED_SUPPORT
	    if (!strncmp(links[curdoc.link].lname,
			 "LYNXDIRED:", 10) ||
		!strcmp(curdoc.address, LYDiredFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			DIRED_MENU_TITLE) ||
		!strcmp(curdoc.address, LYPermitFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			PERMIT_OPTIONS_TITLE) ||
		!strcmp(curdoc.address, LYUploadFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			UPLOAD_OPTIONS_TITLE)) {
		/*
		 *  Disallow editing of File Management URLs. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
d6429 35
a6463 1
		break;
d6465 1
a6465 1
#endif /* DIRED_SUPPORT */
d6467 1
d6469 2
a6470 2
	     *	Save the current user_input_buffer string,
	     *	and load the current link's address. - FM
d6472 26
a6497 21
	    StrAllocCopy(temp, user_input_buffer);
	    LYstrncpy(user_input_buffer,
		      ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
						?
	    links[curdoc.link].form->submit_action : links[curdoc.link].lname),
		      (sizeof(user_input_buffer) - 1));

	    /*
	     *	Offer the current link's URL for editing. - FM
	     */
	    _statusline(EDIT_CURLINK_URL);
	    if (((ch = LYgetstr(user_input_buffer, VISIBLE,
				sizeof(user_input_buffer), RECALL)) >= 0) &&
		user_input_buffer[0] != '\0' &&
		strcmp(user_input_buffer,
		       ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
				? links[curdoc.link].form->submit_action
				: links[curdoc.link].lname))) {
		LYTrimAllStartfile(user_input_buffer); 
		if (user_input_buffer[0] != '\0') {
		    goto check_goto_URL;
d6500 1
d6502 1
a6502 2
	     *	User cancelled via ^G, a full deletion,
	     *	or not modifying the URL. - FM
a6503 4
	    HTInfoMsg(CANCELLED);
	    strcpy(user_input_buffer, temp);
	    FREE(temp);
	    break;
d6505 15
a6519 8
	case LYK_ECGOTO:   /* edit current URL and go to to it	*/
	    if (no_goto && !LYValidate) {
		/*
		 *  Go to not allowed. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(GOTO_DISALLOWED);
d6521 97
a6617 22
		break;
	    }
#ifdef DIRED_SUPPORT
	    if (!strcmp(curdoc.address, LYDiredFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			DIRED_MENU_TITLE) ||
		!strcmp(curdoc.address, LYPermitFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			PERMIT_OPTIONS_TITLE) ||
		!strcmp(curdoc.address, LYUploadFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			UPLOAD_OPTIONS_TITLE)) {
		/*
		 *  Disallow editing of File Management URLs. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
		}
		break;
	    }
#endif /* DIRED_SUPPORT */
d6619 1
a6619 8
	    /*
	     *	Save the current user_input_buffer string,
	     *	and load the current document's address.
	     */
	    StrAllocCopy(temp, user_input_buffer);
	    LYstrncpy(user_input_buffer,
		      curdoc.address,
		      (sizeof(user_input_buffer) - 1));
d6621 2
a6622 6
	    /*
	     *	Warn the user if the current document has POST
	     *	data associated with it. - FM
	     */
	    if (curdoc.post_data)
		HTAlert(CURRENT_DOC_HAS_POST_DATA);
d6624 1
a6624 21
	    /*
	     *	Offer the current document's URL for editing. - FM
	     */
	    _statusline(EDIT_CURDOC_URL);
	    if (((ch = LYgetstr(user_input_buffer, VISIBLE,
				sizeof(user_input_buffer), RECALL)) >= 0) &&
		user_input_buffer[0] != '\0' &&
		strcmp(user_input_buffer, curdoc.address)) {
		LYTrimAllStartfile(user_input_buffer); 
		if (user_input_buffer[0] != '\0') {
		    goto check_goto_URL;
		}
	    }
	    /*
	     *	User cancelled via ^G, a full deletion,
	     *	or not modifying the URL. - FM
	     */
	    HTInfoMsg(CANCELLED);
	    strcpy(user_input_buffer, temp);
	    FREE(temp);
	    break;
d6626 18
a6643 8
	case LYK_GOTO:	 /* 'g' to goto a random URL  */
	    if (no_goto && !LYValidate) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(GOTO_DISALLOWED);
		}
		break;
	    }
d6645 2
a6646 30
	    StrAllocCopy(temp, user_input_buffer);
	    if (!goto_buffer)
		*user_input_buffer = '\0';

	    URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
	    if (goto_buffer && *user_input_buffer) {
		recall = ((URLTotal > 1) ? RECALL : NORECALL);
		URLNum = 0;
		FirstURLRecall = FALSE;
	    } else {
		recall = ((URLTotal >= 1) ? RECALL : NORECALL);
		URLNum = URLTotal;
		FirstURLRecall = TRUE;
	    }

	    /*
	     *	Ask the user.
	     */
	    _statusline(URL_TO_OPEN);
	    if ((ch = LYgetstr(user_input_buffer, VISIBLE,
			       sizeof(user_input_buffer), recall)) < 0 ) {
		/*
		 *  User cancelled the Goto via ^G.
		 *  Restore user_input_buffer and break. - FM
		 */
		strcpy(user_input_buffer, temp);
		FREE(temp);
		HTInfoMsg(CANCELLED);
		break;
	    }
a6647 14
check_recall:
	    /*
	     *	Get rid of leading spaces (and any other spaces).
	     */
	    LYTrimAllStartfile(user_input_buffer); 
	    if (*user_input_buffer == '\0' &&
		!(recall && (ch == UPARROW || ch == DNARROW))) {
		strcpy(user_input_buffer, temp);
		FREE(temp);
		HTInfoMsg(CANCELLED);
		break;
	    }
	    if (recall && ch == UPARROW) {
		if (FirstURLRecall) {
d6649 4
a6652 1
		     *	Use last URL in the list. - FM
d6654 6
a6659 7
		    FirstURLRecall = FALSE;
		    URLNum = 0;
		} else {
		    /*
		     *	Go back to the previous URL in the list. - FM
		     */
		    URLNum++;
d6661 12
a6672 14
		if (URLNum >= URLTotal)
		    /*
		     *	Roll around to the last URL in the list. - FM
		     */
		    URLNum = 0;
		if ((cp = (char *)HTList_objectAt(Goto_URLs,
						  URLNum)) != NULL) {
		    strcpy(user_input_buffer, cp);
		    if (goto_buffer && *temp &&
			!strcmp(temp, user_input_buffer)) {
			_statusline(EDIT_CURRENT_GOTO);
		    } else if ((goto_buffer && URLTotal == 2) ||
			       (!goto_buffer && URLTotal == 1)) {
			_statusline(EDIT_THE_PREV_GOTO);
d6674 1
a6674 13
			_statusline(EDIT_A_PREV_GOTO);
		    }
		    if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				      sizeof(user_input_buffer),
				      recall)) < 0) {
			/*
			 *  User cancelled the Goto via ^G.
			 *  Restore user_input_buffer and break. - FM
			 */
			strcpy(user_input_buffer, temp);
			FREE(temp);
			HTInfoMsg(CANCELLED);
			break;
a6675 1
		    goto check_recall;
d6677 14
a6690 2
	    } else if (recall && ch == DNARROW) {
		if (FirstURLRecall) {
d6692 2
a6693 1
		     *	Use the first URL in the list. - FM
d6695 4
a6698 7
		    FirstURLRecall = FALSE;
		    URLNum = URLTotal - 1;
		} else {
		    /*
		     *	Advance to the next URL in the list. - FM
		     */
		    URLNum--;
d6700 2
a6701 1
		if (URLNum < 0)
d6703 8
a6710 1
		     *	Roll around to the first URL in the list. - FM
d6712 1
a6712 26
		    URLNum = URLTotal - 1;
		if ((cp=(char *)HTList_objectAt(Goto_URLs,
						    URLNum)) != NULL) {
		    strcpy(user_input_buffer, cp);
		    if (goto_buffer && *temp &&
			!strcmp(temp, user_input_buffer)) {
			_statusline(EDIT_CURRENT_GOTO);
		    } else if ((goto_buffer && URLTotal == 2) ||
			       (!goto_buffer && URLTotal == 1)) {
			_statusline(EDIT_THE_PREV_GOTO);
		    } else {
			_statusline(EDIT_A_PREV_GOTO);
		    }
		    if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				       sizeof(user_input_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the Goto via ^G.
			 *  Restore user_input_buffer and break. - FM
			 */
			strcpy(user_input_buffer, temp);
			FREE(temp);
			HTInfoMsg(CANCELLED);
			break;
		    }
		    goto check_recall;
d6714 2
a6715 10
	    }

check_goto_URL:
	    /* allow going to anchors*/
	    if (*user_input_buffer == '#' ) {
		if ( user_input_buffer[1] &&
		     HTFindPoundSelector(user_input_buffer+1) ) {
		     /* HTFindPoundSelector will initialize www_search_result,
			so we do nothing else. */
		    HTAddGotoURL(user_input_buffer);
a6716 1
		break;
d6718 1
a6718 12
	    /*
	     *	If its not a URL then make it one.
	     */
	    StrAllocCopy(temp, user_input_buffer);
	    LYFillLocalFileURL((char **)&temp, "file://localhost");
	    LYEnsureAbsoluteURL((char **)&temp, "", TRUE);
	    sprintf(user_input_buffer, "%.*s",
		    (int)(sizeof(user_input_buffer) - 1), temp);
	    FREE(temp);
	    if ((no_file_url || no_goto_file) &&
		!strncmp(user_input_buffer,"file:",5)) {
		HTUserMsg(GOTO_FILE_DISALLOWED);
d6720 11
a6730 7
	    } else if ((no_shell || no_goto_lynxexec
#ifdef EXEC_LINKS
			|| local_exec_on_local_files
#endif /* EXEC_LINKS */
			) &&
		       !strncmp(user_input_buffer, "lynxexec:",9)) {
		HTUserMsg(GOTO_EXEC_DISALLOWED);
d6732 9
a6740 44
	    } else if ((no_shell || no_goto_lynxprog
#ifdef EXEC_LINKS
			|| local_exec_on_local_files
#endif /* EXEC_LINKS */
			) &&
		       !strncmp(user_input_buffer, "lynxprog:",9)) {
		HTUserMsg(GOTO_PROG_DISALLOWED);

	    } else if ((no_shell || no_goto_lynxcgi) &&
		       !strncmp(user_input_buffer, "lynxcgi:", 8)) {
		HTUserMsg(GOTO_CGI_DISALLOWED);

	    } else if (LYValidate &&
		       strncmp(user_input_buffer, "http:", 5) &&
		       strncmp(user_input_buffer, "https:", 6)) {
		HTUserMsg(GOTO_NON_HTTP_DISALLOWED);

	    } else if (no_goto_cso &&
		       !strncmp(user_input_buffer, "cso:", 4)) {
		HTUserMsg(GOTO_CSO_DISALLOWED);

	    } else if (no_goto_finger &&
		       !strncmp(user_input_buffer, "finger:", 7)) {
		HTUserMsg(GOTO_FINGER_DISALLOWED);

	    } else if (no_goto_ftp &&
		       !strncmp(user_input_buffer, "ftp:", 4)) {
		HTUserMsg(GOTO_FTP_DISALLOWED);

	    } else if (no_goto_gopher &&
		       !strncmp(user_input_buffer, "gopher:", 7)) {
		HTUserMsg(GOTO_GOPHER_DISALLOWED);

	    } else if (no_goto_http &&
		       !strncmp(user_input_buffer, "http:", 5)) {
		HTUserMsg(GOTO_HTTP_DISALLOWED);

	    } else if (no_goto_https &&
		       !strncmp(user_input_buffer, "https:", 6)) {
		HTUserMsg(GOTO_HTTPS_DISALLOWED);

	    } else if (no_goto_mailto &&
		       !strncmp(user_input_buffer, "mailto:", 7)) {
		HTUserMsg(GOTO_MAILTO_DISALLOWED);
d6742 4
a6745 8
#ifndef DISABLE_NEWS
	    } else if (no_goto_news &&
		       !strncmp(user_input_buffer, "news:", 5)) {
		HTUserMsg(GOTO_NEWS_DISALLOWED);

	    } else if (no_goto_nntp &&
		       !strncmp(user_input_buffer, "nntp:", 5)) {
		HTUserMsg(GOTO_NNTP_DISALLOWED);
d6747 13
d6761 5
a6765 3
	    } else if (no_goto_rlogin &&
		       !strncmp(user_input_buffer, "rlogin:", 7)) {
		HTUserMsg(GOTO_RLOGIN_DISALLOWED);
d6767 9
a6775 26
#ifndef DISABLE_NEWS
	    } else if (no_goto_snews &&
		       !strncmp(user_input_buffer, "snews:", 6)) {
		HTUserMsg(GOTO_SNEWS_DISALLOWED);
#endif

	    } else if (no_goto_telnet &&
		       !strncmp(user_input_buffer, "telnet:", 7)) {
		HTUserMsg(GOTO_TELNET_DISALLOWED);

	    } else if (no_goto_tn3270 &&
		       !strncmp(user_input_buffer, "tn3270:", 7)) {
		HTUserMsg(GOTO_TN3270_DISALLOWED);

	    } else if (no_goto_wais &&
		       !strncmp(user_input_buffer, "wais:", 5)) {
		HTUserMsg(GOTO_WAIS_DISALLOWED);

	    } else if (!strncmp(user_input_buffer, "LYNXCOOKIE:", 11) ||
		       !strncmp(user_input_buffer, "LYNXDIRED:", 10) ||
		       !strncmp(user_input_buffer, "LYNXDOWNLOAD:", 13) ||
		       !strncmp(user_input_buffer, "LYNXOPTIONS:", 12) ||
		       !strncmp(user_input_buffer, "LYNXCFG:", 8) ||
		       !strncmp(user_input_buffer, "LYNXCOMPILEOPTS:", 16) ||
		       !strncmp(user_input_buffer, "LYNXPRINT:", 10)) {
		HTUserMsg(GOTO_SPECIAL_DISALLOWED);
d6777 13
a6789 25
	   } else {
		StrAllocCopy(newdoc.address, user_input_buffer);
		newdoc.isHEAD = FALSE;
		/*
		 *  Might be an anchor in the same doc from a POST
		 *  form.  If so, dont't free the content. -- FM
		 */
		if (are_different(&curdoc, &newdoc)) {
		    /*
		     *	Make a name for this new URL.
		     */
		    StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    force_load = TRUE;
#ifdef DIRED_SUPPORT
		    if (lynx_edit_mode)
			HTuncache_current_document();
#endif /* DIRED_SUPPORT */
		}
		LYUserSpecifiedURL = TRUE;
		HTAddGotoURL(newdoc.address);
d6791 1
a6791 1
	    break;
d6793 4
a6796 16
	case LYK_HELP:			/* show help file */
	    if (!STREQ(curdoc.address, helpfile)) {
		/*
		 *  Set the filename.
		 */
		StrAllocCopy(newdoc.address, helpfile);
		/*
		 *  Make a name for this help file.
		 */
		StrAllocCopy(newdoc.title, gettext("Help Screen"));
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
d6800 5
a6804 1
	case LYK_INDEX:  /* index file */
d6806 1
a6806 1
	     *	Make sure we are not in the index already.
d6808 1
a6808 1
	    if (!STREQ(curdoc.address, indexfile)) {
d6810 15
a6824 5
		if (indexfile[0]=='\0') { /* no defined index */
			if (old_c != real_c)	{
			    old_c = real_c;
			    HTUserMsg(NO_INDEX_FILE);
			}
d6826 2
a6827 11
		} else {
		    StrAllocCopy(newdoc.address, indexfile);
		    StrAllocCopy(newdoc.title, gettext("System Index")); /* name it */
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		} /* end else */
	    }  /* end if */
d6830 1
a6830 5
	case LYK_MAIN_MENU:	/* return to main screen */
	    /*
	     *	If its already the homepage then don't reload it.
	     */
	    if (!STREQ(curdoc.address,homepage)) {
d6832 3
a6834 15
		if (HTConfirmDefault(CONFIRM_MAIN_SCREEN, NO) == YES) {
		    StrAllocCopy(newdoc.address, homepage);
		    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    highlight(OFF, curdoc.link, prev_target);
#ifdef DIRED_SUPPORT
		    if (lynx_edit_mode)
		      HTuncache_current_document();
#endif /* DIRED_SUPPORT */
		}
d6836 2
a6837 4
		if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(IN_MAIN_SCREEN);
		}
d6839 32
d6873 6
a6878 122
	case LYK_OPTIONS:     /* options screen */
#ifdef DIRED_SUPPORT
	    c = dir_list_style;
#endif /* DIRED_SUPPORT */
#ifndef NO_OPTION_MENU
if (!LYUseFormsOptions) {
	    BOOLEAN LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
	    BOOLEAN LYSelectPopups_flag = LYSelectPopups;
	    BOOLEAN verbose_img_flag = verbose_img;
	    BOOLEAN keypad_mode_flag = keypad_mode;
	    BOOLEAN show_dotfiles_flag = show_dotfiles;
	    BOOLEAN user_mode_flag = user_mode;
	    int CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
	    int CurrentCharSet_flag = current_char_set;
	    int HTfileSortMethod_flag = HTfileSortMethod;
	    char *CurrentUserAgent = NULL;
	    char *CurrentNegoLanguage = NULL;
	    char *CurrentNegoCharset = NULL;
	    StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
					    LYUserAgent : ""));
	    StrAllocCopy(CurrentNegoLanguage, (language ?
					       language : ""));
	    StrAllocCopy(CurrentNegoCharset, (pref_charset ?
					      pref_charset : ""));

	    LYoptions(); /** do the old-style options stuff **/

	    if (keypad_mode_flag != keypad_mode ||
		(user_mode_flag != user_mode &&
		 (user_mode_flag == NOVICE_MODE ||
		  user_mode == NOVICE_MODE)) ||
		(((HTfileSortMethod_flag != HTfileSortMethod) ||
#ifdef DIRED_SUPPORT
		  (c != dir_list_style) ||
#endif /* DIRED_SUPPORT */
		  (show_dotfiles_flag != show_dotfiles)) &&
		 (!strncmp(curdoc.address, "file:", 5) ||
		  !strncmp(curdoc.address, "ftp:", 4))) ||
		CurrentCharSet_flag != current_char_set ||
		CurrentAssumeCharSet_flag != UCLYhndl_for_unspec ||
		verbose_img_flag != verbose_img ||
		LYUseDefaultRawMode_flag != LYUseDefaultRawMode ||
		LYSelectPopups_flag != LYSelectPopups ||
		((strcmp(CurrentUserAgent, (LYUserAgent ?
					    LYUserAgent : "")) ||
		  strcmp(CurrentNegoLanguage, (language ?
					       language : "")) ||
		  strcmp(CurrentNegoCharset, (pref_charset ?
					      pref_charset : ""))) &&
		 (!strncmp(curdoc.address, "http", 4) ||
		  !strncmp(curdoc.address, "lynxcgi:", 8)))) {
		/*
		 *  Check if this is a reply from a POST, and if so,
		 *  seek confirmation of reload if the safe element
		 *  is not set. - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    confirm_post_resub(curdoc.address, curdoc.title,
				       2, 1) == FALSE) {
		    HTInfoMsg(WILL_NOT_RELOAD_DOC);
		} else {
		    StrAllocCopy(newdoc.address, curdoc.address);
		    if (((strcmp(CurrentUserAgent, (LYUserAgent ?
					    LYUserAgent : "")) ||
			  strcmp(CurrentNegoLanguage,
				 (language ? language : "")) ||
			  strcmp(CurrentNegoCharset,
				 (pref_charset ? pref_charset : ""))) &&
			 (strncmp(curdoc.address, "http", 4) == 0 ||
			  strncmp(curdoc.address, "lynxcgi:", 8) == 0))) {
			/*
			 *  An option has changed which may influence
			 *  content negotiation, and the resource is from
			 *  a http or https or lynxcgi URL (the only protocols
			 *  which currently do anything with this information).
			 *  Set reloading = TRUE so that proxy caches will be
			 *  flushed, which is necessary until the time when
			 *  all proxies understand HTTP 1.1 Vary: and all
			 *  Servers properly use it...	Treat like
			 *  case LYK_RELOAD (see comments there). - KW
			 */
			reloading = TRUE;
		    }
		    if (HTisDocumentSource()) {
#ifndef USE_PSRC
			HTOutputFormat = WWW_SOURCE;
#else
			if (LYpsrc)
			    psrc_view = TRUE;
			else
			    HTOutputFormat = WWW_SOURCE;
#endif
		    }
#ifdef SOURCE_CACHE
		    if (reloading == FALSE) {
			/* one more attempt to be smart enough: */
			if (HTreparse_document()) {
			    FREE(CurrentUserAgent);
			    FREE(CurrentNegoLanguage);
			    FREE(CurrentNegoCharset);
			    break;
			}
		    }
#endif
		    HEAD_request = HTLoadedDocumentIsHEAD();
		    HTuncache_current_document();
#ifdef NO_ASSUME_SAME_DOC
		    newdoc.line = 1;
		    newdoc.link = 0;
#else
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
		    LYforce_no_cache = TRUE;
		    FREE(curdoc.address); /* So it doesn't get pushed. */
		}
	    }
	    FREE(CurrentUserAgent);
	    FREE(CurrentNegoLanguage);
	    FREE(CurrentNegoCharset);
	    refresh_screen = TRUE; /* to repaint screen */
a6879 19
} /* end if !LYUseFormsOptions */
#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS
	    /*
	     * Generally stolen from LYK_COOKIE_JAR.  Options menu handling is
	     * done in postoptions(), called from getfile() currently.
	     *
	     * postoptions() is also responsible for reloading the document
	     * before the 'options menu' but only when (a few) important
	     * options were changed.
	     *
	     * It is critical that post_data is freed here since the
	     * submission of changed options is done via the same protocol as
	     * LYNXOPTIONS:
	     */
	    /*
	     *	Don't do if already viewing options page.
	     */
	    if (strcmp((curdoc.title ? curdoc.title : ""), OPTIONS_TITLE)) {
d6881 2
a6882 19
		StrAllocCopy(newdoc.address, "LYNXOPTIONS:/");
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		LYforce_no_cache = TRUE;
		if (LYValidate || check_realm) {
		    LYPermitURL = TRUE;
		}
	   } else {
		/*
		 *  If already in the options menu, get out.
		 */
		cmd = LYK_PREV_DOC;
		goto new_cmd;
	    }
#endif /* !NO_OPTION_FORMS */
d6885 2
a6886 74
	case LYK_INDEX_SEARCH: /* search for a user string */
	    if (is_www_index) {
		/*
		 *  Perform a database search.
		 *
		 *  do_www_search will try to go out and get the document.
		 *  If it returns TRUE, a new document was returned and is
		 *  named in the newdoc.address.
		 */
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		if (do_www_search(&newdoc) == NORMAL) {
		    /*
		     *	Yah, the search succeeded.
		     */
		    if (TRACE && !LYUseTraceLog && LYCursesON) {
			/*
			 *  Make sure cursor is down.
			 */
			move(LYlines-1, LYcols-1);
#ifdef USE_SLANG
			addstr("\n");
#endif /* USE_SLANG */
			refresh();
		    }
		    LYpush(&curdoc, ForcePush);
		    /*
		     *	Make the curdoc.address the newdoc.address so that
		     *	getfile doesn't try to get the newdoc.address.
		     *	Since we have already gotten it.
		     */
		    StrAllocCopy(curdoc.address, newdoc.address);
		    StrAllocCopy(newdoc.post_data, curdoc.post_data);
		    newdoc.internal_link = FALSE;
		    curdoc.line = -1;
		    Newline = 0;
		    refresh_screen = TRUE; /* redisplay it */
		} else if (use_this_url_instead != NULL) {
		    /*
		     *	Got back a redirecting URL.  Check it out.
		     */
		    _user_message("Using %s", use_this_url_instead);
		    /*
		     *	Make a name for this URL.
		     */
		    StrAllocCopy(newdoc.title,
				 "A URL specified by redirection");
		    StrAllocCopy(newdoc.address, use_this_url_instead);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    FREE(use_this_url_instead);
		    force_load = TRUE;
		    break;
		} else {
		    /*
		     *	Yuk, the search failed.  Restore the old file.
		     */
		    StrAllocCopy(newdoc.address, curdoc.address);
		    StrAllocCopy(newdoc.post_data, curdoc.post_data);
		    StrAllocCopy(newdoc.post_content_type,
				 curdoc.post_content_type);
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    newdoc.isHEAD = curdoc.isHEAD;
		    newdoc.safe = curdoc.safe;
		    newdoc.internal_link = curdoc.internal_link;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTUserMsg(NOT_ISINDEX);
	    }
d6889 3
a6891 13
	case LYK_WHEREIS: /* search within the document */
	case LYK_NEXT:	  /* search for the next occurrence in the document */
	    /* user search */
	{
	    BOOLEAN have_target_onscreen = (*prev_target != '\0' &&
					    HText_pageHasPrevTarget());
	    BOOL found;
	    int oldcur = curdoc.link; /* temporarily remember */
	    char *remember_old_target = NULL;
	    if (have_target_onscreen)
		StrAllocCopy(remember_old_target, prev_target);
	    else
		StrAllocCopy(remember_old_target, "");
d6893 5
a6897 22
	    if (cmd != LYK_NEXT) {
		/*
		 *  Reset prev_target to force prompting
		 *  for a new search string and to turn
		 *  off highlighting in no search string
		 *  is entered by the user.
		 */
		*prev_target = '\0';
		found = textsearch(&curdoc, prev_target, FALSE);
	    } else {
		/*
		 *  When the third argument is TRUE, the previous
		 *  search string, if any, will be recalled from
		 *  a buffer, loaded into prev_target, and used
		 *  for the search without prompting for a new
		 *  search string.  This allows the LYK_NEXT
		 *  command to repeat a search in a new document,
		 *  after prev_target was reset on fetch of that
		 *  document.
		 */
		found = textsearch(&curdoc, prev_target, TRUE);
	    }
d6899 22
a6920 26
	    /*
	     *	Force a redraw to ensure highlighting of hits
	     *	even when found on the same page, or clearing
	     *	of highlighting is the default search string
	     *	was erased without replacement. - FM
	     */
	    /*
	    ** Well let's try to avoid it at least in a few cases
	    ** where it is not needed. - kw
	    */
	    if (www_search_result >= 0 && www_search_result != curdoc.line) {
		refresh_screen = TRUE; /* doesn't really matter */
	    } else if (!found) {
		refresh_screen = have_target_onscreen;
	    } else if (!have_target_onscreen && found) {
		refresh_screen = TRUE;
	    } else if (www_search_result == curdoc.line &&
		       curdoc.link == oldcur &&
		       curdoc.link >= 0 && nlinks > 0 &&
		       links[curdoc.link].ly >= (display_lines/3)) {
		refresh_screen = TRUE;
	    } else if ((case_sensitive && 0!=strcmp(prev_target,
						    remember_old_target)) ||
		      (!case_sensitive && 0!=strcasecomp8(prev_target,
						    remember_old_target))) {
		refresh_screen = TRUE;
a6921 2
	    FREE(remember_old_target);
	}
d6924 20
a6943 6
	case LYK_COMMENT:  /* reply by mail */
	    if (!owner_address &&
		strncasecomp(curdoc.address, "http", 4)) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(NO_OWNER);
d6945 3
a6947 4
	    } else if (no_mail) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(MAIL_DISALLOWED);
d6949 23
a6971 21
	    } else {
		if (HTConfirmDefault(CONFIRM_COMMENT, NO)) {
		    if (!owner_address) {
			/*
			 *  No owner defined, so make a guess and
			 *  and offer it to the user. - FM
			 */
			char *address = NULL;
			temp = HTParse(curdoc.address, "", PARSE_PATH);

			if (temp != NULL) {
			    HTUnEscape(temp);
			    if (*temp == '~' && strlen(temp) > 1) {
				/*
				 *  It's a ~user URL so guess user@@host. - FM
				 */
				if ((cp = strchr((temp+1), '/')) != NULL)
				    *cp = '\0';
				StrAllocCopy(address, "mailto:");
				StrAllocCat(address, (temp+1));
				StrAllocCat(address, "@@");
a6972 1
			    FREE(temp);
d6974 2
a6975 56
			if (address == NULL)
			    /*
			     *	Wasn't a ~user URL so guess WebMaster@@host. - FM
			     */
			    StrAllocCopy(address, "mailto:WebMaster@@");
			temp = HTParse(curdoc.address, "", PARSE_HOST);
			StrAllocCat(address, temp);
			HTSprintf0(&temp, NO_OWNER_USE, address);
			c = HTConfirmDefault(temp, NO);
			FREE(temp);
			if (c == YES) {
			    StrAllocCopy(owner_address, address);
			    FREE(address);
			} else {
			    FREE(address);
			    break;
			}
		    }
		    if (is_url(owner_address) != MAILTO_URL_TYPE) {
			/*
			 *  The address is a URL.  Just follow the link.
			 */
			StrAllocCopy(newdoc.address, owner_address);
			newdoc.internal_link = FALSE;
		    } else {
			/*
			 *  The owner_address is a mailto: URL.
			 */
			CONST char *kp = HText_getRevTitle();
			CONST char *id = HText_getMessageID();
			char *tmptitle = NULL;
			if (!kp && HTMainAnchor) {
			    kp = HTAnchor_subject(HTMainAnchor);
			    if (kp && *kp) {
				if (strncasecomp(kp, "Re: ", 4)) {
				    StrAllocCopy(tmptitle, "Re: ");
				    StrAllocCat(tmptitle, kp);
				    kp = tmptitle;
				}
			    }
			}

			if (strchr(owner_address,':')!=NULL)
			     /*
			      *  Send a reply.	The address is after the colon.
			      */
			     reply_by_mail(strchr(owner_address,':')+1,
					   curdoc.address,
					   (kp ? kp : ""), id);
			else
			    reply_by_mail(owner_address, curdoc.address,
					  (kp ? kp : ""), id);

			FREE(tmptitle);
			refresh_screen = TRUE;	/* to force a showpage */
		    }
d6977 4
d6983 1
d6985 14
a6998 9
#ifdef DIRED_SUPPORT
	case LYK_TAG_LINK:	/* tag or untag the current link */
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
		if (!strcmp(links[curdoc.link].hightext, ".."))
		    break;	/* Never tag the parent directory */
		if (dir_list_style == MIXED_STYLE) {
		    if (!strcmp(links[curdoc.link].hightext, "../"))
			break;
		} else if (!strncmp(links[curdoc.link].hightext, "Up to ", 6))
a6999 34
		{
		    /*
		     *	HTList-based management of tag list, see LYLocal.c - KW
		     */
		    HTList * t1 = tagged;
		    char * tagname = NULL;
		    BOOLEAN found = FALSE;

		    while ((tagname = (char *)HTList_nextObject(t1)) != NULL) {
			if (!strcmp(links[curdoc.link].lname, tagname)) {
			    found = TRUE;
			    HTList_removeObject(tagged, tagname);
			    FREE(tagname);
			    tagflag(OFF,curdoc.link);
			    break;
			}
		    }
		    if (!found) {
			if (tagged == NULL)
			    tagged = HTList_new();
			tagname = NULL;
			StrAllocCopy(tagname,links[curdoc.link].lname);
			HTList_addObject(tagged,tagname);
			tagflag(ON,curdoc.link);
		    }
		}
		if (curdoc.link < nlinks-1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link++;
		} else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = 0;
		} else if (more) {  /* next page */
		    Newline += (display_lines);
d7002 5
d7008 1
d7010 4
a7013 3
	case LYK_MODIFY:  /* rename a file or directory */
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
		int ret;
d7015 6
a7020 17
		ret = local_modify(&curdoc, &newdoc.address);
		if (ret == PERMIT_FORM_RESULT) { /* Permit form thrown up */
		    refresh_screen = TRUE;
		} else if (ret) {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    FREE(curdoc.address);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    clear();
		}
d7024 8
a7031 15
	case LYK_CREATE:  /* create a new file or directory */
	    if (lynx_edit_mode && !no_dired_support) {
		if (local_create(&curdoc)) {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    FREE(curdoc.address);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link > -1 ? curdoc.link : 0;
		    clear();
		}
a7033 1
#endif /* DIRED_SUPPORT */
d7035 24
a7058 17
	case LYK_EDIT:	/* edit */
	    if (no_editor) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_DISABLED);
		}
		break;
	    }
#ifdef AUTOEXTEDIT
	    /*
	     *  If we're in a forms TEXTAREA, invoke the editor on *its*
	     *  contents, rather than attempting to edit the html source
	     *  document.  KED
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
		cmd = LYK_EDIT_TEXTAREA;
d7060 1
a7060 1
	    }
d7062 3
a7064 17
	    /*
	     *  If we're in a forms TEXT type, tell user the request
	     *  is bogus (though in reality, without this trap, if the
	     *  document with the TEXT field is local, the editor *would*
	     *  be invoked on the source .html file; eg, the o(ptions)
	     *  form tempfile).
	     *
	     *  [This is done to avoid possible user confusion, due to
	     *   auto invocation of the editor on the TEXTAREA's contents
	     *   via the above if() statement.]
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXT_TYPE)       {
		HTUserMsg (CANNOT_EDIT_FIELD);
		break;
	    }
#endif /* AUTOEXTEDIT */
d7066 3
a7068 13
#ifdef DIRED_SUPPORT
	    /*
	     *	Allow the user to edit the link rather
	     *	than curdoc in edit mode.
	     */
	    if (lynx_edit_mode &&
		editor && *editor != '\0' && !no_dired_support) {
		if (nlinks > 0) {
		    cp = links[curdoc.link].lname;
		    if (is_url(cp) == FILE_URL_TYPE) {
			cp = HTfullURL_toFile(cp);
			StrAllocCopy(tp, cp);
			FREE(cp);
d7070 7
a7076 55
			if (stat(tp, &dir_info) == -1) {
			    HTAlert(NO_STATUS);
			} else {
			    if (S_ISREG(dir_info.st_mode)) {
				StrAllocCopy(tp, links[curdoc.link].lname);
				HTUnEscapeSome(tp, "/");
				if (edit_current_file(tp,
						      curdoc.link, Newline)) {
				    HTuncache_current_document();
				    StrAllocCopy(newdoc.address,
						 curdoc.address);
				    FREE(curdoc.address);
#ifdef NO_SEEK_OLD_POSITION
				    /*
				     *	Go to top of file.
				     */
				    newdoc.line = 1;
				    newdoc.link = 0;
#else
				    /*
				     *	Seek old position,
				     *	which probably changed.
				     */
				    newdoc.line = curdoc.line;
				    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
				    clear();  /* clear the screen */
				}
			    }
			}
			FREE(tp);
		    }
		}
	    } else
#endif /* DIRED_SUPPORT */
	    if (editor && *editor != '\0') {
		if (edit_current_file(newdoc.address, curdoc.link, Newline)) {
		    HTuncache_current_document();
		    LYforce_no_cache = TRUE;  /*force reload of document */
		    FREE(curdoc.address); /* so it doesn't get pushed */
#ifdef NO_SEEK_OLD_POSITION
		    /*
		     *	Go to top of file.
		     */
		    newdoc.line = 1;
		    newdoc.link = 0;
#else
		    /*
		     *	Seek old position, which probably changed.
		     */
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
		    clear();  /* clear the screen */
		}
d7078 2
a7079 6
	    } else {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_EDITOR);
		}
	    }
d7082 2
a7083 36
	case LYK_DEL_BOOKMARK:	/* remove a bookmark file link */
#ifdef DIRED_SUPPORT
	case LYK_REMOVE:	/* remove files and directories */
	    c = NO;
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
		local_remove(&curdoc);
		c = YES;
	    } else
#endif /* DIRED_SUPPORT */
	    if (curdoc.bookmark != NULL) {
		if ((c = HTConfirmDefault(CONFIRM_BOOKMARK_DELETE,NO)) != YES)
		    break;
		remove_bookmark_link(links[curdoc.link].anchor_number-1,
				     curdoc.bookmark);
	    } else {	/* behave like REFRESH for backward compatibility */
		refresh_screen = TRUE;
		if (old_c != real_c) {
		    old_c = real_c;
		    lynx_force_repaint();
		}
		break;
	    }
	    if (c == YES) {
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
		newdoc.line = curdoc.line;
		if (curdoc.link == nlinks-1) {
		    /*
		     *	We deleted the last link on the page. - FM
		     */
		    newdoc.link = curdoc.link-1;
		} else {
		    newdoc.link = curdoc.link;
		}
	    }
d7086 3
a7088 4
#ifdef DIRED_SUPPORT
	case LYK_INSTALL:  /* install a file into system area */
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support)
		local_install(NULL, links[curdoc.link].lname, &newdoc.address);
a7089 1
#endif /* DIRED_SUPPORT */
d7091 10
a7100 24
	case LYK_INFO:	/* show document info */
	    /*
	     *	Don't do if already viewing info page.
	     */
	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       SHOWINFO_TITLE)) {
		if (showinfo(&curdoc, HText_getNumOfLines(),
			     &newdoc, owner_address) < 0)
		    break;
		StrAllocCopy(newdoc.title, SHOWINFO_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		LYforce_no_cache = TRUE;
		if (LYValidate || check_realm)
		    LYPermitURL = TRUE;
	    } else {
		/*
		 *  If already in info page, get out.
		 */
		cmd = LYK_PREV_DOC;
d7105 6
a7110 6
	case LYK_EDIT_TEXTAREA: /* use external editor on a TEXTAREA - KED */
	    if (no_editor) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_DISABLED);
		}
d7112 11
d7124 11
d7136 9
a7144 5
	    /*
	     *  See if the current link is in a form TEXTAREA.
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d7146 3
a7148 2
		/* stop screen */
		stop_curses();
d7150 3
a7152 1
		n = HText_ExtEditForm (&links[curdoc.link]);
d7154 3
a7156 8
		/*
		 *  TODO: Move cursor "n" lines from the current line to
		 *	  position it on the 1st trailing blank line in
		 *	  the now edited TEXTAREA.  If the target line/
		 *	  anchor requires us to scroll up/down, position
		 *	  the target in the approximate center of the
		 *	  screen.
		 */
d7158 3
a7160 2
		/* curdoc.link += n;*/	/* works, except for page crossing, */
					/* damnit; why is nothing ever easy */
d7162 10
a7171 3
		/* start screen */
		start_curses();
		refresh_screen = TRUE;
d7173 3
a7175 1
	    } else {
d7177 4
a7180 2
		HTInfoMsg (NOT_IN_TEXTAREA);
	    }
d7183 3
a7185 6
	case LYK_GROW_TEXTAREA: /* add new lines to bottom of TEXTAREA - KED */
	    /*
	     *  See if the current link is in a form TEXTAREA.
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d7187 4
a7190 1
		HText_ExpandTextarea (&links[curdoc.link], TEXTAREA_EXPAND_SIZE);
d7192 3
a7194 1
		refresh_screen = TRUE;
d7196 4
a7199 1
	    } else {
d7201 6
a7206 1
		HTInfoMsg (NOT_IN_TEXTAREA);
d7208 4
d7214 3
a7216 6
	case LYK_INSERT_FILE: /* insert file in TEXTAREA, above cursor - KED */
	    /*
	     *  See if the current link is in a form TEXTAREA.
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d7218 5
a7222 1
		n = HText_InsertFile (&links[curdoc.link]);
d7224 5
a7228 12
		/*
		 *  TODO: Move cursor "n" lines from the current line to
		 *	  position it on the 1st line following the text
		 *	  that was inserted.  If the target line/anchor
		 *	  requires us to scroll up/down, position the
		 *	  target in the approximate center of the screen.
		 *
		 *  [Current behavior leaves cursor on the same line relative
		 *   to the start of the TEXTAREA that it was on before the
		 *   insertion.  This is the same behavior that occurs with
		 *   (my) editor, so this TODO will stay unimplemented.]
		 */
d7230 4
a7233 1
		refresh_screen = TRUE;
d7235 3
a7237 1
	    } else {
d7239 2
a7240 2
		HTInfoMsg (NOT_IN_TEXTAREA);
	    }
d7243 3
a7245 14
	case LYK_PRINT:  /* print the file */
	    if (LYValidate) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(PRINT_DISABLED);
		}
		break;
	    }

	    /*
	     *	Don't do if already viewing print options page.
	     */
	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       PRINT_OPTIONS_TITLE)) {
d7247 2
a7248 14
		if (print_options(&newdoc.address,
				  &curdoc.address, HText_getNumOfLines()) < 0)
		    break;
		StrAllocCopy(newdoc.title, PRINT_OPTIONS_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		ForcePush = TRUE;  /* see LYpush() and print_options() */
		if (check_realm)
		    LYPermitURL = TRUE;
		refresh_screen = TRUE;	/* redisplay */
	    }
d7251 2
a7252 10
	case LYK_LIST:	/* list links in the current document */
	    /*
	     *	Don't do if already viewing list page.
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			LIST_PAGE_TITLE)) {
		/*
		 *  Already viewing list page, so get out.
		 */
		cmd = LYK_PREV_DOC;
a7253 20
	    }

	    /*
	     *	Print list page to file.
	     */
	    if (showlist(&newdoc, TRUE) < 0)
		break;
	    StrAllocCopy(newdoc.title, LIST_PAGE_TITLE);
	    /*
	     *	showlist will set newdoc's other fields.  It may leave
	     *	post_data intact so the list can be used to follow
	     *	internal links in the current document even if it is
	     *	a POST response. - kw
	     */

	    refresh_screen = TRUE;  /* redisplay */
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
		StrAllocCopy(lynxlistfile, newdoc.address);
	    }
d7257 2
a7258 10
	case LYK_ADDRLIST:   /* always list URL's (only) */
	    /*
	     *	Don't do if already viewing list addresses page.
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			ADDRLIST_PAGE_TITLE)) {
		/*
		 *  Already viewing list page, so get out.
		 */
		cmd = LYK_PREV_DOC;
a7259 20
	    }

	    /*
	     *	Print address list page to file.
	     */
	    if (showlist(&newdoc, FALSE) < 0)
		break;
	    StrAllocCopy(newdoc.title, ADDRLIST_PAGE_TITLE);
	    /*
	     *	showlist will set newdoc's other fields.  It may leave
	     *	post_data intact so the list can be used to follow
	     *	internal links in the current document even if it is
	     *	a POST response. - kw
	     */

	    refresh_screen = TRUE;  /* redisplay */
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
		StrAllocCopy(lynxlistfile, newdoc.address);
	    }
d7264 1
a7264 6
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			VISITED_LINKS_TITLE)) {
		/*
		 *  Already viewing visited links page, so get out.
		 */
		cmd = LYK_PREV_DOC;
a7265 21
	    }

	    /*
	     *	Print visited links page to file.
	     */
	    if (LYShowVisitedLinks(&newdoc.address) < 0) {
		HTUserMsg(VISITED_LINKS_EMPTY);
		break;
	    }
	    StrAllocCopy(newdoc.title, VISITED_LINKS_TITLE);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    refresh_screen = TRUE;
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
		StrAllocCopy(lynxlinksfile, newdoc.address);
	    }
d7269 1
a7269 22
	    if (!HText_hasToolbar(HTMainText)) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_TOOLBAR);
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		if ((cp = strchr(curdoc.address, '#')) != NULL)
		    *cp = '\0';
		toolbar = (char *)malloc(strlen(curdoc.address) +
					 strlen(LYToolbarName) + 2);
		if (!toolbar)
		    outofmem(__FILE__, "mainloop");

		sprintf(toolbar, "%s#%s", curdoc.address, LYToolbarName);
		if (cp)
		    *cp = '#';
		StrAllocCopy(newdoc.address, toolbar);
		FREE(toolbar);
		try_internal = TRUE;
		force_load = TRUE;  /* force MainLoop to reload */
	    }
d7274 1
a7274 127
#ifdef VMS
	    /*
	     *	Check if the CSwing Directory/File Manager is available.
	     *	Will be disabled if LYCSwingPath is NULL, zero-length,
	     *	or "none" (case insensitive), if no_file_url was set via
	     *	the file_url restriction, if no_goto_file was set for
	     *	the anonymous account, or if HTDirAccess was set to
	     *	HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse
	     *	or -selective switches. - FM
	     */
	    if (!(LYCSwingPath && *LYCSwingPath) ||
		!strcasecomp(LYCSwingPath, "none") ||
		no_file_url || no_goto_file ||
		HTDirAccess == HT_DIR_FORBID ||
		HTDirAccess == HT_DIR_SELECTIVE) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(DFM_NOT_AVAILABLE);
		}
		break;
	    }

	    /*
	     *	If we are viewing a local directory listing or a
	     *	local file which is not temporary, invoke CSwing
	     *	with the URL's directory converted to VMS path specs
	     *	and passed as the argument, so we start up CSwing
	     *	positioned on that node of the directory tree.
	     *	Otherwise, pass the current default directory as
	     *	the argument. - FM
	     */
	    if (LYisLocalFile(curdoc.address) &&
		strncasecomp(curdoc.address,
			     lynx_temp_space, strlen(lynx_temp_space))) {
		/*
		 *  We are viewing a local directory or a local file
		 *  which is not temporary. - FM
		 */
		struct stat stat_info;

		cp = HTParse(curdoc.address, "", PARSE_PATH|PARSE_PUNCTUATION);
		HTUnEscape(cp);
		if (HTStat(cp, &stat_info) == -1) {
		    CTRACE(tfp, "mainloop: Can't stat %s\n", cp);
		    FREE(cp);
		    temp = (char *)calloc(1, (strlen(LYCSwingPath) + 4));
		    if (temp == NULL)
			outofmem(__FILE__, "mainloop");
		    sprintf(temp, "%s []", LYCSwingPath);
		    refresh_screen = TRUE;  /* redisplay */
		} else {
		    char *VMSdir = NULL;

		    if (S_ISDIR(stat_info.st_mode)) {
			/*
			 *  We're viewing a local directory.  Make
			 *  that the CSwing argument. - FM
			 */
			LYAddPathSep(&cp);
			StrAllocCopy(VMSdir, HTVMS_name("", cp));
			FREE(cp);
		    } else {
			/*
			 *  We're viewing a local file.  Make it's
			 *  directory the CSwing argument. - FM
			 */
			StrAllocCopy(VMSdir, HTVMS_name("", cp));
			FREE(cp);
			if ((cp = strrchr(VMSdir, ']')) != NULL) {
			    *(cp + 1) = '\0';
			    cp == NULL;
			} else if ((cp = strrchr(VMSdir, ':')) != NULL) {
			    *(cp + 1) = '\0';
			    cp == NULL;
			}
		    }
		    temp = (char *)calloc(1,
					  (strlen(LYCSwingPath) +
					   strlen(VMSdir) +
					   2));
		    if (temp == NULL)
			outofmem(__FILE__, "mainloop");
		    sprintf(temp, "%s %s", LYCSwingPath, VMSdir);
		    FREE(VMSdir);
		    /*
		     *	Uncache the current document in case we
		     *	change, move, or delete it during the
		     *	CSwing session. - FM
		     */
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    StrAllocCopy(newdoc.title,
				 curdoc.title ? curdoc.title : "");
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    FREE(curdoc.address);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		}
	    } else {
		/*
		 *  We're not viewing a local directory or file.
		 *  Pass CSwing the current default directory as
		 *  an argument and don't uncache the current
		 *  document. - FM
		 */
		temp = (char *)calloc(1, (strlen(LYCSwingPath) + 4));
		if (temp == NULL)
		    outofmem(__FILE__, "mainloop");
		sprintf(temp, "%s []", LYCSwingPath);
		refresh_screen = TRUE;	/* redisplay */
	    }
	    stop_curses();
	    LYSystem(temp);
	    start_curses();
	    FREE(temp);
	    break;
#else
	    /*
	     *	Don't do if not allowed or already viewing the menu.
	     */
	    if (lynx_edit_mode && !no_dired_support &&
		strcmp(curdoc.address, LYDiredFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       DIRED_MENU_TITLE)) {
		dired_options(&curdoc,&newdoc.address);
		refresh_screen = TRUE;	/* redisplay */
	    }
a7275 1
#endif /* VMS */
d7279 5
a7283 6
	case LYK_EXTERN:  /* use external program on url */
	    if  ((nlinks > 0) && (links[curdoc.link].lname != NULL))
	    {
		run_external(links[curdoc.link].lname);
		refresh_screen = TRUE;
	    }
d7288 1
a7288 162
	    if (LYValidate) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(BOOKMARKS_DISABLED);
		}
		break;
	    }

	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       HISTORY_PAGE_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       SHOWINFO_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       PRINT_OPTIONS_TITLE) &&
#ifdef DIRED_SUPPORT
		strcmp(curdoc.address, LYDiredFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       DIRED_MENU_TITLE) &&
		strcmp(curdoc.address, LYPermitFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       PERMIT_OPTIONS_TITLE) &&
		strcmp(curdoc.address, LYUploadFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       UPLOAD_OPTIONS_TITLE) &&
#endif /* DIRED_SUPPORT */
		strcmp((curdoc.title ? curdoc.title : ""),
		       DOWNLOAD_OPTIONS_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       COOKIE_JAR_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       OPTIONS_TITLE) &&
		((nlinks <= 0) ||
		 (links[curdoc.link].lname != NULL &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXHIST:", 9) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXPRINT:", 10) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXDIRED:", 10) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXDOWNLOAD:", 13) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXCOOKIE:", 11) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXOPTIONS:", 12) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXLIST:", 9)))) {
		if (nlinks > 0) {
		    if (curdoc.post_data == NULL &&
			curdoc.bookmark == NULL &&
			!LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
			strcmp((curdoc.title ? curdoc.title : ""),
			       VISITED_LINKS_TITLE)) {
			/*
			 *  The document doesn't have POST content,
			 *  and is not a bookmark file, nor is the
			 *  list or visited links page, so we can
			 *  save either that or the link. - FM
			 */
			_statusline(BOOK_D_L_OR_CANCEL);
			c = LYgetch();
			if (TOUPPER(c) == 'D') {
			    save_bookmark_link(curdoc.address, curdoc.title);
			    refresh_screen = TRUE; /* MultiBookmark support */
			    goto check_add_bookmark_to_self;
			}
		    } else {
			if (LYMultiBookmarks == FALSE &&
			    curdoc.bookmark != NULL &&
			    strstr(curdoc.address,
				   (*bookmark_page == '.'
						  ?
				(bookmark_page+1) : bookmark_page)) != NULL) {
			    /*
			     *	If multiple bookmarks are disabled, offer
			     *	the L)ink or C)ancel, but with wording
			     *	which indicates that the link already
			     *	exists in this bookmark file. - FM
			     */
			    _statusline(MULTIBOOKMARKS_SELF);
			} else if (curdoc.post_data != NULL &&
				   links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
			    /*
			     *	Internal link, and document has POST content.
			     */
			    HTUserMsg(NOBOOK_POST_FORM);
			    break;
			} else {
			    /*
			     *	Only offer the link in a document with
			     *	POST content, or if the current document
			     *	is a bookmark file and multiple bookmarks
			     *	are enabled. - FM
			     */
			    _statusline(BOOK_L_OR_CANCEL);
			}
			c = LYgetch();
		    }
		    if (TOUPPER(c) == 'L') {
			if (curdoc.post_data != NULL &&
			    links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
			    /*
			     *	Internal link, and document has POST content.
			     */
			    HTUserMsg(NOBOOK_POST_FORM);
			    break;
			}
			/*
			 *  User does want to save the link. - FM
			 */
			if (links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
			    save_bookmark_link(links[curdoc.link].lname,
					       links[curdoc.link].hightext);
			    refresh_screen = TRUE; /* MultiBookmark support */
			} else {
			    HTUserMsg(NOBOOK_FORM_FIELD);
			    break;
			}
		    } else {
			break;
		    }
		} else if (curdoc.post_data != NULL) {
		    /*
		     *	No links, and document has POST content. - FM
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    break;
		} else if (curdoc.bookmark != NULL) {
		    /*
		     *	It's a bookmark file from which all
		     *	of the links were deleted. - FM
		     */
		    HTUserMsg(BOOKMARKS_NOLINKS);
		    break;
		} else {
		    _statusline(BOOK_D_OR_CANCEL);
		    c = LYgetch();
		    if (TOUPPER(c) == 'D') {
			save_bookmark_link(curdoc.address, curdoc.title);
			refresh_screen = TRUE; /* MultiBookmark support */
		    } else {
			break;
		    }
		}
check_add_bookmark_to_self:
		if (curdoc.bookmark && BookmarkPage &&
		    !strcmp(curdoc.bookmark, BookmarkPage)) {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    FREE(curdoc.address);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    newdoc.internal_link = FALSE;
		}
		FREE(temp);
	    } else {
		if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NOBOOK_HSML);
		}
	    }
d7291 2
a7292 38
	case LYK_VIEW_BOOKMARK:   /* v to view home page */
	    if (LYValidate) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(BOOKMARKS_DISABLED);
		}
		break;
	    }

	    /*
	     *	See if a bookmark exists.
	     *	If it does replace newdoc.address with it's name.
	     */
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL) {
		if (*cp == '\0' || !strcmp(cp, " ") ||
		    !strcmp(curdoc.address, newdoc.address)) {
		    if (LYMultiBookmarks == TRUE)
			refresh_screen = TRUE;
		    break;
		}
		LYforce_no_cache = TRUE;  /*force the document to be reloaded*/
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
	    } else {
		if (old_c != real_c) {
		    old_c = real_c;
		    LYMBM_statusline(BOOKMARKS_NOT_OPEN);
		    sleep(AlertSecs);
		    if (LYMultiBookmarks == TRUE) {
			refresh_screen = TRUE;
		    }
		}
	    }
d7295 2
a7296 13
	case LYK_SHELL:  /* shell escape */
	    if (!no_shell) {
		stop_curses();
		printf("%s\r\n", SPAWNING_MSG);
		LYSystem(LYSysShell());
		start_curses();
		refresh_screen = TRUE;	/* for an HText_pageDisplay() */
	    } else {
		if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(SPAWNING_DISABLED);
		}
	    }
d7300 5
a7304 211
	    /*
	     *	Don't do if both download and disk_save are restricted.
	     */
	    if (LYValidate ||
		(no_download && !override_no_download && no_disk_save)) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(DOWNLOAD_DISABLED);
		}
		break;
	    }

	    /*
	     *	Don't do if already viewing download options page.
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			DOWNLOAD_OPTIONS_TITLE))
		break;

	    if (nlinks > 0) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
		    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
			links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE) {
			if (links[curdoc.link].form->submit_method ==
				 URL_MAIL_METHOD) {
			    if (old_c != real_c) {
				old_c = real_c;
				HTUserMsg(NO_DOWNLOAD_MAILTO_ACTION);
			    }
			    break;
			}
			if (!strncmp(links[curdoc.link].form->submit_action,
				"LYNXOPTIONS:", 12)) {
			    if (old_c != real_c) {
				old_c = real_c;
				HTUserMsg(NO_DOWNLOAD_SPECIAL);
			    }
			    break;
			}
			HTOutputFormat = HTAtom_for("www/download");
			LYforce_no_cache = TRUE;
			cmd = LYK_ACTIVATE;
			goto new_cmd;
		    }
		    if (old_c != real_c) {
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_INPUT);
		    }

		} else if (!strcmp((curdoc.title ? curdoc.title : ""),
				   COOKIE_JAR_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_COOKIES);
		    }

		} else if (!strcmp((curdoc.title ? curdoc.title : ""),
				   PRINT_OPTIONS_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_PRINT_OP);
		    }

#ifdef DIRED_SUPPORT
		} else if (!strcmp(curdoc.address, LYUploadFileURL) ||
			   !strcmp((curdoc.title ? curdoc.title : ""),
				   UPLOAD_OPTIONS_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_UPLOAD_OP);
		    }

		} else if (!strcmp(curdoc.address, LYPermitFileURL) ||
			   !strcmp((curdoc.title ? curdoc.title : ""),
				   PERMIT_OPTIONS_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_PERMIT_OP);
		    }

		} else if (lynx_edit_mode && !no_dired_support) {
		    /*
		     *	Don't bother making a /tmp copy of the local file.
		     */
		    StrAllocCopy(temp, newdoc.address);
		    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
		    if (LYdownload_options(&newdoc.address,
					   links[curdoc.link].lname) < 0)
			StrAllocCopy(newdoc.address, temp);
		    else
			newdoc.internal_link = FALSE;
		    FREE(temp);
#endif /* DIRED_SUPPORT */

		} else if (!strcmp((curdoc.title ? curdoc.title : ""),
				   HISTORY_PAGE_TITLE) &&
		    !strncmp(links[curdoc.link].lname, "LYNXHIST:", 9)) {
		    int number = atoi(links[curdoc.link].lname+9);
		    if ((history[number].post_data != NULL &&
			 history[number].safe != TRUE) &&
			HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			HTInfoMsg(CANCELLED);
			break;
		    }
		    /*
		     *  OK, we download from history page, restore URL from stack.
		     */
		    StrAllocCopy(newdoc.address, history[number].address);
		    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
		    StrAllocCopy(newdoc.bookmark, history[number].bookmark);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    if (history[number].post_data)
			StrAllocCopy(newdoc.post_data,
				     history[number].post_data);
		    if (history[number].post_content_type)
			StrAllocCopy(newdoc.post_content_type,
				     history[number].post_content_type);
		    newdoc.isHEAD = history[number].isHEAD;
		    newdoc.safe = history[number].safe;
		    newdoc.internal_link = FALSE;
		    newdoc.link = 0;
		    HTOutputFormat = HTAtom_for("www/download");
		    LYUserSpecifiedURL = TRUE;
		    /*
		     *	Force the document to be reloaded.
		     */
		    LYforce_no_cache = TRUE;

		} else if (!strncmp(links[curdoc.link].lname, "data:", 5)) {
		    if (old_c != real_c) {
			old_c = real_c;
			HTAlert(UNSUPPORTED_DATA_URL);
		    }

		} else if (!strncmp(links[curdoc.link].lname,
				    "LYNXCOOKIE:", 11) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXDIRED:", 10) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXDOWNLOAD:", 13) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXPRINT:", 10) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXOPTIONS:", 12) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXCFG:", 8) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXCOMPILEOPTS:", 16) ||
			   !strncmp(links[curdoc.link].lname,
				    "lynxexec:", 9) ||
			   !strncmp(links[curdoc.link].lname,
				    "lynxprog:", 9)) {
		    HTUserMsg(NO_DOWNLOAD_SPECIAL);

		} else if (!strncmp(links[curdoc.link].lname,
				    "mailto:", 7)) {
		    HTUserMsg(NO_DOWNLOAD_MAILTO_LINK);

		/*
		 *  From here on we could have a remote host, so check if
		 *  that's allowed.
		 *
		 *  We copy all these checks from getfile() to LYK_DOWNLOAD
		 *  here because LYNXDOWNLOAD:// will NOT be pushing the
		 *  previous document into the history stack so preserve
		 *  getfile() from returning a wrong status (NULLFILE).
		 */
		} else if (local_host_only &&
			   !(LYisLocalHost(links[curdoc.link].lname) ||
			     LYisLocalAlias(links[curdoc.link].lname))) {
		    HTUserMsg(ACCESS_ONLY_LOCALHOST);
		} else {   /* Not a forms, options or history link */
		    /*
		     *	Follow a normal link or anchor.  Note that
		     *	if it's an anchor within the same document,
		     *	entire document will be downloaded.
		     */
		    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
		    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
		    /*
		     *	Might be an internal link in the same doc from a
		     *	POST form.  If so, don't free the content. - kw
		     */
		    if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE)
#else
		    /*
		     *	Might be an anchor in the same doc from a POST
		     *	form.  If so, don't free the content. -- FM
		     */
		    if (are_different(&curdoc, &newdoc))
#endif /* TRACK_INTERNAL_LINKS */
		    {
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
			FREE(newdoc.bookmark);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
		    }
		    newdoc.internal_link = FALSE;
		    newdoc.link = 0;
		    HTOutputFormat = HTAtom_for("www/download");
		    /*
		     *	Force the document to be reloaded.
		     */
		    LYforce_no_cache = TRUE;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_CHOICE);
d7310 1
a7310 25
	    /*
	     *	Don't do if already viewing upload options page.
	     */
	    if (!strcmp(curdoc.address, LYUploadFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			UPLOAD_OPTIONS_TITLE))
		break;

	    if (lynx_edit_mode && !no_dired_support) {
		LYUpload_options((char **)&newdoc.address,
				 (char *)curdoc.address);
		StrAllocCopy(newdoc.title, UPLOAD_OPTIONS_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		/*
		 *  Uncache the current listing so that it will
		 *  be updated to included the uploaded file if
		 *  placed in the current directory. - FM
		 */
		HTuncache_current_document();
	     }
d7315 1
a7315 3
	    WWW_TraceFlag = ! WWW_TraceFlag;
	    if (LYOpenTraceLog())
		HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
d7319 1
a7319 42
	    /*
	     *	Check whether we've started a TRACE log
	     *	in this session. - FM
	     */
	    if (LYTraceLogFP == NULL) {
		HTUserMsg(NO_TRACELOG_STARTED);
		break;
	    }

	    /*
	     *	Don't do if already viewing the TRACE log. - FM
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			LYNX_TRACELOG_TITLE))
		break;

	    /*
	     *	If TRACE mode is on, turn it off during this fetch of the
	     *	TRACE log, so we don't enter stuff about this fetch, and
	     *	set a flag for turning it back on when we return to this
	     *	loop.  Note that we'll miss any messages about memory
	     *	exhaustion if it should occur.	It seems unlikely that
	     *	anything else bad might happen, but if it does, we'll
	     *	miss messages about that too.  We also fflush(), close,
	     *	and open it again, to make sure all stderr messages thus
	     *	far will be in the log. - FM
	     */
	    if (!LYReopenTracelog(&trace_mode_flag))
		break;

	    LYLocalFileToURL (&(newdoc.address), LYTraceLogPath);
	    StrAllocCopy(newdoc.title, LYNX_TRACELOG_TITLE);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
	    }
	    LYforce_no_cache = TRUE;
d7323 3
a7325 14
	    if (clickable_images)
		clickable_images = FALSE;
	    else
		clickable_images = TRUE;

	    HTUserMsg(clickable_images ?
		     CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break;
	    }
#endif
	    cmd = LYK_RELOAD;
	    goto new_cmd;
d7328 3
a7330 14
	    if (pseudo_inline_alts)
		pseudo_inline_alts = FALSE;
	    else
		pseudo_inline_alts = TRUE;

	    HTUserMsg(pseudo_inline_alts ?
		      PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break;
	    }
#endif
	    cmd = LYK_RELOAD;
	    goto new_cmd;
d7333 1
a7333 13
	    if (HTLoadedDocumentCharset()) {
		HTUserMsg(gettext("charset for this document specified explicitely, sorry..."));
		break;
	    } else {
		LYUseDefaultRawMode = !LYUseDefaultRawMode;
		HTUserMsg(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
		HTMLSetCharacterHandling(current_char_set);
#ifdef SOURCE_CACHE
		if (HTreparse_document()) {
		    break;
		}
#endif
		cmd = LYK_RELOAD;
d7335 1
a7335 1
	    }
d7338 2
a7339 122
	    if (nlinks > 0 &&
		(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
		 links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		 links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE)) {
		/*
		 *  We have links, and the current link is a
		 *  normal link or a form's submit button. - FM
		 */
		_statusline(HEAD_D_L_OR_CANCEL);
		c = LYgetch();
		if (TOUPPER(c) == 'D') {
		    char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
			curdoc.address : curdoc.address + 11;
		    if (LYCanDoHEAD(scheme) != TRUE) {
			HTUserMsg(DOC_NOT_HTTP_URL);
		    } else {
			/*
			 *  Check if this is a reply from a POST,
			 *  and if so, seek confirmation if the
			 *  safe element is not set. - FM
			 */
			if ((curdoc.post_data != NULL &&
			     curdoc.safe != TRUE) &&
			    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
			    HTInfoMsg(CANCELLED);
			    break;
			}
			HEAD_request = TRUE;
			LYforce_no_cache = TRUE;
			StrAllocCopy(newdoc.title, curdoc.title);
			if (HTLoadedDocumentIsHEAD()) {
			    HTuncache_current_document();
			    FREE(curdoc.address);
			} else {
			    StrAllocCat(newdoc.title, " - HEAD");
			}
		    }
		    break;
		} else if (TOUPPER(c) == 'L') {
		    if (links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
			strncmp(links[curdoc.link].lname, "http", 4) &&
			strncmp(links[curdoc.link].lname,
				"LYNXIMGMAP:http", 15) &&
			LYCanDoHEAD(links[curdoc.link].lname) != TRUE &&
			(links[curdoc.link].type != WWW_INTERN_LINK_TYPE ||
			 !curdoc.address ||
			 strncmp(curdoc.address, "http", 4))) {
			HTUserMsg(LINK_NOT_HTTP_URL);
		    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			       links[curdoc.link].form->disabled) {
			HTUserMsg(FORM_ACTION_DISABLED);
		    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			       strncmp(links[curdoc.link].form->submit_action,
							      "lynxcgi:", 8) &&
			       strncmp(links[curdoc.link].form->submit_action,
								 "http", 4)) {
			HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
		    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			       links[curdoc.link].form->submit_method ==
							  URL_POST_METHOD &&
			       HTConfirm(CONFIRM_POST_LINK_HEAD) == FALSE) {
			HTInfoMsg(CANCELLED);
		    } else {
			HEAD_request = TRUE;
			LYforce_no_cache = TRUE;
			cmd = LYK_ACTIVATE;
			goto new_cmd;
		    }
		    break;
		}
		break;
	    } else {
		/*
		 *  We can offer only this document for a HEAD request.
		 *  Check if this is a reply from a POST, and if so,
		 *  seek confirmation if the safe element is not set. - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
		    HTInfoMsg(CANCELLED);
		    break;
		} else if (nlinks > 0) {
		    /*
		     *	The current link is a non-submittable form
		     *	link, so prompt the user to make it clear
		     *	that the HEAD request would be for the
		     *	current document, not the form link. - FM
		     */
		    _statusline(HEAD_D_OR_CANCEL);
		    c = LYgetch();
		} else {
		    /*
		     *	No links, so we can just assume that
		     *	the user wants a HEAD request for the
		     *	current document. - FM
		     */
		    c = 'D';
		}
		if (TOUPPER(c) == 'D') {
		    char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
			curdoc.address : curdoc.address + 11;
		    /*
		     *	The user didn't cancel, so check if
		     *	a HEAD request is appropriate for the
		     *	current document. - FM
		     */
		    if (LYCanDoHEAD(scheme) != TRUE) {
			HTUserMsg(DOC_NOT_HTTP_URL);
		    } else {
			HEAD_request = TRUE;
			LYforce_no_cache = TRUE;
			StrAllocCopy(newdoc.title, curdoc.title);
			if (HTLoadedDocumentIsHEAD()) {
			    HTuncache_current_document();
			    FREE(curdoc.address);
			} else {
			    StrAllocCat(newdoc.title, " - HEAD");
			}
		    }
		}
	    }
d7343 1
a7343 4
	    if (user_mode == NOVICE_MODE) {
		toggle_novice_line();
		noviceline(more);
	    }
d7347 1
a7347 31
	    if (old_c != real_c) {
		old_c = real_c;
		StrAllocCopy(newdoc.address, "LYNXKEYMAP:");
		StrAllocCopy(newdoc.title, CURRENT_KEYMAP_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		/*
		 *  If vi_keys changed, the keymap did too,
		 *  so force no cache, and reset the flag. - FM
		 */
		if (vi_keys_flag != vi_keys ||
		    emacs_keys_flag != emacs_keys) {
		    LYforce_no_cache = TRUE;
		    vi_keys_flag = vi_keys;
		    emacs_keys_flag = emacs_keys;
		}
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
		/*
		 *  Remember whether we are in dired menu
		 *  so we can display the right keymap.
		 */
		if (!no_dired_support) {
		    prev_lynx_edit_mode = lynx_edit_mode;
		}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
		LYforce_no_cache = TRUE;
	    }
d7351 6
a7356 56
	    {
		char *ret;

		if (no_jump || JThead == NULL) {
		    if (old_c != real_c) {
			old_c = real_c;
			if (no_jump)
			    HTUserMsg(JUMP_DISALLOWED);
			else
			    HTUserMsg(NO_JUMPFILE);
		    }
		} else {
		    LYJumpFileURL = TRUE;
		    if ((ret = LYJump(c)) != NULL) {
#ifdef PERMIT_GOTO_FROM_JUMP
			if (!strncasecomp(ret, "Go ", 3)) {
			    LYJumpFileURL = FALSE;
			    StrAllocCopy(temp, user_input_buffer);
			    URLTotal = (Goto_URLs ?
			  HTList_count(Goto_URLs) : 0);
			    recall = ((URLTotal >= 1) ? RECALL : NORECALL);
			    URLNum = URLTotal;
			    FirstURLRecall = TRUE;
			    if (!strcasecomp(ret, "Go :")) {
				if (recall) {
				    ch = UPARROW;
				    goto check_recall;
				}
				FREE(temp);
				HTUserMsg(NO_RANDOM_URLS_YET);
				break;
			    }
			    ret = HTParse((ret+3), startfile, PARSE_ALL);
			    strcpy(user_input_buffer, ret);
			    FREE(ret);
			    goto check_recall;
			}
#endif /* PERMIT_GOTO_FROM_JUMP */
			ret = HTParse(ret, startfile, PARSE_ALL);
			if (!LYTrimStartfile(ret)) {
			    LYRemoveBlanks(user_input_buffer);
			}
			StrAllocCopy(newdoc.address, ret);
			StrAllocCopy(lynxjumpfile, ret);
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
			FREE(newdoc.bookmark);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
			newdoc.internal_link = FALSE;
			FREE(ret);
			LYUserSpecifiedURL = TRUE;
		    } else {
			LYJumpFileURL = FALSE;
		    }
		}
d7361 1
a7361 19
	    if (old_c != real_c) {
		old_c = real_c;
		if (HTConfirm(CLEAR_ALL_AUTH_INFO)) {
		    FREE(authentication_info[0]);
		    FREE(authentication_info[1]);
		    FREE(proxyauth_info[0]);
		    FREE(proxyauth_info[1]);
		    HTClearHTTPAuthInfo();
#ifndef DISABLE_NEWS
		    HTClearNNTPAuthInfo();
#endif
#ifndef DISABLE_FTP
		    HTClearFTPPassword();
#endif
		    HTUserMsg(AUTH_INFO_CLEARED);
		} else {
		    HTUserMsg(CANCELLED);
		}
	    }
d7366 17
a7382 1

a7386 82
/*
 *  Ask a post resubmission prompt with some indication of what would
 *  be resubmitted, useful especially for going backward in history.
 *  Try to use parts of the address or, if given, the title, depending
 *  on how much fits on the statusline.
 *  if_imgmap and if_file indicate how to handle an address that is
 *  a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 *  respectively: 0: auto-deny, 1: auto-confirm, 2: prompt.
 *  - kw
 */

PRIVATE BOOL confirm_post_resub ARGS4(
    CONST char*,	address,
    CONST char*,	title,
    int,		if_imgmap,
    int,		if_file)
{
    size_t len1;
    CONST char *msg = CONFIRM_POST_RESUBMISSION_TO;
    char buf[240];
    char *temp = NULL;
    BOOL res;
    size_t maxlen = LYcols - 6;
    if (!address) {
	return(NO);
    } else if (!strncmp(address, "LYNXIMGMAP:", 11)) {
	if (if_imgmap <= 0)
	    return(NO);
	else if (if_imgmap == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (!strncmp(address, "file:", 5)) {
	if (if_file <= 0)
	    return(NO);
	else if (if_file == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (dump_output_immediately) {
	return(NO);
    }
    if (maxlen >= sizeof(buf))
	maxlen = sizeof(buf) - 1;
    if ((len1 = strlen(msg)) +
	strlen(address) <= maxlen) {
	sprintf(buf, msg, address);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST+PARSE_PATH
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if (title && (len1 + strlen(title) <= maxlen)) {
	sprintf(buf, msg, title);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if ((temp = HTParse(address, "", PARSE_HOST)) && *temp &&
	len1 + strlen(temp) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    return HTConfirm(CONFIRM_POST_RESUBMISSION);
}

d7388 2
a7389 2
	document *,	doc1,
	document *,	doc2)
d7410 2
a7411 4
    if ((cp1 = strchr(doc1->address, '#')) != NULL)
	*cp1 = '\0';
    if ((cp2 = strchr(doc2->address, '#')) != NULL)
	*cp2 = '\0';
d7415 3
a7417 6
    if (strcmp(doc1->address, doc2->address))
      {
	if (cp1)
	    *cp1 = '#';
	if (cp2)
	    *cp2 = '#';
d7419 3
a7421 5
      }
    if (cp1)
	*cp1 = '#';
    if (cp2)
	*cp2 = '#';
d7426 3
a7428 5
    if (doc1->post_data)
      {
	if (doc2->post_data)
	  {
	    if (strcmp(doc1->post_data, doc2->post_data))
d7430 1
a7430 6
	  }
	else
	    return(TRUE);
      }
    else
	if (doc2->post_data)
d7432 2
d7446 2
a7447 2
	document *,	doc1,
	document *,	doc2)
d7466 4
a7469 4
    if (0==strncmp(doc1->address, "LYNXIMGMAP:", 11))
	ap1 += 11;
    if (0==strncmp(doc2->address, "LYNXIMGMAP:", 11))
	ap2 += 11;
d7483 2
a7484 4
    if ((cp1 = strchr(doc1->address, '#')) != NULL)
	*cp1 = '\0';
    if ((cp2 = strchr(doc2->address, '#')) != NULL)
	*cp2 = '\0';
d7488 3
a7490 6
    if (strcmp(ap1, ap2))
      {
	if (cp1)
	    *cp1 = '#';
	if (cp2)
	    *cp2 = '#';
d7492 3
a7494 5
      }
    if (cp1)
	*cp1 = '#';
    if (cp2)
	*cp2 = '#';
d7499 3
a7501 5
    if (doc1->post_data)
      {
	if (doc2->post_data)
	  {
	    if (strcmp(doc1->post_data, doc2->post_data))
d7503 1
a7503 6
	  }
	else
	    return(TRUE);
      }
    else
	if (doc2->post_data)
d7505 2
d7518 2
a7519 1
PUBLIC void HTGotoURLs_free NOARGS
d7524 6
a7529 5
    if (!cur)
	return;

    while (NULL != (url = (char *)HTList_nextObject(cur))) {
	FREE(url);
a7530 3
    HTList_delete(Goto_URLs);
    Goto_URLs = NULL;
    return;
d7532 1
d7541 1
a7541 1
    char *new;
d7548 2
a7549 3
    if ((new = (char *)calloc(1, (strlen(url) + 1))) == NULL)
	outofmem(__FILE__, "HTAddGotoURL");
    strcpy(new, url);
d7578 3
a7580 3
PRIVATE void print_status_message ARGS2(
	CONST linkstruct,	curlink,
	char **,		cp)
d7585 1
a7585 1
    if (user_mode == NOVICE_MODE) {
a7588 4
    /*
     *	If we are in forms mode then explicitly
     *	tell the user what each kind of link is.
     */
d7595 4
d7612 1
a7612 103
	    switch(curlink.form->type) {
	    case F_PASSWORD_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_PASSWORD_UNM_MSG);
		else
		    statusline(FORM_LINK_PASSWORD_MESSAGE);
		break;
	    case F_OPTION_LIST_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
		else
		    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		break;
	    case F_CHECKBOX_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
		else
		    statusline(FORM_LINK_CHECKBOX_MESSAGE);
		break;
	    case F_RADIO_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_RADIO_UNM_MSG);
		else
		    statusline(FORM_LINK_RADIO_MESSAGE);
		break;
	    case F_TEXT_SUBMIT_TYPE:
		if (curlink.form->disabled == YES) {
		    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
		} else if (curlink.form->submit_method ==
			 URL_MAIL_METHOD) {
		    if (no_mail)
			statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
		    else
			statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
		} else if (curlink.form->no_cache) {
		    statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
		} else {
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
		}
		break;
	    case F_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if (curlink.form->disabled == YES) {
		    statusline(FORM_LINK_SUBMIT_DIS_MSG);
		} else if (curlink.form->submit_method ==
			 URL_MAIL_METHOD) {
		    if (no_mail) {
			statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
		    } else {
			if(user_mode == ADVANCED_MODE) {
			    char *submit_str = NULL;

			    StrAllocCopy(submit_str, FORM_LINK_SUBMIT_MAILTO_PREFIX);
			    StrAllocCat(submit_str, curlink.form->submit_action);
			    statusline(submit_str);
			    FREE(submit_str);
			} else {
			    statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
			}
		    }
		} else if (curlink.form->no_cache) {
		    if(user_mode == ADVANCED_MODE) {
			char *submit_str = NULL;

			StrAllocCopy(submit_str, FORM_LINK_RESUBMIT_PREFIX);
			StrAllocCat(submit_str, curlink.form->submit_action);
			statusline(submit_str);
			FREE(submit_str);
		    } else {
			statusline(FORM_LINK_RESUBMIT_MESSAGE);
		    }
		} else {
		    if(user_mode == ADVANCED_MODE) {
			char *submit_str = NULL;

			StrAllocCopy(submit_str, FORM_LINK_SUBMIT_PREFIX);
			StrAllocCat(submit_str, curlink.form->submit_action);
			statusline(submit_str);
			FREE(submit_str);
		    } else {
			statusline(FORM_LINK_SUBMIT_MESSAGE);
		    }
		}
		break;
	    case F_RESET_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_RESET_DIS_MSG);
		else
		    statusline(FORM_LINK_RESET_MESSAGE);
		break;
	    case F_TEXT_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_TEXT_UNM_MSG);
		else
		    statusline(FORM_LINK_TEXT_MESSAGE);
		break;
	    case F_TEXTAREA_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_TEXT_UNM_MSG);
		else
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
		break;
	    }
d7621 2
a7622 1
	    move(LYlines-1, LYcols-8);
d7624 1
a7624 1
	    addstr("-index-");
d7632 2
a7633 1
	*cp = NULL;
d7635 2
a7636 16
	    strncmp(curlink.lname, "LYNXIMGMAP:", 11)) {
	    *cp = strchr(curlink.lname, '#');
	}
	if (!(*cp))
	    *cp = curlink.lname;
	if (more) {
	    if (is_www_index)
		_user_message("-more- -index- %s",
					 *cp);
	    else
		_user_message("-more- %s",*cp);
	} else {
	    if (is_www_index)
		_user_message("-index- %s",*cp);
	    else
		statusline(*cp);
d7638 3
d7653 1
a7653 1
		_statusline(MORE);
d7655 1
a7655 1
		_statusline(MOREHELP);
d7659 1
d7661 19
a7679 1
    move((LYlines - 1), (LYcols - 1));
d7682 32
d7730 1
a7730 1
		   buf2,
d7736 2
a7737 1
		   strstr(buf2, gettext("Can't Access")) ? "" : startfile);
d7743 1
a7743 1
		   buf2,
d7755 1
a7755 1
	fprintf(stderr, buf);
d7760 1
a7760 1
	printf(buf);
d7767 28
a7794 1
	exit_immediately(-1);
d7796 56
a7851 1
    /* else: return(-1) in mainloop */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a2 1
#include <HTParse.h>
d41 1
a41 98
#ifdef KANJI_CODE_OVERRIDE
#include <HTCJK.h>
#endif

#ifdef KANJI_CODE_OVERRIDE
char *str_kcode(HTkcode code)
{
    char *p;
    static char buff[8];

    if (current_char_set == TRANSPARENT) {
	p = "THRU";
    } else if (!LYRawMode) {
	p = "RAW";
    } else {
	switch (code) {
	case NOKANJI:
	    p = "AUTO";
	    break;

	case EUC:
	    p = "EUC+";
	    break;

	case SJIS:
	    p = "SJIS";
	    break;

	case JIS:
	    p = " JIS";
	    break;

	default:
	    p = " ???";
	    break;
	}
    }

    if (no_table_center) {
	buff[0] = '!';
	strcpy(buff + 1, p);
    } else {
	strcpy(buff, p);
    }

    return buff;
}
#endif

#ifdef WIN_EX

static char *str_sjis(char *to, char *from)
{
    if (!LYRawMode) {
	strcpy(to, from);
#ifdef KANJI_CODE_OVERRIDE
    } else if (last_kcode == EUC) {
	EUC_TO_SJIS(from, to);
    } else if (last_kcode == SJIS) {
	strcpy(to, from);
#endif
    } else {
	TO_SJIS(from, to);
    }
    return to;
}

static void set_ws_title(char *str)
{
    SetConsoleTitle(str);
}

#endif /* WIN_EX */

#ifdef SH_EX			/* 1998/10/30 (Fri) 10:06:47 */

#define NOT_EQU	1

static int str_n_cmp(const char *p, const char *q, int n)
{
    if (n == 0)
	return 0;

    if (p == NULL)
	return NOT_EQU;

    if (q == NULL)
	return NOT_EQU;

    return strncmp(p, q, n);
}

#undef strncmp
#define	strncmp(p, q, r)	str_n_cmp(p, q, r)

#endif /* SH_EX */

#if defined(USE_EXTERNALS) || defined(WIN_EX)
a56 12
/* two constants: */
HTLinkType *HTInternalLink = 0;
HTAtom *WWW_SOURCE = 0;

#ifndef DONT_TRACK_INTERNAL_LINKS
#define NO_INTERNAL_OR_DIFFERENT(c,n) TRUE
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) (!curdoc.internal_link || \
			   are_phys_different(p,n))
#else /* TRACK_INTERNAL_LINKS */
#define NO_INTERNAL_OR_DIFFERENT(c,n) are_different(c,n)
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) are_different(p,n)
#endif /* TRACK_INTERNAL_LINKS */
d58 10
a67 5
static void exit_immediately_with_error_message(int state, BOOLEAN first_file);
static void status_link(char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx);
static void show_main_statusline(const LinkInfo curlink, int for_what);
static void form_noviceline(int);
static int are_different(DocInfo *doc1, DocInfo *doc2);
d70 1
a70 1
static int are_phys_different(DocInfo *doc1, DocInfo *doc2);
d75 3
a77 2
static int sametext(char *een,
		    char *twee)
d84 1
a84 4
HTList *Goto_URLs = NULL;	/* List of Goto URLs */

char *LYRequestTitle = NULL;	/* newdoc.title in calls to getfile() */
char *LYRequestReferer = NULL;	/* Referer, may be set in getfile() */
d86 1
a86 1
static char prev_target[512];
d89 4
a92 15
BOOLEAN display_partial = FALSE;	/* could be enabled in HText_new() */
int NumOfLines_partial = 0;	/* number of lines displayed in partial mode */
#endif

static int Newline = 0;
static DocInfo newdoc;
static DocInfo curdoc;
static char *traversal_host = NULL;
static char *traversal_link_to_add = NULL;
static char *owner_address = NULL;	/* Holds the responsible owner's address     */
static char *ownerS_address = NULL;	/* Holds owner's address during source fetch */

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
static BOOL textinput_activated = FALSE;

d94 1
a94 1
#define textinput_activated TRUE	/* a current text input is always active */
a95 2
#ifdef INACTIVE_INPUT_STYLE_VH
BOOL textinput_redrawn = FALSE;
d97 4
a100 2
    /*must be public since used in LYhighlight(..) */
#endif
d104 1
a104 1
 * Function for freeing allocated mainloop() variables.  - FM
d106 1
a106 1
static void free_mainloop_variables(void)
d108 11
a118 4
    LYFreeDocInfo(&newdoc);
    LYFreeDocInfo(&curdoc);

#ifdef USE_COLOR_STYLE
a123 2
    FREE(owner_address);
    FREE(ownerS_address);
a125 1
    reset_dired_menu();
a126 2
    FREE(WWW_Download_File);	/* LYGetFile.c/HTFWriter.c */
    FREE(LYRequestReferer);
d132 9
a140 2
#ifndef NO_LYNX_TRACE
static void TracelogOpenFailed(void)
d147 1
a147 37
	exit_immediately(EXIT_FAILURE);
    }
}

static BOOLEAN LYReopenTracelog(BOOLEAN *trace_flag_ptr)
{
    CTRACE((tfp, "\nTurning off TRACE for fetch of log.\n"));
    LYCloseTracelog();
    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
	TracelogOpenFailed();
	return FALSE;
    }
    if (TRACE) {
	WWW_TraceFlag = FALSE;
	*trace_flag_ptr = TRUE;
    }
    return TRUE;
}

static void turn_trace_back_on(BOOLEAN *trace_flag_ptr)
{
    if (*trace_flag_ptr == TRUE) {
	WWW_TraceFlag = TRUE;
	*trace_flag_ptr = FALSE;
	fprintf(tfp, "Turning TRACE back on.\n\n");
    }
}
#else
#define LYReopenTracelog(flag) TRUE
#define turn_trace_back_on(flag)	/*nothing */
#endif /* NO_LYNX_TRACE */

FILE *TraceFP(void)
{
#ifndef NO_LYNX_TRACE
    if (LYTraceLogFP != 0) {
	return LYTraceLogFP;
a148 2
#endif /* NO_LYNX_TRACE */
    return stderr;
d151 1
a151 1
BOOLEAN LYOpenTraceLog(void)
a152 1
#ifndef NO_LYNX_TRACE
d175 2
a176 5
	 * If TRACE is on, indicate whether the anonymous restrictions are set. 
	 * - FM, LP, kw
	 *
	 * This is only a summary for convenience - it doesn't take the case of
	 * individual -restrictions= options into account.  - kw
d178 2
a179 29
	if (LYValidate) {
	    if (LYRestricted && had_restrictions_default) {
		CTRACE((tfp,
			"Validate and some anonymous restrictions are set.\n"));
	    } else if (had_restrictions_default) {
		CTRACE((tfp,
			"Validate restrictions set, restriction \"default\" was given.\n"));
	    } else if (LYRestricted) {
		CTRACE((tfp,
			"Validate restrictions set, additional anonymous restrictions ignored.\n"));
	    } else {
		CTRACE((tfp, "Validate restrictions are set.\n"));
	    }
	    /* But none of the above can actually happen, since there should
	     * never be a Trace Log with -validate.  If it appears in a log
	     * file something went wrong! */
	} else if (LYRestricted) {
	    if (had_restrictions_all) {
		CTRACE((tfp,
			"Anonymous restrictions set, restriction \"all\" was given.\n"));
	    } else {
		CTRACE((tfp, "Anonymous restrictions are set.\n"));
	    }
	} else if (had_restrictions_all && had_restrictions_default) {
	    CTRACE((tfp, "Restrictions \"all\" and \"default\" were given.\n"));
	} else if (had_restrictions_default) {
	    CTRACE((tfp, "Restriction \"default\" was given.\n"));
	} else if (had_restrictions_all) {
	    CTRACE((tfp, "\"all\" restrictions are set.\n"));
a181 1
#endif /* NO_LYNX_TRACE */
d185 1
a185 1
void LYCloseTracelog(void)
a186 1
#ifndef NO_LYNX_TRACE
a192 1
#endif /* NO_LYNX_TRACE */
d195 1
a195 1
void handle_LYK_TRACE_TOGGLE(void)
d197 11
a207 7
#ifndef NO_LYNX_TRACE
    WWW_TraceFlag = !WWW_TraceFlag;
    if (LYOpenTraceLog())
	HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
d210 2
a211 1
void LYSetNewline(int value)
d213 7
a219 6
    Newline = value;
}

int LYGetNewline(void)
{
    return Newline;
a221 3
#ifdef USE_SOURCE_CACHE
static BOOLEAN from_source_cache = FALSE;

d223 6
a228 1
 * Like HTreparse_document(), but also set the flag.
d230 2
a231 1
static BOOLEAN reparse_document(void)
d233 33
a265 1
    BOOLEAN ok;
d267 4
a270 9
    from_source_cache = TRUE;	/* set for LYMainLoop_pageDisplay() */
    if ((ok = HTreparse_document()) != FALSE) {
	from_source_cache = TRUE;	/* set for mainloop refresh */
	return ok;
    }
    from_source_cache = FALSE;
    return ok;
}
#endif /* USE_SOURCE_CACHE */
d273 6
a278 2
 * Prefer reparsing if we can, but reload if we must - to force regeneration
 * of the display.
d280 21
a300 6
static BOOLEAN reparse_or_reload(int *cmd)
{
#ifdef USE_SOURCE_CACHE
    if (reparse_document()) {
	return FALSE;
    }
d302 9
a310 3
    *cmd = LYK_RELOAD;
    return TRUE;
}
d312 7
a318 7
/*
 * Functions for setting the current address
 */
static void set_address(DocInfo *doc, const char *address)
{
    StrAllocCopy(doc->address, address);
}
d320 7
a326 4
static void copy_address(DocInfo *dst, DocInfo *src)
{
    StrAllocCopy(dst->address, src->address);
}
d328 33
a360 4
static void free_address(DocInfo *doc)
{
    FREE(doc->address);
}
d362 2
a363 5
static void move_address(DocInfo *dst, DocInfo *src)
{
    copy_address(dst, src);
    free_address(src);
}
d365 4
a368 11
#ifdef DISP_PARTIAL
/*
 * This is for traversal call from within partial mode in LYUtils.c
 * and HTFormat.c  It simply calls HText_pageDisplay() but utilizes
 * LYMainLoop.c static variables to manage proper newline position
 * in case of #fragment
 */
BOOL LYMainLoop_pageDisplay(int line_num)
{
    const char *pound;
    int prev_newline = Newline;
d370 3
a372 14
    /*
     * Override Newline with a new value if user scrolled the document while
     * loading (in LYUtils.c).
     */
    Newline = line_num;

#ifdef USE_SOURCE_CACHE
    /*
     * reparse_document() acts on 'curdoc' which always on top of the
     * history stack: no need to resolve #fragment position since
     * we already know it (curdoc.line).
     * So bypass here. Sorry for possible confusion...
     */
    if (!from_source_cache)
d375 2
a376 6
	 * If the requested URL has the #fragment, and we are not popped
	 * from the history stack, and have not scrolled the document yet -
	 * we should calculate correct newline position for the fragment.
	 * (This is a bit suboptimal since HTFindPoundSelector() traverse
	 * anchors list each time, so we have a quadratic complexity
	 * and may load CPU in a worst case).
d378 2
a379 12
	if (display_partial
	    && newdoc.line == 1 && line_num == 1 && prev_newline == 1
	    && (pound = findPoundSelector(newdoc.address))
	    && *pound && *(pound + 1)) {
	    if (HTFindPoundSelector(pound + 1)) {
		/* HTFindPoundSelector will initialize www_search_result */
		Newline = www_search_result;
	    } else {
		Newline = prev_newline;		/* restore ??? */
		return NO;	/* no repaint */
	    }
	}
d381 33
a413 4
    HText_pageDisplay(Newline, prev_target);
    return YES;
}
#endif /* DISP_PARTIAL */
a414 3
static BOOL set_curdoc_link(int nextlink)
{
    BOOL result = FALSE;
d416 8
a423 11
    if (curdoc.link != nextlink
	&& nextlink >= 0
	&& nextlink < nlinks) {
	if (curdoc.link >= 0 && curdoc.link < nlinks) {
	    LYhighlight(OFF, curdoc.link, prev_target);
	    result = TRUE;
	}
	curdoc.link = nextlink;
    }
    return result;
}
a424 10
/*
 * Setup newdoc to jump to the given line.
 *
 * FIXME: prefer to also jump to the link given in a URL fragment, but the
 * interface of getfile() does not provide that ability yet.
 */
static void goto_line(int nextline)
{
    int n;
    int old_link = newdoc.link;
d426 34
a459 162
    newdoc.link = 0;
    for (n = 0; n < nlinks; ++n) {
	if (nextline == links[n].anchor_line_num + 1) {
	    CTRACE((tfp, "top_of_screen %d\n", HText_getTopOfScreen() + 1));
	    CTRACE((tfp, "goto_line(%d) -> link %d -> %d\n", nextline,
		    old_link, n));
	    newdoc.link = n;
	    break;
	}
    }
}

#ifdef USE_MOUSE
static void set_curdoc_link_by_mouse(int nextlink)
{
    if (set_curdoc_link(nextlink)) {
	LYhighlight(ON, nextlink, prev_target);
	LYmsec_delay(20);
    }
}
#else
#define set_curdoc_link_by_mouse(nextlink) set_curdoc_link(nextlink)
#endif

static int do_change_link(void)
{
#ifdef USE_MOUSE
    /* Is there a mouse-clicked link waiting? */
    int mouse_tmp = get_mouse_link();

    /* If yes, use it as the link */
    if (mouse_tmp != -1) {
	if (mouse_tmp < 0 || mouse_tmp >= nlinks) {
	    char *msgtmp = NULL;

	    HTSprintf0(&msgtmp,
		       gettext("Internal error: Invalid mouse link %d!"),
		       mouse_tmp);
	    HTAlert(msgtmp);
	    FREE(msgtmp);
	    return (-1);	/* indicates unexpected error */
	}
	set_curdoc_link_by_mouse(mouse_tmp);
    }
#endif /* USE_MOUSE */
    return (0);			/* indicates OK */
}

#ifdef DIRED_SUPPORT
#define DIRED_UNCACHE_1 if (LYAutoUncacheDirLists < 1) /*nothing*/ ;\
			else HTuncache_current_document()
#define DIRED_UNCACHE_2 if (LYAutoUncacheDirLists < 2) /*nothing*/ ;\
			else HTuncache_current_document()
#endif /* DIRED_SUPPORT */

static void do_check_goto_URL(char *user_input_buffer,
			      char **old_user_input,
			      BOOLEAN *force_load)
{
    static BOOLEAN always = TRUE;
    /* *INDENT-OFF* */
    static struct {
	const char *name;
	BOOLEAN *flag;
    } table[] = {
	{ STR_FILE_URL,		&no_file_url },
	{ STR_FILE_URL,		&no_goto_file },
	{ STR_LYNXEXEC,		&no_goto_lynxexec },
	{ STR_LYNXPROG,		&no_goto_lynxprog },
	{ STR_LYNXCGI,		&no_goto_lynxcgi },
	{ STR_CSO_URL,		&no_goto_cso },
	{ STR_FINGER_URL,	&no_goto_finger },
	{ STR_FTP_URL,		&no_goto_ftp },
	{ STR_GOPHER_URL,	&no_goto_gopher },
	{ STR_HTTP_URL,		&no_goto_http },
	{ STR_HTTPS_URL,	&no_goto_https },
	{ STR_MAILTO_URL,	&no_goto_mailto },
	{ STR_RLOGIN_URL,	&no_goto_rlogin },
	{ STR_TELNET_URL,	&no_goto_telnet },
	{ STR_TN3270_URL,	&no_goto_tn3270 },
	{ STR_WAIS_URL,		&no_goto_wais },
#ifndef DISABLE_BIBP
	{ STR_BIBP_URL,		&no_goto_bibp },
#endif
#ifndef DISABLE_NEWS
	{ STR_NEWS_URL,		&no_goto_news },
	{ STR_NNTP_URL,		&no_goto_nntp },
	{ STR_SNEWS_URL,	&no_goto_snews },
#endif
#ifdef EXEC_LINKS
	{ STR_LYNXEXEC,		&local_exec_on_local_files },
	{ STR_LYNXPROG,		&local_exec_on_local_files },
#endif /* EXEC_LINKS */
	{ STR_LYNXCFG,		&no_goto_configinfo },
	{ STR_LYNXCFLAGS,	&no_goto_configinfo },
	{ STR_LYNXCOOKIE,	&always },
	{ STR_LYNXDIRED,	&always },
	{ STR_LYNXDOWNLOAD,	&always },
	{ STR_LYNXOPTIONS,	&always },
	{ STR_LYNXPRINT,	&always },
    };
    /* *INDENT-ON* */

    unsigned n;
    BOOLEAN found = FALSE;

    /* allow going to anchors */
    if (*user_input_buffer == '#') {
	if (user_input_buffer[1] &&
	    HTFindPoundSelector(user_input_buffer + 1)) {
	    /* HTFindPoundSelector will initialize www_search_result,
	       so we do nothing else. */
	    HTAddGotoURL(user_input_buffer);
	    trimPoundSelector(curdoc.address);
	    StrAllocCat(curdoc.address, user_input_buffer);
	}
    } else {
	/*
	 * If it's not a URL then make it one.
	 */
	StrAllocCopy(*old_user_input, user_input_buffer);
	LYEnsureAbsoluteURL(old_user_input, "", TRUE);
	sprintf(user_input_buffer, "%.*s",
		(int) (MAX_LINE - 1), *old_user_input);
	FREE(*old_user_input);

	for (n = 0; n < TABLESIZE(table); n++) {
	    if (*(table[n].flag)
		&& !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
		found = TRUE;
		HTUserMsg2(GOTO_XXXX_DISALLOWED, table[n].name);
		break;
	    }
	}
	if (found) {
	    ;
	} else if (LYValidate &&
		   !isHTTP_URL(user_input_buffer) &&
		   !isHTTPS_URL(user_input_buffer)) {
	    HTUserMsg(GOTO_NON_HTTP_DISALLOWED);

	} else {
	    set_address(&newdoc, user_input_buffer);
	    newdoc.isHEAD = FALSE;
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * dont't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		/*
		 * Make a name for this new URL.
		 */
		StrAllocCopy(newdoc.title,
			     gettext("A URL specified by the user"));
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		*force_load = TRUE;
#ifdef DIRED_SUPPORT
		if (lynx_edit_mode) {
		    DIRED_UNCACHE_2;
d461 1
a461 7
#endif /* DIRED_SUPPORT */
	    }
	    LYUserSpecifiedURL = TRUE;
	    HTAddGotoURL(newdoc.address);
	}
    }
}
d463 1
a463 83
/* returns FALSE if user cancelled input or URL was invalid, TRUE otherwise */
static BOOL do_check_recall(int ch,
			    char *user_input_buffer,
			    char **old_user_input,
			    int URLTotal,
			    int *URLNum,
			    RecallType recall,
			    BOOLEAN *FirstURLRecall)
{
    char *cp;
    BOOL ret = FALSE;

    if (*old_user_input == 0)
	StrAllocCopy(*old_user_input, "");

    for (;;) {
#ifdef WIN_EX			/* 1998/10/11 (Sun) 10:41:05 */
	int len = strlen(user_input_buffer);

	if (len >= 3) {
	    if (len < MAX_LINE - 1
		&& LYIsHtmlSep(user_input_buffer[len - 3])
		&& LYIsDosDrive(user_input_buffer + len - 2))
		LYAddPathSep0(user_input_buffer);

	} else if (len == 2 && user_input_buffer[1] == ':') {
	    if (LYIsDosDrive(user_input_buffer)) {
		LYAddPathSep0(user_input_buffer);
	    } else {
		HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
		LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		FREE(*old_user_input);
		ret = FALSE;
		break;
	    }
	}
#endif
	/*
	 * Get rid of leading spaces (and any other spaces).
	 */
	LYTrimAllStartfile(user_input_buffer);
	if (*user_input_buffer == '\0' &&
	    !(recall && (ch == UPARROW || ch == DNARROW))) {
	    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	    FREE(*old_user_input);
	    HTInfoMsg(CANCELLED);
	    ret = FALSE;
	    break;
	}
	if (recall && ch == UPARROW) {
	    if (*FirstURLRecall) {
		/*
		 * Use last URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = 0;
	    } else {
		/*
		 * Go back to the previous URL in the list.  - FM
		 */
		*URLNum += 1;
	    }
	    if (*URLNum >= URLTotal)
		/*
		 * Roll around to the last URL in the list.  - FM
		 */
		*URLNum = 0;
	    if ((cp = (char *) HTList_objectAt(Goto_URLs,
					       *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer
		    && **old_user_input
		    && !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
d465 1
a465 2
		     * User cancelled the Goto via ^G.  Restore
		     * user_input_buffer and break.  - FM
d467 15
a481 5
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
d483 1
a483 4
		continue;
	    }
	} else if (recall && ch == DNARROW) {
	    if (*FirstURLRecall) {
d485 27
a511 25
		 * Use the first URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = URLTotal - 1;
	    } else {
		/*
		 * Advance to the next URL in the list.  - FM
		 */
		*URLNum -= 1;
	    }
	    if (*URLNum < 0)
		/*
		 * Roll around to the first URL in the list.  - FM
		 */
		*URLNum = URLTotal - 1;
	    if ((cp = (char *) HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer && **old_user_input &&
		    !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
d513 10
a522 12
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
		    /*
		     * User cancelled the Goto via ^G.  Restore
		     * user_input_buffer and break.  - FM
		     */
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
a523 9
		continue;
	    }
	} else {
	    ret = TRUE;
	    break;
	}
    }
    return ret;
}
d525 28
a552 36
static void do_cleanup_after_delete(void)
{
    HTuncache_current_document();
    move_address(&newdoc, &curdoc);
    newdoc.line = curdoc.line;
    if (curdoc.link == nlinks - 1) {
	/*
	 * We deleted the last link on the page.  - FM
	 */
	newdoc.link = curdoc.link - 1;
    } else {
	newdoc.link = curdoc.link;
    }
}

static int find_link_near_col(int col,
			      int delta)
{
    int i;

    for (i = curdoc.link; delta > 0 ? (i < nlinks) : (i >= 0); i += delta) {
	if ((links[i].ly - links[curdoc.link].ly) * delta > 0) {
	    int cy = links[i].ly, best = -1, dist = 1000000;

	    while ((delta > 0 ? (i < nlinks) : (i >= 0)) && cy == links[i].ly) {
		int cx = links[i].lx;
		const char *text = LYGetHiliteStr(i, 0);

		if (text != NULL)
		    cx += strlen(text) / 2;
		cx -= col;
		if (cx < 0)
		    cx = -cx;
		if (cx < dist) {
		    dist = cx;
		    best = i;
d554 17
a570 56
		i += delta;
	    }
	    return (best);
	}
    }
    return (-1);
}

/*
 * This is a special feature to traverse every http link derived from startfile
 * and check for errors or create crawl output files.  Only URL's that begin
 * with "traversal_host" are searched - this keeps the search from crossing to
 * other servers (a feature, not a bug!).
 */
static int DoTraversal(int c,
		       BOOLEAN *crawl_ok)
{
    BOOLEAN rlink_rejected = FALSE;
    BOOLEAN rlink_exists;
    BOOLEAN rlink_allowed;

    rlink_exists = (BOOL) (nlinks > 0 &&
			   links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
			   links[curdoc.link].lname != NULL);

    if (rlink_exists) {
	rlink_rejected = lookup_reject(links[curdoc.link].lname);
	if (!rlink_rejected &&
	    traversal_host &&
	    links[curdoc.link].lname) {
	    if (!isLYNXIMGMAP(links[curdoc.link].lname)) {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
						links[curdoc.link].lname,
						strlen(traversal_host));
	    } else {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
						links[curdoc.link].lname + LEN_LYNXIMGMAP,
						strlen(traversal_host));
	    }
	} else {
	    rlink_allowed = FALSE;
	}
    } else {
	rlink_allowed = FALSE;
    }
    if (rlink_exists && rlink_allowed) {
	if (lookup_link(links[curdoc.link].lname)) {
	    if (more_links ||
		(curdoc.link > -1 && curdoc.link < nlinks - 1)) {
		c = DNARROW;
	    } else {
		if (STREQ(curdoc.title, "Entry into main screen") ||
		    (nhist <= 0)) {
		    if (!dump_output_immediately) {
			cleanup();
			exit_immediately(EXIT_FAILURE);
a571 1
		    c = -1;
d573 17
a589 1
		    c = LTARROW;
d591 3
a593 38
	    }
	} else {
	    StrAllocCopy(traversal_link_to_add,
			 links[curdoc.link].lname);
	    if (!isLYNXIMGMAP(traversal_link_to_add))
		*crawl_ok = TRUE;
	    c = RTARROW;
	}
    } else {			/* no good right link, so only down and left arrow ok */
	if (rlink_exists /* && !rlink_rejected */ )
	    /* uncomment in previous line to avoid duplicates - kw */
	    add_to_reject_list(links[curdoc.link].lname);
	if (more_links ||
	    (curdoc.link > -1 && curdoc.link < nlinks - 1)) {
	    c = DNARROW;
	} else {
	    /*
	     * curdoc.title doesn't always work, so bail out if the history
	     * list is empty.
	     */
	    if (STREQ(curdoc.title, "Entry into main screen") ||
		(nhist <= 0)) {
		if (!dump_output_immediately) {
		    cleanup();
		    exit_immediately(EXIT_FAILURE);
		}
		c = -1;
	    } else {
		c = LTARROW;
	    }
	}
    }
    CTRACE((tfp, "DoTraversal(%d:%d) -> %s\n",
	    nlinks > 0 ? curdoc.link : 0,
	    nlinks,
	    LYKeycodeToString(c, FALSE)));
    return c;
}
d595 1
a595 4
#ifndef DONT_TRACK_INTERNAL_LINKS
static BOOLEAN check_history(void)
{
    const char *base;
d597 31
a627 5
    if (!curdoc.post_data)
	/*
	 * Normal case - List Page is not associated with post data.  - kw
	 */
	return TRUE;
d629 12
a640 25
    if (nhist > 0
	&& !LYresubmit_posts
	&& HDOC(nhist - 1).post_data
	&& BINEQ(curdoc.post_data, HDOC(nhist - 1).post_data)
	&& (base = HText_getContentBase()) != 0) {
	char *text = !isLYNXIMGMAP(HDOC(nhist - 1).address)
	? HDOC(nhist - 1).address
	: HDOC(nhist - 1).address + LEN_LYNXIMGMAP;

	if (!strncmp(base, text, strlen(base))) {
	    /*
	     * Normal case - as best as we can check, the document at the top
	     * of the history stack seems to be the document the List Page is
	     * about (or a LYNXIMGMAP derived from it), and LYresubmit_posts is
	     * not set, so don't prompt here.  If we actually have to repeat a
	     * POST because, against expectations, the underlying document
	     * isn't cached any more, HTAccess will prompt for confirmation,
	     * unless we had LYK_NOCACHE -kw
	     */
	    return TRUE;
	}
    }
    return FALSE;
}
#endif
d642 12
a653 17
static int handle_LYK_ACTIVATE(int *c,
			       int cmd GCC_UNUSED,
			       BOOLEAN *try_internal GCC_UNUSED,
			       BOOLEAN *refresh_screen,
			       BOOLEAN *force_load,
			       int real_cmd)
{
    if (do_change_link() == -1) {
	LYforce_no_cache = FALSE;
	reloading = FALSE;
	return 1;		/* mouse stuff was confused, ignore - kw */
    }
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (real_cmd == LYK_ACTIVATE && textfields_need_activation &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {
d655 15
a669 20
		textinput_activated = TRUE;
		show_main_statusline(links[curdoc.link], FOR_INPUT);
		textfields_need_activation = textfields_activation_option;

		return 0;
	    }
#endif
	    /*
	     * Don't try to submit forms with bad actions.  - FM
	     */
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type ==
		F_TEXT_SUBMIT_TYPE) {
		/*
		 * Do nothing if it's disabled.  - FM
		 */
		if (links[curdoc.link].l_form->disabled == YES) {
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
d671 25
a695 664
		    return 0;
		}
		/*
		 * Make sure we have an action.  - FM
		 */
		if (!links[curdoc.link].l_form->submit_action ||
		    *links[curdoc.link].l_form->submit_action
		    == '\0') {
		    HTUserMsg(NO_FORM_ACTION);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Check for no_mail if the form action is a mailto URL.  - FM
		 */
		if (links[curdoc.link].l_form->submit_method
		    == URL_MAIL_METHOD && no_mail) {
		    HTAlert(FORM_MAILTO_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure this isn't a spoof in an account with restrictions
		 * on file URLs.  - FM
		 */
		if (no_file_url &&
		    isFILE_URL(links[curdoc.link].l_form->submit_action)) {
		    HTAlert(FILE_ACTIONS_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure this isn't a spoof attempt via an internal URL.  -
		 * FM
		 */
		if (isLYNXCOOKIE(links[curdoc.link].l_form->submit_action) ||
#ifdef DIRED_SUPPORT
#ifdef OK_PERMIT
		    (isLYNXDIRED(links[curdoc.link].l_form->submit_action) &&
		     (no_dired_support ||
		      strncasecomp((links[curdoc.link].l_form->submit_action
				    + 10),
				   "//PERMIT_LOCATION", 17) ||
		      !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS))) ||
#else
		    isLYNXDIRED(links[curdoc.link].l_form->submit_action) ||
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
		    isLYNXDOWNLOAD(links[curdoc.link].l_form->submit_action) ||
		    isLYNXHIST(links[curdoc.link].l_form->submit_action) ||
		    isLYNXKEYMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXIMGMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPRINT(links[curdoc.link].l_form->submit_action) ||
		    isLYNXEXEC(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPROG(links[curdoc.link].l_form->submit_action)) {

		    HTAlert(SPECIAL_ACTION_DISALLOWED);
		    CTRACE((tfp, "LYMainLoop: Rejected '%s'\n",
			    links[curdoc.link].l_form->submit_action));
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
#ifdef NOTDEFINED		/* We're disabling form inputs instead of using this. - FM */
		/*
		 * Check for enctype and let user know we don't yet support
		 * multipart/form-data - FM
		 */
		if (links[curdoc.link].l_form->submit_enctype) {
		    if (!strcmp(links[curdoc.link].l_form->submit_enctype,
				"multipart/form-data")) {
			HTAlert(gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			reloading = FALSE;
			return 0;
		    }
		}
#endif /* NOTDEFINED */
		if (check_realm) {
		    LYPermitURL = TRUE;
		}
		if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
		    LYNoRefererForThis = TRUE;
		}
		if (links[curdoc.link].l_form->submit_method != URL_MAIL_METHOD) {
		    StrAllocCopy(newdoc.title,
				 LYGetHiliteStr(curdoc.link, 0));
		}
	    }

	    /*
	     * Normally we don't get here for text input fields, but it can
	     * happen as a result of mouse positioning.  In that case the
	     * statusline will not have updated info, so update it now.  - kw
	     */
	    if (F_TEXTLIKE(links[curdoc.link].l_form->type)) {
		show_formlink_statusline(links[curdoc.link].l_form,
					 (real_cmd == LYK_NOCACHE ||
					  real_cmd == LYK_DOWNLOAD ||
					  real_cmd == LYK_HEAD ||
					  (real_cmd == LYK_SUBMIT &&
					   !textinput_activated)) ?
					 FOR_PANEL : FOR_INPUT);
		if (user_mode == NOVICE_MODE &&
		    textinput_activated &&
		    (real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT)) {
		    form_noviceline(links[curdoc.link].l_form->disabled);
		}
	    }

	    *c = change_form_link(curdoc.link,
				  &newdoc, refresh_screen,
				  FALSE,
				  (BOOLEAN) (real_cmd == LYK_SUBMIT ||
					     real_cmd == LYK_NOCACHE ||
					     real_cmd == LYK_DOWNLOAD ||
					     real_cmd == LYK_HEAD));
	    if (*c != LKC_DONE || *refresh_screen) {
		/*
		 * Cannot have been a submit field for which newdoc was filled
		 * in.  - kw
		 */
		if ((links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) &&
		    links[curdoc.link].l_form->submit_method
		    != URL_MAIL_METHOD) {
		    /*
		     * Try to undo change of newdoc.title done above.
		     */
		    if (HText_getTitle()) {
			StrAllocCopy(newdoc.title, HText_getTitle());
		    } else if (curdoc.title) {
			StrAllocCopy(newdoc.title, curdoc.title);
		    }
		}
	    } else {
		if (HTOutputFormat == HTAtom_for("www/download") &&
		    newdoc.post_data != NULL &&
		    newdoc.safe == FALSE) {

		    if ((HText_POSTReplyLoaded(&newdoc) == TRUE) &&
			HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			HTInfoMsg(CANCELLED);
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			return 0;
		    }
		}
		/*
		 * Moved here from earlier to only apply when it should. 
		 * Anyway, why should realm checking be overridden for form
		 * submissions, this seems to be an unnecessary loophole??  But
		 * that's the way it was, maybe there is some reason.  However,
		 * at least make sure this doesn't weaken restrictions implied
		 * by -validate!
		 * - kw 1999-05-25
		 */
		if (check_realm && !LYValidate) {
		    LYPermitURL = TRUE;
		}
	    }
	    if (*c == LKC_DONE) {
		*c = DO_NOTHING;
	    } else if (*c == 23) {
		*c = DO_NOTHING;
		*refresh_screen = TRUE;
	    } else {
		/* Avoid getting stuck with repeatedly calling
		 * handle_LYK_ACTIVATE(), instead of calling change_form_link()
		 * directly from mainloop(), for text input fields.  - kw
		 */
		switch (LKC_TO_C(*c)) {
		case '\n':
		case '\r':
		default:
		    if ((real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT) &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
			textinput_activated) {
			return 3;
		    }
		    break;
		}
	    }
	    return 2;
	} else {
	    /*
	     * Not a forms link.
	     *
	     * Make sure this isn't a spoof in an account with restrictions on
	     * file URLs.  - FM
	     */
	    if (no_file_url && isFILE_URL(links[curdoc.link].lname)) {
		if (!isFILE_URL(curdoc.address) &&
		    !((isLYNXKEYMAP(curdoc.address) ||
		       isLYNXCOOKIE(curdoc.address)) &&
		      !strncmp(links[curdoc.link].lname,
			       helpfilepath,
			       strlen(helpfilepath)))) {
		    HTAlert(FILE_SERVED_LINKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		} else if (curdoc.bookmark != NULL) {
		    HTAlert(FILE_BOOKMARKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		}
	    }
	    /*
	     * Make sure this isn't a spoof attempt via an internal URL in a
	     * non-internal document.  - FM
	     */
	    if ((isLYNXCOOKIE(links[curdoc.link].lname) &&
		 (strcmp(NonNull(curdoc.title), COOKIE_JAR_TITLE) ||
		  !isLYNXCOOKIE(curdoc.address))) ||
#ifdef DIRED_SUPPORT
		(isLYNXDIRED(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
		 !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
#ifdef OK_INSTALL
		 !LYIsUIPage(curdoc.address, UIP_INSTALL) &&
#endif /* OK_INSTALL */
		 !LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) ||
#endif /* DIRED_SUPPORT */
		(isLYNXDOWNLOAD(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS)) ||
		(isLYNXHIST(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		 !LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		 !LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) ||
		(isLYNXPRINT(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS))) {
		HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		HTOutputFormat = WWW_PRESENT;
		LYforce_no_cache = FALSE;
		reloading = FALSE;
		return 0;
	    }
#ifdef USE_EXTERNALS
	    if (run_external(links[curdoc.link].lname, TRUE)) {
		*refresh_screen = TRUE;
		return 0;
	    }
#endif /* USE_EXTERNALS */

	    /*
	     * Follow a normal link or anchor.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /*
	     * For internal links, retain POST content if present.  If we are
	     * on the List Page, prevent pushing it on the history stack. 
	     * Otherwise set try_internal to signal that the top of the loop
	     * should attempt to reposition directly, without calling getfile. 
	     * - kw
	     */
	    /*
	     * Might be an internal link anchor in the same doc.  If so, take
	     * the try_internal shortcut if we didn't fall through from
	     * LYK_NOCACHE.  - kw
	     */
	    newdoc.internal_link =
		(links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
	    if (newdoc.internal_link) {
		/*
		 * Special case of List Page document with an internal link
		 * indication, which may really stand for an internal link
		 * within the document the List Page is about.  - kw
		 */
		if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		    (LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		     LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		    if (check_history()) {
			LYinternal_flag = TRUE;
		    } else {
			HTLastConfirmCancelled();	/* reset flag */
			if (!confirm_post_resub(newdoc.address,
						newdoc.title,
						((LYresubmit_posts &&
						  HText_POSTReplyLoaded(&newdoc))
						 ? 1
						 : 2),
						2)) {
			    if (HTLastConfirmCancelled() ||
				(LYresubmit_posts &&
				 cmd != LYK_NOCACHE &&
				 !HText_POSTReplyLoaded(&newdoc))) {
				/* cancel the whole thing */
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				copy_address(&newdoc, &curdoc);
				StrAllocCopy(newdoc.title, curdoc.title);
				newdoc.internal_link = curdoc.internal_link;
				HTInfoMsg(CANCELLED);
				return 1;
			    } else if (LYresubmit_posts &&
				       cmd != LYK_NOCACHE) {
				/* If LYresubmit_posts is set, and the
				   answer was No, and the key wasn't
				   NOCACHE, and we have a cached copy,
				   then use it. - kw */
				LYforce_no_cache = FALSE;
			    } else {
				/* if No, but not ^C or ^G, drop
				 * the post data.  Maybe the link
				 * wasn't meant to be internal after
				 * all, here we can recover from that
				 * assumption. - kw */
				LYFreePostData(&newdoc);
				newdoc.internal_link = FALSE;
				HTAlert(DISCARDING_POST_DATA);
			    }
			}
		    }
		    /*
		     * Don't push the List Page if we follow an internal link
		     * given by it.  - kw
		     */
		    free_address(&curdoc);
		} else if (cmd != LYK_NOCACHE) {
		    *try_internal = TRUE;
		}
		if (!(LYresubmit_posts && newdoc.post_data))
		    LYinternal_flag = TRUE;
		/* We still set force_load so that history pushing
		 * etc. will be done.  - kw
		 */
		*force_load = TRUE;
		return 1;
	    } else {
		/*
		 * Free POST content if not an internal link.  - kw
		 */
		LYFreePostData(&newdoc);
	    }
#endif /* TRACK_INTERNAL_LINKS */
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		if (isLYNXMESSAGES(newdoc.address))
		    LYforce_no_cache = TRUE;
	    }
	    if (!no_jump && lynxjumpfile && curdoc.address &&
		!strcmp(lynxjumpfile, curdoc.address)) {
		LYJumpFileURL = TRUE;
		LYUserSpecifiedURL = TRUE;
	    } else if ((curdoc.title &&
			(LYIsUIPage(curdoc.address, UIP_HISTORY) ||
			 !strcmp(curdoc.title, HISTORY_PAGE_TITLE))) ||
		       curdoc.bookmark != NULL ||
		       (lynxjumpfile &&
			!strcmp(lynxjumpfile, curdoc.address))) {
		LYUserSpecifiedURL = TRUE;
	    } else if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
		LYNoRefererForThis = TRUE;
	    }
	    newdoc.link = 0;
	    *force_load = TRUE;	/* force MainLoop to reload */
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;	/* we get here if link is not internal */
#endif

#if defined(DIRED_SUPPORT) && !defined(__DJGPP__)
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
		/*
		 * Unescaping any slash chars in the URL, but avoid double
		 * unescaping and too-early unescaping of other chars.  - KW
		 */
		HTUnEscapeSome(newdoc.address, "/");
		/* avoid stripping final slash for root dir - kw */
		if (strcasecomp(newdoc.address, "file://localhost/"))
		    strip_trailing_slash(newdoc.address);
	    }
#endif /* DIRED_SUPPORT  && !__DJGPP__ */
	    if (isLYNXCOOKIE(curdoc.address)) {
		HTuncache_current_document();
	    }
	}
    }
    return 0;
}

#ifdef EXP_ADDRLIST_PAGE
static BOOLEAN handle_LYK_ADDRLIST(int *cmd)
{
    /*
     * Don't do if already viewing list addresses page.
     */
    if (LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) {
	/*
	 * Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print address list page to file.
     */
    if (showlist(&newdoc, FALSE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, ADDRLIST_PAGE_TITLE);
    /*
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}
#endif /* EXP_ADDRLIST_PAGE */

static void handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
{
    int c;

    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    if (!LYIsUIPage(curdoc.address, UIP_HISTORY) &&
	!LYIsUIPage(curdoc.address, UIP_SHOWINFO) &&
	!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS) &&
#ifdef DIRED_SUPPORT
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	!LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
	!LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS) &&
#endif /* DIRED_SUPPORT */
	!LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS) &&
	!isLYNXCOOKIE(curdoc.address) &&
	!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU) &&
	((nlinks <= 0) ||
	 (links[curdoc.link].lname != NULL &&
	  !isLYNXHIST(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname) &&
	  !isLYNXDIRED(links[curdoc.link].lname) &&
	  !isLYNXDOWNLOAD(links[curdoc.link].lname) &&
	  !isLYNXCOOKIE(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname)))) {
	if (nlinks > 0) {
	    if (curdoc.post_data == NULL &&
		curdoc.bookmark == NULL &&
		!LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_VLINKS)) {
		/*
		 * The document doesn't have POST content, and is not a
		 * bookmark file, nor is the list or visited links page, so we
		 * can save either that or the link.  - FM
		 */
		_statusline(BOOK_D_L_OR_CANCEL);
		if ((c = LYgetch_single()) == 'D') {
		    save_bookmark_link(curdoc.address, curdoc.title);
		    *refresh_screen = TRUE;	/* MultiBookmark support */
		    goto check_add_bookmark_to_self;
		}
	    } else {
		if (LYMultiBookmarks == MBM_OFF &&
		    curdoc.bookmark != NULL &&
		    strstr(curdoc.address,
			   (*bookmark_page == '.'
			    ? (bookmark_page + 1)
			    : bookmark_page)) != NULL) {
		    /*
		     * If multiple bookmarks are disabled, offer the L)ink or
		     * C)ancel, but with wording which indicates that the link
		     * already exists in this bookmark file.  - FM
		     */
		    _statusline(MULTIBOOKMARKS_SELF);
		} else if (curdoc.post_data != NULL &&
			   links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
		    /*
		     * Internal link, and document has POST content.
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		} else {
		    /*
		     * Only offer the link in a document with POST content, or
		     * if the current document is a bookmark file and multiple
		     * bookmarks are enabled.  - FM
		     */
		    _statusline(BOOK_L_OR_CANCEL);
		}
		c = LYgetch_single();
	    }
	    if (c == 'L') {
		if (curdoc.post_data != NULL &&
		    links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
		    /*
		     * Internal link, and document has POST content.
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		}
		/*
		 * User does want to save the link.  - FM
		 */
		if (links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    save_bookmark_link(links[curdoc.link].lname,
				       LYGetHiliteStr(curdoc.link, 0));
		    *refresh_screen = TRUE;	/* MultiBookmark support */
		} else {
		    HTUserMsg(NOBOOK_FORM_FIELD);
		    return;
		}
	    } else {
		return;
	    }
	} else if (curdoc.post_data != NULL) {
	    /*
	     * No links, and document has POST content.  - FM
	     */
	    HTUserMsg(NOBOOK_POST_FORM);
	    return;
	} else if (curdoc.bookmark != NULL) {
	    /*
	     * It's a bookmark file from which all of the links were deleted. 
	     * - FM
	     */
	    HTUserMsg(BOOKMARKS_NOLINKS);
	    return;
	} else {
	    _statusline(BOOK_D_OR_CANCEL);
	    if (LYgetch_single() == 'D') {
		save_bookmark_link(curdoc.address, curdoc.title);
		*refresh_screen = TRUE;		/* MultiBookmark support */
	    } else {
		return;
	    }
	}
      check_add_bookmark_to_self:
	if (curdoc.bookmark && BookmarkPage &&
	    !strcmp(curdoc.bookmark, BookmarkPage)) {
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    newdoc.internal_link = FALSE;
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOBOOK_HSML);
	}
    }
}

static void handle_LYK_CLEAR_AUTH(int *old_c,
				  int real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	if (HTConfirm(CLEAR_ALL_AUTH_INFO)) {
	    FREE(authentication_info[0]);
	    FREE(authentication_info[1]);
	    FREE(proxyauth_info[0]);
	    FREE(proxyauth_info[1]);
	    HTClearHTTPAuthInfo();
#ifndef DISABLE_NEWS
	    HTClearNNTPAuthInfo();
#endif
#ifndef DISABLE_FTP
	    HTClearFTPPassword();
#endif
	    HTUserMsg(AUTH_INFO_CLEARED);
	} else {
	    HTUserMsg(CANCELLED);
	}
    }
}

static int handle_LYK_COMMAND(char *user_input_buffer)
{
    int ch;
    Kcmd *mp;
    char *src, *tmp;

    *user_input_buffer = 0;
    _statusline(": ");
    if (LYgetstr(user_input_buffer, VISIBLE, MAX_LINE, RECALL_CMD) >= 0) {
	src = LYSkipBlanks(user_input_buffer);
	tmp = LYSkipNonBlanks(src);
	*tmp = 0;
	ch = ((mp = LYStringToKcmd(src)) != 0) ? mp->code : 0;
	CTRACE((tfp, "LYK_COMMAND(%s.%s) = %d\n", src, tmp, ch));
	if (ch == 0) {
	    return *src ? -1 : 0;
	}
	/* FIXME: reuse the rest of the buffer for parameters */
	return ch;
    }
    return 0;
}

static void handle_LYK_COMMENT(BOOLEAN *refresh_screen,
			       char **owner_address_p,
			       int *old_c,
			       int real_c)
{
    int c;

    if (!*owner_address_p &&
	strncasecomp(curdoc.address, "http", 4)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_OWNER);
	}
    } else if (no_mail) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(MAIL_DISALLOWED);
	}
    } else {
	if (HTConfirmDefault(CONFIRM_COMMENT, NO)) {
	    if (!*owner_address_p) {
		/*
		 * No owner defined, so make a guess and and offer it to the
		 * user.  - FM
		 */
		char *address = NULL;
		char *temp = HTParse(curdoc.address, "", PARSE_PATH);
		char *cp;

		if (temp != NULL) {
		    HTUnEscape(temp);
		    if (*temp == '~' && strlen(temp) > 1) {
			/*
			 * It's a ~user URL so guess user@@host.  - FM
d697 1
a697 139
			if ((cp = strchr((temp + 1), '/')) != NULL)
			    *cp = '\0';
			StrAllocCopy(address, STR_MAILTO_URL);
			StrAllocCat(address, (temp + 1));
			StrAllocCat(address, "@@");
		    }
		    FREE(temp);
		}
		if (address == NULL)
		    /*
		     * Wasn't a ~user URL so guess WebMaster@@host.  - FM
		     */
		    StrAllocCopy(address, "mailto:WebMaster@@");
		temp = HTParse(curdoc.address, "", PARSE_HOST);
		StrAllocCat(address, temp);
		HTSprintf0(&temp, NO_OWNER_USE, address);
		c = HTConfirmDefault(temp, NO);
		FREE(temp);
		if (c == YES) {
		    StrAllocCopy(*owner_address_p, address);
		    FREE(address);
		} else {
		    FREE(address);
		    return;
		}
	    }
	    if (is_url(*owner_address_p) != MAILTO_URL_TYPE) {
		/*
		 * The address is a URL.  Just follow the link.
		 */
		set_address(&newdoc, *owner_address_p);
		newdoc.internal_link = FALSE;
	    } else {
		/*
		 * The owner_address is a mailto:  URL.
		 */
		const char *kp = HText_getRevTitle();
		const char *id = HText_getMessageID();
		char *tmptitle = NULL;

		if (!kp && HTMainAnchor) {
		    kp = HTAnchor_subject(HTMainAnchor);
		    if (non_empty(kp)) {
			if (strncasecomp(kp, "Re: ", 4)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, kp);
			    kp = tmptitle;
			}
		    }
		}

		if (strchr(*owner_address_p, ':') != NULL)
		    /*
		     * Send a reply.  The address is after the colon.
		     */
		    reply_by_mail(strchr(*owner_address_p, ':') + 1,
				  curdoc.address,
				  NonNull(kp), id);
		else
		    reply_by_mail(*owner_address_p, curdoc.address,
				  NonNull(kp), id);

		FREE(tmptitle);
		*refresh_screen = TRUE;		/* to force a showpage */
	    }
	}
    }
}

static BOOLEAN handle_LYK_COOKIE_JAR(int *cmd)
{
    /*
     * Don't do if already viewing the cookie jar.
     */
    if (!isLYNXCOOKIE(curdoc.address)) {
	set_address(&newdoc, "LYNXCOOKIE:/");
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in the cookie jar, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

#if defined(DIRED_SUPPORT)
static void handle_LYK_CREATE(void)
{
    if (lynx_edit_mode && !no_dired_support) {
	if (local_create(&curdoc) > 0) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link > -1 ? curdoc.link : 0;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
{
    if (curdoc.bookmark != NULL) {
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE, NO) != YES)
	    return;
	remove_bookmark_link(links[curdoc.link].anchor_number - 1,
			     curdoc.bookmark);
    } else {			/* behave like REFRESH for backward compatibility */
	*refresh_screen = TRUE;
	if (*old_c != real_c) {
	    *old_c = real_c;
	    lynx_force_repaint();
	}
	return;
    }
    do_cleanup_after_delete();
}

#if defined(DIRED_SUPPORT) || defined(VMS)
static void handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen,
				  int *old_c GCC_UNUSED,
				  int real_c GCC_UNUSED)
{
d699 1
a699 100
    char *cp, *temp = 0;
    const char *test = HTGetProgramPath(ppCSWING);

    /*
     * Check if the CSwing Directory/File Manager is available.  Will be
     * disabled if CSWING path is NULL, zero-length, or "none" (case
     * insensitive), if no_file_url was set via the file_url restriction, if
     * no_goto_file was set for the anonymous account, or if HTDirAccess was
     * set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse or -selective
     * switches.  - FM
     */
    if (isEmpty(test) ||
	!strcasecomp(test, "none") ||
	no_file_url || no_goto_file ||
	HTDirAccess == HT_DIR_FORBID ||
	HTDirAccess == HT_DIR_SELECTIVE) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(DFM_NOT_AVAILABLE);
	}
	return;
    }

    /*
     * If we are viewing a local directory listing or a local file which is not
     * temporary, invoke CSwing with the URL's directory converted to VMS path
     * specs and passed as the argument, so we start up CSwing positioned on
     * that node of the directory tree.  Otherwise, pass the current default
     * directory as the argument.  - FM
     */
    if (LYisLocalFile(curdoc.address) &&
	strncasecomp(curdoc.address,
		     lynx_temp_space, strlen(lynx_temp_space))) {
	/*
	 * We are viewing a local directory or a local file which is not
	 * temporary.  - FM
	 */
	struct stat stat_info;

	cp = HTParse(curdoc.address, "", PARSE_PATH | PARSE_PUNCTUATION);
	HTUnEscape(cp);
	if (HTStat(cp, &stat_info) == -1) {
	    CTRACE((tfp, "mainloop: Can't stat %s\n", cp));
	    FREE(cp);
	    HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	    *refresh_screen = TRUE;	/* redisplay */
	} else {
	    char *VMSdir = NULL;

	    if (S_ISDIR(stat_info.st_mode)) {
		/*
		 * We're viewing a local directory.  Make that the CSwing
		 * argument.  - FM
		 */
		LYAddPathSep(&cp);
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
	    } else {
		/*
		 * We're viewing a local file.  Make its directory the CSwing
		 * argument.  - FM
		 */
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
		if ((cp = strrchr(VMSdir, ']')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		} else if ((cp = strrchr(VMSdir, ':')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		}
	    }
	    HTSprintf0(&temp, "%s %s", HTGetProgramPath(ppCSWING), VMSdir);
	    FREE(VMSdir);
	    /*
	     * Uncache the current document in case we change, move, or delete
	     * it during the CSwing session.  - FM
	     */
	    /* could use DIRED_UNCACHE_1 but it's currently only defined
	       for dired - kw */
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.title, NonNull(curdoc.title));
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
    } else {
	/*
	 * We're not viewing a local directory or file.  Pass CSwing the
	 * current default directory as an argument and don't uncache the
	 * current document.  - FM
	 */
	HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	*refresh_screen = TRUE;	/* redisplay */
    }
    stop_curses();
    LYSystem(temp);
    start_curses();
    FREE(temp);
d701 1
a701 9
    /*
     * Don't do if not allowed or already viewing the menu.
     */
    if (lynx_edit_mode && !no_dired_support &&
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	strcmp(NonNull(curdoc.title), DIRED_MENU_TITLE)) {
	dired_options(&curdoc, &newdoc.address);
	*refresh_screen = TRUE;	/* redisplay */
    }
d703 23
a725 450
}
#endif /* defined(DIRED_SUPPORT) || defined(VMS) */

static int handle_LYK_DOWNLOAD(int *cmd,
			       int *old_c,
			       int real_c)
{

    /*
     * Don't do if both download and disk_save are restricted.
     */
    if (LYValidate ||
	(no_download && !override_no_download && no_disk_save)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(DOWNLOAD_DISABLED);
	}
	return 0;
    }

    /*
     * Don't do if already viewing download options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS))
	return 0;

    if (do_change_link() == -1)
	return 1;		/* mouse stuff was confused, ignore - kw */
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) {
		if (links[curdoc.link].l_form->submit_method ==
		    URL_MAIL_METHOD) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_MAILTO_ACTION);
		    }
		    return 0;
		}
		if (isLYNXOPTIONS(links[curdoc.link].l_form->submit_action)) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_SPECIAL);
		    }
		    return 0;
		}
		HTOutputFormat = HTAtom_for("www/download");
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return 2;
	    }
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_INPUT);
	    }

	} else if (isLYNXCOOKIE(curdoc.address)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_COOKIES);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PRINT_OP);
	    }
#ifdef DIRED_SUPPORT
	} else if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_UPLOAD_OP);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PERMIT_OP);
	    }

	} else if (lynx_edit_mode && !no_dired_support &&
		   !strstr(links[curdoc.link].lname, "/SugFile=")) {
	    /*
	     * Don't bother making a /tmp copy of the local file.
	     */
	    static DocInfo temp;

	    copy_address(&temp, &newdoc);
	    set_address(&newdoc, links[curdoc.link].lname);
	    if (LYdownload_options(&newdoc.address,
				   links[curdoc.link].lname) < 0)
		copy_address(&newdoc, &temp);
	    else
		newdoc.internal_link = FALSE;
	    LYFreeDocInfo(&temp);
#endif /* DIRED_SUPPORT */

	} else if (LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		   isLYNXHIST(links[curdoc.link].lname)) {
	    int number = atoi(links[curdoc.link].lname + LEN_LYNXHIST);

	    if (number >= nhist || number < 0) {
		HTUserMsg(NO_DOWNLOAD_SPECIAL);
		return 0;
	    }
	    if ((HDOC(number).post_data != NULL &&
		 HDOC(number).safe != TRUE) &&
		HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
		HTInfoMsg(CANCELLED);
		return 0;
	    }
	    /*
	     * OK, we download from history page, restore URL from stack.
	     */
	    copy_address(&newdoc, &HDOC(number));
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
	    StrAllocCopy(newdoc.bookmark, HDOC(number).bookmark);
	    LYFreePostData(&newdoc);
	    if (HDOC(number).post_data)
		BStrCopy(newdoc.post_data,
			 HDOC(number).post_data);
	    if (HDOC(number).post_content_type)
		StrAllocCopy(newdoc.post_content_type,
			     HDOC(number).post_content_type);
	    newdoc.isHEAD = HDOC(number).isHEAD;
	    newdoc.safe = HDOC(number).safe;
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    LYUserSpecifiedURL = TRUE;
	    /*
	     * Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;

	} else if (!strncmp(links[curdoc.link].lname, "data:", 5)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTAlert(UNSUPPORTED_DATA_URL);
	    }

	} else if (isLYNXCOOKIE(links[curdoc.link].lname) ||
		   isLYNXDIRED(links[curdoc.link].lname) ||
		   isLYNXDOWNLOAD(links[curdoc.link].lname) ||
		   isLYNXPRINT(links[curdoc.link].lname) ||
		   isLYNXOPTIONS(links[curdoc.link].lname) ||
		   isLYNXHIST(links[curdoc.link].lname) ||
	    /* handled above if valid - kw */
/* @@@@@@ should next two be downloadable? - kw */
		   isLYNXHIST(links[curdoc.link].lname) ||
		   isLYNXCFLAGS(links[curdoc.link].lname) ||
		   isLYNXEXEC(links[curdoc.link].lname) ||
		   isLYNXPROG(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_SPECIAL);

	} else if (isMAILTO_URL(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_MAILTO_LINK);

	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     *
	     * We copy all these checks from getfile() to LYK_DOWNLOAD here
	     * because LYNXDOWNLOAD:// will NOT be pushing the previous
	     * document into the history stack so preserve getfile() from
	     * returning a wrong status (NULLFILE).
	     */
	} else if (local_host_only &&
		   !(LYisLocalHost(links[curdoc.link].lname) ||
		     LYisLocalAlias(links[curdoc.link].lname))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	} else {		/* Not a forms, options or history link */
	    /*
	     * Follow a normal link or anchor.  Note that if it's an anchor
	     * within the same document, entire document will be downloaded.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /*
	     * Might be an internal link in the same doc from a POST form.  If
	     * so, don't free the content.  - kw
	     */
	    if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE)
#else
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc))
#endif /* TRACK_INTERNAL_LINKS */
	    {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
	    }
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    /*
	     * Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NO_DOWNLOAD_CHOICE);
    }
    return 0;
}

static void handle_LYK_DOWN_HALF(int *old_c,
				 int real_c)
{
    int i;

    if (more) {
	Newline += (display_lines / 2);
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > display_lines / 2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= (display_lines / 2); i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_DOWN_LINK(int *follow_col,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link < (nlinks - 1)) {	/* more links? */
	int newlink;

	if (*follow_col == -1) {
	    const char *text = LYGetHiliteStr(curdoc.link, 0);

	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, 1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (more) {	/* next page */
	    Newline += (display_lines);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_BELOW);
	    return;
	}
    } else if (more) {		/* next page */
	Newline += (display_lines);

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_DOWN_TWO(int *old_c,
				int real_c)
{
    int i;

    if (more) {
	Newline += 2;
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > 2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= 2; i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static int handle_LYK_DWIMEDIT(int *cmd,
			       int *old_c,
			       int real_c)
{
#ifdef TEXTAREA_AUTOEXTEDIT
    /*
     * If we're in a forms TEXTAREA, invoke the editor on *its* contents,
     * rather than attempting to edit the html source document.  KED
     */
    if (nlinks > 0 &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	*cmd = LYK_EDIT_TEXTAREA;
	return 2;
    }

    /*
     * If we're in a forms TEXT type, tell user the request is bogus (though in
     * reality, without this trap, if the document with the TEXT field is
     * local, the editor *would* be invoked on the source .html file; eg, the
     * o(ptions) form tempfile).
     *
     * [This is done to avoid possible user confusion, due to auto invocation
     * of the editor on the TEXTAREA's contents via the above if() statement.]
     */
    if (nlinks > 0 &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXT_TYPE) {
	HTUserMsg(CANNOT_EDIT_FIELD);
	return 1;
    }

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
	return 1;
    }
#endif /* TEXTAREA_AUTOEXTEDIT */
    return 0;
}

static int handle_LYK_ECGOTO(int *ch,
			     char *user_input_buffer,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 * Go to not allowed.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 * Disallow editing of File Management URLs.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */

    /*
     * Save the current user_input_buffer string, and load the current
     * document's address.
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      curdoc.address,
	      (MAX_LINE - 1));

    /*
     * Warn the user if the current document has POST data associated with it. 
     * - FM
     */
    if (curdoc.post_data)
	HTAlert(CURRENT_DOC_HAS_POST_DATA);

    /*
     * Offer the current document's URL for editing.  - FM
     */
    _statusline(EDIT_CURDOC_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			 MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer, curdoc.address)) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}

static void handle_LYK_EDIT(int *old_c,
			    int real_c)
{
#ifdef DIRED_SUPPORT
    char *cp;
    char *tp = NULL;
    struct stat dir_info;
#endif /* DIRED_SUPPORT */

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_DISABLED);
	}
    } else
#ifdef DIRED_SUPPORT
	/*
	 * Allow the user to edit the link rather than curdoc in edit mode.
	 */
	if (lynx_edit_mode &&
	    non_empty(editor) && !no_dired_support) {
	if (nlinks > 0) {
	    cp = links[curdoc.link].lname;
	    if (is_url(cp) == FILE_URL_TYPE) {
		cp = HTfullURL_toFile(cp);
		StrAllocCopy(tp, cp);
		FREE(cp);

		if (stat(tp, &dir_info) == -1) {
		    HTAlert(NO_STATUS);
		} else {
		    if (S_ISREG(dir_info.st_mode)) {
			StrAllocCopy(tp, links[curdoc.link].lname);
			HTUnEscapeSome(tp, "/");
			if (edit_current_file(tp, curdoc.link, Newline)) {
			    DIRED_UNCACHE_1;
			    move_address(&newdoc, &curdoc);
#ifdef NO_SEEK_OLD_POSITION
			    /*
			     * Go to top of file.
			     */
			    newdoc.line = 1;
			    newdoc.link = 0;
#else
			    /*
			     * Seek old position, which probably changed.
			     */
			    newdoc.line = curdoc.line;
			    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
			    LYclear();	/* clear the screen */
a727 71
		}
		FREE(tp);
	    }
	}
    } else
#endif /* DIRED_SUPPORT */
    if (non_empty(editor)) {
	if (edit_current_file(newdoc.address, curdoc.link, Newline)) {
	    HTuncache_current_document();
	    LYforce_no_cache = TRUE;	/*force reload of document */
	    free_address(&curdoc);	/* so it doesn't get pushed */
#ifdef NO_SEEK_OLD_POSITION
	    /*
	     * Go to top of file.
	     */
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    /*
	     * Seek old position, which probably changed.
	     */
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
	    LYclear();		/* clear the screen */
	}

    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
}

static void handle_LYK_DWIMHELP(const char **cshelpfile)
{
    /*
     * Currently a help file different from the main 'helpfile' is shown only
     * if current link is a text input form field.  - kw
     */
    if (curdoc.link >= 0 && curdoc.link < nlinks &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	!links[curdoc.link].l_form->disabled &&
	F_TEXTLIKE(links[curdoc.link].l_form->type)) {
	*cshelpfile = LYLineeditHelpURL();
    }
}

static void handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
{
    int n;

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
    } else if (!editor || *editor == '\0') {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
    /*
     * See if the current link is in a form TEXTAREA.
     */
    else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d729 48
a776 2
	/* stop screen */
	stop_curses();
d778 12
a789 1
	n = HText_ExtEditForm(&links[curdoc.link]);
d791 99
a889 7
	/*
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st trailing blank line in the now edited TEXTAREA.  If the target
	 * line/ anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
	 */
d891 21
a911 2
/* curdoc.link += n; *//* works, except for page crossing, */
	/* damnit; why is nothing ever easy */
d913 15
a927 3
	/* start screen */
	start_curses();
	*refresh_screen = TRUE;
d929 21
a949 1
    } else {
d951 7
a957 3
	HTInfoMsg(NOT_IN_TEXTAREA_NOEDIT);
    }
}
d959 14
a972 57
static int handle_LYK_ELGOTO(int *ch,
			     char *user_input_buffer,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 * Go to not allowed.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
    if (!(nlinks > 0 && curdoc.link > -1) ||
	(links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	 links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE)) {
	/*
	 * No links on page, or not a normal link or form submit button.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	}
	return 0;
    }
    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
	(!links[curdoc.link].l_form->submit_action ||
	 *links[curdoc.link].l_form->submit_action == '\0')) {
	/*
	 * Form submit button with no ACTION defined.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_FORM_ACTION);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (isLYNXDIRED(links[curdoc.link].lname) ||
	LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 * Disallow editing of File Management URLs.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */
d974 5
a978 10
    /*
     * Save the current user_input_buffer string, and load the current link's
     * address.  - FM
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
	       ?
	       links[curdoc.link].l_form->submit_action : links[curdoc.link].lname),
	      (MAX_LINE - 1));
d980 11
a990 41
    /*
     * Offer the current link's URL for editing.  - FM
     */
    _statusline(EDIT_CURLINK_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			 MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer,
	       ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
		? links[curdoc.link].l_form->submit_action
		: links[curdoc.link].lname))) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}

#ifdef USE_EXTERNALS
static void handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen)
{
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL)) {
	run_external(links[curdoc.link].lname, FALSE);
	*refresh_screen = TRUE;
    }
}

static void handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen)
{
    if (curdoc.address != NULL) {
	run_external(curdoc.address, FALSE);
	*refresh_screen = TRUE;
    }
}
d992 2
a994 91
static BOOLEAN handle_LYK_FASTBACKW_LINK(int *cmd,
					 int *old_c,
					 int real_c)
{
    int samepage = 0, nextlink = curdoc.link;
    int res;

    if (nlinks > 1) {

	/*
	 * If in textarea, move to first link or textarea group before it if
	 * there is one on this screen.  - kw
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link > 0 &&
		!(links[0].type == WWW_FORM_LINK_TYPE &&
		  links[0].l_form->type == F_TEXTAREA_TYPE &&
		  links[0].l_form->number == thisgroup &&
		  sametext(links[0].l_form->name, thisname))) {
		do
		    nextlink--;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;

	    } else if (!more && Newline == 1 &&
		       (links[0].type == WWW_FORM_LINK_TYPE &&
			links[0].l_form->type == F_TEXTAREA_TYPE &&
			links[0].l_form->number == thisgroup &&
			sametext(links[0].l_form->name, thisname)) &&
		       !(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
			 links[nlinks - 1].l_form->number == thisgroup &&
			 sametext(links[nlinks - 1].l_form->name, thisname))) {
		nextlink = nlinks - 1;
		samepage = 1;

	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link > 0) {
	    nextlink--;
	    samepage = 1;
	} else if (!more && Newline == 1) {
	    nextlink = nlinks - 1;
	    samepage = 1;
	}
    }
    if (samepage) {
	/*
	 * If the link as determined so far is part of a group of textarea
	 * fields, try to use the first of them that's on the screen instead. 
	 * - kw
	 */
	if (nextlink > 0 &&
	    links[nextlink].type == WWW_FORM_LINK_TYPE &&
	    links[nextlink].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[nextlink].l_form->number;
	    char *thisname = links[nextlink].l_form->name;

	    if (links[0].type == WWW_FORM_LINK_TYPE &&
		links[0].l_form->type == F_TEXTAREA_TYPE &&
		links[0].l_form->number == thisgroup &&
		sametext(links[0].l_form->name, thisname)) {
		nextlink = 0;
	    } else
		while
		    (nextlink > 1 &&
		     links[nextlink - 1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink - 1].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink - 1].l_form->number == thisgroup &&
		     sametext(links[nextlink - 1].l_form->name, thisname)) {
		    nextlink--;
		}
	}
	set_curdoc_link(nextlink);
	return FALSE;		/* and we are done. */

    } else if (Newline > 1 &&	/* need a previous page */
	       (res = HTGetLinkOrFieldStart(curdoc.link,
					    &Newline, &newdoc.link,
					    -1, TRUE)) != NO) {
	if (res == LINK_DO_ARROWUP) {
d996 2
a997 2
	     * It says we should use the normal PREV_LINK mechanism, so we'll
	     * do that.  - kw
d999 20
a1018 7
	    if (nlinks > 0)
		curdoc.link = 0;
	    *cmd = LYK_PREV_LINK;
	    return TRUE;
	}
	Newline++;		/* our line counting starts with 1 not 0 */
	/* nothing more to do here */
a1019 6
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_ABOVE);
    }
    return FALSE;
}
d1021 23
a1043 4
static void handle_LYK_FASTFORW_LINK(int *old_c,
				     int real_c)
{
    int samepage = 0, nextlink = curdoc.link;
d1045 1
a1045 1
    if (nlinks > 1) {
d1047 7
a1053 32
	/*
	 * If in textarea, move to first link or field after it if there is one
	 * on this screen.  - kw
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link < nlinks - 1 &&
		!(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
		  links[nlinks - 1].l_form->number == thisgroup &&
		  sametext(links[nlinks - 1].l_form->name, thisname))) {
		do
		    nextlink++;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;
	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link < nlinks - 1) {
	    nextlink++;
	    samepage = 1;
	} else if (!more && Newline == 1 && curdoc.link > 0) {
	    nextlink = 0;
	    samepage = 1;
a1054 4
    }
    if (samepage) {
	set_curdoc_link(nextlink);
	return;			/* and we are done. */
d1057 2
a1058 2
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
d1060 13
a1072 26
    } else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
	set_curdoc_link(0);

    } else if (more &&		/* need a later page */
	       HTGetLinkOrFieldStart(curdoc.link,
				     &Newline, &newdoc.link,
				     1, TRUE) != NO) {
	Newline++;		/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_BELOW);
    }
    return;
}

static void handle_LYK_FIRST_LINK(void)
{
    int i = curdoc.link;

    for (;;) {
	if (--i < 0
	    || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i + 1);
	    break;
a1073 2
    }
}
d1075 7
a1081 15
static BOOLEAN handle_LYK_GOTO(int *ch,
			       char *user_input_buffer,
			       char **old_user_input,
			       RecallType * recall,
			       int *URLTotal,
			       int *URLNum,
			       BOOLEAN *FirstURLRecall,
			       int *old_c,
			       int real_c)
{

    if (no_goto && !LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
a1082 2
	return FALSE;
    }
d1084 5
a1088 14
    StrAllocCopy(*old_user_input, user_input_buffer);
    if (!goto_buffer)
	*user_input_buffer = '\0';

    *URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
    if (goto_buffer && *user_input_buffer) {
	*recall = ((*URLTotal > 1) ? RECALL_URL : NORECALL);
	*URLNum = 0;
	*FirstURLRecall = FALSE;
    } else {
	*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
	*URLNum = *URLTotal;
	*FirstURLRecall = TRUE;
    }
d1090 35
a1124 17
    /*
     * Ask the user.
     */
    _statusline(URL_TO_OPEN);
    if ((*ch = LYgetstr(user_input_buffer, VISIBLE,
			MAX_LINE, *recall)) < 0) {
	/*
	 * User cancelled the Goto via ^G.  Restore user_input_buffer and
	 * break.  - FM
	 */
	LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	FREE(*old_user_input);
	HTInfoMsg(CANCELLED);
	return FALSE;
    }
    return TRUE;
}
d1126 21
a1146 41
static void handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen)
{
    /*
     * See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {

	HText_ExpandTextarea(&links[curdoc.link], TEXTAREA_EXPAND_SIZE);

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg(NOT_IN_TEXTAREA);
    }
}

static BOOLEAN handle_LYK_HEAD(int *cmd)
{
    int c;

    if (nlinks > 0 &&
	(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
	 links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE)) {
	/*
	 * We have links, and the current link is a normal link or a form's
	 * submit button.  - FM
	 */
	_statusline(HEAD_D_L_OR_CANCEL);
	c = LYgetch_single();
	if (c == 'D') {
	    char *scheme = !isLYNXIMGMAP(curdoc.address)
	    ? curdoc.address
	    : curdoc.address + LEN_LYNXIMGMAP;

	    if (LYCanDoHEAD(scheme) != TRUE) {
		HTUserMsg(DOC_NOT_HTTP_URL);
	    } else {
d1148 1
a1148 2
		 * Check if this is a reply from a POST, and if so, seek
		 * confirmation if the safe element is not set.  - FM
d1150 5
a1154 4
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
		    HTInfoMsg(CANCELLED);
d1156 4
a1159 6
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HText_setNoCache(HTMainText);
			free_address(&curdoc);
d1161 2
a1162 1
			StrAllocCat(newdoc.title, " - HEAD");
d1164 1
d1166 1
d1168 1
a1168 42
	} else if (c == 'L') {
	    if (links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		strncmp(links[curdoc.link].lname, "http", 4) &&
		strncmp(links[curdoc.link].lname,
			"LYNXIMGMAP:http", 15) &&
		LYCanDoHEAD(links[curdoc.link].lname) != TRUE &&
		(links[curdoc.link].type != WWW_INTERN_LINK_TYPE ||
		 !curdoc.address ||
		 strncmp(curdoc.address, "http", 4))) {
		HTUserMsg(LINK_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->disabled) {
		HTUserMsg(FORM_ACTION_DISABLED);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       !isLYNXCGI(links[curdoc.link].l_form->submit_action) &&
		       strncmp(links[curdoc.link].l_form->submit_action,
			       "http", 4)) {
		HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->submit_method ==
		       URL_POST_METHOD &&
		       HTConfirm(CONFIRM_POST_LINK_HEAD) == FALSE) {
		HTInfoMsg(CANCELLED);
	    } else {
		HEAD_request = TRUE;
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return TRUE;
	    }
	}
    } else {
	/*
	 * We can offer only this document for a HEAD request.  Check if this
	 * is a reply from a POST, and if so, seek confirmation if the safe
	 * element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
	    HTInfoMsg(CANCELLED);
	} else {
	    if (nlinks > 0) {
d1170 3
a1172 3
		 * The current link is a non-submittable form link, so prompt
		 * the user to make it clear that the HEAD request would be for
		 * the current document, not the form link.  - FM
d1174 2
a1175 3
		_statusline(HEAD_D_OR_CANCEL);
		c = LYgetch_single();
	    } else {
d1177 4
a1180 2
		 * No links, so we can just assume that the user wants a HEAD
		 * request for the current document.  - FM
d1182 3
a1184 1
		c = 'D';
d1186 4
a1189 21
	    if (c == 'D') {
		char *scheme = !isLYNXIMGMAP(curdoc.address)
		? curdoc.address
		: curdoc.address + LEN_LYNXIMGMAP;

		/*
		 * The user didn't cancel, so check if a HEAD request is
		 * appropriate for the current document.  - FM
		 */
		if (LYCanDoHEAD(scheme) != TRUE) {
		    HTUserMsg(DOC_NOT_HTTP_URL);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HText_setNoCache(HTMainText);
			free_address(&curdoc);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
		    }
a1192 7
    }
    return FALSE;
}

static void handle_LYK_HELP(const char **cshelpfile)
{
    char *my_value = NULL;
d1194 1
a1194 5
    if (*cshelpfile == NULL)
	*cshelpfile = helpfile;
    StrAllocCopy(my_value, *cshelpfile);
    LYEnsureAbsoluteURL(&my_value, *cshelpfile, FALSE);
    if (!STREQ(curdoc.address, my_value)) {
d1196 2
a1197 58
	 * Set the filename.
	 */
	set_address(&newdoc, my_value);
	/*
	 * Make a name for this help file.
	 */
	StrAllocCopy(newdoc.title, gettext("Help Screen"));
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    }
    FREE(my_value);
    *cshelpfile = NULL;		/* reset pointer - kw */
}

static void handle_LYK_HISTORICAL(void)
{
#ifdef USE_SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
#endif
    historical_comments = !historical_comments;
    if (minimal_comments) {
	HTAlert(historical_comments ?
		HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
    } else {
	HTAlert(historical_comments ?
		HISTORICAL_ON_VALID_OFF : HISTORICAL_OFF_VALID_ON);
    }
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}

static BOOLEAN handle_LYK_HISTORY(BOOLEAN ForcePush)
{
    if (curdoc.title && !LYIsUIPage(curdoc.address, UIP_HISTORY)) {
	/*
	 * Don't do this if already viewing history page.
d1199 2
a1200 3
	 * Push the current file so that the history list contains the current
	 * file for printing purposes.  Pop the file afterwards to prevent
	 * multiple copies.
d1202 15
a1216 6
	if (TRACE && !LYUseTraceLog && LYCursesON) {
	    LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
	    LYaddstr("\n");
#endif /* USE_SLANG */
	    LYrefresh();
a1217 1
	LYpush(&curdoc, ForcePush);
d1220 4
a1223 1
	 * Print history options to file.
d1225 2
a1226 61
	if (showhistory(&newdoc.address) < 0) {
	    LYpop(&curdoc);
	    return TRUE;
	}
	LYRegisterUIPage(newdoc.address, UIP_HISTORY);
	StrAllocCopy(newdoc.title, HISTORY_PAGE_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	newdoc.link = 1;	/*@@@@@@ bypass "recent statusline messages" link */
	free_address(&curdoc);	/* so it doesn't get pushed */

	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
	return TRUE;
    }				/* end if strncmp */
    return FALSE;
}

static BOOLEAN handle_LYK_IMAGE_TOGGLE(int *cmd)
{
    clickable_images = !clickable_images;

    HTUserMsg(clickable_images ?
	      CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
    return reparse_or_reload(cmd);
}

static void handle_LYK_INDEX(int *old_c,
			     int real_c)
{
    /*
     * Make sure we are not in the index already.
     */
    if (!STREQ(curdoc.address, indexfile)) {

	if (indexfile[0] == '\0') {	/* no defined index */
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_INDEX_FILE);
	    }

	} else {
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE) {
		last_kcode = NOKANJI;	/* AUTO */
	    }
#endif
	    set_address(&newdoc, indexfile);
	    StrAllocCopy(newdoc.title, gettext("System Index"));	/* name it */
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	}			/* end else */
    }				/* end if */
}
a1227 30
static void handle_LYK_INDEX_SEARCH(BOOLEAN *force_load,
				    BOOLEAN ForcePush,
				    int *old_c,
				    int real_c)
{
    if (is_www_index) {
	/*
	 * Perform a database search.
	 *
	 * do_www_search will try to go out and get the document.  If it
	 * returns TRUE, a new document was returned and is named in the
	 * newdoc.address.
	 */
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	if (do_www_search(&newdoc) == NORMAL) {
	    /*
	     * Yah, the search succeeded.
	     */
	    if (TRACE && !LYUseTraceLog && LYCursesON) {
		/*
		 * Make sure cursor is down.
		 */
		LYHideCursor();
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
	    }
	    LYpush(&curdoc, ForcePush);
d1229 2
a1230 3
	     * Make the curdoc.address the newdoc.address so that getfile
	     * doesn't try to get the newdoc.address.  Since we have already
	     * gotten it.
a1231 4
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type, curdoc.post_content_type);
	    newdoc.internal_link = FALSE;
a1232 6
	    Newline = 0;
	} else if (use_this_url_instead != NULL) {
	    /*
	     * Got back a redirecting URL.  Check it out.
	     */
	    HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
a1233 25
	    /*
	     * Make a name for this URL.
	     */
	    StrAllocCopy(newdoc.title,
			 "A URL specified by redirection");
	    set_address(&newdoc, use_this_url_instead);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(use_this_url_instead);
	    *force_load = TRUE;
	} else {
	    /*
	     * Yuk, the search failed.  Restore the old file.
	     */
	    copy_address(&newdoc, &curdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type,
			 curdoc.post_content_type);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.isHEAD = curdoc.isHEAD;
	    newdoc.safe = curdoc.safe;
	    newdoc.internal_link = curdoc.internal_link;
d1235 2
a1236 5
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NOT_ISINDEX);
    }
}
a1237 20
static BOOLEAN handle_LYK_INFO(int *cmd)
{
    /*
     * Don't do if already viewing info page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_SHOWINFO)) {
	if (do_change_link() != -1
	    && LYShowInfo(&curdoc, &newdoc, owner_address) >= 0) {
	    LYRegisterUIPage(newdoc.address, UIP_SHOWINFO);
	    StrAllocCopy(newdoc.title, SHOWINFO_TITLE);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYforce_no_cache = TRUE;
	    if (LYValidate || check_realm)
		LYPermitURL = TRUE;
	}
    } else {
d1239 4
a1242 1
	 * If already in info page, get out.
d1244 1
a1244 5
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}
d1246 1
a1246 3
static BOOLEAN handle_LYK_INLINE_TOGGLE(int *cmd)
{
    pseudo_inline_alts = !pseudo_inline_alts;
d1248 1
a1248 4
    HTUserMsg(pseudo_inline_alts ?
	      PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
    return reparse_or_reload(cmd);
}
d1250 4
a1253 5
static void handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen,
				   int *old_c,
				   int real_c)
{
    int n;
d1255 5
a1259 5
    /*
     * See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d1261 10
a1270 18
	/*
	 * Reject attempts to use this for gaining access to local files when
	 * such access is restricted:  if no_file_url was set via the file_url
	 * restriction, if no_goto_file was set for the anonymous account, or
	 * if HTDirAccess was set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the
	 * -nobrowse or -selective switches, it is assumed that inserting files
	 * or checking for existence of files needs to be denied.  - kw
	 */
	if (no_file_url || no_goto_file ||
	    HTDirAccess == HT_DIR_FORBID ||
	    HTDirAccess == HT_DIR_SELECTIVE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		if (no_goto_file)
		    HTUserMsg2(GOTO_XXXX_DISALLOWED, STR_FILE_URL);
		else
		    HTUserMsg(NOAUTH_TO_ACCESS_FILES);
		HTInfoMsg(FILE_INSERT_CANCELLED);
a1271 2
	    return;
	}
d1273 19
a1291 76
	n = HText_InsertFile(&links[curdoc.link]);

	/*
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st line following the text that was inserted.  If the target
	 * line/anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
	 *
	 * [Current behavior leaves cursor on the same line relative to the
	 * start of the TEXTAREA that it was on before the insertion.  This is
	 * the same behavior that occurs with (my) editor, so this TODO will
	 * stay unimplemented.]
	 */

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg(NOT_IN_TEXTAREA);
    }
}

#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
static void handle_LYK_INSTALL(void)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support)
	local_install(NULL, links[curdoc.link].lname, &newdoc.address);
}
#endif

static BOOLEAN handle_LYK_JUMP(int c,
			       char *user_input_buffer,
			       char **old_user_input GCC_UNUSED,
			       RecallType * recall GCC_UNUSED,
			       BOOLEAN *FirstURLRecall GCC_UNUSED,
			       int *URLNum GCC_UNUSED,
			       int *URLTotal GCC_UNUSED,
			       int *ch GCC_UNUSED,
			       int *old_c,
			       int real_c)
{
    char *ret;

    if (no_jump || JThead == NULL) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    if (no_jump)
		HTUserMsg(JUMP_DISALLOWED);
	    else
		HTUserMsg(NO_JUMPFILE);
	}
    } else {
	LYJumpFileURL = TRUE;
	if ((ret = LYJump(c)) != NULL) {
#ifdef PERMIT_GOTO_FROM_JUMP
	    if (!strncasecomp(ret, "Go ", 3)) {
		LYJumpFileURL = FALSE;
		StrAllocCopy(*old_user_input, user_input_buffer);
		*URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
		*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
		*URLNum = *URLTotal;
		*FirstURLRecall = TRUE;
		if (!strcasecomp(ret, "Go :")) {
		    if (recall) {
			*ch = UPARROW;
			return TRUE;
		    }
		    FREE(*old_user_input);
		    HTUserMsg(NO_RANDOM_URLS_YET);
		    return FALSE;
		}
		ret = HTParse((ret + 3), startfile, PARSE_ALL);
		LYstrncpy(user_input_buffer, ret, MAX_LINE - 1);
		FREE(ret);
		return TRUE;
a1292 20
#endif /* PERMIT_GOTO_FROM_JUMP */
	    ret = HTParse(ret, startfile, PARSE_ALL);
	    if (!LYTrimStartfile(ret)) {
		LYRemoveBlanks(user_input_buffer);
	    }
	    set_address(&newdoc, ret);
	    StrAllocCopy(lynxjumpfile, ret);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(ret);
	    LYUserSpecifiedURL = TRUE;
	} else {
	    LYJumpFileURL = FALSE;
	}
    }
    return FALSE;
}
d1294 4
a1297 46
static void handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag,
			      BOOLEAN *emacs_keys_flag,
			      int *old_c,
			      int real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	set_address(&newdoc, STR_LYNXKEYMAP);
	StrAllocCopy(newdoc.title, CURRENT_KEYMAP_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 * If vi_keys changed, the keymap did too, so force no cache, and reset
	 * the flag.  - FM
	 */
	if (*vi_keys_flag != vi_keys ||
	    *emacs_keys_flag != emacs_keys) {
	    LYforce_no_cache = TRUE;
	    *vi_keys_flag = vi_keys;
	    *emacs_keys_flag = emacs_keys;
	}
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	/*
	 * Remember whether we are in dired menu so we can display the right
	 * keymap.
	 */
	if (!no_dired_support) {
	    prev_lynx_edit_mode = lynx_edit_mode;
	}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	LYforce_no_cache = TRUE;
    }
}

static void handle_LYK_LAST_LINK(void)
{
    int i = curdoc.link;

    for (;;) {
	if (++i >= nlinks
	    || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i - 1);
	    break;
a1298 10
    }
}

static void handle_LYK_LEFT_LINK(void)
{
    if (curdoc.link > 0 &&
	links[curdoc.link].ly == links[curdoc.link - 1].ly) {
	set_curdoc_link(curdoc.link - 1);
    }
}
a1299 7
static BOOLEAN handle_LYK_LIST(int *cmd)
{
    /*
     * Don't do if already viewing list page.
     */
    if (!strcmp(NonNull(curdoc.title), LIST_PAGE_TITLE) &&
	LYIsUIPage(curdoc.address, UIP_LIST_PAGE)) {
d1301 1
a1301 1
	 * Already viewing list page, so get out.
d1303 11
a1313 30
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print list page to file.
     */
    if (showlist(&newdoc, TRUE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, LIST_PAGE_TITLE);
    /*
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}

static void handle_LYK_MAIN_MENU(int *old_c,
				 int real_c)
{
    /*
     * If its already the homepage then don't reload it.
     */
    if (!STREQ(curdoc.address, homepage)) {
a1314 9
	if (HTConfirmDefault(CONFIRM_MAIN_SCREEN, NO) == YES) {
	    set_address(&newdoc, homepage);
	    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYhighlight(OFF, curdoc.link, prev_target);
d1316 2
a1317 3
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
	    }
a1318 8
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(IN_MAIN_SCREEN);
	}
    }
}
a1319 6
static void handle_LYK_MINIMAL(void)
{
    if (!historical_comments) {
#ifdef USE_SOURCE_CACHE
	if (!HTcan_reparse_document()) {
#endif
d1321 1
a1321 2
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
d1323 1
a1323 27
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HText_setNoCache(HTMainText);
		move_address(&newdoc, &curdoc);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
#ifdef USE_SOURCE_CACHE
	}			/* end if no bypass */
#endif
    }
    minimal_comments = !minimal_comments;
    if (!historical_comments) {
	HTAlert(minimal_comments ?
		MINIMAL_ON_IN_EFFECT : MINIMAL_OFF_VALID_ON);
    } else {
	HTAlert(minimal_comments ?
		MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
    }
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}
d1325 3
a1327 5
#if defined(DIRED_SUPPORT)
static void handle_LYK_MODIFY(BOOLEAN *refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int ret;
a1328 14
	ret = local_modify(&curdoc, &newdoc.address);
	if (ret == PERMIT_FORM_RESULT) {	/* Permit form thrown up */
	    *refresh_screen = TRUE;
	} else if (ret) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    LYclear();
a1329 3
    }
}
#endif /* DIRED_SUPPORT */
d1331 5
a1335 8
#ifdef EXP_NESTED_TABLES
static BOOLEAN handle_LYK_NESTED_TABLES(int *cmd)
{
    nested_tables = !nested_tables;
    HTUserMsg(nested_tables ? NESTED_TABLES_ON : NESTED_TABLES_OFF);
    return reparse_or_reload(cmd);
}
#endif
d1337 10
a1346 42
static BOOLEAN handle_LYK_OPTIONS(int *cmd,
				  BOOLEAN *refresh_screen)
{
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions) {
	BOOLEAN LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
	BOOLEAN LYSelectPopups_flag = LYSelectPopups;
	BOOLEAN verbose_img_flag = verbose_img;
	BOOLEAN keypad_mode_flag = (BOOL) keypad_mode;
	BOOLEAN show_dotfiles_flag = show_dotfiles;
	BOOLEAN user_mode_flag = (BOOL) user_mode;
	int CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
	int CurrentCharSet_flag = current_char_set;
	int HTfileSortMethod_flag = HTfileSortMethod;
	char *CurrentUserAgent = NULL;
	char *CurrentNegoLanguage = NULL;
	char *CurrentNegoCharset = NULL;

	StrAllocCopy(CurrentUserAgent, NonNull(LYUserAgent));
	StrAllocCopy(CurrentNegoLanguage, NonNull(language));
	StrAllocCopy(CurrentNegoCharset, NonNull(pref_charset));

	LYoptions(); /** do the old-style options stuff **/

	if (keypad_mode_flag != keypad_mode ||
	    (user_mode_flag != user_mode &&
	     (user_mode_flag == NOVICE_MODE ||
	      user_mode == NOVICE_MODE)) ||
	    (((HTfileSortMethod_flag != HTfileSortMethod) ||
	      (show_dotfiles_flag != show_dotfiles)) &&
	     (isFILE_URL(curdoc.address) ||
	      isFTP_URL(curdoc.address))) ||
	    CurrentCharSet_flag != current_char_set ||
	    CurrentAssumeCharSet_flag != UCLYhndl_for_unspec ||
	    verbose_img_flag != verbose_img ||
	    LYUseDefaultRawMode_flag != LYUseDefaultRawMode ||
	    LYSelectPopups_flag != LYSelectPopups ||
	    ((strcmp(CurrentUserAgent, NonNull(LYUserAgent)) ||
	      strcmp(CurrentNegoLanguage, NonNull(language)) ||
	      strcmp(CurrentNegoCharset, NonNull(pref_charset))) &&
	     (!strncmp(curdoc.address, "http", 4) ||
	      isLYNXCGI(curdoc.address)))) {
d1348 8
a1355 1
	    BOOLEAN canreparse_post = FALSE;
d1357 1
d1359 2
a1360 2
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
d1362 19
a1380 4
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
#ifdef USE_SOURCE_CACHE
		(!(canreparse_post = HTcan_reparse_document())) &&
d1382 4
a1385 33
		confirm_post_resub(curdoc.address, curdoc.title,
				   2, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		copy_address(&newdoc, &curdoc);
		if (((strcmp(CurrentUserAgent, NonNull(LYUserAgent)) ||
		      strcmp(CurrentNegoLanguage, NonNull(language)) ||
		      strcmp(CurrentNegoCharset, NonNull(pref_charset))) &&
		     (strncmp(curdoc.address, "http", 4) == 0 ||
		      !isLYNXCGI(curdoc.address) == 0))) {
		    /*
		     * An option has changed which may influence content
		     * negotiation, and the resource is from a http or https or
		     * lynxcgi URL (the only protocols which currently do
		     * anything with this information).  Set reloading = TRUE
		     * so that proxy caches will be flushed, which is necessary
		     * until the time when all proxies understand HTTP 1.1
		     * Vary:  and all Servers properly use it...  Treat like
		     * case LYK_RELOAD (see comments there).  - KW
		     */
		    reloading = TRUE;
		}
		if (HTisDocumentSource()) {
		    srcmode_for_next_retrieval(1);
		}
#ifdef USE_SOURCE_CACHE
		if (reloading == FALSE) {
		    /* one more attempt to be smart enough: */
		    if (reparse_document()) {
			FREE(CurrentUserAgent);
			FREE(CurrentNegoLanguage);
			FREE(CurrentNegoCharset);
			return FALSE;
d1387 1
d1389 60
a1448 12
#endif
		if (canreparse_post &&
		    confirm_post_resub(curdoc.address, curdoc.title,
				       2, 1) == FALSE) {
		    if (HTisDocumentSource()) {
			srcmode_for_next_retrieval(0);
		    }
		    FREE(CurrentUserAgent);
		    FREE(CurrentNegoLanguage);
		    FREE(CurrentNegoCharset);
		    return FALSE;
		}
d1450 2
a1451 37
		HEAD_request = HTLoadedDocumentIsHEAD();
		HText_setNoCache(HTMainText);
#ifdef NO_ASSUME_SAME_DOC
		newdoc.line = 1;
		newdoc.link = 0;
#else
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
		LYforce_no_cache = TRUE;
		free_address(&curdoc);	/* So it doesn't get pushed. */
	    }
	}
	FREE(CurrentUserAgent);
	FREE(CurrentNegoLanguage);
	FREE(CurrentNegoCharset);
	*refresh_screen = TRUE;	/* to repaint screen */
	return FALSE;
    }				/* end if !LYUseFormsOptions */
#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS
    /*
     * Generally stolen from LYK_COOKIE_JAR.  Options menu handling is
     * done in postoptions(), called from getfile() currently.
     *
     * postoptions() is also responsible for reloading the document
     * before the 'options menu' but only when (a few) important
     * options were changed.
     *
     * It is critical that post_data is freed here since the
     * submission of changed options is done via the same protocol as
     * LYNXOPTIONS:
     */
    /*
     * Don't do if already viewing options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU)) {
d1453 1
a1453 23
	set_address(&newdoc, LYNXOPTIONS_PAGE("/"));
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	/* change to 'if (check_realm && !LYValidate)' and
	   make change near top of getfile to forbid
	   using forms options menu with -validate:  - kw */
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in the options menu, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
#endif /* !NO_OPTION_FORMS */
    return FALSE;
}
d1455 11
a1465 8
static void handle_NEXT_DOC(void)
{
    if (LYhist_next(&curdoc, &newdoc)) {
	free_address(&curdoc);	/* avoid push */
	return;
    }
    HTUserMsg(gettext("No next document present"));
}
a1466 6
static void handle_LYK_NEXT_LINK(int c,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link < nlinks - 1) {	/* next link */
	LYhighlight(OFF, curdoc.link, prev_target);
d1468 36
a1503 8
	/*
	 * Move to different textarea if TAB in textarea.
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
	    c == '\t') {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;
d1505 4
a1508 9
	    do
		curdoc.link++;
	    while ((curdoc.link < nlinks - 1) &&
		   links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		   links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
		   links[curdoc.link].l_form->number == thisgroup &&
		   sametext(links[curdoc.link].l_form->name, thisname));
	} else {
	    curdoc.link++;
d1511 7
a1517 2
	curdoc.link++;
#endif /* FASTTAB */
d1519 2
a1520 2
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
d1522 68
a1589 2
    } else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
	set_curdoc_link(0);
d1591 1
a1591 2
    } else if (more) {		/* next page */
	Newline += (display_lines);
d1593 4
a1596 5
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}
d1598 1
a1598 12
static void handle_LYK_NEXT_PAGE(int *old_c,
				 int real_c)
{
    if (more) {
	Newline += display_lines;
    } else if (curdoc.link < nlinks - 1) {
	set_curdoc_link(nlinks - 1);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}
d1600 4
a1603 20
static BOOLEAN handle_LYK_NOCACHE(int *old_c,
				  int real_c)
{
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	    }
	    return FALSE;
	} else {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
    }
    return TRUE;
}
d1605 1
a1605 6
static void handle_LYK_PREV_LINK(int *arrowup,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link > 0) {	/* previous link */
	set_curdoc_link(curdoc.link - 1);
d1607 8
a1614 7
    } else if (!more &&
	       curdoc.link == 0 && Newline == 1) {	/* at the top of list */
	/*
	 * If there is only one page of data and the user goes off the top,
	 * just move the cursor to last link on the page.
	 */
	set_curdoc_link(nlinks - 1);
d1616 6
a1621 6
    } else if (curdoc.line > 1) {	/* previous page */
	/*
	 * Go back to the previous page.
	 */
	int scrollamount = (Newline > display_lines ?
			    display_lines : Newline - 1);
d1623 5
a1627 10
	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link == 0 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}
d1629 17
a1645 5
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}
d1647 124
a1770 1
#define nhist_1 (nhist - 1)	/* workaround for indent */
d1772 37
a1808 55
static int handle_PREV_DOC(int *cmd,
			   int *old_c,
			   int real_c)
{
    if (nhist > 0) {		/* if there is anything to go back to */
	/*
	 * Check if the previous document is a reply from a POST, and if so,
	 * seek confirmation of resubmission if the safe element is not set and
	 * the document is not still in the cache or LYresubmit_posts is set. 
	 * If not confirmed and it is not the startfile, pop it so we go to the
	 * yet previous document, until we're OK or reach the startfile.  If we
	 * reach the startfile and its not OK or we don't get confirmation,
	 * cancel.  - FM
	 */
	DocAddress WWWDoc;
	HTParentAnchor *tmpanchor;
	HText *text;
	BOOLEAN conf = FALSE, first = TRUE;

	HTLastConfirmCancelled();	/* reset flag */
	while (nhist > 0) {
	    conf = FALSE;
	    if (HDOC(nhist_1).post_data == NULL) {
		break;
	    }
	    WWWDoc.address = HDOC(nhist_1).address;
	    WWWDoc.post_data = HDOC(nhist_1).post_data;
	    WWWDoc.post_content_type =
		HDOC(nhist_1).post_content_type;
	    WWWDoc.bookmark = HDOC(nhist_1).bookmark;
	    WWWDoc.isHEAD = HDOC(nhist_1).isHEAD;
	    WWWDoc.safe = HDOC(nhist_1).safe;
	    tmpanchor = HTAnchor_findAddress(&WWWDoc);
	    if (HTAnchor_safe(tmpanchor)) {
		break;
	    }
	    if (((text = (HText *) HTAnchor_document(tmpanchor)) == NULL &&
		 (isLYNXIMGMAP(WWWDoc.address) ||
		  (conf = confirm_post_resub(WWWDoc.address,
					     HDOC(nhist_1).title,
					     0, 0))
		  == FALSE)) ||
		((LYresubmit_posts && !conf &&
		  (NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &newdoc))) &&
		 !confirm_post_resub(WWWDoc.address,
				     HDOC(nhist_1).title,
				     2, 2))) {
		if (HTLastConfirmCancelled()) {
		    if (!first && curdoc.internal_link)
			free_address(&curdoc);
		    *cmd = LYK_DO_NOTHING;
		    return 2;
d1810 3
a1812 16
		if (nhist == 1) {
		    HTInfoMsg(CANCELLED);
		    *old_c = 0;
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		} else {
		    HTUserMsg2(WWW_SKIP_MESSAGE, WWWDoc.address);
		    do {	/* Should be LYhist_prev when _next supports */
			LYpop(&curdoc);		/* skipping of forms */
		    } while (nhist > 1
			     && !are_different((DocInfo *) &history[nhist_1],
					       &curdoc));
		    first = FALSE;	/* have popped at least one */
		    continue;
		}
	    } else {
d1814 1
a1814 3
		 * Break from loop; if user just confirmed to load again
		 * because document wasn't in cache, set LYforce_no_cache to
		 * avoid unnecessary repeat question down the road.  - kw
d1816 26
a1841 2
		if (conf)
		    LYforce_no_cache = TRUE;
d1844 1
d1847 12
a1858 2
	if (!first)
	    curdoc.internal_link = FALSE;
d1860 18
a1877 12
	/*
	 * Set newdoc.address to empty to pop a file.
	 */
	LYhist_prev_register(&curdoc);	/* Why not call _prev instead of zeroing address?  */
	free_address(&newdoc);
#ifdef DIRED_SUPPORT
	if (lynx_edit_mode) {
	    DIRED_UNCACHE_2;
	}
#endif /* DIRED_SUPPORT */
    } else if (child_lynx == TRUE) {
	return (1);		/* exit on left arrow in main screen */
d1879 16
a1894 6
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(ALREADY_AT_FIRST);
    }
    return 0;
}
d1896 3
a1898 12
static void handle_LYK_PREV_PAGE(int *old_c,
				 int real_c)
{
    if (Newline > 1) {
	Newline -= display_lines;
    } else if (curdoc.link > 0) {
	set_curdoc_link(0);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}
d1900 3
a1902 11
static void handle_LYK_PRINT(BOOLEAN *ForcePush,
			     int *old_c,
			     int real_c)
{
    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(PRINT_DISABLED);
	}
	return;
    }
d1904 11
a1914 17
    /*
     * Don't do if already viewing print options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)
	&& print_options(&newdoc.address,
			 curdoc.address, HText_getNumOfLines()) >= 0) {
	LYRegisterUIPage(newdoc.address, UIP_PRINT_OPTIONS);
	StrAllocCopy(newdoc.title, PRINT_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	*ForcePush = TRUE;	/* see LYpush() and print_options() */
	if (check_realm)
	    LYPermitURL = TRUE;
    }
}
d1916 3
a1918 3
static BOOLEAN handle_LYK_QUIT(void)
{
    int c;
d1920 12
a1931 18
    if (LYQuitDefaultYes == TRUE) {
	c = HTConfirmDefault(REALLY_QUIT, YES);
    } else {
	c = HTConfirmDefault(REALLY_QUIT, NO);
    }
    if (LYQuitDefaultYes == TRUE) {
	if (c != NO) {
	    return (TRUE);
	} else {
	    HTInfoMsg(NO_CANCEL);
	}
    } else if (c == YES) {
	return (TRUE);
    } else {
	HTInfoMsg(NO_CANCEL);
    }
    return FALSE;
}
d1933 2
a1934 38
static BOOLEAN handle_LYK_RAW_TOGGLE(int *cmd)
{
    if (HTLoadedDocumentCharset()) {
	HTUserMsg(gettext("charset for this document specified explicitly, sorry..."));
	return FALSE;
    } else {
	LYUseDefaultRawMode = (BOOL) !LYUseDefaultRawMode;
	HTUserMsg(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
	HTMLSetCharacterHandling(current_char_set);
	return reparse_or_reload(cmd);
    }
}

static void handle_LYK_RELOAD(int real_cmd)
{
    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    /*
     * Check to see if should reload source, or load html
     */

    if (HTisDocumentSource()) {
	if ((forced_UCLYhdnl = HTMainText_Get_UCLYhndl()) >= 0)
	    force_old_UCLYhndl_on_reload = TRUE;
	srcmode_for_next_retrieval(1);
    }

    HEAD_request = HTLoadedDocumentIsHEAD();
    HText_setNoCache(HTMainText);
d1936 5
a1940 5
    /*
     * Don't assume the reloaded document will be the same.  - FM
     */
    newdoc.line = 1;
    newdoc.link = 0;
d1942 8
a1949 8
    /*
     * Do assume the reloaded document will be the same.  - FM
     *
     * (I don't remember all the reasons why we couldn't assume this.  As the
     * problems show up, we'll try to fix them, or add warnings.  - FM)
     */
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
d1951 1
a1951 1
    free_address(&curdoc);	/* so it doesn't get pushed */
d1953 1
a1953 1
    lynx_force_repaint();
d1955 11
a1965 10
    /*
     * Reload should force a cache refresh on a proxy.  -- Ari L. 
     * <luotonen@@dxcern.cern.ch>
     *
     * -- but only if this was really a reload requested by the user, not if we
     * jumped here to handle reloading for INLINE_TOGGLE, IMAGE_TOGGLE,
     * RAW_TOGGLE, etc.  - KW
     */
    if (real_cmd == LYK_RELOAD)
	reloading = TRUE;
d1967 39
a2005 38
    return;
}

#ifdef DIRED_SUPPORT
static void handle_LYK_REMOVE(BOOLEAN *refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int linkno = curdoc.link;	/* may be changed in local_remove - kw */

	local_remove(&curdoc);
	if (LYAutoUncacheDirLists >= 1)
	    do_cleanup_after_delete();
	else if (curdoc.link != linkno)
	    *refresh_screen = TRUE;
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_RIGHT_LINK(void)
{
    if (curdoc.link < nlinks - 1 &&
	links[curdoc.link].ly == links[curdoc.link + 1].ly) {
	set_curdoc_link(curdoc.link + 1);
    }
}

static void handle_LYK_SHELL(BOOLEAN *refresh_screen,
			     int *old_c,
			     int real_c)
{
    if (!no_shell) {
	stop_curses();
	printf("%s\r\n", SPAWNING_MSG);
#if defined(__CYGWIN__)
	/* handling "exec $SHELL" does not work if $SHELL is null */
	if (LYGetEnv("SHELL") == NULL) {
	    Cygwin_Shell();
	} else
d2007 1
a2007 2
	{
	    static char *shell = NULL;
d2009 4
a2012 18
	    if (shell == 0)
		StrAllocCopy(shell, LYSysShell());
	    LYSystem(shell);
	}
	start_curses();
	*refresh_screen = TRUE;	/* for an HText_pageDisplay() */
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(SPAWNING_DISABLED);
	}
    }
}

static void handle_LYK_SOFT_DQUOTES(void)
{
#ifdef USE_SOURCE_CACHE
    if (!HTcan_reparse_document()) {
d2014 20
a2033 16
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
d2035 15
a2049 5
    soft_dquotes = !soft_dquotes;
    HTUserMsg(soft_dquotes ?
	      SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
d2051 1
a2051 2
    return;
}
d2053 23
a2075 8
static void handle_LYK_SOURCE(char **ownerS_address_p)
{
    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
#ifdef USE_SOURCE_CACHE
    BOOLEAN canreparse_post = FALSE;
d2077 10
a2086 43
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
#ifdef USE_SOURCE_CACHE
	(!(canreparse_post = HTcan_reparse_document())) &&
#endif
	(curdoc.isHEAD ? HTConfirm(CONFIRM_POST_RESUBMISSION) :
	 confirm_post_resub(curdoc.address, curdoc.title, 1, 1)) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (HTisDocumentSource()) {
	srcmode_for_next_retrieval(-1);
    } else {
	if (HText_getOwner())
	    StrAllocCopy(*ownerS_address_p, HText_getOwner());
	LYUCPushAssumed(HTMainAnchor);
	srcmode_for_next_retrieval(1);
    }

#ifdef USE_SOURCE_CACHE
    if (reparse_document()) {
	/*
	 * These normally get cleaned up after getfile() returns;
	 * since we're not calling getfile(), we have to clean them
	 * up ourselves.  -dsb
	 */
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    HTMark_asSource();
	psrc_view = FALSE;
#endif
	FREE(*ownerS_address_p);	/* not used with source_cache */
	LYUCPopAssumed();	/* probably a right place here */
	HTMLSetCharacterHandling(current_char_set);	/* restore now */

	return;
    } else if (canreparse_post) {
	srcmode_for_next_retrieval(0);
	LYUCPopAssumed();	/* probably a right place here */
	return;
    }
d2088 1
d2090 3
a2092 12
    if (curdoc.title)
	StrAllocCopy(newdoc.title, curdoc.title);
    free_address(&curdoc);	/* so it doesn't get pushed */
    LYforce_no_cache = TRUE;
}

static void handle_LYK_SWITCH_DTD(void)
{
#ifdef USE_SOURCE_CACHE
    BOOLEAN canreparse = FALSE;

    if (!(canreparse = HTcan_reparse_document())) {
a2093 10
	/*
	 * Check if this is a reply from a POST, and if so,
	 * seek confirmation of reload if the safe element
	 * is not set.  - FM, kw
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
d2095 3
a2097 3
	     * If currently viewing preparsed source, switching to the other
	     * DTD parsing may show source differences, so stay in source view
	     * - kw
d2099 11
d2111 16
a2126 10
	    /* NOTE: this conditional can be considered incorrect -
	       current behaviour - when viewing source and
	       LYPreparsedSource==TRUE, pressing ^V will toggle parser mode
	       AND switch back from the source view to presentation view.-HV
	     */
	    if (HTisDocumentSource() && LYPreparsedSource) {
		srcmode_for_next_retrieval(1);
	    }
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
d2128 2
a2129 2
	    newdoc.line = 1;
	    newdoc.link = 0;
d2131 2
a2132 2
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
d2134 3
a2136 3
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
d2138 10
a2147 12
    Old_DTD = !Old_DTD;
    HTSwitchDTD(!Old_DTD);
    HTUserMsg(Old_DTD ? USING_DTD_0 : USING_DTD_1);
#ifdef USE_SOURCE_CACHE
    if (canreparse) {
	if (HTisDocumentSource() && LYPreparsedSource) {
	    srcmode_for_next_retrieval(1);
	}
	if (!reparse_document()) {
	    srcmode_for_next_retrieval(0);
	}
    }
d2149 1
a2149 30
    return;
}

#ifdef DIRED_SUPPORT
static void handle_LYK_TAG_LINK(void)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	if (!strcmp(LYGetHiliteStr(curdoc.link, 0), ".."))
	    return;		/* Never tag the parent directory */
	if (dir_list_style == MIXED_STYLE) {
	    if (!strcmp(LYGetHiliteStr(curdoc.link, 0), "../"))
		return;
	} else if (!strncmp(LYGetHiliteStr(curdoc.link, 0), "Up to ", 6))
	    return;
	{
	    /*
	     * HTList-based management of tag list, see LYLocal.c - KW
	     */
	    HTList *t1 = tagged;
	    char *tagname = NULL;
	    BOOLEAN found = FALSE;

	    while ((tagname = (char *) HTList_nextObject(t1)) != NULL) {
		if (!strcmp(links[curdoc.link].lname, tagname)) {
		    found = TRUE;
		    HTList_removeObject(tagged, tagname);
		    FREE(tagname);
		    tagflag(OFF, curdoc.link);
		    break;
		}
d2151 2
a2152 7
	    if (!found) {
		if (tagged == NULL)
		    tagged = HTList_new();
		tagname = NULL;
		StrAllocCopy(tagname, links[curdoc.link].lname);
		HTList_addObject(tagged, tagname);
		tagflag(ON, curdoc.link);
d2154 3
a2156 11
	}
	if (curdoc.link < nlinks - 1) {
	    set_curdoc_link(curdoc.link + 1);
	} else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
	    set_curdoc_link(0);
	} else if (more) {	/* next page */
	    Newline += (display_lines);
	}
    }
}
#endif /* DIRED_SUPPORT */
d2158 5
a2162 111
static void handle_LYK_TOGGLE_HELP(void)
{
    if (user_mode == NOVICE_MODE) {
	toggle_novice_line();
	noviceline(more);
    }
}

static void handle_LYK_TOOLBAR(BOOLEAN *try_internal,
			       BOOLEAN *force_load,
			       int *old_c,
			       int real_c)
{
    char *cp;
    char *toolbar = NULL;

    if (!HText_hasToolbar(HTMainText)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_TOOLBAR);
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	cp = trimPoundSelector(curdoc.address);
	HTSprintf0(&toolbar, "%s#%s", curdoc.address, LYToolbarName);
	restorePoundSelector(cp);
	set_address(&newdoc, toolbar);
	FREE(toolbar);
	*try_internal = TRUE;
	*force_load = TRUE;	/* force MainLoop to reload */
    }
}

static void handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr)
{
#ifndef NO_LYNX_TRACE
    /*
     * Check whether we've started a TRACE log in this session.  - FM
     */
    if (LYTraceLogFP == NULL) {
	HTUserMsg(NO_TRACELOG_STARTED);
	return;
    }

    /*
     * Don't do if already viewing the TRACE log.  - FM
     */
    if (LYIsUIPage(curdoc.address, UIP_TRACELOG))
	return;

    /*
     * If TRACE mode is on, turn it off during this fetch of the TRACE log, so
     * we don't enter stuff about this fetch, and set a flag for turning it
     * back on when we return to this loop.  Note that we'll miss any messages
     * about memory exhaustion if it should occur.  It seems unlikely that
     * anything else bad might happen, but if it does, we'll miss messages
     * about that too.  We also fflush(), close, and open it again, to make
     * sure all stderr messages thus far will be in the log.  - FM
     */
    if (!LYReopenTracelog(trace_flag_ptr))
	return;

    LYLocalFileToURL(&(newdoc.address), LYTraceLogPath);
    LYRegisterUIPage(newdoc.address, UIP_TRACELOG);
    StrAllocCopy(newdoc.title, LYNX_TRACELOG_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
    }
    LYforce_no_cache = TRUE;
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

#ifdef DIRED_SUPPORT
static void handle_LYK_UPLOAD(void)
{
    /*
     * Don't do if already viewing upload options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS))
	return;

    if (lynx_edit_mode && !no_dired_support) {
	LYUpload_options(&(newdoc.address), curdoc.address);
	StrAllocCopy(newdoc.title, UPLOAD_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 * Uncache the current listing so that it will be updated to included
	 * the uploaded file if placed in the current directory.  - FM
	 */
	DIRED_UNCACHE_1;
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_UP_HALF(int *arrowup,
			       int *old_c,
			       int real_c)
{
    if (Newline > 1) {
	int scrollamount = display_lines / 2;
d2164 3
a2166 9
	if (Newline - scrollamount < 1)
	    scrollamount = Newline - 1;
	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
		    HText_LinksInLines(HTMainText,
				       Newline,
				       scrollamount);
d2168 1
a2168 1
		*arrowup = TRUE;
d2170 8
a2177 70
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_UP_LINK(int *follow_col,
			       int *arrowup,
			       int *old_c,
			       int real_c)
{
    if (curdoc.link > 0 &&
	(links[0].ly != links[curdoc.link].ly ||
	 !HText_LinksInLines(HTMainText, 1, Newline - 1))) {
	/* more links before this on screen, and first of them on
	   a different line or no previous links before this screen? */
	int newlink;

	if (*follow_col == -1) {
	    const char *text = LYGetHiliteStr(curdoc.link, 0);

	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, -1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_ABOVE);
	}

    } else if (curdoc.line > 1 && Newline > 1) {	/* previous page */
	int scrollamount = (Newline > display_lines ?
			    display_lines : Newline - 1);

	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link > -1 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_UP_TWO(int *arrowup,
			      int *old_c,
			      int real_c)
{
    if (Newline > 1) {
	int scrollamount = (Newline > 2 ? 2 : 1);

	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
		    HText_LinksInLines(HTMainText,
				       Newline, scrollamount);
d2179 1
a2179 1
		*arrowup = TRUE;
d2181 1
a2181 6
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}
d2183 2
a2184 5
static void handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
{
    const char *cp;
d2186 11
a2196 7
    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }
d2198 9
a2206 30
    /*
     * See if a bookmark exists.  If it does replace newdoc.address with its
     * name.
     */
    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL) {
	if (*cp == '\0' || !strcmp(cp, " ") ||
	    !strcmp(curdoc.address, newdoc.address)) {
	    if (LYMultiBookmarks != MBM_OFF)
		*refresh_screen = TRUE;
	    return;
	}
#ifdef KANJI_CODE_OVERRIDE
	if (HTCJK == JAPANESE) {
	    last_kcode = NOKANJI;	/* AUTO */
	}
#endif
	LYforce_no_cache = TRUE;	/*force the document to be reloaded */
	StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
	StrAllocCopy(newdoc.bookmark, BookmarkPage);
	LYFreePostData(&newdoc);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    LYMBM_statusline(BOOKMARKS_NOT_OPEN);
	    LYSleepAlert();
	    if (LYMultiBookmarks != MBM_OFF) {
		*refresh_screen = TRUE;
d2208 1
a2208 3
	}
    }
}
d2210 18
a2227 4
static BOOLEAN handle_LYK_VLINKS(int *cmd,
				 BOOLEAN *newdoc_link_is_absolute)
{
    int c;
d2229 14
a2242 7
    if (LYIsUIPage(curdoc.address, UIP_VLINKS)) {
	/*
	 * Already viewing visited links page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
d2244 21
a2264 25
    /*
     * Print visited links page to file.
     */
    c = LYShowVisitedLinks(&newdoc.address);
    if (c < 0) {
	HTUserMsg(VISITED_LINKS_EMPTY);
	return FALSE;
    }
    StrAllocCopy(newdoc.title, VISITED_LINKS_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (c > 0) {
	/* Select a correct link. */
	*newdoc_link_is_absolute = TRUE;
	newdoc.link = c - 1;
    }
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlinksfile, newdoc.address);
    }
    return FALSE;
}
d2266 14
a2279 8
void handle_LYK_WHEREIS(int cmd,
			BOOLEAN *refresh_screen)
{
    BOOLEAN have_target_onscreen = (BOOLEAN) (*prev_target != '\0' &&
					      HText_pageHasPrevTarget());
    BOOL found;
    int oldcur = curdoc.link;	/* temporarily remember */
    char *remember_old_target = NULL;
d2281 4
a2284 4
    if (have_target_onscreen)
	StrAllocCopy(remember_old_target, prev_target);
    else
	StrAllocCopy(remember_old_target, "");
d2286 8
a2293 13
    if (cmd == LYK_WHEREIS) {
	/*
	 * Reset prev_target to force prompting for a new search string and to
	 * turn off highlighting if no search string is entered by the user.
	 */
	*prev_target = '\0';
    }
    found = textsearch(&curdoc, prev_target, sizeof(prev_target) - 1,
		       (cmd == LYK_WHEREIS)
		       ? 0
		       : ((cmd == LYK_NEXT)
			  ? 1
			  : -1));
d2295 9
a2303 28
    /*
     * Force a redraw to ensure highlighting of hits even when found on the
     * same page, or clearing of highlighting if the default search string was
     * erased without replacement.  - FM
     */
    /*
     * Well let's try to avoid it at least in a few cases
     * where it is not needed. - kw
     */
    if (www_search_result >= 0 && www_search_result != curdoc.line) {
	*refresh_screen = TRUE;	/* doesn't really matter */
    } else if (!found) {
	*refresh_screen = have_target_onscreen;
    } else if (!have_target_onscreen && found) {
	*refresh_screen = TRUE;
    } else if (www_search_result == curdoc.line &&
	       curdoc.link == oldcur &&
	       curdoc.link >= 0 && nlinks > 0 &&
	       links[curdoc.link].ly >= (display_lines / 3)) {
	*refresh_screen = TRUE;
    } else if ((case_sensitive && 0 != strcmp(prev_target,
					      remember_old_target)) ||
	       (!case_sensitive && 0 != strcasecomp8(prev_target,
						     remember_old_target))) {
	*refresh_screen = TRUE;
    }
    FREE(remember_old_target);
}
d2305 7
a2311 13
/*
 * Get a number from the user and follow that link number.
 */
static void handle_LYK_digit(int c,
			     BOOLEAN *force_load,
			     char *user_input_buffer,
			     int *old_c,
			     int real_c,
			     BOOLEAN *try_internal GCC_UNUSED)
{
    int lindx = ((nlinks > 0) ? curdoc.link : 0);
    int number;
    char *temp = NULL;
d2313 2
a2314 65
    /* pass cur line num for use in follow_link_number()
     * Note: Current line may not equal links[cur].line
     */
    number = curdoc.line;
    switch (follow_link_number(c, lindx, &newdoc, &number)) {
    case DO_LINK_STUFF:
	/*
	 * Follow a normal link.
	 */
	set_address(&newdoc, links[lindx].lname);
	StrAllocCopy(newdoc.title, LYGetHiliteStr(lindx, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	/*
	 * For internal links, retain POST content if present.  If we are on
	 * the List Page, prevent pushing it on the history stack.  Otherwise
	 * set try_internal to signal that the top of the loop should attempt
	 * to reposition directly, without calling getfile.  - kw
	 */
	if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
	    LYinternal_flag = TRUE;
	    newdoc.internal_link = TRUE;
	    if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		(LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		 LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		if (check_history()) {
		    LYinternal_flag = TRUE;
		} else {
		    HTLastConfirmCancelled();	/* reset flag */
		    if (!confirm_post_resub(newdoc.address,
					    newdoc.title,
					    ((LYresubmit_posts &&
					      HText_POSTReplyLoaded(&newdoc))
					     ? 1
					     : 2),
					    2)) {
			if (HTLastConfirmCancelled() ||
			    (LYresubmit_posts &&
			     !HText_POSTReplyLoaded(&newdoc))) {
			    /* cancel the whole thing */
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    copy_address(&newdoc, &curdoc);
			    StrAllocCopy(newdoc.title, curdoc.title);
			    newdoc.internal_link = curdoc.internal_link;
			    HTInfoMsg(CANCELLED);
			    if (nlinks > 0)
				HText_pageDisplay(curdoc.line, prev_target);
			    break;
			} else if (LYresubmit_posts) {
			    /* If LYresubmit_posts is set, and the
			       answer was No, and we have a cached
			       copy, then use it. - kw */
			    LYforce_no_cache = FALSE;
			} else {
			    /* if No, but not ^C or ^G, drop
			     * the post data.  Maybe the link
			     * wasn't meant to be internal after
			     * all, here we can recover from that
			     * assumption. - kw */
			    LYFreePostData(&newdoc);
			    newdoc.internal_link = FALSE;
			    HTAlert(DISCARDING_POST_DATA);
			}
		    }
		}
d2316 4
a2319 2
		 * Don't push the List Page if we follow an internal link given
		 * by it.  - kw
d2321 2
a2322 29
		free_address(&curdoc);
	    } else
		*try_internal = TRUE;
	    if (!(LYresubmit_posts && newdoc.post_data))
		LYinternal_flag = TRUE;
	    *force_load = TRUE;
	    break;
	} else {
	    /*
	     * Free POST content if not an internal link.  - kw
	     */
	    LYFreePostData(&newdoc);
	}
#endif /* DONT_TRACK_INTERNAL_LINKS */
	/*
	 * Might be an anchor in the same doc from a POST form.  If so, don't
	 * free the content.  -- FM
	 */
	if (are_different(&curdoc, &newdoc)) {
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    if (isLYNXMESSAGES(newdoc.address))
		LYforce_no_cache = TRUE;
	}
	newdoc.internal_link = FALSE;
	*force_load = TRUE;	/* force MainLoop to reload */
	break;
d2324 13
a2336 23
    case DO_GOTOLINK_STUFF:
	/*
	 * Position on a normal link, don't follow it.  - KW
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
	    /*
	     * It's a link in the current page.  - FM
	     */
	    if (nlinks > 0 && curdoc.link > -1) {
		if (curdoc.link == newdoc.link) {
		    /*
		     * It's the current link, and presumably reflects a typo in
		     * the statusline entry, so issue a statusline message for
		     * the typo-prone users (like me 8-).  - FM
		     */
		    StrAllocCopy(temp, user_input_buffer);
		    sprintf(user_input_buffer,
			    LINK_ALREADY_CURRENT, number);
		    HTUserMsg(user_input_buffer);
		    LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		    FREE(temp);
d2338 1
a2338 5
		    /*
		     * It's a different link on this page,
		     */
		    set_curdoc_link(newdoc.link);
		    newdoc.link = 0;
d2340 4
d2345 1
a2345 2
	}
	break;			/* nothing more to do */
d2347 25
a2371 7
    case DO_GOTOPAGE_STUFF:
	/*
	 * Position on a page in this document.  - FM
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
d2373 2
a2374 2
	     * It's the current page, so issue a statusline message for the
	     * typo-prone users (like me 8-).  - FM
d2376 3
a2378 14
	    if (Newline <= 1) {
		HTInfoMsg(ALREADY_AT_BEGIN);
	    } else if (!more) {
		HTInfoMsg(ALREADY_AT_END);
	    } else {
		StrAllocCopy(temp, user_input_buffer);
		sprintf(user_input_buffer,
			ALREADY_AT_PAGE, number);
		HTUserMsg(user_input_buffer);
		LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		FREE(temp);
	    }
	}
	break;
d2380 2
a2381 7
    case PRINT_ERROR:
	*old_c = real_c;
	HTUserMsg(BAD_LINK_NUM_ENTERED);
	break;
    }
    return;
}
d2383 5
a2387 1
#ifdef SUPPORT_CHDIR
d2389 4
a2392 5
/* original implementation by VH */
void handle_LYK_CHDIR(void)
{
    static char buf[LY_MAXPATH];
    char *p = NULL;
d2394 37
a2430 4
    if (no_chdir) {
	HTUserMsg(CHDIR_DISABLED);
	return;
    }
d2432 7
a2438 8
    _statusline(gettext("cd to:"));
    /* some people may prefer automatic clearing of the previous user input,
       here, to do this, just uncomment next line - VH */
    /* buf[0]='\0'; */
    if (LYgetstr(buf, VISIBLE, sizeof(buf) - 1, NORECALL) < 0 || !*buf) {
	HTInfoMsg(CANCELLED);
	return;
    }
d2440 11
a2450 22
    if (*buf == '~' && !buf[1]) {
	StrAllocCopy(p, Home_Dir());
    } else if (*buf == '~') {
	HTSprintf0(&p, "%s%s", Home_Dir(), buf + 1);
    } else {
	StrAllocCopy(p, buf);
    }

    CTRACE((tfp, "changing directory to '%s'\n", p));
    if (chdir(p)) {
	switch (errno) {
	case EACCES:
	    HTInfoMsg(COULD_NOT_ACCESS_DIR);
	    break;
	case ENOENT:
	    HTInfoMsg(gettext("No such directory"));
	    break;
	case ENOTDIR:
	    HTInfoMsg(gettext("A component of path is not a directory"));
	    break;
	default:
	    HTInfoMsg(gettext("failed to change directory"));
d2453 98
a2550 10
    } else {
#ifdef DIRED_SUPPORT
	/*if in dired, load content of other directory */
	if (!no_dired_support
	    && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
	    char buf2[LY_MAXPATH];
	    char *addr = NULL;

	    Current_Dir(buf2);
	    LYLocalFileToURL(&addr, buf2);
d2552 3
a2554 10
	    newdoc.address = addr;
	    newdoc.isHEAD = FALSE;
	    StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    /**force_load = TRUE;*/
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
a2555 29
	} else
#endif
	    HTInfoMsg(OPERATION_DONE);
    }
    FREE(p);
}
#endif

#ifdef USE_CURSES_PADS
/*
 * Having jumps larger than this is counter-productive.  Indeed, it is natural
 * to expect that when the relevant text appears, one would "overshoot" and
 * would scroll 3-4 extra full screens.  When going back, the "accumulation"
 * logic would again start moving in full screens, so one would overshoot
 * again, etc.
 *
 * Going back, one can fix it in 28 keypresses. The relevant text will appear
 * on the screen soon enough for the key-repeat to become not that important,
 * and we are still moving in smaller steps than when we overshot.  Since key
 * repeat is not important, even if we overshoot again, it is going to be by 30
 * steps, which is easy to fix by reversing the direction again.
 */
static int repeat_to_delta(int n)
{
    int threshold = LYcols / 3;

    while (threshold > 0) {
	if (n >= threshold) {
	    n = threshold;
a2557 4
	threshold = (threshold * 2) / 3;
    }
    return n;
}
d2559 28
a2586 13
static void handle_LYK_SHIFT_LEFT(BOOLEAN *flag, int count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    if (LYshiftWin > 0) {
	LYshiftWin -= repeat_to_delta(count);
	*flag = TRUE;
    }
    if (LYshiftWin < 0)
	LYshiftWin = 0;
}
d2588 9
a2596 9
static void handle_LYK_SHIFT_RIGHT(BOOLEAN *flag, int count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    LYshiftWin += repeat_to_delta(count);
    *flag = TRUE;
}
d2598 13
a2610 27
static BOOLEAN handle_LYK_LINEWRAP_TOGGLE(int *cmd,
					  BOOLEAN *flag)
{
    static const char *choices[] =
    {
	"Try to fit screen width",
	"No line wrap in columns",
	"Wrap columns at screen width",
	"Wrap columns at 3/4 screen width",
	"Wrap columns at 2/3 screen width",
	"Wrap columns at 1/2 screen width",
	"Wrap columns at 1/3 screen width",
	"Wrap columns at 1/4 screen width",
	NULL
    };
    static int wrap[] =
    {
	0,
	0,
	12,			/* In units of 1/12 */
	9,
	8,
	6,
	4,
	3
    };
    int c;
d2612 5
a2616 2
    if (LYwin == stdscr)
	return FALSE;
d2618 8
a2625 14
    /* Somehow the mouse is over the number instead of being over the
       name, so we decrease x. */
    c = LYChoosePopup(!LYwideLines, LYlines / 2 - 2, LYcolLimit / 2 - 6,
		      choices, TABLESIZE(choices) - 1, FALSE, TRUE);
    /*
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
     */
    if (term_options)
	return FALSE;
    LYwideLines = c;
    LYtableCols = wrap[c];
d2627 27
a2653 7
    if (LYwideLines == 0)
	LYshiftWin = 0;
    *flag = TRUE;
    HTUserMsg(LYwideLines ? LINEWRAP_OFF : LINEWRAP_ON);
    return reparse_or_reload(cmd);
}
#endif
d2655 5
a2659 8
/*
 * Here's where we do all the work.
 * mainloop is basically just a big switch dependent on the users input.  I
 * have tried to offload most of the work done here to procedures to make it
 * more modular, but this procedure still does a lot of variable manipulation. 
 * This needs some work to make it neater.  - Lou Moutilli
 *					(memoir from the original Lynx - FM)
 */
d2661 3
a2663 46
int mainloop(void)
{
#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
#undef	STRING_MAX
#define	STRING_MAX	4096
    char temp_buff[STRING_MAX];

#define	BUFF_MAX	1024
    char sjis_buff[BUFF_MAX];
#endif
    int c = 0;
    int real_c = 0;
    int old_c = 0;
    int pending_form_c = -1;
    int cmd = LYK_DO_NOTHING, real_cmd = LYK_DO_NOTHING;
    int getresult;
    int arrowup = FALSE, show_help = FALSE;
    char user_input_buffer[MAX_LINE];
    const char *cshelpfile = NULL;
    BOOLEAN first_file = TRUE;
    BOOLEAN popped_doc = FALSE;
    BOOLEAN refresh_screen = FALSE;
    BOOLEAN force_load = FALSE;
    BOOLEAN try_internal = FALSE;
    BOOLEAN crawl_ok = FALSE;
    BOOLEAN vi_keys_flag = vi_keys;
    BOOLEAN emacs_keys_flag = emacs_keys;
    BOOLEAN trace_mode_flag = FALSE;
    BOOLEAN forced_HTML_mode = LYforce_HTML_mode;
    char cfile[128];
    FILE *cfp;
    char *cp;
    int ch;
    RecallType recall;
    int URLTotal;
    int URLNum;
    BOOLEAN FirstURLRecall = TRUE;
    char *temp = NULL;
    BOOLEAN ForcePush = FALSE;
    BOOLEAN override_LYresubmit_posts = FALSE;
    BOOLEAN newdoc_link_is_absolute = FALSE;
    BOOLEAN curlink_is_editable;
    BOOLEAN use_last_tfpos;
    unsigned int len;
    int i;
    int follow_col = -1, key_count = 0, last_key = 0;
d2665 7
a2671 5
    /* "internal" means "within the same document, with certainty".  It includes a
     * space so it cannot conflict with any (valid) "TYPE" attributes on A
     * elements.  [According to which DTD, anyway??] - kw
     */
    HTInternalLink = HTAtom_for("internal link");	/* init, used as const */
d2673 7
a2679 74
#ifndef WWW_SOURCE
    WWW_SOURCE = HTAtom_for("www/source");	/* init, used as const */
#endif

    /*
     * curdoc.address contains the name of the file that is currently open.
     * newdoc.address contains the name of the file that will soon be
     *                opened if it exits.
     * prev_target    contains the last search string the user searched for.
     * newdoc.title   contains the link name that the user last chose to get
     *                into the current link (file).
     */
    /* initialize some variables */
    newdoc.address = NULL;
    newdoc.title = NULL;
    newdoc.post_data = NULL;
    newdoc.post_content_type = NULL;
    newdoc.bookmark = NULL;
    newdoc.internal_link = FALSE;
    curdoc.address = NULL;
    curdoc.title = NULL;
    curdoc.post_data = NULL;
    curdoc.post_content_type = NULL;
    curdoc.bookmark = NULL;
    curdoc.internal_link = FALSE;
#ifdef USE_COLOR_STYLE
    curdoc.style = NULL;
    newdoc.style = NULL;
#endif
    nhist = 0;
    user_input_buffer[(sizeof(user_input_buffer) - 1)] = '\0';
    *prev_target = '\0';
    *user_input_buffer = '\0';
#ifdef LY_FIND_LEAKS
    atexit(free_mainloop_variables);
#endif
  initialize:
    set_address(&newdoc, startfile);
    StrAllocCopy(startrealm, startfile);
    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.line = 1;
    newdoc.link = 0;

#ifdef USE_SLANG
    if (TRACE && LYCursesON) {
	LYaddstr("\n");
	LYrefresh();
    }
#endif /* USE_SLANG */
    CTRACE((tfp, "Entering mainloop, startfile=%s\n", startfile));

    if (form_post_data) {
	BStrCopy0(newdoc.post_data, form_post_data);
	StrAllocCopy(newdoc.post_content_type,
		     "application/x-www-form-urlencoded");
    } else if (form_get_data) {
	StrAllocCat(newdoc.address, form_get_data);
    }

    if (bookmark_start) {
	if (LYValidate) {
	    HTAlert(BOOKMARKS_DISABLED);
	    bookmark_start = FALSE;
	    goto initialize;
	} else if (traversal) {
	    HTAlert(BOOKMARKS_NOT_TRAVERSED);
	    traversal = FALSE;
	    crawl = FALSE;
	    bookmark_start = FALSE;
	    goto initialize;
	} else {
	    const char *cp1;
d2681 1
d2683 1
a2683 2
	     * See if a bookmark page exists.  If it does, replace
	     * newdoc.address with its name
d2685 6
a2690 6
	    if ((cp1 = get_bookmark_filename(&newdoc.address)) != NULL &&
		*cp1 != '\0' && strcmp(cp1, " ")) {
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		StrAllocCopy(startrealm, newdoc.address);
		LYFreePostData(&newdoc);
d2693 4
a2696 95
		CTRACE((tfp, "Using bookmarks=%s\n", newdoc.address));
	    } else {
		HTUserMsg(BOOKMARKS_NOT_OPEN);
		bookmark_start = FALSE;
		goto initialize;
	    }
	}
    }

    FREE(form_post_data);
    FREE(form_get_data);

    if (user_mode == NOVICE_MODE)
	display_lines = LYlines - 4;
    else
	display_lines = LYlines - 2;

    while (TRUE) {
#ifdef USE_COLOR_STYLE
	if (curdoc.style != NULL)
	    force_load = TRUE;
#endif
	/*
	 * If newdoc.address is different from curdoc.address then we need to
	 * go out and find and load newdoc.address.
	 */
	if (LYforce_no_cache || force_load ||
	    are_different(&curdoc, &newdoc)) {

	    force_load = FALSE;	/* done */
	    if (TRACE && LYCursesON) {
		LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
	    }
	  try_again:
	    /*
	     * Push the old file onto the history stack if we have a current
	     * doc and a new address.  - FM
	     */
	    if (curdoc.address && newdoc.address) {
		/*
		 * Don't actually push if this is a LYNXDOWNLOAD URL, because
		 * that returns NORMAL even if it fails due to a spoof attempt
		 * or file access problem, and we set the newdoc structure
		 * elements to the curdoc structure elements under case NORMAL. 
		 * - FM
		 */
		if (!isLYNXDOWNLOAD(newdoc.address)) {
		    LYpush(&curdoc, ForcePush);
		}
	    } else if (!newdoc.address) {
		/*
		 * If newdoc.address is empty then pop a file and load it.  -
		 * FM
		 */
		LYhist_prev(&newdoc);
		popped_doc = TRUE;

#ifndef DONT_TRACK_INTERNAL_LINKS
		/*
		 * If curdoc had been reached via an internal
		 * (fragment) link from what we now have just
		 * popped into newdoc, then override non-caching in
		 * all cases. - kw
		 */
		if (curdoc.internal_link &&
		    !are_phys_different(&curdoc, &newdoc)) {
		    LYinternal_flag = TRUE;
		    LYoverride_no_cache = TRUE;
		    LYforce_no_cache = FALSE;
		    try_internal = TRUE;
		} else
#endif /* TRACK_INTERNAL_LINKS */
		{
		    /*
		     * Force a no_cache override unless it's a bookmark file,
		     * or it has POST content and LYresubmit_posts is set
		     * without safe also set, and we are not going to another
		     * position in the current document or restoring the
		     * previous document due to a NOT_FOUND or NULLFILE return
		     * value from getfile().  - FM
		     */
		    if ((newdoc.bookmark != NULL) ||
			(newdoc.post_data != NULL &&
			 !newdoc.safe &&
			 LYresubmit_posts &&
			 !override_LYresubmit_posts &&
			 NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			LYoverride_no_cache = FALSE;
		    } else {
			LYoverride_no_cache = TRUE;
		    }
d2698 6
d2705 19
a2723 1
	    override_LYresubmit_posts = FALSE;
a2724 1
	    if (HEAD_request) {
d2726 1
a2726 1
		 * Make SURE this is an appropriate request.  - FM
d2728 3
a2730 12
		if (newdoc.address) {
		    if (LYCanDoHEAD(newdoc.address) == TRUE) {
			newdoc.isHEAD = TRUE;
		    } else if (isLYNXIMGMAP(newdoc.address)) {
			if (LYCanDoHEAD(newdoc.address + LEN_LYNXIMGMAP) == TRUE) {
			    StrAllocCopy(temp, newdoc.address + LEN_LYNXIMGMAP);
			    free_address(&newdoc);
			    newdoc.address = temp;
			    newdoc.isHEAD = TRUE;
			    temp = NULL;
			}
		    }
d2732 9
a2740 3
		try_internal = FALSE;
		HEAD_request = FALSE;
	    }
d2742 6
d2749 17
a2765 9
	     * If we're getting the TRACE log and it's not new, check whether
	     * its HText structure has been dumped, and if so, fflush() and
	     * fclose() it to ensure it's fully updated, and then fopen() it
	     * again.  - FM
	     */
	    if (LYUseTraceLog == TRUE &&
		trace_mode_flag == FALSE &&
		LYTraceLogFP != NULL &&
		LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
d2768 2
d2771 65
a2835 12
		WWWDoc.address = newdoc.address;
		WWWDoc.post_data = newdoc.post_data;
		WWWDoc.post_content_type = newdoc.post_content_type;
		WWWDoc.bookmark = newdoc.bookmark;
		WWWDoc.isHEAD = newdoc.isHEAD;
		WWWDoc.safe = newdoc.safe;
		tmpanchor = HTAnchor_findAddress(&WWWDoc);
		if ((HText *) HTAnchor_document(tmpanchor) == NULL) {
		    if (!LYReopenTracelog(&trace_mode_flag)) {
			old_c = 0;
			cmd = LYK_PREV_DOC;
			goto new_cmd;
a2837 1
	    }
d2839 2
a2840 10
	    LYRequestTitle = newdoc.title;
	    if (newdoc.bookmark)
		LYforce_HTML_mode = TRUE;
	    if (LYValidate &&
		startfile_ok &&
		newdoc.address && startfile && homepage &&
		(!strcmp(newdoc.address, startfile) ||
		 !strcmp(newdoc.address, homepage))) {
		LYPermitURL = TRUE;
	    }
d2842 10
a2851 23
	    /* reset these two variables here before getfile()
	     * so they will be available in partial mode
	     * (was previously implemented in case NORMAL).
	     */
	    *prev_target = '\0';	/* Reset for new coming document */
	    Newline = newdoc.line;	/* set for LYGetNewline() */

#ifdef USE_PRETTYSRC
	    psrc_first_tag = TRUE;
#endif
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = textfields_activation_option;
#endif
	    FREE(LYRequestReferer);
	    /*
	     * Don't send Referer if we have to load a document again that we
	     * got from the history stack.  We don't know any more how we
	     * originally got to that page.  Using a Referer based on the
	     * current HTMainText could only be right by coincidence.  - kw
	     * 1999-11-01
	     */
	    if (popped_doc)
		LYNoRefererForThis = TRUE;
d2853 3
a2855 9
#ifndef DONT_TRACK_INTERNAL_LINKS
	    if (try_internal) {
		if (newdoc.address &&
		    isLYNXIMGMAP(newdoc.address)) {
		    try_internal = FALSE;
		} else if (curdoc.address &&
			   isLYNXIMGMAP(curdoc.address)) {
		    try_internal = FALSE;
		}
d2857 1
a2857 2
	    if (try_internal) {
		char *hashp = findPoundSelector(newdoc.address);
d2859 13
a2871 15
		if (hashp) {
		    HTFindPoundSelector(hashp + 1);
		}
		getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		try_internal = FALSE;	/* done */
		/* fix up newdoc.address which may have been fragment-only */
		if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
		    if (!hashp) {
			set_address(&newdoc, HTLoadedDocumentURL());
		    } else {
			StrAllocCopy(temp, HTLoadedDocumentURL());
			StrAllocCat(temp, hashp);	/* append fragment */
			set_address(&newdoc, temp);
			FREE(temp);
		    }
d2873 1
a2873 4
	    } else {
		if (newdoc.internal_link && newdoc.address &&
		    *newdoc.address == '#' && nhist > 0) {
		    char *cp0;
d2875 6
a2880 12
		    if (isLYNXIMGMAP(HDOC(nhist_1).address))
			cp0 = HDOC(nhist_1).address + LEN_LYNXIMGMAP;
		    else
			cp0 = HDOC(nhist_1).address;
		    StrAllocCopy(temp, cp0);
		    (void) trimPoundSelector(temp);
		    StrAllocCat(temp, newdoc.address);
		    free_address(&newdoc);
		    newdoc.address = temp;
		    temp = NULL;
		}
		getresult = getfile(&newdoc, &Newline);
d2882 109
a2990 36
#else /* TRACK_INTERNAL_LINKS */
	    getresult = getfile(&newdoc, &Newline);
#endif /* TRACK_INTERNAL_LINKS */

#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;	/* for sure */
#endif

	    switch (getresult) {

	    case NOT_FOUND:
		/*
		 * OK!  can't find the file, so it must not be around now.  Do
		 * any error logging, if appropriate.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		if (!first_file && !LYCancelledFetch) {
		    /*
		     * Do error mail sending and/or traversal stuff.  Note that
		     * the links[] elements may not be valid at this point, if
		     * we did call HTuncache_current_document!  This should not
		     * have happened for traversal, but for sending error mail
		     * check that HTMainText exists for this reason.  - kw
		     */
		    if (error_logging && nhist > 0 && !popped_doc &&
			!LYUserSpecifiedURL &&
			HTMainText &&
			nlinks > 0 && curdoc.link < nlinks &&
			!isLYNXHIST(NonNull(newdoc.address)) &&
			!isLYNXCOOKIE(NonNull(newdoc.address))) {
			char *mail_owner = NULL;

			if (owner_address && isMAILTO_URL(owner_address)) {
			    mail_owner = owner_address + LEN_MAILTO_URL;
d2992 1
d2994 2
a2995 3
			 * Email a bad link message to the owner of the
			 * document, or to ALERTMAIL if defined, but NOT to
			 * lynx-dev (it is rejected in mailmsg).  - FM, kw
d2997 22
a3018 7
#ifndef ALERTMAIL
			if (mail_owner)
#endif
			    mailmsg(curdoc.link,
				    mail_owner,
				    HDOC(nhist_1).address,
				    HDOC(nhist_1).title);
d3020 22
a3041 8
		    if (traversal) {
			FILE *ofp;

			if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
			    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				perror(NOOPEN_TRAV_ERR_FILE);
				exit_immediately(EXIT_FAILURE);
			    }
d3043 23
a3065 13
			if (nhist > 0) {
			    fprintf(ofp,
				    "%s %s\tin %s\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target,
				    HDOC(nhist_1).address);
			} else {
			    fprintf(ofp,
				    "%s %s\t\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target);
a3066 1
			LYCloseOutput(ofp);
d3068 47
a3114 2
		}

d3116 5
a3120 2
		 * Fall through to do the NULL stuff and reload the old file,
		 * unless the first file wasn't found or has gone missing.
a3121 1
		if (!nhist) {
d3123 3
a3125 1
		     * If nhist = 0 then it must be the first file.
d3127 3
a3129 25
		    exit_immediately_with_error_message(NOT_FOUND, first_file);
		    return (EXIT_FAILURE);
		}
		/* FALLTHRU */

	    case NULLFILE:
		/*
		 * Not supposed to return any file.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		popped_doc = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		free_address(&newdoc);	/* to pop last doc */
		FREE(newdoc.bookmark);
		LYJumpFileURL = FALSE;
		reloading = FALSE;
		LYPermitURL = FALSE;
		LYCancelledFetch = FALSE;
		ForcePush = FALSE;
		LYforce_HTML_mode = FALSE;
		force_old_UCLYhndl_on_reload = FALSE;
		if (traversal) {
		    crawl_ok = FALSE;
		    if (traversal_link_to_add) {
d3131 4
a3134 3
			 * It's a binary file, or the fetch attempt failed. 
			 * Add it to TRAVERSE_REJECT_FILE so we don't try again
			 * in this run.
d3136 77
a3212 2
			if (!lookup_reject(traversal_link_to_add)) {
			    add_to_reject_list(traversal_link_to_add);
d3214 12
a3225 1
			FREE(traversal_link_to_add);
d3227 1
a3227 5
		}
		/*
		 * Make sure the first file was found and has not gone missing.
		 */
		if (!nhist) {
d3229 2
a3230 1
		     * If nhist = 0 then it must be the first file.
d3232 3
a3234 14
		    if (first_file && homepage &&
			!LYSameFilename(homepage, startfile)) {
			/*
			 * Couldn't return to the first file but there is a
			 * homepage we can use instead.  Useful for when the
			 * first URL causes a program to be invoked.  - GL
			 *
			 * But first make sure homepage is different from
			 * startfile (above), then make it the same (below) so
			 * we don't enter an infinite getfile() loop on on
			 * failures to find the files.  - FM
			 */
			set_address(&newdoc, homepage);
			LYFreePostData(&newdoc);
a3235 8
			StrAllocCopy(startfile, homepage);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
			newdoc.internal_link = FALSE;
			goto try_again;
		    } else {
			exit_immediately_with_error_message(NULLFILE, first_file);
			return (EXIT_FAILURE);
d3237 19
a3255 1
		}
d3257 14
a3270 52
		/*
		 * If we're going to pop from history because getfile didn't
		 * succeed, reset LYforce_no_cache first.  This would have been
		 * done in HTAccess.c if the request got that far, but the URL
		 * may have been handled or rejected in getfile without taking
		 * care of that.  - kw
		 */
		LYforce_no_cache = FALSE;
		/*
		 * Retrieval of a newdoc just failed, and just going to
		 * try_again would pop the next doc from history and try to get
		 * it without further questions.  This may not be the right
		 * thing to do if we have POST data, so fake a PREV_DOC key if
		 * it seems that some prompting should be done.  This doesn't
		 * affect the traversal logic, since with traversal POST data
		 * can never occur.  - kw
		 */
		if (HDOC(nhist - 1).post_data &&
		    !HDOC(nhist - 1).safe) {
		    if (HText_POSTReplyLoaded((DocInfo *) &history[(nhist_1)])) {
			override_LYresubmit_posts = TRUE;
			goto try_again;
		    }
		    /* Set newdoc fields, just in case the PREV_DOC gets
		     * cancelled.  - kw
		     */
		    if (!curdoc.address) {
			set_address(&newdoc, HTLoadedDocumentURL());
			StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			if (HTMainAnchor
			    && HTMainAnchor->post_data) {
			    BStrCopy(newdoc.post_data,
				     HTMainAnchor->post_data);
			    StrAllocCopy(newdoc.post_content_type,
					 HTMainAnchor->post_content_type);
			} else {
			    BStrFree(newdoc.post_data);
			}
			newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			newdoc.safe = HTLoadedDocumentIsSafe();
			newdoc.internal_link = FALSE;
		    } else {
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
a3271 2
		    cmd = LYK_PREV_DOC;
		    goto new_cmd;
d3273 2
a3274 2
		override_LYresubmit_posts = TRUE;
		goto try_again;
d3276 2
a3277 1
	    case NORMAL:
d3279 1
a3279 1
		 * Marvelously, we got the document!
d3281 11
a3291 4
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);

d3293 2
a3294 3
		 * If it's the first file and we're interactive, check whether
		 * it's a bookmark file which was not accessed via the -book
		 * switch.  - FM
d3296 3
a3298 84
		if (((first_file == TRUE) &&
		     (dump_output_immediately == FALSE) &&
		     isEmpty(newdoc.bookmark)) &&
		    ((LYisLocalFile(newdoc.address) == TRUE) &&
		     !(strcmp(NonNull(HText_getTitle()),
			      BOOKMARK_TITLE))) &&
		    (temp = HTParse(newdoc.address, "",
				    PARSE_PATH + PARSE_PUNCTUATION)) != NULL) {
		    const char *name = wwwName(Home_Dir());

		    len = strlen(name);
#ifdef VMS
		    if (!strncasecomp(temp, name, len) &&
			strlen(temp) > len)
#else
		    if (!strncmp(temp, name, len) &&
			strlen(temp) > len)
#endif /* VMS */
		    {
			/*
			 * We're interactive and this might be a bookmark file
			 * entered as a startfile rather than invoked via
			 * -book.  Check if it's in our bookmark file list, and
			 * if so, reload if with the relevant bookmark elements
			 * set.  - FM
			 */
			cp = NULL;
			if (temp[len] == '/') {
			    if (strchr(&temp[(len + 1)], '/')) {
				HTSprintf0(&cp, ".%s", &temp[len]);
			    } else {
				StrAllocCopy(cp, &temp[(len + 1)]);
			    }
			} else {
			    StrAllocCopy(cp, &temp[len]);
			}
			for (i = 0; i <= MBM_V_MAXFILES; i++) {
			    if (MBM_A_subbookmark[i] &&
				LYSameFilename(cp, MBM_A_subbookmark[i])) {
				StrAllocCopy(BookmarkPage,
					     MBM_A_subbookmark[i]);
				break;
			    }
			}
			FREE(cp);
			if (i <= MBM_V_MAXFILES) {
			    FREE(temp);
			    if (LYValidate) {
				HTAlert(BOOKMARKS_DISABLED);
				return (EXIT_FAILURE);
			    }
			    if ((temp = HTParse(newdoc.address, "",
						PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION))) {
				set_address(&newdoc, temp);
				HTuncache_current_document();
				free_address(&curdoc);
				StrAllocCat(newdoc.address,
					    wwwName(Home_Dir()));
				StrAllocCat(newdoc.address, "/");
				StrAllocCat(newdoc.address,
					    (strncmp(BookmarkPage, "./", 2) ?
					     BookmarkPage :
					     (BookmarkPage + 2)));
				StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				StrAllocCopy(newdoc.bookmark, BookmarkPage);
#ifdef USE_COLOR_STYLE
				if (curdoc.style)
				    StrAllocCopy(newdoc.style, curdoc.style);
#endif
				StrAllocCopy(startrealm, newdoc.address);
				LYFreePostData(&newdoc);
				newdoc.isHEAD = FALSE;
				newdoc.safe = FALSE;
				FREE(temp);
				if (!strcmp(homepage, startfile))
				    StrAllocCopy(homepage, newdoc.address);
				StrAllocCopy(startfile, newdoc.address);
				CTRACE((tfp, "Reloading as bookmarks=%s\n",
					newdoc.address));
				goto try_again;
			    }
			}
		    }
		    cp = NULL;
d3300 11
a3310 22
		FREE(temp);

		if (traversal) {
		    /*
		     * During traversal build up lists of all links traversed. 
		     * Traversal mode is a special feature for traversing http
		     * links in the web.
		     */
		    if (traversal_link_to_add) {
			/*
			 * Add the address we sought to TRAVERSE_FILE.
			 */
			if (!lookup_link(traversal_link_to_add))
			    add_to_table(traversal_link_to_add);
			FREE(traversal_link_to_add);
		    }
		    if (curdoc.address && curdoc.title &&
			!isLYNXIMGMAP(curdoc.address))
			/*
			 * Add the address we got to TRAVERSE_FOUND_FILE.
			 */
			add_to_traverse_list(curdoc.address, curdoc.title);
d3312 14
a3325 1

d3327 1
a3327 3
		 * If this was a LYNXDOWNLOAD, we still have curdoc, not a
		 * newdoc, so reset the address, title and positioning
		 * elements.  - FM
d3329 3
a3331 8
		if (newdoc.address && curdoc.address &&
		    isLYNXDOWNLOAD(newdoc.address)) {
		    copy_address(&newdoc, &curdoc);
		    StrAllocCopy(newdoc.title, NonNull(curdoc.title));
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    newdoc.internal_link = FALSE;	/* can't be true. - kw */
d3333 3
d3337 35
a3371 24
		/*
		 * Set Newline to the saved line.  It contains the line the
		 * user was on if s/he has been in the file before, or it is 1
		 * if this is a new file.
		 *
		 * We already set Newline before getfile() and probably update
		 * it explicitly if popping from the history stack via LYpop()
		 * or LYpop_num() within getfile() cycle.
		 *
		 * In partial mode, Newline was probably updated in
		 * LYMainLoop_pageDisplay() if user scrolled the document while
		 * loading.  Incremental loading stage already closed in
		 * HT*Copy().
		 */
#ifdef DISP_PARTIAL
		/* Newline = newdoc.line; */
		display_partial = FALSE;	/* for sure, LYNXfoo:/ may be a problem */
#else
		/* Should not be needed either if we remove "DISP_PARTIAL" from
		 * LYHistory.c, but lets leave it as an important comment for
		 * now.
		 */
		/* Newline = newdoc.line; */
#endif
d3373 2
d3376 1
a3376 2
		 * If we are going to a target line or the first page of a
		 * popped document, override any www_search line result.
d3378 16
a3393 3
		if (Newline > 1 || popped_doc == TRUE)
		    www_search_result = -1;

d3395 1
a3395 2
		 * Make sure curdoc.line will not be equal to Newline, so we
		 * get a redraw.
d3397 4
a3400 1
		curdoc.line = -1;
d3402 2
a3403 1
	    }			/* end switch */
d3405 8
a3412 5
	    if (TRACE) {
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();	/* allow me to look at the results */
		}
	    }
d3415 2
a3416 1
	     * Set the files the same.
d3418 2
a3419 11
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(curdoc.post_data, newdoc.post_data);
	    StrAllocCopy(curdoc.post_content_type, newdoc.post_content_type);
	    StrAllocCopy(curdoc.bookmark, newdoc.bookmark);
#ifdef USE_COLOR_STYLE
	    StrAllocCopy(curdoc.style, HText_getStyle());
	    if (curdoc.style != NULL)
		style_readFromFile(curdoc.style);
#endif
	    curdoc.isHEAD = newdoc.isHEAD;
	    curdoc.internal_link = newdoc.internal_link;
d3422 1
a3422 2
	     * Set the remaining document elements and add to the visited links
	     * list.  - FM
d3424 9
a3432 19
	    if (ownerS_address != NULL) {
#ifndef USE_PRETTYSRC
		if (HTOutputFormat == WWW_SOURCE && !HText_getOwner())
#else
		if ((LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
		    && !HText_getOwner())
#endif
		    HText_setMainTextOwner(ownerS_address);
		FREE(ownerS_address);
	    }
	    if (HText_getTitle()) {
		StrAllocCopy(curdoc.title, HText_getTitle());
	    } else if (!dump_output_immediately) {
		StrAllocCopy(curdoc.title, newdoc.title);
	    }
	    StrAllocCopy(owner_address, HText_getOwner());
	    curdoc.safe = HTLoadedDocumentIsSafe();
	    if (!dump_output_immediately) {
		LYAddVisitedLink(&curdoc);
a3433 1

d3435 2
a3436 2
	     * Reset WWW present mode so that if we were getting the source, we
	     * get rendered HTML from now on.
d3438 4
a3441 21
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;
#endif

	    HTMLSetCharacterHandling(current_char_set);		/* restore, for sure? */

	    /*
	     * Reset all of the other relevant flags.  - FM
	     */
	    LYUserSpecifiedURL = FALSE;		/* only set for goto's and jumps's */
	    LYJumpFileURL = FALSE;	/* only set for jump's */
	    LYNoRefererForThis = FALSE;		/* always reset on return here */
	    reloading = FALSE;	/* set for RELOAD and NOCACHE keys */
	    HEAD_request = FALSE;	/* only set for HEAD requests */
	    LYPermitURL = FALSE;	/* only for LYValidate or check_realm */
	    ForcePush = FALSE;	/* only set for some PRINT requests. */
	    LYforce_HTML_mode = FALSE;
	    force_old_UCLYhndl_on_reload = FALSE;
	    popped_doc = FALSE;
	    pending_form_c = -1;
d3443 7
a3449 7
	}
	/* end if (LYforce_no_cache || force_load || are_different(...)) */
	if (dump_output_immediately) {
	    if (crawl) {
		print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
	    } else if (!dump_links_only) {
		print_wwwfile_to_fd(stdout, FALSE, FALSE);
a3450 2
	    return (EXIT_SUCCESS);
	}
d3452 9
a3460 41
	/*
	 * If the recent_sizechange variable is set to TRUE then the window
	 * size changed recently.
	 */
	if (recent_sizechange) {
	    /*
	     * First we need to make sure the display library - curses, slang,
	     * whatever - gets notified about the change, and gets a chance to
	     * update external structures appropriately.  Hopefully the
	     * stop_curses()/start_curses() sequence achieves this, at least if
	     * the display library has a way to get the new screen size from
	     * the OS.
	     *
	     * However, at least for ncurses, the update of the internal
	     * structures will come still too late - the changed screen size is
	     * detected in doupdate(), which would only be called (indirectly
	     * through the HText_pageDisplay below) after the WINDOW structures
	     * are already filled based on the old size.  So we notify the
	     * ncurses library directly here.  - kw
	     */
#if defined(NCURSES) && defined(HAVE_RESIZETERM) && defined(HAVE_WRESIZE)
	    resizeterm(LYlines, LYcols);
	    wresize(LYwin, LYlines, LYcols);
#else
#if 0				/* defined(PDCURSES) && defined(HAVE_XCURSES) */
	    resize_term(LYlines, LYcols);
	    if (LYwin != 0)
		LYwin = resize_window(LYwin, LYlines, LYcols);
	    refresh();
#else
	    stop_curses();
	    start_curses();
	    LYclear();
#endif
#endif
	    refresh_screen = TRUE;	/* to force a redraw */
	    if (HTMainText)	/* to REALLY force it... - kw */
		HText_setStale(HTMainText);
	    recent_sizechange = FALSE;
	    if (user_mode == NOVICE_MODE) {
		display_lines = LYlines - 4;
d3462 3
a3464 1
		display_lines = LYlines - 2;
a3465 1
	}
a3466 1
	if (www_search_result != -1) {
d3468 1
a3468 1
	     * This was a WWW search, set the line to the result of the search.
d3470 12
a3481 9
	    Newline = www_search_result;
	    www_search_result = -1;	/* reset */
	}

	if (first_file == TRUE) {
	    /*
	     * We can never again have the first file.
	     */
	    first_file = FALSE;
d3483 1
d3485 1
a3485 2
	     * Set the startrealm, and deal as best we can with preserving
	     * forced HTML mode for a local startfile.  - FM
d3487 4
a3490 6
	    temp = HTParse(curdoc.address, "",
			   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
	    if (!temp || *temp == '\0') {
		StrAllocCopy(startrealm, NO_NOTHING);
	    } else {
		StrAllocCopy(startrealm, temp);
d3492 10
a3501 3
		if (!(temp = HTParse(curdoc.address, "",
				     PARSE_PATH + PARSE_PUNCTUATION))) {
		    LYAddHtmlSep(&startrealm);
d3503 25
a3527 5
		    if (forced_HTML_mode &&
			!dump_output_immediately &&
			!curdoc.bookmark &&
			isFILE_URL(curdoc.address) &&
			strlen(temp) > 1) {
d3529 2
a3530 10
			 * We forced HTML for a local startfile which is not a
			 * bookmark file and has a path of at least two
			 * letters.  If it doesn't have a suffix mapped to
			 * text/html, we'll set the entire path (including the
			 * lead slash) as a "suffix" mapped to text/html to
			 * ensure it is always treated as an HTML source file. 
			 * We are counting on a tail match to this full path
			 * for some other URL fetched during the session having
			 * too low a probability to worry about, but it could
			 * happen.  - FM
d3532 4
a3535 9
			HTAtom *encoding;

			if (HTFileFormat(temp, &encoding, NULL) != WWW_HTML) {
			    HTSetSuffix(temp, "text/html", "8bit", 1.0);
			}
		    }
		    if ((cp = strrchr(temp, '/')) != NULL) {
			*(cp + 1) = '\0';
			StrAllocCat(startrealm, temp);
d3537 1
d3539 12
a3550 11
	    }
	    FREE(temp);
	    CTRACE((tfp, "Starting realm is '%s'\n\n", startrealm));
	    if (traversal) {
		/*
		 * Set up the crawl output stuff.
		 */
		if (curdoc.address && !lookup_link(curdoc.address)) {
		    if (!isLYNXIMGMAP(curdoc.address))
			crawl_ok = TRUE;
		    add_to_table(curdoc.address);
d3552 14
a3565 13
		/*
		 * Set up the traversal_host comparison string.
		 */
		if (strncmp((curdoc.address ? curdoc.address : "NULL"),
			    "http", 4)) {
		    StrAllocCopy(traversal_host, NO_NOTHING);
		} else if (check_realm) {
		    StrAllocCopy(traversal_host, startrealm);
		} else {
		    temp = HTParse(curdoc.address, "",
				   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
		    if (!temp || *temp == '\0') {
			StrAllocCopy(traversal_host, NO_NOTHING);
d3567 13
a3579 2
			StrAllocCopy(traversal_host, temp);
			LYAddHtmlSep(&traversal_host);
d3581 12
a3592 1
		    FREE(temp);
d3594 1
a3594 1
		CTRACE((tfp, "Traversal host is '%s'\n\n", traversal_host));
d3596 110
a3705 1
	    if (startfile) {
d3707 2
a3708 2
		 * If homepage was not equated to startfile, make the homepage
		 * URL the first goto entry.  - FM
d3710 15
a3724 15
		if (homepage && strcmp(startfile, homepage))
		    HTAddGotoURL(homepage);
		/*
		 * If we are not starting up with startfile (e.g., had -book),
		 * or if we are using the startfile and it has no POST content,
		 * make the startfile URL a goto entry.  - FM
		 */
		if (strcmp(startfile, newdoc.address) ||
		    newdoc.post_data == NULL)
		    HTAddGotoURL(startfile);
	    }
	    if (TRACE) {
		refresh_screen = TRUE;
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();
d3726 2
d3729 4
a3732 14
	}
#ifdef USE_SOURCE_CACHE
	/*
	 * If the parse settings have changed since this HText was
	 * generated, we need to reparse and redraw it.  -dsb
	 *
	 * Should be configured to avoid shock for experienced lynx users.
	 * Currently enabled for cached sources only.
	 */
	if (HTdocument_settings_changed()) {
	    if (HTcan_reparse_document()) {
		HTInfoMsg(gettext("Reparsing document under current settings..."));
		reparse_document();
	    } else {
d3734 1
a3734 2
		 * Urk.  I have no idea how to recover from a failure here.
		 * At a guess, I'll try reloading.  -dsb
d3736 3
a3738 4
		/*  currently disabled ***
		   HTUserMsg(gettext("Reparsing document under current settings..."));
		   cmd = LYK_RELOAD;
		   goto new_cmd;
d3740 7
d3748 13
a3760 1
	}
d3762 12
a3773 5
	if (from_source_cache) {
	    from_source_cache = FALSE;	/* reset */
	    curdoc.line = -1;	/* so curdoc.line != Newline, see below */
	}
#endif
d3775 5
a3779 12
	/*
	 * If the curdoc.line is different than Newline then there must have
	 * been a change since last update.  Run HText_pageDisplay() create a
	 * fresh screen of text out.
	 *
	 * If we got new HTMainText go this way.  All display_partial calls
	 * ends here for final redraw.
	 */
	if (curdoc.line != Newline) {
#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;
#endif
d3781 22
a3802 3
	    refresh_screen = FALSE;

	    HText_pageDisplay(Newline, prev_target);
d3804 32
d3837 1
a3837 2
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
d3839 20
a3858 13

	    /*
	     * If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();
	    if (newdoc.link < 0)
		goto_line(Newline);
	    curdoc.line = Newline = HText_getTopOfScreen() + 1;

	    if (curdoc.title == NULL) {
		/*
		 * If we don't yet have a title, try to get it, or set to that
		 * for newdoc.title.  - FM
d3860 5
a3864 2
		if (HText_getTitle()) {
		    StrAllocCopy(curdoc.title, HText_getTitle());
d3866 54
a3919 1
		    StrAllocCopy(curdoc.title, newdoc.title);
d3922 20
a3941 1

d3943 1
a3943 2
	     * If the request is to highlight a link which is counted from the
	     * start of document, correct the link number:
d3945 19
a3963 5
	    if (newdoc_link_is_absolute) {
		newdoc_link_is_absolute = FALSE;
		if (curdoc.line > 1)
		    newdoc.link -= HText_LinksInLines(HTMainText, 1,
						      curdoc.line - 1);
d3965 2
d3968 2
a3969 1
	    if (arrowup) {
d3971 5
a3975 1
		 * arrowup is set if we just came up from a page below.
d3977 49
a4025 7
		curdoc.link = nlinks - 1;
		arrowup = FALSE;
	    } else {
		curdoc.link = newdoc.link;
		if (curdoc.link >= nlinks) {
		    curdoc.link = nlinks - 1;
		} else if (curdoc.link < 0 && nlinks > 0) {
d4027 1
a4027 6
		     * We may have popped a doc (possibly in local_dired) which
		     * didn't have any links when it was pushed, but does have
		     * links now (e.g., a file was created).  Code below
		     * assumes that curdoc.link is valid and that
		     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  -
		     * KW
d4029 8
a4036 1
		    curdoc.link = 0;
d4038 3
d4042 1
d4044 13
a4056 7
	    show_help = FALSE;	/* reset */
	    newdoc.line = 1;
	    newdoc.link = 0;
	    curdoc.line = Newline;	/* set */
	} else if (newdoc.link < 0) {
	    newdoc.link = 0;	/* ...just in case getfile set this */
	}
d4058 9
a4066 7
	/*
	 * Refresh the screen if necessary.
	 */
	if (refresh_screen) {
#if defined(FANCY_CURSES) || defined (USE_SLANG)
	    if (enable_scrollback) {
		LYclear();
d4068 11
a4078 1
		LYerase();
a4079 9
#else
	    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
	    HText_pageDisplay(Newline, prev_target);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
#endif /* DIRED_SUPPORT */
d4082 25
a4106 14
	     * If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();

	    /*
	     * Adjust curdoc.link as above; nlinks may have changed, if the
	     * refresh_screen flag was set as a result of a size change.  Code
	     * below assumes that curdoc.link is valid and that
	     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  - kw
	     */
	    if (curdoc.link >= nlinks) {
		curdoc.link = nlinks - 1;
	    } else if (curdoc.link < 0 && nlinks > 0) {
		curdoc.link = 0;
d4108 3
d4112 21
a4132 3
	    if (user_mode == NOVICE_MODE)
		noviceline(more);	/* print help message */
	    refresh_screen = FALSE;
d4134 55
a4188 1
	}
d4190 10
a4199 17
	curlink_is_editable =
	    (nlinks > 0 &&
	     links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     F_TEXTLIKE(links[curdoc.link].l_form->type));

	use_last_tfpos = (curlink_is_editable &&
			  (real_cmd == LYK_LPOS_PREV_LINK ||
			   real_cmd == LYK_LPOS_NEXT_LINK));

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (!textfields_need_activation)
	    textinput_activated = TRUE;
#endif

#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
	if (nlinks > 0) {
	    char *p = "LYNX (unknown link type)";
d4201 6
a4206 2
	    /* Show the URL & kanji code . */
	    if (strlen(links[curdoc.link].lname) == 0) {
d4208 7
a4214 30
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {

		    switch (links[curdoc.link].l_form->type) {
		    case F_TEXT_SUBMIT_TYPE:
		    case F_SUBMIT_TYPE:
		    case F_IMAGE_SUBMIT_TYPE:
			p = "[SUBMIT]";
			break;
		    case F_PASSWORD_TYPE:
			p = "Password";
			break;
		    case F_OPTION_LIST_TYPE:
			p = "Option list";
			break;
		    case F_CHECKBOX_TYPE:
			p = "Check box";
			break;
		    case F_RADIO_TYPE:
			p = "[Radio]";
			break;
		    case F_RESET_TYPE:
			p = "[Reset]";
			break;
		    case F_TEXT_TYPE:
			p = "Text input";
			break;
		    case F_TEXTAREA_TYPE:
			p = "Text input lines";
			break;
		    default:
d4216 26
a4242 1
		    set_ws_title(p);
d4244 8
a4251 5
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    p = curdoc.title;
		} else {
		    p = links[curdoc.link].lname;
d4253 2
d4256 20
a4275 7
		if (strlen(p) < 500) {
		    strcpy(temp_buff, p);
		    if (strchr(temp_buff, '%')) {
			HTUnEscape(temp_buff);
		    }
		    str_sjis(sjis_buff, temp_buff);
		    set_ws_title(LYElideString(sjis_buff, 10));
d4278 16
a4293 6
	} else {
	    if (strlen(curdoc.address) < sizeof(temp_buff) - 1) {
		if (user_mode == ADVANCED_MODE) {
		    str_sjis(temp_buff, curdoc.title);
		} else {
		    strcpy(temp_buff, curdoc.address);
a4294 1
		set_ws_title(HTUnEscape(temp_buff));
d4296 2
a4297 2
	}
#endif /* WIN_EX */
d4299 9
a4307 19
	/*
	 * Report unread or new mail, if appropriate.
	 */
	if (check_mail && !no_mail)
	    LYCheckMail();

	/*
	 * If help is not on the screen, then put a message on the screen to
	 * tell the user other misc info.
	 */
	if (!show_help) {
	    show_main_statusline(links[curdoc.link],
				 (curlink_is_editable && textinput_activated) ?
				 FOR_INPUT : FOR_PANEL);
	} else {
	    show_help = FALSE;
	}

	if (nlinks > 0) {
d4309 8
a4316 8
	     * Highlight current link, unless it is an active text input field.
	     */
	    if (!curlink_is_editable) {
		LYhighlight(ON, curdoc.link, prev_target);
#ifndef INACTIVE_INPUT_STYLE_VH
	    } else if (!textinput_activated) {
		LYhighlight(ON, curdoc.link, prev_target);
#endif
a4317 1
	}
a4318 1
	if (traversal) {
d4320 14
a4333 31
	     * Don't go interactively into forms, or accept keystrokes from the
	     * user
	     */
	    if (crawl && crawl_ok) {
		crawl_ok = FALSE;
#ifdef FNAMES_8_3
		sprintf(cfile, "lnk%05d.dat", crawl_count);
#else
		sprintf(cfile, "lnk%08d.dat", crawl_count);
#endif /* FNAMES_8_3 */
		crawl_count = crawl_count + 1;
		if ((cfp = LYNewTxtFile(cfile)) != NULL) {
		    print_crawl_to_fd(cfp, curdoc.address, curdoc.title);
		    LYCloseOutput(cfp);
		} else {
		    if (!dump_output_immediately)
			cleanup();
		    fprintf(
#ifdef UNIX
			       (dump_output_immediately
				? stderr
				: stdout),
#else
			       stdout,
#endif
			       gettext("Fatal error - could not open output file %s\n"), cfile);
		    if (!dump_output_immediately) {
			exit_immediately(EXIT_FAILURE);
		    }
		    return (EXIT_FAILURE);
		}
d4335 3
a4337 1
	} else {
d4339 2
a4340 1
	     * Normal, non-traversal handling.
d4342 8
a4349 23
	    if (curlink_is_editable &&
		(textinput_activated || pending_form_c != -1)) {
		if (pending_form_c != -1) {
		    real_c = pending_form_c;
		    pending_form_c = -1;
		} else {
		    /*
		     * Replace novice lines if in NOVICE_MODE.
		     */
		    if (user_mode == NOVICE_MODE) {
			form_noviceline(links[curdoc.link].l_form->disabled);
		    }
		    real_c = change_form_link(curdoc.link,
					      &newdoc, &refresh_screen,
					      use_last_tfpos, FALSE);
		}
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation)
		    textinput_activated = FALSE;
#ifdef INACTIVE_INPUT_STYLE_VH
		textinput_redrawn = FALSE;
#endif
#endif
d4351 24
a4374 102
		c = (real_c == LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
		if (c != DO_NOTHING &&
		    peek_mouse_link() != -1 && peek_mouse_link() != -2)
		    old_c = 0;
		if (peek_mouse_link() >= 0 &&
		    LKC_TO_LAC(keymap, real_c) != LYK_CHANGE_LINK) {
		    do_change_link();
		    if ((c == '\n' || c == '\r') &&
			links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
			!textfields_need_activation) {
			c = DO_NOTHING;
		    }
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		} else if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
			   && textfields_need_activation
			   && !links[curdoc.link].l_form->disabled
			   && peek_mouse_link() < 0 &&
			   (((LKC_TO_LAC(keymap, real_c) == LYK_NEXT_LINK ||
#ifdef TEXTAREA_AUTOGROW
			      LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE ||
#endif
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks - 1 &&
			       links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link + 1].l_form->number)
			       && strcmp(links[curdoc.link].l_form->name,
					 links[curdoc.link + 1].l_form->name)
			       == 0) ||
			      (curdoc.link == nlinks - 1 && more &&
			       HText_TAHasMoreLines(curdoc.link, 1)))) ||
			    ((LKC_TO_LAC(keymap, real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_UP_LINK) &&
			     ((curdoc.link > 0 &&
			       links[curdoc.link - 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link - 1].l_form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link - 1].l_form->number) &&
			       strcmp(links[curdoc.link].l_form->name,
				      links[curdoc.link - 1].l_form->name) == 0)
			      || (curdoc.link == 0 && curdoc.line > 1 &&
				  HText_TAHasMoreLines(curdoc.link, -1)))))) {
		    textinput_activated = TRUE;
#ifdef TEXTAREA_AUTOGROW
		    if ((c == '\n' || c == '\r') &&
			LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE)
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
#endif /* TEXTAREA_AUTOGROW */
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION */
		} else
		    switch (c) {
		    case '\n':
		    case '\r':
#ifdef TEXTAREA_AUTOGROW
			/*
			 * If on the bottom line of a TEXTAREA, and the user
			 * hit the ENTER key, we add a new line/anchor
			 * automatically, positioning the cursor on it.
			 *
			 * If at the bottom of the screen, we effectively
			 * perform an LYK_DOWN_HALF-like operation, then move
			 * down to the new line we just added.  --KED 02/14/99
			 *
			 * [There is some redundancy and non-standard
			 * indentation in the monster-if() below.  This is
			 * intentional ...  to try and improve the
			 * "readability" (such as it is).  Caveat emptor to
			 * anyone trying to change it.]
			 */
			if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
			    && ((curdoc.link == nlinks - 1 &&
				 !(more && HText_TAHasMoreLines(curdoc.link, 1)))
				||
				((curdoc.link < nlinks - 1) &&
				 !(links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE))
				||
				((curdoc.link < nlinks - 1) &&
				 ((links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE)
				  && ((links[curdoc.link].l_form->number !=
				       links[curdoc.link + 1].l_form->number) ||
				      (strcmp(links[curdoc.link].l_form->name,
					      links[curdoc.link + 1].l_form->name)
				       != 0)))))) {

			    HText_ExpandTextarea(&links[curdoc.link], 1);

			    if (links[curdoc.link].ly < display_lines) {
				refresh_screen = TRUE;

			    } else {

				Newline += (display_lines / 2);
				if (nlinks > 0 && curdoc.link > -1 &&
				    links[curdoc.link].ly > display_lines / 2) {
d4376 2
a4377 5
				    for (i = 0;
					 links[i].ly <= (display_lines / 2);
					 i++)
					--newdoc.link;
				    newdoc.link++;
a4379 10
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			    if (textfields_need_activation) {
				textinput_activated = TRUE;
				textfields_need_activation = textfields_activation_option;
#ifdef INACTIVE_INPUT_STYLE_VH
				textinput_redrawn = TRUE;
#endif
			    };
#endif

d4381 1
a4381 29
#endif /* TEXTAREA_AUTOGROW */

			/*
			 * Make return in input field (if it was returned by
			 * change_form_link) act as LYK_NEXT_LINK, independent
			 * of what key (if any) is mapped to LYK_NEXT_LINK.  -
			 * kw
			 */
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
			break;
		    default:

			if (old_c != c && old_c != real_c && c != real_c)
			    real_c = c;
		    }
	    } else {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
		if (curlink_is_editable && !textinput_redrawn) {
		    /*draw the text entry, but don't activate it */
		    textinput_redrawn = TRUE;
		    change_form_link_ex(curdoc.link,
					&newdoc, &refresh_screen,
					use_last_tfpos, FALSE, TRUE);
		    if (LYShowCursor) {
			LYmove(links[curdoc.link].ly,
			       ((links[curdoc.link].lx > 0) ?
				(links[curdoc.link].lx - 1) : 0));
		    } else {
			LYHideCursor();
d4384 8
a4391 13
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
		/*
		 * Get a keystroke from the user.  Save the last keystroke to
		 * avoid redundant error reporting.
		 */
		real_c = c = LYgetch();		/* get user input */

		if (c != last_key)
		    key_count = 0;
		key_count++;
		last_key = c;
#ifndef VMS
		if (c == 3) {	/* ^C */
d4393 1
a4393 2
		     * This shouldn't happen.  We'll try to deal with whatever
		     * bug caused it.  - FM
d4395 3
a4397 7
		    signal(SIGINT, cleanup_sig);
		    old_c = 0;
		    cmd = LYK_QUIT;
		    goto new_cmd;
		}
#endif /* !VMS */
		if (LKC_HAS_ESC_MOD(c) && EditBinding(c) != LYE_FORM_PASS) {
d4399 1
a4399 8
		     * If ESC + <key> was read (and not recognized as a
		     * terminal escape sequence for another key), ignore the
		     * ESC modifier and act on <key> only if the line editor
		     * binding would have passed the same ESC-modified
		     * lynxkeycode back to us if it had been pressed in a text
		     * input field.  Otherwise set interesting part so that it
		     * will map to 0, to prevent that ESC + <key> acts like
		     * <key>, which might be unexpected.  - kw
d4401 4
a4404 1
		    c = (c & ~LKC_MASK) | LAC_TO_LKC(0);
d4406 2
d4409 2
a4410 1
		    old_c = 0;
a4412 53
	}

#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = DO_NOTHING;
	}
#else
	if (recent_sizechange) {
	    if (c <= 0)
		c = DO_NOTHING;
	}
#endif /* VMS */

      new_keyboard_input:
	/*
	 * A goto point for new input without going back through the getch()
	 * loop.
	 */
	if (traversal) {
	    if ((c = DoTraversal(c, &crawl_ok)) < 0)
		return (EXIT_FAILURE);
	}
	/* traversal */
#ifdef WIN_EX
	if (c == DO_NOTHING)
	    cmd = LYK_DO_NOTHING;
	else
#endif
	    cmd = LKC_TO_LAC(keymap, c);	/* adds 1 to map EOF to 0 */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override, c))
	    cmd = LKC_TO_LAC(key_override, c);
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

	real_cmd = cmd;

	/*
	 * A goto point for new input without going back through the getch()
	 * loop.
	 */
      new_cmd:

	force_old_UCLYhndl_on_reload = FALSE;
	CTRACE_FLUSH(tfp);

	if (cmd != LYK_UP_LINK && cmd != LYK_DOWN_LINK)
	    follow_col = -1;

	switch (cmd) {
	case -1:
	    HTUserMsg(COMMAND_UNKNOWN);
a4413 5
	case 0:		/* unmapped character */
	default:
	    if (curdoc.link >= 0 && curdoc.link < nlinks &&
		links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {
d4415 21
a4435 13
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation) {
		    show_main_statusline(links[curdoc.link], FOR_PANEL);
#ifdef INACTIVE_INPUT_STYLE_VH
		    textinput_redrawn = FALSE;
#endif
		} else
#endif
		    show_main_statusline(links[curdoc.link], FOR_INPUT);
	    } else if (more) {
		HTInfoMsg(MOREHELP);
	    } else {
		HTInfoMsg(HELP);
d4437 13
a4449 6
	    show_help = TRUE;

	    if (TRACE) {
		sprintf(cfile, "%d", c);
		LYaddstr(cfile);	/* show the user input */
		cfile[0] = '\0';
d4453 6
a4458 3
	case LYK_COMMAND:
	    cmd = handle_LYK_COMMAND(user_input_buffer);
	    goto new_cmd;
d4460 1
a4460 1
	case LYK_INTERRUPT:
d4462 1
a4462 1
	     * No network transmission to interrupt - 'til we multithread.
d4464 22
d4488 8
a4495 15
	case LYK_F_LINK_NUM:
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
	case LYK_9:
	    handle_LYK_digit(c, &force_load, user_input_buffer,
			     &old_c, real_c, &try_internal);
	    break;
d4497 5
a4501 3
	case LYK_SOURCE:	/* toggle view source mode */
	    handle_LYK_SOURCE(&ownerS_address);
	    break;
d4503 2
a4504 1
	case LYK_CHG_CENTER:	/* ^Q */
d4506 1
a4506 8
	    if (no_table_center) {
		no_table_center = FALSE;
		HTInfoMsg(gettext("TABLE center enable."));
	    } else {
		no_table_center = TRUE;
		HTInfoMsg(gettext("TABLE center disable."));
	    }
	    /* FALLTHRU */
d4508 8
a4515 3
	case LYK_RELOAD:	/* control-R to reload and refresh */
	    handle_LYK_RELOAD(real_cmd);
	    break;
d4517 2
a4518 3
	case LYK_HISTORICAL:	/* toggle 'historical' comments parsing */
	    handle_LYK_HISTORICAL();
	    break;
d4520 3
a4522 3
	case LYK_MINIMAL:	/* toggle 'minimal' comments parsing */
	    handle_LYK_MINIMAL();
	    break;
d4524 1
a4524 3
	case LYK_SOFT_DQUOTES:
	    handle_LYK_SOFT_DQUOTES();
	    break;
d4526 2
a4527 2
	case LYK_SWITCH_DTD:
	    handle_LYK_SWITCH_DTD();
d4530 6
a4535 4
	case LYK_QUIT:		/* quit */
	    if (handle_LYK_QUIT())
		return (EXIT_SUCCESS);
	    break;
d4537 1
a4537 2
	case LYK_ABORT:	/* don't ask the user about quitting */
	    return (EXIT_SUCCESS);
d4539 1
a4539 3
	case LYK_NEXT_PAGE:	/* next page */
	    handle_LYK_NEXT_PAGE(&old_c, real_c);
	    break;
d4541 1
a4541 3
	case LYK_PREV_PAGE:	/* page up */
	    handle_LYK_PREV_PAGE(&old_c, real_c);
	    break;
d4543 2
a4544 2
	case LYK_UP_TWO:
	    handle_LYK_UP_TWO(&arrowup, &old_c, real_c);
d4547 6
a4552 3
	case LYK_DOWN_TWO:
	    handle_LYK_DOWN_TWO(&old_c, real_c);
	    break;
d4554 1
a4554 3
	case LYK_UP_HALF:
	    handle_LYK_UP_HALF(&arrowup, &old_c, real_c);
	    break;
d4556 12
a4567 3
	case LYK_DOWN_HALF:
	    handle_LYK_DOWN_HALF(&old_c, real_c);
	    break;
d4569 1
a4569 30
#ifdef CAN_CUT_AND_PASTE
	case LYK_TO_CLIPBOARD:	/* ^S */
	    {
		char *s;
		int ch2;

		/* The logic resembles one of ADD_BOOKMARK */
		if (nlinks > 0 && links[curdoc.link].lname
		    && links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    /* Makes sense to copy a link */
		    _statusline("Copy D)ocument's or L)ink's URL to clipboard or C)ancel?");
		    ch2 = LYgetch_single();
		    if (ch2 == 'D')
			s = curdoc.address;
		    else if (ch2 == 'C')
			break;
		    else
			s = links[curdoc.link].lname;
		} else
		    s = curdoc.address;
		if (isEmpty(s))
		    HTInfoMsg(gettext("Current URL is empty."));
		if (put_clip(s))
		    HTInfoMsg(gettext("Copy to clipboard failed."));
		else if (s == curdoc.address)
		    HTInfoMsg(gettext("Document URL put to clipboard."));
		else
		    HTInfoMsg(gettext("Link URL put to clipboard."));
	    }
	    break;
a4570 3
	case LYK_PASTE_URL:
	    if (no_goto && !LYValidate) {	/*  Go to not allowed. - FM */
		HTUserMsg(GOTO_DISALLOWED);
a4571 3
		unsigned char *s = (unsigned char *) get_clip_grab(), *e, *t;
		char *buf;
		int len2;
d4573 1
a4573 50
		if (!s)
		    break;
		len2 = strlen((const char *) s);
		e = s + len2;
		while (s < e && strchr(" \t\n\r", *s))
		    s++;
		while (s < e && strchr(" \t\n\r", e[-1]))
		    e--;
		if (s[0] == '<' && e > s && e[-1] == '>') {
		    s++;
		    e--;
		    if (!strncasecomp((const char *) s, "URL:", 4))
			s += 4;
		}
		if (s >= e) {
		    HTInfoMsg(gettext("No URL in the clipboard."));
		    break;
		}
		len = e - s + 1;
		if (len < MAX_LINE)
		    len = MAX_LINE;	/* Required for do_check_goto_URL() */
		buf = (char *) malloc(len);
		strncpy(buf, (const char *) s, e - s);
		buf[e - s] = '\0';
		t = (unsigned char *) buf;

		while (s < e) {
		    if (strchr(" \t\n\r", *s)) {
			int nl2 = 0;	/* Keep whitespace without NL - file names! */
			unsigned char *s1 = s;

			while (strchr(" \t\n\r", *s)) {
			    if (!nl2 && *s == '\n')
				nl2 = 1;
			    s++;
			}
			if (!nl2) {
			    while (s1 < s) {
				if (*s1 != '\r' && *s1 != '\r')
				    *t = *s1;
				t++, s1++;
			    }
			}
		    } else
			*t++ = *s++;
		}
		*t = '\0';
		get_clip_release();
		do_check_goto_URL(buf, &temp, &force_load);
		free(buf);
a4575 1
#endif
d4577 5
a4581 15
#ifdef KANJI_CODE_OVERRIDE
	case LYK_CHG_KCODE:	/* ^L */
	    if (LYRawMode && (HTCJK == JAPANESE)) {
		switch (last_kcode) {
		case NOKANJI:
		    last_kcode = SJIS;
		    break;
		case SJIS:
		    last_kcode = EUC;
		    break;
		case EUC:
		    last_kcode = NOKANJI;
		    break;
		default:
		    break;
d4583 1
a4584 4
	    LYmove(0, 0);
	    lynx_start_title_color();
	    LYaddstr(str_kcode(last_kcode));
	    lynx_stop_title_color();
d4586 5
a4590 2
	    break;
#endif
d4592 13
a4604 11
	case LYK_REFRESH:
	    refresh_screen = TRUE;
	    lynx_force_repaint();
	    break;

	case LYK_HOME:
	    if (curdoc.line > 1)
		Newline = 1;
	    else {
		cmd = LYK_PREV_PAGE;
		goto new_cmd;
d4608 10
a4617 7
	case LYK_END:
	    i = HText_getNumOfLines() - display_lines + 2;
	    if (i >= 1 && Newline != i) {
		Newline = i;	/* go to end of file */
		arrowup = TRUE;	/* position on last link */
	    } else {
		cmd = LYK_NEXT_PAGE;
a4619 1
	    break;
d4621 12
a4632 3
	case LYK_FIRST_LINK:
	    handle_LYK_FIRST_LINK();
	    break;
d4634 5
a4638 2
	case LYK_LAST_LINK:
	    handle_LYK_LAST_LINK();
d4641 11
a4651 16
	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	    handle_LYK_PREV_LINK(&arrowup, &old_c, real_c);
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	    handle_LYK_NEXT_LINK(c, &old_c, real_c);
	    break;

	case LYK_FASTFORW_LINK:
	    handle_LYK_FASTFORW_LINK(&old_c, real_c);
	    break;

	case LYK_FASTBACKW_LINK:
	    if (handle_LYK_FASTBACKW_LINK(&cmd, &old_c, real_c))
d4653 1
a4653 1
	    break;
d4655 12
a4666 3
	case LYK_UP_LINK:
	    handle_LYK_UP_LINK(&follow_col, &arrowup, &old_c, real_c);
	    break;
d4668 5
a4672 2
	case LYK_DOWN_LINK:
	    handle_LYK_DOWN_LINK(&follow_col, &old_c, real_c);
d4674 1
d4676 7
a4682 18
	case LYK_CHANGE_LINK:
	    do_change_link();
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	    if (textfields_need_activation)
		textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    break;

	case LYK_RIGHT_LINK:
	    handle_LYK_RIGHT_LINK();
	    break;

	case LYK_LEFT_LINK:
	    handle_LYK_LEFT_LINK();
	    break;

	case LYK_COOKIE_JAR:	/* show the cookie jar */
	    if (handle_LYK_COOKIE_JAR(&cmd))
d4684 1
a4684 1
	    break;
d4686 5
a4690 2
	case LYK_HISTORY:	/* show the history page */
	    if (handle_LYK_HISTORY(ForcePush))
d4692 12
a4703 8

	    /* FALLTHRU */
	case LYK_PREV_DOC:	/* back up a level */
	    switch (handle_PREV_DOC(&cmd, &old_c, real_c)) {
	    case 1:
		return (EXIT_SUCCESS);
	    case 2:
		goto new_cmd;
d4707 23
a4729 2
	case LYK_NEXT_DOC:	/* undo back up a level */
	    handle_NEXT_DOC();
d4732 21
a4752 19
	case LYK_NOCACHE:	/* Force submission of form or link with no-cache */
	    if (!handle_LYK_NOCACHE(&old_c, real_c))
		break;

	    /* FALLTHRU */
	case LYK_ACTIVATE:	/* follow a link */
	case LYK_SUBMIT:	/* follow a link, submit TEXT_SUBMIT input */
	    switch (handle_LYK_ACTIVATE(&c,
					cmd,
					&try_internal,
					&refresh_screen,
					&force_load,
					real_cmd)) {
	    case 1:
		continue;
	    case 2:
		goto new_keyboard_input;
	    case 3:
		pending_form_c = c;
a4754 1
	    break;
d4756 30
a4785 4
	case LYK_ELGOTO:	/* edit URL of current link and go to it  */
	    if (handle_LYK_ELGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    break;
d4787 62
a4848 3
	case LYK_ECGOTO:	/* edit current URL and go to to it     */
	    if (handle_LYK_ECGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
d4850 10
a4859 8

	case LYK_GOTO:		/* 'g' to goto a random URL  */
	    if (handle_LYK_GOTO(&ch, user_input_buffer, &temp, &recall,
				&URLTotal, &URLNum, &FirstURLRecall, &old_c,
				real_c)) {
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
d4862 2
d4865 7
a4871 6
	case LYK_DWIMHELP:	/* show context-dependent help file */
	    handle_LYK_DWIMHELP(&cshelpfile);
	    /* FALLTHRU */

	case LYK_HELP:		/* show help file */
	    handle_LYK_HELP(&cshelpfile);
d4873 1
d4875 8
a4882 32
	case LYK_INDEX:	/* index file */
	    handle_LYK_INDEX(&old_c, real_c);
	    break;

	case LYK_MAIN_MENU:	/* return to main screen */
	    handle_LYK_MAIN_MENU(&old_c, real_c);
	    break;

#ifdef EXP_NESTED_TABLES
	case LYK_NESTED_TABLES:
	    if (handle_LYK_NESTED_TABLES(&cmd))
		goto new_cmd;
	    break;
#endif
	case LYK_OPTIONS:	/* options screen */
	    if (handle_LYK_OPTIONS(&cmd, &refresh_screen))
		goto new_cmd;
	    break;

	case LYK_INDEX_SEARCH:	/* search for a user string */
	    handle_LYK_INDEX_SEARCH(&force_load, ForcePush, &old_c, real_c);
	    break;

	case LYK_WHEREIS:	/* search within the document */
	case LYK_NEXT:		/* find the next occurrence in the document */
	case LYK_PREV:		/* find the previous occurrence in the document */
	    handle_LYK_WHEREIS(cmd, &refresh_screen);
	    break;

	case LYK_COMMENT:	/* reply by mail */
	    handle_LYK_COMMENT(&refresh_screen, &owner_address, &old_c, real_c);
	    break;
d4884 6
d4891 147
a5037 2
	case LYK_TAG_LINK:	/* tag or untag the current link */
	    handle_LYK_TAG_LINK();
d5040 8
a5047 3
	case LYK_MODIFY:	/* rename a file or directory */
	    handle_LYK_MODIFY(&refresh_screen);
	    break;
d5049 29
a5077 2
	case LYK_CREATE:	/* create a new file or directory */
	    handle_LYK_CREATE();
a5078 1
#endif /* DIRED_SUPPORT */
d5080 12
a5091 6
	case LYK_DWIMEDIT:	/* context-dependent edit */
	    switch (handle_LYK_DWIMEDIT(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
a5092 4
	    /* FALLTHRU */

	case LYK_EDIT:		/* edit */
	    handle_LYK_EDIT(&old_c, real_c);
d5095 12
a5106 3
	case LYK_DEL_BOOKMARK:	/* remove a bookmark file link */
	    handle_LYK_DEL_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;
d5108 6
a5113 5
#ifdef DIRED_SUPPORT
	case LYK_REMOVE:	/* remove files and directories */
	    handle_LYK_REMOVE(&refresh_screen);
	    break;
#endif /* DIRED_SUPPORT */
d5115 29
a5143 5
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
	case LYK_INSTALL:	/* install a file into system area */
	    handle_LYK_INSTALL();
	    break;
#endif /* DIRED_SUPPORT && OK_INSTALL */
d5145 6
a5150 4
	case LYK_INFO:		/* show document info */
	    if (handle_LYK_INFO(&cmd))
		goto new_cmd;
	    break;
d5152 6
a5157 3
	case LYK_EDIT_TEXTAREA:	/* use external editor on a TEXTAREA - KED */
	    handle_LYK_EDIT_TEXTAREA(&refresh_screen, &old_c, real_c);
	    break;
d5159 8
a5166 3
	case LYK_GROW_TEXTAREA:	/* add new lines to bottom of TEXTAREA - KED */
	    handle_LYK_GROW_TEXTAREA(&refresh_screen);
	    break;
d5168 7
a5174 3
	case LYK_INSERT_FILE:	/* insert file in TEXTAREA, above cursor - KED */
	    handle_LYK_INSERT_FILE(&refresh_screen, &old_c, real_c);
	    break;
d5176 13
a5188 3
	case LYK_PRINT:	/* print the file */
	    handle_LYK_PRINT(&ForcePush, &old_c, real_c);
	    break;
d5190 34
a5223 4
	case LYK_LIST:		/* list links in the current document */
	    if (handle_LYK_LIST(&cmd))
		goto new_cmd;
	    break;
d5225 5
a5229 6
#ifdef EXP_ADDRLIST_PAGE
	case LYK_ADDRLIST:	/* always list URL's (only) */
	    if (handle_LYK_ADDRLIST(&cmd))
		goto new_cmd;
	    break;
#endif /* EXP_ADDRLIST_PAGE */
d5231 23
a5253 4
	case LYK_VLINKS:	/* list links visited during the current session */
	    if (handle_LYK_VLINKS(&cmd, &newdoc_link_is_absolute))
		goto new_cmd;
	    break;
d5255 53
a5307 2
	case LYK_TOOLBAR:	/* go to Toolbar or Banner in current document */
	    handle_LYK_TOOLBAR(&try_internal, &force_load, &old_c, real_c);
d5310 9
a5318 5
#if defined(DIRED_SUPPORT) || defined(VMS)
	case LYK_DIRED_MENU:	/* provide full file management menu */
	    handle_LYK_DIRED_MENU(&refresh_screen, &old_c, real_c);
	    break;
#endif /* DIRED_SUPPORT || VMS */
d5320 17
a5336 3
#ifdef USE_EXTERNALS
	case LYK_EXTERN_LINK:	/* use external program on url */
	    handle_LYK_EXTERN_LINK(&refresh_screen);
d5338 1
a5338 4
	case LYK_EXTERN_PAGE:	/* use external program on current page */
	    handle_LYK_EXTERN_PAGE(&refresh_screen);
	    break;
#endif /* USE_EXTERNALS */
d5340 4
a5343 2
	case LYK_ADD_BOOKMARK:	/* add link to bookmark file */
	    handle_LYK_ADD_BOOKMARK(&refresh_screen, &old_c, real_c);
d5346 8
a5353 14
	case LYK_VIEW_BOOKMARK:	/* v to view home page */
	    handle_LYK_VIEW_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_SHELL:	/* (!) shell escape */
	    handle_LYK_SHELL(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_DOWNLOAD:
	    switch (handle_LYK_DOWNLOAD(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
a5354 1
	    break;
d5356 6
a5361 5
#ifdef DIRED_SUPPORT
	case LYK_UPLOAD:
	    handle_LYK_UPLOAD();
	    break;
#endif /* DIRED_SUPPORT */
d5363 13
a5375 3
	case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	    handle_LYK_TRACE_TOGGLE();
	    break;
d5377 12
a5388 2
	case LYK_TRACE_LOG:	/*  View TRACE log. */
	    handle_LYK_TRACE_LOG(&trace_mode_flag);
d5392 14
a5405 3
	    if (handle_LYK_IMAGE_TOGGLE(&cmd))
		goto new_cmd;
	    break;
d5408 14
a5421 3
	    if (handle_LYK_INLINE_TOGGLE(&cmd))
		goto new_cmd;
	    break;
d5424 13
a5436 1
	    if (handle_LYK_RAW_TOGGLE(&cmd))
d5438 1
a5438 1
	    break;
d5441 122
a5562 2
	    if (handle_LYK_HEAD(&cmd))
		goto new_cmd;
d5566 4
a5569 1
	    handle_LYK_TOGGLE_HELP();
d5573 31
a5603 1
	    handle_LYK_KEYMAP(&vi_keys_flag, &emacs_keys_flag, &old_c, real_c);
d5607 56
a5662 6
	    if (handle_LYK_JUMP(c, user_input_buffer, &temp, &recall,
				&FirstURLRecall, &URLNum, &URLTotal, &ch,
				&old_c, real_c)) {
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
d5667 19
a5685 1
	    handle_LYK_CLEAR_AUTH(&old_c, real_c);
d5690 82
a5771 18
#ifdef SUPPORT_CHDIR
	case LYK_CHDIR:
	    handle_LYK_CHDIR();
	    break;
#endif
#ifdef USE_CURSES_PADS
	case LYK_SHIFT_LEFT:
	    handle_LYK_SHIFT_LEFT(&refresh_screen, key_count);
	    break;
	case LYK_SHIFT_RIGHT:
	    handle_LYK_SHIFT_RIGHT(&refresh_screen, key_count);
	    break;
	case LYK_LINEWRAP_TOGGLE:
	    if (handle_LYK_LINEWRAP_TOGGLE(&cmd, &refresh_screen))
		goto new_cmd;
	    break;
#endif
	}			/* end of BIG switch */
d5773 2
d5777 3
a5779 1
static int are_different(DocInfo *doc1, DocInfo *doc2)
d5784 1
a5784 1
     * Do we have two addresses?
d5790 1
a5790 1
     * Do they differ in the type of request?
d5796 40
a5835 27
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
     */
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
    /*
     * Are the base addresses different?
     */
    if (strcmp(doc1->address, doc2->address)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
	return (TRUE);
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);

    /*
     * Do the docs have different contents?
     */
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
		return (TRUE);
	} else
	    return (TRUE);
    } else if (doc2->post_data)
	return (TRUE);
d5838 1
a5838 1
     * We'll assume the two documents in fact are the same.
d5840 1
a5840 1
    return (FALSE);
d5847 3
a5849 1
static int are_phys_different(DocInfo *doc1, DocInfo *doc2)
d5854 1
a5854 1
     * Do we have two addresses?
d5860 1
a5860 1
     * Do they differ in the type of request?
d5868 4
a5871 4
    if (isLYNXIMGMAP(doc1->address))
	ap1 += LEN_LYNXIMGMAP;
    if (isLYNXIMGMAP(doc2->address))
	ap2 += LEN_LYNXIMGMAP;
d5878 1
a5878 1
	return (FALSE);
d5881 40
a5920 27
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
     */
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
    /*
     * Are the base addresses different?
     */
    if (strcmp(ap1, ap2)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
	return (TRUE);
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);

    /*
     * Do the docs have different contents?
     */
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
		return (TRUE);
	} else
	    return (TRUE);
    } else if (doc2->post_data)
	return (TRUE);
d5923 1
a5923 1
     * We'll assume the two documents in fact are the same.
d5925 1
a5925 1
    return (FALSE);
d5930 1
a5930 1
 * Utility for freeing the list of goto URLs.  - FM
d5932 1
a5932 2
#ifdef LY_FIND_LEAKS
static void HTGotoURLs_free(void)
d5934 10
a5943 1
    LYFreeStringList(Goto_URLs);
d5945 1
a5946 1
#endif
d5949 2
a5950 2
 * Utility for listing Goto URLs, making any repeated URLs the most current in
 * the list.  - FM
d5952 2
a5953 1
void HTAddGotoURL(char *url)
d5955 1
a5955 1
    char *copy = NULL;
d5959 1
a5959 1
    if (isEmpty(url))
d5962 3
a5964 2
    CTRACE((tfp, "HTAddGotoURL %s\n", url));
    StrAllocCopy(copy, url);
d5971 1
a5971 1
	HTList_addObject(Goto_URLs, copy);
d5976 2
a5977 2
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, copy)) {
d5983 1
a5983 1
    HTList_addObject(Goto_URLs, copy);
d5989 3
a5991 2
 * When help is not on the screen, put a message on the screen to tell the user
 * other misc info.
d5993 3
a5995 2
static void show_main_statusline(const LinkInfo curlink,
				 int for_what)
d5998 1
a5998 1
     * Make sure form novice lines are replaced.
d6000 1
a6000 1
    if (user_mode == NOVICE_MODE && for_what != FOR_INPUT) {
d6004 4
d6010 1
a6010 1
	 * Currently displaying HTML source.
a6013 4
	/*
	 * If we are in forms mode then explicitly tell the user what each kind
	 * of link is.
	 */
d6027 103
a6129 1
	    show_formlink_statusline(curlink.l_form, for_what);
d6135 1
a6135 1
	 * Let them know if it's an index -- very rare.
d6138 4
a6141 6
	    const char *indx = gettext("-index-");

	    LYmove(LYlines - 1, LYcolLimit - strlen(indx));
	    lynx_start_reverse();
	    LYaddstr(indx);
	    lynx_stop_reverse();
d6146 1
a6146 1
	 * Show the URL or, for some internal links, the fragment
d6148 1
a6148 2
	char *cp = NULL;

d6150 16
a6165 2
	    !isLYNXIMGMAP(curlink.lname)) {
	    cp = findPoundSelector(curlink.lname);
a6166 3
	if (!cp)
	    cp = curlink.lname;
	status_link(cp, more, is_www_index);
d6179 1
a6179 1
	    _statusline(MORE);
d6181 1
a6181 1
	    _statusline(MOREHELP);
a6184 1

d6186 1
a6186 18
    /* But not if LYShowCursor is on.  -show_cursor may be used as a
     * workaround to avoid putting the cursor in the last position, for
     * curses implementations or terminals that cannot deal with that
     * correctly. - kw */
    if (!LYShowCursor) {
	LYHideCursor();
    }
}

/*
 * Public function for redrawing the statusline appropriate for the selected
 * link.  It should only be called at times when curdoc.link, nlinks, and the
 * links[] array are valid.  - kw
 */
void repaint_main_statusline(int for_what)
{
    if (curdoc.link >= 0 && curdoc.link < nlinks)
	show_main_statusline(links[curdoc.link], for_what);
a6188 34
static void form_noviceline(int disabled)
{
    LYmove(LYlines - 2, 0);
    LYclrtoeol();
    if (!disabled) {
	LYaddstr(FORM_NOVICELINE_ONE);
    }
    LYmove(LYlines - 1, 0);
    LYclrtoeol();
    if (disabled)
	return;
    if (EditBinding(FROMASCII('\025')) == LYE_ERASE) {
	LYaddstr(FORM_NOVICELINE_TWO);
    } else if (EditBinding(FROMASCII('\025')) == LYE_DELBL) {
	LYaddstr(FORM_NOVICELINE_TWO_DELBL);
    } else {
	char *temp = NULL;
	char *erasekey = fmt_keys(LYKeyForEditAction(LYE_ERASE), -1);

	if (erasekey) {
	    HTSprintf0(&temp, FORM_NOVICELINE_TWO_VAR, erasekey);
	} else {
	    erasekey = fmt_keys(LYKeyForEditAction(LYE_DELBL), -1);
	    if (erasekey)
		HTSprintf0(&temp,
			   FORM_NOVICELINE_TWO_DELBL_VAR, erasekey);
	}
	if (temp) {
	    LYaddstr(temp);
	    FREE(temp);
	}
	FREE(erasekey);
    }
}
d6190 3
a6192 2
static void exit_immediately_with_error_message(int state,
						BOOLEAN first_file)
d6202 2
a6203 1
    if (state == NOT_FOUND) {
d6205 1
a6205 1
		   NonNull(buf2),
d6207 5
a6211 6
	/*
	 * hack: if we fail in HTAccess.c
	 * avoid duplicating URL, oh.
	 */
		   (buf2 && strstr(buf2, gettext("Can't Access"))) ?
		   "" : startfile);
d6214 2
a6215 1
    if (state == NULLFILE) {
d6217 1
a6217 1
		   NonNull(buf2),
d6229 1
a6229 1
	fputs(buf, stderr);
d6233 3
a6235 3
	SetOutputMode(O_TEXT);
	fputs(buf, stdout);
	SetOutputMode(O_BINARY);
d6241 1
a6241 26
	exit_immediately(EXIT_FAILURE);
    }
    /* else: return(EXIT_FAILURE) in mainloop */
}

static void status_link(char *curlink_name,
			BOOLEAN show_more,
			BOOLEAN show_indx)
{
#define MAX_STATUS (LYcolLimit - 1)
#define MIN_STATUS 0
    char format[MAX_LINE];
    int prefix = 0;
    int length;

    *format = 0;
    if (show_more) {
	sprintf(format, "%.*s ",
		(int) (sizeof(format) - 2),
		gettext("-more-"));
	prefix = strlen(format);
    }
    if (show_indx) {
	sprintf(format + prefix, "%.*s ",
		(int) (sizeof(format) - prefix - 2),
		gettext("-index-"));
d6243 1
a6243 53
    prefix = strlen(format);
    length = strlen(curlink_name);

    if (prefix > MAX_STATUS || prefix >= MAX_LINE - 1) {
	_user_message("%s", format);	/* no room for url */
    } else {
	sprintf(format + prefix, "%%.%ds", MAX_STATUS - prefix);

	if ((length + prefix > MAX_STATUS) && long_url_ok) {
	    char *buf = NULL;
	    int cut_from_pos;
	    int cut_to_pos;
	    int n;

	    StrAllocCopy(buf, curlink_name);
	    /*
	     * Scan to find the final leaf of the URL.  Ignore trailing '/'.
	     */
	    for (cut_to_pos = length - 2;
		 (cut_to_pos > 0) && (buf[cut_to_pos] != '/');
		 cut_to_pos--) ;
	    /*
	     * Jump back to the next leaf to remove.
	     */
	    for (cut_from_pos = cut_to_pos - 4;
		 (cut_from_pos > 0) && ((buf[cut_from_pos] != '/')
					|| ((prefix + cut_from_pos
					     + 4
					     + (length - cut_to_pos)) >= MAX_STATUS));
		 cut_from_pos--) ;
	    /*
	     * Replace some leaves to '...', if possible, and put the final
	     * leaf at the end.  We assume that one can recognize the link from
	     * at least MIN_STATUS characters.
	     */
	    if (cut_from_pos > MIN_STATUS) {
		for (n = 1; n <= 3; n++)
		    buf[cut_from_pos + n] = '.';
		for (n = 0; cut_to_pos + n <= length; n++)
		    buf[cut_from_pos + 4 + n] = buf[cut_to_pos + n];
	    }
	    _user_message(format, buf);
	    CTRACE((tfp, "lastline = %s\n", buf));	/* don't forget to erase me */
	    FREE(buf);
	} else {		/* show (possibly truncated) url */
	    _user_message(format, curlink_name);
	}
    }
}

const char *LYDownLoadAddress(void)
{
    return NonNull(newdoc.address);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a2 1
#include <HTParse.h>
a39 1
#include <GridText.h>
d41 1
a41 99
#ifdef KANJI_CODE_OVERRIDE
#include <HTCJK.h>
#endif

#ifdef KANJI_CODE_OVERRIDE
PUBLIC char *str_kcode(HTkcode code)
{
    char *p;
    static char buff[8];

    if (current_char_set == TRANSPARENT) {
	p = "THRU";
    } else if (!LYRawMode) {
	p = "RAW";
    } else {
	switch (code) {
	case NOKANJI:
	    p = "AUTO";
	    break;

	case EUC:
	    p = "EUC+";
	    break;

	case SJIS:
	    p = "SJIS";
	    break;

	case JIS:
	    p = " JIS";
	    break;

	default:
	    p = " ???";
	    break;
	}
    }

    if (no_table_center) {
	buff[0] = '!';
	strcpy(buff + 1, p);
    } else {
	strcpy(buff, p);
    }

    return buff;
}
#endif

#ifdef WIN_EX

PRIVATE char *str_sjis(char *to, char *from)
{
    if (!LYRawMode) {
	strcpy(to, from);
#ifdef KANJI_CODE_OVERRIDE
    } else if (last_kcode == EUC) {
	EUC_TO_SJIS(from, to);
    } else if (last_kcode == SJIS) {
	strcpy(to, from);
#endif
    } else {
	TO_SJIS(from, to);
    }
    return to;
}

PRIVATE void set_ws_title(char * str)
{
    SetConsoleTitle(str);
}

#endif /* WIN_EX */


#ifdef SH_EX  /* 1998/10/30 (Fri) 10:06:47 */

#define NOT_EQU	1

PRIVATE int str_n_cmp(const char *p, const char *q, int n)
{
    if (n == 0)
	return 0;

    if (p == NULL)
	return NOT_EQU;

    if (q == NULL)
	return NOT_EQU;

    return strncmp(p, q, n);
}

#undef strncmp
#define	strncmp(p, q, r)	str_n_cmp(p, q, r)

#endif	/* SH_EX */

#if defined(USE_EXTERNALS) || defined(WIN_EX)
a56 13
/* two constants: */
PUBLIC HTLinkType * HTInternalLink = 0;
PUBLIC HTAtom * WWW_SOURCE = 0;

#ifndef DONT_TRACK_INTERNAL_LINKS
#define NO_INTERNAL_OR_DIFFERENT(c,n) TRUE
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) (!curdoc.internal_link || \
			   are_phys_different(p,n))
#else /* TRACK_INTERNAL_LINKS */
#define NO_INTERNAL_OR_DIFFERENT(c,n) are_different(c,n)
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) are_different(p,n)
#endif /* TRACK_INTERNAL_LINKS */

d59 9
a67 4
PRIVATE void status_link PARAMS((char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx));
PRIVATE void show_main_statusline PARAMS((CONST LinkInfo curlink, int for_what));
PRIVATE void form_noviceline PARAMS((int));
PRIVATE int are_different PARAMS((DocInfo *doc1, DocInfo *doc2));
d70 1
a70 1
PRIVATE int are_phys_different PARAMS((DocInfo *doc1, DocInfo *doc2));
a86 3
PUBLIC char * LYRequestReferer = NULL; /* Referer, may be set in getfile() */

PRIVATE char prev_target[512];
d89 6
a94 2
PUBLIC BOOLEAN display_partial = FALSE; /* could be enabled in HText_new() */
PUBLIC int NumOfLines_partial = 0;  /* number of lines displayed in partial mode */
d97 2
a98 3
PRIVATE int Newline = 0;
PRIVATE DocInfo newdoc;
PRIVATE DocInfo curdoc;
a100 12
PRIVATE char *owner_address = NULL;  /* Holds the responsible owner's address     */
PRIVATE char *ownerS_address = NULL; /* Holds owner's address during source fetch */

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
PRIVATE BOOL textinput_activated = FALSE;
#else
#define textinput_activated TRUE /* a current text input is always active */
#endif
#ifdef INACTIVE_INPUT_STYLE_VH
PUBLIC BOOL textinput_redrawn = FALSE;
    /*must be public since used in LYhighlight(..)*/
#endif
d108 11
a118 4
    LYFreeDocInfo(&newdoc);
    LYFreeDocInfo(&curdoc);

#ifdef USE_COLOR_STYLE
a123 2
    FREE(owner_address);
    FREE(ownerS_address);
a125 1
    reset_dired_menu();
a126 2
    FREE(WWW_Download_File);	/* LYGetFile.c/HTFWriter.c */
    FREE(LYRequestReferer);
d132 8
a139 1
#ifndef NO_LYNX_TRACE
d147 1
a147 37
	exit(EXIT_FAILURE);
    }
}

PRIVATE BOOLEAN LYReopenTracelog ARGS1(BOOLEAN *, trace_flag_ptr)
{
    CTRACE((tfp, "\nTurning off TRACE for fetch of log.\n"));
    LYCloseTracelog();
    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
	TracelogOpenFailed();
	return FALSE;
    }
    if (TRACE) {
	WWW_TraceFlag = FALSE;
	*trace_flag_ptr = TRUE;
    }
    return TRUE;
}

PRIVATE void turn_trace_back_on ARGS1(BOOLEAN *, trace_flag_ptr)
{
    if (*trace_flag_ptr == TRUE) {
	WWW_TraceFlag = TRUE;
	*trace_flag_ptr = FALSE;
	fprintf(tfp, "Turning TRACE back on.\n\n");
    }
}
#else
#define LYReopenTracelog(flag) TRUE
#define turn_trace_back_on(flag) /*nothing*/
#endif /* NO_LYNX_TRACE */

PUBLIC FILE *TraceFP NOARGS
{
#ifndef NO_LYNX_TRACE
    if (LYTraceLogFP != 0) {
	return LYTraceLogFP;
a148 2
#endif /* NO_LYNX_TRACE */
    return stderr;
a152 1
#ifndef NO_LYNX_TRACE
d176 1
a176 4
	 *  anonymous restrictions are set. - FM, LP, kw
	 *  This is only a summary for convenience - it doesn't
	 *  take the case of individual -restrictions= options
	 *  into account. - kw
d178 2
a179 25
	if (LYValidate) {
	    if (LYRestricted && had_restrictions_default) {
		CTRACE((tfp, "Validate and some anonymous restrictions are set.\n"));
	    } else if (had_restrictions_default) {
		CTRACE((tfp, "Validate restrictions set, restriction \"default\" was given.\n"));
	    } else if (LYRestricted) {
		CTRACE((tfp, "Validate restrictions set, additional anonymous restrictions ignored.\n"));
	    } else {
		CTRACE((tfp, "Validate restrictions are set.\n"));
	    }
	    /* But none of the above can actually happen, since there should
	     * never be a Trace Log with -validate.  If it appears in a log
	     * file something went wrong! */
	} else if (LYRestricted) {
	    if (had_restrictions_all) {
		CTRACE((tfp, "Anonymous restrictions set, restriction \"all\" was given.\n"));
	    } else {
		CTRACE((tfp, "Anonymous restrictions are set.\n"));
	    }
	} else if (had_restrictions_all && had_restrictions_default) {
	    CTRACE((tfp, "Restrictions \"all\" and \"default\" were given.\n"));
	} else if (had_restrictions_default) {
	    CTRACE((tfp, "Restriction \"default\" was given.\n"));
	} else if (had_restrictions_all) {
	    CTRACE((tfp, "\"all\" restrictions are set.\n"));
a181 1
#endif /* NO_LYNX_TRACE */
a186 1
#ifndef NO_LYNX_TRACE
a192 1
#endif /* NO_LYNX_TRACE */
d195 1
a195 1
PUBLIC void handle_LYK_TRACE_TOGGLE NOARGS
d197 9
a205 33
#ifndef NO_LYNX_TRACE
    WWW_TraceFlag = ! WWW_TraceFlag;
    if (LYOpenTraceLog())
	HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

PUBLIC void LYSetNewline ARGS1(
	int,		value)
{
    Newline = value;
}

PUBLIC int LYGetNewline NOARGS
{
    return Newline;
}

#ifdef SOURCE_CACHE
PRIVATE BOOLEAN from_source_cache = FALSE;

/*
 * Like HTreparse_document(), but also set the flag.
 */
PRIVATE BOOLEAN reparse_document NOARGS
{
    BOOLEAN ok;
    from_source_cache = TRUE;	/* set for LYMainLoop_pageDisplay() */
    if ((ok = HTreparse_document()) != FALSE) {
	from_source_cache = TRUE;	/* set for mainloop refresh */
	return ok;
d207 1
a207 2
    from_source_cache = FALSE;
    return ok;
a208 1
#endif /* SOURCE_CACHE */
d210 2
a211 6
/*
 * Prefer reparsing if we can, but reload if we must - to force regeneration
 * of the display.
 */
PRIVATE BOOLEAN reparse_or_reload ARGS1(
    int *,	cmd)
d213 6
a218 3
#ifdef SOURCE_CACHE
    if (reparse_document()) {
	return FALSE;
a219 3
#endif
    *cmd = LYK_RELOAD;
    return TRUE;
d223 6
a228 1
 * Functions for setting the current address
a229 6
PRIVATE void set_address ARGS2(
	DocInfo *,	doc,
	CONST char *,	address)
{
    StrAllocCopy(doc->address, address);
}
d231 1
a231 3
PRIVATE void copy_address ARGS2(
	DocInfo *,	dst,
	DocInfo *,	src)
d233 33
a265 2
    StrAllocCopy(dst->address, src->address);
}
d267 4
a270 13
PRIVATE void free_address ARGS1(
	DocInfo *,	doc)
{
    FREE(doc->address);
}

PRIVATE void move_address ARGS2(
	DocInfo *,	dst,
	DocInfo *,	src)
{
    copy_address(dst, src);
    free_address(src);
}
a271 1
#ifdef DISP_PARTIAL
d273 6
a278 4
 * This is for traversal call from within partial mode in LYUtils.c
 * and HTFormat.c  It simply calls HText_pageDisplay() but utilizes
 * LYMainLoop.c PRIVATE variables to manage proper newline position
 * in case of #fragment
d280 21
a300 20
PUBLIC BOOL LYMainLoop_pageDisplay ARGS1(
	int,		line_num)
{
    CONST char * pound;
    int prev_newline = Newline;

    /*
     *  Override Newline with a new value if user
     *  scrolled the document while loading (in LYUtils.c).
     */
    Newline = line_num;

#ifdef SOURCE_CACHE
    /*
     * reparse_document() acts on 'curdoc' which always on top of the
     * history stack: no need to resolve #fragment position since
     * we already know it (curdoc.line).
     * So bypass here. Sorry for possible confusion...
     */
    if (!from_source_cache)
d302 9
a310 20
	/*
	 * If the requested URL has the #fragment, and we are not popped
	 * from the history stack, and have not scrolled the document yet -
	 * we should calculate correct newline position for the fragment.
	 * (This is a bit suboptimal since HTFindPoundSelector() traverse
	 * anchors list each time, so we have a quadratic complexity
	 * and may load CPU in a worst case).
	 */
	if (display_partial
	    && newdoc.line == 1 && line_num == 1 && prev_newline == 1
	    && (pound = findPoundSelector(newdoc.address))
	    && *pound && *(pound+1)) {
	    if (HTFindPoundSelector(pound+1)) {
		/* HTFindPoundSelector will initialize www_search_result */
		Newline = www_search_result;
	    } else {
		Newline = prev_newline; /* restore ??? */
		return NO;	/* no repaint */
	    }
	}
d312 7
a318 4
    HText_pageDisplay(Newline, prev_target);
    return YES;
}
#endif /* DISP_PARTIAL */
d320 6
a325 10

PRIVATE void set_curdoc_link ARGS1(
    int,	nextlink)
{
    if (curdoc.link != nextlink
     && nextlink >= 0
     && nextlink < nlinks) {
	if (curdoc.link >= 0 && curdoc.link < nlinks)
	    LYhighlight(OFF, curdoc.link, prev_target);
	curdoc.link = nextlink;
a326 114
}

PRIVATE int do_change_link NOARGS
{
#ifdef USE_MOUSE
    /* Is there a mouse-clicked link waiting? */
    int mouse_tmp = get_mouse_link();
    /* If yes, use it as the link */
    if (mouse_tmp != -1) {
	if (mouse_tmp < 0 || mouse_tmp >= nlinks) {
	    char *msgtmp = NULL;
	    HTSprintf0(&msgtmp,
		       gettext("Internal error: Invalid mouse link %d!"),
		       mouse_tmp);
	    HTAlert(msgtmp);
	    FREE(msgtmp);
	    return(-1);		/* indicates unexpected error */
	}
	set_curdoc_link(mouse_tmp);
    }
#endif /* USE_MOUSE */
    return(0);			/* indicates OK */
}

#ifdef DIRED_SUPPORT
#define DIRED_UNCACHE_1 if (LYAutoUncacheDirLists < 1) /*nothing*/ ;\
			else HTuncache_current_document()
#define DIRED_UNCACHE_2 if (LYAutoUncacheDirLists < 2) /*nothing*/ ;\
			else HTuncache_current_document()
#endif /* DIRED_SUPPORT */

PRIVATE void do_check_goto_URL ARGS3(
    char *,	user_input_buffer,
    char **,	old_user_input,
    BOOLEAN *,	force_load)
{
    static BOOLEAN always = TRUE;
    static struct {
	CONST char *name;
	BOOLEAN *flag;
    } table[] = {
	{ STR_FILE_URL,		&no_file_url },
	{ STR_FILE_URL,		&no_goto_file },
	{ STR_LYNXEXEC,		&no_goto_lynxexec },
	{ STR_LYNXPROG,		&no_goto_lynxprog },
	{ STR_LYNXCGI,		&no_goto_lynxcgi },
	{ STR_CSO_URL,		&no_goto_cso },
	{ STR_FINGER_URL,	&no_goto_finger },
	{ STR_FTP_URL,		&no_goto_ftp },
	{ STR_GOPHER_URL,	&no_goto_gopher },
	{ STR_HTTP_URL,		&no_goto_http },
	{ STR_HTTPS_URL,	&no_goto_https },
	{ STR_MAILTO_URL,	&no_goto_mailto },
	{ STR_RLOGIN_URL,	&no_goto_rlogin },
	{ STR_TELNET_URL,	&no_goto_telnet },
	{ STR_TN3270_URL,	&no_goto_tn3270 },
	{ STR_WAIS_URL,		&no_goto_wais },
#ifndef DISABLE_BIBP
	{ STR_BIBP_URL,		&no_goto_bibp },
#endif
#ifndef DISABLE_NEWS
	{ STR_NEWS_URL,		&no_goto_news },
	{ STR_NNTP_URL,		&no_goto_nntp },
	{ STR_SNEWS_URL,	&no_goto_snews },
#endif
#ifdef EXEC_LINKS
	{ STR_LYNXEXEC,		&local_exec_on_local_files },
	{ STR_LYNXPROG,		&local_exec_on_local_files },
#endif /* EXEC_LINKS */
	{ STR_LYNXCFG,		&no_goto_configinfo },
	{ STR_LYNXCFLAGS,	&no_goto_configinfo },
	{ STR_LYNXCOOKIE,	&always },
	{ STR_LYNXDIRED,	&always },
	{ STR_LYNXDOWNLOAD,	&always },
	{ STR_LYNXOPTIONS,	&always },
	{ STR_LYNXPRINT,	&always },
    };
    unsigned n;
    BOOLEAN found = FALSE;

    /* allow going to anchors*/
    if (*user_input_buffer == '#' ) {
	if ( user_input_buffer[1] &&
	     HTFindPoundSelector(user_input_buffer+1) ) {
	     /* HTFindPoundSelector will initialize www_search_result,
		so we do nothing else. */
	    HTAddGotoURL(user_input_buffer);
	    trimPoundSelector(curdoc.address);
	    StrAllocCat(curdoc.address, user_input_buffer);
	}
    } else {
	/*
	 * If it's not a URL then make it one.
	 */
	StrAllocCopy(*old_user_input, user_input_buffer);
	LYEnsureAbsoluteURL(old_user_input, "", TRUE);
	sprintf(user_input_buffer, "%.*s",
		(int)(MAX_LINE - 1), *old_user_input);
	FREE(*old_user_input);

	for (n = 0; n < TABLESIZE(table); n++) {
	    if (*(table[n].flag)
	     && !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
		found = TRUE;
		HTUserMsg2(GOTO_XXXX_DISALLOWED, table[n].name);
		break;
	    }
	}
	if (found) {
	    ;
	} else if (LYValidate &&
		   !isHTTP_URL(user_input_buffer) &&
		   !isHTTPS_URL(user_input_buffer)) {
	    HTUserMsg(GOTO_NON_HTTP_DISALLOWED);
d328 11
a339 2
	    set_address(&newdoc, user_input_buffer);
	    newdoc.isHEAD = FALSE;
d341 2
a342 2
	     *  Might be an anchor in the same doc from a POST
	     *  form.  If so, dont't free the content. -- FM
d344 8
a351 7
	    if (are_different(&curdoc, &newdoc)) {
		/*
		 * Make a name for this new URL.
		 */
		StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
d353 5
a357 7
		newdoc.internal_link = FALSE;
		*force_load = TRUE;
#ifdef DIRED_SUPPORT
		if (lynx_edit_mode) {
		    DIRED_UNCACHE_2;
		}
#endif /* DIRED_SUPPORT */
a358 2
	    LYUserSpecifiedURL = TRUE;
	    HTAddGotoURL(newdoc.address);
a360 1
}
d362 2
a363 12
/* returns FALSE if user cancelled input or URL was invalid, TRUE otherwise */
PRIVATE BOOL do_check_recall ARGS7(
    int,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int,	URLTotal,
    int *,	URLNum,
    int,	recall,
    BOOLEAN *,	FirstURLRecall)
{
    char *cp;
    BOOL ret = FALSE;
d365 4
a368 2
    if (*old_user_input == 0)
	StrAllocCopy(*old_user_input, "");
d370 3
a372 21
    for (;;) {
#ifdef WIN_EX	/* 1998/10/11 (Sun) 10:41:05 */
	int len = strlen(user_input_buffer);

	if (len >= 3) {
	    if (len < MAX_LINE - 1
	     && LYIsHtmlSep(user_input_buffer[len - 3])
	     && LYIsDosDrive(user_input_buffer + len - 2))
		LYAddPathSep0(user_input_buffer);

	} else if (len == 2 && user_input_buffer[1] == ':') {
		if (LYIsDosDrive(user_input_buffer)) {
			LYAddPathSep0(user_input_buffer);
		} else {
			HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
			LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
			FREE(*old_user_input);
			ret = FALSE;
			break;
		}
	}
d375 2
a376 1
	 * Get rid of leading spaces (and any other spaces).
d378 12
a389 11
	LYTrimAllStartfile(user_input_buffer);
	if (*user_input_buffer == '\0' &&
	    !(recall && (ch == UPARROW || ch == DNARROW))) {
	    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	    FREE(*old_user_input);
	    HTInfoMsg(CANCELLED);
	    ret = FALSE;
	    break;
	}
	if (recall && ch == UPARROW) {
	    if (*FirstURLRecall) {
d391 2
a392 1
		 * Use last URL in the list.  - FM
d394 1
a394 29
		*FirstURLRecall = FALSE;
		*URLNum = 0;
	    } else {
		/*
		 * Go back to the previous URL in the list.  - FM
		 */
		*URLNum += 1;
	    }
	    if (*URLNum >= URLTotal)
		/*
		 * Roll around to the last URL in the list.  - FM
		 */
		*URLNum = 0;
	    if ((cp = (char *)HTList_objectAt(Goto_URLs,
					      *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer
		 && **old_user_input
		 && !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				  MAX_LINE,
				  recall)) < 0) {
d396 6
a401 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d403 5
a407 40
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else if (recall && ch == DNARROW) {
	    if (*FirstURLRecall) {
		/*
		 * Use the first URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = URLTotal - 1;
	    } else {
		/*
		 * Advance to the next URL in the list.  - FM
		 */
		*URLNum -= 1;
	    }
	    if (*URLNum < 0)
		/*
		 * Roll around to the first URL in the list.  - FM
		 */
		*URLNum = URLTotal - 1;
	    if ((cp=(char *)HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer && **old_user_input &&
		    !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
d409 2
a410 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d412 12
a423 15
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else {
	    ret = TRUE;
	    break;
	}
    }
    return ret;
}
a424 14
PRIVATE void do_cleanup_after_delete NOARGS
{
    HTuncache_current_document();
    move_address(&newdoc, &curdoc);
    newdoc.line = curdoc.line;
    if (curdoc.link == nlinks-1) {
	/*
	 * We deleted the last link on the page.  - FM
	 */
	newdoc.link = curdoc.link-1;
    } else {
	newdoc.link = curdoc.link;
    }
}
d426 36
a461 5
PRIVATE int find_link_near_col ARGS2(
	int,	col,
	int,	delta)
{
    int i;
d463 19
a481 16
    for (i = curdoc.link; delta > 0 ? (i < nlinks) : (i >= 0); i += delta) {
	if ( (links[i].ly - links[curdoc.link].ly) * delta > 0 ) {
	    int cy = links[i].ly, best = -1, dist = 1000000;

	    while ((delta > 0 ? (i < nlinks) : (i >= 0)) && cy == links[i].ly) {
		int cx = links[i].lx;
		char *text = LYGetHiliteStr(i, 0);

		if (text != NULL)
		    cx += strlen(text) / 2;
		cx -= col;
		if (cx < 0)
		    cx = -cx;
		if (cx < dist) {
		    dist = cx;
		    best = i;
a482 7
		i += delta;
	    }
	    return(best);
	}
    }
    return(-1);
}
d484 13
a496 13
/*
 * This is a special feature to traverse every http link derived from startfile
 * and check for errors or create crawl output files.  Only URL's that begin
 * with "traversal_host" are searched - this keeps the search from crossing to
 * other servers (a feature, not a bug!).
 */
PRIVATE int DoTraversal ARGS2(
    int,	c,
    BOOLEAN *,	crawl_ok)
{
    BOOLEAN rlink_rejected = FALSE;
    BOOLEAN rlink_exists;
    BOOLEAN rlink_allowed;
d498 13
a510 35
    rlink_exists = (BOOL) (nlinks > 0 &&
		    links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].lname != NULL);

    if (rlink_exists) {
	rlink_rejected = lookup_reject(links[curdoc.link].lname);
	if (!rlink_rejected &&
	     traversal_host &&
	     links[curdoc.link].lname) {
	    if (!isLYNXIMGMAP(links[curdoc.link].lname)) {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
					 links[curdoc.link].lname,
					 strlen(traversal_host));
	    } else {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
					 links[curdoc.link].lname + LEN_LYNXIMGMAP,
					 strlen(traversal_host));
	    }
	} else {
	    rlink_allowed = FALSE;
	}
    } else {
	rlink_allowed = FALSE;
    }
    if (rlink_exists && rlink_allowed) {
	if (lookup(links[curdoc.link].lname)) {
	    if (more_links ||
		(curdoc.link > -1 && curdoc.link < nlinks -1))
		 c= DNARROW;
	    else {
		if (STREQ(curdoc.title,"Entry into main screen") ||
		    (nhist <= 0 )) {
		    if (!dump_output_immediately) {
			cleanup();
			exit_immediately(EXIT_FAILURE);
a511 1
		    return(-1);
d513 10
a522 26
		c = LTARROW;
	    }
	} else {
	    StrAllocCopy(traversal_link_to_add,
			 links[curdoc.link].lname);
	    if (!isLYNXIMGMAP(traversal_link_to_add))
		*crawl_ok = TRUE;
	    c = RTARROW;
	}
    } else { /* no good right link, so only down and left arrow ok*/
	if (rlink_exists /* && !rlink_rejected */)
	    /* uncomment in previous line to avoid duplicates - kw */
	    add_to_reject_list(links[curdoc.link].lname);
	if (more_links ||
	    (curdoc.link > -1 && curdoc.link < nlinks-1))
	    c = DNARROW;
	else {
	    /*
	     *	curdoc.title doesn't always work, so
	     *	bail out if the history list is empty.
	     */
	    if (STREQ(curdoc.title,"Entry into main screen") ||
		(nhist <= 0 )) {
		if (!dump_output_immediately) {
		    cleanup();
		    exit_immediately(EXIT_FAILURE);
a523 7
		return(-1);
	    }
	    c = LTARROW;
	}
    } /* right link not NULL or link to another site*/
    return c;
}
d525 19
d545 8
a552 77
PRIVATE BOOLEAN check_history NOARGS
{
    CONST char *base;

    if (!curdoc.post_data)
	/*
	 *  Normal case - List Page is not associated
	 *  with post data. - kw
	 */
	return TRUE;

    if (nhist > 0
     && !LYresubmit_posts
     && HDOC(nhist - 1).post_data
     && BINEQ(curdoc.post_data, HDOC(nhist - 1).post_data)
     && (base = HText_getContentBase()) != 0) {
	 char *text = !isLYNXIMGMAP(HDOC(nhist - 1).address)
		     ? HDOC(nhist - 1).address
		     : HDOC(nhist - 1).address + LEN_LYNXIMGMAP;
	if (!strncmp(base, text, strlen(base))) {
	    /*
	     * Normal case - as best as we can check, the document at the top
	     * of the history stack seems to be the document the List Page is
	     * about (or a LYNXIMGMAP derived from it), and LYresubmit_posts is
	     * not set, so don't prompt here.  If we actually have to repeat a
	     * POST because, against expectations, the underlying document
	     * isn't cached any more, HTAccess will prompt for confirmation,
	     * unless we had LYK_NOCACHE -kw
	     */
	    return TRUE;
	}
    }
    return FALSE;
}
#endif

PRIVATE int handle_LYK_ACTIVATE ARGS6(
    int *,	c,
    int,	cmd GCC_UNUSED,
    BOOLEAN *,	try_internal GCC_UNUSED,
    BOOLEAN *,	refresh_screen,
    BOOLEAN *,	force_load,
    int,	real_cmd)
{
    if (do_change_link() == -1) {
	LYforce_no_cache = FALSE;
	reloading = FALSE;
	return 1;	/* mouse stuff was confused, ignore - kw */
    }
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (real_cmd == LYK_ACTIVATE && textfields_need_activation &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {

		textinput_activated = TRUE;
		show_main_statusline(links[curdoc.link], FOR_INPUT);
		textfields_need_activation = textfields_activation_option;

		return 0;
	    }
#endif
	    /*
	     *	Don't try to submit forms with bad actions. - FM
	     */
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type ==
					    F_TEXT_SUBMIT_TYPE) {
		/*
		 *  Do nothing if it's disabled. - FM
		 */
		if (links[curdoc.link].l_form->disabled == YES) {
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
d554 34
a587 84
		/*
		 *  Make sure we have an action. - FM
		 */
		if (!links[curdoc.link].l_form->submit_action ||
		    *links[curdoc.link].l_form->submit_action
							== '\0') {
		    HTUserMsg(NO_FORM_ACTION);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 *  Check for no_mail if the form action
		 *  is a mailto URL. - FM
		 */
		if (links[curdoc.link].l_form->submit_method
			     == URL_MAIL_METHOD && no_mail) {
		    HTAlert(FORM_MAILTO_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 *  Make sure this isn't a spoof in an account
		 *  with restrictions on file URLs. - FM
		 */
		if (no_file_url &&
		    isFILE_URL(links[curdoc.link].l_form->submit_action)) {
		    HTAlert(FILE_ACTIONS_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 *  Make sure this isn't a spoof attempt
		 *  via an internal URL. - FM
		 */
		if (isLYNXCOOKIE(links[curdoc.link].l_form->submit_action) ||
#ifdef DIRED_SUPPORT
#ifdef OK_PERMIT
		    (isLYNXDIRED(links[curdoc.link].l_form->submit_action) &&
		     (no_dired_support ||
		      strncasecomp(
			(links[curdoc.link].l_form->submit_action + 10),
				   "//PERMIT_LOCATION", 17) ||
		      !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS))) ||
#else
		    isLYNXDIRED(links[curdoc.link].l_form->submit_action) ||
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
		    isLYNXDOWNLOAD(links[curdoc.link].l_form->submit_action) ||
		    isLYNXHIST(links[curdoc.link].l_form->submit_action) ||
		    isLYNXKEYMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXIMGMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPRINT(links[curdoc.link].l_form->submit_action) ||
		    isLYNXEXEC(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPROG(links[curdoc.link].l_form->submit_action)) {

		    HTAlert(SPECIAL_ACTION_DISALLOWED);
		    CTRACE((tfp, "LYMainLoop: Rejected '%s'\n",
				links[curdoc.link].l_form->submit_action));
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
#ifdef NOTDEFINED /* We're disabling form inputs instead of using this. - FM */
		/*
		 *  Check for enctype and let user know we
		 *  don't yet support multipart/form-data - FM
		 */
		if (links[curdoc.link].l_form->submit_enctype) {
		    if (!strcmp(
			     links[curdoc.link].l_form->submit_enctype,
				"multipart/form-data")) {
			HTAlert(
gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			reloading = FALSE;
			return 0;
d589 1
d591 3
a593 12
#endif /* NOTDEFINED */
		if (check_realm) {
		    LYPermitURL = TRUE;
		}
		if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
		    LYNoRefererForThis = TRUE;
		}
		if (links[curdoc.link].l_form->submit_method != URL_MAIL_METHOD) {
		    StrAllocCopy(newdoc.title,
				 LYGetHiliteStr(curdoc.link, 0));
		}
	    }
d595 1
a595 20
	    /*
	     *	Normally we don't get here for text input fields,
	     *  but it can happen as a result of mouse positioning.
	     *  In that case the statusline will not have updated
	     *  info, so update it now. - kw
	     */
	    if (F_TEXTLIKE(links[curdoc.link].l_form->type)) {
		show_formlink_statusline(links[curdoc.link].l_form,
					 (real_cmd == LYK_NOCACHE ||
					  real_cmd == LYK_DOWNLOAD ||
					  real_cmd == LYK_HEAD ||
					  (real_cmd == LYK_SUBMIT &&
					   !textinput_activated)) ?
					 FOR_PANEL : FOR_INPUT);
		if (user_mode == NOVICE_MODE &&
		    textinput_activated &&
		    (real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT)) {
			form_noviceline(links[curdoc.link].l_form->disabled);
		}
	    }
d597 12
a608 24
	    *c = change_form_link(curdoc.link,
				 &newdoc, refresh_screen,
				 FALSE,
				 (BOOLEAN)(real_cmd == LYK_SUBMIT ||
				  real_cmd == LYK_NOCACHE ||
				  real_cmd == LYK_DOWNLOAD ||
				  real_cmd == LYK_HEAD));
	    if (*c != LKC_DONE || *refresh_screen) {
		/*
		 *  Cannot have been a submit field for which
		 *  newdoc was filled in. - kw
		 */
		if ((links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) &&
		    links[curdoc.link].l_form->submit_method
			     != URL_MAIL_METHOD) {
		    /*
		     *  Try to undo change of newdoc.title done above.
		     */
		    if (HText_getTitle()) {
			StrAllocCopy(newdoc.title, HText_getTitle());
		    } else if (curdoc.title) {
			StrAllocCopy(newdoc.title, curdoc.title);
d610 15
a624 21
		}
	    } else {
		if (HTOutputFormat == HTAtom_for("www/download") &&
		    newdoc.post_data != NULL &&
		    newdoc.safe == FALSE) {

		    if ((HText_POSTReplyLoaded(&newdoc) == TRUE) &&
			HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			HTInfoMsg(CANCELLED);
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			return 0;
d626 2
a627 100
		}
		/*
		 *  Moved here from earlier to only apply when it
		 *  should.   Anyway, why should realm checking be
		 *  overridden for form submissions, this seems to
		 *  be an unnecessary loophole??  But that's the way
		 *  it was, maybe there is some reason.
		 *  However, at least make sure this doesn't weaken
		 *  restrictions implied by -validate!
		 *  - kw 1999-05-25
		 */
		if (check_realm && !LYValidate) {
		    LYPermitURL = TRUE;
		}
	    }
	    if (*c == LKC_DONE) {
		*c = DO_NOTHING;
	    } else if (*c == 23) {
		*c = DO_NOTHING;
		*refresh_screen = TRUE;
	    } else {
		/*  Avoid getting stuck with repeatedly calling
		**  handle_LYK_ACTIVATE(), instead of calling
		**  change_form_link() directly from mainloop(),
		**  for text input fields. - kw
		*/
		switch (LKC_TO_C(*c)) {
		case '\n':
		case '\r':
		default:
		    if ((real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT) &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
			textinput_activated)
			return 3;
		    break;
		}
	    }
	    return 2;
	} else {
	    /*
	     *	Not a forms link.
	     *
	     *	Make sure this isn't a spoof in an account
	     *	with restrictions on file URLs. - FM
	     */
	    if (no_file_url && isFILE_URL(links[curdoc.link].lname)) {
		if (!isFILE_URL(curdoc.address) &&
		    !((isLYNXKEYMAP(curdoc.address) ||
		       isLYNXCOOKIE(curdoc.address)) &&
		      !strncmp(links[curdoc.link].lname,
			       helpfilepath,
			       strlen(helpfilepath)))) {
		    HTAlert(FILE_SERVED_LINKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		} else if (curdoc.bookmark != NULL) {
		    HTAlert(FILE_BOOKMARKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		}
	    }
	    /*
	     *	Make sure this isn't a spoof attempt
	     *	via an internal URL in a non-internal
	     *	document. - FM
	     */
	    if ((isLYNXCOOKIE(links[curdoc.link].lname) &&
		 (strcmp(NonNull(curdoc.title), COOKIE_JAR_TITLE) ||
		  !isLYNXCOOKIE(curdoc.address))) ||
#ifdef DIRED_SUPPORT
		(isLYNXDIRED(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
		 !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
#ifdef OK_INSTALL
		 !LYIsUIPage(curdoc.address, UIP_INSTALL) &&
#endif /* OK_INSTALL */
		 !LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) ||
#endif /* DIRED_SUPPORT */
		(isLYNXDOWNLOAD(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS)) ||
		(isLYNXHIST(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		 !LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		 !LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) ||
		(isLYNXPRINT(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS))) {
		    HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}

#ifdef USE_EXTERNALS
	    if (run_external(links[curdoc.link].lname, TRUE))
	    {
		*refresh_screen = TRUE;
		return 0;
	    }
#endif /* USE_EXTERNALS */
d629 4
a632 67
	    /*
	     *	Follow a normal link or anchor.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	/*
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
	 */
	    /*
	     *	Might be an internal link anchor in the same doc.
	     *	If so, take the try_internal shortcut if we didn't
	     *	fall through from LYK_NOCACHE. - kw
	     */
	    newdoc.internal_link =
		(links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
	    if (newdoc.internal_link) {
		/*
		 *  Special case of List Page document with an
		 *  internal link indication, which may really stand
		 *  for an internal link within the document the
		 *  List Page is about. - kw
		 */
		if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		    (LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		     LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		    if (check_history()) {
			LYinternal_flag = TRUE;
		    } else {
			HTLastConfirmCancelled(); /* reset flag */
			if (!confirm_post_resub(newdoc.address,
						newdoc.title,
					(LYresubmit_posts &&
			       HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
						2)) {
			    if (HTLastConfirmCancelled() ||
				(LYresubmit_posts &&
				 cmd != LYK_NOCACHE &&
				 !HText_POSTReplyLoaded(&newdoc))) {
				/* cancel the whole thing */
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				copy_address(&newdoc, &curdoc);
				StrAllocCopy(newdoc.title, curdoc.title);
				newdoc.internal_link = curdoc.internal_link;
				HTInfoMsg(CANCELLED);
				return 1;
			    } else if (LYresubmit_posts &&
				       cmd != LYK_NOCACHE) {
				/* If LYresubmit_posts is set, and the
				   answer was No, and the key wasn't
				   NOCACHE, and we have a cached copy,
				   then use it. - kw */
				LYforce_no_cache = FALSE;
			    } else {
				/* if No, but not ^C or ^G, drop
				 * the post data.  Maybe the link
				 * wasn't meant to be internal after
				 * all, here we can recover from that
				 * assumption. - kw */
				LYFreePostData(&newdoc);
				newdoc.internal_link = FALSE;
				HTAlert(DISCARDING_POST_DATA);
d635 5
d641 1
d643 3
a645 2
		     *	Don't push the List Page if we follow an
		     *	internal link given by it. - kw
d647 7
a653 68
		    free_address(&curdoc);
		} else if (cmd != LYK_NOCACHE) {
		    *try_internal = TRUE;
		}
		if (!(LYresubmit_posts && newdoc.post_data))
		    LYinternal_flag = TRUE;
		/* We still set force_load so that history pushing
		** etc. will be done.  - kw */
		*force_load = TRUE;
		return 1;
	    } else {
		/*
		 *  Free POST content if not an internal link. - kw
		 */
		LYFreePostData(&newdoc);
	    }
#endif /* TRACK_INTERNAL_LINKS */
	    /*
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		if (isLYNXMESSAGES(newdoc.address))
		    LYforce_no_cache = TRUE;
	    }
	    if (!no_jump && lynxjumpfile && curdoc.address &&
		!strcmp(lynxjumpfile, curdoc.address)) {
		LYJumpFileURL = TRUE;
		LYUserSpecifiedURL = TRUE;
	    } else if ((curdoc.title &&
			(LYIsUIPage(curdoc.address, UIP_HISTORY) ||
			 !strcmp(curdoc.title, HISTORY_PAGE_TITLE))) ||
		       curdoc.bookmark != NULL ||
		       (lynxjumpfile &&
			!strcmp(lynxjumpfile, curdoc.address))) {
		LYUserSpecifiedURL = TRUE;
	    } else if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
		LYNoRefererForThis = TRUE;
	    }
	    newdoc.link = 0;
	    *force_load = TRUE;	/* force MainLoop to reload */
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;	/* we get here if link is not internal */
#endif

#if defined(DIRED_SUPPORT) && !defined(__DJGPP__)
	    if (lynx_edit_mode) {
		  DIRED_UNCACHE_2;
		  /*
		   *  Unescaping any slash chars in the URL,
		   *  but avoid double unescaping and too-early
		   *  unescaping of other chars. - KW
		   */
		  HTUnEscapeSome(newdoc.address,"/");
		  /* avoid stripping final slash for root dir - kw */
		  if (strcasecomp(newdoc.address, "file://localhost/"))
		      strip_trailing_slash(newdoc.address);
	    }
#endif /* DIRED_SUPPORT  && !__DJGPP__ */
	    if (isLYNXCOOKIE(curdoc.address)) {
		HTuncache_current_document();
	    }
	}
    }
    return 0;
}
d655 1
a655 104
#ifdef EXP_ADDRLIST_PAGE
PRIVATE BOOLEAN handle_LYK_ADDRLIST ARGS1(
    int *,     cmd)
{
    /*
     *	Don't do if already viewing list addresses page.
     */
    if (LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) {
	/*
	 *  Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     *	Print address list page to file.
     */
    if (showlist(&newdoc, FALSE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, ADDRLIST_PAGE_TITLE);
    /*
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}
#endif /* EXP_ADDRLIST_PAGE */

PRIVATE void handle_LYK_ADD_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    int c;

    if (LYValidate) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    if (!LYIsUIPage(curdoc.address, UIP_HISTORY) &&
	!LYIsUIPage(curdoc.address, UIP_SHOWINFO) &&
	!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS) &&
#ifdef DIRED_SUPPORT
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	!LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
	!LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS) &&
#endif /* DIRED_SUPPORT */
	!LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS) &&
	!isLYNXCOOKIE(curdoc.address) &&
	!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU) &&
	((nlinks <= 0) ||
	 (links[curdoc.link].lname != NULL &&
	  !isLYNXHIST(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname) &&
	  !isLYNXDIRED(links[curdoc.link].lname) &&
	  !isLYNXDOWNLOAD(links[curdoc.link].lname) &&
	  !isLYNXCOOKIE(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname)))) {
	if (nlinks > 0) {
	    if (curdoc.post_data == NULL &&
		curdoc.bookmark == NULL &&
		!LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_VLINKS)) {
		/*
		 *  The document doesn't have POST content,
		 *  and is not a bookmark file, nor is the
		 *  list or visited links page, so we can
		 *  save either that or the link. - FM
		 */
		_statusline(BOOK_D_L_OR_CANCEL);
		if ((c = LYgetch_single()) == 'D') {
		    save_bookmark_link(curdoc.address, curdoc.title);
		    *refresh_screen = TRUE; /* MultiBookmark support */
		    goto check_add_bookmark_to_self;
		}
	    } else {
		if (LYMultiBookmarks == MBM_OFF &&
		    curdoc.bookmark != NULL &&
		    strstr(curdoc.address,
			   (*bookmark_page == '.'
					  ? (bookmark_page+1)
					  : bookmark_page)) != NULL) {
		    /*
		     *	If multiple bookmarks are disabled, offer
		     *	the L)ink or C)ancel, but with wording
		     *	which indicates that the link already
		     *	exists in this bookmark file. - FM
		     */
		    _statusline(MULTIBOOKMARKS_SELF);
		} else if (curdoc.post_data != NULL &&
			   links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
d657 1
a657 1
		     *	Internal link, and document has POST content.
d659 30
a688 3
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		} else {
d690 2
a691 4
		     *	Only offer the link in a document with
		     *	POST content, or if the current document
		     *	is a bookmark file and multiple bookmarks
		     *	are enabled. - FM
d693 33
a725 198
		    _statusline(BOOK_L_OR_CANCEL);
		}
		c = LYgetch_single();
	    }
	    if (c == 'L') {
		if (curdoc.post_data != NULL &&
		    links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
		    /*
		     *	Internal link, and document has POST content.
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		}
		/*
		 *  User does want to save the link. - FM
		 */
		if (links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    save_bookmark_link(links[curdoc.link].lname,
				       LYGetHiliteStr(curdoc.link, 0));
		    *refresh_screen = TRUE; /* MultiBookmark support */
		} else {
		    HTUserMsg(NOBOOK_FORM_FIELD);
		    return;
		}
	    } else {
		return;
	    }
	} else if (curdoc.post_data != NULL) {
	    /*
	     *	No links, and document has POST content. - FM
	     */
	    HTUserMsg(NOBOOK_POST_FORM);
	    return;
	} else if (curdoc.bookmark != NULL) {
	    /*
	     *	It's a bookmark file from which all
	     *	of the links were deleted. - FM
	     */
	    HTUserMsg(BOOKMARKS_NOLINKS);
	    return;
	} else {
	    _statusline(BOOK_D_OR_CANCEL);
	    if (LYgetch_single() == 'D') {
		save_bookmark_link(curdoc.address, curdoc.title);
		*refresh_screen = TRUE; /* MultiBookmark support */
	    } else {
		return;
	    }
	}
check_add_bookmark_to_self:
	if (curdoc.bookmark && BookmarkPage &&
	    !strcmp(curdoc.bookmark, BookmarkPage)) {
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    newdoc.internal_link = FALSE;
	}
    } else {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(NOBOOK_HSML);
	}
    }
}

PRIVATE void handle_LYK_CLEAR_AUTH ARGS2(
    int *,	old_c,
    int,	real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	if (HTConfirm(CLEAR_ALL_AUTH_INFO)) {
	    FREE(authentication_info[0]);
	    FREE(authentication_info[1]);
	    FREE(proxyauth_info[0]);
	    FREE(proxyauth_info[1]);
	    HTClearHTTPAuthInfo();
#ifndef DISABLE_NEWS
	    HTClearNNTPAuthInfo();
#endif
#ifndef DISABLE_FTP
	    HTClearFTPPassword();
#endif
	    HTUserMsg(AUTH_INFO_CLEARED);
	} else {
	    HTUserMsg(CANCELLED);
	}
    }
}

PRIVATE int handle_LYK_COMMAND ARGS1(
    char *,	user_input_buffer)
{
    int ch;
    Kcmd *mp;
    char *src, *tmp;

    *user_input_buffer = 0;
    _statusline(": ");
    if (LYgetstr(user_input_buffer, VISIBLE, MAX_LINE, RECALL_CMD) >= 0) {
	src = LYSkipBlanks(user_input_buffer);
	tmp = LYSkipNonBlanks(src);
	*tmp = 0;
	ch = ((mp = LYStringToKcmd(src)) != 0) ? mp->code : 0;
	CTRACE((tfp, "LYK_COMMAND(%s.%s) = %d\n", src, tmp, ch));
	if (ch == 0) {
	    return *src ? -1 : 0;
	}
	/* FIXME: reuse the rest of the buffer for parameters */
	return ch;
    }
    return 0;
}

PRIVATE void handle_LYK_COMMENT ARGS4(
    BOOLEAN *,	refresh_screen,
    char **,	owner_address_p,
    int *,	old_c,
    int,	real_c)
{
    int	c;

    if (!*owner_address_p &&
	strncasecomp(curdoc.address, "http", 4)) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(NO_OWNER);
	}
    } else if (no_mail) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(MAIL_DISALLOWED);
	}
    } else {
	if (HTConfirmDefault(CONFIRM_COMMENT, NO)) {
	    if (!*owner_address_p) {
		/*
		 *  No owner defined, so make a guess and
		 *  and offer it to the user. - FM
		 */
		char *address = NULL;
		char *temp = HTParse(curdoc.address, "", PARSE_PATH);
		char *cp;

		if (temp != NULL) {
		    HTUnEscape(temp);
		    if (*temp == '~' && strlen(temp) > 1) {
			/*
			 *  It's a ~user URL so guess user@@host. - FM
			 */
			if ((cp = strchr((temp+1), '/')) != NULL)
			    *cp = '\0';
			StrAllocCopy(address, STR_MAILTO_URL);
			StrAllocCat(address, (temp+1));
			StrAllocCat(address, "@@");
		    }
		    FREE(temp);
		}
		if (address == NULL)
		    /*
		     *	Wasn't a ~user URL so guess WebMaster@@host. - FM
		     */
		    StrAllocCopy(address, "mailto:WebMaster@@");
		temp = HTParse(curdoc.address, "", PARSE_HOST);
		StrAllocCat(address, temp);
		HTSprintf0(&temp, NO_OWNER_USE, address);
		c = HTConfirmDefault(temp, NO);
		FREE(temp);
		if (c == YES) {
		    StrAllocCopy(*owner_address_p, address);
		    FREE(address);
		} else {
		    FREE(address);
		    return;
		}
	    }
	    if (is_url(*owner_address_p) != MAILTO_URL_TYPE) {
		/*
		 *  The address is a URL.  Just follow the link.
		 */
		set_address(&newdoc, *owner_address_p);
		newdoc.internal_link = FALSE;
	    } else {
		/*
		 *  The owner_address is a mailto: URL.
		 */
		CONST char *kp = HText_getRevTitle();
		CONST char *id = HText_getMessageID();
		char *tmptitle = NULL;
		if (!kp && HTMainAnchor) {
		    kp = HTAnchor_subject(HTMainAnchor);
		    if (kp && *kp) {
			if (strncasecomp(kp, "Re: ", 4)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, kp);
			    kp = tmptitle;
a727 1
		}
d729 45
a773 247
		if (strchr(*owner_address_p, ':') != NULL)
		     /*
		      *  Send a reply.	The address is after the colon.
		      */
		     reply_by_mail(strchr(*owner_address_p, ':') + 1,
				   curdoc.address,
				   NonNull(kp), id);
		else
		    reply_by_mail(*owner_address_p, curdoc.address,
				  NonNull(kp), id);

		FREE(tmptitle);
		*refresh_screen = TRUE;	/* to force a showpage */
	    }
	}
    }
}

PRIVATE BOOLEAN handle_LYK_COOKIE_JAR ARGS1(
    int *,	cmd)
{
    /*
     *	Don't do if already viewing the cookie jar.
     */
    if (!isLYNXCOOKIE(curdoc.address)) {
	set_address(&newdoc, "LYNXCOOKIE:/");
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 *  If already in the cookie jar, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

#if defined(DIRED_SUPPORT)
PRIVATE void handle_LYK_CREATE NOARGS
{
    if (lynx_edit_mode && !no_dired_support) {
	if (local_create(&curdoc) > 0) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link > -1 ? curdoc.link : 0;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

PRIVATE void handle_LYK_DEL_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.bookmark != NULL) {
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE,NO) != YES)
	    return;
	remove_bookmark_link(links[curdoc.link].anchor_number-1,
			     curdoc.bookmark);
    } else {	/* behave like REFRESH for backward compatibility */
	*refresh_screen = TRUE;
	if (*old_c != real_c) {
	    *old_c = real_c;
	    lynx_force_repaint();
	}
	return;
    }
    do_cleanup_after_delete();
}

#if defined(DIRED_SUPPORT) || defined(VMS)
PRIVATE void handle_LYK_DIRED_MENU ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c GCC_UNUSED,
    int,	real_c GCC_UNUSED)
{
#ifdef VMS
    char *cp, *temp = 0;
    char *test = HTGetProgramPath(ppCSWING);

    /*
     *	Check if the CSwing Directory/File Manager is available.
     *	Will be disabled if CSWING path is NULL, zero-length,
     *	or "none" (case insensitive), if no_file_url was set via
     *	the file_url restriction, if no_goto_file was set for
     *	the anonymous account, or if HTDirAccess was set to
     *	HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse
     *	or -selective switches. - FM
     */
    if (isEmpty(test) ||
	!strcasecomp(test, "none") ||
	no_file_url || no_goto_file ||
	HTDirAccess == HT_DIR_FORBID ||
	HTDirAccess == HT_DIR_SELECTIVE) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(DFM_NOT_AVAILABLE);
	}
	return;
    }

    /*
     *	If we are viewing a local directory listing or a
     *	local file which is not temporary, invoke CSwing
     *	with the URL's directory converted to VMS path specs
     *	and passed as the argument, so we start up CSwing
     *	positioned on that node of the directory tree.
     *	Otherwise, pass the current default directory as
     *	the argument. - FM
     */
    if (LYisLocalFile(curdoc.address) &&
	strncasecomp(curdoc.address,
		     lynx_temp_space, strlen(lynx_temp_space))) {
	/*
	 *  We are viewing a local directory or a local file
	 *  which is not temporary. - FM
	 */
	struct stat stat_info;

	cp = HTParse(curdoc.address, "", PARSE_PATH|PARSE_PUNCTUATION);
	HTUnEscape(cp);
	if (HTStat(cp, &stat_info) == -1) {
	    CTRACE((tfp, "mainloop: Can't stat %s\n", cp));
	    FREE(cp);
	    HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	    *refresh_screen = TRUE;  /* redisplay */
	} else {
	    char *VMSdir = NULL;

	    if (S_ISDIR(stat_info.st_mode)) {
		/*
		 *  We're viewing a local directory.  Make
		 *  that the CSwing argument. - FM
		 */
		LYAddPathSep(&cp);
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
	    } else {
		/*
		 *  We're viewing a local file.  Make its
		 *  directory the CSwing argument. - FM
		 */
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
		if ((cp = strrchr(VMSdir, ']')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		} else if ((cp = strrchr(VMSdir, ':')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		}
	    }
	    HTSprintf0(&temp, "%s %s", HTGetProgramPath(ppCSWING), VMSdir);
	    FREE(VMSdir);
	    /*
	     *	Uncache the current document in case we
	     *	change, move, or delete it during the
	     *	CSwing session. - FM
	     */
	    /* could use DIRED_UNCACHE_1 but it's currently only defined
	       for dired - kw */
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.title, NonNull(curdoc.title));
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
    } else {
	/*
	 *  We're not viewing a local directory or file.
	 *  Pass CSwing the current default directory as
	 *  an argument and don't uncache the current
	 *  document. - FM
	 */
	HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	*refresh_screen = TRUE;	/* redisplay */
    }
    stop_curses();
    LYSystem(temp);
    start_curses();
    FREE(temp);
#else
    /*
     *	Don't do if not allowed or already viewing the menu.
     */
    if (lynx_edit_mode && !no_dired_support &&
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	strcmp(NonNull(curdoc.title), DIRED_MENU_TITLE)) {
	dired_options(&curdoc,&newdoc.address);
	*refresh_screen = TRUE;	/* redisplay */
    }
#endif /* VMS */
}
#endif /* defined(DIRED_SUPPORT) || defined(VMS) */

PRIVATE int handle_LYK_DOWNLOAD ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{

    /*
     *	Don't do if both download and disk_save are restricted.
     */
    if (LYValidate ||
	(no_download && !override_no_download && no_disk_save)) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(DOWNLOAD_DISABLED);
	}
	return 0;
    }

    /*
     *	Don't do if already viewing download options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS))
	return 0;

    if (do_change_link() == -1)
	return 1;	/* mouse stuff was confused, ignore - kw */
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) {
		if (links[curdoc.link].l_form->submit_method ==
			 URL_MAIL_METHOD) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_MAILTO_ACTION);
d775 2
a776 18
		    return 0;
		}
		if (isLYNXOPTIONS(links[curdoc.link].l_form->submit_action)) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_SPECIAL);
		    }
		    return 0;
		}
		HTOutputFormat = HTAtom_for("www/download");
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return 2;
	    }
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_INPUT);
	    }
d778 10
a787 1005
	} else if (isLYNXCOOKIE(curdoc.address)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_COOKIES);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PRINT_OP);
	    }

#ifdef DIRED_SUPPORT
	} else if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_UPLOAD_OP);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PERMIT_OP);
	    }

	} else if (lynx_edit_mode && !no_dired_support &&
		   !strstr(links[curdoc.link].lname, "/SugFile=")) {
	    /*
	     *	Don't bother making a /tmp copy of the local file.
	     */
	    static DocInfo temp;
	    copy_address(&temp, &newdoc);
	    set_address(&newdoc, links[curdoc.link].lname);
	    if (LYdownload_options(&newdoc.address,
				   links[curdoc.link].lname) < 0)
		copy_address(&newdoc, &temp);
	    else
		newdoc.internal_link = FALSE;
	    LYFreeDocInfo(&temp);
#endif /* DIRED_SUPPORT */

	} else if (LYIsUIPage(curdoc.address, UIP_HISTORY) &&
	    isLYNXHIST(links[curdoc.link].lname)) {
	    int number = atoi(links[curdoc.link].lname + LEN_LYNXHIST);
	    if (number >= nhist || number < 0) {
		HTUserMsg(NO_DOWNLOAD_SPECIAL);
		return 0;
	    }
	    if ((HDOC(number).post_data != NULL &&
		 HDOC(number).safe != TRUE) &&
		HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
		HTInfoMsg(CANCELLED);
		return 0;
	    }
	    /*
	     *  OK, we download from history page, restore URL from stack.
	     */
	    copy_address(&newdoc, &HDOC(number));
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
	    StrAllocCopy(newdoc.bookmark, HDOC(number).bookmark);
	    LYFreePostData(&newdoc);
	    if (HDOC(number).post_data)
		BStrCopy(newdoc.post_data,
			 HDOC(number).post_data);
	    if (HDOC(number).post_content_type)
		StrAllocCopy(newdoc.post_content_type,
			     HDOC(number).post_content_type);
	    newdoc.isHEAD = HDOC(number).isHEAD;
	    newdoc.safe = HDOC(number).safe;
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    LYUserSpecifiedURL = TRUE;
	    /*
	     *	Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;

	} else if (!strncmp(links[curdoc.link].lname, "data:", 5)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTAlert(UNSUPPORTED_DATA_URL);
	    }

	} else if (isLYNXCOOKIE(links[curdoc.link].lname) ||
		   isLYNXDIRED(links[curdoc.link].lname) ||
		   isLYNXDOWNLOAD(links[curdoc.link].lname) ||
		   isLYNXPRINT(links[curdoc.link].lname) ||
		   isLYNXOPTIONS(links[curdoc.link].lname) ||
		   isLYNXHIST(links[curdoc.link].lname) ||
		   /* handled above if valid - kw */
/* @@@@@@ should next two be downloadable? - kw */
		   isLYNXHIST(links[curdoc.link].lname) ||
		   isLYNXCFLAGS(links[curdoc.link].lname) ||
		   isLYNXEXEC(links[curdoc.link].lname) ||
		   isLYNXPROG(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_SPECIAL);

	} else if (isMAILTO_URL(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_MAILTO_LINK);

	/*
	 *  From here on we could have a remote host, so check if
	 *  that's allowed.
	 *
	 *  We copy all these checks from getfile() to LYK_DOWNLOAD
	 *  here because LYNXDOWNLOAD:// will NOT be pushing the
	 *  previous document into the history stack so preserve
	 *  getfile() from returning a wrong status (NULLFILE).
	 */
	} else if (local_host_only &&
		   !(LYisLocalHost(links[curdoc.link].lname) ||
		     LYisLocalAlias(links[curdoc.link].lname))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	} else {   /* Not a forms, options or history link */
	    /*
	     *	Follow a normal link or anchor.  Note that
	     *	if it's an anchor within the same document,
	     *	entire document will be downloaded.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /*
	     *	Might be an internal link in the same doc from a
	     *	POST form.  If so, don't free the content. - kw
	     */
	    if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE)
#else
	    /*
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
	     */
	    if (are_different(&curdoc, &newdoc))
#endif /* TRACK_INTERNAL_LINKS */
	    {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
	    }
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    /*
	     *	Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NO_DOWNLOAD_CHOICE);
    }
    return 0;
}

PRIVATE void handle_LYK_DOWN_HALF ARGS2(
    int *,	old_c,
    int,	real_c)
{
    int i;

    if (more) {
	Newline += (display_lines/2);
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > display_lines/2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= (display_lines/2); i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

PRIVATE void handle_LYK_DOWN_LINK ARGS3(
    int *,	follow_col,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.link < (nlinks-1)) {	/* more links? */
	int newlink;

	if (*follow_col == -1) {
	    char *text = LYGetHiliteStr(curdoc.link, 0);
	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, 1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (more) {  /* next page */
	    Newline += (display_lines);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_BELOW);
	    return;
	}
    } else if (more) {	/* next page */
	    Newline += (display_lines);

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

PRIVATE void handle_LYK_DOWN_TWO ARGS2(
    int *,	old_c,
    int,	real_c)
{
    int i;

    if (more) {
	Newline += 2;
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > 2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= 2; i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

PRIVATE int handle_LYK_DWIMEDIT ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
#ifdef TEXTAREA_AUTOEXTEDIT
    /*
     *  If we're in a forms TEXTAREA, invoke the editor on *its*
     *  contents, rather than attempting to edit the html source
     *  document.  KED
     */
    if (nlinks > 0  &&
	links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
	*cmd = LYK_EDIT_TEXTAREA;
	return 2;
    }

    /*
     *  If we're in a forms TEXT type, tell user the request
     *  is bogus (though in reality, without this trap, if the
     *  document with the TEXT field is local, the editor *would*
     *  be invoked on the source .html file; eg, the o(ptions)
     *  form tempfile).
     *
     *  [This is done to avoid possible user confusion, due to
     *   auto invocation of the editor on the TEXTAREA's contents
     *   via the above if() statement.]
     */
    if (nlinks > 0 &&
	links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXT_TYPE)       {
	HTUserMsg (CANNOT_EDIT_FIELD);
	return 1;
    }

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
	return 1;
    }
#endif /* TEXTAREA_AUTOEXTEDIT */
    return 0;
}

PRIVATE int handle_LYK_ECGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 *  Go to not allowed. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 *  Disallow editing of File Management URLs. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */

    /*
     *	Save the current user_input_buffer string,
     *	and load the current document's address.
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      curdoc.address,
	      (MAX_LINE - 1));

    /*
     *	Warn the user if the current document has POST
     *	data associated with it. - FM
     */
    if (curdoc.post_data)
	HTAlert(CURRENT_DOC_HAS_POST_DATA);

    /*
     *	Offer the current document's URL for editing. - FM
     */
    _statusline(EDIT_CURDOC_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer, curdoc.address)) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}

PRIVATE void handle_LYK_EDIT ARGS2(
    int *,	old_c,
    int,	real_c)
{
#ifdef DIRED_SUPPORT
    char *cp;
    char *tp = NULL;
    struct stat dir_info;
#endif /* DIRED_SUPPORT */

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_DISABLED);
	}
    } else

#ifdef DIRED_SUPPORT
    /*
     *	Allow the user to edit the link rather
     *	than curdoc in edit mode.
     */
    if (lynx_edit_mode &&
	editor && *editor != '\0' && !no_dired_support) {
	if (nlinks > 0) {
	    cp = links[curdoc.link].lname;
	    if (is_url(cp) == FILE_URL_TYPE) {
		cp = HTfullURL_toFile(cp);
		StrAllocCopy(tp, cp);
		FREE(cp);

		if (stat(tp, &dir_info) == -1) {
		    HTAlert(NO_STATUS);
		} else {
		    if (S_ISREG(dir_info.st_mode)) {
			StrAllocCopy(tp, links[curdoc.link].lname);
			HTUnEscapeSome(tp, "/");
			if (edit_current_file(tp, curdoc.link, Newline)) {
			    DIRED_UNCACHE_1;
			    move_address(&newdoc, &curdoc);
#ifdef NO_SEEK_OLD_POSITION
			    /*
			     *	Go to top of file.
			     */
			    newdoc.line = 1;
			    newdoc.link = 0;
#else
			    /*
			     *	Seek old position,
			     *	which probably changed.
			     */
			    newdoc.line = curdoc.line;
			    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
			    LYclear();  /* clear the screen */
			}
		    }
		}
		FREE(tp);
	    }
	}
    } else
#endif /* DIRED_SUPPORT */
    if (editor && *editor != '\0') {
	if (edit_current_file(newdoc.address, curdoc.link, Newline)) {
	    HTuncache_current_document();
	    LYforce_no_cache = TRUE;  /*force reload of document */
	    free_address(&curdoc); /* so it doesn't get pushed */
#ifdef NO_SEEK_OLD_POSITION
	    /*
	     *	Go to top of file.
	     */
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    /*
	     *	Seek old position, which probably changed.
	     */
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
	    LYclear();  /* clear the screen */
	}

    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
}

PRIVATE void handle_LYK_DWIMHELP ARGS1(
    CONST char **,	cshelpfile)
{
    /*
     *  Currently a help file different from the main
     *  'helpfile' is shown only if current link is a
     *  text input form field. - kw
     */
    if (curdoc.link >= 0 && curdoc.link < nlinks &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	!links[curdoc.link].l_form->disabled &&
	F_TEXTLIKE(links[curdoc.link].l_form->type)) {
	*cshelpfile = LYLineeditHelpURL();
    }
}

PRIVATE void handle_LYK_EDIT_TEXTAREA ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    int n;

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
    } else if (!editor || *editor == '\0') {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
    /*
     *  See if the current link is in a form TEXTAREA.
     */
    else if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {

	/* stop screen */
	stop_curses();

	n = HText_ExtEditForm (&links[curdoc.link]);

	/*
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st trailing blank line in
	 *	  the now edited TEXTAREA.  If the target line/
	 *	  anchor requires us to scroll up/down, position
	 *	  the target in the approximate center of the
	 *	  screen.
	 */

	/* curdoc.link += n;*/	/* works, except for page crossing, */
				/* damnit; why is nothing ever easy */

	/* start screen */
	start_curses();
	*refresh_screen = TRUE;

    } else {

	HTInfoMsg (NOT_IN_TEXTAREA_NOEDIT);
    }
}

PRIVATE int handle_LYK_ELGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 *  Go to not allowed. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
    if (!(nlinks > 0 && curdoc.link > -1) ||
	(links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	 links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE)) {
	/*
	 *  No links on page, or not a normal link
	 *  or form submit button. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	}
	return 0;
    }
    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
	(!links[curdoc.link].l_form->submit_action ||
	 *links[curdoc.link].l_form->submit_action == '\0')) {
	/*
	 *  Form submit button with no ACTION defined. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_FORM_ACTION);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (isLYNXDIRED(links[curdoc.link].lname) ||
	LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 *  Disallow editing of File Management URLs. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */

    /*
     *	Save the current user_input_buffer string,
     *	and load the current link's address. - FM
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
					?
    links[curdoc.link].l_form->submit_action : links[curdoc.link].lname),
	      (MAX_LINE - 1));

    /*
     *	Offer the current link's URL for editing. - FM
     */
    _statusline(EDIT_CURLINK_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer,
	       ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
			? links[curdoc.link].l_form->submit_action
			: links[curdoc.link].lname))) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}

#ifdef USE_EXTERNALS
PRIVATE void handle_LYK_EXTERN_LINK ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL))
    {
	run_external(links[curdoc.link].lname, FALSE);
	*refresh_screen = TRUE;
    }
}

PRIVATE void handle_LYK_EXTERN_PAGE ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if (curdoc.address != NULL)
    {
	run_external(curdoc.address, FALSE);
	*refresh_screen = TRUE;
    }
}
#endif

PRIVATE BOOLEAN handle_LYK_FASTBACKW_LINK ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
    int samepage = 0, nextlink = curdoc.link;
    int res;

    if (nlinks > 1) {

	/*
	 *  If in textarea, move to first link or textarea group
	 *  before it if there is one on this screen. - kw
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link > 0 &&
		!(links[0].type == WWW_FORM_LINK_TYPE &&
		  links[0].l_form->type == F_TEXTAREA_TYPE &&
		  links[0].l_form->number == thisgroup &&
		  sametext(links[0].l_form->name, thisname))) {
		do nextlink--;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;

	    } else if (!more && Newline == 1 &&
		       (links[0].type == WWW_FORM_LINK_TYPE &&
			links[0].l_form->type == F_TEXTAREA_TYPE &&
			links[0].l_form->number == thisgroup &&
			sametext(links[0].l_form->name, thisname)) &&
		       !(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks-1].l_form->type == F_TEXTAREA_TYPE &&
			 links[nlinks-1].l_form->number == thisgroup &&
			 sametext(links[nlinks-1].l_form->name, thisname))) {
		nextlink = nlinks - 1;
		samepage = 1;

	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link > 0) {
	    nextlink--;
	    samepage = 1;
	} else if (!more && Newline == 1) {
	    nextlink = nlinks - 1;
	    samepage = 1;
	}
    }
    if (samepage) {
	/*
	 *  If the link as determined so far is part of a
	 *  group of textarea fields, try to use the first
	 *  of them that's on the screen instead. - kw
	 */
	if (nextlink > 0 &&
	    links[nextlink].type == WWW_FORM_LINK_TYPE &&
	    links[nextlink].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[nextlink].l_form->number;
	    char *thisname = links[nextlink].l_form->name;
	    if (links[0].type == WWW_FORM_LINK_TYPE &&
		links[0].l_form->type == F_TEXTAREA_TYPE &&
		links[0].l_form->number == thisgroup &&
		sametext(links[0].l_form->name, thisname)) {
		nextlink = 0;
	    } else
		while
		    (nextlink > 1 &&
		     links[nextlink-1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink-1].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink-1].l_form->number == thisgroup &&
		     sametext(links[nextlink-1].l_form->name, thisname)) {
		    nextlink--;
		}
	}
	set_curdoc_link(nextlink);
	return FALSE;		/* and we are done. */

    } else if (Newline > 1 &&	/* need a previous page */
	       (res = HTGetLinkOrFieldStart(curdoc.link,
					    &Newline, &newdoc.link,
					    -1, TRUE)) != NO) {
	if (res == LINK_DO_ARROWUP) {
	    /*
	     *  It says we should use the normal PREV_LINK
	     *  mechanism, so we'll do that. - kw
	     */
	    if (nlinks > 0)
		curdoc.link = 0;
	    *cmd = LYK_PREV_LINK;
	    return TRUE;
	}
	Newline++;	/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_ABOVE);
    }
    return FALSE;
}

PRIVATE void handle_LYK_FASTFORW_LINK ARGS2(
    int *,	old_c,
    int,	real_c)
{
    int samepage = 0, nextlink = curdoc.link;

    if (nlinks > 1) {

	/*
	 *  If in textarea, move to first link or field
	 *  after it if there is one on this screen. - kw
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link < nlinks-1 &&
		!(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks-1].l_form->type == F_TEXTAREA_TYPE &&
		  links[nlinks-1].l_form->number == thisgroup &&
		  sametext(links[nlinks-1].l_form->name, thisname))) {
		do nextlink++;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;
	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link < nlinks-1) {
	    nextlink++;
	    samepage = 1;
	} else if (!more && Newline == 1 && curdoc.link > 0) {
	    nextlink = 0;
	    samepage = 1;
	}
    }
    if (samepage) {
	set_curdoc_link(nextlink);
	return;		/* and we are done. */

    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
	set_curdoc_link(0);

    } else if (more &&	/* need a later page */
	       HTGetLinkOrFieldStart(curdoc.link,
				     &Newline, &newdoc.link,
				     1, TRUE) != NO) {
	Newline++;	/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_BELOW);
    }
    return;
}

PRIVATE void handle_LYK_FIRST_LINK NOARGS
{
    int i = curdoc.link;

    for (;;) {
	if (--i < 0
	 || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i + 1);
	    break;
	}
    }
}

PRIVATE BOOLEAN handle_LYK_GOTO ARGS9(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	recall,
    int *,	URLTotal,
    int *,	URLNum,
    BOOLEAN *,	FirstURLRecall,
    int *,	old_c,
    int,	real_c)
{

    if (no_goto && !LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return FALSE;
    }

    StrAllocCopy(*old_user_input, user_input_buffer);
    if (!goto_buffer)
	*user_input_buffer = '\0';

    *URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
    if (goto_buffer && *user_input_buffer) {
	*recall = ((*URLTotal > 1) ? RECALL_URL : NORECALL);
	*URLNum = 0;
	*FirstURLRecall = FALSE;
    } else {
	*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
	*URLNum = *URLTotal;
	*FirstURLRecall = TRUE;
    }

    /*
     *	Ask the user.
     */
    _statusline(URL_TO_OPEN);
    if ((*ch = LYgetstr(user_input_buffer, VISIBLE,
		       MAX_LINE, *recall)) < 0 ) {
	/*
	 *  User cancelled the Goto via ^G.
	 *  Restore user_input_buffer and break. - FM
	 */
	LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	FREE(*old_user_input);
	HTInfoMsg(CANCELLED);
	return FALSE;
    }
    return TRUE;
}

PRIVATE void handle_LYK_GROW_TEXTAREA ARGS1(
    BOOLEAN *,	refresh_screen)
{
    /*
     *  See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {

	HText_ExpandTextarea (&links[curdoc.link], TEXTAREA_EXPAND_SIZE);

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg (NOT_IN_TEXTAREA);
    }
}

PRIVATE BOOLEAN handle_LYK_HEAD ARGS1(
    int *,	cmd)
{
    int c;

    if (nlinks > 0 &&
	(links[curdoc.link].type         != WWW_FORM_LINK_TYPE ||
	 links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE)) {
	/*
	 * We have links, and the current link is a normal link or a form's
	 * submit button.  - FM
	 */
	_statusline(HEAD_D_L_OR_CANCEL);
	c = LYgetch_single();
	if (c == 'D') {
	    char *scheme = !isLYNXIMGMAP(curdoc.address)
			 ? curdoc.address
			 : curdoc.address + LEN_LYNXIMGMAP;
	    if (LYCanDoHEAD(scheme) != TRUE) {
		HTUserMsg(DOC_NOT_HTTP_URL);
	    } else {
		/*
		 * Check if this is a reply from a POST, and if so, seek
		 * confirmation if the safe element is not set.  - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
		    HTInfoMsg(CANCELLED);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HTuncache_current_document();
			free_address(&curdoc);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
		    }
		}
	    }
	} else if (c == 'L') {
	    if (links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		strncmp(links[curdoc.link].lname, "http", 4) &&
		strncmp(links[curdoc.link].lname,
			"LYNXIMGMAP:http", 15) &&
		LYCanDoHEAD(links[curdoc.link].lname) != TRUE &&
		(links[curdoc.link].type != WWW_INTERN_LINK_TYPE ||
		 !curdoc.address ||
		 strncmp(curdoc.address, "http", 4))) {
		HTUserMsg(LINK_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->disabled) {
		HTUserMsg(FORM_ACTION_DISABLED);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       !isLYNXCGI(links[curdoc.link].l_form->submit_action) &&
		       strncmp(links[curdoc.link].l_form->submit_action,
							 "http", 4)) {
		HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->submit_method ==
						  URL_POST_METHOD &&
		       HTConfirm(CONFIRM_POST_LINK_HEAD) == FALSE) {
		HTInfoMsg(CANCELLED);
	    } else {
		HEAD_request = TRUE;
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return TRUE;
	    }
	}
    } else {
	/*
	 * We can offer only this document for a HEAD request.  Check if this
	 * is a reply from a POST, and if so, seek confirmation if the safe
	 * element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
	    HTInfoMsg(CANCELLED);
	} else {
	    if (nlinks > 0) {
		/*
		 * The current link is a non-submittable form link, so prompt
		 * the user to make it clear that the HEAD request would be for
		 * the current document, not the form link.  - FM
		 */
		_statusline(HEAD_D_OR_CANCEL);
		c = LYgetch_single();
	    } else {
		/*
		 * No links, so we can just assume that the user wants a HEAD
		 * request for the current document.  - FM
		 */
		c = 'D';
	    }
	    if (c == 'D') {
		char *scheme = !isLYNXIMGMAP(curdoc.address)
			     ? curdoc.address
			     : curdoc.address + LEN_LYNXIMGMAP;
		/*
		 * The user didn't cancel, so check if a HEAD request is
		 * appropriate for the current document.  - FM
		 */
		if (LYCanDoHEAD(scheme) != TRUE) {
		    HTUserMsg(DOC_NOT_HTTP_URL);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HTuncache_current_document();
			free_address(&curdoc);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
d789 1
a789 6
		}
	    }
	}
    }
    return FALSE;
}
d791 80
a870 27
PRIVATE void handle_LYK_HELP ARGS1(
    CONST char **,	cshelpfile)
{
    if (*cshelpfile == NULL)
	*cshelpfile = helpfile;
    if (!STREQ(curdoc.address, *cshelpfile)) {
	/*
	 *  Set the filename.
	 */
	set_address(&newdoc, *cshelpfile);
	/*
	 *  Make a name for this help file.
	 */
	StrAllocCopy(newdoc.title, gettext("Help Screen"));
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    }
    *cshelpfile = NULL;		/* reset pointer - kw */
}

PRIVATE void handle_LYK_HISTORICAL NOARGS
{
#ifdef SOURCE_CACHE
    if (!HTcan_reparse_document()) {
d872 18
a889 31
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HTuncache_current_document();
	move_address(&newdoc, &curdoc);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
#ifdef SOURCE_CACHE
    } /* end if no bypass */
#endif
    historical_comments = !historical_comments;
    if (minimal_comments) {
	HTAlert(historical_comments ?
		HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
    } else {
	HTAlert(historical_comments ?
		HISTORICAL_ON_VALID_OFF : HISTORICAL_OFF_VALID_ON);
    }
#ifdef SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}
d891 21
a911 19
PRIVATE BOOLEAN handle_LYK_HISTORY ARGS1(
    BOOLEAN,	ForcePush)
{
    if (curdoc.title && !LYIsUIPage(curdoc.address, UIP_HISTORY)) {
	/*
	 *  Don't do this if already viewing history page.
	 *
	 *  Push the current file so that the history list
	 *  contains the current file for printing purposes.
	 *  Pop the file afterwards to prevent multiple copies.
	 */
	if (TRACE && !LYUseTraceLog && LYCursesON) {
	    LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
	    LYaddstr("\n");
#endif /* USE_SLANG */
	    LYrefresh();
	}
	LYpush(&curdoc, ForcePush);
d913 15
a927 16
	/*
	 *  Print history options to file.
	 */
	if (showhistory(&newdoc.address) < 0) {
	    LYpop(&curdoc);
	    return TRUE;
	}
	LYRegisterUIPage(newdoc.address, UIP_HISTORY);
	StrAllocCopy(newdoc.title, HISTORY_PAGE_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	newdoc.link = 1; /*@@@@@@ bypass "recent statusline messages" link */
	free_address(&curdoc);  /* so it doesn't get pushed */
d929 9
a937 7
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
	return TRUE;
    } /* end if strncmp */
    return FALSE;
}
d939 11
a949 4
PRIVATE BOOLEAN handle_LYK_IMAGE_TOGGLE ARGS1(
    int *,	cmd)
{
    clickable_images = !clickable_images;
d951 7
a957 4
    HTUserMsg(clickable_images ?
	     CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
    return reparse_or_reload(cmd);
}
d959 14
a972 8
PRIVATE void handle_LYK_INDEX ARGS2(
    int *,	old_c,
    int,	real_c)
{
    /*
     *	Make sure we are not in the index already.
     */
    if (!STREQ(curdoc.address, indexfile)) {
d974 3
a976 4
	if (indexfile[0]=='\0') { /* no defined index */
		if (*old_c != real_c)	{
		    *old_c = real_c;
		    HTUserMsg(NO_INDEX_FILE);
a977 5

	} else {
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE) {
		last_kcode = NOKANJI;	/* AUTO */
a978 11
#endif
	    set_address(&newdoc, indexfile);
	    StrAllocCopy(newdoc.title, gettext("System Index")); /* name it */
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	} /* end else */
    }  /* end if */
}
a979 17
PRIVATE void handle_LYK_INDEX_SEARCH ARGS4(
    BOOLEAN *,	force_load,
    BOOLEAN,	ForcePush,
    int *,	old_c,
    int,	real_c)
{
    if (is_www_index) {
	/*
	 *  Perform a database search.
	 *
	 *  do_www_search will try to go out and get the document.
	 *  If it returns TRUE, a new document was returned and is
	 *  named in the newdoc.address.
	 */
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	if (do_www_search(&newdoc) == NORMAL) {
d981 1
a981 1
	     *	Yah, the search succeeded.
d983 11
a993 27
	    if (TRACE && !LYUseTraceLog && LYCursesON) {
		/*
		 *  Make sure cursor is down.
		 */
		LYHideCursor();
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
	    }
	    LYpush(&curdoc, ForcePush);
	    /*
	     *	Make the curdoc.address the newdoc.address so that
	     *	getfile doesn't try to get the newdoc.address.
	     *	Since we have already gotten it.
	     */
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type, curdoc.post_content_type);
	    newdoc.internal_link = FALSE;
	    curdoc.line = -1;
	    Newline = 0;
	} else if (use_this_url_instead != NULL) {
	    /*
	     *	Got back a redirecting URL.  Check it out.
	     */
	    HTUserMsg2 (WWW_USING_MESSAGE, use_this_url_instead);
d996 2
a997 1
	     *	Make a name for this URL.
d999 20
a1018 28
	    StrAllocCopy(newdoc.title,
			 "A URL specified by redirection");
	    set_address(&newdoc, use_this_url_instead);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(use_this_url_instead);
	    *force_load = TRUE;
	} else {
	    /*
	     *	Yuk, the search failed.  Restore the old file.
	     */
	    copy_address(&newdoc, &curdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type,
			 curdoc.post_content_type);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.isHEAD = curdoc.isHEAD;
	    newdoc.safe = curdoc.safe;
	    newdoc.internal_link = curdoc.internal_link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NOT_ISINDEX);
    }
}
a1019 30
PRIVATE BOOLEAN handle_LYK_INFO ARGS1(
    int *,	cmd)
{
    /*
     *	Don't do if already viewing info page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_SHOWINFO)) {
	if (do_change_link() != -1
	 && LYShowInfo(&curdoc, HText_getNumOfLines(),
		       &newdoc, owner_address) >= 0) {
	    LYRegisterUIPage(newdoc.address, UIP_SHOWINFO);
	    StrAllocCopy(newdoc.title, SHOWINFO_TITLE);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYforce_no_cache = TRUE;
	    if (LYValidate || check_realm)
		LYPermitURL = TRUE;
	}
    } else {
	/*
	 *  If already in info page, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}
d1021 8
a1028 4
PRIVATE BOOLEAN handle_LYK_INLINE_TOGGLE ARGS1(
    int *,	cmd)
{
    pseudo_inline_alts = !pseudo_inline_alts;
d1030 1
a1030 4
    HTUserMsg(pseudo_inline_alts ?
	      PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
    return reparse_or_reload(cmd);
}
d1032 12
a1043 6
PRIVATE void handle_LYK_INSERT_FILE ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    int n;
d1045 1
a1045 5
    /*
     *  See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d1047 5
a1051 20
	/*
	 *  Reject attempts to use this for gaining access to
	 *  local files when such access is restricted:
	 *  if no_file_url was set via the file_url restriction,
	 *  if no_goto_file was set for the anonymous account,
	 *  or if HTDirAccess was set to HT_DIR_FORBID or
	 *  HT_DIR_SELECTIVE via the -nobrowse or -selective
	 *  switches, it is assumed that inserting files or
	 *  checking for existence of files needs to be denied. - kw
	 */
	if (no_file_url || no_goto_file ||
	    HTDirAccess == HT_DIR_FORBID ||
	    HTDirAccess == HT_DIR_SELECTIVE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		if (no_goto_file)
		    HTUserMsg2(GOTO_XXXX_DISALLOWED, STR_FILE_URL);
		else
		    HTUserMsg(NOAUTH_TO_ACCESS_FILES);
		HTInfoMsg(FILE_INSERT_CANCELLED);
d1053 1
a1053 1
	    return;
a1055 2
	n = HText_InsertFile (&links[curdoc.link]);

d1057 2
a1058 10
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st line following the text
	 *	  that was inserted.  If the target line/anchor
	 *	  requires us to scroll up/down, position the
	 *	  target in the approximate center of the screen.
	 *
	 *  [Current behavior leaves cursor on the same line relative
	 *   to the start of the TEXTAREA that it was on before the
	 *   insertion.  This is the same behavior that occurs with
	 *   (my) editor, so this TODO will stay unimplemented.]
d1060 14
d1075 8
a1082 1
	*refresh_screen = TRUE;
d1084 5
a1088 1
    } else {
d1090 35
a1124 3
	HTInfoMsg (NOT_IN_TEXTAREA);
    }
}
d1126 65
a1190 54
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
PRIVATE void handle_LYK_INSTALL NOARGS
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support)
	local_install(NULL, links[curdoc.link].lname, &newdoc.address);
}
#endif

PRIVATE BOOLEAN handle_LYK_JUMP ARGS10(
    int,	c,
    char *,	user_input_buffer,
    char **,	old_user_input GCC_UNUSED,
    int *,	recall GCC_UNUSED,
    BOOLEAN *,	FirstURLRecall GCC_UNUSED,
    int *,	URLNum GCC_UNUSED,
    int *,	URLTotal GCC_UNUSED,
    int *,	ch GCC_UNUSED,
    int *,	old_c,
    int,	real_c)
{
    char *ret;

    if (no_jump || JThead == NULL) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    if (no_jump)
		HTUserMsg(JUMP_DISALLOWED);
	    else
		HTUserMsg(NO_JUMPFILE);
	}
    } else {
	LYJumpFileURL = TRUE;
	if ((ret = LYJump(c)) != NULL) {
#ifdef PERMIT_GOTO_FROM_JUMP
	    if (!strncasecomp(ret, "Go ", 3)) {
		LYJumpFileURL = FALSE;
		StrAllocCopy(*old_user_input, user_input_buffer);
		*URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
		*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
		*URLNum = *URLTotal;
		*FirstURLRecall = TRUE;
		if (!strcasecomp(ret, "Go :")) {
		    if (recall) {
			*ch = UPARROW;
			return TRUE;
		    }
		    FREE(*old_user_input);
		    HTUserMsg(NO_RANDOM_URLS_YET);
		    return FALSE;
		}
		ret = HTParse((ret+3), startfile, PARSE_ALL);
		LYstrncpy(user_input_buffer, ret, MAX_LINE - 1);
		FREE(ret);
		return TRUE;
a1191 16
#endif /* PERMIT_GOTO_FROM_JUMP */
	    ret = HTParse(ret, startfile, PARSE_ALL);
	    if (!LYTrimStartfile(ret)) {
		LYRemoveBlanks(user_input_buffer);
	    }
	    set_address(&newdoc, ret);
	    StrAllocCopy(lynxjumpfile, ret);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(ret);
	    LYUserSpecifiedURL = TRUE;
	} else {
	    LYJumpFileURL = FALSE;
a1192 3
    }
    return FALSE;
}
d1194 1
a1194 15
PRIVATE void handle_LYK_KEYMAP ARGS4(
    BOOLEAN *,	vi_keys_flag,
    BOOLEAN *,	emacs_keys_flag,
    int *,	old_c,
    int,	real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	set_address(&newdoc, STR_LYNXKEYMAP);
	StrAllocCopy(newdoc.title, CURRENT_KEYMAP_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
d1196 5
a1200 2
	 *  If vi_keys changed, the keymap did too,
	 *  so force no cache, and reset the flag. - FM
d1202 15
a1216 5
	if (*vi_keys_flag != vi_keys ||
	    *emacs_keys_flag != emacs_keys) {
	    LYforce_no_cache = TRUE;
	    *vi_keys_flag = vi_keys;
	    *emacs_keys_flag = emacs_keys;
a1217 33
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	/*
	 *  Remember whether we are in dired menu
	 *  so we can display the right keymap.
	 */
	if (!no_dired_support) {
	    prev_lynx_edit_mode = lynx_edit_mode;
	}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	LYforce_no_cache = TRUE;
    }
}

PRIVATE void handle_LYK_LAST_LINK NOARGS
{
    int i = curdoc.link;

    for (;;) {
	if (++i >= nlinks
	 || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i - 1);
	    break;
	}
    }
}

PRIVATE void handle_LYK_LEFT_LINK NOARGS
{
    if (curdoc.link>0 &&
		links[curdoc.link].ly == links[curdoc.link-1].ly) {
	set_curdoc_link(curdoc.link-1);
    }
}
a1218 8
PRIVATE BOOLEAN handle_LYK_LIST ARGS1(
    int *,     cmd)
{
    /*
     *	Don't do if already viewing list page.
     */
    if (!strcmp(NonNull(curdoc.title), LIST_PAGE_TITLE) &&
	LYIsUIPage(curdoc.address, UIP_LIST_PAGE)) {
d1220 4
a1223 1
	 *  Already viewing list page, so get out.
d1225 2
a1226 3
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
d1228 5
a1232 51
    /*
     *	Print list page to file.
     */
    if (showlist(&newdoc, TRUE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, LIST_PAGE_TITLE);
    /*
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}

PRIVATE void handle_LYK_MAIN_MENU ARGS2(
    int *,	old_c,
    int,	real_c)
{
    /*
     *	If its already the homepage then don't reload it.
     */
    if (!STREQ(curdoc.address,homepage)) {

	if (HTConfirmDefault(CONFIRM_MAIN_SCREEN, NO) == YES) {
	    set_address(&newdoc, homepage);
	    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYhighlight(OFF, curdoc.link, prev_target);
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
	    }
#endif /* DIRED_SUPPORT */
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(IN_MAIN_SCREEN);
	}
    }
}
a1233 20
PRIVATE void handle_LYK_MINIMAL NOARGS
{
    if (!historical_comments) {
#ifdef SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
	/*
	 *  Check if this is a reply from a POST, and if so,
	 *  seek confirmation of reload if the safe element
	 *  is not set. - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
a1234 14
#ifdef SOURCE_CACHE
    } /* end if no bypass */
#endif
    }
    minimal_comments = !minimal_comments;
    if (!historical_comments) {
	HTAlert(minimal_comments ?
		MINIMAL_ON_IN_EFFECT : MINIMAL_OFF_VALID_ON);
    } else {
	HTAlert(minimal_comments ?
		MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
    }
#ifdef SOURCE_CACHE
    (void)reparse_document();
a1235 2
    return;
}
a1236 6
#if defined(DIRED_SUPPORT)
PRIVATE void handle_LYK_MODIFY ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int ret;
d1238 15
a1252 17
	ret = local_modify(&curdoc, &newdoc.address);
	if (ret == PERMIT_FORM_RESULT) { /* Permit form thrown up */
	    *refresh_screen = TRUE;
	} else if (ret) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    LYclear();
	}
    }
}
d1255 17
a1271 9
#ifdef EXP_NESTED_TABLES
PRIVATE BOOLEAN handle_LYK_NESTED_TABLES ARGS1(
    int *,	cmd)
{
    nested_tables = !nested_tables;
    HTUserMsg(nested_tables ? NESTED_TABLES_ON : NESTED_TABLES_OFF);
    return reparse_or_reload(cmd);
}
#endif
d1273 7
a1279 64
PRIVATE BOOLEAN handle_LYK_OPTIONS ARGS2(
    int *,	cmd,
    BOOLEAN *,	refresh_screen)
{
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions) {
	BOOLEAN LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
	BOOLEAN LYSelectPopups_flag = LYSelectPopups;
	BOOLEAN verbose_img_flag = verbose_img;
	BOOLEAN keypad_mode_flag = (BOOL) keypad_mode;
	BOOLEAN show_dotfiles_flag = show_dotfiles;
	BOOLEAN user_mode_flag = (BOOL) user_mode;
	int CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
	int CurrentCharSet_flag = current_char_set;
	int HTfileSortMethod_flag = HTfileSortMethod;
	char *CurrentUserAgent = NULL;
	char *CurrentNegoLanguage = NULL;
	char *CurrentNegoCharset = NULL;
	StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : ""));
	StrAllocCopy(CurrentNegoLanguage, (language ?
					   language : ""));
	StrAllocCopy(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""));

	LYoptions(); /** do the old-style options stuff **/

	if (keypad_mode_flag != keypad_mode ||
	    (user_mode_flag != user_mode &&
	     (user_mode_flag == NOVICE_MODE ||
	      user_mode == NOVICE_MODE)) ||
	    (((HTfileSortMethod_flag != HTfileSortMethod) ||
	      (show_dotfiles_flag != show_dotfiles)) &&
	     (isFILE_URL(curdoc.address) ||
	      isFTP_URL(curdoc.address))) ||
	    CurrentCharSet_flag != current_char_set ||
	    CurrentAssumeCharSet_flag != UCLYhndl_for_unspec ||
	    verbose_img_flag != verbose_img ||
	    LYUseDefaultRawMode_flag != LYUseDefaultRawMode ||
	    LYSelectPopups_flag != LYSelectPopups ||
	    ((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
	      strcmp(CurrentNegoLanguage, (language ?
					   language : "")) ||
	      strcmp(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""))) &&
	     (!strncmp(curdoc.address, "http", 4) ||
	      isLYNXCGI(curdoc.address)))) {

	    BOOLEAN canreparse_post = FALSE;

	    /*
	     *  Check if this is a reply from a POST, and if so,
	     *  seek confirmation of reload if the safe element
	     *  is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
#ifdef SOURCE_CACHE
		(!(canreparse_post = HTcan_reparse_document())) &&
#endif
		confirm_post_resub(curdoc.address, curdoc.title,
				   2, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
d1281 8
a1288 17
		copy_address(&newdoc, &curdoc);
		if (((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
		      strcmp(CurrentNegoLanguage, NonNull(language)) ||
		      strcmp(CurrentNegoCharset, NonNull(pref_charset))) &&
		     (strncmp(curdoc.address, "http", 4) == 0 ||
		      !isLYNXCGI(curdoc.address) == 0))) {
		    /*
		     *  An option has changed which may influence
		     *  content negotiation, and the resource is from
		     *  a http or https or lynxcgi URL (the only protocols
		     *  which currently do anything with this information).
		     *  Set reloading = TRUE so that proxy caches will be
		     *  flushed, which is necessary until the time when
		     *  all proxies understand HTTP 1.1 Vary: and all
		     *  Servers properly use it...	Treat like
		     *  case LYK_RELOAD (see comments there). - KW
d1290 1
a1290 26
		    reloading = TRUE;
		}
		if (HTisDocumentSource()) {
		    srcmode_for_next_retrieval(1);
		}
#ifdef SOURCE_CACHE
		if (reloading == FALSE) {
		    /* one more attempt to be smart enough: */
		    if (reparse_document()) {
			FREE(CurrentUserAgent);
			FREE(CurrentNegoLanguage);
			FREE(CurrentNegoCharset);
			return FALSE;
		    }
		}
#endif
		if (canreparse_post &&
		    confirm_post_resub(curdoc.address, curdoc.title,
				       2, 1) == FALSE) {
		    if (HTisDocumentSource()) {
			srcmode_for_next_retrieval(0);
		    }
		    FREE(CurrentUserAgent);
		    FREE(CurrentNegoLanguage);
		    FREE(CurrentNegoCharset);
		    return FALSE;
a1291 12

		HEAD_request = HTLoadedDocumentIsHEAD();
		HTuncache_current_document();
#ifdef NO_ASSUME_SAME_DOC
		newdoc.line = 1;
		newdoc.link = 0;
#else
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
		LYforce_no_cache = TRUE;
		free_address(&curdoc); /* So it doesn't get pushed. */
a1292 25
	}
	FREE(CurrentUserAgent);
	FREE(CurrentNegoLanguage);
	FREE(CurrentNegoCharset);
	*refresh_screen = TRUE; /* to repaint screen */
	return FALSE;
    } /* end if !LYUseFormsOptions */
#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS
    /*
     * Generally stolen from LYK_COOKIE_JAR.  Options menu handling is
     * done in postoptions(), called from getfile() currently.
     *
     * postoptions() is also responsible for reloading the document
     * before the 'options menu' but only when (a few) important
     * options were changed.
     *
     * It is critical that post_data is freed here since the
     * submission of changed options is done via the same protocol as
     * LYNXOPTIONS:
     */
    /*
     *	Don't do if already viewing options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU)) {
d1294 4
a1297 12
	set_address(&newdoc, "LYNXOPTIONS:/");
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	/* change to 'if (check_realm && !LYValidate)' and
	   make change near top of getfile to forbid
	   using forms options menu with -validate:  - kw */
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
a1298 19
   } else {
	/*
	 *  If already in the options menu, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
#endif /* !NO_OPTION_FORMS */
    return FALSE;
}

PRIVATE void handle_NEXT_DOC NOARGS
{
    if (LYhist_next(&curdoc, &newdoc)) {
	free_address(&curdoc);	/* avoid push */
	return;
    }
    HTUserMsg(gettext("No next document present"));
}
a1299 8
PRIVATE void handle_LYK_NEXT_LINK ARGS3(
    int,	c,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.link < nlinks-1) {	/* next link */
	LYhighlight(OFF, curdoc.link, prev_target);
#ifdef FASTTAB
d1301 1
a1301 1
	 *  Move to different textarea if TAB in textarea.
d1303 7
a1309 15
	if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
	    c=='\t') {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    do curdoc.link++;
	    while ((curdoc.link < nlinks-1) &&
		   links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		   links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
		   links[curdoc.link].l_form->number == thisgroup &&
		   sametext(links[curdoc.link].l_form->name, thisname));
	} else {
	    curdoc.link++;
	}
d1311 3
a1313 8
	curdoc.link++;
#endif /* FASTTAB */
    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
	set_curdoc_link(0);
d1315 4
a1318 2
    } else if (more) {	/* next page */
	Newline += (display_lines);
d1320 4
a1323 5
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}
d1325 3
a1327 13
PRIVATE void handle_LYK_NEXT_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
{
    if (more) {
	Newline += display_lines;
    } else if (curdoc.link < nlinks-1) {
	set_curdoc_link(nlinks - 1);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}
a1328 17
PRIVATE BOOLEAN handle_LYK_NOCACHE ARGS2(
    int *,	old_c,
    int,	real_c)
{
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	    }
	    return FALSE;
	} else {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
a1329 11
    }
    return TRUE;
}

PRIVATE void handle_LYK_PREV_LINK ARGS3(
    int *,	arrowup,
    int	*,	old_c,
    int,	real_c)
{
    if (curdoc.link > 0) {	     /* previous link */
	set_curdoc_link(curdoc.link - 1);
a1330 2
    } else if (!more &&
	       curdoc.link==0 && Newline==1) { /* at the top of list */
d1332 1
a1332 3
	 *  If there is only one page of data and the user
	 *  goes off the top, just move the cursor to last link on
	 *  the page.
d1334 2
a1335 1
	set_curdoc_link(nlinks - 1);
a1336 1
    } else if (curdoc.line > 1) {	/* previous page */
d1338 3
a1340 1
	 *  Go back to the previous page.
d1342 2
a1343 9
	int scrollamount = (Newline > display_lines ?
				      display_lines : Newline - 1);
	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link == 0 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
d1345 1
a1345 1
	    *arrowup = TRUE;
d1348 118
a1465 5
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}
d1467 11
a1477 74
PRIVATE int handle_PREV_DOC ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
    if (nhist > 0) {  /* if there is anything to go back to */
	/*
	 *  Check if the previous document is a reply from a POST,
	 *  and if so, seek confirmation of resubmission if the safe
	 *  element is not set and the document is not still in the
	 *  cache or LYresubmit_posts is set.  If not confirmed and
	 *  it is not the startfile, pop it so we go to the yet
	 *  previous document, until we're OK or reach the startfile.
	 *  If we reach the startfile and its not OK or we don't get
	 *  confirmation, cancel. - FM
	 */
	DocAddress WWWDoc;
	HTParentAnchor *tmpanchor;
	HText *text;
	BOOLEAN conf = FALSE, first = TRUE;

	HTLastConfirmCancelled(); /* reset flag */
	while (nhist > 0) {
	    conf = FALSE;
	    if (HDOC(nhist - 1).post_data == NULL) {
		break;
	    }
	    WWWDoc.address = HDOC(nhist - 1).address;
	    WWWDoc.post_data = HDOC(nhist - 1).post_data;
	    WWWDoc.post_content_type =
			       HDOC(nhist - 1).post_content_type;
	    WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
	    WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
	    WWWDoc.safe = HDOC(nhist - 1).safe;
	    tmpanchor = HTAnchor_findAddress(&WWWDoc);
	    if (HTAnchor_safe(tmpanchor)) {
		break;
	    }
	    if (((text = (HText *)HTAnchor_document(tmpanchor)) == NULL &&
		 (isLYNXIMGMAP(WWWDoc.address) ||
		 (conf = confirm_post_resub(WWWDoc.address,
					    HDOC(nhist - 1).title,
					    0, 0))
		  == FALSE)) ||
		((LYresubmit_posts && !conf &&
		  (NONINTERNAL_OR_PHYS_DIFFERENT(
		      (DocInfo *)&history[(nhist - 1)],
		      &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT(
		       (DocInfo *)&history[(nhist - 1)],
		       &newdoc))) &&
		 !confirm_post_resub(WWWDoc.address,
				     HDOC(nhist - 1).title,
				     2, 2))) {
		if (HTLastConfirmCancelled()) {
		    if (!first && curdoc.internal_link)
			free_address(&curdoc);
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		}
		if (nhist == 1) {
		    HTInfoMsg(CANCELLED);
		    *old_c = 0;
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		} else {
		    HTUserMsg2(WWW_SKIP_MESSAGE, WWWDoc.address);
		    do {	/* Should be LYhist_prev when _next supports */
			LYpop(&curdoc);		/* skipping of forms */
		    } while (nhist > 1 && !are_different(
			(DocInfo *)&history[(nhist - 1)],
			&curdoc));
		    first = FALSE; /* have popped at least one */
		    continue;
d1481 3
a1483 4
		 *  Break from loop; if user just confirmed to
		 *  load again because document wasn't in cache,
		 *  set LYforce_no_cache to avoid unnecessary
		 *  repeat question down the road. - kw
d1485 17
a1501 3
		if (conf)
		    LYforce_no_cache = TRUE;
		break;
d1505 11
a1515 2
	if (!first)
	    curdoc.internal_link = FALSE;
d1517 1
d1519 2
a1520 1
	 *  Set newdoc.address to empty to pop a file.
d1522 68
a1589 9
	LYhist_prev_register(&curdoc);	/* Why not call _prev instead of zeroing address?  */
	free_address(&newdoc);
#ifdef DIRED_SUPPORT
	if (lynx_edit_mode) {
	    DIRED_UNCACHE_2;
	}
#endif /* DIRED_SUPPORT */
    } else if (child_lynx == TRUE) {
	return(1); /* exit on left arrow in main screen */
d1591 1
a1591 6
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(ALREADY_AT_FIRST);
    }
    return 0;
}
d1593 4
a1596 13
PRIVATE void handle_LYK_PREV_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	Newline -= display_lines;
    } else if (curdoc.link > 0) {
	set_curdoc_link(0);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}
d1598 1
a1598 12
PRIVATE void handle_LYK_PRINT ARGS3(
    BOOLEAN *,	ForcePush,
    int *,	old_c,
    int,	real_c)
{
    if (LYValidate) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(PRINT_DISABLED);
	}
	return;
    }
d1600 4
a1603 17
    /*
     *	Don't do if already viewing print options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)
     && print_options(&newdoc.address,
		      curdoc.address, HText_getNumOfLines()) >= 0) {
	LYRegisterUIPage(newdoc.address, UIP_PRINT_OPTIONS);
	StrAllocCopy(newdoc.title, PRINT_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	*ForcePush = TRUE;  /* see LYpush() and print_options() */
	if (check_realm)
	    LYPermitURL = TRUE;
    }
}
d1605 1
a1605 3
PRIVATE BOOLEAN handle_LYK_QUIT NOARGS
{
    int c;
d1607 8
a1614 18
    if (LYQuitDefaultYes == TRUE) {
	c = HTConfirmDefault(REALLY_QUIT, YES);
    } else {
	c = HTConfirmDefault(REALLY_QUIT, NO);
    }
    if (LYQuitDefaultYes == TRUE) {
	if (c != NO) {
	    return(TRUE);
	} else {
	    HTInfoMsg(NO_CANCEL);
	}
    } else if (c == YES) {
	return(TRUE);
    } else {
	HTInfoMsg(NO_CANCEL);
    }
    return FALSE;
}
d1616 6
a1621 13
PRIVATE BOOLEAN handle_LYK_RAW_TOGGLE ARGS1(
    int *,	cmd)
{
    if (HTLoadedDocumentCharset()) {
	HTUserMsg(gettext("charset for this document specified explicitly, sorry..."));
	return FALSE;
    } else {
	LYUseDefaultRawMode = (BOOL) !LYUseDefaultRawMode;
	HTUserMsg(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
	HTMLSetCharacterHandling(current_char_set);
	return reparse_or_reload(cmd);
    }
}
d1623 5
a1627 13
/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
PRIVATE void handle_LYK_RELOAD ARGS1(
    int,	real_cmd)
{
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }
d1629 17
a1645 3
    /*
     *	Check to see if should reload source, or load html
     */
d1647 124
a1770 5
    if (HTisDocumentSource()) {
	if ((forced_UCLYhdnl = HTMainText_Get_UCLYhndl()) >= 0)
	    force_old_UCLYhndl_on_reload = TRUE;
	srcmode_for_next_retrieval(1);
    }
d1772 39
a1810 32
    HEAD_request = HTLoadedDocumentIsHEAD();
    HTuncache_current_document();
#ifdef NO_ASSUME_SAME_DOC
    /*
     *	Don't assume the reloaded document will be the same. - FM
     */
    newdoc.line = 1;
    newdoc.link = 0;
#else
    /*
     *	Do assume the reloaded document will be the same. - FM
     *	(I don't remember all the reasons why we couldn't assume
     *	 this.	As the problems show up, we'll try to fix them,
     *	 or add warnings.  - FM)
     */
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
    free_address(&curdoc); /* so it doesn't get pushed */
#ifdef VMS
    lynx_force_repaint();
#endif /* VMS */
    /*
     *	Reload should force a cache refresh on a proxy.
     *	      -- Ari L. <luotonen@@dxcern.cern.ch>
     *
     *	-- but only if this was really a reload requested by
     *	the user, not if we jumped here to handle reloading for
     *	INLINE_TOGGLE, IMAGE_TOGGLE, RAW_TOGGLE, etc. - KW
     */
    if (real_cmd == LYK_RELOAD)
	reloading = TRUE;
d1812 26
a1837 2
    return;
}
d1839 6
a1844 44
#ifdef DIRED_SUPPORT
PRIVATE void handle_LYK_REMOVE ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int linkno = curdoc.link; /* may be changed in local_remove - kw */
	local_remove(&curdoc);
	if (LYAutoUncacheDirLists >= 1)
	    do_cleanup_after_delete();
	else if (curdoc.link != linkno)
	    *refresh_screen = TRUE;
    }
}
#endif /* DIRED_SUPPORT */

PRIVATE void handle_LYK_RIGHT_LINK NOARGS
{
    if (curdoc.link<nlinks-1 &&
		links[curdoc.link].ly == links[curdoc.link+1].ly) {
	set_curdoc_link(curdoc.link + 1);
    }
}

PRIVATE void handle_LYK_SHELL ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    if (!no_shell) {
	stop_curses();
	printf("%s\r\n", SPAWNING_MSG);
#if defined(__CYGWIN__)
	/* handling "exec $SHELL" does not work if $SHELL is null */
	if (LYGetEnv("SHELL") == NULL) {
	    Cygwin_Shell();
	} else
#endif
	LYSystem(LYSysShell());
	start_curses();
	*refresh_screen = TRUE;	/* for an HText_pageDisplay() */
    } else {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(SPAWNING_DISABLED);
a1845 2
    }
}
d1847 12
a1858 31
PRIVATE void handle_LYK_SOFT_DQUOTES NOARGS
{
#ifdef SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HTuncache_current_document();
	move_address(&newdoc, &curdoc);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
#ifdef SOURCE_CACHE
    } /* end if no bypass */
#endif
    soft_dquotes = !soft_dquotes;
    HTUserMsg(soft_dquotes ?
	      SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
#ifdef SOURCE_CACHE
    (void)reparse_document();
#endif
    return;
}
d1860 4
a1863 9
/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
PRIVATE void handle_LYK_SOURCE ARGS1(
    char **,	ownerS_address_p)
{
#ifdef SOURCE_CACHE
    BOOLEAN canreparse_post = FALSE;
d1865 11
a1875 4
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
#ifdef SOURCE_CACHE
	(!(canreparse_post = HTcan_reparse_document())) &&
d1877 1
a1877 14
	(curdoc.isHEAD ? HTConfirm(CONFIRM_POST_RESUBMISSION) :
	 confirm_post_resub(curdoc.address, curdoc.title, 1, 1)) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (HTisDocumentSource()) {
	srcmode_for_next_retrieval(-1);
    } else {
	if (HText_getOwner())
	    StrAllocCopy(*ownerS_address_p, HText_getOwner());
	LYUCPushAssumed(HTMainAnchor);
	srcmode_for_next_retrieval(1);
    }
d1880 15
a1894 15
    if (reparse_document()) {
	/*
	 * These normally get cleaned up after getfile() returns;
	 * since we're not calling getfile(), we have to clean them
	 * up ourselves.  -dsb
	 */
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    HTMark_asSource();
	psrc_view = FALSE;
#endif
	FREE(*ownerS_address_p);  /* not used with source_cache */
	LYUCPopAssumed();	/* probably a right place here */
	HTMLSetCharacterHandling(current_char_set);  /* restore now */
d1896 2
a1897 6
	return;
    } else if (canreparse_post) {
	srcmode_for_next_retrieval(0);
	LYUCPopAssumed();	/* probably a right place here */
	return;
    }
d1900 15
a1914 5
    if (curdoc.title)
	StrAllocCopy(newdoc.title, curdoc.title);
    free_address(&curdoc); /* so it doesn't get pushed */
    LYforce_no_cache = TRUE;
}
a1915 16
PRIVATE void handle_LYK_SWITCH_DTD NOARGS
{
#ifdef SOURCE_CACHE
    BOOLEAN canreparse = FALSE;
    if (!(canreparse = HTcan_reparse_document())) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so,
	 * seek confirmation of reload if the safe element
	 * is not set.  - FM, kw
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
d1917 1
a1917 3
	     *  If currently viewing preparsed source, switching
	     *  to the other DTD parsing may show source differences,
	     *  so stay in source view - kw
d1920 11
a1930 7
	    /* NOTE: this conditional can be considered incorrect -
	       current behaviour - when viewing source and
	       LYPreparsedSource==TRUE, pressing ^V will toggle parser mode
	       AND switch back from the source view to presentation view.-HV
	    */
	    if (HTisDocumentSource() && LYPreparsedSource) {
		srcmode_for_next_retrieval(1);
d1932 2
a1934 1
	    move_address(&newdoc, &curdoc);
d1936 3
d1942 6
d1951 17
a1967 7
	}
#ifdef SOURCE_CACHE
    } /* end if no bypass */
#endif
    Old_DTD = !Old_DTD;
    HTSwitchDTD(!Old_DTD);
    HTUserMsg(Old_DTD ? USING_DTD_0 : USING_DTD_1);
d1969 1
a1969 8
    if (canreparse) {
	if (HTisDocumentSource() && LYPreparsedSource) {
	    srcmode_for_next_retrieval(1);
	}
	if (!reparse_document()) {
	    srcmode_for_next_retrieval(0);
	}
    }
a1970 15
    return;
}

#ifdef DIRED_SUPPORT
PRIVATE void handle_LYK_TAG_LINK NOARGS
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	if (!strcmp(LYGetHiliteStr(curdoc.link, 0), ".."))
	    return;	/* Never tag the parent directory */
	if (dir_list_style == MIXED_STYLE) {
	    if (!strcmp(LYGetHiliteStr(curdoc.link, 0), "../"))
		return;
	} else if (!strncmp(LYGetHiliteStr(curdoc.link, 0), "Up to ", 6))
	    return;
	{
d1972 3
a1974 1
	     *	HTList-based management of tag list, see LYLocal.c - KW
d1976 11
a1986 12
	    HTList * t1 = tagged;
	    char * tagname = NULL;
	    BOOLEAN found = FALSE;

	    while ((tagname = (char *)HTList_nextObject(t1)) != NULL) {
		if (!strcmp(links[curdoc.link].lname, tagname)) {
		    found = TRUE;
		    HTList_removeObject(tagged, tagname);
		    FREE(tagname);
		    tagflag(OFF,curdoc.link);
		    break;
		}
d1988 10
a1997 147
	    if (!found) {
		if (tagged == NULL)
		    tagged = HTList_new();
		tagname = NULL;
		StrAllocCopy(tagname,links[curdoc.link].lname);
		HTList_addObject(tagged,tagname);
		tagflag(ON,curdoc.link);
	    }
	}
	if (curdoc.link < nlinks-1) {
	    set_curdoc_link(curdoc.link + 1);
	} else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
	    set_curdoc_link(0);
	} else if (more) {  /* next page */
	    Newline += (display_lines);
	}
    }
}
#endif /* DIRED_SUPPORT */

PRIVATE void handle_LYK_TOGGLE_HELP NOARGS
{
    if (user_mode == NOVICE_MODE) {
	toggle_novice_line();
	noviceline(more);
    }
}

PRIVATE void handle_LYK_TOOLBAR ARGS4(
    BOOLEAN *,	try_internal,
    BOOLEAN *,	force_load,
    int *,	old_c,
    int,	real_c)
{
    char *cp;
    char *toolbar = NULL;

    if (!HText_hasToolbar(HTMainText)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_TOOLBAR);
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	cp = trimPoundSelector(curdoc.address);
	HTSprintf0(&toolbar, "%s#%s", curdoc.address, LYToolbarName);
	restorePoundSelector(cp);
	set_address(&newdoc, toolbar);
	FREE(toolbar);
	*try_internal = TRUE;
	*force_load = TRUE;  /* force MainLoop to reload */
    }
}

PRIVATE void handle_LYK_TRACE_LOG ARGS1(
    BOOLEAN *,	trace_flag_ptr)
{
#ifndef NO_LYNX_TRACE
    /*
     *	Check whether we've started a TRACE log
     *	in this session. - FM
     */
    if (LYTraceLogFP == NULL) {
	HTUserMsg(NO_TRACELOG_STARTED);
	return;
    }

    /*
     *	Don't do if already viewing the TRACE log. - FM
     */
    if (LYIsUIPage(curdoc.address, UIP_TRACELOG))
	return;

    /*
     *	If TRACE mode is on, turn it off during this fetch of the
     *	TRACE log, so we don't enter stuff about this fetch, and
     *	set a flag for turning it back on when we return to this
     *	loop.  Note that we'll miss any messages about memory
     *	exhaustion if it should occur.	It seems unlikely that
     *	anything else bad might happen, but if it does, we'll
     *	miss messages about that too.  We also fflush(), close,
     *	and open it again, to make sure all stderr messages thus
     *	far will be in the log. - FM
     */
    if (!LYReopenTracelog(trace_flag_ptr))
	return;

    LYLocalFileToURL (&(newdoc.address), LYTraceLogPath);
    LYRegisterUIPage(newdoc.address, UIP_TRACELOG);
    StrAllocCopy(newdoc.title, LYNX_TRACELOG_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
    }
    LYforce_no_cache = TRUE;
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

#ifdef DIRED_SUPPORT
PRIVATE void handle_LYK_UPLOAD NOARGS
{
    /*
     *	Don't do if already viewing upload options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS))
	return;

    if (lynx_edit_mode && !no_dired_support) {
	LYUpload_options(&(newdoc.address), curdoc.address);
	StrAllocCopy(newdoc.title, UPLOAD_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 *  Uncache the current listing so that it will
	 *  be updated to included the uploaded file if
	 *  placed in the current directory. - FM
	 */
	DIRED_UNCACHE_1;
     }
}
#endif /* DIRED_SUPPORT */

PRIVATE void handle_LYK_UP_HALF ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	int scrollamount = display_lines/2;
	if (Newline - scrollamount < 1)
	    scrollamount = Newline - 1;
	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
			      HText_LinksInLines(HTMainText,
						 Newline,
						 scrollamount);
d1999 2
a2000 1
		*arrowup = TRUE;
d2002 3
a2004 71
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

PRIVATE void handle_LYK_UP_LINK ARGS4(
    int *,	follow_col,
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.link > 0 &&
	(links[0].ly != links[curdoc.link].ly ||
	 !HText_LinksInLines(HTMainText, 1, Newline - 1))) {
	/* more links before this on screen, and first of them on
	   a different line or no previous links before this screen? */
	int newlink;

	if (*follow_col == -1) {
	    char *text = LYGetHiliteStr(curdoc.link, 0);
	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, -1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_ABOVE);
	}

    } else if (curdoc.line > 1 && Newline > 1) {  /* previous page */
	int scrollamount = (Newline > display_lines ?
				      display_lines : Newline - 1);
	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link > -1 &&
	    links[0].ly -1 + scrollamount <= display_lines) {
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

PRIVATE void handle_LYK_UP_TWO ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	int scrollamount = (Newline > 2 ? 2 : 1);
	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
			      HText_LinksInLines(HTMainText,
						 Newline, scrollamount);
	    } else {
		*arrowup = TRUE;
d2006 2
a2007 6
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}
d2009 4
a2012 30
PRIVATE void handle_LYK_VIEW_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    char *cp;

    if (LYValidate) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    /*
     *	See if a bookmark exists.
     *	If it does replace newdoc.address with its name.
     */
    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL) {
	if (*cp == '\0' || !strcmp(cp, " ") ||
	    !strcmp(curdoc.address, newdoc.address)) {
	    if (LYMultiBookmarks != MBM_OFF)
		*refresh_screen = TRUE;
	    return;
	}
#ifdef KANJI_CODE_OVERRIDE
	if (HTCJK == JAPANESE) {
	    last_kcode = NOKANJI;	/* AUTO */
	}
a2013 198
	LYforce_no_cache = TRUE;  /*force the document to be reloaded*/
	StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
	StrAllocCopy(newdoc.bookmark, BookmarkPage);
	LYFreePostData(&newdoc);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    LYMBM_statusline(BOOKMARKS_NOT_OPEN);
	    LYSleepAlert();
	    if (LYMultiBookmarks != MBM_OFF) {
		*refresh_screen = TRUE;
	    }
	}
    }
}

PRIVATE BOOLEAN handle_LYK_VLINKS ARGS2(
    int *,	cmd,
    BOOLEAN *,	newdoc_link_is_absolute)
{
    int c;

    if (LYIsUIPage(curdoc.address, UIP_VLINKS)) {
	/*
	 *  Already viewing visited links page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     *	Print visited links page to file.
     */
    c = LYShowVisitedLinks(&newdoc.address);
    if (c < 0) {
	HTUserMsg(VISITED_LINKS_EMPTY);
	return FALSE;
    }
    StrAllocCopy(newdoc.title, VISITED_LINKS_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (c > 0) {
	/* Select a correct link. */
	*newdoc_link_is_absolute = TRUE;
	newdoc.link = c - 1;
    }
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlinksfile, newdoc.address);
    }
    return FALSE;
}

PUBLIC void handle_LYK_WHEREIS ARGS2(
    int,	cmd,
    BOOLEAN *,	refresh_screen)
{
    BOOLEAN have_target_onscreen = (BOOLEAN) (*prev_target != '\0' &&
				    HText_pageHasPrevTarget());
    BOOL found;
    int oldcur = curdoc.link; /* temporarily remember */
    char *remember_old_target = NULL;
    if (have_target_onscreen)
	StrAllocCopy(remember_old_target, prev_target);
    else
	StrAllocCopy(remember_old_target, "");

    if (cmd == LYK_WHEREIS) {
	/*
	 *  Reset prev_target to force prompting
	 *  for a new search string and to turn
	 *  off highlighting if no search string
	 *  is entered by the user.
	 */
	*prev_target = '\0';
    }
    found = textsearch(&curdoc, prev_target, sizeof(prev_target)-1,
		       (cmd == LYK_WHEREIS)
		       ? 0
		       : ((cmd == LYK_NEXT)
			 ? 1
			 : -1));

    /*
     *	Force a redraw to ensure highlighting of hits
     *	even when found on the same page, or clearing
     *	of highlighting if the default search string
     *	was erased without replacement. - FM
     */
    /*
    ** Well let's try to avoid it at least in a few cases
    ** where it is not needed. - kw
    */
    if (www_search_result >= 0 && www_search_result != curdoc.line) {
	*refresh_screen = TRUE; /* doesn't really matter */
    } else if (!found) {
	*refresh_screen = have_target_onscreen;
    } else if (!have_target_onscreen && found) {
	*refresh_screen = TRUE;
    } else if (www_search_result == curdoc.line &&
	       curdoc.link == oldcur &&
	       curdoc.link >= 0 && nlinks > 0 &&
	       links[curdoc.link].ly >= (display_lines/3)) {
	*refresh_screen = TRUE;
    } else if ((case_sensitive && 0!=strcmp(prev_target,
					    remember_old_target)) ||
	     (!case_sensitive && 0!=strcasecomp8(prev_target,
					    remember_old_target))) {
	*refresh_screen = TRUE;
    }
    FREE(remember_old_target);
}

/*
 * Get a number from the user and follow that link number.
 */
PRIVATE void handle_LYK_digit ARGS6(
    int,	c,
    BOOLEAN *,	force_load,
    char *,	user_input_buffer,
    int *,	old_c,
    int,	real_c,
    BOOLEAN *,	try_internal GCC_UNUSED)
{
    int lindx = ((nlinks > 0) ? curdoc.link : 0);
    int number;
    char *temp = NULL;

    /* pass cur line num for use in follow_link_number()
     * Note: Current line may not equal links[cur].line
     */
    number = curdoc.line;
    switch (follow_link_number(c, lindx, &newdoc, &number)) {
    case DO_LINK_STUFF:
	/*
	 *  Follow a normal link.
	 */
	set_address(&newdoc, links[lindx].lname);
	StrAllocCopy(newdoc.title, LYGetHiliteStr(lindx, 0));
#ifndef DONT_TRACK_INTERNAL_LINKS
	/*
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
	 */
	if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
	    LYinternal_flag = TRUE;
	    newdoc.internal_link = TRUE;
	    if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		(LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		 LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		if (check_history()) {
		    LYinternal_flag = TRUE;
		} else {
		    HTLastConfirmCancelled(); /* reset flag */
		    if (!confirm_post_resub(newdoc.address,
					    newdoc.title,
					    (LYresubmit_posts &&
					     HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
					    2)) {
			if (HTLastConfirmCancelled() ||
			    (LYresubmit_posts &&
			     !HText_POSTReplyLoaded(&newdoc))) {
			    /* cancel the whole thing */
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    copy_address(&newdoc, &curdoc);
			    StrAllocCopy(newdoc.title, curdoc.title);
			    newdoc.internal_link = curdoc.internal_link;
			    HTInfoMsg(CANCELLED);
			    if (nlinks > 0)
				HText_pageDisplay(curdoc.line, prev_target);
			    break;
			} else if (LYresubmit_posts) {
			    /* If LYresubmit_posts is set, and the
			       answer was No, and we have a cached
			       copy, then use it. - kw */
			    LYforce_no_cache = FALSE;
			} else {
			    /* if No, but not ^C or ^G, drop
			     * the post data.  Maybe the link
			     * wasn't meant to be internal after
			     * all, here we can recover from that
			     * assumption. - kw */
			    LYFreePostData(&newdoc);
			    newdoc.internal_link = FALSE;
			    HTAlert(DISCARDING_POST_DATA);
			}
		    }
		}
d2015 3
a2017 2
		 *  Don't push the List Page if we follow an
		 *  internal link given by it. - kw
d2019 5
a2023 54
		free_address(&curdoc);
	    } else
		*try_internal = TRUE;
	    if (!(LYresubmit_posts && newdoc.post_data))
		LYinternal_flag = TRUE;
	    *force_load = TRUE;
	    break;
	} else {
	    /*
	     *	Free POST content if not an internal link. - kw
	     */
	    LYFreePostData(&newdoc);
	}
#endif /* DONT_TRACK_INTERNAL_LINKS */
	/*
	 *  Might be an anchor in the same doc from a POST
	 *  form.  If so, don't free the content. -- FM
	 */
	if (are_different(&curdoc, &newdoc)) {
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    if (isLYNXMESSAGES(newdoc.address))
		LYforce_no_cache = TRUE;
	}
	newdoc.internal_link = FALSE;
	*force_load = TRUE;  /* force MainLoop to reload */
	break;

    case DO_GOTOLINK_STUFF:
	/*
	 *  Position on a normal link, don't follow it. - KW
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
	    /*
	     *	It's a link in the current page. - FM
	     */
	    if (nlinks > 0 && curdoc.link > -1) {
		if (curdoc.link == newdoc.link) {
		    /*
		     *	It's the current link, and presumably
		     *	reflects a typo in the statusline entry,
		     *	so issue a statusline message for the
		     *	typo-prone users (like me 8-). - FM
		     */
		    StrAllocCopy(temp, user_input_buffer);
		    sprintf(user_input_buffer,
			    LINK_ALREADY_CURRENT, number);
		    HTUserMsg(user_input_buffer);
		    LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		    FREE(temp);
d2025 5
a2029 5
		    /*
		     *	It's a different link on this page,
		     */
		    set_curdoc_link(newdoc.link);
		    newdoc.link = 0;
d2032 20
a2051 2
	}
	break;		/* nothing more to do */
d2053 8
a2060 11
    case DO_GOTOPAGE_STUFF:
	/*
	 *  Position on a page in this document. - FM
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
	    /*
	     *	It's the current page, so issue a
	     *	statusline message for the typo-prone
	     *	users (like me 8-). - FM
d2062 5
a2066 4
	    if (Newline <= 1) {
		HTInfoMsg(ALREADY_AT_BEGIN);
	    } else if (!more) {
		HTInfoMsg(ALREADY_AT_END);
d2068 18
a2085 6
		StrAllocCopy(temp, user_input_buffer);
		sprintf(user_input_buffer,
			ALREADY_AT_PAGE, number);
		HTUserMsg(user_input_buffer);
		LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		FREE(temp);
d2087 1
a2087 49
	}
	break;

    case PRINT_ERROR:
	*old_c = real_c;
	HTUserMsg(BAD_LINK_NUM_ENTERED);
	break;
    }
    return;
}

#ifdef SUPPORT_CHDIR

/* original implementation by VH */
PUBLIC void handle_LYK_CHDIR NOARGS
{
    static char buf[LY_MAXPATH];
    char *p = NULL;

    if (no_chdir) {
	HTUserMsg(CHDIR_DISABLED);
	return;
    }

    _statusline(gettext("cd to:"));
    /* some people may prefer automatic clearing of the previous user input,
       here, to do this, just uncomment next line - VH */
    /* buf[0]='\0'; */
    if (LYgetstr(buf, VISIBLE, sizeof(buf)-1, 0) < 0 || !*buf) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (*buf == '~' && !buf[1]) {
	StrAllocCopy(p, Home_Dir());
    } else if (*buf == '~') {
	HTSprintf0(&p, "%s%s", Home_Dir(), buf+1);
    } else {
	StrAllocCopy(p, buf);
    }

    CTRACE((tfp, "changing directory to '%s'\n", p));
    if (chdir(p)) {
	switch (errno) {
	case EACCES:
	    HTInfoMsg(COULD_NOT_ACCESS_DIR);
	    break;
	case ENOENT:
	    HTInfoMsg(gettext("No such directory"));
a2088 14
	case ENOTDIR:
	    HTInfoMsg(gettext("A component of path is not a directory"));
	    break;
	default:
	    HTInfoMsg(gettext("failed to change directory"));
	    break;
	}
    } else {
#ifdef DIRED_SUPPORT
	/*if in dired, load content of other directory*/
	if (!no_dired_support
	 && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
	    char buf2[LY_MAXPATH];
	    char* addr = NULL;
d2090 20
a2109 2
	    Current_Dir(buf2);
	    LYLocalFileToURL(&addr, buf2);
d2111 23
a2133 10
	    newdoc.address = addr;
	    newdoc.isHEAD = FALSE;
	    StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    /**force_load = TRUE;*/
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
d2135 13
a2147 1
	} else
d2149 6
a2154 4
	    HTInfoMsg(OPERATION_DONE);
    }
    FREE(p);
}
d2156 1
d2158 5
a2162 17
#ifdef USE_CURSES_PADS
/*
 * Having jumps larger than this is counter-productive.  Indeed, it is natural
 * to expect that when the relevant text appears, one would "overshoot" and
 * would scroll 3-4 extra full screens.  When going back, the "accumulation"
 * logic would again start moving in full screens, so one would overshoot
 * again, etc.
 *
 * Going back, one can fix it in 28 keypresses. The relevant text will appear
 * on the screen soon enough for the key-repeat to become not that important,
 * and we are still moving in smaller steps than when we overshot.  Since key
 * repeat is not important, even if we overshoot again, it is going to be by 30
 * steps, which is easy to fix by reversing the direction again.
 */
PRIVATE int repeat_to_delta ARGS1(int, n)
{
    int threshold = LYcols / 3;
d2164 17
a2180 3
    while (threshold > 0) {
	if (n >= threshold) {
	    n = threshold;
a2181 5
	}
	threshold = (threshold * 2) / 3;
    }
    return n;
}
d2183 14
a2196 13
PRIVATE void handle_LYK_SHIFT_LEFT ARGS2(BOOLEAN *, flag, int, count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    if (LYshiftWin > 0) {
	LYshiftWin -= repeat_to_delta(count);
	*flag = TRUE;
    }
    if (LYshiftWin < 0)
	LYshiftWin = 0;
}
d2198 11
a2208 9
PRIVATE void handle_LYK_SHIFT_RIGHT ARGS2(BOOLEAN *, flag, int, count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    LYshiftWin += repeat_to_delta(count);
    *flag = TRUE;
}
d2210 18
a2227 26
PRIVATE BOOLEAN handle_LYK_LINEWRAP_TOGGLE ARGS2(
    int *,	cmd,
    BOOLEAN *,	flag)
{
    static char *choices[] = {
	"Try to fit screen width",
	"No line wrap in columns",
	"Wrap columns at screen width",
	"Wrap columns at 3/4 screen width",
	"Wrap columns at 2/3 screen width",
	"Wrap columns at 1/2 screen width",
	"Wrap columns at 1/3 screen width",
	"Wrap columns at 1/4 screen width",
	NULL
    };
    static int wrap[] = {
	0,
	0,
	12,				/* In units of 1/12 */
	9,
	8,
	6,
	4,
	3
    };
    int c;
d2229 14
a2242 2
    if (LYwin == stdscr)
	return FALSE;
d2244 21
a2264 15
    /* Somehow the mouse is over the number instead of being over the
       name, so we decrease x. */
    c = LYChoosePopup(!LYwideLines, LYlines /2 - 2, LYcols/2-6,
		      choices, TABLESIZE(choices) - 1, FALSE, TRUE);
    /*
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
     */
    if (term_options)
	return FALSE;
    LYwideLines = c;
    LYtableCols = wrap[c];
d2266 14
a2279 7
    if (LYwideLines == 0)
	LYshiftWin = 0;
    *flag = TRUE;
    HTUserMsg(LYwideLines ? LINEWRAP_OFF : LINEWRAP_ON);
    return reparse_or_reload(cmd);
}
#endif
d2281 4
a2284 8
/*
 *  Here's where we do all the work.
 *  mainloop is basically just a big switch dependent on the users input.
 *  I have tried to offload most of the work done here to procedures to
 *  make it more modular, but this procedure still does a lot of variable
 *  manipulation.  This needs some work to make it neater. - Lou Moutilli
 *					(memoir from the original Lynx - FM)
 */
d2286 8
a2293 6
int mainloop NOARGS
{
#if defined(WIN_EX)	/* 1997/10/08 (Wed) 14:52:06 */
#undef	STRING_MAX
#define	STRING_MAX	4096
    char temp_buff[STRING_MAX];
d2295 9
a2303 35
#define	BUFF_MAX	1024
    char sjis_buff[BUFF_MAX];
#endif
    int c = 0, real_c = 0, old_c = 0, pending_form_c = -1;
    int cmd = LYK_DO_NOTHING, real_cmd = LYK_DO_NOTHING;
    int getresult;
    int arrowup = FALSE, show_help = FALSE;
    char user_input_buffer[MAX_LINE];
    CONST char *cshelpfile = NULL;
    BOOLEAN first_file = TRUE;
    BOOLEAN popped_doc = FALSE;
    BOOLEAN refresh_screen = FALSE;
    BOOLEAN force_load = FALSE;
    BOOLEAN try_internal = FALSE;
    BOOLEAN crawl_ok = FALSE;
    BOOLEAN vi_keys_flag = vi_keys;
    BOOLEAN emacs_keys_flag = emacs_keys;
    BOOLEAN trace_mode_flag = FALSE;
    BOOLEAN forced_HTML_mode = LYforce_HTML_mode;
    char cfile[128];
    FILE *cfp;
    char *cp;
    int ch, recall;
    int URLTotal;
    int URLNum;
    BOOLEAN FirstURLRecall = TRUE;
    char *temp = NULL;
    BOOLEAN ForcePush = FALSE;
    BOOLEAN override_LYresubmit_posts = FALSE;
    BOOLEAN newdoc_link_is_absolute = FALSE;
    BOOLEAN curlink_is_editable;
    BOOLEAN use_last_tfpos;
    unsigned int len;
    int i;
    int follow_col = -1, key_count = 0, last_key = 0;
d2305 7
a2311 5
/*  "internal" means "within the same document, with certainty".
 *  It includes a space so it cannot conflict with any (valid) "TYPE"
 *  attributes on A elements. [According to which DTD, anyway??] - kw
 */
    HTInternalLink = HTAtom_for("internal link");  /* init, used as const */
d2313 10
a2322 3
#ifndef WWW_SOURCE
    WWW_SOURCE = HTAtom_for("www/source");  /* init, used as const */
#endif
d2324 16
a2339 40
/*
 *  curdoc.address contains the name of the file that is currently open.
 *  newdoc.address contains the name of the file that will soon be
 *		     opened if it exits.
 *  prev_target    contains the last search string the user searched for.
 *  newdoc.title   contains the link name that the user last chose to get
 *		     into the current link (file).
 */
    /* initialize some variables*/
    newdoc.address = NULL;
    newdoc.title = NULL;
    newdoc.post_data = NULL;
    newdoc.post_content_type = NULL;
    newdoc.bookmark = NULL;
    newdoc.internal_link = FALSE;
    curdoc.address = NULL;
    curdoc.title = NULL;
    curdoc.post_data = NULL;
    curdoc.post_content_type = NULL;
    curdoc.bookmark = NULL;
    curdoc.internal_link = FALSE;
#ifdef USE_COLOR_STYLE
    curdoc.style = NULL;
    newdoc.style = NULL;
#endif
    nhist = 0;
    user_input_buffer[(sizeof(user_input_buffer) - 1)] = '\0';
    *prev_target = '\0';
    *user_input_buffer = '\0';
#ifdef LY_FIND_LEAKS
    atexit(free_mainloop_variables);
#endif
initialize:
    set_address(&newdoc, startfile);
    StrAllocCopy(startrealm, startfile);
    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.line = 1;
    newdoc.link = 0;
d2341 5
a2345 7
#ifdef USE_SLANG
    if (TRACE && LYCursesON) {
	LYaddstr("\n");
	LYrefresh();
    }
#endif /* USE_SLANG */
    CTRACE((tfp, "Entering mainloop, startfile=%s\n", startfile));
d2347 25
a2371 20
    if (form_post_data) {
	BStrCopy0(newdoc.post_data, form_post_data);
	StrAllocCopy(newdoc.post_content_type,
		     "application/x-www-form-urlencoded");
    } else if (form_get_data) {
	StrAllocCat(newdoc.address, form_get_data);
    }

    if (bookmark_start) {
	if (LYValidate) {
	    HTAlert(BOOKMARKS_DISABLED);
	    bookmark_start = FALSE;
	    goto initialize;
	} else if (traversal) {
	    HTAlert(BOOKMARKS_NOT_TRAVERSED);
	    traversal = FALSE;
	    crawl = FALSE;
	    bookmark_start = FALSE;
	    goto initialize;
	} else {
d2373 2
a2374 2
	     *	See if a bookmark page exists.	If it does,
	     *	replace newdoc.address with its name
d2376 3
a2378 16
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL &&
		 *cp != '\0' && strcmp(cp, " ")) {
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		StrAllocCopy(startrealm, newdoc.address);
		LYFreePostData(&newdoc);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		CTRACE((tfp, "Using bookmarks=%s\n", newdoc.address));
	    } else {
		HTUserMsg(BOOKMARKS_NOT_OPEN);
		bookmark_start = FALSE;
		goto initialize;
	    }
	}
    }
d2380 2
a2381 2
    FREE(form_post_data);
    FREE(form_get_data);
d2383 5
a2387 4
    if (user_mode == NOVICE_MODE)
	display_lines = LYlines-4;
    else
	display_lines = LYlines-2;
d2389 4
a2392 10
    while (TRUE) {
#ifdef USE_COLOR_STYLE
	if (curdoc.style != NULL) force_load = TRUE;
#endif
	/*
	 *  If newdoc.address is different then curdoc.address then
	 *  we need to go out and find and load newdoc.address.
	 */
	if (LYforce_no_cache || force_load ||
	    are_different(&curdoc, &newdoc)) {
a2393 9
		force_load = FALSE;  /* done */
		if (TRACE && LYCursesON) {
		    LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
		    LYaddstr("\n");
#endif /* USE_SLANG */
		    LYrefresh();
		}
try_again:
d2395 2
a2396 2
		 *  Push the old file onto the history stack if we
		 *  have a current doc and a new address. - FM
d2398 98
a2495 12
		if (curdoc.address && newdoc.address) {
		    /*
		     *	Don't actually push if this is a LYNXDOWNLOAD
		     *	URL, because that returns NORMAL even if it
		     *	fails due to a spoof attempt or file access
		     *	problem, and we set the newdoc structure
		     *	elements to the curdoc structure elements
		     *	under case NORMAL.  - FM
		     */
		    if (!isLYNXDOWNLOAD(newdoc.address))
		    {
			LYpush(&curdoc, ForcePush);
d2497 43
a2539 1
		} else if (!newdoc.address) {
d2541 2
a2542 2
		     *	If newdoc.address is empty then pop a file
		     *	and load it.  - FM
d2544 7
a2550 2
		    LYhist_prev(&newdoc);
		    popped_doc = TRUE;
d2552 6
d2559 11
a2569 36

#ifndef DONT_TRACK_INTERNAL_LINKS
		    /*
		    ** If curdoc had been reached via an internal
		    ** (fragment) link from what we now have just
		    ** popped into newdoc, then override non-caching in
		    ** all cases. - kw
		    */
		    if (curdoc.internal_link &&
			!are_phys_different(&curdoc, &newdoc)) {
			LYinternal_flag = TRUE;
			LYoverride_no_cache = TRUE;
			LYforce_no_cache = FALSE;
			try_internal = TRUE;
		    } else
#endif /* TRACK_INTERNAL_LINKS */
		    {
			/*
			 * Force a no_cache override unless
			 *  it's a bookmark file, or it has POST content
			 *  and LYresubmit_posts is set without safe also
			 *  set, and we are not going to another position
			 *  in the current document or restoring the previous
			 *  document due to a NOT_FOUND or NULLFILE return
			 *  value from getfile(). - FM
			 */
			if ((newdoc.bookmark != NULL) ||
			    (newdoc.post_data != NULL &&
			     !newdoc.safe &&
			     LYresubmit_posts &&
			     !override_LYresubmit_posts &&
				NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			    LYoverride_no_cache = FALSE;
			} else {
			    LYoverride_no_cache = TRUE;
			}
d2572 25
a2596 1
		override_LYresubmit_posts = FALSE;
d2598 12
a2609 19
		if (HEAD_request) {
		    /*
		     *	Make SURE this is an appropriate request. - FM
		     */
		    if (newdoc.address) {
			if (LYCanDoHEAD(newdoc.address) == TRUE) {
			    newdoc.isHEAD = TRUE;
			} else if (isLYNXIMGMAP(newdoc.address)) {
			    if (LYCanDoHEAD(newdoc.address + LEN_LYNXIMGMAP) == TRUE) {
				StrAllocCopy(temp, newdoc.address + LEN_LYNXIMGMAP);
				free_address(&newdoc);
				newdoc.address = temp;
				newdoc.isHEAD = TRUE;
				temp = NULL;
			    }
			}
		    }
		    try_internal = FALSE;
		    HEAD_request = FALSE;
d2612 14
a2625 12
		/*
		 *  If we're getting the TRACE log and it's not new,
		 *  check whether its HText structure has been dumped,
		 *  and if so, fflush() and fclose() it to ensure it's
		 *  fully updated, and then fopen() it again. - FM
		 */
		if (LYUseTraceLog == TRUE &&
		    trace_mode_flag == FALSE &&
		    LYTraceLogFP != NULL &&
		    LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
		    DocAddress WWWDoc;
		    HTParentAnchor *tmpanchor;
d2627 15
a2641 14
		    WWWDoc.address = newdoc.address;
		    WWWDoc.post_data = newdoc.post_data;
		    WWWDoc.post_content_type = newdoc.post_content_type;
		    WWWDoc.bookmark = newdoc.bookmark;
		    WWWDoc.isHEAD = newdoc.isHEAD;
		    WWWDoc.safe = newdoc.safe;
		    tmpanchor = HTAnchor_findAddress(&WWWDoc);
		    if ((HText *)HTAnchor_document(tmpanchor) == NULL) {
			if (!LYReopenTracelog(&trace_mode_flag)) {
			    old_c = 0;
			    cmd = LYK_PREV_DOC;
			    goto new_cmd;
			}
		    }
d2643 37
d2681 15
a2695 8
		LYRequestTitle = newdoc.title;
		if (newdoc.bookmark)
		    LYforce_HTML_mode = TRUE;
		if (LYValidate &&
		    startfile_ok &&
		    newdoc.address && startfile && homepage &&
		    (!strcmp(newdoc.address, startfile) ||
		     !strcmp(newdoc.address, homepage))) {
d2698 8
d2707 8
a2714 3
		/* reset these two variables here before getfile()
		 * so they will be available in partial mode
		 * (was previously implemented in case NORMAL).
d2716 8
a2723 2
		*prev_target = '\0';	/* Reset for new coming document */
		Newline = newdoc.line;	/* set for LYGetNewline() */
a2724 7
#ifdef USE_PRETTYSRC
		psrc_first_tag = TRUE;
#endif
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		textfields_need_activation = textfields_activation_option;
#endif
		FREE(LYRequestReferer);
d2726 1
a2726 5
		 *  Don't send Referer if we have to load a document again
		 *  that we got from the history stack.  We don't know
		 *  any more how we originally got to that page.  Using
		 *  a Referer based on the current HTMainText could only
		 *  be right by coincidence. - kw 1999-11-01
d2728 13
a2740 2
		if (popped_doc)
		    LYNoRefererForThis = TRUE;
d2742 34
a2775 8
#ifndef DONT_TRACK_INTERNAL_LINKS
		if (try_internal) {
		    if (newdoc.address &&
			isLYNXIMGMAP(newdoc.address)) {
			try_internal = FALSE;
		    } else if (curdoc.address &&
			isLYNXIMGMAP(curdoc.address)) {
			try_internal = FALSE;
d2777 10
a2786 5
		}
		if (try_internal) {
		    char *hashp = findPoundSelector(newdoc.address);
		    if (hashp) {
			HTFindPoundSelector(hashp+1);
d2788 28
a2815 6
		    getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		    try_internal = FALSE; /* done */
		    /* fix up newdoc.address which may have been fragment-only */
		    if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
			if (!hashp) {
			    set_address(&newdoc, HTLoadedDocumentURL());
d2817 8
a2824 4
			    StrAllocCopy(temp, HTLoadedDocumentURL());
			    StrAllocCat(temp, hashp); /* append fragment */
			    set_address(&newdoc, temp);
			    FREE(temp);
d2826 10
a2836 16
		} else {
		    if (newdoc.internal_link && newdoc.address &&
			*newdoc.address == '#' && nhist > 0) {
			char *cp0;
			if (isLYNXIMGMAP(HDOC(nhist-1).address))
			    cp0 = HDOC(nhist-1).address + LEN_LYNXIMGMAP;
			else
			    cp0 = HDOC(nhist-1).address;
			StrAllocCopy(temp, cp0);
			(void) trimPoundSelector(temp);
			StrAllocCat(temp, newdoc.address);
			free_address(&newdoc);
			newdoc.address = temp;
			temp = NULL;
		    }
		    getresult = getfile(&newdoc);
a2837 3
#else  /* TRACK_INTERNAL_LINKS */
		getresult = getfile(&newdoc);
#endif /* TRACK_INTERNAL_LINKS */
d2839 19
a2857 3
#ifdef INACTIVE_INPUT_STYLE_VH
		textinput_redrawn = FALSE; /* for sure */
#endif
d2859 15
a2873 1
		switch(getresult) {
d2875 9
a2883 1
		case NOT_FOUND:
d2885 1
a2885 2
		     *	OK! can't find the file, so it must not be around now.
		     *	Do any error logging, if appropriate.
d2887 13
a2899 4
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    if (!first_file && !LYCancelledFetch) {
d2901 1
a2901 7
			 *  Do error mail sending and/or traversal
			 *  stuff.  Note that the links[] elements may
			 *  not be valid at this point, if we did call
			 *  HTuncache_current_document!   This should
			 *  not have happened for traversal, but for
			 *  sending error mail check that HTMainText
			 *  exists for this reason. - kw
d2903 8
a2910 48
			if (error_logging && nhist > 0 && !popped_doc &&
			    !LYUserSpecifiedURL &&
			    HTMainText &&
			    nlinks > 0 && curdoc.link < nlinks &&
			    !isLYNXHIST(NonNull(newdoc.address)) &&
			    !isLYNXCOOKIE(NonNull(newdoc.address))) {
			    char *mail_owner = NULL;
			    if (owner_address && isMAILTO_URL(owner_address)) {
				mail_owner = owner_address + LEN_MAILTO_URL;
			    }
			    /*
			     *  Email a bad link message to the owner of
			     *  the document, or to ALERTMAIL if defined,
			     *  but NOT to lynx-dev (it is rejected in
			     *  mailmsg). - FM, kw
			     */
#ifndef ALERTMAIL
			    if (mail_owner)
#endif
				mailmsg(curdoc.link,
					mail_owner,
					HDOC(nhist-1).address,
					HDOC(nhist-1).title);
			}
			if (traversal) {
			    FILE *ofp;

			    if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
				if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				    perror(NOOPEN_TRAV_ERR_FILE);
				    exit_immediately(EXIT_FAILURE);
				}
			    }
			    if (nhist > 0) {
				fprintf(ofp,
					"%s %s\tin %s\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target,
					HDOC(nhist-1).address);
			    } else {
				fprintf(ofp,
					"%s %s\t\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target);
			    }
			    LYCloseOutput(ofp);
a2911 8
		    }

		    /*
		     *	Fall through to do the NULL stuff and reload the
		     *	old file, unless the first file wasn't found or
		     *	has gone missing.
		     */
		    if (!nhist) {
d2913 2
a2914 1
			 *  If nhist = 0 then it must be the first file.
d2916 7
a2922 34
			exit_immediately_with_error_message(NOT_FOUND, first_file);
			return(EXIT_FAILURE);
		    }
		    /* FALLTHRU */

		case NULLFILE:
		    /*
		     *	Not supposed to return any file.
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    free_address(&newdoc); /* to pop last doc */
		    FREE(newdoc.bookmark);
		    LYJumpFileURL = FALSE;
		    reloading = FALSE;
		    LYPermitURL = FALSE;
		    LYCancelledFetch = FALSE;
		    ForcePush = FALSE;
		    LYforce_HTML_mode = FALSE;
		    force_old_UCLYhndl_on_reload = FALSE;
		    if (traversal) {
			crawl_ok = FALSE;
			if (traversal_link_to_add) {
			    /*
			     *	It's a binary file, or the fetch attempt
			     *	failed.  Add it to TRAVERSE_REJECT_FILE
			     *	so we don't try again in this run.
			     */
			    if (!lookup_reject(traversal_link_to_add)) {
				add_to_reject_list(traversal_link_to_add);
			    }
			    FREE(traversal_link_to_add);
a2923 6
		    }
		    /*
		     *  Make sure the first file was found and
		     *  has not gone missing.
		     */
		    if (!nhist) {
d2925 2
a2926 1
			 *  If nhist = 0 then it must be the first file.
d2928 9
a2936 23
			if (first_file && homepage &&
			   !LYSameFilename(homepage, startfile)) {
			   /*
			    *  Couldn't return to the first file but there is a
			    *  homepage we can use instead. Useful for when the
			    *  first URL causes a program to be invoked. - GL
			    *
			    *  But first make sure homepage is different from
			    *  startfile (above), then make it the same (below)
			    *  so we don't enter an infinite getfile() loop on
			    *  on failures to find the files. - FM
			    */
			   set_address(&newdoc, homepage);
			   LYFreePostData(&newdoc);
			   FREE(newdoc.bookmark);
			   StrAllocCopy(startfile, homepage);
			   newdoc.isHEAD = FALSE;
			   newdoc.safe = FALSE;
			   newdoc.internal_link = FALSE;
			   goto try_again;
			} else {
			   exit_immediately_with_error_message(NULLFILE, first_file);
			   return(EXIT_FAILURE);
d2938 19
a2956 88
		    }

		   /*
		    *  If we're going to pop from history because
		    *  getfile didn't succeed, reset LYforce_no_cache
		    *  first.  This would have been done in HTAccess.c
		    *  if the request got that far, but the URL may
		    *  have been handled or rejected in getfile without
		    *  taking care of that. - kw
		    */
		    LYforce_no_cache = FALSE;
		   /*
		    *  Retrieval of a newdoc just failed, and just
		    *  going to try_again would pop the next doc
		    *  from history and try to get it without further
		    *  questions.  This may not be the right thing to do if
		    *  we have POST data, so fake a PREV_DOC key if it seems
		    *  that some prompting should be done.  This doesn't
		    *  affect the traversal logic, since with traversal
		    *  POST data can never occur. - kw
		    */
		   if (HDOC(nhist - 1).post_data &&
		       !HDOC(nhist - 1).safe) {
		       if (HText_POSTReplyLoaded((DocInfo *)&history[(nhist - 1)])) {
			   override_LYresubmit_posts = TRUE;
			   goto try_again;
		       }
		       /*  Set newdoc fields, just in case the PREV_DOC
			*  gets cancelled. - kw */
		       if (!curdoc.address) {
			   set_address(&newdoc, HTLoadedDocumentURL());
			   StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			   if (HTMainAnchor
			    && HTMainAnchor->post_data) {
			       BStrCopy(newdoc.post_data,
					HTMainAnchor->post_data);
			       StrAllocCopy(newdoc.post_content_type,
					    HTMainAnchor->post_content_type);
			   } else {
			       BStrFree(newdoc.post_data);
			   }
			   newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			   newdoc.safe = HTLoadedDocumentIsSafe();
			   newdoc.internal_link = FALSE;
		       } else {
			   copy_address(&newdoc, &curdoc);
			   StrAllocCopy(newdoc.title, curdoc.title);
			   BStrCopy(newdoc.post_data, curdoc.post_data);
			   StrAllocCopy(newdoc.post_content_type,
					curdoc.post_content_type);
			   newdoc.isHEAD = curdoc.isHEAD;
			   newdoc.safe = curdoc.safe;
			   newdoc.internal_link = curdoc.internal_link;
			   newdoc.line = curdoc.line;
			   newdoc.link = curdoc.link;
		       }
		       cmd = LYK_PREV_DOC;
		       goto new_cmd;
		    }
		    override_LYresubmit_posts = TRUE;
		    goto try_again;

		case NORMAL:
		    /*
		     *	Marvelously, we got the document!
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);

		    /*
		     *	If it's the first file and we're interactive,
		     *	check whether it's a bookmark file which was
		     *	not accessed via the -book switch. - FM
		     */
		    if (((first_file == TRUE) &&
			 (dump_output_immediately == FALSE) &&
			 !(newdoc.bookmark && *newdoc.bookmark)) &&
			((LYisLocalFile(newdoc.address) == TRUE) &&
			 !(strcmp(NonNull(HText_getTitle()),
				  BOOKMARK_TITLE))) &&
			(temp = HTParse(newdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION)) != NULL) {
			CONST char *name = wwwName(Home_Dir());
			len = strlen(name);
#ifdef VMS
			if (!strncasecomp(temp, name, len) &&
			    strlen(temp) > len)
d2958 49
a3006 67
			if (!strncmp(temp, name, len) &&
			    strlen(temp) > len)
#endif /* VMS */
			{
			    /*
			     *	We're interactive and this might be a
			     *	bookmark file entered as a startfile
			     *	rather than invoked via -book.	Check
			     *	if it's in our bookmark file list, and
			     *	if so, reload if with the relevant
			     *	bookmark elements set. - FM
			     */
			    cp = NULL;
			    if (temp[len] == '/') {
				if (strchr(&temp[(len + 1)], '/')) {
				    HTSprintf0(&cp, ".%s", &temp[len]);
				} else {
				    StrAllocCopy(cp, &temp[(len + 1)]);
				}
			    } else {
				StrAllocCopy(cp, &temp[len]);
			    }
			    for (i = 0; i <= MBM_V_MAXFILES; i++) {
				if (MBM_A_subbookmark[i] &&
				    LYSameFilename(cp, MBM_A_subbookmark[i])) {
				    StrAllocCopy(BookmarkPage,
						 MBM_A_subbookmark[i]);
				    break;
				}
			    }
			    FREE(cp);
			    if (i <= MBM_V_MAXFILES) {
				FREE(temp);
				if (LYValidate) {
				    HTAlert(BOOKMARKS_DISABLED);
				    return(EXIT_FAILURE);
				}
				if ((temp = HTParse(newdoc.address, "",
				 PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION))) {
				    set_address(&newdoc, temp);
				    HTuncache_current_document();
				    free_address(&curdoc);
				    StrAllocCat(newdoc.address,
					    wwwName(Home_Dir()));
				    StrAllocCat(newdoc.address, "/");
				    StrAllocCat(newdoc.address,
					(strncmp(BookmarkPage, "./", 2) ?
							   BookmarkPage :
							(BookmarkPage + 2)));
				    StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				    StrAllocCopy(newdoc.bookmark, BookmarkPage);
#ifdef USE_COLOR_STYLE
				    if (curdoc.style)
					StrAllocCopy(newdoc.style, curdoc.style);
#endif
				    StrAllocCopy(startrealm, newdoc.address);
				    LYFreePostData(&newdoc);
				    newdoc.isHEAD = FALSE;
				    newdoc.safe = FALSE;
				    FREE(temp);
				    if (!strcmp(homepage, startfile))
					StrAllocCopy(homepage, newdoc.address);
				    StrAllocCopy(startfile, newdoc.address);
				    CTRACE((tfp, "Reloading as bookmarks=%s\n",
						newdoc.address));
				    goto try_again;
				}
d3009 10
a3018 1
			cp = NULL;
d3020 22
a3041 15
		    FREE(temp);

		    if (traversal) {
			/*
			 *  During traversal build up lists of all links
			 *  traversed.	Traversal mode is a special
			 *  feature for traversing http links in the web.
			 */
			if (traversal_link_to_add) {
			    /*
			     *	Add the address we sought to TRAVERSE_FILE.
			     */
			    if (!lookup(traversal_link_to_add))
				add_to_table(traversal_link_to_add);
			    FREE(traversal_link_to_add);
a3042 6
			if (curdoc.address && curdoc.title &&
			    !isLYNXIMGMAP(curdoc.address))
			    /*
			     *	Add the address we got to TRAVERSE_FOUND_FILE.
			     */
			    add_to_traverse_list(curdoc.address, curdoc.title);
d3044 6
a3049 1

d3051 4
a3054 3
		     *	If this was a LYNXDOWNLOAD, we still have curdoc,
		     *	not a newdoc, so reset the address, title and
		     *	positioning elements. - FM
d3056 11
a3066 9
		    if (newdoc.address && curdoc.address &&
			isLYNXDOWNLOAD(newdoc.address)) {
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, (curdoc.title ?
						    curdoc.title : ""));
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
			newdoc.internal_link = FALSE; /* can't be true. - kw */
a3067 1

d3069 3
a3071 12
		     *	Set Newline to the saved line.	It contains the
		     *	line the user was on if s/he has been in the file
		     *	before, or it is 1 if this is a new file.
		     *
		     * We already set Newline before getfile() and probably
		     * update it explicitly if popping from the history stack
		     * via LYpop() or LYpop_num() within getfile() cycle.
		     *
		     * In partial mode, Newline was probably updated in
		     * LYMainLoop_pageDisplay() if user scrolled
		     * the document while loading.
		     * Incremental loading stage already closed in HT*Copy().
d3073 38
a3110 7
#ifdef DISP_PARTIAL
		    /* Newline = newdoc.line; */
		    display_partial = FALSE; /* for sure, LYNXfoo:/ may be a problem */
#else
		    /* Should not be needed either if we remove
		     * "DISP_PARTIAL" from LYHistory.c, but lets leave it
		     * as an important comment for now.
d3112 10
a3121 3
		    Newline = newdoc.line;
#endif

d3123 3
a3125 3
		     *	If we are going to a target line or
		     *	the first page of a popped document,
		     *	override any www_search line result.
d3127 101
a3227 3
		    if (Newline > 1 || popped_doc == TRUE)
			 www_search_result = -1;

d3229 2
a3230 2
		     *	Make sure curdoc.line will not be equal
		     *	to Newline, so we get a redraw.
d3232 23
a3254 21
		    curdoc.line = -1;
		    break;
		}  /* end switch */

	    if (TRACE) {
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert(); /* allow me to look at the results */
		}
	    }

	    /*
	     *	Set the files the same.
	     */
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(curdoc.post_data, newdoc.post_data);
	    StrAllocCopy(curdoc.post_content_type, newdoc.post_content_type);
	    StrAllocCopy(curdoc.bookmark, newdoc.bookmark);
#ifdef USE_COLOR_STYLE
	    StrAllocCopy(curdoc.style, HText_getStyle());
	    if (curdoc.style != NULL)
		style_readFromFile (curdoc.style);
a3255 2
	    curdoc.isHEAD = newdoc.isHEAD;
	    curdoc.internal_link = newdoc.internal_link;
d3257 10
a3266 162
	    /*
	     *	Set the remaining document elements and add to
	     *	the visited links list. - FM
	     */
	    if (ownerS_address != NULL) {
#ifndef USE_PRETTYSRC
		if (HTOutputFormat == WWW_SOURCE && !HText_getOwner())
#else
		if ( (LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
			&& !HText_getOwner() )
#endif
		    HText_setMainTextOwner(ownerS_address);
		FREE(ownerS_address);
	    }
	    if (HText_getTitle()) {
		StrAllocCopy(curdoc.title, HText_getTitle());
	    } else if (!dump_output_immediately) {
		StrAllocCopy(curdoc.title, newdoc.title);
	    }
	    StrAllocCopy(owner_address, HText_getOwner());
	    curdoc.safe = HTLoadedDocumentIsSafe();
	    if (!dump_output_immediately) {
		LYAddVisitedLink(&curdoc);
	    }


	   /*
	    *  Reset WWW present mode so that if we were getting
	    *  the source, we get rendered HTML from now on.
	    */
	   HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	   psrc_view = FALSE;
#endif

	   HTMLSetCharacterHandling(current_char_set);	/* restore, for sure? */

	   /*
	    *  Reset all of the other relevant flags. - FM
	    */
	   LYUserSpecifiedURL = FALSE;	/* only set for goto's and jumps's */
	   LYJumpFileURL = FALSE;	/* only set for jump's */
	   LYNoRefererForThis = FALSE;	/* always reset on return here */
	   reloading = FALSE;		/* set for RELOAD and NOCACHE keys */
	   HEAD_request = FALSE;	/* only set for HEAD requests */
	   LYPermitURL = FALSE;		/* only for LYValidate or check_realm */
	   ForcePush = FALSE;		/* only set for some PRINT requests. */
	   LYforce_HTML_mode = FALSE;
	   force_old_UCLYhndl_on_reload = FALSE;
	   popped_doc = FALSE;
	   pending_form_c = -1;

	} /* end if (LYforce_no_cache || force_load || are_different(...)) */

	if (dump_output_immediately) {
	    if (crawl) {
		print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
	    } else {
		print_wwwfile_to_fd(stdout, FALSE);
	    }
	    return(EXIT_SUCCESS);
	}

	/*
	 *  If the recent_sizechange variable is set to TRUE
	 *  then the window size changed recently.
	 */
	if (recent_sizechange) {
	    /*
	     *  First we need to make sure the display library - curses, slang,
	     *  whatever - gets notified about the change, and gets a chance
	     *  to update external structures appropriately.  Hopefully the
	     *  stop_curses()/start_curses() sequence achieves this, at least
	     *  if the display library has a way to get the new screen size
	     *  from the OS.
	     *  However, at least for ncurses, the update of the internal
	     *  structures will come still too late - the changed screen
	     *  size is detected in doupdate(), which would only be called
	     *  (indirectly through the HText_pageDisplay below) after the
	     *  WINDOW structures are already filled based on the old size.
	     *  So we notify the ncurses library directly here. - kw
	     */
#if defined(NCURSES) && defined(HAVE_RESIZETERM) && defined(HAVE_WRESIZE)
	    resizeterm(LYlines, LYcols);
	    wresize(LYwin, LYlines, LYcols);
#else
#if 0 /* defined(PDCURSES) && defined(HAVE_XCURSES) */
	    resize_term(LYlines, LYcols);
	    if (LYwin != 0)
		LYwin = resize_window(LYwin, LYlines, LYcols);
	    refresh();
#else
	    stop_curses();
	    start_curses();
	    LYclear();
#endif
#endif
	    refresh_screen = TRUE; /* to force a redraw */
	    if (HTMainText)	/* to REALLY force it... - kw */
		HText_setStale(HTMainText);
	    recent_sizechange = FALSE;
	    if (user_mode == NOVICE_MODE) {
		display_lines = LYlines-4;
	    } else {
		display_lines = LYlines-2;
	    }
	}

	if (www_search_result != -1) {
	     /*
	      *  This was a WWW search, set the line
	      *  to the result of the search.
	      */
	     Newline = www_search_result;
	     www_search_result = -1;  /* reset */
	}

	if (first_file == TRUE) {
	    /*
	     *	We can never again have the first file.
	     */
	    first_file = FALSE;

	    /*
	     *	Set the startrealm, and deal as best we can
	     *	with preserving forced HTML mode for a local
	     *	startfile. - FM
	     */
	    temp = HTParse(curdoc.address, "",
			   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
	    if (!temp || *temp == '\0') {
		StrAllocCopy(startrealm, NO_NOTHING);
	    } else {
		StrAllocCopy(startrealm, temp);
		FREE(temp);
		if (!(temp = HTParse(curdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION))) {
		    LYAddHtmlSep(&startrealm);
		} else {
		    if (forced_HTML_mode &&
			!dump_output_immediately &&
			!curdoc.bookmark &&
			isFILE_URL(curdoc.address) &&
			strlen(temp) > 1) {
			/*
			 *  We forced HTML for a local startfile which
			 *  is not a bookmark file and has a path of at
			 *  least two letters.	If it doesn't have a
			 *  suffix mapped to text/html, we'll set the
			 *  entire path (including the lead slash) as a
			 *  "suffix" mapped to text/html to ensure it is
			 *  always treated as an HTML source file.  We
			 *  are counting on a tail match to this full path
			 *  for some other URL fetched during the session
			 *  having too low a probability to worry about,
			 *  but it could happen. - FM
			 */
			HTAtom *encoding;

			if (HTFileFormat(temp, &encoding, NULL) != WWW_HTML) {
			    HTSetSuffix(temp, "text/html", "8bit", 1.0);
			}
d3268 3
a3270 3
		    if ((cp = strrchr(temp, '/')) != NULL) {
			*(cp+1) = '\0';
			StrAllocCat(startrealm, temp);
d3274 4
a3277 3
	    FREE(temp);
	    CTRACE((tfp, "Starting realm is '%s'\n\n", startrealm));
	    if (traversal) {
d3279 1
a3279 1
		 *  Set up the crawl output stuff.
d3281 3
a3283 4
		if (curdoc.address && !lookup(curdoc.address)) {
		    if (!isLYNXIMGMAP(curdoc.address))
			crawl_ok = TRUE;
		    add_to_table(curdoc.address);
d3285 7
d3293 2
a3294 1
		 *  Set up the traversal_host comparison string.
d3296 3
a3298 15
		if (strncmp((curdoc.address ? curdoc.address : "NULL"),
			    "http", 4)) {
		    StrAllocCopy(traversal_host, NO_NOTHING);
		} else if (check_realm) {
		    StrAllocCopy(traversal_host, startrealm);
		} else {
		    temp = HTParse(curdoc.address, "",
				   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
		    if (!temp || *temp == '\0') {
			StrAllocCopy(traversal_host, NO_NOTHING);
		    } else {
			StrAllocCopy(traversal_host, temp);
			LYAddHtmlSep(&traversal_host);
		    }
		    FREE(temp);
d3300 1
a3300 1
		CTRACE((tfp, "Traversal host is '%s'\n\n", traversal_host));
d3302 3
a3304 1
	    if (startfile) {
d3306 1
a3306 3
		 *  If homepage was not equated to startfile,
		 *  make the homepage URL the first goto
		 *  entry. - FM
d3308 3
a3310 16
		if (homepage && strcmp(startfile, homepage))
		    HTAddGotoURL(homepage);
		/*
		 *  If we are not starting up with startfile
		 *  (e.g., had -book), or if we are using the
		 *  startfile and it has no POST content, make
		 *  the startfile URL a goto entry. - FM
		 */
		if (strcmp(startfile, newdoc.address) ||
		    newdoc.post_data == NULL)
		    HTAddGotoURL(startfile);
	    }
	    if (TRACE) {
		refresh_screen = TRUE;
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();
d3312 1
d3314 12
a3325 15
	}

#ifdef SOURCE_CACHE
	/*
	 * If the parse settings have changed since this HText was
	 * generated, we need to reparse and redraw it.  -dsb
	 *
	 * Should be configured to avoid shock for experienced lynx users.
	 * Currently enabled for cached sources only.
	 */
	if (HTdocument_settings_changed()) {
	   if (HTcan_reparse_document()) {
		HTInfoMsg(gettext("Reparsing document under current settings..."));
		reparse_document();
	   } else {
d3327 1
a3327 2
		 * Urk.  I have no idea how to recover from a failure here.
		 * At a guess, I'll try reloading.  -dsb
d3329 5
a3333 5
			/*  currently disabled ***
		HTUserMsg(gettext("Reparsing document under current settings..."));
		cmd = LYK_RELOAD;
		goto new_cmd;
			*/
a3334 28
	}

	if (from_source_cache) {
	    from_source_cache = FALSE; /* reset */
	    curdoc.line = -1 ;  /* so curdoc.line != Newline, see below */
	}
#endif

	/*
	 *  If the curdoc.line is different than Newline then there must
	 *  have been a change since last update.  Run HText_pageDisplay()
	 *  create a fresh screen of text out.
	 *
	 *  If we got new HTMainText go this way.
	 *  All display_partial calls ends here for final redraw.
	 */
	if (curdoc.line != Newline) {
#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;
#endif

	    refresh_screen = FALSE;

	    HText_pageDisplay(Newline, prev_target);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
	      showtags(tagged);
d3338 2
a3339 1
	     *  If more equals TRUE, then there is more info below this page.
d3341 21
a3361 12
	    more = HText_canScrollDown();
	    curdoc.line = Newline = HText_getTopOfScreen()+1;

	    if (curdoc.title == NULL) {
		/*
		 *  If we don't yet have a title, try to get it,
		 *  or set to that for newdoc.title. - FM
		 */
		if (HText_getTitle()) {
		    StrAllocCopy(curdoc.title, HText_getTitle());
		} else {
		    StrAllocCopy(curdoc.title, newdoc.title);
a3363 1

d3365 2
a3366 2
	     *	If the request is to highlight a link which is counted
	     *  from the start of document, correct the link number:
d3368 4
a3371 6
	    if (newdoc_link_is_absolute) {
		newdoc_link_is_absolute = FALSE;
		if (curdoc.line > 1)
		    newdoc.link -= HText_LinksInLines(HTMainText, 1,
						      curdoc.line - 1);
	    }
d3373 2
a3374 1
	    if (arrowup) {
d3376 1
a3376 2
		 *  arrowup is set if we just came up from
		 *  a page below.
d3378 3
a3380 16
		curdoc.link = nlinks - 1;
		arrowup = FALSE;
	    } else {
		curdoc.link = newdoc.link;
		if (curdoc.link >= nlinks) {
		    curdoc.link = nlinks - 1;
		} else if (curdoc.link < 0 && nlinks > 0) {
		    /*
		     *	We may have popped a doc (possibly in local_dired)
		     *	which didn't have any links when it was pushed, but
		     *	does have links now (e.g., a file was created).
		     *  Code below assumes that curdoc.link is valid and
		     *  that (curdoc.link==-1) only occurs if (nlinks==0)
		     *  is true. - KW
		     */
		    curdoc.link = 0;
d3382 1
d3384 18
a3401 16

	    show_help = FALSE; /* reset */
	    newdoc.line = 1;
	    newdoc.link = 0;
	    curdoc.line = Newline; /* set */
	}

	/*
	 *  Refresh the screen if necessary.
	 */
	if (refresh_screen) {
#if defined(FANCY_CURSES) || defined (USE_SLANG)
	    if (enable_scrollback) {
		LYclear();
	    } else {
		LYerase();
a3402 8
#else
	    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
	   HText_pageDisplay(Newline, prev_target);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
d3406 2
a3407 1
	     *  If more equals TRUE, then there is more info below this page.
d3409 4
a3412 1
	    more = HText_canScrollDown();
d3415 2
a3416 6
	     *  Adjust curdoc.link as above; nlinks may have changed,
	     *  if the refresh_screen flag was set as a result of
	     *  a size change.
	     *  Code below assumes that curdoc.link is valid and
	     *  that (curdoc.link==-1) only occurs if (nlinks==0)
	     *  is true. - kw
d3418 2
a3419 5
	    if (curdoc.link >= nlinks) {
		curdoc.link = nlinks - 1;
	    } else if (curdoc.link < 0 && nlinks > 0) {
		curdoc.link = 0;
	    }
d3421 11
a3431 66
	    if (user_mode == NOVICE_MODE)
		noviceline(more);  /* print help message */
	    refresh_screen = FALSE;

	}

	curlink_is_editable =
	    (nlinks > 0 &&
	     links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     F_TEXTLIKE(links[curdoc.link].l_form->type));

	use_last_tfpos = (curlink_is_editable &&
			  (real_cmd == LYK_LPOS_PREV_LINK ||
			   real_cmd == LYK_LPOS_NEXT_LINK));

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (!textfields_need_activation)
	    textinput_activated = TRUE;
#endif

#if defined(WIN_EX)			/* 1997/10/08 (Wed) 14:52:06 */
	if (nlinks > 0) {
	    char *p = "LYNX (unknown link type)";

	    /* Show the URL & kanji code . */
	    if (strlen(links[curdoc.link].lname) == 0) {

	       if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {

		    switch(links[curdoc.link].l_form->type) {
		    case F_TEXT_SUBMIT_TYPE:
		    case F_SUBMIT_TYPE:
		    case F_IMAGE_SUBMIT_TYPE:
			p = "[SUBMIT]";
			break;
		    case F_PASSWORD_TYPE:
			p = "Password";
			break;
		    case F_OPTION_LIST_TYPE:
			p = "Option list";
			break;
		    case F_CHECKBOX_TYPE:
			p = "Check box";
			break;
		    case F_RADIO_TYPE:
			p = "[Radio]";
			break;
		    case F_RESET_TYPE:
			p = "[Reset]";
			break;
		    case F_TEXT_TYPE:
			p = "Text input";
			break;
		    case F_TEXTAREA_TYPE:
			p = "Text input lines";
			break;
		    default:
			break;
		    }
		    set_ws_title(p);
	       }
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    p = curdoc.title;
		} else {
		    p = links[curdoc.link].lname;
d3433 9
d3443 5
a3447 7
		if (strlen(p) < 500) {
		    strcpy(temp_buff, p);
		    if (strchr(temp_buff, '%')) {
			HTUnEscape(temp_buff);
		    }
		    str_sjis(sjis_buff, temp_buff);
		    set_ws_title(LYElideString(sjis_buff, 10));
d3449 1
a3450 11
	} else {
	    if (strlen(curdoc.address) < sizeof(temp_buff)-1) {
		if (user_mode == ADVANCED_MODE) {
		    str_sjis(temp_buff, curdoc.title);
		} else {
		    strcpy(temp_buff, curdoc.address);
		}
		set_ws_title(HTUnEscape(temp_buff));
	    }
	}
#endif /* WIN_EX */
d3452 13
a3464 30
	/*
	 *  Report unread or new mail, if appropriate.
	 */
	if (check_mail && !no_mail)
	    LYCheckMail();

	/*
	 *  If help is not on the screen,
	 *  then put a message on the screen
	 *  to tell the user other misc info.
	 */
	if (!show_help) {
	   show_main_statusline(links[curdoc.link],
				(curlink_is_editable && textinput_activated) ?
				FOR_INPUT : FOR_PANEL);
	} else {
	   show_help = FALSE;
	}

	if (nlinks > 0) {
	     /*
	      *  Highlight current link, unless it is an active
	      *  text input field.
	      */
	    if (!curlink_is_editable) {
		LYhighlight(ON, curdoc.link, prev_target);
#ifndef INACTIVE_INPUT_STYLE_VH
	    } else if (!textinput_activated) {
		LYhighlight(ON, curdoc.link, prev_target);
#endif
a3465 1
	}
a3466 1
	if (traversal) {
d3468 1
a3468 2
	     *	Don't go interactively into forms,
	     *	or accept keystrokes from the user
d3470 11
a3480 27
	    if (crawl && crawl_ok) {
		crawl_ok = FALSE;
#ifdef FNAMES_8_3
		sprintf(cfile,"lnk%05d.dat",ccount);
#else
		sprintf(cfile,"lnk%08d.dat",ccount);
#endif /* FNAMES_8_3 */
		ccount = ccount + 1;
		if ((cfp = LYNewTxtFile(cfile))  != NULL) {
		    print_crawl_to_fd(cfp,curdoc.address,curdoc.title);
		    LYCloseOutput(cfp);
		} else {
		    if (!dump_output_immediately)
			cleanup();
#ifdef UNIX
		    if (dump_output_immediately)
			fprintf(stderr,
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    else
#endif
			printf(
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    if (!dump_output_immediately) {
			exit_immediately(EXIT_FAILURE);
		    }
		    return(EXIT_FAILURE);
		}
d3482 2
a3483 1
	} else {
d3485 1
a3485 1
	     *	Normal, non-traversal handling.
d3487 15
a3501 6

	    if (curlink_is_editable &&
		(textinput_activated || pending_form_c != -1)) {
		if (pending_form_c != -1) {
		    real_c = pending_form_c;
		    pending_form_c = -1;
d3504 1
a3504 1
		     *  Replace novice lines if in NOVICE_MODE.
d3506 1
a3506 6
		    if (user_mode==NOVICE_MODE) {
			form_noviceline(links[curdoc.link].l_form->disabled);
		    }
		    real_c = change_form_link(curdoc.link,
				     &newdoc, &refresh_screen,
				     use_last_tfpos, FALSE);
d3508 1
a3508 127
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation)
		    textinput_activated = FALSE;
#ifdef INACTIVE_INPUT_STYLE_VH
		textinput_redrawn = FALSE;
#endif
#endif

		c = (real_c==LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
		if (c != DO_NOTHING &&
		    peek_mouse_link() != -1 && peek_mouse_link() != -2)
		    old_c = 0;
		if (peek_mouse_link() >= 0 &&
		    LKC_TO_LAC(keymap,real_c) != LYK_CHANGE_LINK) {
		    do_change_link();
		    if ((c == '\n' || c == '\r') &&
			links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
			!textfields_need_activation) {
			c = DO_NOTHING;
		    }
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		} else if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
			   && textfields_need_activation
			   && !links[curdoc.link].l_form->disabled
			   && peek_mouse_link() < 0 &&
			   (((LKC_TO_LAC(keymap,real_c) == LYK_NEXT_LINK ||
#ifdef TEXTAREA_AUTOGROW
			      LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE ||
#endif
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks-1 &&
			       links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link+1].l_form->number) &&
			       strcmp(links[curdoc.link].l_form->name,
				      links[curdoc.link+1].l_form->name) == 0) ||
			      (curdoc.link == nlinks-1 && more &&
			       HText_TAHasMoreLines(curdoc.link, 1)))) ||
			    ((LKC_TO_LAC(keymap,real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_UP_LINK) &&
			     ((curdoc.link > 0 &&
			       links[curdoc.link-1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link-1].l_form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link-1].l_form->number) &&
			       strcmp(links[curdoc.link].l_form->name,
				      links[curdoc.link-1].l_form->name) == 0) ||
			      (curdoc.link == 0 && curdoc.line > 1 &&
			       HText_TAHasMoreLines(curdoc.link, -1)))))) {
		    textinput_activated = TRUE;
#ifdef TEXTAREA_AUTOGROW
		    if ((c == '\n' || c == '\r') &&
			LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE)
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
#endif /* TEXTAREA_AUTOGROW */
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION */
		} else
		    switch (c) {
		    case '\n':
		    case '\r':
#ifdef TEXTAREA_AUTOGROW
		    /*
		     *  If on the bottom line of a TEXTAREA, and the user hit
		     *  the ENTER key, we add a new line/anchor automatically,
		     *  positioning the cursor on it.
		     *
		     *  If at the bottom of the screen, we effectively perform
		     *  an LYK_DOWN_HALF-like operation, then move down to the
		     *  new line we just added.  --KED  02/14/99
		     *
		     *  [There is some redundancy and non-standard indentation
		     *   in the monster-if() below.  This is intentional ... to
		     *   try and improve the "readability" (such as it is).
		     *   Caveat emptor to anyone trying to change it.]
		     */
		    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			 links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) &&
			((curdoc.link == nlinks-1 &&
			  !(more && HText_TAHasMoreLines(curdoc.link, 1)))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  !(links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  ((links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE)
			    &&
			    ((links[curdoc.link].l_form->number	       !=
				      links[curdoc.link+1].l_form->number) ||
			     (strcmp (links[curdoc.link].l_form->name,
				      links[curdoc.link+1].l_form->name) != 0)))))) {

			HText_ExpandTextarea (&links[curdoc.link], 1);

			if (links[curdoc.link].ly < display_lines) {
			    refresh_screen = TRUE;

			} else {

			    Newline += (display_lines/2);
			    if (nlinks > 0 && curdoc.link > -1 &&
				links[curdoc.link].ly > display_lines/2) {
				    newdoc.link = curdoc.link;
				    for (i = 0; links[i].ly <= (display_lines/2); i++)
					--newdoc.link;
				    newdoc.link++;
			    }
			}
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			if (textfields_need_activation) {
			    textinput_activated = TRUE;
			    textfields_need_activation = textfields_activation_option;
#ifdef INACTIVE_INPUT_STYLE_VH
			    textinput_redrawn = TRUE;
#endif
			};
#endif

		   }
#endif /* TEXTAREA_AUTOGROW */

d3510 1
a3510 4
		     *	Make return in input field (if it was returned
		     *  by change_form_link) act as LYK_NEXT_LINK,
		     *  independent of what key (if any) is mapped to
		     *  LYK_NEXT_LINK. - kw
d3512 10
a3521 19
		    c = LAC_TO_LKC0(LYK_NEXT_LINK);
		    break;
		default:

		    if (old_c != c && old_c != real_c && c != real_c)
			real_c = c;
		}
	    } else {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
		if (curlink_is_editable && !textinput_redrawn) {
		/*draw the text entry, but don't activate it*/
		    textinput_redrawn = TRUE;
		    change_form_link_ex(curdoc.link,
				    &newdoc, &refresh_screen,
				    use_last_tfpos, FALSE, TRUE);
		    if (LYShowCursor) {
			LYmove(links[curdoc.link].ly,
			     ((links[curdoc.link].lx > 0) ?
			      (links[curdoc.link].lx - 1) : 0));
d3523 13
a3535 1
			LYHideCursor();
d3537 1
d3539 8
a3546 14
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
		/*
		 *  Get a keystroke from the user.
		 *  Save the last keystroke to avoid
		 *  redundant error reporting.
		 */
		real_c = c = LYgetch(); /* get user input */

		if (c != last_key)
		    key_count = 0;
		key_count++;
		last_key = c;
#ifndef VMS
		if (c == 3) {		/* ^C */
d3548 1
a3548 2
		     *	This shouldn't happen.	We'll try to
		     *	deal with whatever bug caused it. - FM
d3550 1
a3550 4
		    signal(SIGINT, cleanup_sig);
		    old_c = 0;
		    cmd = LYK_QUIT;
		    goto new_cmd;
d3552 1
a3552 2
#endif /* !VMS */
		if (LKC_HAS_ESC_MOD(c) && EditBinding(c) != LYE_FORM_PASS) {
d3554 1
a3554 8
		     *  If ESC + <key> was read (and not recognized as a
		     *  terminal escape sequence for another key), ignore
		     *  the ESC modifier and act on <key> only if the line
		     *  editor binding would have passed the same ESC-modified
		     *  lynxkeycode back to us if it had been pressed in a
		     *  text input field.  Otherwise set interesting part
		     *  so that it will map to 0, to prevent that ESC + <key>
		     *  acts like <key>, which might be unexpected. - kw
d3556 26
a3581 1
		    c = (c & ~LKC_MASK) | LAC_TO_LKC(0);
d3583 10
a3592 2
		if (old_c != real_c) {
		    old_c = 0;
d3594 1
d3596 12
a3607 1
	}
d3609 7
a3615 11
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = DO_NOTHING;
	}
#else
	if (recent_sizechange) {
	    if (c <= 0)
		c = DO_NOTHING;
	}
#endif /* VMS */
d3617 44
a3660 9
new_keyboard_input:
	/*
	 *  A goto point for new input without going
	 *  back through the getch() loop.
	 */
	if (traversal) {
	    if ((c = DoTraversal(c, &crawl_ok)) < 0)
		return (EXIT_FAILURE);
	} /* traversal */
d3662 8
a3669 4
#ifdef WIN_EX
	if (c == DO_NOTHING)
	    cmd = LYK_DO_NOTHING;
	else
a3670 1
	cmd = LKC_TO_LAC(keymap,c);  /* adds 1 to map EOF to 0 */
d3672 3
a3674 4
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override,c))
	  cmd = LKC_TO_LAC(key_override,c);
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
d3676 26
a3701 1
	real_cmd = cmd;
d3703 26
a3728 14
new_cmd:  /*
	   *  A goto point for new input without going
	   *  back through the getch() loop.
	   */

	force_old_UCLYhndl_on_reload = FALSE;
	CTRACE_FLUSH(tfp);

	if (cmd != LYK_UP_LINK && cmd != LYK_DOWN_LINK)
	    follow_col = -1;

	switch(cmd) {
	case -1:
	    HTUserMsg(COMMAND_UNKNOWN);
a3729 5
	case 0: /* unmapped character */
	default:
	    if (curdoc.link >= 0 && curdoc.link < nlinks &&
		links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {
d3731 16
a3746 20
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation) {
		    show_main_statusline(links[curdoc.link], FOR_PANEL);
#ifdef INACTIVE_INPUT_STYLE_VH
		    textinput_redrawn = FALSE;
#endif
		} else
#endif
		    show_main_statusline(links[curdoc.link], FOR_INPUT);
	    } else if (more) {
		HTInfoMsg(MOREHELP);
	    } else {
		HTInfoMsg(HELP);
	    }
	    show_help = TRUE;

	    if (TRACE) {
		sprintf(cfile, "%d", c);
		LYaddstr(cfile);	/* show the user input */
		cfile[0] = '\0';
d3750 1
a3750 5
	case LYK_COMMAND:
	    cmd = handle_LYK_COMMAND(user_input_buffer);
	    goto new_cmd;

	case LYK_INTERRUPT:
d3752 1
a3752 1
	     *	No network transmission to interrupt - 'til we multithread.
d3754 1
a3754 1
	    break;
d3756 5
a3760 15
	case LYK_F_LINK_NUM:
	     c = '\0';
	     /* FALLTHRU */
	case LYK_1: /* FALLTHRU */
	case LYK_2: /* FALLTHRU */
	case LYK_3: /* FALLTHRU */
	case LYK_4: /* FALLTHRU */
	case LYK_5: /* FALLTHRU */
	case LYK_6: /* FALLTHRU */
	case LYK_7: /* FALLTHRU */
	case LYK_8: /* FALLTHRU */
	case LYK_9:
	    handle_LYK_digit(c, &force_load, user_input_buffer,
			     &old_c, real_c, &try_internal);
	    break;
d3762 11
a3772 2
	case LYK_SOURCE:  /* toggle view source mode */
	    handle_LYK_SOURCE(&ownerS_address);
d3775 5
a3779 1
	case LYK_CHG_CENTER:	/* ^Q */
d3781 15
a3795 3
	    if (no_table_center) {
		no_table_center = FALSE;
		HTInfoMsg(gettext("TABLE center enable."));
d3797 4
a3800 2
		no_table_center = TRUE;
		HTInfoMsg(gettext("TABLE center disable."));
a3801 4
	    /* FALLTHRU */

	case LYK_RELOAD:  /* control-R to reload and refresh */
	    handle_LYK_RELOAD(real_cmd);
d3804 122
a3925 30
	case LYK_HISTORICAL:	/* toggle 'historical' comments parsing */
	    handle_LYK_HISTORICAL();
	    break;

	case LYK_MINIMAL:	/* toggle 'minimal' comments parsing */
	    handle_LYK_MINIMAL();
	    break;

	case LYK_SOFT_DQUOTES:
	    handle_LYK_SOFT_DQUOTES();
	    break;

	case LYK_SWITCH_DTD:
	    handle_LYK_SWITCH_DTD();
	    break;

	case LYK_QUIT:		/* quit */
	    if (handle_LYK_QUIT())
		return(EXIT_SUCCESS);
	    break;

	case LYK_ABORT:		/* don't ask the user about quitting */
	    return(EXIT_SUCCESS);

	case LYK_NEXT_PAGE:	/* next page */
	    handle_LYK_NEXT_PAGE(&old_c, real_c);
	    break;

	case LYK_PREV_PAGE:	/* page up */
	    handle_LYK_PREV_PAGE(&old_c, real_c);
d3927 19
d3947 19
a3965 2
	case  LYK_UP_TWO:
	    handle_LYK_UP_TWO(&arrowup, &old_c, real_c);
d3968 74
a4041 2
	case  LYK_DOWN_TWO:
	    handle_LYK_DOWN_TWO(&old_c, real_c);
d4044 13
a4056 3
	case  LYK_UP_HALF:
	    handle_LYK_UP_HALF(&arrowup, &old_c, real_c);
	    break;
d4058 22
a4079 3
	case  LYK_DOWN_HALF:
	    handle_LYK_DOWN_HALF(&old_c, real_c);
	    break;
d4081 26
a4106 28
#ifdef CAN_CUT_AND_PASTE
	case LYK_TO_CLIPBOARD:	/* ^S */
	    {
		char *s;
		int ch2;

		/* The logic resembles one of ADD_BOOKMARK */
		if (nlinks > 0 && links[curdoc.link].lname
		    && links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    /* Makes sense to copy a link */
		    _statusline("Copy D)ocument's or L)ink's URL to clipboard or C)ancel?");
		    ch2 = LYgetch_single();
		    if (ch2 == 'D')
			s = curdoc.address;
		    else if (ch2 == 'C')
			break;
		    else
			s = links[curdoc.link].lname;
		} else
		    s = curdoc.address;
		if (isEmpty(s))
		    HTInfoMsg(gettext("Current URL is empty."));
		if (put_clip(s))
		    HTInfoMsg(gettext("Copy to clipboard failed."));
		else if (s == curdoc.address)
		    HTInfoMsg(gettext("Document URL put to clipboard."));
		else
		    HTInfoMsg(gettext("Link URL put to clipboard."));
d4108 2
d4112 12
a4123 3
	case LYK_PASTE_URL:
	    if (no_goto && !LYValidate) { /*  Go to not allowed. - FM */
		HTUserMsg(GOTO_DISALLOWED);
d4125 8
a4132 3
		unsigned char *s = get_clip_grab(), *e, *t;
		char *buf;
		int len2;
d4134 53
a4186 40
		if (!s)
		    break;
		len2 = strlen(s);
		e = s + len2;
		while (s < e && strchr(" \t\n\r", *s))
		    s++;
		while (s < e && strchr(" \t\n\r", e[-1]))
		    e--;
		if (s[0] == '<' && e > s && e[-1] == '>') {
		    s++; e--;
		    if (!strncasecomp(s,"URL:", 4))
			s += 4;
		}
		if (s >= e) {
		    HTInfoMsg(gettext("No URL in the clipboard."));
		    break;
		}
		len = e - s + 1;
		if (len < MAX_LINE)
		    len = MAX_LINE;	/* Required for do_check_goto_URL() */
		buf = (char*)malloc(len);
		strncpy(buf, s, e - s);
		buf[e - s] = '\0';
		t = buf;

		while (s < e) {
		    if (strchr(" \t\n\r", *s)) {
			int nl2 = 0;	/* Keep whitespace without NL - file names! */
			unsigned char *s1 = s;

			while (strchr(" \t\n\r", *s)) {
			    if (!nl2 && *s == '\n')
				nl2 = 1;
			    s++;
			}
			if (!nl2) {
			    while (s1 < s) {
				if (*s1 != '\r' && *s1 != '\r')
				    *t = *s1;
				t++, s1++;
d4189 15
a4203 2
		    } else
			*t++ = *s++;
a4204 4
		*t = '\0';
		get_clip_release();
		do_check_goto_URL(buf, &temp, &force_load);
		free(buf);
a4206 1
#endif
d4208 9
a4216 14
#ifdef KANJI_CODE_OVERRIDE
	case LYK_CHG_KCODE:	/* ^L */
	    if (LYRawMode && (HTCJK == JAPANESE)) {
		switch(last_kcode) {
		case NOKANJI:
		    last_kcode = SJIS;
		    break;
		case SJIS:
		    last_kcode = EUC;
		    break;
		case EUC:
		    last_kcode = NOKANJI;
		    break;
		default:
d4218 34
a4253 5
	    LYmove(0, 0);
	    lynx_start_title_color ();
	    LYaddstr(str_kcode(last_kcode));
	    lynx_stop_title_color ();

a4254 1
#endif
d4256 3
a4258 4
	case LYK_REFRESH:
	    refresh_screen = TRUE;
	    lynx_force_repaint();
	    break;
d4260 17
a4276 6
	case LYK_HOME:
	    if (curdoc.line > 1)
		Newline = 1;
	    else {
		cmd = LYK_PREV_PAGE;
		goto new_cmd;
d4280 15
a4294 8
	case LYK_END:
	    i = HText_getNumOfLines() - display_lines + 2;
	    if (i >= 1 && Newline != i) {
		Newline = i;		/* go to end of file */
		arrowup = TRUE;		/* position on last link */
	    } else {
		cmd = LYK_NEXT_PAGE;
		goto new_cmd;
d4297 1
d4299 17
a4315 24
	case LYK_FIRST_LINK:
	    handle_LYK_FIRST_LINK();
	    break;

	case LYK_LAST_LINK:
	    handle_LYK_LAST_LINK();
	    break;

	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	    handle_LYK_PREV_LINK(&arrowup, &old_c, real_c);
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	    handle_LYK_NEXT_LINK(c, &old_c, real_c);
	    break;

	case LYK_FASTFORW_LINK:
	    handle_LYK_FASTFORW_LINK(&old_c, real_c);
	    break;

	case LYK_FASTBACKW_LINK:
	    if (handle_LYK_FASTBACKW_LINK(&cmd, &old_c, real_c))
d4317 1
a4317 1
	    break;
d4319 17
a4335 3
	case LYK_UP_LINK:
	    handle_LYK_UP_LINK(&follow_col, &arrowup, &old_c, real_c);
	    break;
d4337 13
a4349 3
	case LYK_DOWN_LINK:
	    handle_LYK_DOWN_LINK(&follow_col, &old_c, real_c);
	    break;
d4351 55
a4405 7
	case LYK_CHANGE_LINK:
	    do_change_link();
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	    if (textfields_need_activation)
		textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    break;
d4407 6
a4412 2
	case LYK_RIGHT_LINK:
	    handle_LYK_RIGHT_LINK();
d4415 36
a4450 2
	case LYK_LEFT_LINK:
	    handle_LYK_LEFT_LINK();
d4453 4
a4456 3
	case LYK_COOKIE_JAR:	/* show the cookie jar */
	    if (handle_LYK_COOKIE_JAR(&cmd))
		goto new_cmd;
d4458 1
d4460 24
a4483 10
	case LYK_HISTORY:	/* show the history page */
	    if (handle_LYK_HISTORY(ForcePush))
		break;

	    /* FALLTHRU */
	case LYK_PREV_DOC:	/* back up a level */
	    switch (handle_PREV_DOC(&cmd, &old_c, real_c)) {
	    case 1:
		return(EXIT_SUCCESS);
	    case 2:
d4488 6
a4493 6
	case LYK_NEXT_DOC:	/* undo back up a level */
	    handle_NEXT_DOC();
	    break;

	case LYK_NOCACHE: /* Force submission of form or link with no-cache */
	    if (!handle_LYK_NOCACHE(&old_c, real_c))
a4494 11

	    /* FALLTHRU */
	case LYK_ACTIVATE:	/* follow a link */
	case LYK_SUBMIT:	/* follow a link, submit TEXT_SUBMIT input */
	    switch (handle_LYK_ACTIVATE(&c, cmd, &try_internal, &refresh_screen, &force_load, real_cmd)) {
	    case 1:
		continue;
	    case 2:
		goto new_keyboard_input;
	    case 3:
		pending_form_c = c;
a4495 1
	    break;
d4497 5
a4501 4
	case LYK_ELGOTO:	/* edit URL of current link and go to it  */
	    if (handle_LYK_ELGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    break;
d4503 2
a4504 4
	case LYK_ECGOTO:	/* edit current URL and go to to it	*/
	    if (handle_LYK_ECGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    break;
d4506 1
a4506 9
	case LYK_GOTO:		/* 'g' to goto a random URL  */
	    if (handle_LYK_GOTO(&ch, user_input_buffer, &temp, &recall,
				&URLTotal, &URLNum, &FirstURLRecall, &old_c,
				real_c)) {
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    }
	    break;
d4508 8
a4515 3
	case LYK_DWIMHELP:	/* show context-dependent help file */
	    handle_LYK_DWIMHELP(&cshelpfile);
	    /* FALLTHRU */
d4517 2
a4518 3
	case LYK_HELP:		/* show help file */
	    handle_LYK_HELP(&cshelpfile);
	    break;
d4520 3
a4522 3
	case LYK_INDEX:		/* index file */
	    handle_LYK_INDEX(&old_c, real_c);
	    break;
d4524 1
a4524 3
	case LYK_MAIN_MENU:	/* return to main screen */
	    handle_LYK_MAIN_MENU(&old_c, real_c);
	    break;
d4526 2
a4527 9
#ifdef EXP_NESTED_TABLES
	case LYK_NESTED_TABLES:
	    if (handle_LYK_NESTED_TABLES(&cmd))
		goto new_cmd;
	    break;
#endif
	case LYK_OPTIONS:	/* options screen */
	    if (handle_LYK_OPTIONS(&cmd, &refresh_screen))
		goto new_cmd;
d4530 6
a4535 3
	case LYK_INDEX_SEARCH:	/* search for a user string */
	    handle_LYK_INDEX_SEARCH(&force_load, ForcePush, &old_c, real_c);
	    break;
d4537 1
a4537 5
	case LYK_WHEREIS:	/* search within the document */
	case LYK_NEXT:		/* find the next occurrence in the document */
	case LYK_PREV:		/* find the previous occurrence in the document */
	    handle_LYK_WHEREIS(cmd, &refresh_screen);
	    break;
d4539 1
a4539 3
	case LYK_COMMENT:	/* reply by mail */
	    handle_LYK_COMMENT(&refresh_screen, &owner_address, &old_c, real_c);
	    break;
d4541 1
a4541 4
#ifdef DIRED_SUPPORT
	case LYK_TAG_LINK:	/* tag or untag the current link */
	    handle_LYK_TAG_LINK();
	    break;
d4543 2
a4544 2
	case LYK_MODIFY:	/* rename a file or directory */
	    handle_LYK_MODIFY(&refresh_screen);
d4547 6
a4552 4
	case LYK_CREATE:	/* create a new file or directory */
	    handle_LYK_CREATE();
	    break;
#endif /* DIRED_SUPPORT */
d4554 1
a4554 8
	case LYK_DWIMEDIT:	/* context-dependent edit */
	    switch (handle_LYK_DWIMEDIT(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
	    }
	    /* FALLTHRU */
d4556 12
a4567 3
	case LYK_EDIT:		/* edit */
	    handle_LYK_EDIT(&old_c, real_c);
	    break;
d4569 1
a4569 3
	case LYK_DEL_BOOKMARK:	/* remove a bookmark file link */
	    handle_LYK_DEL_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;
d4571 1
a4571 5
#ifdef DIRED_SUPPORT
	case LYK_REMOVE:	/* remove files and directories */
	    handle_LYK_REMOVE(&refresh_screen);
	    break;
#endif /* DIRED_SUPPORT */
d4573 2
a4574 3
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
	case LYK_INSTALL:	/* install a file into system area */
	    handle_LYK_INSTALL();
a4575 1
#endif /* DIRED_SUPPORT && OK_INSTALL */
d4577 8
a4584 4
	case LYK_INFO:		/* show document info */
	    if (handle_LYK_INFO(&cmd))
		goto new_cmd;
	    break;
d4586 5
a4590 3
	case LYK_EDIT_TEXTAREA: /* use external editor on a TEXTAREA - KED */
	    handle_LYK_EDIT_TEXTAREA(&refresh_screen, &old_c, real_c);
	    break;
d4592 14
a4605 2
	case LYK_GROW_TEXTAREA:	/* add new lines to bottom of TEXTAREA - KED */
	    handle_LYK_GROW_TEXTAREA(&refresh_screen);
d4608 12
a4619 3
	case LYK_INSERT_FILE:	/* insert file in TEXTAREA, above cursor - KED */
	    handle_LYK_INSERT_FILE(&refresh_screen, &old_c, real_c);
	    break;
d4621 12
a4632 3
	case LYK_PRINT:		/* print the file */
	    handle_LYK_PRINT(&ForcePush, &old_c, real_c);
	    break;
d4634 5
a4638 3
	case LYK_LIST:		/* list links in the current document */
	    if (handle_LYK_LIST(&cmd))
		goto new_cmd;
d4642 10
a4651 2
	case LYK_ADDRLIST:	/* always list URL's (only) */
	    if (handle_LYK_ADDRLIST(&cmd))
d4653 20
d4677 6
a4682 1
	    if (handle_LYK_VLINKS(&cmd, &newdoc_link_is_absolute))
d4684 21
d4708 22
a4729 1
	    handle_LYK_TOOLBAR(&try_internal, &force_load, &old_c, real_c);
d4734 127
a4860 1
	    handle_LYK_DIRED_MENU(&refresh_screen, &old_c, real_c);
d4862 1
d4866 6
a4871 5
	case LYK_EXTERN_LINK:	/* use external program on url */
	    handle_LYK_EXTERN_LINK(&refresh_screen);
	    break;
	case LYK_EXTERN_PAGE:	/* use external program on current page */
	    handle_LYK_EXTERN_PAGE(&refresh_screen);
d4876 162
a5037 1
	    handle_LYK_ADD_BOOKMARK(&refresh_screen, &old_c, real_c);
d5040 38
a5077 2
	case LYK_VIEW_BOOKMARK:	/* v to view home page */
	    handle_LYK_VIEW_BOOKMARK(&refresh_screen, &old_c, real_c);
d5080 13
a5092 2
	case LYK_SHELL:		/* (!) shell escape */
	    handle_LYK_SHELL(&refresh_screen, &old_c, real_c);
d5096 211
a5306 5
	    switch (handle_LYK_DOWNLOAD(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
d5312 25
a5336 1
	    handle_LYK_UPLOAD();
d5341 3
a5343 1
	    handle_LYK_TRACE_TOGGLE();
d5347 42
a5388 1
	    handle_LYK_TRACE_LOG(&trace_mode_flag);
d5392 14
a5405 3
	    if (handle_LYK_IMAGE_TOGGLE(&cmd))
		goto new_cmd;
	    break;
d5408 14
a5421 3
	    if (handle_LYK_INLINE_TOGGLE(&cmd))
		goto new_cmd;
	    break;
d5424 13
a5436 1
	    if (handle_LYK_RAW_TOGGLE(&cmd))
d5438 1
a5438 1
	    break;
d5441 122
a5562 2
	    if (handle_LYK_HEAD(&cmd))
		goto new_cmd;
d5566 4
a5569 1
	    handle_LYK_TOGGLE_HELP();
d5573 31
a5603 1
	    handle_LYK_KEYMAP(&vi_keys_flag, &emacs_keys_flag, &old_c, real_c);
d5607 56
a5662 6
	    if (handle_LYK_JUMP(c, user_input_buffer, &temp, &recall,
				    &FirstURLRecall, &URLNum, &URLTotal, &ch,
				    &old_c, real_c)) {
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
d5667 19
a5685 1
	    handle_LYK_CLEAR_AUTH(&old_c, real_c);
d5690 1
a5690 17
#ifdef SUPPORT_CHDIR
	case LYK_CHDIR:
	    handle_LYK_CHDIR();
	    break;
#endif
#ifdef USE_CURSES_PADS
	case LYK_SHIFT_LEFT:
	    handle_LYK_SHIFT_LEFT(&refresh_screen, key_count);
	    break;
	case LYK_SHIFT_RIGHT:
	    handle_LYK_SHIFT_RIGHT(&refresh_screen, key_count);
	    break;
	case LYK_LINEWRAP_TOGGLE:
	    if (handle_LYK_LINEWRAP_TOGGLE(&cmd, &refresh_screen))
		goto new_cmd;
	    break;
#endif
d5695 82
d5778 2
a5779 2
	DocInfo *,	doc1,
	DocInfo *,	doc2)
d5800 4
a5803 2
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
d5807 6
a5812 3
    if (strcmp(doc1->address, doc2->address)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
d5814 5
a5818 3
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);
d5823 5
a5827 3
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
d5829 6
a5834 1
	} else
a5835 2
    } else if (doc2->post_data)
	return(TRUE);
d5848 2
a5849 2
	DocInfo *,	doc1,
	DocInfo *,	doc2)
d5868 4
a5871 4
    if (isLYNXIMGMAP(doc1->address))
	ap1 += LEN_LYNXIMGMAP;
    if (isLYNXIMGMAP(doc2->address))
	ap2 += LEN_LYNXIMGMAP;
d5885 4
a5888 2
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
d5892 6
a5897 3
    if (strcmp(ap1, ap2)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
d5899 5
a5903 3
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);
d5908 5
a5912 3
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
d5914 6
a5919 1
	} else
a5920 2
    } else if (doc2->post_data)
	return(TRUE);
d5932 1
a5932 2
#ifdef LY_FIND_LEAKS
PRIVATE void HTGotoURLs_free NOARGS
d5937 5
a5941 6
    if (cur != 0) {
	while (NULL != (url = (char *)HTList_nextObject(cur))) {
	    FREE(url);
	}
	HTList_delete(Goto_URLs);
	Goto_URLs = NULL;
d5943 3
a5946 1
#endif
d5955 1
a5955 1
    char *new = NULL;
d5962 3
a5964 2
    CTRACE((tfp, "HTAddGotoURL %s\n", url));
    StrAllocCopy(new, url);
d5993 3
a5995 3
PRIVATE void show_main_statusline ARGS2(
    CONST LinkInfo,	curlink,
    int,		for_what)
d6000 1
a6000 1
    if (user_mode == NOVICE_MODE && for_what != FOR_INPUT) {
d6004 4
a6013 4
    /*
     *	If we are in forms mode then explicitly
     *	tell the user what each kind of link is.
     */
d6027 103
a6129 1
	    show_formlink_statusline(curlink.l_form, for_what);
d6138 1
a6138 2
	    char *indx = gettext("-index-");
	    LYmove(LYlines-1, LYcols - strlen(indx) - 1);
d6140 1
a6140 1
	    LYaddstr(indx);
d6148 1
a6148 2
	char *cp = NULL;

d6150 16
a6165 2
	    !isLYNXIMGMAP(curlink.lname)) {
	    cp = findPoundSelector(curlink.lname);
a6166 3
	if (!cp)
	    cp = curlink.lname;
	status_link(cp, more, is_www_index);
d6179 1
a6179 1
	    _statusline(MORE);
d6181 1
a6181 1
	    _statusline(MOREHELP);
a6184 1

d6186 1
a6186 19
    /* But not if LYShowCursor is on.  -show_cursor may be used as a
     * workaround to avoid putting the cursor in the last position, for
     * curses implementations or terminals that cannot deal with that
     * correctly. - kw */
    if (!LYShowCursor) {
	LYHideCursor();
    }
}

/*
 *  Public function for redrawing the statusline appropriate for the
 *  selected link.  It should only be called at times when curdoc.link,
 *  nlinks, and the links[] array are valid. - kw
 */
PUBLIC void repaint_main_statusline ARGS1(
    int,	for_what)
{
    if (curdoc.link >= 0 && curdoc.link < nlinks)
	show_main_statusline(links[curdoc.link], for_what);
a6188 32
PRIVATE void form_noviceline ARGS1(
    int,	disabled)
{
    LYmove(LYlines-2,0); LYclrtoeol();
    if (!disabled) {
	LYaddstr(FORM_NOVICELINE_ONE);
    }
    LYmove(LYlines-1,0); LYclrtoeol();
    if (disabled)
	return;
    if (EditBinding(FROMASCII('\025')) == LYE_ERASE) {
	LYaddstr(FORM_NOVICELINE_TWO);
    } else if (EditBinding(FROMASCII('\025')) == LYE_DELBL) {
	LYaddstr(FORM_NOVICELINE_TWO_DELBL);
    } else {
	char *temp = NULL;
	char *erasekey = fmt_keys(LYKeyForEditAction(LYE_ERASE), -1);
	if (erasekey) {
	    HTSprintf0(&temp, FORM_NOVICELINE_TWO_VAR, erasekey);
	} else {
	    erasekey = fmt_keys(LYKeyForEditAction(LYE_DELBL), -1);
	    if (erasekey)
		HTSprintf0(&temp,
			   FORM_NOVICELINE_TWO_DELBL_VAR, erasekey);
	}
	if (temp) {
	    LYaddstr(temp);
	    FREE(temp);
	}
	FREE(erasekey);
    }
}
d6205 1
a6205 1
		   NonNull(buf2),
d6211 1
a6211 2
		   (buf2 && strstr(buf2, gettext("Can't Access"))) ?
							       "" : startfile);
d6217 1
a6217 1
		   NonNull(buf2),
d6229 1
a6229 1
	fputs(buf, stderr);
d6234 1
a6234 1
	fputs(buf, stdout);
d6241 1
a6241 28
	exit_immediately(EXIT_FAILURE);
    }
    /* else: return(EXIT_FAILURE) in mainloop */
}


PRIVATE void status_link ARGS3(
	char *,		curlink_name,
	BOOLEAN,	show_more,
	BOOLEAN,	show_indx)
{
#define MAX_STATUS (LYcols - 2)
#define MIN_STATUS 0
    char format[MAX_LINE];
    int prefix = 0;
    int length;

    *format = 0;
    if (show_more) {
	sprintf(format, "%.*s ",
		(int)(sizeof(format) - 2),
		gettext("-more-"));
	prefix = strlen(format);
    }
    if (show_indx) {
	sprintf(format + prefix, "%.*s ",
		(int)(sizeof(format) - prefix - 2),
		gettext("-index-"));
d6243 1
a6243 56
    prefix = strlen(format);
    length = strlen(curlink_name);

    if (prefix > MAX_STATUS || prefix >= MAX_LINE - 1) {
	_user_message("%s", format);	/* no room for url */
    } else {
	sprintf(format + prefix, "%%.%ds", MAX_STATUS - prefix);

	if ((length + prefix > MAX_STATUS) && long_url_ok) {
	    char *buf = NULL;
	    int cut_from_pos;
	    int cut_to_pos;
	    int n;

	    StrAllocCopy(buf, curlink_name);
	    /*
	     *  Scan to find the final leaf of the URL.
	     *  Ignore trailing '/'.
	     */
	    for (cut_to_pos = length - 2;
		 (cut_to_pos > 0) && (buf[cut_to_pos] != '/');
		 cut_to_pos--)
		 ;
	    /*
	     *  Jump back to the next leaf to remove.
	     */
	    for (cut_from_pos = cut_to_pos - 4;
		 (cut_from_pos > 0) && ((buf[cut_from_pos] != '/')
		 || (prefix + cut_from_pos + 4 + (length - cut_to_pos) >= MAX_STATUS));
		 cut_from_pos--)
		 ;
	    /*
	     *  Replace some leaves to '...', if possible, and put the
	     *  final leaf at the end. We assume that one can recognize
	     *  the link from at least MIN_STATUS characters.
	     */
	    if (cut_from_pos > MIN_STATUS) {
		for (n = 1; n <= 3; n++)
		    buf[cut_from_pos + n] = '.';
		for (n = 0; cut_to_pos + n <= length; n++)
		    buf[cut_from_pos + 4 + n] = buf[cut_to_pos + n];
	    }
	    _user_message(format, buf);
	    CTRACE((tfp,"lastline = %s\n",buf)); /* don't forget to erase me */
	    FREE(buf);
	} else {	/* show (possibly truncated) url */
	    _user_message(format, curlink_name);
	}
    }
}

PUBLIC char*
LYDownLoadAddress NOARGS
{
    char *s = newdoc.address ? newdoc.address : "";
    return s;
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d396 1
a396 1
#ifdef USE_SOURCE_CACHE
d413 1
a413 1
#endif /* USE_SOURCE_CACHE */
d422 1
a422 1
#ifdef USE_SOURCE_CACHE
d481 1
a481 1
#ifdef USE_SOURCE_CACHE
d1853 1
a1853 1
    const char *test = HTGetProgramPath(ppCSWING);
d2950 1
a2950 1
			HText_setNoCache(HTMainText);
d3028 1
a3028 1
			HText_setNoCache(HTMainText);
d3065 1
a3065 1
#ifdef USE_SOURCE_CACHE
d3078 1
a3078 1
	HText_setNoCache(HTMainText);
d3083 1
a3083 1
#ifdef USE_SOURCE_CACHE
d3094 1
a3094 1
#ifdef USE_SOURCE_CACHE
d3573 1
a3573 1
#ifdef USE_SOURCE_CACHE
d3586 1
a3586 1
	    HText_setNoCache(HTMainText);
d3591 1
a3591 1
#ifdef USE_SOURCE_CACHE
d3603 1
a3603 1
#ifdef USE_SOURCE_CACHE
d3703 1
a3703 1
#ifdef USE_SOURCE_CACHE
d3733 1
a3733 1
#ifdef USE_SOURCE_CACHE
d3757 1
a3757 1
		HText_setNoCache(HTMainText);
d4141 4
a4147 4
    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
d4166 1
a4166 1
    HText_setNoCache(HTMainText);
d4251 1
a4251 1
#ifdef USE_SOURCE_CACHE
d4264 1
a4264 1
	HText_setNoCache(HTMainText);
d4269 1
a4269 1
#ifdef USE_SOURCE_CACHE
d4275 1
a4275 1
#ifdef USE_SOURCE_CACHE
d4281 4
d4288 1
a4288 5
    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
#ifdef USE_SOURCE_CACHE
d4293 1
a4293 1
#ifdef USE_SOURCE_CACHE
d4311 1
a4311 1
#ifdef USE_SOURCE_CACHE
d4344 1
a4344 1
#ifdef USE_SOURCE_CACHE
d4372 1
a4372 1
	    HText_setNoCache(HTMainText);
d4382 1
a4382 1
#ifdef USE_SOURCE_CACHE
d4388 1
a4388 1
#ifdef USE_SOURCE_CACHE
d6194 1
a6194 1
#ifdef USE_SOURCE_CACHE
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d41 1
d6928 1
a6928 1
		unsigned char *s = (unsigned char *) get_clip_grab(), *e, *t;
d6934 1
a6934 1
		len2 = strlen((const char *) s);
d6942 1
a6942 1
		    if (!strncasecomp((const char *) s,"URL:", 4))
d6953 1
a6953 1
		strncpy(buf, (const char *) s, e - s);
d6955 1
a6955 1
		t = (unsigned char *) buf;
d7623 1
a7623 1
	    lynx_start_reverse();
d7625 1
a7625 1
	    lynx_stop_reverse();
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d47 1
a47 1
char *str_kcode(HTkcode code)
d93 1
a93 1
static char *str_sjis(char *to, char *from)
d109 1
a109 1
static void set_ws_title(char * str)
d121 1
a121 1
static int str_n_cmp(const char *p, const char *q, int n)
d157 2
a158 2
HTLinkType * HTInternalLink = 0;
HTAtom * WWW_SOURCE = 0;
d170 5
a174 5
static void exit_immediately_with_error_message (int state, BOOLEAN first_file);
static void status_link (char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx);
static void show_main_statusline (const LinkInfo curlink, int for_what);
static void form_noviceline (int);
static int are_different (DocInfo *doc1, DocInfo *doc2);
d177 1
a177 1
static int are_phys_different (DocInfo *doc1, DocInfo *doc2);
d182 3
a184 3
static int sametext (
	char *		een,
	char *		twee)
d191 1
a191 1
HTList * Goto_URLs = NULL;  /* List of Goto URLs */
d193 2
a194 2
char * LYRequestTitle = NULL; /* newdoc.title in calls to getfile() */
char * LYRequestReferer = NULL; /* Referer, may be set in getfile() */
d196 1
a196 1
static char prev_target[512];
d199 2
a200 2
BOOLEAN display_partial = FALSE; /* could be enabled in HText_new() */
int NumOfLines_partial = 0;  /* number of lines displayed in partial mode */
d203 7
a209 7
static int Newline = 0;
static DocInfo newdoc;
static DocInfo curdoc;
static char *traversal_host = NULL;
static char *traversal_link_to_add = NULL;
static char *owner_address = NULL;  /* Holds the responsible owner's address     */
static char *ownerS_address = NULL; /* Holds owner's address during source fetch */
d212 1
a212 1
static BOOL textinput_activated = FALSE;
d217 1
a217 1
BOOL textinput_redrawn = FALSE;
d225 1
a225 1
static void free_mainloop_variables (void)
d250 1
a250 1
static void TracelogOpenFailed (void)
d261 1
a261 1
static BOOLEAN LYReopenTracelog (BOOLEAN * trace_flag_ptr)
d276 1
a276 1
static void turn_trace_back_on (BOOLEAN * trace_flag_ptr)
d289 1
a289 1
FILE *TraceFP (void)
d299 1
a299 1
BOOLEAN LYOpenTraceLog (void)
d361 1
a361 1
void LYCloseTracelog (void)
d373 1
a373 1
void handle_LYK_TRACE_TOGGLE (void)
d384 2
a385 2
void LYSetNewline (
	int		value)
d390 1
a390 1
int LYGetNewline (void)
d396 1
a396 1
static BOOLEAN from_source_cache = FALSE;
d401 1
a401 1
static BOOLEAN reparse_document (void)
d418 2
a419 2
static BOOLEAN reparse_or_reload (
    int *	cmd)
d433 3
a435 3
static void set_address (
	DocInfo *	doc,
	const char *	address)
d440 3
a442 3
static void copy_address (
	DocInfo *	dst,
	DocInfo *	src)
d447 2
a448 2
static void free_address (
	DocInfo *	doc)
d453 3
a455 3
static void move_address (
	DocInfo *	dst,
	DocInfo *	src)
d465 1
a465 1
 * LYMainLoop.c static variables to manage proper newline position
d468 2
a469 2
BOOL LYMainLoop_pageDisplay (
	int		line_num)
d471 1
a471 1
    const char * pound;
d516 2
a517 2
static void set_curdoc_link (
    int	nextlink)
d528 1
a528 1
static int do_change_link (void)
d557 4
a560 4
static void do_check_goto_URL (
    char *	user_input_buffer,
    char **	old_user_input,
    BOOLEAN *	force_load)
d564 1
a564 1
	const char *name;
d671 8
a678 8
static BOOL do_check_recall (
    int	ch,
    char *	user_input_buffer,
    char **	old_user_input,
    int	URLTotal,
    int *	URLNum,
    int	recall,
    BOOLEAN *	FirstURLRecall)
d818 1
a818 1
static void do_cleanup_after_delete (void)
d833 3
a835 3
static int find_link_near_col (
	int	col,
	int	delta)
d870 3
a872 3
static int DoTraversal (
    int	c,
    BOOLEAN *	crawl_ok)
d952 1
a952 1
static BOOLEAN check_history (void)
d954 1
a954 1
    const char *base;
d988 7
a994 7
static int handle_LYK_ACTIVATE (
    int *	c,
    int	cmd GCC_UNUSED,
    BOOLEAN *	try_internal GCC_UNUSED,
    BOOLEAN *	refresh_screen,
    BOOLEAN *	force_load,
    int	real_cmd)
d1442 2
a1443 2
static BOOLEAN handle_LYK_ADDRLIST (
    int *     cmd)
d1477 4
a1480 4
static void handle_LYK_ADD_BOOKMARK (
    BOOLEAN *	refresh_screen,
    int *	old_c,
    int	real_c)
d1624 3
a1626 3
static void handle_LYK_CLEAR_AUTH (
    int *	old_c,
    int	real_c)
d1649 2
a1650 2
static int handle_LYK_COMMAND (
    char *	user_input_buffer)
d1673 5
a1677 5
static void handle_LYK_COMMENT (
    BOOLEAN *	refresh_screen,
    char **	owner_address_p,
    int *	old_c,
    int	real_c)
d1745 2
a1746 2
		const char *kp = HText_getRevTitle();
		const char *id = HText_getMessageID();
d1777 2
a1778 2
static BOOLEAN handle_LYK_COOKIE_JAR (
    int *	cmd)
d1805 1
a1805 1
static void handle_LYK_CREATE (void)
d1823 4
a1826 4
static void handle_LYK_DEL_BOOKMARK (
    BOOLEAN *	refresh_screen,
    int *	old_c,
    int	real_c)
d1845 4
a1848 4
static void handle_LYK_DIRED_MENU (
    BOOLEAN *	refresh_screen,
    int *	old_c GCC_UNUSED,
    int	real_c GCC_UNUSED)
d1970 4
a1973 4
static int handle_LYK_DOWNLOAD (
    int *	cmd,
    int *	old_c,
    int	real_c)
d2182 3
a2184 3
static void handle_LYK_DOWN_HALF (
    int *	old_c,
    int	real_c)
d2202 4
a2205 4
static void handle_LYK_DOWN_LINK (
    int *	follow_col,
    int *	old_c,
    int	real_c)
d2237 3
a2239 3
static void handle_LYK_DOWN_TWO (
    int *	old_c,
    int	real_c)
d2257 4
a2260 4
static int handle_LYK_DWIMEDIT (
    int *	cmd,
    int *	old_c,
    int	real_c)
d2304 6
a2309 6
static int handle_LYK_ECGOTO (
    int *	ch,
    char *	user_input_buffer,
    char **	old_user_input,
    int *	old_c,
    int	real_c)
d2375 3
a2377 3
static void handle_LYK_EDIT (
    int *	old_c,
    int	real_c)
d2467 2
a2468 2
static void handle_LYK_DWIMHELP (
    const char **	cshelpfile)
d2483 4
a2486 4
static void handle_LYK_EDIT_TEXTAREA (
    BOOLEAN *	refresh_screen,
    int *	old_c,
    int	real_c)
d2534 6
a2539 6
static int handle_LYK_ELGOTO (
    int *	ch,
    char *	user_input_buffer,
    char **	old_user_input,
    int *	old_c,
    int	real_c)
d2632 2
a2633 2
static void handle_LYK_EXTERN_LINK (
    BOOLEAN *	refresh_screen)
d2642 2
a2643 2
static void handle_LYK_EXTERN_PAGE (
    BOOLEAN *	refresh_screen)
d2653 4
a2656 4
static BOOLEAN handle_LYK_FASTBACKW_LINK (
    int *	cmd,
    int *	old_c,
    int	real_c)
d2762 3
a2764 3
static void handle_LYK_FASTFORW_LINK (
    int *	old_c,
    int	real_c)
d2828 1
a2828 1
static void handle_LYK_FIRST_LINK (void)
d2841 10
a2850 10
static BOOLEAN handle_LYK_GOTO (
    int *	ch,
    char *	user_input_buffer,
    char **	old_user_input,
    int *	recall,
    int *	URLTotal,
    int *	URLNum,
    BOOLEAN *	FirstURLRecall,
    int *	old_c,
    int	real_c)
d2894 2
a2895 2
static void handle_LYK_GROW_TEXTAREA (
    BOOLEAN *	refresh_screen)
d2913 2
a2914 2
static BOOLEAN handle_LYK_HEAD (
    int *	cmd)
d3039 2
a3040 2
static void handle_LYK_HELP (
    const char **	cshelpfile)
d3062 1
a3062 1
static void handle_LYK_HISTORICAL (void)
d3099 2
a3100 2
static BOOLEAN handle_LYK_HISTORY (
    BOOLEAN	ForcePush)
d3144 2
a3145 2
static BOOLEAN handle_LYK_IMAGE_TOGGLE (
    int *	cmd)
d3154 3
a3156 3
static void handle_LYK_INDEX (
    int *	old_c,
    int	real_c)
d3186 5
a3190 5
static void handle_LYK_INDEX_SEARCH (
    BOOLEAN *	force_load,
    BOOLEAN	ForcePush,
    int *	old_c,
    int	real_c)
d3266 2
a3267 2
static BOOLEAN handle_LYK_INFO (
    int *	cmd)
d3297 2
a3298 2
static BOOLEAN handle_LYK_INLINE_TOGGLE (
    int *	cmd)
d3307 4
a3310 4
static void handle_LYK_INSERT_FILE (
    BOOLEAN *	refresh_screen,
    int *	old_c,
    int	real_c)
d3368 1
a3368 1
static void handle_LYK_INSTALL (void)
d3375 11
a3385 11
static BOOLEAN handle_LYK_JUMP (
    int	c,
    char *	user_input_buffer,
    char **	old_user_input GCC_UNUSED,
    int *	recall GCC_UNUSED,
    BOOLEAN *	FirstURLRecall GCC_UNUSED,
    int *	URLNum GCC_UNUSED,
    int *	URLTotal GCC_UNUSED,
    int *	ch GCC_UNUSED,
    int *	old_c,
    int	real_c)
d3443 5
a3447 5
static void handle_LYK_KEYMAP (
    BOOLEAN *	vi_keys_flag,
    BOOLEAN *	emacs_keys_flag,
    int *	old_c,
    int	real_c)
d3481 1
a3481 1
static void handle_LYK_LAST_LINK (void)
d3494 1
a3494 1
static void handle_LYK_LEFT_LINK (void)
d3502 2
a3503 2
static BOOLEAN handle_LYK_LIST (
    int *     cmd)
d3537 3
a3539 3
static void handle_LYK_MAIN_MENU (
    int *	old_c,
    int	real_c)
d3569 1
a3569 1
static void handle_LYK_MINIMAL (void)
d3609 2
a3610 2
static void handle_LYK_MODIFY (
    BOOLEAN *	refresh_screen)
d3635 2
a3636 2
static BOOLEAN handle_LYK_NESTED_TABLES (
    int *	cmd)
d3644 3
a3646 3
static BOOLEAN handle_LYK_OPTIONS (
    int *	cmd,
    BOOLEAN *	refresh_screen)
d3817 1
a3817 1
static void handle_NEXT_DOC (void)
d3826 4
a3829 4
static void handle_LYK_NEXT_LINK (
    int	c,
    int *	old_c,
    int	real_c)
d3871 3
a3873 3
static void handle_LYK_NEXT_PAGE (
    int	*	old_c,
    int	real_c)
d3885 3
a3887 3
static BOOLEAN handle_LYK_NOCACHE (
    int *	old_c,
    int	real_c)
d3907 4
a3910 4
static void handle_LYK_PREV_LINK (
    int *	arrowup,
    int	*	old_c,
    int	real_c)
d3947 4
a3950 4
static int handle_PREV_DOC (
    int *	cmd,
    int *	old_c,
    int	real_c)
d4058 3
a4060 3
static void handle_LYK_PREV_PAGE (
    int	*	old_c,
    int	real_c)
d4072 4
a4075 4
static void handle_LYK_PRINT (
    BOOLEAN *	ForcePush,
    int *	old_c,
    int	real_c)
d4103 1
a4103 1
static BOOLEAN handle_LYK_QUIT (void)
d4126 2
a4127 2
static BOOLEAN handle_LYK_RAW_TOGGLE (
    int *	cmd)
d4140 2
a4141 2
static void handle_LYK_RELOAD (
    int	real_cmd)
d4201 2
a4202 2
static void handle_LYK_REMOVE (
    BOOLEAN *	refresh_screen)
d4215 1
a4215 1
static void handle_LYK_RIGHT_LINK (void)
d4223 4
a4226 4
static void handle_LYK_SHELL (
    BOOLEAN *	refresh_screen,
    int *	old_c,
    int	real_c)
d4248 1
a4248 1
static void handle_LYK_SOFT_DQUOTES (void)
d4280 2
a4281 2
static void handle_LYK_SOURCE (
    char **	ownerS_address_p)
d4341 1
a4341 1
static void handle_LYK_SWITCH_DTD (void)
d4401 1
a4401 1
static void handle_LYK_TAG_LINK (void)
d4448 1
a4448 1
static void handle_LYK_TOGGLE_HELP (void)
d4456 5
a4460 5
static void handle_LYK_TOOLBAR (
    BOOLEAN *	try_internal,
    BOOLEAN *	force_load,
    int *	old_c,
    int	real_c)
d4482 2
a4483 2
static void handle_LYK_TRACE_LOG (
    BOOLEAN *	trace_flag_ptr)
d4533 1
a4533 1
static void handle_LYK_UPLOAD (void)
d4559 4
a4562 4
static void handle_LYK_UP_HALF (
    int *	arrowup,
    int *	old_c,
    int	real_c)
d4585 5
a4589 5
static void handle_LYK_UP_LINK (
    int *	follow_col,
    int *	arrowup,
    int *	old_c,
    int	real_c)
d4634 4
a4637 4
static void handle_LYK_UP_TWO (
    int *	arrowup,
    int *	old_c,
    int	real_c)
d4657 4
a4660 4
static void handle_LYK_VIEW_BOOKMARK (
    BOOLEAN *	refresh_screen,
    int *	old_c,
    int	real_c)
d4707 3
a4709 3
static BOOLEAN handle_LYK_VLINKS (
    int *	cmd,
    BOOLEAN *	newdoc_link_is_absolute)
d4747 3
a4749 3
void handle_LYK_WHEREIS (
    int	cmd,
    BOOLEAN *	refresh_screen)
d4810 7
a4816 7
static void handle_LYK_digit (
    int	c,
    BOOLEAN *	force_load,
    char *	user_input_buffer,
    int *	old_c,
    int	real_c,
    BOOLEAN *	try_internal GCC_UNUSED)
d4993 1
a4993 1
void handle_LYK_CHDIR (void)
d5080 1
a5080 1
static int repeat_to_delta (int n)
d5094 1
a5094 1
static void handle_LYK_SHIFT_LEFT (BOOLEAN * flag, int count)
d5108 1
a5108 1
static void handle_LYK_SHIFT_RIGHT (BOOLEAN * flag, int count)
d5118 3
a5120 3
static BOOLEAN handle_LYK_LINEWRAP_TOGGLE (
    int *	cmd,
    BOOLEAN *	flag)
d5181 1
a5181 1
int mainloop (void)
d5196 1
a5196 1
    const char *cshelpfile = NULL;
d5787 1
a5787 1
			const char *name = wwwName(Home_Dir());
d6024 1
a6024 1
		print_wwwfile_to_fd(stdout, FALSE, FALSE);
d7386 3
a7388 3
static int are_different (
	DocInfo *	doc1,
	DocInfo *	doc2)
d7444 3
a7446 3
static int are_phys_different (
	DocInfo *	doc1,
	DocInfo *	doc2)
d7518 1
a7518 1
static void HTGotoURLs_free (void)
d7537 2
a7538 2
void HTAddGotoURL (
	char *		url)
d7577 3
a7579 3
static void show_main_statusline (
    const LinkInfo	curlink,
    int		for_what)
d7674 2
a7675 2
void repaint_main_statusline (
    int	for_what)
d7681 2
a7682 2
static void form_noviceline (
    int	disabled)
d7714 3
a7716 3
static void exit_immediately_with_error_message (
	int		state,
	BOOLEAN	first_file)
d7772 4
a7775 4
static void status_link (
	char *		curlink_name,
	BOOLEAN	show_more,
	BOOLEAN	show_indx)
d7846 2
a7847 2
char*
LYDownLoadAddress (void)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d109 1
a109 1
static void set_ws_title(char *str)
d116 2
a117 1
#ifdef SH_EX			/* 1998/10/30 (Fri) 10:06:47 */
d138 1
a138 1
#endif /* SH_EX */
d157 2
a158 2
HTLinkType *HTInternalLink = 0;
HTAtom *WWW_SOURCE = 0;
d169 6
a174 5
static void exit_immediately_with_error_message(int state, BOOLEAN first_file);
static void status_link(char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx);
static void show_main_statusline(const LinkInfo curlink, int for_what);
static void form_noviceline(int);
static int are_different(DocInfo *doc1, DocInfo *doc2);
d177 1
a177 1
static int are_phys_different(DocInfo *doc1, DocInfo *doc2);
d182 3
a184 2
static int sametext(char *een,
		    char *twee)
d191 1
a191 1
HTList *Goto_URLs = NULL;	/* List of Goto URLs */
d193 2
a194 2
char *LYRequestTitle = NULL;	/* newdoc.title in calls to getfile() */
char *LYRequestReferer = NULL;	/* Referer, may be set in getfile() */
d199 2
a200 2
BOOLEAN display_partial = FALSE;	/* could be enabled in HText_new() */
int NumOfLines_partial = 0;	/* number of lines displayed in partial mode */
d208 2
a209 2
static char *owner_address = NULL;	/* Holds the responsible owner's address     */
static char *ownerS_address = NULL;	/* Holds owner's address during source fetch */
a212 1

d214 1
a214 1
#define textinput_activated TRUE	/* a current text input is always active */
d218 1
a218 2

    /*must be public since used in LYhighlight(..) */
d223 1
a223 1
 * Function for freeing allocated mainloop() variables.  - FM
d225 1
a225 1
static void free_mainloop_variables(void)
d250 1
a250 1
static void TracelogOpenFailed(void)
d261 1
a261 1
static BOOLEAN LYReopenTracelog(BOOLEAN *trace_flag_ptr)
d276 1
a276 1
static void turn_trace_back_on(BOOLEAN *trace_flag_ptr)
d286 1
a286 1
#define turn_trace_back_on(flag)	/*nothing */
d289 1
a289 1
FILE *TraceFP(void)
d299 1
a299 1
BOOLEAN LYOpenTraceLog(void)
d324 5
a328 5
	 * If TRACE is on, indicate whether the anonymous restrictions are set. 
	 * - FM, LP, kw
	 *
	 * This is only a summary for convenience - it doesn't take the case of
	 * individual -restrictions= options into account.  - kw
d332 1
a332 2
		CTRACE((tfp,
			"Validate and some anonymous restrictions are set.\n"));
d334 1
a334 2
		CTRACE((tfp,
			"Validate restrictions set, restriction \"default\" was given.\n"));
d336 1
a336 2
		CTRACE((tfp,
			"Validate restrictions set, additional anonymous restrictions ignored.\n"));
d345 1
a345 2
		CTRACE((tfp,
			"Anonymous restrictions set, restriction \"all\" was given.\n"));
d361 1
a361 1
void LYCloseTracelog(void)
d373 1
a373 1
void handle_LYK_TRACE_TOGGLE(void)
d376 1
a376 1
    WWW_TraceFlag = !WWW_TraceFlag;
d384 2
a385 1
void LYSetNewline(int value)
d390 1
a390 1
int LYGetNewline(void)
d401 1
a401 1
static BOOLEAN reparse_document(void)
a403 1

d418 2
a419 1
static BOOLEAN reparse_or_reload(int *cmd)
d433 3
a435 1
static void set_address(DocInfo *doc, const char *address)
d440 3
a442 1
static void copy_address(DocInfo *dst, DocInfo *src)
d447 2
a448 1
static void free_address(DocInfo *doc)
d453 3
a455 1
static void move_address(DocInfo *dst, DocInfo *src)
d468 2
a469 1
BOOL LYMainLoop_pageDisplay(int line_num)
d471 1
a471 1
    const char *pound;
d475 2
a476 2
     * Override Newline with a new value if user scrolled the document while
     * loading (in LYUtils.c).
d500 2
a501 2
	    && *pound && *(pound + 1)) {
	    if (HTFindPoundSelector(pound + 1)) {
d505 1
a505 1
		Newline = prev_newline;		/* restore ??? */
d515 3
a517 1
static void set_curdoc_link(int nextlink)
d520 2
a521 2
	&& nextlink >= 0
	&& nextlink < nlinks) {
d528 1
a528 1
static int do_change_link(void)
a532 1

a536 1

d542 1
a542 1
	    return (-1);	/* indicates unexpected error */
d547 1
a547 1
    return (0);			/* indicates OK */
d557 4
a560 3
static void do_check_goto_URL(char *user_input_buffer,
			      char **old_user_input,
			      BOOLEAN *force_load)
a562 1
    /* *INDENT-OFF* */
a602 2
    /* *INDENT-ON* */

d606 6
a611 6
    /* allow going to anchors */
    if (*user_input_buffer == '#') {
	if (user_input_buffer[1] &&
	    HTFindPoundSelector(user_input_buffer + 1)) {
	    /* HTFindPoundSelector will initialize www_search_result,
	       so we do nothing else. */
d623 1
a623 1
		(int) (MAX_LINE - 1), *old_user_input);
d628 1
a628 1
		&& !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
d645 2
a646 2
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * dont't free the content.  -- FM
d652 1
a652 2
		StrAllocCopy(newdoc.title,
			     gettext("A URL specified by the user"));
d671 8
a678 7
static BOOL do_check_recall(int ch,
			    char *user_input_buffer,
			    char **old_user_input,
			    int URLTotal,
			    int *URLNum,
			    int recall,
			    BOOLEAN *FirstURLRecall)
d687 1
a687 1
#ifdef WIN_EX			/* 1998/10/11 (Sun) 10:41:05 */
d692 2
a693 2
		&& LYIsHtmlSep(user_input_buffer[len - 3])
		&& LYIsDosDrive(user_input_buffer + len - 2))
d697 9
a705 9
	    if (LYIsDosDrive(user_input_buffer)) {
		LYAddPathSep0(user_input_buffer);
	    } else {
		HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
		LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		FREE(*old_user_input);
		ret = FALSE;
		break;
	    }
d738 2
a739 2
	    if ((cp = (char *) HTList_objectAt(Goto_URLs,
					       *URLNum)) != NULL) {
d742 2
a743 2
		    && **old_user_input
		    && !strcmp(*old_user_input, user_input_buffer)) {
d752 2
a753 2
				   MAX_LINE,
				   recall)) < 0) {
d755 2
a756 2
		     * User cancelled the Goto via ^G.  Restore
		     * user_input_buffer and break.  - FM
d784 1
a784 1
	    if ((cp = (char *) HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
d799 2
a800 2
		     * User cancelled the Goto via ^G.  Restore
		     * user_input_buffer and break.  - FM
d818 1
a818 1
static void do_cleanup_after_delete(void)
d823 1
a823 1
    if (curdoc.link == nlinks - 1) {
d827 1
a827 1
	newdoc.link = curdoc.link - 1;
d833 3
a835 2
static int find_link_near_col(int col,
			      int delta)
d840 1
a840 1
	if ((links[i].ly - links[curdoc.link].ly) * delta > 0) {
d858 1
a858 1
	    return (best);
d861 1
a861 1
    return (-1);
d870 3
a872 2
static int DoTraversal(int c,
		       BOOLEAN *crawl_ok)
d879 2
a880 2
			   links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
			   links[curdoc.link].lname != NULL);
d885 2
a886 2
	    traversal_host &&
	    links[curdoc.link].lname) {
d889 2
a890 2
						links[curdoc.link].lname,
						strlen(traversal_host));
d893 2
a894 2
						links[curdoc.link].lname + LEN_LYNXIMGMAP,
						strlen(traversal_host));
d905 2
a906 2
		(curdoc.link > -1 && curdoc.link < nlinks - 1))
		c = DNARROW;
d908 2
a909 2
		if (STREQ(curdoc.title, "Entry into main screen") ||
		    (nhist <= 0)) {
d914 1
a914 1
		    return (-1);
d925 2
a926 2
    } else {			/* no good right link, so only down and left arrow ok */
	if (rlink_exists /* && !rlink_rejected */ )
d930 1
a930 1
	    (curdoc.link > -1 && curdoc.link < nlinks - 1))
d934 2
a935 2
	     * curdoc.title doesn't always work, so bail out if the history
	     * list is empty.
d937 2
a938 2
	    if (STREQ(curdoc.title, "Entry into main screen") ||
		(nhist <= 0)) {
d943 1
a943 1
		return (-1);
d947 1
a947 1
    }				/* right link not NULL or link to another site */
d952 1
a952 1
static BOOLEAN check_history(void)
d958 2
a959 1
	 * Normal case - List Page is not associated with post data.  - kw
d964 7
a970 8
	&& !LYresubmit_posts
	&& HDOC(nhist - 1).post_data
	&& BINEQ(curdoc.post_data, HDOC(nhist - 1).post_data)
	&& (base = HText_getContentBase()) != 0) {
	char *text = !isLYNXIMGMAP(HDOC(nhist - 1).address)
	? HDOC(nhist - 1).address
	: HDOC(nhist - 1).address + LEN_LYNXIMGMAP;

d988 7
a994 6
static int handle_LYK_ACTIVATE(int *c,
			       int cmd GCC_UNUSED,
			       BOOLEAN *try_internal GCC_UNUSED,
			       BOOLEAN *refresh_screen,
			       BOOLEAN *force_load,
			       int real_cmd)
d999 1
a999 1
	return 1;		/* mouse stuff was confused, ignore - kw */
d1015 1
a1015 1
	     * Don't try to submit forms with bad actions.  - FM
d1020 1
a1020 1
		F_TEXT_SUBMIT_TYPE) {
d1022 1
a1022 1
		 * Do nothing if it's disabled.  - FM
d1031 1
a1031 1
		 * Make sure we have an action.  - FM
d1035 1
a1035 1
		    == '\0') {
d1043 2
a1044 1
		 * Check for no_mail if the form action is a mailto URL.  - FM
d1047 1
a1047 1
		    == URL_MAIL_METHOD && no_mail) {
d1055 2
a1056 2
		 * Make sure this isn't a spoof in an account with restrictions
		 * on file URLs.  - FM
d1067 2
a1068 2
		 * Make sure this isn't a spoof attempt via an internal URL.  -
		 * FM
d1075 2
a1076 2
		      strncasecomp((links[curdoc.link].l_form->submit_action
				    + 10),
d1093 1
a1093 1
			    links[curdoc.link].l_form->submit_action));
d1099 1
a1099 1
#ifdef NOTDEFINED		/* We're disabling form inputs instead of using this. - FM */
d1101 2
a1102 2
		 * Check for enctype and let user know we don't yet support
		 * multipart/form-data - FM
d1105 2
a1106 1
		    if (!strcmp(links[curdoc.link].l_form->submit_enctype,
d1108 2
a1109 1
			HTAlert(gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
d1130 4
a1133 3
	     * Normally we don't get here for text input fields, but it can
	     * happen as a result of mouse positioning.  In that case the
	     * statusline will not have updated info, so update it now.  - kw
d1146 1
a1146 1
		    form_noviceline(links[curdoc.link].l_form->disabled);
d1151 6
a1156 6
				  &newdoc, refresh_screen,
				  FALSE,
				  (BOOLEAN) (real_cmd == LYK_SUBMIT ||
					     real_cmd == LYK_NOCACHE ||
					     real_cmd == LYK_DOWNLOAD ||
					     real_cmd == LYK_HEAD));
d1159 2
a1160 2
		 * Cannot have been a submit field for which newdoc was filled
		 * in.  - kw
d1166 1
a1166 1
		    != URL_MAIL_METHOD) {
d1168 1
a1168 1
		     * Try to undo change of newdoc.title done above.
d1199 8
a1206 7
		 * Moved here from earlier to only apply when it should. 
		 * Anyway, why should realm checking be overridden for form
		 * submissions, this seems to be an unnecessary loophole??  But
		 * that's the way it was, maybe there is some reason.  However,
		 * at least make sure this doesn't weaken restrictions implied
		 * by -validate!
		 * - kw 1999-05-25
d1218 5
a1222 4
		/* Avoid getting stuck with repeatedly calling
		 * handle_LYK_ACTIVATE(), instead of calling change_form_link()
		 * directly from mainloop(), for text input fields.  - kw
		 */
d1237 1
a1237 1
	     * Not a forms link.
d1239 2
a1240 2
	     * Make sure this isn't a spoof in an account with restrictions on
	     * file URLs.  - FM
d1259 3
a1261 2
	     * Make sure this isn't a spoof attempt via an internal URL in a
	     * non-internal document.  - FM
d1283 7
a1289 6
		HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		HTOutputFormat = WWW_PRESENT;
		LYforce_no_cache = FALSE;
		reloading = FALSE;
		return 0;
	    }
d1291 2
a1292 1
	    if (run_external(links[curdoc.link].lname, TRUE)) {
d1299 1
a1299 1
	     * Follow a normal link or anchor.
d1304 7
d1312 3
a1314 10
	     * For internal links, retain POST content if present.  If we are
	     * on the List Page, prevent pushing it on the history stack. 
	     * Otherwise set try_internal to signal that the top of the loop
	     * should attempt to reposition directly, without calling getfile. 
	     * - kw
	     */
	    /*
	     * Might be an internal link anchor in the same doc.  If so, take
	     * the try_internal shortcut if we didn't fall through from
	     * LYK_NOCACHE.  - kw
d1320 4
a1323 3
		 * Special case of List Page document with an internal link
		 * indication, which may really stand for an internal link
		 * within the document the List Page is about.  - kw
d1331 1
a1331 1
			HTLastConfirmCancelled();	/* reset flag */
d1334 2
a1335 4
						((LYresubmit_posts &&
						  HText_POSTReplyLoaded(&newdoc))
						 ? 1
						 : 2),
d1369 2
a1370 2
		     * Don't push the List Page if we follow an internal link
		     * given by it.  - kw
d1379 1
a1379 2
		 * etc. will be done.  - kw
		 */
d1384 1
a1384 1
		 * Free POST content if not an internal link.  - kw
d1390 2
a1391 2
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
d1421 10
a1430 9
		DIRED_UNCACHE_2;
		/*
		 * Unescaping any slash chars in the URL, but avoid double
		 * unescaping and too-early unescaping of other chars.  - KW
		 */
		HTUnEscapeSome(newdoc.address, "/");
		/* avoid stripping final slash for root dir - kw */
		if (strcasecomp(newdoc.address, "file://localhost/"))
		    strip_trailing_slash(newdoc.address);
d1442 2
a1443 1
static BOOLEAN handle_LYK_ADDRLIST(int *cmd)
d1446 1
a1446 1
     * Don't do if already viewing list addresses page.
d1450 1
a1450 1
	 * Already viewing list page, so get out.
d1457 1
a1457 1
     * Print address list page to file.
d1463 4
a1466 3
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
d1477 4
a1480 3
static void handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
d1485 1
a1485 1
	if (*old_c != real_c) {
d1518 4
a1521 3
		 * The document doesn't have POST content, and is not a
		 * bookmark file, nor is the list or visited links page, so we
		 * can save either that or the link.  - FM
d1526 1
a1526 1
		    *refresh_screen = TRUE;	/* MultiBookmark support */
d1534 2
a1535 2
			    ? (bookmark_page + 1)
			    : bookmark_page)) != NULL) {
d1537 4
a1540 3
		     * If multiple bookmarks are disabled, offer the L)ink or
		     * C)ancel, but with wording which indicates that the link
		     * already exists in this bookmark file.  - FM
d1546 1
a1546 1
		     * Internal link, and document has POST content.
d1552 4
a1555 3
		     * Only offer the link in a document with POST content, or
		     * if the current document is a bookmark file and multiple
		     * bookmarks are enabled.  - FM
d1565 1
a1565 1
		     * Internal link, and document has POST content.
d1571 1
a1571 1
		 * User does want to save the link.  - FM
d1576 1
a1576 1
		    *refresh_screen = TRUE;	/* MultiBookmark support */
d1586 1
a1586 1
	     * No links, and document has POST content.  - FM
d1592 2
a1593 2
	     * It's a bookmark file from which all of the links were deleted. 
	     * - FM
d1601 1
a1601 1
		*refresh_screen = TRUE;		/* MultiBookmark support */
d1606 1
a1606 1
      check_add_bookmark_to_self:
d1617 1
a1617 1
	if (*old_c != real_c) {
d1624 3
a1626 2
static void handle_LYK_CLEAR_AUTH(int *old_c,
				  int real_c)
d1649 2
a1650 1
static int handle_LYK_COMMAND(char *user_input_buffer)
d1673 5
a1677 4
static void handle_LYK_COMMENT(BOOLEAN *refresh_screen,
			       char **owner_address_p,
			       int *old_c,
			       int real_c)
d1679 1
a1679 1
    int c;
d1683 1
a1683 1
	if (*old_c != real_c) {
d1696 2
a1697 2
		 * No owner defined, so make a guess and and offer it to the
		 * user.  - FM
d1707 1
a1707 1
			 * It's a ~user URL so guess user@@host.  - FM
d1709 1
a1709 1
			if ((cp = strchr((temp + 1), '/')) != NULL)
d1712 1
a1712 1
			StrAllocCat(address, (temp + 1));
d1719 1
a1719 1
		     * Wasn't a ~user URL so guess WebMaster@@host.  - FM
d1737 1
a1737 1
		 * The address is a URL.  Just follow the link.
d1743 1
a1743 1
		 * The owner_address is a mailto:  URL.
a1747 1

d1760 6
a1765 6
		    /*
		     * Send a reply.  The address is after the colon.
		     */
		    reply_by_mail(strchr(*owner_address_p, ':') + 1,
				  curdoc.address,
				  NonNull(kp), id);
d1771 1
a1771 1
		*refresh_screen = TRUE;		/* to force a showpage */
d1777 2
a1778 1
static BOOLEAN handle_LYK_COOKIE_JAR(int *cmd)
d1781 1
a1781 1
     * Don't do if already viewing the cookie jar.
d1796 1
a1796 1
	 * If already in the cookie jar, get out.
d1805 1
a1805 1
static void handle_LYK_CREATE(void)
d1823 4
a1826 3
static void handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
d1829 1
a1829 1
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE, NO) != YES)
d1831 1
a1831 1
	remove_bookmark_link(links[curdoc.link].anchor_number - 1,
d1833 1
a1833 1
    } else {			/* behave like REFRESH for backward compatibility */
d1845 4
a1848 3
static void handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen,
				  int *old_c GCC_UNUSED,
				  int real_c GCC_UNUSED)
d1855 7
a1861 6
     * Check if the CSwing Directory/File Manager is available.  Will be
     * disabled if CSWING path is NULL, zero-length, or "none" (case
     * insensitive), if no_file_url was set via the file_url restriction, if
     * no_goto_file was set for the anonymous account, or if HTDirAccess was
     * set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse or -selective
     * switches.  - FM
d1868 1
a1868 1
	if (*old_c != real_c) {
d1876 7
a1882 5
     * If we are viewing a local directory listing or a local file which is not
     * temporary, invoke CSwing with the URL's directory converted to VMS path
     * specs and passed as the argument, so we start up CSwing positioned on
     * that node of the directory tree.  Otherwise, pass the current default
     * directory as the argument.  - FM
d1888 2
a1889 2
	 * We are viewing a local directory or a local file which is not
	 * temporary.  - FM
d1893 1
a1893 1
	cp = HTParse(curdoc.address, "", PARSE_PATH | PARSE_PUNCTUATION);
d1899 1
a1899 1
	    *refresh_screen = TRUE;	/* redisplay */
d1905 2
a1906 2
		 * We're viewing a local directory.  Make that the CSwing
		 * argument.  - FM
d1913 2
a1914 2
		 * We're viewing a local file.  Make its directory the CSwing
		 * argument.  - FM
d1929 3
a1931 2
	     * Uncache the current document in case we change, move, or delete
	     * it during the CSwing session.  - FM
d1944 4
a1947 3
	 * We're not viewing a local directory or file.  Pass CSwing the
	 * current default directory as an argument and don't uncache the
	 * current document.  - FM
d1958 1
a1958 1
     * Don't do if not allowed or already viewing the menu.
d1963 1
a1963 1
	dired_options(&curdoc, &newdoc.address);
d1970 4
a1973 3
static int handle_LYK_DOWNLOAD(int *cmd,
			       int *old_c,
			       int real_c)
d1977 1
a1977 1
     * Don't do if both download and disk_save are restricted.
d1981 1
a1981 1
	if (*old_c != real_c) {
d1989 1
a1989 1
     * Don't do if already viewing download options page.
d1995 1
a1995 1
	return 1;		/* mouse stuff was confused, ignore - kw */
d2002 1
a2002 1
		    URL_MAIL_METHOD) {
d2027 1
a2027 1
	    if (*old_c != real_c) {
d2033 1
a2033 1
	    if (*old_c != real_c) {
d2037 1
d2040 1
a2040 1
	    if (*old_c != real_c) {
d2046 1
a2046 1
	    if (*old_c != real_c) {
d2054 1
a2054 1
	     * Don't bother making a /tmp copy of the local file.
a2056 1

d2068 1
a2068 1
		   isLYNXHIST(links[curdoc.link].lname)) {
a2069 1

d2081 1
a2081 1
	     * OK, we download from history page, restore URL from stack.
d2100 1
a2100 1
	     * Force the document to be reloaded.
d2116 1
a2116 1
	    /* handled above if valid - kw */
d2127 9
a2135 9
	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     *
	     * We copy all these checks from getfile() to LYK_DOWNLOAD here
	     * because LYNXDOWNLOAD:// will NOT be pushing the previous
	     * document into the history stack so preserve getfile() from
	     * returning a wrong status (NULLFILE).
	     */
d2140 1
a2140 1
	} else {		/* Not a forms, options or history link */
d2142 3
a2144 2
	     * Follow a normal link or anchor.  Note that if it's an anchor
	     * within the same document, entire document will be downloaded.
d2150 2
a2151 2
	     * Might be an internal link in the same doc from a POST form.  If
	     * so, don't free the content.  - kw
d2156 2
a2157 2
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
d2171 1
a2171 1
	     * Force the document to be reloaded.
d2182 3
a2184 2
static void handle_LYK_DOWN_HALF(int *old_c,
				 int real_c)
d2189 1
a2189 1
	Newline += (display_lines / 2);
d2191 1
a2191 1
	    links[curdoc.link].ly > display_lines / 2) {
d2193 1
a2193 1
	    for (i = 0; links[i].ly <= (display_lines / 2); i++)
d2202 4
a2205 3
static void handle_LYK_DOWN_LINK(int *follow_col,
				 int *old_c,
				 int real_c)
d2207 1
a2207 1
    if (curdoc.link < (nlinks - 1)) {	/* more links? */
a2211 1

d2221 1
a2221 1
	} else if (more) {	/* next page */
d2228 2
a2229 2
    } else if (more) {		/* next page */
	Newline += (display_lines);
d2237 3
a2239 2
static void handle_LYK_DOWN_TWO(int *old_c,
				int real_c)
d2257 4
a2260 3
static int handle_LYK_DWIMEDIT(int *cmd,
			       int *old_c,
			       int real_c)
d2264 7
a2270 6
     * If we're in a forms TEXTAREA, invoke the editor on *its* contents,
     * rather than attempting to edit the html source document.  KED
     */
    if (nlinks > 0 &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d2276 5
a2280 4
     * If we're in a forms TEXT type, tell user the request is bogus (though in
     * reality, without this trap, if the document with the TEXT field is
     * local, the editor *would* be invoked on the source .html file; eg, the
     * o(ptions) form tempfile).
d2282 3
a2284 2
     * [This is done to avoid possible user confusion, due to auto invocation
     * of the editor on the TEXTAREA's contents via the above if() statement.]
d2287 3
a2289 3
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXT_TYPE) {
	HTUserMsg(CANNOT_EDIT_FIELD);
d2304 6
a2309 5
static int handle_LYK_ECGOTO(int *ch,
			     char *user_input_buffer,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
d2313 1
a2313 1
	 * Go to not allowed.  - FM
d2326 1
a2326 1
	 * Disallow editing of File Management URLs.  - FM
d2337 2
a2338 2
     * Save the current user_input_buffer string, and load the current
     * document's address.
d2346 2
a2347 2
     * Warn the user if the current document has POST data associated with it. 
     * - FM
d2353 1
a2353 1
     * Offer the current document's URL for editing.  - FM
d2357 1
a2357 1
			 MAX_LINE, RECALL_URL)) >= 0) &&
d2366 2
a2367 1
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
d2375 3
a2377 2
static void handle_LYK_EDIT(int *old_c,
			    int real_c)
d2391 1
d2393 6
a2398 5
	/*
	 * Allow the user to edit the link rather than curdoc in edit mode.
	 */
	if (lynx_edit_mode &&
	    editor && *editor != '\0' && !no_dired_support) {
d2417 1
a2417 1
			     * Go to top of file.
d2423 2
a2424 1
			     * Seek old position, which probably changed.
d2429 1
a2429 1
			    LYclear();	/* clear the screen */
d2441 2
a2442 2
	    LYforce_no_cache = TRUE;	/*force reload of document */
	    free_address(&curdoc);	/* so it doesn't get pushed */
d2445 1
a2445 1
	     * Go to top of file.
d2451 1
a2451 1
	     * Seek old position, which probably changed.
d2456 1
a2456 1
	    LYclear();		/* clear the screen */
d2467 2
a2468 1
static void handle_LYK_DWIMHELP(const char **cshelpfile)
d2471 3
a2473 2
     * Currently a help file different from the main 'helpfile' is shown only
     * if current link is a text input form field.  - kw
d2483 4
a2486 3
static void handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
d2502 1
a2502 1
     * See if the current link is in a form TEXTAREA.
d2504 2
a2505 2
    else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d2510 1
a2510 1
	n = HText_ExtEditForm(&links[curdoc.link]);
d2513 6
a2518 5
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st trailing blank line in the now edited TEXTAREA.  If the target
	 * line/ anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
d2521 2
a2522 2
/* curdoc.link += n; *//* works, except for page crossing, */
	/* damnit; why is nothing ever easy */
d2530 1
a2530 1
	HTInfoMsg(NOT_IN_TEXTAREA_NOEDIT);
d2534 6
a2539 5
static int handle_LYK_ELGOTO(int *ch,
			     char *user_input_buffer,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
d2543 1
a2543 1
	 * Go to not allowed.  - FM
d2557 2
a2558 1
	 * No links on page, or not a normal link or form submit button.  - FM
d2570 1
a2570 1
	 * Form submit button with no ACTION defined.  - FM
d2584 1
a2584 1
	 * Disallow editing of File Management URLs.  - FM
d2595 2
a2596 2
     * Save the current user_input_buffer string, and load the current link's
     * address.  - FM
d2601 2
a2602 2
	       ?
	       links[curdoc.link].l_form->submit_action : links[curdoc.link].lname),
d2606 1
a2606 1
     * Offer the current link's URL for editing.  - FM
d2610 1
a2610 1
			 MAX_LINE, RECALL_URL)) >= 0) &&
d2614 2
a2615 2
		? links[curdoc.link].l_form->submit_action
		: links[curdoc.link].lname))) {
d2622 2
a2623 1
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
d2632 2
a2633 1
static void handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen)
d2635 2
a2636 1
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL)) {
d2642 2
a2643 1
static void handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen)
d2645 2
a2646 1
    if (curdoc.address != NULL) {
d2653 4
a2656 3
static BOOLEAN handle_LYK_FASTBACKW_LINK(int *cmd,
					 int *old_c,
					 int real_c)
d2664 2
a2665 2
	 * If in textarea, move to first link or textarea group before it if
	 * there is one on this screen.  - kw
d2677 1
a2677 2
		do
		    nextlink--;
d2690 4
a2693 4
		       !(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
			 links[nlinks - 1].l_form->number == thisgroup &&
			 sametext(links[nlinks - 1].l_form->name, thisname))) {
d2711 3
a2713 3
	 * If the link as determined so far is part of a group of textarea
	 * fields, try to use the first of them that's on the screen instead. 
	 * - kw
a2719 1

d2728 4
a2731 4
		     links[nextlink - 1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink - 1].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink - 1].l_form->number == thisgroup &&
		     sametext(links[nextlink - 1].l_form->name, thisname)) {
d2744 2
a2745 2
	     * It says we should use the normal PREV_LINK mechanism, so we'll
	     * do that.  - kw
d2752 1
a2752 1
	Newline++;		/* our line counting starts with 1 not 0 */
d2762 3
a2764 2
static void handle_LYK_FASTFORW_LINK(int *old_c,
				     int real_c)
d2771 2
a2772 2
	 * If in textarea, move to first link or field after it if there is one
	 * on this screen.  - kw
d2779 6
a2784 7
	    if (curdoc.link < nlinks - 1 &&
		!(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
		  links[nlinks - 1].l_form->number == thisgroup &&
		  sametext(links[nlinks - 1].l_form->name, thisname))) {
		do
		    nextlink++;
d2795 1
a2795 1
	} else if (curdoc.link < nlinks - 1) {
d2805 1
a2805 1
	return;			/* and we are done. */
d2807 5
a2811 5
	/*
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
	 */
    } else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
d2814 1
a2814 1
    } else if (more &&		/* need a later page */
d2818 1
a2818 1
	Newline++;		/* our line counting starts with 1 not 0 */
d2828 1
a2828 1
static void handle_LYK_FIRST_LINK(void)
d2834 1
a2834 1
	    || links[i].ly != links[curdoc.link].ly) {
d2841 10
a2850 9
static BOOLEAN handle_LYK_GOTO(int *ch,
			       char *user_input_buffer,
			       char **old_user_input,
			       int *recall,
			       int *URLTotal,
			       int *URLNum,
			       BOOLEAN *FirstURLRecall,
			       int *old_c,
			       int real_c)
d2877 1
a2877 1
     * Ask the user.
d2881 1
a2881 1
			MAX_LINE, *recall)) < 0) {
d2883 2
a2884 2
	 * User cancelled the Goto via ^G.  Restore user_input_buffer and
	 * break.  - FM
d2894 2
a2895 1
static void handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen)
d2898 1
a2898 1
     * See if the current link is in a form TEXTAREA.
d2900 2
a2901 2
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d2903 1
a2903 1
	HText_ExpandTextarea(&links[curdoc.link], TEXTAREA_EXPAND_SIZE);
d2909 1
a2909 1
	HTInfoMsg(NOT_IN_TEXTAREA);
d2913 2
a2914 1
static BOOLEAN handle_LYK_HEAD(int *cmd)
d2919 1
a2919 1
	(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
d2931 2
a2932 3
	    ? curdoc.address
	    : curdoc.address + LEN_LYNXIMGMAP;

d2972 1
a2972 1
			       "http", 4)) {
d2976 1
a2976 1
		       URL_POST_METHOD &&
d3014 2
a3015 3
		? curdoc.address
		: curdoc.address + LEN_LYNXIMGMAP;

d3039 2
a3040 1
static void handle_LYK_HELP(const char **cshelpfile)
a3041 2
    char *my_value = NULL;

d3044 1
a3044 3
    StrAllocCopy(my_value, *cshelpfile);
    LYEnsureAbsoluteURL(&my_value, *cshelpfile, FALSE);
    if (!STREQ(curdoc.address, my_value)) {
d3046 1
a3046 1
	 * Set the filename.
d3048 1
a3048 1
	set_address(&newdoc, my_value);
d3050 1
a3050 1
	 * Make a name for this help file.
a3058 1
    FREE(my_value);
d3062 1
a3062 1
static void handle_LYK_HISTORICAL(void)
d3067 15
a3081 14
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
d3083 1
a3083 1
    }				/* end if no bypass */
d3099 2
a3100 1
static BOOLEAN handle_LYK_HISTORY(BOOLEAN ForcePush)
d3104 1
a3104 1
	 * Don't do this if already viewing history page.
d3106 3
a3108 3
	 * Push the current file so that the history list contains the current
	 * file for printing purposes.  Pop the file afterwards to prevent
	 * multiple copies.
d3120 1
a3120 1
	 * Print history options to file.
d3133 2
a3134 2
	newdoc.link = 1;	/*@@@@@@ bypass "recent statusline messages" link */
	free_address(&curdoc);	/* so it doesn't get pushed */
d3140 1
a3140 1
    }				/* end if strncmp */
d3144 2
a3145 1
static BOOLEAN handle_LYK_IMAGE_TOGGLE(int *cmd)
d3150 1
a3150 1
	      CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
d3154 3
a3156 2
static void handle_LYK_INDEX(int *old_c,
			     int real_c)
d3159 1
a3159 1
     * Make sure we are not in the index already.
d3163 5
a3167 5
	if (indexfile[0] == '\0') {	/* no defined index */
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_INDEX_FILE);
	    }
d3176 1
a3176 1
	    StrAllocCopy(newdoc.title, gettext("System Index"));	/* name it */
d3182 2
a3183 2
	}			/* end else */
    }				/* end if */
d3186 5
a3190 4
static void handle_LYK_INDEX_SEARCH(BOOLEAN *force_load,
				    BOOLEAN ForcePush,
				    int *old_c,
				    int real_c)
d3194 1
a3194 1
	 * Perform a database search.
d3196 3
a3198 3
	 * do_www_search will try to go out and get the document.  If it
	 * returns TRUE, a new document was returned and is named in the
	 * newdoc.address.
d3204 1
a3204 1
	     * Yah, the search succeeded.
d3208 1
a3208 1
		 * Make sure cursor is down.
d3218 3
a3220 3
	     * Make the curdoc.address the newdoc.address so that getfile
	     * doesn't try to get the newdoc.address.  Since we have already
	     * gotten it.
d3230 1
a3230 1
	     * Got back a redirecting URL.  Check it out.
d3232 1
a3232 1
	    HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
d3235 1
a3235 1
	     * Make a name for this URL.
d3249 1
a3249 1
	     * Yuk, the search failed.  Restore the old file.
d3266 2
a3267 1
static BOOLEAN handle_LYK_INFO(int *cmd)
d3270 1
a3270 1
     * Don't do if already viewing info page.
d3274 2
a3275 2
	    && LYShowInfo(&curdoc, HText_getNumOfLines(),
			  &newdoc, owner_address) >= 0) {
d3289 1
a3289 1
	 * If already in info page, get out.
d3297 2
a3298 1
static BOOLEAN handle_LYK_INLINE_TOGGLE(int *cmd)
d3307 4
a3310 3
static void handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen,
				   int *old_c,
				   int real_c)
d3315 1
a3315 1
     * See if the current link is in a form TEXTAREA.
d3317 2
a3318 2
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d3321 8
a3328 6
	 * Reject attempts to use this for gaining access to local files when
	 * such access is restricted:  if no_file_url was set via the file_url
	 * restriction, if no_goto_file was set for the anonymous account, or
	 * if HTDirAccess was set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the
	 * -nobrowse or -selective switches, it is assumed that inserting files
	 * or checking for existence of files needs to be denied.  - kw
d3344 1
a3344 1
	n = HText_InsertFile(&links[curdoc.link]);
d3347 5
a3351 5
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st line following the text that was inserted.  If the target
	 * line/anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
d3353 4
a3356 4
	 * [Current behavior leaves cursor on the same line relative to the
	 * start of the TEXTAREA that it was on before the insertion.  This is
	 * the same behavior that occurs with (my) editor, so this TODO will
	 * stay unimplemented.]
d3363 1
a3363 1
	HTInfoMsg(NOT_IN_TEXTAREA);
d3368 1
a3368 1
static void handle_LYK_INSTALL(void)
d3375 11
a3385 10
static BOOLEAN handle_LYK_JUMP(int c,
			       char *user_input_buffer,
			       char **old_user_input GCC_UNUSED,
			       int *recall GCC_UNUSED,
			       BOOLEAN *FirstURLRecall GCC_UNUSED,
			       int *URLNum GCC_UNUSED,
			       int *URLTotal GCC_UNUSED,
			       int *ch GCC_UNUSED,
			       int *old_c,
			       int real_c)
d3417 1
a3417 1
		ret = HTParse((ret + 3), startfile, PARSE_ALL);
d3443 5
a3447 4
static void handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag,
			      BOOLEAN *emacs_keys_flag,
			      int *old_c,
			      int real_c)
d3459 2
a3460 2
	 * If vi_keys changed, the keymap did too, so force no cache, and reset
	 * the flag.  - FM
d3470 2
a3471 2
	 * Remember whether we are in dired menu so we can display the right
	 * keymap.
d3481 1
a3481 1
static void handle_LYK_LAST_LINK(void)
d3487 1
a3487 1
	    || links[i].ly != links[curdoc.link].ly) {
d3494 1
a3494 1
static void handle_LYK_LEFT_LINK(void)
d3496 3
a3498 3
    if (curdoc.link > 0 &&
	links[curdoc.link].ly == links[curdoc.link - 1].ly) {
	set_curdoc_link(curdoc.link - 1);
d3502 2
a3503 1
static BOOLEAN handle_LYK_LIST(int *cmd)
d3506 1
a3506 1
     * Don't do if already viewing list page.
d3511 1
a3511 1
	 * Already viewing list page, so get out.
d3518 1
a3518 1
     * Print list page to file.
d3524 4
a3527 3
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
d3537 3
a3539 2
static void handle_LYK_MAIN_MENU(int *old_c,
				 int real_c)
d3542 1
a3542 1
     * If its already the homepage then don't reload it.
d3544 1
a3544 1
    if (!STREQ(curdoc.address, homepage)) {
d3569 1
a3569 1
static void handle_LYK_MINIMAL(void)
d3573 1
a3573 1
	if (!HTcan_reparse_document()) {
d3575 15
a3589 14
	    /*
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HText_setNoCache(HTMainText);
		move_address(&newdoc, &curdoc);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
d3591 1
a3591 1
	}			/* end if no bypass */
d3603 1
a3603 1
    (void) reparse_document();
d3609 2
a3610 1
static void handle_LYK_MODIFY(BOOLEAN *refresh_screen)
d3616 1
a3616 1
	if (ret == PERMIT_FORM_RESULT) {	/* Permit form thrown up */
d3635 2
a3636 1
static BOOLEAN handle_LYK_NESTED_TABLES(int *cmd)
d3644 3
a3646 2
static BOOLEAN handle_LYK_OPTIONS(int *cmd,
				  BOOLEAN *refresh_screen)
a3661 1

d3696 3
a3698 2
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
d3711 1
a3711 1
						LYUserAgent : "")) ||
d3717 9
a3725 8
		     * An option has changed which may influence content
		     * negotiation, and the resource is from a http or https or
		     * lynxcgi URL (the only protocols which currently do
		     * anything with this information).  Set reloading = TRUE
		     * so that proxy caches will be flushed, which is necessary
		     * until the time when all proxies understand HTTP 1.1
		     * Vary:  and all Servers properly use it...  Treat like
		     * case LYK_RELOAD (see comments there).  - KW
d3765 1
a3765 1
		free_address(&curdoc);	/* So it doesn't get pushed. */
d3771 1
a3771 1
	*refresh_screen = TRUE;	/* to repaint screen */
d3773 1
a3773 1
    }				/* end if !LYUseFormsOptions */
d3789 1
a3789 1
     * Don't do if already viewing options page.
d3793 1
a3793 1
	set_address(&newdoc, LYNXOPTIONS_PAGE("/"));
d3806 1
a3806 1
    } else {
d3808 1
a3808 1
	 * If already in the options menu, get out.
d3817 1
a3817 1
static void handle_NEXT_DOC(void)
d3826 4
a3829 3
static void handle_LYK_NEXT_LINK(int c,
				 int *old_c,
				 int real_c)
d3831 1
a3831 1
    if (curdoc.link < nlinks - 1) {	/* next link */
d3835 1
a3835 1
	 * Move to different textarea if TAB in textarea.
d3837 1
a3837 1
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
d3839 1
a3839 1
	    c == '\t') {
d3843 2
a3844 3
	    do
		curdoc.link++;
	    while ((curdoc.link < nlinks - 1) &&
d3855 5
a3859 5
	/*
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
	 */
    } else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
d3862 1
a3862 1
    } else if (more) {		/* next page */
d3871 3
a3873 2
static void handle_LYK_NEXT_PAGE(int *old_c,
				 int real_c)
d3877 1
a3877 1
    } else if (curdoc.link < nlinks - 1) {
d3885 3
a3887 2
static BOOLEAN handle_LYK_NOCACHE(int *old_c,
				  int real_c)
d3907 4
a3910 3
static void handle_LYK_PREV_LINK(int *arrowup,
				 int *old_c,
				 int real_c)
d3912 1
a3912 1
    if (curdoc.link > 0) {	/* previous link */
d3916 1
a3916 1
	       curdoc.link == 0 && Newline == 1) {	/* at the top of list */
d3918 3
a3920 2
	 * If there is only one page of data and the user goes off the top,
	 * just move the cursor to last link on the page.
d3926 1
a3926 1
	 * Go back to the previous page.
d3929 1
a3929 2
			    display_lines : Newline - 1);

d3934 3
a3936 3
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
d3947 15
a3961 15
#define nhist_1 (nhist - 1)	/* workaround for indent */

static int handle_PREV_DOC(int *cmd,
			   int *old_c,
			   int real_c)
{
    if (nhist > 0) {		/* if there is anything to go back to */
	/*
	 * Check if the previous document is a reply from a POST, and if so,
	 * seek confirmation of resubmission if the safe element is not set and
	 * the document is not still in the cache or LYresubmit_posts is set. 
	 * If not confirmed and it is not the startfile, pop it so we go to the
	 * yet previous document, until we're OK or reach the startfile.  If we
	 * reach the startfile and its not OK or we don't get confirmation,
	 * cancel.  - FM
d3968 1
a3968 1
	HTLastConfirmCancelled();	/* reset flag */
d3971 1
a3971 1
	    if (HDOC(nhist_1).post_data == NULL) {
d3974 2
a3975 2
	    WWWDoc.address = HDOC(nhist_1).address;
	    WWWDoc.post_data = HDOC(nhist_1).post_data;
d3977 4
a3980 4
		HDOC(nhist_1).post_content_type;
	    WWWDoc.bookmark = HDOC(nhist_1).bookmark;
	    WWWDoc.isHEAD = HDOC(nhist_1).isHEAD;
	    WWWDoc.safe = HDOC(nhist_1).safe;
d3985 1
a3985 1
	    if (((text = (HText *) HTAnchor_document(tmpanchor)) == NULL &&
d3987 3
a3989 3
		  (conf = confirm_post_resub(WWWDoc.address,
					     HDOC(nhist_1).title,
					     0, 0))
d3992 6
a3997 4
		  (NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &newdoc))) &&
d3999 1
a3999 1
				     HDOC(nhist_1).title,
d4016 4
a4019 4
		    } while (nhist > 1
			     && !are_different((DocInfo *) &history[nhist_1],
					       &curdoc));
		    first = FALSE;	/* have popped at least one */
d4024 4
a4027 3
		 * Break from loop; if user just confirmed to load again
		 * because document wasn't in cache, set LYforce_no_cache to
		 * avoid unnecessary repeat question down the road.  - kw
d4039 1
a4039 1
	 * Set newdoc.address to empty to pop a file.
d4049 1
a4049 1
	return (1);		/* exit on left arrow in main screen */
d4058 3
a4060 2
static void handle_LYK_PREV_PAGE(int *old_c,
				 int real_c)
d4072 4
a4075 3
static void handle_LYK_PRINT(BOOLEAN *ForcePush,
			     int *old_c,
			     int real_c)
d4078 1
a4078 1
	if (*old_c != real_c) {
d4086 1
a4086 1
     * Don't do if already viewing print options page.
d4089 2
a4090 2
	&& print_options(&newdoc.address,
			 curdoc.address, HText_getNumOfLines()) >= 0) {
d4097 1
a4097 1
	*ForcePush = TRUE;	/* see LYpush() and print_options() */
d4103 1
a4103 1
static BOOLEAN handle_LYK_QUIT(void)
d4114 1
a4114 1
	    return (TRUE);
d4119 1
a4119 1
	return (TRUE);
d4126 2
a4127 1
static BOOLEAN handle_LYK_RAW_TOGGLE(int *cmd)
d4140 2
a4141 1
static void handle_LYK_RELOAD(int real_cmd)
d4155 1
a4155 1
     * Check to see if should reload source, or load html
d4168 1
a4168 1
     * Don't assume the reloaded document will be the same.  - FM
d4174 4
a4177 4
     * Do assume the reloaded document will be the same.  - FM
     *
     * (I don't remember all the reasons why we couldn't assume this.  As the
     * problems show up, we'll try to fix them, or add warnings.  - FM)
d4182 1
a4182 1
    free_address(&curdoc);	/* so it doesn't get pushed */
d4187 2
a4188 2
     * Reload should force a cache refresh on a proxy.  -- Ari L. 
     * <luotonen@@dxcern.cern.ch>
d4190 3
a4192 3
     * -- but only if this was really a reload requested by the user, not if we
     * jumped here to handle reloading for INLINE_TOGGLE, IMAGE_TOGGLE,
     * RAW_TOGGLE, etc.  - KW
d4201 2
a4202 1
static void handle_LYK_REMOVE(BOOLEAN *refresh_screen)
d4205 1
a4205 2
	int linkno = curdoc.link;	/* may be changed in local_remove - kw */

d4215 1
a4215 1
static void handle_LYK_RIGHT_LINK(void)
d4217 2
a4218 2
    if (curdoc.link < nlinks - 1 &&
	links[curdoc.link].ly == links[curdoc.link + 1].ly) {
d4223 4
a4226 3
static void handle_LYK_SHELL(BOOLEAN *refresh_screen,
			     int *old_c,
			     int real_c)
d4237 1
a4237 1
	    LYSystem(LYSysShell());
d4241 1
a4241 1
	if (*old_c != real_c) {
d4248 1
a4248 1
static void handle_LYK_SOFT_DQUOTES(void)
d4253 15
a4267 14
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
d4269 1
a4269 1
    }				/* end if no bypass */
d4275 1
a4275 1
    (void) reparse_document();
d4280 2
a4281 1
static void handle_LYK_SOURCE(char **ownerS_address_p)
d4323 1
a4323 1
	FREE(*ownerS_address_p);	/* not used with source_cache */
d4325 1
a4325 1
	HTMLSetCharacterHandling(current_char_set);	/* restore now */
d4337 1
a4337 1
    free_address(&curdoc);	/* so it doesn't get pushed */
d4341 1
a4341 1
static void handle_LYK_SWITCH_DTD(void)
a4344 1

d4358 3
a4360 3
	     * If currently viewing preparsed source, switching to the other
	     * DTD parsing may show source differences, so stay in source view
	     * - kw
d4367 1
a4367 1
	     */
d4382 1
a4382 1
    }				/* end if no bypass */
d4401 1
a4401 1
static void handle_LYK_TAG_LINK(void)
d4405 1
a4405 1
	    return;		/* Never tag the parent directory */
d4413 1
a4413 1
	     * HTList-based management of tag list, see LYLocal.c - KW
d4415 2
a4416 2
	    HTList *t1 = tagged;
	    char *tagname = NULL;
d4419 1
a4419 1
	    while ((tagname = (char *) HTList_nextObject(t1)) != NULL) {
d4424 1
a4424 1
		    tagflag(OFF, curdoc.link);
d4432 3
a4434 3
		StrAllocCopy(tagname, links[curdoc.link].lname);
		HTList_addObject(tagged, tagname);
		tagflag(ON, curdoc.link);
d4437 1
a4437 1
	if (curdoc.link < nlinks - 1) {
d4439 1
a4439 1
	} else if (!more && Newline == 1 && curdoc.link == nlinks - 1) {
d4441 1
a4441 1
	} else if (more) {	/* next page */
d4448 1
a4448 1
static void handle_LYK_TOGGLE_HELP(void)
d4456 5
a4460 4
static void handle_LYK_TOOLBAR(BOOLEAN *try_internal,
			       BOOLEAN *force_load,
			       int *old_c,
			       int real_c)
d4478 1
a4478 1
	*force_load = TRUE;	/* force MainLoop to reload */
d4482 2
a4483 1
static void handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr)
d4487 2
a4488 1
     * Check whether we've started a TRACE log in this session.  - FM
d4496 1
a4496 1
     * Don't do if already viewing the TRACE log.  - FM
d4502 9
a4510 7
     * If TRACE mode is on, turn it off during this fetch of the TRACE log, so
     * we don't enter stuff about this fetch, and set a flag for turning it
     * back on when we return to this loop.  Note that we'll miss any messages
     * about memory exhaustion if it should occur.  It seems unlikely that
     * anything else bad might happen, but if it does, we'll miss messages
     * about that too.  We also fflush(), close, and open it again, to make
     * sure all stderr messages thus far will be in the log.  - FM
d4515 1
a4515 1
    LYLocalFileToURL(&(newdoc.address), LYTraceLogPath);
d4533 1
a4533 1
static void handle_LYK_UPLOAD(void)
d4536 1
a4536 1
     * Don't do if already viewing upload options page.
d4550 3
a4552 2
	 * Uncache the current listing so that it will be updated to included
	 * the uploaded file if placed in the current directory.  - FM
d4555 1
a4555 1
    }
d4559 4
a4562 3
static void handle_LYK_UP_HALF(int *arrowup,
			       int *old_c,
			       int real_c)
d4565 1
a4565 2
	int scrollamount = display_lines / 2;

d4572 3
a4574 3
		    HText_LinksInLines(HTMainText,
				       Newline,
				       scrollamount);
d4585 5
a4589 4
static void handle_LYK_UP_LINK(int *follow_col,
			       int *arrowup,
			       int *old_c,
			       int real_c)
a4599 1

d4614 1
a4614 1
    } else if (curdoc.line > 1 && Newline > 1) {	/* previous page */
d4616 1
a4616 2
			    display_lines : Newline - 1);

d4620 4
a4623 4
	    links[0].ly - 1 + scrollamount <= display_lines) {
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
d4634 4
a4637 3
static void handle_LYK_UP_TWO(int *arrowup,
			      int *old_c,
			      int real_c)
a4640 1

d4645 2
a4646 2
		    HText_LinksInLines(HTMainText,
				       Newline, scrollamount);
d4657 4
a4660 3
static void handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
d4665 1
a4665 1
	if (*old_c != real_c) {
d4673 2
a4674 2
     * See if a bookmark exists.  If it does replace newdoc.address with its
     * name.
d4688 1
a4688 1
	LYforce_no_cache = TRUE;	/*force the document to be reloaded */
d4707 3
a4709 2
static BOOLEAN handle_LYK_VLINKS(int *cmd,
				 BOOLEAN *newdoc_link_is_absolute)
d4715 1
a4715 1
	 * Already viewing visited links page, so get out.
d4722 1
a4722 1
     * Print visited links page to file.
d4747 3
a4749 2
void handle_LYK_WHEREIS(int cmd,
			BOOLEAN *refresh_screen)
d4752 1
a4752 1
					      HText_pageHasPrevTarget());
d4754 1
a4754 1
    int oldcur = curdoc.link;	/* temporarily remember */
a4755 1

d4763 4
a4766 2
	 * Reset prev_target to force prompting for a new search string and to
	 * turn off highlighting if no search string is entered by the user.
d4770 1
a4770 1
    found = textsearch(&curdoc, prev_target, sizeof(prev_target) - 1,
d4774 2
a4775 2
			  ? 1
			  : -1));
d4778 4
a4781 3
     * Force a redraw to ensure highlighting of hits even when found on the
     * same page, or clearing of highlighting if the default search string was
     * erased without replacement.  - FM
d4784 3
a4786 3
     * Well let's try to avoid it at least in a few cases
     * where it is not needed. - kw
     */
d4788 1
a4788 1
	*refresh_screen = TRUE;	/* doesn't really matter */
d4796 1
a4796 1
	       links[curdoc.link].ly >= (display_lines / 3)) {
d4798 4
a4801 4
    } else if ((case_sensitive && 0 != strcmp(prev_target,
					      remember_old_target)) ||
	       (!case_sensitive && 0 != strcasecomp8(prev_target,
						     remember_old_target))) {
d4810 7
a4816 6
static void handle_LYK_digit(int c,
			     BOOLEAN *force_load,
			     char *user_input_buffer,
			     int *old_c,
			     int real_c,
			     BOOLEAN *try_internal GCC_UNUSED)
d4829 1
a4829 1
	 * Follow a normal link.
d4835 5
a4839 4
	 * For internal links, retain POST content if present.  If we are on
	 * the List Page, prevent pushing it on the history stack.  Otherwise
	 * set try_internal to signal that the top of the loop should attempt
	 * to reposition directly, without calling getfile.  - kw
d4850 1
a4850 1
		    HTLastConfirmCancelled();	/* reset flag */
d4853 2
a4854 4
					    ((LYresubmit_posts &&
					      HText_POSTReplyLoaded(&newdoc))
					     ? 1
					     : 2),
d4887 2
a4888 2
		 * Don't push the List Page if we follow an internal link given
		 * by it.  - kw
d4899 1
a4899 1
	     * Free POST content if not an internal link.  - kw
d4905 2
a4906 2
	 * Might be an anchor in the same doc from a POST form.  If so, don't
	 * free the content.  -- FM
d4917 1
a4917 1
	*force_load = TRUE;	/* force MainLoop to reload */
d4922 1
a4922 1
	 * Position on a normal link, don't follow it.  - KW
d4928 1
a4928 1
	     * It's a link in the current page.  - FM
d4933 4
a4936 3
		     * It's the current link, and presumably reflects a typo in
		     * the statusline entry, so issue a statusline message for
		     * the typo-prone users (like me 8-).  - FM
d4946 1
a4946 1
		     * It's a different link on this page,
d4953 1
a4953 1
	break;			/* nothing more to do */
d4957 1
a4957 1
	 * Position on a page in this document.  - FM
d4963 3
a4965 2
	     * It's the current page, so issue a statusline message for the
	     * typo-prone users (like me 8-).  - FM
d4993 1
a4993 1
void handle_LYK_CHDIR(void)
d5007 1
a5007 1
    if (LYgetstr(buf, VISIBLE, sizeof(buf) - 1, 0) < 0 || !*buf) {
d5015 1
a5015 1
	HTSprintf0(&p, "%s%s", Home_Dir(), buf + 1);
d5038 1
a5038 1
	/*if in dired, load content of other directory */
d5040 1
a5040 1
	    && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
d5042 1
a5042 1
	    char *addr = NULL;
d5080 1
a5080 1
static int repeat_to_delta(int n)
d5094 1
a5094 1
static void handle_LYK_SHIFT_LEFT(BOOLEAN *flag, int count)
d5108 1
a5108 1
static void handle_LYK_SHIFT_RIGHT(BOOLEAN *flag, int count)
d5118 3
a5120 2
static BOOLEAN handle_LYK_LINEWRAP_TOGGLE(int *cmd,
					  BOOLEAN *flag)
d5122 1
a5122 2
    static char *choices[] =
    {
d5133 1
a5133 2
    static int wrap[] =
    {
d5136 1
a5136 1
	12,			/* In units of 1/12 */
d5150 1
a5150 1
    c = LYChoosePopup(!LYwideLines, LYlines / 2 - 2, LYcols / 2 - 6,
d5153 5
a5157 4
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
d5173 5
a5177 5
 * Here's where we do all the work.
 * mainloop is basically just a big switch dependent on the users input.  I
 * have tried to offload most of the work done here to procedures to make it
 * more modular, but this procedure still does a lot of variable manipulation. 
 * This needs some work to make it neater.  - Lou Moutilli
d5181 1
a5181 1
int mainloop(void)
d5183 1
a5183 1
#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
d5224 5
a5228 5
    /* "internal" means "within the same document, with certainty".  It includes a
     * space so it cannot conflict with any (valid) "TYPE" attributes on A
     * elements.  [According to which DTD, anyway??] - kw
     */
    HTInternalLink = HTAtom_for("internal link");	/* init, used as const */
d5231 1
a5231 1
    WWW_SOURCE = HTAtom_for("www/source");	/* init, used as const */
d5234 9
a5242 9
    /*
     * curdoc.address contains the name of the file that is currently open.
     * newdoc.address contains the name of the file that will soon be
     *                opened if it exits.
     * prev_target    contains the last search string the user searched for.
     * newdoc.title   contains the link name that the user last chose to get
     *                into the current link (file).
     */
    /* initialize some variables */
d5266 1
a5266 1
  initialize:
d5304 2
a5305 2
	     * See if a bookmark page exists.  If it does, replace
	     * newdoc.address with its name
d5308 1
a5308 1
		*cp != '\0' && strcmp(cp, " ")) {
d5328 1
a5328 1
	display_lines = LYlines - 4;
d5330 1
a5330 1
	display_lines = LYlines - 2;
d5334 1
a5334 2
	if (curdoc.style != NULL)
	    force_load = TRUE;
d5337 2
a5338 2
	 * If newdoc.address is different then curdoc.address then we need to
	 * go out and find and load newdoc.address.
d5343 3
a5345 3
	    force_load = FALSE;	/* done */
	    if (TRACE && LYCursesON) {
		LYHideCursor();	/* make sure cursor is down */
d5347 1
a5347 1
		LYaddstr("\n");
d5349 1
a5349 17
		LYrefresh();
	    }
	  try_again:
	    /*
	     * Push the old file onto the history stack if we have a current
	     * doc and a new address.  - FM
	     */
	    if (curdoc.address && newdoc.address) {
		/*
		 * Don't actually push if this is a LYNXDOWNLOAD URL, because
		 * that returns NORMAL even if it fails due to a spoof attempt
		 * or file access problem, and we set the newdoc structure
		 * elements to the curdoc structure elements under case NORMAL. 
		 * - FM
		 */
		if (!isLYNXDOWNLOAD(newdoc.address)) {
		    LYpush(&curdoc, ForcePush);
d5351 1
a5351 1
	    } else if (!newdoc.address) {
d5353 2
a5354 2
		 * If newdoc.address is empty then pop a file and load it.  -
		 * FM
d5356 22
a5377 2
		LYhist_prev(&newdoc);
		popped_doc = TRUE;
a5379 15
		/*
		 * If curdoc had been reached via an internal
		 * (fragment) link from what we now have just
		 * popped into newdoc, then override non-caching in
		 * all cases. - kw
		 */
		if (curdoc.internal_link &&
		    !are_phys_different(&curdoc, &newdoc)) {
		    LYinternal_flag = TRUE;
		    LYoverride_no_cache = TRUE;
		    LYforce_no_cache = FALSE;
		    try_internal = TRUE;
		} else
#endif /* TRACK_INTERNAL_LINKS */
		{
d5381 8
a5388 15
		     * Force a no_cache override unless it's a bookmark file,
		     * or it has POST content and LYresubmit_posts is set
		     * without safe also set, and we are not going to another
		     * position in the current document or restoring the
		     * previous document due to a NOT_FOUND or NULLFILE return
		     * value from getfile().  - FM
		     */
		    if ((newdoc.bookmark != NULL) ||
			(newdoc.post_data != NULL &&
			 !newdoc.safe &&
			 LYresubmit_posts &&
			 !override_LYresubmit_posts &&
			 NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			LYoverride_no_cache = FALSE;
		    } else {
d5390 24
d5416 1
a5416 2
	    }
	    override_LYresubmit_posts = FALSE;
d5418 6
a5423 12
	    if (HEAD_request) {
		/*
		 * Make SURE this is an appropriate request.  - FM
		 */
		if (newdoc.address) {
		    if (LYCanDoHEAD(newdoc.address) == TRUE) {
			newdoc.isHEAD = TRUE;
		    } else if (isLYNXIMGMAP(newdoc.address)) {
			if (LYCanDoHEAD(newdoc.address + LEN_LYNXIMGMAP) == TRUE) {
			    StrAllocCopy(temp, newdoc.address + LEN_LYNXIMGMAP);
			    free_address(&newdoc);
			    newdoc.address = temp;
d5425 8
a5432 1
			    temp = NULL;
d5435 2
a5437 3
		try_internal = FALSE;
		HEAD_request = FALSE;
	    }
d5439 26
a5464 25
	    /*
	     * If we're getting the TRACE log and it's not new, check whether
	     * its HText structure has been dumped, and if so, fflush() and
	     * fclose() it to ensure it's fully updated, and then fopen() it
	     * again.  - FM
	     */
	    if (LYUseTraceLog == TRUE &&
		trace_mode_flag == FALSE &&
		LYTraceLogFP != NULL &&
		LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
		DocAddress WWWDoc;
		HTParentAnchor *tmpanchor;

		WWWDoc.address = newdoc.address;
		WWWDoc.post_data = newdoc.post_data;
		WWWDoc.post_content_type = newdoc.post_content_type;
		WWWDoc.bookmark = newdoc.bookmark;
		WWWDoc.isHEAD = newdoc.isHEAD;
		WWWDoc.safe = newdoc.safe;
		tmpanchor = HTAnchor_findAddress(&WWWDoc);
		if ((HText *) HTAnchor_document(tmpanchor) == NULL) {
		    if (!LYReopenTracelog(&trace_mode_flag)) {
			old_c = 0;
			cmd = LYK_PREV_DOC;
			goto new_cmd;
a5466 1
	    }
d5468 10
a5477 10
	    LYRequestTitle = newdoc.title;
	    if (newdoc.bookmark)
		LYforce_HTML_mode = TRUE;
	    if (LYValidate &&
		startfile_ok &&
		newdoc.address && startfile && homepage &&
		(!strcmp(newdoc.address, startfile) ||
		 !strcmp(newdoc.address, homepage))) {
		LYPermitURL = TRUE;
	    }
d5479 6
a5484 6
	    /* reset these two variables here before getfile()
	     * so they will be available in partial mode
	     * (was previously implemented in case NORMAL).
	     */
	    *prev_target = '\0';	/* Reset for new coming document */
	    Newline = newdoc.line;	/* set for LYGetNewline() */
d5487 1
a5487 1
	    psrc_first_tag = TRUE;
d5490 1
a5490 1
	    textfields_need_activation = textfields_activation_option;
d5492 10
a5501 10
	    FREE(LYRequestReferer);
	    /*
	     * Don't send Referer if we have to load a document again that we
	     * got from the history stack.  We don't know any more how we
	     * originally got to that page.  Using a Referer based on the
	     * current HTMainText could only be right by coincidence.  - kw
	     * 1999-11-01
	     */
	    if (popped_doc)
		LYNoRefererForThis = TRUE;
d5504 8
a5511 7
	    if (try_internal) {
		if (newdoc.address &&
		    isLYNXIMGMAP(newdoc.address)) {
		    try_internal = FALSE;
		} else if (curdoc.address &&
			   isLYNXIMGMAP(curdoc.address)) {
		    try_internal = FALSE;
d5513 32
a5544 18
	    }
	    if (try_internal) {
		char *hashp = findPoundSelector(newdoc.address);

		if (hashp) {
		    HTFindPoundSelector(hashp + 1);
		}
		getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		try_internal = FALSE;	/* done */
		/* fix up newdoc.address which may have been fragment-only */
		if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
		    if (!hashp) {
			set_address(&newdoc, HTLoadedDocumentURL());
		    } else {
			StrAllocCopy(temp, HTLoadedDocumentURL());
			StrAllocCat(temp, hashp);	/* append fragment */
			set_address(&newdoc, temp);
			FREE(temp);
d5546 1
d5548 1
a5548 16
	    } else {
		if (newdoc.internal_link && newdoc.address &&
		    *newdoc.address == '#' && nhist > 0) {
		    char *cp0;

		    if (isLYNXIMGMAP(HDOC(nhist_1).address))
			cp0 = HDOC(nhist_1).address + LEN_LYNXIMGMAP;
		    else
			cp0 = HDOC(nhist_1).address;
		    StrAllocCopy(temp, cp0);
		    (void) trimPoundSelector(temp);
		    StrAllocCat(temp, newdoc.address);
		    free_address(&newdoc);
		    newdoc.address = temp;
		    temp = NULL;
		}
a5549 3
	    }
#else /* TRACK_INTERNAL_LINKS */
	    getresult = getfile(&newdoc);
d5553 1
a5553 1
	    textinput_redrawn = FALSE;	/* for sure */
d5556 1
a5556 1
	    switch (getresult) {
d5558 1
a5558 9
	    case NOT_FOUND:
		/*
		 * OK!  can't find the file, so it must not be around now.  Do
		 * any error logging, if appropriate.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		if (!first_file && !LYCancelledFetch) {
d5560 2
a5561 5
		     * Do error mail sending and/or traversal stuff.  Note that
		     * the links[] elements may not be valid at this point, if
		     * we did call HTuncache_current_document!  This should not
		     * have happened for traversal, but for sending error mail
		     * check that HTMainText exists for this reason.  - kw
d5563 4
a5566 11
		    if (error_logging && nhist > 0 && !popped_doc &&
			!LYUserSpecifiedURL &&
			HTMainText &&
			nlinks > 0 && curdoc.link < nlinks &&
			!isLYNXHIST(NonNull(newdoc.address)) &&
			!isLYNXCOOKIE(NonNull(newdoc.address))) {
			char *mail_owner = NULL;

			if (owner_address && isMAILTO_URL(owner_address)) {
			    mail_owner = owner_address + LEN_MAILTO_URL;
			}
d5568 7
a5574 3
			 * Email a bad link message to the owner of the
			 * document, or to ALERTMAIL if defined, but NOT to
			 * lynx-dev (it is rejected in mailmsg).  - FM, kw
d5576 16
d5593 1
a5593 1
			if (mail_owner)
d5595 7
a5601 7
			    mailmsg(curdoc.link,
				    mail_owner,
				    HDOC(nhist_1).address,
				    HDOC(nhist_1).title);
		    }
		    if (traversal) {
			FILE *ofp;
d5603 19
a5621 4
			if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
			    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				perror(NOOPEN_TRAV_ERR_FILE);
				exit_immediately(EXIT_FAILURE);
d5623 1
a5624 15
			if (nhist > 0) {
			    fprintf(ofp,
				    "%s %s\tin %s\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target,
				    HDOC(nhist_1).address);
			} else {
			    fprintf(ofp,
				    "%s %s\t\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target);
			}
			LYCloseOutput(ofp);
a5625 1
		}
a5626 5
		/*
		 * Fall through to do the NULL stuff and reload the old file,
		 * unless the first file wasn't found or has gone missing.
		 */
		if (!nhist) {
d5628 3
a5630 1
		     * If nhist = 0 then it must be the first file.
d5632 1
a5632 25
		    exit_immediately_with_error_message(NOT_FOUND, first_file);
		    return (EXIT_FAILURE);
		}
		/* FALLTHRU */

	    case NULLFILE:
		/*
		 * Not supposed to return any file.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		popped_doc = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		free_address(&newdoc);	/* to pop last doc */
		FREE(newdoc.bookmark);
		LYJumpFileURL = FALSE;
		reloading = FALSE;
		LYPermitURL = FALSE;
		LYCancelledFetch = FALSE;
		ForcePush = FALSE;
		LYforce_HTML_mode = FALSE;
		force_old_UCLYhndl_on_reload = FALSE;
		if (traversal) {
		    crawl_ok = FALSE;
		    if (traversal_link_to_add) {
d5634 1
a5634 3
			 * It's a binary file, or the fetch attempt failed. 
			 * Add it to TRAVERSE_REJECT_FILE so we don't try again
			 * in this run.
d5636 34
a5669 2
			if (!lookup_reject(traversal_link_to_add)) {
			    add_to_reject_list(traversal_link_to_add);
a5670 1
			FREE(traversal_link_to_add);
a5671 5
		}
		/*
		 * Make sure the first file was found and has not gone missing.
		 */
		if (!nhist) {
d5673 2
a5674 1
		     * If nhist = 0 then it must be the first file.
d5676 1
a5676 2
		    if (first_file && homepage &&
			!LYSameFilename(homepage, startfile)) {
d5678 1
a5678 8
			 * Couldn't return to the first file but there is a
			 * homepage we can use instead.  Useful for when the
			 * first URL causes a program to be invoked.  - GL
			 *
			 * But first make sure homepage is different from
			 * startfile (above), then make it the same (below) so
			 * we don't enter an infinite getfile() loop on on
			 * failures to find the files.  - FM
d5680 24
a5703 11
			set_address(&newdoc, homepage);
			LYFreePostData(&newdoc);
			FREE(newdoc.bookmark);
			StrAllocCopy(startfile, homepage);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
			newdoc.internal_link = FALSE;
			goto try_again;
		    } else {
			exit_immediately_with_error_message(NULLFILE, first_file);
			return (EXIT_FAILURE);
a5704 1
		}
d5706 31
a5736 30
		/*
		 * If we're going to pop from history because getfile didn't
		 * succeed, reset LYforce_no_cache first.  This would have been
		 * done in HTAccess.c if the request got that far, but the URL
		 * may have been handled or rejected in getfile without taking
		 * care of that.  - kw
		 */
		LYforce_no_cache = FALSE;
		/*
		 * Retrieval of a newdoc just failed, and just going to
		 * try_again would pop the next doc from history and try to get
		 * it without further questions.  This may not be the right
		 * thing to do if we have POST data, so fake a PREV_DOC key if
		 * it seems that some prompting should be done.  This doesn't
		 * affect the traversal logic, since with traversal POST data
		 * can never occur.  - kw
		 */
		if (HDOC(nhist - 1).post_data &&
		    !HDOC(nhist - 1).safe) {
		    if (HText_POSTReplyLoaded((DocInfo *) &history[(nhist_1)])) {
			override_LYresubmit_posts = TRUE;
			goto try_again;
		    }
		    /* Set newdoc fields, just in case the PREV_DOC gets
		     * cancelled.  - kw
		     */
		    if (!curdoc.address) {
			set_address(&newdoc, HTLoadedDocumentURL());
			StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			if (HTMainAnchor
d5738 24
a5761 21
			    BStrCopy(newdoc.post_data,
				     HTMainAnchor->post_data);
			    StrAllocCopy(newdoc.post_content_type,
					 HTMainAnchor->post_content_type);
			} else {
			    BStrFree(newdoc.post_data);
			}
			newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			newdoc.safe = HTLoadedDocumentIsSafe();
			newdoc.internal_link = FALSE;
		    } else {
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
d5763 2
a5764 5
		    cmd = LYK_PREV_DOC;
		    goto new_cmd;
		}
		override_LYresubmit_posts = TRUE;
		goto try_again;
d5766 7
a5772 7
	    case NORMAL:
		/*
		 * Marvelously, we got the document!
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
d5774 15
a5788 16
		/*
		 * If it's the first file and we're interactive, check whether
		 * it's a bookmark file which was not accessed via the -book
		 * switch.  - FM
		 */
		if (((first_file == TRUE) &&
		     (dump_output_immediately == FALSE) &&
		     !(newdoc.bookmark && *newdoc.bookmark)) &&
		    ((LYisLocalFile(newdoc.address) == TRUE) &&
		     !(strcmp(NonNull(HText_getTitle()),
			      BOOKMARK_TITLE))) &&
		    (temp = HTParse(newdoc.address, "",
				    PARSE_PATH + PARSE_PUNCTUATION)) != NULL) {
		    const char *name = wwwName(Home_Dir());

		    len = strlen(name);
d5790 2
a5791 2
		    if (!strncasecomp(temp, name, len) &&
			strlen(temp) > len)
d5793 2
a5794 2
		    if (!strncmp(temp, name, len) &&
			strlen(temp) > len)
d5796 16
a5811 12
		    {
			/*
			 * We're interactive and this might be a bookmark file
			 * entered as a startfile rather than invoked via
			 * -book.  Check if it's in our bookmark file list, and
			 * if so, reload if with the relevant bookmark elements
			 * set.  - FM
			 */
			cp = NULL;
			if (temp[len] == '/') {
			    if (strchr(&temp[(len + 1)], '/')) {
				HTSprintf0(&cp, ".%s", &temp[len]);
d5813 1
a5813 1
				StrAllocCopy(cp, &temp[(len + 1)]);
d5815 7
a5821 9
			} else {
			    StrAllocCopy(cp, &temp[len]);
			}
			for (i = 0; i <= MBM_V_MAXFILES; i++) {
			    if (MBM_A_subbookmark[i] &&
				LYSameFilename(cp, MBM_A_subbookmark[i])) {
				StrAllocCopy(BookmarkPage,
					     MBM_A_subbookmark[i]);
				break;
d5823 13
a5835 14
			}
			FREE(cp);
			if (i <= MBM_V_MAXFILES) {
			    FREE(temp);
			    if (LYValidate) {
				HTAlert(BOOKMARKS_DISABLED);
				return (EXIT_FAILURE);
			    }
			    if ((temp = HTParse(newdoc.address, "",
						PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION))) {
				set_address(&newdoc, temp);
				HTuncache_current_document();
				free_address(&curdoc);
				StrAllocCat(newdoc.address,
d5837 7
a5843 7
				StrAllocCat(newdoc.address, "/");
				StrAllocCat(newdoc.address,
					    (strncmp(BookmarkPage, "./", 2) ?
					     BookmarkPage :
					     (BookmarkPage + 2)));
				StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				StrAllocCopy(newdoc.bookmark, BookmarkPage);
d5845 2
a5846 2
				if (curdoc.style)
				    StrAllocCopy(newdoc.style, curdoc.style);
d5848 12
a5859 11
				StrAllocCopy(startrealm, newdoc.address);
				LYFreePostData(&newdoc);
				newdoc.isHEAD = FALSE;
				newdoc.safe = FALSE;
				FREE(temp);
				if (!strcmp(homepage, startfile))
				    StrAllocCopy(homepage, newdoc.address);
				StrAllocCopy(startfile, newdoc.address);
				CTRACE((tfp, "Reloading as bookmarks=%s\n",
					newdoc.address));
				goto try_again;
d5862 1
d5864 1
a5864 3
		    cp = NULL;
		}
		FREE(temp);
d5866 1
a5866 7
		if (traversal) {
		    /*
		     * During traversal build up lists of all links traversed. 
		     * Traversal mode is a special feature for traversing http
		     * links in the web.
		     */
		    if (traversal_link_to_add) {
d5868 3
a5870 1
			 * Add the address we sought to TRAVERSE_FILE.
d5872 14
a5885 3
			if (!lookup(traversal_link_to_add))
			    add_to_table(traversal_link_to_add);
			FREE(traversal_link_to_add);
a5886 7
		    if (curdoc.address && curdoc.title &&
			!isLYNXIMGMAP(curdoc.address))
			/*
			 * Add the address we got to TRAVERSE_FOUND_FILE.
			 */
			add_to_traverse_list(curdoc.address, curdoc.title);
		}
d5888 15
a5902 15
		/*
		 * If this was a LYNXDOWNLOAD, we still have curdoc, not a
		 * newdoc, so reset the address, title and positioning
		 * elements.  - FM
		 */
		if (newdoc.address && curdoc.address &&
		    isLYNXDOWNLOAD(newdoc.address)) {
		    copy_address(&newdoc, &curdoc);
		    StrAllocCopy(newdoc.title, (curdoc.title ?
						curdoc.title : ""));
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    newdoc.internal_link = FALSE;	/* can't be true. - kw */
		}
d5904 14
a5917 14
		/*
		 * Set Newline to the saved line.  It contains the line the
		 * user was on if s/he has been in the file before, or it is 1
		 * if this is a new file.
		 *
		 * We already set Newline before getfile() and probably update
		 * it explicitly if popping from the history stack via LYpop()
		 * or LYpop_num() within getfile() cycle.
		 *
		 * In partial mode, Newline was probably updated in
		 * LYMainLoop_pageDisplay() if user scrolled the document while
		 * loading.  Incremental loading stage already closed in
		 * HT*Copy().
		 */
d5919 2
a5920 2
		/* Newline = newdoc.line; */
		display_partial = FALSE;	/* for sure, LYNXfoo:/ may be a problem */
d5922 5
a5926 5
		/* Should not be needed either if we remove "DISP_PARTIAL" from
		 * LYHistory.c, but lets leave it as an important comment for
		 * now.
		 */
		Newline = newdoc.line;
d5929 7
a5935 6
		/*
		 * If we are going to a target line or the first page of a
		 * popped document, override any www_search line result.
		 */
		if (Newline > 1 || popped_doc == TRUE)
		    www_search_result = -1;
d5937 7
a5943 7
		/*
		 * Make sure curdoc.line will not be equal to Newline, so we
		 * get a redraw.
		 */
		curdoc.line = -1;
		break;
	    }			/* end switch */
d5947 1
a5947 1
		    LYSleepAlert();	/* allow me to look at the results */
d5952 1
a5952 1
	     * Set the files the same.
d5961 1
a5961 1
		style_readFromFile(curdoc.style);
d5967 2
a5968 2
	     * Set the remaining document elements and add to the visited links
	     * list.  - FM
d5974 2
a5975 2
		if ((LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
		    && !HText_getOwner())
d5991 6
a5996 5
	    /*
	     * Reset WWW present mode so that if we were getting the source, we
	     * get rendered HTML from now on.
	     */
	    HTOutputFormat = WWW_PRESENT;
d5998 1
a5998 1
	    psrc_view = FALSE;
d6001 16
a6016 1
	    HTMLSetCharacterHandling(current_char_set);		/* restore, for sure? */
d6018 1
a6018 14
	    /*
	     * Reset all of the other relevant flags.  - FM
	     */
	    LYUserSpecifiedURL = FALSE;		/* only set for goto's and jumps's */
	    LYJumpFileURL = FALSE;	/* only set for jump's */
	    LYNoRefererForThis = FALSE;		/* always reset on return here */
	    reloading = FALSE;	/* set for RELOAD and NOCACHE keys */
	    HEAD_request = FALSE;	/* only set for HEAD requests */
	    LYPermitURL = FALSE;	/* only for LYValidate or check_realm */
	    ForcePush = FALSE;	/* only set for some PRINT requests. */
	    LYforce_HTML_mode = FALSE;
	    force_old_UCLYhndl_on_reload = FALSE;
	    popped_doc = FALSE;
	    pending_form_c = -1;
a6019 2
	}
	/* end if (LYforce_no_cache || force_load || are_different(...)) */
d6026 1
a6026 1
	    return (EXIT_SUCCESS);
d6030 2
a6031 2
	 * If the recent_sizechange variable is set to TRUE then the window
	 * size changed recently.
d6035 12
a6046 13
	     * First we need to make sure the display library - curses, slang,
	     * whatever - gets notified about the change, and gets a chance to
	     * update external structures appropriately.  Hopefully the
	     * stop_curses()/start_curses() sequence achieves this, at least if
	     * the display library has a way to get the new screen size from
	     * the OS.
	     *
	     * However, at least for ncurses, the update of the internal
	     * structures will come still too late - the changed screen size is
	     * detected in doupdate(), which would only be called (indirectly
	     * through the HText_pageDisplay below) after the WINDOW structures
	     * are already filled based on the old size.  So we notify the
	     * ncurses library directly here.  - kw
d6052 1
a6052 1
#if 0				/* defined(PDCURSES) && defined(HAVE_XCURSES) */
d6063 1
a6063 1
	    refresh_screen = TRUE;	/* to force a redraw */
d6068 1
a6068 1
		display_lines = LYlines - 4;
d6070 1
a6070 1
		display_lines = LYlines - 2;
d6075 6
a6080 5
	    /*
	     * This was a WWW search, set the line to the result of the search.
	     */
	    Newline = www_search_result;
	    www_search_result = -1;	/* reset */
d6085 1
a6085 1
	     * We can never again have the first file.
d6090 3
a6092 2
	     * Set the startrealm, and deal as best we can with preserving
	     * forced HTML mode for a local startfile.  - FM
d6095 1
a6095 1
			   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
d6102 1
a6102 1
				     PARSE_PATH + PARSE_PUNCTUATION))) {
d6111 11
a6121 10
			 * We forced HTML for a local startfile which is not a
			 * bookmark file and has a path of at least two
			 * letters.  If it doesn't have a suffix mapped to
			 * text/html, we'll set the entire path (including the
			 * lead slash) as a "suffix" mapped to text/html to
			 * ensure it is always treated as an HTML source file. 
			 * We are counting on a tail match to this full path
			 * for some other URL fetched during the session having
			 * too low a probability to worry about, but it could
			 * happen.  - FM
d6130 1
a6130 1
			*(cp + 1) = '\0';
d6139 1
a6139 1
		 * Set up the crawl output stuff.
d6147 1
a6147 1
		 * Set up the traversal_host comparison string.
d6156 1
a6156 1
				   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
d6169 3
a6171 2
		 * If homepage was not equated to startfile, make the homepage
		 * URL the first goto entry.  - FM
d6176 4
a6179 3
		 * If we are not starting up with startfile (e.g., had -book),
		 * or if we are using the startfile and it has no POST content,
		 * make the startfile URL a goto entry.  - FM
d6192 1
d6202 1
a6202 1
	    if (HTcan_reparse_document()) {
d6205 1
a6205 1
	    } else {
d6210 5
a6214 5
		/*  currently disabled ***
		   HTUserMsg(gettext("Reparsing document under current settings..."));
		   cmd = LYK_RELOAD;
		   goto new_cmd;
		 */
d6219 2
a6220 2
	    from_source_cache = FALSE;	/* reset */
	    curdoc.line = -1;	/* so curdoc.line != Newline, see below */
d6225 3
a6227 3
	 * If the curdoc.line is different than Newline then there must have
	 * been a change since last update.  Run HText_pageDisplay() create a
	 * fresh screen of text out.
d6229 2
a6230 2
	 * If we got new HTMainText go this way.  All display_partial calls
	 * ends here for final redraw.
d6243 1
a6243 1
		showtags(tagged);
d6247 1
a6247 1
	     * If more equals TRUE, then there is more info below this page.
d6250 1
a6250 1
	    curdoc.line = Newline = HText_getTopOfScreen() + 1;
d6254 2
a6255 2
		 * If we don't yet have a title, try to get it, or set to that
		 * for newdoc.title.  - FM
d6265 2
a6266 2
	     * If the request is to highlight a link which is counted from the
	     * start of document, correct the link number:
d6277 2
a6278 1
		 * arrowup is set if we just came up from a page below.
d6288 6
a6293 6
		     * We may have popped a doc (possibly in local_dired) which
		     * didn't have any links when it was pushed, but does have
		     * links now (e.g., a file was created).  Code below
		     * assumes that curdoc.link is valid and that
		     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  -
		     * KW
d6299 1
a6299 1
	    show_help = FALSE;	/* reset */
d6302 1
a6302 1
	    curdoc.line = Newline;	/* set */
d6306 1
a6306 1
	 * Refresh the screen if necessary.
d6318 1
a6318 1
	    HText_pageDisplay(Newline, prev_target);
d6326 1
a6326 1
	     * If more equals TRUE, then there is more info below this page.
d6331 6
a6336 4
	     * Adjust curdoc.link as above; nlinks may have changed, if the
	     * refresh_screen flag was set as a result of a size change.  Code
	     * below assumes that curdoc.link is valid and that
	     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  - kw
d6345 1
a6345 1
		noviceline(more);	/* print help message */
d6364 1
a6364 1
#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
d6371 1
a6371 1
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
d6373 1
a6373 1
		    switch (links[curdoc.link].l_form->type) {
d6404 1
a6404 1
		}
d6422 1
a6422 1
	    if (strlen(curdoc.address) < sizeof(temp_buff) - 1) {
d6434 1
a6434 1
	 * Report unread or new mail, if appropriate.
d6440 3
a6442 2
	 * If help is not on the screen, then put a message on the screen to
	 * tell the user other misc info.
d6445 3
a6447 3
	    show_main_statusline(links[curdoc.link],
				 (curlink_is_editable && textinput_activated) ?
				 FOR_INPUT : FOR_PANEL);
d6449 1
a6449 1
	    show_help = FALSE;
d6453 4
a6456 3
	    /*
	     * Highlight current link, unless it is an active text input field.
	     */
d6468 2
a6469 2
	     * Don't go interactively into forms, or accept keystrokes from the
	     * user
d6474 1
a6474 1
		sprintf(cfile, "lnk%05d.dat", ccount);
d6476 1
a6476 1
		sprintf(cfile, "lnk%08d.dat", ccount);
d6479 2
a6480 2
		if ((cfp = LYNewTxtFile(cfile)) != NULL) {
		    print_crawl_to_fd(cfp, curdoc.address, curdoc.title);
a6484 1
		    fprintf(
d6486 4
a6489 5
			       (dump_output_immediately
				? stderr
				: stdout),
#else
			       stdout,
d6491 2
a6492 1
			       gettext("Fatal error - could not open output file %s\n"), cfile);
d6496 1
a6496 1
		    return (EXIT_FAILURE);
d6501 1
a6501 1
	     * Normal, non-traversal handling.
d6503 1
d6511 1
a6511 1
		     * Replace novice lines if in NOVICE_MODE.
d6513 1
a6513 1
		    if (user_mode == NOVICE_MODE) {
d6517 2
a6518 2
					      &newdoc, &refresh_screen,
					      use_last_tfpos, FALSE);
d6528 1
a6528 1
		c = (real_c == LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
d6533 1
a6533 1
		    LKC_TO_LAC(keymap, real_c) != LYK_CHANGE_LINK) {
d6547 1
a6547 1
			   (((LKC_TO_LAC(keymap, real_c) == LYK_NEXT_LINK ||
d6549 1
a6549 1
			      LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE ||
d6551 5
a6555 5
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks - 1 &&
			       links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE
d6557 4
a6560 5
				   links[curdoc.link + 1].l_form->number)
			       && strcmp(links[curdoc.link].l_form->name,
					 links[curdoc.link + 1].l_form->name)
			       == 0) ||
			      (curdoc.link == nlinks - 1 && more &&
d6562 3
a6564 3
			    ((LKC_TO_LAC(keymap, real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_UP_LINK) &&
d6566 2
a6567 2
			       links[curdoc.link - 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link - 1].l_form->type == F_TEXTAREA_TYPE
d6569 1
a6569 1
				   links[curdoc.link - 1].l_form->number) &&
d6571 3
a6573 3
				      links[curdoc.link - 1].l_form->name) == 0)
			      || (curdoc.link == 0 && curdoc.line > 1 &&
				  HText_TAHasMoreLines(curdoc.link, -1)))))) {
d6577 1
a6577 1
			LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE)
d6586 31
a6616 32
			/*
			 * If on the bottom line of a TEXTAREA, and the user
			 * hit the ENTER key, we add a new line/anchor
			 * automatically, positioning the cursor on it.
			 *
			 * If at the bottom of the screen, we effectively
			 * perform an LYK_DOWN_HALF-like operation, then move
			 * down to the new line we just added.  --KED 02/14/99
			 *
			 * [There is some redundancy and non-standard
			 * indentation in the monster-if() below.  This is
			 * intentional ...  to try and improve the
			 * "readability" (such as it is).  Caveat emptor to
			 * anyone trying to change it.]
			 */
			if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
			    && ((curdoc.link == nlinks - 1 &&
				 !(more && HText_TAHasMoreLines(curdoc.link, 1)))
				||
				((curdoc.link < nlinks - 1) &&
				 !(links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE))
				||
				((curdoc.link < nlinks - 1) &&
				 ((links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE)
				  && ((links[curdoc.link].l_form->number !=
				       links[curdoc.link + 1].l_form->number) ||
				      (strcmp(links[curdoc.link].l_form->name,
					      links[curdoc.link + 1].l_form->name)
				       != 0)))))) {
d6618 1
a6618 1
			    HText_ExpandTextarea(&links[curdoc.link], 1);
d6620 2
a6621 2
			    if (links[curdoc.link].ly < display_lines) {
				refresh_screen = TRUE;
d6623 1
a6623 1
			    } else {
d6625 3
a6627 3
				Newline += (display_lines / 2);
				if (nlinks > 0 && curdoc.link > -1 &&
				    links[curdoc.link].ly > display_lines / 2) {
d6629 1
a6629 3
				    for (i = 0;
					 links[i].ly <= (display_lines / 2);
					 i++)
a6631 1
				}
d6633 1
d6635 3
a6637 3
			    if (textfields_need_activation) {
				textinput_activated = TRUE;
				textfields_need_activation = textfields_activation_option;
d6639 1
a6639 1
				textinput_redrawn = TRUE;
d6641 1
a6641 1
			    };
d6644 1
a6644 1
			}
d6647 9
a6655 9
			/*
			 * Make return in input field (if it was returned by
			 * change_form_link) act as LYK_NEXT_LINK, independent
			 * of what key (if any) is mapped to LYK_NEXT_LINK.  -
			 * kw
			 */
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
			break;
		    default:
d6657 3
a6659 3
			if (old_c != c && old_c != real_c && c != real_c)
			    real_c = c;
		    }
d6663 1
a6663 1
		    /*draw the text entry, but don't activate it */
d6666 2
a6667 2
					&newdoc, &refresh_screen,
					use_last_tfpos, FALSE, TRUE);
d6670 2
a6671 2
			       ((links[curdoc.link].lx > 0) ?
				(links[curdoc.link].lx - 1) : 0));
d6678 3
a6680 2
		 * Get a keystroke from the user.  Save the last keystroke to
		 * avoid redundant error reporting.
d6682 1
a6682 1
		real_c = c = LYgetch();		/* get user input */
d6689 1
a6689 1
		if (c == 3) {	/* ^C */
d6691 2
a6692 2
		     * This shouldn't happen.  We'll try to deal with whatever
		     * bug caused it.  - FM
d6702 8
a6709 8
		     * If ESC + <key> was read (and not recognized as a
		     * terminal escape sequence for another key), ignore the
		     * ESC modifier and act on <key> only if the line editor
		     * binding would have passed the same ESC-modified
		     * lynxkeycode back to us if it had been pressed in a text
		     * input field.  Otherwise set interesting part so that it
		     * will map to 0, to prevent that ESC + <key> acts like
		     * <key>, which might be unexpected.  - kw
d6731 1
a6731 1
      new_keyboard_input:
d6733 2
a6734 2
	 * A goto point for new input without going back through the getch()
	 * loop.
d6739 2
a6740 2
	}
	/* traversal */
d6746 1
a6746 1
	    cmd = LKC_TO_LAC(keymap, c);	/* adds 1 to map EOF to 0 */
d6749 2
a6750 2
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override, c))
	    cmd = LKC_TO_LAC(key_override, c);
d6755 4
a6758 5
	/*
	 * A goto point for new input without going back through the getch()
	 * loop.
	 */
      new_cmd:
d6766 1
a6766 1
	switch (cmd) {
d6770 1
a6770 1
	case 0:		/* unmapped character */
d6805 1
a6805 1
	     * No network transmission to interrupt - 'til we multithread.
d6810 10
a6819 10
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
d6825 1
a6825 1
	case LYK_SOURCE:	/* toggle view source mode */
d6840 1
a6840 1
	case LYK_RELOAD:	/* control-R to reload and refresh */
d6862 1
a6862 1
		return (EXIT_SUCCESS);
d6865 2
a6866 2
	case LYK_ABORT:	/* don't ask the user about quitting */
	    return (EXIT_SUCCESS);
d6876 1
a6876 1
	case LYK_UP_TWO:
d6880 1
a6880 1
	case LYK_DOWN_TWO:
d6884 1
a6884 1
	case LYK_UP_HALF:
d6888 1
a6888 1
	case LYK_DOWN_HALF:
d6924 1
a6924 1
	    if (no_goto && !LYValidate) {	/*  Go to not allowed. - FM */
d6940 2
a6941 3
		    s++;
		    e--;
		    if (!strncasecomp((const char *) s, "URL:", 4))
d6951 1
a6951 1
		buf = (char *) malloc(len);
d6987 1
a6987 1
		switch (last_kcode) {
d7002 1
a7002 1
	    lynx_start_title_color();
d7004 1
a7004 1
	    lynx_stop_title_color();
d7026 2
a7027 2
		Newline = i;	/* go to end of file */
		arrowup = TRUE;	/* position on last link */
d7098 1
a7098 1
		return (EXIT_SUCCESS);
d7108 1
a7108 1
	case LYK_NOCACHE:	/* Force submission of form or link with no-cache */
d7115 1
a7115 6
	    switch (handle_LYK_ACTIVATE(&c,
					cmd,
					&try_internal,
					&refresh_screen,
					&force_load,
					real_cmd)) {
d7130 1
a7130 1
	case LYK_ECGOTO:	/* edit current URL and go to to it     */
d7139 2
a7140 2
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
d7153 1
a7153 1
	case LYK_INDEX:	/* index file */
d7234 1
a7234 1
	case LYK_EDIT_TEXTAREA:	/* use external editor on a TEXTAREA - KED */
d7246 1
a7246 1
	case LYK_PRINT:	/* print the file */
d7262 1
a7262 1
	case LYK_VLINKS:	/* list links visited during the current session */
d7267 1
a7267 1
	case LYK_TOOLBAR:	/* go to Toolbar or Banner in current document */
d7272 1
a7272 1
	case LYK_DIRED_MENU:	/* provide full file management menu */
d7275 1
a7275 1
#endif /* DIRED_SUPPORT || VMS */
d7294 1
a7294 1
	case LYK_SHELL:	/* (!) shell escape */
d7308 1
a7308 1
	case LYK_UPLOAD:
d7351 4
a7354 4
				&FirstURLRecall, &URLNum, &URLTotal, &ch,
				&old_c, real_c)) {
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
d7382 1
a7382 1
	}			/* end of BIG switch */
d7386 3
a7388 1
static int are_different(DocInfo *doc1, DocInfo *doc2)
d7393 1
a7393 1
     * Do we have two addresses?
d7399 1
a7399 1
     * Do they differ in the type of request?
d7405 3
a7407 2
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
d7412 1
a7412 1
     * Are the base addresses different?
d7417 1
a7417 1
	return (TRUE);
d7423 1
a7423 1
     * Do the docs have different contents?
d7428 1
a7428 1
		return (TRUE);
d7430 1
a7430 1
	    return (TRUE);
d7432 1
a7432 1
	return (TRUE);
d7435 1
a7435 1
     * We'll assume the two documents in fact are the same.
d7437 1
a7437 1
    return (FALSE);
d7444 3
a7446 1
static int are_phys_different(DocInfo *doc1, DocInfo *doc2)
d7451 1
a7451 1
     * Do we have two addresses?
d7457 1
a7457 1
     * Do they differ in the type of request?
d7475 1
a7475 1
	return (FALSE);
d7478 3
a7480 2
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
d7485 1
a7485 1
     * Are the base addresses different?
d7490 1
a7490 1
	return (TRUE);
d7496 1
a7496 1
     * Do the docs have different contents?
d7501 1
a7501 1
		return (TRUE);
d7503 1
a7503 1
	    return (TRUE);
d7505 1
a7505 1
	return (TRUE);
d7508 1
a7508 1
     * We'll assume the two documents in fact are the same.
d7510 1
a7510 1
    return (FALSE);
d7515 1
a7515 1
 * Utility for freeing the list of goto URLs.  - FM
d7518 1
a7518 1
static void HTGotoURLs_free(void)
d7524 1
a7524 1
	while (NULL != (url = (char *) HTList_nextObject(cur))) {
d7534 2
a7535 2
 * Utility for listing Goto URLs, making any repeated URLs the most current in
 * the list.  - FM
d7537 2
a7538 1
void HTAddGotoURL(char *url)
d7540 1
a7540 1
    char *copy = NULL;
d7548 1
a7548 1
    StrAllocCopy(copy, url);
d7555 1
a7555 1
	HTList_addObject(Goto_URLs, copy);
d7560 2
a7561 2
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, copy)) {
d7567 1
a7567 1
    HTList_addObject(Goto_URLs, copy);
d7573 3
a7575 2
 * When help is not on the screen, put a message on the screen to tell the user
 * other misc info.
d7577 3
a7579 2
static void show_main_statusline(const LinkInfo curlink,
				 int for_what)
d7582 1
a7582 1
     * Make sure form novice lines are replaced.
d7590 1
a7590 1
	 * Currently displaying HTML source.
d7594 4
a7597 4
	/*
	 * If we are in forms mode then explicitly tell the user what each kind
	 * of link is.
	 */
d7617 1
a7617 1
	 * Let them know if it's an index -- very rare.
d7621 1
a7621 2

	    LYmove(LYlines - 1, LYcols - strlen(indx) - 1);
d7629 1
a7629 1
	 * Show the URL or, for some internal links, the fragment
d7670 3
a7672 3
 * Public function for redrawing the statusline appropriate for the selected
 * link.  It should only be called at times when curdoc.link, nlinks, and the
 * links[] array are valid.  - kw
d7674 2
a7675 1
void repaint_main_statusline(int for_what)
d7681 2
a7682 1
static void form_noviceline(int disabled)
d7684 1
a7684 2
    LYmove(LYlines - 2, 0);
    LYclrtoeol();
d7688 1
a7688 2
    LYmove(LYlines - 1, 0);
    LYclrtoeol();
a7697 1

d7714 3
a7716 2
static void exit_immediately_with_error_message(int state,
						BOOLEAN first_file)
d7726 2
a7727 1
    if (state == NOT_FOUND) {
d7731 4
a7734 4
	/*
	 * hack: if we fail in HTAccess.c
	 * avoid duplicating URL, oh.
	 */
d7736 1
a7736 1
		   "" : startfile);
d7739 2
a7740 1
    if (state == NULLFILE) {
d7758 1
a7758 1
	SetOutputMode(O_TEXT);
d7760 1
a7760 1
	SetOutputMode(O_BINARY);
d7771 5
a7775 3
static void status_link(char *curlink_name,
			BOOLEAN show_more,
			BOOLEAN show_indx)
d7786 1
a7786 1
		(int) (sizeof(format) - 2),
d7792 1
a7792 1
		(int) (sizeof(format) - prefix - 2),
d7811 2
a7812 1
	     * Scan to find the final leaf of the URL.  Ignore trailing '/'.
d7816 2
a7817 1
		 cut_to_pos--) ;
d7819 1
a7819 1
	     * Jump back to the next leaf to remove.
d7823 7
a7829 8
					|| ((prefix + cut_from_pos
					     + 4
					     + (length - cut_to_pos)) >= MAX_STATUS));
		 cut_from_pos--) ;
	    /*
	     * Replace some leaves to '...', if possible, and put the final
	     * leaf at the end.  We assume that one can recognize the link from
	     * at least MIN_STATUS characters.
d7838 1
a7838 1
	    CTRACE((tfp, "lastline = %s\n", buf));	/* don't forget to erase me */
d7840 1
a7840 1
	} else {		/* show (possibly truncated) url */
d7846 2
a7847 1
char *LYDownLoadAddress(void)
a7849 1

@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d509 1
a509 1
static BOOL set_curdoc_link(int nextlink)
a510 2
    BOOL result = FALSE;

d514 1
a514 1
	if (curdoc.link >= 0 && curdoc.link < nlinks) {
a515 2
	    result = TRUE;
	}
a517 10
    return result;
}

#ifdef USE_MOUSE
static void set_curdoc_link_by_mouse(int nextlink)
{
    if (set_curdoc_link(nextlink)) {
	LYhighlight(ON, nextlink, prev_target);
	LYmsec_delay(20);
    }
a518 3
#else
#define set_curdoc_link_by_mouse(nextlink) set_curdoc_link(nextlink)
#endif
d538 1
a538 1
	set_curdoc_link_by_mouse(mouse_tmp);
d897 1
a897 1
	if (lookup_link(links[curdoc.link].lname)) {
d899 1
a899 1
		(curdoc.link > -1 && curdoc.link < nlinks - 1)) {
d901 1
a901 1
	    } else {
d908 1
a908 3
		    c = -1;
		} else {
		    c = LTARROW;
d910 1
d924 1
a924 1
	    (curdoc.link > -1 && curdoc.link < nlinks - 1)) {
d926 1
a926 1
	} else {
d937 1
a937 3
		c = -1;
	    } else {
		c = LTARROW;
d939 1
d941 1
a941 5
    }
    CTRACE((tfp, "DoTraversal(%d:%d) -> %s\n",
	    nlinks > 0 ? curdoc.link : 0,
	    nlinks,
	    LYKeycodeToString(c, FALSE)));
d1216 1
a1216 1
			textinput_activated) {
a1217 1
		    }
d5056 1
a5056 1
    c = LYChoosePopup(!LYwideLines, LYlines / 2 - 2, LYcolLimit / 2 - 6,
d5243 1
a5243 1
	 * If newdoc.address is different from curdoc.address then we need to
d5774 1
a5774 1
			if (!lookup_link(traversal_link_to_add))
d5919 1
a5919 1
	    } else if (!dump_links_only) {
d6035 1
a6035 1
		if (curdoc.address && !lookup_link(curdoc.address)) {
d6360 1
a6360 1
		sprintf(cfile, "lnk%05d.dat", crawl_count);
d6362 1
a6362 1
		sprintf(cfile, "lnk%08d.dat", crawl_count);
d6364 1
a6364 1
		crawl_count = crawl_count + 1;
a7017 1
		break;
d7509 1
a7509 1
	    LYmove(LYlines - 1, LYcolLimit - strlen(indx));
d7661 1
a7661 1
#define MAX_STATUS (LYcolLimit - 1)
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d1751 1
a1751 1
		    if (non_empty(kp)) {
d2379 1
a2379 1
	    non_empty(editor) && !no_dired_support) {
d2418 1
a2418 1
    if (non_empty(editor)) {
d5703 1
a5703 1
		     isEmpty(newdoc.bookmark)) &&
d7458 1
a7458 1
    if (isEmpty(url))
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a2 1
#include <HTParse.h>
a39 1
#include <GridText.h>
d41 1
a41 103
#ifdef KANJI_CODE_OVERRIDE
#include <HTCJK.h>
#endif

#ifdef KANJI_CODE_OVERRIDE
PUBLIC char *str_kcode(HTkcode code)
{
    char *p;
    static char buff[8];

    if (current_char_set == TRANSPARENT) {
	p = "THRU";
    } else if (!LYRawMode) {
	p = "RAW";
    } else {
	switch (code) {
	case NOKANJI:
	    p = "AUTO";
	    break;

	case EUC:
	    p = "EUC+";
	    break;

	case SJIS:
	    p = "SJIS";
	    break;

	case JIS:
	    p = " JIS";
	    break;

	default:
	    p = " ???";
	    break;
	}
    }

#ifdef SH_EX	/* 1999/05/25 (Tue) 11:12:05 */
    if (no_table_center) {
	buff[0] = '!';
	strcpy(buff + 1, p);
    } else {
	strcpy(buff, p);
    }
#else
    strcpy(buff, p);
#endif

    return buff;
}
#endif

#ifdef WIN_EX

PRIVATE char *str_sjis(char *to, char *from)
{
    if (!LYRawMode) {
	strcpy(to, from);
#ifdef KANJI_CODE_OVERRIDE
    } else if (last_kcode == EUC) {
	EUC_TO_SJIS(from, to);
    } else if (last_kcode == SJIS) {
	strcpy(to, from);
#endif
    } else {
	TO_SJIS(from, to);
    }
    return to;
}

PRIVATE void set_ws_title(char * str)
{
    SetConsoleTitle(str);
}

#endif /* WIN_EX */


#ifdef SH_EX  /* 1998/10/30 (Fri) 10:06:47 */

#define NOT_EQU	1

PRIVATE int str_n_cmp(const char *p, const char *q, int n)
{
    if (n == 0)
	return 0;

    if (p == NULL)
	return NOT_EQU;

    if (q == NULL)
	return NOT_EQU;

    return strncmp(p, q, n);
}

#undef strncmp
#define	strncmp(p, q, r)	str_n_cmp(p, q, r)

#endif	/* SH_EX */

#if defined(USE_EXTERNALS) || defined(WIN_EX)
a57 10
#ifndef DONT_TRACK_INTERNAL_LINKS
#define NO_INTERNAL_OR_DIFFERENT(c,n) TRUE
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) (!curdoc.internal_link || \
			   are_phys_different(p,n))
#else /* TRACK_INTERNAL_LINKS */
#define NO_INTERNAL_OR_DIFFERENT(c,n) are_different(c,n)
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) are_different(p,n)
#endif /* TRACK_INTERNAL_LINKS */


d59 6
a64 3
PRIVATE void status_link PARAMS((char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx));
PRIVATE void show_main_statusline PARAMS((CONST linkstruct curlink, int for_what));
PRIVATE void form_noviceline PARAMS((int));
d66 2
a86 3
PUBLIC char * LYRequestReferer = NULL; /* Referer, may be set in getfile() */

PRIVATE char prev_target[512];
d89 6
a94 2
PUBLIC BOOLEAN display_partial = FALSE; /* could be enabled in HText_new() */
PUBLIC int NumOfLines_partial = 0;  /* number of lines displayed in partial mode */
a96 1
PRIVATE int Newline = 0;
a100 12
PRIVATE char *owner_address = NULL;  /* Holds the responsible owner's address     */
PRIVATE char *ownerS_address = NULL; /* Holds owner's address during source fetch */

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
PRIVATE BOOL textinput_activated = FALSE;
#else
#define textinput_activated TRUE /* a current text input is always active */
#endif
#ifdef INACTIVE_INPUT_STYLE_VH
PUBLIC BOOL textinput_redrawn = FALSE;
    /*must be public since used in highlight(..)*/
#endif
d118 1
a118 1
#ifdef USE_COLOR_STYLE
a123 2
    FREE(owner_address);
    FREE(ownerS_address);
a125 1
    reset_dired_menu();
a126 2
    FREE(WWW_Download_File);	/* LYGetFile.c/HTFWriter.c */
    FREE(LYRequestReferer);
d132 8
a139 1
#ifndef NO_LYNX_TRACE
d147 1
a147 37
	exit(EXIT_FAILURE);
    }
}

PRIVATE BOOLEAN LYReopenTracelog ARGS1(BOOLEAN *, trace_flag_ptr)
{
    CTRACE((tfp, "\nTurning off TRACE for fetch of log.\n"));
    LYCloseTracelog();
    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
	TracelogOpenFailed();
	return FALSE;
    }
    if (TRACE) {
	WWW_TraceFlag = FALSE;
	*trace_flag_ptr = TRUE;
    }
    return TRUE;
}

PRIVATE void turn_trace_back_on ARGS1(BOOLEAN *, trace_flag_ptr)
{
    if (*trace_flag_ptr == TRUE) {
	WWW_TraceFlag = TRUE;
	*trace_flag_ptr = FALSE;
	fprintf(tfp, "Turning TRACE back on.\n\n");
    }
}
#else
#define LYReopenTracelog(flag) TRUE
#define turn_trace_back_on(flag) /*nothing*/
#endif /* NO_LYNX_TRACE */

PUBLIC FILE *TraceFP NOARGS
{
#ifndef NO_LYNX_TRACE
    if (LYTraceLogFP != 0) {
	return LYTraceLogFP;
a148 2
#endif /* NO_LYNX_TRACE */
    return stderr;
a152 1
#ifndef NO_LYNX_TRACE
d176 1
a176 4
	 *  anonymous restrictions are set. - FM, LP, kw
	 *  This is only a summary for convenience - it doesn't
	 *  take the case of individual -restrictions= options
	 *  into account. - kw
d178 2
a179 25
	if (LYValidate) {
	    if (LYRestricted && had_restrictions_default) {
		CTRACE((tfp, "Validate and some anonymous restrictions are set.\n"));
	    } else if (had_restrictions_default) {
		CTRACE((tfp, "Validate restrictions set, restriction \"default\" was given.\n"));
	    } else if (LYRestricted) {
		CTRACE((tfp, "Validate restrictions set, additional anonymous restrictions ignored.\n"));
	    } else {
		CTRACE((tfp, "Validate restrictions are set.\n"));
	    }
	    /* But none of the above can actually happen, since there should
	     * never be a Trace Log with -validate.  If it appears in a log
	     * file something went wrong! */
	} else if (LYRestricted) {
	    if (had_restrictions_all) {
		CTRACE((tfp, "Anonymous restrictions set, restriction \"all\" was given.\n"));
	    } else {
		CTRACE((tfp, "Anonymous restrictions are set.\n"));
	    }
	} else if (had_restrictions_all && had_restrictions_default) {
	    CTRACE((tfp, "Restrictions \"all\" and \"default\" were given.\n"));
	} else if (had_restrictions_default) {
	    CTRACE((tfp, "Restriction \"default\" was given.\n"));
	} else if (had_restrictions_all) {
	    CTRACE((tfp, "\"all\" restrictions are set.\n"));
a181 1
#endif /* NO_LYNX_TRACE */
a186 1
#ifndef NO_LYNX_TRACE
a192 1
#endif /* NO_LYNX_TRACE */
d195 1
a195 1
PUBLIC void handle_LYK_TRACE_TOGGLE NOARGS
d197 11
a207 7
#ifndef NO_LYNX_TRACE
    WWW_TraceFlag = ! WWW_TraceFlag;
    if (LYOpenTraceLog())
	HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
d210 2
a211 2
PUBLIC void LYSetNewline ARGS1(
	int,		value)
d213 7
a219 6
    Newline = value;
}

PUBLIC int LYGetNewline NOARGS
{
    return Newline;
a221 1
#ifdef SOURCE_CACHE
d223 6
a228 8
 * To reparse current html document under the different settings we call
 * reparse_document() within mainloop refresh cycle, it relies upon 'curdoc'.
 *
 * From the other hand, regular requests for new document go to getfile()
 * and rely upon 'newdoc'.
 *
 * To work around newdoc.line/curdoc.line/www_search_target/Newline message
 * the following flag is introduced:
a229 1
PRIVATE BOOLEAN from_source_cache = FALSE;
d231 1
a231 1
PRIVATE BOOLEAN reparse_document NOARGS
d233 38
a270 10
    BOOLEAN ok;
    from_source_cache = TRUE;	/* set for LYMainLoop_pageDisplay() */
    if ((ok = HTreparse_document()) != FALSE) {
	from_source_cache = TRUE;	/* set for mainloop refresh */
	return ok;
    }
    from_source_cache = FALSE;
    return ok;
}
#endif /* SOURCE_CACHE */
d273 6
a278 2
 * Prefer reparsing if we can, but reload if we must - to force regeneration
 * of the display.
d280 14
a293 8
PRIVATE BOOLEAN reparse_or_reload ARGS1(
    int *,	cmd)
{
#ifdef SOURCE_CACHE
    if (HTcan_reparse_document()) {
	reparse_document();
	return FALSE;
    }
d295 6
a300 22
    *cmd = LYK_RELOAD;
    return TRUE;
}

/*
 * This is for traversal call from within partial mode in LYUtils.c
 * and HTFormat.c  It simply calls HText_pageDisplay() but utilizes
 * LYMainLoop.c PRIVATE variables.
 * Perhaps, this could adhere more logic from mainloop(), in the future.
 */
PUBLIC void LYMainLoop_pageDisplay ARGS1(
	int,		line_num)
{
#ifdef DISP_PARTIAL
#ifdef SOURCE_CACHE
    /*
     * reparse_document() acts on 'curdoc' which always on top of the
     * history stack: no need to resolve #fragment position since
     * we already know it (curdoc.line).
     * So bypass here. Sorry for possible confusion...
     */
    if (!from_source_cache)
d302 9
a310 12
    /*
     * Disable display_partial if requested URL has #fragment and we are not
     * popped from the history stack so can't calculate correct newline
     * position for fragment.  Otherwise user got the new document from the
     * first page and was moved to #fragment later after download completed,
     * but only if s/he did not mess screen up by scrolling before...  So fall
     * down to old behavior here ... until we rewrite HTFindPoundSelector()
     */
    if (display_partial && newdoc.line == 1 && strchr(newdoc.address, '#')) {
	display_partial = FALSE; /* restrict for this document */
	return;			/* no repaint */
    }
d312 4
a315 20
    /*
     *  Override Newline with a new value if user
     *  scrolled the document while loading (in LYUtils.c).
     */
#endif /* DISP_PARTIAL */
    Newline = line_num;

    HText_pageDisplay(Newline, prev_target);
}


PRIVATE void set_curdoc_link ARGS1(
    int,	nextlink)
{
    if (curdoc.link != nextlink
     && nextlink >= 0
     && nextlink < nlinks) {
	if (curdoc.link >= 0 && curdoc.link < nlinks)
	    highlight(OFF, curdoc.link, prev_target);
	curdoc.link = nextlink;
d317 2
a318 1
}
d320 6
a325 17
PRIVATE int do_change_link NOARGS
{
#ifdef USE_MOUSE
    /* Is there a mouse-clicked link waiting? */
    int mouse_tmp = get_mouse_link();
    /* If yes, use it as the link */
    if (mouse_tmp != -1) {
	if (mouse_tmp < 0 || mouse_tmp >= nlinks) {
	    char *msgtmp = NULL;
	    HTSprintf0(&msgtmp,
		       gettext("Internal error: Invalid mouse link %d!"),
		       mouse_tmp);
	    HTAlert(msgtmp);
	    FREE(msgtmp);
	    return(-1);		/* indicates unexpected error */
	}
	set_curdoc_link(mouse_tmp);
a326 93
#endif /* USE_MOUSE */
    return(0);			/* indicates OK */
}

#ifdef DIRED_SUPPORT
#define DIRED_UNCACHE_1 if (LYAutoUncacheDirLists < 1) /*nothing*/ ;\
			else HTuncache_current_document()
#define DIRED_UNCACHE_2 if (LYAutoUncacheDirLists < 2) /*nothing*/ ;\
			else HTuncache_current_document()
#endif /* DIRED_SUPPORT */

PRIVATE void do_check_goto_URL ARGS3(
    char *,	user_input_buffer,
    char **,	old_user_input,
    BOOLEAN *,	force_load)
{
    static BOOLEAN always = TRUE;
    static struct {
	CONST char *name;
	BOOLEAN *flag;
    } table[] = {
	{ "file:",		&no_file_url },
	{ "file:",		&no_goto_file },
	{ "lynxexec:",		&no_goto_lynxexec },
	{ "lynxprog:",		&no_goto_lynxprog },
	{ "lynxcgi:",		&no_goto_lynxcgi },
	{ "cso:",		&no_goto_cso },
	{ "finger:",		&no_goto_finger },
	{ "ftp:",		&no_goto_ftp },
	{ "gopher:",		&no_goto_gopher },
	{ "http:",		&no_goto_http },
	{ "https:",		&no_goto_https },
	{ "mailto:",		&no_goto_mailto },
	{ "rlogin:",		&no_goto_rlogin },
	{ "telnet:",		&no_goto_telnet },
	{ "tn3270:",		&no_goto_tn3270 },
	{ "wais:",		&no_goto_wais },
#ifndef DISABLE_BIBP
	{ "bibp:",		&no_goto_bibp },
#endif
#ifndef DISABLE_NEWS
	{ "news:",		&no_goto_news },
	{ "nntp:",		&no_goto_nntp },
	{ "snews:",		&no_goto_snews },
#endif
#ifdef EXEC_LINKS
	{ "lynxexec:",		&local_exec_on_local_files },
	{ "lynxprog:",		&local_exec_on_local_files },
#endif /* EXEC_LINKS */
	{ "LYNXCFG:",		&no_goto_configinfo },
	{ "LYNXCOMPILEOPTS:",	&no_goto_configinfo },
	{ "LYNXCOOKIE:",	&always },
	{ "LYNXDIRED:",		&always },
	{ "LYNXDOWNLOAD:",	&always },
	{ "LYNXOPTIONS:",	&always },
	{ "LYNXPRINT:",		&always },
    };
    unsigned n;
    BOOLEAN found = FALSE;

    /* allow going to anchors*/
    if (*user_input_buffer == '#' ) {
	if ( user_input_buffer[1] &&
	     HTFindPoundSelector(user_input_buffer+1) ) {
	     /* HTFindPoundSelector will initialize www_search_result,
		so we do nothing else. */
	    HTAddGotoURL(user_input_buffer);
	}
    } else {
	/*
	 * If it's not a URL then make it one.
	 */
	StrAllocCopy(*old_user_input, user_input_buffer);
	LYFillLocalFileURL(old_user_input, "file://localhost");
	LYEnsureAbsoluteURL(old_user_input, "", TRUE);
	sprintf(user_input_buffer, "%.*s",
		(int)(MAX_LINE - 1), *old_user_input);
	FREE(*old_user_input);

	for (n = 0; n < TABLESIZE(table); n++) {
	    if (*(table[n].flag)
	     && !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
		found = TRUE;
		HTUserMsg2(GOTO_XXXX_DISALLOWED, table[n].name);
		break;
	    }
	}
	if (found) {
	    ;
	} else if (LYValidate &&
		   strncmp(user_input_buffer, "http:", 5) &&
		   strncmp(user_input_buffer, "https:", 6)) {
	    HTUserMsg(GOTO_NON_HTTP_DISALLOWED);
d328 11
a339 2
	    StrAllocCopy(newdoc.address, user_input_buffer);
	    newdoc.isHEAD = FALSE;
d341 2
a342 2
	     *  Might be an anchor in the same doc from a POST
	     *  form.  If so, dont't free the content. -- FM
d344 5
a348 5
	    if (are_different(&curdoc, &newdoc)) {
		/*
		 * Make a name for this new URL.
		 */
		StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
d351 1
a351 1
		FREE(newdoc.bookmark);
d353 5
a357 7
		newdoc.internal_link = FALSE;
		*force_load = TRUE;
#ifdef DIRED_SUPPORT
		if (lynx_edit_mode) {
		    DIRED_UNCACHE_2;
		}
#endif /* DIRED_SUPPORT */
a358 2
	    LYUserSpecifiedURL = TRUE;
	    HTAddGotoURL(newdoc.address);
a360 1
}
d362 2
a363 12
/* returns FALSE if user cancelled input or URL was invalid, TRUE otherwise */
PRIVATE BOOL do_check_recall ARGS7(
    int,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int,	URLTotal,
    int *,	URLNum,
    int,	recall,
    BOOLEAN *,	FirstURLRecall)
{
    char *cp;
    BOOL ret = FALSE;
d365 4
a368 2
    if (*old_user_input == 0)
	StrAllocCopy(*old_user_input, "");
d370 3
a372 28
    for (;;) {
#ifdef WIN_EX	/* 1998/10/11 (Sun) 10:41:05 */
	int len = strlen(user_input_buffer);
	char last_2, last_1, last;

	if (len >= 3) {

	    last_2 = user_input_buffer[len - 3];
	    last_1 = user_input_buffer[len - 2];
	    last = user_input_buffer[len - 1];

	    if (len < MAX_LINE - 1
	     && last_2 == '/'
	     && isalpha(last_1)
	     && last == ':')
		LYAddHtmlSep0(user_input_buffer);

	} else if (len == 2 && user_input_buffer[1] == ':') {
	    if (isalpha(UCH(user_input_buffer[0]))) {
		LYAddHtmlSep0(user_input_buffer);
	    } else {
		HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
		LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		FREE(*old_user_input);
		ret = FALSE;
		break;
	    }
	}
d375 2
a376 1
	 * Get rid of leading spaces (and any other spaces).
d378 12
a389 11
	LYTrimAllStartfile(user_input_buffer);
	if (*user_input_buffer == '\0' &&
	    !(recall && (ch == UPARROW || ch == DNARROW))) {
	    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	    FREE(*old_user_input);
	    HTInfoMsg(CANCELLED);
	    ret = FALSE;
	    break;
	}
	if (recall && ch == UPARROW) {
	    if (*FirstURLRecall) {
d391 2
a392 1
		 * Use last URL in the list.  - FM
d394 1
a394 29
		*FirstURLRecall = FALSE;
		*URLNum = 0;
	    } else {
		/*
		 * Go back to the previous URL in the list.  - FM
		 */
		*URLNum += 1;
	    }
	    if (*URLNum >= URLTotal)
		/*
		 * Roll around to the last URL in the list.  - FM
		 */
		*URLNum = 0;
	    if ((cp = (char *)HTList_objectAt(Goto_URLs,
					      *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer
		 && **old_user_input
		 && !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				  MAX_LINE,
				  recall)) < 0) {
d396 6
a401 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d403 5
a407 40
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else if (recall && ch == DNARROW) {
	    if (*FirstURLRecall) {
		/*
		 * Use the first URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = URLTotal - 1;
	    } else {
		/*
		 * Advance to the next URL in the list.  - FM
		 */
		*URLNum -= 1;
	    }
	    if (*URLNum < 0)
		/*
		 * Roll around to the first URL in the list.  - FM
		 */
		*URLNum = URLTotal - 1;
	    if ((cp=(char *)HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
		if (goto_buffer && **old_user_input &&
		    !strcmp(*old_user_input, user_input_buffer)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
d409 2
a410 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d412 12
a423 15
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else {
	    ret = TRUE;
	    break;
	}
    }
    return ret;
}
a424 15
PRIVATE void do_cleanup_after_delete NOARGS
{
    HTuncache_current_document();
    StrAllocCopy(newdoc.address, curdoc.address);
    FREE(curdoc.address);
    newdoc.line = curdoc.line;
    if (curdoc.link == nlinks-1) {
	/*
	 * We deleted the last link on the page.  - FM
	 */
	newdoc.link = curdoc.link-1;
    } else {
	newdoc.link = curdoc.link;
    }
}
d426 36
a461 5
PRIVATE int find_link_near_col ARGS2(
	int,	col,
	int,	delta)
{
    int i;
d463 19
a481 15
    for (i = curdoc.link; delta > 0 ? (i < nlinks) : (i >= 0); i += delta) {
	if ( (links[i].ly - links[curdoc.link].ly) * delta > 0 ) {
	    int cy = links[i].ly, best = -1, dist = 1000000;

	    while ((delta > 0 ? (i < nlinks) : (i >= 0)) && cy == links[i].ly) {
		int cx = links[i].lx;

		if (links[i].hightext)
		    cx += strlen(links[i].hightext)/2;
		cx -= col;
		if (cx < 0)
		    cx = -cx;
		if (cx < dist) {
		    dist = cx;
		    best = i;
a482 7
		i += delta;
	    }
	    return(best);
	}
    }
    return(-1);
}
d484 13
a496 13
/*
 * This is a special feature to traverse every http link derived from startfile
 * and check for errors or create crawl output files.  Only URL's that begin
 * with "traversal_host" are searched - this keeps the search from crossing to
 * other servers (a feature, not a bug!).
 */
PRIVATE int DoTraversal ARGS2(
    int,	c,
    BOOLEAN *,	crawl_ok)
{
    BOOLEAN rlink_rejected = FALSE;
    BOOLEAN rlink_exists;
    BOOLEAN rlink_allowed;
d498 13
a510 35
    rlink_exists = (BOOL) (nlinks > 0 &&
		    links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].lname != NULL);

    if (rlink_exists) {
	rlink_rejected = lookup_reject(links[curdoc.link].lname);
	if (!rlink_rejected &&
	     traversal_host &&
	     links[curdoc.link].lname) {
	    if (strncmp(links[curdoc.link].lname, "LYNXIMGMAP:", 11)) {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
					 links[curdoc.link].lname,
					 strlen(traversal_host));
	    } else {
		rlink_allowed = (BOOL) !strncmp(traversal_host,
					 links[curdoc.link].lname + 11,
					 strlen(traversal_host));
	    }
	} else {
	    rlink_allowed = FALSE;
	}
    } else {
	rlink_allowed = FALSE;
    }
    if (rlink_exists && rlink_allowed) {
	if (lookup(links[curdoc.link].lname)) {
	    if (more_links ||
		(curdoc.link > -1 && curdoc.link < nlinks -1))
		 c= DNARROW;
	    else {
		if (STREQ(curdoc.title,"Entry into main screen") ||
		    (nhist <= 0 )) {
		    if (!dump_output_immediately) {
			cleanup();
			exit_immediately(EXIT_FAILURE);
a511 1
		    return(-1);
d513 10
a522 26
		c = LTARROW;
	    }
	} else {
	    StrAllocCopy(traversal_link_to_add,
			 links[curdoc.link].lname);
	    if (strncmp(traversal_link_to_add, "LYNXIMGMAP:", 11))
		*crawl_ok = TRUE;
	    c = RTARROW;
	}
    } else { /* no good right link, so only down and left arrow ok*/
	if (rlink_exists /* && !rlink_rejected */)
	    /* uncomment in previous line to avoid duplicates - kw */
	    add_to_reject_list(links[curdoc.link].lname);
	if (more_links ||
	    (curdoc.link > -1 && curdoc.link < nlinks-1))
	    c = DNARROW;
	else {
	    /*
	     *	curdoc.title doesn't always work, so
	     *	bail out if the history list is empty.
	     */
	    if (STREQ(curdoc.title,"Entry into main screen") ||
		(nhist <= 0 )) {
		if (!dump_output_immediately) {
		    cleanup();
		    exit_immediately(EXIT_FAILURE);
a523 7
		return(-1);
	    }
	    c = LTARROW;
	}
    } /* right link not NULL or link to another site*/
    return c;
}
d525 19
d545 13
a557 184
PRIVATE BOOLEAN check_history NOARGS
{
    CONST char *base;

    if (!curdoc.post_data)
	/*
	 *  Normal case - List Page is not associated
	 *  with post data. - kw
	 */
	return TRUE;

    if (nhist > 0
     && !LYresubmit_posts
     && curdoc.post_data
     && history[nhist - 1].post_data
     && !strcmp(curdoc.post_data, history[nhist - 1].post_data)
     && (base = HText_getContentBase()) != 0) {
	 char *text = strncmp(history[nhist - 1].address, "LYNXIMGMAP:", 11)
		     ? history[nhist - 1].address
		     : history[nhist - 1].address + 11;
	if (!strncmp(base, text, strlen(base))) {
	    /*
	     * Normal case - as best as we can check, the document at the top
	     * of the history stack seems to be the document the List Page is
	     * about (or a LYNXIMGMAP derived from it), and LYresubmit_posts is
	     * not set, so don't prompt here.  If we actually have to repeat a
	     * POST because, against expectations, the underlying document
	     * isn't cached any more, HTAccess will prompt for confirmation,
	     * unless we had LYK_NOCACHE -kw
	     */
	    return TRUE;
	}
    }
    return FALSE;
}
#endif

PRIVATE int handle_LYK_ACTIVATE ARGS6(
    int *,	c,
    int,	cmd GCC_UNUSED,
    BOOLEAN *,	try_internal GCC_UNUSED,
    BOOLEAN *,	refresh_screen,
    BOOLEAN *,	force_load,
    int,	real_cmd)
{
    if (do_change_link() == -1) {
	LYforce_no_cache = FALSE;
	reloading = FALSE;
	return 1;	/* mouse stuff was confused, ignore - kw */
    }
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (real_cmd == LYK_ACTIVATE && textfields_need_activation &&
		F_TEXTLIKE(links[curdoc.link].form->type)) {

		textinput_activated = TRUE;
		show_main_statusline(links[curdoc.link], FOR_INPUT);
		textfields_need_activation = textfields_activation_option;

		return 0;
	    }
#endif
	    /*
	     *	Don't try to submit forms with bad actions. - FM
	     */
	    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].form->type ==
					    F_TEXT_SUBMIT_TYPE) {
		/*
		 *  Do nothing if it's disabled. - FM
		 */
		if (links[curdoc.link].form->disabled == YES) {
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 *  Make sure we have an action. - FM
		 */
		if (!links[curdoc.link].form->submit_action ||
		    *links[curdoc.link].form->submit_action
							== '\0') {
		    HTUserMsg(NO_FORM_ACTION);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 *  Check for no_mail if the form action
		 *  is a mailto URL. - FM
		 */
		if (links[curdoc.link].form->submit_method
			     == URL_MAIL_METHOD && no_mail) {
		    HTAlert(FORM_MAILTO_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 *  Make sure this isn't a spoof in an account
		 *  with restrictions on file URLs. - FM
		 */
		if (no_file_url &&
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "file:", 5)) {
		    HTAlert(FILE_ACTIONS_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 *  Make sure this isn't a spoof attempt
		 *  via an internal URL. - FM
		 */
		if (!strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXCOOKIE:", 11) ||
#ifdef DIRED_SUPPORT
#ifdef OK_PERMIT
		    (!(strncasecomp(
			    links[curdoc.link].form->submit_action,
				   "LYNXDIRED:", 10)) &&
		     (no_dired_support ||
		      strncasecomp(
			(links[curdoc.link].form->submit_action + 10),
				   "//PERMIT_LOCATION", 17) ||
		      !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS))) ||
#else
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXDIRED:", 10) ||
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXDOWNLOAD:", 13) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXHIST:", 9) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXKEYMAP:", 11) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXIMGMAP:", 11) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXPRINT:", 10) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "lynxexec:", 9) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "lynxprog:", 9)) {
		    HTAlert(SPECIAL_ACTION_DISALLOWED);
		    CTRACE((tfp, "LYMainLoop: Rejected '%s'\n",
				links[curdoc.link].form->submit_action));
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
#ifdef NOTDEFINED /* We're disabling form inputs instead of using this. - FM */
		/*
		 *  Check for enctype and let user know we
		 *  don't yet support multipart/form-data - FM
		 */
		if (links[curdoc.link].form->submit_enctype) {
		    if (!strcmp(
			     links[curdoc.link].form->submit_enctype,
				"multipart/form-data")) {
			HTAlert(
gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			reloading = FALSE;
			return 0;
d559 12
a570 63
		}
#endif /* NOTDEFINED */
		if (check_realm) {
		    LYPermitURL = TRUE;
		}
		if (no_filereferer == TRUE &&
		    !strncmp(curdoc.address, "file:", 5)) {
		    LYNoRefererForThis = TRUE;
		}
		if (links[curdoc.link].form->submit_method
			     != URL_MAIL_METHOD) {
		    StrAllocCopy(newdoc.title,
				 links[curdoc.link].hightext);
		}
	    }
	    /*
	     *	Normally we don't get here for text input fields,
	     *  but it can happen as a result of mouse positioning.
	     *  In that case the statusline will not have updated
	     *  info, so update it now. - kw
	     */

	    if (F_TEXTLIKE(links[curdoc.link].form->type)) {
		show_formlink_statusline(links[curdoc.link].form,
					 (real_cmd==LYK_NOCACHE ||
					  real_cmd==LYK_DOWNLOAD ||
					  real_cmd==LYK_HEAD ||
					  (real_cmd==LYK_SUBMIT &&
					   !textinput_activated)) ?
					 FOR_PANEL : FOR_INPUT);
		if (user_mode==NOVICE_MODE &&
		    textinput_activated &&
		    (real_cmd==LYK_ACTIVATE || real_cmd==LYK_SUBMIT)) {
			form_noviceline(links[curdoc.link].form->disabled);
		}
	    }

	    *c = change_form_link(&links[curdoc.link],
				 &newdoc, refresh_screen,
				 links[curdoc.link].form->name,
				 links[curdoc.link].form->value,
				 FALSE,
				 (BOOLEAN)(real_cmd==LYK_SUBMIT ||
				  real_cmd==LYK_NOCACHE ||
				  real_cmd==LYK_DOWNLOAD ||
				  real_cmd==LYK_HEAD));
	    if (*c != LKC_DONE || *refresh_screen) {
		/*
		 *  Cannot have been a submit field for which
		 *  newdoc was filled in. - kw
		 */
		if ((links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		     links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
		     links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE) &&
		    links[curdoc.link].form->submit_method
			     != URL_MAIL_METHOD) {
		    /*
		     *  Try to undo change of newdoc.title done above.
		     */
		    if (HText_getTitle()) {
			StrAllocCopy(newdoc.title, HText_getTitle());
		    } else if (curdoc.title) {
			StrAllocCopy(newdoc.title, curdoc.title);
d572 16
a587 20
		}
	    } else {
		if (HTOutputFormat == HTAtom_for("www/download") &&
		newdoc.post_data != NULL &&
		newdoc.safe == FALSE) {
		    if ((HText_POSTReplyLoaded(&newdoc) == TRUE) &&
			HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			HTInfoMsg(CANCELLED);
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			StrAllocCopy(newdoc.address, curdoc.address);
			StrAllocCopy(newdoc.title, curdoc.title);
			StrAllocCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			return 0;
d589 1
d591 3
a593 98
		/*
		 *  Moved here from earlier to only apply when it
		 *  should.   Anyway, why should realm checking be
		 *  overridden for form submissions, this seems to
		 *  be an unnecessary loophole??  But that's the way
		 *  it was, maybe there is some reason.
		 *  However, at least make sure this doesn't weaken
		 *  restrictions implied by -validate!
		 *  - kw 1999-05-25
		 */
		if (check_realm && !LYValidate) {
		    LYPermitURL = TRUE;
		}
	    }
	    if (*c == LKC_DONE) {
		*c = DO_NOTHING;
	    } else if (*c == 23) {
		*c = DO_NOTHING;
		*refresh_screen = TRUE;
	    } else {
		/*  Avoid getting stuck with repeatedly calling
		**  handle_LYK_ACTIVATE(), instead of calling
		**  change_form_link() directly from mainloop(),
		**  for text input fields. - kw
		*/
		switch (LKC_TO_C(*c)) {
		case '\n':
		case '\r':
		default:
		    if ((real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT) &&
			F_TEXTLIKE(links[curdoc.link].form->type) &&
			textinput_activated)
			return 3;
		    break;
		}
	    }
	    return 2;
	} else {
	    /*
	     *	Not a forms link.
	     *
	     *	Make sure this isn't a spoof in an account
	     *	with restrictions on file URLs. - FM
	     */
	    if (no_file_url &&
		!strncmp(links[curdoc.link].lname, "file:", 5)) {
		if (strncmp(curdoc.address, "file:", 5) &&
		    !((!strncmp(curdoc.address, "LYNXKEYMAP:", 11) ||
		       !strncmp(curdoc.address, "LYNXCOOKIE:", 11)) &&
		      !strncmp(links[curdoc.link].lname,
			       helpfilepath,
			       strlen(helpfilepath)))) {
		    HTAlert(FILE_SERVED_LINKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		} else if (curdoc.bookmark != NULL) {
		    HTAlert(FILE_BOOKMARKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		}
	    }
	    /*
	     *	Make sure this isn't a spoof attempt
	     *	via an internal URL in a non-internal
	     *	document. - FM
	     */
	    if ((!strncmp(links[curdoc.link].lname,
			  "LYNXCOOKIE:", 11) &&
		 (strcmp((curdoc.title ? curdoc.title : ""),
			 COOKIE_JAR_TITLE) ||
		  strncmp(curdoc.address, "LYNXCOOKIE:", 11))) ||
#ifdef DIRED_SUPPORT
		(!strncmp(links[curdoc.link].lname,
			  "LYNXDIRED:", 10) &&
		 !LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
		 !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
#ifdef OK_INSTALL
		 !LYIsUIPage(curdoc.address, UIP_INSTALL) &&
#endif /* OK_INSTALL */
		 !LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) ||
#endif /* DIRED_SUPPORT */
		(!strncmp(links[curdoc.link].lname,
			 "LYNXDOWNLOAD:", 13) &&
		 !LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS)) ||
		(!strncmp(links[curdoc.link].lname,
			  "LYNXHIST:", 9) &&
		 !LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		 !LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		 !LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) ||
		(!strncmp(links[curdoc.link].lname,
			  "LYNXPRINT:", 10) &&
		 !LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS))) {
		    HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
d595 1
a595 7
#ifdef USE_EXTERNALS
	    if (run_external(links[curdoc.link].lname, TRUE))
	    {
		*refresh_screen = TRUE;
		return 0;
	    }
#endif /* USE_EXTERNALS */
d597 26
a622 68
	    /*
	     *	Follow a normal link or anchor.
	     */
	    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
	/*
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
	 */
	    /*
	     *	Might be an internal link anchor in the same doc.
	     *	If so, take the try_internal shortcut if we didn't
	     *	fall through from LYK_NOCACHE. - kw
	     */
	    newdoc.internal_link =
		(links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
	    if (newdoc.internal_link) {
		/*
		 *  Special case of List Page document with an
		 *  internal link indication, which may really stand
		 *  for an internal link within the document the
		 *  List Page is about. - kw
		 */
		if (LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
		    (LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		     LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		    if (check_history()) {
			LYinternal_flag = TRUE;
		    } else {
			HTLastConfirmCancelled(); /* reset flag */
			if (!confirm_post_resub(newdoc.address,
						newdoc.title,
					(LYresubmit_posts &&
			       HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
						2)) {
			    if (HTLastConfirmCancelled() ||
				(LYresubmit_posts &&
				 cmd != LYK_NOCACHE &&
				 !HText_POSTReplyLoaded(&newdoc))) {
				/* cancel the whole thing */
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				StrAllocCopy(newdoc.address, curdoc.address);
				StrAllocCopy(newdoc.title, curdoc.title);
				newdoc.internal_link = curdoc.internal_link;
				HTInfoMsg(CANCELLED);
				return 1;
			    } else if (LYresubmit_posts &&
				       cmd != LYK_NOCACHE) {
				/* If LYresubmit_posts is set, and the
				   answer was No, and the key wasn't
				   NOCACHE, and we have a cached copy,
				   then use it. - kw */
				LYforce_no_cache = FALSE;
			    } else {
				/* if No, but not ^C or ^G, drop
				 * the post data.  Maybe the link
				 * wasn't meant to be internal after
				 * all, here we can recover from that
				 * assumption. - kw */
				FREE(newdoc.post_data);
				FREE(newdoc.post_content_type);
				newdoc.internal_link = FALSE;
				HTAlert(DISCARDING_POST_DATA);
d626 2
a627 75
		    /*
		     *	Don't push the List Page if we follow an
		     *	internal link given by it. - kw
		     */
		    FREE(curdoc.address);
		} else if (cmd != LYK_NOCACHE) {
		    *try_internal = TRUE;
		}
		if (!(LYresubmit_posts && newdoc.post_data))
		    LYinternal_flag = TRUE;
		/* We still set force_load so that history pushing
		** etc. will be done.  - kw */
		*force_load = TRUE;
		return 1;
	    } else {
		/*
		 *  Free POST content if not an internal link. - kw
		 */
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
	    }
#endif /* TRACK_INTERNAL_LINKS */
	    /*
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		if (!strncmp(newdoc.address, "LYNXMESSAGES:", 13))
		    LYforce_no_cache = TRUE;
	    }
	    if (!no_jump && lynxjumpfile && curdoc.address &&
		!strcmp(lynxjumpfile, curdoc.address)) {
		LYJumpFileURL = TRUE;
		LYUserSpecifiedURL = TRUE;
	    } else if ((curdoc.title &&
			(LYIsUIPage(curdoc.address, UIP_HISTORY) ||
			 !strcmp(curdoc.title, HISTORY_PAGE_TITLE))) ||
		       curdoc.bookmark != NULL ||
		       (lynxjumpfile &&
			!strcmp(lynxjumpfile, curdoc.address))) {
		LYUserSpecifiedURL = TRUE;
	    } else if (no_filereferer == TRUE &&
		       !strncmp(curdoc.address, "file:", 5)) {
		LYNoRefererForThis = TRUE;
	    }
	    newdoc.link = 0;
	    *force_load = TRUE;	/* force MainLoop to reload */
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;	/* we get here if link is not internal */
#endif

#if defined(DIRED_SUPPORT) && !defined(__DJGPP__)
	    if (lynx_edit_mode) {
		  DIRED_UNCACHE_2;
		  /*
		   *  Unescaping any slash chars in the URL,
		   *  but avoid double unescaping and too-early
		   *  unescaping of other chars. - KW
		   */
		  HTUnEscapeSome(newdoc.address,"/");
		  /* avoid stripping final slash for root dir - kw */
		  if (strcasecomp(newdoc.address, "file://localhost/"))
		      strip_trailing_slash(newdoc.address);
	    }
#endif /* DIRED_SUPPORT  && !__DJGPP__ */
	    if (!strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
		HTuncache_current_document();
	    }
	}
    }
    return 0;
}
d629 12
a640 35
#ifdef EXP_ADDRLIST_PAGE
PRIVATE BOOLEAN handle_LYK_ADDRLIST ARGS1(
    int *,     cmd)
{
    /*
     *	Don't do if already viewing list addresses page.
     */
    if (LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) {
	/*
	 *  Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     *	Print address list page to file.
     */
    if (showlist(&newdoc, FALSE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, ADDRLIST_PAGE_TITLE);
    /*
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}
#endif /* EXP_ADDRLIST_PAGE */
a641 68
PRIVATE void handle_LYK_ADD_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    int c;

    if (LYValidate) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    if (!LYIsUIPage(curdoc.address, UIP_HISTORY) &&
	!LYIsUIPage(curdoc.address, UIP_SHOWINFO) &&
	!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS) &&
#ifdef DIRED_SUPPORT
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	!LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
	!LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS) &&
#endif /* DIRED_SUPPORT */
	!LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS) &&
	strncmp(curdoc.address, "LYNXCOOKIE:", 11) &&
	!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU) &&
	((nlinks <= 0) ||
	 (links[curdoc.link].lname != NULL &&
	  strncmp(links[curdoc.link].lname, "LYNXHIST:", 9) &&
	  strncmp(links[curdoc.link].lname, "LYNXPRINT:", 10) &&
	  strncmp(links[curdoc.link].lname, "LYNXDIRED:", 10) &&
	  strncmp(links[curdoc.link].lname, "LYNXDOWNLOAD:", 13) &&
	  strncmp(links[curdoc.link].lname, "LYNXCOOKIE:", 11) &&
	  strncmp(links[curdoc.link].lname, "LYNXOPTIONS:", 12)))) {
	if (nlinks > 0) {
	    if (curdoc.post_data == NULL &&
		curdoc.bookmark == NULL &&
		!LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_VLINKS)) {
		/*
		 *  The document doesn't have POST content,
		 *  and is not a bookmark file, nor is the
		 *  list or visited links page, so we can
		 *  save either that or the link. - FM
		 */
		_statusline(BOOK_D_L_OR_CANCEL);
		if ((c = LYgetch_single()) == 'D') {
		    save_bookmark_link(curdoc.address, curdoc.title);
		    *refresh_screen = TRUE; /* MultiBookmark support */
		    goto check_add_bookmark_to_self;
		}
	    } else {
		if (LYMultiBookmarks == MBM_OFF &&
		    curdoc.bookmark != NULL &&
		    strstr(curdoc.address,
			   (*bookmark_page == '.'
					  ?
			(bookmark_page+1) : bookmark_page)) != NULL) {
		    /*
		     *	If multiple bookmarks are disabled, offer
		     *	the L)ink or C)ancel, but with wording
		     *	which indicates that the link already
		     *	exists in this bookmark file. - FM
		     */
		    _statusline(MULTIBOOKMARKS_SELF);
		} else if (curdoc.post_data != NULL &&
			   links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
d643 3
a645 1
		     *	Internal link, and document has POST content.
d647 9
a655 3
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		} else {
d657 1
a657 4
		     *	Only offer the link in a document with
		     *	POST content, or if the current document
		     *	is a bookmark file and multiple bookmarks
		     *	are enabled. - FM
d659 30
a688 7
		    _statusline(BOOK_L_OR_CANCEL);
		}
		c = LYgetch_single();
	    }
	    if (c == 'L') {
		if (curdoc.post_data != NULL &&
		    links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
d690 2
a691 1
		     *	Internal link, and document has POST content.
d693 1
a693 140
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		}
		/*
		 *  User does want to save the link. - FM
		 */
		if (links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    save_bookmark_link(links[curdoc.link].lname,
				       links[curdoc.link].hightext);
		    *refresh_screen = TRUE; /* MultiBookmark support */
		} else {
		    HTUserMsg(NOBOOK_FORM_FIELD);
		    return;
		}
	    } else {
		return;
	    }
	} else if (curdoc.post_data != NULL) {
	    /*
	     *	No links, and document has POST content. - FM
	     */
	    HTUserMsg(NOBOOK_POST_FORM);
	    return;
	} else if (curdoc.bookmark != NULL) {
	    /*
	     *	It's a bookmark file from which all
	     *	of the links were deleted. - FM
	     */
	    HTUserMsg(BOOKMARKS_NOLINKS);
	    return;
	} else {
	    _statusline(BOOK_D_OR_CANCEL);
	    if (LYgetch_single() == 'D') {
		save_bookmark_link(curdoc.address, curdoc.title);
		*refresh_screen = TRUE; /* MultiBookmark support */
	    } else {
		return;
	    }
	}
check_add_bookmark_to_self:
	if (curdoc.bookmark && BookmarkPage &&
	    !strcmp(curdoc.bookmark, BookmarkPage)) {
	    HTuncache_current_document();
	    StrAllocCopy(newdoc.address, curdoc.address);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    FREE(curdoc.address);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    newdoc.internal_link = FALSE;
	}
    } else {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(NOBOOK_HSML);
	}
    }
}

PRIVATE void handle_LYK_CLEAR_AUTH ARGS2(
    int *,	old_c,
    int,	real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	if (HTConfirm(CLEAR_ALL_AUTH_INFO)) {
	    FREE(authentication_info[0]);
	    FREE(authentication_info[1]);
	    FREE(proxyauth_info[0]);
	    FREE(proxyauth_info[1]);
	    HTClearHTTPAuthInfo();
#ifndef DISABLE_NEWS
	    HTClearNNTPAuthInfo();
#endif
#ifndef DISABLE_FTP
	    HTClearFTPPassword();
#endif
	    HTUserMsg(AUTH_INFO_CLEARED);
	} else {
	    HTUserMsg(CANCELLED);
	}
    }
}

PRIVATE int handle_LYK_COMMAND ARGS1(
    char *,	user_input_buffer)
{
    int ch;
    Kcmd *mp;
    char *src, *tmp;

    *user_input_buffer = 0;
    _statusline(": ");
    if (LYgetstr(user_input_buffer, VISIBLE, MAX_LINE, RECALL_CMD) >= 0) {
	src = LYSkipBlanks(user_input_buffer);
	tmp = LYSkipNonBlanks(src);
	*tmp = 0;
	ch = ((mp = LYStringToKcmd(src)) != 0) ? mp->code : 0;
	CTRACE((tfp, "LYK_COMMAND(%s.%s) = %d\n", src, tmp, ch));
	if (ch == 0) {
	    return *src ? -1 : 0;
	}
	/* FIXME: reuse the rest of the buffer for parameters */
	return ch;
    }
    return 0;
}

PRIVATE void handle_LYK_COMMENT ARGS4(
    BOOLEAN *,	refresh_screen,
    char **,	owner_address_p,
    int *,	old_c,
    int,	real_c)
{
    int	c;

    if (!*owner_address_p &&
	strncasecomp(curdoc.address, "http", 4)) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(NO_OWNER);
	}
    } else if (no_mail) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(MAIL_DISALLOWED);
	}
    } else {
	if (HTConfirmDefault(CONFIRM_COMMENT, NO)) {
	    if (!*owner_address_p) {
		/*
		 *  No owner defined, so make a guess and
		 *  and offer it to the user. - FM
		 */
		char *address = NULL;
		char *temp = HTParse(curdoc.address, "", PARSE_PATH);
		char *cp;

		if (temp != NULL) {
		    HTUnEscape(temp);
		    if (*temp == '~' && strlen(temp) > 1) {
d695 1
a695 1
			 *  It's a ~user URL so guess user@@host. - FM
d697 77
a773 5
			if ((cp = strchr((temp+1), '/')) != NULL)
			    *cp = '\0';
			StrAllocCopy(address, "mailto:");
			StrAllocCat(address, (temp+1));
			StrAllocCat(address, "@@");
d775 4
a778 3
		    FREE(temp);
		}
		if (address == NULL)
d780 1
a780 1
		     *	Wasn't a ~user URL so guess WebMaster@@host. - FM
d782 6
a787 35
		    StrAllocCopy(address, "mailto:WebMaster@@");
		temp = HTParse(curdoc.address, "", PARSE_HOST);
		StrAllocCat(address, temp);
		HTSprintf0(&temp, NO_OWNER_USE, address);
		c = HTConfirmDefault(temp, NO);
		FREE(temp);
		if (c == YES) {
		    StrAllocCopy(*owner_address_p, address);
		    FREE(address);
		} else {
		    FREE(address);
		    return;
		}
	    }
	    if (is_url(*owner_address_p) != MAILTO_URL_TYPE) {
		/*
		 *  The address is a URL.  Just follow the link.
		 */
		StrAllocCopy(newdoc.address, *owner_address_p);
		newdoc.internal_link = FALSE;
	    } else {
		/*
		 *  The owner_address is a mailto: URL.
		 */
		CONST char *kp = HText_getRevTitle();
		CONST char *id = HText_getMessageID();
		char *tmptitle = NULL;
		if (!kp && HTMainAnchor) {
		    kp = HTAnchor_subject(HTMainAnchor);
		    if (kp && *kp) {
			if (strncasecomp(kp, "Re: ", 4)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, kp);
			    kp = tmptitle;
			}
d789 1
a789 1
		}
d791 15
a805 94
		if (strchr(*owner_address_p,':')!=NULL)
		     /*
		      *  Send a reply.	The address is after the colon.
		      */
		     reply_by_mail(strchr(*owner_address_p,':')+1,
				   curdoc.address,
				   (kp ? kp : ""), id);
		else
		    reply_by_mail(*owner_address_p, curdoc.address,
				  (kp ? kp : ""), id);

		FREE(tmptitle);
		*refresh_screen = TRUE;	/* to force a showpage */
	    }
	}
    }
}

PRIVATE BOOLEAN handle_LYK_COOKIE_JAR ARGS1(
    int *,	cmd)
{
    /*
     *	Don't do if already viewing the cookie jar.
     */
    if (strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
	StrAllocCopy(newdoc.address, "LYNXCOOKIE:/");
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 *  If already in the cookie jar, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

#if defined(DIRED_SUPPORT)
PRIVATE void handle_LYK_CREATE NOARGS
{
    if (lynx_edit_mode && !no_dired_support) {
	if (local_create(&curdoc) > 0) {
	    DIRED_UNCACHE_1;
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link > -1 ? curdoc.link : 0;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

PRIVATE void handle_LYK_DEL_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.bookmark != NULL) {
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE,NO) != YES)
	    return;
	remove_bookmark_link(links[curdoc.link].anchor_number-1,
			     curdoc.bookmark);
    } else {	/* behave like REFRESH for backward compatibility */
	*refresh_screen = TRUE;
	if (*old_c != real_c) {
	    *old_c = real_c;
	    lynx_force_repaint();
	}
	return;
    }
    do_cleanup_after_delete();
}

#if defined(DIRED_SUPPORT) || defined(VMS)
PRIVATE void handle_LYK_DIRED_MENU ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c GCC_UNUSED,
    int,	real_c GCC_UNUSED)
{
d807 2
a808 106
    char *cp, *temp = 0;

    /*
     *	Check if the CSwing Directory/File Manager is available.
     *	Will be disabled if LYCSwingPath is NULL, zero-length,
     *	or "none" (case insensitive), if no_file_url was set via
     *	the file_url restriction, if no_goto_file was set for
     *	the anonymous account, or if HTDirAccess was set to
     *	HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse
     *	or -selective switches. - FM
     */
    if (!(LYCSwingPath && *LYCSwingPath) ||
	!strcasecomp(LYCSwingPath, "none") ||
	no_file_url || no_goto_file ||
	HTDirAccess == HT_DIR_FORBID ||
	HTDirAccess == HT_DIR_SELECTIVE) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(DFM_NOT_AVAILABLE);
	}
	return;
    }

    /*
     *	If we are viewing a local directory listing or a
     *	local file which is not temporary, invoke CSwing
     *	with the URL's directory converted to VMS path specs
     *	and passed as the argument, so we start up CSwing
     *	positioned on that node of the directory tree.
     *	Otherwise, pass the current default directory as
     *	the argument. - FM
     */
    if (LYisLocalFile(curdoc.address) &&
	strncasecomp(curdoc.address,
		     lynx_temp_space, strlen(lynx_temp_space))) {
	/*
	 *  We are viewing a local directory or a local file
	 *  which is not temporary. - FM
	 */
	struct stat stat_info;

	cp = HTParse(curdoc.address, "", PARSE_PATH|PARSE_PUNCTUATION);
	HTUnEscape(cp);
	if (HTStat(cp, &stat_info) == -1) {
	    CTRACE((tfp, "mainloop: Can't stat %s\n", cp));
	    FREE(cp);
	    HTSprintf0(&temp, "%s []", LYCSwingPath);
	    *refresh_screen = TRUE;  /* redisplay */
	} else {
	    char *VMSdir = NULL;

	    if (S_ISDIR(stat_info.st_mode)) {
		/*
		 *  We're viewing a local directory.  Make
		 *  that the CSwing argument. - FM
		 */
		LYAddPathSep(&cp);
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
	    } else {
		/*
		 *  We're viewing a local file.  Make its
		 *  directory the CSwing argument. - FM
		 */
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
		if ((cp = strrchr(VMSdir, ']')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		} else if ((cp = strrchr(VMSdir, ':')) != NULL) {
		    *(cp + 1) = '\0';
		    cp == NULL;
		}
	    }
	    HTSprintf0(&temp, "%s %s", LYCSwingPath, VMSdir);
	    FREE(VMSdir);
	    /*
	     *	Uncache the current document in case we
	     *	change, move, or delete it during the
	     *	CSwing session. - FM
	     */
	    /* could use DIRED_UNCACHE_1 but it's currently only defined
	       for dired - kw */
	    HTuncache_current_document();
	    StrAllocCopy(newdoc.address, curdoc.address);
	    StrAllocCopy(newdoc.title,
			 curdoc.title ? curdoc.title : "");
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    FREE(curdoc.address);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
    } else {
	/*
	 *  We're not viewing a local directory or file.
	 *  Pass CSwing the current default directory as
	 *  an argument and don't uncache the current
	 *  document. - FM
	 */
	HTSprintf0(&temp, "%s []", LYCSwingPath);
	*refresh_screen = TRUE;	/* redisplay */
    }
    stop_curses();
    LYSystem(temp);
    start_curses();
    FREE(temp);
d810 2
a811 10
    /*
     *	Don't do if not allowed or already viewing the menu.
     */
    if (lynx_edit_mode && !no_dired_support &&
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	strcmp((curdoc.title ? curdoc.title : ""),
	       DIRED_MENU_TITLE)) {
	dired_options(&curdoc,&newdoc.address);
	*refresh_screen = TRUE;	/* redisplay */
    }
d813 77
a889 2
}
#endif /* defined(DIRED_SUPPORT) || defined(VMS) */
d891 21
a911 5
PRIVATE int handle_LYK_DOWNLOAD ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
d913 15
a927 11
    /*
     *	Don't do if both download and disk_save are restricted.
     */
    if (LYValidate ||
	(no_download && !override_no_download && no_disk_save)) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(DOWNLOAD_DISABLED);
	}
	return 0;
    }
d929 9
a937 5
    /*
     *	Don't do if already viewing download options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS))
	return 0;
d939 7
a945 12
    if (do_change_link() == -1)
	return 1;	/* mouse stuff was confused, ignore - kw */
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
	    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE) {
		if (links[curdoc.link].form->submit_method ==
			 URL_MAIL_METHOD) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_MAILTO_ACTION);
d947 3
a949 19
		    return 0;
		}
		if (!strncmp(links[curdoc.link].form->submit_action,
			"LYNXOPTIONS:", 12)) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_SPECIAL);
		    }
		    return 0;
		}
		HTOutputFormat = HTAtom_for("www/download");
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return 2;
	    }
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_INPUT);
	    }
d951 7
a957 5
	} else if (!strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_COOKIES);
	    }
d959 14
a972 5
	} else if (LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PRINT_OP);
	    }
d974 4
a977 11
#ifdef DIRED_SUPPORT
	} else if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_UPLOAD_OP);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS)) {
	    if (*old_c != real_c)	{
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PERMIT_OP);
a979 2
	} else if (lynx_edit_mode && !no_dired_support &&
		   !strstr(links[curdoc.link].lname, "/SugFile=")) {
d981 1
a981 1
	     *	Don't bother making a /tmp copy of the local file.
d983 11
a993 10
	    char *temp = NULL;
	    StrAllocCopy(temp, newdoc.address);
	    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
	    if (LYdownload_options(&newdoc.address,
				   links[curdoc.link].lname) < 0)
		StrAllocCopy(newdoc.address, temp);
	    else
		newdoc.internal_link = FALSE;
	    FREE(temp);
#endif /* DIRED_SUPPORT */
a994 13
	} else if (LYIsUIPage(curdoc.address, UIP_HISTORY) &&
	    !strncmp(links[curdoc.link].lname, "LYNXHIST:", 9)) {
	    int number = atoi(links[curdoc.link].lname+9);
	    if (number >= nhist || number < 0) {
		HTUserMsg(NO_DOWNLOAD_SPECIAL);
		return 0;
	    }
	    if ((history[number].post_data != NULL &&
		 history[number].safe != TRUE) &&
		HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
		HTInfoMsg(CANCELLED);
		return 0;
	    }
d996 2
a997 1
	     *  OK, we download from history page, restore URL from stack.
d999 3
a1001 82
	    StrAllocCopy(newdoc.address, history[number].address);
	    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
	    StrAllocCopy(newdoc.bookmark, history[number].bookmark);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    if (history[number].post_data)
		StrAllocCopy(newdoc.post_data,
			     history[number].post_data);
	    if (history[number].post_content_type)
		StrAllocCopy(newdoc.post_content_type,
			     history[number].post_content_type);
	    newdoc.isHEAD = history[number].isHEAD;
	    newdoc.safe = history[number].safe;
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    LYUserSpecifiedURL = TRUE;
	    /*
	     *	Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;

	} else if (!strncmp(links[curdoc.link].lname, "data:", 5)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTAlert(UNSUPPORTED_DATA_URL);
	    }

	} else if (!strncmp(links[curdoc.link].lname,
			    "LYNXCOOKIE:", 11) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXDIRED:", 10) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXDOWNLOAD:", 13) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXPRINT:", 10) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXOPTIONS:", 12) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXHIST:", 9) || /* handled above if valid - kw */
/* @@@@@@ should next two be downloadable? - kw */
		   !strncmp(links[curdoc.link].lname,
			    "LYNXCFG:", 8) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXCOMPILEOPTS:", 16) ||
		   !strncmp(links[curdoc.link].lname,
			    "lynxexec:", 9) ||
		   !strncmp(links[curdoc.link].lname,
			    "lynxprog:", 9)) {
	    HTUserMsg(NO_DOWNLOAD_SPECIAL);

	} else if (!strncmp(links[curdoc.link].lname,
			    "mailto:", 7)) {
	    HTUserMsg(NO_DOWNLOAD_MAILTO_LINK);

	/*
	 *  From here on we could have a remote host, so check if
	 *  that's allowed.
	 *
	 *  We copy all these checks from getfile() to LYK_DOWNLOAD
	 *  here because LYNXDOWNLOAD:// will NOT be pushing the
	 *  previous document into the history stack so preserve
	 *  getfile() from returning a wrong status (NULLFILE).
	 */
	} else if (local_host_only &&
		   !(LYisLocalHost(links[curdoc.link].lname) ||
		     LYisLocalAlias(links[curdoc.link].lname))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	} else {   /* Not a forms, options or history link */
	    /*
	     *	Follow a normal link or anchor.  Note that
	     *	if it's an anchor within the same document,
	     *	entire document will be downloaded.
	     */
	    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /*
	     *	Might be an internal link in the same doc from a
	     *	POST form.  If so, don't free the content. - kw
	     */
	    if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE)
d1003 15
a1017 12
	    /*
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
	     */
	    if (are_different(&curdoc, &newdoc))
#endif /* TRACK_INTERNAL_LINKS */
	    {
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
a1018 14
	    newdoc.internal_link = FALSE;
	    newdoc.link = 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    /*
	     *	Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NO_DOWNLOAD_CHOICE);
    }
    return 0;
}
a1019 5
PRIVATE void handle_LYK_DOWN_HALF ARGS2(
    int *,	old_c,
    int,	real_c)
{
    int i;
d1021 10
a1030 13
    if (more) {
	Newline += (display_lines/2);
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > display_lines/2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= (display_lines/2); i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}
d1032 12
a1043 7
PRIVATE void handle_LYK_DOWN_LINK ARGS3(
    int *,	follow_col,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.link < (nlinks-1)) {	/* more links? */
	int newlink;
d1045 1
a1045 2
	if (*follow_col == -1) {
	    *follow_col = links[curdoc.link].lx;
d1047 7
a1053 2
	    if (links[curdoc.link].hightext)
		*follow_col += strlen(links[curdoc.link].hightext)/2;
d1056 17
a1072 9
	newlink = find_link_near_col(*follow_col, 1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (more) {  /* next page */
	    Newline += (display_lines);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_BELOW);
	    return;
a1073 2
    } else if (more) {	/* next page */
	    Newline += (display_lines);
d1075 7
a1081 19
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

PRIVATE void handle_LYK_DOWN_TWO ARGS2(
    int *,	old_c,
    int,	real_c)
{
    int i;

    if (more) {
	Newline += 2;
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > 2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= 2; i++)
		--newdoc.link;
a1082 5
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}
d1084 5
a1088 17
PRIVATE int handle_LYK_DWIMEDIT ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
#ifdef TEXTAREA_AUTOEXTEDIT
    /*
     *  If we're in a forms TEXTAREA, invoke the editor on *its*
     *  contents, rather than attempting to edit the html source
     *  document.  KED
     */
    if (nlinks > 0  &&
	links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
	*cmd = LYK_EDIT_TEXTAREA;
	return 2;
    }
d1090 35
a1124 17
    /*
     *  If we're in a forms TEXT type, tell user the request
     *  is bogus (though in reality, without this trap, if the
     *  document with the TEXT field is local, the editor *would*
     *  be invoked on the source .html file; eg, the o(ptions)
     *  form tempfile).
     *
     *  [This is done to avoid possible user confusion, due to
     *   auto invocation of the editor on the TEXTAREA's contents
     *   via the above if() statement.]
     */
    if (nlinks > 0 &&
	links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXT_TYPE)       {
	HTUserMsg (CANNOT_EDIT_FIELD);
	return 1;
    }
d1126 66
a1191 4
    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
a1192 5
	return 1;
    }
#endif /* TEXTAREA_AUTOEXTEDIT */
    return 0;
}
d1194 1
a1194 8
PRIVATE int handle_LYK_ECGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
{
    if (no_goto && !LYValidate) {
d1196 5
a1200 1
	 *  Go to not allowed. - FM
d1202 15
a1216 3
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
d1218 1
a1218 6
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
d1220 4
a1223 1
	 *  Disallow editing of File Management URLs. - FM
d1225 9
a1233 3
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
d1235 2
a1236 3
	return 0;
    }
#endif /* DIRED_SUPPORT */
d1238 7
a1244 8
    /*
     *	Save the current user_input_buffer string,
     *	and load the current document's address.
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      curdoc.address,
	      (MAX_LINE - 1));
d1246 1
a1246 6
    /*
     *	Warn the user if the current document has POST
     *	data associated with it. - FM
     */
    if (curdoc.post_data)
	HTAlert(CURRENT_DOC_HAS_POST_DATA);
d1248 1
a1248 22
    /*
     *	Offer the current document's URL for editing. - FM
     */
    _statusline(EDIT_CURDOC_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer, curdoc.address)) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}
a1249 4
PRIVATE void handle_LYK_EDIT ARGS2(
    int *,	old_c,
    int,	real_c)
{
d1251 2
a1252 3
    char *cp;
    char *tp = NULL;
    struct stat dir_info;
d1255 5
a1259 6
    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_DISABLED);
	}
    } else
d1261 11
a1271 13
#ifdef DIRED_SUPPORT
    /*
     *	Allow the user to edit the link rather
     *	than curdoc in edit mode.
     */
    if (lynx_edit_mode &&
	editor && *editor != '\0' && !no_dired_support) {
	if (nlinks > 0) {
	    cp = links[curdoc.link].lname;
	    if (is_url(cp) == FILE_URL_TYPE) {
		cp = HTfullURL_toFile(cp);
		StrAllocCopy(tp, cp);
		FREE(cp);
d1273 18
a1290 28
		if (stat(tp, &dir_info) == -1) {
		    HTAlert(NO_STATUS);
		} else {
		    if (S_ISREG(dir_info.st_mode)) {
			StrAllocCopy(tp, links[curdoc.link].lname);
			HTUnEscapeSome(tp, "/");
			if (edit_current_file(tp, curdoc.link, Newline)) {
			    DIRED_UNCACHE_1;
			    StrAllocCopy(newdoc.address,
					 curdoc.address);
			    FREE(curdoc.address);
#ifdef NO_SEEK_OLD_POSITION
			    /*
			     *	Go to top of file.
			     */
			    newdoc.line = 1;
			    newdoc.link = 0;
#else
			    /*
			     *	Seek old position,
			     *	which probably changed.
			     */
			    newdoc.line = curdoc.line;
			    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
			    LYclear();  /* clear the screen */
			}
		    }
a1291 1
		FREE(tp);
d1293 2
a1294 12
	}
    } else
#endif /* DIRED_SUPPORT */
    if (editor && *editor != '\0') {
	if (edit_current_file(newdoc.address, curdoc.link, Newline)) {
	    HTuncache_current_document();
	    LYforce_no_cache = TRUE;  /*force reload of document */
	    FREE(curdoc.address); /* so it doesn't get pushed */
#ifdef NO_SEEK_OLD_POSITION
	    /*
	     *	Go to top of file.
	     */
d1297 1
a1297 8
#else
	    /*
	     *	Seek old position, which probably changed.
	     */
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
	    LYclear();  /* clear the screen */
d1300 19
a1318 7
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
}
d1320 4
a1323 18
PRIVATE void handle_LYK_DWIMHELP ARGS1(
    CONST char **,	cshelpfile)
{
    /*
     *  Currently a help file different from the main
     *  'helpfile' is shown only if current link is a
     *  text input form field. - kw
     */
    if (curdoc.link >= 0 && curdoc.link < nlinks &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	!links[curdoc.link].form->disabled &&
	(links[curdoc.link].form->type == F_TEXT_TYPE ||
	 links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE ||
	 links[curdoc.link].form->type == F_PASSWORD_TYPE ||
	 links[curdoc.link].form->type == F_TEXTAREA_TYPE)) {
	*cshelpfile = LYLineeditHelpURL();
    }
}
d1325 3
a1327 6
PRIVATE void handle_LYK_EDIT_TEXTAREA ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    int n;
a1328 9
    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
    } else if (!editor || *editor == '\0') {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
a1329 11
    }
    /*
     *  See if the current link is in a form TEXTAREA.
     */
    else if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {

	/* stop screen */
	stop_curses();

	n = HText_ExtEditForm (&links[curdoc.link]);
d1332 1
a1332 6
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st trailing blank line in
	 *	  the now edited TEXTAREA.  If the target line/
	 *	  anchor requires us to scroll up/down, position
	 *	  the target in the approximate center of the
	 *	  screen.
d1334 2
a1336 21
	/* curdoc.link += n;*/	/* works, except for page crossing, */
				/* damnit; why is nothing ever easy */

	/* start screen */
	start_curses();
	*refresh_screen = TRUE;

    } else {

	HTInfoMsg (NOT_IN_TEXTAREA_NOEDIT);
    }
}

PRIVATE int handle_LYK_ELGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
{
    if (no_goto && !LYValidate) {
d1338 3
a1340 1
	 *  Go to not allowed. - FM
d1342 4
a1345 3
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
a1346 44
	return 0;
    }
    if (!(nlinks > 0 && curdoc.link > -1) ||
	(links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	 links[curdoc.link].form->type != F_SUBMIT_TYPE &&
	 links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE &&
	 links[curdoc.link].form->type != F_TEXT_SUBMIT_TYPE)) {
	/*
	 *  No links on page, or not a normal link
	 *  or form submit button. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	}
	return 0;
    }
    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
	(!links[curdoc.link].form->submit_action ||
	 *links[curdoc.link].form->submit_action == '\0')) {
	/*
	 *  Form submit button with no ACTION defined. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_FORM_ACTION);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (!strncmp(links[curdoc.link].lname, "LYNXDIRED:", 10) ||
	LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 *  Disallow editing of File Management URLs. - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */
d1348 8
a1355 10
    /*
     *	Save the current user_input_buffer string,
     *	and load the current link's address. - FM
     */
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
					?
    links[curdoc.link].form->submit_action : links[curdoc.link].lname),
	      (MAX_LINE - 1));
d1357 56
a1412 25
    /*
     *	Offer the current link's URL for editing. - FM
     */
    _statusline(EDIT_CURLINK_URL);
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer,
	       ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
			? links[curdoc.link].form->submit_action
			: links[curdoc.link].lname))) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
	    return 2;
	}
    }
    /*
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
     */
    HTInfoMsg(CANCELLED);
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
    FREE(*old_user_input);
    return 0;
}
d1414 33
a1446 10
#ifdef USE_EXTERNALS
PRIVATE void handle_LYK_EXTERN_LINK ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL))
    {
	run_external(links[curdoc.link].lname, FALSE);
	*refresh_screen = TRUE;
    }
}
d1448 1
a1448 10
PRIVATE void handle_LYK_EXTERN_PAGE ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if (curdoc.address != NULL)
    {
	run_external(curdoc.address, FALSE);
	*refresh_screen = TRUE;
    }
}
#endif
d1450 2
a1451 7
PRIVATE BOOLEAN handle_LYK_FASTBACKW_LINK ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
    int samepage = 0, nextlink = curdoc.link;
    int res;
d1453 1
a1453 1
    if (nlinks > 1) {
d1455 11
a1465 8
	/*
	 *  If in textarea, move to first link or textarea group
	 *  before it if there is one on this screen. - kw
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].form->number;
	    char *thisname = links[curdoc.link].form->name;
d1467 19
a1485 12
	    if (curdoc.link > 0 &&
		!(links[0].type == WWW_FORM_LINK_TYPE &&
		  links[0].form->type == F_TEXTAREA_TYPE &&
		  links[0].form->number == thisgroup &&
		  sametext(links[0].form->name, thisname))) {
		do nextlink--;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].form->number == thisgroup &&
		     sametext(links[nextlink].form->name, thisname));
		samepage = 1;
d1487 14
a1500 48
	    } else if (!more && Newline == 1 &&
		       (links[0].type == WWW_FORM_LINK_TYPE &&
			links[0].form->type == F_TEXTAREA_TYPE &&
			links[0].form->number == thisgroup &&
			sametext(links[0].form->name, thisname)) &&
		       !(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
			 links[nlinks-1].form->number == thisgroup &&
			 sametext(links[nlinks-1].form->name, thisname))) {
		nextlink = nlinks - 1;
		samepage = 1;

	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link > 0) {
	    nextlink--;
	    samepage = 1;
	} else if (!more && Newline == 1) {
	    nextlink = nlinks - 1;
	    samepage = 1;
	}
    }
    if (samepage) {
	/*
	 *  If the link as determined so far is part of a
	 *  group of textarea fields, try to use the first
	 *  of them that's on the screen instead. - kw
	 */
	if (nextlink > 0 &&
	    links[nextlink].type == WWW_FORM_LINK_TYPE &&
	    links[nextlink].form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[nextlink].form->number;
	    char *thisname = links[nextlink].form->name;
	    if (links[0].type == WWW_FORM_LINK_TYPE &&
		links[0].form->type == F_TEXTAREA_TYPE &&
		links[0].form->number == thisgroup &&
		sametext(links[0].form->name, thisname)) {
		nextlink = 0;
	    } else
		while
		    (nextlink > 1 &&
		     links[nextlink-1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink-1].form->type == F_TEXTAREA_TYPE &&
		     links[nextlink-1].form->number == thisgroup &&
		     sametext(links[nextlink-1].form->name, thisname)) {
		    nextlink--;
d1502 1
a1503 2
	set_curdoc_link(nextlink);
	return FALSE;		/* and we are done. */
d1505 9
a1513 13
    } else if (Newline > 1 &&	/* need a previous page */
	       (res = HTGetLinkOrFieldStart(curdoc.link,
					    &Newline, &newdoc.link,
					    -1, TRUE)) != NO) {
	if (res == LINK_DO_ARROWUP) {
	    /*
	     *  It says we should use the normal PREV_LINK
	     *  mechanism, so we'll do that. - kw
	     */
	    if (nlinks > 0)
		curdoc.link = 0;
	    *cmd = LYK_PREV_LINK;
	    return TRUE;
d1515 1
a1515 17
	Newline++;	/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_ABOVE);
    }
    return FALSE;
}

PRIVATE void handle_LYK_FASTFORW_LINK ARGS2(
    int *,	old_c,
    int,	real_c)
{
    int samepage = 0, nextlink = curdoc.link;

    if (nlinks > 1) {
d1517 1
d1519 2
a1520 2
	 *  If in textarea, move to first link or field
	 *  after it if there is one on this screen. - kw
d1522 68
a1589 32
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].form->number;
	    char *thisname = links[curdoc.link].form->name;

	    if (curdoc.link < nlinks-1 &&
		!(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
		  links[nlinks-1].form->number == thisgroup &&
		  sametext(links[nlinks-1].form->name, thisname))) {
		do nextlink++;
		while
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].form->number == thisgroup &&
		     sametext(links[nextlink].form->name, thisname));
		samepage = 1;
	    } else if (!more && Newline == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link < nlinks-1) {
	    nextlink++;
	    samepage = 1;
	} else if (!more && Newline == 1 && curdoc.link > 0) {
	    nextlink = 0;
	    samepage = 1;
	}
    }
    if (samepage) {
	set_curdoc_link(nextlink);
	return;		/* and we are done. */
d1591 1
a1591 6
    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
	set_curdoc_link(0);
d1593 4
a1596 13
    } else if (more &&	/* need a later page */
	       HTGetLinkOrFieldStart(curdoc.link,
				     &Newline, &newdoc.link,
				     1, TRUE) != NO) {
	Newline++;	/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_BELOW);
    }
    return;
}
d1598 1
a1598 3
PRIVATE void handle_LYK_FIRST_LINK NOARGS
{
    int i = curdoc.link;
d1600 4
a1603 8
    for (;;) {
	if (--i < 0
	 || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i + 1);
	    break;
	}
    }
}
d1605 1
a1605 11
PRIVATE BOOLEAN handle_LYK_GOTO ARGS9(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	recall,
    int *,	URLTotal,
    int *,	URLNum,
    BOOLEAN *,	FirstURLRecall,
    int *,	old_c,
    int,	real_c)
{
d1607 8
a1614 7
    if (no_goto && !LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return FALSE;
    }
d1616 6
a1621 14
    StrAllocCopy(*old_user_input, user_input_buffer);
    if (!goto_buffer)
	*user_input_buffer = '\0';

    *URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
    if (goto_buffer && *user_input_buffer) {
	*recall = ((*URLTotal > 1) ? RECALL_URL : NORECALL);
	*URLNum = 0;
	*FirstURLRecall = FALSE;
    } else {
	*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
	*URLNum = *URLTotal;
	*FirstURLRecall = TRUE;
    }
d1623 5
a1627 17
    /*
     *	Ask the user.
     */
    _statusline(URL_TO_OPEN);
    if ((*ch = LYgetstr(user_input_buffer, VISIBLE,
		       MAX_LINE, *recall)) < 0 ) {
	/*
	 *  User cancelled the Goto via ^G.
	 *  Restore user_input_buffer and break. - FM
	 */
	LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
	FREE(*old_user_input);
	HTInfoMsg(CANCELLED);
	return FALSE;
    }
    return TRUE;
}
d1629 17
a1645 8
PRIVATE void handle_LYK_GROW_TEXTAREA ARGS1(
    BOOLEAN *,	refresh_screen)
{
    /*
     *  See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d1647 12
a1658 32
	HText_ExpandTextarea (&links[curdoc.link], TEXTAREA_EXPAND_SIZE);

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg (NOT_IN_TEXTAREA);
    }
}

PRIVATE BOOLEAN handle_LYK_HEAD ARGS1(
    int *,	cmd)
{
    int c;

    if (nlinks > 0 &&
	(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
	 links[curdoc.link].form->type == F_SUBMIT_TYPE ||
	 links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
	 links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE)) {
	/*
	 * We have links, and the current link is a normal link or a form's
	 * submit button.  - FM
	 */
	_statusline(HEAD_D_L_OR_CANCEL);
	c = LYgetch_single();
	if (c == 'D') {
	    char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
		curdoc.address : curdoc.address + 11;
	    if (LYCanDoHEAD(scheme) != TRUE) {
		HTUserMsg(DOC_NOT_HTTP_URL);
	    } else {
d1660 5
a1664 2
		 * Check if this is a reply from a POST, and if so, seek
		 * confirmation if the safe element is not set.  - FM
d1666 83
a1748 4
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
		    HTInfoMsg(CANCELLED);
d1750 5
a1754 9
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HTuncache_current_document();
			FREE(curdoc.address);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
		    }
d1756 1
a1756 44
	    }
	} else if (c == 'L') {
	    if (links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		strncmp(links[curdoc.link].lname, "http", 4) &&
		strncmp(links[curdoc.link].lname,
			"LYNXIMGMAP:http", 15) &&
		LYCanDoHEAD(links[curdoc.link].lname) != TRUE &&
		(links[curdoc.link].type != WWW_INTERN_LINK_TYPE ||
		 !curdoc.address ||
		 strncmp(curdoc.address, "http", 4))) {
		HTUserMsg(LINK_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].form->disabled) {
		HTUserMsg(FORM_ACTION_DISABLED);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       strncmp(links[curdoc.link].form->submit_action,
						      "lynxcgi:", 8) &&
		       strncmp(links[curdoc.link].form->submit_action,
							 "http", 4)) {
		HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].form->submit_method ==
						  URL_POST_METHOD &&
		       HTConfirm(CONFIRM_POST_LINK_HEAD) == FALSE) {
		HTInfoMsg(CANCELLED);
	    } else {
		HEAD_request = TRUE;
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return TRUE;
	    }
	}
    } else {
	/*
	 * We can offer only this document for a HEAD request.  Check if this
	 * is a reply from a POST, and if so, seek confirmation if the safe
	 * element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
	    HTInfoMsg(CANCELLED);
	} else {
	    if (nlinks > 0) {
d1758 2
a1759 3
		 * The current link is a non-submittable form link, so prompt
		 * the user to make it clear that the HEAD request would be for
		 * the current document, not the form link.  - FM
d1761 12
a1772 3
		_statusline(HEAD_D_OR_CANCEL);
		c = LYgetch_single();
	    } else {
d1774 1
a1774 2
		 * No links, so we can just assume that the user wants a HEAD
		 * request for the current document.  - FM
d1776 37
a1812 5
		c = 'D';
	    }
	    if (c == 'D') {
		char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
		    curdoc.address : curdoc.address + 11;
d1814 1
a1814 2
		 * The user didn't cancel, so check if a HEAD request is
		 * appropriate for the current document.  - FM
d1816 12
a1827 9
		if (LYCanDoHEAD(scheme) != TRUE) {
		    HTUserMsg(DOC_NOT_HTTP_URL);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HTuncache_current_document();
			FREE(curdoc.address);
d1829 6
a1834 1
			StrAllocCat(newdoc.title, " - HEAD");
d1837 6
d1844 1
a1845 3
    }
    return FALSE;
}
d1847 12
a1858 23
PRIVATE void handle_LYK_HELP ARGS1(
    CONST char **,	cshelpfile)
{
    if (*cshelpfile == NULL)
	*cshelpfile = helpfile;
    if (!STREQ(curdoc.address, *cshelpfile)) {
	/*
	 *  Set the filename.
	 */
	StrAllocCopy(newdoc.address, *cshelpfile);
	/*
	 *  Make a name for this help file.
	 */
	StrAllocCopy(newdoc.title, gettext("Help Screen"));
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    }
    *cshelpfile = NULL;		/* reset pointer - kw */
}
d1860 4
a1863 4
PRIVATE void handle_LYK_HISTORICAL NOARGS
{
#ifdef SOURCE_CACHE
    if (!HTcan_reparse_document()) {
d1865 11
a1875 19
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL,
			   0, 0) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HTuncache_current_document();
	StrAllocCopy(newdoc.address, curdoc.address);
	FREE(curdoc.address);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
#ifdef SOURCE_CACHE
    } /* end if no bypass */
d1877 2
a1878 11
    if (historical_comments)
	historical_comments = FALSE;
    else
	historical_comments = TRUE;
    if (minimal_comments) {
	HTAlert(historical_comments ?
		HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
    } else {
	HTAlert(historical_comments ?
		HISTORICAL_ON_VALID_OFF : HISTORICAL_OFF_VALID_ON);
    }
d1880 18
a1897 1
    (void) reparse_document();
a1898 2
    return;
}
d1900 3
a1902 19
PRIVATE BOOLEAN handle_LYK_HISTORY ARGS1(
    BOOLEAN,	ForcePush)
{
    if (curdoc.title && !LYIsUIPage(curdoc.address, UIP_HISTORY)) {
	/*
	 *  Don't do this if already viewing history page.
	 *
	 *  Push the current file so that the history list
	 *  contains the current file for printing purposes.
	 *  Pop the file afterwards to prevent multiple copies.
	 */
	if (TRACE && !LYUseTraceLog && LYCursesON) {
	    LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
	    LYaddstr("\n");
#endif /* USE_SLANG */
	    LYrefresh();
	}
	LYpush(&curdoc, ForcePush);
d1904 10
a1913 58
	/*
	 *  Print history options to file.
	 */
	if (showhistory(&newdoc.address) < 0) {
	    LYpop(&curdoc);
	    return TRUE;
	}
	LYRegisterUIPage(newdoc.address, UIP_HISTORY);
	StrAllocCopy(newdoc.title, HISTORY_PAGE_TITLE);
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	newdoc.link = 1; /*@@@@@@ bypass "recent statusline messages" link */
	FREE(curdoc.address);  /* so it doesn't get pushed */

	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
	return TRUE;
    } /* end if strncmp */
    return FALSE;
}

PRIVATE BOOLEAN handle_LYK_IMAGE_TOGGLE ARGS1(
    int *,	cmd)
{
    if (clickable_images)
	clickable_images = FALSE;
    else
	clickable_images = TRUE;

    HTUserMsg(clickable_images ?
	     CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
    return reparse_or_reload(cmd);
}

PRIVATE void handle_LYK_INDEX ARGS2(
    int *,	old_c,
    int,	real_c)
{
    /*
     *	Make sure we are not in the index already.
     */
    if (!STREQ(curdoc.address, indexfile)) {

	if (indexfile[0]=='\0') { /* no defined index */
		if (*old_c != real_c)	{
		    *old_c = real_c;
		    HTUserMsg(NO_INDEX_FILE);
		}

	} else {
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE) {
		last_kcode = NOKANJI;	/* AUTO */
a1914 12
#endif
	    StrAllocCopy(newdoc.address, indexfile);
	    StrAllocCopy(newdoc.title, gettext("System Index")); /* name it */
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	} /* end else */
    }  /* end if */
}
a1915 17
PRIVATE void handle_LYK_INDEX_SEARCH ARGS4(
    BOOLEAN *,	force_load,
    BOOLEAN,	ForcePush,
    int *,	old_c,
    int,	real_c)
{
    if (is_www_index) {
	/*
	 *  Perform a database search.
	 *
	 *  do_www_search will try to go out and get the document.
	 *  If it returns TRUE, a new document was returned and is
	 *  named in the newdoc.address.
	 */
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	if (do_www_search(&newdoc) == NORMAL) {
d1917 1
a1917 1
	     *	Yah, the search succeeded.
d1919 12
a1930 9
	    if (TRACE && !LYUseTraceLog && LYCursesON) {
		/*
		 *  Make sure cursor is down.
		 */
		LYHideCursor();
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
d1932 4
a1935 1
	    LYpush(&curdoc, ForcePush);
d1937 1
a1937 3
	     *	Make the curdoc.address the newdoc.address so that
	     *	getfile doesn't try to get the newdoc.address.
	     *	Since we have already gotten it.
d1939 3
a1941 7
	    StrAllocCopy(curdoc.address, newdoc.address);
	    StrAllocCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type, curdoc.post_content_type);
	    newdoc.internal_link = FALSE;
	    curdoc.line = -1;
	    Newline = 0;
	} else if (use_this_url_instead != NULL) {
d1943 4
a1946 1
	     *	Got back a redirecting URL.  Check it out.
d1948 7
a1954 1
	    _user_message("Using %s", use_this_url_instead);
d1956 6
a1961 1
	     *	Make a name for this URL.
d1963 8
a1970 12
	    StrAllocCopy(newdoc.title,
			 "A URL specified by redirection");
	    StrAllocCopy(newdoc.address, use_this_url_instead);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(use_this_url_instead);
	    *force_load = TRUE;
	} else {
d1972 3
a1974 1
	     *	Yuk, the search failed.  Restore the old file.
d1976 11
a1986 93
	    StrAllocCopy(newdoc.address, curdoc.address);
	    StrAllocCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type,
			 curdoc.post_content_type);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.isHEAD = curdoc.isHEAD;
	    newdoc.safe = curdoc.safe;
	    newdoc.internal_link = curdoc.internal_link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NOT_ISINDEX);
    }
}

PRIVATE BOOLEAN handle_LYK_INFO ARGS1(
    int *,	cmd)
{
    /*
     *	Don't do if already viewing info page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_SHOWINFO)) {
	if (do_change_link() != -1
	 && LYShowInfo(&curdoc, HText_getNumOfLines(),
		       &newdoc, owner_address) >= 0) {
	    LYRegisterUIPage(newdoc.address, UIP_SHOWINFO);
	    StrAllocCopy(newdoc.title, SHOWINFO_TITLE);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYforce_no_cache = TRUE;
	    if (LYValidate || check_realm)
		LYPermitURL = TRUE;
	}
    } else {
	/*
	 *  If already in info page, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

PRIVATE BOOLEAN handle_LYK_INLINE_TOGGLE ARGS1(
    int *,	cmd)
{
    if (pseudo_inline_alts)
	pseudo_inline_alts = FALSE;
    else
	pseudo_inline_alts = TRUE;

    HTUserMsg(pseudo_inline_alts ?
	      PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
    return reparse_or_reload(cmd);
}

PRIVATE void handle_LYK_INSERT_FILE ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    int n;

    /*
     *  See if the current link is in a form TEXTAREA.
     */
    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {

	/*
	 *  Reject attempts to use this for gaining access to
	 *  local files when such access is restricted:
	 *  if no_file_url was set via the file_url restriction,
	 *  if no_goto_file was set for the anonymous account,
	 *  or if HTDirAccess was set to HT_DIR_FORBID or
	 *  HT_DIR_SELECTIVE via the -nobrowse or -selective
	 *  switches, it is assumed that inserting files or
	 *  checking for existence of files needs to be denied. - kw
	 */
	if (no_file_url || no_goto_file ||
	    HTDirAccess == HT_DIR_FORBID ||
	    HTDirAccess == HT_DIR_SELECTIVE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		if (no_goto_file)
		    HTUserMsg2(GOTO_XXXX_DISALLOWED, "file:");
		else
		    HTUserMsg(NOAUTH_TO_ACCESS_FILES);
		HTInfoMsg(FILE_INSERT_CANCELLED);
d1988 2
a1989 32
	    return;
	}

	n = HText_InsertFile (&links[curdoc.link]);

	/*
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st line following the text
	 *	  that was inserted.  If the target line/anchor
	 *	  requires us to scroll up/down, position the
	 *	  target in the approximate center of the screen.
	 *
	 *  [Current behavior leaves cursor on the same line relative
	 *   to the start of the TEXTAREA that it was on before the
	 *   insertion.  This is the same behavior that occurs with
	 *   (my) editor, so this TODO will stay unimplemented.]
	 */

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg (NOT_IN_TEXTAREA);
    }
}

#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
PRIVATE void handle_LYK_INSTALL NOARGS
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support)
	local_install(NULL, links[curdoc.link].lname, &newdoc.address);
}
d1991 2
a1992 20

PRIVATE BOOLEAN handle_LYK_JUMP ARGS10(
    int,	c,
    char *,	user_input_buffer,
    char **,	old_user_input GCC_UNUSED,
    int *,	recall GCC_UNUSED,
    BOOLEAN *,	FirstURLRecall GCC_UNUSED,
    int *,	URLNum GCC_UNUSED,
    int *,	URLTotal GCC_UNUSED,
    int *,	ch GCC_UNUSED,
    int *,	old_c,
    int,	real_c)
{
    char *ret;

    if (no_jump || JThead == NULL) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    if (no_jump)
		HTUserMsg(JUMP_DISALLOWED);
d1994 7
a2000 26
		HTUserMsg(NO_JUMPFILE);
	}
    } else {
	LYJumpFileURL = TRUE;
	if ((ret = LYJump(c)) != NULL) {
#ifdef PERMIT_GOTO_FROM_JUMP
	    if (!strncasecomp(ret, "Go ", 3)) {
		LYJumpFileURL = FALSE;
		StrAllocCopy(*old_user_input, user_input_buffer);
		*URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
		*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
		*URLNum = *URLTotal;
		*FirstURLRecall = TRUE;
		if (!strcasecomp(ret, "Go :")) {
		    if (recall) {
			*ch = UPARROW;
			return TRUE;
		    }
		    FREE(*old_user_input);
		    HTUserMsg(NO_RANDOM_URLS_YET);
		    return FALSE;
		}
		ret = HTParse((ret+3), startfile, PARSE_ALL);
		LYstrncpy(user_input_buffer, ret, MAX_LINE - 1);
		FREE(ret);
		return TRUE;
d2002 3
a2004 4
#endif /* PERMIT_GOTO_FROM_JUMP */
	    ret = HTParse(ret, startfile, PARSE_ALL);
	    if (!LYTrimStartfile(ret)) {
		LYRemoveBlanks(user_input_buffer);
d2006 1
a2006 64
	    StrAllocCopy(newdoc.address, ret);
	    StrAllocCopy(lynxjumpfile, ret);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(ret);
	    LYUserSpecifiedURL = TRUE;
	} else {
	    LYJumpFileURL = FALSE;
	}
    }
    return FALSE;
}

PRIVATE void handle_LYK_KEYMAP ARGS4(
    BOOLEAN *,	vi_keys_flag,
    BOOLEAN *,	emacs_keys_flag,
    int *,	old_c,
    int,	real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	StrAllocCopy(newdoc.address, "LYNXKEYMAP:");
	StrAllocCopy(newdoc.title, CURRENT_KEYMAP_TITLE);
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 *  If vi_keys changed, the keymap did too,
	 *  so force no cache, and reset the flag. - FM
	 */
	if (*vi_keys_flag != vi_keys ||
	    *emacs_keys_flag != emacs_keys) {
	    LYforce_no_cache = TRUE;
	    *vi_keys_flag = vi_keys;
	    *emacs_keys_flag = emacs_keys;
	}
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	/*
	 *  Remember whether we are in dired menu
	 *  so we can display the right keymap.
	 */
	if (!no_dired_support) {
	    prev_lynx_edit_mode = lynx_edit_mode;
	}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	LYforce_no_cache = TRUE;
    }
}

PRIVATE void handle_LYK_LAST_LINK NOARGS
{
    int i = curdoc.link;

    for (;;) {
	if (++i >= nlinks
	 || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i - 1);
a2007 3
	}
    }
}
d2009 40
a2048 66
PRIVATE void handle_LYK_LEFT_LINK NOARGS
{
    if (curdoc.link>0 &&
		links[curdoc.link].ly == links[curdoc.link-1].ly) {
	set_curdoc_link(curdoc.link-1);
    }
}

PRIVATE BOOLEAN handle_LYK_LIST ARGS1(
    int *,     cmd)
{
    /*
     *	Don't do if already viewing list page.
     */
    if (!strcmp((curdoc.title ? curdoc.title : ""),
		LIST_PAGE_TITLE) &&
	LYIsUIPage(curdoc.address, UIP_LIST_PAGE)) {
	/*
	 *  Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     *	Print list page to file.
     */
    if (showlist(&newdoc, TRUE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, LIST_PAGE_TITLE);
    /*
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}

PRIVATE void handle_LYK_MAIN_MENU ARGS2(
    int *,	old_c,
    int,	real_c)
{
    /*
     *	If its already the homepage then don't reload it.
     */
    if (!STREQ(curdoc.address,homepage)) {

	if (HTConfirmDefault(CONFIRM_MAIN_SCREEN, NO) == YES) {
	    StrAllocCopy(newdoc.address, homepage);
	    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    highlight(OFF, curdoc.link, prev_target);
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
d2050 2
a2051 9
#endif /* DIRED_SUPPORT */
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(IN_MAIN_SCREEN);
	}
    }
}
d2053 1
a2053 3
PRIVATE void handle_LYK_MINIMAL NOARGS
{
    if (!historical_comments) {
d2055 1
a2055 1
    if (!HTcan_reparse_document()) {
d2057 17
a2073 17
	/*
	 *  Check if this is a reply from a POST, and if so,
	 *  seek confirmation of reload if the safe element
	 *  is not set. - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL,
			       0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HTuncache_current_document();
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
d2075 1
a2075 1
    } /* end if no bypass */
d2077 6
a2082 8
    }
    if (minimal_comments)
	minimal_comments = FALSE;
    else
	minimal_comments = TRUE;
    if (!historical_comments) {
	HTAlert(minimal_comments ?
		MINIMAL_ON_IN_EFFECT : MINIMAL_OFF_VALID_ON);
d2084 3
a2086 1
	(void)reparse_document();
d2088 1
a2088 6
    } else {
	HTAlert(minimal_comments ?
		MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
    }
    return;
}
d2090 3
a2092 36
#if defined(DIRED_SUPPORT)
PRIVATE void handle_LYK_MODIFY ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int ret;

	ret = local_modify(&curdoc, &newdoc.address);
	if (ret == PERMIT_FORM_RESULT) { /* Permit form thrown up */
	    *refresh_screen = TRUE;
	} else if (ret) {
	    DIRED_UNCACHE_1;
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

#ifdef EXP_NESTED_TABLES
PRIVATE BOOLEAN handle_LYK_NESTED_TABLES ARGS1(
    int *,	cmd)
{
    nested_tables = !nested_tables;
    HTUserMsg(nested_tables ? NESTED_TABLES_ON : NESTED_TABLES_OFF);
    return reparse_or_reload(cmd);
}
d2094 4
a2097 56

PRIVATE BOOLEAN handle_LYK_OPTIONS ARGS2(
    int *,	cmd,
    BOOLEAN *,	refresh_screen)
{
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions) {
	BOOLEAN LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
	BOOLEAN LYSelectPopups_flag = LYSelectPopups;
	BOOLEAN verbose_img_flag = verbose_img;
	BOOLEAN keypad_mode_flag = (BOOL) keypad_mode;
	BOOLEAN show_dotfiles_flag = show_dotfiles;
	BOOLEAN user_mode_flag = (BOOL) user_mode;
	int CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
	int CurrentCharSet_flag = current_char_set;
	int HTfileSortMethod_flag = HTfileSortMethod;
	char *CurrentUserAgent = NULL;
	char *CurrentNegoLanguage = NULL;
	char *CurrentNegoCharset = NULL;
	StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : ""));
	StrAllocCopy(CurrentNegoLanguage, (language ?
					   language : ""));
	StrAllocCopy(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""));

	LYoptions(); /** do the old-style options stuff **/

	if (keypad_mode_flag != keypad_mode ||
	    (user_mode_flag != user_mode &&
	     (user_mode_flag == NOVICE_MODE ||
	      user_mode == NOVICE_MODE)) ||
	    (((HTfileSortMethod_flag != HTfileSortMethod) ||
	      (show_dotfiles_flag != show_dotfiles)) &&
	     (!strncmp(curdoc.address, "file:", 5) ||
	      !strncmp(curdoc.address, "ftp:", 4))) ||
	    CurrentCharSet_flag != current_char_set ||
	    CurrentAssumeCharSet_flag != UCLYhndl_for_unspec ||
	    verbose_img_flag != verbose_img ||
	    LYUseDefaultRawMode_flag != LYUseDefaultRawMode ||
	    LYSelectPopups_flag != LYSelectPopups ||
	    ((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
	      strcmp(CurrentNegoLanguage, (language ?
					   language : "")) ||
	      strcmp(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""))) &&
	     (!strncmp(curdoc.address, "http", 4) ||
	      !strncmp(curdoc.address, "lynxcgi:", 8)))) {

	    BOOLEAN canreparse_post = FALSE;

	    /*
	     *  Check if this is a reply from a POST, and if so,
	     *  seek confirmation of reload if the safe element
	     *  is not set. - FM
d2101 2
a2102 5
#ifdef SOURCE_CACHE
		(!(canreparse_post = HTcan_reparse_document())) &&
#endif
		confirm_post_resub(curdoc.address, curdoc.title,
				   2, 1) == FALSE) {
d2105 16
a2120 35
		StrAllocCopy(newdoc.address, curdoc.address);
		if (((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
		      strcmp(CurrentNegoLanguage,
			     (language ? language : "")) ||
		      strcmp(CurrentNegoCharset,
			     (pref_charset ? pref_charset : ""))) &&
		     (strncmp(curdoc.address, "http", 4) == 0 ||
		      strncmp(curdoc.address, "lynxcgi:", 8) == 0))) {
		    /*
		     *  An option has changed which may influence
		     *  content negotiation, and the resource is from
		     *  a http or https or lynxcgi URL (the only protocols
		     *  which currently do anything with this information).
		     *  Set reloading = TRUE so that proxy caches will be
		     *  flushed, which is necessary until the time when
		     *  all proxies understand HTTP 1.1 Vary: and all
		     *  Servers properly use it...	Treat like
		     *  case LYK_RELOAD (see comments there). - KW
		     */
		    reloading = TRUE;
		}
		if (HTisDocumentSource()) {
		    srcmode_for_next_retrieval(1);
		}
#ifdef SOURCE_CACHE
		if (reloading == FALSE) {
		    /* one more attempt to be smart enough: */
		    if (reparse_document()) {
			FREE(CurrentUserAgent);
			FREE(CurrentNegoLanguage);
			FREE(CurrentNegoCharset);
			return FALSE;
		    }
		}
d2122 1
a2122 10
		if (canreparse_post &&
		    confirm_post_resub(curdoc.address, curdoc.title,
				       2, 1) == FALSE) {
		    if (HTisDocumentSource()) {
			srcmode_for_next_retrieval(0);
		    }
		    FREE(CurrentUserAgent);
		    FREE(CurrentNegoLanguage);
		    FREE(CurrentNegoCharset);
		    return FALSE;
a2123 2

		HEAD_request = HTLoadedDocumentIsHEAD();
d2125 2
a2133 2
		LYforce_no_cache = TRUE;
		FREE(curdoc.address); /* So it doesn't get pushed. */
d2135 28
a2162 25
	}
	FREE(CurrentUserAgent);
	FREE(CurrentNegoLanguage);
	FREE(CurrentNegoCharset);
	*refresh_screen = TRUE; /* to repaint screen */
	return FALSE;
    } /* end if !LYUseFormsOptions */
#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS
    /*
     * Generally stolen from LYK_COOKIE_JAR.  Options menu handling is
     * done in postoptions(), called from getfile() currently.
     *
     * postoptions() is also responsible for reloading the document
     * before the 'options menu' but only when (a few) important
     * options were changed.
     *
     * It is critical that post_data is freed here since the
     * submission of changed options is done via the same protocol as
     * LYNXOPTIONS:
     */
    /*
     *	Don't do if already viewing options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU)) {
d2164 5
a2168 105
	StrAllocCopy(newdoc.address, "LYNXOPTIONS:/");
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	/* change to 'if (check_realm && !LYValidate)' and
	   make change near top of getfile to forbid
	   using forms options menu with -validate:  - kw */
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
   } else {
	/*
	 *  If already in the options menu, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
#endif /* !NO_OPTION_FORMS */
    return FALSE;
}

PRIVATE void handle_NEXT_DOC NOARGS
{
    if (LYhist_next(&curdoc, &newdoc)) {
	FREE(curdoc.address);		/* avoid push */
	return;
    }
    HTUserMsg(gettext("No next document present"));
}

PRIVATE void handle_LYK_NEXT_LINK ARGS3(
    int,	c,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.link < nlinks-1) {	/* next link */
	highlight(OFF, curdoc.link, prev_target);
#ifdef FASTTAB
	/*
	 *  Move to different textarea if TAB in textarea.
	 */
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
	    c=='\t') {
	    int thisgroup = links[curdoc.link].form->number;
	    char *thisname = links[curdoc.link].form->name;

	    do curdoc.link++;
	    while ((curdoc.link < nlinks-1) &&
		   links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		   links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
		   links[curdoc.link].form->number == thisgroup &&
		   sametext(links[curdoc.link].form->name, thisname));
	} else {
	    curdoc.link++;
	}
#else
	curdoc.link++;
#endif /* FASTTAB */
    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
	set_curdoc_link(0);

    } else if (more) {	/* next page */
	Newline += (display_lines);

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

PRIVATE void handle_LYK_NEXT_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
{
    if (more) {
	Newline += display_lines;
    } else if (curdoc.link < nlinks-1) {
	set_curdoc_link(nlinks - 1);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

PRIVATE BOOLEAN handle_LYK_NOCACHE ARGS2(
    int *,	old_c,
    int,	real_c)
{
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].form->type != F_SUBMIT_TYPE &&
	    links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE &&
	    links[curdoc.link].form->type != F_TEXT_SUBMIT_TYPE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
d2170 3
a2172 115
	    return FALSE;
	} else {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
    }
    return TRUE;
}

PRIVATE void handle_LYK_PREV_LINK ARGS3(
    int *,	arrowup,
    int	*,	old_c,
    int,	real_c)
{
    if (curdoc.link > 0) {	     /* previous link */
	set_curdoc_link(curdoc.link - 1);

    } else if (!more &&
	       curdoc.link==0 && Newline==1) { /* at the top of list */
	/*
	 *  If there is only one page of data and the user
	 *  goes off the top, just move the cursor to last link on
	 *  the page.
	 */
	set_curdoc_link(nlinks - 1);

    } else if (curdoc.line > 1) {	/* previous page */
	/*
	 *  Go back to the previous page.
	 */
	int scrollamount = (Newline > display_lines ?
				      display_lines : Newline - 1);
	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link == 0 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

PRIVATE int handle_PREV_DOC ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
    if (nhist > 0) {  /* if there is anything to go back to */
	/*
	 *  Check if the previous document is a reply from a POST,
	 *  and if so, seek confirmation of resubmission if the safe
	 *  element is not set and the document is not still in the
	 *  cache or LYresubmit_posts is set.  If not confirmed and
	 *  it is not the startfile, pop it so we go to the yet
	 *  previous document, until we're OK or reach the startfile.
	 *  If we reach the startfile and its not OK or we don't get
	 *  confirmation, cancel. - FM
	 */
	DocAddress WWWDoc;
	HTParentAnchor *tmpanchor;
	HText *text;
	BOOLEAN conf = FALSE, first = TRUE;

	HTLastConfirmCancelled(); /* reset flag */
	while (nhist > 0) {
	    conf = FALSE;
	    if (history[(nhist - 1)].post_data == NULL) {
		break;
	    }
	    WWWDoc.address = history[(nhist - 1)].address;
	    WWWDoc.post_data = history[(nhist - 1)].post_data;
	    WWWDoc.post_content_type =
			       history[(nhist - 1)].post_content_type;
	    WWWDoc.bookmark = history[(nhist - 1)].bookmark;
	    WWWDoc.isHEAD = history[(nhist - 1)].isHEAD;
	    WWWDoc.safe = history[(nhist - 1)].safe;
	    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
	    if (HTAnchor_safe(tmpanchor)) {
		break;
	    }
	    if (((text =
		  (HText *)HTAnchor_document(tmpanchor)) == NULL &&
		 (!strncmp(WWWDoc.address, "LYNXIMGMAP:", 11) ||
		 (conf = confirm_post_resub(WWWDoc.address,
					    history[(nhist - 1)].title,
					    0, 0))
		  == FALSE)) ||
		((LYresubmit_posts && !conf &&
		  (NONINTERNAL_OR_PHYS_DIFFERENT(
		      (document *)&history[(nhist - 1)],
		      &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT(
		       (document *)&history[(nhist - 1)],
		       &newdoc))) &&
		 !confirm_post_resub(WWWDoc.address,
				     history[(nhist - 1)].title,
				     2, 2))) {
		if (HTLastConfirmCancelled()) {
		    if (!first && curdoc.internal_link)
			FREE(curdoc.address);
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		}
		if (nhist == 1) {
		    HTInfoMsg(CANCELLED);
		    *old_c = 0;
		    *cmd = LYK_DO_NOTHING;
		    return 2;
d2174 1
a2174 8
		    HTUserMsg2(WWW_SKIP_MESSAGE, WWWDoc.address);
		    do {	/* Should be LYhist_prev when _next supports */
			LYpop(&curdoc);		/* skipping of forms */
		    } while (nhist > 1 && !are_different(
			(document *)&history[(nhist - 1)],
			&curdoc));
		    first = FALSE; /* have popped at least one */
		    continue;
d2176 2
d2179 1
a2179 9
		/*
		 *  Break from loop; if user just confirmed to
		 *  load again because document wasn't in cache,
		 *  set LYforce_no_cache to avoid unnecessary
		 *  repeat question down the road. - kw
		 */
		if (conf)
		    LYforce_no_cache = TRUE;
		break;
d2181 1
a2181 1
	}
d2183 2
a2184 2
	if (!first)
	    curdoc.internal_link = FALSE;
d2186 9
a2194 336
	/*
	 *  Set newdoc.address to empty to pop a file.
	 */
	LYhist_prev_register(&curdoc);	/* Why not call _prev instead of zeroing address?  */
	FREE(newdoc.address);
#ifdef DIRED_SUPPORT
	if (lynx_edit_mode) {
	    DIRED_UNCACHE_2;
	}
#endif /* DIRED_SUPPORT */
    } else if (child_lynx == TRUE) {
	return(1); /* exit on left arrow in main screen */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(ALREADY_AT_FIRST);
    }
    return 0;
}

PRIVATE void handle_LYK_PREV_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	Newline -= display_lines;
    } else if (curdoc.link > 0) {
	set_curdoc_link(0);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

PRIVATE void handle_LYK_PRINT ARGS3(
    BOOLEAN *,	ForcePush,
    int *,	old_c,
    int,	real_c)
{
    if (LYValidate) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(PRINT_DISABLED);
	}
	return;
    }

    /*
     *	Don't do if already viewing print options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)
     && print_options(&newdoc.address,
		      curdoc.address, HText_getNumOfLines()) >= 0) {
	LYRegisterUIPage(newdoc.address, UIP_PRINT_OPTIONS);
	StrAllocCopy(newdoc.title, PRINT_OPTIONS_TITLE);
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	*ForcePush = TRUE;  /* see LYpush() and print_options() */
	if (check_realm)
	    LYPermitURL = TRUE;
    }
}

PRIVATE BOOLEAN handle_LYK_QUIT NOARGS
{
    int c;

    if (LYQuitDefaultYes == TRUE) {
	c = HTConfirmDefault(REALLY_QUIT_Y, YES);
    } else {
	c = HTConfirmDefault(REALLY_QUIT_N, NO);
    }
    if (LYQuitDefaultYes == TRUE) {
	if (c != NO) {
	    return(TRUE);
	} else {
	    HTInfoMsg(NO_CANCEL);
	}
    } else if (c == YES) {
	return(TRUE);
    } else {
	HTInfoMsg(NO_CANCEL);
    }
    return FALSE;
}

PRIVATE BOOLEAN handle_LYK_RAW_TOGGLE ARGS1(
    int *,	cmd)
{
    if (HTLoadedDocumentCharset()) {
	HTUserMsg(gettext("charset for this document specified explicitly, sorry..."));
	return FALSE;
    } else {
	LYUseDefaultRawMode = (BOOL) !LYUseDefaultRawMode;
	HTUserMsg(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
	HTMLSetCharacterHandling(current_char_set);
	return reparse_or_reload(cmd);
    }
}

/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
PRIVATE void handle_LYK_RELOAD ARGS1(
    int,	real_cmd)
{
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    /*
     *	Check to see if should reload source, or load html
     */

    if (HTisDocumentSource()) {
	if ((forced_UCLYhdnl = HTMainText_Get_UCLYhndl()) >= 0)
	    force_old_UCLYhndl_on_reload = TRUE;
	srcmode_for_next_retrieval(1);
    }

    HEAD_request = HTLoadedDocumentIsHEAD();
    HTuncache_current_document();
#ifdef NO_ASSUME_SAME_DOC
    /*
     *	Don't assume the reloaded document will be the same. - FM
     */
    newdoc.line = 1;
    newdoc.link = 0;
#else
    /*
     *	Do assume the reloaded document will be the same. - FM
     *	(I don't remember all the reasons why we couldn't assume
     *	 this.	As the problems show up, we'll try to fix them,
     *	 or add warnings.  - FM)
     */
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
    FREE(curdoc.address); /* so it doesn't get pushed */
#ifdef VMS
    lynx_force_repaint();
#endif /* VMS */
    /*
     *	Reload should force a cache refresh on a proxy.
     *	      -- Ari L. <luotonen@@dxcern.cern.ch>
     *
     *	-- but only if this was really a reload requested by
     *	the user, not if we jumped here to handle reloading for
     *	INLINE_TOGGLE, IMAGE_TOGGLE, RAW_TOGGLE, etc. - KW
     */
    if (real_cmd == LYK_RELOAD)
	reloading = TRUE;

    return;
}

#ifdef DIRED_SUPPORT
PRIVATE void handle_LYK_REMOVE ARGS1(
    BOOLEAN *,	refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int linkno = curdoc.link; /* may be changed in local_remove - kw */
	local_remove(&curdoc);
	if (LYAutoUncacheDirLists >= 1)
	    do_cleanup_after_delete();
	else if (curdoc.link != linkno)
	    *refresh_screen = TRUE;
    }
}
#endif /* DIRED_SUPPORT */

PRIVATE void handle_LYK_RIGHT_LINK NOARGS
{
    if (curdoc.link<nlinks-1 &&
		links[curdoc.link].ly == links[curdoc.link+1].ly) {
	set_curdoc_link(curdoc.link + 1);
    }
}

PRIVATE void handle_LYK_SHELL ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    if (!no_shell) {
	stop_curses();
	printf("%s\r\n", SPAWNING_MSG);
#if defined(__CYGWIN__)
	Cygwin_Shell();
#else
	LYSystem(LYSysShell());
#endif
	start_curses();
	*refresh_screen = TRUE;	/* for an HText_pageDisplay() */
    } else {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(SPAWNING_DISABLED);
	}
    }
}

PRIVATE void handle_LYK_SOFT_DQUOTES NOARGS
{
#ifdef SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HTuncache_current_document();
	StrAllocCopy(newdoc.address, curdoc.address);
	FREE(curdoc.address);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
#ifdef SOURCE_CACHE
    } /* end if no bypass */
#endif
    if (soft_dquotes)
	soft_dquotes = FALSE;
    else
	soft_dquotes = TRUE;
    HTUserMsg(soft_dquotes ?
	      SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
#ifdef SOURCE_CACHE
    (void)reparse_document();
#endif
    return;
}

/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
PRIVATE void handle_LYK_SOURCE ARGS1(
    char **,	ownerS_address_p)
{
#ifdef SOURCE_CACHE
    BOOLEAN canreparse_post = FALSE;
#endif
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
#ifdef SOURCE_CACHE
	(!(canreparse_post = HTcan_reparse_document())) &&
#endif
	(curdoc.isHEAD ? HTConfirm(CONFIRM_POST_RESUBMISSION) :
	 confirm_post_resub(curdoc.address, curdoc.title,
			    1, 1)) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (HTisDocumentSource()) {
	srcmode_for_next_retrieval(-1);
    } else {
	if (HText_getOwner())
	    StrAllocCopy(*ownerS_address_p, HText_getOwner());
	LYUCPushAssumed(HTMainAnchor);
	srcmode_for_next_retrieval(1);
    }

#ifdef SOURCE_CACHE
    if (reparse_document()) {
	/*
	 * These normally get cleaned up after getfile() returns;
	 * since we're not calling getfile(), we have to clean them
	 * up ourselves.  -dsb
	 */
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    HTMark_asSource();
	psrc_view = FALSE;
#endif
	FREE(*ownerS_address_p);  /* not used with source_cache */
	LYUCPopAssumed();	/* probably a right place here */
	HTMLSetCharacterHandling(current_char_set);  /* restore now */

	return;
    } else if (canreparse_post) {
	srcmode_for_next_retrieval(0);
	LYUCPopAssumed();	/* probably a right place here */
	return;
    }
#endif

    if (curdoc.title)
	StrAllocCopy(newdoc.title, curdoc.title);
    FREE(curdoc.address); /* so it doesn't get pushed */
    LYforce_no_cache = TRUE;
}

PRIVATE void handle_LYK_SWITCH_DTD NOARGS
{
#ifdef SOURCE_CACHE
    BOOLEAN canreparse = FALSE;
    if (!(canreparse = HTcan_reparse_document())) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so,
	 * seek confirmation of reload if the safe element
	 * is not set.  - FM, kw
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    /*
	     *  If currently viewing preparsed source, switching
	     *  to the other DTD parsing may show source differences,
	     *  so stay in source view - kw
	     */

	    /* NOTE: this conditional can be considered incorrect -
	       current behaviour - when viewing source and
	       LYPreparsedSource==TRUE, pressing ^V will toggle parser mode
	       AND switch back from the source view to presentation view.-HV
	    */
	    if (HTisDocumentSource() && LYPreparsedSource) {
		srcmode_for_next_retrieval(1);
d2196 1
a2196 29
	    HTuncache_current_document();
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
#ifdef NO_ASSUME_SAME_DOC
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
	}
#ifdef SOURCE_CACHE
    } /* end if no bypass */
#endif
    Old_DTD = !Old_DTD;
    HTSwitchDTD(!Old_DTD);
    HTUserMsg(Old_DTD ? USING_DTD_0 : USING_DTD_1);
#ifdef SOURCE_CACHE
    if (canreparse) {
	if (HTisDocumentSource() && LYPreparsedSource) {
	    srcmode_for_next_retrieval(1);
	}
	if (!reparse_document()) {
	    srcmode_for_next_retrieval(0);
	}
    }
#endif
    return;
}
d2198 9
a2206 27
#ifdef DIRED_SUPPORT
PRIVATE void handle_LYK_TAG_LINK NOARGS
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	if (!strcmp(links[curdoc.link].hightext, ".."))
	    return;	/* Never tag the parent directory */
	if (dir_list_style == MIXED_STYLE) {
	    if (!strcmp(links[curdoc.link].hightext, "../"))
		return;
	} else if (!strncmp(links[curdoc.link].hightext, "Up to ", 6))
	    return;
	{
	    /*
	     *	HTList-based management of tag list, see LYLocal.c - KW
	     */
	    HTList * t1 = tagged;
	    char * tagname = NULL;
	    BOOLEAN found = FALSE;

	    while ((tagname = (char *)HTList_nextObject(t1)) != NULL) {
		if (!strcmp(links[curdoc.link].lname, tagname)) {
		    found = TRUE;
		    HTList_removeObject(tagged, tagname);
		    FREE(tagname);
		    tagflag(OFF,curdoc.link);
		    break;
		}
d2208 1
a2208 19
	    if (!found) {
		if (tagged == NULL)
		    tagged = HTList_new();
		tagname = NULL;
		StrAllocCopy(tagname,links[curdoc.link].lname);
		HTList_addObject(tagged,tagname);
		tagflag(ON,curdoc.link);
	    }
	}
	if (curdoc.link < nlinks-1) {
	    set_curdoc_link(curdoc.link + 1);
	} else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
	    set_curdoc_link(0);
	} else if (more) {  /* next page */
	    Newline += (display_lines);
	}
    }
}
#endif /* DIRED_SUPPORT */
d2210 11
a2220 1456
PRIVATE void handle_LYK_TOGGLE_HELP NOARGS
{
    if (user_mode == NOVICE_MODE) {
	toggle_novice_line();
	noviceline(more);
    }
}

PRIVATE void handle_LYK_TOOLBAR ARGS4(
    BOOLEAN *,	try_internal,
    BOOLEAN *,	force_load,
    int *,	old_c,
    int,	real_c)
{
    char *cp;
    char *toolbar = NULL;

    if (!HText_hasToolbar(HTMainText)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_TOOLBAR);
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	if ((cp = strchr(curdoc.address, '#')) != NULL)
	    *cp = '\0';

	HTSprintf0(&toolbar, "%s#%s", curdoc.address, LYToolbarName);
	if (cp)
	    *cp = '#';
	StrAllocCopy(newdoc.address, toolbar);
	FREE(toolbar);
	*try_internal = TRUE;
	*force_load = TRUE;  /* force MainLoop to reload */
    }
}

PRIVATE void handle_LYK_TRACE_LOG ARGS1(
    BOOLEAN *,	trace_flag_ptr)
{
#ifndef NO_LYNX_TRACE
    /*
     *	Check whether we've started a TRACE log
     *	in this session. - FM
     */
    if (LYTraceLogFP == NULL) {
	HTUserMsg(NO_TRACELOG_STARTED);
	return;
    }

    /*
     *	Don't do if already viewing the TRACE log. - FM
     */
    if (LYIsUIPage(curdoc.address, UIP_TRACELOG))
	return;

    /*
     *	If TRACE mode is on, turn it off during this fetch of the
     *	TRACE log, so we don't enter stuff about this fetch, and
     *	set a flag for turning it back on when we return to this
     *	loop.  Note that we'll miss any messages about memory
     *	exhaustion if it should occur.	It seems unlikely that
     *	anything else bad might happen, but if it does, we'll
     *	miss messages about that too.  We also fflush(), close,
     *	and open it again, to make sure all stderr messages thus
     *	far will be in the log. - FM
     */
    if (!LYReopenTracelog(trace_flag_ptr))
	return;

    LYLocalFileToURL (&(newdoc.address), LYTraceLogPath);
    LYRegisterUIPage(newdoc.address, UIP_TRACELOG);
    StrAllocCopy(newdoc.title, LYNX_TRACELOG_TITLE);
    FREE(newdoc.post_data);
    FREE(newdoc.post_content_type);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
    }
    LYforce_no_cache = TRUE;
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

#ifdef DIRED_SUPPORT
PRIVATE void handle_LYK_UPLOAD NOARGS
{
    /*
     *	Don't do if already viewing upload options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS))
	return;

    if (lynx_edit_mode && !no_dired_support) {
	LYUpload_options((char **)&newdoc.address,
			 (char *)curdoc.address);
	StrAllocCopy(newdoc.title, UPLOAD_OPTIONS_TITLE);
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 *  Uncache the current listing so that it will
	 *  be updated to included the uploaded file if
	 *  placed in the current directory. - FM
	 */
	DIRED_UNCACHE_1;
     }
}
#endif /* DIRED_SUPPORT */

PRIVATE void handle_LYK_UP_HALF ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	int scrollamount = display_lines/2;
	if (Newline - scrollamount < 1)
	    scrollamount = Newline - 1;
	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
			      HText_LinksInLines(HTMainText,
						 Newline,
						 scrollamount);
	    } else {
		*arrowup = TRUE;
	    }
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

PRIVATE void handle_LYK_UP_LINK ARGS4(
    int *,	follow_col,
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (curdoc.link > 0 &&
	(links[0].ly != links[curdoc.link].ly ||
	 !HText_LinksInLines(HTMainText, 1, Newline - 1))) {
	/* more links before this on screen, and first of them on
	   a different line or no previous links before this screen? */
	int newlink;

	if (*follow_col == -1) {
	    *follow_col = links[curdoc.link].lx;

	    if (links[curdoc.link].hightext)
		*follow_col += strlen(links[curdoc.link].hightext)/2;
	}

	newlink = find_link_near_col(*follow_col, -1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_ABOVE);
	}

    } else if (curdoc.line > 1 && Newline > 1) {  /* previous page */
	int scrollamount = (Newline > display_lines ?
				      display_lines : Newline - 1);
	Newline -= scrollamount;
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link > -1 &&
	    links[0].ly -1 + scrollamount <= display_lines) {
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

PRIVATE void handle_LYK_UP_TWO ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	int scrollamount = (Newline > 2 ? 2 : 1);
	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
			      HText_LinksInLines(HTMainText,
						 Newline, scrollamount);
	    } else {
		*arrowup = TRUE;
	    }
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

PRIVATE void handle_LYK_VIEW_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
{
    char *cp;

    if (LYValidate) {
	if (*old_c != real_c)	{
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    /*
     *	See if a bookmark exists.
     *	If it does replace newdoc.address with its name.
     */
    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL) {
	if (*cp == '\0' || !strcmp(cp, " ") ||
	    !strcmp(curdoc.address, newdoc.address)) {
	    if (LYMultiBookmarks != MBM_OFF)
		*refresh_screen = TRUE;
	    return;
	}
#ifdef KANJI_CODE_OVERRIDE
	if (HTCJK == JAPANESE) {
	    last_kcode = NOKANJI;	/* AUTO */
	}
#endif
	LYforce_no_cache = TRUE;  /*force the document to be reloaded*/
	StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
	StrAllocCopy(newdoc.bookmark, BookmarkPage);
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    LYMBM_statusline(BOOKMARKS_NOT_OPEN);
	    LYSleepAlert();
	    if (LYMultiBookmarks != MBM_OFF) {
		*refresh_screen = TRUE;
	    }
	}
    }
}

PRIVATE BOOLEAN handle_LYK_VLINKS ARGS2(
    int *,	cmd,
    BOOLEAN *,	newdoc_link_is_absolute)
{
    int c;

    if (LYIsUIPage(curdoc.address, UIP_VLINKS)) {
	/*
	 *  Already viewing visited links page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     *	Print visited links page to file.
     */
    c = LYShowVisitedLinks(&newdoc.address);
    if (c < 0) {
	HTUserMsg(VISITED_LINKS_EMPTY);
	return FALSE;
    }
    StrAllocCopy(newdoc.title, VISITED_LINKS_TITLE);
    FREE(newdoc.post_data);
    FREE(newdoc.post_content_type);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (c > 0) {
	/* Select a correct link. */
	*newdoc_link_is_absolute = TRUE;
	newdoc.link = c - 1;
    }
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlinksfile, newdoc.address);
    }
    return FALSE;
}

PUBLIC void handle_LYK_WHEREIS ARGS2(
    int,	cmd,
    BOOLEAN *,	refresh_screen)
{
    BOOLEAN have_target_onscreen = (BOOLEAN) (*prev_target != '\0' &&
				    HText_pageHasPrevTarget());
    BOOL found;
    int oldcur = curdoc.link; /* temporarily remember */
    char *remember_old_target = NULL;
    if (have_target_onscreen)
	StrAllocCopy(remember_old_target, prev_target);
    else
	StrAllocCopy(remember_old_target, "");

    if (cmd == LYK_WHEREIS) {
	/*
	 *  Reset prev_target to force prompting
	 *  for a new search string and to turn
	 *  off highlighting if no search string
	 *  is entered by the user.
	 */
	*prev_target = '\0';
    }
    found = textsearch(&curdoc, prev_target, sizeof(prev_target)-1,
		       (cmd == LYK_WHEREIS)
		       ? 0
		       : ((cmd == LYK_NEXT)
			 ? 1
			 : -1));

    /*
     *	Force a redraw to ensure highlighting of hits
     *	even when found on the same page, or clearing
     *	of highlighting if the default search string
     *	was erased without replacement. - FM
     */
    /*
    ** Well let's try to avoid it at least in a few cases
    ** where it is not needed. - kw
    */
    if (www_search_result >= 0 && www_search_result != curdoc.line) {
	*refresh_screen = TRUE; /* doesn't really matter */
    } else if (!found) {
	*refresh_screen = have_target_onscreen;
    } else if (!have_target_onscreen && found) {
	*refresh_screen = TRUE;
    } else if (www_search_result == curdoc.line &&
	       curdoc.link == oldcur &&
	       curdoc.link >= 0 && nlinks > 0 &&
	       links[curdoc.link].ly >= (display_lines/3)) {
	*refresh_screen = TRUE;
    } else if ((case_sensitive && 0!=strcmp(prev_target,
					    remember_old_target)) ||
	     (!case_sensitive && 0!=strcasecomp8(prev_target,
					    remember_old_target))) {
	*refresh_screen = TRUE;
    }
    FREE(remember_old_target);
}

/*
 * Get a number from the user and follow that link number.
 */
PRIVATE void handle_LYK_digit ARGS6(
    int,	c,
    BOOLEAN *,	force_load,
    char *,	user_input_buffer,
    int *,	old_c,
    int,	real_c,
    BOOLEAN *,	try_internal GCC_UNUSED)
{
    int lindx = ((nlinks > 0) ? curdoc.link : 0);
    int number;
    char *temp = NULL;

    /* pass cur line num for use in follow_link_number()
     * Note: Current line may not equal links[cur].line
     */
    number = curdoc.line;
    switch (follow_link_number(c, lindx, &newdoc, &number)) {
    case DO_LINK_STUFF:
	/*
	 *  Follow a normal link.
	 */
	StrAllocCopy(newdoc.address, links[lindx].lname);
	StrAllocCopy(newdoc.title, links[lindx].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
	/*
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
	 */
	if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
	    LYinternal_flag = TRUE;
	    newdoc.internal_link = TRUE;
	    if (LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
		(LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		 LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		if (check_history()) {
		    LYinternal_flag = TRUE;
		} else {
		    HTLastConfirmCancelled(); /* reset flag */
		    if (!confirm_post_resub(newdoc.address,
					    newdoc.title,
					    (LYresubmit_posts &&
					     HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
					    2)) {
			if (HTLastConfirmCancelled() ||
			    (LYresubmit_posts &&
			     !HText_POSTReplyLoaded(&newdoc))) {
			    /* cancel the whole thing */
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    StrAllocCopy(newdoc.address, curdoc.address);
			    StrAllocCopy(newdoc.title, curdoc.title);
			    newdoc.internal_link = curdoc.internal_link;
			    HTInfoMsg(CANCELLED);
			    if (nlinks > 0)
				HText_pageDisplay(curdoc.line, prev_target);
			    break;
			} else if (LYresubmit_posts) {
			    /* If LYresubmit_posts is set, and the
			       answer was No, and we have a cached
			       copy, then use it. - kw */
			    LYforce_no_cache = FALSE;
			} else {
			    /* if No, but not ^C or ^G, drop
			     * the post data.  Maybe the link
			     * wasn't meant to be internal after
			     * all, here we can recover from that
			     * assumption. - kw */
			    FREE(newdoc.post_data);
			    FREE(newdoc.post_content_type);
			    newdoc.internal_link = FALSE;
			    HTAlert(DISCARDING_POST_DATA);
			}
		    }
		}
		/*
		 *  Don't push the List Page if we follow an
		 *  internal link given by it. - kw
		 */
		FREE(curdoc.address);
	    } else
		*try_internal = TRUE;
	    if (!(LYresubmit_posts && newdoc.post_data))
		LYinternal_flag = TRUE;
	    *force_load = TRUE;
	    break;
	} else {
	    /*
	     *	Free POST content if not an internal link. - kw
	     */
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	}
#endif /* DONT_TRACK_INTERNAL_LINKS */
	/*
	 *  Might be an anchor in the same doc from a POST
	 *  form.  If so, don't free the content. -- FM
	 */
	if (are_different(&curdoc, &newdoc)) {
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    if (!strncmp(newdoc.address, "LYNXMESSAGES:", 13))
		LYforce_no_cache = TRUE;
	}
	newdoc.internal_link = FALSE;
	*force_load = TRUE;  /* force MainLoop to reload */
	break;

    case DO_GOTOLINK_STUFF:
	/*
	 *  Position on a normal link, don't follow it. - KW
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
	    /*
	     *	It's a link in the current page. - FM
	     */
	    if (nlinks > 0 && curdoc.link > -1) {
		if (curdoc.link == newdoc.link) {
		    /*
		     *	It's the current link, and presumably
		     *	reflects a typo in the statusline entry,
		     *	so issue a statusline message for the
		     *	typo-prone users (like me 8-). - FM
		     */
		    StrAllocCopy(temp, user_input_buffer);
		    sprintf(user_input_buffer,
			    LINK_ALREADY_CURRENT, number);
		    HTUserMsg(user_input_buffer);
		    LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		    FREE(temp);
		} else {
		    /*
		     *	It's a different link on this page,
		     */
		    set_curdoc_link(newdoc.link);
		    newdoc.link = 0;
		}
	    }
	}
	break;		/* nothing more to do */

    case DO_GOTOPAGE_STUFF:
	/*
	 *  Position on a page in this document. - FM
	 */
	Newline = newdoc.line;
	newdoc.line = 1;
	if (Newline == curdoc.line) {
	    /*
	     *	It's the current page, so issue a
	     *	statusline message for the typo-prone
	     *	users (like me 8-). - FM
	     */
	    if (Newline <= 1) {
		HTInfoMsg(ALREADY_AT_BEGIN);
	    } else if (!more) {
		HTInfoMsg(ALREADY_AT_END);
	    } else {
		StrAllocCopy(temp, user_input_buffer);
		sprintf(user_input_buffer,
			ALREADY_AT_PAGE, number);
		HTUserMsg(user_input_buffer);
		LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
		FREE(temp);
	    }
	}
	break;

    case PRINT_ERROR:
	*old_c = real_c;
	HTUserMsg(BAD_LINK_NUM_ENTERED);
	break;
    }
    return;
}

#ifdef SUPPORT_CHDIR

/* original implementation by VH */
PUBLIC void handle_LYK_CHDIR NOARGS
{
    static char buf[LY_MAXPATH];
    char *p = NULL;

    if (no_chdir) {
	HTUserMsg(CHDIR_DISABLED);
	return;
    }

    _statusline(gettext("cd to:"));
    /* some people may prefer automatic clearing of the previous user input,
       here, to do this, just uncomment next line - VH */
    /* buf[0]='\0'; */
    if (LYgetstr(buf, VISIBLE, sizeof(buf)-1, 0) < 0 || !*buf) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (*buf == '~' && !buf[1]) {
	StrAllocCopy(p, Home_Dir());
    } else if (*buf == '~') {
	HTSprintf0(&p, "%s%s", Home_Dir(), buf+1);
    } else {
	StrAllocCopy(p, buf);
    }

    CTRACE((tfp, "changing directory to '%s'\n", p));
    if (chdir(p)) {
	switch (errno) {
	case EACCES:
	    HTInfoMsg(COULD_NOT_ACCESS_DIR);
	    break;
	case ENOENT:
	    HTInfoMsg(gettext("No such directory"));
	    break;
	case ENOTDIR:
	    HTInfoMsg(gettext("A component of path is not a directory"));
	    break;
	default:
	    HTInfoMsg(gettext("failed to change directory"));
	    break;
	}
    } else {
#ifdef DIRED_SUPPORT
	/*if in dired, load content of other directory*/
	if (!no_dired_support
	 && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
	    char buf2[LY_MAXPATH];
	    char* addr = NULL;

	    Current_Dir(buf2);
	    LYLocalFileToURL(&addr, buf2);

	    newdoc.address = addr;
	    newdoc.isHEAD = FALSE;
	    StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    /**force_load = TRUE;*/
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
	    }
	} else
#endif
	    HTInfoMsg(OPERATION_DONE);
    }
    FREE(p);
}
#endif

#ifdef USE_CURSES_PADS
/*
 * Having jumps larger than this is counter-productive.  Indeed, it is natural
 * to expect that when the relevant text appears, one would "overshoot" and
 * would scroll 3-4 extra full screens.  When going back, the "accumulation"
 * logic would again start moving in full screens, so one would overshoot
 * again, etc.
 * 
 * Going back, one can fix it in 28 keypresses. The relevant text will appear
 * on the screen soon enough for the key-repeat to become not that important,
 * and we are still moving in smaller steps than when we overshot.  Since key
 * repeat is not important, even if we overshoot again, it is going to be by 30
 * steps, which is easy to fix by reversing the direction again.
 */
PRIVATE int repeat_to_delta ARGS1(int, n)
{
    int threshold = LYcols / 3;

    while (threshold > 0) {
	if (n >= threshold) {
	    n = threshold;
	    break;
	}
	threshold = (threshold * 2) / 3;
    }
    return n;
}

PRIVATE void handle_LYK_SHIFT_LEFT ARGS2(BOOLEAN *, flag, int, count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    if (LYshiftWin > 0) {
	LYshiftWin -= repeat_to_delta(count);
	*flag = TRUE;
    }
    if (LYshiftWin < 0)
	LYshiftWin = 0;
}

PRIVATE void handle_LYK_SHIFT_RIGHT ARGS2(BOOLEAN *, flag, int, count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    LYshiftWin += repeat_to_delta(count);
    *flag = TRUE;
}

PRIVATE BOOLEAN handle_LYK_LINEWRAP_TOGGLE ARGS2(
    int *,	cmd,
    BOOLEAN *,	flag)
{
    static char *choices[] = {
	"Try to fit screen width",
	"No line wrap in columns",
	"Wrap columns at screen width",
	"Wrap columns at 3/4 screen width",
	"Wrap columns at 2/3 screen width",
	"Wrap columns at 1/2 screen width",
	"Wrap columns at 1/3 screen width",
	"Wrap columns at 1/4 screen width",
	NULL
    };
    static int wrap[] = {
	0,
	0,
	12,				/* In units of 1/12 */
	9,
	8,
	6,
	4,
	3
    };
    int c;

    if (LYwin == stdscr)
	return FALSE;

    /* Somehow the mouse is over the number instead of being over the
       name, so we decrease x. */
    c = LYChoosePopup(!LYwideLines, LYlines /2 - 2, LYcols/2-6,
		      choices, TABLESIZE(choices) - 1, FALSE, TRUE);
    /*
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
     */
    if (term_options)
	return FALSE;
    LYwideLines = c;
    LYtableCols = wrap[c];

    if (LYwideLines == 0)
	LYshiftWin = 0;
    *flag = TRUE;
    HTUserMsg(LYwideLines ? LINEWRAP_OFF : LINEWRAP_ON);
    return reparse_or_reload(cmd);
}
#endif

/*
 *  Here's where we do all the work.
 *  mainloop is basically just a big switch dependent on the users input.
 *  I have tried to offload most of the work done here to procedures to
 *  make it more modular, but this procedure still does a lot of variable
 *  manipulation.  This needs some work to make it neater. - Lou Moutilli
 *					(memoir from the original Lynx - FM)
 */

int mainloop NOARGS
{
#if defined(WIN_EX)	/* 1997/10/08 (Wed) 14:52:06 */
#undef	STRING_MAX
#define	STRING_MAX	4096
    char temp_buff[STRING_MAX];

#define	BUFF_MAX	1024
    char sjis_buff[BUFF_MAX];
#endif
    int c = 0, real_c = 0, old_c = 0, pending_form_c = -1;
    int cmd = LYK_DO_NOTHING, real_cmd = LYK_DO_NOTHING;
    int getresult;
    int arrowup = FALSE, show_help = FALSE;
    char user_input_buffer[MAX_LINE];
    CONST char *cshelpfile = NULL;
    BOOLEAN first_file = TRUE;
    BOOLEAN popped_doc = FALSE;
    BOOLEAN refresh_screen = FALSE;
    BOOLEAN force_load = FALSE;
    BOOLEAN try_internal = FALSE;
    BOOLEAN crawl_ok = FALSE;
    BOOLEAN vi_keys_flag = vi_keys;
    BOOLEAN emacs_keys_flag = emacs_keys;
    BOOLEAN trace_mode_flag = FALSE;
    BOOLEAN forced_HTML_mode = LYforce_HTML_mode;
    char cfile[128];
    FILE *cfp;
    char *cp;
    int ch, recall;
    int URLTotal;
    int URLNum;
    BOOLEAN FirstURLRecall = TRUE;
    char *temp = NULL;
    BOOLEAN ForcePush = FALSE;
    BOOLEAN override_LYresubmit_posts = FALSE;
    BOOLEAN newdoc_link_is_absolute = FALSE;
    BOOLEAN curlink_is_editable;
    BOOLEAN use_last_tfpos;
    unsigned int len;
    int i;
    int follow_col = -1, key_count = 0, last_key = 0;

/*
 *  curdoc.address contains the name of the file that is currently open.
 *  newdoc.address contains the name of the file that will soon be
 *		     opened if it exits.
 *  prev_target    contains the last search string the user searched for.
 *  newdoc.title   contains the link name that the user last chose to get
 *		     into the current link (file).
 */
    /* initialize some variables*/
    newdoc.address = NULL;
    newdoc.title = NULL;
    newdoc.post_data = NULL;
    newdoc.post_content_type = NULL;
    newdoc.bookmark = NULL;
    newdoc.internal_link = FALSE;
    curdoc.address = NULL;
    curdoc.title = NULL;
    curdoc.post_data = NULL;
    curdoc.post_content_type = NULL;
    curdoc.bookmark = NULL;
    curdoc.internal_link = FALSE;
#ifdef USE_COLOR_STYLE
    curdoc.style = NULL;
    newdoc.style = NULL;
#endif
    nhist = 0;
    user_input_buffer[(sizeof(user_input_buffer) - 1)] = '\0';
    *prev_target = '\0';
    *user_input_buffer = '\0';
#ifdef LY_FIND_LEAKS
    atexit(free_mainloop_variables);
#endif
initialize:
    StrAllocCopy(newdoc.address, startfile);
    StrAllocCopy(startrealm, startfile);
    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.line = 1;
    newdoc.link = 0;

#ifdef USE_SLANG
    if (TRACE && LYCursesON) {
	LYaddstr("\n");
	LYrefresh();
    }
#endif /* USE_SLANG */
    CTRACE((tfp, "Entering mainloop, startfile=%s\n", startfile));

    if (form_post_data) {
	StrAllocCopy(newdoc.post_data, form_post_data);
	StrAllocCopy(newdoc.post_content_type,
		     "application/x-www-form-urlencoded");
    } else if (form_get_data) {
	StrAllocCat(newdoc.address, form_get_data);
    }

    if (bookmark_start) {
	if (LYValidate) {
	    HTAlert(BOOKMARKS_DISABLED);
	    bookmark_start = FALSE;
	    goto initialize;
	} else if (traversal) {
	    HTAlert(BOOKMARKS_NOT_TRAVERSED);
	    traversal = FALSE;
	    crawl = FALSE;
	    bookmark_start = FALSE;
	    goto initialize;
	} else {
	    /*
	     *	See if a bookmark page exists.	If it does,
	     *	replace newdoc.address with its name
	     */
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL &&
		 *cp != '\0' && strcmp(cp, " ")) {
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		StrAllocCopy(startrealm, newdoc.address);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		CTRACE((tfp, "Using bookmarks=%s\n", newdoc.address));
	    } else {
		HTUserMsg(BOOKMARKS_NOT_OPEN);
		bookmark_start = FALSE;
		goto initialize;
	    }
	}
    }

    FREE(form_post_data);
    FREE(form_get_data);

    if (user_mode == NOVICE_MODE)
	display_lines = LYlines-4;
    else
	display_lines = LYlines-2;

    while (TRUE) {
#ifdef USE_COLOR_STYLE
	if (curdoc.style != NULL) force_load = TRUE;
#endif
	/*
	 *  If newdoc.address is different then curdoc.address then
	 *  we need to go out and find and load newdoc.address.
	 */
	if (LYforce_no_cache || force_load ||
	    are_different(&curdoc, &newdoc)) {

		force_load = FALSE;  /* done */
		if (TRACE && LYCursesON) {
		    LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
		    LYaddstr("\n");
#endif /* USE_SLANG */
		    LYrefresh();
		}
try_again:
		/*
		 *  Push the old file onto the history stack if we
		 *  have a current doc and a new address. - FM
		 */
		if (curdoc.address && newdoc.address) {
		    /*
		     *	Don't actually push if this is a LYNXDOWNLOAD
		     *	URL, because that returns NORMAL even if it
		     *	fails due to a spoof attempt or file access
		     *	problem, and we set the newdoc structure
		     *	elements to the curdoc structure elements
		     *	under case NORMAL.  - FM
		     */
		    if (strncmp(newdoc.address, "LYNXDOWNLOAD:", 13))
		    {
			LYpush(&curdoc, ForcePush);
		    }
		} else if (!newdoc.address) {
		    /*
		     *	If newdoc.address is empty then pop a file
		     *	and load it.  - FM
		     */
		    LYhist_prev(&newdoc);
		    popped_doc = TRUE;



#ifndef DONT_TRACK_INTERNAL_LINKS
		    /*
		    ** If curdoc had been reached via an internal
		    ** (fragment) link from what we now have just
		    ** popped into newdoc, then override non-caching in
		    ** all cases. - kw
		    */
		    if (curdoc.internal_link &&
			!are_phys_different(&curdoc, &newdoc)) {
			LYinternal_flag = TRUE;
			LYoverride_no_cache = TRUE;
			LYforce_no_cache = FALSE;
			try_internal = TRUE;
		    } else
#endif /* TRACK_INTERNAL_LINKS */
		    {
			/*
			 * Force a no_cache override unless
			 *  it's a bookmark file, or it has POST content
			 *  and LYresubmit_posts is set without safe also
			 *  set, and we are not going to another position
			 *  in the current document or restoring the previous
			 *  document due to a NOT_FOUND or NULLFILE return
			 *  value from getfile(). - FM
			 */
			if ((newdoc.bookmark != NULL) ||
			    (newdoc.post_data != NULL &&
			     !newdoc.safe &&
			     LYresubmit_posts &&
			     !override_LYresubmit_posts &&
				NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			    LYoverride_no_cache = FALSE;
			} else {
			    LYoverride_no_cache = TRUE;
			}
		    }
		}
		override_LYresubmit_posts = FALSE;

		if (HEAD_request) {
		    /*
		     *	Make SURE this is an appropriate request. - FM
		     */
		    if (newdoc.address) {
			if (LYCanDoHEAD(newdoc.address) == TRUE) {
			    newdoc.isHEAD = TRUE;
			} else if (!strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
			    if (LYCanDoHEAD(newdoc.address + 11) == TRUE) {
				StrAllocCopy(temp, newdoc.address + 11);
				FREE(newdoc.address);
				newdoc.address = temp;
				newdoc.isHEAD = TRUE;
				temp = NULL;
			    }
			}
		    }
		    try_internal = FALSE;
		    HEAD_request = FALSE;
		}

		/*
		 *  If we're getting the TRACE log and it's not new,
		 *  check whether its HText structure has been dumped,
		 *  and if so, fflush() and fclose() it to ensure it's
		 *  fully updated, and then fopen() it again. - FM
		 */
		if (LYUseTraceLog == TRUE &&
		    trace_mode_flag == FALSE &&
		    LYTraceLogFP != NULL &&
		    LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
		    DocAddress WWWDoc;
		    HTParentAnchor *tmpanchor;

		    WWWDoc.address = newdoc.address;
		    WWWDoc.post_data = newdoc.post_data;
		    WWWDoc.post_content_type = newdoc.post_content_type;
		    WWWDoc.bookmark = newdoc.bookmark;
		    WWWDoc.isHEAD = newdoc.isHEAD;
		    WWWDoc.safe = newdoc.safe;
		    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
		    if ((HText *)HTAnchor_document(tmpanchor) == NULL) {
			if (!LYReopenTracelog(&trace_mode_flag)) {
			    old_c = 0;
			    cmd = LYK_PREV_DOC;
			    goto new_cmd;
			}
		    }
		}

		LYRequestTitle = newdoc.title;
		if (newdoc.bookmark)
		    LYforce_HTML_mode = TRUE;
		if (LYValidate &&
		    startfile_ok &&
		    newdoc.address && startfile && homepage &&
		    (!strcmp(newdoc.address, startfile) ||
		     !strcmp(newdoc.address, homepage))) {
		    LYPermitURL = TRUE;
		}

		/* reset these two variables here before getfile()
		 * so they will be available in partial mode
		 * (was previously implemented in case NORMAL).
		 */
		*prev_target = '\0';	/* Reset for new coming document */
		Newline = newdoc.line;	/* set for LYGetNewline() */

#ifdef USE_PRETTYSRC
		psrc_first_tag = TRUE;
#endif
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		textfields_need_activation = textfields_activation_option;
#endif
		FREE(LYRequestReferer);
		/*
		 *  Don't send Referer if we have to load a document again
		 *  that we got from the history stack.  We don't know
		 *  any more how we originally got to that page.  Using
		 *  a Referer based on the current HTMainText could only
		 *  be right by coincidence. - kw 1999-11-01
		 */
		if (popped_doc)
		    LYNoRefererForThis = TRUE;

#ifndef DONT_TRACK_INTERNAL_LINKS
		if (try_internal) {
		    if (newdoc.address &&
			0==strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
			try_internal = FALSE;
		    } else if (curdoc.address &&
			0==strncmp(curdoc.address, "LYNXIMGMAP:", 11)) {
			try_internal = FALSE;
		    }
		}
		if (try_internal) {
		    char *hashp = strchr(newdoc.address,'#');
		    if (hashp) {
			HTFindPoundSelector(hashp+1);
		    }
		    getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		    try_internal = FALSE; /* done */
		    /* fix up newdoc.address which may have been fragment-only */
		    if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
			if (!hashp) {
			    StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
			} else {
			    StrAllocCopy(temp, HTLoadedDocumentURL());
			    StrAllocCat(temp, hashp); /* append fragment */
			    StrAllocCopy(newdoc.address, temp);
			    FREE(temp);
			}
		    }
		} else {
		    if (newdoc.internal_link && newdoc.address &&
			*newdoc.address == '#' && nhist > 0) {
			char *cp0;
			if (0==strncmp(history[nhist-1].address, "LYNXIMGMAP:", 11))
			    cp0 = history[nhist-1].address + 11;
			else
			    cp0 = history[nhist-1].address;
			StrAllocCopy(temp, cp0);
			cp0 = strchr(temp, '#');
			if (cp0)
			    *cp0 = '\0';
			StrAllocCat(temp, newdoc.address);
			FREE(newdoc.address);
			newdoc.address = temp;
			temp = NULL;
		    }
		    getresult = getfile(&newdoc);
		}
#else  /* TRACK_INTERNAL_LINKS */
		getresult = getfile(&newdoc);
#endif /* TRACK_INTERNAL_LINKS */

#ifdef INACTIVE_INPUT_STYLE_VH
		textinput_redrawn = FALSE; /* for sure */
#endif

		switch(getresult) {

		case NOT_FOUND:
		    /*
		     *	OK! can't find the file, so it must not be around now.
		     *	Do any error logging, if appropriate.
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    if (!first_file && !LYCancelledFetch) {
			/*
			 *  Do error mail sending and/or traversal
			 *  stuff.  Note that the links[] elements may
			 *  not be valid at this point, if we did call
			 *  HTuncache_current_document!   This should
			 *  not have happened for traversal, but for
			 *  sending error mail check that HTMainText
			 *  exists for this reason. - kw
			 */
			if (error_logging && nhist > 0 && !popped_doc &&
			    !LYUserSpecifiedURL &&
			    HTMainText &&
			    nlinks > 0 && curdoc.link < nlinks &&
			    strncmp(newdoc.address ? newdoc.address : "",
				    "LYNXHIST:", 9) &&
			    strncmp(newdoc.address ? newdoc.address : "",
				    "LYNXCOOKIE:", 11)) {
			    char *mail_owner = NULL;
			    if (owner_address &&
				strncasecomp(owner_address, "mailto:", 7)) {
				mail_owner = owner_address + 7;
			    }
			    /*
			     *  Email a bad link message to the owner of
			     *  the document, or to ALERTMAIL if defined,
			     *  but NOT to lynx-dev (it is rejected in
			     *  mailmsg). - FM, kw
			     */
#ifndef ALERTMAIL
			    if (mail_owner)
#endif
				mailmsg(curdoc.link,
					mail_owner,
					history[nhist-1].address,
					history[nhist-1].title);
			}
			if (traversal) {
			    FILE *ofp;

			    if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
				if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				    perror(NOOPEN_TRAV_ERR_FILE);
				    exit_immediately(EXIT_FAILURE);
				}
			    }
			    if (nhist > 0) {
				fprintf(ofp,
					"%s %s\tin %s\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target,
					history[nhist-1].address);
			    } else {
				fprintf(ofp,
					"%s %s\t\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target);
			    }
			    LYCloseOutput(ofp);
			}
		    }

		    /*
		     *	Fall through to do the NULL stuff and reload the
		     *	old file, unless the first file wasn't found or
		     *	has gone missing.
		     */
		    if (!nhist) {
			/*
			 *  If nhist = 0 then it must be the first file.
			 */
			exit_immediately_with_error_message(NOT_FOUND, first_file);
			return(EXIT_FAILURE);
		    }
		    /* FALLTHRU */

		case NULLFILE:
		    /*
		     *	Not supposed to return any file.
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    FREE(newdoc.address); /* to pop last doc */
		    FREE(newdoc.bookmark);
		    LYJumpFileURL = FALSE;
		    reloading = FALSE;
		    LYPermitURL = FALSE;
		    LYCancelledFetch = FALSE;
		    ForcePush = FALSE;
		    LYforce_HTML_mode = FALSE;
		    force_old_UCLYhndl_on_reload = FALSE;
		    if (traversal) {
			crawl_ok = FALSE;
			if (traversal_link_to_add) {
			    /*
			     *	It's a binary file, or the fetch attempt
			     *	failed.  Add it to TRAVERSE_REJECT_FILE
			     *	so we don't try again in this run.
			     */
			    if (!lookup_reject(traversal_link_to_add)) {
				add_to_reject_list(traversal_link_to_add);
			    }
			    FREE(traversal_link_to_add);
			}
		    }
		    /*
		     *  Make sure the first file was found and
		     *  has not gone missing.
		     */
		    if (!nhist) {
			/*
			 *  If nhist = 0 then it must be the first file.
			 */
			if (first_file && homepage &&
#ifdef VMS
			   strcasecomp(homepage, startfile) != 0
#else
			   strcmp(homepage, startfile) != 0
#endif /* VMS */
			   ) {
			   /*
			    *  Couldn't return to the first file but there is a
			    *  homepage we can use instead. Useful for when the
			    *  first URL causes a program to be invoked. - GL
			    *
			    *  But first make sure homepage is different from
			    *  startfile (above), then make it the same (below)
			    *  so we don't enter an infinite getfile() loop on
			    *  on failures to find the files. - FM
			    */
			   StrAllocCopy(newdoc.address, homepage);
			   FREE(newdoc.post_data);
			   FREE(newdoc.post_content_type);
			   FREE(newdoc.bookmark);
			   StrAllocCopy(startfile, homepage);
			   newdoc.isHEAD = FALSE;
			   newdoc.safe = FALSE;
			   newdoc.internal_link = FALSE;
			   goto try_again;
			} else {
			   exit_immediately_with_error_message(NULLFILE, first_file);
			   return(EXIT_FAILURE);
			}
		    }

		   /*
		    *  If we're going to pop from history because
		    *  getfile didn't succeed, reset LYforce_no_cache
		    *  first.  This would have been done in HTAccess.c
		    *  if the request got that far, but the URL may
		    *  have been handled or rejected in getfile without
		    *  taking care of that. - kw
		    */
		    LYforce_no_cache = FALSE;
		   /*
		    *  Retrieval of a newdoc just failed, and just
		    *  going to try_again would pop the next doc
		    *  from history and try to get it without further
		    *  questions.  This may not be the right thing to do if
		    *  we have POST data, so fake a PREV_DOC key if it seems
		    *  that some prompting should be done.  This doesn't
		    *  affect the traversal logic, since with traversal
		    *  POST data can never occur. - kw
		    */
		   if (history[nhist - 1].post_data &&
		       !history[nhist - 1].safe) {
		       if (HText_POSTReplyLoaded((document *)&history[(nhist - 1)])) {
			   override_LYresubmit_posts = TRUE;
			   goto try_again;
		       }
		       /*  Set newdoc fields, just in case the PREV_DOC
			*  gets cancelled. - kw */
		       if (!curdoc.address) {
			   StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
			   StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			   if (HTMainAnchor && HTMainAnchor->post_data) {
			       StrAllocCopy(newdoc.post_data,
					    HTMainAnchor->post_data);
			       StrAllocCopy(newdoc.post_content_type,
					    HTMainAnchor->post_content_type);
			   } else {
			       FREE(newdoc.post_data);
			   }
			   newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			   newdoc.safe = HTLoadedDocumentIsSafe();
			   newdoc.internal_link = FALSE;
		       } else {
			   StrAllocCopy(newdoc.address, curdoc.address);
			   StrAllocCopy(newdoc.title, curdoc.title);
			   StrAllocCopy(newdoc.post_data, curdoc.post_data);
			   StrAllocCopy(newdoc.post_content_type,
					curdoc.post_content_type);
			   newdoc.isHEAD = curdoc.isHEAD;
			   newdoc.safe = curdoc.safe;
			   newdoc.internal_link = curdoc.internal_link;
			   newdoc.line = curdoc.line;
			   newdoc.link = curdoc.link;
		       }
		       cmd = LYK_PREV_DOC;
		       goto new_cmd;
		    }
		    override_LYresubmit_posts = TRUE;
		    goto try_again;

		case NORMAL:
		    /*
		     *	Marvelously, we got the document!
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);

		    /*
		     *	If it's the first file and we're interactive,
		     *	check whether it's a bookmark file which was
		     *	not accessed via the -book switch. - FM
		     */
		    if (((first_file == TRUE) &&
			 (dump_output_immediately == FALSE) &&
			 !(newdoc.bookmark && *newdoc.bookmark)) &&
			((LYisLocalFile(newdoc.address) == TRUE) &&
			 !(strcmp((HText_getTitle() ? HText_getTitle() : ""),
				  BOOKMARK_TITLE))) &&
			(temp = HTParse(newdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION)) != NULL) {
			cp = wwwName(Home_Dir());
			len = strlen(cp);
#ifdef VMS
			if (!strncasecomp(temp, cp, len) &&
			    strlen(temp) > len)
#else
			if (!strncmp(temp, cp, len) &&
			    strlen(temp) > len)
#endif /* VMS */
			{
			    /*
			     *	We're interactive and this might be a
			     *	bookmark file entered as a startfile
			     *	rather than invoked via -book.	Check
			     *	if it's in our bookmark file list, and
			     *	if so, reload if with the relevant
			     *	bookmark elements set. - FM
			     */
			    cp = NULL;
			    if (temp[len] == '/') {
				if (strchr(&temp[(len + 1)], '/')) {
				    HTSprintf0(&cp, ".%s", &temp[len]);
				} else {
				    StrAllocCopy(cp, &temp[(len + 1)]);
				}
			    } else {
				StrAllocCopy(cp, &temp[len]);
			    }
#ifdef VMS
#define CompareBookmark(a,b) strcasecomp(a, b)
#else
#define CompareBookmark(a,b) strcmp(a, b)
#endif /* VMS */
			    for (i = 0; i <= MBM_V_MAXFILES; i++) {
				if (MBM_A_subbookmark[i] &&
				    !CompareBookmark(cp, MBM_A_subbookmark[i])) {
				    StrAllocCopy(BookmarkPage,
						 MBM_A_subbookmark[i]);
				    break;
				}
			    }
			    FREE(cp);
			    if (i <= MBM_V_MAXFILES) {
				FREE(temp);
				if (LYValidate) {
				    HTAlert(BOOKMARKS_DISABLED);
				    return(EXIT_FAILURE);
				}
				if ((temp = HTParse(newdoc.address, "",
				 PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION))) {
				    StrAllocCopy(newdoc.address, temp);
				    HTuncache_current_document();
				    FREE(curdoc.address);
				    StrAllocCat(newdoc.address,
					    wwwName(Home_Dir()));
				    StrAllocCat(newdoc.address, "/");
				    StrAllocCat(newdoc.address,
					(strncmp(BookmarkPage, "./", 2) ?
							   BookmarkPage :
							(BookmarkPage + 2)));
				    StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				    StrAllocCopy(newdoc.bookmark, BookmarkPage);
#ifdef USE_COLOR_STYLE
				    if (curdoc.style)
					StrAllocCopy(newdoc.style, curdoc.style);
#endif
				    StrAllocCopy(startrealm, newdoc.address);
				    FREE(newdoc.post_data);
				    FREE(newdoc.post_content_type);
				    newdoc.isHEAD = FALSE;
				    newdoc.safe = FALSE;
				    FREE(temp);
				    if (!strcmp(homepage, startfile))
					StrAllocCopy(homepage, newdoc.address);
				    StrAllocCopy(startfile, newdoc.address);
				    CTRACE((tfp, "Reloading as bookmarks=%s\n",
						newdoc.address));
				    goto try_again;
				}
			    }
			}
			cp = NULL;
		    }
		    FREE(temp);

		    if (traversal) {
			/*
			 *  During traversal build up lists of all links
			 *  traversed.	Traversal mode is a special
			 *  feature for traversing http links in the web.
			 */
			if (traversal_link_to_add) {
			    /*
			     *	Add the address we sought to TRAVERSE_FILE.
			     */
			    if (!lookup(traversal_link_to_add))
				add_to_table(traversal_link_to_add);
			    FREE(traversal_link_to_add);
			}
			if (curdoc.address && curdoc.title &&
			    strncmp(curdoc.address, "LYNXIMGMAP:", 11))
			    /*
			     *	Add the address we got to TRAVERSE_FOUND_FILE.
			     */
			    add_to_traverse_list(curdoc.address, curdoc.title);
d2222 21
d2244 14
a2257 14
		    /*
		     *	If this was a LYNXDOWNLOAD, we still have curdoc,
		     *	not a newdoc, so reset the address, title and
		     *	positioning elements. - FM
		     */
		    if (newdoc.address && curdoc.address &&
			!strncmp(newdoc.address, "LYNXDOWNLOAD:", 13)) {
			StrAllocCopy(newdoc.address, curdoc.address);
			StrAllocCopy(newdoc.title, (curdoc.title ?
						    curdoc.title : ""));
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
			newdoc.internal_link = FALSE; /* can't be true. - kw */
d2259 35
d2295 9
a2303 24
		    /*
		     *	Set Newline to the saved line.	It contains the
		     *	line the user was on if s/he has been in the file
		     *	before, or it is 1 if this is a new file.
		     *
		     * We already set Newline before getfile() and probably
		     * update it explicitly if popping from the history stack
		     * via LYpop() or LYpop_num() within getfile() cycle.
		     *
		     * In partial mode, Newline was probably updated in
		     * LYMainLoop_pageDisplay() if user scrolled
		     * the document while loading.
		     * Incremental loading stage already closed in HT*Copy().
		     */
#ifdef DISP_PARTIAL
		    /* Newline = newdoc.line; */
		    display_partial = FALSE; /* for sure, LYNXfoo:/ may be a problem */
#else
		    /* Should not be needed either if we remove
		     * "DISP_PARTIAL" from LYHistory.c, but lets leave it
		     * as an important comment for now.
		     */
		    Newline = newdoc.line;
#endif
d2305 7
a2311 7
		    /*
		     *	If we are going to a target line or
		     *	the first page of a popped document,
		     *	override any www_search line result.
		     */
		    if (Newline > 1 || popped_doc == TRUE)
			 www_search_result = -1;
d2313 10
a2322 7
		    /*
		     *	Make sure curdoc.line will not be equal
		     *	to Newline, so we get a redraw.
		     */
		    curdoc.line = -1;
		    break;
		}  /* end switch */
d2324 15
a2338 3
	    if (TRACE) {
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert(); /* allow me to look at the results */
d2340 4
d2345 1
d2347 25
d2373 2
a2374 1
	     *	Set the files the same.
d2376 6
a2381 11
	    StrAllocCopy(curdoc.address, newdoc.address);
	    StrAllocCopy(curdoc.post_data, newdoc.post_data);
	    StrAllocCopy(curdoc.post_content_type, newdoc.post_content_type);
	    StrAllocCopy(curdoc.bookmark, newdoc.bookmark);
#ifdef USE_COLOR_STYLE
	    StrAllocCopy(curdoc.style, HText_getStyle());
	    if (curdoc.style != NULL)
		style_readFromFile (curdoc.style);
#endif
	    curdoc.isHEAD = newdoc.isHEAD;
	    curdoc.internal_link = newdoc.internal_link;
d2383 3
a2385 23
	    /*
	     *	Set the remaining document elements and add to
	     *	the visited links list. - FM
	     */
	    if (ownerS_address != NULL) {
#ifndef USE_PRETTYSRC
		if (HTOutputFormat == WWW_SOURCE && !HText_getOwner())
#else
		if ( (LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
			&& !HText_getOwner() )
#endif
		    HText_setMainTextOwner(ownerS_address);
		FREE(ownerS_address);
	    }
	    if (HText_getTitle()) {
		StrAllocCopy(curdoc.title, HText_getTitle());
	    } else if (!dump_output_immediately) {
		StrAllocCopy(curdoc.title, newdoc.title);
	    }
	    StrAllocCopy(owner_address, HText_getOwner());
	    curdoc.safe = HTLoadedDocumentIsSafe();
	    if (!dump_output_immediately) {
		LYAddVisitedLink(&curdoc);
d2387 1
d2389 4
d2394 37
a2430 8
	   /*
	    *  Reset WWW present mode so that if we were getting
	    *  the source, we get rendered HTML from now on.
	    */
	   HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	   psrc_view = FALSE;
#endif
d2432 7
a2438 16
	   HTMLSetCharacterHandling(current_char_set);	/* restore, for sure? */

	   /*
	    *  Reset all of the other relevant flags. - FM
	    */
	   LYUserSpecifiedURL = FALSE;	/* only set for goto's and jumps's */
	   LYJumpFileURL = FALSE;	/* only set for jump's */
	   LYNoRefererForThis = FALSE;	/* always reset on return here */
	   reloading = FALSE;		/* set for RELOAD and NOCACHE keys */
	   HEAD_request = FALSE;	/* only set for HEAD requests */
	   LYPermitURL = FALSE;		/* only for LYValidate or check_realm */
	   ForcePush = FALSE;		/* only set for some PRINT requests. */
	   LYforce_HTML_mode = FALSE;
	   force_old_UCLYhndl_on_reload = FALSE;
	   popped_doc = FALSE;
	   pending_form_c = -1;
d2440 10
a2449 7
	} /* end if (LYforce_no_cache || force_load || are_different(...)) */

	if (dump_output_immediately) {
	    if (crawl) {
		print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
	    } else {
		print_wwwfile_to_fd(stdout, FALSE);
d2451 1
a2451 1
	    return(EXIT_SUCCESS);
d2453 98
d2552 3
a2554 35
	/*
	 *  If the recent_sizechange variable is set to TRUE
	 *  then the window size changed recently.
	 */
	if (recent_sizechange) {
	    /*
	     *  First we need to make sure the display library - curses, slang,
	     *  whatever - gets notified about the change, and gets a chance
	     *  to update external structures appropriately.  Hopefully the
	     *  stop_curses()/start_curses() sequence achieves this, at least
	     *  if the display library has a way to get the new screen size
	     *  from the OS.
	     *  However, at least for ncurses, the update of the internal
	     *  structures will come still too late - the changed screen
	     *  size is detected in doupdate(), which would only be called
	     *  (indirectly through the HText_pageDisplay below) after the
	     *  WINDOW structures are already filled based on the old size.
	     *  So we notify the ncurses library directly here. - kw
	     */
#if defined(NCURSES) && defined(HAVE_RESIZETERM) && defined(HAVE_WRESIZE)
	    resizeterm(LYlines, LYcols);
	    wresize(LYwin, LYlines, LYcols);
#else
	    stop_curses();
	    start_curses();
	    LYclear();
#endif
	    refresh_screen = TRUE; /* to force a redraw */
	    if (HTMainText)	/* to REALLY force it... - kw */
		HText_setStale(HTMainText);
	    recent_sizechange = FALSE;
	    if (user_mode == NOVICE_MODE) {
		display_lines = LYlines-4;
	    } else {
		display_lines = LYlines-2;
d2556 1
d2559 28
a2586 8
	if (www_search_result != -1) {
	     /*
	      *  This was a WWW search, set the line
	      *  to the result of the search.
	      */
	     Newline = www_search_result;
	     www_search_result = -1;  /* reset */
	}
d2588 1
a2588 1
	if (first_file == TRUE) {
d2590 2
a2591 1
	     *	We can never again have the first file.
d2593 33
a2625 1
	    first_file = FALSE;
d2627 17
d2645 2
a2646 3
	     *	Set the startrealm, and deal as best we can
	     *	with preserving forced HTML mode for a local
	     *	startfile. - FM
d2648 32
a2679 30
	    temp = HTParse(curdoc.address, "",
			   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
	    if (!temp || *temp == '\0') {
		StrAllocCopy(startrealm, NO_NOTHING);
	    } else {
		StrAllocCopy(startrealm, temp);
		FREE(temp);
		if (!(temp = HTParse(curdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION))) {
		    LYAddHtmlSep(&startrealm);
		} else {
		    if (forced_HTML_mode &&
			!dump_output_immediately &&
			!curdoc.bookmark &&
			!strncasecomp(curdoc.address, "file:", 5) &&
			strlen(temp) > 1) {
			/*
			 *  We forced HTML for a local startfile which
			 *  is not a bookmark file and has a path of at
			 *  least two letters.	If it doesn't have a
			 *  suffix mapped to text/html, we'll set the
			 *  entire path (including the lead slash) as a
			 *  "suffix" mapped to text/html to ensure it is
			 *  always treated as an HTML source file.  We
			 *  are counting on a tail match to this full path
			 *  for some other URL fetched during the session
			 *  having too low a probability to worry about,
			 *  but it could happen. - FM
			 */
			HTAtom *encoding;
d2681 16
a2696 8
			if (HTFileFormat(temp, &encoding, NULL) != WWW_HTML) {
			    HTSetSuffix(temp, "text/html", "8bit", 1.0);
			}
		    }
		    if ((cp = strrchr(temp, '/')) != NULL) {
			*(cp+1) = '\0';
			StrAllocCat(startrealm, temp);
		    }
d2698 6
d2705 4
a2708 3
	    FREE(temp);
	    CTRACE((tfp, "Starting realm is '%s'\n\n", startrealm));
	    if (traversal) {
d2710 5
a2714 1
		 *  Set up the crawl output stuff.
d2716 6
a2721 4
		if (curdoc.address && !lookup(curdoc.address)) {
		    if (strncmp(curdoc.address, "LYNXIMGMAP:", 11))
			crawl_ok = TRUE;
		    add_to_table(curdoc.address);
d2723 2
d2726 1
a2726 1
		 *  Set up the traversal_host comparison string.
d2728 98
a2825 10
		if (strncmp((curdoc.address ? curdoc.address : "NULL"),
			    "http", 4)) {
		    StrAllocCopy(traversal_host, NO_NOTHING);
		} else if (check_realm) {
		    StrAllocCopy(traversal_host, startrealm);
		} else {
		    temp = HTParse(curdoc.address, "",
				   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
		    if (!temp || *temp == '\0') {
			StrAllocCopy(traversal_host, NO_NOTHING);
d2827 9
a2835 2
			StrAllocCopy(traversal_host, temp);
			LYAddHtmlSep(&traversal_host);
a2836 1
		    FREE(temp);
d2838 4
a2841 10
		CTRACE((tfp, "Traversal host is '%s'\n\n", traversal_host));
	    }
	    if (startfile) {
		/*
		 *  If homepage was not equated to startfile,
		 *  make the homepage URL the first goto
		 *  entry. - FM
		 */
		if (homepage && strcmp(startfile, homepage))
		    HTAddGotoURL(homepage);
d2843 1
a2843 4
		 *  If we are not starting up with startfile
		 *  (e.g., had -book), or if we are using the
		 *  startfile and it has no POST content, make
		 *  the startfile URL a goto entry. - FM
d2845 11
a2855 3
		if (strcmp(startfile, newdoc.address) ||
		    newdoc.post_data == NULL)
		    HTAddGotoURL(startfile);
d2857 15
a2871 4
	    if (TRACE) {
		refresh_screen = TRUE;
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();
d2873 8
d2882 233
a3114 15
	}

#ifdef SOURCE_CACHE
	/*
	 * If the parse settings have changed since this HText was
	 * generated, we need to reparse and redraw it.  -dsb
	 *
	 * Should be configured to avoid shock for experienced lynx users.
	 * Currently enabled for cached sources only.
	 */
	if (HTdocument_settings_changed()) {
	   if (HTcan_reparse_document()) {
		HTInfoMsg(gettext("Reparsing document under current settings..."));
		reparse_document();
	   } else {
d3116 139
a3254 28
		 * Urk.  I have no idea how to recover from a failure here.
		 * At a guess, I'll try reloading.  -dsb
		 */
			/*  currently disabled ***
		HTUserMsg(gettext("Reparsing document under current settings..."));
		cmd = LYK_RELOAD;
		goto new_cmd;
			*/
	    }
	}

	if (from_source_cache) {
	    from_source_cache = FALSE; /* reset */
	    curdoc.line = -1 ;  /* so curdoc.line != Newline, see below */
	}
#endif

	/*
	 *  If the curdoc.line is different than Newline then there must
	 *  have been a change since last update.  Run HText_pageDisplay()
	 *  create a fresh screen of text out.
	 *
	 *  If we got new HTMainText go this way.
	 *  All display_partial calls ends here for final redraw.
	 */
	if (curdoc.line != Newline) {
#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;
a3256 4
	    refresh_screen = FALSE;

	    HText_pageDisplay(Newline, prev_target);

d3258 10
a3267 2
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
	      showtags(tagged);
d3269 6
d3276 2
a3277 7
	    /*
	     *  If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();
	    curdoc.line = Newline = HText_getTopOfScreen()+1;

	    if (curdoc.title == NULL) {
d3279 1
a3279 2
		 *  If we don't yet have a title, try to get it,
		 *  or set to that for newdoc.title. - FM
d3281 3
a3283 4
		if (HText_getTitle()) {
		    StrAllocCopy(curdoc.title, HText_getTitle());
		} else {
		    StrAllocCopy(curdoc.title, newdoc.title);
d3285 1
d3287 14
a3300 10

	    /*
	     *	If the request is to highlight a link which is counted
	     *  from the start of document, correct the link number:
	     */
	    if (newdoc_link_is_absolute) {
		newdoc_link_is_absolute = FALSE;
		if (curdoc.line > 1)
		    newdoc.link -= HText_LinksInLines(HTMainText, 1,
						      curdoc.line - 1);
d3302 3
a3304 2

	    if (arrowup) {
d3306 1
a3306 2
		 *  arrowup is set if we just came up from
		 *  a page below.
d3308 3
a3310 16
		curdoc.link = nlinks - 1;
		arrowup = FALSE;
	    } else {
		curdoc.link = newdoc.link;
		if (curdoc.link >= nlinks) {
		    curdoc.link = nlinks - 1;
		} else if (curdoc.link < 0 && nlinks > 0) {
		    /*
		     *	We may have popped a doc (possibly in local_dired)
		     *	which didn't have any links when it was pushed, but
		     *	does have links now (e.g., a file was created).
		     *  Code below assumes that curdoc.link is valid and
		     *  that (curdoc.link==-1) only occurs if (nlinks==0)
		     *  is true. - KW
		     */
		    curdoc.link = 0;
d3312 1
d3314 20
a3333 16

	    show_help = FALSE; /* reset */
	    newdoc.line = 1;
	    newdoc.link = 0;
	    curdoc.line = Newline; /* set */
	}

	/*
	 *  Refresh the screen if necessary.
	 */
	if (refresh_screen) {
#if defined(FANCY_CURSES) || defined (USE_SLANG)
	    if (enable_scrollback) {
		LYclear();
	    } else {
		LYerase();
a3334 8
#else
	    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
	   HText_pageDisplay(Newline, prev_target);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
d3338 2
a3339 1
	     *  If more equals TRUE, then there is more info below this page.
d3341 23
a3363 2
	    more = HText_canScrollDown();

d3365 2
a3366 6
	     *  Adjust curdoc.link as above; nlinks may have changed,
	     *  if the refresh_screen flag was set as a result of
	     *  a size change.
	     *  Code below assumes that curdoc.link is valid and
	     *  that (curdoc.link==-1) only occurs if (nlinks==0)
	     *  is true. - kw
d3368 4
a3371 5
	    if (curdoc.link >= nlinks) {
		curdoc.link = nlinks - 1;
	    } else if (curdoc.link < 0 && nlinks > 0) {
		curdoc.link = 0;
	    }
d3373 8
a3380 78
	    if (user_mode == NOVICE_MODE)
		noviceline(more);  /* print help message */
	    refresh_screen = FALSE;

	}

	curlink_is_editable =
	    (nlinks > 0 &&
	     links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     (links[curdoc.link].form->type == F_TEXT_TYPE ||
	      links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE ||
	      links[curdoc.link].form->type == F_PASSWORD_TYPE ||
	      links[curdoc.link].form->type == F_TEXTAREA_TYPE));

	use_last_tfpos = (curlink_is_editable &&
			  (real_cmd == LYK_LPOS_PREV_LINK ||
			   real_cmd == LYK_LPOS_NEXT_LINK));

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (!textfields_need_activation)
	    textinput_activated = TRUE;
#endif

#if defined(WIN_EX)			/* 1997/10/08 (Wed) 14:52:06 */
	if (nlinks > 0) {
	    char *p = "LYNX (unknown link type)";

	    /* Show the URL & kanji code . */
	    if (strlen(links[curdoc.link].lname) == 0) {

	       if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {

		    switch(links[curdoc.link].form->type) {
		    case F_TEXT_SUBMIT_TYPE:
		    case F_SUBMIT_TYPE:
		    case F_IMAGE_SUBMIT_TYPE:
			p = "[SUBMIT]";
			break;
		    case F_PASSWORD_TYPE:
			p = "Password";
			break;
		    case F_OPTION_LIST_TYPE:
			p = "Option list";
			break;
		    case F_CHECKBOX_TYPE:
			p = "Check box";
			break;
		    case F_RADIO_TYPE:
			p = "[Radio]";
			break;
		    case F_RESET_TYPE:
			p = "[Reset]";
			break;
		    case F_TEXT_TYPE:
			p = "Text input";
			break;
		    case F_TEXTAREA_TYPE:
			p = "Text input lines";
			break;
		    default:
			break;
		    }
		    set_ws_title(p);
	       }
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    p = curdoc.title;
		} else {
		    p = links[curdoc.link].lname;
		}

		if (strlen(p) < 500) {
		    strcpy(temp_buff, p);
		    if (strchr(temp_buff, '%')) {
			HTUnEscape(temp_buff);
		    }
		    str_sjis(sjis_buff, temp_buff);
		    set_ws_title(LYElideString(sjis_buff, 10));
d3382 1
d3384 16
a3399 6
	} else {
	    if (strlen(curdoc.address) < sizeof(temp_buff)-1) {
		if (user_mode == ADVANCED_MODE) {
		    str_sjis(temp_buff, curdoc.title);
		} else {
		    strcpy(temp_buff, curdoc.address);
d3401 1
a3401 1
		set_ws_title(HTUnEscape(temp_buff));
d3403 1
a3403 2
	}
#endif /* WIN_EX */
d3405 8
a3412 5
	/*
	 *  Report unread or new mail, if appropriate.
	 */
	if (check_mail && !no_mail)
	    LYCheckMail();
d3414 6
a3419 26
	/*
	 *  If help is not on the screen,
	 *  then put a message on the screen
	 *  to tell the user other misc info.
	 */
	if (!show_help) {
	   show_main_statusline(links[curdoc.link],
				(curlink_is_editable && textinput_activated) ?
				FOR_INPUT : FOR_PANEL);
	} else {
	   show_help = FALSE;
	}

	if (nlinks > 0) {
	     /*
	      *  Highlight current link, unless it is an active
	      *  text input field.
	      */
	    if (!curlink_is_editable) {
		highlight(ON, curdoc.link, prev_target);
#ifndef INACTIVE_INPUT_STYLE_VH
	    } else if (!textinput_activated) {
		highlight(ON, curdoc.link, prev_target);
#endif
	    }
	}
a3420 1
	if (traversal) {
d3422 1
a3422 2
	     *	Don't go interactively into forms,
	     *	or accept keystrokes from the user
d3424 8
a3431 26
	    if (crawl && crawl_ok) {
		crawl_ok = FALSE;
#ifdef FNAMES_8_3
		sprintf(cfile,"lnk%05d.dat",ccount);
#else
		sprintf(cfile,"lnk%08d.dat",ccount);
#endif /* FNAMES_8_3 */
		ccount = ccount + 1;
		if ((cfp = LYNewTxtFile(cfile))  != NULL) {
		    print_crawl_to_fd(cfp,curdoc.address,curdoc.title);
		    LYCloseOutput(cfp);
		} else {
		    if (!dump_output_immediately)
			cleanup();
#ifdef UNIX
		    if (dump_output_immediately)
			fprintf(stderr,
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    else
#endif
			printf(
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    if (!dump_output_immediately) {
			exit_immediately(EXIT_FAILURE);
		    }
		    return(EXIT_FAILURE);
a3433 1
	} else {
d3435 2
a3436 1
	     *	Normal, non-traversal handling.
d3438 4
d3443 5
a3447 17
	    if (curlink_is_editable &&
		(textinput_activated || pending_form_c != -1)) {
		if (pending_form_c != -1) {
		    real_c = pending_form_c;
		    pending_form_c = -1;
		} else {
		    /*
		     *  Replace novice lines if in NOVICE_MODE.
		     */
		    if (user_mode==NOVICE_MODE) {
			form_noviceline(links[curdoc.link].form->disabled);
		    }
		    real_c = change_form_link(&links[curdoc.link],
				     &newdoc, &refresh_screen,
				     links[curdoc.link].form->name,
					  links[curdoc.link].form->value,
					  use_last_tfpos, FALSE);
d3449 2
a3450 7
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation)
		    textinput_activated = FALSE;
#ifdef INACTIVE_INPUT_STYLE_VH
		textinput_redrawn = FALSE;
#endif
#endif
d3452 14
a3465 115
		c = (real_c==LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
		if (c != DO_NOTHING &&
		    peek_mouse_link() != -1 && peek_mouse_link() != -2)
		    old_c = 0;
		if (peek_mouse_link() >= 0 &&
		    LKC_TO_LAC(keymap,real_c) != LYK_CHANGE_LINK) {
		    do_change_link();
		    if ((c == '\n' || c == '\r') &&
			links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			F_TEXTLIKE(links[curdoc.link].form->type) &&
			!textfields_need_activation) {
			c = DO_NOTHING;
		    }
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		} else if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			    links[curdoc.link].form->type == F_TEXTAREA_TYPE)
			   && textfields_need_activation
			   && !links[curdoc.link].form->disabled
			   && peek_mouse_link() < 0 &&
			   (((LKC_TO_LAC(keymap,real_c) == LYK_NEXT_LINK ||
#ifdef TEXTAREA_AUTOGROW
			      LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE ||
#endif
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks-1 &&
			       links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link+1].form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].form->number ==
				   links[curdoc.link+1].form->number) &&
			       strcmp(links[curdoc.link].form->name,
				      links[curdoc.link+1].form->name) == 0) ||
			      (curdoc.link == nlinks-1 && more &&
			       HText_TAHasMoreLines(curdoc.link, 1)))) ||
			    ((LKC_TO_LAC(keymap,real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_UP_LINK) &&
			     ((curdoc.link > 0 &&
			       links[curdoc.link-1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link-1].form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].form->number ==
				   links[curdoc.link-1].form->number) &&
			       strcmp(links[curdoc.link].form->name,
				      links[curdoc.link-1].form->name) == 0) ||
			      (curdoc.link == 0 && curdoc.line > 1 &&
			       HText_TAHasMoreLines(curdoc.link, -1)))))) {
		    textinput_activated = TRUE;
#ifdef TEXTAREA_AUTOGROW
		    if ((c == '\n' || c == '\r') &&
			LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE)
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
#endif /* TEXTAREA_AUTOGROW */
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION */
		} else
		    switch (c) {
		    case '\n':
		    case '\r':
#ifdef TEXTAREA_AUTOGROW
		    /*
		     *  If on the bottom line of a TEXTAREA, and the user hit
		     *  the ENTER key, we add a new line/anchor automatically,
		     *  positioning the cursor on it.
		     *
		     *  If at the bottom of the screen, we effectively perform
		     *  an LYK_DOWN_HALF-like operation, then move down to the
		     *  new line we just added.  --KED  02/14/99
		     *
		     *  [There is some redundancy and non-standard indentation
		     *   in the monster-if() below.  This is intentional ... to
		     *   try and improve the "readability" (such as it is).
		     *   Caveat emptor to anyone trying to change it.]
		     */
		    if ((links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
			 links[curdoc.link].form->type == F_TEXTAREA_TYPE) &&
			((curdoc.link == nlinks-1 &&
			  !(more && HText_TAHasMoreLines(curdoc.link, 1)))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  !(links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  ((links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE)
			    &&
			    ((links[curdoc.link].form->number	       !=
				      links[curdoc.link+1].form->number)     ||
			     (strcmp (links[curdoc.link].form->name,
				      links[curdoc.link+1].form->name) != 0)))))) {

			HText_ExpandTextarea (&links[curdoc.link], 1);

			if (links[curdoc.link].ly < display_lines) {
			    refresh_screen = TRUE;

			} else {

			    Newline += (display_lines/2);
			    if (nlinks > 0 && curdoc.link > -1 &&
				links[curdoc.link].ly > display_lines/2) {
				    newdoc.link = curdoc.link;
				    for (i = 0; links[i].ly <= (display_lines/2); i++)
					--newdoc.link;
				    newdoc.link++;
			    }
			}
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			if (textfields_need_activation) {
			    textinput_activated = TRUE;
			    textfields_need_activation = textfields_activation_option;
#ifdef INACTIVE_INPUT_STYLE_VH
			    textinput_redrawn = TRUE;
#endif
			};
#endif
d3467 15
a3481 2
		   }
#endif /* TEXTAREA_AUTOGROW */
d3483 14
d3498 1
a3498 4
		     *	Make return in input field (if it was returned
		     *  by change_form_link) act as LYK_NEXT_LINK,
		     *  independent of what key (if any) is mapped to
		     *  LYK_NEXT_LINK. - kw
d3500 7
a3506 6
		    c = LAC_TO_LKC0(LYK_NEXT_LINK);
		    break;
		default:

		    if (old_c != c && old_c != real_c && c != real_c)
			real_c = c;
d3508 14
a3521 14
	    } else {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
		if (curlink_is_editable && !textinput_redrawn) {
		/*draw the text entry, but don't activate it*/
		    textinput_redrawn = TRUE;
		    change_form_link_ex(&links[curdoc.link],
				    &newdoc, &refresh_screen,
				    links[curdoc.link].form->name,
				    links[curdoc.link].form->value,
				    use_last_tfpos, FALSE, TRUE);
		    if (LYShowCursor) {
			LYmove(links[curdoc.link].ly,
			     ((links[curdoc.link].lx > 0) ?
			      (links[curdoc.link].lx - 1) : 0));
d3523 1
a3523 1
			LYHideCursor();
d3525 13
d3539 8
a3546 14
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
		/*
		 *  Get a keystroke from the user.
		 *  Save the last keystroke to avoid
		 *  redundant error reporting.
		 */
		real_c = c = LYgetch(); /* get user input */

		if (c != last_key)
		    key_count = 0;
		key_count++;
		last_key = c;
#ifndef VMS
		if (c == 3) {		/* ^C */
d3548 1
a3548 2
		     *	This shouldn't happen.	We'll try to
		     *	deal with whatever bug caused it. - FM
d3550 1
a3550 4
		    signal(SIGINT, cleanup_sig);
		    old_c = 0;
		    cmd = LYK_QUIT;
		    goto new_cmd;
d3552 1
a3552 2
#endif /* !VMS */
		if (LKC_HAS_ESC_MOD(c) && EditBinding(c) != LYE_FORM_PASS) {
d3554 1
a3554 8
		     *  If ESC + <key> was read (and not recognized as a
		     *  terminal escape sequence for another key), ignore
		     *  the ESC modifier and act on <key> only if the line
		     *  editor binding would have passed the same ESC-modified
		     *  lynxkeycode back to us if it had been pressed in a
		     *  text input field.  Otherwise set interesting part
		     *  so that it will map to 0, to prevent that ESC + <key>
		     *  acts like <key>, which might be unexpected. - kw
d3556 26
a3581 1
		    c = (c & ~LKC_MASK) | LAC_TO_LKC(0);
d3583 10
a3592 2
		if (old_c != real_c) {
		    old_c = 0;
d3594 1
d3596 12
a3607 1
	}
d3609 7
a3615 11
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = DO_NOTHING;
	}
#else
	if (recent_sizechange) {
	    if (c <= 0)
		c = DO_NOTHING;
	}
#endif /* VMS */
d3617 44
a3660 9
new_keyboard_input:
	/*
	 *  A goto point for new input without going
	 *  back through the getch() loop.
	 */
	if (traversal) {
	    if ((c = DoTraversal(c, &crawl_ok)) < 0)
		return (EXIT_FAILURE);
	} /* traversal */
d3662 8
a3669 4
#ifdef WIN_EX
	if (c == DO_NOTHING)
	    cmd = LYK_DO_NOTHING;
	else
a3670 1
	cmd = LKC_TO_LAC(keymap,c);  /* adds 1 to map EOF to 0 */
d3672 30
a3701 4
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override,c))
	  cmd = LKC_TO_LAC(key_override,c);
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
d3703 27
a3729 1
	real_cmd = cmd;
d3731 18
a3748 4
new_cmd:  /*
	   *  A goto point for new input without going
	   *  back through the getch() loop.
	   */
d3750 5
a3754 2
	force_old_UCLYhndl_on_reload = FALSE;
	CTRACE_FLUSH(tfp);
d3756 5
a3760 2
	if (cmd != LYK_UP_LINK && cmd != LYK_DOWN_LINK)
	    follow_col = -1;
d3762 11
a3772 3
	switch(cmd) {
	case -1:
	    HTUserMsg(COMMAND_UNKNOWN);
a3773 5
	case 0: /* unmapped character */
	default:
	    if (curdoc.link >= 0 && curdoc.link < nlinks &&
		links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		F_TEXTLIKE(links[curdoc.link].form->type)) {
d3775 21
a3795 11
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation) {
		    show_main_statusline(links[curdoc.link], FOR_PANEL);
#ifdef INACTIVE_INPUT_STYLE_VH
		    textinput_redrawn = FALSE;
#endif
		} else
#endif
		    show_main_statusline(links[curdoc.link], FOR_INPUT);
	    } else if (more) {
		HTInfoMsg(MOREHELP);
d3797 4
a3800 1
		HTInfoMsg(HELP);
d3802 1
a3802 1
	    show_help = TRUE;
d3804 117
a3920 4
	    if (TRACE) {
		sprintf(cfile, "%d", c);
		LYaddstr(cfile);	/* show the user input */
		cfile[0] = '\0';
d3922 4
d3927 15
a3941 6

	case LYK_COMMAND:
	    cmd = handle_LYK_COMMAND(user_input_buffer);
	    goto new_cmd;

	case LYK_INTERRUPT:
d3943 1
a3943 1
	     *	No network transmission to interrupt - 'til we multithread.
d3945 1
a3945 1
	    break;
d3947 19
a3965 14
	case LYK_F_LINK_NUM:
	     c = '\0';
	     /* FALLTHRU */
	case LYK_1: /* FALLTHRU */
	case LYK_2: /* FALLTHRU */
	case LYK_3: /* FALLTHRU */
	case LYK_4: /* FALLTHRU */
	case LYK_5: /* FALLTHRU */
	case LYK_6: /* FALLTHRU */
	case LYK_7: /* FALLTHRU */
	case LYK_8: /* FALLTHRU */
	case LYK_9:
	    handle_LYK_digit(c, &force_load, user_input_buffer,
			     &old_c, real_c, &try_internal);
d3968 74
a4041 2
	case LYK_SOURCE:  /* toggle view source mode */
	    handle_LYK_SOURCE(&ownerS_address);
d4044 13
a4056 2
#ifdef SH_EX		/* 1999/01/01 (Fri) */
	case LYK_CHG_CENTER:	/* ^Q */
d4058 9
a4066 3
	    if (no_table_center) {
		no_table_center = FALSE;
		HTInfoMsg("TABLE center enable.");
d4068 11
a4078 2
		no_table_center = TRUE;
		HTInfoMsg("TABLE center disable.");
a4079 13
#endif
	    /* FALLTHRU */
	case LYK_RELOAD:  /* control-R to reload and refresh */
	    handle_LYK_RELOAD(real_cmd);
	    break;

	case LYK_HISTORICAL:	/* toggle 'historical' comments parsing */
	    handle_LYK_HISTORICAL();
	    break;

	case LYK_MINIMAL:	/* toggle 'minimal' comments parsing */
	    handle_LYK_MINIMAL();
	    break;
d4081 29
a4109 2
	case LYK_SOFT_DQUOTES:
	    handle_LYK_SOFT_DQUOTES();
d4112 21
a4132 3
	case LYK_SWITCH_DTD:
	    handle_LYK_SWITCH_DTD();
	    break;
d4134 55
a4188 4
	case LYK_QUIT:		/* quit */
	    if (handle_LYK_QUIT())
		return(EXIT_SUCCESS);
	    break;
d4190 10
a4199 2
	case LYK_ABORT:		/* don't ask the user about quitting */
	    return(EXIT_SUCCESS);
d4201 5
a4205 2
	case LYK_NEXT_PAGE:	/* next page */
	    handle_LYK_NEXT_PAGE(&old_c, real_c);
d4208 46
a4253 2
	case LYK_PREV_PAGE:	/* page up */
	    handle_LYK_PREV_PAGE(&old_c, real_c);
d4256 3
a4258 3
	case  LYK_UP_TWO:
	    handle_LYK_UP_TWO(&arrowup, &old_c, real_c);
	    break;
d4260 18
a4277 2
	case  LYK_DOWN_TWO:
	    handle_LYK_DOWN_TWO(&old_c, real_c);
d4280 16
a4295 2
	case  LYK_UP_HALF:
	    handle_LYK_UP_HALF(&arrowup, &old_c, real_c);
d4297 1
d4299 19
a4317 3
	case  LYK_DOWN_HALF:
	    handle_LYK_DOWN_HALF(&old_c, real_c);
	    break;
d4319 15
a4333 28
#ifdef CAN_CUT_AND_PASTE
	case LYK_TO_CLIPBOARD:	/* ^S */
	    {
		char *s;
		int c;

		/* The logic resembles one of ADD_BOOKMARK */
		if (nlinks > 0 && links[curdoc.link].lname
		    && links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    /* Makes sense to copy a link */
		    _statusline("Copy D)ocument's or L)ink's URL to clipboard or C)ancel?");
		    c = LYgetch_single();
		    if (c == 'D')
			s = curdoc.address;
		    else if (c == 'C')
			break;
		    else
			s = links[curdoc.link].lname;
		} else
		    s = curdoc.address;
		if (!s && !*s)
		    HTInfoMsg("Current URL is empty.");
		if (put_clip(s))
		    HTInfoMsg("Copy to clipboard failed.");
		else if (s == curdoc.address)
		    HTInfoMsg("Document URL put to clipboard.");
		else
		    HTInfoMsg("Link URL put to clipboard.");
d4335 1
a4335 1
	    break;
d4337 13
a4349 7
	case LYK_PASTE_URL:
	    if (no_goto && !LYValidate) { /*  Go to not allowed. - FM */
		HTUserMsg(GOTO_DISALLOWED);
	    } else {
		unsigned char *s = get_clip_grab(), *e, *t;
		char *buf;
		int len;
d4351 28
a4378 32
		if (!s)
		    break;
		len = strlen(s);
		e = s + len;
		while (s < e && strchr(" \t\n\r", *s))
		    s++;
		while (s < e && strchr(" \t\n\r", e[-1]))
		    e--;
		if (s >= e) {
		    HTInfoMsg("No URL in the clipboard.");
		    break;
		}
		buf = (char*)malloc(e - s + 1);
		strncpy(buf, s, e - s);
		buf[e - s] = '\0';
		t = buf;

		while (s < e) {
		    if (strchr(" \t\n\r", *s)) {
			int nl = 0;	/* Keep whitespace without NL - file names! */
			unsigned char *s1 = s;

			while (strchr(" \t\n\r", *s)) {
			    if (!nl && *s == '\n')
				nl = 1;
			    s++;
			}
			if (!nl) {
			    while (s1 < s) {
				if (*s1 != '\r' && *s1 != '\r')
				    *t = *s1;
				t++, s1++;
d4381 30
a4410 2
		    } else
			*t++ = *s++;
a4411 4
		*t = '\0';
		get_clip_release();
		do_check_goto_URL(buf, &temp, &force_load);
		free(buf);
a4413 1
#endif
d4415 11
a4425 14
#ifdef KANJI_CODE_OVERRIDE
	case LYK_CHG_KCODE:	/* ^L */
	    if (LYRawMode && (HTCJK == JAPANESE)) {
		switch(last_kcode) {
		case NOKANJI:
		    last_kcode = SJIS;
		    break;
		case SJIS:
		    last_kcode = EUC;
		    break;
		case EUC:
		    last_kcode = NOKANJI;
		    break;
		default:
d4427 22
a4450 5
	    LYmove(0, 0);
	    lynx_start_title_color ();
	    LYaddstr(str_kcode(last_kcode));
	    lynx_stop_title_color ();

a4451 1
#endif
d4453 4
a4456 3
	case LYK_REFRESH:
	    refresh_screen = TRUE;
	    lynx_force_repaint();
d4458 1
d4460 24
a4483 5
	case LYK_HOME:
	    if (curdoc.line > 1)
		Newline = 1;
	    else {
		cmd = LYK_PREV_PAGE;
d4488 36
a4523 5
	case LYK_END:
	    i = HText_getNumOfLines() - display_lines + 2;
	    if (i >= 1 && Newline != i) {
		Newline = i;		/* go to end of file */
		arrowup = TRUE;		/* position on last link */
d4525 2
a4526 2
		cmd = LYK_NEXT_PAGE;
		goto new_cmd;
d4530 6
a4535 3
	case LYK_FIRST_LINK:
	    handle_LYK_FIRST_LINK();
	    break;
d4537 1
a4537 3
	case LYK_LAST_LINK:
	    handle_LYK_LAST_LINK();
	    break;
d4539 1
a4539 4
	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	    handle_LYK_PREV_LINK(&arrowup, &old_c, real_c);
	    break;
d4541 1
a4541 4
	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	    handle_LYK_NEXT_LINK(c, &old_c, real_c);
	    break;
d4543 2
a4544 2
	case LYK_FASTFORW_LINK:
	    handle_LYK_FASTFORW_LINK(&old_c, real_c);
d4547 6
a4552 4
	case LYK_FASTBACKW_LINK:
	    if (handle_LYK_FASTBACKW_LINK(&cmd, &old_c, real_c))
		goto new_cmd;
	    break;
d4554 1
a4554 3
	case LYK_UP_LINK:
	    handle_LYK_UP_LINK(&follow_col, &arrowup, &old_c, real_c);
	    break;
d4556 12
a4567 3
	case LYK_DOWN_LINK:
	    handle_LYK_DOWN_LINK(&follow_col, &old_c, real_c);
	    break;
d4569 1
a4569 7
	case LYK_CHANGE_LINK:
	    do_change_link();
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	    if (textfields_need_activation)
		textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    break;
d4571 1
a4571 3
	case LYK_RIGHT_LINK:
	    handle_LYK_RIGHT_LINK();
	    break;
d4573 2
a4574 2
	case LYK_LEFT_LINK:
	    handle_LYK_LEFT_LINK();
d4577 8
a4584 4
	case LYK_COOKIE_JAR:	/* show the cookie jar */
	    if (handle_LYK_COOKIE_JAR(&cmd))
		goto new_cmd;
	    break;
d4586 5
a4590 3
	case LYK_HISTORY:	/* show the history page */
	    if (handle_LYK_HISTORY(ForcePush))
		break;
d4592 13
a4604 7
	    /* FALLTHRU */
	case LYK_PREV_DOC:	/* back up a level */
	    switch (handle_PREV_DOC(&cmd, &old_c, real_c)) {
	    case 1:
		return(EXIT_SUCCESS);
	    case 2:
		goto new_cmd;
d4608 12
a4619 3
	case LYK_NEXT_DOC:	/* undo back up a level */
	    handle_NEXT_DOC();
	    break;
d4621 4
a4624 2
	case LYK_NOCACHE: /* Force submission of form or link with no-cache */
	    if (!handle_LYK_NOCACHE(&old_c, real_c))
d4626 7
d4634 4
a4637 10
	    /* FALLTHRU */
	case LYK_ACTIVATE:	/* follow a link */
	case LYK_SUBMIT:	/* follow a link, submit TEXT_SUBMIT input */
	    switch (handle_LYK_ACTIVATE(&c, cmd, &try_internal, &refresh_screen, &force_load, real_cmd)) {
	    case 1:
		continue;
	    case 2:
		goto new_keyboard_input;
	    case 3:
		pending_form_c = c;
d4641 13
a4653 4
	case LYK_ELGOTO:	/* edit URL of current link and go to it  */
	    if (handle_LYK_ELGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    break;
d4655 12
a4666 4
	case LYK_ECGOTO:	/* edit current URL and go to to it	*/
	    if (handle_LYK_ECGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
	    break;
d4668 4
a4671 7
	case LYK_GOTO:		/* 'g' to goto a random URL  */
	    if (handle_LYK_GOTO(&ch, user_input_buffer, &temp, &recall,
				&URLTotal, &URLNum, &FirstURLRecall, &old_c,
				real_c)) {
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
d4674 1
d4676 7
a4682 19
	case LYK_DWIMHELP:	/* show context-dependent help file */
	    handle_LYK_DWIMHELP(&cshelpfile);
	    /* FALLTHRU */

	case LYK_HELP:		/* show help file */
	    handle_LYK_HELP(&cshelpfile);
	    break;

	case LYK_INDEX:		/* index file */
	    handle_LYK_INDEX(&old_c, real_c);
	    break;

	case LYK_MAIN_MENU:	/* return to main screen */
	    handle_LYK_MAIN_MENU(&old_c, real_c);
	    break;

#ifdef EXP_NESTED_TABLES
	case LYK_NESTED_TABLES:
	    if (handle_LYK_NESTED_TABLES(&cmd))
d4684 1
a4684 6
	    break;
#endif
	case LYK_OPTIONS:	/* options screen */
	    if (handle_LYK_OPTIONS(&cmd, &refresh_screen))
		goto new_cmd;
	    break;
d4686 19
a4704 2
	case LYK_INDEX_SEARCH:	/* search for a user string */
	    handle_LYK_INDEX_SEARCH(&force_load, ForcePush, &old_c, real_c);
d4707 23
a4729 4
	case LYK_WHEREIS:	/* search within the document */
	case LYK_NEXT:		/* find the next occurrence in the document */
	case LYK_PREV:		/* find the previous occurrence in the document */
	    handle_LYK_WHEREIS(cmd, &refresh_screen);
d4732 23
a4754 3
	case LYK_COMMENT:	/* reply by mail */
	    handle_LYK_COMMENT(&refresh_screen, &owner_address, &old_c, real_c);
	    break;
d4756 30
a4785 4
#ifdef DIRED_SUPPORT
	case LYK_TAG_LINK:	/* tag or untag the current link */
	    handle_LYK_TAG_LINK();
	    break;
d4787 62
a4848 2
	case LYK_MODIFY:	/* rename a file or directory */
	    handle_LYK_MODIFY(&refresh_screen);
d4850 11
a4860 3

	case LYK_CREATE:	/* create a new file or directory */
	    handle_LYK_CREATE();
d4862 2
a4863 1
#endif /* DIRED_SUPPORT */
d4865 6
a4870 6
	case LYK_DWIMEDIT:	/* context-dependent edit */
	    switch (handle_LYK_DWIMEDIT(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
a4871 4
	    /* FALLTHRU */

	case LYK_EDIT:		/* edit */
	    handle_LYK_EDIT(&old_c, real_c);
d4873 1
d4875 8
a4882 3
	case LYK_DEL_BOOKMARK:	/* remove a bookmark file link */
	    handle_LYK_DEL_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;
d4884 6
d4891 9
a4899 3
	case LYK_REMOVE:	/* remove files and directories */
	    handle_LYK_REMOVE(&refresh_screen);
	    break;
d4901 137
a5037 4

#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
	case LYK_INSTALL:	/* install a file into system area */
	    handle_LYK_INSTALL();
a5038 1
#endif /* DIRED_SUPPORT && OK_INSTALL */
d5040 8
a5047 4
	case LYK_INFO:		/* show document info */
	    if (handle_LYK_INFO(&cmd))
		goto new_cmd;
	    break;
d5049 29
a5077 2
	case LYK_EDIT_TEXTAREA: /* use external editor on a TEXTAREA - KED */
	    handle_LYK_EDIT_TEXTAREA(&refresh_screen, &old_c, real_c);
d5080 13
a5092 2
	case LYK_GROW_TEXTAREA:	/* add new lines to bottom of TEXTAREA - KED */
	    handle_LYK_GROW_TEXTAREA(&refresh_screen);
d5095 12
a5106 3
	case LYK_INSERT_FILE:	/* insert file in TEXTAREA, above cursor - KED */
	    handle_LYK_INSERT_FILE(&refresh_screen, &old_c, real_c);
	    break;
d5108 6
a5113 3
	case LYK_PRINT:		/* print the file */
	    handle_LYK_PRINT(&ForcePush, &old_c, real_c);
	    break;
d5115 43
a5157 4
	case LYK_LIST:		/* list links in the current document */
	    if (handle_LYK_LIST(&cmd))
		goto new_cmd;
	    break;
d5159 16
a5174 6
#ifdef EXP_ADDRLIST_PAGE
	case LYK_ADDRLIST:	/* always list URL's (only) */
	    if (handle_LYK_ADDRLIST(&cmd))
		goto new_cmd;
	    break;
#endif /* EXP_ADDRLIST_PAGE */
d5176 13
a5188 4
	case LYK_VLINKS:  /* list links visited during the current session */
	    if (handle_LYK_VLINKS(&cmd, &newdoc_link_is_absolute))
		goto new_cmd;
	    break;
d5190 34
a5223 3
	case LYK_TOOLBAR:  /* go to Toolbar or Banner in current document */
	    handle_LYK_TOOLBAR(&try_internal, &force_load, &old_c, real_c);
	    break;
d5225 83
a5307 3
#if defined(DIRED_SUPPORT) || defined(VMS)
	case LYK_DIRED_MENU:  /* provide full file management menu */
	    handle_LYK_DIRED_MENU(&refresh_screen, &old_c, real_c);
a5308 1
#endif /* DIRED_SUPPORT || VMS*/
d5310 9
a5318 8
#ifdef USE_EXTERNALS
	case LYK_EXTERN_LINK:	/* use external program on url */
	    handle_LYK_EXTERN_LINK(&refresh_screen);
	    break;
	case LYK_EXTERN_PAGE:	/* use external program on current page */
	    handle_LYK_EXTERN_PAGE(&refresh_screen);
	    break;
#endif /* USE_EXTERNALS */
d5320 17
a5336 6
	case LYK_ADD_BOOKMARK:	/* add link to bookmark file */
	    handle_LYK_ADD_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_VIEW_BOOKMARK:	/* v to view home page */
	    handle_LYK_VIEW_BOOKMARK(&refresh_screen, &old_c, real_c);
d5338 1
d5340 4
a5343 2
	case LYK_SHELL:		/* (!) shell escape */
	    handle_LYK_SHELL(&refresh_screen, &old_c, real_c);
d5346 8
a5353 6
	case LYK_DOWNLOAD:
	    switch (handle_LYK_DOWNLOAD(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
a5354 1
	    break;
d5356 6
a5361 5
#ifdef DIRED_SUPPORT
	  case LYK_UPLOAD:
	    handle_LYK_UPLOAD();
	    break;
#endif /* DIRED_SUPPORT */
d5363 13
a5375 3
	case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	    handle_LYK_TRACE_TOGGLE();
	    break;
d5377 12
a5388 2
	case LYK_TRACE_LOG:	/*  View TRACE log. */
	    handle_LYK_TRACE_LOG(&trace_mode_flag);
d5392 14
a5405 3
	    if (handle_LYK_IMAGE_TOGGLE(&cmd))
		goto new_cmd;
	    break;
d5408 14
a5421 3
	    if (handle_LYK_INLINE_TOGGLE(&cmd))
		goto new_cmd;
	    break;
d5424 13
a5436 1
	    if (handle_LYK_RAW_TOGGLE(&cmd))
d5438 1
a5438 1
	    break;
d5441 122
a5562 2
	    if (handle_LYK_HEAD(&cmd))
		goto new_cmd;
d5566 4
a5569 1
	    handle_LYK_TOGGLE_HELP();
d5573 31
a5603 1
	    handle_LYK_KEYMAP(&vi_keys_flag, &emacs_keys_flag, &old_c, real_c);
d5607 56
a5662 6
	    if (handle_LYK_JUMP(c, user_input_buffer, &temp, &recall,
				    &FirstURLRecall, &URLNum, &URLTotal, &ch,
				    &old_c, real_c)) {
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
d5667 19
a5685 1
	    handle_LYK_CLEAR_AUTH(&old_c, real_c);
d5690 1
a5690 17
#ifdef SUPPORT_CHDIR
	case LYK_CHDIR:
	    handle_LYK_CHDIR();
	    break;
#endif
#ifdef USE_CURSES_PADS
	case LYK_SHIFT_LEFT:
	    handle_LYK_SHIFT_LEFT(&refresh_screen, key_count);
	    break;
	case LYK_SHIFT_RIGHT:
	    handle_LYK_SHIFT_RIGHT(&refresh_screen, key_count);
	    break;
	case LYK_LINEWRAP_TOGGLE:
	    if (handle_LYK_LINEWRAP_TOGGLE(&cmd, &refresh_screen))
		goto new_cmd;
	    break;
#endif
d5695 82
d5807 2
a5808 1
    if (strcmp(doc1->address, doc2->address)) {
d5814 1
a5814 1
    }
d5823 4
a5826 2
    if (doc1->post_data) {
	if (doc2->post_data) {
d5829 6
a5834 1
	} else
a5835 2
    } else if (doc2->post_data)
	return(TRUE);
d5892 2
a5893 1
    if (strcmp(ap1, ap2)) {
d5899 1
a5899 1
    }
d5908 4
a5911 2
    if (doc1->post_data) {
	if (doc2->post_data) {
d5914 6
a5919 1
	} else
a5920 2
    } else if (doc2->post_data)
	return(TRUE);
d5932 1
a5932 2
#ifdef LY_FIND_LEAKS
PRIVATE void HTGotoURLs_free NOARGS
d5937 5
a5941 6
    if (cur != 0) {
	while (NULL != (url = (char *)HTList_nextObject(cur))) {
	    FREE(url);
	}
	HTList_delete(Goto_URLs);
	Goto_URLs = NULL;
d5943 3
a5946 1
#endif
d5955 1
a5955 1
    char *new = NULL;
d5962 3
a5964 1
    StrAllocCopy(new, url);
d5993 3
a5995 3
PRIVATE void show_main_statusline ARGS2(
    CONST linkstruct,	curlink,
    int,		for_what)
d6000 1
a6000 1
    if (user_mode == NOVICE_MODE && for_what != FOR_INPUT) {
d6004 4
a6013 4
    /*
     *	If we are in forms mode then explicitly
     *	tell the user what each kind of link is.
     */
d6027 103
a6129 1
	    show_formlink_statusline(curlink.form, for_what);
d6138 1
a6138 2
	    char *indx = gettext("-index-");
	    LYmove(LYlines-1, LYcols - strlen(indx) - 1);
d6140 1
a6140 1
	    LYaddstr(indx);
d6148 1
a6148 2
	char *cp = NULL;

d6151 15
a6165 1
	    cp = strchr(curlink.lname, '#');
a6166 3
	if (!cp)
	    cp = curlink.lname;
	status_link(cp, more, is_www_index);
d6179 1
a6179 1
	    _statusline(MORE);
d6181 1
a6181 1
	    _statusline(MOREHELP);
a6184 1

d6186 1
a6186 19
    /* But not if LYShowCursor is on.  -show_cursor may be used as a
     * workaround to avoid putting the cursor in the last position, for
     * curses implementations or terminals that cannot deal with that
     * correctly. - kw */
    if (!LYShowCursor) {
	LYHideCursor();
    }
}

/*
 *  Public function for redrawing the statusline appropriate for the
 *  selected link.  It should only be called at times when curdoc.link,
 *  nlinks, and the links[] array are valid. - kw
 */
PUBLIC void repaint_main_statusline ARGS1(
    int,	for_what)
{
    if (curdoc.link >= 0 && curdoc.link < nlinks)
	show_main_statusline(links[curdoc.link], for_what);
a6188 32
PRIVATE void form_noviceline ARGS1(
    int,	disabled)
{
    LYmove(LYlines-2,0); LYclrtoeol();
    if (!disabled) {
	LYaddstr(FORM_NOVICELINE_ONE);
    }
    LYmove(LYlines-1,0); LYclrtoeol();
    if (disabled)
	return;
    if (EditBinding(FROMASCII('\025')) == LYE_ERASE) {
	LYaddstr(FORM_NOVICELINE_TWO);
    } else if (EditBinding(FROMASCII('\025')) == LYE_DELBL) {
	LYaddstr(FORM_NOVICELINE_TWO_DELBL);
    } else {
	char *temp = NULL;
	char *erasekey = fmt_keys(LYKeyForEditAction(LYE_ERASE), -1);
	if (erasekey) {
	    HTSprintf0(&temp, FORM_NOVICELINE_TWO_VAR, erasekey);
	} else {
	    erasekey = fmt_keys(LYKeyForEditAction(LYE_DELBL), -1);
	    if (erasekey)
		HTSprintf0(&temp,
			   FORM_NOVICELINE_TWO_DELBL_VAR, erasekey);
	}
	if (temp) {
	    LYaddstr(temp);
	    FREE(temp);
	}
	FREE(erasekey);
    }
}
d6205 1
a6205 1
		   buf2 ? buf2 : "",
d6211 1
a6211 2
		   (buf2 && strstr(buf2, gettext("Can't Access"))) ?
							       "" : startfile);
d6217 1
a6217 1
		   buf2 ? buf2 : "",
d6229 1
a6229 1
	fputs(buf, stderr);
d6234 1
a6234 1
	fputs(buf, stdout);
d6241 1
a6241 77
	exit_immediately(EXIT_FAILURE);
    }
    /* else: return(EXIT_FAILURE) in mainloop */
}


PRIVATE void status_link ARGS3(
	char *,		curlink_name,
	BOOLEAN,	show_more,
	BOOLEAN,	show_indx)
{
#define MAX_STATUS (LYcols - 2)
#define MIN_STATUS 0
    char format[MAX_LINE];
    int prefix = 0;
    int length;

    *format = 0;
    if (show_more) {
	sprintf(format, "%.*s ",
		(int)(sizeof(format) - 2),
		gettext("-more-"));
	prefix = strlen(format);
    }
    if (show_indx) {
	sprintf(format + prefix, "%.*s ",
		(int)(sizeof(format) - prefix - 2),
		gettext("-index-"));
    }
    prefix = strlen(format);
    length = strlen(curlink_name);

    if (prefix > MAX_STATUS || prefix >= MAX_LINE - 1) {
	_user_message("%s", format);	/* no room for url */
    } else {
	sprintf(format + prefix, "%%.%ds", MAX_STATUS - prefix);

	if ((length + prefix > MAX_STATUS) && long_url_ok) {
	    char *buf = NULL;
	    int cut_from_pos;
	    int cut_to_pos;
	    int n;

	    StrAllocCopy(buf, curlink_name);
	    /*
	     *  Scan to find the final leaf of the URL.
	     *  Ignore trailing '/'.
	     */
	    for (cut_to_pos = length - 2;
		 (cut_to_pos > 0) && (buf[cut_to_pos] != '/');
		 cut_to_pos--)
		 ;
	    /*
	     *  Jump back to the next leaf to remove.
	     */
	    for (cut_from_pos = cut_to_pos - 4;
		 (cut_from_pos > 0) && ((buf[cut_from_pos] != '/')
		 || (prefix + cut_from_pos + 4 + (length - cut_to_pos) >= MAX_STATUS));
		 cut_from_pos--)
		 ;
	    /*
	     *  Replace some leaves to '...', if possible, and put the
	     *  final leaf at the end. We assume that one can recognize
	     *  the link from at least MIN_STATUS characters.
	     */
	    if (cut_from_pos > MIN_STATUS) {
		for (n = 1; n <= 3; n++)
		    buf[cut_from_pos + n] = '.';
		for (n = 0; cut_to_pos + n <= length; n++)
		    buf[cut_from_pos + 4 + n] = buf[cut_to_pos + n];
	    }
	    _user_message(format, buf);
	    CTRACE((tfp,"lastline = %s\n",buf)); /* don't forget to erase me */
	    FREE(buf);
	} else {	/* show (possibly truncated) url */
	    _user_message(format, curlink_name);
	}
d6243 1
@

