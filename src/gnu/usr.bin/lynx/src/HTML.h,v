head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.55;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.10.26.26;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.51;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.30;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.08;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.28;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.26;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.20;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.29;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.13;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.38;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.50;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.51.23;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@/*					HTML to rich text converter for libwww
 *
 *			THE HTML TO RTF OBJECT CONVERTER
 *
 *  This interprets the HTML semantics.
 */
#ifndef HTML_H
#define HTML_H

#ifndef HTUTILS_H
#include <HTUtils.h>
#endif /* HTUTILS_H */

#include <UCDefs.h>
#include <UCAux.h>
#include <HTAnchor.h>
#include <HTMLDTD.h>

#ifdef __cplusplus
extern "C" {
#endif
/* #define ATTR_CS_IN (me->T.output_utf8 ? me->UCLYhndl : 0) */
#define ATTR_CS_IN me->tag_charset
#define TRANSLATE_AND_UNESCAPE_ENTITIES(s, p, h) \
	LYUCTranslateHTMLString(s, ATTR_CS_IN, current_char_set, YES, p, h, st_HTML)
#define TRANSLATE_AND_UNESCAPE_ENTITIES5(s,cs_from,cs_to,p,h) \
	LYUCTranslateHTMLString(s, cs_from, cs_to, YES, p, h, st_HTML)
#define TRANSLATE_AND_UNESCAPE_ENTITIES6(s,cs_from,cs_to,spcls,p,h) \
	LYUCTranslateHTMLString(s, cs_from, cs_to, spcls, p, h, st_HTML)
#define TRANSLATE_HTML(s,p,h) \
	LYUCFullyTranslateString(s, me->UCLYhndl, current_char_set, NO, YES, p, h, NO, st_HTML)
#define TRANSLATE_HTML5(s,cs_from,cs_to,p,h) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, YES, p, h, NO, st_HTML)
#define TRANSLATE_HTML7(s,cs_from,cs_to,spcls,p,h,Back) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, spcls, p, h, Back, st_HTML)
/*
 * Strings from attributes which should be converted to some kind of "standard"
 * representation (character encoding), was Latin-1, esp.  URLs (incl. 
 * #fragments) and HTML NAME and ID stuff.
 */
#define TRANSLATE_AND_UNESCAPE_TO_STD(s) \
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_URL)
#define UNESCAPE_FIELDNAME_TO_STD(s) \
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_HTML)
    extern const HTStructuredClass HTMLPresentation;

#ifdef Lynx_HTML_Handler
/*
 *	This section is semi-private to HTML.c and it's helper modules. - FM
 *	--------------------------------------------------------------------
 */

    typedef struct _stack_element {
	HTStyle *style;
	int tag_number;
    } stack_element;

/*		HTML Object
 *		-----------
 */
#define MAX_NESTING 800		/* Should be checked by parser */

    struct _HTStructured {
	const HTStructuredClass *isa;
	HTParentAnchor *node_anchor;
	HText *text;

	HTStream *target;	/* Output stream */
	HTStreamClass targetClass;	/* Output routines */

	HTChildAnchor *CurrentA;	/* current HTML_A anchor */
	int CurrentANum;	/* current HTML_A number */
	char *base_href;	/* current HTML_BASE href */
	char *map_address;	/* current HTML_MAP address */

	HTChunk title;		/* Grow by 128 */
	HTChunk object;		/* Grow by 128 */
	BOOL object_started;
	BOOL object_declare;
	BOOL object_shapes;
	BOOL object_ismap;
	char *object_usemap;
	char *object_id;
	char *object_title;
	char *object_data;
	char *object_type;
	char *object_classid;
	char *object_codebase;
	char *object_codetype;
	char *object_name;
	int objects_mixed_open, objects_figged_open;
	HTChunk option;		/* Grow by 128 */
	BOOL first_option;	/* First OPTION in SELECT? */
	char *LastOptionValue;
	BOOL LastOptionChecked;
	BOOL select_disabled;
	HTChunk textarea;	/* Grow by 128 */
	char *textarea_name;
	int textarea_name_cs;
	char *textarea_accept_cs;
	int textarea_cols;
	int textarea_rows;
	int textarea_disabled;
	char *textarea_id;
	HTChunk math;		/* Grow by 128 */
	HTChunk style_block;	/* Grow by 128 */
	HTChunk script;		/* Grow by 128 */

	/*
	 *  Used for nested lists. - FM
	 */
	int List_Nesting_Level;	/* counter for list nesting level */
	int OL_Counter[12];	/* counter for ordered lists */
	char OL_Type[12];	/* types for ordered lists */
	int Last_OL_Count;	/* last count in ordered lists */
	char Last_OL_Type;	/* last type in ordered lists */

	int Division_Level;
	short DivisionAlignments[MAX_NESTING];
	int Underline_Level;
	int Quote_Level;

	BOOL UsePlainSpace;
	BOOL HiddenValue;
	int lastraw;

	char *comment_start;	/* for literate programming */
	char *comment_end;

	HTTag *current_tag;
	BOOL style_change;
	HTStyle *new_style;
	HTStyle *old_style;
	int current_default_alignment;
	BOOL in_word;		/* Have just had a non-white char */
	stack_element stack[MAX_NESTING];
	stack_element *sp;	/* Style stack pointer */
	BOOL stack_overrun;	/* Was MAX_NESTING exceeded? */
	int skip_stack;		/* flag to skip next style stack operation */

	/*
	 *  Track if we are in an anchor, paragraph, address, base, etc.
	 */
	BOOL inA;
	BOOL inAPPLET;
	BOOL inAPPLETwithP;
	BOOL inBadBASE;
	BOOL inBadHREF;
	BOOL inBadHTML;
	BOOL inBASE;
	BOOL inBoldA;
	BOOL inBoldH;
	BOOL inCAPTION;
	BOOL inCREDIT;
	BOOL inFIG;
	BOOL inFIGwithP;
	BOOL inFONT;
	BOOL inFORM;
	BOOL inLABEL;
	BOOL inP;
	BOOL inPRE;
	BOOL inSELECT;
	BOOL inTABLE;
	BOOL inTEXTAREA;
	BOOL inUnderline;

	BOOL needBoldH;

	char *xinclude;		/* if no include strin address passed */
	/*
	 * UCI and UCLYhndl give the UCInfo and charset registered for the HTML
	 * parser in the node_anchor's UCStages structure.  It indicates what is
	 * fed to the HTML parser as the stream of character data (not necessarily
	 * tags and attributes).  It should currently always be set to be the same
	 * as UCI and UCLhndl for the HTEXT stage in the node_anchor's UCStages
	 * structure, since the HTML parser sends its input character data to the
	 * output without further charset translation.
	 */
	LYUCcharset *UCI;
	int UCLYhndl;
	/*
	 * inUCI and inUCLYhndl indicate the UCInfo and charset which the HTML
	 * parser treats at the input charset.  It is normally set to the UCI and
	 * UCLhndl for the SGML parser in the node_anchor's UCStages structure
	 * (which may be a dummy, based on the MIME parser's UCI and UCLhndl in
	 * that structure, when we are handling a local file or non-http(s)
	 * gateway).  It could be changed temporarily by the HTML parser, for
	 * conversions of attribute strings, but should be reset once done.  - FM
	 */
	LYUCcharset *inUCI;
	int inUCLYhndl;
	/*
	 * outUCI and outUCLYhndl indicate the UCInfo and charset which the HTML
	 * parser treats as the output charset.  It is normally set to its own UCI
	 * and UCLhndl.  It could be changed for conversions of attribute strings,
	 * but should be reset once done.  - FM
	 */
	LYUCcharset *outUCI;
	int outUCLYhndl;
	/*
	 * T holds the transformation rules for conversions of strings between the
	 * input and output charsets by the HTML parser.  - FM
	 */
	UCTransParams T;

	int tag_charset;	/* charset for attribute values etc. */
    };

    extern HTStyle *LYstyles(int style_number);
    extern BOOL LYBadHTML(HTStructured * me);

/*
 *	Semi-Private functions. - FM
 */
    extern void HTML_put_character(HTStructured * me, char c);
    extern void HTML_put_string(HTStructured * me, const char *s);
    extern void HTML_write(HTStructured * me, const char *s, int l);
    extern int HTML_put_entity(HTStructured * me, int entity_number);
    extern void actually_set_style(HTStructured * me);

/*	Style buffering avoids dummy paragraph begin/ends.
*/
#define UPDATE_STYLE if (me->style_change) { actually_set_style(me); }
#endif				/* Lynx_HTML_Handler */

    extern void strtolower(char *i);

/*				P U B L I C
*/

/*
 *  HTConverter to present HTML
 */
    extern HTStream *HTMLToPlain(HTPresentation *pres,
				 HTParentAnchor *anchor,
				 HTStream *sink);

    extern HTStream *HTMLParsedPresent(HTPresentation *pres,
				       HTParentAnchor *anchor,
				       HTStream *sink);

    extern HTStream *HTMLToC(HTPresentation *pres,
			     HTParentAnchor *anchor,
			     HTStream *sink);

    extern HTStream *HTMLPresent(HTPresentation *pres,
				 HTParentAnchor *anchor,
				 HTStream *sink);

    extern HTStructured *HTML_new(HTParentAnchor *anchor,
				  HTFormat format_out,
				  HTStream *target);

/*
 * Record error message as a hypertext object.
 *
 * The error message should be marked as an error so that it can be reloaded
 * later.  This implementation just throws up an error message and leaves the
 * document unloaded.
 *
 * On entry,
 *      sink    is a stream to the output device if any
 *      number  is the HTTP error number
 *      message is the human readable message.
 * On exit,
 *      a return code like HT_LOADED if object exists else 60; 0
 */
    extern int HTLoadError(HTStream *sink,
			   int number,
			   const char *message);

#ifdef __cplusplus
}
#endif
#endif				/* HTML_H */
@


1.7
log
@automatic merge
@
text
@d19 3
a23 1

a25 1

a27 1

a29 1

a31 1

a33 1

a35 1

d45 1
a45 2

extern const HTStructuredClass HTMLPresentation;
d53 4
a56 4
typedef struct _stack_element {
    HTStyle *style;
    int tag_number;
} stack_element;
d63 142
a204 142
struct _HTStructured {
    const HTStructuredClass *isa;
    HTParentAnchor *node_anchor;
    HText *text;

    HTStream *target;		/* Output stream */
    HTStreamClass targetClass;	/* Output routines */

    HTChildAnchor *CurrentA;	/* current HTML_A anchor */
    int CurrentANum;		/* current HTML_A number */
    char *base_href;		/* current HTML_BASE href */
    char *map_address;		/* current HTML_MAP address */

    HTChunk title;		/* Grow by 128 */
    HTChunk object;		/* Grow by 128 */
    BOOL object_started;
    BOOL object_declare;
    BOOL object_shapes;
    BOOL object_ismap;
    char *object_usemap;
    char *object_id;
    char *object_title;
    char *object_data;
    char *object_type;
    char *object_classid;
    char *object_codebase;
    char *object_codetype;
    char *object_name;
    int objects_mixed_open, objects_figged_open;
    HTChunk option;		/* Grow by 128 */
    BOOL first_option;		/* First OPTION in SELECT? */
    char *LastOptionValue;
    BOOL LastOptionChecked;
    BOOL select_disabled;
    HTChunk textarea;		/* Grow by 128 */
    char *textarea_name;
    int textarea_name_cs;
    char *textarea_accept_cs;
    int textarea_cols;
    int textarea_rows;
    int textarea_disabled;
    char *textarea_id;
    HTChunk math;		/* Grow by 128 */
    HTChunk style_block;	/* Grow by 128 */
    HTChunk script;		/* Grow by 128 */

    /*
     *  Used for nested lists. - FM
     */
    int List_Nesting_Level;	/* counter for list nesting level */
    int OL_Counter[12];		/* counter for ordered lists */
    char OL_Type[12];		/* types for ordered lists */
    int Last_OL_Count;		/* last count in ordered lists */
    char Last_OL_Type;		/* last type in ordered lists */

    int Division_Level;
    short DivisionAlignments[MAX_NESTING];
    int Underline_Level;
    int Quote_Level;

    BOOL UsePlainSpace;
    BOOL HiddenValue;
    int lastraw;

    char *comment_start;	/* for literate programming */
    char *comment_end;

    HTTag *current_tag;
    BOOL style_change;
    HTStyle *new_style;
    HTStyle *old_style;
    int current_default_alignment;
    BOOL in_word;		/* Have just had a non-white char */
    stack_element stack[MAX_NESTING];
    stack_element *sp;		/* Style stack pointer */
    BOOL stack_overrun;		/* Was MAX_NESTING exceeded? */
    int skip_stack;		/* flag to skip next style stack operation */

    /*
     *  Track if we are in an anchor, paragraph, address, base, etc.
     */
    BOOL inA;
    BOOL inAPPLET;
    BOOL inAPPLETwithP;
    BOOL inBadBASE;
    BOOL inBadHREF;
    BOOL inBadHTML;
    BOOL inBASE;
    BOOL inBoldA;
    BOOL inBoldH;
    BOOL inCAPTION;
    BOOL inCREDIT;
    BOOL inFIG;
    BOOL inFIGwithP;
    BOOL inFONT;
    BOOL inFORM;
    BOOL inLABEL;
    BOOL inP;
    BOOL inPRE;
    BOOL inSELECT;
    BOOL inTABLE;
    BOOL inTEXTAREA;
    BOOL inUnderline;

    BOOL needBoldH;

    char *xinclude;		/* if no include strin address passed */
    /*
     * UCI and UCLYhndl give the UCInfo and charset registered for the HTML
     * parser in the node_anchor's UCStages structure.  It indicates what is
     * fed to the HTML parser as the stream of character data (not necessarily
     * tags and attributes).  It should currently always be set to be the same
     * as UCI and UCLhndl for the HTEXT stage in the node_anchor's UCStages
     * structure, since the HTML parser sends its input character data to the
     * output without further charset translation.
     */
    LYUCcharset *UCI;
    int UCLYhndl;
    /*
     * inUCI and inUCLYhndl indicate the UCInfo and charset which the HTML
     * parser treats at the input charset.  It is normally set to the UCI and
     * UCLhndl for the SGML parser in the node_anchor's UCStages structure
     * (which may be a dummy, based on the MIME parser's UCI and UCLhndl in
     * that structure, when we are handling a local file or non-http(s)
     * gateway).  It could be changed temporarily by the HTML parser, for
     * conversions of attribute strings, but should be reset once done.  - FM
     */
    LYUCcharset *inUCI;
    int inUCLYhndl;
    /*
     * outUCI and outUCLYhndl indicate the UCInfo and charset which the HTML
     * parser treats as the output charset.  It is normally set to its own UCI
     * and UCLhndl.  It could be changed for conversions of attribute strings,
     * but should be reset once done.  - FM
     */
    LYUCcharset *outUCI;
    int outUCLYhndl;
    /*
     * T holds the transformation rules for conversions of strings between the
     * input and output charsets by the HTML parser.  - FM
     */
    UCTransParams T;
d206 2
a207 2
    int tag_charset;		/* charset for attribute values etc. */
};
d209 2
a210 2
extern HTStyle *LYstyles(int style_number);
extern BOOL LYBadHTML(HTStructured * me);
d215 5
a219 5
extern void HTML_put_character(HTStructured * me, char c);
extern void HTML_put_string(HTStructured * me, const char *s);
extern void HTML_write(HTStructured * me, const char *s, int l);
extern int HTML_put_entity(HTStructured * me, int entity_number);
extern void actually_set_style(HTStructured * me);
d224 1
a224 1
#endif /* Lynx_HTML_Handler */
d226 1
a226 1
extern void strtolower(char *i);
d234 7
a240 11
extern HTStream *HTMLToPlain(HTPresentation *pres,
			     HTParentAnchor *anchor,
			     HTStream *sink);

extern HTStream *HTMLParsedPresent(HTPresentation *pres,
				   HTParentAnchor *anchor,
				   HTStream *sink);

extern HTStream *HTMLToC(HTPresentation *pres,
			 HTParentAnchor *anchor,
			 HTStream *sink);
d242 1
a242 1
extern HTStream *HTMLPresent(HTPresentation *pres,
d246 7
a252 3
extern HTStructured *HTML_new(HTParentAnchor *anchor,
			      HTFormat format_out,
			      HTStream *target);
d268 8
a275 5
extern int HTLoadError(HTStream *sink,
		       int number,
		       const char *message);

#endif /* HTML_H */
@


1.6
log
@automatic merge of lynx-current
@
text
@d106 1
a106 1
    char *textarea_cols;
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 5
a6 5
**
**			THE HTML TO RTF OBJECT CONVERTER
**
**  This interprets the HTML semantics.
*/
d41 3
a43 3
 *  Strings from attributes which should be converted to some kind
 *  of "standard" representation (character encoding), was Latin-1,
 *  esp. URLs (incl. #fragments) and HTML NAME and ID stuff.
d54 3
a56 3
**	This section is semi-private to HTML.c and it's helper modules. - FM
**	--------------------------------------------------------------------
*/
d59 2
a60 2
	HTStyle *	style;
	int		tag_number;
d64 2
a65 2
**		-----------
*/
d69 44
a112 45
    const HTStructuredClass *	isa;
    HTParentAnchor *		node_anchor;
    HText *			text;

    HTStream*			target;			/* Output stream */
    HTStreamClass		targetClass;		/* Output routines */

    HTChildAnchor *		CurrentA;	/* current HTML_A anchor */
    int				CurrentANum;	/* current HTML_A number */
    char *			base_href;	/* current HTML_BASE href */
    char *			map_address;	/* current HTML_MAP address */

    HTChunk			title;		/* Grow by 128 */
    HTChunk			object;		/* Grow by 128 */
    BOOL			object_started;
    BOOL			object_declare;
    BOOL			object_shapes;
    BOOL			object_ismap;
    char *			object_usemap;
    char *			object_id;
    char *			object_title;
    char *			object_data;
    char *			object_type;
    char *			object_classid;
    char *			object_codebase;
    char *			object_codetype;
    char *			object_name;
    int				objects_mixed_open,
				objects_figged_open;
    HTChunk			option;		/* Grow by 128 */
    BOOL			first_option;	/* First OPTION in SELECT? */
    char *			LastOptionValue;
    BOOL			LastOptionChecked;
    BOOL			select_disabled;
    HTChunk			textarea;	/* Grow by 128 */
    char *			textarea_name;
    int				textarea_name_cs;
    char *			textarea_accept_cs;
    char *			textarea_cols;
    int				textarea_rows;
    int				textarea_disabled;
    char *			textarea_id;
    HTChunk			math;		/* Grow by 128 */
    HTChunk			style_block;	/* Grow by 128 */
    HTChunk			script;		/* Grow by 128 */
d117 28
a144 28
    int		List_Nesting_Level;	/* counter for list nesting level */
    int		OL_Counter[12];		/* counter for ordered lists */
    char	OL_Type[12];		/* types for ordered lists */
    int		Last_OL_Count;		/* last count in ordered lists */
    char	Last_OL_Type;		/* last type in ordered lists */

    int				Division_Level;
    short			DivisionAlignments[MAX_NESTING];
    int				Underline_Level;
    int				Quote_Level;

    BOOL			UsePlainSpace;
    BOOL			HiddenValue;
    int				lastraw;

    char *			comment_start;	/* for literate programming */
    char *			comment_end;

    HTTag *			current_tag;
    BOOL			style_change;
    HTStyle *			new_style;
    HTStyle *			old_style;
    int				current_default_alignment;
    BOOL			in_word;  /* Have just had a non-white char */
    stack_element	stack[MAX_NESTING];
    stack_element	*sp;		/* Style stack pointer */
    BOOL		stack_overrun;	/* Was MAX_NESTING exceeded? */
    int			skip_stack; /* flag to skip next style stack operation */
d147 24
a170 24
    **  Track if we are in an anchor, paragraph, address, base, etc.
    */
    BOOL		inA;
    BOOL		inAPPLET;
    BOOL		inAPPLETwithP;
    BOOL		inBadBASE;
    BOOL		inBadHREF;
    BOOL		inBadHTML;
    BOOL		inBASE;
    BOOL		inBoldA;
    BOOL		inBoldH;
    BOOL		inCAPTION;
    BOOL		inCREDIT;
    BOOL		inFIG;
    BOOL		inFIGwithP;
    BOOL		inFONT;
    BOOL		inFORM;
    BOOL		inLABEL;
    BOOL		inP;
    BOOL		inPRE;
    BOOL		inSELECT;
    BOOL		inTABLE;
    BOOL		inTEXTAREA;
    BOOL		inUnderline;
d172 1
a172 1
    BOOL		needBoldH;
d174 1
a174 1
    char *		xinclude; /* if no include strin address passed */
d176 10
a185 11
    **  UCI and UCLYhndl give the UCInfo and charset registered for
    **  the HTML parser in the node_anchor's UCStages structure.  It
    **  indicates what is fed to the HTML parser as the stream of character
    **  data (not necessarily tags and attributes).  It should currently
    **  always be set to be the same as UCI and UCLhndl for the HTEXT stage
    **  in the node_anchor's UCStages structure, since the HTML parser sends
    **  its input character data to the output without further charset
    **  translation.
    */
    LYUCcharset	*	UCI;
    int			UCLYhndl;
d187 10
a196 11
    **  inUCI and inUCLYhndl indicate the UCInfo and charset which the
    **  HTML parser treats at the input charset.  It is normally set
    **  to the UCI and UCLhndl for the SGML parser in the node_anchor's
    **  UCStages structure (which may be a dummy, based on the MIME
    **  parser's UCI and UCLhndl in that structure, when we are handling
    **  a local file or non-http(s) gateway).  It could be changed
    **  temporarily by the HTML parser, for conversions of attribute
    **  strings, but should be reset once done. - FM
    */
    LYUCcharset	*	inUCI;
    int			inUCLYhndl;
d198 7
a204 8
    **  outUCI and outUCLYhndl indicate the UCInfo and charset which
    **  the HTML parser treats as the output charset.  It is normally
    **  set to its own UCI and UCLhndl.  It could be changed for
    **  conversions of attribute strings, but should be reset once
    **  done. - FM
    */
    LYUCcharset	*	outUCI;
    int			outUCLYhndl;
d206 4
a209 4
    **  T holds the transformation rules for conversions of strings
    **  between the input and output charsets by the HTML parser. - FM
    */
    UCTransParams	T;
d211 1
a211 1
    int			tag_charset; /* charset for attribute values etc. */
d214 2
a215 2
extern  HTStyle *LYstyles (int style_number);
extern	BOOL LYBadHTML (HTStructured *me); 
d220 5
a224 5
extern void HTML_put_character (HTStructured *me, char c);
extern void HTML_put_string (HTStructured *me, const char *s);
extern void HTML_write (HTStructured *me, const char *s, int l);
extern int HTML_put_entity (HTStructured *me, int entity_number);
extern void actually_set_style (HTStructured * me);
d231 1
a231 1
extern void strtolower (char* i);
d237 21
a257 26
**  HTConverter to present HTML
*/
extern HTStream* HTMLToPlain (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink);

extern HTStream* HTMLParsedPresent (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink);

extern HTStream* HTMLToC (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink);

extern HTStream* HTMLPresent (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink);

extern HTStructured* HTML_new (
	HTParentAnchor * anchor,
	HTFormat	format_out,
	HTStream *	target);
d260 16
a275 17
**  Record error message as a hypertext object.
**
**  The error message should be marked as an error so that it can be
**  reloaded later.  This implementation just throws up an error message
**  and leaves the document unloaded.
**
**  On entry,
**      sink    is a stream to the output device if any
**      number  is the HTTP error number
**      message is the human readable message.
**  On exit,
**      a return code like HT_LOADED if object exists else 60; 0
*/
extern int HTLoadError (
	HTStream *	sink,
	int		number,
	const char *	message);
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d50 1
a50 1
extern CONST HTStructuredClass HTMLPresentation;
d69 1
a69 1
    CONST HTStructuredClass *	isa;
d218 2
a219 2
extern  HTStyle *LYstyles PARAMS((int style_number));
extern	BOOL LYBadHTML PARAMS((HTStructured *me)); 
d224 5
a228 5
extern void HTML_put_character PARAMS((HTStructured *me, char c));
extern void HTML_put_string PARAMS((HTStructured *me, CONST char *s));
extern void HTML_write PARAMS((HTStructured *me, CONST char *s, int l));
extern int HTML_put_entity PARAMS((HTStructured *me, int entity_number));
extern void actually_set_style PARAMS((HTStructured * me));
d235 1
a235 1
extern void strtolower PARAMS((char* i));
d243 1
a243 1
extern HTStream* HTMLToPlain PARAMS((
d246 1
a246 1
	HTStream *		sink));
d248 1
a248 1
extern HTStream* HTMLParsedPresent PARAMS((
d251 1
a251 1
	HTStream *		sink));
d253 1
a253 1
extern HTStream* HTMLToC PARAMS((
d256 1
a256 1
	HTStream *		sink));
d258 1
a258 1
extern HTStream* HTMLPresent PARAMS((
d261 1
a261 1
	HTStream *		sink));
d263 1
a263 1
extern HTStructured* HTML_new PARAMS((
d266 1
a266 1
	HTStream *	target));
d280 1
a280 1
**      a retrun code like HT_LOADED if object exists else 60; 0
d282 1
a282 1
extern int HTLoadError PARAMS((
d285 1
a285 1
	CONST char *	message));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d69 3
a71 3
    CONST HTStructuredClass * 	isa;
    HTParentAnchor * 		node_anchor;
    HText * 			text;
d81 1
a81 1
    HTChunk 			title;		/* Grow by 128 */
d97 1
a97 1
    				objects_figged_open;
d108 1
a108 1
    int 			textarea_rows;
d119 4
a122 4
    int 	OL_Counter[12];		/* counter for ordered lists */
    char 	OL_Type[12];		/* types for ordered lists */
    int 	Last_OL_Count;		/* last count in ordered lists */
    char 	Last_OL_Type;		/* last type in ordered lists */
d142 2
a143 2
    stack_element 	stack[MAX_NESTING];
    stack_element 	*sp;		/* Style stack pointer */
d215 1
a215 1
    int 		tag_charset; /* charset for attribute values etc. */
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d23 1
a23 1
	LYUCFullyTranslateString(s, ATTR_CS_IN, current_char_set, YES, p, h, st_HTML)
d26 1
a26 1
	LYUCFullyTranslateString(s, cs_from, cs_to, YES, p, h, st_HTML)
d29 10
a38 1
	LYUCFullyTranslateString(s, cs_from, cs_to, spcls, p, h, st_HTML)
d46 1
a46 1
	LYUCFullyTranslateString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_URL)
d48 1
a48 1
	LYUCFullyTranslateString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_HTML)
d96 2
d175 1
d219 1
a287 1

@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 5
a6 5
 *
 *			THE HTML TO RTF OBJECT CONVERTER
 *
 *  This interprets the HTML semantics.
 */
a18 3
#ifdef __cplusplus
extern "C" {
#endif
d21 1
d23 2
a24 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, current_char_set, YES, p, h, st_HTML)
d26 2
a27 1
	LYUCTranslateHTMLString(s, cs_from, cs_to, YES, p, h, st_HTML)
d29 2
a30 7
	LYUCTranslateHTMLString(s, cs_from, cs_to, spcls, p, h, st_HTML)
#define TRANSLATE_HTML(s,p,h) \
	LYUCFullyTranslateString(s, me->UCLYhndl, current_char_set, NO, YES, p, h, NO, st_HTML)
#define TRANSLATE_HTML5(s,cs_from,cs_to,p,h) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, YES, p, h, NO, st_HTML)
#define TRANSLATE_HTML7(s,cs_from,cs_to,spcls,p,h,Back) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, spcls, p, h, Back, st_HTML)
d32 3
a34 3
 * Strings from attributes which should be converted to some kind of "standard"
 * representation (character encoding), was Latin-1, esp.  URLs (incl. 
 * #fragments) and HTML NAME and ID stuff.
d37 1
a37 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_URL)
d39 3
a41 2
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_HTML)
    extern const HTStructuredClass HTMLPresentation;
d45 3
a47 3
 *	This section is semi-private to HTML.c and it's helper modules. - FM
 *	--------------------------------------------------------------------
 */
d49 4
a52 4
    typedef struct _stack_element {
	HTStyle *style;
	int tag_number;
    } stack_element;
d55 2
a56 2
 *		-----------
 */
d59 143
a201 142
    struct _HTStructured {
	const HTStructuredClass *isa;
	HTParentAnchor *node_anchor;
	HText *text;

	HTStream *target;	/* Output stream */
	HTStreamClass targetClass;	/* Output routines */

	HTChildAnchor *CurrentA;	/* current HTML_A anchor */
	int CurrentANum;	/* current HTML_A number */
	char *base_href;	/* current HTML_BASE href */
	char *map_address;	/* current HTML_MAP address */

	HTChunk title;		/* Grow by 128 */
	HTChunk object;		/* Grow by 128 */
	BOOL object_started;
	BOOL object_declare;
	BOOL object_shapes;
	BOOL object_ismap;
	char *object_usemap;
	char *object_id;
	char *object_title;
	char *object_data;
	char *object_type;
	char *object_classid;
	char *object_codebase;
	char *object_codetype;
	char *object_name;
	int objects_mixed_open, objects_figged_open;
	HTChunk option;		/* Grow by 128 */
	BOOL first_option;	/* First OPTION in SELECT? */
	char *LastOptionValue;
	BOOL LastOptionChecked;
	BOOL select_disabled;
	HTChunk textarea;	/* Grow by 128 */
	char *textarea_name;
	int textarea_name_cs;
	char *textarea_accept_cs;
	int textarea_cols;
	int textarea_rows;
	int textarea_disabled;
	char *textarea_id;
	HTChunk math;		/* Grow by 128 */
	HTChunk style_block;	/* Grow by 128 */
	HTChunk script;		/* Grow by 128 */

	/*
	 *  Used for nested lists. - FM
	 */
	int List_Nesting_Level;	/* counter for list nesting level */
	int OL_Counter[12];	/* counter for ordered lists */
	char OL_Type[12];	/* types for ordered lists */
	int Last_OL_Count;	/* last count in ordered lists */
	char Last_OL_Type;	/* last type in ordered lists */

	int Division_Level;
	short DivisionAlignments[MAX_NESTING];
	int Underline_Level;
	int Quote_Level;

	BOOL UsePlainSpace;
	BOOL HiddenValue;
	int lastraw;

	char *comment_start;	/* for literate programming */
	char *comment_end;

	HTTag *current_tag;
	BOOL style_change;
	HTStyle *new_style;
	HTStyle *old_style;
	int current_default_alignment;
	BOOL in_word;		/* Have just had a non-white char */
	stack_element stack[MAX_NESTING];
	stack_element *sp;	/* Style stack pointer */
	BOOL stack_overrun;	/* Was MAX_NESTING exceeded? */
	int skip_stack;		/* flag to skip next style stack operation */

	/*
	 *  Track if we are in an anchor, paragraph, address, base, etc.
	 */
	BOOL inA;
	BOOL inAPPLET;
	BOOL inAPPLETwithP;
	BOOL inBadBASE;
	BOOL inBadHREF;
	BOOL inBadHTML;
	BOOL inBASE;
	BOOL inBoldA;
	BOOL inBoldH;
	BOOL inCAPTION;
	BOOL inCREDIT;
	BOOL inFIG;
	BOOL inFIGwithP;
	BOOL inFONT;
	BOOL inFORM;
	BOOL inLABEL;
	BOOL inP;
	BOOL inPRE;
	BOOL inSELECT;
	BOOL inTABLE;
	BOOL inTEXTAREA;
	BOOL inUnderline;

	BOOL needBoldH;

	char *xinclude;		/* if no include strin address passed */
	/*
	 * UCI and UCLYhndl give the UCInfo and charset registered for the HTML
	 * parser in the node_anchor's UCStages structure.  It indicates what is
	 * fed to the HTML parser as the stream of character data (not necessarily
	 * tags and attributes).  It should currently always be set to be the same
	 * as UCI and UCLhndl for the HTEXT stage in the node_anchor's UCStages
	 * structure, since the HTML parser sends its input character data to the
	 * output without further charset translation.
	 */
	LYUCcharset *UCI;
	int UCLYhndl;
	/*
	 * inUCI and inUCLYhndl indicate the UCInfo and charset which the HTML
	 * parser treats at the input charset.  It is normally set to the UCI and
	 * UCLhndl for the SGML parser in the node_anchor's UCStages structure
	 * (which may be a dummy, based on the MIME parser's UCI and UCLhndl in
	 * that structure, when we are handling a local file or non-http(s)
	 * gateway).  It could be changed temporarily by the HTML parser, for
	 * conversions of attribute strings, but should be reset once done.  - FM
	 */
	LYUCcharset *inUCI;
	int inUCLYhndl;
	/*
	 * outUCI and outUCLYhndl indicate the UCInfo and charset which the HTML
	 * parser treats as the output charset.  It is normally set to its own UCI
	 * and UCLhndl.  It could be changed for conversions of attribute strings,
	 * but should be reset once done.  - FM
	 */
	LYUCcharset *outUCI;
	int outUCLYhndl;
	/*
	 * T holds the transformation rules for conversions of strings between the
	 * input and output charsets by the HTML parser.  - FM
	 */
	UCTransParams T;
d203 2
a204 2
	int tag_charset;	/* charset for attribute values etc. */
    };
d206 1
a206 2
    extern HTStyle *LYstyles(int style_number);
    extern BOOL LYBadHTML(HTStructured * me);
d211 5
a215 5
    extern void HTML_put_character(HTStructured * me, char c);
    extern void HTML_put_string(HTStructured * me, const char *s);
    extern void HTML_write(HTStructured * me, const char *s, int l);
    extern int HTML_put_entity(HTStructured * me, int entity_number);
    extern void actually_set_style(HTStructured * me);
d220 1
a220 1
#endif				/* Lynx_HTML_Handler */
d222 1
a222 1
    extern void strtolower(char *i);
d228 26
a253 21
 *  HTConverter to present HTML
 */
    extern HTStream *HTMLToPlain(HTPresentation *pres,
				 HTParentAnchor *anchor,
				 HTStream *sink);

    extern HTStream *HTMLParsedPresent(HTPresentation *pres,
				       HTParentAnchor *anchor,
				       HTStream *sink);

    extern HTStream *HTMLToC(HTPresentation *pres,
			     HTParentAnchor *anchor,
			     HTStream *sink);

    extern HTStream *HTMLPresent(HTPresentation *pres,
				 HTParentAnchor *anchor,
				 HTStream *sink);

    extern HTStructured *HTML_new(HTParentAnchor *anchor,
				  HTFormat format_out,
				  HTStream *target);
d256 20
a275 21
 * Record error message as a hypertext object.
 *
 * The error message should be marked as an error so that it can be reloaded
 * later.  This implementation just throws up an error message and leaves the
 * document unloaded.
 *
 * On entry,
 *      sink    is a stream to the output device if any
 *      number  is the HTTP error number
 *      message is the human readable message.
 * On exit,
 *      a return code like HT_LOADED if object exists else 60; 0
 */
    extern int HTLoadError(HTStream *sink,
			   int number,
			   const char *message);

#ifdef __cplusplus
}
#endif
#endif				/* HTML_H */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d23 1
a23 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, current_char_set, YES, p, h, st_HTML)
d26 1
a26 1
	LYUCTranslateHTMLString(s, cs_from, cs_to, YES, p, h, st_HTML)
d29 1
a29 10
	LYUCTranslateHTMLString(s, cs_from, cs_to, spcls, p, h, st_HTML)

#define TRANSLATE_HTML(s,p,h) \
	LYUCFullyTranslateString(s, me->UCLYhndl, current_char_set, NO, YES, p, h, NO, st_HTML)

#define TRANSLATE_HTML5(s,cs_from,cs_to,p,h) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, YES, p, h, NO, st_HTML)

#define TRANSLATE_HTML7(s,cs_from,cs_to,spcls,p,h,Back) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, spcls, p, h, Back, st_HTML)
d37 1
a37 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_URL)
d39 1
a39 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_HTML)
a86 2
    int				objects_mixed_open,
    				objects_figged_open;
a163 1
    char *		xinclude; /* if no include strin address passed */
a206 1
extern	BOOL LYBadHTML PARAMS((HTStructured *me)); 
d275 1
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d69 3
a71 3
    CONST HTStructuredClass *	isa;
    HTParentAnchor *		node_anchor;
    HText *			text;
d81 1
a81 1
    HTChunk			title;		/* Grow by 128 */
d97 1
a97 1
				objects_figged_open;
d108 1
a108 1
    int				textarea_rows;
d119 4
a122 4
    int		OL_Counter[12];		/* counter for ordered lists */
    char	OL_Type[12];		/* types for ordered lists */
    int		Last_OL_Count;		/* last count in ordered lists */
    char	Last_OL_Type;		/* last type in ordered lists */
d142 2
a143 2
    stack_element	stack[MAX_NESTING];
    stack_element	*sp;		/* Style stack pointer */
d215 1
a215 1
    int			tag_charset; /* charset for attribute values etc. */
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d50 1
a50 1
extern const HTStructuredClass HTMLPresentation;
d69 1
a69 1
    const HTStructuredClass *	isa;
d218 2
a219 2
extern  HTStyle *LYstyles (int style_number);
extern	BOOL LYBadHTML (HTStructured *me); 
d224 5
a228 5
extern void HTML_put_character (HTStructured *me, char c);
extern void HTML_put_string (HTStructured *me, const char *s);
extern void HTML_write (HTStructured *me, const char *s, int l);
extern int HTML_put_entity (HTStructured *me, int entity_number);
extern void actually_set_style (HTStructured * me);
d235 1
a235 1
extern void strtolower (char* i);
d243 1
a243 1
extern HTStream* HTMLToPlain (
d246 1
a246 1
	HTStream *		sink);
d248 1
a248 1
extern HTStream* HTMLParsedPresent (
d251 1
a251 1
	HTStream *		sink);
d253 1
a253 1
extern HTStream* HTMLToC (
d256 1
a256 1
	HTStream *		sink);
d258 1
a258 1
extern HTStream* HTMLPresent (
d261 1
a261 1
	HTStream *		sink);
d263 1
a263 1
extern HTStructured* HTML_new (
d266 1
a266 1
	HTStream *	target);
d280 1
a280 1
**      a return code like HT_LOADED if object exists else 60; 0
d282 1
a282 1
extern int HTLoadError (
d285 1
a285 1
	const char *	message);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 5
a6 5
 *
 *			THE HTML TO RTF OBJECT CONVERTER
 *
 *  This interprets the HTML semantics.
 */
d41 3
a43 3
 * Strings from attributes which should be converted to some kind of "standard"
 * representation (character encoding), was Latin-1, esp.  URLs (incl. 
 * #fragments) and HTML NAME and ID stuff.
d54 3
a56 3
 *	This section is semi-private to HTML.c and it's helper modules. - FM
 *	--------------------------------------------------------------------
 */
d59 2
a60 2
    HTStyle *style;
    int tag_number;
d64 2
a65 2
 *		-----------
 */
d69 45
a113 44
    const HTStructuredClass *isa;
    HTParentAnchor *node_anchor;
    HText *text;

    HTStream *target;		/* Output stream */
    HTStreamClass targetClass;	/* Output routines */

    HTChildAnchor *CurrentA;	/* current HTML_A anchor */
    int CurrentANum;		/* current HTML_A number */
    char *base_href;		/* current HTML_BASE href */
    char *map_address;		/* current HTML_MAP address */

    HTChunk title;		/* Grow by 128 */
    HTChunk object;		/* Grow by 128 */
    BOOL object_started;
    BOOL object_declare;
    BOOL object_shapes;
    BOOL object_ismap;
    char *object_usemap;
    char *object_id;
    char *object_title;
    char *object_data;
    char *object_type;
    char *object_classid;
    char *object_codebase;
    char *object_codetype;
    char *object_name;
    int objects_mixed_open, objects_figged_open;
    HTChunk option;		/* Grow by 128 */
    BOOL first_option;		/* First OPTION in SELECT? */
    char *LastOptionValue;
    BOOL LastOptionChecked;
    BOOL select_disabled;
    HTChunk textarea;		/* Grow by 128 */
    char *textarea_name;
    int textarea_name_cs;
    char *textarea_accept_cs;
    char *textarea_cols;
    int textarea_rows;
    int textarea_disabled;
    char *textarea_id;
    HTChunk math;		/* Grow by 128 */
    HTChunk style_block;	/* Grow by 128 */
    HTChunk script;		/* Grow by 128 */
d118 28
a145 28
    int List_Nesting_Level;	/* counter for list nesting level */
    int OL_Counter[12];		/* counter for ordered lists */
    char OL_Type[12];		/* types for ordered lists */
    int Last_OL_Count;		/* last count in ordered lists */
    char Last_OL_Type;		/* last type in ordered lists */

    int Division_Level;
    short DivisionAlignments[MAX_NESTING];
    int Underline_Level;
    int Quote_Level;

    BOOL UsePlainSpace;
    BOOL HiddenValue;
    int lastraw;

    char *comment_start;	/* for literate programming */
    char *comment_end;

    HTTag *current_tag;
    BOOL style_change;
    HTStyle *new_style;
    HTStyle *old_style;
    int current_default_alignment;
    BOOL in_word;		/* Have just had a non-white char */
    stack_element stack[MAX_NESTING];
    stack_element *sp;		/* Style stack pointer */
    BOOL stack_overrun;		/* Was MAX_NESTING exceeded? */
    int skip_stack;		/* flag to skip next style stack operation */
d148 24
a171 24
     *  Track if we are in an anchor, paragraph, address, base, etc.
     */
    BOOL inA;
    BOOL inAPPLET;
    BOOL inAPPLETwithP;
    BOOL inBadBASE;
    BOOL inBadHREF;
    BOOL inBadHTML;
    BOOL inBASE;
    BOOL inBoldA;
    BOOL inBoldH;
    BOOL inCAPTION;
    BOOL inCREDIT;
    BOOL inFIG;
    BOOL inFIGwithP;
    BOOL inFONT;
    BOOL inFORM;
    BOOL inLABEL;
    BOOL inP;
    BOOL inPRE;
    BOOL inSELECT;
    BOOL inTABLE;
    BOOL inTEXTAREA;
    BOOL inUnderline;
d173 1
a173 1
    BOOL needBoldH;
d175 1
a175 1
    char *xinclude;		/* if no include strin address passed */
d177 11
a187 10
     * UCI and UCLYhndl give the UCInfo and charset registered for the HTML
     * parser in the node_anchor's UCStages structure.  It indicates what is
     * fed to the HTML parser as the stream of character data (not necessarily
     * tags and attributes).  It should currently always be set to be the same
     * as UCI and UCLhndl for the HTEXT stage in the node_anchor's UCStages
     * structure, since the HTML parser sends its input character data to the
     * output without further charset translation.
     */
    LYUCcharset *UCI;
    int UCLYhndl;
d189 11
a199 10
     * inUCI and inUCLYhndl indicate the UCInfo and charset which the HTML
     * parser treats at the input charset.  It is normally set to the UCI and
     * UCLhndl for the SGML parser in the node_anchor's UCStages structure
     * (which may be a dummy, based on the MIME parser's UCI and UCLhndl in
     * that structure, when we are handling a local file or non-http(s)
     * gateway).  It could be changed temporarily by the HTML parser, for
     * conversions of attribute strings, but should be reset once done.  - FM
     */
    LYUCcharset *inUCI;
    int inUCLYhndl;
d201 8
a208 7
     * outUCI and outUCLYhndl indicate the UCInfo and charset which the HTML
     * parser treats as the output charset.  It is normally set to its own UCI
     * and UCLhndl.  It could be changed for conversions of attribute strings,
     * but should be reset once done.  - FM
     */
    LYUCcharset *outUCI;
    int outUCLYhndl;
d210 4
a213 4
     * T holds the transformation rules for conversions of strings between the
     * input and output charsets by the HTML parser.  - FM
     */
    UCTransParams T;
d215 1
a215 1
    int tag_charset;		/* charset for attribute values etc. */
d218 2
a219 2
extern HTStyle *LYstyles(int style_number);
extern BOOL LYBadHTML(HTStructured * me);
d224 5
a228 5
extern void HTML_put_character(HTStructured * me, char c);
extern void HTML_put_string(HTStructured * me, const char *s);
extern void HTML_write(HTStructured * me, const char *s, int l);
extern int HTML_put_entity(HTStructured * me, int entity_number);
extern void actually_set_style(HTStructured * me);
d235 1
a235 1
extern void strtolower(char *i);
d241 26
a266 21
 *  HTConverter to present HTML
 */
extern HTStream *HTMLToPlain(HTPresentation *pres,
			     HTParentAnchor *anchor,
			     HTStream *sink);

extern HTStream *HTMLParsedPresent(HTPresentation *pres,
				   HTParentAnchor *anchor,
				   HTStream *sink);

extern HTStream *HTMLToC(HTPresentation *pres,
			 HTParentAnchor *anchor,
			 HTStream *sink);

extern HTStream *HTMLPresent(HTPresentation *pres,
			     HTParentAnchor *anchor,
			     HTStream *sink);

extern HTStructured *HTML_new(HTParentAnchor *anchor,
			      HTFormat format_out,
			      HTStream *target);
d269 17
a285 16
 * Record error message as a hypertext object.
 *
 * The error message should be marked as an error so that it can be reloaded
 * later.  This implementation just throws up an error message and leaves the
 * document unloaded.
 *
 * On entry,
 *      sink    is a stream to the output device if any
 *      number  is the HTTP error number
 *      message is the human readable message.
 * On exit,
 *      a return code like HT_LOADED if object exists else 60; 0
 */
extern int HTLoadError(HTStream *sink,
		       int number,
		       const char *message);
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d106 1
a106 1
    int textarea_cols;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d23 1
a23 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, current_char_set, YES, p, h, st_HTML)
d26 1
a26 1
	LYUCTranslateHTMLString(s, cs_from, cs_to, YES, p, h, st_HTML)
d29 1
a29 10
	LYUCTranslateHTMLString(s, cs_from, cs_to, spcls, p, h, st_HTML)

#define TRANSLATE_HTML(s,p,h) \
	LYUCFullyTranslateString(s, me->UCLYhndl, current_char_set, NO, YES, p, h, NO, st_HTML)

#define TRANSLATE_HTML5(s,cs_from,cs_to,p,h) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, YES, p, h, NO, st_HTML)

#define TRANSLATE_HTML7(s,cs_from,cs_to,spcls,p,h,Back) \
	LYUCFullyTranslateString(s, cs_from, cs_to, NO, spcls, p, h, Back, st_HTML)
d37 1
a37 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_URL)
d39 1
a39 1
	LYUCTranslateHTMLString(s, ATTR_CS_IN, ATTR_CS_IN, NO, NO, YES, st_HTML)
a86 2
    int				objects_mixed_open,
    				objects_figged_open;
a163 1
    char *		xinclude; /* if no include strin address passed */
a206 1
extern	BOOL LYBadHTML PARAMS((HTStructured *me)); 
@

