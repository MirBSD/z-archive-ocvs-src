head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.6
	tg-mergefixes-1-branch:1.1.3.6.0.4
	tg-mergefixes-1-base:1.1.3.6
	MIROS_X:1.1.3.6.0.2
	MIROS_X_BASE:1.1.3.6
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.56;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.11;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.29;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.21;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.43;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.24;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.44;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.11.47;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.16.08;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.54.16;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTAlert.h>

#ifdef __MINGW32__
#ifdef UNIX
#undef UNIX
#endif /* UNIX */
#endif /* __MINGW32__ */

#include <LYCurses.h>
#include <LYStyle.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYSignal.h>
#include <LYClean.h>
#include <LYReadCFG.h>
#include <LYStrings.h>
#include <LYCharSets.h>
#include <UCAux.h>
#include <HTFont.h>

#include <LYexit.h>
#include <LYLeaks.h>

#ifdef VMS
#include <LYMainLoop.h>
#endif

#if defined(VMS) && defined(__GNUC__)
#include <gnu_hacks.h>
#undef LINES
#undef COLS
#define LINES lines
#define COLS cols
extern int _NOSHARE(LINES);
extern int _NOSHARE(COLS);
#endif /* VMS && __GNUC__ */

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>
#endif

#ifdef NEED_WCHAR_H
#include <wchar.h>
#endif

#if defined(COLOR_CURSES)
int lynx_has_color = FALSE;
#endif

#ifdef HAVE_XCURSES
char *XCursesProgramName = "Lynx";
#endif

#if defined(USE_COLOR_STYLE) && !defined(USE_COLOR_TABLE)
#define COLOR_BKGD ((s_normal != NOSTYLE) ? hashStyles[s_normal].color : A_NORMAL)
#else
#define COLOR_BKGD ((COLOR_PAIRS >= 9) ? get_color_pair(9) : A_NORMAL)
#endif

#ifdef USE_CURSES_PADS
WINDOW *LYwin = 0;
int LYshiftWin = 0;
int LYwideLines = FALSE;
int LYtableCols = 0;		/* in 1/12 of screen width */
BOOL LYuseCursesPads = TRUE;	/* use pads for left/right shifting */
#endif

/*
 * These are routines to start and stop curses and to cleanup the screen at the
 * end.
 */

static int dumbterm(char *terminal);
BOOLEAN LYCursesON = FALSE;

#if defined(USE_BLINK) && defined(__EMX__)
static void make_blink_boldbg(void);
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
int Current_Attr, Masked_Attr;
#endif

#ifdef USE_SLANG
unsigned int Lynx_Color_Flags = 0;
BOOLEAN FullRefresh = FALSE;
int curscr = 0;

#ifdef SLANG_MBCS_HACK
/*
 * Will be set by size_change.  - KW
 */
int PHYSICAL_SLtt_Screen_Cols = 10;
#endif /* SLANG_MBCS_HACK */

void LY_SLrefresh(void)
{
    if (FullRefresh) {
	SLsmg_suspend_smg();
	SLsmg_resume_smg();
	FullRefresh = FALSE;
    } else {
	SLsmg_refresh();
    }

    return;
}

/* the following renamed from LY_SLclear since it is more like erase()
   described in curses man pages than like clear(); but for USE_SLANG
   clear() is still a macro calling this, and will do the same thing as
   erase(). - kw */
void LY_SLerase(void)
{
    SLsmg_gotorc(0, 0);
    SLsmg_erase_eos();
}

#ifdef VMS
void VTHome(void)
{
    printf("\033[;H");

    return;
}
#endif /* VMS */

void LYaddAttr(int a)
{
    Current_Attr |= a;
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
}

void LYsubAttr(int a)
{
    Current_Attr &= ~a;
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
}

static void lynx_setup_attrs(void)
{
    static int monoattr[] =
    {
	0,
	SLTT_BOLD_MASK,
	SLTT_REV_MASK,
	SLTT_REV_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK | SLTT_REV_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK | SLTT_REV_MASK
    };
    int n;

    for (n = 1; n <= 7; n++)
	SLtt_set_mono(n, NULL, (monoattr[n] & ~Masked_Attr));
}

void lynx_setup_colors(void)
{
    CTRACE((tfp, "lynx_setup_colors\n"));
    SLtt_set_color(0, NULL, DEFAULT_FG, DEFAULT_BG);
    SLtt_set_color(1, NULL, "blue", DEFAULT_BG);	/* bold */
    SLtt_set_color(2, NULL, "yellow", "blue");	/* reverse */
    SLtt_set_color(4, NULL, "magenta", DEFAULT_BG);	/* underline */
    /*
     * The other objects are '|'ed together to get rest.
     */
    SLtt_set_color(3, NULL, "green", DEFAULT_BG);	/* bold-reverse */
    SLtt_set_color(5, NULL, "blue", DEFAULT_BG);	/* bold-underline */
    SLtt_set_color(6, NULL, "red", DEFAULT_BG);		/* reverse-underline */
    SLtt_set_color(7, NULL, "magenta", "cyan");		/* reverse-underline-bold */
    /*
     * Now set monochrome attributes.
     */
    lynx_setup_attrs();
}

static void sl_suspend(int sig)
{
#ifdef SIGSTOP
#ifndef VMS
    int r, c;

    lynx_enable_mouse(0);
    if (sig == SIGTSTP)
	SLsmg_suspend_smg();
    SLang_reset_tty();
    kill(getpid(), SIGSTOP);
#if SLANG_VERSION > 9929
    SLang_init_tty(-1, 0, 1);
#else
    SLang_init_tty(3, 0, 1);
#endif /* SLANG_VERSION > 9929 */
    signal(SIGTSTP, sl_suspend);
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
    SLtty_set_suspend_state(1);
#endif
    if (sig == SIGTSTP)
	SLsmg_resume_smg();
    /*
     * Get new window size in case it changed.
     */
    r = SLtt_Screen_Rows;
    c = SLtt_Screen_Cols;
    size_change(0);
    if ((r != SLtt_Screen_Rows) || (c != SLtt_Screen_Cols)) {
	recent_sizechange = TRUE;
    }
    lynx_enable_mouse(1);
#endif /* !VMS */
#endif /* SIGSTOP */
    return;
}
#else

#ifdef FANCY_CURSES

#ifndef VMS
/* *INDENT-OFF* */
/* definitions for the mono attributes we can use */
static struct {
    const char *name;
    int code;
} Mono_Attrs[7] =
{
    { "normal",		A_NORMAL },
    { "bold",		A_BOLD },
    { "reverse",	A_REVERSE },
    { "underline",	A_UNDERLINE },
    { "standout",	A_STANDOUT },
    { "blink",		A_BLINK },
    { "dim",		A_DIM },
};
/* *INDENT-ON* */

int string_to_attr(char *name)
{
    unsigned i;

    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (!strcasecomp(Mono_Attrs[i].name, name)) {
	    return Mono_Attrs[i].code;
	}
    }
    return 0;
}
#endif /* VMS */

#ifdef USE_COLOR_STYLE
static char *attr_to_string(int code)
{
    static char result[sizeof(Mono_Attrs) + 80];
    unsigned i;
    int pair = PAIR_NUMBER(code);
    int bold = (pair != 0 && (code & A_BOLD) != 0);

    if (bold)
	code &= ~A_BOLD;

    *result = 0;
    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (Mono_Attrs[i].code & code) {
	    if (*result)
		strcat(result, "+");
	    strcat(result, Mono_Attrs[i].name);
	}
    }
    if (pair != 0) {
	short f, b;

	if (pair_content(pair, &f, &b) != ERR) {
	    const char *fg = lookup_color(bold ? f + COLORS : f);
	    const char *bg = lookup_color(b);

	    if (*result)
		strcat(result, "+");
	    sprintf(result + strlen(result), "%s/%s", fg, bg);
	}
    }
    return result;
}
#endif /* USE_COLOR_STYLE */
#endif /* FANCY_CURSES */
#endif /* USE_SLANG */

/*
 *  This function boxes windows for (n)curses.
 */
void LYbox(WINDOW * win, BOOLEAN formfield GCC_UNUSED)
{
#ifdef USE_SLANG
    SLsmg_draw_box(win->top_y, win->left_x, win->height, win->width + 4);
#else
#ifdef VMS
    /*
     * This should work for VAX-C and DEC-C, since they both have the same
     * win._max_y and win._max_x members -TD
     *
     * (originally VMSbox by FM)
     */
    int i;

    wmove(win, 0, 0);
    waddstr(win, "\033)0\016l");
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
    waddch(win, 'k');
    for (i = 1; i < win->_max_y - 1; i++) {
	wmove(win, i, 0);
	waddch(win, 'x');
	wmove(win, i, win->_max_x - 1);
	waddch(win, 'x');
    }
    wmove(win, i, 0);
    waddch(win, 'm');
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
    waddstr(win, "j\017");
#else /* !VMS */
    /*
     * If the terminal is in UTF-8 mode, it probably cannot understand box
     * drawing characters as (n)curses handles them.  (This may also be true
     * for other display character sets, but isn't currently checked.) In that
     * case, substitute ASCII characters for BOXVERT and BOXHORI if they were
     * defined to 0 for automatic use of box drawing characters.  They'll stay
     * as they are otherwise.  - KW & FM
     */
    int boxvert, boxhori;

    UCSetBoxChars(current_char_set, &boxvert, &boxhori, BOXVERT, BOXHORI);
#ifdef CSS
    if (formfield)
	wcurses_css(win, "frame", ABS_ON);
#endif
    /*
     * If we don't have explicitly specified characters for either vertical or
     * horizontal lines, the characters that box() would use for the corners
     * probably also won't work well.  So we specify our own ASCII characters
     * for the corners and call wborder() instead of box().  - kw
     */
    LynxWChangeStyle(win, s_menu_frame, STACK_ON);
#ifdef HAVE_WBORDER
    if (!boxvert || !boxhori)
	box(win, boxvert, boxhori);
    else if (boxvert == '*' || boxhori == '*')
	wborder(win, boxvert, boxvert, boxhori, boxhori, '*', '*', '*', '*');
    else
	wborder(win, boxvert, boxvert, boxhori, boxhori, '/', '\\', '\\', '/');
#else
    box(win, boxvert, boxhori);
#endif
    LynxWChangeStyle(win, s_menu_frame, STACK_OFF);
#ifdef CSS
    if (formfield)
	wcurses_css(win, "frame", ABS_OFF);
#endif
#endif /* VMS */
    wrefresh(win);
#endif /* USE_SLANG */
}

#if defined(USE_COLOR_STYLE)
/* Ok, explanation of the USE_COLOR_STYLE styles.  The basic styles (ie non
 * HTML) are set the same as the SLANG version for ease of programming.  The
 * other styles are simply the HTML enum from HTMLDTD.h + 16.
 */
HTCharStyle displayStyles[DSTYLE_ELEMENTS];

/*
 * set a style's attributes - RP
 */
void setStyle(int style,
	      int color,
	      int cattr,
	      int mono)
{
    displayStyles[style].color = color;
    displayStyles[style].cattr = cattr;
    displayStyles[style].mono = mono;
}

void setHashStyle(int style,
		  int color,
		  int cattr,
		  int mono,
		  char *element)
{
    bucket *ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE,
	    (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n",
	     element, style, color, mono));

    ds->color = color;
    ds->cattr = cattr;
    ds->mono = mono;
    ds->code = style;
    FREE(ds->name);
    StrAllocCopy(ds->name, element);
}

/*
 * set the curses attributes to be color or mono - RP
 */
static void LYAttrset(WINDOW * win, int color,
		      int mono)
{
    if (lynx_has_color
	&& LYShowColor >= SHOW_COLOR_ON
	&& color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color (%s)\n",
			      attr_to_string(color)));
	wattrset(win, color);
    } else if (mono >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono (%s)\n",
			      attr_to_string(mono)));
	wattrset(win, mono);
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset (A_NORMAL)\n"));
	wattrset(win, A_NORMAL);
    }
}

void curses_w_style(WINDOW * win, int style,
		    int dir)
{
#if OMIT_SCN_KEEPING
# define SPECIAL_STYLE /*(CSHASHSIZE+1) */ 88888
/* if TRACEs are not compiled in, this macro is redundant - we needn't valid
'ds' to stack off. */
#endif

    int YP, XP;

#if !OMIT_SCN_KEEPING
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);

#else
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket :
		  (style == SPECIAL_STYLE ? &special_bucket : &hashStyles[style]));
#endif

    if (!ds->name) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n", style));
#if !OMIT_SCN_KEEPING
	return;
#endif
    }

    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> (%d)\n",
			  (dir ? "" : "/"),
			  ds->name, ds->code));

    getyx(win, YP, XP);

    if (style == s_normal && dir) {
	wattrset(win, A_NORMAL);
	if (win == LYwin)
	    cached_styles[YP][XP] = s_normal;
	return;
    }

    switch (dir) {
	/* ABS_OFF is the same as STACK_OFF for the moment */
    case STACK_OFF:
	if (last_colorattr_ptr) {
	    int last_attr = last_styles[--last_colorattr_ptr];

	    LYAttrset(win, last_attr, last_attr);
	} else
	    LYAttrset(win, A_NORMAL, -1);
	break;

    case STACK_ON:		/* remember the current attributes */
	if (last_colorattr_ptr >= MAX_LAST_STYLES) {
	    CTRACE2(TRACE_STYLE, (tfp, "........... %s (0x%x) %s\r\n",
				  "attribute cache FULL, dropping last",
				  last_styles[last_colorattr_ptr],
				  "in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr = MAX_LAST_STYLES - 1;
	}
	last_styles[last_colorattr_ptr++] = LYgetattrs(win);
	/* don't cache style changes for active links */
#if OMIT_SCN_KEEPING
	/* since we don't compute the hcode to stack off in HTML.c, we
	 * don't know whether this style is configured.  So, we
	 * shouldn't simply return on stacking on unconfigured
	 * styles, we should push curr attrs on stack.  -HV
	 */
	if (!ds->name)
	    break;
#endif
	/* FALL THROUGH */
    case ABS_ON:		/* change without remembering the previous style */
	/* don't cache style changes for active links and edits */
	if (style != s_alink
	    && style != s_curedit
	    && style != s_aedit
	    && style != s_aedit_sel
	    && style != s_aedit_pad
	    && style != s_aedit_arr) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n",
				  ds->name, YP, XP));
	    if (win == LYwin)
		cached_styles[YP][XP] = style;
	}
	LYAttrset(win, ds->color, ds->mono);
	break;
    }
}

/*
 * wrapper function to set on-screen styles - RP
 */
void wcurses_css(WINDOW * win, char *name,
		 int dir)
{
    int try_again = 1;

    while (try_again) {
	int tmpHash = hash_code(name);

	CTRACE2(TRACE_STYLE, (tfp, "CSSTRIM:trying to set [%s] style - ", name));
	if (tmpHash == NOSTYLE) {
	    char *pclass = strrchr(name, '.');

	    CTRACE2(TRACE_STYLE, (tfp, "undefined, trimming at %p\n", pclass));
	    if (pclass)
		*pclass = '\0';
	    else
		try_again = 0;
	} else {
	    CTRACE2(TRACE_STYLE, (tfp, "ok (%d)\n", hash_code(name)));
	    curses_w_style(win, hash_code(name), dir);
	    try_again = 0;
	}
    }
}

void curses_css(char *name,
		int dir)
{
    wcurses_css(LYwin, name, dir);
}

void curses_style(int style,
		  int dir)
{
    curses_w_style(LYwin, style, dir);
}
#endif /* USE_COLOR_STYLE */

static BOOL lynx_called_initscr = FALSE;

#if defined(HAVE_USE_DEFAULT_COLORS) && defined(USE_DEFAULT_COLORS)
/*
 * If we find a "default" color while reading the config-file, set default
 * colors on the screen.
 */
int lynx_default_colors(void)
{
    int code = 0;

    if (lynx_called_initscr) {
	code = -1;
	if (!default_color_reset && use_default_colors() == OK) {
	    default_fg = DEFAULT_COLOR;
	    default_bg = DEFAULT_COLOR;
	    code = 1;
	}
    }
    return code;
}
#endif /* HAVE_USE_DEFAULT_COLORS && USE_DEFAULT_COLORS */

#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
/*
 * This block of code is designed to produce the same color effects using SVr4
 * curses as the slang library's implementation in this module.  That maps the
 * SGR codes into a 0-7 index into the color table, with special treatment for
 * backgrounds.  There's a bit of convoluted (but necessary) code handling the
 * special case of initialization before 'initscr()' is called.
 * 1997/1/19 - T.E.Dickey <dickey@@clark.net>
 */
/* *INDENT-OFF* */
static struct {
    int fg, bg;
} lynx_color_cfg[] = {
    /*0*/ { DEFAULT_FG,    DEFAULT_BG},
    /*1*/ { COLOR_BLUE,    DEFAULT_BG},
    /*2*/ { COLOR_YELLOW+8,COLOR_BLUE},
    /*3*/ { COLOR_GREEN,   DEFAULT_BG},
    /*4*/ { COLOR_MAGENTA, DEFAULT_BG},
    /*5*/ { COLOR_BLUE,    DEFAULT_BG},
    /*6*/ { COLOR_RED,	   DEFAULT_BG},
    /*7*/ { COLOR_MAGENTA, COLOR_CYAN}
};
/* *INDENT-ON* */

/*
 * Hold the codes for color-pairs here until 'initscr()' is called.
 */
static struct {
    int fg;
    int bg;
} lynx_color_pairs[25];

/*
 * If we find an exact match for the given default colors, force curses to use
 * color pair 0, which corresponds to the terminal's default colors.  Normally
 * curses assumes white-on-black, but we can override the assumption with this
 * function.
 */
static int get_color_pair(int n)
{
#ifdef USE_CURSES_PAIR_0
    if (lynx_color_pairs[n].fg == default_fg
	&& lynx_color_pairs[n].bg == default_bg)
	return 0;
#endif
    return COLOR_PAIR(n);
}

/*
 * Lynx "knows" about 16 colors.  ANSI colors (and most color terminal
 * emulators) only go to 8, though some curses implementations (ncurses and
 * PDCurses) handle 16.  If lynx's configuration calls for a color past the
 * number of colors that the terminal handles (COLORS), map the extra value
 * to bold.
 */
#define is_boldc(c) ((c) > (COLORS-1))
#define map2bold(c) (is_boldc(c) ? ((c) & (COLORS-1)) : (c))

/*
 * Return the extra color as A_BOLD.
 * If there is no extra color, return A_NORMAL.
 */
static int lynx_color_cfg_attr(int code)
{
    int result = A_NORMAL;

    if (code >= 0 && code < 8) {
	int fg = lynx_color_cfg[code].fg;

	if (is_boldc(fg) && (fg & COLORS))
	    result = A_BOLD;
    }
    return result;
}

/*
 * Map the SGR attributes (0-7) into ANSI colors, modified with the actual BOLD
 * attribute we'll get 16 colors.
 */
static void LYsetWAttr(WINDOW * win)
{
    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON) {
	int code = 0;
	int attr = A_NORMAL;
	int offs = 1;

	if (Current_Attr & A_BOLD)
	    code |= 1;
	if (Current_Attr & A_REVERSE)
	    code |= 2;
	if (Current_Attr & A_UNDERLINE)
	    code |= 4;
	attr = lynx_color_cfg_attr(code);

	if (code + offs < COLOR_PAIRS) {
	    attr |= get_color_pair(code + offs);
	}

	wattrset(win, attr & ~Masked_Attr);
    } else {
	wattrset(win, Current_Attr & ~Masked_Attr);
    }
}

/*
 * Initialize a curses color-pair based on our configured color values.
 */
static void lynx_init_color_pair(int n)
{
    int m;

    if (lynx_called_initscr) {
	for (m = 0; m <= 16; m += 8) {
	    int pair = n + m + 1;

	    if (pair < COLOR_PAIRS)
		init_pair((short) pair,
			  (short) map2bold(lynx_color_pairs[pair].fg),
			  (short) map2bold(lynx_color_pairs[pair].bg));
	}
	if (n == 0 && LYShowColor >= SHOW_COLOR_ON)
	    wbkgd(LYwin, COLOR_BKGD | ' ');
    }
}

static void lynx_map_color(int n)
{
    CTRACE((tfp, "lynx_map_color(%d)\n", n));

    lynx_color_pairs[n + 1].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n + 1].bg = lynx_color_cfg[n].bg;

    lynx_color_pairs[n + 9].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n + 9].bg = lynx_color_cfg[0].bg;

    lynx_color_pairs[n + 17].fg = lynx_color_cfg[n].bg;
    lynx_color_pairs[n + 17].bg = lynx_color_cfg[n].bg;

    lynx_init_color_pair(n);
}

/*
 * Change a configured color value.  This may be called before initscr(), so
 * we may not be able to call init_pair() to finish the change.
 */
int lynx_chg_color(int color,
		   int fg,
		   int bg
)
{
    if (fg == ERR_COLOR || bg == ERR_COLOR)
	return -1;
    if (color >= 0 && color < 8) {
	lynx_color_cfg[color].fg = fg;
	lynx_color_cfg[color].bg = bg;
	lynx_map_color(color);
    } else {
	return -1;
    }
    return 0;
}

void lynx_set_color(int a)
{
    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON) {
	wattrset(LYwin, lynx_color_cfg_attr(a)
		 | (((a + 1) < COLOR_PAIRS)
		    ? get_color_pair(a + 1)
		    : A_NORMAL));
    }
}

void lynx_standout(int flag)
{
    if (flag)
	LYaddAttr(A_REVERSE);
    else
	LYsubAttr(A_REVERSE);
}

static void lynx_init_colors(void)
{
    if (lynx_has_color) {
	size_t n;

	CTRACE((tfp, "lynx_init_colors (default %d/%d)\n",
		default_fg, default_bg));

	lynx_color_cfg[0].fg = default_fg;
	lynx_color_cfg[0].bg = default_bg;

	for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
	    lynx_init_color_pair(n);
	}
    } else if (LYShowColor != SHOW_COLOR_NEVER) {
	LYShowColor = SHOW_COLOR_OFF;
    }
}

void lynx_setup_colors(void)
{
    int n;

    CTRACE((tfp, "lynx_setup_colors\n"));
    for (n = 0; n < 8; n++)
	lynx_map_color(n);
}
#endif /* USE_COLOR_TABLE */

void LYnoVideo(int a)
{
    CTRACE((tfp, "LYnoVideo(%d)\n", a));
#ifdef USE_SLANG
    if (a & 1)
	Masked_Attr |= SLTT_BOLD_MASK;
    if (a & 2)
	Masked_Attr |= SLTT_REV_MASK;
    if (a & 4)
	Masked_Attr |= SLTT_ULINE_MASK;
    lynx_setup_attrs();
#else
#ifdef USE_COLOR_TABLE
    if (a & 1)
	Masked_Attr |= A_BOLD;
    if (a & 2)
	Masked_Attr |= A_REVERSE;
    if (a & 4)
	Masked_Attr |= A_UNDERLINE;
#endif
#endif
}

#define NEWTERM_NAME "newterm"
#if       !defined(VMS) && !defined(USE_SLANG)
/*
 * If newterm is not defined, assume a curses subset which
 * supports only initscr.  --gil
 */
#if defined(HAVE_NEWTERM) && defined(HAVE_DELSCREEN) && !(defined(NCURSES) && defined(HAVE_RESIZETERM))
static SCREEN *LYscreen = NULL;

#define LYDELSCR() { \
if (recent_sizechange) { \
    CTRACE((tfp, "Screen size: delscreen()\n")); \
    delscreen(LYscreen); \
    LYscreen = NULL; } }
/*
 * Surrogates for newterm annd delscreen
 */
#else /* HAVE_NEWTERM   */
static WINDOW *LYscreen = NULL;

#undef  NEWTERM_NAME
#define NEWTERM_NAME "initscr"
#undef  newterm
#define newterm(type, out, in) (initscr())
#define LYDELSCR()		/* nothing */
#endif /* HAVE_NEWTERM   */
#else /* !defined(VMS) && !defined(USE_SLANG) */
/*
 * Provide last recourse definitions of LYscreen and LYDELSCR for
 * stop_curses, which only tests LYscreen for zero/nonzero but
 * never uses it as a pointer or L-value.
 */
#define LYscreen TRUE
#define LYDELSCR()		/* nothing */
#endif /* !defined(VMS) && !defined(USE_SLANG) */

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
int saved_scrsize_x = 0;
int saved_scrsize_y = 0;
#endif

void start_curses(void)
{
#ifdef USE_SLANG
    static int slinit;

    if (LYCursesON) {
	CTRACE((tfp, "start_curses: Hmm, already ON.\n"));
	return;
    }

    if (slinit == 0) {
#if defined(USE_KEYMAPS)
	if (-1 == lynx_initialize_keymaps())
	    exit_immediately(EXIT_FAILURE);
#else
	SLtt_get_terminfo();
#endif
#if (defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)) || defined(__CYGWIN__)
	SLkp_init();
#endif /* __DJGPP__ && !DJGPP_KEYHANDLER */

#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
#if SLANG_VERSION >= 9935
	SLang_TT_Read_FD = fileno(stdin);
#endif /* SLANG_VERSION >= 9935 */
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */

#if !defined(USE_KEYMAPS) && defined(ENHANCED_LINEEDIT) && defined(ESCDELAY)
	/* way to get ESC that's not part of a recognized sequence through */
	ESCDELAY = 2000;
#endif
	/*
	 * Check whether a saved show_color:off override is in effect.  - kw
	 */
	if (LYrcShowColor == SHOW_COLOR_NEVER) {
	    SLtt_Use_Ansi_Colors = 0;
	}
	/*
	 * Check whether we're forcing color on.  - FM
	 */
	if ((LYShowColor > 1) && (Lynx_Color_Flags & SL_LYNX_USE_COLOR))
	    SLtt_Use_Ansi_Colors = 1;
	/*
	 * Check whether a -nocolor override is in effect.  - kw
	 */
	if (Lynx_Color_Flags & SL_LYNX_OVERRIDE_COLOR)
	    SLtt_Use_Ansi_Colors = 0;
	/*
	 * Make sure our flags are in register.  - FM
	 */
	if (SLtt_Use_Ansi_Colors == 1) {
	    if (LYShowColor != SHOW_COLOR_ALWAYS) {
		LYShowColor = SHOW_COLOR_ON;
	    }
	} else {
	    if (LYShowColor != SHOW_COLOR_NEVER) {
		LYShowColor = SHOW_COLOR_OFF;
	    }
	}
	size_change(0);

#if (defined(VMS) || defined(REAL_UNIX_SYSTEM)) && !defined(__CYGWIN__)
	if ((Masked_Attr & SLTT_ULINE_MASK) == 0) {
	    SLtt_add_color_attribute(4, SLTT_ULINE_MASK);
	    SLtt_add_color_attribute(5, SLTT_ULINE_MASK);
	}
	/*
	 * If set, the blink escape sequence will turn on high intensity
	 * background (rxvt and maybe Linux console).
	 */
	SLtt_Blink_Mode = term_blink_is_boldbg;
#endif /* (VMS || REAL_UNIX_SYSTEM) && !__CYGWIN__  */
    }
#ifdef __DJGPP__
    _eth_init();
#endif /* __DJGPP__ */

    slinit = 1;
    Current_Attr = 0;
#ifndef VMS
#if SLANG_VERSION > 9929
    SLang_init_tty(-1, 0, 1);
#else
    SLang_init_tty(3, 0, 1);
#endif /* SLANG_VERSION > 9929 */
#endif /* !VMS */
    SLsmg_init_smg();
    SLsmg_Display_Eight_Bit = LYlowest_eightbit[current_char_set];
    if (SLsmg_Display_Eight_Bit > 191)
	SLsmg_Display_Eight_Bit = 191;	/* may print ctrl chars otherwise - kw */
    scrollok(0, 0);
    SLsmg_Backspace_Moves = 1;
#if SLANG_VERSION > 10306
    SLsmg_touch_screen();
#endif
#ifndef VMS
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
    SLtty_set_suspend_state(1);
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
#ifdef SIGTSTP
    if (!no_suspend)
	signal(SIGTSTP, sl_suspend);
#endif /* SIGTSTP */
    signal(SIGINT, cleanup_sig);
#endif /* !VMS */

    lynx_enable_mouse(1);

#else /* USE_SLANG; Now using curses: */
    int keypad_on = 0;

#ifdef VMS
    /*
     * If we are VMS then do initscr() everytime start_curses() is called!
     */
    CTRACE((tfp, "Screen size: initscr()\n"));
    initscr();			/* start curses */
#else /* Unix: */

#ifdef __CYGWIN__
    /*
     * Workaround for buggy Cygwin, which breaks subprocesses of a
     * full-screen application (tested with cygwin dll, dated
     * 2002/6/23 -TD)
     */
    if (!lynx_called_initscr) {
	FILE *fp = fopen("/dev/tty", "w");

	if (fp != 0)
	    stdout = fp;
    }
#endif

    if (!LYscreen) {
	/*
	 * If we're not VMS then only do initscr() one time, and one time only!
	 */
#if defined(HAVE_NEWTERM)
#if !(defined(NCURSES) && !defined(HAVE_RESIZETERM))
	BOOLEAN savesize;

	savesize = recent_sizechange;
	size_change(0);
	recent_sizechange = savesize;	/* avoid extra redraw */
#if defined(__MVS__)
	{
	    /*
	     * The requirement to do this may be a bug in OS/390.
	     *
	     * Put screen geometry in environment variables used by
	     * XOpen curses before calling newterm().  I believe this
	     * completes work left unfinished by AJL & FM -- gil
	     */
	    static char lines_putenv[] = "LINES=abcde", cols_putenv[] = "COLUMNS=abcde";

	    sprintf(lines_putenv + 6, "%d", LYlines & 0xfff);
	    sprintf(cols_putenv + 8, "%d", LYcols & 0xfff);
	    putenv(lines_putenv);
	    putenv(cols_putenv);
	    CTRACE((tfp, "start_curses putenv %s, %s\n", lines_putenv, cols_putenv));
	}
#endif /* defined(__MVS__) */
#endif /* !(defined(NCURSES) && defined(HAVE_RESIZETERM)) */
	CTRACE((tfp, "Screen size: %s()\n", NEWTERM_NAME));
	if (!(LYscreen = newterm(NULL, stdout, stdin))) {	/* start curses */
	    fprintf(tfp, "%s\n",
		    gettext("Terminal initialisation failed - unknown terminal type?"));
	    exit_immediately(EXIT_FAILURE);
	}
#else
	CTRACE((tfp, "Screen size: initscr()\n"));
	initscr();
#endif /* HAVE_NEWTERM */
	lynx_called_initscr = TRUE;
	LYlines = LYscreenHeight();
	LYcols = LYscreenWidth();

#if defined(SIGWINCH) && defined(NCURSES_VERSION)
	size_change(0);
	recent_sizechange = FALSE;	/* prevent mainloop drawing 1st doc twice */
#endif /* SIGWINCH */
	CTRACE((tfp, "Screen size is now %d x %d\n", LYlines, LYcols));

#ifdef USE_CURSES_PADS
	if (LYuseCursesPads) {
	    LYwin = newpad(LYlines, MAX_COLS);
	    LYshiftWin = 0;
	    LYwideLines = FALSE;
	} else {
	    LYwin = stdscr;
	}
#endif

#if defined(USE_KEYMAPS) && defined(NCURSES_VERSION)
#  if HAVE_KEYPAD
	/* Need to switch keypad on before initializing keymaps, otherwise
	   when the keypad is switched on, some keybindings may be overriden. */
	keypad(LYwin, TRUE);
	keypad_on = 1;
#  endif			/* HAVE_KEYPAD */

	if (-1 == lynx_initialize_keymaps()) {
	    endwin();
	    exit_immediately(EXIT_FAILURE);
	}
#endif

	/*
	 * This is a workaround for a bug in SVr4 curses, observed on Solaris
	 * 2.4:  if your terminal's alternate-character set contains codes in
	 * the range 128-255, they'll be sign-extended in the acs_map[] table,
	 * which in turn causes their values to be emitted as 255 (0xff).
	 * "Fix" this by forcing the table to 8-bit codes (it has to be
	 * anyway).
	 */
#if defined(ALT_CHAR_SET) && !defined(NCURSES_VERSION)
	{
	    int n;

	    for (n = 0; n < 128; n++)
		if (ALT_CHAR_SET[n] & 0x80) {
		    ALT_CHAR_SET[n] &= 0xff;
		    ALT_CHAR_SET[n] |= A_ALTCHARSET;
		}
	}
#endif

#if defined(USE_COLOR_STYLE) || defined(USE_COLOR_TABLE)
	if (has_colors()) {
	    lynx_has_color = TRUE;
	    start_color();

#ifndef COLORS
	    /* map2boldc() relies on COLORS being a power of 2 */
	    if (COLORS > 16)
		COLORS = 16;
	    if (COLORS < 8)
		COLORS = 2;
	    if (COLORS > 8 && COLORS != 16)
		COLORS = 8;
#endif

#ifdef USE_DEFAULT_COLORS
#if defined(EXP_ASSUMED_COLOR) && defined(USE_COLOR_TABLE)
	    /*
	     * Adjust the color mapping table to match the ASSUMED_COLOR
	     * setting in lynx.cfg
	     */
	    if (assume_default_colors(default_fg, default_bg) != OK) {
		default_fg = COLOR_WHITE;
		default_bg = COLOR_BLACK;
	    }
	    CTRACE((tfp, "initializing default colors %d/%d\n",
		    default_fg, default_bg));
	    if (default_fg >= 0 || default_bg >= 0) {
		unsigned n;

		for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
		    if (default_fg >= 0 && lynx_color_cfg[n].fg < 0)
			lynx_color_cfg[n].fg = default_fg;
		    if (default_bg >= 0 && lynx_color_cfg[n].bg < 0)
			lynx_color_cfg[n].bg = default_bg;
		    CTRACE((tfp, "color_cfg[%d] = %d/%d\n", n,
			    lynx_color_cfg[n].fg,
			    lynx_color_cfg[n].bg));
		}
		lynx_setup_colors();
	    }
#else
#if defined(HAVE_USE_DEFAULT_COLORS)
	    lynx_default_colors();
#endif /* HAVE_USE_DEFAULT_COLORS */
#endif /* EXP_ASSUMED_COLOR */
#endif /* USE_DEFAULT_COLORS */
	}
#endif /* USE_COLOR_STYLE || USE_COLOR_TABLE */

#ifdef USE_COLOR_STYLE
	parse_userstyles();
#endif
#ifdef USE_COLOR_TABLE
	lynx_init_colors();
#endif /* USE_COLOR_TABLE */
    }
#ifdef __DJGPP__
    _eth_init();
#endif /* __DJGPP__ */
#endif /* not VMS */

/* nonl();   *//* seems to slow things down */

#ifdef VMS
    crmode();
    raw();
#else
#ifdef HAVE_CBREAK
    cbreak();
#else
    crmode();
#endif /* HAVE_CBREAK */
    signal(SIGINT, cleanup_sig);
#endif /* VMS */

    noecho();

#ifdef HAVE_KEYPAD
    if (!keypad_on)
	keypad(LYwin, TRUE);
#endif /* HAVE_KEYPAD */

    lynx_enable_mouse(1);

    fflush(stdin);
    fflush(stdout);
    fflush(stderr);
#endif /* USE_SLANG */

#if defined(WIN_EX)
    LYclear();
#endif

#if defined(USE_BLINK) && defined(__EMX__)
    if (term_blink_is_boldbg)	/* Now actually make it so! */
	make_blink_boldbg();
#endif

    LYCursesON = TRUE;
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    if ((scrsize_x != 0) && (scrsize_y != 0)) {
	if (saved_scrsize_x == 0) {
	    saved_scrsize_x = COLS;
	    saved_scrsize_y = LINES;
	}
	CTRACE((tfp, "resize_term: x=%d, y=%d\n", scrsize_x, scrsize_y));
	CTRACE((tfp, "saved terminal size: x=%d, y=%d\n", saved_scrsize_x, saved_scrsize_y));
	resize_term(scrsize_y, scrsize_x);
	LYclear();
    }
#endif
    CTRACE((tfp, "start_curses: done.\n"));
}				/* end of start_curses() */

void lynx_enable_mouse(int state)
{
#ifdef USE_MOUSE
/***********************************************************************/

#if defined(WIN_EX)
/* modify lynx_enable_mouse() for pdcurses configuration so that mouse support
   is disabled unless -use_mouse is specified
*/
    HANDLE hConIn = INVALID_HANDLE_VALUE;

    hConIn = GetStdHandle(STD_INPUT_HANDLE);
    if (LYUseMouse == 0) {
	SetConsoleMode(hConIn, ENABLE_WINDOW_INPUT);
	FlushConsoleInputBuffer(hConIn);
	return;
    }
#endif

    if (LYUseMouse == 0)
	return;

#if defined(USE_SLANG)
    SLtt_set_mouse_mode(state, 0);
    SLtt_flush_output();
#else

#if defined(WIN_EX) && defined(PDCURSES)
    if (state) {
	SetConsoleMode(hConIn, ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT);
	FlushConsoleInputBuffer(hConIn);
    }
#else
#if defined(NCURSES)
    if (state) {
	/* Compensate for small value of maxclick in ncurses.  */
	static int was = 0;

	if (!was) {
	    int old = mouseinterval(-1);

	    was++;
	    if (old < 200)	/* Default 166 */
		mouseinterval(300);
	}
	/* Inform ncurses which mouse events we're interested in.
	 * We shouldn't need to include BUTTONn_PRESSED and BUTTONn_RELEASED
	 * events, since ncurses should translate them to click events. - kw
	 * However, if we do not include them, then ncurses effectively
	 * ignores mouseinterval(), thus translates *any* sequence of
	 * press/release to a click, which leads to inconveniences.
	 * We special-case these events in LYStrings.c.
	 */
	mousemask(BUTTON_CTRL | BUTTON_ALT
		  | BUTTON1_PRESSED | BUTTON1_RELEASED
		  | BUTTON1_CLICKED
		  | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
		  | BUTTON2_PRESSED | BUTTON2_RELEASED
		  | BUTTON2_CLICKED
		  | BUTTON3_PRESSED | BUTTON3_RELEASED
		  | BUTTON3_CLICKED
		  | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED,
		  NULL);
    } else
	mousemask(0, NULL);
#endif /* NCURSES */
#endif /* WIN_EX and PDCURSES */

#if defined(PDCURSES)
    if (state)
	mouse_set(
		     BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		     BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		     BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
#endif
#endif /* NOT USE_SLANG */

/***********************************************************************/
#endif /* USE_MOUSE */
}

/*
 * SVr4 curses (and ncurses) initialize the terminal I/O to raw mode, and
 * simulate other modes in the library.  This means that when running, it
 * simulates the OCRNL setting.  Normally that is not a problem.  However, when
 * spawning a subprocess (e.g., xli), the subprocess may write to the screen.
 * Fine so far - curses resets the terminal I/O to the normal state on exit.
 * But the subprocess's messages can still be coming to the screen when lynx
 * returns to the screen mode.  This function delays restoring OCRNL until
 * after the first getch() call.
 *
 * The OCRNL setting is controlled by nl()/nonl() of course - but we do not
 * want to give up that optimization since it would be a bit slower.  (Note -
 * slang does not use this optimization; if it did, the same screen glitch
 * would occur).
 *
 * FIXME:  for simplicity, only ncurses is implemented here - the TTY and
 * SET_TTY definitions are ncurses-specific.  The same effect could be done for
 * other curses implementations, since the "cur_term->Nttyb" part is common to
 * SVr4 curses.
 */
void lynx_nl2crlf(int normal GCC_UNUSED)
{
#if defined(NCURSES_VERSION_PATCH) && defined(SET_TTY) && defined(TERMIOS) && defined(ONLCR)
    static TTY saved_tty;
    static int did_save = FALSE;
    static int waiting = FALSE;
    static int can_fix = TRUE;

    if (!did_save) {
	saved_tty = cur_term->Nttyb;
	did_save = TRUE;
#if NCURSES_VERSION_PATCH < 20010529
	/* workaround for optimizer bug with nonl() */
	if ((tigetstr("cud1") != 0 && *tigetstr("cud1") == '\n')
	    || (tigetstr("ind") != 0 && *tigetstr("ind") == '\n'))
	    can_fix = FALSE;
#endif
    }
    if (can_fix) {
	if (normal) {
	    if (!waiting) {
		cur_term->Nttyb.c_oflag |= ONLCR;
		waiting = TRUE;
		nonl();
	    }
	} else {
	    if (waiting) {
		cur_term->Nttyb = saved_tty;
		SET_TTY(fileno(stdout), &saved_tty);
		waiting = FALSE;
		nl();
		LYrefresh();
	    }
	}
    }
#endif
}

void stop_curses(void)
{
    if (LYCursesON) {
	echo();
    }
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    resetty();
#endif
#ifdef __DJGPP__
    _eth_release();
#endif /* __DJGPP__ */

#if defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC))
#ifdef __DJGPP__
    ScreenClear();
#else
#ifdef __MINGW32__
    clear();
#else
    clrscr();
#endif
#endif
#else

    if (LYCursesON == TRUE) {
	lynx_nl2crlf(TRUE);
	lynx_enable_mouse(0);
#if 1 /* (!defined(WIN_EX) || defined(__CYGWIN__)) */	/* @@@@@@ */
#ifdef WIN_EX
	if (system_is_NT)
#endif
	    if (LYscreen || lynx_called_initscr) {
		endwin();	/* stop curses */
		LYDELSCR();
	    }
#endif
    }
#ifdef SH_EX
    {
	int i;

	for (i = 0; i <= 3; i++) {
	    fprintf(stdout, "\r\n");
	}
    }
#endif

    fflush(stdout);
#endif /* defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC)) */
    fflush(stderr);

    LYCursesON = FALSE;
    CTRACE((tfp, "stop_curses: done.\n"));

#if defined(SIGTSTP) && defined(USE_SLANG)
#ifndef VMS
    if (!no_suspend)
	signal(SIGTSTP, SIG_DFL);
#endif /* !VMS */
#endif /* SIGTSTP && USE_SLANG */

#ifndef VMS
    signal(SIGINT, SIG_DFL);
#endif /* !VMS */
}

#ifdef VMS

#ifdef USE_SLANG
extern void longname(char *, char *);
#endif /* USE_SLANG */

/*
 * Check terminal type, start curses & setup terminal.
 */
BOOLEAN setup(char *terminal)
{
    int c;
    int status;
    char *dummy = 0, *cp, term[81];

    /*
     * If the display was not set by a command line option then see if it is
     * available from the environment.
     */
    if ((cp = LYgetXDisplay()) != 0) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }

    /*
     * Get terminal type, and convert to lower case.
     */
    term[0] = '\0';
    longname(dummy, term);
    if (term[0] == '\0' && (form_get_data || form_post_data)) {
	/*
	 * Some yoyo used these under conditions which require -dump, so force
	 * that mode here.  - FM
	 */
	dump_output_immediately = TRUE;
	LYcols = DFT_COLS;
	if (keypad_mode == NUMBERS_AS_ARROWS)
	    keypad_mode = LINKS_ARE_NUMBERED;
	status = mainloop();
	exit_immediately(status);
    }
    LYLowerCase(term);

    printf("%s%s\n", gettext("Terminal ="), term);
    if ((strlen(term) < 5) ||
	strncmp(term, "vt", 2) || !isdigit(term[2])) {
	printf("%s\n",
	       gettext("You must use a vt100, 200, etc. terminal with this program."));
	printf(CONFIRM_PROCEED, "n/y");
	c = getchar();
	if (c != 'y' && c != 'Y') {
	    printf("\n");
	    return (FALSE);
	}
	strcpy(term, "vt100");
    }

    ttopen();
    start_curses();

    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();

    return (TRUE);
}

#else /* Not VMS: */

/*
 * Check terminal type, start curses & setup terminal.
 */
BOOLEAN setup(char *terminal)
{
    char *term_putenv = NULL;
    char *buffer = NULL;
    char *cp;

    /*
     * If the display was not set by a command line option then see if it is
     * available from the environment .
     */
    if ((cp = LYgetXDisplay()) != NULL) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }

    if (terminal != NULL) {
	HTSprintf0(&term_putenv, "TERM=%.106s", terminal);
	(void) putenv(term_putenv);
    }

    /*
     * Query the terminal type.
     */
    if (dumbterm(LYGetEnv("TERM"))) {
	printf("\n\n  %s\n\n", gettext("Your Terminal type is unknown!"));
	printf("  %s [vt100] ", gettext("Enter a terminal type:"));

	if (LYSafeGets(&buffer, stdin) != 0) {
	    LYTrimLeading(buffer);
	    LYTrimTrailing(buffer);
	}

	if (isEmpty(buffer))
	    StrAllocCopy(buffer, "vt100");

	HTSprintf0(&term_putenv, "TERM=%.106s", buffer);
	FREE(buffer);

	(void) putenv(term_putenv);
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"),
	       LYGetEnv("TERM"));
	LYSleepMsg();
    }

    start_curses();

#ifdef HAVE_TTYTYPE
    /*
     * Account for lossage on the 'sun' terminal type (80x24) Sun text console
     * driver.  It only supports reverse video, but all SGR sequences produce
     * that same reverse video, and the terminfo entry lists different SGRs for
     * 'bold' and 'rev'.  As a result, the current link is indistinguishable
     * from all other links.  The workaround here is to disable the 'rev'
     * capability.
     */
    if ((strncmp((const char *) ttytype, "sun", 3) == 0)) {
	LYnoVideo(2);
    }
#endif /* HAVE_TTYTYPE */

    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();

    return (1);
}

static int dumbterm(char *terminal)
{
    int dumb = FALSE;

    /*
     * Began checking for terminal == NULL in case that TERM environment
     * variable is not set.  Thanks to Dick Wesseling (ftu@@fi.ruu.nl).
     */
    if (terminal == NULL ||
	!strcasecomp(terminal, "network") ||
	!strcasecomp(terminal, "unknown") ||
	!strcasecomp(terminal, "dialup") ||
	!strcasecomp(terminal, "dumb") ||
	!strcasecomp(terminal, "switch") ||
	!strcasecomp(terminal, "ethernet"))
	dumb = TRUE;
    return (dumb);
}

#ifdef FANCY_CURSES
#ifndef USE_COLOR_STYLE
#ifdef USE_COLOR_TABLE
void LYaddWAttr(WINDOW * win, int a)
{
    Current_Attr |= a;
    LYsetWAttr(win);
}

void LYaddAttr(int a)
{
    LYaddWAttr(LYwin, a);
}

void LYsubWAttr(WINDOW * win, int a)
{
    Current_Attr &= ~a;
    LYsetWAttr(win);
}

void LYsubAttr(int a)
{
    LYsubWAttr(LYwin, a);
}
#endif /* USE_COLOR_TABLE */
#endif /* !USE_COLOR_STYLE */
#endif /* FANCY_CURSES */
#endif /* VMS */

/* Use this rather than the 'wprintw()' function to write a blank-padded
 * string to the given window, since someone's asserted that printw doesn't
 * handle 8-bit characters unlike addstr (though more info would be useful).
 *
 * We're blank-filling so that with SVr4 curses, it'll show the background
 * color to a uniform width in the popup-menu.
 */
#ifndef USE_SLANG
void LYpaddstr(WINDOW * the_window, int width,
	       const char *the_string)
{
    int y, x;
    int actual = strlen(the_string);

    getyx(the_window, y, x);
    if (width + x > LYcolLimit)
	width = LYcolLimit - x;
    if (actual > width)
	actual = width;
    LYwaddnstr(the_window, the_string, actual);
    width -= actual;
    while (width-- > 0)
	waddstr(the_window, " ");
}

/*
 * Workaround a bug in ncurses order-of-refresh by setting a pointer to
 * the topmost window that should be displayed.
 *
 * FIXME: the associated call on 'keypad()' is not needed for Unix, but
 * something in the OS/2 EMX port requires it.
 */
static WINDOW *my_subwindow;

void LYsubwindow(WINDOW * param)
{
    if (param != 0) {
	my_subwindow = param;
#if defined(NCURSES) || defined(PDCURSES)
	keypad(my_subwindow, TRUE);
#if defined(HAVE_GETBKGD)	/* not defined in ncurses 1.8.7 */
	wbkgd(my_subwindow, getbkgd(LYwin));
	wbkgdset(my_subwindow, getbkgd(LYwin));
#endif
#endif
	scrollok(my_subwindow, TRUE);
    } else {
	touchwin(LYwin);
	delwin(my_subwindow);
	my_subwindow = 0;
    }
}

WINDOW *LYtopwindow(void)
{
    return (my_subwindow ? my_subwindow : LYwin);
}
#endif

WINDOW *LYstartPopup(int *top_y,
		     int *left_x,
		     int *height,
		     int *width)
{
    WINDOW *form_window = 0;

#ifdef USE_SLANG
    static WINDOW fake_window;

    if (*left_x < 1 || (*left_x + *width + 4) >= LYcolLimit) {
	*left_x = 1;
	*width = LYcolLimit - 5;
    }

    SLsmg_fill_region(*top_y, *left_x - 1, *height, *width + 4, ' ');
    form_window = &fake_window;
    form_window->top_y = *top_y;
    form_window->left_x = *left_x;
    form_window->height = *height;
    form_window->width = *width;
#else
    if (*left_x > 0 && (*left_x + *width + 4) < LYcolLimit)
	form_window = newwin(*height, *width + 4, *top_y, *left_x - 1);
    if (form_window == 0) {
	*width = LYcolLimit - 4;
	form_window = newwin(*height, LYcolLimit, *top_y, 0);
    }
    if (form_window == 0) {
	HTAlert(POPUP_FAILED);
    } else {
	LYsubwindow(form_window);
#  ifdef USE_COLOR_STYLE
	{
	    long b;

	    /* Get a proper value for the attribute */
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_ON);
	    b = LYgetattrs(form_window);
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_OFF);
	    wbkgd(form_window, b | ' ');
	    /* wbkgdset does not make a lot of sense with USE_COLOR_STYLE
	       since it *forces* attributes on all the cells in the window.
	       Undo the change done in LYsubwindow, since we set our styles.
	     */
	    wbkgdset(form_window, (b & ~(A_BOLD | A_BLINK)) | ' ');
	}
#  endif
    }
#endif /* USE_SLANG */
    return form_window;
}

void LYstartTargetEmphasis(void)
{
#ifdef USE_COLOR_STYLE
    if (s_whereis != NOSTYLE) {
	curses_style(s_whereis, STACK_ON);
	return;
    }
#endif
#if defined(FANCY_CURSES) || defined(USE_SLANG)
    lynx_start_bold();
    lynx_start_reverse();
#endif /* FANCY_CURSES || USE_SLANG */
    lynx_start_underline();
}

void LYstopTargetEmphasis(void)
{
#ifdef USE_COLOR_STYLE
    if (s_whereis != NOSTYLE) {
	curses_style(s_whereis, STACK_OFF);
	return;
    }
#endif
    lynx_stop_underline();
#if defined(FANCY_CURSES) || defined(USE_SLANG)
    lynx_stop_reverse();
    lynx_stop_bold();
#endif /* FANCY_CURSES || USE_SLANG */
}

/*
 * Accommodate the different flavors of touchline
 */
void LYtouchline(int row)
{
#if defined(HAVE_WREDRAWLN) && !defined(NCURSES_VERSION)
    wredrawln(LYwin, row, 1);
#else
#if defined(HAVE_TOUCHLINE)
    /* touchline() is not available on VMS before version 7.0, and then only on
     * Alpha, since prior ports of curses were broken.  BSD touchline() has a
     * 4th parameter since it is used internally by touchwin().
     */
#if defined(HAVE_BSD_TOUCHLINE)
    touchline(LYwin, row, 0, COLS);
#else
    touchline(LYwin, row, 1);
#endif
#else
#if !defined(USE_SLANG)
    touchwin(LYwin);
#else
    SLsmg_touch_lines(row, 1);
#endif
#endif
#endif
}

/*
 * Wrapper for waddnstr().
 */
void LYwaddnstr(WINDOW * w GCC_UNUSED,
		const char *src,
		size_t len)
{
    /*
     * We only want to trace this function for the color-style code.  It would
     * be too much logging if not needed.
     */
#ifdef USE_COLOR_STYLE
    if (TRACE) {
	int y, x;

	LYGetYX(y, x);
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n",
			      y, x, (int) len, src));
    }
#endif
    /*
     * Wide (multibyte) characters are always written as part of a string.  So
     * we can handle the conversion in one place.
     *
     * X/Open curses documents addstr() as able to handle multibyte sequences
     * directly, but that is not (2001/11/5) yet implemented in ncurses.  Two
     * alternatives are possible:  translating the string to an array of
     * wchar_t's or to an array of cchar_t's.  The former is more direct.  Both
     * have problems with combining-characters in this version of ncurses
     * (successive calls are not merged), so I'm using them for testing -TD
     */
#if 0				/* defined(WIDEC_CURSES) && defined(HAVE_MBSTATE_T) */
#if 1				/* array of wchar_t's */
    {
	static wchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	unsigned j;
	size_t need;

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(wchar_t, used);
	}
	for (j = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t) (-1) || rc == (size_t) (-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    temp[l++] = wch;
	}
	temp[l] = L'\0';
	waddnwstr(w, temp, l);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
    }
#else /* array of cchar_t's */
    {
	static cchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	wchar_t wstr[CCHARW_MAX + 1];
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	int y, x;
	unsigned j, k;
	size_t need;
	attr_t attr;
	short pair;

	wattr_get(w, &attr, &pair, (void *) 0);

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(cchar_t, used);
	}
	for (j = k = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t) (-1) || rc == (size_t) (-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    if ((width > 0 && l > 0) || l == CCHARW_MAX) {
		wstr[l] = L'\0';
		l = 0;
		if (setcchar(temp + k, wstr, attr, 0, NULL) != OK)
		    break;
		++k;
	    }
	    if (width == 0 && l == 0)
		wstr[l++] = L' ';
	    wstr[l++] = wch;
	}
	if (l > 0) {
	    wstr[l] = L'\0';
	    if (setcchar(temp + k, wstr, attr, 0, NULL) == OK)
		++k;
	}
	setcchar(temp + k, L"", 0, 0, NULL);
	wadd_wchnstr(w, temp, k);
	getyx(w, y, x);		/* we didn't move - do it now */
	wmove(w, y, x + k);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
    }
#endif
#else
    /*
     * There's no guarantee that a library won't temporarily write on its input.
     * Be safe and copy it when we have const-data.
     */
    while (len > 0) {
	char temp[MAX_LINE];
	size_t use = (len >= MAX_LINE) ? MAX_LINE - 1 : len;

	memcpy(temp, src, use);
	temp[use] = 0;
	waddstr(w, temp);
	len -= use;
    }
#endif
}

/*
 * Determine the number of cells the given string would take up on the screen,
 * limited by the maxCells parameter.  This is used for constructing aligned
 * text in the options and similar forms.
 *
 * FIXME: make this account for wrapping, too.
 * FIXME: make this useful for "lynx -dump", which hasn't initialized curses.
 */
int LYstrExtent(const char *string, int len, int maxCells)
{
    int result = 0;
    int used;

    if (len < 0)
	used = strlen(string);
    else
	used = len;

    result = used;
#ifdef WIDEC_CURSES
    if (used > 0 && lynx_called_initscr) {
	static WINDOW *fake_win;
	static int fake_max;
	int n;

	if (fake_max < maxCells) {
	    fake_max = (maxCells + 1) * 2;
	    if (fake_win != 0) {
		delwin(fake_win);
		fake_win = 0;
	    }
	}
	if (fake_win == 0) {
	    fake_win = newwin(2, fake_max, 0, 0);
	}
	if (fake_win != 0) {
	    int new_x = 0;
	    int new_y = 0;

	    result = 0;
	    wmove(fake_win, 0, 0);
	    for (n = 0; n < used; ++n) {
		if (IsNormalChar(string[n])) {
		    waddch(fake_win, UCH(string[n]));
		    getyx(fake_win, new_y, new_x);
		    if (new_y > 0 || new_x > maxCells)
			break;
		    result = new_x;
		}
	    }
	}
    }
#endif
    if (result > maxCells)
	result = maxCells;
    return result;
}

/*
 * A simple call that relies upon the coincidence that multicell characters
 * use at least as many bytes as cells.
 */
int LYstrExtent2(const char *string, int len)
{
    return LYstrExtent(string, len, len);
}

/*
 * Returns the total number of cells that the string would use.
 */
int LYstrCells(const char *string)
{
    return LYstrExtent2(string, strlen(string));
}

#ifdef VMS
/*
 *	Cut-down termio --
 *		Do character-oriented stream input for Jeff.
 *		Code ripped off from Micro-Emacs 3.7 by Daniel Lawrence.
 *
 *		Ever-so-slightly modified by Kathryn Huxtable.	29-Jan-1991.
 *		Cut down for Lou.  8 Sep 1992.
 *		Cut down farther for Lou.  19 Apr 1993.
 *			We don't set PASSALL or PASTHRU since we don't
 *			want to block CTRL/C, CTRL/Y, CTRL/S or CTRL/Q.
 *			Simply setting NOECHO and doing timed reads
 *			is sufficient.
 *		Further mods by Fote.  29-June-1993
 *			ttopen() and ttclose() are now terminal initialization
 *			 and restoration procedures, called once at startup
 *			 and at exit, respectively, of the LYNX image.
 *			ttclose() should be called before an exit from LYNX
 *			 no matter how the exit is invoked.
 *			setup(terminal) does the ttopen().
 *			cleanup() calls cleanup_files() and ttclose().
 *			ttgetc() now handles NOECHO and NOFLITR (instead of
 *			 setting the terminal itself to NOECHO in ttopen()).
 *			VMSsignal() added for handling both Ctrl-C *and* Ctrl-Y
 *			 interrupts, and disabling system response to Ctrl-T.
 *		Further mods by Fote.  15-Dec-1993
 *			Added edit handler in ttopen() which will invoke
 *			 VMSexit() and behave intelligently on ACCVIO's.
 *		Further mods by Fote.  29-Dec-1993
 *			Simplified ttgetc().
 *		Further mods by Fote.  16-Jan-1994
 *			Added code in ttopen() which will invoke VMSVersion()
 *			 to get the version of VMS as VersionVMS for use by
 *			 by new or modified interrupt or spawning routines.
 *		Further mods by Fote.  27-Jan-1994
 *			Added back a typeahead() which supports 'z' or 'Z' as
 *			an "Zap transfer" command via HTCheckForInterrupt()
 *			in LYUtils.c.
 */

#include <descrip.h>
#include <iodef.h>
#include <ssdef.h>
#include <msgdef.h>
#include <ttdef.h>
#include <tt2def.h>
#include <libclidef.h>
#include <lib$routines.h>
#include <starlet.h>
#include <clidef.h>
#include <syidef.h>
#ifdef signal
#undef signal
#endif /* signal */
#include <signal.h>
#ifdef system
#undef system
#endif /* system */
#include <processes.h>
#include <LYVMSdef.h>

#define EFN	0		/* Event flag                   */

static unsigned char buffer[20];	/* Input buffer                 */
static int in_pos, in_len;	/* For escape sequences         */
static int oldmode[3];		/* Old TTY mode bits            */
static int newmode[3];		/* New TTY mode bits            */
static short iochan;		/* TTY I/O channel              */
static $DESCRIPTOR(term_nam_dsc, "TT");		/* Descriptor for iochan        */
static unsigned long mask = LIB$M_CLI_CTRLY | LIB$M_CLI_CTRLT;	/* ^Y and ^T */
static unsigned long old_msk;	/* Saved control mask           */
static short trap_flag = FALSE;	/* TRUE if AST is set           */
BOOLEAN DidCleanup = FALSE;	/* Exit handler flag            */
static char VersionVMS[20];	/* Version of VMS               */

int VMSVersion(char *VerString,
	       int VerLen)
{
    unsigned long status, itm_cod = SYI$_VERSION;
    int i, verlen = 0;
    struct dsc$descriptor version;
    char *m;

    version.dsc$a_pointer = VerString;
    version.dsc$w_length = VerLen - 1;
    version.dsc$b_dtype = DSC$K_DTYPE_B;
    version.dsc$b_class = DSC$K_CLASS_S;

    status = lib$getsyi(&itm_cod, 0, &version, &verlen, 0, 0);
    if (!(status & 1) || verlen == 0)
	return 0;

    /*
     * Cut out trailing spaces
     */
    for (m = VerString + verlen, i = verlen - 1; i > 0 && VerString[i] == ' '; --i)
	*(--m) = '\0';

    return strlen(VerString) + 1;	/* Transmit ending 0 too */
}

void VMSexit(void)
{
    /*
     * If we get here and DidCleanup is not set, it was via an ACCVIO, or
     * outofmemory forced exit, so make *sure* we attempt a cleanup and reset
     * the terminal.
     */
    if (!DidCleanup) {
	if (LYOutOfMemory == FALSE) {
	    fprintf(stderr,
		    gettext("\nA Fatal error has occurred in %s Ver. %s\n"),
		    LYNX_NAME, LYNX_VERSION);
	    fprintf(stderr,
		    gettext("\nPlease notify your system administrator to confirm a bug, and if\n\
confirmed, to notify the lynx-dev list.  Bug reports should have concise\n\
descriptions of the command and/or URL which causes the problem, the\n\
operating system name with version number, the TCPIP implementation, the\n\
TRACEBACK if it can be captured, and any other relevant information.\n"));

	    if (LYTraceLogFP == NULL) {
		fprintf(stderr, RETURN_TO_CLEANUP);
		(void) getchar();
	    }
	} else if (LYCursesON) {
	    HTAlert(MEMORY_EXHAUSTED_ABORT);
	}
	cleanup();
    }
    if (LYOutOfMemory == TRUE) {
	printf("\r\n%s\r\n\r\n", MEMORY_EXHAUSTED_ABORT);
	fflush(stdout);
	fflush(stderr);
    }
}

/*
 *	TTOPEN --
 *		This function is called once to set up the terminal
 *		device streams.  It translates TT until it finds
 *		the terminal, then assigns a channel to it, sets it
 *		to EDIT, and sets up the Ctrl-C and Ctrl-Y interrupt
 *		handling.
 */
int ttopen(void)
{
    int iosb[2];
    int status;
    static unsigned long condition;
    static struct _exit_block {
	unsigned long forward;
	unsigned long address;
	unsigned long zero;
	unsigned long condition;
    } exit_handler_block;

    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = sys$qiow(EFN, iochan, IO$_SENSEMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit_immediately(status);

    newmode[0] = oldmode[0];
    newmode[1] = oldmode[1];
    newmode[2] = oldmode[2] | TT2$M_EDIT;

    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &newmode, sizeof(newmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit_immediately(status);

    /*
     * Declare the exit handler block.
     */
    exit_handler_block.forward = 0;
    exit_handler_block.address = (unsigned long) &VMSexit;
    exit_handler_block.zero = 0;
    exit_handler_block.condition = (unsigned long) &condition;
    status = sys$dclexh(&exit_handler_block);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    /*
     * Set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      &cleanup_sig, SIGINT, 0, 0, 0, 0);
    if (status != SS$_NORMAL) {
	lib$enable_ctrl(&old_msk);
	exit_immediately(status);
    }

    /*
     * Get the version of VMS.
     */
    if (VMSVersion(VersionVMS, 20) < 3)
	/*
	 * Load zeros on error.
	 */
	strcpy(VersionVMS, "V0.0-0");

    return (0);
}				/*  ttopen  */

/*
 *	TTCLOSE --
 *		This function gets called just before we go back home
 *		to the command interpreter.  It puts the terminal back
 *		in a reasonable state.
 */
int ttclose(void)
{
    int status;
    int iosb[1];

    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);

    if (status != SS$_NORMAL || (iosb[0] & 0xFFFF) != SS$_NORMAL)
	exit_immediately(status);

    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }
    return (0);
}				/*  ttclose  */

/*
 *	TTGETC --
 *		Read a character from the terminal, with NOECHO and NOFILTR.
 */
int ttgetc(void)
{
    int status;
    unsigned short iosb[4];

    if (in_pos < in_len)
	return (buffer[in_pos++]);

    status = sys$qiow(EFN, iochan,
		      IO$_READVBLK | IO$M_NOECHO | IO$M_NOFILTR,
		      &iosb, 0, 0,
		      &buffer, 1, 0, 0, 0, 0);
    if ((status & 1) == 1)
	status = iosb[0];
    if (status == SS$_PARTESCAPE) {
	/*
	 * Escape sequence in progress.  Fake a successful read.
	 */
	status = 1;
    }
    if ((status & 1) != 1 && status != SS$_DATAOVERUN)
	exit_immediately(status);
    in_pos = 1;
    in_len = iosb[1] + iosb[3];
    return (buffer[0]);
}

/*
 *	TYPEAHEAD -- Fote Macrides 27-Jan-1994
 *		Check whether a keystroke has been entered, and return
 *		 it, or -1 if none was entered.
 */
int typeahead(void)
{
    int status;
    unsigned short iosb[4];

    if (dump_output_immediately)
	return -1;

    if (in_pos < in_len)
	return (buffer[in_pos++]);

  again:
    status = sys$qiow(EFN, iochan,
		      IO$_READVBLK | IO$M_TIMED | IO$M_NOECHO | IO$M_NOFILTR,
		      &iosb, 0, 0,
		      &buffer, 1, 0, 0, 0, 0);
    if ((status & 1) == 1)
	status = iosb[0];
    if (status == SS$_PARTESCAPE) {
	/*
	 * Escape sequence in progress, finish reading it.
	 */
	goto again;
    }

    in_pos = 1;
    in_len = iosb[1] + iosb[3];
    if (status == SS$_TIMEOUT || status == SS$_DATAOVERUN)
	return (-1);
    return (buffer[0]);
}

/*
 *	VMSSIGNAL -- Fote Macrides 29-Jun-1993
 *		Sets up AST for both Ctrl-C and Ctrl-Y, with system response
 *		 to Ctrl-T disabled.  If called with a sig other than SIGINT,
 *		 it will use the C library's system(sig, func).
 *		The equivalent of VMSsignal(SIGINT, cleanup_sig) is done on
 *		 intialization by ttopen(), so don't do it again.
 *		VMSsignal(SIGINT, SIG_DFL) is treated as a call to ttclose().
 *		Call VMSsignal(SIGINT, SIG_IGN) before system() calls to
 *		 enable Ctrl-C and Ctrl-Y in the subprocess, and then call
 *		 VMSsignal(SIG_INT, cleanup_sig) on return from the subprocess.
 *		For func's which set flags and do not invoke an exit from
 *		 LYNX, the func should reassert itself.
 *		The VMS signal() calls do not fully emulate the Unix calls,
 *		 and VMSsignal() is just a "helper", also not a full emulation.
 */

void VMSsignal(int sig,
	       void (*func) ())
{
    int status;
    short iosb[4];
    static int SIG_IGN_flag;

    /*
     * Pass all signals other than SIGINT to signal().
     * Also pass SIGINT to signal() if we're dumping.
     */
    if (sig != SIGINT || dump_output_immediately) {
	signal(sig, func);
	return;
    }

    /*
     * If func is SIG_DFL, treat it as ttclose().
     */
    if (func == SIG_DFL) {
	ttclose();
	return;
    }

    /*
     * Clear any previous AST.
     */
    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }

    /*
     * If func is SIG_IGN, leave the TT channel closed and the system response
     * to interrupts enabled for system() calls.
     */
    if (func == SIG_IGN)
	return;

    /*
     * If we get to here, we have a LYNX func, so set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      func, SIGINT, 0, 0, 0, 0);

}				/* VMSsignal */

/*
 * DCLspawn_exception, spawn_DCLprocess, DCLsystem -- F.Macrides 16-Jan-1994
 *	Exception-handler routines for regulating interrupts and enabling
 *	Control-T during spawns.  Includes TRUSTED flag for versions of VMS
 *	which require it in captive accounts.  This code should be used
 *	instead of the VAXC or DECC system(), by including LYUtils.h in
 *	modules which have system() calls.  It helps ensure that we return
 *	to Lynx instead of breaking out to DCL if a user issues interrupts
 *	or generates an ACCVIO during spawns.
 */
#ifdef __DECC
static unsigned int DCLspawn_exception(void *sigarr,
				       void *mecharr)
#else
static int DCLspawn_exception(void *sigarr,
			      void *mecharr)
#endif				/* __DECC */
{
    int status;

    status = lib$sig_to_ret(sigarr, mecharr);
    return (SS$_UNWIND);
}

static int spawn_DCLprocess(char *command)
{
    int status;
    unsigned long Status = 0;

    /*
     * Keep DECC from complaining.
     */
    struct dsc$descriptor_s command_desc;

    command_desc.dsc$w_length = strlen(command);
    command_desc.dsc$b_class = DSC$K_CLASS_S;
    command_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    command_desc.dsc$a_pointer = command;

    VAXC$ESTABLISH(DCLspawn_exception);

#ifdef __ALPHA /** OpenVMS/AXP lacked the TRUSTED flag before v6.1 **/
    if (VersionVMS[1] > '6' ||
	(VersionVMS[1] == '6' && VersionVMS[2] == '.' &&
	 VersionVMS[3] >= '1'))
#else
    if (VersionVMS[1] >= '6')
#endif /* __ALPHA */
    {
	/*
	 * Include TRUSTED flag.
	 */
	unsigned long trusted = CLI$M_TRUSTED;

	status = lib$spawn(&command_desc, 0, 0, &trusted,
			   0, 0, &Status);
	/*
	 * If it was invalid, try again without the flag.
	 */
	if (status == LIB$_INVARG)
	    status = lib$spawn(&command_desc, 0, 0, 0,
			       0, 0, &Status);
    } else
	status = lib$spawn(&command_desc, 0, 0, 0,
			   0, 0, &Status);
    /*
     * Return -1 on error.
     */
    if ((status & 1) != 1 || (Status & 1) != 1)
	return (-1);
    /*
     * Return 0 on success.
     */
    return (0);
}

int DCLsystem(char *command)
{
    int status;

    VMSsignal(SIGINT, SIG_IGN);
    status = spawn_DCLprocess(command);
    VMSsignal(SIGINT, cleanup_sig);
    /*
     * Returns 0 on success, -1 any error.
     */
    return (status);
}
#endif /* VMS */

/*
 * Return the physical screen dimensions that we're allowed to use.
 */
int LYscreenHeight(void)
{
    int result = LINES;

    if (result <= 0)
	result = DFT_ROWS;
    return result;
}

int LYscreenWidth(void)
{
    int result = COLS;

#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX)		/* 1999/08/26 (Thu) 17:53:38 */
    {
	extern int current_codepage;	/* PDCurses lib. */

	if (current_codepage == 932)
	    result--;
    }
#endif
    if (result <= 0)
	result = DFT_COLS;
    return result;
}

/*
 * The functions ifdef'd with USE_CURSES_PADS are implemented that way so we
 * don't break the slang configuration.
 */
void LYclear(void)
{
#ifdef USE_CURSES_PADS
    wclear(LYwin);
#else
    clear();
#endif
}

void LYclrtoeol(void)
{
#ifdef USE_CURSES_PADS
    wclrtoeol(LYwin);
#else
    clrtoeol();
#endif
}

void LYerase(void)
{
#ifdef USE_CURSES_PADS
    werase(LYwin);
#else
    erase();
#endif
}

void LYmove(int y, int x)
{
#ifdef USE_CURSES_PADS
    wmove(LYwin, y, x);
#else
    move(y, x);
#endif
}

void LYrefresh(void)
{
#ifdef USE_CURSES_PADS
    if (LYwin != stdscr) {
	/*
	 * Workaround for special case where lynx is prompting for a mailto,
	 * and has a subject line that is wider than the screen.  The
	 * wnoutrefresh() call resets newscr's position to match stdscr's,
	 * which happens to be the window's origin because we were not updating
	 * that, and other stray wmove's in lynx fail because the coordinate
	 * is on/after the right margin.  Force things to look ok here.
	 */
	int y, x;

	getyx(LYwin, y, x);
	if (x > LYcolLimit)
	    x = LYcolLimit;
	wmove(stdscr, y, x);

	wnoutrefresh(stdscr);
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth() - 1);

	/*
	 * Keep a popup window visible.  This can happen if the user presses
	 * '/' to do a search within a popup.
	 */
	if (my_subwindow != 0) {
	    touchwin(my_subwindow);
	    wnoutrefresh(my_subwindow);
	}
	doupdate();
    } else {
	refresh();
    }
#else
    refresh();
#endif
}

void lynx_force_repaint(void)
{
    clearok(curscr, TRUE);
}

void lynx_start_title_color(void)
{
#ifdef SH_EX
    lynx_start_reverse();
#endif
}

void lynx_stop_title_color(void)
{
#ifdef SH_EX
    lynx_stop_reverse();
#endif
}

void lynx_start_link_color(int flag,
			   int pending)
{
    if (flag) {
	/* makes some terminals work wrong because
	 * they can't handle two attributes at the
	 * same time
	 */
	/* lynx_start_bold();  */
	lynx_start_reverse();
#if defined(USE_SLANG)
#ifndef __DJGPP__
	if (SLtt_Use_Ansi_Colors)
#endif /* !__DJGPP__ */
	    lynx_start_underline();
#endif /* USE_SLANG */
#if defined(FANCY_CURSES) && defined(COLOR_CURSES)
	if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	    lynx_start_underline();
#endif /* USE_SLANG */
    } else {
	lynx_start_bold();
	/*
	 * Make sure when flag is OFF that "unhighlighted" links will be
	 * underlined if appropriate.  - LE & FM
	 */
	if (pending)
	    lynx_start_underline();
    }
}

void lynx_stop_link_color(int flag,
			  int pending GCC_UNUSED)
{
#ifdef USE_COLOR_STYLE
    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_OFF);
#else
    if (flag) {
	lynx_stop_reverse();
#if defined(USE_SLANG)
#ifndef __DJGPP__
	if (SLtt_Use_Ansi_Colors)
#endif /* !__DJGPP__ */
	    lynx_stop_underline();
#endif /* USE_SLANG */
#if defined(FANCY_CURSES) && defined(COLOR_CURSES)
	if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	    lynx_stop_underline();
#endif /* FANCY_CURSES && COLOR_CURSES */
    } else {
	lynx_stop_bold();
	/*
	 * If underlining was turned on above, turn it off.  - LE & FM
	 */
	if (pending)
	    lynx_stop_underline();
    }
#endif
}

/* FIXME: consider inlining these */

void lynx_stop_target_color(void)
{
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
}

void lynx_start_target_color(void)
{
    lynx_start_bold();
    lynx_start_reverse();
    lynx_start_underline();
}

void lynx_start_status_color(void)
{
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	lynx_set_color(2);
    else
#endif
	lynx_start_reverse();
}

void lynx_stop_status_color(void)
{
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	lynx_set_color(0);
    else
#endif
	lynx_stop_reverse();
}

void lynx_start_h1_color(void)
{
    if (bold_H1 || bold_headers)
	lynx_start_bold();
}

void lynx_stop_h1_color(void)
{
    if (bold_H1 || bold_headers)
	lynx_stop_bold();
}

void lynx_start_prompt_color(void)
{
    lynx_start_reverse();
}

void lynx_stop_prompt_color(void)
{
    lynx_stop_reverse();
}

void lynx_start_radio_color(void)
{
    lynx_start_bold();
}

void lynx_stop_radio_color(void)
{
    lynx_stop_bold();
}

void lynx_stop_all_colors(void)
{
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
}

/*
 * Wrappers for LYUnderlineLinks flag.
 */
void lynx_start_bold(void)
{
    start_bold();
}

void lynx_start_reverse(void)
{
    start_reverse();
}

void lynx_start_underline(void)
{
    start_underline();
}

void lynx_stop_bold(void)
{
    stop_bold();
}

void lynx_stop_reverse(void)
{
    stop_reverse();
}

void lynx_stop_underline(void)
{
    stop_underline();
}

/*
 * If LYShowCursor is ON, move the cursor to the left of the current option, so
 * that blind users, who are most likely to have LYShowCursor ON, will have
 * it's string spoken or passed to the braille interface as each option is made
 * current.  Otherwise, move it to the bottom, right column of the screen, to
 * "hide" the cursor as for the main document, and let sighted users rely on
 * the current option's highlighting or color without the distraction of a
 * blinking cursor in the window.  - FM
 */
void LYstowCursor(WINDOW * win, int row,
		  int col)
{
    if (LYShowCursor)
	wmove(win, row, col);
    else
	LYHideCursor();
#ifdef USE_SLANG
    SLsmg_refresh();
#else
    wrefresh(win);
#endif /* USE_SLANG  */
}

#if defined(USE_BLINK) && defined(__EMX__)	/* Can't put it earler due to BOOLEAN conflict */
#  define BOOLEAN os2BOOLEAN
#  define INCL_VIO
#  include "os2.h"
static void make_blink_boldbg(void)
{
    VIOINTENSITY buf;		/* VIO windows have it anyway, */

    /* but FS session need a switch */
    buf.cb = sizeof(buf);
    buf.type = 2;		/* VIOINTENSITY request */
    buf.fs = 1;			/* Intensity == boldbg */
    VioSetState(&buf, 0);
}
#endif

#if defined(HAVE_WATTR_GET)
/*
 * getattrs() is not in X/Open curses, but it is more convenient than this.
 */
long LYgetattrs(WINDOW * win)
{
#if ( defined(HAVE_GETATTRS) && ( !defined(NCURSES_MAJOR_VERSION) || NCURSES_VERSION_MAJOR < 5 ) )
    long result = 0;

    result = getattrs(win);
#else
    attr_t result = 0;
    short pair = 0;

    wattr_get(win, &result, &pair, NULL);
#endif
    return result;
}
#endif /* HAVE_WATTR_GET */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d4 6
d20 1
d71 2
a72 2
 *  These are routines to start and stop curses and to cleanup
 *  the screen at the end.
d75 1
a75 1
PRIVATE int dumbterm PARAMS((char *terminal));
d79 1
a79 1
PRIVATE void make_blink_boldbg NOARGS;
d83 1
a83 1
PUBLIC int Current_Attr, Masked_Attr;
d87 3
a89 3
PUBLIC unsigned int Lynx_Color_Flags = 0;
PUBLIC BOOLEAN FullRefresh = FALSE;
PUBLIC int curscr = 0;
d93 1
a93 1
 *  Will be set by size_change. - KW
d95 1
a95 1
PUBLIC int PHYSICAL_SLtt_Screen_Cols = 10;
d98 1
a98 2

PUBLIC void LY_SLrefresh NOARGS
d115 1
a115 1
PUBLIC void LY_SLerase NOARGS
d117 2
a118 2
    SLsmg_gotorc (0, 0);
    SLsmg_erase_eos ();
d122 1
a122 1
PUBLIC void VTHome NOARGS
d130 1
a130 2
PUBLIC void LYaddAttr ARGS1(
	int,		a)
d136 1
a136 2
PUBLIC void LYsubAttr ARGS1(
	int,		a)
d142 1
a142 1
PRIVATE void lynx_setup_attrs NOARGS
d144 2
a145 1
    static int monoattr[] = {
d161 1
a161 1
PUBLIC void lynx_setup_colors NOARGS
d165 10
a174 10
    SLtt_set_color(1, NULL, "blue",	DEFAULT_BG); /* bold */
    SLtt_set_color(2, NULL, "yellow",	"blue");     /* reverse */
    SLtt_set_color(4, NULL, "magenta",	DEFAULT_BG); /* underline */
    /*
     *	The other objects are '|'ed together to get rest.
     */
    SLtt_set_color(3, NULL, "green",	DEFAULT_BG); /* bold-reverse */
    SLtt_set_color(5, NULL, "blue",	DEFAULT_BG); /* bold-underline */
    SLtt_set_color(6, NULL, "red",	DEFAULT_BG); /* reverse-underline */
    SLtt_set_color(7, NULL, "magenta",	"cyan");     /* reverse-underline-bold */
d176 1
a176 1
     *	Now set monochrome attributes.
d181 1
a181 2
PRIVATE void sl_suspend ARGS1(
	int,		sig)
d187 1
a187 1
    lynx_enable_mouse (0);
d191 1
a191 1
    kill(getpid(),SIGSTOP);
d204 1
a204 1
     *	Get new window size in case it changed.
d212 1
a212 1
    lynx_enable_mouse (1);
d222 1
d225 1
a225 1
    char *name;
d237 1
d239 1
a239 2
PUBLIC int string_to_attr ARGS1(
    char *,	name)
d253 1
a253 2
PRIVATE char *attr_to_string ARGS1(
    int,	code)
d273 1
d275 3
a277 2
	    CONST char *fg = lookup_color(bold ? f+COLORS : f);
	    CONST char *bg = lookup_color(b);
d290 3
a292 5
**  This function boxes windows for (n)curses.
*/
PUBLIC void LYbox ARGS2(
	WINDOW *,	win,
	BOOLEAN,	formfield GCC_UNUSED)
d311 1
a311 1
    for (i = 1; i < win->_max_y-1; i++) {
d314 1
a314 1
	wmove(win, i, win->_max_x-1);
d324 6
a329 6
     *	If the terminal is in UTF-8 mode, it probably cannot understand
     *	box drawing characters as (n)curses handles them.  (This may also
     *	be true for other display character sets, but isn't currently
     *	checked.)  In that case, substitute ASCII characters for BOXVERT
     *	and BOXHORI if they were defined to 0 for automatic use of box
     *	drawing characters.  They'll stay as they are otherwise. - KW & FM
d339 4
a342 5
     *	If we don't have explicitly specified characters for either
     *	vertical or horizontal lines, the characters that box() would
     *	use for the corners probably also won't work well.  So we
     *	specify our own ASCII characters for the corners and call
     *	wborder() instead of box(). - kw
d370 1
a370 1
PUBLIC HTCharStyle displayStyles[DSTYLE_ELEMENTS];
d375 4
a378 5
PUBLIC void setStyle ARGS4(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono)
d385 11
a395 10
PUBLIC void setHashStyle ARGS5(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono,
    char *,	element)
{
    bucket* ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE, (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n", element, style, color, mono));
d408 2
a409 4
PRIVATE void LYAttrset ARGS3(
    WINDOW *,	win,
    int,	color,
    int,	mono)
d412 4
a415 3
     && LYShowColor >= SHOW_COLOR_ON
     && color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color (%s)\n", attr_to_string(color)));
d418 2
a419 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono (%s)\n", attr_to_string(mono)));
d427 2
a428 4
PUBLIC void curses_w_style ARGS3(
	WINDOW*,	win,
	int,		style,
	int,		dir)
d436 2
a437 1
    int YP,XP;
d439 2
a440 1
    bucket* ds= (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);
d442 2
a443 2
    bucket* ds= (style == NOSTYLE ?	     &nostyle_bucket :
	    (style== SPECIAL_STYLE ? &special_bucket :&hashStyles[style]) );
a445 1

d447 1
a447 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n",style));
d453 3
a455 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> (%d)\n",(dir?"":"/"),ds->name,ds->code));
d457 1
a457 1
    getyx (win, YP, XP);
d460 3
a462 2
	wattrset(win,A_NORMAL);
	if (win == LYwin) cached_styles[YP][XP] = s_normal;
d466 1
a466 2
    switch (dir)
    {
d471 4
a474 4
	    LYAttrset(win,last_attr,last_attr);
	}
	else
	    LYAttrset(win,A_NORMAL,-1);
d477 7
a483 7
    case STACK_ON: /* remember the current attributes */
	if (last_colorattr_ptr > 127) {
	    CTRACE2(TRACE_STYLE, (tfp,"........... %s (0x%x) %s\r\n",
			"attribute cache FULL, dropping last",
			last_styles[last_colorattr_ptr],
			"in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr = 127;
d493 2
a494 1
	if (!ds->name) break;
d497 12
a508 10
    case ABS_ON: /* change without remembering the previous style */
	    /* don't cache style changes for active links and edits */
	if ( style != s_alink
	     && style != s_curedit
	     && style != s_aedit
	     && style != s_aedit_sel
	     && style != s_aedit_pad
	     && style != s_aedit_arr ) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP));
	    if (win == LYwin) cached_styles[YP][XP] = style;
d518 2
a519 4
PUBLIC void wcurses_css ARGS3(
    WINDOW *,	win,
    char*,	name,
    int,	dir)
d525 1
d528 7
a534 4
	    char *class = strrchr(name, '.');
	    CTRACE2(TRACE_STYLE, (tfp, "undefined, trimming at %p\n", class));
	    if (class)	*class = '\0';
	    else	try_again = 0;
d543 2
a544 3
PUBLIC void curses_css ARGS2(
    char *,	name,
    int,	dir)
d549 2
a550 3
PUBLIC void curses_style ARGS2(
	int,	style,
	int,	dir)
d556 1
a556 1
PRIVATE BOOL lynx_called_initscr = FALSE;
d563 1
a563 1
PUBLIC int lynx_default_colors NOARGS
d566 1
d588 2
a589 2

PRIVATE struct {
d601 1
d606 1
a606 1
PRIVATE struct {
d617 1
a617 1
PRIVATE int get_color_pair ARGS1(int, n)
d621 1
a621 1
     && lynx_color_pairs[n].bg == default_bg)
d641 1
a641 1
PRIVATE int lynx_color_cfg_attr ARGS1(int, code)
d644 1
d647 1
d658 1
a658 1
PRIVATE void LYsetWAttr ARGS1(WINDOW *, win)
d673 2
a674 2
	if (code+offs < COLOR_PAIRS) {
	    attr |= get_color_pair(code+offs);
d686 1
a686 1
PRIVATE void lynx_init_color_pair ARGS1(int, n)
d693 1
d695 3
a697 3
		init_pair((short)pair,
		    (short)map2bold(lynx_color_pairs[pair].fg),
		    (short)map2bold(lynx_color_pairs[pair].bg));
d704 1
a704 1
PRIVATE void lynx_map_color ARGS1(int, n)
d708 2
a709 2
    lynx_color_pairs[n+1].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n+1].bg = lynx_color_cfg[n].bg;
d711 2
a712 2
    lynx_color_pairs[n+9].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n+9].bg = lynx_color_cfg[0].bg;
d714 2
a715 2
    lynx_color_pairs[n+17].fg = lynx_color_cfg[n].bg;
    lynx_color_pairs[n+17].bg = lynx_color_cfg[n].bg;
d724 4
a727 5
PUBLIC int lynx_chg_color ARGS3(
	int, color,
	int, fg,
	int, bg
	)
d729 2
a730 1
    if (fg == ERR_COLOR || bg == ERR_COLOR) return -1;
d741 1
a741 1
PUBLIC void lynx_set_color ARGS1(int, a)
d745 3
a747 3
		| (((a+1) < COLOR_PAIRS)
			? get_color_pair(a+1)
			: A_NORMAL));
d751 1
a751 1
PUBLIC void lynx_standout ARGS1(int, flag)
d759 1
a759 1
PRIVATE void lynx_init_colors NOARGS
d765 1
a765 1
		     default_fg, default_bg));
d778 1
a778 1
PUBLIC void lynx_setup_colors NOARGS
d781 1
d788 1
a788 2
PUBLIC void LYnoVideo ARGS1(
	int,		a)
d792 6
a797 3
    if (a & 1) Masked_Attr |= SLTT_BOLD_MASK;
    if (a & 2) Masked_Attr |= SLTT_REV_MASK;
    if (a & 4) Masked_Attr |= SLTT_ULINE_MASK;
d801 6
a806 3
    if (a & 1) Masked_Attr |= A_BOLD;
    if (a & 2) Masked_Attr |= A_REVERSE;
    if (a & 4) Masked_Attr |= A_UNDERLINE;
d819 1
d828 1
a828 1
#else  /* HAVE_NEWTERM   */
d830 1
d835 1
a835 1
#define LYDELSCR()  /* nothing */
d837 1
a837 1
#else  /* !defined(VMS) && !defined(USE_SLANG) */
d844 1
a844 1
#define LYDELSCR()  /* nothing */
d848 2
a849 2
PUBLIC int saved_scrsize_x = 0;
PUBLIC int saved_scrsize_y = 0;
d852 1
a852 1
PUBLIC void start_curses NOARGS
d864 2
a865 2
	if (-1 == lynx_initialize_keymaps ())
	    exit (EXIT_FAILURE);
d870 1
a870 1
	SLkp_init ();
d884 1
a884 1
	 *  Check whether a saved show_color:off override is in effect. - kw
d890 1
a890 1
	 *  Check whether we're forcing color on. - FM
d895 1
a895 1
	 *  Check whether a -nocolor override is in effect. - kw
d900 1
a900 1
	 *  Make sure our flags are in register. - FM
d919 2
a920 2
	 *  If set, the blink escape sequence will turn on high
	 *  intensity background (rxvt and maybe Linux console).
d941 2
a942 2
	SLsmg_Display_Eight_Bit = 191; /* may print ctrl chars otherwise - kw */
    scrollok(0,0);
d945 1
a945 1
    SLsmg_touch_screen ();
d958 1
a958 1
    lynx_enable_mouse (1);
d965 1
a965 2
     *	If we are VMS then do initscr() everytime start_curses()
     *	is called!
d968 2
a969 2
    initscr();	/* start curses */
#else  /* Unix: */
d979 1
d987 1
a987 2
	 *  If we're not VMS then only do initscr() one time,
	 *  and one time only!
d995 1
a995 1
	recent_sizechange = savesize;    /* avoid extra redraw */
d1005 1
a1005 2
	    static char lines_putenv[] = "LINES=abcde",
			cols_putenv[]  = "COLUMNS=abcde";
d1008 1
a1008 1
	    sprintf(cols_putenv  + 8, "%d", LYcols  & 0xfff);
d1016 1
a1016 1
	if (!(LYscreen = newterm(NULL,stdout,stdin))) {  /* start curses */
d1018 2
a1019 2
		gettext("Terminal initialisation failed - unknown terminal type?"));
	    exit_immediately (EXIT_FAILURE);
d1031 1
a1031 1
	recent_sizechange = FALSE; /* prevent mainloop drawing 1st doc twice */
d1033 1
a1033 1
	CTRACE((tfp, "Screen size is now %d x %d\n", LYlines, LYcols ));
d1049 1
a1049 1
	keypad(LYwin,TRUE);
d1051 1
a1051 1
#  endif /* HAVE_KEYPAD */
d1053 1
a1053 1
	if (-1 == lynx_initialize_keymaps ()) {
d1055 1
a1055 1
	    exit (EXIT_FAILURE);
d1070 1
d1105 1
a1105 1
			 default_fg, default_bg));
d1108 1
d1141 1
a1141 1
    /* nonl();	 */ /* seems to slow things down */
d1159 1
a1159 1
	keypad(LYwin,TRUE);
d1162 1
a1162 1
    lynx_enable_mouse (1);
d1174 1
a1174 1
    if (term_blink_is_boldbg)		/* Now actually make it so! */
d1188 1
a1188 1
        LYclear();
d1192 1
a1192 1
}  /* end of start_curses() */
d1194 1
a1194 2

PUBLIC void lynx_enable_mouse ARGS1(int,state)
d1204 1
d1206 1
a1206 2
    if (LYUseMouse == 0)
    {
d1217 2
a1218 2
    SLtt_set_mouse_mode (state, 0);
    SLtt_flush_output ();
d1222 1
a1222 2
    if (state)
    {
d1236 1
a1236 1
	    if (old < 200)		/* Default 166 */
d1265 3
a1267 3
		BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
d1269 1
a1269 1
#endif      /* NOT USE_SLANG */
d1295 1
a1295 1
PUBLIC void lynx_nl2crlf ARGS1(int, normal GCC_UNUSED)
d1309 1
a1309 1
	 || (tigetstr("ind")  != 0 && *tigetstr("ind")  == '\n'))
d1333 1
a1333 1
PUBLIC void stop_curses NOARGS
d1335 1
a1335 1
    if (LYCursesON)
d1337 1
d1339 1
a1339 1
    resetty ();
d1349 3
d1354 1
d1357 1
a1357 1
    if(LYCursesON == TRUE)	{
d1359 1
a1359 1
	lynx_enable_mouse (0);
d1364 4
a1367 4
	if(LYscreen || lynx_called_initscr) {
	    endwin();	/* stop curses */
	    LYDELSCR();
	}
d1373 2
a1374 1
	for (i=0; i <= 3; i++) {
d1400 5
d1406 1
a1406 1
 *  Check terminal type, start curses & setup terminal.
d1408 1
a1408 2
PUBLIC BOOLEAN setup ARGS1(
	char *,		terminal)
a1412 3
#ifdef USE_SLANG
    extern void longname();
#endif /* USE_SLANG */
d1415 2
a1416 2
     *	If the display was not set by a command line option then
     *	see if it is available from the environment.
d1425 1
a1425 1
     *	Get terminal type, and convert to lower case.
d1431 2
a1432 2
	 *  Some yoyo used these under conditions which require
	 *  -dump, so force that mode here. - FM
d1439 1
a1439 7
	(void) signal (SIGHUP, SIG_DFL);
	(void) signal (SIGTERM, SIG_DFL);
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit(status);
d1447 1
a1447 1
	    gettext("You must use a vt100, 200, etc. terminal with this program."));
d1452 1
a1452 1
	    return(FALSE);
d1454 1
a1454 1
	strcpy(term,"vt100");
d1463 1
a1463 1
    return(TRUE);
d1466 1
a1466 1
#else	/* Not VMS: */
d1469 1
a1469 1
 *  Check terminal type, start curses & setup terminal.
d1471 1
a1471 2
PUBLIC BOOLEAN setup ARGS1(
	char *,		terminal)
d1478 2
a1479 2
     *  If the display was not set by a command line option then
     *  see if it is available from the environment .
d1493 1
a1493 1
     *	Query the terminal type.
d1505 1
a1505 1
	    StrAllocCopy(buffer,"vt100");
d1507 1
a1507 1
	HTSprintf0(&term_putenv,"TERM=%.106s", buffer);
d1511 2
a1512 1
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"), LYGetEnv("TERM"));
d1520 6
a1525 6
     *  Account for lossage on the 'sun' terminal type (80x24) Sun text
     *  console driver. It only supports reverse video, but all SGR
     *  sequences produce that same reverse video, and the terminfo
     *  entry lists different SGRs for 'bold' and 'rev'. As a result,
     *  the current link is indistinguishable from all other links.
     *  The workaround here is to disable the 'rev' capability.
d1527 1
a1527 1
    if ((strncmp((CONST char *)ttytype, "sun", 3) == 0)) {
d1535 1
a1535 1
    return(1);
d1538 1
a1538 2
PRIVATE int dumbterm ARGS1(
	char *,		terminal)
d1543 2
a1544 2
     *	Began checking for terminal == NULL in case that TERM environment
     *	variable is not set.  Thanks to Dick Wesseling (ftu@@fi.ruu.nl).
d1549 4
a1552 4
	!strcasecomp(terminal, "dialup")  ||
	!strcasecomp(terminal, "dumb")	  ||
	!strcasecomp(terminal, "switch")  ||
	!strcasecomp(terminal, "ethernet")  )
d1554 1
a1554 1
    return(dumb);
d1560 1
a1560 3
PUBLIC void LYaddWAttr ARGS2(
	WINDOW *,	win,
	int,		a)
d1566 1
a1566 2
PUBLIC void LYaddAttr ARGS1(
	int,		a)
d1571 1
a1571 3
PUBLIC void LYsubWAttr ARGS2(
	WINDOW *,	win,
	int,		a)
d1577 1
a1577 2
PUBLIC void LYsubAttr ARGS1(
	int,		a)
d1594 2
a1595 4
PUBLIC void LYpaddstr ARGS3(
	WINDOW *,	the_window,
	int,		width,
	CONST char *,	the_string)
d1601 2
a1602 2
    if (width + x >= LYcols)
	width = LYcols - x - 1;
d1618 1
a1618 1
PRIVATE WINDOW *my_subwindow;
d1620 1
a1620 1
PUBLIC void LYsubwindow ARGS1(WINDOW *, param)
d1626 1
a1626 1
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
d1639 1
a1639 1
PUBLIC WINDOW *LYtopwindow NOARGS
d1645 4
a1648 5
PUBLIC WINDOW *LYstartPopup ARGS4(
    int,	top_y,
    int,	left_x,
    int,	height,
    int,	width)
d1651 1
d1654 7
a1660 1
    SLsmg_fill_region(top_y, left_x - 1, height, width + 4, ' ');
d1662 12
a1673 7
    form_window->top_y  = top_y;
    form_window->left_x = left_x;
    form_window->height = height;
    form_window->width  = width;
#else
    if (!(form_window = newwin(height, width + 4, top_y, left_x - 1)) &&
	!(form_window = newwin(height, 0, top_y, 0))) {
d1690 1
a1690 1
	    wbkgdset(form_window, (b & ~(A_BOLD|A_BLINK)) | ' ');
d1698 1
a1698 1
PUBLIC void LYstartTargetEmphasis NOARGS
d1707 2
a1708 2
    start_bold();
    start_reverse();
d1710 1
a1710 1
    start_underline();
d1713 1
a1713 1
PUBLIC void LYstopTargetEmphasis NOARGS
d1721 1
a1721 1
    stop_underline();
d1723 2
a1724 2
    stop_reverse();
    stop_bold();
d1731 1
a1731 2
PUBLIC void LYtouchline ARGS1(
	int,		row)
d1759 3
a1761 4
PUBLIC void LYwaddnstr ARGS3(
	WINDOW *,	w,
	CONST char *,	src,
	size_t,		len)
d1770 1
d1772 2
a1773 1
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n", y, x, (int) len, src));
d1787 2
a1788 2
#if 0	/* defined(WIDEC_CURSES) && defined(HAVE_MBSTATE_T) */
#if 1	/* array of wchar_t's */
d1811 1
a1811 1
	    if (rc == 0 || rc == (size_t)(-1) || rc == (size_t)(-2))
d1825 1
a1825 1
#else	/* array of cchar_t's */
d1842 1
a1842 1
	wattr_get(w, &attr, &pair, (void *)0);
d1854 1
a1854 1
	    if (rc == 0 || rc == (size_t)(-1) || rc == (size_t)(-2))
d1876 1
a1876 1
	wadd_wchnstr (w, temp, k);
d1893 1
d1902 75
d2038 30
a2067 1
#define EFN	0			/* Event flag			*/
d2069 15
a2083 45
static	unsigned char buffer[20];	/* Input buffer			*/
static	int	in_pos, in_len;		/* For escape sequences		*/
static	int	oldmode[3];		/* Old TTY mode bits		*/
static	int	newmode[3];		/* New TTY mode bits		*/
static	short	iochan;			/* TTY I/O channel		*/
static	$DESCRIPTOR(term_nam_dsc,"TT"); /* Descriptor for iochan	*/
static	unsigned long mask = LIB$M_CLI_CTRLY|LIB$M_CLI_CTRLT; /* ^Y and ^T */
static	unsigned long old_msk;		/* Saved control mask		*/
static	short	trap_flag = FALSE;	/* TRUE if AST is set		*/
BOOLEAN DidCleanup = FALSE;		/* Exit handler flag		*/
static char VersionVMS[20];		/* Version of VMS		*/

PUBLIC int VMSVersion ARGS2(
	char *,		VerString,
	int,		VerLen)
{
     unsigned long status, itm_cod = SYI$_VERSION;
     int i, verlen = 0;
     struct dsc$descriptor version;
     char *m;

     version.dsc$a_pointer = VerString;
     version.dsc$w_length = VerLen - 1;
     version.dsc$b_dtype = DSC$K_DTYPE_B;
     version.dsc$b_class = DSC$K_CLASS_S;

     status = lib$getsyi(&itm_cod, 0, &version, &verlen, 0, 0);
     if (!(status&1) || verlen == 0)
	  return 0;

     /*
      *  Cut out trailing spaces
      */
     for (m = VerString+verlen, i = verlen-1; i > 0 && VerString[i] == ' '; --i)
	  *(--m) = '\0';

     return strlen(VerString)+1;	/* Transmit ending 0 too */
}

PUBLIC void VMSexit NOARGS
{
    /*
     *	If we get here and DidCleanup is not set, it was via an
     *	ACCVIO, or outofmemory forced exit, so make *sure* we
     *	attempt a cleanup and reset the terminal.
d2088 2
a2089 1
gettext("\nA Fatal error has occurred in %s Ver. %s\n"), LYNX_NAME, LYNX_VERSION);
d2091 1
a2091 1
gettext("\nPlease notify your system administrator to confirm a bug, and if\n\
d2098 1
a2098 1
		fprintf(stderr,RETURN_TO_CLEANUP);
d2121 1
a2121 1
PUBLIC int ttopen NOARGS
d2123 35
a2157 35
	int	iosb[2];
	int	status;
	static unsigned long condition;
	static struct _exit_block {
	    unsigned long forward;
	    unsigned long address;
	    unsigned long zero;
	    unsigned long condition;
	} exit_handler_block;

	status = sys$assign( &term_nam_dsc, &iochan, 0, 0 );
	if( status != SS$_NORMAL )
		exit( status );

	status = sys$qiow( EFN, iochan, IO$_SENSEMODE, &iosb, 0, 0,
			  &oldmode, sizeof(oldmode), 0, 0, 0, 0 );
	if( status != SS$_NORMAL )
		exit( status );

	status = iosb[0] & 0xFFFF;
	if( status != SS$_NORMAL )
		exit( status );

	newmode[0] = oldmode[0];
	newmode[1] = oldmode[1];
	newmode[2] = oldmode[2] | TT2$M_EDIT;

	status = sys$qiow( EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
			  &newmode, sizeof(newmode), 0, 0, 0, 0 );
	if( status != SS$_NORMAL )
		exit( status );

	status = iosb[0] & 0xFFFF;
	if( status != SS$_NORMAL )
		exit( status );
d2159 10
a2168 10
	/*
	 *  Declare the exit handler block.
	 */
	exit_handler_block.forward   = 0;
	exit_handler_block.address   = (unsigned long) &VMSexit;
	exit_handler_block.zero      = 0;
	exit_handler_block.condition = (unsigned long) &condition;
	status = sys$dclexh(&exit_handler_block);
	if (status != SS$_NORMAL)
		exit( status );
d2170 13
a2182 13
	/*
	 *  Set the AST.
	 */
	lib$disable_ctrl(&mask, &old_msk);
	trap_flag = TRUE;
	status = sys$qiow ( EFN, iochan,
			    IO$_SETMODE|IO$M_CTRLCAST|IO$M_CTRLYAST,
			    &iosb, 0, 0,
			    &cleanup_sig, SIGINT, 0, 0, 0, 0 );
	if ( status != SS$_NORMAL ) {
		lib$enable_ctrl(&old_msk);
		exit ( status );
	}
d2184 4
d2189 1
a2189 1
	 *  Get the version of VMS.
d2191 1
a2191 5
	if (VMSVersion(VersionVMS, 20) < 3)
		/*
		 *  Load zeros on error.
		 */
		strcpy(VersionVMS, "V0.0-0");
d2193 2
a2194 2
	return(0);
}	/*  ttopen  */
d2202 1
a2202 1
PUBLIC int ttclose NOARGS
d2204 2
a2205 2
	int	status;
	int	iosb[1];
d2207 2
a2208 2
	status = sys$qiow( EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
			  &oldmode, sizeof(oldmode), 0, 0, 0, 0 );
d2210 2
a2211 2
	if( status != SS$_NORMAL || (iosb[0] & 0xFFFF) != SS$_NORMAL )
		exit( status );
d2213 7
a2219 7
	if (trap_flag) {
	    status = sys$dassgn (iochan);
	    status = lib$enable_ctrl(&old_msk);
	    trap_flag = FALSE;
	}
	return(0);
}	/*  ttclose  */
d2225 1
a2225 1
PUBLIC int ttgetc NOARGS
d2231 1
a2231 1
	return(buffer[in_pos++]);
d2234 1
a2234 1
		      IO$_READVBLK|IO$M_NOECHO|IO$M_NOFILTR,
d2237 1
a2237 1
    if ((status&1) == 1)
d2241 1
a2241 1
	 *  Escape sequence in progress.  Fake a successful read.
d2245 2
a2246 2
    if ((status&1) != 1 && status != SS$_DATAOVERUN)
	exit(status);
d2249 1
a2249 1
    return(buffer[0]);
d2257 1
a2257 1
PUBLIC int typeahead NOARGS
d2266 1
a2266 1
	return(buffer[in_pos++]);
d2268 6
a2273 6
again:
    status = sys$qiow (EFN, iochan,
		       IO$_READVBLK|IO$M_TIMED|IO$M_NOECHO|IO$M_NOFILTR,
		       &iosb, 0, 0,
		       &buffer, 1, 0, 0, 0, 0);
    if ((status&1) == 1)
d2277 1
a2277 1
	 *  Escape sequence in progress, finish reading it.
d2285 1
a2285 1
	return(-1);
d2306 6
a2311 7
PUBLIC void VMSsignal (sig,func)
int sig;
void (*func)();
{
	int status;
	short iosb[4];
	static int SIG_IGN_flag;
d2313 8
a2320 8
	/*
	 *  Pass all signals other than SIGINT to signal().
	 *  Also pass SIGINT to signal() if we're dumping.
	 */
	if (sig != SIGINT || dump_output_immediately) {
	    signal(sig, func);
	    return;
	}
d2322 7
a2328 7
	/*
	 *  If func is SIG_DFL, treat it as ttclose().
	 */
	if (func == SIG_DFL) {
	    ttclose();
	    return;
	}
d2330 8
a2337 8
	/*
	 *  Clear any previous AST.
	 */
	if (trap_flag) {
	    status = sys$dassgn (iochan);
	    status = lib$enable_ctrl(&old_msk);
	    trap_flag = FALSE;
	}
d2339 6
a2344 6
	/*
	 *  If func is SIG_IGN, leave the TT channel closed and the
	 *  system response to interrupts enabled for system() calls.
	 */
	if (func == SIG_IGN)
	    return;
d2346 10
a2355 10
	/*
	 *  If we get to here, we have a LYNX func, so set the AST.
	 */
	lib$disable_ctrl(&mask, &old_msk);
	trap_flag = TRUE;
	status = sys$assign (&term_nam_dsc, &iochan, 0, 0 );
	status = sys$qiow ( EFN, iochan,
			    IO$_SETMODE|IO$M_CTRLCAST|IO$M_CTRLYAST,
			    &iosb, 0, 0,
			    func, SIGINT, 0, 0, 0, 0 );
d2357 1
a2357 1
}	/* VMSsignal */
d2360 1
a2360 1
 *  DCLspawn_exception, spawn_DCLprocess, DCLsystem -- F.Macrides 16-Jan-1994
d2370 12
a2381 28
PRIVATE unsigned int DCLspawn_exception ARGS2(
	void *,		sigarr,
	void *,		mecharr)
#else
PRIVATE int DCLspawn_exception ARGS2(
	void *,		sigarr,
	void *,		mecharr)
#endif /* __DECC */
{
     int status;

     status = lib$sig_to_ret(sigarr, mecharr);
     return(SS$_UNWIND);
}

PRIVATE int spawn_DCLprocess ARGS1(
	char *,		command)
{
     int status;
     unsigned long Status = 0;
     /*
      *  Keep DECC from complaining.
      */
     struct dsc$descriptor_s  command_desc;
     command_desc.dsc$w_length	= strlen(command);
     command_desc.dsc$b_class	= DSC$K_CLASS_S;
     command_desc.dsc$b_dtype	= DSC$K_DTYPE_T;
     command_desc.dsc$a_pointer = command;
d2383 16
a2398 1
     VAXC$ESTABLISH(DCLspawn_exception);
d2401 3
a2403 3
     if (VersionVMS[1] > '6' ||
	 (VersionVMS[1] == '6' && VersionVMS[2] == '.' &&
	  VersionVMS[3] >= '1'))
d2405 1
a2405 1
     if (VersionVMS[1] >= '6')
d2407 39
a2445 39
     {
	 /*
	  *  Include TRUSTED flag.
	  */
	 unsigned long trusted = CLI$M_TRUSTED;
	 status = lib$spawn(&command_desc,0,0,&trusted,
			    0,0,&Status);
	 /*
	  *  If it was invalid, try again without the flag.
	  */
	 if (status == LIB$_INVARG)
	    status = lib$spawn(&command_desc,0,0,0,
			       0,0,&Status );
     } else
	 status = lib$spawn(&command_desc,0,0,0,
			    0,0,&Status);
     /*
      *  Return -1 on error.
      */
     if ((status&1) != 1 || (Status&1) != 1)
	 return(-1);
     /*
      *  Return 0 on success.
      */
     return(0);
}

PUBLIC int DCLsystem ARGS1(
	char *,		command)
{
     int status;

     VMSsignal(SIGINT, SIG_IGN);
     status = spawn_DCLprocess(command);
     VMSsignal(SIGINT, cleanup_sig);
     /*
      *  Returns 0 on success, -1 any error.
      */
     return(status);
d2452 1
a2452 1
PUBLIC int LYscreenHeight NOARGS
d2455 1
d2461 1
a2461 1
PUBLIC int LYscreenWidth NOARGS
d2464 2
a2465 1
#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX) /* 1999/08/26 (Thu) 17:53:38 */
d2482 1
a2482 1
PUBLIC void LYclear NOARGS
d2491 1
a2491 1
PUBLIC void LYclrtoeol NOARGS
d2500 1
a2500 1
PUBLIC void LYerase NOARGS
d2509 1
a2509 1
PUBLIC void LYmove ARGS2(int, y, int, x)
d2518 1
a2518 1
PUBLIC void LYrefresh NOARGS
d2531 1
d2533 2
a2534 1
	if (x >= LYcols) x = LYcols-1;
d2538 1
a2538 1
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth()-1);
d2557 1
a2557 1
PUBLIC void lynx_force_repaint NOARGS
d2562 1
a2562 1
PUBLIC void lynx_start_title_color NOARGS
d2565 1
a2565 1
    start_reverse();
d2569 1
a2569 1
PUBLIC void lynx_stop_title_color NOARGS
d2572 1
a2572 1
    stop_reverse();
d2576 2
a2577 3
PUBLIC void lynx_start_link_color ARGS2(
	int,	flag,
	int,	pending)
d2584 2
a2585 2
	/* start_bold();  */
	start_reverse();
d2590 1
a2590 1
	    start_underline ();
d2594 1
a2594 1
	    start_underline ();
d2596 2
a2597 2
     } else {
	start_bold();
d2599 2
a2600 2
	 *  Make sure when flag is OFF that "unhighlighted" links
	 *  will be underlined if appropriate. - LE & FM
d2603 2
a2604 2
	    start_underline();
     }
d2607 2
a2608 3
PUBLIC void lynx_stop_link_color ARGS2(
	int,	flag,
	int,	pending GCC_UNUSED)
d2614 1
a2614 1
	stop_reverse();
d2619 1
a2619 1
	stop_underline ();
d2623 1
a2623 1
	    stop_underline ();
d2626 1
a2626 1
	stop_bold();
d2628 1
a2628 1
	 *  If underlining was turned on above, turn it off. - LE & FM
d2631 1
a2631 1
	    stop_underline();
d2636 1
d2638 1
a2638 1
PUBLIC void lynx_stop_target_color NOARGS
d2640 3
a2642 3
    stop_underline();
    stop_reverse();
    stop_bold();
d2645 1
a2645 1
PUBLIC void lynx_start_target_color NOARGS
d2647 3
a2649 3
    start_bold();
    start_reverse();
    start_underline();
d2652 1
a2652 2

PUBLIC void lynx_start_status_color NOARGS
d2656 1
a2656 1
	lynx_set_color (2);
d2659 1
a2659 1
	start_reverse ();
d2662 1
a2662 1
PUBLIC void lynx_stop_status_color NOARGS
d2666 1
a2666 1
	lynx_set_color (0);
d2669 1
a2669 1
	stop_reverse ();
d2672 1
a2672 1
PUBLIC void lynx_start_h1_color NOARGS
d2675 1
a2675 1
	start_bold();
d2678 1
a2678 1
PUBLIC void lynx_stop_h1_color NOARGS
d2681 1
a2681 1
	stop_bold();
d2684 1
a2684 1
PUBLIC void lynx_start_prompt_color NOARGS
d2686 1
a2686 1
    start_reverse ();
d2689 1
a2689 1
PUBLIC void lynx_stop_prompt_color NOARGS
d2691 1
a2691 1
    stop_reverse ();
d2694 1
a2694 1
PUBLIC void lynx_start_radio_color NOARGS
d2696 1
a2696 1
    start_bold ();
d2699 1
a2699 1
PUBLIC void lynx_stop_radio_color NOARGS
d2701 1
a2701 1
    stop_bold ();
d2704 1
a2704 1
PUBLIC void lynx_stop_all_colors NOARGS
d2706 36
a2741 3
    stop_underline ();
    stop_reverse ();
    stop_bold ();
d2753 2
a2754 4
PUBLIC void LYstowCursor ARGS3(
    WINDOW *,	win,
    int,	row,
    int,	col)
d2767 1
a2767 1
#if defined(USE_BLINK) && defined(__EMX__) /* Can't put it earler due to BOOLEAN conflict */
d2771 1
a2771 1
PRIVATE void make_blink_boldbg NOARGS
d2774 2
a2775 1
				/* but FS session need a switch */
d2779 1
a2779 1
    VioSetState(&buf,0);
d2787 1
a2787 1
PUBLIC long LYgetattrs ARGS1(WINDOW *, win)
d2789 5
d2798 1
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@a78 4
#define OMIT_SCN_KEEPING 0 /* whether to omit keeping of Style_className
    in HTML.c when lss support is on. 1 to increase performance. The value
    must correspond to the value of macro OMIT_SCN_KEEPING defined in HTML.c*/

d405 1
a405 1
PRIVATE int LYAttrset ARGS3(
a414 1
	return color;
a417 1
	return mono;
a420 1
	return A_NORMAL;
d479 1
a479 1
	    last_colorattr_ptr--;
d481 1
a481 1
	last_styles[last_colorattr_ptr++] = getattrs(win);
a582 1
    chtype attr;
d584 8
a591 8
    /*0*/ { DEFAULT_FG,    DEFAULT_BG,	A_NORMAL}, /* A_NORMAL */
    /*1*/ { COLOR_BLUE,    DEFAULT_BG,	A_NORMAL}, /* A_BOLD */
    /*2*/ { COLOR_YELLOW,  COLOR_BLUE,	A_BOLD},   /* A_REVERSE */
    /*3*/ { COLOR_GREEN,   DEFAULT_BG,	A_NORMAL}, /* A_REVERSE | A_BOLD */
    /*4*/ { COLOR_MAGENTA, DEFAULT_BG,	A_NORMAL}, /* A_UNDERLINE */
    /*5*/ { COLOR_BLUE,    DEFAULT_BG,	A_NORMAL}, /* A_UNDERLINE | A_BOLD */
    /*6*/ { COLOR_RED,	   DEFAULT_BG,	A_NORMAL}, /* A_UNDERLINE | A_REVERSE */
    /*7*/ { COLOR_MAGENTA, COLOR_CYAN,	A_NORMAL}  /* A_UNDERLINE | A_BOLD | A_REVERSE */
d613 1
a613 1
    	return 0;
d619 25
d660 1
a660 1
	attr = lynx_color_cfg[code].attr;
d672 4
a675 1
PRIVATE void lynx_map_color ARGS1(int, n)
d679 15
d705 1
a705 11
    if (lynx_called_initscr) {
	for (m = 0; m <= 16; m += 8) {
	    int pair = n + m + 1;
	    if (pair < COLOR_PAIRS)
		init_pair((short)pair,
		    (short)lynx_color_pairs[pair].fg,
		    (short)lynx_color_pairs[pair].bg);
	}
	if (n == 0 && LYShowColor >= SHOW_COLOR_ON)
	    wbkgd(LYwin, COLOR_BKGD | ' ');
    }
d708 4
d720 2
a721 3
	lynx_color_cfg[color].fg = (fg > 7) ? (fg & 7) : fg;
	lynx_color_cfg[color].bg = (bg > 7) ? (bg & 7) : bg;
	lynx_color_cfg[color].attr = ((fg > 7) && (fg & 8)) ? A_BOLD : A_NORMAL;
d732 1
a732 1
	wattrset(LYwin, lynx_color_cfg[a].attr
d750 1
a750 1
	size_t n, m;
d759 1
a759 9
	    for (m = 0; m <= 16; m += 8) {
		int pair = n + m + 1;
		if (pair < COLOR_PAIRS)
		    init_pair((short)pair,
			(short)lynx_color_pairs[pair].fg,
			(short)lynx_color_pairs[pair].bg);
	    }
	    if (n == 0 && LYShowColor >= SHOW_COLOR_ON)
		wbkgd(LYwin, COLOR_BKGD | ' ');
d827 5
d1008 2
d1064 11
d1159 12
d1319 3
d1337 4
a1340 1
#if (!defined(WIN_EX) || defined(__CYGWIN__))	/* @@@@@@ */
d1662 1
a1662 1
	    b = getattrs(form_window);
d2653 14
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d3 1
a7 1
#include <LYMainLoop.h>
d18 4
d37 4
d45 5
a49 1
#if defined(USE_COLOR_STYLE) && !USE_COLOR_TABLE
d52 9
a60 1
#define COLOR_BKGD ((COLOR_PAIRS >= 9) ? COLOR_PAIR(9) : A_NORMAL)
d71 6
a76 2
#if USE_COLOR_TABLE || defined(USE_SLANG)
PRIVATE int Current_Attr;
a82 1

d87 1
a95 1

d132 1
a132 1
    SLsmg_set_color(Current_Attr);
d139 19
a157 1
    SLsmg_set_color(Current_Attr);
d162 1
a173 1

d177 1
a177 7
    SLtt_set_mono(1, NULL, SLTT_BOLD_MASK);
    SLtt_set_mono(2, NULL, SLTT_REV_MASK);
    SLtt_set_mono(3, NULL, SLTT_REV_MASK | SLTT_BOLD_MASK);
    SLtt_set_mono(4, NULL, SLTT_ULINE_MASK);
    SLtt_set_mono(5, NULL, SLTT_ULINE_MASK | SLTT_BOLD_MASK);
    SLtt_set_mono(6, NULL, SLTT_ULINE_MASK | SLTT_REV_MASK);
    SLtt_set_mono(7, NULL, SLTT_ULINE_MASK | SLTT_BOLD_MASK | SLTT_REV_MASK);
d198 1
a198 1
#if !defined(_WINDOWS) && !defined(__DJGPP__)
d215 1
a215 1
   return;
d217 33
d251 35
a285 1
#else  /* Not slang: */
a286 1
#ifdef VMS
d288 1
a288 3
**  This function boxes windows with graphic characters for
**  VMS curses.  Pass it the window, it's height, and it's
**  width. - FM
d290 1
a290 1
PUBLIC void VMSbox ARGS3(
d292 1
a292 2
	int,		height,
	int,		width)
d294 10
d308 2
a309 2
    for (i = 1; i < width; i++)
       waddch(win, 'q');
d311 1
a311 1
    for (i = 1; i < height-1; i++) {
d314 1
a314 1
	wmove(win, i, width-1);
d319 2
a320 2
    for (i = 1; i < width; i++)
       waddch(win, 'q');
d322 1
a322 10
}
#else
/*
**  This function boxes windows for non-VMS (n)curses.
**  Pass it the window. - FM
*/
PUBLIC void LYbox ARGS2(
	WINDOW *,	win,
	BOOLEAN,	formfield GCC_UNUSED)
{
d345 1
d356 1
a360 1
}
d362 1
d364 1
d376 26
a401 15
PUBLIC void setStyle ARGS4(int,style,int,color,int,cattr,int,mono)
{
	displayStyles[style].color=color;
	displayStyles[style].cattr=cattr;
	displayStyles[style].mono=mono;
}

PUBLIC void setHashStyle ARGS5(int,style,int,color,int,cattr,int,mono,char*,element)
{
    bucket* ds=&hashStyles[style];
    CTRACE(tfp, "CSS(SET): <%s> hash=%d, ca=%d, ma=%d\n", element, style, color, mono);
    ds->color=color;
    ds->cattr=cattr;
    ds->mono=mono;
    ds->code=style;
d403 1
a403 4
    ds->name=malloc(sizeof(char)*(strlen(element)+2));
    if(!ds->name)
	outofmem(__FILE__, "setHashStyle");
    strcpy(ds->name, element);
d409 18
a426 14
PRIVATE int LYAttrset ARGS3(WINDOW*,win,int,color,int,mono)
{
	CTRACE(tfp, "CSS:LYAttrset (%#x, %#x)\n", color, mono);
	if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON && color > -1)
	{
		wattrset(win,color);
		return color;
	}
	if (mono > -1)
	{
		wattrset(win,mono);
		return mono;
	}
	wattrset(win,A_NORMAL);
d428 1
d438 2
a439 2
  /* if TRACEs are not compiled in, this macro is redundant - we neend't valid
    'ds' to stack off. */
d442 1
a442 1
	int YP,XP;
d444 1
a444 1
	bucket* ds= (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);
d446 2
a447 2
        bucket* ds= (style == NOSTYLE ?      &nostyle_bucket :
                (style== SPECIAL_STYLE ? &special_bucket :&hashStyles[style]) );
d451 2
a452 3
	if (!ds->name)
	{
		CTRACE(tfp, "CSS.CS:Style %d not configured\n",style);
d454 1
a454 1
		return;
d456 3
a458 1
	}
d460 1
a460 1
	CTRACE(tfp, "CSS.CS:<%s%s> (%d)\n",(dir?"":"/"),ds->name,ds->code);
d462 5
a466 1
	getyx (win, YP, XP);
d468 19
a486 5
	if (style == s_normal && dir)
	{
		wattrset(win,A_NORMAL);
		if (win==stdscr) cached_styles[YP][XP]=s_normal;
		return;
d488 2
a489 23

	switch (dir)
	{
		/* ABS_OFF is the same as STACK_OFF for the moment */
	case STACK_OFF:
		if (last_colorattr_ptr) {
		    int last_attr = last_styles[--last_colorattr_ptr];
		    LYAttrset(win,last_attr,last_attr);
		}
		else
			LYAttrset(win,A_NORMAL,-1);
		return;

	case STACK_ON: /* remember the current attributes */
		if (last_colorattr_ptr > 127) {
		    CTRACE(tfp,"........... %s (0x%x) %s\r\n",
				"attribute cache FULL, dropping last",
				last_styles[last_colorattr_ptr],
				"in LynxChangeStyle(curses_w_style)");
		    last_colorattr_ptr--;
		}
		last_styles[last_colorattr_ptr++] = getattrs(stdscr);
		/* don't cache style changes for active links */
d491 18
a508 24
                /* since we don't compute the hcode
                  to stack off in HTML.c, we don't know whether this style is
                  configured. So, we shouldn't simply return on stacking on on
                  unconfigured styles, we should push curr attrs on stack. -HV
                */
                if (!ds->name) return;
#endif
		if (style != s_alink)
		{
			CTRACE(tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP);
			if (win==stdscr) cached_styles[YP][XP]=style;
		}
		LYAttrset(win, ds->color, ds->mono);
		return;

	case ABS_ON: /* change without remembering the previous style */
		/* don't cache style changes for active links */
		if (style != s_alink)
		{
			CTRACE(tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP);
			if (win==stdscr) cached_styles[YP][XP]=style;
		}
                LYAttrset(win, ds->color, ds->mono);
		return;
d510 3
d518 19
a536 17
PUBLIC void wcurses_css ARGS3(WINDOW *,win,char*,name,int,dir)
{
	int try_again=1;
	while (try_again)
	{
		int tmpHash=hash_code(name);
		CTRACE(tfp, "CSSTRIM:trying to set [%s] style - ", name);
		if (tmpHash==NOSTYLE) {
			char *class=strrchr(name, '.');
			CTRACE(tfp, "undefined, trimming at %p\n", class);
			if (class)	*class='\0';
			else		try_again=0;
		} else {
			CTRACE(tfp, "ok (%d)\n", hash_code(name));
			curses_w_style(win, hash_code(name), dir);
			try_again=0;
		}
d538 1
d541 3
a543 1
PUBLIC void curses_css ARGS2(char *,name,int,dir)
d545 1
a545 1
    wcurses_css(stdscr, name, dir);
d552 1
a552 1
    curses_w_style(stdscr, style, dir);
d554 3
d558 6
a563 2
#ifdef NOT_USED
void attribute ARGS2(int,style,int,dir)
d565 10
a574 1
    curses_style(style, dir, 0);
d576 1
a576 2
#endif
#endif /* USE_COLOR_STYLE */
d578 1
a578 1
#if USE_COLOR_TABLE && defined(COLOR_CURSES)
a586 1
PRIVATE int lynx_called_initscr;
d611 16
a635 9
	static int NoColorVideo = -1;

#ifdef UNIX
	if (NoColorVideo < 0) {
		NoColorVideo = tigetnum("ncv");
	}
	if (NoColorVideo < 0)
		NoColorVideo = 0;
#endif /* UNIX */
d638 1
a638 1
		code |= 1;
d640 1
a640 1
		code |= 2;
d642 1
a642 1
		code |= 4;
a644 12
	/*
	 * no_color_video isn't implemented (97/4/14) in ncurses 4.1, but may
	 * be in SVr4 (which would make this redundant for the latter).
	 */
	if ((Current_Attr & A_BOLD) && !(NoColorVideo & 33)) {
		attr |= A_BOLD;
	}

	if ((Current_Attr == A_UNDERLINE) && !(NoColorVideo & 2)) {
		attr |= A_UNDERLINE;
	}

d646 1
a646 1
		attr |= COLOR_PAIR(code+offs);
d649 1
a649 1
	wattrset(win, attr);
d651 1
a651 1
	wattrset(win, Current_Attr);
d659 2
d674 3
a676 3
		init_pair(pair,
		    lynx_color_pairs[pair].fg,
		    lynx_color_pairs[pair].bg);
d679 1
a679 1
	    bkgd(COLOR_BKGD | ' ');
d704 1
a704 1
	attrset(lynx_color_cfg[a].attr
d706 1
a706 1
			? COLOR_PAIR(a+1)
d724 3
d730 1
a730 1
	for (n = 0; n < sizeof(lynx_color_cfg)/sizeof(lynx_color_cfg[0]); n++) {
d734 3
a736 3
		    init_pair(pair,
			lynx_color_pairs[pair].fg,
			lynx_color_pairs[pair].bg);
d739 1
a739 1
		bkgd(COLOR_BKGD | ' ');
d749 1
d755 2
a756 7
#ifdef NOTUSED
#if defined (DJGPP) && !defined (USE_SLANG)
/*
 * Sorry about making a completely new function,
 * but the real one is messy! WB
 */
PUBLIC void start_curses NOARGS
d758 13
a770 30
    static BOOLEAN first_time = TRUE;

    if(first_time)
    {
	initscr();		/* start curses */
	first_time = FALSE;
	cbreak();
	keypad(stdscr, TRUE);
	fflush(stdin);
	fflush(stdout);
	if (has_colors()) {
	    lynx_has_color = TRUE;
	    start_color();
	}
	lynx_init_colors();
	lynx_called_initscr = TRUE;

	/* Inform pdcurses that we're interested in knowing when mouse buttons
	 * are clicked.  Maybe someday pdcurses will support it.
	 */
	if (LYUseMouse)
	    lynx_enable_mouse (1);

    } else
	sock_init();

    LYCursesON = TRUE;
    CTRACE(tfp, "start_curses: done.\n");
    clear();
    noecho();
a771 3
#else
#endif /* defined (DJGPP) && !defined (USE_SLANG) */
#endif /* NOTUSED */
d773 33
d813 1
a813 1
	CTRACE(tfp, "start_curses: Hmm, already ON.\n");
d818 4
d823 2
a824 1
#if defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)
d828 1
a828 1
#ifdef UNIX
d832 1
a832 1
#endif /* UNIX */
d834 4
d868 5
a872 3
#if defined(VMS) || defined(UNIX)
	SLtt_add_color_attribute(4, SLTT_ULINE_MASK);
	SLtt_add_color_attribute(5, SLTT_ULINE_MASK);
d877 2
a878 6
	if (LYShowColor && (Lynx_Color_Flags & SL_LYNX_USE_BLINK)) {
	    SLtt_Blink_Mode = 1;
	} else {
	    SLtt_Blink_Mode = 0;
	}
#endif /* VMS || UNIX */
d881 1
a881 1
    else sock_init();
d899 3
d903 1
a903 1
#if !defined(_WINDOWS) && !defined(__DJGPP__)
d905 1
a905 1
#endif /* !_WINDOWS */
d913 1
a913 3
   lynx_enable_mouse (1);

#else /* Using curses: */
d915 2
d923 1
d927 12
a938 1
    static BOOLEAN first_time = TRUE;
d940 1
a940 1
    if (first_time) {
d945 29
a973 1
	if (initscr() == NULL) {  /* start curses */
d976 1
a976 1
	    exit_immediately (-1);
d978 6
d988 12
d1001 11
a1011 2
	if (-1 == lynx_initialize_keymaps ())
	    exit (-1);
d1037 9
a1045 4
#if HAVE_USE_DEFAULT_COLORS
	    if (use_default_colors() == OK) {
		default_fg = DEFAULT_COLOR;
		default_bg = DEFAULT_COLOR;
d1047 18
d1066 2
d1074 1
a1074 2
	first_time = FALSE;
#if USE_COLOR_TABLE
a1075 1
	lynx_called_initscr = TRUE;
d1079 1
a1079 1
    else sock_init();
d1089 1
a1089 1
#if HAVE_CBREAK
d1099 3
a1101 2
#if HAVE_KEYPAD
    keypad(stdscr,TRUE);
d1104 1
a1104 1
   lynx_enable_mouse (1);
d1111 7
a1117 2
#ifdef _WINDOWS
    clear();
d1121 2
a1122 2
    CTRACE(tfp, "start_curses: done.\n");
}
d1127 2
d1130 1
a1130 1
#ifdef __BORLANDC__
d1132 1
a1132 2
   is disabled unless -use_mouse is specified.  This is ifdef'd with
   __BORLANDC__ for the time being (WB).
d1147 1
a1147 1
#ifdef USE_SLANG_MOUSE
d1152 1
a1152 2
#ifdef NCURSES_MOUSE_VERSION
#if defined(__BORLANDC__) && defined(__PDCURSES__)
d1159 1
a1159 5
    /* Inform ncurses that we're interested in knowing when mouse
     * button 1 is clicked.  We cannot just specify
     * BUTTON1_CLICKED | BUTTON3_CLICKED, since ncurses will try hard
     * to translate other events to single-clicks.
     * Compensate for small value of maxclick in ncurses.  */
d1161 1
d1171 18
a1188 1
	mousemask(ALL_MOUSE_EVENTS, NULL);
d1191 2
a1192 2
#endif /* __BORLANDC__ and __PDCURSES__ */
#endif /* NCURSES_MOUSE_VERSION */
d1194 1
a1194 1
#if defined(DJGPP) && !defined(USE_SLANG)
d1196 66
a1261 1
	mouse_set(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED);
a1262 1
#endif				       /* NOT USE_SLANG_MOUSE */
d1267 11
a1277 3
    echo();
#ifdef DJGPP
    sock_exit();
a1278 2
#if defined (DOSPATH) && !defined(USE_SLANG)
    clrscr();
a1280 4
    /*
     *	Fixed for better dumb terminal support.
     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     */
d1282 15
a1296 2
	 lynx_enable_mouse (0);
	 endwin();	/* stop curses */
d1298 1
d1301 1
a1301 1
#endif /* DJGPP */
d1305 1
a1305 1
    CTRACE(tfp, "stop_curses: done.\n");
d1324 1
a1324 1
	char *, 	terminal)
d1354 1
a1354 1
	LYcols = 80;
a1368 1
    sleep(InfoSecs);
d1385 2
a1386 6
    LYlines = LINES;
    LYcols = COLS;
    if (LYlines <= 0)
	LYlines = 24;
    if (LYcols <= 0)
	LYcols = 80;
d1397 1
a1397 1
	char *, 	terminal)
a1401 14
#if defined(HAVE_SIZECHANGE) && !defined(USE_SLANG) && defined(NOTDEFINED)
/*
 *  Hack to deal with a problem in sysV curses, that screen can't be
 *  resized to greater than the size used by initscr, which can only
 *  be called once.  So set environment variables LINES and COLUMNS
 *  to some suitably large size to force initscr to allocate enough
 *  space.  Later we get the real window size for setting LYlines
 *  and LYcols. - AJL & FM
 *
 *  Has problems, so we don't use this hack, but the code is here
 *  if someone wants to play with it some more. - FM
 */
    char *lines_putenv = NULL;
    char *cols_putenv = NULL;
d1403 4
a1406 12
    if (getenv("LINES") == NULL && getenv("COLUMNS") == NULL) {
	StrAllocCopy(lines_putenv, "LINES=120");
	(void) putenv(lines_putenv);
	StrAllocCopy(cols_putenv, "COLUMNS=240");
	(void) putenv(cols_putenv);
    }
#endif /* HAVE_SIZECHANGE && !USE_SLANG && NOTDEFINED */

   /*
    *  If the display was not set by a command line option then
    *  see if it is available from the environment .
    */
d1421 1
a1421 3
    if (dumbterm(getenv("TERM"))) {
	char *s;

d1425 4
a1428 3
	if (LYSafeGets(&buffer, stdin) != 0)
	    if ((s = strchr(buffer, '\n')) != NULL)
		*s = '\0';
d1430 1
a1430 1
	if (buffer == 0 || *buffer == 0)
d1437 2
a1438 2
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"), getenv("TERM"));
	sleep(MESSAGESECS);
d1443 1
a1443 1
#if HAVE_TTYTYPE
d1445 6
a1450 1
     *	Get terminal type (strip 'dec-' from vms style types).
d1452 2
a1453 2
    if (strncmp((CONST char*)ttytype, "dec-vt", 6) == 0) {
	(void) setterm(ttytype + 4);
d1457 2
a1458 27
#if defined(HAVE_SIZECHANGE) && !defined(USE_SLANG) && defined(NOTDEFINED)
    if (lines_putenv != NULL) {
	/*
	 *  Use SIGWINCH handler to set the true window size. - AJL && FM
	 *
	 *  Has problems, so we don't use this hack, but the code is here
	 *  if someone wants to play with it some more. - FM
	 */
	size_change(0);
	lines_putenv[6] = '\0';
	(void) putenv(lines_putenv);
	cols_putenv[8] = '\0';
	(void) putenv(cols_putenv);
	FREE(lines_putenv);
	FREE(cols_putenv);
    } else {
	LYlines = LINES;
	LYcols = COLS;
    }
#else
    LYlines = LINES;
    LYcols = COLS;
#endif /* HAVE_SIZECHANGE && !USE_SLANG && USE_NOTDEFINED */
    if (LYlines <= 0)
	LYlines = 24;
    if (LYcols <= 0)
	LYcols = 80;
d1464 1
a1464 1
	char *, 	terminal)
d1485 1
a1485 1
#if USE_COLOR_TABLE
d1497 1
a1497 1
    LYaddWAttr(stdscr, a);
d1511 1
a1511 1
    LYsubWAttr(stdscr, a);
d1518 103
d1651 173
d1887 2
a1888 2
static	unsigned char buffer[20];	/* Input buffer 		*/
static	int	in_pos, in_len; 	/* For escape sequences 	*/
d1891 1
a1891 1
static	short	iochan; 		/* TTY I/O channel		*/
d1900 1
a1900 1
	char *, 	VerString,
a1969 1
	extern	void cleanup_sig();
d2219 2
a2220 2
	void *, 	sigarr,
	void *, 	mecharr)
d2223 2
a2224 2
	void *, 	sigarr,
	void *, 	mecharr)
d2234 1
a2234 1
	char *, 	command)
d2284 1
a2284 1
	char *, 	command)
a2286 1
     extern void controlc();
d2298 104
a2403 12
#if defined(COLOR_CURSES)
    chtype a;
    if (LYShowColor >= SHOW_COLOR_ON)
	a = COLOR_BKGD;
    else
	a = A_NORMAL;
    bkgdset(a | ' ');
#ifndef USE_COLOR_STYLE
    bkgd(a | ' ');
#endif
    attrset(a);
#endif /* COLOR_CURSES */
d2409 3
d2416 3
d2458 1
a2458 1
    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_OFF, 0);
d2486 3
a2488 3
   stop_underline();
   stop_reverse();
   stop_bold();
d2493 3
a2495 3
   start_bold();
   start_reverse();
   start_underline();
d2501 1
a2501 1
#if USE_COLOR_TABLE && defined(COLOR_CURSES)
d2511 1
a2511 1
#if USE_COLOR_TABLE && defined(COLOR_CURSES)
d2521 2
a2522 2
   if (bold_H1 || bold_headers)
     start_bold();
d2527 2
a2528 2
   if (bold_H1 || bold_headers)
     stop_bold();
d2533 1
a2533 1
   start_reverse ();
d2538 1
a2538 1
   stop_reverse ();
d2543 1
a2543 1
   start_bold ();
d2548 1
a2548 1
   stop_bold ();
d2553 3
a2555 3
   stop_underline ();
   stop_reverse ();
   stop_bold ();
d2557 40
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a2 7

#ifdef __MINGW32__
#ifdef UNIX
#undef UNIX
#endif /* UNIX */
#endif /* __MINGW32__ */

d7 1
a13 1
#include <HTFont.h>
a17 4
#ifdef VMS
#include <LYMainLoop.h>
#endif

a32 4
#ifdef NEED_WCHAR_H
#include <wchar.h>
#endif

d37 1
a37 5
#ifdef HAVE_XCURSES
char *XCursesProgramName = "Lynx";
#endif

#if defined(USE_COLOR_STYLE) && !defined(USE_COLOR_TABLE)
d40 1
a40 9
#define COLOR_BKGD ((COLOR_PAIRS >= 9) ? get_color_pair(9) : A_NORMAL)
#endif

#ifdef USE_CURSES_PADS
WINDOW *LYwin = 0;
int LYshiftWin = 0;
int LYwideLines = FALSE;
int LYtableCols = 0;		/* in 1/12 of screen width */
BOOL LYuseCursesPads = TRUE;	/* use pads for left/right shifting */
d44 2
a45 2
 * These are routines to start and stop curses and to cleanup the screen at the
 * end.
d48 1
a48 1
static int dumbterm(char *terminal);
d51 2
a52 2
#if defined(USE_BLINK) && defined(__EMX__)
static void make_blink_boldbg(void);
d55 4
a58 3
#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
int Current_Attr, Masked_Attr;
#endif
d61 3
a63 4
unsigned int Lynx_Color_Flags = 0;
BOOLEAN FullRefresh = FALSE;
int curscr = 0;

d66 1
a66 1
 * Will be set by size_change.  - KW
d68 1
a68 1
int PHYSICAL_SLtt_Screen_Cols = 10;
d71 3
a73 1
void LY_SLrefresh(void)
d90 1
a90 1
void LY_SLerase(void)
d92 2
a93 2
    SLsmg_gotorc(0, 0);
    SLsmg_erase_eos();
d97 1
a97 1
void VTHome(void)
d105 2
a106 1
void LYaddAttr(int a)
d109 1
a109 1
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
d112 2
a113 1
void LYsubAttr(int a)
d116 1
a116 20
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
}

static void lynx_setup_attrs(void)
{
    static int monoattr[] =
    {
	0,
	SLTT_BOLD_MASK,
	SLTT_REV_MASK,
	SLTT_REV_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK | SLTT_REV_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK | SLTT_REV_MASK
    };
    int n;

    for (n = 1; n <= 7; n++)
	SLtt_set_mono(n, NULL, (monoattr[n] & ~Masked_Attr));
d119 1
a119 1
void lynx_setup_colors(void)
a120 1
    CTRACE((tfp, "lynx_setup_colors\n"));
d122 3
a124 3
    SLtt_set_color(1, NULL, "blue", DEFAULT_BG);	/* bold */
    SLtt_set_color(2, NULL, "yellow", "blue");	/* reverse */
    SLtt_set_color(4, NULL, "magenta", DEFAULT_BG);	/* underline */
d126 1
a126 1
     * The other objects are '|'ed together to get rest.
d128 5
a132 4
    SLtt_set_color(3, NULL, "green", DEFAULT_BG);	/* bold-reverse */
    SLtt_set_color(5, NULL, "blue", DEFAULT_BG);	/* bold-underline */
    SLtt_set_color(6, NULL, "red", DEFAULT_BG);		/* reverse-underline */
    SLtt_set_color(7, NULL, "magenta", "cyan");		/* reverse-underline-bold */
d134 1
a134 1
     * Now set monochrome attributes.
d136 7
a142 1
    lynx_setup_attrs();
d145 2
a146 1
static void sl_suspend(int sig)
d152 1
a152 1
    lynx_enable_mouse(0);
d156 1
a156 1
    kill(getpid(), SIGSTOP);
d163 1
a163 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d169 1
a169 1
     * Get new window size in case it changed.
d177 1
a177 1
    lynx_enable_mouse(1);
d180 1
a180 1
    return;
a181 1
#else
d183 1
a183 69
#ifdef FANCY_CURSES

#ifndef VMS
/* *INDENT-OFF* */
/* definitions for the mono attributes we can use */
static struct {
    const char *name;
    int code;
} Mono_Attrs[7] =
{
    { "normal",		A_NORMAL },
    { "bold",		A_BOLD },
    { "reverse",	A_REVERSE },
    { "underline",	A_UNDERLINE },
    { "standout",	A_STANDOUT },
    { "blink",		A_BLINK },
    { "dim",		A_DIM },
};
/* *INDENT-ON* */

int string_to_attr(char *name)
{
    unsigned i;

    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (!strcasecomp(Mono_Attrs[i].name, name)) {
	    return Mono_Attrs[i].code;
	}
    }
    return 0;
}
#endif /* VMS */

#ifdef USE_COLOR_STYLE
static char *attr_to_string(int code)
{
    static char result[sizeof(Mono_Attrs) + 80];
    unsigned i;
    int pair = PAIR_NUMBER(code);
    int bold = (pair != 0 && (code & A_BOLD) != 0);

    if (bold)
	code &= ~A_BOLD;

    *result = 0;
    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (Mono_Attrs[i].code & code) {
	    if (*result)
		strcat(result, "+");
	    strcat(result, Mono_Attrs[i].name);
	}
    }
    if (pair != 0) {
	short f, b;

	if (pair_content(pair, &f, &b) != ERR) {
	    const char *fg = lookup_color(bold ? f + COLORS : f);
	    const char *bg = lookup_color(b);

	    if (*result)
		strcat(result, "+");
	    sprintf(result + strlen(result), "%s/%s", fg, bg);
	}
    }
    return result;
}
#endif /* USE_COLOR_STYLE */
#endif /* FANCY_CURSES */
#endif /* USE_SLANG */
d185 1
d187 8
a194 3
 *  This function boxes windows for (n)curses.
 */
void LYbox(WINDOW * win, BOOLEAN formfield GCC_UNUSED)
a195 10
#ifdef USE_SLANG
    SLsmg_draw_box(win->top_y, win->left_x, win->height, win->width + 4);
#else
#ifdef VMS
    /*
     * This should work for VAX-C and DEC-C, since they both have the same
     * win._max_y and win._max_x members -TD
     *
     * (originally VMSbox by FM)
     */
d200 2
a201 2
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
d203 1
a203 1
    for (i = 1; i < win->_max_y - 1; i++) {
d206 1
a206 1
	wmove(win, i, win->_max_x - 1);
d211 2
a212 2
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
d214 10
a223 1
#else /* !VMS */
d225 6
a230 6
     * If the terminal is in UTF-8 mode, it probably cannot understand box
     * drawing characters as (n)curses handles them.  (This may also be true
     * for other display character sets, but isn't currently checked.) In that
     * case, substitute ASCII characters for BOXVERT and BOXHORI if they were
     * defined to 0 for automatic use of box drawing characters.  They'll stay
     * as they are otherwise.  - KW & FM
d240 5
a244 4
     * If we don't have explicitly specified characters for either vertical or
     * horizontal lines, the characters that box() would use for the corners
     * probably also won't work well.  So we specify our own ASCII characters
     * for the corners and call wborder() instead of box().  - kw
a245 1
    LynxWChangeStyle(win, s_menu_frame, STACK_ON);
a255 1
    LynxWChangeStyle(win, s_menu_frame, STACK_OFF);
d260 1
a261 1
    wrefresh(win);
a262 1
}
d269 1
a269 1
HTCharStyle displayStyles[DSTYLE_ELEMENTS];
d274 15
a288 26
void setStyle(int style,
	      int color,
	      int cattr,
	      int mono)
{
    displayStyles[style].color = color;
    displayStyles[style].cattr = cattr;
    displayStyles[style].mono = mono;
}

void setHashStyle(int style,
		  int color,
		  int cattr,
		  int mono,
		  char *element)
{
    bucket *ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE,
	    (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n",
	     element, style, color, mono));

    ds->color = color;
    ds->cattr = cattr;
    ds->mono = mono;
    ds->code = style;
d290 4
a293 1
    StrAllocCopy(ds->name, element);
d299 1
a299 2
static void LYAttrset(WINDOW * win, int color,
		      int mono)
d301 13
a313 14
    if (lynx_has_color
	&& LYShowColor >= SHOW_COLOR_ON
	&& color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color (%s)\n",
			      attr_to_string(color)));
	wattrset(win, color);
    } else if (mono >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono (%s)\n",
			      attr_to_string(mono)));
	wattrset(win, mono);
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset (A_NORMAL)\n"));
	wattrset(win, A_NORMAL);
    }
d316 4
a319 2
void curses_w_style(WINDOW * win, int style,
		    int dir)
d323 2
a324 2
/* if TRACEs are not compiled in, this macro is redundant - we needn't valid
'ds' to stack off. */
d327 1
a327 2
    int YP, XP;

d329 1
a329 2
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);

d331 2
a332 2
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket :
		  (style == SPECIAL_STYLE ? &special_bucket : &hashStyles[style]));
d335 4
a338 2
    if (!ds->name) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n", style));
d340 1
a340 1
	return;
d342 3
a344 1
    }
d346 1
a346 12
    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> (%d)\n",
			  (dir ? "" : "/"),
			  ds->name, ds->code));

    getyx(win, YP, XP);

    if (style == s_normal && dir) {
	wattrset(win, A_NORMAL);
	if (win == LYwin)
	    cached_styles[YP][XP] = s_normal;
	return;
    }
d348 5
a352 18
    switch (dir) {
	/* ABS_OFF is the same as STACK_OFF for the moment */
    case STACK_OFF:
	if (last_colorattr_ptr) {
	    int last_attr = last_styles[--last_colorattr_ptr];

	    LYAttrset(win, last_attr, last_attr);
	} else
	    LYAttrset(win, A_NORMAL, -1);
	break;

    case STACK_ON:		/* remember the current attributes */
	if (last_colorattr_ptr >= MAX_LAST_STYLES) {
	    CTRACE2(TRACE_STYLE, (tfp, "........... %s (0x%x) %s\r\n",
				  "attribute cache FULL, dropping last",
				  last_styles[last_colorattr_ptr],
				  "in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr = MAX_LAST_STYLES - 1;
d354 23
a376 2
	last_styles[last_colorattr_ptr++] = LYgetattrs(win);
	/* don't cache style changes for active links */
d378 24
a401 21
	/* since we don't compute the hcode to stack off in HTML.c, we
	 * don't know whether this style is configured.  So, we
	 * shouldn't simply return on stacking on unconfigured
	 * styles, we should push curr attrs on stack.  -HV
	 */
	if (!ds->name)
	    break;
#endif
	/* FALL THROUGH */
    case ABS_ON:		/* change without remembering the previous style */
	/* don't cache style changes for active links and edits */
	if (style != s_alink
	    && style != s_curedit
	    && style != s_aedit
	    && style != s_aedit_sel
	    && style != s_aedit_pad
	    && style != s_aedit_arr) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n",
				  ds->name, YP, XP));
	    if (win == LYwin)
		cached_styles[YP][XP] = style;
a402 3
	LYAttrset(win, ds->color, ds->mono);
	break;
    }
d408 1
a408 2
void wcurses_css(WINDOW * win, char *name,
		 int dir)
d410 15
a424 18
    int try_again = 1;

    while (try_again) {
	int tmpHash = hash_code(name);

	CTRACE2(TRACE_STYLE, (tfp, "CSSTRIM:trying to set [%s] style - ", name));
	if (tmpHash == NOSTYLE) {
	    char *pclass = strrchr(name, '.');

	    CTRACE2(TRACE_STYLE, (tfp, "undefined, trimming at %p\n", pclass));
	    if (pclass)
		*pclass = '\0';
	    else
		try_again = 0;
	} else {
	    CTRACE2(TRACE_STYLE, (tfp, "ok (%d)\n", hash_code(name)));
	    curses_w_style(win, hash_code(name), dir);
	    try_again = 0;
a425 1
    }
d428 1
a428 2
void curses_css(char *name,
		int dir)
d430 1
a430 1
    wcurses_css(LYwin, name, dir);
d433 3
a435 2
void curses_style(int style,
		  int dir)
d437 1
a437 1
    curses_w_style(LYwin, style, dir);
a438 3
#endif /* USE_COLOR_STYLE */

static BOOL lynx_called_initscr = FALSE;
d440 2
a441 6
#if defined(HAVE_USE_DEFAULT_COLORS) && defined(USE_DEFAULT_COLORS)
/*
 * If we find a "default" color while reading the config-file, set default
 * colors on the screen.
 */
int lynx_default_colors(void)
d443 1
a443 11
    int code = 0;

    if (lynx_called_initscr) {
	code = -1;
	if (!default_color_reset && use_default_colors() == OK) {
	    default_fg = DEFAULT_COLOR;
	    default_bg = DEFAULT_COLOR;
	    code = 1;
	}
    }
    return code;
d445 2
a446 1
#endif /* HAVE_USE_DEFAULT_COLORS && USE_DEFAULT_COLORS */
d448 1
a448 1
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
d457 3
a459 2
/* *INDENT-OFF* */
static struct {
d461 1
d463 8
a470 8
    /*0*/ { DEFAULT_FG,    DEFAULT_BG},
    /*1*/ { COLOR_BLUE,    DEFAULT_BG},
    /*2*/ { COLOR_YELLOW+8,COLOR_BLUE},
    /*3*/ { COLOR_GREEN,   DEFAULT_BG},
    /*4*/ { COLOR_MAGENTA, DEFAULT_BG},
    /*5*/ { COLOR_BLUE,    DEFAULT_BG},
    /*6*/ { COLOR_RED,	   DEFAULT_BG},
    /*7*/ { COLOR_MAGENTA, COLOR_CYAN}
a471 1
/* *INDENT-ON* */
d476 1
a476 1
static struct {
a481 43
 * If we find an exact match for the given default colors, force curses to use
 * color pair 0, which corresponds to the terminal's default colors.  Normally
 * curses assumes white-on-black, but we can override the assumption with this
 * function.
 */
static int get_color_pair(int n)
{
#ifdef USE_CURSES_PAIR_0
    if (lynx_color_pairs[n].fg == default_fg
	&& lynx_color_pairs[n].bg == default_bg)
	return 0;
#endif
    return COLOR_PAIR(n);
}

/*
 * Lynx "knows" about 16 colors.  ANSI colors (and most color terminal
 * emulators) only go to 8, though some curses implementations (ncurses and
 * PDCurses) handle 16.  If lynx's configuration calls for a color past the
 * number of colors that the terminal handles (COLORS), map the extra value
 * to bold.
 */
#define is_boldc(c) ((c) > (COLORS-1))
#define map2bold(c) (is_boldc(c) ? ((c) & (COLORS-1)) : (c))

/*
 * Return the extra color as A_BOLD.
 * If there is no extra color, return A_NORMAL.
 */
static int lynx_color_cfg_attr(int code)
{
    int result = A_NORMAL;

    if (code >= 0 && code < 8) {
	int fg = lynx_color_cfg[code].fg;

	if (is_boldc(fg) && (fg & COLORS))
	    result = A_BOLD;
    }
    return result;
}

/*
d485 1
a485 1
static void LYsetWAttr(WINDOW * win)
d491 9
d502 1
a502 1
	    code |= 1;
d504 1
a504 1
	    code |= 2;
d506 14
a519 2
	    code |= 4;
	attr = lynx_color_cfg_attr(code);
d521 2
a522 2
	if (code + offs < COLOR_PAIRS) {
	    attr |= get_color_pair(code + offs);
d525 1
a525 1
	wattrset(win, attr & ~Masked_Attr);
d527 1
a527 1
	wattrset(win, Current_Attr & ~Masked_Attr);
d531 1
a531 4
/*
 * Initialize a curses color-pair based on our configured color values.
 */
static void lynx_init_color_pair(int n)
d535 9
a546 1

d548 3
a550 3
		init_pair((short) pair,
			  (short) map2bold(lynx_color_pairs[pair].fg),
			  (short) map2bold(lynx_color_pairs[pair].bg));
d553 1
a553 1
	    wbkgd(LYwin, COLOR_BKGD | ' ');
d557 5
a561 24
static void lynx_map_color(int n)
{
    CTRACE((tfp, "lynx_map_color(%d)\n", n));

    lynx_color_pairs[n + 1].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n + 1].bg = lynx_color_cfg[n].bg;

    lynx_color_pairs[n + 9].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n + 9].bg = lynx_color_cfg[0].bg;

    lynx_color_pairs[n + 17].fg = lynx_color_cfg[n].bg;
    lynx_color_pairs[n + 17].bg = lynx_color_cfg[n].bg;

    lynx_init_color_pair(n);
}

/*
 * Change a configured color value.  This may be called before initscr(), so
 * we may not be able to call init_pair() to finish the change.
 */
int lynx_chg_color(int color,
		   int fg,
		   int bg
)
d563 1
a563 2
    if (fg == ERR_COLOR || bg == ERR_COLOR)
	return -1;
d565 3
a567 2
	lynx_color_cfg[color].fg = fg;
	lynx_color_cfg[color].bg = bg;
d575 1
a575 1
void lynx_set_color(int a)
d578 4
a581 4
	wattrset(LYwin, lynx_color_cfg_attr(a)
		 | (((a + 1) < COLOR_PAIRS)
		    ? get_color_pair(a + 1)
		    : A_NORMAL));
d585 1
a585 1
void lynx_standout(int flag)
d593 1
a593 1
static void lynx_init_colors(void)
d596 1
a596 4
	size_t n;

	CTRACE((tfp, "lynx_init_colors (default %d/%d)\n",
		default_fg, default_bg));
d601 10
a610 2
	for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
	    lynx_init_color_pair(n);
d617 1
a617 1
void lynx_setup_colors(void)
a619 2

    CTRACE((tfp, "lynx_setup_colors\n"));
d625 7
a631 1
void LYnoVideo(int a)
d633 16
a648 20
    CTRACE((tfp, "LYnoVideo(%d)\n", a));
#ifdef USE_SLANG
    if (a & 1)
	Masked_Attr |= SLTT_BOLD_MASK;
    if (a & 2)
	Masked_Attr |= SLTT_REV_MASK;
    if (a & 4)
	Masked_Attr |= SLTT_ULINE_MASK;
    lynx_setup_attrs();
#else
#ifdef USE_COLOR_TABLE
    if (a & 1)
	Masked_Attr |= A_BOLD;
    if (a & 2)
	Masked_Attr |= A_REVERSE;
    if (a & 4)
	Masked_Attr |= A_UNDERLINE;
#endif
#endif
}
d650 5
a654 8
#define NEWTERM_NAME "newterm"
#if       !defined(VMS) && !defined(USE_SLANG)
/*
 * If newterm is not defined, assume a curses subset which
 * supports only initscr.  --gil
 */
#if defined(HAVE_NEWTERM) && defined(HAVE_DELSCREEN) && !(defined(NCURSES) && defined(HAVE_RESIZETERM))
static SCREEN *LYscreen = NULL;
d656 2
a657 10
#define LYDELSCR() { \
if (recent_sizechange) { \
    CTRACE((tfp, "Screen size: delscreen()\n")); \
    delscreen(LYscreen); \
    LYscreen = NULL; } }
/*
 * Surrogates for newterm annd delscreen
 */
#else /* HAVE_NEWTERM   */
static WINDOW *LYscreen = NULL;
d659 8
a666 15
#undef  NEWTERM_NAME
#define NEWTERM_NAME "initscr"
#undef  newterm
#define newterm(type, out, in) (initscr())
#define LYDELSCR()		/* nothing */
#endif /* HAVE_NEWTERM   */
#else /* !defined(VMS) && !defined(USE_SLANG) */
/*
 * Provide last recourse definitions of LYscreen and LYDELSCR for
 * stop_curses, which only tests LYscreen for zero/nonzero but
 * never uses it as a pointer or L-value.
 */
#define LYscreen TRUE
#define LYDELSCR()		/* nothing */
#endif /* !defined(VMS) && !defined(USE_SLANG) */
a667 4
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
int saved_scrsize_x = 0;
int saved_scrsize_y = 0;
#endif
d669 1
a669 1
void start_curses(void)
d675 1
a675 1
	CTRACE((tfp, "start_curses: Hmm, already ON.\n"));
a679 4
#if defined(USE_KEYMAPS)
	if (-1 == lynx_initialize_keymaps())
	    exit_immediately(EXIT_FAILURE);
#else
d681 2
a682 3
#endif
#if (defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)) || defined(__CYGWIN__)
	SLkp_init();
d685 1
a685 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d689 1
a689 1
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
a690 4
#if !defined(USE_KEYMAPS) && defined(ENHANCED_LINEEDIT) && defined(ESCDELAY)
	/* way to get ESC that's not part of a recognized sequence through */
	ESCDELAY = 2000;
#endif
d692 1
a692 1
	 * Check whether a saved show_color:off override is in effect.  - kw
d698 1
a698 1
	 * Check whether we're forcing color on.  - FM
d703 1
a703 1
	 * Check whether a -nocolor override is in effect.  - kw
d708 1
a708 1
	 * Make sure our flags are in register.  - FM
d721 3
a723 5
#if (defined(VMS) || defined(REAL_UNIX_SYSTEM)) && !defined(__CYGWIN__)
	if ((Masked_Attr & SLTT_ULINE_MASK) == 0) {
	    SLtt_add_color_attribute(4, SLTT_ULINE_MASK);
	    SLtt_add_color_attribute(5, SLTT_ULINE_MASK);
	}
d725 2
a726 2
	 * If set, the blink escape sequence will turn on high intensity
	 * background (rxvt and maybe Linux console).
d728 6
a733 2
	SLtt_Blink_Mode = term_blink_is_boldbg;
#endif /* (VMS || REAL_UNIX_SYSTEM) && !__CYGWIN__  */
d736 1
a736 1
    _eth_init();
d751 2
a752 2
	SLsmg_Display_Eight_Bit = 191;	/* may print ctrl chars otherwise - kw */
    scrollok(0, 0);
a753 3
#if SLANG_VERSION > 10306
    SLsmg_touch_screen();
#endif
d755 1
a755 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d757 1
a757 1
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
d765 3
a767 1
    lynx_enable_mouse(1);
a768 2
#else /* USE_SLANG; Now using curses: */
    int keypad_on = 0;
d772 2
a773 11
     * If we are VMS then do initscr() everytime start_curses() is called!
     */
    CTRACE((tfp, "Screen size: initscr()\n"));
    initscr();			/* start curses */
#else /* Unix: */

#ifdef __CYGWIN__
    /*
     * Workaround for buggy Cygwin, which breaks subprocesses of a
     * full-screen application (tested with cygwin dll, dated
     * 2002/6/23 -TD)
d775 2
a776 2
    if (!lynx_called_initscr) {
	FILE *fp = fopen("/dev/tty", "w");
d778 1
a778 4
	if (fp != 0)
	    stdout = fp;
    }
#endif
d780 1
a780 1
    if (!LYscreen) {
d782 2
a783 1
	 * If we're not VMS then only do initscr() one time, and one time only!
d785 1
a785 28
#if defined(HAVE_NEWTERM)
#if !(defined(NCURSES) && !defined(HAVE_RESIZETERM))
	BOOLEAN savesize;

	savesize = recent_sizechange;
	size_change(0);
	recent_sizechange = savesize;	/* avoid extra redraw */
#if defined(__MVS__)
	{
	    /*
	     * The requirement to do this may be a bug in OS/390.
	     *
	     * Put screen geometry in environment variables used by
	     * XOpen curses before calling newterm().  I believe this
	     * completes work left unfinished by AJL & FM -- gil
	     */
	    static char lines_putenv[] = "LINES=abcde", cols_putenv[] = "COLUMNS=abcde";

	    sprintf(lines_putenv + 6, "%d", LYlines & 0xfff);
	    sprintf(cols_putenv + 8, "%d", LYcols & 0xfff);
	    putenv(lines_putenv);
	    putenv(cols_putenv);
	    CTRACE((tfp, "start_curses putenv %s, %s\n", lines_putenv, cols_putenv));
	}
#endif /* defined(__MVS__) */
#endif /* !(defined(NCURSES) && defined(HAVE_RESIZETERM)) */
	CTRACE((tfp, "Screen size: %s()\n", NEWTERM_NAME));
	if (!(LYscreen = newterm(NULL, stdout, stdin))) {	/* start curses */
d787 2
a788 2
		    gettext("Terminal initialisation failed - unknown terminal type?"));
	    exit_immediately(EXIT_FAILURE);
a789 8
#else
	CTRACE((tfp, "Screen size: initscr()\n"));
	initscr();
#endif /* HAVE_NEWTERM */
	lynx_called_initscr = TRUE;
	LYlines = LYscreenHeight();
	LYcols = LYscreenWidth();

d792 1
a792 1
	recent_sizechange = FALSE;	/* prevent mainloop drawing 1st doc twice */
a793 12
	CTRACE((tfp, "Screen size is now %d x %d\n", LYlines, LYcols));

#ifdef USE_CURSES_PADS
	if (LYuseCursesPads) {
	    LYwin = newpad(LYlines, MAX_COLS);
	    LYshiftWin = 0;
	    LYwideLines = FALSE;
	} else {
	    LYwin = stdscr;
	}
#endif

d795 2
a796 11
#  if HAVE_KEYPAD
	/* Need to switch keypad on before initializing keymaps, otherwise
	   when the keypad is switched on, some keybindings may be overriden. */
	keypad(LYwin, TRUE);
	keypad_on = 1;
#  endif			/* HAVE_KEYPAD */

	if (-1 == lynx_initialize_keymaps()) {
	    endwin();
	    exit_immediately(EXIT_FAILURE);
	}
a809 1

d822 4
a825 36

#ifndef COLORS
	    /* map2boldc() relies on COLORS being a power of 2 */
	    if (COLORS > 16)
		COLORS = 16;
	    if (COLORS < 8)
		COLORS = 2;
	    if (COLORS > 8 && COLORS != 16)
		COLORS = 8;
#endif

#ifdef USE_DEFAULT_COLORS
#if defined(EXP_ASSUMED_COLOR) && defined(USE_COLOR_TABLE)
	    /*
	     * Adjust the color mapping table to match the ASSUMED_COLOR
	     * setting in lynx.cfg
	     */
	    if (assume_default_colors(default_fg, default_bg) != OK) {
		default_fg = COLOR_WHITE;
		default_bg = COLOR_BLACK;
	    }
	    CTRACE((tfp, "initializing default colors %d/%d\n",
		    default_fg, default_bg));
	    if (default_fg >= 0 || default_bg >= 0) {
		unsigned n;

		for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
		    if (default_fg >= 0 && lynx_color_cfg[n].fg < 0)
			lynx_color_cfg[n].fg = default_fg;
		    if (default_bg >= 0 && lynx_color_cfg[n].bg < 0)
			lynx_color_cfg[n].bg = default_bg;
		    CTRACE((tfp, "color_cfg[%d] = %d/%d\n", n,
			    lynx_color_cfg[n].fg,
			    lynx_color_cfg[n].bg));
		}
		lynx_setup_colors();
a826 3
#else
#if defined(HAVE_USE_DEFAULT_COLORS)
	    lynx_default_colors();
a827 2
#endif /* EXP_ASSUMED_COLOR */
#endif /* USE_DEFAULT_COLORS */
d834 2
a835 1
#ifdef USE_COLOR_TABLE
d837 1
d841 1
a841 1
    _eth_init();
d845 1
a845 1
/* nonl();   *//* seems to slow things down */
d851 1
a851 1
#ifdef HAVE_CBREAK
d861 2
a862 3
#ifdef HAVE_KEYPAD
    if (!keypad_on)
	keypad(LYwin, TRUE);
d865 1
a865 1
    lynx_enable_mouse(1);
d872 2
a873 2
#if defined(WIN_EX)
    LYclear();
d876 3
a878 4
#if defined(USE_BLINK) && defined(__EMX__)
    if (term_blink_is_boldbg)	/* Now actually make it so! */
	make_blink_boldbg();
#endif
a879 15
    LYCursesON = TRUE;
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    if ((scrsize_x != 0) && (scrsize_y != 0)) {
	if (saved_scrsize_x == 0) {
	    saved_scrsize_x = COLS;
	    saved_scrsize_y = LINES;
	}
	CTRACE((tfp, "resize_term: x=%d, y=%d\n", scrsize_x, scrsize_y));
	CTRACE((tfp, "saved terminal size: x=%d, y=%d\n", saved_scrsize_x, saved_scrsize_y));
	resize_term(scrsize_y, scrsize_x);
	LYclear();
    }
#endif
    CTRACE((tfp, "start_curses: done.\n"));
}				/* end of start_curses() */
d881 1
a881 1
void lynx_enable_mouse(int state)
a882 2
#ifdef USE_MOUSE
/***********************************************************************/
d884 1
a884 1
#if defined(WIN_EX)
d886 2
a887 1
   is disabled unless -use_mouse is specified
a889 1

d891 2
a892 1
    if (LYUseMouse == 0) {
d902 3
a904 3
#if defined(USE_SLANG)
    SLtt_set_mouse_mode(state, 0);
    SLtt_flush_output();
d907 4
a910 2
#if defined(WIN_EX) && defined(PDCURSES)
    if (state) {
d915 5
a919 1
#if defined(NCURSES)
a920 1
	/* Compensate for small value of maxclick in ncurses.  */
d927 1
a927 1
	    if (old < 200)	/* Default 166 */
d930 1
a930 18
	/* Inform ncurses which mouse events we're interested in.
	 * We shouldn't need to include BUTTONn_PRESSED and BUTTONn_RELEASED
	 * events, since ncurses should translate them to click events. - kw
	 * However, if we do not include them, then ncurses effectively
	 * ignores mouseinterval(), thus translates *any* sequence of
	 * press/release to a click, which leads to inconveniences.
	 * We special-case these events in LYStrings.c.
	 */
	mousemask(BUTTON_CTRL | BUTTON_ALT
		  | BUTTON1_PRESSED | BUTTON1_RELEASED
		  | BUTTON1_CLICKED
		  | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
		  | BUTTON2_PRESSED | BUTTON2_RELEASED
		  | BUTTON2_CLICKED
		  | BUTTON3_PRESSED | BUTTON3_RELEASED
		  | BUTTON3_CLICKED
		  | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED,
		  NULL);
d933 2
a934 2
#endif /* NCURSES */
#endif /* WIN_EX and PDCURSES */
d936 1
a936 1
#if defined(PDCURSES)
d938 3
a940 9
	mouse_set(
		     BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		     BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		     BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
#endif
#endif /* NOT USE_SLANG */

/***********************************************************************/
#endif /* USE_MOUSE */
d943 1
a943 21
/*
 * SVr4 curses (and ncurses) initialize the terminal I/O to raw mode, and
 * simulate other modes in the library.  This means that when running, it
 * simulates the OCRNL setting.  Normally that is not a problem.  However, when
 * spawning a subprocess (e.g., xli), the subprocess may write to the screen.
 * Fine so far - curses resets the terminal I/O to the normal state on exit.
 * But the subprocess's messages can still be coming to the screen when lynx
 * returns to the screen mode.  This function delays restoring OCRNL until
 * after the first getch() call.
 *
 * The OCRNL setting is controlled by nl()/nonl() of course - but we do not
 * want to give up that optimization since it would be a bit slower.  (Note -
 * slang does not use this optimization; if it did, the same screen glitch
 * would occur).
 *
 * FIXME:  for simplicity, only ncurses is implemented here - the TTY and
 * SET_TTY definitions are ncurses-specific.  The same effect could be done for
 * other curses implementations, since the "cur_term->Nttyb" part is common to
 * SVr4 curses.
 */
void lynx_nl2crlf(int normal GCC_UNUSED)
d945 3
a947 33
#if defined(NCURSES_VERSION_PATCH) && defined(SET_TTY) && defined(TERMIOS) && defined(ONLCR)
    static TTY saved_tty;
    static int did_save = FALSE;
    static int waiting = FALSE;
    static int can_fix = TRUE;

    if (!did_save) {
	saved_tty = cur_term->Nttyb;
	did_save = TRUE;
#if NCURSES_VERSION_PATCH < 20010529
	/* workaround for optimizer bug with nonl() */
	if ((tigetstr("cud1") != 0 && *tigetstr("cud1") == '\n')
	    || (tigetstr("ind") != 0 && *tigetstr("ind") == '\n'))
	    can_fix = FALSE;
#endif
    }
    if (can_fix) {
	if (normal) {
	    if (!waiting) {
		cur_term->Nttyb.c_oflag |= ONLCR;
		waiting = TRUE;
		nonl();
	    }
	} else {
	    if (waiting) {
		cur_term->Nttyb = saved_tty;
		SET_TTY(fileno(stdout), &saved_tty);
		waiting = FALSE;
		nl();
		LYrefresh();
	    }
	}
    }
d949 3
a951 1
}
d953 7
a959 4
void stop_curses(void)
{
    if (LYCursesON) {
	echo();
a960 41
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    resetty();
#endif
#ifdef __DJGPP__
    _eth_release();
#endif /* __DJGPP__ */

#if defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC))
#ifdef __DJGPP__
    ScreenClear();
#else
#ifdef __MINGW32__
    clear();
#else
    clrscr();
#endif
#endif
#else

    if (LYCursesON == TRUE) {
	lynx_nl2crlf(TRUE);
	lynx_enable_mouse(0);
#if 1 /* (!defined(WIN_EX) || defined(__CYGWIN__)) */	/* @@@@@@ */
#ifdef WIN_EX
	if (system_is_NT)
#endif
	    if (LYscreen || lynx_called_initscr) {
		endwin();	/* stop curses */
		LYDELSCR();
	    }
#endif
    }
#ifdef SH_EX
    {
	int i;

	for (i = 0; i <= 3; i++) {
	    fprintf(stdout, "\r\n");
	}
    }
#endif
d963 1
a963 1
#endif /* defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC)) */
d967 1
a967 1
    CTRACE((tfp, "stop_curses: done.\n"));
a981 5

#ifdef USE_SLANG
extern void longname(char *, char *);
#endif /* USE_SLANG */

d983 1
a983 1
 * Check terminal type, start curses & setup terminal.
d985 2
a986 1
BOOLEAN setup(char *terminal)
d991 3
d996 2
a997 2
     * If the display was not set by a command line option then see if it is
     * available from the environment.
d1006 1
a1006 1
     * Get terminal type, and convert to lower case.
d1012 2
a1013 2
	 * Some yoyo used these under conditions which require -dump, so force
	 * that mode here.  - FM
d1016 1
a1016 1
	LYcols = DFT_COLS;
d1020 7
a1026 1
	exit_immediately(status);
d1031 1
d1035 1
a1035 1
	       gettext("You must use a vt100, 200, etc. terminal with this program."));
d1040 1
a1040 1
	    return (FALSE);
d1042 1
a1042 1
	strcpy(term, "vt100");
d1048 6
a1053 2
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
d1055 1
a1055 1
    return (TRUE);
d1058 1
a1058 1
#else /* Not VMS: */
d1061 1
a1061 1
 * Check terminal type, start curses & setup terminal.
d1063 2
a1064 1
BOOLEAN setup(char *terminal)
d1069 14
d1084 12
a1095 4
    /*
     * If the display was not set by a command line option then see if it is
     * available from the environment .
     */
d1108 1
a1108 1
     * Query the terminal type.
d1110 3
a1112 1
    if (dumbterm(LYGetEnv("TERM"))) {
d1116 3
a1118 4
	if (LYSafeGets(&buffer, stdin) != 0) {
	    LYTrimLeading(buffer);
	    LYTrimTrailing(buffer);
	}
d1120 2
a1121 2
	if (isEmpty(buffer))
	    StrAllocCopy(buffer, "vt100");
d1123 1
a1123 1
	HTSprintf0(&term_putenv, "TERM=%.106s", buffer);
d1127 2
a1128 3
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"),
	       LYGetEnv("TERM"));
	LYSleepMsg();
d1133 1
a1133 1
#ifdef HAVE_TTYTYPE
d1135 1
a1135 6
     * Account for lossage on the 'sun' terminal type (80x24) Sun text console
     * driver.  It only supports reverse video, but all SGR sequences produce
     * that same reverse video, and the terminfo entry lists different SGRs for
     * 'bold' and 'rev'.  As a result, the current link is indistinguishable
     * from all other links.  The workaround here is to disable the 'rev'
     * capability.
d1137 2
a1138 2
    if ((strncmp((const char *) ttytype, "sun", 3) == 0)) {
	LYnoVideo(2);
d1142 27
a1168 2
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
d1170 1
a1170 1
    return (1);
d1173 2
a1174 1
static int dumbterm(char *terminal)
d1179 2
a1180 2
     * Began checking for terminal == NULL in case that TERM environment
     * variable is not set.  Thanks to Dick Wesseling (ftu@@fi.ruu.nl).
d1185 4
a1188 4
	!strcasecomp(terminal, "dialup") ||
	!strcasecomp(terminal, "dumb") ||
	!strcasecomp(terminal, "switch") ||
	!strcasecomp(terminal, "ethernet"))
d1190 1
a1190 1
    return (dumb);
d1195 4
a1198 2
#ifdef USE_COLOR_TABLE
void LYaddWAttr(WINDOW * win, int a)
d1204 2
a1205 1
void LYaddAttr(int a)
d1207 1
a1207 1
    LYaddWAttr(LYwin, a);
d1210 3
a1212 1
void LYsubWAttr(WINDOW * win, int a)
d1218 2
a1219 1
void LYsubAttr(int a)
d1221 1
a1221 1
    LYsubWAttr(LYwin, a);
d1228 1
a1228 113
/* Use this rather than the 'wprintw()' function to write a blank-padded
 * string to the given window, since someone's asserted that printw doesn't
 * handle 8-bit characters unlike addstr (though more info would be useful).
 *
 * We're blank-filling so that with SVr4 curses, it'll show the background
 * color to a uniform width in the popup-menu.
 */
#ifndef USE_SLANG
void LYpaddstr(WINDOW * the_window, int width,
	       const char *the_string)
{
    int y, x;
    int actual = strlen(the_string);

    getyx(the_window, y, x);
    if (width + x > LYcolLimit)
	width = LYcolLimit - x;
    if (actual > width)
	actual = width;
    LYwaddnstr(the_window, the_string, actual);
    width -= actual;
    while (width-- > 0)
	waddstr(the_window, " ");
}

/*
 * Workaround a bug in ncurses order-of-refresh by setting a pointer to
 * the topmost window that should be displayed.
 *
 * FIXME: the associated call on 'keypad()' is not needed for Unix, but
 * something in the OS/2 EMX port requires it.
 */
static WINDOW *my_subwindow;

void LYsubwindow(WINDOW * param)
{
    if (param != 0) {
	my_subwindow = param;
#if defined(NCURSES) || defined(PDCURSES)
	keypad(my_subwindow, TRUE);
#if defined(HAVE_GETBKGD)	/* not defined in ncurses 1.8.7 */
	wbkgd(my_subwindow, getbkgd(LYwin));
	wbkgdset(my_subwindow, getbkgd(LYwin));
#endif
#endif
	scrollok(my_subwindow, TRUE);
    } else {
	touchwin(LYwin);
	delwin(my_subwindow);
	my_subwindow = 0;
    }
}

WINDOW *LYtopwindow(void)
{
    return (my_subwindow ? my_subwindow : LYwin);
}
#endif

WINDOW *LYstartPopup(int *top_y,
		     int *left_x,
		     int *height,
		     int *width)
{
    WINDOW *form_window = 0;

#ifdef USE_SLANG
    static WINDOW fake_window;

    if (*left_x < 1 || (*left_x + *width + 4) >= LYcolLimit) {
	*left_x = 1;
	*width = LYcolLimit - 5;
    }

    SLsmg_fill_region(*top_y, *left_x - 1, *height, *width + 4, ' ');
    form_window = &fake_window;
    form_window->top_y = *top_y;
    form_window->left_x = *left_x;
    form_window->height = *height;
    form_window->width = *width;
#else
    if (*left_x > 0 && (*left_x + *width + 4) < LYcolLimit)
	form_window = newwin(*height, *width + 4, *top_y, *left_x - 1);
    if (form_window == 0) {
	*width = LYcolLimit - 4;
	form_window = newwin(*height, LYcolLimit, *top_y, 0);
    }
    if (form_window == 0) {
	HTAlert(POPUP_FAILED);
    } else {
	LYsubwindow(form_window);
#  ifdef USE_COLOR_STYLE
	{
	    long b;

	    /* Get a proper value for the attribute */
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_ON);
	    b = LYgetattrs(form_window);
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_OFF);
	    wbkgd(form_window, b | ' ');
	    /* wbkgdset does not make a lot of sense with USE_COLOR_STYLE
	       since it *forces* attributes on all the cells in the window.
	       Undo the change done in LYsubwindow, since we set our styles.
	     */
	    wbkgdset(form_window, (b & ~(A_BOLD | A_BLINK)) | ' ');
	}
#  endif
    }
#endif /* USE_SLANG */
    return form_window;
}

void LYstartTargetEmphasis(void)
d1237 2
a1238 2
    lynx_start_bold();
    lynx_start_reverse();
d1240 1
a1240 1
    lynx_start_underline();
d1243 1
a1243 1
void LYstopTargetEmphasis(void)
d1251 1
a1251 1
    lynx_stop_underline();
d1253 2
a1254 2
    lynx_stop_reverse();
    lynx_stop_bold();
a1257 249
/*
 * Accommodate the different flavors of touchline
 */
void LYtouchline(int row)
{
#if defined(HAVE_WREDRAWLN) && !defined(NCURSES_VERSION)
    wredrawln(LYwin, row, 1);
#else
#if defined(HAVE_TOUCHLINE)
    /* touchline() is not available on VMS before version 7.0, and then only on
     * Alpha, since prior ports of curses were broken.  BSD touchline() has a
     * 4th parameter since it is used internally by touchwin().
     */
#if defined(HAVE_BSD_TOUCHLINE)
    touchline(LYwin, row, 0, COLS);
#else
    touchline(LYwin, row, 1);
#endif
#else
#if !defined(USE_SLANG)
    touchwin(LYwin);
#else
    SLsmg_touch_lines(row, 1);
#endif
#endif
#endif
}

/*
 * Wrapper for waddnstr().
 */
void LYwaddnstr(WINDOW * w GCC_UNUSED,
		const char *src,
		size_t len)
{
    /*
     * We only want to trace this function for the color-style code.  It would
     * be too much logging if not needed.
     */
#ifdef USE_COLOR_STYLE
    if (TRACE) {
	int y, x;

	LYGetYX(y, x);
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n",
			      y, x, (int) len, src));
    }
#endif
    /*
     * Wide (multibyte) characters are always written as part of a string.  So
     * we can handle the conversion in one place.
     *
     * X/Open curses documents addstr() as able to handle multibyte sequences
     * directly, but that is not (2001/11/5) yet implemented in ncurses.  Two
     * alternatives are possible:  translating the string to an array of
     * wchar_t's or to an array of cchar_t's.  The former is more direct.  Both
     * have problems with combining-characters in this version of ncurses
     * (successive calls are not merged), so I'm using them for testing -TD
     */
#if 0				/* defined(WIDEC_CURSES) && defined(HAVE_MBSTATE_T) */
#if 1				/* array of wchar_t's */
    {
	static wchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	unsigned j;
	size_t need;

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(wchar_t, used);
	}
	for (j = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t) (-1) || rc == (size_t) (-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    temp[l++] = wch;
	}
	temp[l] = L'\0';
	waddnwstr(w, temp, l);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
    }
#else /* array of cchar_t's */
    {
	static cchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	wchar_t wstr[CCHARW_MAX + 1];
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	int y, x;
	unsigned j, k;
	size_t need;
	attr_t attr;
	short pair;

	wattr_get(w, &attr, &pair, (void *) 0);

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(cchar_t, used);
	}
	for (j = k = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t) (-1) || rc == (size_t) (-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    if ((width > 0 && l > 0) || l == CCHARW_MAX) {
		wstr[l] = L'\0';
		l = 0;
		if (setcchar(temp + k, wstr, attr, 0, NULL) != OK)
		    break;
		++k;
	    }
	    if (width == 0 && l == 0)
		wstr[l++] = L' ';
	    wstr[l++] = wch;
	}
	if (l > 0) {
	    wstr[l] = L'\0';
	    if (setcchar(temp + k, wstr, attr, 0, NULL) == OK)
		++k;
	}
	setcchar(temp + k, L"", 0, 0, NULL);
	wadd_wchnstr(w, temp, k);
	getyx(w, y, x);		/* we didn't move - do it now */
	wmove(w, y, x + k);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
    }
#endif
#else
    /*
     * There's no guarantee that a library won't temporarily write on its input.
     * Be safe and copy it when we have const-data.
     */
    while (len > 0) {
	char temp[MAX_LINE];
	size_t use = (len >= MAX_LINE) ? MAX_LINE - 1 : len;

	memcpy(temp, src, use);
	temp[use] = 0;
	waddstr(w, temp);
	len -= use;
    }
#endif
}

/*
 * Determine the number of cells the given string would take up on the screen,
 * limited by the maxCells parameter.  This is used for constructing aligned
 * text in the options and similar forms.
 *
 * FIXME: make this account for wrapping, too.
 * FIXME: make this useful for "lynx -dump", which hasn't initialized curses.
 */
int LYstrExtent(const char *string, int len, int maxCells)
{
    int result = 0;
    int used;

    if (len < 0)
	used = strlen(string);
    else
	used = len;

    result = used;
#ifdef WIDEC_CURSES
    if (used > 0 && lynx_called_initscr) {
	static WINDOW *fake_win;
	static int fake_max;
	int n;

	if (fake_max < maxCells) {
	    fake_max = (maxCells + 1) * 2;
	    if (fake_win != 0) {
		delwin(fake_win);
		fake_win = 0;
	    }
	}
	if (fake_win == 0) {
	    fake_win = newwin(2, fake_max, 0, 0);
	}
	if (fake_win != 0) {
	    int new_x = 0;
	    int new_y = 0;

	    result = 0;
	    wmove(fake_win, 0, 0);
	    for (n = 0; n < used; ++n) {
		if (IsNormalChar(string[n])) {
		    waddch(fake_win, UCH(string[n]));
		    getyx(fake_win, new_y, new_x);
		    if (new_y > 0 || new_x > maxCells)
			break;
		    result = new_x;
		}
	    }
	}
    }
#endif
    if (result > maxCells)
	result = maxCells;
    return result;
}

/*
 * A simple call that relies upon the coincidence that multicell characters
 * use at least as many bytes as cells.
 */
int LYstrExtent2(const char *string, int len)
{
    return LYstrExtent(string, len, len);
}

/*
 * Returns the total number of cells that the string would use.
 */
int LYstrCells(const char *string)
{
    return LYstrExtent2(string, strlen(string));
}

d1319 1
a1319 30
#define EFN	0		/* Event flag                   */

static unsigned char buffer[20];	/* Input buffer                 */
static int in_pos, in_len;	/* For escape sequences         */
static int oldmode[3];		/* Old TTY mode bits            */
static int newmode[3];		/* New TTY mode bits            */
static short iochan;		/* TTY I/O channel              */
static $DESCRIPTOR(term_nam_dsc, "TT");		/* Descriptor for iochan        */
static unsigned long mask = LIB$M_CLI_CTRLY | LIB$M_CLI_CTRLT;	/* ^Y and ^T */
static unsigned long old_msk;	/* Saved control mask           */
static short trap_flag = FALSE;	/* TRUE if AST is set           */
BOOLEAN DidCleanup = FALSE;	/* Exit handler flag            */
static char VersionVMS[20];	/* Version of VMS               */

int VMSVersion(char *VerString,
	       int VerLen)
{
    unsigned long status, itm_cod = SYI$_VERSION;
    int i, verlen = 0;
    struct dsc$descriptor version;
    char *m;

    version.dsc$a_pointer = VerString;
    version.dsc$w_length = VerLen - 1;
    version.dsc$b_dtype = DSC$K_DTYPE_B;
    version.dsc$b_class = DSC$K_CLASS_S;

    status = lib$getsyi(&itm_cod, 0, &version, &verlen, 0, 0);
    if (!(status & 1) || verlen == 0)
	return 0;
d1321 45
a1365 15
    /*
     * Cut out trailing spaces
     */
    for (m = VerString + verlen, i = verlen - 1; i > 0 && VerString[i] == ' '; --i)
	*(--m) = '\0';

    return strlen(VerString) + 1;	/* Transmit ending 0 too */
}

void VMSexit(void)
{
    /*
     * If we get here and DidCleanup is not set, it was via an ACCVIO, or
     * outofmemory forced exit, so make *sure* we attempt a cleanup and reset
     * the terminal.
d1370 1
a1370 2
		    gettext("\nA Fatal error has occurred in %s Ver. %s\n"),
		    LYNX_NAME, LYNX_VERSION);
d1372 1
a1372 1
		    gettext("\nPlease notify your system administrator to confirm a bug, and if\n\
d1379 1
a1379 1
		fprintf(stderr, RETURN_TO_CLEANUP);
d1402 1
a1402 1
int ttopen(void)
d1404 36
a1439 35
    int iosb[2];
    int status;
    static unsigned long condition;
    static struct _exit_block {
	unsigned long forward;
	unsigned long address;
	unsigned long zero;
	unsigned long condition;
    } exit_handler_block;

    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = sys$qiow(EFN, iochan, IO$_SENSEMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit_immediately(status);

    newmode[0] = oldmode[0];
    newmode[1] = oldmode[1];
    newmode[2] = oldmode[2] | TT2$M_EDIT;

    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &newmode, sizeof(newmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit_immediately(status);
d1441 10
a1450 10
    /*
     * Declare the exit handler block.
     */
    exit_handler_block.forward = 0;
    exit_handler_block.address = (unsigned long) &VMSexit;
    exit_handler_block.zero = 0;
    exit_handler_block.condition = (unsigned long) &condition;
    status = sys$dclexh(&exit_handler_block);
    if (status != SS$_NORMAL)
	exit_immediately(status);
d1452 13
a1464 13
    /*
     * Set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      &cleanup_sig, SIGINT, 0, 0, 0, 0);
    if (status != SS$_NORMAL) {
	lib$enable_ctrl(&old_msk);
	exit_immediately(status);
    }
a1465 4
    /*
     * Get the version of VMS.
     */
    if (VMSVersion(VersionVMS, 20) < 3)
d1467 1
a1467 1
	 * Load zeros on error.
d1469 5
a1473 1
	strcpy(VersionVMS, "V0.0-0");
d1475 2
a1476 2
    return (0);
}				/*  ttopen  */
d1484 1
a1484 1
int ttclose(void)
d1486 2
a1487 2
    int status;
    int iosb[1];
d1489 2
a1490 2
    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);
d1492 2
a1493 2
    if (status != SS$_NORMAL || (iosb[0] & 0xFFFF) != SS$_NORMAL)
	exit_immediately(status);
d1495 7
a1501 7
    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }
    return (0);
}				/*  ttclose  */
d1507 1
a1507 1
int ttgetc(void)
d1513 1
a1513 1
	return (buffer[in_pos++]);
d1516 1
a1516 1
		      IO$_READVBLK | IO$M_NOECHO | IO$M_NOFILTR,
d1519 1
a1519 1
    if ((status & 1) == 1)
d1523 1
a1523 1
	 * Escape sequence in progress.  Fake a successful read.
d1527 2
a1528 2
    if ((status & 1) != 1 && status != SS$_DATAOVERUN)
	exit_immediately(status);
d1531 1
a1531 1
    return (buffer[0]);
d1539 1
a1539 1
int typeahead(void)
d1548 1
a1548 1
	return (buffer[in_pos++]);
d1550 6
a1555 6
  again:
    status = sys$qiow(EFN, iochan,
		      IO$_READVBLK | IO$M_TIMED | IO$M_NOECHO | IO$M_NOFILTR,
		      &iosb, 0, 0,
		      &buffer, 1, 0, 0, 0, 0);
    if ((status & 1) == 1)
d1559 1
a1559 1
	 * Escape sequence in progress, finish reading it.
d1567 1
a1567 1
	return (-1);
d1588 7
a1594 6
void VMSsignal(int sig,
	       void (*func) ())
{
    int status;
    short iosb[4];
    static int SIG_IGN_flag;
d1596 8
a1603 8
    /*
     * Pass all signals other than SIGINT to signal().
     * Also pass SIGINT to signal() if we're dumping.
     */
    if (sig != SIGINT || dump_output_immediately) {
	signal(sig, func);
	return;
    }
d1605 7
a1611 7
    /*
     * If func is SIG_DFL, treat it as ttclose().
     */
    if (func == SIG_DFL) {
	ttclose();
	return;
    }
d1613 8
a1620 8
    /*
     * Clear any previous AST.
     */
    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }
d1622 6
a1627 6
    /*
     * If func is SIG_IGN, leave the TT channel closed and the system response
     * to interrupts enabled for system() calls.
     */
    if (func == SIG_IGN)
	return;
d1629 10
a1638 10
    /*
     * If we get to here, we have a LYNX func, so set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      func, SIGINT, 0, 0, 0, 0);
d1640 1
a1640 1
}				/* VMSsignal */
d1643 1
a1643 1
 * DCLspawn_exception, spawn_DCLprocess, DCLsystem -- F.Macrides 16-Jan-1994
d1653 28
a1680 8
static unsigned int DCLspawn_exception(void *sigarr,
				       void *mecharr)
#else
static int DCLspawn_exception(void *sigarr,
			      void *mecharr)
#endif				/* __DECC */
{
    int status;
d1682 1
a1682 20
    status = lib$sig_to_ret(sigarr, mecharr);
    return (SS$_UNWIND);
}

static int spawn_DCLprocess(char *command)
{
    int status;
    unsigned long Status = 0;

    /*
     * Keep DECC from complaining.
     */
    struct dsc$descriptor_s command_desc;

    command_desc.dsc$w_length = strlen(command);
    command_desc.dsc$b_class = DSC$K_CLASS_S;
    command_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    command_desc.dsc$a_pointer = command;

    VAXC$ESTABLISH(DCLspawn_exception);
d1685 3
a1687 3
    if (VersionVMS[1] > '6' ||
	(VersionVMS[1] == '6' && VersionVMS[2] == '.' &&
	 VersionVMS[3] >= '1'))
d1689 1
a1689 1
    if (VersionVMS[1] >= '6')
d1691 40
a1730 39
    {
	/*
	 * Include TRUSTED flag.
	 */
	unsigned long trusted = CLI$M_TRUSTED;

	status = lib$spawn(&command_desc, 0, 0, &trusted,
			   0, 0, &Status);
	/*
	 * If it was invalid, try again without the flag.
	 */
	if (status == LIB$_INVARG)
	    status = lib$spawn(&command_desc, 0, 0, 0,
			       0, 0, &Status);
    } else
	status = lib$spawn(&command_desc, 0, 0, 0,
			   0, 0, &Status);
    /*
     * Return -1 on error.
     */
    if ((status & 1) != 1 || (Status & 1) != 1)
	return (-1);
    /*
     * Return 0 on success.
     */
    return (0);
}

int DCLsystem(char *command)
{
    int status;

    VMSsignal(SIGINT, SIG_IGN);
    status = spawn_DCLprocess(command);
    VMSsignal(SIGINT, cleanup_sig);
    /*
     * Returns 0 on success, -1 any error.
     */
    return (status);
d1734 1
a1734 4
/*
 * Return the physical screen dimensions that we're allowed to use.
 */
int LYscreenHeight(void)
d1736 9
a1744 18
    int result = LINES;

    if (result <= 0)
	result = DFT_ROWS;
    return result;
}

int LYscreenWidth(void)
{
    int result = COLS;

#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX)		/* 1999/08/26 (Thu) 17:53:38 */
    {
	extern int current_codepage;	/* PDCurses lib. */

	if (current_codepage == 932)
	    result--;
    }
d1746 2
a1747 86
    if (result <= 0)
	result = DFT_COLS;
    return result;
}

/*
 * The functions ifdef'd with USE_CURSES_PADS are implemented that way so we
 * don't break the slang configuration.
 */
void LYclear(void)
{
#ifdef USE_CURSES_PADS
    wclear(LYwin);
#else
    clear();
#endif
}

void LYclrtoeol(void)
{
#ifdef USE_CURSES_PADS
    wclrtoeol(LYwin);
#else
    clrtoeol();
#endif
}

void LYerase(void)
{
#ifdef USE_CURSES_PADS
    werase(LYwin);
#else
    erase();
#endif
}

void LYmove(int y, int x)
{
#ifdef USE_CURSES_PADS
    wmove(LYwin, y, x);
#else
    move(y, x);
#endif
}

void LYrefresh(void)
{
#ifdef USE_CURSES_PADS
    if (LYwin != stdscr) {
	/*
	 * Workaround for special case where lynx is prompting for a mailto,
	 * and has a subject line that is wider than the screen.  The
	 * wnoutrefresh() call resets newscr's position to match stdscr's,
	 * which happens to be the window's origin because we were not updating
	 * that, and other stray wmove's in lynx fail because the coordinate
	 * is on/after the right margin.  Force things to look ok here.
	 */
	int y, x;

	getyx(LYwin, y, x);
	if (x > LYcolLimit)
	    x = LYcolLimit;
	wmove(stdscr, y, x);

	wnoutrefresh(stdscr);
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth() - 1);

	/*
	 * Keep a popup window visible.  This can happen if the user presses
	 * '/' to do a search within a popup.
	 */
	if (my_subwindow != 0) {
	    touchwin(my_subwindow);
	    wnoutrefresh(my_subwindow);
	}
	doupdate();
    } else {
	refresh();
    }
#else
    refresh();
#endif
}

void lynx_force_repaint(void)
{
d1751 1
a1751 1
void lynx_start_title_color(void)
a1752 3
#ifdef SH_EX
    lynx_start_reverse();
#endif
d1755 1
a1755 1
void lynx_stop_title_color(void)
a1756 3
#ifdef SH_EX
    lynx_stop_reverse();
#endif
d1759 3
a1761 2
void lynx_start_link_color(int flag,
			   int pending)
d1768 2
a1769 2
	/* lynx_start_bold();  */
	lynx_start_reverse();
d1774 1
a1774 1
	    lynx_start_underline();
d1778 1
a1778 1
	    lynx_start_underline();
d1780 2
a1781 2
    } else {
	lynx_start_bold();
d1783 2
a1784 2
	 * Make sure when flag is OFF that "unhighlighted" links will be
	 * underlined if appropriate.  - LE & FM
d1787 2
a1788 2
	    lynx_start_underline();
    }
d1791 3
a1793 2
void lynx_stop_link_color(int flag,
			  int pending GCC_UNUSED)
d1796 1
a1796 1
    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_OFF);
d1799 1
a1799 1
	lynx_stop_reverse();
d1804 1
a1804 1
	    lynx_stop_underline();
d1808 1
a1808 1
	    lynx_stop_underline();
d1811 1
a1811 1
	lynx_stop_bold();
d1813 1
a1813 1
	 * If underlining was turned on above, turn it off.  - LE & FM
d1816 1
a1816 1
	    lynx_stop_underline();
a1820 1
/* FIXME: consider inlining these */
d1822 1
a1822 1
void lynx_stop_target_color(void)
d1824 3
a1826 3
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
d1829 1
a1829 1
void lynx_start_target_color(void)
d1831 3
a1833 3
    lynx_start_bold();
    lynx_start_reverse();
    lynx_start_underline();
d1836 2
a1837 1
void lynx_start_status_color(void)
d1839 1
a1839 1
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
d1841 1
a1841 1
	lynx_set_color(2);
d1844 1
a1844 1
	lynx_start_reverse();
d1847 1
a1847 1
void lynx_stop_status_color(void)
d1849 1
a1849 1
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
d1851 1
a1851 1
	lynx_set_color(0);
d1854 1
a1854 1
	lynx_stop_reverse();
d1857 1
a1857 1
void lynx_start_h1_color(void)
d1859 2
a1860 2
    if (bold_H1 || bold_headers)
	lynx_start_bold();
d1863 1
a1863 1
void lynx_stop_h1_color(void)
d1865 2
a1866 2
    if (bold_H1 || bold_headers)
	lynx_stop_bold();
d1869 1
a1869 1
void lynx_start_prompt_color(void)
d1871 1
a1871 1
    lynx_start_reverse();
d1874 1
a1874 1
void lynx_stop_prompt_color(void)
d1876 1
a1876 1
    lynx_stop_reverse();
d1879 1
a1879 1
void lynx_start_radio_color(void)
d1881 1
a1881 1
    lynx_start_bold();
d1884 1
a1884 1
void lynx_stop_radio_color(void)
d1886 1
a1886 1
    lynx_stop_bold();
d1889 1
a1889 1
void lynx_stop_all_colors(void)
d1891 3
a1893 94
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
}

/*
 * Wrappers for LYUnderlineLinks flag.
 */
void lynx_start_bold(void)
{
    start_bold();
}

void lynx_start_reverse(void)
{
    start_reverse();
}

void lynx_start_underline(void)
{
    start_underline();
}

void lynx_stop_bold(void)
{
    stop_bold();
}

void lynx_stop_reverse(void)
{
    stop_reverse();
}

void lynx_stop_underline(void)
{
    stop_underline();
}

/*
 * If LYShowCursor is ON, move the cursor to the left of the current option, so
 * that blind users, who are most likely to have LYShowCursor ON, will have
 * it's string spoken or passed to the braille interface as each option is made
 * current.  Otherwise, move it to the bottom, right column of the screen, to
 * "hide" the cursor as for the main document, and let sighted users rely on
 * the current option's highlighting or color without the distraction of a
 * blinking cursor in the window.  - FM
 */
void LYstowCursor(WINDOW * win, int row,
		  int col)
{
    if (LYShowCursor)
	wmove(win, row, col);
    else
	LYHideCursor();
#ifdef USE_SLANG
    SLsmg_refresh();
#else
    wrefresh(win);
#endif /* USE_SLANG  */
}

#if defined(USE_BLINK) && defined(__EMX__)	/* Can't put it earler due to BOOLEAN conflict */
#  define BOOLEAN os2BOOLEAN
#  define INCL_VIO
#  include "os2.h"
static void make_blink_boldbg(void)
{
    VIOINTENSITY buf;		/* VIO windows have it anyway, */

    /* but FS session need a switch */
    buf.cb = sizeof(buf);
    buf.type = 2;		/* VIOINTENSITY request */
    buf.fs = 1;			/* Intensity == boldbg */
    VioSetState(&buf, 0);
}
#endif

#if defined(HAVE_WATTR_GET)
/*
 * getattrs() is not in X/Open curses, but it is more convenient than this.
 */
long LYgetattrs(WINDOW * win)
{
#if ( defined(HAVE_GETATTRS) && ( !defined(NCURSES_MAJOR_VERSION) || NCURSES_VERSION_MAJOR < 5 ) )
    long result = 0;

    result = getattrs(win);
#else
    attr_t result = 0;
    short pair = 0;

    wattr_get(win, &result, &pair, NULL);
#endif
    return result;
a1894 1
#endif /* HAVE_WATTR_GET */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a2 1

d7 1
a17 4
#ifdef VMS
#include <LYMainLoop.h>
#endif

a32 4
#ifdef NEED_WCHAR_H
#include <wchar.h>
#endif

d37 1
a37 5
#ifdef HAVE_XCURSES
char *XCursesProgramName = "Lynx";
#endif

#if defined(USE_COLOR_STYLE) && !defined(USE_COLOR_TABLE)
d40 1
a40 9
#define COLOR_BKGD ((COLOR_PAIRS >= 9) ? get_color_pair(9) : A_NORMAL)
#endif

#ifdef USE_CURSES_PADS
WINDOW *LYwin = 0;
int LYshiftWin = 0;
int LYwideLines = FALSE;
int LYtableCols = 0;		/* in 1/12 of screen width */
BOOL LYuseCursesPads = TRUE;	/* use pads for left/right shifting */
d51 2
a52 6
#if defined(USE_BLINK) && defined(__EMX__)
PRIVATE void make_blink_boldbg NOARGS;
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
PUBLIC int Current_Attr, Masked_Attr;
d59 1
a63 1

d72 1
d109 1
a109 1
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
d116 1
a116 19
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
}

PRIVATE void lynx_setup_attrs NOARGS
{
    static int monoattr[] = {
	0,
	SLTT_BOLD_MASK,
	SLTT_REV_MASK,
	SLTT_REV_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK | SLTT_REV_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK | SLTT_REV_MASK
    };
    int n;

    for (n = 1; n <= 7; n++)
	SLtt_set_mono(n, NULL, (monoattr[n] & ~Masked_Attr));
a120 1
    CTRACE((tfp, "lynx_setup_colors\n"));
d132 1
d136 7
a142 1
    lynx_setup_attrs();
d163 1
a163 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d180 1
a180 1
    return;
a181 1
#else
d183 1
a183 67
#ifdef FANCY_CURSES

#ifndef VMS
/* definitions for the mono attributes we can use */
static struct {
    char *name;
    int code;
} Mono_Attrs[7] =
{
    { "normal",		A_NORMAL },
    { "bold",		A_BOLD },
    { "reverse",	A_REVERSE },
    { "underline",	A_UNDERLINE },
    { "standout",	A_STANDOUT },
    { "blink",		A_BLINK },
    { "dim",		A_DIM },
};

PUBLIC int string_to_attr ARGS1(
    char *,	name)
{
    unsigned i;

    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (!strcasecomp(Mono_Attrs[i].name, name)) {
	    return Mono_Attrs[i].code;
	}
    }
    return 0;
}
#endif /* VMS */

#ifdef USE_COLOR_STYLE
PRIVATE char *attr_to_string ARGS1(
    int,	code)
{
    static char result[sizeof(Mono_Attrs) + 80];
    unsigned i;
    int pair = PAIR_NUMBER(code);
    int bold = (pair != 0 && (code & A_BOLD) != 0);

    if (bold)
	code &= ~A_BOLD;

    *result = 0;
    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (Mono_Attrs[i].code & code) {
	    if (*result)
		strcat(result, "+");
	    strcat(result, Mono_Attrs[i].name);
	}
    }
    if (pair != 0) {
	short f, b;
	if (pair_content(pair, &f, &b) != ERR) {
	    CONST char *fg = lookup_color(bold ? f+COLORS : f);
	    CONST char *bg = lookup_color(b);
	    if (*result)
		strcat(result, "+");
	    sprintf(result + strlen(result), "%s/%s", fg, bg);
	}
    }
    return result;
}
#endif /* USE_COLOR_STYLE */
#endif /* FANCY_CURSES */
#endif /* USE_SLANG */
d185 1
d187 3
a189 1
**  This function boxes windows for (n)curses.
d191 1
a191 1
PUBLIC void LYbox ARGS2(
d193 2
a194 1
	BOOLEAN,	formfield GCC_UNUSED)
a195 10
#ifdef USE_SLANG
    SLsmg_draw_box(win->top_y, win->left_x, win->height, win->width + 4);
#else
#ifdef VMS
    /*
     * This should work for VAX-C and DEC-C, since they both have the same
     * win._max_y and win._max_x members -TD
     *
     * (originally VMSbox by FM)
     */
d200 2
a201 2
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
d203 1
a203 1
    for (i = 1; i < win->_max_y-1; i++) {
d206 1
a206 1
	wmove(win, i, win->_max_x-1);
d211 2
a212 2
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
d214 10
a223 1
#else /* !VMS */
a245 1
    LynxWChangeStyle(win, s_menu_frame, STACK_ON);
a255 1
    LynxWChangeStyle(win, s_menu_frame, STACK_OFF);
d260 1
a261 1
    wrefresh(win);
a262 1
}
d274 15
a288 26
PUBLIC void setStyle ARGS4(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono)
{
    displayStyles[style].color = color;
    displayStyles[style].cattr = cattr;
    displayStyles[style].mono = mono;
}

PUBLIC void setHashStyle ARGS5(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono,
    char *,	element)
{
    bucket* ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE, (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n", element, style, color, mono));

    ds->color = color;
    ds->cattr = cattr;
    ds->mono = mono;
    ds->code = style;
d290 4
a293 1
    StrAllocCopy(ds->name, element);
d299 14
a312 18
PRIVATE int LYAttrset ARGS3(
    WINDOW *,	win,
    int,	color,
    int,	mono)
{
    if (lynx_has_color
     && LYShowColor >= SHOW_COLOR_ON
     && color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color (%s)\n", attr_to_string(color)));
	wattrset(win, color);
	return color;
    } else if (mono >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono (%s)\n", attr_to_string(mono)));
	wattrset(win, mono);
	return mono;
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset (A_NORMAL)\n"));
	wattrset(win, A_NORMAL);
a313 1
    }
d323 2
a324 2
/* if TRACEs are not compiled in, this macro is redundant - we needn't valid
'ds' to stack off. */
d327 1
a327 1
    int YP,XP;
d329 1
a329 1
    bucket* ds= (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);
d331 2
a332 2
    bucket* ds= (style == NOSTYLE ?	     &nostyle_bucket :
	    (style== SPECIAL_STYLE ? &special_bucket :&hashStyles[style]) );
d336 3
a338 2
    if (!ds->name) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n",style));
d340 1
a340 1
	return;
d342 1
a342 1
    }
d344 1
a344 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> (%d)\n",(dir?"":"/"),ds->name,ds->code));
d346 1
a346 1
    getyx (win, YP, XP);
d348 6
a353 5
    if (style == s_normal && dir) {
	wattrset(win,A_NORMAL);
	if (win == LYwin) cached_styles[YP][XP] = s_normal;
	return;
    }
d355 22
a376 22
    switch (dir)
    {
	/* ABS_OFF is the same as STACK_OFF for the moment */
    case STACK_OFF:
	if (last_colorattr_ptr) {
	    int last_attr = last_styles[--last_colorattr_ptr];
	    LYAttrset(win,last_attr,last_attr);
	}
	else
	    LYAttrset(win,A_NORMAL,-1);
	break;

    case STACK_ON: /* remember the current attributes */
	if (last_colorattr_ptr > 127) {
	    CTRACE2(TRACE_STYLE, (tfp,"........... %s (0x%x) %s\r\n",
			"attribute cache FULL, dropping last",
			last_styles[last_colorattr_ptr],
			"in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr--;
	}
	last_styles[last_colorattr_ptr++] = getattrs(win);
	/* don't cache style changes for active links */
d378 24
a401 18
	/* since we don't compute the hcode to stack off in HTML.c, we
	 * don't know whether this style is configured.  So, we
	 * shouldn't simply return on stacking on unconfigured
	 * styles, we should push curr attrs on stack.  -HV
	 */
	if (!ds->name) break;
#endif
	/* FALL THROUGH */
    case ABS_ON: /* change without remembering the previous style */
	    /* don't cache style changes for active links and edits */
	if ( style != s_alink
	     && style != s_curedit
	     && style != s_aedit
	     && style != s_aedit_sel
	     && style != s_aedit_pad
	     && style != s_aedit_arr ) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP));
	    if (win == LYwin) cached_styles[YP][XP] = style;
a402 3
	LYAttrset(win, ds->color, ds->mono);
	break;
    }
d408 17
a424 19
PUBLIC void wcurses_css ARGS3(
    WINDOW *,	win,
    char*,	name,
    int,	dir)
{
    int try_again = 1;

    while (try_again) {
	int tmpHash = hash_code(name);
	CTRACE2(TRACE_STYLE, (tfp, "CSSTRIM:trying to set [%s] style - ", name));
	if (tmpHash == NOSTYLE) {
	    char *class = strrchr(name, '.');
	    CTRACE2(TRACE_STYLE, (tfp, "undefined, trimming at %p\n", class));
	    if (class)	*class = '\0';
	    else	try_again = 0;
	} else {
	    CTRACE2(TRACE_STYLE, (tfp, "ok (%d)\n", hash_code(name)));
	    curses_w_style(win, hash_code(name), dir);
	    try_again = 0;
a425 1
    }
d428 1
a428 3
PUBLIC void curses_css ARGS2(
    char *,	name,
    int,	dir)
d430 1
a430 1
    wcurses_css(LYwin, name, dir);
d437 1
a437 1
    curses_w_style(LYwin, style, dir);
a438 3
#endif /* USE_COLOR_STYLE */

PRIVATE BOOL lynx_called_initscr = FALSE;
d440 2
a441 6
#if defined(HAVE_USE_DEFAULT_COLORS) && defined(USE_DEFAULT_COLORS)
/*
 * If we find a "default" color while reading the config-file, set default
 * colors on the screen.
 */
PUBLIC int lynx_default_colors NOARGS
d443 1
a443 10
    int code = 0;
    if (lynx_called_initscr) {
	code = -1;
	if (!default_color_reset && use_default_colors() == OK) {
	    default_fg = DEFAULT_COLOR;
	    default_bg = DEFAULT_COLOR;
	    code = 1;
	}
    }
    return code;
d445 2
a446 1
#endif /* HAVE_USE_DEFAULT_COLORS && USE_DEFAULT_COLORS */
d448 1
a448 1
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
d457 1
a481 16
 * If we find an exact match for the given default colors, force curses to use
 * color pair 0, which corresponds to the terminal's default colors.  Normally
 * curses assumes white-on-black, but we can override the assumption with this
 * function.
 */
PRIVATE int get_color_pair ARGS1(int, n)
{
#ifdef USE_CURSES_PAIR_0
    if (lynx_color_pairs[n].fg == default_fg
     && lynx_color_pairs[n].bg == default_bg)
    	return 0;
#endif
    return COLOR_PAIR(n);
}

/*
d491 9
d502 1
a502 1
	    code |= 1;
d504 1
a504 1
	    code |= 2;
d506 1
a506 1
	    code |= 4;
d509 12
d522 1
a522 1
	    attr |= get_color_pair(code+offs);
d525 1
a525 1
	wattrset(win, attr & ~Masked_Attr);
d527 1
a527 1
	wattrset(win, Current_Attr & ~Masked_Attr);
a534 2
    CTRACE((tfp, "lynx_map_color(%d)\n", n));

d548 3
a550 3
		init_pair((short)pair,
		    (short)lynx_color_pairs[pair].fg,
		    (short)lynx_color_pairs[pair].bg);
d553 1
a553 1
	    wbkgd(LYwin, COLOR_BKGD | ' ');
d578 1
a578 1
	wattrset(LYwin, lynx_color_cfg[a].attr
d580 1
a580 1
			? get_color_pair(a+1)
a597 3
	CTRACE((tfp, "lynx_init_colors (default %d/%d)\n",
		     default_fg, default_bg));

d601 1
a601 1
	for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
d605 3
a607 3
		    init_pair((short)pair,
			(short)lynx_color_pairs[pair].fg,
			(short)lynx_color_pairs[pair].bg);
d610 1
a610 1
		wbkgd(LYwin, COLOR_BKGD | ' ');
a619 1
    CTRACE((tfp, "lynx_setup_colors\n"));
d625 7
a631 2
PUBLIC void LYnoVideo ARGS1(
	int,		a)
d633 31
a663 6
    CTRACE((tfp, "LYnoVideo(%d)\n", a));
#ifdef USE_SLANG
    if (a & 1) Masked_Attr |= SLTT_BOLD_MASK;
    if (a & 2) Masked_Attr |= SLTT_REV_MASK;
    if (a & 4) Masked_Attr |= SLTT_ULINE_MASK;
    lynx_setup_attrs();
d665 2
a666 7
#ifdef USE_COLOR_TABLE
    if (a & 1) Masked_Attr |= A_BOLD;
    if (a & 2) Masked_Attr |= A_REVERSE;
    if (a & 4) Masked_Attr |= A_UNDERLINE;
#endif
#endif
}
a667 33
#define NEWTERM_NAME "newterm"
#if       !defined(VMS) && !defined(USE_SLANG)
/*
 * If newterm is not defined, assume a curses subset which
 * supports only initscr.  --gil
 */
#if defined(HAVE_NEWTERM) && defined(HAVE_DELSCREEN) && !(defined(NCURSES) && defined(HAVE_RESIZETERM))
static SCREEN *LYscreen = NULL;
#define LYDELSCR() { \
if (recent_sizechange) { \
    CTRACE((tfp, "Screen size: delscreen()\n")); \
    delscreen(LYscreen); \
    LYscreen = NULL; } }
/*
 * Surrogates for newterm annd delscreen
 */
#else  /* HAVE_NEWTERM   */
static WINDOW *LYscreen = NULL;
#undef  NEWTERM_NAME
#define NEWTERM_NAME "initscr"
#undef  newterm
#define newterm(type, out, in) (initscr())
#define LYDELSCR()  /* nothing */
#endif /* HAVE_NEWTERM   */
#else  /* !defined(VMS) && !defined(USE_SLANG) */
/*
 * Provide last recourse definitions of LYscreen and LYDELSCR for
 * stop_curses, which only tests LYscreen for zero/nonzero but
 * never uses it as a pointer or L-value.
 */
#define LYscreen TRUE
#define LYDELSCR()  /* nothing */
#endif /* !defined(VMS) && !defined(USE_SLANG) */
d675 1
a675 1
	CTRACE((tfp, "start_curses: Hmm, already ON.\n"));
a679 4
#if defined(USE_KEYMAPS)
	if (-1 == lynx_initialize_keymaps ())
	    exit (EXIT_FAILURE);
#else
d681 1
a681 2
#endif
#if (defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)) || defined(__CYGWIN__)
d685 1
a685 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d689 1
a689 1
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
a690 4
#if !defined(USE_KEYMAPS) && defined(ENHANCED_LINEEDIT) && defined(ESCDELAY)
	/* way to get ESC that's not part of a recognized sequence through */
	ESCDELAY = 2000;
#endif
d721 3
a723 5
#if (defined(VMS) || defined(REAL_UNIX_SYSTEM)) && !defined(__CYGWIN__)
	if ((Masked_Attr & SLTT_ULINE_MASK) == 0) {
	    SLtt_add_color_attribute(4, SLTT_ULINE_MASK);
	    SLtt_add_color_attribute(5, SLTT_ULINE_MASK);
	}
d728 6
a733 2
	SLtt_Blink_Mode = term_blink_is_boldbg;
#endif /* (VMS || REAL_UNIX_SYSTEM) && !__CYGWIN__  */
d736 1
a736 1
    _eth_init();
a753 3
#if SLANG_VERSION > 10306
    SLsmg_touch_screen ();
#endif
d755 1
a755 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d757 1
a757 1
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
d765 3
a767 1
    lynx_enable_mouse (1);
a768 2
#else /* USE_SLANG; Now using curses: */
    int keypad_on = 0;
a774 1
    CTRACE((tfp, "Screen size: initscr()\n"));
d778 1
a778 12
#ifdef __CYGWIN__
    /*
     * Workaround for buggy Cygwin, which breaks subprocesses of a
     * full-screen application (tested with cygwin dll, dated
     * 2002/6/23 -TD)
     */
    if (!lynx_called_initscr) {
	FILE *fp = fopen("/dev/tty", "w");
	if (fp != 0)
	    stdout = fp;
    }
#endif
d780 1
a780 1
    if (!LYscreen) {
d785 1
a785 29
#if defined(HAVE_NEWTERM)
#if !(defined(NCURSES) && !defined(HAVE_RESIZETERM))
	BOOLEAN savesize;

	savesize = recent_sizechange;
	size_change(0);
	recent_sizechange = savesize;    /* avoid extra redraw */
#if defined(__MVS__)
	{
	    /*
	     * The requirement to do this may be a bug in OS/390.
	     *
	     * Put screen geometry in environment variables used by
	     * XOpen curses before calling newterm().  I believe this
	     * completes work left unfinished by AJL & FM -- gil
	     */
	    static char lines_putenv[] = "LINES=abcde",
			cols_putenv[]  = "COLUMNS=abcde";

	    sprintf(lines_putenv + 6, "%d", LYlines & 0xfff);
	    sprintf(cols_putenv  + 8, "%d", LYcols  & 0xfff);
	    putenv(lines_putenv);
	    putenv(cols_putenv);
	    CTRACE((tfp, "start_curses putenv %s, %s\n", lines_putenv, cols_putenv));
	}
#endif /* defined(__MVS__) */
#endif /* !(defined(NCURSES) && defined(HAVE_RESIZETERM)) */
	CTRACE((tfp, "Screen size: %s()\n", NEWTERM_NAME));
	if (!(LYscreen = newterm(NULL,stdout,stdin))) {  /* start curses */
d788 1
a788 1
	    exit_immediately (EXIT_FAILURE);
a789 6
#else
	CTRACE((tfp, "Screen size: initscr()\n"));
	initscr();
#endif /* HAVE_NEWTERM */
	lynx_called_initscr = TRUE;

a793 12
	CTRACE((tfp, "Screen size is now %d x %d\n", LYlines, LYcols ));

#ifdef USE_CURSES_PADS
	if (LYuseCursesPads) {
	    LYwin = newpad(LYlines, MAX_COLS);
	    LYshiftWin = 0;
	    LYwideLines = FALSE;
	} else {
	    LYwin = stdscr;
	}
#endif

d795 2
a796 11
#  if HAVE_KEYPAD
	/* Need to switch keypad on before initializing keymaps, otherwise
	   when the keypad is switched on, some keybindings may be overriden. */
	keypad(LYwin,TRUE);
	keypad_on = 1;
#  endif /* HAVE_KEYPAD */

	if (-1 == lynx_initialize_keymaps ()) {
	    endwin();
	    exit (EXIT_FAILURE);
	}
d822 4
a825 9
#ifdef USE_DEFAULT_COLORS
#if defined(EXP_ASSUMED_COLOR) && defined(USE_COLOR_TABLE)
	    /*
	     * Adjust the color mapping table to match the ASSUMED_COLOR
	     * setting in lynx.cfg
	     */
	    if (assume_default_colors(default_fg, default_bg) != OK) {
		default_fg = COLOR_WHITE;
		default_bg = COLOR_BLACK;
a826 18
	    CTRACE((tfp, "initializing default colors %d/%d\n",
			 default_fg, default_bg));
	    if (default_fg >= 0 || default_bg >= 0) {
		unsigned n;
		for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
		    if (default_fg >= 0 && lynx_color_cfg[n].fg < 0)
			lynx_color_cfg[n].fg = default_fg;
		    if (default_bg >= 0 && lynx_color_cfg[n].bg < 0)
			lynx_color_cfg[n].bg = default_bg;
		    CTRACE((tfp, "color_cfg[%d] = %d/%d\n", n,
			    lynx_color_cfg[n].fg,
			    lynx_color_cfg[n].bg));
		}
		lynx_setup_colors();
	    }
#else
#if defined(HAVE_USE_DEFAULT_COLORS)
	    lynx_default_colors();
a827 2
#endif /* EXP_ASSUMED_COLOR */
#endif /* USE_DEFAULT_COLORS */
d834 2
a835 1
#ifdef USE_COLOR_TABLE
d837 1
d841 1
a841 1
    _eth_init();
d851 1
a851 1
#ifdef HAVE_CBREAK
d861 2
a862 3
#ifdef HAVE_KEYPAD
    if (!keypad_on)
	keypad(LYwin,TRUE);
d865 1
a865 1
    lynx_enable_mouse (1);
d872 2
a873 7
#if defined(WIN_EX)
    LYclear();
#endif

#if defined(USE_BLINK) && defined(__EMX__)
    if (term_blink_is_boldbg)		/* Now actually make it so! */
	make_blink_boldbg();
d877 2
a878 2
    CTRACE((tfp, "start_curses: done.\n"));
}  /* end of start_curses() */
a882 2
#ifdef USE_MOUSE
/***********************************************************************/
d884 1
a884 1
#if defined(WIN_EX)
d886 2
a887 1
   is disabled unless -use_mouse is specified
d902 1
a902 1
#if defined(USE_SLANG)
d907 2
a908 1
#if defined(WIN_EX) && defined(PDCURSES)
d915 5
a919 1
#if defined(NCURSES)
a920 1
	/* Compensate for small value of maxclick in ncurses.  */
d930 1
a930 18
	/* Inform ncurses which mouse events we're interested in.
	 * We shouldn't need to include BUTTONn_PRESSED and BUTTONn_RELEASED
	 * events, since ncurses should translate them to click events. - kw
	 * However, if we do not include them, then ncurses effectively
	 * ignores mouseinterval(), thus translates *any* sequence of
	 * press/release to a click, which leads to inconveniences.
	 * We special-case these events in LYStrings.c.
	 */
	mousemask(BUTTON_CTRL | BUTTON_ALT
		  | BUTTON1_PRESSED | BUTTON1_RELEASED
		  | BUTTON1_CLICKED
		  | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
		  | BUTTON2_PRESSED | BUTTON2_RELEASED
		  | BUTTON2_CLICKED
		  | BUTTON3_PRESSED | BUTTON3_RELEASED
		  | BUTTON3_CLICKED
		  | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED,
		  NULL);
d933 2
a934 2
#endif /* NCURSES */
#endif /* WIN_EX and PDCURSES */
d936 1
a936 1
#if defined(PDCURSES)
d938 1
a938 66
	mouse_set(
		BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
#endif
#endif      /* NOT USE_SLANG */

/***********************************************************************/
#endif /* USE_MOUSE */
}

/*
 * SVr4 curses (and ncurses) initialize the terminal I/O to raw mode, and
 * simulate other modes in the library.  This means that when running, it
 * simulates the OCRNL setting.  Normally that is not a problem.  However, when
 * spawning a subprocess (e.g., xli), the subprocess may write to the screen.
 * Fine so far - curses resets the terminal I/O to the normal state on exit.
 * But the subprocess's messages can still be coming to the screen when lynx
 * returns to the screen mode.  This function delays restoring OCRNL until
 * after the first getch() call.
 *
 * The OCRNL setting is controlled by nl()/nonl() of course - but we do not
 * want to give up that optimization since it would be a bit slower.  (Note -
 * slang does not use this optimization; if it did, the same screen glitch
 * would occur).
 *
 * FIXME:  for simplicity, only ncurses is implemented here - the TTY and
 * SET_TTY definitions are ncurses-specific.  The same effect could be done for
 * other curses implementations, since the "cur_term->Nttyb" part is common to
 * SVr4 curses.
 */
PUBLIC void lynx_nl2crlf ARGS1(int, normal GCC_UNUSED)
{
#if defined(NCURSES_VERSION_PATCH) && defined(SET_TTY) && defined(TERMIOS) && defined(ONLCR)
    static TTY saved_tty;
    static int did_save = FALSE;
    static int waiting = FALSE;
    static int can_fix = TRUE;

    if (!did_save) {
	saved_tty = cur_term->Nttyb;
	did_save = TRUE;
#if NCURSES_VERSION_PATCH < 20010529
	/* workaround for optimizer bug with nonl() */
	if ((tigetstr("cud1") != 0 && *tigetstr("cud1") == '\n')
	 || (tigetstr("ind")  != 0 && *tigetstr("ind")  == '\n'))
	    can_fix = FALSE;
#endif
    }
    if (can_fix) {
	if (normal) {
	    if (!waiting) {
		cur_term->Nttyb.c_oflag |= ONLCR;
		waiting = TRUE;
		nonl();
	    }
	} else {
	    if (waiting) {
		cur_term->Nttyb = saved_tty;
		SET_TTY(fileno(stdout), &saved_tty);
		waiting = FALSE;
		nl();
		LYrefresh();
	    }
	}
    }
d940 1
d945 5
a949 10
    if (LYCursesON)
	echo();
#ifdef __DJGPP__
    _eth_release();
#endif /* __DJGPP__ */

#if defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC))
#ifdef __DJGPP__
    ScreenClear();
#else
a950 1
#endif
d953 4
d958 2
a959 15
	lynx_nl2crlf(TRUE);
	lynx_enable_mouse (0);
#if (!defined(WIN_EX) || defined(__CYGWIN__))	/* @@@@@@ */
	if(LYscreen || lynx_called_initscr) {
	    endwin();	/* stop curses */
	    LYDELSCR();
	}
#endif
    }
#ifdef SH_EX
    {
	int i;
	for (i=0; i <= 3; i++) {
	    fprintf(stdout, "\r\n");
	}
a960 1
#endif
d963 1
a963 1
#endif /* defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC)) */
d967 1
a967 1
    CTRACE((tfp, "stop_curses: done.\n"));
d986 1
a986 1
	char *,		terminal)
d1016 1
a1016 1
	LYcols = DFT_COLS;
d1031 1
d1048 6
a1053 2
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
d1064 1
a1064 1
	char *,		terminal)
d1069 14
d1084 12
a1095 4
    /*
     *  If the display was not set by a command line option then
     *  see if it is available from the environment .
     */
d1110 3
a1112 1
    if (dumbterm(LYGetEnv("TERM"))) {
d1116 3
a1118 4
	if (LYSafeGets(&buffer, stdin) != 0) {
	    LYTrimLeading(buffer);
	    LYTrimTrailing(buffer);
	}
d1120 1
a1120 1
	if (isEmpty(buffer))
d1127 2
a1128 2
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"), LYGetEnv("TERM"));
	LYSleepMsg();
d1133 1
a1133 1
#ifdef HAVE_TTYTYPE
d1135 1
a1135 6
     *  Account for lossage on the 'sun' terminal type (80x24) Sun text
     *  console driver. It only supports reverse video, but all SGR
     *  sequences produce that same reverse video, and the terminfo
     *  entry lists different SGRs for 'bold' and 'rev'. As a result,
     *  the current link is indistinguishable from all other links.
     *  The workaround here is to disable the 'rev' capability.
d1137 2
a1138 2
    if ((strncmp((CONST char *)ttytype, "sun", 3) == 0)) {
	LYnoVideo(2);
d1142 27
a1168 2
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
d1174 1
a1174 1
	char *,		terminal)
d1195 1
a1195 1
#ifdef USE_COLOR_TABLE
d1207 1
a1207 1
    LYaddWAttr(LYwin, a);
d1221 1
a1221 1
    LYsubWAttr(LYwin, a);
a1227 103
/* Use this rather than the 'wprintw()' function to write a blank-padded
 * string to the given window, since someone's asserted that printw doesn't
 * handle 8-bit characters unlike addstr (though more info would be useful).
 *
 * We're blank-filling so that with SVr4 curses, it'll show the background
 * color to a uniform width in the popup-menu.
 */
#ifndef USE_SLANG
PUBLIC void LYpaddstr ARGS3(
	WINDOW *,	the_window,
	int,		width,
	CONST char *,	the_string)
{
    int y, x;
    int actual = strlen(the_string);

    getyx(the_window, y, x);
    if (width + x >= LYcols)
	width = LYcols - x - 1;
    if (actual > width)
	actual = width;
    LYwaddnstr(the_window, the_string, actual);
    width -= actual;
    while (width-- > 0)
	waddstr(the_window, " ");
}

/*
 * Workaround a bug in ncurses order-of-refresh by setting a pointer to
 * the topmost window that should be displayed.
 *
 * FIXME: the associated call on 'keypad()' is not needed for Unix, but
 * something in the OS/2 EMX port requires it.
 */
PRIVATE WINDOW *my_subwindow;

PUBLIC void LYsubwindow ARGS1(WINDOW *, param)
{
    if (param != 0) {
	my_subwindow = param;
#if defined(NCURSES) || defined(PDCURSES)
	keypad(my_subwindow, TRUE);
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
	wbkgd(my_subwindow, getbkgd(LYwin));
	wbkgdset(my_subwindow, getbkgd(LYwin));
#endif
#endif
	scrollok(my_subwindow, TRUE);
    } else {
	touchwin(LYwin);
	delwin(my_subwindow);
	my_subwindow = 0;
    }
}

PUBLIC WINDOW *LYtopwindow NOARGS
{
    return (my_subwindow ? my_subwindow : LYwin);
}
#endif

PUBLIC WINDOW *LYstartPopup ARGS4(
    int,	top_y,
    int,	left_x,
    int,	height,
    int,	width)
{
    WINDOW *form_window = 0;
#ifdef USE_SLANG
    static WINDOW fake_window;
    SLsmg_fill_region(top_y, left_x - 1, height, width + 4, ' ');
    form_window = &fake_window;
    form_window->top_y  = top_y;
    form_window->left_x = left_x;
    form_window->height = height;
    form_window->width  = width;
#else
    if (!(form_window = newwin(height, width + 4, top_y, left_x - 1)) &&
	!(form_window = newwin(height, 0, top_y, 0))) {
	HTAlert(POPUP_FAILED);
    } else {
	LYsubwindow(form_window);
#  ifdef USE_COLOR_STYLE
	{
	    long b;

	    /* Get a proper value for the attribute */
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_ON);
	    b = getattrs(form_window);
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_OFF);
	    wbkgd(form_window, b | ' ');
	    /* wbkgdset does not make a lot of sense with USE_COLOR_STYLE
	       since it *forces* attributes on all the cells in the window.
	       Undo the change done in LYsubwindow, since we set our styles.
	     */
	    wbkgdset(form_window, (b & ~(A_BOLD|A_BLINK)) | ' ');
	}
#  endif
    }
#endif /* USE_SLANG */
    return form_window;
}

a1257 173
/*
 * Accommodate the different flavors of touchline
 */
PUBLIC void LYtouchline ARGS1(
	int,		row)
{
#if defined(HAVE_WREDRAWLN) && !defined(NCURSES_VERSION)
    wredrawln(LYwin, row, 1);
#else
#if defined(HAVE_TOUCHLINE)
    /* touchline() is not available on VMS before version 7.0, and then only on
     * Alpha, since prior ports of curses were broken.  BSD touchline() has a
     * 4th parameter since it is used internally by touchwin().
     */
#if defined(HAVE_BSD_TOUCHLINE)
    touchline(LYwin, row, 0, COLS);
#else
    touchline(LYwin, row, 1);
#endif
#else
#if !defined(USE_SLANG)
    touchwin(LYwin);
#else
    SLsmg_touch_lines(row, 1);
#endif
#endif
#endif
}

/*
 * Wrapper for waddnstr().
 */
PUBLIC void LYwaddnstr ARGS3(
	WINDOW *,	w,
	CONST char *,	src,
	size_t,		len)
{
    /*
     * We only want to trace this function for the color-style code.  It would
     * be too much logging if not needed.
     */
#ifdef USE_COLOR_STYLE
    if (TRACE) {
	int y, x;
	LYGetYX(y, x);
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n", y, x, (int) len, src));
    }
#endif
    /*
     * Wide (multibyte) characters are always written as part of a string.  So
     * we can handle the conversion in one place.
     *
     * X/Open curses documents addstr() as able to handle multibyte sequences
     * directly, but that is not (2001/11/5) yet implemented in ncurses.  Two
     * alternatives are possible:  translating the string to an array of
     * wchar_t's or to an array of cchar_t's.  The former is more direct.  Both
     * have problems with combining-characters in this version of ncurses
     * (successive calls are not merged), so I'm using them for testing -TD
     */
#if 0	/* defined(WIDEC_CURSES) && defined(HAVE_MBSTATE_T) */
#if 1	/* array of wchar_t's */
    {
	static wchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	unsigned j;
	size_t need;

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(wchar_t, used);
	}
	for (j = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t)(-1) || rc == (size_t)(-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    temp[l++] = wch;
	}
	temp[l] = L'\0';
	waddnwstr(w, temp, l);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
    }
#else	/* array of cchar_t's */
    {
	static cchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	wchar_t wstr[CCHARW_MAX + 1];
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	int y, x;
	unsigned j, k;
	size_t need;
	attr_t attr;
	short pair;

	wattr_get(w, &attr, &pair, (void *)0);

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(cchar_t, used);
	}
	for (j = k = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t)(-1) || rc == (size_t)(-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    if ((width > 0 && l > 0) || l == CCHARW_MAX) {
		wstr[l] = L'\0';
		l = 0;
		if (setcchar(temp + k, wstr, attr, 0, NULL) != OK)
		    break;
		++k;
	    }
	    if (width == 0 && l == 0)
		wstr[l++] = L' ';
	    wstr[l++] = wch;
	}
	if (l > 0) {
	    wstr[l] = L'\0';
	    if (setcchar(temp + k, wstr, attr, 0, NULL) == OK)
		++k;
	}
	setcchar(temp + k, L"", 0, 0, NULL);
	wadd_wchnstr (w, temp, k);
	getyx(w, y, x);		/* we didn't move - do it now */
	wmove(w, y, x + k);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
    }
#endif
#else
    /*
     * There's no guarantee that a library won't temporarily write on its input.
     * Be safe and copy it when we have const-data.
     */
    while (len > 0) {
	char temp[MAX_LINE];
	size_t use = (len >= MAX_LINE) ? MAX_LINE - 1 : len;
	memcpy(temp, src, use);
	temp[use] = 0;
	waddstr(w, temp);
	len -= use;
    }
#endif
}

d1321 2
a1322 2
static	unsigned char buffer[20];	/* Input buffer			*/
static	int	in_pos, in_len;		/* For escape sequences		*/
d1325 1
a1325 1
static	short	iochan;			/* TTY I/O channel		*/
d1334 1
a1334 1
	char *,		VerString,
d1404 1
d1654 2
a1655 2
	void *,		sigarr,
	void *,		mecharr)
d1658 2
a1659 2
	void *,		sigarr,
	void *,		mecharr)
d1669 1
a1669 1
	char *,		command)
d1719 1
a1719 1
	char *,		command)
d1722 1
d1734 1
a1734 4
/*
 * Return the physical screen dimensions that we're allowed to use.
 */
PUBLIC int LYscreenHeight NOARGS
d1736 9
a1744 96
    int result = LINES;
    if (result <= 0)
	result = DFT_ROWS;
    return result;
}

PUBLIC int LYscreenWidth NOARGS
{
    int result = COLS;
#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX) /* 1999/08/26 (Thu) 17:53:38 */
    {
	extern int current_codepage;	/* PDCurses lib. */

	if (current_codepage == 932)
	    result--;
    }
#endif
    if (result <= 0)
	result = DFT_COLS;
    return result;
}

/*
 * The functions ifdef'd with USE_CURSES_PADS are implemented that way so we
 * don't break the slang configuration.
 */
PUBLIC void LYclear NOARGS
{
#ifdef USE_CURSES_PADS
    wclear(LYwin);
#else
    clear();
#endif
}

PUBLIC void LYclrtoeol NOARGS
{
#ifdef USE_CURSES_PADS
    wclrtoeol(LYwin);
#else
    clrtoeol();
#endif
}

PUBLIC void LYerase NOARGS
{
#ifdef USE_CURSES_PADS
    werase(LYwin);
#else
    erase();
#endif
}

PUBLIC void LYmove ARGS2(int, y, int, x)
{
#ifdef USE_CURSES_PADS
    wmove(LYwin, y, x);
#else
    move(y, x);
#endif
}

PUBLIC void LYrefresh NOARGS
{
#ifdef USE_CURSES_PADS
    if (LYwin != stdscr) {
	/*
	 * Workaround for special case where lynx is prompting for a mailto,
	 * and has a subject line that is wider than the screen.  The
	 * wnoutrefresh() call resets newscr's position to match stdscr's,
	 * which happens to be the window's origin because we were not updating
	 * that, and other stray wmove's in lynx fail because the coordinate
	 * is on/after the right margin.  Force things to look ok here.
	 */
	int y, x;
	getyx(LYwin, y, x);
	if (x >= LYcols) x = LYcols-1;
	wmove(stdscr, y, x);

	wnoutrefresh(stdscr);
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth()-1);

	/*
	 * Keep a popup window visible.  This can happen if the user presses
	 * '/' to do a search within a popup.
	 */
	if (my_subwindow != 0) {
	    touchwin(my_subwindow);
	    wnoutrefresh(my_subwindow);
	}
	doupdate();
    } else {
	refresh();
    }
#else
    refresh();
d1746 2
a1747 4
}

PUBLIC void lynx_force_repaint NOARGS
{
a1752 3
#ifdef SH_EX
    start_reverse();
#endif
a1756 3
#ifdef SH_EX
    stop_reverse();
#endif
d1796 1
a1796 1
    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_OFF);
d1824 3
a1826 3
    stop_underline();
    stop_reverse();
    stop_bold();
d1831 3
a1833 3
    start_bold();
    start_reverse();
    start_underline();
d1839 1
a1839 1
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
d1849 1
a1849 1
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
d1859 2
a1860 2
    if (bold_H1 || bold_headers)
	start_bold();
d1865 2
a1866 2
    if (bold_H1 || bold_headers)
	stop_bold();
d1871 1
a1871 1
    start_reverse ();
d1876 1
a1876 1
    stop_reverse ();
d1881 1
a1881 1
    start_bold ();
d1886 1
a1886 1
    stop_bold ();
d1891 3
a1893 3
    stop_underline ();
    stop_reverse ();
    stop_bold ();
a1894 40

/*
 * If LYShowCursor is ON, move the cursor to the left of the current option, so
 * that blind users, who are most likely to have LYShowCursor ON, will have
 * it's string spoken or passed to the braille interface as each option is made
 * current.  Otherwise, move it to the bottom, right column of the screen, to
 * "hide" the cursor as for the main document, and let sighted users rely on
 * the current option's highlighting or color without the distraction of a
 * blinking cursor in the window.  - FM
 */
PUBLIC void LYstowCursor ARGS3(
    WINDOW *,	win,
    int,	row,
    int,	col)
{
    if (LYShowCursor)
	wmove(win, row, col);
    else
	LYHideCursor();
#ifdef USE_SLANG
    SLsmg_refresh();
#else
    wrefresh(win);
#endif /* USE_SLANG  */
}

#if defined(USE_BLINK) && defined(__EMX__) /* Can't put it earler due to BOOLEAN conflict */
#  define BOOLEAN os2BOOLEAN
#  define INCL_VIO
#  include "os2.h"
PRIVATE void make_blink_boldbg NOARGS
{
    VIOINTENSITY buf;		/* VIO windows have it anyway, */
				/* but FS session need a switch */
    buf.cb = sizeof(buf);
    buf.type = 2;		/* VIOINTENSITY request */
    buf.fs = 1;			/* Intensity == boldbg */
    VioSetState(&buf,0);
}
#endif
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d79 4
d409 1
a409 1
PRIVATE void LYAttrset ARGS3(
d419 1
d423 1
d427 1
d486 1
a486 1
	    last_colorattr_ptr = 127;
d488 1
a488 1
	last_styles[last_colorattr_ptr++] = LYgetattrs(win);
d590 1
d592 8
a599 8
    /*0*/ { DEFAULT_FG,    DEFAULT_BG},
    /*1*/ { COLOR_BLUE,    DEFAULT_BG},
    /*2*/ { COLOR_YELLOW+8,COLOR_BLUE},
    /*3*/ { COLOR_GREEN,   DEFAULT_BG},
    /*4*/ { COLOR_MAGENTA, DEFAULT_BG},
    /*5*/ { COLOR_BLUE,    DEFAULT_BG},
    /*6*/ { COLOR_RED,	   DEFAULT_BG},
    /*7*/ { COLOR_MAGENTA, COLOR_CYAN}
d621 1
a621 1
	return 0;
a626 25
 * Lynx "knows" about 16 colors.  ANSI colors (and most color terminal
 * emulators) only go to 8, though some curses implementations (ncurses and
 * PDCurses) handle 16.  If lynx's configuration calls for a color past the
 * number of colors that the terminal handles (COLORS), map the extra value
 * to bold.
 */
#define is_boldc(c) ((c) > (COLORS-1))
#define map2bold(c) (is_boldc(c) ? ((c) & (COLORS-1)) : (c))

/*
 * Return the extra color as A_BOLD.
 * If there is no extra color, return A_NORMAL.
 */
PRIVATE int lynx_color_cfg_attr ARGS1(int, code)
{
    int result = A_NORMAL;
    if (code >= 0 && code < 8) {
	int fg = lynx_color_cfg[code].fg;
	if (is_boldc(fg) && (fg & COLORS))
	    result = A_BOLD;
    }
    return result;
}

/*
d643 1
a643 1
	attr = lynx_color_cfg_attr(code);
d655 1
a655 4
/*
 * Initialize a curses color-pair based on our configured color values.
 */
PRIVATE void lynx_init_color_pair ARGS1(int, n)
a658 15
    if (lynx_called_initscr) {
	for (m = 0; m <= 16; m += 8) {
	    int pair = n + m + 1;
	    if (pair < COLOR_PAIRS)
		init_pair((short)pair,
		    (short)map2bold(lynx_color_pairs[pair].fg),
		    (short)map2bold(lynx_color_pairs[pair].bg));
	}
	if (n == 0 && LYShowColor >= SHOW_COLOR_ON)
	    wbkgd(LYwin, COLOR_BKGD | ' ');
    }
}

PRIVATE void lynx_map_color ARGS1(int, n)
{
d670 11
a680 1
    lynx_init_color_pair(n);
a682 4
/*
 * Change a configured color value.  This may be called before initscr(), so
 * we may not be able to call init_pair() to finish the change.
 */
d691 3
a693 2
	lynx_color_cfg[color].fg = fg;
	lynx_color_cfg[color].bg = bg;
d704 1
a704 1
	wattrset(LYwin, lynx_color_cfg_attr(a)
d722 1
a722 1
	size_t n;
d731 9
a739 1
	    lynx_init_color_pair(n);
a806 5
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
PUBLIC int saved_scrsize_x = 0;
PUBLIC int saved_scrsize_y = 0;
#endif

a982 2
	LYlines = LYscreenHeight();
	LYcols = LYscreenWidth();
a1036 11

#ifndef COLORS
	    /* map2boldc() relies on COLORS being a power of 2 */
	    if (COLORS > 16)
		COLORS = 16;
	    if (COLORS < 8)
		COLORS = 2;
	    if (COLORS > 8 && COLORS != 16)
		COLORS = 8;
#endif

a1120 12
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    if ((scrsize_x != 0) && (scrsize_y != 0)) {
	if (saved_scrsize_x == 0) {
	    saved_scrsize_x = COLS;
	    saved_scrsize_y = LINES;
	}
	CTRACE((tfp, "resize_term: x=%d, y=%d\n", scrsize_x, scrsize_y));
	CTRACE((tfp, "saved terminal size: x=%d, y=%d\n", saved_scrsize_x, saved_scrsize_y));
	resize_term(scrsize_y, scrsize_x);
        LYclear();
    }
#endif
a1268 3
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    resetty ();
#endif
d1284 1
a1284 4
#if 1 /* (!defined(WIN_EX) || defined(__CYGWIN__)) */	/* @@@@@@ */
#ifdef WIN_EX
	if (system_is_NT)
#endif
d1606 1
a1606 1
	    b = LYgetattrs(form_window);
a2596 14

#if defined(HAVE_WATTR_GET)
/*
 * getattrs() is not in X/Open curses, but it is more convenient than this.
 */
PUBLIC long LYgetattrs ARGS1(WINDOW *, win)
{
    attr_t result = 0;
    short pair = 0;

    wattr_get(win, &result, &pair, NULL);
    return result;
}
#endif /* HAVE_WATTR_GET */
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a3 6
#ifdef __MINGW32__
#ifdef UNIX
#undef UNIX
#endif /* UNIX */
#endif /* __MINGW32__ */

a1329 3
#ifdef __MINGW32__
    clear();
#else
a1331 1
#endif
d1686 2
a1687 2
    lynx_start_bold();
    lynx_start_reverse();
d1689 1
a1689 1
    lynx_start_underline();
d1700 1
a1700 1
    lynx_stop_underline();
d1702 2
a1703 2
    lynx_stop_reverse();
    lynx_stop_bold();
d2466 1
a2466 1
    lynx_start_reverse();
d2473 1
a2473 1
    lynx_stop_reverse();
d2486 2
a2487 2
	/* lynx_start_bold();  */
	lynx_start_reverse();
d2492 1
a2492 1
	    lynx_start_underline ();
d2496 1
a2496 1
	    lynx_start_underline ();
d2499 1
a2499 1
	lynx_start_bold();
d2505 1
a2505 1
	    lynx_start_underline();
d2517 1
a2517 1
	lynx_stop_reverse();
d2522 1
a2522 1
	lynx_stop_underline ();
d2526 1
a2526 1
	    lynx_stop_underline ();
d2529 1
a2529 1
	lynx_stop_bold();
d2534 1
a2534 1
	    lynx_stop_underline();
a2538 1
/* FIXME: consider inlining these */
d2542 3
a2544 3
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
d2549 3
a2551 3
    lynx_start_bold();
    lynx_start_reverse();
    lynx_start_underline();
d2562 1
a2562 1
	lynx_start_reverse ();
d2572 1
a2572 1
	lynx_stop_reverse ();
d2578 1
a2578 1
	lynx_start_bold();
d2584 1
a2584 1
	lynx_stop_bold();
d2589 1
a2589 1
    lynx_start_reverse ();
d2594 1
a2594 1
    lynx_stop_reverse ();
d2599 1
a2599 1
    lynx_start_bold ();
d2604 1
a2604 1
    lynx_stop_bold ();
d2609 3
a2611 36
    lynx_stop_underline ();
    lynx_stop_reverse ();
    lynx_stop_bold ();
}

/*
 * Wrappers for LYUnderlineLinks flag.
 */
PUBLIC void lynx_start_bold NOARGS
{
    start_bold();
}

PUBLIC void lynx_start_reverse NOARGS
{
    start_reverse();
}

PUBLIC void lynx_start_underline NOARGS
{
    start_underline();
}

PUBLIC void lynx_stop_bold NOARGS
{
    stop_bold();
}

PUBLIC void lynx_stop_reverse NOARGS
{
    stop_reverse();
}

PUBLIC void lynx_stop_underline NOARGS
{
    stop_underline();
a2659 4
#if (defined(NCURSES_VERSION_MAJOR) && NCURSES_VERSION_MAJOR < 5) || !defined(NCURSES_MAJOR_VERSION)
    long result = 0;
    result = getattrs(win);
#else
a2663 1
#endif
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d74 1
a74 1
static int dumbterm (char *terminal);
d78 1
a78 1
static void make_blink_boldbg (void);
d82 1
a82 1
int Current_Attr, Masked_Attr;
d86 3
a88 3
unsigned int Lynx_Color_Flags = 0;
BOOLEAN FullRefresh = FALSE;
int curscr = 0;
d94 1
a94 1
int PHYSICAL_SLtt_Screen_Cols = 10;
d98 1
a98 1
void LY_SLrefresh (void)
d115 1
a115 1
void LY_SLerase (void)
d122 1
a122 1
void VTHome (void)
d130 2
a131 2
void LYaddAttr (
	int		a)
d137 2
a138 2
void LYsubAttr (
	int		a)
d144 1
a144 1
static void lynx_setup_attrs (void)
d162 1
a162 1
void lynx_setup_colors (void)
d182 2
a183 2
static void sl_suspend (
	int		sig)
d239 2
a240 2
int string_to_attr (
    char *	name)
d254 2
a255 2
static char *attr_to_string (
    int	code)
d276 2
a277 2
	    const char *fg = lookup_color(bold ? f+COLORS : f);
	    const char *bg = lookup_color(b);
d292 3
a294 3
void LYbox (
	WINDOW *	win,
	BOOLEAN	formfield GCC_UNUSED)
d373 1
a373 1
HTCharStyle displayStyles[DSTYLE_ELEMENTS];
d378 5
a382 5
void setStyle (
    int	style,
    int	color,
    int	cattr,
    int	mono)
d389 6
a394 6
void setHashStyle (
    int	style,
    int	color,
    int	cattr,
    int	mono,
    char *	element)
d411 4
a414 4
static void LYAttrset (
    WINDOW *	win,
    int	color,
    int	mono)
d430 4
a433 4
void curses_w_style (
	WINDOW*	win,
	int		style,
	int		dir)
d517 4
a520 4
void wcurses_css (
    WINDOW *	win,
    char*	name,
    int	dir)
d540 3
a542 3
void curses_css (
    char *	name,
    int	dir)
d547 3
a549 3
void curses_style (
	int	style,
	int	dir)
d555 1
a555 1
static BOOL lynx_called_initscr = FALSE;
d562 1
a562 1
int lynx_default_colors (void)
d587 1
a587 1
static struct {
d603 1
a603 1
static struct {
d614 1
a614 1
static int get_color_pair (int n)
d638 1
a638 1
static int lynx_color_cfg_attr (int code)
d653 1
a653 1
static void LYsetWAttr (WINDOW * win)
d681 1
a681 1
static void lynx_init_color_pair (int n)
d698 1
a698 1
static void lynx_map_color (int n)
d718 4
a721 4
int lynx_chg_color (
	int color,
	int fg,
	int bg
d735 1
a735 1
void lynx_set_color (int a)
d745 1
a745 1
void lynx_standout (int flag)
d753 1
a753 1
static void lynx_init_colors (void)
d772 1
a772 1
void lynx_setup_colors (void)
d781 2
a782 2
void LYnoVideo (
	int		a)
d834 2
a835 2
int saved_scrsize_x = 0;
int saved_scrsize_y = 0;
d838 1
a838 1
void start_curses (void)
d1181 1
a1181 1
void lynx_enable_mouse (int state)
d1283 1
a1283 1
void lynx_nl2crlf (int normal GCC_UNUSED)
d1321 1
a1321 1
void stop_curses (void)
d1389 2
a1390 2
BOOLEAN setup (
	char *		terminal)
d1462 2
a1463 2
BOOLEAN setup (
	char *		terminal)
d1518 1
a1518 1
    if ((strncmp((const char *)ttytype, "sun", 3) == 0)) {
d1529 2
a1530 2
static int dumbterm (
	char *		terminal)
d1552 3
a1554 3
void LYaddWAttr (
	WINDOW *	win,
	int		a)
d1560 2
a1561 2
void LYaddAttr (
	int		a)
d1566 3
a1568 3
void LYsubWAttr (
	WINDOW *	win,
	int		a)
d1574 2
a1575 2
void LYsubAttr (
	int		a)
d1592 4
a1595 4
void LYpaddstr (
	WINDOW *	the_window,
	int		width,
	const char *	the_string)
d1618 1
a1618 1
static WINDOW *my_subwindow;
d1620 1
a1620 1
void LYsubwindow (WINDOW * param)
d1639 1
a1639 1
WINDOW *LYtopwindow (void)
d1645 5
a1649 5
WINDOW *LYstartPopup (
    int	top_y,
    int	left_x,
    int	height,
    int	width)
d1687 1
a1687 1
void LYstartTargetEmphasis (void)
d1702 1
a1702 1
void LYstopTargetEmphasis (void)
d1720 2
a1721 2
void LYtouchline (
	int		row)
d1749 4
a1752 4
void LYwaddnstr (
	WINDOW *	w,
	const char *	src,
	size_t		len)
d1965 3
a1967 3
int VMSVersion (
	char *		VerString,
	int		VerLen)
d1992 1
a1992 1
void VMSexit (void)
d2034 1
a2034 1
int ttopen (void)
d2115 1
a2115 1
int ttclose (void)
d2138 1
a2138 1
int ttgetc (void)
d2170 1
a2170 1
int typeahead (void)
d2219 3
a2221 3
void VMSsignal (
int sig,
void (*func)())
d2284 7
a2290 7
static unsigned int DCLspawn_exception (
	void *		sigarr,
	void *		mecharr)
#else
static int DCLspawn_exception (
	void *		sigarr,
	void *		mecharr)
d2299 2
a2300 2
static int spawn_DCLprocess (
	char *		command)
d2349 2
a2350 2
int DCLsystem (
	char *		command)
d2367 1
a2367 1
int LYscreenHeight (void)
d2375 1
a2375 1
int LYscreenWidth (void)
d2395 1
a2395 1
void LYclear (void)
d2404 1
a2404 1
void LYclrtoeol (void)
d2413 1
a2413 1
void LYerase (void)
d2422 1
a2422 1
void LYmove (int y, int x)
d2431 1
a2431 1
void LYrefresh (void)
d2468 1
a2468 1
void lynx_force_repaint (void)
d2473 1
a2473 1
void lynx_start_title_color (void)
d2480 1
a2480 1
void lynx_stop_title_color (void)
d2487 3
a2489 3
void lynx_start_link_color (
	int	flag,
	int	pending)
d2519 3
a2521 3
void lynx_stop_link_color (
	int	flag,
	int	pending GCC_UNUSED)
d2551 1
a2551 1
void lynx_stop_target_color (void)
d2558 1
a2558 1
void lynx_start_target_color (void)
d2566 1
a2566 1
void lynx_start_status_color (void)
d2576 1
a2576 1
void lynx_stop_status_color (void)
d2586 1
a2586 1
void lynx_start_h1_color (void)
d2592 1
a2592 1
void lynx_stop_h1_color (void)
d2598 1
a2598 1
void lynx_start_prompt_color (void)
d2603 1
a2603 1
void lynx_stop_prompt_color (void)
d2608 1
a2608 1
void lynx_start_radio_color (void)
d2613 1
a2613 1
void lynx_stop_radio_color (void)
d2618 1
a2618 1
void lynx_stop_all_colors (void)
d2628 1
a2628 1
void lynx_start_bold (void)
d2633 1
a2633 1
void lynx_start_reverse (void)
d2638 1
a2638 1
void lynx_start_underline (void)
d2643 1
a2643 1
void lynx_stop_bold (void)
d2648 1
a2648 1
void lynx_stop_reverse (void)
d2653 1
a2653 1
void lynx_stop_underline (void)
d2667 4
a2670 4
void LYstowCursor (
    WINDOW *	win,
    int	row,
    int	col)
d2687 1
a2687 1
static void make_blink_boldbg (void)
d2702 1
a2702 1
long LYgetattrs (WINDOW * win)
d2704 1
a2704 1
#if ( defined(HAVE_GETATTRS) && ( !defined(NCURSES_MAJOR_VERSION) || NCURSES_VERSION_MAJOR < 5 ) )
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d70 2
a71 2
 * These are routines to start and stop curses and to cleanup the screen at the
 * end.
d74 1
a74 1
static int dumbterm(char *terminal);
d78 1
a78 1
static void make_blink_boldbg(void);
d92 1
a92 1
 * Will be set by size_change.  - KW
d97 2
a98 1
void LY_SLrefresh(void)
d115 1
a115 1
void LY_SLerase(void)
d117 2
a118 2
    SLsmg_gotorc(0, 0);
    SLsmg_erase_eos();
d122 1
a122 1
void VTHome(void)
d130 2
a131 1
void LYaddAttr(int a)
d137 2
a138 1
void LYsubAttr(int a)
d144 1
a144 1
static void lynx_setup_attrs(void)
d146 1
a146 2
    static int monoattr[] =
    {
d162 1
a162 1
void lynx_setup_colors(void)
d166 10
a175 10
    SLtt_set_color(1, NULL, "blue", DEFAULT_BG);	/* bold */
    SLtt_set_color(2, NULL, "yellow", "blue");	/* reverse */
    SLtt_set_color(4, NULL, "magenta", DEFAULT_BG);	/* underline */
    /*
     * The other objects are '|'ed together to get rest.
     */
    SLtt_set_color(3, NULL, "green", DEFAULT_BG);	/* bold-reverse */
    SLtt_set_color(5, NULL, "blue", DEFAULT_BG);	/* bold-underline */
    SLtt_set_color(6, NULL, "red", DEFAULT_BG);		/* reverse-underline */
    SLtt_set_color(7, NULL, "magenta", "cyan");		/* reverse-underline-bold */
d177 1
a177 1
     * Now set monochrome attributes.
d182 2
a183 1
static void sl_suspend(int sig)
d189 1
a189 1
    lynx_enable_mouse(0);
d193 1
a193 1
    kill(getpid(), SIGSTOP);
d206 1
a206 1
     * Get new window size in case it changed.
d214 1
a214 1
    lynx_enable_mouse(1);
a223 1
/* *INDENT-OFF* */
a237 1
/* *INDENT-ON* */
d239 2
a240 1
int string_to_attr(char *name)
d254 2
a255 1
static char *attr_to_string(int code)
a274 1

d276 1
a276 1
	    const char *fg = lookup_color(bold ? f + COLORS : f);
a277 1

d290 5
a294 3
 *  This function boxes windows for (n)curses.
 */
void LYbox(WINDOW * win, BOOLEAN formfield GCC_UNUSED)
d313 1
a313 1
    for (i = 1; i < win->_max_y - 1; i++) {
d316 1
a316 1
	wmove(win, i, win->_max_x - 1);
d326 6
a331 6
     * If the terminal is in UTF-8 mode, it probably cannot understand box
     * drawing characters as (n)curses handles them.  (This may also be true
     * for other display character sets, but isn't currently checked.) In that
     * case, substitute ASCII characters for BOXVERT and BOXHORI if they were
     * defined to 0 for automatic use of box drawing characters.  They'll stay
     * as they are otherwise.  - KW & FM
d341 5
a345 4
     * If we don't have explicitly specified characters for either vertical or
     * horizontal lines, the characters that box() would use for the corners
     * probably also won't work well.  So we specify our own ASCII characters
     * for the corners and call wborder() instead of box().  - kw
d378 5
a382 4
void setStyle(int style,
	      int color,
	      int cattr,
	      int mono)
d389 10
a398 11
void setHashStyle(int style,
		  int color,
		  int cattr,
		  int mono,
		  char *element)
{
    bucket *ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE,
	    (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n",
	     element, style, color, mono));
d411 4
a414 2
static void LYAttrset(WINDOW * win, int color,
		      int mono)
d417 3
a419 4
	&& LYShowColor >= SHOW_COLOR_ON
	&& color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color (%s)\n",
			      attr_to_string(color)));
d422 1
a422 2
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono (%s)\n",
			      attr_to_string(mono)));
d430 4
a433 2
void curses_w_style(WINDOW * win, int style,
		    int dir)
d441 1
a441 2
    int YP, XP;

d443 1
a443 2
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);

d445 2
a446 2
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket :
		  (style == SPECIAL_STYLE ? &special_bucket : &hashStyles[style]));
d449 1
d451 1
a451 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n", style));
d457 1
a457 3
    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> (%d)\n",
			  (dir ? "" : "/"),
			  ds->name, ds->code));
d459 1
a459 1
    getyx(win, YP, XP);
d462 2
a463 3
	wattrset(win, A_NORMAL);
	if (win == LYwin)
	    cached_styles[YP][XP] = s_normal;
d467 2
a468 1
    switch (dir) {
d473 4
a476 4

	    LYAttrset(win, last_attr, last_attr);
	} else
	    LYAttrset(win, A_NORMAL, -1);
d479 7
a485 7
    case STACK_ON:		/* remember the current attributes */
	if (last_colorattr_ptr >= MAX_LAST_STYLES) {
	    CTRACE2(TRACE_STYLE, (tfp, "........... %s (0x%x) %s\r\n",
				  "attribute cache FULL, dropping last",
				  last_styles[last_colorattr_ptr],
				  "in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr = MAX_LAST_STYLES - 1;
d495 1
a495 2
	if (!ds->name)
	    break;
d498 10
a507 12
    case ABS_ON:		/* change without remembering the previous style */
	/* don't cache style changes for active links and edits */
	if (style != s_alink
	    && style != s_curedit
	    && style != s_aedit
	    && style != s_aedit_sel
	    && style != s_aedit_pad
	    && style != s_aedit_arr) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n",
				  ds->name, YP, XP));
	    if (win == LYwin)
		cached_styles[YP][XP] = style;
d517 4
a520 2
void wcurses_css(WINDOW * win, char *name,
		 int dir)
a525 1

a528 1

d530 2
a531 4
	    if (class)
		*class = '\0';
	    else
		try_again = 0;
d540 3
a542 2
void curses_css(char *name,
		int dir)
d547 3
a549 2
void curses_style(int style,
		  int dir)
d562 1
a562 1
int lynx_default_colors(void)
a564 1

d586 1
a586 1
/* *INDENT-OFF* */
a598 1
/* *INDENT-ON* */
d614 1
a614 1
static int get_color_pair(int n)
d618 1
a618 1
	&& lynx_color_pairs[n].bg == default_bg)
d638 1
a638 1
static int lynx_color_cfg_attr(int code)
a640 1

a642 1

d653 1
a653 1
static void LYsetWAttr(WINDOW * win)
d668 2
a669 2
	if (code + offs < COLOR_PAIRS) {
	    attr |= get_color_pair(code + offs);
d681 1
a681 1
static void lynx_init_color_pair(int n)
a687 1

d689 3
a691 3
		init_pair((short) pair,
			  (short) map2bold(lynx_color_pairs[pair].fg),
			  (short) map2bold(lynx_color_pairs[pair].bg));
d698 1
a698 1
static void lynx_map_color(int n)
d702 2
a703 2
    lynx_color_pairs[n + 1].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n + 1].bg = lynx_color_cfg[n].bg;
d705 2
a706 2
    lynx_color_pairs[n + 9].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n + 9].bg = lynx_color_cfg[0].bg;
d708 2
a709 2
    lynx_color_pairs[n + 17].fg = lynx_color_cfg[n].bg;
    lynx_color_pairs[n + 17].bg = lynx_color_cfg[n].bg;
d718 5
a722 4
int lynx_chg_color(int color,
		   int fg,
		   int bg
)
d724 1
a724 2
    if (fg == ERR_COLOR || bg == ERR_COLOR)
	return -1;
d735 1
a735 1
void lynx_set_color(int a)
d739 3
a741 3
		 | (((a + 1) < COLOR_PAIRS)
		    ? get_color_pair(a + 1)
		    : A_NORMAL));
d745 1
a745 1
void lynx_standout(int flag)
d753 1
a753 1
static void lynx_init_colors(void)
d759 1
a759 1
		default_fg, default_bg));
d772 1
a772 1
void lynx_setup_colors(void)
a774 1

d781 2
a782 1
void LYnoVideo(int a)
d786 3
a788 6
    if (a & 1)
	Masked_Attr |= SLTT_BOLD_MASK;
    if (a & 2)
	Masked_Attr |= SLTT_REV_MASK;
    if (a & 4)
	Masked_Attr |= SLTT_ULINE_MASK;
d792 3
a794 6
    if (a & 1)
	Masked_Attr |= A_BOLD;
    if (a & 2)
	Masked_Attr |= A_REVERSE;
    if (a & 4)
	Masked_Attr |= A_UNDERLINE;
a806 1

d815 1
a815 1
#else /* HAVE_NEWTERM   */
a816 1

d821 1
a821 1
#define LYDELSCR()		/* nothing */
d823 1
a823 1
#else /* !defined(VMS) && !defined(USE_SLANG) */
d830 1
a830 1
#define LYDELSCR()		/* nothing */
d838 1
a838 1
void start_curses(void)
d850 2
a851 2
	if (-1 == lynx_initialize_keymaps())
	    exit(EXIT_FAILURE);
d856 1
a856 1
	SLkp_init();
d870 1
a870 1
	 * Check whether a saved show_color:off override is in effect.  - kw
d876 1
a876 1
	 * Check whether we're forcing color on.  - FM
d881 1
a881 1
	 * Check whether a -nocolor override is in effect.  - kw
d886 1
a886 1
	 * Make sure our flags are in register.  - FM
d905 2
a906 2
	 * If set, the blink escape sequence will turn on high intensity
	 * background (rxvt and maybe Linux console).
d927 2
a928 2
	SLsmg_Display_Eight_Bit = 191;	/* may print ctrl chars otherwise - kw */
    scrollok(0, 0);
d931 1
a931 1
    SLsmg_touch_screen();
d944 1
a944 1
    lynx_enable_mouse(1);
d951 2
a952 1
     * If we are VMS then do initscr() everytime start_curses() is called!
d955 2
a956 2
    initscr();			/* start curses */
#else /* Unix: */
a965 1

d973 2
a974 1
	 * If we're not VMS then only do initscr() one time, and one time only!
d982 1
a982 1
	recent_sizechange = savesize;	/* avoid extra redraw */
d992 2
a993 1
	    static char lines_putenv[] = "LINES=abcde", cols_putenv[] = "COLUMNS=abcde";
d996 1
a996 1
	    sprintf(cols_putenv + 8, "%d", LYcols & 0xfff);
d1004 1
a1004 1
	if (!(LYscreen = newterm(NULL, stdout, stdin))) {	/* start curses */
d1006 2
a1007 2
		    gettext("Terminal initialisation failed - unknown terminal type?"));
	    exit_immediately(EXIT_FAILURE);
d1019 1
a1019 1
	recent_sizechange = FALSE;	/* prevent mainloop drawing 1st doc twice */
d1021 1
a1021 1
	CTRACE((tfp, "Screen size is now %d x %d\n", LYlines, LYcols));
d1037 1
a1037 1
	keypad(LYwin, TRUE);
d1039 1
a1039 1
#  endif			/* HAVE_KEYPAD */
d1041 1
a1041 1
	if (-1 == lynx_initialize_keymaps()) {
d1043 1
a1043 1
	    exit(EXIT_FAILURE);
a1057 1

d1092 1
a1092 1
		    default_fg, default_bg));
a1094 1

d1127 1
a1127 1
/* nonl();   *//* seems to slow things down */
d1145 1
a1145 1
	keypad(LYwin, TRUE);
d1148 1
a1148 1
    lynx_enable_mouse(1);
d1160 1
a1160 1
    if (term_blink_is_boldbg)	/* Now actually make it so! */
d1174 1
a1174 1
	LYclear();
d1178 1
a1178 1
}				/* end of start_curses() */
d1180 2
a1181 1
void lynx_enable_mouse(int state)
a1190 1

d1192 2
a1193 1
    if (LYUseMouse == 0) {
d1204 2
a1205 2
    SLtt_set_mouse_mode(state, 0);
    SLtt_flush_output();
d1209 2
a1210 1
    if (state) {
d1224 1
a1224 1
	    if (old < 200)	/* Default 166 */
d1253 3
a1255 3
		     BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		     BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		     BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
d1257 1
a1257 1
#endif /* NOT USE_SLANG */
d1283 1
a1283 1
void lynx_nl2crlf(int normal GCC_UNUSED)
d1297 1
a1297 1
	    || (tigetstr("ind") != 0 && *tigetstr("ind") == '\n'))
d1321 1
a1321 1
void stop_curses(void)
d1326 1
a1326 1
    resetty();
d1344 1
a1344 1
    if (LYCursesON == TRUE) {
d1346 1
a1346 1
	lynx_enable_mouse(0);
d1351 4
a1354 4
	    if (LYscreen || lynx_called_initscr) {
		endwin();	/* stop curses */
		LYDELSCR();
	    }
d1360 1
a1360 2

	for (i = 0; i <= 3; i++) {
d1387 1
a1387 1
 * Check terminal type, start curses & setup terminal.
d1389 2
a1390 1
BOOLEAN setup(char *terminal)
a1394 1

d1400 2
a1401 2
     * If the display was not set by a command line option then see if it is
     * available from the environment.
d1410 1
a1410 1
     * Get terminal type, and convert to lower case.
d1416 2
a1417 2
	 * Some yoyo used these under conditions which require -dump, so force
	 * that mode here.  - FM
d1424 2
a1425 2
	(void) signal(SIGHUP, SIG_DFL);
	(void) signal(SIGTERM, SIG_DFL);
d1428 1
a1428 1
	    (void) signal(SIGTSTP, SIG_DFL);
d1438 1
a1438 1
	       gettext("You must use a vt100, 200, etc. terminal with this program."));
d1443 1
a1443 1
	    return (FALSE);
d1445 1
a1445 1
	strcpy(term, "vt100");
d1454 1
a1454 1
    return (TRUE);
d1457 1
a1457 1
#else /* Not VMS: */
d1460 1
a1460 1
 * Check terminal type, start curses & setup terminal.
d1462 2
a1463 1
BOOLEAN setup(char *terminal)
d1470 2
a1471 2
     * If the display was not set by a command line option then see if it is
     * available from the environment .
d1485 1
a1485 1
     * Query the terminal type.
d1497 1
a1497 1
	    StrAllocCopy(buffer, "vt100");
d1499 1
a1499 1
	HTSprintf0(&term_putenv, "TERM=%.106s", buffer);
d1503 1
a1503 2
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"),
	       LYGetEnv("TERM"));
d1511 6
a1516 6
     * Account for lossage on the 'sun' terminal type (80x24) Sun text console
     * driver.  It only supports reverse video, but all SGR sequences produce
     * that same reverse video, and the terminfo entry lists different SGRs for
     * 'bold' and 'rev'.  As a result, the current link is indistinguishable
     * from all other links.  The workaround here is to disable the 'rev'
     * capability.
d1518 1
a1518 1
    if ((strncmp((const char *) ttytype, "sun", 3) == 0)) {
d1526 1
a1526 1
    return (1);
d1529 2
a1530 1
static int dumbterm(char *terminal)
d1535 2
a1536 2
     * Began checking for terminal == NULL in case that TERM environment
     * variable is not set.  Thanks to Dick Wesseling (ftu@@fi.ruu.nl).
d1541 4
a1544 4
	!strcasecomp(terminal, "dialup") ||
	!strcasecomp(terminal, "dumb") ||
	!strcasecomp(terminal, "switch") ||
	!strcasecomp(terminal, "ethernet"))
d1546 1
a1546 1
    return (dumb);
d1552 3
a1554 1
void LYaddWAttr(WINDOW * win, int a)
d1560 2
a1561 1
void LYaddAttr(int a)
d1566 3
a1568 1
void LYsubWAttr(WINDOW * win, int a)
d1574 2
a1575 1
void LYsubAttr(int a)
d1592 4
a1595 2
void LYpaddstr(WINDOW * the_window, int width,
	       const char *the_string)
d1620 1
a1620 1
void LYsubwindow(WINDOW * param)
d1626 1
a1626 1
#if defined(HAVE_GETBKGD)	/* not defined in ncurses 1.8.7 */
d1639 1
a1639 1
WINDOW *LYtopwindow(void)
d1645 5
a1649 5
WINDOW *LYstartPopup(
			int top_y,
			int left_x,
			int height,
			int width)
a1651 1

a1653 1

d1656 1
a1656 1
    form_window->top_y = top_y;
d1659 1
a1659 1
    form_window->width = width;
d1679 1
a1679 1
	    wbkgdset(form_window, (b & ~(A_BOLD | A_BLINK)) | ' ');
d1687 1
a1687 1
void LYstartTargetEmphasis(void)
d1702 1
a1702 1
void LYstopTargetEmphasis(void)
d1720 2
a1721 1
void LYtouchline(int row)
d1749 4
a1752 2
void LYwaddnstr(WINDOW * w, const char *src,
		size_t len)
a1760 1

d1762 1
a1762 2
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n",
			      y, x, (int) len, src));
d1776 2
a1777 2
#if 0				/* defined(WIDEC_CURSES) && defined(HAVE_MBSTATE_T) */
#if 1				/* array of wchar_t's */
d1800 1
a1800 1
	    if (rc == 0 || rc == (size_t) (-1) || rc == (size_t) (-2))
d1814 1
a1814 1
#else /* array of cchar_t's */
d1831 1
a1831 1
	wattr_get(w, &attr, &pair, (void *) 0);
d1843 1
a1843 1
	    if (rc == 0 || rc == (size_t) (-1) || rc == (size_t) (-2))
d1865 1
a1865 1
	wadd_wchnstr(w, temp, k);
a1881 1

d1951 1
a1951 26
#define EFN	0		/* Event flag                   */

static unsigned char buffer[20];	/* Input buffer                 */
static int in_pos, in_len;	/* For escape sequences         */
static int oldmode[3];		/* Old TTY mode bits            */
static int newmode[3];		/* New TTY mode bits            */
static short iochan;		/* TTY I/O channel              */
static $DESCRIPTOR(term_nam_dsc, "TT");		/* Descriptor for iochan        */
static unsigned long mask = LIB$M_CLI_CTRLY | LIB$M_CLI_CTRLT;	/* ^Y and ^T */
static unsigned long old_msk;	/* Saved control mask           */
static short trap_flag = FALSE;	/* TRUE if AST is set           */
BOOLEAN DidCleanup = FALSE;	/* Exit handler flag            */
static char VersionVMS[20];	/* Version of VMS               */

int VMSVersion(char *VerString,
	       int VerLen)
{
    unsigned long status, itm_cod = SYI$_VERSION;
    int i, verlen = 0;
    struct dsc$descriptor version;
    char *m;

    version.dsc$a_pointer = VerString;
    version.dsc$w_length = VerLen - 1;
    version.dsc$b_dtype = DSC$K_DTYPE_B;
    version.dsc$b_class = DSC$K_CLASS_S;
d1953 45
a1997 19
    status = lib$getsyi(&itm_cod, 0, &version, &verlen, 0, 0);
    if (!(status & 1) || verlen == 0)
	return 0;

    /*
     * Cut out trailing spaces
     */
    for (m = VerString + verlen, i = verlen - 1; i > 0 && VerString[i] == ' '; --i)
	*(--m) = '\0';

    return strlen(VerString) + 1;	/* Transmit ending 0 too */
}

void VMSexit(void)
{
    /*
     * If we get here and DidCleanup is not set, it was via an ACCVIO, or
     * outofmemory forced exit, so make *sure* we attempt a cleanup and reset
     * the terminal.
d2002 1
a2002 2
		    gettext("\nA Fatal error has occurred in %s Ver. %s\n"),
		    LYNX_NAME, LYNX_VERSION);
d2004 1
a2004 1
		    gettext("\nPlease notify your system administrator to confirm a bug, and if\n\
d2011 1
a2011 1
		fprintf(stderr, RETURN_TO_CLEANUP);
d2034 1
a2034 1
int ttopen(void)
d2036 35
a2070 9
    int iosb[2];
    int status;
    static unsigned long condition;
    static struct _exit_block {
	unsigned long forward;
	unsigned long address;
	unsigned long zero;
	unsigned long condition;
    } exit_handler_block;
d2072 10
a2081 3
    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    if (status != SS$_NORMAL)
	exit(status);
d2083 13
a2095 8
    status = sys$qiow(EFN, iochan, IO$_SENSEMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit(status);
a2096 42
    newmode[0] = oldmode[0];
    newmode[1] = oldmode[1];
    newmode[2] = oldmode[2] | TT2$M_EDIT;

    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &newmode, sizeof(newmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit(status);

    /*
     * Declare the exit handler block.
     */
    exit_handler_block.forward = 0;
    exit_handler_block.address = (unsigned long) &VMSexit;
    exit_handler_block.zero = 0;
    exit_handler_block.condition = (unsigned long) &condition;
    status = sys$dclexh(&exit_handler_block);
    if (status != SS$_NORMAL)
	exit(status);

    /*
     * Set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      &cleanup_sig, SIGINT, 0, 0, 0, 0);
    if (status != SS$_NORMAL) {
	lib$enable_ctrl(&old_msk);
	exit(status);
    }

    /*
     * Get the version of VMS.
     */
    if (VMSVersion(VersionVMS, 20) < 3)
d2098 1
a2098 1
	 * Load zeros on error.
d2100 5
a2104 1
	strcpy(VersionVMS, "V0.0-0");
d2106 2
a2107 2
    return (0);
}				/*  ttopen  */
d2115 1
a2115 1
int ttclose(void)
d2117 2
a2118 2
    int status;
    int iosb[1];
d2120 2
a2121 2
    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);
d2123 2
a2124 2
    if (status != SS$_NORMAL || (iosb[0] & 0xFFFF) != SS$_NORMAL)
	exit(status);
d2126 7
a2132 7
    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }
    return (0);
}				/*  ttclose  */
d2138 1
a2138 1
int ttgetc(void)
d2144 1
a2144 1
	return (buffer[in_pos++]);
d2147 1
a2147 1
		      IO$_READVBLK | IO$M_NOECHO | IO$M_NOFILTR,
d2150 1
a2150 1
    if ((status & 1) == 1)
d2154 1
a2154 1
	 * Escape sequence in progress.  Fake a successful read.
d2158 1
a2158 1
    if ((status & 1) != 1 && status != SS$_DATAOVERUN)
d2162 1
a2162 1
    return (buffer[0]);
d2170 1
a2170 1
int typeahead(void)
d2179 1
a2179 1
	return (buffer[in_pos++]);
d2181 6
a2186 6
  again:
    status = sys$qiow(EFN, iochan,
		      IO$_READVBLK | IO$M_TIMED | IO$M_NOECHO | IO$M_NOFILTR,
		      &iosb, 0, 0,
		      &buffer, 1, 0, 0, 0, 0);
    if ((status & 1) == 1)
d2190 1
a2190 1
	 * Escape sequence in progress, finish reading it.
d2198 1
a2198 1
	return (-1);
d2219 7
a2225 6
void VMSsignal(int sig,
	       void (*func) ())
{
    int status;
    short iosb[4];
    static int SIG_IGN_flag;
d2227 8
a2234 8
    /*
     * Pass all signals other than SIGINT to signal().
     * Also pass SIGINT to signal() if we're dumping.
     */
    if (sig != SIGINT || dump_output_immediately) {
	signal(sig, func);
	return;
    }
d2236 7
a2242 7
    /*
     * If func is SIG_DFL, treat it as ttclose().
     */
    if (func == SIG_DFL) {
	ttclose();
	return;
    }
d2244 8
a2251 8
    /*
     * Clear any previous AST.
     */
    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }
d2253 6
a2258 6
    /*
     * If func is SIG_IGN, leave the TT channel closed and the system response
     * to interrupts enabled for system() calls.
     */
    if (func == SIG_IGN)
	return;
d2260 10
a2269 10
    /*
     * If we get to here, we have a LYNX func, so set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      func, SIGINT, 0, 0, 0, 0);
d2271 1
a2271 1
}				/* VMSsignal */
d2274 1
a2274 1
 * DCLspawn_exception, spawn_DCLprocess, DCLsystem -- F.Macrides 16-Jan-1994
d2284 28
a2311 8
static unsigned int DCLspawn_exception(void *sigarr,
				       void *mecharr)
#else
static int DCLspawn_exception(void *sigarr,
			      void *mecharr)
#endif				/* __DECC */
{
    int status;
d2313 1
a2313 20
    status = lib$sig_to_ret(sigarr, mecharr);
    return (SS$_UNWIND);
}

static int spawn_DCLprocess(char *command)
{
    int status;
    unsigned long Status = 0;

    /*
     * Keep DECC from complaining.
     */
    struct dsc$descriptor_s command_desc;

    command_desc.dsc$w_length = strlen(command);
    command_desc.dsc$b_class = DSC$K_CLASS_S;
    command_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    command_desc.dsc$a_pointer = command;

    VAXC$ESTABLISH(DCLspawn_exception);
d2316 3
a2318 3
    if (VersionVMS[1] > '6' ||
	(VersionVMS[1] == '6' && VersionVMS[2] == '.' &&
	 VersionVMS[3] >= '1'))
d2320 1
a2320 1
    if (VersionVMS[1] >= '6')
d2322 39
a2360 39
    {
	/*
	 * Include TRUSTED flag.
	 */
	unsigned long trusted = CLI$M_TRUSTED;

	status = lib$spawn(&command_desc, 0, 0, &trusted,
			   0, 0, &Status);
	/*
	 * If it was invalid, try again without the flag.
	 */
	if (status == LIB$_INVARG)
	    status = lib$spawn(&command_desc, 0, 0, 0,
			       0, 0, &Status);
    } else
	status = lib$spawn(&command_desc, 0, 0, 0,
			   0, 0, &Status);
    /*
     * Return -1 on error.
     */
    if ((status & 1) != 1 || (Status & 1) != 1)
	return (-1);
    /*
     * Return 0 on success.
     */
    return (0);
}

int DCLsystem(char *command)
{
    int status;

    VMSsignal(SIGINT, SIG_IGN);
    status = spawn_DCLprocess(command);
    VMSsignal(SIGINT, cleanup_sig);
    /*
     * Returns 0 on success, -1 any error.
     */
    return (status);
d2367 1
a2367 1
int LYscreenHeight(void)
a2369 1

d2375 1
a2375 1
int LYscreenWidth(void)
d2378 1
a2378 2

#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX)		/* 1999/08/26 (Thu) 17:53:38 */
d2395 1
a2395 1
void LYclear(void)
d2404 1
a2404 1
void LYclrtoeol(void)
d2413 1
a2413 1
void LYerase(void)
d2422 1
a2422 1
void LYmove(int y, int x)
d2431 1
a2431 1
void LYrefresh(void)
a2443 1

d2445 1
a2445 2
	if (x >= LYcols)
	    x = LYcols - 1;
d2449 1
a2449 1
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth() - 1);
d2468 1
a2468 1
void lynx_force_repaint(void)
d2473 1
a2473 1
void lynx_start_title_color(void)
d2480 1
a2480 1
void lynx_stop_title_color(void)
d2487 3
a2489 2
void lynx_start_link_color(int flag,
			   int pending)
d2502 1
a2502 1
	    lynx_start_underline();
d2506 1
a2506 1
	    lynx_start_underline();
d2508 1
a2508 1
    } else {
d2511 2
a2512 2
	 * Make sure when flag is OFF that "unhighlighted" links will be
	 * underlined if appropriate.  - LE & FM
d2516 1
a2516 1
    }
d2519 3
a2521 2
void lynx_stop_link_color(int flag,
			  int pending GCC_UNUSED)
d2532 1
a2532 1
	    lynx_stop_underline();
d2536 1
a2536 1
	    lynx_stop_underline();
d2541 1
a2541 1
	 * If underlining was turned on above, turn it off.  - LE & FM
d2551 1
a2551 1
void lynx_stop_target_color(void)
d2558 1
a2558 1
void lynx_start_target_color(void)
d2565 2
a2566 1
void lynx_start_status_color(void)
d2570 1
a2570 1
	lynx_set_color(2);
d2573 1
a2573 1
	lynx_start_reverse();
d2576 1
a2576 1
void lynx_stop_status_color(void)
d2580 1
a2580 1
	lynx_set_color(0);
d2583 1
a2583 1
	lynx_stop_reverse();
d2586 1
a2586 1
void lynx_start_h1_color(void)
d2592 1
a2592 1
void lynx_stop_h1_color(void)
d2598 1
a2598 1
void lynx_start_prompt_color(void)
d2600 1
a2600 1
    lynx_start_reverse();
d2603 1
a2603 1
void lynx_stop_prompt_color(void)
d2605 1
a2605 1
    lynx_stop_reverse();
d2608 1
a2608 1
void lynx_start_radio_color(void)
d2610 1
a2610 1
    lynx_start_bold();
d2613 1
a2613 1
void lynx_stop_radio_color(void)
d2615 1
a2615 1
    lynx_stop_bold();
d2618 1
a2618 1
void lynx_stop_all_colors(void)
d2620 3
a2622 3
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
d2628 1
a2628 1
void lynx_start_bold(void)
d2633 1
a2633 1
void lynx_start_reverse(void)
d2638 1
a2638 1
void lynx_start_underline(void)
d2643 1
a2643 1
void lynx_stop_bold(void)
d2648 1
a2648 1
void lynx_stop_reverse(void)
d2653 1
a2653 1
void lynx_stop_underline(void)
d2667 4
a2670 2
void LYstowCursor(WINDOW * win, int row,
		  int col)
d2683 1
a2683 1
#if defined(USE_BLINK) && defined(__EMX__)	/* Can't put it earler due to BOOLEAN conflict */
d2687 1
a2687 1
static void make_blink_boldbg(void)
d2690 1
a2690 2

    /* but FS session need a switch */
d2694 1
a2694 1
    VioSetState(&buf, 0);
d2702 1
a2702 1
long LYgetattrs(WINDOW * win)
a2705 1

@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a19 1
#include <HTFont.h>
d1334 1
a1334 1
    if (LYCursesON) {
a1335 1
    }
d1604 2
a1605 2
    if (width + x > LYcolLimit)
	width = LYcolLimit - x;
d1648 5
a1652 4
WINDOW *LYstartPopup(int *top_y,
		     int *left_x,
		     int *height,
		     int *width)
d1659 1
a1659 6
    if (*left_x < 1 || (*left_x + *width + 4) >= LYcolLimit) {
	*left_x = 1;
	*width = LYcolLimit - 5;
    }

    SLsmg_fill_region(*top_y, *left_x - 1, *height, *width + 4, ' ');
d1661 7
a1667 12
    form_window->top_y = *top_y;
    form_window->left_x = *left_x;
    form_window->height = *height;
    form_window->width = *width;
#else
    if (*left_x > 0 && (*left_x + *width + 4) < LYcolLimit)
	form_window = newwin(*height, *width + 4, *top_y, *left_x - 1);
    if (form_window == 0) {
	*width = LYcolLimit - 4;
	form_window = newwin(*height, LYcolLimit, *top_y, 0);
    }
    if (form_window == 0) {
d1753 1
a1753 2
void LYwaddnstr(WINDOW * w GCC_UNUSED,
		const char *src,
a1894 75
/*
 * Determine the number of cells the given string would take up on the screen,
 * limited by the maxCells parameter.  This is used for constructing aligned
 * text in the options and similar forms.
 *
 * FIXME: make this account for wrapping, too.
 * FIXME: make this useful for "lynx -dump", which hasn't initialized curses.
 */
int LYstrExtent(const char *string, int len, int maxCells)
{
    int result = 0;
    int used;

    if (len < 0)
	used = strlen(string);
    else
	used = len;

    result = used;
#ifdef WIDEC_CURSES
    if (used > 0 && lynx_called_initscr) {
	static WINDOW *fake_win;
	static int fake_max;
	int n;

	if (fake_max < maxCells) {
	    fake_max = (maxCells + 1) * 2;
	    if (fake_win != 0) {
		delwin(fake_win);
		fake_win = 0;
	    }
	}
	if (fake_win == 0) {
	    fake_win = newwin(2, fake_max, 0, 0);
	}
	if (fake_win != 0) {
	    int new_x = 0;
	    int new_y = 0;

	    result = 0;
	    wmove(fake_win, 0, 0);
	    for (n = 0; n < used; ++n) {
		if (IsNormalChar(string[n])) {
		    waddch(fake_win, UCH(string[n]));
		    getyx(fake_win, new_y, new_x);
		    if (new_y > 0 || new_x > maxCells)
			break;
		    result = new_x;
		}
	    }
	}
    }
#endif
    if (result > maxCells)
	result = maxCells;
    return result;
}

/*
 * A simple call that relies upon the coincidence that multicell characters
 * use at least as many bytes as cells.
 */
int LYstrExtent2(const char *string, int len)
{
    return LYstrExtent(string, len, len);
}

/*
 * Returns the total number of cells that the string would use.
 */
int LYstrCells(const char *string)
{
    return LYstrExtent2(string, strlen(string));
}

d2451 2
a2452 2
	if (x > LYcolLimit)
	    x = LYcolLimit;
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d7 1
a17 4
#ifdef VMS
#include <LYMainLoop.h>
#endif

a36 4
#ifdef HAVE_XCURSES
char *XCursesProgramName = "Lynx";
#endif

a42 8
#ifdef USE_CURSES_PADS
WINDOW *LYwin = 0;
int LYshiftWin = 0;
int LYwideLines = FALSE;
int LYtableCols = 0;			/* in 1/12 of screen width */
BOOL LYuseCursesPads = TRUE;	/* use pads for left/right shifting */
#endif

a50 4
#if defined(USE_BLINK) && defined(__EMX__)
PRIVATE void make_blink_boldbg NOARGS;
#endif

d52 1
a52 1
PUBLIC int Current_Attr, Masked_Attr;
d59 1
a63 1

d72 1
d109 1
a109 1
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
d116 1
a116 19
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
}

PRIVATE void lynx_setup_attrs NOARGS
{
    static int monoattr[] = {
	0,
	SLTT_BOLD_MASK,
	SLTT_REV_MASK,
	SLTT_REV_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK | SLTT_REV_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK | SLTT_REV_MASK
    };
    int n;

    for (n = 1; n <= 7; n++)
	SLtt_set_mono(n, NULL, (monoattr[n] & ~Masked_Attr));
a120 1
    CTRACE((tfp, "lynx_setup_colors\n"));
d132 1
d136 7
a142 1
    lynx_setup_attrs();
d163 1
a163 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d180 1
a180 1
    return;
a181 1
#else
d183 1
a183 67
#ifdef FANCY_CURSES

#ifndef VMS
/* definitions for the mono attributes we can use */
static struct {
    char *name;
    int code;
} Mono_Attrs[7] =
{
    { "normal",		A_NORMAL },
    { "bold",		A_BOLD },
    { "reverse",	A_REVERSE },
    { "underline",	A_UNDERLINE },
    { "standout",	A_STANDOUT },
    { "blink",		A_BLINK },
    { "dim",		A_DIM },
};

PUBLIC int string_to_attr ARGS1(
    char *,	name)
{
    unsigned i;

    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (!strcasecomp(Mono_Attrs[i].name, name)) {
	    return Mono_Attrs[i].code;
	}
    }
    return 0;
}
#endif /* VMS */

#ifdef USE_COLOR_STYLE
PRIVATE char *attr_to_string ARGS1(
    int,	code)
{
    static char result[sizeof(Mono_Attrs) + 80];
    unsigned i;
    int pair = PAIR_NUMBER(code);
    int bold = (pair != 0 && (code & A_BOLD) != 0);

    if (bold)
	code &= ~A_BOLD;

    *result = 0;
    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (Mono_Attrs[i].code & code) {
	    if (*result)
		strcat(result, "+");
	    strcat(result, Mono_Attrs[i].name);
	}
    }
    if (pair != 0) {
	short f, b;
	if (pair_content(pair, &f, &b) != ERR) {
	    CONST char *fg = lookup_color(bold ? f+COLORS : f);
	    CONST char *bg = lookup_color(b);
	    if (*result)
		strcat(result, "+");
	    sprintf(result + strlen(result), "%s/%s", fg, bg);
	}
    }
    return result;
}
#endif /* USE_COLOR_STYLE */
#endif /* FANCY_CURSES */
#endif /* USE_SLANG */
d185 1
d187 3
a189 1
**  This function boxes windows for (n)curses.
d191 1
a191 1
PUBLIC void LYbox ARGS2(
d193 2
a194 1
	BOOLEAN,	formfield GCC_UNUSED)
a195 10
#ifdef USE_SLANG
    SLsmg_draw_box(win->top_y, win->left_x, win->height, win->width + 4);
#else
#ifdef VMS
    /*
     * This should work for VAX-C and DEC-C, since they both have the same
     * win._max_y and win._max_x members -TD
     *
     * (originally VMSbox by FM)
     */
d200 2
a201 2
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
d203 1
a203 1
    for (i = 1; i < win->_max_y-1; i++) {
d206 1
a206 1
	wmove(win, i, win->_max_x-1);
d211 2
a212 2
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
d214 10
a223 1
#else /* !VMS */
a245 1
    LynxWChangeStyle(win, s_menu_frame, STACK_ON);
a255 1
    LynxWChangeStyle(win, s_menu_frame, STACK_OFF);
d260 1
a261 1
    wrefresh(win);
a262 1
}
d274 15
a288 26
PUBLIC void setStyle ARGS4(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono)
{
    displayStyles[style].color = color;
    displayStyles[style].cattr = cattr;
    displayStyles[style].mono = mono;
}

PUBLIC void setHashStyle ARGS5(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono,
    char *,	element)
{
    bucket* ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE, (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n", element, style, color, mono));

    ds->color = color;
    ds->cattr = cattr;
    ds->mono = mono;
    ds->code = style;
d290 4
a293 1
    StrAllocCopy(ds->name, element);
d299 14
a312 18
PRIVATE int LYAttrset ARGS3(
    WINDOW *,	win,
    int,	color,
    int,	mono)
{
    if (lynx_has_color
     && LYShowColor >= SHOW_COLOR_ON
     && color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color (%s)\n", attr_to_string(color)));
	wattrset(win, color);
	return color;
    } else if (mono >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono (%s)\n", attr_to_string(mono)));
	wattrset(win, mono);
	return mono;
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset (A_NORMAL)\n"));
	wattrset(win, A_NORMAL);
a313 1
    }
d323 2
a324 2
/* if TRACEs are not compiled in, this macro is redundant - we needn't valid
'ds' to stack off. */
d327 1
a327 1
    int YP,XP;
d329 1
a329 1
    bucket* ds= (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);
d331 2
a332 2
    bucket* ds= (style == NOSTYLE ?	     &nostyle_bucket :
	    (style== SPECIAL_STYLE ? &special_bucket :&hashStyles[style]) );
d336 3
a338 2
    if (!ds->name) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n",style));
d340 1
a340 1
	return;
d342 1
a342 1
    }
d344 1
a344 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> (%d)\n",(dir?"":"/"),ds->name,ds->code));
d346 1
a346 1
    getyx (win, YP, XP);
d348 6
a353 5
    if (style == s_normal && dir) {
	wattrset(win,A_NORMAL);
	if (win == LYwin) cached_styles[YP][XP] = s_normal;
	return;
    }
d355 22
a376 22
    switch (dir)
    {
	/* ABS_OFF is the same as STACK_OFF for the moment */
    case STACK_OFF:
	if (last_colorattr_ptr) {
	    int last_attr = last_styles[--last_colorattr_ptr];
	    LYAttrset(win,last_attr,last_attr);
	}
	else
	    LYAttrset(win,A_NORMAL,-1);
	break;

    case STACK_ON: /* remember the current attributes */
	if (last_colorattr_ptr > 127) {
	    CTRACE2(TRACE_STYLE, (tfp,"........... %s (0x%x) %s\r\n",
			"attribute cache FULL, dropping last",
			last_styles[last_colorattr_ptr],
			"in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr--;
	}
	last_styles[last_colorattr_ptr++] = getattrs(win);
	/* don't cache style changes for active links */
d378 24
a401 18
	/* since we don't compute the hcode to stack off in HTML.c, we
	 * don't know whether this style is configured.  So, we
	 * shouldn't simply return on stacking on unconfigured
	 * styles, we should push curr attrs on stack.  -HV
	 */
	if (!ds->name) break;
#endif
	/* FALL THROUGH */
    case ABS_ON: /* change without remembering the previous style */
	    /* don't cache style changes for active links and edits */
	if ( style != s_alink
	     && style != s_curedit
	     && style != s_aedit
	     && style != s_aedit_sel
	     && style != s_aedit_pad
	     && style != s_aedit_arr ) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP));
	    if (win == LYwin) cached_styles[YP][XP] = style;
a402 3
	LYAttrset(win, ds->color, ds->mono);
	break;
    }
d408 17
a424 19
PUBLIC void wcurses_css ARGS3(
    WINDOW *,	win,
    char*,	name,
    int,	dir)
{
    int try_again = 1;

    while (try_again) {
	int tmpHash = hash_code(name);
	CTRACE2(TRACE_STYLE, (tfp, "CSSTRIM:trying to set [%s] style - ", name));
	if (tmpHash == NOSTYLE) {
	    char *class = strrchr(name, '.');
	    CTRACE2(TRACE_STYLE, (tfp, "undefined, trimming at %p\n", class));
	    if (class)	*class = '\0';
	    else	try_again = 0;
	} else {
	    CTRACE2(TRACE_STYLE, (tfp, "ok (%d)\n", hash_code(name)));
	    curses_w_style(win, hash_code(name), dir);
	    try_again = 0;
a425 1
    }
d428 1
a428 3
PUBLIC void curses_css ARGS2(
    char *,	name,
    int,	dir)
d430 1
a430 1
    wcurses_css(LYwin, name, dir);
d437 1
a437 1
    curses_w_style(LYwin, style, dir);
a438 1
#endif /* USE_COLOR_STYLE */
d440 2
a441 8
PRIVATE BOOL lynx_called_initscr = FALSE;

#if HAVE_USE_DEFAULT_COLORS && USE_DEFAULT_COLORS
/*
 * If we find a "default" color while reading the config-file, set default
 * colors on the screen.
 */
PUBLIC int lynx_default_colors NOARGS
d443 1
a443 10
    int code = 0;
    if (lynx_called_initscr) {
	code = -1;
	if (!default_color_reset && use_default_colors() == OK) {
	    default_fg = DEFAULT_COLOR;
	    default_bg = DEFAULT_COLOR;
	    code = 1;
	}
    }
    return code;
d445 2
a446 1
#endif /* HAVE_USE_DEFAULT_COLORS && USE_DEFAULT_COLORS */
d457 1
d491 9
d509 12
d525 1
a525 1
	wattrset(win, attr & ~Masked_Attr);
d527 1
a527 1
	wattrset(win, Current_Attr & ~Masked_Attr);
a534 2
    CTRACE((tfp, "lynx_map_color(%d)\n", n));

d548 3
a550 3
		init_pair((short)pair,
		    (short)lynx_color_pairs[pair].fg,
		    (short)lynx_color_pairs[pair].bg);
d553 1
a553 1
	    wbkgd(LYwin, COLOR_BKGD | ' ');
d578 1
a578 1
	wattrset(LYwin, lynx_color_cfg[a].attr
a597 2
	CTRACE((tfp, "lynx_init_colors\n"));

d601 1
a601 1
	for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
d605 3
a607 3
		    init_pair((short)pair,
			(short)lynx_color_pairs[pair].fg,
			(short)lynx_color_pairs[pair].bg);
d610 1
a610 1
		wbkgd(LYwin, COLOR_BKGD | ' ');
a619 1
    CTRACE((tfp, "lynx_setup_colors\n"));
d625 7
a631 2
PUBLIC void LYnoVideo ARGS1(
	int,		a)
d633 31
a663 6
    CTRACE((tfp, "LYnoVideo(%d)\n", a));
#ifdef USE_SLANG
    if (a & 1) Masked_Attr |= SLTT_BOLD_MASK;
    if (a & 2) Masked_Attr |= SLTT_REV_MASK;
    if (a & 4) Masked_Attr |= SLTT_ULINE_MASK;
    lynx_setup_attrs();
d665 2
a666 7
#if USE_COLOR_TABLE
    if (a & 1) Masked_Attr |= A_BOLD;
    if (a & 2) Masked_Attr |= A_REVERSE;
    if (a & 4) Masked_Attr |= A_UNDERLINE;
#endif
#endif
}
a667 29
#if       !defined(VMS) && !defined(USE_SLANG)
/*
 * If newterm is not defined, assume a curses subset which
 * supports only initscr.  --gil
 */
#if defined(HAVE_NEWTERM) && defined(HAVE_DELSCREEN) && !(defined(NCURSES) && defined(HAVE_RESIZETERM))
static SCREEN *LYscreen = NULL;
#define LYDELSCR() { \
if (recent_sizechange) { \
    delscreen(LYscreen); \
    LYscreen = NULL; } }
/*
 * Surrogates for newterm annd delscreen
 */
#else  /* HAVE_NEWTERM   */
static WINDOW *LYscreen = NULL;
#undef  newterm
#define newterm(type, out, in) (initscr())
#define LYDELSCR()  /* nothing */
#endif /* HAVE_NEWTERM   */
#else  /* !defined(VMS) && !defined(USE_SLANG) */
/*
 * Provide last recourse definitions of LYscreen and LYDELSCR for
 * stop_curses, which only tests LYscreen for zero/nonzero but
 * never uses it as a pointer or L-value.
 */
#define LYscreen TRUE
#define LYDELSCR()  /* nothing */
#endif /* !defined(VMS) && !defined(USE_SLANG) */
d675 1
a675 1
	CTRACE((tfp, "start_curses: Hmm, already ON.\n"));
a679 4
#if defined(USE_KEYMAPS)
	if (-1 == lynx_initialize_keymaps ())
	    exit (EXIT_FAILURE);
#else
d681 1
a681 2
#endif
#if (defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)) || defined(__CYGWIN__)
d685 1
a685 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d689 1
a689 1
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
a690 4
#if !defined(USE_KEYMAPS) && defined(ENHANCED_LINEEDIT) && defined(ESCDELAY)
	/* way to get ESC that's not part of a recognized sequence through */
	ESCDELAY = 2000;
#endif
d721 3
a723 5
#if (defined(VMS) || defined(REAL_UNIX_SYSTEM)) && !defined(__CYGWIN__)
	if ((Masked_Attr & SLTT_ULINE_MASK) == 0) {
	    SLtt_add_color_attribute(4, SLTT_ULINE_MASK);
	    SLtt_add_color_attribute(5, SLTT_ULINE_MASK);
	}
d728 6
a733 2
	SLtt_Blink_Mode = term_blink_is_boldbg;
#endif /* (VMS || REAL_UNIX_SYSTEM) && !__CYGWIN__  */
a735 3
#ifdef WATT32
    _eth_init();
#else
a736 1
#endif /* WATT32 */
a753 3
#if SLANG_VERSION > 10306
    SLsmg_touch_screen ();
#endif
d755 1
a755 1
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
d757 1
a757 1
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
d765 3
a767 1
    lynx_enable_mouse (1);
a768 2
#else /* USE_SLANG; Now using curses: */
    int keypad_on = 0;
d778 3
a780 1
    if (!LYscreen) {
d785 1
a785 28
#if defined(HAVE_NEWTERM)
#if !(defined(NCURSES) && !defined(HAVE_RESIZETERM))
	BOOLEAN savesize;

	savesize = recent_sizechange;
	size_change(0);
	recent_sizechange = savesize;    /* avoid extra redraw */
#if defined(__MVS__)
	{
	    /*
	     * The requirement to do this may be a bug in OS/390.
	     *
	     * Put screen geometry in environment variables used by
	     * XOpen curses before calling newterm().  I believe this
	     * completes work left unfinished by AJL & FM -- gil
	     */
	    static char lines_putenv[] = "LINES=abcde",
			cols_putenv[]  = "COLUMNS=abcde";

	    sprintf(lines_putenv + 6, "%d", LYlines & 0xfff);
	    sprintf(cols_putenv  + 8, "%d", LYcols  & 0xfff);
	    putenv(lines_putenv);
	    putenv(cols_putenv);
	    CTRACE((tfp, "start_curses putenv %s, %s\n", lines_putenv, cols_putenv));
	}
#endif /* defined(__MVS__) */
#endif /* !(defined(NCURSES) && defined(HAVE_RESIZETERM)) */
	if (!(LYscreen = newterm(NULL,stdout,stdin))) {  /* start curses */
d788 1
a788 1
	    exit_immediately (EXIT_FAILURE);
a789 5
#else
	initscr();
#endif /* HAVE_NEWTERM */
	lynx_called_initscr = TRUE;

a793 11

#ifdef USE_CURSES_PADS
	if (LYuseCursesPads) {
	    LYwin = newpad(LYlines, MAX_COLS);
	    LYshiftWin = 0;
	    LYwideLines = FALSE;
	} else {
	    LYwin = stdscr;
	}
#endif

d795 2
a796 11
#  if HAVE_KEYPAD
	/* Need to switch keypad on before initializing keymaps, otherwise
	   when the keypad is switched on, some keybindings may be overriden. */
	keypad(LYwin,TRUE);
	keypad_on = 1;
#  endif /* HAVE_KEYPAD */

	if (-1 == lynx_initialize_keymaps ()) {
	    endwin();
	    exit (EXIT_FAILURE);
	}
d822 4
a825 9
#if USE_DEFAULT_COLORS
#ifdef EXP_ASSUMED_COLOR
	    /*
	     * Adjust the color mapping table to match the ASSUMED_COLOR
	     * setting in lynx.cfg
	     */
	    if (assume_default_colors(default_fg, default_bg) != OK) {
		default_fg = COLOR_WHITE;
		default_bg = COLOR_BLACK;
d827 1
a827 17
	    if (default_fg >= 0 || default_bg >= 0) {
		unsigned n;
		for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
		    if (default_fg >= 0 && lynx_color_cfg[n].fg < 0)
			lynx_color_cfg[n].fg = default_fg;
		    if (default_bg >= 0 && lynx_color_cfg[n].bg < 0)
			lynx_color_cfg[n].bg = default_bg;
		    CTRACE((tfp, "color_cfg[%d] = %d/%d\n", n,
			    lynx_color_cfg[n].fg,
			    lynx_color_cfg[n].bg));
		}
		lynx_setup_colors();
	    }
#else
	    lynx_default_colors();
#endif /* EXP_ASSUMED_COLOR */
#endif /* USE_DEFAULT_COLORS */
d834 1
d837 1
a840 3
#ifdef WATT32
    _eth_init();
#else
a841 1
#endif /* WATT32 */
d862 1
a862 2
    if (!keypad_on)
	keypad(LYwin,TRUE);
d865 1
a865 1
    lynx_enable_mouse (1);
d872 2
a873 7
#if defined(WIN_EX)
    LYclear();
#endif

#if defined(USE_BLINK) && defined(__EMX__)
    if (term_blink_is_boldbg)		/* Now actually make it so! */
	make_blink_boldbg();
d877 2
a878 2
    CTRACE((tfp, "start_curses: done.\n"));
}  /* end of start_curses() */
a882 2
#ifdef USE_MOUSE
/***********************************************************************/
d884 1
a884 1
#if defined(WIN_EX)
d902 1
a902 2

#if defined(USE_SLANG)
d907 2
a908 1
#if defined(WIN_EX) && defined(PDCURSES)
d915 5
a919 1
#if defined(NCURSES)
a920 1
	/* Compensate for small value of maxclick in ncurses.  */
d930 1
a930 18
	/* Inform ncurses which mouse events we're interested in.
	 * We shouldn't need to include BUTTONn_PRESSED and BUTTONn_RELEASED
	 * events, since ncurses should translate them to click events. - kw
	 * However, if we do not include them, then ncurses effectively
	 * ignores mouseinterval(), thus translates *any* sequence of
	 * press/release to a click, which leads to inconveniences.
	 * We special-case these events in LYStrings.c.
	 */
	mousemask(BUTTON_CTRL | BUTTON_ALT
		  | BUTTON1_PRESSED | BUTTON1_RELEASED
		  | BUTTON1_CLICKED
		  | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
		  | BUTTON2_PRESSED | BUTTON2_RELEASED
		  | BUTTON2_CLICKED
		  | BUTTON3_PRESSED | BUTTON3_RELEASED
		  | BUTTON3_CLICKED
		  | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED,
		  NULL);
d933 2
a934 2
#endif /* NCURSES */
#endif /* WIN_EX and PDCURSES */
d936 1
a936 1
#if defined(PDCURSES)
d938 1
a938 66
	mouse_set(
		BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
#endif
#endif      /* NOT USE_SLANG */

/***********************************************************************/
#endif /* USE_MOUSE */
}

/*
 * SVr4 curses (and ncurses) initialize the terminal I/O to raw mode, and
 * simulate other modes in the library.  This means that when running, it
 * simulates the OCRNL setting.  Normally that is not a problem.  However, when
 * spawning a subprocess (e.g., xli), the subprocess may write to the screen.
 * Fine so far - curses resets the terminal I/O to the normal state on exit.
 * But the subprocess's messages can still be coming to the screen when lynx
 * returns to the screen mode.  This function delays restoring OCRNL until
 * after the first getch() call.
 *
 * The OCRNL setting is controlled by nl()/nonl() of course - but we do not
 * want to give up that optimization since it would be a bit slower.  (Note -
 * slang does not use this optimization; if it did, the same screen glitch
 * would occur).
 *
 * FIXME:  for simplicity, only ncurses is implemented here - the TTY and
 * SET_TTY definitions are ncurses-specific.  The same effect could be done for
 * other curses implementations, since the "cur_term->Nttyb" part is common to
 * SVr4 curses.
 */
PUBLIC void lynx_nl2crlf ARGS1(int, normal GCC_UNUSED)
{
#if defined(NCURSES_VERSION_PATCH) && defined(SET_TTY) && defined(TERMIOS) && defined(ONLCR)
    static TTY saved_tty;
    static int did_save = FALSE;
    static int waiting = FALSE;
    static int can_fix = TRUE;

    if (!did_save) {
	saved_tty = cur_term->Nttyb;
	did_save = TRUE;
#if NCURSES_VERSION_PATCH < 20010529
	/* workaround for optimizer bug with nonl() */
	if ((tigetstr("cud1") != 0 && *tigetstr("cud1") == '\n')
	 || (tigetstr("ind")  != 0 && *tigetstr("ind")  == '\n'))
	    can_fix = FALSE;
#endif
    }
    if (can_fix) {
	if (normal) {
	    if (!waiting) {
		cur_term->Nttyb.c_oflag |= ONLCR;
		waiting = TRUE;
		nonl();
	    }
	} else {
	    if (waiting) {
		cur_term->Nttyb = saved_tty;
		SET_TTY(fileno(stdout), &saved_tty);
		waiting = FALSE;
		nl();
		LYrefresh();
	    }
	}
    }
d940 1
d945 2
a946 6
    if (LYCursesON)
	echo();
#ifdef __DJGPP__
#ifdef WATT32
    _eth_release();
#else
d948 2
a949 3
#endif /* WATT32 */
#endif /* __DJGPP__ */
#if defined(DOSPATH) && !(defined(USE_SLANG) || _WIN_CC)
d958 2
a959 15
	lynx_nl2crlf(TRUE);
	lynx_enable_mouse (0);
#if (!defined(WIN_EX) || defined(__CYGWIN__))	/* @@@@@@ */
	if(LYscreen || lynx_called_initscr) {
	    endwin();	/* stop curses */
	    LYDELSCR();
	}
#endif
    }
#ifdef SH_EX
    {
	int i;
	for (i=0; i <= 3; i++) {
	    fprintf(stdout, "\r\n");
	}
a960 1
#endif
d963 1
a963 1
#endif /* defined(DOSPATH) && !(defined(USE_SLANG) || _WIN_CC) */
d967 1
a967 1
    CTRACE((tfp, "stop_curses: done.\n"));
d986 1
a986 1
	char *,		terminal)
d1016 1
a1016 1
	LYcols = DFT_COLS;
d1031 1
d1048 6
a1053 2
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
d1064 1
a1064 1
	char *,		terminal)
d1069 14
d1084 12
a1095 4
    /*
     *  If the display was not set by a command line option then
     *  see if it is available from the environment .
     */
d1128 1
a1128 1
	LYSleepMsg();
d1140 1
d1142 18
a1159 10
    /*
     *  Account for lossage on the 'sun' terminal type (80x24) Sun text
     *  console driver. It only supports reverse video, but all SGR
     *  sequences produce that same reverse video, and the terminfo
     *  entry lists different SGRs for 'bold' and 'rev'. As a result,
     *  the current link is indistinguishable from all other links.
     *  The workaround here is to disable the 'rev' capability.
     */
    if ((strncmp((CONST char *)ttytype, "sun", 3) == 0)) {
	LYnoVideo(2);
d1161 8
a1168 4
#endif /* HAVE_TTYTYPE */

    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
d1174 1
a1174 1
	char *,		terminal)
d1207 1
a1207 1
    LYaddWAttr(LYwin, a);
d1221 1
a1221 1
    LYsubWAttr(LYwin, a);
a1227 66
/* Use this rather than the 'wprintw()' function to write a blank-padded
 * string to the given window, since someone's asserted that printw doesn't
 * handle 8-bit characters unlike addstr (though more info would be useful).
 *
 * We're blank-filling so that with SVr4 curses, it'll show the background
 * color to a uniform width in the popup-menu.
 */
#ifndef USE_SLANG
PUBLIC void LYpaddstr ARGS3(
	WINDOW *,	the_window,
	int,		width,
	CONST char *,	the_string)
{
    int y, x;
    getyx(the_window, y, x);
    if (width + x >= LYcols)
	width = LYcols - x - 1;
    LYwaddnstr(the_window, the_string, width);
    width -= strlen(the_string);
    while (width-- > 0)
	waddstr(the_window, " ");
}
#endif

PUBLIC WINDOW *LYstartPopup ARGS4(
    int,	top_y,
    int,	left_x,
    int,	height,
    int,	width)
{
    WINDOW *form_window = 0;
#ifdef USE_SLANG
    static WINDOW fake_window;
    SLsmg_fill_region(top_y, left_x - 1, height, width + 4, ' ');
    form_window = &fake_window;
    form_window->top_y  = top_y;
    form_window->left_x = left_x;
    form_window->height = height;
    form_window->width  = width;
#else
    if (!(form_window = newwin(height, width + 4, top_y, left_x - 1)) &&
	!(form_window = newwin(height, 0, top_y, 0))) {
	HTAlert(POPUP_FAILED);
    } else {
	LYsubwindow(form_window);
#  ifdef USE_COLOR_STYLE
	{
	    long b;

	    /* Get a proper value for the attribute */
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_ON);
	    b = getattrs(form_window);
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_OFF);
	    wbkgd(form_window, b | ' ');
	    /* wbkgdset does not make a lot of sense with USE_COLOR_STYLE
	       since it *forces* attributes on all the cells in the window.
	       Undo the change done in LYsubwindow, since we set our styles.
	     */
	    wbkgdset(form_window, (b & ~(A_BOLD|A_BLINK)) | ' ');
	}
#  endif
    }
#endif /* USE_SLANG */
    return form_window;
}

a1257 55
/*
 * Accommodate the different flavors of touchline
 */
PUBLIC void LYtouchline ARGS1(
	int,		row)
{
#if defined(HAVE_WREDRAWLN) && !defined(NCURSES_VERSION)
    wredrawln(LYwin, row, 1);
#else
#if defined(HAVE_TOUCHLINE)
    /* touchline() is not available on VMS before version 7.0, and then only on
     * Alpha, since prior ports of curses were broken.  BSD touchline() has a
     * 4th parameter since it is used internally by touchwin().
     */
#if defined(HAVE_BSD_TOUCHLINE)
    touchline(LYwin, row, 0, COLS);
#else
    touchline(LYwin, row, 1);
#endif
#else
#if !defined(USE_SLANG)
    touchwin(LYwin);
#else
    SLsmg_touch_lines(row, 1);
#endif
#endif
#endif
}

/*
 * There's no guarantee that a library won't temporarily write on its input.
 * Be safe and copy it when we have const-data.
 */
PUBLIC void LYwaddnstr ARGS3(
	WINDOW *,	w,
	CONST char *,	s,
	size_t,		len)
{
#ifdef USE_COLOR_STYLE
    if (TRACE) {
	int y, x;
	LYGetYX(y, x);
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n", y, x, (int) len, s));
    }
#endif
    while (len > 0) {
	char temp[MAX_LINE];
	size_t use = (len >= MAX_LINE) ? MAX_LINE - 1 : len;
	memcpy(temp, s, use);
	temp[use] = 0;
	waddstr(w, temp);
	len -= use;
    }
}

d1321 2
a1322 2
static	unsigned char buffer[20];	/* Input buffer			*/
static	int	in_pos, in_len;		/* For escape sequences		*/
d1325 1
a1325 1
static	short	iochan;			/* TTY I/O channel		*/
d1334 1
a1334 1
	char *,		VerString,
d1654 2
a1655 2
	void *,		sigarr,
	void *,		mecharr)
d1658 2
a1659 2
	void *,		sigarr,
	void *,		mecharr)
d1669 1
a1669 1
	char *,		command)
d1719 1
a1719 1
	char *,		command)
d1734 1
a1734 4
/*
 * Return the physical screen dimensions that we're allowed to use.
 */
PUBLIC int LYscreenHeight NOARGS
d1736 9
a1744 50
    int result = LINES;
    if (result <= 0)
	result = DFT_ROWS;
    return result;
}

PUBLIC int LYscreenWidth NOARGS
{
    int result = COLS;
#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX) /* 1999/08/26 (Thu) 17:53:38 */
    {
	extern int current_codepage;	/* PDCurses lib. */

	if (current_codepage == 932)
	    result--;
    }
#endif
    if (result <= 0)
	result = DFT_COLS;
    return result;
}

/*
 * The functions ifdef'd with USE_CURSES_PADS are implemented that way so we
 * don't break the slang configuration.
 */
PUBLIC void LYclear NOARGS
{
#ifdef USE_CURSES_PADS
    wclear(LYwin);
#else
    clear();
#endif
}

PUBLIC void LYclrtoeol NOARGS
{
#ifdef USE_CURSES_PADS
    wclrtoeol(LYwin);
#else
    clrtoeol();
#endif
}

PUBLIC void LYerase NOARGS
{
#ifdef USE_CURSES_PADS
    werase(LYwin);
#else
    erase();
d1746 2
a1747 41
}

PUBLIC void LYmove ARGS2(int, y, int, x)
{
#ifdef USE_CURSES_PADS
    wmove(LYwin, y, x);
#else
    move(y, x);
#endif
}

PUBLIC void LYrefresh NOARGS
{
#ifdef USE_CURSES_PADS
    if (LYwin != stdscr) {
	/*
	 * Workaround for special case where lynx is prompting for a mailto,
	 * and has a subject line that is wider than the screen.  The
	 * wnoutrefresh() call resets newscr's position to match stdscr's,
	 * which happens to be the window's origin because we were not updating
	 * that, and other stray wmove's in lynx fail because the coordinate
	 * is on/after the right margin.  Force things to look ok here.
	 */
	int y, x;
	getyx(LYwin, y, x);
	if (x >= LYcols) x = LYcols-1;
	wmove(stdscr, y, x);

	wnoutrefresh(stdscr);
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth()-1);
	doupdate();
    } else {
	refresh();
    }
#else
    refresh();
#endif
}

PUBLIC void lynx_force_repaint NOARGS
{
a1752 3
#ifdef SH_EX
    start_reverse();
#endif
a1756 3
#ifdef SH_EX
    stop_reverse();
#endif
d1796 1
a1796 1
    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_OFF);
d1824 3
a1826 3
    stop_underline();
    stop_reverse();
    stop_bold();
d1831 3
a1833 3
    start_bold();
    start_reverse();
    start_underline();
d1859 2
a1860 2
    if (bold_H1 || bold_headers)
	start_bold();
d1865 2
a1866 2
    if (bold_H1 || bold_headers)
	stop_bold();
d1871 1
a1871 1
    start_reverse ();
d1876 1
a1876 1
    stop_reverse ();
d1881 1
a1881 1
    start_bold ();
d1886 1
a1886 1
    stop_bold ();
d1891 3
a1893 3
    stop_underline ();
    stop_reverse ();
    stop_bold ();
a1894 44

/*
 * If LYShowCursor is ON, move the cursor to the left of the current option, so
 * that blind users, who are most likely to have LYShowCursor ON, will have
 * it's string spoken or passed to the braille interface as each option is made
 * current.  Otherwise, move it to the bottom, right column of the screen, to
 * "hide" the cursor as for the main document, and let sighted users rely on
 * the current option's highlighting or color without the distraction of a
 * blinking cursor in the window.  - FM
 */
PUBLIC void LYstowCursor ARGS3(
    WINDOW *,	win,
    int,	row,
    int,	col)
{
#ifdef USE_SLANG
    if (LYShowCursor)
	SLsmg_gotorc(win->top_y + row, win->left_x + col);
    else
	LYHideCursor();
    SLsmg_refresh();
#else
    if (LYShowCursor)
	wmove(win, row, col);
    else
	LYHideCursor();
    wrefresh(win);
#endif /* USE_SLANG  */
}

#if defined(USE_BLINK) && defined(__EMX__) /* Can't put it earler due to BOOLEAN conflict */
#  define BOOLEAN os2BOOLEAN
#  define INCL_VIO
#  include "os2.h"
PRIVATE void make_blink_boldbg NOARGS
{
    VIOINTENSITY buf;		/* VIO windows have it anyway, */
				/* but FS session need a switch */
    buf.cb = sizeof(buf);
    buf.type = 2;		/* VIOINTENSITY request */
    buf.fs = 1;			/* Intensity == boldbg */
    VioSetState(&buf,0);
}
#endif
@

