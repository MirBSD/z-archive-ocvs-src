head	1.12;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.11
	tg-mergefixes-1-branch:1.11.0.4
	tg-mergefixes-1-base:1.11
	MIROS_X:1.11.0.2
	MIROS_X_BASE:1.11
	MIRBSD_XP_MIRPPC:1.10.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.10
	MIRBSD_XP_SPARC:1.10.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.6
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.6.0.6
	MIRBSD_7:1.6.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.6
	MIRBSD_7_DEV:1.6.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2005.01.03.00.46.06;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.20.10.26.31;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.15.18.17.05;	author tg;	state Stab;
branches;
next	1.9;

1.9
date	2004.04.30.16.32.38;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.08.19.49.01;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.18.16.56.32;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.25.17.51.03;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.01.18.49.54;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.31.21.27.57;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.39;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.35;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.29;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.45;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.14;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.39;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.09.57;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.51;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.51.35;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.20.10.10.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.12
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/src/LYrcFile.c,v 1.11 2004/10/20 10:26:31 tg Exp $ */

#include <HTUtils.h>
#include <HTFTP.h>
#include <LYUtils.h>
#include <LYrcFile.h>
#include <LYStrings.h>
#include <LYGlobalDefs.h>
#include <LYCharSets.h>
#include <LYBookmark.h>
#include <LYCookie.h>
#include <LYKeymap.h>
#include <HTMLDTD.h>

#include <LYLeaks.h>

#ifdef FNAMES_8_3
#define FNAME_LYNXRC "lynx.rc"
#else
#define FNAME_LYNXRC ".etc/lynxrc"
#endif /* FNAMES_8_3 */

#define MSG_ENABLE_LYNXRC N_("Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n")
#define putBool(value) ((value) ? "on" : "off")
/* *INDENT-OFF* */
static Config_Enum tbl_DTD_recovery[] = {
    { "true",		TRUE },
    { "false",		FALSE },
    { "on",		TRUE },
    { "off",		FALSE },
    { "sortasgml",	TRUE },
    { "tagsoup",	FALSE },
    { NULL,		-1 },
};

#ifdef DIRED_SUPPORT
static Config_Enum tbl_dir_list_style[] = {
    { "FILES_FIRST",	FILES_FIRST },
    { "DIRECTORIES_FIRST", DIRS_FIRST },
    { "MIXED_STYLE",	MIXED_STYLE },
    { NULL,		MIXED_STYLE },
};
#ifdef LONG_LIST
static Config_Enum tbl_dir_list_order[] = {
    { "ORDER_BY_NAME",	ORDER_BY_NAME },
    { "ORDER_BY_TYPE",	ORDER_BY_TYPE },
    { "ORDER_BY_SIZE",  ORDER_BY_SIZE },
    { "ORDER_BY_DATE",	ORDER_BY_DATE },
    { "ORDER_BY_MODE",	ORDER_BY_MODE },
#ifndef NO_GROUPS
    { "ORDER_BY_USER",	ORDER_BY_USER },
    { "ORDER_BY_GROUP",	ORDER_BY_GROUP },
#endif
    { NULL,		ORDER_BY_NAME },
};
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

static Config_Enum tbl_file_sort[] = {
    { "BY_FILENAME",	FILE_BY_NAME },
    { "BY_TYPE",	FILE_BY_TYPE },
    { "BY_SIZE",	FILE_BY_SIZE },
    { "BY_DATE",	FILE_BY_DATE },
    { NULL,		-1 },
};

Config_Enum tbl_keypad_mode[] = {
    { "FIELDS_ARE_NUMBERED", FIELDS_ARE_NUMBERED },
    { "LINKS_AND_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "LINKS_ARE_NUMBERED", LINKS_ARE_NUMBERED },
    { "LINKS_ARE_NOT_NUMBERED", NUMBERS_AS_ARROWS },
    /* obsolete variations: */
    { "LINKS_AND_FORM_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "NUMBERS_AS_ARROWS", NUMBERS_AS_ARROWS },
    { NULL,		DEFAULT_KEYPAD_MODE }
};

Config_Enum tbl_multi_bookmarks[] = {
    { "OFF",		MBM_OFF },
    { "STANDARD",	MBM_STANDARD },
    { "ON",		MBM_STANDARD },
    { "ADVANCED",	MBM_ADVANCED },
    { NULL,		-1 }
};

/* the names in this table are used as lowercase in HTTP.c */
Config_Enum tbl_preferred_encoding[] = {
    { "none",		encodingNONE },
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    { "gzip",		encodingGZIP },
    { "deflate",	encodingDEFLATE },
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    { "compress",	encodingCOMPRESS },
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    { "bzip2",		encodingBZIP2 },
#endif
    { "all",		encodingALL },
    { NULL,		-1 }
};

Config_Enum tbl_preferred_media[] = {
    { "INTERNAL",	mediaOpt1 },
    { "CONFIGFILE",	mediaOpt2 },
    { "USER",		mediaOpt3 },
    { "SYSTEM",		mediaOpt4 },
    { "ALL",		mediaALL },
    { NULL,		-1 }
};

static Config_Enum tbl_show_colors[] = {
    { "default",	SHOW_COLOR_UNKNOWN },
    { "default",	SHOW_COLOR_OFF },
    { "default",	SHOW_COLOR_ON },
    { "on",		SHOW_COLOR_UNKNOWN },
    { "off",		SHOW_COLOR_UNKNOWN },
    { "never",		SHOW_COLOR_NEVER },
    { "always",		SHOW_COLOR_ALWAYS },
    { NULL,		SHOW_COLOR_UNKNOWN }
};

Config_Enum tbl_transfer_rate[] = {
    { "NONE",		rateOFF },
    { "KB",		rateKB },
    { "TRUE",		rateKB },
    { "BYTES",		rateBYTES },
    { "FALSE",		rateBYTES },
#ifdef USE_READPROGRESS
    { "KB,ETA",		rateEtaKB },
    { "BYTES,ETA",	rateEtaBYTES },
#endif
    { NULL,		-1 },
};

Config_Enum tbl_user_mode[] = {
    { "ADVANCED",	ADVANCED_MODE },
    { "INTERMEDIATE",	INTERMEDIATE_MODE },
    { "NOVICE",		NOVICE_MODE },
    { NULL,		NOVICE_MODE }
};

static Config_Enum tbl_visited_links[] = {
    { "FIRST_REVERSED",	VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE },
    { "FIRST",		VISITED_LINKS_AS_FIRST_V },
    { "TREE",		VISITED_LINKS_AS_TREE    },
    { "LAST_REVERSED",	VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE },
    { "LAST",		VISITED_LINKS_AS_LATEST  },
    { NULL,		DEFAULT_VISITED_LINKS }
};

Config_Enum tbl_force_prompt[] = {
    { "prompt",		FORCE_PROMPT_DFT	},
    { "yes",		FORCE_PROMPT_YES	},
    { "no",		FORCE_PROMPT_NO		},
    { NULL,		-1			}
};
/* *INDENT-ON* */

static BOOL getBool(char *src)
{
    return (BOOL) (!strncasecomp(src, "on", 2) || !strncasecomp(src, "true", 4));
}

const char *LYputEnum(Config_Enum * table, int value)
{
    while (table->name != 0) {
	if (table->value == value) {
	    return table->name;
	}
	table++;
    }
    return "?";
}

BOOL LYgetEnum(Config_Enum * table, char *name,
	       int *result)
{
    Config_Enum *found = 0;
    unsigned len = strlen(name);
    int match = 0;

    if (len != 0) {
	while (table->name != 0) {
	    if (!strncasecomp(table->name, name, len)) {
		found = table;
		if (!strcasecomp(table->name, name)) {
		    match = 1;
		    break;
		}
		++match;
	    }
	    table++;
	}
	if (match == 1) {	/* if unambiguous */
	    *result = found->value;
	    return TRUE;
	}
    }
    return FALSE;		/* no match */
}

/* these are for data that are normally not read/written from .lynxrc */
#define PARSE_SET(n,v,h)   {n,    1, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define PARSE_ARY(n,v,t,h) {n,    1, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define PARSE_ENU(n,v,t,h) {n,    1, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define PARSE_LIS(n,v,h)   {n,    1, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_STR(n,v,h)   {n,    1, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_FUN(n,v,w,h) {n,    1, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define PARSE_MBM(n,h)     {n,    1, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

/* these are for data that are optionally read/written from .lynxrc */
#define MAYBE_SET(n,v,h)   {n,    0, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define MAYBE_ARY(n,v,t,h) {n,    0, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define MAYBE_ENU(n,v,t,h) {n,    0, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define MAYBE_LIS(n,v,h)   {n,    0, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_STR(n,v,h)   {n,    0, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_FUN(n,v,w,h) {n,    0, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define MAYBE_MBM(n,h)     {n,    0, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

#define PARSE_NIL          {NULL, 1, CONF_NIL,   UNION_DEF(0), 0, 0, 0, 0}

typedef enum {
    CONF_NIL = 0
    ,CONF_ARRAY
    ,CONF_BOOL
    ,CONF_FUN
    ,CONF_INT
    ,CONF_ENUM
    ,CONF_LIS
    ,CONF_MBM
    ,CONF_STR
} Conf_Types;

typedef struct config_type {
    const char *name;
    int enabled;		/* see lynx.cfg ENABLE_LYNXRC "off" lines */
    Conf_Types type;
      ParseData;
    const char **strings;
    Config_Enum *table;
    void (*write_it) (FILE *fp, struct config_type *);
    const char *note;
} Config_Type;

static int get_assume_charset(char *value)
{
    int i;

    for (i = 0; i < LYNumCharsets; ++i) {
	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
	    UCLYhndl_for_unspec = i;
	    break;
	}
    }
    return 0;
}

static void put_assume_charset(FILE *fp, struct config_type *tbl)
{
    int i;

    for (i = 0; i < LYNumCharsets; ++i)
	fprintf(fp, "#    %s\n", LYCharSet_UC[i].MIMEname);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
}

static int get_display_charset(char *value)
{
    int i = 0;

    i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */
    if (i >= 0)
	current_char_set = i;
    return 0;
}

static void put_display_charset(FILE *fp, struct config_type *tbl)
{
    int i;

    for (i = 0; LYchar_set_names[i]; i++)
	fprintf(fp, "#    %s\n", LYchar_set_names[i]);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYchar_set_names[current_char_set]);
}

static int get_editor(char *value)
{
    if (!system_editor)
	StrAllocCopy(editor, value);
    return 0;
}

static void put_editor(FILE *fp, struct config_type *tbl)
{
    fprintf(fp, "%s=%s\n\n", tbl->name, NonNull(editor));
}

int get_tagsoup(char *value)
{
    int found = Old_DTD;

    if (LYgetEnum(tbl_DTD_recovery, value, &found)
	&& Old_DTD != found) {
	Old_DTD = found;
	HTSwitchDTD(!Old_DTD);
    }
    return 0;
}

static void put_tagsoup(FILE *fp, struct config_type *tbl)
{
    fprintf(fp, "%s=%s\n\n", tbl->name, LYputEnum(tbl_DTD_recovery, Old_DTD));
}

/* This table is searched ignoring case */
/* *INDENT-OFF* */
static Config_Type Config_Table [] =
{
    PARSE_SET(RC_ACCEPT_ALL_COOKIES,    LYAcceptAllCookies, N_("\
accept_all_cookies allows the user to tell Lynx to automatically\n\
accept all cookies if desired.  The default is \"FALSE\" which will\n\
prompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\n\
all cookies.\n\
")),
    MAYBE_FUN(RC_ASSUME_CHARSET,        get_assume_charset, put_assume_charset, MSG_ENABLE_LYNXRC),
    PARSE_STR(RC_ANONFTP_PASSWORD,      anonftp_password, N_("\
anonftp_password allows the user to tell Lynx to use the personal\n\
email address as the password for anonymous ftp.  If no value is given,\n\
Lynx will use the personal email address.  Set anonftp_password\n\
to a different value if you choose.\n\
")),
    PARSE_STR(RC_BOOKMARK_FILE,         bookmark_page,     N_("\
bookmark_file specifies the name and location of the default bookmark\n\
file into which the user can paste links for easy access at a later\n\
date.\n\
")),
    PARSE_SET(RC_CASE_SENSITIVE_SEARCHING, case_sensitive, N_("\
If case_sensitive_searching is \"on\" then when the user invokes a search\n\
using the 's' or '/' keys, the search performed will be case sensitive\n\
instead of case INsensitive.  The default is usually \"off\".\n\
")),
    PARSE_FUN(RC_CHARACTER_SET,         get_display_charset, put_display_charset, N_("\
The character_set definition controls the representation of 8 bit\n\
characters for your terminal.  If 8 bit characters do not show up\n\
correctly on your screen you may try changing to a different 8 bit\n\
set or using the 7 bit character approximations.\n\
Current valid characters sets are:\n\
")),
    PARSE_LIS(RC_COOKIE_ACCEPT_DOMAINS, LYCookieAcceptDomains, N_("\
cookie_accept_domains and cookie_reject_domains are comma-delimited\n\
lists of domains from which Lynx should automatically accept or reject\n\
all cookies.  If a domain is specified in both options, rejection will\n\
take precedence.  The accept_all_cookies parameter will override any\n\
settings made here.\n\
")),
#ifdef USE_PERSISTENT_COOKIES
    PARSE_STR(RC_COOKIE_FILE,	        LYCookieFile, N_("\
cookie_file specifies the file from which to read persistent cookies.\n\
The default is ~/.etc/cookies.txt.\n\
")),
#endif
    PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieLooseCheckDomains, N_("\
cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\n\
cookie_query_invalid_domains are comma-delimited lists of which domains\n\
should be subjected to varying degrees of validity checking.  If a\n\
domain is set to strict checking, strict conformance to RFC2109 will\n\
be applied.  A domain with loose checking will be allowed to set cookies\n\
with an invalid path or domain attribute.  All domains will default to\n\
querying the user for an invalid path or domain.\n\
")),
    PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieQueryCheckDomains, NULL),
    PARSE_LIS(RC_COOKIE_REJECT_DOMAINS, LYCookieRejectDomains, NULL),
    PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieStrictCheckDomains, NULL),
#ifdef DIRED_SUPPORT
#ifdef LONG_LIST
    PARSE_ENU(RC_DIR_LIST_ORDER,        dir_list_order,     tbl_dir_list_order, N_("\
dir_list_order specifies the directory list order under DIRED_SUPPORT\n\
(if implemented).  The default is \"ORDER_BY_NAME\"\n\
")),
#endif
    PARSE_ENU(RC_DIR_LIST_STYLE,        dir_list_style,     tbl_dir_list_style, N_("\
dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
(if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
files and directories together.  \"FILES_FIRST\" lists files first and\n\
\"DIRECTORIES_FIRST\" lists directories first.\n\
")),
#endif
    MAYBE_STR(RC_DISPLAY,               x_display,          MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_EMACS_KEYS,            emacs_keys, N_("\
If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
  ^N = down    ^P = up\n\
  ^B = left    ^F = right\n\
will be enabled.\n\
")),
    PARSE_FUN(RC_FILE_EDITOR,           get_editor,         put_editor, N_("\
file_editor specifies the editor to be invoked when editing local files\n\
or sending mail.  If no editor is specified, then file editing is disabled\n\
unless it is activated from the command line, and the built-in line editor\n\
will be used for sending mail.\n\
")),
    PARSE_ENU(RC_FILE_SORTING_METHOD,   HTfileSortMethod,   tbl_file_sort, N_("\
The file_sorting_method specifies which value to sort on when viewing\n\
file lists such as FTP directories.  The options are:\n\
   BY_FILENAME -- sorts on the name of the file\n\
   BY_TYPE     -- sorts on the type of the file\n\
   BY_SIZE     -- sorts on the size of the file\n\
   BY_DATE     -- sorts on the date of the file\n\
")),
    MAYBE_ENU(RC_FORCE_COOKIE_PROMPT,   cookie_noprompt,    tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#ifdef USE_SSL
    MAYBE_ENU(RC_FORCE_SSL_PROMPT,      ssl_noprompt,       tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#endif
#ifdef EXP_KEYBOARD_LAYOUT
    PARSE_ARY(RC_KBLAYOUT,              current_layout,     LYKbLayoutNames, NULL),
#endif
    PARSE_ENU(RC_KEYPAD_MODE,           keypad_mode,        tbl_keypad_mode, NULL),
    PARSE_ARY(RC_LINEEDIT_MODE,         current_lineedit,   LYLineeditNames, N_("\
lineedit_mode specifies the key binding used for inputting strings in\n\
prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
the following control characters are used for moving and deleting:\n\
\n\
             Prev  Next       Enter = Accept input\n\
   Move char: <-    ->        ^G    = Cancel input\n\
   Move word: ^P    ^N        ^U    = Erase line\n\
 Delete char: ^H    ^R        ^A    = Beginning of line\n\
 Delete word: ^B    ^F        ^E    = End of line\n\
\n\
Current lineedit modes are:\n\
")),
#ifdef EXP_LOCALE_CHARSET
    MAYBE_SET(RC_LOCALE_CHARSET,      LYLocaleCharset,        MSG_ENABLE_LYNXRC),
#endif
    MAYBE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts, MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images, MSG_ENABLE_LYNXRC),
    PARSE_MBM(RC_MULTI_BOOKMARK, N_("\
The following allow you to define sub-bookmark files and descriptions.\n\
The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
Up to 26 bookmark files (for the English capital letters) are allowed.\n\
We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n\
")),
    PARSE_STR(RC_PERSONAL_MAIL_ADDRESS, personal_mail_address, N_("\
personal_mail_address specifies your personal mail address.  The\n\
address will be sent during HTTP file transfers for authorization and\n\
logging purposes, and for mailed comments.\n\
If you do not want this information given out, set the NO_FROM_HEADER\n\
to TRUE in lynx.cfg, or use the -nofrom command line switch.  You also\n\
could leave this field blank, but then you won't have it included in\n\
your mailed comments.\n\
")),
    PARSE_STR(RC_PREFERRED_CHARSET,     pref_charset, N_("\
preferred_charset specifies the character set in MIME notation (e.g.,\n\
ISO-8859-2, ISO-8859-5) which Lynx will indicate you prefer in requests\n\
to http servers using an Accept-Charset header.  The value should NOT\n\
include ISO-8859-1 or US-ASCII, since those values are always assumed\n\
by default.  May be a comma-separated list.\n\
If a file in that character set is available, the server will send it.\n\
If no Accept-Charset header is present, the default is that any\n\
character set is acceptable.  If an Accept-Charset header is present,\n\
and if the server cannot send a response which is acceptable\n\
according to the Accept-Charset header, then the server SHOULD send\n\
an error response, though the sending of an unacceptable response\n\
is also allowed.\n\
")),
    MAYBE_ENU(RC_PREFERRED_ENCODING,    LYAcceptEncoding,   tbl_preferred_encoding,
	      MSG_ENABLE_LYNXRC),
    PARSE_STR(RC_PREFERRED_LANGUAGE,    language, N_("\
preferred_language specifies the language in MIME notation (e.g., en,\n\
fr, may be a comma-separated list in decreasing preference)\n\
which Lynx will indicate you prefer in requests to http servers.\n\
If a file in that language is available, the server will send it.\n\
Otherwise, the server will send the file in its default language.\n\
")),
    MAYBE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia,      tbl_preferred_media,
	      MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_RAW_MODE,              LYRawMode,          MSG_ENABLE_LYNXRC),
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PARSE_SET(RC_RUN_ALL_EXECUTION_LINKS, local_exec, N_("\
If run_all_execution_links is set \"on\" then all local execution links\n\
will be executed when they are selected.\n\
\n\
WARNING - This is potentially VERY dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
    PARSE_SET(RC_RUN_EXECUTION_LINKS_LOCAL, local_exec_on_local_files, N_("\
If run_execution_links_on_local_files is set \"on\" then all local\n\
execution links that are found in LOCAL files will be executed when they\n\
are selected.  This is different from run_all_execution_links in that\n\
only files that reside on the local system will have execution link\n\
permissions.\n\
\n\
WARNING - This is potentially dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
#endif
#ifdef USE_SCROLLBAR
    MAYBE_SET(RC_SCROLLBAR,             LYShowScrollbar, MSG_ENABLE_LYNXRC),
#endif
    PARSE_SET(RC_SELECT_POPUPS,         LYSelectPopups, N_("\
select_popups specifies whether the OPTIONs in a SELECT block which\n\
lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
present in the SELECT start tag, Lynx always will create a vertical list\n\
of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
as the default while a value of \"off\" will set use of radio boxes.\n\
The default can be overridden via the -popup command line toggle.\n\
")),
    MAYBE_SET(RC_SET_COOKIES,           LYSetCookies,      MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_SHOW_COLOR,            LYrcShowColor,     tbl_show_colors, N_("\
show_color specifies how to set the color mode at startup.  A value of\n\
\"never\" will force color mode off (treat the terminal as monochrome)\n\
at startup even if the terminal appears to be color capable.  A value of\n\
\"always\" will force color mode on even if the terminal appears to be\n\
monochrome, if this is supported by the library used to build lynx.\n\
A value of \"default\" will yield the behavior of assuming\n\
a monochrome terminal unless color capability is inferred at startup\n\
based on the terminal type, or the -color command line switch is used, or\n\
the COLORTERM environment variable is set.  The default behavior always is\n\
used in anonymous accounts or if the \"option_save\" restriction is set.\n\
The effect of the saved value can be overridden via\n\
the -color and -nocolor command line switches.\n\
The mode set at startup can be changed via the \"show color\" option in\n\
the 'o'ptions menu.  If the option settings are saved, the \"on\" and\n\
\"off\" \"show color\" settings will be treated as \"default\".\n\
")),
    PARSE_SET(RC_SHOW_CURSOR,           LYShowCursor, N_("\
show_cursor specifies whether to 'hide' the cursor to the right (and\n\
bottom, if possible) of the screen, or to place it to the left of the\n\
current link in documents, or current option in select popup windows.\n\
Positioning the cursor to the left of the current link or option is\n\
helpful for speech or braille interfaces, and when the terminal is\n\
one which does not distinguish the current link based on highlighting\n\
or color.  A value of \"on\" will set positioning to the left as the\n\
default while a value of \"off\" will set 'hiding' of the cursor.\n\
The default can be overridden via the -show_cursor command line toggle.\n\
")),
    PARSE_SET(RC_SHOW_DOTFILES,         show_dotfiles, N_("\
show_dotfiles specifies that the directory listing should include\n\
\"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
restricted via a command line switch.  If display of hidden files\n\
is disabled, creation of such files via Lynx also is disabled.\n\
")),
#ifdef USE_READPROGRESS
    MAYBE_ENU(RC_SHOW_KB_RATE,          LYTransferRate,    tbl_transfer_rate,
	      MSG_ENABLE_LYNXRC),
#endif
    PARSE_ENU(RC_SUB_BOOKMARKS,         LYMultiBookmarks,  tbl_multi_bookmarks, N_("\
If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
been defined (see below), then all bookmark operations will first\n\
prompt the user to select an active sub-bookmark file.  If the default\n\
Lynx bookmark_file is defined (see above), it will be used as the\n\
default selection.  When this option is set to \"advanced\", and the\n\
user mode is advanced, the 'v'iew bookmark command will invoke a\n\
statusline prompt instead of the menu seen in novice and intermediate\n\
user modes.  When this option is set to \"standard\", the menu will be\n\
presented regardless of user mode.\n\
")),
    MAYBE_FUN(RC_TAGSOUP,               get_tagsoup,        put_tagsoup,
              MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_UNDERLINE_LINKS,       LYUnderlineLinks,   MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_USER_MODE,             user_mode,          tbl_user_mode, N_("\
user_mode specifies the users level of knowledge with Lynx.  The\n\
default is \"NOVICE\" which displays two extra lines of help at the\n\
bottom of the screen to aid the user in learning the basic Lynx\n\
commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
bottom of the screen.\n\
")),
    MAYBE_STR(RC_USERAGENT,             LYUserAgent,        MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_VERBOSE_IMAGES,        verbose_img, N_("\
If verbose_images is \"on\", lynx will print the name of the image\n\
source file in place of [INLINE], [LINK] or [IMAGE]\n\
See also VERBOSE_IMAGES in lynx.cfg\n\
")),
    PARSE_SET(RC_VI_KEYS,               vi_keys, N_("\
If vi_keys is set to \"on\", then the normal VI movement keys:\n\
  j = down    k = up\n\
  h = left    l = right\n\
will be enabled.  These keys are only lower case.\n\
Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
and the keymap display, respectively.\n\
")),
    PARSE_ENU(RC_VISITED_LINKS,         Visited_Links_As,   tbl_visited_links, N_("\
The visited_links setting controls how Lynx organizes the information\n\
in the Visited Links Page.\n\
")),

    PARSE_NIL
};
/* *INDENT-ON* */

static Config_Type *lookup_config(const char *name)
{
    Config_Type *tbl = Config_Table;
    char ch = (char) TOUPPER(*name);

    while (tbl->name != 0) {
	if (tbl->enabled) {
	    char ch1 = tbl->name[0];

	    if ((ch == TOUPPER(ch1))
		&& (0 == strcasecomp(name, tbl->name)))
		break;
	}

	tbl++;
    }
    return tbl;
}

/* Read and process user options.  If the passed-in fp is NULL, open the
 * regular user defaults file for reading, otherwise use fp which has to be a
 * file open for reading.  - kw
 */
void read_rc(FILE *fp)
{
    char *buffer = NULL;
    char rcfile[LY_MAXPATH];
    char MBM_line[256];
    int n;

    if (!fp) {
	/*
	 * Make an RC file name, open it for reading.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);
	if ((fp = fopen(rcfile, TXT_R)) == NULL) {
	    return;
	}
	CTRACE((tfp, "read_rc opened %s\n", rcfile));
    } else {
	CTRACE((tfp, "read_rc used passed-in stream\n"));
    }

    /*
     * Process the entries.
     */
    while (LYSafeGets(&buffer, fp) != NULL) {
	char *name, *value, *notes;
	Config_Type *tbl;
	ParseUnionPtr q;

	/* Most lines in the config file are comment lines.  Weed them out
	 * now.  Also, leading whitespace is ok, so trim it.
	 */
	LYTrimTrailing(buffer);
	name = LYSkipBlanks(buffer);
	if (ispunct(UCH(*name)) || *name == '\0')
	    continue;

	/*
	 * Parse the "name=value" strings.
	 */
	if ((value = strchr(name, '=')) == 0) {
	    CTRACE((tfp, "LYrcFile: missing '=' %s\n", name));
	    continue;
	}
	*value++ = '\0';
	LYTrimTrailing(name);
	value = LYSkipBlanks(value);
	CTRACE2(TRACE_CFG, (tfp, "LYrcFile %s:%s\n", name, value));

	tbl = lookup_config(name);
	if (tbl->name == 0) {
	    const char *special = RC_MULTI_BOOKMARK;

	    if (!strncasecomp(name, special, strlen(special))) {
		tbl = lookup_config(special);
	    }
	    /* lynx ignores unknown keywords */
	    if (tbl->name == 0) {
		CTRACE((tfp, "LYrcFile: ignored %s=%s\n", name, value));
		continue;
	    }
	}

	q = ParseUnionOf(tbl);
	switch (tbl->type) {
	case CONF_BOOL:
	    if (q->set_value != 0)
		*(q->set_value) = getBool(value);
	    break;

	case CONF_FUN:
	    if (q->fun_value != 0)
		(*(q->fun_value)) (value);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n) {
		if (!strcasecomp(value, tbl->strings[n])) {
		    *(q->int_value) = n;
		    break;
		}
	    }
	    break;

	case CONF_ENUM:
	    if (tbl->table != 0)
		LYgetEnum(tbl->table, value, q->int_value);
	    break;

	case CONF_INT:
	    if (q->int_value != 0) {
		int ival;

		if (1 == sscanf(value, "%d", &ival))
		    *(q->int_value) = ival;
	    }
	    break;

	case CONF_LIS:
	    if (q->str_value != 0) {
		if (*(q->str_value) != NULL)
		    StrAllocCat(*(q->str_value), ",");
		StrAllocCat(*(q->str_value), value);
	    }
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		sprintf(MBM_line, "multi_bookmark%c", LYindex2MBM(n));

		if (!strcasecomp(name, MBM_line)) {
		    if ((notes = strchr(value, ',')) != 0) {
			*notes++ = '\0';
			LYTrimTrailing(value);
			notes = LYSkipBlanks(notes);
		    } else {
			notes = value + strlen(value);
		    }
		    StrAllocCopy(MBM_A_subbookmark[n], value);
		    StrAllocCopy(MBM_A_subdescript[n], notes);
		    break;
		}
	    }
	    break;

	case CONF_STR:
	    if (q->str_value != 0)
		StrAllocCopy(*(q->str_value), value);
	    break;

	case CONF_NIL:
	    break;
	}
    }

    LYCloseInput(fp);
    LYConfigCookies();		/* update cookie settings, if any */

#if defined(USE_SLANG) || defined(COLOR_CURSES)
    /*
     * We may override the commandline "-color" option with the .lynxrc file
     */
    switch (LYrcShowColor) {
    case SHOW_COLOR_ALWAYS:
	if (LYShowColor != SHOW_COLOR_NEVER)
	    LYShowColor = SHOW_COLOR_ALWAYS;
	break;
    case SHOW_COLOR_NEVER:
	if (LYShowColor == SHOW_COLOR_ON)
	    LYShowColor = SHOW_COLOR_OFF;
	break;
    default:
	/* don't override */
	break;
    }
#endif
    set_default_bookmark_page(bookmark_page);
}

/*
 * Write a set of comments.  Doing it this way avoids preprocessor problems
 * with the leading '#', makes it simpler to use gettext.
 */
static void write_list(FILE *fp, const char *list)
{
    int first = TRUE;

    while (*list != 0) {
	int ch = *list++;

	if (ch == '\n') {
	    first = TRUE;
	} else {
	    if (first) {
		fputs("# ", fp);
		first = FALSE;
	    }
	}
	fputc(ch, fp);
    }
}

/*
 * This is too long for some compilers.
 */
static void explain_keypad_mode(FILE *fp)
{
    write_list(fp, gettext("\
If keypad_mode is set to \"NUMBERS_AS_ARROWS\", then the numbers on\n\
your keypad when the numlock is on will act as arrow keys:\n\
            8 = Up Arrow\n\
  4 = Left Arrow    6 = Right Arrow\n\
            2 = Down Arrow\n\
and the corresponding keyboard numbers will act as arrow keys,\n\
regardless of whether numlock is on.\n\
"));
    write_list(fp, gettext("\
If keypad_mode is set to \"LINKS_ARE_NUMBERED\", then numbers will\n\
appear next to each link and numbers are used to select links.\n\
"));
    write_list(fp, gettext("\
If keypad_mode is set to \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\", then\n\
numbers will appear next to each link and visible form input field.\n\
Numbers are used to select links, or to move the \"current link\" to a\n\
form input field or button.  In addition, options in popup menus are\n\
indexed so that the user may type an option number to select an option in\n\
a popup menu, even if the option isn't visible on the screen.  Reference\n\
lists and output from the list command also enumerate form inputs.\n\
"));
    write_list(fp, gettext("\
NOTE: Some fixed format documents may look disfigured when\n\
\"LINKS_ARE_NUMBERED\" or \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\" are\n\
enabled.\n\
"));
}

/* Save user options.  If the passed-in fp is NULL, open the regular user
 * defaults file for writing, otherwise use fp which has to be a temp file open
 * for writing.  - kw
 */
int save_rc(FILE *fp)
{
    Config_Type *tbl = Config_Table;
    char rcfile[LY_MAXPATH];
    BOOLEAN is_tempfile = (BOOL) (fp != NULL);
    int n;

    if (!fp) {
	/*
	 * Make a name.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

	/*
	 * Open the file for write.
	 */
	if ((fp = LYNewTxtFile(rcfile)) == NULL) {
	    return FALSE;
	}
    }

    write_list(fp, gettext("\
Lynx User Defaults File\n\
\n\
This file contains options saved from the Lynx Options Screen (normally\n\
with the '>' key).  There is normally no need to edit this file manually,\n\
since the defaults here can be controlled from the Options Screen, and the\n\
next time options are saved from the Options Screen this file will be\n\
completely rewritten.  You have been warned...\n\
If you are looking for the general configuration file - it is normally\n\
called lynx.cfg, and it has different content and a different format.\n\
It is not this file.\n\
"));
    fprintf(fp, "\n");

    while (tbl->name != 0) {
	ParseUnionPtr q = ParseUnionOf(tbl);

	if (!tbl->enabled) {
	    tbl++;
	    continue;
	}
	if (tbl->note != NULL) {
	    write_list(fp, gettext(tbl->note));
	} else if (tbl->table == tbl_keypad_mode) {
	    explain_keypad_mode(fp);
	}

	switch (tbl->type) {
	case CONF_BOOL:
	    fprintf(fp, "%s=%s\n\n", tbl->name, putBool(*(q->set_value)));
	    break;

	case CONF_FUN:
	    if (tbl->write_it != 0)
		tbl->write_it(fp, tbl);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n)
		fprintf(fp, "#    %s\n", tbl->strings[n]);
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    tbl->strings[*(q->int_value)]);
	    break;

	case CONF_ENUM:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    LYputEnum(tbl->table, *(q->int_value)));
	    break;

	case CONF_INT:
	    fprintf(fp, "%s=%d\n\n", tbl->name, *(q->int_value));
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		fprintf(fp, "multi_bookmark%c=", LYindex2MBM(n));

		fprintf(fp, "%s", NonNull(MBM_A_subbookmark[n]));
		if (MBM_A_subdescript[n] != 0
		    && *MBM_A_subdescript[n] != 0)
		    fprintf(fp, ",%s", MBM_A_subdescript[n]);
		fprintf(fp, "\n");
	    }
	    fprintf(fp, "\n");
	    break;

	case CONF_LIS:
	    /* FALLTHRU */
	case CONF_STR:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    (q->str_value != 0 && *(q->str_value) != 0)
		    ? *(q->str_value)
		    : "");
	    break;

	case CONF_NIL:
	    break;
	}
	tbl++;
    }

    /*
     * Close the RC file.
     */
    if (is_tempfile) {
	LYCloseTempFP(fp);
    } else {
	LYCloseOutput(fp);
	HTSYS_purge(rcfile);
    }

    return TRUE;
}

/*
 * Returns true if the given name would be saved in .lynxrc
 */
BOOL will_save_rc(const char *name)
{
    Config_Type *tbl = lookup_config(name);

    return tbl->name != 0;
}

int enable_lynxrc(char *value)
{
    Config_Type *tbl;
    char *colon = strchr(value, ':');

    if (colon != 0) {
	*colon++ = 0;
	LYTrimLeading(value);
	LYTrimTrailing(value);

	for (tbl = Config_Table; tbl->name != 0; tbl++) {
	    if (!strcasecomp(value, tbl->name)) {
		tbl->enabled = getBool(colon);
		CTRACE((tfp, "enable_lynxrc(%s) %s\n", value, putBool(tbl->enabled)));
		break;
	    }
	}
    }
    return 0;
}
@


1.11
log
@automatic merge
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYrcFile.c,v 1.10 2004/07/15 18:17:05 tg Stab $ */
d221 1
a221 1
#define PARSE_NIL          {NULL, 1, 0,          UNION_DEF(0), 0, 0, 0, 0}
d224 1
a224 1
    CONF_UNSPECIFIED = 0
d240 1
a240 1
    char **strings;
d243 1
a243 1
    char *note;
d327 6
d603 1
a603 1
static Config_Type *lookup_config(char *name)
d676 1
a676 1
	    char *special = RC_MULTI_BOOKMARK;
d755 1
a755 1
	case CONF_UNSPECIFIED:
d788 1
a788 1
static void write_list(FILE *fp, char *list)
d941 1
a941 1
	case CONF_UNSPECIFIED:
d963 1
a963 1
BOOL will_save_rc(char *name)
@


1.10
log
@automatic merge of lynx-current
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYrcFile.c,v 1.9 2004/04/30 16:32:38 tg Exp $ */
d91 1
@


1.9
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYrcFile.c,v 1.8 2004/02/08 19:49:01 tg Exp $ */
d25 2
a26 2

Config_Enum tbl_DTD_recovery[] = {
d86 25
d157 1
d159 1
a159 1
static BOOL getBool (char * src)
d164 1
a164 3
const char *LYputEnum (
    Config_Enum *	table,
    int		value)
d175 2
a176 4
BOOL LYgetEnum (
    Config_Enum *	table,
    char *		name,
    int *		result)
d234 1
a234 2
typedef struct config_type
{
d238 1
a238 1
    ParseData;
d241 1
a241 1
    void (*write_it) (FILE * fp, struct config_type *);
d245 1
a245 1
static int get_assume_charset (char * value)
d250 1
a250 1
    	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
d258 1
a258 1
static void put_assume_charset (FILE * fp, struct config_type * tbl)
d267 1
a267 1
static int get_display_charset (char * value)
d271 1
a271 1
    i = UCGetLYhndl_byAnyName(value); /* by MIME or full name */
d277 1
a277 1
static void put_display_charset (FILE * fp, struct config_type * tbl)
d286 1
a286 1
static int get_editor (char * value)
d293 1
a293 1
static void put_editor (FILE * fp, struct config_type * tbl)
d298 1
a298 1
int get_tagsoup (char * value)
d303 1
a303 1
     && Old_DTD != found) {
d310 1
a310 1
static void put_tagsoup (FILE * fp, struct config_type * tbl)
d316 1
d460 2
d469 2
d594 1
d596 1
a596 2
static Config_Type *lookup_config (
	char *		name)
d606 1
a606 1
		&& (0 == strcasecomp (name, tbl->name)))
d615 3
a617 4
/*  Read and process user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for reading, otherwise use fp which has to be a file open for
 *  reading. - kw
d619 1
a619 1
void read_rc (FILE * fp)
d624 1
a624 1
    int  n;
d628 1
a628 1
	 *  Make an RC file name, open it for reading.
d640 1
a640 1
     *  Process the entries.
d670 1
d685 1
a685 1
		*(q->set_value) = getBool (value);
d710 2
a711 1
		if (1 == sscanf (value, "%d", &ival))
d754 1
a754 1
    LYConfigCookies();	/* update cookie settings, if any */
d781 1
a781 3
static void write_list (
    	FILE *		fp,
	char *		list)
d784 1
d787 1
d803 1
a803 1
static void explain_keypad_mode (FILE * fp)
d834 3
a836 4
/*  Save user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for writing, otherwise use fp which has to be a temp file open for
 *  writing. - kw
d838 1
a838 1
int save_rc (FILE * fp)
d847 1
a847 1
	 *  Make a name.
d852 1
a852 1
	 *  Open the file for write.
d879 2
a880 1
	} if (tbl->note != NULL) {
d918 1
a918 1
		 && *MBM_A_subdescript[n] != 0)
d929 3
a931 3
			(q->str_value != 0 && *(q->str_value) != 0)
			    ? *(q->str_value)
			    : "");
d941 1
a941 1
     *  Close the RC file.
d956 1
a956 1
BOOL will_save_rc (char * name)
d959 1
d963 1
a963 2
int enable_lynxrc (
	char *		value)
@


1.8
log
@* bump to 0x079D (a bit late for tiff, but hey)
* sync lists
* regenerate configure files
* remove MirLibtool, go back to gcc3 libtool :-(
* fix for $stuff
* remove dupes (libz, etc.) and unused (libintl, getopt)
* update lynx
* update texinfo.tex
etc.

XXX borked commit, eleventh try
@
text
@d1 1
a1 1
/* $MirBSD: LYrcFile.c,v 1.7 2004/01/18 16:56:32 tg Exp $ */
d26 1
a26 1
PUBLIC Config_Enum tbl_DTD_recovery[] = {
d37 1
a37 1
PRIVATE Config_Enum tbl_dir_list_style[] = {
d44 1
a44 1
PRIVATE Config_Enum tbl_dir_list_order[] = {
d59 1
a59 1
PRIVATE Config_Enum tbl_file_sort[] = {
d67 1
a67 1
PUBLIC Config_Enum tbl_keypad_mode[] = {
d78 1
a78 1
PUBLIC Config_Enum tbl_multi_bookmarks[] = {
d86 1
a86 1
PRIVATE Config_Enum tbl_show_colors[] = {
d97 1
a97 1
PUBLIC Config_Enum tbl_transfer_rate[] = {
d110 1
a110 1
PUBLIC Config_Enum tbl_user_mode[] = {
d117 1
a117 1
PRIVATE Config_Enum tbl_visited_links[] = {
d126 1
a126 1
PUBLIC Config_Enum tbl_force_prompt[] = {
d133 1
a133 1
PRIVATE BOOL getBool ARGS1(char *, src)
d138 3
a140 3
PUBLIC CONST char *LYputEnum ARGS2(
    Config_Enum *,	table,
    int,		value)
d151 4
a154 4
PUBLIC BOOL LYgetEnum ARGS3(
    Config_Enum *,	table,
    char *,		name,
    int *,		result)
d214 1
a214 1
    CONST char *name;
d220 1
a220 1
    void (*write_it) PARAMS((FILE * fp, struct config_type *));
d224 1
a224 1
PRIVATE int get_assume_charset ARGS1(char *, value)
d237 1
a237 1
PRIVATE void put_assume_charset ARGS2(FILE *, fp, struct config_type *, tbl)
d246 1
a246 1
PRIVATE int get_display_charset ARGS1(char *, value)
d256 1
a256 1
PRIVATE void put_display_charset ARGS2(FILE *, fp, struct config_type *, tbl)
d265 1
a265 1
PRIVATE int get_editor ARGS1(char *, value)
d272 1
a272 1
PRIVATE void put_editor ARGS2(FILE *, fp, struct config_type *, tbl)
d277 1
a277 1
PUBLIC int get_tagsoup ARGS1(char *, value)
d289 1
a289 1
PRIVATE void put_tagsoup ARGS2(FILE *, fp, struct config_type *, tbl)
d569 2
a570 2
PRIVATE Config_Type *lookup_config ARGS1(
	char *,		name)
d594 1
a594 1
PUBLIC void read_rc ARGS1(FILE *, fp)
d754 3
a756 3
PRIVATE void write_list ARGS2(
    	FILE *,		fp,
	char *,		list)
d776 1
a776 1
PRIVATE void explain_keypad_mode ARGS1(FILE *, fp)
d812 1
a812 1
PUBLIC int save_rc ARGS1(FILE *, fp)
d929 1
a929 1
PUBLIC BOOL will_save_rc ARGS1(char *, name)
d935 2
a936 2
PUBLIC int enable_lynxrc ARGS1(
	char *,		value)
@


1.7
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d1 1
a1 1
/* $MirBSD: LYrcFile.c,v 1.6 2003/09/25 17:51:03 tg Exp $ */
d404 3
d538 1
@


1.6
log
@"default" -> "prompt" (from lynx-dev@@ list)
while here, add RCS Id
@
text
@d1 1
a1 1
/* $MirBSD$ */
d103 1
a103 1
#ifdef EXP_READPROGRESS
d328 1
a328 1
#ifdef EXP_PERSISTENT_COOKIES
d518 1
a518 1
#ifdef EXP_READPROGRESS
@


1.5
log
@~/.lynx_cookies		-> ~/.etc/cookies.txt
~/.lynx_bookmarks.html	-> ~/.etc/bookmarks.htm
@
text
@d1 2
d127 1
a127 1
    { "default",	FORCE_PROMPT_DFT	},
@


1.4
log
@.lynxrc -> .etc/lynxrc
@
text
@a17 1
#ifdef __MirBSD__
a18 3
#else
#define FNAME_LYNXRC ".lynxrc"
#endif
d329 1
a329 1
The default is ~/.lynx_cookies.\n\
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d18 3
d22 1
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d11 1
d21 2
a22 3
#define FIND_KEYWORD(cp, keyword) \
    ((cp = LYstrstr(line_buffer, keyword)) != NULL && \
     (cp - line_buffer) < number_sign)
d24 108
a131 1
PRIVATE char *SkipEquals ARGS1(char *, src)
d133 1
a133 4
    char *tmp;
    if ((tmp = (char *)strchr(src, '=')) != NULL)
	src = tmp + 1;
    return LYSkipBlanks(src);
d136 3
a138 1
PUBLIC void read_rc NOPARAMS
d140 5
a144 20
    char *line_buffer = NULL;
    char rcfile[LY_MAXPATH];
    FILE *fp;
    char *cp;
    int number_sign;
    char MBM_line[256];
    int  MBM_counter;
    char *MBM_cp2, *MBM_cp1;
    int  MBM_i2;

    /*
     *  Make an RC file name.
     */
    LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

    /*
     *  Open the RC file for reading.
     */
    if ((fp = fopen(rcfile, "r")) == NULL) {
	return;
d146 2
d149 15
a163 296
    /*
     *  Process the entries.
     */
    while (LYSafeGets(&line_buffer, fp) != NULL) {
	/*
	 *  Remove any trailing white space.
	 */
	LYTrimTrailing(line_buffer);

	/*
	 *  Skip any comment or blank lines.
	 */
	if (line_buffer[0] == '\0' || line_buffer[0] == '#')
	    continue;

	/*
	 *  Find the line position of the number sign if there is one.
	 */
	if ((cp = (char *)strchr(line_buffer, '#')) == NULL)
	    number_sign = 999;
	else
	    number_sign = cp - line_buffer;

	/*
	 *  File editor.
	 */
	if (!system_editor && FIND_KEYWORD(cp, "file_editor")) {

	    cp = SkipEquals(cp);
	    StrAllocCopy(editor, cp);

	/*
	 *  Default bookmark file.
	 */
	} else if (FIND_KEYWORD(cp, "bookmark_file")) {

	    cp = SkipEquals(cp);

	    /*
	     *  Since this is the "Default Bookmark File", we save it
	     *  as a globals, and as the first MBM_A_subbookmark entry.
	     */
	    StrAllocCopy(bookmark_page, cp);
	    StrAllocCopy(BookmarkPage, cp);
	    StrAllocCopy(MBM_A_subbookmark[0], cp);
	    StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);

	/*
	 *  Multiple (sub)bookmark support settings.
	 */
	} else if (FIND_KEYWORD(cp, "sub_bookmarks")) {

	   cp = SkipEquals(cp);
	   if (!strncasecomp(cp, "standard", 8)) {
	      LYMultiBookmarks = TRUE;
	      LYMBMAdvanced = FALSE;
	   } else if (!strncasecomp(cp, "advanced", 8)) {
	      LYMultiBookmarks = TRUE;
	      LYMBMAdvanced = TRUE;
	   } else {
	      LYMultiBookmarks = FALSE;
	   }

	/*
	 *  Multiple (sub)bookmark definitions and descriptions.
	 */
	} else if (FIND_KEYWORD(cp, "multi_bookmark")) {

	    /*
	     *  Found the root, now cycle through all the
	     *	possible spaces and match specific ones.
	     */
	    for (MBM_counter = 1;
		 MBM_counter <= MBM_V_MAXFILES; MBM_counter++) {
		sprintf(MBM_line, "multi_bookmark%c", (MBM_counter + 'A'));

		if (FIND_KEYWORD(cp, MBM_line)) {
		    if ((MBM_cp1 = (char *)strchr(cp, '=')) == NULL) {
			break;
		    } else {
			if ((MBM_cp2 = (char *)strchr(cp, ',')) == NULL) {
			    break;
			} else {
			    MBM_i2 = 0;
			    /*
			     *  skip over the '='.
			     */
			    MBM_cp1++;
			    while (MBM_cp1 && MBM_cp1 != MBM_cp2) {
				/*
				 *  Skip spaces.
				 */
				if (isspace(*MBM_cp1)) {
				    MBM_cp1++;
				    continue;
				} else {
				    MBM_line[MBM_i2++] = *MBM_cp1++;
				}
			    }
			    MBM_line[MBM_i2++] = '\0';

			    StrAllocCopy(MBM_A_subbookmark[MBM_counter],
					 MBM_line);

			    /*
			     *  Now get the description ',' and ->.
			     */
			    MBM_cp1 = (char *)strchr(cp, ',');

			    MBM_i2 = 0;
			    /*
			     *  Skip over the ','.
			     */
			    MBM_cp1++;
			    /*
			     *  Eat spaces in front of description.
			     */
			    MBM_cp1 = LYSkipBlanks(MBM_cp1);
			    while (*MBM_cp1)
				MBM_line[MBM_i2++] = *MBM_cp1++;
			    MBM_line[MBM_i2++] = '\0';

			    StrAllocCopy(MBM_A_subdescript[MBM_counter],
					 MBM_line);

			    break;
			}
		    }
		}
	    }

	/*
	 *  FTP/file sorting method.
	 */
	} else if (FIND_KEYWORD(cp, "file_sorting_method")) {

	   cp = SkipEquals(cp);
	   if (!strncasecomp(cp, "BY_FILENAME", 11))
		HTfileSortMethod = FILE_BY_NAME;
	   else if (!strncasecomp(cp, "BY_TYPE", 7))
		HTfileSortMethod = FILE_BY_TYPE;
	   else if (!strncasecomp(cp, "BY_SIZE", 7))
		HTfileSortMethod = FILE_BY_SIZE;
	   else if (!strncasecomp(cp, "BY_DATE", 7))
		HTfileSortMethod = FILE_BY_DATE;

	/*
	 *  Personal mail address.
	 */
	} else if (FIND_KEYWORD(cp, "personal_mail_address")) {

	    cp = SkipEquals(cp);
	    StrAllocCopy(personal_mail_address, cp);

	/*
	 *  Searching type.
	 */
	} else if (FIND_KEYWORD(cp, "case_sensitive_searching")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		case_sensitive = TRUE;
	    else
		case_sensitive = FALSE;

	/*
	 *  Character set.
	 */
	} else if (FIND_KEYWORD(cp, "character_set")) {

	    int i = 0;

	    cp = SkipEquals(cp);

	    i = UCGetLYhndl_byAnyName(cp); /* by MIME or full name */
	    if (i < 0)
		; /* do nothing here: so fallback to lynx.cfg */
	    else
		current_char_set = i;

	/*
	 *  Preferred language.
	 */
	} else if (FIND_KEYWORD(cp, "preferred_language")) {

	    cp = SkipEquals(cp);
	    StrAllocCopy(language, cp);

	/*
	 *  Preferred charset.
	 */
	} else if (FIND_KEYWORD(cp, "preferred_charset")) {

	    cp = SkipEquals(cp);
	    StrAllocCopy(pref_charset, cp);

	/*
	 *  VI keys.
	 */
	} else if (FIND_KEYWORD(cp, "vi_keys")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		vi_keys = TRUE;
	    else
		vi_keys = FALSE;

	/*
	 *  EMACS keys.
	 */
	} else if (FIND_KEYWORD(cp, "emacs_keys")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		emacs_keys = TRUE;
	    else
		emacs_keys=FALSE;

	/*
	 *  Show dot files.
	 */
	} else if (FIND_KEYWORD(cp, "show_dotfiles")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		show_dotfiles = TRUE;
	    else
		show_dotfiles = FALSE;

	/*
	 *  Show color.
	 */
	} else if (FIND_KEYWORD(cp, "show_color")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "always", 6)) {
		LYrcShowColor = SHOW_COLOR_ALWAYS;
#if defined(USE_SLANG) || defined(COLOR_CURSES)
		if (LYShowColor != SHOW_COLOR_NEVER)
		    LYShowColor = SHOW_COLOR_ALWAYS;
#endif /* USE_SLANG || COLOR_CURSES */
	    } else if (!strncasecomp(cp, "never", 5)) {
		LYrcShowColor = SHOW_COLOR_NEVER;
#if defined(COLOR_CURSES)
		if (LYShowColor == SHOW_COLOR_ON)
		    LYShowColor = SHOW_COLOR_OFF;
#endif /* COLOR_CURSES */
	    }

	/*
	 *  Select popups.
	 */
	} else if (FIND_KEYWORD(cp, "select_popups")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "off", 3))
		LYSelectPopups = FALSE;
	    else
		LYSelectPopups = TRUE;

	/*
	 *  Show cursor.
	 */
	} else if (FIND_KEYWORD(cp, "show_cursor")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "off", 3))
		LYShowCursor = FALSE;
	    else
		LYShowCursor = TRUE;

	/*
	 *  Keypad mode.
	 */
	} else if (FIND_KEYWORD(cp, "keypad_mode")) {

	    cp = SkipEquals(cp);
	    if (LYstrstr(cp, "LINKS_ARE_NUMBERED"))
		keypad_mode = LINKS_ARE_NUMBERED;
	    else if (LYstrstr(cp, "LINKS_AND_FORM_FIELDS_ARE_NUMBERED"))
		keypad_mode = LINKS_AND_FORM_FIELDS_ARE_NUMBERED;
	    else
		keypad_mode = NUMBERS_AS_ARROWS;

	/*
	 *  Keyboard layout.
	 */
#ifdef EXP_KEYBOARD_LAYOUT
	} else if (FIND_KEYWORD(cp, "kblayout")) {

	    int i = 0;

	    cp = SkipEquals(cp);
	    for (; LYKbLayoutNames[i]; i++) {
		if (!strcmp(cp, LYKbLayoutNames[i])) {
		    current_layout = i;
d166 1
d168 9
a176 1
#endif /* EXP_KEYBOARD_LAYOUT */
d178 31
a208 4
	/*
	 *  Line edit mode.
	 */
	} else if (FIND_KEYWORD(cp, "lineedit_mode")) {
d210 11
a220 1
	    int i = 0;
d222 3
a224 7
	    cp = SkipEquals(cp);
	    for (; LYLineeditNames[i]; i++) {
		if (!strncmp(cp, LYLineeditNames[i], strlen(cp))) {
		    current_lineedit = i;
		    break;
		}
	    }
d226 8
a233 5
#ifdef DIRED_SUPPORT
	/*
	 *  Directory list style.
	 */
	} else if (FIND_KEYWORD(cp, "dir_list_style")) {
d235 3
a237 9
	    cp = SkipEquals(cp);
	    if (LYstrstr(cp, "FILES_FIRST") != NULL) {
		dir_list_style = FILES_FIRST;
	    } else if (LYstrstr(cp,"DIRECTORIES_FIRST") != NULL) {
		dir_list_style = 0;
	    } else {
		dir_list_style = MIXED_STYLE;
	    }
#endif /* DIRED_SUPPORT */
d239 4
a242 10
	/*
	 *  Accept cookies from all domains?
	 */
	} else if (FIND_KEYWORD(cp, "accept_all_cookies")) {
	    cp = SkipEquals(cp);
	    if (LYstrstr(cp,"TRUE") != NULL) {
		LYAcceptAllCookies = TRUE;
	    } else {
		LYAcceptAllCookies = FALSE;
	    }
d244 3
d248 5
a252 10
	/*
	 *  Accept all cookies from certain domains?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_accept_domains")) {
	    cp = SkipEquals(cp);
	    cookie_domain_flag_set(cp, FLAG_ACCEPT_ALWAYS);
	    if(LYCookieAcceptDomains != NULL) {
		StrAllocCat(LYCookieAcceptDomains, ",");
	    }
	    StrAllocCat(LYCookieAcceptDomains, cp);
d254 3
d258 4
a261 10
	/*
	 *  Reject all cookies from certain domains?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_reject_domains")) {
	    cp = SkipEquals(cp);
	    cookie_domain_flag_set(cp, FLAG_REJECT_ALWAYS);
	    if(LYCookieRejectDomains != NULL) {
		StrAllocCat(LYCookieRejectDomains, ",");
	    }
	    StrAllocCat(LYCookieRejectDomains, cp);
d263 6
a268 59
	/*
	 *  Cookie domains to perform loose checks?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_loose_invalid_domains")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieLooseCheckDomains, cp);
	    cookie_domain_flag_set(cp, FLAG_INVCHECK_LOOSE);

	/*
	 *  Cookie domains to perform strict checks?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_strict_invalid_domains")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieStrictCheckDomains, cp);
	    cookie_domain_flag_set(cp, FLAG_INVCHECK_STRICT);

	/*
	 *  Cookie domains to query user over invalid cookies?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_query_invalid_domains")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieQueryCheckDomains, cp);
	    cookie_domain_flag_set(cp, FLAG_INVCHECK_QUERY);

#ifdef EXP_PERSISTENT_COOKIES
	/*
	 *  File in which to store persistent cookies.
	 */
	} else if (FIND_KEYWORD(cp, "cookie_file")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieFile, cp);
#endif /* EXP_PERSISTENT_COOKIES */

	/*
	 *  User mode.
	 */
	} else if (FIND_KEYWORD(cp, "user_mode")) {

	    cp = SkipEquals(cp);
	    if (LYstrstr(cp, "ADVANCED") != NULL) {
		user_mode = ADVANCED_MODE;
	    } else if (LYstrstr(cp,"INTERMEDIATE") != NULL) {
		user_mode = INTERMEDIATE_MODE;
	    } else {
		user_mode = NOVICE_MODE;
	    }

#ifdef NOTUSED
#ifdef DISP_PARTIAL
	/*
	 *  Partial display logic--set the threshold # of lines before
	 *  Lynx redraws the screen
	 */
	} else if (FIND_KEYWORD(cp, "partial_thres")) {
	    cp = SkipEquals(cp);
	    if (atoi(cp) != 0)
		partial_threshold = atoi(cp);
#endif /* DISP_PARTIAL */
#endif /* NOTUSED */
d270 1
a270 44
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
	/*
	 *  Local execution mode - all links.
	 */
	} else if (FIND_KEYWORD(cp, "run_all_execution_links")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		local_exec = TRUE;
	     else
		local_exec = FALSE;

	/*
	 *  Local execution mode - only links in local files.
	 */
	} else if (FIND_KEYWORD(cp, "run_execution_links_on_local_files")) {
	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		local_exec_on_local_files = TRUE;
	    else
		local_exec_on_local_files=FALSE;
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */

	} else if (FIND_KEYWORD(cp, "verbose_images")) {
	   cp = SkipEquals(cp);
	   if (!strncasecomp(cp, "on", 2))
		verbose_img = 1;
	   else if (!strncasecomp(cp, "off", 3))
		verbose_img = 0;

	} /* end of if */

    } /* end of while */

    fclose(fp);
} /* big end */

/*
 * Write a set of comments.  Doing it this way avoids preprocessor problems
 * with the leading '#', makes it simpler to use gettext.
 */
PRIVATE void write_list ARGS2(
    	FILE *,		fp,
	char *,		list)
d272 1
a272 13
    int first = TRUE;
    while (*list != 0) {
	int ch = *list++;
	if (ch == '\n') {
	    first = TRUE;
	} else {
	    if (first) {
		fputs("# ", fp);
		first = FALSE;
	    }
	}
	fputc(ch, fp);
    }
d275 1
a275 1
PUBLIC int save_rc NOPARAMS
d277 1
a277 9
    char rcfile[LY_MAXPATH];
    FILE *fp;
    int i;
    int MBM_c;

    /*
     *  Make a name.
     */
    LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);
d279 4
a282 5
    /*
     *  Open the file for write.
     */
    if ((fp = LYNewTxtFile(rcfile)) == NULL) {
	return FALSE;
d284 2
d287 4
a290 16
    /*
     *  Header.
     */
    write_list(fp, gettext("\
Lynx User Defaults File\n\
\n\
This file contains options saved from the Lynx Options Screen (normally\n\
with the '>' key).  There is normally no need to edit this file manually,\n\
since the defaults here can be controlled from the Options Screen, and the\n\
next time options are saved from the Options Screen this file will be\n\
completely rewritten.  You have been warned...\n\
If you are looking for the general configuration file - it is normally\n\
called lynx.cfg, and it has different content and a different format.\n\
It is not this file.\n\
"));
    fprintf(fp, "\n");
d292 74
a365 4
    /*
     *  File editor
     */
    write_list(fp, gettext("\
d370 2
a371 56
"));
    fprintf(fp, "file_editor=%s\n\n", (editor ? editor : ""));

    /*
     *  Default bookmark file.
     */
    write_list(fp, gettext("\
bookmark_file specifies the name and location of the default bookmark\n\
file into which the user can paste links for easy access at a later\n\
date.\n\
"));
    fprintf(fp, "bookmark_file=%s\n\n", (bookmark_page ? bookmark_page : ""));

    /*
     *  Multiple (sub)bookmark support settings.
     */
    write_list(fp, gettext("\
If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
been defined (see below), then all bookmark operations will first\n\
prompt the user to select an active sub-bookmark file.  If the default\n\
Lynx bookmark_file is defined (see above), it will be used as the\n\
default selection.  When this option is set to \"advanced\", and the\n\
user mode is advanced, the 'v'iew bookmark command will invoke a\n\
statusline prompt instead of the menu seen in novice and intermediate\n\
user modes.  When this option is set to \"standard\", the menu will be\n\
presented regardless of user mode.\n\
"));
    fprintf(fp, "sub_bookmarks=%s\n\n", (LYMultiBookmarks ?
					   (LYMBMAdvanced ?
					       "advanced" : "standard")
							  : "off"));

    /*
     *  Multiple (sub)bookmark definitions and descriptions.
     */
    write_list(fp, gettext("\
The following allow you to define sub-bookmark files and descriptions.\n\
The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
Up to 26 bookmark files (for the English capital letters) are allowed.\n\
We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n\
"));
    for (MBM_c = 1; MBM_c <= MBM_V_MAXFILES; MBM_c++)
       fprintf(fp, "multi_bookmark%c=%s%s%s\n",
		   (MBM_c + 'A'),
		   (MBM_A_subbookmark[MBM_c] ?
		    MBM_A_subbookmark[MBM_c] : ""),
		   (MBM_A_subbookmark[MBM_c] ?
					 "," : ""),
		   (MBM_A_subdescript[MBM_c] ?
		    MBM_A_subdescript[MBM_c] : ""));
    fprintf(fp, "\n");

    /*
     *  FTP/file sorting method.
     */
    write_list(fp, gettext("\
d378 33
a410 13
"));
    fprintf(fp, "file_sorting_method=%s\n\n",
		(HTfileSortMethod == FILE_BY_NAME ? "BY_FILENAME"
						  :
		(HTfileSortMethod == FILE_BY_SIZE ? "BY_SIZE"
						  :
		(HTfileSortMethod == FILE_BY_TYPE ? "BY_TYPE"
						  : "BY_DATE"))));

    /*
     *  Personal mail address.
     */
    write_list(fp, gettext("\
d418 2
a419 46
"));
    fprintf(fp, "personal_mail_address=%s\n\n",
		(personal_mail_address ? personal_mail_address : ""));

    /*
     *  Searching type.
     */
    write_list(fp, gettext("\
If case_sensitive_searching is \"on\" then when the user invokes a search\n\
using the 's' or '/' keys, the search performed will be case sensitive\n\
instead of case INsensitive.  The default is usually \"off\".\n\
"));
    fprintf(fp, "case_sensitive_searching=%s\n\n",
		(case_sensitive ? "on" : "off"));

    /*
     *  Character set.
     */
    write_list(fp, gettext("\
The character_set definition controls the representation of 8 bit\n\
characters for your terminal.  If 8 bit characters do not show up\n\
correctly on your screen you may try changing to a different 8 bit\n\
set or using the 7 bit character approximations.\n\
Current valid characters sets are:\n\
"));
    for (i = 0; LYchar_set_names[i]; i++)
	fprintf(fp, "#    %s\n", LYchar_set_names[i]);
    fprintf(fp, "character_set=%s\n\n", LYchar_set_names[current_char_set]);


    /*
     *  Preferred language.
     */
    write_list(fp, gettext("\
preferred_language specifies the language in MIME notation (e.g., en,\n\
fr, may be a comma-separated list in decreasing preference)\n\
which Lynx will indicate you prefer in requests to http servers.\n\
If a file in that language is available, the server will send it.\n\
Otherwise, the server will send the file in it's default language.\n\
"));
    fprintf(fp, "preferred_language=%s\n\n", (language ? language : ""));

    /*
     *  Preferred charset.
     */
    write_list(fp, gettext("\
d432 50
a481 9
"));
    fprintf(fp, "preferred_charset=%s\n\n",
		(pref_charset ? pref_charset : ""));

    /*
     *  Show color.
     */
    if (LYChosenShowColor != SHOW_COLOR_UNKNOWN) {
	write_list(fp, gettext("\
d494 112
a605 8
The mode set at startup can be changed via the \"show color\" option in\n\
the 'o'ptions menu.  If the option settings are saved, the \"on\" and\n\
\"off\" \"show color\" settings will be treated as \"default\".\n\
"));
     fprintf(fp, "show_color=%s\n\n",
	     ((LYChosenShowColor == SHOW_COLOR_NEVER  ? "never"  :
	       (LYChosenShowColor == SHOW_COLOR_ALWAYS ? "always" :
						      "default"))));
d609 1
a609 1
     *  VI keys.
d611 103
a713 9
    write_list(fp, gettext("\
If vi_keys is set to \"on\", then the normal VI movement keys:\n\
  j = down    k = up\n\
  h = left    l = right\n\
will be enabled.  These keys are only lower case.\n\
Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
and the keymap display, respectively.\n\
"));
     fprintf(fp, "vi_keys=%s\n\n", (vi_keys ? "on" : "off"));
d715 4
a718 10
    /*
     *  EMACS keys.
     */
    write_list(fp, gettext("\
If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
  ^N = down    ^P = up\n\
  ^B = left    ^F = right\n\
will be enabled.\n\
"));
    fprintf(fp, "emacs_keys=%s\n\n", (emacs_keys ? "on" : "off"));
d720 2
a721 11
    /*
     *  Show dot files.
     */
    write_list(fp, gettext("\
show_dotfiles specifies that the directory listing should include\n\
\"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
restricted via a command line switch.  If display of hidden files\n\
is disabled, creation of such files via Lynx also is disabled.\n\
"));
    fprintf(fp, "show_dotfiles=%s\n\n", (show_dotfiles ? "on" : "off"));
d723 1
d725 1
a725 1
     *  Select popups.
d727 16
a742 10
    write_list(fp, gettext("\
select_popups specifies whether the OPTIONs in a SELECT block which\n\
lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
present in the SELECT start tag, Lynx always will create a vertical list\n\
of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
as the default while a value of \"off\" will set use of radio boxes.\n\
The default can be overridden via the -popup command line toggle.\n\
"));
    fprintf(fp, "select_popups=%s\n\n", (LYSelectPopups ? "on" : "off"));
d744 22
a765 15
    /*
     *  Show cursor.
     */
    write_list(fp, gettext("\
show_cursor specifies whether to 'hide' the cursor to the right (and\n\
bottom, if possible) of the screen, or to place it to the left of the\n\
current link in documents, or current option in select popup windows.\n\
Positioning the cursor to the left of the current link or option is\n\
helpful for speech or braille interfaces, and when the terminal is\n\
one which does not distinguish the current link based on highlighting\n\
or color.  A value of \"on\" will set positioning to the left as the\n\
default while a value of \"off\" will set 'hiding' of the cursor.\n\
The default can be overridden via the -show_cursor command line toggle.\n\
"));
    fprintf(fp, "show_cursor=%s\n\n", (LYShowCursor ? "on" : "off"));
d767 5
a771 3
    /*
     *  Keypad mode.
     */
d799 13
a811 4
    fprintf(fp, "keypad_mode=%s\n\n",
		((keypad_mode == NUMBERS_AS_ARROWS) ?  "NUMBERS_AS_ARROWS" :
	       ((keypad_mode == LINKS_ARE_NUMBERED) ? "LINKS_ARE_NUMBERED" :
				      "LINKS_AND_FORM_FIELDS_ARE_NUMBERED")));
d813 5
a817 15
#ifdef NOTUSED
#ifdef DISP_PARTIAL
    /*
     *  Partial display threshold
     */
    write_list(fp, gettext("\
partial_thres specifies the number of lines Lynx should download and render\n\
before we redraw the screen in Partial Display logic\n\
e.g., partial_thres=2\n\
would have Lynx redraw every 2 lines that it renders\n\
partial_thres=-1 would use the entire screensize\n\
"));
    fprintf(fp, "partial_thres=%d\n\n", partial_threshold);
#endif /* DISP_PARTIAL */
#endif /* NOTUSED */
d819 5
a823 21
    /*
     *  Line edit mode.
     */
    write_list(fp, gettext("\
lineedit_mode specifies the key binding used for inputting strings in\n\
prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
the following control characters are used for moving and deleting:\n\
\n\
             Prev  Next       Enter = Accept input\n\
   Move char: <-    ->        ^G    = Cancel input\n\
   Move word: ^P    ^N        ^U    = Erase line\n\
 Delete char: ^H    ^R        ^A    = Beginning of line\n\
 Delete word: ^B    ^F        ^E    = End of line\n\
\n\
Current lineedit modes are:\n\
"));
    {
	char **bindings = LYLineeditNames;
	while (*bindings) {
	    fprintf(fp, "#    %s\n", *bindings);
	    bindings++;
a825 4
    fprintf(fp, "lineedit_mode=%s\n\n", LYLineeditNames[current_lineedit]);
#ifdef EXP_KEYBOARD_LAYOUT
    fprintf(fp, "kblayout=%s\n\n", LYKbLayoutNames[current_layout]);
#endif
a826 4
#ifdef DIRED_SUPPORT
    /*
     *  Directory list style.
     */
d828 10
a837 4
dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
(if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
files and directories together.  \"FILES_FIRST\" lists files first and\n\
\"DIRECTORIES_FIRST\" lists directories first.\n\
d839 1
a839 6
    fprintf(fp, "dir_list_style=%s\n\n",
		(dir_list_style==FILES_FIRST ? "FILES_FIRST"
					     :
		(dir_list_style==MIXED_STYLE ? "MIXED_STYLE"
					     : "DIRECTORIES_FIRST")));
#endif /* DIRED_SUPPORT */
d841 2
a842 15
    /*
     *  User mode.
     */
    write_list(fp, gettext("\
user_mode specifies the users level of knowledge with Lynx.  The\n\
default is \"NOVICE\" which displays two extra lines of help at the\n\
bottom of the screen to aid the user in learning the basic Lynx\n\
commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
bottom of the screen.\n\
"));
    fprintf(fp, "user_mode=%s\n\n",
		(user_mode == NOVICE_MODE ? "NOVICE" :
			 (user_mode == ADVANCED_MODE ?
					  "ADVANCED" : "INTERMEDIATE")));
d844 8
a851 11
    /*
     *  Cookie options
     */
    write_list(fp, gettext("\
accept_all_cookies allows the user to tell Lynx to automatically\n\
accept all cookies if desired.  The default is \"FALSE\" which will\n\
prompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\n\
all cookies.\n\
"));
    fprintf(fp, "accept_all_cookies=%s\n\n",
		(LYAcceptAllCookies == FALSE ? "FALSE" : "TRUE"));
d853 38
a890 13
    write_list(fp, gettext("\
cookie_accept_domains and cookie_reject_domains are comma-delimited\n\
lists of domains from which Lynx should automatically accept or reject\n\
all cookies.  If a domain is specified in both options, rejection will\n\
take precedence.  The accept_all_cookies parameter will override any\n\
settings made here.\n\
"));
    fprintf(fp, "cookie_accept_domains=%s\n",
		    (LYCookieAcceptDomains == NULL ? ""
		    : LYCookieAcceptDomains));
    fprintf(fp, "cookie_reject_domains=%s\n\n",
		    (LYCookieRejectDomains == NULL ? ""
		    : LYCookieRejectDomains));
d892 8
d901 5
a905 19
    write_list(fp, gettext("\
cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\n\
cookie_query_invalid_domains are comma-delimited lists of which domains\n\
should be subjected to varying degrees of validity checking.  If a\n\
domain is set to strict checking, strict conformance to RFC2109 will\n\
be applied.  A domain with loose checking will be allowed to set cookies\n\
with an invalid path or domain attribute.  All domains will default to\n\
querying the user for an invalid path or domain.\n\
"));
    fprintf(fp, "cookie_loose_invalid_domains=%s\n",
	    (LYCookieLooseCheckDomains == NULL) ? ""
		    : LYCookieLooseCheckDomains);
    fprintf(fp, "cookie_strict_invalid_domains=%s\n",
	    (LYCookieStrictCheckDomains == NULL) ? ""
		    : LYCookieStrictCheckDomains);
    fprintf(fp, "cookie_query_invalid_domains=%s\n\n",
	    (LYCookieQueryCheckDomains == NULL) ? ""
		    : LYCookieQueryCheckDomains);

a906 1
#ifdef EXP_PERSISTENT_COOKIES
d908 1
a908 1
     *  Cookie file.
d910 6
a915 7
    write_list(fp, gettext("\
cookie_file specifies the file in which to store persistent cookies.\n\
The default is ~/.lynx_cookies.\n\
"));
    fprintf(fp, "cookie_file=%s\n\n",
		(LYCookieFile == NULL ? "~/.lynx_cookies" : LYCookieFile));
#endif /* EXP_PERSISTENT_COOKIES */
d917 2
d920 8
d929 5
a933 17
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    /*
     *  Local execution mode - all links.
     */
    write_list(fp, gettext("\
If run_all_execution_links is set \"on\" then all local execution links\n\
will be executed when they are selected.\n\
\n\
WARNING - This is potentially VERY dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
"));
    fprintf(fp, "run_all_execution_links=%s\n\n",
		(local_exec ? "on" : "off"));
d935 14
a948 37
    /*
     *  Local execution mode - only links in local files.
     */
    write_list(fp, gettext("\
If run_execution_links_on_local_files is set \"on\" then all local\n\
execution links that are found in LOCAL files will be executed when they\n\
are selected.  This is different from run_all_execution_links in that\n\
only files that reside on the local system will have execution link\n\
permissions.\n\
\n\
WARNING - This is potentially dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
"));
    fprintf(fp, "run_execution_links_on_local_files=%s\n\n",
		(local_exec_on_local_files ? "on" : "off"));
#endif /* defined(EXEC_LINKS) || defined(EXEC_SCRIPTS) */

    write_list(fp, gettext("\
If verbose_images is \"on\", lynx will print the name of the image\n\
source file in place of [INLINE], [LINK] or [IMAGE]\n\
See also VERBOSE_IMAGES in lynx.cfg\n\
"));
    fprintf(fp, "verbose_images=%s\n\n",
		verbose_img ? "on" : "off");

    /*
     *  Close the RC file.
     */
    fclose(fp);

    HTSYS_purge(rcfile);

    return TRUE;
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a10 1
#include <HTMLDTD.h>
d20 3
a22 12
#define MSG_ENABLE_LYNXRC N_("Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n")
#define putBool(value) ((value) ? "on" : "off")
/* *INDENT-OFF* */
static Config_Enum tbl_DTD_recovery[] = {
    { "true",		TRUE },
    { "false",		FALSE },
    { "on",		TRUE },
    { "off",		FALSE },
    { "sortasgml",	TRUE },
    { "tagsoup",	FALSE },
    { NULL,		-1 },
};
d24 1
a24 125
#ifdef DIRED_SUPPORT
static Config_Enum tbl_dir_list_style[] = {
    { "FILES_FIRST",	FILES_FIRST },
    { "DIRECTORIES_FIRST", DIRS_FIRST },
    { "MIXED_STYLE",	MIXED_STYLE },
    { NULL,		MIXED_STYLE },
};
#ifdef LONG_LIST
static Config_Enum tbl_dir_list_order[] = {
    { "ORDER_BY_NAME",	ORDER_BY_NAME },
    { "ORDER_BY_TYPE",	ORDER_BY_TYPE },
    { "ORDER_BY_SIZE",  ORDER_BY_SIZE },
    { "ORDER_BY_DATE",	ORDER_BY_DATE },
    { "ORDER_BY_MODE",	ORDER_BY_MODE },
#ifndef NO_GROUPS
    { "ORDER_BY_USER",	ORDER_BY_USER },
    { "ORDER_BY_GROUP",	ORDER_BY_GROUP },
#endif
    { NULL,		ORDER_BY_NAME },
};
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

static Config_Enum tbl_file_sort[] = {
    { "BY_FILENAME",	FILE_BY_NAME },
    { "BY_TYPE",	FILE_BY_TYPE },
    { "BY_SIZE",	FILE_BY_SIZE },
    { "BY_DATE",	FILE_BY_DATE },
    { NULL,		-1 },
};

Config_Enum tbl_keypad_mode[] = {
    { "FIELDS_ARE_NUMBERED", FIELDS_ARE_NUMBERED },
    { "LINKS_AND_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "LINKS_ARE_NUMBERED", LINKS_ARE_NUMBERED },
    { "LINKS_ARE_NOT_NUMBERED", NUMBERS_AS_ARROWS },
    /* obsolete variations: */
    { "LINKS_AND_FORM_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "NUMBERS_AS_ARROWS", NUMBERS_AS_ARROWS },
    { NULL,		DEFAULT_KEYPAD_MODE }
};

Config_Enum tbl_multi_bookmarks[] = {
    { "OFF",		MBM_OFF },
    { "STANDARD",	MBM_STANDARD },
    { "ON",		MBM_STANDARD },
    { "ADVANCED",	MBM_ADVANCED },
    { NULL,		-1 }
};

/* the names in this table are used as lowercase in HTTP.c */
Config_Enum tbl_preferred_encoding[] = {
    { "none",		encodingNONE },
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    { "gzip",		encodingGZIP },
    { "deflate",	encodingDEFLATE },
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    { "compress",	encodingCOMPRESS },
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    { "bzip2",		encodingBZIP2 },
#endif
    { "all",		encodingALL },
    { NULL,		-1 }
};

Config_Enum tbl_preferred_media[] = {
    { "INTERNAL",	mediaOpt1 },
    { "CONFIGFILE",	mediaOpt2 },
    { "USER",		mediaOpt3 },
    { "SYSTEM",		mediaOpt4 },
    { "ALL",		mediaALL },
    { NULL,		-1 }
};

static Config_Enum tbl_show_colors[] = {
    { "default",	SHOW_COLOR_UNKNOWN },
    { "default",	SHOW_COLOR_OFF },
    { "default",	SHOW_COLOR_ON },
    { "on",		SHOW_COLOR_UNKNOWN },
    { "off",		SHOW_COLOR_UNKNOWN },
    { "never",		SHOW_COLOR_NEVER },
    { "always",		SHOW_COLOR_ALWAYS },
    { NULL,		SHOW_COLOR_UNKNOWN }
};

Config_Enum tbl_transfer_rate[] = {
    { "NONE",		rateOFF },
    { "KB",		rateKB },
    { "TRUE",		rateKB },
    { "BYTES",		rateBYTES },
    { "FALSE",		rateBYTES },
#ifdef USE_READPROGRESS
    { "KB,ETA",		rateEtaKB },
    { "BYTES,ETA",	rateEtaBYTES },
#endif
    { NULL,		-1 },
};

Config_Enum tbl_user_mode[] = {
    { "ADVANCED",	ADVANCED_MODE },
    { "INTERMEDIATE",	INTERMEDIATE_MODE },
    { "NOVICE",		NOVICE_MODE },
    { NULL,		NOVICE_MODE }
};

static Config_Enum tbl_visited_links[] = {
    { "FIRST_REVERSED",	VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE },
    { "FIRST",		VISITED_LINKS_AS_FIRST_V },
    { "TREE",		VISITED_LINKS_AS_TREE    },
    { "LAST_REVERSED",	VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE },
    { "LAST",		VISITED_LINKS_AS_LATEST  },
    { NULL,		DEFAULT_VISITED_LINKS }
};

Config_Enum tbl_force_prompt[] = {
    { "prompt",		FORCE_PROMPT_DFT	},
    { "yes",		FORCE_PROMPT_YES	},
    { "no",		FORCE_PROMPT_NO		},
    { NULL,		-1			}
};
/* *INDENT-ON* */

static BOOL getBool(char *src)
d26 4
a29 1
    return (BOOL) (!strncasecomp(src, "on", 2) || !strncasecomp(src, "true", 4));
d32 1
a32 1
const char *LYputEnum(Config_Enum * table, int value)
d34 20
a53 5
    while (table->name != 0) {
	if (table->value == value) {
	    return table->name;
	}
	table++;
a54 2
    return "?";
}
d56 312
a367 13
BOOL LYgetEnum(Config_Enum * table, char *name,
	       int *result)
{
    Config_Enum *found = 0;
    unsigned len = strlen(name);
    int match = 0;

    if (len != 0) {
	while (table->name != 0) {
	    if (!strncasecomp(table->name, name, len)) {
		found = table;
		if (!strcasecomp(table->name, name)) {
		    match = 1;
a369 1
		++match;
a370 9
	    table++;
	}
	if (match == 1) {	/* if unambiguous */
	    *result = found->value;
	    return TRUE;
	}
    }
    return FALSE;		/* no match */
}
d372 88
a459 42
/* these are for data that are normally not read/written from .lynxrc */
#define PARSE_SET(n,v,h)   {n,    1, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define PARSE_ARY(n,v,t,h) {n,    1, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define PARSE_ENU(n,v,t,h) {n,    1, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define PARSE_LIS(n,v,h)   {n,    1, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_STR(n,v,h)   {n,    1, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_FUN(n,v,w,h) {n,    1, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define PARSE_MBM(n,h)     {n,    1, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

/* these are for data that are optionally read/written from .lynxrc */
#define MAYBE_SET(n,v,h)   {n,    0, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define MAYBE_ARY(n,v,t,h) {n,    0, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define MAYBE_ENU(n,v,t,h) {n,    0, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define MAYBE_LIS(n,v,h)   {n,    0, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_STR(n,v,h)   {n,    0, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_FUN(n,v,w,h) {n,    0, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define MAYBE_MBM(n,h)     {n,    0, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

#define PARSE_NIL          {NULL, 1, CONF_NIL,   UNION_DEF(0), 0, 0, 0, 0}

typedef enum {
    CONF_NIL = 0
    ,CONF_ARRAY
    ,CONF_BOOL
    ,CONF_FUN
    ,CONF_INT
    ,CONF_ENUM
    ,CONF_LIS
    ,CONF_MBM
    ,CONF_STR
} Conf_Types;

typedef struct config_type {
    const char *name;
    int enabled;		/* see lynx.cfg ENABLE_LYNXRC "off" lines */
    Conf_Types type;
      ParseData;
    const char **strings;
    Config_Enum *table;
    void (*write_it) (FILE *fp, struct config_type *);
    const char *note;
} Config_Type;
d461 8
a468 3
static int get_assume_charset(char *value)
{
    int i;
d470 12
a481 8
    for (i = 0; i < LYNumCharsets; ++i) {
	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
	    UCLYhndl_for_unspec = i;
	    break;
	}
    }
    return 0;
}
d483 5
a487 3
static void put_assume_charset(FILE *fp, struct config_type *tbl)
{
    int i;
d489 5
a493 4
    for (i = 0; i < LYNumCharsets; ++i)
	fprintf(fp, "#    %s\n", LYCharSet_UC[i].MIMEname);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
}
d495 17
a511 3
static int get_display_charset(char *value)
{
    int i = 0;
d513 1
a513 5
    i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */
    if (i >= 0)
	current_char_set = i;
    return 0;
}
d515 1
a515 3
static void put_display_charset(FILE *fp, struct config_type *tbl)
{
    int i;
d517 2
a518 4
    for (i = 0; LYchar_set_names[i]; i++)
	fprintf(fp, "#    %s\n", LYchar_set_names[i]);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYchar_set_names[current_char_set]);
}
d520 7
a526 1
static int get_editor(char *value)
d528 13
a540 3
    if (!system_editor)
	StrAllocCopy(editor, value);
    return 0;
d543 1
a543 1
static void put_editor(FILE *fp, struct config_type *tbl)
d545 4
a548 2
    fprintf(fp, "%s=%s\n\n", tbl->name, NonNull(editor));
}
d550 4
a553 3
int get_tagsoup(char *value)
{
    int found = Old_DTD;
d555 5
a559 4
    if (LYgetEnum(tbl_DTD_recovery, value, &found)
	&& Old_DTD != found) {
	Old_DTD = found;
	HTSwitchDTD(!Old_DTD);
a560 2
    return 0;
}
d562 16
a577 4
static void put_tagsoup(FILE *fp, struct config_type *tbl)
{
    fprintf(fp, "%s=%s\n\n", tbl->name, LYputEnum(tbl_DTD_recovery, Old_DTD));
}
d579 4
a582 81
/* This table is searched ignoring case */
/* *INDENT-OFF* */
static Config_Type Config_Table [] =
{
    PARSE_SET(RC_ACCEPT_ALL_COOKIES,    LYAcceptAllCookies, N_("\
accept_all_cookies allows the user to tell Lynx to automatically\n\
accept all cookies if desired.  The default is \"FALSE\" which will\n\
prompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\n\
all cookies.\n\
")),
    MAYBE_FUN(RC_ASSUME_CHARSET,        get_assume_charset, put_assume_charset, MSG_ENABLE_LYNXRC),
    PARSE_STR(RC_ANONFTP_PASSWORD,      anonftp_password, N_("\
anonftp_password allows the user to tell Lynx to use the personal\n\
email address as the password for anonymous ftp.  If no value is given,\n\
Lynx will use the personal email address.  Set anonftp_password\n\
to a different value if you choose.\n\
")),
    PARSE_STR(RC_BOOKMARK_FILE,         bookmark_page,     N_("\
bookmark_file specifies the name and location of the default bookmark\n\
file into which the user can paste links for easy access at a later\n\
date.\n\
")),
    PARSE_SET(RC_CASE_SENSITIVE_SEARCHING, case_sensitive, N_("\
If case_sensitive_searching is \"on\" then when the user invokes a search\n\
using the 's' or '/' keys, the search performed will be case sensitive\n\
instead of case INsensitive.  The default is usually \"off\".\n\
")),
    PARSE_FUN(RC_CHARACTER_SET,         get_display_charset, put_display_charset, N_("\
The character_set definition controls the representation of 8 bit\n\
characters for your terminal.  If 8 bit characters do not show up\n\
correctly on your screen you may try changing to a different 8 bit\n\
set or using the 7 bit character approximations.\n\
Current valid characters sets are:\n\
")),
    PARSE_LIS(RC_COOKIE_ACCEPT_DOMAINS, LYCookieAcceptDomains, N_("\
cookie_accept_domains and cookie_reject_domains are comma-delimited\n\
lists of domains from which Lynx should automatically accept or reject\n\
all cookies.  If a domain is specified in both options, rejection will\n\
take precedence.  The accept_all_cookies parameter will override any\n\
settings made here.\n\
")),
#ifdef USE_PERSISTENT_COOKIES
    PARSE_STR(RC_COOKIE_FILE,	        LYCookieFile, N_("\
cookie_file specifies the file from which to read persistent cookies.\n\
The default is ~/.lynx_cookies.\n\
")),
#endif
    PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieLooseCheckDomains, N_("\
cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\n\
cookie_query_invalid_domains are comma-delimited lists of which domains\n\
should be subjected to varying degrees of validity checking.  If a\n\
domain is set to strict checking, strict conformance to RFC2109 will\n\
be applied.  A domain with loose checking will be allowed to set cookies\n\
with an invalid path or domain attribute.  All domains will default to\n\
querying the user for an invalid path or domain.\n\
")),
    PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieQueryCheckDomains, NULL),
    PARSE_LIS(RC_COOKIE_REJECT_DOMAINS, LYCookieRejectDomains, NULL),
    PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieStrictCheckDomains, NULL),
#ifdef DIRED_SUPPORT
#ifdef LONG_LIST
    PARSE_ENU(RC_DIR_LIST_ORDER,        dir_list_order,     tbl_dir_list_order, N_("\
dir_list_order specifies the directory list order under DIRED_SUPPORT\n\
(if implemented).  The default is \"ORDER_BY_NAME\"\n\
")),
#endif
    PARSE_ENU(RC_DIR_LIST_STYLE,        dir_list_style,     tbl_dir_list_style, N_("\
dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
(if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
files and directories together.  \"FILES_FIRST\" lists files first and\n\
\"DIRECTORIES_FIRST\" lists directories first.\n\
")),
#endif
    MAYBE_STR(RC_DISPLAY,               x_display,          MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_EMACS_KEYS,            emacs_keys, N_("\
If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
  ^N = down    ^P = up\n\
  ^B = left    ^F = right\n\
will be enabled.\n\
")),
    PARSE_FUN(RC_FILE_EDITOR,           get_editor,         put_editor, N_("\
d587 56
a642 2
")),
    PARSE_ENU(RC_FILE_SORTING_METHOD,   HTfileSortMethod,   tbl_file_sort, N_("\
d649 13
a661 36
")),
    MAYBE_ENU(RC_FORCE_COOKIE_PROMPT,   cookie_noprompt,    tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#ifdef USE_SSL
    MAYBE_ENU(RC_FORCE_SSL_PROMPT,      ssl_noprompt,       tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#endif
#ifdef EXP_KEYBOARD_LAYOUT
    PARSE_ARY(RC_KBLAYOUT,              current_layout,     LYKbLayoutNames, NULL),
#endif
    PARSE_ENU(RC_KEYPAD_MODE,           keypad_mode,        tbl_keypad_mode, NULL),
    PARSE_ARY(RC_LINEEDIT_MODE,         current_lineedit,   LYLineeditNames, N_("\
lineedit_mode specifies the key binding used for inputting strings in\n\
prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
the following control characters are used for moving and deleting:\n\
\n\
             Prev  Next       Enter = Accept input\n\
   Move char: <-    ->        ^G    = Cancel input\n\
   Move word: ^P    ^N        ^U    = Erase line\n\
 Delete char: ^H    ^R        ^A    = Beginning of line\n\
 Delete word: ^B    ^F        ^E    = End of line\n\
\n\
Current lineedit modes are:\n\
")),
#ifdef EXP_LOCALE_CHARSET
    MAYBE_SET(RC_LOCALE_CHARSET,      LYLocaleCharset,        MSG_ENABLE_LYNXRC),
#endif
    MAYBE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts, MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images, MSG_ENABLE_LYNXRC),
    PARSE_MBM(RC_MULTI_BOOKMARK, N_("\
The following allow you to define sub-bookmark files and descriptions.\n\
The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
Up to 26 bookmark files (for the English capital letters) are allowed.\n\
We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n\
")),
    PARSE_STR(RC_PERSONAL_MAIL_ADDRESS, personal_mail_address, N_("\
d669 46
a714 2
")),
    PARSE_STR(RC_PREFERRED_CHARSET,     pref_charset, N_("\
d727 9
a735 54
")),
    MAYBE_ENU(RC_PREFERRED_ENCODING,    LYAcceptEncoding,   tbl_preferred_encoding,
	      MSG_ENABLE_LYNXRC),
    PARSE_STR(RC_PREFERRED_LANGUAGE,    language, N_("\
preferred_language specifies the language in MIME notation (e.g., en,\n\
fr, may be a comma-separated list in decreasing preference)\n\
which Lynx will indicate you prefer in requests to http servers.\n\
If a file in that language is available, the server will send it.\n\
Otherwise, the server will send the file in its default language.\n\
")),
    MAYBE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia,      tbl_preferred_media,
	      MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_RAW_MODE,              LYRawMode,          MSG_ENABLE_LYNXRC),
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PARSE_SET(RC_RUN_ALL_EXECUTION_LINKS, local_exec, N_("\
If run_all_execution_links is set \"on\" then all local execution links\n\
will be executed when they are selected.\n\
\n\
WARNING - This is potentially VERY dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
    PARSE_SET(RC_RUN_EXECUTION_LINKS_LOCAL, local_exec_on_local_files, N_("\
If run_execution_links_on_local_files is set \"on\" then all local\n\
execution links that are found in LOCAL files will be executed when they\n\
are selected.  This is different from run_all_execution_links in that\n\
only files that reside on the local system will have execution link\n\
permissions.\n\
\n\
WARNING - This is potentially dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
#endif
#ifdef USE_SCROLLBAR
    MAYBE_SET(RC_SCROLLBAR,             LYShowScrollbar, MSG_ENABLE_LYNXRC),
#endif
    PARSE_SET(RC_SELECT_POPUPS,         LYSelectPopups, N_("\
select_popups specifies whether the OPTIONs in a SELECT block which\n\
lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
present in the SELECT start tag, Lynx always will create a vertical list\n\
of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
as the default while a value of \"off\" will set use of radio boxes.\n\
The default can be overridden via the -popup command line toggle.\n\
")),
    MAYBE_SET(RC_SET_COOKIES,           LYSetCookies,      MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_SHOW_COLOR,            LYrcShowColor,     tbl_show_colors, N_("\
d750 62
a811 3
\"off\" \"show color\" settings will be treated as \"default\".\n\
")),
    PARSE_SET(RC_SHOW_CURSOR,           LYShowCursor, N_("\
d821 2
a822 216
")),
    PARSE_SET(RC_SHOW_DOTFILES,         show_dotfiles, N_("\
show_dotfiles specifies that the directory listing should include\n\
\"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
restricted via a command line switch.  If display of hidden files\n\
is disabled, creation of such files via Lynx also is disabled.\n\
")),
#ifdef USE_READPROGRESS
    MAYBE_ENU(RC_SHOW_KB_RATE,          LYTransferRate,    tbl_transfer_rate,
	      MSG_ENABLE_LYNXRC),
#endif
    PARSE_ENU(RC_SUB_BOOKMARKS,         LYMultiBookmarks,  tbl_multi_bookmarks, N_("\
If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
been defined (see below), then all bookmark operations will first\n\
prompt the user to select an active sub-bookmark file.  If the default\n\
Lynx bookmark_file is defined (see above), it will be used as the\n\
default selection.  When this option is set to \"advanced\", and the\n\
user mode is advanced, the 'v'iew bookmark command will invoke a\n\
statusline prompt instead of the menu seen in novice and intermediate\n\
user modes.  When this option is set to \"standard\", the menu will be\n\
presented regardless of user mode.\n\
")),
    MAYBE_FUN(RC_TAGSOUP,               get_tagsoup,        put_tagsoup,
              MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_UNDERLINE_LINKS,       LYUnderlineLinks,   MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_USER_MODE,             user_mode,          tbl_user_mode, N_("\
user_mode specifies the users level of knowledge with Lynx.  The\n\
default is \"NOVICE\" which displays two extra lines of help at the\n\
bottom of the screen to aid the user in learning the basic Lynx\n\
commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
bottom of the screen.\n\
")),
    MAYBE_STR(RC_USERAGENT,             LYUserAgent,        MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_VERBOSE_IMAGES,        verbose_img, N_("\
If verbose_images is \"on\", lynx will print the name of the image\n\
source file in place of [INLINE], [LINK] or [IMAGE]\n\
See also VERBOSE_IMAGES in lynx.cfg\n\
")),
    PARSE_SET(RC_VI_KEYS,               vi_keys, N_("\
If vi_keys is set to \"on\", then the normal VI movement keys:\n\
  j = down    k = up\n\
  h = left    l = right\n\
will be enabled.  These keys are only lower case.\n\
Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
and the keymap display, respectively.\n\
")),
    PARSE_ENU(RC_VISITED_LINKS,         Visited_Links_As,   tbl_visited_links, N_("\
The visited_links setting controls how Lynx organizes the information\n\
in the Visited Links Page.\n\
")),

    PARSE_NIL
};
/* *INDENT-ON* */

static Config_Type *lookup_config(const char *name)
{
    Config_Type *tbl = Config_Table;
    char ch = (char) TOUPPER(*name);

    while (tbl->name != 0) {
	if (tbl->enabled) {
	    char ch1 = tbl->name[0];

	    if ((ch == TOUPPER(ch1))
		&& (0 == strcasecomp(name, tbl->name)))
		break;
	}

	tbl++;
    }
    return tbl;
}

/* Read and process user options.  If the passed-in fp is NULL, open the
 * regular user defaults file for reading, otherwise use fp which has to be a
 * file open for reading.  - kw
 */
void read_rc(FILE *fp)
{
    char *buffer = NULL;
    char rcfile[LY_MAXPATH];
    char MBM_line[256];
    int n;

    if (!fp) {
	/*
	 * Make an RC file name, open it for reading.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);
	if ((fp = fopen(rcfile, TXT_R)) == NULL) {
	    return;
	}
	CTRACE((tfp, "read_rc opened %s\n", rcfile));
    } else {
	CTRACE((tfp, "read_rc used passed-in stream\n"));
    }

    /*
     * Process the entries.
     */
    while (LYSafeGets(&buffer, fp) != NULL) {
	char *name, *value, *notes;
	Config_Type *tbl;
	ParseUnionPtr q;

	/* Most lines in the config file are comment lines.  Weed them out
	 * now.  Also, leading whitespace is ok, so trim it.
	 */
	LYTrimTrailing(buffer);
	name = LYSkipBlanks(buffer);
	if (ispunct(UCH(*name)) || *name == '\0')
	    continue;

	/*
	 * Parse the "name=value" strings.
	 */
	if ((value = strchr(name, '=')) == 0) {
	    CTRACE((tfp, "LYrcFile: missing '=' %s\n", name));
	    continue;
	}
	*value++ = '\0';
	LYTrimTrailing(name);
	value = LYSkipBlanks(value);
	CTRACE2(TRACE_CFG, (tfp, "LYrcFile %s:%s\n", name, value));

	tbl = lookup_config(name);
	if (tbl->name == 0) {
	    const char *special = RC_MULTI_BOOKMARK;

	    if (!strncasecomp(name, special, strlen(special))) {
		tbl = lookup_config(special);
	    }
	    /* lynx ignores unknown keywords */
	    if (tbl->name == 0) {
		CTRACE((tfp, "LYrcFile: ignored %s=%s\n", name, value));
		continue;
	    }
	}

	q = ParseUnionOf(tbl);
	switch (tbl->type) {
	case CONF_BOOL:
	    if (q->set_value != 0)
		*(q->set_value) = getBool(value);
	    break;

	case CONF_FUN:
	    if (q->fun_value != 0)
		(*(q->fun_value)) (value);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n) {
		if (!strcasecomp(value, tbl->strings[n])) {
		    *(q->int_value) = n;
		    break;
		}
	    }
	    break;

	case CONF_ENUM:
	    if (tbl->table != 0)
		LYgetEnum(tbl->table, value, q->int_value);
	    break;

	case CONF_INT:
	    if (q->int_value != 0) {
		int ival;

		if (1 == sscanf(value, "%d", &ival))
		    *(q->int_value) = ival;
	    }
	    break;

	case CONF_LIS:
	    if (q->str_value != 0) {
		if (*(q->str_value) != NULL)
		    StrAllocCat(*(q->str_value), ",");
		StrAllocCat(*(q->str_value), value);
	    }
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		sprintf(MBM_line, "multi_bookmark%c", LYindex2MBM(n));

		if (!strcasecomp(name, MBM_line)) {
		    if ((notes = strchr(value, ',')) != 0) {
			*notes++ = '\0';
			LYTrimTrailing(value);
			notes = LYSkipBlanks(notes);
		    } else {
			notes = value + strlen(value);
		    }
		    StrAllocCopy(MBM_A_subbookmark[n], value);
		    StrAllocCopy(MBM_A_subdescript[n], notes);
		    break;
		}
	    }
	    break;

	case CONF_STR:
	    if (q->str_value != 0)
		StrAllocCopy(*(q->str_value), value);
	    break;

	case CONF_NIL:
	    break;
	}
    }

    LYCloseInput(fp);
    LYConfigCookies();		/* update cookie settings, if any */
a823 1
#if defined(USE_SLANG) || defined(COLOR_CURSES)
d825 1
a825 1
     * We may override the commandline "-color" option with the .lynxrc file
a826 45
    switch (LYrcShowColor) {
    case SHOW_COLOR_ALWAYS:
	if (LYShowColor != SHOW_COLOR_NEVER)
	    LYShowColor = SHOW_COLOR_ALWAYS;
	break;
    case SHOW_COLOR_NEVER:
	if (LYShowColor == SHOW_COLOR_ON)
	    LYShowColor = SHOW_COLOR_OFF;
	break;
    default:
	/* don't override */
	break;
    }
#endif
    set_default_bookmark_page(bookmark_page);
}

/*
 * Write a set of comments.  Doing it this way avoids preprocessor problems
 * with the leading '#', makes it simpler to use gettext.
 */
static void write_list(FILE *fp, const char *list)
{
    int first = TRUE;

    while (*list != 0) {
	int ch = *list++;

	if (ch == '\n') {
	    first = TRUE;
	} else {
	    if (first) {
		fputs("# ", fp);
		first = FALSE;
	    }
	}
	fputc(ch, fp);
    }
}

/*
 * This is too long for some compilers.
 */
static void explain_keypad_mode(FILE *fp)
{
d854 4
a857 1
}
d859 15
a873 10
/* Save user options.  If the passed-in fp is NULL, open the regular user
 * defaults file for writing, otherwise use fp which has to be a temp file open
 * for writing.  - kw
 */
int save_rc(FILE *fp)
{
    Config_Type *tbl = Config_Table;
    char rcfile[LY_MAXPATH];
    BOOLEAN is_tempfile = (BOOL) (fp != NULL);
    int n;
d875 21
a895 11
    if (!fp) {
	/*
	 * Make a name.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

	/*
	 * Open the file for write.
	 */
	if ((fp = LYNewTxtFile(rcfile)) == NULL) {
	    return FALSE;
d898 49
d949 5
a953 10
Lynx User Defaults File\n\
\n\
This file contains options saved from the Lynx Options Screen (normally\n\
with the '>' key).  There is normally no need to edit this file manually,\n\
since the defaults here can be controlled from the Options Screen, and the\n\
next time options are saved from the Options Screen this file will be\n\
completely rewritten.  You have been warned...\n\
If you are looking for the general configuration file - it is normally\n\
called lynx.cfg, and it has different content and a different format.\n\
It is not this file.\n\
d955 7
a961 1
    fprintf(fp, "\n");
d963 18
a980 2
    while (tbl->name != 0) {
	ParseUnionPtr q = ParseUnionOf(tbl);
a981 9
	if (!tbl->enabled) {
	    tbl++;
	    continue;
	}
	if (tbl->note != NULL) {
	    write_list(fp, gettext(tbl->note));
	} else if (tbl->table == tbl_keypad_mode) {
	    explain_keypad_mode(fp);
	}
d983 11
a993 38
	switch (tbl->type) {
	case CONF_BOOL:
	    fprintf(fp, "%s=%s\n\n", tbl->name, putBool(*(q->set_value)));
	    break;

	case CONF_FUN:
	    if (tbl->write_it != 0)
		tbl->write_it(fp, tbl);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n)
		fprintf(fp, "#    %s\n", tbl->strings[n]);
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    tbl->strings[*(q->int_value)]);
	    break;

	case CONF_ENUM:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    LYputEnum(tbl->table, *(q->int_value)));
	    break;

	case CONF_INT:
	    fprintf(fp, "%s=%d\n\n", tbl->name, *(q->int_value));
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		fprintf(fp, "multi_bookmark%c=", LYindex2MBM(n));

		fprintf(fp, "%s", NonNull(MBM_A_subbookmark[n]));
		if (MBM_A_subdescript[n] != 0
		    && *MBM_A_subdescript[n] != 0)
		    fprintf(fp, ",%s", MBM_A_subdescript[n]);
		fprintf(fp, "\n");
	    }
	    fprintf(fp, "\n");
	    break;
a994 8
	case CONF_LIS:
	    /* FALLTHRU */
	case CONF_STR:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    (q->str_value != 0 && *(q->str_value) != 0)
		    ? *(q->str_value)
		    : "");
	    break;
a995 5
	case CONF_NIL:
	    break;
	}
	tbl++;
    }
d997 1
d999 1
a999 1
     * Close the RC file.
d1001 13
a1013 6
    if (is_tempfile) {
	LYCloseTempFP(fp);
    } else {
	LYCloseOutput(fp);
	HTSYS_purge(rcfile);
    }
d1015 20
a1034 2
    return TRUE;
}
d1036 7
a1042 6
/*
 * Returns true if the given name would be saved in .lynxrc
 */
BOOL will_save_rc(const char *name)
{
    Config_Type *tbl = lookup_config(name);
d1044 4
a1047 2
    return tbl->name != 0;
}
d1049 1
a1049 4
int enable_lynxrc(char *value)
{
    Config_Type *tbl;
    char *colon = strchr(value, ':');
d1051 1
a1051 14
    if (colon != 0) {
	*colon++ = 0;
	LYTrimLeading(value);
	LYTrimTrailing(value);

	for (tbl = Config_Table; tbl->name != 0; tbl++) {
	    if (!strcasecomp(value, tbl->name)) {
		tbl->enabled = getBool(colon);
		CTRACE((tfp, "enable_lynxrc(%s) %s\n", value, putBool(tbl->enabled)));
		break;
	    }
	}
    }
    return 0;
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a10 1
#include <HTMLDTD.h>
d20 3
a22 2
#define MSG_ENABLE_LYNXRC N_("Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n")
#define putBool(value) ((value) ? "on" : "off")
d24 347
a370 9
PUBLIC Config_Enum tbl_DTD_recovery[] = {
    { "true",		TRUE },
    { "false",		FALSE },
    { "on",		TRUE },
    { "off",		FALSE },
    { "sortasgml",	TRUE },
    { "tagsoup",	FALSE },
    { NULL,		-1 },
};
d373 13
a385 20
PRIVATE Config_Enum tbl_dir_list_style[] = {
    { "FILES_FIRST",	FILES_FIRST },
    { "DIRECTORIES_FIRST", DIRS_FIRST },
    { "MIXED_STYLE",	MIXED_STYLE },
    { NULL,		MIXED_STYLE },
};
#ifdef LONG_LIST
PRIVATE Config_Enum tbl_dir_list_order[] = {
    { "ORDER_BY_NAME",	ORDER_BY_NAME },
    { "ORDER_BY_TYPE",	ORDER_BY_TYPE },
    { "ORDER_BY_SIZE",  ORDER_BY_SIZE },
    { "ORDER_BY_DATE",	ORDER_BY_DATE },
    { "ORDER_BY_MODE",	ORDER_BY_MODE },
#ifndef NO_GROUPS
    { "ORDER_BY_USER",	ORDER_BY_USER },
    { "ORDER_BY_GROUP",	ORDER_BY_GROUP },
#endif
    { NULL,		ORDER_BY_NAME },
};
#endif /* LONG_LIST */
d388 10
a397 50
PRIVATE Config_Enum tbl_file_sort[] = {
    { "BY_FILENAME",	FILE_BY_NAME },
    { "BY_TYPE",	FILE_BY_TYPE },
    { "BY_SIZE",	FILE_BY_SIZE },
    { "BY_DATE",	FILE_BY_DATE },
    { NULL,		-1 },
};

PUBLIC Config_Enum tbl_keypad_mode[] = {
    { "FIELDS_ARE_NUMBERED", FIELDS_ARE_NUMBERED },
    { "LINKS_AND_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "LINKS_ARE_NUMBERED", LINKS_ARE_NUMBERED },
    { "LINKS_ARE_NOT_NUMBERED", NUMBERS_AS_ARROWS },
    /* obsolete variations: */
    { "LINKS_AND_FORM_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "NUMBERS_AS_ARROWS", NUMBERS_AS_ARROWS },
    { NULL,		DEFAULT_KEYPAD_MODE }
};

PUBLIC Config_Enum tbl_multi_bookmarks[] = {
    { "OFF",		MBM_OFF },
    { "STANDARD",	MBM_STANDARD },
    { "ON",		MBM_STANDARD },
    { "ADVANCED",	MBM_ADVANCED },
    { NULL,		-1 }
};

PRIVATE Config_Enum tbl_show_colors[] = {
    { "default",	SHOW_COLOR_UNKNOWN },
    { "default",	SHOW_COLOR_OFF },
    { "default",	SHOW_COLOR_ON },
    { "on",		SHOW_COLOR_UNKNOWN },
    { "off",		SHOW_COLOR_UNKNOWN },
    { "never",		SHOW_COLOR_NEVER },
    { "always",		SHOW_COLOR_ALWAYS },
    { NULL,		SHOW_COLOR_UNKNOWN }
};

PUBLIC Config_Enum tbl_transfer_rate[] = {
    { "NONE",		rateOFF },
    { "KB",		rateKB },
    { "TRUE",		rateKB },
    { "BYTES",		rateBYTES },
    { "FALSE",		rateBYTES },
#ifdef EXP_READPROGRESS
    { "KB,ETA",		rateEtaKB },
    { "BYTES,ETA",	rateEtaBYTES },
#endif
    { NULL,		-1 },
};
a398 22
PUBLIC Config_Enum tbl_user_mode[] = {
    { "ADVANCED",	ADVANCED_MODE },
    { "INTERMEDIATE",	INTERMEDIATE_MODE },
    { "NOVICE",		NOVICE_MODE },
    { NULL,		NOVICE_MODE }
};

PRIVATE Config_Enum tbl_visited_links[] = {
    { "FIRST_REVERSED",	VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE },
    { "FIRST",		VISITED_LINKS_AS_FIRST_V },
    { "TREE",		VISITED_LINKS_AS_TREE    },
    { "LAST_REVERSED",	VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE },
    { "LAST",		VISITED_LINKS_AS_LATEST  },
    { NULL,		DEFAULT_VISITED_LINKS }
};

PUBLIC Config_Enum tbl_force_prompt[] = {
    { "default",	FORCE_PROMPT_DFT	},
    { "yes",		FORCE_PROMPT_YES	},
    { "no",		FORCE_PROMPT_NO		},
    { NULL,		-1			}
};
d400 10
a409 4
PRIVATE BOOL getBool ARGS1(char *, src)
{
    return (BOOL) (!strncasecomp(src, "on", 2) || !strncasecomp(src, "true", 4));
}
a410 12
PUBLIC CONST char *LYputEnum ARGS2(
    Config_Enum *,	table,
    int,		value)
{
    while (table->name != 0) {
	if (table->value == value) {
	    return table->name;
	}
	table++;
    }
    return "?";
}
d412 8
a419 18
PUBLIC BOOL LYgetEnum ARGS3(
    Config_Enum *,	table,
    char *,		name,
    int *,		result)
{
    Config_Enum *found = 0;
    unsigned len = strlen(name);
    int match = 0;

    if (len != 0) {
	while (table->name != 0) {
	    if (!strncasecomp(table->name, name, len)) {
		found = table;
		if (!strcasecomp(table->name, name)) {
		    match = 1;
		    break;
		}
		++match;
d421 17
a437 9
	    table++;
	}
	if (match == 1) {	/* if unambiguous */
	    *result = found->value;
	    return TRUE;
	}
    }
    return FALSE;		/* no match */
}
d439 7
a445 31
/* these are for data that are normally not read/written from .lynxrc */
#define PARSE_SET(n,v,h)   {n,    1, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define PARSE_ARY(n,v,t,h) {n,    1, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define PARSE_ENU(n,v,t,h) {n,    1, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define PARSE_LIS(n,v,h)   {n,    1, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_STR(n,v,h)   {n,    1, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_FUN(n,v,w,h) {n,    1, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define PARSE_MBM(n,h)     {n,    1, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

/* these are for data that are optionally read/written from .lynxrc */
#define MAYBE_SET(n,v,h)   {n,    0, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define MAYBE_ARY(n,v,t,h) {n,    0, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define MAYBE_ENU(n,v,t,h) {n,    0, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define MAYBE_LIS(n,v,h)   {n,    0, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_STR(n,v,h)   {n,    0, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_FUN(n,v,w,h) {n,    0, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define MAYBE_MBM(n,h)     {n,    0, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

#define PARSE_NIL          {NULL, 1, 0,          UNION_DEF(0), 0, 0, 0, 0}

typedef enum {
    CONF_UNSPECIFIED = 0
    ,CONF_ARRAY
    ,CONF_BOOL
    ,CONF_FUN
    ,CONF_INT
    ,CONF_ENUM
    ,CONF_LIS
    ,CONF_MBM
    ,CONF_STR
} Conf_Types;
d447 13
a459 11
typedef struct config_type
{
    CONST char *name;
    int enabled;		/* see lynx.cfg ENABLE_LYNXRC "off" lines */
    Conf_Types type;
    ParseData;
    char **strings;
    Config_Enum *table;
    void (*write_it) PARAMS((FILE * fp, struct config_type *));
    char *note;
} Config_Type;
d461 8
a468 3
PRIVATE int get_assume_charset ARGS1(char *, value)
{
    int i;
d470 12
a481 8
    for (i = 0; i < LYNumCharsets; ++i) {
    	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
	    UCLYhndl_for_unspec = i;
	    break;
	}
    }
    return 0;
}
d483 5
a487 3
PRIVATE void put_assume_charset ARGS2(FILE *, fp, struct config_type *, tbl)
{
    int i;
d489 5
a493 4
    for (i = 0; i < LYNumCharsets; ++i)
	fprintf(fp, "#    %s\n", LYCharSet_UC[i].MIMEname);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
}
d495 17
a511 3
PRIVATE int get_display_charset ARGS1(char *, value)
{
    int i = 0;
d513 1
a513 5
    i = UCGetLYhndl_byAnyName(value); /* by MIME or full name */
    if (i >= 0)
	current_char_set = i;
    return 0;
}
d515 1
a515 3
PRIVATE void put_display_charset ARGS2(FILE *, fp, struct config_type *, tbl)
{
    int i;
d517 2
a518 4
    for (i = 0; LYchar_set_names[i]; i++)
	fprintf(fp, "#    %s\n", LYchar_set_names[i]);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYchar_set_names[current_char_set]);
}
d520 7
a526 1
PRIVATE int get_editor ARGS1(char *, value)
d528 13
a540 3
    if (!system_editor)
	StrAllocCopy(editor, value);
    return 0;
d543 1
a543 1
PRIVATE void put_editor ARGS2(FILE *, fp, struct config_type *, tbl)
d545 4
a548 2
    fprintf(fp, "%s=%s\n\n", tbl->name, NonNull(editor));
}
d550 4
a553 3
PUBLIC int get_tagsoup ARGS1(char *, value)
{
    int found = Old_DTD;
d555 5
a559 4
    if (LYgetEnum(tbl_DTD_recovery, value, &found)
     && Old_DTD != found) {
	Old_DTD = found;
	HTSwitchDTD(!Old_DTD);
a560 2
    return 0;
}
d562 16
a577 4
PRIVATE void put_tagsoup ARGS2(FILE *, fp, struct config_type *, tbl)
{
    fprintf(fp, "%s=%s\n\n", tbl->name, LYputEnum(tbl_DTD_recovery, Old_DTD));
}
d579 4
a582 74
/* This table is searched ignoring case */
static Config_Type Config_Table [] =
{
    PARSE_SET(RC_ACCEPT_ALL_COOKIES,    LYAcceptAllCookies, N_("\
accept_all_cookies allows the user to tell Lynx to automatically\n\
accept all cookies if desired.  The default is \"FALSE\" which will\n\
prompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\n\
all cookies.\n\
")),
    MAYBE_FUN(RC_ASSUME_CHARSET,        get_assume_charset, put_assume_charset, MSG_ENABLE_LYNXRC),
    PARSE_STR(RC_BOOKMARK_FILE,         bookmark_page,     N_("\
bookmark_file specifies the name and location of the default bookmark\n\
file into which the user can paste links for easy access at a later\n\
date.\n\
")),
    PARSE_SET(RC_CASE_SENSITIVE_SEARCHING, case_sensitive, N_("\
If case_sensitive_searching is \"on\" then when the user invokes a search\n\
using the 's' or '/' keys, the search performed will be case sensitive\n\
instead of case INsensitive.  The default is usually \"off\".\n\
")),
    PARSE_FUN(RC_CHARACTER_SET,         get_display_charset, put_display_charset, N_("\
The character_set definition controls the representation of 8 bit\n\
characters for your terminal.  If 8 bit characters do not show up\n\
correctly on your screen you may try changing to a different 8 bit\n\
set or using the 7 bit character approximations.\n\
Current valid characters sets are:\n\
")),
    PARSE_LIS(RC_COOKIE_ACCEPT_DOMAINS, LYCookieAcceptDomains, N_("\
cookie_accept_domains and cookie_reject_domains are comma-delimited\n\
lists of domains from which Lynx should automatically accept or reject\n\
all cookies.  If a domain is specified in both options, rejection will\n\
take precedence.  The accept_all_cookies parameter will override any\n\
settings made here.\n\
")),
#ifdef EXP_PERSISTENT_COOKIES
    PARSE_STR(RC_COOKIE_FILE,	        LYCookieFile, N_("\
cookie_file specifies the file from which to read persistent cookies.\n\
The default is ~/.lynx_cookies.\n\
")),
#endif
    PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieLooseCheckDomains, N_("\
cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\n\
cookie_query_invalid_domains are comma-delimited lists of which domains\n\
should be subjected to varying degrees of validity checking.  If a\n\
domain is set to strict checking, strict conformance to RFC2109 will\n\
be applied.  A domain with loose checking will be allowed to set cookies\n\
with an invalid path or domain attribute.  All domains will default to\n\
querying the user for an invalid path or domain.\n\
")),
    PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieQueryCheckDomains, NULL),
    PARSE_LIS(RC_COOKIE_REJECT_DOMAINS, LYCookieRejectDomains, NULL),
    PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieStrictCheckDomains, NULL),
#ifdef DIRED_SUPPORT
#ifdef LONG_LIST
    PARSE_ENU(RC_DIR_LIST_ORDER,        dir_list_order,     tbl_dir_list_order, N_("\
dir_list_order specifies the directory list order under DIRED_SUPPORT\n\
(if implemented).  The default is \"ORDER_BY_NAME\"\n\
")),
#endif
    PARSE_ENU(RC_DIR_LIST_STYLE,        dir_list_style,     tbl_dir_list_style, N_("\
dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
(if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
files and directories together.  \"FILES_FIRST\" lists files first and\n\
\"DIRECTORIES_FIRST\" lists directories first.\n\
")),
#endif
    MAYBE_STR(RC_DISPLAY,               x_display,          MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_EMACS_KEYS,            emacs_keys, N_("\
If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
  ^N = down    ^P = up\n\
  ^B = left    ^F = right\n\
will be enabled.\n\
")),
    PARSE_FUN(RC_FILE_EDITOR,           get_editor,         put_editor, N_("\
d587 56
a642 2
")),
    PARSE_ENU(RC_FILE_SORTING_METHOD,   HTfileSortMethod,   tbl_file_sort, N_("\
d649 13
a661 33
")),
    MAYBE_ENU(RC_FORCE_COOKIE_PROMPT,   cookie_noprompt,    tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#ifdef USE_SSL
    MAYBE_ENU(RC_FORCE_SSL_PROMPT,      ssl_noprompt,       tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#endif
#ifdef EXP_KEYBOARD_LAYOUT
    PARSE_ARY(RC_KBLAYOUT,              current_layout,     LYKbLayoutNames, NULL),
#endif
    PARSE_ENU(RC_KEYPAD_MODE,           keypad_mode,        tbl_keypad_mode, NULL),
    PARSE_ARY(RC_LINEEDIT_MODE,         current_lineedit,   LYLineeditNames, N_("\
lineedit_mode specifies the key binding used for inputting strings in\n\
prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
the following control characters are used for moving and deleting:\n\
\n\
             Prev  Next       Enter = Accept input\n\
   Move char: <-    ->        ^G    = Cancel input\n\
   Move word: ^P    ^N        ^U    = Erase line\n\
 Delete char: ^H    ^R        ^A    = Beginning of line\n\
 Delete word: ^B    ^F        ^E    = End of line\n\
\n\
Current lineedit modes are:\n\
")),
    MAYBE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts, MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images, MSG_ENABLE_LYNXRC),
    PARSE_MBM(RC_MULTI_BOOKMARK, N_("\
The following allow you to define sub-bookmark files and descriptions.\n\
The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
Up to 26 bookmark files (for the English capital letters) are allowed.\n\
We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n\
")),
    PARSE_STR(RC_PERSONAL_MAIL_ADDRESS, personal_mail_address, N_("\
d669 46
a714 2
")),
    PARSE_STR(RC_PREFERRED_CHARSET,     pref_charset, N_("\
d727 9
a735 50
")),
    PARSE_STR(RC_PREFERRED_LANGUAGE,    language, N_("\
preferred_language specifies the language in MIME notation (e.g., en,\n\
fr, may be a comma-separated list in decreasing preference)\n\
which Lynx will indicate you prefer in requests to http servers.\n\
If a file in that language is available, the server will send it.\n\
Otherwise, the server will send the file in its default language.\n\
")),
    MAYBE_SET(RC_RAW_MODE,              LYRawMode,          MSG_ENABLE_LYNXRC),
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PARSE_SET(RC_RUN_ALL_EXECUTION_LINKS, local_exec, N_("\
If run_all_execution_links is set \"on\" then all local execution links\n\
will be executed when they are selected.\n\
\n\
WARNING - This is potentially VERY dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
    PARSE_SET(RC_RUN_EXECUTION_LINKS_LOCAL, local_exec_on_local_files, N_("\
If run_execution_links_on_local_files is set \"on\" then all local\n\
execution links that are found in LOCAL files will be executed when they\n\
are selected.  This is different from run_all_execution_links in that\n\
only files that reside on the local system will have execution link\n\
permissions.\n\
\n\
WARNING - This is potentially dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
#endif
#ifdef USE_SCROLLBAR
    MAYBE_SET(RC_SCROLLBAR,             LYShowScrollbar, MSG_ENABLE_LYNXRC),
#endif
    PARSE_SET(RC_SELECT_POPUPS,         LYSelectPopups, N_("\
select_popups specifies whether the OPTIONs in a SELECT block which\n\
lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
present in the SELECT start tag, Lynx always will create a vertical list\n\
of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
as the default while a value of \"off\" will set use of radio boxes.\n\
The default can be overridden via the -popup command line toggle.\n\
")),
    MAYBE_SET(RC_SET_COOKIES,           LYSetCookies,      MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_SHOW_COLOR,            LYrcShowColor,     tbl_show_colors, N_("\
d751 5
a755 109
")),
    PARSE_SET(RC_SHOW_CURSOR,           LYShowCursor, N_("\
show_cursor specifies whether to 'hide' the cursor to the right (and\n\
bottom, if possible) of the screen, or to place it to the left of the\n\
current link in documents, or current option in select popup windows.\n\
Positioning the cursor to the left of the current link or option is\n\
helpful for speech or braille interfaces, and when the terminal is\n\
one which does not distinguish the current link based on highlighting\n\
or color.  A value of \"on\" will set positioning to the left as the\n\
default while a value of \"off\" will set 'hiding' of the cursor.\n\
The default can be overridden via the -show_cursor command line toggle.\n\
")),
    PARSE_SET(RC_SHOW_DOTFILES,         show_dotfiles, N_("\
show_dotfiles specifies that the directory listing should include\n\
\"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
restricted via a command line switch.  If display of hidden files\n\
is disabled, creation of such files via Lynx also is disabled.\n\
")),
#ifdef EXP_READPROGRESS
    MAYBE_ENU(RC_SHOW_KB_RATE,          LYTransferRate,    tbl_transfer_rate,
	      MSG_ENABLE_LYNXRC),
#endif
    PARSE_ENU(RC_SUB_BOOKMARKS,         LYMultiBookmarks,  tbl_multi_bookmarks, N_("\
If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
been defined (see below), then all bookmark operations will first\n\
prompt the user to select an active sub-bookmark file.  If the default\n\
Lynx bookmark_file is defined (see above), it will be used as the\n\
default selection.  When this option is set to \"advanced\", and the\n\
user mode is advanced, the 'v'iew bookmark command will invoke a\n\
statusline prompt instead of the menu seen in novice and intermediate\n\
user modes.  When this option is set to \"standard\", the menu will be\n\
presented regardless of user mode.\n\
")),
    MAYBE_FUN(RC_TAGSOUP,               get_tagsoup,        put_tagsoup,
              MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_USER_MODE,             user_mode,          tbl_user_mode, N_("\
user_mode specifies the users level of knowledge with Lynx.  The\n\
default is \"NOVICE\" which displays two extra lines of help at the\n\
bottom of the screen to aid the user in learning the basic Lynx\n\
commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
bottom of the screen.\n\
")),
    MAYBE_STR(RC_USERAGENT,             LYUserAgent,        MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_VERBOSE_IMAGES,        verbose_img, N_("\
If verbose_images is \"on\", lynx will print the name of the image\n\
source file in place of [INLINE], [LINK] or [IMAGE]\n\
See also VERBOSE_IMAGES in lynx.cfg\n\
")),
    PARSE_SET(RC_VI_KEYS,               vi_keys, N_("\
If vi_keys is set to \"on\", then the normal VI movement keys:\n\
  j = down    k = up\n\
  h = left    l = right\n\
will be enabled.  These keys are only lower case.\n\
Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
and the keymap display, respectively.\n\
")),
    PARSE_ENU(RC_VISITED_LINKS,         Visited_Links_As,   tbl_visited_links, N_("\
The visited_links setting controls how Lynx organizes the information\n\
in the Visited Links Page.\n\
")),

    PARSE_NIL
};

PRIVATE Config_Type *lookup_config ARGS1(
	char *,		name)
{
    Config_Type *tbl = Config_Table;
    char ch = (char) TOUPPER(*name);

    while (tbl->name != 0) {
	if (tbl->enabled) {
	    char ch1 = tbl->name[0];

	    if ((ch == TOUPPER(ch1))
		&& (0 == strcasecomp (name, tbl->name)))
		break;
	}

	tbl++;
    }
    return tbl;
}

/*  Read and process user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for reading, otherwise use fp which has to be a file open for
 *  reading. - kw
 */
PUBLIC void read_rc ARGS1(FILE *, fp)
{
    char *buffer = NULL;
    char rcfile[LY_MAXPATH];
    char MBM_line[256];
    int  n;

    if (!fp) {
	/*
	 *  Make an RC file name, open it for reading.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);
	if ((fp = fopen(rcfile, TXT_R)) == NULL) {
	    return;
	}
	CTRACE((tfp, "read_rc opened %s\n", rcfile));
    } else {
	CTRACE((tfp, "read_rc used passed-in stream\n"));
d759 1
a759 1
     *  Process the entries.
d761 9
a769 12
    while (LYSafeGets(&buffer, fp) != NULL) {
	char *name, *value, *notes;
	Config_Type *tbl;
	ParseUnionPtr q;

	/* Most lines in the config file are comment lines.  Weed them out
	 * now.  Also, leading whitespace is ok, so trim it.
	 */
	LYTrimTrailing(buffer);
	name = LYSkipBlanks(buffer);
	if (ispunct(UCH(*name)) || *name == '\0')
	    continue;
d771 10
a780 24
	/*
	 * Parse the "name=value" strings.
	 */
	if ((value = strchr(name, '=')) == 0) {
	    CTRACE((tfp, "LYrcFile: missing '=' %s\n", name));
	    continue;
	}
	*value++ = '\0';
	LYTrimTrailing(name);
	value = LYSkipBlanks(value);
	CTRACE2(TRACE_CFG, (tfp, "LYrcFile %s:%s\n", name, value));

	tbl = lookup_config(name);
	if (tbl->name == 0) {
	    char *special = RC_MULTI_BOOKMARK;
	    if (!strncasecomp(name, special, strlen(special))) {
		tbl = lookup_config(special);
	    }
	    /* lynx ignores unknown keywords */
	    if (tbl->name == 0) {
		CTRACE((tfp, "LYrcFile: ignored %s=%s\n", name, value));
		continue;
	    }
	}
d782 11
a792 20
	q = ParseUnionOf(tbl);
	switch (tbl->type) {
	case CONF_BOOL:
	    if (q->set_value != 0)
		*(q->set_value) = getBool (value);
	    break;

	case CONF_FUN:
	    if (q->fun_value != 0)
		(*(q->fun_value)) (value);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n) {
		if (!strcasecomp(value, tbl->strings[n])) {
		    *(q->int_value) = n;
		    break;
		}
	    }
	    break;
d794 13
a806 12
	case CONF_ENUM:
	    if (tbl->table != 0)
		LYgetEnum(tbl->table, value, q->int_value);
	    break;

	case CONF_INT:
	    if (q->int_value != 0) {
		int ival;
		if (1 == sscanf (value, "%d", &ival))
		    *(q->int_value) = ival;
	    }
	    break;
d808 15
a822 39
	case CONF_LIS:
	    if (q->str_value != 0) {
		if (*(q->str_value) != NULL)
		    StrAllocCat(*(q->str_value), ",");
		StrAllocCat(*(q->str_value), value);
	    }
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		sprintf(MBM_line, "multi_bookmark%c", LYindex2MBM(n));

		if (!strcasecomp(name, MBM_line)) {
		    if ((notes = strchr(value, ',')) != 0) {
			*notes++ = '\0';
			LYTrimTrailing(value);
			notes = LYSkipBlanks(notes);
		    } else {
			notes = value + strlen(value);
		    }
		    StrAllocCopy(MBM_A_subbookmark[n], value);
		    StrAllocCopy(MBM_A_subdescript[n], notes);
		    break;
		}
	    }
	    break;

	case CONF_STR:
	    if (q->str_value != 0)
		StrAllocCopy(*(q->str_value), value);
	    break;

	case CONF_UNSPECIFIED:
	    break;
	}
    }

    LYCloseInput(fp);
    LYConfigCookies();	/* update cookie settings, if any */
a823 1
#if defined(USE_SLANG) || defined(COLOR_CURSES)
d825 1
a825 1
     * We may override the commandline "-color" option with the .lynxrc file
a826 45
    switch (LYrcShowColor) {
    case SHOW_COLOR_ALWAYS:
	if (LYShowColor != SHOW_COLOR_NEVER)
	    LYShowColor = SHOW_COLOR_ALWAYS;
	break;
    case SHOW_COLOR_NEVER:
	if (LYShowColor == SHOW_COLOR_ON)
	    LYShowColor = SHOW_COLOR_OFF;
	break;
    default:
	/* don't override */
	break;
    }
#endif
    set_default_bookmark_page(bookmark_page);
}

/*
 * Write a set of comments.  Doing it this way avoids preprocessor problems
 * with the leading '#', makes it simpler to use gettext.
 */
PRIVATE void write_list ARGS2(
    	FILE *,		fp,
	char *,		list)
{
    int first = TRUE;
    while (*list != 0) {
	int ch = *list++;
	if (ch == '\n') {
	    first = TRUE;
	} else {
	    if (first) {
		fputs("# ", fp);
		first = FALSE;
	    }
	}
	fputc(ch, fp);
    }
}

/*
 * This is too long for some compilers.
 */
PRIVATE void explain_keypad_mode ARGS1(FILE *, fp)
{
d854 4
a857 1
}
d859 15
a873 11
/*  Save user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for writing, otherwise use fp which has to be a temp file open for
 *  writing. - kw
 */
PUBLIC int save_rc ARGS1(FILE *, fp)
{
    Config_Type *tbl = Config_Table;
    char rcfile[LY_MAXPATH];
    BOOLEAN is_tempfile = (BOOL) (fp != NULL);
    int n;
d875 21
a895 11
    if (!fp) {
	/*
	 *  Make a name.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

	/*
	 *  Open the file for write.
	 */
	if ((fp = LYNewTxtFile(rcfile)) == NULL) {
	    return FALSE;
d898 64
d964 7
a970 10
Lynx User Defaults File\n\
\n\
This file contains options saved from the Lynx Options Screen (normally\n\
with the '>' key).  There is normally no need to edit this file manually,\n\
since the defaults here can be controlled from the Options Screen, and the\n\
next time options are saved from the Options Screen this file will be\n\
completely rewritten.  You have been warned...\n\
If you are looking for the general configuration file - it is normally\n\
called lynx.cfg, and it has different content and a different format.\n\
It is not this file.\n\
d972 9
a980 1
    fprintf(fp, "\n");
a981 2
    while (tbl->name != 0) {
	ParseUnionPtr q = ParseUnionOf(tbl);
d983 11
a993 8
	if (!tbl->enabled) {
	    tbl++;
	    continue;
	} if (tbl->note != NULL) {
	    write_list(fp, gettext(tbl->note));
	} else if (tbl->table == tbl_keypad_mode) {
	    explain_keypad_mode(fp);
	}
a994 38
	switch (tbl->type) {
	case CONF_BOOL:
	    fprintf(fp, "%s=%s\n\n", tbl->name, putBool(*(q->set_value)));
	    break;

	case CONF_FUN:
	    if (tbl->write_it != 0)
		tbl->write_it(fp, tbl);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n)
		fprintf(fp, "#    %s\n", tbl->strings[n]);
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    tbl->strings[*(q->int_value)]);
	    break;

	case CONF_ENUM:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    LYputEnum(tbl->table, *(q->int_value)));
	    break;

	case CONF_INT:
	    fprintf(fp, "%s=%d\n\n", tbl->name, *(q->int_value));
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		fprintf(fp, "multi_bookmark%c=", LYindex2MBM(n));

		fprintf(fp, "%s", NonNull(MBM_A_subbookmark[n]));
		if (MBM_A_subdescript[n] != 0
		 && *MBM_A_subdescript[n] != 0)
		    fprintf(fp, ",%s", MBM_A_subdescript[n]);
		fprintf(fp, "\n");
	    }
	    fprintf(fp, "\n");
	    break;
a995 8
	case CONF_LIS:
	    /* FALLTHRU */
	case CONF_STR:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
			(q->str_value != 0 && *(q->str_value) != 0)
			    ? *(q->str_value)
			    : "");
	    break;
d997 17
a1013 5
	case CONF_UNSPECIFIED:
	    break;
	}
	tbl++;
    }
d1016 1
a1016 1
     *  Close the RC file.
d1018 17
a1034 6
    if (is_tempfile) {
	LYCloseTempFP(fp);
    } else {
	LYCloseOutput(fp);
	HTSYS_purge(rcfile);
    }
d1036 7
a1042 2
    return TRUE;
}
d1044 4
a1047 8
/*
 * Returns true if the given name would be saved in .lynxrc
 */
PUBLIC BOOL will_save_rc ARGS1(char *, name)
{
    Config_Type *tbl = lookup_config(name);
    return tbl->name != 0;
}
d1049 1
a1049 5
PUBLIC int enable_lynxrc ARGS1(
	char *,		value)
{
    Config_Type *tbl;
    char *colon = strchr(value, ':');
d1051 1
a1051 14
    if (colon != 0) {
	*colon++ = 0;
	LYTrimLeading(value);
	LYTrimTrailing(value);

	for (tbl = Config_Table; tbl->name != 0; tbl++) {
	    if (!strcasecomp(value, tbl->name)) {
		tbl->enabled = getBool(colon);
		CTRACE((tfp, "enable_lynxrc(%s) %s\n", value, putBool(tbl->enabled)));
		break;
	    }
	}
    }
    return 0;
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d101 1
a101 1
#ifdef USE_READPROGRESS
d125 1
a125 1
    { "prompt",		FORCE_PROMPT_DFT	},
d326 1
a326 1
#ifdef USE_PERSISTENT_COOKIES
d516 1
a516 1
#ifdef USE_READPROGRESS
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a401 3
#ifdef EXP_LOCALE_CHARSET
    MAYBE_SET(RC_LOCALE_CHARSET,      LYLocaleCharset,        MSG_ENABLE_LYNXRC),
#endif
a532 1
    MAYBE_SET(RC_UNDERLINE_LINKS,       LYUnderlineLinks,   MSG_ENABLE_LYNXRC),
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d24 1
a24 1
Config_Enum tbl_DTD_recovery[] = {
d35 1
a35 1
static Config_Enum tbl_dir_list_style[] = {
d42 1
a42 1
static Config_Enum tbl_dir_list_order[] = {
d57 1
a57 1
static Config_Enum tbl_file_sort[] = {
d65 1
a65 1
Config_Enum tbl_keypad_mode[] = {
d76 1
a76 1
Config_Enum tbl_multi_bookmarks[] = {
d84 1
a84 1
static Config_Enum tbl_show_colors[] = {
d95 1
a95 1
Config_Enum tbl_transfer_rate[] = {
d108 1
a108 1
Config_Enum tbl_user_mode[] = {
d115 1
a115 1
static Config_Enum tbl_visited_links[] = {
d124 1
a124 1
Config_Enum tbl_force_prompt[] = {
d131 1
a131 1
static BOOL getBool (char * src)
d136 3
a138 3
const char *LYputEnum (
    Config_Enum *	table,
    int		value)
d149 4
a152 4
BOOL LYgetEnum (
    Config_Enum *	table,
    char *		name,
    int *		result)
d212 1
a212 1
    const char *name;
d218 1
a218 1
    void (*write_it) (FILE * fp, struct config_type *);
d222 1
a222 1
static int get_assume_charset (char * value)
d235 1
a235 1
static void put_assume_charset (FILE * fp, struct config_type * tbl)
d244 1
a244 1
static int get_display_charset (char * value)
d254 1
a254 1
static void put_display_charset (FILE * fp, struct config_type * tbl)
d263 1
a263 1
static int get_editor (char * value)
d270 1
a270 1
static void put_editor (FILE * fp, struct config_type * tbl)
d275 1
a275 1
int get_tagsoup (char * value)
d287 1
a287 1
static void put_tagsoup (FILE * fp, struct config_type * tbl)
d567 2
a568 2
static Config_Type *lookup_config (
	char *		name)
d592 1
a592 1
void read_rc (FILE * fp)
d752 3
a754 3
static void write_list (
    	FILE *		fp,
	char *		list)
d774 1
a774 1
static void explain_keypad_mode (FILE * fp)
d810 1
a810 1
int save_rc (FILE * fp)
d927 1
a927 1
BOOL will_save_rc (char * name)
d933 2
a934 2
int enable_lynxrc (
	char *		value)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d23 2
a24 2
/* *INDENT-OFF* */
static Config_Enum tbl_DTD_recovery[] = {
a83 25
/* the names in this table are used as lowercase in HTTP.c */
Config_Enum tbl_preferred_encoding[] = {
    { "none",		encodingNONE },
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    { "gzip",		encodingGZIP },
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    { "compress",	encodingCOMPRESS },
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    { "bzip2",		encodingBZIP2 },
#endif
    { "all",		encodingALL },
    { NULL,		-1 }
};

Config_Enum tbl_preferred_media[] = {
    { "INTERNAL",	mediaOpt1 },
    { "CONFIGFILE",	mediaOpt2 },
    { "USER",		mediaOpt3 },
    { "SYSTEM",		mediaOpt4 },
    { "ALL",		mediaALL },
    { NULL,		-1 }
};

a129 1
/* *INDENT-ON* */
d131 1
a131 1
static BOOL getBool(char *src)
d136 3
a138 1
const char *LYputEnum(Config_Enum * table, int value)
d149 4
a152 2
BOOL LYgetEnum(Config_Enum * table, char *name,
	       int *result)
d210 2
a211 1
typedef struct config_type {
d215 1
a215 1
      ParseData;
d218 1
a218 1
    void (*write_it) (FILE *fp, struct config_type *);
d222 1
a222 1
static int get_assume_charset(char *value)
d227 1
a227 1
	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
d235 1
a235 1
static void put_assume_charset(FILE *fp, struct config_type *tbl)
d244 1
a244 1
static int get_display_charset(char *value)
d248 1
a248 1
    i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */
d254 1
a254 1
static void put_display_charset(FILE *fp, struct config_type *tbl)
d263 1
a263 1
static int get_editor(char *value)
d270 1
a270 1
static void put_editor(FILE *fp, struct config_type *tbl)
d275 1
a275 1
int get_tagsoup(char *value)
d280 1
a280 1
	&& Old_DTD != found) {
d287 1
a287 1
static void put_tagsoup(FILE *fp, struct config_type *tbl)
a292 1
/* *INDENT-OFF* */
a435 2
    MAYBE_ENU(RC_PREFERRED_ENCODING,    LYAcceptEncoding,   tbl_preferred_encoding,
	      MSG_ENABLE_LYNXRC),
a442 2
    MAYBE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia,      tbl_preferred_media,
	      MSG_ENABLE_LYNXRC),
a565 1
/* *INDENT-ON* */
d567 2
a568 1
static Config_Type *lookup_config(char *name)
d578 1
a578 1
		&& (0 == strcasecomp(name, tbl->name)))
d587 4
a590 3
/* Read and process user options.  If the passed-in fp is NULL, open the
 * regular user defaults file for reading, otherwise use fp which has to be a
 * file open for reading.  - kw
d592 1
a592 1
void read_rc(FILE *fp)
d597 1
a597 1
    int n;
d601 1
a601 1
	 * Make an RC file name, open it for reading.
d613 1
a613 1
     * Process the entries.
a642 1

d657 1
a657 1
		*(q->set_value) = getBool(value);
d682 1
a682 2

		if (1 == sscanf(value, "%d", &ival))
d725 1
a725 1
    LYConfigCookies();		/* update cookie settings, if any */
d752 3
a754 1
static void write_list(FILE *fp, char *list)
a756 1

a758 1

d774 1
a774 1
static void explain_keypad_mode(FILE *fp)
d805 4
a808 3
/* Save user options.  If the passed-in fp is NULL, open the regular user
 * defaults file for writing, otherwise use fp which has to be a temp file open
 * for writing.  - kw
d810 1
a810 1
int save_rc(FILE *fp)
d819 1
a819 1
	 * Make a name.
d824 1
a824 1
	 * Open the file for write.
d851 1
a851 2
	}
	if (tbl->note != NULL) {
d889 1
a889 1
		    && *MBM_A_subdescript[n] != 0)
d900 3
a902 3
		    (q->str_value != 0 && *(q->str_value) != 0)
		    ? *(q->str_value)
		    : "");
d912 1
a912 1
     * Close the RC file.
d927 1
a927 1
BOOL will_save_rc(char *name)
a929 1

d933 2
a934 1
int enable_lynxrc(char *value)
@


1.1.3.6
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a88 1
    { "deflate",	encodingDEFLATE },
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d20 351
a370 11
#define MSG_ENABLE_LYNXRC N_("Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n")
#define NonNull(string) ((string) != 0 ? (string) : "")
#define putBool(value) ((value) ? "on" : "off")

PUBLIC Config_Enum tbl_DTD_recovery[] = {
    { "on",		TRUE },
    { "off",		FALSE },
    { "sortasgml",	TRUE },
    { "tagsoup",	FALSE },
    { NULL,		-1 },
};
d373 65
a437 7
PRIVATE Config_Enum tbl_dir_list_style[] = {
    { "FILES_FIRST",	FILES_FIRST },
    { "DIRECTORIES_FIRST", 0 },
    { "MIXED_STYLE",	MIXED_STYLE },
    { NULL,		MIXED_STYLE },
};
#endif
d439 7
a445 47
PRIVATE Config_Enum tbl_file_sort[] = {
    { "BY_FILENAME",	FILE_BY_NAME },
    { "BY_TYPE",	FILE_BY_TYPE },
    { "BY_SIZE",	FILE_BY_SIZE },
    { "BY_DATE",	FILE_BY_DATE },
    { NULL,		-1 },
};

PUBLIC Config_Enum tbl_keypad_mode[] = {
    { "LINKS_AND_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "LINKS_AND_FORM_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "LINKS_ARE_NUMBERED", LINKS_ARE_NUMBERED },
    { "NUMBERS_AS_ARROWS", NUMBERS_AS_ARROWS },
    { NULL,		DEFAULT_KEYPAD_MODE }
};

PUBLIC Config_Enum tbl_multi_bookmarks[] = {
    { "OFF",		MBM_OFF },
    { "STANDARD",	MBM_STANDARD },
    { "ON",		MBM_STANDARD },
    { "ADVANCED",	MBM_ADVANCED },
    { NULL,		-1 }
};

PRIVATE Config_Enum tbl_show_colors[] = {
    { "default",	SHOW_COLOR_UNKNOWN },
    { "default",	SHOW_COLOR_OFF },
    { "default",	SHOW_COLOR_ON },
    { "on",		SHOW_COLOR_UNKNOWN },
    { "off",		SHOW_COLOR_UNKNOWN },
    { "never",		SHOW_COLOR_NEVER },
    { "always",		SHOW_COLOR_ALWAYS },
    { NULL,		SHOW_COLOR_UNKNOWN }
};

PUBLIC Config_Enum tbl_transfer_rate[] = {
    { "NONE",		rateOFF },
    { "KB",		rateKB },
    { "TRUE",		rateKB },
    { "BYTES",		rateBYTES },
    { "FALSE",		rateBYTES },
#ifdef EXP_READPROGRESS
    { "KB,ETA",		rateEtaKB },
    { "BYTES,ETA",	rateEtaBYTES },
#endif
    { NULL,		-1 },
};
d447 8
a454 15
PUBLIC Config_Enum tbl_user_mode[] = {
    { "ADVANCED",	ADVANCED_MODE },
    { "INTERMEDIATE",	INTERMEDIATE_MODE },
    { "NOVICE",		NOVICE_MODE },
    { NULL,		NOVICE_MODE }
};

PRIVATE Config_Enum tbl_visited_links[] = {
    { "FIRST_REVERSED",	VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE },
    { "FIRST",		VISITED_LINKS_AS_FIRST_V },
    { "TREE",		VISITED_LINKS_AS_TREE    },
    { "LAST_REVERSED",	VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE },
    { "LAST",		VISITED_LINKS_AS_LATEST  },
    { NULL,		DEFAULT_VISITED_LINKS }
};
d456 4
a459 4
PRIVATE BOOL getBool ARGS1(char *, src)
{
    return (BOOL) (!strncasecomp(src, "on", 2) || !strncasecomp(src, "true", 4));
}
d461 8
a468 12
PRIVATE CONST char *LYputEnum ARGS2(
    Config_Enum *,	table,
    int,		value)
{
    while (table->name != 0) {
	if (table->value == value) {
	    return table->name;
	}
	table++;
    }
    return "?";
}
d470 12
a481 16
PRIVATE BOOL LYgetEnum ARGS3(
    Config_Enum *,	table,
    char *,		src,
    int *,		value)
{
    while (table->name != 0) {
	if (!strncasecomp(table->name, src, strlen(table->name))) {
	    *value = table->value;
	    return TRUE;
	}
	table++;
    }
    if (table->value >= 0) 	/* is there a default? */
	*value = table->value;
    return FALSE;
}
d483 5
a487 31
/* these are for data that are normally not read/written from .lynxrc */
#define PARSE_SET(n,v,h)   {n,    1, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define PARSE_ARY(n,v,t,h) {n,    1, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define PARSE_ENU(n,v,t,h) {n,    1, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define PARSE_LIS(n,v,h)   {n,    1, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_STR(n,v,h)   {n,    1, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_FUN(n,v,w,h) {n,    1, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define PARSE_MBM(n,h)     {n,    1, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

/* these are for data that are optionally read/written from .lynxrc */
#define MAYBE_SET(n,v,h)   {n,    0, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define MAYBE_ARY(n,v,t,h) {n,    0, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define MAYBE_ENU(n,v,t,h) {n,    0, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define MAYBE_LIS(n,v,h)   {n,    0, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_STR(n,v,h)   {n,    0, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_FUN(n,v,w,h) {n,    0, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define MAYBE_MBM(n,h)     {n,    0, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

#define PARSE_NIL          {NULL, 1, 0,          UNION_DEF(0), 0, 0, 0, 0}

typedef enum {
    CONF_UNSPECIFIED = 0
    ,CONF_ARRAY
    ,CONF_BOOL
    ,CONF_FUN
    ,CONF_INT
    ,CONF_ENUM
    ,CONF_LIS
    ,CONF_MBM
    ,CONF_STR
} Conf_Types;
d489 5
a493 11
typedef struct config_type
{
    CONST char *name;
    int enabled;		/* see lynx.cfg ENABLE_LYNXRC */
    Conf_Types type;
    ParseData;
    char **strings;
    Config_Enum *table;
    void (*write_it) PARAMS((FILE * fp, struct config_type *));
    char *note;
} Config_Type;
d495 17
a511 3
PRIVATE int get_assume_charset ARGS1(char *, value)
{
    int i;
d513 1
a513 8
    for (i = 0; i < LYNumCharsets; ++i) {
    	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
	    UCLYhndl_for_unspec = i;
	    break;
	}
    }
    return 0;
}
d515 1
a515 3
PRIVATE void put_assume_charset ARGS2(FILE *, fp, struct config_type *, tbl)
{
    int i;
d517 2
a518 4
    for (i = 0; i < LYNumCharsets; ++i)
	fprintf(fp, "#    %s\n", LYCharSet_UC[i].MIMEname);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
}
d520 7
a526 1
PRIVATE int get_display_charset ARGS1(char *, value)
d528 13
a540 6
    int i = 0;

    i = UCGetLYhndl_byAnyName(value); /* by MIME or full name */
    if (i >= 0)
	current_char_set = i;
    return 0;
d543 1
a543 1
PRIVATE void put_display_charset ARGS2(FILE *, fp, struct config_type *, tbl)
d545 2
d548 1
d550 4
a553 4
    for (i = 0; LYchar_set_names[i]; i++)
	fprintf(fp, "#    %s\n", LYchar_set_names[i]);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYchar_set_names[current_char_set]);
}
d555 6
a560 6
PRIVATE int get_editor ARGS1(char *, value)
{
    if (!system_editor)
	StrAllocCopy(editor, value);
    return 0;
}
d562 16
a577 4
PRIVATE void put_editor ARGS2(FILE *, fp, struct config_type *, tbl)
{
    fprintf(fp, "%s=%s\n\n", tbl->name, NonNull(editor));
}
d579 4
a582 70
/* This table is searched ignoring case */
static Config_Type Config_Table [] =
{
    MAYBE_ENU("DTD_recovery",          Old_DTD,            tbl_DTD_recovery,
              MSG_ENABLE_LYNXRC),
    PARSE_SET("accept_all_cookies",    LYAcceptAllCookies, N_("\
accept_all_cookies allows the user to tell Lynx to automatically\n\
accept all cookies if desired.  The default is \"FALSE\" which will\n\
prompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\n\
all cookies.\n\
")),
    MAYBE_FUN("assume_char_set",       get_assume_charset, put_assume_charset, MSG_ENABLE_LYNXRC),
    PARSE_STR("bookmark_file",         bookmark_page,     N_("\
bookmark_file specifies the name and location of the default bookmark\n\
file into which the user can paste links for easy access at a later\n\
date.\n\
")),
    PARSE_SET("case_sensitive_searching", case_sensitive, N_("\
If case_sensitive_searching is \"on\" then when the user invokes a search\n\
using the 's' or '/' keys, the search performed will be case sensitive\n\
instead of case INsensitive.  The default is usually \"off\".\n\
")),
    PARSE_FUN("character_set",         get_display_charset, put_display_charset, N_("\
The character_set definition controls the representation of 8 bit\n\
characters for your terminal.  If 8 bit characters do not show up\n\
correctly on your screen you may try changing to a different 8 bit\n\
set or using the 7 bit character approximations.\n\
Current valid characters sets are:\n\
")),
    PARSE_LIS("cookie_accept_domains", LYCookieAcceptDomains, N_("\
cookie_accept_domains and cookie_reject_domains are comma-delimited\n\
lists of domains from which Lynx should automatically accept or reject\n\
all cookies.  If a domain is specified in both options, rejection will\n\
take precedence.  The accept_all_cookies parameter will override any\n\
settings made here.\n\
")),
#ifdef EXP_PERSISTENT_COOKIES
    PARSE_STR("cookie_file",	       LYCookieFile, N_("\
cookie_file specifies the file from which to read persistent cookies.\n\
The default is ~/.lynx_cookies.\n\
")),
#endif
    PARSE_STR("cookie_loose_invalid_domains", LYCookieLooseCheckDomains, N_("\
cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\n\
cookie_query_invalid_domains are comma-delimited lists of which domains\n\
should be subjected to varying degrees of validity checking.  If a\n\
domain is set to strict checking, strict conformance to RFC2109 will\n\
be applied.  A domain with loose checking will be allowed to set cookies\n\
with an invalid path or domain attribute.  All domains will default to\n\
querying the user for an invalid path or domain.\n\
")),
    PARSE_STR("cookie_query_invalid_domains", LYCookieQueryCheckDomains, NULL),
    PARSE_LIS("cookie_reject_domains", LYCookieRejectDomains, NULL),
    PARSE_STR("cookie_strict_invalid_domains", LYCookieStrictCheckDomains, NULL),
#ifdef DIRED_SUPPORT
    PARSE_ENU("dir_list_style",        dir_list_style,     tbl_dir_list_style, N_("\
dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
(if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
files and directories together.  \"FILES_FIRST\" lists files first and\n\
\"DIRECTORIES_FIRST\" lists directories first.\n\
")),
#endif
    MAYBE_STR("display",               x_display,          MSG_ENABLE_LYNXRC),
    PARSE_SET("emacs_keys",            emacs_keys, N_("\
If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
  ^N = down    ^P = up\n\
  ^B = left    ^F = right\n\
will be enabled.\n\
")),
    PARSE_FUN("file_editor",           get_editor,         put_editor, N_("\
d587 56
a642 2
")),
    PARSE_ENU("file_sorting_method",   HTfileSortMethod,   tbl_file_sort, N_("\
d649 13
a661 27
")),
#ifdef EXP_KEYBOARD_LAYOUT
    PARSE_ARY("kblayout",              current_layout,     LYKbLayoutNames, NULL),
#endif
    PARSE_ENU("keypad_mode",           keypad_mode,        tbl_keypad_mode, NULL),
    PARSE_ARY("lineedit_mode",         current_lineedit,   LYLineeditNames, N_("\
lineedit_mode specifies the key binding used for inputting strings in\n\
prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
the following control characters are used for moving and deleting:\n\
\n\
             Prev  Next       Enter = Accept input\n\
   Move char: <-    ->        ^G    = Cancel input\n\
   Move word: ^P    ^N        ^U    = Erase line\n\
 Delete char: ^H    ^R        ^A    = Beginning of line\n\
 Delete word: ^B    ^F        ^E    = End of line\n\
\n\
Current lineedit modes are:\n\
")),
    MAYBE_SET("make_pseudo_alts_for_inlines", pseudo_inline_alts, MSG_ENABLE_LYNXRC),
    MAYBE_SET("make_links_for_all_images", clickable_images, MSG_ENABLE_LYNXRC),
    PARSE_MBM("multi_bookmark", N_("\
The following allow you to define sub-bookmark files and descriptions.\n\
The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
Up to 26 bookmark files (for the English capital letters) are allowed.\n\
We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n\
")),
    PARSE_STR("personal_mail_address", personal_mail_address, N_("\
d669 46
a714 2
")),
    PARSE_STR("preferred_charset",     pref_charset, N_("\
d727 9
a735 47
")),
    PARSE_STR("preferred_language",    language, N_("\
preferred_language specifies the language in MIME notation (e.g., en,\n\
fr, may be a comma-separated list in decreasing preference)\n\
which Lynx will indicate you prefer in requests to http servers.\n\
If a file in that language is available, the server will send it.\n\
Otherwise, the server will send the file in it's default language.\n\
")),
    MAYBE_SET("raw_mode",              LYRawMode,          MSG_ENABLE_LYNXRC),
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PARSE_SET("run_all_execution_links", local_exec, N_("\
If run_all_execution_links is set \"on\" then all local execution links\n\
will be executed when they are selected.\n\
\n\
WARNING - This is potentially VERY dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
    PARSE_SET("run_execution_links_on_local_files", local_exec_on_local_files, N_("\
If run_execution_links_on_local_files is set \"on\" then all local\n\
execution links that are found in LOCAL files will be executed when they\n\
are selected.  This is different from run_all_execution_links in that\n\
only files that reside on the local system will have execution link\n\
permissions.\n\
\n\
WARNING - This is potentially dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
#endif
    PARSE_SET("select_popups",         LYSelectPopups, N_("\
select_popups specifies whether the OPTIONs in a SELECT block which\n\
lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
present in the SELECT start tag, Lynx always will create a vertical list\n\
of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
as the default while a value of \"off\" will set use of radio boxes.\n\
The default can be overridden via the -popup command line toggle.\n\
")),
    MAYBE_SET("set_cookies",           LYSetCookies,      MSG_ENABLE_LYNXRC),
    PARSE_ENU("show_color",            LYrcShowColor,     tbl_show_colors, N_("\
d751 61
a811 2
")),
    PARSE_SET("show_cursor",           LYShowCursor, N_("\
d821 2
a822 150
")),
    PARSE_SET("show_dotfiles",         show_dotfiles, N_("\
show_dotfiles specifies that the directory listing should include\n\
\"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
restricted via a command line switch.  If display of hidden files\n\
is disabled, creation of such files via Lynx also is disabled.\n\
")),
#ifdef EXP_READPROGRESS
    MAYBE_ENU("show_rate",             LYTransferRate,    tbl_transfer_rate,
	      MSG_ENABLE_LYNXRC),
#endif
    PARSE_ENU("sub_bookmarks",         LYMultiBookmarks,  tbl_multi_bookmarks, N_("\
If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
been defined (see below), then all bookmark operations will first\n\
prompt the user to select an active sub-bookmark file.  If the default\n\
Lynx bookmark_file is defined (see above), it will be used as the\n\
default selection.  When this option is set to \"advanced\", and the\n\
user mode is advanced, the 'v'iew bookmark command will invoke a\n\
statusline prompt instead of the menu seen in novice and intermediate\n\
user modes.  When this option is set to \"standard\", the menu will be\n\
presented regardless of user mode.\n\
")),
    MAYBE_STR("user_agent",            LYUserAgent,        MSG_ENABLE_LYNXRC),
    PARSE_ENU("user_mode",             user_mode,          tbl_user_mode, N_("\
user_mode specifies the users level of knowledge with Lynx.  The\n\
default is \"NOVICE\" which displays two extra lines of help at the\n\
bottom of the screen to aid the user in learning the basic Lynx\n\
commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
bottom of the screen.\n\
")),
    PARSE_SET("verbose_images",        verbose_img, N_("\
If verbose_images is \"on\", lynx will print the name of the image\n\
source file in place of [INLINE], [LINK] or [IMAGE]\n\
See also VERBOSE_IMAGES in lynx.cfg\n\
")),
    PARSE_SET("vi_keys",               vi_keys, N_("\
If vi_keys is set to \"on\", then the normal VI movement keys:\n\
  j = down    k = up\n\
  h = left    l = right\n\
will be enabled.  These keys are only lower case.\n\
Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
and the keymap display, respectively.\n\
")),
    PARSE_ENU("visited_links",         Visited_Links_As,   tbl_visited_links, N_("\
The visited_links setting controls how Lynx organizes the information\n\
in the Visited Links Page.\n\
")),

    PARSE_NIL
};

PRIVATE Config_Type *lookup_config ARGS1(
	char *,		name)
{
    Config_Type *tbl = Config_Table;
    char ch = (char) TOUPPER(*name);

    while (tbl->name != 0) {
	if (tbl->enabled) {
	    char ch1 = tbl->name[0];

	    if ((ch == TOUPPER(ch1))
		&& (0 == strcasecomp (name, tbl->name)))
		break;
	}

	tbl++;
    }
    return tbl;
}

/*  Read and process user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for reading, otherwise use fp which has to be a file open for
 *  reading. - kw
 */
PUBLIC void read_rc ARGS1(FILE *, fp)
{
    char *buffer = NULL;
    char rcfile[LY_MAXPATH];
    char MBM_line[256];
    int  n;

    if (!fp) {
	/*
	 *  Make an RC file name, open it for reading.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);
	if ((fp = fopen(rcfile, TXT_R)) == NULL) {
	    return;
	}
    }

    /*
     *  Process the entries.
     */
    while (LYSafeGets(&buffer, fp) != NULL) {
	char *name, *value, *notes;
	Config_Type *tbl;
	ParseUnionPtr q;

	/* Most lines in the config file are comment lines.  Weed them out
	 * now.  Also, leading whitespace is ok, so trim it.
	 */
	LYTrimTrailing(buffer);
	name = LYSkipBlanks(buffer);
	if (ispunct(UCH(*name)) || *name == '\0')
	    continue;

	/*
	 * Parse the "name=value" strings.
	 */
	if ((value = strchr(name, '=')) == 0)
	    continue;
	*value++ = '\0';
	LYTrimTrailing(name);
	value = LYSkipBlanks(value);
	tbl = lookup_config(name);
	if (tbl->name == 0) {
	    char *special = "multi_bookmark";
	    if (!strncasecomp(name, special, strlen(special))) {
		tbl = lookup_config(special);
	    }
	    /* lynx ignores unknown keywords */
	    if (tbl->name == 0)
		continue;
	}

	q = ParseUnionOf(tbl);
	switch (tbl->type) {
	case CONF_BOOL:
	    if (q->set_value != 0)
		*(q->set_value) = getBool (value);
	    break;

	case CONF_FUN:
	    if (q->fun_value != 0)
		(*(q->fun_value)) (value);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n) {
		if (!strcasecomp(value, tbl->strings[n])) {
		    *(q->int_value) = n;
		    break;
		}
	    }
	    break;
a823 54
	case CONF_ENUM:
	    if (tbl->table != 0)
		LYgetEnum(tbl->table, value, q->int_value);
	    break;

	case CONF_INT:
	    if (q->int_value != 0) {
		int ival;
		if (1 == sscanf (value, "%d", &ival))
		    *(q->int_value) = ival;
	    }
	    break;

	case CONF_LIS:
	    if (q->str_value != 0) {
		if (*(q->str_value) != NULL)
		    StrAllocCat(*(q->str_value), ",");
		StrAllocCat(*(q->str_value), value);
	    }
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		sprintf(MBM_line, "multi_bookmark%c", LYindex2MBM(n));

		if (!strcasecomp(name, MBM_line)) {
		    if ((notes = strchr(value, ',')) != 0) {
			*notes++ = '\0';
			LYTrimTrailing(value);
			notes = LYSkipBlanks(notes);
		    } else {
			notes = value + strlen(value);
		    }
		    StrAllocCopy(MBM_A_subbookmark[n], value);
		    StrAllocCopy(MBM_A_subdescript[n], notes);
		    break;
		}
	    }
	    break;

	case CONF_STR:
	    if (q->str_value != 0)
		StrAllocCopy(*(q->str_value), value);
	    break;

	case CONF_UNSPECIFIED:
	    break;
	}
    }

    LYCloseInput(fp);
    LYConfigCookies();	/* update cookie settings, if any */

#if defined(USE_SLANG) || defined(COLOR_CURSES)
d825 1
a825 1
     * We may override the commandline "-color" option with the .lynxrc file
a826 45
    switch (LYrcShowColor) {
    case SHOW_COLOR_ALWAYS:
	if (LYShowColor != SHOW_COLOR_NEVER)
	    LYShowColor = SHOW_COLOR_ALWAYS;
	break;
    case SHOW_COLOR_NEVER:
	if (LYShowColor == SHOW_COLOR_ON)
	    LYShowColor = SHOW_COLOR_OFF;
	break;
    default:
	/* don't override */
	break;
    }
#endif
    set_default_bookmark_page(bookmark_page);
}

/*
 * Write a set of comments.  Doing it this way avoids preprocessor problems
 * with the leading '#', makes it simpler to use gettext.
 */
PRIVATE void write_list ARGS2(
    	FILE *,		fp,
	char *,		list)
{
    int first = TRUE;
    while (*list != 0) {
	int ch = *list++;
	if (ch == '\n') {
	    first = TRUE;
	} else {
	    if (first) {
		fputs("# ", fp);
		first = FALSE;
	    }
	}
	fputc(ch, fp);
    }
}

/*
 * This is too long for some compilers.
 */
PRIVATE void explain_keypad_mode ARGS1(FILE *, fp)
{
d854 4
a857 1
}
d859 15
a873 11
/*  Save user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for writing, otherwise use fp which has to be a temp file open for
 *  writing. - kw
 */
PUBLIC int save_rc ARGS1(FILE *, fp)
{
    Config_Type *tbl = Config_Table;
    char rcfile[LY_MAXPATH];
    BOOLEAN is_tempfile = (BOOL) (fp != NULL);
    int n;
d875 21
a895 11
    if (!fp) {
	/*
	 *  Make a name.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

	/*
	 *  Open the file for write.
	 */
	if ((fp = LYNewTxtFile(rcfile)) == NULL) {
	    return FALSE;
d898 64
d964 7
a970 10
Lynx User Defaults File\n\
\n\
This file contains options saved from the Lynx Options Screen (normally\n\
with the '>' key).  There is normally no need to edit this file manually,\n\
since the defaults here can be controlled from the Options Screen, and the\n\
next time options are saved from the Options Screen this file will be\n\
completely rewritten.  You have been warned...\n\
If you are looking for the general configuration file - it is normally\n\
called lynx.cfg, and it has different content and a different format.\n\
It is not this file.\n\
d972 9
a980 1
    fprintf(fp, "\n");
a981 2
    while (tbl->name != 0) {
	ParseUnionPtr q = ParseUnionOf(tbl);
d983 11
a993 8
	if (!tbl->enabled) {
	    tbl++;
	    continue;
	} if (tbl->note != NULL) {
	    write_list(fp, gettext(tbl->note));
	} else if (tbl->table == tbl_keypad_mode) {
	    explain_keypad_mode(fp);
	}
a994 38
	switch (tbl->type) {
	case CONF_BOOL:
	    fprintf(fp, "%s=%s\n\n", tbl->name, putBool(*(q->set_value)));
	    break;

	case CONF_FUN:
	    if (tbl->write_it != 0)
		tbl->write_it(fp, tbl);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n)
		fprintf(fp, "#    %s\n", tbl->strings[n]);
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    tbl->strings[*(q->int_value)]);
	    break;

	case CONF_ENUM:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    LYputEnum(tbl->table, *(q->int_value)));
	    break;

	case CONF_INT:
	    fprintf(fp, "%s=%d\n\n", tbl->name, *(q->int_value));
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		fprintf(fp, "multi_bookmark%c=", LYindex2MBM(n));

		fprintf(fp, "%s", NonNull(MBM_A_subbookmark[n]));
		if (MBM_A_subdescript[n] != 0
		 && *MBM_A_subdescript[n] != 0)
		    fprintf(fp, ",%s", MBM_A_subdescript[n]);
		fprintf(fp, "\n");
	    }
	    fprintf(fp, "\n");
	    break;
a995 8
	case CONF_LIS:
	    /* FALLTHRU */
	case CONF_STR:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
			(q->str_value != 0 && *(q->str_value) != 0)
			    ? *(q->str_value)
			    : "");
	    break;
d997 17
a1013 5
	case CONF_UNSPECIFIED:
	    break;
	}
	tbl++;
    }
d1016 1
a1016 1
     *  Close the RC file.
d1018 17
a1034 6
    if (is_tempfile) {
	LYCloseTempFP(fp);
    } else {
	LYCloseOutput(fp);
	HTSYS_purge(rcfile);
    }
d1036 7
a1042 2
    return TRUE;
}
d1044 4
a1047 8
/*
 * Returns true if the given name would be saved in .lynxrc
 */
PUBLIC BOOL will_save_rc ARGS1(char *, name)
{
    Config_Type *tbl = lookup_config(name);
    return tbl->name != 0;
}
d1049 1
a1049 5
PUBLIC int enable_lynxrc ARGS1(
	char *,		value)
{
    Config_Type *tbl;
    char *colon = strchr(value, ':');
d1051 1
a1051 14
    if (colon != 0) {
	*colon++ = 0;
	LYTrimLeading(value);
	LYTrimTrailing(value);

	for (tbl = Config_Table; tbl->name != 0; tbl++) {
	    if (!strcasecomp(value, tbl->name)) {
		tbl->enabled = getBool(colon);
		CTRACE((tfp, "enable_lynxrc(%s) %s\n", value, putBool(tbl->enabled)));
		break;
	    }
	}
    }
    return 0;
@

