head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.8
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.6
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.8.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.8
	MIRBSD_XP_SPARC:1.8.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.46.11;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.15.18.17.09;	author tg;	state Stab;
branches;
next	1.7;

1.7
date	2004.04.30.16.32.39;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.10.19.50.15;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.07.21.18.07;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.39;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.47;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.40;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.34;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.32.13;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.26;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.45;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.12.12;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.16.10;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.54.57;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/src/chrtrans/makeuctb.c,v 1.8 2004/07/15 18:17:09 tg Stab $ */

/*
 *  makeuctb.c, derived from conmakehash.c   - kw
 *
 *    Original comments from conmakehash.c:
 *
 *  Create arrays for initializing the kernel folded tables (using a hash
 *  table turned out to be to limiting...)  Unfortunately we can't simply
 *  preinitialize the tables at compile time since kfree() cannot accept
 *  memory not allocated by kmalloc(), and doing our own memory management
 *  just for this seems like massive overkill.
 *
 *  Copyright (C) 1995 H. Peter Anvin
 *
 *  This program is a part of the Linux kernel, and may be freely
 *  copied under the terms of the GNU General Public License (GPL),
 *  version 2, or at your option any later version.
 */

#ifndef HAVE_CONFIG_H
/* override HTUtils.h fallbacks for cross-compiling */
#define HAVE_LSTAT
#define NO_FILIO_H
#endif

#define DONT_USE_SOCKS5
#include <UCDefs.h>
#include <UCkd.h>

/*
 *  Don't try to use LYexit() since this is a standalone file.
 */
#ifdef exit
#undef exit
#endif /* exit */

#define MAX_FONTLEN 256

/*
 *  We don't deal with UCS4 here. - KW
 */
typedef u16 unicode;

static FILE *chdr = 0;

/*
 * Since we may be writing the formatted file to stdout, ensure that we flush
 * everything before leaving, since some old (and a few not-so-old) platforms
 * do not properly implement POSIX 'exit()'.
 */
static void done(int code) GCC_NORETURN;

static void done(int code)
{
    if (chdr != 0) {
	fflush(chdr);
	fclose(chdr);
    }
    fflush(stderr);
    exit(code);
}

static void usage(void)
{
    static const char *tbl[] =
    {
	"Usage: makeuctb [parameters]",
	"",
	"Utility to convert .tbl into .h files for Lynx compilation.",
	"",
	"Parameters (all are optional):",
	"  1: the input file (normally {filename}.tbl, but \"-\" for stdin",
	"  2: the output file (normally {filename}.tbl but \"-\" for stdout",
	"  3: charset mime name",
	"  4: charset display name"
    };
    unsigned n;

    for (n = 0; n < TABLESIZE(tbl); n++) {
	fprintf(stderr, "%s\n", tbl[n]);
    };
    done(EX_USAGE);
}

#ifdef EXP_ASCII_CTYPES
int ascii_tolower(int i)
{
    if (91 > i && i > 64)
	return (i + 32);
    else
	return i;
}
#endif

/* copied from HTString.c, not everybody has strncasecmp */
int strncasecomp(const char *a, const char *b, int n)
{
    const char *p = a;
    const char *q = b;

    for (p = a, q = b;; p++, q++) {
	int diff;

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
	if (!(*p && *q))
	    return (*p - *q);
	diff = TOLOWER(*p) - TOLOWER(*q);
	if (diff)
	    return diff;
    }
    /*NOTREACHED */
}

static int getunicode(char **p0)
{
    char *p = *p0;

    while (*p == ' ' || *p == '\t')
	p++;

    if (*p == '-') {
	return -2;
    } else if (*p != 'U' || p[1] != '+' ||
	       !isxdigit(UCH(p[2])) ||
	       !isxdigit(UCH(p[3])) ||
	       !isxdigit(UCH(p[4])) ||
	       !isxdigit(UCH(p[5])) ||
	       isxdigit(UCH(p[6]))) {
	return -1;
    }
    *p0 = p + 6;
    return strtol((p + 2), 0, 16);
}

/*
 *  Massive overkill, but who cares?
 */
static unicode unitable[MAX_FONTLEN][255];
static int unicount[MAX_FONTLEN];

static struct unimapdesc_str themap_str =
{0, NULL, 0, 0};

static const char *tblname;
static const char *hdrname;

static int RawOrEnc = 0;
static int Raw_found = 0;	/* whether explicit R directive found */
static int CodePage = 0;
static int CodePage_found = 0;	/* whether explicit C directive found */

#define MAX_UNIPAIRS 2500

static void addpair_str(char *str, int un)
{
    int i = 0;

    if (un <= 0xfffe) {
	if (!themap_str.entry_ct) {
	    /*
	     *  Initialize the map for replacement strings.
	     */
	    themap_str.entries = (struct unipair_str *) malloc(MAX_UNIPAIRS
							       * sizeof(struct unipair_str));

	    if (!themap_str.entries) {
		fprintf(stderr,
			"%s: Out of memory\n", tblname);
		done(EX_DATAERR);
	    }
	} else {
	    /*
	     *  Check that it isn't a duplicate.
	     */
	    for (i = 0; i < themap_str.entry_ct; i++) {
		if (themap_str.entries[i].unicode == un) {
		    themap_str.entries[i].replace_str = str;
		    return;
		}
	    }
	}

	/*
	 *  Add to list.
	 */
	if (themap_str.entry_ct > MAX_UNIPAIRS - 1) {
	    fprintf(stderr,
		    "ERROR: Only %d unicode replacement strings permitted!\n",
		    MAX_UNIPAIRS);
	    done(EX_DATAERR);
	}
	themap_str.entries[themap_str.entry_ct].unicode = un;
	themap_str.entries[themap_str.entry_ct].replace_str = str;
	themap_str.entry_ct++;
    }
    /* otherwise: ignore */
}

static void addpair(int fp, int un)
{
    int i;

    if (!Raw_found) {		/* enc not (yet) explicitly given with 'R' */
	if (fp >= 128) {
	    if (RawOrEnc != UCT_ENC_8BIT && RawOrEnc <= UCT_ENC_8859) {
		if (fp < 160) {	/* cannot be 8859 */
		    RawOrEnc = UCT_ENC_8BIT;
		} else if (fp != 160 && fp != 173) {
		    RawOrEnc = UCT_ENC_8859;	/* hmmm.. more tests needed? */
		} else if (unicount[fp] == 0 && fp != un) {
		    /* first unicode for fp doesn't map to itself */
		    RawOrEnc = UCT_ENC_8BIT;
		} else {
		    RawOrEnc = UCT_ENC_8859;	/* hmmm.. more tests needed? */
		}
	    }
	}
    }
    if (un <= 0xfffe) {
	/*
	 *  Check that it isn't a duplicate.
	 */
	for (i = 0; i < unicount[fp]; i++) {
	    if (unitable[fp][i] == un) {
		return;
	    }
	}

	/*
	 *  Add to list.
	 */
	if (unicount[fp] > 254) {
	    fprintf(stderr, "ERROR: Only 255 unicodes/glyph permitted!\n");
	    done(EX_DATAERR);
	}
	unitable[fp][unicount[fp]] = un;
	unicount[fp]++;
    }
    /* otherwise: ignore */
}

static char this_MIMEcharset[UC_MAXLEN_MIMECSNAME + 1];
static char this_LYNXcharset[UC_MAXLEN_LYNXCSNAME + 1];
static char id_append[UC_MAXLEN_ID_APPEND + 1] = "_";
static int this_isDefaultMap = -1;
static int useDefaultMap = 1;
static int lowest_eight = 999;

int main(int argc, char **argv)
{
    static const char *first_ifdefs[] =
    {
	"/*",
	" * Compile-in this chunk of code unless we've turned it off specifically",
	" * or in general (id=%s).",
	" */",
	"",
	"#ifndef INCL_CHARSET%s",
	"#define INCL_CHARSET%s 1",
	"",
	"/*ifdef NO_CHARSET*/",
	"#ifdef  NO_CHARSET",
	"#undef  NO_CHARSET",
	"#endif",
	"#define NO_CHARSET 0 /* force default to always be active */",
	"",
	"/*ifndef NO_CHARSET%s*/",
	"#ifndef NO_CHARSET%s",
	"",
	"#if    ALL_CHARSETS",
	"#define NO_CHARSET%s 0",
	"#else",
	"#define NO_CHARSET%s 1",
	"#endif",
	"",
	"#endif /* ndef(NO_CHARSET%s) */",
	"",
	"#if NO_CHARSET%s",
	"#define UC_CHARSET_SETUP%s /*nothing*/",
	"#else"
    };
    static const char *last_ifdefs[] =
    {
	"",
	"#endif /* NO_CHARSET%s */",
	"",
	"#endif /* INCL_CHARSET%s */"
    };

    FILE *ctbl;
    char buffer[65536];
    char outname[256];
    unsigned n;
    int fontlen;
    int i, nuni, nent;
    int fp0 = 0, fp1 = 0, un0, un1;
    char *p, *p1;
    char *tbuf, ch;
    size_t plen;

    if (argc < 2 || argc > 5) {
	usage();
    }

    if (!strcmp(argv[1], "-")) {
	ctbl = stdin;
	tblname = "stdin";
    } else {
	ctbl = fopen(tblname = argv[1], "r");
	if (!ctbl) {
	    perror(tblname);
	    done(EX_NOINPUT);
	}
    }

    if (argc > 2) {
	if (!strcmp(argv[2], "-")) {
	    chdr = stdout;
	    hdrname = "stdout";
	} else {
	    hdrname = argv[2];
	}
    } else if (ctbl == stdin) {
	chdr = stdout;
	hdrname = "stdout";
    } else {
	strlcpy(outname, tblname, 256);
	hdrname = outname;
	if ((p = strrchr(outname, '.')) == 0)
	    p = outname + strlen(outname);
	    strlcat(outname, ".h", 256);
	} else strlcpy(p, ".h", 256-(p-outname));
    }

    if (chdr == 0) {
	chdr = fopen(hdrname, "w");
	if (!chdr) {
	    perror(hdrname);
	    done(EX_NOINPUT);
	}
    }

    /*
     *  For now we assume the default font is always 256 characters.
     */
    fontlen = 256;

    /*
     *  Initialize table.
     */
    for (i = 0; i < fontlen; i++) {
	unicount[i] = 0;
    }

    /*
     *  Now we comes to the tricky part.  Parse the input table.
     */
    while (fgets(buffer, sizeof(buffer), ctbl) != NULL) {
	if ((p = strchr(buffer, '\n')) != NULL) {
	    *p = '\0';
	} else {
	    fprintf(stderr,
		    "%s: Warning: line too long or incomplete.\n",
		    tblname);
	}

	/*
	 *  Syntax accepted:
	 *      <fontpos>       <unicode> <unicode> ...
	 *      <fontpos>       <unicode range> <unicode range> ...
	 *      <fontpos>       idem
	 *      <range>         idem
	 *      <range>         <unicode range>
	 *      <unicode>       :<replace>
	 *      <unicode range> :<replace>
	 *      <unicode>       "<C replace>"
	 *      <unicode range> "<C replace>"
	 *
	 *  where <range> ::= <fontpos>-<fontpos>
	 *  and <unicode> ::= U+<h><h><h><h>
	 *  and <h> ::= <hexadecimal digit>
	 *  and <replace> any string not containing '\n' or '\0'
	 *  and <C replace> any string with C backslash escapes.
	 */
	p = buffer;
	while (*p == ' ' || *p == '\t') {
	    p++;
	}
	if (!(*p) || *p == '#') {
	    /*
	     *  Skip comment or blank line.
	     */
	    continue;
	}

	switch (*p) {
	    /*
	     *  Raw Unicode?  I.e. needs some special
	     *  processing.  One digit code.
	     */
	case 'R':
	    if (p[1] == 'a' || p[1] == 'A') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "RawOrEnc", 8)) {
		    p += 8;
		}
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    RawOrEnc = strtol(p, 0, 10);
	    Raw_found = 1;
	    continue;

	    /*
	     *  Is this the default table?
	     */
	case 'D':
	    if (p[1] == 'e' || p[1] == 'E') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "Default", 7)) {
		    p += 7;
		}
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    this_isDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
	    continue;

	    /*
	     *  Is this the default table?
	     */
	case 'F':
	    if (p[1] == 'a' || p[1] == 'A') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "FallBack", 8)) {
		    p += 8;
		}
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    useDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
	    continue;

	case 'M':
	    if (p[1] == 'i' || p[1] == 'I') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "MIMEName", 8)) {
		    p += 8;
		}
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    sscanf(p, "%40s", this_MIMEcharset);
	    continue;

	    /*
	     *  Display charset name for options screen.
	     */
	case 'O':
	    if (p[1] == 'p' || p[1] == 'P') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "OptionName", 10)) {
		    p += 10;
		}
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    for (i = 0; *p && i < UC_MAXLEN_LYNXCSNAME; p++, i++) {
		this_LYNXcharset[i] = *p;
	    }
	    this_LYNXcharset[i] = '\0';
	    continue;

	    /*
	     *  Codepage number.  Three or four digit code.
	     */
	case 'C':
	    if (p[1] == 'o' || p[1] == 'O') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "CodePage", 8)) {
		    p += 8;
		}
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    CodePage = strtol(p, 0, 10);
	    CodePage_found = 1;
	    continue;
	}

	if (*p == 'U') {
	    un0 = getunicode(&p);
	    if (un0 < 0) {
		fprintf(stderr, "Bad input line: %s\n", buffer);
		done(EX_DATAERR);
		fprintf(stderr,
			"%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
			tblname, fp0, fp1);
		done(EX_DATAERR);
	    }
	    un1 = un0;
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    if (*p == '-') {
		p++;
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		un1 = getunicode(&p);
		if (un1 < 0 || un1 < un0) {
		    fprintf(stderr,
			    "%s: Bad Unicode range U+%x-U+%x\n",
			    tblname, un0, un1);
		    fprintf(stderr, "Bad input line: %s\n", buffer);
		    done(EX_DATAERR);
		}
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
	    }

	    if (*p != ':' && *p != '"') {
		fprintf(stderr, "No ':' or '\"' where expected: %s\n",
			buffer);
		continue;
	    }

	    plen = 4 * strlen(p);
	    tbuf = (char *) malloc(plen);

	    if (!(p1 = tbuf)) {
		fprintf(stderr, "%s: Out of memory\n", tblname);
		done(EX_DATAERR);
	    }
	    if (*p == '"') {
		/*
		 *  Handle "<C replace>".
		 *  Copy chars verbatim until first '"' not \-escaped or
		 *  end of buffer.
		 */
		int escaped = 0;

		for (ch = *(++p); (ch = *p) != '\0'; p++) {
		    if (escaped) {
			escaped = 0;
		    } else if (ch == '"') {
			break;
		    } else if (ch == '\\') {
			escaped = 1;
		    }
		    *p1++ = ch;
		}
		if (escaped || ch != '"') {
		    fprintf(stderr, "Warning: String not terminated: %s\n",
			    buffer);
		    if (escaped)
			*p1++ = '\n';
		}
	    } else {
		/*
		 *  We had ':'.
		 */
		for (ch = *(++p); (ch = *p) != '\0'; p++, p1++) {
		    if (UCH(ch) < 32 || ch == '\\' || ch == '\"' ||
			UCH(ch) >= 127) {
			snprintf(p1, plen - (p1 - tbuf), "\\%.3o", UCH(ch));
			p1 += 3;
		    } else {
			*p1 = ch;
		    }
		}
	    }
	    *p1 = '\0';
	    for (i = un0; i <= un1; i++) {
		addpair_str(tbuf, i);
	    }
	    continue;
	}

	/*
	 *  Input line (after skipping spaces) doesn't start with one
	 *  of the specially recognized characters, so try to interpret
	 *  it as starting with a fontpos.
	 */
	fp0 = strtol(p, &p1, 0);
	if (p1 == p) {
	    fprintf(stderr, "Bad input line: %s\n", buffer);
	    done(EX_DATAERR);
	}
	p = p1;

	while (*p == ' ' || *p == '\t') {
	    p++;
	}
	if (*p == '-') {
	    p++;
	    fp1 = strtol(p, &p1, 0);
	    if (p1 == p) {
		fprintf(stderr, "Bad input line: %s\n", buffer);
		done(EX_DATAERR);
	    }
	    p = p1;
	} else {
	    fp1 = 0;
	}

	if (fp0 < 0 || fp0 >= fontlen) {
	    fprintf(stderr,
		    "%s: Glyph number (0x%x) larger than font length\n",
		    tblname, fp0);
	    done(EX_DATAERR);
	}
	if (fp1 && (fp1 < fp0 || fp1 >= fontlen)) {
	    fprintf(stderr,
		    "%s: Bad end of range (0x%x)\n",
		    tblname, fp1);
	    done(EX_DATAERR);
	}

	if (fp1) {
	    /*
	     *  We have a range; expect the word "idem"
	     *  or a Unicode range of the same length.
	     */
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    if (!strncmp(p, "idem", 4)) {
		for (i = fp0; i <= fp1; i++) {
		    addpair(i, i);
		}
		p += 4;
	    } else {
		un0 = getunicode(&p);
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		if (*p != '-') {
		    fprintf(stderr,
			    "%s: Corresponding to a range of font positions,",
			    tblname);
		    fprintf(stderr,
			    " there should be a Unicode range.\n");
		    done(EX_DATAERR);
		}
		p++;
		un1 = getunicode(&p);
		if (un0 < 0 || un1 < 0) {
		    fprintf(stderr,
			    "%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
			    tblname, fp0, fp1);
		    done(EX_DATAERR);
		}
		if (un1 - un0 != fp1 - fp0) {
		    fprintf(stderr,
			    "%s: Unicode range U+%x-U+%x not of the same length",
			    tblname, un0, un1);
		    fprintf(stderr,
			    " as font position range 0x%x-0x%x\n",
			    fp0, fp1);
		    done(EX_DATAERR);
		}
		for (i = fp0; i <= fp1; i++) {
		    addpair(i, un0 - fp0 + i);
		}
	    }
	} else {
	    /*
	     *  No range; expect a list of unicode values
	     *  or unicode ranges for a single font position,
	     *  or the word "idem"
	     */
	    while (*p == ' ' || *p == '\t') {
		p++;
	    }
	    if (!strncmp(p, "idem", 4)) {
		addpair(fp0, fp0);
		p += 4;
	    }
	    while ((un0 = getunicode(&p)) >= 0) {
		addpair(fp0, un0);
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		if (*p == '-') {
		    p++;
		    un1 = getunicode(&p);
		    if (un1 < un0) {
			fprintf(stderr,
				"%s: Bad Unicode range 0x%x-0x%x\n",
				tblname, un0, un1);
			done(EX_DATAERR);
		    }
		    for (un0++; un0 <= un1; un0++) {
			addpair(fp0, un0);
		    }
		}
	    }
	}
	while (*p == ' ' || *p == '\t') {
	    p++;
	}
	if (*p && *p != '#') {
	    fprintf(stderr, "%s: trailing junk (%s) ignored\n", tblname, p);
	}
    }

    /*
     *  Okay, we hit EOF, now output tables.
     */
    fclose(ctbl);

    /*
     *  Compute total size of Unicode list.
     */
    nuni = 0;
    for (i = 0; i < fontlen; i++) {
	nuni += unicount[i];
    }

    if (argc > 3) {
	strncpy(this_MIMEcharset, argv[3], UC_MAXLEN_MIMECSNAME);
    } else if (this_MIMEcharset[0] == '\0') {
	strncpy(this_MIMEcharset, tblname, UC_MAXLEN_MIMECSNAME);
	if ((p = strchr(this_MIMEcharset, '.')) != 0) {
	    *p = '\0';
	}
    }
    for (p = this_MIMEcharset; *p; p++) {
	*p = TOLOWER(*p);
    }
    if (argc > 4) {
	strncpy(this_LYNXcharset, argv[4], UC_MAXLEN_LYNXCSNAME);
    } else if (this_LYNXcharset[0] == '\0') {
	strncpy(this_LYNXcharset, this_MIMEcharset, UC_MAXLEN_LYNXCSNAME);
    }

    if (this_isDefaultMap == -1) {
	this_isDefaultMap = !strncmp(this_MIMEcharset, "iso-8859-1", 10);
    }
    fprintf(stderr,
	    "makeuctb: %s: %stranslation map",
	    this_MIMEcharset, (this_isDefaultMap ? "default " : ""));
    if (this_isDefaultMap == 1) {
	*id_append = '\0';
    } else {
	for (i = 0, p = this_MIMEcharset;
	     *p && (i < UC_MAXLEN_ID_APPEND - 1);
	     p++, i++) {
	    id_append[i + 1] = isalnum(UCH(*p)) ? *p : '_';
	}
	id_append[i + 1] = '\0';
    }
    fprintf(stderr, " (%s).\n", id_append);

    for (n = 0; n < TABLESIZE(first_ifdefs); n++) {
	fprintf(chdr, first_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }

    fprintf(chdr, "\n\
/*\n\
 *  uni_hash.tbl\n\
 *\n\
 *  Do not edit this file; it was automatically generated by\n\
 *\n\
 *  %s %s\n\
 *\n\
 */\n\
\n\
static const u8 dfont_unicount%s[%d] = \n\
{\n\t", argv[0], argv[1], id_append, fontlen);

    for (i = 0; i < fontlen; i++) {
	if (i >= 128 && unicount[i] > 0 && i < lowest_eight) {
	    lowest_eight = i;
	}
	fprintf(chdr, "%3d", unicount[i]);
	if (i == (fontlen - 1)) {
	    fprintf(chdr, "\n};\n");
	} else if ((i % 8) == 7) {
	    fprintf(chdr, ",\n\t");
	} else {
	    fprintf(chdr, ", ");
	}
    }

    /*
     *  If lowest_eightbit is anything else but 999,
     *  this can't be 7-bit only.
     */
    if (lowest_eight != 999 && !RawOrEnc) {
	RawOrEnc = UCT_ENC_8BIT;
    }

    if (nuni) {
	fprintf(chdr, "\nstatic const u16 dfont_unitable%s[%d] = \n{\n\t",
		id_append, nuni);
    } else {
	fprintf(chdr,
		"\nstatic const u16 dfont_unitable%s[1] = {0}; /* dummy */\n", id_append);
    }

    fp0 = 0;
    nent = 0;
    for (i = 0; i < nuni; i++) {
	while (nent >= unicount[fp0]) {
	    fp0++;
	    nent = 0;
	}
	fprintf(chdr, "0x%04x", unitable[fp0][nent++]);
	if (i == (nuni - 1)) {
	    fprintf(chdr, "\n};\n");
	} else if ((i % 8) == 7) {
	    fprintf(chdr, ",\n\t");
	} else {
	    fprintf(chdr, ", ");
	}
    }

    if (themap_str.entry_ct) {
	fprintf(chdr, "\n\
static struct unipair_str repl_map%s[%d] = \n\
{\n\t", id_append, themap_str.entry_ct);
    } else {
	fprintf(chdr, "\n\
/* static struct unipair_str repl_map%s[]; */\n", id_append);
    }

    for (i = 0; i < themap_str.entry_ct; i++) {
	fprintf(chdr, "{0x%x,\"%s\"}",
		themap_str.entries[i].unicode,
		themap_str.entries[i].replace_str);
	if (i == (themap_str.entry_ct - 1)) {
	    fprintf(chdr, "\n};\n");
	} else if ((i % 4) == 3) {
	    fprintf(chdr, ",\n\t");
	} else {
	    fprintf(chdr, ", ");
	}
    }
    if (themap_str.entry_ct) {
	fprintf(chdr, "\n\
static const struct unimapdesc_str dfont_replacedesc%s = {%d,repl_map%s,",
		id_append, themap_str.entry_ct, id_append);
    } else {
	fprintf(chdr, "\n\
static const struct unimapdesc_str dfont_replacedesc%s = {0,NULL,", id_append);
    }
    fprintf(chdr, "%d,%d};\n",
	    this_isDefaultMap ? 1 : 0,
	    (useDefaultMap && !this_isDefaultMap) ? 1 : 0
	);

    fprintf(chdr, "#define UC_CHARSET_SETUP%s UC_Charset_Setup(\
\"%s\",\\\n\"%s\",\\\n\
dfont_unicount%s,dfont_unitable%s,%d,\\\n\
dfont_replacedesc%s,%d,%d,%d)\n",
	    id_append, this_MIMEcharset, this_LYNXcharset,
	    id_append, id_append, nuni, id_append, lowest_eight, RawOrEnc, CodePage);

    for (n = 0; n < TABLESIZE(last_ifdefs); n++) {
	fprintf(chdr, last_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }

    done(EX_OK);
    return 0;
}
@


1.8
log
@automatic merge of lynx-current
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/chrtrans/makeuctb.c,v 1.7 2004/04/30 16:32:39 tg Exp $ */
d140 2
a141 2
unicode unitable[MAX_FONTLEN][255];
int unicount[MAX_FONTLEN];
d143 1
a143 1
struct unimapdesc_str themap_str =
d146 2
a147 2
static char *tblname;
static char *hdrname;
d244 6
a249 6
char this_MIMEcharset[UC_MAXLEN_MIMECSNAME + 1];
char this_LYNXcharset[UC_MAXLEN_LYNXCSNAME + 1];
char id_append[UC_MAXLEN_ID_APPEND + 1] = "_";
int this_isDefaultMap = -1;
int useDefaultMap = 1;
int lowest_eight = 999;
d253 1
a253 1
    static char *first_ifdefs[] =
d284 1
a284 1
    static char *last_ifdefs[] =
d329 3
a331 2
	strlcpy(hdrname = outname, tblname, 256);
	if ((p = strrchr(outname, '.')) == 0) {
d815 2
a816 1
	fprintf(chdr, "\nstatic const u16 dfont_unitable%s[1]; /* dummy */\n", id_append);
@


1.7
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/chrtrans/makeuctb.c,v 1.6 2004/03/10 19:50:15 tg Exp $ */
d52 3
a54 2
static void done (int code) GCC_NORETURN;
static void done (int code)
d64 1
a64 1
static void usage (void)
d66 2
a67 1
    static const char *tbl[] = {
d79 1
d87 1
a87 1
int ascii_tolower (int i)
d89 2
a90 2
    if ( 91 > i && i > 64 )
	return (i+32);
d97 1
a97 4
int strncasecomp (
	const char*	a,
	const char *	b,
	int		n)
d102 1
a102 1
    for (p = a, q = b; ; p++, q++) {
d104 3
a106 2
	if (p == (a+n))
	    return 0;	/*   Match up to n characters */
d113 1
a113 1
    /*NOTREACHED*/
d116 1
a116 2
static int getunicode (
	char **	p0)
d130 1
a130 1
	        isxdigit(UCH(p[6]))) {
d133 1
a133 1
    *p0 = p+6;
d143 2
a144 1
struct unimapdesc_str themap_str = {0, NULL, 0, 0};
d150 1
a150 1
static int Raw_found = 0;		/* whether explicit R directive found */
d152 1
a152 1
static int CodePage_found = 0;		/* whether explicit C directive found */
d156 1
a156 3
static void addpair_str (
	char *		str,
	int		un)
d158 1
a158 1
   int i = 0;
d165 3
a167 2
	    themap_str.entries = (struct unipair_str *) malloc (MAX_UNIPAIRS
				* sizeof (struct unipair_str));
d177 2
a178 2
	    for (i = 0 ; i < themap_str.entry_ct; i++) {
		if (themap_str.entries[i].unicode == un ) {
d188 1
a188 1
	if (themap_str.entry_ct > MAX_UNIPAIRS-1) {
d201 1
a201 3
static void addpair (
	int	fp,
	int	un)
d205 1
a205 1
    if (!Raw_found) {	/* enc not (yet) explicitly given with 'R' */
d211 1
a211 1
		    RawOrEnc = UCT_ENC_8859; /* hmmm.. more tests needed? */
d216 1
a216 1
		    RawOrEnc = UCT_ENC_8859; /* hmmm.. more tests needed? */
d244 3
a246 3
char this_MIMEcharset[UC_MAXLEN_MIMECSNAME +1];
char this_LYNXcharset[UC_MAXLEN_LYNXCSNAME +1];
char id_append[UC_MAXLEN_ID_APPEND +1] = "_";
d251 1
a251 3
int main (
	int	argc,
	char **	argv)
d253 2
a254 1
    static char *first_ifdefs[] = {
d284 2
a285 1
    static char *last_ifdefs[] = {
d370 9
a378 9
	 *	<fontpos>	<unicode> <unicode> ...
	 *	<fontpos>	<unicode range> <unicode range> ...
	 *	<fontpos>	idem
	 *	<range>		idem
	 *	<range>		<unicode range>
	 *      <unicode>	:<replace>
	 *      <unicode range>	:<replace>
	 *      <unicode>	"<C replace>"
	 *      <unicode range>	"<C replace>"
d402 5
a406 6
	    case 'R':
		if (p[1] == 'a' || p[1] == 'A') {
		    buffer[sizeof(buffer) - 1] = '\0';
		    if (!strncasecomp(p, "RawOrEnc", 8)) {
			p += 8;
		    }
d408 3
d412 4
a415 6
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		RawOrEnc = strtol(p,0,10);
		Raw_found = 1;
		continue;
d420 5
a424 6
	    case 'D':
		if (p[1] == 'e' || p[1] == 'E') {
		    buffer[sizeof(buffer) - 1] = '\0';
		    if (!strncasecomp(p, "Default", 7)) {
			p += 7;
		    }
d426 3
d430 3
a432 5
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		this_isDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
		continue;
d437 5
a441 6
	    case 'F':
		if (p[1] == 'a' || p[1] == 'A') {
		    buffer[sizeof(buffer) - 1] = '\0';
		    if (!strncasecomp(p, "FallBack", 8)) {
			p += 8;
		    }
d443 3
d447 3
a449 5
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		useDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
		continue;
d451 5
a455 6
	    case 'M':
		if (p[1] == 'i' || p[1] == 'I') {
		    buffer[sizeof(buffer) - 1] = '\0';
		    if (!strncasecomp(p, "MIMEName", 8)) {
			p += 8;
		    }
d457 3
d461 3
a463 5
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		sscanf(p,"%40s",this_MIMEcharset);
		continue;
d468 5
a472 6
	    case 'O':
		if (p[1] == 'p' || p[1] == 'P') {
		    buffer[sizeof(buffer) - 1] = '\0';
		    if (!strncasecomp(p, "OptionName", 10)) {
			p += 10;
		    }
d474 3
d478 6
a483 8
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		for (i = 0; *p && i < UC_MAXLEN_LYNXCSNAME; p++, i++) {
		    this_LYNXcharset[i] = *p;
		}
		this_LYNXcharset[i] = '\0';
		continue;
d488 5
a492 6
	    case 'C':
		if (p[1] == 'o' || p[1] == 'O') {
		    buffer[sizeof(buffer) - 1] = '\0';
		    if (!strncasecomp(p, "CodePage", 8)) {
			p += 8;
		    }
d494 3
d498 4
a501 6
		while (*p == ' ' || *p == '\t') {
		    p++;
		}
		CodePage = strtol(p,0,10);
		CodePage_found = 1;
		continue;
d510 1
a510 1
    "%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
d542 2
a543 2
	    plen = 4*strlen(p);
	    tbuf = (char *)malloc(plen);
d556 1
d589 1
a589 1
		addpair_str(tbuf,i);
d644 1
a644 1
		    addpair(i,i);
d664 1
a664 1
     "%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
d670 1
a670 1
			"%s: Unicode range U+%x-U+%x not of the same length",
d678 1
a678 1
		    addpair(i,un0-fp0+i);
d691 1
a691 1
		addpair(fp0,fp0);
a726 1

d731 1
a731 1
    for (i = 0 ; i < fontlen ; i++) {
d736 1
a736 1
	strncpy(this_MIMEcharset,argv[3],UC_MAXLEN_MIMECSNAME);
d738 2
a739 2
	strncpy(this_MIMEcharset,tblname,UC_MAXLEN_MIMECSNAME);
	if ((p = strchr(this_MIMEcharset,'.')) != 0) {
d747 1
a747 1
	strncpy(this_LYNXcharset,argv[4],UC_MAXLEN_LYNXCSNAME);
d749 1
a749 1
	strncpy(this_LYNXcharset,this_MIMEcharset,UC_MAXLEN_LYNXCSNAME);
d753 1
a753 1
	this_isDefaultMap = !strncmp(this_MIMEcharset,"iso-8859-1", 10);
d762 1
a762 1
	     *p && (i < UC_MAXLEN_ID_APPEND-1);
d764 1
a764 1
	    id_append[i+1] = isalnum(UCH(*p)) ? *p : '_';
d766 1
a766 1
	id_append[i+1] = '\0';
d858 1
a858 1
id_append, themap_str.entry_ct, id_append);
d861 1
a861 1
static const struct unimapdesc_str dfont_replacedesc%s = {0,NULL,",id_append);
d866 1
a866 2
    );

d872 2
a873 2
id_append, this_MIMEcharset, this_LYNXcharset,
id_append, id_append, nuni, id_append, lowest_eight, RawOrEnc, CodePage);
@


1.6
log
@thinko: strlen(p) isn't constant
added when fixing sprintf, my bad
@
text
@d1 1
a1 1
/* $MirBSD: makeuctb.c,v 1.5 2004/03/07 21:18:07 tg Exp $ */
d21 6
d28 2
a29 1
#include <HTUtils.h>
d32 1
a32 1
 *  Don't try to use LYexit().
a37 3
#include <UCkd.h>
#include <UCDefs.h>

d50 1
a50 1
 * that do not implement POSIX 'exit()'.
d52 2
a53 2
PRIVATE void done PARAMS((int code)) GCC_NORETURN;
PRIVATE void done ARGS1(int, code)
d55 4
a58 2
    fflush(chdr);
    fclose(chdr);
d63 1
a63 1
PRIVATE void usage NOARGS
d65 1
a65 1
    static CONST char *tbl[] = {
d84 1
a84 1
PUBLIC int ascii_tolower ARGS1(int, i)
d94 4
a97 4
PUBLIC int strncasecomp ARGS3(
	CONST char*,	a,
	CONST char *,	b,
	int,		n)
d99 2
a100 2
    CONST char *p = a;
    CONST char *q = b;
d115 2
a116 2
PRIVATE int getunicode ARGS1(
	char **,	p0)
d145 2
a146 2
PRIVATE char *tblname;
PRIVATE char *hdrname;
d148 4
a151 4
PRIVATE int RawOrEnc = 0;
PRIVATE int Raw_found = 0;		/* whether explicit R directive found */
PRIVATE int CodePage = 0;
PRIVATE int CodePage_found = 0;		/* whether explicit C directive found */
d155 3
a157 3
PRIVATE void addpair_str ARGS2(
	char *,		str,
	int,		un)
d201 3
a203 3
PRIVATE void addpair ARGS2(
	int,	fp,
	int,	un)
d253 3
a255 3
PUBLIC int main ARGS2(
	int,		argc,
	char **,	argv)
d581 1
a581 4
			snprintf(p1, plen-strlen(tbuf), "\\%.3o", UCH(ch));
#ifdef NOTDEFINED
			fprintf(stderr, "%s\n", tbuf);
#endif /* NOTDEFINED */
a589 3
#ifdef NOTDEFINED
		fprintf(chdr, "U+0x%x:%s\n", i, tbuf); */
#endif /* NOTDEFINED */
d753 1
a753 12
/***** DO NOT produce trailing spaces!
    if ((i = strlen(this_LYNXcharset)) < UC_LEN_LYNXCSNAME) {
	for (; i < UC_LEN_LYNXCSNAME; i++) {
	    this_LYNXcharset[i] = ' ';
	}
	this_LYNXcharset[i] = '\0';
    }
*******/
#ifdef NOTDEFINED
    fprintf(stderr,"this_MIMEcharset: %s.\n",this_MIMEcharset);
    fprintf(stderr,"this_LYNXcharset: %s.\n",this_LYNXcharset);
#endif /* NOTDEFINED */
d787 1
a787 1
static CONST u8 dfont_unicount%s[%d] = \n\
d813 1
a813 1
	fprintf(chdr, "\nstatic CONST u16 dfont_unitable%s[%d] = \n{\n\t",
d816 1
a816 1
	fprintf(chdr, "\nstatic CONST u16 dfont_unitable%s[1]; /* dummy */\n", id_append);
d859 1
a859 1
static CONST struct unimapdesc_str dfont_replacedesc%s = {%d,repl_map%s,",
d863 1
a863 1
static CONST struct unimapdesc_str dfont_replacedesc%s = {0,NULL,",id_append);
@


1.5
log
@small warnings fixup
@
text
@d1 1
a1 1
/* $MirBSD$ */
d297 1
d538 2
a539 1
	    tbuf = (char *)malloc(4*strlen(p));
d575 1
a575 1
			snprintf(p1, (4*strlen(p))-strlen(tbuf), "\\%.3o", UCH(ch));
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d1 2
d324 2
a325 2
	strcpy(hdrname = outname, tblname);
	if ((p = strrchr(outname, '.')) == 0)
d327 2
a328 1
	strcpy(p, ".h");
d573 1
a573 1
			sprintf(p1, "\\%.3o", UCH(ch));
d893 1
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d21 1
a28 8
#ifndef TOUPPER
#define TOUPPER(c) (islower(UCH(c)) ? toupper(UCH(c)) : (c))
#endif /* !TOLOWER */

#ifndef TOLOWER
#define TOLOWER(c) (isupper(UCH(c)) ? tolower(UCH(c)) : (c))
#endif /* !TOLOWER */

d75 10
d440 1
a440 1
		useDefaultMap = (*p == '1' || tolower(*p) == 'y');
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a20 1
#include <tcp.h>
d28 4
d33 1
a33 1
#define TOLOWER(c) (isupper((unsigned char)c) ? tolower((unsigned char)c) : (c))
d46 2
d49 1
a49 1
 * Since we're writing the formatted file to stdout, ensure that we flush
d53 8
a60 4
#define done(code)  \
    fflush(stdout); \
    fflush(stderr); \
    exit(code)
d62 1
a62 2
PRIVATE void usage ARGS1(
	char *,		argv0)
d64 15
a78 6
    fprintf(stderr, "Usage: \n");
    fprintf(stderr,
	    "        %s chartable [charsetmimename] [charsetdisplayname]\n",
	    argv0);
    fprintf(stderr,
	    "Utility to convert .tbl into .h files for Lynx compilation.\n");
d92 1
a92 1
        int diff;
d115 5
a119 2
	       !isxdigit(p[2]) || !isxdigit(p[3]) || !isxdigit(p[4]) ||
	       !isxdigit(p[5]) || isxdigit(p[6])) {
d132 1
a132 1
struct unimapdesc_str themap_str = {0, NULL};
d134 2
a135 1
char *tblname;
d142 2
d148 1
a148 1
   int i;
d155 2
a156 2
	    themap_str.entries =
	  (struct unipair_str *) malloc (2000 * sizeof (struct unipair_str));
d177 1
a177 1
	if (themap_str.entry_ct > 1999) {
d179 2
a180 1
		"ERROR: Only 2000 unicode replacement strings permitted!\n");
d196 1
a196 1
    if (!Raw_found) {       /* enc not (yet) explicitly given with 'R' */
d246 37
d285 2
d289 1
a289 1
    int fp0, fp1, un0, un1;
d293 2
a294 2
    if (argc < 2 || argc > 4) {
	usage(argv[0]);
d308 25
d400 1
a400 1
	  	    p++;
d409 1
a409 1
 	    case 'D':
d426 1
a426 1
 	    case 'F':
d486 1
a486 1
	  	    p++;
d565 3
a567 3
		    if ((unsigned char)ch < 32 || ch == '\\' || ch == '\"' ||
			(unsigned char)ch >= 127) {
			sprintf(p1, "\\%.3o", (unsigned char)ch);
d580 1
a580 1
		printf("U+0x%x:%s\n", i, tbuf); */
d596 1
a596 1
        }
d610 1
a610 1
        } else {
d652 1
a652 1
	        }
d660 1
a660 1
	        }
d669 1
a669 1
	        }
d729 2
a730 2
    if (argc >= 3) {
	strncpy(this_MIMEcharset,argv[2],UC_MAXLEN_MIMECSNAME);
d740 2
a741 2
    if (argc >= 4) {
	strncpy(this_LYNXcharset,argv[3],UC_MAXLEN_LYNXCSNAME);
d761 2
a762 2
    	    "makeuctb: %s: %stranslation map",
 	    this_MIMEcharset, (this_isDefaultMap ? "default " : ""));
d769 1
a769 1
	    id_append[i+1] = isalnum(*p) ? *p : '_';
d775 6
a780 1
    printf("\
d797 1
a797 1
	printf("%3d", unicount[i]);
d799 1
a799 1
	    printf("\n};\n");
d801 1
a801 1
	    printf(",\n\t");
d803 1
a803 1
	    printf(", ");
d816 2
a817 2
	printf("\nstatic CONST u16 dfont_unitable%s[%d] = \n{\n\t",
	       id_append, nuni);
d819 1
a819 1
	printf("\nstatic CONST u16 dfont_unitable%s[1]; /* dummy */\n", id_append);
d829 1
a829 1
	printf("0x%04x", unitable[fp0][nent++]);
d831 1
a831 1
	    printf("\n};\n");
d833 1
a833 1
	    printf(",\n\t");
d835 1
a835 1
	    printf(", ");
d840 1
a840 1
	printf("\n\
d844 1
a844 1
	printf("\n\
d849 3
a851 3
	printf("{0x%x,\"%s\"}",
	       themap_str.entries[i].unicode,
	       themap_str.entries[i].replace_str);
d853 1
a853 1
	    printf("\n};\n");
d855 1
a855 1
	    printf(",\n\t");
d857 1
a857 1
	    printf(", ");
d861 1
a861 1
	printf("\n\
d865 1
a865 1
	printf("\n\
d868 3
a870 3
    printf("%d,%d};\n",
    this_isDefaultMap ? 1 : 0,
    (useDefaultMap && !this_isDefaultMap) ? 1 : 0
d874 1
a874 1
    printf("#define UC_CHARSET_SETUP%s UC_Charset_Setup(\
d880 5
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a18 6
#ifndef HAVE_CONFIG_H
/* override HTUtils.h fallbacks for cross-compiling */
#define HAVE_LSTAT
#define NO_FILIO_H
#endif

d20 2
a21 3
#include <UCDefs.h>
#include <UCkd.h>

d23 1
a23 1
 *  Don't try to use LYexit() since this is a standalone file.
d29 7
a42 2
static FILE *chdr = 0;

d44 1
a44 1
 * Since we may be writing the formatted file to stdout, ensure that we flush
d46 1
a46 1
 * do not properly implement POSIX 'exit()'.
d48 4
a51 1
static void done(int code) GCC_NORETURN;
d53 2
a54 1
static void done(int code)
d56 6
a61 27
    if (chdr != 0) {
	fflush(chdr);
	fclose(chdr);
    }
    fflush(stderr);
    exit(code);
}

static void usage(void)
{
    static const char *tbl[] =
    {
	"Usage: makeuctb [parameters]",
	"",
	"Utility to convert .tbl into .h files for Lynx compilation.",
	"",
	"Parameters (all are optional):",
	"  1: the input file (normally {filename}.tbl, but \"-\" for stdin",
	"  2: the output file (normally {filename}.tbl but \"-\" for stdout",
	"  3: charset mime name",
	"  4: charset display name"
    };
    unsigned n;

    for (n = 0; n < TABLESIZE(tbl); n++) {
	fprintf(stderr, "%s\n", tbl[n]);
    };
a64 10
#ifdef EXP_ASCII_CTYPES
int ascii_tolower(int i)
{
    if (91 > i && i > 64)
	return (i + 32);
    else
	return i;
}
#endif

d66 4
a69 1
int strncasecomp(const char *a, const char *b, int n)
d71 2
a72 2
    const char *p = a;
    const char *q = b;
d74 4
a77 5
    for (p = a, q = b;; p++, q++) {
	int diff;

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
d84 1
a84 1
    /*NOTREACHED */
d87 2
a88 1
static int getunicode(char **p0)
d98 2
a99 5
	       !isxdigit(UCH(p[2])) ||
	       !isxdigit(UCH(p[3])) ||
	       !isxdigit(UCH(p[4])) ||
	       !isxdigit(UCH(p[5])) ||
	       isxdigit(UCH(p[6]))) {
d102 1
a102 1
    *p0 = p + 6;
d109 2
a110 5
static unicode unitable[MAX_FONTLEN][255];
static int unicount[MAX_FONTLEN];

static struct unimapdesc_str themap_str =
{0, NULL, 0, 0};
d112 1
a112 2
static const char *tblname;
static const char *hdrname;
d114 1
a114 4
static int RawOrEnc = 0;
static int Raw_found = 0;	/* whether explicit R directive found */
static int CodePage = 0;
static int CodePage_found = 0;	/* whether explicit C directive found */
d116 4
a119 1
#define MAX_UNIPAIRS 2500
d121 3
a123 1
static void addpair_str(char *str, int un)
d125 1
a125 1
    int i = 0;
d132 2
a133 3
	    themap_str.entries = (struct unipair_str *) malloc(MAX_UNIPAIRS
							       * sizeof(struct unipair_str));

d143 2
a144 2
	    for (i = 0; i < themap_str.entry_ct; i++) {
		if (themap_str.entries[i].unicode == un) {
d154 1
a154 1
	if (themap_str.entry_ct > MAX_UNIPAIRS - 1) {
d156 1
a156 2
		    "ERROR: Only %d unicode replacement strings permitted!\n",
		    MAX_UNIPAIRS);
d166 3
a168 1
static void addpair(int fp, int un)
d172 1
a172 1
    if (!Raw_found) {		/* enc not (yet) explicitly given with 'R' */
d178 1
a178 1
		    RawOrEnc = UCT_ENC_8859;	/* hmmm.. more tests needed? */
d183 1
a183 1
		    RawOrEnc = UCT_ENC_8859;	/* hmmm.. more tests needed? */
d211 10
a220 8
static char this_MIMEcharset[UC_MAXLEN_MIMECSNAME + 1];
static char this_LYNXcharset[UC_MAXLEN_LYNXCSNAME + 1];
static char id_append[UC_MAXLEN_ID_APPEND + 1] = "_";
static int this_isDefaultMap = -1;
static int useDefaultMap = 1;
static int lowest_eight = 999;

int main(int argc, char **argv)
a221 39
    static const char *first_ifdefs[] =
    {
	"/*",
	" * Compile-in this chunk of code unless we've turned it off specifically",
	" * or in general (id=%s).",
	" */",
	"",
	"#ifndef INCL_CHARSET%s",
	"#define INCL_CHARSET%s 1",
	"",
	"/*ifdef NO_CHARSET*/",
	"#ifdef  NO_CHARSET",
	"#undef  NO_CHARSET",
	"#endif",
	"#define NO_CHARSET 0 /* force default to always be active */",
	"",
	"/*ifndef NO_CHARSET%s*/",
	"#ifndef NO_CHARSET%s",
	"",
	"#if    ALL_CHARSETS",
	"#define NO_CHARSET%s 0",
	"#else",
	"#define NO_CHARSET%s 1",
	"#endif",
	"",
	"#endif /* ndef(NO_CHARSET%s) */",
	"",
	"#if NO_CHARSET%s",
	"#define UC_CHARSET_SETUP%s /*nothing*/",
	"#else"
    };
    static const char *last_ifdefs[] =
    {
	"",
	"#endif /* NO_CHARSET%s */",
	"",
	"#endif /* INCL_CHARSET%s */"
    };

a223 2
    char outname[256];
    unsigned n;
d226 1
a226 1
    int fp0 = 0, fp1 = 0, un0, un1;
d230 2
a231 2
    if (argc < 2 || argc > 5) {
	usage();
a244 26
    if (argc > 2) {
	if (!strcmp(argv[2], "-")) {
	    chdr = stdout;
	    hdrname = "stdout";
	} else {
	    hdrname = argv[2];
	}
    } else if (ctbl == stdin) {
	chdr = stdout;
	hdrname = "stdout";
    } else {
	strcpy(outname, tblname);
	hdrname = outname;
	if ((p = strrchr(outname, '.')) == 0)
	    p = outname + strlen(outname);
	strcpy(p, ".h");
    }

    if (chdr == 0) {
	chdr = fopen(hdrname, "w");
	if (!chdr) {
	    perror(hdrname);
	    done(EX_NOINPUT);
	}
    }

d271 9
a279 9
	 *      <fontpos>       <unicode> <unicode> ...
	 *      <fontpos>       <unicode range> <unicode range> ...
	 *      <fontpos>       idem
	 *      <range>         idem
	 *      <range>         <unicode range>
	 *      <unicode>       :<replace>
	 *      <unicode range> :<replace>
	 *      <unicode>       "<C replace>"
	 *      <unicode range> "<C replace>"
d303 6
a308 5
	case 'R':
	    if (p[1] == 'a' || p[1] == 'A') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "RawOrEnc", 8)) {
		    p += 8;
a309 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d311 6
a316 4
	    }
	    RawOrEnc = strtol(p, 0, 10);
	    Raw_found = 1;
	    continue;
d321 6
a326 5
	case 'D':
	    if (p[1] == 'e' || p[1] == 'E') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "Default", 7)) {
		    p += 7;
a327 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d329 5
a333 3
	    }
	    this_isDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
	    continue;
d338 6
a343 5
	case 'F':
	    if (p[1] == 'a' || p[1] == 'A') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "FallBack", 8)) {
		    p += 8;
a344 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d346 5
a350 3
	    }
	    useDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
	    continue;
d352 6
a357 5
	case 'M':
	    if (p[1] == 'i' || p[1] == 'I') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "MIMEName", 8)) {
		    p += 8;
a358 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d360 5
a364 3
	    }
	    sscanf(p, "%40s", this_MIMEcharset);
	    continue;
d369 6
a374 5
	case 'O':
	    if (p[1] == 'p' || p[1] == 'P') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "OptionName", 10)) {
		    p += 10;
a375 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d377 8
a384 6
	    }
	    for (i = 0; *p && i < UC_MAXLEN_LYNXCSNAME; p++, i++) {
		this_LYNXcharset[i] = *p;
	    }
	    this_LYNXcharset[i] = '\0';
	    continue;
d389 6
a394 5
	case 'C':
	    if (p[1] == 'o' || p[1] == 'O') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "CodePage", 8)) {
		    p += 8;
a395 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d397 6
a402 4
	    }
	    CodePage = strtol(p, 0, 10);
	    CodePage_found = 1;
	    continue;
d411 1
a411 1
			"%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
d443 1
a443 1
	    tbuf = (char *) malloc(4 * strlen(p));
a455 1

d477 6
a482 3
		    if (UCH(ch) < 32 || ch == '\\' || ch == '\"' ||
			UCH(ch) >= 127) {
			sprintf(p1, "\\%.3o", UCH(ch));
d491 4
a494 1
		addpair_str(tbuf, i);
d508 1
a508 1
	}
d522 1
a522 1
	} else {
d549 1
a549 1
		    addpair(i, i);
d564 1
a564 1
		}
d569 1
a569 1
			    "%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
d572 1
a572 1
		}
d575 1
a575 1
			    "%s: Unicode range U+%x-U+%x not of the same length",
d581 1
a581 1
		}
d583 1
a583 1
		    addpair(i, un0 - fp0 + i);
d596 1
a596 1
		addpair(fp0, fp0);
d632 1
d637 1
a637 1
    for (i = 0; i < fontlen; i++) {
d641 2
a642 2
    if (argc > 3) {
	strncpy(this_MIMEcharset, argv[3], UC_MAXLEN_MIMECSNAME);
d644 2
a645 2
	strncpy(this_MIMEcharset, tblname, UC_MAXLEN_MIMECSNAME);
	if ((p = strchr(this_MIMEcharset, '.')) != 0) {
d652 2
a653 2
    if (argc > 4) {
	strncpy(this_LYNXcharset, argv[4], UC_MAXLEN_LYNXCSNAME);
d655 1
a655 1
	strncpy(this_LYNXcharset, this_MIMEcharset, UC_MAXLEN_LYNXCSNAME);
d657 12
a668 1

d670 1
a670 1
	this_isDefaultMap = !strncmp(this_MIMEcharset, "iso-8859-1", 10);
d673 2
a674 2
	    "makeuctb: %s: %stranslation map",
	    this_MIMEcharset, (this_isDefaultMap ? "default " : ""));
d679 1
a679 1
	     *p && (i < UC_MAXLEN_ID_APPEND - 1);
d681 1
a681 1
	    id_append[i + 1] = isalnum(UCH(*p)) ? *p : '_';
d683 1
a683 1
	id_append[i + 1] = '\0';
d687 1
a687 6
    for (n = 0; n < TABLESIZE(first_ifdefs); n++) {
	fprintf(chdr, first_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }

    fprintf(chdr, "\n\
d697 1
a697 1
static const u8 dfont_unicount%s[%d] = \n\
d704 1
a704 1
	fprintf(chdr, "%3d", unicount[i]);
d706 1
a706 1
	    fprintf(chdr, "\n};\n");
d708 1
a708 1
	    fprintf(chdr, ",\n\t");
d710 1
a710 1
	    fprintf(chdr, ", ");
d723 2
a724 2
	fprintf(chdr, "\nstatic const u16 dfont_unitable%s[%d] = \n{\n\t",
		id_append, nuni);
d726 1
a726 2
	fprintf(chdr,
		"\nstatic const u16 dfont_unitable%s[1] = {0}; /* dummy */\n", id_append);
d736 1
a736 1
	fprintf(chdr, "0x%04x", unitable[fp0][nent++]);
d738 1
a738 1
	    fprintf(chdr, "\n};\n");
d740 1
a740 1
	    fprintf(chdr, ",\n\t");
d742 1
a742 1
	    fprintf(chdr, ", ");
d747 1
a747 1
	fprintf(chdr, "\n\
d751 1
a751 1
	fprintf(chdr, "\n\
d756 3
a758 3
	fprintf(chdr, "{0x%x,\"%s\"}",
		themap_str.entries[i].unicode,
		themap_str.entries[i].replace_str);
d760 1
a760 1
	    fprintf(chdr, "\n};\n");
d762 1
a762 1
	    fprintf(chdr, ",\n\t");
d764 1
a764 1
	    fprintf(chdr, ", ");
d768 3
a770 3
	fprintf(chdr, "\n\
static const struct unimapdesc_str dfont_replacedesc%s = {%d,repl_map%s,",
		id_append, themap_str.entry_ct, id_append);
d772 2
a773 2
	fprintf(chdr, "\n\
static const struct unimapdesc_str dfont_replacedesc%s = {0,NULL,", id_append);
d775 4
a778 4
    fprintf(chdr, "%d,%d};\n",
	    this_isDefaultMap ? 1 : 0,
	    (useDefaultMap && !this_isDefaultMap) ? 1 : 0
	);
d780 2
a781 1
    fprintf(chdr, "#define UC_CHARSET_SETUP%s UC_Charset_Setup(\
d785 2
a786 7
	    id_append, this_MIMEcharset, this_LYNXcharset,
	    id_append, id_append, nuni, id_append, lowest_eight, RawOrEnc, CodePage);

    for (n = 0; n < TABLESIZE(last_ifdefs); n++) {
	fprintf(chdr, last_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }
a788 1
    return 0;
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d21 1
a28 4
#ifndef TOUPPER
#define TOUPPER(c) (islower(UCH(c)) ? toupper(UCH(c)) : (c))
#endif /* !TOLOWER */

d30 1
a30 1
#define TOLOWER(c) (isupper(UCH(c)) ? tolower(UCH(c)) : (c))
a42 2
static FILE *chdr = 0;

d44 1
a44 1
 * Since we may be writing the formatted file to stdout, ensure that we flush
d48 4
a51 8
PRIVATE void done PARAMS((int code)) GCC_NORETURN;
PRIVATE void done ARGS1(int, code)
{
    fflush(chdr);
    fclose(chdr);
    fflush(stderr);
    exit(code);
}
d53 2
a54 1
PRIVATE void usage NOARGS
d56 6
a61 15
    static CONST char *tbl[] = {
	"Usage: makeuctb [parameters]",
	"",
	"Utility to convert .tbl into .h files for Lynx compilation.",
	"",
	"Parameters (all are optional):",
	"  1: the input file (normally {filename}.tbl, but \"-\" for stdin",
	"  2: the output file (normally {filename}.tbl but \"-\" for stdout",
	"  3: charset mime name",
	"  4: charset display name"
    };
    unsigned n;
    for (n = 0; n < TABLESIZE(tbl); n++) {
	fprintf(stderr, "%s\n", tbl[n]);
    };
d75 1
a75 1
	int diff;
d98 2
a99 5
	       !isxdigit(UCH(p[2])) ||
	       !isxdigit(UCH(p[3])) ||
	       !isxdigit(UCH(p[4])) ||
	       !isxdigit(UCH(p[5])) ||
	        isxdigit(UCH(p[6]))) {
d112 1
a112 1
struct unimapdesc_str themap_str = {0, NULL, 0, 0};
d114 1
a114 2
PRIVATE char *tblname;
PRIVATE char *hdrname;
a120 2
#define MAX_UNIPAIRS 2500

d125 1
a125 1
   int i = 0;
d132 2
a133 2
	    themap_str.entries = (struct unipair_str *) malloc (MAX_UNIPAIRS
				* sizeof (struct unipair_str));
d154 1
a154 1
	if (themap_str.entry_ct > MAX_UNIPAIRS-1) {
d156 1
a156 2
		    "ERROR: Only %d unicode replacement strings permitted!\n",
		    MAX_UNIPAIRS);
d172 1
a172 1
    if (!Raw_found) {	/* enc not (yet) explicitly given with 'R' */
a221 37
    static char *first_ifdefs[] = {
	"/*",
	" * Compile-in this chunk of code unless we've turned it off specifically",
	" * or in general (id=%s).",
	" */",
	"",
	"#ifndef INCL_CHARSET%s",
	"#define INCL_CHARSET%s 1",
	"",
	"/*ifdef NO_CHARSET*/",
	"#ifdef  NO_CHARSET",
	"#undef  NO_CHARSET",
	"#endif",
	"#define NO_CHARSET 0 /* force default to always be active */",
	"",
	"/*ifndef NO_CHARSET%s*/",
	"#ifndef NO_CHARSET%s",
	"",
	"#if    ALL_CHARSETS",
	"#define NO_CHARSET%s 0",
	"#else",
	"#define NO_CHARSET%s 1",
	"#endif",
	"",
	"#endif /* ndef(NO_CHARSET%s) */",
	"",
	"#if NO_CHARSET%s",
	"#define UC_CHARSET_SETUP%s /*nothing*/",
	"#else"
    };
    static char *last_ifdefs[] = {
	"",
	"#endif /* NO_CHARSET%s */",
	"",
	"#endif /* INCL_CHARSET%s */"
    };

a223 2
    char outname[256];
    unsigned n;
d226 1
a226 1
    int fp0 = 0, fp1 = 0, un0, un1;
d230 2
a231 2
    if (argc < 2 || argc > 5) {
	usage();
a244 25
    if (argc > 2) {
	if (!strcmp(argv[2], "-")) {
	    chdr = stdout;
	    hdrname = "stdout";
	} else {
	    hdrname = argv[2];
	}
    } else if (ctbl == stdin) {
	chdr = stdout;
	hdrname = "stdout";
    } else {
	strcpy(hdrname = outname, tblname);
	if ((p = strrchr(outname, '.')) == 0)
	    p = outname + strlen(outname);
	strcpy(p, ".h");
    }

    if (chdr == 0) {
	chdr = fopen(hdrname, "w");
	if (!chdr) {
	    perror(hdrname);
	    done(EX_NOINPUT);
	}
    }

d312 1
a312 1
		    p++;
d321 1
a321 1
	    case 'D':
d338 1
a338 1
	    case 'F':
d398 1
a398 1
		    p++;
d477 3
a479 3
		    if (UCH(ch) < 32 || ch == '\\' || ch == '\"' ||
			UCH(ch) >= 127) {
			sprintf(p1, "\\%.3o", UCH(ch));
d492 1
a492 1
		fprintf(chdr, "U+0x%x:%s\n", i, tbuf); */
d508 1
a508 1
	}
d522 1
a522 1
	} else {
d564 1
a564 1
		}
d572 1
a572 1
		}
d581 1
a581 1
		}
d641 2
a642 2
    if (argc > 3) {
	strncpy(this_MIMEcharset,argv[3],UC_MAXLEN_MIMECSNAME);
d652 2
a653 2
    if (argc > 4) {
	strncpy(this_LYNXcharset,argv[4],UC_MAXLEN_LYNXCSNAME);
d673 2
a674 2
	    "makeuctb: %s: %stranslation map",
	    this_MIMEcharset, (this_isDefaultMap ? "default " : ""));
d681 1
a681 1
	    id_append[i+1] = isalnum(UCH(*p)) ? *p : '_';
d687 1
a687 6
    for (n = 0; n < TABLESIZE(first_ifdefs); n++) {
	fprintf(chdr, first_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }

    fprintf(chdr, "\n\
d704 1
a704 1
	fprintf(chdr, "%3d", unicount[i]);
d706 1
a706 1
	    fprintf(chdr, "\n};\n");
d708 1
a708 1
	    fprintf(chdr, ",\n\t");
d710 1
a710 1
	    fprintf(chdr, ", ");
d723 2
a724 2
	fprintf(chdr, "\nstatic CONST u16 dfont_unitable%s[%d] = \n{\n\t",
		id_append, nuni);
d726 1
a726 1
	fprintf(chdr, "\nstatic CONST u16 dfont_unitable%s[1]; /* dummy */\n", id_append);
d736 1
a736 1
	fprintf(chdr, "0x%04x", unitable[fp0][nent++]);
d738 1
a738 1
	    fprintf(chdr, "\n};\n");
d740 1
a740 1
	    fprintf(chdr, ",\n\t");
d742 1
a742 1
	    fprintf(chdr, ", ");
d747 1
a747 1
	fprintf(chdr, "\n\
d751 1
a751 1
	fprintf(chdr, "\n\
d756 3
a758 3
	fprintf(chdr, "{0x%x,\"%s\"}",
		themap_str.entries[i].unicode,
		themap_str.entries[i].replace_str);
d760 1
a760 1
	    fprintf(chdr, "\n};\n");
d762 1
a762 1
	    fprintf(chdr, ",\n\t");
d764 1
a764 1
	    fprintf(chdr, ", ");
d768 1
a768 1
	fprintf(chdr, "\n\
d772 1
a772 1
	fprintf(chdr, "\n\
d775 3
a777 3
    fprintf(chdr, "%d,%d};\n",
	    this_isDefaultMap ? 1 : 0,
	    (useDefaultMap && !this_isDefaultMap) ? 1 : 0
d781 1
a781 1
    fprintf(chdr, "#define UC_CHARSET_SETUP%s UC_Charset_Setup(\
a786 5

    for (n = 0; n < TABLESIZE(last_ifdefs); n++) {
	fprintf(chdr, last_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@a20 1

d28 8
a81 10
#ifdef EXP_ASCII_CTYPES
PUBLIC int ascii_tolower ARGS1(int, i)
{
    if ( 91 > i && i > 64 )
	return (i+32);
    else
	return i;
}
#endif

d437 1
a437 1
		useDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a889 1
    return 0;
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@a18 6
#ifndef HAVE_CONFIG_H
/* override HTUtils.h fallbacks for cross-compiling */
#define HAVE_LSTAT
#define NO_FILIO_H
#endif

d20 1
a20 2
#include <UCDefs.h>
#include <UCkd.h>
d23 1
a23 1
 *  Don't try to use LYexit() since this is a standalone file.
d29 3
d44 1
a44 1
 * do not properly implement POSIX 'exit()'.
d46 2
a47 2
static void done (int code) GCC_NORETURN;
static void done (int code)
d49 2
a50 4
    if (chdr != 0) {
	fflush(chdr);
	fclose(chdr);
    }
d55 1
a55 1
static void usage (void)
d57 1
a57 1
    static const char *tbl[] = {
d76 1
a76 1
int ascii_tolower (int i)
d86 4
a89 4
int strncasecomp (
	const char*	a,
	const char *	b,
	int		n)
d91 2
a92 2
    const char *p = a;
    const char *q = b;
d107 2
a108 2
static int getunicode (
	char **	p0)
d137 2
a138 2
static char *tblname;
static char *hdrname;
d140 4
a143 4
static int RawOrEnc = 0;
static int Raw_found = 0;		/* whether explicit R directive found */
static int CodePage = 0;
static int CodePage_found = 0;		/* whether explicit C directive found */
d147 3
a149 3
static void addpair_str (
	char *		str,
	int		un)
d193 3
a195 3
static void addpair (
	int	fp,
	int	un)
d245 3
a247 3
int main (
	int	argc,
	char **	argv)
d571 3
d582 3
d748 12
a759 1

d793 1
a793 1
static const u8 dfont_unicount%s[%d] = \n\
d819 1
a819 1
	fprintf(chdr, "\nstatic const u16 dfont_unitable%s[%d] = \n{\n\t",
d822 1
a822 1
	fprintf(chdr, "\nstatic const u16 dfont_unitable%s[1]; /* dummy */\n", id_append);
d865 1
a865 1
static const struct unimapdesc_str dfont_replacedesc%s = {%d,repl_map%s,",
d869 1
a869 1
static const struct unimapdesc_str dfont_replacedesc%s = {0,NULL,",id_append);
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d50 2
a51 3
static void done(int code) GCC_NORETURN;

static void done(int code)
d61 1
a61 1
static void usage(void)
d63 1
a63 2
    static const char *tbl[] =
    {
a74 1

d82 1
a82 1
int ascii_tolower(int i)
d84 2
a85 2
    if (91 > i && i > 64)
	return (i + 32);
d92 4
a95 1
int strncasecomp(const char *a, const char *b, int n)
d100 1
a100 1
    for (p = a, q = b;; p++, q++) {
d102 2
a103 3

	if (p == (a + n))
	    return 0;		/*   Match up to n characters */
d110 1
a110 1
    /*NOTREACHED */
d113 2
a114 1
static int getunicode(char **p0)
d128 1
a128 1
	       isxdigit(UCH(p[6]))) {
d131 1
a131 1
    *p0 = p + 6;
d141 1
a141 2
struct unimapdesc_str themap_str =
{0, NULL, 0, 0};
d147 1
a147 1
static int Raw_found = 0;	/* whether explicit R directive found */
d149 1
a149 1
static int CodePage_found = 0;	/* whether explicit C directive found */
d153 3
a155 1
static void addpair_str(char *str, int un)
d157 1
a157 1
    int i = 0;
d164 2
a165 3
	    themap_str.entries = (struct unipair_str *) malloc(MAX_UNIPAIRS
							       * sizeof(struct unipair_str));

d175 2
a176 2
	    for (i = 0; i < themap_str.entry_ct; i++) {
		if (themap_str.entries[i].unicode == un) {
d186 1
a186 1
	if (themap_str.entry_ct > MAX_UNIPAIRS - 1) {
d199 3
a201 1
static void addpair(int fp, int un)
d205 1
a205 1
    if (!Raw_found) {		/* enc not (yet) explicitly given with 'R' */
d211 1
a211 1
		    RawOrEnc = UCT_ENC_8859;	/* hmmm.. more tests needed? */
d216 1
a216 1
		    RawOrEnc = UCT_ENC_8859;	/* hmmm.. more tests needed? */
d244 3
a246 3
char this_MIMEcharset[UC_MAXLEN_MIMECSNAME + 1];
char this_LYNXcharset[UC_MAXLEN_LYNXCSNAME + 1];
char id_append[UC_MAXLEN_ID_APPEND + 1] = "_";
d251 3
a253 1
int main(int argc, char **argv)
d255 1
a255 2
    static char *first_ifdefs[] =
    {
d285 1
a285 2
    static char *last_ifdefs[] =
    {
d368 9
a376 9
	 *      <fontpos>       <unicode> <unicode> ...
	 *      <fontpos>       <unicode range> <unicode range> ...
	 *      <fontpos>       idem
	 *      <range>         idem
	 *      <range>         <unicode range>
	 *      <unicode>       :<replace>
	 *      <unicode range> :<replace>
	 *      <unicode>       "<C replace>"
	 *      <unicode range> "<C replace>"
d400 6
a405 5
	case 'R':
	    if (p[1] == 'a' || p[1] == 'A') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "RawOrEnc", 8)) {
		    p += 8;
a406 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d408 6
a413 4
	    }
	    RawOrEnc = strtol(p, 0, 10);
	    Raw_found = 1;
	    continue;
d418 6
a423 5
	case 'D':
	    if (p[1] == 'e' || p[1] == 'E') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "Default", 7)) {
		    p += 7;
a424 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d426 5
a430 3
	    }
	    this_isDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
	    continue;
d435 6
a440 5
	case 'F':
	    if (p[1] == 'a' || p[1] == 'A') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "FallBack", 8)) {
		    p += 8;
a441 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d443 5
a447 3
	    }
	    useDefaultMap = (*p == '1' || TOLOWER(*p) == 'y');
	    continue;
d449 6
a454 5
	case 'M':
	    if (p[1] == 'i' || p[1] == 'I') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "MIMEName", 8)) {
		    p += 8;
a455 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d457 5
a461 3
	    }
	    sscanf(p, "%40s", this_MIMEcharset);
	    continue;
d466 6
a471 5
	case 'O':
	    if (p[1] == 'p' || p[1] == 'P') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "OptionName", 10)) {
		    p += 10;
a472 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d474 8
a481 6
	    }
	    for (i = 0; *p && i < UC_MAXLEN_LYNXCSNAME; p++, i++) {
		this_LYNXcharset[i] = *p;
	    }
	    this_LYNXcharset[i] = '\0';
	    continue;
d486 6
a491 5
	case 'C':
	    if (p[1] == 'o' || p[1] == 'O') {
		buffer[sizeof(buffer) - 1] = '\0';
		if (!strncasecomp(p, "CodePage", 8)) {
		    p += 8;
a492 3
	    }
	    p++;
	    while (*p == ' ' || *p == '\t') {
d494 6
a499 4
	    }
	    CodePage = strtol(p, 0, 10);
	    CodePage_found = 1;
	    continue;
d508 1
a508 1
			"%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
d540 1
a540 1
	    tbuf = (char *) malloc(4 * strlen(p));
a552 1

d585 1
a585 1
		addpair_str(tbuf, i);
d640 1
a640 1
		    addpair(i, i);
d660 1
a660 1
			    "%s: Bad Unicode range corresponding to font position range 0x%x-0x%x\n",
d666 1
a666 1
			    "%s: Unicode range U+%x-U+%x not of the same length",
d674 1
a674 1
		    addpair(i, un0 - fp0 + i);
d687 1
a687 1
		addpair(fp0, fp0);
d723 1
d728 1
a728 1
    for (i = 0; i < fontlen; i++) {
d733 1
a733 1
	strncpy(this_MIMEcharset, argv[3], UC_MAXLEN_MIMECSNAME);
d735 2
a736 2
	strncpy(this_MIMEcharset, tblname, UC_MAXLEN_MIMECSNAME);
	if ((p = strchr(this_MIMEcharset, '.')) != 0) {
d744 1
a744 1
	strncpy(this_LYNXcharset, argv[4], UC_MAXLEN_LYNXCSNAME);
d746 1
a746 1
	strncpy(this_LYNXcharset, this_MIMEcharset, UC_MAXLEN_LYNXCSNAME);
d750 1
a750 1
	this_isDefaultMap = !strncmp(this_MIMEcharset, "iso-8859-1", 10);
d759 1
a759 1
	     *p && (i < UC_MAXLEN_ID_APPEND - 1);
d761 1
a761 1
	    id_append[i + 1] = isalnum(UCH(*p)) ? *p : '_';
d763 1
a763 1
	id_append[i + 1] = '\0';
d855 1
a855 1
		id_append, themap_str.entry_ct, id_append);
d858 1
a858 1
static const struct unimapdesc_str dfont_replacedesc%s = {0,NULL,", id_append);
d863 2
a864 1
	);
d870 2
a871 2
	    id_append, this_MIMEcharset, this_LYNXcharset,
	    id_append, id_append, nuni, id_append, lowest_eight, RawOrEnc, CodePage);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d21 1
a28 4
#ifndef TOUPPER
#define TOUPPER(c) (islower(UCH(c)) ? toupper(UCH(c)) : (c))
#endif /* !TOLOWER */

d30 1
a30 1
#define TOLOWER(c) (isupper(UCH(c)) ? tolower(UCH(c)) : (c))
a42 2
static FILE *chdr = 0;

d44 1
a44 1
 * Since we may be writing the formatted file to stdout, ensure that we flush
d48 4
a51 8
PRIVATE void done PARAMS((int code)) GCC_NORETURN;
PRIVATE void done ARGS1(int, code)
{
    fflush(chdr);
    fclose(chdr);
    fflush(stderr);
    exit(code);
}
d53 2
a54 1
PRIVATE void usage NOARGS
d56 6
a61 15
    static CONST char *tbl[] = {
	"Usage: makeuctb [parameters]",
	"",
	"Utility to convert .tbl into .h files for Lynx compilation.",
	"",
	"Parameters (all are optional):",
	"  1: the input file (normally {filename}.tbl, but \"-\" for stdin",
	"  2: the output file (normally {filename}.tbl but \"-\" for stdout",
	"  3: charset mime name",
	"  4: charset display name"
    };
    unsigned n;
    for (n = 0; n < TABLESIZE(tbl); n++) {
	fprintf(stderr, "%s\n", tbl[n]);
    };
d75 1
a75 1
	int diff;
d98 2
a99 5
	       !isxdigit(UCH(p[2])) ||
	       !isxdigit(UCH(p[3])) ||
	       !isxdigit(UCH(p[4])) ||
	       !isxdigit(UCH(p[5])) ||
	        isxdigit(UCH(p[6]))) {
d112 1
a112 1
struct unimapdesc_str themap_str = {0, NULL, 0, 0};
d114 1
a114 2
PRIVATE char *tblname;
PRIVATE char *hdrname;
a120 2
#define MAX_UNIPAIRS 2500

d125 1
a125 1
   int i = 0;
d132 2
a133 2
	    themap_str.entries = (struct unipair_str *) malloc (MAX_UNIPAIRS
				* sizeof (struct unipair_str));
d154 1
a154 1
	if (themap_str.entry_ct > MAX_UNIPAIRS-1) {
d156 1
a156 2
		    "ERROR: Only %d unicode replacement strings permitted!\n",
		    MAX_UNIPAIRS);
d172 1
a172 1
    if (!Raw_found) {	/* enc not (yet) explicitly given with 'R' */
a221 37
    static char *first_ifdefs[] = {
	"/*",
	" * Compile-in this chunk of code unless we've turned it off specifically",
	" * or in general (id=%s).",
	" */",
	"",
	"#ifndef INCL_CHARSET%s",
	"#define INCL_CHARSET%s 1",
	"",
	"/*ifdef NO_CHARSET*/",
	"#ifdef  NO_CHARSET",
	"#undef  NO_CHARSET",
	"#endif",
	"#define NO_CHARSET 0 /* force default to always be active */",
	"",
	"/*ifndef NO_CHARSET%s*/",
	"#ifndef NO_CHARSET%s",
	"",
	"#if    ALL_CHARSETS",
	"#define NO_CHARSET%s 0",
	"#else",
	"#define NO_CHARSET%s 1",
	"#endif",
	"",
	"#endif /* ndef(NO_CHARSET%s) */",
	"",
	"#if NO_CHARSET%s",
	"#define UC_CHARSET_SETUP%s /*nothing*/",
	"#else"
    };
    static char *last_ifdefs[] = {
	"",
	"#endif /* NO_CHARSET%s */",
	"",
	"#endif /* INCL_CHARSET%s */"
    };

a223 2
    char outname[256];
    unsigned n;
d226 1
a226 1
    int fp0 = 0, fp1 = 0, un0, un1;
d230 2
a231 2
    if (argc < 2 || argc > 5) {
	usage();
a244 25
    if (argc > 2) {
	if (!strcmp(argv[2], "-")) {
	    chdr = stdout;
	    hdrname = "stdout";
	} else {
	    hdrname = argv[2];
	}
    } else if (ctbl == stdin) {
	chdr = stdout;
	hdrname = "stdout";
    } else {
	strcpy(hdrname = outname, tblname);
	if ((p = strrchr(outname, '.')) == 0)
	    p = outname + strlen(outname);
	strcpy(p, ".h");
    }

    if (chdr == 0) {
	chdr = fopen(hdrname, "w");
	if (!chdr) {
	    perror(hdrname);
	    done(EX_NOINPUT);
	}
    }

d312 1
a312 1
		    p++;
d321 1
a321 1
	    case 'D':
d338 1
a338 1
	    case 'F':
d398 1
a398 1
		    p++;
d477 3
a479 3
		    if (UCH(ch) < 32 || ch == '\\' || ch == '\"' ||
			UCH(ch) >= 127) {
			sprintf(p1, "\\%.3o", UCH(ch));
d492 1
a492 1
		fprintf(chdr, "U+0x%x:%s\n", i, tbuf); */
d508 1
a508 1
	}
d522 1
a522 1
	} else {
d564 1
a564 1
		}
d572 1
a572 1
		}
d581 1
a581 1
		}
d641 2
a642 2
    if (argc > 3) {
	strncpy(this_MIMEcharset,argv[3],UC_MAXLEN_MIMECSNAME);
d652 2
a653 2
    if (argc > 4) {
	strncpy(this_LYNXcharset,argv[4],UC_MAXLEN_LYNXCSNAME);
d673 2
a674 2
	    "makeuctb: %s: %stranslation map",
	    this_MIMEcharset, (this_isDefaultMap ? "default " : ""));
d681 1
a681 1
	    id_append[i+1] = isalnum(UCH(*p)) ? *p : '_';
d687 1
a687 6
    for (n = 0; n < TABLESIZE(first_ifdefs); n++) {
	fprintf(chdr, first_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }

    fprintf(chdr, "\n\
d704 1
a704 1
	fprintf(chdr, "%3d", unicount[i]);
d706 1
a706 1
	    fprintf(chdr, "\n};\n");
d708 1
a708 1
	    fprintf(chdr, ",\n\t");
d710 1
a710 1
	    fprintf(chdr, ", ");
d723 2
a724 2
	fprintf(chdr, "\nstatic CONST u16 dfont_unitable%s[%d] = \n{\n\t",
		id_append, nuni);
d726 1
a726 1
	fprintf(chdr, "\nstatic CONST u16 dfont_unitable%s[1]; /* dummy */\n", id_append);
d736 1
a736 1
	fprintf(chdr, "0x%04x", unitable[fp0][nent++]);
d738 1
a738 1
	    fprintf(chdr, "\n};\n");
d740 1
a740 1
	    fprintf(chdr, ",\n\t");
d742 1
a742 1
	    fprintf(chdr, ", ");
d747 1
a747 1
	fprintf(chdr, "\n\
d751 1
a751 1
	fprintf(chdr, "\n\
d756 3
a758 3
	fprintf(chdr, "{0x%x,\"%s\"}",
		themap_str.entries[i].unicode,
		themap_str.entries[i].replace_str);
d760 1
a760 1
	    fprintf(chdr, "\n};\n");
d762 1
a762 1
	    fprintf(chdr, ",\n\t");
d764 1
a764 1
	    fprintf(chdr, ", ");
d768 1
a768 1
	fprintf(chdr, "\n\
d772 1
a772 1
	fprintf(chdr, "\n\
d775 3
a777 3
    fprintf(chdr, "%d,%d};\n",
	    this_isDefaultMap ? 1 : 0,
	    (useDefaultMap && !this_isDefaultMap) ? 1 : 0
d781 1
a781 1
    fprintf(chdr, "#define UC_CHARSET_SETUP%s UC_Charset_Setup(\
a786 5

    for (n = 0; n < TABLESIZE(last_ifdefs); n++) {
	fprintf(chdr, last_ifdefs[n], id_append);
	fprintf(chdr, "\n");
    }
@

