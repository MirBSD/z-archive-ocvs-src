head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.8
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.6
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.7.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.56;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.15.18.16.54;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.04.30.16.32.32;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.18.16.56.12;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.13.12.45;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.22;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.44;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.13;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.45.57;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.38;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.50;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.51.22;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTParse.h>
#include <HTList.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYDownload.h>

#include <LYLeaks.h>

/*
 * LYDownload takes a URL and downloads it using a user selected download
 * program
 *
 * It parses an incoming link that looks like
 *
 * LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
 */
#ifdef VMS
BOOLEAN LYDidRename = FALSE;
#endif /* VMS */

static char LYValidDownloadFile[LY_MAXPATH] = "\0";

void LYDownload(char *line)
{
    char *Line = NULL, *method, *file, *sug_file = NULL;
    int method_number;
    int count;
    char *the_command = 0;
    char buffer[LY_MAXPATH];
    char command[LY_MAXPATH];
    char *cp;
    lynx_list_item_type *download_command = 0;
    int ch;
    RecallType recall;
    int FnameTotal;
    int FnameNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN SecondS = FALSE;

#ifdef VMS
    LYDidRename = FALSE;
#endif /* VMS */

    /*
     * Make sure we have a valid download file comparison string loaded via the
     * download options menu.  - FM
     */
    if (LYValidDownloadFile[0] == '\0') {
	goto failed;
    }

    /*
     * Make a copy of the LYNXDOWNLOAD internal URL for parsing.  - FM
     */
    StrAllocCopy(Line, line);

    /*
     * Parse out the File, sug_file, and the Method.
     */
    if ((file = strstr(Line, "/File=")) == NULL)
	goto failed;
    *file = '\0';
    /*
     * Go past "File=".
     */
    file += 6;

    if ((sug_file = strstr(file + 1, "/SugFile=")) != NULL) {
	*sug_file = '\0';
	/*
	 * Go past "SugFile=".
	 */
	sug_file += 9;
	HTUnEscape(sug_file);
    }

    /*
     * Make sure that the file string is the one from the last displayed
     * download options menu.  - FM
     */
    if (strcmp(file, LYValidDownloadFile)) {
	goto failed;
    }
#if defined(DIRED_SUPPORT)
    /* FIXME: use HTLocalName */
    if (!strncmp(file, "file://localhost", 16)) {
#ifdef __DJGPP__
	if (!strncmp(file + 16, "/dev/", 5))
	    file += 16;
	else {
	    file += 17;
	    file = HTDOS_name(file);
	}
#else
	file += 16;
#endif /* __DJGPP__ */
    } else if (isFILE_URL(file))
	file += LEN_FILE_URL;
    HTUnEscape(file);
#else
#if defined(_WINDOWS)		/* 1997/10/15 (Wed) 16:27:38 */
    if (!strncmp(file, "file://localhost/", 17))
	file += 17;
    else if (!strncmp(file, "file:/", 6))
	file += 6;
    HTUnEscape(file);
#endif /* _WINDOWS */
#endif /* DIRED_SUPPORT */

    if ((method = strstr(Line, "Method=")) == NULL)
	goto failed;
    /*
     * Go past "Method=".
     */
    method += 7;
    method_number = atoi(method);

    /*
     * Set up the sug_filenames recall buffer.
     */
    FnameTotal = (sug_filenames ? HTList_count(sug_filenames) : 0);
    recall = ((FnameTotal >= 1) ? RECALL_URL : NORECALL);
    FnameNum = FnameTotal;

    if (method_number < 0) {
	/*
	 * Write to local file.
	 */
	_statusline(FILENAME_PROMPT);
      retry:
	if (sug_file)
	    LYstrncpy(buffer, sug_file, ((sizeof(buffer) / 2) - 1));
	else
	    *buffer = '\0';
      check_recall:
	if ((ch = LYgetstr(buffer,
			   VISIBLE, (sizeof(buffer) / 2), recall)) < 0 ||
	    *buffer == '\0' || ch == UPARROW || ch == DNARROW) {
	    if (recall && ch == UPARROW) {
		if (FirstRecall) {
		    FirstRecall = FALSE;
		    /*
		     * Use the last Fname in the list.  - FM
		     */
		    FnameNum = 0;
		} else {
		    /*
		     * Go back to the previous Fname in the list.  - FM
		     */
		    FnameNum++;
		}
		if (FnameNum >= FnameTotal) {
		    /*
		     * Reset the FirstRecall flag, and use sug_file or a blank. 
		     * - FM
		     */
		    FirstRecall = TRUE;
		    FnameNum = FnameTotal;
		    _statusline(FILENAME_PROMPT);
		    goto retry;
		} else if ((cp = (char *) HTList_objectAt(sug_filenames,
							  FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
		    if (FnameTotal == 1) {
			_statusline(EDIT_THE_PREV_FILENAME);
		    } else {
			_statusline(EDIT_A_PREV_FILENAME);
		    }
		    goto check_recall;
		}
	    } else if (recall && ch == DNARROW) {
		if (FirstRecall) {
		    FirstRecall = FALSE;
		    /*
		     * Use the first Fname in the list.  - FM
		     */
		    FnameNum = FnameTotal - 1;
		} else {
		    /*
		     * Advance to the next Fname in the list.  - FM
		     */
		    FnameNum--;
		}
		if (FnameNum < 0) {
		    /*
		     * Set the FirstRecall flag, and use sug_file or a blank. 
		     * - FM
		     */
		    FirstRecall = TRUE;
		    FnameNum = FnameTotal;
		    _statusline(FILENAME_PROMPT);
		    goto retry;
		} else if ((cp = (char *) HTList_objectAt(sug_filenames,
							  FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
		    if (FnameTotal == 1) {
			_statusline(EDIT_THE_PREV_FILENAME);
		    } else {
			_statusline(EDIT_A_PREV_FILENAME);
		    }
		    goto check_recall;
		}
	    }

	    /*
	     * Save cancelled.
	     */
	    goto cancelled;
	}

	strcpy(command, buffer);
	if (!LYValidateFilename(buffer, command))
	    goto cancelled;
#ifdef HAVE_POPEN
	else if (LYIsPipeCommand(buffer)) {
	    /* I don't know how to download to a pipe */
	    HTAlert(CANNOT_WRITE_TO_FILE);
	    _statusline(NEW_FILENAME_PROMPT);
	    FirstRecall = TRUE;
	    FnameNum = FnameTotal;
	    goto retry;
	}
#endif

	/*
	 * See if it already exists.
	 */
	switch (LYValidateOutput(buffer)) {
	case 'Y':
	    break;
	case 'N':
	    _statusline(NEW_FILENAME_PROMPT);
	    FirstRecall = TRUE;
	    FnameNum = FnameTotal;
	    goto retry;
	default:
	    FREE(Line);
	    return;
	}

	/*
	 * See if we can write to it.
	 */
	CTRACE((tfp, "LYDownload: filename is %s\n", buffer));

	if (!LYCanWriteFile(buffer)) {
	    FirstRecall = TRUE;
	    FnameNum = FnameTotal;
	    goto retry;
	}
	SecondS = TRUE;

	HTInfoMsg(SAVING);
#ifdef VMS
	/*
	 * Try rename() first.  - FM
	 */
	CTRACE((tfp, "command: rename(%s, %s)\n", file, buffer));
	if (rename(file, buffer)) {
	    /*
	     * Failed.  Use spawned COPY_COMMAND.  - FM
	     */
	    CTRACE((tfp, "         FAILED!\n"));
	    LYCopyFile(file, buffer);
	} else {
	    /*
	     * We don't have the temporary file (it was renamed to a permanent
	     * file), so set a flag to pop out of the download menu.  - FM
	     */
	    LYDidRename = TRUE;
	}
	chmod(buffer, HIDE_CHMOD);
#else /* Unix: */

	LYCopyFile(file, buffer);
	LYRelaxFilePermissions(buffer);
#endif /* VMS */

    } else {
	/*
	 * Use configured download commands.
	 */
	buffer[0] = '\0';
	for (count = 0, download_command = downloaders;
	     count < method_number;
	     count++, download_command = download_command->next) ;	/* null body */

	/*
	 * Commands have the form "command %s [etc]" where %s is the filename.
	 */
	if (download_command->command != NULL) {
	    /*
	     * Check for two '%s' and ask for the local filename if there is.
	     */
	    if (HTCountCommandArgs(download_command->command) >= 2) {
		_statusline(FILENAME_PROMPT);
	      again:if (sug_file)
		    strncpy(buffer, sug_file, (sizeof(buffer) / 2) - 1);
		else
		    *buffer = '\0';
	      check_again:
		if ((ch = LYgetstr(buffer, VISIBLE,
				   sizeof(buffer), recall)) < 0 ||
		    *buffer == '\0' || ch == UPARROW || ch == DNARROW) {
		    if (recall && ch == UPARROW) {
			if (FirstRecall) {
			    FirstRecall = FALSE;
			    /*
			     * Use the last Fname in the list.  - FM
			     */
			    FnameNum = 0;
			} else {
			    /*
			     * Go back to the previous Fname in the list.  - FM
			     */
			    FnameNum++;
			}
			if (FnameNum >= FnameTotal) {
			    /*
			     * Reset the FirstRecall flag, and use sug_file or
			     * a blank.  - FM
			     */
			    FirstRecall = TRUE;
			    FnameNum = FnameTotal;
			    _statusline(FILENAME_PROMPT);
			    goto again;
			} else if ((cp = (char *) HTList_objectAt(sug_filenames,
								  FnameNum))
				   != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
			    if (FnameTotal == 1) {
				_statusline(EDIT_THE_PREV_FILENAME);
			    } else {
				_statusline(EDIT_A_PREV_FILENAME);
			    }
			    goto check_again;
			}
		    } else if (recall && ch == DNARROW) {
			if (FirstRecall) {
			    FirstRecall = FALSE;
			    /*
			     * Use the first Fname in the list.  - FM
			     */
			    FnameNum = FnameTotal - 1;
			} else {
			    /*
			     * Advance to the next Fname in the list.  - FM
			     */
			    FnameNum--;
			}
			if (FnameNum < 0) {
			    /*
			     * Set the FirstRecall flag, and use sug_file or a
			     * blank.  - FM
			     */
			    FirstRecall = TRUE;
			    FnameNum = FnameTotal;
			    _statusline(FILENAME_PROMPT);
			    goto again;
			} else if ((cp = (char *) HTList_objectAt(sug_filenames,
								  FnameNum))
				   != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
			    if (FnameTotal == 1) {
				_statusline(EDIT_THE_PREV_FILENAME);
			    } else {
				_statusline(EDIT_A_PREV_FILENAME);
			    }
			    goto check_again;
			}
		    }

		    /*
		     * Download cancelled.
		     */
		    goto cancelled;
		}

		if (no_dotfiles || !show_dotfiles) {
		    if (*LYPathLeaf(buffer) == '.') {
			HTAlert(FILENAME_CANNOT_BE_DOT);
			_statusline(NEW_FILENAME_PROMPT);
			goto again;
		    }
		}
		/*
		 * Cancel if the user entered "/dev/null" on Unix, or an "nl:"
		 * path on VMS.  - FM
		 */
		if (LYIsNullDevice(buffer)) {
		    goto cancelled;
		}
		SecondS = TRUE;
	    }

	    /*
	     * The following is considered a bug by the community.  If the
	     * command only takes one argument on the command line, then the
	     * suggested file name is not used.  It actually is not a bug at
	     * all and does as it should, putting both names on the command
	     * line.
	     */
	    count = 1;
	    HTAddParam(&the_command, download_command->command, count, file);
	    if (HTCountCommandArgs(download_command->command) > 1)
		HTAddParam(&the_command, download_command->command, ++count, buffer);
	    HTEndParam(&the_command, download_command->command, count);

	} else {
	    HTAlert(MISCONF_DOWNLOAD_COMMAND);
	    goto failed;
	}

	CTRACE((tfp, "command: %s\n", the_command));
	stop_curses();
	LYSystem(the_command);
	FREE(the_command);
	start_curses();
	/* don't remove(file); */
    }

    if (SecondS == TRUE) {
#ifdef VMS
	if (0 == strncasecomp(buffer, "sys$disk:", 9)) {
	    if (0 == strncmp((buffer + 9), "[]", 2)) {
		HTAddSugFilename(buffer + 11);
	    } else {
		HTAddSugFilename(buffer + 9);
	    }
	} else {
	    HTAddSugFilename(buffer);
	}
#else
	HTAddSugFilename(buffer);
#endif /* VMS */
    }
    FREE(Line);
    return;

  failed:
    HTAlert(CANNOT_DOWNLOAD_FILE);
    FREE(Line);
    return;

  cancelled:
    HTInfoMsg(CANCELLING);
    FREE(Line);
    return;
}

/*
 * Compare a filename with a given suffix, which we have set to give a rough
 * idea of its content.
 */
static int SuffixIs(char *filename, const char *suffix)
{
    size_t have = strlen(filename);
    size_t need = strlen(suffix);

    return have > need && !strcmp(filename + have - need, suffix);
}

/*
 * LYdownload_options writes out the current download choices to a file so that
 * the user can select downloaders in the same way that they select all other
 * links.  Download links look like: 
 * LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
 */
int LYdownload_options(char **newfile, char *data_file)
{
    static char tempfile[LY_MAXPATH] = "\0";
    char *downloaded_url = NULL;
    char *sug_filename = NULL;
    FILE *fp0;
    lynx_list_item_type *cur_download;
    int count;

    /*
     * Get a suggested filename.
     */
    StrAllocCopy(sug_filename, *newfile);
    change_sug_filename(sug_filename);

    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (-1);

    StrAllocCopy(downloaded_url, *newfile);
    LYLocalFileToURL(newfile, tempfile);

    LYstrncpy(LYValidDownloadFile,
	      data_file,
	      (sizeof(LYValidDownloadFile) - 1));
    LYforce_no_cache = TRUE;	/* don't cache this doc */

    BeginInternalPage(fp0, DOWNLOAD_OPTIONS_TITLE, DOWNLOAD_OPTIONS_HELP);

    fprintf(fp0, "<pre>\n");
    fprintf(fp0, "<em>%s</em> %s\n",
	    gettext("Downloaded link:"),
	    downloaded_url);
    FREE(downloaded_url);

    fprintf(fp0, "<em>%s</em> %s\n",
	    gettext("Suggested file name:"),
	    sug_filename);

    fprintf(fp0, "\n%s\n",
	    (user_mode == NOVICE_MODE)
	    ? gettext("Standard download options:")
	    : gettext("Download options:"));

    if (!no_disk_save && !child_lynx) {
#if defined(DIRED_SUPPORT)
	/*
	 * Disable save to disk option for local files.
	 */
	if (!lynx_edit_mode)
#endif /* DIRED_SUPPORT */
	{
	    fprintf(fp0,
		    "   <a href=\"%s//Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
		    STR_LYNXDOWNLOAD,
		    data_file,
		    NonNull(lynx_save_space),
		    sug_filename,
		    gettext("Save to disk"));
	    /*
	     * If it is not a binary file, offer the opportunity to view the
	     * downloaded temporary file (see HTSaveToFile).
	     */
	    if (SuffixIs(data_file, HTML_SUFFIX)
		|| SuffixIs(data_file, TEXT_SUFFIX)) {
		char *target = NULL;
		char *source = LYAddPathToSave(data_file);

		LYLocalFileToURL(&target, source);
		fprintf(fp0,
			"   <a href=\"%s\">%s</a>\n",
			target,
			gettext("View temporary file"));

		FREE(source);
		FREE(target);
	    }
	}
    } else {
	fprintf(fp0, "   <em>%s</em>\n", gettext("Save to disk disabled."));
    }

    if (user_mode == NOVICE_MODE)
	fprintf(fp0, "\n%s\n", gettext("Local additions:"));

    if (downloaders != NULL) {
	for (count = 0, cur_download = downloaders; cur_download != NULL;
	     cur_download = cur_download->next, count++) {
	    if (!no_download || cur_download->always_enabled) {
		fprintf(fp0,
			"   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">",
			STR_LYNXDOWNLOAD, count, data_file, sug_filename);
		fprintf(fp0, "%s", (cur_download->name
				    ? cur_download->name
				    : gettext("No Name Given")));
		fprintf(fp0, "</a>\n");
	    }
	}
    }

    fprintf(fp0, "</pre>\n");
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);
    LYRegisterUIPage(*newfile, UIP_DOWNLOAD_OPTIONS);

    /*
     * Free off temp copy.
     */
    FREE(sug_filename);

    return (0);
}
@


1.7
log
@automatic merge of lynx-current
@
text
@d37 2
a38 1
    int ch, recall;
d459 1
a459 1
static int SuffixIs(char *filename, char *suffix)
@


1.6
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d14 2
a15 2
 *  LYDownload takes a URL and downloads it using a user selected
 *  download program
d17 1
a17 1
 *  It parses an incoming link that looks like
d19 1
a19 1
 *  LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
d27 1
a27 2
void LYDownload (
	char *		line)
d42 1
d48 2
a49 3
     *	Make sure we have a valid download
     *	file comparison string loaded via
     *	the download options menu. - FM
d56 1
a56 2
     *	Make a copy of the LYNXDOWNLOAD
     *	internal URL for parsing. - FM
d61 1
a61 1
     *	Parse out the File, sug_file, and the Method.
d67 1
a67 1
     *	Go past "File=".
d74 1
a74 1
	 *  Go past "SugFile=".
d81 2
a82 2
     *	Make sure that the file string is the one from
     *	the last displayed download options menu. - FM
a86 1

d100 1
a100 2
    }
    else if (isFILE_URL(file))
d104 1
a104 1
#if defined(_WINDOWS)	/* 1997/10/15 (Wed) 16:27:38 */
d116 1
a116 1
     *	Go past "Method=".
d122 1
a122 1
     *	Set up the sug_filenames recall buffer.
d130 1
a130 1
	 *  Write to local file.
d133 1
a133 1
retry:
d135 1
a135 1
	    LYstrncpy(buffer, sug_file, ((sizeof(buffer)/2) - 1));
d138 1
a138 1
check_recall:
d140 1
a140 1
			   VISIBLE, (sizeof(buffer)/2), recall)) < 0 ||
d146 1
a146 1
		     *	Use the last Fname in the list. - FM
d151 1
a151 1
		     *	Go back to the previous Fname in the list. - FM
d157 2
a158 2
		     *	Reset the FirstRecall flag,
		     *	and use sug_file or a blank. - FM
d164 3
a166 4
		} else if ((cp = (char *)HTList_objectAt(
						sug_filenames,
						FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d178 1
a178 1
		     *	Use the first Fname in the list. - FM
d183 1
a183 1
		     *	Advance to the next Fname in the list. - FM
d189 2
a190 2
		     *	Set the FirstRecall flag,
		     *	and use sug_file or a blank. - FM
d196 3
a198 4
		} else if ((cp = (char *)HTList_objectAt(
						sug_filenames,
						FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d209 1
a209 1
	     *	Save cancelled.
d229 1
a229 1
	 *  See if it already exists.
d245 1
a245 1
	 *  See if we can write to it.
d249 1
a249 1
	if (! LYCanWriteFile(buffer)) {
d259 1
a259 1
	 *  Try rename() first. - FM
d264 1
a264 1
	     *	Failed.  Use spawned COPY_COMMAND. - FM
d270 2
a271 3
	     *	We don't have the temporary file (it was renamed to
	     *	a permanent file), so set a flag to pop out of the
	     *	download menu. - FM
d284 1
a284 1
	 *  Use configured download commands.
d287 1
a287 1
	for (count = 0, download_command=downloaders;
d289 1
a289 2
	     count++, download_command = download_command->next)
	    ; /* null body */
d292 1
a292 2
	 *  Commands have the form "command %s [etc]"
	 *  where %s is the filename.
d296 1
a296 2
	     *	Check for two '%s' and ask for the local filename if
	     *	there is.
d300 2
a301 2
	again:	if (sug_file)
		    strncpy(buffer, sug_file, (sizeof(buffer)/2) - 1);
d304 1
a304 1
	check_again:
d312 1
a312 1
			     *	Use the last Fname in the list. - FM
d317 1
a317 2
			     *	Go back to the previous Fname
			     *	in the list. - FM
d323 2
a324 2
			     *	Reset the FirstRecall flag,
			     *	and use sug_file or a blank. - FM
d330 4
a333 4
			} else if ((cp = (char *)HTList_objectAt(
							sug_filenames,
							FnameNum)) != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d345 1
a345 1
			     *	Use the first Fname in the list. - FM
d350 1
a350 1
			     *	Advance to the next Fname in the list. - FM
d356 2
a357 2
			     *	Set the FirstRecall flag,
			     *	and use sug_file or a blank. - FM
d363 4
a366 4
			} else if ((cp = (char *)HTList_objectAt(
							sug_filenames,
							FnameNum)) != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d390 2
a391 2
		 *  Cancel if the user entered "/dev/null" on Unix,
		 *  or an "nl:" path on VMS. - FM
d400 5
a404 5
	     *	The following is considered a bug by the community.
	     *	If the command only takes one argument on the command
	     *	line, then the suggested file name is not used.
	     *	It actually is not a bug at all and does as it should,
	     *	putting both names on the command line.
d428 2
a429 2
	    if (0 == strncmp((buffer+9), "[]", 2)) {
		HTAddSugFilename(buffer+11);
d431 1
a431 1
		HTAddSugFilename(buffer+9);
d443 1
a443 1
failed:
d448 1
a448 1
cancelled:
d458 1
a458 3
static int SuffixIs (
	char *		filename,
	char *		suffix)
d462 1
d467 4
a470 4
 *  LYdownload_options writes out the current download choices to
 *  a file so that the user can select downloaders in the same way that
 *  they select all other links.  Download links look like:
 *  LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
d472 1
a472 3
int LYdownload_options (
	char **	newfile,
	char *		data_file)
d482 1
a482 1
     *	Get a suggested filename.
d488 1
a488 1
	return(-1);
d496 1
a496 2
    LYforce_no_cache = TRUE;  /* don't cache this doc */

d518 1
a518 1
	 *  Disable save to disk option for local files.
d535 1
a535 1
	     || SuffixIs(data_file, TEXT_SUFFIX)) {
d558 1
a558 1
			cur_download = cur_download->next, count++) {
d560 7
a566 5
		fprintf(fp0, "   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">",
			STR_LYNXDOWNLOAD, count,data_file, sug_filename);
		fprintf(fp0, "%s", (cur_download->name ?
			cur_download->name : gettext("No Name Given")));
		fprintf(fp0,"</a>\n");
d577 1
a577 1
     *	Free off temp copy.
d581 1
a581 1
    return(0);
@


1.5
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d22 1
a22 1
PUBLIC BOOLEAN LYDidRename = FALSE;
d25 1
a25 1
PRIVATE char LYValidDownloadFile[LY_MAXPATH] = "\0";
d27 2
a28 2
PUBLIC void LYDownload ARGS1(
	char *,		line)
d469 3
a471 3
PRIVATE int SuffixIs ARGS2(
	char *,		filename,
	char *,		suffix)
d484 3
a486 3
PUBLIC int LYdownload_options ARGS2(
	char **,	newfile,
	char *,		data_file)
@


1.4
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d552 1
a552 4
		char *source = NULL;

		StrAllocCopy(source, NonNull(lynx_save_space));
		StrAllocCat(source, data_file);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d503 1
a503 1
 
d551 7
d559 2
a560 3
			"   <a href=\"file://localhost%s%s\">%s</a>\n",
			NonNull(lynx_save_space),
			data_file,
d562 3
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d28 1
a28 1
	char *, 	line)
d37 1
a37 2
    lynx_html_item_type *download_command = 0;
    FILE *fp;
d63 1
a63 1
     *	Parse out the sug_file, Method and the File.
d65 10
a74 2
    if ((sug_file = (char *)strstr(Line, "SugFile=")) != NULL) {
	*(sug_file-1) = '\0';
d78 1
a78 1
	sug_file += 8;
a81 8
    if ((file = (char *)strstr(Line, "File=")) == NULL)
	goto failed;
    *(file-1) = '\0';
    /*
     *	Go past "File=".
     */
    file += 5;

d90 1
a90 1
#ifdef DIRED_SUPPORT
d92 9
a100 1
    if (!strncmp(file, "file://localhost", 16))
d102 11
a112 2
    else if (!strncmp(file, "file:", 5))
	file += 5;
d114 1
d117 1
a117 1
    if ((method = (char *)strstr(Line, "Method=")) == NULL)
d129 1
a129 1
    recall = ((FnameTotal >= 1) ? RECALL : NORECALL);
d171 1
a171 1
		    strcpy(buffer, cp);
d204 1
a204 1
		    strcpy(buffer, cp);
d223 1
a223 1
#if HAVE_POPEN
d253 1
a253 1
	CTRACE(tfp, "LYDownload: filename is %s", buffer);
d255 1
a255 6
	if ((fp = fopen(buffer, "w")) != NULL) {
	    fclose(fp);
	    remove(buffer);
	} else {
	    HTAlert(CANNOT_WRITE_TO_FILE);
	    _statusline(NEW_FILENAME_PROMPT);
d267 1
a267 1
	CTRACE(tfp, "command: rename(%s, %s)\n", file, buffer);
d272 1
a272 1
	    CTRACE(tfp, "         FAILED!\n");
a285 2

#if defined(UNIX)
a286 1
#endif /* defined(UNIX) */
d344 1
a344 1
			    strcpy(buffer, cp);
d377 1
a377 1
			    strcpy(buffer, cp);
d402 1
a402 1
		 *  or an "nl:" path (case-insensitive) on VMS. - FM
d404 1
a404 7
#ifdef VMS
		if (!strncasecomp(buffer, "nl:", 3) ||
		    !strncasecomp(buffer, "/nl/", 4))
#else
		if (!strcmp(buffer, "/dev/null"))
#endif /* VMS */
		{
d428 1
a428 1
	CTRACE(tfp, "command: %s\n", the_command);
d466 13
d486 1
a486 1
	char *, 	data_file)
d488 1
a488 1
    static char tempfile[LY_MAXPATH];
d492 1
a492 1
    lynx_html_item_type *cur_download;
d501 1
a501 3
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
d503 1
a503 1
    }
d517 1
a517 1
    	    gettext("Downloaded link:"),
d522 1
a522 1
    	    gettext("Suggested file name:"),
d531 1
a531 1
#ifdef DIRED_SUPPORT
d537 21
a557 6
	fprintf(fp0,
		"   <a href=\"LYNXDOWNLOAD://Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
		data_file,
		(lynx_save_space ? lynx_save_space : ""),
		sug_filename,
		gettext("Save to disk"));
d569 2
a570 2
		fprintf(fp0, "   <a href=\"LYNXDOWNLOAD://Method=%d/File=%s/SugFile=%s\">",
			count,data_file, sug_filename);
d581 1
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d14 2
a15 2
 * LYDownload takes a URL and downloads it using a user selected download
 * program
d17 1
a17 1
 * It parses an incoming link that looks like
d19 1
a19 1
 * LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
d22 1
a22 1
BOOLEAN LYDidRename = FALSE;
d25 1
a25 1
static char LYValidDownloadFile[LY_MAXPATH] = "\0";
d27 2
a28 1
void LYDownload(char *line)
d37 3
a39 3
    lynx_list_item_type *download_command = 0;
    int ch;
    RecallType recall;
a43 1

d49 3
a51 2
     * Make sure we have a valid download file comparison string loaded via the
     * download options menu.  - FM
d58 2
a59 1
     * Make a copy of the LYNXDOWNLOAD internal URL for parsing.  - FM
d64 1
a64 1
     * Parse out the File, sug_file, and the Method.
d66 2
a67 10
    if ((file = strstr(Line, "/File=")) == NULL)
	goto failed;
    *file = '\0';
    /*
     * Go past "File=".
     */
    file += 6;

    if ((sug_file = strstr(file + 1, "/SugFile=")) != NULL) {
	*sug_file = '\0';
d69 1
a69 1
	 * Go past "SugFile=".
d71 1
a71 1
	sug_file += 9;
d75 8
d84 2
a85 2
     * Make sure that the file string is the one from the last displayed
     * download options menu.  - FM
d90 2
a91 1
#if defined(DIRED_SUPPORT)
d93 1
a93 9
    if (!strncmp(file, "file://localhost", 16)) {
#ifdef __DJGPP__
	if (!strncmp(file + 16, "/dev/", 5))
	    file += 16;
	else {
	    file += 17;
	    file = HTDOS_name(file);
	}
#else
d95 2
a96 10
#endif /* __DJGPP__ */
    } else if (isFILE_URL(file))
	file += LEN_FILE_URL;
    HTUnEscape(file);
#else
#if defined(_WINDOWS)		/* 1997/10/15 (Wed) 16:27:38 */
    if (!strncmp(file, "file://localhost/", 17))
	file += 17;
    else if (!strncmp(file, "file:/", 6))
	file += 6;
a97 1
#endif /* _WINDOWS */
d100 1
a100 1
    if ((method = strstr(Line, "Method=")) == NULL)
d103 1
a103 1
     * Go past "Method=".
d109 1
a109 1
     * Set up the sug_filenames recall buffer.
d112 1
a112 1
    recall = ((FnameTotal >= 1) ? RECALL_URL : NORECALL);
d117 1
a117 1
	 * Write to local file.
d120 1
a120 1
      retry:
d122 1
a122 1
	    LYstrncpy(buffer, sug_file, ((sizeof(buffer) / 2) - 1));
d125 1
a125 1
      check_recall:
d127 1
a127 1
			   VISIBLE, (sizeof(buffer) / 2), recall)) < 0 ||
d133 1
a133 1
		     * Use the last Fname in the list.  - FM
d138 1
a138 1
		     * Go back to the previous Fname in the list.  - FM
d144 2
a145 2
		     * Reset the FirstRecall flag, and use sug_file or a blank. 
		     * - FM
d151 4
a154 3
		} else if ((cp = (char *) HTList_objectAt(sug_filenames,
							  FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d166 1
a166 1
		     * Use the first Fname in the list.  - FM
d171 1
a171 1
		     * Advance to the next Fname in the list.  - FM
d177 2
a178 2
		     * Set the FirstRecall flag, and use sug_file or a blank. 
		     * - FM
d184 4
a187 3
		} else if ((cp = (char *) HTList_objectAt(sug_filenames,
							  FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d198 1
a198 1
	     * Save cancelled.
d206 1
a206 1
#ifdef HAVE_POPEN
d218 1
a218 1
	 * See if it already exists.
d234 1
a234 1
	 * See if we can write to it.
d236 1
a236 1
	CTRACE((tfp, "LYDownload: filename is %s\n", buffer));
d238 6
a243 1
	if (!LYCanWriteFile(buffer)) {
d253 1
a253 1
	 * Try rename() first.  - FM
d255 1
a255 1
	CTRACE((tfp, "command: rename(%s, %s)\n", file, buffer));
d258 1
a258 1
	     * Failed.  Use spawned COPY_COMMAND.  - FM
d260 1
a260 1
	    CTRACE((tfp, "         FAILED!\n"));
d264 3
a266 2
	     * We don't have the temporary file (it was renamed to a permanent
	     * file), so set a flag to pop out of the download menu.  - FM
d274 2
d277 1
d282 1
a282 1
	 * Use configured download commands.
d285 1
a285 1
	for (count = 0, download_command = downloaders;
d287 2
a288 1
	     count++, download_command = download_command->next) ;	/* null body */
d291 2
a292 1
	 * Commands have the form "command %s [etc]" where %s is the filename.
d296 2
a297 1
	     * Check for two '%s' and ask for the local filename if there is.
d301 2
a302 2
	      again:if (sug_file)
		    strncpy(buffer, sug_file, (sizeof(buffer) / 2) - 1);
d305 1
a305 1
	      check_again:
d313 1
a313 1
			     * Use the last Fname in the list.  - FM
d318 2
a319 1
			     * Go back to the previous Fname in the list.  - FM
d325 2
a326 2
			     * Reset the FirstRecall flag, and use sug_file or
			     * a blank.  - FM
d332 4
a335 4
			} else if ((cp = (char *) HTList_objectAt(sug_filenames,
								  FnameNum))
				   != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d347 1
a347 1
			     * Use the first Fname in the list.  - FM
d352 1
a352 1
			     * Advance to the next Fname in the list.  - FM
d358 2
a359 2
			     * Set the FirstRecall flag, and use sug_file or a
			     * blank.  - FM
d365 4
a368 4
			} else if ((cp = (char *) HTList_objectAt(sug_filenames,
								  FnameNum))
				   != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d392 2
a393 2
		 * Cancel if the user entered "/dev/null" on Unix, or an "nl:"
		 * path on VMS.  - FM
d395 7
a401 1
		if (LYIsNullDevice(buffer)) {
d408 5
a412 5
	     * The following is considered a bug by the community.  If the
	     * command only takes one argument on the command line, then the
	     * suggested file name is not used.  It actually is not a bug at
	     * all and does as it should, putting both names on the command
	     * line.
d425 1
a425 1
	CTRACE((tfp, "command: %s\n", the_command));
d436 2
a437 2
	    if (0 == strncmp((buffer + 9), "[]", 2)) {
		HTAddSugFilename(buffer + 11);
d439 1
a439 1
		HTAddSugFilename(buffer + 9);
d451 1
a451 1
  failed:
d456 1
a456 1
  cancelled:
d463 4
a466 16
 * Compare a filename with a given suffix, which we have set to give a rough
 * idea of its content.
 */
static int SuffixIs(char *filename, const char *suffix)
{
    size_t have = strlen(filename);
    size_t need = strlen(suffix);

    return have > need && !strcmp(filename + have - need, suffix);
}

/*
 * LYdownload_options writes out the current download choices to a file so that
 * the user can select downloaders in the same way that they select all other
 * links.  Download links look like: 
 * LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
d468 3
a470 1
int LYdownload_options(char **newfile, char *data_file)
d472 1
a472 1
    static char tempfile[LY_MAXPATH] = "\0";
d476 1
a476 1
    lynx_list_item_type *cur_download;
d480 1
a480 1
     * Get a suggested filename.
d485 5
a489 3
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (-1);

d496 2
a497 1
    LYforce_no_cache = TRUE;	/* don't cache this doc */
d503 1
a503 1
	    gettext("Downloaded link:"),
d508 1
a508 1
	    gettext("Suggested file name:"),
d517 1
a517 1
#if defined(DIRED_SUPPORT)
d519 1
a519 1
	 * Disable save to disk option for local files.
d523 6
a528 27
	{
	    fprintf(fp0,
		    "   <a href=\"%s//Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
		    STR_LYNXDOWNLOAD,
		    data_file,
		    NonNull(lynx_save_space),
		    sug_filename,
		    gettext("Save to disk"));
	    /*
	     * If it is not a binary file, offer the opportunity to view the
	     * downloaded temporary file (see HTSaveToFile).
	     */
	    if (SuffixIs(data_file, HTML_SUFFIX)
		|| SuffixIs(data_file, TEXT_SUFFIX)) {
		char *target = NULL;
		char *source = LYAddPathToSave(data_file);

		LYLocalFileToURL(&target, source);
		fprintf(fp0,
			"   <a href=\"%s\">%s</a>\n",
			target,
			gettext("View temporary file"));

		FREE(source);
		FREE(target);
	    }
	}
d538 1
a538 1
	     cur_download = cur_download->next, count++) {
d540 5
a544 7
		fprintf(fp0,
			"   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">",
			STR_LYNXDOWNLOAD, count, data_file, sug_filename);
		fprintf(fp0, "%s", (cur_download->name
				    ? cur_download->name
				    : gettext("No Name Given")));
		fprintf(fp0, "</a>\n");
a551 1
    LYRegisterUIPage(*newfile, UIP_DOWNLOAD_OPTIONS);
d554 1
a554 1
     * Free off temp copy.
d558 1
a558 1
    return (0);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d28 1
a28 1
	char *,		line)
d37 2
a38 1
    lynx_list_item_type *download_command = 0;
d64 1
a64 1
     *	Parse out the File, sug_file, and the Method.
d66 2
a67 10
    if ((file = strstr(Line, "/File=")) == NULL)
	goto failed;
    *file = '\0';
    /*
     *	Go past "File=".
     */
    file += 6;

    if ((sug_file = strstr(file + 1, "/SugFile=")) != NULL) {
	*sug_file = '\0';
d71 1
a71 1
	sug_file += 9;
d75 8
d91 1
a91 1
#if defined(DIRED_SUPPORT)
d93 1
a93 9
    if (!strncmp(file, "file://localhost", 16)) {
#ifdef __DJGPP__
	if (!strncmp(file + 16, "/dev/", 5))
	    file += 16;
	else {
	    file += 17;
	    file = HTDOS_name(file);
	}
#else
d95 2
a96 11
#endif /* __DJGPP__ */
    }
    else if (isFILE_URL(file))
	file += LEN_FILE_URL;
    HTUnEscape(file);
#else
#if defined(_WINDOWS)	/* 1997/10/15 (Wed) 16:27:38 */
    if (!strncmp(file, "file://localhost/", 17))
	file += 17;
    else if (!strncmp(file, "file:/", 6))
	file += 6;
a97 1
#endif /* _WINDOWS */
d100 1
a100 1
    if ((method = strstr(Line, "Method=")) == NULL)
d112 1
a112 1
    recall = ((FnameTotal >= 1) ? RECALL_URL : NORECALL);
d154 1
a154 1
		    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d187 1
a187 1
		    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d206 1
a206 1
#ifdef HAVE_POPEN
d236 1
a236 1
	CTRACE((tfp, "LYDownload: filename is %s\n", buffer));
d238 6
a243 1
	if (! LYCanWriteFile(buffer)) {
d255 1
a255 1
	CTRACE((tfp, "command: rename(%s, %s)\n", file, buffer));
d260 1
a260 1
	    CTRACE((tfp, "         FAILED!\n"));
d274 2
d277 1
d335 1
a335 1
			    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d368 1
a368 1
			    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d393 1
a393 1
		 *  or an "nl:" path on VMS. - FM
d395 7
a401 1
		if (LYIsNullDevice(buffer)) {
d425 1
a425 1
	CTRACE((tfp, "command: %s\n", the_command));
a462 13
 * Compare a filename with a given suffix, which we have set to give a rough
 * idea of its content.
 */
PRIVATE int SuffixIs ARGS2(
	char *,		filename,
	char *,		suffix)
{
    size_t have = strlen(filename);
    size_t need = strlen(suffix);
    return have > need && !strcmp(filename + have - need, suffix);
}

/*
d470 1
a470 1
	char *,		data_file)
d472 1
a472 1
    static char tempfile[LY_MAXPATH] = "\0";
d476 1
a476 1
    lynx_list_item_type *cur_download;
d485 3
a487 1
    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
d489 1
a489 1
 
d503 1
a503 1
	    gettext("Downloaded link:"),
d508 1
a508 1
	    gettext("Suggested file name:"),
d517 1
a517 1
#if defined(DIRED_SUPPORT)
d523 6
a528 21
	{
	    fprintf(fp0,
		    "   <a href=\"%s//Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
		    STR_LYNXDOWNLOAD,
		    data_file,
		    NonNull(lynx_save_space),
		    sug_filename,
		    gettext("Save to disk"));
	    /*
	     * If it is not a binary file, offer the opportunity to view the
	     * downloaded temporary file (see HTSaveToFile).
	     */
	    if (SuffixIs(data_file, HTML_SUFFIX)
	     || SuffixIs(data_file, TEXT_SUFFIX)) {
		fprintf(fp0,
			"   <a href=\"file://localhost%s%s\">%s</a>\n",
			NonNull(lynx_save_space),
			data_file,
			gettext("View temporary file"));
	    }
	}
d540 2
a541 2
		fprintf(fp0, "   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">",
			STR_LYNXDOWNLOAD, count,data_file, sug_filename);
a551 1
    LYRegisterUIPage(*newfile, UIP_DOWNLOAD_OPTIONS);
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d503 1
a503 1

a550 7
		char *target = NULL;
		char *source = NULL;

		StrAllocCopy(source, NonNull(lynx_save_space));
		StrAllocCat(source, data_file);

		LYLocalFileToURL(&target, source);
d552 3
a554 2
			"   <a href=\"%s\">%s</a>\n",
			target,
a555 3

		FREE(source);
		FREE(target);
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d552 4
a555 1
		char *source = LYAddPathToSave(data_file);
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d22 1
a22 1
BOOLEAN LYDidRename = FALSE;
d25 1
a25 1
static char LYValidDownloadFile[LY_MAXPATH] = "\0";
d27 2
a28 2
void LYDownload (
	char *		line)
d469 3
a471 3
static int SuffixIs (
	char *		filename,
	char *		suffix)
d484 3
a486 3
int LYdownload_options (
	char **	newfile,
	char *		data_file)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d14 2
a15 2
 * LYDownload takes a URL and downloads it using a user selected download
 * program
d17 1
a17 1
 * It parses an incoming link that looks like
d19 1
a19 1
 * LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
d27 2
a28 1
void LYDownload(char *line)
a42 1

d48 3
a50 2
     * Make sure we have a valid download file comparison string loaded via the
     * download options menu.  - FM
d57 2
a58 1
     * Make a copy of the LYNXDOWNLOAD internal URL for parsing.  - FM
d63 1
a63 1
     * Parse out the File, sug_file, and the Method.
d69 1
a69 1
     * Go past "File=".
d76 1
a76 1
	 * Go past "SugFile=".
d83 2
a84 2
     * Make sure that the file string is the one from the last displayed
     * download options menu.  - FM
d89 1
d103 2
a104 1
    } else if (isFILE_URL(file))
d108 1
a108 1
#if defined(_WINDOWS)		/* 1997/10/15 (Wed) 16:27:38 */
d120 1
a120 1
     * Go past "Method=".
d126 1
a126 1
     * Set up the sug_filenames recall buffer.
d134 1
a134 1
	 * Write to local file.
d137 1
a137 1
      retry:
d139 1
a139 1
	    LYstrncpy(buffer, sug_file, ((sizeof(buffer) / 2) - 1));
d142 1
a142 1
      check_recall:
d144 1
a144 1
			   VISIBLE, (sizeof(buffer) / 2), recall)) < 0 ||
d150 1
a150 1
		     * Use the last Fname in the list.  - FM
d155 1
a155 1
		     * Go back to the previous Fname in the list.  - FM
d161 2
a162 2
		     * Reset the FirstRecall flag, and use sug_file or a blank. 
		     * - FM
d168 4
a171 3
		} else if ((cp = (char *) HTList_objectAt(sug_filenames,
							  FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d183 1
a183 1
		     * Use the first Fname in the list.  - FM
d188 1
a188 1
		     * Advance to the next Fname in the list.  - FM
d194 2
a195 2
		     * Set the FirstRecall flag, and use sug_file or a blank. 
		     * - FM
d201 4
a204 3
		} else if ((cp = (char *) HTList_objectAt(sug_filenames,
							  FnameNum)) != NULL) {
		    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d215 1
a215 1
	     * Save cancelled.
d235 1
a235 1
	 * See if it already exists.
d251 1
a251 1
	 * See if we can write to it.
d255 1
a255 1
	if (!LYCanWriteFile(buffer)) {
d265 1
a265 1
	 * Try rename() first.  - FM
d270 1
a270 1
	     * Failed.  Use spawned COPY_COMMAND.  - FM
d276 3
a278 2
	     * We don't have the temporary file (it was renamed to a permanent
	     * file), so set a flag to pop out of the download menu.  - FM
d291 1
a291 1
	 * Use configured download commands.
d294 1
a294 1
	for (count = 0, download_command = downloaders;
d296 2
a297 1
	     count++, download_command = download_command->next) ;	/* null body */
d300 2
a301 1
	 * Commands have the form "command %s [etc]" where %s is the filename.
d305 2
a306 1
	     * Check for two '%s' and ask for the local filename if there is.
d310 2
a311 2
	      again:if (sug_file)
		    strncpy(buffer, sug_file, (sizeof(buffer) / 2) - 1);
d314 1
a314 1
	      check_again:
d322 1
a322 1
			     * Use the last Fname in the list.  - FM
d327 2
a328 1
			     * Go back to the previous Fname in the list.  - FM
d334 2
a335 2
			     * Reset the FirstRecall flag, and use sug_file or
			     * a blank.  - FM
d341 4
a344 4
			} else if ((cp = (char *) HTList_objectAt(sug_filenames,
								  FnameNum))
				   != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d356 1
a356 1
			     * Use the first Fname in the list.  - FM
d361 1
a361 1
			     * Advance to the next Fname in the list.  - FM
d367 2
a368 2
			     * Set the FirstRecall flag, and use sug_file or a
			     * blank.  - FM
d374 4
a377 4
			} else if ((cp = (char *) HTList_objectAt(sug_filenames,
								  FnameNum))
				   != NULL) {
			    LYstrncpy(buffer, cp, sizeof(buffer) - 1);
d401 2
a402 2
		 * Cancel if the user entered "/dev/null" on Unix, or an "nl:"
		 * path on VMS.  - FM
d411 5
a415 5
	     * The following is considered a bug by the community.  If the
	     * command only takes one argument on the command line, then the
	     * suggested file name is not used.  It actually is not a bug at
	     * all and does as it should, putting both names on the command
	     * line.
d439 2
a440 2
	    if (0 == strncmp((buffer + 9), "[]", 2)) {
		HTAddSugFilename(buffer + 11);
d442 1
a442 1
		HTAddSugFilename(buffer + 9);
d454 1
a454 1
  failed:
d459 1
a459 1
  cancelled:
d469 3
a471 1
static int SuffixIs(char *filename, char *suffix)
a474 1

d479 4
a482 4
 * LYdownload_options writes out the current download choices to a file so that
 * the user can select downloaders in the same way that they select all other
 * links.  Download links look like: 
 * LYNXDOWNLOAD://Method=<#>/File=<STRING>/SugFile=<STRING>
d484 3
a486 1
int LYdownload_options(char **newfile, char *data_file)
d496 1
a496 1
     * Get a suggested filename.
d502 1
a502 1
	return (-1);
d510 2
a511 1
    LYforce_no_cache = TRUE;	/* don't cache this doc */
d533 1
a533 1
	 * Disable save to disk option for local files.
d550 1
a550 1
		|| SuffixIs(data_file, TEXT_SUFFIX)) {
d573 1
a573 1
	     cur_download = cur_download->next, count++) {
d575 5
a579 7
		fprintf(fp0,
			"   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">",
			STR_LYNXDOWNLOAD, count, data_file, sug_filename);
		fprintf(fp0, "%s", (cur_download->name
				    ? cur_download->name
				    : gettext("No Name Given")));
		fprintf(fp0, "</a>\n");
d590 1
a590 1
     * Free off temp copy.
d594 1
a594 1
    return (0);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d28 1
a28 1
	char *,		line)
d37 2
a38 1
    lynx_list_item_type *download_command = 0;
d64 1
a64 1
     *	Parse out the File, sug_file, and the Method.
d66 2
a67 10
    if ((file = strstr(Line, "/File=")) == NULL)
	goto failed;
    *file = '\0';
    /*
     *	Go past "File=".
     */
    file += 6;

    if ((sug_file = strstr(file + 1, "/SugFile=")) != NULL) {
	*sug_file = '\0';
d71 1
a71 1
	sug_file += 9;
d75 8
d91 1
a91 1
#if defined(DIRED_SUPPORT)
d93 1
a93 5
    if (!strncmp(file, "file://localhost", 16)) {
#ifdef __DJGPP__
	file += 17;
	file = HTDOS_name(file);
#else
a94 2
#endif /* __DJGPP__ */
    }
a97 8
#else
#if defined(_WINDOWS)	/* 1997/10/15 (Wed) 16:27:38 */
    if (!strncmp(file, "file://localhost/", 17))
	file += 17;
    else if (!strncmp(file, "file:/", 6))
	file += 6;
    HTUnEscape(file);
#endif /* _WINDOWS */
d100 1
a100 1
    if ((method = strstr(Line, "Method=")) == NULL)
d112 1
a112 1
    recall = ((FnameTotal >= 1) ? RECALL_URL : NORECALL);
d154 1
a154 1
		    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d187 1
a187 1
		    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d236 1
a236 1
	CTRACE((tfp, "LYDownload: filename is %s\n", buffer));
d238 6
a243 1
	if (! LYCanWriteFile(buffer)) {
d255 1
a255 1
	CTRACE((tfp, "command: rename(%s, %s)\n", file, buffer));
d260 1
a260 1
	    CTRACE((tfp, "         FAILED!\n"));
d335 1
a335 1
			    LYstrncpy(buffer, cp, sizeof(buffer)-1);
d368 1
a368 1
			    LYstrncpy(buffer, cp, sizeof(buffer)-1);
a398 3
#if defined(DOSPATH)	/* 1997/10/15 (Wed) 16:41:30 */
		if (!strcmp(buffer, "nul"))
#else
a399 1
#endif /* DOSPATH */
d425 1
a425 1
	CTRACE((tfp, "command: %s\n", the_command));
d470 1
a470 1
	char *,		data_file)
d472 1
a472 1
    static char tempfile[LY_MAXPATH] = "\0";
d476 1
a476 1
    lynx_list_item_type *cur_download;
d485 2
a486 7
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, BIN_W);
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, BIN_W);
    }
    if (fp0 == NULL) {
d503 1
a503 1
	    gettext("Downloaded link:"),
d508 1
a508 1
	    gettext("Suggested file name:"),
d517 1
a517 1
#if defined(DIRED_SUPPORT)
a551 1
    LYRegisterUIPage(*newfile, UIP_DOWNLOAD_OPTIONS);
@

