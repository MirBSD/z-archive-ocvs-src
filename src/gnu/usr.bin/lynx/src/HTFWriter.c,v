head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.7
	tg-mergefixes-1-branch:1.1.3.7.0.4
	tg-mergefixes-1-base:1.1.3.7
	MIROS_X:1.1.3.7.0.2
	MIROS_X_BASE:1.1.3.7
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.53;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.03;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.27;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.25;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.16;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.17;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.14;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.38;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.09.48;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.50;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.51.27;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.24;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/*		FILE WRITER				HTFWrite.h
 *		===========
 *
 *	This version of the stream object just writes to a C file.
 *	The file is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */

#include <HTUtils.h>
#include <LYCurses.h>
#include <HTFWriter.h>
#include <HTSaveToFile.h>

#ifdef WIN_EX
#include <HTParse.h>
#endif

#include <HTFormat.h>
#include <UCDefs.h>
#include <HTAlert.h>
#include <HTFile.h>
#include <HTInit.h>
#include <HTPlain.h>

#include <LYStrings.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYClean.h>
#include <GridText.h>
#include <LYExtern.h>
#include <LYexit.h>
#include <LYLeaks.h>
#include <LYKeymap.h>
#include <LYGetFile.h>

#ifdef USE_PERSISTENT_COOKIES
#include <LYCookie.h>
#endif

/* contains the name of the temp file which is being downloaded into */
char *WWW_Download_File = NULL;
BOOLEAN LYCancelDownload = FALSE;	/* exported to HTFormat.c in libWWW */

#ifdef VMS
static char *FIXED_RECORD_COMMAND = NULL;

#ifdef USE_COMMAND_FILE		/* Keep this as an option. - FM    */
#define FIXED_RECORD_COMMAND_MASK "@@Lynx_Dir:FIXED512 %s"
#else
#define FIXED_RECORD_COMMAND_MASK "%s"
unsigned long LYVMS_FixedLengthRecords(char *filename);
#endif /* USE_COMMAND_FILE */
#endif /* VMS */

HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink);

/*	Stream Object
 *	-------------
 */
struct _HTStream {
    const HTStreamClass *isa;

    FILE *fp;			/* The file we've opened */
    char *end_command;		/* What to do on _free.  */
    char *remove_command;	/* What to do on _abort. */
    char *viewer_command;	/* Saved external viewer */
    HTFormat input_format;	/* Original pres->rep     */
    HTFormat output_format;	/* Original pres->rep_out */
    HTParentAnchor *anchor;	/* Original stream's anchor. */
    HTStream *sink;		/* Original stream's sink.   */
#ifdef FNAMES_8_3
    BOOLEAN idash;		/* remember position to become '.' */
#endif
};

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 *  Bug:
 *	All errors are ignored.
 */

/*	Character handling
 *	------------------
 */
static void HTFWriter_put_character(HTStream *me, char c)
{
    if (me->fp) {
	putc(c, me->fp);
    }
}

/*	String handling
 *	---------------
 */
static void HTFWriter_put_string(HTStream *me, const char *s)
{
    if (me->fp) {
	fputs(s, me->fp);
    }
}

/*	Buffer write.  Buffers can (and should!) be big.
 *	------------
 */
static void HTFWriter_write(HTStream *me, const char *s, int l)
{
    if (me->fp) {
	fwrite(s, 1, l, me->fp);
    }
}

/*	Free an HTML object
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created
 *	object is not,
 *	as it takes on an existence of its own unless explicitly freed.
 */
static void HTFWriter_free(HTStream *me)
{
    int len;
    char *path = NULL;
    char *addr = NULL;
    int status;
    BOOL use_zread = NO;
    BOOLEAN found = FALSE;

#ifdef WIN_EX
    HANDLE cur_handle;

    cur_handle = GetForegroundWindow();
#endif

    if (me->fp)
	fflush(me->fp);
    if (me->end_command) {	/* Temp file */
	LYCloseTempFP(me->fp);
#ifdef VMS
	if (0 == strcmp(me->end_command, "SaveVMSBinaryFile")) {
	    /*
	     * It's a binary file saved to disk on VMS, which
	     * we want to convert to fixed records format.  - FM
	     */
#ifdef USE_COMMAND_FILE
	    LYSystem(FIXED_RECORD_COMMAND);
#else
	    LYVMS_FixedLengthRecords(FIXED_RECORD_COMMAND);
#endif /* USE_COMMAND_FILE */
	    FREE(FIXED_RECORD_COMMAND);

	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort! */
		FREE(me->remove_command);
	    }
	} else
#endif /* VMS */
	if (me->input_format == HTAtom_for("www/compressed")) {
	    /*
	     * It's a compressed file supposedly cached to
	     * a temporary file for uncompression.  - FM
	     */
	    if (me->anchor->FileCache != NULL) {
		BOOL skip_loadfile = (BOOL) (me->viewer_command != NULL);

		/*
		 * Save the path with the "gz" or "Z" suffix trimmed,
		 * and remove any previous uncompressed copy.  - FM
		 */
		StrAllocCopy(path, me->anchor->FileCache);
		if ((len = strlen(path)) > 3 &&
		    (!strcasecomp(&path[len - 2], "gz") ||
		     !strcasecomp(&path[len - 2], "zz"))) {
#ifdef USE_ZLIB
		    if (!skip_loadfile) {
			use_zread = YES;
		    } else
#endif /* USE_ZLIB */
		    {
			path[len - 3] = '\0';
			remove(path);
		    }
		} else if (len > 4 && !strcasecomp(&path[len - 3], "bz2")) {
#ifdef USE_BZLIB
		    if (!skip_loadfile) {
			use_zread = YES;
		    } else
#endif /* USE_BZLIB */
		    {
			path[len - 4] = '\0';
			remove(path);
		    }
		} else if (len > 2 && !strcasecomp(&path[len - 1], "Z")) {
		    path[len - 2] = '\0';
		    remove(path);
		}
		if (!use_zread) {
		    if (!dump_output_immediately) {
			/*
			 * Tell user what's happening.  - FM
			 */
			_HTProgress(me->end_command);
		    }
		    /*
		     * Uncompress it.  - FM
		     */
		    if (me->end_command && me->end_command[0])
			LYSystem(me->end_command);
		    found = LYCanReadFile(me->anchor->FileCache);
		}
		if (found) {
		    /*
		     * It's still there with the "gz" or "Z" suffix,
		     * so the uncompression failed.  - FM
		     */
		    if (!dump_output_immediately) {
			lynx_force_repaint();
			LYrefresh();
		    }
		    HTAlert(ERROR_UNCOMPRESSING_TEMP);
		    LYRemoveTemp(me->anchor->FileCache);
		    FREE(me->anchor->FileCache);
		} else {
		    /*
		     * Succeeded!  Create a complete address
		     * for the uncompressed file and invoke
		     * HTLoadFile() to handle it.  - FM
		     */
#ifdef FNAMES_8_3
		    /*
		     * Assuming we have just uncompressed e.g.
		     * FILE-mpeg.gz -> FILE-mpeg, restore/shorten
		     * the name to be fit for passing to an external
		     * viewer, by renaming FILE-mpeg -> FILE.mpe - kw
		     */
		    if (skip_loadfile) {
			char *new_path = NULL;
			char *the_dash = me->idash ? strrchr(path, '-') : 0;

			if (the_dash != 0) {
			    unsigned off = (the_dash - path);

			    StrAllocCopy(new_path, path);
			    new_path[off] = '.';
			    if (strlen(new_path + off) > 4)
				new_path[off + 4] = '\0';
			    if (rename(path, new_path) == 0) {
				FREE(path);
				path = new_path;
			    } else {
				FREE(new_path);
			    }
			}
		    }
#endif /* FNAMES_8_3 */
		    LYLocalFileToURL(&addr, path);
		    if (!use_zread) {
			LYRenamedTemp(me->anchor->FileCache, path);
			StrAllocCopy(me->anchor->FileCache, path);
			StrAllocCopy(me->anchor->content_encoding, "binary");
		    }
		    FREE(path);
		    if (!skip_loadfile) {
			/*
			 * Lock the chartrans info we may possibly have,
			 * so HTCharsetFormat() will not apply the default
			 * for local files.  - KW
			 */
			if (HTAnchor_getUCLYhndl(me->anchor,
						 UCT_STAGE_PARSER) < 0) {
			    /*
			     * If not yet set - KW
			     */
			    HTAnchor_copyUCInfoStage(me->anchor,
						     UCT_STAGE_PARSER,
						     UCT_STAGE_MIME,
						     UCT_SETBY_DEFAULT + 1);
			}
			HTAnchor_copyUCInfoStage(me->anchor,
						 UCT_STAGE_PARSER,
						 UCT_STAGE_MIME, -1);
		    }
		    /*
		     * Create a complete address for
		     * the uncompressed file.  - FM
		     */
		    if (!dump_output_immediately) {
			/*
			 * Tell user what's happening.  - FM
			 */
			HTUserMsg2(WWW_USING_MESSAGE, addr);
		    }

		    if (skip_loadfile) {
			/*
			 * It's a temporary file we're passing to a viewer or
			 * helper application.  Loading the temp file through
			 * HTLoadFile() would result in yet another HTStream
			 * (created with HTSaveAndExecute()) which would just
			 * copy the temp file to another temp file (or even the
			 * same!).  We can skip this needless duplication by
			 * using the viewer_command which has already been
			 * determined when the HTCompressed stream was created. 
			 * - kw
			 */
			FREE(me->end_command);

			HTAddParam(&(me->end_command), me->viewer_command, 1, me->anchor->FileCache);
			HTEndParam(&(me->end_command), me->viewer_command, 1);

			if (!dump_output_immediately) {
			    /*
			     * Tell user what's happening.  - FM
			     */
			    HTProgress(me->end_command);
#ifndef WIN_EX
			    stop_curses();
#endif
			}
#ifdef _WIN_CC
			exec_command(me->end_command, FALSE);
#else
			LYSystem(me->end_command);
#endif
			if (me->remove_command) {
			    /* NEVER REMOVE THE FILE unless during an abort!!! */
			    FREE(me->remove_command);
			}
			if (!dump_output_immediately) {
#ifdef WIN_EX
			    if (focus_window) {
				HTInfoMsg(gettext("Set focus1"));
				status = SetForegroundWindow(cur_handle);
			    }
#else
			    start_curses();
#endif
			}
		    } else
			status = HTLoadFile(addr,
					    me->anchor,
					    me->output_format,
					    me->sink);
		    if (dump_output_immediately &&
			me->output_format == HTAtom_for("www/present")) {
			FREE(addr);
			remove(me->anchor->FileCache);
			FREE(me->anchor->FileCache);
			FREE(me->remove_command);
			FREE(me->end_command);
			FREE(me->viewer_command);
			FREE(me);
			return;
		    }
		}
		FREE(addr);
	    }
	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort!!! */
		FREE(me->remove_command);
	    }
	} else if (strcmp(me->end_command, "SaveToFile")) {
	    /*
	     * It's a temporary file we're passing to a viewer or helper
	     * application.  - FM
	     */
	    if (!dump_output_immediately) {
		/*
		 * Tell user what's happening.  - FM
		 */
		_HTProgress(me->end_command);
#ifndef WIN_EX
		stop_curses();
#endif
	    }
#ifdef _WIN_CC
	    exec_command(me->end_command, FALSE);
#else
	    LYSystem(me->end_command);
#endif

	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort!!! */
		FREE(me->remove_command);
	    }
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus2"));
		    status = SetForegroundWindow(cur_handle);
		}
#else
		start_curses();
#endif
	    }
	} else {
	    /*
	     * It's a file we saved to disk for handling via a menu.  - FM
	     */
	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort!!! */
		FREE(me->remove_command);
	    }
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus3"));
		    status = SetForegroundWindow(cur_handle);
		}
#else
		start_curses();
#endif
	    }
	}
	FREE(me->end_command);
    }
    FREE(me->viewer_command);

    if (dump_output_immediately) {
	if (me->anchor->FileCache)
	    remove(me->anchor->FileCache);
	FREE(me);
#ifdef USE_PERSISTENT_COOKIES
	/*
	 * We want to save cookies picked up when in source mode.  ...
	 */
	if (persistent_cookies)
	    LYStoreCookies(LYCookieSaveFile);
#endif /* USE_PERSISTENT_COOKIES */
	exit_immediately(EXIT_SUCCESS);
    }

    FREE(me);
    return;
}

#ifdef VMS
#  define REMOVE_COMMAND "delete/noconfirm/nolog %s;"
#else
#  define REMOVE_COMMAND "%s"
#endif /* VMS */

/*	Abort writing
 *	-------------
 */
static void HTFWriter_abort(HTStream *me, HTError e GCC_UNUSED)
{
    CTRACE((tfp, "HTFWriter_abort called\n"));
    LYCloseTempFP(me->fp);
    FREE(me->viewer_command);
    if (me->end_command) {	/* Temp file */
	CTRACE((tfp, "HTFWriter: Aborting: file not executed or saved.\n"));
	FREE(me->end_command);
	if (me->remove_command) {
#ifdef VMS
	    LYSystem(me->remove_command);
#else
	    chmod(me->remove_command, 0600);	/* Ignore errors */
	    if (0 != unlink(me->remove_command)) {
		char buf[560];

		sprintf(buf, "%.60s '%.400s': %.60s",
			gettext("Error deleting file"),
			me->remove_command, LYStrerror(errno));
		HTAlert(buf);
	    }
#endif
	    FREE(me->remove_command);
	}
    }

    FREE(WWW_Download_File);

    FREE(me);
}

/*	Structured Object Class
 *	-----------------------
 */
static const HTStreamClass HTFWriter =	/* As opposed to print etc */
{
    "FileWriter",
    HTFWriter_free,
    HTFWriter_abort,
    HTFWriter_put_character, HTFWriter_put_string,
    HTFWriter_write
};

/*	Subclass-specific Methods
 *	-------------------------
 */
HTStream *HTFWriter_new(FILE *fp)
{
    HTStream *me;

    if (!fp)
	return NULL;

    me = typecalloc(HTStream);
    if (me == NULL)
	outofmem(__FILE__, "HTFWriter_new");
    me->isa = &HTFWriter;

    me->fp = fp;
    me->end_command = NULL;
    me->remove_command = NULL;
    me->anchor = NULL;
    me->sink = NULL;

    return me;
}

/*	Make system command from template
 *	---------------------------------
 *
 *	See mailcap spec for description of template.
 */
static char *mailcap_substitute(HTParentAnchor *anchor,
				HTPresentation *pres,
				char *fnam)
{
    char *result = LYMakeMailcapCommand(pres->command,
					anchor->content_type_params,
					fnam);

#if defined(UNIX)
    /* if we don't have a "%s" token, expect to provide the file via stdin */
    if (!LYMailcapUsesPctS(pres->command)) {
	char *prepend = 0;
	const char *format = "( %s ) < %s";

	HTSprintf(&prepend, "( %s", result);	/* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam);	/* ...to quote if needed */
	FREE(result);
	result = prepend;
    }
#endif
    return result;
}

/*	Take action using a system command
 *	----------------------------------
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Creates temporary file, writes to it, executes system command
 *	on end-document.  The suffix of the temp file can be given
 *	in case the application is fussy, or so that a generic opener can
 *	be used.
 */
HTStream *HTSaveAndExecute(HTPresentation *pres,
			   HTParentAnchor *anchor,
			   HTStream *sink)
{
    char fnam[LY_MAXPATH];
    const char *suffix;
    HTStream *me;

    if (traversal) {
	LYCancelledFetch = TRUE;
	return (NULL);
    }
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    if (pres->quality == 999.0) {	/* exec link */
	if (dump_output_immediately) {
	    LYCancelledFetch = TRUE;
	    return (NULL);
	}
	if (no_exec) {
	    HTAlert(EXECUTION_DISABLED);
	    return HTPlainPresent(pres, anchor, sink);
	}
	if (!local_exec) {
	    if (local_exec_on_local_files &&
		(LYJumpFileURL ||
		 !strncmp(anchor->address, "file://localhost", 16))) {
		/* allow it to continue */
		;
	    } else {
		char *buf = 0;

		HTSprintf0(&buf, EXECUTION_DISABLED_FOR_FILE,
			   key_for_func(LYK_OPTIONS));
		HTAlert(buf);
		FREE(buf);
		return HTPlainPresent(pres, anchor, sink);
	    }
	}
    }
#endif /* EXEC_LINKS || EXEC_SCRIPTS */

    if (dump_output_immediately) {
	return (HTSaveToFile(pres, anchor, sink));
    }

    me = typecalloc(HTStream);
    if (me == NULL)
	outofmem(__FILE__, "HTSaveAndExecute");
    me->isa = &HTFWriter;
    me->input_format = pres->rep;
    me->output_format = pres->rep_out;
    me->anchor = anchor;
    me->sink = sink;

    if (LYCachedTemp(fnam, &(anchor->FileCache))) {
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
	 */
	me->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
    } else {
#if defined(WIN_EX) && !defined(__CYGWIN__)	/* 1998/01/04 (Sun) */
	if (!strncmp(anchor->address, "file://localhost", 16)) {

	    /* 1998/01/23 (Fri) 17:38:26 */
	    unsigned char *cp, *view_fname;

#define IS_SJIS_HI1(hi) ((0x81<=hi)&&(hi<=0x9F))	/* 1st lev. */
#define IS_SJIS_HI2(hi) ((0xE0<=hi)&&(hi<=0xEF))	/* 2nd lev. */

	    me->fp = NULL;

	    view_fname = fnam + 3;
	    LYstrncpy(view_fname, anchor->address + 17, sizeof(fnam) - 5);
	    HTUnEscape(view_fname);

	    if (strchr(view_fname, ':') == NULL) {
		fnam[0] = windows_drive[0];
		fnam[1] = windows_drive[1];
		fnam[2] = '/';
		view_fname = fnam;
	    }

	    /* 1998/04/21 (Tue) 11:04:16 */
	    cp = view_fname;
	    while (*cp) {
		if (IS_SJIS_HI1(*cp) || IS_SJIS_HI2(*cp)) {
		    cp += 2;
		    continue;
		} else if (*cp == '/') {
		    *cp = '\\';
		}
		cp++;
	    }
	    if (strchr(view_fname, ' '))
		view_fname = (unsigned char *) quote_pathname(view_fname);

	    StrAllocCopy(me->viewer_command, pres->command);

	    me->end_command = mailcap_substitute(anchor, pres, view_fname);
	    me->remove_command = NULL;

	    return me;
	}
#endif
	/*
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
	 */
	if (!strcasecomp(pres->rep->name, "text/html")) {
	    suffix = HTML_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if ((suffix = HTFileSuffix(pres->rep,
					  anchor->content_encoding)) == 0
		   || *suffix != '.') {
	    if (!strncasecomp(pres->rep->name, "application/", 12)) {
		suffix = BIN_SUFFIX;
	    } else {
		suffix = HTML_SUFFIX;
	    }
	}
	me->fp = LYOpenTemp(fnam, suffix, BIN_W);
    }

    if (!me->fp) {
	HTAlert(CANNOT_OPEN_TEMP);
	FREE(me);
	return NULL;
    }

    StrAllocCopy(me->viewer_command, pres->command);
    /*
     * Make command to process file.
     */
    me->end_command = mailcap_substitute(anchor, pres, fnam);

    /*
     * Make command to delete file.
     */
    me->remove_command = 0;
    HTAddParam(&(me->remove_command), REMOVE_COMMAND, 1, fnam);
    HTEndParam(&(me->remove_command), REMOVE_COMMAND, 1);

    StrAllocCopy(anchor->FileCache, fnam);
    return me;
}

/*	Format Converter using system command
 *	-------------------------------------
 */

/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */

/*	Save to a local file   LJM!!!
 *	--------------------
 *
 *	usually a binary file that can't be displayed
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Asks the user if he wants to continue, creates a temporary
 *	file, and writes to it.  In HTSaveToFile_Free
 *	the user will see a list of choices for download
 */
HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
{
    HTStream *ret_obj;
    char fnam[LY_MAXPATH];
    const char *suffix;
    char *cp;
    int c = 0;
    BOOL IsBinary = TRUE;

    ret_obj = typecalloc(HTStream);

    if (ret_obj == NULL)
	outofmem(__FILE__, "HTSaveToFile");
    ret_obj->isa = &HTFWriter;
    ret_obj->remove_command = NULL;
    ret_obj->end_command = NULL;
    ret_obj->input_format = pres->rep;
    ret_obj->output_format = pres->rep_out;
    ret_obj->anchor = anchor;
    ret_obj->sink = sink;

    if (dump_output_immediately) {
	ret_obj->fp = stdout;	/* stdout */
	if (HTOutputFormat == HTAtom_for("www/download"))
	    goto Prepend_BASE;
	return ret_obj;
    }

    LYCancelDownload = FALSE;
    if (HTOutputFormat != HTAtom_for("www/download")) {
	if (traversal ||
	    (no_download && !override_no_download && no_disk_save)) {
	    if (!traversal) {
		HTAlert(CANNOT_DISPLAY_FILE);
	    }
	    LYCancelDownload = TRUE;
	    if (traversal)
		LYCancelledFetch = TRUE;
	    FREE(ret_obj);
	    return (NULL);
	}

	if (((cp = strchr(pres->rep->name, ';')) != NULL) &&
	    strstr((cp + 1), "charset") != NULL) {
	    _user_message(MSG_DOWNLOAD_OR_CANCEL, pres->rep->name);
	} else if (*(pres->rep->name) != '\0') {
	    _user_message(MSG_DOWNLOAD_OR_CANCEL, pres->rep->name);
	} else {
	    _statusline(CANNOT_DISPLAY_FILE_D_OR_C);
	}

	while (c != 'D' && c != 'C' && !LYCharIsINTERRUPT(c)) {
	    c = LYgetch_single();
#ifdef VMS
	    /*
	     * 'C'ancel on Control-C or Control-Y and
	     * a 'N'o to the "really exit" query.  - FM
	     */
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = 'C';
	    }
#endif /* VMS */
	}

	/*
	 * Cancel on 'C', 'c' or Control-G or Control-C.
	 */
	if (c == 'C' || LYCharIsINTERRUPT(c)) {
	    _statusline(CANCELLING_FILE);
	    LYCancelDownload = TRUE;
	    FREE(ret_obj);
	    return (NULL);
	}
    }

    /*
     * Set up a 'D'ownload.
     */
    if (LYCachedTemp(fnam, &(anchor->FileCache))) {
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
	 */
	ret_obj->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
    } else {
	/*
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
	 */
	if (!strcasecomp(pres->rep->name, "text/html")) {
	    suffix = HTML_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "application/", 12)) {
	    suffix = BIN_SUFFIX;
	} else if ((suffix = HTFileSuffix(pres->rep,
					  anchor->content_encoding)) == 0
		   || *suffix != '.') {
	    suffix = HTML_SUFFIX;
	}
	ret_obj->fp = LYOpenTemp(fnam, suffix, BIN_W);
    }

    if (!ret_obj->fp) {
	HTAlert(CANNOT_OPEN_OUTPUT);
	FREE(ret_obj);
	return NULL;
    }

    if (0 == strncasecomp(pres->rep->name, "text/", 5) ||
	0 == strcasecomp(pres->rep->name, "application/postscript") ||
	0 == strcasecomp(pres->rep->name, "application/x-RUNOFF-MANUAL"))
	/*
	 * It's a text file requested via 'd'ownload.  Keep adding others to
	 * the above list, 'til we add a configurable procedure.  - FM
	 */
	IsBinary = FALSE;

    /*
     * Any "application/foo" or other non-"text/foo" types that are actually
     * text but not checked, above, will be treated as binary, so show the type
     * to help sort that out later.  Unix folks don't need to know this, but
     * we'll show it to them, too.  - FM
     */
    HTUserMsg2(CONTENT_TYPE_MSG, pres->rep->name);

    StrAllocCopy(WWW_Download_File, fnam);

    /*
     * Make command to delete file.
     */
    ret_obj->remove_command = 0;
    HTAddParam(&(ret_obj->remove_command), REMOVE_COMMAND, 1, fnam);
    HTEndParam(&(ret_obj->remove_command), REMOVE_COMMAND, 1);

#ifdef VMS
    if (IsBinary && UseFixedRecords) {
	StrAllocCopy(ret_obj->end_command, "SaveVMSBinaryFile");
	FIXED_RECORD_COMMAND = 0;
	HTAddParam(&FIXED_RECORD_COMMAND, FIXED_RECORD_COMMAND_MASK, 1, fnam);
	HTEndParam(&FIXED_RECORD_COMMAND, FIXED_RECORD_COMMAND_MASK, 1);

    } else {
#endif /* VMS */
	StrAllocCopy(ret_obj->end_command, "SaveToFile");
#ifdef VMS
    }
#endif /* VMS */

    _statusline(RETRIEVING_FILE);

    StrAllocCopy(anchor->FileCache, fnam);
  Prepend_BASE:
    if (LYPrependBaseToSource &&
	!strncasecomp(pres->rep->name, "text/html", 9) &&
	!anchor->content_encoding) {
	/*
	 * Add the document's base as a BASE tag at the top of the file, so
	 * that any partial or relative URLs within it will be resolved
	 * relative to that if no BASE tag is present and replaces it.  Note
	 * that the markup will be technically invalid if a DOCTYPE
	 * declaration, or HTML or HEAD tags, are present, and thus the file
	 * may need editing for perfection.  - FM
	 *
	 * Add timestamp (last reload).
	 */
	char *temp = NULL;

	if (non_empty(anchor->content_base)) {
	    StrAllocCopy(temp, anchor->content_base);
	} else if (non_empty(anchor->content_location)) {
	    StrAllocCopy(temp, anchor->content_location);
	}
	if (temp) {
	    LYRemoveBlanks(temp);
	    if (!is_url(temp)) {
		FREE(temp);
	    }
	}

	fprintf(ret_obj->fp,
		"<!-- X-URL: %s -->\n", anchor->address);
	if (non_empty(anchor->date)) {
	    fprintf(ret_obj->fp,
		    "<!-- Date: %s -->\n", anchor->date);
	    if (non_empty(anchor->last_modified)
		&& strcmp(anchor->last_modified, anchor->date)
		&& strcmp(anchor->last_modified,
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(ret_obj->fp,
			"<!-- Last-Modified: %s -->\n", anchor->last_modified);
	    }
	}
	fprintf(ret_obj->fp,
		"<BASE HREF=\"%s\">\n\n", (temp ? temp : anchor->address));
	FREE(temp);
    }
    if (LYPrependCharsetToSource &&
	!strncasecomp(pres->rep->name, "text/html", 9) &&
	!anchor->content_encoding) {
	/*
	 * Add the document's charset as a META CHARSET tag at the top of the
	 * file, so HTTP charset header will not be forgotten when a document
	 * saved as local file.  We add this line only(!) if HTTP charset
	 * present.  - LP Note that the markup will be technically invalid if a
	 * DOCTYPE declaration, or HTML or HEAD tags, are present, and thus the
	 * file may need editing for perfection.  - FM
	 */
	char *temp = NULL;

	if (non_empty(anchor->charset)) {
	    StrAllocCopy(temp, anchor->charset);
	    LYRemoveBlanks(temp);
	    fprintf(ret_obj->fp,
		    "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		    temp);
	}
	FREE(temp);
    }
    return ret_obj;
}

/*	Set up stream for uncompressing - FM
 *	-------------------------------
 */
HTStream *HTCompressed(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
{
    HTStream *me;
    HTFormat format;
    char *type = NULL;
    HTPresentation *Pres = NULL;
    HTPresentation *Pnow = NULL;
    int n, i;
    BOOL can_present = FALSE;
    char fnam[LY_MAXPATH];
    char temp[LY_MAXPATH];	/* actually stores just a suffix */
    const char *suffix;
    char *uncompress_mask = NULL;
    const char *compress_suffix = "";
    const char *middle;

    /*
     * Deal with any inappropriate invocations of this function, or a download
     * request, in which case we won't bother to uncompress the file.  - FM
     */
    if (!(anchor && anchor->content_encoding && anchor->content_type)) {
	/*
	 * We have no idea what we're dealing with, so treat it as a binary
	 * stream.  - FM
	 */
	format = HTAtom_for("application/octet-stream");
	me = HTStreamStack(format, pres->rep_out, sink, anchor);
	return me;
    }
    n = HTList_count(HTPresentations);
    for (i = 0; i < n; i++) {
	Pnow = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (!strcasecomp(Pnow->rep->name, anchor->content_type) &&
	    Pnow->rep_out == WWW_PRESENT) {
	    const char *program = "";

	    /*
	     * Pick the best presentation.  User-defined mappings are at the
	     * end of the list, and unless the quality is lower, we prefer
	     * those.
	     */
	    if (Pres == 0)
		Pres = Pnow;
	    else if (Pres->quality > Pnow->quality)
		continue;
	    else
		Pres = Pnow;
	    /*
	     * We have a presentation mapping for it.  - FM
	     */
	    can_present = TRUE;
	    switch (HTEncodingToCompressType(anchor->content_encoding)) {
	    case cftGzip:
		if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		    /*
		     * It's compressed with the modern gzip.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d --no-name %s");
		    compress_suffix = "gz";
		}
		break;
	    case cftDeflate:
		if ((program = HTGetProgramPath(ppINFLATE)) != NULL) {
		    /*
		     * It's compressed with a zlib wrapper.
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "zz";
		}
		break;
	    case cftBzip2:
		if ((program = HTGetProgramPath(ppBZIP2)) != NULL) {
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d %s");
		    compress_suffix = "bz2";
		}
		break;
	    case cftCompress:
		if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
		    /*
		     * It's compressed the old fashioned Unix way.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "Z";
		}
		break;
	    case cftNone:
		break;
	    }
	}
    }
    if (can_present == FALSE ||	/* no presentation mapping */
	uncompress_mask == NULL ||	/* not gzip or compress */
	strchr(anchor->content_type, ';') ||	/* wrong charset */
	HTOutputFormat == HTAtom_for("www/download") ||		/* download */
	!strcasecomp(pres->rep_out->name, "www/download") ||	/* download */
	(traversal &&		/* only handle html or plain text for traversals */
	 strcasecomp(anchor->content_type, "text/html") &&
	 strcasecomp(anchor->content_type, "text/plain"))) {
	/*
	 * Cast the Content-Encoding to a Content-Type and pass it back to be
	 * handled as that type.  - FM
	 */
	if (strchr(anchor->content_encoding, '/') == NULL) {
	    /*
	     * Use "x-" prefix, none of the types we are likely to construct
	     * here are official.  That is we generate "application/x-gzip" and
	     * so on.  - kw
	     */
	    if (!strncasecomp(anchor->content_encoding, "x-", 2))
		StrAllocCopy(type, "application/");
	    else
		StrAllocCopy(type, "application/x-");
	    StrAllocCat(type, anchor->content_encoding);
	} else {
	    StrAllocCopy(type, anchor->content_encoding);
	}
	format = HTAtom_for(type);
	FREE(type);
	FREE(uncompress_mask);
	me = HTStreamStack(format, pres->rep_out, sink, anchor);
	return me;
    }

    /*
     * Set up the stream structure for uncompressing and then handling based on
     * the uncompressed Content-Type.- FM
     */
    me = typecalloc(HTStream);
    if (me == NULL)
	outofmem(__FILE__, "HTCompressed");
    me->isa = &HTFWriter;
    me->input_format = pres->rep;
    me->output_format = pres->rep_out;
    me->anchor = anchor;
    me->sink = sink;
#ifdef FNAMES_8_3
    me->idash = FALSE;
#endif

    /*
     * Remove any old versions of the file.  - FM
     */
    if (anchor->FileCache) {
	LYRemoveTemp(anchor->FileCache);
	FREE(anchor->FileCache);
    }

    /*
     * Get a new temporary filename and substitute a suitable suffix.  - FM
     */
    middle = NULL;
    if (!strcasecomp(anchor->content_type, "text/html")) {
	middle = HTML_SUFFIX;
	middle++;		/* point to 'h' of .htm(l) - kw */
    } else if (!strncasecomp(anchor->content_type, "text/", 5)) {
	middle = TEXT_SUFFIX + 1;
    } else if (!strncasecomp(anchor->content_type, "application/", 12)) {
	/* FIXME: why is this BEFORE HTFileSuffix? */
	middle = BIN_SUFFIX + 1;
    } else if ((suffix =
		HTFileSuffix(HTAtom_for(anchor->content_type), NULL)) &&
	       *suffix == '.') {
#if defined(VMS) || defined(FNAMES_8_3)
	if (strchr(suffix + 1, '.') == NULL)
#endif
	    middle = suffix + 1;
    }

    temp[0] = 0;		/* construct the suffix */
    if (middle) {
#ifdef FNAMES_8_3
	me->idash = TRUE;	/* remember position of '-'  - kw */
	strcat(temp, "-");	/* NAME-htm,  NAME-txt, etc. - hack for DOS */
#else
	strcat(temp, ".");	/* NAME.html, NAME-txt etc. */
#endif /* FNAMES_8_3 */
	strcat(temp, middle);
#ifdef VMS
	strcat(temp, "-");	/* NAME.html-gz, NAME.txt-gz, NAME.txt-Z etc. */
#else
	strcat(temp, ".");	/* NAME-htm.gz (DOS), NAME.html.gz (UNIX)etc. */
#endif /* VMS */
    }
    strcat(temp, compress_suffix);

    /*
     * Open the file for receiving the compressed input stream.  - FM
     */
    me->fp = LYOpenTemp(fnam, temp, BIN_W);
    if (!me->fp) {
	HTAlert(CANNOT_OPEN_TEMP);
	FREE(uncompress_mask);
	FREE(me);
	return NULL;
    }

    /*
     * me->viewer_command will be NULL if the converter Pres found above is not
     * for an external viewer but an internal HTStream converter.  We also
     * don't set it under conditions where HTSaveAndExecute would disallow
     * execution of the command.  - KW
     */
    if (!dump_output_immediately && !traversal
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
	&& (Pres->quality != 999.0 ||
	    (!no_exec &&	/* allowed exec link or script ? */
	     (local_exec ||
	      (local_exec_on_local_files &&
	       (LYJumpFileURL ||
		!strncmp(anchor->address, "file://localhost", 16))))))
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
	) {
	StrAllocCopy(me->viewer_command, Pres->command);
    }

    /*
     * Make command to process file.  - FM
     */
#ifdef USE_BZLIB
    if (compress_suffix[0] == 'b'	/* must be bzip2 */
	&& !me->viewer_command) {
	/*
	 * We won't call bzip2 externally, so we don't need to supply a command
	 * for it.
	 */
	StrAllocCopy(me->end_command, "");
    } else
#endif
#ifdef USE_ZLIB
	/* FIXME: allow deflate here, e.g., 'z' */
	if (compress_suffix[0] == 'g'	/* must be gzip */
	    && !me->viewer_command) {
	/*
	 * We won't call gzip or compress externally, so we don't need to
	 * supply a command for it.
	 */
	StrAllocCopy(me->end_command, "");
    } else
#endif /* USE_ZLIB */
    {
	me->end_command = 0;
	HTAddParam(&(me->end_command), uncompress_mask, 1, fnam);
	HTEndParam(&(me->end_command), uncompress_mask, 1);
    }
    FREE(uncompress_mask);

    /*
     * Make command to delete file.  - FM
     */
    me->remove_command = 0;
    HTAddParam(&(me->remove_command), REMOVE_COMMAND, 1, fnam);
    HTEndParam(&(me->remove_command), REMOVE_COMMAND, 1);

    /*
     * Save the filename and return the structure.  - FM
     */
    StrAllocCopy(anchor->FileCache, fnam);
    return me;
}

/*	Dump output to stdout - LJM & FM
 *	---------------------
 *
 */
HTStream *HTDumpToStdout(HTPresentation *pres GCC_UNUSED,
			 HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
{
    HTStream *ret_obj;

    ret_obj = typecalloc(HTStream);

    if (ret_obj == NULL)
	outofmem(__FILE__, "HTDumpToStdout");
    ret_obj->isa = &HTFWriter;
    ret_obj->remove_command = NULL;
    ret_obj->end_command = NULL;
    ret_obj->anchor = anchor;

    ret_obj->fp = stdout;	/* stdout */
    return ret_obj;
}

#if defined(VMS) && !defined(USE_COMMAND_FILE)
#include <fab.h>
#include <rmsdef.h>		/* RMS status codes */
#include <iodef.h>		/* I/O function codes */
#include <fibdef.h>		/* file information block defs */
#include <atrdef.h>		/* attribute request codes */
#ifdef NOTDEFINED /*** Not all versions of VMS compilers have these.	 ***/
#include <fchdef.h>		/* file characteristics */
#include <fatdef.h>		/* file attribute defs */
#else		  /*** So we'll define what we need from them ourselves. ***/
#define FCH$V_CONTIGB	0x005	/* pos of cont best try bit */
#define FCH$M_CONTIGB	(1 << FCH$V_CONTIGB)	/* contig best try bit mask */
/* VMS I/O User's Reference Manual: Part I (V5.x doc set) */
struct fatdef {
    unsigned char fat$b_rtype, fat$b_rattrib;
    unsigned short fat$w_rsize;
    unsigned long fat$l_hiblk, fat$l_efblk;
    unsigned short fat$w_ffbyte;
    unsigned char fat$b_bktsize, fat$b_vfcsize;
    unsigned short fat$w_maxrec, fat$w_defext, fat$w_gbc;
    unsigned:16,:32,:16;	/* 6 bytes reserved, 2 bytes not used */
    unsigned short fat$w_versions;
};
#endif /* NOTDEFINED */

/* arbitrary descriptor without type and class info */
typedef struct dsc {
    unsigned short len, mbz;
    void *adr;
} Desc;

extern unsigned long sys$open(), sys$qiow(), sys$dassgn();

#define syswork(sts)	((sts) & 1)
#define sysfail(sts)	(!syswork(sts))

/*
 * 25-Jul-1995 - Pat Rankin (rankin@@eql.caltech.edu)
 *
 * Force a file to be marked as having fixed-length, 512 byte records
 * without implied carriage control, and with best_try_contiguous set.
 */
unsigned long LYVMS_FixedLengthRecords(char *filename)
{
    struct FAB fab;		/* RMS file access block */
    struct fibdef fib;		/* XQP file information block */
    struct fatdef recattr;	/* XQP file "record" attributes */
    struct atrdef attr_rqst_list[3];	/* XQP attribute request itemlist */

    Desc fib_dsc;
    unsigned short channel, iosb[4];
    unsigned long fchars, sts, tmp;

    /* initialize file access block */
    fab = cc$rms_fab;
    fab.fab$l_fna = filename;
    fab.fab$b_fns = (unsigned char) strlen(filename);
    fab.fab$l_fop = FAB$M_UFO;	/* user file open; no further RMS processing */
    fab.fab$b_fac = FAB$M_PUT;	/* need write access */
    fab.fab$b_shr = FAB$M_NIL;	/* exclusive access */

    sts = sys$open(&fab);	/* channel in stv; $dassgn to close */
    if (sts == RMS$_FLK) {
	/* For MultiNet, at least, if the file was just written by a remote
	   NFS client, the local NFS server might still have it open, and the
	   failed access attempt will provoke it to be closed, so try again. */
	sts = sys$open(&fab);
    }
    if (sysfail(sts))
	return sts;

    /* RMS supplies a user-mode channel (see FAB$L_FOP FAB$V_UFO doc) */
    channel = (unsigned short) fab.fab$l_stv;

    /* set up ACP interface structures */
    /* file information block, passed by descriptor; it's okay to start with
       an empty FIB after RMS has accessed the file for us */
    fib_dsc.len = sizeof fib;
    fib_dsc.mbz = 0;
    fib_dsc.adr = &fib;
    memset((void *) &fib, 0, sizeof fib);
    /* attribute request list */
    attr_rqst_list[0].atr$w_size = sizeof recattr;
    attr_rqst_list[0].atr$w_type = ATR$C_RECATTR;
    *(void **) &attr_rqst_list[0].atr$l_addr = (void *) &recattr;
    attr_rqst_list[1].atr$w_size = sizeof fchars;
    attr_rqst_list[1].atr$w_type = ATR$C_UCHAR;
    *(void **) &attr_rqst_list[1].atr$l_addr = (void *) &fchars;
    attr_rqst_list[2].atr$w_size = attr_rqst_list[2].atr$w_type = 0;
    attr_rqst_list[2].atr$l_addr = 0;
    /* file "record" attributes */
    memset((void *) &recattr, 0, sizeof recattr);
    fchars = 0;			/* file characteristics */

    /* get current attributes */
    sts = sys$qiow(0, channel, IO$_ACCESS, iosb, (void (*)()) 0, 0,
		   &fib_dsc, 0, 0, 0, attr_rqst_list, 0);
    if (syswork(sts))
	sts = iosb[0];

    /* set desired attributes */
    if (syswork(sts)) {
	recattr.fat$b_rtype = FAB$C_SEQ | FAB$C_FIX;	/* org=seq, rfm=fix */
	recattr.fat$w_rsize = recattr.fat$w_maxrec = 512;	/* lrl=mrs=512 */
	recattr.fat$b_rattrib = 0;	/* rat=none */
	fchars |= FCH$M_CONTIGB;	/* contiguous-best-try */
	sts = sys$qiow(0, channel, IO$_DEACCESS, iosb, (void (*)()) 0, 0,
		       &fib_dsc, 0, 0, 0, attr_rqst_list, 0);
	if (syswork(sts))
	    sts = iosb[0];
    }

    /* all done */
    tmp = sys$dassgn(channel);
    if (syswork(sts))
	sts = tmp;
    return sts;
}
#endif /* VMS && !USE_COMMAND_FILE */
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d2 8
a9 8
**		===========
**
**	This version of the stream object just writes to a C file.
**	The file is assumed open and left open.
**
**	Bugs:
**		strings written must be less than buffer size.
*/
a19 4
#ifdef _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

d24 1
d36 1
d42 3
a44 4
PUBLIC char * WWW_Download_File=NULL; /* contains the name of the temp file
				      ** which is being downloaded into
				      */
PUBLIC BOOLEAN LYCancelDownload=FALSE;   /* exported to HTFormat.c in libWWW */
d47 3
a49 2
PRIVATE char * FIXED_RECORD_COMMAND = NULL;
#ifdef USE_COMMAND_FILE		     /* Keep this as an option. - FM	*/
d53 1
a53 1
PUBLIC unsigned long LYVMS_FixedLengthRecords PARAMS((char *filename));
d57 3
a59 4
PUBLIC HTStream* HTSaveToFile PARAMS((
	HTPresentation *       pres,
	HTParentAnchor *       anchor,
	HTStream *	       sink));
d62 2
a63 2
**	-------------
*/
d65 1
a65 1
	CONST HTStreamClass *	isa;
d67 8
a74 8
	FILE *			fp;		/* The file we've opened */
	char *			end_command;	/* What to do on _free.  */
	char *			remove_command; /* What to do on _abort. */
	char *			viewer_command; /* Saved external viewer */
	HTFormat		input_format;  /* Original pres->rep	 */
	HTFormat		output_format; /* Original pres->rep_out */
	HTParentAnchor *	anchor;     /* Original stream's anchor. */
	HTStream *		sink;	    /* Original stream's sink.	 */
d76 1
a76 1
	BOOLEAN			idash; /* remember position to become '.'*/
a79 1

d81 5
a85 5
**
**			A C T I O N	R O U T I N E S
**  Bug:
**	All errors are ignored.
*/
d88 3
a90 3
**	------------------
*/
PRIVATE void HTFWriter_put_character ARGS2(HTStream *, me, char, c)
d98 3
a100 5
**	---------------
**
**	Strings must be smaller than this buffer size.
*/
PRIVATE void HTFWriter_put_string ARGS2(HTStream *, me, CONST char*, s)
d108 3
a110 3
**	------------
*/
PRIVATE void HTFWriter_write ARGS3(HTStream *, me, CONST char*, s, int, l)
a116 3



d118 7
a124 7
**	-------------------
**
**	Note that the SGML parsing context is freed, but the created
**	object is not,
**	as it takes on an existence of its own unless explicitly freed.
*/
PRIVATE void HTFWriter_free ARGS1(HTStream *, me)
d132 1
d141 1
a141 1
    if (me->end_command) {		/* Temp file */
d145 4
a148 4
	/*
	 *  It's a binary file saved to disk on VMS, which
	 *  we want to convert to fixed records format. - FM
	 */
d157 1
a157 1
		/* NEVER REMOVE THE FILE unless during an abort!*/
d164 2
a165 2
	     *	It's a compressed file supposedly cached to
	     *	a temporary file for uncompression. - FM
d169 1
d171 2
a172 2
		 *  Save the path with the "gz" or "Z" suffix trimmed,
		 *  and remove any previous uncompressed copy. - FM
d176 2
a177 1
		    !strcasecomp(&path[len-2], "gz")) {
d184 1
a184 1
			path[len-3] = '\0';
d187 1
a187 1
		} else if (len > 4 && !strcasecomp(&path[len-3], "bz2")) {
d194 1
a194 1
			path[len-4] = '\0';
d197 2
a198 2
		} else if (len > 2 && !strcasecomp(&path[len-1], "Z")) {
		    path[len-2] = '\0';
d204 1
a204 1
			 *  Tell user what's happening. - FM
d209 1
a209 1
		     *	Uncompress it. - FM
d217 2
a218 2
		     *	It's still there with the "gz" or "Z" suffix,
		     *	so the uncompression failed. - FM
d229 3
a231 3
		     *	Succeeded!  Create a complete address
		     *	for the uncompressed file and invoke
		     *	HTLoadFile() to handle it. - FM
d235 4
a238 4
		     *	Assuming we have just uncompressed e.g.
		     *	FILE-mpeg.gz -> FILE-mpeg, restore/shorten
		     *	the name to be fit for passing to an external
		     *	viewer, by renaming FILE-mpeg -> FILE.mpe  - kw
d243 1
d246 1
d260 1
a260 1
		    LYLocalFileToURL (&addr, path);
d269 3
a271 3
			 *  Lock the chartrans info we may possibly have,
			 *  so HTCharsetFormat() will not apply the default
			 *  for local files. - KW
d274 1
a274 1
						 UCT_STAGE_PARSER) < 0 ) {
d276 1
a276 1
			     *	If not yet set - KW
d281 1
a281 1
						     UCT_SETBY_DEFAULT+1);
d288 2
a289 2
		     *	Create a complete address for
		     *	the uncompressed file. - FM
d293 1
a293 1
			 *  Tell user what's happening. - FM
d300 9
a308 11
			 *  It's a temporary file we're passing to a
			 *  viewer or helper application.
			 *  Loading the temp file through HTLoadFile()
			 *  would result in yet another HTStream (created
			 *  with HTSaveAndExecute()) which would just
			 *  copy the temp file to another temp file
			 *  (or even the same!).  We can skip this
			 *  needless duplication by using the
			 *  viewer_command which has already been
			 *  determined when the HTCompressed stream was
			 *  created. - kw
d317 1
a317 1
			     *	Tell user what's happening. - FM
d330 1
a330 1
			    /* NEVER REMOVE THE FILE unless during an abort!!!*/
d344 4
a347 4
		    status = HTLoadFile(addr,
					me->anchor,
					me->output_format,
					me->sink);
d363 1
a363 1
		/* NEVER REMOVE THE FILE unless during an abort!!!*/
d368 2
a369 2
	     *	It's a temporary file we're passing to a
	     *	viewer or helper application. - FM
d373 1
a373 1
		 *  Tell user what's happening. - FM
d387 1
a387 1
		/* NEVER REMOVE THE FILE unless during an abort!!!*/
d402 1
a402 2
	     *	It's a file we saved to disk for handling
	     *	via a menu. - FM
d405 1
a405 1
		/* NEVER REMOVE THE FILE unless during an abort!!!*/
d429 1
a429 2
	 *  We want to save cookies picked up when in source
	 *  mode.  ...
d448 3
a450 5
**	-------------
*/
PRIVATE void HTFWriter_abort ARGS2(
	HTStream *,	me,
	HTError,	e GCC_UNUSED)
d452 1
a452 1
    CTRACE((tfp,"HTFWriter_abort called\n"));
d455 1
a455 1
    if (me->end_command) {		/* Temp file */
d462 1
a462 1
	    chmod(me->remove_command, 0600);		/* Ignore errors */
d468 1
a468 1
			me->remove_command, strerror(errno));
d482 3
a484 3
**	-----------------------
*/
PRIVATE CONST HTStreamClass HTFWriter = /* As opposed to print etc */
d486 5
a490 5
	"FileWriter",
	HTFWriter_free,
	HTFWriter_abort,
	HTFWriter_put_character,	HTFWriter_put_string,
	HTFWriter_write
d494 3
a496 3
**	-------------------------
*/
PUBLIC HTStream* HTFWriter_new ARGS1(FILE *, fp)
d498 1
a498 1
    HTStream* me;
d517 8
a524 3
PRIVATE void chrcat ARGS2(
	char *,		result,
	int,		ch)
d526 3
a528 4
    result += strlen(result);
    *result++ = (char)ch;
    *result = 0;
}
a529 65
/*	Make system command from template
**	---------------------------------
**
**	See mailcap spec for description of template.
*/
PRIVATE char *mailcap_substitute ARGS3(
	HTParentAnchor *,	anchor,
	HTPresentation *,	pres,
	char *,			fnam)
{
    int pass;
    int skip;
    size_t need = 0;
    char *result = 0;
    char *s;
    char *repl;

    for (pass = 0; pass < 2; pass++) {
	for (s = pres->command; *s; s++) {
	    if (*s == '%') {
		repl = 0;
		skip = 0;
		if (s[1] == 't') {
		    repl = pres->rep->name;
		    skip = 1;
		} else if (s[1] == 's') {
		    repl = fnam;
		    skip = 1;
		} else if (!strncasecomp(s+1, "{charset}", 9)) {
		    repl = anchor->charset;
		    skip = 9;
		} else if (!strncasecomp(s+1, "{encoding}", 10)) {
		    repl = anchor->content_encoding;
		    skip = 10;
		}
		if (skip != 0) {
		    if (repl == 0)
			repl = "";
		    if (pass) {
			strcat(result, repl);
		    } else {
			need += strlen(repl);
		    }
		    s += skip;
		} else {
		    if (pass) {
			chrcat(result, *s);
		    } else {
			need++;
		    }
		}
	    } else {
		if (pass) {
		    chrcat(result, *s);
		} else {
		    need++;
		}
	    }
	}
	if (pass == 0) {
	    if ((result = malloc(need + 1)) == 0)
		outofmem(__FILE__, "mailcap_substitute");
	    *result = 0;
	}
    }
d532 1
a532 1
    if (strstr(pres->command, "%s") == 0) {
d534 4
a537 3
	char *format = "( %s ) < %s";
	HTSprintf(&prepend, "( %s", pres->command); /* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam); /* ...to quote if needed */
d546 11
a556 12
**	----------------------------------
**
**	originally from Ghostview handling by Marc Andreseen.
**	Creates temporary file, writes to it, executes system command
**	on end-document.  The suffix of the temp file can be given
**	in case the application is fussy, or so that a generic opener can
**	be used.
*/
PUBLIC HTStream* HTSaveAndExecute ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d559 2
a560 2
    CONST char *suffix;
    HTStream* me;
d564 1
a564 1
	return(NULL);
d567 1
a567 1
    if (pres->quality == 999.0) { /* exec link */
d570 1
a570 1
	    return(NULL);
d579 1
a579 1
		 !strncmp(anchor->address,"file://localhost",16))) {
d596 1
a596 1
	return(HTSaveToFile(pres, anchor, sink));
d609 6
a614 6
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The binary suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
d619 1
a619 1
	if (!strncmp(anchor->address,"file://localhost",16)) {
d633 1
a633 1
	    if (strchr(view_fname, ':')==NULL) {
d663 2
a664 2
	 *  Check for a suffix.
	 *  Save the file under a suitably suffixed name.
a669 2
	} else if (!strncasecomp(pres->rep->name, "application/", 12)) {
	    suffix = BIN_SUFFIX;
d672 6
a677 2
		    || *suffix != '.') {
	    suffix = HTML_SUFFIX;
d690 1
a690 1
     *	Make command to process file.
d695 1
a695 1
     *	Make command to delete file.
a704 1

d706 2
a707 2
**	-------------------------------------
*/
d712 12
a723 13
**	--------------------
**
**	usually a binary file that can't be displayed
**
**	originally from Ghostview handling by Marc Andreseen.
**	Asks the user if he wants to continue, creates a temporary
**	file, and writes to it.  In HTSaveToFile_Free
**	the user will see a list of choices for download
*/
PUBLIC HTStream* HTSaveToFile ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d725 1
a725 1
    HTStream * ret_obj;
d727 1
a727 1
    CONST char * suffix;
d733 1
d745 1
a745 1
	ret_obj->fp = stdout; /* stdout*/
d762 1
a762 1
	    return(NULL);
d766 1
a766 1
	    strstr((cp+1), "charset") != NULL) {
d768 1
a768 1
	} else if (*(pres->rep->name) != '\0')	{
d778 2
a779 2
	     *	'C'ancel on Control-C or Control-Y and
	     *	a 'N'o to the "really exit" query. - FM
d789 1
a789 1
	 *  Cancel on 'C', 'c' or Control-G or Control-C.
d795 1
a795 1
	    return(NULL);
d800 1
a800 1
     *	Set up a 'D'ownload.
d803 6
a808 6
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The binary suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
d813 2
a814 2
	 *  Check for a suffix.
	 *  Save the file under a suitably suffixed name.
d824 1
a824 1
		    || *suffix != '.') {
d836 3
a838 3
    if (0==strncasecomp(pres->rep->name, "text/", 5) ||
	0==strcasecomp(pres->rep->name, "application/postscript") ||
	0==strcasecomp(pres->rep->name, "application/x-RUNOFF-MANUAL"))
d840 2
a841 3
	 *  It's a text file requested via 'd'ownload.
	 *  Keep adding others to the above list, 'til
	 *  we add a configurable procedure. - FM
d846 4
a849 5
     *	Any "application/foo" or other non-"text/foo" types that
     *	are actually text but not checked, above, will be treated
     *	as binary, so show the type to help sort that out later.
     *	Unix folks don't need to know this, but we'll show it to
     *	them, too. - FM
d853 1
a853 1
    StrAllocCopy(WWW_Download_File,fnam);
d856 1
a856 1
     *	Make command to delete file.
d871 1
a871 1
    StrAllocCopy(ret_obj->end_command, "SaveToFile");
d879 1
a879 1
Prepend_BASE:
d884 6
a889 6
	 *  Add the document's base as a BASE tag at the top of the file,
	 *  so that any partial or relative URLs within it will be resolved
	 *  relative to that if no BASE tag is present and replaces it.
	 *  Note that the markup will be technically invalid if a DOCTYPE
	 *  declaration, or HTML or HEAD tags, are present, and thus the
	 *  file may need editing for perfection. - FM
d891 1
a891 1
	 *  Add timestamp (last reload).
d895 1
a895 1
	if (anchor->content_base && *anchor->content_base) {
d897 1
a897 1
	} else if (anchor->content_location && *anchor->content_location) {
d909 1
a909 1
	if (anchor->date && *anchor->date) {
d911 5
a915 4
		"<!-- Date: %s -->\n", anchor->date);
	    if (anchor->last_modified && *anchor->last_modified
			&& strcmp(anchor->last_modified, anchor->date)
			&& strcmp(anchor->last_modified, "Thu, 01 Jan 1970 00:00:01 GMT")) {
d917 1
a917 1
		    "<!-- Last-Modified: %s -->\n", anchor->last_modified);
d928 6
a933 7
	 *  Add the document's charset as a META CHARSET tag
	 *  at the top of the file, so HTTP charset header
	 *  will not be forgotten when a document saved as local file.
	 *  We add this line only(!) if HTTP charset present. - LP
	 *  Note that the markup will be technically invalid if a DOCTYPE
	 *  declaration, or HTML or HEAD tags, are present, and thus the
	 *  file may need editing for perfection. - FM
d937 1
a937 1
	if (anchor->charset && *anchor->charset) {
d941 2
a942 2
		"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		temp);
d950 5
a954 6
**	-------------------------------
*/
PUBLIC HTStream* HTCompressed ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d956 1
a956 1
    HTStream* me;
d960 1
d965 1
a965 2
    CONST char *program;
    CONST char *suffix;
d967 2
a968 2
    char *compress_suffix = "";
    CONST char *middle;
d971 2
a972 3
     *	Deal with any inappropriate invocations of this function,
     *	or a download request, in which case we won't bother to
     *	uncompress the file. - FM
d976 2
a977 2
	 *  We have no idea what we're dealing with,
	 *  so treat it as a binary stream. - FM
d985 5
a989 3
	Pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
	if (!strcasecomp(Pres->rep->name, anchor->content_type) &&
	    Pres->rep_out == WWW_PRESENT) {
d991 12
a1002 1
	     *	We have a presentation mapping for it. - FM
d1005 27
a1031 9
	    if ((!strcasecomp(anchor->content_encoding, "x-gzip") ||
		 !strcasecomp(anchor->content_encoding, "gzip")) &&
		 (program = HTGetProgramPath(ppGZIP)) != NULL) {
		/*
		 *  It's compressed with the modern gzip. - FM
		 */
		StrAllocCopy(uncompress_mask, program);
		StrAllocCat(uncompress_mask, " -d --no-name %s");
		compress_suffix = "gz";
d1033 9
a1041 7
	    }
	    if ((!strcasecomp(anchor->content_encoding, "x-bzip2") ||
		 !strcasecomp(anchor->content_encoding, "bzip2")) &&
		(program = HTGetProgramPath(ppBZIP2)) != NULL) {
		StrAllocCopy(uncompress_mask, program);
		StrAllocCat(uncompress_mask, " -d %s");
		compress_suffix = "bz2";
d1043 1
a1043 10
	    }
	    if ((!strcasecomp(anchor->content_encoding, "x-compress") ||
		 !strcasecomp(anchor->content_encoding, "compress")) &&
		(program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
		/*
		 *  It's compressed the old fashioned Unix way. - FM
		 */
		StrAllocCopy(uncompress_mask, program);
		StrAllocCat(uncompress_mask, " %s");
		compress_suffix = "Z";
a1045 1
	    break;
d1048 3
a1050 3
    if (can_present == FALSE ||			 /* no presentation mapping */
	uncompress_mask == NULL ||		    /* not gzip or compress */
	strchr(anchor->content_type, ';') ||		   /* wrong charset */
d1053 1
a1053 1
	(traversal &&	   /* only handle html or plain text for traversals */
d1057 2
a1058 2
	 *  Cast the Content-Encoding to a Content-Type
	 *  and pass it back to be handled as that type. - FM
d1062 3
a1064 3
	     *  Use "x-" prefix, none of the types we are likely to
	     *  construct here are official.  That is we generate
	     *  "application/x-gzip" and so on. - kw
d1075 1
a1075 1
	FREE(type)
d1082 2
a1083 2
     *	Set up the stream structure for uncompressing and then
     *	handling based on the uncompressed Content-Type.- FM
d1098 1
a1098 1
     *	Remove any old versions of the file. - FM
d1106 1
a1106 1
     *	Get a new temporary filename and substitute a suitable suffix. - FM
d1115 1
d1136 1
a1136 1
	strcat(temp, "-");	/* NAME.html-gz, NAME.txt-gz, NAME.txt-Z etc.*/
d1138 1
a1138 1
	strcat(temp, ".");	/* NAME-htm.gz (DOS), NAME.html.gz (UNIX)etc.*/
d1144 1
a1144 1
     *	Open the file for receiving the compressed input stream. - FM
d1146 1
a1146 1
    me->fp = LYOpenTemp (fnam, temp, BIN_W);
d1155 4
a1158 4
     *	me->viewer_command will be NULL if the converter Pres found above
     *	is not for an external viewer but an internal HTStream converter.
     *	We also don't set it under conditions where HTSaveAndExecute would
     *	disallow execution of the command. - KW
d1167 1
a1167 1
		!strncmp(anchor->address,"file://localhost",16))))))
d1174 1
a1174 1
     *	Make command to process file. - FM
d1187 3
a1189 2
    if (compress_suffix[0] == 'g'	/* must be gzip */
	&& !me->viewer_command) {
d1205 1
a1205 1
     *	Make command to delete file. - FM
d1212 1
a1212 1
     *	Save the filename and return the structure. - FM
d1219 6
a1224 7
**	---------------------
**
*/
PUBLIC HTStream* HTDumpToStdout ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink GCC_UNUSED)
d1226 2
a1227 1
    HTStream * ret_obj;
d1229 1
d1237 1
a1237 1
    ret_obj->fp = stdout; /* stdout*/
d1251 1
a1251 1
#define FCH$V_CONTIGB	0x005			/* pos of cont best try bit */
d1255 8
a1262 8
    unsigned char	fat$b_rtype,	fat$b_rattrib;
    unsigned short	fat$w_rsize;
    unsigned long	fat$l_hiblk,	fat$l_efblk;
    unsigned short	fat$w_ffbyte;
    unsigned char	fat$b_bktsize,	fat$b_vfcsize;
    unsigned short	fat$w_maxrec,	fat$w_defext,	fat$w_gbc;
    unsigned	: 16, : 32, : 16;   /* 6 bytes reserved, 2 bytes not used */
    unsigned short	fat$w_versions;
d1267 4
a1270 1
typedef struct dsc { unsigned short len, mbz; void *adr; } Desc;
d1272 1
a1272 1
extern unsigned long	sys$open(),  sys$qiow(),  sys$dassgn();
a1276 1

d1278 1
a1278 1
 *  25-Jul-1995 - Pat Rankin (rankin@@eql.caltech.edu)
d1280 2
a1281 2
 *  Force a file to be marked as having fixed-length, 512 byte records
 *  without implied carriage control, and with best_try_contiguous set.
d1283 1
a1283 1
PUBLIC unsigned long LYVMS_FixedLengthRecords ARGS1(char *, filename)
d1285 8
a1292 8
    struct FAB	    fab;		/* RMS file access block */
    struct fibdef   fib;		/* XQP file information block */
    struct fatdef   recattr;		/* XQP file "record" attributes */
    struct atrdef   attr_rqst_list[3];	/* XQP attribute request itemlist */

    Desc	    fib_dsc;
    unsigned short  channel,  iosb[4];
    unsigned long   fchars,  sts,  tmp;
d1309 2
a1310 1
    if (sysfail(sts)) return sts;
d1321 1
a1321 1
    memset((void *)&fib, 0, sizeof fib);
d1325 1
a1325 1
    *(void **)&attr_rqst_list[0].atr$l_addr = (void *)&recattr;
d1328 1
a1328 1
    *(void **)&attr_rqst_list[1].atr$l_addr = (void *)&fchars;
d1332 2
a1333 2
    memset((void *)&recattr, 0, sizeof recattr);
    fchars = 0;		/* file characteristics */
d1336 1
a1336 1
    sts = sys$qiow(0, channel, IO$_ACCESS, iosb, (void(*)())0, 0,
d1344 4
a1347 4
	recattr.fat$w_rsize = recattr.fat$w_maxrec = 512;   /* lrl=mrs=512 */
	recattr.fat$b_rattrib = 0;			/* rat=none */
	fchars |= FCH$M_CONTIGB;		/* contiguous-best-try */
	sts = sys$qiow(0, channel, IO$_DEACCESS, iosb, (void(*)())0, 0,
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d40 1
a40 1
#ifdef EXP_PERSISTENT_COOKIES
d139 1
a139 1
    BOOL use_gzread = NO;
d186 1
a186 1
			use_gzread = YES;
d194 9
a202 2
		    path[len-4] = '\0';
		    remove(path);
d207 1
a207 1
		if (!use_gzread) {
d265 1
a265 1
		    if (!use_gzread) {
d434 1
a434 1
#ifdef EXP_PERSISTENT_COOKIES
d441 1
a441 1
#endif /* EXP_PERSISTENT_COOKIES */
d1226 10
d1237 2
a1238 2
    if (compress_suffix[0] == 'g' && /* must be gzip */
	!me->viewer_command) {
d1240 2
a1241 2
	 *  We won't call gzip externally, so we don't need to supply
	 *  a command for it. - kw
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d16 8
d35 1
d40 4
d51 1
a51 1
#ifdef USE_COMMAND_FILE 	     /* Keep this as an option. - FM	*/
d96 3
a98 1
    putc(c, me->fp);
d108 3
a110 1
    fputs(s, me->fp);
d118 3
a120 1
    fwrite(s, 1, l, me->fp);
a134 1
    FILE *fp = NULL;
d140 6
d147 2
a148 1
    fflush(me->fp);
d176 1
a176 1
		BOOL skip_loadfile = (me->viewer_command != NULL);
d182 2
a183 5
		if ((len = strlen(path)) > 3) {
		    if (!strcasecomp(&path[len-3], "bz2")) {
			    path[len-4] = '\0';
			    remove(path);
		    } else if (!strcasecomp(&path[len-2], "gz")) {
d185 3
a187 3
			if (!skip_loadfile) {
			    use_gzread = YES;
			} else
d189 2
a190 6
			{
			    path[len-3] = '\0';
			    remove(path);
			}
		    } else if (!strcasecomp(&path[len-1], "Z")) {
			path[len-2] = '\0';
d193 6
d212 1
a212 1
		    fp = fopen(me->anchor->FileCache, "r");
d214 1
a214 1
		if (fp != NULL) {
a218 2
		    fclose(fp);
		    fp = NULL;
d221 1
a221 1
			refresh();
d224 1
a224 1
		    remove(me->anchor->FileCache);
d292 1
a292 1
			_user_message(WWW_USING_MESSAGE, addr);
d319 1
d321 1
d323 3
d327 1
a327 1

d332 7
a338 1
			if (!dump_output_immediately)
d340 2
d375 1
d377 1
d379 3
d383 1
d389 7
a395 1
	    if (!dump_output_immediately)
d397 2
d408 10
d427 9
a435 1
	exit_immediately(0);
d442 6
d455 1
a455 1
    CTRACE(tfp,"HTFWriter_abort called\n");
d459 1
a459 1
	CTRACE(tfp, "HTFWriter: Aborting: file not executed.\n");
d462 1
d464 11
d506 1
a506 1
    me = (HTStream*)calloc(sizeof(*me),1);
d520 9
d534 73
a606 6

#ifndef VMS
#define REMOVE_COMMAND "/bin/rm -f %s"
#else
#define REMOVE_COMMAND "delete/noconfirm/nolog %s;"
#endif /* VMS */
a629 1

d640 1
a640 1
	if (!local_exec)
d645 1
d655 1
d663 1
a663 1
    me = (HTStream*)calloc(sizeof(*me),1);
d673 8
a680 1
	me->fp = LYNewBinFile (fnam);
d682 44
d732 7
a738 7
	} else if (!strcasecomp(pres->rep->name, "text/plain")) {
	    suffix = ".txt";
	} else if (!strcasecomp(pres->rep->name,
				"application/octet-stream")) {
	    suffix = ".bin";
	} else if ((suffix = HTFileSuffix(pres->rep, anchor->content_encoding)) == 0
		   || *suffix != '.') {
d741 1
a741 1
	me->fp = LYOpenTemp(fnam, suffix, "wb");
d754 1
a754 3
    me->end_command = 0;
    HTAddParam(&(me->end_command), pres->command, 1, fnam);
    HTEndParam(&(me->end_command), pres->command, 1);
d796 1
a796 1
    ret_obj = (HTStream*)calloc(sizeof(* ret_obj),1);
d828 1
a828 1
	if (((cp=strchr(pres->rep->name, ';')) != NULL) &&
d837 2
a838 2
	while(TOUPPER(c)!='C' && TOUPPER(c)!='D' && c!=7) {
	    c=LYgetch();
d854 1
a854 1
	if (TOUPPER(c)=='C' || c==7 || c==3) {
d866 8
a873 1
	ret_obj->fp = LYNewBinFile (fnam);
d881 4
a884 5
	} else if (!strcasecomp(pres->rep->name, "text/plain")) {
	    suffix = ".txt";
	} else if (!strcasecomp(pres->rep->name,
				    "application/octet-stream")) {
	    suffix = ".bin";
d890 1
a890 1
	ret_obj->fp = LYOpenTemp(fnam, suffix, "wb");
d974 2
a975 2
	if (anchor->date && *anchor->date)
	     fprintf(ret_obj->fp,
d977 7
d1030 1
a1034 1
    FILE *fp = NULL;
d1059 3
a1061 7
	    if (!strcasecomp(anchor->content_encoding, "x-bzip2") ||
		!strcasecomp(anchor->content_encoding, "bzip")) {
		StrAllocCopy(uncompress_mask, BZIP2_PATH);
		StrAllocCat(uncompress_mask, " -d %s");
		compress_suffix = "bz2";
	    } else if (!strcasecomp(anchor->content_encoding, "x-gzip") ||
		!strcasecomp(anchor->content_encoding, "gzip")) {
d1065 1
a1065 1
		StrAllocCopy(uncompress_mask, GZIP_PATH);
d1068 13
a1080 2
	    } else if (!strcasecomp(anchor->content_encoding, "x-compress") ||
		       !strcasecomp(anchor->content_encoding, "compress")) {
d1084 1
a1084 1
		StrAllocCopy(uncompress_mask, UNCOMPRESS_PATH);
d1087 1
d1092 1
a1092 1
    if (can_present == FALSE || 		 /* no presentation mapping */
d1095 1
a1095 1
	HTOutputFormat == HTAtom_for("www/download") || 	/* download */
d1105 9
a1113 1
	    StrAllocCopy(type, "application/");
d1129 1
a1129 1
    me = (HTStream*)calloc(sizeof(*me),1);
d1145 1
a1145 4
	while ((fp = fopen(anchor->FileCache, "r")) != NULL) {
	    fclose(fp);
	    remove(anchor->FileCache);
	}
d1156 4
a1159 5
    } else if (!strcasecomp(anchor->content_type, "text/plain")) {
	middle = "txt";
    } else if (!strcasecomp(anchor->content_type,
			    "application/octet-stream")) {
	middle = "bin";
d1189 1
a1189 1
    me->fp = LYOpenTemp (fnam, temp, "wb");
d1260 1
a1260 1
    ret_obj = (HTStream*)calloc(sizeof(* ret_obj),1);
d1361 1
a1361 1
    fchars = 0; 	/* file characteristics */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 8
a9 8
 *		===========
 *
 *	This version of the stream object just writes to a C file.
 *	The file is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */
a15 4
#ifdef WIN_EX
#include <HTParse.h>
#endif

a19 1
#include <HTInit.h>
a26 1
#include <LYExtern.h>
a29 1
#include <LYGetFile.h>
d31 4
a34 7
#ifdef USE_PERSISTENT_COOKIES
#include <LYCookie.h>
#endif

/* contains the name of the temp file which is being downloaded into */
char *WWW_Download_File = NULL;
BOOLEAN LYCancelDownload = FALSE;	/* exported to HTFormat.c in libWWW */
d37 2
a38 3
static char *FIXED_RECORD_COMMAND = NULL;

#ifdef USE_COMMAND_FILE		/* Keep this as an option. - FM    */
d42 1
a42 1
unsigned long LYVMS_FixedLengthRecords(char *filename);
d46 4
a49 3
HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink);
d52 2
a53 2
 *	-------------
 */
d55 1
a55 1
    const HTStreamClass *isa;
d57 8
a64 8
    FILE *fp;			/* The file we've opened */
    char *end_command;		/* What to do on _free.  */
    char *remove_command;	/* What to do on _abort. */
    char *viewer_command;	/* Saved external viewer */
    HTFormat input_format;	/* Original pres->rep     */
    HTFormat output_format;	/* Original pres->rep_out */
    HTParentAnchor *anchor;	/* Original stream's anchor. */
    HTStream *sink;		/* Original stream's sink.   */
d66 1
a66 1
    BOOLEAN idash;		/* remember position to become '.' */
d70 1
d72 5
a76 5
 *
 *			A C T I O N	R O U T I N E S
 *  Bug:
 *	All errors are ignored.
 */
d79 3
a81 3
 *	------------------
 */
static void HTFWriter_put_character(HTStream *me, char c)
d83 1
a83 3
    if (me->fp) {
	putc(c, me->fp);
    }
d87 5
a91 3
 *	---------------
 */
static void HTFWriter_put_string(HTStream *me, const char *s)
d93 1
a93 3
    if (me->fp) {
	fputs(s, me->fp);
    }
d97 3
a99 3
 *	------------
 */
static void HTFWriter_write(HTStream *me, const char *s, int l)
d101 1
a101 3
    if (me->fp) {
	fwrite(s, 1, l, me->fp);
    }
d104 3
d108 7
a114 7
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created
 *	object is not,
 *	as it takes on an existence of its own unless explicitly freed.
 */
static void HTFWriter_free(HTStream *me)
d116 1
d121 1
a121 5
    BOOL use_zread = NO;
    BOOLEAN found = FALSE;

#ifdef WIN_EX
    HANDLE cur_handle;
d123 2
a124 6
    cur_handle = GetForegroundWindow();
#endif

    if (me->fp)
	fflush(me->fp);
    if (me->end_command) {	/* Temp file */
d128 4
a131 4
	    /*
	     * It's a binary file saved to disk on VMS, which
	     * we want to convert to fixed records format.  - FM
	     */
d140 1
a140 1
		/* NEVER REMOVE THE FILE unless during an abort! */
d147 2
a148 2
	     * It's a compressed file supposedly cached to
	     * a temporary file for uncompression.  - FM
d151 1
a151 2
		BOOL skip_loadfile = (BOOL) (me->viewer_command != NULL);

d153 2
a154 2
		 * Save the path with the "gz" or "Z" suffix trimmed,
		 * and remove any previous uncompressed copy.  - FM
d157 5
a161 3
		if ((len = strlen(path)) > 3 &&
		    (!strcasecomp(&path[len - 2], "gz") ||
		     !strcasecomp(&path[len - 2], "zz"))) {
d163 3
a165 3
		    if (!skip_loadfile) {
			use_zread = YES;
		    } else
d167 6
a172 12
		    {
			path[len - 3] = '\0';
			remove(path);
		    }
		} else if (len > 4 && !strcasecomp(&path[len - 3], "bz2")) {
#ifdef USE_BZLIB
		    if (!skip_loadfile) {
			use_zread = YES;
		    } else
#endif /* USE_BZLIB */
		    {
			path[len - 4] = '\0';
a174 3
		} else if (len > 2 && !strcasecomp(&path[len - 1], "Z")) {
		    path[len - 2] = '\0';
		    remove(path);
d176 1
a176 1
		if (!use_zread) {
d179 1
a179 1
			 * Tell user what's happening.  - FM
d184 1
a184 1
		     * Uncompress it.  - FM
d188 1
a188 1
		    found = LYCanReadFile(me->anchor->FileCache);
d190 1
a190 1
		if (found) {
d192 2
a193 2
		     * It's still there with the "gz" or "Z" suffix,
		     * so the uncompression failed.  - FM
d195 2
d199 1
a199 1
			LYrefresh();
d202 1
a202 1
		    LYRemoveTemp(me->anchor->FileCache);
d206 3
a208 3
		     * Succeeded!  Create a complete address
		     * for the uncompressed file and invoke
		     * HTLoadFile() to handle it.  - FM
d212 4
a215 4
		     * Assuming we have just uncompressed e.g.
		     * FILE-mpeg.gz -> FILE-mpeg, restore/shorten
		     * the name to be fit for passing to an external
		     * viewer, by renaming FILE-mpeg -> FILE.mpe - kw
a219 1

a221 1

d235 2
a236 2
		    LYLocalFileToURL(&addr, path);
		    if (!use_zread) {
d244 3
a246 3
			 * Lock the chartrans info we may possibly have,
			 * so HTCharsetFormat() will not apply the default
			 * for local files.  - KW
d249 1
a249 1
						 UCT_STAGE_PARSER) < 0) {
d251 1
a251 1
			     * If not yet set - KW
d256 1
a256 1
						     UCT_SETBY_DEFAULT + 1);
d263 2
a264 2
		     * Create a complete address for
		     * the uncompressed file.  - FM
d268 1
a268 1
			 * Tell user what's happening.  - FM
d270 1
a270 1
			HTUserMsg2(WWW_USING_MESSAGE, addr);
d275 11
a285 9
			 * It's a temporary file we're passing to a viewer or
			 * helper application.  Loading the temp file through
			 * HTLoadFile() would result in yet another HTStream
			 * (created with HTSaveAndExecute()) which would just
			 * copy the temp file to another temp file (or even the
			 * same!).  We can skip this needless duplication by
			 * using the viewer_command which has already been
			 * determined when the HTCompressed stream was created. 
			 * - kw
d294 1
a294 1
			     * Tell user what's happening.  - FM
a296 1
#ifndef WIN_EX
a297 1
#endif
a298 3
#ifdef _WIN_CC
			exec_command(me->end_command, FALSE);
#else
d300 1
a300 1
#endif
d302 1
a302 1
			    /* NEVER REMOVE THE FILE unless during an abort!!! */
d305 1
a305 7
			if (!dump_output_immediately) {
#ifdef WIN_EX
			    if (focus_window) {
				HTInfoMsg(gettext("Set focus1"));
				status = SetForegroundWindow(cur_handle);
			    }
#else
a306 2
#endif
			}
d308 4
a311 4
			status = HTLoadFile(addr,
					    me->anchor,
					    me->output_format,
					    me->sink);
d327 1
a327 1
		/* NEVER REMOVE THE FILE unless during an abort!!! */
d332 2
a333 2
	     * It's a temporary file we're passing to a viewer or helper
	     * application.  - FM
d337 1
a337 1
		 * Tell user what's happening.  - FM
a339 1
#ifndef WIN_EX
a340 1
#endif
a341 3
#ifdef _WIN_CC
	    exec_command(me->end_command, FALSE);
#else
a342 1
#endif
d345 1
a345 1
		/* NEVER REMOVE THE FILE unless during an abort!!! */
d348 1
a348 7
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus2"));
		    status = SetForegroundWindow(cur_handle);
		}
#else
a349 2
#endif
	    }
d352 2
a353 1
	     * It's a file we saved to disk for handling via a menu.  - FM
d356 1
a356 1
		/* NEVER REMOVE THE FILE unless during an abort!!! */
a358 10
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus3"));
		    status = SetForegroundWindow(cur_handle);
		}
#else
		start_curses();
#endif
	    }
d368 1
a368 8
#ifdef USE_PERSISTENT_COOKIES
	/*
	 * We want to save cookies picked up when in source mode.  ...
	 */
	if (persistent_cookies)
	    LYStoreCookies(LYCookieSaveFile);
#endif /* USE_PERSISTENT_COOKIES */
	exit_immediately(EXIT_SUCCESS);
a374 6
#ifdef VMS
#  define REMOVE_COMMAND "delete/noconfirm/nolog %s;"
#else
#  define REMOVE_COMMAND "%s"
#endif /* VMS */

d376 5
a380 3
 *	-------------
 */
static void HTFWriter_abort(HTStream *me, HTError e GCC_UNUSED)
d382 1
a382 1
    CTRACE((tfp, "HTFWriter_abort called\n"));
d385 2
a386 2
    if (me->end_command) {	/* Temp file */
	CTRACE((tfp, "HTFWriter: Aborting: file not executed or saved.\n"));
a388 1
#ifdef VMS
a389 11
#else
	    chmod(me->remove_command, 0600);	/* Ignore errors */
	    if (0 != unlink(me->remove_command)) {
		char buf[560];

		sprintf(buf, "%.60s '%.400s': %.60s",
			gettext("Error deleting file"),
			me->remove_command, LYStrerror(errno));
		HTAlert(buf);
	    }
#endif
d400 3
a402 3
 *	-----------------------
 */
static const HTStreamClass HTFWriter =	/* As opposed to print etc */
d404 5
a408 5
    "FileWriter",
    HTFWriter_free,
    HTFWriter_abort,
    HTFWriter_put_character, HTFWriter_put_string,
    HTFWriter_write
d412 3
a414 3
 *	-------------------------
 */
HTStream *HTFWriter_new(FILE *fp)
d416 1
a416 1
    HTStream *me;
d421 1
a421 1
    me = typecalloc(HTStream);
d436 10
a445 26
 *	---------------------------------
 *
 *	See mailcap spec for description of template.
 */
static char *mailcap_substitute(HTParentAnchor *anchor,
				HTPresentation *pres,
				char *fnam)
{
    char *result = LYMakeMailcapCommand(pres->command,
					anchor->content_type_params,
					fnam);

#if defined(UNIX)
    /* if we don't have a "%s" token, expect to provide the file via stdin */
    if (!LYMailcapUsesPctS(pres->command)) {
	char *prepend = 0;
	const char *format = "( %s ) < %s";

	HTSprintf(&prepend, "( %s", result);	/* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam);	/* ...to quote if needed */
	FREE(result);
	result = prepend;
    }
#endif
    return result;
}
d448 12
a459 11
 *	----------------------------------
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Creates temporary file, writes to it, executes system command
 *	on end-document.  The suffix of the temp file can be given
 *	in case the application is fussy, or so that a generic opener can
 *	be used.
 */
HTStream *HTSaveAndExecute(HTPresentation *pres,
			   HTParentAnchor *anchor,
			   HTStream *sink)
d462 2
a463 2
    const char *suffix;
    HTStream *me;
d467 1
a467 1
	return (NULL);
d469 1
d471 1
a471 1
    if (pres->quality == 999.0) {	/* exec link */
d474 1
a474 1
	    return (NULL);
d480 1
a480 1
	if (!local_exec) {
d483 1
a483 1
		 !strncmp(anchor->address, "file://localhost", 16))) {
a484 1
		;
a493 1
	}
d498 1
a498 1
	return (HTSaveToFile(pres, anchor, sink));
d501 1
a501 1
    me = typecalloc(HTStream);
d511 1
a511 8
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
	 */
	me->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
a512 44
#if defined(WIN_EX) && !defined(__CYGWIN__)	/* 1998/01/04 (Sun) */
	if (!strncmp(anchor->address, "file://localhost", 16)) {

	    /* 1998/01/23 (Fri) 17:38:26 */
	    unsigned char *cp, *view_fname;

#define IS_SJIS_HI1(hi) ((0x81<=hi)&&(hi<=0x9F))	/* 1st lev. */
#define IS_SJIS_HI2(hi) ((0xE0<=hi)&&(hi<=0xEF))	/* 2nd lev. */

	    me->fp = NULL;

	    view_fname = fnam + 3;
	    LYstrncpy(view_fname, anchor->address + 17, sizeof(fnam) - 5);
	    HTUnEscape(view_fname);

	    if (strchr(view_fname, ':') == NULL) {
		fnam[0] = windows_drive[0];
		fnam[1] = windows_drive[1];
		fnam[2] = '/';
		view_fname = fnam;
	    }

	    /* 1998/04/21 (Tue) 11:04:16 */
	    cp = view_fname;
	    while (*cp) {
		if (IS_SJIS_HI1(*cp) || IS_SJIS_HI2(*cp)) {
		    cp += 2;
		    continue;
		} else if (*cp == '/') {
		    *cp = '\\';
		}
		cp++;
	    }
	    if (strchr(view_fname, ' '))
		view_fname = (unsigned char *) quote_pathname(view_fname);

	    StrAllocCopy(me->viewer_command, pres->command);

	    me->end_command = mailcap_substitute(anchor, pres, view_fname);
	    me->remove_command = NULL;

	    return me;
	}
#endif
d514 2
a515 2
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
d519 6
a524 4
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if ((suffix = HTFileSuffix(pres->rep,
					  anchor->content_encoding)) == 0
d526 1
a526 5
	    if (!strncasecomp(pres->rep->name, "application/", 12)) {
		suffix = BIN_SUFFIX;
	    } else {
		suffix = HTML_SUFFIX;
	    }
d528 1
a528 1
	me->fp = LYOpenTemp(fnam, suffix, BIN_W);
d539 1
a539 1
     * Make command to process file.
d541 3
a543 1
    me->end_command = mailcap_substitute(anchor, pres, fnam);
d546 1
a546 1
     * Make command to delete file.
d556 1
d558 2
a559 2
 *	-------------------------------------
 */
d564 13
a576 12
 *	--------------------
 *
 *	usually a binary file that can't be displayed
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Asks the user if he wants to continue, creates a temporary
 *	file, and writes to it.  In HTSaveToFile_Free
 *	the user will see a list of choices for download
 */
HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
d578 1
a578 1
    HTStream *ret_obj;
d580 1
a580 1
    const char *suffix;
d585 1
a585 2
    ret_obj = typecalloc(HTStream);

d597 1
a597 1
	ret_obj->fp = stdout;	/* stdout */
d614 1
a614 1
	    return (NULL);
d617 2
a618 2
	if (((cp = strchr(pres->rep->name, ';')) != NULL) &&
	    strstr((cp + 1), "charset") != NULL) {
d620 1
a620 1
	} else if (*(pres->rep->name) != '\0') {
d626 2
a627 2
	while (c != 'D' && c != 'C' && !LYCharIsINTERRUPT(c)) {
	    c = LYgetch_single();
d630 2
a631 2
	     * 'C'ancel on Control-C or Control-Y and
	     * a 'N'o to the "really exit" query.  - FM
d641 1
a641 1
	 * Cancel on 'C', 'c' or Control-G or Control-C.
d643 1
a643 1
	if (c == 'C' || LYCharIsINTERRUPT(c)) {
d647 1
a647 1
	    return (NULL);
d652 1
a652 1
     * Set up a 'D'ownload.
d655 1
a655 8
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
	 */
	ret_obj->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
d658 2
a659 2
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
d663 5
a667 4
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "application/", 12)) {
	    suffix = BIN_SUFFIX;
d670 1
a670 1
		   || *suffix != '.') {
d673 1
a673 1
	ret_obj->fp = LYOpenTemp(fnam, suffix, BIN_W);
d682 3
a684 3
    if (0 == strncasecomp(pres->rep->name, "text/", 5) ||
	0 == strcasecomp(pres->rep->name, "application/postscript") ||
	0 == strcasecomp(pres->rep->name, "application/x-RUNOFF-MANUAL"))
d686 3
a688 2
	 * It's a text file requested via 'd'ownload.  Keep adding others to
	 * the above list, 'til we add a configurable procedure.  - FM
d693 5
a697 4
     * Any "application/foo" or other non-"text/foo" types that are actually
     * text but not checked, above, will be treated as binary, so show the type
     * to help sort that out later.  Unix folks don't need to know this, but
     * we'll show it to them, too.  - FM
d701 1
a701 1
    StrAllocCopy(WWW_Download_File, fnam);
d704 1
a704 1
     * Make command to delete file.
d719 1
a719 1
	StrAllocCopy(ret_obj->end_command, "SaveToFile");
d727 1
a727 1
  Prepend_BASE:
d732 6
a737 6
	 * Add the document's base as a BASE tag at the top of the file, so
	 * that any partial or relative URLs within it will be resolved
	 * relative to that if no BASE tag is present and replaces it.  Note
	 * that the markup will be technically invalid if a DOCTYPE
	 * declaration, or HTML or HEAD tags, are present, and thus the file
	 * may need editing for perfection.  - FM
d739 1
a739 1
	 * Add timestamp (last reload).
d743 1
a743 1
	if (non_empty(anchor->content_base)) {
d745 1
a745 1
	} else if (non_empty(anchor->content_location)) {
d757 3
a759 11
	if (non_empty(anchor->date)) {
	    fprintf(ret_obj->fp,
		    "<!-- Date: %s -->\n", anchor->date);
	    if (non_empty(anchor->last_modified)
		&& strcmp(anchor->last_modified, anchor->date)
		&& strcmp(anchor->last_modified,
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(ret_obj->fp,
			"<!-- Last-Modified: %s -->\n", anchor->last_modified);
	    }
	}
d768 7
a774 6
	 * Add the document's charset as a META CHARSET tag at the top of the
	 * file, so HTTP charset header will not be forgotten when a document
	 * saved as local file.  We add this line only(!) if HTTP charset
	 * present.  - LP Note that the markup will be technically invalid if a
	 * DOCTYPE declaration, or HTML or HEAD tags, are present, and thus the
	 * file may need editing for perfection.  - FM
d778 1
a778 1
	if (non_empty(anchor->charset)) {
d782 2
a783 2
		    "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		    temp);
d791 6
a796 5
 *	-------------------------------
 */
HTStream *HTCompressed(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
d798 1
a798 1
    HTStream *me;
a801 1
    HTPresentation *Pnow = NULL;
d806 1
a806 1
    const char *suffix;
d808 3
a810 2
    const char *compress_suffix = "";
    const char *middle;
d813 3
a815 2
     * Deal with any inappropriate invocations of this function, or a download
     * request, in which case we won't bother to uncompress the file.  - FM
d819 2
a820 2
	 * We have no idea what we're dealing with, so treat it as a binary
	 * stream.  - FM
d828 3
a830 16
	Pnow = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (!strcasecomp(Pnow->rep->name, anchor->content_type) &&
	    Pnow->rep_out == WWW_PRESENT) {
	    const char *program = "";

	    /*
	     * Pick the best presentation.  User-defined mappings are at the
	     * end of the list, and unless the quality is lower, we prefer
	     * those.
	     */
	    if (Pres == 0)
		Pres = Pnow;
	    else if (Pres->quality > Pnow->quality)
		continue;
	    else
		Pres = Pnow;
d832 1
a832 1
	     * We have a presentation mapping for it.  - FM
d835 21
a855 40
	    switch (HTEncodingToCompressType(anchor->content_encoding)) {
	    case cftGzip:
		if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		    /*
		     * It's compressed with the modern gzip.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d --no-name %s");
		    compress_suffix = "gz";
		}
		break;
	    case cftDeflate:
		if ((program = HTGetProgramPath(ppINFLATE)) != NULL) {
		    /*
		     * It's compressed with a zlib wrapper.
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "zz";
		}
		break;
	    case cftBzip2:
		if ((program = HTGetProgramPath(ppBZIP2)) != NULL) {
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d %s");
		    compress_suffix = "bz2";
		}
		break;
	    case cftCompress:
		if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
		    /*
		     * It's compressed the old fashioned Unix way.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "Z";
		}
		break;
	    case cftNone:
		break;
d857 1
d860 4
a863 4
    if (can_present == FALSE ||	/* no presentation mapping */
	uncompress_mask == NULL ||	/* not gzip or compress */
	strchr(anchor->content_type, ';') ||	/* wrong charset */
	HTOutputFormat == HTAtom_for("www/download") ||		/* download */
d865 1
a865 1
	(traversal &&		/* only handle html or plain text for traversals */
d869 2
a870 2
	 * Cast the Content-Encoding to a Content-Type and pass it back to be
	 * handled as that type.  - FM
d873 1
a873 9
	    /*
	     * Use "x-" prefix, none of the types we are likely to construct
	     * here are official.  That is we generate "application/x-gzip" and
	     * so on.  - kw
	     */
	    if (!strncasecomp(anchor->content_encoding, "x-", 2))
		StrAllocCopy(type, "application/");
	    else
		StrAllocCopy(type, "application/x-");
d879 1
a879 1
	FREE(type);
d886 2
a887 2
     * Set up the stream structure for uncompressing and then handling based on
     * the uncompressed Content-Type.- FM
d889 1
a889 1
    me = typecalloc(HTStream);
d902 1
a902 1
     * Remove any old versions of the file.  - FM
d905 4
a908 1
	LYRemoveTemp(anchor->FileCache);
d913 1
a913 1
     * Get a new temporary filename and substitute a suitable suffix.  - FM
d919 5
a923 5
    } else if (!strncasecomp(anchor->content_type, "text/", 5)) {
	middle = TEXT_SUFFIX + 1;
    } else if (!strncasecomp(anchor->content_type, "application/", 12)) {
	/* FIXME: why is this BEFORE HTFileSuffix? */
	middle = BIN_SUFFIX + 1;
d943 1
a943 1
	strcat(temp, "-");	/* NAME.html-gz, NAME.txt-gz, NAME.txt-Z etc. */
d945 1
a945 1
	strcat(temp, ".");	/* NAME-htm.gz (DOS), NAME.html.gz (UNIX)etc. */
d951 1
a951 1
     * Open the file for receiving the compressed input stream.  - FM
d953 1
a953 1
    me->fp = LYOpenTemp(fnam, temp, BIN_W);
d962 4
a965 4
     * me->viewer_command will be NULL if the converter Pres found above is not
     * for an external viewer but an internal HTStream converter.  We also
     * don't set it under conditions where HTSaveAndExecute would disallow
     * execution of the command.  - KW
d974 1
a974 1
		!strncmp(anchor->address, "file://localhost", 16))))))
d981 1
a981 1
     * Make command to process file.  - FM
a982 10
#ifdef USE_BZLIB
    if (compress_suffix[0] == 'b'	/* must be bzip2 */
	&& !me->viewer_command) {
	/*
	 * We won't call bzip2 externally, so we don't need to supply a command
	 * for it.
	 */
	StrAllocCopy(me->end_command, "");
    } else
#endif
d984 2
a985 3
	/* FIXME: allow deflate here, e.g., 'z' */
	if (compress_suffix[0] == 'g'	/* must be gzip */
	    && !me->viewer_command) {
d987 2
a988 2
	 * We won't call gzip or compress externally, so we don't need to
	 * supply a command for it.
d1001 1
a1001 1
     * Make command to delete file.  - FM
d1008 1
a1008 1
     * Save the filename and return the structure.  - FM
d1015 7
a1021 6
 *	---------------------
 *
 */
HTStream *HTDumpToStdout(HTPresentation *pres GCC_UNUSED,
			 HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
d1023 2
a1024 4
    HTStream *ret_obj;

    ret_obj = typecalloc(HTStream);

d1032 1
a1032 1
    ret_obj->fp = stdout;	/* stdout */
d1046 1
a1046 1
#define FCH$V_CONTIGB	0x005	/* pos of cont best try bit */
d1050 8
a1057 8
    unsigned char fat$b_rtype, fat$b_rattrib;
    unsigned short fat$w_rsize;
    unsigned long fat$l_hiblk, fat$l_efblk;
    unsigned short fat$w_ffbyte;
    unsigned char fat$b_bktsize, fat$b_vfcsize;
    unsigned short fat$w_maxrec, fat$w_defext, fat$w_gbc;
    unsigned:16,:32,:16;	/* 6 bytes reserved, 2 bytes not used */
    unsigned short fat$w_versions;
d1062 1
a1062 4
typedef struct dsc {
    unsigned short len, mbz;
    void *adr;
} Desc;
d1064 1
a1064 1
extern unsigned long sys$open(), sys$qiow(), sys$dassgn();
d1069 1
d1071 1
a1071 1
 * 25-Jul-1995 - Pat Rankin (rankin@@eql.caltech.edu)
d1073 2
a1074 2
 * Force a file to be marked as having fixed-length, 512 byte records
 * without implied carriage control, and with best_try_contiguous set.
d1076 1
a1076 1
unsigned long LYVMS_FixedLengthRecords(char *filename)
d1078 8
a1085 8
    struct FAB fab;		/* RMS file access block */
    struct fibdef fib;		/* XQP file information block */
    struct fatdef recattr;	/* XQP file "record" attributes */
    struct atrdef attr_rqst_list[3];	/* XQP attribute request itemlist */

    Desc fib_dsc;
    unsigned short channel, iosb[4];
    unsigned long fchars, sts, tmp;
d1102 1
a1102 2
    if (sysfail(sts))
	return sts;
d1113 1
a1113 1
    memset((void *) &fib, 0, sizeof fib);
d1117 1
a1117 1
    *(void **) &attr_rqst_list[0].atr$l_addr = (void *) &recattr;
d1120 1
a1120 1
    *(void **) &attr_rqst_list[1].atr$l_addr = (void *) &fchars;
d1124 2
a1125 2
    memset((void *) &recattr, 0, sizeof recattr);
    fchars = 0;			/* file characteristics */
d1128 1
a1128 1
    sts = sys$qiow(0, channel, IO$_ACCESS, iosb, (void (*)()) 0, 0,
d1136 4
a1139 4
	recattr.fat$w_rsize = recattr.fat$w_maxrec = 512;	/* lrl=mrs=512 */
	recattr.fat$b_rattrib = 0;	/* rat=none */
	fchars |= FCH$M_CONTIGB;	/* contiguous-best-try */
	sts = sys$qiow(0, channel, IO$_DEACCESS, iosb, (void (*)()) 0, 0,
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a15 8
#ifdef WIN_EX
#include <HTParse.h>
#endif

#ifdef _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

a26 1
#include <LYExtern.h>
a30 4
#ifdef EXP_PERSISTENT_COOKIES
#include <LYCookie.h>
#endif

d38 1
a38 1
#ifdef USE_COMMAND_FILE		     /* Keep this as an option. - FM	*/
d83 1
a83 3
    if (me->fp) {
	putc(c, me->fp);
    }
d93 1
a93 3
    if (me->fp) {
	fputs(s, me->fp);
    }
d101 1
a101 3
    if (me->fp) {
	fwrite(s, 1, l, me->fp);
    }
d116 1
a121 6
    BOOLEAN found = FALSE;
#ifdef WIN_EX
    HANDLE cur_handle;

    cur_handle = GetForegroundWindow();
#endif
d123 1
a123 2
    if (me->fp)
	fflush(me->fp);
d151 1
a151 1
		BOOL skip_loadfile = (BOOL) (me->viewer_command != NULL);
d157 5
a161 2
		if ((len = strlen(path)) > 3 &&
		    !strcasecomp(&path[len-2], "gz")) {
d163 3
a165 3
		    if (!skip_loadfile) {
			use_gzread = YES;
		    } else
d167 6
a172 2
		    {
			path[len-3] = '\0';
a174 6
		} else if (len > 4 && !strcasecomp(&path[len-3], "bz2")) {
		    path[len-4] = '\0';
		    remove(path);
		} else if (len > 2 && !strcasecomp(&path[len-1], "Z")) {
		    path[len-2] = '\0';
		    remove(path);
d188 1
a188 1
		    found = LYCanReadFile(me->anchor->FileCache);
d190 1
a190 1
		if (found) {
d195 2
d199 1
a199 1
			LYrefresh();
d202 1
a202 1
		    LYRemoveTemp(me->anchor->FileCache);
d270 1
a270 1
			HTUserMsg2(WWW_USING_MESSAGE, addr);
a296 1
#ifndef WIN_EX
a297 1
#endif
a298 3
#ifdef _WIN_CC
			exec_command(me->end_command, FALSE);
#else
d300 1
a300 1
#endif
d305 1
a305 7
			if (!dump_output_immediately) {
#ifdef WIN_EX
			    if (focus_window) {
				HTInfoMsg(gettext("Set focus1"));
				status = SetForegroundWindow(cur_handle);
			    }
#else
a306 2
#endif
			}
a339 1
#ifndef WIN_EX
a340 1
#endif
a341 3
#ifdef _WIN_CC
	    exec_command(me->end_command, FALSE);
#else
a342 1
#endif
d348 1
a348 7
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus2"));
		    status = SetForegroundWindow(cur_handle);
		}
#else
a349 2
#endif
	    }
a358 10
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus3"));
		    status = SetForegroundWindow(cur_handle);
		}
#else
		start_curses();
#endif
	    }
d368 1
a368 9
#ifdef EXP_PERSISTENT_COOKIES
	/*
	 *  We want to save cookies picked up when in source
	 *  mode.  ...
	 */
	if (persistent_cookies)
	    LYStoreCookies(LYCookieSaveFile);
#endif /* EXP_PERSISTENT_COOKIES */
	exit_immediately(EXIT_SUCCESS);
a374 6
#ifdef VMS
#  define REMOVE_COMMAND "delete/noconfirm/nolog %s;"
#else
#  define REMOVE_COMMAND "%s"
#endif /* VMS */

d382 1
a382 1
    CTRACE((tfp,"HTFWriter_abort called\n"));
d386 1
a386 1
	CTRACE((tfp, "HTFWriter: Aborting: file not executed or saved.\n"));
a388 1
#ifdef VMS
a389 11
#else
	    chmod(me->remove_command, 0600);		/* Ignore errors */
	    if (0 != unlink(me->remove_command)) {
		char buf[560];

		sprintf(buf, "%.60s '%.400s': %.60s",
			gettext("Error deleting file"),
			me->remove_command, strerror(errno));
		HTAlert(buf);
	    }
#endif
d421 1
a421 1
    me = typecalloc(HTStream);
a434 9
PRIVATE void chrcat ARGS2(
	char *,		result,
	int,		ch)
{
    result += strlen(result);
    *result++ = (char)ch;
    *result = 0;
}

d440 6
a445 73
PRIVATE char *mailcap_substitute ARGS3(
	HTParentAnchor *,	anchor,
	HTPresentation *,	pres,
	char *,			fnam)
{
    int pass;
    int skip;
    size_t need = 0;
    char *result = 0;
    char *s;
    char *repl;

    for (pass = 0; pass < 2; pass++) {
	for (s = pres->command; *s; s++) {
	    if (*s == '%') {
		repl = 0;
		skip = 0;
		if (s[1] == 't') {
		    repl = pres->rep->name;
		    skip = 1;
		} else if (s[1] == 's') {
		    repl = fnam;
		    skip = 1;
		} else if (!strncasecomp(s+1, "{charset}", 9)) {
		    repl = anchor->charset;
		    skip = 9;
		} else if (!strncasecomp(s+1, "{encoding}", 10)) {
		    repl = anchor->content_encoding;
		    skip = 10;
		}
		if (skip != 0) {
		    if (repl == 0)
			repl = "";
		    if (pass) {
			strcat(result, repl);
		    } else {
			need += strlen(repl);
		    }
		    s += skip;
		} else {
		    if (pass) {
			chrcat(result, *s);
		    } else {
			need++;
		    }
		}
	    } else {
		if (pass) {
		    chrcat(result, *s);
		} else {
		    need++;
		}
	    }
	}
	if (pass == 0) {
	    if ((result = malloc(need + 1)) == 0)
		outofmem(__FILE__, "mailcap_substitute");
	    *result = 0;
	}
    }
#if defined(UNIX)
    /* if we don't have a "%s" token, expect to provide the file via stdin */
    if (strstr(pres->command, "%s") == 0) {
	char *prepend = 0;
	char *format = "( %s ) < %s";
	HTSprintf(&prepend, "( %s", pres->command); /* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam); /* ...to quote if needed */
	FREE(result);
	result = prepend;
    }
#endif
    return result;
}
d469 1
d480 1
a480 1
	if (!local_exec) {
a484 1
		;
a493 1
	}
d501 1
a501 1
    me = typecalloc(HTStream);
d511 1
a511 8
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The binary suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
	 */
	me->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
a512 44
#if defined(WIN_EX) && !defined(__CYGWIN__)	/* 1998/01/04 (Sun) */
	if (!strncmp(anchor->address,"file://localhost",16)) {

	    /* 1998/01/23 (Fri) 17:38:26 */
	    unsigned char *cp, *view_fname;

#define IS_SJIS_HI1(hi) ((0x81<=hi)&&(hi<=0x9F))	/* 1st lev. */
#define IS_SJIS_HI2(hi) ((0xE0<=hi)&&(hi<=0xEF))	/* 2nd lev. */

	    me->fp = NULL;

	    view_fname = fnam + 3;
	    LYstrncpy(view_fname, anchor->address + 17, sizeof(fnam) - 5);
	    HTUnEscape(view_fname);

	    if (strchr(view_fname, ':')==NULL) {
		fnam[0] = windows_drive[0];
		fnam[1] = windows_drive[1];
		fnam[2] = '/';
		view_fname = fnam;
	    }

	    /* 1998/04/21 (Tue) 11:04:16 */
	    cp = view_fname;
	    while (*cp) {
		if (IS_SJIS_HI1(*cp) || IS_SJIS_HI2(*cp)) {
		    cp += 2;
		    continue;
		} else if (*cp == '/') {
		    *cp = '\\';
		}
		cp++;
	    }
	    if (strchr(view_fname, ' '))
		view_fname = (unsigned char *) quote_pathname(view_fname);

	    StrAllocCopy(me->viewer_command, pres->command);

	    me->end_command = mailcap_substitute(anchor, pres, view_fname);
	    me->remove_command = NULL;

	    return me;
	}
#endif
d519 7
a525 7
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "application/", 12)) {
	    suffix = BIN_SUFFIX;
	} else if ((suffix = HTFileSuffix(pres->rep,
					  anchor->content_encoding)) == 0
		    || *suffix != '.') {
d528 1
a528 1
	me->fp = LYOpenTemp(fnam, suffix, BIN_W);
d541 3
a543 1
    me->end_command = mailcap_substitute(anchor, pres, fnam);
d585 1
a585 1
    ret_obj = typecalloc(HTStream);
d617 1
a617 1
	if (((cp = strchr(pres->rep->name, ';')) != NULL) &&
d626 2
a627 2
	while (c != 'D' && c != 'C' && !LYCharIsINTERRUPT(c)) {
	    c = LYgetch_single();
d643 1
a643 1
	if (c == 'C' || LYCharIsINTERRUPT(c)) {
d655 1
a655 8
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The binary suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
	 */
	ret_obj->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
d663 5
a667 4
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "application/", 12)) {
	    suffix = BIN_SUFFIX;
d673 1
a673 1
	ret_obj->fp = LYOpenTemp(fnam, suffix, BIN_W);
d757 2
a758 2
	if (anchor->date && *anchor->date) {
	    fprintf(ret_obj->fp,
a759 7
	    if (anchor->last_modified && *anchor->last_modified
			&& strcmp(anchor->last_modified, anchor->date)
			&& strcmp(anchor->last_modified, "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(ret_obj->fp,
		    "<!-- Last-Modified: %s -->\n", anchor->last_modified);
	    }
	}
a805 1
    CONST char *program;
d810 1
d835 7
a841 3
	    if ((!strcasecomp(anchor->content_encoding, "x-gzip") ||
		 !strcasecomp(anchor->content_encoding, "gzip")) &&
		 (program = HTGetProgramPath(ppGZIP)) != NULL) {
d845 1
a845 1
		StrAllocCopy(uncompress_mask, program);
d848 2
a849 13
		break;
	    }
	    if ((!strcasecomp(anchor->content_encoding, "x-bzip2") ||
		 !strcasecomp(anchor->content_encoding, "bzip2")) &&
		(program = HTGetProgramPath(ppBZIP2)) != NULL) {
		StrAllocCopy(uncompress_mask, program);
		StrAllocCat(uncompress_mask, " -d %s");
		compress_suffix = "bz2";
		break;
	    }
	    if ((!strcasecomp(anchor->content_encoding, "x-compress") ||
		 !strcasecomp(anchor->content_encoding, "compress")) &&
		(program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
d853 1
a853 1
		StrAllocCopy(uncompress_mask, program);
a855 1
		break;
d860 1
a860 1
    if (can_present == FALSE ||			 /* no presentation mapping */
d863 1
a863 1
	HTOutputFormat == HTAtom_for("www/download") ||		/* download */
d873 1
a873 9
	    /*
	     *  Use "x-" prefix, none of the types we are likely to
	     *  construct here are official.  That is we generate
	     *  "application/x-gzip" and so on. - kw
	     */
	    if (!strncasecomp(anchor->content_encoding, "x-", 2))
		StrAllocCopy(type, "application/");
	    else
		StrAllocCopy(type, "application/x-");
d889 1
a889 1
    me = typecalloc(HTStream);
d905 4
a908 1
	LYRemoveTemp(anchor->FileCache);
d919 5
a923 4
    } else if (!strncasecomp(anchor->content_type, "text/", 5)) {
	middle = TEXT_SUFFIX + 1;
    } else if (!strncasecomp(anchor->content_type, "application/", 12)) {
	middle = BIN_SUFFIX + 1;
d953 1
a953 1
    me->fp = LYOpenTemp (fnam, temp, BIN_W);
d1024 1
a1024 1
    ret_obj = typecalloc(HTStream);
d1125 1
a1125 1
    fchars = 0;		/* file characteristics */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d40 1
a40 1
#ifdef USE_PERSISTENT_COOKIES
d139 1
a139 1
    BOOL use_zread = NO;
d186 1
a186 1
			use_zread = YES;
d194 2
a195 9
#ifdef USE_BZLIB
		    if (!skip_loadfile) {
			use_zread = YES;
		    } else
#endif /* USE_BZLIB */
		    {
			path[len-4] = '\0';
			remove(path);
		    }
d200 1
a200 1
		if (!use_zread) {
d258 1
a258 1
		    if (!use_zread) {
d427 1
a427 1
#ifdef USE_PERSISTENT_COOKIES
d434 1
a434 1
#endif /* USE_PERSISTENT_COOKIES */
a1218 10
#ifdef USE_BZLIB
    if (compress_suffix[0] == 'b'	/* must be bzip2 */
	&& !me->viewer_command) {
	/*
	 * We won't call bzip2 externally, so we don't need to supply a command
	 * for it.
	 */
	StrAllocCopy(me->end_command, "");
    } else
#endif
d1220 2
a1221 2
    if (compress_suffix[0] == 'g'	/* must be gzip */
	&& !me->viewer_command) {
d1223 2
a1224 2
	 * We won't call gzip or compress externally, so we don't need to
	 * supply a command for it.
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d478 1
a478 1
			me->remove_command, LYStrerror(errno));
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d44 1
a44 1
char * WWW_Download_File=NULL; /* contains the name of the temp file
d47 1
a47 1
BOOLEAN LYCancelDownload=FALSE;   /* exported to HTFormat.c in libWWW */
d50 1
a50 1
static char * FIXED_RECORD_COMMAND = NULL;
d55 1
a55 1
unsigned long LYVMS_FixedLengthRecords (char *filename);
d59 1
a59 1
HTStream* HTSaveToFile (
d62 1
a62 1
	HTStream *	       sink);
d68 1
a68 1
	const HTStreamClass *	isa;
d94 1
a94 1
static void HTFWriter_put_character (HTStream * me, char c)
d106 1
a106 1
static void HTFWriter_put_string (HTStream * me, const char* s)
d116 1
a116 1
static void HTFWriter_write (HTStream * me, const char* s, int l)
d133 1
a133 1
static void HTFWriter_free (HTStream * me)
d458 3
a460 3
static void HTFWriter_abort (
	HTStream *	me,
	HTError	e GCC_UNUSED)
d494 1
a494 1
static const HTStreamClass HTFWriter = /* As opposed to print etc */
d506 1
a506 1
HTStream* HTFWriter_new (FILE * fp)
d527 3
a529 3
static void chrcat (
	char *		result,
	int		ch)
d541 4
a544 4
static char *mailcap_substitute (
	HTParentAnchor *	anchor,
	HTPresentation *	pres,
	char *			fnam)
d624 4
a627 4
HTStream* HTSaveAndExecute (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d630 1
a630 1
    const char *suffix;
d791 4
a794 4
HTStream* HTSaveToFile (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d798 1
a798 1
    const char * suffix;
d1024 4
a1027 4
HTStream* HTCompressed (
	HTPresentation *	pres,
	HTParentAnchor *	anchor,
	HTStream *		sink)
d1037 2
a1038 2
    const char *program;
    const char *suffix;
d1041 1
a1041 1
    const char *middle;
d1271 4
a1274 4
HTStream* HTDumpToStdout (
	HTPresentation *	pres GCC_UNUSED,
	HTParentAnchor *	anchor,
	HTStream *		sink GCC_UNUSED)
d1329 1
a1329 1
unsigned long LYVMS_FixedLengthRecords (char * filename)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 8
a9 8
 *		===========
 *
 *	This version of the stream object just writes to a C file.
 *	The file is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */
d20 4
a27 1
#include <HTInit.h>
d44 4
a47 3
/* contains the name of the temp file which is being downloaded into */
char *WWW_Download_File = NULL;
BOOLEAN LYCancelDownload = FALSE;	/* exported to HTFormat.c in libWWW */
d50 2
a51 3
static char *FIXED_RECORD_COMMAND = NULL;

#ifdef USE_COMMAND_FILE		/* Keep this as an option. - FM    */
d55 1
a55 1
unsigned long LYVMS_FixedLengthRecords(char *filename);
d59 4
a62 3
HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink);
d65 2
a66 2
 *	-------------
 */
d68 1
a68 1
    const HTStreamClass *isa;
d70 8
a77 8
    FILE *fp;			/* The file we've opened */
    char *end_command;		/* What to do on _free.  */
    char *remove_command;	/* What to do on _abort. */
    char *viewer_command;	/* Saved external viewer */
    HTFormat input_format;	/* Original pres->rep     */
    HTFormat output_format;	/* Original pres->rep_out */
    HTParentAnchor *anchor;	/* Original stream's anchor. */
    HTStream *sink;		/* Original stream's sink.   */
d79 1
a79 1
    BOOLEAN idash;		/* remember position to become '.' */
d83 1
d85 5
a89 5
 *
 *			A C T I O N	R O U T I N E S
 *  Bug:
 *	All errors are ignored.
 */
d92 3
a94 3
 *	------------------
 */
static void HTFWriter_put_character(HTStream *me, char c)
d102 5
a106 5
 *	---------------
 *
 *	Strings must be smaller than this buffer size.
 */
static void HTFWriter_put_string(HTStream *me, const char *s)
d114 3
a116 3
 *	------------
 */
static void HTFWriter_write(HTStream *me, const char *s, int l)
d123 3
d127 7
a133 7
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created
 *	object is not,
 *	as it takes on an existence of its own unless explicitly freed.
 */
static void HTFWriter_free(HTStream *me)
a140 1

d149 1
a149 1
    if (me->end_command) {	/* Temp file */
d153 4
a156 4
	    /*
	     * It's a binary file saved to disk on VMS, which
	     * we want to convert to fixed records format.  - FM
	     */
d165 1
a165 1
		/* NEVER REMOVE THE FILE unless during an abort! */
d172 2
a173 2
	     * It's a compressed file supposedly cached to
	     * a temporary file for uncompression.  - FM
a176 1

d178 2
a179 2
		 * Save the path with the "gz" or "Z" suffix trimmed,
		 * and remove any previous uncompressed copy.  - FM
d183 1
a183 1
		    !strcasecomp(&path[len - 2], "gz")) {
d190 1
a190 1
			path[len - 3] = '\0';
d193 1
a193 1
		} else if (len > 4 && !strcasecomp(&path[len - 3], "bz2")) {
d200 1
a200 1
			path[len - 4] = '\0';
d203 2
a204 2
		} else if (len > 2 && !strcasecomp(&path[len - 1], "Z")) {
		    path[len - 2] = '\0';
d210 1
a210 1
			 * Tell user what's happening.  - FM
d215 1
a215 1
		     * Uncompress it.  - FM
d223 2
a224 2
		     * It's still there with the "gz" or "Z" suffix,
		     * so the uncompression failed.  - FM
d235 3
a237 3
		     * Succeeded!  Create a complete address
		     * for the uncompressed file and invoke
		     * HTLoadFile() to handle it.  - FM
d241 4
a244 4
		     * Assuming we have just uncompressed e.g.
		     * FILE-mpeg.gz -> FILE-mpeg, restore/shorten
		     * the name to be fit for passing to an external
		     * viewer, by renaming FILE-mpeg -> FILE.mpe - kw
a248 1

a250 1

d264 1
a264 1
		    LYLocalFileToURL(&addr, path);
d273 3
a275 3
			 * Lock the chartrans info we may possibly have,
			 * so HTCharsetFormat() will not apply the default
			 * for local files.  - KW
d278 1
a278 1
						 UCT_STAGE_PARSER) < 0) {
d280 1
a280 1
			     * If not yet set - KW
d285 1
a285 1
						     UCT_SETBY_DEFAULT + 1);
d292 2
a293 2
		     * Create a complete address for
		     * the uncompressed file.  - FM
d297 1
a297 1
			 * Tell user what's happening.  - FM
d304 11
a314 9
			 * It's a temporary file we're passing to a viewer or
			 * helper application.  Loading the temp file through
			 * HTLoadFile() would result in yet another HTStream
			 * (created with HTSaveAndExecute()) which would just
			 * copy the temp file to another temp file (or even the
			 * same!).  We can skip this needless duplication by
			 * using the viewer_command which has already been
			 * determined when the HTCompressed stream was created. 
			 * - kw
d323 1
a323 1
			     * Tell user what's happening.  - FM
d336 1
a336 1
			    /* NEVER REMOVE THE FILE unless during an abort!!! */
d350 4
a353 4
			status = HTLoadFile(addr,
					    me->anchor,
					    me->output_format,
					    me->sink);
d369 1
a369 1
		/* NEVER REMOVE THE FILE unless during an abort!!! */
d374 2
a375 2
	     * It's a temporary file we're passing to a viewer or helper
	     * application.  - FM
d379 1
a379 1
		 * Tell user what's happening.  - FM
d393 1
a393 1
		/* NEVER REMOVE THE FILE unless during an abort!!! */
d408 2
a409 1
	     * It's a file we saved to disk for handling via a menu.  - FM
d412 1
a412 1
		/* NEVER REMOVE THE FILE unless during an abort!!! */
d436 2
a437 1
	 * We want to save cookies picked up when in source mode.  ...
d456 5
a460 3
 *	-------------
 */
static void HTFWriter_abort(HTStream *me, HTError e GCC_UNUSED)
d462 1
a462 1
    CTRACE((tfp, "HTFWriter_abort called\n"));
d465 1
a465 1
    if (me->end_command) {	/* Temp file */
d472 1
a472 1
	    chmod(me->remove_command, 0600);	/* Ignore errors */
d492 3
a494 3
 *	-----------------------
 */
static const HTStreamClass HTFWriter =	/* As opposed to print etc */
d496 5
a500 5
    "FileWriter",
    HTFWriter_free,
    HTFWriter_abort,
    HTFWriter_put_character, HTFWriter_put_string,
    HTFWriter_write
d504 3
a506 3
 *	-------------------------
 */
HTStream *HTFWriter_new(FILE *fp)
d508 1
a508 1
    HTStream *me;
d527 9
d537 8
a544 7
 *	---------------------------------
 *
 *	See mailcap spec for description of template.
 */
static char *mailcap_substitute(HTParentAnchor *anchor,
				HTPresentation *pres,
				char *fnam)
d546 55
a600 4
    char *result = LYMakeMailcapCommand(pres->command,
					anchor->content_type_params,
					fnam);

d603 1
a603 1
    if (!LYMailcapUsesPctS(pres->command)) {
d606 2
a607 3

	HTSprintf(&prepend, "( %s", result);	/* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam);	/* ...to quote if needed */
d616 12
a627 11
 *	----------------------------------
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Creates temporary file, writes to it, executes system command
 *	on end-document.  The suffix of the temp file can be given
 *	in case the application is fussy, or so that a generic opener can
 *	be used.
 */
HTStream *HTSaveAndExecute(HTPresentation *pres,
			   HTParentAnchor *anchor,
			   HTStream *sink)
d631 1
a631 1
    HTStream *me;
d635 1
a635 1
	return (NULL);
d638 1
a638 1
    if (pres->quality == 999.0) {	/* exec link */
d641 1
a641 1
	    return (NULL);
d650 1
a650 1
		 !strncmp(anchor->address, "file://localhost", 16))) {
d667 1
a667 1
	return (HTSaveToFile(pres, anchor, sink));
d680 6
a685 6
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
d690 1
a690 1
	if (!strncmp(anchor->address, "file://localhost", 16)) {
d704 1
a704 1
	    if (strchr(view_fname, ':') == NULL) {
d734 2
a735 2
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
d741 2
d745 2
a746 6
		   || *suffix != '.') {
	    if (!strncasecomp(pres->rep->name, "application/", 12)) {
		suffix = BIN_SUFFIX;
	    } else {
		suffix = HTML_SUFFIX;
	    }
d759 1
a759 1
     * Make command to process file.
d764 1
a764 1
     * Make command to delete file.
d774 1
d776 2
a777 2
 *	-------------------------------------
 */
d782 13
a794 12
 *	--------------------
 *
 *	usually a binary file that can't be displayed
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Asks the user if he wants to continue, creates a temporary
 *	file, and writes to it.  In HTSaveToFile_Free
 *	the user will see a list of choices for download
 */
HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
d796 1
a796 1
    HTStream *ret_obj;
d798 1
a798 1
    const char *suffix;
a803 1

d815 1
a815 1
	ret_obj->fp = stdout;	/* stdout */
d832 1
a832 1
	    return (NULL);
d836 1
a836 1
	    strstr((cp + 1), "charset") != NULL) {
d838 1
a838 1
	} else if (*(pres->rep->name) != '\0') {
d848 2
a849 2
	     * 'C'ancel on Control-C or Control-Y and
	     * a 'N'o to the "really exit" query.  - FM
d859 1
a859 1
	 * Cancel on 'C', 'c' or Control-G or Control-C.
d865 1
a865 1
	    return (NULL);
d870 1
a870 1
     * Set up a 'D'ownload.
d873 6
a878 6
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
d883 2
a884 2
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
d894 1
a894 1
		   || *suffix != '.') {
d906 3
a908 3
    if (0 == strncasecomp(pres->rep->name, "text/", 5) ||
	0 == strcasecomp(pres->rep->name, "application/postscript") ||
	0 == strcasecomp(pres->rep->name, "application/x-RUNOFF-MANUAL"))
d910 3
a912 2
	 * It's a text file requested via 'd'ownload.  Keep adding others to
	 * the above list, 'til we add a configurable procedure.  - FM
d917 5
a921 4
     * Any "application/foo" or other non-"text/foo" types that are actually
     * text but not checked, above, will be treated as binary, so show the type
     * to help sort that out later.  Unix folks don't need to know this, but
     * we'll show it to them, too.  - FM
d925 1
a925 1
    StrAllocCopy(WWW_Download_File, fnam);
d928 1
a928 1
     * Make command to delete file.
d943 1
a943 1
	StrAllocCopy(ret_obj->end_command, "SaveToFile");
d951 1
a951 1
  Prepend_BASE:
d956 6
a961 6
	 * Add the document's base as a BASE tag at the top of the file, so
	 * that any partial or relative URLs within it will be resolved
	 * relative to that if no BASE tag is present and replaces it.  Note
	 * that the markup will be technically invalid if a DOCTYPE
	 * declaration, or HTML or HEAD tags, are present, and thus the file
	 * may need editing for perfection.  - FM
d963 1
a963 1
	 * Add timestamp (last reload).
d983 1
a983 1
		    "<!-- Date: %s -->\n", anchor->date);
d985 2
a986 3
		&& strcmp(anchor->last_modified, anchor->date)
		&& strcmp(anchor->last_modified,
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
d988 1
a988 1
			"<!-- Last-Modified: %s -->\n", anchor->last_modified);
d999 7
a1005 6
	 * Add the document's charset as a META CHARSET tag at the top of the
	 * file, so HTTP charset header will not be forgotten when a document
	 * saved as local file.  We add this line only(!) if HTTP charset
	 * present.  - LP Note that the markup will be technically invalid if a
	 * DOCTYPE declaration, or HTML or HEAD tags, are present, and thus the
	 * file may need editing for perfection.  - FM
d1013 2
a1014 2
		    "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		    temp);
d1022 6
a1027 5
 *	-------------------------------
 */
HTStream *HTCompressed(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
d1029 1
a1029 1
    HTStream *me;
d1044 3
a1046 2
     * Deal with any inappropriate invocations of this function, or a download
     * request, in which case we won't bother to uncompress the file.  - FM
d1050 2
a1051 2
	 * We have no idea what we're dealing with, so treat it as a binary
	 * stream.  - FM
d1059 1
a1059 1
	Pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
d1063 1
a1063 1
	     * We have a presentation mapping for it.  - FM
d1068 1
a1068 1
		(program = HTGetProgramPath(ppGZIP)) != NULL) {
d1070 1
a1070 1
		 * It's compressed with the modern gzip.  - FM
d1089 1
a1089 1
		 * It's compressed the old fashioned Unix way.  - FM
d1099 3
a1101 3
    if (can_present == FALSE ||	/* no presentation mapping */
	uncompress_mask == NULL ||	/* not gzip or compress */
	strchr(anchor->content_type, ';') ||	/* wrong charset */
d1104 1
a1104 1
	(traversal &&		/* only handle html or plain text for traversals */
d1108 2
a1109 2
	 * Cast the Content-Encoding to a Content-Type and pass it back to be
	 * handled as that type.  - FM
d1113 3
a1115 3
	     * Use "x-" prefix, none of the types we are likely to construct
	     * here are official.  That is we generate "application/x-gzip" and
	     * so on.  - kw
d1126 1
a1126 1
	FREE(type);
d1133 2
a1134 2
     * Set up the stream structure for uncompressing and then handling based on
     * the uncompressed Content-Type.- FM
d1149 1
a1149 1
     * Remove any old versions of the file.  - FM
d1157 1
a1157 1
     * Get a new temporary filename and substitute a suitable suffix.  - FM
d1186 1
a1186 1
	strcat(temp, "-");	/* NAME.html-gz, NAME.txt-gz, NAME.txt-Z etc. */
d1188 1
a1188 1
	strcat(temp, ".");	/* NAME-htm.gz (DOS), NAME.html.gz (UNIX)etc. */
d1194 1
a1194 1
     * Open the file for receiving the compressed input stream.  - FM
d1196 1
a1196 1
    me->fp = LYOpenTemp(fnam, temp, BIN_W);
d1205 4
a1208 4
     * me->viewer_command will be NULL if the converter Pres found above is not
     * for an external viewer but an internal HTStream converter.  We also
     * don't set it under conditions where HTSaveAndExecute would disallow
     * execution of the command.  - KW
d1217 1
a1217 1
		!strncmp(anchor->address, "file://localhost", 16))))))
d1224 1
a1224 1
     * Make command to process file.  - FM
d1237 2
a1238 2
	if (compress_suffix[0] == 'g'	/* must be gzip */
	    && !me->viewer_command) {
d1254 1
a1254 1
     * Make command to delete file.  - FM
d1261 1
a1261 1
     * Save the filename and return the structure.  - FM
d1268 7
a1274 6
 *	---------------------
 *
 */
HTStream *HTDumpToStdout(HTPresentation *pres GCC_UNUSED,
			 HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
d1276 1
a1276 2
    HTStream *ret_obj;

a1277 1

d1285 1
a1285 1
    ret_obj->fp = stdout;	/* stdout */
d1299 1
a1299 1
#define FCH$V_CONTIGB	0x005	/* pos of cont best try bit */
d1303 8
a1310 8
    unsigned char fat$b_rtype, fat$b_rattrib;
    unsigned short fat$w_rsize;
    unsigned long fat$l_hiblk, fat$l_efblk;
    unsigned short fat$w_ffbyte;
    unsigned char fat$b_bktsize, fat$b_vfcsize;
    unsigned short fat$w_maxrec, fat$w_defext, fat$w_gbc;
    unsigned:16,:32,:16;	/* 6 bytes reserved, 2 bytes not used */
    unsigned short fat$w_versions;
d1315 1
a1315 4
typedef struct dsc {
    unsigned short len, mbz;
    void *adr;
} Desc;
d1317 1
a1317 1
extern unsigned long sys$open(), sys$qiow(), sys$dassgn();
d1322 1
d1324 1
a1324 1
 * 25-Jul-1995 - Pat Rankin (rankin@@eql.caltech.edu)
d1326 2
a1327 2
 * Force a file to be marked as having fixed-length, 512 byte records
 * without implied carriage control, and with best_try_contiguous set.
d1329 1
a1329 1
unsigned long LYVMS_FixedLengthRecords(char *filename)
d1331 8
a1338 8
    struct FAB fab;		/* RMS file access block */
    struct fibdef fib;		/* XQP file information block */
    struct fatdef recattr;	/* XQP file "record" attributes */
    struct atrdef attr_rqst_list[3];	/* XQP attribute request itemlist */

    Desc fib_dsc;
    unsigned short channel, iosb[4];
    unsigned long fchars, sts, tmp;
d1355 1
a1355 2
    if (sysfail(sts))
	return sts;
d1366 1
a1366 1
    memset((void *) &fib, 0, sizeof fib);
d1370 1
a1370 1
    *(void **) &attr_rqst_list[0].atr$l_addr = (void *) &recattr;
d1373 1
a1373 1
    *(void **) &attr_rqst_list[1].atr$l_addr = (void *) &fchars;
d1377 2
a1378 2
    memset((void *) &recattr, 0, sizeof recattr);
    fchars = 0;			/* file characteristics */
d1381 1
a1381 1
    sts = sys$qiow(0, channel, IO$_ACCESS, iosb, (void (*)()) 0, 0,
d1389 4
a1392 4
	recattr.fat$w_rsize = recattr.fat$w_maxrec = 512;	/* lrl=mrs=512 */
	recattr.fat$b_rattrib = 0;	/* rat=none */
	fchars |= FCH$M_CONTIGB;	/* contiguous-best-try */
	sts = sys$qiow(0, channel, IO$_DEACCESS, iosb, (void (*)()) 0, 0,
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d98 2
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d175 1
a175 2
		    (!strcasecomp(&path[len - 2], "gz") ||
		     !strcasecomp(&path[len - 2], "zz"))) {
d893 1
a893 1
	if (non_empty(anchor->content_base)) {
d895 1
a895 1
	} else if (non_empty(anchor->content_location)) {
d907 1
a907 1
	if (non_empty(anchor->date)) {
d910 1
a910 1
	    if (non_empty(anchor->last_modified)
d935 1
a935 1
	if (non_empty(anchor->charset)) {
a957 1
    HTPresentation *Pnow = NULL;
d962 1
d983 3
a985 16
	Pnow = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (!strcasecomp(Pnow->rep->name, anchor->content_type) &&
	    Pnow->rep_out == WWW_PRESENT) {
	    const char *program = "";

	    /*
	     * Pick the best presentation.  User-defined mappings are at the
	     * end of the list, and unless the quality is lower, we prefer
	     * those.
	     */
	    if (Pres == 0)
		Pres = Pnow;
	    else if (Pres->quality > Pnow->quality)
		continue;
	    else
		Pres = Pnow;
d990 9
a998 10
	    switch (HTEncodingToCompressType(anchor->content_encoding)) {
	    case cftGzip:
		if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		    /*
		     * It's compressed with the modern gzip.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d --no-name %s");
		    compress_suffix = "gz";
		}
d1000 7
a1006 9
	    case cftDeflate:
		if ((program = HTGetProgramPath(ppINFLATE)) != NULL) {
		    /*
		     * It's compressed with a zlib wrapper.
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "zz";
		}
d1008 10
a1017 18
	    case cftBzip2:
		if ((program = HTGetProgramPath(ppBZIP2)) != NULL) {
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d %s");
		    compress_suffix = "bz2";
		}
		break;
	    case cftCompress:
		if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
		    /*
		     * It's compressed the old fashioned Unix way.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "Z";
		}
		break;
	    case cftNone:
d1020 1
a1089 1
	/* FIXME: why is this BEFORE HTFileSuffix? */
a1160 1
	/* FIXME: allow deflate here, e.g., 'z' */
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a15 8
#ifdef WIN_EX
#include <HTParse.h>
#endif

#if _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

a26 1
#include <LYExtern.h>
a30 4
#ifdef EXP_PERSISTENT_COOKIES 
#include <LYCookie.h>
#endif

d83 1
a83 3
    if (me->fp) {
	putc(c, me->fp);
    }
d93 1
a93 3
    if (me->fp) {
	fputs(s, me->fp);
    }
d101 1
a101 3
    if (me->fp) {
	fwrite(s, 1, l, me->fp);
    }
d116 1
a121 6
    BOOLEAN found = FALSE;
#ifdef WIN_EX
    HANDLE cur_handle;

    cur_handle = GetForegroundWindow();
#endif
d123 1
a123 2
    if (me->fp)
	fflush(me->fp);
d151 1
a151 1
		BOOL skip_loadfile = (BOOL) (me->viewer_command != NULL);
d157 5
a161 2
		if ((len = strlen(path)) > 3 &&
		    !strcasecomp(&path[len-2], "gz")) {
d163 3
a165 3
		    if (!skip_loadfile) {
			use_gzread = YES;
		    } else
d167 6
a172 2
		    {
			path[len-3] = '\0';
a174 8
#ifdef BZIP2_PATH
		} else if (len > 4 && !strcasecomp(&path[len-3], "bz2")) {
		    path[len-4] = '\0';
		    remove(path);
#endif /* BZIP2_PATH */
		} else if (len > 2 && !strcasecomp(&path[len-1], "Z")) {
		    path[len-2] = '\0';
		    remove(path);
d188 1
a188 1
		    found = LYCanReadFile(me->anchor->FileCache);
d190 1
a190 1
		if (found) {
d195 2
d199 1
a199 1
			LYrefresh();
d202 1
a202 1
		    LYRemoveTemp(me->anchor->FileCache);
a296 1
#ifndef WIN_EX
a297 1
#endif
a298 3
#if _WIN_CC
			exec_command(me->end_command, FALSE);
#else
d300 1
a300 1
#endif
d305 1
a305 7
			if (!dump_output_immediately) {
#ifdef WIN_EX
			    if (focus_window) {
				HTInfoMsg("Set focus1");
				status = SetForegroundWindow(cur_handle);
			    }
#else
a306 2
#endif
			}
a339 1
#ifndef WIN_EX
a340 1
#endif
a341 3
#if _WIN_CC
	    exec_command(me->end_command, FALSE);
#else
a342 1
#endif
d348 1
a348 7
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg("Set focus2");
		    status = SetForegroundWindow(cur_handle);
		}
#else
a349 2
#endif
	    }
a358 10
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg("Set focus3");
		    status = SetForegroundWindow(cur_handle);
		}
#else
	        start_curses();
#endif
	    }
d368 1
a368 9
#ifdef EXP_PERSISTENT_COOKIES 
	/* 
	 *  We want to save cookies picked up when in source 
	 *  mode.  ... 
	 */ 
	if (persistent_cookies) 
	    LYStoreCookies(LYCookieSaveFile); 
#endif /* EXP_PERSISTENT_COOKIES */ 
	exit_immediately(EXIT_SUCCESS);
d382 1
a382 1
    CTRACE((tfp,"HTFWriter_abort called\n"));
d386 1
a386 1
	CTRACE((tfp, "HTFWriter: Aborting: file not executed or saved.\n"));
d421 1
a421 1
    me = typecalloc(HTStream);
a434 9
PRIVATE void chrcat ARGS2(
	char *,		result,
	int,		ch)
{
    result += strlen(result);
    *result++ = (char)ch;
    *result = 0;
}

a439 73
PRIVATE char *mailcap_substitute ARGS3(
	HTParentAnchor *,	anchor,
	HTPresentation *,	pres,
	char *,			fnam)
{
    int pass;
    int skip;
    size_t need = 0;
    char *result = 0;
    char *s;
    char *repl;

    for (pass = 0; pass < 2; pass++) {
	for (s = pres->command; *s; s++) {
	    if (*s == '%') {
		repl = 0;
		skip = 0;
		if (s[1] == 't') {
		    repl = pres->rep->name;
		    skip = 1;
		} else if (s[1] == 's') {
		    repl = fnam;
		    skip = 1;
		} else if (!strncasecomp(s+1, "{charset}", 9)) {
		    repl = anchor->charset;
		    skip = 9;
		} else if (!strncasecomp(s+1, "{encoding}", 10)) {
		    repl = anchor->content_encoding;
		    skip = 10;
		}
		if (skip != 0) {
		    if (repl == 0)
			repl = "";
		    if (pass) {
			strcat(result, repl);
		    } else {
			need += strlen(repl);
		    }
		    s += skip;
		} else {
		    if (pass) {
			chrcat(result, *s);
		    } else {
			need++;
		    }
		}
	    } else {
		if (pass) {
		    chrcat(result, *s);
		} else {
		    need++;
		}
	    }
	}
	if (pass == 0) {
	    if ((result = malloc(need + 1)) == 0)
		outofmem(__FILE__, "mailcap_substitute");
	    *result = 0;
	}
    }
#if defined(UNIX)
    /* if we don't have a "%s" token, expect to provide the file via stdin */
    if (strstr(pres->command, "%s") == 0) {
	char *prepend = 0;
	char *format = "( %s ) < %s";
	HTSprintf(&prepend, "( %s", pres->command); /* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam); /* ...to quote if needed */
	FREE(result);
	result = prepend;
    }
#endif
    return result;
}
d469 1
d480 1
a480 1
	if (!local_exec) {
a484 1
		;
a493 1
	}
d501 1
a501 1
    me = typecalloc(HTStream);
d511 1
a511 8
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The ".bin" suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
	 */
	me->fp = LYOpenTempRewrite(fnam, ".bin", BIN_W);
a512 44
#if defined(WIN_EX) && !defined(__CYGWIN__)	/* 1998/01/04 (Sun) */
	if (!strncmp(anchor->address,"file://localhost",16)) {

	    /* 1998/01/23 (Fri) 17:38:26 */
	    unsigned char *cp, *view_fname;

#define IS_SJIS_HI1(hi) ((0x81<=hi)&&(hi<=0x9F))	/* 1st lev. */
#define IS_SJIS_HI2(hi) ((0xE0<=hi)&&(hi<=0xEF))	/* 2nd lev. */

	    me->fp = NULL;

	    view_fname = fnam + 3;
	    LYstrncpy(view_fname, anchor->address + 17, sizeof(fnam) - 5);
	    HTUnEscape(view_fname);

	    if (strchr(view_fname, ':')==NULL) {
		fnam[0] = windows_drive[0];
		fnam[1] = windows_drive[1];
		fnam[2] = '/';
		view_fname = fnam;
	    }

	    /* 1998/04/21 (Tue) 11:04:16 */
	    cp = view_fname;
	    while (*cp) {
		if (IS_SJIS_HI1(*cp) || IS_SJIS_HI2(*cp)) {
		    cp += 2;
		    continue;
		} else if (*cp == '/') {
		    *cp = '\\';
		}
		cp++;
	    }
	    if (strchr(view_fname, ' '))
		view_fname = (unsigned char *) quote_pathname(view_fname);

	    StrAllocCopy(me->viewer_command, pres->command);

	    me->end_command = mailcap_substitute(anchor, pres, view_fname);
	    me->remove_command = NULL;

	    return me;
	}
#endif
d524 2
a525 4
	} else if (
	(suffix = HTFileSuffix(pres->rep, anchor->content_encoding)) == 0
		   || *suffix != '.')
	{
d528 1
a528 1
	me->fp = LYOpenTemp(fnam, suffix, BIN_W);
d541 3
a543 1
    me->end_command = mailcap_substitute(anchor, pres, fnam);
d585 1
a585 1
    ret_obj = typecalloc(HTStream);
d617 1
a617 1
	if (((cp = strchr(pres->rep->name, ';')) != NULL) &&
d626 2
a627 2
	while (c != 'D' && c != 'C' && !LYCharIsINTERRUPT(c)) {
	    c = LYgetch_single();
d643 1
a643 1
	if (c == 'C' || LYCharIsINTERRUPT(c)) {
d655 1
a655 8
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The ".bin" suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
	 */
	ret_obj->fp = LYOpenTempRewrite(fnam, ".bin", BIN_W);
d673 1
a673 1
	ret_obj->fp = LYOpenTemp(fnam, suffix, BIN_W);
d757 2
a758 2
	if (anchor->date && *anchor->date) {
	    fprintf(ret_obj->fp,
a759 7
	    if (anchor->last_modified && *anchor->last_modified
			&& strcmp(anchor->last_modified, anchor->date)
			&& strcmp(anchor->last_modified, "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(ret_obj->fp,
		    "<!-- Last-Modified: %s -->\n", anchor->last_modified);
	    }
	}
d810 1
d835 6
a840 1
	    if (!strcasecomp(anchor->content_encoding, "x-gzip") ||
a847 7
#ifdef BZIP2_PATH
	    } else if (!strcasecomp(anchor->content_encoding, "x-bzip2") ||
		!strcasecomp(anchor->content_encoding, "bzip2")) {
		StrAllocCopy(uncompress_mask, BZIP2_PATH);
		StrAllocCat(uncompress_mask, " -d %s");
		compress_suffix = "bz2";
#endif /* BZIP2_PATH */
d873 1
a873 9
	    /*
	     *  Use "x-" prefix, none of the types we are likely to
	     *  construct here are official.  That is we generate
	     *  "application/x-gzip" and so on. - kw
	     */
	    if (!strncasecomp(anchor->content_encoding, "x-", 2))
		StrAllocCopy(type, "application/");
	    else
		StrAllocCopy(type, "application/x-");
d889 1
a889 1
    me = typecalloc(HTStream);
d905 4
a908 1
	LYRemoveTemp(anchor->FileCache);
d953 1
a953 1
    me->fp = LYOpenTemp (fnam, temp, BIN_W);
d1024 1
a1024 1
    ret_obj = typecalloc(HTStream);
@

