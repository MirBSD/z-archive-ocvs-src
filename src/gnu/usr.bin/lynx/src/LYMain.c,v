head	1.20;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.19
	tg-mergefixes-1-branch:1.19.0.4
	tg-mergefixes-1-base:1.19
	MIROS_X:1.19.0.2
	MIROS_X_BASE:1.19
	MIRBSD_XP_MIRPPC:1.16.0.4
	lynx-2_8_6dev_7b:1.1.3.9
	lynx-2_8_6dev_6:1.1.3.8
	MIRBSD_XP_SPARC_BASE:1.16
	MIRBSD_XP_SPARC:1.16.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.7
	lynx-2_8_6dev_5:1.1.3.6
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.11
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.5
	lynx-2_8_5:1.1.3.4
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.3
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.11.0.6
	MIRBSD_7:1.11.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.11
	MIRBSD_7_DEV:1.11.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2005.01.03.00.45.59;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.05.13.24.39;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.20.10.26.28;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.11.20.30.41;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.23.05.43.53;	author tg;	state Stab;
branches;
next	1.15;

1.15
date	2004.07.15.18.16.58;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.30.16.32.35;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.08.19.48.59;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.18.16.56.16;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.27.13.12.45;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.18.21.35.56;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.18.20.06.25;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.01.18.51.55;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.01.18.49.53;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.07.20.31.17;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.07.20.00.29;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.19.55.45;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.36;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.32;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.25;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.07;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.19;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.46.06;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.01.18.15.34.41;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.02.08.13.10.52;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.04.30.16.15.58;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.07.15.15.52.32;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.07.15.16.05.48;	author tg;	state Exp;
branches;
next	1.1.3.8;

1.1.3.8
date	2004.10.11.20.16.25;	author tg;	state Exp;
branches;
next	1.1.3.9;

1.1.3.9
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.20
log
@soft merge
@
text
@/**	$MirBSD: src/gnu/usr.bin/lynx/src/LYMain.c,v 1.19 2004/12/05 13:24:39 tg Exp $ */

/*-
 * Copyright (c) 2002, 2003, 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
 *-
 * These are patches to the Lynx web browser, which is licensed under
 * the GNU General Public License, Version 2.
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTParse.h>
#include <HTAccess.h>
#include <HTList.h>
#include <HTFile.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <HTInit.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <LYStyle.h>
#include <HTML.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYOptions.h>
#include <LYSignal.h>
#include <LYGetFile.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYReadCFG.h>
#include <LYrcFile.h>
#include <LYKeymap.h>
#include <HTForms.h>
#include <LYList.h>
#include <LYJump.h>
#include <LYMainLoop.h>
#include <LYBookmark.h>
#include <LYCookie.h>
#include <LYPrettySrc.h>
#include <LYShowInfo.h>
#include <LYHistory.h>

#ifdef VMS
#include <HTFTP.h>
#endif /* !DECNET */

#ifdef __DJGPP__
#include <dos.h>
#include <dpmi.h>
#include <io.h>
#include <sys/stat.h>
#include <sys/exceptn.h>
#endif /* __DJGPP__ */

#ifdef __EMX__
#include <io.h>
#endif

#ifdef LOCALE
#undef gettext			/* Solaris locale.h prototypes gettext() */
#include <locale.h>
#ifndef HAVE_GETTEXT
#define gettext(s) s
#endif
#endif /* LOCALE */

#include <LYexit.h>
#include <LYLeaks.h>

#ifdef FNAMES_8_3
#define COOKIE_FILE "cookies"
#define TRACE_FILE "LY-TRACE.LOG"
#else
#define COOKIE_FILE ".etc/cookies.txt"
#define TRACE_FILE "Lynx.trace"
#endif /* FNAMES_8_3 */

/* ahhhhhhhhhh!! Global variables :-< */
#ifdef SOCKS
BOOLEAN socks_flag = TRUE;
#endif /* SOCKS */

#ifdef IGNORE_CTRL_C
BOOLEAN sigint = FALSE;
#endif /* IGNORE_CTRL_C */

#ifdef __DJGPP__
static char init_ctrl_break[1];
#endif /* __DJGPP__ */

#if USE_VMS_MAILER
char *mail_adrs = NULL;		/* the mask for a VMS mail transport */
#endif

#ifdef VMS
	       /* create FIXED 512 binaries */
BOOLEAN UseFixedRecords = USE_FIXED_RECORDS;
#endif /* VMS */

#ifndef VMS
static char *lynx_version_putenv_command = NULL;
char *list_format = NULL;	/* LONG_LIST formatting mask */
#endif /* !VMS */

#ifdef SYSLOG_REQUESTED_URLS
char *syslog_txt = NULL;	/* syslog arb text for session */
BOOLEAN syslog_requested_urls = TRUE;
#endif

#ifdef DIRED_SUPPORT
BOOLEAN lynx_edit_mode = FALSE;
BOOLEAN no_dired_support = FALSE;
HTList *tagged = NULL;
int LYAutoUncacheDirLists = 2;	/* default dired uncaching behavior */
int dir_list_order = ORDER_BY_NAME;
int dir_list_style = MIXED_STYLE;

#ifdef OK_OVERRIDE
BOOLEAN prev_lynx_edit_mode = FALSE;
#endif /* OK_OVERRIDE */

#ifdef OK_PERMIT
#ifdef NO_CHANGE_EXECUTE_PERMS
BOOLEAN no_change_exec_perms = TRUE;

#else
BOOLEAN no_change_exec_perms = FALSE;
#endif /* NO_CHANGE_EXECUTE_PERMS */
#endif /* OK_PERMIT */

#endif /* DIRED_SUPPORT */

	   /* Number of docs cached in memory */
int HTCacheSize = DEFAULT_CACHE_SIZE;

#if defined(VMS) && defined(VAXC) && !defined(__DECC)
	   /* Don't dump doc cache unless this size is exceeded */
int HTVirtualMemorySize = DEFAULT_VIRTUAL_MEMORY_SIZE;
#endif /* VMS && VAXC && !_DECC */

#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
#ifndef NEVER_ALLOW_REMOTE_EXEC
BOOLEAN local_exec = LOCAL_EXECUTION_LINKS_ALWAYS_ON;

#else
BOOLEAN local_exec = FALSE;
#endif /* NEVER_ALLOW_REMOTE_EXEC */
BOOLEAN local_exec_on_local_files =
LOCAL_EXECUTION_LINKS_ON_BUT_NOT_REMOTE;
#endif /* EXEC_LINKS || EXEC_SCRIPTS */

#if defined(LYNXCGI_LINKS) && !defined(VMS)	/* WebSter Mods -jkt */
char *LYCgiDocumentRoot = NULL;	/* DOCUMENT_ROOT in the lynxcgi env */
#endif /* LYNXCGI_LINKS */

#ifdef REVERSE_CLEAR_SCREEN_PROBLEM
BOOLEAN enable_scrollback = TRUE;

#else
BOOLEAN enable_scrollback = FALSE;
#endif /* REVERSE_CLEAR_SCREEN_PROBLEM */

char empty_string[] =
{'\0'};

int display_lines;		/* number of lines in display */
int www_search_result = -1;

			       /* linked list of printers */
lynx_list_item_type *printers = NULL;

			    /* linked list of download options */
lynx_list_item_type *downloaders = NULL;

			    /* linked list of upload options */
#ifdef USE_EXTERNALS
lynx_list_item_type *externals = NULL;

			    /* linked list of external options */
#endif

lynx_list_item_type *uploaders = NULL;
int LYShowColor = SHOW_COLOR_UNKNOWN;	/* to show or not */
int LYrcShowColor = SHOW_COLOR_UNKNOWN;		/* ... last used */

#if !defined(NO_OPTION_FORMS) && !defined(NO_OPTION_MENU)
BOOLEAN LYUseFormsOptions = TRUE;	/* use forms-based options menu */
#endif

BOOLEAN LYJumpFileURL = FALSE;	/* always FALSE the first time */
BOOLEAN LYPermitURL = FALSE;
BOOLEAN LYRestricted = FALSE;	/* whether we have -anonymous option */
BOOLEAN LYShowCursor = SHOW_CURSOR;	/* to show or not to show */
BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS;	/* Show the links underlined vs bold */
BOOLEAN LYUseDefShoCur = TRUE;	/* Command line -show_cursor toggle */
BOOLEAN LYUserSpecifiedURL = TRUE;	/* always TRUE  the first time */
BOOLEAN LYValidate = FALSE;
BOOLEAN LYforce_no_cache = FALSE;
BOOLEAN LYinternal_flag = FALSE;	/* override no-cache b/c internal link */
BOOLEAN LYoverride_no_cache = FALSE;	/*override no-cache b/c history etc */
BOOLEAN LYresubmit_posts = ALWAYS_RESUBMIT_POSTS;
BOOLEAN LYtrimInputFields = FALSE;
BOOLEAN bold_H1 = FALSE;
BOOLEAN bold_headers = FALSE;
BOOLEAN bold_name_anchors = FALSE;
BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
BOOLEAN check_mail = CHECKMAIL;
BOOLEAN child_lynx = FALSE;
BOOLEAN dump_links_only = FALSE;
BOOLEAN dump_output_immediately = FALSE;
BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
BOOLEAN ftp_passive = FTP_PASSIVE;	/* TRUE if doing ftp in passive mode */
BOOLEAN ftp_local_passive;
char *ftp_lasthost;
BOOLEAN goto_buffer = GOTOBUFFER;	/* TRUE if offering default goto URL */
BOOLEAN historical_comments = FALSE;
BOOLEAN is_www_index = FALSE;
BOOLEAN jump_buffer = JUMPBUFFER;	/* TRUE if offering default shortcut */
BOOLEAN lynx_mode = NORMAL_LYNX_MODE;
BOOLEAN minimal_comments = FALSE;
BOOLEAN number_fields_on_left = TRUE;
BOOLEAN number_links_on_left = TRUE;
BOOLEAN recent_sizechange = FALSE;	/* the window size changed recently? */
BOOLEAN soft_dquotes = FALSE;
BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
BOOLEAN verbose_img = VERBOSE_IMAGES;	/* show filenames or not */
BOOLEAN vi_keys = VI_KEYS_ALWAYS_ON;
int keypad_mode = DEFAULT_KEYPAD_MODE;
int user_mode = NOVICE_MODE;

BOOLEAN telnet_ok = TRUE;

#ifndef DISABLE_NEWS
BOOLEAN news_ok = TRUE;
#endif
BOOLEAN rlogin_ok = TRUE;
BOOLEAN long_url_ok = FALSE;
BOOLEAN ftp_ok = TRUE;
BOOLEAN system_editor = FALSE;

BOOLEAN had_restrictions_default = FALSE;
BOOLEAN had_restrictions_all = FALSE;

BOOLEAN exec_frozen = FALSE;
BOOLEAN no_bookmark = FALSE;
BOOLEAN no_bookmark_exec = FALSE;
BOOLEAN no_chdir = FALSE;
BOOLEAN no_disk_save = FALSE;
BOOLEAN no_dotfiles = NO_DOT_FILES;
BOOLEAN no_download = FALSE;
BOOLEAN no_editor = FALSE;
BOOLEAN no_exec = FALSE;
BOOLEAN no_file_url = FALSE;
BOOLEAN no_goto = FALSE;
BOOLEAN no_goto_configinfo = FALSE;
BOOLEAN no_goto_cso = FALSE;
BOOLEAN no_goto_file = FALSE;
BOOLEAN no_goto_finger = FALSE;
BOOLEAN no_goto_ftp = FALSE;
BOOLEAN no_goto_gopher = FALSE;
BOOLEAN no_goto_http = FALSE;
BOOLEAN no_goto_https = FALSE;
BOOLEAN no_goto_lynxcgi = FALSE;
BOOLEAN no_goto_lynxexec = FALSE;
BOOLEAN no_goto_lynxprog = FALSE;
BOOLEAN no_goto_mailto = FALSE;
BOOLEAN no_goto_rlogin = FALSE;
BOOLEAN no_goto_telnet = FALSE;
BOOLEAN no_goto_tn3270 = FALSE;
BOOLEAN no_goto_wais = FALSE;
BOOLEAN no_inside_ftp = FALSE;
BOOLEAN no_inside_rlogin = FALSE;
BOOLEAN no_inside_telnet = FALSE;
BOOLEAN no_jump = FALSE;
BOOLEAN no_lynxcfg_info = FALSE;
BOOLEAN no_lynxcgi = FALSE;
BOOLEAN no_mail = FALSE;
BOOLEAN no_multibook = FALSE;
BOOLEAN no_option_save = FALSE;
BOOLEAN no_outside_ftp = FALSE;
BOOLEAN no_outside_rlogin = FALSE;
BOOLEAN no_outside_telnet = FALSE;
BOOLEAN no_print = FALSE;
BOOLEAN no_shell = FALSE;
BOOLEAN no_suspend = FALSE;
BOOLEAN no_telnet_port = FALSE;
BOOLEAN no_useragent = FALSE;

#ifndef DISABLE_NEWS
BOOLEAN no_goto_news = FALSE;
BOOLEAN no_goto_nntp = FALSE;
BOOLEAN no_goto_snews = FALSE;
BOOLEAN no_inside_news = FALSE;
BOOLEAN no_newspost = FALSE;
BOOLEAN no_outside_news = FALSE;
#endif

#ifdef USE_EXTERNALS
BOOLEAN no_externals = FALSE;
#endif

#ifndef NO_CONFIG_INFO
BOOLEAN no_lynxcfg_xinfo = FALSE;

#ifdef HAVE_CONFIG_H
BOOLEAN no_compileopts_info = FALSE;
#endif
#endif

BOOLEAN no_statusline = FALSE;
BOOLEAN no_filereferer = TRUE;
char LYRefererWithQuery = 'D';	/* 'D' for drop */
BOOLEAN local_host_only = FALSE;
BOOLEAN override_no_download = FALSE;
BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
BOOLEAN LYforce_HTML_mode = FALSE;
BOOLEAN LYfind_leaks = TRUE;

#ifdef __DJGPP__
BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
BOOLEAN dj_is_bash = FALSE;	/* Check for bash shell under DJGPP */
#endif /* __DJGPP__ */

#ifdef WIN_EX
BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
#endif

#ifdef _WINDOWS
#define	TIMEOUT	180		/* 1998/03/30 (Mon) 14:50:44 */
int lynx_timeout = TIMEOUT;
CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
#endif /* _WINDOWS */

#if defined(WIN_EX)
BOOLEAN system_is_NT = FALSE;
#endif

#ifdef SH_EX
BOOLEAN show_cfg = FALSE;
#endif

BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */

#if USE_BLAT_MAILER
BOOLEAN mail_is_blat = TRUE;
#endif

#ifdef USE_BLINK
#  ifdef __EMX__
BOOLEAN term_blink_is_boldbg = TRUE;

#  else
BOOLEAN term_blink_is_boldbg = FALSE;

#  endif
#endif

BOOLEAN HEAD_request = FALSE;
BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES;	/* take all cookies? */
BOOLEAN LYCancelledFetch = FALSE;	/* TRUE if cancelled binary fetch */
BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;	/* Collapse serial BRs? */
BOOLEAN LYDefaultRawMode;
BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
BOOLEAN LYNewsPosting = NEWS_POSTING;	/* News posting supported? */
BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?         */
BOOLEAN LYNoRefererForThis = FALSE;	/* No Referer header for this URL? */
BOOLEAN LYNoRefererHeader = FALSE;	/* Never send Referer header?     */
BOOLEAN LYRawMode;
BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
BOOLEAN LYSetCookies = SET_COOKIES;	/* Process Set-Cookie headers? */
BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
BOOLEAN LYUseDefaultRawMode = TRUE;
BOOLEAN LYUseMouse = FALSE;
BOOLEAN LYisConfiguredForX = FALSE;
BOOLEAN UCForce8bitTOUPPER = FALSE;	/* override locale for case-conversion? */
BOOLEAN UCSaveBookmarksInUnicode = FALSE;
BOOLEAN bookmark_start = FALSE;
BOOLEAN check_realm = FALSE;	/* Restrict to the starting realm? */
BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
BOOLEAN crawl = FALSE;		/* Do crawl? */
BOOLEAN keep_mime_headers = FALSE;	/* Include mime headers with source dump */
BOOLEAN more = FALSE;		/* is there more text to display? */
BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
BOOLEAN no_list = FALSE;
BOOLEAN no_url_redirection = FALSE;	/* Don't follow URL redirections */
BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
BOOLEAN scan_for_buried_news_references = TRUE;
BOOLEAN startfile_ok = FALSE;
static BOOLEAN startfile_stdin = FALSE;
BOOLEAN traversal = FALSE;	/* Do traversals? */

char *BookmarkPage = NULL;	/* the name of the current bookmark page */
char *LYCookieAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieLooseCheckDomains = NULL;		/* check loosely   */
char *LYCookieQueryCheckDomains = NULL;		/* check w/a query */
char *LYCookieRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieSLooseCheckDomains = NULL;	/* check loosely   */
char *LYCookieSQueryCheckDomains = NULL;	/* check w/a query */
char *LYCookieSRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSStrictCheckDomains = NULL;	/* check strictly  */
char *LYCookieStrictCheckDomains = NULL;	/* check strictly  */
char *LYHostName = NULL;	/* treat as a local host name */
char *LYLocalDomain = NULL;	/* treat as a local domain tail */
char *LYUserAgent = NULL;	/* Lynx User-Agent header          */
char *LYUserAgentDefault = NULL;	/* Lynx default User-Agent header  */
char *LynxHome = NULL;		/* the default Home HREF. */
char *LynxSigFile = NULL;	/* Signature file, in or off home */
char *UCAssume_MIMEcharset = NULL;
char *URLDomainPrefixes = NULL;
char *URLDomainSuffixes = NULL;
char *anonftp_password = NULL;	/* anonymous ftp password (default: email) */
char *authentication_info[2] =
{NULL, NULL};			/* Id:Password for protected documents */
char *bookmark_page = NULL;	/* the name of the default bookmark page */
char *editor = NULL;		/* the name of the current editor */
char *form_get_data = NULL;	/* User data for get form */
char *form_post_data = NULL;	/* User data for post form */
char *global_extension_map = NULL;	/* global mime.types */
char *global_type_map = NULL;	/* global mailcap */
char *helpfile = NULL;		/* the main help file */
char *helpfilepath = NULL;	/* the path to the help file set */
char *homepage = NULL;		/* home page or main screen */
char *http_error_file = NULL;	/* Place HTTP status code in this file */
char *indexfile = NULL;		/* an index file if there is one */
char *jumpfile = NULL;		/* the name of the default jumps file */
char *jumpprompt = NULL;	/* the default jumps prompt */
char *language = NULL;		/* preferred language */
char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
char *lynx_cmd_script;		/* file to read keystroke commands, if any */
char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
char *lynxjumpfile = NULL;	/* the current jump file URL */
char *lynxlinksfile = NULL;	/* the current visited links file URL */
char *lynxlistfile = NULL;	/* the current list file URL */
char *original_dir = NULL;	/* the original directory */
char *personal_extension_map = NULL;	/* .mime.types */
char *personal_mail_address = NULL;	/* the users mail address */
char *personal_type_map = NULL;	/* .mailcap */
char *pref_charset = NULL;	/* preferred character set */
char *proxyauth_info[2] =
{NULL, NULL};			/* Id:Password for protected proxy servers */
char *startfile = NULL;		/* the first file */
char *startrealm = NULL;	/* the startfile realm */
char *system_mail = NULL;	/* The path for sending mail */
char *system_mail_flags = NULL;	/* Flags for sending mail */
char *x_display = NULL;		/* display environment variable */

HistInfo *history;
int nhist = 0;			/* number of used history entries */
int size_history;		/* number of allocated history entries */

LinkInfo links[MAXLINKS];

int AlertSecs;			/* time-delay for HTAlert() messages   */
int DebugSecs;			/* time-delay for HTProgress messages */
int InfoSecs;			/* time-delay for Information messages */
int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
int LYStatusLine = -1;		/* Line for statusline() if > -1 */
int LYcols = DFT_COLS;
int LYlines = DFT_ROWS;
int MessageSecs;		/* time-delay for important Messages   */
int ReplaySecs;			/* time-delay for command-scripts */
int crawl_count = 0;		/* Starting number for lnk#.dat files in crawls */
int dump_output_width = 0;
int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
int max_cookies_domain = 50;
int max_cookies_global = 500;
int max_cookies_buffer = 4096;
int nlinks = 0;			/* number of links in memory */
int outgoing_mail_charset = -1;	/* translate mail to this charset */

#ifndef DISABLE_BIBP
BOOLEAN BibP_bibhost_available = FALSE;		/* until check succeeds  */
BOOLEAN BibP_bibhost_checked = FALSE;	/*  until LYCheckBibHost   */
BOOLEAN no_goto_bibp = FALSE;
char *BibP_bibhost = NULL;	/* local server for bibp: links  */
char *BibP_globalserver = NULL;	/* global server for bibp: links */
#endif

#ifdef USE_PERSISTENT_COOKIES
BOOLEAN persistent_cookies = FALSE;	/* disabled by default! */
char *LYCookieFile = NULL;	/* cookie read file */
char *LYCookieSaveFile = NULL;	/* cookie save file */
#endif /* USE_PERSISTENT_COOKIES */

#ifdef EXP_NESTED_TABLES
BOOLEAN nested_tables =
#if defined(USE_COLOR_STYLE)
TRUE
#else
FALSE				/* see 2001-08-15  */
#endif
 ;
#endif

BOOLEAN LYShowTransferRate = TRUE;
int LYTransferRate = rateKB;
int LYAcceptEncoding = encodingALL;
int LYAcceptMedia = mediaOpt1;
char *LYTransferName = NULL;

char *XLoadImageCommand = NULL;	/* Default image viewer for X */
BOOLEAN LYNoISMAPifUSEMAP = FALSE;	/* Omit ISMAP link if MAP present? */
int LYHiddenLinks = HIDDENLINKS_SEPARATE;	/* Show hidden links? */

int Old_DTD = NO;
static BOOL DTD_recovery = NO;

#ifndef NO_LYNX_TRACE
FILE *LYTraceLogFP = NULL;	/* Pointer for TRACE log  */
#endif
char *LYTraceLogPath = NULL;	/* Path for TRACE log      */
BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?        */

BOOLEAN LYSeekFragMAPinCur = TRUE;
BOOLEAN LYSeekFragAREAinCur = TRUE;
BOOLEAN LYStripDotDotURLs = TRUE;	/* Try to fix ../ in some URLs? */
BOOLEAN LYForceSSLCookiesSecure = FALSE;
BOOLEAN LYNoCc = FALSE;
BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
BOOLEAN LYPrependBaseToSource = TRUE;
BOOLEAN LYPrependCharsetToSource = TRUE;
BOOLEAN LYQuitDefaultYes = QUIT_DEFAULT_YES;
BOOLEAN dont_wrap_pre = FALSE;

int cookie_noprompt;

#ifdef USE_SSL
int ssl_noprompt = FORCE_PROMPT_DFT;
#endif

int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/

#ifdef EXP_JUSTIFY_ELTS
BOOL ok_justify = TRUE;
int justify_max_void_percent = 35;
#endif

#ifdef EXP_LOCALE_CHARSET
BOOLEAN LYLocaleCharset = FALSE;
#endif

#ifndef NO_DUMP_WITH_BACKSPACES
BOOLEAN with_backspaces = FALSE;
#endif

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
int scrsize_x = 0;
int scrsize_y = 0;
#endif

BOOL force_empty_hrefless_a = FALSE;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
BOOL textfields_need_activation = FALSE;
BOOL textfields_activation_option = FALSE;
#endif

BOOLEAN textfield_prompt_at_left_edge = FALSE;

#ifdef MARK_HIDDEN_LINKS
char *hidden_link_marker = NULL;
#endif

#ifdef DISP_PARTIAL
BOOLEAN display_partial_flag = TRUE;	/* Display document during download */
BOOLEAN debug_display_partial = FALSE;	/* Show with MessageSecs delay */
int partial_threshold = -1;	/* # of lines to be d/l'ed until we repaint */
#endif

BOOLEAN LYNonRestartingSIGWINCH = FALSE;
BOOLEAN LYReuseTempfiles = FALSE;
BOOLEAN LYUseBuiltinSuffixes = TRUE;

#ifdef MISC_EXP
int LYNoZapKey = 0;		/* 0: off (do z checking), 1: full, 2: initially */
#endif

#ifndef DISABLE_NEWS
#include <HTNews.h>
#endif

BOOLEAN FileInitAlreadyDone = FALSE;

static BOOLEAN stack_dump = FALSE;
static char *terminal = NULL;
static const char *pgm;
static BOOLEAN no_numbers = FALSE;
static BOOLEAN number_links = FALSE;
static BOOLEAN number_fields = FALSE;
static BOOLEAN LYPrependBase = FALSE;
static HTList *LYStdinArgs = NULL;

#ifndef EXTENDED_OPTION_LOGIC
/* if set then '--' will be recognized as the end of options */
#define EXTENDED_OPTION_LOGIC 1
#endif

#ifndef EXTENDED_STARTFILE_RECALL
/* if set then additional non-option args (before the last one) will be
   made available for 'g'oto recall - kw */
#define EXTENDED_STARTFILE_RECALL 1
#endif

#if EXTENDED_STARTFILE_RECALL
static char *nonoption = 0;
#endif

#ifndef OPTNAME_ALLOW_DASHES
/* if set, then will allow dashes and underscores to be used interchangeable
   in commandline option's names - VH */
#define OPTNAME_ALLOW_DASHES 1
#endif

static BOOL parse_arg(char **arg, unsigned mask, int *countp);
static void print_help_and_exit(int exit_status) GCC_NORETURN;
static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       BOOLEAN option);

#ifndef VMS
BOOLEAN LYNoCore = NO_FORCED_CORE_DUMP;
BOOLEAN restore_sigpipe_for_children = FALSE;
static void FatalProblem(int sig);
#endif /* !VMS */

#if defined(USE_COLOR_STYLE)
char *lynx_lss_file = NULL;
#endif

#ifdef __DJGPP__
static void LY_set_ctrl_break(int setting)
{
    (void) signal(SIGINT, (setting ? SIG_DFL : SIG_IGN));
    setcbrk(setting);
}

static int LY_get_ctrl_break(void)
{
    __dpmi_regs regs;

    regs.h.ah = 0x33;
    regs.h.al = 0x00;
    __dpmi_int(0x21, &regs);
    return ((int) regs.h.dl);
}

static void reset_break(void)
{
    LY_set_ctrl_break(init_ctrl_break[0]);
}
#endif /* __DJGPP__ */

#if defined(WIN_EX)
static int is_windows_nt(void)
{
    DWORD version;

    version = GetVersion();
    if ((version & 0x80000000) == 0)
	return 1;
    else
	return 0;
}
#endif

#ifdef LY_FIND_LEAKS
static void free_lynx_globals(void)
{
    int i;

#ifndef VMS
    FREE(list_format);
#ifdef LYNXCGI_LINKS		/* WebSter Mods -jkt */
    FREE(LYCgiDocumentRoot);
#endif /* LYNXCGI_LINKS */
    free_lynx_cfg();
#endif /* !VMS */

#ifdef SYSLOG_REQUESTED_URLS
    FREE(syslog_txt);
#endif

#ifdef VMS
    Define_VMSLogical("LYNX_VERSION", "");
#endif /* VMS */
#ifndef VMS
    FREE(lynx_version_putenv_command);
#endif

#if USE_VMS_MAILER
    FREE(mail_adrs);
#endif

    FREE(LynxHome);
    FREE(history);
    FREE(homepage);
    FREE(original_dir);
    FREE(startfile);
    FREE(helpfile);
    FREE(helpfilepath);
    FREE(jumpprompt);
#ifdef JUMPFILE
    FREE(jumpfile);
#endif /* JUMPFILE */
    FREE(indexfile);
    FREE(x_display);
    FREE(global_type_map);
    FREE(personal_type_map);
    FREE(global_extension_map);
    FREE(personal_extension_map);
    FREE(language);
    FREE(pref_charset);
    FREE(LynxSigFile);
    FREE(system_mail);
    FREE(system_mail_flags);
#ifndef DISABLE_BIBP
    FREE(BibP_bibhost);
    FREE(BibP_globalserver);
#endif
#ifdef USE_PERSISTENT_COOKIES
    FREE(LYCookieFile);
    FREE(LYCookieSaveFile);
#endif
    FREE(LYCookieAcceptDomains);
    FREE(LYCookieRejectDomains);
    FREE(LYCookieLooseCheckDomains);
    FREE(LYCookieStrictCheckDomains);
    FREE(LYCookieQueryCheckDomains);
    FREE(LYUserAgent);
    FREE(LYUserAgentDefault);
    FREE(LYHostName);
    FREE(LYLocalDomain);
    FREE(lynx_save_space);
    FREE(bookmark_page);
    FREE(BookmarkPage);
    for (i = 0; i <= MBM_V_MAXFILES; i++) {
	FREE(MBM_A_subbookmark[i]);
	FREE(MBM_A_subdescript[i]);
    }
    FREE(editor);
    FREE(authentication_info[0]);
    FREE(authentication_info[1]);
    FREE(proxyauth_info[0]);
    FREE(proxyauth_info[1]);
    FREE(lynxjumpfile);
    FREE(ftp_lasthost);
    FREE(startrealm);
    FREE(personal_mail_address);
    FREE(anonftp_password);
    FREE(URLDomainPrefixes);
    FREE(URLDomainSuffixes);
    FREE(XLoadImageCommand);
    FREE(lynx_temp_space);
    FREE(LYTraceLogPath);
    FREE(lynx_cfg_file);
#if defined(USE_COLOR_STYLE)
    FREE(lynx_lss_file);
#endif
    FREE(UCAssume_MIMEcharset);
    LYUIPages_free();
    LYFreeHilites(0, nlinks);
    nlinks = 0;
    LYFreeStringList(LYcommandList());
    HTInitProgramPaths();
#if EXTENDED_STARTFILE_RECALL
    FREE(nonoption);
#endif

    return;
}
#endif /* LY_FIND_LEAKS */

/*
 * This function frees the LYStdinArgs list.  - FM
 */
static void LYStdinArgs_free(void)
{
    LYFreeStringList(LYStdinArgs);
    LYStdinArgs = NULL;
}

void reset_signals(void)
{
#ifndef NOSIGHUP
    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
    if (no_suspend)
	(void) signal(SIGTSTP, SIG_DFL);
#endif /* SIGTSTP */
}

void exit_immediately(int code)
{
    reset_signals();
#ifdef NCURSES_NO_LEAKS
    _nc_freeall();
#endif
    exit(code);
}

#ifdef  EBCDIC
/* *INDENT-OFF* */
      char un_IBM1047[ 256 ] = "";
unsigned char IBM1047[ 256 ] = /* ATOE OEMVS311 */
{
0x00,0x01,0x02,0x03,0x37,0x2d,0x2e,0x2f,0x16,0x05,0x15,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x3c,0x3d,0x32,0x26,0x18,0x19,0x3f,0x27,0x1c,0x1d,0x1e,0x1f,
0x40,0x5a,0x7f,0x7b,0x5b,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,
0x7c,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,
0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xad,0xe0,0xbd,0x5f,0x6d,
0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,
0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xc0,0x4f,0xd0,0xa1,0x07,
0x20,0x21,0x22,0x23,0x24,0x25,0x06,0x17,0x28,0x29,0x2a,0x2b,0x2c,0x09,0x0a,0x1b,
0x30,0x31,0x1a,0x33,0x34,0x35,0x36,0x08,0x38,0x39,0x3a,0x3b,0x04,0x14,0x3e,0xff,
0x41,0xaa,0x4a,0xb1,0x9f,0xb2,0x6a,0xb5,0xbb,0xb4,0x9a,0x8a,0xb0,0xca,0xaf,0xbc,
0x90,0x8f,0xea,0xfa,0xbe,0xa0,0xb6,0xb3,0x9d,0xda,0x9b,0x8b,0xb7,0xb8,0xb9,0xab,
0x64,0x65,0x62,0x66,0x63,0x67,0x9e,0x68,0x74,0x71,0x72,0x73,0x78,0x75,0x76,0x77,
0xac,0x69,0xed,0xee,0xeb,0xef,0xec,0xbf,0x80,0xfd,0xfe,0xfb,0xfc,0xba,0xae,0x59,
0x44,0x45,0x42,0x46,0x43,0x47,0x9c,0x48,0x54,0x51,0x52,0x53,0x58,0x55,0x56,0x57,
0x8c,0x49,0xcd,0xce,0xcb,0xcf,0xcc,0xe1,0x70,0xdd,0xde,0xdb,0xdc,0x8d,0x8e,0xdf
} ;
/* *INDENT-ON* */

static void FixCharacters(void)
{
    int c;
    int work1[256], work2[256];

    for (c = 0; c < 256; c++) {
	un_IBM1047[IBM1047[c]] = c;
	work1[c] = keymap[c + 1];
	work2[c] = key_override[c + 1];
    }
    for (c = 0; c < 256; c++) {
	keymap[IBM1047[c] + 1] = work1[c];
	key_override[IBM1047[c] + 1] = work2[c];
    }
}
#endif /* EBCDIC */

static void tildeExpand(char **pathname,
			BOOLEAN embedded)
{
    char *temp = *pathname;

    if (embedded) {
	if (temp != NULL) {
	    temp = strstr(*pathname, "/~");
	    if (temp != 0)
		temp++;
	    else
		temp = *pathname;
	}
    }

    if (temp != NULL
	&& temp[0] == '~') {
	if (temp[1] == '/'
	    && temp[2] != '\0') {
	    temp = NULL;
	    StrAllocCopy(temp, *pathname + 2);
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	    LYAddPathSep(pathname);
	    StrAllocCat(*pathname, temp);
	    FREE(temp);
	} else if (temp[1] == '\0') {
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	}
    }
}

static BOOL GetStdin(char **buf,
		     BOOL marker)
{
    if (LYSafeGets(buf, stdin) != 0
	&& (!marker || strncmp(*buf, "---", 3) != 0)) {
	LYTrimTrailing(*buf);
	CTRACE((tfp, "...data: %s\n", *buf));
	return TRUE;
    }
    CTRACE((tfp, "...mark: %s\n", *buf ? *buf : ""));
    return FALSE;
}

#ifdef WIN32
static BOOL cleanup_win32(DWORD fdwCtrlType)
{
    switch (fdwCtrlType) {
    case CTRL_CLOSE_EVENT:
	cleanup_sig(-1);
	return TRUE;
    default:
	return FALSE;
    }
}
#endif

/*
 * Append the SSL version to lynx version or user-agent string.
 */
#ifdef USE_SSL
static void append_ssl_version(char **target,
			       const char *separator)
{
    char SSLLibraryVersion[256];
    char *SSLcp;

    HTSprintf(target, " SSL-MM%s1.4.1", separator);

#undef LYNX_SSL_VERSION

#if defined(SSLEAY_VERSION)
#define LYNX_SSL_VERSION SSLeay_version(SSLEAY_VERSION)
#else
#if defined(OPENSSL_VERSION_TEXT)
#define LYNX_SSL_VERSION OPENSSL_VERSION_TEXT
#else
#if defined(GNUTLS_VERSION)
#define LYNX_SSL_VERSION GNUTLS_VERSION
#endif /* GNUTLS_VERSION */
#endif /* OPENSSL_VERSION_TEXT */
#endif

#ifdef LYNX_SSL_VERSION
    if (*separator == ' ')
	StrAllocCat(*target, ",");
    LYstrncpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion) - 1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = *separator;
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    StrAllocCat(*target, " ");
	    StrAllocCat(*target, SSLLibraryVersion);
	}
    }
#endif /* LYNX_SSL_VERSION */
}
#endif /* USE_SSL */

/*
 * Wow!  Someone wants to start up Lynx.
 */
int main(int argc,
	 char **argv)
{
    int i;			/* indexing variable */
    int status = 0;		/* exit status */
    char *temp = NULL;
    char *cp;
    FILE *fp;
    struct stat dir_info;
    char filename[LY_MAXPATH];
    BOOL LYGetStdinArgs = FALSE;

#ifdef _WINDOWS
    WSADATA WSAData;
#endif /* _WINDOWS */

    /*
     * Just in case someone has the idea to install lynx set-uid, let's try
     * to discourage it.
     */
#if defined(GETUID) && defined(SETUID)
    setuid(getuid());
#endif

#ifdef    NOT_ASCII
    FixCharacters();
#endif /* NOT_ASCII */

#ifndef DISABLE_FTP
    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
    ftp_lasthost = typecalloc(char);
#endif

#ifdef EXP_CHARSET_CHOICE
    memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
#endif

#ifdef _WINDOWS
    {
	int err;
	WORD wVerReq;

	wVerReq = MAKEWORD(1, 1);

	err = WSAStartup(wVerReq, &WSAData);
	if (err != 0) {
	    puts(gettext("No Winsock found, sorry."));
	    sleep(5);
	    return 1;
	}
    }

    /* 1998/09/03 (Thu) 22:02:32 */
    InitializeCriticalSection(&critSec_DNS);
    InitializeCriticalSection(&critSec_READ);

#endif /* _WINDOWS */

#if 0				/* defined(__CYGWIN__) - does not work with screen */
    if (strcmp(ttyname(fileno(stdout)), "/dev/conout") != 0) {
	printf("please \"$CYGWIN=notty\"\n");
	exit_immediately(EXIT_SUCCESS);
    }
#endif

#if defined(WIN_EX)
    /* 1997/10/19 (Sun) 21:40:54 */
    system_is_NT = (BOOL) is_windows_nt();

    /* 1998/01/13 (Tue) 21:13:47 */
    GetWindowsDirectory(filename, sizeof filename);
    windows_drive[0] = filename[0];
    windows_drive[1] = filename[1];
    windows_drive[2] = '\0';
#endif

#ifdef __DJGPP__
    if (LY_get_ctrl_break() == 0) {
	LY_set_ctrl_break(TRUE);
	init_ctrl_break[0] = 0;
    } else {
	init_ctrl_break[0] = 1;
    }
    __djgpp_set_sigquit_key(0x082D);	/* Bind ALT-X to SIGQUIT */
    signal(SIGQUIT, cleanup_sig);
    atexit(reset_break);

    if (((cp = LYGetEnv("SHELL")) != NULL)
	&& (strstr(LYPathLeaf(cp), "sh") != NULL))
	dj_is_bash = TRUE;
#endif /* __DJGPP__ */

    /*
     * To prevent corrupting binary data on DOS, MS-WINDOWS or OS/2
     * we open files and stdout in BINARY mode by default.
     * Where necessary we should open and (close!) TEXT mode.
     * (use LYNewTxtFile/LYAppendToTxtFile to open text files for writing)
     */
    SetDefaultMode(O_BINARY);
    SetOutputMode(O_BINARY);

#ifdef DOSPATH
    if (LYGetEnv("TERM") == NULL)
	putenv("TERM=vt100");
#endif

    LYShowColor = (SHOW_COLOR ? SHOW_COLOR_ON : SHOW_COLOR_OFF);
    /*
     * Set up the argument list.
     */
    pgm = argv[0];
    cp = NULL;
    if ((cp = LYLastPathSep(pgm)) != NULL) {
	pgm = cp + 1;
    }

    /*
     * Act on -help NOW, so we only output the help and exit.  - FM
     */
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 1, &i);
    }

#ifdef LY_FIND_LEAKS
    /*
     * Register the final function to be executed when being exited.  Will
     * display memory leaks if LY_FIND_LEAKS is defined.
     */
    atexit(LYLeaks);
    /*
     * Register the function which will free our allocated globals.
     */
    atexit(free_lynx_globals);
#endif /* LY_FIND_LEAKS */

#ifdef LOCALE
    /*
     * LOCALE support for international characters.
     */
    setlocale(LC_ALL, "");
#endif /* LOCALE */
    /* Set the text message domain.  */
#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
#ifndef __DJGPP__
    if ((cp = LYGetEnv("LYNX_LOCALEDIR")) == 0)
	cp = LOCALEDIR;
    bindtextdomain("lynx", cp);
#endif /* !__DJGPP__ */
    textdomain("lynx");
#endif /* HAVE_LIBINTL_H */

    /*
     * Initialize our startup and global variables.
     */
#ifdef ULTRIX
    /*
     * Need this for Ultrix.
     */
    terminal = LYGetEnv("TERM");
    if ((terminal == NULL) || !strncasecomp(terminal, "xterm", 5))
	terminal = "vt100";
#endif /* ULTRIX */
    /*
     * Zero the links and history struct arrays.
     */
    memset((void *) links, 0, sizeof(LinkInfo) * MAXLINKS);
    LYAllocHistory(8);
    /*
     * Zero the MultiBookmark arrays.
     */
    memset((void *) MBM_A_subbookmark, 0, sizeof(char) * (MBM_V_MAXFILES + 1));
    memset((void *) MBM_A_subdescript, 0, sizeof(char) * (MBM_V_MAXFILES + 1));

#ifndef VMS
    StrAllocCopy(list_format, LIST_FORMAT);
#endif /* !VMS */

    AlertSecs = SECS2Secs(ALERTSECS);
    DebugSecs = SECS2Secs(DEBUGSECS);
    InfoSecs = SECS2Secs(INFOSECS);
    MessageSecs = SECS2Secs(MESSAGESECS);
    ReplaySecs = SECS2Secs(REPLAYSECS);

    StrAllocCopy(helpfile, HELPFILE);
    StrAllocCopy(startfile, STARTFILE);
    LYEscapeStartfile(&startfile);
    StrAllocCopy(indexfile, DEFAULT_INDEX_FILE);
    StrAllocCopy(global_type_map, GLOBAL_MAILCAP);
    StrAllocCopy(personal_type_map, PERSONAL_MAILCAP);
    StrAllocCopy(global_extension_map, GLOBAL_EXTENSION_MAP);
    StrAllocCopy(personal_extension_map, PERSONAL_EXTENSION_MAP);
    StrAllocCopy(language, PREFERRED_LANGUAGE);
    StrAllocCopy(pref_charset, PREFERRED_CHARSET);
    StrAllocCopy(system_mail, SYSTEM_MAIL);
#ifdef SYSTEM_MAIL_FLAGS
    StrAllocCopy(system_mail_flags, SYSTEM_MAIL_FLAGS);
#else
    StrAllocCopy(system_mail_flags, "");
#endif

    /*
     * Ugly code - but StrAlloc* is a macro :(
     */
    StrAllocCopy(LYUserAgent, "Mozilla/5.0 (UNIX; U; ");
#if defined(__OpenBSD__)
    StrAllocCat(LYUserAgent, "OpenBSD");
#elif defined(__FreeBSD__)
    StrAllocCat(LYUserAgent, "FreeBSD");
#elif defined(__NetBSD__)
    StrAllocCat(LYUserAgent, "NetBSD");
#elif defined(__Linux__)
    StrAllocCat(LYUserAgent, "GNU/Linux");
#elif defined(WIN32)
    StrAllocCat(LYUserAgent, "Win32");
#elif defined(_WINDOWS)
    StrAllocCat(LYUserAgent, "Windows (non-32 bit)");
#elif defined(VMS)
    StrAllocCat(LYUserAgent, "VMS");
#else
    StrAllocCat(LYUserAgent, "other");
#endif
    StrAllocCat(LYUserAgent, "; C; compatible) ");
    StrAllocCat(LYUserAgent, LYNX_NAME);
    StrAllocCat(LYUserAgent, "/");
    StrAllocCat(LYUserAgent, LYNX_VERSION);
    if (HTLibraryVersion) {
	StrAllocCat(LYUserAgent, " libwww-FM/");
	StrAllocCat(LYUserAgent, HTLibraryVersion);
    }
#ifdef USE_SSL
    append_ssl_version(&LYUserAgent, "/");
#endif /* USE_SSL */
#ifndef __NO_MIRBSD_EXTENSION
    StrAllocCat(LYUserAgent, " Revision/MirOS:");
#if defined(__MirBSD__) || defined(__MirLinux__)
    StrAllocCat(LYUserAgent, MACHINE_OS);
    StrAllocCat(LYUserAgent,
	" (https://MirBSD.BSDadvocacy.org:8890/)");
#else
    StrAllocCat(LYUserAgent,
	"other (third party building Lynx from MirBSD source)");
#endif
#endif
	/*
	 * the reason for the following one is:
	 * certain web backends only give Netscape, Mozilla
	 * or MS Internet Explorer users the "real" HTML
	 * of the page by checking the user agent
	 */
    StrAllocCat(LYUserAgent, " fake (MSIE 5.5)");
    StrAllocCopy(LYUserAgentDefault, LYUserAgent);

#ifdef VMS
    Define_VMSLogical("LYNX_VERSION", LYNX_VERSION);
#else
    StrAllocCopy(lynx_version_putenv_command, "LYNX_VERSION=");
    StrAllocCat(lynx_version_putenv_command, LYNX_VERSION);
    (void) putenv(lynx_version_putenv_command);
    /* Note: you must not free the data passed to 'putenv()' until you give it
     * a new value for that variable.
     */
#endif /* VMS */

    if ((cp = LYGetEnv("LYNX_TEMP_SPACE")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
#if defined (UNIX) || defined (__DJGPP__)
    else if ((cp = LYGetEnv("TMPDIR")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
#endif
#if defined (DOSPATH) || defined (__EMX__)
    else if ((cp = LYGetEnv("TEMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
    else if ((cp = LYGetEnv("TMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
#endif
    else
#ifdef TEMP_SPACE
	StrAllocCopy(lynx_temp_space, TEMP_SPACE);
#else
    {
	puts(gettext("You MUST define a valid TMP or TEMP area!"));
	exit_immediately(EXIT_FAILURE);
    }
#endif

#ifdef WIN_EX			/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
    if (access(lynx_temp_space, 0) != 0)
#endif
	tildeExpand(&lynx_temp_space, TRUE);

    if ((cp = strstr(lynx_temp_space, "$USER")) != NULL) {
	char *cp1;

	if ((cp1 = LYGetEnv("USER")) != NULL) {
	    *cp = '\0';
	    StrAllocCopy(temp, lynx_temp_space);
	    *cp = '$';
	    StrAllocCat(temp, cp1);
	    cp += 5;
	    StrAllocCat(temp, cp);
	    StrAllocCopy(lynx_temp_space, temp);
	    FREE(temp);
	}
    }
#ifdef VMS
    LYLowerCase(lynx_temp_space);
    if (strchr(lynx_temp_space, '/') != NULL) {
	if (strlen(lynx_temp_space) == 1) {
	    StrAllocCopy(lynx_temp_space, "sys$scratch:");
	} else {
	    LYAddPathSep(&lynx_temp_space);
	    StrAllocCopy(temp, HTVMS_name("", lynx_temp_space));
	    StrAllocCopy(lynx_temp_space, temp);
	    FREE(temp);
	}
    }
    if (strchr(lynx_temp_space, ':') == NULL &&
	strchr(lynx_temp_space, ']') == NULL) {
	StrAllocCat(lynx_temp_space, ":");
    }
#else
    LYAddPathSep(&lynx_temp_space);
    StrAllocCopy(lynx_temp_space, HTSYS_name(lynx_temp_space));
#endif /* VMS */

    if ((HTStat(lynx_temp_space, &dir_info) < 0
#if defined(MULTI_USER_UNIX)
	 && mkdir(lynx_temp_space, 0700) < 0
#endif
	)
	|| !S_ISDIR(dir_info.st_mode)) {
	fprintf(stderr, "%s: %s\n",
		lynx_temp_space,
		gettext("No such directory"));
	exit_immediately(EXIT_FAILURE);
    }
#if USE_VMS_MAILER
#ifndef MAIL_ADRS
#define MAIL_ADRS "\"IN%%\"\"%s\"\"\""
#endif
    StrAllocCopy(mail_adrs, MAIL_ADRS);
#endif

#ifdef LYNX_HOST_NAME
    StrAllocCopy(LYHostName, LYNX_HOST_NAME);
#else
    StrAllocCopy(LYHostName, HTHostName());
#endif /* LYNX_HOST_NAME */

    StrAllocCopy(LYLocalDomain, LOCAL_DOMAIN);
    StrAllocCopy(URLDomainPrefixes, URL_DOMAIN_PREFIXES);
    StrAllocCopy(URLDomainSuffixes, URL_DOMAIN_SUFFIXES);
    StrAllocCopy(XLoadImageCommand, XLOADIMAGE_COMMAND);

#ifndef DISABLE_BIBP
    StrAllocCopy(BibP_globalserver, BIBP_GLOBAL_SERVER);
    StrAllocCopy(BibP_bibhost, "http://bibhost/");	/* protocol specified. */
#endif

    /*
     * Disable news posting if the compilation-based LYNewsPosting value is
     * FALSE.  This may be changed further down via lynx.cfg or the
     * -restriction command line switch.  - FM
     */
#ifndef DISABLE_NEWS
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
#endif

    /*
     * Set up trace, the anonymous account defaults, validate restrictions,
     * and/or the nosocks flag, if requested, and an alternate configuration
     * file, if specified, NOW.  Also, if we only want the help menu, output
     * that and exit.  - FM
     */
#ifndef NO_LYNX_TRACE
    if (LYGetEnv("LYNX_TRACE") != 0) {
	WWW_TraceFlag = TRUE;
    }
#endif
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 2, &i);
    }

    /*
     * If we have a lone "-" switch for getting arguments from stdin, get them
     * NOW, and act on the relevant ones, saving the others into an HTList for
     * handling after the other initializations.  The primary purpose of this
     * feature is to allow for the potentially very long command line that can
     * be associated with post or get data.  The original implementation
     * required that the lone "-" be the only command line argument, but that
     * precluded its use when the lynx command is aliased with other arguments. 
     * When interactive, the stdin input is terminated by by Control-D on Unix
     * or Control-Z on VMS, and each argument is terminated by a RETURN.  When
     * the argument is -get_data or -post_data, the data are terminated by a
     * "---" string, alone on the line (also terminated by RETURN).  - FM
     */
    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-") == 0) {
	    LYGetStdinArgs = TRUE;
	    break;
	}
    }
    if (LYGetStdinArgs == TRUE) {
	char *buf = NULL;

	CTRACE((tfp, "processing stdin arguments\n"));
	while (GetStdin(&buf, TRUE)) {
	    char *noargv[2];

	    noargv[0] = buf;
	    noargv[1] = NULL;
	    LYTrimTrailing(buf);

	    if (parse_arg(&noargv[0], 2, (int *) 0) == FALSE
		&& buf[0] != '\0') {
		char *argument = NULL;

		if (LYStdinArgs == NULL) {
		    LYStdinArgs = HTList_new();
#ifdef LY_FIND_LEAKS
		    atexit(LYStdinArgs_free);
#endif
		}
		StrAllocCopy(argument, buf);
		HTList_appendObject(LYStdinArgs, argument);
		CTRACE((tfp, "...StdinArg:%s\n", argument));
	    } else {
		CTRACE((tfp, "...complete:%s\n", buf));
	    }
	}
	CTRACE((tfp, "...done with stdin arguments\n"));
	FREE(buf);
    }
#ifdef SOCKS
    if (socks_flag)
	SOCKSinit(argv[0]);
#endif /* SOCKS */

    /*
     * If we had -validate set all of the restrictions and disallow a TRACE log
     * NOW.  - FM
     */
    if (LYValidate == TRUE) {
	parse_restrictions("all");
	LYUseTraceLog = FALSE;
    }

    /*
     * If we didn't get and act on a -validate or -anonymous switch, but can
     * verify that this is the anonymous account, set the default restrictions
     * for that account and disallow a TRACE log NOW.  - FM
     */
    if (!LYValidate && !LYRestricted &&
	strlen(ANONYMOUS_USER) > 0 &&
#if defined (VMS) || defined (NOUSERS)
	!strcasecomp((LYGetEnv("USER") == NULL ? " " : LYGetEnv("USER")),
		     ANONYMOUS_USER)
#else
#ifdef HAVE_CUSERID
	STREQ((char *) cuserid((char *) NULL), ANONYMOUS_USER)
#else
	STREQ(((char *) getlogin() == NULL ? " " : getlogin()), ANONYMOUS_USER)
#endif /* HAVE_CUSERID */
#endif /* VMS */
	) {
	parse_restrictions("default");
	LYRestricted = TRUE;
	LYUseTraceLog = FALSE;
    }

    /*
     * Set up the TRACE log path, and logging if appropriate.  - FM
     */
    if ((cp = LYGetEnv("LYNX_TRACE_FILE")) == 0)
	cp = TRACE_FILE;
    LYTraceLogPath = typeMallocn(char, LY_MAXPATH);

    LYAddPathToHome(LYTraceLogPath, LY_MAXPATH, cp);

    LYOpenTraceLog();

#ifdef EXP_CMD_LOGGING
    /*
     * Open command-script, if specified
     */
    if (lynx_cmd_script != 0) {
	tildeExpand(&lynx_cmd_script, TRUE);
	LYOpenCmdScript();
    }
    /*
     * Open command-logging, if specified
     */
    if (lynx_cmd_logfile != 0) {
	tildeExpand(&lynx_cmd_logfile, TRUE);
	LYOpenCmdLogfile(argc, argv);
    }
#endif

    /*
     * Set up the default jump file stuff.  - FM
     */
    StrAllocCopy(jumpprompt, JUMP_PROMPT);
#ifdef JUMPFILE
    StrAllocCopy(jumpfile, JUMPFILE);
    {
	temp = NULL;
	HTSprintf0(&temp, "JUMPFILE:%s", jumpfile);
	if (!LYJumpInit(temp)) {
	    CTRACE((tfp, "Failed to register %s\n", temp));
	}
	FREE(temp);
    }
#endif /* JUMPFILE */

    /*
     * If no alternate configuration file was specified on the command line,
     * see if it's in the environment.
     */
    if (!lynx_cfg_file) {
	if (((cp = LYGetEnv("LYNX_CFG")) != NULL) ||
	    (cp = LYGetEnv("lynx_cfg")) != NULL)
	    StrAllocCopy(lynx_cfg_file, cp);
    }

    /*
     * If we still don't have a configuration file, use the userdefs.h
     * definition.
     */
    if (!lynx_cfg_file)
	StrAllocCopy(lynx_cfg_file, LYNX_CFG_FILE);

#ifndef _WINDOWS		/* avoid the whole ~ thing for now */
    tildeExpand(&lynx_cfg_file, FALSE);
#endif

    /*
     * If the configuration file is not available, inform the user and exit.
     */
    if (!LYCanReadFile(lynx_cfg_file)) {
	fprintf(stderr,
		gettext("\nConfiguration file %s is not available.\n\n"),
		lynx_cfg_file);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Make sure we have the character sets declared.  This will initialize the
     * CHARTRANS handling.  - KW
     */
    if (!LYCharSetsDeclared()) {
	fprintf(stderr, gettext("\nLynx character sets not declared.\n\n"));
	exit_immediately(EXIT_FAILURE);
    }
    /*
     * (**) in Lynx, UCLYhndl_HTFile_for_unspec and UCLYhndl_for_unrec may be
     * valid or not, but current_char_set and UCLYhndl_for_unspec SHOULD ALWAYS
     * be a valid charset.  Initialized here and may be changed later from
     * lynx.cfg/command_line/options_menu.  - LP (**)
     */
    /*
     * Set up the compilation default character set.  - FM
     */
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (auto_display_charset >= 0)
	current_char_set = auto_display_charset;
    else
#endif
	current_char_set = safeUCGetLYhndl_byMIME(CHARACTER_SET);
    /*
     * Set up HTTP default for unlabeled charset (iso-8859-1).
     */
    UCLYhndl_for_unspec = LATIN1;
    StrAllocCopy(UCAssume_MIMEcharset,
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);

    /*
     * Make sure we have the edit map declared.  - FM
     */
    if (!LYEditmapDeclared()) {
	fprintf(stderr, gettext("\nLynx edit map not declared.\n\n"));
	exit_immediately(EXIT_FAILURE);
    }
#if defined(USE_COLOR_STYLE)
    /*
     * If no alternate lynx-style file was specified on the command line, see
     * if it's in the environment.
     */
    if (!lynx_lss_file) {
	if (((cp = LYGetEnv("LYNX_LSS")) != NULL) ||
	    (cp = LYGetEnv("lynx_lss")) != NULL)
	    StrAllocCopy(lynx_lss_file, cp);
    }

    /*
     * If we still don't have a lynx-style file, use the userdefs.h definition.
     */
    if (!lynx_lss_file)
	StrAllocCopy(lynx_lss_file, LYNX_LSS_FILE);

    tildeExpand(&lynx_lss_file, TRUE);

    /*
     * If the lynx-style file is not available, inform the user and exit.
     */
    if (!LYCanReadFile(lynx_lss_file)) {
	fprintf(stderr, gettext("\nLynx file %s is not available.\n\n"),
		lynx_lss_file);
    } else {
	style_readFromFile(lynx_lss_file);
    }
#endif /* USE_COLOR_STYLE */

#ifdef USE_COLOR_TABLE
    /*
     * Set up default foreground and background colors.
     */
    lynx_setup_colors();
#endif /* USE_COLOR_TABLE */

    /*
     * Set the original directory, used for default download
     */
    if (!strcmp(Current_Dir(filename), ".")) {
	if ((cp = LYGetEnv("PWD")) != 0)
	    StrAllocCopy(original_dir, cp);
    } else {
	StrAllocCopy(original_dir, filename);
    }

    /*
     * Set the compilation default signature file.  - FM
     */
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename) - 1);
    if (LYPathOffHomeOK(filename, sizeof(filename))) {
	StrAllocCopy(LynxSigFile, filename);
	LYAddPathToHome(filename, sizeof(filename), LynxSigFile);
	StrAllocCopy(LynxSigFile, filename);
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
    } else {
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
    }

#ifdef USE_PRETTYSRC
    /*this is required for checking the tagspecs when parsing cfg file by
       LYReadCFG.c:parse_html_src_spec -HV */
    HTSwitchDTD(TRUE);
#endif
    /*
     * Process the configuration file.
     */
    read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);

    /*
     * Process the RC file.
     */
    read_rc(NULL);

#ifdef EXP_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif

    /*
     * Get WWW_HOME environment variable if it exists.
     */
    if ((cp = LYGetEnv("WWW_HOME")) != NULL) {
	StrAllocCopy(startfile, cp);
	LYEscapeStartfile(&startfile);
    }

    /*
     * Set the LynxHome URL.  If it's a file URL and the
     * host is defaulted, force in "//localhost", and if
     * it's not an absolute URL, make it one. - FM
     */
    StrAllocCopy(LynxHome, startfile);
    LYEnsureAbsoluteURL(&LynxHome, "LynxHome", FALSE);

    /*
     * Process any command line arguments not already handled.  - FM
     * May set startfile as a side-effect.
     */
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 4, &i);
    }

    /*
     * Process any stdin-derived arguments for a lone "-" which we've loaded
     * into LYStdinArgs.  - FM
     */
    if (LYStdinArgs != NULL) {
	char *my_args[2];
	HTList *cur = LYStdinArgs;

	my_args[1] = NULL;
	while (NULL != (my_args[0] = (char *) HTList_nextObject(cur))) {
	    parse_arg(my_args, 4, (int *) 0);
	}
	LYStdinArgs_free();
    }
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    if (current_char_set == auto_display_charset)	/* Better: explicit option */
	switch_display_charsets = 1;
#endif

#if defined (TTY_DEVICE) || defined(HAVE_TTYNAME)
    /*
     * If we are told to read the startfile from standard input, do it now,
     * after we have read all of the option data from standard input.
     */
    if (startfile_stdin) {
	char result[LY_MAXPATH];
	char *buf = NULL;
	const char *tty = NULL;

# ifdef HAVE_TTYNAME
	tty = ttyname(fileno(stderr));
# endif
	if (tty == NULL)
	    tty = isatty(fileno(stdin)) ? TTY_DEVICE : NUL_DEVICE;

	CTRACE((tfp, "processing stdin startfile, tty=%s\n", tty));
	if ((fp = LYOpenTemp(result, HTML_SUFFIX, "w")) != 0) {
	    StrAllocCopy(startfile, result);
	    while (GetStdin(&buf, FALSE)) {
		fputs(buf, fp);
		fputc('\n', fp);
	    }
	    FREE(buf);
	    LYCloseTempFP(fp);
	}
	CTRACE((tfp, "...done stdin startfile\n"));
	if ((freopen(tty, "r", stdin)) == 0) {
	    CTRACE((tfp, "cannot open a terminal (%s)\n", tty));
	    if (!dump_output_immediately) {
		fprintf(stderr, "cannot open a terminal (%s)\n", tty);
		exit_immediately(1);
	    }
	}
    }
#endif

    /*
     * Initialize other things based on the configuration read.
     */

#ifdef USE_PRETTYSRC
    if ((!Old_DTD) != TRUE)	/* skip if they are already initialized -HV */
#endif
	HTSwitchDTD(!Old_DTD);

    /*
     * Set up the proper character set with the desired
     * startup raw 8-bit or CJK mode handling.  - FM
     */
    HTMLUseCharacterSet(current_char_set);

#ifdef USE_PERSISTENT_COOKIES
    /*
     * Sod it, this looks like a reasonable place to load the
     * cookies file, probably.  - RP
     *
     * And to set LYCookieSaveFile. - BJP
     */
    if (persistent_cookies) {
	if (LYCookieFile == NULL) {
	    LYCookieFile = typeMallocn(char, LY_MAXPATH);

	    LYAddPathToHome(LYCookieFile, LY_MAXPATH, COOKIE_FILE);
	} else {
	    tildeExpand(&LYCookieFile, FALSE);
	}
	LYLoadCookies(LYCookieFile);
    }

    /* tilde-expand LYCookieSaveFile */
    if (LYCookieSaveFile != NULL) {
	tildeExpand(&LYCookieSaveFile, FALSE);
    }

    /*
     * In dump_output_immediately mode, LYCookieSaveFile defaults to
     * /dev/null, otherwise it defaults to LYCookieFile.
     */

    if (LYCookieSaveFile == NULL) {
	if (dump_output_immediately) {
	    StrAllocCopy(LYCookieSaveFile, "/dev/null");
	} else {
	    StrAllocCopy(LYCookieSaveFile, LYCookieFile);
	}
    }
#endif

    /*
     * Set up our help and about file base paths. - FM
     */
    StrAllocCopy(helpfilepath, helpfile);
    if ((cp = LYPathLeaf(helpfilepath)) != helpfilepath)
	*cp = '\0';
    LYAddHtmlSep(&helpfilepath);

    /*
     * Check for a save space path in the environment.  If one was set in the
     * configuration file, that one will be overridden.  - FM
     */
    if ((cp = LYGetEnv("LYNX_SAVE_SPACE")) != NULL)
	StrAllocCopy(lynx_save_space, cp);

    /*
     * We have a save space path, make sure it's valid.  - FM
     */
    if (lynx_save_space && *lynx_save_space == '\0') {
	FREE(lynx_save_space);
    }
    if (lynx_save_space) {
	tildeExpand(&lynx_save_space, TRUE);
#ifdef VMS
	LYLowerCase(lynx_save_space);
	if (strchr(lynx_save_space, '/') != NULL) {
	    if (strlen(lynx_save_space) == 1) {
		StrAllocCopy(lynx_save_space, "sys$login:");
	    } else {
		LYAddPathSep(&lynx_save_space);
		StrAllocCopy(temp, HTVMS_name("", lynx_save_space));
		StrAllocCopy(lynx_save_space, temp);
		FREE(temp);
	    }
	}
	if (strchr(lynx_save_space, ':') == NULL &&
	    strchr(lynx_save_space, ']') == NULL) {
	    StrAllocCat(lynx_save_space, ":");
	}
#else
	LYAddPathSep(&lynx_save_space);
#endif /* VMS */
    }

    /*
     * Set up the file extension and mime type maps from src/HTInit.c and the
     * global and personal mime.types and mailcap files.  These will override
     * any SUFFIX or VIEWER maps in userdefs.h or the configuration file, if
     * they overlap.
     */
    HTFormatInit();
    if (!FileInitAlreadyDone)
	HTFileInit();

    if (!LYCheckUserAgent()) {
	HTAlwaysAlert(gettext("Warning:"), UA_NO_LYNX_WARNING);
    }
#ifdef SH_EX
    if (show_cfg) {
	cleanup();
	exit_immediately(EXIT_SUCCESS);
    }
#endif

#ifdef USE_SLANG
    if (LYShowColor >= SHOW_COLOR_ON &&
	!(Lynx_Color_Flags & SL_LYNX_USE_COLOR)) {
	Lynx_Color_Flags |= SL_LYNX_USE_COLOR;
    } else if ((Lynx_Color_Flags & SL_LYNX_USE_COLOR) ||
	       LYGetEnv("COLORTERM") != NULL) {
	if (LYShowColor != SHOW_COLOR_NEVER &&
	    LYShowColor != SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
    }
#endif /* USE_SLANG */

    if (LYPreparsedSource) {
	HTPreparsedFormatInit();
    }
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
#ifdef NEVER_ALLOW_REMOTE_EXEC
    if (local_exec) {
	local_exec = FALSE;
	local_exec_on_local_files = TRUE;
    }
#endif /* NEVER_ALLOW_REMOTE_EXEC */
#endif /* EXEC_LINKS || EXEC_SCRIPTS */

    if (emacs_keys)
	set_emacs_keys();

    if (vi_keys)
	set_vi_keys();

    if (no_numbers) {
	number_links = FALSE;
	number_fields = FALSE;
	keypad_mode = NUMBERS_AS_ARROWS;
	set_numbers_as_arrows();
    }

    if (crawl) {
	/* No numbered links by default, as documented
	   in CRAWL.announce. - kw */
	if (!number_links) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	}
    }

    if (!links_are_numbered()) {
	if (number_fields)
	    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
	if (number_links)
	    keypad_mode = LINKS_ARE_NUMBERED;
	set_numbers_as_arrows();
    }

    /*
     * Check the -popup command line toggle.  - FM
     */
    if (LYUseDefSelPop == FALSE) {
	LYSelectPopups = !LYSelectPopups;
    }

    /*
     * Check the -show_cursor command line toggle.  - FM
     */
    if (LYUseDefShoCur == FALSE) {
	LYShowCursor = !LYShowCursor;
    }

    /*
     * Check the -base command line switch with -source.  - FM
     */
    if (LYPrependBase && HTOutputFormat == HTAtom_for("www/download")) {
	LYPrependBaseToSource = TRUE;
    }

    /*
     * Disable multiple bookmark support if not interactive, so it doesn't
     * crash on curses functions, or if the support was blocked via userdefs.h
     * and/or lynx.cfg, or via command line restrictions.  - FM
     */
    if (no_multibook)
	LYMBMBlocked = TRUE;
    if (dump_output_immediately || LYMBMBlocked || no_multibook) {
	LYMultiBookmarks = MBM_OFF;
	LYMBMBlocked = TRUE;
	no_multibook = TRUE;
    }
#ifdef USE_SOURCE_CACHE
    /*
     * Disable source caching if not interactive.
     */
    if (dump_output_immediately)
	LYCacheSource = SOURCE_CACHE_NONE;
#endif
#ifdef DISP_PARTIAL
    /*
     * Disable partial mode if not interactive.
     */
    if (dump_output_immediately)
	display_partial_flag = FALSE;
#endif

#ifdef VMS
    set_vms_keys();
#endif /* VMS */

#if defined (__DJGPP__)
    if (watt_debug)
	dbug_init();
    sock_init();

    __system_flags =
	__system_emulate_chdir |	/* handle `cd' internally */
	__system_handle_null_commands |		/* ignore cmds with no effect */
	__system_allow_long_cmds |	/* handle commands > 126 chars   */
	__system_use_shell |	/* use $SHELL if set */
	__system_allow_multiple_cmds |	/* allow `cmd1; cmd2; ...' */
	__system_redirect;	/* redirect internally */

    /* This speeds up stat() tremendously */
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC | _STAT_DIRSIZE;
#endif /* __DJGPP__ */

    /* trap interrupts */
#ifdef WIN32
    SetConsoleCtrlHandler((PHANDLER_ROUTINE) cleanup_win32, TRUE);
#endif

#ifndef NOSIGHUP
    if (!dump_output_immediately)
	(void) signal(SIGHUP, cleanup_sig);
#endif /* NOSIGHUP */

    (void) signal(SIGTERM, cleanup_sig);
#ifdef SIGWINCH
    LYExtSignal(SIGWINCH, size_change);
#endif /* SIGWINCH */
#ifndef VMS
    if (!TRACE && !dump_output_immediately && !stack_dump) {
	(void) signal(SIGINT, cleanup_sig);
#ifndef __linux__
#ifndef DOSPATH
	(void) signal(SIGBUS, FatalProblem);
#endif /* DOSPATH */
#endif /* !__linux__ */
	(void) signal(SIGSEGV, FatalProblem);
	(void) signal(SIGILL, FatalProblem);
	/*
	 * Since we're doing lots of TCP, just ignore SIGPIPE altogether.
	 *
	 * HTTCP.c should deal with a broken pipe for servers.  Rick Mallet's
	 * check after c = GetChar() in LYStrings.c should deal with a
	 * disconnected terminal.  So the runaway CPU time problem on Unix
	 * should not occur any more.
	 */
#ifndef DOSPATH
	if (signal(SIGPIPE, SIG_IGN) != SIG_IGN)
	    restore_sigpipe_for_children = TRUE;
#endif /* DOSPATH */
    }
#endif /* !VMS */

#ifdef SIGTSTP
    /*
     * Block Control-Z suspending if requested.  - FM
     */
    if (no_suspend)
	(void) signal(SIGTSTP, SIG_IGN);
#endif /* SIGTSTP */

    /*
     * Check for a valid HEAD request.  - FM
     */
    if (HEAD_request && LYCanDoHEAD(startfile) != TRUE) {
	fprintf(stderr,
		"The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n",
		startfile);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Check for a valid MIME headers request.  - FM
     */
    if (keep_mime_headers && LYCanDoHEAD(startfile) != TRUE) {
	fprintf(stderr,
		"The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n",
		startfile);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Check for a valid traversal request.  - FM
     */
    if (traversal && strncmp(startfile, "http", 4)) {
	fprintf(stderr,
		"The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n",
		startfile);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Finish setting up for an INTERACTIVE session.  Done here so that URL
     * guessing in LYEnsureAbsoluteURL() can be interruptible (terminal is in
     * raw mode, select() works).  -BL
     */
#ifdef USE_PRETTYSRC
    if (!dump_output_immediately) {
	HTMLSRC_init_caches(FALSE);	/* do it before terminal is initialized */
#ifdef LY_FIND_LEAKS
	atexit(html_src_clean_data);
#endif
    }
#endif

    if (!dump_output_immediately) {
	setup(terminal);
    }
    /*
     * If startfile is a file URL and the host is defaulted, force in
     * "//localhost", and if it's not an absolute URL, make it one.  - FM
     */
    LYEnsureAbsoluteURL(&startfile, "STARTFILE", FALSE);

    /*
     * If homepage was specified and is a file URL with the host defaulted,
     * force in "//localhost", and if it's not an absolute URL, make it one.  -
     * FM
     */
    if (homepage) {
	LYEnsureAbsoluteURL(&homepage, "HOMEPAGE", FALSE);
    }

    /*
     * If we don't have a homepage specified, set it to startfile.  Otherwise,
     * reset LynxHome.  - FM
     */
    if (isEmpty(homepage)) {
	StrAllocCopy(homepage, startfile);
    } else {
	StrAllocCopy(LynxHome, homepage);
    }

    /*
     * Set up the inside/outside domain restriction flags.  - FM
     */
    if (inlocaldomain()) {
#if !defined(HAVE_UTMP) || defined(VMS)		/* not selective */
	telnet_ok = (BOOL) (!no_inside_telnet && !no_outside_telnet && telnet_ok);
#ifndef DISABLE_NEWS
	news_ok = (BOOL) (!no_inside_news && !no_outside_news && news_ok);
#endif
	ftp_ok = (BOOL) (!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
#else
	CTRACE((tfp, "LYMain: User in Local domain\n"));
	telnet_ok = (BOOL) (!no_inside_telnet && telnet_ok);
#ifndef DISABLE_NEWS
	news_ok = (BOOL) (!no_inside_news && news_ok);
#endif
	ftp_ok = (BOOL) (!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && rlogin_ok);
#endif /* !HAVE_UTMP || VMS */
    } else {
	CTRACE((tfp, "LYMain: User in REMOTE domain\n"));
	telnet_ok = (BOOL) (!no_outside_telnet && telnet_ok);
#ifndef DISABLE_NEWS
	news_ok = (BOOL) (!no_outside_news && news_ok);
#endif
	ftp_ok = (BOOL) (!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_outside_rlogin && rlogin_ok);
    }

    /*
     * Make sure our bookmark default strings are all allocated and
     * synchronized.  - FM
     */
    if (!bookmark_page || *bookmark_page == '\0') {
	temp = NULL;
	HTSprintf0(&temp, "./.etc/bookmark.htm");
	set_default_bookmark_page(temp);
	FREE(temp);
    }
    if (!BookmarkPage || *BookmarkPage == '\0') {
	set_default_bookmark_page(bookmark_page);
    }
#if defined(SYSLOG_REQUESTED_URLS)
    LYOpenlog(syslog_txt);
#endif

    if (non_empty(x_display)) {
	LYisConfiguredForX = TRUE;
    }

    /*
     * Here's where we do all the work.
     */
    if (dump_output_immediately) {
	/*
	 * Finish setting up and start a NON-INTERACTIVE session.  - FM
	 */
	if (crawl && !number_links && !number_fields) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	} else if (no_numbers) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	} else if (!no_list) {
	    if (!links_are_numbered()) {
		if (number_fields)
		    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
		else
		    keypad_mode = LINKS_ARE_NUMBERED;
	    }
	}
	if (dump_output_width > 0) {
	    LYcols = dump_output_width;
	}
	/*
	 * Normal argument processing puts non-options (URLs) into the Goto
	 * history.  Use this to dump all of the pages listed on the command
	 * line, or (if none are listed) via the startfile mechanism.
	 * history.
	 */
#ifdef EXTENDED_STARTFILE_RECALL
	HTAddGotoURL(startfile);
	for (i = HTList_count(Goto_URLs) - 1; i >= 0; --i) {
	    StrAllocCopy(startfile, (char *) HTList_objectAt(Goto_URLs, i));
	    CTRACE((tfp, "dumping %d:%d %s\n",
		    i + 1, HTList_count(Goto_URLs), startfile));
	    status = mainloop();
	    if (!no_list &&
		!crawl &&	/* For -crawl it has already been done! */
		links_are_numbered())
		printlist(stdout, FALSE);
	    if (i != 0)
		printf("\n");
	}
#else
	status = mainloop();
	if (!no_list &&
	    !crawl &&		/* For -crawl it has already been done! */
	    links_are_numbered())
	    printlist(stdout, FALSE);
#endif
#ifdef USE_PERSISTENT_COOKIES
	/*
	 * We want to save cookies picked up when in immediate dump mode. 
	 * Instead of calling cleanup() here, let's only call this one.  - BJP
	 */
	if (persistent_cookies)
	    LYStoreCookies(LYCookieSaveFile);
#endif /* USE_PERSISTENT_COOKIES */
	exit_immediately(status);
    } else {
	/*
	 * Start an INTERACTIVE session.  - FM
	 */
#ifdef USE_COLOR_STYLE
	cache_tag_styles();
#endif

#ifndef NO_DUMP_WITH_BACKSPACES
	if (with_backspaces) {
	    /* we should warn about this somehow (nop for now) -VH */
	    with_backspaces = FALSE;
	}
#endif

#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
	init_charset_subsets();
#endif

	ena_csi((BOOLEAN) (LYlowest_eightbit[current_char_set] > 155));
	status = mainloop();
	LYCloseCloset(RECALL_URL);
	LYCloseCloset(RECALL_MAIL);
	cleanup();
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
	if (!isendwin()) {
	    if ((saved_scrsize_x != 0) && (saved_scrsize_y != 0)) {
		resize_term(saved_scrsize_y, saved_scrsize_x);
	    }
	}
#endif
	exit_immediately(status);
    }

    return (status);		/* though redundant, for compiler-warnings */
}

/*
 * Called by HTAccessInit to register any protocols supported by lynx. 
 * Protocols added by lynx:
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE, LYNXMESSAGES
 */
#ifdef GLOBALREF_IS_MACRO
extern GLOBALREF (HTProtocol, LYLynxKeymap);
extern GLOBALREF (HTProtocol, LYLynxCGI);
extern GLOBALREF (HTProtocol, LYLynxIMGmap);
extern GLOBALREF (HTProtocol, LYLynxCookies);
extern GLOBALREF (HTProtocol, LYLynxStatusMessages);

#else
GLOBALREF HTProtocol LYLynxKeymap;
GLOBALREF HTProtocol LYLynxCGI;
GLOBALREF HTProtocol LYLynxIMGmap;
GLOBALREF HTProtocol LYLynxCookies;
GLOBALREF HTProtocol LYLynxStatusMessages;
#endif /* GLOBALREF_IS_MACRO */

void LYRegisterLynxProtocols(void)
{
    HTRegisterProtocol(&LYLynxKeymap);
    HTRegisterProtocol(&LYLynxCGI);
    HTRegisterProtocol(&LYLynxIMGmap);
    HTRegisterProtocol(&LYLynxCookies);
    HTRegisterProtocol(&LYLynxStatusMessages);
}

#ifndef NO_CONFIG_INFO
/*
 * Some stuff to reload lynx.cfg without restarting new lynx session, also load
 * options menu items and command-line options to make things consistent.
 *
 * Called by user of interactive session by LYNXCFG://reload/ link.
 *
 * Warning:  experimental, more main() reorganization required.
 *	*Known* exceptions: persistent cookies, cookie files.
 *
 *	Some aspects of COLOR (with slang?).
 *	Viewer stuff, mailcap files
 *	SUFFIX, mime.types files
 *	RULESFILE/RULE
 *
 *	All work "somewhat", but not exactly as the first time.
 */
void reload_read_cfg(void)
{
    char *tempfile;
    FILE *rcfp;

    /*
     * no_option_save is always set for -anonymous and -validate.  It is better
     * to check for one or several specific restriction flags than for
     * 'LYRestricted', which doesn't get set for individual restrictions or for
     * -validate!  However, no_option_save may not be the appropriate one to
     * check - in that case, a new no_something should be added that gets
     * automatically set for -anonymous and -validate (and whether it applies
     * for -anonymous can be made installer- configurable in the usual way at
     * the bottom of userdefs.h).  - kw
     *
     */
    if (no_option_save) {
	/* current logic requires(?) that saving user preferences is
	   possible.  Additional applicable restrictions are already
	   checked by caller. - kw */
	return;
    }

    /*
     * Current user preferences are saved in a temporary file, to be read in
     * again after lynx.cfg has been read.  This avoids accidental changing of
     * the preferences file.  The regular preferences file doesn't even need to
     * exist, and won't be created as a side effect of this function.  Honoring
     * the no_option_save restriction may thus be unnecessarily restrictive,
     * but the check is currently still left in place.  - kw
     */
    tempfile = typecallocn(char, LY_MAXPATH);
    if (!tempfile) {
	HTAlwaysAlert(NULL, NOT_ENOUGH_MEMORY);
	return;
    }
    rcfp = LYOpenTemp(tempfile, ".rc", "w");
    if (rcfp == NULL) {
	FREE(tempfile);
	HTAlwaysAlert(NULL, CANNOT_OPEN_TEMP);
	return;
    }
    if (!save_rc(rcfp)) {
	HTAlwaysAlert(NULL, OPTIONS_NOT_SAVED);
	LYRemoveTemp(tempfile);
	FREE(tempfile);
	return;			/* can not write the very own file :( */
    } {
	/* set few safe flags: */
#ifdef USE_PERSISTENT_COOKIES
	BOOLEAN persistent_cookies_flag = persistent_cookies;
	char *LYCookieFile_flag = NULL;
	char *LYCookieSaveFile_flag = NULL;

	if (persistent_cookies) {
	    StrAllocCopy(LYCookieFile_flag, LYCookieFile);
	    StrAllocCopy(LYCookieSaveFile_flag, LYCookieSaveFile);
	}
#endif

#ifdef EXP_CHARSET_CHOICE
	custom_assumed_doc_charset = FALSE;
	custom_display_charset = FALSE;
	memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
#endif

#ifdef USE_PRETTYSRC
	html_src_on_lynxcfg_reload();
#endif
	/* free downloaders, printers, environments, dired menu */
	free_lynx_cfg();
#ifdef USE_SOURCE_CACHE
	source_cache_file_error = FALSE;	/* reset flag */
#endif

	/*
	 * Process the configuration file.
	 */
	read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);

	/*
	 * Process the temporary RC file.
	 */
	rcfp = fopen(tempfile, "r");
	read_rc(rcfp);
	LYRemoveTemp(tempfile);
	FREE(tempfile);		/* done with it - kw */

#ifdef EXP_CHARSET_CHOICE
	init_charset_subsets();
#endif

	/* We are not interested in startfile here */
	/* but other things may be lost: */

	/*
	 * Process any command line arguments not already handled.
	 */
	/* Not implemented yet here */

	/*
	 * Process any stdin-derived arguments for a lone "-" which we've
	 * loaded into LYStdinArgs.
	 */
	/* Not implemented yet here */

	/*
	 * Initialize other things based on the configuration read.
	 */
	if (user_mode == NOVICE_MODE) {
	    display_lines = LYlines - 4;
	} else {
	    display_lines = LYlines - 2;
	}
	/* Not implemented yet here,
	 * a major problem: file paths
	 * like lynx_save_space, LYCookieFile etc.
	 */
#ifdef USE_PERSISTENT_COOKIES
	/* restore old settings */
	if (persistent_cookies != persistent_cookies_flag) {
	    persistent_cookies = persistent_cookies_flag;
	    HTAlert(gettext("persistent cookies state will be changed in next session only."));
	}
	if (persistent_cookies) {
	    if (strcmp(LYCookieFile, LYCookieFile_flag)) {
		StrAllocCopy(LYCookieFile, LYCookieFile_flag);
		CTRACE((tfp,
			"cookie file can be changed in next session only, restored.\n"));
	    }
	    if (strcmp(LYCookieSaveFile, LYCookieSaveFile_flag)) {
		StrAllocCopy(LYCookieSaveFile, LYCookieSaveFile_flag);
		CTRACE((tfp,
			"cookie save file can be changed in next session only, restored.\n"));
	    }
	    FREE(LYCookieFile_flag);
	    FREE(LYCookieSaveFile_flag);
	}
#endif

    }
}
#endif /* !NO_CONFIG_INFO */

static void disable_pausing(void)
{
    AlertSecs = 0;
    DebugSecs = 0;
    InfoSecs = 0;
    MessageSecs = 0;
    ReplaySecs = 0;
}

static void force_dump_mode(void)
{
    dump_output_immediately = TRUE;
    disable_pausing();
    LYcols = DFT_COLS;
}

/* There are different ways of setting arguments on the command line, and
 * there are different types of arguments.  These include:
 *
 *   -set_some_variable		 ==> some_variable  = TRUE
 *   -toggle_some_variable	 ==> some_variable = !some_variable
 *   -some_variable=value	 ==> some_variable = value
 *
 * Others are complicated and require a function call.
 */

#define PARSE_SET(n,t,v,h) {n,    t, UNION_SET(v), h}
#define PARSE_INT(n,t,v,h) {n,    t, UNION_INT(v), h}
#define PARSE_STR(n,t,v,h) {n,    t, UNION_STR(v), h}
#define PARSE_FUN(n,t,v,h) {n,    t, UNION_FUN(v), h}
#define PARSE_NIL          {NULL, 0, UNION_DEF(0), NULL}

typedef struct parse_args_type {
    const char *name;
    int type;

#define TOGGLE_ARG		0x0010
#define SET_ARG			0x0020
#define UNSET_ARG		0x0030
#define FUNCTION_ARG		0x0040
#define LYSTRING_ARG		0x0050
#define INT_ARG			0x0060
#define STRING_ARG		0x0070
#define TIME_ARG		0x0080
#define ARG_TYPE_MASK		0x0FF0
#define NEED_NEXT_ARG		0x1000

#define NEED_INT_ARG		(NEED_NEXT_ARG | INT_ARG)
#define NEED_TIME_ARG		(NEED_NEXT_ARG | TIME_ARG)
#define NEED_LYSTRING_ARG	(NEED_NEXT_ARG | LYSTRING_ARG)
#define NEED_STRING_ARG		(NEED_NEXT_ARG | STRING_ARG)
#define NEED_FUNCTION_ARG	(NEED_NEXT_ARG | FUNCTION_ARG)

    /* If the NEED_NEXT_ARG flags is set, and the option was not specified
     * with an '=' character, then use the next argument in the argv list.
     */

      ParseData;
    const char *help_string;
} Config_Type;

/* -auth, -pauth */
static int parse_authentication(char *next_arg,
				char **result)
{
    /*
     * Authentication information for protected documents.
     */
    char *auth_info = 0;

    if (next_arg != 0) {
	StrAllocCopy(auth_info, next_arg);
	memset(next_arg, ' ', strlen(next_arg));	/* Let's not show too much */
    }

    if (auth_info != 0) {
	char *cp;

	if ((cp = strchr(auth_info, ':')) != 0) {	/* Pw */
	    *cp++ = '\0';	/* Terminate ID */
	    HTUnEscape(cp);
	    StrAllocCopy(result[1], cp);
	}
	if (*auth_info) {	/* Id */
	    HTUnEscape(auth_info);
	    StrAllocCopy(result[0], auth_info);
	}
	FREE(auth_info);
    }
    return 0;
}

/* -anonymous */
static int anonymous_fun(char *next_arg GCC_UNUSED)
{
    if (!LYValidate && !LYRestricted)
	parse_restrictions("default");
    LYRestricted = TRUE;
    return 0;
}

/* -assume_charset */
static int assume_charset_fun(char *next_arg)
{
    UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
    StrAllocCopy(UCAssume_MIMEcharset,
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
/*	   this may be a memory for bogus typo -
    StrAllocCopy(UCAssume_MIMEcharset, next_arg);
    LYLowerCase(UCAssume_MIMEcharset);   */

    return 0;
}

/* -assume_local_charset */
static int assume_local_charset_fun(char *next_arg)
{
    UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
    return 0;
}

/* -assume_unrec_charset */
static int assume_unrec_charset_fun(char *next_arg)
{
    UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(next_arg);
    return 0;
}

/* -auth */
static int auth_fun(char *next_arg)
{
    parse_authentication(next_arg, authentication_info);
    return 0;
}

/* -base */
static int base_fun(char *next_arg GCC_UNUSED)
{
    /*
     * Treat -source equivalently to an interactive download with
     * LYPrefixBaseToSource configured to TRUE, so that a BASE tag is prepended
     * for text/html content types.  We normally treat the module-wide global
     * LYPrefixBaseToSource flag as FALSE with -source, but force it TRUE,
     * later, if LYPrependBase is set TRUE here.  - FM
     */
    LYPrependBase = TRUE;
    if (HTOutputFormat == HTAtom_for("www/dump"))
	HTOutputFormat = HTAtom_for("www/download");

    return 0;
}

/* -cache */
static int cache_fun(char *next_arg)
{
    if (next_arg != 0)
	HTCacheSize = atoi(next_arg);
    /*
     * Limit size.
     */
    if (HTCacheSize < 2)
	HTCacheSize = 2;

    return 0;
}

/* -child */
static int child_fun(char *next_arg GCC_UNUSED)
{
    child_lynx = TRUE;
    no_disk_save = TRUE;
    return 0;
}

#ifdef USE_SLANG
/* -color */
static int color_fun(char *next_arg GCC_UNUSED)
{
    Lynx_Color_Flags |= SL_LYNX_USE_COLOR;

    if (LYShowColor != SHOW_COLOR_ALWAYS)
	LYShowColor = SHOW_COLOR_ON;

    return 0;
}
#endif

#ifdef MISC_EXP
/* -convert_to */
static int convert_to_fun(char *next_arg)
{
    if (next_arg != 0) {
	char *outformat = NULL;
	char *cp1, *cp2, *cp4;
	int chndl;

	StrAllocCopy(outformat, next_arg);
	/* not lowercased, to allow for experimentation - kw */
	/*LYLowerCase(outformat); */
	if ((cp1 = strchr(outformat, ';')) != NULL) {
	    if ((cp2 = LYstrstr(cp1, "charset")) != NULL) {
		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
		    cp2++;
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '"' &&
				 *cp4 != ';' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
		*cp4 = '\0';
		/* This is intentionally not the "safe" version,
		   to allow for experimentation. */
		chndl = UCGetLYhndl_byMIME(cp2);
		if (chndl < 0)
		    chndl = UCLYhndl_for_unrec;
		if (chndl < 0) {
		    fprintf(stderr,
			    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
		} else {
		    current_char_set = chndl;
		}
		*cp1 = '\0';	/* truncate outformat */
	    }
	}
	HTOutputFormat = HTAtom_for(outformat);
	FREE(outformat);
    } else {
	HTOutputFormat = NULL;
    }
    return 0;
}
#endif

/* -crawl */
static int crawl_fun(char *next_arg GCC_UNUSED)
{
    crawl = TRUE;
    LYcols = DFT_COLS;
    return 0;
}

/* -display */
static int display_fun(char *next_arg)
{
    if (next_arg != 0) {
	LYsetXDisplay(next_arg);
    }

    return 0;
}

/* -display_charset */
static int display_charset_fun(char *next_arg)
{
    int i = UCGetLYhndl_byMIME(next_arg);

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (i < 0 && !strcasecomp(next_arg, "auto"))
	i = auto_display_charset;
#endif
    if (i < 0) {		/* do nothing here: so fallback to lynx.cfg */
	fprintf(stderr,
		gettext("Lynx: ignoring unrecognized charset=%s\n"), next_arg);
    } else
	current_char_set = i;
    return 0;
}

/* -dump */
static int dump_output_fun(char *next_arg GCC_UNUSED)
{
    force_dump_mode();
    return 0;
}

/* -editor */
static int editor_fun(char *next_arg)
{
    if (next_arg != 0)
	StrAllocCopy(editor, next_arg);
    system_editor = TRUE;
    return 0;
}

/* -error_file */
static int error_file_fun(char *next_arg)
{
    /*
     * Output return (success/failure) code of an HTTP transaction.
     */
    if (next_arg != 0)
	http_error_file = next_arg;
    return 0;
}

#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
/* -exec */
static int exec_fun(char *next_arg GCC_UNUSED)
{
#ifndef NEVER_ALLOW_REMOTE_EXEC
    local_exec = TRUE;
#else
    local_exec_on_local_files = TRUE;
#endif /* NEVER_ALLOW_REMOTE_EXEC */
    return 0;
}
#endif

/* -get_data */
static int get_data_fun(char *next_arg GCC_UNUSED)
{
    /*
     * User data for GET form.
     */
    char **get_data;
    char *buf = NULL;

    /*
     * On Unix, conflicts with curses when interactive so let's force a dump. 
     * -CL
     *
     * On VMS, mods have been made in LYCurses.c to deal with potential
     * conflicts, so don't force the dump here.  - FM
     */
#ifndef VMS
    force_dump_mode();
#endif /* VMS */

    StrAllocCopy(form_get_data, "?");	/* Prime the pump */
    get_data = &form_get_data;

    /*
     * Build GET data for later.  Stop reading when we see a line with "---" as
     * its first three characters.
     */
    while (GetStdin(&buf, TRUE)) {
	StrAllocCat(*get_data, buf);
    }

    CTRACE((tfp, "get_data:%s\n", *get_data));
    CTRACE((tfp, "get_data:%s\n", form_get_data));
    return 0;
}

/* -help */
static int help_fun(char *next_arg GCC_UNUSED)
{
    print_help_and_exit(0);
    return 0;
}

/* -hiddenlinks */
static int hiddenlinks_fun(char *next_arg)
{
    /* *INDENT-OFF* */
    static Config_Enum table[] = {
	{ "merge",	HIDDENLINKS_MERGE },
	{ "listonly",	HIDDENLINKS_SEPARATE },
	{ "ignore",	HIDDENLINKS_IGNORE },
	{ NULL,		-1 },
    };
    /* *INDENT-ON* */

    if (next_arg != 0) {
	if (!LYgetEnum(table, next_arg, &LYHiddenLinks))
	    print_help_and_exit(-1);
    } else {
	LYHiddenLinks = HIDDENLINKS_MERGE;
    }

    return 0;
}

/* -homepage */
static int homepage_fun(char *next_arg)
{
    if (next_arg != 0) {
	StrAllocCopy(homepage, next_arg);
	LYEscapeStartfile(&homepage);
    }
    return 0;
}

/* -mime_header */
static int mime_header_fun(char *next_arg GCC_UNUSED)
{
    /*
     * Include mime headers and force source dump.
     */
    keep_mime_headers = TRUE;
    force_dump_mode();
    HTOutputFormat = (LYPrependBase ?
		      HTAtom_for("www/download") : HTAtom_for("www/dump"));
    LYcols = MAX_COLS;
    return 0;
}

#ifndef DISABLE_NEWS
/* -newschunksize */
static int newschunksize_fun(char *next_arg)
{
    if (next_arg != 0) {
	HTNewsChunkSize = atoi(next_arg);
	/*
	 * If the new HTNewsChunkSize exceeds the maximum,
	 * increase HTNewsMaxChunk to this size. - FM
	 */
	if (HTNewsChunkSize > HTNewsMaxChunk)
	    HTNewsMaxChunk = HTNewsChunkSize;
    }
    return 0;
}

/* -newsmaxchunk */
static int newsmaxchunk_fun(char *next_arg)
{
    if (next_arg) {
	HTNewsMaxChunk = atoi(next_arg);
	/*
	 * If HTNewsChunkSize exceeds the new maximum,
	 * reduce HTNewsChunkSize to this maximum. - FM
	 */
	if (HTNewsChunkSize > HTNewsMaxChunk)
	    HTNewsChunkSize = HTNewsMaxChunk;
    }
    return 0;
}
#endif /* not DISABLE_NEWS */

/* -nobold */
static int nobold_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(1);
    return 0;
}

/* -nobrowse */
static int nobrowse_fun(char *next_arg GCC_UNUSED)
{
    HTDirAccess = HT_DIR_FORBID;
    return 0;
}

/* -nocolor */
static int nocolor_fun(char *next_arg GCC_UNUSED)
{
    LYShowColor = SHOW_COLOR_NEVER;
#ifdef USE_SLANG
    Lynx_Color_Flags &= ~SL_LYNX_USE_COLOR;
    Lynx_Color_Flags |= SL_LYNX_OVERRIDE_COLOR;
#endif
    return 0;
}

/* -nopause */
static int nopause_fun(char *next_arg GCC_UNUSED)
{
    disable_pausing();
    return 0;
}

/* -noreverse */
static int noreverse_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(2);
    return 0;
}

/* -nounderline */
static int nounderline_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(4);
    return 0;
}

#ifdef MISC_EXP
/* -nozap */
static int nozap_fun(char *next_arg)
{
    LYNoZapKey = 1;		/* everything but "initially" treated as "full" - kw */
    if (next_arg != 0) {
	if (strcasecomp(next_arg, "initially") == 0)
	    LYNoZapKey = 2;

    }
    return 0;
}
#endif /* MISC_EXP */

/* -pauth */
static int pauth_fun(char *next_arg)
{
    parse_authentication(next_arg, proxyauth_info);
    return 0;
}

/* -post_data */
static int post_data_fun(char *next_arg GCC_UNUSED)
{
    /*
     * User data for POST form.
     */
    char **post_data;
    char *buf = NULL;

    /*
     * On Unix, conflicts with curses when interactive so let's force a dump.
     * - CL
     *
     * On VMS, mods have been made in LYCurses.c to deal with potential
     * conflicts, so don't force a dump here.  - FM
     */
#ifndef VMS
    force_dump_mode();
#endif /* VMS */

    post_data = &form_post_data;

    /*
     * Build post data for later.  Stop reading when we see a line with "---"
     * as its first three characters.
     */
    while (GetStdin(&buf, TRUE)) {
	StrAllocCat(*post_data, buf);
    }
    return 0;
}

static const char *show_restriction(const char *name)
{
    const char *value = 0;

    switch (find_restriction(name, -1)) {
    case TRUE:
	value = "on";
	break;
    case FALSE:
	value = "off";
	break;
    default:
	value = "?";
	break;
    }
    return value;
}

/* -restrictions */
static int restrictions_fun(char *next_arg)
{
    /* *INDENT-OFF* */
    static const struct {
	const char *name;
	const char *help;
    } table[] = {
	{ "all", "restricts all options." },
	{ "bookmark", "disallow changing the location of the bookmark file" },
	{ "bookmark_exec", "disallow execution links via the bookmark file" },
#if defined(DIRED_SUPPORT) && defined(OK_PERMIT)
	{ "change_exec_perms", "\
disallow changing the eXecute permission on files\n\
(but still allow it for directories) when local file\n\
management is enabled." },
#endif /* DIRED_SUPPORT && OK_PERMIT */
#ifdef SUPPORT_CHDIR
	{ "chdir", "\
disallow changing the working directory of lynx, e.g.,\n\
to affect the behavior of download command" },
#endif
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	{ "compileopts_info", "\
disable info on options used to compile the binary" },
#endif
	{ "default", "\
same as commandline option -anonymous.  Sets the\n\
default service restrictions for anonymous users.  Set to\n\
all restricted, except for: inside_telnet, outside_telnet,\n\
inside_ftp, outside_ftp, inside_rlogin, outside_rlogin,\n\
inside_news, outside_news, telnet_port, jump, mail, print,\n\
exec, and goto.  The settings for these, as well as\n\
additional goto restrictions for specific URL schemes\n\
that are also applied, are derived from definitions\n\
within userdefs.h." },
#ifdef DIRED_SUPPORT
	{ "dired_support", "disallow local file management" },
#endif /* DIRED_SUPPORT */
	{ "disk_save", "disallow saving to disk in the download and print menus" },
	{ "dotfiles", "disallow access to, or creation of, hidden (dot) files" },
	{ "download", "disallow some downloaders in the download menu" },
	{ "editor", "disallow editing" },
	{ "exec", "disable execution scripts" },
	{ "exec_frozen", "disallow the user from changing the execution link option" },
#ifdef USE_EXTERNALS
	{ "externals", "disable passing URLs to some external programs" },
#endif
	{ "file_url", "\
disallow using G)oto, served links or bookmarks for\n\
file: URL's" },
	{ "goto", "disable the 'g' (goto) command" },
#if !defined(HAVE_UTMP) || defined(VMS) /* not selective */
	{ "inside_ftp", "\
disallow ftps coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain (utmp required for selectivity)" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_telnet", "\
disallow telnets coming from inside your\n\
domain (utmp required for selectivity)" },
#else
	{ "inside_ftp", "\
disallow ftps coming from inside your domain" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your domain" },
	{ "inside_telnet", "\
disallow telnets coming from inside your domain" },
#endif /* HAVE_UTMP || VMS */
	{ "jump", "disable the 'j' (jump) command" },
	{ "lynxcfg_info", "\
disable viewing of lynx.cfg configuration file info" },
#ifndef NO_CONFIG_INFO
	{ "lynxcfg_xinfo", "\
disable extended lynx.cfg viewing and reloading" },
#endif
	{ "lynxcgi", "\
disallow execution of Lynx CGI URLs" },
	{ "mail", "disallow mail" },
	{ "multibook", "disallow multiple bookmark files" },
	{ "news_post", "disallow USENET News posting." },
	{ "option_save", "disallow saving options in .lynxrc" },
#if !defined(HAVE_UTMP) || defined(VMS) /* not selective */
	{ "outside_ftp", "\
disallow ftps coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain (utmp required for selectivity)" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_telnet", "\
disallow telnets coming from outside your\n\
domain (utmp required for selectivity)" },
#else
	{ "outside_ftp", "\
disallow ftp coming from outside your domain" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your domain" },
	{ "outside_telnet", "\
disallow telnets coming from outside your domain" },
#endif /* !HAVE_UTMP || VMS */
	{ "print", "disallow most print options" },
	{ "shell", "\
disallow shell escapes, and lynxexec, lynxprog or lynxcgi\n\
G)oto's" },
	{ "suspend", "disallow Control-Z suspends with escape to shell" },
	{ "telnet_port", "disallow specifying a port in telnet G)oto's" },
	{ "useragent", "disallow modifications of the User-Agent header" },
    };
    /* *INDENT-ON* */

    static const char *Usage[] =
    {
	""
	,"USAGE: lynx -restrictions=[option][,option][,option]"
	,"List of Options:"
	,"  ?                 when used alone, list restrictions in effect."

    };
    unsigned j, k, column = 0;
    const char *name;
    const char *value;
    BOOLEAN found, first;

    if (isEmpty(next_arg)) {
	SetOutputMode(O_TEXT);
	for (j = 0; j < TABLESIZE(Usage); j++) {
	    printf("%s\n", Usage[j]);
	}
	for (j = 0; j < TABLESIZE(table); j++) {
	    if (!strcmp(table[j].name, "all")
		|| !strcmp(table[j].name, "default")) {
		value = NULL;
	    } else {
		value = show_restriction(table[j].name);
	    }
	    print_help_strings(table[j].name, table[j].help, value, FALSE);
	}
	first = TRUE;
	for (j = 0;; j++) {
	    found = FALSE;
	    if ((name = index_to_restriction(j)) == 0) {
		break;
	    }
	    for (k = 0; k < TABLESIZE(table); k++) {
		if (!strcmp(name, table[k].name)) {
		    found = TRUE;
		}
	    }
	    if (!found) {
		if (first) {
		    printf("Other restrictions (see the user's guide):\n");
		}
		value = show_restriction(table[j].name);
		printf("%s%s (%s)", column ? ", " : "  ", name, value);
		column += 5 + strlen(name) + strlen(value);
		if (column > 50) {
		    column = 0;
		    printf("\n");
		}
		first = FALSE;
	    }
	}
	if (column)
	    printf("\n");
	SetOutputMode(O_BINARY);
	exit_immediately(EXIT_SUCCESS);
    } else if (*next_arg == '?') {
	SetOutputMode(O_TEXT);
	print_restrictions_to_fd(stdout);
	SetOutputMode(O_BINARY);
	exit_immediately(EXIT_SUCCESS);
    } else {
	parse_restrictions(next_arg);
    }
    return 0;
}

/* -selective */
static int selective_fun(char *next_arg GCC_UNUSED)
{
    HTDirAccess = HT_DIR_SELECTIVE;
    return 0;
}

/* -source */
static int source_fun(char *next_arg GCC_UNUSED)
{
    force_dump_mode();
    HTOutputFormat = (LYPrependBase ?
		      HTAtom_for("www/download") : HTAtom_for("www/dump"));
    LYcols = MAX_COLS;
    return 0;
}

/* -traversal */
static int traversal_fun(char *next_arg GCC_UNUSED)
{
    traversal = TRUE;
#ifdef USE_SLANG
    LYcols = DFT_COLS;
#else
    LYcols = MAX_COLS;
#endif /* USE_SLANG */

    return 0;
}

/* -version */
static int version_fun(char *next_arg GCC_UNUSED)
{
    char *result = NULL;

    SetOutputMode(O_TEXT);

    HTSprintf0(&result, gettext("%s Version %s (%s)"),
	       LYNX_NAME, LYNX_VERSION,
	       LYVersionDate());
#ifdef USE_SSL
    StrAllocCat(result, "\n");
    HTSprintf(&result, "libwww-FM %s,", HTLibraryVersion);
    append_ssl_version(&result, " ");
#endif /* USE_SSL */

#if defined(NCURSES) && defined(HAVE_CURSES_VERSION)
    HTSprintf(&result, ", %s", curses_version());
#if defined(WIDEC_CURSES)
    HTSprintf(&result, "(wide)");
#endif
#elif defined(PDCURSES) && defined(PDC_BUILD)
    HTSprintf(&result, ", pdcurses %.3f", PDC_BUILD * 0.001);
#elif defined(USE_SLANG) && defined(SLANG_VERSION_STRING)
    HTSprintf(&result, ", s-lang %s", SLANG_VERSION_STRING);
#endif

    printf("%s\n", result);
    free(result);

#ifndef __DATE__
#define __DATE__ ""
#endif
#ifndef __TIME__
#define __TIME__ ""
#endif

/*
 * SYSTEM_NAME is set by the configure script.  Show build date/time for other
 * systems, according to predefined compiler symbols.
 */
#ifdef SYSTEM_NAME
    printf(gettext("Built on %s %s %s\n"), SYSTEM_NAME, __DATE__, __TIME__);
#else
#ifdef __CYGWIN__
    printf("Compiled by CYGWIN (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __BORLANDC__
    printf("Compiled by Borland C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef _MSC_VER
    printf("Compiled by Microsoft Visual C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __DJGPP__
    printf("Compiled by DJGPP (%s %s).\n", __DATE__, __TIME__);
#else
    printf("Compiled at (%s %s).\n", __DATE__, __TIME__);
#endif /* __DJGPP__ */
#endif /* _MSC_VER */
#endif /* __BORLANDC__ */
#endif /* __CYGWIN__ */
#endif

    puts("");
    puts(gettext("Copyrights held by the University of Kansas, CERN, and other contributors."));
    puts(gettext("Distributed under the GNU General Public License."));
    puts(gettext("See http://lynx.isc.org/ and the online help for more information."));
    puts("");
#ifdef USE_SSL
    puts("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.");
#ifdef OPENSSL_VERSION_TEXT
    puts("See http://www.openssl.org/ for information about OpenSSL.");
#endif /* OPENSSL_VERSION_TEXT */
    puts("");
#endif /* USE_SSL */

    SetOutputMode(O_BINARY);

    exit_immediately(EXIT_SUCCESS);
    /* NOT REACHED */
    return 0;
}

/* -width */
static int width_fun(char *next_arg)
{
    if (next_arg != 0) {
	int w = atoi(next_arg);

	if (w > 0)
	    dump_output_width = ((w < MAX_COLS) ? w : MAX_COLS);
    }

    return 0;
}

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* -scrsize */
static int scrsize_fun(char *next_arg)
{
    if (next_arg != 0) {
	char *cp;

	if ((cp = strchr(next_arg, ',')) != 0) {
	    *cp++ = '\0';	/* Terminate ID */
	    scrsize_x = atoi(next_arg);
	    scrsize_y = atoi(cp);
	    if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
		scrsize_x = scrsize_y = 0;
	    }
	    if ((scrsize_x > 0) && (scrsize_x < 80)) {
		scrsize_x = 80;
	    }
	    if ((scrsize_y > 0) && (scrsize_y < 4)) {
		scrsize_y = 4;
	    }
	    CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
	}
    }
    return 0;
}
#endif

/* NOTE: This table is sorted by name to make the help message useful */
/* *INDENT-OFF* */
static Config_Type Arg_Table [] =
{
   PARSE_SET(
      "accept_all_cookies", 4|SET_ARG,		LYAcceptAllCookies,
      "\naccept cookies without prompting if Set-Cookie handling\nis on"
   ),
   PARSE_FUN(
      "anonymous",	2|FUNCTION_ARG,		anonymous_fun,
      "apply restrictions for anonymous account,\nsee also -restrictions"
   ),
   PARSE_FUN(
      "assume_charset", 4|NEED_FUNCTION_ARG,	assume_charset_fun,
      "=MIMEname\ncharset for documents that don't specify it"
   ),
   PARSE_FUN(
      "assume_local_charset",	4|NEED_FUNCTION_ARG,assume_local_charset_fun,
      "=MIMEname\ncharset assumed for local files"
   ),
   PARSE_FUN(
      "assume_unrec_charset",	4|NEED_FUNCTION_ARG,assume_unrec_charset_fun,
      "=MIMEname\nuse this instead of unrecognized charsets"
   ),
   PARSE_FUN(
      "auth",		4|NEED_FUNCTION_ARG,	auth_fun,
      "=id:pw\nauthentication information for protected documents"
   ),
   PARSE_FUN(
      "base",		4|FUNCTION_ARG,		base_fun,
      "prepend a request URL comment and BASE tag to text/html\noutputs for -source dumps"
   ),
#ifndef DISABLE_BIBP
   PARSE_STR(
      "bibhost",	4|NEED_LYSTRING_ARG,	BibP_bibhost,
      "=URL\nlocal bibp server (default http://bibhost/)"
   ),
#endif
#ifdef USE_BLINK
   PARSE_SET(
      "blink",		4|SET_ARG,		term_blink_is_boldbg,
      "enable bright background via the BLINK terminal attribute"
   ),
#endif
   PARSE_SET(
      "book",		4|SET_ARG,		bookmark_start,
      "use the bookmark page as the startfile"
   ),
   PARSE_SET(
      "buried_news",	4|TOGGLE_ARG,		scan_for_buried_news_references,
      "toggles scanning of news articles for buried references"
   ),
   PARSE_FUN(
      "cache",		4|NEED_FUNCTION_ARG,	cache_fun,
      "=NUMBER\nNUMBER of documents cached in memory"
   ),
   PARSE_SET(
      "case",		4|SET_ARG,		case_sensitive,
      "enable case sensitive user searching"
   ),
   PARSE_SET(
      "center",		4|TOGGLE_ARG,		no_table_center,
      "toggle center alignment in HTML TABLE"
   ),
   PARSE_STR(
      "cfg",		2|NEED_LYSTRING_ARG,	lynx_cfg_file,
      "=FILENAME\nspecifies a lynx.cfg file other than the default"
   ),
   PARSE_FUN(
      "child",		4|FUNCTION_ARG,		child_fun,
      "exit on left-arrow in startfile, and disable save to disk"
   ),
#ifdef EXP_CMD_LOGGING
   PARSE_STR(
       "cmd_log",	2|NEED_LYSTRING_ARG,	lynx_cmd_logfile,
       "=FILENAME\nlog keystroke commands to the given file"
   ),
   PARSE_STR(
       "cmd_script",	2|NEED_LYSTRING_ARG,	lynx_cmd_script,
       "=FILENAME\nread keystroke commands from the given file\n(see -cmd_log)"
   ),
#endif
#ifdef USE_SLANG
   PARSE_FUN(
      "color",		4|FUNCTION_ARG,		color_fun,
      "force color mode on with standard bg colors"
   ),
#endif
   PARSE_INT(
      "connect_timeout", 4|NEED_INT_ARG,	connect_timeout,
      "=N\nset the N-second connection timeout"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "convert_to",	4|FUNCTION_ARG,		convert_to_fun,
      "=FORMAT\nconvert input, FORMAT is in MIME type notation\n(experimental)"
   ),
#endif
#ifdef USE_PERSISTENT_COOKIES
   PARSE_STR(
      "cookie_file",	4|LYSTRING_ARG,		LYCookieFile,
      "=FILENAME\nspecifies a file to use to read cookies"
   ),
   PARSE_STR(
      "cookie_save_file",	4|LYSTRING_ARG,	LYCookieSaveFile,
      "=FILENAME\nspecifies a file to use to store cookies"
   ),
#endif /* USE_PERSISTENT_COOKIES */
   PARSE_SET(
      "cookies",	4|TOGGLE_ARG,		LYSetCookies,
      "toggles handling of Set-Cookie headers"
   ),
#ifndef VMS
   PARSE_SET(
      "core",		4|TOGGLE_ARG,		LYNoCore,
      "toggles forced core dumps on fatal errors"
   ),
#endif
   PARSE_FUN(
      "crawl",		4|FUNCTION_ARG,		crawl_fun,
      "with -traversal, output each page to a file\n\
with -dump, format output as with -traversal, but to stdout"
   ),
#ifdef USE_CURSES_PADS
   PARSE_SET(
      "curses_pads",	4|TOGGLE_ARG,		LYuseCursesPads,
      "uses curses pad feature to support left/right shifting"
   ),
#endif
#ifdef DISP_PARTIAL
   PARSE_SET(
      "debug_partial",	4|TOGGLE_ARG,		debug_display_partial,
      "incremental display stages with MessageSecs delay"
   ),
#endif
   PARSE_INT(
      "delay",		4|NEED_TIME_ARG,	DebugSecs,
      "=NNN\nset NNN-second delay at statusline message"
   ),
   PARSE_FUN(
      "display",	4|NEED_FUNCTION_ARG,	display_fun,
      "=DISPLAY\nset the display variable for X exec'ed programs"
   ),
   PARSE_FUN(
      "display_charset", 4|NEED_FUNCTION_ARG,	display_charset_fun,
      "=MIMEname\ncharset for the terminal output"
   ),
   PARSE_SET(
      "dont_wrap_pre",	4|SET_ARG,		dont_wrap_pre,
      "inhibit wrapping of text in <pre> when -dump'ing and\n\
-crawl'ing, mark wrapped lines in interactive session"
   ),
   PARSE_FUN(
      "dump",		4|FUNCTION_ARG,		dump_output_fun,
      "dump the first file to stdout and exit"
   ),
   PARSE_FUN(
      "editor",		4|NEED_FUNCTION_ARG,	editor_fun,
      "=EDITOR\nenable edit mode with specified editor"
   ),
   PARSE_SET(
      "emacskeys",	4|SET_ARG,		emacs_keys,
      "enable emacs-like key movement"
   ),
   PARSE_SET(
      "enable_scrollback", 4|TOGGLE_ARG,	enable_scrollback,
      "\ntoggles compatibility with comm programs' scrollback\n\
keys (may be incompatible with some curses packages)"
   ),
   PARSE_FUN(
      "error_file",	4|NEED_FUNCTION_ARG,	error_file_fun,
      "=FILE\nwrite the HTTP status code here"
   ),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
#ifndef NEVER_ALLOW_REMOTE_EXEC
   PARSE_FUN(
      "exec",		4|FUNCTION_ARG,		exec_fun,
      "enable local program execution"
   ),
#endif
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#ifdef VMS
   PARSE_SET(
      "fileversions",	4|SET_ARG,		HTVMSFileVersions,
      "include all versions of files in local VMS directory\nlistings"
   ),
#endif
#ifdef LY_FIND_LEAKS
   PARSE_SET(
      "find_leaks",	4|TOGGLE_ARG,		LYfind_leaks,
      "toggles memory-leak checking"
   ),
#endif
   PARSE_SET(
      "force_empty_hrefless_a",	4|SET_ARG,	force_empty_hrefless_a,
      "\nforce HREF-less 'A' elements to be empty (close them as\nsoon as they are seen)"
   ),
   PARSE_SET(
      "force_html",	4|SET_ARG,		LYforce_HTML_mode,
      "forces the first document to be interpreted as HTML"
   ),
   PARSE_SET(
      "force_secure",	4|TOGGLE_ARG,		LYForceSSLCookiesSecure,
      "toggles forcing of the secure flag for SSL cookies"
   ),
#if !defined(NO_OPTION_FORMS) && !defined(NO_OPTION_MENU)
   PARSE_SET(
      "forms_options",	4|TOGGLE_ARG,		LYUseFormsOptions,
      "toggles forms-based vs old-style options menu"
   ),
#endif
   PARSE_SET(
      "from",		4|TOGGLE_ARG,		LYNoFromHeader,
      "toggle transmission of From headers"
   ),
   PARSE_SET(
      "ftp",		4|UNSET_ARG,		ftp_ok,
      "disable ftp access"
   ),
   PARSE_FUN(
      "get_data",	2|FUNCTION_ARG,		get_data_fun,
      "user data for get forms, read from stdin,\nterminated by '---' on a line"
   ),
   PARSE_SET(
      "head",		4|SET_ARG,		HEAD_request,
      "send a HEAD request"
   ),
   PARSE_FUN(
      "help",		1|FUNCTION_ARG,		help_fun,
      "print this usage message"
   ),
   PARSE_FUN(
      "hiddenlinks",	4|NEED_FUNCTION_ARG,	hiddenlinks_fun,
      "=[option]\nhidden links: options are merge, listonly, or ignore"
   ),
   PARSE_SET(
      "historical",	4|TOGGLE_ARG,		historical_comments,
      "toggles use of '>' or '-->' as terminator for comments"
   ),
   PARSE_FUN(
      "homepage",	4|NEED_FUNCTION_ARG,	homepage_fun,
      "=URL\nset homepage separate from start page"
   ),
   PARSE_SET(
      "image_links",	4|TOGGLE_ARG,		clickable_images,
      "toggles inclusion of links for all images"
   ),
   PARSE_STR(
      "index",		4|NEED_LYSTRING_ARG,	indexfile,
      "=URL\nset the default index file to URL"
   ),
   PARSE_SET(
      "ismap",		4|TOGGLE_ARG,		LYNoISMAPifUSEMAP,
      "toggles inclusion of ISMAP links when client-side\nMAPs are present"
   ),
#ifdef EXP_JUSTIFY_ELTS
   PARSE_SET(
      "justify",	4|SET_ARG,		ok_justify,
      "do justification of text"
   ),
#endif
   PARSE_INT(
      "link",		4|NEED_INT_ARG,		crawl_count,
      "=NUMBER\nstarting count for lnk#.dat files produced by -crawl"
   ),
   PARSE_SET(
      "listonly",	4|TOGGLE_ARG,		dump_links_only,
      "with -dump, forces it to show only the list of links"
   ),
   PARSE_SET(
      "localhost",	4|SET_ARG,		local_host_only,
      "disable URLs that point to remote hosts"
   ),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "locexec",	4|SET_ARG,		local_exec_on_local_files,
      "enable local program execution from local files only"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#if defined(USE_COLOR_STYLE)
   PARSE_STR(
      "lss",		2|NEED_LYSTRING_ARG,	lynx_lss_file,
      "=FILENAME\nspecifies a lynx.lss file other than the default"
   ),
#endif
   PARSE_FUN(
      "mime_header",	4|FUNCTION_ARG,		mime_header_fun,
      "include mime headers and force source dump"
   ),
   PARSE_SET(
      "minimal",	4|TOGGLE_ARG,		minimal_comments,
      "toggles minimal versus valid comment parsing"
   ),
#ifdef EXP_NESTED_TABLES
   PARSE_SET(
      "nested_tables",	4|TOGGLE_ARG,		nested_tables,
      "toggles nested-tables logic"
   ),
#endif
#ifndef DISABLE_NEWS
   PARSE_FUN(
      "newschunksize",	4|NEED_FUNCTION_ARG,	newschunksize_fun,
      "=NUMBER\nnumber of articles in chunked news listings"
   ),
   PARSE_FUN(
      "newsmaxchunk",	4|NEED_FUNCTION_ARG,	newsmaxchunk_fun,
      "=NUMBER\nmaximum news articles in listings before chunking"
   ),
#endif
#if USE_BLAT_MAILER
   PARSE_SET(
      "noblat",		4|TOGGLE_ARG,		mail_is_blat,
      "select mail tool (`BLAT' ==> `sendmail')"
   ),
#endif
   PARSE_FUN(
      "nobold",		4|FUNCTION_ARG,		nobold_fun,
      "disable bold video-attribute"
   ),
   PARSE_FUN(
      "nobrowse",	4|FUNCTION_ARG,		nobrowse_fun,
      "disable directory browsing"
   ),
   PARSE_SET(
      "nocc",		4|SET_ARG,		LYNoCc,
      "disable Cc: prompts for self copies of mailings"
   ),
   PARSE_FUN(
      "nocolor",	4|FUNCTION_ARG,		nocolor_fun,
      "turn off color support"
   ),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "noexec",		4|UNSET_ARG,		local_exec,
      "disable local program execution (DEFAULT)"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
   PARSE_SET(
      "nofilereferer",	4|SET_ARG,		no_filereferer,
      "disable transmission of Referer headers for file URLs"
   ),
   PARSE_SET(
      "nolist",		4|SET_ARG,		no_list,
      "disable the link list feature in dumps"
   ),
   PARSE_SET(
      "nolog",		4|UNSET_ARG,		error_logging,
      "disable mailing of error messages to document owners"
   ),
#if defined(HAVE_SIGACTION) && defined(SIGWINCH)
   PARSE_SET(
      "nonrestarting_sigwinch", 4|SET_ARG,	LYNonRestartingSIGWINCH,
      "\nmake window size change handler non-restarting"
   ),
#endif /* HAVE_SIGACTION */
   PARSE_SET(
      "nonumbers",	4|SET_ARG,		no_numbers,
      "disable the link/form numbering feature in dumps"
   ),
   PARSE_FUN(
      "nopause",	4|FUNCTION_ARG,		nopause_fun,
      "disable forced pauses for statusline messages"
   ),
   PARSE_SET(
      "noprint",	4|SET_ARG,		no_print,
      "disable some print functions, like -restrictions=print"
   ),
   PARSE_SET(
      "noredir",	4|SET_ARG,		no_url_redirection,
      "don't follow Location: redirection"
   ),
   PARSE_SET(
      "noreferer",	4|SET_ARG,		LYNoRefererHeader,
      "disable transmission of Referer headers"
   ),
   PARSE_FUN(
      "noreverse",	4|FUNCTION_ARG,		noreverse_fun,
      "disable reverse video-attribute"
   ),
#ifdef SOCKS
   PARSE_SET(
      "nosocks",	2|UNSET_ARG,		socks_flag,
      "don't use SOCKS proxy for this session"
   ),
#endif
   PARSE_SET(
      "nostatus",	4|SET_ARG,		no_statusline,
      "disable the miscellaneous information messages"
   ),
   PARSE_FUN(
      "nounderline",	4|FUNCTION_ARG,		nounderline_fun,
      "disable underline video-attribute"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "nozap",		4|FUNCTION_ARG,		nozap_fun,
      "=DURATION (\"initially\" or \"full\") disable checks for 'z' key"
   ),
#endif
   PARSE_SET(
      "number_fields",	4|SET_ARG,		number_fields,
      "force numbering of links as well as form input fields"
   ),
   PARSE_SET(
      "number_links",	4|SET_ARG,		number_links,
      "force numbering of links"
   ),
#ifdef DISP_PARTIAL
   PARSE_SET(
      "partial",	4|TOGGLE_ARG,		display_partial_flag,
      "toggles display partial pages while downloading"
   ),
   PARSE_INT(
      "partial_thres",	4|NEED_INT_ARG,		partial_threshold,
      "[=NUMBER]\nnumber of lines to render before repainting display\n\
with partial-display logic"
   ),
#endif
   PARSE_FUN(
      "pauth",		4|NEED_FUNCTION_ARG,	pauth_fun,
      "=id:pw\nauthentication information for protected proxy server"
   ),
   PARSE_SET(
      "popup",		4|UNSET_ARG,		LYUseDefSelPop,
      "toggles handling of single-choice SELECT options via\npopup windows or as lists of radio buttons"
   ),
   PARSE_FUN(
      "post_data",	2|FUNCTION_ARG,		post_data_fun,
      "user data for post forms, read from stdin,\nterminated by '---' on a line"
   ),
   PARSE_SET(
      "preparsed",	4|SET_ARG,		LYPreparsedSource,
      "show parsed text/html with -source and in source view\n\
to visualize how lynx behaves with invalid HTML"
   ),
#ifdef USE_PRETTYSRC
   PARSE_SET(
      "prettysrc",	4|SET_ARG,		LYpsrc,
      "do syntax highlighting and hyperlink handling in source\nview"
   ),
#endif
   PARSE_SET(
      "print",		4|UNSET_ARG,		no_print,
      "enable print functions (DEFAULT), opposite of -noprint"
   ),
   PARSE_SET(
      "pseudo_inlines", 4|TOGGLE_ARG,		pseudo_inline_alts,
      "toggles pseudo-ALTs for inlines with no ALT string"
   ),
   PARSE_SET(
      "raw",		4|UNSET_ARG,		LYUseDefaultRawMode,
      "toggles default setting of 8-bit character translations\n\
or CJK mode for the startup character set"
   ),
   PARSE_SET(
      "realm",		4|SET_ARG,		check_realm,
      "restricts access to URLs in the starting realm"
   ),
   PARSE_SET(
      "reload",		4|SET_ARG,		reloading,
      "flushes the cache on a proxy server\n(only the first document affected)"
   ),
   PARSE_FUN(
      "restrictions",	4|FUNCTION_ARG,		restrictions_fun,
      "=[options]\nuse -restrictions to see list"
   ),
   PARSE_SET(
      "resubmit_posts", 4|TOGGLE_ARG,		LYresubmit_posts,
      "toggles forced resubmissions (no-cache) of forms with\n\
method POST when the documents they returned are sought\n\
with the PREV_DOC command or from the History List"
   ),
   PARSE_SET(
      "rlogin",		4|UNSET_ARG,		rlogin_ok,
      "disable rlogins"
   ),
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
   PARSE_FUN(
      "scrsize",	4|NEED_FUNCTION_ARG,	scrsize_fun,
      "=width,height\nsize of window"
   ),
#endif
#ifdef USE_SCROLLBAR
   PARSE_SET(
      "scrollbar",	4|TOGGLE_ARG,		LYShowScrollbar,
      "toggles showing scrollbar"
   ),
   PARSE_SET(
      "scrollbar_arrow", 4|TOGGLE_ARG,		LYsb_arrow,
      "toggles showing arrows at ends of the scrollbar"
   ),
#endif
   PARSE_FUN(
      "selective",	4|FUNCTION_ARG,		selective_fun,
      "require .www_browsable files to browse directories"
   ),
   PARSE_SET(
      "short_url",	4|SET_ARG,		long_url_ok,
      "enables examination of beginning and end of long URL in\nstatus line"
   ),
#ifdef SH_EX
   PARSE_SET(
      "show_cfg",	1|SET_ARG,		show_cfg,
      "Show `LYNX.CFG' setting"
   ),
#endif
   PARSE_SET(
      "show_cursor",	4|TOGGLE_ARG,		LYUseDefShoCur,
      "toggles hiding of the cursor in the lower right corner"
   ),
#ifdef USE_READPROGRESS
   PARSE_SET(
      "show_rate",	4|TOGGLE_ARG,		LYShowTransferRate,
      "toggles display of transfer rate"
   ),
#endif
   PARSE_SET(
      "soft_dquotes",	4|TOGGLE_ARG,		soft_dquotes,
      "toggles emulation of the old Netscape and Mosaic bug which\n\
treated '>' as a co-terminator for double-quotes and tags"
   ),
   PARSE_FUN(
      "source",		4|FUNCTION_ARG,		source_fun,
      "dump the source of the first file to stdout and exit"
   ),
   PARSE_SET(
      "stack_dump",	4|SET_ARG,		stack_dump,
      "disable SIGINT cleanup handler"
   ),
   PARSE_SET(
      "startfile_ok",	4|SET_ARG,		startfile_ok,
      "allow non-http startfile and homepage with -validate"
   ),
   PARSE_SET(
      "stdin",		4|SET_ARG,		startfile_stdin,
      "read startfile from standard input"
   ),
#ifdef SYSLOG_REQUESTED_URLS
   PARSE_STR(
      "syslog",		4|NEED_LYSTRING_ARG,	syslog_txt,
      "=text\ninformation for syslog call"
   ),
   PARSE_SET(
      "syslog-urls",	4|SET_ARG,		syslog_requested_urls,
      "log requested URLs with syslog"
   ),
#endif
   PARSE_SET(
      "tagsoup",	4|SET_ARG,		DTD_recovery,
      "use TagSoup rather than SortaSGML parser"
   ),
   PARSE_SET(
      "telnet",		4|UNSET_ARG,		telnet_ok,
      "disable telnets"
   ),
   PARSE_STR(
      "term",		4|NEED_STRING_ARG,	terminal,
      "=TERM\nset terminal type to TERM"
   ),
#ifdef _WINDOWS
   PARSE_INT(
      "timeout",	4|INT_ARG,		lynx_timeout,
      "=NUMBER\nset TCP/IP timeout"
   ),
#endif
   PARSE_SET(
      "tlog",		2|TOGGLE_ARG,		LYUseTraceLog,
      "toggles use of a Lynx Trace Log for the current session"
   ),
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
   PARSE_SET(
      "tna",		4|SET_ARG,		textfields_activation_option,
      "turn on \"Textfields Need Activation\" mode"
   ),
#endif
#ifndef NO_LYNX_TRACE
   PARSE_SET(
      "trace",		2|SET_ARG,		WWW_TraceFlag,
      "turns on Lynx trace mode"
   ),
   PARSE_INT(
      "trace_mask",	2|INT_ARG,		WWW_TraceMask,
      "customize Lynx trace mode"
   ),
#endif
   PARSE_FUN(
      "traversal",	4|FUNCTION_ARG,		traversal_fun,
      "traverse all http links derived from startfile"
   ),
   PARSE_SET(
      "trim_input_fields", 2|SET_ARG,		LYtrimInputFields,
      "trim input text/textarea fields in forms"
   ),
   PARSE_SET(
      "underline_links",4|TOGGLE_ARG,		LYUnderlineLinks,
      "toggles use of underline/bold attribute for links"
   ),
   PARSE_SET(
      "underscore",	4|TOGGLE_ARG,		use_underscore,
      "toggles use of _underline_ format in dumps"
   ),
#if defined(USE_MOUSE)
   PARSE_SET(
      "use_mouse",	4|SET_ARG,		LYUseMouse,
      "turn on mouse support"
   ),
#endif
   PARSE_STR(
      "useragent",	4|NEED_LYSTRING_ARG,	LYUserAgent,
      "=Name\nset alternate Lynx User-Agent header"
   ),
   PARSE_SET(
      "validate",	2|SET_ARG,		LYValidate,
      "accept only http URLs (meant for validation)\nimplies more restrictions than -anonymous, but\ngoto is allowed for http and https"
   ),
   PARSE_SET(
      "verbose",	4|TOGGLE_ARG,		verbose_img,
      "toggles [LINK], [IMAGE] and [INLINE] comments \nwith filenames of these images"
   ),
   PARSE_FUN(
      "version",	4|FUNCTION_ARG,		version_fun,
      "print Lynx version information"
   ),
   PARSE_SET(
      "vikeys",		4|SET_ARG,		vi_keys,
      "enable vi-like key movement"
   ),
#ifdef __DJGPP__
   PARSE_SET(
      "wdebug",		4|TOGGLE_ARG,		watt_debug,
      "enables Waterloo tcp/ip packet debug. Prints to watt\ndebugfile"
  ),
#endif /* __DJGPP__ */
   PARSE_FUN(
      "width",		4|NEED_FUNCTION_ARG,	width_fun,
      "=NUMBER\nscreen width for formatting of dumps (default is 80)"
   ),
#ifndef NO_DUMP_WITH_BACKSPACES
   PARSE_SET(
      "with_backspaces", 4|SET_ARG,		with_backspaces,
      "emit backspaces in output if -dumping or -crawling\n(like 'man' does)"
   ),
#endif
   PARSE_NIL
};
/* *INDENT-ON* */

static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       BOOLEAN option)
{
    int pad;
    int c;
    int first;
    int field_width = 20;

    pad = field_width - (2 + option + (int) strlen(name));

    fprintf(stdout, "  %s%s", option ? "-" : "", name);

    if (*help != '=') {
	pad--;
	while (pad > 0) {
	    fputc(' ', stdout);
	    pad--;
	}
	fputc(' ', stdout);	/* at least one space */
	first = 0;
    } else {
	first = pad;
    }

    if (strchr(help, '\n') == 0) {
	fprintf(stdout, "%s", help);
    } else {
	while ((c = *help) != 0) {
	    if (c == '\n') {
		if ((pad = --first) < 0) {
		    pad = field_width;
		} else {
		    c = ' ';
		}
		fputc(c, stdout);
		while (pad--)
		    fputc(' ', stdout);
	    } else {
		fputc(c, stdout);
	    }
	    help++;
	    first--;
	}
    }
    if (value)
	printf(" (%s)", value);
    fputc('\n', stdout);
}

static void print_help_and_exit(int exit_status)
{
    Config_Type *p;

    if (pgm == NULL)
	pgm = "lynx";

    SetOutputMode(O_TEXT);

    fprintf(stdout, gettext("USAGE: %s [options] [file]\n"), pgm);
    fprintf(stdout, gettext("Options are:\n"));
#ifdef VMS
    print_help_strings("",
		       "receive the arguments from stdin (enclose\n\
in double-quotes (\"-\") on VMS)", NULL, TRUE);
#else
    print_help_strings("", "receive options and arguments from stdin", NULL, TRUE);
#endif /* VMS */

    for (p = Arg_Table; p->name != 0; p++) {
	char temp[LINESIZE], *value = temp;
	ParseUnionPtr q = ParseUnionOf(p);

	switch (p->type & ARG_TYPE_MASK) {
	case TOGGLE_ARG:
	case SET_ARG:
	    strcpy(temp, *(q->set_value) ? "on" : "off");
	    break;
	case UNSET_ARG:
	    strcpy(temp, *(q->set_value) ? "off" : "on");
	    break;
	case INT_ARG:
	    sprintf(temp, "%d", *(q->int_value));
	    break;
	case TIME_ARG:
	    sprintf(temp, SECS_FMT, (double) Secs2SECS(*(q->int_value)));
	    break;
	case STRING_ARG:
	    if ((value = *(q->str_value)) != 0
		&& !*value)
		value = 0;
	    break;
	default:
	    value = 0;
	    break;
	}
	print_help_strings(p->name, p->help_string, value, TRUE);
    }

    SetOutputMode(O_BINARY);

    exit_immediately(exit_status);
}

/*
 * This function performs a string comparison on two strings a and b.  a is
 * assumed to be an ordinary null terminated string, but b may be terminated
 * by an '=', '+' or '-' character.  If terminated by '=', *c will be pointed
 * to the character following the '='.  If terminated by '+' or '-', *c will
 * be pointed to that character.  (+/- added for toggle processing - BL.)
 * If a and b match, it returns 1.  Otherwise 0 is returned.
 */
static int arg_eqs_parse(const char *a,
			 char *b,
			 char **c)
{
    int result = -1;

    *c = NULL;
    while (result < 0) {
	if ((*a != *b)
	    || (*a == 0)
	    || (*b == 0)) {
	    if (*a == 0) {
		switch (*b) {
		case '\t':	/* embedded blank when reading stdin */
		case ' ':
		    *c = LYSkipBlanks(b);
		    result = 1;
		    break;
		case '=':
		case ':':
		    *c = b + 1;
		    result = 1;
		    break;
		case '-':
#if OPTNAME_ALLOW_DASHES
		    if (isalpha(UCH(b[1]))) {
			result = 0;
			break;
		    }
#endif
		    /* FALLTHRU */
		case '+':
		    *c = b;
		    result = 1;
		    break;
		case 0:
		    result = 1;
		    break;
		default:
		    result = 0;
		    break;
		}
	    } else {
#if OPTNAME_ALLOW_DASHES
		if (!(*a == '_' && *b == '-'))
#endif
		    result = 0;
	    }
	}
	a++;
	b++;
    }
    return result;
}

#define is_true(s)  (*s == '1' || *s == '+' || !strcmp(s, "on"))
#define is_false(s) (*s == '0' || *s == '-' || !strcmp(s, "off"))

/*
 * Parse an option.
 *	argv[] points to the beginning of the unprocessed options.
 *	mask is used to select certain options which must be processed
 *		before others.
 *	countp (if nonnull) points to an index into argv[], which is updated
 *		to reflect option values which are also parsed.
 */
static BOOL parse_arg(char **argv,
		      unsigned mask,
		      int *countp)
{
    Config_Type *p;
    char *arg_name;

#if EXTENDED_STARTFILE_RECALL
    static BOOLEAN no_options_further = FALSE;	/* set to TRUE after '--' argument */
#endif

    arg_name = argv[0];
    CTRACE((tfp, "parse_arg(arg_name=%s, mask=%d, count=%d)\n",
	    arg_name, mask, countp ? *countp : -1));

#if EXTENDED_STARTFILE_RECALL
    if (mask == ((countp != 0) ? 0 : 1)) {
	no_options_further = FALSE;
	/* want to reset nonoption when beginning scan for --stdin */
	if (nonoption != 0) {
	    FREE(nonoption);
	}
    }
#endif

    /*
     * Check for a command line startfile.  - FM
     */
    if (*arg_name != '-'
#if EXTENDED_OPTION_LOGIC
	|| no_options_further == TRUE
#endif
	) {
#if EXTENDED_STARTFILE_RECALL
	/*
	 * On the last pass (mask==4), check for cases where we may want to
	 * provide G)oto history for multiple startfiles.
	 */
	if (mask == 4) {
	    if (nonoption != 0) {
		LYEnsureAbsoluteURL(&nonoption, "NONOPTION", FALSE);
		HTAddGotoURL(nonoption);
		FREE(nonoption);
	    }
	    StrAllocCopy(nonoption, arg_name);
	}
#endif
	StrAllocCopy(startfile, arg_name);
	LYEscapeStartfile(&startfile);
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 20:11:17 */
	HTUnEscape(startfile);
	{
	    char *q = startfile;

	    while (*q++) {
		if (*q == '|')
		    *q = ':';
	    }
	}
#endif
	CTRACE((tfp, "parse_arg startfile:%s\n", startfile));
	return (BOOL) (countp != 0);
    }
#if EXTENDED_OPTION_LOGIC
    if (strcmp(arg_name, "--") == 0) {
	no_options_further = TRUE;
	return TRUE;
    }
#endif

    /* lose the first '-' character */
    arg_name++;

    /*
     * Skip any lone "-" arguments, because we've loaded the stdin input into
     * an HTList structure for special handling.  - FM
     */
    if (*arg_name == 0)
	return TRUE;

    /* allow GNU-style options with -- prefix */
    if (*arg_name == '-')
	++arg_name;

    CTRACE((tfp, "parse_arg lookup(%s)\n", arg_name));

    p = Arg_Table;
    while (p->name != 0) {
	ParseUnionPtr q = ParseUnionOf(p);
	ParseFunc fun;
	char *next_arg = NULL;
	char *temp_ptr = NULL;

	if ((p->name[0] != *arg_name)
	    || (0 == arg_eqs_parse(p->name, arg_name, &next_arg))) {
	    p++;
	    continue;
	}

	if (p->type & NEED_NEXT_ARG) {
	    if (next_arg == 0) {
		next_arg = argv[1];
		if ((countp != 0) && (next_arg != 0))
		    (*countp)++;
	    }
	    CTRACE((tfp, "...arg:%s\n", NONNULL(next_arg)));
	}

	/* ignore option if it's not our turn */
	if ((p->type & mask) == 0) {
	    CTRACE((tfp, "...skip (mask %d/%d)\n", mask, p->type & 7));
	    return FALSE;
	}

	switch (p->type & ARG_TYPE_MASK) {
	case TOGGLE_ARG:	/* FALLTHRU */
	case SET_ARG:		/* FALLTHRU */
	case UNSET_ARG:
	    if (q->set_value != 0) {
		if (next_arg == 0) {
		    switch (p->type & ARG_TYPE_MASK) {
		    case TOGGLE_ARG:
			*(q->set_value) = (BOOL) !(*(q->set_value));
			break;
		    case SET_ARG:
			*(q->set_value) = TRUE;
			break;
		    case UNSET_ARG:
			*(q->set_value) = FALSE;
			break;
		    }
		} else if (is_true(next_arg)) {
		    *(q->set_value) = TRUE;
		} else if (is_false(next_arg)) {
		    *(q->set_value) = FALSE;
		}
		/* deliberately ignore anything else - BL */
	    }
	    break;

	case FUNCTION_ARG:
	    fun = q->fun_value;
	    if (0 != fun) {
		if (-1 == (*fun) (next_arg)) {
		}
	    }
	    break;

	case LYSTRING_ARG:
	    if ((q->str_value != 0) && (next_arg != 0))
		StrAllocCopy(*(q->str_value), next_arg);
	    break;

	case INT_ARG:
	    if ((q->int_value != 0) && (next_arg != 0))
		*(q->int_value) = strtol(next_arg, &temp_ptr, 0);
	    break;

	case TIME_ARG:
	    if ((q->int_value != 0) && (next_arg != 0)) {
		float ival;

		if (1 == sscanf(next_arg, "%f", &ival)) {
		    *(q->int_value) = (int) SECS2Secs(ival);
		}
	    }
	    break;

	case STRING_ARG:
	    if ((q->str_value != 0) && (next_arg != 0))
		*(q->str_value) = next_arg;
	    break;
	}

	Old_DTD = DTD_recovery;	/* BOOL != int */
	return TRUE;
    }

    if (pgm == 0)
	pgm = "LYNX";

    fprintf(stderr, gettext("%s: Invalid Option: %s\n"), pgm, argv[0]);
    print_help_and_exit(-1);
    return FALSE;
}

#ifndef VMS
static void FatalProblem(int sig)
{
    /*
     * Ignore further interrupts.  - mhc:  11/2/91
     */
#ifndef NOSIGHUP
    (void) signal(SIGHUP, SIG_IGN);
#endif /* NOSIGHUP */
    (void) signal(SIGTERM, SIG_IGN);
    (void) signal(SIGINT, SIG_IGN);
#ifndef __linux__
#ifndef DOSPATH
    (void) signal(SIGBUS, SIG_IGN);
#endif /* ! DOSPATH */
#endif /* !__linux__ */
    (void) signal(SIGSEGV, SIG_IGN);
    (void) signal(SIGILL, SIG_IGN);

    /*
     * Flush all messages.  - FM
     */
    fflush(stderr);
    fflush(stdout);

    /*
     * Deal with curses, if on, and clean up.  - FM
     */
    if (LYOutOfMemory && LYCursesON) {
	LYSleepAlert();
    }
    cleanup_sig(0);
#ifndef __linux__
#ifndef DOSPATH
    signal(SIGBUS, SIG_DFL);
#endif /* DOSPATH */
#endif /* !__linux__ */
    signal(SIGSEGV, SIG_DFL);
    signal(SIGILL, SIG_DFL);

    /*
     * Issue appropriate messages and abort or exit.  - FM
     */
    if (LYOutOfMemory == FALSE) {
	fprintf(stderr, "\r\n\
A Fatal error has occurred in %s Ver. %s\r\n", LYNX_NAME, LYNX_VERSION);

	fprintf(stderr, "\r\n\
Please notify your system administrator to confirm a bug, and\r\n\
if confirmed, to notify the lynx-dev list.  Bug reports should\r\n\
have concise descriptions of the command and/or URL which causes\r\n\
the problem, the operating system name with version number, the\r\n\
TCPIP implementation, and any other relevant information.\r\n");

	if (!(sig == 0 && LYNoCore)) {
	    fprintf(stderr, "\r\n\
Do NOT mail the core file if one was generated.\r\n");
	}
	if (sig != 0) {
	    fprintf(stderr, "\r\n\
Lynx now exiting with signal:  %d\r\n\r\n", sig);
#ifdef WIN_EX			/* 1998/08/09 (Sun) 09:58:25 */
	    {
		char *msg;

		switch (sig) {
		case SIGABRT:
		    msg = "SIGABRT";
		    break;
		case SIGFPE:
		    msg = "SIGFPE";
		    break;
		case SIGILL:
		    msg = "SIGILL";
		    break;
		case SIGSEGV:
		    msg = "SIGSEGV";
		    break;
		default:
		    msg = "Not-def";
		    break;
		}
		fprintf(stderr, "signal code = %s\n", msg);
	    }
#endif
	}

	/*
	 * Exit and possibly dump core.
	 */
	if (LYNoCore) {
	    exit_immediately(EXIT_FAILURE);
	}
	abort();

    } else {
	LYOutOfMemory = FALSE;
	printf("\r\n%s\r\n\r\n", MEMORY_EXHAUSTED_ABORT);
	fflush(stdout);

	/*
	 * Exit without dumping core.
	 */
	exit_immediately(EXIT_SUCCESS);
    }
}
#endif /* !VMS */
@


1.19
log
@* replace all occurences of old eMail addresses of mine
  with their more recent counterparts
* no $Log keyword!
* update licence template to most recent version in files touched
* in some places, don't add our own licence boilerplate, just
  add my name to the others
* make dev/rndvar.h suitable for inclusion in asm code
* include dev/rndvar.h by in_cksum.s instead of
  hardcoding pool size
* ENTRY(a); ENTRY(b) -> NENTRY(a); ENTRY(b)
* RCS IDs belong into .comment not .text
@
text
@d1 1
a1 1
/**	$MirBSD: src/share/misc/licence.template,v 1.20 2004/12/03 16:18:37 tg Rel $ */
d51 1
d59 1
d121 1
d125 2
a126 2
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d181 3
a183 1
char *empty_string = "\0";
a200 1
int port_syntax = 1;
d412 1
a412 1
BOOLEAN startfile_stdin = FALSE;
d414 1
d435 1
d472 7
a478 1
HistInfo history[MAXHIST];
d491 3
a493 1
int nhist = 0;			/* number of history entries */
a495 1
LinkInfo links[MAXLINKS];
d612 1
a612 1
static char *pgm;
d630 4
a699 3
#ifdef SYSLOG_REQUESTED_URLS
    FREE(syslog_txt);
#endif /* SYSLOG_REQUESTED_URLS */
d706 4
d722 1
d773 1
d776 1
d788 1
a788 3
    for (i = 0; i < nlinks; i++) {
	FREE(links[i].lname);
    }
d790 5
a794 1
    HTList_delete(LYcommandList());
d805 1
a805 10
    char *argument;
    HTList *cur = LYStdinArgs;

    if (cur == NULL)
	return;

    while (NULL != (argument = (char *) HTList_nextObject(cur))) {
	FREE(argument);
    }
    HTList_delete(LYStdinArgs);
a806 1
    return;
d809 1
a809 1
void exit_immediately(int code)
d822 8
d936 1
a936 1
			       char *separator)
d1006 1
a1006 1
    ftp_lasthost = calloc(1, sizeof(char));
d1037 1
a1037 1
	exit(EXIT_SUCCESS);
d1142 1
a1142 1
    memset((void *) history, 0, sizeof(HistInfo) * MAXHIST);
d1257 1
a1257 1
	exit(EXIT_FAILURE);
d1451 3
a1453 1
    LYAddPathToHome(LYTraceLogPath = malloc(LY_MAXPATH), LY_MAXPATH, cp);
d1518 1
a1518 1
	exit(EXIT_FAILURE);
d1527 1
a1527 1
	exit(EXIT_FAILURE);
d1556 1
a1556 1
	exit(EXIT_FAILURE);
d1688 1
a1688 1
	char *tty = NULL;
d1711 1
a1711 1
		exit(1);
d1741 3
a1743 1
	    LYAddPathToHome(LYCookieFile = malloc(LY_MAXPATH), LY_MAXPATH, COOKIE_FILE);
d1829 1
a1829 1
	exit(EXIT_SUCCESS);
d2118 1
a2118 1
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
a2209 3
	    extern int saved_scrsize_x;
	    extern int saved_scrsize_y;

d2215 1
a2215 1
	exit(status);
d2937 1
a2937 1
static char *show_restriction(const char *name)
d2939 1
a2939 1
    char *value = 0;
d3133 1
a3133 1
	exit(EXIT_SUCCESS);
d3138 1
a3138 1
	exit(EXIT_SUCCESS);
d3253 1
a3253 1
    exit(EXIT_SUCCESS);
a3834 1
#ifndef VMS
d3840 4
a3843 1
#endif
d4047 1
a4047 1
    exit(exit_status);
a4131 1
    static char *nonoption = 0;
d4401 1
a4401 1
	    exit(EXIT_FAILURE);
d4413 1
a4413 1
	exit(EXIT_SUCCESS);
@


1.18
log
@automatic merge
@
text
@d1 3
a3 2
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYMain.c,v 1.17 2004/10/11 20:30:41 tg Exp $
 *-
d5 1
a5 1
 *	Thorsten "mirabile" Glaser <x86@@ePost.de>
d8 5
a12 5
 * tion, including unlimited rights to use, publically perform, modi-
 * fy, merge, distribute, sell, give away or sublicence, provided the
 * above copyright notices, these terms and the disclaimer are retai-
 * ned in all redistributions, or reproduced in accompanying documen-
 * tation or other materials provided with binary redistributions.
d20 1
a20 1
 * of covered work, even if advised of the possibility of such damage.
@


1.17
log
@automatic merge; regen configure
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYMain.c,v 1.16 2004/07/23 05:43:53 tg Stab $
d2043 1
a2043 1
    if (!(homepage && *homepage)) {
d2096 1
a2096 1
    if (x_display != NULL && *x_display != '\0') {
d4205 1
a4205 1
	    CTRACE((tfp, "...arg:%s\n", next_arg != 0 ? next_arg : "<null>"));
@


1.16
log
@back out the -iz patch; slashdot.org and symlink.lu look
way different (not the front page, but the articles), and
also on www.heise.de/newsticker/ there is no left spacing
at the left side of the text, which is confusing in a
full-screen xterm
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYMain.c,v 1.15 2004/07/15 18:16:58 tg Exp $
d222 1
a234 1
BOOLEAN nolist = FALSE;
d402 1
d475 1
a475 1
int ccount = 0;			/* Starting number for lnk#.dat files in crawls */
d599 1
d1838 7
d2109 3
a2111 1
	} else if (!nolist) {
d2135 1
a2135 1
	    if (!nolist &&
d2144 1
a2144 1
	if (!nolist &&
d2590 1
a2590 1
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
d2592 1
a2592 1
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '\"' &&
d3537 1
a3537 1
      "link",		4|NEED_INT_ARG,		ccount,
d3541 4
d3617 1
a3617 1
      "nolist",		4|SET_ARG,		nolist,
d3630 4
@


1.15
log
@automatic merge of lynx-current
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYMain.c,v 1.14 2004/04/30 16:32:35 tg Exp $
a505 2
long tables_disable = 0;

a3800 4
   PARSE_SET(
      "tables_disable",	4|INT_ARG,		tables_disable,
      "=NUMBER\nbits disable table support in certain situations"
   ),
@


1.14
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.9 2004/03/19 23:25:19 tg Stab $
d6 6
a11 6
 * Subject to these terms, everybody who obtained a copy of this work
 * is hereby permitted to deal in the work without restriction inclu-
 * ding without limitation the rights to use, distribute, sell, modi-
 * fy, publically perform, give away, merge or sublicence it provided
 * this notice is kept and the authors and contributors are given due
 * credit in derivates or accompanying documents.
d13 7
a19 6
 * This work is provided by its developers (authors and contributors)
 * "as is" and without any warranties whatsoever, express or implied,
 * to the maximum extent permitted by applicable law; in no event may
 * developers be held liable for damage caused, directly or indirect-
 * ly, but not by a developer's malice intent, even if advised of the
 * possibility of such damage.
d75 1
a75 1
#undef gettext		/* Solaris locale.h prototypes gettext() */
d95 1
a95 1
BOOLEAN socks_flag=TRUE;
d107 1
a107 1
char *mail_adrs = NULL;	/* the mask for a VMS mail transport */
d118 1
d120 1
a120 1
char *syslog_txt = NULL;		/* syslog arb text for session */
d128 1
a128 1
int LYAutoUncacheDirLists = 2; /* default dired uncaching behavior */
d139 1
d149 1
d158 1
d163 1
a163 1
	       LOCAL_EXECUTION_LINKS_ON_BUT_NOT_REMOTE;
d166 2
a167 2
#if defined(LYNXCGI_LINKS) && !defined(VMS)  /* WebSter Mods -jkt */
char *LYCgiDocumentRoot = NULL; /* DOCUMENT_ROOT in the lynxcgi env */
d171 2
a172 1
BOOLEAN enable_scrollback=TRUE;
d174 1
a174 1
BOOLEAN enable_scrollback=FALSE;
d178 3
a180 2
int display_lines;  /* number of lines in display */
int www_search_result= -1;
d183 1
d186 1
d190 1
d196 2
a197 2
int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not */
int LYrcShowColor = SHOW_COLOR_UNKNOWN; /* ... last used */
d200 1
a200 1
BOOLEAN LYUseFormsOptions = TRUE; /* use forms-based options menu */
d203 1
a203 1
BOOLEAN LYJumpFileURL = FALSE;	 /* always FALSE the first time */
d205 3
a207 3
BOOLEAN LYRestricted = FALSE; /* whether we have -anonymous option */
BOOLEAN LYShowCursor = SHOW_CURSOR; /* to show or not to show */
BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS; /* Show the links underlined vs bold */
d209 1
a209 1
BOOLEAN LYUserSpecifiedURL = TRUE;/* always TRUE  the first time */
d212 2
a213 2
BOOLEAN LYinternal_flag = FALSE; /* override no-cache b/c internal link*/
BOOLEAN LYoverride_no_cache = FALSE;/*override no-cache b/c history etc*/
d225 1
a225 1
BOOLEAN ftp_passive = FTP_PASSIVE; /* TRUE if doing ftp in passive mode */
d228 1
a228 1
BOOLEAN goto_buffer = GOTOBUFFER; /* TRUE if offering default goto URL */
d231 1
a231 1
BOOLEAN jump_buffer = JUMPBUFFER; /* TRUE if offering default shortcut */
d237 1
a237 1
BOOLEAN recent_sizechange = FALSE;/* the window size changed recently? */
d240 1
a240 1
BOOLEAN verbose_img = VERBOSE_IMAGES;  /* show filenames or not */
d246 1
d318 1
d335 1
a335 1
BOOLEAN dj_is_bash = FALSE;  /* Check for bash shell under DJGPP */
d344 1
a344 1
#define	TIMEOUT	180			/* 1998/03/30 (Mon) 14:50:44 */
d367 1
d370 1
d375 3
a377 3
BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
BOOLEAN LYCancelledFetch = FALSE;/* TRUE if cancelled binary fetch */
BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
d382 4
a385 4
BOOLEAN LYNewsPosting = NEWS_POSTING; /* News posting supported? */
BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
d388 1
a388 1
BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
d393 1
a393 1
BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
d396 1
a396 1
BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
d399 1
a399 1
BOOLEAN keep_mime_headers = FALSE; /* Include mime headers with source dump */
d402 1
a402 1
BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
d409 11
a419 11
char *LYCookieAcceptDomains = NULL; /* domains to accept all cookies */
char *LYCookieLooseCheckDomains = NULL;  /* check loosely   */
char *LYCookieQueryCheckDomains = NULL;  /* check w/a query */
char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
char *LYCookieSAcceptDomains = NULL; /* domains to accept all cookies */
char *LYCookieSLooseCheckDomains = NULL;  /* check loosely   */
char *LYCookieSQueryCheckDomains = NULL;  /* check w/a query */
char *LYCookieSRejectDomains = NULL; /* domains to reject all cookies */
char *LYCookieSStrictCheckDomains = NULL; /* check strictly  */
char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
char *LYHostName = NULL;		/* treat as a local host name */
d421 2
a422 2
char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
d428 2
a429 1
char *authentication_info[2] = {NULL, NULL}; /* Id:Password for protected documents */
d434 1
a434 1
char *global_extension_map = NULL;  /* global mime.types */
d442 1
a442 1
char *jumpprompt = NULL;		/* the default jumps prompt */
d453 3
a455 3
char *personal_extension_map = NULL;/* .mime.types */
char *personal_mail_address = NULL; /* the users mail address */
char *personal_type_map = NULL;	   /* .mailcap */
d457 2
a458 1
char *proxyauth_info[2] = {NULL, NULL}; /* Id:Password for protected proxy servers */
d460 1
a460 1
char *startrealm = NULL;		/* the startfile realm */
d472 1
a472 1
int MessageSecs;			/* time-delay for important Messages   */
d483 2
a484 2
BOOLEAN BibP_bibhost_available = FALSE;  /* until check succeeds  */
BOOLEAN BibP_bibhost_checked = FALSE;  /*  until LYCheckBibHost   */
d486 2
a487 2
char *BibP_bibhost = NULL;	 /* local server for bibp: links  */
char *BibP_globalserver = NULL;   /* global server for bibp: links */
d491 1
a491 1
BOOLEAN persistent_cookies = FALSE; /* disabled by default! */
d499 1
a499 1
    TRUE
d501 1
a501 1
    FALSE				/* see 2001-08-15  */
d503 1
a503 1
    ;
d506 2
d510 3
d515 2
a516 2
BOOLEAN LYNoISMAPifUSEMAP = FALSE; /* Omit ISMAP link if MAP present? */
int LYHiddenLinks = HIDDENLINKS_SEPARATE; /* Show hidden links? */
d522 1
a522 1
FILE *LYTraceLogFP = NULL;		/* Pointer for TRACE log  */
d524 2
a525 2
char *LYTraceLogPath = NULL;		/* Path for TRACE log	   */
BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?	   */
d574 1
a574 1
char* hidden_link_marker = NULL;
d578 3
a580 3
BOOLEAN display_partial_flag = TRUE; /* Display document during download */
BOOLEAN debug_display_partial = FALSE; /* Show with MessageSecs delay */
int partial_threshold = -1;  /* # of lines to be d/l'ed until we repaint */
d588 1
a588 1
int LYNoZapKey = 0; /* 0: off (do z checking), 1: full, 2: initially */
d622 6
a627 7
#if EXTENDED_OPTION_LOGIC
static BOOLEAN no_options_further=FALSE; /* set to TRUE after '--' argument */
#endif

static BOOL parse_arg (char **arg, unsigned mask, int *i);
static void print_help_and_exit (int exit_status) GCC_NORETURN;
static void print_help_strings (const char * name, const char * help, const char * value, BOOLEAN option);
d632 1
a632 1
static void FatalProblem (int sig);
d642 1
a642 1
    (void)signal(SIGINT, (setting ? SIG_DFL : SIG_IGN));
d649 1
d652 1
a652 1
    __dpmi_int (0x21, &regs);
a674 1

d676 1
a676 1
static void free_lynx_globals (void)
d685 1
a685 1
#ifdef LYNXCGI_LINKS  /* WebSter Mods -jkt */
d777 1
a777 1
 *  This function frees the LYStdinArgs list. - FM
d779 1
a779 1
static void LYStdinArgs_free (void)
d787 1
a787 1
    while (NULL != (argument = (char *)HTList_nextObject(cur))) {
d795 1
a795 2
void exit_immediately (
	int		code)
d812 1
d833 1
d838 1
a838 2
    int work1[256],
	work2[256];
d842 2
a843 2
	work1[c] = keymap[c+1];
	work2[c] = key_override[c+1];
d846 2
a847 2
	keymap      [IBM1047[c]+1] = work1[c];
	key_override[IBM1047[c]+1] = work2[c];
d852 2
a853 16
static int argncmp (
	char*		str,
	char*		what)
{
    if (str[0] == '-' && str[1] == '-' ) ++str;
#if OPTNAME_ALLOW_DASHES
    return strncmp(str, what, strlen(what));
#else
    ++str; ++what; /*skip leading dash in both strings*/
    return !strn_dash_equ(str, what, strlen(what));
#endif
}

static void tildeExpand (
	char **	pathname,
	BOOLEAN	embedded)
d868 1
a868 1
     && temp[0] == '~') {
d870 1
a870 1
	 && temp[2] != '\0') {
d883 2
a884 3
static BOOL GetStdin (
	char **	buf,
	BOOL		marker)
d887 1
a887 1
     && (!marker || strncmp(*buf, "---", 3) != 0)) {
d913 2
a914 3
static void append_ssl_version (
	char **	target,
	char *		separator)
d938 1
a938 1
    LYstrncpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion)-1);
d954 2
a955 3
int main (
	int		argc,
	char **	argv)
d957 2
a958 2
    int  i;		/* indexing variable */
    int status = 0;	/* exit status */
d965 1
d984 1
a984 1
    ftp_lasthost = calloc(1,sizeof(char));
d988 1
a988 1
    memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
d999 2
a1000 3
	if (err != 0)
	{
	    printf(gettext("No Winsock found, sorry."));
d1012 1
a1012 1
#if 0 /* defined(__CYGWIN__) - does not work with screen */
a1029 1

d1037 1
a1037 1
    __djgpp_set_sigquit_key(0x082D); /* Bind ALT-X to SIGQUIT */
d1042 1
a1042 1
      && (strstr(LYPathLeaf(cp), "sh") != NULL))
d1056 2
a1057 1
    if (LYGetEnv("TERM")==NULL) putenv("TERM=vt100");
d1062 1
a1062 1
     *	Set up the argument list.
d1071 1
a1071 1
     *	Act on -help NOW, so we only output the help and exit. - FM
d1074 1
a1074 8
	if (argncmp(argv[i], "-help") == 0) {
	    parse_arg(&argv[i], 1, &i);
	}
#ifdef SH_EX
	if (strncmp(argv[i], "-show_cfg", 9) == 0) {
	    show_cfg = TRUE;
	}
#endif
d1079 2
a1080 2
     *	Register the final function to be executed when being exited.
     *	Will display memory leaks if LY_FIND_LEAKS is defined.
d1084 1
a1084 1
     *	Register the function which will free our allocated globals.
a1088 1

d1091 1
a1091 1
     *	LOCALE support for international characters.
d1100 1
a1100 1
    bindtextdomain ("lynx", cp);
d1102 1
a1102 1
    textdomain ("lynx");
d1106 1
a1106 1
     *	Initialize our startup and global variables.
d1110 1
a1110 1
     *	Need this for Ultrix.
d1117 1
a1117 1
     *	Zero the links and history struct arrays.
d1119 2
a1120 2
    memset((void *)links, 0, sizeof(LinkInfo)*MAXLINKS);
    memset((void *)history, 0, sizeof(HistInfo)*MAXHIST);
d1122 1
a1122 1
     *	Zero the MultiBookmark arrays.
d1124 3
a1126 2
    memset((void *)MBM_A_subbookmark, 0, sizeof(char)*(MBM_V_MAXFILES+1));
    memset((void *)MBM_A_subdescript, 0, sizeof(char)*(MBM_V_MAXFILES+1));
d1131 5
a1135 5
    AlertSecs	= SECS2Secs(ALERTSECS);
    DebugSecs	= SECS2Secs(DEBUGSECS);
    InfoSecs	= SECS2Secs(INFOSECS);
    MessageSecs	= SECS2Secs(MESSAGESECS);
    ReplaySecs	= SECS2Secs(REPLAYSECS);
d1234 1
a1234 1
	printf(gettext("You MUST define a valid TMP or TEMP area!\n"));
d1239 1
a1239 1
#ifdef WIN_EX	/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
a1257 1

d1281 1
a1281 1
	&& mkdir(lynx_temp_space, 0700) < 0
d1284 1
a1284 1
     || !S_ISDIR(dir_info.st_mode)) {
a1289 1

d1310 1
a1310 1
    StrAllocCopy(BibP_bibhost, "http://bibhost/");  /* protocol specified. */
d1314 3
a1316 4
     *	Disable news posting if the compilation-based
     *	LYNewsPosting value is FALSE.  This may be changed
     *	further down via lynx.cfg or the -restriction
     *	command line switch. - FM
d1323 4
a1326 5
     *	Set up trace, the anonymous account defaults,
     *	validate restrictions, and/or the nosocks flag,
     *	if requested, and an alternate configuration
     *	file, if specified, NOW.  Also, if we only want
     *	the help menu, output that and exit. - FM
d1338 11
a1348 13
     *	If we have a lone "-" switch for getting arguments from stdin,
     *	get them NOW, and act on the relevant ones, saving the others
     *	into an HTList for handling after the other initializations.
     *	The primary purpose of this feature is to allow for the
     *	potentially very long command line that can be associated with
     *	post or get data.  The original implementation required that
     *	the lone "-" be the only command line argument, but that
     *	precluded its use when the lynx command is aliased with other
     *	arguments.  When interactive, the stdin input is terminated by
     *	by Control-D on Unix or Control-Z on VMS, and each argument
     *	is terminated by a RETURN.  When the argument is -get_data or
     *	-post_data, the data are terminated by a "---" string, alone
     *	on the line (also terminated by RETURN). - FM
d1367 2
a1368 2
	    if (parse_arg(&noargv[0], 2, (int *)0) == FALSE
	     &&  buf[0] != '\0') {
a1386 1

d1393 2
a1394 2
     *	If we had -validate set all of the restrictions
     *	and disallow a TRACE log NOW. - FM
d1402 3
a1404 4
     *	If we didn't get and act on a -validate or -anonymous
     *	switch, but can verify that this is the anonymous account,
     *	set the default restrictions for that account and disallow
     *	a TRACE log NOW. - FM
d1409 1
a1409 1
	!strcasecomp((LYGetEnv("USER")==NULL ? " " : LYGetEnv("USER")),
d1413 1
a1413 1
	STREQ((char *)cuserid((char *) NULL), ANONYMOUS_USER)
d1415 1
a1415 1
	STREQ(((char *)getlogin()==NULL ? " " : getlogin()), ANONYMOUS_USER)
d1425 1
a1425 1
     *	Set up the TRACE log path, and logging if appropriate. - FM
d1435 1
a1435 1
     *	Open command-script, if specified
d1442 1
a1442 1
     *	Open command-logging, if specified
d1451 1
a1451 1
     *	Set up the default jump file stuff. - FM
d1467 2
a1468 2
     *	If no alternate configuration file was specified on
     *	the command line, see if it's in the environment.
d1471 2
a1472 2
	if (((cp=LYGetEnv("LYNX_CFG")) != NULL) ||
	    (cp=LYGetEnv("lynx_cfg")) != NULL)
d1477 2
a1478 2
     *	If we still don't have a configuration file,
     *	use the userdefs.h definition.
d1483 1
a1483 1
#ifndef _WINDOWS /* avoid the whole ~ thing for now */
d1488 1
a1488 2
     *	If the configuration file is not available,
     *	inform the user and exit.
d1491 3
a1493 2
	fprintf(stderr, gettext("\nConfiguration file %s is not available.\n\n"),
			lynx_cfg_file);
d1498 2
a1499 2
     * Make sure we have the character sets declared.
     *	This will initialize the CHARTRANS handling. - KW
d1506 4
a1509 4
     *  (**) in Lynx, UCLYhndl_HTFile_for_unspec and UCLYhndl_for_unrec may be
     *  valid or not, but current_char_set and UCLYhndl_for_unspec SHOULD
     *  ALWAYS be a valid charset.  Initialized here and may be changed later
     *  from lynx.cfg/command_line/options_menu. - LP  (**)
d1512 1
a1512 1
     *	Set up the compilation default character set. - FM
d1519 1
a1519 1
    current_char_set = safeUCGetLYhndl_byMIME(CHARACTER_SET);
d1521 1
a1521 1
     *	Set up HTTP default for unlabeled charset (iso-8859-1).
d1528 1
a1528 1
     *	Make sure we have the edit map declared. - FM
a1533 1

d1536 2
a1537 2
     *	If no alternate lynx-style file was specified on
     *	the command line, see if it's in the environment.
d1540 2
a1541 2
	if (((cp=LYGetEnv("LYNX_LSS")) != NULL) ||
	    (cp=LYGetEnv("lynx_lss")) != NULL)
d1546 1
a1546 2
     *	If we still don't have a lynx-style file,
     *	use the userdefs.h definition.
d1554 1
a1554 2
     *	If the lynx-style file is not available,
     *	inform the user and exit.
d1558 2
a1559 4
			lynx_lss_file);
    }
    else
    {
d1566 1
a1566 1
     *	Set up default foreground and background colors.
d1572 1
a1572 1
     *  Set the original directory, used for default download
d1582 1
a1582 1
     *	Set the compilation default signature file. - FM
d1584 1
a1584 1
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename)-1);
d1600 1
a1600 1
     *	Process the configuration file.
d1602 1
a1602 1
    read_cfg(lynx_cfg_file, "main program", 1, (FILE *)0);
d1605 1
a1605 1
     *	Process the RC file.
d1627 1
a1627 1
    LYEnsureAbsoluteURL((char **)&LynxHome, "LynxHome", FALSE);
d1630 2
a1631 1
     *  Process any command line arguments not already handled. - FM
d1638 2
a1639 2
     *  Process any stdin-derived arguments for a lone "-"  which we've
     *  loaded into LYStdinArgs. - FM
d1646 2
a1647 2
	while (NULL != (my_args[0] = (char *)HTList_nextObject(cur))) {
	    parse_arg(my_args, 4, (int *)0);
d1652 1
a1652 1
    if (current_char_set == auto_display_charset) /* Better: explicit option */
d1658 2
a1659 2
     *	If we are told to read the startfile from standard input, do it now,
     *	after we have read all of the option data from standard input.
d1665 1
d1673 1
a1673 1
	if ((fp = LYOpenTemp (result, HTML_SUFFIX, "w")) != 0) {
d1694 1
a1694 1
     *  Initialize other things based on the configuration read.
d1698 1
a1698 1
    if ( (!Old_DTD) != TRUE ) /* skip if they are already initialized -HV */
d1700 1
a1700 1
    HTSwitchDTD(!Old_DTD);
d1716 1
a1716 1
	if(LYCookieFile == NULL) {
d1752 2
a1753 3
     *	Check for a save space path in the environment.
     *	If one was set in the configuration file, that
     *	one will be overridden. - FM
d1759 1
a1759 1
     *	We have a save space path, make sure it's valid. - FM
d1788 4
a1791 5
     *	Set up the file extension and mime type maps from
     *	src/HTInit.c and the global and personal mime.types
     *	and mailcap files.  These will override any SUFFIX
     *	or VIEWER maps in userdefs.h or the configuration
     *	file, if they overlap.
a1822 1

d1855 1
a1855 1
     *	Check the -popup command line toggle. - FM
d1862 1
a1862 1
     *	Check the -show_cursor command line toggle. - FM
d1869 1
a1869 1
     *	Check the -base command line switch with -source. - FM
d1876 3
a1878 4
     *	Disable multiple bookmark support if not interactive,
     *	so it doesn't crash on curses functions, or if the
     *	support was blocked via userdefs.h and/or lynx.cfg,
     *	or via command line restrictions. - FM
a1886 1

d1912 6
a1917 6
	__system_emulate_chdir	      | /* handle `cd' internally */
	__system_handle_null_commands | /* ignore cmds with no effect */
	__system_allow_long_cmds      | /* handle commands > 126 chars	 */
	__system_use_shell	      | /* use $SHELL if set */
	__system_allow_multiple_cmds  | /* allow `cmd1; cmd2; ...' */
	__system_redirect;		/* redirect internally */
d1920 2
a1921 2
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC |_STAT_DIRSIZE;
#endif  /* __DJGPP__ */
d1948 1
a1948 1
	 *  Since we're doing lots of TCP, just ignore SIGPIPE altogether.
d1950 4
a1953 5
	 *  HTTCP.c should deal with a broken pipe for servers.
	 *  Rick Mallet's check after c = GetChar() in LYStrings.c should
	 *   deal with a disconnected terminal.
	 *  So the runaway CPU time problem on Unix should not occur any
	 *   more.
d1957 1
a1957 1
	     restore_sigpipe_for_children = TRUE;
d1964 1
a1964 1
     *	Block Control-Z suspending if requested. - FM
d1971 1
a1971 1
     *	Check for a valid HEAD request. - FM
d1975 1
a1975 1
 "The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n",
d1981 1
a1981 1
     *	Check for a valid MIME headers request. - FM
d1985 1
a1985 1
 "The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n",
d1991 1
a1991 1
     *	Check for a valid traversal request. - FM
d1995 1
a1995 1
 "The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n",
d2001 3
a2003 3
     *  Finish setting up for an INTERACTIVE session.
     *  Done here so that URL guessing in LYEnsureAbsoluteURL() can be
     *  interruptible (terminal is in raw mode, select() works).  -BL
d2007 1
a2007 1
	HTMLSRC_init_caches(FALSE); /* do it before terminal is initialized*/
d2018 2
a2019 3
     *	If startfile is a file URL and the host is defaulted,
     *	force in "//localhost", and if it's not an absolute URL,
     *	make it one. - FM
d2021 1
a2021 1
    LYEnsureAbsoluteURL((char **)&startfile, "STARTFILE", FALSE);
d2024 3
a2026 3
     *	If homepage was specified and is a file URL with the
     *	host defaulted, force in "//localhost", and if it's
     *	not an absolute URL, make it one. - FM
d2029 1
a2029 1
	LYEnsureAbsoluteURL((char **)&homepage, "HOMEPAGE", FALSE);
d2033 2
a2034 3
     *	If we don't have a homepage specified,
     *	set it to startfile.  Otherwise, reset
     *	LynxHome. - FM
d2043 1
a2043 1
     *	Set up the inside/outside domain restriction flags. - FM
d2046 2
a2047 2
#if !defined(HAVE_UTMP) || defined(VMS) /* not selective */
	telnet_ok = (BOOL)(!no_inside_telnet && !no_outside_telnet && telnet_ok);
d2049 1
a2049 1
	news_ok = (BOOL)(!no_inside_news && !no_outside_news && news_ok);
d2051 2
a2052 2
	ftp_ok = (BOOL)(!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
d2055 1
a2055 1
	telnet_ok = (BOOL)(!no_inside_telnet && telnet_ok);
d2057 1
a2057 1
	news_ok = (BOOL)(!no_inside_news && news_ok);
d2059 2
a2060 2
	ftp_ok = (BOOL)(!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && rlogin_ok);
d2064 1
a2064 1
	telnet_ok = (BOOL)(!no_outside_telnet && telnet_ok);
d2066 1
a2066 1
	news_ok = (BOOL)(!no_outside_news && news_ok);
d2068 2
a2069 2
	ftp_ok = (BOOL)(!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_outside_rlogin && rlogin_ok);
d2073 2
a2074 2
     *	Make sure our bookmark default strings
     *	are all allocated and synchronized. - FM
a2084 1

d2086 1
a2086 1
    LYOpenlog (syslog_txt);
d2089 4
d2094 1
a2094 1
     *	Here's where we do all the work.
d2098 1
a2098 2
	 *  Finish setting up and start a
	 *  NON-INTERACTIVE session. - FM
a2109 4

	if (x_display != NULL && *x_display != '\0') {
	    LYisConfiguredForX = TRUE;
	}
d2113 21
d2139 1
d2142 2
a2143 3
	 *  We want to save cookies picked up when in immediate dump
	 *  mode.  Instead of calling cleanup() here, let's only call
	 *  this one. - BJP
d2151 1
a2151 1
	 *  Start an INTERACTIVE session. - FM
a2152 3
	if (x_display != NULL && *x_display != '\0') {
	    LYisConfiguredForX = TRUE;
	}
d2168 1
a2168 1
	ena_csi((BOOLEAN)(LYlowest_eightbit[current_char_set] > 155));
d2174 1
a2174 1
	if (! isendwin()) {
d2177 1
d2179 1
a2179 1
	        resize_term(saved_scrsize_y, saved_scrsize_x);
d2186 1
a2186 1
    return(status);	/* though redundant, for compiler-warnings */
d2190 2
a2191 2
 *  Called by HTAccessInit to register any protocols supported by lynx.
 *  Protocols added by lynx:
d2200 1
d2202 5
a2206 5
GLOBALREF  HTProtocol LYLynxKeymap;
GLOBALREF  HTProtocol LYLynxCGI;
GLOBALREF  HTProtocol LYLynxIMGmap;
GLOBALREF  HTProtocol LYLynxCookies;
GLOBALREF  HTProtocol LYLynxStatusMessages;
d2209 1
a2209 1
void LYRegisterLynxProtocols (void)
d2220 2
a2221 3
 *  Some stuff to reload lynx.cfg without restarting new lynx session,
 *  also load options menu items and command-line options
 *  to make things consistent.
d2223 1
a2223 1
 *  Called by user of interactive session by LYNXCFG://reload/ link.
d2225 1
a2225 1
 *  Warning: experimental, more main() reorganization required.
d2235 1
a2235 1
void reload_read_cfg (void)
d2239 1
d2241 8
a2248 9
     *  no_option_save is always set for -anonymous and -validate.
     *  It is better to check for one or several specific restriction
     *  flags than for 'LYRestricted', which doesn't get set for
     *  individual restrictions or for -validate!
     *  However, no_option_save may not be the appropriate one to
     *  check - in that case, a new no_something should be added
     *  that gets automatically set for -anonymous and -validate
     *  (and whether it applies for -anonymous can be made installer-
     *  configurable in the usual way at the bottom of userdefs.h). - kw
d2259 6
a2264 7
     *  Current user preferences are saved in a temporary file, to be
     *  read in again after lynx.cfg has been read.  This avoids
     *  accidental changing of the preferences file.  The regular
     *  preferences file doesn't even need to exist, and won't be
     *  created as a side effect of this function.  Honoring the
     *  no_option_save restriction may thus be unnecessarily restrictive,
     *  but the check is currently still left in place. - kw
d2271 1
a2271 1
    rcfp = LYOpenTemp(tempfile, ".rc" , "w");
d2281 2
a2282 4
	return;    /* can not write the very own file :( */
    }

    {
d2286 3
a2288 2
	char * LYCookieFile_flag = NULL;
	char * LYCookieSaveFile_flag = NULL;
d2298 1
a2298 1
	memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
d2307 1
a2307 1
	source_cache_file_error = FALSE; /* reset flag */
d2311 1
a2311 1
	 *  Process the configuration file.
d2313 1
a2313 1
	read_cfg(lynx_cfg_file, "main program", 1, (FILE *)0);
d2316 1
a2316 1
	 *  Process the temporary RC file.
d2331 1
a2331 1
	 *  Process any command line arguments not already handled.
d2333 1
a2333 1
		/* Not implemented yet here */
d2336 2
a2337 2
	 *  Process any stdin-derived arguments for a lone "-"  which we've
	 *  loaded into LYStdinArgs.
d2339 1
a2339 1
		/* Not implemented yet here */
d2342 1
a2342 1
	 *  Initialize other things based on the configuration read.
d2349 4
a2352 4
		/* Not implemented yet here,
		 * a major problem: file paths
		 * like lynx_save_space, LYCookieFile etc.
		 */
d2362 2
a2363 1
		CTRACE((tfp, "cookie file can be changed in next session only, restored.\n"));
d2367 2
a2368 1
		CTRACE((tfp, "cookie save file can be changed in next session only, restored.\n"));
d2379 1
a2379 1
static void disable_pausing (void)
d2388 1
a2388 1
static void force_dump_mode (void)
d2411 3
a2413 4
typedef struct parse_args_type
{
   const char *name;
   int type;
d2432 3
a2434 3
   /* If the NEED_NEXT_ARG flags is set, and the option was not specified
    * with an '=' character, then use the next argument in the argv list.
    */
d2436 3
a2438 4
   ParseData;
   const char *help_string;
}
Config_Type;
d2441 2
a2442 3
static int parse_authentication (
	char *			next_arg,
	char **		result)
d2445 1
a2445 1
     *  Authentication information for protected documents.
d2451 1
a2451 1
	memset(next_arg, ' ', strlen(next_arg));  /* Let's not show too much */
d2457 1
a2457 1
	if ((cp = strchr(auth_info, ':')) != 0) {		/* Pw */
d2462 1
a2462 1
	if (*auth_info) {					/* Id */
d2472 1
a2472 2
static int anonymous_fun (
	char *			next_arg GCC_UNUSED)
d2481 1
a2481 2
static int assume_charset_fun (
	char *			next_arg)
d2494 1
a2494 2
static int assume_local_charset_fun (
	char *			next_arg)
d2501 1
a2501 2
static int assume_unrec_charset_fun (
	char *			next_arg)
d2508 1
a2508 2
static int auth_fun (
	char *			next_arg)
d2515 1
a2515 2
static int base_fun (
	char *			next_arg GCC_UNUSED)
d2518 5
a2522 6
     *  Treat -source equivalently to an interactive download with
     *  LYPrefixBaseToSource configured to TRUE, so that a BASE tag is
     *  prepended for text/html content types.  We normally treat the
     *  module-wide global LYPrefixBaseToSource flag as FALSE with
     *  -source, but force it TRUE, later, if LYPrependBase is set
     *  TRUE here. - FM
d2532 1
a2532 2
static int cache_fun (
	char *			next_arg)
d2537 1
a2537 1
     *  Limit size.
d2539 2
a2540 1
    if (HTCacheSize < 2) HTCacheSize = 2;
d2546 1
a2546 2
static int child_fun (
	char *			next_arg GCC_UNUSED)
d2555 1
a2555 2
static int color_fun (
	char *			next_arg GCC_UNUSED)
d2568 1
a2568 2
static int convert_to_fun (
	char *			next_arg)
d2574 1
d2577 1
a2577 1
	/*LYLowerCase(outformat);*/
d2584 2
a2585 3
				 *cp4 != ';'  &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
d2590 2
a2591 1
		if (chndl < 0) chndl = UCLYhndl_for_unrec;
d2594 1
a2594 1
		    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
d2611 1
a2611 2
static int crawl_fun (
	char *			next_arg GCC_UNUSED)
d2619 1
a2619 2
static int display_fun (
	char *			next_arg)
d2629 1
a2629 2
static int display_charset_fun (
	char *			next_arg)
d2637 1
a2637 1
    if (i < 0) {	/* do nothing here: so fallback to lynx.cfg */
d2640 1
a2640 2
    }
    else
d2646 1
a2646 2
static int dump_output_fun (
	char *			next_arg GCC_UNUSED)
d2653 1
a2653 2
static int editor_fun (
	char *			next_arg)
d2662 1
a2662 2
static int error_file_fun (
	char *			next_arg)
d2665 1
a2665 2
     *  Output return (success/failure) code
     *  of an HTTP transaction.
d2674 1
a2674 2
static int exec_fun (
	char *			next_arg GCC_UNUSED)
d2686 1
a2686 2
static int get_data_fun (
	char *			next_arg GCC_UNUSED)
d2689 1
a2689 1
     *  User data for GET form.
d2695 2
a2696 2
     *  On Unix, conflicts with curses when interactive
     *  so let's force a dump.  - CL
d2698 2
a2699 2
     *  On VMS, mods have been made in LYCurses.c to deal with
     *  potential conflicts, so don't force the dump here. - FM
d2705 1
a2705 1
    StrAllocCopy(form_get_data, "?");   /* Prime the pump */
d2709 2
a2710 2
     *  Build GET data for later.  Stop reading when we see a line
     *  with "---" as its first three characters.
d2716 2
d2722 1
a2722 2
static int help_fun (
	char *			next_arg GCC_UNUSED)
d2724 1
a2724 1
    print_help_and_exit (0);
d2729 1
a2729 2
static int hiddenlinks_fun (
	char *			next_arg)
d2731 1
d2738 1
d2742 1
a2742 1
	    print_help_and_exit (-1);
d2751 1
a2751 2
static int homepage_fun (
	char *			next_arg)
d2761 1
a2761 2
static int mime_header_fun (
	char *			next_arg GCC_UNUSED)
d2764 1
a2764 1
     *  Include mime headers and force source dump.
d2776 1
a2776 2
static int newschunksize_fun (
	char *			next_arg)
d2791 1
a2791 2
static int newsmaxchunk_fun (
	char *			next_arg)
d2807 1
a2807 2
static int nobold_fun (
	char *			next_arg GCC_UNUSED)
d2809 2
a2810 2
   LYnoVideo(1);
   return 0;
d2814 1
a2814 2
static int nobrowse_fun (
	char *			next_arg GCC_UNUSED)
d2816 2
a2817 2
   HTDirAccess = HT_DIR_FORBID;
   return 0;
d2821 1
a2821 2
static int nocolor_fun (
	char *			next_arg GCC_UNUSED)
d2832 1
a2832 2
static int nopause_fun (
	char *			next_arg GCC_UNUSED)
d2839 1
a2839 2
static int noreverse_fun (
	char *			next_arg GCC_UNUSED)
d2841 2
a2842 2
   LYnoVideo(2);
   return 0;
d2846 1
a2846 2
static int nounderline_fun (
	char *			next_arg GCC_UNUSED)
d2848 2
a2849 2
   LYnoVideo(4);
   return 0;
d2854 1
a2854 2
static int nozap_fun (
	char *			next_arg)
d2856 1
a2856 1
    LYNoZapKey = 1; /* everything but "initially" treated as "full" - kw */
d2862 1
a2862 1
   return 0;
d2867 1
a2867 2
static int pauth_fun (
	char *			next_arg)
d2874 1
a2874 2
static int post_data_fun (
	char *			next_arg GCC_UNUSED)
d2877 1
a2877 1
     *  User data for POST form.
d2905 1
a2905 2
static char *show_restriction (
	const char *		name)
d2924 1
a2924 2
static int restrictions_fun (
	char *			next_arg)
d2926 1
d3044 8
a3051 5
    static const char *Usage[] = {
 ""
,"USAGE: lynx -restrictions=[option][,option][,option]"
,"List of Options:"
,"  ?                 when used alone, list restrictions in effect."
d3060 1
a3060 1
	SetOutputMode( O_TEXT );
d3066 1
a3066 1
	     || !strcmp(table[j].name, "default")) {
d3071 1
a3071 2
	    print_help_strings (
		table[j].name, table[j].help, value, FALSE);
d3074 1
a3074 1
	for (j = 0; ; j++) {
d3100 1
a3100 1
	SetOutputMode( O_BINARY );
d3103 1
a3103 1
	SetOutputMode( O_TEXT );
d3105 1
a3105 1
	SetOutputMode( O_BINARY );
d3114 1
a3114 2
static int selective_fun (
	char *			next_arg GCC_UNUSED)
d3116 2
a3117 2
   HTDirAccess = HT_DIR_SELECTIVE;
   return 0;
d3121 1
a3121 2
static int source_fun (
	char *			next_arg GCC_UNUSED)
d3131 1
a3131 2
static int traversal_fun (
	char *			next_arg GCC_UNUSED)
d3144 1
a3144 2
static int version_fun (
	char *			next_arg GCC_UNUSED)
d3148 1
a3148 1
    SetOutputMode( O_TEXT );
d3158 12
d3206 5
a3210 8
    printf("\n");
    printf(gettext(
	  "Copyrights held by the University of Kansas, CERN, and other contributors.\n"
	  ));
    printf(gettext("Distributed under the GNU General Public License.\n"));
    printf(gettext(
	  "See http://lynx.isc.org/ and the online help for more information.\n\n"
	  ));
d3212 1
a3212 1
    printf("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.\n");
d3214 1
a3214 1
    printf("See http://www.openssl.org/ for information about OpenSSL.\n");
d3216 1
a3216 1
    printf("\n");
d3219 1
a3219 1
    SetOutputMode( O_BINARY );
d3227 1
a3227 2
static int width_fun (
	char *			next_arg)
d3231 1
d3241 1
a3241 2
static int scrsize_fun (
	char *			next_arg)
d3267 1
d3486 1
a3486 1
      "get_data",	6|FUNCTION_ARG,		get_data_fun,
d3494 1
a3494 1
      "help",		5|FUNCTION_ARG,		help_fun,
d3639 1
a3639 1
      "nosocks",	6|UNSET_ARG,		socks_flag,
d3685 1
a3685 1
      "post_data",	6|FUNCTION_ARG,		post_data_fun,
d3760 1
a3760 1
      "show_cfg",	4|SET_ARG,		show_cfg,
d3804 4
d3905 1
d3907 4
a3910 5
static void print_help_strings (
	const char *	name,
	const char *	help,
	const char *	value,
	BOOLEAN	option)
d3917 1
a3917 1
    pad = field_width - (2 + option + (int) strlen (name));
d3919 1
a3919 1
    fprintf (stdout, "  %s%s", option ? "-" : "", name);
d3924 1
a3924 1
	    fputc (' ', stdout);
d3927 1
a3927 1
	fputc (' ', stdout);	  /* at least one space */
d3933 2
a3934 2
    if (strchr (help, '\n') == 0) {
	fprintf (stdout, "%s", help);
d3943 1
a3943 1
		fputc (c, stdout);
d3945 1
a3945 1
		    fputc (' ', stdout);
d3947 1
a3947 1
		fputc (c, stdout);
d3955 1
a3955 1
    fputc ('\n', stdout);
d3958 1
a3958 1
static void print_help_and_exit (int exit_status)
d3962 2
a3963 1
    if (pgm == NULL) pgm = "lynx";
d3965 1
a3965 1
    SetOutputMode( O_TEXT );
d3967 2
a3968 2
    fprintf (stdout, gettext("USAGE: %s [options] [file]\n"), pgm);
    fprintf (stdout, gettext("Options are:\n"));
d3971 1
a3971 1
"receive the arguments from stdin (enclose\n\
d3982 16
a3997 19
	    case TOGGLE_ARG:
	    case SET_ARG:
		strcpy(temp, *(q->set_value) ? "on" : "off");
		break;
	    case UNSET_ARG:
		strcpy(temp, *(q->set_value) ? "off" : "on");
		break;
	    case INT_ARG:
		sprintf(temp, "%d", *(q->int_value));
		break;
	    case TIME_ARG:
		sprintf(temp, SECS_FMT, (double) Secs2SECS(*(q->int_value)));
		break;
	    case STRING_ARG:
		if ((value = *(q->str_value)) != 0
		 && !*value)
		    value = 0;
		break;
	    default:
d3999 4
a4002 1
		break;
d4007 1
a4007 1
    SetOutputMode( O_BINARY );
d4009 1
a4009 1
    exit (exit_status);
d4020 3
a4022 4
static int arg_eqs_parse (
	const char *	a,
	char *		b,
	char **	c)
d4029 2
a4030 2
	 || (*a == 0)
	 || (*b == 0)) {
d4066 1
a4066 1
		result = 0;
d4078 11
a4088 4
static BOOL parse_arg (
	char **	argv,
	unsigned	mask,
	int *		i)
d4092 1
d4094 2
a4095 1
    static BOOLEAN had_nonoption = FALSE;
d4099 12
d4113 1
a4113 1
     *	Check for a command line startfile. - FM
d4115 3
a4117 4
#if !EXTENDED_OPTION_LOGIC
    if (*arg_name != '-')
#else
    if (*arg_name != '-' || no_options_further == TRUE )
d4119 1
a4119 1
    {
d4121 11
a4131 2
	if (had_nonoption && !dump_output_immediately) {
	    HTAddGotoURL(startfile); /* startfile was set by a previous arg */
a4132 1
	had_nonoption = TRUE;
d4136 1
a4136 1
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 20:11:17 */
d4139 1
a4139 1
	    char *p;
d4141 3
a4143 4
	    p = startfile;
	    while (*p++) {
		if (*p == '|')
		    *p = ':';
d4147 2
a4148 1
	return (BOOL)(i != 0);
d4151 1
a4151 1
    if (strcmp(arg_name,"--") == 0) {
d4161 2
a4162 3
     *	Skip any lone "-" arguments, because we've loaded
     *	the stdin input into an HTList structure for
     *	special handling. - FM
d4167 3
a4169 2
    /* allow GNU-style options with -- prefix*/
    if (*arg_name == '-') ++arg_name;
d4171 1
a4171 1
    CTRACE((tfp, "parse_arg(%s)\n", arg_name));
d4181 1
a4181 1
	    || (0 == arg_eqs_parse (p->name, arg_name, &next_arg))) {
d4189 2
a4190 2
		if ((i != 0) && (next_arg != 0))
		    (*i)++;
d4205 2
a4206 2
	     if (q->set_value != 0) {
		 if (next_arg == 0) {
d4209 2
a4210 2
			 *(q->set_value) = (BOOL) !(*(q->set_value));
			 break;
d4212 2
a4213 2
			 *(q->set_value) = TRUE;
			 break;
d4215 2
a4216 2
			 *(q->set_value) = FALSE;
			 break;
d4218 8
a4225 8
		 } else if (is_true(next_arg)) {
		     *(q->set_value) = TRUE;
		 } else if (is_false(next_arg)) {
		     *(q->set_value) = FALSE;
		 }
		 /* deliberately ignore anything else - BL */
	     }
	     break;
d4228 6
a4233 6
	     fun = q->fun_value;
	     if (0 != fun) {
		 if (-1 == (*fun) (next_arg)) {
		 }
	     }
	     break;
d4236 3
a4238 3
	     if ((q->str_value != 0) && (next_arg != 0))
		 StrAllocCopy(*(q->str_value), next_arg);
	     break;
d4241 3
a4243 3
	     if ((q->int_value != 0) && (next_arg != 0))
		 *(q->int_value) = strtol (next_arg, &temp_ptr, 0);
	     break;
d4248 2
a4249 1
		if (1 == sscanf (next_arg, "%f", &ival)) {
d4265 2
a4266 1
    if (pgm == 0) pgm = "LYNX";
d4268 2
a4269 2
    fprintf (stderr, gettext("%s: Invalid Option: %s\n"), pgm, argv[0]);
    print_help_and_exit (-1);
d4274 1
a4274 2
static void FatalProblem (
	int		sig)
d4277 1
a4277 1
     *	Ignore further interrupts. - mhc: 11/2/91
d4282 2
a4283 2
    (void) signal (SIGTERM, SIG_IGN);
    (void) signal (SIGINT, SIG_IGN);
d4293 1
a4293 1
     *	Flush all messages. - FM
d4299 1
a4299 1
     *	Deal with curses, if on, and clean up. - FM
d4314 1
a4314 1
     *	Issue appropriate messages and abort or exit. - FM
d4317 1
a4317 1
	fprintf (stderr, "\r\n\
d4334 22
a4355 9
#ifdef WIN_EX	/* 1998/08/09 (Sun) 09:58:25 */
	{
	    char *msg;
	    switch (sig) {
	    case SIGABRT:	msg = "SIGABRT";	break;
	    case SIGFPE:	msg = "SIGFPE";		break;
	    case SIGILL:	msg = "SIGILL";		break;
	    case SIGSEGV:	msg = "SIGSEGV";	break;
	    default:		msg = "Not-def";	break;
a4356 2
	    fprintf(stderr, "signal code = %s\n", msg);
	}
d4361 1
a4361 1
	 *  Exit and possibly dump core.
d4374 1
a4374 1
	 *  Exit without dumping core.
@


1.13
log
@* bump to 0x079D (a bit late for tiff, but hey)
* sync lists
* regenerate configure files
* remove MirLibtool, go back to gcc3 libtool :-(
* fix for $stuff
* remove dupes (libz, etc.) and unused (libintl, getopt)
* update lynx
* update texinfo.tex
etc.

XXX borked commit, eleventh try
@
text
@d1 1
a1 1
/* $MirBSD: LYMain.c,v 1.12 2004/01/18 16:56:16 tg Exp $
d13 6
a18 5
 * This work is provided "as is" with no explicit or implicit warran-
 * ties whatsoever to the maximum extent permitted by applicable law;
 * in no event may an author or contributor be held liable for damage
 * that is, directly or indirectly, caused by the work, even if advi-
 * sed of the possibility of such damage.
d94 1
a94 1
PUBLIC BOOLEAN socks_flag=TRUE;
d98 1
a98 1
PUBLIC BOOLEAN sigint = FALSE;
d102 1
a102 1
PRIVATE char init_ctrl_break[1];
d106 1
a106 1
PUBLIC char *mail_adrs = NULL;	/* the mask for a VMS mail transport */
d111 1
a111 1
PUBLIC BOOLEAN UseFixedRecords = USE_FIXED_RECORDS;
d115 2
a116 2
PRIVATE char *lynx_version_putenv_command = NULL;
PUBLIC char *list_format = NULL;	/* LONG_LIST formatting mask */
d118 1
a118 1
PUBLIC char *syslog_txt = NULL;		/* syslog arb text for session */
d123 6
a128 6
PUBLIC BOOLEAN lynx_edit_mode = FALSE;
PUBLIC BOOLEAN no_dired_support = FALSE;
PUBLIC HTList *tagged = NULL;
PUBLIC int LYAutoUncacheDirLists = 2; /* default dired uncaching behavior */
PUBLIC int dir_list_order = ORDER_BY_NAME;
PUBLIC int dir_list_style = MIXED_STYLE;
d131 1
a131 1
PUBLIC BOOLEAN prev_lynx_edit_mode = FALSE;
d136 1
a136 1
PUBLIC BOOLEAN no_change_exec_perms = TRUE;
d138 1
a138 1
PUBLIC BOOLEAN no_change_exec_perms = FALSE;
d145 1
a145 1
PUBLIC int HTCacheSize = DEFAULT_CACHE_SIZE;
d148 1
a148 1
PUBLIC int HTVirtualMemorySize = DEFAULT_VIRTUAL_MEMORY_SIZE;
d153 1
a153 1
PUBLIC BOOLEAN local_exec = LOCAL_EXECUTION_LINKS_ALWAYS_ON;
d155 1
a155 1
PUBLIC BOOLEAN local_exec = FALSE;
d157 1
a157 1
PUBLIC BOOLEAN local_exec_on_local_files =
d162 1
a162 1
PUBLIC char *LYCgiDocumentRoot = NULL; /* DOCUMENT_ROOT in the lynxcgi env */
d166 1
a166 1
PUBLIC BOOLEAN enable_scrollback=TRUE;
d168 1
a168 1
PUBLIC BOOLEAN enable_scrollback=FALSE;
d171 3
a173 3
PUBLIC char *empty_string = "\0";
PUBLIC int display_lines;  /* number of lines in display */
PUBLIC int www_search_result= -1;
d175 1
a175 1
PUBLIC lynx_list_item_type *printers = NULL;
d177 1
a177 1
PUBLIC lynx_list_item_type *downloaders = NULL;
d180 1
a180 1
PUBLIC lynx_list_item_type *externals = NULL;
d184 4
a187 4
PUBLIC lynx_list_item_type *uploaders = NULL;
PUBLIC int port_syntax = 1;
PUBLIC int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not */
PUBLIC int LYrcShowColor = SHOW_COLOR_UNKNOWN; /* ... last used */
d190 1
a190 1
PUBLIC BOOLEAN LYUseFormsOptions = TRUE; /* use forms-based options menu */
d193 41
a233 41
PUBLIC BOOLEAN LYJumpFileURL = FALSE;	 /* always FALSE the first time */
PUBLIC BOOLEAN LYPermitURL = FALSE;
PUBLIC BOOLEAN LYRestricted = FALSE; /* whether we have -anonymous option */
PUBLIC BOOLEAN LYShowCursor = SHOW_CURSOR; /* to show or not to show */
PUBLIC BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS; /* Show the links underlined vs bold */
PUBLIC BOOLEAN LYUseDefShoCur = TRUE;	/* Command line -show_cursor toggle */
PUBLIC BOOLEAN LYUserSpecifiedURL = TRUE;/* always TRUE  the first time */
PUBLIC BOOLEAN LYValidate = FALSE;
PUBLIC BOOLEAN LYforce_no_cache = FALSE;
PUBLIC BOOLEAN LYinternal_flag = FALSE; /* override no-cache b/c internal link*/
PUBLIC BOOLEAN LYoverride_no_cache = FALSE;/*override no-cache b/c history etc*/
PUBLIC BOOLEAN LYresubmit_posts = ALWAYS_RESUBMIT_POSTS;
PUBLIC BOOLEAN LYtrimInputFields = FALSE;
PUBLIC BOOLEAN bold_H1 = FALSE;
PUBLIC BOOLEAN bold_headers = FALSE;
PUBLIC BOOLEAN bold_name_anchors = FALSE;
PUBLIC BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
PUBLIC BOOLEAN check_mail = CHECKMAIL;
PUBLIC BOOLEAN child_lynx = FALSE;
PUBLIC BOOLEAN dump_output_immediately = FALSE;
PUBLIC BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
PUBLIC BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
PUBLIC BOOLEAN ftp_passive = FTP_PASSIVE; /* TRUE if doing ftp in passive mode */
PUBLIC BOOLEAN ftp_local_passive;
PUBLIC char *ftp_lasthost;
PUBLIC BOOLEAN goto_buffer = GOTOBUFFER; /* TRUE if offering default goto URL */
PUBLIC BOOLEAN historical_comments = FALSE;
PUBLIC BOOLEAN is_www_index = FALSE;
PUBLIC BOOLEAN jump_buffer = JUMPBUFFER; /* TRUE if offering default shortcut */
PUBLIC BOOLEAN lynx_mode = NORMAL_LYNX_MODE;
PUBLIC BOOLEAN minimal_comments = FALSE;
PUBLIC BOOLEAN nolist = FALSE;
PUBLIC BOOLEAN number_fields_on_left = TRUE;
PUBLIC BOOLEAN number_links_on_left = TRUE;
PUBLIC BOOLEAN recent_sizechange = FALSE;/* the window size changed recently? */
PUBLIC BOOLEAN soft_dquotes = FALSE;
PUBLIC BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
PUBLIC BOOLEAN verbose_img = VERBOSE_IMAGES;  /* show filenames or not */
PUBLIC BOOLEAN vi_keys = VI_KEYS_ALWAYS_ON;
PUBLIC int keypad_mode = DEFAULT_KEYPAD_MODE;
PUBLIC int user_mode = NOVICE_MODE;
d235 1
a235 1
PUBLIC BOOLEAN telnet_ok = TRUE;
d237 1
a237 1
PUBLIC BOOLEAN news_ok = TRUE;
d239 52
a290 52
PUBLIC BOOLEAN rlogin_ok = TRUE;
PUBLIC BOOLEAN long_url_ok = FALSE;
PUBLIC BOOLEAN ftp_ok = TRUE;
PUBLIC BOOLEAN system_editor = FALSE;

PUBLIC BOOLEAN had_restrictions_default = FALSE;
PUBLIC BOOLEAN had_restrictions_all = FALSE;

PUBLIC BOOLEAN exec_frozen = FALSE;
PUBLIC BOOLEAN no_bookmark = FALSE;
PUBLIC BOOLEAN no_bookmark_exec = FALSE;
PUBLIC BOOLEAN no_chdir = FALSE;
PUBLIC BOOLEAN no_disk_save = FALSE;
PUBLIC BOOLEAN no_dotfiles = NO_DOT_FILES;
PUBLIC BOOLEAN no_download = FALSE;
PUBLIC BOOLEAN no_editor = FALSE;
PUBLIC BOOLEAN no_exec = FALSE;
PUBLIC BOOLEAN no_file_url = FALSE;
PUBLIC BOOLEAN no_goto = FALSE;
PUBLIC BOOLEAN no_goto_configinfo = FALSE;
PUBLIC BOOLEAN no_goto_cso = FALSE;
PUBLIC BOOLEAN no_goto_file = FALSE;
PUBLIC BOOLEAN no_goto_finger = FALSE;
PUBLIC BOOLEAN no_goto_ftp = FALSE;
PUBLIC BOOLEAN no_goto_gopher = FALSE;
PUBLIC BOOLEAN no_goto_http = FALSE;
PUBLIC BOOLEAN no_goto_https = FALSE;
PUBLIC BOOLEAN no_goto_lynxcgi = FALSE;
PUBLIC BOOLEAN no_goto_lynxexec = FALSE;
PUBLIC BOOLEAN no_goto_lynxprog = FALSE;
PUBLIC BOOLEAN no_goto_mailto = FALSE;
PUBLIC BOOLEAN no_goto_rlogin = FALSE;
PUBLIC BOOLEAN no_goto_telnet = FALSE;
PUBLIC BOOLEAN no_goto_tn3270 = FALSE;
PUBLIC BOOLEAN no_goto_wais = FALSE;
PUBLIC BOOLEAN no_inside_ftp = FALSE;
PUBLIC BOOLEAN no_inside_rlogin = FALSE;
PUBLIC BOOLEAN no_inside_telnet = FALSE;
PUBLIC BOOLEAN no_jump = FALSE;
PUBLIC BOOLEAN no_lynxcfg_info = FALSE;
PUBLIC BOOLEAN no_lynxcgi = FALSE;
PUBLIC BOOLEAN no_mail = FALSE;
PUBLIC BOOLEAN no_multibook = FALSE;
PUBLIC BOOLEAN no_option_save = FALSE;
PUBLIC BOOLEAN no_outside_ftp = FALSE;
PUBLIC BOOLEAN no_outside_rlogin = FALSE;
PUBLIC BOOLEAN no_outside_telnet = FALSE;
PUBLIC BOOLEAN no_print = FALSE;
PUBLIC BOOLEAN no_shell = FALSE;
PUBLIC BOOLEAN no_suspend = FALSE;
PUBLIC BOOLEAN no_telnet_port = FALSE;
PUBLIC BOOLEAN no_useragent = FALSE;
d293 6
a298 6
PUBLIC BOOLEAN no_goto_news = FALSE;
PUBLIC BOOLEAN no_goto_nntp = FALSE;
PUBLIC BOOLEAN no_goto_snews = FALSE;
PUBLIC BOOLEAN no_inside_news = FALSE;
PUBLIC BOOLEAN no_newspost = FALSE;
PUBLIC BOOLEAN no_outside_news = FALSE;
d302 1
a302 1
PUBLIC BOOLEAN no_externals = FALSE;
d306 1
a306 1
PUBLIC BOOLEAN no_lynxcfg_xinfo = FALSE;
d308 1
a308 1
PUBLIC BOOLEAN no_compileopts_info = FALSE;
d312 8
a319 8
PUBLIC BOOLEAN no_statusline = FALSE;
PUBLIC BOOLEAN no_filereferer = TRUE;
PUBLIC char LYRefererWithQuery = 'D';	/* 'D' for drop */
PUBLIC BOOLEAN local_host_only = FALSE;
PUBLIC BOOLEAN override_no_download = FALSE;
PUBLIC BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
PUBLIC BOOLEAN LYforce_HTML_mode = FALSE;
PUBLIC BOOLEAN LYfind_leaks = TRUE;
d322 2
a323 2
PUBLIC BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
PUBLIC BOOLEAN dj_is_bash = FALSE;  /* Check for bash shell under DJGPP */
d327 2
a328 2
PUBLIC BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
PUBLIC char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
d333 3
a335 3
PUBLIC int lynx_timeout = TIMEOUT;
PUBLIC CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
PUBLIC CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
d339 1
a339 1
PUBLIC BOOLEAN system_is_NT = FALSE;
d343 1
a343 1
PUBLIC BOOLEAN show_cfg = FALSE;
d346 1
a346 1
PUBLIC BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */
d349 1
a349 1
PUBLIC BOOLEAN mail_is_blat = TRUE;
d354 1
a354 1
PUBLIC BOOLEAN term_blink_is_boldbg = TRUE;
d356 1
a356 1
PUBLIC BOOLEAN term_blink_is_boldbg = FALSE;
d360 105
a464 105
PUBLIC BOOLEAN HEAD_request = FALSE;
PUBLIC BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
PUBLIC BOOLEAN LYCancelledFetch = FALSE;/* TRUE if cancelled binary fetch */
PUBLIC BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
PUBLIC BOOLEAN LYDefaultRawMode;
PUBLIC BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
PUBLIC BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
PUBLIC BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
PUBLIC BOOLEAN LYNewsPosting = NEWS_POSTING; /* News posting supported? */
PUBLIC BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
PUBLIC BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
PUBLIC BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
PUBLIC BOOLEAN LYRawMode;
PUBLIC BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
PUBLIC BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
PUBLIC BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
PUBLIC BOOLEAN LYUseDefaultRawMode = TRUE;
PUBLIC BOOLEAN LYUseMouse = FALSE;
PUBLIC BOOLEAN LYisConfiguredForX = FALSE;
PUBLIC BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
PUBLIC BOOLEAN UCSaveBookmarksInUnicode = FALSE;
PUBLIC BOOLEAN bookmark_start = FALSE;
PUBLIC BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
PUBLIC BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
PUBLIC BOOLEAN crawl = FALSE;		/* Do crawl? */
PUBLIC BOOLEAN keep_mime_headers = FALSE; /* Include mime headers with source dump */
PUBLIC BOOLEAN more = FALSE;		/* is there more text to display? */
PUBLIC BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
PUBLIC BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
PUBLIC BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
PUBLIC BOOLEAN scan_for_buried_news_references = TRUE;
PUBLIC BOOLEAN startfile_ok = FALSE;
PUBLIC BOOLEAN startfile_stdin = FALSE;
PUBLIC BOOLEAN traversal = FALSE;	/* Do traversals? */
PUBLIC char *BookmarkPage = NULL;	/* the name of the current bookmark page */
PUBLIC char *LYCookieAcceptDomains = NULL; /* domains to accept all cookies */
PUBLIC char *LYCookieLooseCheckDomains = NULL;  /* check loosely   */
PUBLIC char *LYCookieQueryCheckDomains = NULL;  /* check w/a query */
PUBLIC char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieSAcceptDomains = NULL; /* domains to accept all cookies */
PUBLIC char *LYCookieSLooseCheckDomains = NULL;  /* check loosely   */
PUBLIC char *LYCookieSQueryCheckDomains = NULL;  /* check w/a query */
PUBLIC char *LYCookieSRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieSStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYHostName = NULL;		/* treat as a local host name */
PUBLIC char *LYLocalDomain = NULL;	/* treat as a local domain tail */
PUBLIC char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
PUBLIC char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
PUBLIC char *LynxHome = NULL;		/* the default Home HREF. */
PUBLIC char *LynxSigFile = NULL;	/* Signature file, in or off home */
PUBLIC char *UCAssume_MIMEcharset = NULL;
PUBLIC char *URLDomainPrefixes = NULL;
PUBLIC char *URLDomainSuffixes = NULL;
PUBLIC char *authentication_info[2] = {NULL, NULL}; /* Id:Password for protected documents */
PUBLIC char *bookmark_page = NULL;	/* the name of the default bookmark page */
PUBLIC char *editor = NULL;		/* the name of the current editor */
PUBLIC char *form_get_data = NULL;	/* User data for get form */
PUBLIC char *form_post_data = NULL;	/* User data for post form */
PUBLIC char *global_extension_map = NULL;  /* global mime.types */
PUBLIC char *global_type_map = NULL;	/* global mailcap */
PUBLIC char *helpfile = NULL;		/* the main help file */
PUBLIC char *helpfilepath = NULL;	/* the path to the help file set */
PUBLIC char *homepage = NULL;		/* home page or main screen */
PUBLIC char *http_error_file = NULL;	/* Place HTTP status code in this file */
PUBLIC char *indexfile = NULL;		/* an index file if there is one */
PUBLIC char *jumpfile = NULL;		/* the name of the default jumps file */
PUBLIC char *jumpprompt = NULL;		/* the default jumps prompt */
PUBLIC char *language = NULL;		/* preferred language */
PUBLIC char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
PUBLIC char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
PUBLIC char *lynx_cmd_script;		/* file to read keystroke commands, if any */
PUBLIC char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
PUBLIC char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
PUBLIC char *lynxjumpfile = NULL;	/* the current jump file URL */
PUBLIC char *lynxlinksfile = NULL;	/* the current visited links file URL */
PUBLIC char *lynxlistfile = NULL;	/* the current list file URL */
PUBLIC char *original_dir = NULL;	/* the original directory */
PUBLIC char *personal_extension_map = NULL;/* .mime.types */
PUBLIC char *personal_mail_address = NULL; /* the users mail address */
PUBLIC char *personal_type_map = NULL;	   /* .mailcap */
PUBLIC char *pref_charset = NULL;	/* preferred character set */
PUBLIC char *proxyauth_info[2] = {NULL, NULL}; /* Id:Password for protected proxy servers */
PUBLIC char *startfile = NULL;		/* the first file */
PUBLIC char *startrealm = NULL;		/* the startfile realm */
PUBLIC char *system_mail = NULL;	/* The path for sending mail */
PUBLIC char *system_mail_flags = NULL;	/* Flags for sending mail */
PUBLIC char *x_display = NULL;		/* display environment variable */
PUBLIC HistInfo history[MAXHIST];
PUBLIC int AlertSecs;			/* time-delay for HTAlert() messages   */
PUBLIC int DebugSecs;			/* time-delay for HTProgress messages */
PUBLIC int InfoSecs;			/* time-delay for Information messages */
PUBLIC int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
PUBLIC int LYStatusLine = -1;		/* Line for statusline() if > -1 */
PUBLIC int LYcols = DFT_COLS;
PUBLIC int LYlines = DFT_ROWS;
PUBLIC int MessageSecs;			/* time-delay for important Messages   */
PUBLIC int ReplaySecs;			/* time-delay for command-scripts */
PUBLIC int ccount = 0;			/* Starting number for lnk#.dat files in crawls */
PUBLIC int dump_output_width = 0;
PUBLIC int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
PUBLIC int nhist = 0;			/* number of history entries */
PUBLIC int nlinks = 0;			/* number of links in memory */
PUBLIC int outgoing_mail_charset = -1;	/* translate mail to this charset */
PUBLIC LinkInfo links[MAXLINKS];
d467 5
a471 5
PUBLIC BOOLEAN BibP_bibhost_available = FALSE;  /* until check succeeds  */
PUBLIC BOOLEAN BibP_bibhost_checked = FALSE;  /*  until LYCheckBibHost   */
PUBLIC BOOLEAN no_goto_bibp = FALSE;
PUBLIC char *BibP_bibhost = NULL;	 /* local server for bibp: links  */
PUBLIC char *BibP_globalserver = NULL;   /* global server for bibp: links */
d475 3
a477 3
PUBLIC BOOLEAN persistent_cookies = FALSE; /* disabled by default! */
PUBLIC char *LYCookieFile = NULL;	/* cookie read file */
PUBLIC char *LYCookieSaveFile = NULL;	/* cookie save file */
d481 1
a481 1
PUBLIC BOOLEAN nested_tables =
d490 2
a491 2
PUBLIC BOOLEAN LYShowTransferRate = TRUE;
PUBLIC int LYTransferRate = rateKB;
d493 3
a495 3
PUBLIC char *XLoadImageCommand = NULL;	/* Default image viewer for X */
PUBLIC BOOLEAN LYNoISMAPifUSEMAP = FALSE; /* Omit ISMAP link if MAP present? */
PUBLIC int LYHiddenLinks = HIDDENLINKS_SEPARATE; /* Show hidden links? */
d497 2
a498 2
PUBLIC int Old_DTD = NO;
PRIVATE BOOL DTD_recovery = NO;
d501 1
a501 1
PUBLIC FILE *LYTraceLogFP = NULL;		/* Pointer for TRACE log  */
d503 2
a504 2
PUBLIC char *LYTraceLogPath = NULL;		/* Path for TRACE log	   */
PUBLIC BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?	   */
d506 10
a515 10
PUBLIC BOOLEAN LYSeekFragMAPinCur = TRUE;
PUBLIC BOOLEAN LYSeekFragAREAinCur = TRUE;
PUBLIC BOOLEAN LYStripDotDotURLs = TRUE;	/* Try to fix ../ in some URLs? */
PUBLIC BOOLEAN LYForceSSLCookiesSecure = FALSE;
PUBLIC BOOLEAN LYNoCc = FALSE;
PUBLIC BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
PUBLIC BOOLEAN LYPrependBaseToSource = TRUE;
PUBLIC BOOLEAN LYPrependCharsetToSource = TRUE;
PUBLIC BOOLEAN LYQuitDefaultYes = QUIT_DEFAULT_YES;
PUBLIC BOOLEAN dont_wrap_pre = FALSE;
d517 1
a517 1
PUBLIC int cookie_noprompt;
d520 1
a520 1
PUBLIC int ssl_noprompt = FORCE_PROMPT_DFT;
d523 1
a523 1
PUBLIC int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/
d526 2
a527 2
PUBLIC BOOL ok_justify = TRUE;
PUBLIC int justify_max_void_percent = 35;
d531 1
a531 1
PUBLIC BOOLEAN LYLocaleCharset = FALSE;
d535 1
a535 1
PUBLIC BOOLEAN with_backspaces = FALSE;
d539 2
a540 2
PUBLIC int scrsize_x = 0;
PUBLIC int scrsize_y = 0;
d543 1
a543 1
PUBLIC BOOL force_empty_hrefless_a = FALSE;
d546 2
a547 2
PUBLIC BOOL textfields_need_activation = FALSE;
PUBLIC BOOL textfields_activation_option = FALSE;
d550 1
a550 1
PUBLIC BOOLEAN textfield_prompt_at_left_edge = FALSE;
d553 1
a553 1
PUBLIC char* hidden_link_marker = NULL;
d557 3
a559 3
PUBLIC BOOLEAN display_partial_flag = TRUE; /* Display document during download */
PUBLIC BOOLEAN debug_display_partial = FALSE; /* Show with MessageSecs delay */
PUBLIC int partial_threshold = -1;  /* # of lines to be d/l'ed until we repaint */
d562 3
a564 3
PUBLIC BOOLEAN LYNonRestartingSIGWINCH = FALSE;
PUBLIC BOOLEAN LYReuseTempfiles = FALSE;
PUBLIC BOOLEAN LYUseBuiltinSuffixes = TRUE;
d567 1
a567 1
PUBLIC int LYNoZapKey = 0; /* 0: off (do z checking), 1: full, 2: initially */
d574 1
a574 1
PUBLIC BOOLEAN FileInitAlreadyDone = FALSE;
d576 7
a582 7
PRIVATE BOOLEAN stack_dump = FALSE;
PRIVATE char *terminal = NULL;
PRIVATE char *pgm;
PRIVATE BOOLEAN number_links = FALSE;
PRIVATE BOOLEAN number_fields = FALSE;
PRIVATE BOOLEAN LYPrependBase = FALSE;
PRIVATE HTList *LYStdinArgs = NULL;
d602 1
a602 1
PRIVATE BOOLEAN no_options_further=FALSE; /* set to TRUE after '--' argument */
d605 3
a607 3
PRIVATE BOOL parse_arg PARAMS((char **arg, unsigned mask, int *i));
PRIVATE void print_help_and_exit PARAMS((int exit_status)) GCC_NORETURN;
PRIVATE void print_help_strings PARAMS((CONST char * name, CONST char * help, CONST char * value, BOOLEAN option));
d610 3
a612 3
PUBLIC BOOLEAN LYNoCore = NO_FORCED_CORE_DUMP;
PUBLIC BOOLEAN restore_sigpipe_for_children = FALSE;
PRIVATE void FatalProblem PARAMS((int sig));
d616 1
a616 1
PUBLIC char *lynx_lss_file = NULL;
d620 1
a620 1
PRIVATE void LY_set_ctrl_break(int setting)
d626 1
a626 1
PRIVATE int LY_get_ctrl_break(void)
d635 1
a635 1
PRIVATE void reset_break(void)
d642 1
a642 1
PRIVATE int is_windows_nt(void)
d656 1
a656 1
PRIVATE void free_lynx_globals NOARGS
d759 1
a759 1
PRIVATE void LYStdinArgs_free NOARGS
d775 2
a776 2
PUBLIC void exit_immediately ARGS1(
	int,		code)
d814 1
a814 1
PRIVATE void FixCharacters(void)
d832 3
a834 3
PRIVATE int argncmp ARGS2(
	char*,		str,
	char*,		what)
d845 3
a847 3
PRIVATE void tildeExpand ARGS2(
	char **,	pathname,
	BOOLEAN,	embedded)
d877 3
a879 3
PRIVATE BOOL GetStdin ARGS2(
	char **,	buf,
	BOOL,		marker)
d892 1
a892 1
PRIVATE BOOL cleanup_win32(DWORD fdwCtrlType)
d908 3
a910 3
PRIVATE void append_ssl_version ARGS2(
	char **,	target,
	char *,		separator)
d950 3
a952 3
PUBLIC int main ARGS2(
	int,		argc,
	char **,	argv)
d1194 1
a1194 1
    StrAllocCat(LYUserAgent, 
d2214 1
a2214 1
PUBLIC void LYRegisterLynxProtocols NOARGS
d2241 1
a2241 1
PUBLIC void reload_read_cfg NOARGS
d2385 1
a2385 1
PRIVATE void disable_pausing NOARGS
d2394 1
a2394 1
PRIVATE void force_dump_mode NOARGS
d2419 1
a2419 1
   CONST char *name;
d2444 1
a2444 1
   CONST char *help_string;
d2449 3
a2451 3
PRIVATE int parse_authentication ARGS2(
	char *,			next_arg,
	char **,		result)
d2481 2
a2482 2
PRIVATE int anonymous_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2491 2
a2492 2
PRIVATE int assume_charset_fun ARGS1(
	char *,			next_arg)
d2505 2
a2506 2
PRIVATE int assume_local_charset_fun ARGS1(
	char *,			next_arg)
d2513 2
a2514 2
PRIVATE int assume_unrec_charset_fun ARGS1(
	char *,			next_arg)
d2521 2
a2522 2
PRIVATE int auth_fun ARGS1(
	char *,			next_arg)
d2529 2
a2530 2
PRIVATE int base_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2548 2
a2549 2
PRIVATE int cache_fun ARGS1(
	char *,			next_arg)
d2562 2
a2563 2
PRIVATE int child_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2572 2
a2573 2
PRIVATE int color_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2586 2
a2587 2
PRIVATE int convert_to_fun ARGS1(
	char *,			next_arg)
d2629 2
a2630 2
PRIVATE int crawl_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2638 2
a2639 2
PRIVATE int display_fun ARGS1(
	char *,			next_arg)
d2649 2
a2650 2
PRIVATE int display_charset_fun ARGS1(
	char *,			next_arg)
d2668 2
a2669 2
PRIVATE int dump_output_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2676 2
a2677 2
PRIVATE int editor_fun ARGS1(
	char *,			next_arg)
d2686 2
a2687 2
PRIVATE int error_file_fun ARGS1(
	char *,			next_arg)
d2700 2
a2701 2
PRIVATE int exec_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2713 2
a2714 2
PRIVATE int get_data_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2748 2
a2749 2
PRIVATE int help_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2756 2
a2757 2
PRIVATE int hiddenlinks_fun ARGS1(
	char *,			next_arg)
d2777 2
a2778 2
PRIVATE int homepage_fun ARGS1(
	char *,			next_arg)
d2788 2
a2789 2
PRIVATE int mime_header_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2804 2
a2805 2
PRIVATE int newschunksize_fun ARGS1(
	char *,			next_arg)
d2820 2
a2821 2
PRIVATE int newsmaxchunk_fun ARGS1(
	char *,			next_arg)
d2837 2
a2838 2
PRIVATE int nobold_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2845 2
a2846 2
PRIVATE int nobrowse_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2853 2
a2854 2
PRIVATE int nocolor_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2865 2
a2866 2
PRIVATE int nopause_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2873 2
a2874 2
PRIVATE int noreverse_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2881 2
a2882 2
PRIVATE int nounderline_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2890 2
a2891 2
PRIVATE int nozap_fun ARGS1(
	char *,			next_arg)
d2904 2
a2905 2
PRIVATE int pauth_fun ARGS1(
	char *,			next_arg)
d2912 2
a2913 2
PRIVATE int post_data_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2944 2
a2945 2
PRIVATE char *show_restriction ARGS1(
	CONST char *,		name)
d2964 2
a2965 2
PRIVATE int restrictions_fun ARGS1(
	char *,			next_arg)
d2967 3
a2969 3
    static CONST struct {
	CONST char *name;
	CONST char *help;
d3084 1
a3084 1
    static CONST char *Usage[] = {
d3092 2
a3093 2
    CONST char *name;
    CONST char *value;
d3152 2
a3153 2
PRIVATE int selective_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3160 2
a3161 2
PRIVATE int source_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3171 2
a3172 2
PRIVATE int traversal_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3185 2
a3186 2
PRIVATE int version_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3260 2
a3261 2
PRIVATE int width_fun ARGS1(
	char *,			next_arg)
d3274 2
a3275 2
PRIVATE int scrsize_fun ARGS1(
	char *,			next_arg)
d3301 1
a3301 1
PRIVATE Config_Type Arg_Table [] =
d3935 5
a3939 5
PRIVATE void print_help_strings ARGS4(
	CONST char *,	name,
	CONST char *,	help,
	CONST char *,	value,
	BOOLEAN,	option)
d3987 1
a3987 1
PRIVATE void print_help_and_exit ARGS1(int, exit_status)
d4048 4
a4051 4
PRIVATE int arg_eqs_parse ARGS3(
	CONST char *,	a,
	char *,		b,
	char **,	c)
d4107 4
a4110 4
PRIVATE BOOL parse_arg ARGS3(
	char **,	argv,
	unsigned,	mask,
	int *,		i)
d4273 2
a4274 2
PRIVATE void FatalProblem ARGS1(
	int,		sig)
@


1.12
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.8 2003/12/17 14:35:00 tg Exp $
d196 1
d529 4
d1625 4
d3241 1
a3241 1
	  "See http://lynx.browser.org/ and the online help for more information.\n\n"
d3880 4
@


1.11
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d1 1
a1 1
/* $MirBSD: LYMain.c,v 1.10 2003/09/18 21:35:56 tg Exp $
d3 2
a4 1
 * Copyright (c) 2002, 2003 Thorsten Glaser <x86@@ePost.de>
d9 1
a9 1
 * fy, publically perform, give away, merge or sublicense it provided
d12 1
d14 1
a14 1
 * ties whatsoever to the maximum extend permitted by applicable law;
d101 1
a101 1
char init_ctrl_break[1];
d321 1
d472 1
a472 1
#ifdef EXP_PERSISTENT_COOKIES
d476 1
a476 1
#endif /* EXP_PERSISTENT_COOKIES */
d489 1
a489 1
PUBLIC int LYTransferRate = rateEtaKB_maybe;
d532 5
d701 1
a701 1
#ifdef EXP_PERSISTENT_COOKIES
d899 43
a958 4
#ifdef USE_SSL
    char SSLLibraryVersion[256];
    char *SSLcp;
#endif /* USE_SSL */
d1032 4
d1151 1
d1158 4
d1182 1
a1182 12
    StrAllocCat(LYUserAgent, " SSL-MM/1.4.1");
#ifdef OPENSSL_VERSION_TEXT
    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = '/';
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    StrAllocCat(LYUserAgent, " ");
	    StrAllocCat(LYUserAgent, SSLLibraryVersion);
	}
    }
#endif /* OPENSSL_VERSION_TEXT */
d1184 1
d1194 1
d1203 1
a1255 4
#ifdef __OpenBSD__
    StrAllocCat(lynx_temp_space, "/lynx-XXXXXXXXXX");
    lynx_temp_space = mkdtemp(lynx_temp_space);
#endif
d1713 1
a1713 1
#ifdef EXP_PERSISTENT_COOKIES
d1897 1
a1897 1
#ifdef SOURCE_CACHE
d2133 1
a2133 1
#ifdef EXP_PERSISTENT_COOKIES
d2141 1
a2141 1
#endif /* EXP_PERSISTENT_COOKIES */
d2170 9
d2283 1
a2283 1
#ifdef EXP_PERSISTENT_COOKIES
d2304 1
a2304 1
#ifdef SOURCE_CACHE
d2351 1
a2351 1
#ifdef EXP_PERSISTENT_COOKIES
d3178 1
a3178 4
#ifdef USE_SSL
    char SSLLibraryVersion[256];
    char *SSLcp;
#endif
d3182 3
a3184 3
    printf(gettext("%s Version %s (%s)\n"),
	  LYNX_NAME, LYNX_VERSION,
	  LYVersionDate());
d3186 3
a3188 12
    printf("libwww-FM %s, SSL-MM 1.4.1", HTLibraryVersion);
#ifdef OPENSSL_VERSION_TEXT
    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = ' ';
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    printf(", %s", SSLLibraryVersion);
	}
    }
#endif /* OPENSSL_VERSION_TEXT */
    printf("\n");
d3190 2
d3262 28
d3387 1
a3387 1
#ifdef EXP_PERSISTENT_COOKIES
d3396 1
a3396 1
#endif /* EXP_PERSISTENT_COOKIES */
d3757 6
d3791 1
a3791 1
#ifdef EXP_READPROGRESS
@


1.10
log
@live code, part ][: macroes suck. big whales through straw pipes.
@
text
@d1 1
a1 1
/* $MirBSD: LYMain.c,v 1.9 2003/09/18 20:06:25 tg Exp $
d927 1
a927 2
    ftp_lasthost = (char *)malloc(sizeof(char));
    *ftp_lasthost = NULL;
@


1.9
log
@re-do the lynx user-agent string code, expanding for
MirOS and other OS building Lynx from MirBSD source
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.5 2003/07/26 12:33:13 tg Exp $
d1101 4
a1104 1
    StrAllocCopy(LYUserAgent, "Mozilla/5.0 (UNIX; U; "
d1106 1
a1106 1
	"OpenBSD"
d1108 1
a1108 1
	"GNU/Linux"
d1110 1
a1110 1
	"Win32"
d1112 1
a1112 1
	"Windows (non-32 bit)"
d1114 1
a1114 1
	"VMS"
d1116 1
a1116 1
	"other"
d1118 1
a1118 1
	"; C; compatible) ");
d1140 1
a1140 1
    StrAllocCat(LYUserAgent, " Revision/MirOS:"
d1142 3
a1144 1
	MACHINE_OS " (https://MirBSD.BSDadvocacy.org:8890/)"
d1146 2
a1147 1
	"other (third party building Lynx from MirBSD source)"
d1155 1
a1155 1
	" fake (MSIE 5.5)");
@


1.8
log
@I meant: ~/.etc/bookmark.htm
@
text
@d1 1
a1 1
/* $MirBSD: LYMain.c,v 1.7 2003/09/01 18:49:53 tg Exp $
d1101 15
a1115 2
#ifdef	__OpenBSD__
    StrAllocCopy(LYUserAgent, "Mozilla/5.0 (UNIX; U; OpenBSD; C; compatible) ");
a1116 3
#else	/* def __OpenBSD__ */
    StrAllocCopy(LYUserAgent, LYNX_NAME);
#endif	/* ! def __OpenBSD__ */
d1137 6
a1142 3
#ifdef	__MirBSD__
    StrAllocCat(LYUserAgent, " Revision/MirBSD"
	" (https://MirBSD.BSDadvocacy.org:8890/)"
a1149 1
#endif	/* def __MirBSD__ */
@


1.7
log
@~/.lynx_cookies		-> ~/.etc/cookies.txt
~/.lynx_bookmarks.html	-> ~/.etc/bookmarks.htm
@
text
@d1 1
a1 1
/* $MirBSD: LYMain.c,v 1.6 2003/07/07 20:31:17 tg Exp $
d2030 1
a2030 1
	HTSprintf0(&temp, "./.etc/bookmarks.htm");
@


1.6
log
@adjust default user agent
@
text
@d1 1
a1 1
/* $MirBSD: LYMain.c,v 1.5 2003/07/07 20:00:29 tg Exp $
d85 1
a85 1
#define COOKIE_FILE ".lynx_cookies"
d2030 1
a2030 1
	HTSprintf0(&temp, "lynx_bookmarks%s", HTML_SUFFIX);
@


1.5
log
@improve temp file handlink, from openbsd:
- mkdtemp temp space directory (art)
@
text
@d1 1
a1 1
/* $MirBSD: LYMain.c,v 1.4 2003/07/07 19:55:45 tg Exp $
d1101 4
d1106 1
d1127 11
@


1.4
log
@from OpenBSD (with minor changes):
- default to ftp passive (deraadt)
When passive FTP fails, switch to active FTP and try again

Submitted by Andrew Basterfield <bob@@cemetery.homeunix.org>
@
text
@d1 1
a1 1
/* $MirBSD: licence.template,v 1.4 2003/07/07 19:03:08 tg Exp $
d1175 4
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 20
d212 2
d924 6
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d10 1
d16 1
d32 5
d41 3
a49 6
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
#include <syslog.h>
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */

d63 1
d66 1
d82 4
a86 1
PUBLIC char *mail_adrs = NULL;	/* the mask for a VMS mail transport */
a98 4
#ifdef VMS
PUBLIC char *LYCSwingPath = NULL;
#endif /* VMS */

d102 3
d106 1
a106 1
PUBLIC HTList *tagged = NULL;
d110 1
d118 1
d152 1
a152 1
PUBLIC lynx_printer_item_type *printers = NULL;
d154 1
a154 1
PUBLIC lynx_html_item_type *downloaders = NULL;
d157 1
a157 1
PUBLIC lynx_html_item_type *externals = NULL;
d160 2
a161 1
PUBLIC lynx_html_item_type *uploaders = NULL;
d163 3
a165 3
PUBLIC int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not to show */
PUBLIC int LYChosenShowColor = SHOW_COLOR_UNKNOWN; /* whether to show and save */
PUBLIC int LYrcShowColor = SHOW_COLOR_UNKNOWN;	/* ... as last read or written */
d169 4
a173 1
PUBLIC BOOLEAN verbose_img = VERBOSE_IMAGES;  /* show filenames or not */
d175 2
d178 1
a179 1
PUBLIC BOOLEAN LYinternal_flag = FALSE; /* override no-cache b/c internal link*/
d181 11
a191 4
PUBLIC BOOLEAN LYshow_kb_rate = TRUE;
PUBLIC BOOLEAN LYUserSpecifiedURL = TRUE;/* always TRUE  the first time */
PUBLIC BOOLEAN LYJumpFileURL = FALSE;	 /* always FALSE the first time */
PUBLIC BOOLEAN jump_buffer = JUMPBUFFER; /* TRUE if offering default shortcut */
d193 1
a193 6
PUBLIC BOOLEAN ftp_passive = FTP_PASSIVE; /* TRUE if doing ftp in passive mode */
PUBLIC BOOLEAN ftp_local_passive;    /* TRUE for PASV for this server only */
PUBLIC char *ftp_lasthost;           /* host of last ftp transaction */
PUBLIC BOOLEAN recent_sizechange = FALSE;/* the window size changed recently? */
PUBLIC int user_mode = NOVICE_MODE;
PUBLIC BOOLEAN dump_output_immediately = FALSE;
d195 1
d197 1
a197 4
PUBLIC BOOLEAN bold_headers = FALSE;
PUBLIC BOOLEAN bold_H1 = FALSE;
PUBLIC BOOLEAN bold_name_anchors = FALSE;
PUBLIC BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
d199 3
a201 2
PUBLIC BOOLEAN historical_comments = FALSE;
PUBLIC BOOLEAN minimal_comments = FALSE;
d203 2
a204 6
PUBLIC BOOLEAN LYRestricted = FALSE;
PUBLIC BOOLEAN LYValidate = FALSE;
PUBLIC BOOLEAN LYPermitURL = FALSE;
PUBLIC BOOLEAN child_lynx = FALSE;
PUBLIC BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
PUBLIC BOOLEAN check_mail = CHECKMAIL;
a205 1
PUBLIC BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
d207 2
a208 1
PUBLIC BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
d214 1
d217 5
a221 17
#ifdef USE_EXTERNALS
PUBLIC BOOLEAN no_externals = FALSE;
#endif
PUBLIC BOOLEAN no_inside_telnet = FALSE;
PUBLIC BOOLEAN no_outside_telnet = FALSE;
PUBLIC BOOLEAN no_telnet_port = FALSE;
#ifndef DISABLE_NEWS
PUBLIC BOOLEAN no_inside_news = FALSE;
PUBLIC BOOLEAN no_outside_news = FALSE;
#endif
PUBLIC BOOLEAN no_inside_ftp = FALSE;
PUBLIC BOOLEAN no_outside_ftp = FALSE;
PUBLIC BOOLEAN no_inside_rlogin = FALSE;
PUBLIC BOOLEAN no_outside_rlogin = FALSE;
PUBLIC BOOLEAN no_suspend = FALSE;
PUBLIC BOOLEAN no_editor = FALSE;
PUBLIC BOOLEAN no_shell = FALSE;
a222 1
PUBLIC BOOLEAN no_multibook = FALSE;
d224 3
a226 2
PUBLIC BOOLEAN no_option_save = FALSE;
PUBLIC BOOLEAN no_print = FALSE;
d228 1
a228 1
PUBLIC BOOLEAN no_disk_save = FALSE;
d230 1
a230 2
PUBLIC BOOLEAN no_lynxcgi = FALSE;
PUBLIC BOOLEAN exec_frozen = FALSE;
d232 1
a243 4
#ifndef DISABLE_NEWS
PUBLIC BOOLEAN no_goto_news = FALSE;
PUBLIC BOOLEAN no_goto_nntp = FALSE;
#endif
a244 3
#ifndef DISABLE_NEWS
PUBLIC BOOLEAN no_goto_snews = FALSE;
#endif
d248 3
d252 14
a265 1
PUBLIC BOOLEAN no_file_url = FALSE;
d267 4
d272 5
d278 8
a285 3
PUBLIC BOOLEAN no_mail = FALSE;
PUBLIC BOOLEAN no_dotfiles = NO_DOT_FILES;
PUBLIC BOOLEAN no_useragent = FALSE;
d287 2
a288 1
PUBLIC BOOLEAN no_filereferer = FALSE;
d291 1
a291 1
PUBLIC BOOLEAN show_dotfiles = FALSE; /* From rcfile if no_dotfiles is false */
d293 48
a340 25
PUBLIC char *editor = NULL;	/* the name of the current editor */
PUBLIC char *jumpfile = NULL;	/* the name of the default jumps file */
PUBLIC char *jumpprompt = NULL; /* the default jumps prompt */
PUBLIC char *bookmark_page = NULL; /* the name of the default bookmark page */
PUBLIC char *BookmarkPage = NULL;  /* the name of the current bookmark page */
PUBLIC char *LynxHome = NULL;	/* the default Home HREF. */
PUBLIC char *homepage = NULL;  /* home page or main screen */
PUBLIC char *original_dir = NULL; /* the original directory */
PUBLIC char *startfile = NULL;	/* the first file */
PUBLIC char *helpfile = NULL;	/* the main help file */
PUBLIC char *helpfilepath = NULL;   /* the path to the help file set */
PUBLIC char *lynxjumpfile = NULL;   /* the current jump file URL */
PUBLIC char *lynxlistfile = NULL;   /* the current list file URL */
PUBLIC char *lynxlinksfile = NULL;  /* the current visited links file URL */
PUBLIC char *startrealm = NULL;     /* the startfile realm */
PUBLIC char *indexfile = NULL;	    /* an index file if there is one */
PUBLIC int outgoing_mail_charset = -1;     /* translate mail to this charset */
PUBLIC char *personal_mail_address = NULL; /* the users mail address */
PUBLIC char *x_display = NULL;	    /* display environment variable */
PUBLIC char *personal_type_map = NULL;	   /* .mailcap */
PUBLIC char *global_type_map = NULL;	   /* global mailcap */
PUBLIC char *global_extension_map = NULL;  /* global mime.types */
PUBLIC char *personal_extension_map = NULL;/* .mime.types */
PUBLIC char *language = NULL;	    /* preferred language */
PUBLIC char *pref_charset = NULL;   /* preferred character set */
d342 3
a344 29
PUBLIC char *LynxSigFile = NULL;    /* Signature file, in or off home */
PUBLIC char *system_mail = NULL;	  /* The path for sending mail */
PUBLIC char *system_mail_flags = NULL;	  /* Flags for sending mail */
PUBLIC char *lynx_cfg_file = NULL;	  /* location of active lynx.cfg */
PUBLIC char *lynx_temp_space = NULL; /* The prefix for temporary file paths */
PUBLIC char *lynx_save_space = NULL; /* The prefix for save to disk paths */
PUBLIC char *LYHostName = NULL;		/* treat as a local host name */
PUBLIC char *LYLocalDomain = NULL;	/* treat as a local domain tail */
PUBLIC BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
PUBLIC BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
PUBLIC BOOLEAN crawl = FALSE;	     /* Do crawl? */
PUBLIC BOOLEAN traversal = FALSE;    /* Do traversals? */
PUBLIC BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
	       /* Links beyond a displayed page with no links? */
PUBLIC BOOLEAN more_links = FALSE;
PUBLIC int     ccount = 0; /* Starting number for lnk#.dat files in crawls */
PUBLIC BOOLEAN LYCancelledFetch = FALSE; /* TRUE if cancelled binary fetch */
	       /* Include mime headers with source dump */
PUBLIC BOOLEAN keep_mime_headers = FALSE;
PUBLIC BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
PUBLIC char *form_post_data = NULL;  /* User data for post form */
PUBLIC char *form_get_data = NULL;   /* User data for get form */
PUBLIC char *http_error_file = NULL; /* Place HTTP status code in this file */
	     /* Id:Password for protected documents */
PUBLIC char *authentication_info[2] = {NULL, NULL};
	     /* Id:Password for protected proxy servers */
PUBLIC char *proxyauth_info[2] = {NULL, NULL};
PUBLIC BOOLEAN HEAD_request = FALSE;
PUBLIC BOOLEAN scan_for_buried_news_references = TRUE;
d346 3
a348 1
PUBLIC BOOLEAN LYDefaultRawMode;
d350 3
a352 1
PUBLIC char *UCAssume_MIMEcharset = NULL;
a353 12
PUBLIC BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
PUBLIC int LYlines = 24;
PUBLIC int LYcols = 80;
PUBLIC int dump_output_width = 0;
PUBLIC linkstruct links[MAXLINKS];
PUBLIC histstruct history[MAXHIST];
PUBLIC int nlinks = 0;		/* number of links in memory */
PUBLIC int nhist = 0;		/* number of history entries */
PUBLIC int more = FALSE;	/* is there more text to display? */
PUBLIC int InfoSecs;	/* Seconds to sleep() for Information messages */
PUBLIC int MessageSecs; /* Seconds to sleep() for important Messages   */
PUBLIC int AlertSecs;	/* Seconds to sleep() for HTAlert() messages   */
d355 9
a363 11
PUBLIC char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
PUBLIC char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
PUBLIC BOOLEAN LYUseMouse = FALSE;
PUBLIC BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
PUBLIC BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
PUBLIC BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
PUBLIC BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
PUBLIC BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
PUBLIC BOOLEAN LYisConfiguredForX = FALSE;
PUBLIC char *URLDomainPrefixes = NULL;
PUBLIC char *URLDomainSuffixes = NULL;
d365 3
a367 9
PUBLIC BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
PUBLIC BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
PUBLIC BOOLEAN LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
PUBLIC BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
PUBLIC BOOLEAN LYMBMAdvanced = TRUE;
PUBLIC int LYStatusLine = -1;		 /* Line for statusline() if > -1 */
PUBLIC BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
PUBLIC BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
PUBLIC BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
a368 2
PUBLIC char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
d371 1
d373 2
d377 70
a446 2
PUBLIC char *LYCookieSLooseCheckDomains = NULL;  /* check loosely   */
PUBLIC char *LYCookieSQueryCheckDomains = NULL;  /* check w/a query */
d448 3
a450 2
BOOLEAN persistent_cookies = TRUE;
PUBLIC char *LYCookieFile = NULL;	   /* default cookie file */
d452 14
d470 4
a473 1
PUBLIC BOOL Old_DTD = NO;
d475 1
d478 1
a480 1

d484 1
a484 1
PUBLIC BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed?	 */
d488 31
d526 7
a532 5
/* These are declared in cutil.h for current freeWAIS libraries. - FM */
#ifdef DECLARE_WAIS_LOGFILES
PUBLIC char *log_file_name = NULL; /* for WAIS log file name	in libWWW */
PUBLIC FILE *logfile = NULL;	   /* for WAIS log file output	in libWWW */
#endif /* DECLARE_WAIS_LOGFILES */
d535 1
a535 2
extern int HTNewsChunkSize; /* Number of news articles per chunk (HTNews.c) */
extern int HTNewsMaxChunk;  /* Max news articles before chunking (HTNews.c) */
d538 2
d544 1
d553 12
d569 3
a571 3

PRIVATE void parse_arg PARAMS((char **arg, int *i));
PRIVATE void print_help_and_exit PARAMS((int exit_status));
d575 1
d579 2
a580 2
#if defined(USE_HASH)
    char *lynx_lss_file=NULL;
d584 1
a584 1
PRIVATE int LY_set_ctrl_break(int setting)
d605 14
d637 6
d644 1
a644 2
    FREE(LYCSwingPath);
#endif /* VMS */
d667 4
d673 1
a701 3
#ifndef VMS
    FREE(lynx_version_putenv_command);
#endif
d705 1
a705 1
#if defined(USE_HASH)
d709 1
a709 7
    {
	char *p = LYlist_temp_url();
	if (p && *p) {
	    *p = '\0';
	    FREE(p);
	}
    }
d714 1
d778 1
a778 1
static void FixCharacters(void)
d796 1
a796 2
/* these are used for matching commandline options. */
PRIVATE int argcmp ARGS2(
d801 6
a806 1
    return strcmp(str,what);
d809 3
a811 3
PRIVATE int argncmp ARGS2(
	char*,		str,
	char*,		what)
d813 52
a864 2
    if (str[0] == '-' && str[1] == '-' ) ++str;
    return strncmp(str, what, strlen(what));
d866 1
d880 1
d883 7
d891 7
a897 5
#ifndef DISABLE_FTP
    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
    ftp_lasthost = (char *)malloc(sizeof(char));
    *ftp_lasthost = NULL;
#endif /* DISABLE_FTP */
d903 4
a907 1
    WSADATA WSAData;
d912 1
a912 1
	wVerReq = MAKEWORD(1,1);
d918 15
a932 3
	    sleep(5);
	    return;
	}
d934 13
a946 1
#endif /* _WINDOWS */
d955 2
d958 1
a958 3
    dbug_init();
    sock_init();
#endif
d970 1
a970 1
    if (getenv("TERM")==NULL) putenv("TERM=vt100");
d978 2
a979 1
    if ((cp = strrchr(pgm, '/')) != NULL) {
d988 1
a988 1
	    parse_arg(&argv[i], &i);
d990 5
d1017 1
a1017 1
#ifdef HAVE_LIBINTL_H
d1019 3
a1021 1
    bindtextdomain ("lynx", LOCALEDIR);
d1033 1
a1033 1
    terminal = getenv("TERM");
d1040 2
a1041 2
    memset((void *)links, 0, sizeof(linkstruct)*MAXLINKS);
    memset((void *)history, 0, sizeof(histstruct)*MAXHIST);
a1047 3
#ifdef SYSLOG_REQUESTED_URLS
    openlog("lynx", LOG_PID, LOG_LOCAL5);
#endif /* SYSLOG_REQUESTED_URLS */
d1050 7
a1056 3
    InfoSecs	= (int)INFOSECS;
    MessageSecs = (int)MESSAGESECS;
    AlertSecs	= (int)ALERTSECS;
d1059 1
a1059 1
    LYEscapeStartfile(&startfile); 
d1068 1
d1070 3
d1080 14
d1106 1
a1106 1
    if ((cp = getenv("LYNX_TEMP_SPACE")) != NULL)
d1108 2
a1109 2
#if defined (UNIX)
    else if ((cp = getenv("TMPDIR")) != NULL)
d1113 4
a1116 4
    else if ((cp = getenv("TEMP")) != NULL)
	StrAllocCopy(lynx_temp_space, HTDOS_name(cp));
    else if ((cp = getenv("TMP")) != NULL)
	StrAllocCopy(lynx_temp_space, HTDOS_name(cp));
d1124 1
a1124 1
	exit(-1);
d1128 5
a1132 9
    if ((cp = strchr(lynx_temp_space, '~'))) {
	*(cp++) = '\0';
	StrAllocCopy(temp, lynx_temp_space);
	LYTrimPathSep(temp);
	StrAllocCat(temp, wwwName(Home_Dir()));
	StrAllocCat(temp, cp);
	StrAllocCopy(lynx_temp_space, temp);
	FREE(temp);
    }
d1136 1
a1136 1
	if ((cp1 = (char *)getenv("USER")) != NULL) {
d1147 1
a1147 2
    StrAllocCat(lynx_temp_space, "/lynx-XXXXXX");
    lynx_temp_space = mkdtemp(lynx_temp_space);
d1166 1
d1168 17
a1184 1
#ifdef VMS
d1186 2
a1187 4
#ifdef CSWING_PATH
    StrAllocCopy(LYCSwingPath, CSWING_PATH);
#endif /* CSWING_PATH */
#endif /* VMS */
d1193 1
d1199 5
d1211 1
a1211 1
    no_newspost = (LYNewsPosting == FALSE);
d1221 5
d1227 1
a1227 41
	if (argncmp(argv[i], "-trace") == 0) {
	    WWW_TraceFlag = TRUE;
	} else if (argncmp(argv[i], "-tlog") == 0) {
	    if (LYUseTraceLog) {
		LYUseTraceLog = FALSE;
	    } else {
		LYUseTraceLog = TRUE;
	    }
	} else if (argncmp(argv[i], "-anonymous") == 0) {
	    if (!LYValidate)
		parse_restrictions("default");
	    LYRestricted = TRUE;
	} else if (argcmp(argv[i], "-validate") == 0) {
	    /*
	     *	Follow only http URLs.
	     */
	    LYValidate = TRUE;
#ifdef SOCKS
	} else if (argncmp(argv[i], "-nosocks") == 0) {
	    socks_flag = FALSE;
#endif /* SOCKS */
	} else if (argncmp(argv[i], "-cfg") == 0) {
	    if ((cp=strchr(argv[i],'=')) != NULL)
		StrAllocCopy(lynx_cfg_file, cp+1);
	    else {
		StrAllocCopy(lynx_cfg_file, argv[i+1]);
		i++;
	    }

#if defined(USE_HASH)
	} else if (argncmp(argv[i], "-lss") == 0) {
	    if ((cp=strchr(argv[i],'=')) != NULL)
		StrAllocCopy(lynx_lss_file, cp+1);
	    else {
		StrAllocCopy(lynx_lss_file, argv[i+1]);
		i++;
	    }
	    CTRACE(tfp, "LYMain found -lss flag, lss file is %s\n",
		    lynx_lss_file ? lynx_lss_file : "<NONE>");
#endif
	}
d1242 1
a1242 1
     *	-post_data, the data are terminate by a "___" string, alone
d1248 1
d1254 7
a1260 110
	while (LYSafeGets(&buf, stdin) != 0) {
	    int j;

	    for (j = strlen(buf) - 1; j > 0 &&
		(buf[j] == CR || buf[j] == LF); j--) {
		buf[j] = '\0';
	    }

	    if (argncmp(buf, "-trace") == 0) {
		WWW_TraceFlag = TRUE;
	    } else if (argncmp(buf, "-tlog") == 0) {
		if (LYUseTraceLog) {
		    LYUseTraceLog = FALSE;
		} else {
		    LYUseTraceLog = TRUE;
		}
	    } else if (argncmp(buf, "-anonymous") == 0) {
		if (!LYValidate && !LYRestricted)
		    parse_restrictions("default");
		LYRestricted = TRUE;
	    } else if (argcmp(buf, "-validate") == 0) {
		/*
		 *  Follow only http URLs.
		 */
		LYValidate = TRUE;
#ifdef SOCKS
	    } else if (argncmp(buf, "-nosocks") == 0) {
		socks_flag = FALSE;
#endif /* SOCKS */
	    } else if (argncmp(buf, "-cfg") == 0) {
		if ((cp = strchr(buf,'=')) != NULL) {
		    StrAllocCopy(lynx_cfg_file, cp+1);
		} else {
		    cp = LYSkipNonBlanks(buf);
		    cp = LYSkipBlanks(cp);
		    if (*cp)
			StrAllocCopy(lynx_cfg_file, cp);
		}
#if defined(USE_HASH)
	    } else if (argncmp(buf, "-lss") == 0) {
		if ((cp = strchr(buf,'=')) != NULL) {
		    StrAllocCopy(lynx_lss_file, cp+1);
		} else {
		    cp = LYSkipNonBlanks(buf);
		    cp = LYSkipBlanks(cp);
		    if (*cp)
			StrAllocCopy(lynx_lss_file, cp);
		}
		CTRACE(tfp, "LYMain found -lss flag, lss file is %s\n",
			lynx_lss_file ? lynx_lss_file : "<NONE>");
#endif
	    } else if (argcmp(buf, "-get_data") == 0) {
		/*
		 *  User data for GET form.
		 */
		char **get_data;

		/*
		 *  On Unix, conflicts with curses when interactive
		 *  so let's force a dump.  - CL
		 *
		 *  On VMS, mods have been made in LYCurses.c to deal
		 *  with potential conflicts, so don't force the dump
		 *  here. - FM
		 */
#ifndef VMS
		dump_output_immediately = TRUE;
		LYcols = 80;
#endif /* VMS */

		StrAllocCopy(form_get_data, "?");   /* Prime the pump */
		get_data = &form_get_data;

		/*
		 *  Build GET data for later.  Stop reading when we see
		 *  a line with "---" as its first three characters.
		 */
		while (LYSafeGets(&buf, stdin) != 0 &&
		       strncmp(buf, "---", 3) != 0) {
		    int j2;

		    /*
		     *	Strip line terminators.
		     */
		    for (j2 = strlen(buf) - 1; j2 >= 0 &&
			 (buf[j2] == CR || buf[j2] == LF); j2--) {
			buf[j2] = '\0';
		    }
		    StrAllocCat(*get_data, buf);
		}
	    } else if (argcmp(buf, "-post_data") == 0) {
		/*
		 *  User data for POST form.
		 */
		char **post_data;

		/*
		 *  On Unix, conflicts with curses when interactive
		 *  so let's force a dump.  - CL
		 *
		 *  On VMS, mods have been made in LYCurses.c to deal
		 *  with potential conflicts, so don't force a dump
		 *  here. - FM
		 */
#ifndef VMS
		dump_output_immediately = TRUE;
		LYcols = 80;
#endif /* VMS */

		post_data = &form_post_data;
d1262 2
a1263 18
		/*
		 *  Build post data for later.	Stop reading when we see
		 *  a line with "---" as its first three characters.
		 */
		while (LYSafeGets(&buf, stdin) != 0 &&
		       strncmp(buf, "---", 3) != 0) {
		    int j2;

		     /*
		      *  Strip line terminators.
		      */
		    for (j2 = strlen(buf) - 1; j2 >= 0 &&
			 (buf[j2] == CR || buf[j2] == LF); j2--) {
			buf[j2] = '\0';
		    }
		    StrAllocCat(*post_data, buf);
		}
	    } else if (buf[0] != '\0') {
d1274 3
d1279 1
d1304 1
a1304 1
	strlen((char *)ANONYMOUS_USER) > 0 &&
d1306 2
a1307 2
	!strcasecomp(((char *)getenv("USER")==NULL ? " " : getenv("USER")),
		     ANONYMOUS_USER))
d1309 2
a1310 2
#if HAVE_CUSERID
	STREQ((char *)cuserid((char *) NULL), ANONYMOUS_USER))
d1312 1
a1312 1
	STREQ(((char *)getlogin()==NULL ? " " : getlogin()), ANONYMOUS_USER))
d1315 1
a1315 1
    {
d1324 4
a1327 1
    LYAddPathToHome(LYTraceLogPath = malloc(LY_MAXPATH), LY_MAXPATH, "Lynx.trace");
d1330 17
d1354 4
a1357 9
	temp = (char *)malloc(strlen(jumpfile) + 10);
	if (!temp) {
	    outofmem(__FILE__, "main");
	} else {
	    sprintf(temp, "JUMPFILE:%s", jumpfile);
	    if (!LYJumpInit(temp)) {
		CTRACE(tfp, "Failed to register %s\n", temp);
	    }
	    FREE(temp);
d1359 1
d1368 2
a1369 2
	if (((cp=getenv("LYNX_CFG")) != NULL) ||
	    (cp=getenv("lynx_cfg")) != NULL)
a1379 3
    /*
     *	Convert a '~' in the configuration file path to $HOME.
     */
d1381 1
a1381 12
   /* I think this should only be performed if lynx_cfg_file starts with ~/ */
   if ((lynx_cfg_file[0] == '~') && LYIsPathSep(lynx_cfg_file[1]))
     {
#ifdef VMS
	StrAllocCopy(temp, HTVMS_wwwName((char *)Home_Dir()));
#else
	StrAllocCopy(temp, Home_Dir());
#endif /* VMS */
	StrAllocCat(temp, lynx_cfg_file + 1);
	StrAllocCopy(lynx_cfg_file, temp);
	FREE(temp);
     }
d1388 1
a1388 1
    if ((fp = fopen(lynx_cfg_file, "r")) == NULL) {
d1391 1
a1391 1
	exit(-1);
a1392 6
    fclose(fp);

#if defined(USE_KEYMAPS) && defined(USE_SLANG)
    if (-1 == lynx_initialize_keymaps ())
	exit (-1);
#endif
d1400 1
a1400 1
	exit(-1);
d1411 5
d1422 1
a1422 1
			LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d1429 1
a1429 1
	exit(-1);
d1432 1
a1432 1
#if defined(USE_HASH)
d1438 2
a1439 2
	if (((cp=getenv("LYNX_LSS")) != NULL) ||
	    (cp=getenv("lynx_lss")) != NULL)
d1450 2
a1451 16
    /*
     *	Convert a '~' in the lynx-style file path to $HOME.
     */
    if ((cp = strchr(lynx_lss_file, '~'))) {
	*(cp++) = '\0';
	StrAllocCopy(temp, lynx_lss_file);
	LYTrimPathSep(temp);
#ifdef VMS
	StrAllocCat(temp, HTVMS_wwwName((char *)Home_Dir()));
#else
	StrAllocCat(temp, Home_Dir());
#endif /* VMS */
	StrAllocCat(temp, cp);
	StrAllocCopy(lynx_lss_file, temp);
	FREE(temp);
    }
d1456 1
a1456 1
    if ((fp = fopen(lynx_lss_file, "r")) == NULL) {
a1461 1
	fclose(fp);
d1464 1
a1464 1
#endif /* USE_HASH */
d1466 1
a1466 1
#if USE_COLOR_TABLE
d1477 1
a1477 1
	if ((cp = getenv("PWD")) != 0)
d1486 1
a1486 1
    strcpy(filename, LYNX_SIG_FILE);
d1491 1
a1491 1
	CTRACE(tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile);
d1493 1
a1493 1
	CTRACE(tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE);
d1496 1
a1496 1
#ifdef USE_PSRC
d1509 1
a1509 1
    read_rc();
d1514 1
a1514 1
    if ((cp = getenv("WWW_HOME")) != NULL) {
a1524 1
    LYFillLocalFileURL((char **)&LynxHome, "file://localhost");
d1531 1
a1531 1
	parse_arg(&argv[i], &i);
d1544 1
a1544 1
	     parse_arg(my_args, (int *)0);
d1548 40
d1593 1
a1593 1
#ifdef USE_PSRC
d1608 2
d1613 1
a1613 1
	   LYAddPathToHome(LYCookieFile = malloc(LY_MAXPATH), LY_MAXPATH, COOKIE_FILE);
d1615 1
a1615 9
	    if ((cp = strchr(LYCookieFile, '~'))) {
		temp = NULL;
		*(cp++) = '\0';
		StrAllocCopy(temp, cp);
		LYTrimPathSep(temp);
		StrAllocCopy(LYCookieFile, wwwName(Home_Dir()));
		StrAllocCat(LYCookieFile, temp);
		FREE(temp);
	    }
d1619 18
d1652 1
a1652 1
    if ((cp=getenv("LYNX_SAVE_SPACE")) != NULL)
d1662 1
a1662 9
	if ((cp = strchr(lynx_save_space, '~')) != NULL) {
	    *(cp++) = '\0';
	    StrAllocCopy(temp, lynx_save_space);
	    LYTrimPathSep(temp);
	    StrAllocCat(temp, wwwName(Home_Dir()));
	    StrAllocCat(temp, cp);
	    StrAllocCopy(lynx_save_space, temp);
	    FREE(temp);
	}
d1692 2
a1693 1
    HTFileInit();
d1695 7
a1701 6
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    if (syslog_txt) {
	syslog(LOG_INFO, "Session start:%s", syslog_txt);
    } else {
	syslog(LOG_INFO, "Session start");
d1703 1
a1703 2
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d1710 1
a1710 1
	       getenv("COLORTERM") != NULL) {
d1737 13
a1749 3
    if (number_links && keypad_mode == NUMBERS_AS_ARROWS)
	keypad_mode = LINKS_ARE_NUMBERED;
    if (keypad_mode == NUMBERS_AS_ARROWS)
d1751 1
d1757 1
a1757 4
	if (LYSelectPopups == TRUE)
	    LYSelectPopups = FALSE;
	else
	    LYSelectPopups = TRUE;
d1764 1
a1764 4
	if (LYShowCursor == TRUE)
	    LYShowCursor = FALSE;
	else
	    LYShowCursor = TRUE;
d1783 1
a1783 1
	LYMultiBookmarks = FALSE;
d1807 17
d1825 5
a1830 1
#ifndef NOSIGHUP
d1833 1
d1836 1
a1836 1
    (void) signal(SIGWINCH, size_change);
d1858 2
a1859 1
	(void) signal(SIGPIPE, SIG_IGN);
d1869 1
a1869 1
	(void) signal(SIGTSTP,SIG_IGN);
d1879 1
a1879 1
	exit_immediately(-1);
d1889 1
a1889 1
	exit_immediately(-1);
d1899 1
a1899 1
	exit_immediately(-1);
d1907 7
a1913 3
#ifdef USE_PSRC
    if (!dump_output_immediately)
	HTMLSRC_init_caches(); /* do it before terminal is initialized*/
a1923 1
    LYFillLocalFileURL((char **)&startfile, "file://localhost");
a1931 1
	LYFillLocalFileURL((char **)&homepage, "file://localhost");
d1951 1
a1951 1
	telnet_ok = !no_inside_telnet && !no_outside_telnet && telnet_ok;
d1953 1
a1953 1
	news_ok = !no_inside_news && !no_outside_news && news_ok;
d1955 2
a1956 2
	ftp_ok = !no_inside_ftp && !no_outside_ftp && ftp_ok;
	rlogin_ok = !no_inside_rlogin && !no_outside_rlogin && rlogin_ok;
d1958 2
a1959 2
	CTRACE(tfp,"LYMain.c: User in Local domain\n");
	telnet_ok = !no_inside_telnet && telnet_ok;
d1961 1
a1961 1
	news_ok = !no_inside_news && news_ok;
d1963 2
a1964 2
	ftp_ok = !no_inside_ftp && ftp_ok;
	rlogin_ok = !no_inside_rlogin && rlogin_ok;
d1967 2
a1968 2
	CTRACE(tfp,"LYMain.c: User in REMOTE domain\n");
	telnet_ok = !no_outside_telnet && telnet_ok;
d1970 1
a1970 1
	news_ok = !no_outside_news && news_ok;
d1972 2
a1973 2
	ftp_ok = !no_outside_ftp && ftp_ok;
	rlogin_ok = !no_outside_rlogin && rlogin_ok;
d1981 4
a1984 5
	StrAllocCopy(bookmark_page, "lynx_bookmarks");
	StrAllocCat(bookmark_page, HTML_SUFFIX);
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], "Default");
d1987 1
a1987 3
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
d1990 4
d2002 1
a2002 1
	if (crawl && !number_links) {
d2005 5
a2009 2
	    if (keypad_mode == NUMBERS_AS_ARROWS) {
		keypad_mode = LINKS_ARE_NUMBERED;
d2012 1
d2021 3
a2023 3
	    (keypad_mode == LINKS_ARE_NUMBERED ||
	     keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED))
	    printlist(stdout,FALSE);
d2031 1
a2031 1
	    LYStoreCookies(LYCookieFile);
a2032 1
	cleanup_files();
d2045 12
a2056 2
	ena_csi((LYlowest_eightbit[current_char_set] > 155));
	LYOpenCloset();
d2058 2
a2059 1
	LYCloseCloset();
d2070 1
a2070 1
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE
d2077 1
d2083 1
d2092 1
d2099 4
a2102 1
 *  to make things consistent.  Not implemented yet.
d2104 6
d2111 1
a2111 1
 *  Called by user of interactive session by LYNXCFG://reload/ link.
d2115 20
a2134 1
    if (LYRestricted) return;  /* for sure */
d2136 26
a2161 2
    /* save .lynxrc file in case we change something from Options Menu */
    if (!save_rc()) return;    /* can not write the very own file :( */
d2165 1
a2165 1
#ifdef PERSISTENT_COOKIES
d2167 21
a2187 1
	char * LYCookieFile_flag = LYCookieFile;
a2189 1
	free_lynx_cfg(); /* free downloaders, printers, not always environments */
d2196 1
a2196 1
	 *  Process the RC file.
d2198 4
a2201 1
	read_rc();
d2203 3
d2224 5
d2233 1
a2233 1
#ifdef PERSISTENT_COOKIES
d2235 16
a2250 8
	 if (persistent_cookies != persistent_cookies_flag) {
	     persistent_cookies = persistent_cookies_flag;
	     HTAlert(gettext("persistent cookies state will be changed in next session only."));
	 }
	 if (strcmp(LYCookieFile, LYCookieFile_flag)) {
	     StrAllocCopy(LYCookieFile, LYCookieFile_flag);
	     CTRACE(tfp, "cookies file can be changed in next session only, restored.\n")
	 }
d2257 15
d2283 5
a2287 29
struct parse_args_type;
typedef int (*ParseFunc) PARAMS((char *));

typedef union {
	BOOLEAN * set_value;
	int *     int_value;
	char **   str_value;
	ParseFunc fun_value;
} ParseUnion;

/*
 * Storing the four types of data in separate fields costs about 1K of data.
 * However, this provides usable type-checking.  The initial version of the
 * parse_args_type used 'long' for all types, and dumped core when processing
 * "lynx -help".  (The compiler was unable to detect some minor errors).
 */
#ifdef  PARSE_DEBUG
#define ParseData BOOLEAN *set_value; int *int_value; char **str_value; ParseFunc fun_value
#define PARSE_SET(n,t,v,h) {n,t,    v,  0,  0,  0,    h}
#define PARSE_INT(n,t,v,h) {n,t,    0,  v,  0,  0,    h}
#define PARSE_STR(n,t,v,h) {n,t,    0,  0,  v,  0,    h}
#define PARSE_FUN(n,t,v,h) {n,t,    0,  0,  0,  v,    h}
#else
#define ParseData long value
#define PARSE_SET(n,t,v,h) {n,t,   (long) (v),        h}
#define PARSE_INT(n,t,v,h) {n,t,   (long) (v),        h}
#define PARSE_STR(n,t,v,h) {n,t,   (long) (v),        h}
#define PARSE_FUN(n,t,v,h) {n,t,   (long) (v),        h}
#endif
d2293 11
a2303 10
#define IGNORE_ARG		0x000
#define TOGGLE_ARG		0x001
#define SET_ARG			0x002
#define UNSET_ARG		0x003
#define FUNCTION_ARG		0x004
#define LYSTRING_ARG		0x005
#define INT_ARG			0x006
#define STRING_ARG		0x007
#define ARG_TYPE_MASK		0x0FF
#define NEED_NEXT_ARG		0x100
d2306 1
d2318 1
a2318 1
Parse_Args_Type;
d2321 1
a2321 1
static int parse_authentication ARGS2(
d2353 1
a2353 1
static int anonymous_fun ARGS1(
d2356 4
a2359 9
   /*
    *  Should already have been set, so we don't
    *  override or replace any additional
    *  restrictions from the command line. - FM
    */
   if (!LYRestricted)
      parse_restrictions("default");
   LYRestricted = TRUE;
   return 0;
d2363 1
a2363 1
static int assume_charset_fun ARGS1(
d2377 1
a2377 1
static int assume_local_charset_fun ARGS1(
d2385 1
a2385 1
static int assume_unrec_charset_fun ARGS1(
d2393 1
a2393 1
static int auth_fun ARGS1(
d2401 1
a2401 1
static int base_fun ARGS1(
a2418 10
#ifdef USE_SLANG
/* -blink */
static int blink_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
    Lynx_Color_Flags |= SL_LYNX_USE_BLINK;
    return 0;
}
#endif

d2420 1
a2420 1
static int cache_fun ARGS1(
d2434 1
a2434 1
static int child_fun ARGS1(
d2444 1
a2444 1
static int color_fun ARGS1(
d2456 44
d2501 1
a2501 1
static int crawl_fun ARGS1(
d2505 1
a2505 1
    LYcols = 80;
d2510 12
a2521 1
static int display_fun ARGS1(
d2524 9
a2532 4
    if (next_arg != 0) {
	LYsetXDisplay(next_arg);
	if ((next_arg = LYgetXDisplay()) != 0)
	    StrAllocCopy(x_display, next_arg);
d2534 2
a2535 1

d2540 1
a2540 1
static int dump_output_fun ARGS1(
d2543 1
a2543 2
    dump_output_immediately = TRUE;
    LYcols = 80;
d2548 1
a2548 1
static int editor_fun ARGS1(
d2558 1
a2558 1
static int error_file_fun ARGS1(
d2572 1
a2572 1
static int exec_fun ARGS1(
d2585 1
a2585 1
static int get_data_fun ARGS1(
d2602 1
a2602 2
    dump_output_immediately = TRUE;
    LYcols = 80;
d2612 1
a2612 8
    while (LYSafeGets(&buf, stdin) != 0 &&
	  strncmp(buf, "---", 3) != 0) {
	int j;

	for (j = strlen(buf) - 1; j >= 0 && /* Strip line terminators */
	    (buf[j] == CR || buf[j] == LF); j--)
	    buf[j] = '\0';

d2620 1
a2620 1
static int help_fun ARGS1(
d2628 1
a2628 1
static int hiddenlinks_fun ARGS1(
d2631 7
d2639 1
a2639 7
	if (strncasecomp(next_arg, "merge", 1) == 0)
	    LYHiddenLinks = HIDDENLINKS_MERGE;
	else if (strncasecomp(next_arg, "listonly", 1) == 0)
	    LYHiddenLinks = HIDDENLINKS_SEPARATE;
	else if (strncasecomp(next_arg, "ignore", 1) == 0)
	    LYHiddenLinks = HIDDENLINKS_IGNORE;
	else
d2649 1
a2649 1
static int homepage_fun ARGS1(
d2660 1
a2660 1
static int mime_header_fun ARGS1(
d2667 1
a2667 1
    dump_output_immediately = TRUE;
d2670 1
a2670 1
    LYcols = 999;
d2676 1
a2676 1
static int newschunksize_fun ARGS1(
d2692 1
a2692 1
static int newsmaxchunk_fun ARGS1(
d2708 8
d2717 1
a2717 1
static int nobrowse_fun ARGS1(
d2725 1
a2725 1
static int nocolor_fun ARGS1(
d2737 1
a2737 1
static int nopause_fun ARGS1(
d2740 1
a2740 3
    InfoSecs = 0;
    MessageSecs = 0;
    AlertSecs = 0;
d2744 31
d2776 1
a2776 1
static int pauth_fun ARGS1(
d2784 1
a2784 1
static int post_data_fun ARGS1(
d2801 1
a2801 2
    dump_output_immediately = TRUE;
    LYcols = 80;
d2810 1
a2810 8
    while (LYSafeGets(&buf, stdin) != 0 &&
	  strncmp(buf, "---", 3) != 0) {
	int j;

	for (j = strlen(buf) - 1; j >= 0 && /* Strip line terminators */
	    (buf[j] == CR || buf[j] == LF); j--) {
	    buf[j] = '\0';
	}
d2816 19
d2836 1
a2836 1
static int restrictions_fun ARGS1(
d2839 7
a2845 7
    static CONST char *Usage[] = {
 ""
,"   USAGE: lynx -restrictions=[option][,option][,option]"
,"   List of Options:"
,"   all             restricts all options."
,"   bookmark        disallow changing the location of the bookmark file."
,"   bookmark_exec   disallow execution links via the bookmark file"
d2847 4
a2850 3
,"   change_exec_perms  disallow changing the eXecute permission on files"
,"                   (but still allow it for directories) when local file"
,"                   management is enabled."
d2852 19
a2870 6
,"   default         same as commandline option -anonymous.  Disables"
,"                   default services for anonymous users.  Currently set to,"
,"                   all restricted except for: inside_telnet, outside_telnet,"
,"                   inside_news, inside_ftp, outside_ftp, inside_rlogin,"
,"                   outside_rlogin, goto, jump and mail.  Defaults"
,"                   are settable within userdefs.h"
d2872 1
a2872 1
,"   dired_support   disallow local file management"
d2874 6
a2879 6
,"   disk_save       disallow saving to disk in the download and print menus"
,"   dotfiles        disallow access to, or creation of, hidden (dot) files"
,"   download        disallow downloaders in the download menu"
,"   editor          disallow editing"
,"   exec            disable execution scripts"
,"   exec_frozen     disallow the user from changing the execution link"
d2881 1
a2881 1
,"   externals       disable passing URLs to external programs"
d2883 4
a2886 3
,"   file_url        disallow using G)oto, served links or bookmarks for"
,"                   file: URL's"
,"   goto            disable the 'g' (goto) command"
d2888 22
a2909 14
,"   inside_ftp      disallow ftps for people coming from inside your"
,"                   domain (utmp required for selectivity)"
,"   inside_news     disallow USENET news posting for people coming from"
,"                   inside your domain (utmp required for selectivity)"
,"   inside_rlogin   disallow rlogins for people coming from inside your"
,"                   domain (utmp required for selectivity)"
,"   inside_telnet   disallow telnets for people coming from inside your"
,"                   domain (utmp required for selectivity)"
#else
,"   inside_ftp      disallow ftps for people coming from inside your domain"
,"   inside_news     disallow USENET news posting for people coming from inside"
,"                   your domain"
,"   inside_rlogin   disallow rlogins for people coming from inside your domain"
,"   inside_telnet   disallow telnets for people coming from inside your domain"
d2911 13
a2923 5
,"   jump            disable the 'j' (jump) command"
,"   mail            disallow mail"
,"   multibook       disallow multiple bookmark files"
,"   news_post       disallow USENET News posting."
,"   option_save     disallow saving options in .lynxrc"
d2925 22
a2946 14
,"   outside_ftp     disallow ftps for people coming from outside your"
,"                   domain (utmp required for selectivity)"
,"   outside_news    disallow USENET news posting for people coming from"
,"                   outside your domain (utmp required for selectivity)"
,"   outside_rlogin  disallow rlogins for people coming from outside your"
,"                   domain (utmp required for selectivity)"
,"   outside_telnet  disallow telnets for people coming from outside your"
,"                   domain (utmp required for selectivity)"
#else
,"   outside_ftp     disallow ftps for people coming from outside your domain"
,"   outside_news    disallow USENET news posting for people coming from outside"
,"                   your domain"
,"   outside_rlogin  disallow rlogins for people coming from outside your domain"
,"   outside_telnet  disallow telnets for people coming from outside your domain"
d2948 14
a2961 6
,"   print           disallow most print options"
,"   shell           disallow shell escapes, and lynxexec, lynxprog or lynxcgi"
,"                   G)oto's"
,"   suspend         disallow Control-Z suspends with escape to shell"
,"   telnet_port     disallow specifying a port in telnet G)oto's"
,"   useragent       disallow modifications of the User-Agent header"
d2963 4
a2966 1
    size_t n;
d2968 45
a3012 3
    if (next_arg != 0) {
	parse_restrictions(next_arg);
    } else {
d3014 1
a3014 2
	for (n = 0; n < sizeof(Usage)/sizeof(Usage[0]); n++)
	    printf("%s\n", Usage[n]);
d3016 3
a3018 1
	exit(0);
d3024 1
a3024 1
static int selective_fun ARGS1(
d3032 1
a3032 1
static int source_fun ARGS1(
d3035 1
a3035 1
    dump_output_immediately = TRUE;
d3038 1
a3038 1
    LYcols = 999;
d3043 1
a3043 1
static int traversal_fun ARGS1(
d3048 1
a3048 1
    LYcols = 80;
d3050 1
a3050 1
    LYcols = 999;
d3057 1
a3057 1
static int version_fun ARGS1(
d3060 5
d3067 15
d3083 2
a3084 6
    printf(gettext("\n%s Version %s (%.*s)\n"),
	  LYNX_NAME, LYNX_VERSION,
	  LYNX_DATE_LEN,
	  LYNX_RELEASE ? LYNX_RELEASE_DATE : &LYNX_DATE[LYNX_DATE_OFF]
	  );
#ifdef SYSTEM_NAME
d3091 6
d3098 18
d3117 1
d3126 7
d3136 1
a3136 1
    exit(0);
d3142 1
a3142 1
static int width_fun ARGS1(
d3148 1
a3148 1
	    dump_output_width = ((w < 999) ? w : 999);
d3154 2
a3155 2
/* NOTE: This table is sorted by name; the lookup relies on that. */
static Parse_Args_Type Arg_Table [] =
d3158 2
a3159 2
      "accept_all_cookies", SET_ARG,		&LYAcceptAllCookies,
      "\naccepts all cookies"
d3162 2
a3163 2
      "anonymous",	FUNCTION_ARG,	anonymous_fun,
      "used to specify the anonymous account"
d3166 1
a3166 1
      "assume_charset", NEED_FUNCTION_ARG, assume_charset_fun,
d3170 1
a3170 1
      "assume_local_charset",	NEED_FUNCTION_ARG,assume_local_charset_fun,
d3174 1
a3174 1
      "assume_unrec_charset",	NEED_FUNCTION_ARG,assume_unrec_charset_fun,
d3178 1
a3178 1
      "auth",		NEED_FUNCTION_ARG,	auth_fun,
d3182 1
a3182 1
      "base",		FUNCTION_ARG,		base_fun,
d3185 10
a3194 4
#ifdef USE_SLANG
   PARSE_FUN(
      "blink",		FUNCTION_ARG,		blink_fun,
      "force high intensity bg colors in color mode"
d3198 1
a3198 1
      "book",		SET_ARG,		&bookmark_start,
d3202 1
a3202 1
      "buried_news",	TOGGLE_ARG,		&scan_for_buried_news_references,
d3206 1
a3206 1
      "cache",		NEED_FUNCTION_ARG,	cache_fun,
d3210 1
a3210 1
      "case",		SET_ARG,		&case_sensitive,
d3213 4
d3218 1
a3218 1
      "cfg",		IGNORE_ARG|NEED_NEXT_ARG,	0,
d3222 1
a3222 1
      "child",		FUNCTION_ARG,		child_fun,
d3225 10
d3237 1
a3237 1
      "color",		FUNCTION_ARG,		color_fun,
d3241 8
a3248 3
   PARSE_SET(
      "cookies",	TOGGLE_ARG,		&LYSetCookies,
      "toggles handling of Set-Cookie headers"
d3250 1
d3253 5
a3257 1
      "cookie_file",	LYSTRING_ARG,		&LYCookieFile,
d3261 4
d3267 1
a3267 1
      "core",		TOGGLE_ARG,		&LYNoCore,
d3272 1
a3272 1
      "crawl",		FUNCTION_ARG,		crawl_fun,
d3276 6
d3284 1
a3284 1
      "debug_partial",	TOGGLE_ARG,		&debug_display_partial,
d3288 4
d3293 1
a3293 1
      "display",	NEED_FUNCTION_ARG,	display_fun,
d3297 10
a3306 1
      "dump",		FUNCTION_ARG,		dump_output_fun,
d3310 1
a3310 1
      "editor",		NEED_FUNCTION_ARG,	editor_fun,
d3314 1
a3314 1
      "emacskeys",	SET_ARG,		&emacs_keys,
d3318 1
a3318 1
      "enable_scrollback", TOGGLE_ARG,		&enable_scrollback,
d3323 1
a3323 1
      "error_file",	NEED_FUNCTION_ARG,	error_file_fun,
d3329 1
a3329 1
      "exec",		FUNCTION_ARG,		exec_fun,
d3333 2
d3336 2
a3337 2
      "locexec",	SET_ARG,		&local_exec_on_local_files,
      "enable local program execution from local files only"
d3339 2
d3342 2
a3343 2
      "noexec",		UNSET_ARG,		&local_exec,
      "disable local program execution (DEFAULT)"
d3345 1
a3345 2
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#ifdef VMS
d3347 2
a3348 2
      "fileversions",	SET_ARG,		&HTVMSFileVersions,
      "include all versions of files in local VMS directory\nlistings"
a3349 1
#endif
d3351 1
a3351 1
      "force_html",	SET_ARG,		&LYforce_HTML_mode,
d3355 1
a3355 1
      "force_secure",	TOGGLE_ARG,		&LYForceSSLCookiesSecure,
a3357 4
   PARSE_SET(
      "from",		TOGGLE_ARG,		&LYNoFromHeader,
      "toggle transmissions of From headers"
   ),
d3360 1
a3360 1
      "forms_options",	TOGGLE_ARG,		&LYUseFormsOptions,
d3365 5
a3369 1
      "ftp",		UNSET_ARG,		&ftp_ok,
d3373 1
a3373 1
      "get_data",	FUNCTION_ARG,		get_data_fun,
d3377 1
a3377 1
      "head",		SET_ARG,		&HEAD_request,
d3381 1
a3381 1
      "help",		FUNCTION_ARG,		help_fun,
d3385 1
a3385 1
      "hiddenlinks",	NEED_FUNCTION_ARG,	hiddenlinks_fun,
d3389 2
a3390 2
      "historical",	TOGGLE_ARG,		&historical_comments,
      "toggles use of '>' or '-->' as a terminator for comments"
d3393 1
a3393 1
      "homepage",	NEED_FUNCTION_ARG,	homepage_fun,
d3397 1
a3397 1
      "image_links",	TOGGLE_ARG,		&clickable_images,
d3401 1
a3401 1
      "index",		NEED_LYSTRING_ARG,	&indexfile,
d3405 1
a3405 1
      "ismap",		TOGGLE_ARG,		&LYNoISMAPifUSEMAP,
d3408 6
d3415 1
a3415 1
      "link",		NEED_INT_ARG,		&ccount,
d3419 1
a3419 1
      "localhost",	SET_ARG,		&local_host_only,
d3422 7
a3428 1
#if defined(USE_HASH)
d3430 1
a3430 1
      "lss",		IGNORE_ARG|NEED_NEXT_ARG,	0,
d3435 1
a3435 1
      "mime_header",	FUNCTION_ARG,		mime_header_fun,
d3439 1
a3439 1
      "minimal",	TOGGLE_ARG,		&minimal_comments,
d3442 6
d3450 1
a3450 1
      "newschunksize",	NEED_FUNCTION_ARG,	newschunksize_fun,
d3454 1
a3454 1
      "newsmaxchunk",	NEED_FUNCTION_ARG,	newsmaxchunk_fun,
d3458 6
d3465 5
a3469 1
      "nobrowse",	FUNCTION_ARG,		nobrowse_fun,
d3473 1
a3473 1
      "nocc",		SET_ARG,		&LYNoCc,
d3477 1
a3477 1
      "nocolor",	FUNCTION_ARG,		nocolor_fun,
d3480 6
d3487 2
a3488 2
      "nofilereferer",	SET_ARG,		&no_filereferer,
      "disable transmissions of Referer headers for file URLs"
d3491 1
a3491 1
      "nolist",		SET_ARG,		&nolist,
d3495 1
a3495 1
      "nolog",		UNSET_ARG,		&error_logging,
d3498 6
d3505 1
a3505 1
      "nopause",	FUNCTION_ARG,		nopause_fun,
d3509 2
a3510 2
      "noprint",	SET_ARG,		&no_print,
      "disable print functions"
d3513 1
a3513 1
      "noredir",	SET_ARG,		&no_url_redirection,
d3517 6
a3522 2
      "noreferer",	SET_ARG,		&LYNoRefererHeader,
      "disable transmissions of Referer headers"
d3526 1
a3526 1
      "nosocks",	UNSET_ARG,		&socks_flag,
d3531 1
a3531 1
      "nostatus",	SET_ARG,		&no_statusline,
d3534 14
d3549 1
a3549 1
      "number_links",	SET_ARG,		&number_links,
d3554 1
a3554 1
      "partial",	TOGGLE_ARG,		&display_partial_flag,
d3558 1
a3558 1
      "partial_thres",  NEED_INT_ARG,          &partial_threshold,
d3564 1
a3564 1
      "pauth",		NEED_FUNCTION_ARG,	pauth_fun,
d3568 1
a3568 1
      "popup",		UNSET_ARG,		&LYUseDefSelPop,
d3572 1
a3572 1
      "post_data",	FUNCTION_ARG,		post_data_fun,
d3576 1
a3576 1
      "preparsed",	SET_ARG,		&LYPreparsedSource,
d3580 1
a3580 1
#ifdef USE_PSRC
d3582 2
a3583 2
      "prettysrc",	SET_ARG,		&LYpsrc,
      "do syntax highlighting and hyperlink handling in source view"
d3587 2
a3588 2
      "print",		UNSET_ARG,		&no_print,
      "enable print functions (DEFAULT)"
d3591 1
a3591 1
      "pseudo_inlines", TOGGLE_ARG,		&pseudo_inline_alts,
d3595 3
a3597 2
      "raw",		UNSET_ARG,		&LYUseDefaultRawMode,
      "toggles default setting of 8-bit character translations\nor CJK mode for the startup character set"
d3600 1
a3600 1
      "realm",		SET_ARG,		&check_realm,
d3604 1
a3604 1
      "reload",		SET_ARG,		&reloading,
d3608 1
a3608 1
      "restrictions",	FUNCTION_ARG,		restrictions_fun,
d3612 1
a3612 1
      "resubmit_posts", TOGGLE_ARG,		&LYresubmit_posts,
d3618 1
a3618 1
      "rlogin",		UNSET_ARG,		&rlogin_ok,
d3621 10
d3632 1
a3632 1
      "selective",	FUNCTION_ARG,		selective_fun,
d3636 11
a3646 1
      "show_cursor",	TOGGLE_ARG,		&LYUseDefShoCur,
d3649 1
d3651 6
a3656 1
      "soft_dquotes",	TOGGLE_ARG,		&soft_dquotes,
d3661 1
a3661 1
      "source",		FUNCTION_ARG,		source_fun,
d3665 1
a3665 1
      "stack_dump",	SET_ARG,		&stack_dump,
d3669 1
a3669 1
      "startfile_ok",	SET_ARG,		&startfile_ok,
d3672 4
d3679 1
a3679 1
      "syslog",		NEED_LYSTRING_ARG,	&syslog_txt,
d3685 1
a3685 1
      "tagsoup",	SET_ARG,		&Old_DTD,
d3689 1
a3689 1
      "telnet",		UNSET_ARG,		&telnet_ok,
d3693 1
a3693 1
      "term",		NEED_STRING_ARG,	&terminal,
d3696 6
d3703 1
a3703 1
      "tlog",		IGNORE_ARG,		0,
d3706 7
d3714 1
a3714 1
      "trace",		IGNORE_ARG,		0,
d3717 5
d3723 1
a3723 1
      "traversal",	FUNCTION_ARG,		traversal_fun,
d3727 5
a3731 1
      "underscore",	TOGGLE_ARG,		&use_underscore,
d3734 1
a3734 1
#if defined(NCURSES_MOUSE_VERSION) || defined(USE_SLANG_MOUSE)
d3736 2
a3737 2
      "use_mouse",	SET_ARG,		&LYUseMouse,
      "turn on xterm mouse support"
d3741 1
a3741 1
      "useragent",	NEED_LYSTRING_ARG,	&LYUserAgent,
d3745 2
a3746 2
      "validate",	IGNORE_ARG,		0,
      "accept only http URLs (for validation)"
d3749 1
a3749 1
      "verbose",	TOGGLE_ARG,		&verbose_img,
d3753 1
a3753 1
      "version",	FUNCTION_ARG,		version_fun,
d3757 1
a3757 1
      "vikeys",		SET_ARG,		&vi_keys,
d3760 6
d3767 1
a3767 1
      "width",		NEED_FUNCTION_ARG,	width_fun,
d3770 7
a3776 1
   {NULL, 0, 0, NULL}
d3779 1
a3779 1
static void print_help_strings ARGS3(
d3782 2
a3783 1
	CONST char *,	value)
d3790 1
a3790 1
    pad = field_width - (4 + (int) strlen (name));
d3792 1
a3792 1
    fprintf (stdout, "   -%s", name);
d3831 1
a3831 1
static void print_help_and_exit ARGS1(int, exit_status)
d3833 1
a3833 1
    Parse_Args_Type *p;
d3841 1
d3844 4
a3847 1
in double-quotes (\"-\") on VMS)", NULL);
d3851 2
a3852 5
#ifdef PARSE_DEBUG
	Parse_Args_Type * q = p;
#else
	ParseUnion *q = (ParseUnion *)(&(p->value));
#endif
d3856 1
a3856 1
		sprintf(temp, "%s", *(q->set_value) ? "on" : "off");
d3859 1
a3859 1
		sprintf(temp, "%s", *(q->set_value) ? "off" : "on");
d3864 3
d3876 1
a3876 1
	print_help_strings(p->name, p->help_string, value);
d3892 1
a3892 1
static int arg_eqs_parse ARGS3(
d3897 2
d3900 1
a3900 1
    while (1) {
d3906 5
d3912 1
d3914 10
a3923 2
		    return 1;
		case '-':	/* FALLTHRU */
d3926 2
a3927 1
		    return 1;
d3929 2
a3930 1
		    return 1;
d3932 2
a3933 1
		    return 0;
d3936 4
a3939 1
		return 0;
d3944 2
a3945 1
     }
d3951 1
a3951 1
PRIVATE void parse_arg ARGS2(
d3953 1
d3956 1
a3956 1
    Parse_Args_Type *p;
d3958 3
d3973 6
d3981 13
a3993 1
	return;
d3998 1
a3998 1
	return;
d4011 1
a4011 1
	return;
d4016 1
d4020 1
a4020 5
#ifdef PARSE_DEBUG
	Parse_Args_Type *q = p;
#else
	ParseUnion *q = (ParseUnion *)(&(p->value));
#endif
d4023 1
d4031 13
a4043 4
	if ((p->type & NEED_NEXT_ARG) && (next_arg == 0)) {
	    next_arg = argv[1];
	    if ((i != 0) && (next_arg != 0))
		(*i)++;
d4054 1
a4054 1
			 *(q->set_value) = !(*(q->set_value));
d4087 1
a4087 1
		 *(q->int_value) = atoi (next_arg);
d4090 9
d4100 1
a4100 1
	     if ((q->str_value != 0) && (next_arg != 0))
d4102 1
a4102 4
	     break;

	case IGNORE_ARG:
	     break;
d4105 2
a4106 1
	return;
d4113 1
d4146 1
a4146 1
	sleep(AlertSecs);
d4171 2
a4172 1
	fprintf(stderr, "\r\n\
d4174 3
a4176 2

	fprintf(stderr, "\r\n\
d4178 14
d4197 1
a4197 1
	    exit(-1);
d4209 1
a4209 1
	exit(0);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a9 1
#include <HTAlert.h>
a14 1
#include <LYOptions.h>
a23 1
#include <HTForms.h>
a29 6
#include <LYShowInfo.h>
#include <LYHistory.h>

#ifdef VMS
#include <HTFTP.h>
#endif /* !DECNET */
a33 3
#include <io.h>
#include <sys/stat.h>
#include <sys/exceptn.h>
d40 6
d47 1
a47 1
#undef gettext			/* Solaris locale.h prototypes gettext() */
a58 1
#define TRACE_FILE "LY-TRACE.LOG"
a60 1
#define TRACE_FILE "Lynx.trace"
d65 1
a65 1
BOOLEAN socks_flag = TRUE;
d69 1
a69 1
BOOLEAN sigint = FALSE;
d73 1
a73 1
static char init_ctrl_break[1];
a75 4
#if USE_VMS_MAILER
char *mail_adrs = NULL;		/* the mask for a VMS mail transport */
#endif

d77 1
d79 1
a79 1
BOOLEAN UseFixedRecords = USE_FIXED_RECORDS;
d83 5
a87 2
static char *lynx_version_putenv_command = NULL;
char *list_format = NULL;	/* LONG_LIST formatting mask */
d90 3
a92 4
#ifdef SYSLOG_REQUESTED_URLS
char *syslog_txt = NULL;	/* syslog arb text for session */
BOOLEAN syslog_requested_urls = TRUE;
#endif
d95 4
a98 7
BOOLEAN lynx_edit_mode = FALSE;
BOOLEAN no_dired_support = FALSE;
HTList *tagged = NULL;
int LYAutoUncacheDirLists = 2;	/* default dired uncaching behavior */
int dir_list_order = ORDER_BY_NAME;
int dir_list_style = MIXED_STYLE;

d100 1
a100 1
BOOLEAN prev_lynx_edit_mode = FALSE;
a101 1

d104 1
a104 2
BOOLEAN no_change_exec_perms = TRUE;

d106 1
a106 1
BOOLEAN no_change_exec_perms = FALSE;
a108 1

d112 1
a112 2
int HTCacheSize = DEFAULT_CACHE_SIZE;

d115 1
a115 1
int HTVirtualMemorySize = DEFAULT_VIRTUAL_MEMORY_SIZE;
d120 1
a120 2
BOOLEAN local_exec = LOCAL_EXECUTION_LINKS_ALWAYS_ON;

d122 1
a122 1
BOOLEAN local_exec = FALSE;
d124 2
a125 2
BOOLEAN local_exec_on_local_files =
LOCAL_EXECUTION_LINKS_ON_BUT_NOT_REMOTE;
d128 2
a129 2
#if defined(LYNXCGI_LINKS) && !defined(VMS)	/* WebSter Mods -jkt */
char *LYCgiDocumentRoot = NULL;	/* DOCUMENT_ROOT in the lynxcgi env */
d133 1
a133 2
BOOLEAN enable_scrollback = TRUE;

d135 1
a135 1
BOOLEAN enable_scrollback = FALSE;
d138 3
a140 6
char empty_string[] =
{'\0'};

int display_lines;		/* number of lines in display */
int www_search_result = -1;

d142 1
a142 2
lynx_list_item_type *printers = NULL;

d144 1
a144 2
lynx_list_item_type *downloaders = NULL;

d147 1
a147 2
lynx_list_item_type *externals = NULL;

d150 5
a154 5

lynx_list_item_type *uploaders = NULL;
int LYShowColor = SHOW_COLOR_UNKNOWN;	/* to show or not */
int LYrcShowColor = SHOW_COLOR_UNKNOWN;		/* ... last used */

d156 1
a156 49
BOOLEAN LYUseFormsOptions = TRUE;	/* use forms-based options menu */
#endif

BOOLEAN LYJumpFileURL = FALSE;	/* always FALSE the first time */
BOOLEAN LYPermitURL = FALSE;
BOOLEAN LYRestricted = FALSE;	/* whether we have -anonymous option */
BOOLEAN LYShowCursor = SHOW_CURSOR;	/* to show or not to show */
BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS;	/* Show the links underlined vs bold */
BOOLEAN LYUseDefShoCur = TRUE;	/* Command line -show_cursor toggle */
BOOLEAN LYUserSpecifiedURL = TRUE;	/* always TRUE  the first time */
BOOLEAN LYValidate = FALSE;
BOOLEAN LYforce_no_cache = FALSE;
BOOLEAN LYinternal_flag = FALSE;	/* override no-cache b/c internal link */
BOOLEAN LYoverride_no_cache = FALSE;	/*override no-cache b/c history etc */
BOOLEAN LYresubmit_posts = ALWAYS_RESUBMIT_POSTS;
BOOLEAN LYtrimInputFields = FALSE;
BOOLEAN bold_H1 = FALSE;
BOOLEAN bold_headers = FALSE;
BOOLEAN bold_name_anchors = FALSE;
BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
BOOLEAN check_mail = CHECKMAIL;
BOOLEAN child_lynx = FALSE;
BOOLEAN dump_links_only = FALSE;
BOOLEAN dump_output_immediately = FALSE;
BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
BOOLEAN ftp_passive = FTP_PASSIVE;	/* TRUE if doing ftp in passive mode */
BOOLEAN ftp_local_passive;
char *ftp_lasthost;
BOOLEAN goto_buffer = GOTOBUFFER;	/* TRUE if offering default goto URL */
BOOLEAN historical_comments = FALSE;
BOOLEAN is_www_index = FALSE;
BOOLEAN jump_buffer = JUMPBUFFER;	/* TRUE if offering default shortcut */
BOOLEAN lynx_mode = NORMAL_LYNX_MODE;
BOOLEAN minimal_comments = FALSE;
BOOLEAN number_fields_on_left = TRUE;
BOOLEAN number_links_on_left = TRUE;
BOOLEAN recent_sizechange = FALSE;	/* the window size changed recently? */
BOOLEAN soft_dquotes = FALSE;
BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
BOOLEAN verbose_img = VERBOSE_IMAGES;	/* show filenames or not */
BOOLEAN vi_keys = VI_KEYS_ALWAYS_ON;
int keypad_mode = DEFAULT_KEYPAD_MODE;
int user_mode = NOVICE_MODE;

BOOLEAN telnet_ok = TRUE;

#ifndef DISABLE_NEWS
BOOLEAN news_ok = TRUE;
d158 39
a196 53
BOOLEAN rlogin_ok = TRUE;
BOOLEAN long_url_ok = FALSE;
BOOLEAN ftp_ok = TRUE;
BOOLEAN system_editor = FALSE;

BOOLEAN had_restrictions_default = FALSE;
BOOLEAN had_restrictions_all = FALSE;

BOOLEAN exec_frozen = FALSE;
BOOLEAN no_bookmark = FALSE;
BOOLEAN no_bookmark_exec = FALSE;
BOOLEAN no_chdir = FALSE;
BOOLEAN no_disk_save = FALSE;
BOOLEAN no_dotfiles = NO_DOT_FILES;
BOOLEAN no_download = FALSE;
BOOLEAN no_editor = FALSE;
BOOLEAN no_exec = FALSE;
BOOLEAN no_file_url = FALSE;
BOOLEAN no_goto = FALSE;
BOOLEAN no_goto_configinfo = FALSE;
BOOLEAN no_goto_cso = FALSE;
BOOLEAN no_goto_file = FALSE;
BOOLEAN no_goto_finger = FALSE;
BOOLEAN no_goto_ftp = FALSE;
BOOLEAN no_goto_gopher = FALSE;
BOOLEAN no_goto_http = FALSE;
BOOLEAN no_goto_https = FALSE;
BOOLEAN no_goto_lynxcgi = FALSE;
BOOLEAN no_goto_lynxexec = FALSE;
BOOLEAN no_goto_lynxprog = FALSE;
BOOLEAN no_goto_mailto = FALSE;
BOOLEAN no_goto_rlogin = FALSE;
BOOLEAN no_goto_telnet = FALSE;
BOOLEAN no_goto_tn3270 = FALSE;
BOOLEAN no_goto_wais = FALSE;
BOOLEAN no_inside_ftp = FALSE;
BOOLEAN no_inside_rlogin = FALSE;
BOOLEAN no_inside_telnet = FALSE;
BOOLEAN no_jump = FALSE;
BOOLEAN no_lynxcfg_info = FALSE;
BOOLEAN no_lynxcgi = FALSE;
BOOLEAN no_mail = FALSE;
BOOLEAN no_multibook = FALSE;
BOOLEAN no_option_save = FALSE;
BOOLEAN no_outside_ftp = FALSE;
BOOLEAN no_outside_rlogin = FALSE;
BOOLEAN no_outside_telnet = FALSE;
BOOLEAN no_print = FALSE;
BOOLEAN no_shell = FALSE;
BOOLEAN no_suspend = FALSE;
BOOLEAN no_telnet_port = FALSE;
BOOLEAN no_useragent = FALSE;

d198 1
a198 6
BOOLEAN no_goto_news = FALSE;
BOOLEAN no_goto_nntp = FALSE;
BOOLEAN no_goto_snews = FALSE;
BOOLEAN no_inside_news = FALSE;
BOOLEAN no_newspost = FALSE;
BOOLEAN no_outside_news = FALSE;
d200 3
a202 1

d204 1
a204 1
BOOLEAN no_externals = FALSE;
d206 6
a211 6

#ifndef NO_CONFIG_INFO
BOOLEAN no_lynxcfg_xinfo = FALSE;

#ifdef HAVE_CONFIG_H
BOOLEAN no_compileopts_info = FALSE;
d213 32
d246 3
a248 18

BOOLEAN no_statusline = FALSE;
BOOLEAN no_filereferer = TRUE;
char LYRefererWithQuery = 'D';	/* 'D' for drop */
BOOLEAN local_host_only = FALSE;
BOOLEAN override_no_download = FALSE;
BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
BOOLEAN LYforce_HTML_mode = FALSE;
BOOLEAN LYfind_leaks = TRUE;

#ifdef __DJGPP__
BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
BOOLEAN dj_is_bash = FALSE;	/* Check for bash shell under DJGPP */
#endif /* __DJGPP__ */

#ifdef WIN_EX
BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
d250 7
a256 241

#ifdef _WINDOWS
#define	TIMEOUT	180		/* 1998/03/30 (Mon) 14:50:44 */
int lynx_timeout = TIMEOUT;
CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
#endif /* _WINDOWS */

#if defined(WIN_EX)
BOOLEAN system_is_NT = FALSE;
#endif

#ifdef SH_EX
BOOLEAN show_cfg = FALSE;
#endif

BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */

#if USE_BLAT_MAILER
BOOLEAN mail_is_blat = TRUE;
#endif

#ifdef USE_BLINK
#  ifdef __EMX__
BOOLEAN term_blink_is_boldbg = TRUE;

#  else
BOOLEAN term_blink_is_boldbg = FALSE;

#  endif
#endif

BOOLEAN HEAD_request = FALSE;
BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES;	/* take all cookies? */
BOOLEAN LYCancelledFetch = FALSE;	/* TRUE if cancelled binary fetch */
BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;	/* Collapse serial BRs? */
BOOLEAN LYDefaultRawMode;
BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
BOOLEAN LYNewsPosting = NEWS_POSTING;	/* News posting supported? */
BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?         */
BOOLEAN LYNoRefererForThis = FALSE;	/* No Referer header for this URL? */
BOOLEAN LYNoRefererHeader = FALSE;	/* Never send Referer header?     */
BOOLEAN LYRawMode;
BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
BOOLEAN LYSetCookies = SET_COOKIES;	/* Process Set-Cookie headers? */
BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
BOOLEAN LYUseDefaultRawMode = TRUE;
BOOLEAN LYUseMouse = FALSE;
BOOLEAN LYisConfiguredForX = FALSE;
BOOLEAN UCForce8bitTOUPPER = FALSE;	/* override locale for case-conversion? */
BOOLEAN UCSaveBookmarksInUnicode = FALSE;
BOOLEAN bookmark_start = FALSE;
BOOLEAN check_realm = FALSE;	/* Restrict to the starting realm? */
BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
BOOLEAN crawl = FALSE;		/* Do crawl? */
BOOLEAN keep_mime_headers = FALSE;	/* Include mime headers with source dump */
BOOLEAN more = FALSE;		/* is there more text to display? */
BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
BOOLEAN no_list = FALSE;
BOOLEAN no_url_redirection = FALSE;	/* Don't follow URL redirections */
BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
BOOLEAN scan_for_buried_news_references = TRUE;
BOOLEAN startfile_ok = FALSE;
static BOOLEAN startfile_stdin = FALSE;
BOOLEAN traversal = FALSE;	/* Do traversals? */

char *BookmarkPage = NULL;	/* the name of the current bookmark page */
char *LYCookieAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieLooseCheckDomains = NULL;		/* check loosely   */
char *LYCookieQueryCheckDomains = NULL;		/* check w/a query */
char *LYCookieRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieSLooseCheckDomains = NULL;	/* check loosely   */
char *LYCookieSQueryCheckDomains = NULL;	/* check w/a query */
char *LYCookieSRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSStrictCheckDomains = NULL;	/* check strictly  */
char *LYCookieStrictCheckDomains = NULL;	/* check strictly  */
char *LYHostName = NULL;	/* treat as a local host name */
char *LYLocalDomain = NULL;	/* treat as a local domain tail */
char *LYUserAgent = NULL;	/* Lynx User-Agent header          */
char *LYUserAgentDefault = NULL;	/* Lynx default User-Agent header  */
char *LynxHome = NULL;		/* the default Home HREF. */
char *LynxSigFile = NULL;	/* Signature file, in or off home */
char *UCAssume_MIMEcharset = NULL;
char *URLDomainPrefixes = NULL;
char *URLDomainSuffixes = NULL;
char *anonftp_password = NULL;	/* anonymous ftp password (default: email) */
char *authentication_info[2] =
{NULL, NULL};			/* Id:Password for protected documents */
char *bookmark_page = NULL;	/* the name of the default bookmark page */
char *editor = NULL;		/* the name of the current editor */
char *form_get_data = NULL;	/* User data for get form */
char *form_post_data = NULL;	/* User data for post form */
char *global_extension_map = NULL;	/* global mime.types */
char *global_type_map = NULL;	/* global mailcap */
char *helpfile = NULL;		/* the main help file */
char *helpfilepath = NULL;	/* the path to the help file set */
char *homepage = NULL;		/* home page or main screen */
char *http_error_file = NULL;	/* Place HTTP status code in this file */
char *indexfile = NULL;		/* an index file if there is one */
char *jumpfile = NULL;		/* the name of the default jumps file */
char *jumpprompt = NULL;	/* the default jumps prompt */
char *language = NULL;		/* preferred language */
char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
char *lynx_cmd_script;		/* file to read keystroke commands, if any */
char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
char *lynxjumpfile = NULL;	/* the current jump file URL */
char *lynxlinksfile = NULL;	/* the current visited links file URL */
char *lynxlistfile = NULL;	/* the current list file URL */
char *original_dir = NULL;	/* the original directory */
char *personal_extension_map = NULL;	/* .mime.types */
char *personal_mail_address = NULL;	/* the users mail address */
char *personal_type_map = NULL;	/* .mailcap */
char *pref_charset = NULL;	/* preferred character set */
char *proxyauth_info[2] =
{NULL, NULL};			/* Id:Password for protected proxy servers */
char *startfile = NULL;		/* the first file */
char *startrealm = NULL;	/* the startfile realm */
char *system_mail = NULL;	/* The path for sending mail */
char *system_mail_flags = NULL;	/* Flags for sending mail */
char *x_display = NULL;		/* display environment variable */

HistInfo *history;
int nhist = 0;			/* number of used history entries */
int size_history;		/* number of allocated history entries */

LinkInfo links[MAXLINKS];

int AlertSecs;			/* time-delay for HTAlert() messages   */
int DebugSecs;			/* time-delay for HTProgress messages */
int InfoSecs;			/* time-delay for Information messages */
int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
int LYStatusLine = -1;		/* Line for statusline() if > -1 */
int LYcols = DFT_COLS;
int LYlines = DFT_ROWS;
int MessageSecs;		/* time-delay for important Messages   */
int ReplaySecs;			/* time-delay for command-scripts */
int crawl_count = 0;		/* Starting number for lnk#.dat files in crawls */
int dump_output_width = 0;
int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
int max_cookies_domain = 50;
int max_cookies_global = 500;
int max_cookies_buffer = 4096;
int nlinks = 0;			/* number of links in memory */
int outgoing_mail_charset = -1;	/* translate mail to this charset */

#ifndef DISABLE_BIBP
BOOLEAN BibP_bibhost_available = FALSE;		/* until check succeeds  */
BOOLEAN BibP_bibhost_checked = FALSE;	/*  until LYCheckBibHost   */
BOOLEAN no_goto_bibp = FALSE;
char *BibP_bibhost = NULL;	/* local server for bibp: links  */
char *BibP_globalserver = NULL;	/* global server for bibp: links */
#endif

#ifdef USE_PERSISTENT_COOKIES
BOOLEAN persistent_cookies = FALSE;	/* disabled by default! */
char *LYCookieFile = NULL;	/* cookie read file */
char *LYCookieSaveFile = NULL;	/* cookie save file */
#endif /* USE_PERSISTENT_COOKIES */

#ifdef EXP_NESTED_TABLES
BOOLEAN nested_tables =
#if defined(USE_COLOR_STYLE)
TRUE
#else
FALSE				/* see 2001-08-15  */
#endif
 ;
#endif

BOOLEAN LYShowTransferRate = TRUE;
int LYTransferRate = rateKB;
int LYAcceptEncoding = encodingALL;
int LYAcceptMedia = mediaOpt1;
char *LYTransferName = NULL;

char *XLoadImageCommand = NULL;	/* Default image viewer for X */
BOOLEAN LYNoISMAPifUSEMAP = FALSE;	/* Omit ISMAP link if MAP present? */
int LYHiddenLinks = HIDDENLINKS_SEPARATE;	/* Show hidden links? */

int Old_DTD = NO;
static BOOL DTD_recovery = NO;

#ifndef NO_LYNX_TRACE
FILE *LYTraceLogFP = NULL;	/* Pointer for TRACE log  */
#endif
char *LYTraceLogPath = NULL;	/* Path for TRACE log      */
BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?        */

BOOLEAN LYSeekFragMAPinCur = TRUE;
BOOLEAN LYSeekFragAREAinCur = TRUE;
BOOLEAN LYStripDotDotURLs = TRUE;	/* Try to fix ../ in some URLs? */
BOOLEAN LYForceSSLCookiesSecure = FALSE;
BOOLEAN LYNoCc = FALSE;
BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
BOOLEAN LYPrependBaseToSource = TRUE;
BOOLEAN LYPrependCharsetToSource = TRUE;
BOOLEAN LYQuitDefaultYes = QUIT_DEFAULT_YES;
BOOLEAN dont_wrap_pre = FALSE;

int cookie_noprompt;

#ifdef USE_SSL
int ssl_noprompt = FORCE_PROMPT_DFT;
#endif

int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/

#ifdef EXP_JUSTIFY_ELTS
BOOL ok_justify = TRUE;
int justify_max_void_percent = 35;
#endif

#ifdef EXP_LOCALE_CHARSET
BOOLEAN LYLocaleCharset = FALSE;
#endif

#ifndef NO_DUMP_WITH_BACKSPACES
BOOLEAN with_backspaces = FALSE;
#endif

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
int scrsize_x = 0;
int scrsize_y = 0;
#endif

BOOL force_empty_hrefless_a = FALSE;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
BOOL textfields_need_activation = FALSE;
BOOL textfields_activation_option = FALSE;
#endif

BOOLEAN textfield_prompt_at_left_edge = FALSE;

#ifdef MARK_HIDDEN_LINKS
char *hidden_link_marker = NULL;
d258 135
d395 3
a397 3
BOOLEAN display_partial_flag = TRUE;	/* Display document during download */
BOOLEAN debug_display_partial = FALSE;	/* Show with MessageSecs delay */
int partial_threshold = -1;	/* # of lines to be d/l'ed until we repaint */
d400 5
a404 7
BOOLEAN LYNonRestartingSIGWINCH = FALSE;
BOOLEAN LYReuseTempfiles = FALSE;
BOOLEAN LYUseBuiltinSuffixes = TRUE;

#ifdef MISC_EXP
int LYNoZapKey = 0;		/* 0: off (do z checking), 1: full, 2: initially */
#endif
d407 2
a408 1
#include <HTNews.h>
d411 6
a416 10
BOOLEAN FileInitAlreadyDone = FALSE;

static BOOLEAN stack_dump = FALSE;
static char *terminal = NULL;
static const char *pgm;
static BOOLEAN no_numbers = FALSE;
static BOOLEAN number_links = FALSE;
static BOOLEAN number_fields = FALSE;
static BOOLEAN LYPrependBase = FALSE;
static HTList *LYStdinArgs = NULL;
d423 2
a424 8
#ifndef EXTENDED_STARTFILE_RECALL
/* if set then additional non-option args (before the last one) will be
   made available for 'g'oto recall - kw */
#define EXTENDED_STARTFILE_RECALL 1
#endif

#if EXTENDED_STARTFILE_RECALL
static char *nonoption = 0;
a426 5
#ifndef OPTNAME_ALLOW_DASHES
/* if set, then will allow dashes and underscores to be used interchangeable
   in commandline option's names - VH */
#define OPTNAME_ALLOW_DASHES 1
#endif
d428 2
a429 6
static BOOL parse_arg(char **arg, unsigned mask, int *countp);
static void print_help_and_exit(int exit_status) GCC_NORETURN;
static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       BOOLEAN option);
d432 2
a433 3
BOOLEAN LYNoCore = NO_FORCED_CORE_DUMP;
BOOLEAN restore_sigpipe_for_children = FALSE;
static void FatalProblem(int sig);
d436 2
a437 2
#if defined(USE_COLOR_STYLE)
char *lynx_lss_file = NULL;
d441 1
a441 1
static void LY_set_ctrl_break(int setting)
d443 1
a443 1
    (void) signal(SIGINT, (setting ? SIG_DFL : SIG_IGN));
d447 1
a447 1
static int LY_get_ctrl_break(void)
a449 1

d452 1
a452 1
    __dpmi_int(0x21, &regs);
d456 1
a456 1
static void reset_break(void)
a461 13
#if defined(WIN_EX)
static int is_windows_nt(void)
{
    DWORD version;

    version = GetVersion();
    if ((version & 0x80000000) == 0)
	return 1;
    else
	return 0;
}
#endif

d463 1
a463 1
static void free_lynx_globals(void)
d469 4
a472 1
#ifdef LYNXCGI_LINKS		/* WebSter Mods -jkt */
a477 4
#ifdef SYSLOG_REQUESTED_URLS
    FREE(syslog_txt);
#endif

d480 2
a482 7
#ifndef VMS
    FREE(lynx_version_putenv_command);
#endif

#if USE_VMS_MAILER
    FREE(mail_adrs);
#endif
a484 1
    FREE(history);
d505 1
a505 5
#ifndef DISABLE_BIBP
    FREE(BibP_bibhost);
    FREE(BibP_globalserver);
#endif
#ifdef USE_PERSISTENT_COOKIES
a506 1
    FREE(LYCookieSaveFile);
a529 1
    FREE(ftp_lasthost);
a531 1
    FREE(anonftp_password);
d535 3
a538 1
    FREE(LYTransferName);
d541 1
a541 1
#if defined(USE_COLOR_STYLE)
d545 10
a554 2
    LYUIPages_free();
    LYFreeHilites(0, nlinks);
a555 5
    LYFreeStringList(LYcommandList());
    HTInitProgramPaths();
#if EXTENDED_STARTFILE_RECALL
    FREE(nonoption);
#endif
d562 1
a562 1
 * This function frees the LYStdinArgs list.  - FM
d564 1
a564 1
static void LYStdinArgs_free(void)
d566 10
a575 1
    LYFreeStringList(LYStdinArgs);
d577 1
d580 2
a581 1
void reset_signals(void)
a593 8
}

void exit_immediately(int code)
{
    reset_signals();
#ifdef NCURSES_NO_LEAKS
    _nc_freeall();
#endif
a597 1
/* *INDENT-OFF* */
a617 1
/* *INDENT-ON* */
d622 2
a623 1
    int work1[256], work2[256];
d627 2
a628 2
	work1[c] = keymap[c + 1];
	work2[c] = key_override[c + 1];
d631 2
a632 2
	keymap[IBM1047[c] + 1] = work1[c];
	key_override[IBM1047[c] + 1] = work2[c];
d637 4
a640 2
static void tildeExpand(char **pathname,
			BOOLEAN embedded)
d642 2
a643 26
    char *temp = *pathname;

    if (embedded) {
	if (temp != NULL) {
	    temp = strstr(*pathname, "/~");
	    if (temp != 0)
		temp++;
	    else
		temp = *pathname;
	}
    }

    if (temp != NULL
	&& temp[0] == '~') {
	if (temp[1] == '/'
	    && temp[2] != '\0') {
	    temp = NULL;
	    StrAllocCopy(temp, *pathname + 2);
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	    LYAddPathSep(pathname);
	    StrAllocCat(*pathname, temp);
	    FREE(temp);
	} else if (temp[1] == '\0') {
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	}
    }
d646 3
a648 32
static BOOL GetStdin(char **buf,
		     BOOL marker)
{
    if (LYSafeGets(buf, stdin) != 0
	&& (!marker || strncmp(*buf, "---", 3) != 0)) {
	LYTrimTrailing(*buf);
	CTRACE((tfp, "...data: %s\n", *buf));
	return TRUE;
    }
    CTRACE((tfp, "...mark: %s\n", *buf ? *buf : ""));
    return FALSE;
}

#ifdef WIN32
static BOOL cleanup_win32(DWORD fdwCtrlType)
{
    switch (fdwCtrlType) {
    case CTRL_CLOSE_EVENT:
	cleanup_sig(-1);
	return TRUE;
    default:
	return FALSE;
    }
}
#endif

/*
 * Append the SSL version to lynx version or user-agent string.
 */
#ifdef USE_SSL
static void append_ssl_version(char **target,
			       const char *separator)
d650 2
a651 32
    char SSLLibraryVersion[256];
    char *SSLcp;

    HTSprintf(target, " SSL-MM%s1.4.1", separator);

#undef LYNX_SSL_VERSION

#if defined(SSLEAY_VERSION)
#define LYNX_SSL_VERSION SSLeay_version(SSLEAY_VERSION)
#else
#if defined(OPENSSL_VERSION_TEXT)
#define LYNX_SSL_VERSION OPENSSL_VERSION_TEXT
#else
#if defined(GNUTLS_VERSION)
#define LYNX_SSL_VERSION GNUTLS_VERSION
#endif /* GNUTLS_VERSION */
#endif /* OPENSSL_VERSION_TEXT */
#endif

#ifdef LYNX_SSL_VERSION
    if (*separator == ' ')
	StrAllocCat(*target, ",");
    LYstrncpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion) - 1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = *separator;
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    StrAllocCat(*target, " ");
	    StrAllocCat(*target, SSLLibraryVersion);
	}
    }
#endif /* LYNX_SSL_VERSION */
a652 1
#endif /* USE_SSL */
d657 3
a659 2
int main(int argc,
	 char **argv)
d661 2
a662 2
    int i;			/* indexing variable */
    int status = 0;		/* exit status */
a665 1
    struct stat dir_info;
d669 5
a673 11
#ifdef _WINDOWS
    WSADATA WSAData;
#endif /* _WINDOWS */

    /*
     * Just in case someone has the idea to install lynx set-uid, let's try
     * to discourage it.
     */
#if defined(GETUID) && defined(SETUID)
    setuid(getuid());
#endif
a678 9
#ifndef DISABLE_FTP
    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
    ftp_lasthost = typecalloc(char);
#endif

#ifdef EXP_CHARSET_CHOICE
    memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
#endif

d680 1
d685 1
a685 1
	wVerReq = MAKEWORD(1, 1);
d688 3
a690 2
	if (err != 0) {
	    puts(gettext("No Winsock found, sorry."));
d692 1
a692 1
	    return 1;
a694 5

    /* 1998/09/03 (Thu) 22:02:32 */
    InitializeCriticalSection(&critSec_DNS);
    InitializeCriticalSection(&critSec_READ);

a696 18
#if 0				/* defined(__CYGWIN__) - does not work with screen */
    if (strcmp(ttyname(fileno(stdout)), "/dev/conout") != 0) {
	printf("please \"$CYGWIN=notty\"\n");
	exit_immediately(EXIT_SUCCESS);
    }
#endif

#if defined(WIN_EX)
    /* 1997/10/19 (Sun) 21:40:54 */
    system_is_NT = (BOOL) is_windows_nt();

    /* 1998/01/13 (Tue) 21:13:47 */
    GetWindowsDirectory(filename, sizeof filename);
    windows_drive[0] = filename[0];
    windows_drive[1] = filename[1];
    windows_drive[2] = '\0';
#endif

a703 2
    __djgpp_set_sigquit_key(0x082D);	/* Bind ALT-X to SIGQUIT */
    signal(SIGQUIT, cleanup_sig);
d705 3
a707 5

    if (((cp = LYGetEnv("SHELL")) != NULL)
	&& (strstr(LYPathLeaf(cp), "sh") != NULL))
	dj_is_bash = TRUE;
#endif /* __DJGPP__ */
d719 1
a719 2
    if (LYGetEnv("TERM") == NULL)
	putenv("TERM=vt100");
d724 1
a724 1
     * Set up the argument list.
d727 1
a727 2
    cp = NULL;
    if ((cp = LYLastPathSep(pgm)) != NULL) {
d732 1
a732 1
     * Act on -help NOW, so we only output the help and exit.  - FM
d735 3
a737 1
	parse_arg(&argv[i], 1, &i);
d742 2
a743 2
     * Register the final function to be executed when being exited.  Will
     * display memory leaks if LY_FIND_LEAKS is defined.
d747 1
a747 1
     * Register the function which will free our allocated globals.
d752 1
d755 1
a755 1
     * LOCALE support for international characters.
d760 1
a760 1
#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
d762 1
a762 3
    if ((cp = LYGetEnv("LYNX_LOCALEDIR")) == 0)
	cp = LOCALEDIR;
    bindtextdomain("lynx", cp);
d764 1
a764 1
    textdomain("lynx");
d768 1
a768 1
     * Initialize our startup and global variables.
d772 1
a772 1
     * Need this for Ultrix.
d774 1
a774 1
    terminal = LYGetEnv("TERM");
d779 1
a779 1
     * Zero the links and history struct arrays.
d781 2
a782 2
    memset((void *) links, 0, sizeof(LinkInfo) * MAXLINKS);
    LYAllocHistory(8);
d784 1
a784 1
     * Zero the MultiBookmark arrays.
d786 2
a787 3
    memset((void *) MBM_A_subbookmark, 0, sizeof(char) * (MBM_V_MAXFILES + 1));
    memset((void *) MBM_A_subdescript, 0, sizeof(char) * (MBM_V_MAXFILES + 1));

d789 3
d794 3
a796 8

    AlertSecs = SECS2Secs(ALERTSECS);
    DebugSecs = SECS2Secs(DEBUGSECS);
    InfoSecs = SECS2Secs(INFOSECS);
    MessageSecs = SECS2Secs(MESSAGESECS);
    ReplaySecs = SECS2Secs(REPLAYSECS);

    StrAllocCopy(LYTransferName, "KiB");
d799 1
a799 1
    LYEscapeStartfile(&startfile);
a807 1
#ifdef SYSTEM_MAIL_FLAGS
a808 4
#else
    StrAllocCopy(system_mail_flags, "");
#endif

a815 3
#ifdef USE_SSL
    append_ssl_version(&LYUserAgent, "/");
#endif /* USE_SSL */
a816 1

d828 1
a828 1
    if ((cp = LYGetEnv("LYNX_TEMP_SPACE")) != NULL)
d830 2
a831 2
#if defined (UNIX) || defined (__DJGPP__)
    else if ((cp = LYGetEnv("TMPDIR")) != NULL)
d835 4
a838 4
    else if ((cp = LYGetEnv("TEMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
    else if ((cp = LYGetEnv("TMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
d845 2
a846 2
	puts(gettext("You MUST define a valid TMP or TEMP area!"));
	exit_immediately(EXIT_FAILURE);
d850 9
a858 5
#ifdef WIN_EX			/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
    if (access(lynx_temp_space, 0) != 0)
#endif
	tildeExpand(&lynx_temp_space, TRUE);

d862 1
a862 1
	if ((cp1 = LYGetEnv("USER")) != NULL) {
d873 2
a892 1
    StrAllocCopy(lynx_temp_space, HTSYS_name(lynx_temp_space));
d894 1
a894 16

    if ((HTStat(lynx_temp_space, &dir_info) < 0
#if defined(MULTI_USER_UNIX)
	 && mkdir(lynx_temp_space, 0700) < 0
#endif
	)
	|| !S_ISDIR(dir_info.st_mode)) {
	fprintf(stderr, "%s: %s\n",
		lynx_temp_space,
		gettext("No such directory"));
	exit_immediately(EXIT_FAILURE);
    }
#if USE_VMS_MAILER
#ifndef MAIL_ADRS
#define MAIL_ADRS "\"IN%%\"\"%s\"\"\""
#endif
d896 4
a899 2
#endif

a904 1

a909 5
#ifndef DISABLE_BIBP
    StrAllocCopy(BibP_globalserver, BIBP_GLOBAL_SERVER);
    StrAllocCopy(BibP_bibhost, "http://bibhost/");	/* protocol specified. */
#endif

d911 4
a914 3
     * Disable news posting if the compilation-based LYNewsPosting value is
     * FALSE.  This may be changed further down via lynx.cfg or the
     * -restriction command line switch.  - FM
d917 1
a917 1
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
d921 5
a925 4
     * Set up trace, the anonymous account defaults, validate restrictions,
     * and/or the nosocks flag, if requested, and an alternate configuration
     * file, if specified, NOW.  Also, if we only want the help menu, output
     * that and exit.  - FM
d927 40
a966 4
#ifndef NO_LYNX_TRACE
    if (LYGetEnv("LYNX_TRACE") != 0) {
	WWW_TraceFlag = TRUE;
    }
d968 1
a968 2
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 2, &i);
d972 13
a984 11
     * If we have a lone "-" switch for getting arguments from stdin, get them
     * NOW, and act on the relevant ones, saving the others into an HTList for
     * handling after the other initializations.  The primary purpose of this
     * feature is to allow for the potentially very long command line that can
     * be associated with post or get data.  The original implementation
     * required that the lone "-" be the only command line argument, but that
     * precluded its use when the lynx command is aliased with other arguments. 
     * When interactive, the stdin input is terminated by by Control-D on Unix
     * or Control-Z on VMS, and each argument is terminated by a RETURN.  When
     * the argument is -get_data or -post_data, the data are terminated by a
     * "---" string, alone on the line (also terminated by RETURN).  - FM
a988 1
	    break;
d994 7
a1000 7
	CTRACE((tfp, "processing stdin arguments\n"));
	while (GetStdin(&buf, TRUE)) {
	    char *noargv[2];

	    noargv[0] = buf;
	    noargv[1] = NULL;
	    LYTrimTrailing(buf);
d1002 121
a1122 2
	    if (parse_arg(&noargv[0], 2, (int *) 0) == FALSE
		&& buf[0] != '\0') {
a1132 3
		CTRACE((tfp, "...StdinArg:%s\n", argument));
	    } else {
		CTRACE((tfp, "...complete:%s\n", buf));
a1134 1
	CTRACE((tfp, "...done with stdin arguments\n"));
d1137 1
d1144 2
a1145 2
     * If we had -validate set all of the restrictions and disallow a TRACE log
     * NOW.  - FM
d1153 4
a1156 3
     * If we didn't get and act on a -validate or -anonymous switch, but can
     * verify that this is the anonymous account, set the default restrictions
     * for that account and disallow a TRACE log NOW.  - FM
d1159 1
a1159 1
	strlen(ANONYMOUS_USER) > 0 &&
d1161 2
a1162 2
	!strcasecomp((LYGetEnv("USER") == NULL ? " " : LYGetEnv("USER")),
		     ANONYMOUS_USER)
d1164 2
a1165 2
#ifdef HAVE_CUSERID
	STREQ((char *) cuserid((char *) NULL), ANONYMOUS_USER)
d1167 1
a1167 1
	STREQ(((char *) getlogin() == NULL ? " " : getlogin()), ANONYMOUS_USER)
d1170 1
a1170 1
	) {
d1177 1
a1177 1
     * Set up the TRACE log path, and logging if appropriate.  - FM
d1179 1
a1179 6
    if ((cp = LYGetEnv("LYNX_TRACE_FILE")) == 0)
	cp = TRACE_FILE;
    LYTraceLogPath = typeMallocn(char, LY_MAXPATH);

    LYAddPathToHome(LYTraceLogPath, LY_MAXPATH, cp);

a1181 1
#ifdef EXP_CMD_LOGGING
d1183 1
a1183 17
     * Open command-script, if specified
     */
    if (lynx_cmd_script != 0) {
	tildeExpand(&lynx_cmd_script, TRUE);
	LYOpenCmdScript();
    }
    /*
     * Open command-logging, if specified
     */
    if (lynx_cmd_logfile != 0) {
	tildeExpand(&lynx_cmd_logfile, TRUE);
	LYOpenCmdLogfile(argc, argv);
    }
#endif

    /*
     * Set up the default jump file stuff.  - FM
d1189 9
a1197 4
	temp = NULL;
	HTSprintf0(&temp, "JUMPFILE:%s", jumpfile);
	if (!LYJumpInit(temp)) {
	    CTRACE((tfp, "Failed to register %s\n", temp));
a1198 1
	FREE(temp);
d1203 2
a1204 2
     * If no alternate configuration file was specified on the command line,
     * see if it's in the environment.
d1207 2
a1208 2
	if (((cp = LYGetEnv("LYNX_CFG")) != NULL) ||
	    (cp = LYGetEnv("lynx_cfg")) != NULL)
d1213 2
a1214 2
     * If we still don't have a configuration file, use the userdefs.h
     * definition.
d1219 16
a1234 2
#ifndef _WINDOWS		/* avoid the whole ~ thing for now */
    tildeExpand(&lynx_cfg_file, FALSE);
d1238 2
a1239 1
     * If the configuration file is not available, inform the user and exit.
d1241 4
a1244 5
    if (!LYCanReadFile(lynx_cfg_file)) {
	fprintf(stderr,
		gettext("\nConfiguration file %s is not available.\n\n"),
		lynx_cfg_file);
	exit_immediately(EXIT_FAILURE);
d1246 6
d1254 2
a1255 2
     * Make sure we have the character sets declared.  This will initialize the
     * CHARTRANS handling.  - KW
d1259 1
a1259 1
	exit_immediately(EXIT_FAILURE);
d1262 4
a1265 4
     * (**) in Lynx, UCLYhndl_HTFile_for_unspec and UCLYhndl_for_unrec may be
     * valid or not, but current_char_set and UCLYhndl_for_unspec SHOULD ALWAYS
     * be a valid charset.  Initialized here and may be changed later from
     * lynx.cfg/command_line/options_menu.  - LP (**)
d1268 1
a1268 1
     * Set up the compilation default character set.  - FM
d1270 1
a1270 6
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (auto_display_charset >= 0)
	current_char_set = auto_display_charset;
    else
#endif
	current_char_set = safeUCGetLYhndl_byMIME(CHARACTER_SET);
d1272 1
a1272 1
     * Set up HTTP default for unlabeled charset (iso-8859-1).
d1276 1
a1276 1
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d1279 1
a1279 1
     * Make sure we have the edit map declared.  - FM
d1283 1
a1283 1
	exit_immediately(EXIT_FAILURE);
d1285 2
a1286 1
#if defined(USE_COLOR_STYLE)
d1288 2
a1289 2
     * If no alternate lynx-style file was specified on the command line, see
     * if it's in the environment.
d1292 2
a1293 2
	if (((cp = LYGetEnv("LYNX_LSS")) != NULL) ||
	    (cp = LYGetEnv("lynx_lss")) != NULL)
d1298 2
a1299 1
     * If we still don't have a lynx-style file, use the userdefs.h definition.
a1303 2
    tildeExpand(&lynx_lss_file, TRUE);

d1305 18
a1322 1
     * If the lynx-style file is not available, inform the user and exit.
d1324 1
a1324 1
    if (!LYCanReadFile(lynx_lss_file)) {
d1326 5
a1330 2
		lynx_lss_file);
    } else {
d1333 1
a1333 1
#endif /* USE_COLOR_STYLE */
d1335 1
a1335 1
#ifdef USE_COLOR_TABLE
d1337 1
a1337 1
     * Set up default foreground and background colors.
d1343 1
a1343 1
     * Set the original directory, used for default download
d1346 1
a1346 1
	if ((cp = LYGetEnv("PWD")) != 0)
d1353 1
a1353 1
     * Set the compilation default signature file.  - FM
d1355 1
a1355 1
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename) - 1);
d1360 1
a1360 1
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
d1362 1
a1362 1
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
d1365 1
a1365 1
#ifdef USE_PRETTYSRC
d1371 1
a1371 1
     * Process the configuration file.
d1373 1
a1373 1
    read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);
d1376 1
a1376 1
     * Process the RC file.
d1378 1
a1378 5
    read_rc(NULL);

#ifdef EXP_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif
d1383 1
a1383 1
    if ((cp = LYGetEnv("WWW_HOME")) != NULL) {
d1394 2
a1395 1
    LYEnsureAbsoluteURL(&LynxHome, "LynxHome", FALSE);
d1398 1
a1398 2
     * Process any command line arguments not already handled.  - FM
     * May set startfile as a side-effect.
d1401 1
a1401 1
	parse_arg(&argv[i], 4, &i);
d1405 2
a1406 2
     * Process any stdin-derived arguments for a lone "-" which we've loaded
     * into LYStdinArgs.  - FM
d1413 2
a1414 2
	while (NULL != (my_args[0] = (char *) HTList_nextObject(cur))) {
	    parse_arg(my_args, 4, (int *) 0);
a1417 4
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    if (current_char_set == auto_display_charset)	/* Better: explicit option */
	switch_display_charsets = 1;
#endif
a1418 1
#if defined (TTY_DEVICE) || defined(HAVE_TTYNAME)
d1420 1
a1420 37
     * If we are told to read the startfile from standard input, do it now,
     * after we have read all of the option data from standard input.
     */
    if (startfile_stdin) {
	char result[LY_MAXPATH];
	char *buf = NULL;
	const char *tty = NULL;

# ifdef HAVE_TTYNAME
	tty = ttyname(fileno(stderr));
# endif
	if (tty == NULL)
	    tty = isatty(fileno(stdin)) ? TTY_DEVICE : NUL_DEVICE;

	CTRACE((tfp, "processing stdin startfile, tty=%s\n", tty));
	if ((fp = LYOpenTemp(result, HTML_SUFFIX, "w")) != 0) {
	    StrAllocCopy(startfile, result);
	    while (GetStdin(&buf, FALSE)) {
		fputs(buf, fp);
		fputc('\n', fp);
	    }
	    FREE(buf);
	    LYCloseTempFP(fp);
	}
	CTRACE((tfp, "...done stdin startfile\n"));
	if ((freopen(tty, "r", stdin)) == 0) {
	    CTRACE((tfp, "cannot open a terminal (%s)\n", tty));
	    if (!dump_output_immediately) {
		fprintf(stderr, "cannot open a terminal (%s)\n", tty);
		exit_immediately(1);
	    }
	}
    }
#endif

    /*
     * Initialize other things based on the configuration read.
d1423 2
a1424 2
#ifdef USE_PRETTYSRC
    if ((!Old_DTD) != TRUE)	/* skip if they are already initialized -HV */
d1426 1
a1426 1
	HTSwitchDTD(!Old_DTD);
d1434 1
a1434 1
#ifdef USE_PERSISTENT_COOKIES
a1437 2
     *
     * And to set LYCookieSaveFile. - BJP
d1440 2
a1441 4
	if (LYCookieFile == NULL) {
	    LYCookieFile = typeMallocn(char, LY_MAXPATH);

	    LYAddPathToHome(LYCookieFile, LY_MAXPATH, COOKIE_FILE);
d1443 9
a1451 1
	    tildeExpand(&LYCookieFile, FALSE);
a1454 18

    /* tilde-expand LYCookieSaveFile */
    if (LYCookieSaveFile != NULL) {
	tildeExpand(&LYCookieSaveFile, FALSE);
    }

    /*
     * In dump_output_immediately mode, LYCookieSaveFile defaults to
     * /dev/null, otherwise it defaults to LYCookieFile.
     */

    if (LYCookieSaveFile == NULL) {
	if (dump_output_immediately) {
	    StrAllocCopy(LYCookieSaveFile, "/dev/null");
	} else {
	    StrAllocCopy(LYCookieSaveFile, LYCookieFile);
	}
    }
d1466 3
a1468 2
     * Check for a save space path in the environment.  If one was set in the
     * configuration file, that one will be overridden.  - FM
d1470 1
a1470 1
    if ((cp = LYGetEnv("LYNX_SAVE_SPACE")) != NULL)
d1474 1
a1474 1
     * We have a save space path, make sure it's valid.  - FM
d1480 9
a1488 1
	tildeExpand(&lynx_save_space, TRUE);
d1511 5
a1515 4
     * Set up the file extension and mime type maps from src/HTInit.c and the
     * global and personal mime.types and mailcap files.  These will override
     * any SUFFIX or VIEWER maps in userdefs.h or the configuration file, if
     * they overlap.
d1518 1
a1518 2
    if (!FileInitAlreadyDone)
	HTFileInit();
d1520 6
a1525 2
    if (!LYCheckUserAgent()) {
	HTAlwaysAlert(gettext("Warning:"), UA_NO_LYNX_WARNING);
d1527 2
a1528 6
#ifdef SH_EX
    if (show_cfg) {
	cleanup();
	exit_immediately(EXIT_SUCCESS);
    }
#endif
d1535 1
a1535 1
	       LYGetEnv("COLORTERM") != NULL) {
d1546 1
d1562 3
a1564 20
    if (no_numbers) {
	number_links = FALSE;
	number_fields = FALSE;
	keypad_mode = NUMBERS_AS_ARROWS;
	set_numbers_as_arrows();
    }

    if (crawl) {
	/* No numbered links by default, as documented
	   in CRAWL.announce. - kw */
	if (!number_links) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	}
    }

    if (!links_are_numbered()) {
	if (number_fields)
	    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
	if (number_links)
	    keypad_mode = LINKS_ARE_NUMBERED;
a1565 1
    }
d1568 1
a1568 1
     * Check the -popup command line toggle.  - FM
d1571 4
a1574 1
	LYSelectPopups = !LYSelectPopups;
d1578 1
a1578 1
     * Check the -show_cursor command line toggle.  - FM
d1581 4
a1584 1
	LYShowCursor = !LYShowCursor;
d1588 1
a1588 1
     * Check the -base command line switch with -source.  - FM
d1595 4
a1598 3
     * Disable multiple bookmark support if not interactive, so it doesn't
     * crash on curses functions, or if the support was blocked via userdefs.h
     * and/or lynx.cfg, or via command line restrictions.  - FM
d1603 1
a1603 1
	LYMultiBookmarks = MBM_OFF;
d1607 2
a1608 1
#ifdef USE_SOURCE_CACHE
a1626 17
#if defined (__DJGPP__)
    if (watt_debug)
	dbug_init();
    sock_init();

    __system_flags =
	__system_emulate_chdir |	/* handle `cd' internally */
	__system_handle_null_commands |		/* ignore cmds with no effect */
	__system_allow_long_cmds |	/* handle commands > 126 chars   */
	__system_use_shell |	/* use $SHELL if set */
	__system_allow_multiple_cmds |	/* allow `cmd1; cmd2; ...' */
	__system_redirect;	/* redirect internally */

    /* This speeds up stat() tremendously */
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC | _STAT_DIRSIZE;
#endif /* __DJGPP__ */

d1628 1
a1628 4
#ifdef WIN32
    SetConsoleCtrlHandler((PHANDLER_ROUTINE) cleanup_win32, TRUE);
#endif

a1629 1
    if (!dump_output_immediately)
a1631 1

d1634 1
a1634 1
    LYExtSignal(SIGWINCH, size_change);
d1647 1
a1647 1
	 * Since we're doing lots of TCP, just ignore SIGPIPE altogether.
d1649 5
a1653 4
	 * HTTCP.c should deal with a broken pipe for servers.  Rick Mallet's
	 * check after c = GetChar() in LYStrings.c should deal with a
	 * disconnected terminal.  So the runaway CPU time problem on Unix
	 * should not occur any more.
d1656 1
a1656 2
	if (signal(SIGPIPE, SIG_IGN) != SIG_IGN)
	    restore_sigpipe_for_children = TRUE;
d1663 1
a1663 1
     * Block Control-Z suspending if requested.  - FM
d1666 1
a1666 1
	(void) signal(SIGTSTP, SIG_IGN);
d1670 1
a1670 1
     * Check for a valid HEAD request.  - FM
d1674 1
a1674 1
		"The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n",
d1676 1
a1676 1
	exit_immediately(EXIT_FAILURE);
d1680 1
a1680 1
     * Check for a valid MIME headers request.  - FM
d1684 1
a1684 1
		"The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n",
d1686 1
a1686 1
	exit_immediately(EXIT_FAILURE);
d1690 1
a1690 1
     * Check for a valid traversal request.  - FM
d1694 1
a1694 1
		"The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n",
d1696 1
a1696 1
	exit_immediately(EXIT_FAILURE);
d1700 3
a1702 3
     * Finish setting up for an INTERACTIVE session.  Done here so that URL
     * guessing in LYEnsureAbsoluteURL() can be interruptible (terminal is in
     * raw mode, select() works).  -BL
d1704 3
a1706 7
#ifdef USE_PRETTYSRC
    if (!dump_output_immediately) {
	HTMLSRC_init_caches(FALSE);	/* do it before terminal is initialized */
#ifdef LY_FIND_LEAKS
	atexit(html_src_clean_data);
#endif
    }
d1713 3
a1715 2
     * If startfile is a file URL and the host is defaulted, force in
     * "//localhost", and if it's not an absolute URL, make it one.  - FM
d1717 2
a1718 1
    LYEnsureAbsoluteURL(&startfile, "STARTFILE", FALSE);
d1721 3
a1723 3
     * If homepage was specified and is a file URL with the host defaulted,
     * force in "//localhost", and if it's not an absolute URL, make it one.  -
     * FM
d1726 2
a1727 1
	LYEnsureAbsoluteURL(&homepage, "HOMEPAGE", FALSE);
d1731 3
a1733 2
     * If we don't have a homepage specified, set it to startfile.  Otherwise,
     * reset LynxHome.  - FM
d1735 1
a1735 1
    if (isEmpty(homepage)) {
d1742 1
a1742 1
     * Set up the inside/outside domain restriction flags.  - FM
d1745 2
a1746 2
#if !defined(HAVE_UTMP) || defined(VMS)		/* not selective */
	telnet_ok = (BOOL) (!no_inside_telnet && !no_outside_telnet && telnet_ok);
d1748 1
a1748 1
	news_ok = (BOOL) (!no_inside_news && !no_outside_news && news_ok);
d1750 2
a1751 2
	ftp_ok = (BOOL) (!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
d1753 2
a1754 2
	CTRACE((tfp, "LYMain: User in Local domain\n"));
	telnet_ok = (BOOL) (!no_inside_telnet && telnet_ok);
d1756 1
a1756 1
	news_ok = (BOOL) (!no_inside_news && news_ok);
d1758 2
a1759 2
	ftp_ok = (BOOL) (!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && rlogin_ok);
d1762 2
a1763 2
	CTRACE((tfp, "LYMain: User in REMOTE domain\n"));
	telnet_ok = (BOOL) (!no_outside_telnet && telnet_ok);
d1765 1
a1765 1
	news_ok = (BOOL) (!no_outside_news && news_ok);
d1767 2
a1768 2
	ftp_ok = (BOOL) (!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_outside_rlogin && rlogin_ok);
d1772 2
a1773 2
     * Make sure our bookmark default strings are all allocated and
     * synchronized.  - FM
d1776 5
a1780 4
	temp = NULL;
	HTSprintf0(&temp, "lynx_bookmarks%s", HTML_SUFFIX);
	set_default_bookmark_page(temp);
	FREE(temp);
d1783 3
a1785 8
	set_default_bookmark_page(bookmark_page);
    }
#if defined(SYSLOG_REQUESTED_URLS)
    LYOpenlog(syslog_txt);
#endif

    if (non_empty(x_display)) {
	LYisConfiguredForX = TRUE;
d1789 1
a1789 1
     * Here's where we do all the work.
d1793 2
a1794 1
	 * Finish setting up and start a NON-INTERACTIVE session.  - FM
d1796 1
a1796 3
	if (crawl && !number_links && !number_fields) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	} else if (no_numbers) {
d1798 3
a1800 6
	} else if (!no_list) {
	    if (!links_are_numbered()) {
		if (number_fields)
		    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
		else
		    keypad_mode = LINKS_ARE_NUMBERED;
d1803 3
a1808 21
	/*
	 * Normal argument processing puts non-options (URLs) into the Goto
	 * history.  Use this to dump all of the pages listed on the command
	 * line, or (if none are listed) via the startfile mechanism.
	 * history.
	 */
#ifdef EXTENDED_STARTFILE_RECALL
	HTAddGotoURL(startfile);
	for (i = HTList_count(Goto_URLs) - 1; i >= 0; --i) {
	    StrAllocCopy(startfile, (char *) HTList_objectAt(Goto_URLs, i));
	    CTRACE((tfp, "dumping %d:%d %s\n",
		    i + 1, HTList_count(Goto_URLs), startfile));
	    status = mainloop();
	    if (!no_list &&
		!crawl &&	/* For -crawl it has already been done! */
		links_are_numbered())
		printlist(stdout, FALSE);
	    if (i != 0)
		printf("\n");
	}
#else
d1810 5
a1814 6
	if (!no_list &&
	    !crawl &&		/* For -crawl it has already been done! */
	    links_are_numbered())
	    printlist(stdout, FALSE);
#endif
#ifdef USE_PERSISTENT_COOKIES
d1816 3
a1818 2
	 * We want to save cookies picked up when in immediate dump mode. 
	 * Instead of calling cleanup() here, let's only call this one.  - BJP
d1821 3
a1823 2
	    LYStoreCookies(LYCookieSaveFile);
#endif /* USE_PERSISTENT_COOKIES */
d1827 1
a1827 1
	 * Start an INTERACTIVE session.  - FM
d1829 3
d1836 2
a1837 12
#ifndef NO_DUMP_WITH_BACKSPACES
	if (with_backspaces) {
	    /* we should warn about this somehow (nop for now) -VH */
	    with_backspaces = FALSE;
	}
#endif

#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
	init_charset_subsets();
#endif

	ena_csi((BOOLEAN) (LYlowest_eightbit[current_char_set] > 155));
d1839 1
a1839 2
	LYCloseCloset(RECALL_URL);
	LYCloseCloset(RECALL_MAIL);
d1841 1
a1841 8
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
	if (!isendwin()) {
	    if ((saved_scrsize_x != 0) && (saved_scrsize_y != 0)) {
		resize_term(saved_scrsize_y, saved_scrsize_x);
	    }
	}
#endif
	exit_immediately(status);
d1844 1
a1844 1
    return (status);		/* though redundant, for compiler-warnings */
d1848 3
a1850 3
 * Called by HTAccessInit to register any protocols supported by lynx. 
 * Protocols added by lynx:
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE, LYNXMESSAGES
a1856 2
extern GLOBALREF (HTProtocol, LYLynxStatusMessages);

d1858 4
a1861 5
GLOBALREF HTProtocol LYLynxKeymap;
GLOBALREF HTProtocol LYLynxCGI;
GLOBALREF HTProtocol LYLynxIMGmap;
GLOBALREF HTProtocol LYLynxCookies;
GLOBALREF HTProtocol LYLynxStatusMessages;
d1864 1
a1864 1
void LYRegisterLynxProtocols(void)
a1869 1
    HTRegisterProtocol(&LYLynxStatusMessages);
d1874 4
a1877 7
 * Some stuff to reload lynx.cfg without restarting new lynx session, also load
 * options menu items and command-line options to make things consistent.
 *
 * Called by user of interactive session by LYNXCFG://reload/ link.
 *
 * Warning:  experimental, more main() reorganization required.
 *	*Known* exceptions: persistent cookies, cookie files.
d1879 1
a1879 6
 *	Some aspects of COLOR (with slang?).
 *	Viewer stuff, mailcap files
 *	SUFFIX, mime.types files
 *	RULESFILE/RULE
 *
 *	All work "somewhat", but not exactly as the first time.
d1881 1
a1881 1
void reload_read_cfg(void)
d1883 1
a1883 2
    char *tempfile;
    FILE *rcfp;
d1885 2
a1886 17
    /*
     * no_option_save is always set for -anonymous and -validate.  It is better
     * to check for one or several specific restriction flags than for
     * 'LYRestricted', which doesn't get set for individual restrictions or for
     * -validate!  However, no_option_save may not be the appropriate one to
     * check - in that case, a new no_something should be added that gets
     * automatically set for -anonymous and -validate (and whether it applies
     * for -anonymous can be made installer- configurable in the usual way at
     * the bottom of userdefs.h).  - kw
     *
     */
    if (no_option_save) {
	/* current logic requires(?) that saving user preferences is
	   possible.  Additional applicable restrictions are already
	   checked by caller. - kw */
	return;
    }
d1888 1
a1888 25
    /*
     * Current user preferences are saved in a temporary file, to be read in
     * again after lynx.cfg has been read.  This avoids accidental changing of
     * the preferences file.  The regular preferences file doesn't even need to
     * exist, and won't be created as a side effect of this function.  Honoring
     * the no_option_save restriction may thus be unnecessarily restrictive,
     * but the check is currently still left in place.  - kw
     */
    tempfile = typecallocn(char, LY_MAXPATH);
    if (!tempfile) {
	HTAlwaysAlert(NULL, NOT_ENOUGH_MEMORY);
	return;
    }
    rcfp = LYOpenTemp(tempfile, ".rc", "w");
    if (rcfp == NULL) {
	FREE(tempfile);
	HTAlwaysAlert(NULL, CANNOT_OPEN_TEMP);
	return;
    }
    if (!save_rc(rcfp)) {
	HTAlwaysAlert(NULL, OPTIONS_NOT_SAVED);
	LYRemoveTemp(tempfile);
	FREE(tempfile);
	return;			/* can not write the very own file :( */
    } {
d1890 1
a1890 1
#ifdef USE_PERSISTENT_COOKIES
d1892 1
a1892 22
	char *LYCookieFile_flag = NULL;
	char *LYCookieSaveFile_flag = NULL;

	if (persistent_cookies) {
	    StrAllocCopy(LYCookieFile_flag, LYCookieFile);
	    StrAllocCopy(LYCookieSaveFile_flag, LYCookieSaveFile);
	}
#endif

#ifdef EXP_CHARSET_CHOICE
	custom_assumed_doc_charset = FALSE;
	custom_display_charset = FALSE;
	memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
#endif

#ifdef USE_PRETTYSRC
	html_src_on_lynxcfg_reload();
#endif
	/* free downloaders, printers, environments, dired menu */
	free_lynx_cfg();
#ifdef USE_SOURCE_CACHE
	source_cache_file_error = FALSE;	/* reset flag */
d1895 1
d1897 1
a1897 1
	 * Process the configuration file.
d1899 1
a1899 1
	read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);
d1902 1
a1902 1
	 * Process the temporary RC file.
d1904 1
a1904 4
	rcfp = fopen(tempfile, "r");
	read_rc(rcfp);
	LYRemoveTemp(tempfile);
	FREE(tempfile);		/* done with it - kw */
a1905 3
#ifdef EXP_CHARSET_CHOICE
	init_charset_subsets();
#endif
d1911 1
a1911 1
	 * Process any command line arguments not already handled.
d1913 1
a1913 1
	/* Not implemented yet here */
d1916 2
a1917 2
	 * Process any stdin-derived arguments for a lone "-" which we've
	 * loaded into LYStdinArgs.
d1919 1
a1919 1
	/* Not implemented yet here */
d1922 1
a1922 10
	 * Initialize other things based on the configuration read.
	 */
	if (user_mode == NOVICE_MODE) {
	    display_lines = LYlines - 4;
	} else {
	    display_lines = LYlines - 2;
	}
	/* Not implemented yet here,
	 * a major problem: file paths
	 * like lynx_save_space, LYCookieFile etc.
d1924 5
a1928 1
#ifdef USE_PERSISTENT_COOKIES
d1930 8
a1937 18
	if (persistent_cookies != persistent_cookies_flag) {
	    persistent_cookies = persistent_cookies_flag;
	    HTAlert(gettext("persistent cookies state will be changed in next session only."));
	}
	if (persistent_cookies) {
	    if (strcmp(LYCookieFile, LYCookieFile_flag)) {
		StrAllocCopy(LYCookieFile, LYCookieFile_flag);
		CTRACE((tfp,
			"cookie file can be changed in next session only, restored.\n"));
	    }
	    if (strcmp(LYCookieSaveFile, LYCookieSaveFile_flag)) {
		StrAllocCopy(LYCookieSaveFile, LYCookieSaveFile_flag);
		CTRACE((tfp,
			"cookie save file can be changed in next session only, restored.\n"));
	    }
	    FREE(LYCookieFile_flag);
	    FREE(LYCookieSaveFile_flag);
	}
a1943 15
static void disable_pausing(void)
{
    AlertSecs = 0;
    DebugSecs = 0;
    InfoSecs = 0;
    MessageSecs = 0;
    ReplaySecs = 0;
}

static void force_dump_mode(void)
{
    dump_output_immediately = TRUE;
    disable_pausing();
    LYcols = DFT_COLS;
}
d1955 44
a1998 20
#define PARSE_SET(n,t,v,h) {n,    t, UNION_SET(v), h}
#define PARSE_INT(n,t,v,h) {n,    t, UNION_INT(v), h}
#define PARSE_STR(n,t,v,h) {n,    t, UNION_STR(v), h}
#define PARSE_FUN(n,t,v,h) {n,    t, UNION_FUN(v), h}
#define PARSE_NIL          {NULL, 0, UNION_DEF(0), NULL}

typedef struct parse_args_type {
    const char *name;
    int type;

#define TOGGLE_ARG		0x0010
#define SET_ARG			0x0020
#define UNSET_ARG		0x0030
#define FUNCTION_ARG		0x0040
#define LYSTRING_ARG		0x0050
#define INT_ARG			0x0060
#define STRING_ARG		0x0070
#define TIME_ARG		0x0080
#define ARG_TYPE_MASK		0x0FF0
#define NEED_NEXT_ARG		0x1000
a2000 1
#define NEED_TIME_ARG		(NEED_NEXT_ARG | TIME_ARG)
d2005 3
a2007 3
    /* If the NEED_NEXT_ARG flags is set, and the option was not specified
     * with an '=' character, then use the next argument in the argv list.
     */
d2009 4
a2012 3
      ParseData;
    const char *help_string;
} Config_Type;
d2015 3
a2017 2
static int parse_authentication(char *next_arg,
				char **result)
d2020 1
a2020 1
     * Authentication information for protected documents.
d2026 1
a2026 1
	memset(next_arg, ' ', strlen(next_arg));	/* Let's not show too much */
d2032 1
a2032 1
	if ((cp = strchr(auth_info, ':')) != 0) {	/* Pw */
d2037 1
a2037 1
	if (*auth_info) {	/* Id */
d2047 2
a2048 1
static int anonymous_fun(char *next_arg GCC_UNUSED)
d2050 9
a2058 4
    if (!LYValidate && !LYRestricted)
	parse_restrictions("default");
    LYRestricted = TRUE;
    return 0;
d2062 2
a2063 1
static int assume_charset_fun(char *next_arg)
d2076 2
a2077 1
static int assume_local_charset_fun(char *next_arg)
d2084 2
a2085 1
static int assume_unrec_charset_fun(char *next_arg)
d2092 2
a2093 1
static int auth_fun(char *next_arg)
d2100 2
a2101 1
static int base_fun(char *next_arg GCC_UNUSED)
d2104 6
a2109 5
     * Treat -source equivalently to an interactive download with
     * LYPrefixBaseToSource configured to TRUE, so that a BASE tag is prepended
     * for text/html content types.  We normally treat the module-wide global
     * LYPrefixBaseToSource flag as FALSE with -source, but force it TRUE,
     * later, if LYPrependBase is set TRUE here.  - FM
d2118 10
d2129 2
a2130 1
static int cache_fun(char *next_arg)
d2135 1
a2135 1
     * Limit size.
d2137 1
a2137 2
    if (HTCacheSize < 2)
	HTCacheSize = 2;
d2143 2
a2144 1
static int child_fun(char *next_arg GCC_UNUSED)
d2153 2
a2154 1
static int color_fun(char *next_arg GCC_UNUSED)
a2164 44
#ifdef MISC_EXP
/* -convert_to */
static int convert_to_fun(char *next_arg)
{
    if (next_arg != 0) {
	char *outformat = NULL;
	char *cp1, *cp2, *cp4;
	int chndl;

	StrAllocCopy(outformat, next_arg);
	/* not lowercased, to allow for experimentation - kw */
	/*LYLowerCase(outformat); */
	if ((cp1 = strchr(outformat, ';')) != NULL) {
	    if ((cp2 = LYstrstr(cp1, "charset")) != NULL) {
		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
		    cp2++;
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '"' &&
				 *cp4 != ';' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
		*cp4 = '\0';
		/* This is intentionally not the "safe" version,
		   to allow for experimentation. */
		chndl = UCGetLYhndl_byMIME(cp2);
		if (chndl < 0)
		    chndl = UCLYhndl_for_unrec;
		if (chndl < 0) {
		    fprintf(stderr,
			    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
		} else {
		    current_char_set = chndl;
		}
		*cp1 = '\0';	/* truncate outformat */
	    }
	}
	HTOutputFormat = HTAtom_for(outformat);
	FREE(outformat);
    } else {
	HTOutputFormat = NULL;
    }
    return 0;
}
#endif

d2166 2
a2167 1
static int crawl_fun(char *next_arg GCC_UNUSED)
d2170 1
a2170 1
    LYcols = DFT_COLS;
d2175 2
a2176 1
static int display_fun(char *next_arg)
d2180 2
a2186 17
/* -display_charset */
static int display_charset_fun(char *next_arg)
{
    int i = UCGetLYhndl_byMIME(next_arg);

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (i < 0 && !strcasecomp(next_arg, "auto"))
	i = auto_display_charset;
#endif
    if (i < 0) {		/* do nothing here: so fallback to lynx.cfg */
	fprintf(stderr,
		gettext("Lynx: ignoring unrecognized charset=%s\n"), next_arg);
    } else
	current_char_set = i;
    return 0;
}

d2188 2
a2189 1
static int dump_output_fun(char *next_arg GCC_UNUSED)
d2191 2
a2192 1
    force_dump_mode();
d2197 2
a2198 1
static int editor_fun(char *next_arg)
d2207 2
a2208 1
static int error_file_fun(char *next_arg)
d2211 2
a2212 1
     * Output return (success/failure) code of an HTTP transaction.
d2221 2
a2222 1
static int exec_fun(char *next_arg GCC_UNUSED)
d2234 2
a2235 1
static int get_data_fun(char *next_arg GCC_UNUSED)
d2238 1
a2238 1
     * User data for GET form.
d2244 2
a2245 2
     * On Unix, conflicts with curses when interactive so let's force a dump. 
     * -CL
d2247 2
a2248 2
     * On VMS, mods have been made in LYCurses.c to deal with potential
     * conflicts, so don't force the dump here.  - FM
d2251 2
a2252 1
    force_dump_mode();
d2255 1
a2255 1
    StrAllocCopy(form_get_data, "?");	/* Prime the pump */
d2259 2
a2260 2
     * Build GET data for later.  Stop reading when we see a line with "---" as
     * its first three characters.
d2262 8
a2269 1
    while (GetStdin(&buf, TRUE)) {
a2272 2
    CTRACE((tfp, "get_data:%s\n", *get_data));
    CTRACE((tfp, "get_data:%s\n", form_get_data));
d2277 2
a2278 1
static int help_fun(char *next_arg GCC_UNUSED)
d2280 1
a2280 1
    print_help_and_exit(0);
d2285 2
a2286 1
static int hiddenlinks_fun(char *next_arg)
a2287 9
    /* *INDENT-OFF* */
    static Config_Enum table[] = {
	{ "merge",	HIDDENLINKS_MERGE },
	{ "listonly",	HIDDENLINKS_SEPARATE },
	{ "ignore",	HIDDENLINKS_IGNORE },
	{ NULL,		-1 },
    };
    /* *INDENT-ON* */

d2289 8
a2296 2
	if (!LYgetEnum(table, next_arg, &LYHiddenLinks))
	    print_help_and_exit(-1);
d2305 2
a2306 1
static int homepage_fun(char *next_arg)
d2316 2
a2317 1
static int mime_header_fun(char *next_arg GCC_UNUSED)
d2320 1
a2320 1
     * Include mime headers and force source dump.
d2323 1
a2323 1
    force_dump_mode();
d2326 1
a2326 1
    LYcols = MAX_COLS;
d2332 2
a2333 1
static int newschunksize_fun(char *next_arg)
d2348 2
a2349 1
static int newsmaxchunk_fun(char *next_arg)
a2363 7
/* -nobold */
static int nobold_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(1);
    return 0;
}

d2365 2
a2366 1
static int nobrowse_fun(char *next_arg GCC_UNUSED)
d2368 2
a2369 2
    HTDirAccess = HT_DIR_FORBID;
    return 0;
d2373 2
a2374 1
static int nocolor_fun(char *next_arg GCC_UNUSED)
d2385 2
a2386 1
static int nopause_fun(char *next_arg GCC_UNUSED)
d2388 3
a2390 28
    disable_pausing();
    return 0;
}

/* -noreverse */
static int noreverse_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(2);
    return 0;
}

/* -nounderline */
static int nounderline_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(4);
    return 0;
}

#ifdef MISC_EXP
/* -nozap */
static int nozap_fun(char *next_arg)
{
    LYNoZapKey = 1;		/* everything but "initially" treated as "full" - kw */
    if (next_arg != 0) {
	if (strcasecomp(next_arg, "initially") == 0)
	    LYNoZapKey = 2;

    }
a2392 1
#endif /* MISC_EXP */
d2395 2
a2396 1
static int pauth_fun(char *next_arg)
d2403 2
a2404 1
static int post_data_fun(char *next_arg GCC_UNUSED)
d2407 1
a2407 1
     * User data for POST form.
d2420 2
a2421 1
    force_dump_mode();
d2430 8
a2437 1
    while (GetStdin(&buf, TRUE)) {
d2440 1
a2440 19
    return 0;
}

static const char *show_restriction(const char *name)
{
    const char *value = 0;

    switch (find_restriction(name, -1)) {
    case TRUE:
	value = "on";
	break;
    case FALSE:
	value = "off";
	break;
    default:
	value = "?";
	break;
    }
    return value;
d2444 2
a2445 1
static int restrictions_fun(char *next_arg)
d2447 7
a2453 8
    /* *INDENT-OFF* */
    static const struct {
	const char *name;
	const char *help;
    } table[] = {
	{ "all", "restricts all options." },
	{ "bookmark", "disallow changing the location of the bookmark file" },
	{ "bookmark_exec", "disallow execution links via the bookmark file" },
d2455 3
a2457 4
	{ "change_exec_perms", "\
disallow changing the eXecute permission on files\n\
(but still allow it for directories) when local file\n\
management is enabled." },
d2459 6
a2464 19
#ifdef SUPPORT_CHDIR
	{ "chdir", "\
disallow changing the working directory of lynx, e.g.,\n\
to affect the behavior of download command" },
#endif
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	{ "compileopts_info", "\
disable info on options used to compile the binary" },
#endif
	{ "default", "\
same as commandline option -anonymous.  Sets the\n\
default service restrictions for anonymous users.  Set to\n\
all restricted, except for: inside_telnet, outside_telnet,\n\
inside_ftp, outside_ftp, inside_rlogin, outside_rlogin,\n\
inside_news, outside_news, telnet_port, jump, mail, print,\n\
exec, and goto.  The settings for these, as well as\n\
additional goto restrictions for specific URL schemes\n\
that are also applied, are derived from definitions\n\
within userdefs.h." },
d2466 1
a2466 1
	{ "dired_support", "disallow local file management" },
d2468 6
a2473 6
	{ "disk_save", "disallow saving to disk in the download and print menus" },
	{ "dotfiles", "disallow access to, or creation of, hidden (dot) files" },
	{ "download", "disallow some downloaders in the download menu" },
	{ "editor", "disallow editing" },
	{ "exec", "disable execution scripts" },
	{ "exec_frozen", "disallow the user from changing the execution link option" },
d2475 1
a2475 1
	{ "externals", "disable passing URLs to some external programs" },
d2477 3
a2479 4
	{ "file_url", "\
disallow using G)oto, served links or bookmarks for\n\
file: URL's" },
	{ "goto", "disable the 'g' (goto) command" },
d2481 14
a2494 22
	{ "inside_ftp", "\
disallow ftps coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain (utmp required for selectivity)" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_telnet", "\
disallow telnets coming from inside your\n\
domain (utmp required for selectivity)" },
#else
	{ "inside_ftp", "\
disallow ftps coming from inside your domain" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your domain" },
	{ "inside_telnet", "\
disallow telnets coming from inside your domain" },
d2496 5
a2500 13
	{ "jump", "disable the 'j' (jump) command" },
	{ "lynxcfg_info", "\
disable viewing of lynx.cfg configuration file info" },
#ifndef NO_CONFIG_INFO
	{ "lynxcfg_xinfo", "\
disable extended lynx.cfg viewing and reloading" },
#endif
	{ "lynxcgi", "\
disallow execution of Lynx CGI URLs" },
	{ "mail", "disallow mail" },
	{ "multibook", "disallow multiple bookmark files" },
	{ "news_post", "disallow USENET News posting." },
	{ "option_save", "disallow saving options in .lynxrc" },
d2502 14
a2515 22
	{ "outside_ftp", "\
disallow ftps coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain (utmp required for selectivity)" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_telnet", "\
disallow telnets coming from outside your\n\
domain (utmp required for selectivity)" },
#else
	{ "outside_ftp", "\
disallow ftp coming from outside your domain" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your domain" },
	{ "outside_telnet", "\
disallow telnets coming from outside your domain" },
d2517 6
a2522 7
	{ "print", "disallow most print options" },
	{ "shell", "\
disallow shell escapes, and lynxexec, lynxprog or lynxcgi\n\
G)oto's" },
	{ "suspend", "disallow Control-Z suspends with escape to shell" },
	{ "telnet_port", "disallow specifying a port in telnet G)oto's" },
	{ "useragent", "disallow modifications of the User-Agent header" },
d2524 1
a2524 1
    /* *INDENT-ON* */
d2526 2
a2527 61
    static const char *Usage[] =
    {
	""
	,"USAGE: lynx -restrictions=[option][,option][,option]"
	,"List of Options:"
	,"  ?                 when used alone, list restrictions in effect."

    };
    unsigned j, k, column = 0;
    const char *name;
    const char *value;
    BOOLEAN found, first;

    if (isEmpty(next_arg)) {
	SetOutputMode(O_TEXT);
	for (j = 0; j < TABLESIZE(Usage); j++) {
	    printf("%s\n", Usage[j]);
	}
	for (j = 0; j < TABLESIZE(table); j++) {
	    if (!strcmp(table[j].name, "all")
		|| !strcmp(table[j].name, "default")) {
		value = NULL;
	    } else {
		value = show_restriction(table[j].name);
	    }
	    print_help_strings(table[j].name, table[j].help, value, FALSE);
	}
	first = TRUE;
	for (j = 0;; j++) {
	    found = FALSE;
	    if ((name = index_to_restriction(j)) == 0) {
		break;
	    }
	    for (k = 0; k < TABLESIZE(table); k++) {
		if (!strcmp(name, table[k].name)) {
		    found = TRUE;
		}
	    }
	    if (!found) {
		if (first) {
		    printf("Other restrictions (see the user's guide):\n");
		}
		value = show_restriction(table[j].name);
		printf("%s%s (%s)", column ? ", " : "  ", name, value);
		column += 5 + strlen(name) + strlen(value);
		if (column > 50) {
		    column = 0;
		    printf("\n");
		}
		first = FALSE;
	    }
	}
	if (column)
	    printf("\n");
	SetOutputMode(O_BINARY);
	exit_immediately(EXIT_SUCCESS);
    } else if (*next_arg == '?') {
	SetOutputMode(O_TEXT);
	print_restrictions_to_fd(stdout);
	SetOutputMode(O_BINARY);
	exit_immediately(EXIT_SUCCESS);
d2529 5
a2533 1
	parse_restrictions(next_arg);
d2539 2
a2540 1
static int selective_fun(char *next_arg GCC_UNUSED)
d2542 2
a2543 2
    HTDirAccess = HT_DIR_SELECTIVE;
    return 0;
d2547 2
a2548 1
static int source_fun(char *next_arg GCC_UNUSED)
d2550 1
a2550 1
    force_dump_mode();
d2553 1
a2553 1
    LYcols = MAX_COLS;
d2558 2
a2559 1
static int traversal_fun(char *next_arg GCC_UNUSED)
d2563 1
a2563 1
    LYcols = DFT_COLS;
d2565 1
a2565 1
    LYcols = MAX_COLS;
d2572 2
a2573 1
static int version_fun(char *next_arg GCC_UNUSED)
d2575 1
a2575 26
    char *result = NULL;

    SetOutputMode(O_TEXT);

    HTSprintf0(&result, gettext("%s Version %s (%s)"),
	       LYNX_NAME, LYNX_VERSION,
	       LYVersionDate());
#ifdef USE_SSL
    StrAllocCat(result, "\n");
    HTSprintf(&result, "libwww-FM %s,", HTLibraryVersion);
    append_ssl_version(&result, " ");
#endif /* USE_SSL */

#if defined(NCURSES) && defined(HAVE_CURSES_VERSION)
    HTSprintf(&result, ", %s", curses_version());
#if defined(WIDEC_CURSES)
    HTSprintf(&result, "(wide)");
#endif
#elif defined(PDCURSES) && defined(PDC_BUILD)
    HTSprintf(&result, ", pdcurses %.3f", PDC_BUILD * 0.001);
#elif defined(USE_SLANG) && defined(SLANG_VERSION_STRING)
    HTSprintf(&result, ", s-lang %s", SLANG_VERSION_STRING);
#endif

    printf("%s\n", result);
    free(result);
d2577 7
a2589 6

/*
 * SYSTEM_NAME is set by the configure script.  Show build date/time for other
 * systems, according to predefined compiler symbols.
 */
#ifdef SYSTEM_NAME
d2591 9
a2599 32
#else
#ifdef __CYGWIN__
    printf("Compiled by CYGWIN (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __BORLANDC__
    printf("Compiled by Borland C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef _MSC_VER
    printf("Compiled by Microsoft Visual C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __DJGPP__
    printf("Compiled by DJGPP (%s %s).\n", __DATE__, __TIME__);
#else
    printf("Compiled at (%s %s).\n", __DATE__, __TIME__);
#endif /* __DJGPP__ */
#endif /* _MSC_VER */
#endif /* __BORLANDC__ */
#endif /* __CYGWIN__ */
#endif

    puts("");
    puts(gettext("Copyrights held by the University of Kansas, CERN, and other contributors."));
    puts(gettext("Distributed under the GNU General Public License."));
    puts(gettext("See http://lynx.isc.org/ and the online help for more information."));
    puts("");
#ifdef USE_SSL
    puts("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.");
#ifdef OPENSSL_VERSION_TEXT
    puts("See http://www.openssl.org/ for information about OpenSSL.");
#endif /* OPENSSL_VERSION_TEXT */
    puts("");
#endif /* USE_SSL */
d2601 1
a2601 1
    SetOutputMode(O_BINARY);
d2603 1
a2603 1
    exit_immediately(EXIT_SUCCESS);
d2609 2
a2610 1
static int width_fun(char *next_arg)
a2613 1

d2615 1
a2615 1
	    dump_output_width = ((w < MAX_COLS) ? w : MAX_COLS);
d2621 2
a2622 30
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* -scrsize */
static int scrsize_fun(char *next_arg)
{
    if (next_arg != 0) {
	char *cp;

	if ((cp = strchr(next_arg, ',')) != 0) {
	    *cp++ = '\0';	/* Terminate ID */
	    scrsize_x = atoi(next_arg);
	    scrsize_y = atoi(cp);
	    if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
		scrsize_x = scrsize_y = 0;
	    }
	    if ((scrsize_x > 0) && (scrsize_x < 80)) {
		scrsize_x = 80;
	    }
	    if ((scrsize_y > 0) && (scrsize_y < 4)) {
		scrsize_y = 4;
	    }
	    CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
	}
    }
    return 0;
}
#endif

/* NOTE: This table is sorted by name to make the help message useful */
/* *INDENT-OFF* */
static Config_Type Arg_Table [] =
d2625 2
a2626 2
      "accept_all_cookies", 4|SET_ARG,		LYAcceptAllCookies,
      "\naccept cookies without prompting if Set-Cookie handling\nis on"
d2629 2
a2630 2
      "anonymous",	2|FUNCTION_ARG,		anonymous_fun,
      "apply restrictions for anonymous account,\nsee also -restrictions"
d2633 1
a2633 1
      "assume_charset", 4|NEED_FUNCTION_ARG,	assume_charset_fun,
d2637 1
a2637 1
      "assume_local_charset",	4|NEED_FUNCTION_ARG,assume_local_charset_fun,
d2641 1
a2641 1
      "assume_unrec_charset",	4|NEED_FUNCTION_ARG,assume_unrec_charset_fun,
d2645 1
a2645 1
      "auth",		4|NEED_FUNCTION_ARG,	auth_fun,
d2649 1
a2649 1
      "base",		4|FUNCTION_ARG,		base_fun,
d2652 4
a2655 4
#ifndef DISABLE_BIBP
   PARSE_STR(
      "bibhost",	4|NEED_LYSTRING_ARG,	BibP_bibhost,
      "=URL\nlocal bibp server (default http://bibhost/)"
a2657 1
#ifdef USE_BLINK
d2659 1
a2659 6
      "blink",		4|SET_ARG,		term_blink_is_boldbg,
      "enable bright background via the BLINK terminal attribute"
   ),
#endif
   PARSE_SET(
      "book",		4|SET_ARG,		bookmark_start,
d2663 1
a2663 1
      "buried_news",	4|TOGGLE_ARG,		scan_for_buried_news_references,
d2667 1
a2667 1
      "cache",		4|NEED_FUNCTION_ARG,	cache_fun,
d2671 1
a2671 1
      "case",		4|SET_ARG,		case_sensitive,
a2673 4
   PARSE_SET(
      "center",		4|TOGGLE_ARG,		no_table_center,
      "toggle center alignment in HTML TABLE"
   ),
d2675 1
a2675 1
      "cfg",		2|NEED_LYSTRING_ARG,	lynx_cfg_file,
d2679 1
a2679 1
      "child",		4|FUNCTION_ARG,		child_fun,
a2681 10
#ifdef EXP_CMD_LOGGING
   PARSE_STR(
       "cmd_log",	2|NEED_LYSTRING_ARG,	lynx_cmd_logfile,
       "=FILENAME\nlog keystroke commands to the given file"
   ),
   PARSE_STR(
       "cmd_script",	2|NEED_LYSTRING_ARG,	lynx_cmd_script,
       "=FILENAME\nread keystroke commands from the given file\n(see -cmd_log)"
   ),
#endif
d2684 1
a2684 1
      "color",		4|FUNCTION_ARG,		color_fun,
d2688 3
a2690 14
   PARSE_INT(
      "connect_timeout", 4|NEED_INT_ARG,	connect_timeout,
      "=N\nset the N-second connection timeout"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "convert_to",	4|FUNCTION_ARG,		convert_to_fun,
      "=FORMAT\nconvert input, FORMAT is in MIME type notation\n(experimental)"
   ),
#endif
#ifdef USE_PERSISTENT_COOKIES
   PARSE_STR(
      "cookie_file",	4|LYSTRING_ARG,		LYCookieFile,
      "=FILENAME\nspecifies a file to use to read cookies"
d2692 1
d2694 1
a2694 1
      "cookie_save_file",	4|LYSTRING_ARG,	LYCookieSaveFile,
d2697 1
a2697 5
#endif /* USE_PERSISTENT_COOKIES */
   PARSE_SET(
      "cookies",	4|TOGGLE_ARG,		LYSetCookies,
      "toggles handling of Set-Cookie headers"
   ),
d2700 1
a2700 1
      "core",		4|TOGGLE_ARG,		LYNoCore,
d2705 1
a2705 1
      "crawl",		4|FUNCTION_ARG,		crawl_fun,
a2708 6
#ifdef USE_CURSES_PADS
   PARSE_SET(
      "curses_pads",	4|TOGGLE_ARG,		LYuseCursesPads,
      "uses curses pad feature to support left/right shifting"
   ),
#endif
d2711 1
a2711 1
      "debug_partial",	4|TOGGLE_ARG,		debug_display_partial,
a2714 4
   PARSE_INT(
      "delay",		4|NEED_TIME_ARG,	DebugSecs,
      "=NNN\nset NNN-second delay at statusline message"
   ),
d2716 1
a2716 1
      "display",	4|NEED_FUNCTION_ARG,	display_fun,
d2720 1
a2720 10
      "display_charset", 4|NEED_FUNCTION_ARG,	display_charset_fun,
      "=MIMEname\ncharset for the terminal output"
   ),
   PARSE_SET(
      "dont_wrap_pre",	4|SET_ARG,		dont_wrap_pre,
      "inhibit wrapping of text in <pre> when -dump'ing and\n\
-crawl'ing, mark wrapped lines in interactive session"
   ),
   PARSE_FUN(
      "dump",		4|FUNCTION_ARG,		dump_output_fun,
d2724 1
a2724 1
      "editor",		4|NEED_FUNCTION_ARG,	editor_fun,
d2728 1
a2728 1
      "emacskeys",	4|SET_ARG,		emacs_keys,
d2732 1
a2732 1
      "enable_scrollback", 4|TOGGLE_ARG,	enable_scrollback,
d2737 1
a2737 1
      "error_file",	4|NEED_FUNCTION_ARG,	error_file_fun,
d2743 1
a2743 1
      "exec",		4|FUNCTION_ARG,		exec_fun,
d2747 8
d2758 1
a2758 1
      "fileversions",	4|SET_ARG,		HTVMSFileVersions,
a2761 1
#ifdef LY_FIND_LEAKS
d2763 2
a2764 2
      "find_leaks",	4|TOGGLE_ARG,		LYfind_leaks,
      "toggles memory-leak checking"
a2765 1
#endif
d2767 2
a2768 2
      "force_empty_hrefless_a",	4|SET_ARG,	force_empty_hrefless_a,
      "\nforce HREF-less 'A' elements to be empty (close them as\nsoon as they are seen)"
d2771 2
a2772 6
      "force_html",	4|SET_ARG,		LYforce_HTML_mode,
      "forces the first document to be interpreted as HTML"
   ),
   PARSE_SET(
      "force_secure",	4|TOGGLE_ARG,		LYForceSSLCookiesSecure,
      "toggles forcing of the secure flag for SSL cookies"
d2776 1
a2776 1
      "forms_options",	4|TOGGLE_ARG,		LYUseFormsOptions,
d2781 1
a2781 5
      "from",		4|TOGGLE_ARG,		LYNoFromHeader,
      "toggle transmission of From headers"
   ),
   PARSE_SET(
      "ftp",		4|UNSET_ARG,		ftp_ok,
d2785 1
a2785 1
      "get_data",	2|FUNCTION_ARG,		get_data_fun,
d2789 1
a2789 1
      "head",		4|SET_ARG,		HEAD_request,
d2793 1
a2793 1
      "help",		1|FUNCTION_ARG,		help_fun,
d2797 1
a2797 1
      "hiddenlinks",	4|NEED_FUNCTION_ARG,	hiddenlinks_fun,
d2801 2
a2802 2
      "historical",	4|TOGGLE_ARG,		historical_comments,
      "toggles use of '>' or '-->' as terminator for comments"
d2805 1
a2805 1
      "homepage",	4|NEED_FUNCTION_ARG,	homepage_fun,
d2809 1
a2809 1
      "image_links",	4|TOGGLE_ARG,		clickable_images,
d2813 1
a2813 1
      "index",		4|NEED_LYSTRING_ARG,	indexfile,
d2817 1
a2817 1
      "ismap",		4|TOGGLE_ARG,		LYNoISMAPifUSEMAP,
a2819 6
#ifdef EXP_JUSTIFY_ELTS
   PARSE_SET(
      "justify",	4|SET_ARG,		ok_justify,
      "do justification of text"
   ),
#endif
d2821 1
a2821 1
      "link",		4|NEED_INT_ARG,		crawl_count,
d2825 1
a2825 5
      "listonly",	4|TOGGLE_ARG,		dump_links_only,
      "with -dump, forces it to show only the list of links"
   ),
   PARSE_SET(
      "localhost",	4|SET_ARG,		local_host_only,
d2828 1
a2828 7
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "locexec",	4|SET_ARG,		local_exec_on_local_files,
      "enable local program execution from local files only"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#if defined(USE_COLOR_STYLE)
d2830 1
a2830 1
      "lss",		2|NEED_LYSTRING_ARG,	lynx_lss_file,
d2835 1
a2835 1
      "mime_header",	4|FUNCTION_ARG,		mime_header_fun,
d2839 1
a2839 1
      "minimal",	4|TOGGLE_ARG,		minimal_comments,
a2841 6
#ifdef EXP_NESTED_TABLES
   PARSE_SET(
      "nested_tables",	4|TOGGLE_ARG,		nested_tables,
      "toggles nested-tables logic"
   ),
#endif
d2844 1
a2844 1
      "newschunksize",	4|NEED_FUNCTION_ARG,	newschunksize_fun,
d2848 1
a2848 1
      "newsmaxchunk",	4|NEED_FUNCTION_ARG,	newsmaxchunk_fun,
a2851 10
#if USE_BLAT_MAILER
   PARSE_SET(
      "noblat",		4|TOGGLE_ARG,		mail_is_blat,
      "select mail tool (`BLAT' ==> `sendmail')"
   ),
#endif
   PARSE_FUN(
      "nobold",		4|FUNCTION_ARG,		nobold_fun,
      "disable bold video-attribute"
   ),
d2853 1
a2853 1
      "nobrowse",	4|FUNCTION_ARG,		nobrowse_fun,
d2857 1
a2857 1
      "nocc",		4|SET_ARG,		LYNoCc,
d2861 1
a2861 1
      "nocolor",	4|FUNCTION_ARG,		nocolor_fun,
a2863 6
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "noexec",		4|UNSET_ARG,		local_exec,
      "disable local program execution (DEFAULT)"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
d2865 2
a2866 2
      "nofilereferer",	4|SET_ARG,		no_filereferer,
      "disable transmission of Referer headers for file URLs"
d2869 1
a2869 1
      "nolist",		4|SET_ARG,		no_list,
d2873 1
a2873 1
      "nolog",		4|UNSET_ARG,		error_logging,
a2875 10
#if defined(HAVE_SIGACTION) && defined(SIGWINCH)
   PARSE_SET(
      "nonrestarting_sigwinch", 4|SET_ARG,	LYNonRestartingSIGWINCH,
      "\nmake window size change handler non-restarting"
   ),
#endif /* HAVE_SIGACTION */
   PARSE_SET(
      "nonumbers",	4|SET_ARG,		no_numbers,
      "disable the link/form numbering feature in dumps"
   ),
d2877 1
a2877 1
      "nopause",	4|FUNCTION_ARG,		nopause_fun,
d2881 2
a2882 2
      "noprint",	4|SET_ARG,		no_print,
      "disable some print functions, like -restrictions=print"
d2885 1
a2885 1
      "noredir",	4|SET_ARG,		no_url_redirection,
d2889 2
a2890 6
      "noreferer",	4|SET_ARG,		LYNoRefererHeader,
      "disable transmission of Referer headers"
   ),
   PARSE_FUN(
      "noreverse",	4|FUNCTION_ARG,		noreverse_fun,
      "disable reverse video-attribute"
d2894 1
a2894 1
      "nosocks",	2|UNSET_ARG,		socks_flag,
d2899 1
a2899 1
      "nostatus",	4|SET_ARG,		no_statusline,
a2901 14
   PARSE_FUN(
      "nounderline",	4|FUNCTION_ARG,		nounderline_fun,
      "disable underline video-attribute"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "nozap",		4|FUNCTION_ARG,		nozap_fun,
      "=DURATION (\"initially\" or \"full\") disable checks for 'z' key"
   ),
#endif
   PARSE_SET(
      "number_fields",	4|SET_ARG,		number_fields,
      "force numbering of links as well as form input fields"
   ),
d2903 1
a2903 1
      "number_links",	4|SET_ARG,		number_links,
d2908 1
a2908 1
      "partial",	4|TOGGLE_ARG,		display_partial_flag,
d2912 1
a2912 1
      "partial_thres",	4|NEED_INT_ARG,		partial_threshold,
d2918 1
a2918 1
      "pauth",		4|NEED_FUNCTION_ARG,	pauth_fun,
d2922 1
a2922 1
      "popup",		4|UNSET_ARG,		LYUseDefSelPop,
d2926 1
a2926 1
      "post_data",	2|FUNCTION_ARG,		post_data_fun,
d2930 1
a2930 1
      "preparsed",	4|SET_ARG,		LYPreparsedSource,
d2934 1
a2934 1
#ifdef USE_PRETTYSRC
d2936 2
a2937 2
      "prettysrc",	4|SET_ARG,		LYpsrc,
      "do syntax highlighting and hyperlink handling in source\nview"
d2941 2
a2942 2
      "print",		4|UNSET_ARG,		no_print,
      "enable print functions (DEFAULT), opposite of -noprint"
d2945 1
a2945 1
      "pseudo_inlines", 4|TOGGLE_ARG,		pseudo_inline_alts,
d2949 2
a2950 3
      "raw",		4|UNSET_ARG,		LYUseDefaultRawMode,
      "toggles default setting of 8-bit character translations\n\
or CJK mode for the startup character set"
d2953 1
a2953 1
      "realm",		4|SET_ARG,		check_realm,
d2957 1
a2957 1
      "reload",		4|SET_ARG,		reloading,
d2961 1
a2961 1
      "restrictions",	4|FUNCTION_ARG,		restrictions_fun,
d2965 1
a2965 1
      "resubmit_posts", 4|TOGGLE_ARG,		LYresubmit_posts,
d2971 1
a2971 1
      "rlogin",		4|UNSET_ARG,		rlogin_ok,
a2973 16
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
   PARSE_FUN(
      "scrsize",	4|NEED_FUNCTION_ARG,	scrsize_fun,
      "=width,height\nsize of window"
   ),
#endif
#ifdef USE_SCROLLBAR
   PARSE_SET(
      "scrollbar",	4|TOGGLE_ARG,		LYShowScrollbar,
      "toggles showing scrollbar"
   ),
   PARSE_SET(
      "scrollbar_arrow", 4|TOGGLE_ARG,		LYsb_arrow,
      "toggles showing arrows at ends of the scrollbar"
   ),
#endif
d2975 1
a2975 1
      "selective",	4|FUNCTION_ARG,		selective_fun,
d2979 1
a2979 11
      "short_url",	4|SET_ARG,		long_url_ok,
      "enables examination of beginning and end of long URL in\nstatus line"
   ),
#ifdef SH_EX
   PARSE_SET(
      "show_cfg",	1|SET_ARG,		show_cfg,
      "Show `LYNX.CFG' setting"
   ),
#endif
   PARSE_SET(
      "show_cursor",	4|TOGGLE_ARG,		LYUseDefShoCur,
a2981 6
#ifdef USE_READPROGRESS
   PARSE_SET(
      "show_rate",	4|TOGGLE_ARG,		LYShowTransferRate,
      "toggles display of transfer rate"
   ),
#endif
d2983 1
a2983 1
      "soft_dquotes",	4|TOGGLE_ARG,		soft_dquotes,
d2988 1
a2988 1
      "source",		4|FUNCTION_ARG,		source_fun,
d2992 1
a2992 1
      "stack_dump",	4|SET_ARG,		stack_dump,
d2996 1
a2996 1
      "startfile_ok",	4|SET_ARG,		startfile_ok,
d2999 1
a2999 4
   PARSE_SET(
      "stdin",		4|SET_ARG,		startfile_stdin,
      "read startfile from standard input"
   ),
d3002 1
a3002 1
      "syslog",		4|NEED_LYSTRING_ARG,	syslog_txt,
d3005 1
a3005 4
   PARSE_SET(
      "syslog-urls",	4|SET_ARG,		syslog_requested_urls,
      "log requested URLs with syslog"
   ),
d3008 1
a3008 1
      "tagsoup",	4|SET_ARG,		DTD_recovery,
d3012 1
a3012 1
      "telnet",		4|UNSET_ARG,		telnet_ok,
d3016 1
a3016 1
      "term",		4|NEED_STRING_ARG,	terminal,
a3018 6
#ifdef _WINDOWS
   PARSE_INT(
      "timeout",	4|INT_ARG,		lynx_timeout,
      "=NUMBER\nset TCP/IP timeout"
   ),
#endif
d3020 1
a3020 1
      "tlog",		2|TOGGLE_ARG,		LYUseTraceLog,
a3022 1
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
d3024 1
a3024 7
      "tna",		4|SET_ARG,		textfields_activation_option,
      "turn on \"Textfields Need Activation\" mode"
   ),
#endif
#ifndef NO_LYNX_TRACE
   PARSE_SET(
      "trace",		2|SET_ARG,		WWW_TraceFlag,
a3026 5
   PARSE_INT(
      "trace_mask",	2|INT_ARG,		WWW_TraceMask,
      "customize Lynx trace mode"
   ),
#endif
d3028 1
a3028 1
      "traversal",	4|FUNCTION_ARG,		traversal_fun,
d3032 1
a3032 9
      "trim_input_fields", 2|SET_ARG,		LYtrimInputFields,
      "trim input text/textarea fields in forms"
   ),
   PARSE_SET(
      "underline_links",4|TOGGLE_ARG,		LYUnderlineLinks,
      "toggles use of underline/bold attribute for links"
   ),
   PARSE_SET(
      "underscore",	4|TOGGLE_ARG,		use_underscore,
d3035 1
a3035 1
#if defined(USE_MOUSE)
d3037 2
a3038 2
      "use_mouse",	4|SET_ARG,		LYUseMouse,
      "turn on mouse support"
d3042 1
a3042 1
      "useragent",	4|NEED_LYSTRING_ARG,	LYUserAgent,
d3046 2
a3047 2
      "validate",	2|SET_ARG,		LYValidate,
      "accept only http URLs (meant for validation)\nimplies more restrictions than -anonymous, but\ngoto is allowed for http and https"
d3050 1
a3050 1
      "verbose",	4|TOGGLE_ARG,		verbose_img,
d3054 1
a3054 1
      "version",	4|FUNCTION_ARG,		version_fun,
d3058 1
a3058 1
      "vikeys",		4|SET_ARG,		vi_keys,
a3060 6
#ifdef __DJGPP__
   PARSE_SET(
      "wdebug",		4|TOGGLE_ARG,		watt_debug,
      "enables Waterloo tcp/ip packet debug. Prints to watt\ndebugfile"
  ),
#endif /* __DJGPP__ */
d3062 1
a3062 1
      "width",		4|NEED_FUNCTION_ARG,	width_fun,
d3065 1
a3065 7
#ifndef NO_DUMP_WITH_BACKSPACES
   PARSE_SET(
      "with_backspaces", 4|SET_ARG,		with_backspaces,
      "emit backspaces in output if -dumping or -crawling\n(like 'man' does)"
   ),
#endif
   PARSE_NIL
a3066 1
/* *INDENT-ON* */
d3068 4
a3071 4
static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       BOOLEAN option)
d3078 1
a3078 1
    pad = field_width - (2 + option + (int) strlen(name));
d3080 1
a3080 1
    fprintf(stdout, "  %s%s", option ? "-" : "", name);
d3085 1
a3085 1
	    fputc(' ', stdout);
d3088 1
a3088 1
	fputc(' ', stdout);	/* at least one space */
d3094 2
a3095 2
    if (strchr(help, '\n') == 0) {
	fprintf(stdout, "%s", help);
d3104 1
a3104 1
		fputc(c, stdout);
d3106 1
a3106 1
		    fputc(' ', stdout);
d3108 1
a3108 1
		fputc(c, stdout);
d3116 1
a3116 1
    fputc('\n', stdout);
d3119 1
a3119 1
static void print_help_and_exit(int exit_status)
d3121 1
a3121 1
    Config_Type *p;
d3123 1
a3123 2
    if (pgm == NULL)
	pgm = "lynx";
d3125 1
a3125 1
    SetOutputMode(O_TEXT);
d3127 2
a3128 3
    fprintf(stdout, gettext("USAGE: %s [options] [file]\n"), pgm);
    fprintf(stdout, gettext("Options are:\n"));
#ifdef VMS
d3130 2
a3131 5
		       "receive the arguments from stdin (enclose\n\
in double-quotes (\"-\") on VMS)", NULL, TRUE);
#else
    print_help_strings("", "receive options and arguments from stdin", NULL, TRUE);
#endif /* VMS */
d3135 5
a3139 2
	ParseUnionPtr q = ParseUnionOf(p);

d3141 16
a3156 16
	case TOGGLE_ARG:
	case SET_ARG:
	    strcpy(temp, *(q->set_value) ? "on" : "off");
	    break;
	case UNSET_ARG:
	    strcpy(temp, *(q->set_value) ? "off" : "on");
	    break;
	case INT_ARG:
	    sprintf(temp, "%d", *(q->int_value));
	    break;
	case TIME_ARG:
	    sprintf(temp, SECS_FMT, (double) Secs2SECS(*(q->int_value)));
	    break;
	case STRING_ARG:
	    if ((value = *(q->str_value)) != 0
		&& !*value)
d3158 1
a3158 4
	    break;
	default:
	    value = 0;
	    break;
d3160 1
a3160 1
	print_help_strings(p->name, p->help_string, value, TRUE);
d3163 1
a3163 1
    SetOutputMode(O_BINARY);
d3165 1
a3165 1
    exit_immediately(exit_status);
d3176 4
a3179 3
static int arg_eqs_parse(const char *a,
			 char *b,
			 char **c)
a3180 2
    int result = -1;

d3182 1
a3182 1
    while (result < 0) {
d3184 2
a3185 2
	    || (*a == 0)
	    || (*b == 0)) {
a3187 5
		case '\t':	/* embedded blank when reading stdin */
		case ' ':
		    *c = LYSkipBlanks(b);
		    result = 1;
		    break;
a3188 1
		case ':':
d3190 2
a3191 10
		    result = 1;
		    break;
		case '-':
#if OPTNAME_ALLOW_DASHES
		    if (isalpha(UCH(b[1]))) {
			result = 0;
			break;
		    }
#endif
		    /* FALLTHRU */
d3194 1
a3194 2
		    result = 1;
		    break;
d3196 1
a3196 2
		    result = 1;
		    break;
d3198 1
a3198 2
		    result = 0;
		    break;
d3201 1
a3201 4
#if OPTNAME_ALLOW_DASHES
		if (!(*a == '_' && *b == '-'))
#endif
		    result = 0;
d3206 1
a3206 2
    }
    return result;
d3212 3
a3214 11
/*
 * Parse an option.
 *	argv[] points to the beginning of the unprocessed options.
 *	mask is used to select certain options which must be processed
 *		before others.
 *	countp (if nonnull) points to an index into argv[], which is updated
 *		to reflect option values which are also parsed.
 */
static BOOL parse_arg(char **argv,
		      unsigned mask,
		      int *countp)
d3216 1
a3216 1
    Config_Type *p;
a3218 4
#if EXTENDED_STARTFILE_RECALL
    static BOOLEAN no_options_further = FALSE;	/* set to TRUE after '--' argument */
#endif

a3219 12
    CTRACE((tfp, "parse_arg(arg_name=%s, mask=%d, count=%d)\n",
	    arg_name, mask, countp ? *countp : -1));

#if EXTENDED_STARTFILE_RECALL
    if (mask == ((countp != 0) ? 0 : 1)) {
	no_options_further = FALSE;
	/* want to reset nonoption when beginning scan for --stdin */
	if (nonoption != 0) {
	    FREE(nonoption);
	}
    }
#endif
d3222 1
a3222 1
     * Check for a command line startfile.  - FM
d3224 4
a3227 18
    if (*arg_name != '-'
#if EXTENDED_OPTION_LOGIC
	|| no_options_further == TRUE
#endif
	) {
#if EXTENDED_STARTFILE_RECALL
	/*
	 * On the last pass (mask==4), check for cases where we may want to
	 * provide G)oto history for multiple startfiles.
	 */
	if (mask == 4) {
	    if (nonoption != 0) {
		LYEnsureAbsoluteURL(&nonoption, "NONOPTION", FALSE);
		HTAddGotoURL(nonoption);
		FREE(nonoption);
	    }
	    StrAllocCopy(nonoption, arg_name);
	}
d3229 1
d3232 1
a3232 13
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 20:11:17 */
	HTUnEscape(startfile);
	{
	    char *q = startfile;

	    while (*q++) {
		if (*q == '|')
		    *q = ':';
	    }
	}
#endif
	CTRACE((tfp, "parse_arg startfile:%s\n", startfile));
	return (BOOL) (countp != 0);
d3235 1
a3235 1
    if (strcmp(arg_name, "--") == 0) {
d3237 1
a3237 1
	return TRUE;
d3245 3
a3247 2
     * Skip any lone "-" arguments, because we've loaded the stdin input into
     * an HTList structure for special handling.  - FM
d3250 1
a3250 1
	return TRUE;
d3252 2
a3253 3
    /* allow GNU-style options with -- prefix */
    if (*arg_name == '-')
	++arg_name;
a3254 1
    CTRACE((tfp, "parse_arg lookup(%s)\n", arg_name));
d3258 5
a3262 1
	ParseUnionPtr q = ParseUnionOf(p);
a3264 1
	char *temp_ptr = NULL;
d3267 1
a3267 1
	    || (0 == arg_eqs_parse(p->name, arg_name, &next_arg))) {
d3272 4
a3275 13
	if (p->type & NEED_NEXT_ARG) {
	    if (next_arg == 0) {
		next_arg = argv[1];
		if ((countp != 0) && (next_arg != 0))
		    (*countp)++;
	    }
	    CTRACE((tfp, "...arg:%s\n", NONNULL(next_arg)));
	}

	/* ignore option if it's not our turn */
	if ((p->type & mask) == 0) {
	    CTRACE((tfp, "...skip (mask %d/%d)\n", mask, p->type & 7));
	    return FALSE;
d3282 2
a3283 2
	    if (q->set_value != 0) {
		if (next_arg == 0) {
d3286 2
a3287 2
			*(q->set_value) = (BOOL) !(*(q->set_value));
			break;
d3289 2
a3290 2
			*(q->set_value) = TRUE;
			break;
d3292 2
a3293 2
			*(q->set_value) = FALSE;
			break;
d3295 8
a3302 8
		} else if (is_true(next_arg)) {
		    *(q->set_value) = TRUE;
		} else if (is_false(next_arg)) {
		    *(q->set_value) = FALSE;
		}
		/* deliberately ignore anything else - BL */
	    }
	    break;
d3305 6
a3310 6
	    fun = q->fun_value;
	    if (0 != fun) {
		if (-1 == (*fun) (next_arg)) {
		}
	    }
	    break;
d3313 3
a3315 3
	    if ((q->str_value != 0) && (next_arg != 0))
		StrAllocCopy(*(q->str_value), next_arg);
	    break;
d3318 3
a3320 13
	    if ((q->int_value != 0) && (next_arg != 0))
		*(q->int_value) = strtol(next_arg, &temp_ptr, 0);
	    break;

	case TIME_ARG:
	    if ((q->int_value != 0) && (next_arg != 0)) {
		float ival;

		if (1 == sscanf(next_arg, "%f", &ival)) {
		    *(q->int_value) = (int) SECS2Secs(ival);
		}
	    }
	    break;
d3323 1
a3323 1
	    if ((q->str_value != 0) && (next_arg != 0))
d3325 4
a3328 1
	    break;
d3331 1
a3331 2
	Old_DTD = DTD_recovery;	/* BOOL != int */
	return TRUE;
d3334 1
a3334 2
    if (pgm == 0)
	pgm = "LYNX";
d3336 2
a3337 3
    fprintf(stderr, gettext("%s: Invalid Option: %s\n"), pgm, argv[0]);
    print_help_and_exit(-1);
    return FALSE;
d3341 2
a3342 1
static void FatalProblem(int sig)
d3345 1
a3345 1
     * Ignore further interrupts.  - mhc:  11/2/91
d3350 2
a3351 2
    (void) signal(SIGTERM, SIG_IGN);
    (void) signal(SIGINT, SIG_IGN);
d3361 1
a3361 1
     * Flush all messages.  - FM
d3367 1
a3367 1
     * Deal with curses, if on, and clean up.  - FM
d3370 1
a3370 1
	LYSleepAlert();
d3382 1
a3382 1
     * Issue appropriate messages and abort or exit.  - FM
d3385 1
a3385 1
	fprintf(stderr, "\r\n\
d3395 1
a3395 2
	if (!(sig == 0 && LYNoCore)) {
	    fprintf(stderr, "\r\n\
d3397 2
a3398 3
	}
	if (sig != 0) {
	    fprintf(stderr, "\r\n\
a3399 25
#ifdef WIN_EX			/* 1998/08/09 (Sun) 09:58:25 */
	    {
		char *msg;

		switch (sig) {
		case SIGABRT:
		    msg = "SIGABRT";
		    break;
		case SIGFPE:
		    msg = "SIGFPE";
		    break;
		case SIGILL:
		    msg = "SIGILL";
		    break;
		case SIGSEGV:
		    msg = "SIGSEGV";
		    break;
		default:
		    msg = "Not-def";
		    break;
		}
		fprintf(stderr, "signal code = %s\n", msg);
	    }
#endif
	}
d3402 1
a3402 1
	 * Exit and possibly dump core.
d3405 1
a3405 1
	    exit_immediately(EXIT_FAILURE);
d3415 1
a3415 1
	 * Exit without dumping core.
d3417 1
a3417 1
	exit_immediately(EXIT_SUCCESS);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a9 1
#include <HTAlert.h>
a14 1
#include <LYOptions.h>
a29 5
#include <LYShowInfo.h>

#ifdef VMS
#include <HTFTP.h>
#endif /* !DECNET */
a33 3
#include <io.h>
#include <sys/stat.h>
#include <sys/exceptn.h>
d40 6
a58 1
#define TRACE_FILE "LY-TRACE.LOG"
a60 1
#define TRACE_FILE "Lynx.trace"
d76 1
a76 1
#if USE_VMS_MAILER
a77 3
#endif

#ifdef VMS
d90 4
d97 1
a98 4
PUBLIC int LYAutoUncacheDirLists = 2; /* default dired uncaching behavior */
PUBLIC int dir_list_order = ORDER_BY_NAME;
PUBLIC int dir_list_style = MIXED_STYLE;

a101 1

a108 1

d142 1
a142 1
PUBLIC lynx_list_item_type *printers = NULL;
d144 1
a144 1
PUBLIC lynx_list_item_type *downloaders = NULL;
d147 1
a147 1
PUBLIC lynx_list_item_type *externals = NULL;
d150 1
a150 2

PUBLIC lynx_list_item_type *uploaders = NULL;
d152 3
a154 3
PUBLIC int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not */
PUBLIC int LYrcShowColor = SHOW_COLOR_UNKNOWN; /* ... last used */

a157 4

PUBLIC BOOLEAN LYJumpFileURL = FALSE;	 /* always FALSE the first time */
PUBLIC BOOLEAN LYPermitURL = FALSE;
PUBLIC BOOLEAN LYRestricted = FALSE; /* whether we have -anonymous option */
d159 1
a160 2
PUBLIC BOOLEAN LYUserSpecifiedURL = TRUE;/* always TRUE  the first time */
PUBLIC BOOLEAN LYValidate = FALSE;
d162 1
a163 1
PUBLIC BOOLEAN LYoverride_no_cache = FALSE;/*override no-cache b/c history etc*/
d165 14
a178 1
PUBLIC BOOLEAN LYtrimInputFields = FALSE;
a179 1
PUBLIC BOOLEAN bold_headers = FALSE;
d181 2
a182 8
PUBLIC BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
PUBLIC BOOLEAN check_mail = CHECKMAIL;
PUBLIC BOOLEAN child_lynx = FALSE;
PUBLIC BOOLEAN dump_output_immediately = FALSE;
PUBLIC BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
PUBLIC BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
PUBLIC BOOLEAN ftp_passive = FTP_PASSIVE; /* TRUE if doing ftp in passive mode */
PUBLIC BOOLEAN goto_buffer = GOTOBUFFER; /* TRUE if offering default goto URL */
a183 3
PUBLIC BOOLEAN is_www_index = FALSE;
PUBLIC BOOLEAN jump_buffer = JUMPBUFFER; /* TRUE if offering default shortcut */
PUBLIC BOOLEAN lynx_mode = NORMAL_LYNX_MODE;
a184 4
PUBLIC BOOLEAN nolist = FALSE;
PUBLIC BOOLEAN number_fields_on_left = TRUE;
PUBLIC BOOLEAN number_links_on_left = TRUE;
PUBLIC BOOLEAN recent_sizechange = FALSE;/* the window size changed recently? */
d186 6
a191 2
PUBLIC BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
PUBLIC BOOLEAN verbose_img = VERBOSE_IMAGES;  /* show filenames or not */
d193 1
d195 1
a195 2
PUBLIC int user_mode = NOVICE_MODE;

a200 1
PUBLIC BOOLEAN long_url_ok = FALSE;
d203 17
a219 5

PUBLIC BOOLEAN had_restrictions_default = FALSE;
PUBLIC BOOLEAN had_restrictions_all = FALSE;

PUBLIC BOOLEAN exec_frozen = FALSE;
d221 1
d223 3
a225 1
PUBLIC BOOLEAN no_chdir = FALSE;
a226 3
PUBLIC BOOLEAN no_dotfiles = NO_DOT_FILES;
PUBLIC BOOLEAN no_download = FALSE;
PUBLIC BOOLEAN no_editor = FALSE;
d228 2
a229 1
PUBLIC BOOLEAN no_file_url = FALSE;
a230 1
PUBLIC BOOLEAN no_goto_configinfo = FALSE;
d242 4
d247 3
a252 3
PUBLIC BOOLEAN no_inside_ftp = FALSE;
PUBLIC BOOLEAN no_inside_rlogin = FALSE;
PUBLIC BOOLEAN no_inside_telnet = FALSE;
d254 1
a254 14
PUBLIC BOOLEAN no_lynxcfg_info = FALSE;
PUBLIC BOOLEAN no_lynxcgi = FALSE;
PUBLIC BOOLEAN no_mail = FALSE;
PUBLIC BOOLEAN no_multibook = FALSE;
PUBLIC BOOLEAN no_option_save = FALSE;
PUBLIC BOOLEAN no_outside_ftp = FALSE;
PUBLIC BOOLEAN no_outside_rlogin = FALSE;
PUBLIC BOOLEAN no_outside_telnet = FALSE;
PUBLIC BOOLEAN no_print = FALSE;
PUBLIC BOOLEAN no_shell = FALSE;
PUBLIC BOOLEAN no_suspend = FALSE;
PUBLIC BOOLEAN no_telnet_port = FALSE;
PUBLIC BOOLEAN no_useragent = FALSE;

a255 4
PUBLIC BOOLEAN no_goto_news = FALSE;
PUBLIC BOOLEAN no_goto_nntp = FALSE;
PUBLIC BOOLEAN no_goto_snews = FALSE;
PUBLIC BOOLEAN no_inside_news = FALSE;
a256 1
PUBLIC BOOLEAN no_outside_news = FALSE;
d258 3
a260 12

#ifdef USE_EXTERNALS
PUBLIC BOOLEAN no_externals = FALSE;
#endif

#ifndef NO_CONFIG_INFO
PUBLIC BOOLEAN no_lynxcfg_xinfo = FALSE;
#ifdef HAVE_CONFIG_H
PUBLIC BOOLEAN no_compileopts_info = FALSE;
#endif
#endif

d262 1
a262 2
PUBLIC BOOLEAN no_filereferer = TRUE;
PUBLIC char LYRefererWithQuery = 'D';	/* 'D' for drop */
d265 1
a265 1
PUBLIC BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
d267 53
a319 40
PUBLIC BOOLEAN LYfind_leaks = TRUE;

#ifdef __DJGPP__
PUBLIC BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
#endif /* __DJGPP__ */

#ifdef WIN_EX
PUBLIC BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
PUBLIC char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
#endif

#ifdef _WINDOWS
#define	TIMEOUT	180			/* 1998/03/30 (Mon) 14:50:44 */
PUBLIC int lynx_timeout = TIMEOUT;
PUBLIC CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
PUBLIC CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
#endif /* _WINDOWS */

#if defined(WIN_EX)
PUBLIC BOOLEAN system_is_NT = FALSE;
#endif

#ifdef SH_EX
PUBLIC BOOLEAN show_cfg = FALSE;
#endif

PUBLIC BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */

#if USE_BLAT_MAILER
PUBLIC BOOLEAN mail_is_blat = TRUE;
#endif

#ifdef USE_BLINK
#  ifdef __EMX__
PUBLIC BOOLEAN term_blink_is_boldbg = TRUE;
#  else
PUBLIC BOOLEAN term_blink_is_boldbg = FALSE;
#  endif
#endif

d321 2
a322 3
PUBLIC BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
PUBLIC BOOLEAN LYCancelledFetch = FALSE;/* TRUE if cancelled binary fetch */
PUBLIC BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
a323 11
PUBLIC BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
PUBLIC BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
PUBLIC BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
PUBLIC BOOLEAN LYNewsPosting = NEWS_POSTING; /* News posting supported? */
PUBLIC BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
PUBLIC BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
PUBLIC BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
PUBLIC BOOLEAN LYRawMode;
PUBLIC BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
PUBLIC BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
PUBLIC BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
d325 17
d343 5
d349 2
a350 12
PUBLIC BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
PUBLIC BOOLEAN UCSaveBookmarksInUnicode = FALSE;
PUBLIC BOOLEAN bookmark_start = FALSE;
PUBLIC BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
PUBLIC BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
PUBLIC BOOLEAN crawl = FALSE;		/* Do crawl? */
PUBLIC BOOLEAN keep_mime_headers = FALSE; /* Include mime headers with source dump */
PUBLIC BOOLEAN more = FALSE;		/* is there more text to display? */
PUBLIC BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
PUBLIC BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
PUBLIC BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
PUBLIC BOOLEAN scan_for_buried_news_references = TRUE;
d352 9
a360 3
PUBLIC BOOLEAN startfile_stdin = FALSE;
PUBLIC BOOLEAN traversal = FALSE;	/* Do traversals? */
PUBLIC char *BookmarkPage = NULL;	/* the name of the current bookmark page */
d362 2
a365 1
PUBLIC char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
d367 2
a370 72
PUBLIC char *LYCookieSRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieSStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYHostName = NULL;		/* treat as a local host name */
PUBLIC char *LYLocalDomain = NULL;	/* treat as a local domain tail */
PUBLIC char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
PUBLIC char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
PUBLIC char *LynxHome = NULL;		/* the default Home HREF. */
PUBLIC char *LynxSigFile = NULL;	/* Signature file, in or off home */
PUBLIC char *UCAssume_MIMEcharset = NULL;
PUBLIC char *URLDomainPrefixes = NULL;
PUBLIC char *URLDomainSuffixes = NULL;
PUBLIC char *authentication_info[2] = {NULL, NULL}; /* Id:Password for protected documents */
PUBLIC char *bookmark_page = NULL;	/* the name of the default bookmark page */
PUBLIC char *editor = NULL;		/* the name of the current editor */
PUBLIC char *form_get_data = NULL;	/* User data for get form */
PUBLIC char *form_post_data = NULL;	/* User data for post form */
PUBLIC char *global_extension_map = NULL;  /* global mime.types */
PUBLIC char *global_type_map = NULL;	/* global mailcap */
PUBLIC char *helpfile = NULL;		/* the main help file */
PUBLIC char *helpfilepath = NULL;	/* the path to the help file set */
PUBLIC char *homepage = NULL;		/* home page or main screen */
PUBLIC char *http_error_file = NULL;	/* Place HTTP status code in this file */
PUBLIC char *indexfile = NULL;		/* an index file if there is one */
PUBLIC char *jumpfile = NULL;		/* the name of the default jumps file */
PUBLIC char *jumpprompt = NULL;		/* the default jumps prompt */
PUBLIC char *language = NULL;		/* preferred language */
PUBLIC char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
PUBLIC char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
PUBLIC char *lynx_cmd_script;		/* file to read keystroke commands, if any */
PUBLIC char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
PUBLIC char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
PUBLIC char *lynxjumpfile = NULL;	/* the current jump file URL */
PUBLIC char *lynxlinksfile = NULL;	/* the current visited links file URL */
PUBLIC char *lynxlistfile = NULL;	/* the current list file URL */
PUBLIC char *original_dir = NULL;	/* the original directory */
PUBLIC char *personal_extension_map = NULL;/* .mime.types */
PUBLIC char *personal_mail_address = NULL; /* the users mail address */
PUBLIC char *personal_type_map = NULL;	   /* .mailcap */
PUBLIC char *pref_charset = NULL;	/* preferred character set */
PUBLIC char *proxyauth_info[2] = {NULL, NULL}; /* Id:Password for protected proxy servers */
PUBLIC char *startfile = NULL;		/* the first file */
PUBLIC char *startrealm = NULL;		/* the startfile realm */
PUBLIC char *system_mail = NULL;	/* The path for sending mail */
PUBLIC char *system_mail_flags = NULL;	/* Flags for sending mail */
PUBLIC char *x_display = NULL;		/* display environment variable */
PUBLIC HistInfo history[MAXHIST];
PUBLIC int AlertSecs;			/* time-delay for HTAlert() messages   */
PUBLIC int DebugSecs;			/* time-delay for HTProgress messages */
PUBLIC int InfoSecs;			/* time-delay for Information messages */
PUBLIC int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
PUBLIC int LYStatusLine = -1;		/* Line for statusline() if > -1 */
PUBLIC int LYcols = DFT_COLS;
PUBLIC int LYlines = DFT_ROWS;
PUBLIC int MessageSecs;			/* time-delay for important Messages   */
PUBLIC int ReplaySecs;			/* time-delay for command-scripts */
PUBLIC int ccount = 0;			/* Starting number for lnk#.dat files in crawls */
PUBLIC int dump_output_width = 0;
PUBLIC int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
PUBLIC int nhist = 0;			/* number of history entries */
PUBLIC int nlinks = 0;			/* number of links in memory */
PUBLIC int outgoing_mail_charset = -1;	/* translate mail to this charset */
PUBLIC LinkInfo links[MAXLINKS];

#ifndef DISABLE_BIBP
PUBLIC BOOLEAN BibP_bibhost_available = FALSE;  /* until check succeeds  */
PUBLIC BOOLEAN BibP_bibhost_checked = FALSE;  /*  until LYCheckBibHost   */
PUBLIC BOOLEAN no_goto_bibp = FALSE;
PUBLIC char *BibP_bibhost = NULL;	 /* local server for bibp: links  */
PUBLIC char *BibP_globalserver = NULL;   /* global server for bibp: links */
#endif

d372 2
a373 3
PUBLIC BOOLEAN persistent_cookies = FALSE; /* disabled by default! */
PUBLIC char *LYCookieFile = NULL;	/* cookie read file */
PUBLIC char *LYCookieSaveFile = NULL;	/* cookie save file */
a374 14

#ifdef EXP_NESTED_TABLES
PUBLIC BOOLEAN nested_tables =
#if defined(USE_COLOR_STYLE)
    TRUE
#else
    FALSE				/* see 2001-08-15  */
#endif
    ;
#endif

PUBLIC BOOLEAN LYShowTransferRate = TRUE;
PUBLIC int LYTransferRate = rateEtaKB_maybe;

d379 1
a379 4
PUBLIC int Old_DTD = NO;
PRIVATE BOOL DTD_recovery = NO;

#ifndef NO_LYNX_TRACE
a380 1
#endif
a382 1

d385 1
d389 1
a389 1
PUBLIC BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
a392 31
PUBLIC BOOLEAN dont_wrap_pre = FALSE;

PUBLIC int cookie_noprompt;

#ifdef USE_SSL
PUBLIC int ssl_noprompt = FORCE_PROMPT_DFT;
#endif

PUBLIC int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/

#ifdef EXP_JUSTIFY_ELTS
PUBLIC BOOL ok_justify = TRUE;
PUBLIC int justify_max_void_percent = 35;
#endif

#ifndef NO_DUMP_WITH_BACKSPACES
PUBLIC BOOLEAN with_backspaces = FALSE;
#endif

PUBLIC BOOL force_empty_hrefless_a = FALSE;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
PUBLIC BOOL textfields_need_activation = FALSE;
PUBLIC BOOL textfields_activation_option = FALSE;
#endif

PUBLIC BOOLEAN textfield_prompt_at_left_edge = FALSE;

#ifdef MARK_HIDDEN_LINKS
PUBLIC char* hidden_link_marker = NULL;
#endif
d400 5
a404 7
PUBLIC BOOLEAN LYNonRestartingSIGWINCH = FALSE;
PUBLIC BOOLEAN LYReuseTempfiles = FALSE;
PUBLIC BOOLEAN LYUseBuiltinSuffixes = TRUE;

#ifdef MISC_EXP
PUBLIC int LYNoZapKey = 0; /* 0: off (do z checking), 1: full, 2: initially */
#endif
d407 2
a408 1
#include <HTNews.h>
a410 2
PUBLIC BOOLEAN FileInitAlreadyDone = FALSE;

a414 1
PRIVATE BOOLEAN number_fields = FALSE;
a422 12
#ifndef EXTENDED_STARTFILE_RECALL
/* if set then additional non-option args (before the last one) will be
   made available for 'g'oto recall - kw */
#define EXTENDED_STARTFILE_RECALL 1
#endif

#ifndef OPTNAME_ALLOW_DASHES
/* if set, then will allow dashes and underscores to be used interchangeable
   in commandline option's names - VH */
#define OPTNAME_ALLOW_DASHES 1
#endif

d427 3
a429 3
PRIVATE BOOL parse_arg PARAMS((char **arg, unsigned mask, int *i));
PRIVATE void print_help_and_exit PARAMS((int exit_status)) GCC_NORETURN;
PRIVATE void print_help_strings PARAMS((CONST char * name, CONST char * help, CONST char * value, BOOLEAN option));
a432 1
PUBLIC BOOLEAN restore_sigpipe_for_children = FALSE;
d436 2
a437 2
#if defined(USE_COLOR_STYLE)
PUBLIC char *lynx_lss_file = NULL;
d441 1
a441 1
PRIVATE void LY_set_ctrl_break(int setting)
a461 14
#if defined(WIN_EX)
PRIVATE int is_windows_nt(void)
{
    DWORD version;

    version = GetVersion();
    if ((version & 0x80000000) == 0)
	return 1;
    else
	return 0;
}
#endif


d480 2
a482 7
#ifndef VMS
    FREE(lynx_version_putenv_command);
#endif

#if USE_VMS_MAILER
    FREE(mail_adrs);
#endif
a504 4
#ifndef DISABLE_BIBP
    FREE(BibP_bibhost);
    FREE(BibP_globalserver);
#endif
a506 1
    FREE(LYCookieSaveFile);
d535 3
d541 1
a541 1
#if defined(USE_COLOR_STYLE)
d545 7
a551 1
    LYUIPages_free();
a555 1
    HTList_delete(LYcommandList());
d619 1
a619 1
PRIVATE void FixCharacters(void)
d637 2
a638 1
PRIVATE int argncmp ARGS2(
d643 1
a643 6
#if OPTNAME_ALLOW_DASHES
    return strncmp(str, what, strlen(what));
#else
    ++str; ++what; /*skip leading dash in both strings*/
    return !strn_dash_equ(str, what, strlen(what));
#endif
d646 3
a648 3
PRIVATE void tildeExpand ARGS2(
	char **,	pathname,
	BOOLEAN,	embedded)
d650 2
a651 26
    char *temp = *pathname;

    if (embedded) {
	if (temp != NULL) {
	    temp = strstr(*pathname, "/~");
	    if (temp != 0)
		temp++;
	    else
		temp = *pathname;
	}
    }

    if (temp != NULL
     && temp[0] == '~') {
	if (temp[1] == '/'
	 && temp[2] != '\0') {
	    temp = NULL;
	    StrAllocCopy(temp, *pathname + 2);
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	    LYAddPathSep(pathname);
	    StrAllocCat(*pathname, temp);
	    FREE(temp);
	} else if (temp[1] == '\0') {
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	}
    }
a653 27
PRIVATE BOOL GetStdin ARGS2(
	char **,	buf,
	BOOL,		marker)
{
    if (LYSafeGets(buf, stdin) != 0
     && (!marker || strncmp(*buf, "---", 3) != 0)) {
	LYTrimTrailing(*buf);
	CTRACE((tfp, "...data: %s\n", *buf));
	return TRUE;
    }
    CTRACE((tfp, "...mark: %s\n", *buf ? *buf : ""));
    return FALSE;
}

#ifdef WIN32
PRIVATE BOOL cleanup_win32(DWORD fdwCtrlType)
{
    switch (fdwCtrlType) {
    case CTRL_CLOSE_EVENT:
	cleanup_sig(-1);
	return TRUE;
    default:
	return FALSE;
    }
}
#endif

a665 1
    struct stat dir_info;
a667 7
#ifdef _WINDOWS
    WSADATA WSAData;
#endif /* _WINDOWS */
#ifdef USE_SSL
    char SSLLibraryVersion[256];
    char *SSLcp;
#endif /* USE_SSL */
d669 5
a673 7
    /*
     * Just in case someone has the idea to install lynx set-uid, let's try
     * to discourage it.
     */
#if defined(GETUID) && defined(SETUID)
    setuid(getuid());
#endif
a678 4
#ifdef EXP_CHARSET_CHOICE
    memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
#endif

d680 1
d685 1
a685 1
	wVerReq = MAKEWORD(1, 1);
d692 1
a692 1
	    return 1;
a694 5

    /* 1998/09/03 (Thu) 22:02:32 */
    InitializeCriticalSection(&critSec_DNS);
    InitializeCriticalSection(&critSec_READ);

a696 19
#if 0 /* defined(__CYGWIN__) - does not work with screen */
    if (strcmp(ttyname(fileno(stdout)), "/dev/conout") != 0) {
	printf("please \"$CYGWIN=notty\"\n");
	exit(EXIT_SUCCESS);
    }
#endif

#if defined(WIN_EX)
    /* 1997/10/19 (Sun) 21:40:54 */
    system_is_NT = (BOOL) is_windows_nt();

    /* 1998/01/13 (Tue) 21:13:47 */
    GetWindowsDirectory(filename, sizeof filename);
    windows_drive[0] = filename[0];
    windows_drive[1] = filename[1];
    windows_drive[2] = '\0';
#endif


a703 2
    __djgpp_set_sigquit_key(0x082D); /* Bind ALT-X to SIGQUIT */
    signal(SIGQUIT, cleanup_sig);
d705 3
a707 1
#endif /* __DJGPP__ */
d719 1
a719 1
    if (LYGetEnv("TERM")==NULL) putenv("TERM=vt100");
d727 1
a727 2
    cp = NULL;
    if ((cp = LYLastPathSep(pgm)) != NULL) {
d736 1
a736 1
	    parse_arg(&argv[i], 1, &i);
a737 5
#ifdef SH_EX
	if (strncmp(argv[i], "-show_cfg", 9) == 0) {
	    show_cfg = TRUE;
	}
#endif
d760 1
a760 1
#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
d762 1
a762 3
    if ((cp = LYGetEnv("LYNX_LOCALEDIR")) == 0)
	cp = LOCALEDIR;
    bindtextdomain ("lynx", cp);
d774 1
a774 1
    terminal = LYGetEnv("TERM");
d781 2
a782 2
    memset((void *)links, 0, sizeof(LinkInfo)*MAXLINKS);
    memset((void *)history, 0, sizeof(HistInfo)*MAXHIST);
d789 3
d794 3
a796 7

    AlertSecs	= SECS2Secs(ALERTSECS);
    DebugSecs	= SECS2Secs(DEBUGSECS);
    InfoSecs	= SECS2Secs(INFOSECS);
    MessageSecs	= SECS2Secs(MESSAGESECS);
    ReplaySecs	= SECS2Secs(REPLAYSECS);

d799 1
a799 1
    LYEscapeStartfile(&startfile);
a807 1
#ifdef SYSTEM_MAIL_FLAGS
a808 3
#else
    StrAllocCopy(system_mail_flags, "");
#endif
a815 14
#ifdef USE_SSL
    StrAllocCat(LYUserAgent, " SSL-MM/1.4.1");
#ifdef OPENSSL_VERSION_TEXT
    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = '/';
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    StrAllocCat(LYUserAgent, " ");
	    StrAllocCat(LYUserAgent, SSLLibraryVersion);
	}
    }
#endif /* OPENSSL_VERSION_TEXT */
#endif /* USE_SSL */
d828 1
a828 1
    if ((cp = LYGetEnv("LYNX_TEMP_SPACE")) != NULL)
d830 2
a831 2
#if defined (UNIX) || defined (__DJGPP__)
    else if ((cp = LYGetEnv("TMPDIR")) != NULL)
d835 4
a838 4
    else if ((cp = LYGetEnv("TEMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
    else if ((cp = LYGetEnv("TMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
d846 1
a846 1
	exit(EXIT_FAILURE);
d850 9
a858 5
#ifdef WIN_EX	/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
    if (access(lynx_temp_space, 0) != 0)
#endif
	tildeExpand(&lynx_temp_space, TRUE);

d862 1
a862 1
	if ((cp1 = LYGetEnv("USER")) != NULL) {
d873 2
a874 1

a892 1
    StrAllocCopy(lynx_temp_space, HTSYS_name(lynx_temp_space));
d894 1
a894 17

    if ((HTStat(lynx_temp_space, &dir_info) < 0
#if defined(MULTI_USER_UNIX)
	&& mkdir(lynx_temp_space, 0700) < 0
#endif
	)
     || !S_ISDIR(dir_info.st_mode)) {
	fprintf(stderr, "%s: %s\n",
		lynx_temp_space,
		gettext("No such directory"));
	exit_immediately(EXIT_FAILURE);
    }

#if USE_VMS_MAILER
#ifndef MAIL_ADRS
#define MAIL_ADRS "\"IN%%\"\"%s\"\"\""
#endif
d896 4
a899 2
#endif

a904 1

a909 5
#ifndef DISABLE_BIBP
    StrAllocCopy(BibP_globalserver, BIBP_GLOBAL_SERVER);
    StrAllocCopy(BibP_bibhost, "http://bibhost/");  /* protocol specified. */
#endif

d917 1
a917 1
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
d927 40
a966 4
#ifndef NO_LYNX_TRACE
    if (LYGetEnv("LYNX_TRACE") != 0) {
	WWW_TraceFlag = TRUE;
    }
d968 1
a968 2
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 2, &i);
d983 1
a983 1
     *	-post_data, the data are terminated by a "---" string, alone
a988 1
	    break;
d994 110
a1103 7
	CTRACE((tfp, "processing stdin arguments\n"));
	while (GetStdin(&buf, TRUE)) {
	    char *noargv[2];

	    noargv[0] = buf;
	    noargv[1] = NULL;
	    LYTrimTrailing(buf);
d1105 18
a1122 2
	    if (parse_arg(&noargv[0], 2, (int *)0) == FALSE
	     &&  buf[0] != '\0') {
a1132 3
		CTRACE((tfp, "...StdinArg:%s\n", argument));
	    } else {
		CTRACE((tfp, "...complete:%s\n", buf));
a1134 1
	CTRACE((tfp, "...done with stdin arguments\n"));
d1159 1
a1159 1
	strlen(ANONYMOUS_USER) > 0 &&
d1161 2
a1162 2
	!strcasecomp((LYGetEnv("USER")==NULL ? " " : LYGetEnv("USER")),
		     ANONYMOUS_USER)
d1164 2
a1165 2
#ifdef HAVE_CUSERID
	STREQ((char *)cuserid((char *) NULL), ANONYMOUS_USER)
d1167 1
a1167 1
	STREQ(((char *)getlogin()==NULL ? " " : getlogin()), ANONYMOUS_USER)
d1170 1
a1170 1
	) {
d1179 1
a1179 4
    if ((cp = LYGetEnv("LYNX_TRACE_FILE")) == 0)
	cp = TRACE_FILE;
    LYAddPathToHome(LYTraceLogPath = malloc(LY_MAXPATH), LY_MAXPATH, cp);

a1181 17
#ifdef EXP_CMD_LOGGING
    /*
     *	Open command-script, if specified
     */
    if (lynx_cmd_script != 0) {
	tildeExpand(&lynx_cmd_script, TRUE);
	LYOpenCmdScript();
    }
    /*
     *	Open command-logging, if specified
     */
    if (lynx_cmd_logfile != 0) {
	tildeExpand(&lynx_cmd_logfile, TRUE);
	LYOpenCmdLogfile(argc, argv);
    }
#endif

d1189 9
a1197 4
	temp = NULL;
	HTSprintf0(&temp, "JUMPFILE:%s", jumpfile);
	if (!LYJumpInit(temp)) {
	    CTRACE((tfp, "Failed to register %s\n", temp));
a1198 1
	FREE(temp);
d1207 2
a1208 2
	if (((cp=LYGetEnv("LYNX_CFG")) != NULL) ||
	    (cp=LYGetEnv("lynx_cfg")) != NULL)
d1219 3
d1223 12
a1234 1
    tildeExpand(&lynx_cfg_file, FALSE);
d1241 1
a1241 1
    if (!LYCanReadFile(lynx_cfg_file)) {
d1244 1
a1244 1
	exit(EXIT_FAILURE);
d1246 6
d1259 1
a1259 1
	exit(EXIT_FAILURE);
a1269 5
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (auto_display_charset >= 0)
	current_char_set = auto_display_charset;
    else
#endif
d1276 1
a1276 1
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d1283 1
a1283 1
	exit(EXIT_FAILURE);
d1286 1
a1286 1
#if defined(USE_COLOR_STYLE)
d1292 2
a1293 2
	if (((cp=LYGetEnv("LYNX_LSS")) != NULL) ||
	    (cp=LYGetEnv("lynx_lss")) != NULL)
d1304 16
a1319 2
    tildeExpand(&lynx_lss_file, TRUE);

d1324 1
a1324 1
    if (!LYCanReadFile(lynx_lss_file)) {
d1330 1
d1333 1
a1333 1
#endif /* USE_COLOR_STYLE */
d1335 1
a1335 1
#ifdef USE_COLOR_TABLE
d1346 1
a1346 1
	if ((cp = LYGetEnv("PWD")) != 0)
d1355 1
a1355 1
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename)-1);
d1360 1
a1360 1
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
d1362 1
a1362 1
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
d1365 1
a1365 1
#ifdef USE_PRETTYSRC
d1378 1
a1378 1
    read_rc(NULL);
d1383 1
a1383 1
    if ((cp = LYGetEnv("WWW_HOME")) != NULL) {
d1394 1
d1401 1
a1401 1
	parse_arg(&argv[i], 4, &i);
d1414 1
a1414 1
	    parse_arg(my_args, 4, (int *)0);
a1417 40
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    if (current_char_set == auto_display_charset) /* Better: explicit option */
	switch_display_charsets = 1;
#endif

#if defined (TTY_DEVICE) || defined(HAVE_TTYNAME)
    /*
     *	If we are told to read the startfile from standard input, do it now,
     *	after we have read all of the option data from standard input.
     */
    if (startfile_stdin) {
	char result[LY_MAXPATH];
	char *buf = NULL;
	char *tty = NULL;
# ifdef HAVE_TTYNAME
	tty = ttyname(fileno(stderr));
# endif
	if (tty == NULL)
	    tty = isatty(fileno(stdin)) ? TTY_DEVICE : NUL_DEVICE;

	CTRACE((tfp, "processing stdin startfile, tty=%s\n", tty));
	if ((fp = LYOpenTemp (result, HTML_SUFFIX, "w")) != 0) {
	    StrAllocCopy(startfile, result);
	    while (GetStdin(&buf, FALSE)) {
		fputs(buf, fp);
		fputc('\n', fp);
	    }
	    FREE(buf);
	    LYCloseTempFP(fp);
	}
	CTRACE((tfp, "...done stdin startfile\n"));
	if ((freopen(tty, "r", stdin)) == 0) {
	    CTRACE((tfp, "cannot open a terminal (%s)\n", tty));
	    if (!dump_output_immediately) {
		fprintf(stderr, "cannot open a terminal (%s)\n", tty);
		exit(1);
	    }
	}
    }
#endif
d1423 1
a1423 1
#ifdef USE_PRETTYSRC
a1437 2
     *
     * And to set LYCookieSaveFile. - BJP
d1441 1
a1441 1
	    LYAddPathToHome(LYCookieFile = malloc(LY_MAXPATH), LY_MAXPATH, COOKIE_FILE);
d1443 9
a1451 1
	    tildeExpand(&LYCookieFile, FALSE);
a1454 18

    /* tilde-expand LYCookieSaveFile */
    if (LYCookieSaveFile != NULL) {
	tildeExpand(&LYCookieSaveFile, FALSE);
    }

    /*
     * In dump_output_immediately mode, LYCookieSaveFile defaults to
     * /dev/null, otherwise it defaults to LYCookieFile.
     */

    if (LYCookieSaveFile == NULL) {
	if (dump_output_immediately) {
	    StrAllocCopy(LYCookieSaveFile, "/dev/null");
	} else {
	    StrAllocCopy(LYCookieSaveFile, LYCookieFile);
	}
    }
d1470 1
a1470 1
    if ((cp = LYGetEnv("LYNX_SAVE_SPACE")) != NULL)
d1480 9
a1488 1
	tildeExpand(&lynx_save_space, TRUE);
d1518 1
a1518 2
    if (!FileInitAlreadyDone)
	HTFileInit();
d1520 6
a1525 2
    if (!LYCheckUserAgent()) {
	HTAlwaysAlert(gettext("Warning:"), UA_NO_LYNX_WARNING);
d1527 2
a1528 6
#ifdef SH_EX
    if (show_cfg) {
	cleanup();
	exit(EXIT_SUCCESS);
    }
#endif
d1535 1
a1535 1
	       LYGetEnv("COLORTERM") != NULL) {
d1562 3
a1564 13
    if (crawl) {
	/* No numbered links by default, as documented
	   in CRAWL.announce. - kw */
	if (!number_links) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	}
    }

    if (!links_are_numbered()) {
	if (number_fields)
	    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
	if (number_links)
	    keypad_mode = LINKS_ARE_NUMBERED;
a1565 1
    }
d1571 4
a1574 1
	LYSelectPopups = !LYSelectPopups;
d1581 4
a1584 1
	LYShowCursor = !LYShowCursor;
d1603 1
a1603 1
	LYMultiBookmarks = MBM_OFF;
a1626 17
#if defined (__DJGPP__)
    if (watt_debug)
	dbug_init();
    sock_init();

    __system_flags =
	__system_emulate_chdir	      | /* handle `cd' internally */
	__system_handle_null_commands | /* ignore cmds with no effect */
	__system_allow_long_cmds      | /* handle commands > 126 chars	 */
	__system_use_shell	      | /* use $SHELL if set */
	__system_allow_multiple_cmds  | /* allow `cmd1; cmd2; ...' */
	__system_redirect;		/* redirect internally */

    /* This speeds up stat() tremendously */
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC |_STAT_DIRSIZE;
#endif  /* __DJGPP__ */

d1628 1
a1628 4
#ifdef WIN32
    SetConsoleCtrlHandler((PHANDLER_ROUTINE) cleanup_win32, TRUE);
#endif

a1629 1
    if (!dump_output_immediately)
a1631 1

d1634 1
a1634 1
    LYExtSignal(SIGWINCH, size_change);
d1656 1
a1656 2
	if (signal(SIGPIPE, SIG_IGN) != SIG_IGN)
	     restore_sigpipe_for_children = TRUE;
d1666 1
a1666 1
	(void) signal(SIGTSTP, SIG_IGN);
d1676 1
a1676 1
	exit_immediately(EXIT_FAILURE);
d1686 1
a1686 1
	exit_immediately(EXIT_FAILURE);
d1696 1
a1696 1
	exit_immediately(EXIT_FAILURE);
d1704 3
a1706 7
#ifdef USE_PRETTYSRC
    if (!dump_output_immediately) {
	HTMLSRC_init_caches(FALSE); /* do it before terminal is initialized*/
#ifdef LY_FIND_LEAKS
	atexit(html_src_clean_data);
#endif
    }
d1717 1
d1726 1
d1746 1
a1746 1
	telnet_ok = (BOOL)(!no_inside_telnet && !no_outside_telnet && telnet_ok);
d1748 1
a1748 1
	news_ok = (BOOL)(!no_inside_news && !no_outside_news && news_ok);
d1750 2
a1751 2
	ftp_ok = (BOOL)(!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
d1753 2
a1754 2
	CTRACE((tfp, "LYMain: User in Local domain\n"));
	telnet_ok = (BOOL)(!no_inside_telnet && telnet_ok);
d1756 1
a1756 1
	news_ok = (BOOL)(!no_inside_news && news_ok);
d1758 2
a1759 2
	ftp_ok = (BOOL)(!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && rlogin_ok);
d1762 2
a1763 2
	CTRACE((tfp, "LYMain: User in REMOTE domain\n"));
	telnet_ok = (BOOL)(!no_outside_telnet && telnet_ok);
d1765 1
a1765 1
	news_ok = (BOOL)(!no_outside_news && news_ok);
d1767 2
a1768 2
	ftp_ok = (BOOL)(!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_outside_rlogin && rlogin_ok);
d1776 5
a1780 4
	temp = NULL;
	HTSprintf0(&temp, "lynx_bookmarks%s", HTML_SUFFIX);
	set_default_bookmark_page(temp);
	FREE(temp);
d1783 3
a1785 1
	set_default_bookmark_page(bookmark_page);
a1787 4
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
    LYOpenlog (syslog_txt);
#endif

d1796 1
a1796 1
	if (crawl && !number_links && !number_fields) {
d1799 2
a1800 5
	    if (!links_are_numbered()) {
		if (number_fields)
		    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
		else
		    keypad_mode = LINKS_ARE_NUMBERED;
a1802 1

d1811 3
a1813 3
	    !crawl &&		/* For -crawl it has already been done! */
	    links_are_numbered())
	    printlist(stdout, FALSE);
d1821 1
a1821 1
	    LYStoreCookies(LYCookieSaveFile);
d1823 1
d1836 2
a1837 12
#ifndef NO_DUMP_WITH_BACKSPACES
	if (with_backspaces) {
	    /* we should warn about this somehow (nop for now) -VH */
	    with_backspaces = FALSE;
	}
#endif

#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
	init_charset_subsets();
#endif

	ena_csi((BOOLEAN)(LYlowest_eightbit[current_char_set] > 155));
d1839 1
a1839 2
	LYCloseCloset(RECALL_URL);
	LYCloseCloset(RECALL_MAIL);
d1850 1
a1850 1
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE, LYNXMESSAGES
a1856 1
extern GLOBALREF (HTProtocol, LYLynxStatusMessages);
a1861 1
GLOBALREF  HTProtocol LYLynxStatusMessages;
a1869 1
    HTRegisterProtocol(&LYLynxStatusMessages);
d1876 2
a1877 1
 *  to make things consistent.
a1879 10
 *
 *  Warning: experimental, more main() reorganization required.
 *	*Known* exceptions: persistent cookies, cookie files.
 *
 *	Some aspects of COLOR (with slang?).
 *	Viewer stuff, mailcap files
 *	SUFFIX, mime.types files
 *	RULESFILE/RULE
 *
 *	All work "somewhat", but not exactly as the first time.
d1883 1
a1883 20
    char *tempfile;
    FILE *rcfp;
    /*
     *  no_option_save is always set for -anonymous and -validate.
     *  It is better to check for one or several specific restriction
     *  flags than for 'LYRestricted', which doesn't get set for
     *  individual restrictions or for -validate!
     *  However, no_option_save may not be the appropriate one to
     *  check - in that case, a new no_something should be added
     *  that gets automatically set for -anonymous and -validate
     *  (and whether it applies for -anonymous can be made installer-
     *  configurable in the usual way at the bottom of userdefs.h). - kw
     *
     */
    if (no_option_save) {
	/* current logic requires(?) that saving user preferences is
	   possible.  Additional applicable restrictions are already
	   checked by caller. - kw */
	return;
    }
d1885 2
a1886 26
    /*
     *  Current user preferences are saved in a temporary file, to be
     *  read in again after lynx.cfg has been read.  This avoids
     *  accidental changing of the preferences file.  The regular
     *  preferences file doesn't even need to exist, and won't be
     *  created as a side effect of this function.  Honoring the
     *  no_option_save restriction may thus be unnecessarily restrictive,
     *  but the check is currently still left in place. - kw
     */
    tempfile = typecallocn(char, LY_MAXPATH);
    if (!tempfile) {
	HTAlwaysAlert(NULL, NOT_ENOUGH_MEMORY);
	return;
    }
    rcfp = LYOpenTemp(tempfile, ".rc" , "w");
    if (rcfp == NULL) {
	FREE(tempfile);
	HTAlwaysAlert(NULL, CANNOT_OPEN_TEMP);
	return;
    }
    if (!save_rc(rcfp)) {
	HTAlwaysAlert(NULL, OPTIONS_NOT_SAVED);
	LYRemoveTemp(tempfile);
	FREE(tempfile);
	return;    /* can not write the very own file :( */
    }
d1890 1
a1890 1
#ifdef EXP_PERSISTENT_COOKIES
d1892 1
a1892 21
	char * LYCookieFile_flag = NULL;
	char * LYCookieSaveFile_flag = NULL;
	if (persistent_cookies) {
	    StrAllocCopy(LYCookieFile_flag, LYCookieFile);
	    StrAllocCopy(LYCookieSaveFile_flag, LYCookieSaveFile);
	}
#endif

#ifdef EXP_CHARSET_CHOICE
	custom_assumed_doc_charset = FALSE;
	custom_display_charset = FALSE;
	memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
#endif

#ifdef USE_PRETTYSRC
	html_src_on_lynxcfg_reload();
#endif
	/* free downloaders, printers, environments, dired menu */
	free_lynx_cfg();
#ifdef SOURCE_CACHE
	source_cache_file_error = FALSE; /* reset flag */
d1895 1
d1902 1
a1902 1
	 *  Process the temporary RC file.
d1904 1
a1904 4
	rcfp = fopen(tempfile, "r");
	read_rc(rcfp);
	LYRemoveTemp(tempfile);
	FREE(tempfile);		/* done with it - kw */
a1905 3
#ifdef EXP_CHARSET_CHOICE
	init_charset_subsets();
#endif
a1923 5
	if (user_mode == NOVICE_MODE) {
	    display_lines = LYlines - 4;
	} else {
	    display_lines = LYlines - 2;
	}
d1928 1
a1928 1
#ifdef EXP_PERSISTENT_COOKIES
d1930 8
a1937 16
	if (persistent_cookies != persistent_cookies_flag) {
	    persistent_cookies = persistent_cookies_flag;
	    HTAlert(gettext("persistent cookies state will be changed in next session only."));
	}
	if (persistent_cookies) {
	    if (strcmp(LYCookieFile, LYCookieFile_flag)) {
		StrAllocCopy(LYCookieFile, LYCookieFile_flag);
		CTRACE((tfp, "cookie file can be changed in next session only, restored.\n"));
	    }
	    if (strcmp(LYCookieSaveFile, LYCookieSaveFile_flag)) {
		StrAllocCopy(LYCookieSaveFile, LYCookieSaveFile_flag);
		CTRACE((tfp, "cookie save file can be changed in next session only, restored.\n"));
	    }
	    FREE(LYCookieFile_flag);
	    FREE(LYCookieSaveFile_flag);
	}
a1943 15
PRIVATE void disable_pausing NOARGS
{
    AlertSecs = 0;
    DebugSecs = 0;
    InfoSecs = 0;
    MessageSecs = 0;
    ReplaySecs = 0;
}

PRIVATE void force_dump_mode NOARGS
{
    dump_output_immediately = TRUE;
    disable_pausing();
    LYcols = DFT_COLS;
}
d1955 29
a1983 5
#define PARSE_SET(n,t,v,h) {n,    t, UNION_SET(v), h}
#define PARSE_INT(n,t,v,h) {n,    t, UNION_INT(v), h}
#define PARSE_STR(n,t,v,h) {n,    t, UNION_STR(v), h}
#define PARSE_FUN(n,t,v,h) {n,    t, UNION_FUN(v), h}
#define PARSE_NIL          {NULL, 0, UNION_DEF(0), NULL}
d1989 10
a1998 11

#define TOGGLE_ARG		0x0010
#define SET_ARG			0x0020
#define UNSET_ARG		0x0030
#define FUNCTION_ARG		0x0040
#define LYSTRING_ARG		0x0050
#define INT_ARG			0x0060
#define STRING_ARG		0x0070
#define TIME_ARG		0x0080
#define ARG_TYPE_MASK		0x0FF0
#define NEED_NEXT_ARG		0x1000
a2000 1
#define NEED_TIME_ARG		(NEED_NEXT_ARG | TIME_ARG)
d2012 1
a2012 1
Config_Type;
d2015 1
a2015 1
PRIVATE int parse_authentication ARGS2(
d2047 1
a2047 1
PRIVATE int anonymous_fun ARGS1(
d2050 9
a2058 4
    if (!LYValidate && !LYRestricted)
	parse_restrictions("default");
    LYRestricted = TRUE;
    return 0;
d2062 1
a2062 1
PRIVATE int assume_charset_fun ARGS1(
d2076 1
a2076 1
PRIVATE int assume_local_charset_fun ARGS1(
d2084 1
a2084 1
PRIVATE int assume_unrec_charset_fun ARGS1(
d2092 1
a2092 1
PRIVATE int auth_fun ARGS1(
d2100 1
a2100 1
PRIVATE int base_fun ARGS1(
d2118 10
d2129 1
a2129 1
PRIVATE int cache_fun ARGS1(
d2143 1
a2143 1
PRIVATE int child_fun ARGS1(
d2153 1
a2153 1
PRIVATE int color_fun ARGS1(
a2164 44
#ifdef MISC_EXP
/* -convert_to */
PRIVATE int convert_to_fun ARGS1(
	char *,			next_arg)
{
    if (next_arg != 0) {
	char *outformat = NULL;
	char *cp1, *cp2, *cp4;
	int chndl;
	StrAllocCopy(outformat, next_arg);
	/* not lowercased, to allow for experimentation - kw */
	/*LYLowerCase(outformat);*/
	if ((cp1 = strchr(outformat, ';')) != NULL) {
	    if ((cp2 = LYstrstr(cp1, "charset")) != NULL) {
		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
		    cp2++;
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '\"' &&
				 *cp4 != ';'  &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
		*cp4 = '\0';
		/* This is intentionally not the "safe" version,
		   to allow for experimentation. */
		chndl = UCGetLYhndl_byMIME(cp2);
		if (chndl < 0) chndl = UCLYhndl_for_unrec;
		if (chndl < 0) {
		    fprintf(stderr,
		    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
		} else {
		    current_char_set = chndl;
		}
		*cp1 = '\0';	/* truncate outformat */
	    }
	}
	HTOutputFormat = HTAtom_for(outformat);
	FREE(outformat);
    } else {
	HTOutputFormat = NULL;
    }
    return 0;
}
#endif

d2166 1
a2166 1
PRIVATE int crawl_fun ARGS1(
d2170 1
a2170 1
    LYcols = DFT_COLS;
d2175 1
a2175 12
PRIVATE int display_fun ARGS1(
	char *,			next_arg)
{
    if (next_arg != 0) {
	LYsetXDisplay(next_arg);
    }

    return 0;
}

/* -display_charset */
PRIVATE int display_charset_fun ARGS1(
d2178 5
a2182 1
    int i = UCGetLYhndl_byMIME(next_arg);
a2183 10
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (i < 0 && !strcasecomp(next_arg, "auto"))
	i = auto_display_charset;
#endif
    if (i < 0) {	/* do nothing here: so fallback to lynx.cfg */
	fprintf(stderr,
		gettext("Lynx: ignoring unrecognized charset=%s\n"), next_arg);
    }
    else
	current_char_set = i;
d2188 1
a2188 1
PRIVATE int dump_output_fun ARGS1(
d2191 2
a2192 1
    force_dump_mode();
d2197 1
a2197 1
PRIVATE int editor_fun ARGS1(
d2207 1
a2207 1
PRIVATE int error_file_fun ARGS1(
d2221 1
a2221 1
PRIVATE int exec_fun ARGS1(
d2234 1
a2234 1
PRIVATE int get_data_fun ARGS1(
d2251 2
a2252 1
    force_dump_mode();
d2262 8
a2269 1
    while (GetStdin(&buf, TRUE)) {
d2277 1
a2277 1
PRIVATE int help_fun ARGS1(
d2285 1
a2285 1
PRIVATE int hiddenlinks_fun ARGS1(
a2287 7
    static Config_Enum table[] = {
	{ "merge",	HIDDENLINKS_MERGE },
	{ "listonly",	HIDDENLINKS_SEPARATE },
	{ "ignore",	HIDDENLINKS_IGNORE },
	{ NULL,		-1 },
    };

d2289 7
a2295 1
	if (!LYgetEnum(table, next_arg, &LYHiddenLinks))
d2305 1
a2305 1
PRIVATE int homepage_fun ARGS1(
d2316 1
a2316 1
PRIVATE int mime_header_fun ARGS1(
d2323 1
a2323 1
    force_dump_mode();
d2326 1
a2326 1
    LYcols = MAX_COLS;
d2332 1
a2332 1
PRIVATE int newschunksize_fun ARGS1(
d2348 1
a2348 1
PRIVATE int newsmaxchunk_fun ARGS1(
a2363 8
/* -nobold */
PRIVATE int nobold_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
   LYnoVideo(1);
   return 0;
}

d2365 1
a2365 1
PRIVATE int nobrowse_fun ARGS1(
d2373 1
a2373 1
PRIVATE int nocolor_fun ARGS1(
d2385 1
a2385 1
PRIVATE int nopause_fun ARGS1(
d2388 3
a2390 1
    disable_pausing();
a2393 31
/* -noreverse */
PRIVATE int noreverse_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
   LYnoVideo(2);
   return 0;
}

/* -nounderline */
PRIVATE int nounderline_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
   LYnoVideo(4);
   return 0;
}

#ifdef MISC_EXP
/* -nozap */
PRIVATE int nozap_fun ARGS1(
	char *,			next_arg)
{
    LYNoZapKey = 1; /* everything but "initially" treated as "full" - kw */
    if (next_arg != 0) {
	if (strcasecomp(next_arg, "initially") == 0)
	    LYNoZapKey = 2;

    }
   return 0;
}
#endif /* MISC_EXP */

d2395 1
a2395 1
PRIVATE int pauth_fun ARGS1(
d2403 1
a2403 1
PRIVATE int post_data_fun ARGS1(
d2420 2
a2421 1
    force_dump_mode();
d2430 8
a2437 1
    while (GetStdin(&buf, TRUE)) {
a2442 19
PRIVATE char *show_restriction ARGS1(
	CONST char *,		name)
{
    char *value = 0;

    switch (find_restriction(name, -1)) {
    case TRUE:
	value = "on";
	break;
    case FALSE:
	value = "off";
	break;
    default:
	value = "?";
	break;
    }
    return value;
}

d2444 1
a2444 1
PRIVATE int restrictions_fun ARGS1(
d2447 7
a2453 7
    static CONST struct {
	CONST char *name;
	CONST char *help;
    } table[] = {
	{ "all", "restricts all options." },
	{ "bookmark", "disallow changing the location of the bookmark file" },
	{ "bookmark_exec", "disallow execution links via the bookmark file" },
d2455 3
a2457 4
	{ "change_exec_perms", "\
disallow changing the eXecute permission on files\n\
(but still allow it for directories) when local file\n\
management is enabled." },
d2459 6
a2464 19
#ifdef SUPPORT_CHDIR
	{ "chdir", "\
disallow changing the working directory of lynx, e.g.,\n\
to affect the behavior of download command" },
#endif
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	{ "compileopts_info", "\
disable info on options used to compile the binary" },
#endif
	{ "default", "\
same as commandline option -anonymous.  Sets the\n\
default service restrictions for anonymous users.  Set to\n\
all restricted, except for: inside_telnet, outside_telnet,\n\
inside_ftp, outside_ftp, inside_rlogin, outside_rlogin,\n\
inside_news, outside_news, telnet_port, jump, mail, print,\n\
exec, and goto.  The settings for these, as well as\n\
additional goto restrictions for specific URL schemes\n\
that are also applied, are derived from definitions\n\
within userdefs.h." },
d2466 1
a2466 1
	{ "dired_support", "disallow local file management" },
d2468 6
a2473 6
	{ "disk_save", "disallow saving to disk in the download and print menus" },
	{ "dotfiles", "disallow access to, or creation of, hidden (dot) files" },
	{ "download", "disallow some downloaders in the download menu" },
	{ "editor", "disallow editing" },
	{ "exec", "disable execution scripts" },
	{ "exec_frozen", "disallow the user from changing the execution link option" },
d2475 1
a2475 1
	{ "externals", "disable passing URLs to some external programs" },
d2477 3
a2479 4
	{ "file_url", "\
disallow using G)oto, served links or bookmarks for\n\
file: URL's" },
	{ "goto", "disable the 'g' (goto) command" },
d2481 14
a2494 22
	{ "inside_ftp", "\
disallow ftps coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain (utmp required for selectivity)" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_telnet", "\
disallow telnets coming from inside your\n\
domain (utmp required for selectivity)" },
#else
	{ "inside_ftp", "\
disallow ftps coming from inside your domain" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your domain" },
	{ "inside_telnet", "\
disallow telnets coming from inside your domain" },
d2496 5
a2500 13
	{ "jump", "disable the 'j' (jump) command" },
	{ "lynxcfg_info", "\
disable viewing of lynx.cfg configuration file info" },
#ifndef NO_CONFIG_INFO
	{ "lynxcfg_xinfo", "\
disable extended lynx.cfg viewing and reloading" },
#endif
	{ "lynxcgi", "\
disallow execution of Lynx CGI URLs" },
	{ "mail", "disallow mail" },
	{ "multibook", "disallow multiple bookmark files" },
	{ "news_post", "disallow USENET News posting." },
	{ "option_save", "disallow saving options in .lynxrc" },
d2502 14
a2515 22
	{ "outside_ftp", "\
disallow ftps coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain (utmp required for selectivity)" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_telnet", "\
disallow telnets coming from outside your\n\
domain (utmp required for selectivity)" },
#else
	{ "outside_ftp", "\
disallow ftp coming from outside your domain" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your domain" },
	{ "outside_telnet", "\
disallow telnets coming from outside your domain" },
d2517 6
a2522 7
	{ "print", "disallow most print options" },
	{ "shell", "\
disallow shell escapes, and lynxexec, lynxprog or lynxcgi\n\
G)oto's" },
	{ "suspend", "disallow Control-Z suspends with escape to shell" },
	{ "telnet_port", "disallow specifying a port in telnet G)oto's" },
	{ "useragent", "disallow modifications of the User-Agent header" },
d2524 1
a2524 5
    static CONST char *Usage[] = {
 ""
,"USAGE: lynx -restrictions=[option][,option][,option]"
,"List of Options:"
,"  ?                 when used alone, list restrictions in effect."
d2526 3
a2528 51
    };
    unsigned j, k, column = 0;
    CONST char *name;
    CONST char *value;
    BOOLEAN found, first;

    if (isEmpty(next_arg)) {
	SetOutputMode( O_TEXT );
	for (j = 0; j < TABLESIZE(Usage); j++) {
	    printf("%s\n", Usage[j]);
	}
	for (j = 0; j < TABLESIZE(table); j++) {
	    if (!strcmp(table[j].name, "all")
	     || !strcmp(table[j].name, "default")) {
		value = NULL;
	    } else {
		value = show_restriction(table[j].name);
	    }
	    print_help_strings (
		table[j].name, table[j].help, value, FALSE);
	}
	first = TRUE;
	for (j = 0; ; j++) {
	    found = FALSE;
	    if ((name = index_to_restriction(j)) == 0) {
		break;
	    }
	    for (k = 0; k < TABLESIZE(table); k++) {
		if (!strcmp(name, table[k].name)) {
		    found = TRUE;
		}
	    }
	    if (!found) {
		if (first) {
		    printf("Other restrictions (see the user's guide):\n");
		}
		value = show_restriction(table[j].name);
		printf("%s%s (%s)", column ? ", " : "  ", name, value);
		column += 5 + strlen(name) + strlen(value);
		if (column > 50) {
		    column = 0;
		    printf("\n");
		}
		first = FALSE;
	    }
	}
	if (column)
	    printf("\n");
	SetOutputMode( O_BINARY );
	exit(EXIT_SUCCESS);
    } else if (*next_arg == '?') {
d2530 2
a2531 1
	print_restrictions_to_fd(stdout);
d2533 1
a2533 3
	exit(EXIT_SUCCESS);
    } else {
	parse_restrictions(next_arg);
d2539 1
a2539 1
PRIVATE int selective_fun ARGS1(
d2547 1
a2547 1
PRIVATE int source_fun ARGS1(
d2550 1
a2550 1
    force_dump_mode();
d2553 1
a2553 1
    LYcols = MAX_COLS;
d2558 1
a2558 1
PRIVATE int traversal_fun ARGS1(
d2563 1
a2563 1
    LYcols = DFT_COLS;
d2565 1
a2565 1
    LYcols = MAX_COLS;
d2572 1
a2572 1
PRIVATE int version_fun ARGS1(
a2574 5
#ifdef USE_SSL
    char SSLLibraryVersion[256];
    char *SSLcp;
#endif

d2577 2
a2578 1
    printf(gettext("%s Version %s (%s)\n"),
d2580 4
a2583 16
	  LYVersionDate());
#ifdef USE_SSL
    printf("libwww-FM %s, SSL-MM 1.4.1", HTLibraryVersion);
#ifdef OPENSSL_VERSION_TEXT
    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = ' ';
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    printf(", %s", SSLLibraryVersion);
	}
    }
#endif /* OPENSSL_VERSION_TEXT */
    printf("\n");
#endif /* USE_SSL */

a2589 6

/*
 * SYSTEM_NAME is set by the configure script.  Show build date/time for other
 * systems, according to predefined compiler symbols.
 */
#ifdef SYSTEM_NAME
a2590 18
#else
#ifdef __CYGWIN__
    printf("Compiled by CYGWIN (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __BORLANDC__
    printf("Compiled by Borland C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef _MSC_VER
    printf("Compiled by Microsoft Visual C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __DJGPP__
    printf("Compiled by DJGPP (%s %s).\n", __DATE__, __TIME__);
#else
    printf("Compiled at (%s %s).\n", __DATE__, __TIME__);
#endif /* __DJGPP__ */
#endif /* _MSC_VER */
#endif /* __BORLANDC__ */
#endif /* __CYGWIN__ */
a2591 1

a2599 7
#ifdef USE_SSL
    printf("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.\n");
#ifdef OPENSSL_VERSION_TEXT
    printf("See http://www.openssl.org/ for information about OpenSSL.\n");
#endif /* OPENSSL_VERSION_TEXT */
    printf("\n");
#endif /* USE_SSL */
d2603 1
a2603 1
    exit(EXIT_SUCCESS);
d2609 1
a2609 1
PRIVATE int width_fun ARGS1(
d2615 1
a2615 1
	    dump_output_width = ((w < MAX_COLS) ? w : MAX_COLS);
d2621 2
a2622 2
/* NOTE: This table is sorted by name to make the help message useful */
PRIVATE Config_Type Arg_Table [] =
d2625 2
a2626 2
      "accept_all_cookies", 4|SET_ARG,		LYAcceptAllCookies,
      "\naccept cookies without prompting if Set-Cookie handling\nis on"
d2629 2
a2630 2
      "anonymous",	2|FUNCTION_ARG,		anonymous_fun,
      "apply restrictions for anonymous account,\nsee also -restrictions"
d2633 1
a2633 1
      "assume_charset", 4|NEED_FUNCTION_ARG,	assume_charset_fun,
d2637 1
a2637 1
      "assume_local_charset",	4|NEED_FUNCTION_ARG,assume_local_charset_fun,
d2641 1
a2641 1
      "assume_unrec_charset",	4|NEED_FUNCTION_ARG,assume_unrec_charset_fun,
d2645 1
a2645 1
      "auth",		4|NEED_FUNCTION_ARG,	auth_fun,
d2649 1
a2649 1
      "base",		4|FUNCTION_ARG,		base_fun,
d2652 4
a2655 4
#ifndef DISABLE_BIBP
   PARSE_STR(
      "bibhost",	4|NEED_LYSTRING_ARG,	BibP_bibhost,
      "=URL\nlocal bibp server (default http://bibhost/)"
a2657 1
#ifdef USE_BLINK
d2659 1
a2659 6
      "blink",		4|SET_ARG,		term_blink_is_boldbg,
      "enable bright background via the BLINK terminal attribute"
   ),
#endif
   PARSE_SET(
      "book",		4|SET_ARG,		bookmark_start,
d2663 1
a2663 1
      "buried_news",	4|TOGGLE_ARG,		scan_for_buried_news_references,
d2667 1
a2667 1
      "cache",		4|NEED_FUNCTION_ARG,	cache_fun,
d2671 1
a2671 1
      "case",		4|SET_ARG,		case_sensitive,
a2673 4
   PARSE_SET(
      "center",		4|TOGGLE_ARG,		no_table_center,
      "toggle center alignment in HTML TABLE"
   ),
d2675 1
a2675 1
      "cfg",		2|NEED_LYSTRING_ARG,	lynx_cfg_file,
d2679 1
a2679 1
      "child",		4|FUNCTION_ARG,		child_fun,
a2681 10
#ifdef EXP_CMD_LOGGING
   PARSE_STR(
       "cmd_log",	2|NEED_LYSTRING_ARG,	lynx_cmd_logfile,
       "=FILENAME\nlog keystroke commands to the given file"
   ),
   PARSE_STR(
       "cmd_script",	2|NEED_LYSTRING_ARG,	lynx_cmd_script,
       "=FILENAME\nread keystroke commands from the given file\n(see -cmd_log)"
   ),
#endif
d2684 1
a2684 1
      "color",		4|FUNCTION_ARG,		color_fun,
d2688 3
a2690 8
   PARSE_INT(
      "connect_timeout", 4|NEED_INT_ARG,	connect_timeout,
      "=N\nset the N-second connection timeout"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "convert_to",	4|FUNCTION_ARG,		convert_to_fun,
      "=FORMAT\nconvert input, FORMAT is in MIME type notation\n(experimental)"
a2691 1
#endif
d2694 1
a2694 5
      "cookie_file",	4|LYSTRING_ARG,		LYCookieFile,
      "=FILENAME\nspecifies a file to use to read cookies"
   ),
   PARSE_STR(
      "cookie_save_file",	4|LYSTRING_ARG,	LYCookieSaveFile,
a2697 4
   PARSE_SET(
      "cookies",	4|TOGGLE_ARG,		LYSetCookies,
      "toggles handling of Set-Cookie headers"
   ),
d2700 1
a2700 1
      "core",		4|TOGGLE_ARG,		LYNoCore,
d2705 1
a2705 1
      "crawl",		4|FUNCTION_ARG,		crawl_fun,
a2708 6
#ifdef USE_CURSES_PADS
   PARSE_SET(
      "curses_pads",	4|TOGGLE_ARG,		LYuseCursesPads,
      "uses curses pad feature to support left/right shifting"
   ),
#endif
d2711 1
a2711 1
      "debug_partial",	4|TOGGLE_ARG,		debug_display_partial,
a2714 4
   PARSE_INT(
      "delay",		4|NEED_TIME_ARG,	DebugSecs,
      "=NNN\nset NNN-second delay at statusline message"
   ),
d2716 1
a2716 1
      "display",	4|NEED_FUNCTION_ARG,	display_fun,
d2720 1
a2720 10
      "display_charset", 4|NEED_FUNCTION_ARG,	display_charset_fun,
      "=MIMEname\ncharset for the terminal output"
   ),
   PARSE_SET(
      "dont_wrap_pre",	4|SET_ARG,		dont_wrap_pre,
      "inhibit wrapping of text in <pre> when -dump'ing and\n\
-crawl'ing, mark wrapped lines in interactive session"
   ),
   PARSE_FUN(
      "dump",		4|FUNCTION_ARG,		dump_output_fun,
d2724 1
a2724 1
      "editor",		4|NEED_FUNCTION_ARG,	editor_fun,
d2728 1
a2728 1
      "emacskeys",	4|SET_ARG,		emacs_keys,
d2732 1
a2732 1
      "enable_scrollback", 4|TOGGLE_ARG,	enable_scrollback,
d2737 1
a2737 1
      "error_file",	4|NEED_FUNCTION_ARG,	error_file_fun,
d2743 1
a2743 1
      "exec",		4|FUNCTION_ARG,		exec_fun,
d2747 8
d2758 1
a2758 1
      "fileversions",	4|SET_ARG,		HTVMSFileVersions,
a2761 1
#ifdef LY_FIND_LEAKS
d2763 2
a2764 2
      "find_leaks",	4|TOGGLE_ARG,		LYfind_leaks,
      "toggles memory-leak checking"
a2765 1
#endif
d2767 2
a2768 2
      "force_empty_hrefless_a",	4|SET_ARG,	force_empty_hrefless_a,
      "\nforce HREF-less 'A' elements to be empty (close them as\nsoon as they are seen)"
d2771 2
a2772 6
      "force_html",	4|SET_ARG,		LYforce_HTML_mode,
      "forces the first document to be interpreted as HTML"
   ),
   PARSE_SET(
      "force_secure",	4|TOGGLE_ARG,		LYForceSSLCookiesSecure,
      "toggles forcing of the secure flag for SSL cookies"
d2776 1
a2776 1
      "forms_options",	4|TOGGLE_ARG,		LYUseFormsOptions,
d2781 1
a2781 5
      "from",		4|TOGGLE_ARG,		LYNoFromHeader,
      "toggle transmission of From headers"
   ),
   PARSE_SET(
      "ftp",		4|UNSET_ARG,		ftp_ok,
d2785 1
a2785 1
      "get_data",	6|FUNCTION_ARG,		get_data_fun,
d2789 1
a2789 1
      "head",		4|SET_ARG,		HEAD_request,
d2793 1
a2793 1
      "help",		5|FUNCTION_ARG,		help_fun,
d2797 1
a2797 1
      "hiddenlinks",	4|NEED_FUNCTION_ARG,	hiddenlinks_fun,
d2801 2
a2802 2
      "historical",	4|TOGGLE_ARG,		historical_comments,
      "toggles use of '>' or '-->' as terminator for comments"
d2805 1
a2805 1
      "homepage",	4|NEED_FUNCTION_ARG,	homepage_fun,
d2809 1
a2809 1
      "image_links",	4|TOGGLE_ARG,		clickable_images,
d2813 1
a2813 1
      "index",		4|NEED_LYSTRING_ARG,	indexfile,
d2817 1
a2817 1
      "ismap",		4|TOGGLE_ARG,		LYNoISMAPifUSEMAP,
a2819 6
#ifdef EXP_JUSTIFY_ELTS
   PARSE_SET(
      "justify",	4|SET_ARG,		ok_justify,
      "do justification of text"
   ),
#endif
d2821 1
a2821 1
      "link",		4|NEED_INT_ARG,		ccount,
d2825 1
a2825 1
      "localhost",	4|SET_ARG,		local_host_only,
d2828 1
a2828 7
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "locexec",	4|SET_ARG,		local_exec_on_local_files,
      "enable local program execution from local files only"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#if defined(USE_COLOR_STYLE)
d2830 1
a2830 1
      "lss",		2|NEED_LYSTRING_ARG,	lynx_lss_file,
d2835 1
a2835 1
      "mime_header",	4|FUNCTION_ARG,		mime_header_fun,
d2839 1
a2839 1
      "minimal",	4|TOGGLE_ARG,		minimal_comments,
a2841 6
#ifdef EXP_NESTED_TABLES
   PARSE_SET(
      "nested_tables",	4|TOGGLE_ARG,		nested_tables,
      "toggles nested-tables logic"
   ),
#endif
d2844 1
a2844 1
      "newschunksize",	4|NEED_FUNCTION_ARG,	newschunksize_fun,
d2848 1
a2848 1
      "newsmaxchunk",	4|NEED_FUNCTION_ARG,	newsmaxchunk_fun,
a2851 6
#if USE_BLAT_MAILER
   PARSE_SET(
      "noblat",		4|TOGGLE_ARG,		mail_is_blat,
      "select mail tool (`BLAT' ==> `sendmail')"
   ),
#endif
d2853 1
a2853 5
      "nobold",		4|FUNCTION_ARG,		nobold_fun,
      "disable bold video-attribute"
   ),
   PARSE_FUN(
      "nobrowse",	4|FUNCTION_ARG,		nobrowse_fun,
d2857 1
a2857 1
      "nocc",		4|SET_ARG,		LYNoCc,
d2861 1
a2861 1
      "nocolor",	4|FUNCTION_ARG,		nocolor_fun,
a2863 6
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "noexec",		4|UNSET_ARG,		local_exec,
      "disable local program execution (DEFAULT)"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
d2865 2
a2866 2
      "nofilereferer",	4|SET_ARG,		no_filereferer,
      "disable transmission of Referer headers for file URLs"
d2869 1
a2869 1
      "nolist",		4|SET_ARG,		nolist,
d2873 1
a2873 1
      "nolog",		4|UNSET_ARG,		error_logging,
a2875 6
#if defined(HAVE_SIGACTION) && defined(SIGWINCH)
   PARSE_SET(
      "nonrestarting_sigwinch", 4|SET_ARG,	LYNonRestartingSIGWINCH,
      "\nmake window size change handler non-restarting"
   ),
#endif /* HAVE_SIGACTION */
d2877 1
a2877 1
      "nopause",	4|FUNCTION_ARG,		nopause_fun,
d2881 2
a2882 2
      "noprint",	4|SET_ARG,		no_print,
      "disable some print functions, like -restrictions=print"
d2885 1
a2885 1
      "noredir",	4|SET_ARG,		no_url_redirection,
d2889 2
a2890 6
      "noreferer",	4|SET_ARG,		LYNoRefererHeader,
      "disable transmission of Referer headers"
   ),
   PARSE_FUN(
      "noreverse",	4|FUNCTION_ARG,		noreverse_fun,
      "disable reverse video-attribute"
d2894 1
a2894 1
      "nosocks",	6|UNSET_ARG,		socks_flag,
d2899 1
a2899 1
      "nostatus",	4|SET_ARG,		no_statusline,
a2901 14
   PARSE_FUN(
      "nounderline",	4|FUNCTION_ARG,		nounderline_fun,
      "disable underline video-attribute"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "nozap",		4|FUNCTION_ARG,		nozap_fun,
      "=DURATION (\"initially\" or \"full\") disable checks for 'z' key"
   ),
#endif
   PARSE_SET(
      "number_fields",	4|SET_ARG,		number_fields,
      "force numbering of links as well as form input fields"
   ),
d2903 1
a2903 1
      "number_links",	4|SET_ARG,		number_links,
d2908 1
a2908 1
      "partial",	4|TOGGLE_ARG,		display_partial_flag,
d2912 1
a2912 1
      "partial_thres",	4|NEED_INT_ARG,		partial_threshold,
d2918 1
a2918 1
      "pauth",		4|NEED_FUNCTION_ARG,	pauth_fun,
d2922 1
a2922 1
      "popup",		4|UNSET_ARG,		LYUseDefSelPop,
d2926 1
a2926 1
      "post_data",	6|FUNCTION_ARG,		post_data_fun,
d2930 1
a2930 1
      "preparsed",	4|SET_ARG,		LYPreparsedSource,
d2934 1
a2934 1
#ifdef USE_PRETTYSRC
d2936 2
a2937 2
      "prettysrc",	4|SET_ARG,		LYpsrc,
      "do syntax highlighting and hyperlink handling in source\nview"
d2941 2
a2942 2
      "print",		4|UNSET_ARG,		no_print,
      "enable print functions (DEFAULT), opposite of -noprint"
d2945 1
a2945 1
      "pseudo_inlines", 4|TOGGLE_ARG,		pseudo_inline_alts,
d2949 2
a2950 3
      "raw",		4|UNSET_ARG,		LYUseDefaultRawMode,
      "toggles default setting of 8-bit character translations\n\
or CJK mode for the startup character set"
d2953 1
a2953 1
      "realm",		4|SET_ARG,		check_realm,
d2957 1
a2957 1
      "reload",		4|SET_ARG,		reloading,
d2961 1
a2961 1
      "restrictions",	4|FUNCTION_ARG,		restrictions_fun,
d2965 1
a2965 1
      "resubmit_posts", 4|TOGGLE_ARG,		LYresubmit_posts,
d2971 1
a2971 1
      "rlogin",		4|UNSET_ARG,		rlogin_ok,
a2973 10
#ifdef USE_SCROLLBAR
   PARSE_SET(
      "scrollbar",	4|TOGGLE_ARG,		LYShowScrollbar,
      "toggles showing scrollbar"
   ),
   PARSE_SET(
      "scrollbar_arrow", 4|TOGGLE_ARG,		LYsb_arrow,
      "toggles showing arrows at ends of the scrollbar"
   ),
#endif
d2975 1
a2975 1
      "selective",	4|FUNCTION_ARG,		selective_fun,
d2979 1
a2979 11
      "short_url",	4|SET_ARG,		long_url_ok,
      "enables examination of beginning and end of long URL in\nstatus line"
   ),
#ifdef SH_EX
   PARSE_SET(
      "show_cfg",	4|SET_ARG,		show_cfg,
      "Show `LYNX.CFG' setting"
   ),
#endif
   PARSE_SET(
      "show_cursor",	4|TOGGLE_ARG,		LYUseDefShoCur,
a2981 1
#ifdef EXP_READPROGRESS
d2983 1
a2983 6
      "show_rate",	4|TOGGLE_ARG,		LYShowTransferRate,
      "toggles display of transfer rate"
   ),
#endif
   PARSE_SET(
      "soft_dquotes",	4|TOGGLE_ARG,		soft_dquotes,
d2988 1
a2988 1
      "source",		4|FUNCTION_ARG,		source_fun,
d2992 1
a2992 1
      "stack_dump",	4|SET_ARG,		stack_dump,
d2996 1
a2996 1
      "startfile_ok",	4|SET_ARG,		startfile_ok,
a2998 4
   PARSE_SET(
      "stdin",		4|SET_ARG,		startfile_stdin,
      "read startfile from standard input"
   ),
d3002 1
a3002 1
      "syslog",		4|NEED_LYSTRING_ARG,	syslog_txt,
d3008 1
a3008 1
      "tagsoup",	4|SET_ARG,		DTD_recovery,
d3012 1
a3012 1
      "telnet",		4|UNSET_ARG,		telnet_ok,
d3016 1
a3016 1
      "term",		4|NEED_STRING_ARG,	terminal,
a3018 6
#ifdef _WINDOWS
   PARSE_INT(
      "timeout",	4|INT_ARG,		lynx_timeout,
      "=NUMBER\nset TCP/IP timeout"
   ),
#endif
d3020 1
a3020 1
      "tlog",		2|TOGGLE_ARG,		LYUseTraceLog,
a3022 7
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
   PARSE_SET(
      "tna",		4|SET_ARG,		textfields_activation_option,
      "turn on \"Textfields Need Activation\" mode"
   ),
#endif
#ifndef NO_LYNX_TRACE
d3024 1
a3024 1
      "trace",		2|SET_ARG,		WWW_TraceFlag,
a3026 5
   PARSE_INT(
      "trace_mask",	2|INT_ARG,		WWW_TraceMask,
      "customize Lynx trace mode"
   ),
#endif
d3028 1
a3028 1
      "traversal",	4|FUNCTION_ARG,		traversal_fun,
d3032 1
a3032 5
      "trim_input_fields", 2|SET_ARG,		LYtrimInputFields,
      "trim input text/textarea fields in forms"
   ),
   PARSE_SET(
      "underscore",	4|TOGGLE_ARG,		use_underscore,
d3035 1
a3035 1
#if defined(USE_MOUSE)
d3037 2
a3038 2
      "use_mouse",	4|SET_ARG,		LYUseMouse,
      "turn on mouse support"
d3042 1
a3042 1
      "useragent",	4|NEED_LYSTRING_ARG,	LYUserAgent,
d3046 2
a3047 2
      "validate",	2|SET_ARG,		LYValidate,
      "accept only http URLs (meant for validation)\nimplies more restrictions than -anonymous, but\ngoto is allowed for http and https"
d3050 1
a3050 1
      "verbose",	4|TOGGLE_ARG,		verbose_img,
d3054 1
a3054 1
      "version",	4|FUNCTION_ARG,		version_fun,
d3058 1
a3058 1
      "vikeys",		4|SET_ARG,		vi_keys,
a3060 6
#ifdef __DJGPP__
   PARSE_SET(
      "wdebug",		4|TOGGLE_ARG,		watt_debug,
      "enables Waterloo tcp/ip packet debug. Prints to watt\ndebugfile"
  ),
#endif /* __DJGPP__ */
d3062 1
a3062 1
      "width",		4|NEED_FUNCTION_ARG,	width_fun,
d3065 1
a3065 7
#ifndef NO_DUMP_WITH_BACKSPACES
   PARSE_SET(
      "with_backspaces", 4|SET_ARG,		with_backspaces,
      "emit backspaces in output if -dumping or -crawling\n(like 'man' does)"
   ),
#endif
   PARSE_NIL
d3068 1
a3068 1
PRIVATE void print_help_strings ARGS4(
d3071 1
a3071 2
	CONST char *,	value,
	BOOLEAN,	option)
d3078 1
a3078 1
    pad = field_width - (2 + option + (int) strlen (name));
d3080 1
a3080 1
    fprintf (stdout, "  %s%s", option ? "-" : "", name);
d3119 1
a3119 1
PRIVATE void print_help_and_exit ARGS1(int, exit_status)
d3121 1
a3121 1
    Config_Type *p;
a3128 1
#ifdef VMS
d3131 1
a3131 4
in double-quotes (\"-\") on VMS)", NULL, TRUE);
#else
    print_help_strings("", "receive options and arguments from stdin", NULL, TRUE);
#endif /* VMS */
d3135 5
a3139 2
	ParseUnionPtr q = ParseUnionOf(p);

d3143 1
a3143 1
		strcpy(temp, *(q->set_value) ? "on" : "off");
d3146 1
a3146 1
		strcpy(temp, *(q->set_value) ? "off" : "on");
a3150 3
	    case TIME_ARG:
		sprintf(temp, SECS_FMT, (double) Secs2SECS(*(q->int_value)));
		break;
d3160 1
a3160 1
	print_help_strings(p->name, p->help_string, value, TRUE);
d3176 1
a3176 1
PRIVATE int arg_eqs_parse ARGS3(
a3180 2
    int result = -1;

d3182 1
a3182 1
    while (result < 0) {
a3187 5
		case '\t':	/* embedded blank when reading stdin */
		case ' ':
		    *c = LYSkipBlanks(b);
		    result = 1;
		    break;
a3188 1
		case ':':
d3190 2
a3191 10
		    result = 1;
		    break;
		case '-':
#if OPTNAME_ALLOW_DASHES
		    if (isalpha(UCH(b[1]))) {
			result = 0;
			break;
		    }
#endif
		    /* FALLTHRU */
d3194 1
a3194 2
		    result = 1;
		    break;
d3196 1
a3196 2
		    result = 1;
		    break;
d3198 1
a3198 2
		    result = 0;
		    break;
d3201 1
a3201 4
#if OPTNAME_ALLOW_DASHES
		if (!(*a == '_' && *b == '-'))
#endif
		result = 0;
d3206 1
a3206 2
    }
    return result;
d3212 1
a3212 1
PRIVATE BOOL parse_arg ARGS3(
a3213 1
	unsigned,	mask,
d3216 1
a3216 1
    Config_Type *p;
a3217 3
#if EXTENDED_STARTFILE_RECALL
    static BOOLEAN had_nonoption = FALSE;
#endif
a3229 6
#if EXTENDED_STARTFILE_RECALL
	if (had_nonoption && !dump_output_immediately) {
	    HTAddGotoURL(startfile); /* startfile was set by a previous arg */
	}
	had_nonoption = TRUE;
#endif
d3232 1
a3232 13
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 20:11:17 */
	HTUnEscape(startfile);
	{
	    char *p;

	    p = startfile;
	    while (*p++) {
		if (*p == '|')
		    *p = ':';
	    }
	}
#endif
	return (BOOL)(i != 0);
d3237 1
a3237 1
	return TRUE;
d3250 1
a3250 1
	return TRUE;
a3254 1
    CTRACE((tfp, "parse_arg(%s)\n", arg_name));
d3258 5
a3262 1
	ParseUnionPtr q = ParseUnionOf(p);
a3264 1
	char *temp_ptr = NULL;
d3272 4
a3275 13
	if (p->type & NEED_NEXT_ARG) {
	    if (next_arg == 0) {
		next_arg = argv[1];
		if ((i != 0) && (next_arg != 0))
		    (*i)++;
	    }
	    CTRACE((tfp, "...arg:%s\n", next_arg != 0 ? next_arg : "<null>"));
	}

	/* ignore option if it's not our turn */
	if ((p->type & mask) == 0) {
	    CTRACE((tfp, "...skip (mask %d/%d)\n", mask, p->type & 7));
	    return FALSE;
d3286 1
a3286 1
			 *(q->set_value) = (BOOL) !(*(q->set_value));
d3319 1
a3319 1
		 *(q->int_value) = strtol (next_arg, &temp_ptr, 0);
a3321 9
	case TIME_ARG:
	    if ((q->int_value != 0) && (next_arg != 0)) {
		float ival;
		if (1 == sscanf (next_arg, "%f", &ival)) {
		    *(q->int_value) = (int) SECS2Secs(ival);
		}
	    }
	    break;

d3323 1
a3323 1
	    if ((q->str_value != 0) && (next_arg != 0))
d3325 4
a3328 1
	    break;
d3331 1
a3331 2
	Old_DTD = DTD_recovery;	/* BOOL != int */
	return TRUE;
a3337 1
    return FALSE;
d3370 1
a3370 1
	LYSleepAlert();
d3395 1
a3395 2
	if (!(sig == 0 && LYNoCore)) {
	    fprintf(stderr, "\r\n\
d3397 2
a3398 3
	}
	if (sig != 0) {
	    fprintf(stderr, "\r\n\
a3399 14
#ifdef WIN_EX	/* 1998/08/09 (Sun) 09:58:25 */
	{
	    char *msg;
	    switch (sig) {
	    case SIGABRT:	msg = "SIGABRT";	break;
	    case SIGFPE:	msg = "SIGFPE";		break;
	    case SIGILL:	msg = "SIGILL";		break;
	    case SIGSEGV:	msg = "SIGSEGV";	break;
	    default:		msg = "Not-def";	break;
	    }
	    fprintf(stderr, "signal code = %s\n", msg);
	}
#endif
	}
d3405 1
a3405 1
	    exit(EXIT_FAILURE);
d3417 1
a3417 1
	exit(EXIT_SUCCESS);
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@a191 2
PUBLIC BOOLEAN ftp_local_passive;
PUBLIC char *ftp_lasthost;
a901 5

#ifndef DISABLE_FTP
    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
    ftp_lasthost = calloc(1,sizeof(char));
#endif
@


1.1.3.3
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d79 1
a79 1
PRIVATE char init_ctrl_break[1];
a298 1
PUBLIC BOOLEAN dj_is_bash = FALSE;  /* Check for bash shell under DJGPP */
d449 1
a449 1
#ifdef USE_PERSISTENT_COOKIES
d453 1
a453 1
#endif /* USE_PERSISTENT_COOKIES */
d466 1
a466 1
PUBLIC int LYTransferRate = rateKB;
a508 5
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
PUBLIC int scrsize_x = 0;
PUBLIC int scrsize_y = 0;
#endif

d673 1
a673 1
#ifdef USE_PERSISTENT_COOKIES
a870 43
 * Append the SSL version to lynx version or user-agent string.
 */
#ifdef USE_SSL
PRIVATE void append_ssl_version ARGS2(
	char **,	target,
	char *,		separator)
{
    char SSLLibraryVersion[256];
    char *SSLcp;

    HTSprintf(target, " SSL-MM%s1.4.1", separator);

#undef LYNX_SSL_VERSION

#if defined(SSLEAY_VERSION)
#define LYNX_SSL_VERSION SSLeay_version(SSLEAY_VERSION)
#else
#if defined(OPENSSL_VERSION_TEXT)
#define LYNX_SSL_VERSION OPENSSL_VERSION_TEXT
#else
#if defined(GNUTLS_VERSION)
#define LYNX_SSL_VERSION GNUTLS_VERSION
#endif /* GNUTLS_VERSION */
#endif /* OPENSSL_VERSION_TEXT */
#endif

#ifdef LYNX_SSL_VERSION
    if (*separator == ' ')
	StrAllocCat(*target, ",");
    LYstrncpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion)-1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = *separator;
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    StrAllocCat(*target, " ");
	    StrAllocCat(*target, SSLLibraryVersion);
	}
    }
#endif /* LYNX_SSL_VERSION */
}
#endif /* USE_SSL */

/*
d888 4
a964 4

    if (((cp = LYGetEnv("SHELL")) != NULL)
      && (strstr(LYPathLeaf(cp), "sh") != NULL))
	dj_is_bash = TRUE;
a1079 1

d1088 12
a1099 1
    append_ssl_version(&LYUserAgent, "/");
a1101 1

d1611 1
a1611 1
#ifdef USE_PERSISTENT_COOKIES
d1795 1
a1795 1
#ifdef USE_SOURCE_CACHE
d2031 1
a2031 1
#ifdef USE_PERSISTENT_COOKIES
d2039 1
a2039 1
#endif /* USE_PERSISTENT_COOKIES */
a2067 9
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
	if (! isendwin()) {
	    extern int saved_scrsize_x;
	    extern int saved_scrsize_y;
	    if ((saved_scrsize_x != 0) && (saved_scrsize_y != 0)) {
	        resize_term(saved_scrsize_y, saved_scrsize_x);
	    }
	}
#endif
d2172 1
a2172 1
#ifdef USE_PERSISTENT_COOKIES
d2193 1
a2193 1
#ifdef USE_SOURCE_CACHE
d2240 1
a2240 1
#ifdef USE_PERSISTENT_COOKIES
d3067 4
a3070 1
    char *result = NULL;
d3074 3
a3076 3
    HTSprintf0(&result, gettext("%s Version %s (%s)"),
	       LYNX_NAME, LYNX_VERSION,
	       LYVersionDate());
d3078 12
a3089 3
    StrAllocCat(result, "\n");
    HTSprintf(&result, "libwww-FM %s,", HTLibraryVersion);
    append_ssl_version(&result, " ");
a3090 2
    printf("%s\n", result);
    free(result);
a3160 28
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* -scrsize */
PRIVATE int scrsize_fun ARGS1(
	char *,			next_arg)
{
    if (next_arg != 0) {
	char *cp;

	if ((cp = strchr(next_arg, ',')) != 0) {
	    *cp++ = '\0';	/* Terminate ID */
	    scrsize_x = atoi(next_arg);
	    scrsize_y = atoi(cp);
	    if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
		scrsize_x = scrsize_y = 0;
	    }
	    if ((scrsize_x > 0) && (scrsize_x < 80)) {
		scrsize_x = 80;
	    }
	    if ((scrsize_y > 0) && (scrsize_y < 4)) {
		scrsize_y = 4;
	    }
	    CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
	}
    }
    return 0;
}
#endif

d3258 1
a3258 1
#ifdef USE_PERSISTENT_COOKIES
d3267 1
a3267 1
#endif /* USE_PERSISTENT_COOKIES */
a3627 6
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
   PARSE_FUN(
      "scrsize",	4|NEED_FUNCTION_ARG,	scrsize_fun,
      "=width,height\nsize of window"
   ),
#endif
d3656 1
a3656 1
#ifdef USE_READPROGRESS
@


1.1.3.4
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a173 1
PUBLIC BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS; /* Show the links underlined vs bold */
a467 1
PUBLIC char * LYTransferName = NULL;
a505 4
#ifdef EXP_LOCALE_CHARSET
PUBLIC BOOLEAN LYLocaleCharset = FALSE;
#endif

a710 1
    FREE(LYTransferName);
a1112 1
    StrAllocCopy(LYTransferName, "KiB");
a1557 4
#ifdef EXP_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif

d3170 1
a3170 1
	  "See http://lynx.isc.org/ and the online help for more information.\n\n"
a3808 4
   ),
   PARSE_SET(
      "underline_links",4|TOGGLE_ARG,		LYUnderlineLinks,
      "toggles use of underline/bold attribute for links"
@


1.1.3.5
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d71 1
a71 1
BOOLEAN socks_flag=TRUE;
d75 1
a75 1
BOOLEAN sigint = FALSE;
d79 1
a79 1
static char init_ctrl_break[1];
d83 1
a83 1
char *mail_adrs = NULL;	/* the mask for a VMS mail transport */
d88 1
a88 1
BOOLEAN UseFixedRecords = USE_FIXED_RECORDS;
d92 2
a93 2
static char *lynx_version_putenv_command = NULL;
char *list_format = NULL;	/* LONG_LIST formatting mask */
d95 1
a95 1
char *syslog_txt = NULL;		/* syslog arb text for session */
d100 6
a105 6
BOOLEAN lynx_edit_mode = FALSE;
BOOLEAN no_dired_support = FALSE;
HTList *tagged = NULL;
int LYAutoUncacheDirLists = 2; /* default dired uncaching behavior */
int dir_list_order = ORDER_BY_NAME;
int dir_list_style = MIXED_STYLE;
d108 1
a108 1
BOOLEAN prev_lynx_edit_mode = FALSE;
d113 1
a113 1
BOOLEAN no_change_exec_perms = TRUE;
d115 1
a115 1
BOOLEAN no_change_exec_perms = FALSE;
d122 1
a122 1
int HTCacheSize = DEFAULT_CACHE_SIZE;
d125 1
a125 1
int HTVirtualMemorySize = DEFAULT_VIRTUAL_MEMORY_SIZE;
d130 1
a130 1
BOOLEAN local_exec = LOCAL_EXECUTION_LINKS_ALWAYS_ON;
d132 1
a132 1
BOOLEAN local_exec = FALSE;
d134 1
a134 1
BOOLEAN local_exec_on_local_files =
d139 1
a139 1
char *LYCgiDocumentRoot = NULL; /* DOCUMENT_ROOT in the lynxcgi env */
d143 1
a143 1
BOOLEAN enable_scrollback=TRUE;
d145 1
a145 1
BOOLEAN enable_scrollback=FALSE;
d148 3
a150 3
char *empty_string = "\0";
int display_lines;  /* number of lines in display */
int www_search_result= -1;
d152 1
a152 1
lynx_list_item_type *printers = NULL;
d154 1
a154 1
lynx_list_item_type *downloaders = NULL;
d157 1
a157 1
lynx_list_item_type *externals = NULL;
d161 4
a164 4
lynx_list_item_type *uploaders = NULL;
int port_syntax = 1;
int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not */
int LYrcShowColor = SHOW_COLOR_UNKNOWN; /* ... last used */
d167 1
a167 1
BOOLEAN LYUseFormsOptions = TRUE; /* use forms-based options menu */
d170 41
a210 41
BOOLEAN LYJumpFileURL = FALSE;	 /* always FALSE the first time */
BOOLEAN LYPermitURL = FALSE;
BOOLEAN LYRestricted = FALSE; /* whether we have -anonymous option */
BOOLEAN LYShowCursor = SHOW_CURSOR; /* to show or not to show */
BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS; /* Show the links underlined vs bold */
BOOLEAN LYUseDefShoCur = TRUE;	/* Command line -show_cursor toggle */
BOOLEAN LYUserSpecifiedURL = TRUE;/* always TRUE  the first time */
BOOLEAN LYValidate = FALSE;
BOOLEAN LYforce_no_cache = FALSE;
BOOLEAN LYinternal_flag = FALSE; /* override no-cache b/c internal link*/
BOOLEAN LYoverride_no_cache = FALSE;/*override no-cache b/c history etc*/
BOOLEAN LYresubmit_posts = ALWAYS_RESUBMIT_POSTS;
BOOLEAN LYtrimInputFields = FALSE;
BOOLEAN bold_H1 = FALSE;
BOOLEAN bold_headers = FALSE;
BOOLEAN bold_name_anchors = FALSE;
BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
BOOLEAN check_mail = CHECKMAIL;
BOOLEAN child_lynx = FALSE;
BOOLEAN dump_output_immediately = FALSE;
BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
BOOLEAN ftp_passive = FTP_PASSIVE; /* TRUE if doing ftp in passive mode */
BOOLEAN ftp_local_passive;
char *ftp_lasthost;
BOOLEAN goto_buffer = GOTOBUFFER; /* TRUE if offering default goto URL */
BOOLEAN historical_comments = FALSE;
BOOLEAN is_www_index = FALSE;
BOOLEAN jump_buffer = JUMPBUFFER; /* TRUE if offering default shortcut */
BOOLEAN lynx_mode = NORMAL_LYNX_MODE;
BOOLEAN minimal_comments = FALSE;
BOOLEAN nolist = FALSE;
BOOLEAN number_fields_on_left = TRUE;
BOOLEAN number_links_on_left = TRUE;
BOOLEAN recent_sizechange = FALSE;/* the window size changed recently? */
BOOLEAN soft_dquotes = FALSE;
BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
BOOLEAN verbose_img = VERBOSE_IMAGES;  /* show filenames or not */
BOOLEAN vi_keys = VI_KEYS_ALWAYS_ON;
int keypad_mode = DEFAULT_KEYPAD_MODE;
int user_mode = NOVICE_MODE;
d212 1
a212 1
BOOLEAN telnet_ok = TRUE;
d214 1
a214 1
BOOLEAN news_ok = TRUE;
d216 52
a267 52
BOOLEAN rlogin_ok = TRUE;
BOOLEAN long_url_ok = FALSE;
BOOLEAN ftp_ok = TRUE;
BOOLEAN system_editor = FALSE;

BOOLEAN had_restrictions_default = FALSE;
BOOLEAN had_restrictions_all = FALSE;

BOOLEAN exec_frozen = FALSE;
BOOLEAN no_bookmark = FALSE;
BOOLEAN no_bookmark_exec = FALSE;
BOOLEAN no_chdir = FALSE;
BOOLEAN no_disk_save = FALSE;
BOOLEAN no_dotfiles = NO_DOT_FILES;
BOOLEAN no_download = FALSE;
BOOLEAN no_editor = FALSE;
BOOLEAN no_exec = FALSE;
BOOLEAN no_file_url = FALSE;
BOOLEAN no_goto = FALSE;
BOOLEAN no_goto_configinfo = FALSE;
BOOLEAN no_goto_cso = FALSE;
BOOLEAN no_goto_file = FALSE;
BOOLEAN no_goto_finger = FALSE;
BOOLEAN no_goto_ftp = FALSE;
BOOLEAN no_goto_gopher = FALSE;
BOOLEAN no_goto_http = FALSE;
BOOLEAN no_goto_https = FALSE;
BOOLEAN no_goto_lynxcgi = FALSE;
BOOLEAN no_goto_lynxexec = FALSE;
BOOLEAN no_goto_lynxprog = FALSE;
BOOLEAN no_goto_mailto = FALSE;
BOOLEAN no_goto_rlogin = FALSE;
BOOLEAN no_goto_telnet = FALSE;
BOOLEAN no_goto_tn3270 = FALSE;
BOOLEAN no_goto_wais = FALSE;
BOOLEAN no_inside_ftp = FALSE;
BOOLEAN no_inside_rlogin = FALSE;
BOOLEAN no_inside_telnet = FALSE;
BOOLEAN no_jump = FALSE;
BOOLEAN no_lynxcfg_info = FALSE;
BOOLEAN no_lynxcgi = FALSE;
BOOLEAN no_mail = FALSE;
BOOLEAN no_multibook = FALSE;
BOOLEAN no_option_save = FALSE;
BOOLEAN no_outside_ftp = FALSE;
BOOLEAN no_outside_rlogin = FALSE;
BOOLEAN no_outside_telnet = FALSE;
BOOLEAN no_print = FALSE;
BOOLEAN no_shell = FALSE;
BOOLEAN no_suspend = FALSE;
BOOLEAN no_telnet_port = FALSE;
BOOLEAN no_useragent = FALSE;
d270 6
a275 6
BOOLEAN no_goto_news = FALSE;
BOOLEAN no_goto_nntp = FALSE;
BOOLEAN no_goto_snews = FALSE;
BOOLEAN no_inside_news = FALSE;
BOOLEAN no_newspost = FALSE;
BOOLEAN no_outside_news = FALSE;
d279 1
a279 1
BOOLEAN no_externals = FALSE;
d283 1
a283 1
BOOLEAN no_lynxcfg_xinfo = FALSE;
d285 1
a285 1
BOOLEAN no_compileopts_info = FALSE;
d289 8
a296 8
BOOLEAN no_statusline = FALSE;
BOOLEAN no_filereferer = TRUE;
char LYRefererWithQuery = 'D';	/* 'D' for drop */
BOOLEAN local_host_only = FALSE;
BOOLEAN override_no_download = FALSE;
BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
BOOLEAN LYforce_HTML_mode = FALSE;
BOOLEAN LYfind_leaks = TRUE;
d299 2
a300 2
BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
BOOLEAN dj_is_bash = FALSE;  /* Check for bash shell under DJGPP */
d304 2
a305 2
BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
d310 3
a312 3
int lynx_timeout = TIMEOUT;
CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
d316 1
a316 1
BOOLEAN system_is_NT = FALSE;
d320 1
a320 1
BOOLEAN show_cfg = FALSE;
d323 1
a323 1
BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */
d326 1
a326 1
BOOLEAN mail_is_blat = TRUE;
d331 1
a331 1
BOOLEAN term_blink_is_boldbg = TRUE;
d333 1
a333 1
BOOLEAN term_blink_is_boldbg = FALSE;
d337 105
a441 105
BOOLEAN HEAD_request = FALSE;
BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
BOOLEAN LYCancelledFetch = FALSE;/* TRUE if cancelled binary fetch */
BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
BOOLEAN LYDefaultRawMode;
BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
BOOLEAN LYNewsPosting = NEWS_POSTING; /* News posting supported? */
BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
BOOLEAN LYRawMode;
BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
BOOLEAN LYUseDefaultRawMode = TRUE;
BOOLEAN LYUseMouse = FALSE;
BOOLEAN LYisConfiguredForX = FALSE;
BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
BOOLEAN UCSaveBookmarksInUnicode = FALSE;
BOOLEAN bookmark_start = FALSE;
BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
BOOLEAN crawl = FALSE;		/* Do crawl? */
BOOLEAN keep_mime_headers = FALSE; /* Include mime headers with source dump */
BOOLEAN more = FALSE;		/* is there more text to display? */
BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
BOOLEAN scan_for_buried_news_references = TRUE;
BOOLEAN startfile_ok = FALSE;
BOOLEAN startfile_stdin = FALSE;
BOOLEAN traversal = FALSE;	/* Do traversals? */
char *BookmarkPage = NULL;	/* the name of the current bookmark page */
char *LYCookieAcceptDomains = NULL; /* domains to accept all cookies */
char *LYCookieLooseCheckDomains = NULL;  /* check loosely   */
char *LYCookieQueryCheckDomains = NULL;  /* check w/a query */
char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
char *LYCookieSAcceptDomains = NULL; /* domains to accept all cookies */
char *LYCookieSLooseCheckDomains = NULL;  /* check loosely   */
char *LYCookieSQueryCheckDomains = NULL;  /* check w/a query */
char *LYCookieSRejectDomains = NULL; /* domains to reject all cookies */
char *LYCookieSStrictCheckDomains = NULL; /* check strictly  */
char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
char *LYHostName = NULL;		/* treat as a local host name */
char *LYLocalDomain = NULL;	/* treat as a local domain tail */
char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
char *LynxHome = NULL;		/* the default Home HREF. */
char *LynxSigFile = NULL;	/* Signature file, in or off home */
char *UCAssume_MIMEcharset = NULL;
char *URLDomainPrefixes = NULL;
char *URLDomainSuffixes = NULL;
char *authentication_info[2] = {NULL, NULL}; /* Id:Password for protected documents */
char *bookmark_page = NULL;	/* the name of the default bookmark page */
char *editor = NULL;		/* the name of the current editor */
char *form_get_data = NULL;	/* User data for get form */
char *form_post_data = NULL;	/* User data for post form */
char *global_extension_map = NULL;  /* global mime.types */
char *global_type_map = NULL;	/* global mailcap */
char *helpfile = NULL;		/* the main help file */
char *helpfilepath = NULL;	/* the path to the help file set */
char *homepage = NULL;		/* home page or main screen */
char *http_error_file = NULL;	/* Place HTTP status code in this file */
char *indexfile = NULL;		/* an index file if there is one */
char *jumpfile = NULL;		/* the name of the default jumps file */
char *jumpprompt = NULL;		/* the default jumps prompt */
char *language = NULL;		/* preferred language */
char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
char *lynx_cmd_script;		/* file to read keystroke commands, if any */
char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
char *lynxjumpfile = NULL;	/* the current jump file URL */
char *lynxlinksfile = NULL;	/* the current visited links file URL */
char *lynxlistfile = NULL;	/* the current list file URL */
char *original_dir = NULL;	/* the original directory */
char *personal_extension_map = NULL;/* .mime.types */
char *personal_mail_address = NULL; /* the users mail address */
char *personal_type_map = NULL;	   /* .mailcap */
char *pref_charset = NULL;	/* preferred character set */
char *proxyauth_info[2] = {NULL, NULL}; /* Id:Password for protected proxy servers */
char *startfile = NULL;		/* the first file */
char *startrealm = NULL;		/* the startfile realm */
char *system_mail = NULL;	/* The path for sending mail */
char *system_mail_flags = NULL;	/* Flags for sending mail */
char *x_display = NULL;		/* display environment variable */
HistInfo history[MAXHIST];
int AlertSecs;			/* time-delay for HTAlert() messages   */
int DebugSecs;			/* time-delay for HTProgress messages */
int InfoSecs;			/* time-delay for Information messages */
int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
int LYStatusLine = -1;		/* Line for statusline() if > -1 */
int LYcols = DFT_COLS;
int LYlines = DFT_ROWS;
int MessageSecs;			/* time-delay for important Messages   */
int ReplaySecs;			/* time-delay for command-scripts */
int ccount = 0;			/* Starting number for lnk#.dat files in crawls */
int dump_output_width = 0;
int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
int nhist = 0;			/* number of history entries */
int nlinks = 0;			/* number of links in memory */
int outgoing_mail_charset = -1;	/* translate mail to this charset */
LinkInfo links[MAXLINKS];
d444 5
a448 5
BOOLEAN BibP_bibhost_available = FALSE;  /* until check succeeds  */
BOOLEAN BibP_bibhost_checked = FALSE;  /*  until LYCheckBibHost   */
BOOLEAN no_goto_bibp = FALSE;
char *BibP_bibhost = NULL;	 /* local server for bibp: links  */
char *BibP_globalserver = NULL;   /* global server for bibp: links */
d452 3
a454 3
BOOLEAN persistent_cookies = FALSE; /* disabled by default! */
char *LYCookieFile = NULL;	/* cookie read file */
char *LYCookieSaveFile = NULL;	/* cookie save file */
d458 1
a458 1
BOOLEAN nested_tables =
d467 7
a473 7
BOOLEAN LYShowTransferRate = TRUE;
int LYTransferRate = rateKB;
char * LYTransferName = NULL;

char *XLoadImageCommand = NULL;	/* Default image viewer for X */
BOOLEAN LYNoISMAPifUSEMAP = FALSE; /* Omit ISMAP link if MAP present? */
int LYHiddenLinks = HIDDENLINKS_SEPARATE; /* Show hidden links? */
d475 2
a476 2
int Old_DTD = NO;
static BOOL DTD_recovery = NO;
d479 1
a479 1
FILE *LYTraceLogFP = NULL;		/* Pointer for TRACE log  */
d481 2
a482 2
char *LYTraceLogPath = NULL;		/* Path for TRACE log	   */
BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?	   */
d484 10
a493 10
BOOLEAN LYSeekFragMAPinCur = TRUE;
BOOLEAN LYSeekFragAREAinCur = TRUE;
BOOLEAN LYStripDotDotURLs = TRUE;	/* Try to fix ../ in some URLs? */
BOOLEAN LYForceSSLCookiesSecure = FALSE;
BOOLEAN LYNoCc = FALSE;
BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
BOOLEAN LYPrependBaseToSource = TRUE;
BOOLEAN LYPrependCharsetToSource = TRUE;
BOOLEAN LYQuitDefaultYes = QUIT_DEFAULT_YES;
BOOLEAN dont_wrap_pre = FALSE;
d495 1
a495 1
int cookie_noprompt;
d498 1
a498 1
int ssl_noprompt = FORCE_PROMPT_DFT;
d501 1
a501 1
int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/
d504 2
a505 2
BOOL ok_justify = TRUE;
int justify_max_void_percent = 35;
d509 1
a509 1
BOOLEAN LYLocaleCharset = FALSE;
d513 1
a513 1
BOOLEAN with_backspaces = FALSE;
d517 2
a518 2
int scrsize_x = 0;
int scrsize_y = 0;
d521 1
a521 1
BOOL force_empty_hrefless_a = FALSE;
d524 2
a525 2
BOOL textfields_need_activation = FALSE;
BOOL textfields_activation_option = FALSE;
d528 1
a528 1
BOOLEAN textfield_prompt_at_left_edge = FALSE;
d531 1
a531 1
char* hidden_link_marker = NULL;
d535 3
a537 3
BOOLEAN display_partial_flag = TRUE; /* Display document during download */
BOOLEAN debug_display_partial = FALSE; /* Show with MessageSecs delay */
int partial_threshold = -1;  /* # of lines to be d/l'ed until we repaint */
d540 3
a542 3
BOOLEAN LYNonRestartingSIGWINCH = FALSE;
BOOLEAN LYReuseTempfiles = FALSE;
BOOLEAN LYUseBuiltinSuffixes = TRUE;
d545 1
a545 1
int LYNoZapKey = 0; /* 0: off (do z checking), 1: full, 2: initially */
d552 1
a552 1
BOOLEAN FileInitAlreadyDone = FALSE;
d554 7
a560 7
static BOOLEAN stack_dump = FALSE;
static char *terminal = NULL;
static char *pgm;
static BOOLEAN number_links = FALSE;
static BOOLEAN number_fields = FALSE;
static BOOLEAN LYPrependBase = FALSE;
static HTList *LYStdinArgs = NULL;
d580 1
a580 1
static BOOLEAN no_options_further=FALSE; /* set to TRUE after '--' argument */
d583 3
a585 3
static BOOL parse_arg (char **arg, unsigned mask, int *i);
static void print_help_and_exit (int exit_status) GCC_NORETURN;
static void print_help_strings (const char * name, const char * help, const char * value, BOOLEAN option);
d588 3
a590 3
BOOLEAN LYNoCore = NO_FORCED_CORE_DUMP;
BOOLEAN restore_sigpipe_for_children = FALSE;
static void FatalProblem (int sig);
d594 1
a594 1
char *lynx_lss_file = NULL;
d598 1
a598 1
static void LY_set_ctrl_break(int setting)
d604 1
a604 1
static int LY_get_ctrl_break(void)
d613 1
a613 1
static void reset_break(void)
d620 1
a620 1
static int is_windows_nt(void)
d634 1
a634 1
static void free_lynx_globals (void)
d738 1
a738 1
static void LYStdinArgs_free (void)
d754 2
a755 2
void exit_immediately (
	int		code)
d793 1
a793 1
static void FixCharacters(void)
d811 3
a813 3
static int argncmp (
	char*		str,
	char*		what)
d824 3
a826 3
static void tildeExpand (
	char **	pathname,
	BOOLEAN	embedded)
d856 3
a858 3
static BOOL GetStdin (
	char **	buf,
	BOOL		marker)
d871 1
a871 1
static BOOL cleanup_win32(DWORD fdwCtrlType)
d887 3
a889 3
static void append_ssl_version (
	char **	target,
	char *		separator)
d929 3
a931 3
int main (
	int		argc,
	char **	argv)
d2154 1
a2154 1
void LYRegisterLynxProtocols (void)
d2181 1
a2181 1
void reload_read_cfg (void)
d2325 1
a2325 1
static void disable_pausing (void)
d2334 1
a2334 1
static void force_dump_mode (void)
d2359 1
a2359 1
   const char *name;
d2384 1
a2384 1
   const char *help_string;
d2389 3
a2391 3
static int parse_authentication (
	char *			next_arg,
	char **		result)
d2421 2
a2422 2
static int anonymous_fun (
	char *			next_arg GCC_UNUSED)
d2431 2
a2432 2
static int assume_charset_fun (
	char *			next_arg)
d2445 2
a2446 2
static int assume_local_charset_fun (
	char *			next_arg)
d2453 2
a2454 2
static int assume_unrec_charset_fun (
	char *			next_arg)
d2461 2
a2462 2
static int auth_fun (
	char *			next_arg)
d2469 2
a2470 2
static int base_fun (
	char *			next_arg GCC_UNUSED)
d2488 2
a2489 2
static int cache_fun (
	char *			next_arg)
d2502 2
a2503 2
static int child_fun (
	char *			next_arg GCC_UNUSED)
d2512 2
a2513 2
static int color_fun (
	char *			next_arg GCC_UNUSED)
d2526 2
a2527 2
static int convert_to_fun (
	char *			next_arg)
d2569 2
a2570 2
static int crawl_fun (
	char *			next_arg GCC_UNUSED)
d2578 2
a2579 2
static int display_fun (
	char *			next_arg)
d2589 2
a2590 2
static int display_charset_fun (
	char *			next_arg)
d2608 2
a2609 2
static int dump_output_fun (
	char *			next_arg GCC_UNUSED)
d2616 2
a2617 2
static int editor_fun (
	char *			next_arg)
d2626 2
a2627 2
static int error_file_fun (
	char *			next_arg)
d2640 2
a2641 2
static int exec_fun (
	char *			next_arg GCC_UNUSED)
d2653 2
a2654 2
static int get_data_fun (
	char *			next_arg GCC_UNUSED)
d2688 2
a2689 2
static int help_fun (
	char *			next_arg GCC_UNUSED)
d2696 2
a2697 2
static int hiddenlinks_fun (
	char *			next_arg)
d2717 2
a2718 2
static int homepage_fun (
	char *			next_arg)
d2728 2
a2729 2
static int mime_header_fun (
	char *			next_arg GCC_UNUSED)
d2744 2
a2745 2
static int newschunksize_fun (
	char *			next_arg)
d2760 2
a2761 2
static int newsmaxchunk_fun (
	char *			next_arg)
d2777 2
a2778 2
static int nobold_fun (
	char *			next_arg GCC_UNUSED)
d2785 2
a2786 2
static int nobrowse_fun (
	char *			next_arg GCC_UNUSED)
d2793 2
a2794 2
static int nocolor_fun (
	char *			next_arg GCC_UNUSED)
d2805 2
a2806 2
static int nopause_fun (
	char *			next_arg GCC_UNUSED)
d2813 2
a2814 2
static int noreverse_fun (
	char *			next_arg GCC_UNUSED)
d2821 2
a2822 2
static int nounderline_fun (
	char *			next_arg GCC_UNUSED)
d2830 2
a2831 2
static int nozap_fun (
	char *			next_arg)
d2844 2
a2845 2
static int pauth_fun (
	char *			next_arg)
d2852 2
a2853 2
static int post_data_fun (
	char *			next_arg GCC_UNUSED)
d2884 2
a2885 2
static char *show_restriction (
	const char *		name)
d2904 2
a2905 2
static int restrictions_fun (
	char *			next_arg)
d2907 3
a2909 3
    static const struct {
	const char *name;
	const char *help;
d3024 1
a3024 1
    static const char *Usage[] = {
d3032 2
a3033 2
    const char *name;
    const char *value;
d3092 2
a3093 2
static int selective_fun (
	char *			next_arg GCC_UNUSED)
d3100 2
a3101 2
static int source_fun (
	char *			next_arg GCC_UNUSED)
d3111 2
a3112 2
static int traversal_fun (
	char *			next_arg GCC_UNUSED)
d3125 2
a3126 2
static int version_fun (
	char *			next_arg GCC_UNUSED)
d3200 2
a3201 2
static int width_fun (
	char *			next_arg)
d3214 2
a3215 2
static int scrsize_fun (
	char *			next_arg)
d3241 1
a3241 1
static Config_Type Arg_Table [] =
d3875 5
a3879 5
static void print_help_strings (
	const char *	name,
	const char *	help,
	const char *	value,
	BOOLEAN	option)
d3927 1
a3927 1
static void print_help_and_exit (int exit_status)
d3988 4
a3991 4
static int arg_eqs_parse (
	const char *	a,
	char *		b,
	char **	c)
d4047 4
a4050 4
static BOOL parse_arg (
	char **	argv,
	unsigned	mask,
	int *		i)
d4213 2
a4214 2
static void FatalProblem (
	int		sig)
@


1.1.3.6
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d51 1
a51 1
#undef gettext			/* Solaris locale.h prototypes gettext() */
d71 1
a71 1
BOOLEAN socks_flag = TRUE;
d83 1
a83 1
char *mail_adrs = NULL;		/* the mask for a VMS mail transport */
a93 1

d95 1
a95 1
char *syslog_txt = NULL;	/* syslog arb text for session */
d103 1
a103 1
int LYAutoUncacheDirLists = 2;	/* default dired uncaching behavior */
a113 1

a122 1

a130 1

d135 1
a135 1
LOCAL_EXECUTION_LINKS_ON_BUT_NOT_REMOTE;
d138 2
a139 2
#if defined(LYNXCGI_LINKS) && !defined(VMS)	/* WebSter Mods -jkt */
char *LYCgiDocumentRoot = NULL;	/* DOCUMENT_ROOT in the lynxcgi env */
d143 1
a143 2
BOOLEAN enable_scrollback = TRUE;

d145 1
a145 1
BOOLEAN enable_scrollback = FALSE;
d149 2
a150 3
int display_lines;		/* number of lines in display */
int www_search_result = -1;

a152 1

a154 1

a157 1

d163 2
a164 2
int LYShowColor = SHOW_COLOR_UNKNOWN;	/* to show or not */
int LYrcShowColor = SHOW_COLOR_UNKNOWN;		/* ... last used */
d167 1
a167 1
BOOLEAN LYUseFormsOptions = TRUE;	/* use forms-based options menu */
d170 1
a170 1
BOOLEAN LYJumpFileURL = FALSE;	/* always FALSE the first time */
d172 3
a174 3
BOOLEAN LYRestricted = FALSE;	/* whether we have -anonymous option */
BOOLEAN LYShowCursor = SHOW_CURSOR;	/* to show or not to show */
BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS;	/* Show the links underlined vs bold */
d176 1
a176 1
BOOLEAN LYUserSpecifiedURL = TRUE;	/* always TRUE  the first time */
d179 2
a180 2
BOOLEAN LYinternal_flag = FALSE;	/* override no-cache b/c internal link */
BOOLEAN LYoverride_no_cache = FALSE;	/*override no-cache b/c history etc */
d192 1
a192 1
BOOLEAN ftp_passive = FTP_PASSIVE;	/* TRUE if doing ftp in passive mode */
d195 1
a195 1
BOOLEAN goto_buffer = GOTOBUFFER;	/* TRUE if offering default goto URL */
d198 1
a198 1
BOOLEAN jump_buffer = JUMPBUFFER;	/* TRUE if offering default shortcut */
d204 1
a204 1
BOOLEAN recent_sizechange = FALSE;	/* the window size changed recently? */
d207 1
a207 1
BOOLEAN verbose_img = VERBOSE_IMAGES;	/* show filenames or not */
a212 1

a283 1

d300 1
a300 1
BOOLEAN dj_is_bash = FALSE;	/* Check for bash shell under DJGPP */
d309 1
a309 1
#define	TIMEOUT	180		/* 1998/03/30 (Mon) 14:50:44 */
a331 1

a333 1

d338 3
a340 3
BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES;	/* take all cookies? */
BOOLEAN LYCancelledFetch = FALSE;	/* TRUE if cancelled binary fetch */
BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;	/* Collapse serial BRs? */
d345 4
a348 4
BOOLEAN LYNewsPosting = NEWS_POSTING;	/* News posting supported? */
BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?         */
BOOLEAN LYNoRefererForThis = FALSE;	/* No Referer header for this URL? */
BOOLEAN LYNoRefererHeader = FALSE;	/* Never send Referer header?     */
d351 1
a351 1
BOOLEAN LYSetCookies = SET_COOKIES;	/* Process Set-Cookie headers? */
d356 1
a356 1
BOOLEAN UCForce8bitTOUPPER = FALSE;	/* override locale for case-conversion? */
d359 1
a359 1
BOOLEAN check_realm = FALSE;	/* Restrict to the starting realm? */
d362 1
a362 1
BOOLEAN keep_mime_headers = FALSE;	/* Include mime headers with source dump */
d365 1
a365 1
BOOLEAN no_url_redirection = FALSE;	/* Don't follow URL redirections */
d372 11
a382 11
char *LYCookieAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieLooseCheckDomains = NULL;		/* check loosely   */
char *LYCookieQueryCheckDomains = NULL;		/* check w/a query */
char *LYCookieRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieSLooseCheckDomains = NULL;	/* check loosely   */
char *LYCookieSQueryCheckDomains = NULL;	/* check w/a query */
char *LYCookieSRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSStrictCheckDomains = NULL;	/* check strictly  */
char *LYCookieStrictCheckDomains = NULL;	/* check strictly  */
char *LYHostName = NULL;	/* treat as a local host name */
d384 2
a385 2
char *LYUserAgent = NULL;	/* Lynx User-Agent header          */
char *LYUserAgentDefault = NULL;	/* Lynx default User-Agent header  */
d391 1
a391 2
char *authentication_info[2] =
{NULL, NULL};			/* Id:Password for protected documents */
d396 1
a396 1
char *global_extension_map = NULL;	/* global mime.types */
d404 1
a404 1
char *jumpprompt = NULL;	/* the default jumps prompt */
d415 3
a417 3
char *personal_extension_map = NULL;	/* .mime.types */
char *personal_mail_address = NULL;	/* the users mail address */
char *personal_type_map = NULL;	/* .mailcap */
d419 1
a419 2
char *proxyauth_info[2] =
{NULL, NULL};			/* Id:Password for protected proxy servers */
d421 1
a421 1
char *startrealm = NULL;	/* the startfile realm */
d433 1
a433 1
int MessageSecs;		/* time-delay for important Messages   */
d444 2
a445 2
BOOLEAN BibP_bibhost_available = FALSE;		/* until check succeeds  */
BOOLEAN BibP_bibhost_checked = FALSE;	/*  until LYCheckBibHost   */
d447 2
a448 2
char *BibP_bibhost = NULL;	/* local server for bibp: links  */
char *BibP_globalserver = NULL;	/* global server for bibp: links */
d452 1
a452 1
BOOLEAN persistent_cookies = FALSE;	/* disabled by default! */
d460 1
a460 1
TRUE
d462 1
a462 1
FALSE				/* see 2001-08-15  */
d464 1
a464 1
 ;
d469 1
a469 3
int LYAcceptEncoding = encodingALL;
int LYAcceptMedia = mediaOpt1;
char *LYTransferName = NULL;
d472 2
a473 2
BOOLEAN LYNoISMAPifUSEMAP = FALSE;	/* Omit ISMAP link if MAP present? */
int LYHiddenLinks = HIDDENLINKS_SEPARATE;	/* Show hidden links? */
d479 1
a479 1
FILE *LYTraceLogFP = NULL;	/* Pointer for TRACE log  */
d481 2
a482 2
char *LYTraceLogPath = NULL;	/* Path for TRACE log      */
BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?        */
d531 1
a531 1
char *hidden_link_marker = NULL;
d535 3
a537 3
BOOLEAN display_partial_flag = TRUE;	/* Display document during download */
BOOLEAN debug_display_partial = FALSE;	/* Show with MessageSecs delay */
int partial_threshold = -1;	/* # of lines to be d/l'ed until we repaint */
d545 1
a545 1
int LYNoZapKey = 0;		/* 0: off (do z checking), 1: full, 2: initially */
d579 7
a585 6
static BOOL parse_arg(char **arg, unsigned mask, int *countp);
static void print_help_and_exit(int exit_status) GCC_NORETURN;
static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       BOOLEAN option);
d590 1
a590 1
static void FatalProblem(int sig);
d600 1
a600 1
    (void) signal(SIGINT, (setting ? SIG_DFL : SIG_IGN));
a606 1

d609 1
a609 1
    __dpmi_int(0x21, &regs);
d632 1
d634 1
a634 1
static void free_lynx_globals(void)
d643 1
a643 1
#ifdef LYNXCGI_LINKS		/* WebSter Mods -jkt */
d736 1
a736 1
 * This function frees the LYStdinArgs list.  - FM
d738 1
a738 1
static void LYStdinArgs_free(void)
d746 1
a746 1
    while (NULL != (argument = (char *) HTList_nextObject(cur))) {
d754 2
a755 1
void exit_immediately(int code)
a771 1
/* *INDENT-OFF* */
a791 1
/* *INDENT-ON* */
d796 2
a797 1
    int work1[256], work2[256];
d801 2
a802 2
	work1[c] = keymap[c + 1];
	work2[c] = key_override[c + 1];
d805 2
a806 2
	keymap[IBM1047[c] + 1] = work1[c];
	key_override[IBM1047[c] + 1] = work2[c];
d811 16
a826 2
static void tildeExpand(char **pathname,
			BOOLEAN embedded)
d841 1
a841 1
	&& temp[0] == '~') {
d843 1
a843 1
	    && temp[2] != '\0') {
d856 3
a858 2
static BOOL GetStdin(char **buf,
		     BOOL marker)
d861 1
a861 1
	&& (!marker || strncmp(*buf, "---", 3) != 0)) {
d887 3
a889 2
static void append_ssl_version(char **target,
			       char *separator)
d913 1
a913 1
    LYstrncpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion) - 1);
d929 3
a931 2
int main(int argc,
	 char **argv)
d933 2
a934 2
    int i;			/* indexing variable */
    int status = 0;		/* exit status */
a940 1

d959 1
a959 1
    ftp_lasthost = calloc(1, sizeof(char));
d963 1
a963 1
    memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
d974 3
a976 2
	if (err != 0) {
	    puts(gettext("No Winsock found, sorry."));
d988 1
a988 1
#if 0				/* defined(__CYGWIN__) - does not work with screen */
d1006 1
d1014 1
a1014 1
    __djgpp_set_sigquit_key(0x082D);	/* Bind ALT-X to SIGQUIT */
d1019 1
a1019 1
	&& (strstr(LYPathLeaf(cp), "sh") != NULL))
d1033 1
a1033 2
    if (LYGetEnv("TERM") == NULL)
	putenv("TERM=vt100");
d1038 1
a1038 1
     * Set up the argument list.
d1047 1
a1047 1
     * Act on -help NOW, so we only output the help and exit.  - FM
d1050 8
a1057 1
	parse_arg(&argv[i], 1, &i);
d1062 2
a1063 2
     * Register the final function to be executed when being exited.  Will
     * display memory leaks if LY_FIND_LEAKS is defined.
d1067 1
a1067 1
     * Register the function which will free our allocated globals.
d1072 1
d1075 1
a1075 1
     * LOCALE support for international characters.
d1084 1
a1084 1
    bindtextdomain("lynx", cp);
d1086 1
a1086 1
    textdomain("lynx");
d1090 1
a1090 1
     * Initialize our startup and global variables.
d1094 1
a1094 1
     * Need this for Ultrix.
d1101 1
a1101 1
     * Zero the links and history struct arrays.
d1103 2
a1104 2
    memset((void *) links, 0, sizeof(LinkInfo) * MAXLINKS);
    memset((void *) history, 0, sizeof(HistInfo) * MAXHIST);
d1106 1
a1106 1
     * Zero the MultiBookmark arrays.
d1108 2
a1109 3
    memset((void *) MBM_A_subbookmark, 0, sizeof(char) * (MBM_V_MAXFILES + 1));
    memset((void *) MBM_A_subdescript, 0, sizeof(char) * (MBM_V_MAXFILES + 1));

d1114 5
a1118 5
    AlertSecs = SECS2Secs(ALERTSECS);
    DebugSecs = SECS2Secs(DEBUGSECS);
    InfoSecs = SECS2Secs(INFOSECS);
    MessageSecs = SECS2Secs(MESSAGESECS);
    ReplaySecs = SECS2Secs(REPLAYSECS);
d1178 1
a1178 1
	puts(gettext("You MUST define a valid TMP or TEMP area!"));
d1183 1
a1183 1
#ifdef WIN_EX			/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
d1202 1
d1226 1
a1226 1
	 && mkdir(lynx_temp_space, 0700) < 0
d1229 1
a1229 1
	|| !S_ISDIR(dir_info.st_mode)) {
d1235 1
d1256 1
a1256 1
    StrAllocCopy(BibP_bibhost, "http://bibhost/");	/* protocol specified. */
d1260 4
a1263 3
     * Disable news posting if the compilation-based LYNewsPosting value is
     * FALSE.  This may be changed further down via lynx.cfg or the
     * -restriction command line switch.  - FM
d1270 5
a1274 4
     * Set up trace, the anonymous account defaults, validate restrictions,
     * and/or the nosocks flag, if requested, and an alternate configuration
     * file, if specified, NOW.  Also, if we only want the help menu, output
     * that and exit.  - FM
d1286 13
a1298 11
     * If we have a lone "-" switch for getting arguments from stdin, get them
     * NOW, and act on the relevant ones, saving the others into an HTList for
     * handling after the other initializations.  The primary purpose of this
     * feature is to allow for the potentially very long command line that can
     * be associated with post or get data.  The original implementation
     * required that the lone "-" be the only command line argument, but that
     * precluded its use when the lynx command is aliased with other arguments. 
     * When interactive, the stdin input is terminated by by Control-D on Unix
     * or Control-Z on VMS, and each argument is terminated by a RETURN.  When
     * the argument is -get_data or -post_data, the data are terminated by a
     * "---" string, alone on the line (also terminated by RETURN).  - FM
d1317 2
a1318 2
	    if (parse_arg(&noargv[0], 2, (int *) 0) == FALSE
		&& buf[0] != '\0') {
d1337 1
d1344 2
a1345 2
     * If we had -validate set all of the restrictions and disallow a TRACE log
     * NOW.  - FM
d1353 4
a1356 3
     * If we didn't get and act on a -validate or -anonymous switch, but can
     * verify that this is the anonymous account, set the default restrictions
     * for that account and disallow a TRACE log NOW.  - FM
d1361 1
a1361 1
	!strcasecomp((LYGetEnv("USER") == NULL ? " " : LYGetEnv("USER")),
d1365 1
a1365 1
	STREQ((char *) cuserid((char *) NULL), ANONYMOUS_USER)
d1367 1
a1367 1
	STREQ(((char *) getlogin() == NULL ? " " : getlogin()), ANONYMOUS_USER)
d1377 1
a1377 1
     * Set up the TRACE log path, and logging if appropriate.  - FM
d1387 1
a1387 1
     * Open command-script, if specified
d1394 1
a1394 1
     * Open command-logging, if specified
d1403 1
a1403 1
     * Set up the default jump file stuff.  - FM
d1419 2
a1420 2
     * If no alternate configuration file was specified on the command line,
     * see if it's in the environment.
d1423 2
a1424 2
	if (((cp = LYGetEnv("LYNX_CFG")) != NULL) ||
	    (cp = LYGetEnv("lynx_cfg")) != NULL)
d1429 2
a1430 2
     * If we still don't have a configuration file, use the userdefs.h
     * definition.
d1435 1
a1435 1
#ifndef _WINDOWS		/* avoid the whole ~ thing for now */
d1440 2
a1441 1
     * If the configuration file is not available, inform the user and exit.
d1444 2
a1445 3
	fprintf(stderr,
		gettext("\nConfiguration file %s is not available.\n\n"),
		lynx_cfg_file);
d1450 2
a1451 2
     * Make sure we have the character sets declared.  This will initialize the
     * CHARTRANS handling.  - KW
d1458 4
a1461 4
     * (**) in Lynx, UCLYhndl_HTFile_for_unspec and UCLYhndl_for_unrec may be
     * valid or not, but current_char_set and UCLYhndl_for_unspec SHOULD ALWAYS
     * be a valid charset.  Initialized here and may be changed later from
     * lynx.cfg/command_line/options_menu.  - LP (**)
d1464 1
a1464 1
     * Set up the compilation default character set.  - FM
d1471 1
a1471 1
	current_char_set = safeUCGetLYhndl_byMIME(CHARACTER_SET);
d1473 1
a1473 1
     * Set up HTTP default for unlabeled charset (iso-8859-1).
d1480 1
a1480 1
     * Make sure we have the edit map declared.  - FM
d1486 1
d1489 2
a1490 2
     * If no alternate lynx-style file was specified on the command line, see
     * if it's in the environment.
d1493 2
a1494 2
	if (((cp = LYGetEnv("LYNX_LSS")) != NULL) ||
	    (cp = LYGetEnv("lynx_lss")) != NULL)
d1499 2
a1500 1
     * If we still don't have a lynx-style file, use the userdefs.h definition.
d1508 2
a1509 1
     * If the lynx-style file is not available, inform the user and exit.
d1513 4
a1516 2
		lynx_lss_file);
    } else {
d1523 1
a1523 1
     * Set up default foreground and background colors.
d1529 1
a1529 1
     * Set the original directory, used for default download
d1539 1
a1539 1
     * Set the compilation default signature file.  - FM
d1541 1
a1541 1
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename) - 1);
d1557 1
a1557 1
     * Process the configuration file.
d1559 1
a1559 1
    read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);
d1562 1
a1562 1
     * Process the RC file.
d1584 1
a1584 1
    LYEnsureAbsoluteURL(&LynxHome, "LynxHome", FALSE);
d1587 1
a1587 2
     * Process any command line arguments not already handled.  - FM
     * May set startfile as a side-effect.
d1594 2
a1595 2
     * Process any stdin-derived arguments for a lone "-" which we've loaded
     * into LYStdinArgs.  - FM
d1602 2
a1603 2
	while (NULL != (my_args[0] = (char *) HTList_nextObject(cur))) {
	    parse_arg(my_args, 4, (int *) 0);
d1608 1
a1608 1
    if (current_char_set == auto_display_charset)	/* Better: explicit option */
d1614 2
a1615 2
     * If we are told to read the startfile from standard input, do it now,
     * after we have read all of the option data from standard input.
a1620 1

d1628 1
a1628 1
	if ((fp = LYOpenTemp(result, HTML_SUFFIX, "w")) != 0) {
d1649 1
a1649 1
     * Initialize other things based on the configuration read.
d1653 1
a1653 1
    if ((!Old_DTD) != TRUE)	/* skip if they are already initialized -HV */
d1655 1
a1655 1
	HTSwitchDTD(!Old_DTD);
d1671 1
a1671 1
	if (LYCookieFile == NULL) {
d1707 3
a1709 2
     * Check for a save space path in the environment.  If one was set in the
     * configuration file, that one will be overridden.  - FM
d1715 1
a1715 1
     * We have a save space path, make sure it's valid.  - FM
d1744 5
a1748 4
     * Set up the file extension and mime type maps from src/HTInit.c and the
     * global and personal mime.types and mailcap files.  These will override
     * any SUFFIX or VIEWER maps in userdefs.h or the configuration file, if
     * they overlap.
d1780 1
d1813 1
a1813 1
     * Check the -popup command line toggle.  - FM
d1820 1
a1820 1
     * Check the -show_cursor command line toggle.  - FM
d1827 1
a1827 1
     * Check the -base command line switch with -source.  - FM
d1834 4
a1837 3
     * Disable multiple bookmark support if not interactive, so it doesn't
     * crash on curses functions, or if the support was blocked via userdefs.h
     * and/or lynx.cfg, or via command line restrictions.  - FM
d1846 1
d1872 6
a1877 6
	__system_emulate_chdir |	/* handle `cd' internally */
	__system_handle_null_commands |		/* ignore cmds with no effect */
	__system_allow_long_cmds |	/* handle commands > 126 chars   */
	__system_use_shell |	/* use $SHELL if set */
	__system_allow_multiple_cmds |	/* allow `cmd1; cmd2; ...' */
	__system_redirect;	/* redirect internally */
d1880 2
a1881 2
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC | _STAT_DIRSIZE;
#endif /* __DJGPP__ */
d1908 1
a1908 1
	 * Since we're doing lots of TCP, just ignore SIGPIPE altogether.
d1910 5
a1914 4
	 * HTTCP.c should deal with a broken pipe for servers.  Rick Mallet's
	 * check after c = GetChar() in LYStrings.c should deal with a
	 * disconnected terminal.  So the runaway CPU time problem on Unix
	 * should not occur any more.
d1918 1
a1918 1
	    restore_sigpipe_for_children = TRUE;
d1925 1
a1925 1
     * Block Control-Z suspending if requested.  - FM
d1932 1
a1932 1
     * Check for a valid HEAD request.  - FM
d1936 1
a1936 1
		"The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n",
d1942 1
a1942 1
     * Check for a valid MIME headers request.  - FM
d1946 1
a1946 1
		"The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n",
d1952 1
a1952 1
     * Check for a valid traversal request.  - FM
d1956 1
a1956 1
		"The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n",
d1962 3
a1964 3
     * Finish setting up for an INTERACTIVE session.  Done here so that URL
     * guessing in LYEnsureAbsoluteURL() can be interruptible (terminal is in
     * raw mode, select() works).  -BL
d1968 1
a1968 1
	HTMLSRC_init_caches(FALSE);	/* do it before terminal is initialized */
d1979 3
a1981 2
     * If startfile is a file URL and the host is defaulted, force in
     * "//localhost", and if it's not an absolute URL, make it one.  - FM
d1983 1
a1983 1
    LYEnsureAbsoluteURL(&startfile, "STARTFILE", FALSE);
d1986 3
a1988 3
     * If homepage was specified and is a file URL with the host defaulted,
     * force in "//localhost", and if it's not an absolute URL, make it one.  -
     * FM
d1991 1
a1991 1
	LYEnsureAbsoluteURL(&homepage, "HOMEPAGE", FALSE);
d1995 3
a1997 2
     * If we don't have a homepage specified, set it to startfile.  Otherwise,
     * reset LynxHome.  - FM
d2006 1
a2006 1
     * Set up the inside/outside domain restriction flags.  - FM
d2009 2
a2010 2
#if !defined(HAVE_UTMP) || defined(VMS)		/* not selective */
	telnet_ok = (BOOL) (!no_inside_telnet && !no_outside_telnet && telnet_ok);
d2012 1
a2012 1
	news_ok = (BOOL) (!no_inside_news && !no_outside_news && news_ok);
d2014 2
a2015 2
	ftp_ok = (BOOL) (!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
d2018 1
a2018 1
	telnet_ok = (BOOL) (!no_inside_telnet && telnet_ok);
d2020 1
a2020 1
	news_ok = (BOOL) (!no_inside_news && news_ok);
d2022 2
a2023 2
	ftp_ok = (BOOL) (!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && rlogin_ok);
d2027 1
a2027 1
	telnet_ok = (BOOL) (!no_outside_telnet && telnet_ok);
d2029 1
a2029 1
	news_ok = (BOOL) (!no_outside_news && news_ok);
d2031 2
a2032 2
	ftp_ok = (BOOL) (!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_outside_rlogin && rlogin_ok);
d2036 2
a2037 2
     * Make sure our bookmark default strings are all allocated and
     * synchronized.  - FM
d2048 1
d2050 1
a2050 1
    LYOpenlog(syslog_txt);
a2052 4
    if (x_display != NULL && *x_display != '\0') {
	LYisConfiguredForX = TRUE;
    }

d2054 1
a2054 1
     * Here's where we do all the work.
d2058 2
a2059 1
	 * Finish setting up and start a NON-INTERACTIVE session.  - FM
d2071 4
a2077 21
	/*
	 * Normal argument processing puts non-options (URLs) into the Goto
	 * history.  Use this to dump all of the pages listed on the command
	 * line, or (if none are listed) via the startfile mechanism.
	 * history.
	 */
#ifdef EXTENDED_STARTFILE_RECALL
	HTAddGotoURL(startfile);
	for (i = HTList_count(Goto_URLs) - 1; i >= 0; --i) {
	    StrAllocCopy(startfile, (char *) HTList_objectAt(Goto_URLs, i));
	    CTRACE((tfp, "dumping %d:%d %s\n",
		    i + 1, HTList_count(Goto_URLs), startfile));
	    status = mainloop();
	    if (!nolist &&
		!crawl &&	/* For -crawl it has already been done! */
		links_are_numbered())
		printlist(stdout, FALSE);
	    if (i != 0)
		printf("\n");
	}
#else
a2082 1
#endif
d2085 3
a2087 2
	 * We want to save cookies picked up when in immediate dump mode. 
	 * Instead of calling cleanup() here, let's only call this one.  - BJP
d2095 1
a2095 1
	 * Start an INTERACTIVE session.  - FM
d2097 3
d2115 1
a2115 1
	ena_csi((BOOLEAN) (LYlowest_eightbit[current_char_set] > 155));
d2121 1
a2121 1
	if (!isendwin()) {
a2123 1

d2125 1
a2125 1
		resize_term(saved_scrsize_y, saved_scrsize_x);
d2132 1
a2132 1
    return (status);		/* though redundant, for compiler-warnings */
d2136 2
a2137 2
 * Called by HTAccessInit to register any protocols supported by lynx. 
 * Protocols added by lynx:
a2145 1

d2147 5
a2151 5
GLOBALREF HTProtocol LYLynxKeymap;
GLOBALREF HTProtocol LYLynxCGI;
GLOBALREF HTProtocol LYLynxIMGmap;
GLOBALREF HTProtocol LYLynxCookies;
GLOBALREF HTProtocol LYLynxStatusMessages;
d2154 1
a2154 1
void LYRegisterLynxProtocols(void)
d2165 3
a2167 2
 * Some stuff to reload lynx.cfg without restarting new lynx session, also load
 * options menu items and command-line options to make things consistent.
d2169 1
a2169 1
 * Called by user of interactive session by LYNXCFG://reload/ link.
d2171 1
a2171 1
 * Warning:  experimental, more main() reorganization required.
d2181 1
a2181 1
void reload_read_cfg(void)
a2184 1

d2186 9
a2194 8
     * no_option_save is always set for -anonymous and -validate.  It is better
     * to check for one or several specific restriction flags than for
     * 'LYRestricted', which doesn't get set for individual restrictions or for
     * -validate!  However, no_option_save may not be the appropriate one to
     * check - in that case, a new no_something should be added that gets
     * automatically set for -anonymous and -validate (and whether it applies
     * for -anonymous can be made installer- configurable in the usual way at
     * the bottom of userdefs.h).  - kw
d2205 7
a2211 6
     * Current user preferences are saved in a temporary file, to be read in
     * again after lynx.cfg has been read.  This avoids accidental changing of
     * the preferences file.  The regular preferences file doesn't even need to
     * exist, and won't be created as a side effect of this function.  Honoring
     * the no_option_save restriction may thus be unnecessarily restrictive,
     * but the check is currently still left in place.  - kw
d2218 1
a2218 1
    rcfp = LYOpenTemp(tempfile, ".rc", "w");
d2228 4
a2231 2
	return;			/* can not write the very own file :( */
    } {
d2235 2
a2236 3
	char *LYCookieFile_flag = NULL;
	char *LYCookieSaveFile_flag = NULL;

d2246 1
a2246 1
	memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
d2255 1
a2255 1
	source_cache_file_error = FALSE;	/* reset flag */
d2259 1
a2259 1
	 * Process the configuration file.
d2261 1
a2261 1
	read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);
d2264 1
a2264 1
	 * Process the temporary RC file.
d2279 1
a2279 1
	 * Process any command line arguments not already handled.
d2281 1
a2281 1
	/* Not implemented yet here */
d2284 2
a2285 2
	 * Process any stdin-derived arguments for a lone "-" which we've
	 * loaded into LYStdinArgs.
d2287 1
a2287 1
	/* Not implemented yet here */
d2290 1
a2290 1
	 * Initialize other things based on the configuration read.
d2297 4
a2300 4
	/* Not implemented yet here,
	 * a major problem: file paths
	 * like lynx_save_space, LYCookieFile etc.
	 */
d2310 1
a2310 2
		CTRACE((tfp,
			"cookie file can be changed in next session only, restored.\n"));
d2314 1
a2314 2
		CTRACE((tfp,
			"cookie save file can be changed in next session only, restored.\n"));
d2325 1
a2325 1
static void disable_pausing(void)
d2334 1
a2334 1
static void force_dump_mode(void)
d2357 4
a2360 3
typedef struct parse_args_type {
    const char *name;
    int type;
d2379 3
a2381 3
    /* If the NEED_NEXT_ARG flags is set, and the option was not specified
     * with an '=' character, then use the next argument in the argv list.
     */
d2383 4
a2386 3
      ParseData;
    const char *help_string;
} Config_Type;
d2389 3
a2391 2
static int parse_authentication(char *next_arg,
				char **result)
d2394 1
a2394 1
     * Authentication information for protected documents.
d2400 1
a2400 1
	memset(next_arg, ' ', strlen(next_arg));	/* Let's not show too much */
d2406 1
a2406 1
	if ((cp = strchr(auth_info, ':')) != 0) {	/* Pw */
d2411 1
a2411 1
	if (*auth_info) {	/* Id */
d2421 2
a2422 1
static int anonymous_fun(char *next_arg GCC_UNUSED)
d2431 2
a2432 1
static int assume_charset_fun(char *next_arg)
d2445 2
a2446 1
static int assume_local_charset_fun(char *next_arg)
d2453 2
a2454 1
static int assume_unrec_charset_fun(char *next_arg)
d2461 2
a2462 1
static int auth_fun(char *next_arg)
d2469 2
a2470 1
static int base_fun(char *next_arg GCC_UNUSED)
d2473 6
a2478 5
     * Treat -source equivalently to an interactive download with
     * LYPrefixBaseToSource configured to TRUE, so that a BASE tag is prepended
     * for text/html content types.  We normally treat the module-wide global
     * LYPrefixBaseToSource flag as FALSE with -source, but force it TRUE,
     * later, if LYPrependBase is set TRUE here.  - FM
d2488 2
a2489 1
static int cache_fun(char *next_arg)
d2494 1
a2494 1
     * Limit size.
d2496 1
a2496 2
    if (HTCacheSize < 2)
	HTCacheSize = 2;
d2502 2
a2503 1
static int child_fun(char *next_arg GCC_UNUSED)
d2512 2
a2513 1
static int color_fun(char *next_arg GCC_UNUSED)
d2526 2
a2527 1
static int convert_to_fun(char *next_arg)
a2532 1

d2535 1
a2535 1
	/*LYLowerCase(outformat); */
d2542 3
a2544 2
				 *cp4 != ';' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
d2549 1
a2549 2
		if (chndl < 0)
		    chndl = UCLYhndl_for_unrec;
d2552 1
a2552 1
			    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
d2569 2
a2570 1
static int crawl_fun(char *next_arg GCC_UNUSED)
d2578 2
a2579 1
static int display_fun(char *next_arg)
d2589 2
a2590 1
static int display_charset_fun(char *next_arg)
d2598 1
a2598 1
    if (i < 0) {		/* do nothing here: so fallback to lynx.cfg */
d2601 2
a2602 1
    } else
d2608 2
a2609 1
static int dump_output_fun(char *next_arg GCC_UNUSED)
d2616 2
a2617 1
static int editor_fun(char *next_arg)
d2626 2
a2627 1
static int error_file_fun(char *next_arg)
d2630 2
a2631 1
     * Output return (success/failure) code of an HTTP transaction.
d2640 2
a2641 1
static int exec_fun(char *next_arg GCC_UNUSED)
d2653 2
a2654 1
static int get_data_fun(char *next_arg GCC_UNUSED)
d2657 1
a2657 1
     * User data for GET form.
d2663 2
a2664 2
     * On Unix, conflicts with curses when interactive so let's force a dump. 
     * -CL
d2666 2
a2667 2
     * On VMS, mods have been made in LYCurses.c to deal with potential
     * conflicts, so don't force the dump here.  - FM
d2673 1
a2673 1
    StrAllocCopy(form_get_data, "?");	/* Prime the pump */
d2677 2
a2678 2
     * Build GET data for later.  Stop reading when we see a line with "---" as
     * its first three characters.
a2683 2
    CTRACE((tfp, "get_data:%s\n", *get_data));
    CTRACE((tfp, "get_data:%s\n", form_get_data));
d2688 2
a2689 1
static int help_fun(char *next_arg GCC_UNUSED)
d2691 1
a2691 1
    print_help_and_exit(0);
d2696 2
a2697 1
static int hiddenlinks_fun(char *next_arg)
a2698 1
    /* *INDENT-OFF* */
a2704 1
    /* *INDENT-ON* */
d2708 1
a2708 1
	    print_help_and_exit(-1);
d2717 2
a2718 1
static int homepage_fun(char *next_arg)
d2728 2
a2729 1
static int mime_header_fun(char *next_arg GCC_UNUSED)
d2732 1
a2732 1
     * Include mime headers and force source dump.
d2744 2
a2745 1
static int newschunksize_fun(char *next_arg)
d2760 2
a2761 1
static int newsmaxchunk_fun(char *next_arg)
d2777 2
a2778 1
static int nobold_fun(char *next_arg GCC_UNUSED)
d2780 2
a2781 2
    LYnoVideo(1);
    return 0;
d2785 2
a2786 1
static int nobrowse_fun(char *next_arg GCC_UNUSED)
d2788 2
a2789 2
    HTDirAccess = HT_DIR_FORBID;
    return 0;
d2793 2
a2794 1
static int nocolor_fun(char *next_arg GCC_UNUSED)
d2805 2
a2806 1
static int nopause_fun(char *next_arg GCC_UNUSED)
d2813 2
a2814 1
static int noreverse_fun(char *next_arg GCC_UNUSED)
d2816 2
a2817 2
    LYnoVideo(2);
    return 0;
d2821 2
a2822 1
static int nounderline_fun(char *next_arg GCC_UNUSED)
d2824 2
a2825 2
    LYnoVideo(4);
    return 0;
d2830 2
a2831 1
static int nozap_fun(char *next_arg)
d2833 1
a2833 1
    LYNoZapKey = 1;		/* everything but "initially" treated as "full" - kw */
d2839 1
a2839 1
    return 0;
d2844 2
a2845 1
static int pauth_fun(char *next_arg)
d2852 2
a2853 1
static int post_data_fun(char *next_arg GCC_UNUSED)
d2856 1
a2856 1
     * User data for POST form.
d2884 2
a2885 1
static char *show_restriction(const char *name)
d2904 2
a2905 1
static int restrictions_fun(char *next_arg)
a2906 1
    /* *INDENT-OFF* */
d3024 5
a3028 8
    /* *INDENT-ON* */

    static const char *Usage[] =
    {
	""
	,"USAGE: lynx -restrictions=[option][,option][,option]"
	,"List of Options:"
	,"  ?                 when used alone, list restrictions in effect."
d3037 1
a3037 1
	SetOutputMode(O_TEXT);
d3043 1
a3043 1
		|| !strcmp(table[j].name, "default")) {
d3048 2
a3049 1
	    print_help_strings(table[j].name, table[j].help, value, FALSE);
d3052 1
a3052 1
	for (j = 0;; j++) {
d3078 1
a3078 1
	SetOutputMode(O_BINARY);
d3081 1
a3081 1
	SetOutputMode(O_TEXT);
d3083 1
a3083 1
	SetOutputMode(O_BINARY);
d3092 2
a3093 1
static int selective_fun(char *next_arg GCC_UNUSED)
d3095 2
a3096 2
    HTDirAccess = HT_DIR_SELECTIVE;
    return 0;
d3100 2
a3101 1
static int source_fun(char *next_arg GCC_UNUSED)
d3111 2
a3112 1
static int traversal_fun(char *next_arg GCC_UNUSED)
d3125 2
a3126 1
static int version_fun(char *next_arg GCC_UNUSED)
d3130 1
a3130 1
    SetOutputMode(O_TEXT);
a3139 12

#if defined(NCURSES) && defined(HAVE_CURSES_VERSION)
    HTSprintf(&result, ", %s", curses_version());
#if defined(WIDEC_CURSES)
    HTSprintf(&result, "(wide)");
#endif
#elif defined(PDCURSES) && defined(PDC_BUILD)
    HTSprintf(&result, ", pdcurses %.3f", PDC_BUILD * 0.001);
#elif defined(USE_SLANG) && defined(SLANG_VERSION_STRING)
    HTSprintf(&result, ", s-lang %s", SLANG_VERSION_STRING);
#endif

d3176 8
a3183 5
    puts("");
    puts(gettext("Copyrights held by the University of Kansas, CERN, and other contributors."));
    puts(gettext("Distributed under the GNU General Public License."));
    puts(gettext("See http://lynx.isc.org/ and the online help for more information."));
    puts("");
d3185 1
a3185 1
    puts("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.");
d3187 1
a3187 1
    puts("See http://www.openssl.org/ for information about OpenSSL.");
d3189 1
a3189 1
    puts("");
d3192 1
a3192 1
    SetOutputMode(O_BINARY);
d3200 2
a3201 1
static int width_fun(char *next_arg)
a3204 1

d3214 2
a3215 1
static int scrsize_fun(char *next_arg)
a3240 1
/* *INDENT-OFF* */
d3459 1
a3459 1
      "get_data",	2|FUNCTION_ARG,		get_data_fun,
d3467 1
a3467 1
      "help",		1|FUNCTION_ARG,		help_fun,
d3612 1
a3612 1
      "nosocks",	2|UNSET_ARG,		socks_flag,
d3658 1
a3658 1
      "post_data",	2|FUNCTION_ARG,		post_data_fun,
d3733 1
a3733 1
      "show_cfg",	1|SET_ARG,		show_cfg,
a3873 1
/* *INDENT-ON* */
d3875 5
a3879 4
static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       BOOLEAN option)
d3886 1
a3886 1
    pad = field_width - (2 + option + (int) strlen(name));
d3888 1
a3888 1
    fprintf(stdout, "  %s%s", option ? "-" : "", name);
d3893 1
a3893 1
	    fputc(' ', stdout);
d3896 1
a3896 1
	fputc(' ', stdout);	/* at least one space */
d3902 2
a3903 2
    if (strchr(help, '\n') == 0) {
	fprintf(stdout, "%s", help);
d3912 1
a3912 1
		fputc(c, stdout);
d3914 1
a3914 1
		    fputc(' ', stdout);
d3916 1
a3916 1
		fputc(c, stdout);
d3924 1
a3924 1
    fputc('\n', stdout);
d3927 1
a3927 1
static void print_help_and_exit(int exit_status)
d3931 1
a3931 2
    if (pgm == NULL)
	pgm = "lynx";
d3933 1
a3933 1
    SetOutputMode(O_TEXT);
d3935 2
a3936 2
    fprintf(stdout, gettext("USAGE: %s [options] [file]\n"), pgm);
    fprintf(stdout, gettext("Options are:\n"));
d3939 1
a3939 1
		       "receive the arguments from stdin (enclose\n\
d3950 19
a3968 16
	case TOGGLE_ARG:
	case SET_ARG:
	    strcpy(temp, *(q->set_value) ? "on" : "off");
	    break;
	case UNSET_ARG:
	    strcpy(temp, *(q->set_value) ? "off" : "on");
	    break;
	case INT_ARG:
	    sprintf(temp, "%d", *(q->int_value));
	    break;
	case TIME_ARG:
	    sprintf(temp, SECS_FMT, (double) Secs2SECS(*(q->int_value)));
	    break;
	case STRING_ARG:
	    if ((value = *(q->str_value)) != 0
		&& !*value)
d3970 1
a3970 4
	    break;
	default:
	    value = 0;
	    break;
d3975 1
a3975 1
    SetOutputMode(O_BINARY);
d3977 1
a3977 1
    exit(exit_status);
d3988 4
a3991 3
static int arg_eqs_parse(const char *a,
			 char *b,
			 char **c)
d3998 2
a3999 2
	    || (*a == 0)
	    || (*b == 0)) {
d4035 1
a4035 1
		    result = 0;
d4047 4
a4050 11
/*
 * Parse an option.
 *	argv[] points to the beginning of the unprocessed options.
 *	mask is used to select certain options which must be processed
 *		before others.
 *	countp (if nonnull) points to an index into argv[], which is updated
 *		to reflect option values which are also parsed.
 */
static BOOL parse_arg(char **argv,
		      unsigned mask,
		      int *countp)
a4053 1

d4055 1
a4055 2
    static char *nonoption = 0;
    static BOOLEAN no_options_further = FALSE;	/* set to TRUE after '--' argument */
a4058 12
    CTRACE((tfp, "parse_arg(arg_name=%s, mask=%d, count=%d)\n",
	    arg_name, mask, countp ? *countp : -1));

#if EXTENDED_STARTFILE_RECALL
    if (mask == ((countp != 0) ? 0 : 1)) {
	no_options_further = FALSE;
	/* want to reset nonoption when beginning scan for --stdin */
	if (nonoption != 0) {
	    FREE(nonoption);
	}
    }
#endif
d4061 1
a4061 1
     * Check for a command line startfile.  - FM
d4063 4
a4066 3
    if (*arg_name != '-'
#if EXTENDED_OPTION_LOGIC
	|| no_options_further == TRUE
d4068 1
a4068 1
	) {
d4070 2
a4071 11
	/*
	 * On the last pass (mask==4), check for cases where we may want to
	 * provide G)oto history for multiple startfiles.
	 */
	if (mask == 4) {
	    if (nonoption != 0) {
		LYEnsureAbsoluteURL(&nonoption, "NONOPTION", FALSE);
		HTAddGotoURL(nonoption);
		FREE(nonoption);
	    }
	    StrAllocCopy(nonoption, arg_name);
d4073 1
d4077 1
a4077 1
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 20:11:17 */
d4080 1
a4080 1
	    char *q = startfile;
d4082 4
a4085 3
	    while (*q++) {
		if (*q == '|')
		    *q = ':';
d4089 1
a4089 2
	CTRACE((tfp, "parse_arg startfile:%s\n", startfile));
	return (BOOL) (countp != 0);
d4092 1
a4092 1
    if (strcmp(arg_name, "--") == 0) {
d4102 3
a4104 2
     * Skip any lone "-" arguments, because we've loaded the stdin input into
     * an HTList structure for special handling.  - FM
d4109 2
a4110 3
    /* allow GNU-style options with -- prefix */
    if (*arg_name == '-')
	++arg_name;
d4112 1
a4112 1
    CTRACE((tfp, "parse_arg lookup(%s)\n", arg_name));
d4122 1
a4122 1
	    || (0 == arg_eqs_parse(p->name, arg_name, &next_arg))) {
d4130 2
a4131 2
		if ((countp != 0) && (next_arg != 0))
		    (*countp)++;
d4146 2
a4147 2
	    if (q->set_value != 0) {
		if (next_arg == 0) {
d4150 2
a4151 2
			*(q->set_value) = (BOOL) !(*(q->set_value));
			break;
d4153 2
a4154 2
			*(q->set_value) = TRUE;
			break;
d4156 2
a4157 2
			*(q->set_value) = FALSE;
			break;
d4159 8
a4166 8
		} else if (is_true(next_arg)) {
		    *(q->set_value) = TRUE;
		} else if (is_false(next_arg)) {
		    *(q->set_value) = FALSE;
		}
		/* deliberately ignore anything else - BL */
	    }
	    break;
d4169 6
a4174 6
	    fun = q->fun_value;
	    if (0 != fun) {
		if (-1 == (*fun) (next_arg)) {
		}
	    }
	    break;
d4177 3
a4179 3
	    if ((q->str_value != 0) && (next_arg != 0))
		StrAllocCopy(*(q->str_value), next_arg);
	    break;
d4182 3
a4184 3
	    if ((q->int_value != 0) && (next_arg != 0))
		*(q->int_value) = strtol(next_arg, &temp_ptr, 0);
	    break;
d4189 1
a4189 2

		if (1 == sscanf(next_arg, "%f", &ival)) {
d4205 1
a4205 2
    if (pgm == 0)
	pgm = "LYNX";
d4207 2
a4208 2
    fprintf(stderr, gettext("%s: Invalid Option: %s\n"), pgm, argv[0]);
    print_help_and_exit(-1);
d4213 2
a4214 1
static void FatalProblem(int sig)
d4217 1
a4217 1
     * Ignore further interrupts.  - mhc:  11/2/91
d4222 2
a4223 2
    (void) signal(SIGTERM, SIG_IGN);
    (void) signal(SIGINT, SIG_IGN);
d4233 1
a4233 1
     * Flush all messages.  - FM
d4239 1
a4239 1
     * Deal with curses, if on, and clean up.  - FM
d4254 1
a4254 1
     * Issue appropriate messages and abort or exit.  - FM
d4257 1
a4257 1
	fprintf(stderr, "\r\n\
d4274 9
a4282 22
#ifdef WIN_EX			/* 1998/08/09 (Sun) 09:58:25 */
	    {
		char *msg;

		switch (sig) {
		case SIGABRT:
		    msg = "SIGABRT";
		    break;
		case SIGFPE:
		    msg = "SIGFPE";
		    break;
		case SIGILL:
		    msg = "SIGILL";
		    break;
		case SIGSEGV:
		    msg = "SIGSEGV";
		    break;
		default:
		    msg = "Not-def";
		    break;
		}
		fprintf(stderr, "signal code = %s\n", msg);
d4284 2
d4290 1
a4290 1
	 * Exit and possibly dump core.
d4303 1
a4303 1
	 * Exit without dumping core.
@


1.1.3.7
log
@Lynx 2.8.6dev.5 amended with the 2.8.6dev.3-iz2 patch
@
text
@a481 2
long tables_disable = 0;

a3738 4
   PARSE_SET(
      "tables_disable",	4|INT_ARG,		tables_disable,
      "=NUMBER\nbits disable table support in certain situations"
   ),
@


1.1.3.8
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a197 1
BOOLEAN dump_links_only = FALSE;
d210 1
a377 1
BOOLEAN no_list = FALSE;
d450 1
a450 1
int crawl_count = 0;		/* Starting number for lnk#.dat files in crawls */
d482 2
a575 1
static BOOLEAN no_numbers = FALSE;
a1775 7
    if (no_numbers) {
	number_links = FALSE;
	number_fields = FALSE;
	keypad_mode = NUMBERS_AS_ARROWS;
	set_numbers_as_arrows();
    }

d2040 1
a2040 3
	} else if (no_numbers) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	} else if (!no_list) {
d2064 1
a2064 1
	    if (!no_list &&
d2073 1
a2073 1
	if (!no_list &&
d2519 1
a2519 1
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
d2521 1
a2521 1
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '"' &&
d3466 1
a3466 1
      "link",		4|NEED_INT_ARG,		crawl_count,
a3469 4
      "listonly",	4|TOGGLE_ARG,		dump_links_only,
      "with -dump, forces it to show only the list of links"
   ),
   PARSE_SET(
d3542 1
a3542 1
      "nolist",		4|SET_ARG,		no_list,
a3554 4
   PARSE_SET(
      "nonumbers",	4|SET_ARG,		no_numbers,
      "disable the link/form numbering feature in dumps"
   ),
d3741 4
@


1.1.3.9
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d1981 1
a1981 1
    if (isEmpty(homepage)) {
d2034 1
a2034 1
    if (non_empty(x_display)) {
d4143 1
a4143 1
	    CTRACE((tfp, "...arg:%s\n", NONNULL(next_arg)));
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a9 1
#include <HTAlert.h>
a14 1
#include <LYOptions.h>
a29 5
#include <LYShowInfo.h>

#ifdef VMS
#include <HTFTP.h>
#endif /* !DECNET */
a33 2
#include <io.h>
#include <sys/stat.h>
d40 6
d76 1
a76 1
#if USE_VMS_MAILER
a77 3
#endif

#ifdef VMS
a108 1
PUBLIC int LYAutoUncacheDirLists = 2; /* default dired uncaching behavior */
d142 1
a142 1
PUBLIC lynx_list_item_type *printers = NULL;
d144 1
a144 1
PUBLIC lynx_list_item_type *downloaders = NULL;
d147 1
a147 1
PUBLIC lynx_list_item_type *externals = NULL;
d150 1
a150 1
PUBLIC lynx_list_item_type *uploaders = NULL;
d152 3
a154 2
PUBLIC int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not */
PUBLIC int LYrcShowColor = SHOW_COLOR_UNKNOWN; /* ... last used */
d165 1
a165 1
PUBLIC BOOLEAN LYtrimInputFields = FALSE;
d171 2
a172 2
PUBLIC BOOLEAN ftp_local_passive;
PUBLIC char *ftp_lasthost;
d186 1
a186 1
PUBLIC BOOLEAN LYRestricted = FALSE; /* whether we have -anonymous option */
a195 1

a200 1
PUBLIC BOOLEAN long_url_ok = FALSE;
d203 17
a219 5

PUBLIC BOOLEAN had_restrictions_default = FALSE;
PUBLIC BOOLEAN had_restrictions_all = FALSE;

PUBLIC BOOLEAN exec_frozen = FALSE;
d221 1
d223 3
a225 1
PUBLIC BOOLEAN no_chdir = FALSE;
a226 3
PUBLIC BOOLEAN no_dotfiles = NO_DOT_FILES;
PUBLIC BOOLEAN no_download = FALSE;
PUBLIC BOOLEAN no_editor = FALSE;
d228 2
a229 1
PUBLIC BOOLEAN no_file_url = FALSE;
a230 1
PUBLIC BOOLEAN no_goto_configinfo = FALSE;
d242 4
d247 3
a252 3
PUBLIC BOOLEAN no_inside_ftp = FALSE;
PUBLIC BOOLEAN no_inside_rlogin = FALSE;
PUBLIC BOOLEAN no_inside_telnet = FALSE;
d254 1
a254 14
PUBLIC BOOLEAN no_lynxcfg_info = FALSE;
PUBLIC BOOLEAN no_lynxcgi = FALSE;
PUBLIC BOOLEAN no_mail = FALSE;
PUBLIC BOOLEAN no_multibook = FALSE;
PUBLIC BOOLEAN no_option_save = FALSE;
PUBLIC BOOLEAN no_outside_ftp = FALSE;
PUBLIC BOOLEAN no_outside_rlogin = FALSE;
PUBLIC BOOLEAN no_outside_telnet = FALSE;
PUBLIC BOOLEAN no_print = FALSE;
PUBLIC BOOLEAN no_shell = FALSE;
PUBLIC BOOLEAN no_suspend = FALSE;
PUBLIC BOOLEAN no_telnet_port = FALSE;
PUBLIC BOOLEAN no_useragent = FALSE;

a255 4
PUBLIC BOOLEAN no_goto_news = FALSE;
PUBLIC BOOLEAN no_goto_nntp = FALSE;
PUBLIC BOOLEAN no_goto_snews = FALSE;
PUBLIC BOOLEAN no_inside_news = FALSE;
a256 1
PUBLIC BOOLEAN no_outside_news = FALSE;
d258 3
a260 12

#ifdef USE_EXTERNALS
PUBLIC BOOLEAN no_externals = FALSE;
#endif

#ifndef NO_CONFIG_INFO
PUBLIC BOOLEAN no_lynxcfg_xinfo = FALSE;
#ifdef HAVE_CONFIG_H
PUBLIC BOOLEAN no_compileopts_info = FALSE;
#endif
#endif

d262 1
a262 2
PUBLIC BOOLEAN no_filereferer = TRUE;
PUBLIC char LYRefererWithQuery = 'D';	/* 'D' for drop */
d265 1
a265 1
PUBLIC BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
d267 53
a319 41

#ifdef __DJGPP__
PUBLIC BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
#endif /* __DJGPP__ */

#ifdef WIN_EX
PUBLIC BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
PUBLIC char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
#endif

#ifdef _WINDOWS
#define	TIMEOUT	180			/* 1998/03/30 (Mon) 14:50:44 */
PUBLIC int lynx_timeout = TIMEOUT;
PUBLIC CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
PUBLIC CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
#endif /* _WINDOWS */

#if defined(WIN_EX)
PUBLIC BOOLEAN system_is_NT = FALSE;
#endif

#ifdef SH_EX
PUBLIC BOOLEAN show_cfg = FALSE;
#ifdef WIN_EX
PUBLIC int     debug_delay = 0;		/* 1998/10/06 (Tue) 08:41:20 */
#endif
PUBLIC BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */
#endif /* SH_EX */

#if USE_BLAT_MAILER
PUBLIC BOOLEAN mail_is_blat = TRUE;
#endif

#ifdef USE_BLINK
#  ifdef __EMX__
PUBLIC BOOLEAN term_blink_is_boldbg = TRUE;
#  else
PUBLIC BOOLEAN term_blink_is_boldbg = FALSE;
#  endif
#endif

d321 2
a322 3
PUBLIC BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
PUBLIC BOOLEAN LYCancelledFetch = FALSE;/* TRUE if cancelled binary fetch */
PUBLIC BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
a323 11
PUBLIC BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
PUBLIC BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
PUBLIC BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
PUBLIC BOOLEAN LYNewsPosting = NEWS_POSTING; /* News posting supported? */
PUBLIC BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
PUBLIC BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
PUBLIC BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
PUBLIC BOOLEAN LYRawMode;
PUBLIC BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
PUBLIC BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
PUBLIC BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
d325 17
d343 5
d349 2
a350 12
PUBLIC BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
PUBLIC BOOLEAN UCSaveBookmarksInUnicode = FALSE;
PUBLIC BOOLEAN bookmark_start = FALSE;
PUBLIC BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
PUBLIC BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
PUBLIC BOOLEAN crawl = FALSE;		/* Do crawl? */
PUBLIC BOOLEAN keep_mime_headers = FALSE; /* Include mime headers with source dump */
PUBLIC BOOLEAN more = FALSE;		/* is there more text to display? */
PUBLIC BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
PUBLIC BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
PUBLIC BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
PUBLIC BOOLEAN scan_for_buried_news_references = TRUE;
d352 9
a360 3
PUBLIC BOOLEAN startfile_stdin = FALSE;
PUBLIC BOOLEAN traversal = FALSE;	/* Do traversals? */
PUBLIC char *BookmarkPage = NULL;	/* the name of the current bookmark page */
d362 2
a365 1
PUBLIC char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
d367 2
a370 70
PUBLIC char *LYCookieSRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieSStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYHostName = NULL;		/* treat as a local host name */
PUBLIC char *LYLocalDomain = NULL;	/* treat as a local domain tail */
PUBLIC char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
PUBLIC char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
PUBLIC char *LynxHome = NULL;		/* the default Home HREF. */
PUBLIC char *LynxSigFile = NULL;	/* Signature file, in or off home */
PUBLIC char *UCAssume_MIMEcharset = NULL;
PUBLIC char *URLDomainPrefixes = NULL;
PUBLIC char *URLDomainSuffixes = NULL;
PUBLIC char *authentication_info[2] = {NULL, NULL}; /* Id:Password for protected documents */
PUBLIC char *bookmark_page = NULL;	/* the name of the default bookmark page */
PUBLIC char *editor = NULL;		/* the name of the current editor */
PUBLIC char *form_get_data = NULL;	/* User data for get form */
PUBLIC char *form_post_data = NULL;	/* User data for post form */
PUBLIC char *global_extension_map = NULL;  /* global mime.types */
PUBLIC char *global_type_map = NULL;	/* global mailcap */
PUBLIC char *helpfile = NULL;		/* the main help file */
PUBLIC char *helpfilepath = NULL;	/* the path to the help file set */
PUBLIC char *homepage = NULL;		/* home page or main screen */
PUBLIC char *http_error_file = NULL;	/* Place HTTP status code in this file */
PUBLIC char *indexfile = NULL;		/* an index file if there is one */
PUBLIC char *jumpfile = NULL;		/* the name of the default jumps file */
PUBLIC char *jumpprompt = NULL;		/* the default jumps prompt */
PUBLIC char *language = NULL;		/* preferred language */
PUBLIC char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
PUBLIC char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
PUBLIC char *lynx_cmd_script;		/* file to read keystroke commands, if any */
PUBLIC char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
PUBLIC char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
PUBLIC char *lynxjumpfile = NULL;	/* the current jump file URL */
PUBLIC char *lynxlinksfile = NULL;	/* the current visited links file URL */
PUBLIC char *lynxlistfile = NULL;	/* the current list file URL */
PUBLIC char *original_dir = NULL;	/* the original directory */
PUBLIC char *personal_extension_map = NULL;/* .mime.types */
PUBLIC char *personal_mail_address = NULL; /* the users mail address */
PUBLIC char *personal_type_map = NULL;	   /* .mailcap */
PUBLIC char *pref_charset = NULL;	/* preferred character set */
PUBLIC char *proxyauth_info[2] = {NULL, NULL}; /* Id:Password for protected proxy servers */
PUBLIC char *startfile = NULL;		/* the first file */
PUBLIC char *startrealm = NULL;		/* the startfile realm */
PUBLIC char *system_mail = NULL;	/* The path for sending mail */
PUBLIC char *system_mail_flags = NULL;	/* Flags for sending mail */
PUBLIC char *x_display = NULL;		/* display environment variable */
PUBLIC histstruct history[MAXHIST];
PUBLIC int AlertSecs;			/* time-delay for HTAlert() messages   */
PUBLIC int InfoSecs;			/* time-delay for Information messages */
PUBLIC int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
PUBLIC int LYStatusLine = -1;		/* Line for statusline() if > -1 */
PUBLIC int LYcols = DFT_COLS;
PUBLIC int LYlines = DFT_ROWS;
PUBLIC int MessageSecs;			/* time-delay for important Messages   */
PUBLIC int ccount = 0;			/* Starting number for lnk#.dat files in crawls */
PUBLIC int dump_output_width = 0;
PUBLIC int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
PUBLIC int nhist = 0;			/* number of history entries */
PUBLIC int nlinks = 0;			/* number of links in memory */
PUBLIC int outgoing_mail_charset = -1;	/* translate mail to this charset */
PUBLIC linkstruct links[MAXLINKS];

#ifndef DISABLE_BIBP
PUBLIC BOOLEAN BibP_bibhost_available = FALSE;  /* until check succeeds  */
PUBLIC BOOLEAN BibP_bibhost_checked = FALSE;  /*  until LYCheckBibHost   */
PUBLIC BOOLEAN no_goto_bibp = FALSE;
PUBLIC char *BibP_bibhost = NULL;	 /* local server for bibp: links  */
PUBLIC char *BibP_globalserver = NULL;   /* global server for bibp: links */
#endif

d372 2
a373 3
PUBLIC BOOLEAN persistent_cookies = FALSE; /* disabled by default! */
PUBLIC char *LYCookieFile = NULL;	/* cookie read file */
PUBLIC char *LYCookieSaveFile = NULL;	/* cookie save file */
a374 14

#ifdef EXP_NESTED_TABLES
PUBLIC BOOLEAN nested_tables =
#if defined(USE_COLOR_STYLE)
    TRUE
#else
    FALSE				/* see 2001-08-15  */
#endif
    ;
#endif

PUBLIC BOOLEAN LYShowTransferRate = TRUE;
PUBLIC int LYTransferRate = rateEtaKB_maybe;

d379 1
a379 4
PUBLIC int Old_DTD = NO;
PRIVATE BOOL DTD_recovery = NO;

#ifndef NO_LYNX_TRACE
a380 1
#endif
a382 1

d385 1
d389 1
a389 1
PUBLIC BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
a392 25
PUBLIC BOOLEAN dont_wrap_pre = FALSE;

PUBLIC int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/

#ifdef EXP_JUSTIFY_ELTS
PUBLIC BOOL ok_justify = TRUE;
PUBLIC int justify_max_void_percent = 35;
#endif

#ifndef NO_DUMP_WITH_BACKSPACES
PUBLIC BOOLEAN with_backspaces = FALSE;
#endif

PUBLIC BOOL force_empty_hrefless_a = FALSE;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
PUBLIC BOOL textfields_need_activation = FALSE;
PUBLIC BOOL textfields_activation_option = FALSE;
#endif

PUBLIC BOOLEAN textfield_prompt_at_left_edge = FALSE;

#ifdef MARK_HIDDEN_LINKS
PUBLIC char* hidden_link_marker = NULL;
#endif
d400 5
a404 7
PUBLIC BOOLEAN LYNonRestartingSIGWINCH = FALSE;
PUBLIC BOOLEAN LYReuseTempfiles = FALSE;
PUBLIC BOOLEAN LYUseBuiltinSuffixes = TRUE;

#ifdef MISC_EXP
PUBLIC int LYNoZapKey = 0; /* 0: off (do z checking), 1: full, 2: initially */
#endif
a410 2
PUBLIC BOOLEAN FileInitAlreadyDone = FALSE;

a414 1
PRIVATE BOOLEAN number_fields = FALSE;
a422 12
#ifndef EXTENDED_STARTFILE_RECALL
/* if set then additional non-option args (before the last one) will be
   made available for 'g'oto recall - kw */
#define EXTENDED_STARTFILE_RECALL 1
#endif

#ifndef OPTNAME_ALLOW_DASHES
/* if set, then will allow dashes and underscores to be used interchangeable
   in commandline option's names - VH */
#define OPTNAME_ALLOW_DASHES 1
#endif

d427 3
a429 3
PRIVATE BOOL parse_arg PARAMS((char **arg, unsigned mask, int *i));
PRIVATE void print_help_and_exit PARAMS((int exit_status)) GCC_NORETURN;
PRIVATE void print_help_strings PARAMS((CONST char * name, CONST char * help, CONST char * value, BOOLEAN option));
a432 1
PUBLIC BOOLEAN restore_sigpipe_for_children = FALSE;
d436 2
a437 2
#if defined(USE_COLOR_STYLE)
PUBLIC char *lynx_lss_file = NULL;
d441 1
a441 1
PRIVATE void LY_set_ctrl_break(int setting)
a461 14
#if defined(WIN_EX)
PUBLIC int is_windows_nt(void)
{
    DWORD version;

    version = GetVersion();
    if ((version & 0x80000000) == 0)
	return 1;
    else
	return 0;
}
#endif


d480 1
a483 4
#if USE_VMS_MAILER
    FREE(mail_adrs);
#endif

a504 4
#ifndef DISABLE_BIBP
    FREE(BibP_bibhost);
    FREE(BibP_globalserver);
#endif
a506 1
    FREE(LYCookieSaveFile);
d538 22
a559 13
	    FREE(lynx_temp_space);
	    FREE(LYTraceLogPath);
	    FREE(lynx_cfg_file);
	#if defined(USE_COLOR_STYLE)
	    FREE(lynx_lss_file);
	#endif
	    FREE(UCAssume_MIMEcharset);
	    LYUIPages_free();
	    for (i = 0; i < nlinks; i++) {
		FREE(links[i].lname);
	    }
	    nlinks = 0;
	    HTList_delete(LYcommandList());
d561 7
a567 3
	    return;
	}
	#endif /* LY_FIND_LEAKS */
d569 2
a570 7
	/*
	 *  This function frees the LYStdinArgs list. - FM
	 */
	PRIVATE void LYStdinArgs_free NOARGS
	{
	    char *argument;
	    HTList *cur = LYStdinArgs;
d572 7
a578 2
	    if (cur == NULL)
		return;
d580 16
a595 7
	    while (NULL != (argument = (char *)HTList_nextObject(cur))) {
		FREE(argument);
	    }
	    HTList_delete(LYStdinArgs);
	    LYStdinArgs = NULL;
	    return;
	}
d597 21
a617 16
	PUBLIC void exit_immediately ARGS1(
		int,		code)
	{
	#ifndef NOSIGHUP
	    (void) signal(SIGHUP, SIG_DFL);
	#endif /* NOSIGHUP */
	    (void) signal(SIGTERM, SIG_DFL);
	#ifndef VMS
	    (void) signal(SIGINT, SIG_DFL);
	#endif /* !VMS */
	#ifdef SIGTSTP
	    if (no_suspend)
		(void) signal(SIGTSTP, SIG_DFL);
	#endif /* SIGTSTP */
	    exit(code);
	}
d619 5
a623 21
	#ifdef  EBCDIC
	      char un_IBM1047[ 256 ] = "";
	unsigned char IBM1047[ 256 ] = /* ATOE OEMVS311 */
	{
	0x00,0x01,0x02,0x03,0x37,0x2d,0x2e,0x2f,0x16,0x05,0x15,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x10,0x11,0x12,0x13,0x3c,0x3d,0x32,0x26,0x18,0x19,0x3f,0x27,0x1c,0x1d,0x1e,0x1f,
	0x40,0x5a,0x7f,0x7b,0x5b,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,
	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,
	0x7c,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,
	0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xad,0xe0,0xbd,0x5f,0x6d,
	0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,
	0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xc0,0x4f,0xd0,0xa1,0x07,
	0x20,0x21,0x22,0x23,0x24,0x25,0x06,0x17,0x28,0x29,0x2a,0x2b,0x2c,0x09,0x0a,0x1b,
	0x30,0x31,0x1a,0x33,0x34,0x35,0x36,0x08,0x38,0x39,0x3a,0x3b,0x04,0x14,0x3e,0xff,
	0x41,0xaa,0x4a,0xb1,0x9f,0xb2,0x6a,0xb5,0xbb,0xb4,0x9a,0x8a,0xb0,0xca,0xaf,0xbc,
	0x90,0x8f,0xea,0xfa,0xbe,0xa0,0xb6,0xb3,0x9d,0xda,0x9b,0x8b,0xb7,0xb8,0xb9,0xab,
	0x64,0x65,0x62,0x66,0x63,0x67,0x9e,0x68,0x74,0x71,0x72,0x73,0x78,0x75,0x76,0x77,
	0xac,0x69,0xed,0xee,0xeb,0xef,0xec,0xbf,0x80,0xfd,0xfe,0xfb,0xfc,0xba,0xae,0x59,
	0x44,0x45,0x42,0x46,0x43,0x47,0x9c,0x48,0x54,0x51,0x52,0x53,0x58,0x55,0x56,0x57,
	0x8c,0x49,0xcd,0xce,0xcb,0xcf,0xcc,0xe1,0x70,0xdd,0xde,0xdb,0xdc,0x8d,0x8e,0xdf
	} ;
d625 11
a635 17
	PRIVATE void FixCharacters(void)
	{
	    int c;
	    int work1[256],
		work2[256];

	    for (c = 0; c < 256; c++) {
		un_IBM1047[IBM1047[c]] = c;
		work1[c] = keymap[c+1];
		work2[c] = key_override[c+1];
	    }
	    for (c = 0; c < 256; c++) {
		keymap      [IBM1047[c]+1] = work1[c];
		key_override[IBM1047[c]+1] = work2[c];
	    }
	}
	#endif /* EBCDIC */
d637 8
a644 12
	PRIVATE int argncmp ARGS2(
		char*,		str,
		char*,		what)
	{
	    if (str[0] == '-' && str[1] == '-' ) ++str;
	#if OPTNAME_ALLOW_DASHES
	    return strncmp(str, what, strlen(what));
	#else
	    ++str; ++what; /*skip leading dash in both strings*/
	    return !strn_dash_equ(str, what, strlen(what));
	#endif
	}
d646 7
a652 5
	PRIVATE void tildeExpand ARGS2(
		char **,	pathname,
		BOOLEAN,	embedded)
	{
	    char *temp = *pathname;
d654 24
a677 9
	    if (embedded) {
		if (temp != NULL) {
		    temp = strstr(*pathname, "/~");
		    if (temp != 0)
			temp++;
		    else
			temp = *pathname;
		}
	    }
d679 5
a683 15
	    if (temp != NULL
	     && temp[0] == '~') {
		if (temp[1] == '/'
		 && temp[2] != '\0') {
		    temp = NULL;
		    StrAllocCopy(temp, *pathname + 2);
		    StrAllocCopy(*pathname, wwwName(Home_Dir()));
		    LYAddPathSep(pathname);
		    StrAllocCat(*pathname, temp);
		    FREE(temp);
		} else if (temp[1] == '\0') {
		    StrAllocCopy(*pathname, wwwName(Home_Dir()));
		}
	    }
	}
d685 1
a685 13
	PRIVATE BOOL GetStdin ARGS2(
		char **,	buf,
		BOOL,		marker)
	{
	    if (LYSafeGets(buf, stdin) != 0
	     && (!marker || strncmp(*buf, "---", 3) != 0)) {
		LYTrimTrailing(*buf);
		CTRACE((tfp, "...data: %s\n", *buf));
		return TRUE;
	    }
	    CTRACE((tfp, "...mark: %s\n", *buf ? *buf : ""));
	    return FALSE;
	}
d687 2
a688 2
	#ifdef WIN32
	PRIVATE BOOL cleanup_win32(DWORD fdwCtrlType)
d690 3
a692 7
	    switch (fdwCtrlType) {
	    case CTRL_CLOSE_EVENT:
		cleanup_sig(-1);
		return TRUE;
	    default:
		return FALSE;
	    }
d694 2
a695 1
	#endif
d697 11
a707 22
	/*
	 * Wow!  Someone wants to start up Lynx.
	 */
	PUBLIC int main ARGS2(
		int,		argc,
		char **,	argv)
	{
	    int  i;		/* indexing variable */
	    int status = 0;	/* exit status */
	    char *temp = NULL;
	    char *cp;
	    FILE *fp;
	    struct stat dir_info;
	    char filename[LY_MAXPATH];
	    BOOL LYGetStdinArgs = FALSE;
	#ifdef _WINDOWS
	    WSADATA WSAData;
	#endif /* _WINDOWS */
	#ifdef USE_SSL
	    char SSLLibraryVersion[256];
	    char *SSLcp;
	#endif /* USE_SSL */
d709 8
a716 37
	    /*
	     * Just in case someone has the idea to install lynx set-uid, let's try
	     * to discourage it.
	     */
	#if defined(GETUID) && defined(SETUID)
	    setuid(getuid());
	#endif

	#ifdef    NOT_ASCII
	    FixCharacters();
	#endif /* NOT_ASCII */

	#ifndef DISABLE_FTP
	    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
	    ftp_lasthost = (char *)malloc(sizeof(char));
	    *ftp_lasthost = NULL;
	#endif

	#ifdef EXP_CHARSET_CHOICE
	    memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
	#endif

	#ifdef _WINDOWS
	    {
		int err;
		WORD wVerReq;

		wVerReq = MAKEWORD(1, 1);

		err = WSAStartup(wVerReq, &WSAData);
		if (err != 0)
		{
		    printf(gettext("No Winsock found, sorry."));
		    sleep(5);
		    return 1;
		}
	    }
d718 3
a720 12
	    /* 1998/09/03 (Thu) 22:02:32 */
	    InitializeCriticalSection(&critSec_DNS);
	    InitializeCriticalSection(&critSec_READ);

	#endif /* _WINDOWS */

	#if defined(__CYGWIN__) && defined(DOSPATH)
	    if (strcmp(ttyname(fileno(stdout)), "/dev/conout") != 0) {
		printf("please \"$CYGWIN=notty\"\n");
		exit(EXIT_SUCCESS);
	    }
	#endif
d722 8
a729 21
	#if defined(WIN_EX)
	    /* 1997/10/19 (Sun) 21:40:54 */
	    system_is_NT = (BOOL) is_windows_nt();

	    /* 1998/01/13 (Tue) 21:13:47 */
	    GetWindowsDirectory(filename, sizeof filename);
	    windows_drive[0] = filename[0];
	    windows_drive[1] = filename[1];
	    windows_drive[2] = '\0';
	#endif


	#ifdef __DJGPP__
	    if (LY_get_ctrl_break() == 0) {
		LY_set_ctrl_break(TRUE);
		init_ctrl_break[0] = 0;
	    } else {
		init_ctrl_break[0] = 1;
	    }
	    atexit(reset_break);
	#endif /* __DJGPP__ */
d731 8
a738 27
	    /*
	     * To prevent corrupting binary data on DOS, MS-WINDOWS or OS/2
	     * we open files and stdout in BINARY mode by default.
	     * Where necessary we should open and (close!) TEXT mode.
	     * (use LYNewTxtFile/LYAppendToTxtFile to open text files for writing)
	     */
	    SetDefaultMode(O_BINARY);
	    SetOutputMode(O_BINARY);

	#ifdef DOSPATH
	    if (getenv("TERM")==NULL) putenv("TERM=vt100");
	#endif

	    LYShowColor = (SHOW_COLOR ? SHOW_COLOR_ON : SHOW_COLOR_OFF);
	    /*
	     *	Set up the argument list.
	     */
	    pgm = argv[0];
	    cp = NULL;
	#ifdef DOSPATH
	    if ((cp = strrchr(pgm, '\\')) != NULL) {
		pgm = cp + 1;
	    } else if (cp == NULL)
	#endif
	    if ((cp = strrchr(pgm, '/')) != NULL) {
		pgm = cp + 1;
	    }
d740 11
a750 13
	    /*
	     *	Act on -help NOW, so we only output the help and exit. - FM
	     */
	    for (i = 1; i < argc; i++) {
		if (argncmp(argv[i], "-help") == 0) {
		    parse_arg(&argv[i], 1, &i);
		}
	#ifdef SH_EX
		if (strncmp(argv[i], "-show_cfg", 9) == 0) {
		    show_cfg = TRUE;
		}
	#endif
	    }
a751 11
	#ifdef LY_FIND_LEAKS
	    /*
	     *	Register the final function to be executed when being exited.
	     *	Will display memory leaks if LY_FIND_LEAKS is defined.
	     */
	    atexit(LYLeaks);
	    /*
	     *	Register the function which will free our allocated globals.
	     */
	    atexit(free_lynx_globals);
	#endif /* LY_FIND_LEAKS */
d753 13
d767 52
a818 84
	#ifdef LOCALE
	    /*
	     *	LOCALE support for international characters.
	     */
	    setlocale(LC_ALL, "");
	#endif /* LOCALE */
	    /* Set the text message domain.  */
	#ifdef HAVE_LIBINTL_H
	#ifndef __DJGPP__
	    bindtextdomain ("lynx", LOCALEDIR);
	#endif /* !__DJGPP__ */
	    textdomain ("lynx");
	#endif /* HAVE_LIBINTL_H */

	    /*
	     *	Initialize our startup and global variables.
	     */
	#ifdef ULTRIX
	    /*
	     *	Need this for Ultrix.
	     */
	    terminal = getenv("TERM");
	    if ((terminal == NULL) || !strncasecomp(terminal, "xterm", 5))
		terminal = "vt100";
	#endif /* ULTRIX */
	    /*
	     *	Zero the links and history struct arrays.
	     */
	    memset((void *)links, 0, sizeof(linkstruct)*MAXLINKS);
	    memset((void *)history, 0, sizeof(histstruct)*MAXHIST);
	    /*
	     *	Zero the MultiBookmark arrays.
	     */
	    memset((void *)MBM_A_subbookmark, 0, sizeof(char)*(MBM_V_MAXFILES+1));
	    memset((void *)MBM_A_subdescript, 0, sizeof(char)*(MBM_V_MAXFILES+1));
	#ifndef VMS
	    StrAllocCopy(list_format, LIST_FORMAT);
	#endif /* !VMS */

	#ifdef HAVE_NAPMS
	#define SECS2Secs(n) (1000 * (n))
	#else
	#define SECS2Secs(n) (n)
	#endif
	    InfoSecs	= SECS2Secs(INFOSECS);
	    MessageSecs = SECS2Secs(MESSAGESECS);
	    AlertSecs	= SECS2Secs(ALERTSECS);

	    StrAllocCopy(helpfile, HELPFILE);
	    StrAllocCopy(startfile, STARTFILE);
	    LYEscapeStartfile(&startfile);
	    StrAllocCopy(indexfile, DEFAULT_INDEX_FILE);
	    StrAllocCopy(global_type_map, GLOBAL_MAILCAP);
	    StrAllocCopy(personal_type_map, PERSONAL_MAILCAP);
	    StrAllocCopy(global_extension_map, GLOBAL_EXTENSION_MAP);
	    StrAllocCopy(personal_extension_map, PERSONAL_EXTENSION_MAP);
	    StrAllocCopy(language, PREFERRED_LANGUAGE);
	    StrAllocCopy(pref_charset, PREFERRED_CHARSET);
	    StrAllocCopy(system_mail, SYSTEM_MAIL);
	    StrAllocCopy(system_mail_flags, SYSTEM_MAIL_FLAGS);
	    StrAllocCopy(LYUserAgent, LYNX_NAME);
	    StrAllocCat(LYUserAgent, "/");
	    StrAllocCat(LYUserAgent, LYNX_VERSION);
	    if (HTLibraryVersion) {
		StrAllocCat(LYUserAgent, " libwww-FM/");
		StrAllocCat(LYUserAgent, HTLibraryVersion);
	    }
	#ifdef USE_SSL
	    StrAllocCat(LYUserAgent, " SSL-MM/1.4.1");
	#ifdef OPENSSL_VERSION_TEXT
	    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
	    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
		*SSLcp++ = '/';
		if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
		    *SSLcp = '\0';
		    StrAllocCat(LYUserAgent, " ");
		    StrAllocCat(LYUserAgent, SSLLibraryVersion);
		}
	    }
	#endif /* OPENSSL_VERSION_TEXT */
	#endif /* USE_SSL */
	    StrAllocCopy(LYUserAgentDefault, LYUserAgent);
	#ifdef VMS
	    Define_VMSLogical("LYNX_VERSION", LYNX_VERSION);
d836 1
a836 1
	StrAllocCopy(lynx_temp_space, HTSYS_name(cp));
d838 1
a838 1
	StrAllocCopy(lynx_temp_space, HTSYS_name(cp));
d846 1
a846 1
	exit(EXIT_FAILURE);
d850 9
a858 5
#ifdef WIN_EX	/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
    if (access(lynx_temp_space, 0) != 0)
#endif
	tildeExpand(&lynx_temp_space, TRUE);

d862 1
a862 1
	if ((cp1 = getenv("USER")) != NULL) {
d873 1
a873 1
    StrAllocCat(lynx_temp_space, "/lynx-XXXXXXXXXX");
a874 1

a893 13

    if ((HTStat(lynx_temp_space, &dir_info) < 0
#ifdef UNIX
	&& mkdir(lynx_temp_space, 0700) < 0
#endif
	)
     || !S_ISDIR(dir_info.st_mode)) {
	fprintf(stderr, "%s: %s\n",
		lynx_temp_space,
		gettext("No such directory"));
	exit_immediately(EXIT_FAILURE);
    }

d895 1
a899 8

#if USE_VMS_MAILER
#ifndef MAIL_ADRS
#define MAIL_ADRS "\"IN%%\"\"%s\"\"\""
#endif
    StrAllocCopy(mail_adrs, MAIL_ADRS);
#endif

a904 1

a909 5
#ifndef DISABLE_BIBP
    StrAllocCopy(BibP_globalserver, BIBP_GLOBAL_SERVER);
    StrAllocCopy(BibP_bibhost, "http://bibhost/");  /* protocol specified. */
#endif

d917 1
a917 1
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
d927 40
a966 4
#ifndef NO_LYNX_TRACE
    if (getenv("LYNX_TRACE") != 0) {
	WWW_TraceFlag = TRUE;
    }
d968 1
a968 2
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 2, &i);
d983 1
a983 1
     *	-post_data, the data are terminated by a "---" string, alone
a988 1
	    break;
d994 72
a1065 7
	CTRACE((tfp, "processing stdin arguments\n"));
	while (GetStdin(&buf, TRUE)) {
	    char *noargv[2];

	    noargv[0] = buf;
	    noargv[1] = NULL;
	    LYTrimTrailing(buf);
d1067 56
a1122 2
	    if (parse_arg(&noargv[0], 2, (int *)0) == FALSE
	     &&  buf[0] != '\0') {
a1132 3
		CTRACE((tfp, "...StdinArg:%s\n", argument));
	    } else {
		CTRACE((tfp, "...complete:%s\n", buf));
a1134 1
	CTRACE((tfp, "...done with stdin arguments\n"));
d1159 1
a1159 1
	strlen(ANONYMOUS_USER) > 0 &&
d1161 2
a1162 2
	!strcasecomp((getenv("USER")==NULL ? " " : getenv("USER")),
		     ANONYMOUS_USER)
d1165 1
a1165 1
	STREQ((char *)cuserid((char *) NULL), ANONYMOUS_USER)
d1167 1
a1167 1
	STREQ(((char *)getlogin()==NULL ? " " : getlogin()), ANONYMOUS_USER)
d1170 1
a1170 1
	) {
d1179 1
a1179 8
#ifdef FNAMES_8_3
    LYAddPathToHome(LYTraceLogPath =
		malloc(LY_MAXPATH), LY_MAXPATH, "LY-TRACE.LOG");
#else
    LYAddPathToHome(LYTraceLogPath =
		malloc(LY_MAXPATH), LY_MAXPATH, "Lynx.trace");
#endif

a1181 17
#ifdef EXP_CMD_LOGGING
    /*
     *	Open command-script, if specified
     */
    if (lynx_cmd_script != 0) {
	tildeExpand(&lynx_cmd_script, TRUE);
	LYOpenCmdScript();
    }
    /*
     *	Open command-logging, if specified
     */
    if (lynx_cmd_logfile != 0) {
	tildeExpand(&lynx_cmd_logfile, TRUE);
	LYOpenCmdLogfile(argc, argv);
    }
#endif

d1189 9
a1197 4
	temp = NULL;
	HTSprintf0(&temp, "JUMPFILE:%s", jumpfile);
	if (!LYJumpInit(temp)) {
	    CTRACE((tfp, "Failed to register %s\n", temp));
a1198 1
	FREE(temp);
d1219 3
d1223 12
a1234 1
    tildeExpand(&lynx_cfg_file, FALSE);
d1241 1
a1241 1
    if (!LYCanReadFile(lynx_cfg_file)) {
d1244 1
a1244 1
	exit(EXIT_FAILURE);
d1246 6
d1259 1
a1259 1
	exit(EXIT_FAILURE);
a1269 5
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (auto_display_charset >= 0)
	current_char_set = auto_display_charset;
    else
#endif
d1276 1
a1276 1
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d1283 1
a1283 1
	exit(EXIT_FAILURE);
d1286 1
a1286 1
#if defined(USE_COLOR_STYLE)
d1304 16
a1319 2
    tildeExpand(&lynx_lss_file, TRUE);

d1324 1
a1324 1
    if (!LYCanReadFile(lynx_lss_file)) {
d1330 1
d1333 1
a1333 1
#endif /* USE_COLOR_STYLE */
d1335 1
a1335 1
#ifdef USE_COLOR_TABLE
d1355 1
a1355 1
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename)-1);
d1360 1
a1360 1
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
d1362 1
a1362 1
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
d1365 1
a1365 1
#ifdef USE_PRETTYSRC
d1378 1
a1378 1
    read_rc(NULL);
d1401 1
a1401 1
	parse_arg(&argv[i], 4, &i);
d1414 1
a1414 1
	    parse_arg(my_args, 4, (int *)0);
a1417 58
#ifdef CAN_SWITCH_DISPLAY_CHARSET
    if (current_char_set == auto_display_charset) /* Better: explicit option */
	switch_display_charsets = 1;
#endif

#undef TTY_DEVICE
#undef NUL_DEVICE

#ifdef VMS
#define TTY_DEVICE "tt:"
#define NUL_DEVICE "nl:"
#endif

#ifdef _WINDOWS
#define TTY_DEVICE "con"
#define NUL_DEVICE "nul"
#endif

#ifndef TTY_DEVICE
#define TTY_DEVICE "/dev/tty"
#define NUL_DEVICE "/dev/null"
#endif

#if defined (TTY_DEVICE) || defined(HAVE_TTYNAME)
    /*
     *	If we are told to read the startfile from standard input, do it now,
     *	after we have read all of the option data from standard input.
     */
    if (startfile_stdin) {
	char result[LY_MAXPATH];
	char *buf = NULL;
	char *tty = NULL;
# ifdef HAVE_TTYNAME
	tty = ttyname(fileno(stderr));
# endif
	if (tty == NULL)
	    tty = isatty(fileno(stdin)) ? TTY_DEVICE : NUL_DEVICE;

	CTRACE((tfp, "processing stdin startfile, tty=%s\n", tty));
	if ((fp = LYOpenTemp (result, HTML_SUFFIX, "w")) != 0) {
	    StrAllocCopy(startfile, result);
	    while (GetStdin(&buf, FALSE)) {
		fputs(buf, fp);
		fputc('\n', fp);
	    }
	    FREE(buf);
	    LYCloseTempFP(fp);
	}
	CTRACE((tfp, "...done stdin startfile\n"));
	if ((freopen(tty, "r", stdin)) == 0) {
	    CTRACE((tfp, "cannot open a terminal (%s)\n", tty));
	    if (!dump_output_immediately) {
		fprintf(stderr, "cannot open a terminal (%s)\n", tty);
		exit(1);
	    }
	}
    }
#endif
d1423 1
a1423 1
#ifdef USE_PRETTYSRC
a1437 2
     *
     * And to set LYCookieSaveFile. - BJP
d1441 1
a1441 1
	    LYAddPathToHome(LYCookieFile = malloc(LY_MAXPATH), LY_MAXPATH, COOKIE_FILE);
d1443 9
a1451 1
	    tildeExpand(&LYCookieFile, FALSE);
a1454 18

    /* tilde-expand LYCookieSaveFile */
    if (LYCookieSaveFile != NULL) {
	tildeExpand(&LYCookieSaveFile, FALSE);
    }

    /*
     * In dump_output_immediately mode, LYCookieSaveFile defaults to
     * /dev/null, otherwise it defaults to LYCookieFile.
     */

    if (LYCookieSaveFile == NULL) {
	if (dump_output_immediately) {
		StrAllocCopy(LYCookieSaveFile, "/dev/null");
	} else {
		StrAllocCopy(LYCookieSaveFile, LYCookieFile);
	}
    }
d1480 9
a1488 1
	tildeExpand(&lynx_save_space, TRUE);
d1518 1
a1518 2
    if (!FileInitAlreadyDone)
	HTFileInit();
d1520 6
a1525 2
    if (!LYCheckUserAgent()) {
	HTAlwaysAlert(gettext("Warning:"), UA_NO_LYNX_WARNING);
d1527 2
a1528 6
#ifdef SH_EX
    if (show_cfg) {
	cleanup();
	exit(EXIT_SUCCESS);
    }
#endif
d1562 3
a1564 13
    if (crawl) {
	/* No numbered links by default, as documented
	   in CRAWL.announce. - kw */
	if (!number_links) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	}
    }

    if (keypad_mode == NUMBERS_AS_ARROWS) {
	if (number_fields)
	    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
	if (number_links)
	    keypad_mode = LINKS_ARE_NUMBERED;
a1565 1
    }
d1571 4
a1574 1
	LYSelectPopups = !LYSelectPopups;
d1581 4
a1584 1
	LYShowCursor = !LYShowCursor;
d1603 1
a1603 1
	LYMultiBookmarks = MBM_OFF;
a1626 17
#if defined (__DJGPP__)
    if (watt_debug)
	dbug_init();
    sock_init();

    __system_flags =
	__system_emulate_chdir	      | /* handle `cd' internally */
	__system_handle_null_commands | /* ignore cmds with no effect */
	__system_allow_long_cmds      | /* handle commands > 126 chars	 */
	__system_use_shell	      | /* use $SHELL if set */
	__system_allow_multiple_cmds  | /* allow `cmd1; cmd2; ...' */
	__system_redirect;		/* redirect internally */

    /* This speeds up stat() tremendously */
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC |_STAT_DIRSIZE;
#endif  /* __DJGPP__ */

a1627 3
#ifdef WIN32
    SetConsoleCtrlHandler((PHANDLER_ROUTINE) cleanup_win32, TRUE);
#endif
a1631 1

d1634 1
a1634 1
    LYExtSignal(SIGWINCH, size_change);
d1656 1
a1656 2
	if (signal(SIGPIPE, SIG_IGN) != SIG_IGN)
	     restore_sigpipe_for_children = TRUE;
d1666 1
a1666 1
	(void) signal(SIGTSTP, SIG_IGN);
d1676 1
a1676 1
	exit_immediately(EXIT_FAILURE);
d1686 1
a1686 1
	exit_immediately(EXIT_FAILURE);
d1696 1
a1696 1
	exit_immediately(EXIT_FAILURE);
d1704 3
a1706 7
#ifdef USE_PRETTYSRC
    if (!dump_output_immediately) {
	HTMLSRC_init_caches(FALSE); /* do it before terminal is initialized*/
#ifdef LY_FIND_LEAKS
	atexit(html_src_clean_data);
#endif
    }
d1746 1
a1746 1
	telnet_ok = (BOOL)(!no_inside_telnet && !no_outside_telnet && telnet_ok);
d1748 1
a1748 1
	news_ok = (BOOL)(!no_inside_news && !no_outside_news && news_ok);
d1750 2
a1751 2
	ftp_ok = (BOOL)(!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
d1753 2
a1754 2
	CTRACE((tfp, "LYMain: User in Local domain\n"));
	telnet_ok = (BOOL)(!no_inside_telnet && telnet_ok);
d1756 1
a1756 1
	news_ok = (BOOL)(!no_inside_news && news_ok);
d1758 2
a1759 2
	ftp_ok = (BOOL)(!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && rlogin_ok);
d1762 2
a1763 2
	CTRACE((tfp, "LYMain: User in REMOTE domain\n"));
	telnet_ok = (BOOL)(!no_outside_telnet && telnet_ok);
d1765 1
a1765 1
	news_ok = (BOOL)(!no_outside_news && news_ok);
d1767 2
a1768 2
	ftp_ok = (BOOL)(!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_outside_rlogin && rlogin_ok);
d1776 5
a1780 4
	temp = NULL;
	HTSprintf0(&temp, "lynx_bookmarks%s", HTML_SUFFIX);
	set_default_bookmark_page(temp);
	FREE(temp);
d1783 3
a1785 1
	set_default_bookmark_page(bookmark_page);
a1787 4
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
    LYOpenlog (syslog_txt);
#endif

d1796 1
a1796 1
	if (crawl && !number_links && !number_fields) {
d1800 1
a1800 4
		if (number_fields)
		    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
		else
		    keypad_mode = LINKS_ARE_NUMBERED;
a1802 1

a1810 1
	    !crawl &&		/* For -crawl it has already been done! */
d1812 2
a1813 2
	     keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED))
	    printlist(stdout, FALSE);
d1821 1
a1821 1
	    LYStoreCookies(LYCookieSaveFile);
d1823 1
d1836 2
a1837 12
#ifndef NO_DUMP_WITH_BACKSPACES
	if (with_backspaces) {
	    /* we should warn about this somehow (nop for now) -VH */
	    with_backspaces = FALSE;
	}
#endif

#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
	init_charset_subsets();
#endif

	ena_csi((BOOLEAN)(LYlowest_eightbit[current_char_set] > 155));
d1839 1
a1839 2
	LYCloseCloset(RECALL_URL);
	LYCloseCloset(RECALL_MAIL);
d1850 1
a1850 1
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE, LYNXMESSAGES
a1856 1
extern GLOBALREF (HTProtocol, LYLynxStatusMessages);
a1861 1
GLOBALREF  HTProtocol LYLynxStatusMessages;
a1869 1
    HTRegisterProtocol(&LYLynxStatusMessages);
d1876 2
a1877 1
 *  to make things consistent.
a1879 10
 *
 *  Warning: experimental, more main() reorganization required.
 *	*Known* exceptions: persistent cookies, cookie files.
 *
 *	Some aspects of COLOR (with slang?).
 *	Viewer stuff, mailcap files
 *	SUFFIX, mime.types files
 *	RULESFILE/RULE
 *
 *	All work "somewhat", but not exactly as the first time.
d1883 1
a1883 20
    char *tempfile;
    FILE *rcfp;
    /*
     *  no_option_save is always set for -anonymous and -validate.
     *  It is better to check for one or several specific restriction
     *  flags than for 'LYRestricted', which doesn't get set for
     *  individual restrictions or for -validate!
     *  However, no_option_save may not be the appropriate one to
     *  check - in that case, a new no_something should be added
     *  that gets automatically set for -anonymous and -validate
     *  (and whether it applies for -anonymous can be made installer-
     *  configurable in the usual way at the bottom of userdefs.h). - kw
     *
     */
    if (no_option_save) {
	/* current logic requires(?) that saving user preferences is
	   possible.  Additional applicable restrictions are already
	   checked by caller. - kw */
	return;
    }
d1885 2
a1886 26
    /*
     *  Current user preferences are saved in a temporary file, to be
     *  read in again after lynx.cfg has been read.  This avoids
     *  accidental changing of the preferences file.  The regular
     *  preferences file doesn't even need to exist, and won't be
     *  created as a side effect of this function.  Honoring the
     *  no_option_save restriction may thus be unnecessarily restrictive,
     *  but the check is currently still left in place. - kw
     */
    tempfile = typecallocn(char, LY_MAXPATH);
    if (!tempfile) {
	HTAlwaysAlert(NULL, NOT_ENOUGH_MEMORY);
	return;
    }
    rcfp = LYOpenTemp(tempfile, ".rc" , "w");
    if (rcfp == NULL) {
	FREE(tempfile);
	HTAlwaysAlert(NULL, CANNOT_OPEN_TEMP);
	return;
    }
    if (!save_rc(rcfp)) {
	HTAlwaysAlert(NULL, OPTIONS_NOT_SAVED);
	LYRemoveTemp(tempfile);
	FREE(tempfile);
	return;    /* can not write the very own file :( */
    }
d1890 1
a1890 1
#ifdef EXP_PERSISTENT_COOKIES
d1892 1
a1892 21
	char * LYCookieFile_flag = NULL;
	char * LYCookieSaveFile_flag = NULL;
	if (persistent_cookies) {
	    StrAllocCopy(LYCookieFile_flag, LYCookieFile);
	    StrAllocCopy(LYCookieSaveFile_flag, LYCookieSaveFile);
	}
#endif

#ifdef EXP_CHARSET_CHOICE
	custom_assumed_doc_charset = FALSE;
	custom_display_charset = FALSE;
	memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
#endif

#ifdef USE_PRETTYSRC
	html_src_on_lynxcfg_reload();
#endif
	/* free downloaders, printers, environments, dired menu */
	free_lynx_cfg();
#ifdef SOURCE_CACHE
	source_cache_file_error = FALSE; /* reset flag */
d1895 1
d1902 1
a1902 1
	 *  Process the temporary RC file.
d1904 1
a1904 4
	rcfp = fopen(tempfile, "r");
	read_rc(rcfp);
	LYRemoveTemp(tempfile);
	FREE(tempfile);		/* done with it - kw */
a1905 3
#ifdef EXP_CHARSET_CHOICE
	init_charset_subsets();
#endif
a1923 5
	if (user_mode == NOVICE_MODE) {
	    display_lines = LYlines - 4;
	} else {
	    display_lines = LYlines - 2;
	}
d1928 1
a1928 1
#ifdef EXP_PERSISTENT_COOKIES
d1930 8
a1937 16
	if (persistent_cookies != persistent_cookies_flag) {
	    persistent_cookies = persistent_cookies_flag;
	    HTAlert(gettext("persistent cookies state will be changed in next session only."));
	}
	if (persistent_cookies) {
	    if (strcmp(LYCookieFile, LYCookieFile_flag)) {
		StrAllocCopy(LYCookieFile, LYCookieFile_flag);
		CTRACE((tfp, "cookie file can be changed in next session only, restored.\n"));
	    }
	    if (strcmp(LYCookieSaveFile, LYCookieSaveFile_flag)) {
		StrAllocCopy(LYCookieSaveFile, LYCookieSaveFile_flag);
		CTRACE((tfp, "cookie save file can be changed in next session only, restored.\n"));
	    }
	    FREE(LYCookieFile_flag);
	    FREE(LYCookieSaveFile_flag);
	}
d1955 29
a1983 5
#define PARSE_SET(n,t,v,h) {n,    t, UNION_SET(v), h}
#define PARSE_INT(n,t,v,h) {n,    t, UNION_INT(v), h}
#define PARSE_STR(n,t,v,h) {n,    t, UNION_STR(v), h}
#define PARSE_FUN(n,t,v,h) {n,    t, UNION_FUN(v), h}
#define PARSE_NIL          {NULL, 0, UNION_DEF(0), NULL}
d1989 10
a1998 10

#define TOGGLE_ARG		0x0010
#define SET_ARG			0x0020
#define UNSET_ARG		0x0030
#define FUNCTION_ARG		0x0040
#define LYSTRING_ARG		0x0050
#define INT_ARG			0x0060
#define STRING_ARG		0x0070
#define ARG_TYPE_MASK		0x0FF0
#define NEED_NEXT_ARG		0x1000
d2012 1
a2012 1
Config_Type;
d2015 1
a2015 1
PRIVATE int parse_authentication ARGS2(
d2047 1
a2047 1
PRIVATE int anonymous_fun ARGS1(
d2050 9
a2058 4
    if (!LYValidate && !LYRestricted)
	parse_restrictions("default");
    LYRestricted = TRUE;
    return 0;
d2062 1
a2062 1
PRIVATE int assume_charset_fun ARGS1(
d2076 1
a2076 1
PRIVATE int assume_local_charset_fun ARGS1(
d2084 1
a2084 1
PRIVATE int assume_unrec_charset_fun ARGS1(
d2092 1
a2092 1
PRIVATE int auth_fun ARGS1(
d2100 1
a2100 1
PRIVATE int base_fun ARGS1(
d2118 10
d2129 1
a2129 1
PRIVATE int cache_fun ARGS1(
d2143 1
a2143 1
PRIVATE int child_fun ARGS1(
d2153 1
a2153 1
PRIVATE int color_fun ARGS1(
a2164 44
#ifdef MISC_EXP
/* -convert_to */
PRIVATE int convert_to_fun ARGS1(
	char *,			next_arg)
{
    if (next_arg != 0) {
	char *outformat = NULL;
	char *cp1, *cp2, *cp4;
	int chndl;
	StrAllocCopy(outformat, next_arg);
	/* not lowercased, to allow for experimentation - kw */
	/*LYLowerCase(outformat);*/
	if ((cp1 = strchr(outformat, ';')) != NULL) {
	    if ((cp2 = LYstrstr(cp1, "charset")) != NULL) {
		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
		    cp2++;
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '\"' &&
				 *cp4 != ';'  &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
		*cp4 = '\0';
		/* This is intentionally not the "safe" version,
		   to allow for experimentation. */
		chndl = UCGetLYhndl_byMIME(cp2);
		if (chndl < 0) chndl = UCLYhndl_for_unrec;
		if (chndl < 0) {
		    fprintf(stderr,
		    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
		} else {
		    current_char_set = chndl;
		}
		*cp1 = '\0';	/* truncate outformat */
	    }
	}
	HTOutputFormat = HTAtom_for(outformat);
	FREE(outformat);
    } else {
	HTOutputFormat = NULL;
    }
    return 0;
}
#endif

d2166 1
a2166 1
PRIVATE int crawl_fun ARGS1(
d2170 1
a2170 1
    LYcols = DFT_COLS;
d2175 1
a2175 1
PRIVATE int display_fun ARGS1(
d2180 2
a2186 19
/* -display_charset */
PRIVATE int display_charset_fun ARGS1(
	char *,			next_arg)
{
    int i = UCGetLYhndl_byMIME(next_arg);

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (i < 0 && !strcasecomp(next_arg, "auto"))
	i = auto_display_charset;
#endif
    if (i < 0) {	/* do nothing here: so fallback to lynx.cfg */
	fprintf(stderr,
		gettext("Lynx: ignoring unrecognized charset=%s\n"), next_arg);
    }
    else
	current_char_set = i;
    return 0;
}

d2188 1
a2188 1
PRIVATE int dump_output_fun ARGS1(
d2192 1
a2192 1
    LYcols = DFT_COLS;
d2197 1
a2197 1
PRIVATE int editor_fun ARGS1(
d2207 1
a2207 1
PRIVATE int error_file_fun ARGS1(
d2221 1
a2221 1
PRIVATE int exec_fun ARGS1(
d2234 1
a2234 1
PRIVATE int get_data_fun ARGS1(
d2252 1
a2252 1
    LYcols = DFT_COLS;
d2262 8
a2269 1
    while (GetStdin(&buf, TRUE)) {
d2277 1
a2277 1
PRIVATE int help_fun ARGS1(
d2285 1
a2285 1
PRIVATE int hiddenlinks_fun ARGS1(
d2305 1
a2305 1
PRIVATE int homepage_fun ARGS1(
d2316 1
a2316 1
PRIVATE int mime_header_fun ARGS1(
d2326 1
a2326 1
    LYcols = MAX_COLS;
d2332 1
a2332 1
PRIVATE int newschunksize_fun ARGS1(
d2348 1
a2348 1
PRIVATE int newsmaxchunk_fun ARGS1(
a2363 8
/* -nobold */
PRIVATE int nobold_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
   LYnoVideo(1);
   return 0;
}

d2365 1
a2365 1
PRIVATE int nobrowse_fun ARGS1(
d2373 1
a2373 1
PRIVATE int nocolor_fun ARGS1(
d2385 1
a2385 1
PRIVATE int nopause_fun ARGS1(
a2393 31
/* -noreverse */
PRIVATE int noreverse_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
   LYnoVideo(2);
   return 0;
}

/* -nounderline */
PRIVATE int nounderline_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
   LYnoVideo(4);
   return 0;
}

#ifdef MISC_EXP
/* -nozap */
PRIVATE int nozap_fun ARGS1(
	char *,			next_arg)
{
    LYNoZapKey = 1; /* everything but "initially" treated as "full" - kw */
    if (next_arg != 0) {
	if (strcasecomp(next_arg, "initially") == 0)
	    LYNoZapKey = 2;

    }
   return 0;
}
#endif /* MISC_EXP */

d2395 1
a2395 1
PRIVATE int pauth_fun ARGS1(
d2403 1
a2403 1
PRIVATE int post_data_fun ARGS1(
d2421 1
a2421 1
    LYcols = DFT_COLS;
d2430 8
a2437 1
    while (GetStdin(&buf, TRUE)) {
d2444 1
a2444 1
PRIVATE int restrictions_fun ARGS1(
d2447 7
a2453 7
    static CONST struct {
	CONST char *name;
	CONST char *help;
    } table[] = {
	{ "all", "restricts all options." },
	{ "bookmark", "disallow changing the location of the bookmark file" },
	{ "bookmark_exec", "disallow execution links via the bookmark file" },
d2455 3
a2457 4
	{ "change_exec_perms", "\
disallow changing the eXecute permission on files\n\
(but still allow it for directories) when local file\n\
management is enabled." },
d2459 6
a2464 14
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	{ "compileopts_info", "\
disable info on options used to compile the binary" },
#endif
{ "default", "\
same as commandline option -anonymous.  Sets the\n\
default service restrictions for anonymous users.  Set to\n\
all restricted, except for: inside_telnet, outside_telnet,\n\
inside_ftp, outside_ftp, inside_rlogin, outside_rlogin,\n\
inside_news, outside_news, telnet_port, jump, mail, print,\n\
exec, and goto.  The settings for these, as well as\n\
additional goto restrictions for specific URL schemes\n\
that are also applied, are derived from definitions\n\
within userdefs.h." },
d2466 1
a2466 1
	{ "dired_support", "disallow local file management" },
d2468 6
a2473 6
	{ "disk_save", "disallow saving to disk in the download and print menus" },
	{ "dotfiles", "disallow access to, or creation of, hidden (dot) files" },
	{ "download", "disallow some downloaders in the download menu" },
	{ "editor", "disallow editing" },
	{ "exec", "disable execution scripts" },
	{ "exec_frozen", "disallow the user from changing the execution link option" },
d2475 1
a2475 1
	{ "externals", "disable passing URLs to some external programs" },
d2477 3
a2479 4
	{ "file_url", "\
disallow using G)oto, served links or bookmarks for\n\
file: URL's" },
	{ "goto", "disable the 'g' (goto) command" },
d2481 14
a2494 22
	{ "inside_ftp", "\
disallow ftps coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain (utmp required for selectivity)" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_telnet", "\
disallow telnets coming from inside your\n\
domain (utmp required for selectivity)" },
#else
	{ "inside_ftp", "\
disallow ftps coming from inside your domain" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your domain" },
	{ "inside_telnet", "\
disallow telnets coming from inside your domain" },
d2496 5
a2500 11
	{ "jump", "disable the 'j' (jump) command" },
	{ "lynxcfg_info", "\
disable viewing of lynx.cfg configuration file info" },
#ifndef NO_CONFIG_INFO
	{ "lynxcfg_xinfo", "\
disable extended lynx.cfg viewing and reloading" },
#endif
	{ "mail", "disallow mail" },
	{ "multibook", "disallow multiple bookmark files" },
	{ "news_post", "disallow USENET News posting." },
	{ "option_save", "disallow saving options in .lynxrc" },
d2502 14
a2515 22
	{ "outside_ftp", "\
disallow ftps coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain (utmp required for selectivity)" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_telnet", "\
disallow telnets coming from outside your\n\
domain (utmp required for selectivity)" },
#else
	{ "outside_ftp", "\
disallow ftp coming from outside your domain" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your domain" },
	{ "outside_telnet", "\
disallow telnets coming from outside your domain" },
d2517 6
a2522 14
	{ "print", "disallow most print options" },
	{ "shell", "\
disallow shell escapes, and lynxexec, lynxprog or lynxcgi\n\
G)oto's" },
	{ "suspend", "disallow Control-Z suspends with escape to shell" },
	{ "telnet_port", "disallow specifying a port in telnet G)oto's" },
	{ "useragent", "disallow modifications of the User-Agent header" },
    };
    static CONST char *Usage[] = {
 ""
,"USAGE: lynx -restrictions=[option][,option][,option]"
,"List of Options:"
,"  ?                 when used alone, list restrictions in effect."

d2524 1
a2524 4
    unsigned j, k, column = 0;
    CONST char *name;
    CONST char *value;
    BOOLEAN found, first;
d2526 3
a2528 54
    if (next_arg == 0 || *next_arg == '\0') {
	SetOutputMode( O_TEXT );
	for (j = 0; j < TABLESIZE(Usage); j++) {
	    printf("%s\n", Usage[j]);
	}
	for (j = 0; j < TABLESIZE(table); j++) {
	    if (!strcmp(table[j].name, "all")
	     || !strcmp(table[j].name, "default")) {
		value = NULL;
	    } else {
		switch (find_restriction(table[j].name, -1)) {
		case TRUE:
		    value = "on";
		    break;
		case FALSE:
		    value = "off";
		    break;
		default:
		    value = "?";
		    break;
		}
	    }
	    print_help_strings (
		table[j].name, table[j].help, value, FALSE);
	}
	first = TRUE;
	for (j = 0; ; j++) {
	    found = FALSE;
	    if ((name = index_to_restriction(j)) == 0) {
		break;
	    }
	    for (k = 0; k < TABLESIZE(table); k++) {
		if (!strcmp(name, table[k].name)) {
		    found = TRUE;
		}
	    }
	    if (!found) {
		if (first) {
		    printf("Other restrictions (see the user's guide):\n");
		}
		printf("%s%s", column ? ", " : "  ", name);
		column += 2 + strlen(name);
		if (column > 50) {
		    column = 0;
		    printf("\n");
		}
		first = FALSE;
	    }
	}
	if (column)
	    printf("\n");
	SetOutputMode( O_BINARY );
	exit(EXIT_SUCCESS);
    } else if (*next_arg == '?') {
d2530 2
a2531 1
	print_restrictions_to_fd(stdout);
d2533 1
a2533 3
	exit(EXIT_SUCCESS);
    } else {
	parse_restrictions(next_arg);
d2539 1
a2539 1
PRIVATE int selective_fun ARGS1(
d2547 1
a2547 1
PRIVATE int source_fun ARGS1(
d2553 1
a2553 1
    LYcols = MAX_COLS;
d2558 1
a2558 1
PRIVATE int traversal_fun ARGS1(
d2563 1
a2563 1
    LYcols = DFT_COLS;
d2565 1
a2565 1
    LYcols = MAX_COLS;
d2572 1
a2572 1
PRIVATE int version_fun ARGS1(
a2574 5
#ifdef USE_SSL
    char SSLLibraryVersion[256];
    char *SSLcp;
#endif

d2577 2
a2578 1
    printf(gettext("%s Version %s (%s)\n"),
d2580 3
a2582 16
	  LYVersionDate());
#ifdef USE_SSL
    printf("libwww-FM %s, SSL-MM 1.4.1", HTLibraryVersion);
#ifdef OPENSSL_VERSION_TEXT
    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = ' ';
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    printf(", %s", SSLLibraryVersion);
	}
    }
#endif /* OPENSSL_VERSION_TEXT */
    printf("\n");
#endif /* USE_SSL */

a2591 1

a2599 27
#ifdef USE_SSL
    printf("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.\n");
#ifdef OPENSSL_VERSION_TEXT
    printf("See http://www.openssl.org/ for information about OpenSSL.\n");
#endif /* OPENSSL_VERSION_TEXT */
    printf("\n");
#endif /* USE_SSL */

#ifdef SH_EX
#ifdef __CYGWIN__
    printf("Compiled by CYGWIN (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __BORLANDC__
    printf("Compiled by Borland C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef _MSC_VER
    printf("Compiled by Microsoft Visual C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __DJGPP__
    printf("Compiled by DJGPP (%s %s).\n", __DATE__, __TIME__);
#else
    printf("Compiled at (%s %s).\n", __DATE__, __TIME__);
#endif /* __DJGPP__ */
#endif /* _MSC_VER */
#endif /* __BORLANDC__ */
#endif /* __CYGWIN__ */
#endif /* SH_EX */
d2603 1
a2603 1
    exit(EXIT_SUCCESS);
d2609 1
a2609 1
PRIVATE int width_fun ARGS1(
d2615 1
a2615 1
	    dump_output_width = ((w < MAX_COLS) ? w : MAX_COLS);
d2621 2
a2622 2
/* NOTE: This table is sorted by name to make the help message useful */
PRIVATE Config_Type Arg_Table [] =
d2625 2
a2626 2
      "accept_all_cookies", 4|SET_ARG,		LYAcceptAllCookies,
      "\naccept cookies without prompting if Set-Cookie handling\nis on"
d2629 2
a2630 2
      "anonymous",	2|FUNCTION_ARG,		anonymous_fun,
      "apply restrictions for anonymous account,\nsee also -restrictions"
d2633 1
a2633 1
      "assume_charset", 4|NEED_FUNCTION_ARG,	assume_charset_fun,
d2637 1
a2637 1
      "assume_local_charset",	4|NEED_FUNCTION_ARG,assume_local_charset_fun,
d2641 1
a2641 1
      "assume_unrec_charset",	4|NEED_FUNCTION_ARG,assume_unrec_charset_fun,
d2645 1
a2645 1
      "auth",		4|NEED_FUNCTION_ARG,	auth_fun,
d2649 1
a2649 1
      "base",		4|FUNCTION_ARG,		base_fun,
d2652 4
a2655 10
#ifndef DISABLE_BIBP
   PARSE_STR(
      "bibhost",	4|NEED_LYSTRING_ARG,	BibP_bibhost,
      "=URL\nlocal bibp server (default http://bibhost/)"
   ),
#endif
#ifdef USE_BLINK
   PARSE_SET(
      "blink",		4|SET_ARG,		term_blink_is_boldbg,
      "enable bright background via the BLINK terminal attribute"
d2659 1
a2659 1
      "book",		4|SET_ARG,		bookmark_start,
d2663 1
a2663 1
      "buried_news",	4|TOGGLE_ARG,		scan_for_buried_news_references,
d2667 1
a2667 1
      "cache",		4|NEED_FUNCTION_ARG,	cache_fun,
d2671 1
a2671 1
      "case",		4|SET_ARG,		case_sensitive,
a2673 6
#ifdef SH_EX
   PARSE_SET(
      "center",		4|TOGGLE_ARG,		no_table_center,
      "Toggle center alignment in HTML TABLE"
   ),
#endif
d2675 1
a2675 1
      "cfg",		2|NEED_LYSTRING_ARG,	lynx_cfg_file,
d2679 1
a2679 1
      "child",		4|FUNCTION_ARG,		child_fun,
a2681 10
#ifdef EXP_CMD_LOGGING
   PARSE_STR(
       "cmd_log",	2|NEED_LYSTRING_ARG,	lynx_cmd_logfile,
       "=FILENAME\nlog keystroke commands to the given file"
   ),
   PARSE_STR(
       "cmd_script",	2|NEED_LYSTRING_ARG,	lynx_cmd_script,
       "=FILENAME\nread keystroke commands from the given file\n(see -cmd_log)"
   ),
#endif
d2684 1
a2684 1
      "color",		4|FUNCTION_ARG,		color_fun,
d2688 3
a2690 10
#ifndef __DJGPP__
   PARSE_INT(
      "connect_timeout", 4|NEED_INT_ARG,	connect_timeout,
      "=N\nset the N-second connection timeout"
   ),
#endif
#ifdef MISC_EXP
   PARSE_FUN(
      "convert_to",	4|FUNCTION_ARG,		convert_to_fun,
      "=FORMAT\nconvert input, FORMAT is in MIME type notation\n(experimental)"
a2691 1
#endif
d2694 1
a2694 5
      "cookie_file",	4|LYSTRING_ARG,		LYCookieFile,
      "=FILENAME\nspecifies a file to use to read cookies"
   ),
   PARSE_STR(
      "cookie_save_file",	4|LYSTRING_ARG,	LYCookieSaveFile,
a2697 4
   PARSE_SET(
      "cookies",	4|TOGGLE_ARG,		LYSetCookies,
      "toggles handling of Set-Cookie headers"
   ),
d2700 1
a2700 1
      "core",		4|TOGGLE_ARG,		LYNoCore,
d2705 1
a2705 1
      "crawl",		4|FUNCTION_ARG,		crawl_fun,
a2708 6
#ifdef USE_CURSES_PADS
   PARSE_SET(
      "curses_pads",	4|TOGGLE_ARG,		LYuseCursesPads,
      "uses curses pad feature to support left/right shifting"
   ),
#endif
d2711 1
a2711 1
      "debug_partial",	4|TOGGLE_ARG,		debug_display_partial,
a2714 6
#if defined(SH_EX) && defined(WIN_EX)
   PARSE_INT(
      "delay",		4|NEED_INT_ARG,		debug_delay,
      "=NNN\nset the NNN msec delay at statusline message"
   ),
#endif
d2716 1
a2716 1
      "display",	4|NEED_FUNCTION_ARG,	display_fun,
d2720 1
a2720 10
      "display_charset", 4|NEED_FUNCTION_ARG,	display_charset_fun,
      "=MIMEname\ncharset for the terminal output"
   ),
   PARSE_SET(
      "dont_wrap_pre",	4|SET_ARG,		dont_wrap_pre,
      "inhibit wrapping of text in <pre> when -dump'ing and\n\
-crawl'ing, mark wrapped lines in interactive session"
   ),
   PARSE_FUN(
      "dump",		4|FUNCTION_ARG,		dump_output_fun,
d2724 1
a2724 1
      "editor",		4|NEED_FUNCTION_ARG,	editor_fun,
d2728 1
a2728 1
      "emacskeys",	4|SET_ARG,		emacs_keys,
d2732 1
a2732 1
      "enable_scrollback", 4|TOGGLE_ARG,	enable_scrollback,
d2737 1
a2737 1
      "error_file",	4|NEED_FUNCTION_ARG,	error_file_fun,
d2743 1
a2743 1
      "exec",		4|FUNCTION_ARG,		exec_fun,
d2747 8
d2758 1
a2758 1
      "fileversions",	4|SET_ARG,		HTVMSFileVersions,
d2763 2
a2764 2
      "force_empty_hrefless_a",	4|SET_ARG,	force_empty_hrefless_a,
      "\nforce HREF-less 'A' elements to be empty (close them as\nsoon as they are seen)"
d2767 2
a2768 2
      "force_html",	4|SET_ARG,		LYforce_HTML_mode,
      "forces the first document to be interpreted as HTML"
d2771 2
a2772 2
      "force_secure",	4|TOGGLE_ARG,		LYForceSSLCookiesSecure,
      "toggles forcing of the secure flag for SSL cookies"
d2776 1
a2776 1
      "forms_options",	4|TOGGLE_ARG,		LYUseFormsOptions,
d2781 1
a2781 5
      "from",		4|TOGGLE_ARG,		LYNoFromHeader,
      "toggle transmission of From headers"
   ),
   PARSE_SET(
      "ftp",		4|UNSET_ARG,		ftp_ok,
d2785 1
a2785 1
      "get_data",	6|FUNCTION_ARG,		get_data_fun,
d2789 1
a2789 1
      "head",		4|SET_ARG,		HEAD_request,
d2793 1
a2793 1
      "help",		5|FUNCTION_ARG,		help_fun,
d2797 1
a2797 1
      "hiddenlinks",	4|NEED_FUNCTION_ARG,	hiddenlinks_fun,
d2801 2
a2802 2
      "historical",	4|TOGGLE_ARG,		historical_comments,
      "toggles use of '>' or '-->' as terminator for comments"
d2805 1
a2805 1
      "homepage",	4|NEED_FUNCTION_ARG,	homepage_fun,
d2809 1
a2809 1
      "image_links",	4|TOGGLE_ARG,		clickable_images,
d2813 1
a2813 1
      "index",		4|NEED_LYSTRING_ARG,	indexfile,
d2817 1
a2817 1
      "ismap",		4|TOGGLE_ARG,		LYNoISMAPifUSEMAP,
a2819 6
#ifdef EXP_JUSTIFY_ELTS
   PARSE_SET(
      "justify",	4|SET_ARG,		ok_justify,
      "do justification of text"
   ),
#endif
d2821 1
a2821 1
      "link",		4|NEED_INT_ARG,		ccount,
d2825 1
a2825 1
      "localhost",	4|SET_ARG,		local_host_only,
d2828 1
a2828 7
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "locexec",	4|SET_ARG,		local_exec_on_local_files,
      "enable local program execution from local files only"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#if defined(USE_COLOR_STYLE)
d2830 1
a2830 1
      "lss",		2|NEED_LYSTRING_ARG,	lynx_lss_file,
d2835 1
a2835 1
      "mime_header",	4|FUNCTION_ARG,		mime_header_fun,
d2839 1
a2839 1
      "minimal",	4|TOGGLE_ARG,		minimal_comments,
d2844 1
a2844 1
      "newschunksize",	4|NEED_FUNCTION_ARG,	newschunksize_fun,
d2848 1
a2848 1
      "newsmaxchunk",	4|NEED_FUNCTION_ARG,	newsmaxchunk_fun,
a2851 10
#if USE_BLAT_MAILER
   PARSE_SET(
      "noblat",		4|TOGGLE_ARG,		mail_is_blat,
      "select mail tool (`BLAT' ==> `sendmail')"
   ),
#endif
   PARSE_FUN(
      "nobold",		4|FUNCTION_ARG,		nobold_fun,
      "disable bold video-attribute"
   ),
d2853 1
a2853 1
      "nobrowse",	4|FUNCTION_ARG,		nobrowse_fun,
d2857 1
a2857 1
      "nocc",		4|SET_ARG,		LYNoCc,
d2861 1
a2861 1
      "nocolor",	4|FUNCTION_ARG,		nocolor_fun,
a2863 6
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "noexec",		4|UNSET_ARG,		local_exec,
      "disable local program execution (DEFAULT)"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
d2865 2
a2866 2
      "nofilereferer",	4|SET_ARG,		no_filereferer,
      "disable transmission of Referer headers for file URLs"
d2869 1
a2869 1
      "nolist",		4|SET_ARG,		nolist,
d2873 1
a2873 1
      "nolog",		4|UNSET_ARG,		error_logging,
a2875 6
#if HAVE_SIGACTION && defined(SIGWINCH)
   PARSE_SET(
      "nonrestarting_sigwinch", 4|SET_ARG,	LYNonRestartingSIGWINCH,
      "\nmake window size change handler non-restarting"
   ),
#endif /* HAVE_SIGACTION */
d2877 1
a2877 1
      "nopause",	4|FUNCTION_ARG,		nopause_fun,
d2881 2
a2882 2
      "noprint",	4|SET_ARG,		no_print,
      "disable some print functions, like -restrictions=print"
d2885 1
a2885 1
      "noredir",	4|SET_ARG,		no_url_redirection,
d2889 2
a2890 6
      "noreferer",	4|SET_ARG,		LYNoRefererHeader,
      "disable transmission of Referer headers"
   ),
   PARSE_FUN(
      "noreverse",	4|FUNCTION_ARG,		noreverse_fun,
      "disable reverse video-attribute"
d2894 1
a2894 1
      "nosocks",	6|UNSET_ARG,		socks_flag,
d2899 1
a2899 1
      "nostatus",	4|SET_ARG,		no_statusline,
a2901 14
   PARSE_FUN(
      "nounderline",	4|FUNCTION_ARG,		nounderline_fun,
      "disable underline video-attribute"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "nozap",		4|FUNCTION_ARG,		nozap_fun,
      "=DURATION (\"initially\" or \"full\") disable checks for 'z' key"
   ),
#endif
   PARSE_SET(
      "number_fields",	4|SET_ARG,		number_fields,
      "force numbering of links as well as form input fields"
   ),
d2903 1
a2903 1
      "number_links",	4|SET_ARG,		number_links,
d2908 1
a2908 1
      "partial",	4|TOGGLE_ARG,		display_partial_flag,
d2912 1
a2912 1
      "partial_thres",	4|NEED_INT_ARG,		partial_threshold,
d2918 1
a2918 1
      "pauth",		4|NEED_FUNCTION_ARG,	pauth_fun,
d2922 1
a2922 1
      "popup",		4|UNSET_ARG,		LYUseDefSelPop,
d2926 1
a2926 1
      "post_data",	6|FUNCTION_ARG,		post_data_fun,
d2930 1
a2930 1
      "preparsed",	4|SET_ARG,		LYPreparsedSource,
d2934 1
a2934 1
#ifdef USE_PRETTYSRC
d2936 2
a2937 2
      "prettysrc",	4|SET_ARG,		LYpsrc,
      "do syntax highlighting and hyperlink handling in source\nview"
d2941 2
a2942 2
      "print",		4|UNSET_ARG,		no_print,
      "enable print functions (DEFAULT), opposite of -noprint"
d2945 1
a2945 1
      "pseudo_inlines", 4|TOGGLE_ARG,		pseudo_inline_alts,
d2949 2
a2950 3
      "raw",		4|UNSET_ARG,		LYUseDefaultRawMode,
      "toggles default setting of 8-bit character translations\n\
or CJK mode for the startup character set"
d2953 1
a2953 1
      "realm",		4|SET_ARG,		check_realm,
d2957 1
a2957 1
      "reload",		4|SET_ARG,		reloading,
d2961 1
a2961 1
      "restrictions",	4|FUNCTION_ARG,		restrictions_fun,
d2965 1
a2965 1
      "resubmit_posts", 4|TOGGLE_ARG,		LYresubmit_posts,
d2971 1
a2971 1
      "rlogin",		4|UNSET_ARG,		rlogin_ok,
a2973 10
#ifdef USE_SCROLLBAR
   PARSE_SET(
      "scrollbar",	4|TOGGLE_ARG,		LYsb,
      "toggles showing scrollbar"
   ),
   PARSE_SET(
      "scrollbar_arrow", 4|TOGGLE_ARG,		LYsb_arrow,
      "toggles showing arrows at ends of the scrollbar"
   ),
#endif
d2975 1
a2975 1
      "selective",	4|FUNCTION_ARG,		selective_fun,
d2979 1
a2979 11
      "short_url",	4|SET_ARG,		long_url_ok,
      "enables examination of beginning and end of long URL in\nstatus line"
   ),
#ifdef SH_EX
   PARSE_SET(
      "show_cfg",	4|SET_ARG,		show_cfg,
      "Show `LYNX.CFG' setting"
   ),
#endif
   PARSE_SET(
      "show_cursor",	4|TOGGLE_ARG,		LYUseDefShoCur,
a2981 6
#ifdef EXP_READPROGRESS
   PARSE_SET(
      "show_rate",	4|TOGGLE_ARG,		LYShowTransferRate,
      "toggles display of transfer rate"
   ),
#endif
d2983 1
a2983 1
      "soft_dquotes",	4|TOGGLE_ARG,		soft_dquotes,
d2988 1
a2988 1
      "source",		4|FUNCTION_ARG,		source_fun,
d2992 1
a2992 1
      "stack_dump",	4|SET_ARG,		stack_dump,
d2996 1
a2996 1
      "startfile_ok",	4|SET_ARG,		startfile_ok,
a2998 4
   PARSE_SET(
      "stdin",		4|SET_ARG,		startfile_stdin,
      "read startfile from standard input"
   ),
d3002 1
a3002 1
      "syslog",		4|NEED_LYSTRING_ARG,	syslog_txt,
d3008 1
a3008 1
      "tagsoup",	4|SET_ARG,		DTD_recovery,
d3012 1
a3012 1
      "telnet",		4|UNSET_ARG,		telnet_ok,
d3016 1
a3016 1
      "term",		4|NEED_STRING_ARG,	terminal,
a3018 6
#ifdef _WINDOWS
   PARSE_INT(
      "timeout",	4|INT_ARG,		lynx_timeout,
      "=NUMBER\nset TCP/IP timeout"
   ),
#endif
d3020 1
a3020 1
      "tlog",		2|TOGGLE_ARG,		LYUseTraceLog,
a3022 1
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
d3024 1
a3024 7
      "tna",		4|SET_ARG,		textfields_activation_option,
      "turn on \"Textfields Need Activation\" mode"
   ),
#endif
#ifndef NO_LYNX_TRACE
   PARSE_SET(
      "trace",		2|SET_ARG,		WWW_TraceFlag,
a3026 5
   PARSE_INT(
      "trace_mask",	2|INT_ARG,		WWW_TraceMask,
      "customize Lynx trace mode"
   ),
#endif
d3028 1
a3028 1
      "traversal",	4|FUNCTION_ARG,		traversal_fun,
d3032 1
a3032 5
      "trim_input_fields", 2|SET_ARG,		LYtrimInputFields,
      "trim input text/textarea fields in forms"
   ),
   PARSE_SET(
      "underscore",	4|TOGGLE_ARG,		use_underscore,
d3035 1
a3035 1
#if defined(USE_MOUSE)
d3037 2
a3038 2
      "use_mouse",	4|SET_ARG,		LYUseMouse,
      "turn on mouse support"
d3042 1
a3042 1
      "useragent",	4|NEED_LYSTRING_ARG,	LYUserAgent,
d3046 2
a3047 2
      "validate",	2|SET_ARG,		LYValidate,
      "accept only http URLs (meant for validation)\nimplies more restrictions than -anonymous, but\ngoto is allowed for http and https"
d3050 1
a3050 1
      "verbose",	4|TOGGLE_ARG,		verbose_img,
d3054 1
a3054 1
      "version",	4|FUNCTION_ARG,		version_fun,
d3058 1
a3058 1
      "vikeys",		4|SET_ARG,		vi_keys,
a3060 6
#ifdef __DJGPP__
   PARSE_SET(
      "wdebug",		4|TOGGLE_ARG,		watt_debug,
      "enables Waterloo tcp/ip packet debug. Prints to watt\ndebugfile"
  ),
#endif /* __DJGPP__ */
d3062 1
a3062 1
      "width",		4|NEED_FUNCTION_ARG,	width_fun,
d3065 1
a3065 7
#ifndef NO_DUMP_WITH_BACKSPACES
   PARSE_SET(
      "with_backspaces", 4|SET_ARG,		with_backspaces,
      "emit backspaces in output if -dumping or -crawling\n(like 'man' does)"
   ),
#endif
   PARSE_NIL
d3068 1
a3068 1
PRIVATE void print_help_strings ARGS4(
d3071 1
a3071 2
	CONST char *,	value,
	BOOLEAN,	option)
d3078 1
a3078 1
    pad = field_width - (2 + option + (int) strlen (name));
d3080 1
a3080 1
    fprintf (stdout, "  %s%s", option ? "-" : "", name);
d3119 1
a3119 1
PRIVATE void print_help_and_exit ARGS1(int, exit_status)
d3121 1
a3121 1
    Config_Type *p;
a3128 1
#ifdef VMS
d3131 1
a3131 4
in double-quotes (\"-\") on VMS)", NULL, TRUE);
#else
    print_help_strings("", "receive options and arguments from stdin", NULL, TRUE);
#endif /* VMS */
d3135 5
a3139 2
	ParseUnionPtr q = ParseUnionOf(p);

d3143 1
a3143 1
		strcpy(temp, *(q->set_value) ? "on" : "off");
d3146 1
a3146 1
		strcpy(temp, *(q->set_value) ? "off" : "on");
d3160 1
a3160 1
	print_help_strings(p->name, p->help_string, value, TRUE);
d3176 1
a3176 1
PRIVATE int arg_eqs_parse ARGS3(
a3180 2
    int result = -1;

d3182 1
a3182 1
    while (result < 0) {
a3187 5
		case '\t':	/* embedded blank when reading stdin */
		case ' ':
		    *c = LYSkipBlanks(b);
		    result = 1;
		    break;
a3188 1
		case ':':
d3190 2
a3191 10
		    result = 1;
		    break;
		case '-':
#if OPTNAME_ALLOW_DASHES
		    if (isalpha(UCH(b[1]))) {
			result = 0;
			break;
		    }
#endif
		    /* FALLTHRU */
d3194 1
a3194 2
		    result = 1;
		    break;
d3196 1
a3196 2
		    result = 1;
		    break;
d3198 1
a3198 2
		    result = 0;
		    break;
d3201 1
a3201 4
#if OPTNAME_ALLOW_DASHES
		if (!(*a == '_' && *b == '-'))
#endif
		result = 0;
d3206 1
a3206 2
    }
    return result;
d3212 1
a3212 1
PRIVATE BOOL parse_arg ARGS3(
a3213 1
	unsigned,	mask,
d3216 1
a3216 1
    Config_Type *p;
a3217 3
#if EXTENDED_STARTFILE_RECALL
    static BOOLEAN had_nonoption = FALSE;
#endif
a3229 6
#if EXTENDED_STARTFILE_RECALL
	if (had_nonoption && !dump_output_immediately) {
	    HTAddGotoURL(startfile); /* startfile was set by a previous arg */
	}
	had_nonoption = TRUE;
#endif
d3232 1
a3232 13
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 20:11:17 */
	HTUnEscape(startfile);
	{
	    char *p;

	    p = startfile;
	    while (*p++) {
		if (*p == '|')
		    *p = ':';
	    }
	}
#endif
	return (BOOL)(i != 0);
d3237 1
a3237 1
	return TRUE;
d3250 1
a3250 1
	return TRUE;
a3254 1
    CTRACE((tfp, "parse_arg(%s)\n", arg_name));
d3258 5
a3262 1
	ParseUnionPtr q = ParseUnionOf(p);
a3264 1
	char *temp_ptr = NULL;
d3272 4
a3275 13
	if (p->type & NEED_NEXT_ARG) {
	    if (next_arg == 0) {
		next_arg = argv[1];
		if ((i != 0) && (next_arg != 0))
		    (*i)++;
	    }
	    CTRACE((tfp, "...arg:%s\n", next_arg != 0 ? next_arg : "<null>"));
	}

	/* ignore option if it's not our turn */
	if ((p->type & mask) == 0) {
	    CTRACE((tfp, "...skip (mask %d/%d)\n", mask, p->type & 7));
	    return FALSE;
d3286 1
a3286 1
			 *(q->set_value) = (BOOL) !(*(q->set_value));
d3319 1
a3319 1
		 *(q->int_value) = strtol (next_arg, &temp_ptr, 0);
d3326 3
d3331 1
a3331 2
	Old_DTD = DTD_recovery;	/* BOOL != int */
	return TRUE;
a3337 1
    return FALSE;
d3370 1
a3370 1
	LYSleepAlert();
d3395 1
a3395 2
	if (!(sig == 0 && LYNoCore)) {
	    fprintf(stderr, "\r\n\
d3397 2
a3398 3
	}
	if (sig != 0) {
	    fprintf(stderr, "\r\n\
a3399 14
#ifdef WIN_EX	/* 1998/08/09 (Sun) 09:58:25 */
	{
	    char *msg;
	    switch (sig) {
	    case SIGABRT:	msg = "SIGABRT";	break;
	    case SIGFPE:	msg = "SIGFPE";		break;
	    case SIGILL:	msg = "SIGILL";		break;
	    case SIGSEGV:	msg = "SIGSEGV";	break;
	    default:		msg = "Not-def";	break;
	    }
	    fprintf(stderr, "signal code = %s\n", msg);
	}
#endif
	}
d3405 1
a3405 1
	    exit(EXIT_FAILURE);
d3417 1
a3417 1
	exit(EXIT_SUCCESS);
@

