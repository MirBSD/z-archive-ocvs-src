head	1.4;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.5
	tg-mergefixes-1-branch:1.1.3.5.0.8
	tg-mergefixes-1-base:1.1.3.5
	MIROS_X:1.1.3.5.0.6
	MIROS_X_BASE:1.1.3.5
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;
expand	@b@;


1.4
date	2005.01.03.00.46.05;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.38;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.35;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.28;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.35;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.23;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.44;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.11.45;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.16.06;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.54.13;	author tg;	state Stab;
branches;
next	;


desc
@@


1.4
log
@soft merge
@
text
@/* character level styles for Lynx
 * (c) 1996 Rob Partington -- donated to the Lyncei (if they want it :-)
 * $Id: LYStyle.c 1.59 Sun, 02 Jan 2005 15:35:21 -0800 dickey $
 */
#include <HTUtils.h>
#include <HTML.h>
#include <LYGlobalDefs.h>

#include <LYStructs.h>
#include <LYReadCFG.h>
#include <LYCurses.h>
#include <LYCharUtils.h>
#include <LYUtils.h>		/* defines TABLESIZE */
#include <AttrList.h>
#include <SGML.h>
#include <HTMLDTD.h>

/* Hash table definitions */
#include <LYHash.h>
#include <LYStyle.h>

#include <LYexit.h>
#include <LYLeaks.h>
#include <LYStrings.h>

#ifdef USE_COLOR_STYLE

static void style_initialiseHashTable(void);

/* stack of attributes during page rendering */
int last_styles[MAX_LAST_STYLES] =
{0};
int last_colorattr_ptr = 0;

bucket hashStyles[CSHASHSIZE];
bucket special_bucket =
{
    "<special>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
};
bucket nostyle_bucket =
{
    "<NOSTYLE>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
};

int cached_tag_styles[HTML_ELEMENTS];
int current_tag_style;
BOOL force_current_tag_style = FALSE;
char *forced_classname;
BOOL force_classname;

/* Remember the hash codes for common elements */
int s_a = NOSTYLE;
int s_aedit = NOSTYLE;
int s_aedit_arr = NOSTYLE;
int s_aedit_pad = NOSTYLE;
int s_aedit_sel = NOSTYLE;
int s_alert = NOSTYLE;
int s_alink = NOSTYLE;
int s_curedit = NOSTYLE;
int s_forw_backw = NOSTYLE;
int s_hot_paste = NOSTYLE;
int s_menu_active = NOSTYLE;
int s_menu_bg = NOSTYLE;
int s_menu_entry = NOSTYLE;
int s_menu_frame = NOSTYLE;
int s_menu_number = NOSTYLE;
int s_menu_sb = NOSTYLE;
int s_normal = NOSTYLE;
int s_prompt_edit = NOSTYLE;
int s_prompt_edit_arr = NOSTYLE;
int s_prompt_edit_pad = NOSTYLE;
int s_prompt_sel = NOSTYLE;
int s_status = NOSTYLE;
int s_title = NOSTYLE;
int s_whereis = NOSTYLE;

#ifdef USE_SCROLLBAR
int s_sb_aa = NOSTYLE;
int s_sb_bar = NOSTYLE;
int s_sb_bg = NOSTYLE;
int s_sb_naa = NOSTYLE;
#endif

/* start somewhere safe */
#define MAX_COLOR 16
static int colorPairs = 0;

#ifdef USE_BLINK
#  define MAX_BLINK	2
#  define M_BLINK	A_BLINK
#else
#  define MAX_BLINK	1
#  define M_BLINK	0
#endif

static unsigned char our_pairs[2]
[MAX_BLINK]
[MAX_COLOR + 1]
[MAX_COLOR + 1];

/*
 * Parse a string containing a combination of video attributes and color.
 */
static void parse_either(char *attrs,
			 int dft_color,
			 int *monop,
			 int *colorp)
{
    int value;

    while (*attrs != '\0') {
	char *next = strchr(attrs, '+');
	char save = (next != NULL) ? *next : '\0';

	if (next == NULL)
	    next = attrs + strlen(attrs);

	if (save != 0)		/* attrs might be a constant string */
	    *next = '\0';
	if ((value = string_to_attr(attrs)) != 0)
	    *monop |= value;
	else if (colorp != 0
		 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
	    *colorp = value;

	attrs = next;
	if (save != '\0')
	    *attrs++ = save;
    }
}

/* icky parsing of the style options */
static void parse_attributes(char *mono,
			     char *fg,
			     char *bg,
			     int style,
			     char *element)
{
    int mA = A_NORMAL;
    int fA = default_fg;
    int bA = default_bg;
    int cA = A_NORMAL;
    int newstyle = hash_code(element);

    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n",
			  style, newstyle, element));

    parse_either(mono, ERR_COLOR, &mA, (int *) 0);
    parse_either(bg, default_bg, &cA, &bA);
    parse_either(fg, default_fg, &cA, &fA);

    if (style == -1) {		/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n",
			      fA, bA));
	default_fg = fA;
	default_bg = bA;
	default_color_reset = TRUE;
	return;
    }
    if (fA == NO_COLOR) {
	bA = NO_COLOR;
    } else if (COLORS) {
#ifdef USE_BLINK
	if (term_blink_is_boldbg) {
	    if (fA >= COLORS)
		cA = A_BOLD;
	    if (bA >= COLORS)
		cA |= M_BLINK;
	} else
#endif
	if (fA >= COLORS || bA >= COLORS)
	    cA = A_BOLD;
	if (fA >= COLORS)
	    fA %= COLORS;
	if (bA >= COLORS)
	    bA %= COLORS;
    } else {
	cA = A_BOLD;
	fA = NO_COLOR;
	bA = NO_COLOR;
    }

    /*
     * If we have colour, and space to create a new colour attribute,
     * and we have a valid colour description, then add this style
     */
    if (lynx_has_color && colorPairs < COLOR_PAIRS - 1 && fA != NO_COLOR) {
	int curPair = 0;
	int iFg = (1 + (fA >= 0 ? fA : 0));
	int iBg = (1 + (bA >= 0 ? bA : 0));
	int iBold = !!(cA & A_BOLD);
	int iBlink = !!(cA & M_BLINK);

	CTRACE2(TRACE_STYLE, (tfp, "parse_attributes %d/%d %d/%d %#x\n",
			      fA, default_fg, bA, default_bg, cA));
	if (fA < MAX_COLOR
	    && bA < MAX_COLOR
#ifdef USE_CURSES_PAIR_0
	    && (cA != A_NORMAL || fA != default_fg || bA != default_bg)
#endif
	    && curPair < 255) {
	    if (our_pairs[iBold][iBlink][iFg][iBg] != 0) {
		curPair = our_pairs[iBold][iBlink][iFg][iBg];
	    } else {
		curPair = ++colorPairs;
		init_pair((short) curPair, (short) fA, (short) bA);
		our_pairs[iBold][iBlink][iFg][iBg] = curPair;
	    }
	}
	CTRACE2(TRACE_STYLE, (tfp, "CSS(CURPAIR):%d\n", curPair));
	if (style < DSTYLE_ELEMENTS)
	    setStyle(style, COLOR_PAIR(curPair) | cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair) | cA, cA, mA, element);
    } else {
	if (lynx_has_color && fA != NO_COLOR) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n",
		     COLOR_PAIRS - 1));
	}
	/* only mono is set */
	if (style < DSTYLE_ELEMENTS)
	    setStyle(style, -1, -1, mA);
	setHashStyle(newstyle, -1, -1, mA, element);
    }
}

/* parse a style option of the format
 * STYLE:<OBJECT>:FG:BG
 */
static void parse_style(char *param)
{
    /* *INDENT-OFF* */
    static struct {
	char *name;
	int style;
	int *set_hash;
    } table[] = {
	{ "default",		-1,			0 }, /* default fg/bg */
	{ "alink",		DSTYLE_ALINK,		0 }, /* active link */
	{ "a",			DSTYLE_LINK,		0 }, /* normal link */
	{ "a",			HTML_A,			0 }, /* normal link */
	{ "status",		DSTYLE_STATUS,		0 }, /* status bar */
	{ "label",		DSTYLE_OPTION,		0 }, /* [INLINE]'s */
	{ "value",		DSTYLE_VALUE,		0 }, /* [INLINE]'s */
	{ "high",		DSTYLE_HIGH,		0 }, /* [INLINE]'s */
	{ "normal",		DSTYLE_NORMAL,		0 },
	{ "candy",		DSTYLE_CANDY,		0 }, /* [INLINE]'s */
	{ "whereis",		DSTYLE_WHEREIS,		&s_whereis },
	{ "edit.active.pad",	DSTYLE_ELEMENTS,	&s_aedit_pad },
	{ "edit.active.arrow",	DSTYLE_ELEMENTS,	&s_aedit_arr },
	{ "edit.active.marked",	DSTYLE_ELEMENTS,	&s_aedit_sel },
	{ "edit.active",	DSTYLE_ELEMENTS,	&s_aedit },
	{ "edit.current",	DSTYLE_ELEMENTS,	&s_curedit },
	{ "edit.prompt.pad",	DSTYLE_ELEMENTS,	&s_prompt_edit_pad },
	{ "edit.prompt.arrow",	DSTYLE_ELEMENTS,	&s_prompt_edit_arr },
	{ "edit.prompt.marked",	DSTYLE_ELEMENTS,	&s_prompt_sel },
	{ "edit.prompt",	DSTYLE_ELEMENTS,	&s_prompt_edit },
	{ "forwbackw.arrow",	DSTYLE_ELEMENTS,	&s_forw_backw },
	{ "hot.paste",		DSTYLE_ELEMENTS,	&s_hot_paste },
	{ "menu.frame",		DSTYLE_ELEMENTS,	&s_menu_frame },
	{ "menu.bg",		DSTYLE_ELEMENTS,	&s_menu_bg },
	{ "menu.n",		DSTYLE_ELEMENTS,	&s_menu_number },
	{ "menu.entry",		DSTYLE_ELEMENTS,	&s_menu_entry },
	{ "menu.active",	DSTYLE_ELEMENTS,	&s_menu_active },
	{ "menu.sb",		DSTYLE_ELEMENTS,	&s_menu_sb },
    };
    /* *INDENT-ON* */

    unsigned n;
    BOOL found = FALSE;

    char *buffer = 0;
    char *tmp = 0;
    char *element, *mono, *fg, *bg;

    if (param == 0)
	return;
    CTRACE2(TRACE_STYLE, (tfp, "parse_style(%s)\n", param));
    StrAllocCopy(buffer, param);
    if (buffer == 0)
	return;

    if ((tmp = strchr(buffer, ':')) == 0) {
	fprintf(stderr, gettext("\
Syntax Error parsing style in lss file:\n\
[%s]\n\
The line must be of the form:\n\
OBJECT:MONO:COLOR (ie em:bold:brightblue:white)\n\
where OBJECT is one of EM,STRONG,B,I,U,BLINK etc.\n\n"), buffer);
	exit_immediately(EXIT_FAILURE);
    }
    strtolower(buffer);
    *tmp = '\0';
    element = buffer;

    mono = tmp + 1;
    tmp = strchr(mono, ':');

    if (!tmp) {
	fg = "nocolor";
	bg = "nocolor";
    } else {
	*tmp = '\0';
	fg = tmp + 1;
	tmp = strchr(fg, ':');
	if (!tmp)
	    bg = "default";
	else {
	    *tmp = '\0';
	    bg = tmp + 1;
	}
    }

    CTRACE2(TRACE_STYLE, (tfp, "CSSPARSE:%s => %d %s\n",
			  element, hash_code(element),
			  (hashStyles[hash_code(element)].name ? "used" : "")));

    strtolower(element);

    /*
     * We use some pseudo-elements, so catch these first
     */
    for (n = 0; n < TABLESIZE(table); n++) {
	if (!strcasecomp(element, table[n].name)) {
	    parse_attributes(mono, fg, bg, table[n].style, table[n].name);
	    if (table[n].set_hash != 0)
		*(table[n].set_hash) = hash_code(table[n].name);
	    found = TRUE;
	    break;
	}
    }

    if (found) {
	;
    } else if (!strcasecomp(element, "normal"))		/* added - kw */
    {
	parse_attributes(mono, fg, bg, DSTYLE_NORMAL, "html");
	s_normal = hash_code("html");	/* rather bizarre... - kw */
    }
    /* It must be a HTML element, so look through the list until we find it. */
    else {
	int element_number = -1;
	HTTag *t = SGMLFindTag(&HTML_dtd, element);

	if (t && t->name) {
	    element_number = t - HTML_dtd.tags;
	}
	if (element_number >= HTML_A &&
	    element_number < HTML_ELEMENTS)
	    parse_attributes(mono, fg, bg, element_number + STARTAT, element);
	else
	    parse_attributes(mono, fg, bg, DSTYLE_ELEMENTS, element);
    }
    FREE(buffer);
}

#ifdef LY_FIND_LEAKS
static void free_colorstylestuff(void)
{
    style_initialiseHashTable();
    style_deleteStyleList();
}
#endif

/*
 * initialise the default style sheet
 * This should be able to be read from a file in CSS format :-)
 */
static void initialise_default_stylesheet(void)
{
    static const char *table[] =
    {
	"a:bold:green",
	"alert:bold:yellow:red",
	"alink:reverse:yellow:black",
	"label:normal:magenta",
	"status:reverse:yellow:blue",
	"title:normal:magenta",
	"whereis:reverse+underline:magenta:cyan"
    };
    unsigned n;
    char temp[80];

    CTRACE((tfp, "initialize_default_stylesheet\n"));
    for (n = 0; n < TABLESIZE(table); n++) {
	parse_style(strcpy(temp, table[n]));
    }
}

/* Set all the buckets in the hash table to be empty */
static void style_initialiseHashTable(void)
{
    int i;
    static int firsttime = 1;

    for (i = 0; i < CSHASHSIZE; i++) {
	if (firsttime)
	    hashStyles[i].name = NULL;
	else
	    FREE(hashStyles[i].name);
	hashStyles[i].color = 0;
	hashStyles[i].cattr = 0;
	hashStyles[i].mono = 0;
    }
    if (firsttime) {
	firsttime = 0;
#ifdef LY_FIND_LEAKS
	atexit(free_colorstylestuff);
#endif
    }
    s_alink = hash_code("alink");
    s_a = hash_code("a");
    s_status = hash_code("status");
    s_alert = hash_code("alert");
    s_title = hash_code("title");
#ifdef USE_SCROLLBAR
    s_sb_bar = hash_code("scroll.bar");
    s_sb_bg = hash_code("scroll.back");
    s_sb_aa = hash_code("scroll.arrow");
    s_sb_naa = hash_code("scroll.noarrow");
#endif
}

/* because curses isn't started when we parse the config file, we
 * need to remember the STYLE: lines we encounter and parse them
 * after curses has started
 */
static HTList *lss_styles = NULL;

void parse_userstyles(void)
{
    char *name;
    HTList *cur = lss_styles;

    colorPairs = 0;
    style_initialiseHashTable();

    /* set our styles to be the same as vanilla-curses-lynx */
    if (HTList_isEmpty(cur)) {
	initialise_default_stylesheet();
    } else {
	while ((name = (char *) HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n",
				  (name
				   ? name
				   : "!?! empty !?!")));
	    if (name != NULL)
		parse_style(name);
	}
    }

#define dft_style(a,b) if (a == NOSTYLE) a = b
    /* *INDENT-OFF* */
    dft_style(s_prompt_edit,		s_normal);
    dft_style(s_prompt_edit_arr,	s_prompt_edit);
    dft_style(s_prompt_edit_pad,	s_prompt_edit);
    dft_style(s_prompt_sel,		s_prompt_edit);
    dft_style(s_aedit,			s_alink);
    dft_style(s_aedit_arr,		s_aedit);
    dft_style(s_aedit_pad,		s_aedit);
    dft_style(s_curedit,		s_aedit);
    dft_style(s_aedit_sel,		s_aedit);
    dft_style(s_menu_bg,		s_normal);
    dft_style(s_menu_entry,		s_menu_bg);
    dft_style(s_menu_frame,		s_menu_bg);
    dft_style(s_menu_number,		s_menu_bg);
    dft_style(s_menu_active,		s_alink);
    /* *INDENT-ON* */

}

/* Add a STYLE: option line to our list.  Process "default:" early
 * for it to have the same semantic as other lines: works at any place
 * of the style file, the first line overrides the later ones.
 */
static void HStyle_addStyle(char *buffer)
{
    char *name = NULL;

    CTRACE((tfp, "HStyle_addStyle(%s)\n", buffer));
    StrAllocCopy(name, buffer);
    if (lss_styles == NULL)
	lss_styles = HTList_new();
    strtolower(name);
    if (!strncasecomp(name, "default:", 8))	/* default fg/bg */
    {
	CTRACE2(TRACE_STYLE, (tfp, "READCSS.default%s:%s\n",
			      (default_color_reset ? ".ignore" : ""),
			      name ? name : "!?! empty !?!"));
	if (!default_color_reset)
	    parse_style(name);
	return;			/* do not need to process it again */
    }
    CTRACE2(TRACE_STYLE, (tfp, "READCSS:%s\n", name ? name : "!?! empty !?!"));
    HTList_addObject(lss_styles, name);
}

void style_deleteStyleList(void)
{
    LYFreeStringList(lss_styles);
    lss_styles = NULL;
}

static int style_readFromFileREC(char *lss_filename,
				 char *parent_filename)
{
    FILE *fh;
    char *buffer = NULL;
    int len;

    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n",
			  lss_filename ? lss_filename : "?!? empty ?!?"));
    if (isEmpty(lss_filename))
	return -1;
    if ((fh = LYOpenCFG(lss_filename, parent_filename, LYNX_LSS_FILE)) == 0) {
	/* this should probably be an alert or something */
	CTRACE2(TRACE_STYLE, (tfp,
			      "CSS:Can't open style file '%s', using defaults\n", lss_filename));
	return -1;
    }

    if (parent_filename == 0) {
	style_initialiseHashTable();
	style_deleteStyleList();
    }

    while (LYSafeGets(&buffer, fh) != NULL) {
	LYTrimTrailing(buffer);
	LYTrimTail(buffer);
	LYTrimHead(buffer);
	if (!strncasecomp(buffer, "include:", 8))
	    style_readFromFileREC(buffer + 8, lss_filename);
	else if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
	    HStyle_addStyle(buffer);
    }

    LYCloseInput(fh);
    if ((parent_filename == 0) && LYCursesON)
	parse_userstyles();
    return 0;
}

int style_readFromFile(char *filename)
{
    return style_readFromFileREC(filename, (char *) 0);
}

/* Used in HTStructured methods: - kw */

void TrimColorClass(const char *tagname,
		    char *styleclassname,
		    int *phcode)
{
    char *end, *start = NULL, *lookfrom;
    char tmp[64];

    sprintf(tmp, ";%.*s", (int) sizeof(tmp) - 3, tagname);
    strtolower(tmp);

    if ((lookfrom = styleclassname) != 0) {
	do {
	    end = start;
	    start = strstr(lookfrom, tmp);
	    if (start)
		lookfrom = start + 1;
	}
	while (start);
	/* trim the last matching element off the end
	 * - should match classes here as well (rp)
	 */
	if (end)
	    *end = '\0';
    }
    *phcode = hash_code(lookfrom && *lookfrom ? lookfrom : &tmp[1]);
}

/* This function is designed as faster analog to TrimColorClass.
 * It assumes that tag_name is present in stylename! -HV
 */
void FastTrimColorClass(const char *tag_name,
			int name_len,
			char *stylename,
			char **pstylename_end,	/*will be modified */
			int *phcode)	/*will be modified */
{
    char *tag_start = *pstylename_end;
    BOOLEAN found = FALSE;

    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.fast-trim: [%s] from [%s]: ",
	     tag_name, stylename));
    while (tag_start >= stylename) {
	for (; (tag_start >= stylename) && (*tag_start != ';'); --tag_start) ;
	if (!strncasecomp(tag_start + 1, tag_name, name_len)) {
	    found = TRUE;
	    break;
	}
	--tag_start;
    }
    if (found) {
	*tag_start = '\0';
	*pstylename_end = tag_start;
    }
    CTRACE2(TRACE_STYLE, (tfp, found ? "success.\n" : "failed.\n"));
    *phcode = hash_code(tag_start + 1);
}

 /* This is called each time lss styles are read. It will fill
  * each elt of 'cached_tag_styles' -HV
  */
void cache_tag_styles(void)
{
    char buf[200];
    int i;

    for (i = 0; i < HTML_ELEMENTS; ++i) {
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
	LYLowerCase(buf);
	cached_tag_styles[i] = hash_code(buf);
    }
}

#endif /* USE_COLOR_STYLE */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.52 Sun, 01 Jun 2003 18:16:28 -0700 dickey $
d28 1
a28 1
PRIVATE void style_initialiseHashTable NOPARAMS;
d31 3
a33 2
PUBLIC int last_styles[128];
PUBLIC int last_colorattr_ptr = 0;
d35 2
a36 2
PUBLIC bucket hashStyles[CSHASHSIZE];
PUBLIC bucket special_bucket =
d38 1
a38 1
    "<special>", /* in order something to be in trace. */
d41 1
a41 1
PUBLIC bucket nostyle_bucket =
d43 1
a43 1
    "<NOSTYLE>", /* in order something to be in trace. */
d47 5
a51 5
PUBLIC int cached_tag_styles[HTML_ELEMENTS];
PUBLIC int current_tag_style;
PUBLIC BOOL force_current_tag_style = FALSE;
PUBLIC char* forced_classname;
PUBLIC BOOL force_classname;
d54 24
a77 24
PUBLIC int s_a			= NOSTYLE;
PUBLIC int s_aedit		= NOSTYLE;
PUBLIC int s_aedit_arr		= NOSTYLE;
PUBLIC int s_aedit_pad		= NOSTYLE;
PUBLIC int s_aedit_sel		= NOSTYLE;
PUBLIC int s_alert		= NOSTYLE;
PUBLIC int s_alink		= NOSTYLE;
PUBLIC int s_curedit		= NOSTYLE;
PUBLIC int s_forw_backw		= NOSTYLE;
PUBLIC int s_hot_paste		= NOSTYLE;
PUBLIC int s_menu_active	= NOSTYLE;
PUBLIC int s_menu_bg		= NOSTYLE;
PUBLIC int s_menu_entry		= NOSTYLE;
PUBLIC int s_menu_frame		= NOSTYLE;
PUBLIC int s_menu_number	= NOSTYLE;
PUBLIC int s_menu_sb		= NOSTYLE;
PUBLIC int s_normal		= NOSTYLE;
PUBLIC int s_prompt_edit	= NOSTYLE;
PUBLIC int s_prompt_edit_arr	= NOSTYLE;
PUBLIC int s_prompt_edit_pad	= NOSTYLE;
PUBLIC int s_prompt_sel		= NOSTYLE;
PUBLIC int s_status		= NOSTYLE;
PUBLIC int s_title		= NOSTYLE;
PUBLIC int s_whereis		= NOSTYLE;
d80 4
a83 4
PUBLIC int s_sb_aa		= NOSTYLE;
PUBLIC int s_sb_bar		= NOSTYLE;
PUBLIC int s_sb_bg		= NOSTYLE;
PUBLIC int s_sb_naa		= NOSTYLE;
d88 1
a88 1
PRIVATE int colorPairs = 0;
d98 4
a101 4
PRIVATE unsigned char our_pairs[2]
				[MAX_BLINK]
				[MAX_COLOR + 1]
				[MAX_COLOR + 1];
d106 4
a109 5
PRIVATE void parse_either ARGS4(
    char *,	attrs,
    int,	dft_color,
    int *,	monop,
    int *,	colorp)
d116 1
d120 1
a120 1
	if (save != 0)	/* attrs might be a constant string */
d125 1
a125 1
	 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
d135 5
a139 6
PRIVATE void parse_attributes ARGS5(
    char *,	mono,
    char *,	fg,
    char *,	bg,
    int,	style,
    char *,	element)
d147 2
a148 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle, element));
d150 1
a150 1
    parse_either(mono, ERR_COLOR, &mA, (int *)0);
d154 3
a156 2
    if (style == -1) {			/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n", fA, bA));
d189 1
a189 1
    if (lynx_has_color && colorPairs < COLOR_PAIRS-1 && fA != NO_COLOR) {
d196 2
d199 1
a199 1
	 && bA < MAX_COLOR
d201 1
a201 1
	 && (fA != default_fg || bA != default_bg)
d203 1
a203 1
	 && curPair < 255) {
d208 1
a208 1
		init_pair((short)curPair, (short)fA, (short)bA);
d214 2
a215 2
	    setStyle(style, COLOR_PAIR(curPair)|cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair)|cA, cA, mA, element);
d218 3
a220 1
	    CTRACE2(TRACE_STYLE, (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n", COLOR_PAIRS - 1));
d232 1
a232 1
PRIVATE void parse_style ARGS1(char*, param)
d234 1
d269 2
d280 1
d286 1
a286 1
	fprintf (stderr, gettext("\
d292 1
a292 4
	if (!dump_output_immediately) {
	    exit_immediately(EXIT_FAILURE);
	}
	exit(1);
d301 1
a301 2
    if (!tmp)
    {
d304 1
a304 3
    }
    else
    {
d306 1
a306 1
	fg = tmp+1;
d310 1
a310 2
	else
	{
d317 2
a318 2
		element, hash_code(element),
		(hashStyles[hash_code(element)].name ? "used" : "")));
d323 2
a324 2
    * We use some pseudo-elements, so catch these first
    */
d337 1
a337 2
    }
    else if (!strcasecomp(element, "normal")) /* added - kw */
d339 2
a340 2
	parse_attributes(mono,fg,bg,DSTYLE_NORMAL,"html");
	s_normal  = hash_code("html"); /* rather bizarre... - kw */
d342 2
a343 5
    /* Ok, it must be a HTML element, so look through the list until we
    * find it
    */
    else
    {
d345 2
a346 1
	HTTag * t = SGMLFindTag(&HTML_dtd, element);
d352 1
a352 1
	    parse_attributes(mono,fg,bg, element_number+STARTAT,element);
d354 1
a354 1
	    parse_attributes(mono,fg,bg, DSTYLE_ELEMENTS,element);
d360 1
a360 1
PRIVATE void free_colorstylestuff NOARGS
d371 1
a371 1
PRIVATE void initialise_default_stylesheet NOARGS
d373 2
a374 1
    static CONST char *table[] = {
d385 1
d393 1
a393 1
PRIVATE void style_initialiseHashTable NOARGS
d398 1
a398 2
    for (i = 0; i <CSHASHSIZE; i++)
    {
d405 1
a405 1
	hashStyles[i].mono  = 0;
d413 2
a414 2
    s_alink  = hash_code("alink");
    s_a      = hash_code("a");
d416 2
a417 2
    s_alert  = hash_code("alert");
    s_title  = hash_code("title");
d420 2
a421 2
    s_sb_bg  = hash_code("scroll.back");
    s_sb_aa  = hash_code("scroll.arrow");
d430 1
a430 1
PRIVATE HTList *lss_styles = NULL;
d432 1
a432 1
PUBLIC void parse_userstyles NOARGS
d444 5
a448 2
	while ((name = HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n", name ? name : "!?! empty !?!"));
d455 1
a455 1

d470 2
a473 1

d475 4
a478 3
   for it to have the same semantic as other lines: works at any place
   of the style file, the first line overrides the later ones. */
PRIVATE void HStyle_addStyle ARGS1(char*, buffer)
d487 1
a487 1
    if (!strncasecomp(name, "default:", 8)) /* default fg/bg */
d490 2
a491 2
		 (default_color_reset ? ".ignore" : ""),
		 name ? name : "!?! empty !?!"));
d494 1
a494 1
	return;				/* do not need to process it again */
d497 1
a497 1
    HTList_addObject (lss_styles, name);
d500 1
a500 1
PUBLIC void style_deleteStyleList NOARGS
d502 1
a502 4
    char *name;
    while ((name = HTList_removeLastObject(lss_styles)) != NULL)
	FREE(name);
    HTList_delete (lss_styles);
d506 2
a507 3
PRIVATE int style_readFromFileREC ARGS2(
    char *,	lss_filename,
    char *,	parent_filename)
d513 2
a514 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n", lss_filename ? lss_filename : "?!? empty ?!?"));
d519 2
a520 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS:Can't open style file '%s', using defaults\n", lss_filename));
d533 2
a534 2
	if (!strncasecomp(buffer,"include:",8))
	    style_readFromFileREC(buffer+8, lss_filename);
d539 1
a539 1
    LYCloseInput (fh);
d545 1
a545 1
PUBLIC int style_readFromFile ARGS1(char*, filename)
d547 1
a547 1
    return style_readFromFileREC(filename, (char *)0);
d552 3
a554 4
PUBLIC void TrimColorClass ARGS3(
    CONST char *,	tagname,
    char *,		styleclassname,
    int *,		phcode)
d556 1
a556 1
    char *end, *start=NULL, *lookfrom;
d571 2
a572 2
	** - should match classes here as well (rp)
	*/
d574 1
a574 1
	    *end='\0';
d580 7
a586 8
   It assumes that tag_name is present in stylename! -HV
*/
PUBLIC void FastTrimColorClass ARGS5 (
	    CONST char*,	 tag_name,
	    int,		 name_len,
	    char*,		 stylename,
	    char**,		 pstylename_end,/*will be modified*/
	    int*,		 phcode)	/*will be modified*/
d588 1
a588 1
    char* tag_start = *pstylename_end;
d593 4
a596 6
		  tag_name, stylename));
    while (tag_start >= stylename)
    {
	for (; (tag_start >= stylename) && (*tag_start != ';') ; --tag_start)
	    ;
	if ( !strncasecomp(tag_start+1, tag_name, name_len) ) {
d607 1
a607 1
    *phcode = hash_code(tag_start+1);
d611 3
a613 3
    each elt of 'cached_tag_styles' -HV
 */
PUBLIC void cache_tag_styles NOARGS
d618 2
a619 3
    for (i = 0; i < HTML_ELEMENTS; ++i)
    {
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf)-1);
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d3 1
a3 1
 * $Id: LYStyle.c,v 1.1 2003/03/22 17:42:23 tg Exp $
d28 2
d32 1
a32 1
PUBLIC int last_colorattr_ptr=0;
d37 2
a38 1
 "<special>" /* in order something to be in trace. */
d42 2
a43 1
 "<NOSTYLE>" /* in order something to be in trace. */
d48 1
a48 1
PUBLIC BOOL force_current_tag_style=FALSE;
a51 14
/* definitions for the mono attributes we can use */
static int ncursesMono[7] = {
 A_NORMAL, A_BOLD, A_REVERSE, A_UNDERLINE, A_STANDOUT, A_BLINK, A_DIM
};

/*
 * If these strings don't match the meanings of the above attributes,
 * you'll confuse the hell out of people, so make them the same. - RP
 */
static char *Mono_Strings[7] =
{
 "normal", "bold", "reverse", "underline", "standout", "blink", "dim"
};

d53 31
a83 4
PUBLIC int	s_alink  = NOSTYLE, s_a     = NOSTYLE, s_status = NOSTYLE,
		s_label  = NOSTYLE, s_value = NOSTYLE, s_high   = NOSTYLE,
		s_normal = NOSTYLE, s_alert = NOSTYLE, s_title  = NOSTYLE,
		s_whereis= NOSTYLE;
d86 1
d88 44
a131 1
PRIVATE int last_fA = COLOR_WHITE, last_bA = COLOR_BLACK;
d134 11
a144 4
PRIVATE void parse_attributes ARGS5(char*,mono,char*,fg,char*,bg,int,style,char*,element)
{
    int i;
    int mA = 0, fA = default_fg, bA = default_bg, cA = A_NORMAL;
d147 1
a147 1
    CTRACE(tfp, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle,element);
d149 10
a158 34
    for (i = 0; i < (int)TABLESIZE(Mono_Strings); i++)
    {
	if (!strcasecomp(Mono_Strings[i], mono))
	{
	    mA = ncursesMono[i];
	}
    }
    if (!mA) {
	/*
	 *  Not found directly yet, see whether we have a combination
	 *  of several mono attributes separated by '+' - kw
	 */
	char *cp0 = mono;
	char csep = '+';
	char *cp = strchr(mono, csep);
	while (cp) {
	    *cp = '\0';
	    for (i = 0; i < (int)TABLESIZE(Mono_Strings); i++)
	    {
		if (!strcasecomp(Mono_Strings[i], cp0))
		{
		    mA |= ncursesMono[i];
		}
	    }
	    if (!csep)
		break;
	    *cp = csep;
	    cp0 = cp + 1;
	    cp = strchr(cp0, csep);
	    if (!cp) {
		cp = cp0 + strlen(cp0);
		csep = '\0';
	    }
	}
a159 4
    CTRACE(tfp, "CSS(CP):%d\n", colorPairs);

    fA = check_color(fg, default_fg);
    bA = check_color(bg, default_bg);
d163 8
d175 1
a175 1
	if (bA > COLORS)
d187 20
a206 7
    if (lynx_has_color && colorPairs < COLOR_PAIRS-1 && fA != NO_COLOR)
    {
	if (colorPairs <= 0 || fA != last_fA || bA != last_bA) {
	    colorPairs++;
	    init_pair(colorPairs, fA, bA);
	    last_fA = fA;
	    last_bA = bA;
d208 1
d210 7
a216 6
	    setStyle(style, COLOR_PAIR(colorPairs)|cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(colorPairs)|cA, cA, mA, element);
    }
    else
    {
    /* only mono is set */
d226 1
a226 1
PRIVATE void parse_style ARGS1(char*,buffer)
d228 39
a266 1
    char *tmp = strchr(buffer, ':');
d269 7
a275 2
    if(!tmp)
    {
d283 1
a283 1
	    exit_immediately(-1);
d287 1
a287 5
    {
	char *i;
	for (i = buffer; *i; i++)
	    *i = tolower(*i);
    }
d313 1
a313 1
    CTRACE(tfp, "CSSPARSE:%s => %d %s\n",
d315 1
a315 1
		(hashStyles[hash_code(element)].name ? "used" : ""));
d322 8
a329 3
    if (!strncasecomp(element, "alink", 5)) /* active link */
    {
	parse_attributes(mono,fg,bg,DSTYLE_ALINK,"alink");
d331 3
a333 20
    else if (!strcasecomp(element, "a")) /* normal link */
    {
	parse_attributes(mono,fg,bg, DSTYLE_LINK,"a");
	parse_attributes(mono,fg,bg, HTML_A,"a");
    }
    else if (!strncasecomp(element, "status", 4)) /* status bar */
    {
	parse_attributes(mono,fg,bg, DSTYLE_STATUS,"status");
    }
    else if (!strncasecomp(element, "label", 6)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_OPTION,"label");
    }
    else if (!strncasecomp(element, "value", 5)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_VALUE,"value");
    }
    else if (!strncasecomp(element, "high", 4)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_HIGH,"high");
a339 11
    /* this may vanish */
    else if (!strncasecomp(element, "candy", 5)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_CANDY,"candy");
    }
    /* added for whereis search target - kw */
    else if (!strncasecomp(element, "whereis", 7))
    {
	parse_attributes(mono,fg,bg,DSTYLE_WHEREIS,"whereis");
	s_whereis  = hash_code("whereis");
    }
a344 12
#if !defined(USE_HASH)
	int i;
	for (i = 0; i <HTML_ELEMENTS; i++)
	{
	    if (!strcasecomp (HTML_dtd.tags[i].name, element))
	    {
		CTRACE(tfp, "PARSECSS:applying style <%s,%s,%s> for HTML_%s\n",mono,fg,bg,HTML_dtd.tags[i].name);
			parse_attributes(mono,fg,bg,i+STARTAT,element);
		break;
	    }
	}
#else
a354 1
#endif
d356 1
d373 15
d391 1
a391 1
PUBLIC void style_initialiseHashTable NOARGS
d393 2
a394 2
	int i;
	static int firsttime = 1;
d396 12
a407 12
	for (i = 0; i <CSHASHSIZE; i++)
	{
	    if (firsttime)
		hashStyles[i].name = NULL;
	    else
		FREE(hashStyles[i].name);
	    hashStyles[i].color = -1;
	    hashStyles[i].cattr = -1;
	    hashStyles[i].mono  = -1;
	}
	if (firsttime) {
	    firsttime = 0;
d409 13
a421 1
	    atexit(free_colorstylestuff);
a422 9
	}
	s_high   = hash_code("high");
	s_alink  = hash_code("alink");
	s_value  = hash_code("value");
	s_label  = hash_code("label");
	s_a      = hash_code("a");
	s_status = hash_code("status");
	s_alert  = hash_code("alert");
	s_title  = hash_code("title");
d429 1
a429 1
HTList *lss_styles = NULL;
d433 5
a437 4
	char *name;
	HTList *cur = lss_styles;
	colorPairs = 0;
	style_initialiseHashTable();
d439 2
a440 1
	/* set our styles to be the same as vanilla-curses-lynx */
d442 7
d450 16
a465 6
	while ((name = HTList_nextObject(cur)) != NULL)
	{
		CTRACE(tfp, "LSS:%s\n", name ? name : "!?! empty !?!");
		if (name != NULL)
		    parse_style(name);
	}
d469 23
a491 10
/* Add a STYLE: option line to our list */
PUBLIC void HStyle_addStyle ARGS1(char*,buffer)
{
	char *name = NULL;
	StrAllocCopy(name, buffer);
	if (lss_styles == NULL)
		lss_styles = HTList_new();
	strtolower(name);
	CTRACE(tfp, "READCSS:%s\n", name ? name : "!?! empty !?!");
	HTList_addObject (lss_styles, name);
d503 3
a505 13
char* default_stylesheet[] = {
	"a:bold", "em:bold", "strong:bold", "b:bold", "i:bold",
	"alink:reverse", "status:reverse", NULL
};

PUBLIC void style_defaultStyleSheet NOARGS
{
	int i;
	for (i = 0; default_stylesheet[i]; i++)
		HStyle_addStyle(default_stylesheet[i]);
}

PUBLIC int style_readFromFile ARGS1(char*, file)
d511 2
a512 2
    CTRACE(tfp, "CSS:Reading styles from file: %s\n", file ? file : "?!? empty ?!?");
    if (file == NULL || *file == '\0')
d514 1
a514 3
    fh = fopen(file, "r");
    if (!fh)
    {
d516 1
a516 1
	CTRACE(tfp, "CSS:Can't open style file %s, using defaults\n", file);
d520 4
a523 2
    style_initialiseHashTable();
    style_deleteStyleList();
d525 1
a525 2
    while (LYSafeGets(&buffer, fh) != NULL)
    {
d529 3
a531 1
	if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
a533 4
    /* the default styles are added after the user styles in order
    ** that they come before them  <grin>  RP
    */
    /*	style_defaultStyleSheet(); */
d535 2
a536 2
    fclose (fh);
    if (LYCursesON)
d541 5
a573 2
    CTRACE(tfp, "CSS:%s (trimmed %s)\n",
	   (styleclassname ? styleclassname : "<null>"), tmp);
d589 3
d606 1
d620 1
a620 1
	strcpy(buf, HTML_dtd.tags[i].name);
d622 1
a622 1
	cached_tag_styles[i] =hash_code(buf);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * $Id: LYStyle.c,v 1.2 2000/03/25 18:17:12 maja Exp $
@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.59 Sun, 02 Jan 2005 15:35:21 -0800 dickey $
a27 2
static void style_initialiseHashTable(void);

d29 2
a30 3
int last_styles[MAX_LAST_STYLES] =
{0};
int last_colorattr_ptr = 0;
d32 2
a33 2
bucket hashStyles[CSHASHSIZE];
bucket special_bucket =
d35 1
a35 2
    "<special>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
d37 1
a37 1
bucket nostyle_bucket =
d39 12
a50 2
    "<NOSTYLE>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
d53 8
a60 5
int cached_tag_styles[HTML_ELEMENTS];
int current_tag_style;
BOOL force_current_tag_style = FALSE;
char *forced_classname;
BOOL force_classname;
d63 4
a66 31
int s_a = NOSTYLE;
int s_aedit = NOSTYLE;
int s_aedit_arr = NOSTYLE;
int s_aedit_pad = NOSTYLE;
int s_aedit_sel = NOSTYLE;
int s_alert = NOSTYLE;
int s_alink = NOSTYLE;
int s_curedit = NOSTYLE;
int s_forw_backw = NOSTYLE;
int s_hot_paste = NOSTYLE;
int s_menu_active = NOSTYLE;
int s_menu_bg = NOSTYLE;
int s_menu_entry = NOSTYLE;
int s_menu_frame = NOSTYLE;
int s_menu_number = NOSTYLE;
int s_menu_sb = NOSTYLE;
int s_normal = NOSTYLE;
int s_prompt_edit = NOSTYLE;
int s_prompt_edit_arr = NOSTYLE;
int s_prompt_edit_pad = NOSTYLE;
int s_prompt_sel = NOSTYLE;
int s_status = NOSTYLE;
int s_title = NOSTYLE;
int s_whereis = NOSTYLE;

#ifdef USE_SCROLLBAR
int s_sb_aa = NOSTYLE;
int s_sb_bar = NOSTYLE;
int s_sb_bg = NOSTYLE;
int s_sb_naa = NOSTYLE;
#endif
d69 2
a70 46
#define MAX_COLOR 16
static int colorPairs = 0;

#ifdef USE_BLINK
#  define MAX_BLINK	2
#  define M_BLINK	A_BLINK
#else
#  define MAX_BLINK	1
#  define M_BLINK	0
#endif

static unsigned char our_pairs[2]
[MAX_BLINK]
[MAX_COLOR + 1]
[MAX_COLOR + 1];

/*
 * Parse a string containing a combination of video attributes and color.
 */
static void parse_either(char *attrs,
			 int dft_color,
			 int *monop,
			 int *colorp)
{
    int value;

    while (*attrs != '\0') {
	char *next = strchr(attrs, '+');
	char save = (next != NULL) ? *next : '\0';

	if (next == NULL)
	    next = attrs + strlen(attrs);

	if (save != 0)		/* attrs might be a constant string */
	    *next = '\0';
	if ((value = string_to_attr(attrs)) != 0)
	    *monop |= value;
	else if (colorp != 0
		 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
	    *colorp = value;

	attrs = next;
	if (save != '\0')
	    *attrs++ = save;
    }
}
d73 4
a76 10
static void parse_attributes(char *mono,
			     char *fg,
			     char *bg,
			     int style,
			     char *element)
{
    int mA = A_NORMAL;
    int fA = default_fg;
    int bA = default_bg;
    int cA = A_NORMAL;
d79 1
a79 2
    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n",
			  style, newstyle, element));
d81 6
a86 11
    parse_either(mono, ERR_COLOR, &mA, (int *) 0);
    parse_either(bg, default_bg, &cA, &bA);
    parse_either(fg, default_fg, &cA, &fA);

    if (style == -1) {		/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n",
			      fA, bA));
	default_fg = fA;
	default_bg = bA;
	default_color_reset = TRUE;
	return;
d88 32
a122 8
#ifdef USE_BLINK
	if (term_blink_is_boldbg) {
	    if (fA >= COLORS)
		cA = A_BOLD;
	    if (bA >= COLORS)
		cA |= M_BLINK;
	} else
#endif
d127 1
a127 1
	if (bA >= COLORS)
d139 7
a145 22
    if (lynx_has_color && colorPairs < COLOR_PAIRS - 1 && fA != NO_COLOR) {
	int curPair = 0;
	int iFg = (1 + (fA >= 0 ? fA : 0));
	int iBg = (1 + (bA >= 0 ? bA : 0));
	int iBold = !!(cA & A_BOLD);
	int iBlink = !!(cA & M_BLINK);

	CTRACE2(TRACE_STYLE, (tfp, "parse_attributes %d/%d %d/%d %#x\n",
			      fA, default_fg, bA, default_bg, cA));
	if (fA < MAX_COLOR
	    && bA < MAX_COLOR
#ifdef USE_CURSES_PAIR_0
	    && (cA != A_NORMAL || fA != default_fg || bA != default_bg)
#endif
	    && curPair < 255) {
	    if (our_pairs[iBold][iBlink][iFg][iBg] != 0) {
		curPair = our_pairs[iBold][iBlink][iFg][iBg];
	    } else {
		curPair = ++colorPairs;
		init_pair((short) curPair, (short) fA, (short) bA);
		our_pairs[iBold][iBlink][iFg][iBg] = curPair;
	    }
a146 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS(CURPAIR):%d\n", curPair));
d148 6
a153 9
	    setStyle(style, COLOR_PAIR(curPair) | cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair) | cA, cA, mA, element);
    } else {
	if (lynx_has_color && fA != NO_COLOR) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n",
		     COLOR_PAIRS - 1));
	}
	/* only mono is set */
d163 1
a163 1
static void parse_style(char *param)
d165 1
a165 42
    /* *INDENT-OFF* */
    static struct {
	char *name;
	int style;
	int *set_hash;
    } table[] = {
	{ "default",		-1,			0 }, /* default fg/bg */
	{ "alink",		DSTYLE_ALINK,		0 }, /* active link */
	{ "a",			DSTYLE_LINK,		0 }, /* normal link */
	{ "a",			HTML_A,			0 }, /* normal link */
	{ "status",		DSTYLE_STATUS,		0 }, /* status bar */
	{ "label",		DSTYLE_OPTION,		0 }, /* [INLINE]'s */
	{ "value",		DSTYLE_VALUE,		0 }, /* [INLINE]'s */
	{ "high",		DSTYLE_HIGH,		0 }, /* [INLINE]'s */
	{ "normal",		DSTYLE_NORMAL,		0 },
	{ "candy",		DSTYLE_CANDY,		0 }, /* [INLINE]'s */
	{ "whereis",		DSTYLE_WHEREIS,		&s_whereis },
	{ "edit.active.pad",	DSTYLE_ELEMENTS,	&s_aedit_pad },
	{ "edit.active.arrow",	DSTYLE_ELEMENTS,	&s_aedit_arr },
	{ "edit.active.marked",	DSTYLE_ELEMENTS,	&s_aedit_sel },
	{ "edit.active",	DSTYLE_ELEMENTS,	&s_aedit },
	{ "edit.current",	DSTYLE_ELEMENTS,	&s_curedit },
	{ "edit.prompt.pad",	DSTYLE_ELEMENTS,	&s_prompt_edit_pad },
	{ "edit.prompt.arrow",	DSTYLE_ELEMENTS,	&s_prompt_edit_arr },
	{ "edit.prompt.marked",	DSTYLE_ELEMENTS,	&s_prompt_sel },
	{ "edit.prompt",	DSTYLE_ELEMENTS,	&s_prompt_edit },
	{ "forwbackw.arrow",	DSTYLE_ELEMENTS,	&s_forw_backw },
	{ "hot.paste",		DSTYLE_ELEMENTS,	&s_hot_paste },
	{ "menu.frame",		DSTYLE_ELEMENTS,	&s_menu_frame },
	{ "menu.bg",		DSTYLE_ELEMENTS,	&s_menu_bg },
	{ "menu.n",		DSTYLE_ELEMENTS,	&s_menu_number },
	{ "menu.entry",		DSTYLE_ELEMENTS,	&s_menu_entry },
	{ "menu.active",	DSTYLE_ELEMENTS,	&s_menu_active },
	{ "menu.sb",		DSTYLE_ELEMENTS,	&s_menu_sb },
    };
    /* *INDENT-ON* */

    unsigned n;
    BOOL found = FALSE;

    char *buffer = 0;
    char *tmp = 0;
d168 3
a170 9
    if (param == 0)
	return;
    CTRACE2(TRACE_STYLE, (tfp, "parse_style(%s)\n", param));
    StrAllocCopy(buffer, param);
    if (buffer == 0)
	return;

    if ((tmp = strchr(buffer, ':')) == 0) {
	fprintf(stderr, gettext("\
d176 9
a184 1
	exit_immediately(EXIT_FAILURE);
a185 1
    strtolower(buffer);
d192 2
a193 1
    if (!tmp) {
d196 3
a198 1
    } else {
d200 1
a200 1
	fg = tmp + 1;
d204 2
a205 1
	else {
d211 3
a213 3
    CTRACE2(TRACE_STYLE, (tfp, "CSSPARSE:%s => %d %s\n",
			  element, hash_code(element),
			  (hashStyles[hash_code(element)].name ? "used" : "")));
d218 36
a253 10
     * We use some pseudo-elements, so catch these first
     */
    for (n = 0; n < TABLESIZE(table); n++) {
	if (!strcasecomp(element, table[n].name)) {
	    parse_attributes(mono, fg, bg, table[n].style, table[n].name);
	    if (table[n].set_hash != 0)
		*(table[n].set_hash) = hash_code(table[n].name);
	    found = TRUE;
	    break;
	}
d255 2
a256 4

    if (found) {
	;
    } else if (!strcasecomp(element, "normal"))		/* added - kw */
d258 2
a259 2
	parse_attributes(mono, fg, bg, DSTYLE_NORMAL, "html");
	s_normal = hash_code("html");	/* rather bizarre... - kw */
d261 17
a277 2
    /* It must be a HTML element, so look through the list until we find it. */
    else {
d279 1
a279 2
	HTTag *t = SGMLFindTag(&HTML_dtd, element);

d285 1
a285 1
	    parse_attributes(mono, fg, bg, element_number + STARTAT, element);
d287 2
a288 1
	    parse_attributes(mono, fg, bg, DSTYLE_ELEMENTS, element);
a289 1
    FREE(buffer);
d293 1
a293 1
static void free_colorstylestuff(void)
d304 1
a304 1
static void initialise_default_stylesheet(void)
a305 17
    static const char *table[] =
    {
	"a:bold:green",
	"alert:bold:yellow:red",
	"alink:reverse:yellow:black",
	"label:normal:magenta",
	"status:reverse:yellow:blue",
	"title:normal:magenta",
	"whereis:reverse+underline:magenta:cyan"
    };
    unsigned n;
    char temp[80];

    CTRACE((tfp, "initialize_default_stylesheet\n"));
    for (n = 0; n < TABLESIZE(table); n++) {
	parse_style(strcpy(temp, table[n]));
    }
d309 1
a309 1
static void style_initialiseHashTable(void)
d311 2
a312 2
    int i;
    static int firsttime = 1;
d314 12
a325 11
    for (i = 0; i < CSHASHSIZE; i++) {
	if (firsttime)
	    hashStyles[i].name = NULL;
	else
	    FREE(hashStyles[i].name);
	hashStyles[i].color = 0;
	hashStyles[i].cattr = 0;
	hashStyles[i].mono = 0;
    }
    if (firsttime) {
	firsttime = 0;
d327 1
a327 13
	atexit(free_colorstylestuff);
#endif
    }
    s_alink = hash_code("alink");
    s_a = hash_code("a");
    s_status = hash_code("status");
    s_alert = hash_code("alert");
    s_title = hash_code("title");
#ifdef USE_SCROLLBAR
    s_sb_bar = hash_code("scroll.bar");
    s_sb_bg = hash_code("scroll.back");
    s_sb_aa = hash_code("scroll.arrow");
    s_sb_naa = hash_code("scroll.noarrow");
d329 9
d344 1
a344 1
static HTList *lss_styles = NULL;
d346 1
a346 1
void parse_userstyles(void)
d348 4
a351 2
    char *name;
    HTList *cur = lss_styles;
d353 2
a354 2
    colorPairs = 0;
    style_initialiseHashTable();
d356 5
a360 11
    /* set our styles to be the same as vanilla-curses-lynx */
    if (HTList_isEmpty(cur)) {
	initialise_default_stylesheet();
    } else {
	while ((name = (char *) HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n",
				  (name
				   ? name
				   : "!?! empty !?!")));
	    if (name != NULL)
		parse_style(name);
d362 1
a362 1
    }
a363 17
#define dft_style(a,b) if (a == NOSTYLE) a = b
    /* *INDENT-OFF* */
    dft_style(s_prompt_edit,		s_normal);
    dft_style(s_prompt_edit_arr,	s_prompt_edit);
    dft_style(s_prompt_edit_pad,	s_prompt_edit);
    dft_style(s_prompt_sel,		s_prompt_edit);
    dft_style(s_aedit,			s_alink);
    dft_style(s_aedit_arr,		s_aedit);
    dft_style(s_aedit_pad,		s_aedit);
    dft_style(s_curedit,		s_aedit);
    dft_style(s_aedit_sel,		s_aedit);
    dft_style(s_menu_bg,		s_normal);
    dft_style(s_menu_entry,		s_menu_bg);
    dft_style(s_menu_frame,		s_menu_bg);
    dft_style(s_menu_number,		s_menu_bg);
    dft_style(s_menu_active,		s_alink);
    /* *INDENT-ON* */
d365 10
d377 1
a377 5
/* Add a STYLE: option line to our list.  Process "default:" early
 * for it to have the same semantic as other lines: works at any place
 * of the style file, the first line overrides the later ones.
 */
static void HStyle_addStyle(char *buffer)
d379 6
a384 1
    char *name = NULL;
d386 4
a389 17
    CTRACE((tfp, "HStyle_addStyle(%s)\n", buffer));
    StrAllocCopy(name, buffer);
    if (lss_styles == NULL)
	lss_styles = HTList_new();
    strtolower(name);
    if (!strncasecomp(name, "default:", 8))	/* default fg/bg */
    {
	CTRACE2(TRACE_STYLE, (tfp, "READCSS.default%s:%s\n",
			      (default_color_reset ? ".ignore" : ""),
			      name ? name : "!?! empty !?!"));
	if (!default_color_reset)
	    parse_style(name);
	return;			/* do not need to process it again */
    }
    CTRACE2(TRACE_STYLE, (tfp, "READCSS:%s\n", name ? name : "!?! empty !?!"));
    HTList_addObject(lss_styles, name);
}
d391 1
a391 1
void style_deleteStyleList(void)
d393 3
a395 2
    LYFreeStringList(lss_styles);
    lss_styles = NULL;
d398 1
a398 2
static int style_readFromFileREC(char *lss_filename,
				 char *parent_filename)
d404 2
a405 3
    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n",
			  lss_filename ? lss_filename : "?!? empty ?!?"));
    if (isEmpty(lss_filename))
d407 3
a409 1
    if ((fh = LYOpenCFG(lss_filename, parent_filename, LYNX_LSS_FILE)) == 0) {
d411 1
a411 2
	CTRACE2(TRACE_STYLE, (tfp,
			      "CSS:Can't open style file '%s', using defaults\n", lss_filename));
d415 2
a416 4
    if (parent_filename == 0) {
	style_initialiseHashTable();
	style_deleteStyleList();
    }
d418 2
a419 1
    while (LYSafeGets(&buffer, fh) != NULL) {
d423 1
a423 3
	if (!strncasecomp(buffer, "include:", 8))
	    style_readFromFileREC(buffer + 8, lss_filename);
	else if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
d426 4
d431 2
a432 2
    LYCloseInput(fh);
    if ((parent_filename == 0) && LYCursesON)
a436 5
int style_readFromFile(char *filename)
{
    return style_readFromFileREC(filename, (char *) 0);
}

d439 4
a442 3
void TrimColorClass(const char *tagname,
		    char *styleclassname,
		    int *phcode)
d444 1
a444 1
    char *end, *start = NULL, *lookfrom;
d459 2
a460 2
	 * - should match classes here as well (rp)
	 */
d462 1
a462 1
	    *end = '\0';
d465 2
d470 8
a477 7
 * It assumes that tag_name is present in stylename! -HV
 */
void FastTrimColorClass(const char *tag_name,
			int name_len,
			char *stylename,
			char **pstylename_end,	/*will be modified */
			int *phcode)	/*will be modified */
d479 1
a479 1
    char *tag_start = *pstylename_end;
d482 5
a486 6
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.fast-trim: [%s] from [%s]: ",
	     tag_name, stylename));
    while (tag_start >= stylename) {
	for (; (tag_start >= stylename) && (*tag_start != ';'); --tag_start) ;
	if (!strncasecomp(tag_start + 1, tag_name, name_len)) {
d496 1
a496 2
    CTRACE2(TRACE_STYLE, (tfp, found ? "success.\n" : "failed.\n"));
    *phcode = hash_code(tag_start + 1);
d500 3
a502 3
  * each elt of 'cached_tag_styles' -HV
  */
void cache_tag_styles(void)
d507 3
a509 2
    for (i = 0; i < HTML_ELEMENTS; ++i) {
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
d511 1
a511 1
	cached_tag_styles[i] = hash_code(buf);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.52 Sun, 01 Jun 2003 18:16:28 -0700 dickey $
a27 2
PRIVATE void style_initialiseHashTable NOPARAMS;

d30 1
a30 1
PUBLIC int last_colorattr_ptr = 0;
d35 1
a35 2
    "<special>", /* in order something to be in trace. */
    0, 0, 0, 0, NULL
d39 1
a39 2
    "<NOSTYLE>", /* in order something to be in trace. */
    0, 0, 0, 0, NULL
d44 1
a44 1
PUBLIC BOOL force_current_tag_style = FALSE;
d48 14
d63 4
a66 31
PUBLIC int s_a			= NOSTYLE;
PUBLIC int s_aedit		= NOSTYLE;
PUBLIC int s_aedit_arr		= NOSTYLE;
PUBLIC int s_aedit_pad		= NOSTYLE;
PUBLIC int s_aedit_sel		= NOSTYLE;
PUBLIC int s_alert		= NOSTYLE;
PUBLIC int s_alink		= NOSTYLE;
PUBLIC int s_curedit		= NOSTYLE;
PUBLIC int s_forw_backw		= NOSTYLE;
PUBLIC int s_hot_paste		= NOSTYLE;
PUBLIC int s_menu_active	= NOSTYLE;
PUBLIC int s_menu_bg		= NOSTYLE;
PUBLIC int s_menu_entry		= NOSTYLE;
PUBLIC int s_menu_frame		= NOSTYLE;
PUBLIC int s_menu_number	= NOSTYLE;
PUBLIC int s_menu_sb		= NOSTYLE;
PUBLIC int s_normal		= NOSTYLE;
PUBLIC int s_prompt_edit	= NOSTYLE;
PUBLIC int s_prompt_edit_arr	= NOSTYLE;
PUBLIC int s_prompt_edit_pad	= NOSTYLE;
PUBLIC int s_prompt_sel		= NOSTYLE;
PUBLIC int s_status		= NOSTYLE;
PUBLIC int s_title		= NOSTYLE;
PUBLIC int s_whereis		= NOSTYLE;

#ifdef USE_SCROLLBAR
PUBLIC int s_sb_aa		= NOSTYLE;
PUBLIC int s_sb_bar		= NOSTYLE;
PUBLIC int s_sb_bg		= NOSTYLE;
PUBLIC int s_sb_naa		= NOSTYLE;
#endif
a68 1
#define MAX_COLOR 16
d70 1
a70 44

#ifdef USE_BLINK
#  define MAX_BLINK	2
#  define M_BLINK	A_BLINK
#else
#  define MAX_BLINK	1
#  define M_BLINK	0
#endif

PRIVATE unsigned char our_pairs[2]
				[MAX_BLINK]
				[MAX_COLOR + 1]
				[MAX_COLOR + 1];

/*
 * Parse a string containing a combination of video attributes and color.
 */
PRIVATE void parse_either ARGS4(
    char *,	attrs,
    int,	dft_color,
    int *,	monop,
    int *,	colorp)
{
    int value;

    while (*attrs != '\0') {
	char *next = strchr(attrs, '+');
	char save = (next != NULL) ? *next : '\0';
	if (next == NULL)
	    next = attrs + strlen(attrs);

	if (save != 0)	/* attrs might be a constant string */
	    *next = '\0';
	if ((value = string_to_attr(attrs)) != 0)
	    *monop |= value;
	else if (colorp != 0
	 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
	    *colorp = value;

	attrs = next;
	if (save != '\0')
	    *attrs++ = save;
    }
}
d73 4
a76 11
PRIVATE void parse_attributes ARGS5(
    char *,	mono,
    char *,	fg,
    char *,	bg,
    int,	style,
    char *,	element)
{
    int mA = A_NORMAL;
    int fA = default_fg;
    int bA = default_bg;
    int cA = A_NORMAL;
d79 1
a79 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle, element));
d81 34
a114 10
    parse_either(mono, ERR_COLOR, &mA, (int *)0);
    parse_either(bg, default_bg, &cA, &bA);
    parse_either(fg, default_fg, &cA, &fA);

    if (style == -1) {			/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n", fA, bA));
	default_fg = fA;
	default_bg = bA;
	default_color_reset = TRUE;
	return;
d116 4
a122 8
#ifdef USE_BLINK
	if (term_blink_is_boldbg) {
	    if (fA >= COLORS)
		cA = A_BOLD;
	    if (bA >= COLORS)
		cA |= M_BLINK;
	} else
#endif
d127 1
a127 1
	if (bA >= COLORS)
d139 7
a145 20
    if (lynx_has_color && colorPairs < COLOR_PAIRS-1 && fA != NO_COLOR) {
	int curPair = 0;
	int iFg = (1 + (fA >= 0 ? fA : 0));
	int iBg = (1 + (bA >= 0 ? bA : 0));
	int iBold = !!(cA & A_BOLD);
	int iBlink = !!(cA & M_BLINK);

	if (fA < MAX_COLOR
	 && bA < MAX_COLOR
#ifdef USE_CURSES_PAIR_0
	 && (fA != default_fg || bA != default_bg)
#endif
	 && curPair < 255) {
	    if (our_pairs[iBold][iBlink][iFg][iBg] != 0) {
		curPair = our_pairs[iBold][iBlink][iFg][iBg];
	    } else {
		curPair = ++colorPairs;
		init_pair((short)curPair, (short)fA, (short)bA);
		our_pairs[iBold][iBlink][iFg][iBg] = curPair;
	    }
a146 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS(CURPAIR):%d\n", curPair));
d148 6
a153 7
	    setStyle(style, COLOR_PAIR(curPair)|cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair)|cA, cA, mA, element);
    } else {
	if (lynx_has_color && fA != NO_COLOR) {
	    CTRACE2(TRACE_STYLE, (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n", COLOR_PAIRS - 1));
	}
	/* only mono is set */
d163 1
a163 1
PRIVATE void parse_style ARGS1(char*, param)
d165 1
a165 39
    static struct {
	char *name;
	int style;
	int *set_hash;
    } table[] = {
	{ "default",		-1,			0 }, /* default fg/bg */
	{ "alink",		DSTYLE_ALINK,		0 }, /* active link */
	{ "a",			DSTYLE_LINK,		0 }, /* normal link */
	{ "a",			HTML_A,			0 }, /* normal link */
	{ "status",		DSTYLE_STATUS,		0 }, /* status bar */
	{ "label",		DSTYLE_OPTION,		0 }, /* [INLINE]'s */
	{ "value",		DSTYLE_VALUE,		0 }, /* [INLINE]'s */
	{ "high",		DSTYLE_HIGH,		0 }, /* [INLINE]'s */
	{ "normal",		DSTYLE_NORMAL,		0 },
	{ "candy",		DSTYLE_CANDY,		0 }, /* [INLINE]'s */
	{ "whereis",		DSTYLE_WHEREIS,		&s_whereis },
	{ "edit.active.pad",	DSTYLE_ELEMENTS,	&s_aedit_pad },
	{ "edit.active.arrow",	DSTYLE_ELEMENTS,	&s_aedit_arr },
	{ "edit.active.marked",	DSTYLE_ELEMENTS,	&s_aedit_sel },
	{ "edit.active",	DSTYLE_ELEMENTS,	&s_aedit },
	{ "edit.current",	DSTYLE_ELEMENTS,	&s_curedit },
	{ "edit.prompt.pad",	DSTYLE_ELEMENTS,	&s_prompt_edit_pad },
	{ "edit.prompt.arrow",	DSTYLE_ELEMENTS,	&s_prompt_edit_arr },
	{ "edit.prompt.marked",	DSTYLE_ELEMENTS,	&s_prompt_sel },
	{ "edit.prompt",	DSTYLE_ELEMENTS,	&s_prompt_edit },
	{ "forwbackw.arrow",	DSTYLE_ELEMENTS,	&s_forw_backw },
	{ "hot.paste",		DSTYLE_ELEMENTS,	&s_hot_paste },
	{ "menu.frame",		DSTYLE_ELEMENTS,	&s_menu_frame },
	{ "menu.bg",		DSTYLE_ELEMENTS,	&s_menu_bg },
	{ "menu.n",		DSTYLE_ELEMENTS,	&s_menu_number },
	{ "menu.entry",		DSTYLE_ELEMENTS,	&s_menu_entry },
	{ "menu.active",	DSTYLE_ELEMENTS,	&s_menu_active },
	{ "menu.sb",		DSTYLE_ELEMENTS,	&s_menu_sb },
    };
    unsigned n;
    BOOL found = FALSE;

    char *buffer = 0;
    char *tmp = 0;
d168 2
a169 7
    if (param == 0)
	return;
    StrAllocCopy(buffer, param);
    if (buffer == 0)
	return;

    if ((tmp = strchr(buffer, ':')) == 0) {
d177 1
a177 1
	    exit_immediately(EXIT_FAILURE);
d181 5
a185 1
    strtolower(buffer);
d211 1
a211 1
    CTRACE2(TRACE_STYLE, (tfp, "CSSPARSE:%s => %d %s\n",
d213 1
a213 1
		(hashStyles[hash_code(element)].name ? "used" : "")));
d220 20
a239 8
    for (n = 0; n < TABLESIZE(table); n++) {
	if (!strcasecomp(element, table[n].name)) {
	    parse_attributes(mono, fg, bg, table[n].style, table[n].name);
	    if (table[n].set_hash != 0)
		*(table[n].set_hash) = hash_code(table[n].name);
	    found = TRUE;
	    break;
	}
d241 3
a243 3

    if (found) {
	;
d250 11
d266 12
d288 1
a289 1
    FREE(buffer);
a305 15
    static CONST char *table[] = {
	"a:bold:green",
	"alert:bold:yellow:red",
	"alink:reverse:yellow:black",
	"label:normal:magenta",
	"status:reverse:yellow:blue",
	"title:normal:magenta",
	"whereis:reverse+underline:magenta:cyan"
    };
    unsigned n;
    char temp[80];
    CTRACE((tfp, "initialize_default_stylesheet\n"));
    for (n = 0; n < TABLESIZE(table); n++) {
	parse_style(strcpy(temp, table[n]));
    }
d309 1
a309 1
PRIVATE void style_initialiseHashTable NOARGS
d311 2
a312 2
    int i;
    static int firsttime = 1;
d314 12
a325 12
    for (i = 0; i <CSHASHSIZE; i++)
    {
	if (firsttime)
	    hashStyles[i].name = NULL;
	else
	    FREE(hashStyles[i].name);
	hashStyles[i].color = 0;
	hashStyles[i].cattr = 0;
	hashStyles[i].mono  = 0;
    }
    if (firsttime) {
	firsttime = 0;
d327 1
a327 13
	atexit(free_colorstylestuff);
#endif
    }
    s_alink  = hash_code("alink");
    s_a      = hash_code("a");
    s_status = hash_code("status");
    s_alert  = hash_code("alert");
    s_title  = hash_code("title");
#ifdef USE_SCROLLBAR
    s_sb_bar = hash_code("scroll.bar");
    s_sb_bg  = hash_code("scroll.back");
    s_sb_aa  = hash_code("scroll.arrow");
    s_sb_naa = hash_code("scroll.noarrow");
d329 9
d344 1
a344 1
PRIVATE HTList *lss_styles = NULL;
d348 4
a351 2
    char *name;
    HTList *cur = lss_styles;
d353 2
a354 2
    colorPairs = 0;
    style_initialiseHashTable();
d356 5
a360 8
    /* set our styles to be the same as vanilla-curses-lynx */
    if (HTList_isEmpty(cur)) {
	initialise_default_stylesheet();
    } else {
	while ((name = HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n", name ? name : "!?! empty !?!"));
	    if (name != NULL)
		parse_style(name);
a361 18
    }

#define dft_style(a,b) if (a == NOSTYLE) a = b

    dft_style(s_prompt_edit,		s_normal);
    dft_style(s_prompt_edit_arr,	s_prompt_edit);
    dft_style(s_prompt_edit_pad,	s_prompt_edit);
    dft_style(s_prompt_sel,		s_prompt_edit);
    dft_style(s_aedit,			s_alink);
    dft_style(s_aedit_arr,		s_aedit);
    dft_style(s_aedit_pad,		s_aedit);
    dft_style(s_curedit,		s_aedit);
    dft_style(s_aedit_sel,		s_aedit);
    dft_style(s_menu_bg,		s_normal);
    dft_style(s_menu_entry,		s_menu_bg);
    dft_style(s_menu_frame,		s_menu_bg);
    dft_style(s_menu_number,		s_menu_bg);
    dft_style(s_menu_active,		s_alink);
d365 10
a374 23
/* Add a STYLE: option line to our list.  Process "default:" early
   for it to have the same semantic as other lines: works at any place
   of the style file, the first line overrides the later ones. */
PRIVATE void HStyle_addStyle ARGS1(char*, buffer)
{
    char *name = NULL;

    CTRACE((tfp, "HStyle_addStyle(%s)\n", buffer));
    StrAllocCopy(name, buffer);
    if (lss_styles == NULL)
	lss_styles = HTList_new();
    strtolower(name);
    if (!strncasecomp(name, "default:", 8)) /* default fg/bg */
    {
	CTRACE2(TRACE_STYLE, (tfp, "READCSS.default%s:%s\n",
		 (default_color_reset ? ".ignore" : ""),
		 name ? name : "!?! empty !?!"));
	if (!default_color_reset)
	    parse_style(name);
	return;				/* do not need to process it again */
    }
    CTRACE2(TRACE_STYLE, (tfp, "READCSS:%s\n", name ? name : "!?! empty !?!"));
    HTList_addObject (lss_styles, name);
d386 13
a398 3
PRIVATE int style_readFromFileREC ARGS2(
    char *,	lss_filename,
    char *,	parent_filename)
d404 2
a405 2
    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n", lss_filename ? lss_filename : "?!? empty ?!?"));
    if (isEmpty(lss_filename))
d407 3
a409 1
    if ((fh = LYOpenCFG(lss_filename, parent_filename, LYNX_LSS_FILE)) == 0) {
d411 1
a411 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS:Can't open style file '%s', using defaults\n", lss_filename));
d415 2
a416 4
    if (parent_filename == 0) {
	style_initialiseHashTable();
	style_deleteStyleList();
    }
d418 2
a419 1
    while (LYSafeGets(&buffer, fh) != NULL) {
d423 1
a423 3
	if (!strncasecomp(buffer,"include:",8))
	    style_readFromFileREC(buffer+8, lss_filename);
	else if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
d426 4
d431 2
a432 2
    LYCloseInput (fh);
    if ((parent_filename == 0) && LYCursesON)
a436 5
PUBLIC int style_readFromFile ARGS1(char*, filename)
{
    return style_readFromFileREC(filename, (char *)0);
}

d465 2
a481 3
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.fast-trim: [%s] from [%s]: ",
		  tag_name, stylename));
a495 1
    CTRACE2(TRACE_STYLE, (tfp, found ? "success.\n" : "failed.\n"));
d509 1
a509 1
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf)-1);
d511 1
a511 1
	cached_tag_styles[i] = hash_code(buf);
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.53 Wed, 07 Jan 2004 18:03:09 -0800 dickey $
d31 1
a31 1
PUBLIC int last_styles[128] = { 0 };
a193 1
	CTRACE2(TRACE_STYLE, (tfp, "parse_attributes %d/%d %d/%d %#x\n", fA, default_fg, bA, default_bg, cA));
d197 1
a197 1
	 && (cA != A_NORMAL || fA != default_fg || bA != default_bg)
a270 1
    CTRACE2(TRACE_STYLE, (tfp, "parse_style(%s)\n", param));
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.54 Mon, 19 Jan 2004 04:16:02 -0800 dickey $
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.55 Tue, 27 Apr 2004 13:06:18 -0700 dickey $
d28 1
a28 1
static void style_initialiseHashTable (void);
d31 2
a32 2
int last_styles[128] = { 0 };
int last_colorattr_ptr = 0;
d34 2
a35 2
bucket hashStyles[CSHASHSIZE];
bucket special_bucket =
d40 1
a40 1
bucket nostyle_bucket =
d46 5
a50 5
int cached_tag_styles[HTML_ELEMENTS];
int current_tag_style;
BOOL force_current_tag_style = FALSE;
char* forced_classname;
BOOL force_classname;
d53 24
a76 24
int s_a			= NOSTYLE;
int s_aedit		= NOSTYLE;
int s_aedit_arr		= NOSTYLE;
int s_aedit_pad		= NOSTYLE;
int s_aedit_sel		= NOSTYLE;
int s_alert		= NOSTYLE;
int s_alink		= NOSTYLE;
int s_curedit		= NOSTYLE;
int s_forw_backw		= NOSTYLE;
int s_hot_paste		= NOSTYLE;
int s_menu_active	= NOSTYLE;
int s_menu_bg		= NOSTYLE;
int s_menu_entry		= NOSTYLE;
int s_menu_frame		= NOSTYLE;
int s_menu_number	= NOSTYLE;
int s_menu_sb		= NOSTYLE;
int s_normal		= NOSTYLE;
int s_prompt_edit	= NOSTYLE;
int s_prompt_edit_arr	= NOSTYLE;
int s_prompt_edit_pad	= NOSTYLE;
int s_prompt_sel		= NOSTYLE;
int s_status		= NOSTYLE;
int s_title		= NOSTYLE;
int s_whereis		= NOSTYLE;
d79 4
a82 4
int s_sb_aa		= NOSTYLE;
int s_sb_bar		= NOSTYLE;
int s_sb_bg		= NOSTYLE;
int s_sb_naa		= NOSTYLE;
d87 1
a87 1
static int colorPairs = 0;
d97 1
a97 1
static unsigned char our_pairs[2]
d105 5
a109 5
static void parse_either (
    char *	attrs,
    int	dft_color,
    int *	monop,
    int *	colorp)
d134 6
a139 6
static void parse_attributes (
    char *	mono,
    char *	fg,
    char *	bg,
    int	style,
    char *	element)
d227 1
a227 1
static void parse_style (char* param)
d362 1
a362 1
static void free_colorstylestuff (void)
d373 1
a373 1
static void initialise_default_stylesheet (void)
d375 1
a375 1
    static const char *table[] = {
d393 1
a393 1
static void style_initialiseHashTable (void)
d431 1
a431 1
static HTList *lss_styles = NULL;
d433 1
a433 1
void parse_userstyles (void)
d474 1
a474 1
static void HStyle_addStyle (char* buffer)
d496 1
a496 1
void style_deleteStyleList (void)
d505 3
a507 3
static int style_readFromFileREC (
    char *	lss_filename,
    char *	parent_filename)
d543 1
a543 1
int style_readFromFile (char* filename)
d550 4
a553 4
void TrimColorClass (
    const char *	tagname,
    char *		styleclassname,
    int *		phcode)
d581 6
a586 6
void FastTrimColorClass (
	    const char*	 tag_name,
	    int		 name_len,
	    char*		 stylename,
	    char**		 pstylename_end,/*will be modified*/
	    int*		 phcode)	/*will be modified*/
d615 1
a615 1
void cache_tag_styles (void)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.57 Wed, 30 Jun 2004 16:55:04 -0700 dickey $
d28 1
a28 1
static void style_initialiseHashTable(void);
d31 1
a31 2
int last_styles[MAX_LAST_STYLES] =
{0};
d37 1
a37 1
    "<special>",		/* in order something to be in trace. */
d42 1
a42 1
    "<NOSTYLE>",		/* in order something to be in trace. */
d49 1
a49 1
char *forced_classname;
d53 24
a76 24
int s_a = NOSTYLE;
int s_aedit = NOSTYLE;
int s_aedit_arr = NOSTYLE;
int s_aedit_pad = NOSTYLE;
int s_aedit_sel = NOSTYLE;
int s_alert = NOSTYLE;
int s_alink = NOSTYLE;
int s_curedit = NOSTYLE;
int s_forw_backw = NOSTYLE;
int s_hot_paste = NOSTYLE;
int s_menu_active = NOSTYLE;
int s_menu_bg = NOSTYLE;
int s_menu_entry = NOSTYLE;
int s_menu_frame = NOSTYLE;
int s_menu_number = NOSTYLE;
int s_menu_sb = NOSTYLE;
int s_normal = NOSTYLE;
int s_prompt_edit = NOSTYLE;
int s_prompt_edit_arr = NOSTYLE;
int s_prompt_edit_pad = NOSTYLE;
int s_prompt_sel = NOSTYLE;
int s_status = NOSTYLE;
int s_title = NOSTYLE;
int s_whereis = NOSTYLE;
d79 4
a82 4
int s_sb_aa = NOSTYLE;
int s_sb_bar = NOSTYLE;
int s_sb_bg = NOSTYLE;
int s_sb_naa = NOSTYLE;
d98 3
a100 3
[MAX_BLINK]
[MAX_COLOR + 1]
[MAX_COLOR + 1];
d105 5
a109 4
static void parse_either(char *attrs,
			 int dft_color,
			 int *monop,
			 int *colorp)
a115 1

d119 1
a119 1
	if (save != 0)		/* attrs might be a constant string */
d124 1
a124 1
		 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
d134 6
a139 5
static void parse_attributes(char *mono,
			     char *fg,
			     char *bg,
			     int style,
			     char *element)
d147 1
a147 2
    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n",
			  style, newstyle, element));
d149 1
a149 1
    parse_either(mono, ERR_COLOR, &mA, (int *) 0);
d153 2
a154 3
    if (style == -1) {		/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n",
			      fA, bA));
d187 1
a187 1
    if (lynx_has_color && colorPairs < COLOR_PAIRS - 1 && fA != NO_COLOR) {
d194 1
a194 2
	CTRACE2(TRACE_STYLE, (tfp, "parse_attributes %d/%d %d/%d %#x\n",
			      fA, default_fg, bA, default_bg, cA));
d196 1
a196 1
	    && bA < MAX_COLOR
d198 1
a198 1
	    && (cA != A_NORMAL || fA != default_fg || bA != default_bg)
d200 1
a200 1
	    && curPair < 255) {
d205 1
a205 1
		init_pair((short) curPair, (short) fA, (short) bA);
d211 2
a212 2
	    setStyle(style, COLOR_PAIR(curPair) | cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair) | cA, cA, mA, element);
d215 1
a215 3
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n",
		     COLOR_PAIRS - 1));
d227 1
a227 1
static void parse_style(char *param)
a228 1
    /* *INDENT-OFF* */
a262 2
    /* *INDENT-ON* */

d278 1
a278 1
	fprintf(stderr, gettext("\
d296 2
a297 1
    if (!tmp) {
d300 3
a302 1
    } else {
d304 1
a304 1
	fg = tmp + 1;
d308 2
a309 1
	else {
d316 2
a317 2
			  element, hash_code(element),
			  (hashStyles[hash_code(element)].name ? "used" : "")));
d322 2
a323 2
     * We use some pseudo-elements, so catch these first
     */
d336 2
a337 1
    } else if (!strcasecomp(element, "normal"))		/* added - kw */
d339 2
a340 2
	parse_attributes(mono, fg, bg, DSTYLE_NORMAL, "html");
	s_normal = hash_code("html");	/* rather bizarre... - kw */
d342 5
a346 2
    /* It must be a HTML element, so look through the list until we find it. */
    else {
d348 1
a348 2
	HTTag *t = SGMLFindTag(&HTML_dtd, element);

d354 1
a354 1
	    parse_attributes(mono, fg, bg, element_number + STARTAT, element);
d356 1
a356 1
	    parse_attributes(mono, fg, bg, DSTYLE_ELEMENTS, element);
d362 1
a362 1
static void free_colorstylestuff(void)
d373 1
a373 1
static void initialise_default_stylesheet(void)
d375 1
a375 2
    static const char *table[] =
    {
a385 1

d393 1
a393 1
static void style_initialiseHashTable(void)
d398 2
a399 1
    for (i = 0; i < CSHASHSIZE; i++) {
d406 1
a406 1
	hashStyles[i].mono = 0;
d414 2
a415 2
    s_alink = hash_code("alink");
    s_a = hash_code("a");
d417 2
a418 2
    s_alert = hash_code("alert");
    s_title = hash_code("title");
d421 2
a422 2
    s_sb_bg = hash_code("scroll.back");
    s_sb_aa = hash_code("scroll.arrow");
d433 1
a433 1
void parse_userstyles(void)
d446 1
a446 4
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n",
				  (name
				   ? name
				   : "!?! empty !?!")));
d453 1
a453 1
    /* *INDENT-OFF* */
d468 1
a468 1
    /* *INDENT-ON* */
a469 1
}
d472 3
a474 4
 * for it to have the same semantic as other lines: works at any place
 * of the style file, the first line overrides the later ones.
 */
static void HStyle_addStyle(char *buffer)
d483 1
a483 1
    if (!strncasecomp(name, "default:", 8))	/* default fg/bg */
d486 2
a487 2
			      (default_color_reset ? ".ignore" : ""),
			      name ? name : "!?! empty !?!"));
d490 1
a490 1
	return;			/* do not need to process it again */
d493 1
a493 1
    HTList_addObject(lss_styles, name);
d496 1
a496 1
void style_deleteStyleList(void)
a498 1

d501 1
a501 1
    HTList_delete(lss_styles);
d505 3
a507 2
static int style_readFromFileREC(char *lss_filename,
				 char *parent_filename)
d513 1
a513 2
    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n",
			  lss_filename ? lss_filename : "?!? empty ?!?"));
d518 1
a518 2
	CTRACE2(TRACE_STYLE, (tfp,
			      "CSS:Can't open style file '%s', using defaults\n", lss_filename));
d531 2
a532 2
	if (!strncasecomp(buffer, "include:", 8))
	    style_readFromFileREC(buffer + 8, lss_filename);
d537 1
a537 1
    LYCloseInput(fh);
d543 1
a543 1
int style_readFromFile(char *filename)
d545 1
a545 1
    return style_readFromFileREC(filename, (char *) 0);
d550 4
a553 3
void TrimColorClass(const char *tagname,
		    char *styleclassname,
		    int *phcode)
d555 1
a555 1
    char *end, *start = NULL, *lookfrom;
d570 2
a571 2
	 * - should match classes here as well (rp)
	 */
d573 1
a573 1
	    *end = '\0';
d579 8
a586 7
 * It assumes that tag_name is present in stylename! -HV
 */
void FastTrimColorClass(const char *tag_name,
			int name_len,
			char *stylename,
			char **pstylename_end,	/*will be modified */
			int *phcode)	/*will be modified */
d588 1
a588 1
    char *tag_start = *pstylename_end;
d593 6
a598 4
	     tag_name, stylename));
    while (tag_start >= stylename) {
	for (; (tag_start >= stylename) && (*tag_start != ';'); --tag_start) ;
	if (!strncasecomp(tag_start + 1, tag_name, name_len)) {
d609 1
a609 1
    *phcode = hash_code(tag_start + 1);
d613 3
a615 3
  * each elt of 'cached_tag_styles' -HV
  */
void cache_tag_styles(void)
d620 3
a622 2
    for (i = 0; i < HTML_ELEMENTS; ++i) {
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d3 1
a3 1
 * $Id: LYStyle.c,v 1.3 2003/05/01 18:59:39 avsm Exp $
a27 2
PRIVATE void style_initialiseHashTable NOPARAMS;

d30 1
a30 1
PUBLIC int last_colorattr_ptr = 0;
d35 1
a35 2
    "<special>", /* in order something to be in trace. */
    0, 0, 0, 0, NULL
d39 1
a39 2
    "<NOSTYLE>", /* in order something to be in trace. */
    0, 0, 0, 0, NULL
d44 1
a44 1
PUBLIC BOOL force_current_tag_style = FALSE;
d48 14
d63 4
a66 30
PUBLIC int s_a			= NOSTYLE;
PUBLIC int s_aedit		= NOSTYLE;
PUBLIC int s_aedit_arr		= NOSTYLE;
PUBLIC int s_aedit_pad		= NOSTYLE;
PUBLIC int s_aedit_sel		= NOSTYLE;
PUBLIC int s_alert		= NOSTYLE;
PUBLIC int s_alink		= NOSTYLE;
PUBLIC int s_curedit		= NOSTYLE;
PUBLIC int s_forw_backw		= NOSTYLE;
PUBLIC int s_normal		= NOSTYLE;
PUBLIC int s_prompt_edit	= NOSTYLE;
PUBLIC int s_prompt_edit_arr	= NOSTYLE;
PUBLIC int s_prompt_edit_pad	= NOSTYLE;
PUBLIC int s_prompt_sel		= NOSTYLE;
PUBLIC int s_status		= NOSTYLE;
PUBLIC int s_title		= NOSTYLE;
PUBLIC int s_whereis		= NOSTYLE;
PUBLIC int s_menu_frame		= NOSTYLE;
PUBLIC int s_menu_bg		= NOSTYLE;
PUBLIC int s_menu_number	= NOSTYLE;
PUBLIC int s_menu_entry		= NOSTYLE;
PUBLIC int s_menu_active	= NOSTYLE;
PUBLIC int s_menu_sb		= NOSTYLE;

#ifdef USE_SCROLLBAR
PUBLIC int s_sb_aa		= NOSTYLE;
PUBLIC int s_sb_bar		= NOSTYLE;
PUBLIC int s_sb_bg		= NOSTYLE;
PUBLIC int s_sb_naa		= NOSTYLE;
#endif
a68 1
#define MAX_COLOR 16
d70 1
a70 41

#ifdef USE_BLINK
#  define MAX_BLINK	2
#  define M_BLINK	A_BLINK
#else
#  define MAX_BLINK	1
#  define M_BLINK	0
#endif

PRIVATE unsigned char our_pairs[2][MAX_BLINK][MAX_COLOR][MAX_COLOR];

/*
 * Parse a string containing a combination of video attributes and color.
 */
PRIVATE void parse_either ARGS4(
    char *,	attrs,
    int,	dft_color,
    int *,	monop,
    int *,	colorp)
{
    int value;

    while (*attrs != '\0') {
	char *next = strchr(attrs, '+');
	char save = (next != NULL) ? *next : '\0';
	if (next == NULL)
	    next = attrs + strlen(attrs);

	if (save != 0)	/* attrs might be a constant string */
	    *next = '\0';
	if ((value = string_to_attr(attrs)) != 0)
	    *monop |= value;
	else if (colorp != 0
	 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
	    *colorp = value;

	attrs = next;
	if (save != '\0')
	    *attrs++ = save;
    }
}
d73 4
a76 11
PRIVATE void parse_attributes ARGS5(
    char *,	mono,
    char *,	fg,
    char *,	bg,
    int,	style,
    char *,	element)
{
    int mA = A_NORMAL;
    int fA = default_fg;
    int bA = default_bg;
    int cA = A_NORMAL;
d79 1
a79 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle, element));
d81 6
a86 10
    parse_either(mono, ERR_COLOR, &mA, (int *)0);
    parse_either(bg, default_bg, &cA, &bA);
    parse_either(fg, default_fg, &cA, &fA);

    if (style == -1) {			/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n", fA, bA));
	default_fg = fA;
	default_bg = bA;
	default_color_reset = TRUE;
	return;
d88 32
a122 8
#ifdef USE_BLINK
	if (term_blink_is_boldbg) {
	    if (fA >= COLORS)
		cA = A_BOLD;
	    if (bA >= COLORS)
		cA |= M_BLINK;
	} else
#endif
d127 1
a127 1
	if (bA >= COLORS)
d141 5
a145 13
	int curPair;

	if (fA < MAX_COLOR
	 && bA < MAX_COLOR
	 && our_pairs[!!(cA & A_BOLD)][!!(cA & A_BLINK)][fA][bA])
	    curPair = our_pairs[!!(cA & A_BOLD)][!!(cA & M_BLINK)][fA][bA] - 1;
	else {
	    curPair = ++colorPairs;
	    init_pair((short)curPair, (short)fA, (short)bA);
	    if (fA < MAX_COLOR
	     && bA < MAX_COLOR
	     && curPair < 255)
		our_pairs[!!(cA & A_BOLD)][!!(cA & M_BLINK)][fA][bA] = curPair + 1;
a146 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS(CURPAIR):%d\n", curPair));
d148 2
a149 2
	    setStyle(style, COLOR_PAIR(curPair)|cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair)|cA, cA, mA, element);
d153 1
a153 4
	if (lynx_has_color && fA != NO_COLOR) {
	    CTRACE2(TRACE_STYLE, (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n", COLOR_PAIRS - 1));
	}
	/* only mono is set */
d163 1
a163 1
PRIVATE void parse_style ARGS1(char*, param)
a164 37
    static struct {
	char *name;
	int style;
	int *set_hash;
    } table[] = {
	{ "default",		-1,			0 }, /* default fg/bg */
	{ "alink",		DSTYLE_ALINK,		0 }, /* active link */
	{ "a",			DSTYLE_LINK,		0 }, /* normal link */
	{ "a",			HTML_A,			0 }, /* normal link */
	{ "status",		DSTYLE_STATUS,		0 }, /* status bar */
	{ "label",		DSTYLE_OPTION,		0 }, /* [INLINE]'s */
	{ "value",		DSTYLE_VALUE,		0 }, /* [INLINE]'s */
	{ "high",		DSTYLE_HIGH,		0 }, /* [INLINE]'s */
	{ "normal",		DSTYLE_NORMAL,		0 },
	{ "candy",		DSTYLE_CANDY,		0 }, /* [INLINE]'s */
	{ "whereis",		DSTYLE_WHEREIS,		&s_whereis },
	{ "edit.active.pad",	DSTYLE_ELEMENTS,	&s_aedit_pad },
	{ "edit.active.arrow",	DSTYLE_ELEMENTS,	&s_aedit_arr },
	{ "edit.active.marked",	DSTYLE_ELEMENTS,	&s_aedit_sel },
	{ "edit.active",	DSTYLE_ELEMENTS,	&s_aedit },
	{ "edit.current",	DSTYLE_ELEMENTS,	&s_curedit },
	{ "edit.prompt.pad",	DSTYLE_ELEMENTS,	&s_prompt_edit_pad },
	{ "edit.prompt.arrow",	DSTYLE_ELEMENTS,	&s_prompt_edit_arr },
	{ "edit.prompt.marked",	DSTYLE_ELEMENTS,	&s_prompt_sel },
	{ "edit.prompt",	DSTYLE_ELEMENTS,	&s_prompt_edit },
	{ "forwbackw.arrow",	DSTYLE_ELEMENTS,	&s_forw_backw },
	{ "menu.frame",		DSTYLE_ELEMENTS,	&s_menu_frame },
	{ "menu.bg",		DSTYLE_ELEMENTS,	&s_menu_bg },
	{ "menu.n",		DSTYLE_ELEMENTS,	&s_menu_number },
	{ "menu.entry",		DSTYLE_ELEMENTS,	&s_menu_entry },
	{ "menu.active",	DSTYLE_ELEMENTS,	&s_menu_active },
	{ "menu.sb",		DSTYLE_ELEMENTS,	&s_menu_sb },
    };
    unsigned n;
    BOOL found = FALSE;

    char *buffer = strdup(param);
d177 1
a177 1
	    exit_immediately(EXIT_FAILURE);
d181 5
a185 1
    strtolower(buffer);
d211 1
a211 1
    CTRACE2(TRACE_STYLE, (tfp, "CSSPARSE:%s => %d %s\n",
d213 1
a213 1
		(hashStyles[hash_code(element)].name ? "used" : "")));
d220 20
a239 8
    for (n = 0; n < TABLESIZE(table); n++) {
	if (!strcasecomp(element, table[n].name)) {
	    parse_attributes(mono, fg, bg, table[n].style, table[n].name);
	    if (table[n].set_hash != 0)
		*(table[n].set_hash) = hash_code(table[n].name);
	    found = TRUE;
	    break;
	}
d241 3
a243 3

    if (found) {
	;
d250 11
d266 12
d288 1
a289 1
    FREE(buffer);
a305 15
    static CONST char *table[] = {
	"a:bold:green",
	"alert:bold:yellow:red",
	"alink:reverse:yellow:black",
	"label:normal:magenta",
	"status:reverse:yellow:blue",
	"title:normal:magenta",
	"whereis:reverse+underline:magenta:cyan"
    };
    unsigned n;
    char temp[80];
    CTRACE((tfp, "initialize_default_stylesheet\n"));
    for (n = 0; n < TABLESIZE(table); n++) {
	parse_style(strcpy(temp, table[n]));
    }
d309 1
a309 1
PRIVATE void style_initialiseHashTable NOARGS
d311 2
a312 2
    int i;
    static int firsttime = 1;
d314 12
a325 12
    for (i = 0; i <CSHASHSIZE; i++)
    {
	if (firsttime)
	    hashStyles[i].name = NULL;
	else
	    FREE(hashStyles[i].name);
	hashStyles[i].color = 0;
	hashStyles[i].cattr = 0;
	hashStyles[i].mono  = 0;
    }
    if (firsttime) {
	firsttime = 0;
d327 1
a327 13
	atexit(free_colorstylestuff);
#endif
    }
    s_alink  = hash_code("alink");
    s_a      = hash_code("a");
    s_status = hash_code("status");
    s_alert  = hash_code("alert");
    s_title  = hash_code("title");
#ifdef USE_SCROLLBAR
    s_sb_bar = hash_code("scroll.bar");
    s_sb_bg  = hash_code("scroll.back");
    s_sb_aa  = hash_code("scroll.arrow");
    s_sb_naa = hash_code("scroll.noarrow");
d329 9
d344 1
a344 1
PRIVATE HTList *lss_styles = NULL;
d348 4
a351 3
    static BOOL first = TRUE;
    char *name;
    HTList *cur = lss_styles;
d353 2
a354 2
    colorPairs = 0;
    style_initialiseHashTable();
d356 5
a360 8
    /* set our styles to be the same as vanilla-curses-lynx */
    if (HTList_isEmpty(cur)) {
	initialise_default_stylesheet();
    } else {
	while ((name = HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n", name ? name : "!?! empty !?!"));
	    if (name != NULL)
		parse_style(name);
a361 18
    }

#define dft_style(a,b) if (a == NOSTYLE) a = b

    dft_style(s_prompt_edit,		s_normal);
    dft_style(s_prompt_edit_arr,	s_prompt_edit);
    dft_style(s_prompt_edit_pad,	s_prompt_edit);
    dft_style(s_prompt_sel,		s_prompt_edit);
    dft_style(s_aedit,			s_alink);
    dft_style(s_aedit_arr,		s_aedit);
    dft_style(s_aedit_pad,		s_aedit);
    dft_style(s_curedit,		s_aedit);
    dft_style(s_aedit_sel,		s_aedit);
    dft_style(s_menu_bg,		s_normal);
    dft_style(s_menu_entry,		s_menu_bg);
    dft_style(s_menu_frame,		s_menu_bg);
    dft_style(s_menu_number,		s_menu_bg);
    dft_style(s_menu_active,		s_alink);
d365 10
a374 23
/* Add a STYLE: option line to our list.  Process "default:" early
   for it to have the same semantic as other lines: works at any place
   of the style file, the first line overrides the later ones. */
PRIVATE void HStyle_addStyle ARGS1(char*, buffer)
{
    char *name = NULL;

    CTRACE((tfp, "HStyle_addStyle(%s)\n", buffer));
    StrAllocCopy(name, buffer);
    if (lss_styles == NULL)
	lss_styles = HTList_new();
    strtolower(name);
    if (!strncasecomp(name, "default:", 8)) /* default fg/bg */
    {
	CTRACE2(TRACE_STYLE, (tfp, "READCSS.default%s:%s\n",
		 (default_color_reset ? ".ignore" : ""),
		 name ? name : "!?! empty !?!"));
	if (!default_color_reset)
	    parse_style(name);
	return;				/* do not need to process it again */
    }
    CTRACE2(TRACE_STYLE, (tfp, "READCSS:%s\n", name ? name : "!?! empty !?!"));
    HTList_addObject (lss_styles, name);
d386 13
a398 3
PRIVATE int style_readFromFileREC ARGS2(
    char *,	lss_filename,
    char *,	parent_filename)
d404 2
a405 2
    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n", lss_filename ? lss_filename : "?!? empty ?!?"));
    if (lss_filename == NULL || *lss_filename == '\0')
d407 3
a409 1
    if ((fh = LYOpenCFG(lss_filename, parent_filename, LYNX_LSS_FILE)) == 0) {
d411 1
a411 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS:Can't open style file '%s', using defaults\n", lss_filename));
d415 2
a416 4
    if (parent_filename == 0) {
	style_initialiseHashTable();
	style_deleteStyleList();
    }
d418 2
a419 1
    while (LYSafeGets(&buffer, fh) != NULL) {
d423 1
a423 3
	if (!strncasecomp(buffer,"include:",8))
	    style_readFromFileREC(buffer+8, lss_filename);
	else if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
d426 4
d431 2
a432 2
    LYCloseInput (fh);
    if ((parent_filename == 0) && LYCursesON)
a436 5
PUBLIC int style_readFromFile ARGS1(char*, filename)
{
    return style_readFromFileREC(filename, (char *)0);
}

d465 2
a481 3
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.fast-trim: [%s] from [%s]: ",
		  tag_name, stylename));
a495 1
    CTRACE2(TRACE_STYLE, (tfp, found ? "success.\n" : "failed.\n"));
d511 1
a511 1
	cached_tag_styles[i] = hash_code(buf);
@

