head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.07.15.18.17.06;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.38;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.40;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.36;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.27;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.49;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.23;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.16.05;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.53.58;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@automatic merge of lynx-current
@
text
@#include <HTUtils.h>

#include <HTCJK.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <HTStream.h>
#include <UCAux.h>
#include <LYCharSets.h>

BOOL UCCanUniTranslateFrom(int from)
{
    if (from < 0)
	return NO;
    if (LYCharSet_UC[from].enc == UCT_ENC_CJK)
	return NO;
    if (!strcmp(LYCharSet_UC[from].MIMEname, "x-transparent"))
	return NO;

    /* others YES */
    return YES;
}

BOOL UCCanTranslateUniTo(int to)
{
    if (to < 0)
	return NO;
/*???
    if (!strcmp(LYCharSet_UC[to].MIMEname, "x-transparent"))
       return NO;
*/

    return YES;			/* well at least some characters... */
}

BOOL UCCanTranslateFromTo(int from,
			  int to)
{
    if (from == to)
	return YES;
    if (from < 0 || to < 0)
	return NO;
    if (from == LATIN1)
	return UCCanTranslateUniTo(to);
    if (to == LATIN1 || LYCharSet_UC[to].enc == UCT_ENC_UTF8)
	return UCCanUniTranslateFrom(from);
    {
	const char *fromname = LYCharSet_UC[from].MIMEname;
	const char *toname = LYCharSet_UC[to].MIMEname;

	if (!strcmp(fromname, "x-transparent") ||
	    !strcmp(toname, "x-transparent")) {
	    return YES;		/* ??? */
	} else if (!strcmp(fromname, "us-ascii")) {
	    return YES;
	}
	if (LYCharSet_UC[from].enc == UCT_ENC_CJK) {
	    /*
	     * CJK mode may be off (i.e., HTCJK == NOCJK) because the current
	     * document is not CJK, but the check may be for capability in
	     * relation to another document, for which CJK mode might be turned
	     * on when retrieved.  Thus, when the from charset is CJK, check if
	     * the to charset is CJK, and return NO or YES in relation to that. 
	     * - FM
	     */
	    if (LYCharSet_UC[to].enc != UCT_ENC_CJK)
		return NO;
	    if ((!strcmp(toname, "euc-jp") ||
		 !strcmp(toname, "shift_jis")) &&
		(!strcmp(fromname, "euc-jp") ||
		 !strcmp(fromname, "shift_jis")))
		return YES;
	    /*
	     * The euc-cn and euc-kr charsets were handled by the (from == to)
	     * above, so we need not check those.  - FM
	     */
	    return NO;
	}
    }
    return YES;			/* others YES */
}

/*
 *  Returns YES if no translation necessary (because
 *  charsets are equal, are equivalent, etc.).
 */
BOOL UCNeedNotTranslate(int from,
			int to)
{
    const char *fromname;
    const char *toname;

    if (from == to)
	return YES;
    if (from < 0)
	return NO;		/* ??? */
    if (LYCharSet_UC[from].enc == UCT_ENC_7BIT) {
	return YES;		/* Only 7bit chars. */
    }
    fromname = LYCharSet_UC[from].MIMEname;
    if (!strcmp(fromname, "x-transparent") ||
	!strcmp(fromname, "us-ascii")) {
	return YES;
    }
    if (to < 0)
	return NO;		/* ??? */
    if (to == LATIN1) {
	if (LYCharSet_UC[from].codepoints & (UCT_CP_SUBSETOF_LAT1))
	    return YES;
    }
    toname = LYCharSet_UC[to].MIMEname;
    if (!strcmp(toname, "x-transparent")) {
	return YES;
    }
    if (LYCharSet_UC[to].enc == UCT_ENC_UTF8) {
	return NO;
    }
    if (from == LATIN1) {
	if (LYCharSet_UC[from].codepoints & (UCT_CP_SUPERSETOF_LAT1))
	    return YES;
    }
    if (LYCharSet_UC[from].enc == UCT_ENC_CJK) {
	if (HTCJK == NOCJK)	/* Use that global flag, for now. */
	    return NO;
	if (HTCJK == JAPANESE &&
	    (!strcmp(fromname, "euc-jp") ||
	     !strcmp(fromname, "shift_jis")))
	    return YES;		/* translate internally by lynx, no unicode */
	return NO;		/* If not handled by (from == to) above. */
    }
    return NO;
}

/*
 *  The idea here is that any stage of the stream pipe which is interested
 *  in some charset dependent processing will call this function.
 *  Given input and output charsets, this function will set various flags
 *  in a UCTransParams structure that _suggest_ to the caller what to do.
 *
 *  Should be called once when a stage starts processing text (and the
 *  input and output charsets are known), or whenever one of input or
 *  output charsets has changed (e.g., by SGML.c stage after HTML.c stage
 *  has processed a META tag).
 *  The global flags (LYRawMode, HTPassEightBitRaw etc.) are currently
 *  not taken into account here (except for HTCJK, somewhat), it's still
 *  up to the caller to do something about them. - KW
 */
void UCSetTransParams(UCTransParams * pT, int cs_in,
		      const LYUCcharset *p_in,
		      int cs_out,
		      const LYUCcharset *p_out)
{
    CTRACE((tfp, "UCSetTransParams: from %s(%d) to %s(%d)\n",
	    p_in->MIMEname, UCGetLYhndl_byMIME(p_in->MIMEname),
	    p_out->MIMEname, UCGetLYhndl_byMIME(p_out->MIMEname)));

    /*
     * Initialize this element to FALSE, and set it TRUE below if we're dealing
     * with VISCII.  - FM
     */
    pT->trans_C0_to_uni = FALSE;

    /*
     * The "transparent" display character set is a "super raw mode".  - FM
     */
    pT->transp = (BOOL) (!strcmp(p_in->MIMEname, "x-transparent") ||
			 !strcmp(p_out->MIMEname, "x-transparent"));

    if (pT->transp) {
	/*
	 * Set up the structure for "transparent".  - FM
	 */
	pT->do_cjk = FALSE;
	pT->decode_utf8 = FALSE;
	pT->output_utf8 = FALSE;	/* We may, but won't know about it. - KW */
	pT->do_8bitraw = TRUE;
	pT->use_raw_char_in = TRUE;
	pT->strip_raw_char_in = FALSE;
	pT->pass_160_173_raw = TRUE;
	pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
	pT->trans_C0_to_uni = (BOOL) (p_in->enc == UCT_ENC_8BIT_C0 ||
				      p_out->enc == UCT_ENC_8BIT_C0);
    } else {
	/*
	 * Initialize local flags.  - FM
	 */
	BOOL intm_ucs = FALSE;
	BOOL use_ucs = FALSE;

	/*
	 * Set this element if we want to treat the input as CJK.  - FM
	 */
	pT->do_cjk = (BOOL) ((p_in->enc == UCT_ENC_CJK) && (HTCJK != NOCJK));
	/*
	 * Set these elements based on whether we are dealing with UTF-8.  - FM
	 */
	pT->decode_utf8 = (BOOL) (p_in->enc == UCT_ENC_UTF8);
	pT->output_utf8 = (BOOL) (p_out->enc == UCT_ENC_UTF8);
	if (pT->do_cjk) {
	    /*
	     * Set up the structure for a CJK input with
	     * a CJK output (HTCJK != NOCJK).  - FM
	     */
	    intm_ucs = FALSE;
	    pT->trans_to_uni = FALSE;
	    use_ucs = FALSE;
	    pT->do_8bitraw = FALSE;
	    pT->pass_160_173_raw = TRUE;
	    pT->use_raw_char_in = FALSE;	/* Not used for CJK. - KW */
	    pT->repl_translated_C0 = FALSE;
	    pT->trans_from_uni = FALSE;		/* Not used for CJK. - KW */
	} else {
	    /*
	     * Set up for all other charset combinations.  The intm_ucs flag is
	     * set TRUE if the input charset is iso-8859-1 or UTF-8, or largely
	     * equivalent to them, i.e., if we have UCS without having to do a
	     * table translation.
	     */
	    intm_ucs = (BOOL) (cs_in == LATIN1 || pT->decode_utf8 ||
			       (p_in->codepoints &
				(UCT_CP_SUBSETOF_LAT1 | UCT_CP_SUBSETOF_UCS2)));
	    /*
	     * pT->trans_to_uni is set TRUE if we do not have that as input
	     * already, and we can translate to Unicode.  Note that UTF-8
	     * always is converted to Unicode in functions that use the
	     * transformation structure, so it is treated as already Unicode
	     * here.
	     */
	    pT->trans_to_uni = (BOOL) (!intm_ucs &&
				       UCCanUniTranslateFrom(cs_in));
	    /*
	     * We set this if we are translating to Unicode and what normally
	     * are low value control characters in fact are encoding octets for
	     * the input charset (presently, this applies to VISCII).  - FM
	     */
	    pT->trans_C0_to_uni = (BOOL) (pT->trans_to_uni &&
					  p_in->enc == UCT_ENC_8BIT_C0);
	    /*
	     * We set this, presently, for VISCII.  - FM
	     */
	    pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
	    /*
	     * Currently unused for any charset combination.
	     * Should always be FALSE
	     */
	    pT->strip_raw_char_in = FALSE;
	    /*
	     * use_ucs should be set TRUE if we have or will create Unicode
	     * values for input octets or UTF multibytes.  - FM
	     */
	    use_ucs = (BOOL) (intm_ucs || pT->trans_to_uni);
	    /*
	     * This is set TRUE if use_ucs was set FALSE.  It is complementary
	     * to the HTPassEightBitRaw flag, which is set TRUE or FALSE
	     * elsewhere based on the raw mode setting in relation to the
	     * current Display Character Set.  - FM
	     */
	    pT->do_8bitraw = (BOOL) (!use_ucs);
	    /*
	     * This is set TRUE when 160 and 173 should not be treated as nbsp
	     * and shy, respectively.  - FM
	     */
	    pT->pass_160_173_raw = (BOOL) (!use_ucs &&
					   !(p_in->like8859 & UCT_R_8859SPECL));
	    /*
	     * This is set when the input and output charsets match, and they
	     * are not ones which should go through a Unicode translation
	     * process anyway.  - FM
	     */
	    pT->use_raw_char_in = (BOOL) (!pT->output_utf8 &&
					  cs_in == cs_out &&
					  !pT->trans_C0_to_uni);
	    /*
	     * This should be set TRUE when we expect to have done translation
	     * to Unicode or had the equivalent as input, can translate it to
	     * our output charset, and normally want to do so.  The latter
	     * depends on the pT->do_8bitraw and pT->use_raw_char_in values set
	     * above, but also on HTPassEightBitRaw in any functions which use
	     * the transformation structure..  - FM
	     */
	    pT->trans_from_uni = (BOOL) (use_ucs && !pT->do_8bitraw &&
					 !pT->use_raw_char_in &&
					 UCCanTranslateUniTo(cs_out));
	}
    }
}

/*
 *  This function initializes the transformation
 *  structure by setting all its elements to
 *  FALSE. - KW
 */
void UCTransParams_clear(UCTransParams * pT)
{
    pT->transp = FALSE;
    pT->do_cjk = FALSE;
    pT->decode_utf8 = FALSE;
    pT->output_utf8 = FALSE;
    pT->do_8bitraw = FALSE;
    pT->use_raw_char_in = FALSE;
    pT->strip_raw_char_in = FALSE;
    pT->pass_160_173_raw = FALSE;
    pT->trans_to_uni = FALSE;
    pT->trans_C0_to_uni = FALSE;
    pT->repl_translated_C0 = FALSE;
    pT->trans_from_uni = FALSE;
}

/*
 *  If terminal is in UTF-8 mode, it probably cannot understand
 *  box drawing chars as (n)curses handles them.  (This may also
 *  be true for other display character sets, but isn't currently
 *  checked.)  In that case set the chars for hori and vert drawing
 *  chars to displayable ASCII chars if '0' was requested.  They'll
 *  stay as they are otherwise. - kw
 */
void UCSetBoxChars(int cset,
		   int *pvert_out,
		   int *phori_out,
		   int vert_in,
		   int hori_in)
{
#ifndef WIDEC_CURSES
    if (cset >= -1 && LYCharSet_UC[cset].enc == UCT_ENC_UTF8) {
	*pvert_out = (vert_in ? vert_in : '|');
	*phori_out = (hori_in ? hori_in : '-');
    } else
#endif
    {
	*pvert_out = vert_in;
	*phori_out = hori_in;
    }
}

/*
 *  Given an output target HTStream* (can also be a HTStructured* via
 *  typecast), the target stream's put_character method, and a Unicode
 *  character,  CPutUtf8_charstring() will either output the UTF8
 *  encoding of the Unicode and return YES, or do nothing and return
 *  NO (if conversion would be unnecessary or the Unicode character is
 *  considered invalid).
 *
 *  [Could be used more generally, but is currently only used for &#nnnnn
 *  stuff - generation of UTF8 from 8-bit encoded charsets not yet done
 *  by SGML.c etc.]
 */
#define PUTC(ch) ((*myPutc)(target, (char)(ch)))
#define PUTC2(ch) ((*myPutc)(target,(char)(0x80|(0x3f &(ch)))))

BOOL UCPutUtf8_charstring(HTStream *target, putc_func_t * myPutc, long code)
{
    if (code < 128)
	return NO;		/* indicate to caller we didn't handle it */
    else if (code < 0x800L) {
	PUTC(0xc0 | (code >> 6));
	PUTC2(code);
    } else if (code < 0x10000L) {
	PUTC(0xe0 | (code >> 12));
	PUTC2(code >> 6);
	PUTC2(code);
    } else if (code < 0x200000L) {
	PUTC(0xf0 | (code >> 18));
	PUTC2(code >> 12);
	PUTC2(code >> 6);
	PUTC2(code);
    } else if (code < 0x4000000L) {
	PUTC(0xf8 | (code >> 24));
	PUTC2(code >> 18);
	PUTC2(code >> 12);
	PUTC2(code >> 6);
	PUTC2(code);
    } else if (code <= 0x7fffffffL) {
	PUTC(0xfc | (code >> 30));
	PUTC2(code >> 24);
	PUTC2(code >> 18);
	PUTC2(code >> 12);
	PUTC2(code >> 6);
	PUTC2(code);
    } else
	return NO;
    return YES;
}

/*
 *  This function converts a Unicode (UCode_t) value
 *  to a multibyte UTF-8 character, which is loaded
 *  into the buffer received as an argument.  The
 *  buffer should be large enough to hold at least
 *  seven characters (but should be declared as 8
 *  to minimize byte alignment problems with some
 *  compilers). - FM
 */
BOOL UCConvertUniToUtf8(UCode_t code, char *buffer)
{
    char *ch = buffer;

    if (!ch)
	return NO;

    if (code <= 0 || code > 0x7fffffffL) {
	*ch = '\0';
	return NO;
    }

    if (code < 0x800L) {
	*ch++ = (char) (0xc0 | (code >> 6));
	*ch++ = (char) (0x80 | (0x3f & (code)));
	*ch = '\0';
    } else if (code < 0x10000L) {
	*ch++ = (char) (0xe0 | (code >> 12));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
	*ch = '\0';
    } else if (code < 0x200000L) {
	*ch++ = (char) (0xf0 | (code >> 18));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
	*ch = '\0';
    } else if (code < 0x4000000L) {
	*ch++ = (char) (0xf8 | (code >> 24));
	*ch++ = (char) (0x80 | (0x3f & (code >> 18)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
	*ch = '\0';
    } else {
	*ch++ = (char) (0xfc | (code >> 30));
	*ch++ = (char) (0x80 | (0x3f & (code >> 24)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 18)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
	*ch = '\0';
    }
    return YES;
}

/*
 * Get UCS character code for one character from UTF-8 encoded string.
 *
 * On entry:
 *	*ppuni should point to beginning of UTF-8 encoding character
 * On exit:
 *	*ppuni is advanced to point to the last byte of UTF-8 sequence,
 *		if there was a valid one; otherwise unchanged.
 * returns the UCS value
 * returns negative value on error (invalid UTF-8 sequence)
 */
UCode_t UCGetUniFromUtf8String(char **ppuni)
{
    UCode_t uc_out = 0;
    char *p = *ppuni;
    int utf_count, i;

    if (!(**ppuni & 0x80))
	return (UCode_t) **ppuni;	/* ASCII range character */
    else if (!(**ppuni & 0x40))
	return (-1);		/* not a valid UTF-8 start */
    if ((*p & 0xe0) == 0xc0) {
	utf_count = 1;
    } else if ((*p & 0xf0) == 0xe0) {
	utf_count = 2;
    } else if ((*p & 0xf8) == 0xf0) {
	utf_count = 3;
    } else if ((*p & 0xfc) == 0xf8) {
	utf_count = 4;
    } else if ((*p & 0xfe) == 0xfc) {
	utf_count = 5;
    } else {			/* garbage */
	return (-1);
    }
    for (p = *ppuni, i = 0; i < utf_count; i++) {
	if ((*(++p) & 0xc0) != 0x80)
	    return (-1);
    }
    p = *ppuni;
    switch (utf_count) {
    case 1:
	uc_out = (((*p & 0x1f) << 6) |
		  (*(p + 1) & 0x3f));
	break;
    case 2:
	uc_out = (((((*p & 0x0f) << 6) |
		    (*(p + 1) & 0x3f)) << 6) |
		  (*(p + 2) & 0x3f));
	break;
    case 3:
	uc_out = (((((((*p & 0x07) << 6) |
		      (*(p + 1) & 0x3f)) << 6) |
		    (*(p + 2) & 0x3f)) << 6) |
		  (*(p + 3) & 0x3f));
	break;
    case 4:
	uc_out = (((((((((*p & 0x03) << 6) |
			(*(p + 1) & 0x3f)) << 6) |
		      (*(p + 2) & 0x3f)) << 6) |
		    (*(p + 3) & 0x3f)) << 6) |
		  (*(p + 4) & 0x3f));
	break;
    case 5:
	uc_out = (((((((((((*p & 0x01) << 6) |
			  (*(p + 1) & 0x3f)) << 6) |
			(*(p + 2) & 0x3f)) << 6) |
		      (*(p + 3) & 0x3f)) << 6) |
		    (*(p + 4) & 0x3f)) << 6) |
		  (*(p + 5) & 0x3f));
	break;
    }
    *ppuni = p + utf_count;
    return uc_out;
}
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d10 1
a10 2
BOOL UCCanUniTranslateFrom (
	int		from)
d23 1
a23 2
BOOL UCCanTranslateUniTo (
	int		to)
d35 2
a36 3
BOOL UCCanTranslateFromTo (
	int		from,
	int		to)
d47 3
a49 2
	const char * fromname = LYCharSet_UC[from].MIMEname;
	const char * toname = LYCharSet_UC[to].MIMEname;
d52 1
a52 1
	    return YES; /* ??? */
d58 7
a64 8
	    **  CJK mode may be off (i.e., HTCJK == NOCJK) because
	    **  the current document is not CJK, but the check may
	    **  be for capability in relation to another document,
	    **  for which CJK mode might be turned on when retrieved.
	    **  Thus, when the from charset is CJK, check if the to
	    **  charset is CJK, and return NO or YES in relation to
	    **  that. - FM
	    */
d73 3
a75 4
	    **  The euc-cn and euc-kr charsets were handled
	    **  by the (from == to) above, so we need not
	    **  check those. - FM
	    **/
d79 1
a79 1
    return YES;    /* others YES */
d83 5
a87 6
**  Returns YES if no translation necessary (because
**  charsets are equal, are equivalent, etc.).
*/
BOOL UCNeedNotTranslate (
	int		from,
	int		to)
d91 1
d102 1
a102 1
	    return YES;
d127 2
a128 2
	    return YES;	/* translate internally by lynx, no unicode */
	return NO;	/* If not handled by (from == to) above. */
d134 17
a150 19
**  The idea here is that any stage of the stream pipe which is interested
**  in some charset dependent processing will call this function.
**  Given input and output charsets, this function will set various flags
**  in a UCTransParams structure that _suggest_ to the caller what to do.
**
**  Should be called once when a stage starts processing text (and the
**  input and output charsets are known), or whenever one of input or
**  output charsets has changed (e.g., by SGML.c stage after HTML.c stage
**  has processed a META tag).
**  The global flags (LYRawMode, HTPassEightBitRaw etc.) are currently
**  not taken into account here (except for HTCJK, somewhat), it's still
**  up to the caller to do something about them. - KW
*/
void UCSetTransParams (
    UCTransParams *	pT,
    int		cs_in,
    const LYUCcharset*	p_in,
    int		cs_out,
    const LYUCcharset*	p_out)
d153 2
a154 2
	   p_in->MIMEname,  UCGetLYhndl_byMIME(p_in->MIMEname),
	   p_out->MIMEname, UCGetLYhndl_byMIME(p_out->MIMEname)));
d157 3
a159 3
    **  Initialize this element to FALSE, and set it TRUE
    **  below if we're dealing with VISCII. - FM
    */
d163 2
a164 3
    **  The "transparent" display character set is a
    **  "super raw mode". - FM
    */
d166 1
a166 1
		  !strcmp(p_out->MIMEname, "x-transparent"));
d170 2
a171 2
	**  Set up the structure for "transparent". - FM
	*/
d174 1
a174 1
	pT->output_utf8 = FALSE;  /* We may, but won't know about it. - KW */
d181 1
a181 1
			       p_out->enc == UCT_ENC_8BIT_C0);
d184 2
a185 2
	**  Initialize local flags. - FM
	*/
d188 1
d190 2
a191 3
	**  Set this element if we want to treat
	**  the input as CJK. - FM
	*/
d194 2
a195 3
	**  Set these elements based on whether
	**  we are dealing with UTF-8. - FM
	*/
d200 3
a202 3
	    **  Set up the structure for a CJK input with
	    **  a CJK output (HTCJK != NOCJK). - FM
	    */
d208 1
a208 1
	    pT->use_raw_char_in = FALSE; /* Not used for CJK. - KW */
d210 1
a210 1
	    pT->trans_from_uni = FALSE;	 /* Not used for CJK. - KW */
d213 5
a217 6
	    **  Set up for all other charset combinations.
	    **  The intm_ucs flag is set TRUE if the input
	    **  charset is iso-8859-1 or UTF-8, or largely
	    **  equivalent to them, i.e., if we have UCS without
	    **  having to do a table translation.
	    */
d219 2
a220 2
			(p_in->codepoints &
			 (UCT_CP_SUBSETOF_LAT1|UCT_CP_SUBSETOF_UCS2)));
d222 6
a227 6
	    **  pT->trans_to_uni is set TRUE if we do not have that as
	    **  input already, and we can translate to Unicode.  Note
	    **  that UTF-8 always is converted to Unicode in functions
	    **  that use the transformation structure, so it is
	    **  treated as already Unicode here.
	    */
d229 1
a229 1
				UCCanUniTranslateFrom(cs_in));
d231 4
a234 5
	    **  We set this if we are translating to Unicode and
	    **  what normally are low value control characters in
	    **  fact are encoding octets for the input charset
	    **  (presently, this applies to VISCII). - FM
	    */
d236 1
a236 1
				   p_in->enc == UCT_ENC_8BIT_C0);
d238 2
a239 2
	    **  We set this, presently, for VISCII. - FM
	    */
d242 3
a244 3
	    **  Currently unused for any charset combination.
	    **  Should always be FALSE
	    */
d247 3
a249 3
	    **  use_ucs should be set TRUE if we have or will create
	    **  Unicode values for input octets or UTF multibytes. - FM
	    */
d252 5
a256 6
	    **  This is set TRUE if use_ucs was set FALSE.  It is
	    **  complementary to the HTPassEightBitRaw flag, which
	    **  is set TRUE or FALSE elsewhere based on the raw mode
	    **  setting in relation to the current Display Character
	    **  Set. - FM
	    */
d259 3
a261 3
	    **  This is set TRUE when 160 and 173 should not be
	    **  treated as nbsp and shy, respectively. - FM
	    */
d263 1
a263 1
				    !(p_in->like8859 & UCT_R_8859SPECL));
d265 4
a268 4
	    **  This is set when the input and output charsets match,
	    **  and they are not ones which should go through a Unicode
	    **  translation process anyway. - FM
	    */
d270 2
a271 2
				   cs_in == cs_out &&
				   !pT->trans_C0_to_uni);
d273 7
a279 8
	    **  This should be set TRUE when we expect to have
	    **  done translation to Unicode or had the equivalent
	    **  as input, can translate it to our output charset,
	    **  and normally want to do so.  The latter depends on
	    **  the pT->do_8bitraw and pT->use_raw_char_in values set
	    **  above, but also on HTPassEightBitRaw in any functions
	    **  which use the transformation structure.. - FM
	    */
d281 2
a282 2
				  !pT->use_raw_char_in &&
				  UCCanTranslateUniTo(cs_out));
d288 5
a292 6
**  This function initializes the transformation
**  structure by setting all its elements to
**  FALSE. - KW
*/
void UCTransParams_clear (
    UCTransParams *    pT)
d309 12
a320 13
**  If terminal is in UTF-8 mode, it probably cannot understand
**  box drawing chars as (n)curses handles them.  (This may also
**  be true for other display character sets, but isn't currently
**  checked.)  In that case set the chars for hori and vert drawing
**  chars to displayable ASCII chars if '0' was requested.  They'll
**  stay as they are otherwise. - kw
*/
void UCSetBoxChars (
    int	cset,
    int *	pvert_out,
    int *	phori_out,
    int	vert_in,
    int	hori_in)
d335 11
a345 11
**  Given an output target HTStream* (can also be a HTStructured* via
**  typecast), the target stream's put_character method, and a Unicode
**  character,  CPutUtf8_charstring() will either output the UTF8
**  encoding of the Unicode and return YES, or do nothing and return
**  NO (if conversion would be unnecessary or the Unicode character is
**  considered invalid).
**
**  [Could be used more generally, but is currently only used for &#nnnnn
**  stuff - generation of UTF8 from 8-bit encoded charsets not yet done
**  by SGML.c etc.]
*/
d349 1
a349 4
BOOL UCPutUtf8_charstring (
	HTStream *	target,
	putc_func_t *	myPutc,
	long		code)
d353 2
a354 2
    else if   (code < 0x800L) {
	PUTC(0xc0 | (code>>6));
d357 2
a358 2
	PUTC(0xe0 | (code>>12));
	PUTC2(code>>6);
d361 3
a363 3
	PUTC(0xf0 | (code>>18));
	PUTC2(code>>12);
	PUTC2(code>>6);
d366 4
a369 4
	PUTC(0xf8 | (code>>24));
	PUTC2(code>>18);
	PUTC2(code>>12);
	PUTC2(code>>6);
d372 5
a376 5
	PUTC(0xfc | (code>>30));
	PUTC2(code>>24);
	PUTC2(code>>18);
	PUTC2(code>>12);
	PUTC2(code>>6);
d384 9
a392 11
**  This function converts a Unicode (UCode_t) value
**  to a multibyte UTF-8 character, which is loaded
**  into the buffer received as an argument.  The
**  buffer should be large enough to hold at least
**  seven characters (but should be declared as 8
**  to minimize byte alignment problems with some
**  compilers). - FM
*/
BOOL UCConvertUniToUtf8 (
	UCode_t	code,
	char *		buffer)
d405 2
a406 2
	*ch++ = (char)(0xc0 | (code>>6));
	*ch++ = (char)(0x80 | (0x3f & (code)));
d409 3
a411 3
	*ch++ = (char)(0xe0 | (code>>12));
	*ch++ = (char)(0x80 | (0x3f & (code>>6)));
	*ch++ = (char)(0x80 | (0x3f & (code)));
d414 4
a417 4
	*ch++ = (char)(0xf0 | (code>>18));
	*ch++ = (char)(0x80 | (0x3f & (code>>12)));
	*ch++ = (char)(0x80 | (0x3f & (code>>6)));
	*ch++ = (char)(0x80 | (0x3f & (code)));
d420 5
a424 5
	*ch++ = (char)(0xf8 | (code>>24));
	*ch++ = (char)(0x80 | (0x3f & (code>>18)));
	*ch++ = (char)(0x80 | (0x3f & (code>>12)));
	*ch++ = (char)(0x80 | (0x3f & (code>>6)));
	*ch++ = (char)(0x80 | (0x3f & (code)));
d427 6
a432 6
	*ch++ = (char)(0xfc | (code>>30));
	*ch++ = (char)(0x80 | (0x3f & (code>>24)));
	*ch++ = (char)(0x80 | (0x3f & (code>>18)));
	*ch++ = (char)(0x80 | (0x3f & (code>>12)));
	*ch++ = (char)(0x80 | (0x3f & (code>>6)));
	*ch++ = (char)(0x80 | (0x3f & (code)));
d439 11
a449 11
** Get UCS character code for one character from UTF-8 encoded string.
**
** On entry:
**	*ppuni should point to beginning of UTF-8 encoding character
** On exit:
**	*ppuni is advanced to point to the last byte of UTF-8 sequence,
**		if there was a valid one; otherwise unchanged.
** returns the UCS value
** returns negative value on error (invalid UTF-8 sequence)
*/
UCode_t UCGetUniFromUtf8String (char ** ppuni)
d452 1
a452 1
    char * p = *ppuni;
d454 4
a457 3
    if (!(**ppuni&0x80))
	return (UCode_t) **ppuni; /* ASCII range character */
    else if (!(**ppuni&0x40))
d469 1
a469 1
    } else { /* garbage */
d472 1
a472 1
    for (p = *ppuni, i = 0; i < utf_count ; i++) {
d479 2
a480 1
	uc_out = (((*p&0x1f) << 6) | (*(p+1)&0x3f));
d483 3
a485 1
	uc_out = (((((*p&0x0f) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f));
d488 4
a491 2
	uc_out = (((((((*p&0x07) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
	    | (*(p+3)&0x3f));
d494 5
a498 2
	uc_out = (((((((((*p&0x03) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f));
d501 6
a506 2
	uc_out = (((((((((((*p&0x01) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f)) << 6) | (*(p+5)&0x3f));
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d10 2
a11 2
PUBLIC BOOL UCCanUniTranslateFrom ARGS1(
	int,		from)
d24 2
a25 2
PUBLIC BOOL UCCanTranslateUniTo ARGS1(
	int,		to)
d37 3
a39 3
PUBLIC BOOL UCCanTranslateFromTo ARGS2(
	int,		from,
	int,		to)
d50 2
a51 2
	CONST char * fromname = LYCharSet_UC[from].MIMEname;
	CONST char * toname = LYCharSet_UC[to].MIMEname;
d90 3
a92 3
PUBLIC BOOL UCNeedNotTranslate ARGS2(
	int,		from,
	int,		to)
d94 2
a95 2
    CONST char *fromname;
    CONST char *toname;
d151 6
a156 6
PUBLIC void UCSetTransParams ARGS5(
    UCTransParams *,	pT,
    int,		cs_in,
    CONST LYUCcharset*,	p_in,
    int,		cs_out,
    CONST LYUCcharset*,	p_out)
d304 2
a305 2
PUBLIC void UCTransParams_clear ARGS1(
    UCTransParams *,    pT)
d329 6
a334 6
PUBLIC void UCSetBoxChars ARGS5(
    int,	cset,
    int *,	pvert_out,
    int *,	phori_out,
    int,	vert_in,
    int,	hori_in)
d363 4
a366 4
PUBLIC BOOL UCPutUtf8_charstring ARGS3(
	HTStream *,	target,
	putc_func_t *,	myPutc,
	long,		code)
d409 3
a411 3
PUBLIC BOOL UCConvertUniToUtf8 ARGS2(
	UCode_t,	code,
	char *,		buffer)
d468 1
a468 1
PUBLIC UCode_t UCGetUniFromUtf8String ARGS1(char **, ppuni)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d8 1
a8 3

extern HTCJKlang HTCJK;
extern LYUCcharset LYCharSet_UC[];
d152 1
a152 1
    UCTransParams *, 	pT,
d158 1
a158 2
    CTRACE(tfp, "UCSetTransParams: from %s(%d) to %s(%d)\n",
/*	   p_in->MIMEname, p_in->UChndl, p_out->MIMEname, p_out->UChndl); */
d160 1
a160 1
	   p_out->MIMEname, UCGetLYhndl_byMIME(p_out->MIMEname));
d172 1
a172 1
    pT->transp = (!strcmp(p_in->MIMEname, "x-transparent") ||
d186 2
a187 2
	pT->repl_translated_C0 = (p_out->enc == UCT_ENC_8BIT_C0);
	pT->trans_C0_to_uni = (p_in->enc == UCT_ENC_8BIT_C0 ||
d199 1
a199 1
	pT->do_cjk = ((p_in->enc == UCT_ENC_CJK) && (HTCJK != NOCJK));
d204 2
a205 2
	pT->decode_utf8 = (p_in->enc == UCT_ENC_UTF8);
	pT->output_utf8 = (p_out->enc == UCT_ENC_UTF8);
d227 1
a227 1
	    intm_ucs = (cs_in == LATIN1 || pT->decode_utf8 ||
d237 1
a237 1
	    pT->trans_to_uni = (!intm_ucs &&
d245 1
a245 1
	    pT->trans_C0_to_uni = (pT->trans_to_uni &&
d250 1
a250 1
	    pT->repl_translated_C0 = (p_out->enc == UCT_ENC_8BIT_C0);
d260 1
a260 1
	    use_ucs = (intm_ucs || pT->trans_to_uni);
d268 1
a268 1
	    pT->do_8bitraw = (!use_ucs);
d273 1
a273 1
	    pT->pass_160_173_raw = (!use_ucs &&
d280 1
a280 1
	    pT->use_raw_char_in = (!pT->output_utf8 &&
d292 1
a292 1
	    pT->trans_from_uni = (use_ucs && !pT->do_8bitraw &&
d336 1
d340 3
a342 1
    } else {
d455 62
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a7 1
#include <LYCharSets.h>
d9 5
a13 1
BOOL UCCanUniTranslateFrom(int from)
d26 2
a27 1
BOOL UCCanTranslateUniTo(int to)
d39 3
a41 2
BOOL UCCanTranslateFromTo(int from,
			  int to)
d52 2
a53 3
	const char *fromname = LYCharSet_UC[from].MIMEname;
	const char *toname = LYCharSet_UC[to].MIMEname;

d56 1
a56 1
	    return YES;		/* ??? */
d62 8
a69 7
	     * CJK mode may be off (i.e., HTCJK == NOCJK) because the current
	     * document is not CJK, but the check may be for capability in
	     * relation to another document, for which CJK mode might be turned
	     * on when retrieved.  Thus, when the from charset is CJK, check if
	     * the to charset is CJK, and return NO or YES in relation to that. 
	     * - FM
	     */
d78 4
a81 3
	     * The euc-cn and euc-kr charsets were handled by the (from == to)
	     * above, so we need not check those.  - FM
	     */
d85 1
a85 1
    return YES;			/* others YES */
d89 6
a94 5
 *  Returns YES if no translation necessary (because
 *  charsets are equal, are equivalent, etc.).
 */
BOOL UCNeedNotTranslate(int from,
			int to)
d96 2
a97 3
    const char *fromname;
    const char *toname;

d108 1
a108 1
	return YES;
d133 2
a134 2
	    return YES;		/* translate internally by lynx, no unicode */
	return NO;		/* If not handled by (from == to) above. */
d140 19
a158 17
 *  The idea here is that any stage of the stream pipe which is interested
 *  in some charset dependent processing will call this function.
 *  Given input and output charsets, this function will set various flags
 *  in a UCTransParams structure that _suggest_ to the caller what to do.
 *
 *  Should be called once when a stage starts processing text (and the
 *  input and output charsets are known), or whenever one of input or
 *  output charsets has changed (e.g., by SGML.c stage after HTML.c stage
 *  has processed a META tag).
 *  The global flags (LYRawMode, HTPassEightBitRaw etc.) are currently
 *  not taken into account here (except for HTCJK, somewhat), it's still
 *  up to the caller to do something about them. - KW
 */
void UCSetTransParams(UCTransParams * pT, int cs_in,
		      const LYUCcharset *p_in,
		      int cs_out,
		      const LYUCcharset *p_out)
d160 4
a163 3
    CTRACE((tfp, "UCSetTransParams: from %s(%d) to %s(%d)\n",
	    p_in->MIMEname, UCGetLYhndl_byMIME(p_in->MIMEname),
	    p_out->MIMEname, UCGetLYhndl_byMIME(p_out->MIMEname)));
d166 3
a168 3
     * Initialize this element to FALSE, and set it TRUE below if we're dealing
     * with VISCII.  - FM
     */
d172 5
a176 4
     * The "transparent" display character set is a "super raw mode".  - FM
     */
    pT->transp = (BOOL) (!strcmp(p_in->MIMEname, "x-transparent") ||
			 !strcmp(p_out->MIMEname, "x-transparent"));
d180 2
a181 2
	 * Set up the structure for "transparent".  - FM
	 */
d184 1
a184 1
	pT->output_utf8 = FALSE;	/* We may, but won't know about it. - KW */
d189 3
a191 3
	pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
	pT->trans_C0_to_uni = (BOOL) (p_in->enc == UCT_ENC_8BIT_C0 ||
				      p_out->enc == UCT_ENC_8BIT_C0);
d194 2
a195 2
	 * Initialize local flags.  - FM
	 */
a197 1

d199 4
a202 3
	 * Set this element if we want to treat the input as CJK.  - FM
	 */
	pT->do_cjk = (BOOL) ((p_in->enc == UCT_ENC_CJK) && (HTCJK != NOCJK));
d204 5
a208 4
	 * Set these elements based on whether we are dealing with UTF-8.  - FM
	 */
	pT->decode_utf8 = (BOOL) (p_in->enc == UCT_ENC_UTF8);
	pT->output_utf8 = (BOOL) (p_out->enc == UCT_ENC_UTF8);
d211 3
a213 3
	     * Set up the structure for a CJK input with
	     * a CJK output (HTCJK != NOCJK).  - FM
	     */
d219 1
a219 1
	    pT->use_raw_char_in = FALSE;	/* Not used for CJK. - KW */
d221 1
a221 1
	    pT->trans_from_uni = FALSE;		/* Not used for CJK. - KW */
d224 34
a257 32
	     * Set up for all other charset combinations.  The intm_ucs flag is
	     * set TRUE if the input charset is iso-8859-1 or UTF-8, or largely
	     * equivalent to them, i.e., if we have UCS without having to do a
	     * table translation.
	     */
	    intm_ucs = (BOOL) (cs_in == LATIN1 || pT->decode_utf8 ||
			       (p_in->codepoints &
				(UCT_CP_SUBSETOF_LAT1 | UCT_CP_SUBSETOF_UCS2)));
	    /*
	     * pT->trans_to_uni is set TRUE if we do not have that as input
	     * already, and we can translate to Unicode.  Note that UTF-8
	     * always is converted to Unicode in functions that use the
	     * transformation structure, so it is treated as already Unicode
	     * here.
	     */
	    pT->trans_to_uni = (BOOL) (!intm_ucs &&
				       UCCanUniTranslateFrom(cs_in));
	    /*
	     * We set this if we are translating to Unicode and what normally
	     * are low value control characters in fact are encoding octets for
	     * the input charset (presently, this applies to VISCII).  - FM
	     */
	    pT->trans_C0_to_uni = (BOOL) (pT->trans_to_uni &&
					  p_in->enc == UCT_ENC_8BIT_C0);
	    /*
	     * We set this, presently, for VISCII.  - FM
	     */
	    pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
	    /*
	     * Currently unused for any charset combination.
	     * Should always be FALSE
	     */
d260 38
a297 36
	     * use_ucs should be set TRUE if we have or will create Unicode
	     * values for input octets or UTF multibytes.  - FM
	     */
	    use_ucs = (BOOL) (intm_ucs || pT->trans_to_uni);
	    /*
	     * This is set TRUE if use_ucs was set FALSE.  It is complementary
	     * to the HTPassEightBitRaw flag, which is set TRUE or FALSE
	     * elsewhere based on the raw mode setting in relation to the
	     * current Display Character Set.  - FM
	     */
	    pT->do_8bitraw = (BOOL) (!use_ucs);
	    /*
	     * This is set TRUE when 160 and 173 should not be treated as nbsp
	     * and shy, respectively.  - FM
	     */
	    pT->pass_160_173_raw = (BOOL) (!use_ucs &&
					   !(p_in->like8859 & UCT_R_8859SPECL));
	    /*
	     * This is set when the input and output charsets match, and they
	     * are not ones which should go through a Unicode translation
	     * process anyway.  - FM
	     */
	    pT->use_raw_char_in = (BOOL) (!pT->output_utf8 &&
					  cs_in == cs_out &&
					  !pT->trans_C0_to_uni);
	    /*
	     * This should be set TRUE when we expect to have done translation
	     * to Unicode or had the equivalent as input, can translate it to
	     * our output charset, and normally want to do so.  The latter
	     * depends on the pT->do_8bitraw and pT->use_raw_char_in values set
	     * above, but also on HTPassEightBitRaw in any functions which use
	     * the transformation structure..  - FM
	     */
	    pT->trans_from_uni = (BOOL) (use_ucs && !pT->do_8bitraw &&
					 !pT->use_raw_char_in &&
					 UCCanTranslateUniTo(cs_out));
d303 6
a308 5
 *  This function initializes the transformation
 *  structure by setting all its elements to
 *  FALSE. - KW
 */
void UCTransParams_clear(UCTransParams * pT)
d325 13
a337 12
 *  If terminal is in UTF-8 mode, it probably cannot understand
 *  box drawing chars as (n)curses handles them.  (This may also
 *  be true for other display character sets, but isn't currently
 *  checked.)  In that case set the chars for hori and vert drawing
 *  chars to displayable ASCII chars if '0' was requested.  They'll
 *  stay as they are otherwise. - kw
 */
void UCSetBoxChars(int cset,
		   int *pvert_out,
		   int *phori_out,
		   int vert_in,
		   int hori_in)
a338 1
#ifndef WIDEC_CURSES
d342 1
a342 3
    } else
#endif
    {
d349 11
a359 11
 *  Given an output target HTStream* (can also be a HTStructured* via
 *  typecast), the target stream's put_character method, and a Unicode
 *  character,  CPutUtf8_charstring() will either output the UTF8
 *  encoding of the Unicode and return YES, or do nothing and return
 *  NO (if conversion would be unnecessary or the Unicode character is
 *  considered invalid).
 *
 *  [Could be used more generally, but is currently only used for &#nnnnn
 *  stuff - generation of UTF8 from 8-bit encoded charsets not yet done
 *  by SGML.c etc.]
 */
d363 4
a366 1
BOOL UCPutUtf8_charstring(HTStream *target, putc_func_t * myPutc, long code)
d370 2
a371 2
    else if (code < 0x800L) {
	PUTC(0xc0 | (code >> 6));
d374 2
a375 2
	PUTC(0xe0 | (code >> 12));
	PUTC2(code >> 6);
d378 3
a380 3
	PUTC(0xf0 | (code >> 18));
	PUTC2(code >> 12);
	PUTC2(code >> 6);
d383 4
a386 4
	PUTC(0xf8 | (code >> 24));
	PUTC2(code >> 18);
	PUTC2(code >> 12);
	PUTC2(code >> 6);
d389 5
a393 5
	PUTC(0xfc | (code >> 30));
	PUTC2(code >> 24);
	PUTC2(code >> 18);
	PUTC2(code >> 12);
	PUTC2(code >> 6);
d401 11
a411 9
 *  This function converts a Unicode (UCode_t) value
 *  to a multibyte UTF-8 character, which is loaded
 *  into the buffer received as an argument.  The
 *  buffer should be large enough to hold at least
 *  seven characters (but should be declared as 8
 *  to minimize byte alignment problems with some
 *  compilers). - FM
 */
BOOL UCConvertUniToUtf8(UCode_t code, char *buffer)
d424 2
a425 2
	*ch++ = (char) (0xc0 | (code >> 6));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d428 3
a430 3
	*ch++ = (char) (0xe0 | (code >> 12));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d433 4
a436 4
	*ch++ = (char) (0xf0 | (code >> 18));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d439 5
a443 5
	*ch++ = (char) (0xf8 | (code >> 24));
	*ch++ = (char) (0x80 | (0x3f & (code >> 18)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d446 6
a451 6
	*ch++ = (char) (0xfc | (code >> 30));
	*ch++ = (char) (0x80 | (0x3f & (code >> 24)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 18)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
a454 75
}

/*
 * Get UCS character code for one character from UTF-8 encoded string.
 *
 * On entry:
 *	*ppuni should point to beginning of UTF-8 encoding character
 * On exit:
 *	*ppuni is advanced to point to the last byte of UTF-8 sequence,
 *		if there was a valid one; otherwise unchanged.
 * returns the UCS value
 * returns negative value on error (invalid UTF-8 sequence)
 */
UCode_t UCGetUniFromUtf8String(char **ppuni)
{
    UCode_t uc_out = 0;
    char *p = *ppuni;
    int utf_count, i;

    if (!(**ppuni & 0x80))
	return (UCode_t) **ppuni;	/* ASCII range character */
    else if (!(**ppuni & 0x40))
	return (-1);		/* not a valid UTF-8 start */
    if ((*p & 0xe0) == 0xc0) {
	utf_count = 1;
    } else if ((*p & 0xf0) == 0xe0) {
	utf_count = 2;
    } else if ((*p & 0xf8) == 0xf0) {
	utf_count = 3;
    } else if ((*p & 0xfc) == 0xf8) {
	utf_count = 4;
    } else if ((*p & 0xfe) == 0xfc) {
	utf_count = 5;
    } else {			/* garbage */
	return (-1);
    }
    for (p = *ppuni, i = 0; i < utf_count; i++) {
	if ((*(++p) & 0xc0) != 0x80)
	    return (-1);
    }
    p = *ppuni;
    switch (utf_count) {
    case 1:
	uc_out = (((*p & 0x1f) << 6) |
		  (*(p + 1) & 0x3f));
	break;
    case 2:
	uc_out = (((((*p & 0x0f) << 6) |
		    (*(p + 1) & 0x3f)) << 6) |
		  (*(p + 2) & 0x3f));
	break;
    case 3:
	uc_out = (((((((*p & 0x07) << 6) |
		      (*(p + 1) & 0x3f)) << 6) |
		    (*(p + 2) & 0x3f)) << 6) |
		  (*(p + 3) & 0x3f));
	break;
    case 4:
	uc_out = (((((((((*p & 0x03) << 6) |
			(*(p + 1) & 0x3f)) << 6) |
		      (*(p + 2) & 0x3f)) << 6) |
		    (*(p + 3) & 0x3f)) << 6) |
		  (*(p + 4) & 0x3f));
	break;
    case 5:
	uc_out = (((((((((((*p & 0x01) << 6) |
			  (*(p + 1) & 0x3f)) << 6) |
			(*(p + 2) & 0x3f)) << 6) |
		      (*(p + 3) & 0x3f)) << 6) |
		    (*(p + 4) & 0x3f)) << 6) |
		  (*(p + 5) & 0x3f));
	break;
    }
    *ppuni = p + utf_count;
    return uc_out;
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d8 3
a10 1
#include <LYCharSets.h>
d154 1
a154 1
    UCTransParams *,	pT,
d160 2
a161 1
    CTRACE((tfp, "UCSetTransParams: from %s(%d) to %s(%d)\n",
d163 1
a163 1
	   p_out->MIMEname, UCGetLYhndl_byMIME(p_out->MIMEname)));
d175 1
a175 1
    pT->transp = (BOOL) (!strcmp(p_in->MIMEname, "x-transparent") ||
d189 2
a190 2
	pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
	pT->trans_C0_to_uni = (BOOL) (p_in->enc == UCT_ENC_8BIT_C0 ||
d202 1
a202 1
	pT->do_cjk = (BOOL) ((p_in->enc == UCT_ENC_CJK) && (HTCJK != NOCJK));
d207 2
a208 2
	pT->decode_utf8 = (BOOL) (p_in->enc == UCT_ENC_UTF8);
	pT->output_utf8 = (BOOL) (p_out->enc == UCT_ENC_UTF8);
d230 1
a230 1
	    intm_ucs = (BOOL) (cs_in == LATIN1 || pT->decode_utf8 ||
d240 1
a240 1
	    pT->trans_to_uni = (BOOL) (!intm_ucs &&
d248 1
a248 1
	    pT->trans_C0_to_uni = (BOOL) (pT->trans_to_uni &&
d253 1
a253 1
	    pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
d263 1
a263 1
	    use_ucs = (BOOL) (intm_ucs || pT->trans_to_uni);
d271 1
a271 1
	    pT->do_8bitraw = (BOOL) (!use_ucs);
d276 1
a276 1
	    pT->pass_160_173_raw = (BOOL) (!use_ucs &&
d283 1
a283 1
	    pT->use_raw_char_in = (BOOL) (!pT->output_utf8 &&
d295 1
a295 1
	    pT->trans_from_uni = (BOOL) (use_ucs && !pT->do_8bitraw &&
a338 1
#ifndef WIDEC_CURSES
d342 1
a342 3
    } else
#endif
    {
a454 62
}

/*
** Get UCS character code for one character from UTF-8 encoded string.
**
** On entry:
**	*ppuni should point to beginning of UTF-8 encoding character
** On exit:
**	*ppuni is advanced to point to the last byte of UTF-8 sequence,
**		if there was a valid one; otherwise unchanged.
** returns the UCS value
** returns negative value on error (invalid UTF-8 sequence)
*/
PUBLIC UCode_t UCGetUniFromUtf8String ARGS1(char **, ppuni)
{
    UCode_t uc_out = 0;
    char * p = *ppuni;
    int utf_count, i;
    if (!(**ppuni&0x80))
	return (UCode_t) **ppuni; /* ASCII range character */
    else if (!(**ppuni&0x40))
	return (-1);		/* not a valid UTF-8 start */
    if ((*p & 0xe0) == 0xc0) {
	utf_count = 1;
    } else if ((*p & 0xf0) == 0xe0) {
	utf_count = 2;
    } else if ((*p & 0xf8) == 0xf0) {
	utf_count = 3;
    } else if ((*p & 0xfc) == 0xf8) {
	utf_count = 4;
    } else if ((*p & 0xfe) == 0xfc) {
	utf_count = 5;
    } else { /* garbage */
	return (-1);
    }
    for (p = *ppuni, i = 0; i < utf_count ; i++) {
	if ((*(++p) & 0xc0) != 0x80)
	    return (-1);
    }
    p = *ppuni;
    switch (utf_count) {
    case 1:
	uc_out = (((*p&0x1f) << 6) | (*(p+1)&0x3f));
	break;
    case 2:
	uc_out = (((((*p&0x0f) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f));
	break;
    case 3:
	uc_out = (((((((*p&0x07) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
	    | (*(p+3)&0x3f));
	break;
    case 4:
	uc_out = (((((((((*p&0x03) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f));
	break;
    case 5:
	uc_out = (((((((((((*p&0x01) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f)) << 6) | (*(p+5)&0x3f));
	break;
    }
    *ppuni = p + utf_count;
    return uc_out;
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d10 2
a11 2
BOOL UCCanUniTranslateFrom (
	int		from)
d24 2
a25 2
BOOL UCCanTranslateUniTo (
	int		to)
d37 3
a39 3
BOOL UCCanTranslateFromTo (
	int		from,
	int		to)
d50 2
a51 2
	const char * fromname = LYCharSet_UC[from].MIMEname;
	const char * toname = LYCharSet_UC[to].MIMEname;
d90 3
a92 3
BOOL UCNeedNotTranslate (
	int		from,
	int		to)
d94 2
a95 2
    const char *fromname;
    const char *toname;
d151 6
a156 6
void UCSetTransParams (
    UCTransParams *	pT,
    int		cs_in,
    const LYUCcharset*	p_in,
    int		cs_out,
    const LYUCcharset*	p_out)
d304 2
a305 2
void UCTransParams_clear (
    UCTransParams *    pT)
d329 6
a334 6
void UCSetBoxChars (
    int	cset,
    int *	pvert_out,
    int *	phori_out,
    int	vert_in,
    int	hori_in)
d363 4
a366 4
BOOL UCPutUtf8_charstring (
	HTStream *	target,
	putc_func_t *	myPutc,
	long		code)
d409 3
a411 3
BOOL UCConvertUniToUtf8 (
	UCode_t	code,
	char *		buffer)
d468 1
a468 1
UCode_t UCGetUniFromUtf8String (char ** ppuni)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d10 2
a11 1
BOOL UCCanUniTranslateFrom(int from)
d24 2
a25 1
BOOL UCCanTranslateUniTo(int to)
d37 3
a39 2
BOOL UCCanTranslateFromTo(int from,
			  int to)
d50 2
a51 3
	const char *fromname = LYCharSet_UC[from].MIMEname;
	const char *toname = LYCharSet_UC[to].MIMEname;

d54 1
a54 1
	    return YES;		/* ??? */
d60 8
a67 7
	     * CJK mode may be off (i.e., HTCJK == NOCJK) because the current
	     * document is not CJK, but the check may be for capability in
	     * relation to another document, for which CJK mode might be turned
	     * on when retrieved.  Thus, when the from charset is CJK, check if
	     * the to charset is CJK, and return NO or YES in relation to that. 
	     * - FM
	     */
d76 4
a79 3
	     * The euc-cn and euc-kr charsets were handled by the (from == to)
	     * above, so we need not check those.  - FM
	     */
d83 1
a83 1
    return YES;			/* others YES */
d87 6
a92 5
 *  Returns YES if no translation necessary (because
 *  charsets are equal, are equivalent, etc.).
 */
BOOL UCNeedNotTranslate(int from,
			int to)
a95 1

d106 1
a106 1
	return YES;
d131 2
a132 2
	    return YES;		/* translate internally by lynx, no unicode */
	return NO;		/* If not handled by (from == to) above. */
d138 19
a156 17
 *  The idea here is that any stage of the stream pipe which is interested
 *  in some charset dependent processing will call this function.
 *  Given input and output charsets, this function will set various flags
 *  in a UCTransParams structure that _suggest_ to the caller what to do.
 *
 *  Should be called once when a stage starts processing text (and the
 *  input and output charsets are known), or whenever one of input or
 *  output charsets has changed (e.g., by SGML.c stage after HTML.c stage
 *  has processed a META tag).
 *  The global flags (LYRawMode, HTPassEightBitRaw etc.) are currently
 *  not taken into account here (except for HTCJK, somewhat), it's still
 *  up to the caller to do something about them. - KW
 */
void UCSetTransParams(UCTransParams * pT, int cs_in,
		      const LYUCcharset *p_in,
		      int cs_out,
		      const LYUCcharset *p_out)
d159 2
a160 2
	    p_in->MIMEname, UCGetLYhndl_byMIME(p_in->MIMEname),
	    p_out->MIMEname, UCGetLYhndl_byMIME(p_out->MIMEname)));
d163 3
a165 3
     * Initialize this element to FALSE, and set it TRUE below if we're dealing
     * with VISCII.  - FM
     */
d169 3
a171 2
     * The "transparent" display character set is a "super raw mode".  - FM
     */
d173 1
a173 1
			 !strcmp(p_out->MIMEname, "x-transparent"));
d177 2
a178 2
	 * Set up the structure for "transparent".  - FM
	 */
d181 1
a181 1
	pT->output_utf8 = FALSE;	/* We may, but won't know about it. - KW */
d188 1
a188 1
				      p_out->enc == UCT_ENC_8BIT_C0);
d191 2
a192 2
	 * Initialize local flags.  - FM
	 */
a194 1

d196 3
a198 2
	 * Set this element if we want to treat the input as CJK.  - FM
	 */
d201 3
a203 2
	 * Set these elements based on whether we are dealing with UTF-8.  - FM
	 */
d208 3
a210 3
	     * Set up the structure for a CJK input with
	     * a CJK output (HTCJK != NOCJK).  - FM
	     */
d216 1
a216 1
	    pT->use_raw_char_in = FALSE;	/* Not used for CJK. - KW */
d218 1
a218 1
	    pT->trans_from_uni = FALSE;		/* Not used for CJK. - KW */
d221 6
a226 5
	     * Set up for all other charset combinations.  The intm_ucs flag is
	     * set TRUE if the input charset is iso-8859-1 or UTF-8, or largely
	     * equivalent to them, i.e., if we have UCS without having to do a
	     * table translation.
	     */
d228 2
a229 2
			       (p_in->codepoints &
				(UCT_CP_SUBSETOF_LAT1 | UCT_CP_SUBSETOF_UCS2)));
d231 6
a236 6
	     * pT->trans_to_uni is set TRUE if we do not have that as input
	     * already, and we can translate to Unicode.  Note that UTF-8
	     * always is converted to Unicode in functions that use the
	     * transformation structure, so it is treated as already Unicode
	     * here.
	     */
d238 1
a238 1
				       UCCanUniTranslateFrom(cs_in));
d240 5
a244 4
	     * We set this if we are translating to Unicode and what normally
	     * are low value control characters in fact are encoding octets for
	     * the input charset (presently, this applies to VISCII).  - FM
	     */
d246 1
a246 1
					  p_in->enc == UCT_ENC_8BIT_C0);
d248 2
a249 2
	     * We set this, presently, for VISCII.  - FM
	     */
d252 3
a254 3
	     * Currently unused for any charset combination.
	     * Should always be FALSE
	     */
d257 3
a259 3
	     * use_ucs should be set TRUE if we have or will create Unicode
	     * values for input octets or UTF multibytes.  - FM
	     */
d262 6
a267 5
	     * This is set TRUE if use_ucs was set FALSE.  It is complementary
	     * to the HTPassEightBitRaw flag, which is set TRUE or FALSE
	     * elsewhere based on the raw mode setting in relation to the
	     * current Display Character Set.  - FM
	     */
d270 3
a272 3
	     * This is set TRUE when 160 and 173 should not be treated as nbsp
	     * and shy, respectively.  - FM
	     */
d274 1
a274 1
					   !(p_in->like8859 & UCT_R_8859SPECL));
d276 4
a279 4
	     * This is set when the input and output charsets match, and they
	     * are not ones which should go through a Unicode translation
	     * process anyway.  - FM
	     */
d281 2
a282 2
					  cs_in == cs_out &&
					  !pT->trans_C0_to_uni);
d284 8
a291 7
	     * This should be set TRUE when we expect to have done translation
	     * to Unicode or had the equivalent as input, can translate it to
	     * our output charset, and normally want to do so.  The latter
	     * depends on the pT->do_8bitraw and pT->use_raw_char_in values set
	     * above, but also on HTPassEightBitRaw in any functions which use
	     * the transformation structure..  - FM
	     */
d293 2
a294 2
					 !pT->use_raw_char_in &&
					 UCCanTranslateUniTo(cs_out));
d300 6
a305 5
 *  This function initializes the transformation
 *  structure by setting all its elements to
 *  FALSE. - KW
 */
void UCTransParams_clear(UCTransParams * pT)
d322 13
a334 12
 *  If terminal is in UTF-8 mode, it probably cannot understand
 *  box drawing chars as (n)curses handles them.  (This may also
 *  be true for other display character sets, but isn't currently
 *  checked.)  In that case set the chars for hori and vert drawing
 *  chars to displayable ASCII chars if '0' was requested.  They'll
 *  stay as they are otherwise. - kw
 */
void UCSetBoxChars(int cset,
		   int *pvert_out,
		   int *phori_out,
		   int vert_in,
		   int hori_in)
d349 11
a359 11
 *  Given an output target HTStream* (can also be a HTStructured* via
 *  typecast), the target stream's put_character method, and a Unicode
 *  character,  CPutUtf8_charstring() will either output the UTF8
 *  encoding of the Unicode and return YES, or do nothing and return
 *  NO (if conversion would be unnecessary or the Unicode character is
 *  considered invalid).
 *
 *  [Could be used more generally, but is currently only used for &#nnnnn
 *  stuff - generation of UTF8 from 8-bit encoded charsets not yet done
 *  by SGML.c etc.]
 */
d363 4
a366 1
BOOL UCPutUtf8_charstring(HTStream *target, putc_func_t * myPutc, long code)
d370 2
a371 2
    else if (code < 0x800L) {
	PUTC(0xc0 | (code >> 6));
d374 2
a375 2
	PUTC(0xe0 | (code >> 12));
	PUTC2(code >> 6);
d378 3
a380 3
	PUTC(0xf0 | (code >> 18));
	PUTC2(code >> 12);
	PUTC2(code >> 6);
d383 4
a386 4
	PUTC(0xf8 | (code >> 24));
	PUTC2(code >> 18);
	PUTC2(code >> 12);
	PUTC2(code >> 6);
d389 5
a393 5
	PUTC(0xfc | (code >> 30));
	PUTC2(code >> 24);
	PUTC2(code >> 18);
	PUTC2(code >> 12);
	PUTC2(code >> 6);
d401 11
a411 9
 *  This function converts a Unicode (UCode_t) value
 *  to a multibyte UTF-8 character, which is loaded
 *  into the buffer received as an argument.  The
 *  buffer should be large enough to hold at least
 *  seven characters (but should be declared as 8
 *  to minimize byte alignment problems with some
 *  compilers). - FM
 */
BOOL UCConvertUniToUtf8(UCode_t code, char *buffer)
d424 2
a425 2
	*ch++ = (char) (0xc0 | (code >> 6));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d428 3
a430 3
	*ch++ = (char) (0xe0 | (code >> 12));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d433 4
a436 4
	*ch++ = (char) (0xf0 | (code >> 18));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d439 5
a443 5
	*ch++ = (char) (0xf8 | (code >> 24));
	*ch++ = (char) (0x80 | (0x3f & (code >> 18)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d446 6
a451 6
	*ch++ = (char) (0xfc | (code >> 30));
	*ch++ = (char) (0x80 | (0x3f & (code >> 24)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 18)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 12)));
	*ch++ = (char) (0x80 | (0x3f & (code >> 6)));
	*ch++ = (char) (0x80 | (0x3f & (code)));
d458 11
a468 11
 * Get UCS character code for one character from UTF-8 encoded string.
 *
 * On entry:
 *	*ppuni should point to beginning of UTF-8 encoding character
 * On exit:
 *	*ppuni is advanced to point to the last byte of UTF-8 sequence,
 *		if there was a valid one; otherwise unchanged.
 * returns the UCS value
 * returns negative value on error (invalid UTF-8 sequence)
 */
UCode_t UCGetUniFromUtf8String(char **ppuni)
d471 1
a471 1
    char *p = *ppuni;
d473 3
a475 4

    if (!(**ppuni & 0x80))
	return (UCode_t) **ppuni;	/* ASCII range character */
    else if (!(**ppuni & 0x40))
d487 1
a487 1
    } else {			/* garbage */
d490 1
a490 1
    for (p = *ppuni, i = 0; i < utf_count; i++) {
d497 1
a497 2
	uc_out = (((*p & 0x1f) << 6) |
		  (*(p + 1) & 0x3f));
d500 1
a500 3
	uc_out = (((((*p & 0x0f) << 6) |
		    (*(p + 1) & 0x3f)) << 6) |
		  (*(p + 2) & 0x3f));
d503 2
a504 4
	uc_out = (((((((*p & 0x07) << 6) |
		      (*(p + 1) & 0x3f)) << 6) |
		    (*(p + 2) & 0x3f)) << 6) |
		  (*(p + 3) & 0x3f));
d507 2
a508 5
	uc_out = (((((((((*p & 0x03) << 6) |
			(*(p + 1) & 0x3f)) << 6) |
		      (*(p + 2) & 0x3f)) << 6) |
		    (*(p + 3) & 0x3f)) << 6) |
		  (*(p + 4) & 0x3f));
d511 2
a512 6
	uc_out = (((((((((((*p & 0x01) << 6) |
			  (*(p + 1) & 0x3f)) << 6) |
			(*(p + 2) & 0x3f)) << 6) |
		      (*(p + 3) & 0x3f)) << 6) |
		    (*(p + 4) & 0x3f)) << 6) |
		  (*(p + 5) & 0x3f));
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d8 3
a10 1
#include <LYCharSets.h>
d154 1
a154 1
    UCTransParams *,	pT,
d160 2
a161 1
    CTRACE((tfp, "UCSetTransParams: from %s(%d) to %s(%d)\n",
d163 1
a163 1
	   p_out->MIMEname, UCGetLYhndl_byMIME(p_out->MIMEname)));
d175 1
a175 1
    pT->transp = (BOOL) (!strcmp(p_in->MIMEname, "x-transparent") ||
d189 2
a190 2
	pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
	pT->trans_C0_to_uni = (BOOL) (p_in->enc == UCT_ENC_8BIT_C0 ||
d202 1
a202 1
	pT->do_cjk = (BOOL) ((p_in->enc == UCT_ENC_CJK) && (HTCJK != NOCJK));
d207 2
a208 2
	pT->decode_utf8 = (BOOL) (p_in->enc == UCT_ENC_UTF8);
	pT->output_utf8 = (BOOL) (p_out->enc == UCT_ENC_UTF8);
d230 1
a230 1
	    intm_ucs = (BOOL) (cs_in == LATIN1 || pT->decode_utf8 ||
d240 1
a240 1
	    pT->trans_to_uni = (BOOL) (!intm_ucs &&
d248 1
a248 1
	    pT->trans_C0_to_uni = (BOOL) (pT->trans_to_uni &&
d253 1
a253 1
	    pT->repl_translated_C0 = (BOOL) (p_out->enc == UCT_ENC_8BIT_C0);
d263 1
a263 1
	    use_ucs = (BOOL) (intm_ucs || pT->trans_to_uni);
d271 1
a271 1
	    pT->do_8bitraw = (BOOL) (!use_ucs);
d276 1
a276 1
	    pT->pass_160_173_raw = (BOOL) (!use_ucs &&
d283 1
a283 1
	    pT->use_raw_char_in = (BOOL) (!pT->output_utf8 &&
d295 1
a295 1
	    pT->trans_from_uni = (BOOL) (use_ucs && !pT->do_8bitraw &&
a454 62
}

/*
** Get UCS character code for one character from UTF-8 encoded string.
**
** On entry:
**	*ppuni should point to beginning of UTF-8 encoding character
** On exit:
**	*ppuni is advanced to point to the last byte of UTF-8 sequence,
**		if there was a valid one; otherwise unchanged.
** returns the UCS value
** returns negative value on error (invalid UTF-8 sequence)
*/
PUBLIC UCode_t UCGetUniFromUtf8String ARGS1(char **, ppuni)
{
    UCode_t uc_out = 0;
    char * p = *ppuni;
    int utf_count, i;
    if (!(**ppuni&0x80))
	return (UCode_t) **ppuni; /* ASCII range character */
    else if (!(**ppuni&0x40))
	return (-1);		/* not a valid UTF-8 start */
    if ((*p & 0xe0) == 0xc0) {
	utf_count = 1;
    } else if ((*p & 0xf0) == 0xe0) {
	utf_count = 2;
    } else if ((*p & 0xf8) == 0xf0) {
	utf_count = 3;
    } else if ((*p & 0xfc) == 0xf8) {
	utf_count = 4;
    } else if ((*p & 0xfe) == 0xfc) {
	utf_count = 5;
    } else { /* garbage */
	return (-1);
    }
    for (p = *ppuni, i = 0; i < utf_count ; i++) {
	if ((*(++p) & 0xc0) != 0x80)
	    return (-1);
    }
    p = *ppuni;
    switch (utf_count) {
    case 1:
	uc_out = (((*p&0x1f) << 6) | (*(p+1)&0x3f));
	break;
    case 2:
	uc_out = (((((*p&0x0f) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f));
	break;
    case 3:
	uc_out = (((((((*p&0x07) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
	    | (*(p+3)&0x3f));
	break;
    case 4:
	uc_out = (((((((((*p&0x03) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f));
	break;
    case 5:
	uc_out = (((((((((((*p&0x01) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f)) << 6) | (*(p+5)&0x3f));
	break;
    }
    *ppuni = p + utf_count;
    return uc_out;
@

