head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.7.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.46.03;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.20.10.26.30;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.15.18.17.02;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.04.30.16.32.36;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.08.19.49.00;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.25;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.38;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.34;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.27;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.27;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.16;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.40;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.10.24;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.55;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.52.04;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.20.10.10.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/src/LYReadCFG.c,v 1.8 2004/10/20 10:26:30 tg Exp $ */

#ifndef NO_RULES
#include <HTRules.h>
#else
#include <HTUtils.h>
#endif
#include <HTTP.h>		/* 'reloading' flag */
#include <HTFile.h>
#include <HTInit.h>
#include <UCMap.h>

#include <LYUtils.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYStructs.h>
#include <LYGlobalDefs.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYKeymap.h>
#include <LYJump.h>
#include <LYGetFile.h>
#include <LYCgi.h>
#include <LYCurses.h>
#include <LYBookmark.h>
#include <LYCookie.h>
#include <LYReadCFG.h>
#include <HTAlert.h>
#include <LYHistory.h>
#include <LYPrettySrc.h>
#include <LYrcFile.h>

#ifdef DIRED_SUPPORT
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */

#include <LYexit.h>
#include <LYLeaks.h>

#ifndef DISABLE_NEWS
#include <HTNews.h>
#endif

BOOLEAN have_read_cfg = FALSE;
BOOLEAN LYUseNoviceLineTwo = TRUE;

/*
 * Translate a TRUE/FALSE field in a string buffer.
 */
static BOOL is_true(char *string)
{
    if (!strcasecomp(string, "TRUE") || !strcasecomp(string, "ON"))
	return (TRUE);
    else
	return (FALSE);
}

/*
 * Find an unescaped colon in a string buffer.
 */
static char *find_colon(char *buffer)
{
    char ch, *buf = buffer;

    if (buf == NULL)
	return NULL;

    while ((ch = *buf) != 0) {
	if (ch == ':')
	    return buf;
	if (ch == '\\') {
	    buf++;
	    if (*buf == 0)
		break;
	}
	buf++;
    }
    return NULL;
}

static void free_item_list(lynx_list_item_type **ptr)
{
    lynx_list_item_type *cur = *ptr;
    lynx_list_item_type *next;

    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
    }
    *ptr = NULL;
}

/*
 * Function for freeing the DOWNLOADER and UPLOADER menus list.  - FM
 */
static void free_all_item_lists(void)
{
    free_item_list(&printers);
    free_item_list(&downloaders);
#ifdef DIRED_SUPPORT
    free_item_list(&uploaders);
#endif /* DIRED_SUPPORT */

#ifdef USE_EXTERNALS
    free_item_list(&externals);
#endif /* USE_EXTERNALS */

    return;
}

/*
 * Process string buffer fields for DOWNLOADER or UPLOADER menus.
 */
static void add_item_to_list(char *buffer,
			     lynx_list_item_type **list_ptr,
			     int special)
{
    char *colon, *next_colon;
    lynx_list_item_type *cur_item, *prev_item;

    /*
     * Make a linked list
     */
    if (*list_ptr == NULL) {
	/*
	 * First item.
	 */
	cur_item = typecalloc(lynx_list_item_type);

	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");
	*list_ptr = cur_item;
#ifdef LY_FIND_LEAKS
	atexit(free_all_item_lists);
#endif
    } else {
	/*
	 * Find the last item.
	 */
	for (prev_item = *list_ptr;
	     prev_item->next != NULL;
	     prev_item = prev_item->next) ;	/* null body */
	cur_item = typecalloc(lynx_list_item_type);

	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");
	else
	    prev_item->next = cur_item;
    }
    cur_item->next = NULL;
    cur_item->name = NULL;
    cur_item->command = NULL;
    cur_item->always_enabled = FALSE;
    cur_item->override_primary_action = FALSE;
    cur_item->pagelen = 66;

    /*
     * Find first unescaped colon and process fields
     */
    if ((colon = find_colon(buffer)) != NULL) {
	/*
	 * Process name field
	 */
	cur_item->name = typecallocn(char, colon - buffer + 1);

	if (cur_item->name == NULL)
	    outofmem(__FILE__, "read_cfg");
	LYstrncpy(cur_item->name, buffer, (int) (colon - buffer));
	remove_backslashes(cur_item->name);

	/*
	 * Find end of command string and beginning of TRUE/FALSE option field. 
	 * If we do not find a colon that ends the command string, leave the
	 * always_enabled option flag as FALSE.  In any case, we want the
	 * command string.
	 */
	if ((next_colon = find_colon(colon + 1)) == NULL) {
	    next_colon = colon + strlen(colon);
	}
	if (next_colon - (colon + 1) > 0) {
	    cur_item->command = typecallocn(char, next_colon - colon);

	    if (cur_item->command == NULL)
		outofmem(__FILE__, "read_cfg");
	    LYstrncpy(cur_item->command,
		      colon + 1,
		      (int) (next_colon - (colon + 1)));
	    remove_backslashes(cur_item->command);
	}
	if (*next_colon++) {
	    colon = next_colon;
	    if ((next_colon = strchr(colon, ':')) != 0)
		*next_colon++ = '\0';
	    cur_item->always_enabled = is_true(colon);
	    if (next_colon) {
		if (special) {
		    cur_item->pagelen = atoi(next_colon);
		} else {
		    cur_item->override_primary_action = is_true(next_colon);
		}
	    }
	}
    }
}

lynx_list_item_type *find_item_by_number(lynx_list_item_type *list_ptr,
					 char *number)
{
    int value = atoi(number);

    while (value-- >= 0 && list_ptr != 0) {
	list_ptr = list_ptr->next;
    }
    return list_ptr;
}

int match_item_by_name(lynx_list_item_type *ptr, char *name,
		       BOOLEAN only_overriders)
{
    return
	(ptr->command != 0
	 && !strncasecomp(ptr->name, name, strlen(ptr->name))
	 && (only_overriders ? ptr->override_primary_action : 1));
}

#if defined(USE_COLOR_STYLE) || defined(USE_COLOR_TABLE)

#ifndef COLOR_WHITE
#define COLOR_WHITE 7
#endif

#ifndef COLOR_BLACK
#define COLOR_BLACK 0
#endif

#ifdef USE_DEFAULT_COLORS
int default_fg = DEFAULT_COLOR;
int default_bg = DEFAULT_COLOR;

#else
int default_fg = COLOR_WHITE;
int default_bg = COLOR_BLACK;
#endif

static const char *Color_Strings[16] =
{
    "black",
    "red",
    "green",
    "brown",
    "blue",
    "magenta",
    "cyan",
    "lightgray",
    "gray",
    "brightred",
    "brightgreen",
    "yellow",
    "brightblue",
    "brightmagenta",
    "brightcyan",
    "white"
};

#if defined(PDCURSES) && !defined(XCURSES)
/*
 * PDCurses (and possibly some other implementations) use a non-ANSI set of
 * codes for colors.
 */
static int ColorCode(int color)
{
    /* *INDENT-OFF* */
    static int map[] =
    {
	0,  4,  2,  6,  1,  5,  3,  7,
	8, 12, 10, 14,  9, 13, 11, 15
    };
    /* *INDENT-ON* */

    return map[color];
}
#else
#define ColorCode(color) (color)
#endif

BOOL default_color_reset = FALSE;

/*
 * Validator for COLOR fields.
 */
int check_color(char *color,
		int the_default)
{
    int i;

    CTRACE2(TRACE_STYLE, (tfp, "check_color(%s,%d)\n", color, the_default));
    if (!strcasecomp(color, "default")) {
#ifdef USE_DEFAULT_COLORS
	if (!default_color_reset)
	    the_default = DEFAULT_COLOR;
#endif /* USE_DEFAULT_COLORS */
	CTRACE2(TRACE_STYLE, (tfp, "=> default %d\n", the_default));
	return the_default;
    }
    if (!strcasecomp(color, "nocolor"))
	return NO_COLOR;

    for (i = 0; i < 16; i++) {
	if (!strcasecomp(color, Color_Strings[i])) {
	    int c = ColorCode(i);

	    CTRACE2(TRACE_STYLE, (tfp, "=> %d\n", c));
	    return c;
	}
    }
    CTRACE2(TRACE_STYLE, (tfp, "=> ERR_COLOR\n"));
    return ERR_COLOR;
}

const char *lookup_color(int code)
{
    unsigned n;

    for (n = 0; n < 16; n++) {
	if ((int) ColorCode(n) == code)
	    return Color_Strings[n];
    }
    return "default";
}
#endif /* USE_COLOR_STYLE || USE_COLOR_TABLE */

#if defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR)

/*
 * Exit routine for failed COLOR parsing.
 */
static void exit_with_color_syntax(char *error_line)
{
    unsigned int i;

    fprintf(stderr, gettext("\
Syntax Error parsing COLOR in configuration file:\n\
The line must be of the form:\n\
COLOR:INTEGER:FOREGROUND:BACKGROUND\n\
\n\
Here FOREGROUND and BACKGROUND must be one of:\n\
The special strings 'nocolor' or 'default', or\n")
	);
    for (i = 0; i < 16; i += 4) {
	fprintf(stderr, "%16s %16s %16s %16s\n",
		Color_Strings[i], Color_Strings[i + 1],
		Color_Strings[i + 2], Color_Strings[i + 3]);
    }
    fprintf(stderr, "%s\n%s\n", gettext("Offending line:"), error_line);
    exit_immediately(EXIT_FAILURE);
}
#endif /* defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR) */

#if defined(USE_COLOR_TABLE)
/*
 * Process string buffer fields for COLOR setting.
 */
static void parse_color(char *buffer)
{
    int color;
    char *fg, *bg;
    char *temp = 0;

    StrAllocCopy(temp, buffer);	/* save a copy, for error messages */

    /*
     * We are expecting a line of the form:
     *    INTEGER:FOREGROUND:BACKGROUND
     */
    color = atoi(buffer);
    if (NULL == (fg = find_colon(buffer)))
	exit_with_color_syntax(temp);
    *fg++ = '\0';

    if (NULL == (bg = find_colon(fg)))
	exit_with_color_syntax(temp);
    *bg++ = '\0';

#if defined(USE_SLANG)
    if ((check_color(fg, default_fg) == ERR_COLOR) ||
	(check_color(bg, default_bg) == ERR_COLOR))
	exit_with_color_syntax(temp);

    SLtt_set_color(color, NULL, fg, bg);
#else
    if (lynx_chg_color(color,
		       check_color(fg, default_fg),
		       check_color(bg, default_bg)) < 0)
	exit_with_color_syntax(temp);
#endif
    FREE(temp);
}
#endif /* USE_COLOR_TABLE */
/* *INDENT-OFF* */
#ifdef USE_SOURCE_CACHE
static Config_Enum tbl_source_cache[] = {
    { "FILE",	SOURCE_CACHE_FILE },
    { "MEMORY",	SOURCE_CACHE_MEMORY },
    { "NONE",	SOURCE_CACHE_NONE },
    { NULL,		-1 },
};

static Config_Enum tbl_abort_source_cache[] = {
    { "KEEP",	SOURCE_CACHE_FOR_ABORTED_KEEP },
    { "DROP",	SOURCE_CACHE_FOR_ABORTED_DROP },
    { NULL,		-1 },
};
#endif
/* *INDENT-ON* */

#define PARSE_ADD(n,v)   {n, CONF_ADD_ITEM,    UNION_ADD(v), 0}
#define PARSE_SET(n,v)   {n, CONF_BOOL,        UNION_SET(v), 0}
#define PARSE_ENU(n,v,t) {n, CONF_ENUM,        UNION_INT(v), t}
#define PARSE_INT(n,v)   {n, CONF_INT,         UNION_INT(v), 0}
#define PARSE_TIM(n,v)   {n, CONF_TIME,        UNION_INT(v), 0}
#define PARSE_STR(n,v)   {n, CONF_STR,         UNION_STR(v), 0}
#define PARSE_PRG(n,v)   {n, CONF_PRG,         UNION_DEF(v), 0}
#define PARSE_Env(n,v)   {n, CONF_ENV,         UNION_ENV(v), 0}
#define PARSE_ENV(n,v)   {n, CONF_ENV2,        UNION_ENV(v), 0}
#define PARSE_FUN(n,v)   {n, CONF_FUN,         UNION_FUN(v), 0}
#define PARSE_REQ(n,v)   {n, CONF_INCLUDE,     UNION_FUN(v), 0}
#define PARSE_DEF(n,v)   {n, CONF_ADD_TRUSTED, UNION_DEF(v), 0}
#define PARSE_NIL        {NULL, CONF_NIL,      UNION_DEF(0), 0}

typedef enum {
    CONF_NIL = 0
    ,CONF_BOOL			/* BOOLEAN type */
    ,CONF_FUN
    ,CONF_TIME
    ,CONF_ENUM
    ,CONF_INT
    ,CONF_STR
    ,CONF_PRG
    ,CONF_ENV			/* from environment variable */
    ,CONF_ENV2			/* from environment VARIABLE */
    ,CONF_INCLUDE		/* include file-- handle special */
    ,CONF_ADD_ITEM
    ,CONF_ADD_TRUSTED
} Conf_Types;

typedef struct {
    const char *name;
    Conf_Types type;
      ParseData;
    Config_Enum *table;
} Config_Type;

static int assume_charset_fun(char *value)
{
    UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(value);
    StrAllocCopy(UCAssume_MIMEcharset,
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
/*    this may be a memory for bogus typo -
    StrAllocCopy(UCAssume_MIMEcharset, value);
    LYLowerCase(UCAssume_MIMEcharset);    */

    return 0;
}

static int assume_local_charset_fun(char *value)
{
    UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(value);
    return 0;
}

static int assume_unrec_charset_fun(char *value)
{
    UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(value);
    return 0;
}

static int character_set_fun(char *value)
{
    int i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */

    if (i < 0) {
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
	if (auto_display_charset >= 0
	    && (!strnicmp(value, "AutoDetect ", 11)
		|| !strnicmp(value, "AutoDetect-2 ", 13)))
	    current_char_set = auto_display_charset;
#endif
	/* do nothing here: so fallback to userdefs.h */
    } else
	current_char_set = i;

    return 0;
}

static int outgoing_mail_charset_fun(char *value)
{
    outgoing_mail_charset = UCGetLYhndl_byMIME(value);
    /* -1 if NULL or not recognized value: no translation (compatibility) */

    return 0;
}

#ifdef EXP_ASSUMED_COLOR
/*
 * Process string buffer fields for ASSUMED_COLOR setting.
 */
static int assumed_color_fun(char *buffer)
{
    char *fg = buffer, *bg;
    char *temp = 0;

    StrAllocCopy(temp, buffer);	/* save a copy, for error messages */

    /*
     * We are expecting a line of the form:
     *    FOREGROUND:BACKGROUND
     */
    if (NULL == (bg = find_colon(fg)))
	exit_with_color_syntax(temp);
    *bg++ = '\0';

    default_fg = check_color(fg, default_fg);
    default_bg = check_color(bg, default_bg);

    if (default_fg == ERR_COLOR
	|| default_bg == ERR_COLOR)
	exit_with_color_syntax(temp);
#ifdef USE_SLANG
    /*
     * Sorry - the order of initialization of slang precludes setting the
     * default colors from the lynx.cfg file, since slang is already
     * initialized before the file is read, and there is no interface defined
     * for setting it from the application (that's one of the problems with
     * using environment variables rather than a programmable interface) -TD
     */
#endif
    FREE(temp);
    return 0;
}
#endif /* EXP_ASSUMED_COLOR */

#ifdef USE_COLOR_TABLE
static int color_fun(char *value)
{
    parse_color(value);
    return 0;
}
#endif

static int default_bookmark_file_fun(char *value)
{
    set_default_bookmark_page(value);
    return 0;
}

static int default_cache_size_fun(char *value)
{
    HTCacheSize = atoi(value);
    if (HTCacheSize < 2)
	HTCacheSize = 2;
    return 0;
}

static int default_editor_fun(char *value)
{
    if (!system_editor)
	StrAllocCopy(editor, value);
    return 0;
}

static int numbers_as_arrows_fun(char *value)
{
    if (is_true(value))
	keypad_mode = NUMBERS_AS_ARROWS;
    else
	keypad_mode = LINKS_ARE_NUMBERED;

    return 0;
}

#ifdef DIRED_SUPPORT
static int dired_menu_fun(char *value)
{
    add_menu_item(value);
    return 0;
}
#endif

static int jumpfile_fun(char *value)
{
    char *buffer = NULL;

    HTSprintf0(&buffer, "JUMPFILE:%s", value);
    if (!LYJumpInit(buffer))
	CTRACE((tfp, "Failed to register %s\n", buffer));
    FREE(buffer);

    return 0;
}

#ifdef EXP_KEYBOARD_LAYOUT
static int keyboard_layout_fun(char *key)
{
    if (!LYSetKbLayout(key))
	CTRACE((tfp, "Failed to set keyboard layout %s\n", key));
    return 0;
}
#endif /* EXP_KEYBOARD_LAYOUT */

static int keymap_fun(char *key)
{
    char *func, *efunc;

    if ((func = strchr(key, ':')) != NULL) {
	*func++ = '\0';
	efunc = strchr(func, ':');
	/* Allow comments on the ends of key remapping lines. - DT */
	/* Allow third field for line-editor action. - kw */
	if (efunc == func) {	/* have 3rd field, but 2nd field empty */
	    func = NULL;
	} else if (efunc && strncasecomp(efunc + 1, "DIRED", 5) == 0) {
	    if (!remap(key, strtok(func, " \t\n:#"), TRUE)) {
		fprintf(stderr,
			gettext("key remapping of %s to %s for %s failed\n"),
			key, func, efunc + 1);
	    } else if (func && !strcmp("TOGGLE_HELP", func)) {
		LYUseNoviceLineTwo = FALSE;
	    }
	    return 0;
	} else if (!remap(key, strtok(func, " \t\n:#"), FALSE)) {
	    fprintf(stderr, gettext("key remapping of %s to %s failed\n"),
		    key, func);
	} else {
	    if (func && !strcmp("TOGGLE_HELP", func))
		LYUseNoviceLineTwo = FALSE;
	}
	if (efunc) {
	    efunc++;
	    if (efunc == strtok((func ? NULL : efunc), " \t\n:#") && *efunc) {
		BOOLEAN success = FALSE;
		int lkc = lkcstring_to_lkc(key);
		int lec = -1;
		int select_edi = 0;
		char *sselect_edi = strtok(NULL, " \t\n:#");
		char **endp = &sselect_edi;

		if (sselect_edi) {
		    if (*sselect_edi)
			select_edi = strtol(sselect_edi, endp, 10);
		    if (**endp != '\0') {
			fprintf(stderr,
				gettext("invalid line-editor selection %s for key %s, selecting all\n"),
				sselect_edi, key);
			select_edi = 0;
		    }
		}
		/*
		 * PASS!  tries to enter the key into the LYLineEditors
		 * bindings in a different way from PASS, namely as binding
		 * that maps to the specific lynx actioncode (rather than to
		 * LYE_FORM_PASS).  That only works for lynx keycodes with
		 * modifier bit set, and we have no documented/official way to
		 * specify this in the KEYMAP directive, although it can be
		 * made to work e.g. by specifying a hex value that has the
		 * modifier bit set.  But knowledge about the bit pattern of
		 * modifiers should remain in internal matter subject to
		 * change...  At any rate, if PASS!  fails try it the same way
		 * as for PASS.  - kw
		 */
		if (!success && strcasecomp(efunc, "PASS!") == 0) {
		    if (func) {
			lec = LYE_FORM_LAC | lacname_to_lac(func);
			success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		    }
		    if (!success)
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    else
			return 0;
		}
		if (!success) {
		    lec = lecname_to_lec(efunc);
		    success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		}
		if (!success) {
		    if (lec != -1) {
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    } else {
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) for %s failed\n"),
				key, lkc, efunc);
		    }
		}
	    }
	}
    }
    return 0;
}

static int localhost_alias_fun(char *value)
{
    LYAddLocalhostAlias(value);
    return 0;
}

#ifdef LYNXCGI_LINKS
static int lynxcgi_environment_fun(char *value)
{
    add_lynxcgi_environment(value);
    return 0;
}
#endif

static int lynx_sig_file_fun(char *value)
{
    char temp[LY_MAXPATH];

    LYstrncpy(temp, value, sizeof(temp) - 1);
    if (LYPathOffHomeOK(temp, sizeof(temp))) {
	StrAllocCopy(LynxSigFile, temp);
	LYAddPathToHome(temp, sizeof(temp), LynxSigFile);
	StrAllocCopy(LynxSigFile, temp);
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
    } else {
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
    }
    return 0;
}

#ifndef DISABLE_NEWS
static int news_chunk_size_fun(char *value)
{
    HTNewsChunkSize = atoi(value);
    /*
     * If the new HTNewsChunkSize exceeds the maximum,
     * increase HTNewsMaxChunk to this size. - FM
     */
    if (HTNewsChunkSize > HTNewsMaxChunk)
	HTNewsMaxChunk = HTNewsChunkSize;
    return 0;
}

static int news_max_chunk_fun(char *value)
{
    HTNewsMaxChunk = atoi(value);
    /*
     * If HTNewsChunkSize exceeds the new maximum,
     * reduce HTNewsChunkSize to this maximum. - FM
     */
    if (HTNewsChunkSize > HTNewsMaxChunk)
	HTNewsChunkSize = HTNewsMaxChunk;
    return 0;
}

static int news_posting_fun(char *value)
{
    LYNewsPosting = is_true(value);
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
    return 0;
}
#endif /* DISABLE_NEWS */

#ifndef NO_RULES
static int cern_rulesfile_fun(char *value)
{
    char *rulesfile1 = NULL;
    char *rulesfile2 = NULL;

    if (HTLoadRules(value) >= 0) {
	return 0;
    }
    StrAllocCopy(rulesfile1, value);
    LYTrimLeading(value);
    LYTrimTrailing(value);
    if (!strncmp(value, "~/", 2)) {
	StrAllocCopy(rulesfile2, Home_Dir());
	StrAllocCat(rulesfile2, value + 1);
    } else {
	StrAllocCopy(rulesfile2, value);
    }
    if (strcmp(rulesfile1, rulesfile2) &&
	HTLoadRules(rulesfile2) >= 0) {
	FREE(rulesfile1);
	FREE(rulesfile2);
	return 0;
    }
    fprintf(stderr,
	    gettext("Lynx: cannot start, CERN rules file %s is not available\n"),
	    non_empty(rulesfile2) ? rulesfile2 : gettext("(no name)"));
    exit_immediately(EXIT_FAILURE);
    return 0;			/* though redundant, for compiler-warnings */
}
#endif /* NO_RULES */

static int printer_fun(char *value)
{
    add_item_to_list(value, &printers, TRUE);
    return 0;
}

static int referer_with_query_fun(char *value)
{
    if (!strncasecomp(value, "SEND", 4))
	LYRefererWithQuery = 'S';
    else if (!strncasecomp(value, "PARTIAL", 7))
	LYRefererWithQuery = 'P';
    else
	LYRefererWithQuery = 'D';
    return 0;
}

static int suffix_fun(char *value)
{
    char *mime_type, *p;
    char *encoding = NULL;
    char *sq = NULL;
    char *description = NULL;
    double q = 1.0;

    if ((strlen(value) < 3)
	|| (NULL == (mime_type = strchr(value, ':')))) {
	CTRACE((tfp, "Invalid SUFFIX:%s ignored.\n", value));
	return 0;
    }

    *mime_type++ = '\0';
    if (*mime_type) {
	if ((encoding = strchr(mime_type, ':')) != NULL) {
	    *encoding++ = '\0';
	    if ((sq = strchr(encoding, ':')) != NULL) {
		*sq++ = '\0';
		if ((description = strchr(sq, ':')) != NULL) {
		    *description++ = '\0';
		    if ((p = strchr(sq, ':')) != NULL)
			*p = '\0';
		    LYTrimTail(description);
		}
		LYRemoveBlanks(sq);
		if (!*sq)
		    sq = NULL;
	    }
	    LYRemoveBlanks(encoding);
	    LYLowerCase(encoding);
	    if (!*encoding)
		encoding = NULL;
	}
    }

    LYRemoveBlanks(mime_type);
    /*
     * mime-type is not converted to lowercase on input, to make it possible to
     * reproduce the equivalent of some of the HTInit.c defaults that use mixed
     * case, although that is not recomended.  - kw
     */
    if (!*mime_type) {		/* that's ok now, with an encoding!  */
	CTRACE((tfp, "SUFFIX:%s without MIME type for %s\n", value,
		encoding ? encoding : "what?"));
	mime_type = NULL;	/* that's ok now, with an encoding!  */
	if (!encoding)
	    return 0;
    }

    if (!encoding) {
	if (strstr(mime_type, "tex") != NULL ||
	    strstr(mime_type, "postscript") != NULL ||
	    strstr(mime_type, "sh") != NULL ||
	    strstr(mime_type, "troff") != NULL ||
	    strstr(mime_type, "rtf") != NULL)
	    encoding = "8bit";
	else
	    encoding = "binary";
    }
    if (!sq) {
	q = 1.0;
    } else {
	double df = strtod(sq, &p);

	if (p == sq && df == 0.0) {
	    CTRACE((tfp, "Invalid q=%s for SUFFIX:%s, using -1.0\n",
		    sq, value));
	    q = -1.0;
	} else {
	    q = df;
	}
    }
    HTSetSuffix5(value, mime_type, encoding, description, q);

    return 0;
}

static int suffix_order_fun(char *value)
{
    char *p = value;
    char *optn;
    BOOLEAN want_file_init_now = FALSE;

    LYUseBuiltinSuffixes = TRUE;
    while ((optn = HTNextTok(&p, ", ", "", NULL)) != NULL) {
	if (!strcasecomp(optn, "NO_BUILTIN")) {
	    LYUseBuiltinSuffixes = FALSE;
	} else if (!strcasecomp(optn, "PRECEDENCE_HERE")) {
	    want_file_init_now = TRUE;
	} else if (!strcasecomp(optn, "PRECEDENCE_OTHER")) {
	    want_file_init_now = FALSE;
	} else {
	    CTRACE((tfp, "Invalid SUFFIX_ORDER:%s\n", optn));
	    break;
	}
    }

    if (want_file_init_now && !FileInitAlreadyDone) {
	HTFileInit();
	FileInitAlreadyDone = TRUE;
    }
    return 0;
}

static int system_editor_fun(char *value)
{
    StrAllocCopy(editor, value);
    system_editor = TRUE;
    return 0;
}

#define SetViewer(mime_type, viewer) \
    HTSetPresentation(mime_type, viewer, 0, 1.0, 3.0, 0.0, 0, mediaCFG)

static int viewer_fun(char *value)
{
    char *mime_type;
    char *viewer;
    char *environment;

    mime_type = value;

    if ((strlen(value) < 3)
	|| (NULL == (viewer = strchr(mime_type, ':'))))
	return 0;

    *viewer++ = '\0';

    LYRemoveBlanks(mime_type);
    LYLowerCase(mime_type);

    environment = strrchr(viewer, ':');
    if ((environment != NULL) &&
	(strlen(viewer) > 1) && *(environment - 1) != '\\') {
	*environment++ = '\0';
	remove_backslashes(viewer);
	/*
	 * If environment equals xwindows then only assign the presentation if
	 * there is a $DISPLAY variable.
	 */
	if (!strcasecomp(environment, "XWINDOWS")) {
	    if (LYgetXDisplay() != NULL)
		SetViewer(mime_type, viewer);
	} else if (!strcasecomp(environment, "NON_XWINDOWS")) {
	    if (LYgetXDisplay() == NULL)
		SetViewer(mime_type, viewer);
	} else {
	    SetViewer(mime_type, viewer);
	}
    } else {
	remove_backslashes(viewer);
	SetViewer(mime_type, viewer);
    }

    return 0;
}

static int nonrest_sigwinch_fun(char *value)
{
    if (!strncasecomp(value, "XWINDOWS", 8)) {
	LYNonRestartingSIGWINCH = (BOOL) (LYgetXDisplay() != NULL);
    } else {
	LYNonRestartingSIGWINCH = is_true(value);
    }
    return 0;
}

#ifdef EXP_CHARSET_CHOICE
static void matched_charset_choice(BOOL display_charset,
				   int i)
{
    int j;

    if (display_charset && !custom_display_charset) {
	for (custom_display_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_display = TRUE;
    } else if (!display_charset && !custom_assumed_doc_charset) {
	for (custom_assumed_doc_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_assumed = TRUE;
    }
    if (display_charset)
	charset_subsets[i].hide_display = FALSE;
    else
	charset_subsets[i].hide_assumed = FALSE;
}

static int parse_charset_choice(char *p,
				BOOL display_charset)	/*if FALSE, then assumed doc charset */
{
    int len, i;
    int matches = 0;

    /*only one charset choice is allowed per line! */
    LYTrimHead(p);
    LYTrimTail(p);
    CTRACE((tfp, "parsing charset choice for %s:\"%s\"",
	    (display_charset ? "display charset" : "assumed doc charset"), p));
    len = strlen(p);
    if (!len) {
	CTRACE((tfp, " - EMPTY STRING\n"));
	return 1;
    }
    if (*p == '*' && len == 1) {
	if (display_charset)
	    for (custom_display_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_display = FALSE;
	else
	    for (custom_assumed_doc_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_assumed = FALSE;
	CTRACE((tfp, " - all unhidden\n"));
	return 0;
    }
    if (p[len - 1] == '*') {
	--len;
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strncasecomp(p, LYchar_set_names[i], len)) ||
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len))) {
		++matches;
		matched_charset_choice(display_charset, i);
	    }
	}
	CTRACE((tfp, " - %d matches\n", matches));
	return 0;
    } else {
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strcasecomp(p, LYchar_set_names[i])) ||
		(!strcasecomp(p, LYCharSet_UC[i].MIMEname))) {
		matched_charset_choice(display_charset, i);
		CTRACE((tfp, " - OK\n"));
		++matches;
		return 0;
	    }
	}
	CTRACE((tfp, " - NOT recognised\n"));
	return 1;
    }
}

static int parse_display_charset_choice(char *p)
{
    return parse_charset_choice(p, 1);
}

static int parse_assumed_doc_charset_choice(char *p)
{
    return parse_charset_choice(p, 0);
}

#endif /* EXP_CHARSET_CHOICE */

#ifdef USE_PRETTYSRC
static void html_src_bad_syntax(char *value,
				char *option_name)
{
    char *buf = 0;

    HTSprintf0(&buf, "HTMLSRC_%s", option_name);
    LYUpperCase(buf);
    fprintf(stderr, "Bad syntax in TAGSPEC %s:%s\n", buf, value);
    exit_immediately(EXIT_FAILURE);
}

static int parse_html_src_spec(HTlexeme lexeme_code, char *value,
			       char *option_name)
{
    /* Now checking the value for being correct.  Since HTML_dtd is not
     * initialized completely (member tags points to non-initiailized data), we
     * use tags_old.  If the syntax is incorrect, then lynx will exit with error
     * message.
     */
    char *ts2;

    if (isEmpty(value))
	return 0;		/* silently ignoring */

#define BS() html_src_bad_syntax(value,option_name)

    ts2 = strchr(value, ':');
    if (!ts2)
	BS();
    *ts2 = '\0';

    CTRACE((tfp, "ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",
	    value, ts2, option_name));
    html_src_clean_item(lexeme_code);
    if (html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE)) {
	*ts2 = ':';
	BS();
    }

    *ts2 = ':';
    StrAllocCopy(HTL_tagspecs[lexeme_code], value);
#undef BS
    return 0;
}

static int psrcspec_fun(char *s)
{
    char *e;
    /* *INDENT-OFF* */
    static Config_Enum lexemnames[] =
    {
	{ "comm",	HTL_comm	},
	{ "tag",	HTL_tag		},
	{ "attrib",	HTL_attrib	},
	{ "attrval",	HTL_attrval	},
	{ "abracket",	HTL_abracket	},
	{ "entity",	HTL_entity	},
	{ "href",	HTL_href	},
	{ "entire",	HTL_entire	},
	{ "badseq",	HTL_badseq	},
	{ "badtag",	HTL_badtag	},
	{ "badattr",	HTL_badattr	},
	{ "sgmlspecial", HTL_sgmlspecial },
	{ NULL,		-1		}
    };
    /* *INDENT-ON* */

    int found;

    e = strchr(s, ':');
    if (!e) {
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",
		s));
	return 0;
    }
    *e = '\0';
    if (!LYgetEnum(lexemnames, s, &found)) {
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",
		s, e + 1));
	return 0;
    }
    parse_html_src_spec((HTlexeme) found, e + 1, s);
    return 0;
}

static int read_htmlsrc_attrname_xform(char *str)
{
    int val;

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
	} else
	    attrname_transform = val;
    } else {
	CTRACE((tfp, "bad value for htmlsrc_attrname_xform (ignored): %s\n",
		str));
    }
    return 0;
}

static int read_htmlsrc_tagname_xform(char *str)
{
    int val;

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
	} else
	    tagname_transform = val;
    } else {
	CTRACE((tfp, "bad value for htmlsrc_tagname_xform (ignored): %s\n",
		str));
    }
    return 0;
}
#endif

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
static int screen_size_fun(char *value)
{
    char *cp;

    if ((cp = strchr(value, ',')) != 0) {
	*cp++ = '\0';		/* Terminate ID */
	scrsize_x = atoi(value);
	scrsize_y = atoi(cp);
	if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
	    scrsize_x = scrsize_y = 0;
	}
	if ((scrsize_x > 0) && (scrsize_x < 80)) {
	    scrsize_x = 80;
	}
	if ((scrsize_y > 0) && (scrsize_y < 4)) {
	    scrsize_y = 4;
	}
	CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
    }
    return 0;
}
#endif

/* This table is searched ignoring case */
/* *INDENT-OFF* */
static Config_Type Config_Table [] =
{
     PARSE_SET(RC_ACCEPT_ALL_COOKIES,   LYAcceptAllCookies),
     PARSE_TIM(RC_ALERTSECS,            AlertSecs),
     PARSE_SET(RC_ALWAYS_RESUBMIT_POSTS, LYresubmit_posts),
#ifdef EXEC_LINKS
     PARSE_DEF(RC_ALWAYS_TRUSTED_EXEC,  ALWAYS_EXEC_PATH),
#endif
     PARSE_FUN(RC_ASSUME_CHARSET,       assume_charset_fun),
     PARSE_FUN(RC_ASSUME_LOCAL_CHARSET, assume_local_charset_fun),
     PARSE_FUN(RC_ASSUME_UNREC_CHARSET, assume_unrec_charset_fun),
#ifdef EXP_ASSUMED_COLOR
     PARSE_FUN(RC_ASSUMED_COLOR,        assumed_color_fun),
#endif
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN(RC_ASSUMED_DOC_CHARSET_CHOICE, parse_assumed_doc_charset_choice),
#endif
#ifdef DIRED_SUPPORT
     PARSE_INT(RC_AUTO_UNCACHE_DIRLISTS, LYAutoUncacheDirLists),
#endif
#ifndef DISABLE_BIBP
     PARSE_STR(RC_BIBP_BIBHOST,         BibP_bibhost),
     PARSE_STR(RC_BIBP_GLOBALSERVER,    BibP_globalserver),
#endif
     PARSE_SET(RC_BLOCK_MULTI_BOOKMARKS, LYMBMBlocked),
     PARSE_SET(RC_BOLD_H1,              bold_H1),
     PARSE_SET(RC_BOLD_HEADERS,         bold_headers),
     PARSE_SET(RC_BOLD_NAME_ANCHORS,    bold_name_anchors),
     PARSE_PRG(RC_BZIP2_PATH,           ppBZIP2),
     PARSE_SET(RC_CASE_SENSITIVE_ALWAYS_ON, case_sensitive),
     PARSE_FUN(RC_CHARACTER_SET,        character_set_fun),
#ifdef CAN_SWITCH_DISPLAY_CHARSET
     PARSE_STR(RC_CHARSET_SWITCH_RULES, charset_switch_rules),
     PARSE_STR(RC_CHARSETS_DIRECTORY,   charsets_directory),
#endif
     PARSE_SET(RC_CHECKMAIL,            check_mail),
     PARSE_PRG(RC_CHMOD_PATH,           ppCHMOD),
     PARSE_SET(RC_COLLAPSE_BR_TAGS,     LYCollapseBRs),
#ifdef USE_COLOR_TABLE
     PARSE_FUN(RC_COLOR,                color_fun),
#endif
     PARSE_PRG(RC_COMPRESS_PATH,        ppCOMPRESS),
     PARSE_PRG(RC_COPY_PATH,            ppCOPY),
     PARSE_INT(RC_CONNECT_TIMEOUT,      connect_timeout),
     PARSE_STR(RC_COOKIE_ACCEPT_DOMAINS, LYCookieSAcceptDomains),
#ifdef USE_PERSISTENT_COOKIES
     PARSE_STR(RC_COOKIE_FILE,          LYCookieFile),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieSLooseCheckDomains),
     PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieSQueryCheckDomains),
     PARSE_STR(RC_COOKIE_REJECT_DOMAINS, LYCookieSRejectDomains),
#ifdef USE_PERSISTENT_COOKIES
     PARSE_STR(RC_COOKIE_SAVE_FILE,     LYCookieSaveFile),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieSStrictCheckDomains),
     PARSE_Env(RC_CSO_PROXY,		0),
#ifdef VMS
     PARSE_PRG(RC_CSWING_PATH,          ppCSWING),
#endif
     PARSE_TIM(RC_DELAYSECS,            DebugSecs),
     PARSE_FUN(RC_DEFAULT_BOOKMARK_FILE, default_bookmark_file_fun),
     PARSE_FUN(RC_DEFAULT_CACHE_SIZE,   default_cache_size_fun),
     PARSE_FUN(RC_DEFAULT_EDITOR,       default_editor_fun),
     PARSE_STR(RC_DEFAULT_INDEX_FILE,   indexfile),
     PARSE_ENU(RC_DEFAULT_KEYPAD_MODE,  keypad_mode, tbl_keypad_mode),
     PARSE_FUN(RC_DEFAULT_KEYPAD_MODE_NUMARO, numbers_as_arrows_fun),
     PARSE_ENU(RC_DEFAULT_USER_MODE,    user_mode, tbl_user_mode),
#if defined(VMS) && defined(VAXC) && !defined(__DECC)
     PARSE_INT(RC_DEFAULT_VIRTUAL_MEMORY_SIZE, HTVirtualMemorySize),
#endif
#ifdef DIRED_SUPPORT
     PARSE_FUN(RC_DIRED_MENU,           dired_menu_fun),
#endif
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN(RC_DISPLAY_CHARSET_CHOICE, parse_display_charset_choice),
#endif
     PARSE_ADD(RC_DOWNLOADER,           downloaders),
     PARSE_SET(RC_EMACS_KEYS_ALWAYS_ON, emacs_keys),
     PARSE_FUN(RC_ENABLE_LYNXRC,        enable_lynxrc),
     PARSE_SET(RC_ENABLE_SCROLLBACK,    enable_scrollback),
#ifdef USE_EXTERNALS
     PARSE_ADD(RC_EXTERNAL,             externals),
#endif
     PARSE_Env(RC_FINGER_PROXY,         0),
#if defined(_WINDOWS)	/* 1998/10/05 (Mon) 17:34:15 */
     PARSE_SET(RC_FOCUS_WINDOW,         focus_window),
#endif
     PARSE_SET(RC_FORCE_8BIT_TOUPPER,   UCForce8bitTOUPPER),
     PARSE_ENU(RC_FORCE_COOKIE_PROMPT,  cookie_noprompt, tbl_force_prompt),
     PARSE_SET(RC_FORCE_EMPTY_HREFLESS_A, force_empty_hrefless_a),
     PARSE_SET(RC_FORCE_SSL_COOKIES_SECURE, LYForceSSLCookiesSecure),
#ifdef USE_SSL
     PARSE_ENU(RC_FORCE_SSL_PROMPT,     ssl_noprompt, tbl_force_prompt),
#endif
#if !defined(NO_OPTION_FORMS) && !defined(NO_OPTION_MENU)
     PARSE_SET(RC_FORMS_OPTIONS,        LYUseFormsOptions),
#endif
     PARSE_SET(RC_FTP_PASSIVE,          ftp_passive),
     PARSE_Env(RC_FTP_PROXY,            0),
     PARSE_STR(RC_GLOBAL_EXTENSION_MAP, global_extension_map),
     PARSE_STR(RC_GLOBAL_MAILCAP,       global_type_map),
     PARSE_Env(RC_GOPHER_PROXY,         0),
     PARSE_SET(RC_GOTOBUFFER,           goto_buffer),
     PARSE_PRG(RC_GZIP_PATH,            ppGZIP),
     PARSE_STR(RC_HELPFILE,             helpfile),
#ifdef MARK_HIDDEN_LINKS
     PARSE_STR(RC_HIDDEN_LINK_MARKER,   hidden_link_marker),
#endif
     PARSE_SET(RC_HISTORICAL_COMMENTS,  historical_comments),
#ifdef USE_PRETTYSRC
     PARSE_FUN(RC_HTMLSRC_ATTRNAME_XFORM, read_htmlsrc_attrname_xform),
     PARSE_FUN(RC_HTMLSRC_TAGNAME_XFORM, read_htmlsrc_tagname_xform),
#endif
     PARSE_Env(RC_HTTP_PROXY,           0),
     PARSE_Env(RC_HTTPS_PROXY,          0),
     PARSE_REQ(RC_INCLUDE,              0),
     PARSE_PRG(RC_INFLATE_PATH,         ppINFLATE),
     PARSE_TIM(RC_INFOSECS,             InfoSecs),
     PARSE_PRG(RC_INSTALL_PATH,         ppINSTALL),
     PARSE_STR(RC_JUMP_PROMPT,          jumpprompt),
     PARSE_SET(RC_JUMPBUFFER,           jump_buffer),
     PARSE_FUN(RC_JUMPFILE,             jumpfile_fun),
#ifdef EXP_JUSTIFY_ELTS
     PARSE_SET(RC_JUSTIFY,              ok_justify),
     PARSE_INT(RC_JUSTIFY_MAX_VOID_PERCENT, justify_max_void_percent),
#endif
#ifdef EXP_KEYBOARD_LAYOUT
     PARSE_FUN(RC_KEYBOARD_LAYOUT,      keyboard_layout_fun),
#endif
     PARSE_FUN(RC_KEYMAP,               keymap_fun),
     PARSE_SET(RC_LEFTARROW_IN_TEXTFLD_PROMPT, textfield_prompt_at_left_edge),
#ifndef VMS
     PARSE_STR(RC_LIST_FORMAT,          list_format),
#endif
#ifndef DISABLE_NEWS
     PARSE_SET(RC_LIST_NEWS_DATES,      LYListNewsDates),
     PARSE_SET(RC_LIST_NEWS_NUMBERS,    LYListNewsNumbers),
#endif
#ifdef EXP_LOCALE_CHARSET
     PARSE_SET(RC_LOCALE_CHARSET,       LYLocaleCharset),
#endif
     PARSE_STR(RC_LOCAL_DOMAIN,         LYLocalDomain),
     PARSE_FUN(RC_LOCALHOST_ALIAS,      localhost_alias_fun),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_ALWAYS, local_exec),
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_LOCAL, local_exec_on_local_files),
#endif
     PARSE_STR(RC_LYNX_HOST_NAME,       LYHostName),
     PARSE_FUN(RC_LYNX_SIG_FILE,        lynx_sig_file_fun),
#ifdef LYNXCGI_LINKS
#ifndef VMS
     PARSE_STR(RC_LYNXCGI_DOCUMENT_ROOT, LYCgiDocumentRoot),
#endif
     PARSE_FUN(RC_LYNXCGI_ENVIRONMENT,  lynxcgi_environment_fun),
#endif
#if USE_VMS_MAILER
     PARSE_STR(RC_MAIL_ADRS,            mail_adrs),
#endif
     PARSE_SET(RC_MAIL_SYSTEM_ERROR_LOGGING, error_logging),
     PARSE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images),
     PARSE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts),
     PARSE_INT(RC_MAX_COOKIES_BUFFER,   max_cookies_buffer),
     PARSE_INT(RC_MAX_COOKIES_DOMAIN,   max_cookies_domain),
     PARSE_INT(RC_MAX_COOKIES_GLOBAL,   max_cookies_global),
     PARSE_TIM(RC_MESSAGESECS,          MessageSecs),
     PARSE_SET(RC_MINIMAL_COMMENTS,     minimal_comments),
     PARSE_PRG(RC_MKDIR_PATH,           ppMKDIR),
     PARSE_ENU(RC_MULTI_BOOKMARK_SUPPORT, LYMultiBookmarks, tbl_multi_bookmarks),
     PARSE_PRG(RC_MV_PATH,              ppMV),
     PARSE_SET(RC_NCR_IN_BOOKMARKS,     UCSaveBookmarksInUnicode),
#ifndef DISABLE_NEWS
     PARSE_FUN(RC_NEWS_CHUNK_SIZE,      news_chunk_size_fun),
     PARSE_FUN(RC_NEWS_MAX_CHUNK,       news_max_chunk_fun),
     PARSE_FUN(RC_NEWS_POSTING,         news_posting_fun),
     PARSE_Env(RC_NEWS_PROXY,           0),
     PARSE_Env(RC_NEWSPOST_PROXY,       0),
     PARSE_Env(RC_NEWSREPLY_PROXY,      0),
     PARSE_Env(RC_NNTP_PROXY,           0),
     PARSE_ENV(RC_NNTPSERVER,           0), /* actually NNTPSERVER */
#endif
     PARSE_SET(RC_NUMBER_FIELDS_ON_LEFT,number_fields_on_left),
     PARSE_SET(RC_NUMBER_LINKS_ON_LEFT, number_links_on_left),
     PARSE_SET(RC_NO_DOT_FILES,         no_dotfiles),
     PARSE_SET(RC_NO_FILE_REFERER,      no_filereferer),
#ifndef VMS
     PARSE_SET(RC_NO_FORCED_CORE_DUMP,  LYNoCore),
#endif
     PARSE_SET(RC_NO_FROM_HEADER,       LYNoFromHeader),
     PARSE_SET(RC_NO_ISMAP_IF_USEMAP,   LYNoISMAPifUSEMAP),
     PARSE_Env(RC_NO_PROXY,             0),
     PARSE_SET(RC_NO_REFERER_HEADER,    LYNoRefererHeader),
     PARSE_SET(RC_NO_TABLE_CENTER,      no_table_center),
     PARSE_FUN(RC_NONRESTARTING_SIGWINCH, nonrest_sigwinch_fun),
     PARSE_FUN(RC_OUTGOING_MAIL_CHARSET, outgoing_mail_charset_fun),
#ifdef DISP_PARTIAL
     PARSE_SET(RC_PARTIAL,              display_partial_flag),
     PARSE_INT(RC_PARTIAL_THRES,        partial_threshold),
#endif
#ifdef USE_PERSISTENT_COOKIES
     PARSE_SET(RC_PERSISTENT_COOKIES,   persistent_cookies),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_PERSONAL_EXTENSION_MAP, personal_extension_map),
     PARSE_STR(RC_PERSONAL_MAILCAP,     personal_type_map),
     PARSE_STR(RC_PREFERRED_CHARSET,    pref_charset),
     PARSE_ENU(RC_PREFERRED_ENCODING,   LYAcceptEncoding, tbl_preferred_encoding),
     PARSE_STR(RC_PREFERRED_LANGUAGE,   language),
     PARSE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia, tbl_preferred_media),
     PARSE_SET(RC_PREPEND_BASE_TO_SOURCE, LYPrependBaseToSource),
     PARSE_SET(RC_PREPEND_CHARSET_TO_SOURCE, LYPrependCharsetToSource),
#ifdef USE_PRETTYSRC
     PARSE_SET(RC_PRETTYSRC,            LYpsrc),
     PARSE_FUN(RC_PRETTYSRC_SPEC,       psrcspec_fun),
     PARSE_SET(RC_PRETTYSRC_VIEW_NO_ANCHOR_NUM, psrcview_no_anchor_numbering),
#endif
     PARSE_FUN(RC_PRINTER,              printer_fun),
     PARSE_SET(RC_QUIT_DEFAULT_YES,     LYQuitDefaultYes),
     PARSE_FUN(RC_REFERER_WITH_QUERY,   referer_with_query_fun),
#ifdef EXP_CMD_LOGGING
     PARSE_TIM(RC_REPLAYSECS,           ReplaySecs),
#endif
     PARSE_SET(RC_REUSE_TEMPFILES,      LYReuseTempfiles),
     PARSE_PRG(RC_RLOGIN_PATH,          ppRLOGIN),
     PARSE_PRG(RC_RM_PATH,              ppRM),
#ifndef NO_RULES
     PARSE_FUN(RC_RULE,                 HTSetConfiguration),
     PARSE_FUN(RC_RULESFILE,            cern_rulesfile_fun),
#endif /* NO_RULES */
     PARSE_STR(RC_SAVE_SPACE,           lynx_save_space),
     PARSE_SET(RC_SCAN_FOR_BURIED_NEWS_REFS, scan_for_buried_news_references),
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
     PARSE_FUN(RC_SCREEN_SIZE,          screen_size_fun),
#endif
#ifdef USE_SCROLLBAR
     PARSE_SET(RC_SCROLLBAR,            LYShowScrollbar),
     PARSE_SET(RC_SCROLLBAR_ARROW,      LYsb_arrow),
#endif
     PARSE_SET(RC_SEEK_FRAG_AREA_IN_CUR, LYSeekFragAREAinCur),
     PARSE_SET(RC_SEEK_FRAG_MAP_IN_CUR, LYSeekFragMAPinCur),
     PARSE_SET(RC_SET_COOKIES,          LYSetCookies),
     PARSE_SET(RC_SHOW_CURSOR,          LYShowCursor),
     PARSE_ENU(RC_SHOW_KB_RATE,         LYTransferRate, tbl_transfer_rate),
     PARSE_Env(RC_SNEWS_PROXY,          0),
     PARSE_Env(RC_SNEWSPOST_PROXY,      0),
     PARSE_Env(RC_SNEWSREPLY_PROXY,     0),
     PARSE_SET(RC_SOFT_DQUOTES,         soft_dquotes),
#ifdef USE_SOURCE_CACHE
     PARSE_ENU(RC_SOURCE_CACHE,         LYCacheSource, tbl_source_cache),
     PARSE_ENU(RC_SOURCE_CACHE_FOR_ABORTED, LYCacheSourceForAborted, tbl_abort_source_cache),
#endif
     PARSE_STR(RC_STARTFILE,            startfile),
     PARSE_SET(RC_STRIP_DOTDOT_URLS,    LYStripDotDotURLs),
     PARSE_SET(RC_SUBSTITUTE_UNDERSCORES, use_underscore),
     PARSE_FUN(RC_SUFFIX,               suffix_fun),
     PARSE_FUN(RC_SUFFIX_ORDER,         suffix_order_fun),
#ifdef SYSLOG_REQUESTED_URLS
     PARSE_SET(RC_SYSLOG_REQUESTED_URLS, syslog_requested_urls),
     PARSE_SET(RC_SYSLOG_TEXT,		syslog_txt),
#endif
     PARSE_FUN(RC_SYSTEM_EDITOR,        system_editor_fun),
     PARSE_STR(RC_SYSTEM_MAIL,          system_mail),
     PARSE_STR(RC_SYSTEM_MAIL_FLAGS,    system_mail_flags),
     PARSE_FUN(RC_TAGSOUP,              get_tagsoup),
     PARSE_PRG(RC_TAR_PATH,             ppTAR),
     PARSE_PRG(RC_TELNET_PATH,          ppTELNET),
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
     PARSE_SET(RC_TEXTFIELDS_NEED_ACTIVATION, textfields_activation_option),
#endif
     PARSE_PRG(RC_TN3270_PATH,          ppTN3270),
#if defined(_WINDOWS)
     PARSE_INT(RC_TIMEOUT,              lynx_timeout),
#endif
     PARSE_PRG(RC_TOUCH_PATH,           ppTOUCH),
     PARSE_SET(RC_TRIM_INPUT_FIELDS,    LYtrimInputFields),
#ifdef EXEC_LINKS
     PARSE_DEF(RC_TRUSTED_EXEC,         EXEC_PATH),
#endif
#ifdef LYNXCGI_LINKS
     PARSE_DEF(RC_TRUSTED_LYNXCGI,      CGI_PATH),
#endif
     PARSE_PRG(RC_UNCOMPRESS_PATH,      ppUNCOMPRESS),
     PARSE_SET(RC_UNDERLINE_LINKS,      LYUnderlineLinks),
     PARSE_PRG(RC_UNZIP_PATH,           ppUNZIP),
#ifdef DIRED_SUPPORT
     PARSE_ADD(RC_UPLOADER,             uploaders),
#endif
     PARSE_STR(RC_URL_DOMAIN_PREFIXES,  URLDomainPrefixes),
     PARSE_STR(RC_URL_DOMAIN_SUFFIXES,  URLDomainSuffixes),
#ifdef VMS
     PARSE_SET(RC_USE_FIXED_RECORDS,    UseFixedRecords),
#endif
#if defined(USE_MOUSE)
     PARSE_SET(RC_USE_MOUSE,            LYUseMouse),
#endif
     PARSE_SET(RC_USE_SELECT_POPUPS,    LYSelectPopups),
     PARSE_PRG(RC_UUDECODE_PATH,        ppUUDECODE),
     PARSE_SET(RC_VERBOSE_IMAGES,       verbose_img),
     PARSE_SET(RC_VI_KEYS_ALWAYS_ON,    vi_keys),
     PARSE_FUN(RC_VIEWER,               viewer_fun),
     PARSE_Env(RC_WAIS_PROXY,           0),
     PARSE_STR(RC_XLOADIMAGE_COMMAND,   XLoadImageCommand),
     PARSE_PRG(RC_ZCAT_PATH,            ppZCAT),
     PARSE_PRG(RC_ZIP_PATH,             ppZIP),

     PARSE_NIL
};
/* *INDENT-ON* */

static char *lynxcfginfo_url = NULL;	/* static */

#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
static char *configinfo_url = NULL;	/* static */
#endif

/*
 * Free memory allocated in 'read_cfg()'
 */
void free_lynx_cfg(void)
{
    Config_Type *tbl;

    for (tbl = Config_Table; tbl->name != 0; tbl++) {
	ParseUnionPtr q = ParseUnionOf(tbl);

	switch (tbl->type) {
	case CONF_ENV:
	    if (q->str_value != 0) {
		char *name = *(q->str_value);
		char *eqls = strchr(name, '=');

		if (eqls != 0) {
		    *eqls = 0;
#ifdef VMS
		    Define_VMSLogical(name, NULL);
#else
# ifdef HAVE_UNSETENV
		    unsetenv(name);
# else
		    if (putenv(name))
			break;
# endif
#endif
		}
		FREE(*(q->str_value));
		FREE(q->str_value);
		/* is it enough for reload_read_cfg() to clean up
		 * the result of putenv()?  No for certain platforms.
		 */
	    }
	    break;
	default:
	    break;
	}
    }
    free_all_item_lists();
#ifdef DIRED_SUPPORT
    reset_dired_menu();		/* frees and resets dired menu items - kw */
#endif
    FREE(lynxcfginfo_url);
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
    FREE(configinfo_url);
#endif
}

static Config_Type *lookup_config(char *name)
{
    Config_Type *tbl = Config_Table;
    char ch = (char) TOUPPER(*name);

    while (tbl->name != 0) {
	char ch1 = tbl->name[0];

	if ((ch == TOUPPER(ch1))
	    && (0 == strcasecomp(name, tbl->name)))
	    break;

	tbl++;
    }
    return tbl;
}

/*
 * If the given value is an absolute path (by syntax), or we can read it, use
 * the value as given.  Otherwise, assume it must be in the same place we read
 * the parent configuration file from.
 *
 * Note:  only read files from the current directory if there's no parent
 * filename, otherwise it leads to user surprise.
 */
static char *actual_filename(const char *cfg_filename,
			     const char *parent_filename,
			     const char *dft_filename)
{
    char *my_filename = NULL;

    if (!LYisAbsPath(cfg_filename)
	&& !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
	if (!strncmp(cfg_filename, "~/", 2)) {
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename + 1);
	} else {
	    if (parent_filename != 0) {
		StrAllocCopy(my_filename, parent_filename);
		*LYPathLeaf(my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
	    }
	    if (my_filename == 0 || !LYCanReadFile(my_filename)) {
		StrAllocCopy(my_filename, dft_filename);
		*LYPathLeaf(my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
		if (!LYCanReadFile(my_filename)) {
		    StrAllocCopy(my_filename, cfg_filename);
		}
	    }
	}
    } else {
	StrAllocCopy(my_filename, cfg_filename);
    }
    return my_filename;
}

FILE *LYOpenCFG(const char *cfg_filename,
		const char *parent_filename,
		const char *dft_filename)
{
    char *my_file = actual_filename(cfg_filename, parent_filename, dft_filename);
    FILE *result;

    CTRACE((tfp, "opening config file %s\n", my_file));
    result = fopen(my_file, TXT_R);
    FREE(my_file);

    return result;
}

#define NOPTS_ ( TABLESIZE(Config_Table) - 1 )
typedef BOOL (optidx_set_t)[NOPTS_];

 /* if element is FALSE, then it's allowed in the current file */

#define optidx_set_AND(r,a,b) \
    {\
	unsigned i1;\
	for (i1 = 0; i1 < NOPTS_; ++i1) \
	    (r)[i1]= (a)[i1] || (b)[i1]; \
    }

/*
 * For simple (boolean, string, integer, time) values, set the corresponding
 * configuration variable.
 */
void LYSetConfigValue(char *name,
		      char *value)
{
    Config_Type *tbl = lookup_config(name);
    ParseUnionPtr q = ParseUnionOf(tbl);
    char *temp = 0;

    switch (tbl->type) {
    case CONF_BOOL:
	if (q->set_value != 0)
	    *(q->set_value) = is_true(value);
	break;

    case CONF_FUN:
	if (q->fun_value != 0)
	    (*(q->fun_value)) (value);
	break;

    case CONF_TIME:
	if (q->int_value != 0) {
	    float ival;

	    if (1 == sscanf(value, "%f", &ival)) {
		*(q->int_value) = (int) SECS2Secs(ival);
	    }
	}
	break;

    case CONF_ENUM:
	if (tbl->table != 0)
	    LYgetEnum(tbl->table, value, q->int_value);
	break;

    case CONF_INT:
	if (q->int_value != 0) {
	    int ival;

	    if (1 == sscanf(value, "%d", &ival))
		*(q->int_value) = ival;
	}
	break;

    case CONF_STR:
	if (q->str_value != 0)
	    StrAllocCopy(*(q->str_value), value);
	break;

    case CONF_ENV:
    case CONF_ENV2:

	if (tbl->type == CONF_ENV)
	    LYLowerCase(name);
	else
	    LYUpperCase(name);

	if (LYGetEnv(name) == 0) {
#ifdef VMS
	    Define_VMSLogical(name, value);
#else
	    if (q->str_value == 0)
		q->str_value = typecalloc(char *);

	    HTSprintf0(q->str_value, "%s=%s", name, value);
	    putenv(*(q->str_value));
#endif
	}
	break;
    case CONF_ADD_ITEM:
	if (q->add_value != 0)
	    add_item_to_list(value, q->add_value, FALSE);
	break;

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)
    case CONF_ADD_TRUSTED:
	add_trusted(value, q->def_value);
	break;
#endif

    case CONF_PRG:
	if (StrAllocCopy(temp, value))
	    HTSetProgramPath((ProgramPaths) (q->def_value), temp);
	break;

    default:
	break;
    }
}

/*
 * Process the configuration file (lynx.cfg).
 *
 * 'allowed' is a pointer to HTList of allowed options.  Since the included
 * file can also include other files with a list of acceptable options, these
 * lists are ANDed.
 */
static void do_read_cfg(const char *cfg_filename,
			const char *parent_filename,
			int nesting_level,
			FILE *fp0,
			optidx_set_t * allowed)
{
    FILE *fp;
    char *buffer = 0;

    CTRACE((tfp, "Loading cfg file '%s'.\n", cfg_filename));

    /*
     * Don't get hung up by an include file loop.  Arbitrary max depth
     * of 10.  - BL
     */
    if (nesting_level > 10) {
	fprintf(stderr,
		gettext("More than %d nested lynx.cfg includes -- perhaps there is a loop?!?\n"),
		nesting_level - 1);
	fprintf(stderr, gettext("Last attempted include was '%s',\n"), cfg_filename);
	fprintf(stderr, gettext("included from '%s'.\n"), parent_filename);
	exit_immediately(EXIT_FAILURE);
    }
    /*
     * Locate and open the file.
     */
    if (!cfg_filename || strlen(cfg_filename) == 0) {
	CTRACE((tfp, "No filename following -cfg switch!\n"));
	return;
    }
    if ((fp = LYOpenCFG(cfg_filename, parent_filename, LYNX_CFG_FILE)) == 0) {
	CTRACE((tfp, "lynx.cfg file not found as '%s'\n", cfg_filename));
	return;
    }
    have_read_cfg = TRUE;

    /*
     * Process each line in the file.
     */
#ifdef SH_EX
    if (show_cfg) {
	time_t t;

	time(&t);
	printf("### %s %s, at %s", LYNX_NAME, LYNX_VERSION, ctime(&t));
    }
#endif
    while (LYSafeGets(&buffer, fp) != 0) {
	char *name, *value;
	char *cp;
	Config_Type *tbl;
	ParseUnionPtr q;

	/* Most lines in the config file are comment lines.  Weed them out
	 * now.  Also, leading whitespace is ok, so trim it.
	 */
	name = LYSkipBlanks(buffer);

	if (ispunct(UCH(*name)))
	    continue;

	LYTrimTrailing(name);

	if (*name == 0)
	    continue;

	/* Significant lines are of the form KEYWORD:WHATEVER */
	if ((value = strchr(name, ':')) == 0) {
	    /* fprintf (stderr, "Bad line-- no :\n"); */
	    CTRACE((tfp, "LYReadCFG: missing ':' %s\n", name));
	    continue;
	}

	/* skip past colon, but replace ':' with 0 to make name meaningful */
	*value++ = 0;

	/*
	 * Trim off any trailing comments.
	 *
	 * (Apparently, the original code considers a trailing comment valid
	 * only if preceded by a space character but is not followed by a
	 * colon.  -- JED)
	 */
	if ((cp = strrchr(value, ':')) == 0)
	    cp = value;
	if ((cp = strchr(cp, '#')) != 0) {
	    cp--;
	    if (isspace(UCH(*cp)))
		*cp = 0;
	}

	CTRACE2(TRACE_CFG, (tfp, "LYReadCFG %s:%s\n", name, value));
	tbl = lookup_config(name);
	if (tbl->name == 0) {
	    /* lynx ignores unknown keywords */
	    CTRACE((tfp, "LYReadCFG: ignored %s:%s\n", name, value));
	    continue;
	}
#ifdef SH_EX
	if (show_cfg)
	    printf("%s:%s\n", name, value);
#endif

	if (allowed && (*allowed)[tbl - Config_Table]) {
	    if (fp0 == NULL)
		fprintf(stderr, "%s is not allowed in the %s\n",
			name, cfg_filename);
	    /*FIXME: we can do something wiser if we are generating
	       the html representation of lynx.cfg - say include this line
	       in bold, or something... */

	    continue;
	}

	q = ParseUnionOf(tbl);
	switch ((fp0 != 0 && tbl->type != CONF_INCLUDE)
		? CONF_NIL
		: tbl->type) {
	case CONF_BOOL:
	case CONF_FUN:
	case CONF_TIME:
	case CONF_ENUM:
	case CONF_INT:
	case CONF_STR:
	case CONF_ENV:
	case CONF_ENV2:
	case CONF_PRG:
	case CONF_ADD_ITEM:
	case CONF_ADD_TRUSTED:
	    LYSetConfigValue(name, value);
	    break;

	case CONF_INCLUDE:{
		/* include another file */
		optidx_set_t cur_set, anded_set;
		optidx_set_t *resultant_set = NULL;
		char *p1, *p2, savechar;
		BOOL any_optname_found = FALSE;

		char *url = NULL;
		char *cp1 = NULL;
		const char *sep = NULL;

		if ((p1 = strstr(value, sep = " for ")) != 0
#if defined(UNIX) && !defined(USE_DOS_DRIVES)
		    || (p1 = strstr(value, sep = ":")) != 0
#endif
		    ) {
		    *p1 = '\0';
		    p1 += strlen(sep);
		}
#ifndef NO_CONFIG_INFO
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    char *my_file = actual_filename(value, cfg_filename, LYNX_CFG_FILE);

		    LYLocalFileToURL(&url, my_file);
		    FREE(my_file);
		    StrAllocCopy(cp1, value);
		    if (strchr(value, '&') || strchr(value, '<')) {
			LYEntify(&cp1, TRUE);
		    }

		    fprintf(fp0, "%s:<a href=\"%s\">%s</a>\n\n", name, url, cp1);
		    fprintf(fp0, "    #&lt;begin  %s&gt;\n", cp1);
		}
#endif

		if (p1) {
		    while (*(p1 = LYSkipBlanks(p1)) != 0) {
			Config_Type *tbl2;

			p2 = LYSkipNonBlanks(p1);
			savechar = *p2;
			*p2 = 0;

			tbl2 = lookup_config(p1);
			if (tbl2->name == 0) {
			    if (fp0 == NULL)
				fprintf(stderr,
					"unknown option name %s in %s\n",
					p1, cfg_filename);
			} else {
			    unsigned i;

			    if (!any_optname_found) {
				any_optname_found = TRUE;
				for (i = 0; i < NOPTS_; ++i)
				    cur_set[i] = TRUE;
			    }
			    cur_set[tbl2 - Config_Table] = FALSE;
			}
			if (savechar && p2[1])
			    p1 = p2 + 1;
			else
			    break;
		    }
		}
		if (!allowed) {
		    if (!any_optname_found)
			resultant_set = NULL;
		    else
			resultant_set = &cur_set;
		} else {
		    if (!any_optname_found)
			resultant_set = allowed;
		    else {
			optidx_set_AND(anded_set, *allowed, cur_set);
			resultant_set = &anded_set;
		    }
		}

#ifndef NO_CONFIG_INFO
		/*
		 * Now list the opts that are allowed in included file.  If all
		 * opts are allowed, then emit nothing, else emit an effective set
		 * of allowed options in <ul>.  Option names will be uppercased.
		 * FIXME:  uppercasing option names can be considered redundant.
		 */
		if (fp0 != 0 && !no_lynxcfg_xinfo && resultant_set) {
		    char *buf = NULL;
		    unsigned i;

		    fprintf(fp0, "     Options allowed in this file:\n");
		    for (i = 0; i < NOPTS_; ++i) {
			if ((*resultant_set)[i])
			    continue;
			StrAllocCopy(buf, Config_Table[i].name);
			LYUpperCase(buf);
			fprintf(fp0, "         * %s\n", buf);
		    }
		    FREE(buf);
		}
#endif
		do_read_cfg(value, cfg_filename, nesting_level + 1, fp0, resultant_set);

#ifndef NO_CONFIG_INFO
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    fprintf(fp0, "    #&lt;end of %s&gt;\n\n", cp1);
		    FREE(url);
		    FREE(cp1);
		}
#endif
	    }
	    break;

	default:
	    if (fp0 != 0) {
		if (strchr(value, '&') || strchr(value, '<')) {
		    char *cp1 = NULL;

		    StrAllocCopy(cp1, value);
		    LYEntify(&cp1, TRUE);
		    fprintf(fp0, "%s:%s\n", name, cp1);
		    FREE(cp1);
		} else {
		    fprintf(fp0, "%s:%s\n", name, value);
		}
	    }
	    break;
	}
    }

    LYCloseInput(fp);

    /*
     * If any DOWNLOADER:  commands have always_enabled set (:TRUE), make
     * override_no_download TRUE, so that other restriction settings will not
     * block presentation of a download menu with those always_enabled options
     * still available.  - FM
     */
    if (downloaders != 0) {
	lynx_list_item_type *cur_download;

	cur_download = downloaders;
	while (cur_download != 0) {
	    if (cur_download->always_enabled) {
		override_no_download = TRUE;
		break;
	    }
	    cur_download = cur_download->next;
	}
    }

    /*
     * If any COOKIE_{ACCEPT,REJECT}_DOMAINS have been defined,
     * process them.  These are comma delimited lists of
     * domains. - BJP
     *
     * And for query/strict/loose invalid cookie checking. - BJP
     */
    LYConfigCookies();
}

/* this is a public interface to do_read_cfg */
void read_cfg(const char *cfg_filename,
	      const char *parent_filename,
	      int nesting_level,
	      FILE *fp0)
{
    HTInitProgramPaths();
    do_read_cfg(cfg_filename, parent_filename, nesting_level, fp0, NULL);
}

#ifndef NO_CONFIG_INFO
static void extra_cfg_link(FILE *fp, const char *href,
			   const char *name)
{
    fprintf(fp, "<a href=\"%s\">%s</a>",
	    href, name);
}
#endif /* NO_CONFIG_INFO */

/*
 * Show rendered lynx.cfg data without comments, LYNXCFG:/ internal page. 
 * Called from getfile() cycle:  we create and load the page just in place and
 * return to mainloop().
 */
int lynx_cfg_infopage(DocInfo *newdoc)
{
    static char tempfile[LY_MAXPATH] = "\0";
    DocAddress WWWDoc;		/* need on exit */
    char *temp = 0;
    char *cp1 = NULL;
    FILE *fp0;

#ifndef NO_CONFIG_INFO
    /*-------------------------------------------------
     * kludge a link from LYNXCFG:/, the URL was:
     * "  <a href=\"LYNXCFG://reload\">RELOAD THE CHANGES</a>\n"
     *--------------------------------------------------*/

    if (!no_lynxcfg_xinfo && (strstr(newdoc->address, "LYNXCFG://reload"))) {
	/*
	 * Some stuff to reload read_cfg(), but also load options menu items
	 * and command-line options to make things consistent.  Implemented in
	 * LYMain.c
	 */
	reload_read_cfg();

	/*
	 * now pop-up and return to updated LYNXCFG:/ page, remind
	 * postoptions() but much simpler:
	 */
	/*
	 * But check whether the top history document is really the expected
	 * LYNXCFG:  page.  - kw
	 */
	if (HTMainText && nhist > 0 &&
	    !strcmp(HTLoadedDocumentTitle(), LYNXCFG_TITLE) &&
	    !strcmp(HTLoadedDocumentURL(), HDOC(nhist - 1).address) &&
	    LYIsUIPage(HDOC(nhist - 1).address, UIP_LYNXCFG) &&
	    (!lynxcfginfo_url ||
	     strcmp(HTLoadedDocumentURL(), lynxcfginfo_url))) {
	    /*  the page was pushed, so pop-up. */
	    LYpop(newdoc);
	    WWWDoc.address = newdoc->address;
	    WWWDoc.post_data = newdoc->post_data;
	    WWWDoc.post_content_type = newdoc->post_content_type;
	    WWWDoc.bookmark = newdoc->bookmark;
	    WWWDoc.isHEAD = newdoc->isHEAD;
	    WWWDoc.safe = newdoc->safe;
	    LYforce_no_cache = FALSE;	/* ! */
	    LYoverride_no_cache = TRUE;		/* ! */

	    /*
	     * Working out of getfile() cycle we reset *no_cache manually here
	     * so HTLoadAbsolute() will return "Document already in memory": 
	     * it was forced reloading obsolete file again without this
	     * (overhead).
	     *
	     * Probably *no_cache was set in a wrong position because of the
	     * internal page...
	     */
	    if (!HTLoadAbsolute(&WWWDoc))
		return (NOT_FOUND);

	    HTuncache_current_document();	/* will never use again */
	    LYUnRegisterUIPage(UIP_LYNXCFG);
	}

	/*  now set up the flag and fall down to create a new LYNXCFG:/ page */
	FREE(lynxcfginfo_url);	/* see below */
    }
#endif /* !NO_CONFIG_INFO */

    /*
     * We regenerate the file if reloading has been requested (with LYK_NOCACHE
     * key).  If we did not regenerate, there would be no way to recover in a
     * session from a situation where the file is corrupted (for example
     * truncated because the file system was full when it was first created -
     * lynx doesn't check for write errors below), short of manual complete
     * removal or perhaps forcing regeneration with LYNXCFG://reload. 
     * Similarly, there would be no simple way to get a different page if
     * user_mode has changed to Advanced after the file was first generated in
     * a non-Advanced mode (the difference being in whether the page includes
     * the link to LYNXCFG://reload or not).
     *
     * We also try to regenerate the file if lynxcfginfo_url is set, indicating
     * that tempfile is valid, but the file has disappeared anyway.  This can
     * happen to a long-lived lynx process if for example some system script
     * periodically cleans up old files in the temp file space.  - kw
     */

    if (LYforce_no_cache && reloading) {
	FREE(lynxcfginfo_url);	/* flag to code below to regenerate - kw */
    } else if (lynxcfginfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(lynxcfginfo_url);	/* flag to code below to try again - kw */
	}
    }
    if (lynxcfginfo_url == 0) {

	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	    return (NOT_FOUND);

	LYLocalFileToURL(&lynxcfginfo_url, tempfile);

	LYforce_no_cache = TRUE;	/* don't cache this doc */

	BeginInternalPage(fp0, LYNXCFG_TITLE, NULL);
	fprintf(fp0, "<pre>\n");

#ifndef NO_CONFIG_INFO
	if (!no_lynxcfg_xinfo) {
#if defined(HAVE_CONFIG_H) || defined(VMS)
	    if (strcmp(lynx_cfg_file, LYNX_CFG_FILE)) {
		fprintf(fp0, "<em>%s\n%s",
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
		LYLocalFileToURL(&temp, LYNX_CFG_FILE);
		fprintf(fp0, " <a href=\"%s\">lynx.cfg</a> ",
			temp);
		FREE(temp);
		fprintf(fp0, "%s</em>\n\n",
			gettext("for more comments."));
	    } else
#endif /* HAVE_CONFIG_H */
	    {
		/* no absolute path... for lynx.cfg on DOS/Win32 */
		fprintf(fp0, "<em>%s\n%s",
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
		fprintf(fp0, " </em>lynx.cfg<em> ");
		fprintf(fp0, "%s</em>\n",
			gettext("for more comments."));
	    }

#ifndef NO_CONFIG_INFO
#if defined(HAVE_CONFIG_H) && defined(USE_COLOR_STYLE)
	    if (!no_compileopts_info && !no_lynxcfg_xinfo) {
		fprintf(fp0, "%s</pre><ul><li>", SEE_ALSO);
		extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);

		fprintf(fp0, "<li>");
		LYLocalFileToURL(&temp, lynx_lss_file);
		extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		fprintf(fp0, "</ul><pre>\n");
	    } else
#endif
	    {
		fprintf(fp0, "%s ", SEE_ALSO);
#if defined(HAVE_CONFIG_H)
		if (!no_compileopts_info) {
		    extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);
		}
#endif
#if defined(USE_COLOR_STYLE)
		if (!no_lynxcfg_xinfo) {
		    LYLocalFileToURL(&temp, lynx_lss_file);
		    extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		}
#endif
		fprintf(fp0, "\n\n");
	    }
#endif /* NO_CONFIG_INFO */

	    /** a new experimental link ... **/
	    if (user_mode == ADVANCED_MODE)
		fprintf(fp0, "  <a href=\"%s//reload\">%s</a>\n",
			STR_LYNXCFG,
			gettext("RELOAD THE CHANGES"));

	    LYLocalFileToURL(&temp, lynx_cfg_file);
	    StrAllocCopy(cp1, lynx_cfg_file);
	    if (strchr(lynx_cfg_file, '&') || strchr(lynx_cfg_file, '<')) {
		LYEntify(&cp1, TRUE);
	    }
	    fprintf(fp0, "\n    #<em>%s <a href=\"%s\">%s</a></em>\n",
		    gettext("Your primary configuration"),
		    temp,
		    cp1);
	    FREE(temp);
	    FREE(cp1);

	} else
#endif /* !NO_CONFIG_INFO */

	    fprintf(fp0, "<em>%s</em>\n\n",
		    gettext("The following is read from your lynx.cfg file."));

	/*
	 * Process the configuration file.
	 */
	read_cfg(lynx_cfg_file, "main program", 1, fp0);

	fprintf(fp0, "</pre>\n");
	EndInternalPage(fp0);
	LYCloseTempFP(fp0);
	LYRegisterUIPage(lynxcfginfo_url, UIP_LYNXCFG);
    }

    /* return to getfile() cycle */
    StrAllocCopy(newdoc->address, lynxcfginfo_url);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;

    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
    return (NORMAL);
}

#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
/*
 * Compile-time definitions info, LYNXCOMPILEOPTS:/ internal page, from
 * getfile() cycle.
 */
int lynx_compile_opts(DocInfo *newdoc)
{
    static char tempfile[LY_MAXPATH] = "\0";

#define PutDefs(table, N) fprintf(fp0, "%-35s %s\n", table[N].name, table[N].value)
#include <cfg_defs.h>
    unsigned n;
    DocAddress WWWDoc;		/* need on exit */
    FILE *fp0;

    /* In general, create the page only once - compile-time data will not
     * change...  But we will regenerate the file anyway, in a few situations:
     *
     * (a) configinfo_url has been FREEd - this can happen if free_lynx_cfg()
     * was called as part of a LYNXCFG://reload action.
     *
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did not
     * regenerate, there would be no way to recover in a session from a
     * situation where the file is corrupted (for example truncated because the
     * file system was full when it was first created - lynx doesn't check for
     * write errors below), short of manual complete removal or forcing
     * regeneration with LYNXCFG://reload.
     *
     * (c) configinfo_url is set, indicating that tempfile is valid, but the
     * file has disappeared anyway.  This can happen to a long-lived lynx
     * process if for example some system script periodically cleans up old
     * files in the temp file space.  - kw
     */

    if (LYforce_no_cache && reloading) {
	FREE(configinfo_url);	/* flag to code below to regenerate - kw */
    } else if (configinfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(configinfo_url);	/* flag to code below to try again - kw */
	}
    }
    if (configinfo_url == NULL) {
	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	    return (NOT_FOUND);

	LYLocalFileToURL(&configinfo_url, tempfile);

	BeginInternalPage(fp0, CONFIG_DEF_TITLE, NULL);
	fprintf(fp0, "<pre>\n");

	fprintf(fp0, "\n%s<br>\n<em>config.cache</em>\n", AUTOCONF_CONFIG_CACHE);
	for (n = 0; n < TABLESIZE(config_cache); n++) {
	    PutDefs(config_cache, n);
	}
	fprintf(fp0, "\n%s<br>\n<em>lynx_cfg.h</em>\n", AUTOCONF_LYNXCFG_H);
	for (n = 0; n < TABLESIZE(config_defines); n++) {
	    PutDefs(config_defines, n);
	}
	fprintf(fp0, "</pre>\n");
	EndInternalPage(fp0);
	LYCloseTempFP(fp0);
	LYRegisterUIPage(configinfo_url, UIP_CONFIG_DEF);
    }

    /* exit to getfile() cycle */
    StrAllocCopy(newdoc->address, configinfo_url);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;

    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
    return (NORMAL);
}
#endif /* !NO_CONFIG_INFO */
@


1.8
log
@automatic merge
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYReadCFG.c,v 1.7 2004/07/15 18:17:02 tg Stab $ */
d52 1
a52 1
    if (!strncasecomp(string, "TRUE", 4))
d431 1
a431 1
#define PARSE_NIL        {NULL,0,              UNION_DEF(0), 0}
d434 1
a434 1
    CONF_UNSPECIFIED = 0
d821 3
a823 1
    char *encoding = NULL, *sq = NULL, *description = NULL;
d1155 1
a1155 1
    parse_html_src_spec(found, e + 1, s);
d1383 3
d1476 4
d1610 3
a1612 3
static char *actual_filename(char *cfg_filename,
			     char *parent_filename,
			     char *dft_filename)
d1641 3
a1643 3
FILE *LYOpenCFG(char *cfg_filename,
		char *parent_filename,
		char *dft_filename)
d1751 1
a1751 1
	    HTSetProgramPath(q->def_value, temp);
d1766 2
a1767 2
static void do_read_cfg(char *cfg_filename,
			char *parent_filename,
d1787 1
a1787 1
	exit(EXIT_FAILURE);
d1882 1
a1882 1
		? CONF_UNSPECIFIED
d1907 1
a1907 1
		char *sep = NULL;
d2060 2
a2061 2
void read_cfg(char *cfg_filename,
	      char *parent_filename,
d2070 2
a2071 2
static void extra_cfg_link(FILE *fp, char *href,
			   char *name)
@


1.7
log
@automatic merge of lynx-current
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYReadCFG.c,v 1.6 2004/04/30 16:32:36 tg Exp $ */
d795 1
a795 1
	    (rulesfile2 && *rulesfile2) ? rulesfile2 : gettext("(no name)"));
d1336 1
d1667 1
a1667 1
    char *temp;
d1883 1
@


1.6
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYReadCFG.c,v 1.5 2004/02/08 19:49:00 tg Exp $ */
d8 1
a8 1
#include <HTTP.h>  /* 'reloading' flag */
d48 1
a48 1
 *  Translate a TRUE/FALSE field in a string buffer.
d50 1
a50 2
static BOOL is_true (
	char * string)
d52 2
a53 2
    if (!strncasecomp(string,"TRUE",4))
	return(TRUE);
d55 1
a55 1
	return(FALSE);
d59 1
a59 1
 *  Find an unescaped colon in a string buffer.
d61 1
a61 2
static char *find_colon (
	char * buffer)
d81 1
a81 2
static void free_item_list (
    lynx_list_item_type **	ptr)
d97 1
a97 1
 *  Function for freeing the DOWNLOADER and UPLOADER menus list. - FM
d99 1
a99 1
static void free_all_item_lists (void)
d115 1
a115 1
 *  Process string buffer fields for DOWNLOADER or UPLOADER menus.
d117 3
a119 4
static void add_item_to_list (
	char *			buffer,
	lynx_list_item_type ** list_ptr,
	int			special)
d125 1
a125 1
     *	Make a linked list
d129 1
a129 1
	 *  First item.
d132 1
d141 1
a141 1
	 *  Find the last item.
d145 1
a145 2
	     prev_item = prev_item->next)
	    ;  /* null body */
d147 1
d161 1
a161 1
     *	Find first unescaped colon and process fields
d165 1
a165 1
	 *  Process name field
d167 2
a168 1
	cur_item->name = typecallocn(char, colon-buffer+1);
d171 1
a171 1
	LYstrncpy(cur_item->name, buffer, (int)(colon-buffer));
d175 4
a178 4
	 *  Find end of command string and beginning of TRUE/FALSE option
	 *  field.  If we do not find a colon that ends the command string,
	 *  leave the always_enabled option flag as FALSE.  In any case,
	 *  we want the command string.
d180 1
a180 1
	if ((next_colon = find_colon(colon+1)) == NULL) {
d183 3
a185 2
	if (next_colon - (colon+1) > 0) {
	    cur_item->command = typecallocn(char,next_colon-colon);
d188 3
a190 1
	    LYstrncpy(cur_item->command, colon+1, (int)(next_colon-(colon+1)));
d209 2
a210 3
lynx_list_item_type *find_item_by_number (
	lynx_list_item_type *	list_ptr,
	char *			number)
d213 1
d220 2
a221 4
int match_item_by_name (
    lynx_list_item_type *	ptr,
    char *			name,
    BOOLEAN			only_overriders)
d225 2
a226 2
	&& !strncasecomp(ptr->name, name, strlen(ptr->name))
	&& (only_overriders ? ptr->override_primary_action : 1));
d242 1
d273 1
a273 2
static int ColorCode (
	int	color)
d275 9
a283 4
	static int map[] = {
		0,  4,	2,  6, 1,  5,  3,  7,
		8, 12, 10, 14, 9, 13, 11, 15 };
	return map[color];
d292 1
a292 1
 *  Validator for COLOR fields.
d294 2
a295 3
int check_color (
	char * color,
	int	the_default)
d304 1
a304 1
#endif	/* USE_DEFAULT_COLORS */
d323 1
a323 2
const char *lookup_color (
    int	code)
d326 1
d338 1
a338 1
 *  Exit routine for failed COLOR parsing.
d340 1
a340 2
static void exit_with_color_syntax (
	char *		error_line)
d343 2
a344 1
    fprintf (stderr, gettext("\
d351 1
a351 1
	    );
d357 1
a357 1
    fprintf (stderr, "%s\n%s\n", gettext("Offending line:"), error_line);
d364 1
a364 1
 *  Process string buffer fields for COLOR setting.
d366 1
a366 2
static void parse_color (
	char * buffer)
d375 2
a376 2
     *	We are expecting a line of the form:
     *	  INTEGER:FOREGROUND:BACKGROUND
d395 2
a396 2
	check_color(fg, default_fg),
	check_color(bg, default_bg)) < 0)
d402 1
a402 1

d417 1
d449 6
a454 8
typedef struct
{
   const char *name;
   Conf_Types type;
   ParseData;
   Config_Enum *table;
}
Config_Type;
d456 1
a456 2
static int assume_charset_fun (
	char *		value)
d460 1
a460 1
			LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d468 1
a468 2
static int assume_local_charset_fun (
	char *		value)
d474 1
a474 2
static int assume_unrec_charset_fun (
	char *		value)
d480 1
a480 2
static int character_set_fun (
	char *		value)
d482 1
a482 1
    int i = UCGetLYhndl_byAnyName(value); /* by MIME or full name */
d487 2
a488 2
	    && (!strnicmp(value,"AutoDetect ",11)
		|| !strnicmp(value,"AutoDetect-2 ",13)))
d492 1
a492 2
    }
    else
d498 1
a498 2
static int outgoing_mail_charset_fun (
	char *		value)
d508 1
a508 1
 *  Process string buffer fields for ASSUMED_COLOR setting.
d510 1
a510 2
static int assumed_color_fun (
	char * buffer)
d518 2
a519 2
     *	We are expecting a line of the form:
     *	  FOREGROUND:BACKGROUND
d529 1
a529 1
     || default_bg == ERR_COLOR)
d546 1
a546 2
static int color_fun (
	char *		value)
d548 1
a548 1
    parse_color (value);
d553 1
a553 2
static int default_bookmark_file_fun (
	char *		value)
d559 1
a559 2
static int default_cache_size_fun (
	char *		value)
d562 2
a563 1
    if (HTCacheSize < 2) HTCacheSize = 2;
d567 1
a567 2
static int default_editor_fun (
	char *		value)
d569 2
a570 1
    if (!system_editor) StrAllocCopy(editor, value);
d574 1
a574 2
static int numbers_as_arrows_fun (
	char *		value)
d585 1
a585 2
static int dired_menu_fun (
	char *		value)
d592 1
a592 2
static int jumpfile_fun (
	char *		value)
d596 1
a596 1
    HTSprintf0 (&buffer, "JUMPFILE:%s", value);
d605 1
a605 2
static int keyboard_layout_fun (
	char *		key)
d613 1
a613 2
static int keymap_fun (
	char *		key)
d649 1
d655 1
a655 2
				gettext(
	"invalid line-editor selection %s for key %s, selecting all\n"),
d661 11
a671 12
		 *  PASS! tries to enter the key into the LYLineEditors
		 *  bindings in a different way from PASS, namely as
		 *  binding that maps to the specific lynx actioncode
		 *  (rather than to LYE_FORM_PASS).  That only works
		 *  for lynx keycodes with modifier bit set, and we
		 *  have no documented/official way to specify this
		 *  in the KEYMAP directive, although it can be made
		 *  to work e.g. by specifying a hex value that has the
		 *  modifier bit set.  But knowledge about the bit
		 *  pattern of modifiers should remain in internal
		 *  matter subject to change...  At any rate, if
		 *  PASS! fails try it the same way as for PASS. - kw
d675 1
a675 1
			lec = LYE_FORM_LAC|lacname_to_lac(func);
d680 1
a680 2
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
d692 1
a692 2
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
d696 1
a696 2
				gettext(
	   "setting of line-editor binding for key %s (0x%x) for %s failed\n"),
d706 1
a706 2
static int localhost_alias_fun (
	char *		value)
d713 1
a713 2
static int lynxcgi_environment_fun (
	char *		value)
d720 1
a720 2
static int lynx_sig_file_fun (
	char *		value)
d723 2
a724 1
    LYstrncpy(temp, value, sizeof(temp)-1);
d737 1
a737 2
static int news_chunk_size_fun (
	char *		value)
d749 1
a749 2
static int news_max_chunk_fun (
	char *		value)
d761 1
a761 2
static int news_posting_fun (
	char *		value)
d770 1
a770 2
static int cern_rulesfile_fun (
	char *		value)
d774 1
d783 2
a784 3
	StrAllocCat(rulesfile2, value+1);
    }
    else {
d794 1
a794 3
	    gettext(
		"Lynx: cannot start, CERN rules file %s is not available\n"
		),
d801 1
a801 2
static int printer_fun (
	char *		value)
d807 1
a807 2
static int referer_with_query_fun (
	char *		value)
d818 1
a818 2
static int suffix_fun (
	char *		value)
d824 2
a825 2
    if ((strlen (value) < 3)
    || (NULL == (mime_type = strchr (value, ':')))) {
d855 5
a859 6
     *  Not converted to lowercase on input, to make it possible to
     *  reproduce the equivalent of some of the HTInit.c defaults
     *  that use mixed case, although that is not recomended. - kw
     */ /*LYLowerCase(mime_type);*/

    if (!*mime_type) { /* that's ok now, with an encoding!  */
d861 2
a862 2
	       encoding ? encoding : "what?"));
	mime_type = NULL; /* that's ok now, with an encoding!  */
d881 1
d884 1
a884 1
		   sq, value));
d895 1
a895 2
static int suffix_order_fun (
	char *		value)
d922 1
a922 2
static int system_editor_fun (
	char *		value)
d929 4
a932 2
static int viewer_fun (
	char *		value)
d940 2
a941 2
    if ((strlen (value) < 3)
    || (NULL == (viewer = strchr (mime_type, ':'))))
d951 1
a951 1
	(strlen(viewer) > 1) && *(environment-1) != '\\') {
d958 1
a958 1
	if (!strcasecomp(environment,"XWINDOWS")) {
d960 2
a961 2
		HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
	} else if (!strcasecomp(environment,"NON_XWINDOWS")) {
d963 1
a963 1
		HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
d965 1
a965 1
	    HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
d969 1
a969 1
	HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
d975 1
a975 2
static int nonrest_sigwinch_fun (
	char *		value)
d986 2
a987 3
static void matched_charset_choice (
	BOOL	display_charset,
	int	i)
d1004 2
a1005 3
static int parse_charset_choice (
	char *	p,
	BOOL	display_charset) /*if FALSE, then assumed doc charset*/
d1010 1
a1010 1
    /*only one charset choice is allowed per line!*/
d1014 1
a1014 1
	(display_charset ? "display charset" : "assumed doc charset"), p));
d1017 1
a1017 1
	CTRACE((tfp," - EMPTY STRING\n"));
d1022 1
a1022 1
	    for (custom_display_charset = TRUE, i = 0 ;i < LYNumCharsets; ++i)
d1027 1
a1027 1
	CTRACE((tfp," - all unhidden\n"));
d1030 1
a1030 1
    if (p[len-1] == '*') {
d1032 1
a1032 1
	for (i = 0 ;i < LYNumCharsets; ++i) {
d1034 1
a1034 1
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len)) ) {
d1039 1
a1039 1
	CTRACE((tfp," - %d matches\n", matches));
d1043 2
a1044 2
	    if ((!strcasecomp(p,LYchar_set_names[i])) ||
		(!strcasecomp(p,LYCharSet_UC[i].MIMEname)) ) {
d1046 1
a1046 1
		CTRACE((tfp," - OK\n"));
d1051 1
a1051 1
	CTRACE((tfp," - NOT recognised\n"));
d1056 1
a1056 1
static int parse_display_charset_choice (char*p)
d1058 1
a1058 1
    return parse_charset_choice(p,1);
d1061 1
a1061 1
static int parse_assumed_doc_charset_choice (char*p)
d1063 1
a1063 1
    return parse_charset_choice(p,0);
d1069 2
a1070 3
static void html_src_bad_syntax (
	    char* value,
	    char* option_name)
d1074 1
a1074 1
    HTSprintf0(&buf,"HTMLSRC_%s", option_name);
d1076 1
a1076 1
    fprintf(stderr,"Bad syntax in TAGSPEC %s:%s\n", buf, value);
d1080 12
a1091 12
static int parse_html_src_spec (
	    HTlexeme lexeme_code,
	    char* value,
	    char* option_name)
{
   /* Now checking the value for being correct.  Since HTML_dtd is not
    * initialized completely (member tags points to non-initiailized data), we
    * use tags_old.  If the syntax is incorrect, then lynx will exit with error
    * message.
    */
    char* ts2;
    if (isEmpty(value)) return 0; /* silently ignoring*/
d1095 1
a1095 1
    ts2 = strchr(value,':');
d1100 2
a1101 1
    CTRACE((tfp,"ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",value,ts2,option_name));
d1103 2
a1104 3
    if ( html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE) )
    {
d1110 1
a1110 1
    StrAllocCopy(HTL_tagspecs[lexeme_code],value);
d1115 1
a1115 1
static int psrcspec_fun (char*s)
d1117 2
a1118 1
    char* e;
d1135 2
d1141 3
a1143 1
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",s));
d1148 3
a1150 1
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",s,e+1));
d1153 1
a1153 1
    parse_html_src_spec(found, e+1, s);
d1157 1
a1157 1
static int read_htmlsrc_attrname_xform ( char*str)
d1160 6
a1165 3
    if ( 1 == sscanf(str, "%d", &val) ) {
	if (val<0 || val >2) {
	    CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n", val));
d1169 2
a1170 2
	CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored): %s\n",
		    str));
d1175 1
a1175 1
static int read_htmlsrc_tagname_xform ( char*str)
d1178 6
a1183 3
    if ( 1 == sscanf(str,"%d",&val) ) {
	if (val<0 || val >2) {
	    CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n", val));
d1187 2
a1188 2
	CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored): %s\n",
		    str));
d1195 1
a1195 2
static int screen_size_fun (
	char *		value)
d1200 1
a1200 1
	*cp++ = '\0';       /* Terminate ID */
d1219 1
d1420 1
d1422 1
d1517 1
d1520 1
d1528 1
a1528 1
void free_lynx_cfg (void)
d1540 1
d1575 1
a1575 2
static Config_Type *lookup_config (
	char *		name)
d1584 1
a1584 1
	    && (0 == strcasecomp (name, tbl->name)))
d1600 3
a1602 4
static char *actual_filename (
    char *	cfg_filename,
    char *	parent_filename,
    char *	dft_filename)
d1607 1
a1607 1
     && !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
d1609 1
a1609 1
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename+1);
d1613 1
a1613 1
		*LYPathLeaf (my_filename) = '\0';
d1618 1
a1618 1
		*LYPathLeaf (my_filename) = '\0';
d1631 3
a1633 4
FILE *LYOpenCFG (
    char *	cfg_filename,
    char *	parent_filename,
    char *	dft_filename)
d1646 3
a1648 2
typedef BOOL (optidx_set_t) [ NOPTS_ ];
 /* if element is FALSE, then it's allowed in the current file*/
d1661 2
a1662 3
void LYSetConfigValue (
    char *	name,
    char *	value)
d1671 1
a1671 1
	    *(q->set_value) = is_true (value);
d1682 2
a1683 1
	    if (1 == sscanf (value, "%f", &ival)) {
d1697 2
a1698 1
	    if (1 == sscanf (value, "%d", &ival))
d1716 1
a1716 1
	if (LYGetEnv (name) == 0) {
d1722 3
a1724 2
	    HTSprintf0 (q->str_value, "%s=%s", name, value);
	    putenv (*(q->str_value));
d1730 1
a1730 1
	    add_item_to_list (value, q->add_value, FALSE);
d1735 1
a1735 1
	add_trusted (value, q->def_value);
d1756 5
a1760 6
static void do_read_cfg (
	char * cfg_filename,
	char * parent_filename,
	int	nesting_level,
	FILE *	fp0,
	optidx_set_t* allowed)
d1768 2
a1769 2
     *	Don't get hung up by an include file loop.  Arbitrary max depth
     *	of 10.	- BL
d1775 2
a1776 2
	fprintf(stderr,gettext("Last attempted include was '%s',\n"), cfg_filename);
	fprintf(stderr,gettext("included from '%s'.\n"), parent_filename);
d1780 1
a1780 1
     *	Locate and open the file.
d1783 1
a1783 1
	CTRACE((tfp,"No filename following -cfg switch!\n"));
d1793 1
a1793 1
     *	Process each line in the file.
d1798 1
d1819 2
a1820 1
	if (*name == 0) continue;
d1823 1
a1823 1
	if ((value = strchr (name, ':')) == 0) {
d1833 1
a1833 1
	 *  Trim off any trailing comments.
d1835 3
a1837 3
	 *  (Apparently, the original code considers a trailing comment
	 *   valid only if preceded by a space character but is not followed
	 *   by a colon.  -- JED)
d1839 1
a1839 1
	if ((cp = strrchr (value, ':')) == 0)
d1841 1
a1841 1
	if ((cp = strchr (cp, '#')) != 0) {
d1859 1
a1859 1
	if ( allowed && (*allowed)[ tbl-Config_Table ] ) {
d1861 2
a1862 2
		fprintf (stderr, "%s is not allowed in the %s\n",
		    name,cfg_filename);
d1864 2
a1865 2
	    the html representation of lynx.cfg - say include this line
	    in bold, or something...*/
d1887 10
a1896 10
	case CONF_INCLUDE: {
	    /* include another file */
	    optidx_set_t cur_set, anded_set;
	    optidx_set_t* resultant_set = NULL;
	    char* p1, *p2, savechar;
	    BOOL any_optname_found = FALSE;

	    char *url = NULL;
	    char *cp1 = NULL;
	    char *sep = NULL;
d1898 1
a1898 1
	    if ( (p1 = strstr(value, sep = " for ")) != 0
d1900 1
a1900 1
		|| (p1 = strstr(value, sep = ":")) != 0
d1902 7
a1908 4
	    ) {
		*p1 = '\0';
		p1 += strlen(sep);
	    }
d1910 6
a1915 3
#ifndef NO_CONFIG_INFO
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
		char *my_file = actual_filename(value, cfg_filename, LYNX_CFG_FILE);
d1917 2
a1918 5
		LYLocalFileToURL(&url, my_file);
		FREE(my_file);
		StrAllocCopy(cp1, value);
		if (strchr(value, '&') || strchr(value, '<')) {
		    LYEntify(&cp1, TRUE);
a1919 4

		fprintf(fp0, "%s:<a href=\"%s\">%s</a>\n\n", name, url, cp1);
		fprintf(fp0, "    #&lt;begin  %s&gt;\n", cp1);
	    }
d1922 23
a1944 19
	    if (p1) {
		while (*(p1 = LYSkipBlanks(p1)) != 0) {
		    Config_Type *tbl2;

		    p2 = LYSkipNonBlanks(p1);
		    savechar = *p2;
		    *p2 = 0;

		    tbl2 = lookup_config(p1);
		    if (tbl2->name == 0) {
			if (fp0 == NULL)
			    fprintf (stderr, "unknown option name %s in %s\n",
				     p1, cfg_filename);
		    } else {
			unsigned i;
			if (!any_optname_found) {
			    any_optname_found = TRUE;
			    for (i = 0; i < NOPTS_; ++i)
				cur_set[i] = TRUE;
d1946 4
a1949 1
			cur_set[tbl2 - Config_Table] = FALSE;
d1951 4
a1954 2
		    if (savechar && p2[1])
			p1 = p2 + 1;
d1956 8
a1963 14
			break;
		}
	    }
	    if (!allowed) {
		if (!any_optname_found)
		    resultant_set = NULL;
		else
		    resultant_set = &cur_set;
	    } else {
		if (!any_optname_found)
		    resultant_set = allowed;
		else {
		    optidx_set_AND(anded_set, *allowed, cur_set);
		    resultant_set = &anded_set;
a1964 1
	    }
d1967 19
a1985 17
	    /*
	     * Now list the opts that are allowed in included file.  If all
	     * opts are allowed, then emit nothing, else emit an effective set
	     * of allowed options in <ul>.  Option names will be uppercased.
	     * FIXME:  uppercasing option names can be considered redundant.
	     */
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo && resultant_set) {
		char *buf = NULL;
		unsigned i;

		fprintf(fp0,"     Options allowed in this file:\n");
		for (i = 0; i < NOPTS_; ++i) {
		    if ((*resultant_set)[i])
			continue;
		    StrAllocCopy(buf, Config_Table[i].name);
		    LYUpperCase(buf);
		    fprintf(fp0,"         * %s\n", buf);
a1986 2
		FREE(buf);
	    }
d1988 1
a1988 1
	    do_read_cfg (value, cfg_filename, nesting_level + 1, fp0,resultant_set);
d1991 5
a1995 5
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
		fprintf(fp0, "    #&lt;end of %s&gt;\n\n", cp1);
		FREE(url);
		FREE(cp1);
	    }
d2004 1
d2017 1
a2017 1
    LYCloseInput (fp);
d2020 4
a2023 4
     *	If any DOWNLOADER: commands have always_enabled set (:TRUE),
     *	make override_no_download TRUE, so that other restriction
     *	settings will not block presentation of a download menu
     *	with those always_enabled options still available. - FM
d2049 4
a2052 5
void read_cfg (
	char * cfg_filename,
	char * parent_filename,
	int	nesting_level,
	FILE *	fp0)
d2059 2
a2060 4
static void extra_cfg_link (
	FILE *	fp,
	char *	href,
	char *	name)
d2068 3
a2070 3
 *  Show rendered lynx.cfg data without comments, LYNXCFG:/ internal page.
 *  Called from getfile() cycle:
 *  we create and load the page just in place and return to mainloop().
d2072 1
a2072 2
int lynx_cfg_infopage (
    DocInfo *		       newdoc)
d2075 1
a2075 1
    DocAddress WWWDoc;  /* need on exit */
a2079 1

d2088 3
a2090 3
	 *  Some stuff to reload read_cfg(),
	 *  but also load options menu items and command-line options
	 *  to make things consistent.	Implemented in LYMain.c
d2095 2
a2096 2
	 *  now pop-up and return to updated LYNXCFG:/ page,
	 *  remind postoptions() but much simpler:
d2099 2
a2100 2
	 *  But check whether the top history document is really
	 *  the expected LYNXCFG: page. - kw
d2104 2
a2105 2
	    !strcmp(HTLoadedDocumentURL(), HDOC(nhist-1).address) &&
	    LYIsUIPage(HDOC(nhist-1).address, UIP_LYNXCFG) &&
d2116 2
a2117 2
	    LYforce_no_cache = FALSE;   /* ! */
	    LYoverride_no_cache = TRUE; /* ! */
d2120 4
a2123 3
	     * Working out of getfile() cycle we reset *no_cache manually here so
	     * HTLoadAbsolute() will return "Document already in memory":  it was
	     * forced reloading obsolete file again without this (overhead).
d2125 2
a2126 2
	     * Probably *no_cache was set in a wrong position because of
	     * the internal page...
d2129 1
a2129 1
		return(NOT_FOUND);
d2131 1
a2131 1
	    HTuncache_current_document();  /* will never use again */
d2141 15
a2155 15
     * We regenerate the file if reloading has been requested (with
     * LYK_NOCACHE key).  If we did not regenerate, there would be no
     * way to recover in a session from a situation where the file is
     * corrupted (for example truncated because the file system was full
     * when it was first created - lynx doesn't check for write errors
     * below), short of manual complete removal or perhaps forcing
     * regeneration with LYNXCFG://reload.  Similarly, there would be no
     * simple way to get a different page if user_mode has changed to
     * Advanced after the file was first generated in a non-Advanced mode
     * (the difference being in whether the page includes the link to
     * LYNXCFG://reload or not).
     * We also try to regenerate the file if lynxcfginfo_url is set,
     * indicating that tempfile is valid, but the file has disappeared anyway.
     * This can happen to a long-lived lynx process if for example some system
     * script periodically cleans up old files in the temp file space. - kw
d2159 1
a2159 1
	FREE(lynxcfginfo_url); /* flag to code below to regenerate - kw */
d2161 2
a2162 2
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(lynxcfginfo_url); /* flag to code below to try again - kw */
d2168 1
a2168 1
	    return(NOT_FOUND);
d2172 1
a2172 1
	LYforce_no_cache = TRUE;  /* don't cache this doc */
d2174 1
a2174 1
	BeginInternalPage (fp0, LYNXCFG_TITLE, NULL);
d2182 2
a2183 2
			     gettext("The following is read from your lynx.cfg file."),
			     gettext("Please read the distribution"));
d2186 1
a2186 1
			     temp);
d2189 1
a2189 1
			     gettext("for more comments."));
d2193 1
a2193 1
	    /* no absolute path... for lynx.cfg on DOS/Win32 */
d2195 2
a2196 2
			     gettext("The following is read from your lynx.cfg file."),
			     gettext("Please read the distribution"));
d2199 1
a2199 1
			     gettext("for more comments."));
d2234 2
a2235 3
			     STR_LYNXCFG,
			     gettext("RELOAD THE CHANGES"));

d2243 3
a2245 3
			gettext("Your primary configuration"),
			temp,
			cp1);
d2252 2
a2253 1
	fprintf(fp0, "<em>%s</em>\n\n", gettext("The following is read from your lynx.cfg file."));
d2256 1
a2256 1
	 *  Process the configuration file.
d2276 1
a2276 1
	return(NOT_FOUND);
d2280 1
a2280 1
    return(NORMAL);
a2282 1

d2285 2
a2286 2
 *  Compile-time definitions info, LYNXCOMPILEOPTS:/ internal page,
 *  from getfile() cycle.
d2288 1
a2288 2
int lynx_compile_opts (
    DocInfo *		       newdoc)
d2291 1
d2295 1
a2295 1
    DocAddress WWWDoc;  /* need on exit */
d2299 2
a2300 1
     * change...  But we will regenerate the file anyway, in two situations:
d2303 10
a2312 8
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did
     * not regenerate, there would be no way to recover in a session from
     * a situation where the file is corrupted (for example truncated because
     * the file system was full when it was first created - lynx doesn't
     * check for write errors below), short of manual complete removal or
     * forcing regeneration with LYNXCFG://reload.
     * (c) configinfo_url is set, indicating that tempfile is valid, but
     * the file has disappeared anyway.  This can happen to a long-lived lynx
d2314 1
a2314 1
     * files in the temp file space. - kw
d2318 1
a2318 1
	FREE(configinfo_url); /* flag to code below to regenerate - kw */
d2320 2
a2321 2
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(configinfo_url); /* flag to code below to try again - kw */
d2326 1
a2326 1
	    return(NOT_FOUND);
d2330 1
a2330 1
	BeginInternalPage (fp0, CONFIG_DEF_TITLE, NULL);
d2357 1
a2357 1
	return(NOT_FOUND);
d2361 1
a2361 1
    return(NORMAL);
@


1.5
log
@* bump to 0x079D (a bit late for tiff, but hey)
* sync lists
* regenerate configure files
* remove MirLibtool, go back to gcc3 libtool :-(
* fix for $stuff
* remove dupes (libz, etc.) and unused (libintl, getopt)
* update lynx
* update texinfo.tex
etc.

XXX borked commit, eleventh try
@
text
@d1 1
a1 1
/* $MirBSD$ */
d44 2
a45 2
PUBLIC BOOLEAN have_read_cfg = FALSE;
PUBLIC BOOLEAN LYUseNoviceLineTwo = TRUE;
d50 2
a51 2
PRIVATE BOOL is_true ARGS1(
	char *, string)
d62 2
a63 2
PRIVATE char *find_colon ARGS1(
	char *, buffer)
d83 2
a84 2
PRIVATE void free_item_list ARGS1(
    lynx_list_item_type **,	ptr)
d102 1
a102 1
PRIVATE void free_all_item_lists NOARGS
d120 4
a123 4
PRIVATE void add_item_to_list ARGS3(
	char *,			buffer,
	lynx_list_item_type **, list_ptr,
	int,			special)
d208 3
a210 3
PUBLIC lynx_list_item_type *find_item_by_number ARGS2(
	lynx_list_item_type *,	list_ptr,
	char *,			number)
d219 4
a222 4
PUBLIC int match_item_by_name ARGS3(
    lynx_list_item_type *,	ptr,
    char *,			name,
    BOOLEAN,			only_overriders)
d248 1
a248 1
PRIVATE CONST char *Color_Strings[16] =
d273 2
a274 2
PRIVATE int ColorCode ARGS1(
	int,	color)
d290 3
a292 3
PUBLIC int check_color ARGS2(
	char *, color,
	int,	the_default)
d320 2
a321 2
PUBLIC CONST char *lookup_color ARGS1(
    int,	code)
d337 2
a338 2
PRIVATE void exit_with_color_syntax ARGS1(
	char *,		error_line)
d363 2
a364 2
PRIVATE void parse_color ARGS1(
	char *, buffer)
d448 1
a448 1
   CONST char *name;
d455 2
a456 2
PRIVATE int assume_charset_fun ARGS1(
	char *,		value)
d468 2
a469 2
PRIVATE int assume_local_charset_fun ARGS1(
	char *,		value)
d475 2
a476 2
PRIVATE int assume_unrec_charset_fun ARGS1(
	char *,		value)
d482 2
a483 2
PRIVATE int character_set_fun ARGS1(
	char *,		value)
d502 2
a503 2
PRIVATE int outgoing_mail_charset_fun ARGS1(
	char *,		value)
d515 2
a516 2
PRIVATE int assumed_color_fun ARGS1(
	char *, buffer)
d552 2
a553 2
PRIVATE int color_fun ARGS1(
	char *,		value)
d560 2
a561 2
PRIVATE int default_bookmark_file_fun ARGS1(
	char *,		value)
d567 2
a568 2
PRIVATE int default_cache_size_fun ARGS1(
	char *,		value)
d575 2
a576 2
PRIVATE int default_editor_fun ARGS1(
	char *,		value)
d582 2
a583 2
PRIVATE int numbers_as_arrows_fun ARGS1(
	char *,		value)
d594 2
a595 2
PRIVATE int dired_menu_fun ARGS1(
	char *,		value)
d602 2
a603 2
PRIVATE int jumpfile_fun ARGS1(
	char *,		value)
d616 2
a617 2
PRIVATE int keyboard_layout_fun ARGS1(
	char *,		key)
d625 2
a626 2
PRIVATE int keymap_fun ARGS1(
	char *,		key)
d723 2
a724 2
PRIVATE int localhost_alias_fun ARGS1(
	char *,		value)
d731 2
a732 2
PRIVATE int lynxcgi_environment_fun ARGS1(
	char *,		value)
d739 2
a740 2
PRIVATE int lynx_sig_file_fun ARGS1(
	char *,		value)
d756 2
a757 2
PRIVATE int news_chunk_size_fun ARGS1(
	char *,		value)
d769 2
a770 2
PRIVATE int news_max_chunk_fun ARGS1(
	char *,		value)
d782 2
a783 2
PRIVATE int news_posting_fun ARGS1(
	char *,		value)
d792 2
a793 2
PRIVATE int cern_rulesfile_fun ARGS1(
	char *,		value)
d826 2
a827 2
PRIVATE int printer_fun ARGS1(
	char *,		value)
d833 2
a834 2
PRIVATE int referer_with_query_fun ARGS1(
	char *,		value)
d845 2
a846 2
PRIVATE int suffix_fun ARGS1(
	char *,		value)
d923 2
a924 2
PRIVATE int suffix_order_fun ARGS1(
	char *,		value)
d951 2
a952 2
PRIVATE int system_editor_fun ARGS1(
	char *,		value)
d959 2
a960 2
PRIVATE int viewer_fun ARGS1(
	char *,		value)
d1003 2
a1004 2
PRIVATE int nonrest_sigwinch_fun ARGS1(
	char *,		value)
d1015 3
a1017 3
PRIVATE void matched_charset_choice ARGS2(
	BOOL,	display_charset,
	int,	i)
d1034 3
a1036 3
PRIVATE int parse_charset_choice ARGS2(
	char *,	p,
	BOOL,	display_charset) /*if FALSE, then assumed doc charset*/
d1087 1
a1087 1
PRIVATE int parse_display_charset_choice ARGS1(char*,p)
d1092 1
a1092 1
PRIVATE int parse_assumed_doc_charset_choice ARGS1(char*,p)
d1100 3
a1102 3
PRIVATE void html_src_bad_syntax ARGS2(
	    char*, value,
	    char*, option_name)
d1112 4
a1115 4
PRIVATE int parse_html_src_spec ARGS3(
	    HTlexeme, lexeme_code,
	    char*, value,
	    char*, option_name)
d1147 1
a1147 1
PRIVATE int psrcspec_fun ARGS1(char*,s)
d1182 1
a1182 1
PRIVATE int read_htmlsrc_attrname_xform ARGS1( char*,str)
d1197 1
a1197 1
PRIVATE int read_htmlsrc_tagname_xform ARGS1( char*,str)
d1214 2
a1215 2
PRIVATE int screen_size_fun ARGS1(
	char *,		value)
d1239 1
a1239 1
PRIVATE Config_Type Config_Table [] =
d1535 1
a1535 1
PRIVATE char *lynxcfginfo_url = NULL;	/* static */
d1537 1
a1537 1
PRIVATE char *configinfo_url = NULL;	/* static */
d1543 1
a1543 1
PUBLIC void free_lynx_cfg NOARGS
d1589 2
a1590 2
PRIVATE Config_Type *lookup_config ARGS1(
	char *,		name)
d1615 4
a1618 4
PRIVATE char *actual_filename ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
d1647 4
a1650 4
PUBLIC FILE *LYOpenCFG ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
d1677 3
a1679 3
PUBLIC void LYSetConfigValue ARGS2(
    char *,	name,
    char *,	value)
d1770 6
a1775 6
PRIVATE void do_read_cfg ARGS5(
	char *, cfg_filename,
	char *, parent_filename,
	int,	nesting_level,
	FILE *,	fp0,
	optidx_set_t*, allowed)
d2060 5
a2064 5
PUBLIC void read_cfg ARGS4(
	char *, cfg_filename,
	char *, parent_filename,
	int,	nesting_level,
	FILE *,	fp0)
d2071 4
a2074 4
PRIVATE void extra_cfg_link ARGS3(
	FILE *,	fp,
	char *,	href,
	char *,	name)
d2086 2
a2087 2
PUBLIC int lynx_cfg_infopage ARGS1(
    DocInfo *,		       newdoc)
d2304 2
a2305 2
PUBLIC int lynx_compile_opts ARGS1(
    DocInfo *,		       newdoc)
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d1 2
d1376 3
d1380 1
a1384 1
     PARSE_FUN(RC_LOCALHOST_ALIAS,      localhost_alias_fun),
d1509 1
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d399 1
a399 1
#ifdef SOURCE_CACHE
d1211 25
d1282 1
a1282 1
#ifdef EXP_PERSISTENT_COOKIES
d1284 1
a1284 1
#endif /* EXP_PERSISTENT_COOKIES */
d1288 1
a1288 1
#ifdef EXP_PERSISTENT_COOKIES
d1290 1
a1290 1
#endif /* EXP_PERSISTENT_COOKIES */
d1428 1
a1428 1
#ifdef EXP_PERSISTENT_COOKIES
d1430 1
a1430 1
#endif /* EXP_PERSISTENT_COOKIES */
d1457 3
d1473 1
a1473 1
#ifdef SOURCE_CACHE
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d6 1
d8 1
d29 1
d39 1
a39 2
extern int HTNewsMaxChunk;  /* Max news articles before chunking (HTNews.c) */
extern int HTNewsChunkSize; /* Number of news articles per chunk (HTNews.c) */
d48 1
a48 1
PRIVATE int is_true ARGS1(
d81 2
a82 4
/*
 *  Function for freeing the DOWNLOADER and UPLOADER menus list. - FM
 */
PRIVATE void free_item_list NOARGS
d84 2
a85 2
    lynx_html_item_type *cur;
    lynx_html_item_type *next;
a86 1
    cur = downloaders;
d94 2
a95 1
    downloaders = NULL;
d97 7
d105 1
a105 9
    cur = uploaders;
    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
    }
    uploaders = NULL;
d109 1
a109 9
    cur = externals;
    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
    }
    externals = NULL;
d118 1
a118 1
PRIVATE void add_item_to_list ARGS2(
d120 2
a121 1
	lynx_html_item_type **, list_ptr)
d124 1
a124 1
    lynx_html_item_type *cur_item, *prev_item;
d133 1
a133 1
	cur_item = (lynx_html_item_type *)calloc(sizeof(lynx_html_item_type),1);
d138 1
a138 1
	atexit(free_item_list);
d148 1
a148 1
	cur_item = (lynx_html_item_type *)calloc(sizeof(lynx_html_item_type),1);
d158 2
d168 1
a168 1
	cur_item->name = (char *)calloc((colon-buffer+1),sizeof(char));
d175 4
a178 2
	 *  Process TRUE/FALSE field.  If we do not find one, assume it is
	 *  true.  In any case, we want the command string.
d184 1
a184 1
	    cur_item->command = (char *)calloc(next_colon-colon, sizeof(char));
a188 1
	    cur_item->always_enabled = TRUE;
d191 11
a201 1
	    cur_item->always_enabled = is_true(next_colon);
d206 20
a225 19

/*
 *  Function for freeing the PRINTER menus list. - FM
 */
PRIVATE void free_printer_item_list NOARGS
{
    lynx_printer_item_type *cur = printers;
    lynx_printer_item_type *next;

    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
    }
    printers = NULL;

    return;
d228 1
a228 9
/*
 *  Process string buffer fields for PRINTER menus.
 */
PRIVATE void add_printer_to_list ARGS2(
	char *,				buffer,
	lynx_printer_item_type **,	list_ptr)
{
    char *colon, *next_colon;
    lynx_printer_item_type *cur_item, *prev_item;
d230 2
a231 13
    /*
     *	Make a linked list.
     */
    if (*list_ptr == NULL) {
	/*
	 *  First item.
	 */
	cur_item = (lynx_printer_item_type *)calloc(sizeof(lynx_printer_item_type),1);
	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");
	*list_ptr = cur_item;
#ifdef LY_FIND_LEAKS
	atexit(free_printer_item_list);
a232 32
    } else {
	/*
	 *  Find the last item.
	 */
	for (prev_item = *list_ptr;
	     prev_item->next != NULL;
	     prev_item = prev_item->next)
	    ;  /* null body */

	cur_item = (lynx_printer_item_type *)calloc(sizeof(lynx_printer_item_type),1);
	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");
	else
	    prev_item->next = cur_item;
    }
    cur_item->next = NULL;
    cur_item->name = NULL;
    cur_item->command = NULL;
    cur_item->always_enabled = FALSE;

    /*
     *	Find first unescaped colon and process fields.
     */
    if ((colon = find_colon(buffer)) != NULL) {
	/*
	 *  Process name field.
	 */
	cur_item->name = (char *)calloc((colon-buffer+1), sizeof(char));
	if (cur_item->name == NULL)
	    outofmem(__FILE__, "read_cfg");
	LYstrncpy(cur_item->name, buffer, (int)(colon-buffer));
	remove_backslashes(cur_item->name);
d234 1
a234 29
	/*
	 *  Process TRUE/FALSE field.
	 */
	if ((next_colon = find_colon(colon+1)) != NULL) {
	    cur_item->command = (char *)calloc(next_colon-colon, sizeof(char));
	    if (cur_item->command == NULL)
		outofmem(__FILE__, "read_cfg");
	    LYstrncpy(cur_item->command, colon+1, (int)(next_colon-(colon+1)));
	    remove_backslashes(cur_item->command);
	    cur_item->always_enabled = is_true(next_colon+1);
	}

	/*
	 *  Process pagelen field.
	 */
	if (next_colon != NULL
	 && (next_colon = find_colon(next_colon+1)) != NULL) {
	    cur_item->pagelen = atoi(next_colon+1);
	} else {
	    /* default to 66 lines */
	    cur_item->pagelen = 66;
	}
    }
}

#if defined(USE_COLOR_STYLE) || defined(USE_COLOR_TABLE)

#ifdef USE_SLANG
#define COLOR_WHITE 7
d238 4
d244 1
d246 1
a246 1
static CONST char *Color_Strings[16] =
d266 1
a266 1
#ifdef DOSPATH
d283 2
d294 7
a300 1
    if (!strcasecomp(color, "default"))
d302 1
d307 6
a312 2
	if (!strcasecomp(color, Color_Strings[i]))
	    return ColorCode(i);
d314 1
d317 11
d330 1
a330 1
#if defined(USE_COLOR_TABLE)
d353 1
a353 1
    exit_immediately(-1);
d355 1
d357 1
d384 2
a385 2
    if ((check_color(fg, default_fg) < 0) ||
	(check_color(bg, default_bg) < 0))
d399 7
a405 1
typedef int (*ParseFunc) PARAMS((char *));
d407 5
a411 33
typedef union {
	lynx_html_item_type ** add_value;
	BOOLEAN * set_value;
	int *	  int_value;
	char **   str_value;
	ParseFunc fun_value;
	long	  def_value;
} ConfigUnion;

#ifdef	PARSE_DEBUG
#define ParseData \
	lynx_html_item_type** add_value; \
	BOOLEAN *set_value; \
	int *int_value; \
	char **str_value; \
	ParseFunc fun_value; \
	long def_value
#define PARSE_ADD(n,t,v) {n,t,	 &v,  0,  0,  0,  0,  0}
#define PARSE_SET(n,t,v) {n,t,	  0,  v,  0,  0,  0,  0}
#define PARSE_INT(n,t,v) {n,t,	  0,  0,  v,  0,  0,  0}
#define PARSE_STR(n,t,v) {n,t,	  0,  0,  0,  v,  0,  0}
#define PARSE_ENV(n,t,v) {n,t,	  0,  0,  0,  v,  0,  0}
#define PARSE_FUN(n,t,v) {n,t,	  0,  0,  0,  0,  v,  0}
#define PARSE_DEF(n,t,v) {n,t,	  0,  0,  0,  0,  0,  v}
#else
#define ParseData long value
#define PARSE_ADD(n,t,v) {n,t,	 (long)&(v)}
#define PARSE_SET(n,t,v) {n,t,	 (long) (v)}
#define PARSE_INT(n,t,v) {n,t,	 (long) (v)}
#define PARSE_STR(n,t,v) {n,t,	 (long) (v)}
#define PARSE_ENV(n,t,v) {n,t,	 (long) (v)}
#define PARSE_FUN(n,t,v) {n,t,	 (long) (v)}
#define PARSE_DEF(n,t,v) {n,t,	 (long) (v)}
d414 30
d447 1
a447 12
   int type;
#define CONF_UNSPECIFIED	0
#define CONF_BOOL		1      /* BOOLEAN type */
#define CONF_FUN		2
#define CONF_INT		3
#define CONF_STR		4
#define CONF_ENV		5      /* from environment variable */
#define CONF_ENV2		6      /* from environment VARIABLE */
#define CONF_INCLUDE		7      /* include file-- handle special */
#define CONF_ADD_ITEM		8
#define CONF_ADD_TRUSTED	9

d449 1
d453 1
a453 1
static int assume_charset_fun ARGS1(
d466 1
a466 1
static int assume_local_charset_fun ARGS1(
d473 1
a473 1
static int assume_unrec_charset_fun ARGS1(
d480 1
a480 1
static int character_set_fun ARGS1(
d484 10
a493 2
    if (i < 0)
	; /* do nothing here: so fallback to userdefs.h */
d500 1
a500 1
static int outgoing_mail_charset_fun ARGS1(
d509 39
d550 1
a550 1
static int color_fun ARGS1(
d558 1
a558 1
static int default_bookmark_file_fun ARGS1(
d561 1
a561 4
    StrAllocCopy(bookmark_page, value);
    StrAllocCopy(BookmarkPage, bookmark_page);
    StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
    StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
d565 1
a565 1
static int default_cache_size_fun ARGS1(
d573 1
a573 1
static int default_editor_fun ARGS1(
d580 1
a580 1
static int numbers_as_arrows_fun ARGS1(
a590 13
static int default_user_mode_fun ARGS1(
	char *,		value)
{
    if (!strncasecomp(value, "NOVICE", 6))
	user_mode = NOVICE_MODE;
    else if (!strncasecomp(value, "INTER", 5))
	user_mode = INTERMEDIATE_MODE;
    else if (!strncasecomp(value, "ADVANCE", 7))
	user_mode = ADVANCED_MODE;

   return 0;
}

d592 1
a592 1
static int dired_menu_fun ARGS1(
d600 1
a600 1
static int jumpfile_fun ARGS1(
d607 1
a607 1
	CTRACE(tfp, "Failed to register %s\n", buffer);
d614 1
a614 1
static int keyboard_layout_fun ARGS1(
d618 1
a618 1
	CTRACE(tfp, "Failed to set keyboard layout %s\n", key);
d623 1
a623 1
static int keymap_fun ARGS1(
d626 1
a626 1
    char *func;
d628 1
a628 1
    if ((func = strchr(key, ':')) != NULL)	{
d630 1
d632 85
a716 7
	if (!remap(key, strtok(func, " \t\n#")))
	    fprintf(stderr, "%s%s%s%s%s\n",
		    gettext("key remapping of "),
		    key, TO_SEGMENT, func,
		    gettext(" failed"));
	else if (!strcmp("TOGGLE_HELP", strtok(func, " \t\n#")))
	    LYUseNoviceLineTwo = FALSE;
d721 1
a721 1
static int localhost_alias_fun ARGS1(
d729 1
a729 1
static int lynxcgi_environment_fun ARGS1(
d737 1
a737 1
static int lynx_sig_file_fun ARGS1(
d746 1
a746 1
	CTRACE(tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile);
d748 1
a748 1
	CTRACE(tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE);
d754 1
a754 1
static int news_chunk_size_fun ARGS1(
d767 1
a767 1
static int news_max_chunk_fun ARGS1(
d780 1
a780 1
static int news_posting_fun ARGS1(
d784 1
a784 1
    no_newspost = (LYNewsPosting == FALSE);
d790 1
a790 1
static int cern_rulesfile_fun ARGS1(
d819 1
a819 1
    exit_immediately(69);	/* EX_UNAVAILABLE in sysexits.h */
d824 1
a824 1
static int printer_fun ARGS1(
d827 1
a827 1
    add_printer_to_list(value, &printers);
d831 1
a831 2
#ifdef SOURCE_CACHE
static int source_cache_fun ARGS1(
d834 6
a839 7
    if (!strncasecomp(value, "FILE", 4))
	LYCacheSource = SOURCE_CACHE_FILE;
    else if (!strncasecomp(value, "MEM", 3))
	LYCacheSource = SOURCE_CACHE_MEMORY;
    else if (!strncasecomp(value, "NONE", 4))
	LYCacheSource = SOURCE_CACHE_NONE;

a841 1
#endif
d843 1
a843 1
static int suffix_fun ARGS1(
d846 3
a848 1
    char *mime_type;
d851 2
a852 1
    || (NULL == (mime_type = strchr (value, ':'))))
d854 1
d857 21
d880 47
a926 1
    LYLowerCase(mime_type);
d928 13
a940 8
    if (strstr(mime_type, "tex") != NULL ||
	strstr(mime_type, "postscript") != NULL ||
	strstr(mime_type, "sh") != NULL ||
	strstr(mime_type, "troff") != NULL ||
	strstr(mime_type, "rtf") != NULL)
	HTSetSuffix(value, mime_type, "8bit", 1.0);
    else
	HTSetSuffix(value, mime_type, "binary", 1.0);
d942 4
d949 1
a949 1
static int system_editor_fun ARGS1(
d957 1
a957 1
static int viewer_fun ARGS1(
d1001 93
d1095 1
a1095 1
#ifdef USE_PSRC
d1097 2
a1098 1
static void html_src_bad_syntax ARGS2(
d1107 1
a1107 1
    exit_immediately(-1);
d1110 2
a1111 3

static int parse_html_src_spec ARGS3(
	    HTlexem, lexem_code,
d1121 1
a1121 1
    if ( !value || !*value) return 0; /* silently ignoring*/
d1130 4
a1133 2
    if ( html_src_parse_tagspec(value, lexem_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexem_code, TRUE, TRUE) )
d1140 1
a1140 2
    HTL_tagspecs[lexem_code] = NULL;
    StrAllocCopy(HTL_tagspecs[lexem_code],value);
d1145 34
a1178 17
#define defHTSRC_parse_fun(x) static int html_src_set_##x ARGS1( char*,str) \
 { parse_html_src_spec(HTL_##x,str,#x); return 0; }

defHTSRC_parse_fun(comm)
defHTSRC_parse_fun(tag)
defHTSRC_parse_fun(attrib)
defHTSRC_parse_fun(attrval)
defHTSRC_parse_fun(abracket)
defHTSRC_parse_fun(entity)
defHTSRC_parse_fun(href)
defHTSRC_parse_fun(entire)
defHTSRC_parse_fun(badseq)
defHTSRC_parse_fun(badtag)
defHTSRC_parse_fun(badattr)
defHTSRC_parse_fun(sgmlspecial)

#undef defHTSRC_parse_fun
d1180 1
a1180 1
static int read_htmlsrc_attrname_xform ARGS1( char*,str)
d1185 1
a1185 1
	    CTRACE(tfp,"bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n", val);
d1189 2
a1190 2
	CTRACE(tfp,"bad value for htmlsrc_attrname_xform (ignored): %s\n",
		    str);
d1195 1
a1195 1
static int read_htmlsrc_tagname_xform ARGS1( char*,str)
d1200 1
a1200 1
	    CTRACE(tfp,"bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n", val);
d1204 2
a1205 2
	CTRACE(tfp,"bad value for htmlsrc_tagname_xform (ignored): %s\n",
		    str);
a1208 5


#define defHTSRC_option(x) \
    PARSE_FUN( "htmlsrc_" #x ,CONF_FUN, html_src_set_##x),

d1211 2
a1212 3

/* This table should be sorted alphabetically */
static Config_Type Config_Table [] =
d1214 3
a1216 3
     PARSE_SET("accept_all_cookies", CONF_BOOL, &LYAcceptAllCookies),
     PARSE_INT("alertsecs", CONF_INT, &AlertSecs),
     PARSE_SET("always_resubmit_posts", CONF_BOOL, &LYresubmit_posts),
d1218 10
a1227 1
     PARSE_DEF("always_trusted_exec", CONF_ADD_TRUSTED, ALWAYS_EXEC_PATH),
d1229 21
a1249 11
     PARSE_FUN("assume_charset", CONF_FUN, assume_charset_fun),
     PARSE_FUN("assume_local_charset", CONF_FUN, assume_local_charset_fun),
     PARSE_FUN("assume_unrec_charset", CONF_FUN, assume_unrec_charset_fun),
     PARSE_SET("block_multi_bookmarks", CONF_BOOL, &LYMBMBlocked),
     PARSE_SET("bold_h1", CONF_BOOL, &bold_H1),
     PARSE_SET("bold_headers", CONF_BOOL, &bold_headers),
     PARSE_SET("bold_name_anchors", CONF_BOOL, &bold_name_anchors),
     PARSE_SET("case_sensitive_always_on", CONF_BOOL, &case_sensitive),
     PARSE_FUN("character_set", CONF_FUN, character_set_fun),
     PARSE_SET("checkmail", CONF_BOOL, &check_mail),
     PARSE_SET("collapse_br_tags", CONF_BOOL, &LYCollapseBRs),
d1251 1
a1251 1
     PARSE_FUN("color", CONF_FUN, color_fun),
d1253 10
a1262 1
     PARSE_STR("cookie_accept_domains", CONF_STR, &LYCookieSAcceptDomains),
d1264 1
a1264 1
     PARSE_STR("cookie_file", CONF_STR, &LYCookieFile),
d1266 2
a1267 5
     PARSE_STR("cookie_loose_invalid_domains", CONF_STR, &LYCookieSLooseCheckDomains),
     PARSE_STR("cookie_query_invalid_domains", CONF_STR, &LYCookieSQueryCheckDomains),
     PARSE_STR("cookie_reject_domains", CONF_STR, &LYCookieSRejectDomains),
     PARSE_STR("cookie_strict_invalid_domains", CONF_STR, &LYCookieSStrictCheckDomains),
     PARSE_ENV("cso_proxy", CONF_ENV, 0 ),
d1269 1
a1269 1
     PARSE_STR("CSWING_PATH", CONF_STR, &LYCSwingPath),
d1271 8
a1278 6
     PARSE_FUN("default_bookmark_file", CONF_FUN, default_bookmark_file_fun),
     PARSE_FUN("default_cache_size", CONF_FUN, default_cache_size_fun),
     PARSE_FUN("default_editor", CONF_FUN, default_editor_fun),
     PARSE_STR("default_index_file", CONF_STR, &indexfile),
     PARSE_FUN("default_keypad_mode_is_numbers_as_arrows", CONF_FUN, numbers_as_arrows_fun),
     PARSE_FUN("default_user_mode", CONF_FUN, default_user_mode_fun),
d1280 1
a1280 1
     PARSE_INT("default_virtual_memory_size", CONF_INT, &HTVirtualMemorySize),
d1283 4
a1286 1
     PARSE_FUN("dired_menu", CONF_FUN, dired_menu_fun),
d1288 4
a1291 3
     PARSE_ADD("downloader", CONF_ADD_ITEM, downloaders),
     PARSE_SET("emacs_keys_always_on", CONF_BOOL, &emacs_keys),
     PARSE_SET("enable_scrollback", CONF_BOOL, &enable_scrollback),
d1293 12
a1304 1
     PARSE_ADD("external", CONF_ADD_ITEM, externals),
a1305 3
     PARSE_ENV("finger_proxy", CONF_ENV, 0 ),
     PARSE_SET("force_8bit_toupper", CONF_BOOL, &UCForce8bitTOUPPER),
     PARSE_SET("force_ssl_cookies_secure", CONF_BOOL, &LYForceSSLCookiesSecure),
d1307 29
a1335 1
     PARSE_SET("forms_options", CONF_BOOL, &LYUseFormsOptions),
a1336 40
     PARSE_SET("ftp_passive", CONF_BOOL, &ftp_passive),
     PARSE_ENV("ftp_proxy", CONF_ENV, 0 ),
     PARSE_STR("global_extension_map", CONF_STR, &global_extension_map),
     PARSE_STR("global_mailcap", CONF_STR, &global_type_map),
     PARSE_ENV("gopher_proxy", CONF_ENV, 0 ),
     PARSE_SET("gotobuffer", CONF_BOOL, &goto_buffer),
     PARSE_STR("helpfile", CONF_STR, &helpfile),
     PARSE_SET("historical_comments", CONF_BOOL, &historical_comments),

#ifdef USE_PSRC

     defHTSRC_option(abracket)
     defHTSRC_option(attrib)

     PARSE_FUN("htmlsrc_attrname_xform", CONF_FUN, read_htmlsrc_attrname_xform),

     defHTSRC_option(attrval)
     defHTSRC_option(badattr)
     defHTSRC_option(badseq)
     defHTSRC_option(badtag)
     defHTSRC_option(comm)
     defHTSRC_option(entire)
     defHTSRC_option(entity)
     defHTSRC_option(href)
     defHTSRC_option(sgmlspecial)
     defHTSRC_option(tag)

     PARSE_FUN("htmlsrc_tagname_xform", CONF_FUN, read_htmlsrc_tagname_xform),


# undef defHTSRC_option
#endif

     PARSE_ENV("http_proxy", CONF_ENV, 0 ),
     PARSE_ENV("https_proxy", CONF_ENV, 0 ),
     PARSE_FUN("include", CONF_INCLUDE, 0),
     PARSE_INT("infosecs", CONF_INT, &InfoSecs),
     PARSE_STR("jump_prompt", CONF_STR, &jumpprompt),
     PARSE_SET("jumpbuffer", CONF_BOOL, &jump_buffer),
     PARSE_FUN("jumpfile", CONF_FUN, jumpfile_fun),
d1338 6
a1343 1
     PARSE_FUN("keyboard_layout", CONF_FUN, keyboard_layout_fun),
a1344 1
     PARSE_FUN("keymap", CONF_FUN, keymap_fun),
d1346 2
a1347 2
     PARSE_SET("list_news_numbers", CONF_BOOL, &LYListNewsNumbers),
     PARSE_SET("list_news_dates", CONF_BOOL, &LYListNewsDates),
d1349 1
a1349 5
#ifndef VMS
     PARSE_STR("list_format", CONF_STR, &list_format),
#endif
     PARSE_FUN("localhost_alias", CONF_FUN, localhost_alias_fun),
     PARSE_STR("local_domain", CONF_STR, &LYLocalDomain),
d1351 2
a1352 2
     PARSE_SET("local_execution_links_always_on", CONF_BOOL, &local_exec),
     PARSE_SET("local_execution_links_on_but_not_remote", CONF_BOOL, &local_exec_on_local_files),
d1354 3
a1357 1
     PARSE_FUN("lynxcgi_environment", CONF_FUN, lynxcgi_environment_fun),
d1359 1
a1359 1
     PARSE_STR("lynxcgi_document_root", CONF_STR, &LYCgiDocumentRoot),
d1361 1
d1363 2
a1364 5
     PARSE_STR("lynx_host_name", CONF_STR, &LYHostName),
     PARSE_FUN("lynx_sig_file", CONF_FUN, lynx_sig_file_fun),
     PARSE_SET("mail_system_error_logging", CONF_BOOL, &error_logging),
#ifdef VMS
     PARSE_STR("mail_adrs", CONF_STR, &mail_adrs),
d1366 9
a1374 6
     PARSE_SET("make_links_for_all_images", CONF_BOOL, &clickable_images),
     PARSE_SET("make_pseudo_alts_for_inlines", CONF_BOOL, &pseudo_inline_alts),
     PARSE_INT("messagesecs", CONF_INT, &MessageSecs),
     PARSE_SET("minimal_comments", CONF_BOOL, &minimal_comments),
     PARSE_SET("multi_bookmark_support", CONF_BOOL, &LYMultiBookmarks),
     PARSE_SET("ncr_in_bookmarks", CONF_BOOL, &UCSaveBookmarksInUnicode),
d1376 13
a1388 11
     PARSE_FUN("news_chunk_size", CONF_FUN, news_chunk_size_fun),
     PARSE_FUN("news_max_chunk", CONF_FUN, news_max_chunk_fun),
     PARSE_FUN("news_posting", CONF_FUN, news_posting_fun),
     PARSE_ENV("news_proxy", CONF_ENV, 0),
     PARSE_ENV("newspost_proxy", CONF_ENV, 0),
     PARSE_ENV("newsreply_proxy", CONF_ENV, 0),
     PARSE_ENV("nntp_proxy", CONF_ENV, 0),
     PARSE_ENV("nntpserver", CONF_ENV2, 0), /* actually NNTPSERVER */
#endif
     PARSE_SET("no_dot_files", CONF_BOOL, &no_dotfiles),
     PARSE_SET("no_file_referer", CONF_BOOL, &no_filereferer),
d1390 1
a1390 1
     PARSE_SET("no_forced_core_dump", CONF_BOOL, &LYNoCore),
d1392 7
a1398 5
     PARSE_SET("no_from_header", CONF_BOOL, &LYNoFromHeader),
     PARSE_SET("no_ismap_if_usemap", CONF_BOOL, &LYNoISMAPifUSEMAP),
     PARSE_ENV("no_proxy", CONF_ENV, 0 ),
     PARSE_SET("no_referer_header", CONF_BOOL, &LYNoRefererHeader),
     PARSE_FUN("outgoing_mail_charset", CONF_FUN, outgoing_mail_charset_fun),
d1400 2
a1401 2
     PARSE_SET("partial", CONF_BOOL, &display_partial_flag),
     PARSE_INT("partial_thres", CONF_INT, &partial_threshold),
d1404 1
a1404 1
     PARSE_SET("persistent_cookies", CONF_BOOL, &persistent_cookies),
d1406 20
a1425 8
     PARSE_STR("personal_mailcap", CONF_STR, &personal_type_map),
     PARSE_STR("personal_extension_map", CONF_STR, &personal_extension_map),
     PARSE_STR("preferred_charset", CONF_STR, &pref_charset),
     PARSE_STR("preferred_language", CONF_STR, &language),
     PARSE_SET("prepend_base_to_source", CONF_BOOL, &LYPrependBaseToSource),
     PARSE_SET("prepend_charset_to_source", CONF_BOOL, &LYPrependCharsetToSource),
     PARSE_FUN("printer", CONF_FUN, printer_fun),
     PARSE_SET("quit_default_yes", CONF_BOOL, &LYQuitDefaultYes),
d1427 2
a1428 2
     PARSE_FUN("rule", CONF_FUN, HTSetConfiguration),
     PARSE_FUN("rulesfile", CONF_FUN, cern_rulesfile_fun),
d1430 15
a1444 11
     PARSE_STR("save_space", CONF_STR, &lynx_save_space),
     PARSE_SET("scan_for_buried_news_refs", CONF_BOOL, &scan_for_buried_news_references),
     PARSE_SET("seek_frag_area_in_cur", CONF_BOOL, &LYSeekFragAREAinCur),
     PARSE_SET("seek_frag_map_in_cur", CONF_BOOL, &LYSeekFragMAPinCur),
     PARSE_SET("set_cookies", CONF_BOOL, &LYSetCookies),
     PARSE_SET("show_cursor", CONF_BOOL, &LYShowCursor),
     PARSE_SET("show_kb_rate", CONF_BOOL, &LYshow_kb_rate),
     PARSE_ENV("snews_proxy", CONF_ENV, 0 ),
     PARSE_ENV("snewspost_proxy", CONF_ENV, 0 ),
     PARSE_ENV("snewsreply_proxy", CONF_ENV, 0 ),
     PARSE_SET("soft_dquotes", CONF_BOOL, &soft_dquotes),
d1446 2
a1447 1
     PARSE_SET("source_cache", CONF_FUN, source_cache_fun),
d1449 20
a1468 8
     PARSE_STR("startfile", CONF_STR, &startfile),
     PARSE_SET("strip_dotdot_urls", CONF_BOOL, &LYStripDotDotURLs),
     PARSE_SET("substitute_underscores", CONF_BOOL, &use_underscore),
     PARSE_FUN("suffix", CONF_FUN, suffix_fun),
     PARSE_FUN("system_editor", CONF_FUN, system_editor_fun),
     PARSE_STR("system_mail", CONF_STR, &system_mail),
     PARSE_STR("system_mail_flags", CONF_STR, &system_mail_flags),
     PARSE_SET("tagsoup", CONF_BOOL, &Old_DTD),
d1470 1
a1470 1
     PARSE_DEF("trusted_exec", CONF_ADD_TRUSTED, EXEC_PATH),
d1473 1
a1473 1
     PARSE_DEF("trusted_lynxcgi", CONF_ADD_TRUSTED, CGI_PATH),
d1475 2
a1476 2
     PARSE_STR("url_domain_prefixes", CONF_STR, &URLDomainPrefixes),
     PARSE_STR("url_domain_suffixes", CONF_STR, &URLDomainSuffixes),
d1478 1
a1478 1
     PARSE_ADD("uploader", CONF_ADD_ITEM, uploaders),
d1480 2
d1483 1
a1483 1
     PARSE_SET("use_fixed_records", CONF_BOOL, &UseFixedRecords),
d1485 2
a1486 2
#if defined(NCURSES_MOUSE_VERSION) || defined(USE_SLANG_MOUSE)
     PARSE_SET("use_mouse", CONF_BOOL, &LYUseMouse),
d1488 9
a1496 6
     PARSE_SET("use_select_popups", CONF_BOOL, &LYSelectPopups),
     PARSE_SET("verbose_images", CONF_BOOL, &verbose_img),
     PARSE_SET("vi_keys_always_on", CONF_BOOL, &vi_keys),
     PARSE_FUN("viewer", CONF_FUN, viewer_fun),
     PARSE_ENV("wais_proxy", CONF_ENV, 0 ),
     PARSE_STR("xloadimage_command", CONF_STR, &XLoadImageCommand),
d1498 1
a1498 1
     {0, 0, 0}
d1501 5
d1514 2
a1515 5
#ifdef PARSE_DEBUG
	Config_Type *q = tbl;
#else
	ConfigUnion *q = (ConfigUnion *)(&(tbl->value));
#endif
d1530 1
a1530 1
		    	break;
d1545 8
a1552 2
    free_item_list();
    free_printer_item_list();
d1559 1
a1559 1
    char ch = TOUPPER(*name);
d1573 56
a1628 1
#define NOPTS_ ( (sizeof Config_Table)/(sizeof Config_Table[0]) - 1 )
d1639 89
a1743 1
    char mypath[LY_MAXPATH];
d1746 1
a1746 1
    CTRACE(tfp, "Loading cfg file '%s'.\n", cfg_filename);
d1758 1
a1758 1
	exit(-1);
d1764 1
a1764 1
	CTRACE(tfp,"No filename following -cfg switch!\n");
d1767 2
a1768 7
    if (!strncmp(cfg_filename, "~/", 2)) {
	strcpy(mypath, Home_Dir());
	strcat(mypath, cfg_filename+1);
	cfg_filename = mypath;
    }
    if ((fp = fopen(cfg_filename,"r")) == 0) {
	CTRACE(tfp,"lynx.cfg file not found as %s\n",cfg_filename);
d1776 7
d1787 1
a1787 5
#ifdef PARSE_DEBUG
	Config_Type *q;
#else
	ConfigUnion *q;
#endif
d1794 1
a1794 1
	if (*name == '#')
d1804 1
d1822 1
a1822 1
	    if (isspace ((unsigned char) *cp))
d1826 1
d1830 1
d1833 4
d1849 1
a1849 5
#ifdef PARSE_DEBUG
	q = tbl;
#else
	q = (ConfigUnion *)(&(tbl->value));
#endif
a1853 4
	    if (q->set_value != 0)
		*(q->set_value) = is_true (value);
	    break;

d1855 2
a1856 4
	    if (q->fun_value != 0)
		(*(q->fun_value)) (value);
	    break;

a1857 11
	    if (q->int_value != 0) {
		int ival;
		/* Apparently, if an integer value is not present, then the
		 * value is not changed.  So, use the sscanf function to make
		 * this determination.
		 */
		if (1 == sscanf (value, "%d", &ival))
		    *(q->int_value) = ival;
	    }
	    break;

a1858 4
	    if (q->str_value != 0)
		StrAllocCopy(*(q->str_value), value);
	    break;

d1861 3
a1863 16

	    if (tbl->type == CONF_ENV)
		LYLowerCase(name);
	    else
		LYUpperCase(name);

	    if (getenv (name) == 0) {
#ifdef VMS
		Define_VMSLogical(name, value);
#else
		if (q->str_value == 0)
			q->str_value = calloc(1, sizeof(char *));
		HTSprintf0 (q->str_value, "%s=%s", name, value);
		putenv (*(q->str_value));
#endif
	    }
d1868 1
a1868 1
	    optidx_set_t cur_set,anded_set;
d1877 3
a1879 3
	    if ( (p1 = strstr(value, sep=" for ")) != 0
#if defined(UNIX) && !defined(__EMX__)
		|| (p1 = strstr(value, sep=":")) != 0
d1887 5
a1891 2
	    if (fp0 != 0  &&  !LYRestricted) {
		LYLocalFileToURL(&url, value);
d1945 1
a1945 1
	    /* 
d1948 1
a1948 1
	     * of allowed options in <ul>.  Option names will be uppercased. 
d1951 1
a1951 1
	    if (fp0 != 0  &&  !LYRestricted && resultant_set) {
d1969 1
a1969 1
	    if (fp0 != 0  &&  !LYRestricted) {
a1977 10
	case CONF_ADD_ITEM:
	    if (q->add_value != 0)
		add_item_to_list (value, q->add_value);
	    break;

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)
	case CONF_ADD_TRUSTED:
	    add_trusted (value, q->def_value);
	    break;
#endif
d1994 1
a1994 1
    fclose (fp);
d2003 1
a2003 1
	lynx_html_item_type *cur_download;
d2022 2
a2024 46
    if (LYCookieSAcceptDomains != NULL) {
	cookie_domain_flag_set(LYCookieSAcceptDomains, FLAG_ACCEPT_ALWAYS);
	FREE(LYCookieSAcceptDomains);
    }

    if (LYCookieSRejectDomains != NULL) {
	cookie_domain_flag_set(LYCookieSRejectDomains, FLAG_REJECT_ALWAYS);
	FREE(LYCookieSRejectDomains);
    }

    if (LYCookieSStrictCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieSStrictCheckDomains, FLAG_INVCHECK_STRICT);
	FREE(LYCookieSStrictCheckDomains);
    }

    if (LYCookieSLooseCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieSLooseCheckDomains, FLAG_INVCHECK_LOOSE);
	FREE(LYCookieSLooseCheckDomains);
    }

    if (LYCookieSQueryCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieSQueryCheckDomains, FLAG_INVCHECK_QUERY);
	FREE(LYCookieSQueryCheckDomains);
    }

    if (LYCookieAcceptDomains != NULL) {
	cookie_domain_flag_set(LYCookieAcceptDomains, FLAG_ACCEPT_ALWAYS);
    }

    if (LYCookieRejectDomains != NULL) {
	cookie_domain_flag_set(LYCookieRejectDomains, FLAG_REJECT_ALWAYS);
    }

    if (LYCookieStrictCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieStrictCheckDomains, FLAG_INVCHECK_STRICT);
    }

    if (LYCookieLooseCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieLooseCheckDomains, FLAG_INVCHECK_LOOSE);
    }

    if (LYCookieQueryCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieQueryCheckDomains, FLAG_INVCHECK_QUERY);
    }

}
d2032 2
a2033 2
    do_read_cfg(cfg_filename,parent_filename,nesting_level,fp0,
	NULL);
d2036 10
d2049 1
a2049 1
 *  Called from getfile() cyrcle:
d2053 1
a2053 1
    document *,		       newdoc)
d2055 1
a2055 2
    static char tempfile[LY_MAXPATH];
    static char *local_url;  /* static! */
d2068 1
a2068 1
    if ((strstr(newdoc->address, "LYNXCFG://reload")) && !LYRestricted) {
d2070 1
a2070 1
	 *  Some staff to reload read_cfg(),
a2079 12

	/*  the page was pushed, so pop-up. */
	LYpop(newdoc);
	WWWDoc.address = newdoc->address;
	WWWDoc.post_data = newdoc->post_data;
	WWWDoc.post_content_type = newdoc->post_content_type;
	WWWDoc.bookmark = newdoc->bookmark;
	WWWDoc.isHEAD = newdoc->isHEAD;
	WWWDoc.safe = newdoc->safe;
	LYforce_no_cache = FALSE;   /* ! */
	LYoverride_no_cache = TRUE; /* ! */

d2081 2
a2082 6
	 * Working out of getfile() cycle we reset *no_cache manually here so
	 * HTLoadAbsolute() will return "Document already in memory":  it was
	 * forced reloading obsolete file again without this (overhead).
	 *
	 * Probably *no_cache was set in a wrong position because of
	 * the internal page...
d2084 27
a2110 2
	if (!HTLoadAbsolute(&WWWDoc))
	    return(NOT_FOUND);
d2112 3
a2114 1
	HTuncache_current_document();  /* will never use again */
d2117 1
a2117 1
	local_url = 0;	/* see below */
d2121 17
d2139 8
a2146 1
    if (local_url == 0) {
d2148 1
a2148 3
	LYRemoveTemp(tempfile);
	if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	    HTAlert(CANNOT_OPEN_TEMP);
d2150 2
a2151 2
	}
	LYLocalFileToURL(&local_url, tempfile);
a2157 1

d2159 1
a2159 1
	if (!LYRestricted) {
d2183 30
a2212 1
    /** a new experimental link ... **/
d2214 2
a2215 1
		fprintf(fp0, "  <a href=\"LYNXCFG://reload\">%s</a>\n",
d2244 1
d2247 2
a2248 2
    /* return to getfile() cyrcle */
    StrAllocCopy(newdoc->address, local_url);
d2258 3
d2268 1
a2268 1
 *  from getfile() cyrcle.
d2271 1
a2271 1
    document *,		       newdoc)
d2273 1
a2273 1
    char tempfile[LY_MAXPATH];
a2276 1
    static char *info_url;  /* static! */
d2280 15
a2294 1
    /* create the page only once - compile-time data will not change... */
d2296 9
a2304 3
    if (info_url == 0) {
	if ((fp0 = LYOpenTemp (tempfile, HTML_SUFFIX, "w")) == 0) {
	    HTAlert(CANNOT_OPEN_TEMP);
d2306 2
a2307 2
	}
	LYLocalFileToURL(&info_url, tempfile);
a2311 5
	fprintf(fp0, "%s %s<a href=\"LYNXCFG:\"> lynx.cfg</a> %s\n\n",
		     SEE_ALSO,
		     YOUR_SEGMENT,
		     RUNTIME_OPT_SEGMENT);

d2323 1
d2326 2
a2327 2
    /* exit to getfile() cyrcle */
    StrAllocCopy(newdoc->address, info_url);
d2337 3
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a5 1
#include <HTTP.h>		/* 'reloading' flag */
a6 1
#include <HTInit.h>
a26 1
#include <LYrcFile.h>
d36 2
a37 1
#include <HTNews.h>
d40 2
a41 2
BOOLEAN have_read_cfg = FALSE;
BOOLEAN LYUseNoviceLineTwo = TRUE;
d44 1
a44 1
 * Translate a TRUE/FALSE field in a string buffer.
d46 2
a47 1
static BOOL is_true(char *string)
d49 2
a50 2
    if (!strcasecomp(string, "TRUE") || !strcasecomp(string, "ON"))
	return (TRUE);
d52 1
a52 1
	return (FALSE);
d56 1
a56 1
 * Find an unescaped colon in a string buffer.
d58 2
a59 1
static char *find_colon(char *buffer)
d79 4
a82 1
static void free_item_list(lynx_list_item_type **ptr)
d84 2
a85 2
    lynx_list_item_type *cur = *ptr;
    lynx_list_item_type *next;
d87 1
d95 1
a95 2
    *ptr = NULL;
}
a96 7
/*
 * Function for freeing the DOWNLOADER and UPLOADER menus list.  - FM
 */
static void free_all_item_lists(void)
{
    free_item_list(&printers);
    free_item_list(&downloaders);
d98 9
a106 1
    free_item_list(&uploaders);
d110 9
a118 1
    free_item_list(&externals);
d125 1
a125 1
 * Process string buffer fields for DOWNLOADER or UPLOADER menus.
d127 3
a129 3
static void add_item_to_list(char *buffer,
			     lynx_list_item_type **list_ptr,
			     int special)
d132 1
a132 1
    lynx_list_item_type *cur_item, *prev_item;
d135 1
a135 1
     * Make a linked list
d139 1
a139 1
	 * First item.
d141 1
a141 2
	cur_item = typecalloc(lynx_list_item_type);

d146 1
a146 1
	atexit(free_all_item_lists);
d150 1
a150 1
	 * Find the last item.
d154 3
a156 3
	     prev_item = prev_item->next) ;	/* null body */
	cur_item = typecalloc(lynx_list_item_type);

a165 2
    cur_item->override_primary_action = FALSE;
    cur_item->pagelen = 66;
d168 1
a168 1
     * Find first unescaped colon and process fields
d172 1
a172 1
	 * Process name field
d174 1
a174 2
	cur_item->name = typecallocn(char, colon - buffer + 1);

d177 1
a177 1
	LYstrncpy(cur_item->name, buffer, (int) (colon - buffer));
d181 2
a182 4
	 * Find end of command string and beginning of TRUE/FALSE option field. 
	 * If we do not find a colon that ends the command string, leave the
	 * always_enabled option flag as FALSE.  In any case, we want the
	 * command string.
d184 1
a184 1
	if ((next_colon = find_colon(colon + 1)) == NULL) {
d187 2
a188 3
	if (next_colon - (colon + 1) > 0) {
	    cur_item->command = typecallocn(char, next_colon - colon);

d191 1
a191 3
	    LYstrncpy(cur_item->command,
		      colon + 1,
		      (int) (next_colon - (colon + 1)));
d193 1
d196 1
a196 11
	    colon = next_colon;
	    if ((next_colon = strchr(colon, ':')) != 0)
		*next_colon++ = '\0';
	    cur_item->always_enabled = is_true(colon);
	    if (next_colon) {
		if (special) {
		    cur_item->pagelen = atoi(next_colon);
		} else {
		    cur_item->override_primary_action = is_true(next_colon);
		}
	    }
d201 5
a205 2
lynx_list_item_type *find_item_by_number(lynx_list_item_type *list_ptr,
					 char *number)
d207 2
a208 1
    int value = atoi(number);
d210 6
a215 2
    while (value-- >= 0 && list_ptr != 0) {
	list_ptr = list_ptr->next;
d217 3
a219 1
    return list_ptr;
d222 6
a227 2
int match_item_by_name(lynx_list_item_type *ptr, char *name,
		       BOOLEAN only_overriders)
d229 73
a301 4
    return
	(ptr->command != 0
	 && !strncasecomp(ptr->name, name, strlen(ptr->name))
	 && (only_overriders ? ptr->override_primary_action : 1));
d306 1
a306 1
#ifndef COLOR_WHITE
a307 3
#endif

#ifndef COLOR_BLACK
a310 5
#ifdef USE_DEFAULT_COLORS
int default_fg = DEFAULT_COLOR;
int default_bg = DEFAULT_COLOR;

#else
a312 1
#endif
d314 1
a314 1
static const char *Color_Strings[16] =
d334 1
a334 1
#if defined(PDCURSES) && !defined(XCURSES)
d339 2
a340 1
static int ColorCode(int color)
d342 4
a345 9
    /* *INDENT-OFF* */
    static int map[] =
    {
	0,  4,  2,  6,  1,  5,  3,  7,
	8, 12, 10, 14,  9, 13, 11, 15
    };
    /* *INDENT-ON* */

    return map[color];
a350 2
BOOL default_color_reset = FALSE;

d352 1
a352 1
 * Validator for COLOR fields.
d354 3
a356 2
int check_color(char *color,
		int the_default)
d360 1
a360 7
    CTRACE2(TRACE_STYLE, (tfp, "check_color(%s,%d)\n", color, the_default));
    if (!strcasecomp(color, "default")) {
#ifdef USE_DEFAULT_COLORS
	if (!default_color_reset)
	    the_default = DEFAULT_COLOR;
#endif /* USE_DEFAULT_COLORS */
	CTRACE2(TRACE_STYLE, (tfp, "=> default %d\n", the_default));
a361 1
    }
d366 2
a367 6
	if (!strcasecomp(color, Color_Strings[i])) {
	    int c = ColorCode(i);

	    CTRACE2(TRACE_STYLE, (tfp, "=> %d\n", c));
	    return c;
	}
a368 1
    CTRACE2(TRACE_STYLE, (tfp, "=> ERR_COLOR\n"));
a370 11

const char *lookup_color(int code)
{
    unsigned n;

    for (n = 0; n < 16; n++) {
	if ((int) ColorCode(n) == code)
	    return Color_Strings[n];
    }
    return "default";
}
d373 1
a373 1
#if defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR)
d376 1
a376 1
 * Exit routine for failed COLOR parsing.
d378 2
a379 1
static void exit_with_color_syntax(char *error_line)
d382 1
a382 2

    fprintf(stderr, gettext("\
d389 1
a389 1
	);
d395 2
a396 2
    fprintf(stderr, "%s\n%s\n", gettext("Offending line:"), error_line);
    exit_immediately(EXIT_FAILURE);
a397 1
#endif /* defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR) */
a398 1
#if defined(USE_COLOR_TABLE)
d400 1
a400 1
 * Process string buffer fields for COLOR setting.
d402 2
a403 1
static void parse_color(char *buffer)
d412 2
a413 2
     * We are expecting a line of the form:
     *    INTEGER:FOREGROUND:BACKGROUND
d425 2
a426 2
    if ((check_color(fg, default_fg) == ERR_COLOR) ||
	(check_color(bg, default_bg) == ERR_COLOR))
d432 2
a433 2
		       check_color(fg, default_fg),
		       check_color(bg, default_bg)) < 0)
a438 8
/* *INDENT-OFF* */
#ifdef USE_SOURCE_CACHE
static Config_Enum tbl_source_cache[] = {
    { "FILE",	SOURCE_CACHE_FILE },
    { "MEMORY",	SOURCE_CACHE_MEMORY },
    { "NONE",	SOURCE_CACHE_NONE },
    { NULL,		-1 },
};
d440 51
a490 7
static Config_Enum tbl_abort_source_cache[] = {
    { "KEEP",	SOURCE_CACHE_FOR_ABORTED_KEEP },
    { "DROP",	SOURCE_CACHE_FOR_ABORTED_DROP },
    { NULL,		-1 },
};
#endif
/* *INDENT-ON* */
d492 3
a494 36
#define PARSE_ADD(n,v)   {n, CONF_ADD_ITEM,    UNION_ADD(v), 0}
#define PARSE_SET(n,v)   {n, CONF_BOOL,        UNION_SET(v), 0}
#define PARSE_ENU(n,v,t) {n, CONF_ENUM,        UNION_INT(v), t}
#define PARSE_INT(n,v)   {n, CONF_INT,         UNION_INT(v), 0}
#define PARSE_TIM(n,v)   {n, CONF_TIME,        UNION_INT(v), 0}
#define PARSE_STR(n,v)   {n, CONF_STR,         UNION_STR(v), 0}
#define PARSE_PRG(n,v)   {n, CONF_PRG,         UNION_DEF(v), 0}
#define PARSE_Env(n,v)   {n, CONF_ENV,         UNION_ENV(v), 0}
#define PARSE_ENV(n,v)   {n, CONF_ENV2,        UNION_ENV(v), 0}
#define PARSE_FUN(n,v)   {n, CONF_FUN,         UNION_FUN(v), 0}
#define PARSE_REQ(n,v)   {n, CONF_INCLUDE,     UNION_FUN(v), 0}
#define PARSE_DEF(n,v)   {n, CONF_ADD_TRUSTED, UNION_DEF(v), 0}
#define PARSE_NIL        {NULL, CONF_NIL,      UNION_DEF(0), 0}

typedef enum {
    CONF_NIL = 0
    ,CONF_BOOL			/* BOOLEAN type */
    ,CONF_FUN
    ,CONF_TIME
    ,CONF_ENUM
    ,CONF_INT
    ,CONF_STR
    ,CONF_PRG
    ,CONF_ENV			/* from environment variable */
    ,CONF_ENV2			/* from environment VARIABLE */
    ,CONF_INCLUDE		/* include file-- handle special */
    ,CONF_ADD_ITEM
    ,CONF_ADD_TRUSTED
} Conf_Types;

typedef struct {
    const char *name;
    Conf_Types type;
      ParseData;
    Config_Enum *table;
} Config_Type;
d496 2
a497 1
static int assume_charset_fun(char *value)
d501 1
a501 1
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d509 2
a510 1
static int assume_local_charset_fun(char *value)
d516 2
a517 1
static int assume_unrec_charset_fun(char *value)
d523 2
a524 1
static int character_set_fun(char *value)
d526 4
a529 11
    int i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */

    if (i < 0) {
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
	if (auto_display_charset >= 0
	    && (!strnicmp(value, "AutoDetect ", 11)
		|| !strnicmp(value, "AutoDetect-2 ", 13)))
	    current_char_set = auto_display_charset;
#endif
	/* do nothing here: so fallback to userdefs.h */
    } else
d535 2
a536 1
static int outgoing_mail_charset_fun(char *value)
a543 38
#ifdef EXP_ASSUMED_COLOR
/*
 * Process string buffer fields for ASSUMED_COLOR setting.
 */
static int assumed_color_fun(char *buffer)
{
    char *fg = buffer, *bg;
    char *temp = 0;

    StrAllocCopy(temp, buffer);	/* save a copy, for error messages */

    /*
     * We are expecting a line of the form:
     *    FOREGROUND:BACKGROUND
     */
    if (NULL == (bg = find_colon(fg)))
	exit_with_color_syntax(temp);
    *bg++ = '\0';

    default_fg = check_color(fg, default_fg);
    default_bg = check_color(bg, default_bg);

    if (default_fg == ERR_COLOR
	|| default_bg == ERR_COLOR)
	exit_with_color_syntax(temp);
#ifdef USE_SLANG
    /*
     * Sorry - the order of initialization of slang precludes setting the
     * default colors from the lynx.cfg file, since slang is already
     * initialized before the file is read, and there is no interface defined
     * for setting it from the application (that's one of the problems with
     * using environment variables rather than a programmable interface) -TD
     */
#endif
    FREE(temp);
    return 0;
}
#endif /* EXP_ASSUMED_COLOR */
d546 2
a547 1
static int color_fun(char *value)
d549 1
a549 1
    parse_color(value);
d554 2
a555 1
static int default_bookmark_file_fun(char *value)
d557 4
a560 1
    set_default_bookmark_page(value);
d564 2
a565 1
static int default_cache_size_fun(char *value)
d568 1
a568 2
    if (HTCacheSize < 2)
	HTCacheSize = 2;
d572 2
a573 1
static int default_editor_fun(char *value)
d575 1
a575 2
    if (!system_editor)
	StrAllocCopy(editor, value);
d579 2
a580 1
static int numbers_as_arrows_fun(char *value)
d590 13
d604 2
a605 1
static int dired_menu_fun(char *value)
d612 2
a613 1
static int jumpfile_fun(char *value)
d617 1
a617 1
    HTSprintf0(&buffer, "JUMPFILE:%s", value);
d619 1
a619 1
	CTRACE((tfp, "Failed to register %s\n", buffer));
d626 2
a627 1
static int keyboard_layout_fun(char *key)
d630 1
a630 1
	CTRACE((tfp, "Failed to set keyboard layout %s\n", key));
d635 2
a636 1
static int keymap_fun(char *key)
d638 1
a638 1
    char *func, *efunc;
d640 1
a640 1
    if ((func = strchr(key, ':')) != NULL) {
a641 1
	efunc = strchr(func, ':');
d643 7
a649 81
	/* Allow third field for line-editor action. - kw */
	if (efunc == func) {	/* have 3rd field, but 2nd field empty */
	    func = NULL;
	} else if (efunc && strncasecomp(efunc + 1, "DIRED", 5) == 0) {
	    if (!remap(key, strtok(func, " \t\n:#"), TRUE)) {
		fprintf(stderr,
			gettext("key remapping of %s to %s for %s failed\n"),
			key, func, efunc + 1);
	    } else if (func && !strcmp("TOGGLE_HELP", func)) {
		LYUseNoviceLineTwo = FALSE;
	    }
	    return 0;
	} else if (!remap(key, strtok(func, " \t\n:#"), FALSE)) {
	    fprintf(stderr, gettext("key remapping of %s to %s failed\n"),
		    key, func);
	} else {
	    if (func && !strcmp("TOGGLE_HELP", func))
		LYUseNoviceLineTwo = FALSE;
	}
	if (efunc) {
	    efunc++;
	    if (efunc == strtok((func ? NULL : efunc), " \t\n:#") && *efunc) {
		BOOLEAN success = FALSE;
		int lkc = lkcstring_to_lkc(key);
		int lec = -1;
		int select_edi = 0;
		char *sselect_edi = strtok(NULL, " \t\n:#");
		char **endp = &sselect_edi;

		if (sselect_edi) {
		    if (*sselect_edi)
			select_edi = strtol(sselect_edi, endp, 10);
		    if (**endp != '\0') {
			fprintf(stderr,
				gettext("invalid line-editor selection %s for key %s, selecting all\n"),
				sselect_edi, key);
			select_edi = 0;
		    }
		}
		/*
		 * PASS!  tries to enter the key into the LYLineEditors
		 * bindings in a different way from PASS, namely as binding
		 * that maps to the specific lynx actioncode (rather than to
		 * LYE_FORM_PASS).  That only works for lynx keycodes with
		 * modifier bit set, and we have no documented/official way to
		 * specify this in the KEYMAP directive, although it can be
		 * made to work e.g. by specifying a hex value that has the
		 * modifier bit set.  But knowledge about the bit pattern of
		 * modifiers should remain in internal matter subject to
		 * change...  At any rate, if PASS!  fails try it the same way
		 * as for PASS.  - kw
		 */
		if (!success && strcasecomp(efunc, "PASS!") == 0) {
		    if (func) {
			lec = LYE_FORM_LAC | lacname_to_lac(func);
			success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		    }
		    if (!success)
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    else
			return 0;
		}
		if (!success) {
		    lec = lecname_to_lec(efunc);
		    success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		}
		if (!success) {
		    if (lec != -1) {
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    } else {
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) for %s failed\n"),
				key, lkc, efunc);
		    }
		}
	    }
	}
d654 2
a655 1
static int localhost_alias_fun(char *value)
d662 2
a663 1
static int lynxcgi_environment_fun(char *value)
d670 2
a671 1
static int lynx_sig_file_fun(char *value)
d674 1
a674 2

    LYstrncpy(temp, value, sizeof(temp) - 1);
d679 1
a679 1
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
d681 1
a681 1
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
d687 2
a688 1
static int news_chunk_size_fun(char *value)
d700 2
a701 1
static int news_max_chunk_fun(char *value)
d713 2
a714 1
static int news_posting_fun(char *value)
d717 1
a717 1
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
d723 2
a724 1
static int cern_rulesfile_fun(char *value)
a727 1

d736 3
a738 2
	StrAllocCat(rulesfile2, value + 1);
    } else {
d748 5
a752 3
	    gettext("Lynx: cannot start, CERN rules file %s is not available\n"),
	    non_empty(rulesfile2) ? rulesfile2 : gettext("(no name)"));
    exit_immediately(EXIT_FAILURE);
d757 2
a758 1
static int printer_fun(char *value)
d760 1
a760 1
    add_item_to_list(value, &printers, TRUE);
d764 3
a766 1
static int referer_with_query_fun(char *value)
d768 7
a774 6
    if (!strncasecomp(value, "SEND", 4))
	LYRefererWithQuery = 'S';
    else if (!strncasecomp(value, "PARTIAL", 7))
	LYRefererWithQuery = 'P';
    else
	LYRefererWithQuery = 'D';
d777 1
d779 2
a780 1
static int suffix_fun(char *value)
d782 1
a782 5
    char *mime_type, *p;
    char *encoding = NULL;
    char *sq = NULL;
    char *description = NULL;
    double q = 1.0;
d784 2
a785 3
    if ((strlen(value) < 3)
	|| (NULL == (mime_type = strchr(value, ':')))) {
	CTRACE((tfp, "Invalid SUFFIX:%s ignored.\n", value));
a786 1
    }
a788 21
    if (*mime_type) {
	if ((encoding = strchr(mime_type, ':')) != NULL) {
	    *encoding++ = '\0';
	    if ((sq = strchr(encoding, ':')) != NULL) {
		*sq++ = '\0';
		if ((description = strchr(sq, ':')) != NULL) {
		    *description++ = '\0';
		    if ((p = strchr(sq, ':')) != NULL)
			*p = '\0';
		    LYTrimTail(description);
		}
		LYRemoveBlanks(sq);
		if (!*sq)
		    sq = NULL;
	    }
	    LYRemoveBlanks(encoding);
	    LYLowerCase(encoding);
	    if (!*encoding)
		encoding = NULL;
	}
    }
d791 1
a791 12
    /*
     * mime-type is not converted to lowercase on input, to make it possible to
     * reproduce the equivalent of some of the HTInit.c defaults that use mixed
     * case, although that is not recomended.  - kw
     */
    if (!*mime_type) {		/* that's ok now, with an encoding!  */
	CTRACE((tfp, "SUFFIX:%s without MIME type for %s\n", value,
		encoding ? encoding : "what?"));
	mime_type = NULL;	/* that's ok now, with an encoding!  */
	if (!encoding)
	    return 0;
    }
d793 8
a800 33
    if (!encoding) {
	if (strstr(mime_type, "tex") != NULL ||
	    strstr(mime_type, "postscript") != NULL ||
	    strstr(mime_type, "sh") != NULL ||
	    strstr(mime_type, "troff") != NULL ||
	    strstr(mime_type, "rtf") != NULL)
	    encoding = "8bit";
	else
	    encoding = "binary";
    }
    if (!sq) {
	q = 1.0;
    } else {
	double df = strtod(sq, &p);

	if (p == sq && df == 0.0) {
	    CTRACE((tfp, "Invalid q=%s for SUFFIX:%s, using -1.0\n",
		    sq, value));
	    q = -1.0;
	} else {
	    q = df;
	}
    }
    HTSetSuffix5(value, mime_type, encoding, description, q);

    return 0;
}

static int suffix_order_fun(char *value)
{
    char *p = value;
    char *optn;
    BOOLEAN want_file_init_now = FALSE;
a801 18
    LYUseBuiltinSuffixes = TRUE;
    while ((optn = HTNextTok(&p, ", ", "", NULL)) != NULL) {
	if (!strcasecomp(optn, "NO_BUILTIN")) {
	    LYUseBuiltinSuffixes = FALSE;
	} else if (!strcasecomp(optn, "PRECEDENCE_HERE")) {
	    want_file_init_now = TRUE;
	} else if (!strcasecomp(optn, "PRECEDENCE_OTHER")) {
	    want_file_init_now = FALSE;
	} else {
	    CTRACE((tfp, "Invalid SUFFIX_ORDER:%s\n", optn));
	    break;
	}
    }

    if (want_file_init_now && !FileInitAlreadyDone) {
	HTFileInit();
	FileInitAlreadyDone = TRUE;
    }
d805 2
a806 1
static int system_editor_fun(char *value)
d813 2
a814 4
#define SetViewer(mime_type, viewer) \
    HTSetPresentation(mime_type, viewer, 0, 1.0, 3.0, 0.0, 0, mediaCFG)

static int viewer_fun(char *value)
d822 2
a823 2
    if ((strlen(value) < 3)
	|| (NULL == (viewer = strchr(mime_type, ':'))))
d833 1
a833 1
	(strlen(viewer) > 1) && *(environment - 1) != '\\') {
d840 1
a840 1
	if (!strcasecomp(environment, "XWINDOWS")) {
d842 2
a843 2
		SetViewer(mime_type, viewer);
	} else if (!strcasecomp(environment, "NON_XWINDOWS")) {
d845 1
a845 1
		SetViewer(mime_type, viewer);
d847 1
a847 1
	    SetViewer(mime_type, viewer);
d851 1
a851 1
	SetViewer(mime_type, viewer);
a856 90
static int nonrest_sigwinch_fun(char *value)
{
    if (!strncasecomp(value, "XWINDOWS", 8)) {
	LYNonRestartingSIGWINCH = (BOOL) (LYgetXDisplay() != NULL);
    } else {
	LYNonRestartingSIGWINCH = is_true(value);
    }
    return 0;
}

#ifdef EXP_CHARSET_CHOICE
static void matched_charset_choice(BOOL display_charset,
				   int i)
{
    int j;

    if (display_charset && !custom_display_charset) {
	for (custom_display_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_display = TRUE;
    } else if (!display_charset && !custom_assumed_doc_charset) {
	for (custom_assumed_doc_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_assumed = TRUE;
    }
    if (display_charset)
	charset_subsets[i].hide_display = FALSE;
    else
	charset_subsets[i].hide_assumed = FALSE;
}

static int parse_charset_choice(char *p,
				BOOL display_charset)	/*if FALSE, then assumed doc charset */
{
    int len, i;
    int matches = 0;

    /*only one charset choice is allowed per line! */
    LYTrimHead(p);
    LYTrimTail(p);
    CTRACE((tfp, "parsing charset choice for %s:\"%s\"",
	    (display_charset ? "display charset" : "assumed doc charset"), p));
    len = strlen(p);
    if (!len) {
	CTRACE((tfp, " - EMPTY STRING\n"));
	return 1;
    }
    if (*p == '*' && len == 1) {
	if (display_charset)
	    for (custom_display_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_display = FALSE;
	else
	    for (custom_assumed_doc_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_assumed = FALSE;
	CTRACE((tfp, " - all unhidden\n"));
	return 0;
    }
    if (p[len - 1] == '*') {
	--len;
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strncasecomp(p, LYchar_set_names[i], len)) ||
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len))) {
		++matches;
		matched_charset_choice(display_charset, i);
	    }
	}
	CTRACE((tfp, " - %d matches\n", matches));
	return 0;
    } else {
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strcasecomp(p, LYchar_set_names[i])) ||
		(!strcasecomp(p, LYCharSet_UC[i].MIMEname))) {
		matched_charset_choice(display_charset, i);
		CTRACE((tfp, " - OK\n"));
		++matches;
		return 0;
	    }
	}
	CTRACE((tfp, " - NOT recognised\n"));
	return 1;
    }
}

static int parse_display_charset_choice(char *p)
{
    return parse_charset_choice(p, 1);
}

static int parse_assumed_doc_charset_choice(char *p)
{
    return parse_charset_choice(p, 0);
}
d858 1
a858 1
#endif /* EXP_CHARSET_CHOICE */
d860 3
a862 3
#ifdef USE_PRETTYSRC
static void html_src_bad_syntax(char *value,
				char *option_name)
d866 1
a866 1
    HTSprintf0(&buf, "HTMLSRC_%s", option_name);
d868 2
a869 2
    fprintf(stderr, "Bad syntax in TAGSPEC %s:%s\n", buf, value);
    exit_immediately(EXIT_FAILURE);
a871 9
static int parse_html_src_spec(HTlexeme lexeme_code, char *value,
			       char *option_name)
{
    /* Now checking the value for being correct.  Since HTML_dtd is not
     * initialized completely (member tags points to non-initiailized data), we
     * use tags_old.  If the syntax is incorrect, then lynx will exit with error
     * message.
     */
    char *ts2;
d873 12
a884 2
    if (isEmpty(value))
	return 0;		/* silently ignoring */
d888 1
a888 1
    ts2 = strchr(value, ':');
d893 3
a895 5
    CTRACE((tfp, "ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",
	    value, ts2, option_name));
    html_src_clean_item(lexeme_code);
    if (html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE)) {
d901 2
a902 1
    StrAllocCopy(HTL_tagspecs[lexeme_code], value);
d907 17
a923 41
static int psrcspec_fun(char *s)
{
    char *e;
    /* *INDENT-OFF* */
    static Config_Enum lexemnames[] =
    {
	{ "comm",	HTL_comm	},
	{ "tag",	HTL_tag		},
	{ "attrib",	HTL_attrib	},
	{ "attrval",	HTL_attrval	},
	{ "abracket",	HTL_abracket	},
	{ "entity",	HTL_entity	},
	{ "href",	HTL_href	},
	{ "entire",	HTL_entire	},
	{ "badseq",	HTL_badseq	},
	{ "badtag",	HTL_badtag	},
	{ "badattr",	HTL_badattr	},
	{ "sgmlspecial", HTL_sgmlspecial },
	{ NULL,		-1		}
    };
    /* *INDENT-ON* */

    int found;

    e = strchr(s, ':');
    if (!e) {
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",
		s));
	return 0;
    }
    *e = '\0';
    if (!LYgetEnum(lexemnames, s, &found)) {
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",
		s, e + 1));
	return 0;
    }
    parse_html_src_spec((HTlexeme) found, e + 1, s);
    return 0;
}
d925 1
a925 1
static int read_htmlsrc_attrname_xform(char *str)
d928 3
a930 6

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
d934 2
a935 2
	CTRACE((tfp, "bad value for htmlsrc_attrname_xform (ignored): %s\n",
		str));
d940 1
a940 1
static int read_htmlsrc_tagname_xform(char *str)
d943 3
a945 6

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
d949 2
a950 2
	CTRACE((tfp, "bad value for htmlsrc_tagname_xform (ignored): %s\n",
		str));
a953 1
#endif
a954 4
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
static int screen_size_fun(char *value)
{
    char *cp;
d956 3
a958 17
    if ((cp = strchr(value, ',')) != 0) {
	*cp++ = '\0';		/* Terminate ID */
	scrsize_x = atoi(value);
	scrsize_y = atoi(cp);
	if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
	    scrsize_x = scrsize_y = 0;
	}
	if ((scrsize_x > 0) && (scrsize_x < 80)) {
	    scrsize_x = 80;
	}
	if ((scrsize_y > 0) && (scrsize_y < 4)) {
	    scrsize_y = 4;
	}
	CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
    }
    return 0;
}
d961 2
a962 2
/* This table is searched ignoring case */
/* *INDENT-OFF* */
d965 3
a967 3
     PARSE_SET(RC_ACCEPT_ALL_COOKIES,   LYAcceptAllCookies),
     PARSE_TIM(RC_ALERTSECS,            AlertSecs),
     PARSE_SET(RC_ALWAYS_RESUBMIT_POSTS, LYresubmit_posts),
d969 1
a969 7
     PARSE_DEF(RC_ALWAYS_TRUSTED_EXEC,  ALWAYS_EXEC_PATH),
#endif
     PARSE_FUN(RC_ASSUME_CHARSET,       assume_charset_fun),
     PARSE_FUN(RC_ASSUME_LOCAL_CHARSET, assume_local_charset_fun),
     PARSE_FUN(RC_ASSUME_UNREC_CHARSET, assume_unrec_charset_fun),
#ifdef EXP_ASSUMED_COLOR
     PARSE_FUN(RC_ASSUMED_COLOR,        assumed_color_fun),
d971 11
a981 24
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN(RC_ASSUMED_DOC_CHARSET_CHOICE, parse_assumed_doc_charset_choice),
#endif
#ifdef DIRED_SUPPORT
     PARSE_INT(RC_AUTO_UNCACHE_DIRLISTS, LYAutoUncacheDirLists),
#endif
#ifndef DISABLE_BIBP
     PARSE_STR(RC_BIBP_BIBHOST,         BibP_bibhost),
     PARSE_STR(RC_BIBP_GLOBALSERVER,    BibP_globalserver),
#endif
     PARSE_SET(RC_BLOCK_MULTI_BOOKMARKS, LYMBMBlocked),
     PARSE_SET(RC_BOLD_H1,              bold_H1),
     PARSE_SET(RC_BOLD_HEADERS,         bold_headers),
     PARSE_SET(RC_BOLD_NAME_ANCHORS,    bold_name_anchors),
     PARSE_PRG(RC_BZIP2_PATH,           ppBZIP2),
     PARSE_SET(RC_CASE_SENSITIVE_ALWAYS_ON, case_sensitive),
     PARSE_FUN(RC_CHARACTER_SET,        character_set_fun),
#ifdef CAN_SWITCH_DISPLAY_CHARSET
     PARSE_STR(RC_CHARSET_SWITCH_RULES, charset_switch_rules),
     PARSE_STR(RC_CHARSETS_DIRECTORY,   charsets_directory),
#endif
     PARSE_SET(RC_CHECKMAIL,            check_mail),
     PARSE_PRG(RC_CHMOD_PATH,           ppCHMOD),
     PARSE_SET(RC_COLLAPSE_BR_TAGS,     LYCollapseBRs),
d983 1
a983 1
     PARSE_FUN(RC_COLOR,                color_fun),
d985 9
a993 15
     PARSE_PRG(RC_COMPRESS_PATH,        ppCOMPRESS),
     PARSE_PRG(RC_COPY_PATH,            ppCOPY),
     PARSE_INT(RC_CONNECT_TIMEOUT,      connect_timeout),
     PARSE_STR(RC_COOKIE_ACCEPT_DOMAINS, LYCookieSAcceptDomains),
#ifdef USE_PERSISTENT_COOKIES
     PARSE_STR(RC_COOKIE_FILE,          LYCookieFile),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieSLooseCheckDomains),
     PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieSQueryCheckDomains),
     PARSE_STR(RC_COOKIE_REJECT_DOMAINS, LYCookieSRejectDomains),
#ifdef USE_PERSISTENT_COOKIES
     PARSE_STR(RC_COOKIE_SAVE_FILE,     LYCookieSaveFile),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieSStrictCheckDomains),
     PARSE_Env(RC_CSO_PROXY,		0),
d995 1
a995 1
     PARSE_PRG(RC_CSWING_PATH,          ppCSWING),
d997 6
a1002 8
     PARSE_TIM(RC_DELAYSECS,            DebugSecs),
     PARSE_FUN(RC_DEFAULT_BOOKMARK_FILE, default_bookmark_file_fun),
     PARSE_FUN(RC_DEFAULT_CACHE_SIZE,   default_cache_size_fun),
     PARSE_FUN(RC_DEFAULT_EDITOR,       default_editor_fun),
     PARSE_STR(RC_DEFAULT_INDEX_FILE,   indexfile),
     PARSE_ENU(RC_DEFAULT_KEYPAD_MODE,  keypad_mode, tbl_keypad_mode),
     PARSE_FUN(RC_DEFAULT_KEYPAD_MODE_NUMARO, numbers_as_arrows_fun),
     PARSE_ENU(RC_DEFAULT_USER_MODE,    user_mode, tbl_user_mode),
d1004 1
a1004 1
     PARSE_INT(RC_DEFAULT_VIRTUAL_MEMORY_SIZE, HTVirtualMemorySize),
d1007 1
a1007 4
     PARSE_FUN(RC_DIRED_MENU,           dired_menu_fun),
#endif
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN(RC_DISPLAY_CHARSET_CHOICE, parse_display_charset_choice),
d1009 3
a1011 4
     PARSE_ADD(RC_DOWNLOADER,           downloaders),
     PARSE_SET(RC_EMACS_KEYS_ALWAYS_ON, emacs_keys),
     PARSE_FUN(RC_ENABLE_LYNXRC,        enable_lynxrc),
     PARSE_SET(RC_ENABLE_SCROLLBACK,    enable_scrollback),
d1013 1
a1013 12
     PARSE_ADD(RC_EXTERNAL,             externals),
#endif
     PARSE_Env(RC_FINGER_PROXY,         0),
#if defined(_WINDOWS)	/* 1998/10/05 (Mon) 17:34:15 */
     PARSE_SET(RC_FOCUS_WINDOW,         focus_window),
#endif
     PARSE_SET(RC_FORCE_8BIT_TOUPPER,   UCForce8bitTOUPPER),
     PARSE_ENU(RC_FORCE_COOKIE_PROMPT,  cookie_noprompt, tbl_force_prompt),
     PARSE_SET(RC_FORCE_EMPTY_HREFLESS_A, force_empty_hrefless_a),
     PARSE_SET(RC_FORCE_SSL_COOKIES_SECURE, LYForceSSLCookiesSecure),
#ifdef USE_SSL
     PARSE_ENU(RC_FORCE_SSL_PROMPT,     ssl_noprompt, tbl_force_prompt),
d1015 3
d1019 1
a1019 30
     PARSE_SET(RC_FORMS_OPTIONS,        LYUseFormsOptions),
#endif
     PARSE_SET(RC_FTP_PASSIVE,          ftp_passive),
     PARSE_Env(RC_FTP_PROXY,            0),
     PARSE_STR(RC_GLOBAL_EXTENSION_MAP, global_extension_map),
     PARSE_STR(RC_GLOBAL_MAILCAP,       global_type_map),
     PARSE_Env(RC_GOPHER_PROXY,         0),
     PARSE_SET(RC_GOTOBUFFER,           goto_buffer),
     PARSE_PRG(RC_GZIP_PATH,            ppGZIP),
     PARSE_STR(RC_HELPFILE,             helpfile),
#ifdef MARK_HIDDEN_LINKS
     PARSE_STR(RC_HIDDEN_LINK_MARKER,   hidden_link_marker),
#endif
     PARSE_SET(RC_HISTORICAL_COMMENTS,  historical_comments),
#ifdef USE_PRETTYSRC
     PARSE_FUN(RC_HTMLSRC_ATTRNAME_XFORM, read_htmlsrc_attrname_xform),
     PARSE_FUN(RC_HTMLSRC_TAGNAME_XFORM, read_htmlsrc_tagname_xform),
#endif
     PARSE_Env(RC_HTTP_PROXY,           0),
     PARSE_Env(RC_HTTPS_PROXY,          0),
     PARSE_REQ(RC_INCLUDE,              0),
     PARSE_PRG(RC_INFLATE_PATH,         ppINFLATE),
     PARSE_TIM(RC_INFOSECS,             InfoSecs),
     PARSE_PRG(RC_INSTALL_PATH,         ppINSTALL),
     PARSE_STR(RC_JUMP_PROMPT,          jumpprompt),
     PARSE_SET(RC_JUMPBUFFER,           jump_buffer),
     PARSE_FUN(RC_JUMPFILE,             jumpfile_fun),
#ifdef EXP_JUSTIFY_ELTS
     PARSE_SET(RC_JUSTIFY,              ok_justify),
     PARSE_INT(RC_JUSTIFY_MAX_VOID_PERCENT, justify_max_void_percent),
d1021 40
d1062 1
a1062 6
     PARSE_FUN(RC_KEYBOARD_LAYOUT,      keyboard_layout_fun),
#endif
     PARSE_FUN(RC_KEYMAP,               keymap_fun),
     PARSE_SET(RC_LEFTARROW_IN_TEXTFLD_PROMPT, textfield_prompt_at_left_edge),
#ifndef VMS
     PARSE_STR(RC_LIST_FORMAT,          list_format),
d1064 1
d1066 2
a1067 2
     PARSE_SET(RC_LIST_NEWS_DATES,      LYListNewsDates),
     PARSE_SET(RC_LIST_NEWS_NUMBERS,    LYListNewsNumbers),
d1069 2
a1070 2
#ifdef EXP_LOCALE_CHARSET
     PARSE_SET(RC_LOCALE_CHARSET,       LYLocaleCharset),
d1072 2
a1073 2
     PARSE_STR(RC_LOCAL_DOMAIN,         LYLocalDomain),
     PARSE_FUN(RC_LOCALHOST_ALIAS,      localhost_alias_fun),
d1075 2
a1076 2
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_ALWAYS, local_exec),
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_LOCAL, local_exec_on_local_files),
a1077 2
     PARSE_STR(RC_LYNX_HOST_NAME,       LYHostName),
     PARSE_FUN(RC_LYNX_SIG_FILE,        lynx_sig_file_fun),
d1079 1
d1081 1
a1081 1
     PARSE_STR(RC_LYNXCGI_DOCUMENT_ROOT, LYCgiDocumentRoot),
a1082 1
     PARSE_FUN(RC_LYNXCGI_ENVIRONMENT,  lynxcgi_environment_fun),
d1084 5
a1088 2
#if USE_VMS_MAILER
     PARSE_STR(RC_MAIL_ADRS,            mail_adrs),
d1090 6
a1095 12
     PARSE_SET(RC_MAIL_SYSTEM_ERROR_LOGGING, error_logging),
     PARSE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images),
     PARSE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts),
     PARSE_INT(RC_MAX_COOKIES_BUFFER,   max_cookies_buffer),
     PARSE_INT(RC_MAX_COOKIES_DOMAIN,   max_cookies_domain),
     PARSE_INT(RC_MAX_COOKIES_GLOBAL,   max_cookies_global),
     PARSE_TIM(RC_MESSAGESECS,          MessageSecs),
     PARSE_SET(RC_MINIMAL_COMMENTS,     minimal_comments),
     PARSE_PRG(RC_MKDIR_PATH,           ppMKDIR),
     PARSE_ENU(RC_MULTI_BOOKMARK_SUPPORT, LYMultiBookmarks, tbl_multi_bookmarks),
     PARSE_PRG(RC_MV_PATH,              ppMV),
     PARSE_SET(RC_NCR_IN_BOOKMARKS,     UCSaveBookmarksInUnicode),
d1097 11
a1107 13
     PARSE_FUN(RC_NEWS_CHUNK_SIZE,      news_chunk_size_fun),
     PARSE_FUN(RC_NEWS_MAX_CHUNK,       news_max_chunk_fun),
     PARSE_FUN(RC_NEWS_POSTING,         news_posting_fun),
     PARSE_Env(RC_NEWS_PROXY,           0),
     PARSE_Env(RC_NEWSPOST_PROXY,       0),
     PARSE_Env(RC_NEWSREPLY_PROXY,      0),
     PARSE_Env(RC_NNTP_PROXY,           0),
     PARSE_ENV(RC_NNTPSERVER,           0), /* actually NNTPSERVER */
#endif
     PARSE_SET(RC_NUMBER_FIELDS_ON_LEFT,number_fields_on_left),
     PARSE_SET(RC_NUMBER_LINKS_ON_LEFT, number_links_on_left),
     PARSE_SET(RC_NO_DOT_FILES,         no_dotfiles),
     PARSE_SET(RC_NO_FILE_REFERER,      no_filereferer),
d1109 1
a1109 1
     PARSE_SET(RC_NO_FORCED_CORE_DUMP,  LYNoCore),
d1111 5
a1115 7
     PARSE_SET(RC_NO_FROM_HEADER,       LYNoFromHeader),
     PARSE_SET(RC_NO_ISMAP_IF_USEMAP,   LYNoISMAPifUSEMAP),
     PARSE_Env(RC_NO_PROXY,             0),
     PARSE_SET(RC_NO_REFERER_HEADER,    LYNoRefererHeader),
     PARSE_SET(RC_NO_TABLE_CENTER,      no_table_center),
     PARSE_FUN(RC_NONRESTARTING_SIGWINCH, nonrest_sigwinch_fun),
     PARSE_FUN(RC_OUTGOING_MAIL_CHARSET, outgoing_mail_charset_fun),
d1117 2
a1118 2
     PARSE_SET(RC_PARTIAL,              display_partial_flag),
     PARSE_INT(RC_PARTIAL_THRES,        partial_threshold),
d1120 11
a1130 25
#ifdef USE_PERSISTENT_COOKIES
     PARSE_SET(RC_PERSISTENT_COOKIES,   persistent_cookies),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_PERSONAL_EXTENSION_MAP, personal_extension_map),
     PARSE_STR(RC_PERSONAL_MAILCAP,     personal_type_map),
     PARSE_STR(RC_PREFERRED_CHARSET,    pref_charset),
     PARSE_ENU(RC_PREFERRED_ENCODING,   LYAcceptEncoding, tbl_preferred_encoding),
     PARSE_STR(RC_PREFERRED_LANGUAGE,   language),
     PARSE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia, tbl_preferred_media),
     PARSE_SET(RC_PREPEND_BASE_TO_SOURCE, LYPrependBaseToSource),
     PARSE_SET(RC_PREPEND_CHARSET_TO_SOURCE, LYPrependCharsetToSource),
#ifdef USE_PRETTYSRC
     PARSE_SET(RC_PRETTYSRC,            LYpsrc),
     PARSE_FUN(RC_PRETTYSRC_SPEC,       psrcspec_fun),
     PARSE_SET(RC_PRETTYSRC_VIEW_NO_ANCHOR_NUM, psrcview_no_anchor_numbering),
#endif
     PARSE_FUN(RC_PRINTER,              printer_fun),
     PARSE_SET(RC_QUIT_DEFAULT_YES,     LYQuitDefaultYes),
     PARSE_FUN(RC_REFERER_WITH_QUERY,   referer_with_query_fun),
#ifdef EXP_CMD_LOGGING
     PARSE_TIM(RC_REPLAYSECS,           ReplaySecs),
#endif
     PARSE_SET(RC_REUSE_TEMPFILES,      LYReuseTempfiles),
     PARSE_PRG(RC_RLOGIN_PATH,          ppRLOGIN),
     PARSE_PRG(RC_RM_PATH,              ppRM),
d1132 2
a1133 2
     PARSE_FUN(RC_RULE,                 HTSetConfiguration),
     PARSE_FUN(RC_RULESFILE,            cern_rulesfile_fun),
d1135 22
a1156 47
     PARSE_STR(RC_SAVE_SPACE,           lynx_save_space),
     PARSE_SET(RC_SCAN_FOR_BURIED_NEWS_REFS, scan_for_buried_news_references),
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
     PARSE_FUN(RC_SCREEN_SIZE,          screen_size_fun),
#endif
#ifdef USE_SCROLLBAR
     PARSE_SET(RC_SCROLLBAR,            LYShowScrollbar),
     PARSE_SET(RC_SCROLLBAR_ARROW,      LYsb_arrow),
#endif
     PARSE_SET(RC_SEEK_FRAG_AREA_IN_CUR, LYSeekFragAREAinCur),
     PARSE_SET(RC_SEEK_FRAG_MAP_IN_CUR, LYSeekFragMAPinCur),
     PARSE_SET(RC_SET_COOKIES,          LYSetCookies),
     PARSE_SET(RC_SHOW_CURSOR,          LYShowCursor),
     PARSE_STR(RC_SHOW_KB_NAME,         LYTransferName),
     PARSE_ENU(RC_SHOW_KB_RATE,         LYTransferRate, tbl_transfer_rate),
     PARSE_Env(RC_SNEWS_PROXY,          0),
     PARSE_Env(RC_SNEWSPOST_PROXY,      0),
     PARSE_Env(RC_SNEWSREPLY_PROXY,     0),
     PARSE_SET(RC_SOFT_DQUOTES,         soft_dquotes),
#ifdef USE_SOURCE_CACHE
     PARSE_ENU(RC_SOURCE_CACHE,         LYCacheSource, tbl_source_cache),
     PARSE_ENU(RC_SOURCE_CACHE_FOR_ABORTED, LYCacheSourceForAborted, tbl_abort_source_cache),
#endif
     PARSE_STR(RC_STARTFILE,            startfile),
     PARSE_SET(RC_STRIP_DOTDOT_URLS,    LYStripDotDotURLs),
     PARSE_SET(RC_SUBSTITUTE_UNDERSCORES, use_underscore),
     PARSE_FUN(RC_SUFFIX,               suffix_fun),
     PARSE_FUN(RC_SUFFIX_ORDER,         suffix_order_fun),
#ifdef SYSLOG_REQUESTED_URLS
     PARSE_SET(RC_SYSLOG_REQUESTED_URLS, syslog_requested_urls),
     PARSE_SET(RC_SYSLOG_TEXT,		syslog_txt),
#endif
     PARSE_FUN(RC_SYSTEM_EDITOR,        system_editor_fun),
     PARSE_STR(RC_SYSTEM_MAIL,          system_mail),
     PARSE_STR(RC_SYSTEM_MAIL_FLAGS,    system_mail_flags),
     PARSE_FUN(RC_TAGSOUP,              get_tagsoup),
     PARSE_PRG(RC_TAR_PATH,             ppTAR),
     PARSE_PRG(RC_TELNET_PATH,          ppTELNET),
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
     PARSE_SET(RC_TEXTFIELDS_NEED_ACTIVATION, textfields_activation_option),
#endif
     PARSE_PRG(RC_TN3270_PATH,          ppTN3270),
#if defined(_WINDOWS)
     PARSE_INT(RC_TIMEOUT,              lynx_timeout),
#endif
     PARSE_PRG(RC_TOUCH_PATH,           ppTOUCH),
     PARSE_SET(RC_TRIM_INPUT_FIELDS,    LYtrimInputFields),
d1158 1
a1158 1
     PARSE_DEF(RC_TRUSTED_EXEC,         EXEC_PATH),
d1161 1
a1161 1
     PARSE_DEF(RC_TRUSTED_LYNXCGI,      CGI_PATH),
d1163 2
a1164 3
     PARSE_PRG(RC_UNCOMPRESS_PATH,      ppUNCOMPRESS),
     PARSE_SET(RC_UNDERLINE_LINKS,      LYUnderlineLinks),
     PARSE_PRG(RC_UNZIP_PATH,           ppUNZIP),
d1166 1
a1166 1
     PARSE_ADD(RC_UPLOADER,             uploaders),
a1167 2
     PARSE_STR(RC_URL_DOMAIN_PREFIXES,  URLDomainPrefixes),
     PARSE_STR(RC_URL_DOMAIN_SUFFIXES,  URLDomainSuffixes),
d1169 1
a1169 1
     PARSE_SET(RC_USE_FIXED_RECORDS,    UseFixedRecords),
d1171 2
a1172 2
#if defined(USE_MOUSE)
     PARSE_SET(RC_USE_MOUSE,            LYUseMouse),
d1174 6
a1179 9
     PARSE_SET(RC_USE_SELECT_POPUPS,    LYSelectPopups),
     PARSE_PRG(RC_UUDECODE_PATH,        ppUUDECODE),
     PARSE_SET(RC_VERBOSE_IMAGES,       verbose_img),
     PARSE_SET(RC_VI_KEYS_ALWAYS_ON,    vi_keys),
     PARSE_FUN(RC_VIEWER,               viewer_fun),
     PARSE_Env(RC_WAIS_PROXY,           0),
     PARSE_STR(RC_XLOADIMAGE_COMMAND,   XLoadImageCommand),
     PARSE_PRG(RC_ZCAT_PATH,            ppZCAT),
     PARSE_PRG(RC_ZIP_PATH,             ppZIP),
d1181 1
a1181 1
     PARSE_NIL
a1182 7
/* *INDENT-ON* */

static char *lynxcfginfo_url = NULL;	/* static */

#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
static char *configinfo_url = NULL;	/* static */
#endif
d1187 1
a1187 1
void free_lynx_cfg(void)
d1192 5
a1196 2
	ParseUnionPtr q = ParseUnionOf(tbl);

a1201 1

d1211 1
a1211 1
			break;
d1226 2
a1227 8
    free_all_item_lists();
#ifdef DIRED_SUPPORT
    reset_dired_menu();		/* frees and resets dired menu items - kw */
#endif
    FREE(lynxcfginfo_url);
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
    FREE(configinfo_url);
#endif
d1230 2
a1231 1
static Config_Type *lookup_config(char *name)
d1234 1
a1234 1
    char ch = (char) TOUPPER(*name);
d1240 1
a1240 1
	    && (0 == strcasecomp(name, tbl->name)))
d1248 3
a1250 57
/*
 * If the given value is an absolute path (by syntax), or we can read it, use
 * the value as given.  Otherwise, assume it must be in the same place we read
 * the parent configuration file from.
 *
 * Note:  only read files from the current directory if there's no parent
 * filename, otherwise it leads to user surprise.
 */
static char *actual_filename(const char *cfg_filename,
			     const char *parent_filename,
			     const char *dft_filename)
{
    char *my_filename = NULL;

    if (!LYisAbsPath(cfg_filename)
	&& !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
	if (!strncmp(cfg_filename, "~/", 2)) {
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename + 1);
	} else {
	    if (parent_filename != 0) {
		StrAllocCopy(my_filename, parent_filename);
		*LYPathLeaf(my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
	    }
	    if (my_filename == 0 || !LYCanReadFile(my_filename)) {
		StrAllocCopy(my_filename, dft_filename);
		*LYPathLeaf(my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
		if (!LYCanReadFile(my_filename)) {
		    StrAllocCopy(my_filename, cfg_filename);
		}
	    }
	}
    } else {
	StrAllocCopy(my_filename, cfg_filename);
    }
    return my_filename;
}

FILE *LYOpenCFG(const char *cfg_filename,
		const char *parent_filename,
		const char *dft_filename)
{
    char *my_file = actual_filename(cfg_filename, parent_filename, dft_filename);
    FILE *result;

    CTRACE((tfp, "opening config file %s\n", my_file));
    result = fopen(my_file, TXT_R);
    FREE(my_file);

    return result;
}

#define NOPTS_ ( TABLESIZE(Config_Table) - 1 )
typedef BOOL (optidx_set_t)[NOPTS_];

 /* if element is FALSE, then it's allowed in the current file */
a1258 91
/*
 * For simple (boolean, string, integer, time) values, set the corresponding
 * configuration variable.
 */
void LYSetConfigValue(char *name,
		      char *value)
{
    Config_Type *tbl = lookup_config(name);
    ParseUnionPtr q = ParseUnionOf(tbl);
    char *temp = 0;

    switch (tbl->type) {
    case CONF_BOOL:
	if (q->set_value != 0)
	    *(q->set_value) = is_true(value);
	break;

    case CONF_FUN:
	if (q->fun_value != 0)
	    (*(q->fun_value)) (value);
	break;

    case CONF_TIME:
	if (q->int_value != 0) {
	    float ival;

	    if (1 == sscanf(value, "%f", &ival)) {
		*(q->int_value) = (int) SECS2Secs(ival);
	    }
	}
	break;

    case CONF_ENUM:
	if (tbl->table != 0)
	    LYgetEnum(tbl->table, value, q->int_value);
	break;

    case CONF_INT:
	if (q->int_value != 0) {
	    int ival;

	    if (1 == sscanf(value, "%d", &ival))
		*(q->int_value) = ival;
	}
	break;

    case CONF_STR:
	if (q->str_value != 0)
	    StrAllocCopy(*(q->str_value), value);
	break;

    case CONF_ENV:
    case CONF_ENV2:

	if (tbl->type == CONF_ENV)
	    LYLowerCase(name);
	else
	    LYUpperCase(name);

	if (LYGetEnv(name) == 0) {
#ifdef VMS
	    Define_VMSLogical(name, value);
#else
	    if (q->str_value == 0)
		q->str_value = typecalloc(char *);

	    HTSprintf0(q->str_value, "%s=%s", name, value);
	    putenv(*(q->str_value));
#endif
	}
	break;
    case CONF_ADD_ITEM:
	if (q->add_value != 0)
	    add_item_to_list(value, q->add_value, FALSE);
	break;

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)
    case CONF_ADD_TRUSTED:
	add_trusted(value, q->def_value);
	break;
#endif

    case CONF_PRG:
	if (StrAllocCopy(temp, value))
	    HTSetProgramPath((ProgramPaths) (q->def_value), temp);
	break;

    default:
	break;
    }
}
d1267 6
a1272 5
static void do_read_cfg(const char *cfg_filename,
			const char *parent_filename,
			int nesting_level,
			FILE *fp0,
			optidx_set_t * allowed)
d1275 1
d1278 1
a1278 1
    CTRACE((tfp, "Loading cfg file '%s'.\n", cfg_filename));
d1281 2
a1282 2
     * Don't get hung up by an include file loop.  Arbitrary max depth
     * of 10.  - BL
d1288 3
a1290 3
	fprintf(stderr, gettext("Last attempted include was '%s',\n"), cfg_filename);
	fprintf(stderr, gettext("included from '%s'.\n"), parent_filename);
	exit_immediately(EXIT_FAILURE);
d1293 1
a1293 1
     * Locate and open the file.
d1296 1
a1296 1
	CTRACE((tfp, "No filename following -cfg switch!\n"));
d1299 7
a1305 2
    if ((fp = LYOpenCFG(cfg_filename, parent_filename, LYNX_CFG_FILE)) == 0) {
	CTRACE((tfp, "lynx.cfg file not found as '%s'\n", cfg_filename));
d1311 1
a1311 1
     * Process each line in the file.
a1312 8
#ifdef SH_EX
    if (show_cfg) {
	time_t t;

	time(&t);
	printf("### %s %s, at %s", LYNX_NAME, LYNX_VERSION, ctime(&t));
    }
#endif
d1317 5
a1321 1
	ParseUnionPtr q;
d1328 1
a1328 1
	if (ispunct(UCH(*name)))
d1333 1
a1333 2
	if (*name == 0)
	    continue;
d1336 1
a1336 1
	if ((value = strchr(name, ':')) == 0) {
a1337 1
	    CTRACE((tfp, "LYReadCFG: missing ':' %s\n", name));
d1345 1
a1345 1
	 * Trim off any trailing comments.
d1347 3
a1349 3
	 * (Apparently, the original code considers a trailing comment valid
	 * only if preceded by a space character but is not followed by a
	 * colon.  -- JED)
d1351 1
a1351 1
	if ((cp = strrchr(value, ':')) == 0)
d1353 1
a1353 1
	if ((cp = strchr(cp, '#')) != 0) {
d1355 1
a1355 1
	    if (isspace(UCH(*cp)))
a1358 1
	CTRACE2(TRACE_CFG, (tfp, "LYReadCFG %s:%s\n", name, value));
a1361 1
	    CTRACE((tfp, "LYReadCFG: ignored %s:%s\n", name, value));
a1363 4
#ifdef SH_EX
	if (show_cfg)
	    printf("%s:%s\n", name, value);
#endif
d1365 1
a1365 1
	if (allowed && (*allowed)[tbl - Config_Table]) {
d1367 2
a1368 2
		fprintf(stderr, "%s is not allowed in the %s\n",
			name, cfg_filename);
d1370 2
a1371 2
	       the html representation of lynx.cfg - say include this line
	       in bold, or something... */
d1376 5
a1380 1
	q = ParseUnionOf(tbl);
d1382 1
a1382 1
		? CONF_NIL
d1385 4
d1390 4
a1393 2
	case CONF_TIME:
	case CONF_ENUM:
d1395 11
d1407 4
d1413 16
a1428 4
	case CONF_PRG:
	case CONF_ADD_ITEM:
	case CONF_ADD_TRUSTED:
	    LYSetConfigValue(name, value);
d1431 26
a1456 18
	case CONF_INCLUDE:{
		/* include another file */
		optidx_set_t cur_set, anded_set;
		optidx_set_t *resultant_set = NULL;
		char *p1, *p2, savechar;
		BOOL any_optname_found = FALSE;

		char *url = NULL;
		char *cp1 = NULL;
		const char *sep = NULL;

		if ((p1 = strstr(value, sep = " for ")) != 0
#if defined(UNIX) && !defined(USE_DOS_DRIVES)
		    || (p1 = strstr(value, sep = ":")) != 0
#endif
		    ) {
		    *p1 = '\0';
		    p1 += strlen(sep);
a1457 3
#ifndef NO_CONFIG_INFO
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    char *my_file = actual_filename(value, cfg_filename, LYNX_CFG_FILE);
d1459 3
a1461 10
		    LYLocalFileToURL(&url, my_file);
		    FREE(my_file);
		    StrAllocCopy(cp1, value);
		    if (strchr(value, '&') || strchr(value, '<')) {
			LYEntify(&cp1, TRUE);
		    }

		    fprintf(fp0, "%s:<a href=\"%s\">%s</a>\n\n", name, url, cp1);
		    fprintf(fp0, "    #&lt;begin  %s&gt;\n", cp1);
		}
d1464 19
a1482 23
		if (p1) {
		    while (*(p1 = LYSkipBlanks(p1)) != 0) {
			Config_Type *tbl2;

			p2 = LYSkipNonBlanks(p1);
			savechar = *p2;
			*p2 = 0;

			tbl2 = lookup_config(p1);
			if (tbl2->name == 0) {
			    if (fp0 == NULL)
				fprintf(stderr,
					"unknown option name %s in %s\n",
					p1, cfg_filename);
			} else {
			    unsigned i;

			    if (!any_optname_found) {
				any_optname_found = TRUE;
				for (i = 0; i < NOPTS_; ++i)
				    cur_set[i] = TRUE;
			    }
			    cur_set[tbl2 - Config_Table] = FALSE;
d1484 1
a1484 4
			if (savechar && p2[1])
			    p1 = p2 + 1;
			else
			    break;
d1486 4
d1491 12
a1502 12
		if (!allowed) {
		    if (!any_optname_found)
			resultant_set = NULL;
		    else
			resultant_set = &cur_set;
		} else {
		    if (!any_optname_found)
			resultant_set = allowed;
		    else {
			optidx_set_AND(anded_set, *allowed, cur_set);
			resultant_set = &anded_set;
		    }
d1504 1
d1507 17
a1523 19
		/*
		 * Now list the opts that are allowed in included file.  If all
		 * opts are allowed, then emit nothing, else emit an effective set
		 * of allowed options in <ul>.  Option names will be uppercased.
		 * FIXME:  uppercasing option names can be considered redundant.
		 */
		if (fp0 != 0 && !no_lynxcfg_xinfo && resultant_set) {
		    char *buf = NULL;
		    unsigned i;

		    fprintf(fp0, "     Options allowed in this file:\n");
		    for (i = 0; i < NOPTS_; ++i) {
			if ((*resultant_set)[i])
			    continue;
			StrAllocCopy(buf, Config_Table[i].name);
			LYUpperCase(buf);
			fprintf(fp0, "         * %s\n", buf);
		    }
		    FREE(buf);
d1525 2
d1528 1
a1528 1
		do_read_cfg(value, cfg_filename, nesting_level + 1, fp0, resultant_set);
d1531 5
a1535 5
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    fprintf(fp0, "    #&lt;end of %s&gt;\n\n", cp1);
		    FREE(url);
		    FREE(cp1);
		}
d1540 10
a1553 1

d1566 1
a1566 1
    LYCloseInput(fp);
d1569 4
a1572 4
     * If any DOWNLOADER:  commands have always_enabled set (:TRUE), make
     * override_no_download TRUE, so that other restriction settings will not
     * block presentation of a download menu with those always_enabled options
     * still available.  - FM
d1575 1
a1575 1
	lynx_list_item_type *cur_download;
d1594 46
a1639 1
    LYConfigCookies();
a1640 1

d1642 5
a1646 4
void read_cfg(const char *cfg_filename,
	      const char *parent_filename,
	      int nesting_level,
	      FILE *fp0)
d1648 2
a1649 2
    HTInitProgramPaths();
    do_read_cfg(cfg_filename, parent_filename, nesting_level, fp0, NULL);
a1651 8
#ifndef NO_CONFIG_INFO
static void extra_cfg_link(FILE *fp, const char *href,
			   const char *name)
{
    fprintf(fp, "<a href=\"%s\">%s</a>",
	    href, name);
}
#endif /* NO_CONFIG_INFO */
d1654 3
a1656 3
 * Show rendered lynx.cfg data without comments, LYNXCFG:/ internal page. 
 * Called from getfile() cycle:  we create and load the page just in place and
 * return to mainloop().
d1658 2
a1659 1
int lynx_cfg_infopage(DocInfo *newdoc)
d1661 3
a1663 2
    static char tempfile[LY_MAXPATH] = "\0";
    DocAddress WWWDoc;		/* need on exit */
d1668 1
d1675 1
a1675 1
    if (!no_lynxcfg_xinfo && (strstr(newdoc->address, "LYNXCFG://reload"))) {
d1677 3
a1679 3
	 * Some stuff to reload read_cfg(), but also load options menu items
	 * and command-line options to make things consistent.  Implemented in
	 * LYMain.c
d1684 2
a1685 2
	 * now pop-up and return to updated LYNXCFG:/ page, remind
	 * postoptions() but much simpler:
d1687 12
d1700 6
a1705 2
	 * But check whether the top history document is really the expected
	 * LYNXCFG:  page.  - kw
d1707 2
a1708 28
	if (HTMainText && nhist > 0 &&
	    !strcmp(HTLoadedDocumentTitle(), LYNXCFG_TITLE) &&
	    !strcmp(HTLoadedDocumentURL(), HDOC(nhist - 1).address) &&
	    LYIsUIPage(HDOC(nhist - 1).address, UIP_LYNXCFG) &&
	    (!lynxcfginfo_url ||
	     strcmp(HTLoadedDocumentURL(), lynxcfginfo_url))) {
	    /*  the page was pushed, so pop-up. */
	    LYpop(newdoc);
	    WWWDoc.address = newdoc->address;
	    WWWDoc.post_data = newdoc->post_data;
	    WWWDoc.post_content_type = newdoc->post_content_type;
	    WWWDoc.bookmark = newdoc->bookmark;
	    WWWDoc.isHEAD = newdoc->isHEAD;
	    WWWDoc.safe = newdoc->safe;
	    LYforce_no_cache = FALSE;	/* ! */
	    LYoverride_no_cache = TRUE;		/* ! */

	    /*
	     * Working out of getfile() cycle we reset *no_cache manually here
	     * so HTLoadAbsolute() will return "Document already in memory": 
	     * it was forced reloading obsolete file again without this
	     * (overhead).
	     *
	     * Probably *no_cache was set in a wrong position because of the
	     * internal page...
	     */
	    if (!HTLoadAbsolute(&WWWDoc))
		return (NOT_FOUND);
d1710 1
a1710 3
	    HTuncache_current_document();	/* will never use again */
	    LYUnRegisterUIPage(UIP_LYNXCFG);
	}
d1713 1
a1713 1
	FREE(lynxcfginfo_url);	/* see below */
a1716 17
    /*
     * We regenerate the file if reloading has been requested (with LYK_NOCACHE
     * key).  If we did not regenerate, there would be no way to recover in a
     * session from a situation where the file is corrupted (for example
     * truncated because the file system was full when it was first created -
     * lynx doesn't check for write errors below), short of manual complete
     * removal or perhaps forcing regeneration with LYNXCFG://reload. 
     * Similarly, there would be no simple way to get a different page if
     * user_mode has changed to Advanced after the file was first generated in
     * a non-Advanced mode (the difference being in whether the page includes
     * the link to LYNXCFG://reload or not).
     *
     * We also try to regenerate the file if lynxcfginfo_url is set, indicating
     * that tempfile is valid, but the file has disappeared anyway.  This can
     * happen to a long-lived lynx process if for example some system script
     * periodically cleans up old files in the temp file space.  - kw
     */
d1718 6
a1723 5
    if (LYforce_no_cache && reloading) {
	FREE(lynxcfginfo_url);	/* flag to code below to regenerate - kw */
    } else if (lynxcfginfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(lynxcfginfo_url);	/* flag to code below to try again - kw */
d1725 1
a1725 2
    }
    if (lynxcfginfo_url == 0) {
d1727 1
a1727 2
	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	    return (NOT_FOUND);
d1729 2
a1730 1
	LYLocalFileToURL(&lynxcfginfo_url, tempfile);
a1731 4
	LYforce_no_cache = TRUE;	/* don't cache this doc */

	BeginInternalPage(fp0, LYNXCFG_TITLE, NULL);
	fprintf(fp0, "<pre>\n");
d1734 1
a1734 1
	if (!no_lynxcfg_xinfo) {
d1738 2
a1739 2
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
d1742 1
a1742 1
			temp);
d1745 1
a1745 1
			gettext("for more comments."));
d1749 1
a1749 1
		/* no absolute path... for lynx.cfg on DOS/Win32 */
d1751 2
a1752 2
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
d1755 1
a1755 1
			gettext("for more comments."));
d1758 4
a1761 28
#ifndef NO_CONFIG_INFO
#if defined(HAVE_CONFIG_H) && defined(USE_COLOR_STYLE)
	    if (!no_compileopts_info && !no_lynxcfg_xinfo) {
		fprintf(fp0, "%s</pre><ul><li>", SEE_ALSO);
		extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);

		fprintf(fp0, "<li>");
		LYLocalFileToURL(&temp, lynx_lss_file);
		extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		fprintf(fp0, "</ul><pre>\n");
	    } else
#endif
	    {
		fprintf(fp0, "%s ", SEE_ALSO);
#if defined(HAVE_CONFIG_H)
		if (!no_compileopts_info) {
		    extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);
		}
#endif
#if defined(USE_COLOR_STYLE)
		if (!no_lynxcfg_xinfo) {
		    LYLocalFileToURL(&temp, lynx_lss_file);
		    extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		}
#endif
		fprintf(fp0, "\n\n");
	    }
#endif /* NO_CONFIG_INFO */
a1762 5
	    /** a new experimental link ... **/
	    if (user_mode == ADVANCED_MODE)
		fprintf(fp0, "  <a href=\"%s//reload\">%s</a>\n",
			STR_LYNXCFG,
			gettext("RELOAD THE CHANGES"));
d1770 3
a1772 3
		    gettext("Your primary configuration"),
		    temp,
		    cp1);
d1779 1
a1779 2
	    fprintf(fp0, "<em>%s</em>\n\n",
		    gettext("The following is read from your lynx.cfg file."));
d1782 1
a1782 1
	 * Process the configuration file.
a1788 1
	LYRegisterUIPage(lynxcfginfo_url, UIP_LYNXCFG);
d1791 2
a1792 2
    /* return to getfile() cycle */
    StrAllocCopy(newdoc->address, lynxcfginfo_url);
d1801 2
a1802 5
	return (NOT_FOUND);
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
    return (NORMAL);
d1805 1
d1808 2
a1809 2
 * Compile-time definitions info, LYNXCOMPILEOPTS:/ internal page, from
 * getfile() cycle.
d1811 2
a1812 1
int lynx_compile_opts(DocInfo *newdoc)
d1814 1
a1814 2
    static char tempfile[LY_MAXPATH] = "\0";

d1818 2
a1819 1
    DocAddress WWWDoc;		/* need on exit */
d1822 1
a1822 18
    /* In general, create the page only once - compile-time data will not
     * change...  But we will regenerate the file anyway, in a few situations:
     *
     * (a) configinfo_url has been FREEd - this can happen if free_lynx_cfg()
     * was called as part of a LYNXCFG://reload action.
     *
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did not
     * regenerate, there would be no way to recover in a session from a
     * situation where the file is corrupted (for example truncated because the
     * file system was full when it was first created - lynx doesn't check for
     * write errors below), short of manual complete removal or forcing
     * regeneration with LYNXCFG://reload.
     *
     * (c) configinfo_url is set, indicating that tempfile is valid, but the
     * file has disappeared anyway.  This can happen to a long-lived lynx
     * process if for example some system script periodically cleans up old
     * files in the temp file space.  - kw
     */
d1824 4
a1827 5
    if (LYforce_no_cache && reloading) {
	FREE(configinfo_url);	/* flag to code below to regenerate - kw */
    } else if (configinfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(configinfo_url);	/* flag to code below to try again - kw */
d1829 1
a1829 4
    }
    if (configinfo_url == NULL) {
	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	    return (NOT_FOUND);
d1831 2
a1832 1
	LYLocalFileToURL(&configinfo_url, tempfile);
d1834 4
a1837 2
	BeginInternalPage(fp0, CONFIG_DEF_TITLE, NULL);
	fprintf(fp0, "<pre>\n");
a1849 1
	LYRegisterUIPage(configinfo_url, UIP_CONFIG_DEF);
d1852 2
a1853 2
    /* exit to getfile() cycle */
    StrAllocCopy(newdoc->address, configinfo_url);
d1862 2
a1863 5
	return (NOT_FOUND);
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
    return (NORMAL);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a5 1
#include <HTTP.h>  /* 'reloading' flag */
a6 1
#include <HTInit.h>
a26 1
#include <LYrcFile.h>
d36 2
a37 1
#include <HTNews.h>
d46 1
a46 1
PRIVATE BOOL is_true ARGS1(
d79 4
a82 2
PRIVATE void free_item_list ARGS1(
    lynx_list_item_type **,	ptr)
d84 2
a85 2
    lynx_list_item_type *cur = *ptr;
    lynx_list_item_type *next;
d87 1
d95 1
a95 2
    *ptr = NULL;
}
a96 7
/*
 *  Function for freeing the DOWNLOADER and UPLOADER menus list. - FM
 */
PRIVATE void free_all_item_lists NOARGS
{
    free_item_list(&printers);
    free_item_list(&downloaders);
d98 9
a106 1
    free_item_list(&uploaders);
d110 9
a118 1
    free_item_list(&externals);
d127 1
a127 1
PRIVATE void add_item_to_list ARGS3(
d129 1
a129 2
	lynx_list_item_type **, list_ptr,
	int,			special)
d132 1
a132 1
    lynx_list_item_type *cur_item, *prev_item;
d141 1
a141 1
	cur_item = typecalloc(lynx_list_item_type);
d146 1
a146 1
	atexit(free_all_item_lists);
d156 1
a156 1
	cur_item = typecalloc(lynx_list_item_type);
a165 2
    cur_item->override_primary_action = FALSE;
    cur_item->pagelen = 66;
d174 1
a174 1
	cur_item->name = typecallocn(char, colon-buffer+1);
d181 2
a182 4
	 *  Find end of command string and beginning of TRUE/FALSE option
	 *  field.  If we do not find a colon that ends the command string,
	 *  leave the always_enabled option flag as FALSE.  In any case,
	 *  we want the command string.
d188 1
a188 1
	    cur_item->command = typecallocn(char,next_colon-colon);
d193 1
d196 1
a196 11
	    colon = next_colon;
	    if ((next_colon = strchr(colon, ':')) != 0)
		*next_colon++ = '\0';
	    cur_item->always_enabled = is_true(colon);
	    if (next_colon) {
		if (special) {
		    cur_item->pagelen = atoi(next_colon);
		} else {
		    cur_item->override_primary_action = is_true(next_colon);
		}
	    }
d201 101
a301 20
PUBLIC lynx_list_item_type *find_item_by_number ARGS2(
	lynx_list_item_type *,	list_ptr,
	char *,			number)
{
    int value = atoi(number);
    while (value-- >= 0 && list_ptr != 0) {
	list_ptr = list_ptr->next;
    }
    return list_ptr;
}

PUBLIC int match_item_by_name ARGS3(
    lynx_list_item_type *,	ptr,
    char *,			name,
    BOOLEAN,			only_overriders)
{
    return
	(ptr->command != 0
	&& !strncasecomp(ptr->name, name, strlen(ptr->name))
	&& (only_overriders ? ptr->override_primary_action : 1));
d306 1
a306 1
#ifndef COLOR_WHITE
a307 3
#endif

#ifndef COLOR_BLACK
a310 4
#ifdef USE_DEFAULT_COLORS
int default_fg = DEFAULT_COLOR;
int default_bg = DEFAULT_COLOR;
#else
a312 1
#endif
d314 1
a314 1
PRIVATE CONST char *Color_Strings[16] =
d334 1
a334 1
#if defined(PDCURSES) && !defined(XCURSES)
a350 2
BOOL default_color_reset = FALSE;

d360 1
a360 7
    CTRACE2(TRACE_STYLE, (tfp, "check_color(%s,%d)\n", color, the_default));
    if (!strcasecomp(color, "default")) {
#ifdef USE_DEFAULT_COLORS
	if (!default_color_reset)
	    the_default = DEFAULT_COLOR;
#endif	/* USE_DEFAULT_COLORS */
	CTRACE2(TRACE_STYLE, (tfp, "=> default %d\n", the_default));
a361 1
    }
d366 2
a367 6
	if (!strcasecomp(color, Color_Strings[i])) {
	    int c = ColorCode(i);

	    CTRACE2(TRACE_STYLE, (tfp, "=> %d\n", c));
	    return c;
	}
a368 1
    CTRACE2(TRACE_STYLE, (tfp, "=> ERR_COLOR\n"));
a370 11

PUBLIC CONST char *lookup_color ARGS1(
    int,	code)
{
    unsigned n;
    for (n = 0; n < 16; n++) {
	if ((int) ColorCode(n) == code)
	    return Color_Strings[n];
    }
    return "default";
}
d373 1
a373 1
#if defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR)
d396 1
a396 1
    exit_immediately(EXIT_FAILURE);
a397 1
#endif /* defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR) */
a398 1
#if defined(USE_COLOR_TABLE)
d425 2
a426 2
    if ((check_color(fg, default_fg) == ERR_COLOR) ||
	(check_color(bg, default_bg) == ERR_COLOR))
d440 1
a440 7
#ifdef SOURCE_CACHE
static Config_Enum tbl_source_cache[] = {
    { "FILE",	SOURCE_CACHE_FILE },
    { "MEMORY",	SOURCE_CACHE_MEMORY },
    { "NONE",	SOURCE_CACHE_NONE },
    { NULL,		-1 },
};
d442 33
a474 5
static Config_Enum tbl_abort_source_cache[] = {
    { "KEEP",	SOURCE_CACHE_FOR_ABORTED_KEEP },
    { "DROP",	SOURCE_CACHE_FOR_ABORTED_DROP },
    { NULL,		-1 },
};
a476 30
#define PARSE_ADD(n,v)   {n, CONF_ADD_ITEM,    UNION_ADD(v), 0}
#define PARSE_SET(n,v)   {n, CONF_BOOL,        UNION_SET(v), 0}
#define PARSE_ENU(n,v,t) {n, CONF_ENUM,        UNION_INT(v), t}
#define PARSE_INT(n,v)   {n, CONF_INT,         UNION_INT(v), 0}
#define PARSE_TIM(n,v)   {n, CONF_TIME,        UNION_INT(v), 0}
#define PARSE_STR(n,v)   {n, CONF_STR,         UNION_STR(v), 0}
#define PARSE_PRG(n,v)   {n, CONF_PRG,         UNION_DEF(v), 0}
#define PARSE_Env(n,v)   {n, CONF_ENV,         UNION_ENV(v), 0}
#define PARSE_ENV(n,v)   {n, CONF_ENV2,        UNION_ENV(v), 0}
#define PARSE_FUN(n,v)   {n, CONF_FUN,         UNION_FUN(v), 0}
#define PARSE_REQ(n,v)   {n, CONF_INCLUDE,     UNION_FUN(v), 0}
#define PARSE_DEF(n,v)   {n, CONF_ADD_TRUSTED, UNION_DEF(v), 0}
#define PARSE_NIL        {NULL,0,              UNION_DEF(0), 0}

typedef enum {
    CONF_UNSPECIFIED = 0
    ,CONF_BOOL			/* BOOLEAN type */
    ,CONF_FUN
    ,CONF_TIME
    ,CONF_ENUM
    ,CONF_INT
    ,CONF_STR
    ,CONF_PRG
    ,CONF_ENV			/* from environment variable */
    ,CONF_ENV2			/* from environment VARIABLE */
    ,CONF_INCLUDE		/* include file-- handle special */
    ,CONF_ADD_ITEM
    ,CONF_ADD_TRUSTED
} Conf_Types;

d480 12
a491 1
   Conf_Types type;
a492 1
   Config_Enum *table;
d496 1
a496 1
PRIVATE int assume_charset_fun ARGS1(
d509 1
a509 1
PRIVATE int assume_local_charset_fun ARGS1(
d516 1
a516 1
PRIVATE int assume_unrec_charset_fun ARGS1(
d523 1
a523 1
PRIVATE int character_set_fun ARGS1(
d527 2
a528 10

    if (i < 0) {
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
	if (auto_display_charset >= 0
	    && (!strnicmp(value,"AutoDetect ",11)
		|| !strnicmp(value,"AutoDetect-2 ",13)))
	    current_char_set = auto_display_charset;
#endif
	/* do nothing here: so fallback to userdefs.h */
    }
d535 1
a535 1
PRIVATE int outgoing_mail_charset_fun ARGS1(
a543 39
#ifdef EXP_ASSUMED_COLOR
/*
 *  Process string buffer fields for ASSUMED_COLOR setting.
 */
PRIVATE int assumed_color_fun ARGS1(
	char *, buffer)
{
    char *fg = buffer, *bg;
    char *temp = 0;

    StrAllocCopy(temp, buffer);	/* save a copy, for error messages */

    /*
     *	We are expecting a line of the form:
     *	  FOREGROUND:BACKGROUND
     */
    if (NULL == (bg = find_colon(fg)))
	exit_with_color_syntax(temp);
    *bg++ = '\0';

    default_fg = check_color(fg, default_fg);
    default_bg = check_color(bg, default_bg);

    if (default_fg == ERR_COLOR
     || default_bg == ERR_COLOR)
	exit_with_color_syntax(temp);
#ifdef USE_SLANG
    /*
     * Sorry - the order of initialization of slang precludes setting the
     * default colors from the lynx.cfg file, since slang is already
     * initialized before the file is read, and there is no interface defined
     * for setting it from the application (that's one of the problems with
     * using environment variables rather than a programmable interface) -TD
     */
#endif
    FREE(temp);
    return 0;
}
#endif /* EXP_ASSUMED_COLOR */
d546 1
a546 1
PRIVATE int color_fun ARGS1(
d554 1
a554 1
PRIVATE int default_bookmark_file_fun ARGS1(
d557 4
a560 1
    set_default_bookmark_page(value);
d564 1
a564 1
PRIVATE int default_cache_size_fun ARGS1(
d572 1
a572 1
PRIVATE int default_editor_fun ARGS1(
d579 1
a579 1
PRIVATE int numbers_as_arrows_fun ARGS1(
d590 13
d604 1
a604 1
PRIVATE int dired_menu_fun ARGS1(
d612 1
a612 1
PRIVATE int jumpfile_fun ARGS1(
d619 1
a619 1
	CTRACE((tfp, "Failed to register %s\n", buffer));
d626 1
a626 1
PRIVATE int keyboard_layout_fun ARGS1(
d630 1
a630 1
	CTRACE((tfp, "Failed to set keyboard layout %s\n", key));
d635 1
a635 1
PRIVATE int keymap_fun ARGS1(
d638 1
a638 1
    char *func, *efunc;
d640 1
a640 1
    if ((func = strchr(key, ':')) != NULL) {
a641 1
	efunc = strchr(func, ':');
d643 7
a649 85
	/* Allow third field for line-editor action. - kw */
	if (efunc == func) {	/* have 3rd field, but 2nd field empty */
	    func = NULL;
	} else if (efunc && strncasecomp(efunc + 1, "DIRED", 5) == 0) {
	    if (!remap(key, strtok(func, " \t\n:#"), TRUE)) {
		fprintf(stderr,
			gettext("key remapping of %s to %s for %s failed\n"),
			key, func, efunc + 1);
	    } else if (func && !strcmp("TOGGLE_HELP", func)) {
		LYUseNoviceLineTwo = FALSE;
	    }
	    return 0;
	} else if (!remap(key, strtok(func, " \t\n:#"), FALSE)) {
	    fprintf(stderr, gettext("key remapping of %s to %s failed\n"),
		    key, func);
	} else {
	    if (func && !strcmp("TOGGLE_HELP", func))
		LYUseNoviceLineTwo = FALSE;
	}
	if (efunc) {
	    efunc++;
	    if (efunc == strtok((func ? NULL : efunc), " \t\n:#") && *efunc) {
		BOOLEAN success = FALSE;
		int lkc = lkcstring_to_lkc(key);
		int lec = -1;
		int select_edi = 0;
		char *sselect_edi = strtok(NULL, " \t\n:#");
		char **endp = &sselect_edi;
		if (sselect_edi) {
		    if (*sselect_edi)
			select_edi = strtol(sselect_edi, endp, 10);
		    if (**endp != '\0') {
			fprintf(stderr,
				gettext(
	"invalid line-editor selection %s for key %s, selecting all\n"),
				sselect_edi, key);
			select_edi = 0;
		    }
		}
		/*
		 *  PASS! tries to enter the key into the LYLineEditors
		 *  bindings in a different way from PASS, namely as
		 *  binding that maps to the specific lynx actioncode
		 *  (rather than to LYE_FORM_PASS).  That only works
		 *  for lynx keycodes with modifier bit set, and we
		 *  have no documented/official way to specify this
		 *  in the KEYMAP directive, although it can be made
		 *  to work e.g. by specifying a hex value that has the
		 *  modifier bit set.  But knowledge about the bit
		 *  pattern of modifiers should remain in internal
		 *  matter subject to change...  At any rate, if
		 *  PASS! fails try it the same way as for PASS. - kw
		 */
		if (!success && strcasecomp(efunc, "PASS!") == 0) {
		    if (func) {
			lec = LYE_FORM_LAC|lacname_to_lac(func);
			success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		    }
		    if (!success)
			fprintf(stderr,
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    else
			return 0;
		}
		if (!success) {
		    lec = lecname_to_lec(efunc);
		    success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		}
		if (!success) {
		    if (lec != -1) {
			fprintf(stderr,
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    } else {
			fprintf(stderr,
				gettext(
	   "setting of line-editor binding for key %s (0x%x) for %s failed\n"),
				key, lkc, efunc);
		    }
		}
	    }
	}
d654 1
a654 1
PRIVATE int localhost_alias_fun ARGS1(
d662 1
a662 1
PRIVATE int lynxcgi_environment_fun ARGS1(
d670 1
a670 1
PRIVATE int lynx_sig_file_fun ARGS1(
d679 1
a679 1
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
d681 1
a681 1
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
d687 1
a687 1
PRIVATE int news_chunk_size_fun ARGS1(
d700 1
a700 1
PRIVATE int news_max_chunk_fun ARGS1(
d713 1
a713 1
PRIVATE int news_posting_fun ARGS1(
d717 1
a717 1
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
d723 1
a723 1
PRIVATE int cern_rulesfile_fun ARGS1(
d752 1
a752 1
    exit_immediately(EXIT_FAILURE);
d757 1
a757 1
PRIVATE int printer_fun ARGS1(
d760 1
a760 1
    add_item_to_list(value, &printers, TRUE);
d764 2
a765 1
PRIVATE int referer_with_query_fun ARGS1(
d768 7
a774 6
    if (!strncasecomp(value, "SEND", 4))
	LYRefererWithQuery = 'S';
    else if (!strncasecomp(value, "PARTIAL", 7))
	LYRefererWithQuery = 'P';
    else
	LYRefererWithQuery = 'D';
d777 1
d779 1
a779 1
PRIVATE int suffix_fun ARGS1(
d782 1
a782 3
    char *mime_type, *p;
    char *encoding = NULL, *sq = NULL, *description = NULL;
    double q = 1.0;
d785 1
a785 2
    || (NULL == (mime_type = strchr (value, ':')))) {
	CTRACE((tfp, "Invalid SUFFIX:%s ignored.\n", value));
a786 1
    }
a788 21
    if (*mime_type) {
	if ((encoding = strchr(mime_type, ':')) != NULL) {
	    *encoding++ = '\0';
	    if ((sq = strchr(encoding, ':')) != NULL) {
		*sq++ = '\0';
		if ((description = strchr(sq, ':')) != NULL) {
		    *description++ = '\0';
		    if ((p = strchr(sq, ':')) != NULL)
			*p = '\0';
		    LYTrimTail(description);
		}
		LYRemoveBlanks(sq);
		if (!*sq)
		    sq = NULL;
	    }
	    LYRemoveBlanks(encoding);
	    LYLowerCase(encoding);
	    if (!*encoding)
		encoding = NULL;
	}
    }
d791 1
a791 37
    /*
     *  Not converted to lowercase on input, to make it possible to
     *  reproduce the equivalent of some of the HTInit.c defaults
     *  that use mixed case, although that is not recomended. - kw
     */ /*LYLowerCase(mime_type);*/

    if (!*mime_type) { /* that's ok now, with an encoding!  */
	CTRACE((tfp, "SUFFIX:%s without MIME type for %s\n", value,
	       encoding ? encoding : "what?"));
	mime_type = NULL; /* that's ok now, with an encoding!  */
	if (!encoding)
	    return 0;
    }

    if (!encoding) {
	if (strstr(mime_type, "tex") != NULL ||
	    strstr(mime_type, "postscript") != NULL ||
	    strstr(mime_type, "sh") != NULL ||
	    strstr(mime_type, "troff") != NULL ||
	    strstr(mime_type, "rtf") != NULL)
	    encoding = "8bit";
	else
	    encoding = "binary";
    }
    if (!sq) {
	q = 1.0;
    } else {
	double df = strtod(sq, &p);
	if (p == sq && df == 0.0) {
	    CTRACE((tfp, "Invalid q=%s for SUFFIX:%s, using -1.0\n",
		   sq, value));
	    q = -1.0;
	} else {
	    q = df;
	}
    }
    HTSetSuffix5(value, mime_type, encoding, description, q);
d793 8
a800 2
    return 0;
}
a801 25
PRIVATE int suffix_order_fun ARGS1(
	char *,		value)
{
    char *p = value;
    char *optn;
    BOOLEAN want_file_init_now = FALSE;

    LYUseBuiltinSuffixes = TRUE;
    while ((optn = HTNextTok(&p, ", ", "", NULL)) != NULL) {
	if (!strcasecomp(optn, "NO_BUILTIN")) {
	    LYUseBuiltinSuffixes = FALSE;
	} else if (!strcasecomp(optn, "PRECEDENCE_HERE")) {
	    want_file_init_now = TRUE;
	} else if (!strcasecomp(optn, "PRECEDENCE_OTHER")) {
	    want_file_init_now = FALSE;
	} else {
	    CTRACE((tfp, "Invalid SUFFIX_ORDER:%s\n", optn));
	    break;
	}
    }

    if (want_file_init_now && !FileInitAlreadyDone) {
	HTFileInit();
	FileInitAlreadyDone = TRUE;
    }
d805 1
a805 1
PRIVATE int system_editor_fun ARGS1(
d813 1
a813 1
PRIVATE int viewer_fun ARGS1(
a856 93
PRIVATE int nonrest_sigwinch_fun ARGS1(
	char *,		value)
{
    if (!strncasecomp(value, "XWINDOWS", 8)) {
	LYNonRestartingSIGWINCH = (BOOL) (LYgetXDisplay() != NULL);
    } else {
	LYNonRestartingSIGWINCH = is_true(value);
    }
    return 0;
}

#ifdef EXP_CHARSET_CHOICE
PRIVATE void matched_charset_choice ARGS2(
	BOOL,	display_charset,
	int,	i)
{
    int j;

    if (display_charset && !custom_display_charset) {
	for (custom_display_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_display = TRUE;
    } else if (!display_charset && !custom_assumed_doc_charset) {
	for (custom_assumed_doc_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_assumed = TRUE;
    }
    if (display_charset)
	charset_subsets[i].hide_display = FALSE;
    else
	charset_subsets[i].hide_assumed = FALSE;
}

PRIVATE int parse_charset_choice ARGS2(
	char *,	p,
	BOOL,	display_charset) /*if FALSE, then assumed doc charset*/
{
    int len, i;
    int matches = 0;

    /*only one charset choice is allowed per line!*/
    LYTrimHead(p);
    LYTrimTail(p);
    CTRACE((tfp, "parsing charset choice for %s:\"%s\"",
	(display_charset ? "display charset" : "assumed doc charset"), p));
    len = strlen(p);
    if (!len) {
	CTRACE((tfp," - EMPTY STRING\n"));
	return 1;
    }
    if (*p == '*' && len == 1) {
	if (display_charset)
	    for (custom_display_charset = TRUE, i = 0 ;i < LYNumCharsets; ++i)
		charset_subsets[i].hide_display = FALSE;
	else
	    for (custom_assumed_doc_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_assumed = FALSE;
	CTRACE((tfp," - all unhidden\n"));
	return 0;
    }
    if (p[len-1] == '*') {
	--len;
	for (i = 0 ;i < LYNumCharsets; ++i) {
	    if ((!strncasecomp(p, LYchar_set_names[i], len)) ||
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len)) ) {
		++matches;
		matched_charset_choice(display_charset, i);
	    }
	}
	CTRACE((tfp," - %d matches\n", matches));
	return 0;
    } else {
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strcasecomp(p,LYchar_set_names[i])) ||
		(!strcasecomp(p,LYCharSet_UC[i].MIMEname)) ) {
		matched_charset_choice(display_charset, i);
		CTRACE((tfp," - OK\n"));
		++matches;
		return 0;
	    }
	}
	CTRACE((tfp," - NOT recognised\n"));
	return 1;
    }
}

PRIVATE int parse_display_charset_choice ARGS1(char*,p)
{
    return parse_charset_choice(p,1);
}

PRIVATE int parse_assumed_doc_charset_choice ARGS1(char*,p)
{
    return parse_charset_choice(p,0);
}
d858 1
a858 1
#endif /* EXP_CHARSET_CHOICE */
d860 1
a860 2
#ifdef USE_PRETTYSRC
PRIVATE void html_src_bad_syntax ARGS2(
d869 1
a869 1
    exit_immediately(EXIT_FAILURE);
d872 3
a874 2
PRIVATE int parse_html_src_spec ARGS3(
	    HTlexeme, lexeme_code,
d884 1
a884 1
    if (isEmpty(value)) return 0; /* silently ignoring*/
d893 2
a894 4
    CTRACE((tfp,"ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",value,ts2,option_name));
    html_src_clean_item(lexeme_code);
    if ( html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE) )
d901 2
a902 1
    StrAllocCopy(HTL_tagspecs[lexeme_code],value);
d907 17
a923 34
PRIVATE int psrcspec_fun ARGS1(char*,s)
{
    char* e;
    static Config_Enum lexemnames[] =
    {
	{ "comm",	HTL_comm	},
	{ "tag",	HTL_tag		},
	{ "attrib",	HTL_attrib	},
	{ "attrval",	HTL_attrval	},
	{ "abracket",	HTL_abracket	},
	{ "entity",	HTL_entity	},
	{ "href",	HTL_href	},
	{ "entire",	HTL_entire	},
	{ "badseq",	HTL_badseq	},
	{ "badtag",	HTL_badtag	},
	{ "badattr",	HTL_badattr	},
	{ "sgmlspecial", HTL_sgmlspecial },
	{ NULL,		-1		}
    };
    int found;

    e = strchr(s, ':');
    if (!e) {
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",s));
	return 0;
    }
    *e = '\0';
    if (!LYgetEnum(lexemnames, s, &found)) {
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",s,e+1));
	return 0;
    }
    parse_html_src_spec(found, e+1, s);
    return 0;
}
d925 1
a925 1
PRIVATE int read_htmlsrc_attrname_xform ARGS1( char*,str)
d930 1
a930 1
	    CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n", val));
d934 2
a935 2
	CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored): %s\n",
		    str));
d940 1
a940 1
PRIVATE int read_htmlsrc_tagname_xform ARGS1( char*,str)
d945 1
a945 1
	    CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n", val));
d949 2
a950 2
	CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored): %s\n",
		    str));
d954 5
d961 3
a963 2
/* This table is searched ignoring case */
PRIVATE Config_Type Config_Table [] =
d965 3
a967 3
     PARSE_SET(RC_ACCEPT_ALL_COOKIES,   LYAcceptAllCookies),
     PARSE_TIM(RC_ALERTSECS,            AlertSecs),
     PARSE_SET(RC_ALWAYS_RESUBMIT_POSTS, LYresubmit_posts),
d969 1
a969 10
     PARSE_DEF(RC_ALWAYS_TRUSTED_EXEC,  ALWAYS_EXEC_PATH),
#endif
     PARSE_FUN(RC_ASSUME_CHARSET,       assume_charset_fun),
     PARSE_FUN(RC_ASSUME_LOCAL_CHARSET, assume_local_charset_fun),
     PARSE_FUN(RC_ASSUME_UNREC_CHARSET, assume_unrec_charset_fun),
#ifdef EXP_ASSUMED_COLOR
     PARSE_FUN(RC_ASSUMED_COLOR,        assumed_color_fun),
#endif
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN(RC_ASSUMED_DOC_CHARSET_CHOICE, parse_assumed_doc_charset_choice),
d971 11
a981 21
#ifdef DIRED_SUPPORT
     PARSE_INT(RC_AUTO_UNCACHE_DIRLISTS, LYAutoUncacheDirLists),
#endif
#ifndef DISABLE_BIBP
     PARSE_STR(RC_BIBP_BIBHOST,         BibP_bibhost),
     PARSE_STR(RC_BIBP_GLOBALSERVER,    BibP_globalserver),
#endif
     PARSE_SET(RC_BLOCK_MULTI_BOOKMARKS, LYMBMBlocked),
     PARSE_SET(RC_BOLD_H1,              bold_H1),
     PARSE_SET(RC_BOLD_HEADERS,         bold_headers),
     PARSE_SET(RC_BOLD_NAME_ANCHORS,    bold_name_anchors),
     PARSE_PRG(RC_BZIP2_PATH,           ppBZIP2),
     PARSE_SET(RC_CASE_SENSITIVE_ALWAYS_ON, case_sensitive),
     PARSE_FUN(RC_CHARACTER_SET,        character_set_fun),
#ifdef CAN_SWITCH_DISPLAY_CHARSET
     PARSE_STR(RC_CHARSET_SWITCH_RULES, charset_switch_rules),
     PARSE_STR(RC_CHARSETS_DIRECTORY,   charsets_directory),
#endif
     PARSE_SET(RC_CHECKMAIL,            check_mail),
     PARSE_PRG(RC_CHMOD_PATH,           ppCHMOD),
     PARSE_SET(RC_COLLAPSE_BR_TAGS,     LYCollapseBRs),
d983 1
a983 1
     PARSE_FUN(RC_COLOR,                color_fun),
d985 1
a985 10
     PARSE_PRG(RC_COMPRESS_PATH,        ppCOMPRESS),
     PARSE_PRG(RC_COPY_PATH,            ppCOPY),
     PARSE_INT(RC_CONNECT_TIMEOUT,      connect_timeout),
     PARSE_STR(RC_COOKIE_ACCEPT_DOMAINS, LYCookieSAcceptDomains),
#ifdef EXP_PERSISTENT_COOKIES
     PARSE_STR(RC_COOKIE_FILE,          LYCookieFile),
#endif /* EXP_PERSISTENT_COOKIES */
     PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieSLooseCheckDomains),
     PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieSQueryCheckDomains),
     PARSE_STR(RC_COOKIE_REJECT_DOMAINS, LYCookieSRejectDomains),
d987 1
a987 1
     PARSE_STR(RC_COOKIE_SAVE_FILE,     LYCookieSaveFile),
d989 5
a993 2
     PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieSStrictCheckDomains),
     PARSE_Env(RC_CSO_PROXY,		0),
d995 1
a995 1
     PARSE_PRG(RC_CSWING_PATH,          ppCSWING),
d997 6
a1002 8
     PARSE_TIM(RC_DELAYSECS,            DebugSecs),
     PARSE_FUN(RC_DEFAULT_BOOKMARK_FILE, default_bookmark_file_fun),
     PARSE_FUN(RC_DEFAULT_CACHE_SIZE,   default_cache_size_fun),
     PARSE_FUN(RC_DEFAULT_EDITOR,       default_editor_fun),
     PARSE_STR(RC_DEFAULT_INDEX_FILE,   indexfile),
     PARSE_ENU(RC_DEFAULT_KEYPAD_MODE,  keypad_mode, tbl_keypad_mode),
     PARSE_FUN(RC_DEFAULT_KEYPAD_MODE_NUMARO, numbers_as_arrows_fun),
     PARSE_ENU(RC_DEFAULT_USER_MODE,    user_mode, tbl_user_mode),
d1004 1
a1004 1
     PARSE_INT(RC_DEFAULT_VIRTUAL_MEMORY_SIZE, HTVirtualMemorySize),
d1007 1
a1007 4
     PARSE_FUN(RC_DIRED_MENU,           dired_menu_fun),
#endif
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN(RC_DISPLAY_CHARSET_CHOICE, parse_display_charset_choice),
d1009 3
a1011 4
     PARSE_ADD(RC_DOWNLOADER,           downloaders),
     PARSE_SET(RC_EMACS_KEYS_ALWAYS_ON, emacs_keys),
     PARSE_FUN(RC_ENABLE_LYNXRC,        enable_lynxrc),
     PARSE_SET(RC_ENABLE_SCROLLBACK,    enable_scrollback),
d1013 1
a1013 12
     PARSE_ADD(RC_EXTERNAL,             externals),
#endif
     PARSE_Env(RC_FINGER_PROXY,         0),
#if defined(_WINDOWS)	/* 1998/10/05 (Mon) 17:34:15 */
     PARSE_SET(RC_FOCUS_WINDOW,         focus_window),
#endif
     PARSE_SET(RC_FORCE_8BIT_TOUPPER,   UCForce8bitTOUPPER),
     PARSE_ENU(RC_FORCE_COOKIE_PROMPT,  cookie_noprompt, tbl_force_prompt),
     PARSE_SET(RC_FORCE_EMPTY_HREFLESS_A, force_empty_hrefless_a),
     PARSE_SET(RC_FORCE_SSL_COOKIES_SECURE, LYForceSSLCookiesSecure),
#ifdef USE_SSL
     PARSE_ENU(RC_FORCE_SSL_PROMPT,     ssl_noprompt, tbl_force_prompt),
d1015 3
d1019 1
a1019 1
     PARSE_SET(RC_FORMS_OPTIONS,        LYUseFormsOptions),
d1021 42
a1062 27
     PARSE_SET(RC_FTP_PASSIVE,          ftp_passive),
     PARSE_Env(RC_FTP_PROXY,            0),
     PARSE_STR(RC_GLOBAL_EXTENSION_MAP, global_extension_map),
     PARSE_STR(RC_GLOBAL_MAILCAP,       global_type_map),
     PARSE_Env(RC_GOPHER_PROXY,         0),
     PARSE_SET(RC_GOTOBUFFER,           goto_buffer),
     PARSE_PRG(RC_GZIP_PATH,            ppGZIP),
     PARSE_STR(RC_HELPFILE,             helpfile),
#ifdef MARK_HIDDEN_LINKS
     PARSE_STR(RC_HIDDEN_LINK_MARKER,   hidden_link_marker),
#endif
     PARSE_SET(RC_HISTORICAL_COMMENTS,  historical_comments),
#ifdef USE_PRETTYSRC
     PARSE_FUN(RC_HTMLSRC_ATTRNAME_XFORM, read_htmlsrc_attrname_xform),
     PARSE_FUN(RC_HTMLSRC_TAGNAME_XFORM, read_htmlsrc_tagname_xform),
#endif
     PARSE_Env(RC_HTTP_PROXY,           0),
     PARSE_Env(RC_HTTPS_PROXY,          0),
     PARSE_REQ(RC_INCLUDE,              0),
     PARSE_TIM(RC_INFOSECS,             InfoSecs),
     PARSE_PRG(RC_INSTALL_PATH,         ppINSTALL),
     PARSE_STR(RC_JUMP_PROMPT,          jumpprompt),
     PARSE_SET(RC_JUMPBUFFER,           jump_buffer),
     PARSE_FUN(RC_JUMPFILE,             jumpfile_fun),
#ifdef EXP_JUSTIFY_ELTS
     PARSE_SET(RC_JUSTIFY,              ok_justify),
     PARSE_INT(RC_JUSTIFY_MAX_VOID_PERCENT, justify_max_void_percent),
d1064 4
a1067 2
#ifdef EXP_KEYBOARD_LAYOUT
     PARSE_FUN(RC_KEYBOARD_LAYOUT,      keyboard_layout_fun),
a1068 2
     PARSE_FUN(RC_KEYMAP,               keymap_fun),
     PARSE_SET(RC_LEFTARROW_IN_TEXTFLD_PROMPT, textfield_prompt_at_left_edge),
d1070 1
a1070 1
     PARSE_STR(RC_LIST_FORMAT,          list_format),
d1072 2
a1073 5
#ifndef DISABLE_NEWS
     PARSE_SET(RC_LIST_NEWS_DATES,      LYListNewsDates),
     PARSE_SET(RC_LIST_NEWS_NUMBERS,    LYListNewsNumbers),
#endif
     PARSE_STR(RC_LOCAL_DOMAIN,         LYLocalDomain),
d1075 2
a1076 2
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_ALWAYS, local_exec),
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_LOCAL, local_exec_on_local_files),
a1077 3
     PARSE_FUN(RC_LOCALHOST_ALIAS,      localhost_alias_fun),
     PARSE_STR(RC_LYNX_HOST_NAME,       LYHostName),
     PARSE_FUN(RC_LYNX_SIG_FILE,        lynx_sig_file_fun),
d1079 1
d1081 1
a1081 1
     PARSE_STR(RC_LYNXCGI_DOCUMENT_ROOT, LYCgiDocumentRoot),
a1082 1
     PARSE_FUN(RC_LYNXCGI_ENVIRONMENT,  lynxcgi_environment_fun),
d1084 5
a1088 2
#if USE_VMS_MAILER
     PARSE_STR(RC_MAIL_ADRS,            mail_adrs),
d1090 6
a1095 9
     PARSE_SET(RC_MAIL_SYSTEM_ERROR_LOGGING, error_logging),
     PARSE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images),
     PARSE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts),
     PARSE_TIM(RC_MESSAGESECS,          MessageSecs),
     PARSE_SET(RC_MINIMAL_COMMENTS,     minimal_comments),
     PARSE_PRG(RC_MKDIR_PATH,           ppMKDIR),
     PARSE_ENU(RC_MULTI_BOOKMARK_SUPPORT, LYMultiBookmarks, tbl_multi_bookmarks),
     PARSE_PRG(RC_MV_PATH,              ppMV),
     PARSE_SET(RC_NCR_IN_BOOKMARKS,     UCSaveBookmarksInUnicode),
d1097 11
a1107 13
     PARSE_FUN(RC_NEWS_CHUNK_SIZE,      news_chunk_size_fun),
     PARSE_FUN(RC_NEWS_MAX_CHUNK,       news_max_chunk_fun),
     PARSE_FUN(RC_NEWS_POSTING,         news_posting_fun),
     PARSE_Env(RC_NEWS_PROXY,           0),
     PARSE_Env(RC_NEWSPOST_PROXY,       0),
     PARSE_Env(RC_NEWSREPLY_PROXY,      0),
     PARSE_Env(RC_NNTP_PROXY,           0),
     PARSE_ENV(RC_NNTPSERVER,           0), /* actually NNTPSERVER */
#endif
     PARSE_SET(RC_NUMBER_FIELDS_ON_LEFT,number_fields_on_left),
     PARSE_SET(RC_NUMBER_LINKS_ON_LEFT, number_links_on_left),
     PARSE_SET(RC_NO_DOT_FILES,         no_dotfiles),
     PARSE_SET(RC_NO_FILE_REFERER,      no_filereferer),
d1109 1
a1109 1
     PARSE_SET(RC_NO_FORCED_CORE_DUMP,  LYNoCore),
d1111 5
a1115 7
     PARSE_SET(RC_NO_FROM_HEADER,       LYNoFromHeader),
     PARSE_SET(RC_NO_ISMAP_IF_USEMAP,   LYNoISMAPifUSEMAP),
     PARSE_Env(RC_NO_PROXY,             0),
     PARSE_SET(RC_NO_REFERER_HEADER,    LYNoRefererHeader),
     PARSE_SET(RC_NO_TABLE_CENTER,      no_table_center),
     PARSE_FUN(RC_NONRESTARTING_SIGWINCH, nonrest_sigwinch_fun),
     PARSE_FUN(RC_OUTGOING_MAIL_CHARSET, outgoing_mail_charset_fun),
d1117 2
a1118 2
     PARSE_SET(RC_PARTIAL,              display_partial_flag),
     PARSE_INT(RC_PARTIAL_THRES,        partial_threshold),
d1121 1
a1121 1
     PARSE_SET(RC_PERSISTENT_COOKIES,   persistent_cookies),
d1123 8
a1130 20
     PARSE_STR(RC_PERSONAL_EXTENSION_MAP, personal_extension_map),
     PARSE_STR(RC_PERSONAL_MAILCAP,     personal_type_map),
     PARSE_STR(RC_PREFERRED_CHARSET,    pref_charset),
     PARSE_STR(RC_PREFERRED_LANGUAGE,   language),
     PARSE_SET(RC_PREPEND_BASE_TO_SOURCE, LYPrependBaseToSource),
     PARSE_SET(RC_PREPEND_CHARSET_TO_SOURCE, LYPrependCharsetToSource),
#ifdef USE_PRETTYSRC
     PARSE_SET(RC_PRETTYSRC,            LYpsrc),
     PARSE_FUN(RC_PRETTYSRC_SPEC,       psrcspec_fun),
     PARSE_SET(RC_PRETTYSRC_VIEW_NO_ANCHOR_NUM, psrcview_no_anchor_numbering),
#endif
     PARSE_FUN(RC_PRINTER,              printer_fun),
     PARSE_SET(RC_QUIT_DEFAULT_YES,     LYQuitDefaultYes),
     PARSE_FUN(RC_REFERER_WITH_QUERY,   referer_with_query_fun),
#ifdef EXP_CMD_LOGGING
     PARSE_TIM(RC_REPLAYSECS,           ReplaySecs),
#endif
     PARSE_SET(RC_REUSE_TEMPFILES,      LYReuseTempfiles),
     PARSE_PRG(RC_RLOGIN_PATH,          ppRLOGIN),
     PARSE_PRG(RC_RM_PATH,              ppRM),
d1132 2
a1133 2
     PARSE_FUN(RC_RULE,                 HTSetConfiguration),
     PARSE_FUN(RC_RULESFILE,            cern_rulesfile_fun),
d1135 11
a1145 15
     PARSE_STR(RC_SAVE_SPACE,           lynx_save_space),
     PARSE_SET(RC_SCAN_FOR_BURIED_NEWS_REFS, scan_for_buried_news_references),
#ifdef USE_SCROLLBAR
     PARSE_SET(RC_SCROLLBAR,            LYShowScrollbar),
     PARSE_SET(RC_SCROLLBAR_ARROW,      LYsb_arrow),
#endif
     PARSE_SET(RC_SEEK_FRAG_AREA_IN_CUR, LYSeekFragAREAinCur),
     PARSE_SET(RC_SEEK_FRAG_MAP_IN_CUR, LYSeekFragMAPinCur),
     PARSE_SET(RC_SET_COOKIES,          LYSetCookies),
     PARSE_SET(RC_SHOW_CURSOR,          LYShowCursor),
     PARSE_ENU(RC_SHOW_KB_RATE,         LYTransferRate, tbl_transfer_rate),
     PARSE_Env(RC_SNEWS_PROXY,          0),
     PARSE_Env(RC_SNEWSPOST_PROXY,      0),
     PARSE_Env(RC_SNEWSREPLY_PROXY,     0),
     PARSE_SET(RC_SOFT_DQUOTES,         soft_dquotes),
d1147 1
a1147 2
     PARSE_ENU(RC_SOURCE_CACHE,         LYCacheSource, tbl_source_cache),
     PARSE_ENU(RC_SOURCE_CACHE_FOR_ABORTED, LYCacheSourceForAborted, tbl_abort_source_cache),
d1149 8
a1156 20
     PARSE_STR(RC_STARTFILE,            startfile),
     PARSE_SET(RC_STRIP_DOTDOT_URLS,    LYStripDotDotURLs),
     PARSE_SET(RC_SUBSTITUTE_UNDERSCORES, use_underscore),
     PARSE_FUN(RC_SUFFIX,               suffix_fun),
     PARSE_FUN(RC_SUFFIX_ORDER,         suffix_order_fun),
     PARSE_FUN(RC_SYSTEM_EDITOR,        system_editor_fun),
     PARSE_STR(RC_SYSTEM_MAIL,          system_mail),
     PARSE_STR(RC_SYSTEM_MAIL_FLAGS,    system_mail_flags),
     PARSE_FUN(RC_TAGSOUP,              get_tagsoup),
     PARSE_PRG(RC_TAR_PATH,             ppTAR),
     PARSE_PRG(RC_TELNET_PATH,          ppTELNET),
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
     PARSE_SET(RC_TEXTFIELDS_NEED_ACTIVATION, textfields_activation_option),
#endif
     PARSE_PRG(RC_TN3270_PATH,          ppTN3270),
#if defined(_WINDOWS)
     PARSE_INT(RC_TIMEOUT,              lynx_timeout),
#endif
     PARSE_PRG(RC_TOUCH_PATH,           ppTOUCH),
     PARSE_SET(RC_TRIM_INPUT_FIELDS,    LYtrimInputFields),
d1158 1
a1158 1
     PARSE_DEF(RC_TRUSTED_EXEC,         EXEC_PATH),
d1161 1
a1161 1
     PARSE_DEF(RC_TRUSTED_LYNXCGI,      CGI_PATH),
d1163 2
a1164 2
     PARSE_PRG(RC_UNCOMPRESS_PATH,      ppUNCOMPRESS),
     PARSE_PRG(RC_UNZIP_PATH,           ppUNZIP),
d1166 1
a1166 1
     PARSE_ADD(RC_UPLOADER,             uploaders),
a1167 2
     PARSE_STR(RC_URL_DOMAIN_PREFIXES,  URLDomainPrefixes),
     PARSE_STR(RC_URL_DOMAIN_SUFFIXES,  URLDomainSuffixes),
d1169 1
a1169 1
     PARSE_SET(RC_USE_FIXED_RECORDS,    UseFixedRecords),
d1171 2
a1172 2
#if defined(USE_MOUSE)
     PARSE_SET(RC_USE_MOUSE,            LYUseMouse),
d1174 6
a1179 9
     PARSE_SET(RC_USE_SELECT_POPUPS,    LYSelectPopups),
     PARSE_PRG(RC_UUDECODE_PATH,        ppUUDECODE),
     PARSE_SET(RC_VERBOSE_IMAGES,       verbose_img),
     PARSE_SET(RC_VI_KEYS_ALWAYS_ON,    vi_keys),
     PARSE_FUN(RC_VIEWER,               viewer_fun),
     PARSE_Env(RC_WAIS_PROXY,           0),
     PARSE_STR(RC_XLOADIMAGE_COMMAND,   XLoadImageCommand),
     PARSE_PRG(RC_ZCAT_PATH,            ppZCAT),
     PARSE_PRG(RC_ZIP_PATH,             ppZIP),
d1181 1
a1181 1
     PARSE_NIL
a1183 5
PRIVATE char *lynxcfginfo_url = NULL;	/* static */
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
PRIVATE char *configinfo_url = NULL;	/* static */
#endif

d1192 5
a1196 2
	ParseUnionPtr q = ParseUnionOf(tbl);

d1211 1
a1211 1
			break;
d1226 2
a1227 8
    free_all_item_lists();
#ifdef DIRED_SUPPORT
    reset_dired_menu();		/* frees and resets dired menu items - kw */
#endif
    FREE(lynxcfginfo_url);
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
    FREE(configinfo_url);
#endif
d1234 1
a1234 1
    char ch = (char) TOUPPER(*name);
d1248 1
a1248 56
/*
 * If the given value is an absolute path (by syntax), or we can read it, use
 * the value as given.  Otherwise, assume it must be in the same place we read
 * the parent configuration file from.
 *
 * Note:  only read files from the current directory if there's no parent
 * filename, otherwise it leads to user surprise.
 */
PRIVATE char *actual_filename ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
{
    char *my_filename = NULL;

    if (!LYisAbsPath(cfg_filename)
     && !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
	if (!strncmp(cfg_filename, "~/", 2)) {
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename+1);
	} else {
	    if (parent_filename != 0) {
		StrAllocCopy(my_filename, parent_filename);
		*LYPathLeaf (my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
	    }
	    if (my_filename == 0 || !LYCanReadFile(my_filename)) {
		StrAllocCopy(my_filename, dft_filename);
		*LYPathLeaf (my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
		if (!LYCanReadFile(my_filename)) {
		    StrAllocCopy(my_filename, cfg_filename);
		}
	    }
	}
    } else {
	StrAllocCopy(my_filename, cfg_filename);
    }
    return my_filename;
}

PUBLIC FILE *LYOpenCFG ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
{
    char *my_file = actual_filename(cfg_filename, parent_filename, dft_filename);
    FILE *result;

    CTRACE((tfp, "opening config file %s\n", my_file));
    result = fopen(my_file, TXT_R);
    FREE(my_file);

    return result;
}

#define NOPTS_ ( TABLESIZE(Config_Table) - 1 )
a1258 89
/*
 * For simple (boolean, string, integer, time) values, set the corresponding
 * configuration variable.
 */
PUBLIC void LYSetConfigValue ARGS2(
    char *,	name,
    char *,	value)
{
    Config_Type *tbl = lookup_config(name);
    ParseUnionPtr q = ParseUnionOf(tbl);
    char *temp;

    switch (tbl->type) {
    case CONF_BOOL:
	if (q->set_value != 0)
	    *(q->set_value) = is_true (value);
	break;

    case CONF_FUN:
	if (q->fun_value != 0)
	    (*(q->fun_value)) (value);
	break;

    case CONF_TIME:
	if (q->int_value != 0) {
	    float ival;
	    if (1 == sscanf (value, "%f", &ival)) {
		*(q->int_value) = (int) SECS2Secs(ival);
	    }
	}
	break;

    case CONF_ENUM:
	if (tbl->table != 0)
	    LYgetEnum(tbl->table, value, q->int_value);
	break;

    case CONF_INT:
	if (q->int_value != 0) {
	    int ival;
	    if (1 == sscanf (value, "%d", &ival))
		*(q->int_value) = ival;
	}
	break;

    case CONF_STR:
	if (q->str_value != 0)
	    StrAllocCopy(*(q->str_value), value);
	break;

    case CONF_ENV:
    case CONF_ENV2:

	if (tbl->type == CONF_ENV)
	    LYLowerCase(name);
	else
	    LYUpperCase(name);

	if (LYGetEnv (name) == 0) {
#ifdef VMS
	    Define_VMSLogical(name, value);
#else
	    if (q->str_value == 0)
		q->str_value = typecalloc(char *);
	    HTSprintf0 (q->str_value, "%s=%s", name, value);
	    putenv (*(q->str_value));
#endif
	}
	break;
    case CONF_ADD_ITEM:
	if (q->add_value != 0)
	    add_item_to_list (value, q->add_value, FALSE);
	break;

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)
    case CONF_ADD_TRUSTED:
	add_trusted (value, q->def_value);
	break;
#endif

    case CONF_PRG:
	if (StrAllocCopy(temp, value))
	    HTSetProgramPath(q->def_value, temp);
	break;

    default:
	break;
    }
}
d1275 1
d1278 1
a1278 1
    CTRACE((tfp, "Loading cfg file '%s'.\n", cfg_filename));
d1290 1
a1290 1
	exit(EXIT_FAILURE);
d1296 1
a1296 1
	CTRACE((tfp,"No filename following -cfg switch!\n"));
d1299 7
a1305 2
    if ((fp = LYOpenCFG(cfg_filename, parent_filename, LYNX_CFG_FILE)) == 0) {
	CTRACE((tfp, "lynx.cfg file not found as '%s'\n", cfg_filename));
a1312 7
#ifdef SH_EX
    if (show_cfg) {
	time_t t;
	time(&t);
	printf("### %s %s, at %s", LYNX_NAME, LYNX_VERSION, ctime(&t));
    }
#endif
d1317 5
a1321 1
	ParseUnionPtr q;
d1328 1
a1328 1
	if (ispunct(UCH(*name)))
a1337 1
	    CTRACE((tfp, "LYReadCFG: missing ':' %s\n", name));
d1355 1
a1355 1
	    if (isspace(UCH(*cp)))
a1358 1
	CTRACE2(TRACE_CFG, (tfp, "LYReadCFG %s:%s\n", name, value));
a1361 1
	    CTRACE((tfp, "LYReadCFG: ignored %s:%s\n", name, value));
a1363 4
#ifdef SH_EX
	if (show_cfg)
	    printf("%s:%s\n", name, value);
#endif
d1376 5
a1380 1
	q = ParseUnionOf(tbl);
d1385 4
d1390 4
a1393 2
	case CONF_TIME:
	case CONF_ENUM:
d1395 11
d1407 4
d1413 16
a1428 3
	case CONF_ADD_ITEM:
	case CONF_ADD_TRUSTED:
	    LYSetConfigValue(name, value);
d1433 1
a1433 1
	    optidx_set_t cur_set, anded_set;
d1442 3
a1444 3
	    if ( (p1 = strstr(value, sep = " for ")) != 0
#if defined(UNIX) && !defined(USE_DOS_DRIVES)
		|| (p1 = strstr(value, sep = ":")) != 0
d1452 2
a1453 5
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
		char *my_file = actual_filename(value, cfg_filename, LYNX_CFG_FILE);

		LYLocalFileToURL(&url, my_file);
		FREE(my_file);
d1507 1
a1507 1
	    /*
d1510 1
a1510 1
	     * of allowed options in <ul>.  Option names will be uppercased.
d1513 1
a1513 1
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo && resultant_set) {
d1531 1
a1531 1
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
d1540 10
d1566 1
a1566 1
    LYCloseInput (fp);
d1575 1
a1575 1
	lynx_list_item_type *cur_download;
d1594 46
a1639 1
    LYConfigCookies();
a1640 1

d1648 2
a1649 2
    HTInitProgramPaths();
    do_read_cfg(cfg_filename, parent_filename, nesting_level, fp0, NULL);
a1651 10
#ifndef NO_CONFIG_INFO
PRIVATE void extra_cfg_link ARGS3(
	FILE *,	fp,
	char *,	href,
	char *,	name)
{
    fprintf(fp, "<a href=\"%s\">%s</a>",
	    href, name);
}
#endif /* NO_CONFIG_INFO */
d1655 1
a1655 1
 *  Called from getfile() cycle:
d1659 1
a1659 1
    DocInfo *,		       newdoc)
d1661 2
a1662 1
    static char tempfile[LY_MAXPATH] = "\0";
d1675 1
a1675 1
    if (!no_lynxcfg_xinfo && (strstr(newdoc->address, "LYNXCFG://reload"))) {
d1677 1
a1677 1
	 *  Some stuff to reload read_cfg(),
d1687 12
d1700 6
a1705 2
	 *  But check whether the top history document is really
	 *  the expected LYNXCFG: page. - kw
d1707 2
a1708 27
	if (HTMainText && nhist > 0 &&
	    !strcmp(HTLoadedDocumentTitle(), LYNXCFG_TITLE) &&
	    !strcmp(HTLoadedDocumentURL(), HDOC(nhist-1).address) &&
	    LYIsUIPage(HDOC(nhist-1).address, UIP_LYNXCFG) &&
	    (!lynxcfginfo_url ||
	     strcmp(HTLoadedDocumentURL(), lynxcfginfo_url))) {
	    /*  the page was pushed, so pop-up. */
	    LYpop(newdoc);
	    WWWDoc.address = newdoc->address;
	    WWWDoc.post_data = newdoc->post_data;
	    WWWDoc.post_content_type = newdoc->post_content_type;
	    WWWDoc.bookmark = newdoc->bookmark;
	    WWWDoc.isHEAD = newdoc->isHEAD;
	    WWWDoc.safe = newdoc->safe;
	    LYforce_no_cache = FALSE;   /* ! */
	    LYoverride_no_cache = TRUE; /* ! */

	    /*
	     * Working out of getfile() cycle we reset *no_cache manually here so
	     * HTLoadAbsolute() will return "Document already in memory":  it was
	     * forced reloading obsolete file again without this (overhead).
	     *
	     * Probably *no_cache was set in a wrong position because of
	     * the internal page...
	     */
	    if (!HTLoadAbsolute(&WWWDoc))
		return(NOT_FOUND);
d1710 1
a1710 3
	    HTuncache_current_document();  /* will never use again */
	    LYUnRegisterUIPage(UIP_LYNXCFG);
	}
d1713 1
a1713 1
	FREE(lynxcfginfo_url);	/* see below */
a1716 17
    /*
     * We regenerate the file if reloading has been requested (with
     * LYK_NOCACHE key).  If we did not regenerate, there would be no
     * way to recover in a session from a situation where the file is
     * corrupted (for example truncated because the file system was full
     * when it was first created - lynx doesn't check for write errors
     * below), short of manual complete removal or perhaps forcing
     * regeneration with LYNXCFG://reload.  Similarly, there would be no
     * simple way to get a different page if user_mode has changed to
     * Advanced after the file was first generated in a non-Advanced mode
     * (the difference being in whether the page includes the link to
     * LYNXCFG://reload or not).
     * We also try to regenerate the file if lynxcfginfo_url is set,
     * indicating that tempfile is valid, but the file has disappeared anyway.
     * This can happen to a long-lived lynx process if for example some system
     * script periodically cleans up old files in the temp file space. - kw
     */
d1718 1
a1718 8
    if (LYforce_no_cache && reloading) {
	FREE(lynxcfginfo_url); /* flag to code below to regenerate - kw */
    } else if (lynxcfginfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(lynxcfginfo_url); /* flag to code below to try again - kw */
	}
    }
    if (lynxcfginfo_url == 0) {
d1720 3
a1722 1
	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
d1724 2
a1725 2

	LYLocalFileToURL(&lynxcfginfo_url, tempfile);
d1732 1
d1734 1
a1734 1
	if (!no_lynxcfg_xinfo) {
d1758 1
a1758 30
#ifndef NO_CONFIG_INFO
#if defined(HAVE_CONFIG_H) && defined(USE_COLOR_STYLE)
	    if (!no_compileopts_info && !no_lynxcfg_xinfo) {
		fprintf(fp0, "%s</pre><ul><li>", SEE_ALSO);
		extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);

		fprintf(fp0, "<li>");
		LYLocalFileToURL(&temp, lynx_lss_file);
		extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		fprintf(fp0, "</ul><pre>\n");
	    } else
#endif
	    {
		fprintf(fp0, "%s ", SEE_ALSO);
#if defined(HAVE_CONFIG_H)
		if (!no_compileopts_info) {
		    extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);
		}
#endif
#if defined(USE_COLOR_STYLE)
		if (!no_lynxcfg_xinfo) {
		    LYLocalFileToURL(&temp, lynx_lss_file);
		    extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		}
#endif
		fprintf(fp0, "\n\n");
	    }
#endif /* NO_CONFIG_INFO */

	    /** a new experimental link ... **/
d1760 1
a1760 2
		fprintf(fp0, "  <a href=\"%s//reload\">%s</a>\n",
			     STR_LYNXCFG,
a1788 1
	LYRegisterUIPage(lynxcfginfo_url, UIP_LYNXCFG);
d1791 2
a1792 2
    /* return to getfile() cycle */
    StrAllocCopy(newdoc->address, lynxcfginfo_url);
a1801 3
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
d1809 1
a1809 1
 *  from getfile() cycle.
d1812 1
a1812 1
    DocInfo *,		       newdoc)
d1814 1
a1814 1
    static char tempfile[LY_MAXPATH] = "\0";
d1818 1
d1822 1
a1822 15
    /* In general, create the page only once - compile-time data will not
     * change...  But we will regenerate the file anyway, in two situations:
     * (a) configinfo_url has been FREEd - this can happen if free_lynx_cfg()
     * was called as part of a LYNXCFG://reload action.
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did
     * not regenerate, there would be no way to recover in a session from
     * a situation where the file is corrupted (for example truncated because
     * the file system was full when it was first created - lynx doesn't
     * check for write errors below), short of manual complete removal or
     * forcing regeneration with LYNXCFG://reload.
     * (c) configinfo_url is set, indicating that tempfile is valid, but
     * the file has disappeared anyway.  This can happen to a long-lived lynx
     * process if for example some system script periodically cleans up old
     * files in the temp file space. - kw
     */
d1824 4
a1827 5
    if (LYforce_no_cache && reloading) {
	FREE(configinfo_url); /* flag to code below to regenerate - kw */
    } else if (configinfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(configinfo_url); /* flag to code below to try again - kw */
d1829 1
a1829 6
    }
    if (configinfo_url == NULL) {
	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	    return(NOT_FOUND);

	LYLocalFileToURL(&configinfo_url, tempfile);
d1834 5
a1849 1
	LYRegisterUIPage(configinfo_url, UIP_CONFIG_DEF);
d1852 2
a1853 2
    /* exit to getfile() cycle */
    StrAllocCopy(newdoc->address, configinfo_url);
a1862 3
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d399 1
a399 1
#ifdef USE_SOURCE_CACHE
a1210 25
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
PRIVATE int screen_size_fun ARGS1(
	char *,		value)
{
    char *cp;

    if ((cp = strchr(value, ',')) != 0) {
	*cp++ = '\0';       /* Terminate ID */
	scrsize_x = atoi(value);
	scrsize_y = atoi(cp);
	if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
	    scrsize_x = scrsize_y = 0;
	}
	if ((scrsize_x > 0) && (scrsize_x < 80)) {
	    scrsize_x = 80;
	}
	if ((scrsize_y > 0) && (scrsize_y < 4)) {
	    scrsize_y = 4;
	}
	CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
    }
    return 0;
}
#endif

d1257 1
a1257 1
#ifdef USE_PERSISTENT_COOKIES
d1259 1
a1259 1
#endif /* USE_PERSISTENT_COOKIES */
d1263 1
a1263 1
#ifdef USE_PERSISTENT_COOKIES
d1265 1
a1265 1
#endif /* USE_PERSISTENT_COOKIES */
d1403 1
a1403 1
#ifdef USE_PERSISTENT_COOKIES
d1405 1
a1405 1
#endif /* USE_PERSISTENT_COOKIES */
a1431 3
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
     PARSE_FUN(RC_SCREEN_SIZE,          screen_size_fun),
#endif
d1445 1
a1445 1
#ifdef USE_SOURCE_CACHE
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a1373 3
#ifdef EXP_LOCALE_CHARSET
     PARSE_SET(RC_LOCALE_CHARSET,       LYLocaleCharset),
#endif
a1374 1
     PARSE_FUN(RC_LOCALHOST_ALIAS,      localhost_alias_fun),
d1379 1
a1467 1
     PARSE_STR(RC_SHOW_KB_NAME,         LYTransferName),
a1503 1
     PARSE_SET(RC_UNDERLINE_LINKS,      LYUnderlineLinks),
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d42 2
a43 2
BOOLEAN have_read_cfg = FALSE;
BOOLEAN LYUseNoviceLineTwo = TRUE;
d48 2
a49 2
static BOOL is_true (
	char * string)
d60 2
a61 2
static char *find_colon (
	char * buffer)
d81 2
a82 2
static void free_item_list (
    lynx_list_item_type **	ptr)
d100 1
a100 1
static void free_all_item_lists (void)
d118 4
a121 4
static void add_item_to_list (
	char *			buffer,
	lynx_list_item_type ** list_ptr,
	int			special)
d206 3
a208 3
lynx_list_item_type *find_item_by_number (
	lynx_list_item_type *	list_ptr,
	char *			number)
d217 4
a220 4
int match_item_by_name (
    lynx_list_item_type *	ptr,
    char *			name,
    BOOLEAN			only_overriders)
d246 1
a246 1
static const char *Color_Strings[16] =
d271 2
a272 2
static int ColorCode (
	int	color)
d288 3
a290 3
int check_color (
	char * color,
	int	the_default)
d318 2
a319 2
const char *lookup_color (
    int	code)
d335 2
a336 2
static void exit_with_color_syntax (
	char *		error_line)
d361 2
a362 2
static void parse_color (
	char * buffer)
d446 1
a446 1
   const char *name;
d453 2
a454 2
static int assume_charset_fun (
	char *		value)
d466 2
a467 2
static int assume_local_charset_fun (
	char *		value)
d473 2
a474 2
static int assume_unrec_charset_fun (
	char *		value)
d480 2
a481 2
static int character_set_fun (
	char *		value)
d500 2
a501 2
static int outgoing_mail_charset_fun (
	char *		value)
d513 2
a514 2
static int assumed_color_fun (
	char * buffer)
d550 2
a551 2
static int color_fun (
	char *		value)
d558 2
a559 2
static int default_bookmark_file_fun (
	char *		value)
d565 2
a566 2
static int default_cache_size_fun (
	char *		value)
d573 2
a574 2
static int default_editor_fun (
	char *		value)
d580 2
a581 2
static int numbers_as_arrows_fun (
	char *		value)
d592 2
a593 2
static int dired_menu_fun (
	char *		value)
d600 2
a601 2
static int jumpfile_fun (
	char *		value)
d614 2
a615 2
static int keyboard_layout_fun (
	char *		key)
d623 2
a624 2
static int keymap_fun (
	char *		key)
d721 2
a722 2
static int localhost_alias_fun (
	char *		value)
d729 2
a730 2
static int lynxcgi_environment_fun (
	char *		value)
d737 2
a738 2
static int lynx_sig_file_fun (
	char *		value)
d754 2
a755 2
static int news_chunk_size_fun (
	char *		value)
d767 2
a768 2
static int news_max_chunk_fun (
	char *		value)
d780 2
a781 2
static int news_posting_fun (
	char *		value)
d790 2
a791 2
static int cern_rulesfile_fun (
	char *		value)
d824 2
a825 2
static int printer_fun (
	char *		value)
d831 2
a832 2
static int referer_with_query_fun (
	char *		value)
d843 2
a844 2
static int suffix_fun (
	char *		value)
d921 2
a922 2
static int suffix_order_fun (
	char *		value)
d949 2
a950 2
static int system_editor_fun (
	char *		value)
d957 2
a958 2
static int viewer_fun (
	char *		value)
d1001 2
a1002 2
static int nonrest_sigwinch_fun (
	char *		value)
d1013 3
a1015 3
static void matched_charset_choice (
	BOOL	display_charset,
	int	i)
d1032 3
a1034 3
static int parse_charset_choice (
	char *	p,
	BOOL	display_charset) /*if FALSE, then assumed doc charset*/
d1085 1
a1085 1
static int parse_display_charset_choice (char*p)
d1090 1
a1090 1
static int parse_assumed_doc_charset_choice (char*p)
d1098 3
a1100 3
static void html_src_bad_syntax (
	    char* value,
	    char* option_name)
d1110 4
a1113 4
static int parse_html_src_spec (
	    HTlexeme lexeme_code,
	    char* value,
	    char* option_name)
d1145 1
a1145 1
static int psrcspec_fun (char*s)
d1180 1
a1180 1
static int read_htmlsrc_attrname_xform ( char*str)
d1195 1
a1195 1
static int read_htmlsrc_tagname_xform ( char*str)
d1212 2
a1213 2
static int screen_size_fun (
	char *		value)
d1237 1
a1237 1
static Config_Type Config_Table [] =
d1534 1
a1534 1
static char *lynxcfginfo_url = NULL;	/* static */
d1536 1
a1536 1
static char *configinfo_url = NULL;	/* static */
d1542 1
a1542 1
void free_lynx_cfg (void)
d1588 2
a1589 2
static Config_Type *lookup_config (
	char *		name)
d1614 4
a1617 4
static char *actual_filename (
    char *	cfg_filename,
    char *	parent_filename,
    char *	dft_filename)
d1646 4
a1649 4
FILE *LYOpenCFG (
    char *	cfg_filename,
    char *	parent_filename,
    char *	dft_filename)
d1676 3
a1678 3
void LYSetConfigValue (
    char *	name,
    char *	value)
d1769 6
a1774 6
static void do_read_cfg (
	char * cfg_filename,
	char * parent_filename,
	int	nesting_level,
	FILE *	fp0,
	optidx_set_t* allowed)
d2059 5
a2063 5
void read_cfg (
	char * cfg_filename,
	char * parent_filename,
	int	nesting_level,
	FILE *	fp0)
d2070 4
a2073 4
static void extra_cfg_link (
	FILE *	fp,
	char *	href,
	char *	name)
d2085 2
a2086 2
int lynx_cfg_infopage (
    DocInfo *		       newdoc)
d2303 2
a2304 2
int lynx_compile_opts (
    DocInfo *		       newdoc)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d6 1
a6 1
#include <HTTP.h>		/* 'reloading' flag */
d46 1
a46 1
 * Translate a TRUE/FALSE field in a string buffer.
d48 2
a49 1
static BOOL is_true(char *string)
d51 2
a52 2
    if (!strncasecomp(string, "TRUE", 4))
	return (TRUE);
d54 1
a54 1
	return (FALSE);
d58 1
a58 1
 * Find an unescaped colon in a string buffer.
d60 2
a61 1
static char *find_colon(char *buffer)
d81 2
a82 1
static void free_item_list(lynx_list_item_type **ptr)
d98 1
a98 1
 * Function for freeing the DOWNLOADER and UPLOADER menus list.  - FM
d100 1
a100 1
static void free_all_item_lists(void)
d116 1
a116 1
 * Process string buffer fields for DOWNLOADER or UPLOADER menus.
d118 4
a121 3
static void add_item_to_list(char *buffer,
			     lynx_list_item_type **list_ptr,
			     int special)
d127 1
a127 1
     * Make a linked list
d131 1
a131 1
	 * First item.
a133 1

d142 1
a142 1
	 * Find the last item.
d146 2
a147 1
	     prev_item = prev_item->next) ;	/* null body */
a148 1

d162 1
a162 1
     * Find first unescaped colon and process fields
d166 1
a166 1
	 * Process name field
d168 1
a168 2
	cur_item->name = typecallocn(char, colon - buffer + 1);

d171 1
a171 1
	LYstrncpy(cur_item->name, buffer, (int) (colon - buffer));
d175 4
a178 4
	 * Find end of command string and beginning of TRUE/FALSE option field. 
	 * If we do not find a colon that ends the command string, leave the
	 * always_enabled option flag as FALSE.  In any case, we want the
	 * command string.
d180 1
a180 1
	if ((next_colon = find_colon(colon + 1)) == NULL) {
d183 2
a184 3
	if (next_colon - (colon + 1) > 0) {
	    cur_item->command = typecallocn(char, next_colon - colon);

d187 1
a187 3
	    LYstrncpy(cur_item->command,
		      colon + 1,
		      (int) (next_colon - (colon + 1)));
d206 3
a208 2
lynx_list_item_type *find_item_by_number(lynx_list_item_type *list_ptr,
					 char *number)
a210 1

d217 4
a220 2
int match_item_by_name(lynx_list_item_type *ptr, char *name,
		       BOOLEAN only_overriders)
d224 2
a225 2
	 && !strncasecomp(ptr->name, name, strlen(ptr->name))
	 && (only_overriders ? ptr->override_primary_action : 1));
a240 1

d271 2
a272 1
static int ColorCode(int color)
d274 4
a277 9
    /* *INDENT-OFF* */
    static int map[] =
    {
	0,  4,  2,  6,  1,  5,  3,  7,
	8, 12, 10, 14,  9, 13, 11, 15
    };
    /* *INDENT-ON* */

    return map[color];
d286 1
a286 1
 * Validator for COLOR fields.
d288 3
a290 2
int check_color(char *color,
		int the_default)
d299 1
a299 1
#endif /* USE_DEFAULT_COLORS */
d318 2
a319 1
const char *lookup_color(int code)
a321 1

d333 1
a333 1
 * Exit routine for failed COLOR parsing.
d335 2
a336 1
static void exit_with_color_syntax(char *error_line)
d339 1
a339 2

    fprintf(stderr, gettext("\
d346 1
a346 1
	);
d352 1
a352 1
    fprintf(stderr, "%s\n%s\n", gettext("Offending line:"), error_line);
d359 1
a359 1
 * Process string buffer fields for COLOR setting.
d361 2
a362 1
static void parse_color(char *buffer)
d371 2
a372 2
     * We are expecting a line of the form:
     *    INTEGER:FOREGROUND:BACKGROUND
d391 2
a392 2
		       check_color(fg, default_fg),
		       check_color(bg, default_bg)) < 0)
d398 1
a398 1
/* *INDENT-OFF* */
a412 1
/* *INDENT-ON* */
d444 8
a451 6
typedef struct {
    const char *name;
    Conf_Types type;
      ParseData;
    Config_Enum *table;
} Config_Type;
d453 2
a454 1
static int assume_charset_fun(char *value)
d458 1
a458 1
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d466 2
a467 1
static int assume_local_charset_fun(char *value)
d473 2
a474 1
static int assume_unrec_charset_fun(char *value)
d480 2
a481 1
static int character_set_fun(char *value)
d483 1
a483 1
    int i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */
d488 2
a489 2
	    && (!strnicmp(value, "AutoDetect ", 11)
		|| !strnicmp(value, "AutoDetect-2 ", 13)))
d493 2
a494 1
    } else
d500 2
a501 1
static int outgoing_mail_charset_fun(char *value)
d511 1
a511 1
 * Process string buffer fields for ASSUMED_COLOR setting.
d513 2
a514 1
static int assumed_color_fun(char *buffer)
d522 2
a523 2
     * We are expecting a line of the form:
     *    FOREGROUND:BACKGROUND
d533 1
a533 1
	|| default_bg == ERR_COLOR)
d550 2
a551 1
static int color_fun(char *value)
d553 1
a553 1
    parse_color(value);
d558 2
a559 1
static int default_bookmark_file_fun(char *value)
d565 2
a566 1
static int default_cache_size_fun(char *value)
d569 1
a569 2
    if (HTCacheSize < 2)
	HTCacheSize = 2;
d573 2
a574 1
static int default_editor_fun(char *value)
d576 1
a576 2
    if (!system_editor)
	StrAllocCopy(editor, value);
d580 2
a581 1
static int numbers_as_arrows_fun(char *value)
d592 2
a593 1
static int dired_menu_fun(char *value)
d600 2
a601 1
static int jumpfile_fun(char *value)
d605 1
a605 1
    HTSprintf0(&buffer, "JUMPFILE:%s", value);
d614 2
a615 1
static int keyboard_layout_fun(char *key)
d623 2
a624 1
static int keymap_fun(char *key)
a659 1

d665 2
a666 1
				gettext("invalid line-editor selection %s for key %s, selecting all\n"),
d672 12
a683 11
		 * PASS!  tries to enter the key into the LYLineEditors
		 * bindings in a different way from PASS, namely as binding
		 * that maps to the specific lynx actioncode (rather than to
		 * LYE_FORM_PASS).  That only works for lynx keycodes with
		 * modifier bit set, and we have no documented/official way to
		 * specify this in the KEYMAP directive, although it can be
		 * made to work e.g. by specifying a hex value that has the
		 * modifier bit set.  But knowledge about the bit pattern of
		 * modifiers should remain in internal matter subject to
		 * change...  At any rate, if PASS!  fails try it the same way
		 * as for PASS.  - kw
d687 1
a687 1
			lec = LYE_FORM_LAC | lacname_to_lac(func);
d692 2
a693 1
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
d705 2
a706 1
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
d710 2
a711 1
				gettext("setting of line-editor binding for key %s (0x%x) for %s failed\n"),
d721 2
a722 1
static int localhost_alias_fun(char *value)
d729 2
a730 1
static int lynxcgi_environment_fun(char *value)
d737 2
a738 1
static int lynx_sig_file_fun(char *value)
d741 1
a741 2

    LYstrncpy(temp, value, sizeof(temp) - 1);
d754 2
a755 1
static int news_chunk_size_fun(char *value)
d767 2
a768 1
static int news_max_chunk_fun(char *value)
d780 2
a781 1
static int news_posting_fun(char *value)
d790 2
a791 1
static int cern_rulesfile_fun(char *value)
a794 1

d803 3
a805 2
	StrAllocCat(rulesfile2, value + 1);
    } else {
d815 3
a817 1
	    gettext("Lynx: cannot start, CERN rules file %s is not available\n"),
d824 2
a825 1
static int printer_fun(char *value)
d831 2
a832 1
static int referer_with_query_fun(char *value)
d843 2
a844 1
static int suffix_fun(char *value)
d850 2
a851 2
    if ((strlen(value) < 3)
	|| (NULL == (mime_type = strchr(value, ':')))) {
d881 6
a886 5
     * mime-type is not converted to lowercase on input, to make it possible to
     * reproduce the equivalent of some of the HTInit.c defaults that use mixed
     * case, although that is not recomended.  - kw
     */
    if (!*mime_type) {		/* that's ok now, with an encoding!  */
d888 2
a889 2
		encoding ? encoding : "what?"));
	mime_type = NULL;	/* that's ok now, with an encoding!  */
a907 1

d910 1
a910 1
		    sq, value));
d921 2
a922 1
static int suffix_order_fun(char *value)
d949 2
a950 1
static int system_editor_fun(char *value)
d957 2
a958 4
#define SetViewer(mime_type, viewer) \
    HTSetPresentation(mime_type, viewer, 0, 1.0, 3.0, 0.0, 0, mediaCFG)

static int viewer_fun(char *value)
d966 2
a967 2
    if ((strlen(value) < 3)
	|| (NULL == (viewer = strchr(mime_type, ':'))))
d977 1
a977 1
	(strlen(viewer) > 1) && *(environment - 1) != '\\') {
d984 1
a984 1
	if (!strcasecomp(environment, "XWINDOWS")) {
d986 2
a987 2
		SetViewer(mime_type, viewer);
	} else if (!strcasecomp(environment, "NON_XWINDOWS")) {
d989 1
a989 1
		SetViewer(mime_type, viewer);
d991 1
a991 1
	    SetViewer(mime_type, viewer);
d995 1
a995 1
	SetViewer(mime_type, viewer);
d1001 2
a1002 1
static int nonrest_sigwinch_fun(char *value)
d1013 3
a1015 2
static void matched_charset_choice(BOOL display_charset,
				   int i)
d1032 3
a1034 2
static int parse_charset_choice(char *p,
				BOOL display_charset)	/*if FALSE, then assumed doc charset */
d1039 1
a1039 1
    /*only one charset choice is allowed per line! */
d1043 1
a1043 1
	    (display_charset ? "display charset" : "assumed doc charset"), p));
d1046 1
a1046 1
	CTRACE((tfp, " - EMPTY STRING\n"));
d1051 1
a1051 1
	    for (custom_display_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
d1056 1
a1056 1
	CTRACE((tfp, " - all unhidden\n"));
d1059 1
a1059 1
    if (p[len - 1] == '*') {
d1061 1
a1061 1
	for (i = 0; i < LYNumCharsets; ++i) {
d1063 1
a1063 1
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len))) {
d1068 1
a1068 1
	CTRACE((tfp, " - %d matches\n", matches));
d1072 2
a1073 2
	    if ((!strcasecomp(p, LYchar_set_names[i])) ||
		(!strcasecomp(p, LYCharSet_UC[i].MIMEname))) {
d1075 1
a1075 1
		CTRACE((tfp, " - OK\n"));
d1080 1
a1080 1
	CTRACE((tfp, " - NOT recognised\n"));
d1085 1
a1085 1
static int parse_display_charset_choice(char *p)
d1087 1
a1087 1
    return parse_charset_choice(p, 1);
d1090 1
a1090 1
static int parse_assumed_doc_charset_choice(char *p)
d1092 1
a1092 1
    return parse_charset_choice(p, 0);
d1098 3
a1100 2
static void html_src_bad_syntax(char *value,
				char *option_name)
d1104 1
a1104 1
    HTSprintf0(&buf, "HTMLSRC_%s", option_name);
d1106 1
a1106 1
    fprintf(stderr, "Bad syntax in TAGSPEC %s:%s\n", buf, value);
d1110 12
a1121 12
static int parse_html_src_spec(HTlexeme lexeme_code, char *value,
			       char *option_name)
{
    /* Now checking the value for being correct.  Since HTML_dtd is not
     * initialized completely (member tags points to non-initiailized data), we
     * use tags_old.  If the syntax is incorrect, then lynx will exit with error
     * message.
     */
    char *ts2;

    if (isEmpty(value))
	return 0;		/* silently ignoring */
d1125 1
a1125 1
    ts2 = strchr(value, ':');
d1130 1
a1130 2
    CTRACE((tfp, "ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",
	    value, ts2, option_name));
d1132 3
a1134 2
    if (html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE)) {
d1140 1
a1140 1
    StrAllocCopy(HTL_tagspecs[lexeme_code], value);
d1145 1
a1145 1
static int psrcspec_fun(char *s)
d1147 1
a1147 2
    char *e;
    /* *INDENT-OFF* */
a1163 2
    /* *INDENT-ON* */

d1168 1
a1168 3
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",
		s));
d1173 1
a1173 3
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",
		s, e + 1));
d1176 1
a1176 1
    parse_html_src_spec(found, e + 1, s);
d1180 1
a1180 1
static int read_htmlsrc_attrname_xform(char *str)
d1183 3
a1185 6

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
d1189 2
a1190 2
	CTRACE((tfp, "bad value for htmlsrc_attrname_xform (ignored): %s\n",
		str));
d1195 1
a1195 1
static int read_htmlsrc_tagname_xform(char *str)
d1198 3
a1200 6

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
d1204 2
a1205 2
	CTRACE((tfp, "bad value for htmlsrc_tagname_xform (ignored): %s\n",
		str));
d1212 2
a1213 1
static int screen_size_fun(char *value)
d1218 1
a1218 1
	*cp++ = '\0';		/* Terminate ID */
a1236 1
/* *INDENT-OFF* */
a1436 1
     PARSE_ENU(RC_PREFERRED_ENCODING,   LYAcceptEncoding, tbl_preferred_encoding),
a1437 1
     PARSE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia, tbl_preferred_media),
a1532 1
/* *INDENT-ON* */
a1534 1

d1542 1
a1542 1
void free_lynx_cfg(void)
a1553 1

d1588 2
a1589 1
static Config_Type *lookup_config(char *name)
d1598 1
a1598 1
	    && (0 == strcasecomp(name, tbl->name)))
d1614 4
a1617 3
static char *actual_filename(char *cfg_filename,
			     char *parent_filename,
			     char *dft_filename)
d1622 1
a1622 1
	&& !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
d1624 1
a1624 1
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename + 1);
d1628 1
a1628 1
		*LYPathLeaf(my_filename) = '\0';
d1633 1
a1633 1
		*LYPathLeaf(my_filename) = '\0';
d1646 4
a1649 3
FILE *LYOpenCFG(char *cfg_filename,
		char *parent_filename,
		char *dft_filename)
d1662 2
a1663 3
typedef BOOL (optidx_set_t)[NOPTS_];

 /* if element is FALSE, then it's allowed in the current file */
d1676 3
a1678 2
void LYSetConfigValue(char *name,
		      char *value)
d1687 1
a1687 1
	    *(q->set_value) = is_true(value);
d1698 1
a1698 2

	    if (1 == sscanf(value, "%f", &ival)) {
d1712 1
a1712 2

	    if (1 == sscanf(value, "%d", &ival))
d1730 1
a1730 1
	if (LYGetEnv(name) == 0) {
d1736 2
a1737 3

	    HTSprintf0(q->str_value, "%s=%s", name, value);
	    putenv(*(q->str_value));
d1743 1
a1743 1
	    add_item_to_list(value, q->add_value, FALSE);
d1748 1
a1748 1
	add_trusted(value, q->def_value);
d1769 6
a1774 5
static void do_read_cfg(char *cfg_filename,
			char *parent_filename,
			int nesting_level,
			FILE *fp0,
			optidx_set_t * allowed)
d1782 2
a1783 2
     * Don't get hung up by an include file loop.  Arbitrary max depth
     * of 10.  - BL
d1789 2
a1790 2
	fprintf(stderr, gettext("Last attempted include was '%s',\n"), cfg_filename);
	fprintf(stderr, gettext("included from '%s'.\n"), parent_filename);
d1794 1
a1794 1
     * Locate and open the file.
d1797 1
a1797 1
	CTRACE((tfp, "No filename following -cfg switch!\n"));
d1807 1
a1807 1
     * Process each line in the file.
a1811 1

d1832 1
a1832 2
	if (*name == 0)
	    continue;
d1835 1
a1835 1
	if ((value = strchr(name, ':')) == 0) {
d1845 1
a1845 1
	 * Trim off any trailing comments.
d1847 3
a1849 3
	 * (Apparently, the original code considers a trailing comment valid
	 * only if preceded by a space character but is not followed by a
	 * colon.  -- JED)
d1851 1
a1851 1
	if ((cp = strrchr(value, ':')) == 0)
d1853 1
a1853 1
	if ((cp = strchr(cp, '#')) != 0) {
d1871 1
a1871 1
	if (allowed && (*allowed)[tbl - Config_Table]) {
d1873 2
a1874 2
		fprintf(stderr, "%s is not allowed in the %s\n",
			name, cfg_filename);
d1876 2
a1877 2
	       the html representation of lynx.cfg - say include this line
	       in bold, or something... */
d1899 10
a1908 10
	case CONF_INCLUDE:{
		/* include another file */
		optidx_set_t cur_set, anded_set;
		optidx_set_t *resultant_set = NULL;
		char *p1, *p2, savechar;
		BOOL any_optname_found = FALSE;

		char *url = NULL;
		char *cp1 = NULL;
		char *sep = NULL;
d1910 1
a1910 1
		if ((p1 = strstr(value, sep = " for ")) != 0
d1912 1
a1912 1
		    || (p1 = strstr(value, sep = ":")) != 0
d1914 5
a1918 4
		    ) {
		    *p1 = '\0';
		    p1 += strlen(sep);
		}
d1920 2
a1921 2
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    char *my_file = actual_filename(value, cfg_filename, LYNX_CFG_FILE);
d1923 6
a1928 6
		    LYLocalFileToURL(&url, my_file);
		    FREE(my_file);
		    StrAllocCopy(cp1, value);
		    if (strchr(value, '&') || strchr(value, '<')) {
			LYEntify(&cp1, TRUE);
		    }
d1930 3
a1932 3
		    fprintf(fp0, "%s:<a href=\"%s\">%s</a>\n\n", name, url, cp1);
		    fprintf(fp0, "    #&lt;begin  %s&gt;\n", cp1);
		}
d1935 19
a1953 23
		if (p1) {
		    while (*(p1 = LYSkipBlanks(p1)) != 0) {
			Config_Type *tbl2;

			p2 = LYSkipNonBlanks(p1);
			savechar = *p2;
			*p2 = 0;

			tbl2 = lookup_config(p1);
			if (tbl2->name == 0) {
			    if (fp0 == NULL)
				fprintf(stderr,
					"unknown option name %s in %s\n",
					p1, cfg_filename);
			} else {
			    unsigned i;

			    if (!any_optname_found) {
				any_optname_found = TRUE;
				for (i = 0; i < NOPTS_; ++i)
				    cur_set[i] = TRUE;
			    }
			    cur_set[tbl2 - Config_Table] = FALSE;
d1955 1
a1955 4
			if (savechar && p2[1])
			    p1 = p2 + 1;
			else
			    break;
d1957 4
d1962 12
a1973 12
		if (!allowed) {
		    if (!any_optname_found)
			resultant_set = NULL;
		    else
			resultant_set = &cur_set;
		} else {
		    if (!any_optname_found)
			resultant_set = allowed;
		    else {
			optidx_set_AND(anded_set, *allowed, cur_set);
			resultant_set = &anded_set;
		    }
d1975 1
d1978 17
a1994 19
		/*
		 * Now list the opts that are allowed in included file.  If all
		 * opts are allowed, then emit nothing, else emit an effective set
		 * of allowed options in <ul>.  Option names will be uppercased.
		 * FIXME:  uppercasing option names can be considered redundant.
		 */
		if (fp0 != 0 && !no_lynxcfg_xinfo && resultant_set) {
		    char *buf = NULL;
		    unsigned i;

		    fprintf(fp0, "     Options allowed in this file:\n");
		    for (i = 0; i < NOPTS_; ++i) {
			if ((*resultant_set)[i])
			    continue;
			StrAllocCopy(buf, Config_Table[i].name);
			LYUpperCase(buf);
			fprintf(fp0, "         * %s\n", buf);
		    }
		    FREE(buf);
d1996 2
d1999 1
a1999 1
		do_read_cfg(value, cfg_filename, nesting_level + 1, fp0, resultant_set);
d2002 5
a2006 5
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    fprintf(fp0, "    #&lt;end of %s&gt;\n\n", cp1);
		    FREE(url);
		    FREE(cp1);
		}
a2014 1

d2027 1
a2027 1
    LYCloseInput(fp);
d2030 4
a2033 4
     * If any DOWNLOADER:  commands have always_enabled set (:TRUE), make
     * override_no_download TRUE, so that other restriction settings will not
     * block presentation of a download menu with those always_enabled options
     * still available.  - FM
d2059 5
a2063 4
void read_cfg(char *cfg_filename,
	      char *parent_filename,
	      int nesting_level,
	      FILE *fp0)
d2070 4
a2073 2
static void extra_cfg_link(FILE *fp, char *href,
			   char *name)
d2081 3
a2083 3
 * Show rendered lynx.cfg data without comments, LYNXCFG:/ internal page. 
 * Called from getfile() cycle:  we create and load the page just in place and
 * return to mainloop().
d2085 2
a2086 1
int lynx_cfg_infopage(DocInfo *newdoc)
d2089 1
a2089 1
    DocAddress WWWDoc;		/* need on exit */
d2094 1
d2103 3
a2105 3
	 * Some stuff to reload read_cfg(), but also load options menu items
	 * and command-line options to make things consistent.  Implemented in
	 * LYMain.c
d2110 2
a2111 2
	 * now pop-up and return to updated LYNXCFG:/ page, remind
	 * postoptions() but much simpler:
d2114 2
a2115 2
	 * But check whether the top history document is really the expected
	 * LYNXCFG:  page.  - kw
d2119 2
a2120 2
	    !strcmp(HTLoadedDocumentURL(), HDOC(nhist - 1).address) &&
	    LYIsUIPage(HDOC(nhist - 1).address, UIP_LYNXCFG) &&
d2131 2
a2132 2
	    LYforce_no_cache = FALSE;	/* ! */
	    LYoverride_no_cache = TRUE;		/* ! */
d2135 3
a2137 4
	     * Working out of getfile() cycle we reset *no_cache manually here
	     * so HTLoadAbsolute() will return "Document already in memory": 
	     * it was forced reloading obsolete file again without this
	     * (overhead).
d2139 2
a2140 2
	     * Probably *no_cache was set in a wrong position because of the
	     * internal page...
d2143 1
a2143 1
		return (NOT_FOUND);
d2145 1
a2145 1
	    HTuncache_current_document();	/* will never use again */
d2155 15
a2169 15
     * We regenerate the file if reloading has been requested (with LYK_NOCACHE
     * key).  If we did not regenerate, there would be no way to recover in a
     * session from a situation where the file is corrupted (for example
     * truncated because the file system was full when it was first created -
     * lynx doesn't check for write errors below), short of manual complete
     * removal or perhaps forcing regeneration with LYNXCFG://reload. 
     * Similarly, there would be no simple way to get a different page if
     * user_mode has changed to Advanced after the file was first generated in
     * a non-Advanced mode (the difference being in whether the page includes
     * the link to LYNXCFG://reload or not).
     *
     * We also try to regenerate the file if lynxcfginfo_url is set, indicating
     * that tempfile is valid, but the file has disappeared anyway.  This can
     * happen to a long-lived lynx process if for example some system script
     * periodically cleans up old files in the temp file space.  - kw
d2173 1
a2173 1
	FREE(lynxcfginfo_url);	/* flag to code below to regenerate - kw */
d2175 2
a2176 2
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(lynxcfginfo_url);	/* flag to code below to try again - kw */
d2182 1
a2182 1
	    return (NOT_FOUND);
d2186 1
a2186 1
	LYforce_no_cache = TRUE;	/* don't cache this doc */
d2188 1
a2188 1
	BeginInternalPage(fp0, LYNXCFG_TITLE, NULL);
d2196 2
a2197 2
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
d2200 1
a2200 1
			temp);
d2203 1
a2203 1
			gettext("for more comments."));
d2207 1
a2207 1
		/* no absolute path... for lynx.cfg on DOS/Win32 */
d2209 2
a2210 2
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
d2213 1
a2213 1
			gettext("for more comments."));
d2248 3
a2250 2
			STR_LYNXCFG,
			gettext("RELOAD THE CHANGES"));
d2258 3
a2260 3
		    gettext("Your primary configuration"),
		    temp,
		    cp1);
d2267 1
a2267 2
	    fprintf(fp0, "<em>%s</em>\n\n",
		    gettext("The following is read from your lynx.cfg file."));
d2270 1
a2270 1
	 * Process the configuration file.
d2290 1
a2290 1
	return (NOT_FOUND);
d2294 1
a2294 1
    return (NORMAL);
d2297 1
d2300 2
a2301 2
 * Compile-time definitions info, LYNXCOMPILEOPTS:/ internal page, from
 * getfile() cycle.
d2303 2
a2304 1
int lynx_compile_opts(DocInfo *newdoc)
a2306 1

d2310 1
a2310 1
    DocAddress WWWDoc;		/* need on exit */
d2314 1
a2314 2
     * change...  But we will regenerate the file anyway, in a few situations:
     *
d2317 8
a2324 10
     *
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did not
     * regenerate, there would be no way to recover in a session from a
     * situation where the file is corrupted (for example truncated because the
     * file system was full when it was first created - lynx doesn't check for
     * write errors below), short of manual complete removal or forcing
     * regeneration with LYNXCFG://reload.
     *
     * (c) configinfo_url is set, indicating that tempfile is valid, but the
     * file has disappeared anyway.  This can happen to a long-lived lynx
d2326 1
a2326 1
     * files in the temp file space.  - kw
d2330 1
a2330 1
	FREE(configinfo_url);	/* flag to code below to regenerate - kw */
d2332 2
a2333 2
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(configinfo_url);	/* flag to code below to try again - kw */
d2338 1
a2338 1
	    return (NOT_FOUND);
d2342 1
a2342 1
	BeginInternalPage(fp0, CONFIG_DEF_TITLE, NULL);
d2369 1
a2369 1
	return (NOT_FOUND);
d2373 1
a2373 1
    return (NORMAL);
@


1.1.3.6
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d793 1
a793 1
	    non_empty(rulesfile2) ? rulesfile2 : gettext("(no name)"));
a1333 1
     PARSE_PRG(RC_INFLATE_PATH,         ppINFLATE),
d1665 1
a1665 1
    char *temp = 0;
a1880 1
	case CONF_PRG:
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a5 1
#include <HTTP.h>  /* 'reloading' flag */
a6 1
#include <HTInit.h>
a26 1
#include <LYrcFile.h>
d46 1
a46 1
PRIVATE BOOL is_true ARGS1(
d79 4
a82 2
PRIVATE void free_item_list ARGS1(
    lynx_list_item_type **,	ptr)
d84 2
a85 2
    lynx_list_item_type *cur = *ptr;
    lynx_list_item_type *next;
d87 1
d95 1
a95 2
    *ptr = NULL;
}
a96 7
/*
 *  Function for freeing the DOWNLOADER and UPLOADER menus list. - FM
 */
PRIVATE void free_all_item_lists NOARGS
{
    free_item_list(&printers);
    free_item_list(&downloaders);
d98 9
a106 1
    free_item_list(&uploaders);
d110 9
a118 1
    free_item_list(&externals);
d127 1
a127 1
PRIVATE void add_item_to_list ARGS3(
d129 1
a129 2
	lynx_list_item_type **, list_ptr,
	int,			special)
d132 1
a132 1
    lynx_list_item_type *cur_item, *prev_item;
d141 1
a141 1
	cur_item = typecalloc(lynx_list_item_type);
d146 1
a146 1
	atexit(free_all_item_lists);
d156 1
a156 1
	cur_item = typecalloc(lynx_list_item_type);
a165 2
    cur_item->override_primary_action = FALSE;
    cur_item->pagelen = 66;
d174 1
a174 1
	cur_item->name = typecallocn(char, colon-buffer+1);
d181 2
a182 4
	 *  Find end of command string and beginning of TRUE/FALSE option
	 *  field.  If we do not find a colon that ends the command string,
	 *  leave the always_enabled option flag as FALSE.  In any case,
	 *  we want the command string.
d188 1
a188 1
	    cur_item->command = typecallocn(char,next_colon-colon);
d193 1
d196 1
a196 11
	    colon = next_colon;
	    if ((next_colon = strchr(colon,':')) != 0)
		*next_colon++ = '\0';
	    cur_item->always_enabled = is_true(colon);
	    if (next_colon) {
		if (special) {
		    cur_item->pagelen = atoi(next_colon);
		} else {
		    cur_item->override_primary_action = is_true(next_colon);
		}
	    }
d201 101
a301 20
PUBLIC lynx_list_item_type *find_item_by_number ARGS2(
	lynx_list_item_type *,	list_ptr,
	char *,			number)
{
    int value = atoi(number);
    while (value-- >= 0 && list_ptr != 0) {
	list_ptr = list_ptr->next;
    }
    return list_ptr;
}

PUBLIC int match_item_by_name ARGS3(
    lynx_list_item_type *,	ptr,
    char *,			name,
    BOOLEAN,			only_overriders)
{
    return
	(ptr->command != 0
	&& !strncasecomp(ptr->name, name, strlen(ptr->name))
	&& (only_overriders ? ptr->override_primary_action : 1));
d306 1
a306 1
#ifndef COLOR_WHITE
a307 3
#endif

#ifndef COLOR_BLACK
a310 4
#if USE_DEFAULT_COLORS
int default_fg = DEFAULT_COLOR;
int default_bg = DEFAULT_COLOR;
#else
a312 1
#endif
d314 1
a314 1
PRIVATE CONST char *Color_Strings[16] =
d334 1
a334 1
#if defined(PDCURSES) && !defined(XCURSES)
a350 2
BOOL default_color_reset = FALSE;

d360 1
a360 7
    CTRACE2(TRACE_STYLE, (tfp, "check_color(%s,%d)\n", color, the_default));
    if (!strcasecomp(color, "default")) {
#if USE_DEFAULT_COLORS
	if (!default_color_reset)
	    the_default = DEFAULT_COLOR;
#endif	/* USE_DEFAULT_COLORS */
	CTRACE2(TRACE_STYLE, (tfp, "=> default %d\n", the_default));
a361 1
    }
d366 2
a367 6
	if (!strcasecomp(color, Color_Strings[i])) {
	    int c = ColorCode(i);

	    CTRACE2(TRACE_STYLE, (tfp, "=> %d\n", c));
	    return c;
	}
a368 1
    CTRACE2(TRACE_STYLE, (tfp, "=> ERR_COLOR\n"));
a370 11

PUBLIC CONST char *lookup_color ARGS1(
    int,	code)
{
    unsigned n;
    for (n = 0; n < 16; n++) {
	if ((int) ColorCode(n) == code)
	    return Color_Strings[n];
    }
    return "default";
}
d396 1
a396 1
    exit_immediately(EXIT_FAILURE);
d425 2
a426 2
    if ((check_color(fg, default_fg) == ERR_COLOR) ||
	(check_color(bg, default_bg) == ERR_COLOR))
d440 1
a440 7
#ifdef SOURCE_CACHE
static Config_Enum tbl_source_cache[] = {
    { "FILE",	SOURCE_CACHE_FILE },
    { "MEMORY",	SOURCE_CACHE_MEMORY },
    { "NONE",	SOURCE_CACHE_NONE },
    { NULL,		-1 },
};
d442 33
a474 5
static Config_Enum tbl_abort_source_cache[] = {
    { "KEEP",	SOURCE_CACHE_FOR_ABORTED_KEEP },
    { "DROP",	SOURCE_CACHE_FOR_ABORTED_DROP },
    { NULL,		-1 },
};
a476 28
#define PARSE_ADD(n,v)   {n, CONF_ADD_ITEM,    UNION_ADD(v), 0}
#define PARSE_SET(n,v)   {n, CONF_BOOL,        UNION_SET(v), 0}
#define PARSE_ENU(n,v,t) {n, CONF_ENUM,        UNION_INT(v), t}
#define PARSE_INT(n,v)   {n, CONF_INT,         UNION_INT(v), 0}
#define PARSE_TIM(n,v)   {n, CONF_TIME,        UNION_INT(v), 0}
#define PARSE_STR(n,v)   {n, CONF_STR,         UNION_STR(v), 0}
#define PARSE_Env(n,v)   {n, CONF_ENV,         UNION_ENV(v), 0}
#define PARSE_ENV(n,v)   {n, CONF_ENV2,        UNION_ENV(v), 0}
#define PARSE_FUN(n,v)   {n, CONF_FUN,         UNION_FUN(v), 0}
#define PARSE_REQ(n,v)   {n, CONF_INCLUDE,     UNION_FUN(v), 0}
#define PARSE_DEF(n,v)   {n, CONF_ADD_TRUSTED, UNION_DEF(v), 0}
#define PARSE_NIL        {NULL,0,              UNION_DEF(0), 0}

typedef enum {
    CONF_UNSPECIFIED = 0
    ,CONF_BOOL			/* BOOLEAN type */
    ,CONF_FUN
    ,CONF_TIME
    ,CONF_ENUM
    ,CONF_INT
    ,CONF_STR
    ,CONF_ENV			/* from environment variable */
    ,CONF_ENV2			/* from environment VARIABLE */
    ,CONF_INCLUDE		/* include file-- handle special */
    ,CONF_ADD_ITEM
    ,CONF_ADD_TRUSTED
} Conf_Types;

d480 12
a491 1
   Conf_Types type;
a492 1
   Config_Enum *table;
d496 1
a496 26
PRIVATE BOOLEAN LYgetEnum ARGS3(
    Config_Enum *,	table,
    CONST char *,	name,
    int *,		result)
{
    Config_Enum *found = 0;
    unsigned len = strlen(name);

    if (len != 0) {
	while (table->name != 0) {
	    if (!strncasecomp(table->name, name, len)) {
		if (found != 0)
		    return FALSE; /* ambiguous, don't use this */
		found = table;
	    }
	    table++;
	}
	if (found != 0) {
	    *result = found->value;
	    return TRUE;
	}
    }
    return FALSE;		/* no match */
}

PRIVATE int assume_charset_fun ARGS1(
d509 1
a509 1
PRIVATE int assume_local_charset_fun ARGS1(
d516 1
a516 1
PRIVATE int assume_unrec_charset_fun ARGS1(
d523 1
a523 1
PRIVATE int character_set_fun ARGS1(
d527 2
a528 10

    if (i < 0) {
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
	if (auto_display_charset >= 0
	    && (!strnicmp(value,"AutoDetect ",11)
		|| !strnicmp(value,"AutoDetect-2 ",13)))
	    current_char_set = auto_display_charset;
#endif
	/* do nothing here: so fallback to userdefs.h */
    }
d535 1
a535 1
PRIVATE int outgoing_mail_charset_fun ARGS1(
a543 39
#ifdef EXP_ASSUMED_COLOR
/*
 *  Process string buffer fields for ASSUMED_COLOR setting.
 */
PRIVATE int assumed_color_fun ARGS1(
	char *, buffer)
{
    char *fg = buffer, *bg;
    char *temp = 0;

    StrAllocCopy(temp, buffer);	/* save a copy, for error messages */

    /*
     *	We are expecting a line of the form:
     *	  FOREGROUND:BACKGROUND
     */
    if (NULL == (bg = find_colon(fg)))
	exit_with_color_syntax(temp);
    *bg++ = '\0';

    default_fg = check_color(fg, default_fg);
    default_bg = check_color(bg, default_bg);

    if (default_fg == ERR_COLOR
     || default_bg == ERR_COLOR)
	exit_with_color_syntax(temp);
#if USE_SLANG
    /*
     * Sorry - the order of initialization of slang precludes setting the
     * default colors from the lynx.cfg file, since slang is already
     * initialized before the file is read, and there is no interface defined
     * for setting it from the application (that's one of the problems with
     * using environment variables rather than a programmable interface) -TD
     */
#endif
    FREE(temp);
    return 0;
}
#endif /* EXP_ASSUMED_COLOR */
d546 1
a546 1
PRIVATE int color_fun ARGS1(
d554 1
a554 1
PRIVATE int default_bookmark_file_fun ARGS1(
d557 4
a560 1
    set_default_bookmark_page(value);
d564 1
a564 1
PRIVATE int default_cache_size_fun ARGS1(
d572 1
a572 1
PRIVATE int default_editor_fun ARGS1(
d579 1
a579 1
PRIVATE int numbers_as_arrows_fun ARGS1(
d590 13
d604 1
a604 1
PRIVATE int dired_menu_fun ARGS1(
d612 1
a612 1
PRIVATE int jumpfile_fun ARGS1(
d619 1
a619 1
	CTRACE((tfp, "Failed to register %s\n", buffer));
d626 1
a626 1
PRIVATE int keyboard_layout_fun ARGS1(
d630 1
a630 1
	CTRACE((tfp, "Failed to set keyboard layout %s\n", key));
d635 1
a635 1
PRIVATE int keymap_fun ARGS1(
d638 1
a638 1
    char *func, *efunc;
d640 1
a640 1
    if ((func = strchr(key, ':')) != NULL) {
a641 1
	efunc = strchr(func, ':');
d643 7
a649 85
	/* Allow third field for line-editor action. - kw */
	if (efunc == func) {	/* have 3rd field, but 2nd field empty */
	    func = NULL;
	} else if (efunc && strncasecomp(efunc + 1, "DIRED", 5) == 0) {
	    if (!remap(key, strtok(func, " \t\n:#"), TRUE)) {
		fprintf(stderr,
			gettext("key remapping of %s to %s for %s failed\n"),
			key, func, efunc + 1);
	    } else if (func && !strcmp("TOGGLE_HELP", func)) {
		LYUseNoviceLineTwo = FALSE;
	    }
	    return 0;
	} else if (!remap(key, strtok(func, " \t\n:#"), FALSE)) {
	    fprintf(stderr, gettext("key remapping of %s to %s failed\n"),
		    key, func);
	} else {
	    if (func && !strcmp("TOGGLE_HELP", func))
		LYUseNoviceLineTwo = FALSE;
	}
	if (efunc) {
	    efunc++;
	    if (efunc == strtok((func ? NULL : efunc), " \t\n:#") && *efunc) {
		BOOLEAN success = FALSE;
		int lkc = lkcstring_to_lkc(key);
		int lec = -1;
		int select_edi = 0;
		char *sselect_edi = strtok(NULL, " \t\n:#");
		char **endp = &sselect_edi;
		if (sselect_edi) {
		    if (*sselect_edi)
			select_edi = strtol(sselect_edi, endp, 10);
		    if (**endp != '\0') {
			fprintf(stderr,
				gettext(
	"invalid line-editor selection %s for key %s, selecting all\n"),
				sselect_edi, key);
			select_edi = 0;
		    }
		}
		/*
		 *  PASS! tries to enter the key into the LYLineEditors
		 *  bindings in a different way from PASS, namely as
		 *  binding that maps to the specific lynx actioncode
		 *  (rather than to LYE_FORM_PASS).  That only works
		 *  for lynx keycodes with modifier bit set, and we
		 *  have no documented/official way to specify this
		 *  in the KEYMAP directive, although it can be made
		 *  to work e.g. by specifying a hex value that has the
		 *  modifier bit set.  But knowledge about the bit
		 *  pattern of modifiers should remain in internal
		 *  matter subject to change...  At any rate, if
		 *  PASS! fails try it the same way as for PASS. - kw
		 */
		if (!success && strcasecomp(efunc, "PASS!") == 0) {
		    if (func) {
			lec = LYE_FORM_LAC|lacname_to_lac(func);
			success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		    }
		    if (!success)
			fprintf(stderr,
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    else
			return 0;
		}
		if (!success) {
		    lec = lecname_to_lec(efunc);
		    success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		}
		if (!success) {
		    if (lec != -1) {
			fprintf(stderr,
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    } else {
			fprintf(stderr,
				gettext(
	   "setting of line-editor binding for key %s (0x%x) for %s failed\n"),
				key, lkc, efunc);
		    }
		}
	    }
	}
d654 1
a654 1
PRIVATE int localhost_alias_fun ARGS1(
d662 1
a662 1
PRIVATE int lynxcgi_environment_fun ARGS1(
d670 1
a670 1
PRIVATE int lynx_sig_file_fun ARGS1(
d679 1
a679 1
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
d681 1
a681 1
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
d687 1
a687 1
PRIVATE int news_chunk_size_fun ARGS1(
d700 1
a700 1
PRIVATE int news_max_chunk_fun ARGS1(
d713 1
a713 1
PRIVATE int news_posting_fun ARGS1(
d717 1
a717 1
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
d723 1
a723 1
PRIVATE int cern_rulesfile_fun ARGS1(
d752 1
a752 1
    exit_immediately(EXIT_FAILURE);
d757 1
a757 1
PRIVATE int printer_fun ARGS1(
d760 1
a760 1
    add_item_to_list(value, &printers, TRUE);
d764 2
a765 1
PRIVATE int referer_with_query_fun ARGS1(
d768 7
a774 6
    if (!strncasecomp(value, "SEND", 4))
	LYRefererWithQuery = 'S';
    else if (!strncasecomp(value, "PARTIAL", 7))
	LYRefererWithQuery = 'P';
    else
	LYRefererWithQuery = 'D';
d777 1
d779 1
a779 1
PRIVATE int suffix_fun ARGS1(
d782 1
a782 3
    char *mime_type, *p;
    char *encoding = NULL, *sq = NULL, *description = NULL;
    double q = 1.0;
d785 1
a785 2
    || (NULL == (mime_type = strchr (value, ':')))) {
	CTRACE((tfp, "Invalid SUFFIX:%s ignored.\n", value));
a786 1
    }
a788 21
    if (*mime_type) {
	if ((encoding = strchr(mime_type, ':')) != NULL) {
	    *encoding++ = '\0';
	    if ((sq = strchr(encoding, ':')) != NULL) {
		*sq++ = '\0';
		if ((description = strchr(sq, ':')) != NULL) {
		    *description++ = '\0';
		    if ((p = strchr(sq, ':')) != NULL)
			*p = '\0';
		    LYTrimTail(description);
		}
		LYRemoveBlanks(sq);
		if (!*sq)
		    sq = NULL;
	    }
	    LYRemoveBlanks(encoding);
	    LYLowerCase(encoding);
	    if (!*encoding)
		encoding = NULL;
	}
    }
d791 1
a791 37
    /*
     *  Not converted to lowercase on input, to make it possible to
     *  reproduce the equivalent of some of the HTInit.c defaults
     *  that use mixed case, although that is not recomended. - kw
     */ /*LYLowerCase(mime_type);*/

    if (!*mime_type) { /* that's ok now, with an encoding!  */
	CTRACE((tfp, "SUFFIX:%s without MIME type for %s\n", value,
	       encoding ? encoding : "what?"));
	mime_type = NULL; /* that's ok now, with an encoding!  */
	if (!encoding)
	    return 0;
    }

    if (!encoding) {
	if (strstr(mime_type, "tex") != NULL ||
	    strstr(mime_type, "postscript") != NULL ||
	    strstr(mime_type, "sh") != NULL ||
	    strstr(mime_type, "troff") != NULL ||
	    strstr(mime_type, "rtf") != NULL)
	    encoding = "8bit";
	else
	    encoding = "binary";
    }
    if (!sq) {
	q = 1.0;
    } else {
	double df = strtod(sq, &p);
	if (p == sq && df == 0.0) {
	    CTRACE((tfp, "Invalid q=%s for SUFFIX:%s, using -1.0\n",
		   sq, value));
	    q = -1.0;
	} else {
	    q = df;
	}
    }
    HTSetSuffix5(value, mime_type, encoding, description, q);
d793 8
a800 9
    return 0;
}

PRIVATE int suffix_order_fun ARGS1(
	char *,		value)
{
    char *p = value;
    char *optn;
    BOOLEAN want_file_init_now = FALSE;
a801 18
    LYUseBuiltinSuffixes = TRUE;
    while ((optn = HTNextTok(&p, ", ", "", NULL)) != NULL) {
	if (!strcasecomp(optn, "NO_BUILTIN")) {
	    LYUseBuiltinSuffixes = FALSE;
	} else if (!strcasecomp(optn, "PRECEDENCE_HERE")) {
	    want_file_init_now = TRUE;
	} else if (!strcasecomp(optn, "PRECEDENCE_OTHER")) {
	    want_file_init_now = FALSE;
	} else {
	    CTRACE((tfp, "Invalid SUFFIX_ORDER:%s\n", optn));
	    break;
	}
    }

    if (want_file_init_now && !FileInitAlreadyDone) {
	HTFileInit();
	FileInitAlreadyDone = TRUE;
    }
d805 1
a805 1
PRIVATE int system_editor_fun ARGS1(
d813 1
a813 1
PRIVATE int viewer_fun ARGS1(
a856 30
PRIVATE int nonrest_sigwinch_fun ARGS1(
	char *,		value)
{
    if (!strncasecomp(value, "XWINDOWS", 8)) {
	LYNonRestartingSIGWINCH = (BOOL) (LYgetXDisplay() != NULL);
    } else {
	LYNonRestartingSIGWINCH = is_true(value);
    }
    return 0;
}

#ifdef EXP_CHARSET_CHOICE
PRIVATE void matched_charset_choice ARGS2(
	BOOL,	display_charset,
	int,	i)
{
    int j;

    if (display_charset && !custom_display_charset) {
	for (custom_display_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_display = TRUE;
    } else if (!display_charset && !custom_assumed_doc_charset) {
	for (custom_assumed_doc_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_assumed = TRUE;
    }
    if (display_charset)
	charset_subsets[i].hide_display = FALSE;
    else
	charset_subsets[i].hide_assumed = FALSE;
}
d858 1
a858 52
PRIVATE int parse_charset_choice ARGS2(
	char *,	p,
	BOOL,	display_charset) /*if FALSE, then assumed doc charset*/
{
    int len, i;
    int matches = 0;

    /*only one charset choice is allowed per line!*/
    LYTrimHead(p);
    LYTrimTail(p);
    CTRACE((tfp, "parsing charset choice for %s:\"%s\"",
	(display_charset ? "display charset" : "assumed doc charset"), p));
    len = strlen(p);
    if (!len) {
	CTRACE((tfp," - EMPTY STRING\n"));
	return 1;
    }
    if (*p == '*' && len == 1) {
	if (display_charset)
	    for (custom_display_charset = TRUE, i = 0 ;i < LYNumCharsets; ++i)
		charset_subsets[i].hide_display = FALSE;
	else
	    for (custom_assumed_doc_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_assumed = FALSE;
	CTRACE((tfp," - all unhidden\n"));
	return 0;
    }
    if (p[len-1] == '*') {
	--len;
	for (i = 0 ;i < LYNumCharsets; ++i) {
	    if ((!strncasecomp(p, LYchar_set_names[i], len)) ||
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len)) ) {
		++matches;
		matched_charset_choice(display_charset, i);
	    }
	}
	CTRACE((tfp," - %d matches\n", matches));
	return 0;
    } else {
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strcasecomp(p,LYchar_set_names[i])) ||
		(!strcasecomp(p,LYCharSet_UC[i].MIMEname)) ) {
		matched_charset_choice(display_charset, i);
		CTRACE((tfp," - OK\n"));
		++matches;
		return 0;
	    }
	}
	CTRACE((tfp," - NOT recognised\n"));
	return 1;
    }
}
d860 1
a860 14
PRIVATE int parse_display_charset_choice ARGS1(char*,p)
{
    return parse_charset_choice(p,1);
}

PRIVATE int parse_assumed_doc_charset_choice ARGS1(char*,p)
{
    return parse_charset_choice(p,0);
}

#endif /* EXP_CHARSET_CHOICE */

#ifdef USE_PRETTYSRC
PRIVATE void html_src_bad_syntax ARGS2(
d869 1
a869 1
    exit_immediately(EXIT_FAILURE);
d872 3
a874 2
PRIVATE int parse_html_src_spec ARGS3(
	    HTlexeme, lexeme_code,
d893 2
a894 4
    CTRACE((tfp,"ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",value,ts2,option_name));
    html_src_clean_item(lexeme_code);
    if ( html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE) )
d901 2
a902 1
    StrAllocCopy(HTL_tagspecs[lexeme_code],value);
d907 17
a923 34
PRIVATE int psrcspec_fun ARGS1(char*,s)
{
    char* e;
    static Config_Enum lexemnames[] =
    {
	{ "comm",	HTL_comm	},
	{ "tag",	HTL_tag		},
	{ "attrib",	HTL_attrib	},
	{ "attrval",	HTL_attrval	},
	{ "abracket",	HTL_abracket	},
	{ "entity",	HTL_entity	},
	{ "href",	HTL_href	},
	{ "entire",	HTL_entire	},
	{ "badseq",	HTL_badseq	},
	{ "badtag",	HTL_badtag	},
	{ "badattr",	HTL_badattr	},
	{ "sgmlspecial", HTL_sgmlspecial },
	{ NULL,		-1		}
    };
    int found;

    e = strchr(s,':');
    if (!e) {
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",s));
	return 0;
    }
    *e = '\0';
    if (!LYgetEnum(lexemnames, s, &found)) {
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",s,e+1));
	return 0;
    }
    parse_html_src_spec(found, e+1, s);
    return 0;
}
d925 1
a925 1
PRIVATE int read_htmlsrc_attrname_xform ARGS1( char*,str)
d930 1
a930 1
	    CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n", val));
d934 2
a935 2
	CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored): %s\n",
		    str));
d940 1
a940 1
PRIVATE int read_htmlsrc_tagname_xform ARGS1( char*,str)
d945 1
a945 1
	    CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n", val));
d949 2
a950 2
	CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored): %s\n",
		    str));
d954 5
d961 7
a967 6
/* This table is searched ignoring case */
PRIVATE Config_Type Config_Table [] =
{ 
     PARSE_SET("accept_all_cookies",   LYAcceptAllCookies),
     PARSE_TIM("alertsecs",            AlertSecs),
     PARSE_SET("always_resubmit_posts", LYresubmit_posts),
d969 1
a969 27
     PARSE_DEF("always_trusted_exec",  ALWAYS_EXEC_PATH),
#endif
     PARSE_FUN("assume_charset",       assume_charset_fun),
     PARSE_FUN("assume_local_charset", assume_local_charset_fun),
     PARSE_FUN("assume_unrec_charset", assume_unrec_charset_fun),
#ifdef EXP_ASSUMED_COLOR
     PARSE_FUN("assumed_color",        assumed_color_fun),
#endif
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN("assumed_doc_charset_choice", parse_assumed_doc_charset_choice),
#endif
#ifdef DIRED_SUPPORT
     PARSE_INT("auto_uncache_dirlists", LYAutoUncacheDirLists),
#endif
#ifndef DISABLE_BIBP
     PARSE_STR("bibp_bibhost",         BibP_bibhost),
     PARSE_STR("bibp_globalserver",    BibP_globalserver),
#endif
     PARSE_SET("block_multi_bookmarks", LYMBMBlocked),
     PARSE_SET("bold_h1",              bold_H1),
     PARSE_SET("bold_headers",         bold_headers),
     PARSE_SET("bold_name_anchors",    bold_name_anchors),
     PARSE_SET("case_sensitive_always_on", case_sensitive),
     PARSE_FUN("character_set",        character_set_fun),
#ifdef CAN_SWITCH_DISPLAY_CHARSET
     PARSE_STR("charset_switch_rules", charset_switch_rules),
     PARSE_STR("charsets_directory",   charsets_directory),
d971 11
a981 2
     PARSE_SET("checkmail",            check_mail),
     PARSE_SET("collapse_br_tags",     LYCollapseBRs),
d983 1
a983 1
     PARSE_FUN("color",                color_fun),
d985 1
a985 10
#ifndef __DJGPP__
     PARSE_INT("connect_timeout",      connect_timeout),
#endif
     PARSE_STR("cookie_accept_domains", LYCookieSAcceptDomains),
#ifdef EXP_PERSISTENT_COOKIES
     PARSE_STR("cookie_file",          LYCookieFile),
#endif /* EXP_PERSISTENT_COOKIES */
     PARSE_STR("cookie_loose_invalid_domains", LYCookieSLooseCheckDomains),
     PARSE_STR("cookie_query_invalid_domains", LYCookieSQueryCheckDomains),
     PARSE_STR("cookie_reject_domains", LYCookieSRejectDomains),
d987 1
a987 1
     PARSE_STR("cookie_save_file",     LYCookieSaveFile),
d989 5
a993 2
     PARSE_STR("cookie_strict_invalid_domains", LYCookieSStrictCheckDomains),
     PARSE_Env("cso_proxy", 0 ),
d995 1
a995 1
     PARSE_STR("cswing_path",          LYCSwingPath),
d997 6
a1002 7
     PARSE_FUN("default_bookmark_file", default_bookmark_file_fun),
     PARSE_FUN("default_cache_size",   default_cache_size_fun),
     PARSE_FUN("default_editor",       default_editor_fun),
     PARSE_STR("default_index_file",   indexfile),
     PARSE_ENU("default_keypad_mode",  keypad_mode, tbl_keypad_mode),
     PARSE_FUN("default_keypad_mode_is_numbers_as_arrows", numbers_as_arrows_fun),
     PARSE_ENU("default_user_mode",    user_mode, tbl_user_mode),
d1004 1
a1004 1
     PARSE_INT("default_virtual_memory_size", HTVirtualMemorySize),
d1007 1
a1007 1
     PARSE_FUN("dired_menu",           dired_menu_fun),
d1009 3
a1011 7
#ifdef EXP_CHARSET_CHOICE
     PARSE_FUN("display_charset_choice", parse_display_charset_choice),
#endif
     PARSE_ADD("downloader",           downloaders),
     PARSE_SET("emacs_keys_always_on", emacs_keys),
     PARSE_FUN("enable_lynxrc",        enable_lynxrc),
     PARSE_SET("enable_scrollback",    enable_scrollback),
d1013 1
a1013 1
     PARSE_ADD("external",             externals),
d1015 3
a1017 7
     PARSE_Env("finger_proxy",         0 ),
#if defined(_WINDOWS)	/* 1998/10/05 (Mon) 17:34:15 */
     PARSE_SET("focus_window",         focus_window),
#endif
     PARSE_SET("force_8bit_toupper",   UCForce8bitTOUPPER),
     PARSE_SET("force_empty_hrefless_a", force_empty_hrefless_a),
     PARSE_SET("force_ssl_cookies_secure", LYForceSSLCookiesSecure),
d1019 1
a1019 1
     PARSE_SET("forms_options",        LYUseFormsOptions),
d1021 42
a1062 25
     PARSE_SET("ftp_passive",          ftp_passive),
     PARSE_Env("ftp_proxy",            0 ),
     PARSE_STR("global_extension_map", global_extension_map),
     PARSE_STR("global_mailcap",       global_type_map),
     PARSE_Env("gopher_proxy",         0 ),
     PARSE_SET("gotobuffer",           goto_buffer),
     PARSE_STR("helpfile",             helpfile),
#ifdef MARK_HIDDEN_LINKS
     PARSE_STR("hidden_link_marker",   hidden_link_marker),
#endif
     PARSE_SET("historical_comments",  historical_comments),
#ifdef USE_PRETTYSRC
     PARSE_FUN("htmlsrc_attrname_xform", read_htmlsrc_attrname_xform),
     PARSE_FUN("htmlsrc_tagname_xform", read_htmlsrc_tagname_xform),
#endif
     PARSE_Env("http_proxy",           0 ),
     PARSE_Env("https_proxy",          0 ),
     PARSE_REQ("include",              0),
     PARSE_TIM("infosecs",             InfoSecs),
     PARSE_STR("jump_prompt",          jumpprompt),
     PARSE_SET("jumpbuffer",           jump_buffer),
     PARSE_FUN("jumpfile",             jumpfile_fun),
#ifdef EXP_JUSTIFY_ELTS
     PARSE_SET("justify",              ok_justify),
     PARSE_INT("justify_max_void_percent", justify_max_void_percent),
d1064 4
a1067 2
#ifdef EXP_KEYBOARD_LAYOUT
     PARSE_FUN("keyboard_layout",      keyboard_layout_fun),
a1068 2
     PARSE_FUN("keymap",               keymap_fun),
     PARSE_SET("leftarrow_in_textfield_prompt", textfield_prompt_at_left_edge),
d1070 1
a1070 5
     PARSE_STR("list_format",          list_format),
#endif
#ifndef DISABLE_NEWS
     PARSE_SET("list_news_dates",      LYListNewsDates),
     PARSE_SET("list_news_numbers",    LYListNewsNumbers),
d1072 2
a1073 1
     PARSE_STR("local_domain",         LYLocalDomain),
d1075 2
a1076 2
     PARSE_SET("local_execution_links_always_on", local_exec),
     PARSE_SET("local_execution_links_on_but_not_remote", local_exec_on_local_files),
a1077 3
     PARSE_FUN("localhost_alias",      localhost_alias_fun),
     PARSE_STR("lynx_host_name",       LYHostName),
     PARSE_FUN("lynx_sig_file",        lynx_sig_file_fun),
d1079 1
d1081 1
a1081 1
     PARSE_STR("lynxcgi_document_root", LYCgiDocumentRoot),
a1082 1
     PARSE_FUN("lynxcgi_environment",  lynxcgi_environment_fun),
d1084 5
a1088 2
#if USE_VMS_MAILER
     PARSE_STR("mail_adrs",            mail_adrs),
d1090 6
a1095 7
     PARSE_SET("mail_system_error_logging", error_logging),
     PARSE_SET("make_links_for_all_images", clickable_images),
     PARSE_SET("make_pseudo_alts_for_inlines", pseudo_inline_alts),
     PARSE_TIM("messagesecs",          MessageSecs),
     PARSE_SET("minimal_comments",     minimal_comments),
     PARSE_ENU("multi_bookmark_support", LYMultiBookmarks, tbl_multi_bookmarks),
     PARSE_SET("ncr_in_bookmarks",     UCSaveBookmarksInUnicode),
d1097 8
a1104 8
     PARSE_FUN("news_chunk_size",      news_chunk_size_fun),
     PARSE_FUN("news_max_chunk",       news_max_chunk_fun),
     PARSE_FUN("news_posting",         news_posting_fun),
     PARSE_Env("news_proxy",           0),
     PARSE_Env("newspost_proxy",       0),
     PARSE_Env("newsreply_proxy",      0),
     PARSE_Env("nntp_proxy",           0),
     PARSE_ENV("nntpserver",           0), /* actually NNTPSERVER */
d1106 2
a1107 2
     PARSE_SET("no_dot_files",         no_dotfiles),
     PARSE_SET("no_file_referer",      no_filereferer),
d1109 1
a1109 8
     PARSE_SET("no_forced_core_dump",  LYNoCore),
#endif
     PARSE_SET("no_from_header",       LYNoFromHeader),
     PARSE_SET("no_ismap_if_usemap",   LYNoISMAPifUSEMAP),
     PARSE_Env("no_proxy",             0 ),
     PARSE_SET("no_referer_header",    LYNoRefererHeader),
#ifdef SH_EX
     PARSE_SET("no_table_center",      no_table_center),
d1111 5
a1115 2
     PARSE_FUN("nonrestarting_sigwinch", nonrest_sigwinch_fun),
     PARSE_FUN("outgoing_mail_charset", outgoing_mail_charset_fun),
d1117 2
a1118 2
     PARSE_SET("partial",              display_partial_flag),
     PARSE_INT("partial_thres",        partial_threshold),
d1121 1
a1121 1
     PARSE_SET("persistent_cookies",   persistent_cookies),
d1123 8
a1130 15
     PARSE_STR("personal_extension_map", personal_extension_map),
     PARSE_STR("personal_mailcap",     personal_type_map),
     PARSE_STR("preferred_charset",    pref_charset),
     PARSE_STR("preferred_language",   language),
     PARSE_SET("prepend_base_to_source", LYPrependBaseToSource),
     PARSE_SET("prepend_charset_to_source", LYPrependCharsetToSource),
#ifdef USE_PRETTYSRC
     PARSE_SET("prettysrc",            LYpsrc),
     PARSE_FUN("prettysrc_spec",       psrcspec_fun),
     PARSE_SET("prettysrc_view_no_anchor_numbering", psrcview_no_anchor_numbering),
#endif
     PARSE_FUN("printer",              printer_fun),
     PARSE_SET("quit_default_yes",     LYQuitDefaultYes),
     PARSE_FUN("referer_with_query",   referer_with_query_fun),
     PARSE_SET("reuse_tempfiles",      LYReuseTempfiles),
d1132 2
a1133 2
     PARSE_FUN("rule",                 HTSetConfiguration),
     PARSE_FUN("rulesfile",            cern_rulesfile_fun),
d1135 11
a1145 15
     PARSE_STR("save_space",           lynx_save_space),
     PARSE_SET("scan_for_buried_news_refs", scan_for_buried_news_references),
#ifdef USE_SCROLLBAR
     PARSE_SET("scrollbar",            LYsb),
     PARSE_SET("scrollbar_arrow",      LYsb_arrow),
#endif
     PARSE_SET("seek_frag_area_in_cur", LYSeekFragAREAinCur),
     PARSE_SET("seek_frag_map_in_cur", LYSeekFragMAPinCur),
     PARSE_SET("set_cookies",          LYSetCookies),
     PARSE_SET("show_cursor",          LYShowCursor),
     PARSE_ENU("show_kb_rate",         LYTransferRate, tbl_transfer_rate),
     PARSE_Env("snews_proxy",          0 ),
     PARSE_Env("snewspost_proxy",      0 ),
     PARSE_Env("snewsreply_proxy",     0 ),
     PARSE_SET("soft_dquotes",         soft_dquotes),
d1147 1
a1147 2
     PARSE_ENU("source_cache",         LYCacheSource, tbl_source_cache),
     PARSE_ENU("source_cache_for_aborted", LYCacheSourceForAborted, tbl_abort_source_cache),
d1149 8
a1156 16
     PARSE_STR("startfile",            startfile),
     PARSE_SET("strip_dotdot_urls",    LYStripDotDotURLs),
     PARSE_SET("substitute_underscores", use_underscore),
     PARSE_FUN("suffix",               suffix_fun),
     PARSE_FUN("suffix_order",         suffix_order_fun),
     PARSE_FUN("system_editor",        system_editor_fun),
     PARSE_STR("system_mail",          system_mail),
     PARSE_STR("system_mail_flags",    system_mail_flags),
     PARSE_ENU("tagsoup",              Old_DTD, tbl_DTD_recovery),
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
     PARSE_SET("textfields_need_activation", textfields_activation_option),
#endif
#if defined(_WINDOWS)
     PARSE_INT("timeout",              lynx_timeout),
#endif
     PARSE_SET("trim_input_fields",  LYtrimInputFields),
d1158 1
a1158 1
     PARSE_DEF("trusted_exec",         EXEC_PATH),
d1161 1
a1161 1
     PARSE_DEF("trusted_lynxcgi",      CGI_PATH),
d1163 2
d1166 1
a1166 1
     PARSE_ADD("uploader",             uploaders),
a1167 2
     PARSE_STR("url_domain_prefixes",  URLDomainPrefixes),
     PARSE_STR("url_domain_suffixes",  URLDomainSuffixes),
d1169 1
a1169 1
     PARSE_SET("use_fixed_records",    UseFixedRecords),
d1171 2
a1172 2
#if defined(USE_MOUSE)
     PARSE_SET("use_mouse",            LYUseMouse),
d1174 6
a1179 6
     PARSE_SET("use_select_popups",    LYSelectPopups),
     PARSE_SET("verbose_images",       verbose_img),
     PARSE_SET("vi_keys_always_on",    vi_keys),
     PARSE_FUN("viewer",               viewer_fun),
     PARSE_Env("wais_proxy",           0 ),
     PARSE_STR("xloadimage_command",   XLoadImageCommand),
d1181 1
a1181 1
     PARSE_NIL
a1183 5
PRIVATE char *lynxcfginfo_url = NULL;	/* static */
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
PRIVATE char *configinfo_url = NULL;	/* static */
#endif

d1192 5
a1196 2
	ParseUnionPtr q = ParseUnionOf(tbl);

d1211 1
a1211 1
			break;
d1226 2
a1227 8
    free_all_item_lists();
#ifdef DIRED_SUPPORT
    reset_dired_menu();		/* frees and resets dired menu items - kw */
#endif
    FREE(lynxcfginfo_url);
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
    FREE(configinfo_url);
#endif
d1234 1
a1234 1
    char ch = (char) TOUPPER(*name);
d1248 1
a1248 55
/*
 * If the given value is an absolute path (by syntax), or we can read it, use
 * the value as given.  Otherwise, assume it must be in the same place we read
 * the parent configuration file from.
 *
 * Note:  only read files from the current directory if there's no parent
 * filename, otherwise it leads to user surprise.
 */
PRIVATE char *actual_filename ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
{
    static char *my_filename;

    if (my_filename != 0) {
	FREE(my_filename);
    }
    if (!LYisAbsPath(cfg_filename)
     && !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
	if (!strncmp(cfg_filename, "~/", 2)) {
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename+1);
	    cfg_filename = my_filename;
	} else {
	    if (parent_filename != 0) {
		StrAllocCopy(my_filename, parent_filename);
		*LYPathLeaf (my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
	    }
	    if (my_filename != 0 && LYCanReadFile(my_filename)) {
		cfg_filename = my_filename;
	    } else {
		StrAllocCopy(my_filename, dft_filename);
		*LYPathLeaf (my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
		if (LYCanReadFile(my_filename)) {
		    cfg_filename = my_filename;
		}
	    }
	}
    }
    return cfg_filename;
}

PUBLIC FILE *LYOpenCFG ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
{
    cfg_filename = actual_filename(cfg_filename, parent_filename, dft_filename);
    CTRACE((tfp, "opening config file %s\n", cfg_filename));
    return fopen(cfg_filename, TXT_R);
}

#define NOPTS_ ( TABLESIZE(Config_Table) - 1 )
d1275 1
d1278 1
a1278 1
    CTRACE((tfp, "Loading cfg file '%s'.\n", cfg_filename));
d1290 1
a1290 1
	exit(EXIT_FAILURE);
d1296 1
a1296 1
	CTRACE((tfp,"No filename following -cfg switch!\n"));
d1299 7
a1305 2
    if ((fp = LYOpenCFG(cfg_filename, parent_filename, LYNX_CFG_FILE)) == 0) {
	CTRACE((tfp, "lynx.cfg file not found as '%s'\n", cfg_filename));
a1312 7
#ifdef SH_EX
    if (show_cfg) {
	time_t t;
	time(&t);
	printf("### %s %s, at %s", LYNX_NAME, LYNX_VERSION, ctime(&t));
    }
#endif
d1317 5
a1321 1
	ParseUnionPtr q;
d1328 1
a1328 1
	if (ispunct(UCH(*name)))
d1355 1
a1355 1
	    if (isspace(UCH(*cp)))
a1363 4
#ifdef SH_EX
	if (show_cfg)
	    printf("%s:%s\n", name, value);
#endif
d1376 5
a1380 1
	q = ParseUnionOf(tbl);
a1393 17
	case CONF_TIME:
	    if (q->int_value != 0) {
		float ival;
		if (1 == sscanf (value, "%f", &ival)) {
#ifdef HAVE_NAPMS
		    ival *= 1000;
#endif
		    *(q->int_value) = (int) ival;
		}
	    }
	    break;

	case CONF_ENUM:
	    if (tbl->table != 0)
		LYgetEnum(tbl->table, value, q->int_value);
	    break;

d1397 4
d1424 1
a1424 1
			q->str_value = typecalloc(char *);
d1433 1
a1433 1
	    optidx_set_t cur_set, anded_set;
d1452 2
a1453 2
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
		LYLocalFileToURL(&url, actual_filename(value, cfg_filename, LYNX_CFG_FILE));
d1507 1
a1507 1
	    /*
d1510 1
a1510 1
	     * of allowed options in <ul>.  Option names will be uppercased.
d1513 1
a1513 1
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo && resultant_set) {
d1531 1
a1531 1
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
d1542 1
a1542 1
		add_item_to_list (value, q->add_value, FALSE);
d1566 1
a1566 1
    LYCloseInput (fp);
d1575 1
a1575 1
	lynx_list_item_type *cur_download;
d1594 46
a1639 1
    LYConfigCookies();
a1640 1

d1648 2
a1649 1
    do_read_cfg(cfg_filename, parent_filename, nesting_level, fp0, NULL);
d1655 1
a1655 1
 *  Called from getfile() cycle:
d1661 2
a1662 1
    static char tempfile[LY_MAXPATH] = "\0";
d1675 1
a1675 1
    if (!no_lynxcfg_xinfo && (strstr(newdoc->address, "LYNXCFG://reload"))) {
d1677 1
a1677 1
	 *  Some stuff to reload read_cfg(),
d1687 12
d1700 6
a1705 2
	 *  But check whether the top history document is really
	 *  the expected LYNXCFG: page. - kw
d1707 2
a1708 27
	if (HTMainText && nhist > 0 &&
	    !strcmp(HTLoadedDocumentTitle(), LYNXCFG_TITLE) &&
	    !strcmp(HTLoadedDocumentURL(), history[nhist-1].address) &&
	    LYIsUIPage(history[nhist-1].address, UIP_LYNXCFG) &&
	    (!lynxcfginfo_url ||
	     strcmp(HTLoadedDocumentURL(), lynxcfginfo_url))) {
	    /*  the page was pushed, so pop-up. */
	    LYpop(newdoc);
	    WWWDoc.address = newdoc->address;
	    WWWDoc.post_data = newdoc->post_data;
	    WWWDoc.post_content_type = newdoc->post_content_type;
	    WWWDoc.bookmark = newdoc->bookmark;
	    WWWDoc.isHEAD = newdoc->isHEAD;
	    WWWDoc.safe = newdoc->safe;
	    LYforce_no_cache = FALSE;   /* ! */
	    LYoverride_no_cache = TRUE; /* ! */

	    /*
	     * Working out of getfile() cycle we reset *no_cache manually here so
	     * HTLoadAbsolute() will return "Document already in memory":  it was
	     * forced reloading obsolete file again without this (overhead).
	     *
	     * Probably *no_cache was set in a wrong position because of
	     * the internal page...
	     */
	    if (!HTLoadAbsolute(&WWWDoc))
		return(NOT_FOUND);
d1710 1
a1710 3
	    HTuncache_current_document();  /* will never use again */
	    LYUnRegisterUIPage(UIP_LYNXCFG);
	}
d1713 1
a1713 1
	FREE(lynxcfginfo_url);	/* see below */
a1716 17
    /*
     * We regenerate the file if reloading has been requested (with
     * LYK_NOCACHE key).  If we did not regenerate, there would be no
     * way to recover in a session from a situation where the file is
     * corrupted (for example truncated because the file system was full
     * when it was first created - lynx doesn't check for write errors
     * below), short of manual complete removal or perhaps forcing
     * regeneration with LYNXCFG://reload.  Similarly, there would be no
     * simple way to get a different page if user_mode has changed to
     * Advanced after the file was first generated in a non-Advanced mode
     * (the difference being in whether the page includes the link to
     * LYNXCFG://reload or not).
     * We also try to regenerate the file if lynxcfginfo_url is set,
     * indicating that tempfile is valid, but the file has disappeared anyway.
     * This can happen to a long-lived lynx process if for example some system
     * script periodically cleans up old files in the temp file space. - kw
     */
d1718 1
a1718 8
    if (LYforce_no_cache && reloading) {
	FREE(lynxcfginfo_url); /* flag to code below to regenerate - kw */
    } else if (lynxcfginfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(lynxcfginfo_url); /* flag to code below to try again - kw */
	}
    }
    if (lynxcfginfo_url == 0) {
d1720 2
a1721 8
	if (LYReuseTempfiles) {
	    fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
	} else {
	    if (tempfile[0])
		LYRemoveTemp(tempfile);
	    fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
	}
	if (fp0 == NULL) {
d1725 1
a1725 1
	LYLocalFileToURL(&lynxcfginfo_url, tempfile);
d1734 1
a1734 1
	if (!no_lynxcfg_xinfo) {
d1758 1
a1758 9
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	    if (!no_compileopts_info) {
		fprintf(fp0, "%s <a href=\"LYNXCOMPILEOPTS:\">%s</a>\n\n",
			SEE_ALSO,
			COMPILE_OPT_SEGMENT);
	    }
#endif

	    /** a new experimental link ... **/
a1788 1
	LYRegisterUIPage(lynxcfginfo_url, UIP_LYNXCFG);
d1791 2
a1792 2
    /* return to getfile() cycle */
    StrAllocCopy(newdoc->address, lynxcfginfo_url);
a1801 3
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
d1809 1
a1809 1
 *  from getfile() cycle.
d1814 1
a1814 1
    static char tempfile[LY_MAXPATH] = "\0";
d1818 1
d1822 1
a1822 15
    /* In general, create the page only once - compile-time data will not
     * change...  But we will regenerate the file anyway, in two situations:
     * (a) configinfo_url has been FREEd - this can happen if free_lynx_cfg()
     * was called as part of a LYNXCFG://reload action.
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did
     * not regenerate, there would be no way to recover in a session from
     * a situation where the file is corrupted (for example truncated because
     * the file system was full when it was first created - lynx doesn't
     * check for write errors below), short of manual complete removal or
     * forcing regeneration with LYNXCFG://reload.
     * (c) configinfo_url is set, indicating that tempfile is valid, but
     * the file has disappeared anyway.  This can happen to a long-lived lynx
     * process if for example some system script periodically cleans up old
     * files in the temp file space. - kw
     */
d1824 2
a1825 15
    if (LYforce_no_cache && reloading) {
	FREE(configinfo_url); /* flag to code below to regenerate - kw */
    } else if (configinfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(configinfo_url); /* flag to code below to try again - kw */
	}
    }
    if (configinfo_url == NULL) {
	if (LYReuseTempfiles) {
	    fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
	} else {
	    LYRemoveTemp(tempfile);
	    fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
	}
	if (fp0 == NULL) {
d1829 1
a1829 1
	LYLocalFileToURL(&configinfo_url, tempfile);
d1834 5
a1849 1
	LYRegisterUIPage(configinfo_url, UIP_CONFIG_DEF);
d1852 2
a1853 2
    /* exit to getfile() cycle */
    StrAllocCopy(newdoc->address, configinfo_url);
a1862 3
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
@

