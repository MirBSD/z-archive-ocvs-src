head	1.5;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.4
	tg-mergefixes-1-branch:1.4.0.4
	tg-mergefixes-1-base:1.4
	MIROS_X:1.4.0.2
	MIROS_X_BASE:1.4
	MIRBSD_XP_MIRPPC:1.1.3.4.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.1.3.4
	MIRBSD_XP_SPARC:1.1.3.4.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.01.03.00.45.55;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.28.16.36.16;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.28;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.26;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.20;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.31;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.13;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.08.13.09.34;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.49;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.51.11;	author tg;	state Stab;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.11.20.16.24;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/src/LYCgi.c,v 1.4 2004/11/28 16:36:16 tg Exp $ */

/*                   Lynx CGI support                              LYCgi.c
 *                   ================
 *
 * Authors
 *          GL      George Lindholm <George.Lindholm@@ubc.ca>
 *
 * History
 *      15 Jun 95   Created as way to provide a lynx based service with
 *                  dynamic pages without the need for a http daemon.  GL
 *      27 Jun 95   Added <index> (command line) support.  Various cleanup
 *                  and bug fixes. GL
 *	04 Sep 97   Added support for PATH_INFO scripts.  JKT
 *
 * Bugs
 *      If the called scripts aborts before sending the mime headers then
 *      lynx hangs.
 *
 *      Should do something about SIGPIPE, (but then it should never happen)
 *
 *      No support for redirection.  Or mime-types.
 *
 *      Should try and parse for a HTTP 1.1 header in case we are "calling" a
 *      nph- script.
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTParse.h>
#include <HTTCP.h>
#include <HTFormat.h>
#include <HTFile.h>
#include <HTAlert.h>
#include <HTMIME.h>
#include <HTAABrow.h>

#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <HTML.h>
#include <HTInit.h>
#include <LYGetFile.h>
#include <LYBookmark.h>
#include <GridText.h>
#include <LYCgi.h>
#include <LYStrings.h>
#include <LYLocal.h>

#include <LYLeaks.h>
#include <www_wait.h>

struct _HTStream {
    HTStreamClass *isa;
};

static char **env = NULL;	/* Environment variables */
static int envc_size = 0;	/* Slots in environment array */
static int envc = 0;		/* Slots used so far */
static HTList *alloced = NULL;

#ifdef LYNXCGI_LINKS
static char *user_agent = NULL;
static char *server_software = NULL;
static char *accept_language = NULL;
static char *post_len = NULL;
#endif /* LYNXCGI_LINKS */

static void add_environment_value(const char *env_value);

#define PERROR(msg) CTRACE((tfp, "LYNXCGI: %s: %s\n", msg, LYStrerror(errno)))

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

#ifdef LY_FIND_LEAKS
static void free_alloced_lynxcgi(void)
{
    void *ptr;

    while ((ptr = HTList_removeLastObject(alloced)) != NULL) {
	FREE(ptr);
    }
    FREE(alloced);
#ifdef LYNXCGI_LINKS
    FREE(user_agent);
    FREE(server_software);
#endif
}
#endif /* LY_FIND_LEAKS */

static void remember_alloced(void *ptr)
{
    if (!alloced) {
	alloced = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(free_alloced_lynxcgi);
#endif
    }
    HTList_addObject(alloced, ptr);
}

/*
 * Simple routine for expanding the environment array and adding a value to
 * it
 */
static void add_environment_value(const char *env_value)
{
    if (envc == envc_size) {	/* Need some more slots */
	envc_size += 10;
	if (env) {
	    env = (char **) realloc(env,
				    sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
	} else {
	    env = (char **) malloc(sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
	    remember_alloced(env);
	}
	if (env == NULL) {
	    outofmem(__FILE__, "LYCgi");
	}
    }

    env[envc++] = (char *) env_value;
    env[envc] = NULL;		/* Make sure it is always properly terminated */
}

/*
 * Add the value of an existing environment variable to those passed on to the
 * lynxcgi script.
 */
void add_lynxcgi_environment(const char *variable_name)
{
    char *env_value;

    env_value = LYGetEnv(variable_name);
    if (env_value != NULL) {
	char *add_value = NULL;

	HTSprintf0(&add_value, "%s=%s", variable_name, env_value);
	add_environment_value(add_value);
	remember_alloced(add_value);
    }
}

#ifdef __MINGW32__
static int LYLoadCGI(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
{
    return -1;
}
#else
static int LYLoadCGI(const char *arg GCC_UNUSED,
		     HTParentAnchor *anAnchor GCC_UNUSED,
		     HTFormat format_out GCC_UNUSED,
		     HTStream *sink GCC_UNUSED)
{
    int status = 0;

#ifdef LYNXCGI_LINKS
#ifndef VMS
    char *cp;
    struct stat stat_buf;
    char *pgm = NULL;		/* executable */
    char *pgm_args = NULL;	/* and its argument(s) */
    int statrv;
    char *orig_pgm = NULL;	/* Path up to ? as given, URL-escaped */
    char *document_root = NULL;	/* Corrected value of DOCUMENT_ROOT  */
    char *path_info = NULL;	/* PATH_INFO extracted from pgm      */
    char *pgm_buff = NULL;	/* PATH_INFO extraction buffer       */
    char *path_translated;	/* From document_root/path_info      */

    if (isEmpty(arg) || strlen(arg) <= 8) {
	HTAlert(BAD_REQUEST);
	status = -2;
	return (status);

    } else {
	if (strncmp(arg, "lynxcgi://localhost", 19) == 0) {
	    StrAllocCopy(pgm, arg + 19);
	} else {
	    StrAllocCopy(pgm, arg + 8);
	}
	if ((cp = strchr(pgm, '?')) != NULL) {	/* Need to terminate executable */
	    *cp++ = '\0';
	    pgm_args = cp;
	}
    }

    StrAllocCopy(orig_pgm, pgm);
    if ((cp = trimPoundSelector(pgm)) != NULL) {
	/*
	 * Strip a #fragment from path.  In this case any pgm_args found above
	 * will also be bogus, since the '?' came after the '#' and is part of
	 * the fragment.  Note that we don't handle the case where a '#'
	 * appears after a '?' properly according to URL rules.  - kw
	 */
	pgm_args = NULL;
    }
    HTUnEscape(pgm);

    /* BEGIN WebSter Mods */
    /* If pgm is not stat-able, see if PATH_INFO data is at the end of pgm */
    if ((statrv = stat(pgm, &stat_buf)) < 0) {
	StrAllocCopy(pgm_buff, pgm);
	while (statrv < 0 || (statrv = stat(pgm_buff, &stat_buf)) < 0) {
	    if ((cp = strrchr(pgm_buff, '/')) != NULL) {
		*cp = '\0';
		statrv = 1;	/* force new stat()  - kw */
	    } else {
		PERROR("strrchr(pgm_buff, '/') returned NULL");
		break;
	    }
	}

	if (statrv < 0) {
	    /* Did not find PATH_INFO data */
	    PERROR("stat() of pgm_buff failed");
	} else {
	    /* Found PATH_INFO data.  Strip it off of pgm and into path_info. */
	    StrAllocCopy(path_info, pgm + strlen(pgm_buff));
	    /* The following is safe since pgm_buff was derived from pgm
	       by stripping stuff off its end and by HTUnEscaping, so we
	       know we have enough memory allocated for pgm.  Note that
	       pgm_args may still point into that memory, so we cannot
	       reallocate pgm here. - kw */
	    strcpy(pgm, pgm_buff);
	    CTRACE((tfp,
		    "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
		    pgm_buff, path_info));
	}
	FREE(pgm_buff);
    }
    /* END WebSter Mods */

    if (statrv != 0) {
	/*
	 * Neither the path as given nor any components examined by backing up
	 * were stat()able.  - kw
	 */
	HTAlert(gettext("Unable to access cgi script"));
	PERROR("stat() failed");
	status = -4;

    } else
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 09:16:04 */
#define isExecutable(mode) (mode & (S_IXUSR))
#else
#define isExecutable(mode) (mode & (S_IXUSR|S_IXGRP|S_IXOTH))
#endif
    if (!(S_ISREG(stat_buf.st_mode) && isExecutable(stat_buf.st_mode))) {
	/*
	 * Not a runnable file, See if we can load it using "file:" code.
	 */
	char *new_arg = NULL;

	/*
	 * But try "file:" only if the file we are looking at is the path as
	 * given (no path_info was extracted), otherwise it will be to
	 * confusing to know just what file is loaded.  - kw
	 */
	if (path_info) {
	    CTRACE((tfp,
		    "%s is not a file and %s not an executable, giving up.\n",
		    orig_pgm, pgm));
	    FREE(path_info);
	    FREE(pgm);
	    FREE(orig_pgm);
	    status = -4;
	    return (status);
	}

	LYLocalFileToURL(&new_arg, orig_pgm);

	CTRACE((tfp, "%s is not an executable file, passing the buck.\n", arg));
	status = HTLoadFile(new_arg, anAnchor, format_out, sink);
	FREE(new_arg);

    } else if (path_info &&
	       anAnchor != HTMainAnchor &&
	       !(reloading && anAnchor->document) &&
	       strcmp(arg, HTLoadedDocumentURL()) &&
	       HText_AreDifferent(anAnchor, arg) &&
	       HTUnEscape(orig_pgm) &&
	       !exec_ok(HTLoadedDocumentURL(), orig_pgm,
			CGI_PATH)) {	/* exec_ok gives out msg. */
	/*
	 * If we have extra path info and are not just reloading the current,
	 * check the full file path (after unescaping) now to catch forbidden
	 * segments.  - kw
	 */
	status = HT_NOT_LOADED;

    } else if (no_lynxcgi) {
	HTUserMsg(CGI_DISABLED);
	status = HT_NOT_LOADED;

    } else if (no_bookmark_exec &&
	       anAnchor != HTMainAnchor &&
	       !(reloading && anAnchor->document) &&
	       strcmp(arg, HTLoadedDocumentURL()) &&
	       HText_AreDifferent(anAnchor, arg) &&
	       HTLoadedDocumentBookmark()) {
	/*
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if no_bookmark_exec is
	 * TRUE an we are not now coming from a bookmark page.  - kw
	 */
	HTUserMsg(BOOKMARK_EXEC_DISABLED);
	status = HT_NOT_LOADED;

    } else if (anAnchor != HTMainAnchor &&
	       !(reloading && anAnchor->document) &&
	       strcmp(arg, HTLoadedDocumentURL()) &&
	       HText_AreDifferent(anAnchor, arg) &&
	       !exec_ok(HTLoadedDocumentURL(), pgm,
			CGI_PATH)) {	/* exec_ok gives out msg. */
	/*
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if exec_ok() would
	 * reject it because we are not now coming from a document with a URL
	 * allowed by TRUSTED_LYNXCGI rules.  - kw
	 */
	status = HT_NOT_LOADED;

    } else {
	HTFormat format_in;
	HTStream *target = NULL;	/* Unconverted data */
	int fd1[2], fd2[2];
	char buf[1024];
	int pid;

#ifdef HAVE_TYPE_UNIONWAIT
	union wait wstatus;

#else
	int wstatus;
#endif

	if (anAnchor->isHEAD || keep_mime_headers) {

	    /* Show output as plain text */
	    format_in = WWW_PLAINTEXT;
	} else {

	    /* Decode full HTTP response */
	    format_in = HTAtom_for("www/mime");
	}

	target = HTStreamStack(format_in,
			       format_out,
			       sink, anAnchor);

	if (!target || target == NULL) {
	    char *tmp = 0;

	    HTSprintf0(&tmp, CANNOT_CONVERT_I_TO_O,
		       HTAtom_name(format_in),
		       HTAtom_name(format_out));
	    HTAlert(tmp);
	    FREE(tmp);
	    status = HT_NOT_LOADED;

	} else if (anAnchor->post_data && pipe(fd1) < 0) {
	    HTAlert(CONNECT_SET_FAILED);
	    PERROR("pipe() failed");
	    status = -3;

	} else if (pipe(fd2) < 0) {
	    HTAlert(CONNECT_SET_FAILED);
	    PERROR("pipe() failed");
	    close(fd1[0]);
	    close(fd1[1]);
	    status = -3;

	} else {
	    static BOOL first_time = TRUE;	/* One time setup flag */

	    if (first_time) {	/* Set up static environment variables */
		first_time = FALSE;	/* Only once */

		add_environment_value("REMOTE_HOST=localhost");
		add_environment_value("REMOTE_ADDR=127.0.0.1");

		HTSprintf0(&user_agent, "HTTP_USER_AGENT=%s/%s libwww/%s",
			   LYNX_NAME, LYNX_VERSION, HTLibraryVersion);
		add_environment_value(user_agent);

		HTSprintf0(&server_software, "SERVER_SOFTWARE=%s/%s",
			   LYNX_NAME, LYNX_VERSION);
		add_environment_value(server_software);
	    }
	    fflush(stdout);
	    fflush(stderr);
	    CTRACE_FLUSH(tfp);

	    if ((pid = fork()) > 0) {	/* The good, */
		int chars, total_chars;

		close(fd2[1]);

		if (anAnchor->post_data) {
		    int written, remaining, total_written = 0;

		    close(fd1[0]);

		    /* We have form data to push across the pipe */
		    if (TRACE) {
			CTRACE((tfp,
				"LYNXCGI: Doing post, content-type '%s'\n",
				anAnchor->post_content_type));
			CTRACE((tfp, "LYNXCGI: Writing:\n"));
			trace_bstring(anAnchor->post_data);
			CTRACE((tfp, "----------------------------------\n"));
		    }
		    remaining = BStrLen(anAnchor->post_data);
		    while ((written = write(fd1[1],
					    BStrData(anAnchor->post_data) + total_written,
					    remaining)) != 0) {
			if (written < 0) {
#ifdef EINTR
			    if (errno == EINTR)
				continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
			    if (errno == ERESTARTSYS)
				continue;
#endif /* ERESTARTSYS */
			    PERROR("write() of POST data failed");
			    break;
			}
			CTRACE((tfp, "LYNXCGI: Wrote %d bytes of POST data.\n",
				written));
			total_written += written;
			remaining -= written;
			if (remaining == 0)
			    break;
		    }
		    if (remaining != 0) {
			CTRACE((tfp, "LYNXCGI: %d bytes remain unwritten!\n",
				remaining));
		    }
		    close(fd1[1]);
		}

		HTReadProgress(total_chars = 0, 0);
		while ((chars = read(fd2[0], buf, sizeof(buf))) != 0) {
		    if (chars < 0) {
#ifdef EINTR
			if (errno == EINTR)
			    continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
			if (errno == ERESTARTSYS)
			    continue;
#endif /* ERESTARTSYS */
			PERROR("read() of CGI output failed");
			break;
		    }
		    HTReadProgress(total_chars += chars, 0);
		    CTRACE((tfp, "LYNXCGI: Rx: %.*s\n", chars, buf));
		    (*target->isa->put_block) (target, buf, chars);
		}

		if (chars < 0 && total_chars == 0) {
		    status = HT_NOT_LOADED;
		    (*target->isa->_abort) (target, NULL);
		    target = NULL;
		} else if (chars != 0) {
		    status = HT_PARTIAL_CONTENT;
		} else {
		    status = HT_LOADED;
		}

#if !HAVE_WAITPID
		while (wait(&wstatus) != pid) ;		/* do nothing */
#else
		while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
#ifdef EINTR
		    if (errno == EINTR)
			continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
		    if (errno == ERESTARTSYS)
			continue;
#endif /* ERESTARTSYS */
		    break;
		}
#endif /* !HAVE_WAITPID */
		close(fd2[0]);

	    } else if (pid == 0) {	/* The Bad, */
		char **argv = NULL;
		int argv_cnt = 3;	/* name, one arg and terminator */
		char **cur_argv = NULL;
		int exec_errno;

		/* Set up output pipe */
		close(fd2[0]);
		dup2(fd2[1], fileno(stdout));	/* Should check success code */
		dup2(fd2[1], fileno(stderr));
		close(fd2[1]);

		if (non_empty(language)) {
		    HTSprintf0(&accept_language, "HTTP_ACCEPT_LANGUAGE=%s", language);
		    add_environment_value(accept_language);
		}

		if (non_empty(pref_charset)) {
		    cp = NULL;
		    StrAllocCopy(cp, "HTTP_ACCEPT_CHARSET=");
		    StrAllocCat(cp, pref_charset);
		    add_environment_value(cp);
		}

		if (anAnchor->post_data &&
		    anAnchor->post_content_type) {
		    cp = NULL;
		    StrAllocCopy(cp, "CONTENT_TYPE=");
		    StrAllocCat(cp, anAnchor->post_content_type);
		    add_environment_value(cp);
		}

		if (anAnchor->post_data) {	/* post script, read stdin */
		    close(fd1[1]);
		    dup2(fd1[0], fileno(stdin));
		    close(fd1[0]);

		    /* Build environment variables */

		    add_environment_value("REQUEST_METHOD=POST");

		    HTSprintf0(&post_len, "CONTENT_LENGTH=%d",
			       BStrLen(anAnchor->post_data));
		    add_environment_value(post_len);
		} else {
		    close(fileno(stdin));

		    if (anAnchor->isHEAD) {
			add_environment_value("REQUEST_METHOD=HEAD");
		    }
		}

		/*
		 * Set up argument line, mainly for <index> scripts
		 */
		if (pgm_args != NULL) {
		    for (cp = pgm_args; *cp != '\0'; cp++) {
			if (*cp == '+') {
			    argv_cnt++;
			}
		    }
		}

		argv = (char **) malloc(argv_cnt * sizeof(char *));

		if (argv == NULL) {
		    outofmem(__FILE__, "LYCgi");
		}
		cur_argv = argv + 1;	/* For argv[0] */
		if (pgm_args != NULL) {
		    char *cr;

		    /* Data for a get/search form */
		    if (is_www_index) {
			add_environment_value("REQUEST_METHOD=SEARCH");
		    } else if (!anAnchor->isHEAD && !anAnchor->post_data) {
			add_environment_value("REQUEST_METHOD=GET");
		    }

		    cp = NULL;
		    StrAllocCopy(cp, "QUERY_STRING=");
		    StrAllocCat(cp, pgm_args);
		    add_environment_value(cp);

		    /*
		     * Split up arguments into argv array
		     */
		    cp = pgm_args;
		    cr = cp;
		    while (1) {
			if (*cp == '\0') {
			    *(cur_argv++) = HTUnEscape(cr);
			    break;

			} else if (*cp == '+') {
			    *cp++ = '\0';
			    *(cur_argv++) = HTUnEscape(cr);
			    cr = cp;
			}
			cp++;
		    }
		} else if (!anAnchor->isHEAD && !anAnchor->post_data) {
		    add_environment_value("REQUEST_METHOD=GET");
		}
		*cur_argv = NULL;	/* Terminate argv */
		argv[0] = pgm;

		/* Begin WebSter Mods  -jkt */
		if (LYCgiDocumentRoot != NULL) {
		    /* Add DOCUMENT_ROOT to env */
		    cp = NULL;
		    StrAllocCopy(cp, "DOCUMENT_ROOT=");
		    StrAllocCat(cp, LYCgiDocumentRoot);
		    add_environment_value(cp);
		}
		if (path_info != NULL) {
		    /* Add PATH_INFO to env */
		    cp = NULL;
		    StrAllocCopy(cp, "PATH_INFO=");
		    StrAllocCat(cp, path_info);
		    add_environment_value(cp);
		}
		if (LYCgiDocumentRoot != NULL && path_info != NULL) {
		    /* Construct and add PATH_TRANSLATED to env */
		    StrAllocCopy(document_root, LYCgiDocumentRoot);
		    LYTrimHtmlSep(document_root);
		    path_translated = document_root;
		    StrAllocCat(path_translated, path_info);
		    cp = NULL;
		    StrAllocCopy(cp, "PATH_TRANSLATED=");
		    StrAllocCat(cp, path_translated);
		    add_environment_value(cp);
		    FREE(path_translated);
		}
		/* End WebSter Mods  -jkt */

		execve(argv[0], argv, env);
		exec_errno = errno;
		PERROR("execve failed");
		printf("Content-Type: text/plain\r\n\r\n");
		if (!anAnchor->isHEAD) {
		    printf("exec of %s failed", pgm);
		    printf(": %s.\r\n", LYStrerror(exec_errno));
		}
		fflush(stdout);
		fflush(stderr);
		_exit(1);

	    } else {		/* and the Ugly */
		HTAlert(CONNECT_FAILED);
		PERROR("fork() failed");
		status = HT_NO_DATA;
		close(fd1[0]);
		close(fd1[1]);
		close(fd2[0]);
		close(fd2[1]);
		status = -1;
	    }

	}
	if (target != NULL) {
	    (*target->isa->_free) (target);
	}
    }
    FREE(path_info);
    FREE(pgm);
    FREE(orig_pgm);
#else /* VMS */
    HTStream *target;
    char *buf = 0;

    target = HTStreamStack(WWW_HTML,
			   format_out,
			   sink, anAnchor);

    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       gettext("Good Advice"));
    PUTS(buf);

    HTSprintf0(&buf, "<h1>%s</h1>\n", gettext("Good Advice"));
    PUTS(buf);

    HTSprintf0(&buf, "%s <a\n",
	       gettext("An excellent http server for VMS is available via"));
    PUTS(buf);

    HTSprintf0(&buf,
	       "href=\"http://kcgl1.eng.ohio-state.edu/www/doc/serverinfo.html\"\n");
    PUTS(buf);

    HTSprintf0(&buf, ">%s</a>.\n", gettext("this link"));
    PUTS(buf);

    HTSprintf0(&buf, "<p>%s\n",
	       gettext("It provides state of the art CGI script support.\n"));
    PUTS(buf);

    HTSprintf0(&buf, "</body>\n</html>\n");
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(buf);
    status = HT_LOADED;
#endif /* VMS */
#else /* LYNXCGI_LINKS */
    HTUserMsg(CGI_NOT_COMPILED);
    status = HT_NOT_LOADED;
#endif /* LYNXCGI_LINKS */
    return (status);
}
#endif /* __MINGW32__ */

#ifdef GLOBALDEF_IS_MACRO
#define _LYCGI_C_GLOBALDEF_1_INIT { "lynxcgi", LYLoadCGI, 0 }
GLOBALDEF(HTProtocol, LYLynxCGI, _LYCGI_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxCGI =
{"lynxcgi", LYLoadCGI, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.4
log
@all the -W* stuff
@
text
@d1 1
a1 1
/* $MirBSD$ */
d68 1
a68 1
static void add_environment_value(char *env_value);
d105 1
a105 1
static void add_environment_value(char *env_value)
d123 1
a123 1
    env[envc++] = env_value;
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1 2
d4 23
a26 23
**                   ================
**
** Authors
**          GL      George Lindholm <George.Lindholm@@ubc.ca>
**
** History
**      15 Jun 95   Created as way to provide a lynx based service with
**                  dynamic pages without the need for a http daemon.  GL
**      27 Jun 95   Added <index> (command line) support.  Various cleanup
**                  and bug fixes. GL
**	04 Sep 97   Added support for PATH_INFO scripts.  JKT
**
** Bugs
**      If the called scripts aborts before sending the mime headers then
**      lynx hangs.
**
**      Should do something about SIGPIPE, (but then it should never happen)
**
**      No support for redirection.  Or mime-types.
**
**      Should try and parse for a HTTP 1.1 header in case we are "calling" a
**      nph- script.
*/
d52 2
a53 3
struct _HTStream
{
  HTStreamClass * isa;
d56 5
a60 4
PRIVATE char **env = NULL;  /* Environment variables */
PRIVATE int envc_size = 0;  /* Slots in environment array */
PRIVATE int envc = 0;	    /* Slots used so far */
PRIVATE HTList *alloced = NULL;
d62 4
a65 4
PRIVATE char *user_agent = NULL;
PRIVATE char *server_software = NULL;
PRIVATE char *accept_language = NULL;
PRIVATE char *post_len = NULL;
d68 1
a68 1
PRIVATE void add_environment_value PARAMS((char *env_value));
d72 2
d75 1
a75 1
PRIVATE void free_alloced_lynxcgi NOARGS
d78 1
d90 1
a90 2
PRIVATE void remember_alloced ARGS1(
    void *,		ptr)
d105 1
a105 2
PRIVATE void add_environment_value ARGS1(
	char *,	env_value)
d107 1
a107 1
    if (envc == envc_size) {   /* Need some more slots */
d110 3
a112 3
	    env = (char **)realloc(env,
				   sizeof(env[0]) * (envc_size + 2));
						/* + terminator and base 0 */
d114 2
a115 2
	    env = (char **)malloc(sizeof(env[0]) * (envc_size + 2));
						/* + terminator and base 0 */
d124 1
a124 1
    env[envc] = NULL;      /* Make sure it is always properly terminated */
d131 1
a131 2
PUBLIC void add_lynxcgi_environment ARGS1(
	CONST char *,	variable_name)
d145 13
a157 5
PRIVATE int LYLoadCGI ARGS4(
	CONST char *, 		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d160 1
d165 2
a166 2
    char *pgm = NULL;		        /* executable */
    char *pgm_args = NULL;	        /* and its argument(s) */
d168 5
a172 5
    char *orig_pgm = NULL;		/* Path up to ? as given, URL-escaped*/
    char *document_root = NULL;		/* Corrected value of DOCUMENT_ROOT  */
    char *path_info = NULL;             /* PATH_INFO extracted from pgm      */
    char *pgm_buff = NULL;		/* PATH_INFO extraction buffer       */
    char *path_translated;		/* From document_root/path_info      */
d177 1
a177 1
	return(status);
d181 1
a181 1
	    StrAllocCopy(pgm, arg+19);
d183 1
a183 1
	    StrAllocCopy(pgm, arg+8);
d185 1
a185 1
	if ((cp=strchr(pgm, '?')) != NULL) { /* Need to terminate executable */
d194 4
a197 5
	 *  Strip a #fragment from path.  In this case any pgm_args
	 *  found above will also be bogus, since the '?' came after
	 *  the '#' and is part of the fragment.  Note that we don't
	 *  handle the case where a '#' appears after a '?' properly
	 *  according to URL rules. - kw
d208 1
a208 1
	    if ((cp=strrchr(pgm_buff, '/')) != NULL) {
d213 1
a213 1
	    	break;
d215 1
a215 1
        }
d229 3
a231 2
	    CTRACE((tfp, "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
			pgm_buff, path_info));
d239 2
a240 2
	 *  Neither the path as given nor any components examined by
	 *  backing up were stat()able. - kw
d247 1
a247 1
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 09:16:04 */
d254 1
a254 1
	 *  Not a runnable file, See if we can load it using "file:" code.
d259 3
a261 3
	 *  But try "file:" only if the file we are looking at is the path
	 *  as given (no path_info was extracted), otherwise it will be
	 *  to confusing to know just what file is loaded. - kw
d264 3
a266 2
	    CTRACE((tfp, "%s is not a file and %s not an executable, giving up.\n",
			orig_pgm, pgm));
d271 1
a271 1
	    return(status);
d274 1
a274 1
	LYLocalFileToURL (&new_arg, orig_pgm);
d287 1
a287 1
			CGI_PATH)) { /* exec_ok gives out msg. */
d289 3
a291 3
	 *  If we have extra path info and are not just reloading
	 *  the current, check the full file path (after unescaping)
	 *  now to catch forbidden segments. - kw
d304 1
a304 1
 	       HTLoadedDocumentBookmark()) {
d306 3
a308 4
	 *  If we are reloading a lynxcgi document that had already been
	 *  loaded, the various checks above should allow it even if
	 *  no_bookmark_exec is TRUE an we are not now coming from a
	 *  bookmark page. - kw
d318 1
a318 1
			CGI_PATH)) { /* exec_ok gives out msg. */
d320 4
a323 4
	 *  If we are reloading a lynxcgi document that had already been
	 *  loaded, the various checks above should allow it even if
	 *  exec_ok() would reject it because we are not now coming from
	 *  a document with a URL allowed by TRUSTED_LYNXCGI rules. - kw
d329 1
a329 1
	HTStream *target  = NULL;		/* Unconverted data */
d333 1
d336 1
d357 1
d378 1
a378 1
	    static BOOL first_time = TRUE;      /* One time setup flag */
d387 1
a387 1
			LYNX_NAME, LYNX_VERSION, HTLibraryVersion);
d391 1
a391 1
			LYNX_NAME, LYNX_VERSION);
d398 1
a398 1
	    if ((pid = fork()) > 0) { /* The good, */
d410 2
a411 1
			CTRACE((tfp, "LYNXCGI: Doing post, content-type '%s'\n",
d434 1
a434 1
				    written));
d442 1
a442 1
				    remaining));
d448 1
a448 1
		while((chars = read(fd2[0], buf, sizeof(buf))) != 0) {
d463 1
a463 1
		    (*target->isa->put_block)(target, buf, chars);
d468 1
a468 1
		    (*target->isa->_abort)(target, NULL);
d477 1
a477 2
		while (wait(&wstatus) != pid)
		    ; /* do nothing */
d479 1
a479 1
		while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
d493 1
a493 1
	    } else if (pid == 0) { /* The Bad, */
d495 1
a495 1
		int argv_cnt = 3; /* name, one arg and terminator */
d501 1
a501 1
		dup2(fd2[1], fileno(stdout)); /* Should check success code */
d505 3
a507 3
		if (language && *language) {
		HTSprintf0(&accept_language, "HTTP_ACCEPT_LANGUAGE=%s", language);
		add_environment_value(accept_language);
d510 1
a510 1
		if (pref_charset && *pref_charset) {
d525 1
a525 1
		if (anAnchor->post_data) { /* post script, read stdin */
d556 2
a557 1
		argv = (char**)malloc(argv_cnt * sizeof(char*));
d561 1
a561 1
		cur_argv = argv + 1;		/* For argv[0] */
d582 1
a582 1
		    while(1) {
d608 1
a608 1
		if (path_info != NULL ) {
d615 1
a615 1
		if (LYCgiDocumentRoot != NULL && path_info != NULL ) {
d641 1
a641 1
	    } else {	/* and the Ugly */
d654 1
a654 1
	    (*target->isa->_free)(target);
d660 1
a660 1
#else  /* VMS */
d670 1
a670 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d673 1
a673 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d675 3
a677 2
    HTSprintf0(&buf, "%s <a\n", gettext("An excellent http server for VMS is available via"));
    (*target->isa->put_block)(target, buf, strlen(buf));
d681 1
a681 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d684 1
a684 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d688 1
a688 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d690 2
a691 2
    HTSprintf0(&buf,"</body>\n</html>\n");
    (*target->isa->put_block)(target, buf, strlen(buf));
d693 1
a693 1
    (*target->isa->_free)(target);
d701 1
a701 1
    return(status);
d703 1
d707 1
a707 1
GLOBALDEF (HTProtocol,LYLynxCGI,_LYCGI_C_GLOBALDEF_1_INIT);
d709 2
a710 1
GLOBALDEF PUBLIC HTProtocol LYLynxCGI = { "lynxcgi", LYLoadCGI, 0 };
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d48 1
a48 4

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
d68 1
a68 1
#define PERROR(msg) CTRACE(tfp, "LYNXCGI: %s: %s\n", msg, LYStrerror(errno))
d133 1
a133 1
    env_value = getenv(variable_name);
d137 1
a137 8
	add_value = (char *)malloc(strlen(variable_name) +
				   strlen(env_value) + 2);
	if (add_value == NULL) {
	    outofmem(__FILE__, "LYCgi");
	}
	strcpy(add_value, variable_name);
	strcat(add_value, "=");
	strcat(add_value, env_value);
d163 1
a163 1
    if (!arg || !*arg || strlen(arg) <= 8) {
d181 1
a181 1
    if ((cp=strchr(pgm, '#')) != NULL) {
a188 1
	*cp = '\0';
d200 1
a200 1
		statrv = 999;	/* force new stat()  - kw */
d212 6
a217 1
	    StrAllocCopy(path_info, pgm+strlen(pgm_buff));
d219 2
a220 2
	    CTRACE(tfp, "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
			pgm_buff, path_info);
d235 7
a241 2
    } else if (!(S_ISREG(stat_buf.st_mode) &&
		 stat_buf.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))) {
d253 2
a254 2
	    CTRACE(tfp, "%s is not a file and %s not an executable, giving up.\n",
			orig_pgm, pgm);
d264 1
a264 1
	CTRACE(tfp, "%s is not an executable file, passing the buck.\n", arg);
d321 1
a321 1
	pid_t pid;
d391 1
d395 8
a402 5
		    CTRACE(tfp, "LYNXCGI: Doing post, content-type '%s'\n",
				anAnchor->post_content_type);
		    CTRACE(tfp, "LYNXCGI: Writing:\n%s----------------------------------\n",
				anAnchor->post_data);
		    remaining = strlen(anAnchor->post_data);
d404 1
a404 1
					    anAnchor->post_data + total_written,
d418 2
a419 2
			CTRACE(tfp, "LYNXCGI: Wrote %d bytes of POST data.\n",
				    written);
d426 2
a427 2
			CTRACE(tfp, "LYNXCGI: %d bytes remain unwritten!\n",
				    remaining);
d447 1
a447 1
		    CTRACE(tfp, "LYNXCGI: Rx: %.*s\n", chars, buf);
d521 1
a521 1
			    strlen(anAnchor->post_data));
d653 2
a654 1
    HTSprintf0(&buf, "<head>\n<title>%s</title>\n</head>\n<body>\n", gettext("Good Advice"));
d674 1
a674 1
    HTSprintf0(&buf,"</body>\n");
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 23
a24 23
 *                   ================
 *
 * Authors
 *          GL      George Lindholm <George.Lindholm@@ubc.ca>
 *
 * History
 *      15 Jun 95   Created as way to provide a lynx based service with
 *                  dynamic pages without the need for a http daemon.  GL
 *      27 Jun 95   Added <index> (command line) support.  Various cleanup
 *                  and bug fixes. GL
 *	04 Sep 97   Added support for PATH_INFO scripts.  JKT
 *
 * Bugs
 *      If the called scripts aborts before sending the mime headers then
 *      lynx hangs.
 *
 *      Should do something about SIGPIPE, (but then it should never happen)
 *
 *      No support for redirection.  Or mime-types.
 *
 *      Should try and parse for a HTTP 1.1 header in case we are "calling" a
 *      nph- script.
 */
a47 1
#include <www_wait.h>
d49 7
a55 2
struct _HTStream {
    HTStreamClass *isa;
d58 4
a61 5
static char **env = NULL;	/* Environment variables */
static int envc_size = 0;	/* Slots in environment array */
static int envc = 0;		/* Slots used so far */
static HTList *alloced = NULL;

d63 4
a66 4
static char *user_agent = NULL;
static char *server_software = NULL;
static char *accept_language = NULL;
static char *post_len = NULL;
d69 1
a69 3
static void add_environment_value(const char *env_value);

#define PERROR(msg) CTRACE((tfp, "LYNXCGI: %s: %s\n", msg, LYStrerror(errno)))
d71 1
a71 1
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))
d74 1
a74 1
static void free_alloced_lynxcgi(void)
a76 1

d88 2
a89 1
static void remember_alloced(void *ptr)
d104 2
a105 1
static void add_environment_value(const char *env_value)
d107 1
a107 1
    if (envc == envc_size) {	/* Need some more slots */
d110 3
a112 3
	    env = (char **) realloc(env,
				    sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
d114 2
a115 2
	    env = (char **) malloc(sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
d123 2
a124 2
    env[envc++] = (char *) env_value;
    env[envc] = NULL;		/* Make sure it is always properly terminated */
d131 2
a132 1
void add_lynxcgi_environment(const char *variable_name)
d136 1
a136 1
    env_value = LYGetEnv(variable_name);
d140 8
a147 1
	HTSprintf0(&add_value, "%s=%s", variable_name, env_value);
d153 5
a157 13
#ifdef __MINGW32__
static int LYLoadCGI(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
{
    return -1;
}
#else
static int LYLoadCGI(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
a159 1

d164 2
a165 2
    char *pgm = NULL;		/* executable */
    char *pgm_args = NULL;	/* and its argument(s) */
d167 5
a171 5
    char *orig_pgm = NULL;	/* Path up to ? as given, URL-escaped */
    char *document_root = NULL;	/* Corrected value of DOCUMENT_ROOT  */
    char *path_info = NULL;	/* PATH_INFO extracted from pgm      */
    char *pgm_buff = NULL;	/* PATH_INFO extraction buffer       */
    char *path_translated;	/* From document_root/path_info      */
d173 1
a173 1
    if (isEmpty(arg) || strlen(arg) <= 8) {
d176 1
a176 1
	return (status);
d180 1
a180 1
	    StrAllocCopy(pgm, arg + 19);
d182 1
a182 1
	    StrAllocCopy(pgm, arg + 8);
d184 1
a184 1
	if ((cp = strchr(pgm, '?')) != NULL) {	/* Need to terminate executable */
d191 1
a191 1
    if ((cp = trimPoundSelector(pgm)) != NULL) {
d193 5
a197 4
	 * Strip a #fragment from path.  In this case any pgm_args found above
	 * will also be bogus, since the '?' came after the '#' and is part of
	 * the fragment.  Note that we don't handle the case where a '#'
	 * appears after a '?' properly according to URL rules.  - kw
d199 1
d209 1
a209 1
	    if ((cp = strrchr(pgm_buff, '/')) != NULL) {
d211 1
a211 1
		statrv = 1;	/* force new stat()  - kw */
d214 1
a214 1
		break;
d216 1
a216 1
	}
d223 1
a223 6
	    StrAllocCopy(path_info, pgm + strlen(pgm_buff));
	    /* The following is safe since pgm_buff was derived from pgm
	       by stripping stuff off its end and by HTUnEscaping, so we
	       know we have enough memory allocated for pgm.  Note that
	       pgm_args may still point into that memory, so we cannot
	       reallocate pgm here. - kw */
d225 2
a226 3
	    CTRACE((tfp,
		    "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
		    pgm_buff, path_info));
d234 2
a235 2
	 * Neither the path as given nor any components examined by backing up
	 * were stat()able.  - kw
d241 2
a242 7
    } else
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 09:16:04 */
#define isExecutable(mode) (mode & (S_IXUSR))
#else
#define isExecutable(mode) (mode & (S_IXUSR|S_IXGRP|S_IXOTH))
#endif
    if (!(S_ISREG(stat_buf.st_mode) && isExecutable(stat_buf.st_mode))) {
d244 1
a244 1
	 * Not a runnable file, See if we can load it using "file:" code.
d249 3
a251 3
	 * But try "file:" only if the file we are looking at is the path as
	 * given (no path_info was extracted), otherwise it will be to
	 * confusing to know just what file is loaded.  - kw
d254 2
a255 3
	    CTRACE((tfp,
		    "%s is not a file and %s not an executable, giving up.\n",
		    orig_pgm, pgm));
d260 1
a260 1
	    return (status);
d263 1
a263 1
	LYLocalFileToURL(&new_arg, orig_pgm);
d265 1
a265 1
	CTRACE((tfp, "%s is not an executable file, passing the buck.\n", arg));
d276 1
a276 1
			CGI_PATH)) {	/* exec_ok gives out msg. */
d278 3
a280 3
	 * If we have extra path info and are not just reloading the current,
	 * check the full file path (after unescaping) now to catch forbidden
	 * segments.  - kw
d293 1
a293 1
	       HTLoadedDocumentBookmark()) {
d295 4
a298 3
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if no_bookmark_exec is
	 * TRUE an we are not now coming from a bookmark page.  - kw
d308 1
a308 1
			CGI_PATH)) {	/* exec_ok gives out msg. */
d310 4
a313 4
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if exec_ok() would
	 * reject it because we are not now coming from a document with a URL
	 * allowed by TRUSTED_LYNXCGI rules.  - kw
d319 1
a319 1
	HTStream *target = NULL;	/* Unconverted data */
d322 1
a322 2
	int pid;

a324 1

a344 1

d365 1
a365 1
	    static BOOL first_time = TRUE;	/* One time setup flag */
d374 1
a374 1
			   LYNX_NAME, LYNX_VERSION, HTLibraryVersion);
d378 1
a378 1
			   LYNX_NAME, LYNX_VERSION);
d385 1
a385 1
	    if ((pid = fork()) > 0) {	/* The good, */
a391 1

d395 5
a399 9
		    if (TRACE) {
			CTRACE((tfp,
				"LYNXCGI: Doing post, content-type '%s'\n",
				anAnchor->post_content_type));
			CTRACE((tfp, "LYNXCGI: Writing:\n"));
			trace_bstring(anAnchor->post_data);
			CTRACE((tfp, "----------------------------------\n"));
		    }
		    remaining = BStrLen(anAnchor->post_data);
d401 1
a401 1
					    BStrData(anAnchor->post_data) + total_written,
d415 2
a416 2
			CTRACE((tfp, "LYNXCGI: Wrote %d bytes of POST data.\n",
				written));
d423 2
a424 2
			CTRACE((tfp, "LYNXCGI: %d bytes remain unwritten!\n",
				remaining));
d430 1
a430 1
		while ((chars = read(fd2[0], buf, sizeof(buf))) != 0) {
d444 2
a445 2
		    CTRACE((tfp, "LYNXCGI: Rx: %.*s\n", chars, buf));
		    (*target->isa->put_block) (target, buf, chars);
d450 1
a450 1
		    (*target->isa->_abort) (target, NULL);
d459 2
a460 1
		while (wait(&wstatus) != pid) ;		/* do nothing */
d462 1
a462 1
		while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
d476 1
a476 1
	    } else if (pid == 0) {	/* The Bad, */
d478 1
a478 1
		int argv_cnt = 3;	/* name, one arg and terminator */
d484 1
a484 1
		dup2(fd2[1], fileno(stdout));	/* Should check success code */
d488 3
a490 3
		if (non_empty(language)) {
		    HTSprintf0(&accept_language, "HTTP_ACCEPT_LANGUAGE=%s", language);
		    add_environment_value(accept_language);
d493 1
a493 1
		if (non_empty(pref_charset)) {
d508 1
a508 1
		if (anAnchor->post_data) {	/* post script, read stdin */
d518 1
a518 1
			       BStrLen(anAnchor->post_data));
d539 1
a539 2
		argv = (char **) malloc(argv_cnt * sizeof(char *));

d543 1
a543 1
		cur_argv = argv + 1;	/* For argv[0] */
d564 1
a564 1
		    while (1) {
d590 1
a590 1
		if (path_info != NULL) {
d597 1
a597 1
		if (LYCgiDocumentRoot != NULL && path_info != NULL) {
d623 1
a623 1
	    } else {		/* and the Ugly */
d636 1
a636 1
	    (*target->isa->_free) (target);
d642 1
a642 1
#else /* VMS */
d650 2
a651 3
    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       gettext("Good Advice"));
    PUTS(buf);
d654 1
a654 1
    PUTS(buf);
d656 2
a657 3
    HTSprintf0(&buf, "%s <a\n",
	       gettext("An excellent http server for VMS is available via"));
    PUTS(buf);
d661 1
a661 1
    PUTS(buf);
d664 1
a664 1
    PUTS(buf);
d668 1
a668 1
    PUTS(buf);
d670 2
a671 2
    HTSprintf0(&buf, "</body>\n</html>\n");
    PUTS(buf);
d673 1
a673 1
    (*target->isa->_free) (target);
d681 1
a681 1
    return (status);
a682 1
#endif /* __MINGW32__ */
d686 1
a686 1
GLOBALDEF(HTProtocol, LYLynxCGI, _LYCGI_C_GLOBALDEF_1_INIT);
d688 1
a688 2
GLOBALDEF HTProtocol LYLynxCGI =
{"lynxcgi", LYLoadCGI, 0};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d48 4
a51 1
#include <www_wait.h>
d71 1
a71 1
#define PERROR(msg) CTRACE((tfp, "LYNXCGI: %s: %s\n", msg, LYStrerror(errno)))
d136 1
a136 1
    env_value = LYGetEnv(variable_name);
d140 8
a147 1
	HTSprintf0(&add_value, "%s=%s", variable_name, env_value);
d173 1
a173 1
    if (isEmpty(arg) || strlen(arg) <= 8) {
d191 1
a191 1
    if ((cp = trimPoundSelector(pgm)) != NULL) {
d199 1
d211 1
a211 1
		statrv = 1;	/* force new stat()  - kw */
d223 1
a223 6
	    StrAllocCopy(path_info, pgm + strlen(pgm_buff));
	    /* The following is safe since pgm_buff was derived from pgm
	       by stripping stuff off its end and by HTUnEscaping, so we
	       know we have enough memory allocated for pgm.  Note that
	       pgm_args may still point into that memory, so we cannot
	       reallocate pgm here. - kw */
d225 2
a226 2
	    CTRACE((tfp, "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
			pgm_buff, path_info));
d241 2
a242 7
    } else
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 09:16:04 */
#define isExecutable(mode) (mode & (S_IXUSR))
#else
#define isExecutable(mode) (mode & (S_IXUSR|S_IXGRP|S_IXOTH))
#endif
    if (!(S_ISREG(stat_buf.st_mode) && isExecutable(stat_buf.st_mode))) {
d254 2
a255 2
	    CTRACE((tfp, "%s is not a file and %s not an executable, giving up.\n",
			orig_pgm, pgm));
d265 1
a265 1
	CTRACE((tfp, "%s is not an executable file, passing the buck.\n", arg));
d322 1
a322 1
	int pid;
a391 1

d395 5
a399 8
		    if (TRACE) {
			CTRACE((tfp, "LYNXCGI: Doing post, content-type '%s'\n",
				anAnchor->post_content_type));
			CTRACE((tfp, "LYNXCGI: Writing:\n"));
			trace_bstring(anAnchor->post_data);
			CTRACE((tfp, "----------------------------------\n"));
		    }
		    remaining = BStrLen(anAnchor->post_data);
d401 1
a401 1
					    BStrData(anAnchor->post_data) + total_written,
d415 2
a416 2
			CTRACE((tfp, "LYNXCGI: Wrote %d bytes of POST data.\n",
				    written));
d423 2
a424 2
			CTRACE((tfp, "LYNXCGI: %d bytes remain unwritten!\n",
				    remaining));
d444 1
a444 1
		    CTRACE((tfp, "LYNXCGI: Rx: %.*s\n", chars, buf));
d518 1
a518 1
			       BStrLen(anAnchor->post_data));
d650 1
a650 2
    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       gettext("Good Advice"));
d670 1
a670 1
    HTSprintf0(&buf,"</body>\n</html>\n");
@


1.1.3.2
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a142 10
#ifdef __MINGW32__
PRIVATE int LYLoadCGI ARGS4(
	CONST char *, 		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
{
	return -1;
}
#else
a686 1
#endif /* __MINGW32__ */
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d55 4
a58 4
static char **env = NULL;  /* Environment variables */
static int envc_size = 0;  /* Slots in environment array */
static int envc = 0;	    /* Slots used so far */
static HTList *alloced = NULL;
d60 4
a63 4
static char *user_agent = NULL;
static char *server_software = NULL;
static char *accept_language = NULL;
static char *post_len = NULL;
d66 1
a66 1
static void add_environment_value (char *env_value);
d71 1
a71 1
static void free_alloced_lynxcgi (void)
d85 2
a86 2
static void remember_alloced (
    void *		ptr)
d101 2
a102 2
static void add_environment_value (
	char *	env_value)
d128 2
a129 2
void add_lynxcgi_environment (
	const char *	variable_name)
d144 5
a148 5
static int LYLoadCGI (
	const char * 		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d153 5
a157 5
static int LYLoadCGI (
	const char * 		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d703 1
a703 1
GLOBALDEF HTProtocol LYLynxCGI = { "lynxcgi", LYLoadCGI, 0 };
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 23
a24 23
 *                   ================
 *
 * Authors
 *          GL      George Lindholm <George.Lindholm@@ubc.ca>
 *
 * History
 *      15 Jun 95   Created as way to provide a lynx based service with
 *                  dynamic pages without the need for a http daemon.  GL
 *      27 Jun 95   Added <index> (command line) support.  Various cleanup
 *                  and bug fixes. GL
 *	04 Sep 97   Added support for PATH_INFO scripts.  JKT
 *
 * Bugs
 *      If the called scripts aborts before sending the mime headers then
 *      lynx hangs.
 *
 *      Should do something about SIGPIPE, (but then it should never happen)
 *
 *      No support for redirection.  Or mime-types.
 *
 *      Should try and parse for a HTTP 1.1 header in case we are "calling" a
 *      nph- script.
 */
d50 3
a52 2
struct _HTStream {
    HTStreamClass *isa;
d55 3
a57 3
static char **env = NULL;	/* Environment variables */
static int envc_size = 0;	/* Slots in environment array */
static int envc = 0;		/* Slots used so far */
a58 1

d66 1
a66 1
static void add_environment_value(char *env_value);
d71 1
a71 1
static void free_alloced_lynxcgi(void)
a73 1

d85 2
a86 1
static void remember_alloced(void *ptr)
d101 2
a102 1
static void add_environment_value(char *env_value)
d104 1
a104 1
    if (envc == envc_size) {	/* Need some more slots */
d107 3
a109 3
	    env = (char **) realloc(env,
				    sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
d111 2
a112 2
	    env = (char **) malloc(sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
d121 1
a121 1
    env[envc] = NULL;		/* Make sure it is always properly terminated */
d128 2
a129 1
void add_lynxcgi_environment(const char *variable_name)
d144 5
a148 4
static int LYLoadCGI(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
d150 1
a150 1
    return -1;
d153 5
a157 4
static int LYLoadCGI(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
a159 1

d164 2
a165 2
    char *pgm = NULL;		/* executable */
    char *pgm_args = NULL;	/* and its argument(s) */
d167 5
a171 5
    char *orig_pgm = NULL;	/* Path up to ? as given, URL-escaped */
    char *document_root = NULL;	/* Corrected value of DOCUMENT_ROOT  */
    char *path_info = NULL;	/* PATH_INFO extracted from pgm      */
    char *pgm_buff = NULL;	/* PATH_INFO extraction buffer       */
    char *path_translated;	/* From document_root/path_info      */
d176 1
a176 1
	return (status);
d180 1
a180 1
	    StrAllocCopy(pgm, arg + 19);
d182 1
a182 1
	    StrAllocCopy(pgm, arg + 8);
d184 1
a184 1
	if ((cp = strchr(pgm, '?')) != NULL) {	/* Need to terminate executable */
d193 5
a197 4
	 * Strip a #fragment from path.  In this case any pgm_args found above
	 * will also be bogus, since the '?' came after the '#' and is part of
	 * the fragment.  Note that we don't handle the case where a '#'
	 * appears after a '?' properly according to URL rules.  - kw
d208 1
a208 1
	    if ((cp = strrchr(pgm_buff, '/')) != NULL) {
d213 1
a213 1
		break;
d215 1
a215 1
	}
d229 2
a230 3
	    CTRACE((tfp,
		    "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
		    pgm_buff, path_info));
d238 2
a239 2
	 * Neither the path as given nor any components examined by backing up
	 * were stat()able.  - kw
d246 1
a246 1
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 09:16:04 */
d253 1
a253 1
	 * Not a runnable file, See if we can load it using "file:" code.
d258 3
a260 3
	 * But try "file:" only if the file we are looking at is the path as
	 * given (no path_info was extracted), otherwise it will be to
	 * confusing to know just what file is loaded.  - kw
d263 2
a264 3
	    CTRACE((tfp,
		    "%s is not a file and %s not an executable, giving up.\n",
		    orig_pgm, pgm));
d269 1
a269 1
	    return (status);
d272 1
a272 1
	LYLocalFileToURL(&new_arg, orig_pgm);
d285 1
a285 1
			CGI_PATH)) {	/* exec_ok gives out msg. */
d287 3
a289 3
	 * If we have extra path info and are not just reloading the current,
	 * check the full file path (after unescaping) now to catch forbidden
	 * segments.  - kw
d302 1
a302 1
	       HTLoadedDocumentBookmark()) {
d304 4
a307 3
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if no_bookmark_exec is
	 * TRUE an we are not now coming from a bookmark page.  - kw
d317 1
a317 1
			CGI_PATH)) {	/* exec_ok gives out msg. */
d319 4
a322 4
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if exec_ok() would
	 * reject it because we are not now coming from a document with a URL
	 * allowed by TRUSTED_LYNXCGI rules.  - kw
d328 1
a328 1
	HTStream *target = NULL;	/* Unconverted data */
a331 1

a333 1

a353 1

d374 1
a374 1
	    static BOOL first_time = TRUE;	/* One time setup flag */
d383 1
a383 1
			   LYNX_NAME, LYNX_VERSION, HTLibraryVersion);
d387 1
a387 1
			   LYNX_NAME, LYNX_VERSION);
d394 1
a394 1
	    if ((pid = fork()) > 0) {	/* The good, */
d406 1
a406 2
			CTRACE((tfp,
				"LYNXCGI: Doing post, content-type '%s'\n",
d429 1
a429 1
				written));
d437 1
a437 1
				remaining));
d443 1
a443 1
		while ((chars = read(fd2[0], buf, sizeof(buf))) != 0) {
d458 1
a458 1
		    (*target->isa->put_block) (target, buf, chars);
d463 1
a463 1
		    (*target->isa->_abort) (target, NULL);
d472 2
a473 1
		while (wait(&wstatus) != pid) ;		/* do nothing */
d475 1
a475 1
		while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
d489 1
a489 1
	    } else if (pid == 0) {	/* The Bad, */
d491 1
a491 1
		int argv_cnt = 3;	/* name, one arg and terminator */
d497 1
a497 1
		dup2(fd2[1], fileno(stdout));	/* Should check success code */
d502 2
a503 2
		    HTSprintf0(&accept_language, "HTTP_ACCEPT_LANGUAGE=%s", language);
		    add_environment_value(accept_language);
d521 1
a521 1
		if (anAnchor->post_data) {	/* post script, read stdin */
d552 1
a552 2
		argv = (char **) malloc(argv_cnt * sizeof(char *));

d556 1
a556 1
		cur_argv = argv + 1;	/* For argv[0] */
d577 1
a577 1
		    while (1) {
d603 1
a603 1
		if (path_info != NULL) {
d610 1
a610 1
		if (LYCgiDocumentRoot != NULL && path_info != NULL) {
d636 1
a636 1
	    } else {		/* and the Ugly */
d649 1
a649 1
	    (*target->isa->_free) (target);
d655 1
a655 1
#else /* VMS */
d665 1
a665 1
    (*target->isa->put_block) (target, buf, strlen(buf));
d668 1
a668 1
    (*target->isa->put_block) (target, buf, strlen(buf));
d670 2
a671 3
    HTSprintf0(&buf, "%s <a\n",
	       gettext("An excellent http server for VMS is available via"));
    (*target->isa->put_block) (target, buf, strlen(buf));
d675 1
a675 1
    (*target->isa->put_block) (target, buf, strlen(buf));
d678 1
a678 1
    (*target->isa->put_block) (target, buf, strlen(buf));
d682 1
a682 1
    (*target->isa->put_block) (target, buf, strlen(buf));
d684 2
a685 2
    HTSprintf0(&buf, "</body>\n</html>\n");
    (*target->isa->put_block) (target, buf, strlen(buf));
d687 1
a687 1
    (*target->isa->_free) (target);
d695 1
a695 1
    return (status);
d701 1
a701 1
GLOBALDEF(HTProtocol, LYLynxCGI, _LYCGI_C_GLOBALDEF_1_INIT);
d703 1
a703 2
GLOBALDEF HTProtocol LYLynxCGI =
{"lynxcgi", LYLoadCGI, 0};
@


1.1.3.5
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a69 2
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

d666 1
a666 1
    PUTS(buf);
d669 1
a669 1
    PUTS(buf);
d673 1
a673 1
    PUTS(buf);
d677 1
a677 1
    PUTS(buf);
d680 1
a680 1
    PUTS(buf);
d684 1
a684 1
    PUTS(buf);
d687 1
a687 1
    PUTS(buf);
@


1.1.3.6
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d503 1
a503 1
		if (non_empty(language)) {
d508 1
a508 1
		if (non_empty(pref_charset)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d48 4
a51 1
#include <www_wait.h>
d71 1
a71 1
#define PERROR(msg) CTRACE((tfp, "LYNXCGI: %s: %s\n", msg, LYStrerror(errno)))
d140 8
a147 1
	HTSprintf0(&add_value, "%s=%s", variable_name, env_value);
d211 1
a211 1
		statrv = 1;	/* force new stat()  - kw */
d223 1
a223 6
	    StrAllocCopy(path_info, pgm + strlen(pgm_buff));
	    /* The following is safe since pgm_buff was derived from pgm
	       by stripping stuff off its end and by HTUnEscaping, so we
	       know we have enough memory allocated for pgm.  Note that
	       pgm_args may still point into that memory, so we cannot
	       reallocate pgm here. - kw */
d225 2
a226 2
	    CTRACE((tfp, "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
			pgm_buff, path_info));
d241 2
a242 7
    } else
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 09:16:04 */
#define isExecutable(mode) (mode & (S_IXUSR))
#else
#define isExecutable(mode) (mode & (S_IXUSR|S_IXGRP|S_IXOTH))
#endif
    if (!(S_ISREG(stat_buf.st_mode) && isExecutable(stat_buf.st_mode))) {
d254 2
a255 2
	    CTRACE((tfp, "%s is not a file and %s not an executable, giving up.\n",
			orig_pgm, pgm));
d265 1
a265 1
	CTRACE((tfp, "%s is not an executable file, passing the buck.\n", arg));
d395 4
a398 4
		    CTRACE((tfp, "LYNXCGI: Doing post, content-type '%s'\n",
				anAnchor->post_content_type));
		    CTRACE((tfp, "LYNXCGI: Writing:\n%s----------------------------------\n",
				anAnchor->post_data));
d415 2
a416 2
			CTRACE((tfp, "LYNXCGI: Wrote %d bytes of POST data.\n",
				    written));
d423 2
a424 2
			CTRACE((tfp, "LYNXCGI: %d bytes remain unwritten!\n",
				    remaining));
d444 1
a444 1
		    CTRACE((tfp, "LYNXCGI: Rx: %.*s\n", chars, buf));
d650 1
a650 2
    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       gettext("Good Advice"));
d670 1
a670 1
    HTSprintf0(&buf,"</body>\n</html>\n");
@

