head	1.4;
branch	1.1.3;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.7
	tg-mergefixes-1-branch:1.1.3.7.0.4
	tg-mergefixes-1-base:1.1.3.7
	MIROS_X:1.1.3.7.0.2
	MIROS_X_BASE:1.1.3.7
	MIRBSD_XP_MIRPPC:1.1.3.5.0.4
	lynx-2_8_6dev_7b:1.1.3.7
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.1.3.5
	MIRBSD_XP_SPARC:1.1.3.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.01.18.16.56.12;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.33;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.22;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.48;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.23;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.43;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.11.42;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.16.06;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.54.08;	author tg;	state Stab;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.24;	author tg;	state Exp;
branches;
next	1.1.3.7;

1.1.3.7
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@/*
 External application support.
 This feature allows lynx to pass a given URL to an external program.
 It was written for three reasons.
 1) To overcome the deficiency	of Lynx_386 not supporting ftp and news.
    External programs can be used instead by passing the URL.

 2) To allow for background transfers in multitasking systems.
    I use wget for http and ftp transfers via the external command.

 3) To allow for new URLs to be used through lynx.
    URLs can be made up such as mymail: to spawn desired applications
    via the external command.

 See lynx.cfg for other info.
*/

#include <LYUtils.h>

#ifdef USE_EXTERNALS

#include <HTAlert.h>
#include <LYGlobalDefs.h>
#include <LYExtern.h>
#include <LYLeaks.h>
#include <LYCurses.h>
#include <LYReadCFG.h>
#include <LYStrings.h>

#ifdef WIN_EX
/* ASCII char -> HEX digit */
#define ASC2HEXD(x) (((x) >= '0' && (x) <= '9') ?               \
		     ((x) - '0') : (toupper(x) - 'A' + 10))


/* Decodes the forms %xy in a URL to the character the hexadecimal
   code of which is xy. xy are hexadecimal digits from
   [0123456789ABCDEF] (case-insensitive). If x or y are not hex-digits
   or '%' is near '\0', the whole sequence is inserted literally. */


static char *decode_string(char *s)
{
    char *save_s;
    char *p = s;

    save_s = s;
    for (; *s; s++, p++) {
	if (*s != '%')
	    *p = *s;
	else {
	    /* Do nothing if at the end of the string. Or if the chars
	       are not hex-digits. */
	    if (!*(s + 1) || !*(s + 2)
		|| !(isxdigit(*(s + 1)) && isxdigit(*(s + 2)))) {
		*p = *s;
		continue;
	    }
	    *p = (char)((ASC2HEXD(*(s + 1)) << 4) + ASC2HEXD(*(s + 2)));
	    s += 2;
	}
    }
    *p = '\0';
    return save_s;
}
#endif	/* WIN_EX */

#ifdef WIN_EX
/*
 *  Quote the path to make it safe for shell command processing.
 */
PUBLIC char * quote_pathname ARGS1(
	char *, 	pathname)
{
    char * result = NULL;

    if (strchr(pathname, ' ') != NULL) {
	HTSprintf0(&result, "\"%s\"", pathname);
    } else {
	StrAllocCopy(result, pathname);
    }
    return result;
}
#endif /* WIN_EX */


PRIVATE void format ARGS3(
    char **,	result,
    char *,	fmt,
    char *,	parm)
{
    *result = NULL;
    HTAddParam(result, fmt, 1, parm);
    HTEndParam(result, fmt, 1);
}

/*
 * Format the given command into a buffer, returning the resulting string.
 *
 * It is too dangerous to leave any URL that may come along unquoted.  They
 * often contain '&', ';', and '?' chars, and who knows what else may occur.
 * Prevent spoofing of the shell.  Dunno how this needs to be modified for VMS
 * or DOS.  - kw
 */
PRIVATE char *format_command ARGS2(
    char *,	command,
    char *,	param)
{
    char *cmdbuf = NULL;

#if defined(WIN_EX)
    if (*param != '\"' && strchr(param, ' ') != NULL) {
	char *cp = quote_pathname(param);
	format(&cmdbuf, command, cp);
	FREE(cp);
    } else {
	char pram_string[LY_MAXPATH];

	LYstrncpy(pram_string, param, sizeof(pram_string)-1);
	decode_string(pram_string);
	param = pram_string;

	if (isMAILTO_URL(param)) {
	    format(&cmdbuf, command, param + 7);
	} else if (strnicmp("telnet://", param, 9) == 0) {
	    char host[sizeof(pram_string)];
	    int last_pos;

	    strcpy(host, param + 9);
	    last_pos = strlen(host) - 1;
	    if (last_pos > 1 && host[last_pos] == '/')
		host[last_pos] = '\0';

	    format(&cmdbuf, command, host);
	} else if (strnicmp("file://localhost/", param, 17) == 0) {
	    char e_buff[LY_MAXPATH], *p;

	    p = param + 17;
	    *e_buff = 0;
	    if (strchr(p, ':') == NULL) {
		sprintf(e_buff, "%.3s/", windows_drive);
	    }
	    strncat(e_buff, p, sizeof(e_buff) - strlen(e_buff) - 1);
	    p = strrchr(e_buff, '.');
	    if (p) {
		trimPoundSelector(p);
	    }

	    /* Less ==> short filename with backslashes,
	     * less ==> long filename with forward slashes, may be quoted
	     */
	    if (ISUPPER(command[0])) {
		format(&cmdbuf,
			command, HTDOS_short_name(e_buff));
	    } else {
		if (*e_buff != '\"' && strchr(e_buff, ' ') != NULL) {
		    p = quote_pathname(e_buff);
		    LYstrncpy(e_buff, p, sizeof(e_buff)-1);
		    FREE(p);
		}
		format(&cmdbuf, command, e_buff);
	    }
	} else {
	    format(&cmdbuf, command, param);
	}
    }
#else
    format(&cmdbuf, command, param);
#endif
    return cmdbuf;
}

/*
 * Find the EXTERNAL command which matches the given name 'param'.  If there is
 * more than one possibility, make a popup menu of the matching commands and
 * allow the user to select one.  Return the selected command.
 */
PRIVATE char *lookup_external ARGS2(
    char *, 	param,
    BOOL,	only_overriders)
{
    int pass, num_disabled, num_matched, num_choices, cur_choice;
    int length = 0;
    char *cmdbuf = NULL;
    char **choices = 0;
    lynx_list_item_type *ptr = 0;

    for (pass = 0; pass < 2; pass++) {
	num_disabled = 0;
	num_matched = 0;
	num_choices = 0;
	for (ptr = externals; ptr != 0; ptr = ptr->next) {

	    if (match_item_by_name(ptr, param, only_overriders)) {
		++num_matched;
		CTRACE((tfp, "EXTERNAL: '%s' <==> '%s'\n", ptr->name, param));
		if (no_externals && !ptr->always_enabled && !only_overriders) {
		    ++num_disabled;
		} else {
		    if (pass == 0) {
			length++;
		    } else if (pass != 0) {
			cmdbuf = format_command(ptr->command, param);
			if (length > 1)
			    choices[num_choices] = cmdbuf;
		    }
		    num_choices++;
		}
	    }
	}
	if (length > 1) {
	    if (pass == 0) {
		choices = typecallocn(char *, length + 1);
	    } else {
		choices[num_choices] = 0;
	    }
	}
    }

    if (num_disabled != 0
     && num_disabled == num_matched) {
	HTUserMsg(EXTERNALS_DISABLED);
    } else if (num_choices > 1) {
	int old_y, old_x;

	LYGetYX(old_y, old_x);
	cur_choice = LYhandlePopupList(
			-1,
			0,
			old_x,
			(CONST char **)choices,
			-1,
			-1,
			FALSE,
			TRUE,
			FALSE);
	wmove(LYwin, old_y, old_x);
	CTRACE((tfp, "selected choice %d of %d\n", cur_choice, num_choices));
	if (cur_choice < 0) {
	    HTInfoMsg(CANCELLED);
	    cmdbuf = 0;
	}
	for (pass = 0; choices[pass] != 0; pass++) {
	    if (pass == cur_choice) {
		cmdbuf = choices[pass];
	    } else {
		FREE(choices[pass]);
	    }
	}
	FREE(choices);
    }
    return cmdbuf;
}

BOOL run_external ARGS2(
    char *, 	param,
    BOOL,	only_overriders)
{
#ifdef WIN_EX
    int status;
#endif
    int redraw_flag = TRUE;
    char *cmdbuf = NULL;
    BOOL found = FALSE;
    int confirmed = TRUE;

    if (externals == NULL)
	return 0;

#ifdef WIN_EX			/* 1998/01/26 (Mon) 09:16:13 */
    if (param == NULL) {
	HTInfoMsg(gettext("External command is null"));
	return 0;
    }
#endif

    cmdbuf = lookup_external(param, only_overriders);
    if (cmdbuf != 0 && *cmdbuf != '\0') {
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
	int len;
	char buff[LY_MAXPATH];

	CTRACE((tfp, "Lynx EXTERNAL: '%s'\n", cmdbuf));
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:15 */
	confirmed = MessageBox(GetForegroundWindow(), cmdbuf,
			       "Lynx (EXTERNAL COMMAND EXEC)",
			       MB_ICONQUESTION | MB_SETFOREGROUND | MB_OKCANCEL)
		    != IDCANCEL;
#else
	confirmed = HTConfirm(LYElideString(cmdbuf, 40)) != NO;
#endif
	if (confirmed) {
	    len = strlen(cmdbuf);
	    if (len > 255) {
		sprintf(buff, "Lynx: command line too long (%d > 255)", len);
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:02 */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_OK);
		SetConsoleTitle("Lynx for Win32");
#else
		HTConfirm(LYElideString(buff, 40));
#endif
		confirmed = FALSE;
	    } else {
		SetConsoleTitle(cmdbuf);
	    }
	}

	if (strnicmp(cmdbuf, "start ", 6) == 0)
	    redraw_flag = FALSE;
	else
	    redraw_flag = TRUE;
#else
	HTUserMsg(cmdbuf);
#endif
	found = TRUE;
	if (confirmed) {
	    if (redraw_flag) {
		stop_curses();
		fflush(stdout);
	    }

	    /* command running. */
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
#ifdef __CYGWIN__
	    status = system(cmdbuf);
#else
	    status = xsystem(cmdbuf);
#endif
	    if (status != 0) {
		sprintf(buff,
			"EXEC code = %04x (%2d, %2d)\r\n"
			"'%s'",
			status, (status / 256), (status & 0xff),
			cmdbuf);
#ifdef SH_EX	/* WIN_GUI for ERROR only */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONSTOP | MB_SETFOREGROUND | MB_OK);
#else
		HTConfirm(LYElideString(buff, 40));
#endif /* 1 */
	    }
#else	/* Not WIN_EX */
	    LYSystem(cmdbuf);
#endif	/* WIN_EX */

#if defined(WIN_EX)
	    SetConsoleTitle("Lynx for Win32");
#endif
	    if (redraw_flag) {
		fflush(stdout);
		start_curses();
	    }
	}
    }

    FREE(cmdbuf);
    return found;
}
#endif	/* USE_EXTERNALS */
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d152 1
a152 1
	    if (isupper(command[0])) {
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d27 2
d30 44
a73 1
void run_external ARGS1(char *, cmd)
d75 10
a84 2
    char *the_command = 0;
    lynx_html_item_type *ext = 0;
a85 1
    for (ext = externals; ext != NULL; ext = ext->next) {
d87 9
a95 2
	if (ext->command != 0
	&& !strncasecomp(ext->name, cmd, strlen(ext->name))) {
d97 58
a154 2
	    if (no_externals && !ext->always_enabled) {
		HTUserMsg(EXTERNALS_DISABLED);
d156 16
d173 14
a186 2
		HTAddParam(&the_command, ext->command, 1, cmd);
		HTEndParam(&the_command, ext->command, 1);
d188 5
a192 1
		HTUserMsg(the_command);
d194 126
d321 33
a353 2
		LYSystem(the_command);
		FREE(the_command);
a355 2

	    break;
d359 2
a360 1
    return;
d362 1
a362 1
#endif /* USE_EXTERNALS */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a26 2
#include <LYReadCFG.h>
#include <LYStrings.h>
d28 1
a28 145
#ifdef WIN_EX
/* ASCII char -> HEX digit */
#define ASC2HEXD(x) (((x) >= '0' && (x) <= '9') ?               \
		     ((x) - '0') : (toupper(x) - 'A' + 10))

/* Decodes the forms %xy in a URL to the character the hexadecimal
   code of which is xy. xy are hexadecimal digits from
   [0123456789ABCDEF] (case-insensitive). If x or y are not hex-digits
   or '%' is near '\0', the whole sequence is inserted literally. */

static char *decode_string(char *s)
{
    char *save_s;
    char *p = s;

    save_s = s;
    for (; *s; s++, p++) {
	if (*s != '%')
	    *p = *s;
	else {
	    /* Do nothing if at the end of the string. Or if the chars
	       are not hex-digits. */
	    if (!*(s + 1) || !*(s + 2)
		|| !(isxdigit(*(s + 1)) && isxdigit(*(s + 2)))) {
		*p = *s;
		continue;
	    }
	    *p = (char) ((ASC2HEXD(*(s + 1)) << 4) + ASC2HEXD(*(s + 2)));
	    s += 2;
	}
    }
    *p = '\0';
    return save_s;
}
#endif /* WIN_EX */

#ifdef WIN_EX
/*
 * Quote the path to make it safe for shell command processing.
 */
char *quote_pathname(char *pathname)
{
    char *result = NULL;

    if (strchr(pathname, ' ') != NULL) {
	HTSprintf0(&result, "\"%s\"", pathname);
    } else {
	StrAllocCopy(result, pathname);
    }
    return result;
}
#endif /* WIN_EX */

static void format(char **result,
		   char *fmt,
		   char *parm)
{
    *result = NULL;
    HTAddParam(result, fmt, 1, parm);
    HTEndParam(result, fmt, 1);
}

/*
 * Format the given command into a buffer, returning the resulting string.
 *
 * It is too dangerous to leave any URL that may come along unquoted.  They
 * often contain '&', ';', and '?' chars, and who knows what else may occur.
 * Prevent spoofing of the shell.  Dunno how this needs to be modified for VMS
 * or DOS.  - kw
 */
static char *format_command(char *command,
			    char *param)
{
    char *cmdbuf = NULL;

#if defined(WIN_EX)
    if (*param != '"' && strchr(param, ' ') != NULL) {
	char *cp = quote_pathname(param);

	format(&cmdbuf, command, cp);
	FREE(cp);
    } else {
	char pram_string[LY_MAXPATH];

	LYstrncpy(pram_string, param, sizeof(pram_string) - 1);
	decode_string(pram_string);
	param = pram_string;

	if (isMAILTO_URL(param)) {
	    format(&cmdbuf, command, param + 7);
	} else if (strnicmp("telnet://", param, 9) == 0) {
	    char host[sizeof(pram_string)];
	    int last_pos;

	    strcpy(host, param + 9);
	    last_pos = strlen(host) - 1;
	    if (last_pos > 1 && host[last_pos] == '/')
		host[last_pos] = '\0';

	    format(&cmdbuf, command, host);
	} else if (strnicmp("file://localhost/", param, 17) == 0) {
	    char e_buff[LY_MAXPATH], *p;

	    p = param + 17;
	    *e_buff = 0;
	    if (strchr(p, ':') == NULL) {
		sprintf(e_buff, "%.3s/", windows_drive);
	    }
	    strncat(e_buff, p, sizeof(e_buff) - strlen(e_buff) - 1);
	    p = strrchr(e_buff, '.');
	    if (p) {
		trimPoundSelector(p);
	    }

	    /* Less ==> short filename with backslashes,
	     * less ==> long filename with forward slashes, may be quoted
	     */
	    if (ISUPPER(command[0])) {
		format(&cmdbuf,
		       command, HTDOS_short_name(e_buff));
	    } else {
		if (*e_buff != '"' && strchr(e_buff, ' ') != NULL) {
		    p = quote_pathname(e_buff);
		    LYstrncpy(e_buff, p, sizeof(e_buff) - 1);
		    FREE(p);
		}
		format(&cmdbuf, command, e_buff);
	    }
	} else {
	    format(&cmdbuf, command, param);
	}
    }
#else
    format(&cmdbuf, command, param);
#endif
    return cmdbuf;
}

/*
 * Find the EXTERNAL command which matches the given name 'param'.  If there is
 * more than one possibility, make a popup menu of the matching commands and
 * allow the user to select one.  Return the selected command.
 */
static char *lookup_external(char *param,
			     BOOL only_overriders)
d30 2
a31 11
    int pass, num_disabled, num_matched, num_choices, cur_choice;
    int length = 0;
    char *cmdbuf = NULL;
    char **choices = 0;
    lynx_list_item_type *ptr = 0;

    for (pass = 0; pass < 2; pass++) {
	num_disabled = 0;
	num_matched = 0;
	num_choices = 0;
	for (ptr = externals; ptr != 0; ptr = ptr->next) {
d33 1
a33 25
	    if (match_item_by_name(ptr, param, only_overriders)) {
		++num_matched;
		CTRACE((tfp, "EXTERNAL: '%s' <==> '%s'\n", ptr->name, param));
		if (no_externals && !ptr->always_enabled && !only_overriders) {
		    ++num_disabled;
		} else {
		    if (pass == 0) {
			length++;
		    } else if (pass != 0) {
			cmdbuf = format_command(ptr->command, param);
			if (length > 1)
			    choices[num_choices] = cmdbuf;
		    }
		    num_choices++;
		}
	    }
	}
	if (length > 1) {
	    if (pass == 0) {
		choices = typecallocn(char *, length + 1);
	    } else {
		choices[num_choices] = 0;
	    }
	}
    }
d35 2
a36 5
    if (num_disabled != 0
	&& num_disabled == num_matched) {
	HTUserMsg(EXTERNALS_DISABLED);
    } else if (num_choices > 1) {
	int old_y, old_x;
d38 2
a39 19
	LYGetYX(old_y, old_x);
	cur_choice = LYhandlePopupList(-1,
				       0,
				       old_x,
				       (const char **) choices,
				       -1,
				       -1,
				       FALSE,
				       TRUE,
				       FALSE);
	wmove(LYwin, old_y, old_x);
	CTRACE((tfp, "selected choice %d of %d\n", cur_choice, num_choices));
	if (cur_choice < 0) {
	    HTInfoMsg(CANCELLED);
	    cmdbuf = 0;
	}
	for (pass = 0; choices[pass] != 0; pass++) {
	    if (pass == cur_choice) {
		cmdbuf = choices[pass];
a40 7
		FREE(choices[pass]);
	    }
	}
	FREE(choices);
    }
    return cmdbuf;
}
d42 2
a43 20
BOOL run_external(char *param,
		  BOOL only_overriders)
{
#ifdef WIN_EX
    int status;
#endif
    int redraw_flag = TRUE;
    char *cmdbuf = NULL;
    BOOL found = FALSE;
    int confirmed = TRUE;

    if (externals == NULL)
	return 0;

#ifdef WIN_EX			/* 1998/01/26 (Mon) 09:16:13 */
    if (param == NULL) {
	HTInfoMsg(gettext("External command is null"));
	return 0;
    }
#endif
d45 1
a45 5
    cmdbuf = lookup_external(param, only_overriders);
    if (non_empty(cmdbuf)) {
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
	int len;
	char buff[LY_MAXPATH];
a46 37
	CTRACE((tfp, "Lynx EXTERNAL: '%s'\n", cmdbuf));
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:15 */
	confirmed = MessageBox(GetForegroundWindow(), cmdbuf,
			       "Lynx (EXTERNAL COMMAND EXEC)",
			       MB_ICONQUESTION | MB_SETFOREGROUND | MB_OKCANCEL)
	    != IDCANCEL;
#else
	confirmed = HTConfirm(LYElideString(cmdbuf, 40)) != NO;
#endif
	if (confirmed) {
	    len = strlen(cmdbuf);
	    if (len > 255) {
		sprintf(buff, "Lynx: command line too long (%d > 255)", len);
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:02 */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_OK);
		SetConsoleTitle("Lynx for Win32");
#else
		HTConfirm(LYElideString(buff, 40));
#endif
		confirmed = FALSE;
	    } else {
		SetConsoleTitle(cmdbuf);
	    }
	}

	if (strnicmp(cmdbuf, "start ", 6) == 0)
	    redraw_flag = FALSE;
	else
	    redraw_flag = TRUE;
#else
	HTUserMsg(cmdbuf);
#endif
	found = TRUE;
	if (confirmed) {
	    if (redraw_flag) {
d48 3
a50 23
		fflush(stdout);
	    }

	    /* command running. */
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
#if defined(__CYGWIN__) || defined(__MINGW32__)
	    status = system(cmdbuf);
#else
	    status = xsystem(cmdbuf);
#endif
	    if (status != 0) {
		sprintf(buff,
			"EXEC code = %04x (%2d, %2d)\r\n"
			"'%s'",
			status, (status / 256), (status & 0xff),
			cmdbuf);
#ifdef SH_EX			/* WIN_GUI for ERROR only */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONSTOP | MB_SETFOREGROUND | MB_OK);
#else
		HTConfirm(LYElideString(buff, 40));
#endif /* 1 */
a51 3
#else /* Not WIN_EX */
	    LYSystem(cmdbuf);
#endif /* WIN_EX */
d53 1
a53 7
#if defined(WIN_EX)
	    SetConsoleTitle("Lynx for Win32");
#endif
	    if (redraw_flag) {
		fflush(stdout);
		start_curses();
	    }
d57 1
a57 2
    FREE(cmdbuf);
    return found;
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a26 2
#include <LYReadCFG.h>
#include <LYStrings.h>
d28 1
a28 44
#ifdef WIN_EX
/* ASCII char -> HEX digit */
#define ASC2HEXD(x) (((x) >= '0' && (x) <= '9') ?               \
		     ((x) - '0') : (toupper(x) - 'A' + 10))


/* Decodes the forms %xy in a URL to the character the hexadecimal
   code of which is xy. xy are hexadecimal digits from
   [0123456789ABCDEF] (case-insensitive). If x or y are not hex-digits
   or '%' is near '\0', the whole sequence is inserted literally. */


static char *decode_string(char *s)
{
    char *save_s;
    char *p = s;

    save_s = s;
    for (; *s; s++, p++) {
	if (*s != '%')
	    *p = *s;
	else {
	    /* Do nothing if at the end of the string. Or if the chars
	       are not hex-digits. */
	    if (!*(s + 1) || !*(s + 2)
		|| !(isxdigit(*(s + 1)) && isxdigit(*(s + 2)))) {
		*p = *s;
		continue;
	    }
	    *p = (char)((ASC2HEXD(*(s + 1)) << 4) + ASC2HEXD(*(s + 2)));
	    s += 2;
	}
    }
    *p = '\0';
    return save_s;
}
#endif	/* WIN_EX */

#ifdef WIN_EX
/*
 *  Quote the path to make it safe for shell command processing.
 */
PUBLIC char * quote_pathname ARGS1(
	char *, 	pathname)
d30 2
a31 10
    char * result = NULL;

    if (strchr(pathname, ' ') != NULL) {
	HTSprintf0(&result, "\"%s\"", pathname);
    } else {
	StrAllocCopy(result, pathname);
    }
    return result;
}
#endif /* WIN_EX */
d33 1
d35 2
a36 9
PRIVATE void format ARGS3(
    char **,	result,
    char *,	fmt,
    char *,	parm)
{
    *result = NULL;
    HTAddParam(result, fmt, 1, parm);
    HTEndParam(result, fmt, 1);
}
d38 2
a39 58
/*
 * Format the given command into a buffer, returning the resulting string.
 *
 * It is too dangerous to leave any URL that may come along unquoted.  They
 * often contain '&', ';', and '?' chars, and who knows what else may occur.
 * Prevent spoofing of the shell.  Dunno how this needs to be modified for VMS
 * or DOS.  - kw
 */
PRIVATE char *format_command ARGS2(
    char *,	command,
    char *,	param)
{
    char *cmdbuf = NULL;

#if defined(WIN_EX)
    if (*param != '\"' && strchr(param, ' ') != NULL) {
	char *cp = quote_pathname(param);
	format(&cmdbuf, command, cp);
	FREE(cp);
    } else {
	char pram_string[LY_MAXPATH];

	LYstrncpy(pram_string, param, sizeof(pram_string)-1);
	decode_string(pram_string);
	param = pram_string;

	if (isMAILTO_URL(param)) {
	    format(&cmdbuf, command, param + 7);
	} else if (strnicmp("telnet://", param, 9) == 0) {
	    char host[sizeof(pram_string)];
	    int last_pos;

	    strcpy(host, param + 9);
	    last_pos = strlen(host) - 1;
	    if (last_pos > 1 && host[last_pos] == '/')
		host[last_pos] = '\0';

	    format(&cmdbuf, command, host);
	} else if (strnicmp("file://localhost/", param, 17) == 0) {
	    char e_buff[LY_MAXPATH], *p;

	    p = param + 17;
	    *e_buff = 0;
	    if (strchr(p, ':') == NULL) {
		sprintf(e_buff, "%.3s/", windows_drive);
	    }
	    strncat(e_buff, p, sizeof(e_buff) - strlen(e_buff) - 1);
	    p = strrchr(e_buff, '.');
	    if (p) {
		trimPoundSelector(p);
	    }

	    /* Less ==> short filename with backslashes,
	     * less ==> long filename with forward slashes, may be quoted
	     */
	    if (isupper(command[0])) {
		format(&cmdbuf,
			command, HTDOS_short_name(e_buff));
a40 16
		if (*e_buff != '\"' && strchr(e_buff, ' ') != NULL) {
		    p = quote_pathname(e_buff);
		    LYstrncpy(e_buff, p, sizeof(e_buff)-1);
		    FREE(p);
		}
		format(&cmdbuf, command, e_buff);
	    }
	} else {
	    format(&cmdbuf, command, param);
	}
    }
#else
    format(&cmdbuf, command, param);
#endif
    return cmdbuf;
}
d42 2
a43 14
/*
 * Find the EXTERNAL command which matches the given name 'param'.  If there is
 * more than one possibility, make a popup menu of the matching commands and
 * allow the user to select one.  Return the selected command.
 */
PRIVATE char *lookup_external ARGS2(
    char *, 	param,
    BOOL,	only_overriders)
{
    int pass, num_disabled, num_matched, num_choices, cur_choice;
    int length = 0;
    char *cmdbuf = NULL;
    char **choices = 0;
    lynx_list_item_type *ptr = 0;
d45 1
a45 5
    for (pass = 0; pass < 2; pass++) {
	num_disabled = 0;
	num_matched = 0;
	num_choices = 0;
	for (ptr = externals; ptr != 0; ptr = ptr->next) {
a46 126
	    if (match_item_by_name(ptr, param, only_overriders)) {
		++num_matched;
		CTRACE((tfp, "EXTERNAL: '%s' <==> '%s'\n", ptr->name, param));
		if (no_externals && !ptr->always_enabled && !only_overriders) {
		    ++num_disabled;
		} else {
		    if (pass == 0) {
			length++;
		    } else if (pass != 0) {
			cmdbuf = format_command(ptr->command, param);
			if (length > 1)
			    choices[num_choices] = cmdbuf;
		    }
		    num_choices++;
		}
	    }
	}
	if (length > 1) {
	    if (pass == 0) {
		choices = typecallocn(char *, length + 1);
	    } else {
		choices[num_choices] = 0;
	    }
	}
    }

    if (num_disabled != 0
     && num_disabled == num_matched) {
	HTUserMsg(EXTERNALS_DISABLED);
    } else if (num_choices > 1) {
	int old_y, old_x;

	LYGetYX(old_y, old_x);
	cur_choice = LYhandlePopupList(
			-1,
			0,
			old_x,
			(CONST char **)choices,
			-1,
			-1,
			FALSE,
			TRUE,
			FALSE);
	wmove(LYwin, old_y, old_x);
	CTRACE((tfp, "selected choice %d of %d\n", cur_choice, num_choices));
	if (cur_choice < 0) {
	    HTInfoMsg(CANCELLED);
	    cmdbuf = 0;
	}
	for (pass = 0; choices[pass] != 0; pass++) {
	    if (pass == cur_choice) {
		cmdbuf = choices[pass];
	    } else {
		FREE(choices[pass]);
	    }
	}
	FREE(choices);
    }
    return cmdbuf;
}

BOOL run_external ARGS2(
    char *, 	param,
    BOOL,	only_overriders)
{
#ifdef WIN_EX
    int status;
#endif
    int redraw_flag = TRUE;
    char *cmdbuf = NULL;
    BOOL found = FALSE;
    int confirmed = TRUE;

    if (externals == NULL)
	return 0;

#ifdef WIN_EX			/* 1998/01/26 (Mon) 09:16:13 */
    if (param == NULL) {
	HTInfoMsg(gettext("External command is null"));
	return 0;
    }
#endif

    cmdbuf = lookup_external(param, only_overriders);
    if (cmdbuf != 0 && *cmdbuf != '\0') {
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
	int len;
	char buff[LY_MAXPATH];

	CTRACE((tfp, "Lynx EXTERNAL: '%s'\n", cmdbuf));
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:15 */
	confirmed = MessageBox(GetForegroundWindow(), cmdbuf,
			       "Lynx (EXTERNAL COMMAND EXEC)",
			       MB_ICONQUESTION | MB_SETFOREGROUND | MB_OKCANCEL)
		    != IDCANCEL;
#else
	confirmed = HTConfirm(LYElideString(cmdbuf, 40)) != NO;
#endif
	if (confirmed) {
	    len = strlen(cmdbuf);
	    if (len > 255) {
		sprintf(buff, "Lynx: command line too long (%d > 255)", len);
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:02 */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_OK);
		SetConsoleTitle("Lynx for Win32");
#else
		HTConfirm(LYElideString(buff, 40));
#endif
		confirmed = FALSE;
	    } else {
		SetConsoleTitle(cmdbuf);
	    }
	}

	if (strnicmp(cmdbuf, "start ", 6) == 0)
	    redraw_flag = FALSE;
	else
	    redraw_flag = TRUE;
#else
	HTUserMsg(cmdbuf);
#endif
	found = TRUE;
	if (confirmed) {
	    if (redraw_flag) {
d48 3
a50 1
		fflush(stdout);
d53 1
a53 32
	    /* command running. */
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
#ifdef __CYGWIN__
	    status = system(cmdbuf);
#else
	    status = xsystem(cmdbuf);
#endif
	    if (status != 0) {
		sprintf(buff,
			"EXEC code = %04x (%2d, %2d)\r\n"
			"'%s'",
			status, (status / 256), (status & 0xff),
			cmdbuf);
#ifdef SH_EX	/* WIN_GUI for ERROR only */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONSTOP | MB_SETFOREGROUND | MB_OK);
#else
		HTConfirm(LYElideString(buff, 40));
#endif /* 1 */
	    }
#else	/* Not WIN_EX */
	    LYSystem(cmdbuf);
#endif	/* WIN_EX */

#if defined(WIN_EX)
	    SetConsoleTitle("Lynx for Win32");
#endif
	    if (redraw_flag) {
		fflush(stdout);
		start_curses();
	    }
d57 1
a57 2
    FREE(cmdbuf);
    return found;
d59 1
a59 1
#endif	/* USE_EXTERNALS */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d152 1
a152 1
	    if (ISUPPER(command[0])) {
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d326 1
a326 1
#if defined(__CYGWIN__) || defined(__MINGW32__)
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d72 2
a73 2
char * quote_pathname (
	char * 	pathname)
d87 4
a90 4
static void format (
    char **	result,
    char *	fmt,
    char *	parm)
d105 3
a107 3
static char *format_command (
    char *	command,
    char *	param)
d178 3
a180 3
static char *lookup_external (
    char * 	param,
    BOOL	only_overriders)
d231 1
a231 1
			(const char **)choices,
d255 3
a257 3
BOOL run_external (
    char * 	param,
    BOOL	only_overriders)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d35 1
d41 1
d59 1
a59 1
	    *p = (char) ((ASC2HEXD(*(s + 1)) << 4) + ASC2HEXD(*(s + 2)));
d66 1
a66 1
#endif /* WIN_EX */
d70 1
a70 1
 * Quote the path to make it safe for shell command processing.
d72 2
a73 1
char *quote_pathname(char *pathname)
d75 1
a75 1
    char *result = NULL;
d86 5
a90 3
static void format(char **result,
		   char *fmt,
		   char *parm)
d105 3
a107 2
static char *format_command(char *command,
			    char *param)
a113 1

d119 1
a119 1
	LYstrncpy(pram_string, param, sizeof(pram_string) - 1);
d154 1
a154 1
		       command, HTDOS_short_name(e_buff));
d158 1
a158 1
		    LYstrncpy(e_buff, p, sizeof(e_buff) - 1);
d178 3
a180 2
static char *lookup_external(char *param,
			     BOOL only_overriders)
d221 1
a221 1
	&& num_disabled == num_matched) {
d227 10
a236 9
	cur_choice = LYhandlePopupList(-1,
				       0,
				       old_x,
				       (const char **) choices,
				       -1,
				       -1,
				       FALSE,
				       TRUE,
				       FALSE);
d255 3
a257 2
BOOL run_external(char *param,
		  BOOL only_overriders)
d288 1
a288 1
	    != IDCANCEL;
d337 1
a337 1
#ifdef SH_EX			/* WIN_GUI for ERROR only */
d345 1
a345 1
#else /* Not WIN_EX */
d347 1
a347 1
#endif /* WIN_EX */
d362 1
a362 1
#endif /* USE_EXTERNALS */
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d106 1
a106 1
    if (*param != '"' && strchr(param, ' ') != NULL) {
d151 1
a151 1
		if (*e_buff != '"' && strchr(e_buff, ' ') != NULL) {
@


1.1.3.7
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d270 1
a270 1
    if (non_empty(cmdbuf)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a26 2
#include <LYReadCFG.h>
#include <LYStrings.h>
d28 1
a28 48
#ifdef WIN_EX
/* ASCII char -> HEX digit */
#define ASC2HEXD(x) (((x) >= '0' && (x) <= '9') ?               \
		     ((x) - '0') : (toupper(x) - 'A' + 10))


/* Decodes the forms %xy in a URL to the character the hexadecimal
   code of which is xy. xy are hexadecimal digits from
   [0123456789ABCDEF] (case-insensitive). If x or y are not hex-digits
   or '%' is near '\0', the whole sequence is inserted literally. */


static char *decode_string(char *s)
{
    char *save_s;
    char *p = s;

    save_s = s;
    for (; *s; s++, p++) {
	if (*s != '%')
	    *p = *s;
	else {
	    /* Do nothing if at the end of the string. Or if the chars
	       are not hex-digits. */
	    if (!*(s + 1) || !*(s + 2)
		|| !(isxdigit(*(s + 1)) && isxdigit(*(s + 2)))) {
		*p = *s;
		continue;
	    }
	    *p = (char)((ASC2HEXD(*(s + 1)) << 4) + ASC2HEXD(*(s + 2)));
	    s += 2;
	}
    }
    *p = '\0';
    return save_s;
}
#endif	/* WIN_EX */

#ifdef WIN_EX
/*
 *  Quote the path to make it safe for shell command processing.
 *
 *  We use a simple technique which involves quoting the entire
 *  string using single quotes, escaping the real single quotes
 *  with double quotes. This may be gross but it seems to work.
 */
PUBLIC char * quote_pathname ARGS1(
	char *, 	pathname)
d30 2
a31 10
    char * result = NULL;

    if (strchr(pathname, ' ') != NULL) {
	HTSprintf0(&result, "\"%s\"", pathname);
    } else {
	StrAllocCopy(result, pathname);
    }
    return result;
}
#endif /* WIN_EX */
d33 1
d35 2
a36 9
PRIVATE void format ARGS3(
    char **,	result,
    char *,	fmt,
    char *,	parm)
{
    *result = NULL;
    HTAddParam(result, fmt, 1, parm);
    HTEndParam(result, fmt, 1);
}
d38 2
a39 70
/*
 * Format the given command into a buffer, returning the resulting string.
 *
 * It is too dangerous to leave any URL that may come along unquoted.  They
 * often contain '&', ';', and '?' chars, and who knows what else may occur. 
 * Prevent spoofing of the shell.  Dunno how this needs to be modified for VMS
 * or DOS.  - kw
 */
PRIVATE char *format_command ARGS2(
    char *,	command,
    char *,	param)
{
#ifdef WIN_EX
    char pram_string[LY_MAXPATH];
#endif
    char *cmdbuf = NULL;

#if (defined(VMS) || defined(DOSPATH) || defined(__EMX__)) && !defined(WIN_EX)
    format(&cmdbuf, command, param);
#else	/* Unix or DOS/Win: */
#if defined(WIN_EX)
    if (*param != '\"' && strchr(param, ' ') != NULL) {
	char *cp = quote_pathname(param);
	format(&cmdbuf, command, cp);
	FREE(cp);
    } else {
	LYstrncpy(pram_string, param, sizeof(pram_string)-1);
	decode_string(pram_string);
	param = pram_string;

	if (strnicmp("mailto:", param, 7) == 0) {
	    format(&cmdbuf, command, param + 7);
	} else if (strnicmp("telnet://", param, 9) == 0) {
	    char host[sizeof(pram_string)];
	    int last_pos;

	    strcpy(host, param + 9);
	    last_pos = strlen(host) - 1;
	    if (last_pos > 1 && host[last_pos] == '/')
		host[last_pos] = '\0';

	    format(&cmdbuf, command, host);
	} else if (strnicmp("file://localhost/", param, 17) == 0) {
	    char e_buff[LY_MAXPATH], *p;

	    p = param + 17;
	    *e_buff = 0;
	    if (strchr(p, ':') == NULL) {
		sprintf(e_buff, "%.3s/", windows_drive);
	    }
	    strncat(e_buff, p, sizeof(e_buff) - strlen(e_buff) - 1);
	    p = strrchr(e_buff, '.');
	    if (p) {
		p = strchr(p, '#');
		if (p) {
		    *p = '\0';
		}
	    }
	    if (*e_buff != '\"' && strchr(e_buff, ' ') != NULL) {
		p = quote_pathname(e_buff);
		LYstrncpy(e_buff, p, sizeof(e_buff)-1);
		FREE(p);
	    }

	    /* Less ==> short filename,
	     * less ==> long filename
	     */
	    if (isupper(command[0])) {
		format(&cmdbuf,
			command, HTDOS_short_name(e_buff));
a40 14
		format(&cmdbuf, command, e_buff);
	    }
	} else {
	    format(&cmdbuf, command, param);
	}
    }
#else	/* Unix */
    {
	format(&cmdbuf, command, param);
    }
#endif
#endif	/* VMS */
    return cmdbuf;
}
d42 2
a43 105
/*
 * Find the EXTERNAL command which matches the given name 'param'.  If there is
 * more than one possibility, make a popup menu of the matching commands and
 * allow the user to select one.  Return the selected command.
 */
PRIVATE char *lookup_external ARGS2(
    char *, 	param,
    BOOL,	only_overriders)
{
    int pass, num_disabled, num_matched, num_choices, cur_choice;
    int length = 0;
    char *cmdbuf = NULL;
    char **choices = 0;
    lynx_list_item_type *ptr = 0;

    for (pass = 0; pass < 2; pass++) {
	num_disabled = 0;
	num_matched = 0;
	num_choices = 0;
	for (ptr = externals; ptr != 0; ptr = ptr->next) {

	    if (match_item_by_name(ptr, param, only_overriders)) {
		++num_matched;
		CTRACE((tfp, "EXTERNAL: '%s' <==> '%s'\n", ptr->name, param));
		if (no_externals && !ptr->always_enabled && !only_overriders) {
		    ++num_disabled;
		} else {
		    if (pass == 0) {
			length++;
		    } else if (pass != 0) {
			cmdbuf = format_command(ptr->command, param);
			if (length > 1)
			    choices[num_choices] = cmdbuf;
		    }
		    num_choices++;
		}
	    }
	}
	if (length > 1) {
	    if (pass == 0) {
		choices = typecallocn(char *, length + 1);
	    } else {
		choices[num_choices] = 0;
	    }
	}
    }

    if (num_disabled != 0
     && num_disabled == num_matched) {
	HTUserMsg(EXTERNALS_DISABLED);
    } else if (num_choices > 1) {
	int old_y, old_x;
#ifdef USE_SLANG
	old_y = SLsmg_get_row();
	old_x = SLsmg_get_column();
#else
	getyx(LYwin, old_y, old_x);
#endif
	cur_choice = LYhandlePopupList(
			-1,
			0,
			old_x,
			(CONST char **)choices,
			-1,
			-1,
			FALSE,
			TRUE,
			FALSE);
#ifdef USE_SLANG
	SLsmg_gotorc(old_y, old_x);
#else
	wmove(LYwin, old_y, old_x);
#endif
	CTRACE((tfp, "selected choice %d of %d\n", cur_choice, num_choices));
	if (cur_choice < 0) {
	    HTInfoMsg(CANCELLED);
	    cmdbuf = 0;
	}
	for (pass = 0; choices[pass] != 0; pass++) {
	    if (pass == cur_choice) {
		cmdbuf = choices[pass];
	    } else {
		FREE(choices[pass]);
	    }
	}
	FREE(choices);
    }
    return cmdbuf;
}

BOOL run_external ARGS2(
    char *, 	param,
    BOOL,	only_overriders)
{
#ifdef WIN_EX
    int status;
    extern int xsystem(char *cmd);
#endif
    int redraw_flag = TRUE;
    char *cmdbuf = NULL;
    BOOL found = FALSE;
    int confirmed = TRUE;

    if (externals == NULL)
	return 0;
d45 1
a45 12
#ifdef WIN_EX			/* 1998/01/26 (Mon) 09:16:13 */
    if (param == NULL) {
	HTInfoMsg("External command is null");
	return 0;
    }
#endif

    cmdbuf = lookup_external(param, only_overriders);
    if (cmdbuf != 0 && *cmdbuf != '\0') {
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
	int len;
	char buff[LY_MAXPATH];
a46 37
	CTRACE((tfp, "Lynx EXTERNAL: '%s'\n", cmdbuf));
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:15 */
	confirmed = MessageBox(GetForegroundWindow(), cmdbuf,
			       "Lynx (EXTERNAL COMMAND EXEC)",
			       MB_ICONQUESTION | MB_SETFOREGROUND | MB_OKCANCEL)
		    != IDCANCEL;
#else
	confirmed = HTConfirm(LYElideString(cmdbuf, 40)) != NO;
#endif
	if (confirmed) {
	    len = strlen(cmdbuf);
	    if (len > 255) {
		sprintf(buff, "Lynx: command line too long (%d > 255)", len);
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:02 */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_OK);
		SetConsoleTitle("Lynx for Win32");
#else
		HTConfirm(LYElideString(buff, 40));
#endif
		confirmed = FALSE;
	    } else {
		SetConsoleTitle(cmdbuf);
	    }
	}

	if (strnicmp(cmdbuf, "start ", 6) == 0)
	    redraw_flag = FALSE;
	else
	    redraw_flag = TRUE;
#else
	HTUserMsg(cmdbuf);
#endif
	found = TRUE;
	if (confirmed) {
	    if (redraw_flag) {
d48 3
a50 1
		fflush(stdout);
d53 1
a53 32
	    /* command running. */
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
#ifdef __CYGWIN__
	    status = system(cmdbuf);
#else
	    status = xsystem(cmdbuf);
#endif
	    if (status != 0) {
		sprintf(buff,
			"EXEC code = %04x (%2d, %2d)\r\n"
			"'%s'",
			status, (status / 256), (status & 0xff),
			cmdbuf);
#ifdef SH_EX	/* WIN_GUI for ERROR only */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONSTOP | MB_SETFOREGROUND | MB_OK);
#else
		HTConfirm(LYElideString(buff, 40));
#endif /* 1 */
	    }
#else	/* Not WIN_EX */
	    LYSystem(cmdbuf);
#endif	/* WIN_EX */

#if defined(WIN_EX)
	    SetConsoleTitle("Lynx for Win32");
#endif
	    if (redraw_flag) {
		fflush(stdout);
		start_curses();
	    }
d57 1
a57 2
    FREE(cmdbuf);
    return found;
d59 1
a59 1
#endif	/* USE_EXTERNALS */
@

