head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.7.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.7
	MIRBSD_XP_SPARC:1.7.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.1
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.1
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.1
	cvs-200401261630:1.1.1.1
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.1
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.1
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.1
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.1
	cvs-200309251530:1.1.1.1
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.1
	cvs-200308171200:1.1.1.1
	ctm-3496:1.1.1.1
	ctm-3449:1.1.1.1
	ctm-3437:1.1.1.1
	cvs-200307191805:1.1.1.1
	ctm-3425:1.1.1.1
	cvs-200307091500:1.1.1.1
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.1
	cvs-200306291430:1.1.1.1
	ctm-3341:1.1.1.1
	MIRBSD_5:1.1.1.1
	cvs-200306082100:1.1.1.1
	ctm-3316:1.1.1.1
	ctm-3272:1.1.1.1
	ctm-3264:1.1.1.1
	cvs-200305071630:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.46.06;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.11.20.30.43;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.23.05.43.55;	author tg;	state Stab;
branches;
next	1.6;

1.6
date	2004.07.15.18.17.06;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.38;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.33;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.40;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.36;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.05.07.17.30.30;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.05.07.17.30.30;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.48;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.25;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.44;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.16.10;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.54.51;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.16.06.52;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.26;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/*		Simple table object
 *		===================
 * Authors
 *	KW	Klaus Weide <kweide@@enteract.com>
 * History:
 *   2 Jul 1999	KW	Created.
 */

#include <HTUtils.h>
#include <HTStyle.h>		/* for HT_LEFT, HT_CENTER, HT_RIGHT */
#include <LYCurses.h>
#include <TRSTable.h>
#include <LYGlobalDefs.h>

#include <LYLeaks.h>

#ifdef SAVE_TIME_NOT_SPACE
#define CELLS_GROWBY 16
#define ROWS_GROWBY 16
#else
#define CELLS_GROWBY 2
#define ROWS_GROWBY 2
#endif

#ifdef USE_CURSES_PADS
#  define MAX_STBL_POS (LYwideLines ? MAX_COLS - 1 : LYcolLimit)
#else
#  define MAX_STBL_POS (LYcolLimit)
#endif

/* must be different from HT_ALIGN_NONE and HT_LEFT, HT_CENTER etc.: */
#define RESERVEDCELL (-2)	/* cell's alignment field is overloaded, this
				   value means cell was reserved by ROWSPAN */
#define EOCOLG (-2)		/* sumcols' Line field isn't used for line info, this
				   special value means end of COLGROUP */
#ifndef NO_AGGRESSIVE_NEWROW
#  define NO_AGGRESSIVE_NEWROW	0
#endif

typedef enum {
    CS_invalid = -1,		/* cell "before the first",
				   or empty lines after [ce]bc,
				   or TRST aborted */
    CS__new = 0,
    CS__0new,			/* new, at BOL */
    CS__0eb,			/* starts at BOL, empty, break */
    CS__eb,			/* empty, break */
    CS__0cb,			/* starts at BOL, content, break */
    CS__cb,			/* content, break */
    CS__0ef,			/* starts at BOL, empty, finished */
    CS__ef,			/* empty, finished */
    CS__0cf,			/* starts at BOL, content, finished */
    CS__cf,			/* content, finished */
    CS__ebc,			/* empty, break, more content (maybe @@BOL) */
    CS__cbc			/* content, break, more content (maybe @@BOL) */
} cellstate_t;

typedef struct _STable_states {
    cellstate_t prev_state;	/* Contents type of the previous cell */
    cellstate_t state;		/* Contents type of the worked-on cell */
    int lineno;			/* Start line of the current cell */
    int icell_core;		/* -1 or the 1st cell with <BR></TD> on row */
    int x_td;			/* x start pos of the current cell or -1 */
    int pending_len;		/* For multiline cells, the length of
				   the part on the first line (if
				   state is CS__0?[ec]b) (??), or 0 */
} STable_states;

typedef struct _STable_cellinfo {
    int cLine;			/* lineno in doc (zero-based): -1 for
				   contentless cells (and cells we do
				   not want to measure and count?),
				   line-of-the-start otherwise.  */
    int pos;			/* column where cell starts */
    int len;			/* number of character positions */
    int colspan;		/* number of columns to span */
    int alignment;		/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
				   or RESERVEDCELL */
} STable_cellinfo;

enum ended_state {
    ROW_not_ended,
    ROW_ended_by_endtr,
    ROW_ended_by_splitline
};

#define HAS_END_OF_CELL			1
#define HAS_BEG_OF_CELL			2
#define IS_CONTINUATION_OF_CELL		4
#define OFFSET_IS_VALID			8
#define OFFSET_IS_VALID_LAST_CELL	0x10
#define BELIEVE_OFFSET			0x20

typedef struct _STable_rowinfo {
    /* Each row may be displayed on many display lines, but we fix up
       positions of cells on this display line only: */
    int Line;			/* lineno in doc (zero-based) */
    int ncells;			/* number of table cells */

    /* What is the meaning of this?!  It is set if:
       [search for      def of fixed_line       below]

       a1) a non-last cell is not at BOL,
       a2) a non-last cell has something on the first line,
       b) a >=3-lines-cell not at BOL, the first row non-empty, the 2nd empty;
       c) a multiline cell not at BOL, the first row non-empty, the rest empty;
       d) a multiline cell not at BOL, the first row non-empty;
       e) a singleline non-empty cell not at BOL;

       Summary: have seen a cell which is one of:
       (Notation: B: at BOL; L: last; E: the first row is non-empty)

       bcde:    !B && !E
       a1:      !L && !B
       a2:      !L && !E

       Or: has at least two of !B, !L, !E, or: has at most one of B,L,E.

       REMARK: If this variable is not set, but icell_core is, Line is
       reset to the line of icell_core.
     */
    BOOL fixed_line;		/* if we have a 'core' line of cells */
    enum ended_state ended;	/* if we saw </tr> etc */
    int content;		/* Whether contains end-of-cell etc */
    int offset;			/* >=0 after line break in a multiline cell */
    int allocated;		/* number of table cells allocated */
    STable_cellinfo *cells;
    int alignment;		/* global align attribute for this row */
} STable_rowinfo;

struct _STable_info {
#ifdef EXP_NESTED_TABLES
    struct _STable_info *enclosing;	/* The table which contain us */
    struct _TextAnchor *enclosing_last_anchor_before_stbl;
#endif
    int startline;		/* lineno where table starts (zero-based) */
    int nrows;			/* number of rows */
    int ncols;			/* number of rows */
    int maxlen;			/* sum of max. cell lengths of any row */
    int maxpos;			/* max. of max. cell pos's of any row */
    int allocated_rows;		/* number of rows allocated */
    int allocated_sumcols;	/* number of sumcols allocated */
    int ncolinfo;		/* number of COL info collected */
    STable_cellinfo *sumcols;	/* for summary (max len/pos) col info */
    STable_rowinfo *rows;
    STable_rowinfo rowspans2eog;
    short alignment;		/* global align attribute for this table */
    short rowgroup_align;	/* align default for current group of rows */
    short pending_colgroup_align;
    int pending_colgroup_next;
    STable_states s;
};

/*
 *  Functions and structures in this source file keep track of positions.
 *  They don't know about the character data in those lines, or about
 *  the HText and HTLine structures.  GridText.c doesn't know about our
 *  structures.  It should stay that way.
 *
 *  The basic idea: we let the code in HTML.c/GridText.c produce and format
 *  output "as usual", i.e. as without Simple Table support.  We keep track
 *  of the positions in the generated output where cells and rows start (or
 *  end).  If all goes well, that preliminary output (stored in HText/HTLine
 *  structures) can be fixed up when the TABLE end tag is processed, by just
 *  inserting spaces in the right places (and possibly changing alignment).
 *  If all goes not well, we already have a safe fallback.
 *
 *  Note that positions passed to and from these functions should be
 *  in terms of screen positions, not just byte counts in a HTLine.data
 *  (cf. line->data vs. HText_TrueLineSize).
 *
 *  Memory is allocated dynamically, so we can have tables of arbitrary
 *  length.  On allocation error we just return and error indication
 *  instead of outofmem(), so caller can give up table tracking and maybe
 *  recover memory.
 *
 *  Implemented:
 *  - ALIGN={left,right,center,justify} applied to individual table cells
 *    ("justify" is treated as "left")
 *  - Inheritance of horizontal alignment according to HTML 4.0
 *  - COLSPAN >1 (may work incorrectly for some tables?)
 *  - ROWSPAN >1 (reserving cells in following rows)
 *  - Line breaks at start of first cell or at end of last cell are treated
 *    as if they were not part of the cell and row.  This allows us to
 *    cooperate with one way in which tables have been made friendly to
 *    browsers without any table support.
 *  Missing, but can be added:
 *  - Support for COLGROUP/COL
 *  - Tables wider than display.  The limitation is not here but in GridText.c
 *    etc.  If horizontal scrolling were implemented there, the mechanisms
 *    here coudl deal with wide tables (just change MAX_STBL_POS code).
 *  Missing, unlikely to add:
 *  - Support for non-LTR directionality.  A general problem, support is
 *    lacking throughout the lynx code.
 *  - Support for most other table-related attributes.  Most of them are
 *    for decorative purposes.
 *  Impossible or very unlikely (because it doesn't fit the model):
 *  - Any cell contents of more than one line, line breaks within cells.
 *    Anything that requires handling cell contents as paragraphs (block
 *    elements), like reflowing.  Vertical alignment.
 */
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
				int lineno,
				int pos);
static int Stbl_finishRowInTable(STable_info *me);

static const char *cellstate_s(cellstate_t state)
{
    const char *result = "?";
    /* *INDENT-OFF* */
    switch (state) {
    case CS_invalid:	result = "CS_invalid";	break;
    case CS__new:	result = "CS__new";	break;
    case CS__0new:	result = "CS__0new";	break;
    case CS__0eb:	result = "CS__0eb";	break;
    case CS__eb:	result = "CS__eb";	break;
    case CS__0cb:	result = "CS__0cb";	break;
    case CS__cb:	result = "CS__cb";	break;
    case CS__0ef:	result = "CS__0ef";	break;
    case CS__ef:	result = "CS__ef";	break;
    case CS__0cf:	result = "CS__0cf";	break;
    case CS__cf:	result = "CS__cf";	break;
    case CS__ebc:	result = "CS__ebc";	break;
    case CS__cbc:	result = "CS__cbc";	break;
    }
    /* *INDENT-ON* */

    return result;
}

struct _STable_info *Stbl_startTABLE(short alignment)
{
    STable_info *me = typecalloc(STable_info);

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_startTABLE(align=%d)\n", (int) alignment));
    if (me) {
	me->alignment = alignment;
	me->rowgroup_align = HT_ALIGN_NONE;
	me->pending_colgroup_align = HT_ALIGN_NONE;
	me->s.x_td = -1;
	me->s.icell_core = -1;
#ifdef EXP_NESTED_TABLES
	if (nested_tables)
	    me->enclosing = 0;
#endif
    }
    return me;
}

static void free_rowinfo(STable_rowinfo *me)
{
    if (me && me->allocated) {
	FREE(me->cells);
    }
}

void Stbl_free(STable_info *me)
{
    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_free()\n"));
    if (me && me->allocated_rows && me->rows) {
	int i;

	for (i = 0; i < me->allocated_rows; i++)
	    free_rowinfo(me->rows + i);
	FREE(me->rows);
    }
    free_rowinfo(&me->rowspans2eog);
    if (me)
	FREE(me->sumcols);
    FREE(me);
}

/*
 * Returns -1 on error, otherwise index of just-added table cell.
 */
static int Stbl_addCellToRow(STable_rowinfo *me, STable_cellinfo *colinfo, int ncolinfo,
			     STable_states *s,
			     int colspan,
			     int alignment,
			     int isheader,
			     int lineno,
			     int *ppos)
{
    STable_cellinfo *cells;
    int i;
    int last_colspan = me->ncells ?
    me->cells[me->ncells - 1].colspan : 1;
    cellstate_t newstate;
    int ret;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_addCellToRow, line=%d, pos=%d, colspan=%d\n",
	     lineno, *ppos, colspan));
    CTRACE2(TRACE_TRST,
	    (tfp,
	     " ncells=%d, stateLine=%d, pending_len=%d, pstate=%s, state=%s\n",
	     me->ncells, s->lineno, s->pending_len,
	     cellstate_s(s->prev_state), cellstate_s(s->state)));
    if (me->ncells == 0)
	s->prev_state = CS_invalid;
    else if (s->prev_state == CS_invalid ||
	     (s->state != CS__0new &&
	      s->state != CS__ef && s->state != CS__0ef))
	s->prev_state = s->state;

    if (me->ncells == 0 || *ppos == 0)
	newstate = CS__0new;
    else
	newstate = CS__new;

    if (me->ncells > 0 && s->pending_len > 0) {
	if (s->prev_state != CS__cbc)
	    me->cells[me->ncells - 1].len = s->pending_len;
	s->pending_len = 0;
    }
    s->x_td = *ppos;

    if (lineno != s->lineno) {
	if (!me->fixed_line) {
	    if (me->ncells == 0 || *ppos == 0) {
		switch (s->prev_state) {
		case CS_invalid:
		case CS__0new:
		case CS__0eb:
		case CS__0cb:
		case CS__0ef:
		case CS__0cf:
		    if (me->ncells > 0)
			for (i = me->ncells + last_colspan - 2;
			     i >= me->ncells - 1; i--) {
			    me->cells[i].pos = *ppos;
			    me->cells[i].cLine = lineno;
			}
		    me->Line = lineno;
		    break;
		case CS__new:
		case CS__eb:
		case CS__ef:
		case CS__cf:
		default:
		    break;
		case CS__cb:
		    *ppos = me->cells[me->ncells - 1].pos +
			me->cells[me->ncells - 1].len;
		}
	    } else {		/* last cell multiline, ncells != 0, pos != 0 */
		switch (s->prev_state) {
		case CS__0new:
		case CS__0eb:
		case CS__0ef:
		    /* Do not fail, but do not set fixed_line either */
		    break;
		case CS__cb:
		    goto trace_and_fail;
		case CS__cf:
		    goto trace_and_fail;
		case CS__0cb:
		case CS__0cf:
		    if (*ppos > me->cells[0].pos)
			me->Line = lineno;
		    me->fixed_line = YES;	/* type=a def of fixed_line i */
		    break;
		case CS__new:
		case CS__eb:
		case CS__ef:
		default:
		    me->fixed_line = YES;	/* type=e def of fixed_line ii */
		    break;
		case CS__cbc:
		    goto trace_and_fail;
		}
	    }
	}
	if (me->fixed_line && lineno != me->Line) {
	    switch (s->prev_state) {
	    case CS__cb:
	    case CS__cf:
		if (*ppos > 0)
		    goto trace_and_fail;
		else
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */  +
			me->cells[me->ncells - 1].len;
		break;
	    case CS__0cf:
	    case CS__0cb:
		if (*ppos == 0 || *ppos <= me->cells[0].pos)
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */  +
			me->cells[me->ncells - 1].len;
		break;
	    case CS__0new:
	    case CS__0ef:
	    case CS__0eb:
		break;
	    case CS__new:
	    case CS__eb:
	    case CS__ef:
	    default:
		*ppos = me->cells[me->ncells - 1].pos;
		break;
	    case CS__cbc:
		break;
	    case CS_invalid:
		break;
	    }
	}
	s->lineno = lineno;
    } else {			/* lineno == s->lineno: */
	switch (s->prev_state) {
	case CS_invalid:
	case CS__0new:
	case CS__0eb:		/* cannot happen */
	case CS__0cb:		/* cannot happen */
	case CS__0ef:
	case CS__0cf:		/* ##302?? set icell_core? or only in finish? */
	    break;
	case CS__eb:		/* cannot happen */
	case CS__cb:		/* cannot happen */
	case CS__ef:
	    break;
	case CS__ebc:		/* should have done smth in finish */
	case CS__cbc:		/* should have done smth in finish */
	    break;
	case CS__new:
	case CS__cf:
	    if (me->fixed_line && me->Line != lineno) {
		goto trace_and_fail;
	    } else {
		me->fixed_line = YES;
		me->Line = lineno;
	    }
	}
    }

    s->state = newstate;

    if (me->ncells > 0 && me->cells[me->ncells - 1].colspan > 1) {
	me->ncells += me->cells[me->ncells - 1].colspan - 1;
    }
    while (me->ncells < me->allocated &&
	   me->cells[me->ncells].alignment == RESERVEDCELL) {
	me->ncells++;
    }
    {
	int growby = 0;

	while (me->ncells + colspan + 1 > me->allocated + growby)
	    growby += CELLS_GROWBY;
	if (growby) {
	    if (me->allocated == 0 && !me->cells) {
		cells = typecallocn(STable_cellinfo, growby);
	    } else {
		cells = typeRealloc(STable_cellinfo, me->cells,
				      (me->allocated + growby));

		for (i = 0; cells && i < growby; i++) {
		    cells[me->allocated + i].alignment = HT_ALIGN_NONE;
		}
	    }
	    if (cells) {
		me->allocated += growby;
		me->cells = cells;
	    } else {
		goto trace_and_fail;
	    }
	}
    }

    me->cells[me->ncells].cLine = lineno;
    me->cells[me->ncells].pos = *ppos;
    me->cells[me->ncells].len = -1;
    me->cells[me->ncells].colspan = colspan;

    if (alignment != HT_ALIGN_NONE)
	me->cells[me->ncells].alignment = alignment;
    else {
	if (ncolinfo >= me->ncells + 1)
	    me->cells[me->ncells].alignment = colinfo[me->ncells].alignment;
	else
	    me->cells[me->ncells].alignment = me->alignment;
	if (me->cells[me->ncells].alignment == HT_ALIGN_NONE)
	    me->cells[me->ncells].alignment = me->alignment;
	if (me->cells[me->ncells].alignment == HT_ALIGN_NONE)
	    me->cells[me->ncells].alignment = isheader ? HT_CENTER : HT_LEFT;
    }
    for (i = me->ncells + 1; i < me->ncells + colspan; i++) {
	me->cells[i].cLine = lineno;
	me->cells[i].pos = *ppos;
	me->cells[i].len = -1;
	me->cells[i].colspan = 0;
	me->cells[i].alignment = HT_LEFT;
    }
    me->cells[me->ncells + colspan].pos = -1;	/* not yet used */
    me->ncells++;

    ret = me->ncells - 1;
  trace_and_return:
    CTRACE2(TRACE_TRST,
	    (tfp, " => prev_state=%s, state=%s, ret=%d\n",
	     cellstate_s(s->prev_state), cellstate_s(s->state), ret));
    return (ret);

  trace_and_fail:
    ret = -1;
    goto trace_and_return;
}

/* returns -1 on error, 0 otherwise */
/* assumes cells have already been allocated (but may need more) */
static int Stbl_reserveCellsInRow(STable_rowinfo *me, int icell,
				  int colspan)
{
    STable_cellinfo *cells;
    int i;
    int growby = icell + colspan - me->allocated;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_reserveCellsInRow(icell=%d, colspan=%d\n",
	     icell, colspan));
    if (growby > 0) {
	cells = typeRealloc(STable_cellinfo, me->cells,
			      (me->allocated + growby));

	if (cells) {
	    for (i = 0; i < growby; i++) {
		cells[me->allocated + i].alignment = HT_ALIGN_NONE;
	    }
	    me->allocated += growby;
	    me->cells = cells;
	} else {
	    return -1;
	}
    }
    for (i = icell; i < icell + colspan; i++) {
	me->cells[i].cLine = -1;
	me->cells[i].pos = -1;
	me->cells[i].len = -1;
	me->cells[i].colspan = 0;
	me->cells[i].alignment = RESERVEDCELL;
    }
    me->cells[icell].colspan = colspan;
    return 0;
}

/* Returns -1 on failure. */
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
				int lineno,
				int pos)
{
    STable_cellinfo *lastcell;
    cellstate_t newstate = CS_invalid;
    int multiline = NO, empty;
    int ret;

    CTRACE2(TRACE_TRST,
	    (tfp,
	     "TRST:Stbl_finishCellInRow line=%d pos=%d end_td=%d ncells=%d pnd_len=%d\n",
	     lineno, pos, (int) end_td, me->ncells, s->pending_len));

    if (me->ncells <= 0)
	return -1;
    lastcell = me->cells + (me->ncells - 1);
    multiline = (lineno != lastcell->cLine || lineno != s->lineno);
    empty = multiline ? (pos == 0) : (pos <= s->x_td);

    CTRACE2(TRACE_TRST,
	    (tfp,
	     " [lines: lastCell=%d state=%d multi=%d] empty=%d (prev)state=(%s) %s\n",
	     lastcell->cLine, s->lineno, multiline, empty,
	     cellstate_s(s->prev_state), cellstate_s(s->state)));

    if (multiline) {
	if ((end_td & TRST_ENDCELL_MASK) == TRST_ENDCELL_LINEBREAK) {
	    switch (s->state) {
	    case CS_invalid:
		newstate = empty ? CS_invalid : CS__cbc;
		break;
	    case CS__0new:
		newstate = empty ? CS__0eb : CS__0cb;
		break;
	    case CS__0eb:
		newstate = empty ? CS__0eb : CS__ebc;
		s->state = newstate;
		if (me->fixed_line) {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : -1);
		} else {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : 0);
		}
		goto trace_and_return;
	    case CS__0cb:
		if (!me->fixed_line) {
		    if (!empty) {
			if (s->icell_core == -1)
			    me->Line = -1;
		    }
		}
		if (s->pending_len && empty) {	/* First line non-empty */
		    if ((me->fixed_line && me->Line == lastcell->cLine) ||
			s->icell_core == me->ncells - 1)
			lastcell->len = s->pending_len;
		    s->pending_len = 0;
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cb : CS__cbc;	/* ##474_needs_len!=-1? */
		break;
	    case CS__0ef:
	    case CS__0cf:
		break;
	    case CS__new:
		newstate = empty ? CS__eb : CS__cb;
		break;
	    case CS__eb:	/* ##484_set_pending_ret_0_if_empty? */
		newstate = empty ? CS__eb : CS__ebc;
		s->state = newstate;
		if (me->fixed_line) {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : -1);
		} else {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : -1);
		}
		goto trace_and_return;
	    case CS__cb:
		if (s->pending_len && empty) {	/* ##496: */
		    lastcell->len = s->pending_len;
		    s->pending_len = 0;
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		ret = -1;
		if (empty) {
		    if (!me->fixed_line) {
			me->fixed_line = YES;	/* type=b def of fixed_line i */
			me->Line = lastcell->cLine;	/* should've happened in break */
		    } else {
			if (me->Line != lastcell->cLine)
			    goto trace_and_return;
		    }
		} else {
		    if (!me->fixed_line) {
			me->fixed_line = YES;	/* type=b def of fixed_line ii */
			me->Line = lastcell->cLine;	/* should've happened in break */
		    }
		    s->state = CS__cbc;
		    goto trace_and_return;
		}
		newstate = empty ? CS__cb : CS__cbc;
		break;
	    case CS__ef:
		ret = 0;
		goto trace_and_return;
	    case CS__cf:
		ret = lastcell->len;	/* ##523_change_state? */
		goto trace_and_return;
	    case CS__cbc:
		if (!me->fixed_line) {
		    if (empty) {
			if (s->icell_core == -1)	/* ##528??: */
			    me->Line = lineno;
			/* lastcell->Line = lineno; */
		    } else {	/* !empty */
			if (s->icell_core == -1)
			    me->Line = -1;
		    }
		}
		s->pending_len = 0;
		newstate = empty ? CS_invalid : CS__cbc;
		break;
	    default:
		break;
	    }
	} else {		/* multiline cell, processing </TD>: */
	    s->x_td = -1;
	    switch (s->state) {
	    case CS_invalid:
		/* ##540_return_-1_for_invalid_if_len!: */
		if (!empty && lastcell->len > 0) {
		    newstate = CS__0cf;
		    s->state = newstate;
		    ret = -1;
		    goto trace_and_return;
		}
		/* ##541_set_len_0_Line_-1_sometimes: */
		lastcell->len = 0;
		lastcell->cLine = -1;
		/* fall thru ##546 really fall thru??: */
		newstate = empty ? CS_invalid : CS__cbc;
		break;
	    case CS__0new:
		newstate = empty ? CS__0ef : CS__0cf;
		break;
	    case CS__0eb:
		newstate = empty ? CS__0ef : CS__0cf;	/* ebc?? */
		s->state = newstate;
		if (me->fixed_line) {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : -1);
		} else {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : 0);
		}
		goto trace_and_return;
	    case CS__0cb:
		if (s->pending_len) {
		    if (empty)
			lastcell->len = s->pending_len;
		    else
			lastcell->len = 0;
		    s->pending_len = 0;
		}
		if (!me->fixed_line) {
		    if (empty) {
			if (s->icell_core == -1)
			    /* first cell before <BR></TD> => the core cell */
			    s->icell_core = me->ncells - 1;
			/* lastcell->cLine = lineno; */
		    } else {	/* !empty */
			if (s->icell_core == -1)
			    me->Line = -1;
		    }
		}
		if (s->pending_len && empty) {
		    lastcell->len = s->pending_len;
		    s->pending_len = 0;
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cf : CS__cbc;
		break;
	    case CS__0ef:
		newstate = CS__0ef;
		/* FALLTHRU */
	    case CS__0cf:
		break;
	    case CS__new:
		newstate = empty ? CS__ef : CS__cf;
		break;
	    case CS__eb:
		newstate = empty ? CS__ef : CS__ef;	/* ##579??? !!!!! */
		s->state = newstate;
		if (me->fixed_line) {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : -1);
		} else {
		    if (empty)
			ret = (lastcell->len <= 0 ? 0 : lastcell->len);
		    else
			ret = (lastcell->len <= 0 ? 0 : -1);
		}
		goto trace_and_return;
	    case CS__cb:
		if (s->pending_len && empty) {
		    lastcell->len = s->pending_len;
		    s->pending_len = 0;
		}
		ret = -1;
		if (empty) {
		    if (!me->fixed_line) {
			me->fixed_line = YES;	/* type=c def of fixed_line */
			me->Line = lastcell->cLine;	/* should've happened in break */
		    } else {
			if (me->Line != lastcell->cLine)
			    goto trace_and_return;
		    }
		} else {
		    goto trace_and_return;
		}
		newstate = empty ? CS__cf : CS__cbc;
		break;
	    case CS__ef:	/* ignored error */
	    case CS__cf:	/* ignored error */
		break;
	    case CS__ebc:	/* ##540_handle_ebc: */
		lastcell->len = 0;
		if (!me->fixed_line) {
		    if (!empty) {
			if (s->icell_core == -1)
			    lastcell->cLine = -1;
		    }
		}
		s->pending_len = 0;
		newstate = empty ? CS_invalid : CS__cbc;
		break;
	    case CS__cbc:	/* ##586 */
		lastcell->len = 0;	/* ##613 */
		ret = -1;
		if (me->fixed_line && me->Line == lastcell->cLine)
		    goto trace_and_return;
		if (!me->fixed_line) {
		    if (empty) {
			if (s->icell_core == -1)
			    me->Line = lineno;
		    }
		}
		s->pending_len = 0;	/* ##629 v */
		newstate = empty ? CS_invalid : CS__cbc;
		break;
	    }
	}
    } else {			/* (!multiline) */
	if ((end_td & TRST_ENDCELL_MASK) == TRST_ENDCELL_LINEBREAK) {
	    switch (s->state) {
	    case CS_invalid:
	    case CS__0new:
		s->pending_len = empty ? 0 : pos - lastcell->pos;
		newstate = empty ? CS__0eb : CS__0cb;
		s->state = newstate;
		ret = 0;	/* or 0 for xlen to s->pending_len?? */
		goto trace_and_return;
	    case CS__0eb:	/* cannot happen */
		newstate = CS__eb;
		break;
	    case CS__0cb:	/* cannot happen */
		newstate = CS__cb;
		break;
	    case CS__0ef:
	    case CS__0cf:
		break;
	    case CS__new:
		ret = -1;
		if (!empty && s->prev_state == CS__cbc)		/* ##609: */
		    goto trace_and_return;
		if (!empty) {
		    if (!me->fixed_line) {
			me->fixed_line = YES;	/* type=d def of fixed_line */
			me->Line = lineno;
		    } else {
			if (me->Line != lineno)
			    goto trace_and_return;
		    }
		}
		newstate = empty ? CS__eb : CS__cb;
		s->state = newstate;
		if (!me->fixed_line) {
		    s->pending_len = empty ? 0 : pos - lastcell->pos;
		    ret = 0;
		    goto trace_and_return;
		} else {
		    s->pending_len = 0;
		    lastcell->len = empty ? 0 : pos - lastcell->pos;
		    ret = lastcell->len;
		    goto trace_and_return;
		}
	    case CS__eb:	/* cannot happen */
		newstate = empty ? CS__eb : CS__ebc;
		break;
	    case CS__cb:	/* cannot happen */
		newstate = empty ? CS__cb : CS__cbc;
		break;
	    case CS__ef:
		ret = 0;
		goto trace_and_return;
	    case CS__cf:
		ret = lastcell->len;
		goto trace_and_return;
	    case CS__cbc:	/* ??? */
		break;
	    default:
		break;
	    }
	} else {		/* !multiline, processing </TD>: */
	    s->x_td = -1;
	    switch (s->state) {
	    case CS_invalid:	/* ##691_no_lastcell_len_for_invalid: */
		if (!(me->fixed_line && me->Line == lastcell->cLine))
		    lastcell->len = 0;
		/* FALLTHRU */
	    case CS__0new:
		newstate = empty ? CS__0ef : CS__0cf;
		break;		/* ##630 */
	    case CS__0eb:
		newstate = empty ? CS__0ef : CS__0ef;
		break;		/* ??? */
	    case CS__0cb:
		newstate = empty ? CS__0cf : CS__cbc;
		break;		/* ??? */
	    case CS__0ef:
		newstate = CS__0ef;
		break;		/* ??? */
	    case CS__0cf:
		break;		/* ??? */
	    case CS__new:
		ret = -1;
		if (!empty && s->prev_state == CS__cbc)
		    goto trace_and_return;
		if (!empty) {	/* ##642_set_fixed!: */
		    if (!me->fixed_line) {
			me->fixed_line = YES;	/* type=e def of fixed_line */
			me->Line = lineno;
		    } else {
			if (me->Line != lineno)
			    goto trace_and_return;
		    }
		}
		if (lastcell->len < 0)
		    lastcell->len = empty ? 0 : pos - lastcell->pos;
		newstate = empty ? CS__ef : CS__cf;
		s->state = newstate;
		ret = ((me->fixed_line && lineno != me->Line)
		       ? -1 : lastcell->len);
		goto trace_and_return;
	    case CS__eb:
		newstate = empty ? CS__ef : CS__cf;
		break;		/* ??? */
	    case CS__cb:
		newstate = empty ? CS__cf : CS__cf;
		break;		/* ??? */
	    case CS__ef:	/* ignored error */
	    case CS__cf:	/* ignored error */
	    default:
		break;
	    }
	    lastcell->len = pos - lastcell->pos;
	}			/* if (!end_td) ... else */
    }				/* if (multiline) ... else */

    s->state = newstate;
    ret = lastcell->len;
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (ret == -1 && pos == 0)
	    ret = 0;		/* XXXX Hack to allow trailing <P> in multiline cells. */
    }
#endif

/*    lastcell->len = pos - lastcell->pos; */
  trace_and_return:
    CTRACE2(TRACE_TRST,
	    (tfp, " => prev_state=%s, state=%s, return=%d\n",
	     cellstate_s(s->prev_state), cellstate_s(s->state), ret));
    return ret;
}

/*
 * Reserve cells, each of given colspan, in (rowspan-1) rows after the current
 * row of rowspan>1.  If rowspan==0, use special 'row' rowspans2eog to keep
 * track of rowspans that are to remain in effect until the end of the row
 * group (until next THEAD/TFOOT/TBODY) or table.
 */
static int Stbl_reserveCellsInTable(STable_info *me, int icell,
				    int colspan,
				    int rowspan)
{
    STable_rowinfo *rows, *row;
    int growby;
    int i;

    if (me->nrows <= 0)
	return -1;		/* must already have at least one row */

    CTRACE2(TRACE_TRST,
	    (tfp,
	     "TRST:Stbl_reserveCellsInTable(icell=%d, colspan=%d, rowspan=%d)\n",
	     icell, colspan, rowspan));
    if (rowspan == 0) {
	if (!me->rowspans2eog.cells) {
	    me->rowspans2eog.cells = typecallocn(STable_cellinfo, icell + colspan);

	    if (!me->rowspans2eog.cells)
		return 0;	/* fail silently */
	    else
		me->rowspans2eog.allocated = icell + colspan;
	}
	Stbl_reserveCellsInRow(&me->rowspans2eog, icell, colspan);
    }

    growby = me->nrows + rowspan - 1 - me->allocated_rows;
    if (growby > 0) {
	rows = typeRealloc(STable_rowinfo, me->rows,
			     (me->allocated_rows + growby));

	if (!rows)
	    return 0;		/* ignore silently, no free memory, may be recoverable */
	for (i = 0; i < growby; i++) {
	    row = rows + me->allocated_rows + i;
	    row->allocated = 0;
	    row->offset = 0;
	    row->content = 0;
	    if (!me->rowspans2eog.allocated) {
		row->cells = NULL;
	    } else {
		row->cells = typecallocn(STable_cellinfo,
					 me->rowspans2eog.allocated);

		if (row->cells) {
		    row->allocated = me->rowspans2eog.allocated;
		    memcpy(row->cells, me->rowspans2eog.cells,
			   row->allocated * sizeof(STable_cellinfo));
		}
	    }
	    row->ncells = 0;
	    row->fixed_line = NO;
	    row->alignment = HT_ALIGN_NONE;
	}
	me->allocated_rows += growby;
	me->rows = rows;
    }
    for (i = me->nrows;
	 i < (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
	 i++) {
	if (!me->rows[i].allocated) {
	    me->rows[i].cells = typecallocn(STable_cellinfo, icell + colspan);

	    if (!me->rows[i].cells)
		return 0;	/* fail silently */
	    else
		me->rows[i].allocated = icell + colspan;
	}
	Stbl_reserveCellsInRow(me->rows + i, icell, colspan);
    }
    return 0;
}

/* Remove reserved cells in trailing rows that were added for rowspan,
 * to be used when a THEAD/TFOOT/TBODY ends. */
static void Stbl_cancelRowSpans(STable_info *me)
{
    int i;

    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_cancelRowSpans()"));
    for (i = me->nrows; i < me->allocated_rows; i++) {
	if (!me->rows[i].ncells) {	/* should always be the case */
	    FREE(me->rows[i].cells);
	    me->rows[i].allocated = 0;
	}
    }
    free_rowinfo(&me->rowspans2eog);
    me->rowspans2eog.allocated = 0;
}

/*
 * Returns -1 on error, otherwise index of just-added table row.
 */
int Stbl_addRowToTable(STable_info *me, int alignment,
		       int lineno)
{
    STable_rowinfo *rows, *row;
    STable_states *s = &me->s;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_addRowToTable(alignment=%d, lineno=%d)\n",
	     alignment, lineno));
    if (me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0) {
	if (s->pending_len > 0)
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len =
		s->pending_len;
	s->pending_len = 0;
    }
    Stbl_finishRowInTable(me);
    if (me->nrows > 0 && me->rows[me->nrows - 1].Line == lineno)
	me->rows[me->nrows - 1].Line = -1;
    s->pending_len = 0;
    s->x_td = -1;

    {
	int i;
	int growby = 0;

	while (me->nrows + 2 > me->allocated_rows + growby)
	    growby += ROWS_GROWBY;
	if (growby) {
	    if (me->allocated_rows == 0 && !me->rows) {
		rows = typecallocn(STable_rowinfo, growby);
	    } else {
		rows = typeRealloc(STable_rowinfo, me->rows,
				     (me->allocated_rows + growby));

		for (i = 0; rows && i < growby; i++) {
		    row = rows + me->allocated_rows + i;
		    if (!me->rowspans2eog.allocated) {
			row->allocated = 0;
			row->cells = NULL;
		    } else {
			row->cells = typecallocn(STable_cellinfo,
						 me->rowspans2eog.allocated);

			if (row->cells) {
			    row->allocated = me->rowspans2eog.allocated;
			    memcpy(row->cells, me->rowspans2eog.cells,
				   row->allocated * sizeof(STable_cellinfo));
			} else {
			    FREE(rows);
			    break;
			}
		    }
		    row->ncells = 0;
		    row->fixed_line = NO;
		    row->alignment = HT_ALIGN_NONE;
		    row->offset = 0;
		    row->content = 0;
		}
	    }
	    if (rows) {
		me->allocated_rows += growby;
		me->rows = rows;
	    } else {
		return -1;
	    }
	}
    }

    me->rows[me->nrows].Line = lineno;
    if (me->nrows == 0)
	me->startline = lineno;
    if (alignment != HT_ALIGN_NONE)
	me->rows[me->nrows].alignment = alignment;
    else
	me->rows[me->nrows].alignment =
	    (me->rowgroup_align == HT_ALIGN_NONE) ?
	    me->alignment : me->rowgroup_align;
    me->nrows++;
    if (me->pending_colgroup_next > me->ncolinfo) {
	me->ncolinfo = me->pending_colgroup_next;
	me->pending_colgroup_next = 0;
    }
    me->rows[me->nrows].Line = -1;	/* not yet used */
    me->rows[me->nrows].ended = ROW_not_ended;	/* No </tr> yet */
    return (me->nrows - 1);
}

/*
 * Returns -1 on error, otherwise current number of rows.
 */
static int Stbl_finishRowInTable(STable_info *me)
{
    STable_rowinfo *lastrow;
    STable_states *s = &me->s;
    int ncells;

    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishRowInTable()\n"));
    if (!me->rows || !me->nrows)
	return -1;		/* no row started! */
    lastrow = me->rows + (me->nrows - 1);
    ncells = lastrow->ncells;
    lastrow->ended = ROW_ended_by_endtr;
    if (lastrow->ncells > 0) {
	if (s->pending_len > 0)
	    lastrow->cells[lastrow->ncells - 1].len = s->pending_len;
	s->pending_len = 0;
    }
    s->prev_state = s->state = CS_invalid;
    s->lineno = -1;

    if (s->icell_core >= 0 && !lastrow->fixed_line &&
	lastrow->cells[s->icell_core].cLine >= 0)
	lastrow->Line = lastrow->cells[s->icell_core].cLine;
    s->icell_core = -1;
    return (me->nrows);
}

static void update_sumcols0(STable_cellinfo *sumcols,
			    STable_rowinfo *lastrow,
			    int pos,
			    int len,
			    int icell,
			    int ispan,
			    int allocated_sumcols)
{
    int i;

    if (len > 0) {
	int sumpos = pos;
	int prevsumpos = sumcols[icell + ispan].pos;
	int advance;

	if (ispan > 0) {
	    if (lastrow->cells[icell].pos + len > sumpos)
		sumpos = lastrow->cells[icell].pos + len;
	    if (sumcols[icell + ispan - 1].pos +
		sumcols[icell + ispan - 1].len >
		sumpos)
		sumpos = sumcols[icell + ispan - 1].pos +
		    sumcols[icell + ispan - 1].len;
	}
	advance = sumpos - prevsumpos;
	if (advance > 0) {
	    for (i = icell + ispan; i < allocated_sumcols; i++) {
		if (ispan > 0 && sumcols[i].colspan < -1) {
		    if (i + sumcols[i].colspan < icell + ispan) {
			advance = sumpos - sumcols[i].pos;
			if (i > 0)
			    advance = HTMAX(advance,
					    sumcols[i - 1].pos +
					    sumcols[i - 1].len
					    - (sumcols[i].pos));
			if (advance <= 0)
			    break;
		    }
		}
		if (sumcols[i].pos >= 0)
		    sumcols[i].pos += advance;
		else {
		    sumcols[i].pos = sumpos;
		    break;
		}
	    }
	}
    }
}

static int get_remaining_colspan(STable_rowinfo *me,
				 STable_cellinfo *colinfo,
				 int ncolinfo,
				 int colspan,
				 int ncols_sofar)
{
    int i;
    int last_colspan = me->ncells ?
    me->cells[me->ncells - 1].colspan : 1;

    if (ncolinfo == 0 || me->ncells + last_colspan > ncolinfo) {
	colspan = HTMAX(TRST_MAXCOLSPAN,
			ncols_sofar - (me->ncells + last_colspan - 1));
    } else {
	for (i = me->ncells + last_colspan - 1; i < ncolinfo - 1; i++)
	    if (colinfo[i].cLine == EOCOLG)
		break;
	colspan = i - (me->ncells + last_colspan - 2);
    }
    return colspan;
}

#ifdef EXP_NESTED_TABLES
/* Returns -1 on failure, 1 if faking was performed, 0 if not needed. */
static int Stbl_fakeFinishCellInTable(STable_info *me,
				      STable_rowinfo *lastrow,
				      int lineno,
				      int finishing)	/* Processing finish or start */
{
    STable_states *s = &me->s;
    int fake = 0;

    switch (s->state) {		/* We care only about trailing <BR> */
    case CS_invalid:
    case CS__0new:
    case CS__0ef:
    case CS__0cf:
    case CS__new:
    case CS__cbc:
    case CS__ef:
    case CS__cf:
    default:
	/* <BR></TD> may produce these (XXXX instead of CS__cbf?).  But if
	   finishing==0, the caller already checked that we are on a
	   different line.  */
	if (finishing == 0)
	    fake = 1;
	break;			/* Either can't happen, or may be ignored */
    case CS__eb:
    case CS__0eb:
    case CS__0cb:
    case CS__cb:
	fake = 1;
	break;
    }
    if (fake) {
	/* The previous action we did was putting a linebreak.  Now we
	   want to put another one.  Fake necessary
	   </TD></TR><TR><TD></TD><TD> (and possibly </TD>) instead. */
	int ncells = lastrow->ncells;
	int i;
	int al = lastrow->alignment;
	int cs = lastrow->cells[lastrow->ncells - 1].colspan;
	int rs = 1;		/* XXXX How to find rowspan? */
	int ih = 0;		/* XXXX How to find is_header? */
	int end_td = (TRST_ENDCELL_ENDTD | TRST_FAKING_CELLS);
	int need_reserved = 0;
	int prev_reserved_last = -1;
	STable_rowinfo *prev_row;
	int prev_row_n2 = lastrow - me->rows;

	CTRACE2(TRACE_TRST,
		(tfp,
		 "TRST:Stbl_fakeFinishCellInTable(lineno=%d, finishing=%d) START FAKING\n",
		 lineno, finishing));

	/* Although here we use pos=0, this may commit the previous
	   cell which had <BR> as a last element.  This may overflow
	   the screen width, so the additional checks performed in
	   Stbl_finishCellInTable (comparing to Stbl_finishCellInRow)
	   are needed. */
	if (finishing) {
	    /* Fake </TD> at BOL */
	    if (Stbl_finishCellInTable(me, end_td, lineno, 0, 0) < 0) {
		return -1;
	    }
	}

	/* Fake </TR> at BOL */
/* Stbl_finishCellInTable(lineno, 0, 0); *//* Needed? */

	/* Fake <TR> at BOL */
	if (Stbl_addRowToTable(me, al, lineno) < 0) {
	    return -1;
	}
	lastrow = me->rows + (me->nrows - 1);
	lastrow->content = IS_CONTINUATION_OF_CELL;
	for (i = 0; i < lastrow->allocated; i++) {
	    if (lastrow->cells[i].alignment == RESERVEDCELL) {
		need_reserved = 1;
		break;
	    }
	}

	prev_row = me->rows + prev_row_n2;
	for (i = ncells; i < prev_row->allocated; i++) {
	    if (prev_row->cells[i].alignment == RESERVEDCELL)
		prev_reserved_last = i;
	}
	if (need_reserved || prev_reserved_last >= 0) {
	    /* Oups, we are going to stomp over a line which somebody
	       cares about already, or the previous line had reserved
	       cells which were not skipped over.

	       Remember that STable_rowinfo is about logical (TR)
	       table lines, not displayed lines.  We need to duplicate
	       the reservation structure when we fake new logical lines.  */
	    int prev_row_n = prev_row - me->rows;
	    STable_rowinfo *rows = typeRealloc(STable_rowinfo, me->rows,
					       (me->allocated_rows + 1));
	    int need_cells = prev_reserved_last + 1;
	    int n;

	    if (!rows)
		return -1;	/* ignore silently, no free memory, may be recoverable */

	    CTRACE2(TRACE_TRST,
		    (tfp, "TRST:Stbl_fakeFinishCellInTable REALLOC ROWSPAN\n"));
	    me->rows = rows;
	    lastrow = me->rows + (me->nrows - 1);
	    prev_row = me->rows + prev_row_n;
	    me->allocated_rows++;

	    /* Insert a duplicate row after lastrow */
	    for (n = me->allocated_rows - me->nrows - 1; n >= 0; --n)
		lastrow[n + 1] = lastrow[n];

	    /* Ignore cells, they belong to the next row now */
	    lastrow->allocated = 0;
	    lastrow->cells = 0;
	    if (need_cells) {
		lastrow->cells = typecallocn(STable_cellinfo, need_cells);

		/* ignore silently, no free memory, may be recoverable */
		if (!lastrow->cells) {
		    return -1;
		}
		lastrow->allocated = need_cells;
		memcpy(lastrow->cells, prev_row->cells,
		       lastrow->allocated * sizeof(STable_cellinfo));

		i = -1;
		while (++i < ncells) {
		    /* Stbl_addCellToTable grants RESERVEDCELL, but we do not
		       want this action for fake cells.
		       XXX Maybe always fake RESERVEDCELL instead of explicitly
		       creating/destroying cells?  */
		    if (lastrow->cells[i].alignment == RESERVEDCELL)
			lastrow->cells[i].alignment = HT_LEFT;
		}
	    }
	}

	/* Fake <TD></TD>...<TD> (and maybe a </TD>) at BOL. */
	CTRACE2(TRACE_TRST,
		(tfp, "TRST:Stbl_fakeFinishCellInTable FAKE %d elts%s\n",
		 ncells, (finishing ? ", last unfinished" : "")));
	i = 0;
	while (++i <= ncells) {
	    /* XXXX A lot of args may be wrong... */
	    if (Stbl_addCellToTable(me, (i == ncells ? cs : 1), rs, al,
				    ih, lineno, 0, 0) < 0) {
		return -1;
	    }
	    lastrow->content &= ~HAS_BEG_OF_CELL;	/* BEG_OF_CELL was fake */
	    /* We cannot run out of width here, so it is safe to not
	       call Stbl_finishCellInTable(), but Stbl_finishCellInRow. */
	    if (!finishing || (i != ncells)) {
		if (Stbl_finishCellInRow(lastrow, s, end_td, lineno, 0) < 0) {
		    return -1;
		}
	    }
	}
	CTRACE2(TRACE_TRST,
		(tfp,
		 "TRST:Stbl_fakeFinishCellInTable(lineno=%d) FINISH FAKING\n",
		 lineno));
	return 1;
    }
    return 0;
}
#endif

/*
 * Returns -1 on error, otherwise 0.
 */
int Stbl_addCellToTable(STable_info *me, int colspan,
			int rowspan,
			int alignment,
			int isheader,
			int lineno,
			int offset_not_used_yet GCC_UNUSED,
			int pos)
{
    STable_states *s = &me->s;
    STable_rowinfo *lastrow;
    STable_cellinfo *sumcols, *sumcol;
    int i, icell, ncells, sumpos;

    CTRACE2(TRACE_TRST,
	    (tfp,
	     "TRST:Stbl_addCellToTable(lineno=%d, pos=%d, isheader=%d, cs=%d, rs=%d, al=%d)\n",
	     lineno, pos, (int) isheader, colspan, rowspan, alignment));
    if (!me->rows || !me->nrows)
	return -1;		/* no row started! */
    /* ##850_fail_if_fail?? */
    if (me->rows[me->nrows - 1].ended != ROW_not_ended)
	Stbl_addRowToTable(me, alignment, lineno);
    Stbl_finishCellInTable(me, TRST_ENDCELL_ENDTD, lineno, 0, pos);
    lastrow = me->rows + (me->nrows - 1);

#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	/* If the last cell was finished by <BR></TD>, we need to fake an
	   appropriate amount of cells */
	if (!NO_AGGRESSIVE_NEWROW && pos == 0 && lastrow->ncells > 0
	    && lastrow->cells[lastrow->ncells - 1].cLine != lineno) {
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 0);

	    if (rc < 0)
		return -1;
	    if (rc)
		lastrow = me->rows + (me->nrows - 1);
	}
    }
#endif
    if (colspan == 0) {
	colspan = get_remaining_colspan(lastrow, me->sumcols, me->ncolinfo,
					colspan, me->ncols);
    }
    ncells = lastrow->ncells;	/* remember what it was before adding cell. */
    icell = Stbl_addCellToRow(lastrow, me->sumcols, me->ncolinfo, s,
			      colspan, alignment, isheader,
			      lineno, &pos);
    if (icell < 0)
	return icell;
    if (me->nrows == 1 && me->startline < lastrow->Line)
	me->startline = lastrow->Line;

    if (rowspan != 1) {
	Stbl_reserveCellsInTable(me, icell, colspan, rowspan);
	/* me->rows may now have been realloc'd, make lastrow valid pointer */
	lastrow = me->rows + (me->nrows - 1);
    }
    lastrow->content |= HAS_BEG_OF_CELL;

    {
	int growby = 0;

	while (icell + colspan + 1 > me->allocated_sumcols + growby)
	    growby += CELLS_GROWBY;
	if (growby) {
	    if (me->allocated_sumcols == 0 && !me->sumcols) {
		sumcols = typecallocn(STable_cellinfo, growby);
	    } else {
		sumcols = typeRealloc(STable_cellinfo, me->sumcols,
				        (me->allocated_sumcols + growby));

		for (i = 0; sumcols && i < growby; i++) {
		    sumcol = sumcols + me->allocated_sumcols + i;
		    sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
		    sumcol->len = 0;
		    sumcol->colspan = 0;
		    sumcol->cLine = 0;
		    sumcol->alignment = HT_ALIGN_NONE;
		}
	    }
	    if (sumcols) {
		me->allocated_sumcols += growby;
		me->sumcols = sumcols;
	    } else {
		return -1;
	    }
	}
    }
    if (icell + 1 > me->ncols) {
	me->ncols = icell + 1;
    }
    if (colspan > 1 && colspan + me->sumcols[icell + colspan].colspan > 0)
	me->sumcols[icell + colspan].colspan = -colspan;
    sumpos = pos;
    if (ncells > 0)
	sumpos += me->sumcols[ncells - 1].pos - lastrow->cells[ncells - 1].pos;
    update_sumcols0(me->sumcols, lastrow, sumpos,
		    sumpos - ((ncells > 0)
			      ? me->sumcols[icell].pos
			      : me->sumcols[icell].pos),
		    icell, 0, me->allocated_sumcols);

    me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
    if (me->maxpos > /* @@@@@@ max. line length we can accept */ MAX_STBL_POS)
	return -1;
    return 0;
}

/*
 * Returns -1 on error, otherwise 0.
 */
int Stbl_finishCellInTable(STable_info *me, int end_td,
			   int lineno,
			   int offset,
			   int pos)
{
    STable_states *s = &me->s;
    STable_rowinfo *lastrow;
    int len, xlen, icell;
    int i;

    CTRACE2(TRACE_TRST,
	    (tfp,
	     "TRST:Stbl_finishCellInTable(lineno=%d, pos=%d, off=%d, end_td=%d)\n",
	     lineno, pos, offset, (int) end_td));
    if (me->nrows == 0)
	return -1;
    lastrow = me->rows + (me->nrows - 1);
    icell = lastrow->ncells - 1;
    if (icell < 0)
	return icell;
    if (s->x_td == -1) {	/* Stray </TD> or just-in-case, as on </TR> */
	if ((end_td & TRST_ENDCELL_MASK) == TRST_ENDCELL_LINEBREAK)
	    lastrow->ended = ROW_ended_by_splitline;
	return 0;
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (!NO_AGGRESSIVE_NEWROW && !(end_td & TRST_FAKING_CELLS)) {
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 1);

	    if (rc) {
		if (rc < 0)
		    return -1;
		lastrow = me->rows + (me->nrows - 1);
		icell = lastrow->ncells - 1;
	    }
	}
    }
#endif
    len = Stbl_finishCellInRow(lastrow, s, end_td, lineno, pos);
    if (len == -1)
	return len;
    xlen = (len > 0) ? len : s->pending_len;	/* ##890 use xlen if fixed_line?: */
    if (lastrow->Line == lineno)
	len = xlen;
    if (lastrow->cells[icell].colspan > 1) {
	/*
	 * @@@@@@ This is all a too-complicated mess; do we need
	 * sumcols len at all, or is pos enough??
	 * Answer: sumcols len is at least used for center/right
	 * alignment, and should probably continue to be used there;
	 * all other uses are probably not necessary.
	 */
	int spanlen = 0, spanlend = 0;

	for (i = icell; i < icell + lastrow->cells[icell].colspan; i++) {
	    if (me->sumcols[i].len > 0) {
		spanlen += me->sumcols[i].len;
		if (i > icell)
		    spanlen++;
	    }
	    spanlend = HTMAX(spanlend,
			     me->sumcols[i + 1].pos - me->sumcols[icell].pos);
	}
	if (spanlend)
	    spanlend--;
	if (spanlend > spanlen)
	    spanlen = spanlend;
	/* @@@@@@ could overcount? */
	if (len > spanlen)
	    me->maxlen += (len - spanlen);
    } else if (len > me->sumcols[icell].len) {
	if (me->sumcols[icell + 1].colspan >= -1)
	    me->maxlen += (len - me->sumcols[icell].len);
	me->sumcols[icell].len = len;
    }

    if (len > 0) {
	update_sumcols0(me->sumcols, lastrow, pos, len,
			icell, lastrow->cells[icell].colspan,
			me->allocated_sumcols);
	me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
    }

    if ((end_td & TRST_ENDCELL_MASK) == TRST_ENDCELL_LINEBREAK) {
	lastrow->ended = ROW_ended_by_splitline;
	lastrow->content |= BELIEVE_OFFSET;
	lastrow->offset = offset;
    }
#ifdef EXP_NESTED_TABLES	/* maxlen may already include contribution of a cell in this column */
    if (nested_tables) {
	if (me->maxlen > MAX_STBL_POS)
	    return -1;
    } else
#endif
    {
	if (me->maxlen + (xlen - len) > MAX_STBL_POS)
	    return -1;
    }
    if (me->maxpos > /* @@@@@@ max. line length we can accept */ MAX_STBL_POS)
	return -1;

    if (lineno != lastrow->Line) {
	/* @@@@@@ Do something here?  Or is it taken care of in
	   Stbl_finishCellInRow ? */
    }

    return 0;
}

/*
 * Returns -1 on error, otherwise 0.
 */
int Stbl_addColInfo(STable_info *me, int colspan,
		    short alignment,
		    BOOL isgroup)
{
    STable_cellinfo *sumcols, *sumcol;
    int i, icolinfo;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_addColInfo(cs=%d, al=%d, isgroup=%d)\n",
	     colspan, alignment, (int) isgroup));
    if (isgroup) {
	if (me->pending_colgroup_next > me->ncolinfo)
	    me->ncolinfo = me->pending_colgroup_next;
	me->pending_colgroup_next = me->ncolinfo + colspan;
	if (me->ncolinfo > 0)
	    me->sumcols[me->ncolinfo - 1].cLine = EOCOLG;
	me->pending_colgroup_align = alignment;
    } else {
	for (i = me->pending_colgroup_next - 1;
	     i >= me->ncolinfo + colspan; i--)
	    me->sumcols[i].alignment = HT_ALIGN_NONE;
	me->pending_colgroup_next = me->ncolinfo + colspan;
    }
    icolinfo = me->ncolinfo;
    if (!isgroup)
	me->ncolinfo += colspan;

    {
	int growby = 0;

	while (icolinfo + colspan + 1 > me->allocated_sumcols + growby)
	    growby += CELLS_GROWBY;
	if (growby) {
	    if (me->allocated_sumcols == 0) {
		sumcols = typecallocn(STable_cellinfo, growby);
	    } else {
		sumcols = typeRealloc(STable_cellinfo, me->sumcols,
				        (me->allocated_sumcols + growby));

		for (i = 0; sumcols && i < growby; i++) {
		    sumcol = sumcols + me->allocated_sumcols + i;
		    sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
		    sumcol->len = 0;
		    sumcol->colspan = 0;
		    sumcol->cLine = 0;
		}
	    }
	    if (sumcols) {
		me->allocated_sumcols += growby;
		me->sumcols = sumcols;
	    } else {
		return -1;
	    }
	}
    }

    if (alignment == HT_ALIGN_NONE)
	alignment = me->pending_colgroup_align;
    for (i = icolinfo; i < icolinfo + colspan; i++) {
	me->sumcols[i].alignment = alignment;
    }
    return 0;
}

/*
 * Returns -1 on error, otherwise 0.
 */
int Stbl_finishColGroup(STable_info *me)
{
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishColGroup()\n"));
    if (me->pending_colgroup_next >= me->ncolinfo) {
	me->ncolinfo = me->pending_colgroup_next;
	if (me->ncolinfo > 0)
	    me->sumcols[me->ncolinfo - 1].cLine = EOCOLG;
    }
    me->pending_colgroup_next = 0;
    me->pending_colgroup_align = HT_ALIGN_NONE;
    return 0;
}

int Stbl_addRowGroup(STable_info *me, short alignment)
{
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_addRowGroup()\n"));
    Stbl_cancelRowSpans(me);
    me->rowgroup_align = alignment;
    return 0;			/* that's all! */
}

int Stbl_finishTABLE(STable_info *me)
{
    STable_states *s = &me->s;
    int i;
    int curpos = 0;

    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishTABLE()\n"));
    if (!me || me->nrows <= 0 || me->ncols <= 0) {
	return -1;
    }
    if (me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0) {
	if (s->pending_len > 0)
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len = s->pending_len;
	s->pending_len = 0;
    }
    Stbl_finishRowInTable(me);
    /* take into account offsets on multi-line cells.
       XXX We cannot do it honestly, since two cells on the same row may
       participate in multi-line table entries, and we preserve only
       one offset per row.  This implementation may ignore
       horizontal offsets for the last row of a multirow table entry.  */
    for (i = 0; i < me->nrows - 1; i++) {
	int j = i + 1, leading = i, non_empty = 0;
	STable_rowinfo *nextrow = me->rows + j;
	int minoffset, have_offsets;
	int foundcell = -1, max_width;

	if ((nextrow->content & (IS_CONTINUATION_OF_CELL | HAS_BEG_OF_CELL | BELIEVE_OFFSET))
	    != (IS_CONTINUATION_OF_CELL | BELIEVE_OFFSET))
	    continue;		/* Not a continuation line */
	minoffset = nextrow[-1].offset;		/* Line before first continuation */
	CTRACE2(TRACE_TRST, (tfp,
			     "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
			     i, nextrow[-1].offset, nextrow[-1].ended));

	/* Find the common part of the requested offsets */
	while (j < me->nrows
	       && ((nextrow->content &
		    (IS_CONTINUATION_OF_CELL
		     | HAS_BEG_OF_CELL
		     | BELIEVE_OFFSET))
		   == (IS_CONTINUATION_OF_CELL | BELIEVE_OFFSET))) {
	    if (minoffset > nextrow->offset)
		minoffset = nextrow->offset;
	    CTRACE2(TRACE_TRST,
		    (tfp,
		     "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
		     j, nextrow->offset, nextrow[-1].ended));
	    nextrow++;
	    j++;
	}
	i = j - 1;		/* Continue after this line */
	/* Cancel the common part of offsets */
	j = leading;		/* Restart */
	nextrow = me->rows + j;	/* Line before first continuation */
	have_offsets = 0;
	nextrow->content |= OFFSET_IS_VALID_LAST_CELL;
	while (j <= i) {	/* A continuation line */
	    nextrow->offset -= minoffset;
	    nextrow->content |= OFFSET_IS_VALID;
	    if (nextrow->offset)
		have_offsets = 1;
	    nextrow++;
	    j++;
	}
	if (!have_offsets)
	    continue;		/* No offsets to deal with */

	/* Find the cell number */
	foundcell = -1;
	j = leading + 1;	/* Restart */
	nextrow = me->rows + j;	/* First continuation line */
	while (foundcell == -1 && j <= i) {	/* A continuation line */
	    int curcell = -1;

	    while (foundcell == -1 && ++curcell < nextrow->ncells)
		if (nextrow->cells[curcell].len)
		    foundcell = curcell, non_empty = j;
	    nextrow++;
	    j++;
	}
	if (foundcell == -1)	/* Can it happen? */
	    continue;
	/* Find the max width */
	max_width = 0;
	j = leading;		/* Restart */
	nextrow = me->rows + j;	/* Include the pre-continuation line */
	while (j <= i) {	/* A continuation line */
	    if (nextrow->ncells > foundcell) {
		int curwid = nextrow->cells[foundcell].len + nextrow->offset;

		if (curwid > max_width)
		    max_width = curwid;
	    }
	    nextrow++;
	    j++;
	}
	/* Update the widths */
	j = non_empty;		/* Restart from the first nonempty */
	nextrow = me->rows + j;
	/* Register the increase of the width */
	update_sumcols0(me->sumcols, me->rows + non_empty,
			0 /* width only */ , max_width,
			foundcell, nextrow->cells[foundcell].colspan,
			me->allocated_sumcols);
	j = leading;		/* Restart from pre-continuation */
	nextrow = me->rows + j;
	while (j <= i) {	/* A continuation line */
	    if (nextrow->ncells > foundcell)
		nextrow->cells[foundcell].len = max_width;
	    nextrow++;
	    j++;
	}
    }				/* END of Offsets processing */

    for (i = 0; i < me->ncols; i++) {
	if (me->sumcols[i].pos < curpos) {
	    me->sumcols[i].pos = curpos;
	} else {
	    curpos = me->sumcols[i].pos;
	}
	if (me->sumcols[i].len > 0) {
	    curpos += me->sumcols[i].len;
	}
    }
    /* need to recheck curpos: though it is checked each time a cell
       is added, sometimes the result is ignored, as in split_line(). */
    return (curpos > MAX_STBL_POS ? -1 : me->ncols);
}

short Stbl_getAlignment(STable_info *me)
{
    return (short) (me ? me->alignment : HT_ALIGN_NONE);
}

static int get_fixup_positions(STable_rowinfo *me, int *oldpos,
			       int *newpos,
			       STable_cellinfo *sumcols)
{
    int i = 0, ip = 0;
    int next_i, newlen;
    int ninserts;

    if (!me)
	return -1;
    while (i < me->ncells) {
	int offset;

	next_i = i + HTMAX(1, me->cells[i].colspan);
	if (me->cells[i].cLine != me->Line) {
	    if (me->cells[i].cLine > me->Line)
		break;
	    i = next_i;
	    continue;
	}
	oldpos[ip] = me->cells[i].pos;
	if ((me->content & OFFSET_IS_VALID)
	    && (i == me->ncells - 1
		|| !((me->content & OFFSET_IS_VALID_LAST_CELL))))
	    offset = me->offset;
	else
	    offset = 0;
	newpos[ip] = sumcols[i].pos + offset;
	if ((me->cells[i].alignment == HT_CENTER ||
	     me->cells[i].alignment == HT_RIGHT) &&
	    me->cells[i].len > 0) {
	    newlen = sumcols[next_i].pos - newpos[ip] - 1;
	    newlen = HTMAX(newlen, sumcols[i].len);
	    if (me->cells[i].len < newlen) {
		if (me->cells[i].alignment == HT_RIGHT) {
		    newpos[ip] += newlen - me->cells[i].len;
		} else {
		    newpos[ip] += (newlen - me->cells[i].len) / 2;
		}
	    }
	}
	ip++;
	i = next_i;
    }
    ninserts = ip;
    return ninserts;
}

/*
 * Returns -1 if we have no row for this lineno, or for other error,
 *	    0 or greater (number of oldpos/newpos pairs) if we have
 *	      a table row.
 */
int Stbl_getFixupPositions(STable_info *me, int lineno,
			   int *oldpos,
			   int *newpos)
{
    STable_rowinfo *row;
    int j;
    int ninserts = -1;

    if (!me || !me->nrows)
	return -1;
    for (j = 0; j < me->nrows; j++) {
	row = me->rows + j;
	if (row->Line == lineno) {
	    ninserts = get_fixup_positions(row, oldpos, newpos,
					   me->sumcols);
	    break;
	}
    }
    return ninserts;
}

int Stbl_getStartLine(STable_info *me)
{
    if (!me)
	return -1;
    else
	return me->startline;
}

#ifdef EXP_NESTED_TABLES

int Stbl_getStartLineDeep(STable_info *me)
{
    if (!me)
	return -1;
    while (me->enclosing)
	me = me->enclosing;
    return me->startline;
}

void Stbl_update_enclosing(STable_info *me, int max_width,
			   int last_lineno)
{
    int l;

    if (!me || !me->enclosing || !max_width)
	return;
    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",
	     max_width, me->startline, last_lineno));
    for (l = me->startline; l <= last_lineno; l++) {
	/* Fake <BR> in appropriate positions */
	if (Stbl_finishCellInTable(me->enclosing,
				   TRST_ENDCELL_LINEBREAK,
				   l,
				   0,
				   max_width) < 0) {
	    /* It is not handy to let the caller delete me->enclosing,
	       and it does not buy us anything.  Do it directly. */
	    STable_info *stbl = me->enclosing;

	    CTRACE2(TRACE_TRST, (tfp,
				 "TRST:Stbl_update_enclosing: width too large, aborting enclosing\n"));
	    me->enclosing = 0;
	    while (stbl) {
		STable_info *enclosing = stbl->enclosing;

		Stbl_free(stbl);
		stbl = enclosing;
	    }
	    break;
	}
    }
    return;
}

void Stbl_set_enclosing(STable_info *me, STable_info *enclosing, struct _TextAnchor *enclosing_last_anchor_before_stbl)
{
    if (!me)
	return;
    me->enclosing = enclosing;
    me->enclosing_last_anchor_before_stbl = enclosing_last_anchor_before_stbl;
}

STable_info *Stbl_get_enclosing(STable_info *me)
{
    if (!me)
	return 0;
    return me->enclosing;
}

struct _TextAnchor *Stbl_get_last_anchor_before(STable_info *me)
{
    if (!me)
	return 0;
    return me->enclosing_last_anchor_before_stbl;
}
#endif
@


1.8
log
@automatic merge; regen configure
@
text
@d454 2
a455 3
		cells = realloc(me->cells,
				(me->allocated + growby)
				* sizeof(STable_cellinfo));
d522 2
a523 3
	cells = realloc(me->cells,
			(me->allocated + growby)
			* sizeof(STable_cellinfo));
d981 2
a982 3
	rows = realloc(me->rows,
		       (me->allocated_rows + growby)
		       * sizeof(STable_rowinfo));
d1079 2
a1080 3
		rows = realloc(me->rows,
			       (me->allocated_rows + growby)
			       * sizeof(STable_rowinfo));
d1333 2
a1334 3
	    STable_rowinfo *rows = realloc(me->rows,
					   (me->allocated_rows + 1)
					   * sizeof(STable_rowinfo));
d1480 2
a1481 3
		sumcols = realloc(me->sumcols,
				  (me->allocated_sumcols + growby)
				  * sizeof(STable_cellinfo));
d1672 2
a1673 3
		sumcols = realloc(me->sumcols,
				  (me->allocated_sumcols + growby)
				  * sizeof(STable_cellinfo));
@


1.7
log
@back out the -iz patch; slashdot.org and symlink.lu look
way different (not the front page, but the articles), and
also on www.heise.de/newsticker/ there is no left spacing
at the left side of the text, which is confusing in a
full-screen xterm
@
text
@d26 1
a26 1
#  define MAX_STBL_POS (LYwideLines ? MAX_COLS - 1 : LYcols-1)
d28 1
a28 1
#  define MAX_STBL_POS (LYcols-1)
@


1.6
log
@automatic merge of lynx-current
@
text
@d20 1
a20 2
#define ROWS_GROWBY_DIVISOR 2
#else /* This is very silly, and leads to *larger* memory consumption... */
a22 1
#define ROWS_GROWBY_DIVISOR 10
a24 6
#define  REUSE_ROWS_AS_CELLS_POOLS 0	/* Turns out to be not beneficial */

/* Experiments show that 2 is better than 1.5 is better than 1.25 (all by
   a small margin only)??? */
#define CELLS_GROWBY_FACTOR 2

d37 1
a37 1
#  define NO_AGGRESSIVE_NEWROW	(tables_disable & TABLES_DISABLE_AGRESSIVE_NEW_ROW)
d74 4
a77 4
    short pos;			/* column where cell starts */
    short len;			/* number of character positions */
    short colspan;		/* number of columns to span */
    short alignment;		/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
a92 9
#define IS_CONTINUATION_OF_MULTICELL	0x40
#define IS_UNSPLIT_CANDIDATE		0x80
#define LAST_CELL_STARTS_WITH_NL	0x100

enum fakeRow_types {
    fakeRow_starting,
    fakeRow_finishing,
    fakeRow_finishing_firstline,
};
d98 1
a98 1
    short ncells;		/* number of table cells */
d122 1
a122 1
    short fixed_line;		/* if we have a 'core' line of cells */
d124 3
a126 5
    short content;		/* Whether contains end-of-cell etc */
    short offset;		/* >=0 after line break in a multiline cell */
    short allocated;		/* number of table cells allocated or 0
				   if the .cells should not be free()ed */
    short alignment;		/* global align attribute for this row */
d128 1
a130 8
struct _STable_chunk;
typedef struct _STable_chunk {
    struct _STable_chunk *next;
    int alloc_cells;
    int used_cells;
    STable_cellinfo cells[1];
} STable_chunk;

a143 1
    int last_reserved;		/* -1 or last line with reserved cells */
a151 2
    STable_chunk *free_chunks;
    STable_chunk *used_chunks;
d202 1
a202 3
static int Stbl_finishCellInRow(STable_rowinfo *me,
				STable_states *s,
				int end_td,
d205 1
a205 1
static int Stbl_DOfinishRowInTable(STable_info *me);
a242 1
	me->last_reserved = -1;
a246 1
	me->used_chunks = me->free_chunks = NULL;
a257 91
static int addmem_rowinfo(STable_info *me,
			  int incr)
{
    int i;
    int growby = 0;
    STable_rowinfo *rows, *row;

    while (me->nrows + incr + 1 > me->allocated_rows + growby)
	growby += ROWS_GROWBY + me->allocated_rows / ROWS_GROWBY_DIVISOR;
    if (growby) {
	if (me->allocated_rows == 0 && !me->rows) {
	    rows = typecallocn(STable_rowinfo, growby);
	} else {
#if REUSE_ROWS_AS_CELLS_POOLS	/* Turns out to be not beneficial */
	    /* Work in a regime which has a chance to work efficiently
	       even with lousy malloc()s: do not realloc() until we
	       have many (2) free chunks available (possible with very
	       simple structure of each row).  Simultaneously,
	       make it possible to use an effecient realloc() which
	       would grow the region in place - so DO use realloc() if
	       we already have many free chunks to put the cellinfo into.
	     */
	    if (me->free_chunks && me->free_chunks->next
		|| (me->allocated_rows * sizeof(STable_rowinfo) <
		      (sizeof(STable_chunk)
		       + (CELLS_GROWBY - 1) * sizeof(STable_cellinfo)))
		|| 1)
#endif
	    {
		rows = realloc(me->rows,
			       (me->allocated_rows + growby)
			       * sizeof(STable_rowinfo));
	    }
#if REUSE_ROWS_AS_CELLS_POOLS
	    else {
		rows = malloc((me->allocated_rows + growby)
			      * sizeof(STable_rowinfo));

		if (rows) {
		    STable_chunk *p;

		    memcpy(rows, me->rows,
			   (me->allocated_rows + growby)
			   * sizeof(STable_rowinfo));

		    p = (STable_chunk *) me->rows;
		    p->alloc_cells =
			1 + (me->allocated_rows * sizeof(STable_rowinfo)
			     - sizeof(STable_chunk)) / sizeof(STable_cellinfo);

		    p->used_cells = 0;
		    p->next = me->free_chunks;
		    me->free_chunks = p;
		}
	    }
#endif
	    for (i = 0; rows && i < growby; i++) {
		row = rows + me->allocated_rows + i;
		if (!me->rowspans2eog.allocated) {
		    row->allocated = 0;
		    row->cells = NULL;
		} else {
		    row->cells = typecallocn(STable_cellinfo,
					     me->rowspans2eog.allocated);

		    if (row->cells) {
			row->allocated = me->rowspans2eog.allocated;
			memcpy(row->cells, me->rowspans2eog.cells,
			       row->allocated * sizeof(STable_cellinfo));
		    } else {
			FREE(rows);
			break;
		    }
		}
		row->ncells = 0;
		row->fixed_line = NO;
		row->alignment = HT_ALIGN_NONE;
		row->offset = 0;
		row->content = 0;
	    }
	}
	if (rows) {
	    me->allocated_rows += growby;
	    me->rows = rows;
	} else {
	    return 0;
	}
    }
    return 1;
}

a271 12
    if (me) {
	STable_chunk *this;

	while ((this = me->free_chunks)) {
	    me->free_chunks = this->next;
	    FREE(this);
	}
	while ((this = me->used_chunks)) {
	    me->used_chunks = this->next;
	    FREE(this);
	}
    }
d278 1
a278 3
static int Stbl_addCellToRow(STable_rowinfo *me,
			     STable_cellinfo *colinfo,
			     int ncolinfo,
d451 1
a451 1
	    if (!me->cells) {
d454 3
a456 9
		if (me->allocated == 0) {	/* Put into pool */
		    cells = typecallocn(STable_cellinfo, growby);

		    memcpy(cells, me->cells,
			   me->ncells * sizeof(STable_cellinfo));
		} else
		    cells = realloc(me->cells,
				    (me->allocated + growby)
				    * sizeof(STable_cellinfo));
d512 1
a512 2
static int Stbl_reserveCellsInRow(STable_rowinfo *me,
				  int icell,
d549 1
a549 3
static int Stbl_finishCellInRow(STable_rowinfo *me,
				STable_states *s,
				int end_td,
d954 1
a954 2
static int Stbl_reserveCellsInTable(STable_info *me,
				    int icell,
d958 3
a960 1
    int i, last;
d981 18
a998 2
    if (!addmem_rowinfo(me, rowspan - 1))
	return 0;		/* ignore silently, no free memory, may be recoverable */
d1000 16
a1015 4
    last = (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
    if (me->last_reserved < last)
	me->last_reserved = last;
    for (i = me->nrows; i < last; i++) {
d1049 1
a1049 2
int Stbl_addRowToTable(STable_info *me,
		       int alignment,
d1052 1
d1060 4
a1063 2
	    me->rows[me->nrows - 1].cells[me->rows[me->nrows - 1].ncells -
					  1].len = s->pending_len;
d1066 1
a1066 1
    Stbl_DOfinishRowInTable(me);
d1072 47
a1118 2
    if (!addmem_rowinfo(me, 1))
	return -1;
a1128 48
    if (me->nrows >= 2		/* We may use RESERVEDCELL flag of cells in nrows-1 */
	&& me->rows[me->nrows - 2].allocated > me->rows[me->nrows - 2].ncells) {
	int c = me->rows[me->nrows - 2].ncells;
	STable_cellinfo *p = me->rows[me->nrows - 2].cells;

#if 0				/* Leads to no memory savings and quadratic time with EMX malloc */
	/* Do not need extra cells any more */
	me->rows[me->nrows - 2].cells = realloc(p, c * sizeof(STable_cellinfo));

	me->rows[me->nrows - 2].allocated = me->rows[me->nrows - 2].ncells;
#else
	if (!me->used_chunks
	    || ((me->used_chunks->alloc_cells - me->used_chunks->used_cells)
		< c)) {
	    if (me->free_chunks && (me->free_chunks->alloc_cells >= c)) {
		STable_chunk *p2 = me->free_chunks;

		me->free_chunks = p2->next;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    } else {		/* Need to get a new guy */
		STable_chunk *p2;

		if (c < CELLS_GROWBY)
		    c = CELLS_GROWBY;
		if (me->used_chunks
		    && c < me->used_chunks->alloc_cells * CELLS_GROWBY_FACTOR)
		    c = 2 * me->used_chunks->alloc_cells * CELLS_GROWBY_FACTOR;
		p2 = malloc(sizeof(STable_chunk) + (c - 1) * sizeof(STable_cellinfo));

		if (p2 == NULL)
		    outofmem(__FILE__, "Stbl_addRowToTable");
		p2->alloc_cells = c;
		p2->used_cells = 0;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    }
	}
	memcpy(me->used_chunks->cells + me->used_chunks->used_cells,
	       p, me->rows[me->nrows - 2].ncells * sizeof(STable_cellinfo));

	me->rows[me->nrows - 2].cells =
	    me->used_chunks->cells + me->used_chunks->used_cells;
	me->used_chunks->used_cells += me->rows[me->nrows - 2].ncells;
	me->rows[me->nrows - 2].allocated = 0;	/* Do not FREE() */
	FREE(p);
#endif
    }
d1142 1
a1142 1
static int Stbl_DOfinishRowInTable(STable_info *me)
d1148 1
a1148 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_DOfinishRowInTable()\n"));
d1153 1
a1153 2
    if (lastrow->ended != ROW_ended_by_splitline)
	lastrow->ended = ROW_ended_by_endtr;
d1187 5
a1191 4
	    if (sumcols[icell + ispan - 1].pos + sumcols[icell + ispan -
							 1].len > sumpos)
		sumpos = sumcols[icell + ispan - 1].pos + sumcols[icell +
								  ispan - 1].len;
d1201 2
a1202 2
					    sumcols[i - 1].pos + sumcols[i -
									 1].len
d1246 1
a1246 1
				      enum fakeRow_types finishing)	/* Processing finish or start */
d1264 1
a1264 1
	if (finishing == fakeRow_starting)
a1288 1
	int is_multicell = 0;
a1294 5
	if (lastrow->ncells > 1
	    && (lastrow->cells[lastrow->ncells - 2].pos
		!= lastrow->cells[lastrow->ncells - 1].pos))
	    is_multicell = 1;

d1300 1
a1300 1
	if (finishing != fakeRow_starting) {
a1315 4
	if (is_multicell)
	    lastrow->content |= IS_CONTINUATION_OF_MULTICELL;
	if (finishing == fakeRow_finishing_firstline)
	    lastrow->content |= IS_UNSPLIT_CANDIDATE;
a1351 1
	    me->last_reserved++;
a1356 1
	    lastrow[1].content = 0;
d1386 1
a1386 4
		 ncells,
		 ((finishing != fakeRow_starting)
		  ? ", last unfinished"
		  : "")));
d1397 1
a1397 1
	    if (finishing == fakeRow_starting || (i != ncells)) {
d1408 1
a1408 2
    } else if (finishing == fakeRow_finishing_firstline)
	lastrow->content |= LAST_CELL_STARTS_WITH_NL;
d1416 1
a1416 2
int Stbl_addCellToTable(STable_info *me,
			int colspan,
d1447 1
a1447 1
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, fakeRow_starting);
d1515 3
a1517 2
		    sumpos - (ncells > 0 ? me->sumcols[icell].pos :
			      me->sumcols[icell].pos),
a1525 130
BOOL Stbl_at_start_of_cell(STable_info *me,
			   int lineno,
			   int pos)
{
    STable_rowinfo *lastrow;
    int icell;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_at_start_of_cell(lineno=%d, pos=%d): ",
	     lineno, pos));
    if (me->nrows == 0)
	goto yes;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended != ROW_not_ended)
	goto no;		/* E.g., may be processing </tr> */
    icell = lastrow->ncells - 1;
    if (icell < 0)
	goto yes;
    if (lastrow->cells[icell].cLine != lineno
	|| lastrow->cells[icell].pos != pos) {
      no:
	CTRACE2(TRACE_TRST, (tfp, "no\n"));
	return FALSE;		/* XXXX  What to do if cLine is -1? */
    }
  yes:
    CTRACE2(TRACE_TRST, (tfp, "yes\n"));
    return TRUE;
}

int Stbl_start_of_last_cell(STable_info *me,
			    int lineno)
{
    STable_rowinfo *lastrow;
    int icell;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_at_start_of_cell(lineno=%d)\n", lineno));
    if (me->nrows == 0)
	return -1;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended != ROW_not_ended)
	return -1;		/* E.g., may be processing </tr> */
    icell = lastrow->ncells - 1;
    if (icell >= 0 && lastrow->cells[icell].cLine == lineno)
	return lastrow->cells[icell].pos;
    return -1;
}

void Stbl_finishRowInTable(STable_info *me)
{
    STable_rowinfo *lastrow;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_finishRowInTable()\n"));
    if (me->nrows <= 0)
	return;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended == ROW_not_ended)
	lastrow->ended = ROW_ended_by_endtr;
}

/* Assumes that the current pos is at beginning of line.
   Checks whether the last row was a fake row, and undo it if possible.
   Returns TRUE if the last line (empty!) can be safely trimmed. */
int Stbl_trimFakeRows(STable_info *me,
		      int lineno,
		      int pos GCC_UNUSED)
{
    STable_rowinfo *prevrow, *lastrow;
    int icell;

    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_trimFakeRows()\n"));

    /* XXXX The logic may be much better if we support removal of
       RESERVED cells.  Until this is done, bail out early: */
    if (me->nrows <= 0 || me->nrows <= me->last_reserved)
	return 0;
    lastrow = me->rows + (me->nrows - 1);
    icell = lastrow->ncells - 1;
    if (icell >= 0 && lastrow->cells[icell].cLine < lineno) {
	/* The last cell start on a preceeding line; keep lastrow */
	lastrow->ended = ROW_not_ended;		/* Give it new life */
	/* We do not use state info for a lot of things any more, so do
	   not try to do anything special here */
	me->s.state = CS__0new;	/* This is enough to revive things. */
	me->s.x_td = lastrow->cells[lastrow->ncells - 1].pos;
	me->s.lineno = lastrow->cells[lastrow->ncells - 1].cLine;
	lastrow->content &= ~LAST_CELL_STARTS_WITH_NL;
	CTRACE2(TRACE_TRST, (tfp, "  un-ended the last row.\n"));
	return 1;
    }
    if (me->nrows <= 1 || !(lastrow->content & IS_CONTINUATION_OF_CELL))
	return 0;
    prevrow = me->rows + (me->nrows - 2);
    if (prevrow->ncells != icell + 1)	/* Empty cells were added after the break */
	return 0;
    if (prevrow->ended != ROW_ended_by_splitline)	/* Lastrow non-fake */
	return 0;
    me->nrows--;
    /* prevrow is now the last row, so its cells should be realloc()able */
    if (prevrow->cells && prevrow->allocated == 0) {	/* Moved to pool */
	int c = prevrow->ncells;
	STable_cellinfo *p;

	if (lastrow->allocated > c)	/* May have RESERVED info */
	    c = lastrow->allocated;
	if ((p = malloc(c * sizeof(STable_cellinfo))) == NULL)
	      outofmem(__FILE__, "Stbl_trimFakeRows ");
	memcpy(p, prevrow->cells, prevrow->ncells * sizeof(STable_cellinfo));

	/* Copy back the possibly present RESERVED info.
	   XXXX remove duplicated RESERVED stuff from the followup rows too! */
	memcpy(p + prevrow->ncells, lastrow->cells + prevrow->ncells,
	       (c - prevrow->ncells) * sizeof(STable_cellinfo));

	prevrow->cells = p;	/* XXXX How would ride with RESERVED? */
	prevrow->allocated = c;
    }
    lastrow->ncells = 0;
    lastrow->content = 0;
    prevrow->ended = ROW_not_ended;	/* Give it new life */
    /* We do not use state info for a lot of things any more, so do
       not try to do anything special here */
    me->s.state = CS__0new;
    me->s.x_td = prevrow->cells[prevrow->ncells - 1].pos;
    me->s.lineno = prevrow->cells[prevrow->ncells - 1].cLine;
    CTRACE2(TRACE_TRST, (tfp, "  Removed the last row.\n"));
    return 1;
}

d1529 1
a1529 2
int Stbl_finishCellInTable(STable_info *me,
			   int end_td,
d1557 1
a1557 9
	    /* Last cell, has it a newline in a beginning of cell? */
	    int nn = ((lastrow->content & LAST_CELL_STARTS_WITH_NL)
		      && lineno > lastrow->cells[icell].cLine)
	    || ((lastrow->content & HAS_BEG_OF_CELL)
		&& lastrow->cells[icell].pos >= pos);
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno,
						nn
						? fakeRow_finishing_firstline
						: fakeRow_finishing);
d1642 1
a1642 2
int Stbl_addColInfo(STable_info *me,
		    int colspan,
d1723 1
a1723 2
int Stbl_addRowGroup(STable_info *me,
		     short alignment)
d1743 3
a1745 2
	    me->rows[me->nrows - 1].cells[me->rows[me->nrows - 1].ncells -
					  1].len = s->pending_len;
d1748 1
a1748 1
    Stbl_DOfinishRowInTable(me);
d1760 1
a1760 2
	if ((nextrow->content & (IS_CONTINUATION_OF_CELL | HAS_BEG_OF_CELL
				 | IS_CONTINUATION_OF_MULTICELL | BELIEVE_OFFSET))
d1770 4
a1773 2
	       && ((nextrow->content & (IS_CONTINUATION_OF_CELL |
					HAS_BEG_OF_CELL | BELIEVE_OFFSET))
d1777 4
a1780 3
	    CTRACE2(TRACE_TRST, (tfp,
				 "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
				 j, nextrow->offset, nextrow[-1].ended));
d1868 1
a1868 2
static int get_fixup_positions(STable_rowinfo *me,
			       int *oldpos,
d1870 1
a1870 6
			       STable_cellinfo *sumcols,
			       int prevline_len,
			       int *do_unsplit,
			       int *row_start_line_p,
			       int *cur_col_p,
			       int *cell_line_count_p)
a1874 3
    int unsplit = (*do_unsplit && (me->content & IS_UNSPLIT_CANDIDATE)
		   && prevline_len >= 0);
    int did_unsplit = 0, delta = 0;
a1877 4
    *do_unsplit = -1;
    (*cell_line_count_p)++;
    if (!(me->content & IS_CONTINUATION_OF_CELL))
	*row_start_line_p = me->Line;
d1879 1
a1879 1
	int offset, pos;
d1888 1
d1895 1
a1895 1
	pos = sumcols[i].pos + offset;
d1899 1
a1899 1
	    newlen = sumcols[next_i].pos - sumcols[i].pos - offset - 1;
d1903 1
a1903 1
		    pos += newlen - me->cells[i].len;
d1905 1
a1905 1
		    pos += (newlen - me->cells[i].len) / 2;
a1908 14
	if (!me->cells[i].pos && me->cells[i].len) {
	    if (i != *cur_col_p) {
		*cell_line_count_p = 0;
		*cur_col_p = i;
	    }
	    if ((unsplit || *cur_col_p > 0) && !did_unsplit) {
		did_unsplit = 1;
		delta = sumcols[i].pos;
		ip = 0;		/* Undo changes */
		*do_unsplit = delta;
	    }
	}
	oldpos[ip] = me->cells[i].pos;
	newpos[ip] = pos - delta;
d1921 1
a1921 2
int Stbl_getFixupPositions(STable_info *me,
			   int lineno,
d1923 1
a1923 6
			   int *newpos,
			   int prevline_len,
			   int *do_unsplit,
			   int *row_start_line_p,
			   int *cur_col_p,
			   int *cell_line_count_p)
d1927 1
a1927 2
    int ninserts = -1, found = 0;
    static int prev_row = 0;
d1931 1
a1931 5
    if (prev_row < me->nrows && me->rows[prev_row].Line <= lineno)
	j = prev_row;
    else
	j = 0;
    for (; j < me->nrows; j++) {
a1933 2
	    prev_row = j;
	    found = 1;
d1935 1
a1935 3
					   me->sumcols, prevline_len,
					   do_unsplit, row_start_line_p,
					   cur_col_p, cell_line_count_p);
a1938 2
    if (!found)
	*row_start_line_p = -1;
d1961 1
a1961 2
void Stbl_update_enclosing(STable_info *me,
			   int max_width,
d1968 3
a1970 3
    CTRACE2(TRACE_TRST, (tfp,
			 "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",
			 max_width, me->startline, last_lineno));
d1974 4
a1977 1
				   TRST_ENDCELL_LINEBREAK, l, 0, max_width) < 0) {
d1997 1
a1997 3
void Stbl_set_enclosing(STable_info *me,
			STable_info *enclosing,
			struct _TextAnchor *enclosing_last_anchor_before_stbl)
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 6
a7 6
**		===================
** Authors
**	KW	Klaus Weide <kweide@@enteract.com>
** History:
**   2 Jul 1999	KW	Created.
*/
d20 2
a21 1
#else
d24 1
d27 6
d45 1
a45 1
#  define NO_AGGRESSIVE_NEWROW	0
d52 1
a52 1
    CS__new     =  0,
d67 6
a72 6
    cellstate_t	prev_state;	/* Contents type of the previous cell */
    cellstate_t	state;		/* Contents type of the worked-on cell */
    int		lineno;		/* Start line of the current cell */
    int		icell_core;	/* -1 or the 1st cell with <BR></TD> on row */
    int		x_td;		/* x start pos of the current cell or -1 */
    int		pending_len;	/* For multiline cells, the length of
d78 1
a78 1
	int	cLine;		/* lineno in doc (zero-based): -1 for
d82 4
a85 4
	int	pos;		/* column where cell starts */
	int	len;		/* number of character positions */
	int	colspan;	/* number of columns to span */
	int	alignment;	/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
d90 3
a92 3
	ROW_not_ended,
	ROW_ended_by_endtr,
	ROW_ended_by_splitline
d101 9
d114 2
a115 2
	int	Line;		/* lineno in doc (zero-based) */
	int	ncells;		/* number of table cells */
d118 1
a118 1
       [search for	def of fixed_line	below]
d128 1
a128 1
		(Notation: B: at BOL; L: last; E: the first row is non-empty)
d130 3
a132 3
		bcde:	!B && !E
		a1:	!L && !B
		a2:	!L && !E
d139 8
a146 7
	BOOL	fixed_line;	/* if we have a 'core' line of cells */
	enum ended_state ended;	/* if we saw </tr> etc */
	int	content;	/* Whether contains end-of-cell etc */
	int	offset;		/* >=0 after line break in a multiline cell */
	int	allocated;	/* number of table cells allocated */
	STable_cellinfo * cells;
	int	alignment;	/* global align attribute for this row */
d149 8
d159 2
a160 2
	struct _STable_info *enclosing;	/* The table which contain us */
	struct _TextAnchor  *enclosing_last_anchor_before_stbl;
d162 19
a180 16
	int	startline;	/* lineno where table starts (zero-based) */
	int	nrows;		/* number of rows */
	int	ncols;		/* number of rows */
	int	maxlen;		/* sum of max. cell lengths of any row */
	int	maxpos;		/* max. of max. cell pos's of any row */
	int	allocated_rows; /* number of rows allocated */
	int	allocated_sumcols;	/* number of sumcols allocated */
	int	ncolinfo;		/* number of COL info collected */
	STable_cellinfo * sumcols; /* for summary (max len/pos) col info */
	STable_rowinfo * rows;
	STable_rowinfo	rowspans2eog;
	short	alignment;	/* global align attribute for this table */
	short	rowgroup_align;	/* align default for current group of rows */
	short	pending_colgroup_align;
	int	pending_colgroup_next;
	STable_states s;
d184 53
a236 55
**  Functions and structures in this source file keep track of positions.
**  They don't know about the character data in those lines, or about
**  the HText and HTLine structures.  GridText.c doesn't know about our
**  structures.  It should stay that way.
**
**  The basic idea: we let the code in HTML.c/GridText.c produce and format
**  output "as usual", i.e. as without Simple Table support.  We keep track
**  of the positions in the generated output where cells and rows start (or
**  end).  If all goes well, that preliminary output (stored in HText/HTLine
**  structures) can be fixed up when the TABLE end tag is processed, by just
**  inserting spaces in the right places (and possibly changing alignment).
**  If all goes not well, we already have a safe fallback.
**
**  Note that positions passed to and from these functions should be
**  in terms of screen positions, not just byte counts in a HTLine.data
**  (cf. line->data vs. HText_TrueLineSize).
**
**  Memory is allocated dynamically, so we can have tables of arbitrary
**  length.  On allocation error we just return and error indication
**  instead of outofmem(), so caller can give up table tracking and maybe
**  recover memory.
**
**  Implemented:
**  - ALIGN={left,right,center,justify} applied to individual table cells
**    ("justify" is treated as "left")
**  - Inheritance of horizontal alignment according to HTML 4.0
**  - COLSPAN >1 (may work incorrectly for some tables?)
**  - ROWSPAN >1 (reserving cells in following rows)
**  - Line breaks at start of first cell or at end of last cell are treated
**    as if they were not part of the cell and row.  This allows us to
**    cooperate with one way in which tables have been made friendly to
**    browsers without any table support.
**  Missing, but can be added:
**  - Support for COLGROUP/COL
**  - Tables wider than display.  The limitation is not here but in GridText.c
**    etc.  If horizontal scrolling were implemented there, the mechanisms
**    here coudl deal with wide tables (just change MAX_STBL_POS code).
**  Missing, unlikely to add:
**  - Support for non-LTR directionality.  A general problem, support is
**    lacking throughout the lynx code.
**  - Support for most other table-related attributes.  Most of them are
**    for decorative purposes.
**  Impossible or very unlikely (because it doesn't fit the model):
**  - Any cell contents of more than one line, line breaks within cells.
**    Anything that requires handling cell contents as paragraphs (block
**    elements), like reflowing.  Vertical alignment.
*/
static int Stbl_finishCellInRow (
    STable_rowinfo *	me,
    STable_states *	s,
    int			end_td,
    int			lineno,
    int			pos);
static int Stbl_finishRowInTable (
    STable_info *	me);
d238 1
a238 2
static const char * cellstate_s (
	cellstate_t	state)
d241 1
a241 1

d257 2
d262 1
a262 2
struct _STable_info * Stbl_startTABLE (
    short		alignment)
d267 1
a267 1
	    (tfp, "TRST:Stbl_startTABLE(align=%d)\n", (int)alignment));
d274 1
d279 1
d284 1
a284 2
static void free_rowinfo (
    STable_rowinfo *	me)
d291 92
a382 2
void Stbl_free (
    STable_info *	me)
d388 1
d396 12
d414 9
a422 10
static int Stbl_addCellToRow (
    STable_rowinfo *	me,
    STable_cellinfo *	colinfo,
    int		ncolinfo,
    STable_states *	s,
    int		colspan,
    int		alignment,
    int		isheader,
    int		lineno,
    int *		ppos)
d427 1
a427 1
	me->cells[me->ncells - 1].colspan : 1;
d433 1
a433 1
		   lineno, *ppos, colspan));
d435 4
a438 3
	    (tfp, " ncells=%d, stateLine=%d, pending_len=%d, pstate=%s, state=%s\n",
		   me->ncells, s->lineno, s->pending_len,
		   cellstate_s(s->prev_state), cellstate_s(s->state)));
d486 1
a486 1
	    } else {	/* last cell multiline, ncells != 0, pos != 0 */
d501 1
a501 1
		    me->fixed_line = YES; /* type=a def of fixed_line i */
d507 1
a507 1
		    me->fixed_line = YES; /* type=e def of fixed_line ii */
d521 1
a521 1
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */ +
d527 1
a527 1
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */ +
d538 2
a539 1
		*ppos = me->cells[me->ncells - 1].pos;	break;
d577 1
a577 1
	me->ncells += me->cells[me->ncells-1].colspan - 1;
d585 1
d589 1
a589 1
	    if (me->allocated == 0 && !me->cells) {
d592 10
a601 3
		cells = realloc(me->cells,
				  (me->allocated + growby)
				  * sizeof(STable_cellinfo));
d627 1
a627 1
	if (me->cells[me->ncells].alignment==HT_ALIGN_NONE)
d629 1
a629 1
	if (me->cells[me->ncells].alignment==HT_ALIGN_NONE)
d639 1
a639 1
    me->cells[me->ncells + colspan].pos = -1; /* not yet used */
d646 1
a646 1
		  cellstate_s(s->prev_state), cellstate_s(s->state), ret));
d656 3
a658 4
static int Stbl_reserveCellsInRow (
    STable_rowinfo *	me,
    int		icell,
    int		colspan)
d666 1
a666 1
		  icell, colspan));
d671 1
d694 5
a698 6
static int Stbl_finishCellInRow (
    STable_rowinfo *	me,
    STable_states *	s,
    int		end_td,
    int		lineno,
    int		pos)
d706 3
a708 2
	    (tfp, "TRST:Stbl_finishCellInRow line=%d pos=%d end_td=%d ncells=%d pnd_len=%d\n",
		  lineno, pos, (int)end_td, me->ncells, s->pending_len));
d717 4
a720 3
	    (tfp, " [lines: lastCell=%d state=%d multi=%d] empty=%d (prev)state=(%s) %s\n",
		  lastcell->cLine, s->lineno, multiline, empty,
		  cellstate_s(s->prev_state), cellstate_s(s->state)));
d753 1
a753 1
		if (s->pending_len && empty) { /* First line non-empty */
d758 2
a759 2
		} /* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cb : CS__cbc; /* ##474_needs_len!=-1? */
d783 1
a783 1
		if (s->pending_len && empty) { /* ##496: */
d786 1
a786 1
		} /* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
d790 2
a791 2
			me->fixed_line = YES; /* type=b def of fixed_line i */
			me->Line = lastcell->cLine; /* should've happened in break */
d798 2
a799 2
			me->fixed_line = YES; /* type=b def of fixed_line ii */
			me->Line = lastcell->cLine; /* should've happened in break */
d810 1
a810 1
		ret = lastcell->len; /* ##523_change_state? */
d815 1
a815 1
			if (s->icell_core == -1) /* ##528??: */
d840 1
a840 1
				/* ##541_set_len_0_Line_-1_sometimes: */
d843 3
a845 2
		 /* fall thru ##546 really fall thru??: */
		newstate = empty ? CS_invalid : CS__cbc;	break;
d847 2
a848 1
		newstate = empty ? CS__0ef  : CS__0cf;	break;
d850 1
a850 1
		newstate = empty ? CS__0ef  : CS__0cf;		/* ebc?? */
d886 3
a888 2
		} /* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cf : CS__cbc;	break;
d895 2
a896 1
		newstate = empty ? CS__ef  : CS__cf;	break;
d898 1
a898 1
		newstate = empty ? CS__ef  : CS__ef; /* ##579??? !!!!! */
d920 2
a921 2
			me->fixed_line = YES; /* type=c def of fixed_line */
			me->Line = lastcell->cLine; /* should've happened in break */
d929 4
a932 3
		newstate = empty ? CS__cf  : CS__cbc;	break;
	    case CS__ef:		/* ignored error */
	    case CS__cf:		/* ignored error */
d943 2
a944 1
		newstate = empty ? CS_invalid : CS__cbc;	break;
d946 1
a946 1
		lastcell->len = 0; /* ##613 */
d956 3
a958 2
		s->pending_len = 0; /* ##629 v */
		newstate = empty ? CS_invalid : CS__cbc;	break;
d961 1
a961 1
    } else {				/* (!multiline) */
d969 1
a969 1
		ret = 0; /* or 0 for xlen to s->pending_len?? */
d982 1
a982 1
		if (!empty && s->prev_state == CS__cbc)	/* ##609: */
d986 1
a986 1
			me->fixed_line = YES; /* type=d def of fixed_line */
d1006 2
a1007 1
		newstate = empty ? CS__eb : CS__ebc;	break;
d1009 2
a1010 1
		newstate = empty ? CS__cb : CS__cbc;	break;
d1030 2
a1031 1
		newstate = empty ? CS__0ef  : CS__0cf;	break; /* ##630 */
d1033 2
a1034 1
		newstate = empty ? CS__0ef : CS__0ef;	break; /* ??? */
d1036 2
a1037 1
		newstate = empty ? CS__0cf : CS__cbc;	break; /* ??? */
d1039 2
a1040 1
		newstate = CS__0ef;			break; /* ??? */
d1047 1
a1047 1
		if (!empty) { /* ##642_set_fixed!: */
d1049 1
a1049 1
			me->fixed_line = YES; /* type=e def of fixed_line */
d1058 1
a1058 1
		newstate = empty ? CS__ef  : CS__cf;
d1064 2
a1065 1
		newstate = empty ? CS__ef  : CS__cf;	break; /* ??? */
d1067 4
a1070 3
		newstate = empty ? CS__cf  : CS__cf;	break; /* ??? */
	    case CS__ef:		/* ignored error */
	    case CS__cf:		/* ignored error */
d1075 2
a1076 2
	} /* if (!end_td) ... else */
    } /* if (multiline) ... else */
d1083 1
a1083 1
	    ret = 0; /* XXXX Hack to allow trailing <P> in multiline cells. */
d1091 1
a1091 1
		  cellstate_s(s->prev_state), cellstate_s(s->state), ret));
d1096 4
a1099 4
 *  Reserve cells, each of given colspan, in (rowspan-1) rows after
 *  the current row of rowspan>1.  If rowspan==0, use special 'row'
 *  rowspans2eog to keep track of rowspans that are to remain in effect
 *  until the end of the row group (until next THEAD/TFOOT/TBODY) or table.
d1101 4
a1104 5
static int Stbl_reserveCellsInTable (
    STable_info *	me,
    int		icell,
    int		colspan,
    int		rowspan)
d1106 1
a1106 3
    STable_rowinfo *rows, *row;
    int growby;
    int i;
d1112 3
a1114 2
	    (tfp, "TRST:Stbl_reserveCellsInTable(icell=%d, colspan=%d, rowspan=%d)\n",
		  icell, colspan, rowspan));
d1118 1
d1127 7
a1133 33
    growby = me->nrows + rowspan - 1 - me->allocated_rows;
    if (growby > 0) {
	rows = realloc(me->rows,
		       (me->allocated_rows + growby)
		       * sizeof(STable_rowinfo));
	if (!rows)
	    return 0; /* ignore silently, no free memory, may be recoverable */
	for (i = 0; i < growby; i++) {
	    row = rows + me->allocated_rows + i;
	    row->allocated = 0;
	    row->offset = 0;
	    row->content = 0;
	    if (!me->rowspans2eog.allocated) {
		row->cells = NULL;
	    } else {
		row->cells = typecallocn(STable_cellinfo,
					 me->rowspans2eog.allocated);
		if (row->cells) {
		    row->allocated = me->rowspans2eog.allocated;
		    memcpy(row->cells, me->rowspans2eog.cells,
			   row->allocated * sizeof(STable_cellinfo));
		}
	    }
	    row->ncells = 0;
	    row->fixed_line = NO;
	    row->alignment = HT_ALIGN_NONE;
	}
	me->allocated_rows += growby;
	me->rows = rows;
    }
    for (i = me->nrows;
	 i < (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
	 i++) {
d1136 1
d1149 1
a1149 2
static void Stbl_cancelRowSpans (
    STable_info *	me)
d1155 1
a1155 1
	if (!me->rows[i].ncells) { /* should always be the case */
d1167 3
a1169 4
int Stbl_addRowToTable (
    STable_info *	me,
    int		alignment,
    int		lineno)
d1171 1
a1171 2
    STable_rowinfo *rows, *row;
    STable_states * s = &me->s;
d1175 2
a1176 2
		  alignment, lineno));
    if (me->nrows > 0 && me->rows[me->nrows-1].ncells > 0) {
d1178 2
a1179 1
	    me->rows[me->nrows-1].cells[me->rows[me->nrows-1].ncells - 1].len = s->pending_len;
d1182 3
a1184 3
    Stbl_finishRowInTable(me);
    if (me->nrows > 0 && me->rows[me->nrows-1].Line == lineno)
	me->rows[me->nrows-1].Line = -1;
d1188 2
a1189 44
    {
	int i;
	int growby = 0;
	while (me->nrows + 2 > me->allocated_rows + growby)
	    growby += ROWS_GROWBY;
	if (growby) {
	    if (me->allocated_rows == 0 && !me->rows) {
		rows = typecallocn(STable_rowinfo, growby);
	    } else {
		rows = realloc(me->rows,
				  (me->allocated_rows + growby)
				  * sizeof(STable_rowinfo));
		for (i = 0; rows && i < growby; i++) {
		    row = rows + me->allocated_rows + i;
		    if (!me->rowspans2eog.allocated) {
			row->allocated = 0;
			row->cells = NULL;
		    } else {
			row->cells = typecallocn(STable_cellinfo,
						 me->rowspans2eog.allocated);
			if (row->cells) {
			    row->allocated = me->rowspans2eog.allocated;
			    memcpy(row->cells, me->rowspans2eog.cells,
				   row->allocated * sizeof(STable_cellinfo));
			} else {
			    FREE(rows);
			    break;
			}
		    }
		    row->ncells = 0;
		    row->fixed_line = NO;
		    row->alignment = HT_ALIGN_NONE;
		    row->offset = 0;
		    row->content = 0;
		}
	    }
	    if (rows) {
		me->allocated_rows += growby;
		me->rows = rows;
	    } else {
		return -1;
	    }
	}
    }
d1198 50
a1247 2
	    (me->rowgroup_align==HT_ALIGN_NONE) ?
				  me->alignment : me->rowgroup_align;
d1253 2
a1254 2
    me->rows[me->nrows].Line = -1; /* not yet used */
    me->rows[me->nrows].ended = ROW_not_ended; /* No </tr> yet */
d1261 1
a1261 2
static int Stbl_finishRowInTable (
    STable_info *	me)
d1264 1
a1264 1
    STable_states * s = &me->s;
d1267 1
a1267 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishRowInTable()\n"));
d1272 2
a1273 1
    lastrow->ended = ROW_ended_by_endtr;
d1289 7
a1295 8
static void update_sumcols0 (
    STable_cellinfo *	sumcols,
    STable_rowinfo *	lastrow,
    int		pos,
    int		len,
    int		icell,
    int		ispan,
    int		allocated_sumcols)
d1298 1
d1303 1
d1307 4
a1310 2
	    if (sumcols[icell+ispan-1].pos + sumcols[icell+ispan-1].len > sumpos)
		sumpos = sumcols[icell+ispan-1].pos + sumcols[icell+ispan-1].len;
d1320 2
a1321 1
					    sumcols[i-1].pos + sumcols[i-1].len
d1338 5
a1342 6
static int get_remaining_colspan (
    STable_rowinfo *	me,
    STable_cellinfo *	colinfo,
    int		ncolinfo,
    int		colspan,
    int		ncols_sofar)
d1346 1
a1346 1
	me->cells[me->ncells - 1].colspan : 1;
d1362 4
a1365 5
static int Stbl_fakeFinishCellInTable (
    STable_info *	me,
    STable_rowinfo *	lastrow,
    int		lineno,
    int		finishing)	/* Processing finish or start */
d1367 1
a1367 1
    STable_states * s = &me->s;
d1370 1
a1370 1
    switch (s->state) {			/* We care only about trailing <BR> */
d1383 1
a1383 1
	if (finishing==0)
d1385 1
a1385 1
	break;		/* Either can't happen, or may be ignored */
d1401 2
a1402 2
	int rs = 1;			/* XXXX How to find rowspan? */
	int ih = 0;			/* XXXX How to find is_header? */
d1408 1
d1411 8
a1418 2
		(tfp, "TRST:Stbl_fakeFinishCellInTable(lineno=%d, finishing=%d) START FAKING\n",
		      lineno, finishing));
d1425 1
a1425 1
	if (finishing) {
d1433 1
a1433 1
	/* Stbl_finishCellInTable(lineno, 0, 0);*/ /* Needed? */
d1441 4
d1473 1
a1473 1
		return -1; /* ignore silently, no free memory, may be recoverable */
d1481 1
d1487 1
d1493 1
d1517 4
a1520 1
		      ncells, (finishing ? ", last unfinished" : "")));
d1524 1
a1524 1
	    if (Stbl_addCellToTable(me, (i==ncells ? cs : 1), rs, al,
d1528 1
a1528 1
	    lastrow->content &= ~HAS_BEG_OF_CELL; /* BEG_OF_CELL was fake */
d1531 1
a1531 1
	    if (!finishing || (i != ncells)) {
d1538 3
a1540 2
		(tfp, "TRST:Stbl_fakeFinishCellInTable(lineno=%d) FINISH FAKING\n",
		      lineno));
d1542 2
a1543 1
    }
d1551 8
a1558 9
int Stbl_addCellToTable (
    STable_info *	me,
    int		colspan,
    int		rowspan,
    int		alignment,
    int		isheader,
    int		lineno,
    int		offset_not_used_yet GCC_UNUSED,
    int		pos)
d1560 1
a1560 1
    STable_states * s = &me->s;
d1566 3
a1568 2
	    (tfp, "TRST:Stbl_addCellToTable(lineno=%d, pos=%d, isheader=%d, cs=%d, rs=%d, al=%d)\n",
		  lineno, pos, (int)isheader, colspan, rowspan, alignment));
d1571 1
a1571 1
				/* ##850_fail_if_fail?? */
d1582 2
a1583 2
	    && lastrow->cells[lastrow->ncells-1].cLine != lineno) {
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 0);
d1614 1
d1624 1
d1627 1
a1627 1
		    sumcol->pos = sumcols[me->allocated_sumcols-1].pos;
d1649 1
a1649 1
	sumpos += me->sumcols[ncells-1].pos - lastrow->cells[ncells-1].pos;
d1651 2
a1652 1
		    sumpos - (ncells > 0 ? me->sumcols[icell].pos : me->sumcols[icell].pos),
d1655 1
a1655 1
    me->maxpos = me->sumcols[me->allocated_sumcols-1].pos;
d1661 130
d1794 5
a1798 6
int Stbl_finishCellInTable (
    STable_info *	me,
    int		end_td,
    int		lineno,
    int		offset,
    int		pos)
d1800 1
a1800 1
    STable_states * s = &me->s;
d1806 3
a1808 2
	    (tfp, "TRST:Stbl_finishCellInTable(lineno=%d, pos=%d, off=%d, end_td=%d)\n",
		  lineno, pos, offset, (int)end_td));
a1819 1

d1823 9
a1831 1
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 1);
d1845 1
a1845 1
    xlen = (len > 0) ? len : s->pending_len; /* ##890 use xlen if fixed_line?: */
d1857 1
d1865 1
a1865 1
			     me->sumcols[i+1].pos - me->sumcols[icell].pos);
d1884 1
a1884 1
	me->maxpos = me->sumcols[me->allocated_sumcols-1].pos;
d1892 1
a1892 2

#ifdef EXP_NESTED_TABLES /* maxlen may already include contribution of a cell in this column */
d1916 4
a1919 5
int Stbl_addColInfo (
    STable_info *	me,
    int		colspan,
    short		alignment,
    BOOL		isgroup)
d1926 1
a1926 1
		  colspan, alignment, (int)isgroup));
d1932 1
a1932 1
	    me->sumcols[me->ncolinfo -  1].cLine = EOCOLG;
d1946 1
d1956 1
d1959 1
a1959 1
		    sumcol->pos = sumcols[me->allocated_sumcols-1].pos;
d1974 1
a1974 1
    if (alignment==HT_ALIGN_NONE)
d1985 1
a1985 2
int Stbl_finishColGroup (
    STable_info *	me)
d1991 1
a1991 1
	    me->sumcols[me->ncolinfo -  1].cLine = EOCOLG;
d1998 2
a1999 3
int Stbl_addRowGroup (
    STable_info *	me,
    short		alignment)
d2007 1
a2007 2
int Stbl_finishTABLE (
    STable_info *	me)
d2009 1
a2009 1
    STable_states * s = &me->s;
d2017 1
a2017 1
    if (me->nrows > 0 && me->rows[me->nrows-1].ncells > 0) {
d2019 2
a2020 1
	    me->rows[me->nrows-1].cells[me->rows[me->nrows-1].ncells - 1].len = s->pending_len;
d2023 1
a2023 1
    Stbl_finishRowInTable(me);
d2035 2
a2036 1
	if ((nextrow->content & (IS_CONTINUATION_OF_CELL | HAS_BEG_OF_CELL | BELIEVE_OFFSET))
d2038 4
a2041 3
	    continue;			/* Not a continuation line */
	minoffset = nextrow[-1].offset;	/* Line before first continuation */
	CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
d2046 2
a2047 1
	       && ((nextrow->content & (IS_CONTINUATION_OF_CELL | HAS_BEG_OF_CELL | BELIEVE_OFFSET))
d2051 2
a2052 1
	    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
d2057 1
a2057 1
	i = j - 1;			/* Continue after this line */
d2059 2
a2060 2
	j = leading;			/* Restart */
	nextrow = me->rows + j;		/* Line before first continuation */
d2063 1
a2063 1
	while (j <= i) {		/* A continuation line */
d2072 1
a2072 1
	    continue;			/* No offsets to deal with */
d2076 3
a2078 3
	j = leading + 1;		/* Restart */
	nextrow = me->rows + j;		/* First continuation line */
	while (foundcell == -1 && j <= i) { /* A continuation line */
d2087 1
a2087 1
	if (foundcell == -1)		/* Can it happen? */
d2091 3
a2093 3
	j = leading;			/* Restart */
	nextrow = me->rows + j;		/* Include the pre-continuation line */
	while (j <= i) {		/* A continuation line */
d2104 1
a2104 1
	j = non_empty;			/* Restart from the first nonempty */
d2108 1
a2108 1
			0 /* width only */, max_width,
d2111 1
a2111 1
	j = leading;			/* Restart from pre-continuation */
d2113 1
a2113 1
	while (j <= i) {		/* A continuation line */
d2119 1
a2119 1
    }					/* END of Offsets processing */
d2136 1
a2136 2
short Stbl_getAlignment (
    STable_info *	me)
d2138 1
a2138 1
    return (short)(me ? me->alignment : HT_ALIGN_NONE);
d2141 9
a2149 5
static int get_fixup_positions (
    STable_rowinfo *	me,
    int *		oldpos,
    int *		newpos,
    STable_cellinfo *	sumcols)
d2154 3
d2160 4
d2165 1
a2165 1
	int offset;
a2173 1
	oldpos[ip] = me->cells[i].pos;
d2180 1
a2180 1
	newpos[ip] = sumcols[i].pos + offset;
d2184 1
a2184 1
	    newlen = sumcols[next_i].pos - newpos[ip] - 1;
d2188 1
a2188 1
		    newpos[ip] += newlen - me->cells[i].len;
d2190 1
a2190 1
		    newpos[ip] += (newlen - me->cells[i].len) / 2;
d2194 14
d2216 3
a2218 3
 *  Returns -1 if we have no row for this lineno, or for other error,
 *           0 or greater (number of oldpos/newpos pairs) if we have
 *             a table row.
d2220 9
a2228 5
int Stbl_getFixupPositions (
    STable_info *	me,
    int		lineno,
    int *		oldpos,
    int *		newpos)
d2230 1
a2230 1
    STable_rowinfo * row;
d2232 3
a2234 1
    int ninserts = -1;
d2237 5
a2241 1
    for (j = 0; j < me->nrows; j++) {
d2244 2
d2247 3
a2249 1
					   me->sumcols);
d2253 2
d2258 1
a2258 2
int Stbl_getStartLine (
    STable_info *	me)
d2268 1
a2268 2
int Stbl_getStartLineDeep (
    STable_info *	me)
d2277 3
a2279 4
void Stbl_update_enclosing (
    STable_info *	me,
    int		max_width,
    int		last_lineno)
d2285 3
a2287 2
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",
	    max_width, me->startline, last_lineno));
d2290 2
a2291 1
	if (Stbl_finishCellInTable(me->enclosing, TRST_ENDCELL_LINEBREAK, l, 0, max_width) < 0) {
d2293 1
a2293 1
	       and it does not buy us anything.	 Do it directly. */
d2296 2
a2297 1
	    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_update_enclosing: width too large, aborting enclosing\n"));
d2301 1
d2311 3
a2313 4
void Stbl_set_enclosing (
    STable_info *	me,
    STable_info *	enclosing,
    struct _TextAnchor*enclosing_last_anchor_before_stbl)
d2321 1
a2321 2
STable_info * Stbl_get_enclosing (
    STable_info *	me)
d2328 1
a2328 2
struct _TextAnchor * Stbl_get_last_anchor_before (
    STable_info *	me)
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d202 1
a202 1
PRIVATE int Stbl_finishCellInRow PARAMS((
d207 3
a209 3
    int			pos));
PRIVATE int Stbl_finishRowInTable PARAMS((
    STable_info *	me));
d211 2
a212 2
PRIVATE CONST char * cellstate_s ARGS1(
	cellstate_t,	state)
d214 1
a214 1
    CONST char *result = "?";
d234 2
a235 2
PUBLIC struct _STable_info * Stbl_startTABLE ARGS1(
    short,		alignment)
d255 2
a256 2
PRIVATE void free_rowinfo ARGS1(
    STable_rowinfo *,	me)
d263 2
a264 2
PUBLIC void Stbl_free ARGS1(
    STable_info *,	me)
d283 10
a292 10
PRIVATE int Stbl_addCellToRow ARGS9(
    STable_rowinfo *,	me,
    STable_cellinfo *,	colinfo,
    int,		ncolinfo,
    STable_states *,	s,
    int,		colspan,
    int,		alignment,
    int,		isheader,
    int,		lineno,
    int *,		ppos)
d516 4
a519 4
PRIVATE int Stbl_reserveCellsInRow ARGS3(
    STable_rowinfo *,	me,
    int,		icell,
    int,		colspan)
d554 6
a559 6
PRIVATE int Stbl_finishCellInRow ARGS5(
    STable_rowinfo *,	me,
    STable_states *,	s,
    int,		end_td,
    int,		lineno,
    int,		pos)
d945 5
a949 5
PRIVATE int Stbl_reserveCellsInTable ARGS4(
    STable_info *,	me,
    int,		icell,
    int,		colspan,
    int,		rowspan)
d1019 2
a1020 2
PRIVATE void Stbl_cancelRowSpans ARGS1(
    STable_info *,	me)
d1038 4
a1041 4
PUBLIC int Stbl_addRowToTable ARGS3(
    STable_info *,	me,
    int,		alignment,
    int,		lineno)
d1127 2
a1128 2
PRIVATE int Stbl_finishRowInTable ARGS1(
    STable_info *,	me)
d1155 8
a1162 8
PRIVATE void update_sumcols0 ARGS7(
    STable_cellinfo *,	sumcols,
    STable_rowinfo *,	lastrow,
    int,		pos,
    int,		len,
    int,		icell,
    int,		ispan,
    int,		allocated_sumcols)
d1200 6
a1205 6
PRIVATE int get_remaining_colspan ARGS5(
    STable_rowinfo *,	me,
    STable_cellinfo *,	colinfo,
    int,		ncolinfo,
    int,		colspan,
    int,		ncols_sofar)
d1225 5
a1229 5
PRIVATE int Stbl_fakeFinishCellInTable ARGS4(
    STable_info *,	me,
    STable_rowinfo *,	lastrow,
    int,		lineno,
    int,		finishing)	/* Processing finish or start */
d1396 9
a1404 9
PUBLIC int Stbl_addCellToTable ARGS8(
    STable_info *,	me,
    int,		colspan,
    int,		rowspan,
    int,		alignment,
    int,		isheader,
    int,		lineno,
    int,		offset_not_used_yet GCC_UNUSED,
    int,		pos)
d1506 6
a1511 6
PUBLIC int Stbl_finishCellInTable ARGS5(
    STable_info *,	me,
    int,		end_td,
    int,		lineno,
    int,		offset,
    int,		pos)
d1621 5
a1625 5
PUBLIC int Stbl_addColInfo ARGS4(
    STable_info *,	me,
    int,		colspan,
    short,		alignment,
    BOOL,		isgroup)
d1689 2
a1690 2
PUBLIC int Stbl_finishColGroup ARGS1(
    STable_info *,	me)
d1703 3
a1705 3
PUBLIC int Stbl_addRowGroup ARGS2(
    STable_info *,	me,
    short,		alignment)
d1713 2
a1714 2
PUBLIC int Stbl_finishTABLE ARGS1(
    STable_info *,	me)
d1838 2
a1839 2
PUBLIC short Stbl_getAlignment ARGS1(
    STable_info *,	me)
d1844 5
a1848 5
PRIVATE int get_fixup_positions ARGS4(
    STable_rowinfo *,	me,
    int *,		oldpos,
    int *,		newpos,
    STable_cellinfo *,	sumcols)
d1899 5
a1903 5
PUBLIC int Stbl_getFixupPositions ARGS4(
    STable_info *,	me,
    int,		lineno,
    int *,		oldpos,
    int *,		newpos)
d1921 2
a1922 2
PUBLIC int Stbl_getStartLine ARGS1(
    STable_info *,	me)
d1932 2
a1933 2
PUBLIC int Stbl_getStartLineDeep ARGS1(
    STable_info *,	me)
d1942 4
a1945 4
PUBLIC void Stbl_update_enclosing ARGS3(
    STable_info *,	me,
    int,		max_width,
    int,		last_lineno)
d1973 4
a1976 4
PUBLIC void Stbl_set_enclosing ARGS3(
    STable_info *,	me,
    STable_info *,	enclosing,
    struct _TextAnchor*,enclosing_last_anchor_before_stbl)
d1984 2
a1985 2
PUBLIC STable_info * Stbl_get_enclosing ARGS1(
    STable_info *,	me)
d1992 2
a1993 2
PUBLIC struct _TextAnchor * Stbl_get_last_anchor_before ARGS1(
    STable_info *,	me)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d20 1
a20 2
#define ROWS_GROWBY_DIVISOR 2
#else  /* This is very silly, and leads to *larger* memory consumption... */
a22 1
#define ROWS_GROWBY_DIVISOR 10
a24 6
#define  REUSE_ROWS_AS_CELLS_POOLS 0	/* Turns out to be not beneficial */

/* Experiments show that 2 is better than 1.5 is better than 1.25 (all by
   a small margin only)??? */
#define CELLS_GROWBY_FACTOR 2

d74 4
a77 4
	short	pos;		/* column where cell starts */
	short	len;		/* number of character positions */
	short	colspan;	/* number of columns to span */
	short	alignment;	/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
a92 1
#define IS_CONTINUATION_OF_MULTICELL	0x40
d98 1
a98 1
	short	ncells;		/* number of table cells */
d122 1
a122 1
	short	fixed_line;	/* if we have a 'core' line of cells */
d124 3
a126 5
	short	content;	/* Whether contains end-of-cell etc */
	short	offset;		/* >=0 after line break in a multiline cell */
	short	allocated;	/* number of table cells allocated or 0
				   if the .cells should not be free()ed */
	short	alignment;	/* global align attribute for this row */
d128 1
a130 9
struct _STable_chunk;
typedef struct _STable_chunk {
    struct _STable_chunk *next;
    int alloc_cells;
    int used_cells;
    STable_cellinfo cells[1];
} STable_chunk;


d143 1
a143 2
	int	ncolinfo;	/* number of COL info collected */
	int	last_reserved;	/* -1 or last line with reserved cells */
a151 2
	STable_chunk *free_chunks;
	STable_chunk *used_chunks;
d208 1
a208 1
PRIVATE int Stbl_DOfinishRowInTable PARAMS((
a246 1
	me->last_reserved = -1;
a250 1
	me->used_chunks = me->free_chunks = NULL;
a262 89
PRIVATE int addmem_rowinfo ARGS2(
    STable_info *,	me,
    int,		incr)
{
    int i;
    int growby = 0;
    STable_rowinfo *rows, *row;

    while (me->nrows + incr + 1 > me->allocated_rows + growby)
	growby += ROWS_GROWBY + me->allocated_rows/ROWS_GROWBY_DIVISOR;
    if (growby) {
	if (me->allocated_rows == 0 && !me->rows) {
	    rows = typecallocn(STable_rowinfo, growby);
	} else {
#if REUSE_ROWS_AS_CELLS_POOLS		/* Turns out to be not beneficial */
	    /* Work in a regime which has a chance to work efficiently
	       even with lousy malloc()s: do not realloc() until we
	       have many (2) free chunks available (possible with very
	       simple structure of each row).  Simultaneously,
	       make it possible to use an effecient realloc() which
	       would grow the region in place - so DO use realloc() if
	       we already have many free chunks to put the cellinfo into.
	     */
	    if ( me->free_chunks && me->free_chunks->next
		 || (me->allocated_rows*sizeof(STable_rowinfo) <
		    (sizeof(STable_chunk)
		     + (CELLS_GROWBY-1)*sizeof(STable_cellinfo)))
		 || 1)
#endif
	    {
		rows = realloc(me->rows,
			       (me->allocated_rows + growby)
			       * sizeof(STable_rowinfo));
	    }
#if REUSE_ROWS_AS_CELLS_POOLS
	    else {
		rows = malloc((me->allocated_rows + growby)
			      * sizeof(STable_rowinfo));
		if (rows) {
		    STable_chunk *p;

		    memcpy(rows, me->rows,
			   (me->allocated_rows + growby)
			   * sizeof(STable_rowinfo));
		    p = (STable_chunk*)me->rows;
		    p->alloc_cells =
			1 + (me->allocated_rows*sizeof(STable_rowinfo)
			     - sizeof(STable_chunk))/sizeof(STable_cellinfo);
		    p->used_cells = 0;
		    p->next = me->free_chunks;
		    me->free_chunks = p;
		}
	    }
#endif
	    for (i = 0; rows && i < growby; i++) {
		row = rows + me->allocated_rows + i;
		if (!me->rowspans2eog.allocated) {
		    row->allocated = 0;
		    row->cells = NULL;
		} else {
		    row->cells = typecallocn(STable_cellinfo,
					     me->rowspans2eog.allocated);
		    if (row->cells) {
			row->allocated = me->rowspans2eog.allocated;
			memcpy(row->cells, me->rowspans2eog.cells,
			       row->allocated * sizeof(STable_cellinfo));
		    } else {
			FREE(rows);
			break;
		    }
		}
		row->ncells = 0;
		row->fixed_line = NO;
		row->alignment = HT_ALIGN_NONE;
		row->offset = 0;
		row->content = 0;
	    }
	}
	if (rows) {
	    me->allocated_rows += growby;
	    me->rows = rows;
	} else {
	    return 0;
	}
    }
    return 1;
}


a276 11
    if (me) {
	STable_chunk *this;
	while ((this = me->free_chunks)) {
	    me->free_chunks = this->next;
	    FREE(this);
	}
	while ((this = me->used_chunks)) {
	    me->used_chunks = this->next;
	    FREE(this);
	}
    }
d951 3
a953 1
    int i, last;
d972 33
a1004 7
    if (!addmem_rowinfo(me, rowspan - 1))
	return 0; /* ignore silently, no free memory, may be recoverable */

    last = (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
    if (me->last_reserved < last)
	me->last_reserved = last;
    for (i = me->nrows; i < last; i++) {
d1043 1
d1054 1
a1054 1
    Stbl_DOfinishRowInTable(me);
d1060 44
a1103 2
    if (!addmem_rowinfo(me, 1))
	return -1;
a1113 43
    if (me->nrows >= 2	/* We may use RESERVEDCELL flag of cells in nrows-1 */
	&& me->rows[me->nrows - 2].allocated > me->rows[me->nrows - 2].ncells) {
	int c = me->rows[me->nrows - 2].ncells;
	STable_cellinfo *p  = me->rows[me->nrows - 2].cells;

#if 0	/* Leads to no memory savings and quadratic time with EMX malloc */
	/* Do not need extra cells any more */
	me->rows[me->nrows - 2].cells = realloc(p,c * sizeof(STable_cellinfo));
	me->rows[me->nrows - 2].allocated = me->rows[me->nrows - 2].ncells;
#else
	if (!me->used_chunks
	    || ((me->used_chunks->alloc_cells - me->used_chunks->used_cells)
		< c)) {
	    if (me->free_chunks && (me->free_chunks->alloc_cells >= c)) {
	        STable_chunk *p2 = me->free_chunks;

		me->free_chunks = p2->next;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    } else {			/* Need to get a new guy */
	        STable_chunk *p2;

		if (c < CELLS_GROWBY)
		    c = CELLS_GROWBY;
		if ( me->used_chunks
		     && c < me->used_chunks->alloc_cells*CELLS_GROWBY_FACTOR )
		    c = 2*me->used_chunks->alloc_cells * CELLS_GROWBY_FACTOR;
		p2 = malloc(sizeof(STable_chunk) + (c-1)*sizeof(STable_cellinfo));
		p2->alloc_cells = c;
		p2->used_cells = 0;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    }
	}
	memcpy(me->used_chunks->cells + me->used_chunks->used_cells,
	       p, me->rows[me->nrows - 2].ncells * sizeof(STable_cellinfo));
	me->rows[me->nrows - 2].cells =
	    me->used_chunks->cells + me->used_chunks->used_cells;
	me->used_chunks->used_cells += me->rows[me->nrows - 2].ncells;
	me->rows[me->nrows - 2].allocated = 0; /* Do not FREE() */
	FREE(p);
#endif
    }
d1127 1
a1127 1
PRIVATE int Stbl_DOfinishRowInTable ARGS1(
d1134 1
a1134 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_DOfinishRowInTable()\n"));
d1139 1
a1139 2
    if (lastrow->ended != ROW_ended_by_splitline)
	lastrow->ended = ROW_ended_by_endtr;
a1271 1
	int is_multicell = 0;
a1276 5
	if ( lastrow->ncells > 1
	     && (lastrow->cells[lastrow->ncells - 2].pos
		 != lastrow->cells[lastrow->ncells - 1].pos))
	    is_multicell = 1;

a1297 4
	if (is_multicell)
	    lastrow->content = IS_CONTINUATION_OF_MULTICELL;
	else
	    lastrow->content = IS_CONTINUATION_OF_CELL;
a1333 1
	    me->last_reserved++;
a1338 1
	    lastrow[1].content = 0;
a1502 110
PUBLIC BOOL Stbl_at_start_of_cell ARGS3(
    STable_info *,	me,
    int,		lineno,
    int,		pos)
{
    STable_rowinfo *lastrow;
    int icell;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_at_start_of_cell(lineno=%d, pos=%d): ",
		  lineno, pos));
    if (me->nrows == 0)
	goto yes;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended != ROW_not_ended)
	goto no;			/* E.g., may be processing </tr> */
    icell = lastrow->ncells - 1;
    if (icell < 0)
	goto yes;
    if (lastrow->cells[icell].cLine != lineno
	|| lastrow->cells[icell].pos != pos) {
      no:
	CTRACE2(TRACE_TRST, (tfp, "no\n"));
	return FALSE;			/* XXXX  What to do if cLine is -1? */
    }
  yes:
    CTRACE2(TRACE_TRST, (tfp, "yes\n"));
    return TRUE;
}

PUBLIC void Stbl_finishRowInTable ARGS1(
    STable_info *,	me)
{
    STable_rowinfo *lastrow;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_finishRowInTable()\n"));
    if (me->nrows <= 0)
	return;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended == ROW_not_ended)
	lastrow->ended = ROW_ended_by_endtr;
}

/* Assumes that the current pos is at beginning of line.
   Checks whether the last row was a fake row, and undo it if possible.
   Returns TRUE if the last line (empty!) can be safely trimmed. */
PUBLIC int Stbl_trimFakeRows ARGS3(
    STable_info *,	me,
    int,		lineno,
    int,		pos GCC_UNUSED)
{
    STable_rowinfo *prevrow, *lastrow;
    int icell;

    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_trimFakeRows()\n"));

    /* XXXX The logic may be much better if we support removal of
       RESERVED cells.  Until this is done, bail out early: */
    if (me->nrows <= 0 || me->nrows <= me->last_reserved)
	return 0;
    lastrow = me->rows + (me->nrows - 1);
    icell = lastrow->ncells - 1;
    if (icell >= 0 && lastrow->cells[icell].cLine < lineno) {
	/* The last cell start on a preceeding line; keep lastrow */
	lastrow->ended = ROW_not_ended; /* Give it new life */
	/* We do not use state info for a lot of things any more, so do
	   not try to do anything special here */
	me->s.state = CS__0new;		/* This is enough to revive things. */
	me->s.x_td = lastrow->cells[lastrow->ncells - 1].pos;
	me->s.lineno = lastrow->cells[lastrow->ncells - 1].cLine;
	CTRACE2(TRACE_TRST, (tfp, "  un-ended the last row.\n"));
	return 1;
    }
    if (me->nrows <= 1 || !(lastrow->content & IS_CONTINUATION_OF_CELL))
	return 0;
    prevrow = me->rows + (me->nrows - 2);
    if (prevrow->ncells != icell + 1)	/* Empty cells were added after the break */
	return 0;
    if ( prevrow->ended != ROW_ended_by_splitline) /* Lastrow non-fake */
	return 0;
    me->nrows--;
    /* prevrow is now the last row, so its cells should be realloc()able */
    if (prevrow->cells && prevrow->allocated == 0) { /* Moved to pool */
	int c = prevrow->ncells;
	STable_cellinfo *p;

	if (lastrow->allocated > c)	/* May have RESERVED info */
	    c = lastrow->allocated;
	p = malloc(c * sizeof(STable_cellinfo));
	memcpy(p, prevrow->cells, prevrow->ncells * sizeof(STable_cellinfo));
	/* Copy back the possibly present RESERVED info.
	   XXXX remove duplicated RESERVED stuff from the followup rows too! */
	memcpy(p + prevrow->ncells, lastrow->cells + prevrow->ncells,
	       (c - prevrow->ncells) * sizeof(STable_cellinfo));
	prevrow->cells = p;	/* XXXX How would ride with RESERVED? */
	prevrow->allocated = c;
    }
    lastrow->ncells = 0;
    lastrow->content = 0;
    prevrow->ended = ROW_not_ended;	/* Give it new life */
    /* We do not use state info for a lot of things any more, so do
       not try to do anything special here */
    me->s.state = CS__0new;
    me->s.x_td = prevrow->cells[prevrow->ncells - 1].pos;
    me->s.lineno = prevrow->cells[prevrow->ncells - 1].cLine;
    CTRACE2(TRACE_TRST, (tfp, "  Removed the last row.\n"));
    return 1;
}

d1729 1
a1729 1
    Stbl_DOfinishRowInTable(me);
a1907 2
    static int prev_row = 0;

d1910 1
a1910 5
    if (prev_row < me->nrows && me->rows[prev_row].Line <= lineno)
	j = prev_row;
    else
	j = 0;
    for ( ; j < me->nrows; j++) {
a1912 1
	    prev_row = j;
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d20 2
a21 1
#else
d24 1
d27 6
d82 4
a85 4
	int	pos;		/* column where cell starts */
	int	len;		/* number of character positions */
	int	colspan;	/* number of columns to span */
	int	alignment;	/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
d101 1
d107 1
a107 1
	int	ncells;		/* number of table cells */
d131 1
a131 1
	BOOL	fixed_line;	/* if we have a 'core' line of cells */
d133 5
a137 3
	int	content;	/* Whether contains end-of-cell etc */
	int	offset;		/* >=0 after line break in a multiline cell */
	int	allocated;	/* number of table cells allocated */
a138 1
	int	alignment;	/* global align attribute for this row */
d141 9
d162 2
a163 1
	int	ncolinfo;		/* number of COL info collected */
d172 2
d230 1
a230 1
PRIVATE int Stbl_finishRowInTable PARAMS((
d269 1
d274 1
d287 89
d390 11
d1075 1
a1075 3
    STable_rowinfo *rows, *row;
    int growby;
    int i;
d1094 7
a1100 33
    growby = me->nrows + rowspan - 1 - me->allocated_rows;
    if (growby > 0) {
	rows = realloc(me->rows,
		       (me->allocated_rows + growby)
		       * sizeof(STable_rowinfo));
	if (!rows)
	    return 0; /* ignore silently, no free memory, may be recoverable */
	for (i = 0; i < growby; i++) {
	    row = rows + me->allocated_rows + i;
	    row->allocated = 0;
	    row->offset = 0;
	    row->content = 0;
	    if (!me->rowspans2eog.allocated) {
		row->cells = NULL;
	    } else {
		row->cells = typecallocn(STable_cellinfo,
					 me->rowspans2eog.allocated);
		if (row->cells) {
		    row->allocated = me->rowspans2eog.allocated;
		    memcpy(row->cells, me->rowspans2eog.cells,
			   row->allocated * sizeof(STable_cellinfo));
		}
	    }
	    row->ncells = 0;
	    row->fixed_line = NO;
	    row->alignment = HT_ALIGN_NONE;
	}
	me->allocated_rows += growby;
	me->rows = rows;
    }
    for (i = me->nrows;
	 i < (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
	 i++) {
a1138 1
    STable_rowinfo *rows, *row;
d1149 1
a1149 1
    Stbl_finishRowInTable(me);
d1155 2
a1156 44
    {
	int i;
	int growby = 0;
	while (me->nrows + 2 > me->allocated_rows + growby)
	    growby += ROWS_GROWBY;
	if (growby) {
	    if (me->allocated_rows == 0 && !me->rows) {
		rows = typecallocn(STable_rowinfo, growby);
	    } else {
		rows = realloc(me->rows,
				  (me->allocated_rows + growby)
				  * sizeof(STable_rowinfo));
		for (i = 0; rows && i < growby; i++) {
		    row = rows + me->allocated_rows + i;
		    if (!me->rowspans2eog.allocated) {
			row->allocated = 0;
			row->cells = NULL;
		    } else {
			row->cells = typecallocn(STable_cellinfo,
						 me->rowspans2eog.allocated);
			if (row->cells) {
			    row->allocated = me->rowspans2eog.allocated;
			    memcpy(row->cells, me->rowspans2eog.cells,
				   row->allocated * sizeof(STable_cellinfo));
			} else {
			    FREE(rows);
			    break;
			}
		    }
		    row->ncells = 0;
		    row->fixed_line = NO;
		    row->alignment = HT_ALIGN_NONE;
		    row->offset = 0;
		    row->content = 0;
		}
	    }
	    if (rows) {
		me->allocated_rows += growby;
		me->rows = rows;
	    } else {
		return -1;
	    }
	}
    }
d1167 43
d1223 1
a1223 1
PRIVATE int Stbl_finishRowInTable ARGS1(
d1230 1
a1230 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishRowInTable()\n"));
d1235 2
a1236 1
    lastrow->ended = ROW_ended_by_endtr;
d1369 1
d1375 5
d1401 4
d1441 1
d1447 1
d1612 110
d1948 1
a1948 1
    Stbl_finishRowInTable(me);
d2127 2
d2131 5
a2135 1
    for (j = 0; j < me->nrows; j++) {
d2138 1
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 6
a7 6
 *		===================
 * Authors
 *	KW	Klaus Weide <kweide@@enteract.com>
 * History:
 *   2 Jul 1999	KW	Created.
 */
d26 1
a26 1
#  define MAX_STBL_POS (LYwideLines ? MAX_COLS - 1 : LYcolLimit)
d28 1
a28 1
#  define MAX_STBL_POS (LYcolLimit)
d44 1
a44 1
    CS__new = 0,
d59 6
a64 6
    cellstate_t prev_state;	/* Contents type of the previous cell */
    cellstate_t state;		/* Contents type of the worked-on cell */
    int lineno;			/* Start line of the current cell */
    int icell_core;		/* -1 or the 1st cell with <BR></TD> on row */
    int x_td;			/* x start pos of the current cell or -1 */
    int pending_len;		/* For multiline cells, the length of
d70 1
a70 1
    int cLine;			/* lineno in doc (zero-based): -1 for
d74 4
a77 4
    int pos;			/* column where cell starts */
    int len;			/* number of character positions */
    int colspan;		/* number of columns to span */
    int alignment;		/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
d82 3
a84 3
    ROW_not_ended,
    ROW_ended_by_endtr,
    ROW_ended_by_splitline
d97 2
a98 2
    int Line;			/* lineno in doc (zero-based) */
    int ncells;			/* number of table cells */
d101 1
a101 1
       [search for      def of fixed_line       below]
d111 1
a111 1
       (Notation: B: at BOL; L: last; E: the first row is non-empty)
d113 3
a115 3
       bcde:    !B && !E
       a1:      !L && !B
       a2:      !L && !E
d122 7
a128 7
    BOOL fixed_line;		/* if we have a 'core' line of cells */
    enum ended_state ended;	/* if we saw </tr> etc */
    int content;		/* Whether contains end-of-cell etc */
    int offset;			/* >=0 after line break in a multiline cell */
    int allocated;		/* number of table cells allocated */
    STable_cellinfo *cells;
    int alignment;		/* global align attribute for this row */
d133 2
a134 2
    struct _STable_info *enclosing;	/* The table which contain us */
    struct _TextAnchor *enclosing_last_anchor_before_stbl;
d136 16
a151 16
    int startline;		/* lineno where table starts (zero-based) */
    int nrows;			/* number of rows */
    int ncols;			/* number of rows */
    int maxlen;			/* sum of max. cell lengths of any row */
    int maxpos;			/* max. of max. cell pos's of any row */
    int allocated_rows;		/* number of rows allocated */
    int allocated_sumcols;	/* number of sumcols allocated */
    int ncolinfo;		/* number of COL info collected */
    STable_cellinfo *sumcols;	/* for summary (max len/pos) col info */
    STable_rowinfo *rows;
    STable_rowinfo rowspans2eog;
    short alignment;		/* global align attribute for this table */
    short rowgroup_align;	/* align default for current group of rows */
    short pending_colgroup_align;
    int pending_colgroup_next;
    STable_states s;
d155 55
a209 51
 *  Functions and structures in this source file keep track of positions.
 *  They don't know about the character data in those lines, or about
 *  the HText and HTLine structures.  GridText.c doesn't know about our
 *  structures.  It should stay that way.
 *
 *  The basic idea: we let the code in HTML.c/GridText.c produce and format
 *  output "as usual", i.e. as without Simple Table support.  We keep track
 *  of the positions in the generated output where cells and rows start (or
 *  end).  If all goes well, that preliminary output (stored in HText/HTLine
 *  structures) can be fixed up when the TABLE end tag is processed, by just
 *  inserting spaces in the right places (and possibly changing alignment).
 *  If all goes not well, we already have a safe fallback.
 *
 *  Note that positions passed to and from these functions should be
 *  in terms of screen positions, not just byte counts in a HTLine.data
 *  (cf. line->data vs. HText_TrueLineSize).
 *
 *  Memory is allocated dynamically, so we can have tables of arbitrary
 *  length.  On allocation error we just return and error indication
 *  instead of outofmem(), so caller can give up table tracking and maybe
 *  recover memory.
 *
 *  Implemented:
 *  - ALIGN={left,right,center,justify} applied to individual table cells
 *    ("justify" is treated as "left")
 *  - Inheritance of horizontal alignment according to HTML 4.0
 *  - COLSPAN >1 (may work incorrectly for some tables?)
 *  - ROWSPAN >1 (reserving cells in following rows)
 *  - Line breaks at start of first cell or at end of last cell are treated
 *    as if they were not part of the cell and row.  This allows us to
 *    cooperate with one way in which tables have been made friendly to
 *    browsers without any table support.
 *  Missing, but can be added:
 *  - Support for COLGROUP/COL
 *  - Tables wider than display.  The limitation is not here but in GridText.c
 *    etc.  If horizontal scrolling were implemented there, the mechanisms
 *    here coudl deal with wide tables (just change MAX_STBL_POS code).
 *  Missing, unlikely to add:
 *  - Support for non-LTR directionality.  A general problem, support is
 *    lacking throughout the lynx code.
 *  - Support for most other table-related attributes.  Most of them are
 *    for decorative purposes.
 *  Impossible or very unlikely (because it doesn't fit the model):
 *  - Any cell contents of more than one line, line breaks within cells.
 *    Anything that requires handling cell contents as paragraphs (block
 *    elements), like reflowing.  Vertical alignment.
 */
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
				int lineno,
				int pos);
static int Stbl_finishRowInTable(STable_info *me);
d211 2
a212 1
static const char *cellstate_s(cellstate_t state)
d214 2
a215 2
    const char *result = "?";
    /* *INDENT-OFF* */
a230 2
    /* *INDENT-ON* */

d234 2
a235 1
struct _STable_info *Stbl_startTABLE(short alignment)
d240 1
a240 1
	    (tfp, "TRST:Stbl_startTABLE(align=%d)\n", (int) alignment));
d255 2
a256 1
static void free_rowinfo(STable_rowinfo *me)
d263 2
a264 1
void Stbl_free(STable_info *me)
a269 1

d283 10
a292 7
static int Stbl_addCellToRow(STable_rowinfo *me, STable_cellinfo *colinfo, int ncolinfo,
			     STable_states *s,
			     int colspan,
			     int alignment,
			     int isheader,
			     int lineno,
			     int *ppos)
d297 1
a297 1
    me->cells[me->ncells - 1].colspan : 1;
d303 1
a303 1
	     lineno, *ppos, colspan));
d305 3
a307 4
	    (tfp,
	     " ncells=%d, stateLine=%d, pending_len=%d, pstate=%s, state=%s\n",
	     me->ncells, s->lineno, s->pending_len,
	     cellstate_s(s->prev_state), cellstate_s(s->state)));
d355 1
a355 1
	    } else {		/* last cell multiline, ncells != 0, pos != 0 */
d370 1
a370 1
		    me->fixed_line = YES;	/* type=a def of fixed_line i */
d376 1
a376 1
		    me->fixed_line = YES;	/* type=e def of fixed_line ii */
d390 1
a390 1
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */  +
d396 1
a396 1
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */  +
d407 1
a407 2
		*ppos = me->cells[me->ncells - 1].pos;
		break;
d445 1
a445 1
	me->ncells += me->cells[me->ncells - 1].colspan - 1;
a452 1

d459 3
a461 3
		cells = typeRealloc(STable_cellinfo, me->cells,
				      (me->allocated + growby));

d487 1
a487 1
	if (me->cells[me->ncells].alignment == HT_ALIGN_NONE)
d489 1
a489 1
	if (me->cells[me->ncells].alignment == HT_ALIGN_NONE)
d499 1
a499 1
    me->cells[me->ncells + colspan].pos = -1;	/* not yet used */
d506 1
a506 1
	     cellstate_s(s->prev_state), cellstate_s(s->state), ret));
d516 4
a519 2
static int Stbl_reserveCellsInRow(STable_rowinfo *me, int icell,
				  int colspan)
d527 1
a527 1
	     icell, colspan));
d529 3
a531 3
	cells = typeRealloc(STable_cellinfo, me->cells,
			      (me->allocated + growby));

d554 6
a559 3
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
				int lineno,
				int pos)
d567 2
a568 3
	    (tfp,
	     "TRST:Stbl_finishCellInRow line=%d pos=%d end_td=%d ncells=%d pnd_len=%d\n",
	     lineno, pos, (int) end_td, me->ncells, s->pending_len));
d577 3
a579 4
	    (tfp,
	     " [lines: lastCell=%d state=%d multi=%d] empty=%d (prev)state=(%s) %s\n",
	     lastcell->cLine, s->lineno, multiline, empty,
	     cellstate_s(s->prev_state), cellstate_s(s->state)));
d612 1
a612 1
		if (s->pending_len && empty) {	/* First line non-empty */
d617 2
a618 2
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cb : CS__cbc;	/* ##474_needs_len!=-1? */
d642 1
a642 1
		if (s->pending_len && empty) {	/* ##496: */
d645 1
a645 1
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
d649 2
a650 2
			me->fixed_line = YES;	/* type=b def of fixed_line i */
			me->Line = lastcell->cLine;	/* should've happened in break */
d657 2
a658 2
			me->fixed_line = YES;	/* type=b def of fixed_line ii */
			me->Line = lastcell->cLine;	/* should've happened in break */
d669 1
a669 1
		ret = lastcell->len;	/* ##523_change_state? */
d674 1
a674 1
			if (s->icell_core == -1)	/* ##528??: */
d699 1
a699 1
		/* ##541_set_len_0_Line_-1_sometimes: */
d702 2
a703 3
		/* fall thru ##546 really fall thru??: */
		newstate = empty ? CS_invalid : CS__cbc;
		break;
d705 1
a705 2
		newstate = empty ? CS__0ef : CS__0cf;
		break;
d707 1
a707 1
		newstate = empty ? CS__0ef : CS__0cf;	/* ebc?? */
d743 2
a744 3
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cf : CS__cbc;
		break;
d751 1
a751 2
		newstate = empty ? CS__ef : CS__cf;
		break;
d753 1
a753 1
		newstate = empty ? CS__ef : CS__ef;	/* ##579??? !!!!! */
d775 2
a776 2
			me->fixed_line = YES;	/* type=c def of fixed_line */
			me->Line = lastcell->cLine;	/* should've happened in break */
d784 3
a786 4
		newstate = empty ? CS__cf : CS__cbc;
		break;
	    case CS__ef:	/* ignored error */
	    case CS__cf:	/* ignored error */
d797 1
a797 2
		newstate = empty ? CS_invalid : CS__cbc;
		break;
d799 1
a799 1
		lastcell->len = 0;	/* ##613 */
d809 2
a810 3
		s->pending_len = 0;	/* ##629 v */
		newstate = empty ? CS_invalid : CS__cbc;
		break;
d813 1
a813 1
    } else {			/* (!multiline) */
d821 1
a821 1
		ret = 0;	/* or 0 for xlen to s->pending_len?? */
d834 1
a834 1
		if (!empty && s->prev_state == CS__cbc)		/* ##609: */
d838 1
a838 1
			me->fixed_line = YES;	/* type=d def of fixed_line */
d858 1
a858 2
		newstate = empty ? CS__eb : CS__ebc;
		break;
d860 1
a860 2
		newstate = empty ? CS__cb : CS__cbc;
		break;
d880 1
a880 2
		newstate = empty ? CS__0ef : CS__0cf;
		break;		/* ##630 */
d882 1
a882 2
		newstate = empty ? CS__0ef : CS__0ef;
		break;		/* ??? */
d884 1
a884 2
		newstate = empty ? CS__0cf : CS__cbc;
		break;		/* ??? */
d886 1
a886 2
		newstate = CS__0ef;
		break;		/* ??? */
d893 1
a893 1
		if (!empty) {	/* ##642_set_fixed!: */
d895 1
a895 1
			me->fixed_line = YES;	/* type=e def of fixed_line */
d904 1
a904 1
		newstate = empty ? CS__ef : CS__cf;
d910 1
a910 2
		newstate = empty ? CS__ef : CS__cf;
		break;		/* ??? */
d912 3
a914 4
		newstate = empty ? CS__cf : CS__cf;
		break;		/* ??? */
	    case CS__ef:	/* ignored error */
	    case CS__cf:	/* ignored error */
d919 2
a920 2
	}			/* if (!end_td) ... else */
    }				/* if (multiline) ... else */
d927 1
a927 1
	    ret = 0;		/* XXXX Hack to allow trailing <P> in multiline cells. */
d935 1
a935 1
	     cellstate_s(s->prev_state), cellstate_s(s->state), ret));
d940 4
a943 4
 * Reserve cells, each of given colspan, in (rowspan-1) rows after the current
 * row of rowspan>1.  If rowspan==0, use special 'row' rowspans2eog to keep
 * track of rowspans that are to remain in effect until the end of the row
 * group (until next THEAD/TFOOT/TBODY) or table.
d945 5
a949 3
static int Stbl_reserveCellsInTable(STable_info *me, int icell,
				    int colspan,
				    int rowspan)
d959 2
a960 3
	    (tfp,
	     "TRST:Stbl_reserveCellsInTable(icell=%d, colspan=%d, rowspan=%d)\n",
	     icell, colspan, rowspan));
a963 1

d974 3
a976 3
	rows = typeRealloc(STable_rowinfo, me->rows,
			     (me->allocated_rows + growby));

d978 1
a978 1
	    return 0;		/* ignore silently, no free memory, may be recoverable */
a988 1

a1006 1

d1019 2
a1020 1
static void Stbl_cancelRowSpans(STable_info *me)
d1026 1
a1026 1
	if (!me->rows[i].ncells) {	/* should always be the case */
d1038 4
a1041 2
int Stbl_addRowToTable(STable_info *me, int alignment,
		       int lineno)
d1044 1
a1044 1
    STable_states *s = &me->s;
d1048 2
a1049 2
	     alignment, lineno));
    if (me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0) {
d1051 1
a1051 4
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len =
		s->pending_len;
d1055 2
a1056 2
    if (me->nrows > 0 && me->rows[me->nrows - 1].Line == lineno)
	me->rows[me->nrows - 1].Line = -1;
a1062 1

d1069 3
a1071 3
		rows = typeRealloc(STable_rowinfo, me->rows,
				     (me->allocated_rows + growby));

a1079 1

d1112 2
a1113 2
	    (me->rowgroup_align == HT_ALIGN_NONE) ?
	    me->alignment : me->rowgroup_align;
d1119 2
a1120 2
    me->rows[me->nrows].Line = -1;	/* not yet used */
    me->rows[me->nrows].ended = ROW_not_ended;	/* No </tr> yet */
d1127 2
a1128 1
static int Stbl_finishRowInTable(STable_info *me)
d1131 1
a1131 1
    STable_states *s = &me->s;
d1155 8
a1162 7
static void update_sumcols0(STable_cellinfo *sumcols,
			    STable_rowinfo *lastrow,
			    int pos,
			    int len,
			    int icell,
			    int ispan,
			    int allocated_sumcols)
a1164 1

a1168 1

d1172 2
a1173 5
	    if (sumcols[icell + ispan - 1].pos +
		sumcols[icell + ispan - 1].len >
		sumpos)
		sumpos = sumcols[icell + ispan - 1].pos +
		    sumcols[icell + ispan - 1].len;
d1183 1
a1183 2
					    sumcols[i - 1].pos +
					    sumcols[i - 1].len
d1200 6
a1205 5
static int get_remaining_colspan(STable_rowinfo *me,
				 STable_cellinfo *colinfo,
				 int ncolinfo,
				 int colspan,
				 int ncols_sofar)
d1209 1
a1209 1
    me->cells[me->ncells - 1].colspan : 1;
d1225 5
a1229 4
static int Stbl_fakeFinishCellInTable(STable_info *me,
				      STable_rowinfo *lastrow,
				      int lineno,
				      int finishing)	/* Processing finish or start */
d1231 1
a1231 1
    STable_states *s = &me->s;
d1234 1
a1234 1
    switch (s->state) {		/* We care only about trailing <BR> */
d1247 1
a1247 1
	if (finishing == 0)
d1249 1
a1249 1
	break;			/* Either can't happen, or may be ignored */
d1265 2
a1266 2
	int rs = 1;		/* XXXX How to find rowspan? */
	int ih = 0;		/* XXXX How to find is_header? */
d1274 2
a1275 3
		(tfp,
		 "TRST:Stbl_fakeFinishCellInTable(lineno=%d, finishing=%d) START FAKING\n",
		 lineno, finishing));
d1290 1
a1290 1
/* Stbl_finishCellInTable(lineno, 0, 0); *//* Needed? */
d1319 3
a1321 2
	    STable_rowinfo *rows = typeRealloc(STable_rowinfo, me->rows,
					       (me->allocated_rows + 1));
d1326 1
a1326 1
		return -1;	/* ignore silently, no free memory, may be recoverable */
a1343 1

d1367 1
a1367 1
		 ncells, (finishing ? ", last unfinished" : "")));
d1371 1
a1371 1
	    if (Stbl_addCellToTable(me, (i == ncells ? cs : 1), rs, al,
d1375 1
a1375 1
	    lastrow->content &= ~HAS_BEG_OF_CELL;	/* BEG_OF_CELL was fake */
d1385 2
a1386 3
		(tfp,
		 "TRST:Stbl_fakeFinishCellInTable(lineno=%d) FINISH FAKING\n",
		 lineno));
d1396 9
a1404 7
int Stbl_addCellToTable(STable_info *me, int colspan,
			int rowspan,
			int alignment,
			int isheader,
			int lineno,
			int offset_not_used_yet GCC_UNUSED,
			int pos)
d1406 1
a1406 1
    STable_states *s = &me->s;
d1412 2
a1413 3
	    (tfp,
	     "TRST:Stbl_addCellToTable(lineno=%d, pos=%d, isheader=%d, cs=%d, rs=%d, al=%d)\n",
	     lineno, pos, (int) isheader, colspan, rowspan, alignment));
d1416 1
a1416 1
    /* ##850_fail_if_fail?? */
d1427 1
a1427 1
	    && lastrow->cells[lastrow->ncells - 1].cLine != lineno) {
a1458 1

d1465 3
a1467 3
		sumcols = typeRealloc(STable_cellinfo, me->sumcols,
				        (me->allocated_sumcols + growby));

d1470 1
a1470 1
		    sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
d1492 1
a1492 1
	sumpos += me->sumcols[ncells - 1].pos - lastrow->cells[ncells - 1].pos;
d1494 1
a1494 3
		    sumpos - ((ncells > 0)
			      ? me->sumcols[icell].pos
			      : me->sumcols[icell].pos),
d1497 1
a1497 1
    me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
d1506 6
a1511 4
int Stbl_finishCellInTable(STable_info *me, int end_td,
			   int lineno,
			   int offset,
			   int pos)
d1513 1
a1513 1
    STable_states *s = &me->s;
d1519 2
a1520 3
	    (tfp,
	     "TRST:Stbl_finishCellInTable(lineno=%d, pos=%d, off=%d, end_td=%d)\n",
	     lineno, pos, offset, (int) end_td));
d1532 1
d1550 1
a1550 1
    xlen = (len > 0) ? len : s->pending_len;	/* ##890 use xlen if fixed_line?: */
a1561 1

d1569 1
a1569 1
			     me->sumcols[i + 1].pos - me->sumcols[icell].pos);
d1588 1
a1588 1
	me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
d1596 2
a1597 1
#ifdef EXP_NESTED_TABLES	/* maxlen may already include contribution of a cell in this column */
d1621 5
a1625 3
int Stbl_addColInfo(STable_info *me, int colspan,
		    short alignment,
		    BOOL isgroup)
d1632 1
a1632 1
	     colspan, alignment, (int) isgroup));
d1638 1
a1638 1
	    me->sumcols[me->ncolinfo - 1].cLine = EOCOLG;
a1651 1

d1658 3
a1660 3
		sumcols = typeRealloc(STable_cellinfo, me->sumcols,
				        (me->allocated_sumcols + growby));

d1663 1
a1663 1
		    sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
d1678 1
a1678 1
    if (alignment == HT_ALIGN_NONE)
d1689 2
a1690 1
int Stbl_finishColGroup(STable_info *me)
d1696 1
a1696 1
	    me->sumcols[me->ncolinfo - 1].cLine = EOCOLG;
d1703 3
a1705 1
int Stbl_addRowGroup(STable_info *me, short alignment)
d1713 2
a1714 1
int Stbl_finishTABLE(STable_info *me)
d1716 1
a1716 1
    STable_states *s = &me->s;
d1724 1
a1724 1
    if (me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0) {
d1726 1
a1726 3
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len = s->pending_len;
d1743 3
a1745 4
	    continue;		/* Not a continuation line */
	minoffset = nextrow[-1].offset;		/* Line before first continuation */
	CTRACE2(TRACE_TRST, (tfp,
			     "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
d1750 1
a1750 4
	       && ((nextrow->content &
		    (IS_CONTINUATION_OF_CELL
		     | HAS_BEG_OF_CELL
		     | BELIEVE_OFFSET))
d1754 2
a1755 4
	    CTRACE2(TRACE_TRST,
		    (tfp,
		     "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
		     j, nextrow->offset, nextrow[-1].ended));
d1759 1
a1759 1
	i = j - 1;		/* Continue after this line */
d1761 2
a1762 2
	j = leading;		/* Restart */
	nextrow = me->rows + j;	/* Line before first continuation */
d1765 1
a1765 1
	while (j <= i) {	/* A continuation line */
d1774 1
a1774 1
	    continue;		/* No offsets to deal with */
d1778 3
a1780 3
	j = leading + 1;	/* Restart */
	nextrow = me->rows + j;	/* First continuation line */
	while (foundcell == -1 && j <= i) {	/* A continuation line */
d1789 1
a1789 1
	if (foundcell == -1)	/* Can it happen? */
d1793 3
a1795 3
	j = leading;		/* Restart */
	nextrow = me->rows + j;	/* Include the pre-continuation line */
	while (j <= i) {	/* A continuation line */
d1806 1
a1806 1
	j = non_empty;		/* Restart from the first nonempty */
d1810 1
a1810 1
			0 /* width only */ , max_width,
d1813 1
a1813 1
	j = leading;		/* Restart from pre-continuation */
d1815 1
a1815 1
	while (j <= i) {	/* A continuation line */
d1821 1
a1821 1
    }				/* END of Offsets processing */
d1838 2
a1839 1
short Stbl_getAlignment(STable_info *me)
d1841 1
a1841 1
    return (short) (me ? me->alignment : HT_ALIGN_NONE);
d1844 5
a1848 3
static int get_fixup_positions(STable_rowinfo *me, int *oldpos,
			       int *newpos,
			       STable_cellinfo *sumcols)
d1895 3
a1897 3
 * Returns -1 if we have no row for this lineno, or for other error,
 *	    0 or greater (number of oldpos/newpos pairs) if we have
 *	      a table row.
d1899 5
a1903 3
int Stbl_getFixupPositions(STable_info *me, int lineno,
			   int *oldpos,
			   int *newpos)
d1905 1
a1905 1
    STable_rowinfo *row;
a1907 1

d1921 2
a1922 1
int Stbl_getStartLine(STable_info *me)
d1932 2
a1933 1
int Stbl_getStartLineDeep(STable_info *me)
d1942 4
a1945 2
void Stbl_update_enclosing(STable_info *me, int max_width,
			   int last_lineno)
d1951 2
a1952 3
    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",
	     max_width, me->startline, last_lineno));
d1955 1
a1955 5
	if (Stbl_finishCellInTable(me->enclosing,
				   TRST_ENDCELL_LINEBREAK,
				   l,
				   0,
				   max_width) < 0) {
d1957 1
a1957 1
	       and it does not buy us anything.  Do it directly. */
d1960 1
a1960 2
	    CTRACE2(TRACE_TRST, (tfp,
				 "TRST:Stbl_update_enclosing: width too large, aborting enclosing\n"));
a1963 1

d1973 4
a1976 1
void Stbl_set_enclosing(STable_info *me, STable_info *enclosing, struct _TextAnchor *enclosing_last_anchor_before_stbl)
d1984 2
a1985 1
STable_info *Stbl_get_enclosing(STable_info *me)
d1992 2
a1993 1
struct _TextAnchor *Stbl_get_last_anchor_before(STable_info *me)
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d20 1
a20 2
#define ROWS_GROWBY_DIVISOR 2
#else  /* This is very silly, and leads to *larger* memory consumption... */
a22 1
#define ROWS_GROWBY_DIVISOR 10
a24 6
#define  REUSE_ROWS_AS_CELLS_POOLS 0	/* Turns out to be not beneficial */

/* Experiments show that 2 is better than 1.5 is better than 1.25 (all by
   a small margin only)??? */
#define CELLS_GROWBY_FACTOR 2

d74 4
a77 4
	short	pos;		/* column where cell starts */
	short	len;		/* number of character positions */
	short	colspan;	/* number of columns to span */
	short	alignment;	/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
a92 1
#define IS_CONTINUATION_OF_MULTICELL	0x40
d98 1
a98 1
	short	ncells;		/* number of table cells */
d122 1
a122 1
	short	fixed_line;	/* if we have a 'core' line of cells */
d124 3
a126 5
	short	content;	/* Whether contains end-of-cell etc */
	short	offset;		/* >=0 after line break in a multiline cell */
	short	allocated;	/* number of table cells allocated or 0
				   if the .cells should not be free()ed */
	short	alignment;	/* global align attribute for this row */
d128 1
a130 9
struct _STable_chunk;
typedef struct _STable_chunk {
    struct _STable_chunk *next;
    int alloc_cells;
    int used_cells;
    STable_cellinfo cells[1];
} STable_chunk;


d143 1
a143 2
	int	ncolinfo;	/* number of COL info collected */
	int	last_reserved;	/* -1 or last line with reserved cells */
a151 2
	STable_chunk *free_chunks;
	STable_chunk *used_chunks;
d208 1
a208 1
PRIVATE int Stbl_DOfinishRowInTable PARAMS((
a246 1
	me->last_reserved = -1;
a250 1
	me->used_chunks = me->free_chunks = NULL;
a262 89
PRIVATE int addmem_rowinfo ARGS2(
    STable_info *,	me,
    int,		incr)
{
    int i;
    int growby = 0;
    STable_rowinfo *rows, *row;

    while (me->nrows + incr + 1 > me->allocated_rows + growby)
	growby += ROWS_GROWBY + me->allocated_rows/ROWS_GROWBY_DIVISOR;
    if (growby) {
	if (me->allocated_rows == 0 && !me->rows) {
	    rows = typecallocn(STable_rowinfo, growby);
	} else {
#if REUSE_ROWS_AS_CELLS_POOLS		/* Turns out to be not beneficial */
	    /* Work in a regime which has a chance to work efficiently
	       even with lousy malloc()s: do not realloc() until we
	       have many (2) free chunks available (possible with very
	       simple structure of each row).  Simultaneously,
	       make it possible to use an effecient realloc() which
	       would grow the region in place - so DO use realloc() if
	       we already have many free chunks to put the cellinfo into.
	     */
	    if ( me->free_chunks && me->free_chunks->next
		 || (me->allocated_rows*sizeof(STable_rowinfo) <
		    (sizeof(STable_chunk)
		     + (CELLS_GROWBY-1)*sizeof(STable_cellinfo)))
		 || 1)
#endif
	    {
		rows = realloc(me->rows,
			       (me->allocated_rows + growby)
			       * sizeof(STable_rowinfo));
	    }
#if REUSE_ROWS_AS_CELLS_POOLS
	    else {
		rows = malloc((me->allocated_rows + growby)
			      * sizeof(STable_rowinfo));
		if (rows) {
		    STable_chunk *p;

		    memcpy(rows, me->rows,
			   (me->allocated_rows + growby)
			   * sizeof(STable_rowinfo));
		    p = (STable_chunk*)me->rows;
		    p->alloc_cells =
			1 + (me->allocated_rows*sizeof(STable_rowinfo)
			     - sizeof(STable_chunk))/sizeof(STable_cellinfo);
		    p->used_cells = 0;
		    p->next = me->free_chunks;
		    me->free_chunks = p;
		}
	    }
#endif
	    for (i = 0; rows && i < growby; i++) {
		row = rows + me->allocated_rows + i;
		if (!me->rowspans2eog.allocated) {
		    row->allocated = 0;
		    row->cells = NULL;
		} else {
		    row->cells = typecallocn(STable_cellinfo,
					     me->rowspans2eog.allocated);
		    if (row->cells) {
			row->allocated = me->rowspans2eog.allocated;
			memcpy(row->cells, me->rowspans2eog.cells,
			       row->allocated * sizeof(STable_cellinfo));
		    } else {
			FREE(rows);
			break;
		    }
		}
		row->ncells = 0;
		row->fixed_line = NO;
		row->alignment = HT_ALIGN_NONE;
		row->offset = 0;
		row->content = 0;
	    }
	}
	if (rows) {
	    me->allocated_rows += growby;
	    me->rows = rows;
	} else {
	    return 0;
	}
    }
    return 1;
}


a276 11
    if (me) {
	STable_chunk *this;
	while ((this = me->free_chunks)) {
	    me->free_chunks = this->next;
	    FREE(this);
	}
	while ((this = me->used_chunks)) {
	    me->used_chunks = this->next;
	    FREE(this);
	}
    }
d951 3
a953 1
    int i, last;
d972 33
a1004 7
    if (!addmem_rowinfo(me, rowspan - 1))
	return 0; /* ignore silently, no free memory, may be recoverable */

    last = (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
    if (me->last_reserved < last)
	me->last_reserved = last;
    for (i = me->nrows; i < last; i++) {
d1043 1
d1054 1
a1054 1
    Stbl_DOfinishRowInTable(me);
d1060 44
a1103 2
    if (!addmem_rowinfo(me, 1))
	return -1;
a1113 43
    if (me->nrows >= 2	/* We may use RESERVEDCELL flag of cells in nrows-1 */
	&& me->rows[me->nrows - 2].allocated > me->rows[me->nrows - 2].ncells) {
	int c = me->rows[me->nrows - 2].ncells;
	STable_cellinfo *p  = me->rows[me->nrows - 2].cells;

#if 0	/* Leads to no memory savings and quadratic time with EMX malloc */
	/* Do not need extra cells any more */
	me->rows[me->nrows - 2].cells = realloc(p,c * sizeof(STable_cellinfo));
	me->rows[me->nrows - 2].allocated = me->rows[me->nrows - 2].ncells;
#else
	if (!me->used_chunks
	    || ((me->used_chunks->alloc_cells - me->used_chunks->used_cells)
		< c)) {
	    if (me->free_chunks && (me->free_chunks->alloc_cells >= c)) {
	        STable_chunk *p2 = me->free_chunks;

		me->free_chunks = p2->next;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    } else {			/* Need to get a new guy */
	        STable_chunk *p2;

		if (c < CELLS_GROWBY)
		    c = CELLS_GROWBY;
		if ( me->used_chunks
		     && c < me->used_chunks->alloc_cells*CELLS_GROWBY_FACTOR )
		    c = 2*me->used_chunks->alloc_cells * CELLS_GROWBY_FACTOR;
		p2 = malloc(sizeof(STable_chunk) + (c-1)*sizeof(STable_cellinfo));
		p2->alloc_cells = c;
		p2->used_cells = 0;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    }
	}
	memcpy(me->used_chunks->cells + me->used_chunks->used_cells,
	       p, me->rows[me->nrows - 2].ncells * sizeof(STable_cellinfo));
	me->rows[me->nrows - 2].cells =
	    me->used_chunks->cells + me->used_chunks->used_cells;
	me->used_chunks->used_cells += me->rows[me->nrows - 2].ncells;
	me->rows[me->nrows - 2].allocated = 0; /* Do not FREE() */
	FREE(p);
#endif
    }
d1127 1
a1127 1
PRIVATE int Stbl_DOfinishRowInTable ARGS1(
d1134 1
a1134 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_DOfinishRowInTable()\n"));
d1139 1
a1139 2
    if (lastrow->ended != ROW_ended_by_splitline)
	lastrow->ended = ROW_ended_by_endtr;
a1271 1
	int is_multicell = 0;
a1276 5
	if ( lastrow->ncells > 1
	     && (lastrow->cells[lastrow->ncells - 2].pos
		 != lastrow->cells[lastrow->ncells - 1].pos))
	    is_multicell = 1;

a1297 4
	if (is_multicell)
	    lastrow->content = IS_CONTINUATION_OF_MULTICELL;
	else
	    lastrow->content = IS_CONTINUATION_OF_CELL;
a1333 1
	    me->last_reserved++;
a1338 1
	    lastrow[1].content = 0;
a1502 110
PUBLIC BOOL Stbl_at_start_of_cell ARGS3(
    STable_info *,	me,
    int,		lineno,
    int,		pos)
{
    STable_rowinfo *lastrow;
    int icell;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_at_start_of_cell(lineno=%d, pos=%d): ",
		  lineno, pos));
    if (me->nrows == 0)
	goto yes;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended != ROW_not_ended)
	goto no;			/* E.g., may be processing </tr> */
    icell = lastrow->ncells - 1;
    if (icell < 0)
	goto yes;
    if (lastrow->cells[icell].cLine != lineno
	|| lastrow->cells[icell].pos != pos) {
      no:
	CTRACE2(TRACE_TRST, (tfp, "no\n"));
	return FALSE;			/* XXXX  What to do if cLine is -1? */
    }
  yes:
    CTRACE2(TRACE_TRST, (tfp, "yes\n"));
    return TRUE;
}

PUBLIC void Stbl_finishRowInTable ARGS1(
    STable_info *,	me)
{
    STable_rowinfo *lastrow;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_finishRowInTable()\n"));
    if (me->nrows <= 0)
	return;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended == ROW_not_ended)
	lastrow->ended = ROW_ended_by_endtr;
}

/* Assumes that the current pos is at beginning of line.
   Checks whether the last row was a fake row, and undo it if possible.
   Returns TRUE if the last line (empty!) can be safely trimmed. */
PUBLIC int Stbl_trimFakeRows ARGS3(
    STable_info *,	me,
    int,		lineno,
    int,		pos GCC_UNUSED)
{
    STable_rowinfo *prevrow, *lastrow;
    int icell;

    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_trimFakeRows()\n"));

    /* XXXX The logic may be much better if we support removal of
       RESERVED cells.  Until this is done, bail out early: */
    if (me->nrows <= 0 || me->nrows <= me->last_reserved)
	return 0;
    lastrow = me->rows + (me->nrows - 1);
    icell = lastrow->ncells - 1;
    if (icell >= 0 && lastrow->cells[icell].cLine < lineno) {
	/* The last cell start on a preceeding line; keep lastrow */
	lastrow->ended = ROW_not_ended; /* Give it new life */
	/* We do not use state info for a lot of things any more, so do
	   not try to do anything special here */
	me->s.state = CS__0new;		/* This is enough to revive things. */
	me->s.x_td = lastrow->cells[lastrow->ncells - 1].pos;
	me->s.lineno = lastrow->cells[lastrow->ncells - 1].cLine;
	CTRACE2(TRACE_TRST, (tfp, "  un-ended the last row.\n"));
	return 1;
    }
    if (me->nrows <= 1 || !(lastrow->content & IS_CONTINUATION_OF_CELL))
	return 0;
    prevrow = me->rows + (me->nrows - 2);
    if (prevrow->ncells != icell + 1)	/* Empty cells were added after the break */
	return 0;
    if ( prevrow->ended != ROW_ended_by_splitline) /* Lastrow non-fake */
	return 0;
    me->nrows--;
    /* prevrow is now the last row, so its cells should be realloc()able */
    if (prevrow->cells && prevrow->allocated == 0) { /* Moved to pool */
	int c = prevrow->ncells;
	STable_cellinfo *p;

	if (lastrow->allocated > c)	/* May have RESERVED info */
	    c = lastrow->allocated;
	p = malloc(c * sizeof(STable_cellinfo));
	memcpy(p, prevrow->cells, prevrow->ncells * sizeof(STable_cellinfo));
	/* Copy back the possibly present RESERVED info.
	   XXXX remove duplicated RESERVED stuff from the followup rows too! */
	memcpy(p + prevrow->ncells, lastrow->cells + prevrow->ncells,
	       (c - prevrow->ncells) * sizeof(STable_cellinfo));
	prevrow->cells = p;	/* XXXX How would ride with RESERVED? */
	prevrow->allocated = c;
    }
    lastrow->ncells = 0;
    lastrow->content = 0;
    prevrow->ended = ROW_not_ended;	/* Give it new life */
    /* We do not use state info for a lot of things any more, so do
       not try to do anything special here */
    me->s.state = CS__0new;
    me->s.x_td = prevrow->cells[prevrow->ncells - 1].pos;
    me->s.lineno = prevrow->cells[prevrow->ncells - 1].cLine;
    CTRACE2(TRACE_TRST, (tfp, "  Removed the last row.\n"));
    return 1;
}

d1729 1
a1729 1
    Stbl_DOfinishRowInTable(me);
a1907 2
    static int prev_row = 0;

d1910 1
a1910 5
    if (prev_row < me->nrows && me->rows[prev_row].Line <= lineno)
	j = prev_row;
    else
	j = 0;
    for ( ; j < me->nrows; j++) {
a1912 1
	    prev_row = j;
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d20 2
a21 1
#else
d24 1
d27 6
d82 4
a85 4
	int	pos;		/* column where cell starts */
	int	len;		/* number of character positions */
	int	colspan;	/* number of columns to span */
	int	alignment;	/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
d101 1
d107 1
a107 1
	int	ncells;		/* number of table cells */
d131 1
a131 1
	BOOL	fixed_line;	/* if we have a 'core' line of cells */
d133 5
a137 3
	int	content;	/* Whether contains end-of-cell etc */
	int	offset;		/* >=0 after line break in a multiline cell */
	int	allocated;	/* number of table cells allocated */
a138 1
	int	alignment;	/* global align attribute for this row */
d141 9
d162 2
a163 1
	int	ncolinfo;		/* number of COL info collected */
d172 2
d230 1
a230 1
PRIVATE int Stbl_finishRowInTable PARAMS((
d269 1
d274 1
d287 89
d390 11
d1075 1
a1075 3
    STable_rowinfo *rows, *row;
    int growby;
    int i;
d1094 7
a1100 33
    growby = me->nrows + rowspan - 1 - me->allocated_rows;
    if (growby > 0) {
	rows = realloc(me->rows,
		       (me->allocated_rows + growby)
		       * sizeof(STable_rowinfo));
	if (!rows)
	    return 0; /* ignore silently, no free memory, may be recoverable */
	for (i = 0; i < growby; i++) {
	    row = rows + me->allocated_rows + i;
	    row->allocated = 0;
	    row->offset = 0;
	    row->content = 0;
	    if (!me->rowspans2eog.allocated) {
		row->cells = NULL;
	    } else {
		row->cells = typecallocn(STable_cellinfo,
					 me->rowspans2eog.allocated);
		if (row->cells) {
		    row->allocated = me->rowspans2eog.allocated;
		    memcpy(row->cells, me->rowspans2eog.cells,
			   row->allocated * sizeof(STable_cellinfo));
		}
	    }
	    row->ncells = 0;
	    row->fixed_line = NO;
	    row->alignment = HT_ALIGN_NONE;
	}
	me->allocated_rows += growby;
	me->rows = rows;
    }
    for (i = me->nrows;
	 i < (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
	 i++) {
a1138 1
    STable_rowinfo *rows, *row;
d1149 1
a1149 1
    Stbl_finishRowInTable(me);
d1155 2
a1156 44
    {
	int i;
	int growby = 0;
	while (me->nrows + 2 > me->allocated_rows + growby)
	    growby += ROWS_GROWBY;
	if (growby) {
	    if (me->allocated_rows == 0 && !me->rows) {
		rows = typecallocn(STable_rowinfo, growby);
	    } else {
		rows = realloc(me->rows,
				  (me->allocated_rows + growby)
				  * sizeof(STable_rowinfo));
		for (i = 0; rows && i < growby; i++) {
		    row = rows + me->allocated_rows + i;
		    if (!me->rowspans2eog.allocated) {
			row->allocated = 0;
			row->cells = NULL;
		    } else {
			row->cells = typecallocn(STable_cellinfo,
						 me->rowspans2eog.allocated);
			if (row->cells) {
			    row->allocated = me->rowspans2eog.allocated;
			    memcpy(row->cells, me->rowspans2eog.cells,
				   row->allocated * sizeof(STable_cellinfo));
			} else {
			    FREE(rows);
			    break;
			}
		    }
		    row->ncells = 0;
		    row->fixed_line = NO;
		    row->alignment = HT_ALIGN_NONE;
		    row->offset = 0;
		    row->content = 0;
		}
	    }
	    if (rows) {
		me->allocated_rows += growby;
		me->rows = rows;
	    } else {
		return -1;
	    }
	}
    }
d1167 43
d1223 1
a1223 1
PRIVATE int Stbl_finishRowInTable ARGS1(
d1230 1
a1230 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishRowInTable()\n"));
d1235 2
a1236 1
    lastrow->ended = ROW_ended_by_endtr;
d1369 1
d1375 5
d1401 4
d1441 1
d1447 1
d1612 110
d1948 1
a1948 1
    Stbl_finishRowInTable(me);
d2127 2
d2131 5
a2135 1
    for (j = 0; j < me->nrows; j++) {
d2138 1
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d202 1
a202 1
static int Stbl_finishCellInRow (
d207 3
a209 3
    int			pos);
static int Stbl_finishRowInTable (
    STable_info *	me);
d211 2
a212 2
static const char * cellstate_s (
	cellstate_t	state)
d214 1
a214 1
    const char *result = "?";
d234 2
a235 2
struct _STable_info * Stbl_startTABLE (
    short		alignment)
d255 2
a256 2
static void free_rowinfo (
    STable_rowinfo *	me)
d263 2
a264 2
void Stbl_free (
    STable_info *	me)
d283 10
a292 10
static int Stbl_addCellToRow (
    STable_rowinfo *	me,
    STable_cellinfo *	colinfo,
    int		ncolinfo,
    STable_states *	s,
    int		colspan,
    int		alignment,
    int		isheader,
    int		lineno,
    int *		ppos)
d516 4
a519 4
static int Stbl_reserveCellsInRow (
    STable_rowinfo *	me,
    int		icell,
    int		colspan)
d554 6
a559 6
static int Stbl_finishCellInRow (
    STable_rowinfo *	me,
    STable_states *	s,
    int		end_td,
    int		lineno,
    int		pos)
d945 5
a949 5
static int Stbl_reserveCellsInTable (
    STable_info *	me,
    int		icell,
    int		colspan,
    int		rowspan)
d1019 2
a1020 2
static void Stbl_cancelRowSpans (
    STable_info *	me)
d1038 4
a1041 4
int Stbl_addRowToTable (
    STable_info *	me,
    int		alignment,
    int		lineno)
d1127 2
a1128 2
static int Stbl_finishRowInTable (
    STable_info *	me)
d1155 8
a1162 8
static void update_sumcols0 (
    STable_cellinfo *	sumcols,
    STable_rowinfo *	lastrow,
    int		pos,
    int		len,
    int		icell,
    int		ispan,
    int		allocated_sumcols)
d1200 6
a1205 6
static int get_remaining_colspan (
    STable_rowinfo *	me,
    STable_cellinfo *	colinfo,
    int		ncolinfo,
    int		colspan,
    int		ncols_sofar)
d1225 5
a1229 5
static int Stbl_fakeFinishCellInTable (
    STable_info *	me,
    STable_rowinfo *	lastrow,
    int		lineno,
    int		finishing)	/* Processing finish or start */
d1396 9
a1404 9
int Stbl_addCellToTable (
    STable_info *	me,
    int		colspan,
    int		rowspan,
    int		alignment,
    int		isheader,
    int		lineno,
    int		offset_not_used_yet GCC_UNUSED,
    int		pos)
d1506 6
a1511 6
int Stbl_finishCellInTable (
    STable_info *	me,
    int		end_td,
    int		lineno,
    int		offset,
    int		pos)
d1621 5
a1625 5
int Stbl_addColInfo (
    STable_info *	me,
    int		colspan,
    short		alignment,
    BOOL		isgroup)
d1689 2
a1690 2
int Stbl_finishColGroup (
    STable_info *	me)
d1703 3
a1705 3
int Stbl_addRowGroup (
    STable_info *	me,
    short		alignment)
d1713 2
a1714 2
int Stbl_finishTABLE (
    STable_info *	me)
d1838 2
a1839 2
short Stbl_getAlignment (
    STable_info *	me)
d1844 5
a1848 5
static int get_fixup_positions (
    STable_rowinfo *	me,
    int *		oldpos,
    int *		newpos,
    STable_cellinfo *	sumcols)
d1899 5
a1903 5
int Stbl_getFixupPositions (
    STable_info *	me,
    int		lineno,
    int *		oldpos,
    int *		newpos)
d1921 2
a1922 2
int Stbl_getStartLine (
    STable_info *	me)
d1932 2
a1933 2
int Stbl_getStartLineDeep (
    STable_info *	me)
d1942 4
a1945 4
void Stbl_update_enclosing (
    STable_info *	me,
    int		max_width,
    int		last_lineno)
d1973 4
a1976 4
void Stbl_set_enclosing (
    STable_info *	me,
    STable_info *	enclosing,
    struct _TextAnchor*enclosing_last_anchor_before_stbl)
d1984 2
a1985 2
STable_info * Stbl_get_enclosing (
    STable_info *	me)
d1992 2
a1993 2
struct _TextAnchor * Stbl_get_last_anchor_before (
    STable_info *	me)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 6
a7 6
 *		===================
 * Authors
 *	KW	Klaus Weide <kweide@@enteract.com>
 * History:
 *   2 Jul 1999	KW	Created.
 */
d44 1
a44 1
    CS__new = 0,
d59 6
a64 6
    cellstate_t prev_state;	/* Contents type of the previous cell */
    cellstate_t state;		/* Contents type of the worked-on cell */
    int lineno;			/* Start line of the current cell */
    int icell_core;		/* -1 or the 1st cell with <BR></TD> on row */
    int x_td;			/* x start pos of the current cell or -1 */
    int pending_len;		/* For multiline cells, the length of
d70 1
a70 1
    int cLine;			/* lineno in doc (zero-based): -1 for
d74 4
a77 4
    int pos;			/* column where cell starts */
    int len;			/* number of character positions */
    int colspan;		/* number of columns to span */
    int alignment;		/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
d82 3
a84 3
    ROW_not_ended,
    ROW_ended_by_endtr,
    ROW_ended_by_splitline
d97 2
a98 2
    int Line;			/* lineno in doc (zero-based) */
    int ncells;			/* number of table cells */
d101 1
a101 1
       [search for      def of fixed_line       below]
d111 1
a111 1
       (Notation: B: at BOL; L: last; E: the first row is non-empty)
d113 3
a115 3
       bcde:    !B && !E
       a1:      !L && !B
       a2:      !L && !E
d122 7
a128 7
    BOOL fixed_line;		/* if we have a 'core' line of cells */
    enum ended_state ended;	/* if we saw </tr> etc */
    int content;		/* Whether contains end-of-cell etc */
    int offset;			/* >=0 after line break in a multiline cell */
    int allocated;		/* number of table cells allocated */
    STable_cellinfo *cells;
    int alignment;		/* global align attribute for this row */
d133 2
a134 2
    struct _STable_info *enclosing;	/* The table which contain us */
    struct _TextAnchor *enclosing_last_anchor_before_stbl;
d136 16
a151 16
    int startline;		/* lineno where table starts (zero-based) */
    int nrows;			/* number of rows */
    int ncols;			/* number of rows */
    int maxlen;			/* sum of max. cell lengths of any row */
    int maxpos;			/* max. of max. cell pos's of any row */
    int allocated_rows;		/* number of rows allocated */
    int allocated_sumcols;	/* number of sumcols allocated */
    int ncolinfo;		/* number of COL info collected */
    STable_cellinfo *sumcols;	/* for summary (max len/pos) col info */
    STable_rowinfo *rows;
    STable_rowinfo rowspans2eog;
    short alignment;		/* global align attribute for this table */
    short rowgroup_align;	/* align default for current group of rows */
    short pending_colgroup_align;
    int pending_colgroup_next;
    STable_states s;
d155 55
a209 51
 *  Functions and structures in this source file keep track of positions.
 *  They don't know about the character data in those lines, or about
 *  the HText and HTLine structures.  GridText.c doesn't know about our
 *  structures.  It should stay that way.
 *
 *  The basic idea: we let the code in HTML.c/GridText.c produce and format
 *  output "as usual", i.e. as without Simple Table support.  We keep track
 *  of the positions in the generated output where cells and rows start (or
 *  end).  If all goes well, that preliminary output (stored in HText/HTLine
 *  structures) can be fixed up when the TABLE end tag is processed, by just
 *  inserting spaces in the right places (and possibly changing alignment).
 *  If all goes not well, we already have a safe fallback.
 *
 *  Note that positions passed to and from these functions should be
 *  in terms of screen positions, not just byte counts in a HTLine.data
 *  (cf. line->data vs. HText_TrueLineSize).
 *
 *  Memory is allocated dynamically, so we can have tables of arbitrary
 *  length.  On allocation error we just return and error indication
 *  instead of outofmem(), so caller can give up table tracking and maybe
 *  recover memory.
 *
 *  Implemented:
 *  - ALIGN={left,right,center,justify} applied to individual table cells
 *    ("justify" is treated as "left")
 *  - Inheritance of horizontal alignment according to HTML 4.0
 *  - COLSPAN >1 (may work incorrectly for some tables?)
 *  - ROWSPAN >1 (reserving cells in following rows)
 *  - Line breaks at start of first cell or at end of last cell are treated
 *    as if they were not part of the cell and row.  This allows us to
 *    cooperate with one way in which tables have been made friendly to
 *    browsers without any table support.
 *  Missing, but can be added:
 *  - Support for COLGROUP/COL
 *  - Tables wider than display.  The limitation is not here but in GridText.c
 *    etc.  If horizontal scrolling were implemented there, the mechanisms
 *    here coudl deal with wide tables (just change MAX_STBL_POS code).
 *  Missing, unlikely to add:
 *  - Support for non-LTR directionality.  A general problem, support is
 *    lacking throughout the lynx code.
 *  - Support for most other table-related attributes.  Most of them are
 *    for decorative purposes.
 *  Impossible or very unlikely (because it doesn't fit the model):
 *  - Any cell contents of more than one line, line breaks within cells.
 *    Anything that requires handling cell contents as paragraphs (block
 *    elements), like reflowing.  Vertical alignment.
 */
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
				int lineno,
				int pos);
static int Stbl_finishRowInTable(STable_info *me);
d211 2
a212 1
static const char *cellstate_s(cellstate_t state)
d215 1
a215 1
    /* *INDENT-OFF* */
a230 2
    /* *INDENT-ON* */

d234 2
a235 1
struct _STable_info *Stbl_startTABLE(short alignment)
d240 1
a240 1
	    (tfp, "TRST:Stbl_startTABLE(align=%d)\n", (int) alignment));
d255 2
a256 1
static void free_rowinfo(STable_rowinfo *me)
d263 2
a264 1
void Stbl_free(STable_info *me)
a269 1

d283 10
a292 7
static int Stbl_addCellToRow(STable_rowinfo *me, STable_cellinfo *colinfo, int ncolinfo,
			     STable_states *s,
			     int colspan,
			     int alignment,
			     int isheader,
			     int lineno,
			     int *ppos)
d297 1
a297 1
    me->cells[me->ncells - 1].colspan : 1;
d303 1
a303 1
	     lineno, *ppos, colspan));
d305 3
a307 4
	    (tfp,
	     " ncells=%d, stateLine=%d, pending_len=%d, pstate=%s, state=%s\n",
	     me->ncells, s->lineno, s->pending_len,
	     cellstate_s(s->prev_state), cellstate_s(s->state)));
d355 1
a355 1
	    } else {		/* last cell multiline, ncells != 0, pos != 0 */
d370 1
a370 1
		    me->fixed_line = YES;	/* type=a def of fixed_line i */
d376 1
a376 1
		    me->fixed_line = YES;	/* type=e def of fixed_line ii */
d390 1
a390 1
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */  +
d396 1
a396 1
		    *ppos = me->cells[me->ncells - 1].pos /* == 0 */  +
d407 1
a407 2
		*ppos = me->cells[me->ncells - 1].pos;
		break;
d445 1
a445 1
	me->ncells += me->cells[me->ncells - 1].colspan - 1;
a452 1

d460 2
a461 3
				(me->allocated + growby)
				* sizeof(STable_cellinfo));

d487 1
a487 1
	if (me->cells[me->ncells].alignment == HT_ALIGN_NONE)
d489 1
a489 1
	if (me->cells[me->ncells].alignment == HT_ALIGN_NONE)
d499 1
a499 1
    me->cells[me->ncells + colspan].pos = -1;	/* not yet used */
d506 1
a506 1
	     cellstate_s(s->prev_state), cellstate_s(s->state), ret));
d516 4
a519 2
static int Stbl_reserveCellsInRow(STable_rowinfo *me, int icell,
				  int colspan)
d527 1
a527 1
	     icell, colspan));
a531 1

d554 6
a559 3
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
				int lineno,
				int pos)
d567 2
a568 3
	    (tfp,
	     "TRST:Stbl_finishCellInRow line=%d pos=%d end_td=%d ncells=%d pnd_len=%d\n",
	     lineno, pos, (int) end_td, me->ncells, s->pending_len));
d577 3
a579 4
	    (tfp,
	     " [lines: lastCell=%d state=%d multi=%d] empty=%d (prev)state=(%s) %s\n",
	     lastcell->cLine, s->lineno, multiline, empty,
	     cellstate_s(s->prev_state), cellstate_s(s->state)));
d612 1
a612 1
		if (s->pending_len && empty) {	/* First line non-empty */
d617 2
a618 2
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cb : CS__cbc;	/* ##474_needs_len!=-1? */
d642 1
a642 1
		if (s->pending_len && empty) {	/* ##496: */
d645 1
a645 1
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
d649 2
a650 2
			me->fixed_line = YES;	/* type=b def of fixed_line i */
			me->Line = lastcell->cLine;	/* should've happened in break */
d657 2
a658 2
			me->fixed_line = YES;	/* type=b def of fixed_line ii */
			me->Line = lastcell->cLine;	/* should've happened in break */
d669 1
a669 1
		ret = lastcell->len;	/* ##523_change_state? */
d674 1
a674 1
			if (s->icell_core == -1)	/* ##528??: */
d699 1
a699 1
		/* ##541_set_len_0_Line_-1_sometimes: */
d702 2
a703 3
		/* fall thru ##546 really fall thru??: */
		newstate = empty ? CS_invalid : CS__cbc;
		break;
d705 1
a705 2
		newstate = empty ? CS__0ef : CS__0cf;
		break;
d707 1
a707 1
		newstate = empty ? CS__0ef : CS__0cf;	/* ebc?? */
d743 2
a744 3
		}		/* @@@@@@ for empty do smth. about ->Line / ->icell_core !! */
		newstate = empty ? CS__0cf : CS__cbc;
		break;
d751 1
a751 2
		newstate = empty ? CS__ef : CS__cf;
		break;
d753 1
a753 1
		newstate = empty ? CS__ef : CS__ef;	/* ##579??? !!!!! */
d775 2
a776 2
			me->fixed_line = YES;	/* type=c def of fixed_line */
			me->Line = lastcell->cLine;	/* should've happened in break */
d784 3
a786 4
		newstate = empty ? CS__cf : CS__cbc;
		break;
	    case CS__ef:	/* ignored error */
	    case CS__cf:	/* ignored error */
d797 1
a797 2
		newstate = empty ? CS_invalid : CS__cbc;
		break;
d799 1
a799 1
		lastcell->len = 0;	/* ##613 */
d809 2
a810 3
		s->pending_len = 0;	/* ##629 v */
		newstate = empty ? CS_invalid : CS__cbc;
		break;
d813 1
a813 1
    } else {			/* (!multiline) */
d821 1
a821 1
		ret = 0;	/* or 0 for xlen to s->pending_len?? */
d834 1
a834 1
		if (!empty && s->prev_state == CS__cbc)		/* ##609: */
d838 1
a838 1
			me->fixed_line = YES;	/* type=d def of fixed_line */
d858 1
a858 2
		newstate = empty ? CS__eb : CS__ebc;
		break;
d860 1
a860 2
		newstate = empty ? CS__cb : CS__cbc;
		break;
d880 1
a880 2
		newstate = empty ? CS__0ef : CS__0cf;
		break;		/* ##630 */
d882 1
a882 2
		newstate = empty ? CS__0ef : CS__0ef;
		break;		/* ??? */
d884 1
a884 2
		newstate = empty ? CS__0cf : CS__cbc;
		break;		/* ??? */
d886 1
a886 2
		newstate = CS__0ef;
		break;		/* ??? */
d893 1
a893 1
		if (!empty) {	/* ##642_set_fixed!: */
d895 1
a895 1
			me->fixed_line = YES;	/* type=e def of fixed_line */
d904 1
a904 1
		newstate = empty ? CS__ef : CS__cf;
d910 1
a910 2
		newstate = empty ? CS__ef : CS__cf;
		break;		/* ??? */
d912 3
a914 4
		newstate = empty ? CS__cf : CS__cf;
		break;		/* ??? */
	    case CS__ef:	/* ignored error */
	    case CS__cf:	/* ignored error */
d919 2
a920 2
	}			/* if (!end_td) ... else */
    }				/* if (multiline) ... else */
d927 1
a927 1
	    ret = 0;		/* XXXX Hack to allow trailing <P> in multiline cells. */
d935 1
a935 1
	     cellstate_s(s->prev_state), cellstate_s(s->state), ret));
d940 4
a943 4
 * Reserve cells, each of given colspan, in (rowspan-1) rows after the current
 * row of rowspan>1.  If rowspan==0, use special 'row' rowspans2eog to keep
 * track of rowspans that are to remain in effect until the end of the row
 * group (until next THEAD/TFOOT/TBODY) or table.
d945 5
a949 3
static int Stbl_reserveCellsInTable(STable_info *me, int icell,
				    int colspan,
				    int rowspan)
d959 2
a960 3
	    (tfp,
	     "TRST:Stbl_reserveCellsInTable(icell=%d, colspan=%d, rowspan=%d)\n",
	     icell, colspan, rowspan));
a963 1

a976 1

d978 1
a978 1
	    return 0;		/* ignore silently, no free memory, may be recoverable */
a988 1

a1006 1

d1019 2
a1020 1
static void Stbl_cancelRowSpans(STable_info *me)
d1026 1
a1026 1
	if (!me->rows[i].ncells) {	/* should always be the case */
d1038 4
a1041 2
int Stbl_addRowToTable(STable_info *me, int alignment,
		       int lineno)
d1044 1
a1044 1
    STable_states *s = &me->s;
d1048 2
a1049 2
	     alignment, lineno));
    if (me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0) {
d1051 1
a1051 4
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len =
		s->pending_len;
d1055 2
a1056 2
    if (me->nrows > 0 && me->rows[me->nrows - 1].Line == lineno)
	me->rows[me->nrows - 1].Line = -1;
a1062 1

d1070 2
a1071 3
			       (me->allocated_rows + growby)
			       * sizeof(STable_rowinfo));

a1079 1

d1112 2
a1113 2
	    (me->rowgroup_align == HT_ALIGN_NONE) ?
	    me->alignment : me->rowgroup_align;
d1119 2
a1120 2
    me->rows[me->nrows].Line = -1;	/* not yet used */
    me->rows[me->nrows].ended = ROW_not_ended;	/* No </tr> yet */
d1127 2
a1128 1
static int Stbl_finishRowInTable(STable_info *me)
d1131 1
a1131 1
    STable_states *s = &me->s;
d1155 8
a1162 7
static void update_sumcols0(STable_cellinfo *sumcols,
			    STable_rowinfo *lastrow,
			    int pos,
			    int len,
			    int icell,
			    int ispan,
			    int allocated_sumcols)
a1164 1

a1168 1

d1172 2
a1173 5
	    if (sumcols[icell + ispan - 1].pos +
		sumcols[icell + ispan - 1].len >
		sumpos)
		sumpos = sumcols[icell + ispan - 1].pos +
		    sumcols[icell + ispan - 1].len;
d1183 1
a1183 2
					    sumcols[i - 1].pos +
					    sumcols[i - 1].len
d1200 6
a1205 5
static int get_remaining_colspan(STable_rowinfo *me,
				 STable_cellinfo *colinfo,
				 int ncolinfo,
				 int colspan,
				 int ncols_sofar)
d1209 1
a1209 1
    me->cells[me->ncells - 1].colspan : 1;
d1225 5
a1229 4
static int Stbl_fakeFinishCellInTable(STable_info *me,
				      STable_rowinfo *lastrow,
				      int lineno,
				      int finishing)	/* Processing finish or start */
d1231 1
a1231 1
    STable_states *s = &me->s;
d1234 1
a1234 1
    switch (s->state) {		/* We care only about trailing <BR> */
d1247 1
a1247 1
	if (finishing == 0)
d1249 1
a1249 1
	break;			/* Either can't happen, or may be ignored */
d1265 2
a1266 2
	int rs = 1;		/* XXXX How to find rowspan? */
	int ih = 0;		/* XXXX How to find is_header? */
d1274 2
a1275 3
		(tfp,
		 "TRST:Stbl_fakeFinishCellInTable(lineno=%d, finishing=%d) START FAKING\n",
		 lineno, finishing));
d1290 1
a1290 1
/* Stbl_finishCellInTable(lineno, 0, 0); *//* Needed? */
d1326 1
a1326 1
		return -1;	/* ignore silently, no free memory, may be recoverable */
a1343 1

d1367 1
a1367 1
		 ncells, (finishing ? ", last unfinished" : "")));
d1371 1
a1371 1
	    if (Stbl_addCellToTable(me, (i == ncells ? cs : 1), rs, al,
d1375 1
a1375 1
	    lastrow->content &= ~HAS_BEG_OF_CELL;	/* BEG_OF_CELL was fake */
d1385 2
a1386 3
		(tfp,
		 "TRST:Stbl_fakeFinishCellInTable(lineno=%d) FINISH FAKING\n",
		 lineno));
d1396 9
a1404 7
int Stbl_addCellToTable(STable_info *me, int colspan,
			int rowspan,
			int alignment,
			int isheader,
			int lineno,
			int offset_not_used_yet GCC_UNUSED,
			int pos)
d1406 1
a1406 1
    STable_states *s = &me->s;
d1412 2
a1413 3
	    (tfp,
	     "TRST:Stbl_addCellToTable(lineno=%d, pos=%d, isheader=%d, cs=%d, rs=%d, al=%d)\n",
	     lineno, pos, (int) isheader, colspan, rowspan, alignment));
d1416 1
a1416 1
    /* ##850_fail_if_fail?? */
d1427 1
a1427 1
	    && lastrow->cells[lastrow->ncells - 1].cLine != lineno) {
a1458 1

a1467 1

d1470 1
a1470 1
		    sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
d1492 1
a1492 1
	sumpos += me->sumcols[ncells - 1].pos - lastrow->cells[ncells - 1].pos;
d1494 1
a1494 3
		    sumpos - ((ncells > 0)
			      ? me->sumcols[icell].pos
			      : me->sumcols[icell].pos),
d1497 1
a1497 1
    me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
d1506 6
a1511 4
int Stbl_finishCellInTable(STable_info *me, int end_td,
			   int lineno,
			   int offset,
			   int pos)
d1513 1
a1513 1
    STable_states *s = &me->s;
d1519 2
a1520 3
	    (tfp,
	     "TRST:Stbl_finishCellInTable(lineno=%d, pos=%d, off=%d, end_td=%d)\n",
	     lineno, pos, offset, (int) end_td));
d1532 1
d1550 1
a1550 1
    xlen = (len > 0) ? len : s->pending_len;	/* ##890 use xlen if fixed_line?: */
a1561 1

d1569 1
a1569 1
			     me->sumcols[i + 1].pos - me->sumcols[icell].pos);
d1588 1
a1588 1
	me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
d1596 2
a1597 1
#ifdef EXP_NESTED_TABLES	/* maxlen may already include contribution of a cell in this column */
d1621 5
a1625 3
int Stbl_addColInfo(STable_info *me, int colspan,
		    short alignment,
		    BOOL isgroup)
d1632 1
a1632 1
	     colspan, alignment, (int) isgroup));
d1638 1
a1638 1
	    me->sumcols[me->ncolinfo - 1].cLine = EOCOLG;
a1651 1

a1660 1

d1663 1
a1663 1
		    sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
d1678 1
a1678 1
    if (alignment == HT_ALIGN_NONE)
d1689 2
a1690 1
int Stbl_finishColGroup(STable_info *me)
d1696 1
a1696 1
	    me->sumcols[me->ncolinfo - 1].cLine = EOCOLG;
d1703 3
a1705 1
int Stbl_addRowGroup(STable_info *me, short alignment)
d1713 2
a1714 1
int Stbl_finishTABLE(STable_info *me)
d1716 1
a1716 1
    STable_states *s = &me->s;
d1724 1
a1724 1
    if (me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0) {
d1726 1
a1726 3
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len = s->pending_len;
d1743 3
a1745 4
	    continue;		/* Not a continuation line */
	minoffset = nextrow[-1].offset;		/* Line before first continuation */
	CTRACE2(TRACE_TRST, (tfp,
			     "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
d1750 1
a1750 4
	       && ((nextrow->content &
		    (IS_CONTINUATION_OF_CELL
		     | HAS_BEG_OF_CELL
		     | BELIEVE_OFFSET))
d1754 2
a1755 4
	    CTRACE2(TRACE_TRST,
		    (tfp,
		     "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
		     j, nextrow->offset, nextrow[-1].ended));
d1759 1
a1759 1
	i = j - 1;		/* Continue after this line */
d1761 2
a1762 2
	j = leading;		/* Restart */
	nextrow = me->rows + j;	/* Line before first continuation */
d1765 1
a1765 1
	while (j <= i) {	/* A continuation line */
d1774 1
a1774 1
	    continue;		/* No offsets to deal with */
d1778 3
a1780 3
	j = leading + 1;	/* Restart */
	nextrow = me->rows + j;	/* First continuation line */
	while (foundcell == -1 && j <= i) {	/* A continuation line */
d1789 1
a1789 1
	if (foundcell == -1)	/* Can it happen? */
d1793 3
a1795 3
	j = leading;		/* Restart */
	nextrow = me->rows + j;	/* Include the pre-continuation line */
	while (j <= i) {	/* A continuation line */
d1806 1
a1806 1
	j = non_empty;		/* Restart from the first nonempty */
d1810 1
a1810 1
			0 /* width only */ , max_width,
d1813 1
a1813 1
	j = leading;		/* Restart from pre-continuation */
d1815 1
a1815 1
	while (j <= i) {	/* A continuation line */
d1821 1
a1821 1
    }				/* END of Offsets processing */
d1838 2
a1839 1
short Stbl_getAlignment(STable_info *me)
d1841 1
a1841 1
    return (short) (me ? me->alignment : HT_ALIGN_NONE);
d1844 5
a1848 3
static int get_fixup_positions(STable_rowinfo *me, int *oldpos,
			       int *newpos,
			       STable_cellinfo *sumcols)
d1895 3
a1897 3
 * Returns -1 if we have no row for this lineno, or for other error,
 *	    0 or greater (number of oldpos/newpos pairs) if we have
 *	      a table row.
d1899 5
a1903 3
int Stbl_getFixupPositions(STable_info *me, int lineno,
			   int *oldpos,
			   int *newpos)
d1905 1
a1905 1
    STable_rowinfo *row;
a1907 1

d1921 2
a1922 1
int Stbl_getStartLine(STable_info *me)
d1932 2
a1933 1
int Stbl_getStartLineDeep(STable_info *me)
d1942 4
a1945 2
void Stbl_update_enclosing(STable_info *me, int max_width,
			   int last_lineno)
d1951 2
a1952 3
    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",
	     max_width, me->startline, last_lineno));
d1955 1
a1955 5
	if (Stbl_finishCellInTable(me->enclosing,
				   TRST_ENDCELL_LINEBREAK,
				   l,
				   0,
				   max_width) < 0) {
d1957 1
a1957 1
	       and it does not buy us anything.  Do it directly. */
d1960 1
a1960 2
	    CTRACE2(TRACE_TRST, (tfp,
				 "TRST:Stbl_update_enclosing: width too large, aborting enclosing\n"));
a1963 1

d1973 4
a1976 1
void Stbl_set_enclosing(STable_info *me, STable_info *enclosing, struct _TextAnchor *enclosing_last_anchor_before_stbl)
d1984 2
a1985 1
STable_info *Stbl_get_enclosing(STable_info *me)
d1992 2
a1993 1
struct _TextAnchor *Stbl_get_last_anchor_before(STable_info *me)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 amended with the 2.8.6dev.3-iz2 patch
@
text
@d20 1
a20 2
#define ROWS_GROWBY_DIVISOR 2
#else /* This is very silly, and leads to *larger* memory consumption... */
a22 1
#define ROWS_GROWBY_DIVISOR 10
a24 6
#define  REUSE_ROWS_AS_CELLS_POOLS 0	/* Turns out to be not beneficial */

/* Experiments show that 2 is better than 1.5 is better than 1.25 (all by
   a small margin only)??? */
#define CELLS_GROWBY_FACTOR 2

d37 1
a37 1
#  define NO_AGGRESSIVE_NEWROW	(tables_disable & TABLES_DISABLE_AGRESSIVE_NEW_ROW)
d74 4
a77 4
    short pos;			/* column where cell starts */
    short len;			/* number of character positions */
    short colspan;		/* number of columns to span */
    short alignment;		/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
a92 9
#define IS_CONTINUATION_OF_MULTICELL	0x40
#define IS_UNSPLIT_CANDIDATE		0x80
#define LAST_CELL_STARTS_WITH_NL	0x100

enum fakeRow_types {
    fakeRow_starting,
    fakeRow_finishing,
    fakeRow_finishing_firstline,
};
d98 1
a98 1
    short ncells;		/* number of table cells */
d122 1
a122 1
    short fixed_line;		/* if we have a 'core' line of cells */
d124 3
a126 5
    short content;		/* Whether contains end-of-cell etc */
    short offset;		/* >=0 after line break in a multiline cell */
    short allocated;		/* number of table cells allocated or 0
				   if the .cells should not be free()ed */
    short alignment;		/* global align attribute for this row */
d128 1
a130 8
struct _STable_chunk;
typedef struct _STable_chunk {
    struct _STable_chunk *next;
    int alloc_cells;
    int used_cells;
    STable_cellinfo cells[1];
} STable_chunk;

a143 1
    int last_reserved;		/* -1 or last line with reserved cells */
a151 2
    STable_chunk *free_chunks;
    STable_chunk *used_chunks;
d202 1
a202 3
static int Stbl_finishCellInRow(STable_rowinfo *me,
				STable_states *s,
				int end_td,
d205 1
a205 1
static int Stbl_DOfinishRowInTable(STable_info *me);
a242 1
	me->last_reserved = -1;
a246 1
	me->used_chunks = me->free_chunks = NULL;
a257 91
static int addmem_rowinfo(STable_info *me,
			  int incr)
{
    int i;
    int growby = 0;
    STable_rowinfo *rows, *row;

    while (me->nrows + incr + 1 > me->allocated_rows + growby)
	growby += ROWS_GROWBY + me->allocated_rows / ROWS_GROWBY_DIVISOR;
    if (growby) {
	if (me->allocated_rows == 0 && !me->rows) {
	    rows = typecallocn(STable_rowinfo, growby);
	} else {
#if REUSE_ROWS_AS_CELLS_POOLS	/* Turns out to be not beneficial */
	    /* Work in a regime which has a chance to work efficiently
	       even with lousy malloc()s: do not realloc() until we
	       have many (2) free chunks available (possible with very
	       simple structure of each row).  Simultaneously,
	       make it possible to use an effecient realloc() which
	       would grow the region in place - so DO use realloc() if
	       we already have many free chunks to put the cellinfo into.
	     */
	    if (me->free_chunks && me->free_chunks->next
		|| (me->allocated_rows * sizeof(STable_rowinfo) <
		      (sizeof(STable_chunk)
		       + (CELLS_GROWBY - 1) * sizeof(STable_cellinfo)))
		|| 1)
#endif
	    {
		rows = realloc(me->rows,
			       (me->allocated_rows + growby)
			       * sizeof(STable_rowinfo));
	    }
#if REUSE_ROWS_AS_CELLS_POOLS
	    else {
		rows = malloc((me->allocated_rows + growby)
			      * sizeof(STable_rowinfo));

		if (rows) {
		    STable_chunk *p;

		    memcpy(rows, me->rows,
			   (me->allocated_rows + growby)
			   * sizeof(STable_rowinfo));

		    p = (STable_chunk *) me->rows;
		    p->alloc_cells =
			1 + (me->allocated_rows * sizeof(STable_rowinfo)
			     - sizeof(STable_chunk)) / sizeof(STable_cellinfo);

		    p->used_cells = 0;
		    p->next = me->free_chunks;
		    me->free_chunks = p;
		}
	    }
#endif
	    for (i = 0; rows && i < growby; i++) {
		row = rows + me->allocated_rows + i;
		if (!me->rowspans2eog.allocated) {
		    row->allocated = 0;
		    row->cells = NULL;
		} else {
		    row->cells = typecallocn(STable_cellinfo,
					     me->rowspans2eog.allocated);

		    if (row->cells) {
			row->allocated = me->rowspans2eog.allocated;
			memcpy(row->cells, me->rowspans2eog.cells,
			       row->allocated * sizeof(STable_cellinfo));
		    } else {
			FREE(rows);
			break;
		    }
		}
		row->ncells = 0;
		row->fixed_line = NO;
		row->alignment = HT_ALIGN_NONE;
		row->offset = 0;
		row->content = 0;
	    }
	}
	if (rows) {
	    me->allocated_rows += growby;
	    me->rows = rows;
	} else {
	    return 0;
	}
    }
    return 1;
}

a271 12
    if (me) {
	STable_chunk *this;

	while ((this = me->free_chunks)) {
	    me->free_chunks = this->next;
	    FREE(this);
	}
	while ((this = me->used_chunks)) {
	    me->used_chunks = this->next;
	    FREE(this);
	}
    }
d278 1
a278 3
static int Stbl_addCellToRow(STable_rowinfo *me,
			     STable_cellinfo *colinfo,
			     int ncolinfo,
d451 1
a451 1
	    if (!me->cells) {
d454 3
a456 9
		if (me->allocated == 0) {	/* Put into pool */
		    cells = typecallocn(STable_cellinfo, growby);

		    memcpy(cells, me->cells,
			   me->ncells * sizeof(STable_cellinfo));
		} else
		    cells = realloc(me->cells,
				    (me->allocated + growby)
				    * sizeof(STable_cellinfo));
d512 1
a512 2
static int Stbl_reserveCellsInRow(STable_rowinfo *me,
				  int icell,
d549 1
a549 3
static int Stbl_finishCellInRow(STable_rowinfo *me,
				STable_states *s,
				int end_td,
d954 1
a954 2
static int Stbl_reserveCellsInTable(STable_info *me,
				    int icell,
d958 3
a960 1
    int i, last;
d981 18
a998 2
    if (!addmem_rowinfo(me, rowspan - 1))
	return 0;		/* ignore silently, no free memory, may be recoverable */
d1000 16
a1015 4
    last = (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
    if (me->last_reserved < last)
	me->last_reserved = last;
    for (i = me->nrows; i < last; i++) {
d1049 1
a1049 2
int Stbl_addRowToTable(STable_info *me,
		       int alignment,
d1052 1
d1060 4
a1063 2
	    me->rows[me->nrows - 1].cells[me->rows[me->nrows - 1].ncells -
					  1].len = s->pending_len;
d1066 1
a1066 1
    Stbl_DOfinishRowInTable(me);
d1072 47
a1118 2
    if (!addmem_rowinfo(me, 1))
	return -1;
a1128 48
    if (me->nrows >= 2		/* We may use RESERVEDCELL flag of cells in nrows-1 */
	&& me->rows[me->nrows - 2].allocated > me->rows[me->nrows - 2].ncells) {
	int c = me->rows[me->nrows - 2].ncells;
	STable_cellinfo *p = me->rows[me->nrows - 2].cells;

#if 0				/* Leads to no memory savings and quadratic time with EMX malloc */
	/* Do not need extra cells any more */
	me->rows[me->nrows - 2].cells = realloc(p, c * sizeof(STable_cellinfo));

	me->rows[me->nrows - 2].allocated = me->rows[me->nrows - 2].ncells;
#else
	if (!me->used_chunks
	    || ((me->used_chunks->alloc_cells - me->used_chunks->used_cells)
		< c)) {
	    if (me->free_chunks && (me->free_chunks->alloc_cells >= c)) {
		STable_chunk *p2 = me->free_chunks;

		me->free_chunks = p2->next;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    } else {		/* Need to get a new guy */
		STable_chunk *p2;

		if (c < CELLS_GROWBY)
		    c = CELLS_GROWBY;
		if (me->used_chunks
		    && c < me->used_chunks->alloc_cells * CELLS_GROWBY_FACTOR)
		    c = 2 * me->used_chunks->alloc_cells * CELLS_GROWBY_FACTOR;
		p2 = malloc(sizeof(STable_chunk) + (c - 1) * sizeof(STable_cellinfo));

		if (p2 == NULL)
		    outofmem(__FILE__, "Stbl_addRowToTable");
		p2->alloc_cells = c;
		p2->used_cells = 0;
		p2->next = me->used_chunks;
		me->used_chunks = p2;
	    }
	}
	memcpy(me->used_chunks->cells + me->used_chunks->used_cells,
	       p, me->rows[me->nrows - 2].ncells * sizeof(STable_cellinfo));

	me->rows[me->nrows - 2].cells =
	    me->used_chunks->cells + me->used_chunks->used_cells;
	me->used_chunks->used_cells += me->rows[me->nrows - 2].ncells;
	me->rows[me->nrows - 2].allocated = 0;	/* Do not FREE() */
	FREE(p);
#endif
    }
d1142 1
a1142 1
static int Stbl_DOfinishRowInTable(STable_info *me)
d1148 1
a1148 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_DOfinishRowInTable()\n"));
d1153 1
a1153 2
    if (lastrow->ended != ROW_ended_by_splitline)
	lastrow->ended = ROW_ended_by_endtr;
d1187 5
a1191 4
	    if (sumcols[icell + ispan - 1].pos + sumcols[icell + ispan -
							 1].len > sumpos)
		sumpos = sumcols[icell + ispan - 1].pos + sumcols[icell +
								  ispan - 1].len;
d1201 2
a1202 2
					    sumcols[i - 1].pos + sumcols[i -
									 1].len
d1246 1
a1246 1
				      enum fakeRow_types finishing)	/* Processing finish or start */
d1264 1
a1264 1
	if (finishing == fakeRow_starting)
a1288 1
	int is_multicell = 0;
a1294 5
	if (lastrow->ncells > 1
	    && (lastrow->cells[lastrow->ncells - 2].pos
		!= lastrow->cells[lastrow->ncells - 1].pos))
	    is_multicell = 1;

d1300 1
a1300 1
	if (finishing != fakeRow_starting) {
a1315 4
	if (is_multicell)
	    lastrow->content |= IS_CONTINUATION_OF_MULTICELL;
	if (finishing == fakeRow_finishing_firstline)
	    lastrow->content |= IS_UNSPLIT_CANDIDATE;
a1351 1
	    me->last_reserved++;
a1356 1
	    lastrow[1].content = 0;
d1386 1
a1386 4
		 ncells,
		 ((finishing != fakeRow_starting)
		  ? ", last unfinished"
		  : "")));
d1397 1
a1397 1
	    if (finishing == fakeRow_starting || (i != ncells)) {
d1408 1
a1408 2
    } else if (finishing == fakeRow_finishing_firstline)
	lastrow->content |= LAST_CELL_STARTS_WITH_NL;
d1416 1
a1416 2
int Stbl_addCellToTable(STable_info *me,
			int colspan,
d1447 1
a1447 1
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, fakeRow_starting);
d1515 3
a1517 2
		    sumpos - (ncells > 0 ? me->sumcols[icell].pos :
			      me->sumcols[icell].pos),
a1525 130
BOOL Stbl_at_start_of_cell(STable_info *me,
			   int lineno,
			   int pos)
{
    STable_rowinfo *lastrow;
    int icell;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_at_start_of_cell(lineno=%d, pos=%d): ",
	     lineno, pos));
    if (me->nrows == 0)
	goto yes;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended != ROW_not_ended)
	goto no;		/* E.g., may be processing </tr> */
    icell = lastrow->ncells - 1;
    if (icell < 0)
	goto yes;
    if (lastrow->cells[icell].cLine != lineno
	|| lastrow->cells[icell].pos != pos) {
      no:
	CTRACE2(TRACE_TRST, (tfp, "no\n"));
	return FALSE;		/* XXXX  What to do if cLine is -1? */
    }
  yes:
    CTRACE2(TRACE_TRST, (tfp, "yes\n"));
    return TRUE;
}

int Stbl_start_of_last_cell(STable_info *me,
			    int lineno)
{
    STable_rowinfo *lastrow;
    int icell;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_at_start_of_cell(lineno=%d)\n", lineno));
    if (me->nrows == 0)
	return -1;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended != ROW_not_ended)
	return -1;		/* E.g., may be processing </tr> */
    icell = lastrow->ncells - 1;
    if (icell >= 0 && lastrow->cells[icell].cLine == lineno)
	return lastrow->cells[icell].pos;
    return -1;
}

void Stbl_finishRowInTable(STable_info *me)
{
    STable_rowinfo *lastrow;

    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_finishRowInTable()\n"));
    if (me->nrows <= 0)
	return;
    lastrow = me->rows + (me->nrows - 1);
    if (lastrow->ended == ROW_not_ended)
	lastrow->ended = ROW_ended_by_endtr;
}

/* Assumes that the current pos is at beginning of line.
   Checks whether the last row was a fake row, and undo it if possible.
   Returns TRUE if the last line (empty!) can be safely trimmed. */
int Stbl_trimFakeRows(STable_info *me,
		      int lineno,
		      int pos GCC_UNUSED)
{
    STable_rowinfo *prevrow, *lastrow;
    int icell;

    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_trimFakeRows()\n"));

    /* XXXX The logic may be much better if we support removal of
       RESERVED cells.  Until this is done, bail out early: */
    if (me->nrows <= 0 || me->nrows <= me->last_reserved)
	return 0;
    lastrow = me->rows + (me->nrows - 1);
    icell = lastrow->ncells - 1;
    if (icell >= 0 && lastrow->cells[icell].cLine < lineno) {
	/* The last cell start on a preceeding line; keep lastrow */
	lastrow->ended = ROW_not_ended;		/* Give it new life */
	/* We do not use state info for a lot of things any more, so do
	   not try to do anything special here */
	me->s.state = CS__0new;	/* This is enough to revive things. */
	me->s.x_td = lastrow->cells[lastrow->ncells - 1].pos;
	me->s.lineno = lastrow->cells[lastrow->ncells - 1].cLine;
	lastrow->content &= ~LAST_CELL_STARTS_WITH_NL;
	CTRACE2(TRACE_TRST, (tfp, "  un-ended the last row.\n"));
	return 1;
    }
    if (me->nrows <= 1 || !(lastrow->content & IS_CONTINUATION_OF_CELL))
	return 0;
    prevrow = me->rows + (me->nrows - 2);
    if (prevrow->ncells != icell + 1)	/* Empty cells were added after the break */
	return 0;
    if (prevrow->ended != ROW_ended_by_splitline)	/* Lastrow non-fake */
	return 0;
    me->nrows--;
    /* prevrow is now the last row, so its cells should be realloc()able */
    if (prevrow->cells && prevrow->allocated == 0) {	/* Moved to pool */
	int c = prevrow->ncells;
	STable_cellinfo *p;

	if (lastrow->allocated > c)	/* May have RESERVED info */
	    c = lastrow->allocated;
	if ((p = malloc(c * sizeof(STable_cellinfo))) == NULL)
	      outofmem(__FILE__, "Stbl_trimFakeRows ");
	memcpy(p, prevrow->cells, prevrow->ncells * sizeof(STable_cellinfo));

	/* Copy back the possibly present RESERVED info.
	   XXXX remove duplicated RESERVED stuff from the followup rows too! */
	memcpy(p + prevrow->ncells, lastrow->cells + prevrow->ncells,
	       (c - prevrow->ncells) * sizeof(STable_cellinfo));

	prevrow->cells = p;	/* XXXX How would ride with RESERVED? */
	prevrow->allocated = c;
    }
    lastrow->ncells = 0;
    lastrow->content = 0;
    prevrow->ended = ROW_not_ended;	/* Give it new life */
    /* We do not use state info for a lot of things any more, so do
       not try to do anything special here */
    me->s.state = CS__0new;
    me->s.x_td = prevrow->cells[prevrow->ncells - 1].pos;
    me->s.lineno = prevrow->cells[prevrow->ncells - 1].cLine;
    CTRACE2(TRACE_TRST, (tfp, "  Removed the last row.\n"));
    return 1;
}

d1529 1
a1529 2
int Stbl_finishCellInTable(STable_info *me,
			   int end_td,
d1557 1
a1557 9
	    /* Last cell, has it a newline in a beginning of cell? */
	    int nn = ((lastrow->content & LAST_CELL_STARTS_WITH_NL)
		      && lineno > lastrow->cells[icell].cLine)
	    || ((lastrow->content & HAS_BEG_OF_CELL)
		&& lastrow->cells[icell].pos >= pos);
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno,
						nn
						? fakeRow_finishing_firstline
						: fakeRow_finishing);
d1642 1
a1642 2
int Stbl_addColInfo(STable_info *me,
		    int colspan,
d1723 1
a1723 2
int Stbl_addRowGroup(STable_info *me,
		     short alignment)
d1743 3
a1745 2
	    me->rows[me->nrows - 1].cells[me->rows[me->nrows - 1].ncells -
					  1].len = s->pending_len;
d1748 1
a1748 1
    Stbl_DOfinishRowInTable(me);
d1760 1
a1760 2
	if ((nextrow->content & (IS_CONTINUATION_OF_CELL | HAS_BEG_OF_CELL
				 | IS_CONTINUATION_OF_MULTICELL | BELIEVE_OFFSET))
d1770 4
a1773 2
	       && ((nextrow->content & (IS_CONTINUATION_OF_CELL |
					HAS_BEG_OF_CELL | BELIEVE_OFFSET))
d1777 4
a1780 3
	    CTRACE2(TRACE_TRST, (tfp,
				 "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
				 j, nextrow->offset, nextrow[-1].ended));
d1868 1
a1868 2
static int get_fixup_positions(STable_rowinfo *me,
			       int *oldpos,
d1870 1
a1870 6
			       STable_cellinfo *sumcols,
			       int prevline_len,
			       int *do_unsplit,
			       int *row_start_line_p,
			       int *cur_col_p,
			       int *cell_line_count_p)
a1874 3
    int unsplit = (*do_unsplit && (me->content & IS_UNSPLIT_CANDIDATE)
		   && prevline_len >= 0);
    int did_unsplit = 0, delta = 0;
a1877 4
    *do_unsplit = -1;
    (*cell_line_count_p)++;
    if (!(me->content & IS_CONTINUATION_OF_CELL))
	*row_start_line_p = me->Line;
d1879 1
a1879 1
	int offset, pos;
d1888 1
d1895 1
a1895 1
	pos = sumcols[i].pos + offset;
d1899 1
a1899 1
	    newlen = sumcols[next_i].pos - sumcols[i].pos - offset - 1;
d1903 1
a1903 1
		    pos += newlen - me->cells[i].len;
d1905 1
a1905 1
		    pos += (newlen - me->cells[i].len) / 2;
a1908 14
	if (!me->cells[i].pos && me->cells[i].len) {
	    if (i != *cur_col_p) {
		*cell_line_count_p = 0;
		*cur_col_p = i;
	    }
	    if ((unsplit || *cur_col_p > 0) && !did_unsplit) {
		did_unsplit = 1;
		delta = sumcols[i].pos;
		ip = 0;		/* Undo changes */
		*do_unsplit = delta;
	    }
	}
	oldpos[ip] = me->cells[i].pos;
	newpos[ip] = pos - delta;
d1921 1
a1921 2
int Stbl_getFixupPositions(STable_info *me,
			   int lineno,
d1923 1
a1923 6
			   int *newpos,
			   int prevline_len,
			   int *do_unsplit,
			   int *row_start_line_p,
			   int *cur_col_p,
			   int *cell_line_count_p)
d1927 1
a1927 2
    int ninserts = -1, found = 0;
    static int prev_row = 0;
d1931 1
a1931 5
    if (prev_row < me->nrows && me->rows[prev_row].Line <= lineno)
	j = prev_row;
    else
	j = 0;
    for (; j < me->nrows; j++) {
a1933 2
	    prev_row = j;
	    found = 1;
d1935 1
a1935 3
					   me->sumcols, prevline_len,
					   do_unsplit, row_start_line_p,
					   cur_col_p, cell_line_count_p);
a1938 2
    if (!found)
	*row_start_line_p = -1;
d1961 1
a1961 2
void Stbl_update_enclosing(STable_info *me,
			   int max_width,
d1968 3
a1970 3
    CTRACE2(TRACE_TRST, (tfp,
			 "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",
			 max_width, me->startline, last_lineno));
d1974 4
a1977 1
				   TRST_ENDCELL_LINEBREAK, l, 0, max_width) < 0) {
d1997 1
a1997 3
void Stbl_set_enclosing(STable_info *me,
			STable_info *enclosing,
			struct _TextAnchor *enclosing_last_anchor_before_stbl)
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d20 2
a21 1
#else
d24 1
d27 6
d34 1
a34 1
#  define MAX_STBL_POS (LYwideLines ? MAX_COLS - 1 : LYcolLimit)
d36 1
a36 1
#  define MAX_STBL_POS (LYcolLimit)
d45 1
a45 1
#  define NO_AGGRESSIVE_NEWROW	0
d82 4
a85 4
    int pos;			/* column where cell starts */
    int len;			/* number of character positions */
    int colspan;		/* number of columns to span */
    int alignment;		/* one of HT_LEFT, HT_CENTER, HT_RIGHT,
d101 9
d115 1
a115 1
    int ncells;			/* number of table cells */
d139 1
a139 1
    BOOL fixed_line;		/* if we have a 'core' line of cells */
d141 5
a145 3
    int content;		/* Whether contains end-of-cell etc */
    int offset;			/* >=0 after line break in a multiline cell */
    int allocated;		/* number of table cells allocated */
a146 1
    int alignment;		/* global align attribute for this row */
d149 8
d170 1
d179 2
d231 3
a233 1
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
d236 1
a236 1
static int Stbl_finishRowInTable(STable_info *me);
d274 1
d279 1
d291 91
d396 12
d414 3
a416 1
static int Stbl_addCellToRow(STable_rowinfo *me, STable_cellinfo *colinfo, int ncolinfo,
d589 1
a589 1
	    if (me->allocated == 0 && !me->cells) {
d592 9
a600 3
		cells = realloc(me->cells,
				(me->allocated + growby)
				* sizeof(STable_cellinfo));
d656 2
a657 1
static int Stbl_reserveCellsInRow(STable_rowinfo *me, int icell,
d694 3
a696 1
static int Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td,
d1101 2
a1102 1
static int Stbl_reserveCellsInTable(STable_info *me, int icell,
d1106 1
a1106 3
    STable_rowinfo *rows, *row;
    int growby;
    int i;
d1127 2
a1128 18
    growby = me->nrows + rowspan - 1 - me->allocated_rows;
    if (growby > 0) {
	rows = realloc(me->rows,
		       (me->allocated_rows + growby)
		       * sizeof(STable_rowinfo));

	if (!rows)
	    return 0;		/* ignore silently, no free memory, may be recoverable */
	for (i = 0; i < growby; i++) {
	    row = rows + me->allocated_rows + i;
	    row->allocated = 0;
	    row->offset = 0;
	    row->content = 0;
	    if (!me->rowspans2eog.allocated) {
		row->cells = NULL;
	    } else {
		row->cells = typecallocn(STable_cellinfo,
					 me->rowspans2eog.allocated);
d1130 4
a1133 16
		if (row->cells) {
		    row->allocated = me->rowspans2eog.allocated;
		    memcpy(row->cells, me->rowspans2eog.cells,
			   row->allocated * sizeof(STable_cellinfo));
		}
	    }
	    row->ncells = 0;
	    row->fixed_line = NO;
	    row->alignment = HT_ALIGN_NONE;
	}
	me->allocated_rows += growby;
	me->rows = rows;
    }
    for (i = me->nrows;
	 i < (rowspan == 0 ? me->allocated_rows : me->nrows + rowspan - 1);
	 i++) {
d1167 2
a1168 1
int Stbl_addRowToTable(STable_info *me, int alignment,
a1170 1
    STable_rowinfo *rows, *row;
d1178 2
a1179 4
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len =
		s->pending_len;
d1182 1
a1182 1
    Stbl_finishRowInTable(me);
d1188 2
a1189 47
    {
	int i;
	int growby = 0;

	while (me->nrows + 2 > me->allocated_rows + growby)
	    growby += ROWS_GROWBY;
	if (growby) {
	    if (me->allocated_rows == 0 && !me->rows) {
		rows = typecallocn(STable_rowinfo, growby);
	    } else {
		rows = realloc(me->rows,
			       (me->allocated_rows + growby)
			       * sizeof(STable_rowinfo));

		for (i = 0; rows && i < growby; i++) {
		    row = rows + me->allocated_rows + i;
		    if (!me->rowspans2eog.allocated) {
			row->allocated = 0;
			row->cells = NULL;
		    } else {
			row->cells = typecallocn(STable_cellinfo,
						 me->rowspans2eog.allocated);

			if (row->cells) {
			    row->allocated = me->rowspans2eog.allocated;
			    memcpy(row->cells, me->rowspans2eog.cells,
				   row->allocated * sizeof(STable_cellinfo));
			} else {
			    FREE(rows);
			    break;
			}
		    }
		    row->ncells = 0;
		    row->fixed_line = NO;
		    row->alignment = HT_ALIGN_NONE;
		    row->offset = 0;
		    row->content = 0;
		}
	    }
	    if (rows) {
		me->allocated_rows += growby;
		me->rows = rows;
	    } else {
		return -1;
	    }
	}
    }
d1200 48
d1261 1
a1261 1
static int Stbl_finishRowInTable(STable_info *me)
d1267 1
a1267 1
    CTRACE2(TRACE_TRST, (tfp, "TRST:Stbl_finishRowInTable()\n"));
d1272 2
a1273 1
    lastrow->ended = ROW_ended_by_endtr;
d1307 4
a1310 5
	    if (sumcols[icell + ispan - 1].pos +
		sumcols[icell + ispan - 1].len >
		sumpos)
		sumpos = sumcols[icell + ispan - 1].pos +
		    sumcols[icell + ispan - 1].len;
d1320 2
a1321 2
					    sumcols[i - 1].pos +
					    sumcols[i - 1].len
d1365 1
a1365 1
				      int finishing)	/* Processing finish or start */
d1383 1
a1383 1
	if (finishing == 0)
d1408 1
d1415 5
d1425 1
a1425 1
	if (finishing) {
d1441 4
d1481 1
d1487 1
d1517 4
a1520 1
		 ncells, (finishing ? ", last unfinished" : "")));
d1531 1
a1531 1
	    if (!finishing || (i != ncells)) {
d1542 2
a1543 1
    }
d1551 2
a1552 1
int Stbl_addCellToTable(STable_info *me, int colspan,
d1583 1
a1583 1
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 0);
d1651 2
a1652 3
		    sumpos - ((ncells > 0)
			      ? me->sumcols[icell].pos
			      : me->sumcols[icell].pos),
d1661 130
d1794 2
a1795 1
int Stbl_finishCellInTable(STable_info *me, int end_td,
d1823 9
a1831 1
	    int rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 1);
d1916 2
a1917 1
int Stbl_addColInfo(STable_info *me, int colspan,
d1998 2
a1999 1
int Stbl_addRowGroup(STable_info *me, short alignment)
d2019 2
a2020 3
	    me->rows[me->nrows - 1].cells[
					     me->rows[me->nrows - 1].ncells - 1
		].len = s->pending_len;
d2023 1
a2023 1
    Stbl_finishRowInTable(me);
d2035 2
a2036 1
	if ((nextrow->content & (IS_CONTINUATION_OF_CELL | HAS_BEG_OF_CELL | BELIEVE_OFFSET))
d2046 2
a2047 4
	       && ((nextrow->content &
		    (IS_CONTINUATION_OF_CELL
		     | HAS_BEG_OF_CELL
		     | BELIEVE_OFFSET))
d2051 3
a2053 4
	    CTRACE2(TRACE_TRST,
		    (tfp,
		     "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%d.\n",
		     j, nextrow->offset, nextrow[-1].ended));
d2141 2
a2142 1
static int get_fixup_positions(STable_rowinfo *me, int *oldpos,
d2144 6
a2149 1
			       STable_cellinfo *sumcols)
d2154 3
d2160 4
d2165 1
a2165 1
	int offset;
a2173 1
	oldpos[ip] = me->cells[i].pos;
d2180 1
a2180 1
	newpos[ip] = sumcols[i].pos + offset;
d2184 1
a2184 1
	    newlen = sumcols[next_i].pos - newpos[ip] - 1;
d2188 1
a2188 1
		    newpos[ip] += newlen - me->cells[i].len;
d2190 1
a2190 1
		    newpos[ip] += (newlen - me->cells[i].len) / 2;
d2194 14
d2220 2
a2221 1
int Stbl_getFixupPositions(STable_info *me, int lineno,
d2223 6
a2228 1
			   int *newpos)
d2232 2
a2233 1
    int ninserts = -1;
d2237 5
a2241 1
    for (j = 0; j < me->nrows; j++) {
d2244 2
d2247 3
a2249 1
					   me->sumcols);
d2253 2
d2277 2
a2278 1
void Stbl_update_enclosing(STable_info *me, int max_width,
d2285 3
a2287 3
    CTRACE2(TRACE_TRST,
	    (tfp, "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",
	     max_width, me->startline, last_lineno));
d2291 1
a2291 4
				   TRST_ENDCELL_LINEBREAK,
				   l,
				   0,
				   max_width) < 0) {
d2311 3
a2313 1
void Stbl_set_enclosing(STable_info *me, STable_info *enclosing, struct _TextAnchor *enclosing_last_anchor_before_stbl)
@


1.1.1.1
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@@
