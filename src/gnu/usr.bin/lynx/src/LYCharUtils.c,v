head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.5
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.4
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.4.0.6
	MIRBSD_7:1.4.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.4
	MIRBSD_7_DEV:1.4.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.2
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.45.55;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.20.10.26.26;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.11.20.30.40;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.52;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.31;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.13.12.44;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.28;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.26;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.20;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.37;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.24;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2003.09.27.12.46.17;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.16.08;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.54.21;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.11.20.16.24;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/*
 *  Functions associated with LYCharSets.c and the Lynx version of HTML.c - FM
 *  ==========================================================================
 */
#include <HTUtils.h>
#include <SGML.h>

#define Lynx_HTML_Handler
#include <HTChunk.h>
#include <HText.h>
#include <HTStyle.h>
#include <HTMIME.h>
#include <HTML.h>

#include <HTCJK.h>
#include <HTAtom.h>
#include <HTMLGen.h>
#include <HTParse.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYGlobalDefs.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>

#include <HTAlert.h>
#include <HTForms.h>
#include <HTNestedList.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYMap.h>
#include <LYBookmark.h>
#include <LYCurses.h>
#include <LYCookie.h>

#include <LYexit.h>
#include <LYLeaks.h>

/*
 * Used for nested lists.  - FM
 */
int OL_CONTINUE = -29999;	/* flag for whether CONTINUE is set */
int OL_VOID = -29998;		/* flag for whether a count is set */

/*
 *  This function converts any ampersands in allocated
 *  strings to "&amp;".  If isTITLE is TRUE, it also
 *  converts any angle-brackets to "&lt;" or "&gt;". - FM
 */
void LYEntify(char **str,
	      BOOLEAN isTITLE)
{
    char *p = *str;
    char *q = NULL, *cp = NULL;
    int amps = 0, lts = 0, gts = 0;

#ifdef CJK_EX
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren
    } state = S_text;
    int in_sjis = 0;
#endif

    if (isEmpty(p))
	return;

    /*
     * Count the ampersands.  - FM
     */
    while ((*p != '\0') && (q = strchr(p, '&')) != NULL) {
	amps++;
	p = (q + 1);
    }

    /*
     * Count the left-angle-brackets, if needed.  - FM
     */
    if (isTITLE == TRUE) {
	p = *str;
	while ((*p != '\0') && (q = strchr(p, '<')) != NULL) {
	    lts++;
	    p = (q + 1);
	}
    }

    /*
     * Count the right-angle-brackets, if needed.  - FM
     */
    if (isTITLE == TRUE) {
	p = *str;
	while ((*p != '\0') && (q = strchr(p, '>')) != NULL) {
	    gts++;
	    p = (q + 1);
	}
    }

    /*
     * Check whether we need to convert anything.  - FM
     */
    if (amps == 0 && lts == 0 && gts == 0)
	return;

    /*
     * Allocate space and convert.  - FM
     */
    q = typecallocn(char,
		    (strlen(*str) + (4 * amps) + (3 * lts) + (3 * gts) + 1));
    if ((cp = q) == NULL)
	outofmem(__FILE__, "LYEntify");
    for (p = *str; *p; p++) {
#ifdef CJK_EX
	if (HTCJK != NOCJK) {
	    switch (state) {
	    case S_text:
		if (*p == '\033') {
		    state = S_esc;
		    *q++ = *p;
		    continue;
		}
		break;

	    case S_esc:
		if (*p == '$') {
		    state = S_dollar;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}

	    case S_dollar:
		if (*p == '@@' || *p == 'B' || *p == 'A') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_dollar_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}

	    case S_dollar_paren:
		if (*p == 'C') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}

	    case S_paren:
		if (*p == 'B' || *p == 'J' || *p == 'T') {
		    state = S_text;
		    *q++ = *p;
		    continue;
		} else if (*p == 'I') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		}
		/* FALLTHRU */

	    case S_nonascii_text:
		if (*p == '\033')
		    state = S_esc;
		*q++ = *p;
		continue;

	    default:
		break;
	    }
	    if (*(p + 1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p + 1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p + 1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p + 1))))) {
		*q++ = *p++;
		*q++ = *p;
		continue;
	    }
	}
#endif
	if (*p == '&') {
	    *q++ = '&';
	    *q++ = 'a';
	    *q++ = 'm';
	    *q++ = 'p';
	    *q++ = ';';
	} else if (isTITLE && *p == '<') {
	    *q++ = '&';
	    *q++ = 'l';
	    *q++ = 't';
	    *q++ = ';';
	} else if (isTITLE && *p == '>') {
	    *q++ = '&';
	    *q++ = 'g';
	    *q++ = 't';
	    *q++ = ';';
	} else {
	    *q++ = *p;
	}
    }
    *q = '\0';
    FREE(*str);
    *str = cp;
}

/*
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1) and HT_EN_SPACE (2),
 *  but not ESC, from the heads of strings. - FM
 */
void LYTrimHead(char *str)
{
    const char *s = str;

    if (isEmpty(s))
	return;

    while (*s && WHITE(*s) && UCH(*s) != UCH(CH_ESC))	/* S/390 -- gil -- 1669 */
	s++;
    if (s > str) {
	char *ns = str;

	while (*s) {
	    *ns++ = *s++;
	}
	*ns = '\0';
    }
}

/*
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1), HT_EN_SPACE (2), and
 *  ESC from the tails of strings. - FM
 */
void LYTrimTail(char *str)
{
    int i;

    if (isEmpty(str))
	return;

    i = strlen(str) - 1;
    while (i >= 0) {
	if (WHITE(str[i]))
	    str[i] = '\0';
	else
	    break;
	i--;
    }
}

/*
 * This function should receive a pointer to the start
 * of a comment.  It returns a pointer to the end ('>')
 * character of comment, or it's best guess if the comment
 * is invalid. - FM
 */
char *LYFindEndOfComment(char *str)
{
    char *cp, *cp1;
    enum comment_state {
	start1,
	start2,
	end1,
	end2
    } state;

    if (str == NULL)
	/*
	 * We got NULL, so return NULL.  - FM
	 */
	return NULL;

    if (strncmp(str, "<!--", 4))
	/*
	 * We don't have the start of a comment, so return the beginning of the
	 * string.  - FM
	 */
	return str;

    cp = (str + 4);
    if (*cp == '>')
	/*
	 * It's an invalid comment, so
	 * return this end character. - FM
	 */
	return cp;

    if ((cp1 = strchr(cp, '>')) == NULL)
	/*
	 * We don't have an end character, so return the beginning of the
	 * string.  - FM
	 */
	return str;

    if (*cp == '-')
	/*
	 * Ugh, it's a "decorative" series of dashes, so return the next end
	 * character.  - FM
	 */
	return cp1;

    /*
     * OK, we're ready to start parsing.  - FM
     */
    state = start2;
    while (*cp != '\0') {
	switch (state) {
	case start1:
	    if (*cp == '-')
		state = start2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;

	case start2:
	    if (*cp == '-')
		state = end1;
	    break;

	case end1:
	    if (*cp == '-')
		state = end2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;

	case end2:
	    if (*cp == '>')
		/*
		 * Valid comment, so return the end character.  - FM
		 */
		return cp;
	    if (*cp == '-') {
		state = start1;
	    } else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {	/* S/390 -- gil -- 1686 */
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    }
	    break;

	default:
	    break;
	}
	cp++;
    }

    /*
     * Invalid comment, so return the first '>' from the start of the string. 
     * - FM
     */
    return cp1;
}

/*
 *  If an HREF, itself or if resolved against a base,
 *  represents a file URL, and the host is defaulted,
 *  force in "//localhost".  We need this until
 *  all the other Lynx code which performs security
 *  checks based on the "localhost" string is changed
 *  to assume "//localhost" when a host field is not
 *  present in file URLs - FM
 */
void LYFillLocalFileURL(char **href,
			const char *base)
{
    char *temp = NULL;

    if (isEmpty(*href))
	return;

    if (!strcmp(*href, "//") || !strncmp(*href, "///", 3)) {
	if (base != NULL && isFILE_URL(base)) {
	    StrAllocCopy(temp, STR_FILE_URL);
	    StrAllocCat(temp, *href);
	    StrAllocCopy(*href, temp);
	}
    }
    if (isFILE_URL(*href)) {
	if (*(*href + 5) == '\0') {
	    StrAllocCat(*href, "//localhost");
	} else if (!strcmp(*href, "file://")) {
	    StrAllocCat(*href, "localhost");
	} else if (!strncmp(*href, "file:///", 8)) {
	    StrAllocCopy(temp, (*href + 7));
	    LYLocalFileToURL(href, temp);
	} else if (!strncmp(*href, "file:/", 6) && !LYIsHtmlSep(*(*href + 6))) {
	    StrAllocCopy(temp, (*href + 5));
	    LYLocalFileToURL(href, temp);
	}
    }
#if defined(USE_DOS_DRIVES)
    if (LYIsDosDrive(*href)) {
	/*
	 * If it's a local DOS path beginning with drive letter,
	 * add file://localhost/ prefix and go ahead.
	 */
	StrAllocCopy(temp, *href);
	LYLocalFileToURL(href, temp);
    }

    /* use below: strlen("file://localhost/") = 17 */
    if (!strncmp(*href, "file://localhost/", 17)
	&& (strlen(*href) == 19)
	&& LYIsDosDrive(*href + 17)) {
	/*
	 * Terminate DOS drive letter with a slash to surf root successfully.
	 * Here seems a proper place to do so.
	 */
	LYAddPathSep(href);
    }
#endif /* USE_DOS_DRIVES */

    /*
     * No path in a file://localhost URL means a
     * directory listing for the current default. - FM
     */
    if (!strcmp(*href, "file://localhost")) {
	const char *temp2;

#ifdef VMS
	temp2 = HTVMS_wwwName(LYGetEnv("PATH"));
#else
	char curdir[LY_MAXPATH];

	temp2 = wwwName(Current_Dir(curdir));
#endif /* VMS */
	if (!LYIsHtmlSep(*temp2))
	    LYAddHtmlSep(href);
	/*
	 * Check for pathological cases - current dir has chars which MUST BE
	 * URL-escaped - kw
	 */
	if (strchr(temp2, '%') != NULL || strchr(temp2, '#') != NULL) {
	    FREE(temp);
	    temp = HTEscape(temp2, URL_PATH);
	    StrAllocCat(*href, temp);
	} else {
	    StrAllocCat(*href, temp2);
	}
    }
#ifdef VMS
    /*
     * On VMS, a file://localhost/ URL means
     * a listing for the login directory. - FM
     */
    if (!strcmp(*href, "file://localhost/"))
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir()) + 1));
#endif /* VMS */

    FREE(temp);
    return;
}

/*
 *  This function writes a line with a META tag to an open file,
 *  which will specify a charset parameter to use when the file is
 *  read back in.  It is meant for temporary HTML files used by the
 *  various special pages which may show titles of documents.  When those
 *  files are created, the title strings normally have been translated and
 *  expanded to the display character set, so we have to make sure they
 *  don't get translated again.
 *  If the user has changed the display character set during the lifetime
 *  of the Lynx session (or, more exactly, during the time the title
 *  strings to be written were generated), they may now have different
 *  character encodings and there is currently no way to get it all right.
 *  To change this, we would have to add a variable for each string which
 *  keeps track of its character encoding.
 *  But at least we can try to ensure that reading the file after future
 *  display character set changes will give reasonable output.
 *
 *  The META tag is not written if the display character set (passed as
 *  disp_chndl) already corresponds to the charset assumption that
 *  would be made when the file is read. - KW
 *
 *  Currently this function is used for temporary files like "Lynx Info Page"
 *  and for one permanent - bookmarks (so it may be a problem if you change
 *  the display charset later: new bookmark entries may be mistranslated).
 *								 - LP
 */
void LYAddMETAcharsetToFD(FILE *fd, int disp_chndl)
{
    if (disp_chndl == -1)
	/*
	 * -1 means use current_char_set.
	 */
	disp_chndl = current_char_set;

    if (fd == NULL || disp_chndl < 0)
	/*
	 * Should not happen.
	 */
	return;

    if (UCLYhndl_HTFile_for_unspec == disp_chndl)
	/*
	 * Not need to do, so we don't.
	 */
	return;

    if (LYCharSet_UC[disp_chndl].enc == UCT_ENC_7BIT)
	/*
	 * There shouldn't be any 8-bit characters in this case.
	 */
	return;

    /*
     * In other cases we don't know because UCLYhndl_for_unspec may change
     * during the lifetime of the file (by toggling raw mode or changing the
     * display character set), so proceed.
     */
    fprintf(fd, "<META %s content=\"text/html;charset=%s\">\n",
	    "http-equiv=\"content-type\"",
	    LYCharSet_UC[disp_chndl].MIMEname);
}

/*
 * This function returns OL TYPE="A" strings in
 * the range of " A." (1) to "ZZZ." (18278). - FM
 */
char *LYUppercaseA_OL_String(int seqnum)
{
    static char OLstring[8];

    if (seqnum <= 1) {
	strcpy(OLstring, " A.");
	return OLstring;
    }
    if (seqnum < 27) {
	sprintf(OLstring, " %c.", (seqnum + 64));
	return OLstring;
    }
    if (seqnum < 703) {
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
	return OLstring;
    }
    if (seqnum < 18279) {
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 64),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
	return OLstring;
    }
    strcpy(OLstring, "ZZZ.");
    return OLstring;
}

/*
 * This function returns OL TYPE="a" strings in
 * the range of " a." (1) to "zzz." (18278). - FM
 */
char *LYLowercaseA_OL_String(int seqnum)
{
    static char OLstring[8];

    if (seqnum <= 1) {
	strcpy(OLstring, " a.");
	return OLstring;
    }
    if (seqnum < 27) {
	sprintf(OLstring, " %c.", (seqnum + 96));
	return OLstring;
    }
    if (seqnum < 703) {
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
	return OLstring;
    }
    if (seqnum < 18279) {
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 96),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
	return OLstring;
    }
    strcpy(OLstring, "zzz.");
    return OLstring;
}

/*
 * This function returns OL TYPE="I" strings in the
 * range of " I." (1) to "MMM." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYUppercaseI_OL_String(int seqnum)
{
    static char OLstring[20];
    int Arabic = seqnum;

    if (Arabic >= 3000) {
	strcpy(OLstring, "MMM.");
	return OLstring;
    }

    switch (Arabic) {
    case 1:
	strcpy(OLstring, " I.");
	return OLstring;
    case 5:
	strcpy(OLstring, " V.");
	return OLstring;
    case 10:
	strcpy(OLstring, " X.");
	return OLstring;
    case 50:
	strcpy(OLstring, " L.");
	return OLstring;
    case 100:
	strcpy(OLstring, " C.");
	return OLstring;
    case 500:
	strcpy(OLstring, " D.");
	return OLstring;
    case 1000:
	strcpy(OLstring, " M.");
	return OLstring;
    default:
	OLstring[0] = '\0';
	break;
    }

    while (Arabic >= 1000) {
	strcat(OLstring, "M");
	Arabic -= 1000;
    }

    if (Arabic >= 900) {
	strcat(OLstring, "CM");
	Arabic -= 900;
    }

    if (Arabic >= 500) {
	strcat(OLstring, "D");
	Arabic -= 500;
	while (Arabic >= 500) {
	    strcat(OLstring, "C");
	    Arabic -= 10;
	}
    }

    if (Arabic >= 400) {
	strcat(OLstring, "CD");
	Arabic -= 400;
    }

    while (Arabic >= 100) {
	strcat(OLstring, "C");
	Arabic -= 100;
    }

    if (Arabic >= 90) {
	strcat(OLstring, "XC");
	Arabic -= 90;
    }

    if (Arabic >= 50) {
	strcat(OLstring, "L");
	Arabic -= 50;
	while (Arabic >= 50) {
	    strcat(OLstring, "X");
	    Arabic -= 10;
	}
    }

    if (Arabic >= 40) {
	strcat(OLstring, "XL");
	Arabic -= 40;
    }

    while (Arabic > 10) {
	strcat(OLstring, "X");
	Arabic -= 10;
    }

    switch (Arabic) {
    case 1:
	strcat(OLstring, "I.");
	break;
    case 2:
	strcat(OLstring, "II.");
	break;
    case 3:
	strcat(OLstring, "III.");
	break;
    case 4:
	strcat(OLstring, "IV.");
	break;
    case 5:
	strcat(OLstring, "V.");
	break;
    case 6:
	strcat(OLstring, "VI.");
	break;
    case 7:
	strcat(OLstring, "VII.");
	break;
    case 8:
	strcat(OLstring, "VIII.");
	break;
    case 9:
	strcat(OLstring, "IX.");
	break;
    case 10:
	strcat(OLstring, "X.");
	break;
    default:
	strcat(OLstring, ".");
	break;
    }

    return OLstring;
}

/*
 * This function returns OL TYPE="i" strings in
 * range of " i." (1) to "mmm." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYLowercaseI_OL_String(int seqnum)
{
    static char OLstring[20];
    int Arabic = seqnum;

    if (Arabic >= 3000) {
	strcpy(OLstring, "mmm.");
	return OLstring;
    }

    switch (Arabic) {
    case 1:
	strcpy(OLstring, " i.");
	return OLstring;
    case 5:
	strcpy(OLstring, " v.");
	return OLstring;
    case 10:
	strcpy(OLstring, " x.");
	return OLstring;
    case 50:
	strcpy(OLstring, " l.");
	return OLstring;
    case 100:
	strcpy(OLstring, " c.");
	return OLstring;
    case 500:
	strcpy(OLstring, " d.");
	return OLstring;
    case 1000:
	strcpy(OLstring, " m.");
	return OLstring;
    default:
	OLstring[0] = '\0';
	break;
    }

    while (Arabic >= 1000) {
	strcat(OLstring, "m");
	Arabic -= 1000;
    }

    if (Arabic >= 900) {
	strcat(OLstring, "cm");
	Arabic -= 900;
    }

    if (Arabic >= 500) {
	strcat(OLstring, "d");
	Arabic -= 500;
	while (Arabic >= 500) {
	    strcat(OLstring, "c");
	    Arabic -= 10;
	}
    }

    if (Arabic >= 400) {
	strcat(OLstring, "cd");
	Arabic -= 400;
    }

    while (Arabic >= 100) {
	strcat(OLstring, "c");
	Arabic -= 100;
    }

    if (Arabic >= 90) {
	strcat(OLstring, "xc");
	Arabic -= 90;
    }

    if (Arabic >= 50) {
	strcat(OLstring, "l");
	Arabic -= 50;
	while (Arabic >= 50) {
	    strcat(OLstring, "x");
	    Arabic -= 10;
	}
    }

    if (Arabic >= 40) {
	strcat(OLstring, "xl");
	Arabic -= 40;
    }

    while (Arabic > 10) {
	strcat(OLstring, "x");
	Arabic -= 10;
    }

    switch (Arabic) {
    case 1:
	strcat(OLstring, "i.");
	break;
    case 2:
	strcat(OLstring, "ii.");
	break;
    case 3:
	strcat(OLstring, "iii.");
	break;
    case 4:
	strcat(OLstring, "iv.");
	break;
    case 5:
	strcat(OLstring, "v.");
	break;
    case 6:
	strcat(OLstring, "vi.");
	break;
    case 7:
	strcat(OLstring, "vii.");
	break;
    case 8:
	strcat(OLstring, "viii.");
	break;
    case 9:
	strcat(OLstring, "ix.");
	break;
    case 10:
	strcat(OLstring, "x.");
	break;
    default:
	strcat(OLstring, ".");
	break;
    }

    return OLstring;
}

/*
 *  This function initializes the Ordered List counter. - FM
 */
void LYZero_OL_Counter(HTStructured * me)
{
    int i;

    if (!me)
	return;

    for (i = 0; i < 12; i++) {
	me->OL_Counter[i] = OL_VOID;
	me->OL_Type[i] = '1';
    }

    me->Last_OL_Count = 0;
    me->Last_OL_Type = '1';

    return;
}

/*
 *  This function is used by the HTML Structured object. - KW
 */
void LYGetChartransInfo(HTStructured * me)
{
    me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					UCT_STAGE_STRUCTURED);
    if (me->UCLYhndl < 0) {
	int chndl = HTAnchor_getUCLYhndl(me->node_anchor, UCT_STAGE_HTEXT);

	if (chndl < 0) {
	    chndl = current_char_set;
	    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
				    UCT_STAGE_HTEXT,
				    UCT_SETBY_STRUCTURED);
	}
	HTAnchor_setUCInfoStage(me->node_anchor, chndl,
				UCT_STAGE_STRUCTURED,
				UCT_SETBY_STRUCTURED);
	me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					    UCT_STAGE_STRUCTURED);
    }
    me->UCI = HTAnchor_getUCInfoStage(me->node_anchor,
				      UCT_STAGE_STRUCTURED);
}

/*
 * Given an UCS character code, will fill buffer passed in as q with the code's
 * UTF-8 encoding.
 * If terminate = YES, terminates string on success and returns pointer
 *		       to beginning.
 * If terminate = NO,	does not terminate string, and returns pointer
 *		       next char after the UTF-8 put into buffer.
 * On failure, including invalid code or 7-bit code, returns NULL.
 */
static char *UCPutUtf8ToBuffer(char *q, UCode_t code, BOOL terminate)
{
    char *q_in = q;

    if (!q)
	return NULL;
    if (code > 127 && code < 0x7fffffffL) {
	if (code < 0x800L) {
	    *q++ = (char) (0xc0 | (code >> 6));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else if (code < 0x10000L) {
	    *q++ = (char) (0xe0 | (code >> 12));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else if (code < 0x200000L) {
	    *q++ = (char) (0xf0 | (code >> 18));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else if (code < 0x4000000L) {
	    *q++ = (char) (0xf8 | (code >> 24));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else {
	    *q++ = (char) (0xfc | (code >> 30));
	    *q++ = (char) (0x80 | (0x3f & (code >> 24)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	}
    } else {
	return NULL;
    }
    if (terminate) {
	*q = '\0';
	return q_in;
    } else {
	return q;
    }
}

	/* as in HTParse.c, saves some calls - kw */
static const char *hex = "0123456789ABCDEF";

/*
 *	  Any raw 8-bit or multibyte characters already have been
 *	  handled in relation to the display character set
 *	  in SGML_character(), including named and numeric entities.
 *
 *  This function used for translations HTML special fields inside tags
 *  (ALT=, VALUE=, etc.) from charset `cs_from' to charset `cs_to'.
 *  It also unescapes non-ASCII characters from URL (#fragments !)
 *  if st_URL is active.
 *
 *  If `do_ent' is YES, it converts named entities
 *  and numeric character references (NCRs) to their `cs_to' replacements.
 *
 *  Named entities converted to unicodes.  NCRs (unicodes) converted
 *  by UCdomap.c chartrans functions.
 *  ???NCRs with values in the ISO-8859-1 range 160-255 may be converted
 *  to their HTML entity names (via old-style entities) and then translated
 *  according to the LYCharSets.c array for `cs_out'???.
 *
 *  Some characters (see descriptions in `put_special_unicodes' from SGML.c)
 *  translated in relation with the state of boolean variables
 *  `use_lynx_specials', `plain_space' and `hidden'.  It is not clear yet:
 *
 *  If plain_space is TRUE, nbsp (160) will be treated as an ASCII
 *  space (32).  If hidden is TRUE, entities will be translated
 *  (if `do_ent' is YES) but escape sequences will be passed unaltered.
 *  If `hidden' is FALSE, some characters are converted to Lynx special
 *  codes (see `put_special_unicodes') or ASCII space if `plain_space'
 *  applies).  @@@@ is `use_lynx_specials' needed, does it have any effect? @@@@
 *  If `use_lynx_specials' is YES, translate byte values 160 and 173
 *  meaning U+00A0 and U+00AD given as or converted from raw char input
 *  are converted to HT_NON_BREAK_SPACE and LY_SOFT_HYPHEN, respectively
 *  (unless input and output charset are both iso-8859-1, for compatibility
 *  with previous usage in HTML.c) even if `hidden' or `plain_space' is set.
 *
 *  If `Back' is YES, the reverse is done instead i.e., Lynx special codes
 *  in the input are translated back to character values.
 *
 *  If `Back' is YES, an attempt is made to use UCReverseTransChar() for
 *  back translation which may be more efficient. (?)
 *
 *  If `stype' is st_URL, non-ASCII characters are URL-encoded instead.
 *  The sequence of bytes being URL-encoded is the raw input character if
 *  we couldn't translate it from `cs_in' (CJK etc.); otherwise it is the
 *  UTF-8 representation if either `cs_to' requires this or if the
 *  character's Unicode value is > 255, otherwise it should be the iso-8859-1
 *  representation.
 *  No general URL-encoding occurs for displayable ASCII characters and
 *  spaces and some C0 controls valid in HTML (LF, TAB), it is expected
 *  that other functions will take care of that as appropriate.
 *
 *  Escape characters (0x1B, '\033') are
 *  - URL-encoded	if `stype'  is st_URL,	 otherwise
 *  - dropped		if `stype'  is st_other, otherwise (i.e., st_HTML)
 *  - passed		if `hidden' is TRUE or HTCJK is set, otherwise
 *  - dropped.
 *
 *  (If `stype' is st_URL or st_other most of the parameters really predefined:
 *  cs_from=cs_to, use_lynx_specials=plain_space=NO, and hidden=YES)
 *
 *
 *  Returns pointer to the char** passed in
 *		 if string translated or translation unnecessary,
 *	    NULL otherwise
 *		 (in which case something probably went wrong.)
 *
 *
 *  In general, this somehow ugly function (KW)
 *  cover three functions from v.2.7.2 (FM):
 *		    extern void LYExpandString (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeEntities (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeToLatinOne (
 *		       HTStructured *	       me,
 *		       char **		       str,
 *		       BOOLEAN		       isURL);
 */

char **LYUCFullyTranslateString(char **str,
				int cs_from,
				int cs_to,
				BOOLEAN do_ent,
				BOOL use_lynx_specials,
				BOOLEAN plain_space,
				BOOLEAN hidden,
				BOOL Back,
				CharUtil_st stype)
{
    char *p;
    char *q, *qs;
    HTChunk *chunk = NULL;
    char *cp = 0;
    char cpe = 0;
    char *esc = NULL;
    char replace_buf[64];
    int uck;
    int lowest_8;
    UCode_t code = 0;
    long int lcode;
    BOOL output_utf8 = 0, repl_translated_C0 = 0;
    size_t len;
    const char *name = NULL;
    BOOLEAN no_bytetrans;
    UCTransParams T;
    BOOL from_is_utf8 = FALSE;
    char *puni;
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren,
	S_trans_byte,
	S_check_ent,
	S_ncr,
	S_check_uni,
	S_named,
	S_check_name,
	S_recover,
	S_got_oututf8,
	S_got_outstring,
	S_put_urlstring,
	S_got_outchar,
	S_put_urlchar,
	S_next_char,
	S_done
    } state = S_text;
    enum _parsing_what {
	P_text,
	P_utf8,
	P_hex,
	P_decimal,
	P_named
    } what = P_text;

#ifdef KANJI_CODE_OVERRIDE
    static unsigned char sjis_1st = '\0';

#ifdef CONV_JISX0201KANA_JISX0208KANA
    unsigned char sjis_str[3];
#endif
#endif

    /*
     * Make sure we have a non-empty string.  - FM
     */
    if (!str || isEmpty(*str))
	return str;

    /*
     * FIXME: something's wrong with the limit checks here (clearing the
     * buffer helps).
     */
    memset(replace_buf, 0, sizeof(replace_buf));

    /*
     * Don't do byte translation if original AND target character sets are both
     * iso-8859-1 (and we are not called to back-translate), or if we are in
     * CJK mode.
     */
    if ((HTCJK != NOCJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& (strcmp(LYCharSet_UC[cs_from].MIMEname, "utf-8") != 0)
#endif
	) {
	no_bytetrans = TRUE;
    } else if (cs_to <= 0 && cs_from == cs_to && (!Back || cs_to < 0)) {
	no_bytetrans = TRUE;
    } else {
	/* No need to translate or examine the string any further */
	no_bytetrans = (BOOL) (!use_lynx_specials && !Back &&
			       UCNeedNotTranslate(cs_from, cs_to));
    }
    /*
     * Save malloc/calloc overhead in simple case - kw
     */
    if (do_ent && hidden && (stype != st_URL) && (strchr(*str, '&') == NULL))
	do_ent = FALSE;

    /* Can't do, caller should figure out what to do... */
    if (!UCCanTranslateFromTo(cs_from, cs_to)) {
	if (cs_to < 0)
	    return NULL;
	if (!do_ent && no_bytetrans)
	    return NULL;
	no_bytetrans = TRUE;
    } else if (cs_to < 0) {
	do_ent = FALSE;
    }

    if (!do_ent && no_bytetrans)
	return str;
    p = *str;

    if (!no_bytetrans) {
	UCTransParams_clear(&T);
	UCSetTransParams(&T, cs_from, &LYCharSet_UC[cs_from],
			 cs_to, &LYCharSet_UC[cs_to]);
	from_is_utf8 = (BOOL) (LYCharSet_UC[cs_from].enc == UCT_ENC_UTF8);
	output_utf8 = T.output_utf8;
	repl_translated_C0 = T.repl_translated_C0;
	puni = p;
    } else if (do_ent) {
	output_utf8 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8 ||
			      HText_hasUTF8OutputSet(HTMainText));
	repl_translated_C0 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_8BIT_C0);
    }

    lowest_8 = LYlowest_eightbit[cs_to];

    /*
     * Create a buffer string seven times the length of the original, so we
     * have plenty of room for expansions.  - FM
     */
    len = strlen(p) + 16;
    q = p;

    qs = q;

/*  Create the HTChunk only if we need it */
#define CHUNK (chunk ? chunk : (chunk = HTChunkCreate2(128, len+1)))

#define REPLACE_STRING(s) \
		if (q != qs) HTChunkPutb(CHUNK, qs, q-qs); \
		HTChunkPuts(CHUNK, s); \
		qs = q = *str

#define REPLACE_CHAR(c) if (q > p) { \
		HTChunkPutb(CHUNK, qs, q-qs); \
		qs = q = *str; \
		*q++ = c; \
	    } else \
		*q++ = c

    /*
     * Loop through string, making conversions as needed.
     *
     * The while() checks for a non-'\0' char only for the normal text states
     * since other states may temporarily modify p or *p (which should be
     * restored before S_done!) - kw
     */
    while (*p || (state != S_text && state != S_nonascii_text)) {
	switch (state) {
	case S_text:
	    code = UCH(*p);
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE && last_kcode == SJIS) {
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code) || IS_SJIS_HI2(code))) {
		    sjis_1st = UCH(code);
		} else if (sjis_1st && IS_SJIS_LO(code)) {
		    sjis_1st = '\0';
		} else {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    if (0xA1 <= code && code <= 0xDF) {
			sjis_str[2] = '\0';
			JISx0201TO0208_SJIS(UCH(code),
					    sjis_str, sjis_str + 1);
			REPLACE_STRING(sjis_str);
			p++;
			continue;
		    }
#endif
		}
	    }
#endif
	    if (*p == '\033') {
		if ((HTCJK != NOCJK && !hidden) || stype != st_HTML) {
		    state = S_esc;
		    if (stype == st_URL) {
			REPLACE_STRING("%1B");
			p++;
			continue;
		    } else if (stype != st_HTML) {
			p++;
			continue;
		    } else {
			*q++ = *p++;
			continue;
		    }
		} else if (!hidden) {
		    /*
		     * CJK handling not on, and not a hidden INPUT, so block
		     * escape.  - FM
		     */
		    state = S_next_char;
		} else {
		    state = S_trans_byte;
		}
	    } else {
		state = (do_ent ? S_check_ent : S_trans_byte);
	    }
	    break;

	case S_esc:
	    if (*p == '$') {
		state = S_dollar;
		*q++ = *p++;
		continue;
	    } else if (*p == '(') {
		state = S_paren;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_dollar:
	    if (*p == '@@' || *p == 'B' || *p == 'A') {
		state = S_nonascii_text;
		*q++ = *p++;
		continue;
	    } else if (*p == '(') {
		state = S_dollar_paren;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_dollar_paren:
	    if (*p == 'C') {
		state = S_nonascii_text;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_paren:
	    if (*p == 'B' || *p == 'J' || *p == 'T') {
		state = S_text;
		*q++ = *p++;
		continue;
	    } else if (*p == 'I') {
		state = S_nonascii_text;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_nonascii_text:
	    if (*p == '\033') {
		if ((HTCJK != NOCJK && !hidden) || stype != st_HTML) {
		    state = S_esc;
		    if (stype == st_URL) {
			REPLACE_STRING("%1B");
			p++;
			continue;
		    } else if (stype != st_HTML) {
			p++;
			continue;
		    }
		}
	    }
	    *q++ = *p++;
	    continue;

	case S_trans_byte:
	    /* character translation goes here */
	    /*
	     * Don't do anything if we have no string, or if original AND
	     * target character sets are both iso-8859-1, or if we are in CJK
	     * mode.
	     */
	    if (*p == '\0' || no_bytetrans) {
		state = S_got_outchar;
		break;
	    }

	    if (Back) {
		int rev_c;

		if ((*p) == HT_NON_BREAK_SPACE ||
		    (*p) == HT_EN_SPACE) {
		    if (plain_space) {
			code = *p = ' ';
			state = S_got_outchar;
			break;
		    } else {
			code = 160;
			if (LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			    (LYCharSet_UC[cs_to].like8859 & UCT_R_8859SPECL)) {
			    state = S_got_outchar;
			    break;
			} else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
				     || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			    state = S_check_uni;
			    break;
			} else {
			    *(unsigned char *) p = UCH(160);
			}
		    }
		} else if ((*p) == LY_SOFT_HYPHEN) {
		    code = 173;
		    if (LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			(LYCharSet_UC[cs_to].like8859 & UCT_R_8859SPECL)) {
			state = S_got_outchar;
			break;
		    } else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
				 || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			state = S_check_uni;
			break;
		    } else {
			*(unsigned char *) p = UCH(173);
		    }
		} else if (code < 127 || T.transp) {
		    state = S_got_outchar;
		    break;
		}
		rev_c = UCReverseTransChar(*p, cs_to, cs_from);
		if (rev_c > 127) {
		    *p = (char) rev_c;
		    code = rev_c;
		    state = S_got_outchar;
		    break;
		}
	    } else if (code < 127) {
		state = S_got_outchar;
		break;
	    }

	    if (from_is_utf8) {
		if (((*p) & 0xc0) == 0xc0) {
		    puni = p;
		    code = UCGetUniFromUtf8String(&puni);
		    if (code <= 0) {
			code = UCH(*p);
		    } else {
			what = P_utf8;
		    }
		}
	    } else if (use_lynx_specials && !Back &&
		       (code == 160 || code == 173) &&
		       (LYCharSet_UC[cs_from].enc == UCT_ENC_8859 ||
			(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
		if (code == 160)
		    code = *p = HT_NON_BREAK_SPACE;
		else if (code == 173)
		    code = *p = LY_SOFT_HYPHEN;
		state = S_got_outchar;
		break;
	    } else if (T.trans_to_uni) {
		code = UCTransToUni(*p, cs_from);
		if (code <= 0) {
		    /* What else can we do? */
		    code = UCH(*p);
		}
	    } else if (!T.trans_from_uni) {
		state = S_got_outchar;
		break;
	    }
	    /*
	     * Substitute Lynx special character for 160 (nbsp) if
	     * use_lynx_specials is set.
	     */
	    if (use_lynx_specials && !Back &&
		(code == 160 || code == 173)) {
		code = ((code == 160 ? HT_NON_BREAK_SPACE : LY_SOFT_HYPHEN));
		state = S_got_outchar;
		break;
	    }

	    state = S_check_uni;
	    break;

	case S_check_ent:
	    if (*p == '&') {
		char *pp = p + 1;

		len = strlen(pp);
		/*
		 * Check for a numeric entity.  - FM
		 */
		if (*pp == '#' && len > 2 &&
		    (*(pp + 1) == 'x' || *(pp + 1) == 'X') &&
		    UCH(*(pp + 2)) < 127 &&
		    isxdigit(UCH(*(pp + 2)))) {
		    what = P_hex;
		    state = S_ncr;
		} else if (*pp == '#' && len > 2 &&
			   UCH(*(pp + 1)) < 127 &&
			   isdigit(UCH(*(pp + 1)))) {
		    what = P_decimal;
		    state = S_ncr;
		} else if (UCH(*pp) < 127 &&
			   isalpha(UCH(*pp))) {
		    what = P_named;
		    state = S_named;
		} else {
		    state = S_trans_byte;
		}
	    } else {
		state = S_trans_byte;
	    }
	    break;

	case S_ncr:
	    if (what == P_hex) {
		p += 3;
	    } else {		/* P_decimal */
		p += 2;
	    }
	    cp = p;
	    while (*p && UCH(*p) < 127 &&
		   (what == P_hex ? isxdigit(UCH(*p)) :
		    isdigit(UCH(*p)))) {
		p++;
	    }
	    /*
	     * Save the terminator and isolate the digit(s).  - FM
	     */
	    cpe = *p;
	    if (*p)
		*p++ = '\0';
	    /*
	     * Show the numeric entity if the value:
	     * (1) Is greater than 255 and unhandled Unicode.
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if ((((what == P_hex) ? sscanf(cp, "%lx", &lcode) :
		  sscanf(cp, "%ld", &lcode)) != 1) ||
		lcode > 0x7fffffffL || lcode < 0) {
		state = S_recover;
		break;
	    } else {
		code = lcode;
		if ((code == 1) ||
		    (code > 127 && code < 156)) {
		    /*
		     * Assume these are Microsoft code points, inflicted on
		     * us by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159
		     * range and doesn't follow Unicode standards for this
		     * area.  Windows-1252 codepoints are assumed here.
		     */
		    switch (code) {
		    case 1:
			/*
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
			break;
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
			break;
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
			break;
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
			break;
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
			break;
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
			break;
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
			break;
		    }
		}
		state = S_check_uni;
	    }
	    break;

	case S_check_uni:
	    /*
	     * Show the numeric entity if the value:
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if ((code < 32 &&
		 code != 9 && code != 10 && code != 13 &&
		 HTCJK == NOCJK) ||
		(code == 127 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
		(code > 127 && code < 160 &&
		 !HTPassHighCtrlNum)) {
		state = S_recover;
		break;
	    }
	    /*
	     * Convert the value as an unsigned char, hex escaped if isURL is
	     * set and it's 8-bit, and then recycle the terminator if it is not
	     * a semicolon.  - FM
	     */
	    if (code > 159 && stype == st_URL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 160 (nbsp), use that value if it's a hidden INPUT, otherwise
	     * use an ASCII space (32) if plain_space is TRUE, otherwise use
	     * the Lynx special character.  - FM
	     */
	    if (code == 160) {
		if (plain_space) {
		    code = ' ';
		    state = S_got_outchar;
		    break;
		} else if (use_lynx_specials) {
		    code = HT_NON_BREAK_SPACE;
		    state = S_got_outchar;
		    break;
		} else if ((hidden && !Back)
			   || (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1)
			   || LYCharSet_UC[cs_to].enc == UCT_ENC_8859
			   || (LYCharSet_UC[cs_to].like8859 &
			       UCT_R_8859SPECL)) {
		    state = S_got_outchar;
		    break;
		} else if (
			      (LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
		    ;		/* nothing, may be translated later */
		} else {
		    code = ' ';
		    state = S_got_outchar;
		    break;
		}
	    }
	    /*
	     * For 173 (shy), use that value if it's a hidden INPUT, otherwise
	     * ignore it if plain_space is TRUE, otherwise use the Lynx special
	     * character.  - FM
	     */
	    if (code == 173) {
		if (plain_space) {
		    replace_buf[0] = '\0';
		    state = S_got_outstring;
		    break;
		} else if (Back &&
			   !(LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			     (LYCharSet_UC[cs_to].like8859 &
			      UCT_R_8859SPECL))) {
		    ;		/* nothing, may be translated later */
		} else if (hidden || Back) {
		    state = S_got_outchar;
		    break;
		} else if (use_lynx_specials) {
		    code = LY_SOFT_HYPHEN;
		    state = S_got_outchar;
		    break;
		}
	    }
	    /*
	     * Seek a translation from the chartrans tables.
	     */
	    if ((uck = UCTransUniChar(code,
				      cs_to)) >= 32 &&
		uck < 256 &&
		(uck < 127 || uck >= lowest_8)) {
		code = uck;
		state = S_got_outchar;
		break;
	    } else if ((uck == -4 ||
			(repl_translated_C0 &&
			 uck > 0 && uck < 32)) &&
		/*
		 * Not found; look for replacement string.
		 */
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						cs_to,
						0) >= 0)) {
		state = S_got_outstring;
		break;
	    }
	    if (output_utf8 &&
		code > 127 && code < 0x7fffffffL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 8194 (ensp), 8195 (emsp), or 8201 (thinsp), use the
	     * character reference if it's a hidden INPUT, otherwise use an
	     * ASCII space (32) if plain_space is TRUE, otherwise use the Lynx
	     * special character.  - FM
	     */
	    if (code == 8194 || code == 8195 || code == 8201) {
		if (hidden) {
		    state = S_recover;
		} else if (plain_space) {
		    code = ' ';
		    state = S_got_outchar;
		} else {
		    code = HT_EN_SPACE;
		    state = S_got_outchar;
		}
		break;
		/*
		 * Ignore 8204 (zwnj), 8205 (zwj) 8206 (lrm), and 8207 (rlm),
		 * for now, if we got this far without finding a representation
		 * for them.
		 */
	    } else if (code == 8204 || code == 8205 ||
		       code == 8206 || code == 8207) {
		CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
		replace_buf[0] = '\0';
		state = S_got_outstring;
		break;
		/*
		 * Show the numeric entity if the value:  (1) Is greater than
		 * 255 and unhandled Unicode.
		 */
	    } else if (code > 255) {
		/*
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
		state = S_recover;
		break;
		/*
		 * If it's ASCII, or is 8-bit but HTPassEightBitNum is set or
		 * the character set is "ISO Latin 1", use it's value.  - FM
		 */
	    } else if (code < 161 ||
		       (code < 256 &&
			(HTPassEightBitNum || cs_to == LATIN1))) {
		/*
		 * No conversion needed.
		 */
		state = S_got_outchar;
		break;

		/* The following disabled section doesn't make sense any more. 
		 * It used to make sense in the past, when S_check_named would
		 * look in "old style" tables in addition to what it does now. 
		 * Disabling of going to S_check_name here prevents endless
		 * looping between S_check_uni and S_check_names states, which
		 * could occur here for Latin 1 codes for some cs_to if they
		 * had no translation in that cs_to.  Normally all cs_to
		 * *should* now have valid translations via UCTransUniChar or
		 * UCTransUniCharStr for all Latin 1 codes, so that we would
		 * not get here anyway, and no loop could occur.  Still, if we
		 * *do* get here, FALL THROUGH to case S_recover now.  - kw
		 */
#if 0
		/*
		 * If we get to here, convert and handle the character as a
		 * named entity.  - FM
		 */
	    } else {
		name = HTMLGetEntityName(code - 160);
		state = S_check_name;
		break;
#endif
	    }

	case S_recover:
	    if (what == P_decimal || what == P_hex) {
		/*
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
		*q++ = '&';
		*q++ = '#';
		if (what == P_hex)
		    *q++ = 'x';
		if (cpe != '\0')
		    *(p - 1) = cpe;
		p = cp;
		state = S_done;
	    } else if (what == P_named) {
		*cp = cpe;
		*q++ = '&';
		state = S_done;
	    } else if (!T.output_utf8 && stype == st_HTML && !hidden &&
		       !(HTPassEightBitRaw &&
			 UCH(*p) >= lowest_8)) {
		sprintf(replace_buf, "U%.2lX", code);
		state = S_got_outstring;
	    } else {
		puni = p;
		code = UCH(*p);
		state = S_got_outchar;
	    }
	    break;

	case S_named:
	    cp = ++p;
	    while (*cp && UCH(*cp) < 127 &&
		   isalnum(UCH(*cp)))
		cp++;
	    cpe = *cp;
	    *cp = '\0';
	    name = p;
	    state = S_check_name;
	    break;

	case S_check_name:
	    /*
	     * Seek the Unicode value for the named entity.
	     *
	     * !!!!  We manually recover the case of '=' terminator which is
	     * commonly found on query to CGI-scripts enclosed as href= URLs
	     * like "somepath/?x=1&yz=2" Without this dirty fix, submission of
	     * such URLs was broken if &yz string happened to be a recognized
	     * entity name.  - LP
	     */
	    if (((code = HTMLGetEntityUCValue(name)) > 0) &&
		!((cpe == '=') && (stype == st_URL))) {
		state = S_check_uni;
		break;
	    }
	    /*
	     * Didn't find the entity.  Return verbatim.
	     */
	    state = S_recover;
	    break;

	    /* * * O U T P U T   S T A T E S * * */

	case S_got_oututf8:
	    if (code > 255 ||
		(code >= 128 && LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8)) {
		UCPutUtf8ToBuffer(replace_buf, code, YES);
		state = S_got_outstring;
	    } else {
		state = S_got_outchar;
	    }
	    break;
	case S_got_outstring:
	    if (what == P_decimal || what == P_hex) {
		if (cpe != ';' && cpe != '\0')
		    *(--p) = cpe;
		p--;
	    } else if (what == P_named) {
		*cp = cpe;
		p = (*cp != ';') ? (cp - 1) : cp;
	    } else if (what == P_utf8) {
		p = puni;
	    }
	    if (replace_buf[0] == '\0') {
		state = S_next_char;
		break;
	    }
	    if (stype == st_URL) {
		code = replace_buf[0];	/* assume string OK if first char is */
		if (code >= 127 ||
		    (code < 32 && (code != 9 && code != 10 && code != 0))) {
		    state = S_put_urlstring;
		    break;
		}
	    }
	    REPLACE_STRING(replace_buf);
	    state = S_next_char;
	    break;
	case S_put_urlstring:
	    esc = HTEscape(replace_buf, URL_XALPHAS);
	    REPLACE_STRING(esc);
	    FREE(esc);
	    state = S_next_char;
	    break;
	case S_got_outchar:
	    if (what == P_decimal || what == P_hex) {
		if (cpe != ';' && cpe != '\0')
		    *(--p) = cpe;
		p--;
	    } else if (what == P_named) {
		*cp = cpe;
		p = (*cp != ';') ? (cp - 1) : cp;
	    } else if (what == P_utf8) {
		p = puni;
	    }
	    if (stype == st_URL &&
	    /*  Not a full HTEscape, only for 8bit and ctrl chars */
		(TOASCII(code) >= 127 ||	/* S/390 -- gil -- 1925 */
		 (code < ' ' && (code != '\t' && code != '\n')))) {
		state = S_put_urlchar;
		break;
	    } else if (!hidden && code == 10 && *p == 10
		       && q != qs && *(q - 1) == 13) {
		/*
		 * If this is not a hidden string, and the current char is the
		 * LF ('\n') of a CRLF pair, drop the CR ('\r').  - KW
		 */
		*(q - 1) = *p++;
		state = S_done;
		break;
	    }
	    *q++ = (char) code;
	    state = S_next_char;
	    break;
	case S_put_urlchar:
	    *q++ = '%';
	    REPLACE_CHAR(hex[(TOASCII(code) >> 4) & 15]);	/* S/390 -- gil -- 1944 */
	    REPLACE_CHAR(hex[(TOASCII(code) & 15)]);
	    /* fall through */
	case S_next_char:
	    p++;		/* fall through */
	case S_done:
	    state = S_text;
	    what = P_text;
	    /* for next round */
	}
    }

    *q = '\0';
    if (chunk) {
	HTChunkPutb(CHUNK, qs, q - qs + 1);	/* also terminates */
	if (stype == st_URL || stype == st_other) {
	    LYTrimHead(chunk->data);
	    LYTrimTail(chunk->data);
	}
	StrAllocCopy(*str, chunk->data);
	HTChunkFree(chunk);
    } else {
	if (stype == st_URL || stype == st_other) {
	    LYTrimHead(qs);
	    LYTrimTail(qs);
	}
    }
    return str;
}

#undef REPLACE_CHAR
#undef REPLACE_STRING

BOOL LYUCTranslateHTMLString(char **str,
			     int cs_from,
			     int cs_to,
			     BOOL use_lynx_specials,
			     BOOLEAN plain_space,
			     BOOLEAN hidden,
			     CharUtil_st stype)
{
    BOOL ret = YES;

    /* May reallocate *str even if cs_to == 0 */
    if (!LYUCFullyTranslateString(str, cs_from, cs_to, TRUE,
				  use_lynx_specials, plain_space, hidden,
				  NO, stype)) {
	ret = NO;
    }
    return ret;
}

BOOL LYUCTranslateBackFormData(char **str,
			       int cs_from,
			       int cs_to,
			       BOOLEAN plain_space)
{
    char **ret;

    /* May reallocate *str */
    ret = (LYUCFullyTranslateString(str, cs_from, cs_to, FALSE,
				    NO, plain_space, YES,
				    YES, st_HTML));
    return (BOOL) (ret != NULL);
}

/*
 * Parse a parameter from an HTML META tag, i.e., the CONTENT.
 */
char *LYParseTagParam(char *from,
		      const char *name)
{
    size_t len = strlen(name);
    char *result = NULL;
    char *string = from;

    do {
	if ((string = strchr(string, ';')) == NULL)
	    return NULL;
	while (*string != '\0' && (*string == ';' || isspace(UCH(*string)))) {
	    string++;
	}
	if (strlen(string) < len)
	    return NULL;
    } while (strncasecomp(string, name, len) != 0);
    string += len;
    while (*string != '\0' && (UCH(isspace(*string)) || *string == '=')) {
	string++;
    }

    StrAllocCopy(result, string);
    len = 0;
    while (isprint(UCH(string[len])) && !isspace(UCH(string[len]))) {
	len++;
    }
    result[len] = '\0';

    /*
     * Strip single quotes, just in case.
     */
    if (len > 2 && result[0] == '\'' && result[len - 1] == result[0]) {
	result[len - 1] = '\0';
	for (string = result; (string[0] = string[1]) != '\0'; ++string) ;
    }
    return result;
}

/*
 * Given a refresh-URL content string, parses the delay time and the URL
 * string.  Ignore the remainder of the content.
 */
void LYParseRefreshURL(char *content,
		       char **p_seconds,
		       char **p_address)
{
    char *cp;
    char *cp1 = NULL;
    char *Seconds = NULL;

    /*
     * Look for the Seconds field.  - FM
     */
    cp = LYSkipBlanks(content);
    if (*cp && isdigit(UCH(*cp))) {
	cp1 = cp;
	while (*cp1 && isdigit(UCH(*cp1)))
	    cp1++;
	StrnAllocCopy(Seconds, cp, cp1 - cp);
    }
    *p_seconds = Seconds;
    *p_address = LYParseTagParam(content, "URL");

    CTRACE((tfp,
	    "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
	    content, NonNull(*p_seconds), NonNull(*p_address)));
}

/*
 *  This function processes META tags in HTML streams. - FM
 */
void LYHandleMETA(HTStructured * me, const BOOL *present,
		  const char **value,
		  char **include GCC_UNUSED)
{
    char *http_equiv = NULL, *name = NULL, *content = NULL;
    char *href = NULL, *id_string = NULL, *temp = NULL;
    char *cp, *cp0, *cp1 = NULL;
    int url_type = 0;

    if (!me || !present)
	return;

    /*
     * Load the attributes for possible use by Lynx.  - FM
     */
    if (present[HTML_META_HTTP_EQUIV] &&
	non_empty(value[HTML_META_HTTP_EQUIV])) {
	StrAllocCopy(http_equiv, value[HTML_META_HTTP_EQUIV]);
	convert_to_spaces(http_equiv, TRUE);
	LYUCTranslateHTMLString(&http_equiv, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (*http_equiv == '\0') {
	    FREE(http_equiv);
	}
    }
    if (present[HTML_META_NAME] &&
	non_empty(value[HTML_META_NAME])) {
	StrAllocCopy(name, value[HTML_META_NAME]);
	convert_to_spaces(name, TRUE);
	LYUCTranslateHTMLString(&name, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (*name == '\0') {
	    FREE(name);
	}
    }
    if (present[HTML_META_CONTENT] &&
	non_empty(value[HTML_META_CONTENT])) {
	/*
	 * Technically, we should be creating a comma-separated list, but META
	 * tags come one at a time, and we'll handle (or ignore) them as each
	 * is received.  Also, at this point, we only trim leading and trailing
	 * blanks from the CONTENT value, without translating any named
	 * entities or numeric character references, because how we should do
	 * that depends on what type of information it contains, and whether or
	 * not any of it might be sent to the screen.  - FM
	 */
	StrAllocCopy(content, value[HTML_META_CONTENT]);
	convert_to_spaces(content, FALSE);
	LYTrimHead(content);
	LYTrimTail(content);
	if (*content == '\0') {
	    FREE(content);
	}
    }
    CTRACE((tfp,
	    "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
	    (http_equiv ? http_equiv : "NULL"),
	    (name ? name : "NULL"),
	    (content ? content : "NULL")));

    /*
     * Make sure we have META name/value pairs to handle.  - FM
     */
    if (!(http_equiv || name) || !content)
	goto free_META_copies;

    /*
     * Check for a no-cache Pragma
     * or Cache-Control directive. - FM
     */
    if (!strcasecomp(NonNull(http_equiv), "Pragma") ||
	!strcasecomp(NonNull(http_equiv), "Cache-Control")) {
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (!strcasecomp(content, "no-cache")) {
	    me->node_anchor->no_cache = TRUE;
	    HText_setNoCache(me->text);
	}

	/*
	 * If we didn't get a Cache-Control MIME header, and the META has one,
	 * convert to lowercase, store it in the anchor element, and if we
	 * haven't yet set no_cache, check whether we should.  - FM
	 */
	if ((!me->node_anchor->cache_control) &&
	    !strcasecomp(NonNull(http_equiv), "Cache-Control")) {
	    LYLowerCase(content);
	    StrAllocCopy(me->node_anchor->cache_control, content);
	    if (me->node_anchor->no_cache == FALSE) {
		cp0 = content;
		while ((cp = strstr(cp0, "no-cache")) != NULL) {
		    cp += 8;
		    while (*cp != '\0' && WHITE(*cp))
			cp++;
		    if (*cp == '\0' || *cp == ';') {
			me->node_anchor->no_cache = TRUE;
			HText_setNoCache(me->text);
			break;
		    }
		    cp0 = cp;
		}
		if (me->node_anchor->no_cache == TRUE)
		    goto free_META_copies;
		cp0 = content;
		while ((cp = strstr(cp0, "max-age")) != NULL) {
		    cp += 7;
		    while (*cp != '\0' && WHITE(*cp))
			cp++;
		    if (*cp == '=') {
			cp++;
			while (*cp != '\0' && WHITE(*cp))
			    cp++;
			if (isdigit(UCH(*cp))) {
			    cp0 = cp;
			    while (isdigit(UCH(*cp)))
				cp++;
			    if (*cp0 == '0' && cp == (cp0 + 1)) {
				me->node_anchor->no_cache = TRUE;
				HText_setNoCache(me->text);
				break;
			    }
			}
		    }
		    cp0 = cp;
		}
	    }
	}

	/*
	 * Check for an Expires directive. - FM
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Expires")) {
	/*
	 * If we didn't get an Expires MIME header, store it in the anchor
	 * element, and if we haven't yet set no_cache, check whether we
	 * should.  Note that we don't accept a Date header via META tags,
	 * because it's likely to be untrustworthy, but do check for a Date
	 * header from a server when making the comparison.  - FM
	 */
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	StrAllocCopy(me->node_anchor->expires, content);
	if (me->node_anchor->no_cache == FALSE) {
	    if (!strcmp(content, "0")) {
		/*
		 * The value is zero, which we treat as an absolute no-cache
		 * directive.  - FM
		 */
		me->node_anchor->no_cache = TRUE;
		HText_setNoCache(me->text);
	    } else if (me->node_anchor->date != NULL) {
		/*
		 * We have a Date header, so check if the value is less than or
		 * equal to that.  - FM
		 */
		if (LYmktime(content, TRUE) <=
		    LYmktime(me->node_anchor->date, TRUE)) {
		    me->node_anchor->no_cache = TRUE;
		    HText_setNoCache(me->text);
		}
	    } else if (LYmktime(content, FALSE) == 0) {
		/*
		 * We don't have a Date header, and the value is in past for
		 * us.  - FM
		 */
		me->node_anchor->no_cache = TRUE;
		HText_setNoCache(me->text);
	    }
	}

	/*
	 * Check for a text/html Content-Type with a charset directive, if we
	 * didn't already set the charset via a server's header.  - AAC & FM
	 */
    } else if (isEmpty(me->node_anchor->charset) &&
	       !strcasecomp(NonNull(http_equiv), "Content-Type")) {
	LYUCcharset *p_in = NULL;
	LYUCcharset *p_out = NULL;

	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	LYLowerCase(content);

	if ((cp1 = strstr(content, "charset")) != NULL) {
	    BOOL chartrans_ok = NO;
	    char *cp3 = NULL, *cp4;
	    int chndl;

	    cp1 += 7;
	    while (*cp1 == ' ' || *cp1 == '=' || *cp1 == '"')
		cp1++;

	    StrAllocCopy(cp3, cp1);	/* copy to mutilate more */
	    for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
			     *cp4 != ';' && *cp4 != ':' &&
			     !WHITE(*cp4)); cp4++) {
		;		/* do nothing */
	    }
	    *cp4 = '\0';
	    cp4 = cp3;
	    chndl = UCGetLYhndl_byMIME(cp3);

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (Switch_Display_Charset(chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
		/* UCT_STAGE_STRUCTURED and UCT_STAGE_HTEXT
		   should have the same setting for UCInfoStage. */
		int structured = HTAnchor_getUCInfoStage(me->node_anchor,
							 UCT_STAGE_STRUCTURED);

		me->outUCLYhndl = current_char_set;
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_HTEXT,
					UCT_SETBY_MIME);	/* highest priorty! */
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_STRUCTURED,
					UCT_SETBY_MIME);	/* highest priorty! */
		me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor,
						     UCT_STAGE_HTEXT);
		/* The SGML stage will be reset in change_chartrans_handling */
	    }
#endif

	    if (UCCanTranslateFromTo(chndl, current_char_set)) {
		chartrans_ok = YES;
		StrAllocCopy(me->node_anchor->charset, cp4);
		HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					UCT_STAGE_PARSER,
					UCT_SETBY_STRUCTURED);
	    } else if (chndl < 0) {
		/*
		 * Got something but we don't recognize it.
		 */
		chndl = UCLYhndl_for_unrec;
		if (chndl < 0)	/* UCLYhndl_for_unrec not defined :-( */
		    chndl = UCLYhndl_for_unspec;	/* always >= 0 */
		if (UCCanTranslateFromTo(chndl, current_char_set)) {
		    chartrans_ok = YES;
		    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					    UCT_STAGE_PARSER,
					    UCT_SETBY_STRUCTURED);
		}
	    }
	    if (chartrans_ok) {
		p_in = HTAnchor_getUCInfoStage(me->node_anchor,
					       UCT_STAGE_PARSER);
		p_out = HTAnchor_setUCInfoStage(me->node_anchor,
						current_char_set,
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		if (!p_out) {
		    /*
		     * Try again.
		     */
		    p_out = HTAnchor_getUCInfoStage(me->node_anchor,
						    UCT_STAGE_HTEXT);
		}
		if (!strcmp(p_in->MIMEname, "x-transparent")) {
		    HTPassEightBitRaw = TRUE;
		    HTAnchor_setUCInfoStage(me->node_anchor,
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_HTEXT),
					    UCT_STAGE_PARSER,
					    UCT_SETBY_DEFAULT);
		}
		if (!strcmp(p_out->MIMEname, "x-transparent")) {
		    HTPassEightBitRaw = TRUE;
		    HTAnchor_setUCInfoStage(me->node_anchor,
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_PARSER),
					    UCT_STAGE_HTEXT,
					    UCT_SETBY_DEFAULT);
		}
		if ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
		    && (p_in->enc != UCT_ENC_UTF8)
#endif
		    ) {
		    HTCJK = NOCJK;
		    if (!(p_in->codepoints &
			  UCT_CP_SUBSETOF_LAT1) &&
			chndl == current_char_set) {
			HTPassEightBitRaw = TRUE;
		    }
		} else if (p_out->enc == UCT_ENC_CJK) {
		    Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
		}
		LYGetChartransInfo(me);
		/*
		 * Update the chartrans info homologously to a Content-Type
		 * MIME header with a charset parameter.  - FM
		 */
		if (me->UCLYhndl != chndl) {
		    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_STRUCTURED);
		    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					    UCT_STAGE_PARSER,
					    UCT_SETBY_STRUCTURED);
		    me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
							  UCT_STAGE_PARSER);
		    me->inUCI = HTAnchor_getUCInfoStage(me->node_anchor,
							UCT_STAGE_PARSER);
		}
		UCSetTransParams(&me->T,
				 me->inUCLYhndl, me->inUCI,
				 me->outUCLYhndl, me->outUCI);
	    } else {
		/*
		 * Cannot translate.  If according to some heuristic the given
		 * charset and the current display character both are likely to
		 * be like ISO-8859 in structure, pretend we have some kind of
		 * match.
		 */
		BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
					     isdigit(UCH(cp4[9])));
		BOOL given_is_8859like = (BOOL) (given_is_8859
						 || !strncmp(cp4, "windows-", 8)
						 || !strncmp(cp4, "cp12", 4)
						 || !strncmp(cp4, "cp-12", 5));
		BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
							  (strstr(LYchar_set_names[current_char_set],
								  "ISO-8859") ||
							   strstr(LYchar_set_names[current_char_set],
								  "windows-")));

		if (given_is_8859) {
		    cp1 = &cp4[10];
		    while (*cp1 &&
			   isdigit(UCH((*cp1))))
			cp1++;
		    *cp1 = '\0';
		}
		if (given_and_display_8859like) {
		    StrAllocCopy(me->node_anchor->charset, cp4);
		    HTPassEightBitRaw = TRUE;
		}
		HTAlert(*cp4 ? cp4 : me->node_anchor->charset);

	    }
	    FREE(cp3);

	    if (me->node_anchor->charset) {
		CTRACE((tfp,
			"LYHandleMETA: New charset: %s\n",
			me->node_anchor->charset));
	    }
	}
	/*
	 * Set the kcode element based on the charset.  - FM
	 */
	HText_setKcode(me->text, me->node_anchor->charset, p_in);

	/*
	 * Check for a Refresh directive.  - FM
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Refresh")) {
	char *Seconds = NULL;

	LYParseRefreshURL(content, &Seconds, &href);

	if (Seconds) {
	    if (href) {
		/*
		 * We found a URL field, so check it out.  - FM
		 */
		if (!(url_type = LYLegitimizeHREF(me, &href, TRUE, FALSE))) {
		    /*
		     * The specs require a complete URL, but this is a
		     * Netscapism, so don't expect the author to know that.  -
		     * FM
		     */
		    HTUserMsg(REFRESH_URL_NOT_ABSOLUTE);
		    /*
		     * Use the document's address as the base.  - FM
		     */
		    if (*href != '\0') {
			temp = HTParse(href,
				       me->node_anchor->address, PARSE_ALL);
			StrAllocCopy(href, temp);
			FREE(temp);
		    } else {
			StrAllocCopy(href, me->node_anchor->address);
			HText_setNoCache(me->text);
		    }

		} else {
		    /*
		     * Check whether to fill in localhost.  - FM
		     */
		    LYFillLocalFileURL(&href,
				       (me->inBASE ?
					me->base_href : me->node_anchor->address));
		}

		/*
		 * Set the no_cache flag if the Refresh URL is the same as the
		 * document's address.  - FM
		 */
		if (!strcmp(href, me->node_anchor->address)) {
		    HText_setNoCache(me->text);
		}
	    } else {
		/*
		 * We didn't find a URL field, so use the document's own
		 * address and set the no_cache flag.  - FM
		 */
		StrAllocCopy(href, me->node_anchor->address);
		HText_setNoCache(me->text);
	    }
	    /*
	     * Check for an anchor in http or https URLs.  - FM
	     */
	    cp = NULL;
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /* id_string seems to be used wrong below if given.
	       not that it matters much.  avoid setting it here. - kw */
	    if ((strncmp(href, "http", 4) == 0) &&
		(cp = strchr(href, '#')) != NULL) {
		StrAllocCopy(id_string, cp);
		*cp = '\0';
	    }
#endif
	    if (me->inA) {
		/*
		 * Ugh!  The META tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
		 */
		if (me->inBoldA == TRUE && me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->inA = FALSE;
		me->CurrentANum = 0;
	    }
	    me->CurrentA = HTAnchor_findChildAndLink
		(
		    me->node_anchor,	/* Parent */
		    id_string,	/* Tag */
		    href,	/* Addresss */
		    (HTLinkType *) 0);	/* Type */
	    if (id_string)
		*cp = '#';
	    FREE(id_string);
	    LYEnsureSingleSpace(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "REFRESH(");
	    HTML_put_string(me, Seconds);
	    HTML_put_string(me, " sec):");
	    FREE(Seconds);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');
	    me->in_word = NO;
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, href);
	    FREE(href);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	    LYEnsureSingleSpace(me);
	}

	/*
	 * Check for a suggested filename via a Content-Disposition with a
	 * filename=name.suffix in it, if we don't already have it via a server
	 * header.  - FM
	 */
    } else if (isEmpty(me->node_anchor->SugFname) &&
	       !strcasecomp((http_equiv ?
			     http_equiv : ""), "Content-Disposition")) {
	cp = content;
	while (*cp != '\0' && strncasecomp(cp, "filename", 8))
	    cp++;
	if (*cp != '\0') {
	    cp += 8;
	    while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
		cp++;
	    while (*cp != '\0' && WHITE(*cp))
		cp++;
	    if (*cp != '\0') {
		StrAllocCopy(me->node_anchor->SugFname, cp);
		if (*me->node_anchor->SugFname == '"') {
		    if ((cp = strchr((me->node_anchor->SugFname + 1),
				     '"')) != NULL) {
			*(cp + 1) = '\0';
			HTMIME_TrimDoubleQuotes(me->node_anchor->SugFname);
		    } else {
			FREE(me->node_anchor->SugFname);
		    }
		    if (me->node_anchor->SugFname != NULL &&
			*me->node_anchor->SugFname == '\0') {
			FREE(me->node_anchor->SugFname);
		    }
		}
		if ((cp = me->node_anchor->SugFname) != NULL) {
		    while (*cp != '\0' && !WHITE(*cp))
			cp++;
		    *cp = '\0';
		    if (*me->node_anchor->SugFname == '\0')
			FREE(me->node_anchor->SugFname);
		}
	    }
	}
	/*
	 * Check for a Set-Cookie directive.  - AK
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Set-Cookie")) {
	/*
	 * This will need to be updated when Set-Cookie/Set-Cookie2 handling is
	 * finalized.  For now, we'll still assume "historical" cookies in META
	 * directives.  - FM
	 */
	url_type = is_url(me->inBASE ?
			  me->base_href : me->node_anchor->address);
	if (url_type == HTTP_URL_TYPE || url_type == HTTPS_URL_TYPE) {
	    LYSetCookie(content,
			NULL,
			(me->inBASE ?
			 me->base_href : me->node_anchor->address));
	}
    }

    /*
     * Free the copies.  - FM
     */
  free_META_copies:
    FREE(http_equiv);
    FREE(name);
    FREE(content);
}

/*
 *  This function handles P elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if
 *  FALSE, an end tag.	We presently handle start
 *  and end tags identically, but this can lead to
 *  a different number of blank lines between the
 *  current paragraph and subsequent text when a P
 *  end tag is present or not in the markup. - FM
 */
void LYHandlePlike(HTStructured * me, const BOOL *present,
		   const char **value,
		   char **include GCC_UNUSED,
		   int align_idx,
		   BOOL start)
{
    if (TRUE) {
	/*
	 * FIG content should be a true block, which like P inherits the
	 * current style.  APPLET is like character elements or an ALT
	 * attribute, unless it content contains a block element.  If we
	 * encounter a P in either's content, we set flags to treat the content
	 * as a block.  - FM
	 */
	if (start) {
	    if (me->inFIG)
		me->inFIGwithP = TRUE;

	    if (me->inAPPLET)
		me->inAPPLETwithP = TRUE;
	}

	UPDATE_STYLE;
	if (me->List_Nesting_Level >= 0) {
	    /*
	     * We're in a list.  Treat P as an instruction to create one blank
	     * line, if not already present, then fall through to handle
	     * attributes, with the "second line" margins.  - FM
	     */
	    if (me->inP) {
		if (me->inFIG || me->inAPPLET ||
		    me->inCAPTION || me->inCREDIT ||
		    me->sp->style->spaceAfter > 0 ||
		    (start && me->sp->style->spaceBefore > 0)) {
		    LYEnsureDoubleSpace(me);
		} else {
		    LYEnsureSingleSpace(me);
		}
	    }
	} else if (me->sp[0].tag_number == HTML_ADDRESS) {
	    /*
	     * We're in an ADDRESS.  Treat P as an instruction to start a
	     * newline, if needed, then fall through to handle attributes.  -
	     * FM
	     */
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_appendCharacter(me->text, '\r');
	    }
	} else {
	    if (start) {
		if (!(me->inLABEL && !me->inP)) {
		    HText_appendParagraph(me->text);
		}
	    } else if (me->sp->style->spaceAfter > 0) {
		LYEnsureDoubleSpace(me);
	    } else {
		LYEnsureSingleSpace(me);
	    }
	    me->inLABEL = FALSE;
	}
	me->in_word = NO;

	if (LYoverride_default_alignment(me)) {
	    me->sp->style->alignment = LYstyles(me->sp[0].tag_number)->alignment;
	} else if ((me->List_Nesting_Level >= 0 &&
		    (me->sp->style->id == ST_DivCenter ||
		     me->sp->style->id == ST_DivLeft ||
		     me->sp->style->id == ST_DivRight)) ||
		   ((me->Division_Level < 0) &&
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
	    me->sp->style->alignment = HT_LEFT;
	} else {
	    me->sp->style->alignment = (short) me->current_default_alignment;
	}

	if (start) {
	    if (present && present[align_idx] && value[align_idx]) {
		if (!strcasecomp(value[align_idx], "center") &&
		    !(me->List_Nesting_Level >= 0 && !me->inP))
		    me->sp->style->alignment = HT_CENTER;
		else if (!strcasecomp(value[align_idx], "right") &&
			 !(me->List_Nesting_Level >= 0 && !me->inP))
		    me->sp->style->alignment = HT_RIGHT;
		else if (!strcasecomp(value[align_idx], "left") ||
			 !strcasecomp(value[align_idx], "justify"))
		    me->sp->style->alignment = HT_LEFT;
	    }

	}

	/*
	 * Mark that we are starting a new paragraph and don't have any of it's
	 * text yet.  - FM
	 */
	me->inP = FALSE;
    }

    return;
}

/*
 *  This function handles SELECT elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if FALSE,
 *  an end tag. - FM
 */
void LYHandleSELECT(HTStructured * me, const BOOL *present,
		    const char **value,
		    char **include GCC_UNUSED,
		    BOOL start)
{
    int i;

    if (start == TRUE) {
	char *name = NULL;
	BOOLEAN multiple = NO;
	char *size = NULL;

	/*
	 * Initialize the disable attribute.
	 */
	me->select_disabled = FALSE;

	/*
	 * Make sure we're in a form.
	 */
	if (!me->inFORM) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag not within FORM tag\n"));

	    /*
	     * We should have covered all crash possibilities with the current
	     * TagSoup parser, so we'll allow it because some people with other
	     * browsers use SELECT for "information" popups, outside of FORM
	     * blocks, though no Lynx user would do anything that awful, right? 
	     * - FM
	     */
	       /***
	    return;
		***/
	}

	/*
	 * Check for unclosed TEXTAREA.
	 */
	if (me->inTEXTAREA) {
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
	}

	/*
	 * Set to know we are in a select tag.
	 */
	me->inSELECT = TRUE;

	if (!(present && present[HTML_SELECT_NAME] &&
	      non_empty(value[HTML_SELECT_NAME]))) {
	    StrAllocCopy(name, "");
	} else if (strchr(value[HTML_SELECT_NAME], '&') == NULL) {
	    StrAllocCopy(name, value[HTML_SELECT_NAME]);
	} else {
	    StrAllocCopy(name, value[HTML_SELECT_NAME]);
	    UNESCAPE_FIELDNAME_TO_STD(&name);
	}
	if (present && present[HTML_SELECT_MULTIPLE])
	    multiple = YES;
	if (present && present[HTML_SELECT_DISABLED])
	    me->select_disabled = TRUE;
	if (present && present[HTML_SELECT_SIZE] &&
	    non_empty(value[HTML_SELECT_SIZE])) {
	    /*
	     * Let the size be determined by the number of OPTIONs.  - FM
	     */
	    CTRACE((tfp, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
		    value[HTML_SELECT_SIZE]));
	}

	if (me->inBoldH == TRUE &&
	    (multiple == NO || LYSelectPopups == FALSE)) {
	    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    me->inBoldH = FALSE;
	    me->needBoldH = TRUE;
	}
	if (me->inUnderline == TRUE &&
	    (multiple == NO || LYSelectPopups == FALSE)) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	}

	if ((multiple == NO && LYSelectPopups == TRUE) &&
	    (me->sp[0].tag_number == HTML_PRE || me->inPRE == TRUE ||
	     !me->sp->style->freeFormat) &&
	    HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 7)) {
	    /*
	     * Force a newline when we're using a popup in a PRE block and are
	     * within 7 columns from the right margin.  This will allow for the
	     * '[' popup designator and help avoid a wrap in the underscore
	     * placeholder for the retracted popup entry in the HText
	     * structure.  - FM
	     */
	    HTML_put_character(me, '\n');
	    me->in_word = NO;
	}

	LYCheckForID(me, present, value, (int) HTML_SELECT_ID);

	HText_beginSelect(name, ATTR_CS_IN, multiple, size);
	FREE(name);
	FREE(size);

	me->first_option = TRUE;
    } else {
	/*
	 * Handle end tag.
	 */
	char *ptr;

	/*
	 * Make sure we had a select start tag.
	 */
	if (!me->inSELECT) {
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag\n"));
	    return;
	}

	/*
	 * Set to know that we are no longer in a select tag.
	 */
	me->inSELECT = FALSE;

	/*
	 * Clear the disable attribute.
	 */
	me->select_disabled = FALSE;

	/*
	 * Finish the data off.
	 */
	HTChunkTerminate(&me->option);
	/*
	 * Finish the previous option.
	 */
	ptr = HText_setLastOptionValue(me->text,
				       me->option.data,
				       me->LastOptionValue,
				       LAST_ORDER,
				       me->LastOptionChecked,
				       me->UCLYhndl,
				       ATTR_CS_IN);
	FREE(me->LastOptionValue);

	me->LastOptionChecked = FALSE;

	if (HTCurSelectGroupType == F_CHECKBOX_TYPE ||
	    LYSelectPopups == FALSE) {
	    /*
	     * Start a newline after the last checkbox/button option.
	     */
	    LYEnsureSingleSpace(me);
	} else {
	    /*
	     * Output popup box with the default option to screen, but use
	     * non-breaking spaces for output.
	     */
	    if (ptr &&
		me->sp[0].tag_number == HTML_PRE && strlen(ptr) > 6) {
		/*
		 * The code inadequately handles OPTION fields in PRE tags. 
		 * We'll put up a minimum of 6 characters, and if any more
		 * would exceed the wrap column, we'll ignore them.
		 */
		for (i = 0; i < 6; i++) {
		    if (*ptr == ' ')
			HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
		    else
			HText_appendCharacter(me->text, *ptr);
		    ptr++;
		}
		HText_setIgnoreExcess(me->text, TRUE);
	    }
	    for (; non_empty(ptr); ptr++) {
		if (*ptr == ' ')
		    HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
		else
		    HText_appendCharacter(me->text, *ptr);
	    }
	    /*
	     * Add end option character.
	     */
	    if (!me->first_option) {
		HText_appendCharacter(me->text, ']');
		HText_setLastChar(me->text, ']');
		me->in_word = YES;
	    }
	    HText_setIgnoreExcess(me->text, FALSE);
	}
	HTChunkClear(&me->option);

	if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	}
	if (me->needBoldH == TRUE && me->inBoldH == FALSE) {
	    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    me->inBoldH = TRUE;
	    me->needBoldH = FALSE;
	}
    }
}

/*
 *  This function strips white characters and
 *  generally fixes up attribute values that
 *  were received from the SGML parser and
 *  are to be treated as partial or absolute
 *  URLs. - FM
 */
int LYLegitimizeHREF(HTStructured * me, char **href,
		     BOOL force_slash,
		     BOOL strip_dots)
{
    int url_type = 0;
    char *p = NULL;
    char *pound = NULL;
    const char *Base = NULL;

    if (!me || !href || isEmpty(*href))
	return (url_type);

    if (!LYTrimStartfile(*href)) {
	/*
	 * Collapse spaces in the actual URL, but just protect against tabs or
	 * newlines in the fragment, if present.  This seeks to cope with
	 * atrocities inflicted on the Web by authoring tools such as
	 * Frontpage.  - FM
	 */

	/*  Before working on spaces check if we have any, usually none. */
	for (p = *href; (*p && !isspace(*p)); p++) ;

	if (*p) {		/* p == first space character */
	    /* no reallocs below, all converted in place */

	    pound = findPoundSelector(*href);

	    if (pound != NULL && pound < p) {
		convert_to_spaces(p, FALSE);	/* done */

	    } else {
		if (pound != NULL)
		    *pound = '\0';	/* mark */

		/*
		 * No blanks really belong in the HREF,
		 * but if it refers to an actual file,
		 * it may actually have blanks in the name.
		 * Try to accommodate. See also HTParse().
		 */
		if (LYRemoveNewlines(p) || strchr(p, '\t') != 0) {
		    LYRemoveBlanks(p);	/* a compromise... */
		}

		if (pound != NULL) {
		    p = strchr(p, '\0');
		    *pound = '#';	/* restore */
		    convert_to_spaces(pound, FALSE);
		    if (p < pound)
			strcpy(p, pound);
		}
	    }
	}
    }
    if (**href == '\0')
	return (url_type);

    TRANSLATE_AND_UNESCAPE_TO_STD(href);

    Base = me->inBASE ?
	me->base_href : me->node_anchor->address;

    url_type = is_url(*href);
    if (!url_type && force_slash && **href == '.' &&
	(!strcmp(*href, ".") || !strcmp(*href, "..")) &&
	!isFILE_URL(Base)) {
	/*
	 * The Fielding RFC/ID for resolving partial HREFs says that a slash
	 * should be on the end of the preceding symbolic element for "." and
	 * "..", but all tested browsers only do that for an explicit "./" or
	 * "../", so we'll respect the RFC/ID only if force_slash was TRUE and
	 * it's not a file URL.  - FM
	 */
	StrAllocCat(*href, "/");
    }
    if ((!url_type && LYStripDotDotURLs && strip_dots && **href == '.') &&
	!strncasecomp(Base, "http", 4)) {
	/*
	 * We will be resolving a partial reference versus an http or https
	 * URL, and it has lead dots, which may be retained when resolving via
	 * HTParse(), but the request would fail if the first element of the
	 * resultant path is two dots, because no http or https server accepts
	 * such paths, and the current URL draft, likely to become an RFC, says
	 * that it's optional for the UA to strip them as a form of error
	 * recovery.  So we will, recursively, for http/https URLs, like the
	 * "major market browsers" which made this problem so common on the
	 * Web, but we'll also issue a message about it, such that the bad
	 * partial reference might get corrected by the document provider.  -
	 * FM
	 */
	char *temp = NULL, *path = NULL, *cp;
	const char *str = "";

	temp = HTParse(*href, Base, PARSE_ALL);
	path = HTParse(temp, "", PARSE_PATH + PARSE_PUNCTUATION);
	if (!strncmp(path, "/..", 3)) {
	    cp = (path + 3);
	    if (LYIsHtmlSep(*cp) || *cp == '\0') {
		if (Base[4] == 's') {
		    str = "s";
		}
		CTRACE((tfp,
			"LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
			*href, str));
		CTRACE((tfp, "                  Stripping lead dots.\n"));
		if (!me->inBadHREF) {
		    HTUserMsg(BAD_PARTIAL_REFERENCE);
		    me->inBadHREF = TRUE;
		}
	    }
	    if (*cp == '\0') {
		StrAllocCopy(*href, "/");
	    } else if (LYIsHtmlSep(*cp)) {
		while (!strncmp(cp, "/..", 3)) {
		    if (*(cp + 3) == '/') {
			cp += 3;
			continue;
		    } else if (*(cp + 3) == '\0') {
			*(cp + 1) = '\0';
			*(cp + 2) = '\0';
		    }
		    break;
		}
		StrAllocCopy(*href, cp);
	    }
	}
	FREE(temp);
	FREE(path);
    }
    return (url_type);
}

/*
 *  This function checks for a Content-Base header,
 *  and if not present, a Content-Location header
 *  which is an absolute URL, and sets the BASE
 *  accordingly.  If set, it will be replaced by
 *  any BASE tag in the HTML stream, itself. - FM
 */
void LYCheckForContentBase(HTStructured * me)
{
    char *cp = NULL;
    BOOL present[HTML_BASE_ATTRIBUTES];
    const char *value[HTML_BASE_ATTRIBUTES];
    int i;

    if (!(me && me->node_anchor))
	return;

    if (me->node_anchor->content_base != NULL) {
	/*
	 * We have a Content-Base value.  Use it if it's non-zero length.  - FM
	 */
	if (*me->node_anchor->content_base == '\0')
	    return;
	StrAllocCopy(cp, me->node_anchor->content_base);
	LYRemoveBlanks(cp);
    } else if (me->node_anchor->content_location != NULL) {
	/*
	 * We didn't have a Content-Base value, but do have a Content-Location
	 * value.  Use it if it's an absolute URL.  - FM
	 */
	if (*me->node_anchor->content_location == '\0')
	    return;
	StrAllocCopy(cp, me->node_anchor->content_location);
	LYRemoveBlanks(cp);
	if (!is_url(cp)) {
	    FREE(cp);
	    return;
	}
    } else {
	/*
	 * We had neither a Content-Base nor Content-Location value.  - FM
	 */
	return;
    }

    /*
     * If we collapsed to a zero-length value, ignore it.  - FM
     */
    if (*cp == '\0') {
	FREE(cp);
	return;
    }

    /*
     * Pass the value to HTML_start_element as the HREF of a BASE tag.  - FM
     */
    for (i = 0; i < HTML_BASE_ATTRIBUTES; i++)
	present[i] = NO;
    present[HTML_BASE_HREF] = YES;
    value[HTML_BASE_HREF] = (const char *) cp;
    (*me->isa->start_element) (me, HTML_BASE, present, value,
			       0, 0);
    FREE(cp);
}

/*
 *  This function creates NAMEd Anchors if a non-zero-length NAME
 *  or ID attribute was present in the tag. - FM
 */
void LYCheckForID(HTStructured * me, const BOOL *present,
		  const char **value,
		  int attribute)
{
    HTChildAnchor *ID_A = NULL;
    char *temp = NULL;

    if (!(me && me->text))
	return;

    if (present && present[attribute]
	&& non_empty(value[attribute])) {
	/*
	 * Translate any named or numeric character references.  - FM
	 */
	StrAllocCopy(temp, value[attribute]);
	LYUCTranslateHTMLString(&temp, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_URL);

	/*
	 * Create the link if we still have a non-zero-length string.  - FM
	 */
	if ((temp[0] != '\0') &&
	    (ID_A = HTAnchor_findChildAndLink
	     (
		 me->node_anchor,	/* Parent */
		 temp,		/* Tag */
		 NULL,		/* Addresss */
		 (HTLinkType *) 0))) {	/* Type */
	    HText_beginAnchor(me->text, me->inUnderline, ID_A);
	    HText_endAnchor(me->text, 0);
	}
	FREE(temp);
    }
}

/*
 *  This function creates a NAMEd Anchor for the ID string
 *  passed to it directly as an argument.  It assumes the
 *  does not need checking for character references. - FM
 */
void LYHandleID(HTStructured * me, const char *id)
{
    HTChildAnchor *ID_A = NULL;

    if (!(me && me->text) ||
	isEmpty(id))
	return;

    /*
     * Create the link if we still have a non-zero-length string.  - FM
     */
    if ((ID_A = HTAnchor_findChildAndLink
	 (
	     me->node_anchor,	/* Parent */
	     id,		/* Tag */
	     NULL,		/* Addresss */
	     (HTLinkType *) 0)) != NULL) {	/* Type */
	HText_beginAnchor(me->text, me->inUnderline, ID_A);
	HText_endAnchor(me->text, 0);
    }
}

/*
 *  This function checks whether we want to override
 *  the current default alignment for paragraphs and
 *  instead use that specified in the element's style
 *  sheet. - FM
 */
BOOLEAN LYoverride_default_alignment(HTStructured * me)
{
    if (!me)
	return NO;

    switch (me->sp[0].tag_number) {
    case HTML_BLOCKQUOTE:
    case HTML_BQ:
    case HTML_NOTE:
    case HTML_FN:
    case HTML_ADDRESS:
	me->sp->style->alignment = HT_LEFT;
	return YES;

    default:
	break;
    }
    return NO;
}

/*
 *  This function inserts newlines if needed to create double spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureDoubleSpace(HTStructured * me)
{
    if (!me || !me->text)
	return;

    if (!HText_LastLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	HText_appendCharacter(me->text, '\r');
	HText_appendCharacter(me->text, '\r');
    } else if (!HText_PreviousLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	HText_appendCharacter(me->text, '\r');
    } else if (me->List_Nesting_Level >= 0) {
	HText_NegateLineOne(me->text);
    }
    me->in_word = NO;
    return;
}

/*
 *  This function inserts a newline if needed to create single spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureSingleSpace(HTStructured * me)
{
    if (!me || !me->text)
	return;

    if (!HText_LastLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	HText_appendCharacter(me->text, '\r');
    } else if (me->List_Nesting_Level >= 0) {
	HText_NegateLineOne(me->text);
    }
    me->in_word = NO;
    return;
}

/*
 *  This function resets paragraph alignments for block
 *  elements which do not have a defined style sheet. - FM
 */
void LYResetParagraphAlignment(HTStructured * me)
{
    if (!me)
	return;

    if (me->List_Nesting_Level >= 0 ||
	((me->Division_Level < 0) &&
	 (me->sp->style->id == ST_Normal ||
	  me->sp->style->id == ST_Preformatted))) {
	me->sp->style->alignment = HT_LEFT;
    } else {
	me->sp->style->alignment = (short) me->current_default_alignment;
    }
    return;
}

/*
 *  This example function checks whether the given anchor has
 *  an address with a file scheme, and if so, loads it into the
 *  the SGML parser's context->url element, which was passed as
 *  the second argument.  The handle_comment() calling function in
 *  SGML.c then calls LYDoCSI() in LYUtils.c to insert HTML markup
 *  into the corresponding stream, homologously to an SSI by an
 *  HTTP server. - FM
 *
 *  For functions similar to this but which depend on details of
 *  the HTML handler's internal data, the calling interface should
 *  be changed, and functions in SGML.c would have to make sure not
 *  to call such functions inappropriately (e.g., calling a function
 *  specific to the Lynx_HTML_Handler when SGML.c output goes to
 *  some other HTStructured object like in HTMLGen.c), or the new
 *  functions could be added to the SGML.h interface.
 */
BOOLEAN LYCheckForCSI(HTParentAnchor *anchor,
		      char **url)
{
    if (!(anchor && anchor->address))
	return FALSE;

    if (!isFILE_URL(anchor->address))
	return FALSE;

    if (!LYisLocalHost(anchor->address))
	return FALSE;

    StrAllocCopy(*url, anchor->address);
    return TRUE;
}

/*
 *  This function is called from the SGML parser to look at comments
 *  and see whether we should collect some info from them.  Currently
 *  it only looks for comments with Message-Id and Subject info, in the
 *  exact form generated by MHonArc for archived mailing list.  If found,
 *  the info is stored in the document's HTParentAnchor.  It can later be
 *  used for generating a mail response.
 *
 *  We are extra picky here because there isn't any official definition
 *  for these kinds of comments - we might (and still can) misinterpret
 *  arbitrary comments as something they aren't.
 *
 *  If something doesn't look right, for example invalid characters, the
 *  strings are not stored.  Mail responses will use something else as
 *  the subject, probably the document URL, and will not have an
 *  In-Reply-To header.
 *
 *  All this is a hack - to do this the right way, mailing list archivers
 *  would have to agree on some better mechanism to make this kind of info
 *  from original mail headers available, for example using LINK.  - kw
 */
BOOLEAN LYCommentHacks(HTParentAnchor *anchor,
		       const char *comment)
{
    const char *cp = comment;
    size_t len;

    if (comment == NULL)
	return FALSE;

    if (!(anchor && anchor->address))
	return FALSE;

    if (strncmp(comment, "!--X-Message-Id: ", 17) == 0) {
	char *messageid = NULL;
	char *p;

	for (cp = comment + 17; *cp; cp++) {
	    if (UCH(*cp) >= 127 || !isgraph(UCH(*cp))) {
		break;
	    }
	}
	if (strcmp(cp, " --")) {
	    return FALSE;
	}
	cp = comment + 17;
	StrAllocCopy(messageid, cp);
	/* This should be ok - message-id should only contain 7-bit ASCII */
	if (!LYUCTranslateHTMLString(&messageid, 0, 0, NO, NO, YES, st_URL))
	    return FALSE;
	for (p = messageid; *p; p++) {
	    if (UCH(*p) >= 127 || !isgraph(UCH(*p))) {
		break;
	    }
	}
	if (strcmp(p, " --")) {
	    FREE(messageid);
	    return FALSE;
	}
	if ((p = strchr(messageid, '@@')) == NULL || p[1] == '\0') {
	    FREE(messageid);
	    return FALSE;
	}
	p = messageid;
	if ((len = strlen(p)) >= 8 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
	} else {
	    FREE(messageid);
	    return FALSE;
	}
	if (HTAnchor_setMessageID(anchor, messageid)) {
	    FREE(messageid);
	    return TRUE;
	} else {
	    FREE(messageid);
	    return FALSE;
	}
    }
    if (strncmp(comment, "!--X-Subject: ", 14) == 0) {
	char *subject = NULL;
	char *p;

	for (cp = comment + 14; *cp; cp++) {
	    if (UCH(*cp) >= 127 || !isprint(UCH(*cp))) {
		return FALSE;
	    }
	}
	cp = comment + 14;
	StrAllocCopy(subject, cp);
	/* @@@@@@
	 * This may not be the right thing for the subject - but mail
	 * subjects shouldn't contain 8-bit characters in raw form anyway.
	 * We have to unescape character entities, since that's what MHonArc
	 * seems to generate.  But if after that there are 8-bit characters
	 * the string is rejected.  We would probably not know correctly
	 * what charset to assume anyway - the mail sender's can differ from
	 * the archive's.  And the code for sending mail cannot deal well
	 * with 8-bit characters - we should not put them in the Subject
	 * header in raw form, but don't have MIME encoding implemented.
	 * Someone may want to do more about this...  - kw
	 */
	if (!LYUCTranslateHTMLString(&subject, 0, 0, NO, YES, NO, st_HTML))
	    return FALSE;
	for (p = subject; *p; p++) {
	    if (UCH(*p) >= 127 || !isprint(UCH(*p))) {
		FREE(subject);
		return FALSE;
	    }
	}
	p = subject;
	if ((len = strlen(p)) >= 4 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
	} else {
	    FREE(subject);
	    return FALSE;
	}
	if (HTAnchor_setSubject(anchor, subject)) {
	    FREE(subject);
	    return TRUE;
	} else {
	    FREE(subject);
	    return FALSE;
	}
    }

    return FALSE;
}

    /*
     * Create the Title with any left-angle-brackets converted to &lt; entities
     * and any ampersands converted to &amp; entities.  - FM
     *
     * Convert 8-bit letters to &#xUUUU to avoid dependencies from display
     * character set which may need changing.  Do NOT convert any 8-bit chars
     * if we have CJK display.  - LP
     */
void LYformTitle(char **dst,
		 const char *src)
{
    if (HTCJK == JAPANESE) {
	char *tmp_buffer = NULL;

	if ((tmp_buffer = (char *) malloc(strlen(src) + 1)) == 0)
	    outofmem(__FILE__, "LYformTitle");
	switch (kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
	case EUC:
	    TO_EUC((const unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	case SJIS:
	    TO_SJIS((const unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	default:
	    CTRACE((tfp, "\nLYformTitle: kanji_code is an unexpected value."));
	    strcpy(tmp_buffer, src);
	    break;
	}
	StrAllocCopy(*dst, tmp_buffer);
	FREE(tmp_buffer);
    } else {
	StrAllocCopy(*dst, src);
    }
}
@


1.8
log
@automatic merge
@
text
@d2045 1
a2045 1
		      char *name)
d2553 6
a2558 5
	    me->CurrentA = HTAnchor_findChildAndLink(
							me->node_anchor,	/* Parent */
							id_string,	/* Tag */
							href,	/* Addresss */
							(void *) 0);	/* Type */
d3207 6
a3212 5
	    (ID_A = HTAnchor_findChildAndLink(
						 me->node_anchor,	/* Parent */
						 temp,	/* Tag */
						 NULL,	/* Addresss */
						 (void *) 0))) {	/* Type */
d3236 6
a3241 5
    if ((ID_A = HTAnchor_findChildAndLink(
					     me->node_anchor,	/* Parent */
					     id,	/* Tag */
					     NULL,	/* Addresss */
					     (void *) 0)) != NULL) {	/* Type */
@


1.7
log
@automatic merge; regen configure
@
text
@d2131 1
a2131 1
	value[HTML_META_HTTP_EQUIV] && *value[HTML_META_HTTP_EQUIV]) {
d2141 1
a2141 1
	value[HTML_META_NAME] && *value[HTML_META_NAME]) {
d2151 1
a2151 1
	value[HTML_META_CONTENT] && *value[HTML_META_CONTENT]) {
d2289 1
a2289 1
    } else if (!(me->node_anchor->charset && *me->node_anchor->charset) &&
d2588 1
a2588 1
    } else if (!(me->node_anchor->SugFname && *me->node_anchor->SugFname) &&
d2819 1
a2819 1
	      value[HTML_SELECT_NAME] && *value[HTML_SELECT_NAME])) {
d2832 1
a2832 1
	    value[HTML_SELECT_SIZE] && *value[HTML_SELECT_SIZE]) {
d2944 1
a2944 1
	    for (; ptr && *ptr != '\0'; ptr++) {
d3194 1
a3194 1
	&& value[attribute] && *value[attribute]) {
d3228 1
a3228 1
	!(id && *id))
@


1.6
log
@automatic merge of lynx-current
@
text
@d2602 1
a2602 1
		if (*me->node_anchor->SugFname == '\"') {
d2604 1
a2604 1
				     '\"')) != NULL) {
d2855 1
a2855 1
	    HText_LastLineSize(me->text, FALSE) > (LYcols - 8)) {
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 3
a4 3
**  Functions associated with LYCharSets.c and the Lynx version of HTML.c - FM
**  ==========================================================================
*/
d42 1
a42 1
 *  Used for nested lists. - FM
d44 2
a45 3
int OL_CONTINUE = -29999;     /* flag for whether CONTINUE is set */
int OL_VOID = -29998;	     /* flag for whether a count is set */

d48 6
a53 7
**  This function converts any ampersands in allocated
**  strings to "&amp;".  If isTITLE is TRUE, it also
**  converts any angle-brackets to "&lt;" or "&gt;". - FM
*/
void LYEntify (
	char **	str,
	BOOLEAN	isTITLE)
d58 1
d60 8
a67 3
    enum _state
	{ S_text, S_esc, S_dollar, S_paren,
	  S_nonascii_text, S_dollar_paren } state = S_text;
d75 1
a75 1
     *	Count the ampersands. - FM
d83 1
a83 1
     *	Count the left-angle-brackets, if needed. - FM
d94 1
a94 1
     *	Count the right-angle-brackets, if needed. - FM
d105 1
a105 1
     *	Check whether we need to convert anything. - FM
d111 1
a111 1
     *	Allocate space and convert. - FM
d120 8
a127 8
	    switch(state) {
		case S_text:
		    if (*p == '\033') {
			state = S_esc;
			*q++ = *p;
			continue;
		    }
		    break;
d129 14
a142 14
		case S_esc:
		    if (*p == '$') {
			state = S_dollar;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }
d144 14
a157 14
		case S_dollar:
		    if (*p == '@@' || *p == 'B' || *p == 'A') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_dollar_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }
d159 10
a168 10
		case S_dollar_paren:
		    if (*p == 'C') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }
d170 7
a176 15
		case S_paren:
		    if (*p == 'B' || *p == 'J' || *p =='T') {
			state = S_text;
			*q++ = *p;
			continue;
		    } else if (*p == 'I') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    }
		    /* FALLTHRU */

		case S_nonascii_text:
		    if (*p == '\033')
			state = S_esc;
d179 8
d188 2
a189 2
		default:
		    break;
d191 4
a194 4
	    if (*(p+1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p+1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p+1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p+1))))) {
d227 5
a231 6
**  This function trims characters <= that of a space (32),
**  including HT_NON_BREAK_SPACE (1) and HT_EN_SPACE (2),
**  but not ESC, from the heads of strings. - FM
*/
void LYTrimHead (
	char * str)
d238 1
a238 1
    while (*s && WHITE(*s) && UCH(*s) != UCH(CH_ESC))   /* S/390 -- gil -- 1669 */
d242 1
d251 5
a255 6
**  This function trims characters <= that of a space (32),
**  including HT_NON_BREAK_SPACE (1), HT_EN_SPACE (2), and
**  ESC from the tails of strings. - FM
*/
void LYTrimTail (
	char * str)
d273 6
a278 7
** This function should receive a pointer to the start
** of a comment.  It returns a pointer to the end ('>')
** character of comment, or it's best guess if the comment
** is invalid. - FM
*/
char *LYFindEndOfComment (
	char * str)
d281 6
a286 1
    enum comment_state { start1, start2, end1, end2 } state;
d290 1
a290 1
	 *  We got NULL, so return NULL. - FM
d296 2
a297 2
	 *  We don't have the start of a comment, so
	 *  return the beginning of the string. - FM
d302 1
a302 1
    if (*cp =='>')
d311 2
a312 2
	 *  We don't have an end character, so
	 *  return the beginning of the string. - FM
d318 2
a319 2
	 *  Ugh, it's a "decorative" series of dashes,
	 *  so return the next end character. - FM
d324 1
a324 1
     *	OK, we're ready to start parsing. - FM
d329 10
a338 10
	    case start1:
		if (*cp == '-')
		    state = start2;
		else
		    /*
		     *	Invalid comment, so return the first
		     *	'>' from the start of the string. - FM
		     */
		    return cp1;
		break;
d340 4
a343 4
	    case start2:
		if (*cp == '-')
		    state = end1;
		break;
d345 10
a354 10
	    case end1:
		if (*cp == '-')
		    state = end2;
		else
		    /*
		     *	Invalid comment, so return the first
		     *	'>' from the start of the string. - FM
		     */
		    return cp1;
		break;
d356 16
a371 16
	    case end2:
		if (*cp == '>')
		    /*
		     *	Valid comment, so return the end character. - FM
		     */
		    return cp;
		if (*cp == '-') {
		    state = start1;
		} else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {  /* S/390 -- gil -- 1686 */
		    /*
		     *	Invalid comment, so return the first
		     *	'>' from the start of the string. - FM
		     */
		    return cp1;
		 }
		break;
d373 2
a374 2
	    default:
		break;
d380 2
a381 2
     *	Invalid comment, so return the first
     *	'>' from the start of the string. - FM
d387 10
a396 11
**  If an HREF, itself or if resolved against a base,
**  represents a file URL, and the host is defaulted,
**  force in "//localhost".  We need this until
**  all the other Lynx code which performs security
**  checks based on the "localhost" string is changed
**  to assume "//localhost" when a host field is not
**  present in file URLs - FM
*/
void LYFillLocalFileURL (
	char **	href,
	const char *	base)
d398 1
a398 1
    char * temp = NULL;
d411 1
a411 1
	if (*(*href+5) == '\0') {
d416 5
a420 5
	    StrAllocCopy(temp, (*href+7));
	    LYLocalFileToURL (href, temp);
	} else if (!strncmp(*href, "file:/", 6) && !LYIsHtmlSep(*(*href+6))) {
	    StrAllocCopy(temp, (*href+5));
	    LYLocalFileToURL (href, temp);
a422 1

d424 1
a424 1
    if (LYIsDosDrive(*href))  {
d430 1
a430 1
	LYLocalFileToURL (href, temp);
d435 2
a436 2
	  && (strlen(*href) == 19)
	  && LYIsDosDrive(*href+17)) {
d451 1
d456 1
d462 2
a463 2
	 *  Check for pathological cases - current dir has chars which
	 *  MUST BE URL-escaped - kw
a472 1

d479 1
a479 1
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir())+1));
d487 26
a512 28
**  This function writes a line with a META tag to an open file,
**  which will specify a charset parameter to use when the file is
**  read back in.  It is meant for temporary HTML files used by the
**  various special pages which may show titles of documents.  When those
**  files are created, the title strings normally have been translated and
**  expanded to the display character set, so we have to make sure they
**  don't get translated again.
**  If the user has changed the display character set during the lifetime
**  of the Lynx session (or, more exactly, during the time the title
**  strings to be written were generated), they may now have different
**  character encodings and there is currently no way to get it all right.
**  To change this, we would have to add a variable for each string which
**  keeps track of its character encoding.
**  But at least we can try to ensure that reading the file after future
**  display character set changes will give reasonable output.
**
**  The META tag is not written if the display character set (passed as
**  disp_chndl) already corresponds to the charset assumption that
**  would be made when the file is read. - KW
**
**  Currently this function is used for temporary files like "Lynx Info Page"
**  and for one permanent - bookmarks (so it may be a problem if you change
**  the display charset later: new bookmark entries may be mistranslated).
**								 - LP
*/
void LYAddMETAcharsetToFD (
	FILE *		fd,
	int		disp_chndl)
d516 1
a516 1
	 *  -1 means use current_char_set.
d522 1
a522 1
	 *  Should not happen.
d528 1
a528 1
	 *  Not need to do, so we don't.
d534 1
a534 1
	 *  There shouldn't be any 8-bit characters in this case.
d539 3
a541 3
     *	In other cases we don't know because UCLYhndl_for_unspec may
     *	change during the lifetime of the file (by toggling raw mode
     *	or changing the display character set), so proceed.
d544 2
a545 2
		"http-equiv=\"content-type\"",
		LYCharSet_UC[disp_chndl].MIMEname);
d549 4
a552 5
** This function returns OL TYPE="A" strings in
** the range of " A." (1) to "ZZZ." (18278). - FM
*/
char *LYUppercaseA_OL_String (
	int seqnum)
d556 1
a556 1
    if (seqnum <= 1 ) {
d565 2
a566 2
	sprintf(OLstring, "%c%c.", ((seqnum-1)/26 + 64),
		(seqnum - ((seqnum-1)/26)*26 + 64));
d570 3
a572 3
	sprintf(OLstring, "%c%c%c.", ((seqnum-27)/676 + 64),
		(((seqnum - ((seqnum-27)/676)*676)-1)/26 + 64),
		(seqnum - ((seqnum-1)/26)*26 + 64));
d580 4
a583 5
** This function returns OL TYPE="a" strings in
** the range of " a." (1) to "zzz." (18278). - FM
*/
char *LYLowercaseA_OL_String (
	int seqnum)
d587 1
a587 1
    if (seqnum <= 1 ) {
d596 2
a597 2
	sprintf(OLstring, "%c%c.", ((seqnum-1)/26 + 96),
		(seqnum - ((seqnum-1)/26)*26 + 96));
d601 3
a603 3
	sprintf(OLstring, "%c%c%c.", ((seqnum-27)/676 + 96),
		(((seqnum - ((seqnum-27)/676)*676)-1)/26 + 96),
		(seqnum - ((seqnum-1)/26)*26 + 96));
d611 5
a615 6
** This function returns OL TYPE="I" strings in the
** range of " I." (1) to "MMM." (3000).- FM
** Maximum length: 16 -TD
*/
char *LYUppercaseI_OL_String (
	int seqnum)
d625 1
a625 1
    switch(Arabic) {
d745 5
a749 6
** This function returns OL TYPE="i" strings in
** range of " i." (1) to "mmm." (3000).- FM
** Maximum length: 16 -TD
*/
char *LYLowercaseI_OL_String (
	int seqnum)
d759 1
a759 1
    switch(Arabic) {
d879 3
a881 4
**  This function initializes the Ordered List counter. - FM
*/
void LYZero_OL_Counter (
	HTStructured *		me)
d900 3
a902 4
**  This function is used by the HTML Structured object. - KW
*/
void LYGetChartransInfo (
	HTStructured *		me)
d926 7
a932 7
 *  Given an UCS character code, will fill buffer passed in as q with
 *  the code's UTF-8 encoding.
 *  If terminate = YES, terminates string on success and returns pointer
 *			to beginning.
 *  If terminate = NO,	does not terminate string, and returns pointer
 *			next char after the UTF-8 put into buffer.
 *  On failure, including invalid code or 7-bit code, returns NULL.
d934 1
a934 1
static char * UCPutUtf8ToBuffer (char * q, UCode_t code, BOOL terminate)
d937 1
d939 1
a939 1
    return NULL;
d942 2
a943 2
	    *q++ = (char)(0xc0 | (code>>6));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d945 3
a947 3
	    *q++ = (char)(0xe0 | (code>>12));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d949 4
a952 4
	    *q++ = (char)(0xf0 | (code>>18));
	    *q++ = (char)(0x80 | (0x3f & (code>>12)));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d954 5
a958 5
	    *q++ = (char)(0xf8 | (code>>24));
	    *q++ = (char)(0x80 | (0x3f & (code>>18)));
	    *q++ = (char)(0x80 | (0x3f & (code>>12)));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d960 6
a965 6
	    *q++ = (char)(0xfc | (code>>30));
	    *q++ = (char)(0x80 | (0x3f & (code>>24)));
	    *q++ = (char)(0x80 | (0x3f & (code>>18)));
	    *q++ = (char)(0x80 | (0x3f & (code>>12)));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d986 85
a1070 86
**  This function used for translations HTML special fields inside tags
**  (ALT=, VALUE=, etc.) from charset `cs_from' to charset `cs_to'.
**  It also unescapes non-ASCII characters from URL (#fragments !)
**  if st_URL is active.
**
**  If `do_ent' is YES, it converts named entities
**  and numeric character references (NCRs) to their `cs_to' replacements.
**
**  Named entities converted to unicodes.  NCRs (unicodes) converted
**  by UCdomap.c chartrans functions.
**  ???NCRs with values in the ISO-8859-1 range 160-255 may be converted
**  to their HTML entity names (via old-style entities) and then translated
**  according to the LYCharSets.c array for `cs_out'???.
**
**  Some characters (see descriptions in `put_special_unicodes' from SGML.c)
**  translated in relation with the state of boolean variables
**  `use_lynx_specials', `plain_space' and `hidden'.  It is not clear yet:
**
**  If plain_space is TRUE, nbsp (160) will be treated as an ASCII
**  space (32).  If hidden is TRUE, entities will be translated
**  (if `do_ent' is YES) but escape sequences will be passed unaltered.
**  If `hidden' is FALSE, some characters are converted to Lynx special
**  codes (see `put_special_unicodes') or ASCII space if `plain_space'
**  applies).  @@@@ is `use_lynx_specials' needed, does it have any effect? @@@@
**  If `use_lynx_specials' is YES, translate byte values 160 and 173
**  meaning U+00A0 and U+00AD given as or converted from raw char input
**  are converted to HT_NON_BREAK_SPACE and LY_SOFT_HYPHEN, respectively
**  (unless input and output charset are both iso-8859-1, for compatibility
**  with previous usage in HTML.c) even if `hidden' or `plain_space' is set.
**
**  If `Back' is YES, the reverse is done instead i.e., Lynx special codes
**  in the input are translated back to character values.
**
**  If `Back' is YES, an attempt is made to use UCReverseTransChar() for
**  back translation which may be more efficient. (?)
**
**  If `stype' is st_URL, non-ASCII characters are URL-encoded instead.
**  The sequence of bytes being URL-encoded is the raw input character if
**  we couldn't translate it from `cs_in' (CJK etc.); otherwise it is the
**  UTF-8 representation if either `cs_to' requires this or if the
**  character's Unicode value is > 255, otherwise it should be the iso-8859-1
**  representation.
**  No general URL-encoding occurs for displayable ASCII characters and
**  spaces and some C0 controls valid in HTML (LF, TAB), it is expected
**  that other functions will take care of that as appropriate.
**
**  Escape characters (0x1B, '\033') are
**  - URL-encoded	if `stype'  is st_URL,	 otherwise
**  - dropped		if `stype'  is st_other, otherwise (i.e., st_HTML)
**  - passed		if `hidden' is TRUE or HTCJK is set, otherwise
**  - dropped.
**
**  (If `stype' is st_URL or st_other most of the parameters really predefined:
**  cs_from=cs_to, use_lynx_specials=plain_space=NO, and hidden=YES)
**
**
**  Returns pointer to the char** passed in
**		 if string translated or translation unnecessary,
**	    NULL otherwise
**		 (in which case something probably went wrong.)
**
**
**  In general, this somehow ugly function (KW)
**  cover three functions from v.2.7.2 (FM):
**		    extern void LYExpandString (
**		       HTStructured *	       me,
**		       char **		       str);
**		    extern void LYUnEscapeEntities (
**		       HTStructured *	       me,
**		       char **		       str);
**		    extern void LYUnEscapeToLatinOne (
**		       HTStructured *	       me,
**		       char **		       str,
**		       BOOLEAN		       isURL);
*/

char ** LYUCFullyTranslateString (
	char **	str,
	int		cs_from,
	int		cs_to,
	BOOLEAN	do_ent,
	BOOL		use_lynx_specials,
	BOOLEAN	plain_space,
	BOOLEAN	hidden,
	BOOL		Back,
	CharUtil_st	stype)
d1072 1
a1072 1
    char * p;
d1075 1
a1075 1
    char * cp = 0;
d1078 1
a1078 1
    char replace_buf [64];
d1085 1
a1085 1
    const char * name = NULL;
d1089 14
a1102 4
    char * puni;
    enum _state
	{ S_text, S_esc, S_dollar, S_paren, S_nonascii_text, S_dollar_paren,
	S_trans_byte, S_check_ent, S_ncr, S_check_uni, S_named, S_check_name,
d1104 16
a1119 5
	S_got_oututf8, S_got_outstring, S_put_urlstring,
	S_got_outchar, S_put_urlchar, S_next_char, S_done} state = S_text;
    enum _parsing_what
	{ P_text, P_utf8, P_hex, P_decimal, P_named
	} what = P_text;
d1122 1
d1129 2
a1130 2
    **	Make sure we have a non-empty string. - FM
    */
d1141 9
a1149 6
    **	Don't do byte translation
    **	if original AND target character sets
    **	are both iso-8859-1 (and we are not called to back-translate),
    **	or if we are in CJK mode.
    */
    if (HTCJK != NOCJK) {
d1154 1
a1154 1
    /* No need to translate or examine the string any further */
d1159 2
a1160 2
    **	Save malloc/calloc overhead in simple case - kw
    */
d1189 1
a1189 1
		       HText_hasUTF8OutputSet(HTMainText));
d1196 3
a1198 3
    **	Create a buffer string seven times the length of the original,
    **	so we have plenty of room for expansions. - FM
    */
d1220 6
a1225 7
    *  Loop through string, making conversions as needed.
    *
    *  The while() checks for a non-'\0' char only for the normal
    *  text states since other states may temporarily modify p or *p
    *  (which should be restored before S_done!) - kw
    */

d1227 1
a1227 1
	switch(state) {
d1232 1
a1232 1
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code)||IS_SJIS_HI2(code))){
d1241 1
a1241 1
						sjis_str, sjis_str + 1);
d1266 3
a1268 3
		    **	CJK handling not on, and not a hidden INPUT,
		    **	so block escape. - FM
		    */
d1317 1
a1317 1
	    if (*p == 'B' || *p == 'J' || *p == 'T')  {
d1348 1
a1348 1
	    /*	character translation goes here  */
d1350 4
a1353 5
	    **	Don't do anything if we have no string,
	    **	or if original AND target character sets
	    **	are both iso-8859-1,
	    **	or if we are in CJK mode.
	    */
d1361 1
d1375 1
a1375 1
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
d1379 1
a1379 1
			    *(unsigned char *)p = UCH(160);
d1389 1
a1389 1
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
d1393 1
a1393 1
			*(unsigned char *)p = UCH(173);
d1412 1
a1412 1
		if (((*p)&0xc0)==0xc0) {
d1442 3
a1444 3
	    **	Substitute Lynx special character for
	    **	160 (nbsp) if use_lynx_specials is set.
	    */
d1447 1
a1447 1
		code = ((code==160 ? HT_NON_BREAK_SPACE : LY_SOFT_HYPHEN));
d1457 2
a1458 1
		char * pp = p + 1;
d1461 2
a1462 2
		**  Check for a numeric entity. - FM
		*/
d1464 3
a1466 3
		    (*(pp+1) == 'x' || *(pp+1) == 'X') &&
		    UCH(*(pp+2)) < 127 &&
		    isxdigit(UCH(*(pp+2)))) {
d1470 2
a1471 2
			   UCH(*(pp+1)) < 127 &&
			   isdigit(UCH(*(pp+1)))) {
d1487 28
a1514 170
		if (what == P_hex) {
		    p += 3;
		} else {	/* P_decimal */
		    p += 2;
		}
		cp = p;
		while (*p && UCH(*p) < 127 &&
		       (what == P_hex ? isxdigit(UCH(*p)) :
					isdigit(UCH(*p)))) {
		    p++;
		}
		/*
		**  Save the terminator and isolate the digit(s). - FM
		*/
		cpe = *p;
		if (*p)
		    *p++ = '\0';
		/*
		** Show the numeric entity if the value:
		**  (1) Is greater than 255 and unhandled Unicode.
		**  (2) Is less than 32, and not valid and we don't
		**	have HTCJK set.
		**  (3) Is 127 and we don't have HTPassHighCtrlRaw
		**	or HTCJK set.
		**  (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
		*/
		if ((((what == P_hex) ? sscanf(cp, "%lx", &lcode) :
					sscanf(cp, "%ld", &lcode)) != 1) ||
		    lcode > 0x7fffffffL || lcode < 0) {
		    state = S_recover;
		    break;
		} else {
		    code = lcode;
		    if ((code == 1) ||
		       (code > 127 && code < 156)) {
			/*
			** Assume these are Microsoft code points, inflicted on
			** us by FrontPage.  - FM
			**
			** MS FrontPage uses syntax like &#153; in 128-159
			** range and doesn't follow Unicode standards for this
			** area.  Windows-1252 codepoints are assumed here.
			*/
			switch (code) {
			case 1:
			    /*
			    **	WHITE SMILING FACE
			    */
			    code = 0x263a;
			    break;
			case 128:
			    /*
			    **	EURO currency sign
			    */
			    code = 0x20ac;
			    break;
			case 130:
			    /*
			    **	SINGLE LOW-9 QUOTATION MARK (sbquo)
			    */
			    code = 0x201a;
			    break;
			case 132:
			    /*
			    **	DOUBLE LOW-9 QUOTATION MARK (bdquo)
			    */
			    code = 0x201e;
			    break;
			case 133:
			    /*
			    **	HORIZONTAL ELLIPSIS (hellip)
			    */
			    code = 0x2026;
			    break;
			case 134:
			    /*
			    **	DAGGER (dagger)
			    */
			    code = 0x2020;
			    break;
			case 135:
			    /*
			    **	DOUBLE DAGGER (Dagger)
			    */
			    code = 0x2021;
			    break;
			case 137:
			    /*
			    **	PER MILLE SIGN (permil)
			    */
			    code = 0x2030;
			    break;
			case 139:
			    /*
			    **	SINGLE LEFT-POINTING ANGLE QUOTATION MARK
			    **	(lsaquo)
			    */
			    code = 0x2039;
			    break;
			case 145:
			    /*
			    **	LEFT SINGLE QUOTATION MARK (lsquo)
			    */
			    code = 0x2018;
			    break;
			case 146:
			    /*
			    **	RIGHT SINGLE QUOTATION MARK (rsquo)
			    */
			    code = 0x2019;
			    break;
			case 147:
			    /*
			    **	LEFT DOUBLE QUOTATION MARK (ldquo)
			    */
			    code = 0x201c;
			    break;
			case 148:
			    /*
			    **	RIGHT DOUBLE QUOTATION MARK (rdquo)
			    */
			    code = 0x201d;
			    break;
			case 149:
			    /*
			    **	BULLET (bull)
			    */
			    code = 0x2022;
			    break;
			case 150:
			    /*
			    **	EN DASH (ndash)
			    */
			    code = 0x2013;
			    break;
			case 151:
			    /*
			    **	EM DASH (mdash)
			    */
			    code = 0x2014;
			    break;
			case 152:
			    /*
			    **	SMALL TILDE (tilde)
			    */
			    code = 0x02dc;
			    break;
			case 153:
			    /*
			    **	TRADE MARK SIGN (trade)
			    */
			    code = 0x2122;
			    break;
			case 155:
			    /*
			    **	SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
			    **	(rsaquo)
			    */
			    code = 0x203a;
			    break;
			default:
			    /*
			    **	Do not attempt a conversion
			    **	to valid Unicode values.
			    */
			    break;
		       }
		    }
		    state = S_check_uni;
		}
d1516 4
a1519 30

	case S_check_uni:
		/*
		** Show the numeric entity if the value:
		**  (2) Is less than 32, and not valid and we don't
		**	have HTCJK set.
		**  (3) Is 127 and we don't have HTPassHighCtrlRaw
		**	or HTCJK set.
		**  (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
		*/
		 if ((code < 32 &&
		     code != 9 && code != 10 && code != 13 &&
		     HTCJK == NOCJK) ||
		    (code == 127 &&
		     !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
		    (code > 127 && code < 160 &&
		     !HTPassHighCtrlNum)) {
		     state = S_recover;
		     break;
		 }
		/*
		**  Convert the value as an unsigned char,
		**  hex escaped if isURL is set and it's
		**  8-bit, and then recycle the terminator
		**  if it is not a semicolon. - FM
		*/
		if (code > 159 && stype == st_URL) {
		    state = S_got_oututf8;
		    break;
		}
d1521 91
a1611 9
		    **	For 160 (nbsp), use that value if it's
		    **	a hidden INPUT, otherwise use an ASCII
		    **	space (32) if plain_space is TRUE,
		    **	otherwise use the Lynx special character. - FM
		    */
		if (code == 160) {
		    if (plain_space) {
			code = ' ';
			state = S_got_outchar;
d1613 5
a1617 3
		    } else if (use_lynx_specials) {
			code = HT_NON_BREAK_SPACE;
			state = S_got_outchar;
d1619 5
a1623 6
		    } else if ((hidden && !Back) ||
			       (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1) ||
			       LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			       (LYCharSet_UC[cs_to].like8859 &
						UCT_R_8859SPECL)) {
			state = S_got_outchar;
d1625 5
a1629 6
		    } else if (
			(LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
			;	/* nothing, may be translated later */
		    } else {
			code = ' ';
			state = S_got_outchar;
d1631 5
a1635 12
		    }
		}
		/*
		    **	For 173 (shy), use that value if it's
		    **	a hidden INPUT, otherwise ignore it
		    **	if plain_space is TRUE, otherwise use
		    **	the Lynx special character. - FM
		    */
		if (code == 173) {
		    if (plain_space) {
			replace_buf[0] = '\0';
			state = S_got_outstring;
d1637 5
a1641 7
		    } else if (Back &&
			       !(LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
				 (LYCharSet_UC[cs_to].like8859 &
					       UCT_R_8859SPECL))) {
			;	/* nothing, may be translated later */
		    } else if (hidden || Back) {
			state = S_got_outchar;
d1643 4
a1646 3
		    } else if (use_lynx_specials) {
			code = LY_SOFT_HYPHEN;
			state = S_got_outchar;
d1650 42
a1691 8
		/*
		**  Seek a translation from the chartrans tables.
		*/
		if ((uck = UCTransUniChar(code,
					  cs_to)) >= 32 &&
		    uck < 256 &&
		    (uck < 127 || uck >= lowest_8)) {
		    code = uck;
d1694 6
a1699 11
		} else if ((uck == -4 ||
			    (repl_translated_C0 &&
			     uck > 0 && uck < 32)) &&
			   /*
			   **  Not found; look for replacement string.
			   */
			   (uck = UCTransUniCharStr(replace_buf,
						    60, code,
						    cs_to,
						    0) >= 0)) {
		    state = S_got_outstring;
d1701 6
a1706 4
		}
		if (output_utf8 &&
		    code > 127 && code < 0x7fffffffL) {
		    state = S_got_oututf8;
d1709 8
a1716 26
		/*
		**  For 8194 (ensp), 8195 (emsp), or 8201 (thinsp),
		**  use the character reference if it's a hidden INPUT,
		**  otherwise use an ASCII space (32) if plain_space is
		**  TRUE, otherwise use the Lynx special character. - FM
		*/
		if (code == 8194 || code == 8195 || code == 8201) {
		    if (hidden) {
			state = S_recover;
		    } else if (plain_space) {
			code = ' ';
			state = S_got_outchar;
		    } else {
			code = HT_EN_SPACE;
			state = S_got_outchar;
		    }
		    break;
		    /*
		    **	Ignore 8204 (zwnj), 8205 (zwj)
		    **	8206 (lrm), and 8207 (rlm),
		    **	for now, if we got this far without
		    **	finding a representation for them.
		    */
		} else if (code == 8204 || code == 8205 ||
			   code == 8206 || code == 8207) {
		    CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
d1720 11
a1730 11
		    /*
		    **	Show the numeric entity if the value:
		    **	(1) Is greater than 255 and unhandled Unicode.
		    */
		} else if (code > 255) {
		    /*
			**  Illegal or not yet handled value.
			**  Return "&#" verbatim and continue
			**  from there. - FM
			*/
		    state = S_recover;
d1732 15
d1748 28
a1775 10
		**  If it's ASCII, or is 8-bit but HTPassEightBitNum
		**  is set or the character set is "ISO Latin 1",
		**  use it's value. - FM
		*/
		} else if (code < 161 ||
			   (code < 256 &&
			    (HTPassEightBitNum || cs_to == LATIN1))) {
		    /*
		    **	No conversion needed.
		    */
d1777 36
a1812 1
		    break;
d1814 12
a1825 14
		    /* The following disabled section doesn't make sense
		    ** any more.  It used to make sense in the past, when
		    ** S_check_named would look in "old style" tables
		    ** in addition to what it does now.
		    ** Disabling of going to S_check_name here prevents
		    ** endless looping between S_check_uni and S_check_names
		    ** states, which could occur here for Latin 1 codes
		    ** for some cs_to if they had no translation in that
		    ** cs_to.  Normally all cs_to *should* now have valid
		    ** translations via UCTransUniChar or UCTransUniCharStr
		    ** for all Latin 1 codes, so that we would not get here
		    ** anyway, and no loop could occur.  Still, if we *do*
		    ** get here, FALL THROUGH to case S_recover now.  - kw
		    */
d1827 8
a1834 8
		    /*
		    **	If we get to here, convert and handle
		    **	the character as a named entity. - FM
		    */
		} else {
		    name = HTMLGetEntityName(code - 160);
		    state = S_check_name;
		    break;
d1836 1
a1836 1
		}
d1841 3
a1843 4
		**  Illegal or not yet handled value.
		**  Return "&#" verbatim and continue
		**  from there. - FM
		*/
d1849 1
a1849 1
		    *(p-1) = cpe;
d1857 2
a1858 2
		!(HTPassEightBitRaw &&
		 UCH(*p) >= lowest_8)) {
d1881 10
a1890 10
	    **	Seek the Unicode value for the named entity.
	    **
	    **	!!!! We manually recover the case of '=' terminator which
	    **	is commonly found on query to CGI-scripts
	    **	enclosed as href= URLs like  "somepath/?x=1&yz=2"
	    **	Without this dirty fix, submission of such URLs was broken
	    **	if &yz string happened to be a recognized entity name. - LP
	    */
	   if ( ((code = HTMLGetEntityUCValue(name)) > 0) &&
		!((cpe == '=') && (stype == st_URL)) ) {
d1895 2
a1896 3
	    **	Didn't find the entity.
	    **	Return verbatim.
	    */
d1900 1
a1900 1
				/* * * O U T P U T   S T A T E S * * */
d1927 1
a1927 1
		code = replace_buf[0]; /* assume string OK if first char is */
d1955 2
a1956 2
	    /*	Not a full HTEscape, only for 8bit and ctrl chars */
		(TOASCII(code) >= 127 ||  /* S/390 -- gil -- 1925 */
d1958 2
a1959 2
		    state = S_put_urlchar;
		    break;
d1961 1
a1961 1
		       && q != qs && *(q-1) == 13) {
d1963 4
a1966 4
		**  If this is not a hidden string, and the current char is
		**  the LF ('\n') of a CRLF pair, drop the CR ('\r'). - KW
		*/
		*(q-1) = *p++;
d1970 1
a1970 1
	    *q++ = (char)code;
d1975 1
a1975 1
	    REPLACE_CHAR(hex[(TOASCII(code) >> 4) & 15]);  /* S/390 -- gil -- 1944 */
d1977 1
a1977 1
				/* fall through */
d1983 1
a1983 1
				/* for next round */
d1989 1
a1989 1
	HTChunkPutb(CHUNK, qs, q-qs + 1); /* also terminates */
d2008 7
a2014 8
BOOL LYUCTranslateHTMLString (
	char ** str,
	int	cs_from,
	int	cs_to,
	BOOL	use_lynx_specials,
	BOOLEAN	plain_space,
	BOOLEAN	hidden,
	CharUtil_st	stype)
d2017 1
d2020 2
a2021 2
				    use_lynx_specials, plain_space, hidden,
				    NO, stype)) {
d2027 4
a2030 5
BOOL LYUCTranslateBackFormData (
	char ** str,
	int	cs_from,
	int	cs_to,
	BOOLEAN	plain_space)
d2032 2
a2033 1
    char ** ret;
d2036 2
a2037 2
				       NO, plain_space, YES,
				       YES, st_HTML));
d2044 2
a2045 3
char *LYParseTagParam (
	char *		from,
	char *		name)
d2057 2
a2058 1
	if (strlen(string) < len) return NULL;
d2075 3
a2077 4
    if (len > 2 && result[0] == '\'' && result[len-1] == result[0]) {
	result[len-1] = '\0';
	for (string = result; (string[0] = string[1]) != '\0'; ++string)
	    ;
d2086 3
a2088 4
void LYParseRefreshURL (
	char *		content,
	char **	p_seconds,
	char **	p_address)
d2095 1
a2095 1
     *  Look for the Seconds field. - FM
d2107 3
a2109 2
    CTRACE((tfp, "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
	   content, NonNull(*p_seconds), NonNull(*p_address)));
d2113 5
a2117 7
**  This function processes META tags in HTML streams. - FM
*/
void LYHandleMETA (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	char **		include GCC_UNUSED)
d2128 1
a2128 1
     *	Load the attributes for possible use by Lynx. - FM
d2135 1
a2135 1
				 NO, NO, YES, st_other);
d2145 1
a2145 1
				 NO, NO, YES, st_other);
d2153 7
a2159 9
	 *  Technically, we should be creating a comma-separated
	 *  list, but META tags come one at a time, and we'll
	 *  handle (or ignore) them as each is received.  Also,
	 *  at this point, we only trim leading and trailing
	 *  blanks from the CONTENT value, without translating
	 *  any named entities or numeric character references,
	 *  because how we should do that depends on what type
	 *  of information it contains, and whether or not any
	 *  of it might be sent to the screen. - FM
d2169 5
a2173 4
    CTRACE((tfp, "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
		(http_equiv ? http_equiv : "NULL"),
		(name ? name : "NULL"),
		(content ? content : "NULL")));
d2176 1
a2176 1
     *	Make sure we have META name/value pairs to handle. - FM
d2188 1
a2188 1
				 NO, NO, YES, st_other);
d2195 3
a2197 5
	 *  If we didn't get a Cache-Control MIME header,
	 *  and the META has one, convert to lowercase,
	 *  store it in the anchor element, and if we
	 *  haven't yet set no_cache, check whether we
	 *  should. - FM
d2243 3
a2245 3
    /*
     * Check for an Expires directive. - FM
     */
d2248 5
a2252 8
	 *  If we didn't get an Expires MIME header,
	 *  store it in the anchor element, and if we
	 *  haven't yet set no_cache, check whether we
	 *  should.  Note that we don't accept a Date
	 *  header via META tags, because it's likely
	 *  to be untrustworthy, but do check for a
	 *  Date header from a server when making the
	 *  comparison. - FM
d2255 1
a2255 1
				 NO, NO, YES, st_other);
d2260 2
a2261 2
		 *  The value is zero, which we treat as
		 *  an absolute no-cache directive. - FM
d2267 2
a2268 3
		 *  We have a Date header, so check if
		 *  the value is less than or equal to
		 *  that. - FM
d2277 2
a2278 2
		 *  We don't have a Date header, and
		 *  the value is in past for us. - FM
d2285 4
a2288 5
    /*
     *	Check for a text/html Content-Type with a
     *	charset directive, if we didn't already set
     *	the charset via a server's header. - AAC & FM
     */
d2291 3
a2293 2
	LYUCcharset * p_in = NULL;
	LYUCcharset * p_out = NULL;
d2295 1
a2295 1
				 NO, NO, YES, st_other);
d2307 1
a2307 1
	    StrAllocCopy(cp3, cp1); /* copy to mutilate more */
d2309 1
a2309 1
			     *cp4 != ';'  && *cp4 != ':' &&
d2311 1
a2311 1
		; /* do nothing */
d2319 1
a2319 1
	    if (Switch_Display_Charset (chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
d2324 1
d2329 1
a2329 1
					UCT_SETBY_MIME); /* highest priorty! */
d2333 1
a2333 1
					UCT_SETBY_MIME); /* highest priorty! */
d2348 1
a2348 1
		 *  Got something but we don't recognize it.
d2351 2
a2352 2
		if (chndl < 0) /* UCLYhndl_for_unrec not defined :-( */
		     chndl = UCLYhndl_for_unspec; /* always >= 0 */
d2369 1
a2369 1
		     *	Try again.
d2377 4
a2380 4
				HTAnchor_getUCLYhndl(me->node_anchor,
						     UCT_STAGE_HTEXT),
						     UCT_STAGE_PARSER,
						     UCT_SETBY_DEFAULT);
d2385 2
a2386 2
				HTAnchor_getUCLYhndl(me->node_anchor,
						     UCT_STAGE_PARSER),
d2390 5
a2394 1
		if (p_in->enc != UCT_ENC_CJK) {
d2406 3
a2408 4
		**  Update the chartrans info homologously to
		**  a Content-Type MIME header with a charset
		**  parameter. - FM
		*/
d2426 16
a2441 20
		 *  Cannot translate.
		 *  If according to some heuristic the given
		 *  charset and the current display character
		 *  both are likely to be like ISO-8859 in
		 *  structure, pretend we have some kind
		 *  of match.
		 */
		BOOL given_is_8859
		    = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		       isdigit(UCH(cp4[9])));
		BOOL given_is_8859like
		    = (BOOL) (given_is_8859 || !strncmp(cp4, "windows-", 8) ||
			!strncmp(cp4, "cp12", 4) ||
			!strncmp(cp4, "cp-12", 5));
		BOOL given_and_display_8859like
		    = (BOOL) (given_is_8859like &&
		       (strstr(LYchar_set_names[current_char_set],
			       "ISO-8859") ||
			strstr(LYchar_set_names[current_char_set],
			       "windows-")));
d2466 1
a2466 1
	 *  Set the kcode element based on the charset. - FM
d2470 3
a2472 3
    /*
     *	Check for a Refresh directive. - FM
     */
d2481 1
a2481 1
		 *  We found a URL field, so check it out. - FM
d2485 3
a2487 3
		     *	The specs require a complete URL,
		     *	but this is a Netscapism, so don't
		     *	expect the author to know that. - FM
d2491 1
a2491 2
		     *	Use the document's address
		     *	as the base. - FM
d2505 1
a2505 1
		     *  Check whether to fill in localhost. - FM
d2508 2
a2509 2
				   (me->inBASE ?
				 me->base_href : me->node_anchor->address));
d2513 2
a2514 2
		 *  Set the no_cache flag if the Refresh URL
		 *  is the same as the document's address. - FM
d2521 2
a2522 3
		 *  We didn't find a URL field, so use
		 *  the document's own address and set
		 *  the no_cache flag. - FM
d2528 1
a2528 1
	     *	Check for an anchor in http or https URLs. - FM
d2542 3
a2544 4
		 *  Ugh!  The META tag, which is a HEAD element,
		 *  is in an Anchor, which is BODY element.  All
		 *  we can do is close the Anchor and cross our
		 *  fingers. - FM
d2554 4
a2557 4
				me->node_anchor,	/* Parent */
				id_string,		/* Tag */
				href,			/* Addresss */
				(void *)0);		/* Type */
d2583 5
a2587 5
    /*
     *	Check for a suggested filename via a Content-Disposition with
     *	a filename=name.suffix in it, if we don't already have it
     *	via a server header. - FM
     */
d2624 3
a2626 3
    /*
     *	Check for a Set-Cookie directive. - AK
     */
d2629 3
a2631 3
	 *  This will need to be updated when Set-Cookie/Set-Cookie2
	 *  handling is finalized.  For now, we'll still assume
	 *  "historical" cookies in META directives. - FM
d2634 1
a2634 1
		       me->base_href : me->node_anchor->address);
d2639 1
a2639 1
		      me->base_href : me->node_anchor->address));
d2644 1
a2644 1
     *	Free the copies. - FM
d2646 1
a2646 1
free_META_copies:
d2653 13
a2665 15
**  This function handles P elements in HTML streams.
**  If start is TRUE it handles a start tag, and if
**  FALSE, an end tag.	We presently handle start
**  and end tags identically, but this can lead to
**  a different number of blank lines between the
**  current paragraph and subsequent text when a P
**  end tag is present or not in the markup. - FM
*/
void LYHandlePlike (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	char **		include GCC_UNUSED,
	int			align_idx,
	BOOL			start)
d2669 5
a2673 5
	 *  FIG content should be a true block, which like P inherits
	 *  the current style.	APPLET is like character elements or
	 *  an ALT attribute, unless it content contains a block element.
	 *  If we encounter a P in either's content, we set flags to treat
	 *  the content as a block.  - FM
d2686 3
a2688 4
	     *	We're in a list.  Treat P as an instruction to
	     *	create one blank line, if not already present,
	     *	then fall through to handle attributes, with
	     *	the "second line" margins. - FM
d2702 3
a2704 3
	     *	We're in an ADDRESS.  Treat P as an instruction
	     *	to start a newline, if needed, then fall through
	     *	to handle attributes. - FM
d2707 1
a2707 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d2727 3
a2729 3
			(me->sp->style->id == ST_DivCenter ||
			 me->sp->style->id == ST_DivLeft ||
			 me->sp->style->id == ST_DivRight)) ||
d2731 3
a2733 3
			(me->sp->style->id == ST_Normal ||
			 me->sp->style->id == ST_Preformatted))) {
		me->sp->style->alignment = HT_LEFT;
d2744 1
a2744 1
		    !(me->List_Nesting_Level >= 0 && !me->inP))
d2754 2
a2755 3
	 *  Mark that we are starting a new paragraph
	 *  and don't have any of it's text yet. - FM
	 *
d2764 8
a2771 10
**  This function handles SELECT elements in HTML streams.
**  If start is TRUE it handles a start tag, and if FALSE,
**  an end tag. - FM
*/
void LYHandleSELECT (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	char **		include GCC_UNUSED,
	BOOL			start)
d2781 1
a2781 1
	 *  Initialize the disable attribute.
d2786 1
a2786 1
	 *  Make sure we're in a form.
d2794 7
a2800 6
	     *	We should have covered all crash possibilities with the
	     *	current TagSoup parser, so we'll allow it because some
	     *	people with other browsers use SELECT for "information"
	     *	popups, outside of FORM blocks, though no Lynx user
	     *	would do anything that awful, right? - FM
	     *//***
d2806 1
a2806 1
	 *  Check for unclosed TEXTAREA.
d2814 1
a2814 1
	 *  Set to know we are in a select tag.
d2819 1
a2819 1
	      value[HTML_SELECT_NAME]  && *value[HTML_SELECT_NAME])) {
d2828 1
a2828 1
	    multiple=YES;
d2834 1
a2834 1
	     *	Let the size be determined by the number of OPTIONs. - FM
d2837 1
a2837 1
			value[HTML_SELECT_SIZE]));
d2857 5
a2861 6
	     *	Force a newline when we're using a popup in
	     *	a PRE block and are within 7 columns from the
	     *	right margin.  This will allow for the '['
	     *	popup designator and help avoid a wrap in the
	     *	underscore placeholder for the retracted popup
	     *	entry in the HText structure. - FM
d2867 1
a2867 1
	LYCheckForID(me, present, value, (int)HTML_SELECT_ID);
d2876 1
a2876 1
	 *  Handle end tag.
d2881 1
a2881 1
	 *  Make sure we had a select start tag.
d2890 1
a2890 1
	 *  Set to know that we are no longer in a select tag.
d2895 1
a2895 1
	 *  Clear the disable attribute.
d2900 1
a2900 1
	 *  Finish the data off.
d2904 1
a2904 1
	 *  Finish the previous option.
d2920 1
a2920 1
	     *	Start a newline after the last checkbox/button option.
d2925 2
a2926 2
	     *	Output popup box with the default option to screen,
	     *	but use non-breaking spaces for output.
d2931 3
a2933 3
		 *  The code inadequately handles OPTION fields in PRE tags.
		 *  We'll put up a minimum of 6 characters, and if any
		 *  more would exceed the wrap column, we'll ignore them.
d2951 1
a2951 1
	     *	Add end option character.
d2975 9
a2983 11
**  This function strips white characters and
**  generally fixes up attribute values that
**  were received from the SGML parser and
**  are to be treated as partial or absolute
**  URLs. - FM
*/
int LYLegitimizeHREF (
	HTStructured *		me,
	char **		href,
	BOOL			force_slash,
	BOOL			strip_dots)
d2991 1
a2991 1
	return(url_type);
d2995 4
a2998 5
	 *  Collapse spaces in the actual URL, but just
	 *  protect against tabs or newlines in the
	 *  fragment, if present.  This seeks to cope
	 *  with atrocities inflicted on the Web by
	 *  authoring tools such as Frontpage. - FM
d3002 1
a3002 2
	for (p = *href; (*p && !isspace(*p)); p++)
	    ;
d3004 2
a3005 2
	if (*p) {  /* p == first space character */
		   /* no reallocs below, all converted in place */
d3010 1
a3010 1
		convert_to_spaces(p, FALSE);  /* done */
d3014 1
a3014 1
		    *pound = '\0';  /* mark */
d3023 1
a3023 1
		    LYRemoveBlanks(p);  /* a compromise... */
d3028 1
a3028 1
		    *pound = '#';  /* restore */
d3037 1
a3037 1
	return(url_type);
d3042 1
a3042 1
		me->base_href : me->node_anchor->address;
d3047 1
a3047 1
	 !isFILE_URL(Base)) {
d3049 5
a3053 6
	 *  The Fielding RFC/ID for resolving partial HREFs says
	 *  that a slash should be on the end of the preceding
	 *  symbolic element for "." and "..", but all tested
	 *  browsers only do that for an explicit "./" or "../",
	 *  so we'll respect the RFC/ID only if force_slash was
	 *  TRUE and it's not a file URL. - FM
d3058 1
a3058 1
	 !strncasecomp(Base, "http", 4)) {
d3060 11
a3070 12
	 *  We will be resolving a partial reference versus an http
	 *  or https URL, and it has lead dots, which may be retained
	 *  when resolving via HTParse(), but the request would fail
	 *  if the first element of the resultant path is two dots,
	 *  because no http or https server accepts such paths, and
	 *  the current URL draft, likely to become an RFC, says that
	 *  it's optional for the UA to strip them as a form of error
	 *  recovery.  So we will, recursively, for http/https URLs,
	 *  like the "major market browsers" which made this problem
	 *  so common on the Web, but we'll also issue a message about
	 *  it, such that the bad partial reference might get corrected
	 *  by the document provider. - FM
d3076 1
a3076 1
	path = HTParse(temp, "", PARSE_PATH+PARSE_PUNCTUATION);
d3083 2
a3084 1
		CTRACE((tfp, "LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
d3111 1
a3111 1
    return(url_type);
d3115 7
a3121 8
**  This function checks for a Content-Base header,
**  and if not present, a Content-Location header
**  which is an absolute URL, and sets the BASE
**  accordingly.  If set, it will be replaced by
**  any BASE tag in the HTML stream, itself. - FM
*/
void LYCheckForContentBase (
	HTStructured *		me)
d3133 1
a3133 2
	 *  We have a Content-Base value.  Use it
	 *  if it's non-zero length. - FM
d3141 2
a3142 3
	 *  We didn't have a Content-Base value, but do
	 *  have a Content-Location value.  Use it if
	 *  it's an absolute URL. - FM
d3154 1
a3154 2
	 *  We had neither a Content-Base nor
	 *  Content-Location value. - FM
d3160 1
a3160 2
     *	If we collapsed to a zero-length value,
     *	ignore it. - FM
d3168 1
a3168 2
     *	Pass the value to HTML_start_element as
     *	the HREF of a BASE tag. - FM
d3171 1
a3171 1
	 present[i] = NO;
d3173 3
a3175 3
    value[HTML_BASE_HREF] = (const char *)cp;
    (*me->isa->start_element)(me, HTML_BASE, present, value,
			      0, 0);
d3180 6
a3185 8
**  This function creates NAMEd Anchors if a non-zero-length NAME
**  or ID attribute was present in the tag. - FM
*/
void LYCheckForID (
	HTStructured *		me,
	const BOOL *		present,
	const char **		value,
	int			attribute)
d3196 1
a3196 1
	 *  Translate any named or numeric character references. - FM
d3200 1
a3200 1
				 NO, NO, YES, st_URL);
d3203 1
a3203 1
	 *  Create the link if we still have a non-zero-length string. - FM
d3207 4
a3210 4
				me->node_anchor,	/* Parent */
				temp,			/* Tag */
				NULL,			/* Addresss */
				(void *)0))) {		/* Type */
d3219 5
a3223 7
**  This function creates a NAMEd Anchor for the ID string
**  passed to it directly as an argument.  It assumes the
**  does not need checking for character references. - FM
*/
void LYHandleID (
	HTStructured *		me,
	const char *		id)
d3232 1
a3232 1
     *	Create the link if we still have a non-zero-length string. - FM
d3235 4
a3238 4
				me->node_anchor,	/* Parent */
				id,			/* Tag */
				NULL,			/* Addresss */
				(void *)0)) != NULL) {	/* Type */
d3245 6
a3250 7
**  This function checks whether we want to override
**  the current default alignment for paragraphs and
**  instead use that specified in the element's style
**  sheet. - FM
*/
BOOLEAN LYoverride_default_alignment (
	HTStructured * me)
d3255 8
a3262 8
    switch(me->sp[0].tag_number) {
	case HTML_BLOCKQUOTE:
	case HTML_BQ:
	case HTML_NOTE:
	case HTML_FN:
	case HTML_ADDRESS:
	    me->sp->style->alignment = HT_LEFT;
	    return YES;
d3264 2
a3265 2
	default:
	    break;
d3271 5
a3275 6
**  This function inserts newlines if needed to create double spacing,
**  and sets the left margin for subsequent text to the second line
**  indentation of the current style. - FM
*/
void LYEnsureDoubleSpace (
	HTStructured * me)
d3281 1
a3281 1
	HText_setLastChar(me->text, ' ');  /* absorb white space */
d3285 1
a3285 1
	HText_setLastChar(me->text, ' ');  /* absorb white space */
d3295 5
a3299 6
**  This function inserts a newline if needed to create single spacing,
**  and sets the left margin for subsequent text to the second line
**  indentation of the current style. - FM
*/
void LYEnsureSingleSpace (
	HTStructured * me)
d3305 1
a3305 1
	HText_setLastChar(me->text, ' ');  /* absorb white space */
d3315 4
a3318 5
**  This function resets paragraph alignments for block
**  elements which do not have a defined style sheet. - FM
*/
void LYResetParagraphAlignment (
	HTStructured * me)
d3335 18
a3352 19
**  This example function checks whether the given anchor has
**  an address with a file scheme, and if so, loads it into the
**  the SGML parser's context->url element, which was passed as
**  the second argument.  The handle_comment() calling function in
**  SGML.c then calls LYDoCSI() in LYUtils.c to insert HTML markup
**  into the corresponding stream, homologously to an SSI by an
**  HTTP server. - FM
**
**  For functions similar to this but which depend on details of
**  the HTML handler's internal data, the calling interface should
**  be changed, and functions in SGML.c would have to make sure not
**  to call such functions inappropriately (e.g., calling a function
**  specific to the Lynx_HTML_Handler when SGML.c output goes to
**  some other HTStructured object like in HTMLGen.c), or the new
**  functions could be added to the SGML.h interface.
*/
BOOLEAN LYCheckForCSI (
	HTParentAnchor *	anchor,
	char **		url)
d3368 22
a3389 23
**  This function is called from the SGML parser to look at comments
**  and see whether we should collect some info from them.  Currently
**  it only looks for comments with Message-Id and Subject info, in the
**  exact form generated by MHonArc for archived mailing list.  If found,
**  the info is stored in the document's HTParentAnchor.  It can later be
**  used for generating a mail response.
**
**  We are extra picky here because there isn't any official definition
**  for these kinds of comments - we might (and still can) misinterpret
**  arbitrary comments as something they aren't.
**
**  If something doesn't look right, for example invalid characters, the
**  strings are not stored.  Mail responses will use something else as
**  the subject, probably the document URL, and will not have an
**  In-Reply-To header.
**
**  All this is a hack - to do this the right way, mailing list archivers
**  would have to agree on some better mechanism to make this kind of info
**  from original mail headers available, for example using LINK.  - kw
*/
BOOLEAN LYCommentHacks (
	HTParentAnchor *	anchor,
	const char *		comment)
d3403 2
a3404 1
	for (cp = comment+17; *cp; cp++) {
d3431 2
a3432 2
	if ((len = strlen(p)) >= 8 && !strcmp(&p[len-3], " --")) {
	    p[len-3] = '\0';
d3448 2
a3449 1
	for (cp = comment+14; *cp; cp++) {
d3477 2
a3478 2
	if ((len = strlen(p)) >= 4 && !strcmp(&p[len-3], " --")) {
	    p[len-3] = '\0';
d3496 2
a3497 3
     *	Create the Title with any left-angle-brackets
     *	converted to &lt; entities and any ampersands
     *	converted to &amp; entities.  - FM
d3499 6
a3504 7
     *  Convert 8-bit letters to &#xUUUU to avoid dependencies
     *  from display character set which may need changing.
     *  Do NOT convert any 8-bit chars if we have CJK display. - LP
     */
void LYformTitle (
	char **	dst,
	const char *	src)
d3508 2
a3509 1
	if ((tmp_buffer = (char *) malloc (strlen(src)+1)) == 0)
d3511 1
a3511 1
	switch(kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
@


1.4
log
@First step of lynx-2.8.5-dev16c merger
@
text
@d44 2
a45 2
PUBLIC int OL_CONTINUE = -29999;     /* flag for whether CONTINUE is set */
PUBLIC int OL_VOID = -29998;	     /* flag for whether a count is set */
d53 3
a55 3
PUBLIC void LYEntify ARGS2(
	char **,	str,
	BOOLEAN,	isTITLE)
d227 2
a228 2
PUBLIC void LYTrimHead ARGS1(
	char *, str)
d230 1
a230 1
    CONST char *s = str;
d251 2
a252 2
PUBLIC void LYTrimTail ARGS1(
	char *, str)
d275 2
a276 2
PUBLIC char *LYFindEndOfComment ARGS1(
	char *, str)
d388 3
a390 3
PUBLIC void LYFillLocalFileURL ARGS2(
	char **,	href,
	CONST char *,	base)
d445 1
a445 1
	CONST char *temp2;
d506 3
a508 3
PUBLIC void LYAddMETAcharsetToFD ARGS2(
	FILE *,		fd,
	int,		disp_chndl)
d548 2
a549 2
PUBLIC char *LYUppercaseA_OL_String ARGS1(
	int, seqnum)
d580 2
a581 2
PUBLIC char *LYLowercaseA_OL_String ARGS1(
	int, seqnum)
d613 2
a614 2
PUBLIC char *LYUppercaseI_OL_String ARGS1(
	int, seqnum)
d748 2
a749 2
PUBLIC char *LYLowercaseI_OL_String ARGS1(
	int, seqnum)
d881 2
a882 2
PUBLIC void LYZero_OL_Counter ARGS1(
	HTStructured *,		me)
d903 2
a904 2
PUBLIC void LYGetChartransInfo ARGS1(
	HTStructured *,		me)
d936 1
a936 1
PRIVATE char * UCPutUtf8ToBuffer ARGS3(char *, q, UCode_t, code, BOOL, terminate)
d980 1
a980 1
PRIVATE CONST char *hex = "0123456789ABCDEF";
d1051 1
a1051 1
**		    extern void LYExpandString PARAMS((
d1053 2
a1054 2
**		       char **		       str));
**		    extern void LYUnEscapeEntities PARAMS((
d1056 2
a1057 2
**		       char **		       str));
**		    extern void LYUnEscapeToLatinOne PARAMS((
d1060 1
a1060 1
**		       BOOLEAN		       isURL));
d1063 10
a1072 10
PUBLIC char ** LYUCFullyTranslateString ARGS9(
	char **,	str,
	int,		cs_from,
	int,		cs_to,
	BOOLEAN,	do_ent,
	BOOL,		use_lynx_specials,
	BOOLEAN,	plain_space,
	BOOLEAN,	hidden,
	BOOL,		Back,
	CharUtil_st,	stype)
d1087 1
a1087 1
    CONST char * name = NULL;
d2002 8
a2009 8
PUBLIC BOOL LYUCTranslateHTMLString ARGS7(
	char **, str,
	int,	cs_from,
	int,	cs_to,
	BOOL,	use_lynx_specials,
	BOOLEAN,	plain_space,
	BOOLEAN,	hidden,
	CharUtil_st,	stype)
d2021 5
a2025 5
PUBLIC BOOL LYUCTranslateBackFormData ARGS4(
	char **, str,
	int,	cs_from,
	int,	cs_to,
	BOOLEAN,	plain_space)
d2038 3
a2040 3
PUBLIC char *LYParseTagParam ARGS2(
	char *,		from,
	char *,		name)
d2081 4
a2084 4
PUBLIC void LYParseRefreshURL ARGS3(
	char *,		content,
	char **,	p_seconds,
	char **,	p_address)
d2110 5
a2114 5
PUBLIC void LYHandleMETA ARGS4(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	char **,		include GCC_UNUSED)
d2668 7
a2674 7
PUBLIC void LYHandlePlike ARGS6(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	char **,		include GCC_UNUSED,
	int,			align_idx,
	BOOL,			start)
d2779 6
a2784 6
PUBLIC void LYHandleSELECT ARGS5(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	char **,		include GCC_UNUSED,
	BOOL,			start)
d2994 5
a2998 5
PUBLIC int LYLegitimizeHREF ARGS4(
	HTStructured *,		me,
	char **,		href,
	BOOL,			force_slash,
	BOOL,			strip_dots)
d3003 1
a3003 1
    CONST char *Base = NULL;
d3092 1
a3092 1
	CONST char *str = "";
d3139 2
a3140 2
PUBLIC void LYCheckForContentBase ARGS1(
	HTStructured *,		me)
d3144 1
a3144 1
    CONST char *value[HTML_BASE_ATTRIBUTES];
d3197 1
a3197 1
    value[HTML_BASE_HREF] = (CONST char *)cp;
d3207 5
a3211 5
PUBLIC void LYCheckForID ARGS4(
	HTStructured *,		me,
	CONST BOOL *,		present,
	CONST char **,		value,
	int,			attribute)
d3249 3
a3251 3
PUBLIC void LYHandleID ARGS2(
	HTStructured *,		me,
	CONST char *,		id)
d3278 2
a3279 2
PUBLIC BOOLEAN LYoverride_default_alignment ARGS1(
	HTStructured *, me)
d3304 2
a3305 2
PUBLIC void LYEnsureDoubleSpace ARGS1(
	HTStructured *, me)
d3329 2
a3330 2
PUBLIC void LYEnsureSingleSpace ARGS1(
	HTStructured *, me)
d3349 2
a3350 2
PUBLIC void LYResetParagraphAlignment ARGS1(
	HTStructured *, me)
d3383 3
a3385 3
PUBLIC BOOLEAN LYCheckForCSI ARGS2(
	HTParentAnchor *,	anchor,
	char **,		url)
d3421 3
a3423 3
PUBLIC BOOLEAN LYCommentHacks ARGS2(
	HTParentAnchor *,	anchor,
	CONST char *,		comment)
d3425 1
a3425 1
    CONST char *cp = comment;
d3536 3
a3538 3
void LYformTitle ARGS2(
	char **,	dst,
	CONST char *,	src)
d3546 1
a3546 1
	    TO_EUC((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
d3549 1
a3549 1
	    TO_SJIS((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d2061 1
a2061 1
    while (isprint(UCH(string[len])) && string[len] != ';') {
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a27 1
#include <HTFont.h>
a40 7
extern BOOL HTPassEightBitRaw;
extern BOOL HTPassEightBitNum;
extern BOOL HTPassHighCtrlRaw;
extern BOOL HTPassHighCtrlNum;
extern HTkcode kanji_code;
extern HTCJKlang HTCJK;

d60 6
d67 1
a67 1
    if (p == NULL || *p == '\0')
d109 2
a110 2
    q = (char *)calloc(1,
		     (strlen(*str) + (4 * amps) + (3 * lts) + (3 * gts) + 1));
d114 83
d217 3
a219 2
    StrAllocCopy(*str, cp);
    FREE(cp);
d230 1
a230 1
    int i = 0, j;
d232 1
a232 1
    if (!str || *str == '\0')
d235 6
a240 5
    while (str[i] != '\0' && WHITE(str[i]) && (unsigned char)str[i] != (unsigned char)CH_ESC)   /* S/390 -- gil -- 1669 */
	i++;
    if (i > 0) {
	for (j = 0; str[i] != '\0'; i++) {
	    str[j++] = str[i];
d242 1
a242 1
	str[j] = '\0';
d256 1
a256 1
    if (!str || *str == '\0')
d259 1
a259 1
    i = (strlen(str) - 1);
d357 1
a357 1
		} else if (!(WHITE(*cp) && (unsigned char)*cp != (unsigned char)CH_ESC)) {  /* S/390 -- gil -- 1686 */
d390 1
a390 1
	CONST char *, 	base)
d394 1
a394 1
    if (*href == NULL || *(*href) == '\0')
d398 2
a399 2
	if (base != NULL && !strncmp(base, "file:", 5)) {
	    StrAllocCopy(temp, "file:");
d404 1
a404 1
    if (!strncmp(*href, "file:", 5)) {
d418 2
a419 2
#if defined(DOSPATH) || defined(__EMX__)
    if (isalpha(*(*href)) && (*(*href+1) == ':'))  {
d431 1
a431 2
	  && isalpha(*(*href+17))
	  && (*(*href+18) == ':')) {
d436 1
a436 1
	StrAllocCat(*href, "/");
d438 1
a438 1
#endif /* DOSPATH */
d445 1
a445 1
	char *temp2;
d447 1
a447 1
	temp2 = HTVMS_wwwName(getenv("PATH"));
d452 2
a453 1
	LYAddHtmlSep(href);
d473 1
a473 1
	StrAllocCat(*href, (HTVMS_wwwName((char *)Home_Dir())+1));
d507 1
a507 1
	FILE *, 	fd,
d611 1
d616 1
a616 1
    static char OLstring[8];
d746 1
d751 1
a751 1
    static char OLstring[8];
d882 1
a882 1
	HTStructured *, 	me)
d904 1
a904 1
	HTStructured *, 	me)
a926 618
#ifdef NOTUSED_FOTEMODS
/*
**  This function reallocates an allocated string and converts
**  characters for the current display character set.  It assumes
**  that invalid control characters have been dealt with by the
**  SGML (or other initial) parser of the document input stream
**  (i.e., are present only if elements or global flags have been
**  set to allow them), and that otherwise this is a copy of the
**  string with the charset of the input stream.  It handles Lynx
**  special characters based on the 'me' structure's element values
**  (the me->UsePlainSpace and me->HiddenValue elements, and its
**  chartrans related elements), and calls to other functions which
**  return structure element values.  HTChunk functions are used to
**  keep memory allocations at a minimum. - FM
*/
PUBLIC void LYExpandString ARGS2(
	HTStructured *, 	me,
	char **,		str)
{
    char *p = *str;
    HTChunk *s;
    BOOLEAN plain_space, hidden;
    char c;
    unsigned char c_unsign;
    char saved_char_in = '\0';
    BOOLEAN chk;
    UCode_t code, uck;
    char replace_buf [64];
    char utf_buf[8], utf_count = 0;
    char *utf_buf_p = utf_buf;
    UCode_t utf_char = 0, value;
    CONST char *name;
    int i, j, high, low, diff = 0;

    /*
    **	Don't do anything if we have no structure
    **	or string, or are in CJK mode. - FM
    */
    if (!me || !p || *p == '\0' ||
	HTCJK != NOCJK)
	return;

    /*
    **	Set "convenience copies" of me structure
    **	elements. - FM
    */
    plain_space = me->UsePlainSpace;
    hidden = me->HiddenValue;

    /*
    **	Check for special input charsets - FM
    */
    if (!strcmp(me->inUCI->MIMEname, "x-transparent")) {
	/*
	**  Conversions not intended. - FM
	*/
	return;
    }
    if (!strcmp(me->inUCI->MIMEname, "mnemonic") ||
	!strcmp(me->inUCI->MIMEname, "mnemonic+ascii+0")) {
	/*
	**  All ASCII representations of Unicode characters,
	**  and we have no reverse translation code for the
	**  multibyte characters, so punt. - FM
	*/
	return;
    }
    if (me->inUCLYhndl < 0 || me->outUCLYhndl < 0) {
	/*
	**  The chartrans procedure failed, so we don't
	**  do anything, and hope for the best. - FM
	*/
	CTRACE(tfp, "LYExpandString: Bad in (%d) or out (%d) handle(s).\n",
		    me->inUCLYhndl, me->outUCLYhndl);
	return;
    }

    /*
    **	Zero the UTF-8 multibytes buffer. - FM
    */
    utf_buf[0] = utf_buf[6] = utf_buf[7] = '\0';

    /*
    **	Set up an HTChunk for accumulating the expanded copy
    **	of the string, so that allocations are done in 128
    **	byte increments, only as required. - FM
    */
    s = HTChunkCreate(128);

    /*
    **	Check each character in the original string,
    **	and add the characters or substitutions to
    **	our clean copy. - FM
    */
    for (i = 0; p[i]; i++) {
	/*
	**  Make sure the character is handled as Unicode
	**  whenever that's appropriate.  - FM
	*/
	c = p[i];
	c_unsign = (unsigned char)c;
	code = (UCode_t)c_unsign;
	saved_char_in = '\0';
	/*
	**  Combine any UTF-8 multibytes into Unicode
	**  to check for special characters. - FM
	*/
	if (me->T.decode_utf8) {
	    /*
	    **	Our input charset is UTF-8, so check
	    **	for non-ASCII characters. - FM
	    */
	    if (TOASCII(c_unsign) > 127) {  /* S/390 -- gil -- 1703 */
		/*
		**  We have an octet from a multibyte character. - FM
		*/
		if (utf_count > 0 && (c & 0xc0) == 0x80) {
		    /*
		    **	Adjust the UCode_t value, add the octet
		    **	to the buffer, and decrement the byte
		    **	count. - FM
		    */
		    utf_char = (utf_char << 6) | (c & 0x3f);
		    utf_count--;
		    *utf_buf_p = c;
		    utf_buf_p++;
		    if (utf_count == 0) {
			/*
			**  We have all of the bytes, so terminate
			**  the buffer and set 'code' to the UCode_t
			**  value. - FM
			*/
			*utf_buf_p = '\0';
			code = utf_char;
			/*
			**  Set up the monobyte character
			**  values or non-character flags
			**  and fall through. - FM
			*/
			if (code > 0 && code < 256) {
			    c = ((char)(code & 0xff));
			    c_unsign = (unsigned char)c;
			}
		    } else {
			/*
			**  Get the next byte. - FM
			*/
			continue;
		    }
		} else {
		    /*
		    **	Start handling a new multibyte character. - FM
		    */
		    utf_buf[0] = c;
		    utf_buf_p = &utf_buf[1];
		    if ((c & 0xe0) == 0xc0) {
			utf_count = 1;
			utf_char = (c & 0x1f);
		    } else if ((c & 0xf0) == 0xe0) {
			utf_count = 2;
			utf_char = (c & 0x0f);
		    } else if ((c & 0xf8) == 0xf0) {
			utf_count = 3;
			utf_char = (c & 0x07);
		    } else if ((c & 0xfc) == 0xf8) {
			utf_count = 4;
			utf_char = (c & 0x03);
		    } else if ((c & 0xfe) == 0xfc) {
			utf_count = 5;
			utf_char = (c & 0x01);
		    } else {
			/*
			**  We got garbage, even though it should
			**  have been filtered out by the SGML or
			**  input stream parser, so we'll ignore
			**  it. - FM
			*/
			utf_count = 0;
			utf_buf[0] = '\0';
			utf_buf_p = utf_buf;
		    }
		    /*
		    **	Get the next byte. - FM
		    */
		    continue;
		}
	    } else if (utf_count > 0) {
		/*
		**  Got an ASCII character when expecting
		**  UTF-8 multibytes, so ignore the buffered
		**  multibyte characters and fall through with
		**  the current ASCII character. - FM
		*/
		utf_count = 0;
		utf_buf[0] = '\0';
		utf_buf_p = utf_buf;
		code = (UCode_t)c_unsign;
	    } else {
		/*
		**  Got a valid ASCII character, so fall
		**  through with it. - FM
		*/
		code = (UCode_t)c_unsign;
	    }
	}
	/*
	**  Convert characters from non-UTF-8 charsets
	**  to Unicode (if appropriate). - FM
	*/
	if (!(me->T.decode_utf8 &&
	      (unsigned char)p[i] > 127)) {
#ifdef NOTDEFINED
	    if (me->T.strip_raw_char_in)
		saved_char_in = c;
#endif /* NOTDEFINED */
	    if (me->T.trans_to_uni &&
		(code >= LYlowest_eightbit[me->inUCLYhndl] ||
		 (code < 32 && code != 0 &&
		  me->T.trans_C0_to_uni))) {
		/*
		**  Convert the octet to Unicode. - FM
		*/
		code = (UCode_t)UCTransToUni(c, me->inUCLYhndl);
		if (code > 0) {
		    saved_char_in = c;
		    if (code < 256) {
			c = ((char)(code & 0xff));
			c_unsign = (unsigned char)c;
		    }
		}
	    } else if (code < ' ' && code != 0 &&  /* S/390 -- gil -- 1720 */
		       me->T.trans_C0_to_uni) {
		/*
		**  Quote from SGML.c:
		**	"This else if may be too ugly to keep. - KW"
		*/
		if (me->T.trans_from_uni &&
		    (((code = UCTransToUni(c, me->inUCLYhndl)) >= ' ') ||  /* S/390 -- gil -- 1737 */
		     (me->T.transp &&
		      (code = UCTransToUni(c, me->inUCLYhndl)) > 0))) {
		    saved_char_in = c;
		    if (code < 256) {
			c = ((char)(code & 0xff));
			c_unsign = (unsigned char)c;
		    }
		} else {
		    uck = -1;
		    if (me->T.transp) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->inUCLYhndl, NO);
		    }
		    if (!me->T.transp || uck < 0) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->outUCLYhndl, YES);
		    }
		    if (uck == 0) {
			continue;
		    } else if (uck < 0) {
			utf_buf[0] = '\0';
			code = (unsigned char)c;
		    } else {
			c = replace_buf[0];
			if (c && replace_buf[1]) {
			    HTChunkPuts(s, replace_buf);
			    continue;
			}
		    }
		    utf_buf[0] = '\0';
		    code = (unsigned char)c;
		} /*  Next line end of ugly stuff for C0. - KW */
	    } else {
		utf_buf[0] = '\0';
		code = (unsigned char)c;
	    }
	}
	/*
	**  Ignore low ISO 646 7-bit control characters
	**  if they sneaked through (should have been
	**  filtered by the parser). - FM
	*/
	if (code < ' ' &&  /* S/390 -- gil -- 1754 */
	    c != 9 && c != 10 && c != 13) {
	    continue;
	}
	/*
	**  Ignore 127 if we don't have HTPassHighCtrlRaw
	**  and it sneaked through (should have been
	**  filtered by the parser). - FM
	*/
	if (TOASCII(c) == 127 &&  /* S/390 -- gil -- 1771 */
	    !(me->T.transp ||
	      code >= LYlowest_eightbit[me->inUCLYhndl])) {
	    continue;
	}
	/*
	**  Ignore 8-bit control characters 128 - 159 if we don't
	**  have HTPassHighCtrlRaw set and they sneaked through
	**  (should have been filtered by the parser). - FM
	*/
	if (TOASCII(code) > 127 && TOASCII(code) < 160 &&  /* S/390 -- gil -- 1788 */
	    !(me->T.transp ||
	      code >= LYlowest_eightbit[me->inUCLYhndl])) {
	    continue;
	}
	/*
	**  For 160 (nbsp), substitute Lynx special character
	**  (or a space if plain_space or hidden is set) if
	**  HTPassHighCtrlRaw is not set. - FM
	*/
	if (code == CH_NBSP) {  /* S/390 -- gil -- 1805 */
	    if (!me->T.pass_160_173_raw) {
		if (plain_space || hidden) {
		    HTChunkPutc(s, ' ');
		} else {
		    HTChunkPutc(s, HT_NON_BREAK_SPACE);
		}
	    } else if (!me->T.output_utf8) {
		HTChunkPutc(s, ((char)(code & 0xff)));
	    } else if (me->T.decode_utf8 && *utf_buf) {
		HTChunkPuts(s, utf_buf);
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    } else {
		HTChunkPutUtf8Char(s, code);
	    }
	    continue;
	}
	/*
	**  For 173 (shy), substitute Lynx special character
	**  (or skip it if plain_space or hidden is set) if
	**  HTPassHighCtrlRaw is not set. - FM
	*/
	if (code == CH_SHY) {  /* S/390 -- gil -- 1822 */
	    if (!me->T.pass_160_173_raw) {
		if (!(plain_space || hidden)) {
		    HTChunkPutc(s, LY_SOFT_HYPHEN);
		}
	    } else if (!me->T.output_utf8) {
		HTChunkPutc(s, ((char)(code & 0xff)));
	    } else if (me->T.decode_utf8 && *utf_buf) {
		HTChunkPuts(s, utf_buf);
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    } else {
		HTChunkPutUtf8Char(s, code);
	    }
	    continue;
	}
	/*
	**  For 8194 (ensp), 8195 (emsp), or 8201 (thinsp), use
	**  an ASCII space (32) if plain_space or hidden is TRUE,
	**  otherwise use the Lynx special character. - FM
	*/
	if (code == 8194 || code == 8195 || code == 8201) {
	    if (plain_space || hidden) {
		HTChunkPutc(s, ' ');
	    } else {
		HTChunkPutc(s, HT_EN_SPACE);
	    }
	    if (me->T.decode_utf8 && *utf_buf) {
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    }
	    continue;
	}
	/*
	**  If we want the raw character, pass it now. - FM
	*/
	if (me->T.use_raw_char_in && saved_char_in) {
	    HTChunkPutc(s, saved_char_in);
	    continue;
	}
	/*
	**  Seek a translation from the chartrans tables.
	*/
	if ((chk = (me->T.trans_from_uni && code >= 160)) &&
	    (uck = UCTransUniChar(code, me->outUCLYhndl)) >= 32 &&
	    uck < 256 &&
	    (uck < 127 ||
	     uck >= LYlowest_eightbit[me->outUCLYhndl])) {
	    HTChunkPutc(s, ((char)(uck & 0xff)));
	    continue;
	} else if (chk &&
		   (uck == -4 ||
		    (me->T.repl_translated_C0 &&
		     uck > 0 && uck < ' ')) &&  /* S/390 -- gil -- 1839 */
		   /*
		   **  Not found; look for replacement string.
		   */
		   (uck = UCTransUniCharStr(replace_buf,
					    60, code,
					    me->outUCLYhndl,
					    0) >= 0)) {
	    /*
	    **	Got a replacement string.
	    */
	    HTChunkPuts(s, replace_buf);
	    continue;
	}
	/*
	**  If we want raw UTF-8, output that now. - FM
	*/
	if (me->T.output_utf8 &&
	    TOASCII(code) > 127 && code <= 0x7fffffffL) {  /* S/390 -- gil -- 1856 */
	    if (me->T.decode_utf8 && *utf_buf) {
		HTChunkPuts(s, utf_buf);
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    } else {
		HTChunkPutUtf8Char(s, code);
	    }
	    continue;
	}
	/*
	**  If it's any other (> 160) 8-bit character
	**  and we have not set HTPassEightBitRaw
	**  nor have the "ISO Latin 1" character set selected,
	**  back translate for our character set. - FM
	*/
	if (code > 160 && code < 256 &&
	     me->outUCLYhndl != LATIN1 &&
	     (!(HTPassEightBitRaw ||
		(me->T.do_8bitraw && !me->T.trans_from_uni)))) {
	    value = (code - 160);
	    name = HTMLGetEntityName(value);
	    for (low = 0, high = HTML_dtd.number_of_entities;
		 high > low;
		 diff < 0 ? (low = j+1) : (high = j)) {
		/*
		**  Binary search.
		*/
		j = (low + (high-low)/2);
		diff = strcmp(HTML_dtd.entity_names[j], name);
		if (diff == 0) {
		    HTChunkPuts(s, LYCharSets[me->outUCLYhndl][j]);
		    break;
		}
	    }
	    if (diff == 0) {
		continue;
	    }
	}
	/*
	**  If it's ASCII at this point, use it. - FM
	*/
	if (TOASCII(code) < 127 && code > 0) {  /* S/390 -- gil -- 1873 */
	    HTChunkPutc(s, ((char)(code & 0xff)));
	    continue;
	}
	/*
	**  At this point, if we should have translated, the
	**  translation has failed.  We should have sent UTF-8
	**  output to the parser already, but what the heck,
	**  try again. - FM
	*/
	if (me->T.output_utf8 && *utf_buf) {
	    HTChunkPuts(s, utf_buf);
	    utf_buf[0] == '\0';
	    utf_buf_p = utf_buf;
	    continue;
	}
#ifdef NOTDEFINED
	/*
	**  Check for a strippable koi8-r 8-bit character. - FM
	*/
	if (me->T.strip_raw_char_in &&
	    (unsigned char)saved_char_in >= 192 &&
	    (unsigned char)saved_char_in < 255 &&
	    saved_char_in) {
	    /*
	    **	KOI8 special: strip high bit, gives (somewhat) readable
	    **	ASCII or KOI7 - it was constructed that way! - KW
	    */
	    HTChunkPutc(s, (saved_char_in & 0x7f));
	    continue;
	}
#endif /* NOTDEFINED */
	/*
	**  Ignore 8204 (zwnj), 8205 (zwj)
	**  8206 (lrm), and 8207 (rlm),
	**  if we get to here. - FM
	*/
	if (code == 8204 || code == 8205 ||
	    code == 8206 || code == 8207) {
	    CTRACE(tfp, "LYExpandString: Ignoring '%ld'.\n", code);
	    if (me->T.decode_utf8 && *utf_buf) {
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    }
	    continue;
	}
	/*
	**  If we don't actually want the character,
	**  make it safe and output that now. - FM
	*/
	if ((c_unsign > 0 &&
	     c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
	    (me->T.trans_from_uni && !HTPassEightBitRaw)) {
	    /*
	    **	If we do not have the "7-bit approximations" as our
	    **	output character set (in which case we did it already)
	    **	seek a translation for that.  Otherwise, or if the
	    **	translation fails, use UHHH notation. - FM
	    */
	    if ((chk = (me->outUCLYhndl !=
			UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(code,
				      UCGetLYhndl_byMIME("us-ascii")))
				      >= ' ' && TOASCII(uck) < 127) {  /* S/390 -- gil -- 1890 */
		/*
		**  Got an ASCII character (yippey). - FM
		*/
		c = ((char)(uck & 0xff));
		HTChunkPutc(s, c);
		continue;
	    } else if ((uck == -4) &&
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						UCGetLYhndl_byMIME("us-ascii"),
						0) >= 0)) {
		/*
		**  Got a replacement string (yippey). - FM
		*/
		HTChunkPuts(s, replace_buf);
		continue;
	    } else {
		/*
		**  Out of luck, so use the UHHH notation (ugh). - FM
		*/
		sprintf(replace_buf, "U%.2lX", TOASCII(code));  /* S/390 -- gil -- 1907 */
		HTChunkPuts(s, replace_buf);
		continue;
	    }
	}
	/*
	**  If we get to here and have a monobyte character,
	**  pass it. - FM
	*/
	if (c_unsign > 0 && c_unsign < 256) {
	    HTChunkPutc(s, c);
	}
    }

    /*
    **	Terminate the expanded string,
    **	replace the original, and free
    **	the chunk. - FM
    */
    HTChunkTerminate(s);
    StrAllocCopy(*str, s->data);
    HTChunkFree(s);
}
#endif /* NOTUSED_FOTEMODS */

/*
** Get UCS character code for one character from UTF-8 encoded string.
**
** On entry:
**	*ppuni should point to beginning of UTF-8 encoding character
** On exit:
**	*ppuni is advanced to point to the last byte of UTF-8 sequence,
**		if there was a valid one; otherwise unchanged.
** returns the UCS value
** returns negative value on error (invalid UTF-8 sequence)
*/
PRIVATE UCode_t UCGetUniFromUtf8String ARGS1(char **, ppuni)
{
    UCode_t uc_out = 0;
    char * p = *ppuni;
    int utf_count, i;
    if (!(**ppuni&0x80))
	return (UCode_t) **ppuni; /* ASCII range character */
    else if (!(**ppuni&0x40))
	return (-1);		/* not a valid UTF-8 start */
    if ((*p & 0xe0) == 0xc0) {
	utf_count = 1;
    } else if ((*p & 0xf0) == 0xe0) {
	utf_count = 2;
    } else if ((*p & 0xf8) == 0xf0) {
	utf_count = 3;
    } else if ((*p & 0xfc) == 0xf8) {
	utf_count = 4;
    } else if ((*p & 0xfe) == 0xfc) {
	utf_count = 5;
    } else { /* garbage */
	return (-1);
    }
    for (p = *ppuni, i = 0; i < utf_count ; i++) {
	if ((*(++p) & 0xc0) != 0x80)
	    return (-1);
    }
    p = *ppuni;
    switch (utf_count) {
    case 1:
	uc_out = (((*p&0x1f) << 6) | (*(p+1)&0x3f));
	break;
    case 2:
	uc_out = (((((*p&0x0f) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f));
	break;
    case 3:
	uc_out = (((((((*p&0x07) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
	    | (*(p+3)&0x3f));
	break;
    case 4:
	uc_out = (((((((((*p&0x03) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f));
	break;
    case 5:
	uc_out = (((((((((((*p&0x01) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f)) << 6) | (*(p+5)&0x3f));
	break;
    }
    *ppuni = p + utf_count;
    return uc_out;
}

d1063 1
a1063 1
PRIVATE char ** LYUCFullyTranslateString_1 ARGS9(
d1101 6
d1111 1
a1111 1
    if (!str || *str == NULL || **str == '\0')
d1123 1
a1123 1
    **	are both iso-8859-1,
d1126 5
a1130 3
    no_bytetrans = ((cs_to <= 0 && cs_from == cs_to) ||
		    HTCJK != NOCJK);

d1132 3
a1134 4
    if (!no_bytetrans)
	no_bytetrans = (!use_lynx_specials && !Back &&
			UCNeedNotTranslate(cs_from, cs_to));

d1160 1
a1160 1
	from_is_utf8 = (LYCharSet_UC[cs_from].enc == UCT_ENC_UTF8);
d1165 1
a1165 1
	output_utf8 = (LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8 ||
d1167 1
a1167 1
	repl_translated_C0 = (LYCharSet_UC[cs_to].enc == UCT_ENC_8BIT_C0);
d1207 21
a1227 1
	    code = (unsigned char)(*p);
d1268 1
a1346 1
			*p = 160;
d1352 6
a1360 1
		    *p = 173;
d1366 6
d1379 1
a1379 1
		    *p = rev_c;
d1394 1
a1394 1
			code = (unsigned char)(*p);
d1413 1
a1413 1
		    code = (unsigned char)(*p);
a1414 8
#ifdef NOTUSED_FOTEMODS
	    } else if (T.strip_raw_char_in &&
		       (unsigned char)(*p) >= 0xc0 &&
		       (unsigned char)(*p) < 255) {
		code = ((*p & 0x7f));
		state = S_got_outchar;
		break;
#endif /* NOTUSED_FOTEMODS */
d1420 3
a1422 3
		    **	Substitute Lynx special character for
		    **	160 (nbsp) if use_lynx_specials is set.
		    */
d1442 2
a1443 2
		    (unsigned char)*(pp+2) < 127 &&
		    isxdigit((unsigned char)*(pp+2))) {
d1447 2
a1448 2
			   (unsigned char)*(pp+1) < 127 &&
			   isdigit((unsigned char)*(pp+1))) {
d1451 2
a1452 2
		} else if ((unsigned char)*pp < 127 &&
			   isalpha((unsigned char)*pp)) {
d1470 3
a1472 3
		while (*p && (unsigned char)*p < 127 &&
		       (what == P_hex ? isxdigit((unsigned char)*p) :
					isdigit((unsigned char)*p))) {
d1672 1
a1672 3
		    if (hidden) {
			;
		    } else if (plain_space) {
d1674 16
d1691 3
a1693 1
			code = HT_NON_BREAK_SPACE;
a1694 2
		    state = S_got_outchar;
		    break;
d1715 1
a1715 1
		    } else {
d1774 1
a1774 1
		    CTRACE(tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code);
d1803 16
d1827 1
d1832 13
a1844 13
		    /*
		    **	Illegal or not yet handled value.
		    **	Return "&#" verbatim and continue
		    **	from there. - FM
		    */
		    *q++ = '&';
		    *q++ = '#';
		    if (what == P_hex)
			*q++ = 'x';
		    if (cpe != '\0')
			*(p-1) = cpe;
		    p = cp;
		    state = S_done;
a1848 7
#ifdef NOTUSED_FOTEMODS
	    } else if (T.strip_raw_char_in &&
		(unsigned char)(*p) >= 0xc0 &&
		(unsigned char)(*p) < 255) {
		code = (((*p) & 0x7f));
		state = S_got_outchar;
#endif /* NOTUSED_FOTEMODS */
d1851 1
a1851 1
		 (unsigned char)(*p) >= lowest_8)) {
d1856 1
a1856 1
		code = (unsigned char)(*p);
d1863 2
a1864 2
	    while (*cp && (unsigned char)*cp < 127 &&
		   isalnum((unsigned char)*cp))
a1867 1
/*	    ppuni = cp - 1; */
d1984 1
a1984 1
	if (stype == st_URL) {
d1991 1
a1991 1
	if (stype == st_URL) {
d2002 1
a2002 1
PUBLIC BOOL LYUCFullyTranslateString ARGS7(
d2013 1
a2013 1
    if (!LYUCFullyTranslateString_1(str, cs_from, cs_to, TRUE,
d2029 1
a2029 1
    ret = (LYUCFullyTranslateString_1(str, cs_from, cs_to, FALSE,
d2032 73
a2104 1
    return (ret != NULL);
d2111 1
a2111 1
	HTStructured *, 	me,
d2131 1
a2131 1
	LYUCFullyTranslateString(&http_equiv, me->tag_charset, me->tag_charset,
a2132 2
	LYTrimHead(http_equiv);
	LYTrimTail(http_equiv);
d2141 1
a2141 1
	LYUCFullyTranslateString(&name, me->tag_charset, me->tag_charset,
a2142 2
	LYTrimHead(name);
	LYTrimTail(name);
d2168 1
a2168 1
    CTRACE(tfp, "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
d2171 1
a2171 1
		(content ? content : "NULL"));
d2183 3
a2185 3
    if (!strcasecomp((http_equiv ? http_equiv : ""), "Pragma") ||
	!strcasecomp((http_equiv ? http_equiv : ""), "Cache-Control")) {
	LYUCFullyTranslateString(&content, me->tag_charset, me->tag_charset,
a2186 2
	LYTrimHead(content);
	LYTrimTail(content);
d2200 1
a2200 1
	    !strcasecomp((http_equiv ? http_equiv : ""), "Cache-Control")) {
d2227 1
a2227 1
			if (isdigit((unsigned char)*cp)) {
d2229 1
a2229 1
			    while (isdigit((unsigned char)*cp))
d2246 1
a2246 1
    } else if (!strcasecomp((http_equiv ? http_equiv : ""), "Expires")) {
d2257 1
a2257 1
	LYUCFullyTranslateString(&content, me->tag_charset, me->tag_charset,
a2258 2
	LYTrimHead(content);
	LYTrimTail(content);
d2279 1
a2279 1
	    } else if (LYmktime(content, FALSE) <= 0) {
d2295 1
a2295 1
	       !strcasecomp((http_equiv ? http_equiv : ""), "Content-Type")) {
d2298 1
a2298 1
	LYUCFullyTranslateString(&content, me->tag_charset, me->tag_charset,
a2299 2
	LYTrimHead(content);
	LYTrimTail(content);
d2302 1
a2302 3
	if ((cp = strstr(content, "text/html;")) != NULL &&
	    (cp1 = strstr(content, "charset")) != NULL &&
	    cp1 > cp) {
d2320 23
d2434 2
a2435 2
		    = (!strncmp(cp4, "iso-8859-", 9) &&
		       isdigit((unsigned char)cp4[9]));
d2437 1
a2437 1
		    = (given_is_8859 || !strncmp(cp4, "windows-", 8) ||
d2441 1
a2441 1
		    = (given_is_8859like &&
d2450 1
a2450 1
			   isdigit((unsigned char)(*cp1)))
d2464 1
a2464 1
		CTRACE(tfp,
d2466 1
a2466 1
			me->node_anchor->charset);
d2477 1
a2477 1
    } else if (!strcasecomp((http_equiv ? http_equiv : ""), "Refresh")) {
d2480 2
a2481 12
	/*
	 *  Look for the Seconds field. - FM
	 */
	cp = LYSkipBlanks(content);
	if (*cp && isdigit(*cp)) {
	    cp1 = cp;
	    while (*cp1 && isdigit(*cp1))
		cp1++;
	    if (*cp1)
		*cp1++ = '\0';
	    StrAllocCopy(Seconds, cp);
	}
a2482 19
	    /*
	     *	We have the seconds field.
	     *	Now look for a URL field - FM
	     */
	    while (*cp1) {
		if (!strncasecomp(cp1, "URL", 3)) {
		    cp = (cp1 + 3);
		    while (*cp && (*cp == '=' || isspace((unsigned char)*cp)))
			cp++;
		    cp1 = cp;
		    while (*cp1 && !isspace((unsigned char)*cp1))
			cp1++;
		    *cp1 = '\0';
		    if (*cp)
			StrAllocCopy(href, cp);
		    break;
		}
		cp1++;
	    }
d2487 1
a2487 2
		if (!(url_type = LYLegitimizeHREF(me, (char**)&href,
						  TRUE, FALSE))) {
d2507 6
a2512 5
		}
		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL((char **)&href,
d2515 2
d2536 4
d2541 1
a2541 1
		(cp = strrchr(href, '#')) != NULL) {
d2545 1
d2634 1
a2634 1
    } else if (!strcasecomp((http_equiv ? http_equiv : ""), "Set-Cookie")) {
d2668 2
a2669 2
PUBLIC void LYHandleP ARGS5(
	HTStructured *, 	me,
d2673 1
d2716 1
a2716 1
	    if (HText_LastLineSize(me->text, FALSE)) {
d2736 4
a2739 1
	} else if (me->List_Nesting_Level >= 0 ||
d2741 2
a2742 2
		    (!strcmp(me->sp->style->name, "Normal") ||
		     !strcmp(me->sp->style->name, "Preformatted")))) {
d2745 1
a2745 1
	    me->sp->style->alignment = me->current_default_alignment;
d2749 2
a2750 2
	    if (present && present[HTML_P_ALIGN] && value[HTML_P_ALIGN]) {
		if (!strcasecomp(value[HTML_P_ALIGN], "center") &&
d2753 1
a2753 1
		else if (!strcasecomp(value[HTML_P_ALIGN], "right") &&
d2756 2
a2757 2
		else if (!strcasecomp(value[HTML_P_ALIGN], "left") ||
			 !strcasecomp(value[HTML_P_ALIGN], "justify"))
a2760 1
	    CHECK_ID(HTML_P_ID);
d2780 1
a2780 1
	HTStructured *, 	me,
d2802 3
a2804 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: SELECT start tag not within FORM tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d2821 2
a2822 6
	    if (TRACE) {
		fprintf(tfp, "Bad HTML: Missing TEXTAREA end tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
a2844 3
#ifdef NOTDEFINED
	    StrAllocCopy(size, value[HTML_SELECT_SIZE]);
#else
d2848 2
a2849 3
	    CTRACE(tfp, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
			value[HTML_SELECT_SIZE]);
#endif /* NOTDEFINED */
d2897 2
a2898 6
	    if (TRACE) {
		fprintf(tfp, "Bad HTML: Unmatched SELECT end tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d2995 1
a2995 1
	HTStructured *, 	me,
d3001 1
d3003 1
a3003 1
    char *fragment = NULL;
d3005 1
a3005 1
    if (!me || !href || *href == NULL || *(*href) == '\0')
d3016 35
a3050 9
	if ((pound = strchr(*href, '#')) != NULL) {
	    StrAllocCopy(fragment, pound);
	    *pound = '\0';
	    convert_to_spaces(fragment, FALSE);
	}
	LYRemoveBlanks(*href);
	if (fragment != NULL) {
	    StrAllocCat(*href, fragment);
	    FREE(fragment);
d3053 1
a3053 1
    if (*(*href) == '\0')
d3055 6
a3060 2
    LYUCFullyTranslateString(href, me->tag_charset, me->tag_charset,
			     NO, NO, YES, st_URL);
d3062 1
a3062 1
    if (!url_type && force_slash &&
d3064 1
a3064 3
	 strncmp((me->inBASE ?
	       me->base_href : me->node_anchor->address),
		 "file:", 5)) {
d3075 2
a3076 4
    if ((!url_type && LYStripDotDotURLs && strip_dots && *(*href) == '.') &&
	 !strncasecomp((me->inBASE ?
		     me->base_href : me->node_anchor->address),
		       "http", 4)) {
d3094 3
a3096 7
	if (((temp = HTParse(*href,
			     (me->inBASE ?
			   me->base_href : me->node_anchor->address),
			     PARSE_ALL)) != NULL && temp[0] != '\0') &&
	    (path = HTParse(temp, "",
			    PARSE_PATH+PARSE_PUNCTUATION)) != NULL &&
	    !strncmp(path, "/..", 3)) {
d3099 1
a3099 2
		if ((me->inBASE ?
	       me->base_href[4] : me->node_anchor->address[4]) == 's') {
d3102 4
a3105 7
		if (TRACE) {
		    fprintf(tfp,
			 "LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
			   *href, str);
		    fprintf(tfp,
			 "                  Stripping lead dots.\n");
		} else if (!me->inBadHREF) {
d3140 1
a3140 1
	HTStructured *, 	me)
d3208 1
a3208 1
	HTStructured *, 	me,
d3225 1
a3225 1
	LYUCFullyTranslateString(&temp, me->tag_charset, me->tag_charset,
d3250 2
a3251 2
	HTStructured *, 	me,
	char *, 		id)
d3310 1
a3310 1
    if (HText_LastLineSize(me->text, FALSE)) {
d3314 1
a3314 1
    } else if (HText_PreviousLineSize(me->text, FALSE)) {
d3335 1
a3335 1
    if (HText_LastLineSize(me->text, FALSE)) {
d3357 2
a3358 2
	 (!strcmp(me->sp->style->name, "Normal") ||
	  !strcmp(me->sp->style->name, "Preformatted")))) {
d3361 1
a3361 1
	me->sp->style->alignment = me->current_default_alignment;
d3390 1
a3390 1
    if (strncasecomp(anchor->address, "file:", 5))
d3438 1
a3438 1
	    if ((unsigned char)*cp >= 127 || !isgraph((unsigned char)*cp)) {
d3448 1
a3448 1
	if (!LYUCFullyTranslateString(&messageid, 0, 0, NO, NO, YES, st_URL))
d3451 1
a3451 1
	    if ((unsigned char)*p >= 127 || !isgraph((unsigned char)*p)) {
d3482 1
a3482 1
	    if ((unsigned char)*cp >= 127 || !isprint((unsigned char)*cp)) {
d3500 1
a3500 1
	if (!LYUCFullyTranslateString(&subject, 0, 0, NO, YES, NO, st_HTML))
d3503 1
a3503 1
	    if ((unsigned char)*p >= 127 || !isprint((unsigned char)*p)) {
d3525 36
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 3
a4 3
 *  Functions associated with LYCharSets.c and the Lynx version of HTML.c - FM
 *  ==========================================================================
 */
d28 1
d42 7
d50 1
a50 1
 * Used for nested lists.  - FM
d52 3
a54 2
int OL_CONTINUE = -29999;	/* flag for whether CONTINUE is set */
int OL_VOID = -29998;		/* flag for whether a count is set */
d57 7
a63 6
 *  This function converts any ampersands in allocated
 *  strings to "&amp;".  If isTITLE is TRUE, it also
 *  converts any angle-brackets to "&lt;" or "&gt;". - FM
 */
void LYEntify(char **str,
	      BOOLEAN isTITLE)
d69 1
a69 13
#ifdef CJK_EX
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren
    } state = S_text;
    int in_sjis = 0;
#endif

    if (isEmpty(p))
d73 1
a73 1
     * Count the ampersands.  - FM
d81 1
a81 1
     * Count the left-angle-brackets, if needed.  - FM
d92 1
a92 1
     * Count the right-angle-brackets, if needed.  - FM
d103 1
a103 1
     * Check whether we need to convert anything.  - FM
d109 1
a109 1
     * Allocate space and convert.  - FM
d111 2
a112 2
    q = typecallocn(char,
		    (strlen(*str) + (4 * amps) + (3 * lts) + (3 * gts) + 1));
a115 83
#ifdef CJK_EX
	if (HTCJK != NOCJK) {
	    switch (state) {
	    case S_text:
		if (*p == '\033') {
		    state = S_esc;
		    *q++ = *p;
		    continue;
		}
		break;

	    case S_esc:
		if (*p == '$') {
		    state = S_dollar;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}

	    case S_dollar:
		if (*p == '@@' || *p == 'B' || *p == 'A') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_dollar_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}

	    case S_dollar_paren:
		if (*p == 'C') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}

	    case S_paren:
		if (*p == 'B' || *p == 'J' || *p == 'T') {
		    state = S_text;
		    *q++ = *p;
		    continue;
		} else if (*p == 'I') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		}
		/* FALLTHRU */

	    case S_nonascii_text:
		if (*p == '\033')
		    state = S_esc;
		*q++ = *p;
		continue;

	    default:
		break;
	    }
	    if (*(p + 1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p + 1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p + 1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p + 1))))) {
		*q++ = *p++;
		*q++ = *p;
		continue;
	    }
	}
#endif
d136 2
a137 3
    *q = '\0';
    FREE(*str);
    *str = cp;
d141 6
a146 5
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1) and HT_EN_SPACE (2),
 *  but not ESC, from the heads of strings. - FM
 */
void LYTrimHead(char *str)
d148 1
a148 1
    const char *s = str;
d150 1
a150 1
    if (isEmpty(s))
d153 5
a157 7
    while (*s && WHITE(*s) && UCH(*s) != UCH(CH_ESC))	/* S/390 -- gil -- 1669 */
	s++;
    if (s > str) {
	char *ns = str;

	while (*s) {
	    *ns++ = *s++;
d159 1
a159 1
	*ns = '\0';
d164 6
a169 5
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1), HT_EN_SPACE (2), and
 *  ESC from the tails of strings. - FM
 */
void LYTrimTail(char *str)
d173 1
a173 1
    if (isEmpty(str))
d176 1
a176 1
    i = strlen(str) - 1;
d187 7
a193 6
 * This function should receive a pointer to the start
 * of a comment.  It returns a pointer to the end ('>')
 * character of comment, or it's best guess if the comment
 * is invalid. - FM
 */
char *LYFindEndOfComment(char *str)
d196 1
a196 6
    enum comment_state {
	start1,
	start2,
	end1,
	end2
    } state;
d200 1
a200 1
	 * We got NULL, so return NULL.  - FM
d206 2
a207 2
	 * We don't have the start of a comment, so return the beginning of the
	 * string.  - FM
d212 1
a212 1
    if (*cp == '>')
d221 2
a222 2
	 * We don't have an end character, so return the beginning of the
	 * string.  - FM
d228 2
a229 2
	 * Ugh, it's a "decorative" series of dashes, so return the next end
	 * character.  - FM
d234 1
a234 1
     * OK, we're ready to start parsing.  - FM
d239 10
a248 10
	case start1:
	    if (*cp == '-')
		state = start2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;
d250 4
a253 4
	case start2:
	    if (*cp == '-')
		state = end1;
	    break;
d255 10
a264 10
	case end1:
	    if (*cp == '-')
		state = end2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;
d266 16
a281 16
	case end2:
	    if (*cp == '>')
		/*
		 * Valid comment, so return the end character.  - FM
		 */
		return cp;
	    if (*cp == '-') {
		state = start1;
	    } else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {	/* S/390 -- gil -- 1686 */
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    }
	    break;
d283 2
a284 2
	default:
	    break;
d290 2
a291 2
     * Invalid comment, so return the first '>' from the start of the string. 
     * - FM
d297 11
a307 10
 *  If an HREF, itself or if resolved against a base,
 *  represents a file URL, and the host is defaulted,
 *  force in "//localhost".  We need this until
 *  all the other Lynx code which performs security
 *  checks based on the "localhost" string is changed
 *  to assume "//localhost" when a host field is not
 *  present in file URLs - FM
 */
void LYFillLocalFileURL(char **href,
			const char *base)
d309 1
a309 1
    char *temp = NULL;
d311 1
a311 1
    if (isEmpty(*href))
d315 2
a316 2
	if (base != NULL && isFILE_URL(base)) {
	    StrAllocCopy(temp, STR_FILE_URL);
d321 2
a322 2
    if (isFILE_URL(*href)) {
	if (*(*href + 5) == '\0') {
d327 5
a331 5
	    StrAllocCopy(temp, (*href + 7));
	    LYLocalFileToURL(href, temp);
	} else if (!strncmp(*href, "file:/", 6) && !LYIsHtmlSep(*(*href + 6))) {
	    StrAllocCopy(temp, (*href + 5));
	    LYLocalFileToURL(href, temp);
d334 3
a336 2
#if defined(USE_DOS_DRIVES)
    if (LYIsDosDrive(*href)) {
d342 1
a342 1
	LYLocalFileToURL(href, temp);
d347 3
a349 2
	&& (strlen(*href) == 19)
	&& LYIsDosDrive(*href + 17)) {
d354 1
a354 1
	LYAddPathSep(href);
d356 1
a356 1
#endif /* USE_DOS_DRIVES */
d363 1
a363 2
	const char *temp2;

d365 1
a365 1
	temp2 = HTVMS_wwwName(LYGetEnv("PATH"));
a367 1

d370 1
a370 2
	if (!LYIsHtmlSep(*temp2))
	    LYAddHtmlSep(href);
d372 2
a373 2
	 * Check for pathological cases - current dir has chars which MUST BE
	 * URL-escaped - kw
d383 1
d390 1
a390 1
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir()) + 1));
d398 28
a425 26
 *  This function writes a line with a META tag to an open file,
 *  which will specify a charset parameter to use when the file is
 *  read back in.  It is meant for temporary HTML files used by the
 *  various special pages which may show titles of documents.  When those
 *  files are created, the title strings normally have been translated and
 *  expanded to the display character set, so we have to make sure they
 *  don't get translated again.
 *  If the user has changed the display character set during the lifetime
 *  of the Lynx session (or, more exactly, during the time the title
 *  strings to be written were generated), they may now have different
 *  character encodings and there is currently no way to get it all right.
 *  To change this, we would have to add a variable for each string which
 *  keeps track of its character encoding.
 *  But at least we can try to ensure that reading the file after future
 *  display character set changes will give reasonable output.
 *
 *  The META tag is not written if the display character set (passed as
 *  disp_chndl) already corresponds to the charset assumption that
 *  would be made when the file is read. - KW
 *
 *  Currently this function is used for temporary files like "Lynx Info Page"
 *  and for one permanent - bookmarks (so it may be a problem if you change
 *  the display charset later: new bookmark entries may be mistranslated).
 *								 - LP
 */
void LYAddMETAcharsetToFD(FILE *fd, int disp_chndl)
d429 1
a429 1
	 * -1 means use current_char_set.
d435 1
a435 1
	 * Should not happen.
d441 1
a441 1
	 * Not need to do, so we don't.
d447 1
a447 1
	 * There shouldn't be any 8-bit characters in this case.
d452 3
a454 3
     * In other cases we don't know because UCLYhndl_for_unspec may change
     * during the lifetime of the file (by toggling raw mode or changing the
     * display character set), so proceed.
d457 2
a458 2
	    "http-equiv=\"content-type\"",
	    LYCharSet_UC[disp_chndl].MIMEname);
d462 5
a466 4
 * This function returns OL TYPE="A" strings in
 * the range of " A." (1) to "ZZZ." (18278). - FM
 */
char *LYUppercaseA_OL_String(int seqnum)
d470 1
a470 1
    if (seqnum <= 1) {
d479 2
a480 2
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
d484 3
a486 3
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 64),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
d494 5
a498 4
 * This function returns OL TYPE="a" strings in
 * the range of " a." (1) to "zzz." (18278). - FM
 */
char *LYLowercaseA_OL_String(int seqnum)
d502 1
a502 1
    if (seqnum <= 1) {
d511 2
a512 2
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
d516 3
a518 3
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 96),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
d526 5
a530 5
 * This function returns OL TYPE="I" strings in the
 * range of " I." (1) to "MMM." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYUppercaseI_OL_String(int seqnum)
d532 1
a532 1
    static char OLstring[20];
d540 1
a540 1
    switch (Arabic) {
d660 5
a664 5
 * This function returns OL TYPE="i" strings in
 * range of " i." (1) to "mmm." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYLowercaseI_OL_String(int seqnum)
d666 1
a666 1
    static char OLstring[20];
d674 1
a674 1
    switch (Arabic) {
d794 4
a797 3
 *  This function initializes the Ordered List counter. - FM
 */
void LYZero_OL_Counter(HTStructured * me)
d816 4
a819 3
 *  This function is used by the HTML Structured object. - KW
 */
void LYGetChartransInfo(HTStructured * me)
d842 1
d844 624
a1467 7
 * Given an UCS character code, will fill buffer passed in as q with the code's
 * UTF-8 encoding.
 * If terminate = YES, terminates string on success and returns pointer
 *		       to beginning.
 * If terminate = NO,	does not terminate string, and returns pointer
 *		       next char after the UTF-8 put into buffer.
 * On failure, including invalid code or 7-bit code, returns NULL.
d1469 1
a1469 1
static char *UCPutUtf8ToBuffer(char *q, UCode_t code, BOOL terminate)
a1471 1

d1473 1
a1473 1
	return NULL;
d1476 2
a1477 2
	    *q++ = (char) (0xc0 | (code >> 6));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d1479 3
a1481 3
	    *q++ = (char) (0xe0 | (code >> 12));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d1483 4
a1486 4
	    *q++ = (char) (0xf0 | (code >> 18));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d1488 5
a1492 5
	    *q++ = (char) (0xf8 | (code >> 24));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d1494 6
a1499 6
	    *q++ = (char) (0xfc | (code >> 30));
	    *q++ = (char) (0x80 | (0x3f & (code >> 24)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d1513 1
a1513 1
static const char *hex = "0123456789ABCDEF";
d1520 86
a1605 85
 *  This function used for translations HTML special fields inside tags
 *  (ALT=, VALUE=, etc.) from charset `cs_from' to charset `cs_to'.
 *  It also unescapes non-ASCII characters from URL (#fragments !)
 *  if st_URL is active.
 *
 *  If `do_ent' is YES, it converts named entities
 *  and numeric character references (NCRs) to their `cs_to' replacements.
 *
 *  Named entities converted to unicodes.  NCRs (unicodes) converted
 *  by UCdomap.c chartrans functions.
 *  ???NCRs with values in the ISO-8859-1 range 160-255 may be converted
 *  to their HTML entity names (via old-style entities) and then translated
 *  according to the LYCharSets.c array for `cs_out'???.
 *
 *  Some characters (see descriptions in `put_special_unicodes' from SGML.c)
 *  translated in relation with the state of boolean variables
 *  `use_lynx_specials', `plain_space' and `hidden'.  It is not clear yet:
 *
 *  If plain_space is TRUE, nbsp (160) will be treated as an ASCII
 *  space (32).  If hidden is TRUE, entities will be translated
 *  (if `do_ent' is YES) but escape sequences will be passed unaltered.
 *  If `hidden' is FALSE, some characters are converted to Lynx special
 *  codes (see `put_special_unicodes') or ASCII space if `plain_space'
 *  applies).  @@@@ is `use_lynx_specials' needed, does it have any effect? @@@@
 *  If `use_lynx_specials' is YES, translate byte values 160 and 173
 *  meaning U+00A0 and U+00AD given as or converted from raw char input
 *  are converted to HT_NON_BREAK_SPACE and LY_SOFT_HYPHEN, respectively
 *  (unless input and output charset are both iso-8859-1, for compatibility
 *  with previous usage in HTML.c) even if `hidden' or `plain_space' is set.
 *
 *  If `Back' is YES, the reverse is done instead i.e., Lynx special codes
 *  in the input are translated back to character values.
 *
 *  If `Back' is YES, an attempt is made to use UCReverseTransChar() for
 *  back translation which may be more efficient. (?)
 *
 *  If `stype' is st_URL, non-ASCII characters are URL-encoded instead.
 *  The sequence of bytes being URL-encoded is the raw input character if
 *  we couldn't translate it from `cs_in' (CJK etc.); otherwise it is the
 *  UTF-8 representation if either `cs_to' requires this or if the
 *  character's Unicode value is > 255, otherwise it should be the iso-8859-1
 *  representation.
 *  No general URL-encoding occurs for displayable ASCII characters and
 *  spaces and some C0 controls valid in HTML (LF, TAB), it is expected
 *  that other functions will take care of that as appropriate.
 *
 *  Escape characters (0x1B, '\033') are
 *  - URL-encoded	if `stype'  is st_URL,	 otherwise
 *  - dropped		if `stype'  is st_other, otherwise (i.e., st_HTML)
 *  - passed		if `hidden' is TRUE or HTCJK is set, otherwise
 *  - dropped.
 *
 *  (If `stype' is st_URL or st_other most of the parameters really predefined:
 *  cs_from=cs_to, use_lynx_specials=plain_space=NO, and hidden=YES)
 *
 *
 *  Returns pointer to the char** passed in
 *		 if string translated or translation unnecessary,
 *	    NULL otherwise
 *		 (in which case something probably went wrong.)
 *
 *
 *  In general, this somehow ugly function (KW)
 *  cover three functions from v.2.7.2 (FM):
 *		    extern void LYExpandString (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeEntities (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeToLatinOne (
 *		       HTStructured *	       me,
 *		       char **		       str,
 *		       BOOLEAN		       isURL);
 */

char **LYUCFullyTranslateString(char **str,
				int cs_from,
				int cs_to,
				BOOLEAN do_ent,
				BOOL use_lynx_specials,
				BOOLEAN plain_space,
				BOOLEAN hidden,
				BOOL Back,
				CharUtil_st stype)
d1607 1
a1607 1
    char *p;
d1610 1
a1610 1
    char *cp = 0;
d1613 1
a1613 1
    char replace_buf[64];
d1620 1
a1620 1
    const char *name = NULL;
d1624 4
a1627 14
    char *puni;
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren,
	S_trans_byte,
	S_check_ent,
	S_ncr,
	S_check_uni,
	S_named,
	S_check_name,
d1629 5
a1633 23
	S_got_oututf8,
	S_got_outstring,
	S_put_urlstring,
	S_got_outchar,
	S_put_urlchar,
	S_next_char,
	S_done
    } state = S_text;
    enum _parsing_what {
	P_text,
	P_utf8,
	P_hex,
	P_decimal,
	P_named
    } what = P_text;

#ifdef KANJI_CODE_OVERRIDE
    static unsigned char sjis_1st = '\0';

#ifdef CONV_JISX0201KANA_JISX0208KANA
    unsigned char sjis_str[3];
#endif
#endif
d1636 3
a1638 3
     * Make sure we have a non-empty string.  - FM
     */
    if (!str || isEmpty(*str))
d1648 13
a1660 17
     * Don't do byte translation if original AND target character sets are both
     * iso-8859-1 (and we are not called to back-translate), or if we are in
     * CJK mode.
     */
    if ((HTCJK != NOCJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& (strcmp(LYCharSet_UC[cs_from].MIMEname, "utf-8") != 0)
#endif
	) {
	no_bytetrans = TRUE;
    } else if (cs_to <= 0 && cs_from == cs_to && (!Back || cs_to < 0)) {
	no_bytetrans = TRUE;
    } else {
	/* No need to translate or examine the string any further */
	no_bytetrans = (BOOL) (!use_lynx_specials && !Back &&
			       UCNeedNotTranslate(cs_from, cs_to));
    }
d1662 2
a1663 2
     * Save malloc/calloc overhead in simple case - kw
     */
d1686 1
a1686 1
	from_is_utf8 = (BOOL) (LYCharSet_UC[cs_from].enc == UCT_ENC_UTF8);
d1691 3
a1693 3
	output_utf8 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8 ||
			      HText_hasUTF8OutputSet(HTMainText));
	repl_translated_C0 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_8BIT_C0);
d1699 3
a1701 3
     * Create a buffer string seven times the length of the original, so we
     * have plenty of room for expansions.  - FM
     */
d1723 7
a1729 6
     * Loop through string, making conversions as needed.
     *
     * The while() checks for a non-'\0' char only for the normal text states
     * since other states may temporarily modify p or *p (which should be
     * restored before S_done!) - kw
     */
d1731 1
a1731 1
	switch (state) {
d1733 1
a1733 21
	    code = UCH(*p);
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE && last_kcode == SJIS) {
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code) || IS_SJIS_HI2(code))) {
		    sjis_1st = UCH(code);
		} else if (sjis_1st && IS_SJIS_LO(code)) {
		    sjis_1st = '\0';
		} else {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    if (0xA1 <= code && code <= 0xDF) {
			sjis_str[2] = '\0';
			JISx0201TO0208_SJIS(UCH(code),
					    sjis_str, sjis_str + 1);
			REPLACE_STRING(sjis_str);
			p++;
			continue;
		    }
#endif
		}
	    }
#endif
d1750 3
a1752 3
		     * CJK handling not on, and not a hidden INPUT, so block
		     * escape.  - FM
		     */
a1773 1
	    break;
d1800 1
a1800 1
	    if (*p == 'B' || *p == 'J' || *p == 'T') {
d1831 1
a1831 1
	    /* character translation goes here */
d1833 5
a1837 4
	     * Don't do anything if we have no string, or if original AND
	     * target character sets are both iso-8859-1, or if we are in CJK
	     * mode.
	     */
a1844 1

d1852 1
a1857 6
			} else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
				     || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			    state = S_check_uni;
			    break;
			} else {
			    *(unsigned char *) p = UCH(160);
d1861 1
a1866 6
		    } else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
				 || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			state = S_check_uni;
			break;
		    } else {
			*(unsigned char *) p = UCH(173);
d1874 1
a1874 1
		    *p = (char) rev_c;
d1885 1
a1885 1
		if (((*p) & 0xc0) == 0xc0) {
d1889 1
a1889 1
			code = UCH(*p);
d1908 1
a1908 1
		    code = UCH(*p);
d1910 8
d1923 3
a1925 3
	     * Substitute Lynx special character for 160 (nbsp) if
	     * use_lynx_specials is set.
	     */
d1928 1
a1928 1
		code = ((code == 160 ? HT_NON_BREAK_SPACE : LY_SOFT_HYPHEN));
d1938 1
a1938 2
		char *pp = p + 1;

d1941 2
a1942 2
		 * Check for a numeric entity.  - FM
		 */
d1944 3
a1946 3
		    (*(pp + 1) == 'x' || *(pp + 1) == 'X') &&
		    UCH(*(pp + 2)) < 127 &&
		    isxdigit(UCH(*(pp + 2)))) {
d1950 2
a1951 2
			   UCH(*(pp + 1)) < 127 &&
			   isdigit(UCH(*(pp + 1)))) {
d1954 2
a1955 2
		} else if (UCH(*pp) < 127 &&
			   isalpha(UCH(*pp))) {
d1967 35
a2001 43
	    if (what == P_hex) {
		p += 3;
	    } else {		/* P_decimal */
		p += 2;
	    }
	    cp = p;
	    while (*p && UCH(*p) < 127 &&
		   (what == P_hex ? isxdigit(UCH(*p)) :
		    isdigit(UCH(*p)))) {
		p++;
	    }
	    /*
	     * Save the terminator and isolate the digit(s).  - FM
	     */
	    cpe = *p;
	    if (*p)
		*p++ = '\0';
	    /*
	     * Show the numeric entity if the value:
	     * (1) Is greater than 255 and unhandled Unicode.
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if ((((what == P_hex) ? sscanf(cp, "%lx", &lcode) :
		  sscanf(cp, "%ld", &lcode)) != 1) ||
		lcode > 0x7fffffffL || lcode < 0) {
		state = S_recover;
		break;
	    } else {
		code = lcode;
		if ((code == 1) ||
		    (code > 127 && code < 156)) {
		    /*
		     * Assume these are Microsoft code points, inflicted on
		     * us by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159
		     * range and doesn't follow Unicode standards for this
		     * area.  Windows-1252 codepoints are assumed here.
		     */
		    switch (code) {
		    case 1:
d2003 131
a2133 117
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
			break;
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
			break;
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
			break;
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
			break;
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
			break;
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
			break;
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
			break;
d2135 1
d2137 1
a2137 3
		state = S_check_uni;
	    }
	    break;
d2140 42
a2181 33
	    /*
	     * Show the numeric entity if the value:
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if ((code < 32 &&
		 code != 9 && code != 10 && code != 13 &&
		 HTCJK == NOCJK) ||
		(code == 127 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
		(code > 127 && code < 160 &&
		 !HTPassHighCtrlNum)) {
		state = S_recover;
		break;
	    }
	    /*
	     * Convert the value as an unsigned char, hex escaped if isURL is
	     * set and it's 8-bit, and then recycle the terminator if it is not
	     * a semicolon.  - FM
	     */
	    if (code > 159 && stype == st_URL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 160 (nbsp), use that value if it's a hidden INPUT, otherwise
	     * use an ASCII space (32) if plain_space is TRUE, otherwise use
	     * the Lynx special character.  - FM
	     */
	    if (code == 160) {
		if (plain_space) {
		    code = ' ';
d2184 34
a2217 2
		} else if (use_lynx_specials) {
		    code = HT_NON_BREAK_SPACE;
d2220 11
a2230 6
		} else if ((hidden && !Back)
			   || (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1)
			   || LYCharSet_UC[cs_to].enc == UCT_ENC_8859
			   || (LYCharSet_UC[cs_to].like8859 &
			       UCT_R_8859SPECL)) {
		    state = S_got_outchar;
d2232 4
a2235 6
		} else if (
			      (LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
		    ;		/* nothing, may be translated later */
		} else {
		    code = ' ';
		    state = S_got_outchar;
d2238 26
a2263 8
	    }
	    /*
	     * For 173 (shy), use that value if it's a hidden INPUT, otherwise
	     * ignore it if plain_space is TRUE, otherwise use the Lynx special
	     * character.  - FM
	     */
	    if (code == 173) {
		if (plain_space) {
d2267 11
a2277 7
		} else if (Back &&
			   !(LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			     (LYCharSet_UC[cs_to].like8859 &
			      UCT_R_8859SPECL))) {
		    ;		/* nothing, may be translated later */
		} else if (hidden || Back) {
		    state = S_got_outchar;
d2279 11
a2289 2
		} else if (use_lynx_specials) {
		    code = LY_SOFT_HYPHEN;
d2292 4
a2295 42
		}
	    }
	    /*
	     * Seek a translation from the chartrans tables.
	     */
	    if ((uck = UCTransUniChar(code,
				      cs_to)) >= 32 &&
		uck < 256 &&
		(uck < 127 || uck >= lowest_8)) {
		code = uck;
		state = S_got_outchar;
		break;
	    } else if ((uck == -4 ||
			(repl_translated_C0 &&
			 uck > 0 && uck < 32)) &&
		/*
		 * Not found; look for replacement string.
		 */
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						cs_to,
						0) >= 0)) {
		state = S_got_outstring;
		break;
	    }
	    if (output_utf8 &&
		code > 127 && code < 0x7fffffffL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 8194 (ensp), 8195 (emsp), or 8201 (thinsp), use the
	     * character reference if it's a hidden INPUT, otherwise use an
	     * ASCII space (32) if plain_space is TRUE, otherwise use the Lynx
	     * special character.  - FM
	     */
	    if (code == 8194 || code == 8195 || code == 8201) {
		if (hidden) {
		    state = S_recover;
		} else if (plain_space) {
		    code = ' ';
		    state = S_got_outchar;
d2297 3
a2299 2
		    code = HT_EN_SPACE;
		    state = S_got_outchar;
a2300 59
		break;
		/*
		 * Ignore 8204 (zwnj), 8205 (zwj) 8206 (lrm), and 8207 (rlm),
		 * for now, if we got this far without finding a representation
		 * for them.
		 */
	    } else if (code == 8204 || code == 8205 ||
		       code == 8206 || code == 8207) {
		CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
		replace_buf[0] = '\0';
		state = S_got_outstring;
		break;
		/*
		 * Show the numeric entity if the value:  (1) Is greater than
		 * 255 and unhandled Unicode.
		 */
	    } else if (code > 255) {
		/*
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
		state = S_recover;
		break;
		/*
		 * If it's ASCII, or is 8-bit but HTPassEightBitNum is set or
		 * the character set is "ISO Latin 1", use it's value.  - FM
		 */
	    } else if (code < 161 ||
		       (code < 256 &&
			(HTPassEightBitNum || cs_to == LATIN1))) {
		/*
		 * No conversion needed.
		 */
		state = S_got_outchar;
		break;

		/* The following disabled section doesn't make sense any more. 
		 * It used to make sense in the past, when S_check_named would
		 * look in "old style" tables in addition to what it does now. 
		 * Disabling of going to S_check_name here prevents endless
		 * looping between S_check_uni and S_check_names states, which
		 * could occur here for Latin 1 codes for some cs_to if they
		 * had no translation in that cs_to.  Normally all cs_to
		 * *should* now have valid translations via UCTransUniChar or
		 * UCTransUniCharStr for all Latin 1 codes, so that we would
		 * not get here anyway, and no loop could occur.  Still, if we
		 * *do* get here, FALL THROUGH to case S_recover now.  - kw
		 */
#if 0
		/*
		 * If we get to here, convert and handle the character as a
		 * named entity.  - FM
		 */
	    } else {
		name = HTMLGetEntityName(code - 160);
		state = S_check_name;
		break;
#endif
	    }
d2304 13
a2316 12
		/*
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
		*q++ = '&';
		*q++ = '#';
		if (what == P_hex)
		    *q++ = 'x';
		if (cpe != '\0')
		    *(p - 1) = cpe;
		p = cp;
		state = S_done;
d2321 7
d2329 2
a2330 2
		       !(HTPassEightBitRaw &&
			 UCH(*p) >= lowest_8)) {
d2335 1
a2335 1
		code = UCH(*p);
d2342 2
a2343 2
	    while (*cp && UCH(*cp) < 127 &&
		   isalnum(UCH(*cp)))
d2347 1
d2354 10
a2363 10
	     * Seek the Unicode value for the named entity.
	     *
	     * !!!!  We manually recover the case of '=' terminator which is
	     * commonly found on query to CGI-scripts enclosed as href= URLs
	     * like "somepath/?x=1&yz=2" Without this dirty fix, submission of
	     * such URLs was broken if &yz string happened to be a recognized
	     * entity name.  - LP
	     */
	    if (((code = HTMLGetEntityUCValue(name)) > 0) &&
		!((cpe == '=') && (stype == st_URL))) {
d2368 3
a2370 2
	     * Didn't find the entity.  Return verbatim.
	     */
d2374 1
a2374 1
	    /* * * O U T P U T   S T A T E S * * */
d2401 1
a2401 1
		code = replace_buf[0];	/* assume string OK if first char is */
d2429 2
a2430 2
	    /*  Not a full HTEscape, only for 8bit and ctrl chars */
		(TOASCII(code) >= 127 ||	/* S/390 -- gil -- 1925 */
d2432 2
a2433 2
		state = S_put_urlchar;
		break;
d2435 1
a2435 1
		       && q != qs && *(q - 1) == 13) {
d2437 4
a2440 4
		 * If this is not a hidden string, and the current char is the
		 * LF ('\n') of a CRLF pair, drop the CR ('\r').  - KW
		 */
		*(q - 1) = *p++;
d2444 1
a2444 1
	    *q++ = (char) code;
d2449 1
a2449 1
	    REPLACE_CHAR(hex[(TOASCII(code) >> 4) & 15]);	/* S/390 -- gil -- 1944 */
d2451 1
a2451 1
	    /* fall through */
d2457 1
a2457 1
	    /* for next round */
d2463 2
a2464 2
	HTChunkPutb(CHUNK, qs, q - qs + 1);	/* also terminates */
	if (stype == st_URL || stype == st_other) {
d2471 1
a2471 1
	if (stype == st_URL || stype == st_other) {
d2482 8
a2489 7
BOOL LYUCTranslateHTMLString(char **str,
			     int cs_from,
			     int cs_to,
			     BOOL use_lynx_specials,
			     BOOLEAN plain_space,
			     BOOLEAN hidden,
			     CharUtil_st stype)
a2491 1

d2493 3
a2495 3
    if (!LYUCFullyTranslateString(str, cs_from, cs_to, TRUE,
				  use_lynx_specials, plain_space, hidden,
				  NO, stype)) {
d2501 5
a2505 4
BOOL LYUCTranslateBackFormData(char **str,
			       int cs_from,
			       int cs_to,
			       BOOLEAN plain_space)
d2507 1
a2507 2
    char **ret;

d2509 4
a2512 75
    ret = (LYUCFullyTranslateString(str, cs_from, cs_to, FALSE,
				    NO, plain_space, YES,
				    YES, st_HTML));
    return (BOOL) (ret != NULL);
}

/*
 * Parse a parameter from an HTML META tag, i.e., the CONTENT.
 */
char *LYParseTagParam(char *from,
		      const char *name)
{
    size_t len = strlen(name);
    char *result = NULL;
    char *string = from;

    do {
	if ((string = strchr(string, ';')) == NULL)
	    return NULL;
	while (*string != '\0' && (*string == ';' || isspace(UCH(*string)))) {
	    string++;
	}
	if (strlen(string) < len)
	    return NULL;
    } while (strncasecomp(string, name, len) != 0);
    string += len;
    while (*string != '\0' && (UCH(isspace(*string)) || *string == '=')) {
	string++;
    }

    StrAllocCopy(result, string);
    len = 0;
    while (isprint(UCH(string[len])) && !isspace(UCH(string[len]))) {
	len++;
    }
    result[len] = '\0';

    /*
     * Strip single quotes, just in case.
     */
    if (len > 2 && result[0] == '\'' && result[len - 1] == result[0]) {
	result[len - 1] = '\0';
	for (string = result; (string[0] = string[1]) != '\0'; ++string) ;
    }
    return result;
}

/*
 * Given a refresh-URL content string, parses the delay time and the URL
 * string.  Ignore the remainder of the content.
 */
void LYParseRefreshURL(char *content,
		       char **p_seconds,
		       char **p_address)
{
    char *cp;
    char *cp1 = NULL;
    char *Seconds = NULL;

    /*
     * Look for the Seconds field.  - FM
     */
    cp = LYSkipBlanks(content);
    if (*cp && isdigit(UCH(*cp))) {
	cp1 = cp;
	while (*cp1 && isdigit(UCH(*cp1)))
	    cp1++;
	StrnAllocCopy(Seconds, cp, cp1 - cp);
    }
    *p_seconds = Seconds;
    *p_address = LYParseTagParam(content, "URL");

    CTRACE((tfp,
	    "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
	    content, NonNull(*p_seconds), NonNull(*p_address)));
d2516 7
a2522 5
 *  This function processes META tags in HTML streams. - FM
 */
void LYHandleMETA(HTStructured * me, const BOOL *present,
		  const char **value,
		  char **include GCC_UNUSED)
d2533 1
a2533 1
     * Load the attributes for possible use by Lynx.  - FM
d2536 1
a2536 1
	non_empty(value[HTML_META_HTTP_EQUIV])) {
d2539 4
a2542 2
	LYUCTranslateHTMLString(&http_equiv, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
d2548 1
a2548 1
	non_empty(value[HTML_META_NAME])) {
d2551 4
a2554 2
	LYUCTranslateHTMLString(&name, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
d2560 1
a2560 1
	non_empty(value[HTML_META_CONTENT])) {
d2562 9
a2570 7
	 * Technically, we should be creating a comma-separated list, but META
	 * tags come one at a time, and we'll handle (or ignore) them as each
	 * is received.  Also, at this point, we only trim leading and trailing
	 * blanks from the CONTENT value, without translating any named
	 * entities or numeric character references, because how we should do
	 * that depends on what type of information it contains, and whether or
	 * not any of it might be sent to the screen.  - FM
d2580 4
a2583 5
    CTRACE((tfp,
	    "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
	    (http_equiv ? http_equiv : "NULL"),
	    (name ? name : "NULL"),
	    (content ? content : "NULL")));
d2586 1
a2586 1
     * Make sure we have META name/value pairs to handle.  - FM
d2595 6
a2600 4
    if (!strcasecomp(NonNull(http_equiv), "Pragma") ||
	!strcasecomp(NonNull(http_equiv), "Cache-Control")) {
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
d2607 5
a2611 3
	 * If we didn't get a Cache-Control MIME header, and the META has one,
	 * convert to lowercase, store it in the anchor element, and if we
	 * haven't yet set no_cache, check whether we should.  - FM
d2614 1
a2614 1
	    !strcasecomp(NonNull(http_equiv), "Cache-Control")) {
d2641 1
a2641 1
			if (isdigit(UCH(*cp))) {
d2643 1
a2643 1
			    while (isdigit(UCH(*cp)))
d2657 4
d2662 8
a2669 1
	 * Check for an Expires directive. - FM
d2671 4
a2674 10
    } else if (!strcasecomp(NonNull(http_equiv), "Expires")) {
	/*
	 * If we didn't get an Expires MIME header, store it in the anchor
	 * element, and if we haven't yet set no_cache, check whether we
	 * should.  Note that we don't accept a Date header via META tags,
	 * because it's likely to be untrustworthy, but do check for a Date
	 * header from a server when making the comparison.  - FM
	 */
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
d2679 2
a2680 2
		 * The value is zero, which we treat as an absolute no-cache
		 * directive.  - FM
d2686 3
a2688 2
		 * We have a Date header, so check if the value is less than or
		 * equal to that.  - FM
d2695 1
a2695 1
	    } else if (LYmktime(content, FALSE) == 0) {
d2697 2
a2698 2
		 * We don't have a Date header, and the value is in past for
		 * us.  - FM
d2705 13
a2717 11
	/*
	 * Check for a text/html Content-Type with a charset directive, if we
	 * didn't already set the charset via a server's header.  - AAC & FM
	 */
    } else if (isEmpty(me->node_anchor->charset) &&
	       !strcasecomp(NonNull(http_equiv), "Content-Type")) {
	LYUCcharset *p_in = NULL;
	LYUCcharset *p_out = NULL;

	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
d2720 3
a2722 1
	if ((cp1 = strstr(content, "charset")) != NULL) {
d2731 1
a2731 1
	    StrAllocCopy(cp3, cp1);	/* copy to mutilate more */
d2733 1
a2733 1
			     *cp4 != ';' && *cp4 != ':' &&
d2735 1
a2735 1
		;		/* do nothing */
a2739 24

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (Switch_Display_Charset(chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
		/* UCT_STAGE_STRUCTURED and UCT_STAGE_HTEXT
		   should have the same setting for UCInfoStage. */
		int structured = HTAnchor_getUCInfoStage(me->node_anchor,
							 UCT_STAGE_STRUCTURED);

		me->outUCLYhndl = current_char_set;
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_HTEXT,
					UCT_SETBY_MIME);	/* highest priorty! */
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_STRUCTURED,
					UCT_SETBY_MIME);	/* highest priorty! */
		me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor,
						     UCT_STAGE_HTEXT);
		/* The SGML stage will be reset in change_chartrans_handling */
	    }
#endif

d2748 1
a2748 1
		 * Got something but we don't recognize it.
d2751 2
a2752 2
		if (chndl < 0)	/* UCLYhndl_for_unrec not defined :-( */
		    chndl = UCLYhndl_for_unspec;	/* always >= 0 */
d2769 1
a2769 1
		     * Try again.
d2777 4
a2780 4
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_HTEXT),
					    UCT_STAGE_PARSER,
					    UCT_SETBY_DEFAULT);
d2785 2
a2786 2
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_PARSER),
d2790 1
a2790 5
		if ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
		    && (p_in->enc != UCT_ENC_UTF8)
#endif
		    ) {
d2802 4
a2805 3
		 * Update the chartrans info homologously to a Content-Type
		 * MIME header with a charset parameter.  - FM
		 */
d2823 20
a2842 16
		 * Cannot translate.  If according to some heuristic the given
		 * charset and the current display character both are likely to
		 * be like ISO-8859 in structure, pretend we have some kind of
		 * match.
		 */
		BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
					     isdigit(UCH(cp4[9])));
		BOOL given_is_8859like = (BOOL) (given_is_8859
						 || !strncmp(cp4, "windows-", 8)
						 || !strncmp(cp4, "cp12", 4)
						 || !strncmp(cp4, "cp-12", 5));
		BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
							  (strstr(LYchar_set_names[current_char_set],
								  "ISO-8859") ||
							   strstr(LYchar_set_names[current_char_set],
								  "windows-")));
d2847 1
a2847 1
			   isdigit(UCH((*cp1))))
d2861 1
a2861 1
		CTRACE((tfp,
d2863 1
a2863 1
			me->node_anchor->charset));
d2867 1
a2867 1
	 * Set the kcode element based on the charset.  - FM
d2871 6
d2878 1
a2878 1
	 * Check for a Refresh directive.  - FM
d2880 9
a2888 5
    } else if (!strcasecomp(NonNull(http_equiv), "Refresh")) {
	char *Seconds = NULL;

	LYParseRefreshURL(content, &Seconds, &href);

d2890 19
d2911 1
a2911 1
		 * We found a URL field, so check it out.  - FM
d2913 2
a2914 1
		if (!(url_type = LYLegitimizeHREF(me, &href, TRUE, FALSE))) {
d2916 3
a2918 3
		     * The specs require a complete URL, but this is a
		     * Netscapism, so don't expect the author to know that.  -
		     * FM
d2922 2
a2923 1
		     * Use the document's address as the base.  - FM
a2933 8

		} else {
		    /*
		     * Check whether to fill in localhost.  - FM
		     */
		    LYFillLocalFileURL(&href,
				       (me->inBASE ?
					me->base_href : me->node_anchor->address));
a2934 1

d2936 8
a2943 2
		 * Set the no_cache flag if the Refresh URL is the same as the
		 * document's address.  - FM
d2950 3
a2952 2
		 * We didn't find a URL field, so use the document's own
		 * address and set the no_cache flag.  - FM
d2958 1
a2958 1
	     * Check for an anchor in http or https URLs.  - FM
a2959 4
	    cp = NULL;
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /* id_string seems to be used wrong below if given.
	       not that it matters much.  avoid setting it here. - kw */
d2961 1
a2961 1
		(cp = strchr(href, '#')) != NULL) {
a2964 1
#endif
d2967 4
a2970 3
		 * Ugh!  The META tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
d2979 5
a2983 6
	    me->CurrentA = HTAnchor_findChildAndLink
		(
		    me->node_anchor,	/* Parent */
		    id_string,	/* Tag */
		    href,	/* Addresss */
		    (HTLinkType *) 0);	/* Type */
d3009 6
a3014 6
	/*
	 * Check for a suggested filename via a Content-Disposition with a
	 * filename=name.suffix in it, if we don't already have it via a server
	 * header.  - FM
	 */
    } else if (isEmpty(me->node_anchor->SugFname) &&
d3028 1
a3028 1
		if (*me->node_anchor->SugFname == '"') {
d3030 1
a3030 1
				     '"')) != NULL) {
d3050 4
d3055 3
a3057 7
	 * Check for a Set-Cookie directive.  - AK
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Set-Cookie")) {
	/*
	 * This will need to be updated when Set-Cookie/Set-Cookie2 handling is
	 * finalized.  For now, we'll still assume "historical" cookies in META
	 * directives.  - FM
d3060 1
a3060 1
			  me->base_href : me->node_anchor->address);
d3065 1
a3065 1
			 me->base_href : me->node_anchor->address));
d3070 1
a3070 1
     * Free the copies.  - FM
d3072 1
a3072 1
  free_META_copies:
d3079 14
a3092 13
 *  This function handles P elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if
 *  FALSE, an end tag.	We presently handle start
 *  and end tags identically, but this can lead to
 *  a different number of blank lines between the
 *  current paragraph and subsequent text when a P
 *  end tag is present or not in the markup. - FM
 */
void LYHandlePlike(HTStructured * me, const BOOL *present,
		   const char **value,
		   char **include GCC_UNUSED,
		   int align_idx,
		   BOOL start)
d3096 5
a3100 5
	 * FIG content should be a true block, which like P inherits the
	 * current style.  APPLET is like character elements or an ALT
	 * attribute, unless it content contains a block element.  If we
	 * encounter a P in either's content, we set flags to treat the content
	 * as a block.  - FM
d3113 4
a3116 3
	     * We're in a list.  Treat P as an instruction to create one blank
	     * line, if not already present, then fall through to handle
	     * attributes, with the "second line" margins.  - FM
d3130 3
a3132 3
	     * We're in an ADDRESS.  Treat P as an instruction to start a
	     * newline, if needed, then fall through to handle attributes.  -
	     * FM
d3134 2
a3135 2
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d3154 1
a3154 4
	} else if ((me->List_Nesting_Level >= 0 &&
		    (me->sp->style->id == ST_DivCenter ||
		     me->sp->style->id == ST_DivLeft ||
		     me->sp->style->id == ST_DivRight)) ||
d3156 3
a3158 3
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
	    me->sp->style->alignment = HT_LEFT;
d3160 1
a3160 1
	    me->sp->style->alignment = (short) me->current_default_alignment;
d3164 2
a3165 2
	    if (present && present[align_idx] && value[align_idx]) {
		if (!strcasecomp(value[align_idx], "center") &&
d3168 2
a3169 2
		else if (!strcasecomp(value[align_idx], "right") &&
			 !(me->List_Nesting_Level >= 0 && !me->inP))
d3171 2
a3172 2
		else if (!strcasecomp(value[align_idx], "left") ||
			 !strcasecomp(value[align_idx], "justify"))
d3176 1
d3180 3
a3182 2
	 * Mark that we are starting a new paragraph and don't have any of it's
	 * text yet.  - FM
d3191 10
a3200 8
 *  This function handles SELECT elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if FALSE,
 *  an end tag. - FM
 */
void LYHandleSELECT(HTStructured * me, const BOOL *present,
		    const char **value,
		    char **include GCC_UNUSED,
		    BOOL start)
d3210 1
a3210 1
	 * Initialize the disable attribute.
d3215 1
a3215 1
	 * Make sure we're in a form.
d3218 7
a3224 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag not within FORM tag\n"));
d3227 6
a3232 7
	     * We should have covered all crash possibilities with the current
	     * TagSoup parser, so we'll allow it because some people with other
	     * browsers use SELECT for "information" popups, outside of FORM
	     * blocks, though no Lynx user would do anything that awful, right? 
	     * - FM
	     */
	       /***
d3238 1
a3238 1
	 * Check for unclosed TEXTAREA.
d3241 6
a3246 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d3250 1
a3250 1
	 * Set to know we are in a select tag.
d3255 1
a3255 1
	      non_empty(value[HTML_SELECT_NAME]))) {
d3264 1
a3264 1
	    multiple = YES;
d3268 4
a3271 1
	    non_empty(value[HTML_SELECT_SIZE])) {
d3273 1
a3273 1
	     * Let the size be determined by the number of OPTIONs.  - FM
d3275 3
a3277 2
	    CTRACE((tfp, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
		    value[HTML_SELECT_SIZE]));
d3295 1
a3295 1
	    HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 7)) {
d3297 6
a3302 5
	     * Force a newline when we're using a popup in a PRE block and are
	     * within 7 columns from the right margin.  This will allow for the
	     * '[' popup designator and help avoid a wrap in the underscore
	     * placeholder for the retracted popup entry in the HText
	     * structure.  - FM
d3308 1
a3308 1
	LYCheckForID(me, present, value, (int) HTML_SELECT_ID);
d3317 1
a3317 1
	 * Handle end tag.
d3322 1
a3322 1
	 * Make sure we had a select start tag.
d3325 6
a3330 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag\n"));
d3335 1
a3335 1
	 * Set to know that we are no longer in a select tag.
d3340 1
a3340 1
	 * Clear the disable attribute.
d3345 1
a3345 1
	 * Finish the data off.
d3349 1
a3349 1
	 * Finish the previous option.
d3365 1
a3365 1
	     * Start a newline after the last checkbox/button option.
d3370 2
a3371 2
	     * Output popup box with the default option to screen, but use
	     * non-breaking spaces for output.
d3376 3
a3378 3
		 * The code inadequately handles OPTION fields in PRE tags. 
		 * We'll put up a minimum of 6 characters, and if any more
		 * would exceed the wrap column, we'll ignore them.
d3389 1
a3389 1
	    for (; non_empty(ptr); ptr++) {
d3396 1
a3396 1
	     * Add end option character.
d3420 11
a3430 9
 *  This function strips white characters and
 *  generally fixes up attribute values that
 *  were received from the SGML parser and
 *  are to be treated as partial or absolute
 *  URLs. - FM
 */
int LYLegitimizeHREF(HTStructured * me, char **href,
		     BOOL force_slash,
		     BOOL strip_dots)
a3432 1
    char *p = NULL;
d3434 1
a3434 1
    const char *Base = NULL;
d3436 2
a3437 2
    if (!me || !href || isEmpty(*href))
	return (url_type);
d3441 21
a3461 49
	 * Collapse spaces in the actual URL, but just protect against tabs or
	 * newlines in the fragment, if present.  This seeks to cope with
	 * atrocities inflicted on the Web by authoring tools such as
	 * Frontpage.  - FM
	 */

	/*  Before working on spaces check if we have any, usually none. */
	for (p = *href; (*p && !isspace(*p)); p++) ;

	if (*p) {		/* p == first space character */
	    /* no reallocs below, all converted in place */

	    pound = findPoundSelector(*href);

	    if (pound != NULL && pound < p) {
		convert_to_spaces(p, FALSE);	/* done */

	    } else {
		if (pound != NULL)
		    *pound = '\0';	/* mark */

		/*
		 * No blanks really belong in the HREF,
		 * but if it refers to an actual file,
		 * it may actually have blanks in the name.
		 * Try to accommodate. See also HTParse().
		 */
		if (LYRemoveNewlines(p) || strchr(p, '\t') != 0) {
		    LYRemoveBlanks(p);	/* a compromise... */
		}

		if (pound != NULL) {
		    p = strchr(p, '\0');
		    *pound = '#';	/* restore */
		    convert_to_spaces(pound, FALSE);
		    if (p < pound)
			strcpy(p, pound);
		}
	    }
	}
    }
    if (**href == '\0')
	return (url_type);

    TRANSLATE_AND_UNESCAPE_TO_STD(href);

    Base = me->inBASE ?
	me->base_href : me->node_anchor->address;

d3463 1
a3463 1
    if (!url_type && force_slash && **href == '.' &&
d3465 10
a3474 7
	!isFILE_URL(Base)) {
	/*
	 * The Fielding RFC/ID for resolving partial HREFs says that a slash
	 * should be on the end of the preceding symbolic element for "." and
	 * "..", but all tested browsers only do that for an explicit "./" or
	 * "../", so we'll respect the RFC/ID only if force_slash was TRUE and
	 * it's not a file URL.  - FM
d3478 17
a3494 14
    if ((!url_type && LYStripDotDotURLs && strip_dots && **href == '.') &&
	!strncasecomp(Base, "http", 4)) {
	/*
	 * We will be resolving a partial reference versus an http or https
	 * URL, and it has lead dots, which may be retained when resolving via
	 * HTParse(), but the request would fail if the first element of the
	 * resultant path is two dots, because no http or https server accepts
	 * such paths, and the current URL draft, likely to become an RFC, says
	 * that it's optional for the UA to strip them as a form of error
	 * recovery.  So we will, recursively, for http/https URLs, like the
	 * "major market browsers" which made this problem so common on the
	 * Web, but we'll also issue a message about it, such that the bad
	 * partial reference might get corrected by the document provider.  -
	 * FM
d3497 1
a3497 1
	const char *str = "";
d3499 7
a3505 3
	temp = HTParse(*href, Base, PARSE_ALL);
	path = HTParse(temp, "", PARSE_PATH + PARSE_PUNCTUATION);
	if (!strncmp(path, "/..", 3)) {
d3508 2
a3509 1
		if (Base[4] == 's') {
d3512 7
a3518 5
		CTRACE((tfp,
			"LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
			*href, str));
		CTRACE((tfp, "                  Stripping lead dots.\n"));
		if (!me->inBadHREF) {
d3542 1
a3542 1
    return (url_type);
d3546 8
a3553 7
 *  This function checks for a Content-Base header,
 *  and if not present, a Content-Location header
 *  which is an absolute URL, and sets the BASE
 *  accordingly.  If set, it will be replaced by
 *  any BASE tag in the HTML stream, itself. - FM
 */
void LYCheckForContentBase(HTStructured * me)
d3557 1
a3557 1
    const char *value[HTML_BASE_ATTRIBUTES];
d3565 2
a3566 1
	 * We have a Content-Base value.  Use it if it's non-zero length.  - FM
d3574 3
a3576 2
	 * We didn't have a Content-Base value, but do have a Content-Location
	 * value.  Use it if it's an absolute URL.  - FM
d3588 2
a3589 1
	 * We had neither a Content-Base nor Content-Location value.  - FM
d3595 2
a3596 1
     * If we collapsed to a zero-length value, ignore it.  - FM
d3604 2
a3605 1
     * Pass the value to HTML_start_element as the HREF of a BASE tag.  - FM
d3608 1
a3608 1
	present[i] = NO;
d3610 3
a3612 3
    value[HTML_BASE_HREF] = (const char *) cp;
    (*me->isa->start_element) (me, HTML_BASE, present, value,
			       0, 0);
d3617 8
a3624 6
 *  This function creates NAMEd Anchors if a non-zero-length NAME
 *  or ID attribute was present in the tag. - FM
 */
void LYCheckForID(HTStructured * me, const BOOL *present,
		  const char **value,
		  int attribute)
d3633 1
a3633 1
	&& non_empty(value[attribute])) {
d3635 1
a3635 1
	 * Translate any named or numeric character references.  - FM
d3638 2
a3639 2
	LYUCTranslateHTMLString(&temp, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_URL);
d3642 1
a3642 1
	 * Create the link if we still have a non-zero-length string.  - FM
d3645 5
a3649 6
	    (ID_A = HTAnchor_findChildAndLink
	     (
		 me->node_anchor,	/* Parent */
		 temp,		/* Tag */
		 NULL,		/* Addresss */
		 (HTLinkType *) 0))) {	/* Type */
d3658 7
a3664 5
 *  This function creates a NAMEd Anchor for the ID string
 *  passed to it directly as an argument.  It assumes the
 *  does not need checking for character references. - FM
 */
void LYHandleID(HTStructured * me, const char *id)
d3669 1
a3669 1
	isEmpty(id))
d3673 1
a3673 1
     * Create the link if we still have a non-zero-length string.  - FM
d3675 5
a3679 6
    if ((ID_A = HTAnchor_findChildAndLink
	 (
	     me->node_anchor,	/* Parent */
	     id,		/* Tag */
	     NULL,		/* Addresss */
	     (HTLinkType *) 0)) != NULL) {	/* Type */
d3686 7
a3692 6
 *  This function checks whether we want to override
 *  the current default alignment for paragraphs and
 *  instead use that specified in the element's style
 *  sheet. - FM
 */
BOOLEAN LYoverride_default_alignment(HTStructured * me)
d3697 8
a3704 8
    switch (me->sp[0].tag_number) {
    case HTML_BLOCKQUOTE:
    case HTML_BQ:
    case HTML_NOTE:
    case HTML_FN:
    case HTML_ADDRESS:
	me->sp->style->alignment = HT_LEFT;
	return YES;
d3706 2
a3707 2
    default:
	break;
d3713 6
a3718 5
 *  This function inserts newlines if needed to create double spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureDoubleSpace(HTStructured * me)
d3723 2
a3724 2
    if (!HText_LastLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
d3727 2
a3728 2
    } else if (!HText_PreviousLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
d3738 6
a3743 5
 *  This function inserts a newline if needed to create single spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureSingleSpace(HTStructured * me)
d3748 2
a3749 2
    if (!HText_LastLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
d3759 5
a3763 4
 *  This function resets paragraph alignments for block
 *  elements which do not have a defined style sheet. - FM
 */
void LYResetParagraphAlignment(HTStructured * me)
d3770 2
a3771 2
	 (me->sp->style->id == ST_Normal ||
	  me->sp->style->id == ST_Preformatted))) {
d3774 1
a3774 1
	me->sp->style->alignment = (short) me->current_default_alignment;
d3780 19
a3798 18
 *  This example function checks whether the given anchor has
 *  an address with a file scheme, and if so, loads it into the
 *  the SGML parser's context->url element, which was passed as
 *  the second argument.  The handle_comment() calling function in
 *  SGML.c then calls LYDoCSI() in LYUtils.c to insert HTML markup
 *  into the corresponding stream, homologously to an SSI by an
 *  HTTP server. - FM
 *
 *  For functions similar to this but which depend on details of
 *  the HTML handler's internal data, the calling interface should
 *  be changed, and functions in SGML.c would have to make sure not
 *  to call such functions inappropriately (e.g., calling a function
 *  specific to the Lynx_HTML_Handler when SGML.c output goes to
 *  some other HTStructured object like in HTMLGen.c), or the new
 *  functions could be added to the SGML.h interface.
 */
BOOLEAN LYCheckForCSI(HTParentAnchor *anchor,
		      char **url)
d3803 1
a3803 1
    if (!isFILE_URL(anchor->address))
d3814 23
a3836 22
 *  This function is called from the SGML parser to look at comments
 *  and see whether we should collect some info from them.  Currently
 *  it only looks for comments with Message-Id and Subject info, in the
 *  exact form generated by MHonArc for archived mailing list.  If found,
 *  the info is stored in the document's HTParentAnchor.  It can later be
 *  used for generating a mail response.
 *
 *  We are extra picky here because there isn't any official definition
 *  for these kinds of comments - we might (and still can) misinterpret
 *  arbitrary comments as something they aren't.
 *
 *  If something doesn't look right, for example invalid characters, the
 *  strings are not stored.  Mail responses will use something else as
 *  the subject, probably the document URL, and will not have an
 *  In-Reply-To header.
 *
 *  All this is a hack - to do this the right way, mailing list archivers
 *  would have to agree on some better mechanism to make this kind of info
 *  from original mail headers available, for example using LINK.  - kw
 */
BOOLEAN LYCommentHacks(HTParentAnchor *anchor,
		       const char *comment)
d3838 1
a3838 1
    const char *cp = comment;
d3850 2
a3851 3

	for (cp = comment + 17; *cp; cp++) {
	    if (UCH(*cp) >= 127 || !isgraph(UCH(*cp))) {
d3861 1
a3861 1
	if (!LYUCTranslateHTMLString(&messageid, 0, 0, NO, NO, YES, st_URL))
d3864 1
a3864 1
	    if (UCH(*p) >= 127 || !isgraph(UCH(*p))) {
d3877 2
a3878 2
	if ((len = strlen(p)) >= 8 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
d3894 2
a3895 3

	for (cp = comment + 14; *cp; cp++) {
	    if (UCH(*cp) >= 127 || !isprint(UCH(*cp))) {
d3913 1
a3913 1
	if (!LYUCTranslateHTMLString(&subject, 0, 0, NO, YES, NO, st_HTML))
d3916 1
a3916 1
	    if (UCH(*p) >= 127 || !isprint(UCH(*p))) {
d3922 2
a3923 2
	if ((len = strlen(p)) >= 4 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
a3937 35
}

    /*
     * Create the Title with any left-angle-brackets converted to &lt; entities
     * and any ampersands converted to &amp; entities.  - FM
     *
     * Convert 8-bit letters to &#xUUUU to avoid dependencies from display
     * character set which may need changing.  Do NOT convert any 8-bit chars
     * if we have CJK display.  - LP
     */
void LYformTitle(char **dst,
		 const char *src)
{
    if (HTCJK == JAPANESE) {
	char *tmp_buffer = NULL;

	if ((tmp_buffer = (char *) malloc(strlen(src) + 1)) == 0)
	    outofmem(__FILE__, "LYformTitle");
	switch (kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
	case EUC:
	    TO_EUC((const unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	case SJIS:
	    TO_SJIS((const unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	default:
	    CTRACE((tfp, "\nLYformTitle: kanji_code is an unexpected value."));
	    strcpy(tmp_buffer, src);
	    break;
	}
	StrAllocCopy(*dst, tmp_buffer);
	FREE(tmp_buffer);
    } else {
	StrAllocCopy(*dst, src);
    }
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d28 1
d42 7
a67 6
#ifdef CJK_EX
    enum _state
	{ S_text, S_esc, S_dollar, S_paren,
	  S_nonascii_text, S_dollar_paren } state = S_text;
    int in_sjis = 0;
#endif
d69 1
a69 1
    if (isEmpty(p))
d111 2
a112 2
    q = typecallocn(char,
		    (strlen(*str) + (4 * amps) + (3 * lts) + (3 * gts) + 1));
a115 83
#ifdef CJK_EX
	if (HTCJK != NOCJK) {
	    switch(state) {
		case S_text:
		    if (*p == '\033') {
			state = S_esc;
			*q++ = *p;
			continue;
		    }
		    break;

		case S_esc:
		    if (*p == '$') {
			state = S_dollar;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }

		case S_dollar:
		    if (*p == '@@' || *p == 'B' || *p == 'A') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_dollar_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }

		case S_dollar_paren:
		    if (*p == 'C') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }

		case S_paren:
		    if (*p == 'B' || *p == 'J' || *p =='T') {
			state = S_text;
			*q++ = *p;
			continue;
		    } else if (*p == 'I') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    }
		    /* FALLTHRU */

		case S_nonascii_text:
		    if (*p == '\033')
			state = S_esc;
		    *q++ = *p;
		    continue;

		default:
		    break;
	    }
	    if (*(p+1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p+1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p+1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p+1))))) {
		*q++ = *p++;
		*q++ = *p;
		continue;
	    }
	}
#endif
d136 2
a137 3
    *q = '\0';
    FREE(*str);
    *str = cp;
d148 1
a148 1
    CONST char *s = str;
d150 1
a150 1
    if (isEmpty(s))
d153 5
a157 6
    while (*s && WHITE(*s) && UCH(*s) != UCH(CH_ESC))   /* S/390 -- gil -- 1669 */
	s++;
    if (s > str) {
	char *ns = str;
	while (*s) {
	    *ns++ = *s++;
d159 1
a159 1
	*ns = '\0';
d173 1
a173 1
    if (isEmpty(str))
d176 1
a176 1
    i = strlen(str) - 1;
d274 1
a274 1
		} else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {  /* S/390 -- gil -- 1686 */
d307 1
a307 1
	CONST char *,	base)
d311 1
a311 1
    if (isEmpty(*href))
d315 2
a316 2
	if (base != NULL && isFILE_URL(base)) {
	    StrAllocCopy(temp, STR_FILE_URL);
d321 1
a321 1
    if (isFILE_URL(*href)) {
d335 2
a336 2
#if defined(USE_DOS_DRIVES)
    if (LYIsDosDrive(*href))  {
d348 2
a349 1
	  && LYIsDosDrive(*href+17)) {
d354 1
a354 1
	LYAddPathSep(href);
d356 1
a356 1
#endif /* USE_DOS_DRIVES */
d363 1
a363 1
	CONST char *temp2;
d365 1
a365 1
	temp2 = HTVMS_wwwName(LYGetEnv("PATH"));
d370 1
a370 2
	if (!LYIsHtmlSep(*temp2))
	    LYAddHtmlSep(href);
d390 1
a390 1
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir())+1));
d424 1
a424 1
	FILE *,		fd,
a527 1
** Maximum length: 16 -TD
d532 1
a532 1
    static char OLstring[20];
a661 1
** Maximum length: 16 -TD
d666 1
a666 1
    static char OLstring[20];
d797 1
a797 1
	HTStructured *,		me)
d819 1
a819 1
	HTStructured *,		me)
d842 618
d1596 1
a1596 1
PUBLIC char ** LYUCFullyTranslateString ARGS9(
a1633 6
#ifdef KANJI_CODE_OVERRIDE
    static unsigned char sjis_1st = '\0';
#ifdef CONV_JISX0201KANA_JISX0208KANA
    unsigned char sjis_str[3];
#endif
#endif
d1638 1
a1638 1
    if (!str || isEmpty(*str))
d1650 1
a1650 1
    **	are both iso-8859-1 (and we are not called to back-translate),
d1653 3
a1655 5
    if (HTCJK != NOCJK) {
	no_bytetrans = TRUE;
    } else if (cs_to <= 0 && cs_from == cs_to && (!Back || cs_to < 0)) {
	no_bytetrans = TRUE;
    } else {
d1657 4
a1660 3
	no_bytetrans = (BOOL) (!use_lynx_specials && !Back &&
			       UCNeedNotTranslate(cs_from, cs_to));
    }
d1686 1
a1686 1
	from_is_utf8 = (BOOL) (LYCharSet_UC[cs_from].enc == UCT_ENC_UTF8);
d1691 1
a1691 1
	output_utf8 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8 ||
d1693 1
a1693 1
	repl_translated_C0 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_8BIT_C0);
d1733 1
a1733 21
	    code = UCH(*p);
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE && last_kcode == SJIS) {
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code)||IS_SJIS_HI2(code))){
		    sjis_1st = UCH(code);
		} else if (sjis_1st && IS_SJIS_LO(code)) {
		    sjis_1st = '\0';
		} else {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    if (0xA1 <= code && code <= 0xDF) {
			sjis_str[2] = '\0';
			JISx0201TO0208_SJIS(UCH(code),
						sjis_str, sjis_str + 1);
			REPLACE_STRING(sjis_str);
			p++;
			continue;
		    }
#endif
		}
	    }
#endif
a1773 1
	    break;
d1852 1
a1857 6
			} else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			    state = S_check_uni;
			    break;
			} else {
			    *(unsigned char *)p = UCH(160);
d1861 1
a1866 6
		    } else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			state = S_check_uni;
			break;
		    } else {
			*(unsigned char *)p = UCH(173);
d1874 1
a1874 1
		    *p = (char) rev_c;
d1889 1
a1889 1
			code = UCH(*p);
d1908 1
a1908 1
		    code = UCH(*p);
d1910 8
d1923 3
a1925 3
	    **	Substitute Lynx special character for
	    **	160 (nbsp) if use_lynx_specials is set.
	    */
d1945 2
a1946 2
		    UCH(*(pp+2)) < 127 &&
		    isxdigit(UCH(*(pp+2)))) {
d1950 2
a1951 2
			   UCH(*(pp+1)) < 127 &&
			   isdigit(UCH(*(pp+1)))) {
d1954 2
a1955 2
		} else if (UCH(*pp) < 127 &&
			   isalpha(UCH(*pp))) {
d1973 3
a1975 3
		while (*p && UCH(*p) < 127 &&
		       (what == P_hex ? isxdigit(UCH(*p)) :
					isdigit(UCH(*p)))) {
d2175 3
a2177 1
		    if (plain_space) {
d2179 1
a2179 3
			state = S_got_outchar;
			break;
		    } else if (use_lynx_specials) {
a2180 16
			state = S_got_outchar;
			break;
		    } else if ((hidden && !Back) ||
			       (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1) ||
			       LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			       (LYCharSet_UC[cs_to].like8859 &
						UCT_R_8859SPECL)) {
			state = S_got_outchar;
			break;
		    } else if (
			(LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
			;	/* nothing, may be translated later */
		    } else {
			code = ' ';
			state = S_got_outchar;
			break;
d2182 2
d2204 1
a2204 1
		    } else if (use_lynx_specials) {
d2263 1
a2263 1
		    CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
a2291 16

		    /* The following disabled section doesn't make sense
		    ** any more.  It used to make sense in the past, when
		    ** S_check_named would look in "old style" tables
		    ** in addition to what it does now.
		    ** Disabling of going to S_check_name here prevents
		    ** endless looping between S_check_uni and S_check_names
		    ** states, which could occur here for Latin 1 codes
		    ** for some cs_to if they had no translation in that
		    ** cs_to.  Normally all cs_to *should* now have valid
		    ** translations via UCTransUniChar or UCTransUniCharStr
		    ** for all Latin 1 codes, so that we would not get here
		    ** anyway, and no loop could occur.  Still, if we *do*
		    ** get here, FALL THROUGH to case S_recover now.  - kw
		    */
#if 0
a2299 1
#endif
d2304 13
a2316 13
		/*
		**  Illegal or not yet handled value.
		**  Return "&#" verbatim and continue
		**  from there. - FM
		*/
		*q++ = '&';
		*q++ = '#';
		if (what == P_hex)
		    *q++ = 'x';
		if (cpe != '\0')
		    *(p-1) = cpe;
		p = cp;
		state = S_done;
d2321 7
d2330 1
a2330 1
		 UCH(*p) >= lowest_8)) {
d2335 1
a2335 1
		code = UCH(*p);
d2342 2
a2343 2
	    while (*cp && UCH(*cp) < 127 &&
		   isalnum(UCH(*cp)))
d2347 1
d2464 1
a2464 1
	if (stype == st_URL || stype == st_other) {
d2471 1
a2471 1
	if (stype == st_URL || stype == st_other) {
d2482 1
a2482 1
PUBLIC BOOL LYUCTranslateHTMLString ARGS7(
d2493 1
a2493 1
    if (!LYUCFullyTranslateString(str, cs_from, cs_to, TRUE,
d2509 1
a2509 1
    ret = (LYUCFullyTranslateString(str, cs_from, cs_to, FALSE,
d2512 1
a2512 73
    return (BOOL) (ret != NULL);
}

/*
 * Parse a parameter from an HTML META tag, i.e., the CONTENT.
 */
PUBLIC char *LYParseTagParam ARGS2(
	char *,		from,
	char *,		name)
{
    size_t len = strlen(name);
    char *result = NULL;
    char *string = from;

    do {
	if ((string = strchr(string, ';')) == NULL)
	    return NULL;
	while (*string != '\0' && (*string == ';' || isspace(UCH(*string)))) {
	    string++;
	}
	if (strlen(string) < len) return NULL;
    } while (strncasecomp(string, name, len) != 0);
    string += len;
    while (*string != '\0' && (UCH(isspace(*string)) || *string == '=')) {
	string++;
    }

    StrAllocCopy(result, string);
    len = 0;
    while (isprint(UCH(string[len])) && string[len] != ';') {
	len++;
    }
    result[len] = '\0';

    /*
     * Strip single quotes, just in case.
     */
    if (len > 2 && result[0] == '\'' && result[len-1] == result[0]) {
	result[len-1] = '\0';
	for (string = result; (string[0] = string[1]) != '\0'; ++string)
	    ;
    }
    return result;
}

/*
 * Given a refresh-URL content string, parses the delay time and the URL
 * string.  Ignore the remainder of the content.
 */
PUBLIC void LYParseRefreshURL ARGS3(
	char *,		content,
	char **,	p_seconds,
	char **,	p_address)
{
    char *cp;
    char *cp1 = NULL;
    char *Seconds = NULL;

    /*
     *  Look for the Seconds field. - FM
     */
    cp = LYSkipBlanks(content);
    if (*cp && isdigit(UCH(*cp))) {
	cp1 = cp;
	while (*cp1 && isdigit(UCH(*cp1)))
	    cp1++;
	StrnAllocCopy(Seconds, cp, cp1 - cp);
    }
    *p_seconds = Seconds;
    *p_address = LYParseTagParam(content, "URL");

    CTRACE((tfp, "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
	   content, NonNull(*p_seconds), NonNull(*p_address)));
d2519 1
a2519 1
	HTStructured *,		me,
d2539 1
a2539 1
	LYUCTranslateHTMLString(&http_equiv, me->tag_charset, me->tag_charset,
d2541 2
d2551 1
a2551 1
	LYUCTranslateHTMLString(&name, me->tag_charset, me->tag_charset,
d2553 2
d2580 1
a2580 1
    CTRACE((tfp, "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
d2583 1
a2583 1
		(content ? content : "NULL")));
d2595 3
a2597 3
    if (!strcasecomp(NonNull(http_equiv), "Pragma") ||
	!strcasecomp(NonNull(http_equiv), "Cache-Control")) {
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
d2599 2
d2614 1
a2614 1
	    !strcasecomp(NonNull(http_equiv), "Cache-Control")) {
d2641 1
a2641 1
			if (isdigit(UCH(*cp))) {
d2643 1
a2643 1
			    while (isdigit(UCH(*cp)))
d2660 1
a2660 1
    } else if (!strcasecomp(NonNull(http_equiv), "Expires")) {
d2671 1
a2671 1
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
d2673 2
d2695 1
a2695 1
	    } else if (LYmktime(content, FALSE) == 0) {
d2711 1
a2711 1
	       !strcasecomp(NonNull(http_equiv), "Content-Type")) {
d2714 1
a2714 1
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
d2716 2
d2720 3
a2722 1
	if ((cp1 = strstr(content, "charset")) != NULL) {
a2739 23

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (Switch_Display_Charset (chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
		/* UCT_STAGE_STRUCTURED and UCT_STAGE_HTEXT
		   should have the same setting for UCInfoStage. */
		int structured = HTAnchor_getUCInfoStage(me->node_anchor,
							 UCT_STAGE_STRUCTURED);
		me->outUCLYhndl = current_char_set;
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_HTEXT,
					UCT_SETBY_MIME); /* highest priorty! */
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_STRUCTURED,
					UCT_SETBY_MIME); /* highest priorty! */
		me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor,
						     UCT_STAGE_HTEXT);
		/* The SGML stage will be reset in change_chartrans_handling */
	    }
#endif

d2831 2
a2832 2
		    = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		       isdigit(UCH(cp4[9])));
d2834 1
a2834 1
		    = (BOOL) (given_is_8859 || !strncmp(cp4, "windows-", 8) ||
d2838 1
a2838 1
		    = (BOOL) (given_is_8859like &&
d2847 1
a2847 1
			   isdigit(UCH((*cp1))))
d2861 1
a2861 1
		CTRACE((tfp,
d2863 1
a2863 1
			me->node_anchor->charset));
d2874 1
a2874 1
    } else if (!strcasecomp(NonNull(http_equiv), "Refresh")) {
d2877 12
a2888 2
	LYParseRefreshURL(content, &Seconds, &href);

d2890 19
d2913 2
a2914 1
		if (!(url_type = LYLegitimizeHREF(me, &href, TRUE, FALSE))) {
d2934 5
a2938 6

		} else {
		    /*
		     *  Check whether to fill in localhost. - FM
		     */
		    LYFillLocalFileURL(&href,
a2940 2
		}

a2959 4
	    cp = NULL;
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /* id_string seems to be used wrong below if given.
	       not that it matters much.  avoid setting it here. - kw */
d2961 1
a2961 1
		(cp = strchr(href, '#')) != NULL) {
a2964 1
#endif
d3053 1
a3053 1
    } else if (!strcasecomp(NonNull(http_equiv), "Set-Cookie")) {
d3087 2
a3088 2
PUBLIC void LYHandlePlike ARGS6(
	HTStructured *,		me,
a3091 1
	int,			align_idx,
d3134 1
a3134 1
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
d3154 1
a3154 4
	} else if ((me->List_Nesting_Level >= 0 &&
			(me->sp->style->id == ST_DivCenter ||
			 me->sp->style->id == ST_DivLeft ||
			 me->sp->style->id == ST_DivRight)) ||
d3156 2
a3157 2
			(me->sp->style->id == ST_Normal ||
			 me->sp->style->id == ST_Preformatted))) {
d3160 1
a3160 1
	    me->sp->style->alignment = (short) me->current_default_alignment;
d3164 2
a3165 2
	    if (present && present[align_idx] && value[align_idx]) {
		if (!strcasecomp(value[align_idx], "center") &&
d3168 1
a3168 1
		else if (!strcasecomp(value[align_idx], "right") &&
d3171 2
a3172 2
		else if (!strcasecomp(value[align_idx], "left") ||
			 !strcasecomp(value[align_idx], "justify"))
d3176 1
d3196 1
a3196 1
	HTStructured *,		me,
d3218 7
a3224 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag not within FORM tag\n"));
d3241 6
a3246 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d3269 3
d3275 3
a3277 2
	    CTRACE((tfp, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
			value[HTML_SELECT_SIZE]));
d3325 6
a3330 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag\n"));
d3427 1
a3427 1
	HTStructured *,		me,
a3432 1
    char *p = NULL;
d3434 1
a3434 1
    CONST char *Base = NULL;
d3436 1
a3436 1
    if (!me || !href || isEmpty(*href))
d3447 9
a3455 35

	/*  Before working on spaces check if we have any, usually none. */
	for (p = *href; (*p && !isspace(*p)); p++)
	    ;

	if (*p) {  /* p == first space character */
		   /* no reallocs below, all converted in place */

	    pound = findPoundSelector(*href);

	    if (pound != NULL && pound < p) {
		convert_to_spaces(p, FALSE);  /* done */

	    } else {
		if (pound != NULL)
		    *pound = '\0';  /* mark */

		/*
		 * No blanks really belong in the HREF,
		 * but if it refers to an actual file,
		 * it may actually have blanks in the name.
		 * Try to accommodate. See also HTParse().
		 */
		if (LYRemoveNewlines(p) || strchr(p, '\t') != 0) {
		    LYRemoveBlanks(p);  /* a compromise... */
		}

		if (pound != NULL) {
		    p = strchr(p, '\0');
		    *pound = '#';  /* restore */
		    convert_to_spaces(pound, FALSE);
		    if (p < pound)
			strcpy(p, pound);
		}
	    }
d3458 1
a3458 1
    if (**href == '\0')
d3460 2
a3461 6

    TRANSLATE_AND_UNESCAPE_TO_STD(href);

    Base = me->inBASE ?
		me->base_href : me->node_anchor->address;

d3463 1
a3463 1
    if (!url_type && force_slash && **href == '.' &&
d3465 3
a3467 1
	 !isFILE_URL(Base)) {
d3478 4
a3481 2
    if ((!url_type && LYStripDotDotURLs && strip_dots && **href == '.') &&
	 !strncasecomp(Base, "http", 4)) {
d3499 7
a3505 3
	temp = HTParse(*href, Base, PARSE_ALL);
	path = HTParse(temp, "", PARSE_PATH+PARSE_PUNCTUATION);
	if (!strncmp(path, "/..", 3)) {
d3508 2
a3509 1
		if (Base[4] == 's') {
d3512 7
a3518 4
		CTRACE((tfp, "LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
			*href, str));
		CTRACE((tfp, "                  Stripping lead dots.\n"));
		if (!me->inBadHREF) {
d3553 1
a3553 1
	HTStructured *,		me)
d3621 1
a3621 1
	HTStructured *,		me,
d3638 1
a3638 1
	LYUCTranslateHTMLString(&temp, me->tag_charset, me->tag_charset,
d3663 2
a3664 2
	HTStructured *,		me,
	CONST char *,		id)
d3723 1
a3723 1
    if (!HText_LastLineEmpty(me->text, FALSE)) {
d3727 1
a3727 1
    } else if (!HText_PreviousLineEmpty(me->text, FALSE)) {
d3748 1
a3748 1
    if (!HText_LastLineEmpty(me->text, FALSE)) {
d3770 2
a3771 2
	 (me->sp->style->id == ST_Normal ||
	  me->sp->style->id == ST_Preformatted))) {
d3774 1
a3774 1
	me->sp->style->alignment = (short) me->current_default_alignment;
d3803 1
a3803 1
    if (!isFILE_URL(anchor->address))
d3851 1
a3851 1
	    if (UCH(*cp) >= 127 || !isgraph(UCH(*cp))) {
d3861 1
a3861 1
	if (!LYUCTranslateHTMLString(&messageid, 0, 0, NO, NO, YES, st_URL))
d3864 1
a3864 1
	    if (UCH(*p) >= 127 || !isgraph(UCH(*p))) {
d3895 1
a3895 1
	    if (UCH(*cp) >= 127 || !isprint(UCH(*cp))) {
d3913 1
a3913 1
	if (!LYUCTranslateHTMLString(&subject, 0, 0, NO, YES, NO, st_HTML))
d3916 1
a3916 1
	    if (UCH(*p) >= 127 || !isprint(UCH(*p))) {
a3937 36
}

    /*
     *	Create the Title with any left-angle-brackets
     *	converted to &lt; entities and any ampersands
     *	converted to &amp; entities.  - FM
     *
     *  Convert 8-bit letters to &#xUUUU to avoid dependencies
     *  from display character set which may need changing.
     *  Do NOT convert any 8-bit chars if we have CJK display. - LP
     */
void LYformTitle ARGS2(
	char **,	dst,
	CONST char *,	src)
{
    if (HTCJK == JAPANESE) {
	char *tmp_buffer = NULL;
	if ((tmp_buffer = (char *) malloc (strlen(src)+1)) == 0)
	    outofmem(__FILE__, "LYformTitle");
	switch(kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
	case EUC:
	    TO_EUC((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	case SJIS:
	    TO_SJIS((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	default:
	    CTRACE((tfp, "\nLYformTitle: kanji_code is an unexpected value."));
	    strcpy(tmp_buffer, src);
	    break;
	}
	StrAllocCopy(*dst, tmp_buffer);
	FREE(tmp_buffer);
    } else {
	StrAllocCopy(*dst, src);
    }
@


1.1.3.2
log
@Lynx 2.8.5dev.16 intermediate patch 'c' from Thomas Dickey,
including some of the diffs I sent upstream, and more bugfixes
@
text
@d2061 1
a2061 1
    while (isprint(UCH(string[len])) && !isspace(UCH(string[len]))) {
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d44 2
a45 2
int OL_CONTINUE = -29999;     /* flag for whether CONTINUE is set */
int OL_VOID = -29998;	     /* flag for whether a count is set */
d53 3
a55 3
void LYEntify (
	char **	str,
	BOOLEAN	isTITLE)
d227 2
a228 2
void LYTrimHead (
	char * str)
d230 1
a230 1
    const char *s = str;
d251 2
a252 2
void LYTrimTail (
	char * str)
d275 2
a276 2
char *LYFindEndOfComment (
	char * str)
d388 3
a390 3
void LYFillLocalFileURL (
	char **	href,
	const char *	base)
d445 1
a445 1
	const char *temp2;
d506 3
a508 3
void LYAddMETAcharsetToFD (
	FILE *		fd,
	int		disp_chndl)
d548 2
a549 2
char *LYUppercaseA_OL_String (
	int seqnum)
d580 2
a581 2
char *LYLowercaseA_OL_String (
	int seqnum)
d613 2
a614 2
char *LYUppercaseI_OL_String (
	int seqnum)
d748 2
a749 2
char *LYLowercaseI_OL_String (
	int seqnum)
d881 2
a882 2
void LYZero_OL_Counter (
	HTStructured *		me)
d903 2
a904 2
void LYGetChartransInfo (
	HTStructured *		me)
d936 1
a936 1
static char * UCPutUtf8ToBuffer (char * q, UCode_t code, BOOL terminate)
d980 1
a980 1
static const char *hex = "0123456789ABCDEF";
d1051 1
a1051 1
**		    extern void LYExpandString (
d1053 2
a1054 2
**		       char **		       str);
**		    extern void LYUnEscapeEntities (
d1056 2
a1057 2
**		       char **		       str);
**		    extern void LYUnEscapeToLatinOne (
d1060 1
a1060 1
**		       BOOLEAN		       isURL);
d1063 10
a1072 10
char ** LYUCFullyTranslateString (
	char **	str,
	int		cs_from,
	int		cs_to,
	BOOLEAN	do_ent,
	BOOL		use_lynx_specials,
	BOOLEAN	plain_space,
	BOOLEAN	hidden,
	BOOL		Back,
	CharUtil_st	stype)
d1087 1
a1087 1
    const char * name = NULL;
d2002 8
a2009 8
BOOL LYUCTranslateHTMLString (
	char ** str,
	int	cs_from,
	int	cs_to,
	BOOL	use_lynx_specials,
	BOOLEAN	plain_space,
	BOOLEAN	hidden,
	CharUtil_st	stype)
d2021 5
a2025 5
BOOL LYUCTranslateBackFormData (
	char ** str,
	int	cs_from,
	int	cs_to,
	BOOLEAN	plain_space)
d2038 3
a2040 3
char *LYParseTagParam (
	char *		from,
	char *		name)
d2081 4
a2084 4
void LYParseRefreshURL (
	char *		content,
	char **	p_seconds,
	char **	p_address)
d2110 5
a2114 5
void LYHandleMETA (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	char **		include GCC_UNUSED)
d2668 7
a2674 7
void LYHandlePlike (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	char **		include GCC_UNUSED,
	int			align_idx,
	BOOL			start)
d2779 6
a2784 6
void LYHandleSELECT (
	HTStructured *		me,
	const BOOL*		present,
	const char **		value,
	char **		include GCC_UNUSED,
	BOOL			start)
d2994 5
a2998 5
int LYLegitimizeHREF (
	HTStructured *		me,
	char **		href,
	BOOL			force_slash,
	BOOL			strip_dots)
d3003 1
a3003 1
    const char *Base = NULL;
d3092 1
a3092 1
	const char *str = "";
d3139 2
a3140 2
void LYCheckForContentBase (
	HTStructured *		me)
d3144 1
a3144 1
    const char *value[HTML_BASE_ATTRIBUTES];
d3197 1
a3197 1
    value[HTML_BASE_HREF] = (const char *)cp;
d3207 5
a3211 5
void LYCheckForID (
	HTStructured *		me,
	const BOOL *		present,
	const char **		value,
	int			attribute)
d3249 3
a3251 3
void LYHandleID (
	HTStructured *		me,
	const char *		id)
d3278 2
a3279 2
BOOLEAN LYoverride_default_alignment (
	HTStructured * me)
d3304 2
a3305 2
void LYEnsureDoubleSpace (
	HTStructured * me)
d3329 2
a3330 2
void LYEnsureSingleSpace (
	HTStructured * me)
d3349 2
a3350 2
void LYResetParagraphAlignment (
	HTStructured * me)
d3383 3
a3385 3
BOOLEAN LYCheckForCSI (
	HTParentAnchor *	anchor,
	char **		url)
d3421 3
a3423 3
BOOLEAN LYCommentHacks (
	HTParentAnchor *	anchor,
	const char *		comment)
d3425 1
a3425 1
    const char *cp = comment;
d3536 3
a3538 3
void LYformTitle (
	char **	dst,
	const char *	src)
d3546 1
a3546 1
	    TO_EUC((const unsigned char *) src, (unsigned char *) tmp_buffer);
d3549 1
a3549 1
	    TO_SJIS((const unsigned char *) src, (unsigned char *) tmp_buffer);
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 3
a4 3
 *  Functions associated with LYCharSets.c and the Lynx version of HTML.c - FM
 *  ==========================================================================
 */
d42 1
a42 1
 * Used for nested lists.  - FM
d44 3
a46 2
int OL_CONTINUE = -29999;	/* flag for whether CONTINUE is set */
int OL_VOID = -29998;		/* flag for whether a count is set */
d49 7
a55 6
 *  This function converts any ampersands in allocated
 *  strings to "&amp;".  If isTITLE is TRUE, it also
 *  converts any angle-brackets to "&lt;" or "&gt;". - FM
 */
void LYEntify(char **str,
	      BOOLEAN isTITLE)
a59 1

d61 3
a63 8
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren
    } state = S_text;
d71 1
a71 1
     * Count the ampersands.  - FM
d79 1
a79 1
     * Count the left-angle-brackets, if needed.  - FM
d90 1
a90 1
     * Count the right-angle-brackets, if needed.  - FM
d101 1
a101 1
     * Check whether we need to convert anything.  - FM
d107 1
a107 1
     * Allocate space and convert.  - FM
d116 23
a138 8
	    switch (state) {
	    case S_text:
		if (*p == '\033') {
		    state = S_esc;
		    *q++ = *p;
		    continue;
		}
		break;
d140 14
a153 14
	    case S_esc:
		if (*p == '$') {
		    state = S_dollar;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}
d155 10
a164 14
	    case S_dollar:
		if (*p == '@@' || *p == 'B' || *p == 'A') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_dollar_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}
d166 11
a176 10
	    case S_dollar_paren:
		if (*p == 'C') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}
d178 3
a180 7
	    case S_paren:
		if (*p == 'B' || *p == 'J' || *p == 'T') {
		    state = S_text;
		    *q++ = *p;
		    continue;
		} else if (*p == 'I') {
		    state = S_nonascii_text;
a182 2
		}
		/* FALLTHRU */
d184 2
a185 8
	    case S_nonascii_text:
		if (*p == '\033')
		    state = S_esc;
		*q++ = *p;
		continue;

	    default:
		break;
d187 4
a190 4
	    if (*(p + 1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p + 1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p + 1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p + 1))))) {
d223 6
a228 5
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1) and HT_EN_SPACE (2),
 *  but not ESC, from the heads of strings. - FM
 */
void LYTrimHead(char *str)
d235 1
a235 1
    while (*s && WHITE(*s) && UCH(*s) != UCH(CH_ESC))	/* S/390 -- gil -- 1669 */
a238 1

d247 6
a252 5
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1), HT_EN_SPACE (2), and
 *  ESC from the tails of strings. - FM
 */
void LYTrimTail(char *str)
d270 7
a276 6
 * This function should receive a pointer to the start
 * of a comment.  It returns a pointer to the end ('>')
 * character of comment, or it's best guess if the comment
 * is invalid. - FM
 */
char *LYFindEndOfComment(char *str)
d279 1
a279 6
    enum comment_state {
	start1,
	start2,
	end1,
	end2
    } state;
d283 1
a283 1
	 * We got NULL, so return NULL.  - FM
d289 2
a290 2
	 * We don't have the start of a comment, so return the beginning of the
	 * string.  - FM
d295 1
a295 1
    if (*cp == '>')
d304 2
a305 2
	 * We don't have an end character, so return the beginning of the
	 * string.  - FM
d311 2
a312 2
	 * Ugh, it's a "decorative" series of dashes, so return the next end
	 * character.  - FM
d317 1
a317 1
     * OK, we're ready to start parsing.  - FM
d322 10
a331 10
	case start1:
	    if (*cp == '-')
		state = start2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;
d333 4
a336 4
	case start2:
	    if (*cp == '-')
		state = end1;
	    break;
d338 10
a347 10
	case end1:
	    if (*cp == '-')
		state = end2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;
d349 16
a364 16
	case end2:
	    if (*cp == '>')
		/*
		 * Valid comment, so return the end character.  - FM
		 */
		return cp;
	    if (*cp == '-') {
		state = start1;
	    } else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {	/* S/390 -- gil -- 1686 */
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    }
	    break;
d366 2
a367 2
	default:
	    break;
d373 2
a374 2
     * Invalid comment, so return the first '>' from the start of the string. 
     * - FM
d380 11
a390 10
 *  If an HREF, itself or if resolved against a base,
 *  represents a file URL, and the host is defaulted,
 *  force in "//localhost".  We need this until
 *  all the other Lynx code which performs security
 *  checks based on the "localhost" string is changed
 *  to assume "//localhost" when a host field is not
 *  present in file URLs - FM
 */
void LYFillLocalFileURL(char **href,
			const char *base)
d392 1
a392 1
    char *temp = NULL;
d405 1
a405 1
	if (*(*href + 5) == '\0') {
d410 5
a414 5
	    StrAllocCopy(temp, (*href + 7));
	    LYLocalFileToURL(href, temp);
	} else if (!strncmp(*href, "file:/", 6) && !LYIsHtmlSep(*(*href + 6))) {
	    StrAllocCopy(temp, (*href + 5));
	    LYLocalFileToURL(href, temp);
d417 1
d419 1
a419 1
    if (LYIsDosDrive(*href)) {
d425 1
a425 1
	LYLocalFileToURL(href, temp);
d430 2
a431 2
	&& (strlen(*href) == 19)
	&& LYIsDosDrive(*href + 17)) {
a445 1

a449 1

d455 2
a456 2
	 * Check for pathological cases - current dir has chars which MUST BE
	 * URL-escaped - kw
d466 1
d473 1
a473 1
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir()) + 1));
d481 28
a508 26
 *  This function writes a line with a META tag to an open file,
 *  which will specify a charset parameter to use when the file is
 *  read back in.  It is meant for temporary HTML files used by the
 *  various special pages which may show titles of documents.  When those
 *  files are created, the title strings normally have been translated and
 *  expanded to the display character set, so we have to make sure they
 *  don't get translated again.
 *  If the user has changed the display character set during the lifetime
 *  of the Lynx session (or, more exactly, during the time the title
 *  strings to be written were generated), they may now have different
 *  character encodings and there is currently no way to get it all right.
 *  To change this, we would have to add a variable for each string which
 *  keeps track of its character encoding.
 *  But at least we can try to ensure that reading the file after future
 *  display character set changes will give reasonable output.
 *
 *  The META tag is not written if the display character set (passed as
 *  disp_chndl) already corresponds to the charset assumption that
 *  would be made when the file is read. - KW
 *
 *  Currently this function is used for temporary files like "Lynx Info Page"
 *  and for one permanent - bookmarks (so it may be a problem if you change
 *  the display charset later: new bookmark entries may be mistranslated).
 *								 - LP
 */
void LYAddMETAcharsetToFD(FILE *fd, int disp_chndl)
d512 1
a512 1
	 * -1 means use current_char_set.
d518 1
a518 1
	 * Should not happen.
d524 1
a524 1
	 * Not need to do, so we don't.
d530 1
a530 1
	 * There shouldn't be any 8-bit characters in this case.
d535 3
a537 3
     * In other cases we don't know because UCLYhndl_for_unspec may change
     * during the lifetime of the file (by toggling raw mode or changing the
     * display character set), so proceed.
d540 2
a541 2
	    "http-equiv=\"content-type\"",
	    LYCharSet_UC[disp_chndl].MIMEname);
d545 5
a549 4
 * This function returns OL TYPE="A" strings in
 * the range of " A." (1) to "ZZZ." (18278). - FM
 */
char *LYUppercaseA_OL_String(int seqnum)
d553 1
a553 1
    if (seqnum <= 1) {
d562 2
a563 2
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
d567 3
a569 3
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 64),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
d577 5
a581 4
 * This function returns OL TYPE="a" strings in
 * the range of " a." (1) to "zzz." (18278). - FM
 */
char *LYLowercaseA_OL_String(int seqnum)
d585 1
a585 1
    if (seqnum <= 1) {
d594 2
a595 2
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
d599 3
a601 3
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 96),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
d609 6
a614 5
 * This function returns OL TYPE="I" strings in the
 * range of " I." (1) to "MMM." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYUppercaseI_OL_String(int seqnum)
d624 1
a624 1
    switch (Arabic) {
d744 6
a749 5
 * This function returns OL TYPE="i" strings in
 * range of " i." (1) to "mmm." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYLowercaseI_OL_String(int seqnum)
d759 1
a759 1
    switch (Arabic) {
d879 4
a882 3
 *  This function initializes the Ordered List counter. - FM
 */
void LYZero_OL_Counter(HTStructured * me)
d901 4
a904 3
 *  This function is used by the HTML Structured object. - KW
 */
void LYGetChartransInfo(HTStructured * me)
d928 7
a934 7
 * Given an UCS character code, will fill buffer passed in as q with the code's
 * UTF-8 encoding.
 * If terminate = YES, terminates string on success and returns pointer
 *		       to beginning.
 * If terminate = NO,	does not terminate string, and returns pointer
 *		       next char after the UTF-8 put into buffer.
 * On failure, including invalid code or 7-bit code, returns NULL.
d936 1
a936 1
static char *UCPutUtf8ToBuffer(char *q, UCode_t code, BOOL terminate)
a938 1

d940 1
a940 1
	return NULL;
d943 2
a944 2
	    *q++ = (char) (0xc0 | (code >> 6));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d946 3
a948 3
	    *q++ = (char) (0xe0 | (code >> 12));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d950 4
a953 4
	    *q++ = (char) (0xf0 | (code >> 18));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d955 5
a959 5
	    *q++ = (char) (0xf8 | (code >> 24));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d961 6
a966 6
	    *q++ = (char) (0xfc | (code >> 30));
	    *q++ = (char) (0x80 | (0x3f & (code >> 24)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
d987 86
a1072 85
 *  This function used for translations HTML special fields inside tags
 *  (ALT=, VALUE=, etc.) from charset `cs_from' to charset `cs_to'.
 *  It also unescapes non-ASCII characters from URL (#fragments !)
 *  if st_URL is active.
 *
 *  If `do_ent' is YES, it converts named entities
 *  and numeric character references (NCRs) to their `cs_to' replacements.
 *
 *  Named entities converted to unicodes.  NCRs (unicodes) converted
 *  by UCdomap.c chartrans functions.
 *  ???NCRs with values in the ISO-8859-1 range 160-255 may be converted
 *  to their HTML entity names (via old-style entities) and then translated
 *  according to the LYCharSets.c array for `cs_out'???.
 *
 *  Some characters (see descriptions in `put_special_unicodes' from SGML.c)
 *  translated in relation with the state of boolean variables
 *  `use_lynx_specials', `plain_space' and `hidden'.  It is not clear yet:
 *
 *  If plain_space is TRUE, nbsp (160) will be treated as an ASCII
 *  space (32).  If hidden is TRUE, entities will be translated
 *  (if `do_ent' is YES) but escape sequences will be passed unaltered.
 *  If `hidden' is FALSE, some characters are converted to Lynx special
 *  codes (see `put_special_unicodes') or ASCII space if `plain_space'
 *  applies).  @@@@ is `use_lynx_specials' needed, does it have any effect? @@@@
 *  If `use_lynx_specials' is YES, translate byte values 160 and 173
 *  meaning U+00A0 and U+00AD given as or converted from raw char input
 *  are converted to HT_NON_BREAK_SPACE and LY_SOFT_HYPHEN, respectively
 *  (unless input and output charset are both iso-8859-1, for compatibility
 *  with previous usage in HTML.c) even if `hidden' or `plain_space' is set.
 *
 *  If `Back' is YES, the reverse is done instead i.e., Lynx special codes
 *  in the input are translated back to character values.
 *
 *  If `Back' is YES, an attempt is made to use UCReverseTransChar() for
 *  back translation which may be more efficient. (?)
 *
 *  If `stype' is st_URL, non-ASCII characters are URL-encoded instead.
 *  The sequence of bytes being URL-encoded is the raw input character if
 *  we couldn't translate it from `cs_in' (CJK etc.); otherwise it is the
 *  UTF-8 representation if either `cs_to' requires this or if the
 *  character's Unicode value is > 255, otherwise it should be the iso-8859-1
 *  representation.
 *  No general URL-encoding occurs for displayable ASCII characters and
 *  spaces and some C0 controls valid in HTML (LF, TAB), it is expected
 *  that other functions will take care of that as appropriate.
 *
 *  Escape characters (0x1B, '\033') are
 *  - URL-encoded	if `stype'  is st_URL,	 otherwise
 *  - dropped		if `stype'  is st_other, otherwise (i.e., st_HTML)
 *  - passed		if `hidden' is TRUE or HTCJK is set, otherwise
 *  - dropped.
 *
 *  (If `stype' is st_URL or st_other most of the parameters really predefined:
 *  cs_from=cs_to, use_lynx_specials=plain_space=NO, and hidden=YES)
 *
 *
 *  Returns pointer to the char** passed in
 *		 if string translated or translation unnecessary,
 *	    NULL otherwise
 *		 (in which case something probably went wrong.)
 *
 *
 *  In general, this somehow ugly function (KW)
 *  cover three functions from v.2.7.2 (FM):
 *		    extern void LYExpandString (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeEntities (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeToLatinOne (
 *		       HTStructured *	       me,
 *		       char **		       str,
 *		       BOOLEAN		       isURL);
 */

char **LYUCFullyTranslateString(char **str,
				int cs_from,
				int cs_to,
				BOOLEAN do_ent,
				BOOL use_lynx_specials,
				BOOLEAN plain_space,
				BOOLEAN hidden,
				BOOL Back,
				CharUtil_st stype)
d1074 1
a1074 1
    char *p;
d1077 1
a1077 1
    char *cp = 0;
d1080 1
a1080 1
    char replace_buf[64];
d1087 1
a1087 1
    const char *name = NULL;
d1091 4
a1094 14
    char *puni;
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren,
	S_trans_byte,
	S_check_ent,
	S_ncr,
	S_check_uni,
	S_named,
	S_check_name,
d1096 5
a1100 16
	S_got_oututf8,
	S_got_outstring,
	S_put_urlstring,
	S_got_outchar,
	S_put_urlchar,
	S_next_char,
	S_done
    } state = S_text;
    enum _parsing_what {
	P_text,
	P_utf8,
	P_hex,
	P_decimal,
	P_named
    } what = P_text;

a1102 1

d1109 2
a1110 2
     * Make sure we have a non-empty string.  - FM
     */
d1121 6
a1126 9
     * Don't do byte translation if original AND target character sets are both
     * iso-8859-1 (and we are not called to back-translate), or if we are in
     * CJK mode.
     */
    if ((HTCJK != NOCJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& (strcmp(LYCharSet_UC[cs_from].MIMEname, "utf-8") != 0)
#endif
	) {
d1131 1
a1131 1
	/* No need to translate or examine the string any further */
d1136 2
a1137 2
     * Save malloc/calloc overhead in simple case - kw
     */
d1166 1
a1166 1
			      HText_hasUTF8OutputSet(HTMainText));
d1173 3
a1175 3
     * Create a buffer string seven times the length of the original, so we
     * have plenty of room for expansions.  - FM
     */
d1197 7
a1203 6
     * Loop through string, making conversions as needed.
     *
     * The while() checks for a non-'\0' char only for the normal text states
     * since other states may temporarily modify p or *p (which should be
     * restored before S_done!) - kw
     */
d1205 1
a1205 1
	switch (state) {
d1210 1
a1210 1
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code) || IS_SJIS_HI2(code))) {
d1219 1
a1219 1
					    sjis_str, sjis_str + 1);
d1244 3
a1246 3
		     * CJK handling not on, and not a hidden INPUT, so block
		     * escape.  - FM
		     */
d1295 1
a1295 1
	    if (*p == 'B' || *p == 'J' || *p == 'T') {
d1326 1
a1326 1
	    /* character translation goes here */
d1328 5
a1332 4
	     * Don't do anything if we have no string, or if original AND
	     * target character sets are both iso-8859-1, or if we are in CJK
	     * mode.
	     */
a1339 1

d1353 1
a1353 1
				     || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
d1357 1
a1357 1
			    *(unsigned char *) p = UCH(160);
d1367 1
a1367 1
				 || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
d1371 1
a1371 1
			*(unsigned char *) p = UCH(173);
d1390 1
a1390 1
		if (((*p) & 0xc0) == 0xc0) {
d1420 3
a1422 3
	     * Substitute Lynx special character for 160 (nbsp) if
	     * use_lynx_specials is set.
	     */
d1425 1
a1425 1
		code = ((code == 160 ? HT_NON_BREAK_SPACE : LY_SOFT_HYPHEN));
d1435 1
a1435 2
		char *pp = p + 1;

d1438 2
a1439 2
		 * Check for a numeric entity.  - FM
		 */
d1441 3
a1443 3
		    (*(pp + 1) == 'x' || *(pp + 1) == 'X') &&
		    UCH(*(pp + 2)) < 127 &&
		    isxdigit(UCH(*(pp + 2)))) {
d1447 2
a1448 2
			   UCH(*(pp + 1)) < 127 &&
			   isdigit(UCH(*(pp + 1)))) {
d1464 170
a1633 28
	    if (what == P_hex) {
		p += 3;
	    } else {		/* P_decimal */
		p += 2;
	    }
	    cp = p;
	    while (*p && UCH(*p) < 127 &&
		   (what == P_hex ? isxdigit(UCH(*p)) :
		    isdigit(UCH(*p)))) {
		p++;
	    }
	    /*
	     * Save the terminator and isolate the digit(s).  - FM
	     */
	    cpe = *p;
	    if (*p)
		*p++ = '\0';
	    /*
	     * Show the numeric entity if the value:
	     * (1) Is greater than 255 and unhandled Unicode.
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if ((((what == P_hex) ? sscanf(cp, "%lx", &lcode) :
		  sscanf(cp, "%ld", &lcode)) != 1) ||
		lcode > 0x7fffffffL || lcode < 0) {
		state = S_recover;
d1635 30
a1664 4
	    } else {
		code = lcode;
		if ((code == 1) ||
		    (code > 127 && code < 156)) {
d1666 9
a1674 13
		     * Assume these are Microsoft code points, inflicted on
		     * us by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159
		     * range and doesn't follow Unicode standards for this
		     * area.  Windows-1252 codepoints are assumed here.
		     */
		    switch (code) {
		    case 1:
			/*
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
d1676 3
a1678 5
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
d1680 6
a1685 5
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
d1687 6
a1692 5
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
d1694 12
a1705 5
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
d1707 7
a1713 5
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
d1715 3
a1717 82
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
d1721 8
a1728 38
		state = S_check_uni;
	    }
	    break;

	case S_check_uni:
	    /*
	     * Show the numeric entity if the value:
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if ((code < 32 &&
		 code != 9 && code != 10 && code != 13 &&
		 HTCJK == NOCJK) ||
		(code == 127 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
		(code > 127 && code < 160 &&
		 !HTPassHighCtrlNum)) {
		state = S_recover;
		break;
	    }
	    /*
	     * Convert the value as an unsigned char, hex escaped if isURL is
	     * set and it's 8-bit, and then recycle the terminator if it is not
	     * a semicolon.  - FM
	     */
	    if (code > 159 && stype == st_URL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 160 (nbsp), use that value if it's a hidden INPUT, otherwise
	     * use an ASCII space (32) if plain_space is TRUE, otherwise use
	     * the Lynx special character.  - FM
	     */
	    if (code == 160) {
		if (plain_space) {
		    code = ' ';
d1731 11
a1741 3
		} else if (use_lynx_specials) {
		    code = HT_NON_BREAK_SPACE;
		    state = S_got_outchar;
d1743 4
a1746 6
		} else if ((hidden && !Back)
			   || (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1)
			   || LYCharSet_UC[cs_to].enc == UCT_ENC_8859
			   || (LYCharSet_UC[cs_to].like8859 &
			       UCT_R_8859SPECL)) {
		    state = S_got_outchar;
d1748 17
a1764 6
		} else if (
			      (LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
		    ;		/* nothing, may be translated later */
		} else {
		    code = ' ';
		    state = S_got_outchar;
d1766 9
a1774 9
		}
	    }
	    /*
	     * For 173 (shy), use that value if it's a hidden INPUT, otherwise
	     * ignore it if plain_space is TRUE, otherwise use the Lynx special
	     * character.  - FM
	     */
	    if (code == 173) {
		if (plain_space) {
d1778 11
a1788 7
		} else if (Back &&
			   !(LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			     (LYCharSet_UC[cs_to].like8859 &
			      UCT_R_8859SPECL))) {
		    ;		/* nothing, may be translated later */
		} else if (hidden || Back) {
		    state = S_got_outchar;
d1790 11
a1800 2
		} else if (use_lynx_specials) {
		    code = LY_SOFT_HYPHEN;
a1802 81
		}
	    }
	    /*
	     * Seek a translation from the chartrans tables.
	     */
	    if ((uck = UCTransUniChar(code,
				      cs_to)) >= 32 &&
		uck < 256 &&
		(uck < 127 || uck >= lowest_8)) {
		code = uck;
		state = S_got_outchar;
		break;
	    } else if ((uck == -4 ||
			(repl_translated_C0 &&
			 uck > 0 && uck < 32)) &&
		/*
		 * Not found; look for replacement string.
		 */
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						cs_to,
						0) >= 0)) {
		state = S_got_outstring;
		break;
	    }
	    if (output_utf8 &&
		code > 127 && code < 0x7fffffffL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 8194 (ensp), 8195 (emsp), or 8201 (thinsp), use the
	     * character reference if it's a hidden INPUT, otherwise use an
	     * ASCII space (32) if plain_space is TRUE, otherwise use the Lynx
	     * special character.  - FM
	     */
	    if (code == 8194 || code == 8195 || code == 8201) {
		if (hidden) {
		    state = S_recover;
		} else if (plain_space) {
		    code = ' ';
		    state = S_got_outchar;
		} else {
		    code = HT_EN_SPACE;
		    state = S_got_outchar;
		}
		break;
		/*
		 * Ignore 8204 (zwnj), 8205 (zwj) 8206 (lrm), and 8207 (rlm),
		 * for now, if we got this far without finding a representation
		 * for them.
		 */
	    } else if (code == 8204 || code == 8205 ||
		       code == 8206 || code == 8207) {
		CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
		replace_buf[0] = '\0';
		state = S_got_outstring;
		break;
		/*
		 * Show the numeric entity if the value:  (1) Is greater than
		 * 255 and unhandled Unicode.
		 */
	    } else if (code > 255) {
		/*
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
		state = S_recover;
		break;
		/*
		 * If it's ASCII, or is 8-bit but HTPassEightBitNum is set or
		 * the character set is "ISO Latin 1", use it's value.  - FM
		 */
	    } else if (code < 161 ||
		       (code < 256 &&
			(HTPassEightBitNum || cs_to == LATIN1))) {
		/*
		 * No conversion needed.
		 */
		state = S_got_outchar;
		break;
d1804 14
a1817 12
		/* The following disabled section doesn't make sense any more. 
		 * It used to make sense in the past, when S_check_named would
		 * look in "old style" tables in addition to what it does now. 
		 * Disabling of going to S_check_name here prevents endless
		 * looping between S_check_uni and S_check_names states, which
		 * could occur here for Latin 1 codes for some cs_to if they
		 * had no translation in that cs_to.  Normally all cs_to
		 * *should* now have valid translations via UCTransUniChar or
		 * UCTransUniCharStr for all Latin 1 codes, so that we would
		 * not get here anyway, and no loop could occur.  Still, if we
		 * *do* get here, FALL THROUGH to case S_recover now.  - kw
		 */
d1819 8
a1826 8
		/*
		 * If we get to here, convert and handle the character as a
		 * named entity.  - FM
		 */
	    } else {
		name = HTMLGetEntityName(code - 160);
		state = S_check_name;
		break;
d1828 1
a1828 1
	    }
d1833 4
a1836 3
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
d1842 1
a1842 1
		    *(p - 1) = cpe;
d1850 2
a1851 2
		       !(HTPassEightBitRaw &&
			 UCH(*p) >= lowest_8)) {
d1874 10
a1883 10
	     * Seek the Unicode value for the named entity.
	     *
	     * !!!!  We manually recover the case of '=' terminator which is
	     * commonly found on query to CGI-scripts enclosed as href= URLs
	     * like "somepath/?x=1&yz=2" Without this dirty fix, submission of
	     * such URLs was broken if &yz string happened to be a recognized
	     * entity name.  - LP
	     */
	    if (((code = HTMLGetEntityUCValue(name)) > 0) &&
		!((cpe == '=') && (stype == st_URL))) {
d1888 3
a1890 2
	     * Didn't find the entity.  Return verbatim.
	     */
d1894 1
a1894 1
	    /* * * O U T P U T   S T A T E S * * */
d1921 1
a1921 1
		code = replace_buf[0];	/* assume string OK if first char is */
d1949 2
a1950 2
	    /*  Not a full HTEscape, only for 8bit and ctrl chars */
		(TOASCII(code) >= 127 ||	/* S/390 -- gil -- 1925 */
d1952 2
a1953 2
		state = S_put_urlchar;
		break;
d1955 1
a1955 1
		       && q != qs && *(q - 1) == 13) {
d1957 4
a1960 4
		 * If this is not a hidden string, and the current char is the
		 * LF ('\n') of a CRLF pair, drop the CR ('\r').  - KW
		 */
		*(q - 1) = *p++;
d1964 1
a1964 1
	    *q++ = (char) code;
d1969 1
a1969 1
	    REPLACE_CHAR(hex[(TOASCII(code) >> 4) & 15]);	/* S/390 -- gil -- 1944 */
d1971 1
a1971 1
	    /* fall through */
d1977 1
a1977 1
	    /* for next round */
d1983 1
a1983 1
	HTChunkPutb(CHUNK, qs, q - qs + 1);	/* also terminates */
d2002 8
a2009 7
BOOL LYUCTranslateHTMLString(char **str,
			     int cs_from,
			     int cs_to,
			     BOOL use_lynx_specials,
			     BOOLEAN plain_space,
			     BOOLEAN hidden,
			     CharUtil_st stype)
a2011 1

d2014 2
a2015 2
				  use_lynx_specials, plain_space, hidden,
				  NO, stype)) {
d2021 5
a2025 4
BOOL LYUCTranslateBackFormData(char **str,
			       int cs_from,
			       int cs_to,
			       BOOLEAN plain_space)
d2027 1
a2027 2
    char **ret;

d2030 2
a2031 2
				    NO, plain_space, YES,
				    YES, st_HTML));
d2038 3
a2040 2
char *LYParseTagParam(char *from,
		      char *name)
d2052 1
a2052 2
	if (strlen(string) < len)
	    return NULL;
d2069 4
a2072 3
    if (len > 2 && result[0] == '\'' && result[len - 1] == result[0]) {
	result[len - 1] = '\0';
	for (string = result; (string[0] = string[1]) != '\0'; ++string) ;
d2081 4
a2084 3
void LYParseRefreshURL(char *content,
		       char **p_seconds,
		       char **p_address)
d2091 1
a2091 1
     * Look for the Seconds field.  - FM
d2103 2
a2104 3
    CTRACE((tfp,
	    "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
	    content, NonNull(*p_seconds), NonNull(*p_address)));
d2108 7
a2114 5
 *  This function processes META tags in HTML streams. - FM
 */
void LYHandleMETA(HTStructured * me, const BOOL *present,
		  const char **value,
		  char **include GCC_UNUSED)
d2125 1
a2125 1
     * Load the attributes for possible use by Lynx.  - FM
d2132 1
a2132 1
				NO, NO, YES, st_other);
d2142 1
a2142 1
				NO, NO, YES, st_other);
d2150 9
a2158 7
	 * Technically, we should be creating a comma-separated list, but META
	 * tags come one at a time, and we'll handle (or ignore) them as each
	 * is received.  Also, at this point, we only trim leading and trailing
	 * blanks from the CONTENT value, without translating any named
	 * entities or numeric character references, because how we should do
	 * that depends on what type of information it contains, and whether or
	 * not any of it might be sent to the screen.  - FM
d2168 4
a2171 5
    CTRACE((tfp,
	    "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
	    (http_equiv ? http_equiv : "NULL"),
	    (name ? name : "NULL"),
	    (content ? content : "NULL")));
d2174 1
a2174 1
     * Make sure we have META name/value pairs to handle.  - FM
d2186 1
a2186 1
				NO, NO, YES, st_other);
d2193 5
a2197 3
	 * If we didn't get a Cache-Control MIME header, and the META has one,
	 * convert to lowercase, store it in the anchor element, and if we
	 * haven't yet set no_cache, check whether we should.  - FM
d2243 3
a2245 3
	/*
	 * Check for an Expires directive. - FM
	 */
d2248 8
a2255 5
	 * If we didn't get an Expires MIME header, store it in the anchor
	 * element, and if we haven't yet set no_cache, check whether we
	 * should.  Note that we don't accept a Date header via META tags,
	 * because it's likely to be untrustworthy, but do check for a Date
	 * header from a server when making the comparison.  - FM
d2258 1
a2258 1
				NO, NO, YES, st_other);
d2263 2
a2264 2
		 * The value is zero, which we treat as an absolute no-cache
		 * directive.  - FM
d2270 3
a2272 2
		 * We have a Date header, so check if the value is less than or
		 * equal to that.  - FM
d2281 2
a2282 2
		 * We don't have a Date header, and the value is in past for
		 * us.  - FM
d2289 5
a2293 4
	/*
	 * Check for a text/html Content-Type with a charset directive, if we
	 * didn't already set the charset via a server's header.  - AAC & FM
	 */
d2296 2
a2297 3
	LYUCcharset *p_in = NULL;
	LYUCcharset *p_out = NULL;

d2299 1
a2299 1
				NO, NO, YES, st_other);
d2311 1
a2311 1
	    StrAllocCopy(cp3, cp1);	/* copy to mutilate more */
d2313 1
a2313 1
			     *cp4 != ';' && *cp4 != ':' &&
d2315 1
a2315 1
		;		/* do nothing */
d2323 1
a2323 1
	    if (Switch_Display_Charset(chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
a2327 1

d2332 1
a2332 1
					UCT_SETBY_MIME);	/* highest priorty! */
d2336 1
a2336 1
					UCT_SETBY_MIME);	/* highest priorty! */
d2351 1
a2351 1
		 * Got something but we don't recognize it.
d2354 2
a2355 2
		if (chndl < 0)	/* UCLYhndl_for_unrec not defined :-( */
		    chndl = UCLYhndl_for_unspec;	/* always >= 0 */
d2372 1
a2372 1
		     * Try again.
d2380 4
a2383 4
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_HTEXT),
					    UCT_STAGE_PARSER,
					    UCT_SETBY_DEFAULT);
d2388 2
a2389 2
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_PARSER),
d2393 1
a2393 5
		if ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
		    && (p_in->enc != UCT_ENC_UTF8)
#endif
		    ) {
d2405 4
a2408 3
		 * Update the chartrans info homologously to a Content-Type
		 * MIME header with a charset parameter.  - FM
		 */
d2426 20
a2445 16
		 * Cannot translate.  If according to some heuristic the given
		 * charset and the current display character both are likely to
		 * be like ISO-8859 in structure, pretend we have some kind of
		 * match.
		 */
		BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
					     isdigit(UCH(cp4[9])));
		BOOL given_is_8859like = (BOOL) (given_is_8859
						 || !strncmp(cp4, "windows-", 8)
						 || !strncmp(cp4, "cp12", 4)
						 || !strncmp(cp4, "cp-12", 5));
		BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
							  (strstr(LYchar_set_names[current_char_set],
								  "ISO-8859") ||
							   strstr(LYchar_set_names[current_char_set],
								  "windows-")));
d2470 1
a2470 1
	 * Set the kcode element based on the charset.  - FM
d2474 3
a2476 3
	/*
	 * Check for a Refresh directive.  - FM
	 */
d2485 1
a2485 1
		 * We found a URL field, so check it out.  - FM
d2489 3
a2491 3
		     * The specs require a complete URL, but this is a
		     * Netscapism, so don't expect the author to know that.  -
		     * FM
d2495 2
a2496 1
		     * Use the document's address as the base.  - FM
d2510 1
a2510 1
		     * Check whether to fill in localhost.  - FM
d2513 2
a2514 2
				       (me->inBASE ?
					me->base_href : me->node_anchor->address));
d2518 2
a2519 2
		 * Set the no_cache flag if the Refresh URL is the same as the
		 * document's address.  - FM
d2526 3
a2528 2
		 * We didn't find a URL field, so use the document's own
		 * address and set the no_cache flag.  - FM
d2534 1
a2534 1
	     * Check for an anchor in http or https URLs.  - FM
d2548 4
a2551 3
		 * Ugh!  The META tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
d2561 4
a2564 4
							me->node_anchor,	/* Parent */
							id_string,	/* Tag */
							href,	/* Addresss */
							(void *) 0);	/* Type */
d2590 5
a2594 5
	/*
	 * Check for a suggested filename via a Content-Disposition with a
	 * filename=name.suffix in it, if we don't already have it via a server
	 * header.  - FM
	 */
d2631 3
a2633 3
	/*
	 * Check for a Set-Cookie directive.  - AK
	 */
d2636 3
a2638 3
	 * This will need to be updated when Set-Cookie/Set-Cookie2 handling is
	 * finalized.  For now, we'll still assume "historical" cookies in META
	 * directives.  - FM
d2641 1
a2641 1
			  me->base_href : me->node_anchor->address);
d2646 1
a2646 1
			 me->base_href : me->node_anchor->address));
d2651 1
a2651 1
     * Free the copies.  - FM
d2653 1
a2653 1
  free_META_copies:
d2660 15
a2674 13
 *  This function handles P elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if
 *  FALSE, an end tag.	We presently handle start
 *  and end tags identically, but this can lead to
 *  a different number of blank lines between the
 *  current paragraph and subsequent text when a P
 *  end tag is present or not in the markup. - FM
 */
void LYHandlePlike(HTStructured * me, const BOOL *present,
		   const char **value,
		   char **include GCC_UNUSED,
		   int align_idx,
		   BOOL start)
d2678 5
a2682 5
	 * FIG content should be a true block, which like P inherits the
	 * current style.  APPLET is like character elements or an ALT
	 * attribute, unless it content contains a block element.  If we
	 * encounter a P in either's content, we set flags to treat the content
	 * as a block.  - FM
d2695 4
a2698 3
	     * We're in a list.  Treat P as an instruction to create one blank
	     * line, if not already present, then fall through to handle
	     * attributes, with the "second line" margins.  - FM
d2712 3
a2714 3
	     * We're in an ADDRESS.  Treat P as an instruction to start a
	     * newline, if needed, then fall through to handle attributes.  -
	     * FM
d2717 1
a2717 1
		HText_setLastChar(me->text, ' ');	/* absorb white space */
d2737 3
a2739 3
		    (me->sp->style->id == ST_DivCenter ||
		     me->sp->style->id == ST_DivLeft ||
		     me->sp->style->id == ST_DivRight)) ||
d2741 3
a2743 3
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
	    me->sp->style->alignment = HT_LEFT;
d2754 1
a2754 1
			 !(me->List_Nesting_Level >= 0 && !me->inP))
d2764 3
a2766 2
	 * Mark that we are starting a new paragraph and don't have any of it's
	 * text yet.  - FM
d2775 10
a2784 8
 *  This function handles SELECT elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if FALSE,
 *  an end tag. - FM
 */
void LYHandleSELECT(HTStructured * me, const BOOL *present,
		    const char **value,
		    char **include GCC_UNUSED,
		    BOOL start)
d2794 1
a2794 1
	 * Initialize the disable attribute.
d2799 1
a2799 1
	 * Make sure we're in a form.
d2807 6
a2812 7
	     * We should have covered all crash possibilities with the current
	     * TagSoup parser, so we'll allow it because some people with other
	     * browsers use SELECT for "information" popups, outside of FORM
	     * blocks, though no Lynx user would do anything that awful, right? 
	     * - FM
	     */
	       /***
d2818 1
a2818 1
	 * Check for unclosed TEXTAREA.
d2826 1
a2826 1
	 * Set to know we are in a select tag.
d2831 1
a2831 1
	      value[HTML_SELECT_NAME] && *value[HTML_SELECT_NAME])) {
d2840 1
a2840 1
	    multiple = YES;
d2846 1
a2846 1
	     * Let the size be determined by the number of OPTIONs.  - FM
d2849 1
a2849 1
		    value[HTML_SELECT_SIZE]));
d2869 6
a2874 5
	     * Force a newline when we're using a popup in a PRE block and are
	     * within 7 columns from the right margin.  This will allow for the
	     * '[' popup designator and help avoid a wrap in the underscore
	     * placeholder for the retracted popup entry in the HText
	     * structure.  - FM
d2880 1
a2880 1
	LYCheckForID(me, present, value, (int) HTML_SELECT_ID);
d2889 1
a2889 1
	 * Handle end tag.
d2894 1
a2894 1
	 * Make sure we had a select start tag.
d2903 1
a2903 1
	 * Set to know that we are no longer in a select tag.
d2908 1
a2908 1
	 * Clear the disable attribute.
d2913 1
a2913 1
	 * Finish the data off.
d2917 1
a2917 1
	 * Finish the previous option.
d2933 1
a2933 1
	     * Start a newline after the last checkbox/button option.
d2938 2
a2939 2
	     * Output popup box with the default option to screen, but use
	     * non-breaking spaces for output.
d2944 3
a2946 3
		 * The code inadequately handles OPTION fields in PRE tags. 
		 * We'll put up a minimum of 6 characters, and if any more
		 * would exceed the wrap column, we'll ignore them.
d2964 1
a2964 1
	     * Add end option character.
d2988 11
a2998 9
 *  This function strips white characters and
 *  generally fixes up attribute values that
 *  were received from the SGML parser and
 *  are to be treated as partial or absolute
 *  URLs. - FM
 */
int LYLegitimizeHREF(HTStructured * me, char **href,
		     BOOL force_slash,
		     BOOL strip_dots)
d3006 1
a3006 1
	return (url_type);
d3010 5
a3014 4
	 * Collapse spaces in the actual URL, but just protect against tabs or
	 * newlines in the fragment, if present.  This seeks to cope with
	 * atrocities inflicted on the Web by authoring tools such as
	 * Frontpage.  - FM
d3018 2
a3019 1
	for (p = *href; (*p && !isspace(*p)); p++) ;
d3021 2
a3022 2
	if (*p) {		/* p == first space character */
	    /* no reallocs below, all converted in place */
d3027 1
a3027 1
		convert_to_spaces(p, FALSE);	/* done */
d3031 1
a3031 1
		    *pound = '\0';	/* mark */
d3040 1
a3040 1
		    LYRemoveBlanks(p);	/* a compromise... */
d3045 1
a3045 1
		    *pound = '#';	/* restore */
d3054 1
a3054 1
	return (url_type);
d3059 1
a3059 1
	me->base_href : me->node_anchor->address;
d3064 1
a3064 1
	!isFILE_URL(Base)) {
d3066 6
a3071 5
	 * The Fielding RFC/ID for resolving partial HREFs says that a slash
	 * should be on the end of the preceding symbolic element for "." and
	 * "..", but all tested browsers only do that for an explicit "./" or
	 * "../", so we'll respect the RFC/ID only if force_slash was TRUE and
	 * it's not a file URL.  - FM
d3076 1
a3076 1
	!strncasecomp(Base, "http", 4)) {
d3078 12
a3089 11
	 * We will be resolving a partial reference versus an http or https
	 * URL, and it has lead dots, which may be retained when resolving via
	 * HTParse(), but the request would fail if the first element of the
	 * resultant path is two dots, because no http or https server accepts
	 * such paths, and the current URL draft, likely to become an RFC, says
	 * that it's optional for the UA to strip them as a form of error
	 * recovery.  So we will, recursively, for http/https URLs, like the
	 * "major market browsers" which made this problem so common on the
	 * Web, but we'll also issue a message about it, such that the bad
	 * partial reference might get corrected by the document provider.  -
	 * FM
d3095 1
a3095 1
	path = HTParse(temp, "", PARSE_PATH + PARSE_PUNCTUATION);
d3102 1
a3102 2
		CTRACE((tfp,
			"LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
d3129 1
a3129 1
    return (url_type);
d3133 8
a3140 7
 *  This function checks for a Content-Base header,
 *  and if not present, a Content-Location header
 *  which is an absolute URL, and sets the BASE
 *  accordingly.  If set, it will be replaced by
 *  any BASE tag in the HTML stream, itself. - FM
 */
void LYCheckForContentBase(HTStructured * me)
d3152 2
a3153 1
	 * We have a Content-Base value.  Use it if it's non-zero length.  - FM
d3161 3
a3163 2
	 * We didn't have a Content-Base value, but do have a Content-Location
	 * value.  Use it if it's an absolute URL.  - FM
d3175 2
a3176 1
	 * We had neither a Content-Base nor Content-Location value.  - FM
d3182 2
a3183 1
     * If we collapsed to a zero-length value, ignore it.  - FM
d3191 2
a3192 1
     * Pass the value to HTML_start_element as the HREF of a BASE tag.  - FM
d3195 1
a3195 1
	present[i] = NO;
d3197 3
a3199 3
    value[HTML_BASE_HREF] = (const char *) cp;
    (*me->isa->start_element) (me, HTML_BASE, present, value,
			       0, 0);
d3204 8
a3211 6
 *  This function creates NAMEd Anchors if a non-zero-length NAME
 *  or ID attribute was present in the tag. - FM
 */
void LYCheckForID(HTStructured * me, const BOOL *present,
		  const char **value,
		  int attribute)
d3222 1
a3222 1
	 * Translate any named or numeric character references.  - FM
d3226 1
a3226 1
				NO, NO, YES, st_URL);
d3229 1
a3229 1
	 * Create the link if we still have a non-zero-length string.  - FM
d3233 4
a3236 4
						 me->node_anchor,	/* Parent */
						 temp,	/* Tag */
						 NULL,	/* Addresss */
						 (void *) 0))) {	/* Type */
d3245 7
a3251 5
 *  This function creates a NAMEd Anchor for the ID string
 *  passed to it directly as an argument.  It assumes the
 *  does not need checking for character references. - FM
 */
void LYHandleID(HTStructured * me, const char *id)
d3260 1
a3260 1
     * Create the link if we still have a non-zero-length string.  - FM
d3263 4
a3266 4
					     me->node_anchor,	/* Parent */
					     id,	/* Tag */
					     NULL,	/* Addresss */
					     (void *) 0)) != NULL) {	/* Type */
d3273 7
a3279 6
 *  This function checks whether we want to override
 *  the current default alignment for paragraphs and
 *  instead use that specified in the element's style
 *  sheet. - FM
 */
BOOLEAN LYoverride_default_alignment(HTStructured * me)
d3284 8
a3291 8
    switch (me->sp[0].tag_number) {
    case HTML_BLOCKQUOTE:
    case HTML_BQ:
    case HTML_NOTE:
    case HTML_FN:
    case HTML_ADDRESS:
	me->sp->style->alignment = HT_LEFT;
	return YES;
d3293 2
a3294 2
    default:
	break;
d3300 6
a3305 5
 *  This function inserts newlines if needed to create double spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureDoubleSpace(HTStructured * me)
d3311 1
a3311 1
	HText_setLastChar(me->text, ' ');	/* absorb white space */
d3315 1
a3315 1
	HText_setLastChar(me->text, ' ');	/* absorb white space */
d3325 6
a3330 5
 *  This function inserts a newline if needed to create single spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureSingleSpace(HTStructured * me)
d3336 1
a3336 1
	HText_setLastChar(me->text, ' ');	/* absorb white space */
d3346 5
a3350 4
 *  This function resets paragraph alignments for block
 *  elements which do not have a defined style sheet. - FM
 */
void LYResetParagraphAlignment(HTStructured * me)
d3367 19
a3385 18
 *  This example function checks whether the given anchor has
 *  an address with a file scheme, and if so, loads it into the
 *  the SGML parser's context->url element, which was passed as
 *  the second argument.  The handle_comment() calling function in
 *  SGML.c then calls LYDoCSI() in LYUtils.c to insert HTML markup
 *  into the corresponding stream, homologously to an SSI by an
 *  HTTP server. - FM
 *
 *  For functions similar to this but which depend on details of
 *  the HTML handler's internal data, the calling interface should
 *  be changed, and functions in SGML.c would have to make sure not
 *  to call such functions inappropriately (e.g., calling a function
 *  specific to the Lynx_HTML_Handler when SGML.c output goes to
 *  some other HTStructured object like in HTMLGen.c), or the new
 *  functions could be added to the SGML.h interface.
 */
BOOLEAN LYCheckForCSI(HTParentAnchor *anchor,
		      char **url)
d3401 23
a3423 22
 *  This function is called from the SGML parser to look at comments
 *  and see whether we should collect some info from them.  Currently
 *  it only looks for comments with Message-Id and Subject info, in the
 *  exact form generated by MHonArc for archived mailing list.  If found,
 *  the info is stored in the document's HTParentAnchor.  It can later be
 *  used for generating a mail response.
 *
 *  We are extra picky here because there isn't any official definition
 *  for these kinds of comments - we might (and still can) misinterpret
 *  arbitrary comments as something they aren't.
 *
 *  If something doesn't look right, for example invalid characters, the
 *  strings are not stored.  Mail responses will use something else as
 *  the subject, probably the document URL, and will not have an
 *  In-Reply-To header.
 *
 *  All this is a hack - to do this the right way, mailing list archivers
 *  would have to agree on some better mechanism to make this kind of info
 *  from original mail headers available, for example using LINK.  - kw
 */
BOOLEAN LYCommentHacks(HTParentAnchor *anchor,
		       const char *comment)
d3437 1
a3437 2

	for (cp = comment + 17; *cp; cp++) {
d3464 2
a3465 2
	if ((len = strlen(p)) >= 8 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
d3481 1
a3481 2

	for (cp = comment + 14; *cp; cp++) {
d3509 2
a3510 2
	if ((len = strlen(p)) >= 4 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
d3528 3
a3530 2
     * Create the Title with any left-angle-brackets converted to &lt; entities
     * and any ampersands converted to &amp; entities.  - FM
d3532 7
a3538 6
     * Convert 8-bit letters to &#xUUUU to avoid dependencies from display
     * character set which may need changing.  Do NOT convert any 8-bit chars
     * if we have CJK display.  - LP
     */
void LYformTitle(char **dst,
		 const char *src)
d3542 1
a3542 2

	if ((tmp_buffer = (char *) malloc(strlen(src) + 1)) == 0)
d3544 1
a3544 1
	switch (kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
@


1.1.3.5
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d2602 1
a2602 1
		if (*me->node_anchor->SugFname == '"') {
d2604 1
a2604 1
				     '"')) != NULL) {
d2855 1
a2855 1
	    HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 7)) {
@


1.1.3.6
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d2131 1
a2131 1
	non_empty(value[HTML_META_HTTP_EQUIV])) {
d2141 1
a2141 1
	non_empty(value[HTML_META_NAME])) {
d2151 1
a2151 1
	non_empty(value[HTML_META_CONTENT])) {
d2289 1
a2289 1
    } else if (isEmpty(me->node_anchor->charset) &&
d2588 1
a2588 1
    } else if (isEmpty(me->node_anchor->SugFname) &&
d2819 1
a2819 1
	      non_empty(value[HTML_SELECT_NAME]))) {
d2832 1
a2832 1
	    non_empty(value[HTML_SELECT_SIZE])) {
d2944 1
a2944 1
	    for (; non_empty(ptr); ptr++) {
d3194 1
a3194 1
	&& non_empty(value[attribute])) {
d3228 1
a3228 1
	isEmpty(id))
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d28 1
d46 2
a67 6
#ifdef CJK_EX
    enum _state
	{ S_text, S_esc, S_dollar, S_paren,
	  S_nonascii_text, S_dollar_paren } state = S_text;
    int in_sjis = 0;
#endif
d111 2
a112 2
    q = typecallocn(char,
		    (strlen(*str) + (4 * amps) + (3 * lts) + (3 * gts) + 1));
a115 83
#ifdef CJK_EX
	if (HTCJK != NOCJK) {
	    switch(state) {
		case S_text:
		    if (*p == '\033') {
			state = S_esc;
			*q++ = *p;
			continue;
		    }
		    break;

		case S_esc:
		    if (*p == '$') {
			state = S_dollar;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }

		case S_dollar:
		    if (*p == '@@' || *p == 'B' || *p == 'A') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_dollar_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }

		case S_dollar_paren:
		    if (*p == 'C') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }

		case S_paren:
		    if (*p == 'B' || *p == 'J' || *p =='T') {
			state = S_text;
			*q++ = *p;
			continue;
		    } else if (*p == 'I') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    }
		    /* FALLTHRU */

		case S_nonascii_text:
		    if (*p == '\033')
			state = S_esc;
		    *q++ = *p;
		    continue;

		default:
		    break;
	    }
	    if (*(p+1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p+1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p+1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p+1))))) {
		*q++ = *p++;
		*q++ = *p;
		continue;
	    }
	}
#endif
d136 2
a137 3
    *q = '\0';
    FREE(*str);
    *str = cp;
d153 1
a153 1
    while (str[i] != '\0' && WHITE(str[i]) && UCH(str[i]) != UCH(CH_ESC))   /* S/390 -- gil -- 1669 */
d274 1
a274 1
		} else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {  /* S/390 -- gil -- 1686 */
d307 1
a307 1
	CONST char *,	base)
d370 1
a370 2
	if (!LYIsHtmlSep(*temp2))
	    LYAddHtmlSep(href);
d390 1
a390 1
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir())+1));
d424 1
a424 1
	FILE *,		fd,
a527 1
** Maximum length: 16 -TD
d532 1
a532 1
    static char OLstring[20];
a661 1
** Maximum length: 16 -TD
d666 1
a666 1
    static char OLstring[20];
d797 1
a797 1
	HTStructured *,		me)
d819 1
a819 1
	HTStructured *,		me)
d842 618
d1596 1
a1596 1
PUBLIC char ** LYUCFullyTranslateString ARGS9(
a1633 6
#ifdef KANJI_CODE_OVERRIDE
    static unsigned char sjis_1st = '\0';
#ifdef CONV_JISX0201KANA_JISX0208KANA
    unsigned char sjis_str[3];
#endif
#endif
d1650 1
a1650 1
    **	are both iso-8859-1 (and we are not called to back-translate),
d1653 3
a1655 5
    if (HTCJK != NOCJK) {
	no_bytetrans = TRUE;
    } else if (cs_to <= 0 && cs_from == cs_to && (!Back || cs_to < 0)) {
	no_bytetrans = TRUE;
    } else {
d1657 4
a1660 3
	no_bytetrans = (BOOL) (!use_lynx_specials && !Back &&
			       UCNeedNotTranslate(cs_from, cs_to));
    }
d1686 1
a1686 1
	from_is_utf8 = (BOOL) (LYCharSet_UC[cs_from].enc == UCT_ENC_UTF8);
d1691 1
a1691 1
	output_utf8 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8 ||
d1693 1
a1693 1
	repl_translated_C0 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_8BIT_C0);
d1733 1
a1733 21
	    code = UCH(*p);
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE && last_kcode == SJIS) {
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code)||IS_SJIS_HI2(code))){
		    sjis_1st = UCH(code);
		} else if (sjis_1st && IS_SJIS_LO(code)) {
		    sjis_1st = '\0';
		} else {
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    if (0xA1 <= code && code <= 0xDF) {
			sjis_str[2] = '\0';
			JISx0201TO0208_SJIS(UCH(code),
						sjis_str, sjis_str + 1);
			REPLACE_STRING(sjis_str);
			p++;
			continue;
		    }
#endif
		}
	    }
#endif
a1773 1
	    break;
d1852 1
a1857 6
			} else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			    state = S_check_uni;
			    break;
			} else {
			    *(unsigned char *)p = UCH(160);
d1861 1
a1866 6
		    } else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			state = S_check_uni;
			break;
		    } else {
			*(unsigned char *)p = UCH(173);
d1874 1
a1874 1
		    *p = (char) rev_c;
d1889 1
a1889 1
			code = UCH(*p);
d1908 1
a1908 1
		    code = UCH(*p);
d1910 8
d1923 3
a1925 3
	    **	Substitute Lynx special character for
	    **	160 (nbsp) if use_lynx_specials is set.
	    */
d1945 2
a1946 2
		    UCH(*(pp+2)) < 127 &&
		    isxdigit(UCH(*(pp+2)))) {
d1950 2
a1951 2
			   UCH(*(pp+1)) < 127 &&
			   isdigit(UCH(*(pp+1)))) {
d1954 2
a1955 2
		} else if (UCH(*pp) < 127 &&
			   isalpha(UCH(*pp))) {
d1973 3
a1975 3
		while (*p && UCH(*p) < 127 &&
		       (what == P_hex ? isxdigit(UCH(*p)) :
					isdigit(UCH(*p)))) {
d2175 3
a2177 1
		    if (plain_space) {
d2179 1
a2179 3
			state = S_got_outchar;
			break;
		    } else if (use_lynx_specials) {
a2180 16
			state = S_got_outchar;
			break;
		    } else if ((hidden && !Back) ||
			       (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1) ||
			       LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			       (LYCharSet_UC[cs_to].like8859 &
						UCT_R_8859SPECL)) {
			state = S_got_outchar;
			break;
		    } else if (
			(LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
			;	/* nothing, may be translated later */
		    } else {
			code = ' ';
			state = S_got_outchar;
			break;
d2182 2
d2204 1
a2204 1
		    } else if (use_lynx_specials) {
d2263 1
a2263 1
		    CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
a2291 16

		    /* The following disabled section doesn't make sense
		    ** any more.  It used to make sense in the past, when
		    ** S_check_named would look in "old style" tables
		    ** in addition to what it does now.
		    ** Disabling of going to S_check_name here prevents
		    ** endless looping between S_check_uni and S_check_names
		    ** states, which could occur here for Latin 1 codes
		    ** for some cs_to if they had no translation in that
		    ** cs_to.  Normally all cs_to *should* now have valid
		    ** translations via UCTransUniChar or UCTransUniCharStr
		    ** for all Latin 1 codes, so that we would not get here
		    ** anyway, and no loop could occur.  Still, if we *do*
		    ** get here, FALL THROUGH to case S_recover now.  - kw
		    */
#if 0
a2299 1
#endif
d2304 13
a2316 13
		/*
		**  Illegal or not yet handled value.
		**  Return "&#" verbatim and continue
		**  from there. - FM
		*/
		*q++ = '&';
		*q++ = '#';
		if (what == P_hex)
		    *q++ = 'x';
		if (cpe != '\0')
		    *(p-1) = cpe;
		p = cp;
		state = S_done;
d2321 7
d2330 1
a2330 1
		 UCH(*p) >= lowest_8)) {
d2335 1
a2335 1
		code = UCH(*p);
d2342 2
a2343 2
	    while (*cp && UCH(*cp) < 127 &&
		   isalnum(UCH(*cp)))
d2347 1
d2482 1
a2482 1
PUBLIC BOOL LYUCTranslateHTMLString ARGS7(
d2493 1
a2493 1
    if (!LYUCFullyTranslateString(str, cs_from, cs_to, TRUE,
d2509 1
a2509 1
    ret = (LYUCFullyTranslateString(str, cs_from, cs_to, FALSE,
d2512 1
a2512 1
    return (BOOL) (ret != NULL);
d2519 1
a2519 1
	HTStructured *,		me,
d2539 1
a2539 1
	LYUCTranslateHTMLString(&http_equiv, me->tag_charset, me->tag_charset,
d2551 1
a2551 1
	LYUCTranslateHTMLString(&name, me->tag_charset, me->tag_charset,
d2580 1
a2580 1
    CTRACE((tfp, "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
d2583 1
a2583 1
		(content ? content : "NULL")));
d2597 1
a2597 1
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
d2641 1
a2641 1
			if (isdigit(UCH(*cp))) {
d2643 1
a2643 1
			    while (isdigit(UCH(*cp)))
d2671 1
a2671 1
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
d2695 1
a2695 1
	    } else if (LYmktime(content, FALSE) == 0) {
d2714 1
a2714 1
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
a2739 23

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (Switch_Display_Charset (chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
		/* UCT_STAGE_STRUCTURED and UCT_STAGE_HTEXT
		   should have the same setting for UCInfoStage. */
		int structured = HTAnchor_getUCInfoStage(me->node_anchor,
							 UCT_STAGE_STRUCTURED);
		me->outUCLYhndl = current_char_set;
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_HTEXT,
					UCT_SETBY_MIME); /* highest priorty! */
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_STRUCTURED,
					UCT_SETBY_MIME); /* highest priorty! */
		me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor,
						     UCT_STAGE_HTEXT);
		/* The SGML stage will be reset in change_chartrans_handling */
	    }
#endif

d2831 2
a2832 2
		    = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		       isdigit(UCH(cp4[9])));
d2834 1
a2834 1
		    = (BOOL) (given_is_8859 || !strncmp(cp4, "windows-", 8) ||
d2838 1
a2838 1
		    = (BOOL) (given_is_8859like &&
d2847 1
a2847 1
			   isdigit(UCH((*cp1))))
d2861 1
a2861 1
		CTRACE((tfp,
d2863 1
a2863 1
			me->node_anchor->charset));
d2881 1
a2881 1
	if (*cp && isdigit(UCH(*cp))) {
d2883 1
a2883 1
	    while (*cp1 && isdigit(UCH(*cp1)))
d2897 1
a2897 1
		    while (*cp && (*cp == '=' || isspace(UCH(*cp))))
d2900 1
a2900 1
		    while (*cp1 && !isspace(UCH(*cp1)))
a2959 3
#ifndef DONT_TRACK_INTERNAL_LINKS
	    /* id_string seems to be used wrong below if given.
	       not that it matters much.  avoid setting it here. - kw */
a2964 1
#endif
d3087 2
a3088 2
PUBLIC void LYHandlePlike ARGS6(
	HTStructured *,		me,
a3091 1
	int,			align_idx,
d3154 1
a3154 2
	} else if ((me->List_Nesting_Level >= 0 &&
		    strncmp(me->sp->style->name, "Div", 3)) ||
d3160 1
a3160 1
	    me->sp->style->alignment = (short) me->current_default_alignment;
d3164 2
a3165 2
	    if (present && present[align_idx] && value[align_idx]) {
		if (!strcasecomp(value[align_idx], "center") &&
d3168 1
a3168 1
		else if (!strcasecomp(value[align_idx], "right") &&
d3171 2
a3172 2
		else if (!strcasecomp(value[align_idx], "left") ||
			 !strcasecomp(value[align_idx], "justify"))
d3176 1
d3196 1
a3196 1
	HTStructured *,		me,
d3218 7
a3224 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag not within FORM tag\n"));
d3241 6
a3246 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d3269 3
d3275 3
a3277 2
	    CTRACE((tfp, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
			value[HTML_SELECT_SIZE]));
d3325 6
a3330 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag\n"));
d3427 1
a3427 1
	HTStructured *,		me,
d3452 1
a3452 7
	/*
	 * No blanks really belong in the HREF, but if it refers to an actual
	 * file, it may actually have blanks in the name.  Try to accommodate.
	 */
	convert_to_spaces(*href, FALSE);
	LYTrimLeading(*href);
	LYTrimTrailing(*href);
d3460 1
a3460 1
    LYUCTranslateHTMLString(href, me->tag_charset, me->tag_charset,
d3508 2
a3509 3
		if ((me->inBASE
		   ? me->base_href[4]
		   : me->node_anchor->address[4]) == 's') {
d3512 7
a3518 4
		CTRACE((tfp, "LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
			*href, str));
		CTRACE((tfp, "                  Stripping lead dots.\n"));
		if (!me->inBadHREF) {
d3553 1
a3553 1
	HTStructured *,		me)
d3621 1
a3621 1
	HTStructured *,		me,
d3638 1
a3638 1
	LYUCTranslateHTMLString(&temp, me->tag_charset, me->tag_charset,
d3663 2
a3664 2
	HTStructured *,		me,
	CONST char *,		id)
d3774 1
a3774 1
	me->sp->style->alignment = (short) me->current_default_alignment;
d3851 1
a3851 1
	    if (UCH(*cp) >= 127 || !isgraph(UCH(*cp))) {
d3861 1
a3861 1
	if (!LYUCTranslateHTMLString(&messageid, 0, 0, NO, NO, YES, st_URL))
d3864 1
a3864 1
	    if (UCH(*p) >= 127 || !isgraph(UCH(*p))) {
d3895 1
a3895 1
	    if (UCH(*cp) >= 127 || !isprint(UCH(*cp))) {
d3913 1
a3913 1
	if (!LYUCTranslateHTMLString(&subject, 0, 0, NO, YES, NO, st_HTML))
d3916 1
a3916 1
	    if (UCH(*p) >= 127 || !isprint(UCH(*p))) {
a3937 36
}

    /*
     *	Create the Title with any left-angle-brackets
     *	converted to &lt; entities and any ampersands
     *	converted to &amp; entities.  - FM
     *
     *  Convert 8-bit letters to &#xUUUU to avoid dependencies
     *  from display character set which may need changing.
     *  Do NOT convert any 8-bit chars if we have CJK display. - LP
     */
void LYformTitle ARGS2(
	char **,	dst,
	CONST char *,	src)
{
    if (HTCJK == JAPANESE) {
	char *tmp_buffer = NULL;
	if ((tmp_buffer = (char *) malloc (strlen(src)+1)) == 0)
	    outofmem(__FILE__, "LYformTitle");
	switch(kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
	case EUC:
	    TO_EUC((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	case SJIS:
	    TO_SJIS((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	default:
	    CTRACE((tfp, "\nLYformTitle: kanji_code is an unexpected value."));
	    strcpy(tmp_buffer, src);
	    break;
	}
	StrAllocCopy(*dst, tmp_buffer);
	FREE(tmp_buffer);
    } else {
	StrAllocCopy(*dst, src);
    }
@

