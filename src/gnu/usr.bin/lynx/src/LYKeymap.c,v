head	1.9;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.8
	tg-mergefixes-1-branch:1.8.0.4
	tg-mergefixes-1-base:1.8
	MIROS_X:1.8.0.2
	MIROS_X_BASE:1.8
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.01.03.00.45.58;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.20.10.26.28;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.11.20.30.41;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.23.05.52.23;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.07.15.18.16.57;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.33;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.31;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.23;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.56;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.15;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.54;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.51.49;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.11.20.16.25;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@soft merge
@
text
@/* $MirBSD: src/gnu/usr.bin/lynx/src/LYKeymap.c,v 1.8 2004/10/20 10:26:28 tg Exp $ */

#include <HTUtils.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYKeymap.h>
#include <LYCharSets.h>		/* for LYlowest_eightbit - kw */
#include <HTAccess.h>
#include <HTFormat.h>
#include <HTAlert.h>
#include <LYStrings.h>		/* for USE_KEYMAP stuff - kw */

#include <LYLeaks.h>

#ifdef EXP_KEYBOARD_LAYOUT
#include <jcuken_kb.h>
#include <yawerty_kb.h>
#include <rot13_kb.h>
#endif

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

#ifdef EXP_KEYBOARD_LAYOUT
int current_layout = 0;		/* Index into LYKbLayouts[]   */

LYKbLayout_t *LYKbLayouts[] =
{
    kb_layout_rot13,
    kb_layout_jcuken,
    kb_layout_yawerty
};

const char *LYKbLayoutNames[] =
{
    "ROT13'd keyboard layout",
    "JCUKEN Cyrillic, for AT 101-key kbd",
    "YAWERTY Cyrillic, for DEC LK201 kbd",
    (char *) 0
};
#endif /* EXP_KEYBOARD_LAYOUT */

struct _HTStream {
    HTStreamClass *isa;
};

/* * * Tables mapping LynxKeyCodes to LynxActionCodes  * * */

/*
 * Lynxkeycodes include all single-byte keys as well as codes for function keys
 * and some special purposes.  See LYStrings.h.  Extended lynxkeycode values
 * can also contain flags for modifiers and other purposes, but here only the
 * base values are mapped to lynxactioncodes.  They are called `keystrokes' in
 * lynx.cfg.
 *
 * Lynxactioncodes (confusingly, constants are named LYK_foo and typed as
 * LYKeymapCode) specify key `functions', see LYKeymap.h.
 */

/* the character gets 1 added to it before lookup,
 * so that EOF maps to 0
 */
/* *INDENT-OFF* */
LYKeymap_t keymap[KEYMAP_SIZE] = {

0,
/* EOF */

LYK_DO_NOTHING,     LYK_HOME,       LYK_PREV_PAGE,     0,
/* nul */           /* ^A */        /* ^B */       /* ^C */

LYK_ABORT,          LYK_END,        LYK_NEXT_PAGE,     0,
/* ^D */            /* ^E */        /* ^F */       /* ^G */

LYK_HISTORY,    LYK_FASTFORW_LINK,  LYK_ACTIVATE,  LYK_COOKIE_JAR,
/* bs */            /* ht */        /* nl */       /* ^K */

LYK_REFRESH,      LYK_ACTIVATE,     LYK_DOWN_TWO,      0,
/* ^L */            /* cr */        /* ^N */       /* ^O */

LYK_UP_TWO,       LYK_CHG_CENTER,   LYK_RELOAD,    LYK_TO_CLIPBOARD,
/* ^P */            /* XON */       /* ^R */       /* ^S */

LYK_TRACE_TOGGLE,       0,        LYK_SWITCH_DTD,  LYK_REFRESH,
/* ^T */            /* ^U */        /* ^V */       /* ^W */

0,                      0,              0,             0,
/* ^X */            /* ^Y */        /* ^Z */       /* ESC */

0,                      0,              0,             0,
/* ^\ */            /* ^] */        /* ^^ */       /* ^_ */

LYK_NEXT_PAGE,       LYK_SHELL,  LYK_SOFT_DQUOTES,  LYK_TOOLBAR,
/* sp */             /* ! */         /* " */        /* # */

LYK_LAST_LINK,          0,              0,          LYK_HISTORICAL,
/* $ */              /* % */         /* & */        /* ' */

LYK_UP_HALF,      LYK_DOWN_HALF, LYK_IMAGE_TOGGLE,  LYK_NEXT_PAGE,
/* ( */              /* ) */         /* * */        /* + */

LYK_EXTERN_PAGE,  LYK_PREV_PAGE, LYK_EXTERN_LINK,   LYK_WHEREIS,
/* , */              /* - */         /* . */        /* / */

LYK_F_LINK_NUM,      LYK_1,          LYK_2,         LYK_3,
/* 0 */              /* 1 */         /* 2 */        /* 3 */

LYK_4,               LYK_5,          LYK_6,         LYK_7,
/* 4 */              /* 5 */         /* 6 */        /* 7 */

LYK_8,               LYK_9,         LYK_COMMAND,    LYK_TRACE_LOG,
/* 8 */              /* 9 */         /* : */        /* ; */

LYK_UP_LINK,         LYK_INFO,     LYK_DOWN_LINK,   LYK_HELP,
/* < */              /* = */         /* > */        /* ? */

#ifndef SUPPORT_CHDIR
LYK_RAW_TOGGLE,      LYK_ADDRLIST, LYK_PREV_PAGE,   LYK_COMMENT,
/* @@ */              /* A */         /* B */        /* C */
#else
LYK_RAW_TOGGLE,      LYK_ADDRLIST, LYK_PREV_PAGE,   LYK_CHDIR,
/* @@ */              /* A */         /* B */        /* C */
#endif

LYK_DOWNLOAD,        LYK_ELGOTO,  LYK_DIRED_MENU,   LYK_ECGOTO,
/* D */              /* E */         /* F */        /* G */

#ifdef KANJI_CODE_OVERRIDE
LYK_HELP,            LYK_INDEX,      LYK_CHG_KCODE, LYK_KEYMAP,
/* H */              /* I */         /* J */        /* K */

#else
LYK_HELP,            LYK_INDEX,      LYK_JUMP,      LYK_KEYMAP,
/* H */              /* I */         /* J */        /* K */
#endif

LYK_LIST,          LYK_MAIN_MENU,    LYK_PREV,      LYK_OPTIONS,
/* L */              /* M */         /* N */        /* O */

LYK_PRINT,          LYK_ABORT,    LYK_DEL_BOOKMARK, LYK_INDEX_SEARCH,
/* P */              /* Q */         /* R */        /* S */

LYK_TAG_LINK,      LYK_PREV_DOC,    LYK_VLINKS,         0,
/* T */              /* U */         /* V */        /* W */

LYK_NOCACHE,            0,        LYK_INTERRUPT,    LYK_INLINE_TOGGLE,
/* X */              /* Y */         /* Z */        /* [ */

LYK_SOURCE,          LYK_HEAD,    LYK_FIRST_LINK,   LYK_CLEAR_AUTH,
/* \ */              /* ] */         /* ^ */        /* _ */

LYK_MINIMAL,   LYK_ADD_BOOKMARK,  LYK_PREV_PAGE,    LYK_COMMENT,
/* ` */              /* a */         /* b */        /* c */

LYK_DOWNLOAD,        LYK_EDIT,    LYK_DIRED_MENU,   LYK_GOTO,
/* d */              /* e */         /* f */        /* g */

LYK_HELP,            LYK_INDEX,      LYK_JUMP,      LYK_KEYMAP,
/* h */              /* i */         /* j */        /* k */

LYK_LIST,         LYK_MAIN_MENU,     LYK_NEXT,      LYK_OPTIONS,
/* l */              /* m */         /* n */        /* o */

LYK_PRINT,           LYK_QUIT,    LYK_DEL_BOOKMARK, LYK_INDEX_SEARCH,
/* p */              /* q */         /* r */        /* s */

LYK_TAG_LINK,     LYK_PREV_DOC,   LYK_VIEW_BOOKMARK,   0,
/* t */              /* u */         /* v */        /* w */

LYK_NOCACHE,            0,          LYK_INTERRUPT, LYK_SHIFT_LEFT,
/* x */              /* y */          /* z */       /* { */

LYK_LINEWRAP_TOGGLE, LYK_SHIFT_RIGHT, LYK_NESTED_TABLES, LYK_HISTORY,
/* | */               /* } */         /* ~ */       /* del */


/* 80..9F (illegal ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* A0..FF (permissible ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* 100..10F function key definitions in LYStrings.h */
LYK_PREV_LINK,    LYK_NEXT_LINK,    LYK_ACTIVATE,   LYK_PREV_DOC,
/* UPARROW */     /* DNARROW */     /* RTARROW */   /* LTARROW */

LYK_NEXT_PAGE,    LYK_PREV_PAGE,    LYK_HOME,       LYK_END,
/* PGDOWN */      /* PGUP */        /* HOME */      /* END */

#if (defined(_WINDOWS) || defined(__DJGPP__))

LYK_DWIMHELP,          0,              0,             0,
/* F1*/
#else

LYK_DWIMHELP,     LYK_ACTIVATE,     LYK_HOME,       LYK_END,
/* F1*/ 	  /* Do key */      /* Find key */  /* Select key */

#endif /* _WINDOWS || __DJGPP__ */

LYK_UP_TWO,       LYK_DOWN_TWO,     LYK_DO_NOTHING, LYK_FASTBACKW_LINK,
/* Insert key */  /* Remove key */  /* DO_NOTHING*/ /* Back tab */

/* 110..18F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,             LYK_DO_NOTHING,      0,             0,
               /* 0x11d: MOUSE_KEY */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
#ifdef DJGPP_KEYHANDLER
   0,                  LYK_ABORT,      0,             0,
                       /* ALT_X */
#else
   0,                  0,              0,             0,
#endif /* DJGPP_KEYHANDLER */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 190..20F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(USE_SLANG) /* PDCurses */
   LYK_ABORT,          0,              0,             0,
   /* ALT_X */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              LYK_WHEREIS,   0,
                                       /* KP_SLASH */
   0,                  0,              0,           LYK_IMAGE_TOGGLE,
                                                    /* KP_* */
   LYK_PREV_PAGE,      LYK_NEXT_PAGE,  0,             0,
   /* KP_- */          /* KP_+ */
#else
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
#endif /* (_WINDOWS || __DJGPP__ || __CYGWIN__) && !USE_SLANG */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 210..28F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   /* 290...293 */
   LYK_CHANGE_LINK,    0,              0,             0,
};

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
/*
 * This table is used to override the standard keyboard assignments
 * when lynx_edit_mode is in effect and keyboard overrides have been
 * allowed at compile time.
 */

LYKeymap_t key_override[KEYMAP_SIZE] = {

    0,
/* EOF */

    0,                  0,              0,            0,
/* nul */           /* ^A */        /* ^B */      /* ^C */

    0,                  0,              0,            0,
/* ^D */            /* ^E */        /* ^F */      /* ^G */

    0,                  0,              0,            0,
/* bs */            /* ht */        /* nl */      /* ^K */

    0,                  0,              0,            0,
/* ^L */            /* cr */        /* ^N */      /* ^O */

    0,                  0,              0,            0,
/* ^P */            /* XON */       /* ^R */      /* XOFF */

    0,            LYK_PREV_DOC,         0,            0,
/* ^T */            /* ^U */        /* ^V */      /* ^W */

    0,                  0,              0,            0,
/* ^X */            /* ^Y */        /* ^Z */      /* ESC */

    0,                  0,              0,            0,
/* ^\ */            /* ^] */        /* ^^ */      /* ^_ */

    0,                 0,              0,            0,
/* sp */            /* ! */         /* " */       /* # */

   0,                  0,              0,            0,
/* $ */             /* % */         /* & */       /* ' */

    0,                 0,              0,            0,
/* ( */             /* ) */         /* * */       /* + */

    0,                 0,         LYK_TAG_LINK,      0,
/* , */             /* - */         /* . */       /* / */

   0,                  0,              0,            0,
/* 0 */             /* 1 */         /* 2 */       /* 3 */

   0,                  0,              0,            0,
/* 4 */             /* 5 */         /* 6 */       /* 7 */

   0,                  0,              0,             0,
/* 8 */             /* 9 */         /* : */        /* ; */

   0,                  0,              0,             0,
/* < */             /* = */         /* > */        /* ? */
#ifndef SUPPORT_CHDIR
   0,                  0,              0,         LYK_CREATE,
/* @@ */             /* A */         /* B */        /* C */
#else
   0,                  0,              0,         LYK_CHDIR,
/* @@ */             /* A */         /* B */        /* C */
#endif

   0,                  0,        LYK_DIRED_MENU,       0,
/* D */             /* E */         /* F */        /* G */

   0,                  0,              0,             0,
/* H */             /* I */         /* J */        /* K */

   0,             LYK_MODIFY,          0,             0,
/* L */             /* M */         /* N */        /* O */

   0,                  0,         LYK_REMOVE,         0,
/* P */             /* Q */         /* R */        /* S */

LYK_TAG_LINK,     LYK_UPLOAD,          0,             0,
/* T */             /* U */         /* V */        /* W */

   0,                  0,              0,             0,
/* X */             /* Y */         /* Z */        /* [ */

   0,                  0,              0,             0,
/* \ */             /* ] */         /* ^ */        /* _ */

0,                     0,              0,         LYK_CREATE,
/* ` */             /* a */         /* b */        /* c */

   0,                  0,       LYK_DIRED_MENU,       0,
/* d */             /* e */         /* f */        /* g */

   0,                  0,              0,             0,
/* h */             /* i */         /* j */        /* k */

0,                LYK_MODIFY,          0,             0,
/* l */             /* m */         /* n */        /* o */

   0,                  0,          LYK_REMOVE,        0,
/* p */             /* q */         /* r */        /* s */

LYK_TAG_LINK,      LYK_UPLOAD,         0,             0,
/* t */             /* u */         /* v */         /* w */

   0,                  0,               0,            0,
/* x */             /* y */          /* z */       /* { */

   0,                   0,             0,              0,
/* | */              /* } */         /* ~ */       /* del */

/* 80..9F (illegal ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* A0..FF (permissible ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* 100..10F function key definitions in LYStrings.h */
   0,                   0,             0,              0,
/* UPARROW */     /* DNARROW */     /* RTARROW */   /* LTARROW */

   0,                  0,              0,              0,
/* PGDOWN */      /* PGUP */        /* HOME */      /* END */

   0,                  0,              0,              0,
/* F1*/ 	  /* Do key */      /* Find key */  /* Select key */

   0,                  0,           LYK_DO_NOTHING,    0,
/* Insert key */  /* Remove key */  /* DO_NOTHING */ /* Back tab */

/* 110..18F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 190..20F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 210..28F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   /* 290...293 */
   0,                  0,              0,             0,
};
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

#define DATA(code, name, doc) { code, name, doc }
/* The order of this array must match the LYKeymapCode enum in LYKeymap.h */
static Kcmd revmap[] = {
    DATA(
	LYK_UNKNOWN, "UNMAPPED",
	NULL ),
    DATA(
	LYK_COMMAND, "COMMAND",
	"prompt for, execute a command" ),
    DATA(
	LYK_1, "1",
	NULL ),
    DATA(
	LYK_2, "2",
	NULL ),
    DATA(
	LYK_3, "3",
	NULL ),
    DATA(
	LYK_4, "4",
	NULL ),
    DATA(
	LYK_5, "5",
	NULL ),
    DATA(
	LYK_6, "6",
	NULL ),
    DATA(
	LYK_7, "7",
	NULL ),
    DATA(
	LYK_8, "8",
	NULL ),
    DATA(
	LYK_9, "9",
	NULL ),
    DATA(
	LYK_SOURCE, "SOURCE",
	"toggle source/presentation for current document" ),
    DATA(
	LYK_RELOAD, "RELOAD",
	"reload the current document" ),
    DATA(
	LYK_QUIT, "QUIT",
	"quit the browser" ),
    DATA(
	LYK_ABORT, "ABORT",
	"quit the browser unconditionally" ),
    DATA(
	LYK_NEXT_PAGE, "NEXT_PAGE",
	"view the next page of the document" ),
    DATA(
	LYK_PREV_PAGE, "PREV_PAGE",
	"view the previous page of the document" ),
    DATA(
	LYK_UP_TWO, "UP_TWO",
	"go back two lines in the document" ),
    DATA(
	LYK_DOWN_TWO, "DOWN_TWO",
	"go forward two lines in the document" ),
    DATA(
	LYK_UP_HALF, "UP_HALF",
	"go back half a page in the document" ),
    DATA(
	LYK_DOWN_HALF, "DOWN_HALF",
	"go forward half a page in the document" ),
    DATA(
	LYK_REFRESH, "REFRESH",
	"refresh the screen to clear garbled text" ),
    DATA(
	LYK_HOME, "HOME",
	"go to the beginning of the current document" ),
    DATA(
	LYK_END, "END",
	"go to the end of the current document" ),
    DATA(
	LYK_FIRST_LINK, "FIRST_LINK",
	"make the first link on the line current" ),
    DATA(
	LYK_LAST_LINK, "LAST_LINK",
	"make the last link on the line current" ),
    DATA(
	LYK_PREV_LINK, "PREV_LINK",
	"make the previous link current" ),
    DATA(
	LYK_NEXT_LINK, "NEXT_LINK",
	"make the next link current" ),
    DATA(
	LYK_LPOS_PREV_LINK, "LPOS_PREV_LINK",
	"make previous link current, same column for input" ),
    DATA(
	LYK_LPOS_NEXT_LINK, "LPOS_NEXT_LINK",
	"make next link current, same column for input" ),
    DATA(
	LYK_FASTBACKW_LINK, "FASTBACKW_LINK",
	"previous link or text area, only stops on links" ),
    DATA(
	LYK_FASTFORW_LINK, "FASTFORW_LINK",
	"next link or text area, only stops on links" ),
    DATA(
	LYK_UP_LINK, "UP_LINK",
	"move up the page to a previous link" ),
    DATA(
	LYK_DOWN_LINK, "DOWN_LINK",
	"move down the page to another link" ),
    DATA(
	LYK_RIGHT_LINK, "RIGHT_LINK",
	"move right to another link" ),
    DATA(
	LYK_LEFT_LINK, "LEFT_LINK",
	"move left to a previous link" ),
    DATA(
	LYK_HISTORY, "HISTORY",
	"display stack of currently-suspended documents" ),
    DATA(
	LYK_PREV_DOC, "PREV_DOC",
	"go back to the previous document" ),
    DATA(
	LYK_NEXT_DOC, "NEXT_DOC",
	"undo going back to the previous document" ),
    DATA(
	LYK_ACTIVATE, "ACTIVATE",
	"go to the document given by the current link" ),
    DATA(
	LYK_SUBMIT, "MOUSE_SUBMIT",
	"DO NOT MAP:  follow current link, submit" ),
    DATA(
	LYK_GOTO, "GOTO",
	"go to a document given as a URL" ),
    DATA(
	LYK_ECGOTO, "ECGOTO",
	"edit the current document's URL and go to it" ),
    DATA(
	LYK_HELP, "HELP",
	"display help on using the browser" ),
    DATA(
	LYK_DWIMHELP, "DWIMHELP",
	"display help page that may depend on context" ),
    DATA(
	LYK_INDEX, "INDEX",
	"display an index of potentially useful documents" ),
    DATA(
	LYK_NOCACHE, "NOCACHE",
	"force submission of form or link with no-cache" ),
    DATA(
	LYK_INTERRUPT, "INTERRUPT",
	"interrupt network connection or transmission" ),
    DATA(
	LYK_MAIN_MENU, "MAIN_MENU",
	"return to the first screen (home page)" ),
    DATA(
	LYK_OPTIONS, "OPTIONS",
	"display and change option settings" ),
    DATA(
	LYK_INDEX_SEARCH, "INDEX_SEARCH",
	"allow searching of an index" ),
    DATA(
	LYK_WHEREIS, "WHEREIS",
	"search within the current document" ),
    DATA(
	LYK_PREV, "PREV",
	"search for the previous occurence" ),
    DATA(
	LYK_NEXT, "NEXT",
	"search for the next occurence" ),
    DATA(
	LYK_COMMENT, "COMMENT",
	"send a comment to the author of the current document" ),
    DATA(
	LYK_EDIT, "EDIT",
	"edit the current document or a form's textarea" ),
    DATA(
	LYK_INFO, "INFO",
	"display information on the current document and link" ),
    DATA(
	LYK_PRINT, "PRINT",
	"display choices for printing the current document" ),
    DATA(
	LYK_ADD_BOOKMARK, "ADD_BOOKMARK",
	"add to your personal bookmark list" ),
    DATA(
	LYK_DEL_BOOKMARK, "DEL_BOOKMARK",
	"delete from your personal bookmark list" ),
    DATA(
	LYK_VIEW_BOOKMARK, "VIEW_BOOKMARK",
	"view your personal bookmark list" ),
    DATA(
	LYK_VLINKS, "VLINKS",
	"list links visited during the current Lynx session" ),
    DATA(
	LYK_SHELL, "SHELL",
	"escape from the browser to the system" ),
    DATA(
	LYK_DOWNLOAD, "DOWNLOAD",
	"download the current link to your computer" ),
    DATA(
	LYK_TRACE_TOGGLE, "TRACE_TOGGLE",
	"toggle tracing of browser operations" ),
    DATA(
	LYK_TRACE_LOG, "TRACE_LOG",
	"view trace log if started in the current session" ),
    DATA(
	LYK_IMAGE_TOGGLE, "IMAGE_TOGGLE",
	"toggle handling of all images as links" ),
    DATA(
	LYK_INLINE_TOGGLE, "INLINE_TOGGLE",
	"toggle pseudo-ALTs for inlines with no ALT string" ),
    DATA(
	LYK_HEAD, "HEAD",
	"send a HEAD request for the current document or link" ),
    DATA(
	LYK_DO_NOTHING, "DO_NOTHING",
	NULL ),
    DATA(
	LYK_TOGGLE_HELP, "TOGGLE_HELP",
	"show other commands in the novice help menu" ),
    DATA(
	LYK_JUMP, "JUMP",
	"go directly to a target document or action" ),
    DATA(
	LYK_KEYMAP, "KEYMAP",
	"display the current key map" ),
    DATA(
	LYK_LIST, "LIST",
	"list the references (links) in the current document" ),
    DATA(
	LYK_TOOLBAR, "TOOLBAR",
	"go to Toolbar or Banner in the current document" ),
    DATA(
	LYK_HISTORICAL, "HISTORICAL",
	"toggle historical vs.  valid/minimal comment parsing" ),
    DATA(
	LYK_MINIMAL, "MINIMAL",
	"toggle minimal vs.  valid comment parsing" ),
    DATA(
	LYK_SOFT_DQUOTES, "SOFT_DQUOTES",
	"toggle valid vs.  soft double-quote parsing" ),
    DATA(
	LYK_RAW_TOGGLE, "RAW_TOGGLE",
	"toggle raw 8-bit translations or CJK mode ON or OFF" ),
    DATA(
	LYK_COOKIE_JAR, "COOKIE_JAR",
	"examine the Cookie Jar" ),
    DATA(
	LYK_F_LINK_NUM, "F_LINK_NUM",
	"invoke the 'Follow link (or page) number:' prompt" ),
    DATA(
	LYK_CLEAR_AUTH, "CLEAR_AUTH",
	"clear all authorization info for this session" ),
    DATA(
	LYK_SWITCH_DTD, "SWITCH_DTD",
	"switch between two ways of parsing HTML" ),
    DATA(
	LYK_ELGOTO, "ELGOTO",
	"edit the current link's URL or ACTION and go to it" ),
    DATA(
	LYK_CHANGE_LINK, "CHANGE_LINK",
	"force reset of the current link on the page" ),
    DATA(
	LYK_DWIMEDIT, "DWIMEDIT",
	"use external editor for context-dependent purpose" ),
    DATA(
	LYK_EDIT_TEXTAREA, "EDITTEXTAREA",
	"use an external editor to edit a form's textarea" ),
    DATA(
	LYK_GROW_TEXTAREA, "GROWTEXTAREA",
	"add 5 new blank lines to the bottom of a textarea" ),
    DATA(
	LYK_INSERT_FILE, "INSERTFILE",
	"insert file into a textarea (just above cursorline)" ),
#ifdef EXP_ADDRLIST_PAGE
    DATA(
	LYK_ADDRLIST, "ADDRLIST",
	"like LIST command, but always shows the links' URLs" ),
#endif
#ifdef USE_EXTERNALS
    DATA(
	LYK_EXTERN_LINK, "EXTERN_LINK",
	"run external program with current link" ),
    DATA(
	LYK_EXTERN_PAGE, "EXTERN_PAGE",
	"run external program with current page" ),
#endif
#ifdef VMS
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"invoke File/Directory Manager, if available" ),
#else
#ifdef DIRED_SUPPORT
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"display a full menu of file operations" ),
    DATA(
	LYK_CREATE, "CREATE",
	"create a new file or directory" ),
    DATA(
	LYK_REMOVE, "REMOVE",
	"remove a file or directory" ),
    DATA(
	LYK_MODIFY, "MODIFY",
	"modify the name or location of a file or directory" ),
    DATA(
	LYK_TAG_LINK, "TAG_LINK",
	"tag a file or directory for later action" ),
    DATA(
	LYK_UPLOAD, "UPLOAD",
	"upload from your computer to the current directory" ),
    DATA(
	LYK_INSTALL, "INSTALL",
	"install file or tagged files into a system area" ),
#endif /* DIRED_SUPPORT */
    DATA(
	LYK_CHG_CENTER, "CHANGE_CENTER",
	"toggle center alignment in HTML TABLE" ),
#ifdef KANJI_CODE_OVERRIDE
    DATA(
	LYK_CHG_KCODE, "CHANGE_KCODE",
	"Change Kanji code" ),
#endif
#endif /* VMS */
#ifdef SUPPORT_CHDIR
    DATA(
	LYK_CHDIR, "CHDIR",
	"change current directory" ),
#endif
#ifdef USE_CURSES_PADS
    DATA(
	LYK_SHIFT_LEFT, "SHIFT_LEFT",
	"shift the screen left" ),
    DATA(
	LYK_SHIFT_RIGHT, "SHIFT_RIGHT",
	"shift the screen right" ),
    DATA(
	LYK_LINEWRAP_TOGGLE, "LINEWRAP_TOGGLE",
	"toggle linewrap on/off" ),
#endif
#ifdef CAN_CUT_AND_PASTE
    DATA(
	LYK_PASTE_URL, "PASTE_URL",
	"Goto the URL in the clipboard" ),
    DATA(
	LYK_TO_CLIPBOARD, "TO_CLIPBOARD",
	"link's URL to Clip Board" ),
#endif
#ifdef EXP_NESTED_TABLES
    DATA(
	LYK_NESTED_TABLES, "NESTED_TABLES",
	"toggle nested-table parsing on/off" ),
#endif
    DATA(
	LYK_UNKNOWN, NULL,
	"" )
};
#undef DATA

static const struct {
    int key;
    const char *name;
} named_keys[] = {
    { '\t',		"<tab>" },
    { '\r',		"<return>" },
    { CH_ESC,		"ESC" },
    { ' ',		"<space>" },
    { '<',		"<" },
    { '>',		">" },
    { CH_DEL,		"<delete>" },
    { UPARROW,		"Up Arrow" },
    { DNARROW,		"Down Arrow" },
    { RTARROW,		"Right Arrow" },
    { LTARROW,		"Left Arrow" },
    { PGDOWN,		"Page Down" },
    { PGUP,		"Page Up" },
    { HOME,		"Home" },
    { END_KEY,		"End" },
    { F1,		"F1" },
    { DO_KEY,		"Do key" },
    { FIND_KEY,		"Find key" },
    { SELECT_KEY,	"Select key" },
    { INSERT_KEY,	"Insert key" },
    { REMOVE_KEY,	"Remove key" },
    { DO_NOTHING,	"(DO_NOTHING)" },
    { BACKTAB_KEY,	"Back Tab" },
    { MOUSE_KEY,	"mouse pseudo key" },
};

struct emap {
    const char *name;
    const int   code;
    const char *descr;
};

static struct emap ekmap[] = {
  {"NOP",	LYE_NOP,	"Do Nothing"},
  {"CHAR",	LYE_CHAR,	"Insert printable char"},
  {"ENTER",	LYE_ENTER,	"Input complete, return char/lynxkeycode"},
  {"TAB",	LYE_TAB,	"Input complete, return TAB"},
  {"STOP",	LYE_STOP,	"Input deactivated"},
  {"ABORT",	LYE_ABORT,	"Input cancelled"},

  {"PASS",	LYE_FORM_PASS,  "In fields: input complete, or Do Nothing"},

  {"DELN",	LYE_DELN,	"Delete next/curr char"},
  {"DELP",	LYE_DELP,	"Delete prev      char"},
  {"DELNW",	LYE_DELNW,	"Delete next word"},
  {"DELPW",	LYE_DELPW,	"Delete prev word"},

  {"ERASE",	LYE_ERASE,	"Erase the line"},

  {"BOL",	LYE_BOL,	"Go to begin of line"},
  {"EOL",	LYE_EOL,	"Go to end   of line"},
  {"FORW",	LYE_FORW,	"Cursor forwards"},
  {"FORW_RL",	LYE_FORW_RL,	"Cursor forwards or right link"},
  {"BACK",	LYE_BACK,	"Cursor backwards"},
  {"BACK_LL",	LYE_BACK_LL,	"Cursor backwards or left link"},
  {"FORWW",	LYE_FORWW,	"Word forward"},
  {"BACKW",	LYE_BACKW,	"Word back"},

  {"LOWER",	LYE_LOWER,	"Lower case the line"},
  {"UPPER",	LYE_UPPER,	"Upper case the line"},

  {"LKCMD",	LYE_LKCMD,	"Invoke command prompt"},

  {"AIX",	LYE_AIX,	"Hex 97"},

  {"DELBL",	LYE_DELBL,	"Delete back to BOL"},
  {"DELEL",	LYE_DELEL,	"Delete thru EOL"},

  {"SWMAP",	LYE_SWMAP,	"Switch input keymap"},

  {"TPOS",	LYE_TPOS,	"Transpose characters"},

  {"SETM1",	LYE_SETM1,	"Set modifier 1 flag"},
  {"SETM2",	LYE_SETM2,	"Set modifier 2 flag"},
  {"UNMOD",	LYE_UNMOD,	"Fall back to no-modifier command"},

  {"C1CHAR",	LYE_C1CHAR,	"Insert C1 char if printable"},

  {"SETMARK",	LYE_SETMARK,	"emacs-like set-mark-command"},
  {"XPMARK",	LYE_XPMARK,	"emacs-like exchange-point-and-mark"},
  {"KILLREG",	LYE_KILLREG,	"emacs-like kill-region"},
  {"YANK",	LYE_YANK,	"emacs-like yank"},
#ifdef CAN_CUT_AND_PASTE
  {"PASTE",	LYE_PASTE,	"ClipBoard to Lynx"},
#endif
};
/* *INDENT-ON* */

/*
 * Build a list of Lynx's commands, for use in the tab-completion in LYgetstr.
 */
HTList *LYcommandList(void)
{
    static HTList *myList = NULL;

    if (myList == NULL) {
	unsigned j;

	myList = HTList_new();
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].doc != 0) {
		char *data = NULL;

		StrAllocCopy(data, revmap[j].name);
		HTList_addObject(myList, data);
	    }
	}
    }
    return myList;
}

/*
 * Find the given keycode.
 */
Kcmd *LYKeycodeToKcmd(LYKeymapCode code)
{
    unsigned j;
    Kcmd *result = 0;

    if (code > LYK_UNKNOWN) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].code == code) {
		result = revmap + j;
		break;
	    }
	}
    }
    return result;
}

/*
 * Find the given command-name, accepting an abbreviation if it is unique.
 */
Kcmd *LYStringToKcmd(const char *name)
{
    unsigned need = strlen(name);
    unsigned j;
    BOOL exact = FALSE;
    Kcmd *result = 0;
    Kcmd *maybe = 0;

    if (non_empty(name)) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (!strcasecomp(revmap[j].name, name)) {
		result = revmap + j;
		break;
	    } else if (!exact
		       && !strncasecomp(revmap[j].name, name, need)) {
		if (maybe == 0) {
		    maybe = revmap + j;
		} else {
		    if (revmap[j].name[need] != 0
			&& maybe->name[need] != 0) {
			maybe = 0;
			exact = TRUE;
		    }
		}
	    }
	}
    }
    return (result != 0) ? result : maybe;
}

char *LYKeycodeToString(int c,
			BOOLEAN upper8)
{
    static char buf[30];
    unsigned n;
    BOOLEAN named = FALSE;

    for (n = 0; n < TABLESIZE(named_keys); n++) {
	if (named_keys[n].key == c) {
	    named = TRUE;
	    strcpy(buf, named_keys[n].name);
	    break;
	}
    }

    if (!named) {
	if (c > ' '
	    && c < 0177)
	    sprintf(buf, "%c", c);
	else if (upper8
		 && c > ' '
		 && c <= 0377
		 && c <= LYlowest_eightbit[current_char_set])
	    sprintf(buf, "%c", c);
	else if (c < ' ')
	    sprintf(buf, "^%c", c | 0100);
	else if (c >= 0400)
	    sprintf(buf, "key-0x%x", c);
	else
	    sprintf(buf, "0x%x", c);
    }
    return buf;
}

int LYStringToKeycode(char *src)
{
    unsigned n;
    int key = -1;
    int len = strlen(src);

    if (len == 1) {
	key = *src;
    } else if (len == 2 && *src == '^') {
	key = src[1] & 0x1f;
    } else if (len > 2 && !strncasecomp(src, "0x", 2)) {
	char *dst = 0;

	key = strtol(src, &dst, 0);
	if (isEmpty(dst))
	    key = -1;
    } else if (len > 6 && !strncasecomp(src, "key-", 4)) {
	char *dst = 0;

	key = strtol(src + 4, &dst, 0);
	if (isEmpty(dst))
	    key = -1;
    }
    if (key < 0) {
	for (n = 0; n < TABLESIZE(named_keys); n++) {
	    if (!strcasecomp(named_keys[n].name, src)) {
		key = named_keys[n].key;
		break;
	    }
	}
    }
    return key;
}

#define PRETTY_LEN 11

static char *pretty_html(int c)
{
    char *src = LYKeycodeToString(c, TRUE);

    if (src != 0) {
	/* *INDENT-OFF* */
	static const struct {
	    int	code;
	    const char *name;
	} table[] = {
	    { '<',	"&lt;" },
	    { '>',	"&gt;" },
	    { '"',	"&quot;" },
	    { '&',	"&amp;" }
	};
	/* *INDENT-ON* */

	static char buf[30];
	char *dst = buf;
	int adj = 0;
	unsigned n;
	BOOLEAN found;

	while ((c = *src++) != 0) {
	    found = FALSE;
	    for (n = 0; n < TABLESIZE(table); n++) {
		if (c == table[n].code) {
		    found = TRUE;
		    strcpy(dst, table[n].name);
		    adj += strlen(dst) - 1;
		    dst += strlen(dst);
		    break;
		}
	    }
	    if (!found) {
		*dst++ = (char) c;
	    }
	}
	adj -= (dst - buf) - PRETTY_LEN;
	while (adj-- > 0)
	    *dst++ = ' ';
	*dst = 0;
	return buf;
    }

    return 0;
}

static char *format_binding(LYKeymap_t * table, int i)
{
    LYKeymapCode the_key = (LYKeymapCode) table[i];
    char *buf = 0;
    char *formatted;
    Kcmd *rmap = LYKeycodeToKcmd(the_key);

    if (rmap != 0
	&& rmap->name != 0
	&& rmap->doc != 0
	&& (formatted = pretty_html(i - 1)) != 0) {
	HTSprintf0(&buf, "%-*s %-13s %s\n",
		   PRETTY_LEN, formatted,
		   rmap->name,
		   rmap->doc);
	return buf;
    }
    return 0;
}

/* if both is true, produce an additional line for the corresponding
   uppercase key if its binding is different. - kw */
static void print_binding(HTStream *target, int i,
			  BOOLEAN both)
{
    char *buf;
    LYKeymapCode lac1 = LYK_UNKNOWN;	/* 0 */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    if (prev_lynx_edit_mode && !no_dired_support &&
	(lac1 = (LYKeymapCode) key_override[i]) != LYK_UNKNOWN) {
	if ((buf = format_binding(key_override, i)) != 0) {
	    PUTS(buf);
	    FREE(buf);
	}
    } else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
    if ((buf = format_binding(keymap, i)) != 0) {
	lac1 = (LYKeymapCode) keymap[i];
	PUTS(buf);
	FREE(buf);
    }

    if (!both)
	return;
    i -= ' ';			/* corresponding uppercase key */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    if (prev_lynx_edit_mode && !no_dired_support && key_override[i]) {
	if (key_override[i] != lac1 &&
	    (buf = format_binding(key_override, i)) != 0) {
	    PUTS(buf);
	    FREE(buf);
	}
    } else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
    if (keymap[i] != lac1 && (buf = format_binding(keymap, i)) != 0) {
	PUTS(buf);
	FREE(buf);
    }
}

/*
 * Return lynxactioncode whose name is the string func.  returns -1 if not
 * found.  - kw
 */
int lacname_to_lac(const char *func)
{
    Kcmd *mp = LYStringToKcmd(func);

    return (mp != 0) ? (int) mp->code : -1;
}

/*
 * Return editactioncode whose name is the string func.  func must be present
 * in the ekmap table.  returns -1 if not found.  - kw
 */
int lecname_to_lec(const char *func)
{
    int i;
    struct emap *mp;

    if (non_empty(func)) {
	for (i = 0, mp = ekmap; (*mp).name != NULL; mp++, i++) {
	    if (strcmp((*mp).name, func) == 0) {
		return (*mp).code;
	    }
	}
    }
    return (-1);
}

/*
 * Return lynxkeycode represented by string src.  returns -1 if not valid.
 *
 * This is simpler than what map_string_to_keysym() does for USE_KEYMAP, but
 * compatible with revmap() used for processing KEYMAP options in the
 * configuration file.  - kw
 */
int lkcstring_to_lkc(const char *src)
{
    int c = -1;

    if (strlen(src) == 1)
	c = *src;
    else if (strlen(src) == 2 && *src == '^')
	c = src[1] & 037;
    else if (strlen(src) >= 2 && isdigit(UCH(*src))) {
	if (sscanf(src, "%i", &c) != 1)
	    return (-1);
#ifdef USE_KEYMAPS
    } else {
	map_string_to_keysym(src, &c);
#ifndef USE_SLANG
	if (c >= 0) {
	    if ((c & LKC_MASK) > 255 && !(c & LKC_ISLKC))
		return (-1);	/* Don't accept untranslated curses KEY_* */
	    else
		c &= ~LKC_ISLKC;
	}
#endif
#endif
    }
    if (c == CH_ESC)
	escape_bound = 1;
    if (c < -1)
	return (-1);
    else
	return c;
}

static int LYLoadKeymap(const char *arg GCC_UNUSED,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target;
    char *buf = 0;
    int i;

    /*
     * Set up the stream.  - FM
     */
    target = HTStreamStack(format_in, format_out, sink, anAnchor);
    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }
    anAnchor->no_cache = TRUE;

    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       CURRENT_KEYMAP_TITLE);
    PUTS(buf);
    HTSprintf0(&buf, "<pre>\n");
    PUTS(buf);

    for (i = 'a' + 1; i <= 'z' + 1; i++) {
	print_binding(target, i, TRUE);
    }
    for (i = 1; i < KEYMAP_SIZE; i++) {
	/*
	 * Don't show CHANGE_LINK if mouse not enabled.
	 */
	if ((i >= 0200 || i <= ' ' || !isalpha(i - 1)) &&
	    (LYUseMouse || (keymap[i] != LYK_CHANGE_LINK))) {
	    print_binding(target, i, FALSE);
	}
    }

    HTSprintf0(&buf, "</pre>\n</body>\n</html>\n");
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(buf);
    return (HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYKEYMAP_C_GLOBALDEF_1_INIT { "LYNXKEYMAP", LYLoadKeymap, 0}
GLOBALDEF(HTProtocol, LYLynxKeymap, _LYKEYMAP_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxKeymap =
{"LYNXKEYMAP", LYLoadKeymap, 0};
#endif /* GLOBALDEF_IS_MACRO */

/*
 * Install func as the mapping for key.
 * If for_dired is TRUE, install it in the key_override[] table
 * for Dired mode, otherwise in the general keymap[] table.
 * If DIRED_SUPPORT or OK_OVERRIDE is not defined, don't do anything
 * when for_dired is requested.
 * returns lynxkeycode value != 0 if the mapping was made, 0 if not.
 */
int remap(char *key,
	  const char *func,
	  BOOLEAN for_dired)
{
    Kcmd *mp;
    int c;

#if !defined(DIRED_SUPPORT) || !defined(OK_OVERRIDE)
    if (for_dired)
	return 0;
#endif
    if (func == NULL)
	return 0;
    c = lkcstring_to_lkc(key);
    if (c <= -1)
	return 0;
    else if (c >= 0) {
	/* Remapping of key actions is supported only for basic
	 * lynxkeycodes, without modifiers etc.!  If we get somehow
	 * called for an invalid lynxkeycode, fail or silently ignore
	 * modifiers. - kw
	 */
	if (c & (LKC_ISLECLAC | LKC_ISLAC))
	    return 0;
	if ((c & LKC_MASK) != c)
	    c &= LKC_MASK;
    }
    if (c + 1 >= KEYMAP_SIZE)
	return 0;
    if ((mp = LYStringToKcmd(func)) != 0) {
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (for_dired)
	    key_override[c + 1] = mp->code;
	else
#endif
	    keymap[c + 1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code));	/* don't return 0, successful */
    }
    return 0;
}

typedef struct {
    int code;
    LYKeymap_t map;
    LYKeymap_t save;
} ANY_KEYS;

/*
 * Save the given keys in the table, setting them to the map'd value.
 */
static void set_any_keys(ANY_KEYS * table, int size)
{
    int j, k;

    for (j = 0; j < size; ++j) {
	k = table[j].code + 1;
	table[j].save = keymap[k];
	keymap[k] = table[j].map;
    }
}

/*
 * Restore the given keys from the table.
 */
static void reset_any_keys(ANY_KEYS * table, int size)
{
    int j, k;

    for (j = 0; j < size; ++j) {
	k = table[j].code + 1;
	keymap[k] = table[j].save;
    }
}

static ANY_KEYS vms_keys_table[] =
{
    {26, LYK_ABORT, 0},		/* control-Z */
    {'$', LYK_SHELL, 0},
};

void set_vms_keys(void)
{
    set_any_keys(vms_keys_table, TABLESIZE(vms_keys_table));
}

static ANY_KEYS vi_keys_table[] =
{
    {'h', LYK_PREV_DOC, 0},
    {'j', LYK_NEXT_LINK, 0},
    {'k', LYK_PREV_LINK, 0},
    {'l', LYK_ACTIVATE, 0},
};

static BOOLEAN did_vi_keys;

void set_vi_keys(void)
{
    set_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
    did_vi_keys = TRUE;
}

void reset_vi_keys(void)
{
    if (did_vi_keys) {
	reset_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
	did_vi_keys = FALSE;
    }
}

static ANY_KEYS emacs_keys_table[] =
{
    {2, LYK_PREV_DOC, 0},	/* ^B */
    {14, LYK_NEXT_LINK, 0},	/* ^N */
    {16, LYK_PREV_LINK, 0},	/* ^P */
    {6, LYK_ACTIVATE, 0},	/* ^F */
};

static BOOLEAN did_emacs_keys;

void set_emacs_keys(void)
{
    set_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
    did_emacs_keys = TRUE;
}

void reset_emacs_keys(void)
{
    if (did_emacs_keys) {
	reset_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
	did_emacs_keys = FALSE;
    }
}

/*
 * Map numbers to functions as labeled on the IBM Enhanced keypad, and save
 * their original mapping for reset_numbers_as_arrows().  - FM
 */
static ANY_KEYS number_keys_table[] =
{
    {'1', LYK_END, 0},
    {'2', LYK_NEXT_LINK, 0},
    {'3', LYK_NEXT_PAGE, 0},
    {'4', LYK_PREV_DOC, 0},
    {'5', LYK_DO_NOTHING, 0},
    {'6', LYK_ACTIVATE, 0},
    {'7', LYK_HOME, 0},
    {'8', LYK_PREV_LINK, 0},
    {'9', LYK_PREV_PAGE, 0},
};

static BOOLEAN did_number_keys;

void set_numbers_as_arrows(void)
{
    set_any_keys(number_keys_table, TABLESIZE(number_keys_table));
    did_number_keys = TRUE;
}

void reset_numbers_as_arrows(void)
{
    if (did_number_keys) {
	reset_any_keys(number_keys_table, TABLESIZE(number_keys_table));
	did_number_keys = FALSE;
    }
}

char *key_for_func(int func)
{
    static char *buf;
    int i;
    char *formatted;

    if ((i = LYReverseKeymap(func)) >= 0) {
	formatted = LYKeycodeToString(i, TRUE);
	StrAllocCopy(buf, formatted != 0 ? formatted : "?");
    } else if (buf == 0) {
	StrAllocCopy(buf, "");
    }
    return buf;
}

/*
 * Given one or two keys as lynxkeycodes, returns an allocated string
 * representing the key(s) suitable for statusline messages, or NULL if no
 * valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other failure).
 * The caller must free the string.  - kw
 */
char *fmt_keys(int lkc_first,
	       int lkc_second)
{
    char *buf = NULL;
    BOOLEAN quotes = FALSE;
    char *fmt_first;
    char *fmt_second;

    if (lkc_first < 0)
	return NULL;
    fmt_first = LYKeycodeToString(lkc_first, TRUE);
    if (fmt_first && strlen(fmt_first) == 1 && *fmt_first != '\'') {
	quotes = TRUE;
    }
    if (quotes) {
	if (lkc_second < 0) {
	    HTSprintf0(&buf, "'%s'", fmt_first);
	    return buf;
	} else {
	    HTSprintf0(&buf, "'%s", fmt_first);
	}
    } else {
	StrAllocCopy(buf, fmt_first);
    }
    if (lkc_second >= 0) {
	fmt_second = LYKeycodeToString(lkc_second, TRUE);
	if (!fmt_second) {
	    FREE(buf);
	    return NULL;
	}
	HTSprintf(&buf, "%s%s%s",
		  (((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		    (strlen(buf) > 2 && buf[strlen(buf) - 1] != '>'))
		   ? " "
		   : ""),
		  fmt_second, quotes ? "'" : "");
    }
    return buf;
}

/*
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  It is like LYReverseKeymap, only the order of search is
 * different; e.g., small ASCII letters will be returned in preference to
 * capital ones.  Cf.  LYKeyForEditAction, LYEditKeyForAction in LYEditmap.c
 * which use the same order to find a best key.  In addition, this function
 * takes the dired override map into account while LYReverseKeymap doesn't.
 * The caller must free the returned string.  - kw
 */
#define FIRST_I 97
#define NEXT_I(i,imax) ((i==122) ? 32 : (i==96) ? 123 : (i==126) ? 0 :\
			(i==31) ? 256 : (i==imax) ? 127 :\
			(i==255) ? (-1) :i+1)
static int best_reverse_keymap(int lac)
{
    int i, c;

    for (i = FIRST_I; i >= 0; i = NEXT_I(i, KEYMAP_SIZE - 2)) {
#ifdef NOT_ASCII
	if (i < 256) {
	    c = FROMASCII(i);
	} else
#endif
	    c = i;
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && lac &&
	    LKC_TO_LAC(key_override, c) == lac)
	    return c;
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	if (LKC_TO_LAC(keymap, c) == lac) {
	    return c;
	}
    }

    return (-1);
}

/*
 * This function returns a string representing a key mapped to a LYK_foo
 * function, or NULL if not found.  The string may represent a pair of keys.
 * if context_code is FOR_INPUT, an appropriate binding for use while in the
 * (forms) line editor is sought.  - kw
 */
char *key_for_func_ext(int lac,
		       int context_code)
{
    int lkc, modkey = -1;

    if (context_code == FOR_INPUT) {
	lkc = LYEditKeyForAction(lac, &modkey);
	if (lkc >= 0) {
	    if (lkc & (LKC_MOD1 | LKC_MOD2 | LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1 | LKC_MOD2 | LKC_MOD3));
	    } else {
		return fmt_keys(lkc, -1);
	    }
	}
    }
    lkc = best_reverse_keymap(lac);
    if (lkc < 0)
	return NULL;
    if (context_code == FOR_INPUT) {
	modkey = LYKeyForEditAction(LYE_LKCMD);
	if (modkey < 0)
	    return NULL;
	return fmt_keys(modkey, lkc);
    } else {
	return fmt_keys(lkc, -1);
    }
}

/*
 * This function returns TRUE if the ch is non-alphanumeric and maps to KeyName
 * (LYK_foo in the keymap[] array).  - FM
 */
BOOL LYisNonAlnumKeyname(int ch,
			 int KeyName)
{
    if (ch < 0 || ch >= KEYMAP_SIZE)
	return (FALSE);
    if (ch > 0
	&& strchr("0123456789\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz", ch) != NULL)
	return (FALSE);

    return (BOOL) (keymap[ch + 1] == KeyName);
}

/*
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  - FM
 */
int LYReverseKeymap(int KeyName)
{
    int i;

    for (i = 1; i < KEYMAP_SIZE; i++) {
	if (keymap[i] == KeyName) {
	    return (i - 1);
	}
    }

    return (-1);
}

#ifdef EXP_KEYBOARD_LAYOUT
int LYSetKbLayout(char *layout_id)
{
    int i;

    for (i = 0; i < (int) TABLESIZE(LYKbLayoutNames) - 1; i++) {
	if (!strcmp(LYKbLayoutNames[i], layout_id)) {
	    current_layout = i;
	    return (-1);
	}
    }

    return 0;
}
#endif
@


1.8
log
@automatic merge
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYKeymap.c,v 1.7 2004/10/11 20:30:41 tg Exp $ */
d33 1
a33 1
char *LYKbLayoutNames[] =
d1269 1
a1269 1
    LYKeymap_t the_key = table[i];
d1297 1
a1297 1
	(lac1 = key_override[i]) != LYK_UNKNOWN) {
d1305 1
a1305 1
	lac1 = keymap[i];
d1465 1
a1465 1
	  char *func,
@


1.7
log
@automatic merge; regen configure
@
text
@d1 1
a1 1
/* $MirBSD: src/gnu/usr.bin/lynx/src/LYKeymap.c,v 1.6 2004/07/23 05:52:23 tg Stab $ */
d1127 1
a1127 1
    if (name != 0 && *name != 0) {
d1349 1
a1349 1
    if (func != NULL && *func != '\0') {
@


1.6
log
@if KANJI_CODE_OVERRIDE, don't override ^L but rather shift-J
@
text
@d1 1
a1 1
/* $MirBSD$ */
d21 2
d1299 1
a1299 1
	    (*target->isa->put_block) (target, buf, strlen(buf));
d1306 1
a1306 1
	(*target->isa->put_block) (target, buf, strlen(buf));
d1318 1
a1318 1
	    (*target->isa->put_block) (target, buf, strlen(buf));
d1324 1
a1324 1
	(*target->isa->put_block) (target, buf, strlen(buf));
a1419 2

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))
@


1.5
log
@automatic merge of lynx-current
@
text
@d1 2
a74 5
#ifdef KANJI_CODE_OVERRIDE
LYK_CHG_KCODE,    LYK_ACTIVATE,     LYK_DOWN_TWO,      0,
/* ^L */            /* cr */        /* ^N */       /* ^O */

#else
a76 1
#endif
d125 5
d132 1
d1648 1
a1648 1
 * valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other failure). 
d1697 1
a1697 1
 * takes the dired override map into account while LYReverseKeymap doesn't. 
d1730 1
a1730 1
 * function, or NULL if not found.  The string may represent a pair of keys. 
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d20 1
a20 1
int current_layout = 0;  /* Index into LYKbLayouts[]   */
d22 5
a26 4
LYKbLayout_t * LYKbLayouts[]={
	kb_layout_rot13,
	kb_layout_jcuken,
	kb_layout_yawerty
d29 6
a34 5
char * LYKbLayoutNames[]={
	"ROT13'd keyboard layout",
	"JCUKEN Cyrillic, for AT 101-key kbd",
	"YAWERTY Cyrillic, for DEC LK201 kbd",
        (char *) 0
d38 2
a39 3
struct _HTStream
{
  HTStreamClass * isa;
d42 1
a42 1
/* * *  Tables mapping LynxKeyCodes to LynxActionCodes  * * */
d45 5
a49 5
 *  Lynxkeycodes include all single-byte keys as well as codes
 *  for function keys and some special purposes.  See LYStrings.h.
 *  Extended lynxkeycode values can also contain flags for modifiers
 *  and other purposes, but here only the base values are mapped to
 *  lynxactioncodes.  They are called `keystrokes' in lynx.cfg.
d51 2
a52 2
 *  Lynxactioncodes (confusingly, constants are named LYK_foo and
 *  typed as LYKeymapCode) specify key `functions', see LYKeymap.h.
d58 1
d1009 3
a1011 3
	const char *name;
	const int   code;
	const char *descr;
d1068 1
d1073 1
a1073 1
HTList *LYcommandList (void)
d1079 1
d1084 1
d1096 1
a1096 2
Kcmd * LYKeycodeToKcmd (
	LYKeymapCode	code)
d1115 1
a1115 2
Kcmd * LYStringToKcmd (
	const char *	name)
d1129 1
a1129 1
		&& !strncasecomp(revmap[j].name, name, need)) {
d1134 1
a1134 1
		     && maybe->name[need] != 0) {
d1145 2
a1146 3
char *LYKeycodeToString (
	int		c,
	BOOLEAN	upper8)
d1162 1
a1162 1
	 && c < 0177)
d1165 3
a1167 3
	 && c > ' '
	 && c <= 0377
	 && c <= LYlowest_eightbit[current_char_set])
d1170 1
a1170 1
	    sprintf(buf, "^%c", c|0100);
d1179 1
a1179 2
int LYStringToKeycode (
	char *		src)
d1191 1
d1197 1
d1215 1
a1215 1
static char *pretty_html (int c)
d1220 1
d1230 1
d1263 1
a1263 3
static char * format_binding (
	LYKeymap_t *	table,
	int		i)
d1271 3
a1273 3
     && rmap->name != 0
     && rmap->doc != 0
     && (formatted = pretty_html(i-1)) != 0) {
d1285 2
a1286 4
static void print_binding (
    HTStream *	target,
    int	i,
    BOOLEAN 	both)
d1289 1
a1289 1
    LYKeymapCode lac1 = LYK_UNKNOWN; /* 0 */
d1295 1
a1295 1
	    (*target->isa->put_block)(target, buf, strlen(buf));
d1302 1
a1302 1
	(*target->isa->put_block)(target, buf, strlen(buf));
d1314 1
a1314 1
	    (*target->isa->put_block)(target, buf, strlen(buf));
d1320 1
a1320 1
	(*target->isa->put_block)(target, buf, strlen(buf));
d1326 2
a1327 2
 *  Return lynxactioncode whose name is the string func.
 *  returns -1 if not found. - kw
d1329 1
a1329 2
int lacname_to_lac (
	const char *	func)
d1337 2
a1338 3
 *  Return editactioncode whose name is the string func.
 *  func must be present in the ekmap table.
 *  returns -1 if not found. - kw
d1340 1
a1340 2
int lecname_to_lec (
	const char *	func)
d1356 5
a1360 5
 *  Return lynxkeycode represented by string src.
 *  returns -1 if not valid.
 *  This is simpler than what map_string_to_keysym() does for
 *  USE_KEYMAP, but compatible with revmap() used for processing
 *  KEYMAP options in the configuration file. - kw
d1362 1
a1362 2
int lkcstring_to_lkc (
	const char *	src)
d1378 1
a1378 1
	    if ((c&LKC_MASK) > 255 && !(c & LKC_ISLKC))
d1394 4
a1397 5
static int LYLoadKeymap (
	const char * 		arg GCC_UNUSED,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1405 1
a1405 1
     *  Set up the stream. - FM
d1410 1
a1410 1
			 HTAtom_name(format_in), HTAtom_name(format_out));
d1413 1
a1413 1
	return(HT_NOT_LOADED);
d1420 1
a1420 1
		     CURRENT_KEYMAP_TITLE);
d1425 1
a1425 1
    for (i = 'a'+1; i <= 'z'+1; i++) {
d1430 1
a1430 1
	 *  Don't show CHANGE_LINK if mouse not enabled.
d1432 1
a1432 1
	if ((i >= 0200 || i <= ' ' || !isalpha(i-1)) &&
d1438 1
a1438 1
    HTSprintf0(&buf,"</pre>\n</body>\n</html>\n");
d1441 1
a1441 1
    (*target->isa->_free)(target);
d1443 1
a1443 1
    return(HT_LOADED);
d1448 1
a1448 1
GLOBALDEF (HTProtocol,LYLynxKeymap,_LYKEYMAP_C_GLOBALDEF_1_INIT);
d1450 2
a1451 1
GLOBALDEF HTProtocol LYLynxKeymap = {"LYNXKEYMAP", LYLoadKeymap, 0};
d1462 3
a1464 4
int remap (
	char *		key,
	char *		func,
	BOOLEAN	for_dired)
d1484 2
a1485 2
	if (c & (LKC_ISLECLAC|LKC_ISLAC))
	   return 0;
d1487 1
a1487 1
	   c &= LKC_MASK;
d1494 1
a1494 1
	    key_override[c+1] = mp->code;
d1497 2
a1498 2
	    keymap[c+1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code)); /* don't return 0, successful */
d1504 1
a1504 1
    int	code;
d1512 1
a1512 3
static void set_any_keys (
	ANY_KEYS *	table,
	int		size)
d1526 1
a1526 3
static void reset_any_keys (
	ANY_KEYS *	table,
	int		size)
d1536 4
a1539 3
static ANY_KEYS vms_keys_table[] = {
    { 26,   LYK_ABORT,   0 },	/* control-Z */
    { '$',  LYK_SHELL,   0 },
d1542 1
a1542 1
void set_vms_keys (void)
d1547 6
a1552 5
static ANY_KEYS vi_keys_table[] = {
    { 'h', LYK_PREV_DOC,  0 },
    { 'j', LYK_NEXT_LINK, 0 },
    { 'k', LYK_PREV_LINK, 0 },
    { 'l', LYK_ACTIVATE,  0 },
d1557 1
a1557 1
void set_vi_keys (void)
d1563 1
a1563 1
void reset_vi_keys (void)
d1571 6
a1576 5
static ANY_KEYS emacs_keys_table[] = {
    { 2,  LYK_PREV_DOC,  0 },	/* ^B */
    { 14, LYK_NEXT_LINK, 0 },	/* ^N */
    { 16, LYK_PREV_LINK, 0 },	/* ^P */
    { 6,  LYK_ACTIVATE,  0 },	/* ^F */
d1581 1
a1581 1
void set_emacs_keys (void)
d1587 1
a1587 1
void reset_emacs_keys (void)
d1599 11
a1609 10
static ANY_KEYS number_keys_table[] = {
    { '1', LYK_END,        0 },
    { '2', LYK_NEXT_LINK,  0 },
    { '3', LYK_NEXT_PAGE,  0 },
    { '4', LYK_PREV_DOC,   0 },
    { '5', LYK_DO_NOTHING, 0 },
    { '6', LYK_ACTIVATE,   0 },
    { '7', LYK_HOME,       0 },
    { '8', LYK_PREV_LINK,  0 },
    { '9', LYK_PREV_PAGE,  0 },
d1614 1
a1614 1
void set_numbers_as_arrows (void)
d1620 1
a1620 1
void reset_numbers_as_arrows (void)
d1628 1
a1628 2
char *key_for_func (
	int	func)
d1644 4
a1647 4
 *  Given one or two keys as lynxkeycodes, returns an allocated string
 *  representing the key(s) suitable for statusline messages, or NULL
 *  if no valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other
 *  failure).  The caller must free the string. - kw
d1649 2
a1650 3
char *fmt_keys (
    int	lkc_first,
    int	lkc_second)
d1680 4
a1683 2
		  ((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		   (strlen(buf) > 2 && buf[strlen(buf)-1] != '>')) ? " " : "",
d1690 7
a1696 9
 *  This function returns the (int)ch mapped to the
 *  LYK_foo value passed to it as an argument.  It is like
 *  LYReverseKeymap, only the order of search is different;
 *  e.g., small ASCII letters will be returned in preference to
 *  capital ones.  Cf. LYKeyForEditAction, LYEditKeyForAction in
 *  LYEditmap.c which use the same order to find a best key.
 *  In addition, this function takes the dired override map into
 *  account while LYReverseKeymap doesn't.
 *  The caller must free the returned string. - kw
d1702 1
a1702 2
static int best_reverse_keymap (
	int	lac)
d1706 1
a1706 1
    for (i = FIRST_I; i >= 0; i = NEXT_I(i,KEYMAP_SIZE-2)) {
d1715 1
a1715 1
	    LKC_TO_LAC(key_override,c) == lac)
d1718 1
a1718 1
	if (LKC_TO_LAC(keymap,c) == lac) {
d1723 1
a1723 1
    return(-1);
d1727 4
a1730 5
 *  This function returns a string representing a key mapped
 *  to a LYK_foo function, or NULL if not found.  The string
 *  may represent a pair of keys.  if context_code is FOR_INPUT,
 *  an appropriate binding for use while in the (forms) line editor
 *  is sought.  - kw
d1732 2
a1733 3
char* key_for_func_ext (
    int	lac,
    int	context_code)
d1740 2
a1741 2
	    if (lkc & (LKC_MOD1|LKC_MOD2|LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1|LKC_MOD2|LKC_MOD3));
d1761 2
a1762 2
 *  This function returns TRUE if the ch is non-alphanumeric
 *  and maps to KeyName (LYK_foo in the keymap[] array). - FM
d1764 2
a1765 3
BOOL LYisNonAlnumKeyname (
	int	ch,
	int	KeyName)
d1770 1
a1770 1
     && strchr("0123456789\
d1775 1
a1775 1
    return (BOOL) (keymap[ch+1] == KeyName);
d1779 2
a1780 2
 *  This function returns the (int)ch mapped to the
 *  LYK_foo value passed to it as an argument. - FM
d1782 1
a1782 2
int LYReverseKeymap (
	int	KeyName)
d1788 1
a1788 1
	    return(i - 1);
d1792 1
a1792 1
    return(-1);
d1796 1
a1796 2
int LYSetKbLayout (
	char *	layout_id)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d20 1
a20 1
PUBLIC int current_layout = 0;  /* Index into LYKbLayouts[]   */
d22 1
a22 1
PUBLIC LYKbLayout_t * LYKbLayouts[]={
d28 1
a28 1
PUBLIC char * LYKbLayoutNames[]={
d623 1
a623 1
PRIVATE Kcmd revmap[] = {
d976 1
a976 1
PRIVATE CONST struct {
d978 1
a978 1
    CONST char *name;
d1007 3
a1009 3
	CONST char *name;
	CONST int   code;
	CONST char *descr;
d1012 1
a1012 1
PRIVATE struct emap ekmap[] = {
d1070 1
a1070 1
PUBLIC HTList *LYcommandList NOARGS
d1078 5
a1082 2
	    if (revmap[j].doc != 0)
		HTList_addObject(myList, (char *)revmap[j].name);
d1091 2
a1092 2
PUBLIC Kcmd * LYKeycodeToKcmd ARGS1(
	LYKeymapCode,	code)
d1111 2
a1112 2
PUBLIC Kcmd * LYStringToKcmd ARGS1(
	CONST char *,	name)
d1142 3
a1144 3
PUBLIC char *LYKeycodeToString ARGS2 (
	int,		c,
	BOOLEAN,	upper8)
d1177 2
a1178 2
PUBLIC int LYStringToKeycode ARGS1 (
	char *,		src)
d1212 1
a1212 1
PRIVATE char *pretty_html ARGS1 (int, c)
d1217 1
a1217 1
	static CONST struct {
d1219 1
a1219 1
	    CONST char *name;
d1258 3
a1260 3
PRIVATE char * format_binding ARGS2(
	LYKeymap_t *,	table,
	int,		i)
d1282 4
a1285 4
PRIVATE void print_binding ARGS3(
    HTStream *,	target,
    int,	i,
    BOOLEAN, 	both)
d1328 2
a1329 2
PUBLIC int lacname_to_lac ARGS1(
	CONST char *,	func)
d1341 2
a1342 2
PUBLIC int lecname_to_lec ARGS1(
	CONST char *,	func)
d1364 2
a1365 2
PUBLIC int lkcstring_to_lkc ARGS1(
	CONST char *,	src)
d1397 5
a1401 5
PRIVATE int LYLoadKeymap ARGS4 (
	CONST char *, 		arg GCC_UNUSED,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1454 1
a1454 1
GLOBALDEF PUBLIC HTProtocol LYLynxKeymap = {"LYNXKEYMAP", LYLoadKeymap, 0};
d1465 4
a1468 4
PUBLIC int remap ARGS3(
	char *,		key,
	char *,		func,
	BOOLEAN,	for_dired)
d1516 3
a1518 3
PRIVATE void set_any_keys ARGS2(
	ANY_KEYS *,	table,
	int,		size)
d1532 3
a1534 3
PRIVATE void reset_any_keys ARGS2(
	ANY_KEYS *,	table,
	int,		size)
d1549 1
a1549 1
PUBLIC void set_vms_keys NOARGS
d1563 1
a1563 1
PUBLIC void set_vi_keys NOARGS
d1569 1
a1569 1
PUBLIC void reset_vi_keys NOARGS
d1586 1
a1586 1
PUBLIC void set_emacs_keys NOARGS
d1592 1
a1592 1
PUBLIC void reset_emacs_keys NOARGS
d1618 1
a1618 1
PUBLIC void set_numbers_as_arrows NOARGS
d1624 1
a1624 1
PUBLIC void reset_numbers_as_arrows NOARGS
d1632 2
a1633 2
PUBLIC char *key_for_func ARGS1 (
	int,	func)
d1654 3
a1656 3
PUBLIC char *fmt_keys ARGS2(
    int,	lkc_first,
    int,	lkc_second)
d1708 2
a1709 2
PRIVATE int best_reverse_keymap ARGS1(
	int,	lac)
d1740 3
a1742 3
PUBLIC char* key_for_func_ext ARGS2(
    int,	lac,
    int,	context_code)
d1773 3
a1775 3
PUBLIC BOOL LYisNonAlnumKeyname ARGS2(
	int,	ch,
	int,	KeyName)
d1792 2
a1793 2
PUBLIC int LYReverseKeymap ARGS1(
	int,	KeyName)
d1807 2
a1808 2
PUBLIC int LYSetKbLayout ARGS1(
	char *,	layout_id)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d3 1
d5 1
a5 1
#include <LYGlobalDefs.h>
d9 1
d22 1
a22 1
PUBLIC LYKeymap_t * LYKbLayouts[]={
d34 1
a34 4
#endif

PRIVATE CONST DocAddress keymap_anchor = {"LYNXKEYMAP", NULL, NULL,
	NULL, FALSE, FALSE};
d41 13
d71 5
d78 1
d80 2
a81 2
LYK_UP_TWO,             0,          LYK_RELOAD,        0,
/* ^P */            /* XON */       /* ^R */       /* XOFF */
d95 1
a95 1
0,                      0,              0,          LYK_HISTORICAL,
d101 1
a101 5
#ifndef USE_EXTERNALS
LYK_NEXT_PAGE,    LYK_PREV_PAGE,        0,          LYK_WHEREIS,
/* , */              /* - */         /* . */        /* / */
#else
LYK_NEXT_PAGE,    LYK_PREV_PAGE, LYK_EXTERN,        LYK_WHEREIS,
a102 1
#endif
d110 1
a110 1
LYK_8,               LYK_9,             0,          LYK_TRACE_LOG,
d116 1
a118 6

LYK_DOWNLOAD,        LYK_ELGOTO,
/* D */              /* E */

#if defined(DIRED_SUPPORT) || defined(VMS)
LYK_DIRED_MENU,
d120 3
a122 3
0,
#endif /* DIRED_SUPPORT || VMS */
/* F */
d124 2
a125 2
LYK_ECGOTO,
/* G */
d130 1
a130 1
LYK_LIST,          LYK_MAIN_MENU,    LYK_NEXT,      LYK_OPTIONS,
d142 1
a142 1
LYK_SOURCE,          LYK_HEAD,          0,          LYK_CLEAR_AUTH,
d148 2
a149 12
LYK_DOWNLOAD,        LYK_EDIT,
/* d */              /* e */

#if defined(DIRED_SUPPORT) || defined(VMS)
LYK_DIRED_MENU,
#else
0,
#endif /* DIRED_SUPPORT || VMS */
/* f */

LYK_GOTO,
/* g */
d163 1
a163 1
LYK_NOCACHE,            0,          LYK_INTERRUPT,     0,
d166 1
a166 8
#if (defined(_WINDOWS) || defined(__DJGPP__))

LYK_PIPE,               0,              0,             0,
/* | */               /* } */         /* ~ */

#else

LYK_PIPE,               0,              0,          LYK_HISTORY,
a168 1
#endif /* _WINDOWS || __DJGPP__ */
d215 1
a215 1
LYK_HELP,              0,              0,             0,
d219 1
a219 1
LYK_HELP,         LYK_ACTIVATE,     LYK_HOME,       LYK_END,
a228 4
#if (defined(_WINDOWS) || defined(__DJGPP__)) && defined(USE_SLANG) && !defined(DJGPP_KEYHANDLER)
   LYK_HISTORY,        LYK_ACTIVATE,   0,             0,
   /* Backspace */     /* Enter */
#else
a229 1
#endif /* USE_SLANG &&(_WINDOWS || __DJGPP) && !DJGPP_KEYHANDLER */
d279 1
a279 1
#if (defined(_WINDOWS) || defined(__DJGPP__)) && !defined(USE_SLANG) /* PDCurses */
d299 1
a299 1
#endif /* (_WINDOWS || __DJGPP__) && !USE_SLANG */
d412 1
a412 1

d415 4
d621 1
a621 5
struct rmap {
	CONST char *name;
	CONST char *doc;
};

d623 268
a890 81
PRIVATE struct rmap revmap[] = {
{ "UNMAPPED",		NULL },
{ "1",			NULL },
{ "2",			NULL },
{ "3",			NULL },
{ "4",			NULL },
{ "5",			NULL },
{ "6",			NULL },
{ "7",			NULL },
{ "8",			NULL },
{ "9",			NULL },
{ "SOURCE",		"toggle source/presentation for current document" },
{ "RELOAD",		"reload the current document" },
{ "PIPE",		"pipe the current document to an external command" },
{ "QUIT",		"quit the browser" },
{ "ABORT",		"quit the browser unconditionally" },
{ "NEXT_PAGE",		"view the next page of the document" },
{ "PREV_PAGE",		"view the previous page of the document" },
{ "UP_TWO",		"go back two lines in the document" },
{ "DOWN_TWO",		"go forward two lines in the document" },
{ "UP_HALF",		"go back half a page in the document" },
{ "DOWN_HALF",		"go forward half a page in the document" },
{ "REFRESH",		"refresh the screen to clear garbled text" },
{ "HOME",		"go to the beginning of the current document" },
{ "END",		"go to the end of the current document" },
{ "PREV_LINK",		"make the previous link current" },
{ "NEXT_LINK",		"make the next link current" },
{ "FASTBACKW_LINK",	"previous link or text area, only stops on links" },
{ "FASTFORW_LINK",	"next link or text area, only stops on links" },
{ "UP_LINK",		"move up the page to a previous link" },
{ "DOWN_LINK",		"move down the page to another link" },
{ "RIGHT_LINK",		"move right to another link" },
{ "LEFT_LINK",		"move left to a previous link" },
{ "HISTORY",		"display stack of currently-suspended documents" },
{ "PREV_DOC",		"go back to the previous document" },
{ "ACTIVATE",		"go to the document given by the current link" },
{ "GOTO",		"go to a document given as a URL" },
{ "ECGOTO",		"edit the current document's URL and go to it" },
{ "HELP",		"display help on using the browser" },
{ "INDEX",		"display an index of potentially useful documents" },
{ "NOCACHE",		"force submission of form or link with no-cache" },
{ "INTERRUPT",		"interrupt network connection or transmission" },
{ "MAIN_MENU",		"return to the first screen (home page)" },
{ "OPTIONS",		"display and change option settings" },
{ "INDEX_SEARCH",	"allow searching of an index" },
{ "WHEREIS",		"search within the current document" },
{ "NEXT",		"search for the next occurence" },
{ "COMMENT",		"send a comment to the author of the current document" },
{ "EDIT",		"edit the current document or a form's textarea" },
{ "INFO",		"display information on the current document and link" },
{ "PRINT",		"display choices for printing the current document" },
{ "ADD_BOOKMARK",	"add to your personal bookmark list" },
{ "DEL_BOOKMARK",	"delete from your personal bookmark list" },
{ "VIEW_BOOKMARK",	"view your personal bookmark list" },
{ "VLINKS",		"list links visited during the current Lynx session" },
{ "SHELL",		"escape from the browser to the system" },
{ "DOWNLOAD",		"download the current link to your computer" },
{ "TRACE_TOGGLE",	"toggle tracing of browser operations" },
{ "TRACE_LOG",		"view trace log if started in the current session" },
{ "IMAGE_TOGGLE",	"toggle handling of all images as links" },
{ "INLINE_TOGGLE",	"toggle pseudo-ALTs for inlines with no ALT string" },
{ "HEAD",		"send a HEAD request for the current document or link" },
{ "DO_NOTHING",		NULL },
{ "TOGGLE_HELP",	"show other commands in the novice help menu" },
{ "JUMP",		"go directly to a target document or action" },
{ "KEYMAP",		"display the current key map" },
{ "LIST",		"list the references (links) in the current document" },
{ "TOOLBAR",		"go to Toolbar or Banner in the current document" },
{ "HISTORICAL",		"toggle historical vs. valid/minimal comment parsing" },
{ "MINIMAL",		"toggle minimal vs. valid comment parsing" },
{ "SOFT_DQUOTES",	"toggle valid vs. soft double-quote parsing" },
{ "RAW_TOGGLE",		"toggle raw 8-bit translations or CJK mode ON or OFF" },
{ "COOKIE_JAR",		"examine the Cookie Jar" },
{ "F_LINK_NUM",		"invoke the 'Follow link (or page) number:' prompt" },
{ "CLEAR_AUTH",		"clear all authorization info for this session" },
{ "SWITCH_DTD",		"switch between two ways of parsing HTML" },
{ "ELGOTO",		"edit the current link's URL or ACTION and go to it" },
{ "CHANGE_LINK",	"force reset of the current link on the page" },
{ "EDITTEXTAREA",	"use an external editor to edit a form's textarea" },
{ "GROWTEXTAREA",	"add 5 new blank lines to the bottom of a textarea" },
{ "INSERTFILE",		"insert file into a textarea (just above cursorline)" },
d892 3
a894 1
{ "ADDRLIST",		"like LIST command, but always shows the links URL's" },
d897 6
a902 1
{ "EXTERN",		"run external program with url" },
d905 3
a907 1
{ "DIRED_MENU",		"invoke File/Directory Manager, if available" },
d910 21
a930 7
{ "DIRED_MENU",		"display a full menu of file operations" },
{ "CREATE",		"create a new file or directory" },
{ "REMOVE",		"remove a file or directory" },
{ "MODIFY",		"modify the name or location of a file or directory" },
{ "TAG_LINK",		"tag a file or directory for later action" },
{ "UPLOAD",		"upload from your computer to the current directory" },
{ "INSTALL",		"install file or tagged files into a system area" },
d932 8
d941 63
a1003 1
{ NULL,			"" }
d1006 59
a1064 20
PRIVATE CONST char *funckey[] = {
  "Up Arrow",
  "Down Arrow",
  "Right Arrow",
  "Left Arrow",
  "Page Down",
  "Page Up",
  "Home",
  "End",
  "F1",
  "Do key",
  "Find key",
  "Select key",
  "Insert key",
  "Remove key",
  "(DO_NOTHING)",		/* should normally not appear in list */
  "Back Tab",
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  "mouse pseudo key",		/* normally not mapped to keymap[] action? */
d1067 75
a1141 1
PRIVATE char *pretty ARGS1 (int, c)
d1143 11
a1153 1
	static char buf[30];
d1155 9
a1163 14
	if (c == '\t')
		sprintf(buf, "&lt;tab&gt;      ");
	else if (c == '\r')
		sprintf(buf, "&lt;return&gt;   ");
	else if (c == ' ')
		sprintf(buf, "&lt;space&gt;    ");
	else if (c == '<')
		sprintf(buf, "&lt;          ");
	else if (c == '>')
		sprintf(buf, "&gt;          ");
	else if (c == 0177)
		sprintf(buf, "&lt;delete&gt;   ");
	else if (c > ' ' && c <= 0377)
		sprintf(buf, "%c", c);
d1165 1
a1165 4
		sprintf(buf, "^%c", c|0100);
	else if (c >= 0400 && (c - 0400) < (int) TABLESIZE(funckey)
		 && funckey[c-0400])
		sprintf(buf, "%s", funckey[c-0400]);
d1167 1
a1167 1
		sprintf(buf, "%#x", c);
d1169 37
a1205 1
		return 0;
d1207 42
d1250 3
d1259 1
a1259 1
    unsigned the_key = table[i];
d1262 1
d1264 8
a1271 8
    if (the_key != 0
     && the_key < TABLESIZE(revmap)
     && revmap[the_key].name != 0
     && revmap[the_key].doc != 0
     && (formatted = pretty(i-1)) != 0) {
	HTSprintf0(&buf, "%-11s %-13s %s\n", formatted,
		revmap[the_key].name,
		revmap[the_key].doc);
d1277 6
a1282 1
PRIVATE void print_binding ARGS2(HTStream *, target, int, i)
d1285 2
d1289 9
a1297 1
        (buf = format_binding(key_override, i)) != 0) {
d1300 13
d1315 1
a1315 1
    if ((buf = format_binding(keymap, i)) != 0) {
d1321 73
d1418 3
a1420 1
    HTSprintf0(&buf, "<head>\n<title>%s</title>\n</head>\n<body>\n",
d1422 1
a1422 6
    (*target->isa->put_block)(target, buf, strlen(buf));
    HTSprintf0(&buf, "<h1>%s (%s)%s<a href=\"%s%s\">%s</a></h1>\n",
	LYNX_NAME, LYNX_VERSION,
	HELP_ON_SEGMENT,
	helpfilepath, CURRENT_KEYMAP_HELP, CURRENT_KEYMAP_TITLE);
    (*target->isa->put_block)(target, buf, strlen(buf));
d1424 1
a1424 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d1427 1
a1427 4
	print_binding(target, i);
	if (keymap[i - ' '] != keymap[i]) {
	    print_binding(target, i-' ');  /* uppercase mapping is different */
	}
a1430 2
	 *  LYK_PIPE not implemented yet.
	 *
d1433 3
a1435 4
	if ((i >= 0400 || i <= ' ' || !isalpha(i-1)) &&
	    strcmp(revmap[keymap[i]].name, "PIPE") &&
	    (LYUseMouse || strcmp(revmap[keymap[i]].name, "CHANGE_LINK"))) {
	    print_binding(target, i);
d1439 2
a1440 2
    HTSprintf0(&buf,"</pre>\n</body>\n");
    (*target->isa->put_block)(target, buf, strlen(buf));
d1455 73
a1527 3
 * install func as the mapping for key.
 * func must be present in the revmap table.
 * returns TRUE if the mapping was made, FALSE if not.
d1529 10
a1538 24
PUBLIC int remap ARGS2(
	char *,	key,
	char *,	func)
{
       int i;
       struct rmap *mp;
       int c = 0;

       if (func == NULL)
	       return 0;
       if (strlen(key) == 1)
               c = *key;
       else if (strlen(key) == 2 && *key == '^')
               c = key[1] & 037;
       else if (strlen(key) >= 2 && isdigit(*key))
               if (sscanf(key, "%i", &c) != 1)
                       return 0;
       for (i = 0, mp = revmap; (*mp).name != NULL; mp++, i++) {
               if (strcmp((*mp).name, func) == 0) {
                       keymap[c+1] = i;
                       return c;
               }
       }
       return 0;
d1541 4
d1548 1
a1548 2
      keymap[26+1] = LYK_ABORT;  /* control-Z */
      keymap['$'+1] = LYK_SHELL;
d1551 7
a1557 1
static char saved_vi_keys[4];
d1562 2
a1563 10
      saved_vi_keys[0] = keymap['h'+1];
      keymap['h'+1] = LYK_PREV_DOC;
      saved_vi_keys[1] = keymap['j'+1];
      keymap['j'+1] = LYK_NEXT_LINK;
      saved_vi_keys[2] = keymap['k'+1];
      keymap['k'+1] = LYK_PREV_LINK;
      saved_vi_keys[3] = keymap['l'+1];
      keymap['l'+1] = LYK_ACTIVATE;

      did_vi_keys = TRUE;
d1568 5
a1572 2
      if (!did_vi_keys)
              return;
d1574 6
a1579 4
      keymap['h'+1] = saved_vi_keys[0];
      keymap['j'+1] = saved_vi_keys[1];
      keymap['k'+1] = saved_vi_keys[2];
      keymap['l'+1] = saved_vi_keys[3];
a1580 4
      did_vi_keys = FALSE;
}

static char saved_emacs_keys[4];
d1585 2
a1586 10
      saved_emacs_keys[0] = keymap[2+1];
      keymap[2+1] = LYK_PREV_DOC;       /* ^B */
      saved_emacs_keys[1] = keymap[14+1];
      keymap[14+1] = LYK_NEXT_LINK;     /* ^N */
      saved_emacs_keys[2] = keymap[16+1];
      keymap[16+1] = LYK_PREV_LINK;     /* ^P */
      saved_emacs_keys[3] = keymap[6+1];
      keymap[6+1] = LYK_ACTIVATE;         /* ^F */

      did_emacs_keys = TRUE;
d1591 5
a1595 2
      if (!did_emacs_keys)
              return;
d1597 15
a1611 4
      keymap[2+1] = saved_emacs_keys[0];
      keymap[14+1] = saved_emacs_keys[1];
      keymap[16+1] = saved_emacs_keys[2];
      keymap[6+1] = saved_emacs_keys[3];
a1612 4
      did_emacs_keys = FALSE;
}

static char saved_number_keys[9];
d1617 1
a1617 28
    /*
     *  Map numbers to functions as labeled on the
     *  IBM Enhanced keypad, and save their original
     *  mapping for reset_numbers_as_arrows(). - FM
     */
    saved_number_keys[0] = keymap['4'+1];
    keymap['4'+1] = LYK_PREV_DOC;
    saved_number_keys[1] = keymap['2'+1];
    keymap['2'+1] = LYK_NEXT_LINK;
    saved_number_keys[2] = keymap['8'+1];
    keymap['8'+1] = LYK_PREV_LINK;
    saved_number_keys[3] = keymap['6'+1];
    keymap['6'+1] = LYK_ACTIVATE;
    saved_number_keys[4] = keymap['7'+1];
    keymap['7'+1] = LYK_HOME;
    saved_number_keys[5] = keymap['1'+1];
    keymap['1'+1] = LYK_END;
    saved_number_keys[6] = keymap['9'+1];
    keymap['9'+1] = LYK_PREV_PAGE;
    saved_number_keys[7] = keymap['3'+1];
    keymap['3'+1] = LYK_NEXT_PAGE;

    /*
     *  Disable the 5.
     */
    saved_number_keys[8] = keymap['5'+1];
    keymap['5'+1] = LYK_DO_NOTHING;

d1623 3
a1625 25
    if (!did_number_keys)
	return;

    keymap['4'+1] = saved_number_keys[0];
    keymap['2'+1] = saved_number_keys[1];
    keymap['8'+1] = saved_number_keys[2];
    keymap['6'+1] = saved_number_keys[3];
    keymap['7'+1] = saved_number_keys[4];
    keymap['1'+1] = saved_number_keys[5];
    keymap['9'+1] = saved_number_keys[6];
    keymap['3'+1] = saved_number_keys[7];
    keymap['5'+1] = saved_number_keys[8];

    did_number_keys = FALSE;
}

PUBLIC int lookup_keymap ARGS1(
	int,	func)
{
    size_t i;

    for (i = 1; i < KEYMAP_SIZE; i++) {
	if (LYisNonAlnumKeyname(i, func)) {
	    return i;
	}
a1626 1
    return -1;
d1637 1
a1637 1
	formatted = pretty(i);
d1646 121
d1768 1
a1768 1
 *  and maps to key_name (LYK_foo in the keymap[] array). - FM
d1772 1
a1772 1
	int,	key_name)
d1774 6
a1779 3
    if ((ch >= '0' && ch <= '9') ||
        (ch >= 'A' && ch <= 'z') ||
	ch < 0 || ch >= KEYMAP_SIZE)
d1782 1
a1782 1
    return(keymap[ch+1] == key_name);
d1790 1
a1790 1
	int,	key_name)
d1795 1
a1795 1
	if (keymap[i] == key_name) {
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d3 1
a4 2
#include <LYKeymap.h>
#include <LYCharSets.h>		/* for LYlowest_eightbit - kw */
a7 1
#include <LYStrings.h>		/* for USE_KEYMAP stuff - kw */
a16 2
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

d18 1
a18 1
int current_layout = 0;		/* Index into LYKbLayouts[]   */
d20 4
a23 5
LYKbLayout_t *LYKbLayouts[] =
{
    kb_layout_rot13,
    kb_layout_jcuken,
    kb_layout_yawerty
d26 5
a30 6
const char *LYKbLayoutNames[] =
{
    "ROT13'd keyboard layout",
    "JCUKEN Cyrillic, for AT 101-key kbd",
    "YAWERTY Cyrillic, for DEC LK201 kbd",
    (char *) 0
d32 4
a35 1
#endif /* EXP_KEYBOARD_LAYOUT */
d37 3
a39 2
struct _HTStream {
    HTStreamClass *isa;
a41 13
/* * * Tables mapping LynxKeyCodes to LynxActionCodes  * * */

/*
 * Lynxkeycodes include all single-byte keys as well as codes for function keys
 * and some special purposes.  See LYStrings.h.  Extended lynxkeycode values
 * can also contain flags for modifiers and other purposes, but here only the
 * base values are mapped to lynxactioncodes.  They are called `keystrokes' in
 * lynx.cfg.
 *
 * Lynxactioncodes (confusingly, constants are named LYK_foo and typed as
 * LYKeymapCode) specify key `functions', see LYKeymap.h.
 */

a44 1
/* *INDENT-OFF* */
a58 5
#ifdef KANJI_CODE_OVERRIDE
LYK_CHG_KCODE,    LYK_ACTIVATE,     LYK_DOWN_TWO,      0,
/* ^L */            /* cr */        /* ^N */       /* ^O */

#else
a60 1
#endif
d62 2
a63 2
LYK_UP_TWO,       LYK_CHG_CENTER,   LYK_RELOAD,    LYK_TO_CLIPBOARD,
/* ^P */            /* XON */       /* ^R */       /* ^S */
d77 1
a77 1
LYK_LAST_LINK,          0,              0,          LYK_HISTORICAL,
d83 5
a87 1
LYK_EXTERN_PAGE,  LYK_PREV_PAGE, LYK_EXTERN_LINK,   LYK_WHEREIS,
d89 1
d97 1
a97 1
LYK_8,               LYK_9,         LYK_COMMAND,    LYK_TRACE_LOG,
a102 1
#ifndef SUPPORT_CHDIR
d105 6
d112 3
a114 3
LYK_RAW_TOGGLE,      LYK_ADDRLIST, LYK_PREV_PAGE,   LYK_CHDIR,
/* @@ */              /* A */         /* B */        /* C */
#endif
d116 2
a117 2
LYK_DOWNLOAD,        LYK_ELGOTO,  LYK_DIRED_MENU,   LYK_ECGOTO,
/* D */              /* E */         /* F */        /* G */
d122 1
a122 1
LYK_LIST,          LYK_MAIN_MENU,    LYK_PREV,      LYK_OPTIONS,
d134 1
a134 1
LYK_SOURCE,          LYK_HEAD,    LYK_FIRST_LINK,   LYK_CLEAR_AUTH,
d140 12
a151 2
LYK_DOWNLOAD,        LYK_EDIT,    LYK_DIRED_MENU,   LYK_GOTO,
/* d */              /* e */         /* f */        /* g */
d165 1
a165 1
LYK_NOCACHE,            0,          LYK_INTERRUPT, LYK_SHIFT_LEFT,
d168 8
a175 1
LYK_LINEWRAP_TOGGLE, LYK_SHIFT_RIGHT, LYK_NESTED_TABLES, LYK_HISTORY,
d178 1
d225 1
a225 1
LYK_DWIMHELP,          0,              0,             0,
d229 1
a229 1
LYK_DWIMHELP,     LYK_ACTIVATE,     LYK_HOME,       LYK_END,
d239 4
d244 1
d294 1
a294 1
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(USE_SLANG) /* PDCurses */
d314 1
a314 1
#endif /* (_WINDOWS || __DJGPP__ || __CYGWIN__) && !USE_SLANG */
d427 1
a427 1
#ifndef SUPPORT_CHDIR
a429 4
#else
   0,                  0,              0,         LYK_CHDIR,
/* @@ */             /* A */         /* B */        /* C */
#endif
d632 5
a636 1
#define DATA(code, name, doc) { code, name, doc }
d638 81
a718 268
static Kcmd revmap[] = {
    DATA(
	LYK_UNKNOWN, "UNMAPPED",
	NULL ),
    DATA(
	LYK_COMMAND, "COMMAND",
	"prompt for, execute a command" ),
    DATA(
	LYK_1, "1",
	NULL ),
    DATA(
	LYK_2, "2",
	NULL ),
    DATA(
	LYK_3, "3",
	NULL ),
    DATA(
	LYK_4, "4",
	NULL ),
    DATA(
	LYK_5, "5",
	NULL ),
    DATA(
	LYK_6, "6",
	NULL ),
    DATA(
	LYK_7, "7",
	NULL ),
    DATA(
	LYK_8, "8",
	NULL ),
    DATA(
	LYK_9, "9",
	NULL ),
    DATA(
	LYK_SOURCE, "SOURCE",
	"toggle source/presentation for current document" ),
    DATA(
	LYK_RELOAD, "RELOAD",
	"reload the current document" ),
    DATA(
	LYK_QUIT, "QUIT",
	"quit the browser" ),
    DATA(
	LYK_ABORT, "ABORT",
	"quit the browser unconditionally" ),
    DATA(
	LYK_NEXT_PAGE, "NEXT_PAGE",
	"view the next page of the document" ),
    DATA(
	LYK_PREV_PAGE, "PREV_PAGE",
	"view the previous page of the document" ),
    DATA(
	LYK_UP_TWO, "UP_TWO",
	"go back two lines in the document" ),
    DATA(
	LYK_DOWN_TWO, "DOWN_TWO",
	"go forward two lines in the document" ),
    DATA(
	LYK_UP_HALF, "UP_HALF",
	"go back half a page in the document" ),
    DATA(
	LYK_DOWN_HALF, "DOWN_HALF",
	"go forward half a page in the document" ),
    DATA(
	LYK_REFRESH, "REFRESH",
	"refresh the screen to clear garbled text" ),
    DATA(
	LYK_HOME, "HOME",
	"go to the beginning of the current document" ),
    DATA(
	LYK_END, "END",
	"go to the end of the current document" ),
    DATA(
	LYK_FIRST_LINK, "FIRST_LINK",
	"make the first link on the line current" ),
    DATA(
	LYK_LAST_LINK, "LAST_LINK",
	"make the last link on the line current" ),
    DATA(
	LYK_PREV_LINK, "PREV_LINK",
	"make the previous link current" ),
    DATA(
	LYK_NEXT_LINK, "NEXT_LINK",
	"make the next link current" ),
    DATA(
	LYK_LPOS_PREV_LINK, "LPOS_PREV_LINK",
	"make previous link current, same column for input" ),
    DATA(
	LYK_LPOS_NEXT_LINK, "LPOS_NEXT_LINK",
	"make next link current, same column for input" ),
    DATA(
	LYK_FASTBACKW_LINK, "FASTBACKW_LINK",
	"previous link or text area, only stops on links" ),
    DATA(
	LYK_FASTFORW_LINK, "FASTFORW_LINK",
	"next link or text area, only stops on links" ),
    DATA(
	LYK_UP_LINK, "UP_LINK",
	"move up the page to a previous link" ),
    DATA(
	LYK_DOWN_LINK, "DOWN_LINK",
	"move down the page to another link" ),
    DATA(
	LYK_RIGHT_LINK, "RIGHT_LINK",
	"move right to another link" ),
    DATA(
	LYK_LEFT_LINK, "LEFT_LINK",
	"move left to a previous link" ),
    DATA(
	LYK_HISTORY, "HISTORY",
	"display stack of currently-suspended documents" ),
    DATA(
	LYK_PREV_DOC, "PREV_DOC",
	"go back to the previous document" ),
    DATA(
	LYK_NEXT_DOC, "NEXT_DOC",
	"undo going back to the previous document" ),
    DATA(
	LYK_ACTIVATE, "ACTIVATE",
	"go to the document given by the current link" ),
    DATA(
	LYK_SUBMIT, "MOUSE_SUBMIT",
	"DO NOT MAP:  follow current link, submit" ),
    DATA(
	LYK_GOTO, "GOTO",
	"go to a document given as a URL" ),
    DATA(
	LYK_ECGOTO, "ECGOTO",
	"edit the current document's URL and go to it" ),
    DATA(
	LYK_HELP, "HELP",
	"display help on using the browser" ),
    DATA(
	LYK_DWIMHELP, "DWIMHELP",
	"display help page that may depend on context" ),
    DATA(
	LYK_INDEX, "INDEX",
	"display an index of potentially useful documents" ),
    DATA(
	LYK_NOCACHE, "NOCACHE",
	"force submission of form or link with no-cache" ),
    DATA(
	LYK_INTERRUPT, "INTERRUPT",
	"interrupt network connection or transmission" ),
    DATA(
	LYK_MAIN_MENU, "MAIN_MENU",
	"return to the first screen (home page)" ),
    DATA(
	LYK_OPTIONS, "OPTIONS",
	"display and change option settings" ),
    DATA(
	LYK_INDEX_SEARCH, "INDEX_SEARCH",
	"allow searching of an index" ),
    DATA(
	LYK_WHEREIS, "WHEREIS",
	"search within the current document" ),
    DATA(
	LYK_PREV, "PREV",
	"search for the previous occurence" ),
    DATA(
	LYK_NEXT, "NEXT",
	"search for the next occurence" ),
    DATA(
	LYK_COMMENT, "COMMENT",
	"send a comment to the author of the current document" ),
    DATA(
	LYK_EDIT, "EDIT",
	"edit the current document or a form's textarea" ),
    DATA(
	LYK_INFO, "INFO",
	"display information on the current document and link" ),
    DATA(
	LYK_PRINT, "PRINT",
	"display choices for printing the current document" ),
    DATA(
	LYK_ADD_BOOKMARK, "ADD_BOOKMARK",
	"add to your personal bookmark list" ),
    DATA(
	LYK_DEL_BOOKMARK, "DEL_BOOKMARK",
	"delete from your personal bookmark list" ),
    DATA(
	LYK_VIEW_BOOKMARK, "VIEW_BOOKMARK",
	"view your personal bookmark list" ),
    DATA(
	LYK_VLINKS, "VLINKS",
	"list links visited during the current Lynx session" ),
    DATA(
	LYK_SHELL, "SHELL",
	"escape from the browser to the system" ),
    DATA(
	LYK_DOWNLOAD, "DOWNLOAD",
	"download the current link to your computer" ),
    DATA(
	LYK_TRACE_TOGGLE, "TRACE_TOGGLE",
	"toggle tracing of browser operations" ),
    DATA(
	LYK_TRACE_LOG, "TRACE_LOG",
	"view trace log if started in the current session" ),
    DATA(
	LYK_IMAGE_TOGGLE, "IMAGE_TOGGLE",
	"toggle handling of all images as links" ),
    DATA(
	LYK_INLINE_TOGGLE, "INLINE_TOGGLE",
	"toggle pseudo-ALTs for inlines with no ALT string" ),
    DATA(
	LYK_HEAD, "HEAD",
	"send a HEAD request for the current document or link" ),
    DATA(
	LYK_DO_NOTHING, "DO_NOTHING",
	NULL ),
    DATA(
	LYK_TOGGLE_HELP, "TOGGLE_HELP",
	"show other commands in the novice help menu" ),
    DATA(
	LYK_JUMP, "JUMP",
	"go directly to a target document or action" ),
    DATA(
	LYK_KEYMAP, "KEYMAP",
	"display the current key map" ),
    DATA(
	LYK_LIST, "LIST",
	"list the references (links) in the current document" ),
    DATA(
	LYK_TOOLBAR, "TOOLBAR",
	"go to Toolbar or Banner in the current document" ),
    DATA(
	LYK_HISTORICAL, "HISTORICAL",
	"toggle historical vs.  valid/minimal comment parsing" ),
    DATA(
	LYK_MINIMAL, "MINIMAL",
	"toggle minimal vs.  valid comment parsing" ),
    DATA(
	LYK_SOFT_DQUOTES, "SOFT_DQUOTES",
	"toggle valid vs.  soft double-quote parsing" ),
    DATA(
	LYK_RAW_TOGGLE, "RAW_TOGGLE",
	"toggle raw 8-bit translations or CJK mode ON or OFF" ),
    DATA(
	LYK_COOKIE_JAR, "COOKIE_JAR",
	"examine the Cookie Jar" ),
    DATA(
	LYK_F_LINK_NUM, "F_LINK_NUM",
	"invoke the 'Follow link (or page) number:' prompt" ),
    DATA(
	LYK_CLEAR_AUTH, "CLEAR_AUTH",
	"clear all authorization info for this session" ),
    DATA(
	LYK_SWITCH_DTD, "SWITCH_DTD",
	"switch between two ways of parsing HTML" ),
    DATA(
	LYK_ELGOTO, "ELGOTO",
	"edit the current link's URL or ACTION and go to it" ),
    DATA(
	LYK_CHANGE_LINK, "CHANGE_LINK",
	"force reset of the current link on the page" ),
    DATA(
	LYK_DWIMEDIT, "DWIMEDIT",
	"use external editor for context-dependent purpose" ),
    DATA(
	LYK_EDIT_TEXTAREA, "EDITTEXTAREA",
	"use an external editor to edit a form's textarea" ),
    DATA(
	LYK_GROW_TEXTAREA, "GROWTEXTAREA",
	"add 5 new blank lines to the bottom of a textarea" ),
    DATA(
	LYK_INSERT_FILE, "INSERTFILE",
	"insert file into a textarea (just above cursorline)" ),
d720 1
a720 3
    DATA(
	LYK_ADDRLIST, "ADDRLIST",
	"like LIST command, but always shows the links' URLs" ),
d723 1
a723 6
    DATA(
	LYK_EXTERN_LINK, "EXTERN_LINK",
	"run external program with current link" ),
    DATA(
	LYK_EXTERN_PAGE, "EXTERN_PAGE",
	"run external program with current page" ),
d726 1
a726 3
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"invoke File/Directory Manager, if available" ),
d729 7
a735 21
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"display a full menu of file operations" ),
    DATA(
	LYK_CREATE, "CREATE",
	"create a new file or directory" ),
    DATA(
	LYK_REMOVE, "REMOVE",
	"remove a file or directory" ),
    DATA(
	LYK_MODIFY, "MODIFY",
	"modify the name or location of a file or directory" ),
    DATA(
	LYK_TAG_LINK, "TAG_LINK",
	"tag a file or directory for later action" ),
    DATA(
	LYK_UPLOAD, "UPLOAD",
	"upload from your computer to the current directory" ),
    DATA(
	LYK_INSTALL, "INSTALL",
	"install file or tagged files into a system area" ),
a736 8
    DATA(
	LYK_CHG_CENTER, "CHANGE_CENTER",
	"toggle center alignment in HTML TABLE" ),
#ifdef KANJI_CODE_OVERRIDE
    DATA(
	LYK_CHG_KCODE, "CHANGE_KCODE",
	"Change Kanji code" ),
#endif
d738 1
a738 69
#ifdef SUPPORT_CHDIR
    DATA(
	LYK_CHDIR, "CHDIR",
	"change current directory" ),
#endif
#ifdef USE_CURSES_PADS
    DATA(
	LYK_SHIFT_LEFT, "SHIFT_LEFT",
	"shift the screen left" ),
    DATA(
	LYK_SHIFT_RIGHT, "SHIFT_RIGHT",
	"shift the screen right" ),
    DATA(
	LYK_LINEWRAP_TOGGLE, "LINEWRAP_TOGGLE",
	"toggle linewrap on/off" ),
#endif
#ifdef CAN_CUT_AND_PASTE
    DATA(
	LYK_PASTE_URL, "PASTE_URL",
	"Goto the URL in the clipboard" ),
    DATA(
	LYK_TO_CLIPBOARD, "TO_CLIPBOARD",
	"link's URL to Clip Board" ),
#endif
#ifdef EXP_NESTED_TABLES
    DATA(
	LYK_NESTED_TABLES, "NESTED_TABLES",
	"toggle nested-table parsing on/off" ),
#endif
    DATA(
	LYK_UNKNOWN, NULL,
	"" )
};
#undef DATA

static const struct {
    int key;
    const char *name;
} named_keys[] = {
    { '\t',		"<tab>" },
    { '\r',		"<return>" },
    { CH_ESC,		"ESC" },
    { ' ',		"<space>" },
    { '<',		"<" },
    { '>',		">" },
    { CH_DEL,		"<delete>" },
    { UPARROW,		"Up Arrow" },
    { DNARROW,		"Down Arrow" },
    { RTARROW,		"Right Arrow" },
    { LTARROW,		"Left Arrow" },
    { PGDOWN,		"Page Down" },
    { PGUP,		"Page Up" },
    { HOME,		"Home" },
    { END_KEY,		"End" },
    { F1,		"F1" },
    { DO_KEY,		"Do key" },
    { FIND_KEY,		"Find key" },
    { SELECT_KEY,	"Select key" },
    { INSERT_KEY,	"Insert key" },
    { REMOVE_KEY,	"Remove key" },
    { DO_NOTHING,	"(DO_NOTHING)" },
    { BACKTAB_KEY,	"Back Tab" },
    { MOUSE_KEY,	"mouse pseudo key" },
};

struct emap {
    const char *name;
    const int   code;
    const char *descr;
d741 20
a760 53
static struct emap ekmap[] = {
  {"NOP",	LYE_NOP,	"Do Nothing"},
  {"CHAR",	LYE_CHAR,	"Insert printable char"},
  {"ENTER",	LYE_ENTER,	"Input complete, return char/lynxkeycode"},
  {"TAB",	LYE_TAB,	"Input complete, return TAB"},
  {"STOP",	LYE_STOP,	"Input deactivated"},
  {"ABORT",	LYE_ABORT,	"Input cancelled"},

  {"PASS",	LYE_FORM_PASS,  "In fields: input complete, or Do Nothing"},

  {"DELN",	LYE_DELN,	"Delete next/curr char"},
  {"DELP",	LYE_DELP,	"Delete prev      char"},
  {"DELNW",	LYE_DELNW,	"Delete next word"},
  {"DELPW",	LYE_DELPW,	"Delete prev word"},

  {"ERASE",	LYE_ERASE,	"Erase the line"},

  {"BOL",	LYE_BOL,	"Go to begin of line"},
  {"EOL",	LYE_EOL,	"Go to end   of line"},
  {"FORW",	LYE_FORW,	"Cursor forwards"},
  {"FORW_RL",	LYE_FORW_RL,	"Cursor forwards or right link"},
  {"BACK",	LYE_BACK,	"Cursor backwards"},
  {"BACK_LL",	LYE_BACK_LL,	"Cursor backwards or left link"},
  {"FORWW",	LYE_FORWW,	"Word forward"},
  {"BACKW",	LYE_BACKW,	"Word back"},

  {"LOWER",	LYE_LOWER,	"Lower case the line"},
  {"UPPER",	LYE_UPPER,	"Upper case the line"},

  {"LKCMD",	LYE_LKCMD,	"Invoke command prompt"},

  {"AIX",	LYE_AIX,	"Hex 97"},

  {"DELBL",	LYE_DELBL,	"Delete back to BOL"},
  {"DELEL",	LYE_DELEL,	"Delete thru EOL"},

  {"SWMAP",	LYE_SWMAP,	"Switch input keymap"},

  {"TPOS",	LYE_TPOS,	"Transpose characters"},

  {"SETM1",	LYE_SETM1,	"Set modifier 1 flag"},
  {"SETM2",	LYE_SETM2,	"Set modifier 2 flag"},
  {"UNMOD",	LYE_UNMOD,	"Fall back to no-modifier command"},

  {"C1CHAR",	LYE_C1CHAR,	"Insert C1 char if printable"},

  {"SETMARK",	LYE_SETMARK,	"emacs-like set-mark-command"},
  {"XPMARK",	LYE_XPMARK,	"emacs-like exchange-point-and-mark"},
  {"KILLREG",	LYE_KILLREG,	"emacs-like kill-region"},
  {"YANK",	LYE_YANK,	"emacs-like yank"},
#ifdef CAN_CUT_AND_PASTE
  {"PASTE",	LYE_PASTE,	"ClipBoard to Lynx"},
#endif
a761 1
/* *INDENT-ON* */
d763 1
a763 4
/*
 * Build a list of Lynx's commands, for use in the tab-completion in LYgetstr.
 */
HTList *LYcommandList(void)
d765 1
a765 4
    static HTList *myList = NULL;

    if (myList == NULL) {
	unsigned j;
d767 14
a780 89
	myList = HTList_new();
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].doc != 0) {
		char *data = NULL;

		StrAllocCopy(data, revmap[j].name);
		HTList_addObject(myList, data);
	    }
	}
    }
    return myList;
}

/*
 * Find the given keycode.
 */
Kcmd *LYKeycodeToKcmd(LYKeymapCode code)
{
    unsigned j;
    Kcmd *result = 0;

    if (code > LYK_UNKNOWN) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].code == code) {
		result = revmap + j;
		break;
	    }
	}
    }
    return result;
}

/*
 * Find the given command-name, accepting an abbreviation if it is unique.
 */
Kcmd *LYStringToKcmd(const char *name)
{
    unsigned need = strlen(name);
    unsigned j;
    BOOL exact = FALSE;
    Kcmd *result = 0;
    Kcmd *maybe = 0;

    if (non_empty(name)) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (!strcasecomp(revmap[j].name, name)) {
		result = revmap + j;
		break;
	    } else if (!exact
		       && !strncasecomp(revmap[j].name, name, need)) {
		if (maybe == 0) {
		    maybe = revmap + j;
		} else {
		    if (revmap[j].name[need] != 0
			&& maybe->name[need] != 0) {
			maybe = 0;
			exact = TRUE;
		    }
		}
	    }
	}
    }
    return (result != 0) ? result : maybe;
}

char *LYKeycodeToString(int c,
			BOOLEAN upper8)
{
    static char buf[30];
    unsigned n;
    BOOLEAN named = FALSE;

    for (n = 0; n < TABLESIZE(named_keys); n++) {
	if (named_keys[n].key == c) {
	    named = TRUE;
	    strcpy(buf, named_keys[n].name);
	    break;
	}
    }

    if (!named) {
	if (c > ' '
	    && c < 0177)
	    sprintf(buf, "%c", c);
	else if (upper8
		 && c > ' '
		 && c <= 0377
		 && c <= LYlowest_eightbit[current_char_set])
	    sprintf(buf, "%c", c);
d782 4
a785 1
	    sprintf(buf, "^%c", c | 0100);
d787 1
a787 1
	    sprintf(buf, "key-0x%x", c);
d789 1
a789 4
	    sprintf(buf, "0x%x", c);
    }
    return buf;
}
a790 78
int LYStringToKeycode(char *src)
{
    unsigned n;
    int key = -1;
    int len = strlen(src);

    if (len == 1) {
	key = *src;
    } else if (len == 2 && *src == '^') {
	key = src[1] & 0x1f;
    } else if (len > 2 && !strncasecomp(src, "0x", 2)) {
	char *dst = 0;

	key = strtol(src, &dst, 0);
	if (isEmpty(dst))
	    key = -1;
    } else if (len > 6 && !strncasecomp(src, "key-", 4)) {
	char *dst = 0;

	key = strtol(src + 4, &dst, 0);
	if (isEmpty(dst))
	    key = -1;
    }
    if (key < 0) {
	for (n = 0; n < TABLESIZE(named_keys); n++) {
	    if (!strcasecomp(named_keys[n].name, src)) {
		key = named_keys[n].key;
		break;
	    }
	}
    }
    return key;
}

#define PRETTY_LEN 11

static char *pretty_html(int c)
{
    char *src = LYKeycodeToString(c, TRUE);

    if (src != 0) {
	/* *INDENT-OFF* */
	static const struct {
	    int	code;
	    const char *name;
	} table[] = {
	    { '<',	"&lt;" },
	    { '>',	"&gt;" },
	    { '"',	"&quot;" },
	    { '&',	"&amp;" }
	};
	/* *INDENT-ON* */

	static char buf[30];
	char *dst = buf;
	int adj = 0;
	unsigned n;
	BOOLEAN found;

	while ((c = *src++) != 0) {
	    found = FALSE;
	    for (n = 0; n < TABLESIZE(table); n++) {
		if (c == table[n].code) {
		    found = TRUE;
		    strcpy(dst, table[n].name);
		    adj += strlen(dst) - 1;
		    dst += strlen(dst);
		    break;
		}
	    }
	    if (!found) {
		*dst++ = (char) c;
	    }
	}
	adj -= (dst - buf) - PRETTY_LEN;
	while (adj-- > 0)
	    *dst++ = ' ';
	*dst = 0;
a791 3
    }

    return 0;
d794 3
a796 1
static char *format_binding(LYKeymap_t * table, int i)
d798 1
a798 1
    LYKeymapCode the_key = (LYKeymapCode) table[i];
a800 1
    Kcmd *rmap = LYKeycodeToKcmd(the_key);
d802 8
a809 8
    if (rmap != 0
	&& rmap->name != 0
	&& rmap->doc != 0
	&& (formatted = pretty_html(i - 1)) != 0) {
	HTSprintf0(&buf, "%-*s %-13s %s\n",
		   PRETTY_LEN, formatted,
		   rmap->name,
		   rmap->doc);
d815 1
a815 4
/* if both is true, produce an additional line for the corresponding
   uppercase key if its binding is different. - kw */
static void print_binding(HTStream *target, int i,
			  BOOLEAN both)
a817 2
    LYKeymapCode lac1 = LYK_UNKNOWN;	/* 0 */

d820 3
a822 5
	(lac1 = (LYKeymapCode) key_override[i]) != LYK_UNKNOWN) {
	if ((buf = format_binding(key_override, i)) != 0) {
	    PUTS(buf);
	    FREE(buf);
	}
d826 1
a826 20
	lac1 = (LYKeymapCode) keymap[i];
	PUTS(buf);
	FREE(buf);
    }

    if (!both)
	return;
    i -= ' ';			/* corresponding uppercase key */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    if (prev_lynx_edit_mode && !no_dired_support && key_override[i]) {
	if (key_override[i] != lac1 &&
	    (buf = format_binding(key_override, i)) != 0) {
	    PUTS(buf);
	    FREE(buf);
	}
    } else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
    if (keymap[i] != lac1 && (buf = format_binding(keymap, i)) != 0) {
	PUTS(buf);
d831 5
a835 73
/*
 * Return lynxactioncode whose name is the string func.  returns -1 if not
 * found.  - kw
 */
int lacname_to_lac(const char *func)
{
    Kcmd *mp = LYStringToKcmd(func);

    return (mp != 0) ? (int) mp->code : -1;
}

/*
 * Return editactioncode whose name is the string func.  func must be present
 * in the ekmap table.  returns -1 if not found.  - kw
 */
int lecname_to_lec(const char *func)
{
    int i;
    struct emap *mp;

    if (non_empty(func)) {
	for (i = 0, mp = ekmap; (*mp).name != NULL; mp++, i++) {
	    if (strcmp((*mp).name, func) == 0) {
		return (*mp).code;
	    }
	}
    }
    return (-1);
}

/*
 * Return lynxkeycode represented by string src.  returns -1 if not valid.
 *
 * This is simpler than what map_string_to_keysym() does for USE_KEYMAP, but
 * compatible with revmap() used for processing KEYMAP options in the
 * configuration file.  - kw
 */
int lkcstring_to_lkc(const char *src)
{
    int c = -1;

    if (strlen(src) == 1)
	c = *src;
    else if (strlen(src) == 2 && *src == '^')
	c = src[1] & 037;
    else if (strlen(src) >= 2 && isdigit(UCH(*src))) {
	if (sscanf(src, "%i", &c) != 1)
	    return (-1);
#ifdef USE_KEYMAPS
    } else {
	map_string_to_keysym(src, &c);
#ifndef USE_SLANG
	if (c >= 0) {
	    if ((c & LKC_MASK) > 255 && !(c & LKC_ISLKC))
		return (-1);	/* Don't accept untranslated curses KEY_* */
	    else
		c &= ~LKC_ISLKC;
	}
#endif
#endif
    }
    if (c == CH_ESC)
	escape_bound = 1;
    if (c < -1)
	return (-1);
    else
	return c;
}

static int LYLoadKeymap(const char *arg GCC_UNUSED,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
d843 1
a843 1
     * Set up the stream.  - FM
d848 1
a848 1
		   HTAtom_name(format_in), HTAtom_name(format_out));
d851 1
a851 1
	return (HT_NOT_LOADED);
d855 8
a862 3
    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       CURRENT_KEYMAP_TITLE);
    PUTS(buf);
d864 1
a864 1
    PUTS(buf);
d866 5
a870 2
    for (i = 'a' + 1; i <= 'z' + 1; i++) {
	print_binding(target, i, TRUE);
d874 3
a876 1
	 * Don't show CHANGE_LINK if mouse not enabled.
d878 4
a881 3
	if ((i >= 0200 || i <= ' ' || !isalpha(i - 1)) &&
	    (LYUseMouse || (keymap[i] != LYK_CHANGE_LINK))) {
	    print_binding(target, i, FALSE);
d885 2
a886 2
    HTSprintf0(&buf, "</pre>\n</body>\n</html>\n");
    PUTS(buf);
d888 1
a888 1
    (*target->isa->_free) (target);
d890 1
a890 1
    return (HT_LOADED);
d895 1
a895 1
GLOBALDEF(HTProtocol, LYLynxKeymap, _LYKEYMAP_C_GLOBALDEF_1_INIT);
d897 1
a897 2
GLOBALDEF HTProtocol LYLynxKeymap =
{"LYNXKEYMAP", LYLoadKeymap, 0};
d901 3
a903 6
 * Install func as the mapping for key.
 * If for_dired is TRUE, install it in the key_override[] table
 * for Dired mode, otherwise in the general keymap[] table.
 * If DIRED_SUPPORT or OK_OVERRIDE is not defined, don't do anything
 * when for_dired is requested.
 * returns lynxkeycode value != 0 if the mapping was made, 0 if not.
d905 28
a932 3
int remap(char *key,
	  const char *func,
	  BOOLEAN for_dired)
d934 2
a935 35
    Kcmd *mp;
    int c;

#if !defined(DIRED_SUPPORT) || !defined(OK_OVERRIDE)
    if (for_dired)
	return 0;
#endif
    if (func == NULL)
	return 0;
    c = lkcstring_to_lkc(key);
    if (c <= -1)
	return 0;
    else if (c >= 0) {
	/* Remapping of key actions is supported only for basic
	 * lynxkeycodes, without modifiers etc.!  If we get somehow
	 * called for an invalid lynxkeycode, fail or silently ignore
	 * modifiers. - kw
	 */
	if (c & (LKC_ISLECLAC | LKC_ISLAC))
	    return 0;
	if ((c & LKC_MASK) != c)
	    c &= LKC_MASK;
    }
    if (c + 1 >= KEYMAP_SIZE)
	return 0;
    if ((mp = LYStringToKcmd(func)) != 0) {
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (for_dired)
	    key_override[c + 1] = mp->code;
	else
#endif
	    keymap[c + 1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code));	/* don't return 0, successful */
    }
    return 0;
d938 2
a939 5
typedef struct {
    int code;
    LYKeymap_t map;
    LYKeymap_t save;
} ANY_KEYS;
d941 1
a941 4
/*
 * Save the given keys in the table, setting them to the map'd value.
 */
static void set_any_keys(ANY_KEYS * table, int size)
d943 8
a950 1
    int j, k;
d952 1
a952 5
    for (j = 0; j < size; ++j) {
	k = table[j].code + 1;
	table[j].save = keymap[k];
	keymap[k] = table[j].map;
    }
d955 1
a955 4
/*
 * Restore the given keys from the table.
 */
static void reset_any_keys(ANY_KEYS * table, int size)
d957 7
a963 1
    int j, k;
d965 1
a965 4
    for (j = 0; j < size; ++j) {
	k = table[j].code + 1;
	keymap[k] = table[j].save;
    }
d968 4
a971 1
static ANY_KEYS vms_keys_table[] =
d973 8
a980 3
    {26, LYK_ABORT, 0},		/* control-Z */
    {'$', LYK_SHELL, 0},
};
d982 1
a982 3
void set_vms_keys(void)
{
    set_any_keys(vms_keys_table, TABLESIZE(vms_keys_table));
d985 1
a985 1
static ANY_KEYS vi_keys_table[] =
d987 2
a988 5
    {'h', LYK_PREV_DOC, 0},
    {'j', LYK_NEXT_LINK, 0},
    {'k', LYK_PREV_LINK, 0},
    {'l', LYK_ACTIVATE, 0},
};
d990 4
a993 1
static BOOLEAN did_vi_keys;
d995 1
a995 4
void set_vi_keys(void)
{
    set_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
    did_vi_keys = TRUE;
d998 2
a999 7
void reset_vi_keys(void)
{
    if (did_vi_keys) {
	reset_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
	did_vi_keys = FALSE;
    }
}
d1001 1
a1001 1
static ANY_KEYS emacs_keys_table[] =
d1003 21
a1023 5
    {2, LYK_PREV_DOC, 0},	/* ^B */
    {14, LYK_NEXT_LINK, 0},	/* ^N */
    {16, LYK_PREV_LINK, 0},	/* ^P */
    {6, LYK_ACTIVATE, 0},	/* ^F */
};
d1025 5
a1029 1
static BOOLEAN did_emacs_keys;
d1031 1
a1031 4
void set_emacs_keys(void)
{
    set_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
    did_emacs_keys = TRUE;
d1034 1
a1034 1
void reset_emacs_keys(void)
d1036 2
a1037 22
    if (did_emacs_keys) {
	reset_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
	did_emacs_keys = FALSE;
    }
}

/*
 * Map numbers to functions as labeled on the IBM Enhanced keypad, and save
 * their original mapping for reset_numbers_as_arrows().  - FM
 */
static ANY_KEYS number_keys_table[] =
{
    {'1', LYK_END, 0},
    {'2', LYK_NEXT_LINK, 0},
    {'3', LYK_NEXT_PAGE, 0},
    {'4', LYK_PREV_DOC, 0},
    {'5', LYK_DO_NOTHING, 0},
    {'6', LYK_ACTIVATE, 0},
    {'7', LYK_HOME, 0},
    {'8', LYK_PREV_LINK, 0},
    {'9', LYK_PREV_PAGE, 0},
};
d1039 9
a1047 1
static BOOLEAN did_number_keys;
d1049 1
a1049 4
void set_numbers_as_arrows(void)
{
    set_any_keys(number_keys_table, TABLESIZE(number_keys_table));
    did_number_keys = TRUE;
d1052 2
a1053 1
void reset_numbers_as_arrows(void)
d1055 6
a1060 3
    if (did_number_keys) {
	reset_any_keys(number_keys_table, TABLESIZE(number_keys_table));
	did_number_keys = FALSE;
d1062 1
d1065 2
a1066 1
char *key_for_func(int func)
d1073 1
a1073 1
	formatted = LYKeycodeToString(i, TRUE);
d1082 2
a1083 4
 * Given one or two keys as lynxkeycodes, returns an allocated string
 * representing the key(s) suitable for statusline messages, or NULL if no
 * valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other failure). 
 * The caller must free the string.  - kw
d1085 7
a1091 124
char *fmt_keys(int lkc_first,
	       int lkc_second)
{
    char *buf = NULL;
    BOOLEAN quotes = FALSE;
    char *fmt_first;
    char *fmt_second;

    if (lkc_first < 0)
	return NULL;
    fmt_first = LYKeycodeToString(lkc_first, TRUE);
    if (fmt_first && strlen(fmt_first) == 1 && *fmt_first != '\'') {
	quotes = TRUE;
    }
    if (quotes) {
	if (lkc_second < 0) {
	    HTSprintf0(&buf, "'%s'", fmt_first);
	    return buf;
	} else {
	    HTSprintf0(&buf, "'%s", fmt_first);
	}
    } else {
	StrAllocCopy(buf, fmt_first);
    }
    if (lkc_second >= 0) {
	fmt_second = LYKeycodeToString(lkc_second, TRUE);
	if (!fmt_second) {
	    FREE(buf);
	    return NULL;
	}
	HTSprintf(&buf, "%s%s%s",
		  (((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		    (strlen(buf) > 2 && buf[strlen(buf) - 1] != '>'))
		   ? " "
		   : ""),
		  fmt_second, quotes ? "'" : "");
    }
    return buf;
}

/*
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  It is like LYReverseKeymap, only the order of search is
 * different; e.g., small ASCII letters will be returned in preference to
 * capital ones.  Cf.  LYKeyForEditAction, LYEditKeyForAction in LYEditmap.c
 * which use the same order to find a best key.  In addition, this function
 * takes the dired override map into account while LYReverseKeymap doesn't. 
 * The caller must free the returned string.  - kw
 */
#define FIRST_I 97
#define NEXT_I(i,imax) ((i==122) ? 32 : (i==96) ? 123 : (i==126) ? 0 :\
			(i==31) ? 256 : (i==imax) ? 127 :\
			(i==255) ? (-1) :i+1)
static int best_reverse_keymap(int lac)
{
    int i, c;

    for (i = FIRST_I; i >= 0; i = NEXT_I(i, KEYMAP_SIZE - 2)) {
#ifdef NOT_ASCII
	if (i < 256) {
	    c = FROMASCII(i);
	} else
#endif
	    c = i;
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && lac &&
	    LKC_TO_LAC(key_override, c) == lac)
	    return c;
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	if (LKC_TO_LAC(keymap, c) == lac) {
	    return c;
	}
    }

    return (-1);
}

/*
 * This function returns a string representing a key mapped to a LYK_foo
 * function, or NULL if not found.  The string may represent a pair of keys. 
 * if context_code is FOR_INPUT, an appropriate binding for use while in the
 * (forms) line editor is sought.  - kw
 */
char *key_for_func_ext(int lac,
		       int context_code)
{
    int lkc, modkey = -1;

    if (context_code == FOR_INPUT) {
	lkc = LYEditKeyForAction(lac, &modkey);
	if (lkc >= 0) {
	    if (lkc & (LKC_MOD1 | LKC_MOD2 | LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1 | LKC_MOD2 | LKC_MOD3));
	    } else {
		return fmt_keys(lkc, -1);
	    }
	}
    }
    lkc = best_reverse_keymap(lac);
    if (lkc < 0)
	return NULL;
    if (context_code == FOR_INPUT) {
	modkey = LYKeyForEditAction(LYE_LKCMD);
	if (modkey < 0)
	    return NULL;
	return fmt_keys(modkey, lkc);
    } else {
	return fmt_keys(lkc, -1);
    }
}

/*
 * This function returns TRUE if the ch is non-alphanumeric and maps to KeyName
 * (LYK_foo in the keymap[] array).  - FM
 */
BOOL LYisNonAlnumKeyname(int ch,
			 int KeyName)
{
    if (ch < 0 || ch >= KEYMAP_SIZE)
	return (FALSE);
    if (ch > 0
	&& strchr("0123456789\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz", ch) != NULL)
d1094 1
a1094 1
    return (BOOL) (keymap[ch + 1] == KeyName);
d1098 2
a1099 2
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  - FM
d1101 2
a1102 1
int LYReverseKeymap(int KeyName)
d1107 2
a1108 2
	if (keymap[i] == KeyName) {
	    return (i - 1);
d1112 1
a1112 1
    return (-1);
d1116 2
a1117 1
int LYSetKbLayout(char *layout_id)
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d3 1
a4 2
#include <LYKeymap.h>
#include <LYCharSets.h>		/* for LYlowest_eightbit - kw */
a7 1
#include <LYStrings.h>		/* for USE_KEYMAP stuff - kw */
d20 1
a20 1
PUBLIC LYKbLayout_t * LYKbLayouts[]={
d32 4
a35 1
#endif /* EXP_KEYBOARD_LAYOUT */
a41 13
/* * *  Tables mapping LynxKeyCodes to LynxActionCodes  * * */

/*
 *  Lynxkeycodes include all single-byte keys as well as codes
 *  for function keys and some special purposes.  See LYStrings.h.
 *  Extended lynxkeycode values can also contain flags for modifiers
 *  and other purposes, but here only the base values are mapped to
 *  lynxactioncodes.  They are called `keystrokes' in lynx.cfg.
 *
 *  Lynxactioncodes (confusingly, constants are named LYK_foo and
 *  typed as LYKeymapCode) specify key `functions', see LYKeymap.h.
 */

a58 5
#ifdef KANJI_CODE_OVERRIDE
LYK_CHG_KCODE,    LYK_ACTIVATE,     LYK_DOWN_TWO,      0,
/* ^L */            /* cr */        /* ^N */       /* ^O */

#else
a60 1
#endif
d62 2
a63 2
LYK_UP_TWO,       LYK_CHG_CENTER,   LYK_RELOAD,    LYK_TO_CLIPBOARD,
/* ^P */            /* XON */       /* ^R */       /* ^S */
d77 1
a77 1
LYK_LAST_LINK,          0,              0,          LYK_HISTORICAL,
d83 5
a87 1
LYK_EXTERN_PAGE,  LYK_PREV_PAGE, LYK_EXTERN_LINK,   LYK_WHEREIS,
d89 1
d97 1
a97 1
LYK_8,               LYK_9,         LYK_COMMAND,    LYK_TRACE_LOG,
a102 1
#ifndef SUPPORT_CHDIR
d105 6
d112 3
a114 3
LYK_RAW_TOGGLE,      LYK_ADDRLIST, LYK_PREV_PAGE,   LYK_CHDIR,
/* @@ */              /* A */         /* B */        /* C */
#endif
d116 2
a117 2
LYK_DOWNLOAD,        LYK_ELGOTO,  LYK_DIRED_MENU,   LYK_ECGOTO,
/* D */              /* E */         /* F */        /* G */
d122 1
a122 1
LYK_LIST,          LYK_MAIN_MENU,    LYK_PREV,      LYK_OPTIONS,
d134 1
a134 1
LYK_SOURCE,          LYK_HEAD,    LYK_FIRST_LINK,   LYK_CLEAR_AUTH,
d140 12
a151 2
LYK_DOWNLOAD,        LYK_EDIT,    LYK_DIRED_MENU,   LYK_GOTO,
/* d */              /* e */         /* f */        /* g */
d165 1
a165 1
LYK_NOCACHE,            0,          LYK_INTERRUPT, LYK_SHIFT_LEFT,
d168 8
a175 1
LYK_LINEWRAP_TOGGLE, LYK_SHIFT_RIGHT, LYK_NESTED_TABLES, LYK_HISTORY,
d178 1
d225 1
a225 1
LYK_DWIMHELP,          0,              0,             0,
d229 1
a229 1
LYK_DWIMHELP,     LYK_ACTIVATE,     LYK_HOME,       LYK_END,
d239 4
d244 1
d294 1
a294 1
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(USE_SLANG) /* PDCurses */
d314 1
a314 1
#endif /* (_WINDOWS || __DJGPP__ || __CYGWIN__) && !USE_SLANG */
d427 1
a427 1
#ifndef SUPPORT_CHDIR
a429 4
#else
   0,                  0,              0,         LYK_CHDIR,
/* @@ */             /* A */         /* B */        /* C */
#endif
d632 5
a636 1
#define DATA(code, name, doc) { code, name, doc }
d638 81
a718 268
PRIVATE Kcmd revmap[] = {
    DATA(
	LYK_UNKNOWN, "UNMAPPED",
	NULL ),
    DATA(
	LYK_COMMAND, "COMMAND",
	"prompt for, execute a command" ),
    DATA(
	LYK_1, "1",
	NULL ),
    DATA(
	LYK_2, "2",
	NULL ),
    DATA(
	LYK_3, "3",
	NULL ),
    DATA(
	LYK_4, "4",
	NULL ),
    DATA(
	LYK_5, "5",
	NULL ),
    DATA(
	LYK_6, "6",
	NULL ),
    DATA(
	LYK_7, "7",
	NULL ),
    DATA(
	LYK_8, "8",
	NULL ),
    DATA(
	LYK_9, "9",
	NULL ),
    DATA(
	LYK_SOURCE, "SOURCE",
	"toggle source/presentation for current document" ),
    DATA(
	LYK_RELOAD, "RELOAD",
	"reload the current document" ),
    DATA(
	LYK_QUIT, "QUIT",
	"quit the browser" ),
    DATA(
	LYK_ABORT, "ABORT",
	"quit the browser unconditionally" ),
    DATA(
	LYK_NEXT_PAGE, "NEXT_PAGE",
	"view the next page of the document" ),
    DATA(
	LYK_PREV_PAGE, "PREV_PAGE",
	"view the previous page of the document" ),
    DATA(
	LYK_UP_TWO, "UP_TWO",
	"go back two lines in the document" ),
    DATA(
	LYK_DOWN_TWO, "DOWN_TWO",
	"go forward two lines in the document" ),
    DATA(
	LYK_UP_HALF, "UP_HALF",
	"go back half a page in the document" ),
    DATA(
	LYK_DOWN_HALF, "DOWN_HALF",
	"go forward half a page in the document" ),
    DATA(
	LYK_REFRESH, "REFRESH",
	"refresh the screen to clear garbled text" ),
    DATA(
	LYK_HOME, "HOME",
	"go to the beginning of the current document" ),
    DATA(
	LYK_END, "END",
	"go to the end of the current document" ),
    DATA(
	LYK_FIRST_LINK, "FIRST_LINK",
	"make the first link on the line current" ),
    DATA(
	LYK_LAST_LINK, "LAST_LINK",
	"make the last link on the line current" ),
    DATA(
	LYK_PREV_LINK, "PREV_LINK",
	"make the previous link current" ),
    DATA(
	LYK_NEXT_LINK, "NEXT_LINK",
	"make the next link current" ),
    DATA(
	LYK_LPOS_PREV_LINK, "LPOS_PREV_LINK",
	"make previous link current, same column for input" ),
    DATA(
	LYK_LPOS_NEXT_LINK, "LPOS_NEXT_LINK",
	"make next link current, same column for input" ),
    DATA(
	LYK_FASTBACKW_LINK, "FASTBACKW_LINK",
	"previous link or text area, only stops on links" ),
    DATA(
	LYK_FASTFORW_LINK, "FASTFORW_LINK",
	"next link or text area, only stops on links" ),
    DATA(
	LYK_UP_LINK, "UP_LINK",
	"move up the page to a previous link" ),
    DATA(
	LYK_DOWN_LINK, "DOWN_LINK",
	"move down the page to another link" ),
    DATA(
	LYK_RIGHT_LINK, "RIGHT_LINK",
	"move right to another link" ),
    DATA(
	LYK_LEFT_LINK, "LEFT_LINK",
	"move left to a previous link" ),
    DATA(
	LYK_HISTORY, "HISTORY",
	"display stack of currently-suspended documents" ),
    DATA(
	LYK_PREV_DOC, "PREV_DOC",
	"go back to the previous document" ),
    DATA(
	LYK_NEXT_DOC, "NEXT_DOC",
	"undo going back to the previous document" ),
    DATA(
	LYK_ACTIVATE, "ACTIVATE",
	"go to the document given by the current link" ),
    DATA(
	LYK_SUBMIT, "MOUSE_SUBMIT",
	"DO NOT MAP:  follow current link, submit" ),
    DATA(
	LYK_GOTO, "GOTO",
	"go to a document given as a URL" ),
    DATA(
	LYK_ECGOTO, "ECGOTO",
	"edit the current document's URL and go to it" ),
    DATA(
	LYK_HELP, "HELP",
	"display help on using the browser" ),
    DATA(
	LYK_DWIMHELP, "DWIMHELP",
	"display help page that may depend on context" ),
    DATA(
	LYK_INDEX, "INDEX",
	"display an index of potentially useful documents" ),
    DATA(
	LYK_NOCACHE, "NOCACHE",
	"force submission of form or link with no-cache" ),
    DATA(
	LYK_INTERRUPT, "INTERRUPT",
	"interrupt network connection or transmission" ),
    DATA(
	LYK_MAIN_MENU, "MAIN_MENU",
	"return to the first screen (home page)" ),
    DATA(
	LYK_OPTIONS, "OPTIONS",
	"display and change option settings" ),
    DATA(
	LYK_INDEX_SEARCH, "INDEX_SEARCH",
	"allow searching of an index" ),
    DATA(
	LYK_WHEREIS, "WHEREIS",
	"search within the current document" ),
    DATA(
	LYK_PREV, "PREV",
	"search for the previous occurence" ),
    DATA(
	LYK_NEXT, "NEXT",
	"search for the next occurence" ),
    DATA(
	LYK_COMMENT, "COMMENT",
	"send a comment to the author of the current document" ),
    DATA(
	LYK_EDIT, "EDIT",
	"edit the current document or a form's textarea" ),
    DATA(
	LYK_INFO, "INFO",
	"display information on the current document and link" ),
    DATA(
	LYK_PRINT, "PRINT",
	"display choices for printing the current document" ),
    DATA(
	LYK_ADD_BOOKMARK, "ADD_BOOKMARK",
	"add to your personal bookmark list" ),
    DATA(
	LYK_DEL_BOOKMARK, "DEL_BOOKMARK",
	"delete from your personal bookmark list" ),
    DATA(
	LYK_VIEW_BOOKMARK, "VIEW_BOOKMARK",
	"view your personal bookmark list" ),
    DATA(
	LYK_VLINKS, "VLINKS",
	"list links visited during the current Lynx session" ),
    DATA(
	LYK_SHELL, "SHELL",
	"escape from the browser to the system" ),
    DATA(
	LYK_DOWNLOAD, "DOWNLOAD",
	"download the current link to your computer" ),
    DATA(
	LYK_TRACE_TOGGLE, "TRACE_TOGGLE",
	"toggle tracing of browser operations" ),
    DATA(
	LYK_TRACE_LOG, "TRACE_LOG",
	"view trace log if started in the current session" ),
    DATA(
	LYK_IMAGE_TOGGLE, "IMAGE_TOGGLE",
	"toggle handling of all images as links" ),
    DATA(
	LYK_INLINE_TOGGLE, "INLINE_TOGGLE",
	"toggle pseudo-ALTs for inlines with no ALT string" ),
    DATA(
	LYK_HEAD, "HEAD",
	"send a HEAD request for the current document or link" ),
    DATA(
	LYK_DO_NOTHING, "DO_NOTHING",
	NULL ),
    DATA(
	LYK_TOGGLE_HELP, "TOGGLE_HELP",
	"show other commands in the novice help menu" ),
    DATA(
	LYK_JUMP, "JUMP",
	"go directly to a target document or action" ),
    DATA(
	LYK_KEYMAP, "KEYMAP",
	"display the current key map" ),
    DATA(
	LYK_LIST, "LIST",
	"list the references (links) in the current document" ),
    DATA(
	LYK_TOOLBAR, "TOOLBAR",
	"go to Toolbar or Banner in the current document" ),
    DATA(
	LYK_HISTORICAL, "HISTORICAL",
	"toggle historical vs.  valid/minimal comment parsing" ),
    DATA(
	LYK_MINIMAL, "MINIMAL",
	"toggle minimal vs.  valid comment parsing" ),
    DATA(
	LYK_SOFT_DQUOTES, "SOFT_DQUOTES",
	"toggle valid vs.  soft double-quote parsing" ),
    DATA(
	LYK_RAW_TOGGLE, "RAW_TOGGLE",
	"toggle raw 8-bit translations or CJK mode ON or OFF" ),
    DATA(
	LYK_COOKIE_JAR, "COOKIE_JAR",
	"examine the Cookie Jar" ),
    DATA(
	LYK_F_LINK_NUM, "F_LINK_NUM",
	"invoke the 'Follow link (or page) number:' prompt" ),
    DATA(
	LYK_CLEAR_AUTH, "CLEAR_AUTH",
	"clear all authorization info for this session" ),
    DATA(
	LYK_SWITCH_DTD, "SWITCH_DTD",
	"switch between two ways of parsing HTML" ),
    DATA(
	LYK_ELGOTO, "ELGOTO",
	"edit the current link's URL or ACTION and go to it" ),
    DATA(
	LYK_CHANGE_LINK, "CHANGE_LINK",
	"force reset of the current link on the page" ),
    DATA(
	LYK_DWIMEDIT, "DWIMEDIT",
	"use external editor for context-dependent purpose" ),
    DATA(
	LYK_EDIT_TEXTAREA, "EDITTEXTAREA",
	"use an external editor to edit a form's textarea" ),
    DATA(
	LYK_GROW_TEXTAREA, "GROWTEXTAREA",
	"add 5 new blank lines to the bottom of a textarea" ),
    DATA(
	LYK_INSERT_FILE, "INSERTFILE",
	"insert file into a textarea (just above cursorline)" ),
d720 1
a720 3
    DATA(
	LYK_ADDRLIST, "ADDRLIST",
	"like LIST command, but always shows the links' URLs" ),
d723 1
a723 6
    DATA(
	LYK_EXTERN_LINK, "EXTERN_LINK",
	"run external program with current link" ),
    DATA(
	LYK_EXTERN_PAGE, "EXTERN_PAGE",
	"run external program with current page" ),
d726 1
a726 3
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"invoke File/Directory Manager, if available" ),
d729 7
a735 21
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"display a full menu of file operations" ),
    DATA(
	LYK_CREATE, "CREATE",
	"create a new file or directory" ),
    DATA(
	LYK_REMOVE, "REMOVE",
	"remove a file or directory" ),
    DATA(
	LYK_MODIFY, "MODIFY",
	"modify the name or location of a file or directory" ),
    DATA(
	LYK_TAG_LINK, "TAG_LINK",
	"tag a file or directory for later action" ),
    DATA(
	LYK_UPLOAD, "UPLOAD",
	"upload from your computer to the current directory" ),
    DATA(
	LYK_INSTALL, "INSTALL",
	"install file or tagged files into a system area" ),
a736 8
    DATA(
	LYK_CHG_CENTER, "CHANGE_CENTER",
	"toggle center alignment in HTML TABLE" ),
#ifdef KANJI_CODE_OVERRIDE
    DATA(
	LYK_CHG_KCODE, "CHANGE_KCODE",
	"Change Kanji code" ),
#endif
d738 1
a738 63
#ifdef SUPPORT_CHDIR
    DATA(
	LYK_CHDIR, "CHDIR",
	"change current directory" ),
#endif
#ifdef USE_CURSES_PADS
    DATA(
	LYK_SHIFT_LEFT, "SHIFT_LEFT",
	"shift the screen left" ),
    DATA(
	LYK_SHIFT_RIGHT, "SHIFT_RIGHT",
	"shift the screen right" ),
    DATA(
	LYK_LINEWRAP_TOGGLE, "LINEWRAP_TOGGLE",
	"toggle linewrap on/off" ),
#endif
#ifdef CAN_CUT_AND_PASTE
    DATA(
	LYK_PASTE_URL, "PASTE_URL",
	"Goto the URL in the clipboard" ),
    DATA(
	LYK_TO_CLIPBOARD, "TO_CLIPBOARD",
	"link's URL to Clip Board" ),
#endif
#ifdef EXP_NESTED_TABLES
    DATA(
	LYK_NESTED_TABLES, "NESTED_TABLES",
	"toggle nested-table parsing on/off" ),
#endif
    DATA(
	LYK_UNKNOWN, NULL,
	"" )
};
#undef DATA

PRIVATE CONST struct {
    int key;
    CONST char *name;
} named_keys[] = {
    { '\t',		"<tab>" },
    { '\r',		"<return>" },
    { CH_ESC,		"ESC" },
    { ' ',		"<space>" },
    { '<',		"<" },
    { '>',		">" },
    { CH_DEL,		"<delete>" },
    { UPARROW,		"Up Arrow" },
    { DNARROW,		"Down Arrow" },
    { RTARROW,		"Right Arrow" },
    { LTARROW,		"Left Arrow" },
    { PGDOWN,		"Page Down" },
    { PGUP,		"Page Up" },
    { HOME,		"Home" },
    { END_KEY,		"End" },
    { F1,		"F1" },
    { DO_KEY,		"Do key" },
    { FIND_KEY,		"Find key" },
    { SELECT_KEY,	"Select key" },
    { INSERT_KEY,	"Insert key" },
    { REMOVE_KEY,	"Remove key" },
    { DO_NOTHING,	"(DO_NOTHING)" },
    { BACKTAB_KEY,	"Back Tab" },
    { MOUSE_KEY,	"mouse pseudo key" },
d741 20
a760 59
struct emap {
	CONST char *name;
	CONST int   code;
	CONST char *descr;
};

PRIVATE struct emap ekmap[] = {
  {"NOP",	LYE_NOP,	"Do Nothing"},
  {"CHAR",	LYE_CHAR,	"Insert printable char"},
  {"ENTER",	LYE_ENTER,	"Input complete, return char/lynxkeycode"},
  {"TAB",	LYE_TAB,	"Input complete, return TAB"},
  {"STOP",	LYE_STOP,	"Input deactivated"},
  {"ABORT",	LYE_ABORT,	"Input cancelled"},

  {"PASS",	LYE_FORM_PASS,  "In fields: input complete, or Do Nothing"},

  {"DELN",	LYE_DELN,	"Delete next/curr char"},
  {"DELP",	LYE_DELP,	"Delete prev      char"},
  {"DELNW",	LYE_DELNW,	"Delete next word"},
  {"DELPW",	LYE_DELPW,	"Delete prev word"},

  {"ERASE",	LYE_ERASE,	"Erase the line"},

  {"BOL",	LYE_BOL,	"Go to begin of line"},
  {"EOL",	LYE_EOL,	"Go to end   of line"},
  {"FORW",	LYE_FORW,	"Cursor forwards"},
  {"FORW_RL",	LYE_FORW_RL,	"Cursor forwards or right link"},
  {"BACK",	LYE_BACK,	"Cursor backwards"},
  {"BACK_LL",	LYE_BACK_LL,	"Cursor backwards or left link"},
  {"FORWW",	LYE_FORWW,	"Word forward"},
  {"BACKW",	LYE_BACKW,	"Word back"},

  {"LOWER",	LYE_LOWER,	"Lower case the line"},
  {"UPPER",	LYE_UPPER,	"Upper case the line"},

  {"LKCMD",	LYE_LKCMD,	"Invoke command prompt"},

  {"AIX",	LYE_AIX,	"Hex 97"},

  {"DELBL",	LYE_DELBL,	"Delete back to BOL"},
  {"DELEL",	LYE_DELEL,	"Delete thru EOL"},

  {"SWMAP",	LYE_SWMAP,	"Switch input keymap"},

  {"TPOS",	LYE_TPOS,	"Transpose characters"},

  {"SETM1",	LYE_SETM1,	"Set modifier 1 flag"},
  {"SETM2",	LYE_SETM2,	"Set modifier 2 flag"},
  {"UNMOD",	LYE_UNMOD,	"Fall back to no-modifier command"},

  {"C1CHAR",	LYE_C1CHAR,	"Insert C1 char if printable"},

  {"SETMARK",	LYE_SETMARK,	"emacs-like set-mark-command"},
  {"XPMARK",	LYE_XPMARK,	"emacs-like exchange-point-and-mark"},
  {"KILLREG",	LYE_KILLREG,	"emacs-like kill-region"},
  {"YANK",	LYE_YANK,	"emacs-like yank"},
#ifdef CAN_CUT_AND_PASTE
  {"PASTE",	LYE_PASTE,	"ClipBoard to Lynx"},
#endif
d763 1
a763 4
/*
 * Build a list of Lynx's commands, for use in the tab-completion in LYgetstr.
 */
PUBLIC HTList *LYcommandList NOARGS
d765 1
a765 12
    static HTList *myList = NULL;

    if (myList == NULL) {
	unsigned j;
	myList = HTList_new();
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].doc != 0)
		HTList_addObject(myList, (char *)revmap[j].name);
	}
    }
    return myList;
}
d767 14
a780 79
/*
 * Find the given keycode.
 */
PUBLIC Kcmd * LYKeycodeToKcmd ARGS1(
	LYKeymapCode,	code)
{
    unsigned j;
    Kcmd *result = 0;

    if (code > LYK_UNKNOWN) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].code == code) {
		result = revmap + j;
		break;
	    }
	}
    }
    return result;
}

/*
 * Find the given command-name, accepting an abbreviation if it is unique.
 */
PUBLIC Kcmd * LYStringToKcmd ARGS1(
	CONST char *,	name)
{
    unsigned need = strlen(name);
    unsigned j;
    BOOL exact = FALSE;
    Kcmd *result = 0;
    Kcmd *maybe = 0;

    if (name != 0 && *name != 0) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (!strcasecomp(revmap[j].name, name)) {
		result = revmap + j;
		break;
	    } else if (!exact
		&& !strncasecomp(revmap[j].name, name, need)) {
		if (maybe == 0) {
		    maybe = revmap + j;
		} else {
		    if (revmap[j].name[need] != 0
		     && maybe->name[need] != 0) {
			maybe = 0;
			exact = TRUE;
		    }
		}
	    }
	}
    }
    return (result != 0) ? result : maybe;
}

PUBLIC char *LYKeycodeToString ARGS2 (
	int,		c,
	BOOLEAN,	upper8)
{
    static char buf[30];
    unsigned n;
    BOOLEAN named = FALSE;

    for (n = 0; n < TABLESIZE(named_keys); n++) {
	if (named_keys[n].key == c) {
	    named = TRUE;
	    strcpy(buf, named_keys[n].name);
	    break;
	}
    }

    if (!named) {
	if (c > ' '
	 && c < 0177)
	    sprintf(buf, "%c", c);
	else if (upper8
	 && c > ' '
	 && c <= 0377
	 && c <= LYlowest_eightbit[current_char_set])
	    sprintf(buf, "%c", c);
d782 4
a785 1
	    sprintf(buf, "^%c", c|0100);
d787 1
a787 1
	    sprintf(buf, "key-0x%x", c);
d789 1
a789 37
	    sprintf(buf, "0x%x", c);
    }
    return buf;
}

PUBLIC int LYStringToKeycode ARGS1 (
	char *,		src)
{
    unsigned n;
    int key = -1;
    int len = strlen(src);

    if (len == 1) {
	key = *src;
    } else if (len == 2 && *src == '^') {
	key = src[1] & 0x1f;
    } else if (len > 2 && !strncasecomp(src, "0x", 2)) {
	char *dst = 0;
	key = strtol(src, &dst, 0);
	if (isEmpty(dst))
	    key = -1;
    } else if (len > 6 && !strncasecomp(src, "key-", 4)) {
	char *dst = 0;
	key = strtol(src + 4, &dst, 0);
	if (isEmpty(dst))
	    key = -1;
    }
    if (key < 0) {
	for (n = 0; n < TABLESIZE(named_keys); n++) {
	    if (!strcasecomp(named_keys[n].name, src)) {
		key = named_keys[n].key;
		break;
	    }
	}
    }
    return key;
}
a790 42
#define PRETTY_LEN 11

PRIVATE char *pretty_html ARGS1 (int, c)
{
    char *src = LYKeycodeToString(c, TRUE);

    if (src != 0) {
	static CONST struct {
	    int	code;
	    CONST char *name;
	} table[] = {
	    { '<',	"&lt;" },
	    { '>',	"&gt;" },
	    { '"',	"&quot;" },
	    { '&',	"&amp;" }
	};

	static char buf[30];
	char *dst = buf;
	int adj = 0;
	unsigned n;
	BOOLEAN found;

	while ((c = *src++) != 0) {
	    found = FALSE;
	    for (n = 0; n < TABLESIZE(table); n++) {
		if (c == table[n].code) {
		    found = TRUE;
		    strcpy(dst, table[n].name);
		    adj += strlen(dst) - 1;
		    dst += strlen(dst);
		    break;
		}
	    }
	    if (!found) {
		*dst++ = (char) c;
	    }
	}
	adj -= (dst - buf) - PRETTY_LEN;
	while (adj-- > 0)
	    *dst++ = ' ';
	*dst = 0;
a791 3
    }

    return 0;
d798 1
a798 1
    LYKeymap_t the_key = table[i];
a800 1
    Kcmd *rmap = LYKeycodeToKcmd(the_key);
d802 8
a809 8
    if (rmap != 0
     && rmap->name != 0
     && rmap->doc != 0
     && (formatted = pretty_html(i-1)) != 0) {
	HTSprintf0(&buf, "%-*s %-13s %s\n",
		   PRETTY_LEN, formatted,
		   rmap->name,
		   rmap->doc);
d815 1
a815 6
/* if both is true, produce an additional line for the corresponding
   uppercase key if its binding is different. - kw */
PRIVATE void print_binding ARGS3(
    HTStream *,	target,
    int,	i,
    BOOLEAN, 	both)
a817 2
    LYKeymapCode lac1 = LYK_UNKNOWN; /* 0 */

d820 1
a820 9
	(lac1 = key_override[i]) != LYK_UNKNOWN) {
	if ((buf = format_binding(key_override, i)) != 0) {
	    (*target->isa->put_block)(target, buf, strlen(buf));
	    FREE(buf);
	}
    } else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
    if ((buf = format_binding(keymap, i)) != 0) {
	lac1 = keymap[i];
a822 13
    }

    if (!both)
	return;
    i -= ' ';			/* corresponding uppercase key */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    if (prev_lynx_edit_mode && !no_dired_support && key_override[i]) {
	if (key_override[i] != lac1 &&
	    (buf = format_binding(key_override, i)) != 0) {
	    (*target->isa->put_block)(target, buf, strlen(buf));
	    FREE(buf);
	}
d825 1
a825 1
    if (keymap[i] != lac1 && (buf = format_binding(keymap, i)) != 0) {
a830 73
/*
 *  Return lynxactioncode whose name is the string func.
 *  returns -1 if not found. - kw
 */
PUBLIC int lacname_to_lac ARGS1(
	CONST char *,	func)
{
    Kcmd *mp = LYStringToKcmd(func);

    return (mp != 0) ? (int) mp->code : -1;
}

/*
 *  Return editactioncode whose name is the string func.
 *  func must be present in the ekmap table.
 *  returns -1 if not found. - kw
 */
PUBLIC int lecname_to_lec ARGS1(
	CONST char *,	func)
{
    int i;
    struct emap *mp;

    if (func != NULL && *func != '\0') {
	for (i = 0, mp = ekmap; (*mp).name != NULL; mp++, i++) {
	    if (strcmp((*mp).name, func) == 0) {
		return (*mp).code;
	    }
	}
    }
    return (-1);
}

/*
 *  Return lynxkeycode represented by string src.
 *  returns -1 if not valid.
 *  This is simpler than what map_string_to_keysym() does for
 *  USE_KEYMAP, but compatible with revmap() used for processing
 *  KEYMAP options in the configuration file. - kw
 */
PUBLIC int lkcstring_to_lkc ARGS1(
	CONST char *,	src)
{
    int c = -1;

    if (strlen(src) == 1)
	c = *src;
    else if (strlen(src) == 2 && *src == '^')
	c = src[1] & 037;
    else if (strlen(src) >= 2 && isdigit(UCH(*src))) {
	if (sscanf(src, "%i", &c) != 1)
	    return (-1);
#ifdef USE_KEYMAPS
    } else {
	map_string_to_keysym(src, &c);
#ifndef USE_SLANG
	if (c >= 0) {
	    if ((c&LKC_MASK) > 255 && !(c & LKC_ISLKC))
		return (-1);	/* Don't accept untranslated curses KEY_* */
	    else
		c &= ~LKC_ISLKC;
	}
#endif
#endif
    }
    if (c == CH_ESC)
	escape_bound = 1;
    if (c < -1)
	return (-1);
    else
	return c;
}

d855 1
a855 3
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
d857 6
a862 1
    PUTS(buf);
d864 1
a864 1
    PUTS(buf);
d867 4
a870 1
	print_binding(target, i, TRUE);
d874 2
d878 4
a881 3
	if ((i >= 0200 || i <= ' ' || !isalpha(i-1)) &&
	    (LYUseMouse || (keymap[i] != LYK_CHANGE_LINK))) {
	    print_binding(target, i, FALSE);
d885 2
a886 2
    HTSprintf0(&buf,"</pre>\n</body>\n</html>\n");
    PUTS(buf);
d901 3
a903 73
 * Install func as the mapping for key.
 * If for_dired is TRUE, install it in the key_override[] table
 * for Dired mode, otherwise in the general keymap[] table.
 * If DIRED_SUPPORT or OK_OVERRIDE is not defined, don't do anything
 * when for_dired is requested.
 * returns lynxkeycode value != 0 if the mapping was made, 0 if not.
 */
PUBLIC int remap ARGS3(
	char *,		key,
	char *,		func,
	BOOLEAN,	for_dired)
{
    Kcmd *mp;
    int c;

#if !defined(DIRED_SUPPORT) || !defined(OK_OVERRIDE)
    if (for_dired)
	return 0;
#endif
    if (func == NULL)
	return 0;
    c = lkcstring_to_lkc(key);
    if (c <= -1)
	return 0;
    else if (c >= 0) {
	/* Remapping of key actions is supported only for basic
	 * lynxkeycodes, without modifiers etc.!  If we get somehow
	 * called for an invalid lynxkeycode, fail or silently ignore
	 * modifiers. - kw
	 */
	if (c & (LKC_ISLECLAC|LKC_ISLAC))
	   return 0;
	if ((c & LKC_MASK) != c)
	   c &= LKC_MASK;
    }
    if (c + 1 >= KEYMAP_SIZE)
	return 0;
    if ((mp = LYStringToKcmd(func)) != 0) {
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (for_dired)
	    key_override[c+1] = mp->code;
	else
#endif
	    keymap[c+1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code)); /* don't return 0, successful */
    }
    return 0;
}

typedef struct {
    int	code;
    LYKeymap_t map;
    LYKeymap_t save;
} ANY_KEYS;

/*
 * Save the given keys in the table, setting them to the map'd value.
 */
PRIVATE void set_any_keys ARGS2(
	ANY_KEYS *,	table,
	int,		size)
{
    int j, k;

    for (j = 0; j < size; ++j) {
	k = table[j].code + 1;
	table[j].save = keymap[k];
	keymap[k] = table[j].map;
    }
}

/*
 * Restore the given keys from the table.
d905 24
a928 10
PRIVATE void reset_any_keys ARGS2(
	ANY_KEYS *,	table,
	int,		size)
{
    int j, k;

    for (j = 0; j < size; ++j) {
	k = table[j].code + 1;
	keymap[k] = table[j].save;
    }
a930 4
static ANY_KEYS vms_keys_table[] = {
    { 26,   LYK_ABORT,   0 },	/* control-Z */
    { '$',  LYK_SHELL,   0 },
};
d934 2
a935 1
    set_any_keys(vms_keys_table, TABLESIZE(vms_keys_table));
d938 1
a938 7
static ANY_KEYS vi_keys_table[] = {
    { 'h', LYK_PREV_DOC,  0 },
    { 'j', LYK_NEXT_LINK, 0 },
    { 'k', LYK_PREV_LINK, 0 },
    { 'l', LYK_ACTIVATE,  0 },
};

d943 10
a952 2
    set_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
    did_vi_keys = TRUE;
d957 9
a965 4
    if (did_vi_keys) {
	reset_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
	did_vi_keys = FALSE;
    }
d968 1
a968 7
static ANY_KEYS emacs_keys_table[] = {
    { 2,  LYK_PREV_DOC,  0 },	/* ^B */
    { 14, LYK_NEXT_LINK, 0 },	/* ^N */
    { 16, LYK_PREV_LINK, 0 },	/* ^P */
    { 6,  LYK_ACTIVATE,  0 },	/* ^F */
};

d973 10
a982 2
    set_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
    did_emacs_keys = TRUE;
d987 9
a995 4
    if (did_emacs_keys) {
	reset_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
	did_emacs_keys = FALSE;
    }
d998 1
a998 16
/*
 * Map numbers to functions as labeled on the IBM Enhanced keypad, and save
 * their original mapping for reset_numbers_as_arrows().  - FM
 */
static ANY_KEYS number_keys_table[] = {
    { '1', LYK_END,        0 },
    { '2', LYK_NEXT_LINK,  0 },
    { '3', LYK_NEXT_PAGE,  0 },
    { '4', LYK_PREV_DOC,   0 },
    { '5', LYK_DO_NOTHING, 0 },
    { '6', LYK_ACTIVATE,   0 },
    { '7', LYK_HOME,       0 },
    { '8', LYK_PREV_LINK,  0 },
    { '9', LYK_PREV_PAGE,  0 },
};

d1003 28
a1030 1
    set_any_keys(number_keys_table, TABLESIZE(number_keys_table));
d1036 25
a1060 3
    if (did_number_keys) {
	reset_any_keys(number_keys_table, TABLESIZE(number_keys_table));
	did_number_keys = FALSE;
d1062 1
d1073 1
a1073 1
	formatted = LYKeycodeToString(i, TRUE);
a1081 121
 *  Given one or two keys as lynxkeycodes, returns an allocated string
 *  representing the key(s) suitable for statusline messages, or NULL
 *  if no valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other
 *  failure).  The caller must free the string. - kw
 */
PUBLIC char *fmt_keys ARGS2(
    int,	lkc_first,
    int,	lkc_second)
{
    char *buf = NULL;
    BOOLEAN quotes = FALSE;
    char *fmt_first;
    char *fmt_second;

    if (lkc_first < 0)
	return NULL;
    fmt_first = LYKeycodeToString(lkc_first, TRUE);
    if (fmt_first && strlen(fmt_first) == 1 && *fmt_first != '\'') {
	quotes = TRUE;
    }
    if (quotes) {
	if (lkc_second < 0) {
	    HTSprintf0(&buf, "'%s'", fmt_first);
	    return buf;
	} else {
	    HTSprintf0(&buf, "'%s", fmt_first);
	}
    } else {
	StrAllocCopy(buf, fmt_first);
    }
    if (lkc_second >= 0) {
	fmt_second = LYKeycodeToString(lkc_second, TRUE);
	if (!fmt_second) {
	    FREE(buf);
	    return NULL;
	}
	HTSprintf(&buf, "%s%s%s",
		  ((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		   (strlen(buf) > 2 && buf[strlen(buf)-1] != '>')) ? " " : "",
		  fmt_second, quotes ? "'" : "");
    }
    return buf;
}

/*
 *  This function returns the (int)ch mapped to the
 *  LYK_foo value passed to it as an argument.  It is like
 *  LYReverseKeymap, only the order of search is different;
 *  e.g., small ASCII letters will be returned in preference to
 *  capital ones.  Cf. LYKeyForEditAction, LYEditKeyForAction in
 *  LYEditmap.c which use the same order to find a best key.
 *  In addition, this function takes the dired override map into
 *  account while LYReverseKeymap doesn't.
 *  The caller must free the returned string. - kw
 */
#define FIRST_I 97
#define NEXT_I(i,imax) ((i==122) ? 32 : (i==96) ? 123 : (i==126) ? 0 :\
			(i==31) ? 256 : (i==imax) ? 127 :\
			(i==255) ? (-1) :i+1)
PRIVATE int best_reverse_keymap ARGS1(
	int,	lac)
{
    int i, c;

    for (i = FIRST_I; i >= 0; i = NEXT_I(i,KEYMAP_SIZE-2)) {
#ifdef NOT_ASCII
	if (i < 256) {
	    c = FROMASCII(i);
	} else
#endif
	    c = i;
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && lac &&
	    LKC_TO_LAC(key_override,c) == lac)
	    return c;
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	if (LKC_TO_LAC(keymap,c) == lac) {
	    return c;
	}
    }

    return(-1);
}

/*
 *  This function returns a string representing a key mapped
 *  to a LYK_foo function, or NULL if not found.  The string
 *  may represent a pair of keys.  if context_code is FOR_INPUT,
 *  an appropriate binding for use while in the (forms) line editor
 *  is sought.  - kw
 */
PUBLIC char* key_for_func_ext ARGS2(
    int,	lac,
    int,	context_code)
{
    int lkc, modkey = -1;

    if (context_code == FOR_INPUT) {
	lkc = LYEditKeyForAction(lac, &modkey);
	if (lkc >= 0) {
	    if (lkc & (LKC_MOD1|LKC_MOD2|LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1|LKC_MOD2|LKC_MOD3));
	    } else {
		return fmt_keys(lkc, -1);
	    }
	}
    }
    lkc = best_reverse_keymap(lac);
    if (lkc < 0)
	return NULL;
    if (context_code == FOR_INPUT) {
	modkey = LYKeyForEditAction(LYE_LKCMD);
	if (modkey < 0)
	    return NULL;
	return fmt_keys(modkey, lkc);
    } else {
	return fmt_keys(lkc, -1);
    }
}

/*
d1083 1
a1083 1
 *  and maps to KeyName (LYK_foo in the keymap[] array). - FM
d1087 1
a1087 1
	int,	KeyName)
d1089 3
a1091 6
    if (ch < 0 || ch >= KEYMAP_SIZE)
	return (FALSE);
    if (ch > 0
     && strchr("0123456789\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz", ch) != NULL)
d1094 1
a1094 1
    return (BOOL) (keymap[ch+1] == KeyName);
d1102 1
a1102 1
	int,	KeyName)
d1107 1
a1107 1
	if (keymap[i] == KeyName) {
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d20 1
a20 1
int current_layout = 0;  /* Index into LYKbLayouts[]   */
d22 1
a22 1
LYKbLayout_t * LYKbLayouts[]={
d28 1
a28 1
char * LYKbLayoutNames[]={
d623 1
a623 1
static Kcmd revmap[] = {
d976 1
a976 1
static const struct {
d978 1
a978 1
    const char *name;
d1007 3
a1009 3
	const char *name;
	const int   code;
	const char *descr;
d1012 1
a1012 1
static struct emap ekmap[] = {
d1070 1
a1070 1
HTList *LYcommandList (void)
d1078 2
a1079 5
	    if (revmap[j].doc != 0) {
		char *data = NULL;
		StrAllocCopy(data, revmap[j].name);
		HTList_addObject(myList, data);
	    }
d1088 2
a1089 2
Kcmd * LYKeycodeToKcmd (
	LYKeymapCode	code)
d1108 2
a1109 2
Kcmd * LYStringToKcmd (
	const char *	name)
d1139 3
a1141 3
char *LYKeycodeToString (
	int		c,
	BOOLEAN	upper8)
d1174 2
a1175 2
int LYStringToKeycode (
	char *		src)
d1209 1
a1209 1
static char *pretty_html (int c)
d1214 1
a1214 1
	static const struct {
d1216 1
a1216 1
	    const char *name;
d1255 3
a1257 3
static char * format_binding (
	LYKeymap_t *	table,
	int		i)
d1279 4
a1282 4
static void print_binding (
    HTStream *	target,
    int	i,
    BOOLEAN 	both)
d1325 2
a1326 2
int lacname_to_lac (
	const char *	func)
d1338 2
a1339 2
int lecname_to_lec (
	const char *	func)
d1361 2
a1362 2
int lkcstring_to_lkc (
	const char *	src)
d1394 5
a1398 5
static int LYLoadKeymap (
	const char * 		arg GCC_UNUSED,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d1451 1
a1451 1
GLOBALDEF HTProtocol LYLynxKeymap = {"LYNXKEYMAP", LYLoadKeymap, 0};
d1462 4
a1465 4
int remap (
	char *		key,
	char *		func,
	BOOLEAN	for_dired)
d1513 3
a1515 3
static void set_any_keys (
	ANY_KEYS *	table,
	int		size)
d1529 3
a1531 3
static void reset_any_keys (
	ANY_KEYS *	table,
	int		size)
d1546 1
a1546 1
void set_vms_keys (void)
d1560 1
a1560 1
void set_vi_keys (void)
d1566 1
a1566 1
void reset_vi_keys (void)
d1583 1
a1583 1
void set_emacs_keys (void)
d1589 1
a1589 1
void reset_emacs_keys (void)
d1615 1
a1615 1
void set_numbers_as_arrows (void)
d1621 1
a1621 1
void reset_numbers_as_arrows (void)
d1629 2
a1630 2
char *key_for_func (
	int	func)
d1651 3
a1653 3
char *fmt_keys (
    int	lkc_first,
    int	lkc_second)
d1705 2
a1706 2
static int best_reverse_keymap (
	int	lac)
d1737 3
a1739 3
char* key_for_func_ext (
    int	lac,
    int	context_code)
d1770 3
a1772 3
BOOL LYisNonAlnumKeyname (
	int	ch,
	int	KeyName)
d1789 2
a1790 2
int LYReverseKeymap (
	int	KeyName)
d1804 2
a1805 2
int LYSetKbLayout (
	char *	layout_id)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d20 1
a20 1
int current_layout = 0;		/* Index into LYKbLayouts[]   */
d22 4
a25 5
LYKbLayout_t *LYKbLayouts[] =
{
    kb_layout_rot13,
    kb_layout_jcuken,
    kb_layout_yawerty
d28 5
a32 6
char *LYKbLayoutNames[] =
{
    "ROT13'd keyboard layout",
    "JCUKEN Cyrillic, for AT 101-key kbd",
    "YAWERTY Cyrillic, for DEC LK201 kbd",
    (char *) 0
d36 3
a38 2
struct _HTStream {
    HTStreamClass *isa;
d41 1
a41 1
/* * * Tables mapping LynxKeyCodes to LynxActionCodes  * * */
d44 5
a48 5
 * Lynxkeycodes include all single-byte keys as well as codes for function keys
 * and some special purposes.  See LYStrings.h.  Extended lynxkeycode values
 * can also contain flags for modifiers and other purposes, but here only the
 * base values are mapped to lynxactioncodes.  They are called `keystrokes' in
 * lynx.cfg.
d50 2
a51 2
 * Lynxactioncodes (confusingly, constants are named LYK_foo and typed as
 * LYKeymapCode) specify key `functions', see LYKeymap.h.
a56 1
/* *INDENT-OFF* */
d1007 3
a1009 3
    const char *name;
    const int   code;
    const char *descr;
a1065 1
/* *INDENT-ON* */
d1070 1
a1070 1
HTList *LYcommandList(void)
a1075 1

a1079 1

d1091 2
a1092 1
Kcmd *LYKeycodeToKcmd(LYKeymapCode code)
d1111 2
a1112 1
Kcmd *LYStringToKcmd(const char *name)
d1126 1
a1126 1
		       && !strncasecomp(revmap[j].name, name, need)) {
d1131 1
a1131 1
			&& maybe->name[need] != 0) {
d1142 3
a1144 2
char *LYKeycodeToString(int c,
			BOOLEAN upper8)
d1160 1
a1160 1
	    && c < 0177)
d1163 3
a1165 3
		 && c > ' '
		 && c <= 0377
		 && c <= LYlowest_eightbit[current_char_set])
d1168 1
a1168 1
	    sprintf(buf, "^%c", c | 0100);
d1177 2
a1178 1
int LYStringToKeycode(char *src)
a1189 1

a1194 1

d1212 1
a1212 1
static char *pretty_html(int c)
a1216 1
	/* *INDENT-OFF* */
a1225 1
	/* *INDENT-ON* */
d1258 3
a1260 1
static char *format_binding(LYKeymap_t * table, int i)
d1268 3
a1270 3
	&& rmap->name != 0
	&& rmap->doc != 0
	&& (formatted = pretty_html(i - 1)) != 0) {
d1282 4
a1285 2
static void print_binding(HTStream *target, int i,
			  BOOLEAN both)
d1288 1
a1288 1
    LYKeymapCode lac1 = LYK_UNKNOWN;	/* 0 */
d1294 1
a1294 1
	    (*target->isa->put_block) (target, buf, strlen(buf));
d1301 1
a1301 1
	(*target->isa->put_block) (target, buf, strlen(buf));
d1313 1
a1313 1
	    (*target->isa->put_block) (target, buf, strlen(buf));
d1319 1
a1319 1
	(*target->isa->put_block) (target, buf, strlen(buf));
d1325 2
a1326 2
 * Return lynxactioncode whose name is the string func.  returns -1 if not
 * found.  - kw
d1328 2
a1329 1
int lacname_to_lac(const char *func)
d1337 3
a1339 2
 * Return editactioncode whose name is the string func.  func must be present
 * in the ekmap table.  returns -1 if not found.  - kw
d1341 2
a1342 1
int lecname_to_lec(const char *func)
d1358 5
a1362 5
 * Return lynxkeycode represented by string src.  returns -1 if not valid.
 *
 * This is simpler than what map_string_to_keysym() does for USE_KEYMAP, but
 * compatible with revmap() used for processing KEYMAP options in the
 * configuration file.  - kw
d1364 2
a1365 1
int lkcstring_to_lkc(const char *src)
d1381 1
a1381 1
	    if ((c & LKC_MASK) > 255 && !(c & LKC_ISLKC))
d1397 5
a1401 4
static int LYLoadKeymap(const char *arg GCC_UNUSED,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
d1409 1
a1409 1
     * Set up the stream.  - FM
d1414 1
a1414 1
		   HTAtom_name(format_in), HTAtom_name(format_out));
d1417 1
a1417 1
	return (HT_NOT_LOADED);
d1424 1
a1424 1
	       CURRENT_KEYMAP_TITLE);
d1429 1
a1429 1
    for (i = 'a' + 1; i <= 'z' + 1; i++) {
d1434 1
a1434 1
	 * Don't show CHANGE_LINK if mouse not enabled.
d1436 1
a1436 1
	if ((i >= 0200 || i <= ' ' || !isalpha(i - 1)) &&
d1442 1
a1442 1
    HTSprintf0(&buf, "</pre>\n</body>\n</html>\n");
d1445 1
a1445 1
    (*target->isa->_free) (target);
d1447 1
a1447 1
    return (HT_LOADED);
d1452 1
a1452 1
GLOBALDEF(HTProtocol, LYLynxKeymap, _LYKEYMAP_C_GLOBALDEF_1_INIT);
d1454 1
a1454 2
GLOBALDEF HTProtocol LYLynxKeymap =
{"LYNXKEYMAP", LYLoadKeymap, 0};
d1465 4
a1468 3
int remap(char *key,
	  char *func,
	  BOOLEAN for_dired)
d1488 2
a1489 2
	if (c & (LKC_ISLECLAC | LKC_ISLAC))
	    return 0;
d1491 1
a1491 1
	    c &= LKC_MASK;
d1498 1
a1498 1
	    key_override[c + 1] = mp->code;
d1501 2
a1502 2
	    keymap[c + 1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code));	/* don't return 0, successful */
d1508 1
a1508 1
    int code;
d1516 3
a1518 1
static void set_any_keys(ANY_KEYS * table, int size)
d1532 3
a1534 1
static void reset_any_keys(ANY_KEYS * table, int size)
d1544 3
a1546 4
static ANY_KEYS vms_keys_table[] =
{
    {26, LYK_ABORT, 0},		/* control-Z */
    {'$', LYK_SHELL, 0},
d1549 1
a1549 1
void set_vms_keys(void)
d1554 5
a1558 6
static ANY_KEYS vi_keys_table[] =
{
    {'h', LYK_PREV_DOC, 0},
    {'j', LYK_NEXT_LINK, 0},
    {'k', LYK_PREV_LINK, 0},
    {'l', LYK_ACTIVATE, 0},
d1563 1
a1563 1
void set_vi_keys(void)
d1569 1
a1569 1
void reset_vi_keys(void)
d1577 5
a1581 6
static ANY_KEYS emacs_keys_table[] =
{
    {2, LYK_PREV_DOC, 0},	/* ^B */
    {14, LYK_NEXT_LINK, 0},	/* ^N */
    {16, LYK_PREV_LINK, 0},	/* ^P */
    {6, LYK_ACTIVATE, 0},	/* ^F */
d1586 1
a1586 1
void set_emacs_keys(void)
d1592 1
a1592 1
void reset_emacs_keys(void)
d1604 10
a1613 11
static ANY_KEYS number_keys_table[] =
{
    {'1', LYK_END, 0},
    {'2', LYK_NEXT_LINK, 0},
    {'3', LYK_NEXT_PAGE, 0},
    {'4', LYK_PREV_DOC, 0},
    {'5', LYK_DO_NOTHING, 0},
    {'6', LYK_ACTIVATE, 0},
    {'7', LYK_HOME, 0},
    {'8', LYK_PREV_LINK, 0},
    {'9', LYK_PREV_PAGE, 0},
d1618 1
a1618 1
void set_numbers_as_arrows(void)
d1624 1
a1624 1
void reset_numbers_as_arrows(void)
d1632 2
a1633 1
char *key_for_func(int func)
d1649 4
a1652 4
 * Given one or two keys as lynxkeycodes, returns an allocated string
 * representing the key(s) suitable for statusline messages, or NULL if no
 * valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other failure). 
 * The caller must free the string.  - kw
d1654 3
a1656 2
char *fmt_keys(int lkc_first,
	       int lkc_second)
d1686 2
a1687 4
		  (((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		    (strlen(buf) > 2 && buf[strlen(buf) - 1] != '>'))
		   ? " "
		   : ""),
d1694 9
a1702 7
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  It is like LYReverseKeymap, only the order of search is
 * different; e.g., small ASCII letters will be returned in preference to
 * capital ones.  Cf.  LYKeyForEditAction, LYEditKeyForAction in LYEditmap.c
 * which use the same order to find a best key.  In addition, this function
 * takes the dired override map into account while LYReverseKeymap doesn't. 
 * The caller must free the returned string.  - kw
d1708 2
a1709 1
static int best_reverse_keymap(int lac)
d1713 1
a1713 1
    for (i = FIRST_I; i >= 0; i = NEXT_I(i, KEYMAP_SIZE - 2)) {
d1722 1
a1722 1
	    LKC_TO_LAC(key_override, c) == lac)
d1725 1
a1725 1
	if (LKC_TO_LAC(keymap, c) == lac) {
d1730 1
a1730 1
    return (-1);
d1734 5
a1738 4
 * This function returns a string representing a key mapped to a LYK_foo
 * function, or NULL if not found.  The string may represent a pair of keys. 
 * if context_code is FOR_INPUT, an appropriate binding for use while in the
 * (forms) line editor is sought.  - kw
d1740 3
a1742 2
char *key_for_func_ext(int lac,
		       int context_code)
d1749 2
a1750 2
	    if (lkc & (LKC_MOD1 | LKC_MOD2 | LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1 | LKC_MOD2 | LKC_MOD3));
d1770 2
a1771 2
 * This function returns TRUE if the ch is non-alphanumeric and maps to KeyName
 * (LYK_foo in the keymap[] array).  - FM
d1773 3
a1775 2
BOOL LYisNonAlnumKeyname(int ch,
			 int KeyName)
d1780 1
a1780 1
	&& strchr("0123456789\
d1785 1
a1785 1
    return (BOOL) (keymap[ch + 1] == KeyName);
d1789 2
a1790 2
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  - FM
d1792 2
a1793 1
int LYReverseKeymap(int KeyName)
d1799 1
a1799 1
	    return (i - 1);
d1803 1
a1803 1
    return (-1);
d1807 2
a1808 1
int LYSetKbLayout(char *layout_id)
@


1.1.3.4
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@a18 2
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

d1295 1
a1295 1
	    PUTS(buf);
d1302 1
a1302 1
	PUTS(buf);
d1314 1
a1314 1
	    PUTS(buf);
d1320 1
a1320 1
	PUTS(buf);
d1416 2
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d1125 1
a1125 1
    if (non_empty(name)) {
d1347 1
a1347 1
    if (non_empty(func)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d3 1
a4 2
#include <LYKeymap.h>
#include <LYCharSets.h>		/* for LYlowest_eightbit - kw */
a7 1
#include <LYStrings.h>		/* for USE_KEYMAP stuff - kw */
d20 1
a20 1
PUBLIC LYKbLayout_t * LYKbLayouts[]={
d32 4
a35 1
#endif /* EXP_KEYBOARD_LAYOUT */
a41 13
/* * *  Tables mapping LynxKeyCodes to LynxActionCodes  * * */

/*
 *  Lynxkeycodes include all single-byte keys as well as codes
 *  for function keys and some special purposes.  See LYStrings.h.
 *  Extended lynxkeycode values can also contain flags for modifiers
 *  and other purposes, but here only the base values are mapped to
 *  lynxactioncodes.  They are called `keystrokes' in lynx.cfg.
 *
 *  Lynxactioncodes (confusingly, constants are named LYK_foo and
 *  typed as LYKeymapCode) specify key `functions', see LYKeymap.h.
 */

a58 5
#ifdef KANJI_CODE_OVERRIDE
LYK_CHG_KCODE,    LYK_ACTIVATE,     LYK_DOWN_TWO,      0,
/* ^L */            /* cr */        /* ^N */       /* ^O */

#else
a60 1
#endif
a61 5
#ifdef SH_EX	/* 1998/10/02 (Fri) 08:48:44 */
LYK_UP_TWO,       LYK_CHG_CENTER,   LYK_RELOAD,    LYK_TO_CLIPBOARD,
/* ^P */            /* XON */       /* ^R */       /* ^S */

#else
a63 1
#endif
d77 1
a77 1
LYK_LAST_LINK,          0,              0,          LYK_HISTORICAL,
d83 2
a84 1
LYK_EXTERN_PAGE,  LYK_PREV_PAGE, LYK_EXTERN_LINK,   LYK_WHEREIS,
d86 4
d97 1
a97 1
LYK_8,               LYK_9,         LYK_COMMAND,    LYK_TRACE_LOG,
a102 1
#ifndef SUPPORT_CHDIR
d105 6
d112 3
a114 3
LYK_RAW_TOGGLE,      LYK_ADDRLIST, LYK_PREV_PAGE,   LYK_CHDIR,
/* @@ */              /* A */         /* B */        /* C */
#endif
d116 2
a117 2
LYK_DOWNLOAD,        LYK_ELGOTO,  LYK_DIRED_MENU,   LYK_ECGOTO,
/* D */              /* E */         /* F */        /* G */
d122 1
a122 1
LYK_LIST,          LYK_MAIN_MENU,    LYK_PREV,      LYK_OPTIONS,
d134 1
a134 1
LYK_SOURCE,          LYK_HEAD,    LYK_FIRST_LINK,   LYK_CLEAR_AUTH,
d140 12
a151 2
LYK_DOWNLOAD,        LYK_EDIT,    LYK_DIRED_MENU,   LYK_GOTO,
/* d */              /* e */         /* f */        /* g */
d165 1
a165 1
LYK_NOCACHE,            0,          LYK_INTERRUPT, LYK_SHIFT_LEFT,
d168 8
a175 1
LYK_LINEWRAP_TOGGLE, LYK_SHIFT_RIGHT, LYK_NESTED_TABLES, LYK_HISTORY,
d178 1
d223 1
a223 1
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__))
d225 1
a225 1
LYK_DWIMHELP,          0,              0,             0,
d229 1
a229 1
LYK_DWIMHELP,     LYK_ACTIVATE,     LYK_HOME,       LYK_END,
d232 1
a232 1
#endif /* _WINDOWS || __DJGPP__ || __CYGWIN__ */
d239 4
d244 1
d294 1
a294 1
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(USE_SLANG) /* PDCurses */
d314 1
a314 1
#endif /* (_WINDOWS || __DJGPP__ || __CYGWIN__) && !USE_SLANG */
d427 1
a427 1
#ifndef SUPPORT_CHDIR
a429 4
#else
   0,                  0,              0,         LYK_CHDIR,
/* @@ */             /* A */         /* B */        /* C */
#endif
d632 5
a636 1
#define DATA(code, name, doc) { code, name, doc }
d638 81
a718 268
PRIVATE Kcmd revmap[] = {
    DATA(
	LYK_UNKNOWN, "UNMAPPED",
	NULL ),
    DATA(
	LYK_COMMAND, "COMMAND",
	"prompt for, execute a command" ),
    DATA(
	LYK_1, "1",
	NULL ),
    DATA(
	LYK_2, "2",
	NULL ),
    DATA(
	LYK_3, "3",
	NULL ),
    DATA(
	LYK_4, "4",
	NULL ),
    DATA(
	LYK_5, "5",
	NULL ),
    DATA(
	LYK_6, "6",
	NULL ),
    DATA(
	LYK_7, "7",
	NULL ),
    DATA(
	LYK_8, "8",
	NULL ),
    DATA(
	LYK_9, "9",
	NULL ),
    DATA(
	LYK_SOURCE, "SOURCE",
	"toggle source/presentation for current document" ),
    DATA(
	LYK_RELOAD, "RELOAD",
	"reload the current document" ),
    DATA(
	LYK_QUIT, "QUIT",
	"quit the browser" ),
    DATA(
	LYK_ABORT, "ABORT",
	"quit the browser unconditionally" ),
    DATA(
	LYK_NEXT_PAGE, "NEXT_PAGE",
	"view the next page of the document" ),
    DATA(
	LYK_PREV_PAGE, "PREV_PAGE",
	"view the previous page of the document" ),
    DATA(
	LYK_UP_TWO, "UP_TWO",
	"go back two lines in the document" ),
    DATA(
	LYK_DOWN_TWO, "DOWN_TWO",
	"go forward two lines in the document" ),
    DATA(
	LYK_UP_HALF, "UP_HALF",
	"go back half a page in the document" ),
    DATA(
	LYK_DOWN_HALF, "DOWN_HALF",
	"go forward half a page in the document" ),
    DATA(
	LYK_REFRESH, "REFRESH",
	"refresh the screen to clear garbled text" ),
    DATA(
	LYK_HOME, "HOME",
	"go to the beginning of the current document" ),
    DATA(
	LYK_END, "END",
	"go to the end of the current document" ),
    DATA(
	LYK_FIRST_LINK, "FIRST_LINK",
	"make the first link on the line current" ),
    DATA(
	LYK_LAST_LINK, "LAST_LINK",
	"make the last link on the line current" ),
    DATA(
	LYK_PREV_LINK, "PREV_LINK",
	"make the previous link current" ),
    DATA(
	LYK_NEXT_LINK, "NEXT_LINK",
	"make the next link current" ),
    DATA(
	LYK_LPOS_PREV_LINK, "LPOS_PREV_LINK",
	"make previous link current, same column for input" ),
    DATA(
	LYK_LPOS_NEXT_LINK, "LPOS_NEXT_LINK",
	"make next link current, same column for input" ),
    DATA(
	LYK_FASTBACKW_LINK, "FASTBACKW_LINK",
	"previous link or text area, only stops on links" ),
    DATA(
	LYK_FASTFORW_LINK, "FASTFORW_LINK",
	"next link or text area, only stops on links" ),
    DATA(
	LYK_UP_LINK, "UP_LINK",
	"move up the page to a previous link" ),
    DATA(
	LYK_DOWN_LINK, "DOWN_LINK",
	"move down the page to another link" ),
    DATA(
	LYK_RIGHT_LINK, "RIGHT_LINK",
	"move right to another link" ),
    DATA(
	LYK_LEFT_LINK, "LEFT_LINK",
	"move left to a previous link" ),
    DATA(
	LYK_HISTORY, "HISTORY",
	"display stack of currently-suspended documents" ),
    DATA(
	LYK_PREV_DOC, "PREV_DOC",
	"go back to the previous document" ),
    DATA(
	LYK_NEXT_DOC, "NEXT_DOC",
	"undo going back to the previous document" ),
    DATA(
	LYK_ACTIVATE, "ACTIVATE",
	"go to the document given by the current link" ),
    DATA(
	LYK_SUBMIT, "MOUSE_SUBMIT",
	"DO NOT MAP:  follow current link, submit" ),
    DATA(
	LYK_GOTO, "GOTO",
	"go to a document given as a URL" ),
    DATA(
	LYK_ECGOTO, "ECGOTO",
	"edit the current document's URL and go to it" ),
    DATA(
	LYK_HELP, "HELP",
	"display help on using the browser" ),
    DATA(
	LYK_DWIMHELP, "DWIMHELP",
	"display help page that may depend on context" ),
    DATA(
	LYK_INDEX, "INDEX",
	"display an index of potentially useful documents" ),
    DATA(
	LYK_NOCACHE, "NOCACHE",
	"force submission of form or link with no-cache" ),
    DATA(
	LYK_INTERRUPT, "INTERRUPT",
	"interrupt network connection or transmission" ),
    DATA(
	LYK_MAIN_MENU, "MAIN_MENU",
	"return to the first screen (home page)" ),
    DATA(
	LYK_OPTIONS, "OPTIONS",
	"display and change option settings" ),
    DATA(
	LYK_INDEX_SEARCH, "INDEX_SEARCH",
	"allow searching of an index" ),
    DATA(
	LYK_WHEREIS, "WHEREIS",
	"search within the current document" ),
    DATA(
	LYK_PREV, "PREV",
	"search for the previous occurence" ),
    DATA(
	LYK_NEXT, "NEXT",
	"search for the next occurence" ),
    DATA(
	LYK_COMMENT, "COMMENT",
	"send a comment to the author of the current document" ),
    DATA(
	LYK_EDIT, "EDIT",
	"edit the current document or a form's textarea" ),
    DATA(
	LYK_INFO, "INFO",
	"display information on the current document and link" ),
    DATA(
	LYK_PRINT, "PRINT",
	"display choices for printing the current document" ),
    DATA(
	LYK_ADD_BOOKMARK, "ADD_BOOKMARK",
	"add to your personal bookmark list" ),
    DATA(
	LYK_DEL_BOOKMARK, "DEL_BOOKMARK",
	"delete from your personal bookmark list" ),
    DATA(
	LYK_VIEW_BOOKMARK, "VIEW_BOOKMARK",
	"view your personal bookmark list" ),
    DATA(
	LYK_VLINKS, "VLINKS",
	"list links visited during the current Lynx session" ),
    DATA(
	LYK_SHELL, "SHELL",
	"escape from the browser to the system" ),
    DATA(
	LYK_DOWNLOAD, "DOWNLOAD",
	"download the current link to your computer" ),
    DATA(
	LYK_TRACE_TOGGLE, "TRACE_TOGGLE",
	"toggle tracing of browser operations" ),
    DATA(
	LYK_TRACE_LOG, "TRACE_LOG",
	"view trace log if started in the current session" ),
    DATA(
	LYK_IMAGE_TOGGLE, "IMAGE_TOGGLE",
	"toggle handling of all images as links" ),
    DATA(
	LYK_INLINE_TOGGLE, "INLINE_TOGGLE",
	"toggle pseudo-ALTs for inlines with no ALT string" ),
    DATA(
	LYK_HEAD, "HEAD",
	"send a HEAD request for the current document or link" ),
    DATA(
	LYK_DO_NOTHING, "DO_NOTHING",
	NULL ),
    DATA(
	LYK_TOGGLE_HELP, "TOGGLE_HELP",
	"show other commands in the novice help menu" ),
    DATA(
	LYK_JUMP, "JUMP",
	"go directly to a target document or action" ),
    DATA(
	LYK_KEYMAP, "KEYMAP",
	"display the current key map" ),
    DATA(
	LYK_LIST, "LIST",
	"list the references (links) in the current document" ),
    DATA(
	LYK_TOOLBAR, "TOOLBAR",
	"go to Toolbar or Banner in the current document" ),
    DATA(
	LYK_HISTORICAL, "HISTORICAL",
	"toggle historical vs.  valid/minimal comment parsing" ),
    DATA(
	LYK_MINIMAL, "MINIMAL",
	"toggle minimal vs.  valid comment parsing" ),
    DATA(
	LYK_SOFT_DQUOTES, "SOFT_DQUOTES",
	"toggle valid vs.  soft double-quote parsing" ),
    DATA(
	LYK_RAW_TOGGLE, "RAW_TOGGLE",
	"toggle raw 8-bit translations or CJK mode ON or OFF" ),
    DATA(
	LYK_COOKIE_JAR, "COOKIE_JAR",
	"examine the Cookie Jar" ),
    DATA(
	LYK_F_LINK_NUM, "F_LINK_NUM",
	"invoke the 'Follow link (or page) number:' prompt" ),
    DATA(
	LYK_CLEAR_AUTH, "CLEAR_AUTH",
	"clear all authorization info for this session" ),
    DATA(
	LYK_SWITCH_DTD, "SWITCH_DTD",
	"switch between two ways of parsing HTML" ),
    DATA(
	LYK_ELGOTO, "ELGOTO",
	"edit the current link's URL or ACTION and go to it" ),
    DATA(
	LYK_CHANGE_LINK, "CHANGE_LINK",
	"force reset of the current link on the page" ),
    DATA(
	LYK_DWIMEDIT, "DWIMEDIT",
	"use external editor for context-dependent purpose" ),
    DATA(
	LYK_EDIT_TEXTAREA, "EDITTEXTAREA",
	"use an external editor to edit a form's textarea" ),
    DATA(
	LYK_GROW_TEXTAREA, "GROWTEXTAREA",
	"add 5 new blank lines to the bottom of a textarea" ),
    DATA(
	LYK_INSERT_FILE, "INSERTFILE",
	"insert file into a textarea (just above cursorline)" ),
d720 1
a720 3
    DATA(
	LYK_ADDRLIST, "ADDRLIST",
	"like LIST command, but always shows the links' URLs" ),
d723 1
a723 6
    DATA(
	LYK_EXTERN_LINK, "EXTERN_LINK",
	"run external program with current link" ),
    DATA(
	LYK_EXTERN_PAGE, "EXTERN_PAGE",
	"run external program with current page" ),
d726 1
a726 3
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"invoke File/Directory Manager, if available" ),
d729 7
a735 21
    DATA(
	LYK_DIRED_MENU, "DIRED_MENU",
	"display a full menu of file operations" ),
    DATA(
	LYK_CREATE, "CREATE",
	"create a new file or directory" ),
    DATA(
	LYK_REMOVE, "REMOVE",
	"remove a file or directory" ),
    DATA(
	LYK_MODIFY, "MODIFY",
	"modify the name or location of a file or directory" ),
    DATA(
	LYK_TAG_LINK, "TAG_LINK",
	"tag a file or directory for later action" ),
    DATA(
	LYK_UPLOAD, "UPLOAD",
	"upload from your computer to the current directory" ),
    DATA(
	LYK_INSTALL, "INSTALL",
	"install file or tagged files into a system area" ),
a736 10
#ifdef SH_EX /* 1999/01/01 (Fri) 01:18:12 */
    DATA(
	LYK_CHG_CENTER, "CHANGE_CENTER",
	"toggle center alignment in HTML TABLE" ),
#endif
#ifdef KANJI_CODE_OVERRIDE
    DATA(
	LYK_CHG_KCODE, "CHANGE_KCODE",
	"Change Kanji code" ),
#endif
d738 1
a738 32
#ifdef SUPPORT_CHDIR
    DATA(
	LYK_CHDIR, "CHDIR",
	"change current directory" ),
#endif
#ifdef USE_CURSES_PADS
    DATA(
	LYK_SHIFT_LEFT, "SHIFT_LEFT",
	"shift the screen left" ),
    DATA(
	LYK_SHIFT_RIGHT, "SHIFT_RIGHT",
	"shift the screen right" ),
    DATA(
	LYK_LINEWRAP_TOGGLE, "LINEWRAP_TOGGLE",
	"toggle linewrap on/off" ),
#endif
#ifdef CAN_CUT_AND_PASTE
    DATA(
	LYK_PASTE_URL, "PASTE_URL",
	"Goto the URL in the clipboard" ),
    DATA(
	LYK_TO_CLIPBOARD, "TO_CLIPBOARD",
	"link's URL to Clip Board" ),
#endif
#ifdef EXP_NESTED_TABLES
    DATA(
	LYK_NESTED_TABLES, "NESTED_TABLES",
	"toggle nested-table parsing on/off" ),
#endif
    DATA(
	LYK_UNKNOWN, NULL,
	"" )
a739 1
#undef DATA
d741 20
a760 28
PRIVATE CONST struct {
    int key;
    CONST char *name;
} named_keys[] = {
    { '\t',		"<tab>" },
    { '\r',		"<return>" },
    { CH_ESC,		"ESC" },
    { ' ',		"<space>" },
    { '<',		"<" },
    { '>',		">" },
    { 0177,		"<delete>" },
    { UPARROW,		"Up Arrow" },
    { DNARROW,		"Down Arrow" },
    { RTARROW,		"Right Arrow" },
    { LTARROW,		"Left Arrow" },
    { PGDOWN,		"Page Down" },
    { PGUP,		"Page Up" },
    { HOME,		"Home" },
    { END_KEY,		"End" },
    { F1,		"F1" },
    { DO_KEY,		"Do key" },
    { FIND_KEY,		"Find key" },
    { SELECT_KEY,	"Select key" },
    { INSERT_KEY,	"Insert key" },
    { REMOVE_KEY,	"Remove key" },
    { DO_NOTHING,	"(DO_NOTHING)" },
    { BACKTAB_KEY,	"Back Tab" },
    { MOUSE_KEY,	"mouse pseudo key" },
d763 1
a763 65
struct emap {
	CONST char *name;
	CONST int   code;
	CONST char *descr;
};

PRIVATE struct emap ekmap[] = {
  {"NOP",	LYE_NOP,	"Do Nothing"},
  {"CHAR",	LYE_CHAR,	"Insert printable char"},
  {"ENTER",	LYE_ENTER,	"Input complete, return char/lynxkeycode"},
  {"TAB",	LYE_TAB,	"Input complete, return TAB"},
  {"STOP",	LYE_STOP,	"Input deactivated"},
  {"ABORT",	LYE_ABORT,	"Input cancelled"},

  {"PASS",	LYE_FORM_PASS,  "In fields: input complete, or Do Nothing"},

  {"DELN",	LYE_DELN,	"Delete next/curr char"},
  {"DELP",	LYE_DELP,	"Delete prev      char"},
  {"DELNW",	LYE_DELNW,	"Delete next word"},
  {"DELPW",	LYE_DELPW,	"Delete prev word"},

  {"ERASE",	LYE_ERASE,	"Erase the line"},

  {"BOL",	LYE_BOL,	"Go to begin of line"},
  {"EOL",	LYE_EOL,	"Go to end   of line"},
  {"FORW",	LYE_FORW,	"Cursor forwards"},
  {"FORW_RL",	LYE_FORW_RL,	"Cursor forwards or right link"},
  {"BACK",	LYE_BACK,	"Cursor backwards"},
  {"BACK_LL",	LYE_BACK_LL,	"Cursor backwards or left link"},
  {"FORWW",	LYE_FORWW,	"Word forward"},
  {"BACKW",	LYE_BACKW,	"Word back"},

  {"LOWER",	LYE_LOWER,	"Lower case the line"},
  {"UPPER",	LYE_UPPER,	"Upper case the line"},

  {"LKCMD",	LYE_LKCMD,	"Invoke command prompt"},

  {"AIX",	LYE_AIX,	"Hex 97"},

  {"DELBL",	LYE_DELBL,	"Delete back to BOL"},
  {"DELEL",	LYE_DELEL,	"Delete thru EOL"},

  {"SWMAP",	LYE_SWMAP,	"Switch input keymap"},

  {"TPOS",	LYE_TPOS,	"Transpose characters"},

  {"SETM1",	LYE_SETM1,	"Set modifier 1 flag"},
  {"SETM2",	LYE_SETM2,	"Set modifier 2 flag"},
  {"UNMOD",	LYE_UNMOD,	"Fall back to no-modifier command"},

  {"C1CHAR",	LYE_C1CHAR,	"Insert C1 char if printable"},

  {"SETMARK",	LYE_SETMARK,	"emacs-like set-mark-command"},
  {"XPMARK",	LYE_XPMARK,	"emacs-like exchange-point-and-mark"},
  {"KILLREG",	LYE_KILLREG,	"emacs-like kill-region"},
  {"YANK",	LYE_YANK,	"emacs-like yank"},
#ifdef CAN_CUT_AND_PASTE
  {"PASTE",	LYE_PASTE,	"ClipBoard to Lynx"},
#endif
};

/*
 * Build a list of Lynx's commands, for use in the tab-completion in LYgetstr.
 */
PUBLIC HTList *LYcommandList NOARGS
d765 1
a765 82
    static HTList *myList = NULL;

    if (myList == NULL) {
	unsigned j;
	myList = HTList_new();
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].doc != 0)
		HTList_addObject(myList, (char *)revmap[j].name);
	}
    }
    return myList;
}

/*
 * Find the given keycode.
 */
PUBLIC Kcmd * LYKeycodeToKcmd ARGS1(
	LYKeymapCode,	code)
{
    unsigned j;
    Kcmd *result = 0;

    if (code > LYK_UNKNOWN) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].code == code) {
		result = revmap + j;
		break;
	    }
	}
    }
    return result;
}

/*
 * Find the given command-name, accepting an abbreviation if it is unique.
 */
PUBLIC Kcmd * LYStringToKcmd ARGS1(
	CONST char *,	name)
{
    unsigned need = strlen(name);
    unsigned j;
    BOOL exact = FALSE;
    Kcmd *result = 0;
    Kcmd *maybe = 0;

    if (name != 0 && *name != 0) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (!strcasecomp(revmap[j].name, name)) {
		result = revmap + j;
		break;
	    } else if (!exact
		&& !strncasecomp(revmap[j].name, name, need)) {
		if (maybe == 0) {
		    maybe = revmap + j;
		} else {
		    if (revmap[j].name[need] != 0
		     && maybe->name[need] != 0) {
			maybe = 0;
			exact = TRUE;
		    }
		}
	    }
	}
    }
    return (result != 0) ? result : maybe;
}

PUBLIC char *LYKeycodeToString ARGS2 (
	int,		c,
	BOOLEAN,	upper8)
{
    static char buf[30];
    unsigned n;
    BOOLEAN named = FALSE;

    for (n = 0; n < TABLESIZE(named_keys); n++) {
	if (named_keys[n].key == c) {
	    named = TRUE;
	    strcpy(buf, named_keys[n].name);
	    break;
	}
    }
d767 14
a780 9
    if (!named) {
	if (c > ' '
	 && c < 0177)
	    sprintf(buf, "%c", c);
	else if (upper8
	 && c > ' '
	 && c <= 0377
	 && c <= LYlowest_eightbit[current_char_set])
	    sprintf(buf, "%c", c);
d782 4
a785 1
	    sprintf(buf, "^%c", c|0100);
d787 1
a787 1
	    sprintf(buf, "key-%#x", c);
d789 1
a789 4
	    return 0;
    }
    return buf;
}
a790 70
PUBLIC int LYStringToKeycode ARGS1 (
	char *,		src)
{
    unsigned n;
    int key = -1;
    int len = strlen(src);

    if (len == 1)
	key = *src;
    else if (len == 2 && *src == '^')
	key = src[1] & 0x1f;
    else if (len > 6 && !strncasecomp(src, "key-", 4)) {
	char *dst = 0;
	key = strtol(src + 4, &dst, 0);
	if (dst == 0 || *dst != 0)
	    key = -1;
    }
    if (key < 0) {
	for (n = 0; n < TABLESIZE(named_keys); n++) {
	    if (!strcasecomp(named_keys[n].name, src)) {
		key = named_keys[n].key;
		break;
	    }
	}
    }
    return key;
}

#define PRETTY_LEN 11

PRIVATE char *pretty_html ARGS1 (int, c)
{
    char *src = LYKeycodeToString(c, TRUE);

    if (src != 0) {
	static CONST struct {
	    int	code;
	    CONST char *name;
	} table[] = {
	    { '<',	"&lt;" },
	    { '>',	"&gt;" },
	    { '"',	"&quot;" },
	    { '&',	"&amp;" }
	};

	static char buf[30];
	char *dst = buf;
	int adj = 0;
	unsigned n;
	BOOLEAN found;

	while ((c = *src++) != 0) {
	    found = FALSE;
	    for (n = 0; n < TABLESIZE(table); n++) {
		if (c == table[n].code) {
		    found = TRUE;
		    strcpy(dst, table[n].name);
		    adj += strlen(dst) - 1;
		    dst += strlen(dst);
		    break;
		}
	    }
	    if (!found) {
		*dst++ = (char) c;
	    }
	}
	adj -= (dst - buf) - PRETTY_LEN;
	while (adj-- > 0)
	    *dst++ = ' ';
	*dst = 0;
a791 3
    }

    return 0;
d798 1
a798 1
    LYKeymap_t the_key = table[i];
a800 1
    Kcmd *rmap = LYKeycodeToKcmd(the_key);
d802 8
a809 8
    if (rmap != 0
     && rmap->name != 0
     && rmap->doc != 0
     && (formatted = pretty_html(i-1)) != 0) {
	HTSprintf0(&buf, "%-*s %-13s %s\n",
		   PRETTY_LEN, formatted,
		   rmap->name,
		   rmap->doc);
d815 1
a815 6
/* if both is true, produce an additional line for the corresponding
   uppercase key if its binding is different. - kw */
PRIVATE void print_binding ARGS3(
    HTStream *,	target,
    int,	i,
    BOOLEAN, 	both)
a817 2
    LYKeymapCode lac1 = LYK_UNKNOWN; /* 0 */

d820 1
a820 9
	(lac1 = key_override[i]) != LYK_UNKNOWN) {
	if ((buf = format_binding(key_override, i)) != 0) {
	    (*target->isa->put_block)(target, buf, strlen(buf));
	    FREE(buf);
	}
    } else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
    if ((buf = format_binding(keymap, i)) != 0) {
	lac1 = keymap[i];
a822 13
    }

    if (!both)
	return;
    i -= ' ';			/* corresponding uppercase key */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    if (prev_lynx_edit_mode && !no_dired_support && key_override[i]) {
	if (key_override[i] != lac1 &&
	    (buf = format_binding(key_override, i)) != 0) {
	    (*target->isa->put_block)(target, buf, strlen(buf));
	    FREE(buf);
	}
d825 1
a825 1
    if (keymap[i] != lac1 && (buf = format_binding(keymap, i)) != 0) {
a830 73
/*
 *  Return lynxactioncode whose name is the string func.
 *  returns -1 if not found. - kw
 */
PUBLIC int lacname_to_lac ARGS1(
	CONST char *,	func)
{
    Kcmd *mp = LYStringToKcmd(func);

    return (mp != 0) ? (int) mp->code : -1;
}

/*
 *  Return editactioncode whose name is the string func.
 *  func must be present in the ekmap table.
 *  returns -1 if not found. - kw
 */
PUBLIC int lecname_to_lec ARGS1(
	CONST char *,	func)
{
    int i;
    struct emap *mp;

    if (func != NULL && *func != '\0') {
	for (i = 0, mp = ekmap; (*mp).name != NULL; mp++, i++) {
	    if (strcmp((*mp).name, func) == 0) {
		return (*mp).code;
	    }
	}
    }
    return (-1);
}

/*
 *  Return lynxkeycode represented by string src.
 *  returns -1 if not valid.
 *  This is simpler than what map_string_to_keysym() does for
 *  USE_KEYMAP, but compatible with revmap() used for processing
 *  KEYMAP options in the configuration file. - kw
 */
PUBLIC int lkcstring_to_lkc ARGS1(
	CONST char *,	src)
{
    int c = -1;

    if (strlen(src) == 1)
	c = *src;
    else if (strlen(src) == 2 && *src == '^')
	c = src[1] & 037;
    else if (strlen(src) >= 2 && isdigit(UCH(*src))) {
	if (sscanf(src, "%i", &c) != 1)
	    return (-1);
#ifdef USE_KEYMAPS
    } else {
	map_string_to_keysym(src, &c);
#ifndef USE_SLANG
	if (c >= 0) {
	    if ((c&LKC_MASK) > 255 && !(c & LKC_ISLKC))
		return (-1);	/* Don't accept untranslated curses KEY_* */
	    else
		c &= ~LKC_ISLKC;
	}
#endif
#endif
    }
    if (c == CH_ESC)
	escape_bound = 1;
    if (c < -1)
	return (-1);
    else
	return c;
}

d855 1
a855 3
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
d857 6
a862 1
    PUTS(buf);
d864 1
a864 1
    PUTS(buf);
d867 4
a870 1
	print_binding(target, i, TRUE);
d874 2
d878 4
a881 3
	if ((i >= 0200 || i <= ' ' || !isalpha(i-1)) &&
	    (LYUseMouse || (keymap[i] != LYK_CHANGE_LINK))) {
	    print_binding(target, i, FALSE);
d885 2
a886 2
    HTSprintf0(&buf,"</pre>\n</body>\n</html>\n");
    PUTS(buf);
d901 3
a903 6
 * Install func as the mapping for key.
 * If for_dired is TRUE, install it in the key_override[] table
 * for Dired mode, otherwise in the general keymap[] table.
 * If DIRED_SUPPORT or OK_OVERRIDE is not defined, don't do anything
 * when for_dired is requested.
 * returns lynxkeycode value != 0 if the mapping was made, 0 if not.
d905 24
a928 40
PUBLIC int remap ARGS3(
	char *,		key,
	char *,		func,
	BOOLEAN,	for_dired)
{
    Kcmd *mp;
    int c;

#if !defined(DIRED_SUPPORT) || !defined(OK_OVERRIDE)
    if (for_dired)
	return 0;
#endif
    if (func == NULL)
	return 0;
    c = lkcstring_to_lkc(key);
    if (c <= -1)
	return 0;
    else if (c >= 0) {
	/* Remapping of key actions is supported only for basic
	 * lynxkeycodes, without modifiers etc.!  If we get somehow
	 * called for an invalid lynxkeycode, fail or silently ignore
	 * modifiers. - kw
	 */
	if (c & (LKC_ISLECLAC|LKC_ISLAC))
	   return 0;
	if ((c & LKC_MASK) != c)
	   c &= LKC_MASK;
    }
    if (c + 1 >= KEYMAP_SIZE)
	return 0;
    if ((mp = LYStringToKcmd(func)) != 0) {
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (for_dired)
	    key_override[c+1] = mp->code;
	else
#endif
	    keymap[c+1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code)); /* don't return 0, successful */
    }
    return 0;
d938 1
a938 1
static LYKeymap_t saved_vi_keys[4];
d968 1
a968 1
static LYKeymap_t saved_emacs_keys[4];
d998 1
a998 1
static LYKeymap_t saved_number_keys[9];
d1052 13
d1073 1
a1073 1
	formatted = LYKeycodeToString(i, TRUE);
a1081 120
 *  Given one or two keys as lynxkeycodes, returns an allocated string
 *  representing the key(s) suitable for statusline messages, or NULL
 *  if no valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other
 *  failure).  The caller must free the string. - kw
 */
PUBLIC char *fmt_keys ARGS2(
    int,	lkc_first,
    int,	lkc_second)
{
    char *buf = NULL;
    BOOLEAN quotes = FALSE;
    char *fmt_first;
    char *fmt_second;
    if (lkc_first < 0)
	return NULL;
    fmt_first = LYKeycodeToString(lkc_first, TRUE);
    if (fmt_first && strlen(fmt_first) == 1 && *fmt_first != '\'') {
	quotes = TRUE;
    }
    if (quotes) {
	if (lkc_second < 0) {
	    HTSprintf0(&buf, "'%s'", fmt_first);
	    return buf;
	} else {
	    HTSprintf0(&buf, "'%s", fmt_first);
	}
    } else {
	StrAllocCopy(buf, fmt_first);
    }
    if (lkc_second >= 0) {
	fmt_second = LYKeycodeToString(lkc_second, TRUE);
	if (!fmt_second) {
	    FREE(buf);
	    return NULL;
	}
	HTSprintf(&buf, "%s%s%s",
		  ((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		   (strlen(buf) > 2 && buf[strlen(buf)-1] != '>')) ? " " : "",
		  fmt_second, quotes ? "'" : "");
    }
    return buf;
}

/*
 *  This function returns the (int)ch mapped to the
 *  LYK_foo value passed to it as an argument.  It is like
 *  LYReverseKeymap, only the order of search is different;
 *  e.g., small ASCII letters will be returned in preference to
 *  capital ones.  Cf. LYKeyForEditAction, LYEditKeyForAction in
 *  LYEditmap.c which use the same order to find a best key.
 *  In addition, this function takes the dired override map into
 *  account while LYReverseKeymap doesn't.
 *  The caller must free the returned string. - kw
 */
#define FIRST_I 97
#define NEXT_I(i,imax) ((i==122) ? 32 : (i==96) ? 123 : (i==126) ? 0 :\
			(i==31) ? 256 : (i==imax) ? 127 :\
			(i==255) ? (-1) :i+1)
PRIVATE int best_reverse_keymap ARGS1(
	int,	lac)
{
    int i, c;

    for (i = FIRST_I; i >= 0; i = NEXT_I(i,KEYMAP_SIZE-2)) {
#ifdef NOT_ASCII
	if (i < 256) {
	    c = FROMASCII(i);
	} else
#endif
	    c = i;
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && lac &&
	    LKC_TO_LAC(key_override,c) == lac)
	    return c;
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	if (LKC_TO_LAC(keymap,c) == lac) {
	    return c;
	}
    }

    return(-1);
}

/*
 *  This function returns a string representing a key mapped
 *  to a LYK_foo function, or NULL if not found.  The string
 *  may represent a pair of keys.  if context_code is FOR_INPUT,
 *  an appropriate binding for use while in the (forms) line editor
 *  is sought.  - kw
 */
PUBLIC char* key_for_func_ext ARGS2(
    int,	lac,
    int,	context_code)
{
    int lkc, modkey = -1;

    if (context_code == FOR_INPUT) {
	lkc = LYEditKeyForAction(lac, &modkey);
	if (lkc >= 0) {
	    if (lkc & (LKC_MOD1|LKC_MOD2|LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1|LKC_MOD2|LKC_MOD3));
	    } else {
		return fmt_keys(lkc, -1);
	    }
	}
    }
    lkc = best_reverse_keymap(lac);
    if (lkc < 0)
	return NULL;
    if (context_code == FOR_INPUT) {
	modkey = LYKeyForEditAction(LYE_LKCMD);
	if (modkey < 0)
	    return NULL;
	return fmt_keys(modkey, lkc);
    } else {
	return fmt_keys(lkc, -1);
    }
}

/*
d1083 1
a1083 1
 *  and maps to KeyName (LYK_foo in the keymap[] array). - FM
d1087 1
a1087 1
	int,	KeyName)
d1089 3
a1091 6
    if (ch < 0 || ch >= KEYMAP_SIZE)
	return (FALSE);
    if (ch > 0
     && strchr("0123456789\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz", ch) != NULL)
d1094 1
a1094 1
    return (BOOL) (keymap[ch+1] == KeyName);
d1102 1
a1102 1
	int,	KeyName)
d1107 1
a1107 1
	if (keymap[i] == KeyName) {
@

