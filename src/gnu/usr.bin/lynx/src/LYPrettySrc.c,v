head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.4
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.2
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.46.03;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.20.10.26.30;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.17.01;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.36;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.37;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.34;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.27;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.22;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.25;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.16.10;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.54.47;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.20.10.10.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/* HTML source syntax highlighting
   by Vlad Harchev <hvv@@hippo.ru>
   March 1999
*/
#include <HTUtils.h>
#include <LYHash.h>
#include <LYPrettySrc.h>
#include <LYStrings.h>
#include <LYLeaks.h>

 /* This file creates too many "leak detected" entries in Lynx.leaks. */
#define NO_MEMORY_TRACKING
#include <LYLeaks.h>

#ifdef USE_PRETTYSRC
BOOL psrc_convert_string = FALSE;
BOOL psrc_view = FALSE;		/* this is read by SGML_put_character - TRUE

				   when viewing pretty source */
BOOL LYpsrc = FALSE;		/* this tells what will be shown on '\':

				   if TRUE, then pretty source, normal source view otherwise. Toggled by
				   -prettysrc commandline option.  */
BOOL sgml_in_psrc_was_initialized;
BOOL psrc_nested_call;
BOOL psrc_first_tag;
BOOL mark_htext_as_source = FALSE;

  /* tagspecs from lynx.cfg are read here. After .lss file is read (is with lss
     support), the style cache and markup are created before entering the
     mainloop. */
BOOL psrcview_no_anchor_numbering = FALSE;
static const char *HTL_tagspecs_defaults[HTL_num_lexemes] =
{
 /* these values are defaults. They are also listed in comments of distibution's
    lynx.cfg. */
#ifdef USE_COLOR_STYLE
    "span.htmlsrc_comment:!span",
    "span.htmlsrc_tag:!span",
    "span.htmlsrc_attrib:!span",
    "span.htmlsrc_attrval:!span",
    "span.htmlsrc_abracket:!span",
    "span.htmlsrc_entity:!span",
    "span.htmlsrc_href:!span",
    "span.htmlsrc_entire:!span",
    "span.htmlsrc_badseq:!span",
    "span.htmlsrc_badtag:!span",
    "span.htmlsrc_badattr:!span",
    "span.htmlsrc_sgmlspecial:!span"
#else
    "b:!b",			/* comment */
    "b:!b",			/* tag     */
    "b:!b",			/* attrib  */
    ":",			/* attrval */
    "b:!b",			/* abracket */
    "b:!b",			/* entity  */
    ":",			/* href    */
    ":",			/* entire  */
    "b:!b",			/* badseq  */
    ":",			/* badtag  */
    ":",			/* badattr */
    "b:!b"			/* sgmlspec */
#endif
};

char *HTL_tagspecs[HTL_num_lexemes];

 /* these are pointers since tagspec can be empty (the pointer will be NULL
    in that case) */
HT_tagspec *lexeme_start[HTL_num_lexemes];
HT_tagspec *lexeme_end[HTL_num_lexemes];

int tagname_transform = 2;
int attrname_transform = 2;

static int html_src_tag_index(char *tagname)
{
    HTTag *tag = SGMLFindTag(&HTML_dtd, tagname);

    return (tag && tag != &HTTag_unrecognized) ? tag - HTML_dtd.tags : -1;
}

typedef enum {
    HTSRC_CK_normal,
    HTSRC_CK_seen_excl,
    HTSRC_CK_after_tagname,
    HTSRC_CK_seen_dot
} html_src_check_state;

static void append_close_tag(char *tagname,
			     HT_tagspec ** head,
			     HT_tagspec ** tail)
{
    int idx, nattr;
    HTTag *tag;
    HT_tagspec *subj;

    idx = html_src_tag_index(tagname);
    tag = HTML_dtd.tags + idx;
    nattr = tag->number_of_attributes;

    if (idx == -1) {
	fprintf(stderr,
		"internal error: previous check didn't find bad HTML tag %s", tagname);
	exit_immediately(EXIT_FAILURE);
    }

    subj = typecalloc(HT_tagspec);
    subj->element = (HTMLElement) idx;
    subj->present = typecallocn(BOOL, nattr);
    subj->value = typecallocn(char *, nattr);

    subj->start = FALSE;
#ifdef USE_COLOR_STYLE
    subj->class_name = NULL;
#endif

    if (!*head) {
	*head = subj;
	*tail = subj;
    } else {
	(*tail)->next = subj;
	*tail = subj;
    }
}

/* this will allocate node, initialize all members, and node
   append to the list, possibly modifying head and modifying tail */
static void append_open_tag(char *tagname,
			    char *classname GCC_UNUSED,
			    HT_tagspec ** head,
			    HT_tagspec ** tail)
{
    HT_tagspec *subj;
    HTTag *tag;

#ifdef USE_COLOR_STYLE
    int hcode;
#endif

    append_close_tag(tagname, head, tail);	/* initialize common members */
    subj = *tail;
    subj->start = TRUE;

    tag = HTML_dtd.tags + subj->element;

#ifdef USE_COLOR_STYLE
    hcode = hash_code_lowercase_on_fly(tagname);
    if (non_empty(classname)) {

#  if 0
	/*
	 * we don't provide a classname as attribute of that tag, since for plain
	 * formatting tags they are not used directly for anything except style -
	 * and we provide style value directly.
	 */
	int class_attr_idx = 0;
	int n = tag->number_of_attributes;
	attr *attrs = tag->attributes;

/*.... *//* this is not implemented though it's easy */
#  endif

	hcode = hash_code_aggregate_char('.', hcode);
	hcode = hash_code_aggregate_lower_str(classname, hcode);
	StrAllocCopy(subj->class_name, classname);
    } else {
	StrAllocCopy(subj->class_name, "");
    }
    subj->style = hcode;
#endif
}

/* returns 1 if incorrect */
int html_src_parse_tagspec(char *ts,
			   HTlexeme lexeme,
			   BOOL checkonly,
			   BOOL isstart)
{
    char *p = ts;
    char *tagstart = 0;
    char *tagend = 0;
    char *classstart;
    char *classend;
    char stop = FALSE, after_excl = FALSE;
    html_src_check_state state = HTSRC_CK_normal;
    HT_tagspec *head = NULL, *tail = NULL;
    HT_tagspec **slot = (isstart ? lexeme_start : lexeme_end) + lexeme;

    while (!stop) {
	switch (state) {
	case HTSRC_CK_normal:
	case HTSRC_CK_seen_excl:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
		break;
	    case ' ':
	    case '\t':
		break;
	    case '!':
		if (state == HTSRC_CK_seen_excl)
		    return 1;	/*second '!' */
		state = HTSRC_CK_seen_excl;
		after_excl = TRUE;
		break;
	    default:
		if (isalpha(UCH(*p)) || *p == '_') {
		    tagstart = p;
		    while (*p && (isalnum(UCH(*p)) || *p == '_'))
			++p;
		    tagend = p;
		    state = HTSRC_CK_after_tagname;
		} else
		    return 1;
		continue;
	    }
	    break;
	case HTSRC_CK_after_tagname:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
		/* FALLTHRU */
	    case ' ':
		/* FALLTHRU */
	    case '\t':
		{
		    char save = *tagend;

		    *tagend = '\0';
		    classstart = 0;
		    if (checkonly) {
			int idx = html_src_tag_index(tagstart);

			*tagend = save;
			if (idx == -1)
			    return 1;
		    } else {
			if (after_excl)
			    append_close_tag(tagstart, &head, &tail);
			else
			    append_open_tag(tagstart, NULL, &head, &tail);
		    }
		    state = HTSRC_CK_normal;
		    after_excl = FALSE;
		}
		break;
	    case '.':
		if (after_excl)
		    return 1;
		state = HTSRC_CK_seen_dot;
		break;
	    default:
		return 1;
	    }
	    break;
	case HTSRC_CK_seen_dot:{
		switch (*p) {
		case ' ':
		case '\t':
		    break;
		case '\0':
		    return 1;
		default:{
			char save, save1;

			if (isalpha(UCH(*p)) || *p == '_') {
			    classstart = p;
			    while (*p && (isalnum(UCH(*p)) || *p == '_'))
				++p;
			    classend = p;
			    save = *classend;
			    *classend = '\0';
			    save1 = *tagend;
			    *tagend = '\0';
			    if (checkonly) {
				int idx = html_src_tag_index(tagstart);

				*tagend = save1;
				*classend = save;
				if (idx == -1)
				    return 1;
			    } else {
				append_open_tag(tagstart, classstart, &head, &tail);
			    }
			    state = HTSRC_CK_normal;
			    after_excl = FALSE;
			    continue;
			} else
			    return 1;
		    }
		}		/*of switch(*p) */
		break;
	    }			/* of case HTSRC_CK_seen_dot: */
	}			/* of switch */
	++p;
    }

    if (!checkonly)
	*slot = head;
    return 0;
}

/*this will clean the data associated with lexeme 'l' */
void html_src_clean_item(HTlexeme l)
{
    int i;

    if (HTL_tagspecs[l])
	FREE(HTL_tagspecs[l]);
    for (i = 0; i < 2; ++i) {
	HT_tagspec *cur;
	HT_tagspec **pts = (i ? lexeme_start : lexeme_end) + l;
	HT_tagspec *ts = *pts;

	*pts = NULL;
	while (ts) {
	    FREE(ts->present);
	    FREE(ts->value);
#ifdef USE_COLOR_STYLE
	    if (ts->start) {
		FREE(ts->class_name);
	    }
#endif
	    cur = ts;
	    ts = ts->next;
	    FREE(cur);
	}
    }
}

/*this will be registered with atexit*/
void html_src_clean_data(void)
{
    int i;

    for (i = 0; i < HTL_num_lexemes; ++i)
	html_src_clean_item((HTlexeme) i);
}

void html_src_on_lynxcfg_reload(void)
{
    html_src_clean_data();
    HTMLSRC_init_caches(TRUE);
}

void HTMLSRC_init_caches(BOOL dont_exit)
{
    int i;
    char *p;
    char buf[1000];

    for (i = 0; i < HTL_num_lexemes; ++i) {
	/*we assume that HT_tagspecs was NULLs at when program started */
	LYstrncpy(buf,
		  HTL_tagspecs[i]
		  ? HTL_tagspecs[i]
		  : HTL_tagspecs_defaults[i],
		  sizeof(buf) - 1);
	StrAllocCopy(HTL_tagspecs[i], buf);

	if ((p = strchr(buf, ':')) != 0)
	    *p = '\0';
	if (html_src_parse_tagspec(buf, (HTlexeme) i, FALSE, TRUE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 1st tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
	}
	if (html_src_parse_tagspec(p ? p + 1 : NULL, (HTlexeme) i, FALSE,
				   FALSE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 2nd tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
	}
    }
}

#endif /* ifdef USE_PRETTYSRC */
@


1.6
log
@automatic merge
@
text
@d33 1
a33 1
static char *HTL_tagspecs_defaults[HTL_num_lexemes] =
d109 1
a109 1
    subj->element = idx;
d338 1
a338 1
	html_src_clean_item(i);
d364 1
a364 1
	if (html_src_parse_tagspec(buf, i, FALSE, TRUE) && !dont_exit) {
d369 2
a370 1
	if (html_src_parse_tagspec(p ? p + 1 : NULL, i, FALSE, FALSE) && !dont_exit) {
@


1.5
log
@automatic merge of lynx-current
@
text
@d149 1
a149 1
    if (classname && *classname) {
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d17 7
a23 5
BOOL psrc_view = FALSE;/* this is read by SGML_put_character - TRUE
	when viewing pretty source */
BOOL LYpsrc = FALSE; /* this tells what will be shown on '\':
  if TRUE, then pretty source, normal source view otherwise. Toggled by
  -prettysrc commandline option.  */
d27 2
a28 1
BOOL mark_htext_as_source=FALSE;
d33 2
a34 1
static char* HTL_tagspecs_defaults[HTL_num_lexemes] = {
d36 1
a36 1
     lynx.cfg.*/
d51 12
a62 12
    "b:!b",	/*	comment	*/
    "b:!b",	/*	tag	*/
    "b:!b",	/*	attrib	*/
    ":",	/*	attrval	*/
    "b:!b",	/*	abracket*/
    "b:!b",	/*	entity	*/
    ":",	/*	href	*/
    ":",	/*	entire	*/
    "b:!b",	/*	badseq	*/
    ":",	/*	badtag	*/
    ":",	/*	badattr	*/
    "b:!b"	/*	sgmlspec*/
d66 1
a66 1
char* HTL_tagspecs[HTL_num_lexemes];
d70 2
a71 2
HT_tagspec* lexeme_start[HTL_num_lexemes];
HT_tagspec* lexeme_end[HTL_num_lexemes];
d76 3
d80 1
a80 5
static int html_src_tag_index (
	    char* tagname)
{
    HTTag* tag = SGMLFindTag(&HTML_dtd, tagname);
    return (tag && tag != &HTTag_unrecognized ) ? tag - HTML_dtd.tags : -1;
d90 3
a92 4
static void append_close_tag (
	    char*	  tagname,
	    HT_tagspec** head,
	    HT_tagspec** tail)
d95 2
a96 2
    HTTag* tag;
    HT_tagspec* subj;
d99 1
a99 1
    tag = HTML_dtd.tags+idx;
d104 1
a104 1
	"internal error: previous check didn't find bad HTML tag %s", tagname);
d112 1
d119 2
a120 1
	*head = subj; *tail = subj;
d122 2
a123 1
	(*tail)->next = subj; *tail = subj;
d129 4
a132 5
static void append_open_tag (
	    char*	  tagname,
	    char*	  classname GCC_UNUSED,
	    HT_tagspec** head,
	    HT_tagspec** tail)
d134 3
a136 2
    HT_tagspec* subj;
    HTTag* tag;
d141 1
a141 1
    append_close_tag(tagname, head, tail); /* initialize common members*/
d159 3
a161 2
	attr* attrs = tag->attributes;
	 /*.... */ /* this is not implemented though it's easy */
d168 1
a168 1
	StrAllocCopy(subj->class_name,"");
d175 4
a178 5
int html_src_parse_tagspec (
	char*		ts,
	HTlexeme	lexeme,
	BOOL		checkonly,
	BOOL		isstart)
d187 2
a188 2
    HT_tagspec* head = NULL, *tail = NULL;
    HT_tagspec** slot = ( isstart ? lexeme_start : lexeme_end ) + lexeme;
d192 45
a236 19
	    case HTSRC_CK_normal:
	    case HTSRC_CK_seen_excl:
		switch (*p) {
		    case '\0': stop = TRUE; break;
		    case ' ': case '\t': break;
		    case '!':
			if (state == HTSRC_CK_seen_excl)
			    return 1;	/*second '!'*/
			state = HTSRC_CK_seen_excl;
			after_excl = TRUE;
			break;
		    default:
			if (isalpha(UCH(*p)) || *p == '_') {
			    tagstart = p;
			    while (*p && ( isalnum(UCH(*p)) || *p == '_') )
				 ++p;
			    tagend = p;
			    state = HTSRC_CK_after_tagname;
			} else
d238 5
a242 1
			continue;
d244 3
d248 4
a251 34
	    case HTSRC_CK_after_tagname:
		switch (*p) {
		    case '\0': stop = TRUE;
			/* FALLTHRU */
		    case ' ':
			/* FALLTHRU */
		    case '\t':
			{
			    char save = *tagend;
			    *tagend = '\0';
			    classstart = 0;
			    if (checkonly) {
				int idx = html_src_tag_index(tagstart);
				*tagend = save;
				if (idx == -1)
				    return 1;
			    } else {
				if (after_excl)
				    append_close_tag(tagstart, &head, &tail);
				else
				    append_open_tag(tagstart, NULL, &head, &tail);
			    }
			    state = HTSRC_CK_normal;
			    after_excl = FALSE;
			}
			break;
		    case '.':
			if (after_excl)
			    return 1;
			state = HTSRC_CK_seen_dot;
			break;
		    default:
			return 1;
		}
d253 5
a257 1
	    case HTSRC_CK_seen_dot: {
d259 6
a264 6
		    case ' ':
		    case '\t':
			break;
		    case '\0':
			return 1;
		    default: {
d266 2
a267 1
			if ( isalpha(UCH(*p)) || *p == '_' ) {
d269 2
a270 1
			    while (*p && ( isalnum(UCH(*p)) || *p == '_') ) ++p;
d278 3
a280 1
				*tagend = save1; *classend = save;
d282 1
a282 1
				return 1;
d286 2
a287 1
			    state = HTSRC_CK_normal;after_excl = FALSE;
d292 1
a292 1
		}/*of switch(*p)*/
d294 2
a295 2
	    } /* of case HTSRC_CK_seen_dot: */
	}/* of switch */
d305 1
a305 2
void html_src_clean_item (
	HTlexeme l)
d311 4
a314 4
    for(i = 0; i < 2; ++i) {
	HT_tagspec*	cur;
	HT_tagspec**	pts = ( i ?  lexeme_start :  lexeme_end) + l;
	HT_tagspec*	ts = *pts;
d333 1
a333 1
void html_src_clean_data (void)
d336 1
d341 1
a341 1
void html_src_on_lynxcfg_reload (void)
d347 1
a347 2
void HTMLSRC_init_caches (
	BOOL	dont_exit)
d350 1
a350 1
    char* p;
d354 1
a354 1
	/*we assume that HT_tagspecs was NULLs at when program started*/
d364 3
a366 2
	if (html_src_parse_tagspec(buf, i, FALSE, TRUE) && !dont_exit ) {
	    fprintf(stderr, "internal error while caching 1st tagspec of %d lexeme", i);
d369 3
a371 2
	if (html_src_parse_tagspec( p ? p+1 : NULL , i, FALSE, FALSE) && !dont_exit) {
	    fprintf(stderr, "internal error while caching 2nd tagspec of %d lexeme", i);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d17 1
a17 1
PUBLIC BOOL psrc_view = FALSE;/* this is read by SGML_put_character - TRUE
d19 1
a19 1
PUBLIC BOOL LYpsrc = FALSE; /* this tells what will be shown on '\':
d22 4
a25 4
PUBLIC BOOL sgml_in_psrc_was_initialized;
PUBLIC BOOL psrc_nested_call;
PUBLIC BOOL psrc_first_tag;
PUBLIC BOOL mark_htext_as_source=FALSE;
d29 2
a30 2
PUBLIC BOOL psrcview_no_anchor_numbering = FALSE;
PRIVATE char* HTL_tagspecs_defaults[HTL_num_lexemes] = {
d62 1
a62 1
PUBLIC char* HTL_tagspecs[HTL_num_lexemes];
d66 2
a67 2
PUBLIC HT_tagspec* lexeme_start[HTL_num_lexemes];
PUBLIC HT_tagspec* lexeme_end[HTL_num_lexemes];
d69 2
a70 2
PUBLIC int tagname_transform = 2;
PUBLIC int attrname_transform = 2;
d73 2
a74 2
PRIVATE int html_src_tag_index ARGS1(
	    char*, tagname)
d87 4
a90 4
PRIVATE void append_close_tag ARGS3(
	    char*,	  tagname,
	    HT_tagspec**, head,
	    HT_tagspec**, tail)
d124 5
a128 5
PRIVATE void append_open_tag ARGS4(
	    char*,	  tagname,
	    char*,	  classname GCC_UNUSED,
	    HT_tagspec**, head,
	    HT_tagspec**, tail)
d169 5
a173 5
PUBLIC int html_src_parse_tagspec ARGS4(
	char*,		ts,
	HTlexeme,	lexeme,
	BOOL,		checkonly,
	BOOL,		isstart)
d288 2
a289 2
PUBLIC void html_src_clean_item ARGS1(
	HTlexeme, l)
d317 1
a317 1
PUBLIC void html_src_clean_data NOARGS
d324 1
a324 1
PUBLIC void html_src_on_lynxcfg_reload NOARGS
d330 2
a331 2
PUBLIC void HTMLSRC_init_caches ARGS1(
	BOOL,	dont_exit)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d8 2
d11 5
a15 1
#ifdef USE_PSRC
d25 1
a25 1

d29 2
a30 1
PUBLIC char* HTL_tagspecs[HTL_num_lexems] = {
d47 12
a58 12
    "b:!b",
    "b:!b",
    ":",
    "!b:b",
    "b:!b",
    "b:!b",
    ":",
    ":",
    "b:!b",
    ":",
    "!b:b",
    "b:!b"
d62 1
d66 2
a67 2
PUBLIC HT_tagspec* lexem_start[HTL_num_lexems];
PUBLIC HT_tagspec* lexem_end[HTL_num_lexems];
d80 1
a80 2
typedef enum _html_src_check_state
{
d90 1
a90 1
	    HT_tagspec**,  tail)
d103 1
a103 1
	exit_immediately(-1);
d106 1
a106 1
    subj = (HT_tagspec*) calloc( sizeof(*subj), 1);
d108 2
a109 2
    subj->present = (BOOL*)calloc( nattr*sizeof (BOOL), 1);
    subj->value = (char**)calloc( nattr*sizeof (char*), 1);
d111 3
d128 1
a128 1
	    HT_tagspec**,  tail)
d140 1
a140 1
    tag = HTML_dtd.tags+subj->element;
d162 1
a162 1
	subj->class_name = "";
a167 1

d171 1
a171 1
	HTlexem,	lexem,
d183 1
a183 1
    HT_tagspec** slot = ( isstart ? lexem_start : lexem_end ) +lexem;
d199 1
a199 1
			if (isalpha(*p) || *p == '_') {
d201 1
a201 1
			    while (*p && ( isalpha(*p) || *p == '_') )
d213 1
d215 1
d254 1
a254 1
			if ( isalpha(*p) || *p == '_' ) {
d256 1
a256 1
			    while (*p && ( isalpha(*p) || *p == '_') ) ++p;
d287 45
a331 2
/*it shouldn't fail anyway - since everything is checked before it's called. */
PUBLIC void HTMLSRC_init_caches NOARGS
d337 9
a345 5
    for (i = 0; i < HTL_num_lexems; ++i) {
	if (HTL_tagspecs[i])
	    strcpy(buf, HTL_tagspecs[i]);
	else
	    buf[0] = '\0';
d348 3
a350 3
	if (html_src_parse_tagspec(buf, i, FALSE, TRUE) ) {
	    fprintf(stderr, "internal error while caching 1st tagspec of %d lexem", i);
	    exit_immediately(-1);
d352 3
a354 3
	if (html_src_parse_tagspec( p ? p+1 : NULL , i, FALSE, FALSE) )	 {
	    fprintf(stderr, "internal error while caching 2nd tagspec of %d lexem", i);
	    exit_immediately(-1);
d359 1
a359 1
#endif /* ifdef USE_PSRC */
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a7 2
#include <LYStrings.h>
#include <LYLeaks.h>
d9 1
a9 5
 /* This file creates too many "leak detected" entries in Lynx.leaks. */
#define NO_MEMORY_TRACKING
#include <LYLeaks.h>

#ifdef USE_PRETTYSRC
d11 8
a18 11
BOOL psrc_view = FALSE;		/* this is read by SGML_put_character - TRUE

				   when viewing pretty source */
BOOL LYpsrc = FALSE;		/* this tells what will be shown on '\':

				   if TRUE, then pretty source, normal source view otherwise. Toggled by
				   -prettysrc commandline option.  */
BOOL sgml_in_psrc_was_initialized;
BOOL psrc_nested_call;
BOOL psrc_first_tag;
BOOL mark_htext_as_source = FALSE;
d23 1
a23 3
BOOL psrcview_no_anchor_numbering = FALSE;
static const char *HTL_tagspecs_defaults[HTL_num_lexemes] =
{
d25 1
a25 1
    lynx.cfg. */
d40 12
a51 12
    "b:!b",			/* comment */
    "b:!b",			/* tag     */
    "b:!b",			/* attrib  */
    ":",			/* attrval */
    "b:!b",			/* abracket */
    "b:!b",			/* entity  */
    ":",			/* href    */
    ":",			/* entire  */
    "b:!b",			/* badseq  */
    ":",			/* badtag  */
    ":",			/* badattr */
    "b:!b"			/* sgmlspec */
a54 1
char *HTL_tagspecs[HTL_num_lexemes];
d58 2
a59 2
HT_tagspec *lexeme_start[HTL_num_lexemes];
HT_tagspec *lexeme_end[HTL_num_lexemes];
d61 2
a62 2
int tagname_transform = 2;
int attrname_transform = 2;
d64 3
a66 1
static int html_src_tag_index(char *tagname)
d68 2
a69 3
    HTTag *tag = SGMLFindTag(&HTML_dtd, tagname);

    return (tag && tag != &HTTag_unrecognized) ? tag - HTML_dtd.tags : -1;
d72 2
a73 1
typedef enum {
d80 4
a83 3
static void append_close_tag(char *tagname,
			     HT_tagspec ** head,
			     HT_tagspec ** tail)
d86 2
a87 2
    HTTag *tag;
    HT_tagspec *subj;
d90 1
a90 1
    tag = HTML_dtd.tags + idx;
d95 2
a96 2
		"internal error: previous check didn't find bad HTML tag %s", tagname);
	exit_immediately(EXIT_FAILURE);
d99 4
a102 5
    subj = typecalloc(HT_tagspec);
    subj->element = (HTMLElement) idx;
    subj->present = typecallocn(BOOL, nattr);
    subj->value = typecallocn(char *, nattr);

a103 3
#ifdef USE_COLOR_STYLE
    subj->class_name = NULL;
#endif
d106 1
a106 2
	*head = subj;
	*tail = subj;
d108 1
a108 2
	(*tail)->next = subj;
	*tail = subj;
d114 5
a118 4
static void append_open_tag(char *tagname,
			    char *classname GCC_UNUSED,
			    HT_tagspec ** head,
			    HT_tagspec ** tail)
d120 2
a121 3
    HT_tagspec *subj;
    HTTag *tag;

d126 1
a126 1
    append_close_tag(tagname, head, tail);	/* initialize common members */
d130 1
a130 1
    tag = HTML_dtd.tags + subj->element;
d134 1
a134 1
    if (non_empty(classname)) {
d144 2
a145 3
	attr *attrs = tag->attributes;

/*.... *//* this is not implemented though it's easy */
d152 1
a152 1
	StrAllocCopy(subj->class_name, "");
d158 1
d160 5
a164 4
int html_src_parse_tagspec(char *ts,
			   HTlexeme lexeme,
			   BOOL checkonly,
			   BOOL isstart)
d173 2
a174 2
    HT_tagspec *head = NULL, *tail = NULL;
    HT_tagspec **slot = (isstart ? lexeme_start : lexeme_end) + lexeme;
d178 22
a199 5
	case HTSRC_CK_normal:
	case HTSRC_CK_seen_excl:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
d201 26
a226 39
	    case ' ':
	    case '\t':
		break;
	    case '!':
		if (state == HTSRC_CK_seen_excl)
		    return 1;	/*second '!' */
		state = HTSRC_CK_seen_excl;
		after_excl = TRUE;
		break;
	    default:
		if (isalpha(UCH(*p)) || *p == '_') {
		    tagstart = p;
		    while (*p && (isalnum(UCH(*p)) || *p == '_'))
			++p;
		    tagend = p;
		    state = HTSRC_CK_after_tagname;
		} else
		    return 1;
		continue;
	    }
	    break;
	case HTSRC_CK_after_tagname:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
		/* FALLTHRU */
	    case ' ':
		/* FALLTHRU */
	    case '\t':
		{
		    char save = *tagend;

		    *tagend = '\0';
		    classstart = 0;
		    if (checkonly) {
			int idx = html_src_tag_index(tagstart);

			*tagend = save;
			if (idx == -1)
d228 4
a231 8
		    } else {
			if (after_excl)
			    append_close_tag(tagstart, &head, &tail);
			else
			    append_open_tag(tagstart, NULL, &head, &tail);
		    }
		    state = HTSRC_CK_normal;
		    after_excl = FALSE;
d234 1
a234 10
	    case '.':
		if (after_excl)
		    return 1;
		state = HTSRC_CK_seen_dot;
		break;
	    default:
		return 1;
	    }
	    break;
	case HTSRC_CK_seen_dot:{
d236 6
a241 6
		case ' ':
		case '\t':
		    break;
		case '\0':
		    return 1;
		default:{
d243 1
a243 2

			if (isalpha(UCH(*p)) || *p == '_') {
d245 1
a245 2
			    while (*p && (isalnum(UCH(*p)) || *p == '_'))
				++p;
d253 1
a253 3

				*tagend = save1;
				*classend = save;
d255 1
a255 1
				    return 1;
d259 1
a259 2
			    state = HTSRC_CK_normal;
			    after_excl = FALSE;
d264 1
a264 1
		}		/*of switch(*p) */
d266 2
a267 2
	    }			/* of case HTSRC_CK_seen_dot: */
	}			/* of switch */
d276 2
a277 44
/*this will clean the data associated with lexeme 'l' */
void html_src_clean_item(HTlexeme l)
{
    int i;

    if (HTL_tagspecs[l])
	FREE(HTL_tagspecs[l]);
    for (i = 0; i < 2; ++i) {
	HT_tagspec *cur;
	HT_tagspec **pts = (i ? lexeme_start : lexeme_end) + l;
	HT_tagspec *ts = *pts;

	*pts = NULL;
	while (ts) {
	    FREE(ts->present);
	    FREE(ts->value);
#ifdef USE_COLOR_STYLE
	    if (ts->start) {
		FREE(ts->class_name);
	    }
#endif
	    cur = ts;
	    ts = ts->next;
	    FREE(cur);
	}
    }
}

/*this will be registered with atexit*/
void html_src_clean_data(void)
{
    int i;

    for (i = 0; i < HTL_num_lexemes; ++i)
	html_src_clean_item((HTlexeme) i);
}

void html_src_on_lynxcfg_reload(void)
{
    html_src_clean_data();
    HTMLSRC_init_caches(TRUE);
}

void HTMLSRC_init_caches(BOOL dont_exit)
d280 1
a280 1
    char *p;
d283 5
a287 9
    for (i = 0; i < HTL_num_lexemes; ++i) {
	/*we assume that HT_tagspecs was NULLs at when program started */
	LYstrncpy(buf,
		  HTL_tagspecs[i]
		  ? HTL_tagspecs[i]
		  : HTL_tagspecs_defaults[i],
		  sizeof(buf) - 1);
	StrAllocCopy(HTL_tagspecs[i], buf);

d290 3
a292 4
	if (html_src_parse_tagspec(buf, (HTlexeme) i, FALSE, TRUE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 1st tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
d294 3
a296 5
	if (html_src_parse_tagspec(p ? p + 1 : NULL, (HTlexeme) i, FALSE,
				   FALSE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 2nd tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
d301 1
a301 1
#endif /* ifdef USE_PRETTYSRC */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a7 2
#include <LYStrings.h>
#include <LYLeaks.h>
d9 1
a9 5
 /* This file creates too many "leak detected" entries in Lynx.leaks. */
#define NO_MEMORY_TRACKING
#include <LYLeaks.h>

#ifdef USE_PRETTYSRC
d19 1
a19 1
PUBLIC BOOL mark_htext_as_source=FALSE;
d23 1
a23 2
PUBLIC BOOL psrcview_no_anchor_numbering = FALSE;
PRIVATE char* HTL_tagspecs_defaults[HTL_num_lexemes] = {
d40 12
a51 12
    "b:!b",	/*	comment	*/
    "b:!b",	/*	tag	*/
    "b:!b",	/*	attrib	*/
    ":",	/*	attrval	*/
    "b:!b",	/*	abracket*/
    "b:!b",	/*	entity	*/
    ":",	/*	href	*/
    ":",	/*	entire	*/
    "b:!b",	/*	badseq	*/
    ":",	/*	badtag	*/
    ":",	/*	badattr	*/
    "b:!b"	/*	sgmlspec*/
a54 1
PUBLIC char* HTL_tagspecs[HTL_num_lexemes];
d58 2
a59 2
PUBLIC HT_tagspec* lexeme_start[HTL_num_lexemes];
PUBLIC HT_tagspec* lexeme_end[HTL_num_lexemes];
d72 2
a73 1
typedef enum {
d83 1
a83 1
	    HT_tagspec**, tail)
d96 1
a96 1
	exit_immediately(EXIT_FAILURE);
d99 1
a99 1
    subj = typecalloc(HT_tagspec);
d101 2
a102 2
    subj->present = typecallocn(BOOL, nattr);
    subj->value = typecallocn(char *, nattr);
a103 3
#ifdef USE_COLOR_STYLE
    subj->class_name = NULL;
#endif
d118 1
a118 1
	    HT_tagspec**, tail)
d130 1
a130 1
    tag = HTML_dtd.tags + subj->element;
d152 1
a152 1
	StrAllocCopy(subj->class_name,"");
d158 1
d162 1
a162 1
	HTlexeme,	lexeme,
d174 1
a174 1
    HT_tagspec** slot = ( isstart ? lexeme_start : lexeme_end ) + lexeme;
d190 1
a190 1
			if (isalpha(UCH(*p)) || *p == '_') {
d192 1
a192 1
			    while (*p && ( isalnum(UCH(*p)) || *p == '_') )
a203 1
			/* FALLTHRU */
a204 1
			/* FALLTHRU */
d243 1
a243 1
			if ( isalpha(UCH(*p)) || *p == '_' ) {
d245 1
a245 1
			    while (*p && ( isalnum(UCH(*p)) || *p == '_') ) ++p;
d276 2
a277 45
/*this will clean the data associated with lexeme 'l' */
PUBLIC void html_src_clean_item ARGS1(
	HTlexeme, l)
{
    int i;

    if (HTL_tagspecs[l])
	FREE(HTL_tagspecs[l]);
    for(i = 0; i < 2; ++i) {
	HT_tagspec*	cur;
	HT_tagspec**	pts = ( i ?  lexeme_start :  lexeme_end) + l;
	HT_tagspec*	ts = *pts;

	*pts = NULL;
	while (ts) {
	    FREE(ts->present);
	    FREE(ts->value);
#ifdef USE_COLOR_STYLE
	    if (ts->start) {
		FREE(ts->class_name);
	    }
#endif
	    cur = ts;
	    ts = ts->next;
	    FREE(cur);
	}
    }
}

/*this will be registered with atexit*/
PUBLIC void html_src_clean_data NOARGS
{
    int i;
    for (i = 0; i < HTL_num_lexemes; ++i)
	html_src_clean_item(i);
}

PUBLIC void html_src_on_lynxcfg_reload NOARGS
{
    html_src_clean_data();
    HTMLSRC_init_caches(TRUE);
}

PUBLIC void HTMLSRC_init_caches ARGS1(
	BOOL,	dont_exit)
d283 5
a287 9
    for (i = 0; i < HTL_num_lexemes; ++i) {
	/*we assume that HT_tagspecs was NULLs at when program started*/
	LYstrncpy(buf,
		  HTL_tagspecs[i]
		  ? HTL_tagspecs[i]
		  : HTL_tagspecs_defaults[i],
		  sizeof(buf) - 1);
	StrAllocCopy(HTL_tagspecs[i], buf);

d290 3
a292 3
	if (html_src_parse_tagspec(buf, i, FALSE, TRUE) && !dont_exit ) {
	    fprintf(stderr, "internal error while caching 1st tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
d294 3
a296 3
	if (html_src_parse_tagspec( p ? p+1 : NULL , i, FALSE, FALSE) && !dont_exit) {
	    fprintf(stderr, "internal error while caching 2nd tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
d301 1
a301 1
#endif /* ifdef USE_PRETTYSRC */
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d17 1
a17 1
BOOL psrc_view = FALSE;/* this is read by SGML_put_character - TRUE
d19 1
a19 1
BOOL LYpsrc = FALSE; /* this tells what will be shown on '\':
d22 4
a25 4
BOOL sgml_in_psrc_was_initialized;
BOOL psrc_nested_call;
BOOL psrc_first_tag;
BOOL mark_htext_as_source=FALSE;
d29 2
a30 2
BOOL psrcview_no_anchor_numbering = FALSE;
static char* HTL_tagspecs_defaults[HTL_num_lexemes] = {
d62 1
a62 1
char* HTL_tagspecs[HTL_num_lexemes];
d66 2
a67 2
HT_tagspec* lexeme_start[HTL_num_lexemes];
HT_tagspec* lexeme_end[HTL_num_lexemes];
d69 2
a70 2
int tagname_transform = 2;
int attrname_transform = 2;
d73 2
a74 2
static int html_src_tag_index (
	    char* tagname)
d87 4
a90 4
static void append_close_tag (
	    char*	  tagname,
	    HT_tagspec** head,
	    HT_tagspec** tail)
d124 5
a128 5
static void append_open_tag (
	    char*	  tagname,
	    char*	  classname GCC_UNUSED,
	    HT_tagspec** head,
	    HT_tagspec** tail)
d169 5
a173 5
int html_src_parse_tagspec (
	char*		ts,
	HTlexeme	lexeme,
	BOOL		checkonly,
	BOOL		isstart)
d288 2
a289 2
void html_src_clean_item (
	HTlexeme l)
d317 1
a317 1
void html_src_clean_data (void)
d324 1
a324 1
void html_src_on_lynxcfg_reload (void)
d330 2
a331 2
void HTMLSRC_init_caches (
	BOOL	dont_exit)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d17 5
a21 7
BOOL psrc_view = FALSE;		/* this is read by SGML_put_character - TRUE

				   when viewing pretty source */
BOOL LYpsrc = FALSE;		/* this tells what will be shown on '\':

				   if TRUE, then pretty source, normal source view otherwise. Toggled by
				   -prettysrc commandline option.  */
d25 1
a25 2
BOOL mark_htext_as_source = FALSE;

d30 1
a30 2
static char *HTL_tagspecs_defaults[HTL_num_lexemes] =
{
d32 1
a32 1
    lynx.cfg. */
d47 12
a58 12
    "b:!b",			/* comment */
    "b:!b",			/* tag     */
    "b:!b",			/* attrib  */
    ":",			/* attrval */
    "b:!b",			/* abracket */
    "b:!b",			/* entity  */
    ":",			/* href    */
    ":",			/* entire  */
    "b:!b",			/* badseq  */
    ":",			/* badtag  */
    ":",			/* badattr */
    "b:!b"			/* sgmlspec */
d62 1
a62 1
char *HTL_tagspecs[HTL_num_lexemes];
d66 2
a67 2
HT_tagspec *lexeme_start[HTL_num_lexemes];
HT_tagspec *lexeme_end[HTL_num_lexemes];
d72 3
a74 1
static int html_src_tag_index(char *tagname)
d76 2
a77 3
    HTTag *tag = SGMLFindTag(&HTML_dtd, tagname);

    return (tag && tag != &HTTag_unrecognized) ? tag - HTML_dtd.tags : -1;
d87 4
a90 3
static void append_close_tag(char *tagname,
			     HT_tagspec ** head,
			     HT_tagspec ** tail)
d93 2
a94 2
    HTTag *tag;
    HT_tagspec *subj;
d97 1
a97 1
    tag = HTML_dtd.tags + idx;
d102 1
a102 1
		"internal error: previous check didn't find bad HTML tag %s", tagname);
a109 1

d116 1
a116 2
	*head = subj;
	*tail = subj;
d118 1
a118 2
	(*tail)->next = subj;
	*tail = subj;
d124 5
a128 4
static void append_open_tag(char *tagname,
			    char *classname GCC_UNUSED,
			    HT_tagspec ** head,
			    HT_tagspec ** tail)
d130 2
a131 3
    HT_tagspec *subj;
    HTTag *tag;

d136 1
a136 1
    append_close_tag(tagname, head, tail);	/* initialize common members */
d154 2
a155 3
	attr *attrs = tag->attributes;

/*.... *//* this is not implemented though it's easy */
d162 1
a162 1
	StrAllocCopy(subj->class_name, "");
d169 5
a173 4
int html_src_parse_tagspec(char *ts,
			   HTlexeme lexeme,
			   BOOL checkonly,
			   BOOL isstart)
d182 2
a183 2
    HT_tagspec *head = NULL, *tail = NULL;
    HT_tagspec **slot = (isstart ? lexeme_start : lexeme_end) + lexeme;
d187 22
a208 5
	case HTSRC_CK_normal:
	case HTSRC_CK_seen_excl:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
d210 28
a237 39
	    case ' ':
	    case '\t':
		break;
	    case '!':
		if (state == HTSRC_CK_seen_excl)
		    return 1;	/*second '!' */
		state = HTSRC_CK_seen_excl;
		after_excl = TRUE;
		break;
	    default:
		if (isalpha(UCH(*p)) || *p == '_') {
		    tagstart = p;
		    while (*p && (isalnum(UCH(*p)) || *p == '_'))
			++p;
		    tagend = p;
		    state = HTSRC_CK_after_tagname;
		} else
		    return 1;
		continue;
	    }
	    break;
	case HTSRC_CK_after_tagname:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
		/* FALLTHRU */
	    case ' ':
		/* FALLTHRU */
	    case '\t':
		{
		    char save = *tagend;

		    *tagend = '\0';
		    classstart = 0;
		    if (checkonly) {
			int idx = html_src_tag_index(tagstart);

			*tagend = save;
			if (idx == -1)
d239 4
a242 8
		    } else {
			if (after_excl)
			    append_close_tag(tagstart, &head, &tail);
			else
			    append_open_tag(tagstart, NULL, &head, &tail);
		    }
		    state = HTSRC_CK_normal;
		    after_excl = FALSE;
d245 1
a245 10
	    case '.':
		if (after_excl)
		    return 1;
		state = HTSRC_CK_seen_dot;
		break;
	    default:
		return 1;
	    }
	    break;
	case HTSRC_CK_seen_dot:{
d247 6
a252 6
		case ' ':
		case '\t':
		    break;
		case '\0':
		    return 1;
		default:{
d254 1
a254 2

			if (isalpha(UCH(*p)) || *p == '_') {
d256 1
a256 2
			    while (*p && (isalnum(UCH(*p)) || *p == '_'))
				++p;
d264 1
a264 3

				*tagend = save1;
				*classend = save;
d266 1
a266 1
				    return 1;
d270 1
a270 2
			    state = HTSRC_CK_normal;
			    after_excl = FALSE;
d275 1
a275 1
		}		/*of switch(*p) */
d277 2
a278 2
	    }			/* of case HTSRC_CK_seen_dot: */
	}			/* of switch */
d288 2
a289 1
void html_src_clean_item(HTlexeme l)
d295 4
a298 4
    for (i = 0; i < 2; ++i) {
	HT_tagspec *cur;
	HT_tagspec **pts = (i ? lexeme_start : lexeme_end) + l;
	HT_tagspec *ts = *pts;
d317 1
a317 1
void html_src_clean_data(void)
a319 1

d324 1
a324 1
void html_src_on_lynxcfg_reload(void)
d330 2
a331 1
void HTMLSRC_init_caches(BOOL dont_exit)
d334 1
a334 1
    char *p;
d338 1
a338 1
	/*we assume that HT_tagspecs was NULLs at when program started */
d348 2
a349 3
	if (html_src_parse_tagspec(buf, i, FALSE, TRUE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 1st tagspec of %d lexeme", i);
d352 2
a353 3
	if (html_src_parse_tagspec(p ? p + 1 : NULL, i, FALSE, FALSE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 2nd tagspec of %d lexeme", i);
@


1.1.3.4
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d149 1
a149 1
    if (non_empty(classname)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a7 2
#include <LYStrings.h>
#include <LYLeaks.h>
d9 1
a9 5
 /* This file creates too many "leak detected" entries in Lynx.leaks. */
#define NO_MEMORY_TRACKING
#include <LYLeaks.h>

#ifdef USE_PRETTYSRC
d19 1
a19 1
PUBLIC BOOL mark_htext_as_source=FALSE;
d23 1
a23 2
PUBLIC BOOL psrcview_no_anchor_numbering = FALSE;
PRIVATE char* HTL_tagspecs_defaults[HTL_num_lexemes] = {
d40 12
a51 12
    "b:!b",	/*	comment	*/
    "b:!b",	/*	tag	*/
    "b:!b",	/*	attrib	*/
    ":",	/*	attrval	*/
    "b:!b",	/*	abracket*/
    "b:!b",	/*	entity	*/
    ":",	/*	href	*/
    ":",	/*	entire	*/
    "b:!b",	/*	badseq	*/
    ":",	/*	badtag	*/
    ":",	/*	badattr	*/
    "b:!b"	/*	sgmlspec*/
a54 1
PUBLIC char* HTL_tagspecs[HTL_num_lexemes];
d58 2
a59 2
PUBLIC HT_tagspec* lexeme_start[HTL_num_lexemes];
PUBLIC HT_tagspec* lexeme_end[HTL_num_lexemes];
d72 2
a73 1
typedef enum {
d83 1
a83 1
	    HT_tagspec**, tail)
d96 1
a96 1
	exit_immediately(EXIT_FAILURE);
d99 1
a99 1
    subj = typecalloc(HT_tagspec);
d101 2
a102 2
    subj->present = typecallocn(BOOL, nattr);
    subj->value = typecallocn(char *, nattr);
a103 3
#ifdef USE_COLOR_STYLE
    subj->class_name = NULL;
#endif
d118 1
a118 1
	    HT_tagspec**, tail)
d130 1
a130 1
    tag = HTML_dtd.tags + subj->element;
d152 1
a152 1
	StrAllocCopy(subj->class_name,"");
d158 1
d162 1
a162 1
	HTlexeme,	lexeme,
d174 1
a174 1
    HT_tagspec** slot = ( isstart ? lexeme_start : lexeme_end ) + lexeme;
d190 1
a190 1
			if (isalpha(UCH(*p)) || *p == '_') {
d192 1
a192 1
			    while (*p && ( isalnum(UCH(*p)) || *p == '_') )
a203 1
			/* FALLTHRU */
a204 1
			/* FALLTHRU */
d243 1
a243 1
			if ( isalpha(UCH(*p)) || *p == '_' ) {
d245 1
a245 1
			    while (*p && ( isalnum(UCH(*p)) || *p == '_') ) ++p;
d276 2
a277 45
/*this will clean the data associated with lexeme 'l' */
PUBLIC void html_src_clean_item ARGS1(
	HTlexeme, l)
{
    int i;

    if (HTL_tagspecs[l])
	FREE(HTL_tagspecs[l]);
    for(i = 0; i < 2; ++i) {
	HT_tagspec*	cur;
	HT_tagspec**	pts = ( i ?  lexeme_start :  lexeme_end) + l;
	HT_tagspec*	ts = *pts;

	*pts = NULL;
	while (ts) {
	    FREE(ts->present);
	    FREE(ts->value);
#ifdef USE_COLOR_STYLE
	    if (ts->start) {
		FREE(ts->class_name);
	    }
#endif
	    cur = ts;
	    ts = ts->next;
	    FREE(cur);
	}
    }
}

/*this will be registered with atexit*/
PUBLIC void html_src_clean_data NOARGS
{
    int i;
    for (i = 0; i < HTL_num_lexemes; ++i)
	html_src_clean_item(i);
}

PUBLIC void html_src_on_lynxcfg_reload NOARGS
{
    html_src_clean_data();
    HTMLSRC_init_caches(TRUE);
}

PUBLIC void HTMLSRC_init_caches ARGS1(
	BOOL,	dont_exit)
d283 5
a287 9
    for (i = 0; i < HTL_num_lexemes; ++i) {
	/*we assume that HT_tagspecs was NULLs at when program started*/
	LYstrncpy(buf,
		  HTL_tagspecs[i]
		  ? HTL_tagspecs[i]
		  : HTL_tagspecs_defaults[i],
		  sizeof(buf) - 1);
	StrAllocCopy(HTL_tagspecs[i], buf);

d290 3
a292 3
	if (html_src_parse_tagspec(buf, i, FALSE, TRUE) && !dont_exit ) {
	    fprintf(stderr, "internal error while caching 1st tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
d294 3
a296 3
	if (html_src_parse_tagspec( p ? p+1 : NULL , i, FALSE, FALSE) && !dont_exit) {
	    fprintf(stderr, "internal error while caching 2nd tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
d301 1
a301 1
#endif /* ifdef USE_PRETTYSRC */
@

