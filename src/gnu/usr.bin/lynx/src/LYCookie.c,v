head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.55;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.10.26.26;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.53;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.31;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.09;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.29;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.27;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.21;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.40;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.13;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.38;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.15.48;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.51.01;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@/*			       Lynx Cookie Support		   LYCookie.c
 *			       ===================
 *
 *	Author: AMK	A.M. Kuchling (amk@@magnet.com)	12/25/96
 *
 *	Incorporated with mods by FM			01/16/97
 *
 *  Based on:
 *	http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-mgmt-05.txt
 *
 *	Updated for:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *		- FM					1997-07-09
 *
 *	Updated for:
 *   ftp://ds.internic.net/internet-drafts/draft-ietf-http-state-man-mec-03.txt
 *		- FM					1997-08-02
 *
 *	Partially checked against:
 *   http://www.ietf.org/internet-drafts/draft-ietf-http-state-man-mec-10.txt
 *		- kw					1998-12-11
 *
 *  TO DO: (roughly in order of decreasing priority)
      * Persistent cookies are still experimental.  Presently cookies
	lose many pieces of information that distinguish
	version 1 from version 0 cookies.  There is no easy way around
	that with the current cookie file format.  Ports are currently
	not stored persistently at all which is clearly wrong.
      * We currently don't do anything special for unverifiable
	transactions to third-party hosts.
      * We currently don't use effective host names or check for
	Domain=.local.
      * Hex escaping isn't considered at all.  Any semi-colons, commas,
	or spaces actually in cookie names or values (i.e., not serving
	as punctuation for the overall Set-Cookie value) should be hex
	escaped if not quoted, but presumably the server is expecting
	them to be hex escaped in our Cookie request header as well, so
	in theory we need not unescape them.  We'll see how this works
	out in practice.
      * The prompt should show more information about the cookie being
	set in Novice mode.
      * The truncation heuristic in HTConfirmCookie should probably be
	smarter, smart enough to leave a really short name/value string
	alone.
      * We protect against denial-of-service attacks (see section 6.3.1
	of the draft) by limiting a domain to 50 cookies, limiting the
	total number of cookies to 500, and limiting a processed cookie
	to a maximum of 4096 bytes, but we count on the normal garbage
	collections to bring us back down under the limits, rather than
	actively removing cookies and/or domains based on age or frequency
	of use.
      * If a cookie has the secure flag set, we presently treat only SSL
	connections as secure.  This may need to be expanded for other
	secure communication protocols that become standardized.
*/

#include <HTUtils.h>
#include <HTAccess.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYCharUtils.h>
#include <LYClean.h>
#include <LYGlobalDefs.h>
#include <LYEdit.h>
#include <LYStrings.h>
#include <GridText.h>
#include <LYCookie.h>

#include <LYLeaks.h>

/* default for new domains, one of the invcheck_behaviour_t values: */
#define DEFAULT_INVCHECK_BV INVCHECK_QUERY

/*
 *  The first level of the cookie list is a list indexed by the domain
 *  string; cookies with the same domain will be placed in the same
 *  list.  Thus, finding the cookies that apply to a given URL is a
 *  two-level scan; first we check each domain to see if it applies,
 *  and if so, then we check the paths of all the cookies on that
 *  list.  We keep a running total of cookies as we add or delete
 *  them
 */
static HTList *domain_list = NULL;
static HTList *cookie_list = NULL;
static int total_cookies = 0;

struct _cookie {
    char *lynxID;		/* Lynx cookie identifier */
    char *name;			/* Name of this cookie */
    char *value;		/* Value of this cookie */
    int version;		/* Cookie protocol version (=1) */
    char *comment;		/* Comment to show to user */
    char *commentURL;		/* URL for comment to show to user */
    char *domain;		/* Domain for which this cookie is valid */
    int port;			/* Server port from which this cookie was given (usu. 80) */
    char *PortList;		/* List of ports for which cookie can be sent */
    char *path;			/* Path prefix for which this cookie is valid */
    int pathlen;		/* Length of the path */
    int flags;			/* Various flags */
    time_t expires;		/* The time when this cookie expires */
    BOOL quoted;		/* Was a value quoted in the Set-Cookie header? */
};
typedef struct _cookie cookie;

#define COOKIE_FLAG_SECURE 1	/* If set, cookie requires secure links */
#define COOKIE_FLAG_DISCARD 2	/* If set, expire at end of session */
#define COOKIE_FLAG_EXPIRES_SET 4	/* If set, an expiry date was set */
#define COOKIE_FLAG_DOMAIN_SET 8	/* If set, an non-default domain was set */
#define COOKIE_FLAG_PATH_SET 16	/* If set, an non-default path was set */
#define COOKIE_FLAG_FROM_FILE 32	/* If set, this cookie was persistent */

struct _HTStream {
    HTStreamClass *isa;
};

static void MemAllocCopy(char **dest,
			 const char *start,
			 const char *end)
{
    char *temp;

    if (!(start && end) || (end <= start)) {
	HTSACopy(dest, "");
	return;
    }

    temp = typecallocn(char, (end - start) + 1);
    if (temp == NULL)
	outofmem(__FILE__, "MemAllocCopy");
    LYstrncpy(temp, start, (end - start));
    HTSACopy(dest, temp);
    FREE(temp);
}

static cookie *newCookie(void)
{
    cookie *p = typecalloc(cookie);

    if (p == NULL)
	outofmem(__FILE__, "newCookie");
    HTSprintf0(&(p->lynxID), "%p", p);
    p->port = 80;
    return p;
}

static void freeCookie(cookie * co)
{
    if (co) {
	FREE(co->lynxID);
	FREE(co->name);
	FREE(co->value);
	FREE(co->comment);
	FREE(co->commentURL);
	FREE(co->domain);
	FREE(co->path);
	FREE(co->PortList);
	FREE(co);
    }
}

#ifdef LY_FIND_LEAKS
static void LYCookieJar_free(void)
{
    HTList *dl = domain_list;
    domain_entry *de = NULL;
    HTList *cl = NULL, *next = NULL;
    cookie *co = NULL;

    CTRACE((tfp, "LYCookieJar_free\n"));
    while (dl) {
	if ((de = dl->object) != NULL) {
	    CTRACE((tfp, "...LYCookieJar_free domain %s\n", de->domain));
	    cl = de->cookie_list;
	    while (cl) {
		next = cl->next;
		co = cl->object;
		if (co) {
		    HTList_removeObject(de->cookie_list, co);
		    freeCookie(co);
		}
		cl = next;
	    }
	    FREE(de->domain);
	    HTList_delete(de->cookie_list);
	    de->cookie_list = NULL;
	    FREE(dl->object);
	}
	dl = dl->next;
    }
    cookie_list = NULL;
    HTList_delete(domain_list);
    domain_list = NULL;
}
#endif /* LY_FIND_LEAKS */

/*
 *  Compare two hostnames as specified in Section 2 of:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *	- AK & FM
 */
static BOOLEAN host_matches(const char *A,
			    const char *B)
{
    /*
     * The following line will handle both numeric IP addresses and FQDNs.  Do
     * numeric addresses require special handling?
     */
    if (*B != '.' && !strcasecomp(A, B))
	return YES;

    /*
     * The following will pass a "dotted tail" match to "a.b.c.e" as described
     * in Section 2 of draft-ietf-http-state-man-mec-10.txt.
     */
    if (*B == '.' && B[1] != '\0' && B[1] != '.' && *A != '.') {
	int diff = (strlen(A) - strlen(B));

	if (diff > 0) {
	    if (!strcasecomp((A + diff), B))
		return YES;
	}
    }
    return NO;
}

/*
 *  Compare the current port with a port list as specified in Section 4.3 of:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *	- FM
 */
static BOOLEAN port_matches(int port,
			    const char *list)
{
    const char *number = list;

    if (!(number && isdigit(UCH(*number))))
	return (FALSE);

    while (*number != '\0') {
	if (atoi(number) == port) {
	    return (TRUE);
	}
	while (isdigit(UCH(*number))) {
	    number++;
	}
	while (*number != '\0' && !isdigit(UCH(*number))) {
	    number++;
	}
    }

    return (FALSE);
}

/*
 * Returns the length of the given path ignoring trailing slashes.
 */
static int ignore_trailing_slash(const char *a)
{
    int len = strlen(a);

    while (len > 1 && a[len - 1] == '/')
	--len;
    return len;
}

/*
 * Check if the path 'a' is a prefix of path 'b', ignoring trailing slashes
 * in either, since they denote an empty component.
 */
static BOOL is_prefix(const char *a, const char *b)
{
    int len_a = ignore_trailing_slash(a);
    int len_b = ignore_trailing_slash(b);

    if (len_a > len_b) {
	return FALSE;
    } else {
	if (strncmp(a, b, len_a) != 0) {
	    return FALSE;
	}
	if (len_a < len_b && (len_a > 1 || a[0] != '/')) {
	    if (b[len_a] != '\0'
		&& b[len_a] != '/') {
		return FALSE;
	    }
	}
    }
    return TRUE;
}

/*
 * Find the domain-entry for the given name.
 */
static domain_entry *find_domain_entry(const char *name)
{
    HTList *hl;
    domain_entry *de = NULL;

    if (name != 0
	&& *name != '\0') {
	for (hl = domain_list; hl != NULL; hl = hl->next) {
	    de = (domain_entry *) hl->object;
	    if (de != NULL && de->domain != NULL) {
		CTRACE2(TRACE_CFG,
			(tfp,
			 "...test_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
			 de->domain,
			 de->bv,
			 de->invcheck_bv));
		if (!strcasecomp(name, de->domain)) {
		    break;
		}
	    }
	    de = NULL;
	}
    }
    CTRACE((tfp, "find_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
	    name,
	    de ? (int) de->bv : -1,
	    de ? (int) de->invcheck_bv : -1));
    return de;
}

/*
 *  Store a cookie somewhere in the domain list. - AK & FM
 */
static void store_cookie(cookie * co, const char *hostname,
			 const char *path)
{
    HTList *hl, *next;
    cookie *c2;
    time_t now = time(NULL);
    int pos;
    const char *ptr;
    domain_entry *de = NULL;
    BOOL Replacement = FALSE;
    int invprompt_reasons = 0;	/* what is wrong with this cookie - kw */

#define FAILS_COND1 0x01
#define FAILS_COND4 0x02

    if (co == NULL)
	return;

    /*
     * Ensure that the domain list exists.
     */
    if (domain_list == NULL) {
#ifdef LY_FIND_LEAKS
	atexit(LYCookieJar_free);
#endif
	domain_list = HTList_new();
	total_cookies = 0;
    }

    /*
     * Look through domain_list to see if the cookie's domain is already
     * listed.
     */
    cookie_list = NULL;
    if ((de = find_domain_entry(co->domain)) != NULL)
	cookie_list = de->cookie_list;

    /*
     * Apply sanity checks.
     *
     * Section 4.3.2, condition 1:  The value for the Path attribute is
     * not a prefix of the request-URI.
     *
     * If cookie checking for this domain is set to INVCHECK_LOOSE,
     * then we want to bypass this check.  The user should be queried
     * if set to INVCHECK_QUERY.
     */
    if (!is_prefix(co->path, path)) {
	invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
					    : DEFAULT_INVCHECK_BV);

	switch (invcheck_bv) {
	case INVCHECK_LOOSE:
	    break;		/* continue as if nothing were wrong */

	case INVCHECK_QUERY:
	    invprompt_reasons |= FAILS_COND1;
	    break;		/* will prompt later if we get that far */

	case INVCHECK_STRICT:
	    CTRACE((tfp,
		    "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		    co->path, path));
	    freeCookie(co);
	    return;
	}
    }

    /*
     * The next 4 conditions do NOT apply if the domain is still
     * the default of request-host. (domains - case insensitive).
     */
    if (strcasecomp(co->domain, hostname) != 0) {
	/*
	 * The hostname does not contain a dot.
	 */
	if (strchr(hostname, '.') == NULL) {
	    CTRACE((tfp, "store_cookie: Rejecting because '%s' has no dot.\n",
		    hostname));
	    freeCookie(co);
	    return;
	}

	/*
	 * Section 4.3.2, condition 2:  The value for the Domain attribute
	 * contains no embedded dots or does not start with a dot.  (A dot is
	 * embedded if it's neither the first nor last character.) Note that we
	 * added a lead dot ourselves if a domain attribute value otherwise
	 * qualified.  - FM
	 */
	if (co->domain[0] != '.' || co->domain[1] == '\0') {
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n", co->domain));
	    freeCookie(co);
	    return;
	}
	ptr = strchr((co->domain + 1), '.');
	if (ptr == NULL || ptr[1] == '\0') {
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n", co->domain));
	    freeCookie(co);
	    return;
	}

	/*
	 * Section 4.3.2, condition 3:  The value for the request-host does not
	 * domain-match the Domain attribute.
	 */
	if (!host_matches(hostname, co->domain)) {
	    CTRACE((tfp,
		    "store_cookie: Rejecting domain '%s' for host '%s'.\n",
		    co->domain, hostname));
	    freeCookie(co);
	    return;
	}

	/*
	 * Section 4.3.2, condition 4:  The request-host is an HDN (not IP
	 * address) and has the form HD, where D is the value of the Domain
	 * attribute, and H is a string that contains one or more dots.
	 *
	 * If cookie checking for this domain is set to INVCHECK_LOOSE, then we
	 * want to bypass this check.  The user should be queried if set to
	 * INVCHECK_QUERY.
	 */
	ptr = ((hostname + strlen(hostname)) - strlen(co->domain));
	if (strchr(hostname, '.') < ptr) {
	    invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
						: DEFAULT_INVCHECK_BV);

	    switch (invcheck_bv) {
	    case INVCHECK_LOOSE:
		break;		/* continue as if nothing were wrong */

	    case INVCHECK_QUERY:
		invprompt_reasons |= FAILS_COND4;
		break;		/* will prompt later if we get that far */

	    case INVCHECK_STRICT:
		CTRACE((tfp,
			"store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
			co->path, path));
		freeCookie(co);
		return;
	    }
	}
    }

    /*
     * If we found reasons for issuing an invalid cookie confirmation prompt,
     * do that now.  Rejection by the user here is the last chance to
     * completely ignore this cookie; after it passes this hurdle, it may at
     * least supersede a previous cookie (even if it finally gets rejected).  -
     * kw
     */
    if (invprompt_reasons) {
	char *msg = 0;

	if (invprompt_reasons & FAILS_COND4) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_DOMAIN_CONFIRMATION,
		       co->domain,
		       hostname);
	    if (!HTForcedPrompt(cookie_noprompt, msg, NO)) {
		CTRACE((tfp,
			"store_cookie: Rejecting domain '%s' for host '%s'.\n",
			co->domain,
			hostname));
		freeCookie(co);
		FREE(msg);
		return;
	    }
	}
	if (invprompt_reasons & FAILS_COND1) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_PATH_CONFIRMATION,
		       co->path, path);
	    if (!HTForcedPrompt(cookie_noprompt, msg, NO)) {
		CTRACE((tfp,
			"store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
			co->path, path));
		freeCookie(co);
		FREE(msg);
		return;
	    }
	}
	FREE(msg);
    }

    if (de == NULL) {
	/*
	 * Domain not found; add a new entry for this domain.
	 */
	de = typecalloc(domain_entry);
	if (de == NULL)
	    outofmem(__FILE__, "store_cookie");
	de->bv = QUERY_USER;
	de->invcheck_bv = DEFAULT_INVCHECK_BV;	/* should this go here? */
	cookie_list = de->cookie_list = HTList_new();
	StrAllocCopy(de->domain, co->domain);
	HTList_appendObject(domain_list, de);
    }

    /*
     * Loop over the cookie list, deleting expired and matching cookies.
     */
    hl = cookie_list;
    pos = 0;
    while (hl) {
	c2 = (cookie *) hl->object;
	next = hl->next;
	/*
	 * Check if this cookie has expired.
	 */
	if ((c2 != NULL) &&
	    (c2->flags & COOKIE_FLAG_EXPIRES_SET) &&
	    c2->expires <= now) {
	    HTList_removeObject(cookie_list, c2);
	    freeCookie(c2);
	    c2 = NULL;
	    total_cookies--;

	    /*
	     * Check if this cookie matches the one we're inserting.
	     */
	} else if ((c2) &&
		   !strcasecomp(co->domain, c2->domain) &&
		   !strcmp(co->path, c2->path) &&
		   !strcmp(co->name, c2->name)) {
	    HTList_removeObject(cookie_list, c2);
	    freeCookie(c2);
	    c2 = NULL;
	    total_cookies--;
	    Replacement = TRUE;

	} else if ((c2) && (c2->pathlen) >= (co->pathlen)) {
	    /*
	     * This comparison determines the (tentative) position of the new
	     * cookie in the list such that it comes before existing cookies
	     * with a less specific path, but after existing cookies of equal
	     * (or greater) path length.  Thus it should normally preserve the
	     * order of new cookies with the same path as they are received,
	     * although this is not required.
	     *
	     * From RFC 2109 4.3.4:
	     *
	     * If multiple cookies satisfy the criteria above, they are ordered
	     * in the Cookie header such that those with more specific Path
	     * attributes precede those with less specific.  Ordering with
	     * respect to other attributes (e.g., Domain) is unspecified.
	     */
	    pos++;
	}
	hl = next;
    }

    /*
     * Don't bother to add the cookie if it's already expired.
     */
    if ((co->flags & COOKIE_FLAG_EXPIRES_SET) && co->expires <= now) {
	freeCookie(co);
	co = NULL;

	/*
	 * Don't add the cookie if we're over the domain's limit.  - FM
	 */
    } else if (HTList_count(cookie_list) > max_cookies_domain) {
	CTRACE((tfp,
		"store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n"));
	freeCookie(co);
	co = NULL;

	/*
	 * Don't add the cookie if we're over the total cookie limit.  - FM
	 */
    } else if (total_cookies > max_cookies_global) {
	CTRACE((tfp,
		"store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n"));
	freeCookie(co);
	co = NULL;

	/*
	 * Don't add the cookie if the value is NULL. - BJP
	 */
	/*
	 * Presence of value is now needed (indicated normally by '='),
	 * but it can now be an empty string.
	 * - kw 1999-06-24
	 */
    } else if (co->value == NULL) {	/* should not happen - kw */
	CTRACE((tfp, "store_cookie: Value is NULL! Not storing cookie.\n"));
	freeCookie(co);
	co = NULL;

	/*
	 * If it's a replacement for a cookie that had not expired, and never
	 * allow has not been set, add it again without confirmation.  - FM
	 */
    } else if ((Replacement == TRUE && de) && de->bv != REJECT_ALWAYS) {
	HTList_insertObjectAt(cookie_list, co, pos);
	total_cookies++;

	/*
	 * Get confirmation if we need it, and add cookie if confirmed or
	 * 'allow' is set to always.  - FM
	 *
	 * Cookies read from file are accepted without confirmation prompting. 
	 * (Prompting may actually not be possible if LYLoadCookies is called
	 * before curses is setup.) Maybe this should instead depend on
	 * LYSetCookies and/or LYCookieAcceptDomains and/or
	 * LYCookieRejectDomains and/or LYAcceptAllCookies and/or some other
	 * settings.  -kw
	 */
    } else if ((co->flags & COOKIE_FLAG_FROM_FILE)
	       || HTConfirmCookie(de, hostname, co->name, co->value)) {
	/*
	 * Insert the new cookie so that more specific paths (longer
	 * pathlen) come first in the list. - kw
	 */
	HTList_insertObjectAt(cookie_list, co, pos);
	total_cookies++;
    } else {
	freeCookie(co);
	co = NULL;
    }
}

/*
 *  Scan a domain's cookie_list for any cookies we should
 *  include in a Cookie: request header. - AK & FM
 */
static char *scan_cookie_sublist(char *hostname,
				 char *path,
				 int port,
				 HTList *sublist,
				 char *header,
				 BOOL secure)
{
    HTList *hl = sublist, *next = NULL;
    cookie *co;
    time_t now = time(NULL);
    int len = 0;
    char crlftab[8];

    sprintf(crlftab, "%c%c%c", CR, LF, '\t');
    while (hl) {
	co = (cookie *) hl->object;
	next = hl->next;

	if ((co) &&		/* speed-up host_matches() and limit trace output */
	    (LYstrstr(hostname, co->domain) != NULL)) {
	    CTRACE((tfp, "Checking cookie %p %s=%s\n",
		    hl,
		    (co->name ? co->name : "(no name)"),
		    (co->value ? co->value : "(no value)")));
	    CTRACE((tfp, "\t%s %s %d %s %s %d%s\n",
		    hostname,
		    (co->domain ? co->domain : "(no domain)"),
		    host_matches(hostname, co->domain),
		    path, co->path,
		    (co->pathlen > 0)
		    ? !is_prefix(co->path, path)
		    : 0,
		    (co->flags & COOKIE_FLAG_SECURE)
		    ? " secure"
		    : ""));
	}
	/*
	 * Check if this cookie has expired, and if so, delete it.
	 */
	if (((co) && (co->flags & COOKIE_FLAG_EXPIRES_SET)) &&
	    co->expires <= now) {
	    HTList_removeObject(sublist, co);
	    freeCookie(co);
	    co = NULL;
	    total_cookies--;
	}

	/*
	 * Check if we have a unexpired match, and handle if we do.
	 */
	if (((co != NULL) &&
	     host_matches(hostname, co->domain)) &&
	    (co->pathlen == 0 || is_prefix(co->path, path))) {
	    /*
	     * Skip if the secure flag is set and we don't have a secure
	     * connection.  HTTP.c presently treats only SSL connections as
	     * secure.  - FM
	     */
	    if ((co->flags & COOKIE_FLAG_SECURE) && secure == FALSE) {
		hl = next;
		continue;
	    }

	    /*
	     * Skip if we have a port list and the current port is not listed. 
	     * - FM
	     */
	    if (co->PortList && !port_matches(port, co->PortList)) {
		hl = next;
		continue;
	    }

	    /*
	     * Start or append to the request header.
	     */
	    if (header == NULL) {
		if (co->version > 0) {
		    /*
		     * For Version 1 (or greater) cookies, the version number
		     * goes before the first cookie.
		     */
		    HTSprintf0(&header, "$Version=\"%d\"; ", co->version);
		    len += strlen(header);
		}
	    } else {
		/*
		 * There's already cookie data there, so add a separator
		 * (always use a semi-colon for "backward compatibility").  -
		 * FM
		 */
		StrAllocCat(header, "; ");
		/*
		 * Check if we should fold the header.  - FM
		 */

		/*
		 * Section 2.2 of RFC1945 says:
		 *
		 * HTTP/1.0 headers may be folded onto multiple lines if each
		 * continuation line begins with a space or horizontal tab. 
		 * All linear whitespace, including folding, has the same
		 * semantics as SP.  [...] However, folding of header lines is
		 * not expected by some applications, and should not be
		 * generated by HTTP/1.0 applications.
		 *
		 * This code was causing problems.  Let's not use it.  -BJP
		 */

		/* if (len > 800) { */
		/*    StrAllocCat(header, crlftab); */
		/*    len = 0; */
		/* } */

	    }
	    /*
	     * Include the cookie name=value pair.
	     */
	    StrAllocCat(header, co->name);
	    StrAllocCat(header, "=");
	    if (co->quoted) {
		StrAllocCat(header, "\"");
		len++;
	    }
	    StrAllocCat(header, co->value);
	    if (co->quoted) {
		StrAllocCat(header, "\"");
		len++;
	    }
	    len += (strlen(co->name) + strlen(co->value) + 1);
	    /*
	     * For Version 1 (or greater) cookies, add $PATH, $PORT and/or
	     * $DOMAIN attributes for the cookie if they were specified via a
	     * server reply header.  - FM
	     */
	    if (co->version > 0) {
		if (co->path && (co->flags & COOKIE_FLAG_PATH_SET)) {
		    /*
		     * Append the path attribute.  - FM
		     */
		    StrAllocCat(header, "; $Path=\"");
		    StrAllocCat(header, co->path);
		    StrAllocCat(header, "\"");
		    len += (strlen(co->path) + 10);
		}
		if (co->PortList && isdigit(UCH(*co->PortList))) {
		    /*
		     * Append the port attribute.  - FM
		     */
		    StrAllocCat(header, "; $Port=\"");
		    StrAllocCat(header, co->PortList);
		    StrAllocCat(header, "\"");
		    len += (strlen(co->PortList) + 10);
		}
		if (co->domain && (co->flags & COOKIE_FLAG_DOMAIN_SET)) {
		    /*
		     * Append the domain attribute.  - FM
		     */
		    StrAllocCat(header, "; $Domain=\"");
		    StrAllocCat(header, co->domain);
		    StrAllocCat(header, "\"");
		    len += (strlen(co->domain) + 12);
		}
	    }
	}
	hl = next;
    }

    return (header);
}

/*
 * Presence of value is needed (indicated normally by '=') to start a cookie,
 * but it can be an empty string.  - kw 1999-06-24
 */
static char *alloc_attr_value(const char *value_start,
			      const char *value_end)
{
    char *value = NULL;

    if (value_start && value_end >= value_start) {
	int value_len = (value_end - value_start);

	if (value_len > max_cookies_buffer) {
	    value_len = max_cookies_buffer;
	}
	value = typecallocn(char, value_len + 1);

	if (value == NULL)
	    outofmem(__FILE__, "LYProcessSetCookies");
	LYstrncpy(value, value_start, value_len);
    }
    return value;
}

#define FLAGS_INVALID_PORT 1
#define FLAGS_KNOWN_ATTR   2
#define FLAGS_MAXAGE_ATTR  4

#define is_attr(s, len) attr_len == len && !strncasecomp(attr_start, s, len)

static unsigned parse_attribute(unsigned flags,
				cookie * cur_cookie,
				int *cookie_len,
				const char *attr_start,
				int attr_len,
				char *value,
				const char *address,
				char *hostname,
				int port)
{
    BOOLEAN known_attr = NO;
    int url_type;

    flags &= ~FLAGS_KNOWN_ATTR;
    if (is_attr("secure", 6)) {
	if (value == NULL) {
	    known_attr = YES;
	    if (cur_cookie != NULL) {
		cur_cookie->flags |= COOKIE_FLAG_SECURE;
	    }
	} else {
	    /*
	     * If secure has a value, assume someone misused it as cookie name. 
	     * - FM
	     */
	    known_attr = NO;
	}
    } else if (is_attr("discard", 7)) {
	if (value == NULL) {
	    known_attr = YES;
	    if (cur_cookie != NULL) {
		cur_cookie->flags |= COOKIE_FLAG_DISCARD;
	    }
	} else {
	    /*
	     * If discard has a value, assume someone used it as a cookie name. 
	     * - FM
	     */
	    known_attr = NO;
	}
    } else if (is_attr("comment", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat comment.  - FM
	 */
	    cur_cookie->comment == NULL) {
	    StrAllocCopy(cur_cookie->comment, value);
	    *cookie_len += strlen(cur_cookie->comment);
	}
    } else if (is_attr("commentURL", 10)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat commentURL.  - FM
	 */
	    cur_cookie->commentURL == NULL) {
	    /*
	     * We should get only absolute URLs as values, but will resolve
	     * versus the request's URL just in case.  - FM
	     */
	    cur_cookie->commentURL = HTParse(value,
					     address,
					     PARSE_ALL);
	    /*
	     * Accept only URLs for http or https servers.  - FM
	     */
	    if ((url_type = is_url(cur_cookie->commentURL)) &&
		(url_type == HTTP_URL_TYPE ||
		 url_type == HTTPS_URL_TYPE)) {
		*cookie_len += strlen(cur_cookie->commentURL);
	    } else {
		CTRACE((tfp,
			"LYProcessSetCookies: Rejecting commentURL value '%s'\n",
			cur_cookie->commentURL));
		FREE(cur_cookie->commentURL);
	    }
	}
    } else if (is_attr("domain", 6)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat domain.  - FM
	 */
	    !(cur_cookie->flags & COOKIE_FLAG_DOMAIN_SET)) {
	    *cookie_len -= strlen(cur_cookie->domain);
	    /*
	     * If the value does not have a lead dot, but does have an embedded
	     * dot, and is not an exact match to the hostname, nor is a numeric
	     * IP address, add a lead dot.  Otherwise, use the value as is.  -
	     * FM (domains - case insensitive).
	     */
	    if (value[0] != '.' && value[0] != '\0' &&
		value[1] != '\0' && strcasecomp(value, hostname)) {
		char *ptr = strchr(value, '.');

		if (ptr != NULL && ptr[1] != '\0') {
		    ptr = value;
		    while (*ptr == '.' ||
			   isdigit(UCH(*ptr)))
			ptr++;
		    if (*ptr != '\0') {
			CTRACE((tfp,
				"LYProcessSetCookies: Adding lead dot for domain value '%s'\n",
				value));
			StrAllocCopy(cur_cookie->domain, ".");
			StrAllocCat(cur_cookie->domain, value);
		    } else {
			StrAllocCopy(cur_cookie->domain, value);
		    }
		} else {
		    StrAllocCopy(cur_cookie->domain, value);
		}
	    } else {
		StrAllocCopy(cur_cookie->domain, value);
	    }
	    *cookie_len += strlen(cur_cookie->domain);
	    cur_cookie->flags |= COOKIE_FLAG_DOMAIN_SET;
	}
    } else if (is_attr("path", 4)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat path.  - FM
	 */
	    !(cur_cookie->flags & COOKIE_FLAG_PATH_SET)) {
	    *cookie_len -= strlen(cur_cookie->path);
	    StrAllocCopy(cur_cookie->path, value);
	    *cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
	    cur_cookie->flags |= COOKIE_FLAG_PATH_SET;
	}
    } else if (is_attr("port", 4)) {
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat port.  - FM
	 */
	    cur_cookie->PortList == NULL) {
	    char *cp = value;

	    while ((*cp != '\0') &&
		   (isdigit(UCH(*cp)) ||
		    *cp == ',' || *cp == ' ')) {
		cp++;
	    }
	    if (*cp == '\0') {
		if (!port_matches(port, value)) {
		    flags |= FLAGS_INVALID_PORT;
		} else {
		    StrAllocCopy(cur_cookie->PortList, value);
		    *cookie_len += strlen(cur_cookie->PortList);
		}
		known_attr = YES;
	    } else {
		known_attr = NO;
	    }
	} else if (cur_cookie != NULL) {
	    /*
	     * Don't process a repeat port.  - FM
	     */
	    if (cur_cookie->PortList == NULL) {
		HTSprintf0(&(cur_cookie->PortList), "%d", port);
		*cookie_len += strlen(cur_cookie->PortList);
	    }
	    known_attr = YES;
	}
    } else if (is_attr("version", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat version.  - FM
	 */
	    cur_cookie->version < 1) {
	    int temp = strtol(value, NULL, 10);

	    if (errno != -ERANGE) {
		cur_cookie->version = temp;
	    }
	}
    } else if (is_attr("max-age", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat max-age.  - FM
	 */
	    !(flags & FLAGS_MAXAGE_ATTR)) {
	    int temp = strtol(value, NULL, 10);

	    cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
	    if (errno == -ERANGE) {
		cur_cookie->expires = (time_t) 0;
	    } else {
		cur_cookie->expires = (time(NULL) + temp);
		CTRACE((tfp, "LYSetCookie: expires %ld, %s",
			(long) cur_cookie->expires,
			ctime(&cur_cookie->expires)));
	    }
	    flags |= FLAGS_MAXAGE_ATTR;
	}
    } else if (is_attr("expires", 7)) {
	/*
	 * Convert an 'expires' attribute value if we haven't received a
	 * 'max-age'.  Note that 'expires' should not be used in Version 1
	 * cookies, but it might be used for "backward compatibility", and, in
	 * turn, ill-informed people surely would start using it instead of,
	 * rather than in addition to, 'max-age'.  - FM
	 */
	known_attr = YES;
	if ((cur_cookie != NULL && !(flags & FLAGS_MAXAGE_ATTR)) &&
	    !(cur_cookie->flags & COOKIE_FLAG_EXPIRES_SET)) {
	    if (value) {
		cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
		cur_cookie->expires = LYmktime(value, FALSE);
		if (cur_cookie->expires > 0) {
		    CTRACE((tfp, "LYSetCookie: expires %ld, %s",
			    (long) cur_cookie->expires,
			    ctime(&cur_cookie->expires)));
		}
	    }
	}
    }
    if (known_attr)
	flags |= FLAGS_KNOWN_ATTR;
    return flags;
}

/*
 *  Process potentially concatenated Set-Cookie2 and/or Set-Cookie
 *  headers. - FM
 */
static void LYProcessSetCookies(const char *SetCookie,
				const char *SetCookie2,
				const char *address,
				char *hostname,
				char *path,
				int port)
{
    const char *p, *attr_start, *attr_end, *value_start, *value_end;
    HTList *CombinedCookies = NULL, *cl = NULL;
    cookie *cur_cookie = NULL, *co = NULL;
    int cookie_len = 0;
    int NumCookies = 0;
    BOOL Quoted = FALSE;
    unsigned parse_flags = 0;

    if (isEmpty(SetCookie) &&
	isEmpty(SetCookie2)) {
	/*
	 * Yuk!  Garbage in, so nothing out.  - FM
	 */
	return;
    }

    /*
     * If we have both Set-Cookie and Set-Cookie2 headers.  process the
     * Set-Cookie2 header.  Otherwise, process whichever of the two headers we
     * do have.  Note that if more than one instance of a valued attribute for
     * the same cookie is encountered, the value for the first instance is
     * retained.  We only accept up to 50 cookies from the header, and only if
     * a cookie's values do not exceed the 4096 byte limit on overall size.  -
     * FM
     */
    CombinedCookies = HTList_new();

    /*
     * Process the Set-Cookie2 header, if present and not zero-length, adding
     * each cookie to the CombinedCookies list.  - FM
     */
    p = NonNull(SetCookie2);
    if (SetCookie && *p) {
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie2 header.\n"));
    }
    while (NumCookies <= max_cookies_domain && *p) {
	attr_start = attr_end = value_start = value_end = NULL;
	p = LYSkipCBlanks(p);
	/*
	 * Get the attribute name.
	 */
	attr_start = p;
	while (*p != '\0' && !isspace(UCH(*p)) &&
	       *p != '=' && *p != ';' && *p != ',')
	    p++;
	attr_end = p;
	p = LYSkipCBlanks(p);

	/*
	 * Check for an '=' delimiter, or an 'expires' name followed by white,
	 * since Netscape's bogus parser doesn't require an '=' delimiter, and
	 * 'expires' attributes are being encountered without them.  These
	 * shouldn't be in a Set-Cookie2 header, but we'll assume it's an
	 * expires attribute rather a cookie with that name, since the
	 * attribute mistake rather than name mistake seems more likely to be
	 * made by providers.  - FM
	 */
	if (*p == '=' ||
	    !strncasecomp(attr_start, "Expires", 7)) {
	    /*
	     * Get the value string.
	     */
	    if (*p == '=') {
		p++;
	    }
	    p = LYSkipCBlanks(p);
	    /*
	     * Hack alert!  We must handle Netscape-style cookies with
	     *          "Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *          "Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     * No quotes, but there are spaces.  Argh...  Anyway, we know it
	     * will have at least 3 space separators within it, and two dashes
	     * or two more spaces, so this code looks for a space after the 5th
	     * space separator or dash to mark the end of the value.  - FM
	     */
	    if ((attr_end - attr_start) == 7 &&
		!strncasecomp(attr_start, "Expires", 7)) {
		int spaces = 6;

		value_start = p;
		if (isdigit(UCH(*p))) {
		    /*
		     * No alphabetic day field.  - FM
		     */
		    spaces--;
		} else {
		    /*
		     * Skip the alphabetic day field.  - FM
		     */
		    while (*p != '\0' && isalpha(UCH(*p))) {
			p++;
		    }
		    while (*p == ',' || isspace(UCH(*p))) {
			p++;
		    }
		    spaces--;
		}
		while (*p != '\0' && *p != ';' && *p != ',' && spaces) {
		    p++;
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
			    p++;
			spaces--;
		    } else if (*p == '-') {
			spaces--;
		    }
		}
		value_end = p;
		/*
		 * Hack Alert!  The port attribute can take a comma separated
		 * list of numbers as a value, and such values should be
		 * quoted, but if not, make sure we don't treat a number in the
		 * list as the start of a new cookie.  - FM
		 */
	    } else if ((attr_end - attr_start) == 4 &&
		       !strncasecomp(attr_start, "port", 4) &&
		       isdigit(UCH(*p))) {
		/*
		 * The value starts as an unquoted number.
		 */
		const char *cp, *cp1;

		value_start = p;
		while (1) {
		    while (isdigit(UCH(*p)))
			p++;
		    value_end = p;
		    p = LYSkipCBlanks(p);
		    if (*p == '\0' || *p == ';')
			break;
		    if (*p == ',') {
			cp = LYSkipCBlanks(p + 1);
			if (*cp != '\0' && isdigit(UCH(*cp))) {
			    cp1 = cp;
			    while (isdigit(UCH(*cp1)))
				cp1++;
			    cp1 = LYSkipCBlanks(cp1);
			    if (*cp1 == '\0' || *cp1 == ',' || *cp1 == ';') {
				p = cp;
				continue;
			    }
			}
		    }
		    while (*p != '\0' && *p != ';' && *p != ',')
			p++;
		    value_end = p;
		    /*
		     * Trim trailing spaces.
		     */
		    if ((value_end > value_start) &&
			isspace(UCH(*(value_end - 1)))) {
			value_end--;
			while ((value_end > (value_start + 1)) &&
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
			    value_end--;
			}
		    }
		    break;
		}
	    } else if (*p == '"') {
		BOOLEAN escaped = FALSE;

		/*
		 * It looks like quoted string.
		 */
		p++;
		value_start = p;
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
		    p++;
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
		    p++;
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
	    } else {
		/*
		 * Otherwise, it's an unquoted string.
		 */
		value_start = p;
		while (*p != '\0' && *p != ';' && *p != ',')
		    p++;
		value_end = p;
		/*
		 * Trim trailing spaces.
		 */
		if ((value_end > value_start) &&
		    isspace(UCH(*(value_end - 1)))) {
		    value_end--;
		    while ((value_end > (value_start + 1)) &&
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
			value_end--;
		    }
		}
	    }
	}

	/*
	 * Check for a separator character, and skip it.
	 */
	if (*p == ';' || *p == ',')
	    p++;

	/*
	 * Now, we can handle this attribute/value pair.
	 */
	if (attr_end > attr_start) {
	    char *value = alloc_attr_value(value_start, value_end);

	    parse_flags = parse_attribute(parse_flags,
					  cur_cookie,
					  &cookie_len,
					  attr_start,
					  (attr_end - attr_start),
					  value,
					  address,
					  hostname,
					  port);

	    /*
	     * Presence of value is needed (indicated normally by '='),
	     * but it can be an empty string. - kw 1999-06-24
	     */
	    if (!(parse_flags & FLAGS_KNOWN_ATTR)
		&& value
		&& value_end >= value_start) {
		/*
		 * If we've started a cookie, and it's not too big, save it in
		 * the CombinedCookies list.  - FM
		 */
		if (cookie_len <= max_cookies_buffer
		    && cur_cookie != NULL
		    && !(parse_flags & FLAGS_INVALID_PORT)) {
		    /*
		     * Assume version 1 if not set to that or higher.  - FM
		     */
		    if (cur_cookie->version < 1) {
			cur_cookie->version = 1;
		    }
		    HTList_appendObject(CombinedCookies, cur_cookie);
		} else if (cur_cookie != NULL) {
		    CTRACE((tfp,
			    "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
			    (cur_cookie->name ?
			     cur_cookie->name : "[no name]"),
			    (cur_cookie->value ?
			     cur_cookie->value : "[no value]")));
		    CTRACE((tfp,
			    (parse_flags & FLAGS_INVALID_PORT) ?
			    "                     due to excessive length!\n"
			    : "                     due to invalid port!\n"));
		    if (parse_flags & FLAGS_INVALID_PORT) {
			NumCookies--;
		    }
		    freeCookie(cur_cookie);
		    cur_cookie = NULL;
		}
		/*
		 * Start a new cookie.  - FM
		 */
		cur_cookie = newCookie();
		cookie_len = 0;
		NumCookies++;
		MemAllocCopy(&(cur_cookie->name), attr_start, attr_end);
		cookie_len += strlen(cur_cookie->name);
		MemAllocCopy(&(cur_cookie->value), value_start, value_end);
		cookie_len += strlen(cur_cookie->value);
		StrAllocCopy(cur_cookie->domain, hostname);
		cookie_len += strlen(cur_cookie->domain);
		StrAllocCopy(cur_cookie->path, path);
		cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
		cur_cookie->port = port;
		parse_flags = 0;
		cur_cookie->quoted = TRUE;
	    }
	    FREE(value);
	}
    }

    /*
     * Add any final SetCookie2 cookie to the CombinedCookie list if we are
     * within the length limit.  - FM
     */
    if (NumCookies <= max_cookies_domain
	&& cookie_len <= max_cookies_buffer
	&& cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
	if (cur_cookie->version < 1) {
	    cur_cookie->version = 1;
	}
	HTList_appendObject(CombinedCookies, cur_cookie);
    } else if (cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
		(cookie_len > max_cookies_buffer ? "length" : ""),
		(cookie_len > max_cookies_buffer &&
		 NumCookies > max_cookies_domain
		 ? " and "
		 : ""),
		(NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
	freeCookie(cur_cookie);
	cur_cookie = NULL;
    } else if (cur_cookie != NULL) {	/* invalidport */
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to invalid port!\n"));
	NumCookies--;
	freeCookie(cur_cookie);
	cur_cookie = NULL;
    }

    /*
     * Process the Set-Cookie header, if no non-zero-length Set-Cookie2 header
     * was present.  - FM
     */
    cookie_len = 0;
    NumCookies = 0;
    cur_cookie = NULL;
    p = ((SetCookie && isEmpty(SetCookie2)) ? SetCookie : "");
    if (SetCookie2 && *p) {
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie header.\n"));
    }
    while (NumCookies <= max_cookies_domain && *p) {
	attr_start = attr_end = value_start = value_end = NULL;
	p = LYSkipCBlanks(p);
	/*
	 * Get the attribute name.
	 */
	attr_start = p;
	while (*p != '\0' && !isspace(UCH(*p)) &&
	       *p != '=' && *p != ';' && *p != ',')
	    p++;
	attr_end = p;
	p = LYSkipCBlanks(p);

	/*
	 * Check for an '=' delimiter, or an 'expires' name followed by white,
	 * since Netscape's bogus parser doesn't require an '=' delimiter, and
	 * 'expires' attributes are being encountered without them.  - FM
	 */
	if (*p == '=' ||
	    !strncasecomp(attr_start, "Expires", 7)) {
	    /*
	     * Get the value string.
	     */
	    if (*p == '=') {
		p++;
	    }
	    p = LYSkipCBlanks(p);
	    /*
	     * Hack alert!  We must handle Netscape-style cookies with
	     *          "Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *          "Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     * No quotes, but there are spaces.  Argh...  Anyway, we know it
	     * will have at least 3 space separators within it, and two dashes
	     * or two more spaces, so this code looks for a space after the 5th
	     * space separator or dash to mark the end of the value.  - FM
	     */
	    if ((attr_end - attr_start) == 7 &&
		!strncasecomp(attr_start, "Expires", 7)) {
		int spaces = 6;

		value_start = p;
		if (isdigit(UCH(*p))) {
		    /*
		     * No alphabetic day field.  - FM
		     */
		    spaces--;
		} else {
		    /*
		     * Skip the alphabetic day field.  - FM
		     */
		    while (*p != '\0' && isalpha(UCH(*p))) {
			p++;
		    }
		    while (*p == ',' || isspace(UCH(*p))) {
			p++;
		    }
		    spaces--;
		}
		while (*p != '\0' && *p != ';' && *p != ',' && spaces) {
		    p++;
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
			    p++;
			spaces--;
		    } else if (*p == '-') {
			spaces--;
		    }
		}
		value_end = p;
		/*
		 * Hack Alert!  The port attribute can take a comma separated
		 * list of numbers as a value, and such values should be
		 * quoted, but if not, make sure we don't treat a number in the
		 * list as the start of a new cookie.  - FM
		 */
	    } else if ((attr_end - attr_start) == 4 &&
		       !strncasecomp(attr_start, "port", 4) &&
		       isdigit(UCH(*p))) {
		/*
		 * The value starts as an unquoted number.
		 */
		const char *cp, *cp1;

		value_start = p;
		while (1) {
		    while (isdigit(UCH(*p)))
			p++;
		    value_end = p;
		    p = LYSkipCBlanks(p);
		    if (*p == '\0' || *p == ';')
			break;
		    if (*p == ',') {
			cp = LYSkipCBlanks(p + 1);
			if (*cp != '\0' && isdigit(UCH(*cp))) {
			    cp1 = cp;
			    while (isdigit(UCH(*cp1)))
				cp1++;
			    cp1 = LYSkipCBlanks(cp1);
			    if (*cp1 == '\0' || *cp1 == ',' || *cp1 == ';') {
				p = cp;
				continue;
			    }
			}
		    }
		    while (*p != '\0' && *p != ';' && *p != ',')
			p++;
		    value_end = p;
		    /*
		     * Trim trailing spaces.
		     */
		    if ((value_end > value_start) &&
			isspace(UCH(*(value_end - 1)))) {
			value_end--;
			while ((value_end > (value_start + 1)) &&
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
			    value_end--;
			}
		    }
		    break;
		}
	    } else if (*p == '"') {
		BOOLEAN escaped = FALSE;

		/*
		 * It looks like quoted string.
		 */
		p++;
		value_start = p;
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
		    p++;
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
		    p++;
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
	    } else {
		/*
		 * Otherwise, it's an unquoted string.
		 */
		value_start = p;
		while (*p != '\0' && *p != ';' && *p != ',')
		    p++;
		value_end = p;
		/*
		 * Trim trailing spaces.
		 */
		if ((value_end > value_start) &&
		    isspace(UCH(*(value_end - 1)))) {
		    value_end--;
		    while ((value_end > (value_start + 1)) &&
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
			value_end--;
		    }
		}
	    }
	}

	/*
	 * Check for a separator character, and skip it.
	 */
	if (*p == ';' || *p == ',')
	    p++;

	/*
	 * Now, we can handle this attribute/value pair.
	 */
	if (attr_end > attr_start) {
	    char *value = alloc_attr_value(value_start, value_end);

	    parse_flags = parse_attribute(parse_flags,
					  cur_cookie,
					  &cookie_len,
					  attr_start,
					  (attr_end - attr_start),
					  value,
					  address,
					  hostname,
					  port);

	    /*
	     * Presence of value is needed (indicated normally by '='),
	     * but it can be an empty string. - kw 1999-06-24
	     */
	    if (!(parse_flags & FLAGS_KNOWN_ATTR)
		&& value
		&& value_end >= value_start) {
		/*
		 * If we've started a cookie, and it's not too big, save it in
		 * the CombinedCookies list.  - FM
		 */
		if (cookie_len <= max_cookies_buffer
		    && cur_cookie != NULL) {
		    /*
		     * If we had a Set-Cookie2 header, make sure the version is
		     * at least 1, and mark it for quoting.  - FM
		     */
		    if (SetCookie2 != NULL) {
			if (cur_cookie->version < 1) {
			    cur_cookie->version = 1;
			}
			cur_cookie->quoted = TRUE;
		    }
		    HTList_appendObject(CombinedCookies, cur_cookie);
		} else if (cur_cookie != NULL) {
		    CTRACE((tfp,
			    "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
			    (cur_cookie->name ?
			     cur_cookie->name : "[no name]"),
			    (cur_cookie->value ?
			     cur_cookie->value : "[no value]")));
		    CTRACE((tfp,
			    "                     due to excessive length!\n"));
		    freeCookie(cur_cookie);
		    cur_cookie = NULL;
		}
		/*
		 * Start a new cookie.  - FM
		 */
		cur_cookie = newCookie();
		NumCookies++;
		cookie_len = 0;
		MemAllocCopy(&(cur_cookie->name), attr_start, attr_end);
		cookie_len += strlen(cur_cookie->name);
		MemAllocCopy(&(cur_cookie->value), value_start, value_end);
		cookie_len += strlen(cur_cookie->value);
		StrAllocCopy(cur_cookie->domain, hostname);
		cookie_len += strlen(cur_cookie->domain);
		StrAllocCopy(cur_cookie->path, path);
		cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
		cur_cookie->port = port;
		parse_flags = 0;
		cur_cookie->quoted = Quoted;
		Quoted = FALSE;
	    }
	    FREE(value);
	}
    }

    /*
     * Handle the final Set-Cookie cookie if within length limit.  - FM
     */
    if (NumCookies <= max_cookies_domain
	&& cookie_len <= max_cookies_buffer
	&& cur_cookie != NULL) {
	if (SetCookie2 != NULL) {
	    if (cur_cookie->version < 1) {
		cur_cookie->version = 1;
	    }
	    cur_cookie->quoted = TRUE;
	}
	HTList_appendObject(CombinedCookies, cur_cookie);
    } else if (cur_cookie != NULL) {
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
		(cookie_len > max_cookies_buffer ? "length" : ""),
		(cookie_len > max_cookies_buffer && NumCookies > max_cookies_domain
		 ? " and "
		 : ""),
		(NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
	freeCookie(cur_cookie);
	cur_cookie = NULL;
    }

    /*
     * OK, now we can actually store any cookies in the CombinedCookies list. 
     * - FM
     */
    cl = CombinedCookies;
    while (NULL != (co = (cookie *) HTList_nextObject(cl))) {
	CTRACE((tfp, "LYProcessSetCookie: attr=value pair: '%s=%s'\n",
		(co->name ? co->name : "[no name]"),
		(co->value ? co->value : "[no value]")));
	if (co->expires > 0) {
	    CTRACE((tfp, "                    expires: %ld, %s\n",
		    (long) co->expires,
		    ctime(&co->expires)));
	}
	if (isHTTPS_URL(address) &&
	    LYForceSSLCookiesSecure == TRUE &&
	    !(co->flags & COOKIE_FLAG_SECURE)) {
	    co->flags |= COOKIE_FLAG_SECURE;
	    CTRACE((tfp, "                    Forced the 'secure' flag on.\n"));
	}
	store_cookie(co, hostname, path);
    }
    HTList_delete(CombinedCookies);
    CombinedCookies = NULL;

    return;
}

/*
 *  Entry function for handling Set-Cookie: and/or Set-Cookie2:
 *  reply headers.   They may have been concatenated as comma
 *  separated lists in HTTP.c or HTMIME.c. - FM
 */
void LYSetCookie(const char *SetCookie,
		 const char *SetCookie2,
		 const char *address)
{
    BOOL BadHeaders = FALSE;
    char *hostname = NULL, *path = NULL, *ptr;
    int port = 80;

    /*
     * Get the hostname, port and path of the address, and report the
     * Set-Cookie and/or Set-Cookie2 header(s) if trace mode is on, but set the
     * cookie(s) only if LYSetCookies is TRUE.  - FM
     */
    if (((hostname = HTParse(address, "", PARSE_HOST)) != NULL) &&
	(ptr = strchr(hostname, ':')) != NULL) {
	/*
	 * Replace default port number.
	 */
	*ptr = '\0';
	ptr++;
	port = atoi(ptr);
    } else if (isHTTPS_URL(address)) {
	port = 443;
    }
    if (((path = HTParse(address, "",
			 PARSE_PATH | PARSE_PUNCTUATION)) != NULL) &&
	(ptr = strrchr(path, '/')) != NULL) {
	if (ptr == path) {
	    *(ptr + 1) = '\0';	/* Leave a single '/' alone */
	} else {
	    *ptr = '\0';
	}
    }
    if (isEmpty(SetCookie) &&
	isEmpty(SetCookie2)) {
	/*
	 * Yuk, something must have gone wrong in HTMIME.c or HTTP.c because
	 * both SetCookie and SetCookie2 are NULL or zero-length.  - FM
	 */
	BadHeaders = TRUE;
    }
    CTRACE((tfp, "LYSetCookie called with host '%s', path '%s',\n",
	    NonNull(hostname),
	    NonNull(path)));
    if (SetCookie) {
	CTRACE((tfp, "    and Set-Cookie: '%s'\n", SetCookie));
    }
    if (SetCookie2) {
	CTRACE((tfp, "    and Set-Cookie2: '%s'\n", SetCookie2));
    }
    if (LYSetCookies == FALSE || BadHeaders == TRUE) {
	CTRACE((tfp, "    Ignoring this Set-Cookie/Set-Cookie2 request.\n"));
    }

    /*
     * We're done if LYSetCookies is off or we have bad headers.  - FM
     */
    if (LYSetCookies == FALSE || BadHeaders == TRUE) {
	FREE(hostname);
	FREE(path);
	return;
    }

    /*
     * Process the header(s).
     */
    LYProcessSetCookies(SetCookie, SetCookie2, address, hostname, path, port);
    FREE(hostname);
    FREE(path);
    return;
}

/*
 *  Entry function from creating a Cookie: request header
 *  if needed. - AK & FM
 */
char *LYAddCookieHeader(char *hostname,
			char *path,
			int port,
			BOOL secure)
{
    char *header = NULL;
    HTList *hl = domain_list, *next = NULL;
    domain_entry *de;

    CTRACE((tfp, "LYCookie: Searching for '%s:%d', '%s'.\n",
	    NONNULL(hostname),
	    port,
	    NONNULL(path)));

    /*
     * Search the cookie_list elements in the domain_list for any cookies
     * associated with the //hostname:port/path
     */
    while (hl) {
	de = (domain_entry *) hl->object;
	next = hl->next;

	if (de != NULL) {
	    if (!HTList_isEmpty(de->cookie_list)) {
		/*
		 * Scan the domain's cookie_list for any cookies we should
		 * include in our request header.
		 */
		header = scan_cookie_sublist(hostname, path, port,
					     de->cookie_list, header, secure);
	    } else if (de->bv == QUERY_USER && de->invcheck_bv == DEFAULT_INVCHECK_BV) {
		/*
		 * No cookies in this domain, and no default accept/reject
		 * choice was set by the user, so delete the domain.  - FM
		 */
		FREE(de->domain);
		HTList_delete(de->cookie_list);
		de->cookie_list = NULL;
		HTList_removeObject(domain_list, de);
		FREE(de);
	    }
	}
	hl = next;
    }
    if (header)
	return (header);

    return (NULL);
}

#ifdef USE_PERSISTENT_COOKIES
static int number_of_file_cookies = 0;

/* rjp - experiment cookie loading */
void LYLoadCookies(char *cookie_file)
{
    FILE *cookie_handle;
    char *buf = NULL;
    static char domain[256], path[LY_MAXPATH], name[256], value[4100];
    static char what[8], secure[8], expires_a[16];
    /* *INDENT-OFF* */
    static struct {
	char *s;
	size_t n;
    } tok_values[] = {
	{ domain,	sizeof(domain) },
	{ what,		sizeof(what) },
	{ path,		sizeof(path) },
	{ secure,	sizeof(secure) },
	{ expires_a,	sizeof(expires_a) },
	{ name,		sizeof(name) },
	{ value,	sizeof(value) },
	{ NULL, 0 }
	};
    /* *INDENT-ON* */

    time_t expires;

    cookie_handle = fopen(cookie_file, TXT_R);
    if (!cookie_handle)
	return;

    CTRACE((tfp, "LYLoadCookies: reading cookies from %s\n", cookie_file));

    number_of_file_cookies = 0;
    while (LYSafeGets(&buf, cookie_handle) != 0) {
	cookie *moo;
	int tok_loop;
	char *tok_out, *tok_ptr;

	LYTrimNewline(buf);
	if (buf[0] == '\0' || buf[0] == '#') {
	    continue;
	}

	number_of_file_cookies++;

	strcat(buf, "\t");	/* add sep after line if enough space - kw */

	/*
	 * Tokenise the cookie line into its component parts -
	 * this only works for Netscape style cookie files at the
	 * moment.  It may be worth investigating an alternative
	 * format for Lynx because the Netscape format isn't all
	 * that useful, or future-proof. - RP
	 *
	 * 'fixed' by using strsep instead of strtok.  No idea
	 * what kind of platform problems this might introduce. - RP
	 */
	/*
	 * This fails when the path is blank
	 *
	 * sscanf(buf, "%s\t%s\t%s\t%s\t%d\t%s\t%[ -~]",
	 *  domain, what, path, secure, &expires, name, value);
	 */
	CTRACE((tfp, "LYLoadCookies: tokenising %s\n", buf));
	tok_ptr = buf;
	tok_out = LYstrsep(&tok_ptr, "\t");
	for (tok_loop = 0; tok_out && tok_values[tok_loop].s; tok_loop++) {
	    CTRACE((tfp, "\t%d:[%03d]:[%s]\n",
		    tok_loop, tok_out - buf, tok_out));
	    LYstrncpy(tok_values[tok_loop].s,
		      tok_out,
		      tok_values[tok_loop].n);
	    /*
	     * It looks like strtok ignores a leading delimiter,
	     * which makes things a bit more interesting.  Something
	     * like "FALSE\t\tFALSE\t" translates to FALSE,FALSE
	     * instead of FALSE,,FALSE. - RP
	     */
	    tok_out = LYstrsep(&tok_ptr, "\t");
	}

	if (tok_values[tok_loop].s) {
	    /* tok_out in above loop must have been NULL prematurely - kw */
	    CTRACE((tfp,
		    "*** wrong format: not enough tokens, ignoring line!\n"));
	    continue;
	}

	expires = atol(expires_a);
	CTRACE((tfp, "expires:\t%s\n", ctime(&expires)));
/*	CTRACE((tfp, "%s\t%s\t%s\t%s\t%ld\t%s\t%s\tREADCOOKIE\n", */
/*	    domain, what, path, secure, (long) expires, name, value)); */
	moo = newCookie();
	StrAllocCopy(moo->domain, domain);
	StrAllocCopy(moo->path, path);
	StrAllocCopy(moo->name, name);
	if (value && value[0] == '"' &&
	    value[1] && value[strlen(value) - 1] == '"' &&
	    value[strlen(value) - 2] != '\\') {
	    value[strlen(value) - 1] = '\0';
	    StrAllocCopy(moo->value, value + 1);
	    moo->quoted = TRUE;
	} else {
	    StrAllocCopy(moo->value, value);
	}
	moo->pathlen = strlen(moo->path);
	/*
	 *  Justification for following flags:
	 *  COOKIE_FLAG_FROM_FILE    So we know were it comes from.
	 *  COOKIE_FLAG_EXPIRES_SET  It must have had an explicit
	 *                           expiration originally, otherwise
	 *                           it would not be in the file.
	 *  COOKIE_FLAG_DOMAIN_SET,  We don't know whether these were
	 *   COOKIE_FLAG_PATH_SET    explicit or implicit, but this
	 *                           only matters for sending version 1
	 *                           cookies; the cookies read from the
	 *                           file are currently treated all like
	 *                           version 0 (we don't set moo->version)
	 *                           so $Domain= and $Path= will normally
	 *                           not be sent to the server.  But if
	 *                           these cookies somehow get mixed with
	 *                           new version 1 cookies we may end up
	 *                           sending version 1 to the server, and
	 *                           in that case we should send $Domain
	 *                           and $Path.  The state-man-mec drafts
	 *                           and RFC 2109 say that $Domain and
	 *                           $Path SHOULD be omitted if they were
	 *                           not given explicitly, but not that
	 *                           they MUST be omitted.
	 *                           See 8.2 Cookie Spoofing in draft -10
	 *                           for a good reason to send them.
	 *                           However, an explicit domain should be
	 *                           now prefixed with a dot (unless it is
	 *                           for a single host), so we check for
	 *                           that.
	 *  COOKIE_FLAG_SECURE       Should have "FALSE" for normal,
	 *                           otherwise set it.
	 */
	moo->flags |= COOKIE_FLAG_FROM_FILE | COOKIE_FLAG_EXPIRES_SET |
	    COOKIE_FLAG_PATH_SET;
	if (domain[0] == '.')
	    moo->flags |= COOKIE_FLAG_DOMAIN_SET;
	if (secure[0] != 'F')
	    moo->flags |= COOKIE_FLAG_SECURE;
	/* @@@@@@ Should we set port to 443 if secure is set? @@@@@@ */
	moo->expires = expires;
	/*
	 * I don't like using this to store the cookies because it's
	 * designed to store cookies that have been received from an
	 * HTTP request, not from a persistent cookie jar.  Hence the
	 * mucking about with the COOKIE_FLAG_FROM_FILE above. - RP
	 */
	store_cookie(moo, domain, path);
    }
    LYCloseInput(cookie_handle);
}

/* rjp - experimental persistent cookie support */
void LYStoreCookies(char *cookie_file)
{
    HTList *dl, *cl;
    domain_entry *de;
    cookie *co;
    FILE *cookie_handle;
    time_t now = time(NULL);	/* system specific? - RP */

    if (!strcmp(cookie_file, "/dev/null")) {
	/* We give /dev/null the Unix meaning, regardless of OS */
	return;
    }

    /*
     * Check whether we have something to do.  - FM
     */
    if (HTList_isEmpty(domain_list) &&
	number_of_file_cookies == 0) {
	/* No cookies now, and haven't read any,
	 * so don't bother updating the file.
	 */
	return;
    }

    CTRACE((tfp, "LYStoreCookies: save cookies to %s on exit\n", cookie_file));

    cookie_handle = LYNewTxtFile(cookie_file);
    if (cookie_handle == NULL)
	return;
    for (dl = domain_list; dl != NULL; dl = dl->next) {
	de = (domain_entry *) (dl->object);
	if (de == NULL)
	    /*
	     * Fote says the first object is NULL.  Go with that.
	     */
	    continue;

	/*
	 * Show the domain's cookies.  - FM
	 */
	for (cl = de->cookie_list; cl != NULL; cl = cl->next) {
	    /*
	     * First object is always NULL.  - FM
	     */
	    if ((co = (cookie *) cl->object) == NULL)
		continue;

	    CTRACE((tfp, "LYStoreCookies: %ld cf %ld ",
		    (long) now, (long) co->expires));

	    if ((co->flags & COOKIE_FLAG_DISCARD)) {
		CTRACE((tfp, "not stored - DISCARD\n"));
		continue;
	    } else if (!(co->flags & COOKIE_FLAG_EXPIRES_SET)) {
		CTRACE((tfp, "not stored - no expiration time\n"));
		continue;
	    } else if (co->expires <= now) {
		CTRACE((tfp, "not stored - EXPIRED\n"));
		continue;
	    }

	    fprintf(cookie_handle, "%s\t%s\t%s\t%s\t%ld\t%s\t%s%s%s\n",
		    de->domain,
		    (de->domain[0] == '.') ? "TRUE" : "FALSE",
		    co->path,
		    co->flags & COOKIE_FLAG_SECURE ? "TRUE" : "FALSE",
		    (long) co->expires, co->name,
		    (co->quoted ? "\"" : ""),
		    NonNull(co->value),
		    (co->quoted ? "\"" : ""));

	    CTRACE((tfp, "STORED\n"));
	}
    }
    LYCloseOutput(cookie_handle);

    HTSYS_purge(cookie_file);
}
#endif

/*	LYHandleCookies - F.Macrides (macrides@@sci.wfeb.edu)
 *	---------------
 *
 *  Lists all cookies by domain, and allows deletions of
 *  individual cookies or entire domains, and changes of
 *  'allow' settings.  The list is invoked via the COOKIE_JAR
 *  command (Ctrl-K), and deletions or changes of 'allow'
 *  settings are done by activating links in that list.
 *  The procedure uses a LYNXCOOKIE: internal URL scheme.
 *
 *  Semantics:
 *	LYNXCOOKIE:/			Create and load the Cookie Jar Page.
 *	LYNXCOOKIE://domain		Manipulate the domain.
 *	LYNXCOOKIE://domain/lynxID	Delete cookie with lynxID in domain.
 *
 *	New functions can be added as extensions to the path, and/or by
 *	assigning meanings to ;parameters, a ?searchpart, and/or #fragments.
 */
static int LYHandleCookies(const char *arg,
			   HTParentAnchor *anAnchor,
			   HTFormat format_out,
			   HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    char *domain = NULL;
    char *lynxID = NULL;
    HTList *dl, *cl, *next;
    domain_entry *de;
    cookie *co;
    char *name = NULL, *value = NULL, *path = NULL;
    char *comment = NULL, *Address = NULL, *Title = NULL;
    int ch;

    /*
     * Check whether we have something to do.  - FM
     */
    if (HTList_isEmpty(domain_list)) {
	HTProgress(COOKIE_JAR_IS_EMPTY);
	LYSleepMsg();
	HTNoDataOK = 1;
	return (HT_NO_DATA);
    }

    /*
     * If there's a domain string in the "host" field of the LYNXCOOKIE:  URL,
     * this is a request to delete something or change and 'allow' setting.  -
     * FM
     */
    if ((domain = HTParse(arg, "", PARSE_HOST)) != NULL) {
	if (*domain == '\0') {
	    FREE(domain);
	} else {
	    /*
	     * If there is a path string (not just a slash) in the LYNXCOOKIE: 
	     * URL, that's a cookie's lynxID and this is a request to delete it
	     * from the Cookie Jar.  - FM
	     */
	    if ((lynxID = HTParse(arg, "", PARSE_PATH)) != NULL) {
		if (*lynxID == '\0') {
		    FREE(lynxID);
		}
	    }
	}
    }
    if (domain) {
	/*
	 * Seek the domain in the domain_list structure.  - FM
	 */
	if ((de = find_domain_entry(domain)) != NULL) {
	    FREE(domain);
	    /*
	     * We found the domain.  Check whether a lynxID is present.  - FM
	     */
	    if (lynxID) {
		/*
		 * Seek and delete the cookie with this lynxID in the domain's
		 * cookie list.  - FM
		 */
		for (cl = de->cookie_list; cl != NULL; cl = cl->next) {
		    if ((co = (cookie *) cl->object) == NULL)
			/*
			 * First object is always empty.  - FM
			 */
			continue;
		    if (!strcmp(lynxID, co->lynxID)) {
			/*
			 * We found the cookie.  Delete it if confirmed.  - FM
			 */
			if (HTConfirm(DELETE_COOKIE_CONFIRMATION) == FALSE) {
			    FREE(lynxID);
			    HTNoDataOK = 1;
			    return (HT_NO_DATA);
			}
			HTList_removeObject(de->cookie_list, co);
			freeCookie(co);
			co = NULL;
			total_cookies--;
			if ((de->bv == QUERY_USER &&
			     HTList_isEmpty(de->cookie_list)) &&
			    HTConfirm(DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
			    /*
			     * No more cookies in this domain, no default
			     * accept/reject choice was set by the user, and
			     * got confirmation on deleting the domain, so do
			     * it.  - FM
			     */
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			} else {
			    HTProgress(COOKIE_EATEN);
			}
			LYSleepMsg();
			HTNoDataOK = 1;
			break;
		    }
		}
	    } else {
		/*
		 * Prompt whether to delete all of the cookies in this domain,
		 * or the domain if no cookies in it, or to change its 'allow'
		 * setting, or to cancel, and then act on the user's response. 
		 * - FM
		 */
		if (HTList_isEmpty(de->cookie_list)) {
		    _statusline(DELETE_DOMAIN_SET_ALLOW_OR_CANCEL);
		} else {
		    _statusline(DELETE_COOKIES_SET_ALLOW_OR_CANCEL);
		}
		HTNoDataOK = 1;
		while (1) {
		    ch = LYgetch_single();
#ifdef VMS
		    if (HadVMSInterrupt) {
			HadVMSInterrupt = FALSE;
			ch = 'C';
		    }
#endif /* VMS */
		    switch (ch) {
		    case 'A':
			/*
			 * Set to accept all cookies from this domain.  - FM
			 */
			de->bv = ACCEPT_ALWAYS;
			HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
			return (HT_NO_DATA);

		    case 'C':
			/*
			 * Cancelled.  - FM
			 */
		      reject:
			HTUserMsg(CANCELLED);
			return (HT_NO_DATA);

		    case 'D':
			if (HTList_isEmpty(de->cookie_list)) {
			    /*
			     * We had an empty domain, so we were asked to
			     * delete it.  - FM
			     */
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			    LYSleepMsg();
			    break;
			}
		      Delete_all_cookies_in_domain:
			/*
			 * Delete all cookies in this domain.  - FM
			 */
			cl = de->cookie_list;
			while (cl) {
			    next = cl->next;
			    co = (cookie *) (cl->object);
			    if (co) {
				HTList_removeObject(de->cookie_list, co);
				freeCookie(co);
				co = NULL;
				total_cookies--;
			    }
			    cl = next;
			}
			HTProgress(DOMAIN_COOKIES_EATEN);
			LYSleepMsg();
			/*
			 * If a default accept/reject choice is set, we're
			 * done.  - FM
			 */
			if (de->bv != QUERY_USER)
			    return (HT_NO_DATA);
			/*
			 * Check whether to delete the empty domain.  - FM
			 */
			if (HTConfirm(DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			    LYSleepMsg();
			}
			break;

		    case 'P':
			/*
			 * Set to prompt for cookie acceptance from this
			 * domain.  - FM
			 */
			de->bv = QUERY_USER;
			HTUserMsg2(PROMPTING_TO_ALLOW_COOKIES, de->domain);
			return (HT_NO_DATA);

		    case 'V':
			/*
			 * Set to reject all cookies from this domain.  - FM
			 */
			de->bv = REJECT_ALWAYS;
			HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
			if ((!HTList_isEmpty(de->cookie_list)) &&
			    HTConfirm(DELETE_ALL_COOKIES_IN_DOMAIN))
			    goto Delete_all_cookies_in_domain;
			return (HT_NO_DATA);

		    default:
			if (LYCharIsINTERRUPT(ch))
			    goto reject;
			continue;
		    }
		    break;
		}
	    }
	}
	if (HTList_isEmpty(domain_list)) {
	    /*
	     * There are no more domains left.  Don't delete the domain_list,
	     * otherwise atexit may be called multiple times.  - kw
	     */
	    HTProgress(ALL_COOKIES_EATEN);
	    LYSleepMsg();
	}
	FREE(domain);
	FREE(lynxID);
	return (HT_NO_DATA);
    }

    /*
     * If we get to here, it was a LYNXCOOKIE:/ URL for creating and displaying
     * the Cookie Jar Page, or we didn't find the domain or cookie in a
     * deletion request.  Set up an HTML stream and return an updated Cookie
     * Jar Page.  - FM
     */
    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);
    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }

    /*
     * Load HTML strings into buf and pass buf to the target for parsing and
     * rendering.  - FM
     */
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf,
	       "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       COOKIE_JAR_TITLE);
    PUTS(buf);
    HTSprintf0(&buf, "<h1>%s (%s)%s<a href=\"%s%s\">%s</a></h1>\n",
	       LYNX_NAME, LYNX_VERSION,
	       HELP_ON_SEGMENT,
	       helpfilepath, COOKIE_JAR_HELP, COOKIE_JAR_TITLE);
    PUTS(buf);

    HTSprintf0(&buf, "<note>%s\n", ACTIVATE_TO_GOBBLE);
    PUTS(buf);
    HTSprintf0(&buf, "%s</note>\n", OR_CHANGE_ALLOW);
    PUTS(buf);

    HTSprintf0(&buf, "<dl compact>\n");
    PUTS(buf);
    for (dl = domain_list; dl != NULL; dl = dl->next) {
	de = (domain_entry *) (dl->object);
	if (de == NULL)
	    /*
	     * First object always is NULL.  - FM
	     */
	    continue;

	/*
	 * Show the domain link and 'allow' setting.  - FM
	 */
	HTSprintf0(&buf, "<dt>%s<dd><a href=\"%s//%s/\">Domain=%s</a>\n",
		   de->domain, STR_LYNXCOOKIE, de->domain, de->domain);
	PUTS(buf);
	switch (de->bv) {
	case (ACCEPT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_ALWAYS_ALLOWED);
	    break;
	case (REJECT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_NEVER_ALLOWED);
	    break;
	case (QUERY_USER):
	    HTSprintf0(&buf, COOKIES_ALLOWED_VIA_PROMPT);
	    break;
	}
	PUTS(buf);
	HTSprintf0(&buf, "\n");
	PUTS(buf);

	/*
	 * Show the domain's cookies.  - FM
	 */
	for (cl = de->cookie_list; cl != NULL; cl = cl->next) {
	    if ((co = (cookie *) cl->object) == NULL)
		/*
		 * First object is always NULL.  - FM
		 */
		continue;

	    /*
	     * Show the name=value pair.  - FM
	     */
	    if (co->name) {
		StrAllocCopy(name, co->name);
		LYEntify(&name, TRUE);
	    } else {
		StrAllocCopy(name, NO_NAME);
	    }
	    if (co->value) {
		StrAllocCopy(value, co->value);
		LYEntify(&value, TRUE);
	    } else {
		StrAllocCopy(value, NO_VALUE);
	    }
	    HTSprintf0(&buf, "<dd><a href=\"%s//%s/%s\">%s=%s</a>\n",
		       STR_LYNXCOOKIE, de->domain, co->lynxID, name, value);
	    FREE(name);
	    FREE(value);
	    PUTS(buf);

	    if (co->flags & COOKIE_FLAG_FROM_FILE) {
		HTSprintf0(&buf, "%s\n",
			   gettext("(from a previous session)"));
		PUTS(buf);
	    }

	    /*
	     * Show the path, port, secure and discard setting.  - FM
	     */
	    if (co->path) {
		StrAllocCopy(path, co->path);
		LYEntify(&path, TRUE);
	    } else {
		StrAllocCopy(path, "/");
	    }
	    HTSprintf0(&buf,
		       "<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",
		       path, co->port,
		       ((co->flags & COOKIE_FLAG_SECURE) ? "YES" : "NO"),
		       ((co->flags & COOKIE_FLAG_DISCARD) ? "YES" : "NO"));
	    FREE(path);
	    PUTS(buf);

	    /*
	     * Show the list of acceptable ports, if present.  - FM
	     */
	    if (co->PortList) {
		HTSprintf0(&buf, "<dD>PortList=\"%s\"\n", co->PortList);
		PUTS(buf);
	    }

	    /*
	     * Show the commentURL, if we have one.  - FM
	     */
	    if (co->commentURL) {
		StrAllocCopy(Address, co->commentURL);
		LYEntify(&Address, FALSE);
		StrAllocCopy(Title, co->commentURL);
		LYEntify(&Title, TRUE);
		HTSprintf0(&buf,
			   "<dd>CommentURL: <a href=\"%s\">%s</a>\n",
			   Address,
			   Title);
		FREE(Address);
		FREE(Title);
		PUTS(buf);
	    }

	    /*
	     * Show the comment, if we have one.  - FM
	     */
	    if (co->comment) {
		StrAllocCopy(comment, co->comment);
		LYEntify(&comment, TRUE);
		HTSprintf0(&buf, "<dd>Comment: %s\n", comment);
		FREE(comment);
		PUTS(buf);
	    }

	    /*
	     * Show the Maximum Gobble Date.  - FM
	     */
	    HTSprintf0(&buf, "<dd><em>%s</em> %s%s",
		       gettext("Maximum Gobble Date:"),
		       ((co->flags & COOKIE_FLAG_EXPIRES_SET)
			?
			ctime(&co->expires) : END_OF_SESSION),
		       ((co->flags & COOKIE_FLAG_EXPIRES_SET)
			?
			"" : "\n"));
	    PUTS(buf);
	}
	HTSprintf0(&buf, "</dt>\n");
	PUTS(buf);
    }
    HTSprintf0(&buf, "</dl>\n</body>\n</html>\n");
    PUTS(buf);

    /*
     * Free the target to complete loading of the Cookie Jar Page, and report a
     * successful load.  - FM
     */
    (*target->isa->_free) (target);
    FREE(buf);
    return (HT_LOADED);
}

/*      cookie_domain_flag_set
 *      ----------------------
 *      All purpose function to handle setting domain flags for a
 *      comma-delimited list of domains.  cookie_domain_flags handles
 *      invcheck behavior, as well as accept/reject behavior. - BJP
 */

static void cookie_domain_flag_set(char *domainstr,
				   int flag)
{
    domain_entry *de = NULL;
    char **str = typecalloc(char *);
    char *dstr = NULL;
    char *strsmall = NULL;

    if (str == NULL) {
	HTAlwaysAlert(gettext("Internal"),
		      gettext("cookie_domain_flag_set error, aborting program"));
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Is this the first domain we're handling?  If so, initialize domain_list.
     */
    if (domain_list == NULL) {
#ifdef LY_FIND_LEAKS
	atexit(LYCookieJar_free);
#endif
	domain_list = HTList_new();
	total_cookies = 0;
    }

    StrAllocCopy(dstr, domainstr);

    *str = dstr;

    while ((strsmall = LYstrsep(str, ",")) != 0) {

	if (*strsmall == '\0')
	    /* Never add a domain for empty string.  It would actually
	     * make more sense to use strtok here. - kw */
	    continue;

	/*
	 * Check the list of existing domains to see if this is a
	 * re-setting of an already existing domain -- if so, just
	 * change the behavior, if not, create a new domain entry.
	 */

	if ((de = find_domain_entry(strsmall)) == NULL) {
	    de = typecalloc(domain_entry);
	    if (de == NULL)
		outofmem(__FILE__, "cookie_domain_flag_set");

	    de->bv = ACCEPT_ALWAYS;
	    de->invcheck_bv = INVCHECK_QUERY;

	    switch (flag) {
	    case (FLAG_ACCEPT_ALWAYS):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_REJECT_ALWAYS):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_QUERY_USER):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_INVCHECK_QUERY):
		de->bv = QUERY_USER;
		break;
	    case (FLAG_INVCHECK_STRICT):
		de->bv = QUERY_USER;
		break;
	    case (FLAG_INVCHECK_LOOSE):
		de->bv = QUERY_USER;
		break;
	    }

	    StrAllocCopy(de->domain, strsmall);
	    de->cookie_list = HTList_new();
	    HTList_appendObject(domain_list, de);
	}
	switch (flag) {
	case (FLAG_ACCEPT_ALWAYS):
	    de->bv = ACCEPT_ALWAYS;
	    break;
	case (FLAG_REJECT_ALWAYS):
	    de->bv = REJECT_ALWAYS;
	    break;
	case (FLAG_QUERY_USER):
	    de->bv = QUERY_USER;
	    break;
	case (FLAG_INVCHECK_QUERY):
	    de->invcheck_bv = INVCHECK_QUERY;
	    break;
	case (FLAG_INVCHECK_STRICT):
	    de->invcheck_bv = INVCHECK_STRICT;
	    break;
	case (FLAG_INVCHECK_LOOSE):
	    de->invcheck_bv = INVCHECK_LOOSE;
	    break;
	}
	CTRACE((tfp,
		"cookie_domain_flag_set (%s, bv=%d, invcheck_bv=%d)\n",
		strsmall, de->bv, de->invcheck_bv));
    }

    FREE(strsmall);
    FREE(str);
    FREE(dstr);
}

/*
 * If any COOKIE_{ACCEPT,REJECT}_DOMAINS have been defined, process them.
 * These are comma delimited lists of domains.  - BJP
 *
 * And for query/strict/loose invalid cookie checking.  - BJP
 */
void LYConfigCookies(void)
{
    static const struct {
	char **domain;
	int flag;
	int once;
    } table[] = {
	/* *INDENT-OFF* */
	{ &LYCookieSAcceptDomains,	FLAG_ACCEPT_ALWAYS,   TRUE },
	{ &LYCookieSRejectDomains,	FLAG_REJECT_ALWAYS,   TRUE },
	{ &LYCookieSStrictCheckDomains, FLAG_INVCHECK_STRICT, TRUE },
	{ &LYCookieSLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  TRUE },
	{ &LYCookieSQueryCheckDomains,	FLAG_INVCHECK_QUERY,  TRUE },
	{ &LYCookieAcceptDomains,	FLAG_ACCEPT_ALWAYS,   FALSE },
	{ &LYCookieRejectDomains,	FLAG_REJECT_ALWAYS,   FALSE },
	{ &LYCookieStrictCheckDomains,	FLAG_INVCHECK_STRICT, FALSE },
	{ &LYCookieLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  FALSE },
	{ &LYCookieQueryCheckDomains,	FLAG_INVCHECK_QUERY,  FALSE },
	/* *INDENT-ON* */

    };
    unsigned n;

    for (n = 0; n < TABLESIZE(table); n++) {
	if (*(table[n].domain) != NULL) {
	    cookie_domain_flag_set(*(table[n].domain), table[n].flag);
	    /*
	     * Discard the value for system settings after we've used them.
	     * The local settings will be merged with the contents of .lynxrc
	     */
	    if (table[n].once) {
		FREE(*(table[n].domain));
	    }
	}
    }
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYCOOKIE_C_GLOBALDEF_1_INIT { "LYNXCOOKIE",LYHandleCookies,0}
GLOBALDEF(HTProtocol, LYLynxCookies, _LYCOOKIE_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxCookies =
{"LYNXCOOKIE", LYHandleCookies, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.7
log
@automatic merge
@
text
@a72 4
#define max_cookies_domain 50
#define max_cookies_global 500
#define max_cookies_buffer 4096

d2051 1
a2051 1
	de = dl->object;
d2283 1
a2283 1
			    co = cl->object;
d2397 1
a2397 1
	de = dl->object;
@


1.6
log
@automatic merge of lynx-current
@
text
@d1106 2
a1107 2
    if (!(SetCookie && *SetCookie) &&
	!(SetCookie2 && *SetCookie2)) {
d1427 1
a1427 1
    p = ((SetCookie && !(SetCookie2 && *SetCookie2)) ? SetCookie : "");
d1772 2
a1773 2
    if (!(SetCookie && *SetCookie) &&
	!(SetCookie2 && *SetCookie2)) {
@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 22
a23 22
**			       ===================
**
**	Author: AMK	A.M. Kuchling (amk@@magnet.com)	12/25/96
**
**	Incorporated with mods by FM			01/16/97
**
**  Based on:
**	http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-mgmt-05.txt
**
**	Updated for:
**   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
**		- FM					1997-07-09
**
**	Updated for:
**   ftp://ds.internic.net/internet-drafts/draft-ietf-http-state-man-mec-03.txt
**		- FM					1997-08-02
**
**	Partially checked against:
**   http://www.ietf.org/internet-drafts/draft-ietf-http-state-man-mec-10.txt
**		- kw					1998-12-11
**
**  TO DO: (roughly in order of decreasing priority)
d81 8
a88 8
**  The first level of the cookie list is a list indexed by the domain
**  string; cookies with the same domain will be placed in the same
**  list.  Thus, finding the cookies that apply to a given URL is a
**  two-level scan; first we check each domain to see if it applies,
**  and if so, then we check the paths of all the cookies on that
**  list.  We keep a running total of cookies as we add or delete
**  them
*/
d94 14
a107 14
    char *lynxID;  /* Lynx cookie identifier */
    char *name;    /* Name of this cookie */
    char *value;   /* Value of this cookie */
    int version;   /* Cookie protocol version (=1) */
    char *comment; /* Comment to show to user */
    char *commentURL; /* URL for comment to show to user */
    char *domain;  /* Domain for which this cookie is valid */
    int port;	   /* Server port from which this cookie was given (usu. 80) */
    char *PortList;/* List of ports for which cookie can be sent */
    char *path;    /* Path prefix for which this cookie is valid */
    int pathlen;   /* Length of the path */
    int flags;	   /* Various flags */
    time_t expires;/* The time when this cookie expires */
    BOOL quoted;   /* Was a value quoted in the Set-Cookie header? */
d111 6
a116 6
#define COOKIE_FLAG_SECURE 1	   /* If set, cookie requires secure links */
#define COOKIE_FLAG_DISCARD 2	   /* If set, expire at end of session */
#define COOKIE_FLAG_EXPIRES_SET 4  /* If set, an expiry date was set */
#define COOKIE_FLAG_DOMAIN_SET 8   /* If set, an non-default domain was set */
#define COOKIE_FLAG_PATH_SET 16    /* If set, an non-default path was set */
#define COOKIE_FLAG_FROM_FILE 32  /* If set, this cookie was persistent */
d118 2
a119 3
struct _HTStream
{
  HTStreamClass * isa;
d122 3
a124 4
static void MemAllocCopy (
	char **	dest,
	const char *	start,
	const char *	end)
d141 1
a141 1
static cookie * newCookie (void)
d152 1
a152 2
static void freeCookie (
	cookie *	co)
d168 1
a168 1
static void LYCookieJar_free (void)
d203 6
a208 7
**  Compare two hostnames as specified in Section 2 of:
**   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
**	- AK & FM
*/
static BOOLEAN host_matches (
	const char *	A,
	const char *	B)
d211 2
a212 2
     *	The following line will handle both numeric IP addresses and
     *	FQDNs.  Do numeric addresses require special handling?
d218 2
a219 2
     *	The following will pass a "dotted tail" match to "a.b.c.e"
     *	as described in Section 2 of draft-ietf-http-state-man-mec-10.txt.
d223 1
d233 6
a238 7
**  Compare the current port with a port list as specified in Section 4.3 of:
**   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
**	- FM
*/
static BOOLEAN port_matches (
	int		port,
	const char *	list)
d243 1
a243 1
	return(FALSE);
d247 1
a247 1
	    return(TRUE);
d257 1
a257 1
    return(FALSE);
d263 1
a263 1
static int ignore_trailing_slash (const char * a)
d266 2
a267 1
    while (len > 1 && a[len-1] == '/')
d276 1
a276 1
static BOOL is_prefix (const char * a, const char * b)
d289 1
a289 1
	     && b[len_a] != '/') {
d291 1
a291 1
	     }
d300 1
a300 2
static domain_entry * find_domain_entry (
    const char *	name)
d306 1
a306 1
     && *name != '\0') {
d308 1
a308 1
	    de = (domain_entry *)hl->object;
d311 5
a315 4
			(tfp, "...test_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
			      de->domain,
			      de->bv,
			      de->invcheck_bv));
d324 3
a326 3
		 name,
		 de ? (int) de->bv : -1,
		 de ? (int) de->invcheck_bv : -1));
d331 4
a334 6
**  Store a cookie somewhere in the domain list. - AK & FM
*/
static void store_cookie (
	cookie *	co,
	const char *	hostname,
	const char *	path)
d344 1
d352 1
a352 1
     *	Ensure that the domain list exists.
d363 2
a364 2
     *	Look through domain_list to see if the cookie's domain
     *	is already listed.
d382 2
a383 1
					       : DEFAULT_INVCHECK_BV);
d393 3
a395 2
	    CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		   co->path, path));
d407 1
a407 1
	 *  The hostname does not contain a dot.
d417 5
a421 5
	 *  Section 4.3.2, condition 2: The value for the Domain attribute
	 *  contains no embedded dots or does not start with a dot.
	 *  (A dot is embedded if it's neither the first nor last character.)
	 *  Note that we added a lead dot ourselves if a domain attribute
	 *  value otherwise qualified. - FM
d436 2
a437 2
	 *  Section 4.3.2, condition 3: The value for the request-host does
	 *  not domain-match the Domain attribute.
d440 2
a441 1
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
d448 3
a450 3
	 *  Section 4.3.2, condition 4: The request-host is an HDN (not IP
	 *  address) and has the form HD, where D is the value of the Domain
	 *  attribute, and H is a string that contains one or more dots.
d452 3
a454 3
	 *  If cookie checking for this domain is set to INVCHECK_LOOSE,
	 *  then we want to bypass this check.  The user should be queried
	 *  if set to INVCHECK_QUERY.
d459 2
a460 1
						   : DEFAULT_INVCHECK_BV);
d470 3
a472 2
		CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		       co->path, path));
d480 5
a484 5
     *  If we found reasons for issuing an invalid cookie confirmation
     *  prompt, do that now.  Rejection by the user here is the last
     *  chance to completely ignore this cookie; after it passes this
     *  hurdle, it may at least supersede a previous cookie (even if
     *  it finally gets rejected). - kw
d488 1
d495 2
a496 1
		CTRACE((tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
d509 3
a511 2
		CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		       co->path, path));
d528 1
a528 1
	de->invcheck_bv = DEFAULT_INVCHECK_BV; /* should this go here? */
d535 1
a535 1
     *	Loop over the cookie list, deleting expired and matching cookies.
d540 1
a540 1
	c2 = (cookie *)hl->object;
d543 1
a543 1
	 *  Check if this cookie has expired.
d553 3
a555 3
	/*
	 *  Check if this cookie matches the one we're inserting.
	 */
d568 13
a580 14
	     *  This comparison determines the (tentative) position
	     *  of the new cookie in the list such that it comes
	     *  before existing cookies with a less specific path,
	     *  but after existing cookies of equal (or greater)
	     *  path length.  Thus it should normally preserve
	     *  the order of new cookies with the same path as
	     *  they are received, although this is not required.
	     *  From RFC 2109 4.3.4:

   If multiple cookies satisfy the criteria above, they are ordered in
   the Cookie header such that those with more specific Path
   attributes precede those with less specific.  Ordering with respect
   to other attributes (e.g., Domain) is unspecified.

d588 1
a588 1
     *	Don't bother to add the cookie if it's already expired.
d594 3
a596 3
    /*
     *	Don't add the cookie if we're over the domain's limit. - FM
     */
d598 2
a599 1
	CTRACE((tfp, "store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n"));
d603 3
a605 3
    /*
     *	Don't add the cookie if we're over the total cookie limit. - FM
     */
d607 2
a608 1
	CTRACE((tfp, "store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n"));
d612 3
a614 3
    /*
     * Don't add the cookie if the value is NULL. - BJP
     */
d620 1
a620 1
    } else if (co->value == NULL) { /* should not happen - kw */
d625 4
a628 5
    /*
     *	If it's a replacement for a cookie that had not expired,
     *	and never allow has not been set, add it again without
     *	confirmation. - FM
     */
d633 11
a643 11
    /*
     *	Get confirmation if we need it, and add cookie
     *	if confirmed or 'allow' is set to always. - FM
     *
     *  Cookies read from file are accepted without confirmation
     *  prompting.  (Prompting may actually not be possible if
     *  LYLoadCookies is called before curses is setup.)  Maybe
     *  this should instead depend on LYSetCookies and/or
     *  LYCookieAcceptDomains and/or LYCookieRejectDomains and/or
     *  LYAcceptAllCookies and/or some other settings. -kw
     */
d659 9
a667 10
**  Scan a domain's cookie_list for any cookies we should
**  include in a Cookie: request header. - AK & FM
*/
static char * scan_cookie_sublist (
	char *		hostname,
	char *		path,
	int		port,
	HTList *	sublist,
	char *		header,
	BOOL		secure)
d677 1
a677 1
	co = (cookie *)hl->object;
d680 2
a681 3
       if ((co) && /* speed-up host_matches() and limit trace output */
	   (LYstrstr(hostname, co->domain) != NULL))
       {
d683 3
a685 3
			hl,
			(co->name ? co->name : "(no name)"),
			(co->value ? co->value : "(no value)")));
d687 10
a696 10
			hostname,
			(co->domain ? co->domain : "(no domain)"),
			host_matches(hostname, co->domain),
			path, co->path,
			(co->pathlen > 0)
			    ? !is_prefix(co->path, path)
			    : 0,
			(co->flags & COOKIE_FLAG_SECURE)
			    ? " secure"
			    : ""));
d699 1
a699 1
	 *  Check if this cookie has expired, and if so, delete it.
d710 1
a710 1
	 *  Check if we have a unexpired match, and handle if we do.
d716 3
a718 3
	     *	Skip if the secure flag is set and we don't have
	     *	a secure connection.  HTTP.c presently treats only
	     *	SSL connections as secure. - FM
d726 2
a727 2
	     *	Skip if we have a port list and the
	     *	current port is not listed. - FM
d735 1
a735 1
	     *	Start or append to the request header.
d740 2
a741 3
		     *	For Version 1 (or greater) cookies,
		     *	the version number goes before the
		     *	first cookie.
d748 3
a750 3
		 *  There's already cookie data there, so add
		 *  a separator (always use a semi-colon for
		 *  "backward compatibility"). - FM
d754 1
a754 1
		 *  Check if we should fold the header. - FM
d760 6
a765 8
		 *  HTTP/1.0 headers may be folded onto multiple lines
		 *  if each continuation line begins with a space or
		 *  horizontal tab.  All linear whitespace, including
		 *  folding, has the same semantics as SP.
		 *  [...]
		 *  However, folding of header lines is not expected by
		 *  some applications, and should not be generated by
		 *  HTTP/1.0 applications.
d767 1
a767 1
		 * This code was causing problems.  Let's not use it. -BJP
d777 1
a777 1
	     *	Include the cookie name=value pair.
d792 3
a794 4
	     *	For Version 1 (or greater) cookies, add
	     *	$PATH, $PORT and/or $DOMAIN attributes for
	     *	the cookie if they were specified via a
	     *	server reply header. - FM
d799 1
a799 1
		     *	Append the path attribute. - FM
d808 1
a808 1
		     *	Append the port attribute. - FM
d817 1
a817 1
		     *	Append the domain attribute. - FM
d829 1
a829 1
    return(header);
d836 2
a837 3
static char *alloc_attr_value (
	const char *	value_start,
	const char *	value_end)
d848 1
d862 9
a870 10
static unsigned parse_attribute (
	unsigned	flags,
	cookie *	cur_cookie,
	int *		cookie_len,
	const char *	attr_start,
	int		attr_len,
	char *		value,
	const char *	address,
	char *		hostname,
	int		port)
d884 2
a885 2
	     *	If secure has a value, assume someone
	     *	misused it as cookie name. - FM
d897 2
a898 2
	     *	If discard has a value, assume someone
	     *	used it as a cookie name. - FM
d905 3
a907 3
	    /*
	     *	Don't process a repeat comment. - FM
	     */
d915 3
a917 3
	    /*
	     *	Don't process a repeat commentURL. - FM
	     */
d920 2
a921 3
	     *	We should get only absolute URLs as
	     *	values, but will resolve versus the
	     *	request's URL just in case. - FM
d927 1
a927 1
	     *	Accept only URLs for http or https servers. - FM
d934 3
a936 2
		CTRACE((tfp, "LYProcessSetCookies: Rejecting commentURL value '%s'\n",
			    cur_cookie->commentURL));
d943 3
a945 3
	    /*
	     *	Don't process a repeat domain. - FM
	     */
d949 4
a952 6
	     *	If the value does not have a lead dot,
	     *	but does have an embedded dot, and is
	     *	not an exact match to the hostname, nor
	     *	is a numeric IP address, add a lead dot.
	     *	Otherwise, use the value as is. - FM
	     *	(domains - case insensitive).
d957 1
d965 2
a966 2
       "LYProcessSetCookies: Adding lead dot for domain value '%s'\n",
				    value));
d984 3
a986 3
	    /*
	     *	Don't process a repeat path. - FM
	     */
d995 3
a997 3
	    /*
	     *	Don't process a repeat port. - FM
	     */
d1000 1
d1019 1
a1019 1
	     *	Don't process a repeat port. - FM
d1030 3
a1032 3
	    /*
	     *	Don't process a repeat version. - FM
	     */
d1035 1
d1043 3
a1045 3
	    /*
	     *	Don't process a repeat max-age. - FM
	     */
d1048 1
d1051 1
a1051 1
		cur_cookie->expires = (time_t)0;
d1055 2
a1056 2
			    (long) cur_cookie->expires,
			    ctime(&cur_cookie->expires)));
d1062 5
a1066 6
	 *  Convert an 'expires' attribute value if we haven't
	 *  received a 'max-age'.  Note that 'expires' should not
	 *  be used in Version 1 cookies, but it might be used for
	 *  "backward compatibility", and, in turn, ill-informed
	 *  people surely would start using it instead of, rather
	 *  than in addition to, 'max-age'. - FM
d1070 1
a1070 1
	     !(cur_cookie->flags & COOKIE_FLAG_EXPIRES_SET)) {
d1076 2
a1077 2
				(long) cur_cookie->expires,
				ctime(&cur_cookie->expires)));
d1088 9
a1096 10
**  Process potentially concatenated Set-Cookie2 and/or Set-Cookie
**  headers. - FM
*/
static void LYProcessSetCookies (
	const char *	SetCookie,
	const char *	SetCookie2,
	const char *	address,
	char *		hostname,
	char *		path,
	int		port)
d1109 1
a1109 1
	 *  Yuk!  Garbage in, so nothing out. - FM
d1115 7
a1121 8
     *	If we have both Set-Cookie and Set-Cookie2 headers.
     *	process the Set-Cookie2 header.  Otherwise, process
     *	whichever of the two headers we do have.  Note that
     *	if more than one instance of a valued attribute for
     *	the same cookie is encountered, the value for the
     *	first instance is retained.  We only accept up to 50
     *	cookies from the header, and only if a cookie's values
     *	do not exceed the 4096 byte limit on overall size. - FM
d1126 2
a1127 2
     *	Process the Set-Cookie2 header, if present and not zero-length,
     *	adding each cookie to the CombinedCookies list. - FM
d1137 1
a1137 1
	 *  Get the attribute name.
d1147 7
a1153 8
	 *  Check for an '=' delimiter, or an 'expires' name followed
	 *  by white, since Netscape's bogus parser doesn't require
	 *  an '=' delimiter, and 'expires' attributes are being
	 *  encountered without them.  These shouldn't be in a
	 *  Set-Cookie2 header, but we'll assume it's an expires
	 *  attribute rather a cookie with that name, since the
	 *  attribute mistake rather than name mistake seems more
	 *  likely to be made by providers. - FM
d1156 1
a1156 1
	     !strncasecomp(attr_start, "Expires", 7)) {
d1158 1
a1158 1
	     *	Get the value string.
d1165 7
a1171 8
	     *	Hack alert!  We must handle Netscape-style cookies with
	     *		"Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *		"Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     *	No quotes, but there are spaces.  Argh...
	     *	Anyway, we know it will have at least 3 space separators
	     *	within it, and two dashes or two more spaces, so this code
	     *	looks for a space after the 5th space separator or dash to
	     *	mark the end of the value. - FM
d1176 1
d1180 1
a1180 1
		     *	No alphabetic day field. - FM
d1185 1
a1185 1
		     *	Skip the alphabetic day field. - FM
d1206 6
a1211 7
	    /*
	     *	Hack Alert!  The port attribute can take a
	     *	comma separated list of numbers as a value,
	     *	and such values should be quoted, but if
	     *	not, make sure we don't treat a number in
	     *	the list as the start of a new cookie. - FM
	     */
d1216 1
a1216 1
		 *  The value starts as an unquoted number.
d1219 1
d1245 1
a1245 1
		     *	Trim trailing spaces.
d1260 1
d1262 1
a1262 1
		 *  It looks like quoted string.
d1283 1
a1283 1
		 *  Otherwise, it's an unquoted string.
d1290 1
a1290 1
		 *  Trim trailing spaces.
d1305 1
a1305 1
	 *  Check for a separator character, and skip it.
d1311 1
a1311 1
	 *  Now, we can handle this attribute/value pair.
d1316 9
a1324 9
	    parse_flags = parse_attribute (parse_flags,
					   cur_cookie,
					   &cookie_len,
					   attr_start,
					   (attr_end - attr_start),
					   value,
					   address,
					   hostname,
					   port);
d1331 2
a1332 2
	      && value
	      && value_end >= value_start) {
d1334 2
a1335 2
		 *  If we've started a cookie, and it's not too big,
		 *  save it in the CombinedCookies list. - FM
d1338 2
a1339 2
		 && cur_cookie != NULL
		 && !(parse_flags & FLAGS_INVALID_PORT)) {
d1341 1
a1341 1
		     *	Assume version 1 if not set to that or higher. - FM
d1349 5
a1353 5
			"LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
				(cur_cookie->name ?
				 cur_cookie->name : "[no name]"),
				(cur_cookie->value ?
				 cur_cookie->value : "[no value]")));
d1355 3
a1357 3
			   (parse_flags & FLAGS_INVALID_PORT) ?
			   "                     due to excessive length!\n"
			 : "                     due to invalid port!\n"));
d1359 1
a1359 1
			NumCookies --;
d1365 1
a1365 1
		 *  Start a new cookie. - FM
d1387 2
a1388 2
     *	Add any final SetCookie2 cookie to the CombinedCookie list
     *	if we are within the length limit. - FM
d1391 2
a1392 2
     && cookie_len <= max_cookies_buffer
     && cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
d1399 2
a1400 2
		    (cur_cookie->name ? cur_cookie->name : "[no name]"),
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
d1402 6
a1407 6
		    (cookie_len > max_cookies_buffer ? "length" : ""),
		    (cookie_len > max_cookies_buffer &&
		     NumCookies > max_cookies_domain
			? " and "
			: ""),
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1410 1
a1410 1
    } else if (cur_cookie != NULL) {			/* invalidport */
d1412 2
a1413 2
		    (cur_cookie->name ? cur_cookie->name : "[no name]"),
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
d1415 1
a1415 1
	NumCookies --;
d1421 2
a1422 2
     *	Process the Set-Cookie header, if no non-zero-length Set-Cookie2
     *	header was present. - FM
d1435 1
a1435 1
	 *  Get the attribute name.
d1445 3
a1447 4
	 *  Check for an '=' delimiter, or an 'expires' name followed
	 *  by white, since Netscape's bogus parser doesn't require
	 *  an '=' delimiter, and 'expires' attributes are being
	 *  encountered without them. - FM
d1450 1
a1450 1
	     !strncasecomp(attr_start, "Expires", 7)) {
d1452 1
a1452 1
	     *	Get the value string.
d1459 7
a1465 8
	     *	Hack alert!  We must handle Netscape-style cookies with
	     *		"Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *		"Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     *	No quotes, but there are spaces.  Argh...
	     *	Anyway, we know it will have at least 3 space separators
	     *	within it, and two dashes or two more spaces, so this code
	     *	looks for a space after the 5th space separator or dash to
	     *	mark the end of the value. - FM
d1470 1
d1474 1
a1474 1
		     *	No alphabetic day field. - FM
d1479 1
a1479 1
		     *	Skip the alphabetic day field. - FM
d1500 6
a1505 7
	    /*
	     *	Hack Alert!  The port attribute can take a
	     *	comma separated list of numbers as a value,
	     *	and such values should be quoted, but if
	     *	not, make sure we don't treat a number in
	     *	the list as the start of a new cookie. - FM
	     */
d1510 1
a1510 1
		 *  The value starts as an unquoted number.
d1513 1
d1539 1
a1539 1
		     *	Trim trailing spaces.
d1554 1
d1556 1
a1556 1
		 *  It looks like quoted string.
d1577 1
a1577 1
		 *  Otherwise, it's an unquoted string.
d1584 1
a1584 1
		 *  Trim trailing spaces.
d1599 1
a1599 1
	 *  Check for a separator character, and skip it.
d1605 1
a1605 1
	 *  Now, we can handle this attribute/value pair.
d1610 9
a1618 9
	    parse_flags = parse_attribute (parse_flags,
					   cur_cookie,
					   &cookie_len,
					   attr_start,
					   (attr_end - attr_start),
					   value,
					   address,
					   hostname,
					   port);
d1625 2
a1626 2
	      && value
	      && value_end >= value_start) {
d1628 2
a1629 2
		 *  If we've started a cookie, and it's not too big,
		 *  save it in the CombinedCookies list. - FM
d1632 1
a1632 1
		 && cur_cookie != NULL) {
d1634 2
a1635 3
		     *	If we had a Set-Cookie2 header, make sure
		     *	the version is at least 1, and mark it for
		     *	quoting. - FM
d1645 8
a1652 6
		    CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
				(cur_cookie->name ?
				 cur_cookie->name : "[no name]"),
				(cur_cookie->value ?
				 cur_cookie->value : "[no value]")));
		    CTRACE((tfp, "                     due to excessive length!\n"));
d1657 1
a1657 1
		 *  Start a new cookie. - FM
d1680 1
a1680 1
     *	Handle the final Set-Cookie cookie if within length limit. - FM
d1682 3
a1684 1
    if (NumCookies <= max_cookies_domain && cookie_len <= max_cookies_buffer && cur_cookie != NULL) {
d1694 2
a1695 2
		    (cur_cookie->name ? cur_cookie->name : "[no name]"),
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
d1697 5
a1701 3
		    (cookie_len > max_cookies_buffer ? "length" : ""),
		    (cookie_len > max_cookies_buffer && NumCookies > max_cookies_domain ? " and " : ""),
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1707 2
a1708 2
     *	OK, now we can actually store any cookies
     *	in the CombinedCookies list. - FM
d1711 1
a1711 1
    while (NULL != (co = (cookie *)HTList_nextObject(cl))) {
d1713 2
a1714 2
			    (co->name ? co->name : "[no name]"),
			    (co->value ? co->value : "[no value]")));
d1716 3
a1718 3
		CTRACE((tfp, "                    expires: %ld, %s\n",
			    (long)co->expires,
			    ctime(&co->expires)));
d1735 7
a1741 8
**  Entry function for handling Set-Cookie: and/or Set-Cookie2:
**  reply headers.   They may have been concatenated as comma
**  separated lists in HTTP.c or HTMIME.c. - FM
*/
void LYSetCookie (
	const char *	SetCookie,
	const char *	SetCookie2,
	const char *	address)
d1748 3
a1750 3
     *	Get the hostname, port and path of the address, and report
     *	the Set-Cookie and/or Set-Cookie2 header(s) if trace mode is
     *	on, but set the cookie(s) only if LYSetCookies is TRUE. - FM
d1753 1
a1753 1
	(ptr = strchr(hostname, ':')) != NULL)	{
d1755 1
a1755 1
	 *  Replace default port number.
d1764 1
a1764 1
			 PARSE_PATH|PARSE_PUNCTUATION)) != NULL) &&
d1767 1
a1767 1
	    *(ptr+1) = '\0';	/* Leave a single '/' alone */
d1775 2
a1776 3
	 *  Yuk, something must have gone wrong in
	 *  HTMIME.c or HTTP.c because both SetCookie
	 *  and SetCookie2 are NULL or zero-length. - FM
d1781 2
a1782 2
		NonNull(hostname),
		NonNull(path)));
d1794 1
a1794 1
     *	We're done if LYSetCookies is off or we have bad headers. - FM
d1803 1
a1803 1
     *	Process the header(s).
d1812 7
a1818 8
**  Entry function from creating a Cookie: request header
**  if needed. - AK & FM
*/
char * LYAddCookieHeader (
	char *		hostname,
	char *		path,
	int		port,
	BOOL		secure)
d1825 3
a1827 3
		NONNULL(hostname),
		port,
		NONNULL(path)));
d1830 2
a1831 2
     *	Search the cookie_list elements in the domain_list
     *	for any cookies associated with the //hostname:port/path
d1834 1
a1834 1
	de = (domain_entry *)hl->object;
d1860 1
a1860 1
	return(header);
d1862 1
a1862 1
    return(NULL);
d1869 1
a1869 2
void LYLoadCookies (
	char *		cookie_file)
d1875 1
d1889 2
d1910 1
a1910 1
	number_of_file_cookies ++;
d1935 4
a1938 2
		tok_loop, tok_out - buf, tok_out));
	    LYstrncpy(tok_values[tok_loop].s, tok_out, tok_values[tok_loop].n);
d1950 2
a1951 1
	    CTRACE((tfp, "*** wrong format: not enough tokens, ignoring line!\n"));
d1964 4
a1967 4
	    value[1] && value[strlen(value)-1] == '"' &&
	    value[strlen(value)-2] != '\\') {
	    value[strlen(value)-1] = '\0';
	    StrAllocCopy(moo->value, value+1);
d1977 2
a1978 2
	 *			     expiration originally, otherwise
	 *			     it would not be in the file.
d1981 23
a2003 23
	 *			     only matters for sending version 1
	 *			     cookies; the cookies read from the
	 *			     file are currently treated all like
	 *			     version 0 (we don't set moo->version)
	 *			     so $Domain= and $Path= will normally
	 *			     not be sent to the server.  But if
	 *			     these cookies somehow get mixed with
	 *			     new version 1 cookies we may end up
	 *			     sending version 1 to the server, and
	 *			     in that case we should send $Domain
	 *			     and $Path.  The state-man-mec drafts
	 *			     and RFC 2109 say that $Domain and
	 *			     $Path SHOULD be omitted if they were
	 *			     not given explicitly, but not that
	 *			     they MUST be omitted.
	 *			     See 8.2 Cookie Spoofing in draft -10
	 *			     for a good reason to send them.
	 *			     However, an explicit domain should be
	 *			     now prefixed with a dot (unless it is
	 *			     for a single host), so we check for
	 *			     that.
	 *  COOKIE_FLAG_SECURE	     Should have "FALSE" for normal,
	 *			     otherwise set it.
d2006 1
a2006 1
			COOKIE_FLAG_PATH_SET;
d2021 1
a2021 1
    LYCloseInput (cookie_handle);
d2025 1
a2025 2
void LYStoreCookies (
	char *		cookie_file)
d2031 1
a2031 1
    time_t now = time(NULL); /* system specific? - RP */
d2039 1
a2039 1
     *	Check whether we have something to do. - FM
d2051 3
a2053 2
    cookie_handle = LYNewTxtFile (cookie_file);
    if (cookie_handle == NULL) return;
d2058 1
a2058 1
	     *	Fote says the first object is NULL.  Go with that.
d2063 1
a2063 1
	 *  Show the domain's cookies. - FM
d2067 1
a2067 1
	     *	First object is always NULL. - FM
d2069 1
a2069 1
	    if ((co = (cookie *)cl->object) == NULL)
d2073 1
a2073 1
		   (long) now, (long) co->expires));
d2106 21
a2126 22
**	---------------
**
**  Lists all cookies by domain, and allows deletions of
**  individual cookies or entire domains, and changes of
**  'allow' settings.  The list is invoked via the COOKIE_JAR
**  command (Ctrl-K), and deletions or changes of 'allow'
**  settings are done by activating links in that list.
**  The procedure uses a LYNXCOOKIE: internal URL scheme.
**
**  Semantics:
**	LYNXCOOKIE:/			Create and load the Cookie Jar Page.
**	LYNXCOOKIE://domain		Manipulate the domain.
**	LYNXCOOKIE://domain/lynxID	Delete cookie with lynxID in domain.
**
**	New functions can be added as extensions to the path, and/or by
**	assigning meanings to ;parameters, a ?searchpart, and/or #fragments.
*/
static int LYHandleCookies (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d2141 1
a2141 1
     *	Check whether we have something to do. - FM
d2147 1
a2147 1
	return(HT_NO_DATA);
d2151 3
a2153 3
     *	If there's a domain string in the "host" field of the
     *	LYNXCOOKIE: URL, this is a request to delete something
     *	or change and 'allow' setting. - FM
d2160 3
a2162 3
	     *	If there is a path string (not just a slash) in the
	     *	LYNXCOOKIE: URL, that's a cookie's lynxID and this
	     *	is a request to delete it from the Cookie Jar. - FM
d2173 1
a2173 1
	 *  Seek the domain in the domain_list structure. - FM
d2178 1
a2178 2
	     *  We found the domain.  Check
	     *  whether a lynxID is present. - FM
d2182 2
a2183 2
		 *	Seek and delete the cookie with this lynxID
		 *	in the domain's cookie list. - FM
d2186 1
a2186 1
		    if ((co = (cookie *)cl->object) == NULL)
d2188 1
a2188 1
			 *	First object is always empty. - FM
d2193 1
a2193 2
			 *	We found the cookie.
			 *	Delete it if confirmed. - FM
d2195 1
a2195 2
			if (HTConfirm(DELETE_COOKIE_CONFIRMATION) == FALSE)
			{
d2198 1
a2198 1
			    return(HT_NO_DATA);
d2208 4
a2211 4
			     *  No more cookies in this domain, no
			     *  default accept/reject choice was set
			     *  by the user, and got confirmation on
			     *  deleting the domain, so do it. - FM
d2248 1
a2248 1
		    switch(ch) {
d2255 1
a2255 1
			return(HT_NO_DATA);
d2263 1
a2263 1
			return(HT_NO_DATA);
d2280 1
a2280 1
Delete_all_cookies_in_domain:
d2303 1
a2303 1
			    return(HT_NO_DATA);
d2325 1
a2325 1
			return(HT_NO_DATA);
d2336 1
a2336 1
			return(HT_NO_DATA);
d2357 1
a2357 1
	return(HT_NO_DATA);
d2371 1
a2371 1
		HTAtom_name(format_in), HTAtom_name(format_out));
d2374 1
a2374 1
	return(HT_NOT_LOADED);
d2383 3
a2385 3

    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
		 COOKIE_JAR_TITLE);
d2388 3
a2390 3
	LYNX_NAME, LYNX_VERSION,
	HELP_ON_SEGMENT,
	helpfilepath, COOKIE_JAR_HELP, COOKIE_JAR_TITLE);
d2404 1
a2404 1
	     *	First object always is NULL. - FM
d2409 1
a2409 1
	 *  Show the domain link and 'allow' setting. - FM
d2412 1
a2412 1
		      de->domain, STR_LYNXCOOKIE, de->domain, de->domain);
d2430 1
a2430 1
	 *  Show the domain's cookies. - FM
d2433 1
a2433 1
	    if ((co = (cookie *)cl->object) == NULL)
d2435 1
a2435 1
		 *  First object is always NULL. - FM
d2440 1
a2440 1
	     *	Show the name=value pair. - FM
d2455 1
a2455 1
			 STR_LYNXCOOKIE, de->domain, co->lynxID, name, value);
d2461 2
a2462 1
		HTSprintf0(&buf, "%s\n", gettext("(from a previous session)"));
d2467 1
a2467 1
	     *	Show the path, port, secure and discard setting. - FM
d2475 5
a2479 4
	    HTSprintf0(&buf, "<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",
			 path, co->port,
			 ((co->flags & COOKIE_FLAG_SECURE) ? "YES" : "NO"),
			 ((co->flags & COOKIE_FLAG_DISCARD) ? "YES" : "NO"));
d2484 1
a2484 1
	     *	Show the list of acceptable ports, if present. - FM
d2492 1
a2492 1
	     *	Show the commentURL, if we have one. - FM
d2500 3
a2502 3
			"<dd>CommentURL: <a href=\"%s\">%s</a>\n",
			Address,
			Title);
d2509 1
a2509 1
	     *	Show the comment, if we have one. - FM
d2520 1
a2520 1
	     *	Show the Maximum Gobble Date. - FM
d2523 3
a2525 3
			 gettext("Maximum Gobble Date:"),
			 ((co->flags & COOKIE_FLAG_EXPIRES_SET)
					    ?
d2527 3
a2529 3
			 ((co->flags & COOKIE_FLAG_EXPIRES_SET)
					    ?
					 "" : "\n"));
d2539 2
a2540 2
     *	Free the target to complete loading of the
     *	Cookie Jar Page, and report a successful load. - FM
d2542 1
a2542 1
    (*target->isa->_free)(target);
d2544 1
a2544 1
    return(HT_LOADED);
a2546 1

d2548 5
a2552 5
**      ----------------------
**      All purpose function to handle setting domain flags for a
**      comma-delimited list of domains.  cookie_domain_flags handles
**      invcheck behavior, as well as accept/reject behavior. - BJP
*/
d2554 2
a2555 3
static void cookie_domain_flag_set (
	char *		domainstr,
	int		flag)
d2599 1
a2599 1
		    outofmem(__FILE__, "cookie_domain_flag_set");
d2604 19
a2622 13
	    switch(flag) {
	    case (FLAG_ACCEPT_ALWAYS):	de->invcheck_bv = DEFAULT_INVCHECK_BV;
					break;
	    case (FLAG_REJECT_ALWAYS):	de->invcheck_bv = DEFAULT_INVCHECK_BV;
					break;
	    case (FLAG_QUERY_USER):	de->invcheck_bv = DEFAULT_INVCHECK_BV;
					break;
	    case (FLAG_INVCHECK_QUERY): de->bv = QUERY_USER;
					break;
	    case (FLAG_INVCHECK_STRICT): de->bv = QUERY_USER;
					break;
	    case (FLAG_INVCHECK_LOOSE): de->bv = QUERY_USER;
					break;
d2629 19
a2647 13
	switch(flag) {
	case (FLAG_ACCEPT_ALWAYS):	de->bv = ACCEPT_ALWAYS;
					break;
	case (FLAG_REJECT_ALWAYS):	de->bv = REJECT_ALWAYS;
					break;
	case (FLAG_QUERY_USER):		de->bv = QUERY_USER;
					break;
	case (FLAG_INVCHECK_QUERY):	de->invcheck_bv = INVCHECK_QUERY;
					break;
	case (FLAG_INVCHECK_STRICT):    de->invcheck_bv = INVCHECK_STRICT;
					break;
	case (FLAG_INVCHECK_LOOSE):	de->invcheck_bv = INVCHECK_LOOSE;
					break;
d2649 3
a2651 2
	CTRACE((tfp, "cookie_domain_flag_set (%s, bv=%d, invcheck_bv=%d)\n",
		     strsmall, de->bv, de->invcheck_bv));
d2665 1
a2665 1
void LYConfigCookies (void)
d2672 1
d2683 2
d2704 1
a2704 1
GLOBALDEF (HTProtocol,LYLynxCookies,_LYCOOKIE_C_GLOBALDEF_1_INIT);
d2706 2
a2707 1
GLOBALDEF HTProtocol LYLynxCookies = {"LYNXCOOKIE",LYHandleCookies,0};
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d89 3
a91 3
PRIVATE HTList *domain_list = NULL;
PRIVATE HTList *cookie_list = NULL;
PRIVATE int total_cookies = 0;
d123 4
a126 4
PRIVATE void MemAllocCopy ARGS3(
	char **,	dest,
	CONST char *,	start,
	CONST char *,	end)
d143 1
a143 1
PRIVATE cookie * newCookie NOARGS
d154 2
a155 2
PRIVATE void freeCookie ARGS1(
	cookie *,	co)
d171 1
a171 1
PRIVATE void LYCookieJar_free NOARGS
d210 3
a212 3
PRIVATE BOOLEAN host_matches ARGS2(
	CONST char *,	A,
	CONST char *,	B)
d240 3
a242 3
PRIVATE BOOLEAN port_matches ARGS2(
	int,		port,
	CONST char *,	list)
d244 1
a244 1
    CONST char *number = list;
d267 1
a267 1
PRIVATE int ignore_trailing_slash ARGS1(CONST char *, a)
d279 1
a279 1
PRIVATE BOOL is_prefix ARGS2(CONST char *, a, CONST char *, b)
d303 2
a304 2
PRIVATE domain_entry * find_domain_entry ARGS1(
    CONST char *,	name)
d336 4
a339 4
PRIVATE void store_cookie ARGS3(
	cookie *,	co,
	CONST char *,	hostname,
	CONST char *,	path)
d345 1
a345 1
    CONST char *ptr;
d658 7
a664 7
PRIVATE char * scan_cookie_sublist ARGS6(
	char *,		hostname,
	char *,		path,
	int,		port,
	HTList *,	sublist,
	char *,		header,
	BOOL,		secure)
d838 3
a840 3
PRIVATE char *alloc_attr_value ARGS2(
	CONST char *,	value_start,
	CONST char *,	value_end)
d864 10
a873 10
PRIVATE unsigned parse_attribute ARGS9(
	unsigned,	flags,
	cookie *,	cur_cookie,
	int *,		cookie_len,
	CONST char *,	attr_start,
	int,		attr_len,
	char *,		value,
	CONST char *,	address,
	char *,		hostname,
	int,		port)
d1093 7
a1099 7
PRIVATE void LYProcessSetCookies ARGS6(
	CONST char *,	SetCookie,
	CONST char *,	SetCookie2,
	CONST char *,	address,
	char *,		hostname,
	char *,		path,
	int,		port)
d1101 1
a1101 1
    CONST char *p, *attr_start, *attr_end, *value_start, *value_end;
d1224 1
a1224 1
		CONST char *cp, *cp1;
d1518 1
a1518 1
		CONST char *cp, *cp1;
d1738 4
a1741 4
PUBLIC void LYSetCookie ARGS3(
	CONST char *,	SetCookie,
	CONST char *,	SetCookie2,
	CONST char *,	address)
d1816 5
a1820 5
PUBLIC char * LYAddCookieHeader ARGS4(
	char *,		hostname,
	char *,		path,
	int,		port,
	BOOL,		secure)
d1868 1
a1868 1
PRIVATE int number_of_file_cookies = 0;
d1871 2
a1872 2
PUBLIC void LYLoadCookies ARGS1 (
	char *,		cookie_file)
d2022 2
a2023 2
PUBLIC void LYStoreCookies ARGS1 (
	char *,		cookie_file)
d2120 5
a2124 5
PRIVATE int LYHandleCookies ARGS4 (
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d2554 3
a2556 3
PRIVATE void cookie_domain_flag_set ARGS2(
	char *,		domainstr,
	int,		flag)
d2653 1
a2653 1
PUBLIC void LYConfigCookies NOARGS
d2655 1
a2655 1
    static CONST struct {
d2691 1
a2691 1
GLOBALDEF PUBLIC HTProtocol LYLynxCookies = {"LYNXCOOKIE",LYHandleCookies,0};
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d1867 1
a1867 1
#ifdef EXP_PERSISTENT_COOKIES
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d77 3
d135 1
a135 1
    temp = (char *)calloc(1, ((end - start) + 1));
d145 1
a145 1
    cookie *p = (cookie *)calloc(1, sizeof(cookie));
d178 1
d181 1
d246 1
a246 1
    if (!(number && isdigit(*number)))
d253 1
a253 1
	while (isdigit(*number)) {
d256 1
a256 1
	while (*number != '\0' && !isdigit(*number)) {
d265 69
d348 3
d371 2
a372 13
    for (hl = domain_list; hl != NULL; hl = hl->next) {
	de = (domain_entry *)hl->object;
	if ((de != NULL && de->domain != NULL) &&
	    !strcmp(co->domain, de->domain)) {
		cookie_list = de->cookie_list;
		break;
	}
    }

    if(hl == NULL) {
	de = NULL;
	cookie_list = NULL;
    }
d384 16
a399 27
    if (strncmp(co->path, path, co->pathlen) != 0) {
	if((de != NULL && de->invcheck_bv != INVCHECK_LOOSE)
	    || de == NULL) {
		if(de != NULL && de->invcheck_bv == INVCHECK_STRICT) {
		    CTRACE(tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
			co->path, path);
		    freeCookie(co);
		    co = NULL;
		    return;
		} else if ((de != NULL
		    && de->invcheck_bv == INVCHECK_QUERY)
		    || de == NULL) {
			char *msg = 0;
			HTSprintf0(&msg,
			    INVALID_COOKIE_PATH_CONFIRMATION,
			    co->path, path);
			if (!HTConfirm(msg)) {
			    CTRACE(tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
				co->path, path);
			    freeCookie(co);
			    co = NULL;
			    FREE(msg);
			    return;
			} else {
			    FREE(msg);
			}
		}
d402 1
d412 2
a413 2
	    CTRACE(tfp, "store_cookie: Rejecting because '%s' has no dot.\n",
		    hostname);
a414 1
	    co = NULL;
d426 1
a426 2
	    CTRACE(tfp, "store_cookie: Rejecting domain '%s'.\n",
		    co->domain);
a427 1
	    co = NULL;
d432 1
a432 2
	    CTRACE(tfp, "store_cookie: Rejecting domain '%s'.\n",
		    co->domain);
a433 1
	    co = NULL;
d442 2
a443 2
	    CTRACE(tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
		    co->domain, hostname);
a444 1
	    co = NULL;
d459 53
a511 29
		if((de != NULL && de->invcheck_bv != INVCHECK_LOOSE)
		    || de == NULL) {
			if(de != NULL && de->invcheck_bv == INVCHECK_STRICT) {
			    CTRACE(tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
				co->domain,
				hostname);
			    freeCookie(co);
			    co = NULL;
			    return;
			} else if ((de != NULL
			    && de->invcheck_bv == INVCHECK_QUERY)
			    || de == NULL) {
				char *msg = 0;
				HTSprintf0(&msg,
				    INVALID_COOKIE_DOMAIN_CONFIRMATION,
				    co->domain,
				    hostname);
				if (!HTConfirm(msg)) {
				    CTRACE(tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
					co->domain,
					hostname);
				    freeCookie(co);
				    co = NULL;
				    FREE(msg);
				    return;
				}
				FREE(msg);
			}
		}
d513 1
d516 1
a516 1
    if (hl == NULL) {
d518 1
a518 1
	 *	Domain not found; add a new entry for this domain.
d520 1
a520 1
	de = (domain_entry *)calloc(1, sizeof(domain_entry));
d523 2
a524 17
#if 0	/* was: ifdef EXP_PERSISTENT_COOKIES */
	/*
	 * Ok, this is a problem.  The first cookie for a domain
	 * effectively sets the policy for that whole domain - for
	 * something like Netlink, where there are lots of websites
	 * under www.netlink.co.uk, this isn't sensible.  However,
	 * taking this sort of decision down to cookie level also
	 * isn't sensible.  Perhaps something based on the domain
	 * and the path in conjunction makes more sense?  - RP
	 */
	if (persistent_cookies
	 && (co->flags & COOKIE_FLAG_FROM_FILE))
	    de->bv = FROM_FILE;
	else
#endif
	    de->bv = QUERY_USER;
	de->invcheck_bv = INVCHECK_QUERY; /* should this go here? */
d553 1
a553 1
		   !strcmp(co->domain, c2->domain) &&
d595 1
a595 1
	CTRACE(tfp, "store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n");
d603 1
a603 1
	CTRACE(tfp, "store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n");
d610 7
a616 2
    } else if (co->value[0] == '\0') {
	CTRACE(tfp, "store_cookie: Value is NULL! Not storing cookie.\n");
d659 2
a660 2
	CONST char *,	hostname,
	CONST char *,	path,
d663 1
a663 1
	char *, 	header,
d677 4
a680 2
	if (co) {
	    CTRACE(tfp, "Checking cookie %p %s=%s\n",
d683 2
a684 2
			(co->value ? co->value : "(no value)"));
	    CTRACE(tfp, "\t%s %s %d %s %s %d%s\n",
d690 1
a690 1
			    ? strncmp(path, co->path, co->pathlen)
d694 1
a694 1
			    : "");
d712 1
a712 1
	    (co->pathlen == 0 || !strncmp(path, co->path, co->pathlen))) {
d808 1
a808 1
		if (co->PortList && isdigit((unsigned char)*co->PortList)) {
d835 255
d1097 2
a1098 2
	char *, 	hostname,
	char *, 	path,
d1104 1
a1104 1
    int length = 0, url_type = 0;
a1105 1
    BOOL MaxAgeAttrSet = FALSE;
d1107 1
a1107 1
    BOOLEAN invalidport = FALSE;
d1133 1
a1133 1
    p = (SetCookie2 ? SetCookie2 : "");
d1135 1
a1135 1
	CTRACE(tfp, "LYProcessSetCookies: Using Set-Cookie2 header.\n");
d1144 1
a1144 1
	while (*p != '\0' && !isspace((unsigned char)*p) &&
d1183 1
a1183 1
		if (isdigit((unsigned char)*p)) {
d1192 1
a1192 1
		    while (*p != '\0' && isalpha((unsigned char)*p)) {
d1195 1
a1195 1
		    while (*p == ',' || isspace((unsigned char)*p)) {
d1202 2
a1203 2
		    if (isspace((unsigned char)*p)) {
			while (isspace((unsigned char)*(p + 1)))
d1220 1
a1220 1
		       isdigit((unsigned char)*p)) {
d1227 1
a1227 1
		    while (isdigit((unsigned char)*p))
d1235 1
a1235 1
			if (*cp != '\0' && isdigit((unsigned char)*cp)) {
d1237 1
a1237 1
			    while (isdigit((unsigned char)*cp1))
d1253 1
a1253 1
			isspace((unsigned char)*(value_end - 1))) {
d1256 2
a1257 2
			       isspace((unsigned char)*value_end) &&
			       isspace((unsigned char)*(value_end - 1))) {
d1264 1
d1266 1
a1266 1
		 *  It's a quoted string.
d1270 2
a1271 1
		while (*p != '\0' && *p != '"')
d1273 3
a1275 2
		value_end = p;
		if (*p == '"')
d1277 8
d1297 1
a1297 1
		    isspace((unsigned char)*(value_end - 1))) {
d1300 2
a1301 2
			   isspace((unsigned char)*value_end) &&
			   isspace((unsigned char)*(value_end - 1))) {
d1318 1
a1318 220
	    int len = (attr_end - attr_start);
	    BOOLEAN known_attr = NO;
	    char *value = NULL;

	    if (value_end > value_start) {
		int value_len = (value_end - value_start);

		if (value_len > max_cookies_buffer) {
		    value_len = max_cookies_buffer;
		}
		value = (char *)calloc(1, value_len + 1);
		if (value == NULL)
		    outofmem(__FILE__, "LYProcessSetCookies");
		LYstrncpy(value, value_start, value_len);
	    }
	    if (len == 6 && !strncasecomp(attr_start, "secure", 6)) {
		if (value == NULL) {
		    known_attr = YES;
		    if (cur_cookie != NULL) {
			cur_cookie->flags |= COOKIE_FLAG_SECURE;
		    }
		} else {
		    /*
		     *	If secure has a value, assume someone
		     *	misused it as cookie name. - FM
		     */
		    known_attr = NO;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "discard", 7)) {
		if (value == NULL) {
		    known_attr = YES;
		    if (cur_cookie != NULL) {
			cur_cookie->flags |= COOKIE_FLAG_DISCARD;
		    }
		} else {
		    /*
		     *	If discard has a value, assume someone
		     *	used it as a cookie name. - FM
		     */
		    known_attr = NO;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "comment", 7)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat comment. - FM
		     */
		    cur_cookie->comment == NULL) {
		    StrAllocCopy(cur_cookie->comment, value);
		    length += strlen(cur_cookie->comment);
		}
	    } else if (len == 10 && !strncasecomp(attr_start,
						  "commentURL", 10)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat commentURL. - FM
		     */
		    cur_cookie->commentURL == NULL) {
		    /*
		     *	We should get only absolute URLs as
		     *	values, but will resolve versus the
		     *	request's URL just in case. - FM
		     */
		    cur_cookie->commentURL = HTParse(value,
						     address,
						     PARSE_ALL);
		    /*
		     *	Accept only URLs for http or https servers. - FM
		     */
		    if ((url_type = is_url(cur_cookie->commentURL)) &&
			(url_type == HTTP_URL_TYPE ||
			 url_type == HTTPS_URL_TYPE)) {
			length += strlen(cur_cookie->commentURL);
		    } else {
			CTRACE(tfp, "LYProcessSetCookies: Rejecting commentURL value '%s'\n",
				    cur_cookie->commentURL);
			FREE(cur_cookie->commentURL);
		    }
		}
	    } else if (len == 6 && !strncasecomp(attr_start, "domain", 6)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat domain. - FM
		     */
		    !(cur_cookie->flags & COOKIE_FLAG_DOMAIN_SET)) {
		    length -= strlen(cur_cookie->domain);
		    /*
		     *	If the value does not have a lead dot,
		     *	but does have an embedded dot, and is
		     *	not an exact match to the hostname, nor
		     *	is a numeric IP address, add a lead dot.
		     *	Otherwise, use the value as is. - FM
		     *	(domains - case insensitive).
		     */
		    if (value[0] != '.' && value[0] != '\0' &&
			value[1] != '\0' && strcasecomp(value, hostname)) {
			char *ptr = strchr(value, '.');
			if (ptr != NULL && ptr[1] != '\0') {
			    ptr = value;
			    while (*ptr == '.' ||
				   isdigit((unsigned char)*ptr))
				ptr++;
			    if (*ptr != '\0') {
				CTRACE(tfp,
	       "LYProcessSetCookies: Adding lead dot for domain value '%s'\n",
					    value);
				StrAllocCopy(cur_cookie->domain, ".");
				StrAllocCat(cur_cookie->domain, value);
			    } else {
				StrAllocCopy(cur_cookie->domain, value);
			    }
			} else {
			    StrAllocCopy(cur_cookie->domain, value);
			}
		    } else {
			StrAllocCopy(cur_cookie->domain, value);
		    }
		    length += strlen(cur_cookie->domain);
		    cur_cookie->flags |= COOKIE_FLAG_DOMAIN_SET;
		}
	    } else if (len == 4 && !strncasecomp(attr_start, "path", 4)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat path. - FM
		     */
		    !(cur_cookie->flags & COOKIE_FLAG_PATH_SET)) {
		    length -= strlen(cur_cookie->path);
		    StrAllocCopy(cur_cookie->path, value);
		    length += (cur_cookie->pathlen = strlen(cur_cookie->path));
		    cur_cookie->flags |= COOKIE_FLAG_PATH_SET;
		}
	    } else if (len == 4 && !strncasecomp(attr_start, "port", 4)) {
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat port. - FM
		     */
		    cur_cookie->PortList == NULL) {
		    char *cp = value;
		    while ((*cp != '\0') &&
			   (isdigit((unsigned char)*cp) ||
			    *cp == ',' || *cp == ' ')) {
			cp++;
		    }
		    if (*cp == '\0' && !port_matches(port, value)) {
			invalidport = TRUE;
			known_attr = YES;
		    } else if (*cp == '\0') {
			StrAllocCopy(cur_cookie->PortList, value);
			length += strlen(cur_cookie->PortList);
			known_attr = YES;
		    } else {
			known_attr = NO;
		    }
		} else if (cur_cookie != NULL) {
		    /*
		     *	Don't process a repeat port. - FM
		     */
		    if (cur_cookie->PortList == NULL) {
			HTSprintf0(&(cur_cookie->PortList), "%d", port);
			length += strlen(cur_cookie->PortList);
		    }
		    known_attr = YES;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "version", 7)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat version. - FM
		     */
		    cur_cookie->version < 1) {
		    int temp = strtol(value, NULL, 10);
		    if (errno != -ERANGE) {
			cur_cookie->version = temp;
		    }
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "max-age", 7)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat max-age. - FM
		     */
		    !MaxAgeAttrSet) {
		    int temp = strtol(value, NULL, 10);
		    cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
		    if (errno == -ERANGE) {
			cur_cookie->expires = (time_t)0;
		    } else {
			cur_cookie->expires = (time(NULL) + temp);
			CTRACE(tfp, "LYSetCookie: expires %ld, %s",
				    (long) cur_cookie->expires,
				    ctime(&cur_cookie->expires));
		    }
		    MaxAgeAttrSet = TRUE;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "expires", 7)) {
		/*
		 *  Convert an 'expires' attribute value if we haven't
		 *  received a 'max-age'.  Note that 'expires' should not
		 *  be used in Version 1 cookies, but it might be used for
		 *  "backward compatibility", and, in turn, ill-informed
		 *  people surely would start using it instead of, rather
		 *  than in addition to, 'max-age'. - FM
		 */
		known_attr = YES;
		if ((cur_cookie != NULL && !MaxAgeAttrSet) &&
		     !(cur_cookie->flags & COOKIE_FLAG_EXPIRES_SET)) {
		    if (value) {
			cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
			cur_cookie->expires = LYmktime(value, FALSE);
			if (cur_cookie->expires > 0) {
			    CTRACE(tfp, "LYSetCookie: expires %ld, %s",
					(long) cur_cookie->expires,
					ctime(&cur_cookie->expires));
			}
		    }
		}
	    }
d1320 17
a1336 16
	    /*
	     *	If none of the above comparisons succeeded, and we have
	     *	a value, then we have an unknown pair of the form 'foo=bar',
	     *	which means it's time to create a new cookie.  If we don't
	     *	have a non-zero-length value, assume it's an error or a
	     *	new, unknown attribute which doesn't take a value, and
	     *	ignore it. - FM
	     */
	    /* if (!known_attr && value_end > value_start) */

	    /* Is there any reason we don't want to accept cookies with
	     * no value?  This seems to be needed for sites that reset a
	     * cookie by nulling out the value.  If this causes problems,
	     * we can go back to the original behavior above.  - BJP
	     */
	    if (!known_attr) {
d1341 3
a1343 2
		if (length <= max_cookies_buffer && cur_cookie != NULL &&
		    !invalidport) {
d1352 1
a1352 1
		    CTRACE(tfp,
d1357 3
a1359 3
				 cur_cookie->value : "[no value]"));
		    CTRACE(tfp,
			   invalidport ?
d1361 2
a1362 2
			 : "                     due to invalid port!\n");
		    if (invalidport) {
d1372 1
a1372 2
		invalidport = FALSE;
		length = 0;
d1375 1
a1375 1
		length += strlen(cur_cookie->name);
d1377 1
a1377 1
		length += strlen(cur_cookie->value);
d1379 1
a1379 1
		length += strlen(cur_cookie->domain);
d1381 1
a1381 1
		length += (cur_cookie->pathlen = strlen(cur_cookie->path));
d1383 1
a1383 1
		MaxAgeAttrSet = FALSE;
d1395 2
a1396 2
     && length <= max_cookies_buffer
     && cur_cookie != NULL && !invalidport) {
d1401 2
a1402 2
    } else if (cur_cookie != NULL && !invalidport) {
	CTRACE(tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
d1404 4
a1407 4
		    (cur_cookie->value ? cur_cookie->value : "[no value]"));
	CTRACE(tfp, "                     due to excessive %s%s%s\n",
		    (length > max_cookies_buffer ? "length" : ""),
		    (length > max_cookies_buffer &&
d1411 1
a1411 1
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n"));
d1415 1
a1415 1
	CTRACE(tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
d1417 2
a1418 2
		    (cur_cookie->value ? cur_cookie->value : "[no value]"));
	CTRACE(tfp, "                     due to invalid port!\n");
d1428 1
a1428 1
    length = 0;
d1433 1
a1433 1
	CTRACE(tfp, "LYProcessSetCookies: Using Set-Cookie header.\n");
d1442 1
a1442 1
	while (*p != '\0' && !isspace((unsigned char)*p) &&
d1477 1
a1477 1
		if (isdigit((unsigned char)*p)) {
d1486 1
a1486 1
		    while (*p != '\0' && isalpha((unsigned char)*p)) {
d1489 1
a1489 1
		    while (*p == ',' || isspace((unsigned char)*p)) {
d1496 2
a1497 2
		    if (isspace((unsigned char)*p)) {
			while (isspace((unsigned char)*(p + 1)))
d1514 1
a1514 1
		       isdigit((unsigned char)*p)) {
d1521 1
a1521 1
		    while (isdigit((unsigned char)*p))
d1529 1
a1529 1
			if (*cp != '\0' && isdigit((unsigned char)*cp)) {
d1531 1
a1531 1
			    while (isdigit((unsigned char)*cp1))
d1547 1
a1547 1
			isspace((unsigned char)*(value_end - 1))) {
d1550 2
a1551 2
			       isspace((unsigned char)*value_end) &&
			       isspace((unsigned char)*(value_end - 1))) {
d1558 1
d1560 1
a1560 1
		 *  It's a quoted string.
d1564 2
a1565 1
		while (*p != '\0' && *p != '"')
d1567 3
a1569 2
		value_end = p;
		if (*p == '"')
d1571 8
a1578 1
		Quoted = TRUE;
d1591 1
a1591 1
		    isspace((unsigned char)*(value_end - 1))) {
d1594 2
a1595 2
			   isspace((unsigned char)*value_end) &&
			   isspace((unsigned char)*(value_end - 1))) {
d1612 1
a1612 205
	    int len = (attr_end - attr_start);
	    BOOLEAN known_attr = NO;
	    char *value = NULL;

	    if (value_end > value_start) {
		int value_len = (value_end - value_start);

		if (value_len > max_cookies_buffer) {
		    value_len = max_cookies_buffer;
		}
		value = (char *)calloc(1, value_len + 1);
		if (value == NULL)
		    outofmem(__FILE__, "LYProcessSetCookie");
		LYstrncpy(value, value_start, value_len);
	    }
	    if (len == 6 && !strncasecomp(attr_start, "secure", 6)) {
		if (value == NULL) {
		    known_attr = YES;
		    if (cur_cookie != NULL) {
			cur_cookie->flags |= COOKIE_FLAG_SECURE;
		    }
		} else {
		    /*
		     *	If secure has a value, assume someone
		     *	misused it as cookie name. - FM
		     */
		    known_attr = NO;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "discard", 7)) {
		if (value == NULL) {
		    known_attr = YES;
		    if (cur_cookie != NULL) {
			cur_cookie->flags |= COOKIE_FLAG_DISCARD;
		    }
		} else {
		    /*
		     *	If discard has a value, assume someone
		     *	used it as a cookie name. - FM
		     */
		    known_attr = NO;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "comment", 7)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat comment. - FM
		     */
		    cur_cookie->comment == NULL) {
		    StrAllocCopy(cur_cookie->comment, value);
		    length += strlen(cur_cookie->comment);
		}
	    } else if (len == 10 && !strncasecomp(attr_start,
						  "commentURL", 10)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat commentURL. - FM
		     */
		    cur_cookie->commentURL == NULL) {
		    /*
		     *	We should get only absolute URLs as
		     *	values, but will resolve versus the
		     *	request's URL just in case. - FM
		     */
		    cur_cookie->commentURL = HTParse(value,
						     address,
						     PARSE_ALL);
		    /*
		     *	Accept only URLs for http or https servers. - FM
		     */
		    if ((url_type = is_url(cur_cookie->commentURL)) &&
			(url_type == HTTP_URL_TYPE ||
			 url_type == HTTPS_URL_TYPE)) {
			length += strlen(cur_cookie->commentURL);
		    } else {
			CTRACE(tfp, "LYProcessSetCookies: Rejecting commentURL value '%s'\n",
				    cur_cookie->commentURL);
			FREE(cur_cookie->commentURL);
		    }
		}
	    } else if (len == 6 && !strncasecomp(attr_start, "domain", 6)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat domain. - FM
		     */
		    !(cur_cookie->flags & COOKIE_FLAG_DOMAIN_SET)) {
		    length -= strlen(cur_cookie->domain);
		    /*
		     *	If the value does not have a lead dot,
		     *	but does have an embedded dot, and is
		     *	not an exact match to the hostname, nor
		     *	is a numeric IP address, add a lead dot.
		     *	Otherwise, use the value as is. - FM
		     *	(domains - case insensitive).
		     */
		    if (value[0] != '.' && value[0] != '\0' &&
			value[1] != '\0' && strcasecomp(value, hostname)) {
			char *ptr = strchr(value, '.');
			if (ptr != NULL && ptr[1] != '\0') {
			    ptr = value;
			    while (*ptr == '.' ||
				   isdigit((unsigned char)*ptr))
				ptr++;
			    if (*ptr != '\0') {
				CTRACE(tfp,
	       "LYProcessSetCookies: Adding lead dot for domain value '%s'\n",
					    value);
				StrAllocCopy(cur_cookie->domain, ".");
				StrAllocCat(cur_cookie->domain, value);
			    } else {
				StrAllocCopy(cur_cookie->domain, value);
			    }
			} else {
			    StrAllocCopy(cur_cookie->domain, value);
			}
		    } else {
			StrAllocCopy(cur_cookie->domain, value);
		    }
		    length += strlen(cur_cookie->domain);
		    cur_cookie->flags |= COOKIE_FLAG_DOMAIN_SET;
		}
	    } else if (len == 4 && !strncasecomp(attr_start, "path", 4)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat path. - FM
		     */
		    !(cur_cookie->flags & COOKIE_FLAG_PATH_SET)) {
		    length -= strlen(cur_cookie->path);
		    StrAllocCopy(cur_cookie->path, value);
		    length += (cur_cookie->pathlen = strlen(cur_cookie->path));
		    cur_cookie->flags |= COOKIE_FLAG_PATH_SET;
		}
	    } else if (len == 4 && !strncasecomp(attr_start, "port", 4)) {
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat port. - FM
		     */
		    cur_cookie->PortList == NULL) {
		    char *cp = value;
		    while ((*cp != '\0') &&
			   (isdigit((unsigned char)*cp) ||
			    *cp == ',' || *cp == ' ')) {
			cp++;
		    }
		    if (*cp == '\0' && port_matches(port, value)) {
			StrAllocCopy(cur_cookie->PortList, value);
			length += strlen(cur_cookie->PortList);
			known_attr = YES;
		    } else {
			known_attr = NO;
		    }
		} else if (cur_cookie != NULL) {
		    /*
		     *	Don't process a repeat port. - FM
		     */
		    if (cur_cookie->PortList == NULL) {
			HTSprintf0(&(cur_cookie->PortList), "%d", port);
			length += strlen(cur_cookie->PortList);
		    }
		    known_attr = YES;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "version", 7)) {
		known_attr = YES;
		if (cur_cookie != NULL && value &&
		    /*
		     *	Don't process a repeat version. - FM
		     */
		    cur_cookie->version < 1) {
		    int temp = strtol(value, NULL, 10);
		    if (errno != -ERANGE) {
			cur_cookie->version = temp;
		    }
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "max-age", 7)) {
		known_attr = YES;
		if ((cur_cookie != NULL) && !MaxAgeAttrSet && value) {
		    int temp = strtol(value, NULL, 10);
		    cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
		    if (errno == -ERANGE) {
			cur_cookie->expires = (time_t)0;
		    } else {
			cur_cookie->expires = (time(NULL) + temp);
		    }
		    MaxAgeAttrSet = TRUE;
		}
	    } else if (len == 7 && !strncasecomp(attr_start, "expires", 7)) {
		/*
		 *  Convert an 'expires' attribute value if we haven't
		 *  received a 'max-age'.  Note that 'expires' should not
		 *  be used in Version 1 cookies, but it might be used for
		 *  "backward compatibility", and, in turn, ill-informed
		 *  people surely would start using it instead of, rather
		 *  than in addition to, 'max-age'. - FM
		 */
		known_attr = YES;
		if ((cur_cookie != NULL) && !(MaxAgeAttrSet) &&
		    !(cur_cookie->flags & COOKIE_FLAG_EXPIRES_SET)) {
		    if (value) {
			cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
			cur_cookie->expires = LYmktime(value, FALSE);
		    }
		}
	    }
d1614 17
a1630 16
	    /*
	     *	If none of the above comparisons succeeded, and we have
	     *	a value, then we have an unknown pair of the form 'foo=bar',
	     *	which means it's time to create a new cookie.  If we don't
	     *	have a non-zero-length value, assume it's an error or a
	     *	new, unknown attribute which doesn't take a value, and
	     *	ignore it. - FM
	     */
	    /* if (!known_attr && value_end > value_start) */

	    /* Is there any reason we don't want to accept cookies with
	     * no value?  This seems to be needed for sites that reset a
	     * cookie by nulling out the value.  If this causes problems,
	     * we can go back to the original behavior above.  - BJP
	     */
	    if (!known_attr) {
d1635 2
a1636 1
		if (length <= max_cookies_buffer && cur_cookie != NULL) {
d1650 1
a1650 1
		    CTRACE(tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
d1654 2
a1655 2
				 cur_cookie->value : "[no value]"));
		    CTRACE(tfp, "                     due to excessive length!\n");
d1663 2
a1664 1
		length = 0;
d1666 1
a1666 1
		length += strlen(cur_cookie->name);
d1668 1
a1668 1
		length += strlen(cur_cookie->value);
d1670 1
a1670 1
		length += strlen(cur_cookie->domain);
d1672 1
a1672 1
		length += (cur_cookie->pathlen = strlen(cur_cookie->path));
d1674 1
a1674 1
		MaxAgeAttrSet = FALSE;
d1685 1
a1685 1
    if (NumCookies <= max_cookies_domain && length <= max_cookies_buffer && cur_cookie != NULL) {
d1694 1
a1694 1
	CTRACE(tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
d1696 5
a1700 5
		    (cur_cookie->value ? cur_cookie->value : "[no value]"));
	CTRACE(tfp, "                     due to excessive %s%s%s\n",
		    (length > max_cookies_buffer ? "length" : ""),
		    (length > max_cookies_buffer && NumCookies > max_cookies_domain ? " and " : ""),
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n"));
d1711 1
a1711 1
	CTRACE(tfp, "LYProcessSetCookie: attr=value pair: '%s=%s'\n",
d1713 1
a1713 1
			    (co->value ? co->value : "[no value]"));
d1715 1
a1715 1
		CTRACE(tfp, "                    expires: %ld, %s\n",
d1717 1
a1717 1
			    ctime(&co->expires));
d1719 1
a1719 1
	if (!strncasecomp(address, "https:", 6) &&
d1723 1
a1723 1
	    CTRACE(tfp, "                    Forced the 'secure' flag on.\n");
d1760 1
a1760 1
    } else if (!strncasecomp(address, "https:", 6)) {
d1781 3
a1783 3
    CTRACE(tfp, "LYSetCookie called with host '%s', path '%s',\n",
		(hostname ? hostname : ""),
		(path ? path : ""));
d1785 1
a1785 2
	CTRACE(tfp, "    and Set-Cookie: '%s'\n",
			 (SetCookie ? SetCookie : ""));
d1788 1
a1788 2
	CTRACE(tfp, "    and Set-Cookie2: '%s'\n",
			 (SetCookie2 ? SetCookie2 : ""));
d1791 1
a1791 1
	CTRACE(tfp, "    Ignoring this Set-Cookie/Set-Cookie2 request.\n");
d1816 3
a1818 3
PUBLIC char * LYCookie ARGS4(
	CONST char *,	hostname,
	CONST char *,	path,
d1826 2
a1827 2
    CTRACE(tfp, "LYCookie: Searching for '%s:%d', '%s'.\n",
		(hostname ? hostname : "(null)"),
d1829 1
a1829 1
		(path ? path : "(null)"));
d1842 2
a1843 3
		 *  Scan the domain's cookie_list for
		 *  any cookies we should include in
		 *  our request header.
d1847 1
a1847 1
	    } else if (de->bv == QUERY_USER && de->invcheck_bv == INVCHECK_QUERY) {
d1849 2
a1850 3
		 *  No cookies in this domain, and no default
		 *  accept/reject choice was set by the user,
		 *  so delete the domain. - FM
d1893 1
a1893 1
    cookie_handle = fopen(cookie_file, "r+");
d1897 1
a1897 1
    CTRACE(tfp, "LYLoadCookies: reading cookies from %s\n", cookie_file);
a1901 1
	unsigned i = 0;
d1905 2
a1906 1
	if ((buf[0] == '\0' || buf[0] == '\n' || buf[0] == '#')) {
d1912 1
a1912 9
	/*
	 * Strip out the newline that fgets() puts at the end of a
	 * cookie.
	 */

	while(buf[i] != '\n' && buf[i] != 0) {
	    i++;
	}
	buf[i] = '\0';
d1924 7
a1930 1
	CTRACE(tfp, "LYLoadCookies: tokenising %s\n", buf);
d1934 2
a1935 2
	    CTRACE(tfp, "\t%d:%p:%p:[%s]\n",
		tok_loop, tok_values[tok_loop].s, tok_out, tok_out);
a1944 1
	expires = atol(expires_a);
d1946 5
a1950 6
	/*
	 * This fails when the path is blank
	 *
	 * sscanf(buf, "%s\t%s\t%s\t%s\t%d\t%s\t%[ -~]",
	 *  domain, what, path, secure, &expires, name, value);
	 */
d1952 4
a1955 3
	CTRACE(tfp, "expires:\t%s\n", ctime(&expires));
/* 	CTRACE(tfp, "%s\t%s\t%s\t%s\t%ld\t%s\t%s\tREADCOOKIE\n", */
/* 	    domain, what, path, secure, (long) expires, name, value); */
d1960 9
a1968 1
	StrAllocCopy(moo->value, value);
d2003 1
a2003 1
	    		COOKIE_FLAG_PATH_SET;
d2018 1
a2018 1
    fclose (cookie_handle);
a2024 3
#if 0
    char *buf = NULL;
#endif
d2031 5
d2047 1
a2047 1
    CTRACE(tfp, "LYStoreCookies: save cookies to %s on exit\n", cookie_file);
a2058 18
#if 0
	switch (de->bv) {
	case (ACCEPT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_ALWAYS_ALLOWED);
	    break;
	case (REJECT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_NEVER_ALLOWED);
	    break;
	case (QUERY_USER):
	    HTSprintf0(&buf, COOKIES_ALLOWED_VIA_PROMPT);
	    break;
	case (FROM_FILE):	/* not used any more - kw */
	    HTSprintf0(&buf, gettext("(From Cookie Jar)"));
	    break;
	}
	/* FIXME: buf unused */
#endif

d2069 2
a2070 1
	    CTRACE(tfp, "LYStoreCookies: %ld cf %ld ", (long) now, (long) co->expires);
d2073 1
a2073 1
		CTRACE(tfp, "not stored - DISCARD\n");
d2076 1
a2076 1
		CTRACE(tfp, "not stored - no expiration time\n");
d2079 1
a2079 1
		CTRACE(tfp, "not stored - EXPIRED\n");
d2083 9
a2091 5
	    fprintf(cookie_handle, "%s\t%s\t%s\t%s\t%ld\t%s\t%s\n",
		de->domain,
		"FALSE", co->path,
		co->flags & COOKIE_FLAG_SECURE ? "TRUE" : "FALSE",
		(long) co->expires, co->name, co->value);
d2093 1
a2093 1
	    CTRACE(tfp, "STORED\n");
d2096 1
a2096 1
    fclose(cookie_handle);
d2143 2
a2144 1
	sleep(MessageSecs);
d2173 7
a2179 3
	for (dl = domain_list; dl != NULL; dl = dl->next) {
	    de = dl->object;
	    if (!(de && de->domain))
d2181 2
a2182 1
		 *  First object in the list always is empty. - FM
d2184 24
a2207 14
		continue;
	    if (!strcmp(domain, de->domain)) {
		FREE(domain);
		/*
		 *  We found the domain.  Check
		 *  whether a lynxID is present. - FM
		 */
		if (lynxID) {
		    /*
		     *	Seek and delete the cookie with this lynxID
		     *	in the domain's cookie list. - FM
		     */
		    for (cl = de->cookie_list; cl != NULL; cl = cl->next) {
			if ((co = (cookie *)cl->object) == NULL)
d2209 4
a2212 1
			     *	First object is always empty. - FM
d2214 8
a2221 35
			    continue;
			if (!strcmp(lynxID, co->lynxID)) {
			    /*
			     *	We found the cookie.
			     *	Delete it if confirmed. - FM
			     */
			    if (HTConfirm(DELETE_COOKIE_CONFIRMATION) == FALSE)
			    {
				FREE(lynxID);
				return(HT_NO_DATA);
			    }
			    HTList_removeObject(de->cookie_list, co);
			    freeCookie(co);
			    co = NULL;
			    total_cookies--;
			    if ((de->bv == QUERY_USER &&
				 HTList_isEmpty(de->cookie_list)) &&
				HTConfirm(DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
				/*
				 *  No more cookies in this domain, no
				 *  default accept/reject choice was set
				 *  by the user, and got confirmation on
				 *  deleting the domain, so do it. - FM
				 */
				FREE(de->domain);
				HTList_delete(de->cookie_list);
				de->cookie_list = NULL;
				HTList_removeObject(domain_list, de);
				FREE(de);
				HTProgress(DOMAIN_EATEN);
			    } else {
				HTProgress(COOKIE_EATEN);
			    }
			    sleep(MessageSecs);
			    break;
d2223 3
d2227 10
d2238 9
a2246 10
		    /*
		     *	Prompt whether to delete all of the cookies in
		     *	this domain, or the domain if no cookies in it,
		     *	or to change its 'allow' setting, or to cancel,
		     *	and then act on the user's response. - FM
		     */
		    if (HTList_isEmpty(de->cookie_list)) {
			_statusline(DELETE_DOMAIN_SET_ALLOW_OR_CANCEL);
		    } else {
			_statusline(DELETE_COOKIES_SET_ALLOW_OR_CANCEL);
d2248 32
a2279 6
		    while (1) {
			ch = LYgetch();
#ifdef VMS
			if (HadVMSInterrupt) {
			    HadVMSInterrupt = FALSE;
			    ch = 'C';
a2280 36
#endif /* VMS */
			switch(TOUPPER(ch)) {
			    case 'A':
				/*
				 *  Set to accept all cookies
				 *  from this domain. - FM
				 */
				de->bv = ACCEPT_ALWAYS;
				HTUserMsg2(ALWAYS_ALLOWING_COOKIES,
					      de->domain);
				return(HT_NO_DATA);

			    case 'C':
			    case 7:	/* Ctrl-G */
			    case 3:	/* Ctrl-C */
				/*
				 *  Cancelled. - FM
				 */
				HTUserMsg(CANCELLED);
				return(HT_NO_DATA);

			    case 'D':
				if (HTList_isEmpty(de->cookie_list)) {
				    /*
				     *	We had an empty domain, so we
				     *	were asked to delete it. - FM
				     */
				    FREE(de->domain);
				    HTList_delete(de->cookie_list);
				    de->cookie_list = NULL;
				    HTList_removeObject(domain_list, de);
				    FREE(de);
				    HTProgress(DOMAIN_EATEN);
				    sleep(MessageSecs);
				    break;
				}
d2282 34
a2315 65
				/*
				 *  Delete all cookies in this domain. - FM
				 */
				cl = de->cookie_list;
				while (cl) {
				    next = cl->next;
				    co = cl->object;
				    if (co) {
					HTList_removeObject(de->cookie_list,
							    co);
					freeCookie(co);
					co = NULL;
					total_cookies--;
				    }
				    cl = next;
				}
				HTProgress(DOMAIN_COOKIES_EATEN);
				sleep(MessageSecs);
				/*
				 *  If a default accept/reject
				 *  choice is set, we're done. - FM
				 */
				if (de->bv != QUERY_USER)
				    return(HT_NO_DATA);
				/*
				 *  Check whether to delete
				 *  the empty domain. - FM
				 */
				if(HTConfirm(
					DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
				    FREE(de->domain);
				    HTList_delete(de->cookie_list);
				    de->cookie_list = NULL;
				    HTList_removeObject(domain_list, de);
				    FREE(de);
				    HTProgress(DOMAIN_EATEN);
				    sleep(MessageSecs);
				}
				break;

			    case 'P':
				/*
				 *  Set to prompt for cookie acceptance
				 *  from this domain. - FM
				 */
				de->bv = QUERY_USER;
				HTUserMsg2(PROMPTING_TO_ALLOW_COOKIES,
					   de->domain);
				return(HT_NO_DATA);

			    case 'V':
				/*
				 *  Set to reject all cookies
				 *  from this domain. - FM
				 */
				de->bv = REJECT_ALWAYS;
				HTUserMsg2(NEVER_ALLOWING_COOKIES,
					   de->domain);
				if ((!HTList_isEmpty(de->cookie_list)) &&
				    HTConfirm(DELETE_ALL_COOKIES_IN_DOMAIN))
				    goto Delete_all_cookies_in_domain;
				return(HT_NO_DATA);

			    default:
				continue;
d2318 25
d2344 1
a2345 1
		break;
d2350 2
a2351 3
	     *	There are no more domains left.
	     *	Don't delete the domain_list, otherwise
	     *  atexit may be called multiple times. - kw
d2354 1
a2354 1
	    sleep(MessageSecs);
d2362 4
a2365 5
     *	If we get to here, it was a LYNXCOOKIE:/ URL
     *	for creating and displaying the Cookie Jar Page,
     *	or we didn't find the domain or cookie in a
     *	deletion request.  Set up an HTML stream and
     *	return an updated Cookie Jar Page. - FM
d2379 2
a2380 2
     *	Load HTML strings into buf and pass buf
     *	to the target for parsing and rendering. - FM
d2385 1
a2385 1
    HTSprintf0(&buf, "<HEAD>\n<TITLE>%s</title>\n</HEAD>\n<BODY>\n",
d2394 1
a2394 1
    HTSprintf0(&buf, "<NOTE>%s\n", ACTIVATE_TO_GOBBLE);
d2396 1
a2396 1
    HTSprintf0(&buf, "%s</NOTE>\n", OR_CHANGE_ALLOW);
d2399 1
a2399 1
    HTSprintf0(&buf, "<DL COMPACT>\n");
d2412 2
a2413 2
	HTSprintf0(&buf, "<DT>%s<DD><A HREF=\"LYNXCOOKIE://%s/\">Domain=%s</A>\n",
		      de->domain, de->domain, de->domain);
d2416 9
a2424 14
	    case (ACCEPT_ALWAYS):
		HTSprintf0(&buf, COOKIES_ALWAYS_ALLOWED);
		break;
	    case (REJECT_ALWAYS):
		HTSprintf0(&buf, COOKIES_NEVER_ALLOWED);
		break;
	    case (QUERY_USER):
		HTSprintf0(&buf, COOKIES_ALLOWED_VIA_PROMPT);
		break;
	    case (FROM_FILE):
#if 0 /* not used any more - kw */
		HTSprintf0(&buf, COOKIES_READ_FROM_FILE);
#endif
		break;
d2455 2
a2456 2
	    HTSprintf0(&buf, "<DD><A HREF=\"LYNXCOOKIE://%s/%s\">%s=%s</A>\n",
			 de->domain, co->lynxID, name, value);
d2463 1
a2463 1
	        PUTS(buf);
d2475 1
a2475 1
	    HTSprintf0(&buf, "<DD>Path=%s\n<DD>Port: %d Secure: %s Discard: %s\n",
d2486 1
a2486 1
		HTSprintf0(&buf, "<DD>PortList=\"%s\"\n", co->PortList);
d2499 1
a2499 1
			"<DD>CommentURL: <A href=\"%s\">%s</A>\n",
d2513 1
a2513 1
		HTSprintf0(&buf, "<DD>Comment: %s\n", comment);
d2521 2
a2522 2
	    HTSprintf0(&buf, "<DD><EM>%s</EM> %s%s",
	    		 gettext("Maximum Gobble Date:"),
d2531 1
a2531 1
	HTSprintf0(&buf, "</DT>\n");
d2534 1
a2534 1
    HTSprintf0(&buf, "</DL>\n</BODY>\n");
d2554 3
a2556 3
PUBLIC void cookie_domain_flag_set ARGS2(
	char *, 	domainstr,
	int, 	flag)
d2559 1
a2559 3
    domain_entry *de2 = NULL;
    HTList *hl = NULL;
    char **str = (char **)calloc(1, sizeof(domainstr));
a2561 1
    int isexisting = FALSE;
d2563 5
a2567 2
    if (str == NULL)
	outofmem(__FILE__, "cookie_set_invcheck");
d2570 1
a2570 2
     * Is this the first domain we're handling?  If so, initialize
     * domain_list.
a2571 1

d2586 5
d2593 1
a2593 1
	 * re-setting of an already existing domains -- if so, just
d2597 2
a2598 14
	for (hl = domain_list; hl != NULL; hl = hl->next) {
	    de2 = (domain_entry *)hl->object;
	    if ((de2 != NULL && de2->domain != NULL) &&
		!strcmp(strsmall, de2->domain)) {
			isexisting = TRUE;
			break;
	    } else {
		isexisting = FALSE;
	    }
	}

	if(!isexisting) {
	    de = (domain_entry *)calloc(1, sizeof(domain_entry));

d2602 3
d2606 12
a2617 21
		case (FLAG_ACCEPT_ALWAYS): de->bv = ACCEPT_ALWAYS;
					   de->invcheck_bv = INVCHECK_QUERY;
					   break;
		case (FLAG_REJECT_ALWAYS): de->bv = REJECT_ALWAYS;
					   de->invcheck_bv = INVCHECK_QUERY;
					   break;
		case (FLAG_QUERY_USER):    de->bv = QUERY_USER;
					   de->invcheck_bv = INVCHECK_QUERY;
					   break;
		case (FLAG_FROM_FILE):     de->bv = FROM_FILE;
					   de->invcheck_bv = INVCHECK_QUERY;
					   break;
		case (FLAG_INVCHECK_QUERY): de->invcheck_bv = INVCHECK_QUERY;
					    de->bv = QUERY_USER;
					    break;
		case (FLAG_INVCHECK_STRICT): de->invcheck_bv = INVCHECK_STRICT;
					     de->bv = QUERY_USER;
					    break;
		case (FLAG_INVCHECK_LOOSE): de->invcheck_bv = INVCHECK_LOOSE;
					    de->bv = QUERY_USER;
					    break;
a2622 17
	} else {
	    switch(flag) {
		case (FLAG_ACCEPT_ALWAYS): de2->bv = ACCEPT_ALWAYS;
					   break;
		case (FLAG_REJECT_ALWAYS): de2->bv = REJECT_ALWAYS;
					   break;
		case (FLAG_QUERY_USER): de2->bv = QUERY_USER;
					   break;
		case (FLAG_FROM_FILE): de2->bv = FROM_FILE;
					   break;
		case (FLAG_INVCHECK_QUERY): de2->invcheck_bv = INVCHECK_QUERY;
					   break;
		case (FLAG_INVCHECK_STRICT): de2->invcheck_bv = INVCHECK_STRICT;
					   break;
		case (FLAG_INVCHECK_LOOSE): de2->invcheck_bv = INVCHECK_LOOSE;
					   break;
	    }
d2624 16
d2645 40
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 22
a23 22
 *			       ===================
 *
 *	Author: AMK	A.M. Kuchling (amk@@magnet.com)	12/25/96
 *
 *	Incorporated with mods by FM			01/16/97
 *
 *  Based on:
 *	http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-mgmt-05.txt
 *
 *	Updated for:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *		- FM					1997-07-09
 *
 *	Updated for:
 *   ftp://ds.internic.net/internet-drafts/draft-ietf-http-state-man-mec-03.txt
 *		- FM					1997-08-02
 *
 *	Partially checked against:
 *   http://www.ietf.org/internet-drafts/draft-ietf-http-state-man-mec-10.txt
 *		- kw					1998-12-11
 *
 *  TO DO: (roughly in order of decreasing priority)
d73 3
a75 2
/* default for new domains, one of the invcheck_behaviour_t values: */
#define DEFAULT_INVCHECK_BV INVCHECK_QUERY
d78 11
a88 11
 *  The first level of the cookie list is a list indexed by the domain
 *  string; cookies with the same domain will be placed in the same
 *  list.  Thus, finding the cookies that apply to a given URL is a
 *  two-level scan; first we check each domain to see if it applies,
 *  and if so, then we check the paths of all the cookies on that
 *  list.  We keep a running total of cookies as we add or delete
 *  them
 */
static HTList *domain_list = NULL;
static HTList *cookie_list = NULL;
static int total_cookies = 0;
d91 14
a104 14
    char *lynxID;		/* Lynx cookie identifier */
    char *name;			/* Name of this cookie */
    char *value;		/* Value of this cookie */
    int version;		/* Cookie protocol version (=1) */
    char *comment;		/* Comment to show to user */
    char *commentURL;		/* URL for comment to show to user */
    char *domain;		/* Domain for which this cookie is valid */
    int port;			/* Server port from which this cookie was given (usu. 80) */
    char *PortList;		/* List of ports for which cookie can be sent */
    char *path;			/* Path prefix for which this cookie is valid */
    int pathlen;		/* Length of the path */
    int flags;			/* Various flags */
    time_t expires;		/* The time when this cookie expires */
    BOOL quoted;		/* Was a value quoted in the Set-Cookie header? */
d108 6
a113 6
#define COOKIE_FLAG_SECURE 1	/* If set, cookie requires secure links */
#define COOKIE_FLAG_DISCARD 2	/* If set, expire at end of session */
#define COOKIE_FLAG_EXPIRES_SET 4	/* If set, an expiry date was set */
#define COOKIE_FLAG_DOMAIN_SET 8	/* If set, an non-default domain was set */
#define COOKIE_FLAG_PATH_SET 16	/* If set, an non-default path was set */
#define COOKIE_FLAG_FROM_FILE 32	/* If set, this cookie was persistent */
d115 3
a117 2
struct _HTStream {
    HTStreamClass *isa;
d120 4
a123 3
static void MemAllocCopy(char **dest,
			 const char *start,
			 const char *end)
d132 1
a132 1
    temp = typecallocn(char, (end - start) + 1);
d140 1
a140 1
static cookie *newCookie(void)
d142 1
a142 1
    cookie *p = typecalloc(cookie);
d151 2
a152 1
static void freeCookie(cookie * co)
d168 1
a168 1
static void LYCookieJar_free(void)
a174 1
    CTRACE((tfp, "LYCookieJar_free\n"));
a176 1
	    CTRACE((tfp, "...LYCookieJar_free domain %s\n", de->domain));
d201 7
a207 6
 *  Compare two hostnames as specified in Section 2 of:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *	- AK & FM
 */
static BOOLEAN host_matches(const char *A,
			    const char *B)
d210 2
a211 2
     * The following line will handle both numeric IP addresses and FQDNs.  Do
     * numeric addresses require special handling?
d217 2
a218 2
     * The following will pass a "dotted tail" match to "a.b.c.e" as described
     * in Section 2 of draft-ietf-http-state-man-mec-10.txt.
a221 1

d231 7
a237 6
 *  Compare the current port with a port list as specified in Section 4.3 of:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *	- FM
 */
static BOOLEAN port_matches(int port,
			    const char *list)
d239 1
a239 1
    const char *number = list;
d241 2
a242 2
    if (!(number && isdigit(UCH(*number))))
	return (FALSE);
d246 1
a246 1
	    return (TRUE);
d248 1
a248 1
	while (isdigit(UCH(*number))) {
d251 1
a251 1
	while (*number != '\0' && !isdigit(UCH(*number))) {
d256 1
a256 1
    return (FALSE);
d260 6
a265 74
 * Returns the length of the given path ignoring trailing slashes.
 */
static int ignore_trailing_slash(const char *a)
{
    int len = strlen(a);

    while (len > 1 && a[len - 1] == '/')
	--len;
    return len;
}

/*
 * Check if the path 'a' is a prefix of path 'b', ignoring trailing slashes
 * in either, since they denote an empty component.
 */
static BOOL is_prefix(const char *a, const char *b)
{
    int len_a = ignore_trailing_slash(a);
    int len_b = ignore_trailing_slash(b);

    if (len_a > len_b) {
	return FALSE;
    } else {
	if (strncmp(a, b, len_a) != 0) {
	    return FALSE;
	}
	if (len_a < len_b && (len_a > 1 || a[0] != '/')) {
	    if (b[len_a] != '\0'
		&& b[len_a] != '/') {
		return FALSE;
	    }
	}
    }
    return TRUE;
}

/*
 * Find the domain-entry for the given name.
 */
static domain_entry *find_domain_entry(const char *name)
{
    HTList *hl;
    domain_entry *de = NULL;

    if (name != 0
	&& *name != '\0') {
	for (hl = domain_list; hl != NULL; hl = hl->next) {
	    de = (domain_entry *) hl->object;
	    if (de != NULL && de->domain != NULL) {
		CTRACE2(TRACE_CFG,
			(tfp,
			 "...test_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
			 de->domain,
			 de->bv,
			 de->invcheck_bv));
		if (!strcasecomp(name, de->domain)) {
		    break;
		}
	    }
	    de = NULL;
	}
    }
    CTRACE((tfp, "find_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
	    name,
	    de ? (int) de->bv : -1,
	    de ? (int) de->invcheck_bv : -1));
    return de;
}

/*
 *  Store a cookie somewhere in the domain list. - AK & FM
 */
static void store_cookie(cookie * co, const char *hostname,
			 const char *path)
d271 1
a271 1
    const char *ptr;
a273 4
    int invprompt_reasons = 0;	/* what is wrong with this cookie - kw */

#define FAILS_COND1 0x01
#define FAILS_COND4 0x02
d279 1
a279 1
     * Ensure that the domain list exists.
d290 2
a291 2
     * Look through domain_list to see if the cookie's domain is already
     * listed.
d294 13
a306 2
    if ((de = find_domain_entry(co->domain)) != NULL)
	cookie_list = de->cookie_list;
d318 27
a344 18
    if (!is_prefix(co->path, path)) {
	invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
					    : DEFAULT_INVCHECK_BV);

	switch (invcheck_bv) {
	case INVCHECK_LOOSE:
	    break;		/* continue as if nothing were wrong */

	case INVCHECK_QUERY:
	    invprompt_reasons |= FAILS_COND1;
	    break;		/* will prompt later if we get that far */

	case INVCHECK_STRICT:
	    CTRACE((tfp,
		    "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		    co->path, path));
	    freeCookie(co);
	    return;
a346 1

d353 1
a353 1
	 * The hostname does not contain a dot.
d356 2
a357 2
	    CTRACE((tfp, "store_cookie: Rejecting because '%s' has no dot.\n",
		    hostname));
d359 1
d364 5
a368 5
	 * Section 4.3.2, condition 2:  The value for the Domain attribute
	 * contains no embedded dots or does not start with a dot.  (A dot is
	 * embedded if it's neither the first nor last character.) Note that we
	 * added a lead dot ourselves if a domain attribute value otherwise
	 * qualified.  - FM
d371 2
a372 1
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n", co->domain));
d374 1
d379 2
a380 1
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n", co->domain));
d382 1
d387 2
a388 2
	 * Section 4.3.2, condition 3:  The value for the request-host does not
	 * domain-match the Domain attribute.
d391 2
a392 3
	    CTRACE((tfp,
		    "store_cookie: Rejecting domain '%s' for host '%s'.\n",
		    co->domain, hostname));
d394 1
d399 3
a401 3
	 * Section 4.3.2, condition 4:  The request-host is an HDN (not IP
	 * address) and has the form HD, where D is the value of the Domain
	 * attribute, and H is a string that contains one or more dots.
d403 3
a405 3
	 * If cookie checking for this domain is set to INVCHECK_LOOSE, then we
	 * want to bypass this check.  The user should be queried if set to
	 * INVCHECK_QUERY.
d409 29
a437 58
	    invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
						: DEFAULT_INVCHECK_BV);

	    switch (invcheck_bv) {
	    case INVCHECK_LOOSE:
		break;		/* continue as if nothing were wrong */

	    case INVCHECK_QUERY:
		invprompt_reasons |= FAILS_COND4;
		break;		/* will prompt later if we get that far */

	    case INVCHECK_STRICT:
		CTRACE((tfp,
			"store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
			co->path, path));
		freeCookie(co);
		return;
	    }
	}
    }

    /*
     * If we found reasons for issuing an invalid cookie confirmation prompt,
     * do that now.  Rejection by the user here is the last chance to
     * completely ignore this cookie; after it passes this hurdle, it may at
     * least supersede a previous cookie (even if it finally gets rejected).  -
     * kw
     */
    if (invprompt_reasons) {
	char *msg = 0;

	if (invprompt_reasons & FAILS_COND4) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_DOMAIN_CONFIRMATION,
		       co->domain,
		       hostname);
	    if (!HTForcedPrompt(cookie_noprompt, msg, NO)) {
		CTRACE((tfp,
			"store_cookie: Rejecting domain '%s' for host '%s'.\n",
			co->domain,
			hostname));
		freeCookie(co);
		FREE(msg);
		return;
	    }
	}
	if (invprompt_reasons & FAILS_COND1) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_PATH_CONFIRMATION,
		       co->path, path);
	    if (!HTForcedPrompt(cookie_noprompt, msg, NO)) {
		CTRACE((tfp,
			"store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
			co->path, path));
		freeCookie(co);
		FREE(msg);
		return;
	    }
a438 1
	FREE(msg);
d441 1
a441 1
    if (de == NULL) {
d443 1
a443 1
	 * Domain not found; add a new entry for this domain.
d445 1
a445 1
	de = typecalloc(domain_entry);
d448 17
a464 2
	de->bv = QUERY_USER;
	de->invcheck_bv = DEFAULT_INVCHECK_BV;	/* should this go here? */
d471 1
a471 1
     * Loop over the cookie list, deleting expired and matching cookies.
d476 1
a476 1
	c2 = (cookie *) hl->object;
d479 1
a479 1
	 * Check if this cookie has expired.
d489 3
a491 3
	    /*
	     * Check if this cookie matches the one we're inserting.
	     */
d493 1
a493 1
		   !strcasecomp(co->domain, c2->domain) &&
d504 14
a517 13
	     * This comparison determines the (tentative) position of the new
	     * cookie in the list such that it comes before existing cookies
	     * with a less specific path, but after existing cookies of equal
	     * (or greater) path length.  Thus it should normally preserve the
	     * order of new cookies with the same path as they are received,
	     * although this is not required.
	     *
	     * From RFC 2109 4.3.4:
	     *
	     * If multiple cookies satisfy the criteria above, they are ordered
	     * in the Cookie header such that those with more specific Path
	     * attributes precede those with less specific.  Ordering with
	     * respect to other attributes (e.g., Domain) is unspecified.
d525 1
a525 1
     * Don't bother to add the cookie if it's already expired.
d531 3
a533 3
	/*
	 * Don't add the cookie if we're over the domain's limit.  - FM
	 */
d535 1
a535 2
	CTRACE((tfp,
		"store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n"));
d539 3
a541 3
	/*
	 * Don't add the cookie if we're over the total cookie limit.  - FM
	 */
d543 1
a543 2
	CTRACE((tfp,
		"store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n"));
d547 5
a551 10
	/*
	 * Don't add the cookie if the value is NULL. - BJP
	 */
	/*
	 * Presence of value is now needed (indicated normally by '='),
	 * but it can now be an empty string.
	 * - kw 1999-06-24
	 */
    } else if (co->value == NULL) {	/* should not happen - kw */
	CTRACE((tfp, "store_cookie: Value is NULL! Not storing cookie.\n"));
d555 5
a559 4
	/*
	 * If it's a replacement for a cookie that had not expired, and never
	 * allow has not been set, add it again without confirmation.  - FM
	 */
d564 11
a574 11
	/*
	 * Get confirmation if we need it, and add cookie if confirmed or
	 * 'allow' is set to always.  - FM
	 *
	 * Cookies read from file are accepted without confirmation prompting. 
	 * (Prompting may actually not be possible if LYLoadCookies is called
	 * before curses is setup.) Maybe this should instead depend on
	 * LYSetCookies and/or LYCookieAcceptDomains and/or
	 * LYCookieRejectDomains and/or LYAcceptAllCookies and/or some other
	 * settings.  -kw
	 */
d590 10
a599 9
 *  Scan a domain's cookie_list for any cookies we should
 *  include in a Cookie: request header. - AK & FM
 */
static char *scan_cookie_sublist(char *hostname,
				 char *path,
				 int port,
				 HTList *sublist,
				 char *header,
				 BOOL secure)
d609 1
a609 1
	co = (cookie *) hl->object;
d612 16
a627 17
	if ((co) &&		/* speed-up host_matches() and limit trace output */
	    (LYstrstr(hostname, co->domain) != NULL)) {
	    CTRACE((tfp, "Checking cookie %p %s=%s\n",
		    hl,
		    (co->name ? co->name : "(no name)"),
		    (co->value ? co->value : "(no value)")));
	    CTRACE((tfp, "\t%s %s %d %s %s %d%s\n",
		    hostname,
		    (co->domain ? co->domain : "(no domain)"),
		    host_matches(hostname, co->domain),
		    path, co->path,
		    (co->pathlen > 0)
		    ? !is_prefix(co->path, path)
		    : 0,
		    (co->flags & COOKIE_FLAG_SECURE)
		    ? " secure"
		    : ""));
d630 1
a630 1
	 * Check if this cookie has expired, and if so, delete it.
d641 1
a641 1
	 * Check if we have a unexpired match, and handle if we do.
d645 1
a645 1
	    (co->pathlen == 0 || is_prefix(co->path, path))) {
d647 3
a649 3
	     * Skip if the secure flag is set and we don't have a secure
	     * connection.  HTTP.c presently treats only SSL connections as
	     * secure.  - FM
d657 2
a658 2
	     * Skip if we have a port list and the current port is not listed. 
	     * - FM
d666 1
a666 1
	     * Start or append to the request header.
d671 3
a673 2
		     * For Version 1 (or greater) cookies, the version number
		     * goes before the first cookie.
d680 3
a682 3
		 * There's already cookie data there, so add a separator
		 * (always use a semi-colon for "backward compatibility").  -
		 * FM
d686 1
a686 1
		 * Check if we should fold the header.  - FM
d692 8
a699 6
		 * HTTP/1.0 headers may be folded onto multiple lines if each
		 * continuation line begins with a space or horizontal tab. 
		 * All linear whitespace, including folding, has the same
		 * semantics as SP.  [...] However, folding of header lines is
		 * not expected by some applications, and should not be
		 * generated by HTTP/1.0 applications.
d701 1
a701 1
		 * This code was causing problems.  Let's not use it.  -BJP
d711 1
a711 1
	     * Include the cookie name=value pair.
d726 4
a729 3
	     * For Version 1 (or greater) cookies, add $PATH, $PORT and/or
	     * $DOMAIN attributes for the cookie if they were specified via a
	     * server reply header.  - FM
d734 1
a734 1
		     * Append the path attribute.  - FM
d741 1
a741 1
		if (co->PortList && isdigit(UCH(*co->PortList))) {
d743 1
a743 1
		     * Append the port attribute.  - FM
d752 1
a752 1
		     * Append the domain attribute.  - FM
d764 1
a764 1
    return (header);
d768 10
a777 38
 * Presence of value is needed (indicated normally by '=') to start a cookie,
 * but it can be an empty string.  - kw 1999-06-24
 */
static char *alloc_attr_value(const char *value_start,
			      const char *value_end)
{
    char *value = NULL;

    if (value_start && value_end >= value_start) {
	int value_len = (value_end - value_start);

	if (value_len > max_cookies_buffer) {
	    value_len = max_cookies_buffer;
	}
	value = typecallocn(char, value_len + 1);

	if (value == NULL)
	    outofmem(__FILE__, "LYProcessSetCookies");
	LYstrncpy(value, value_start, value_len);
    }
    return value;
}

#define FLAGS_INVALID_PORT 1
#define FLAGS_KNOWN_ATTR   2
#define FLAGS_MAXAGE_ATTR  4

#define is_attr(s, len) attr_len == len && !strncasecomp(attr_start, s, len)

static unsigned parse_attribute(unsigned flags,
				cookie * cur_cookie,
				int *cookie_len,
				const char *attr_start,
				int attr_len,
				char *value,
				const char *address,
				char *hostname,
				int port)
d779 1
a779 227
    BOOLEAN known_attr = NO;
    int url_type;

    flags &= ~FLAGS_KNOWN_ATTR;
    if (is_attr("secure", 6)) {
	if (value == NULL) {
	    known_attr = YES;
	    if (cur_cookie != NULL) {
		cur_cookie->flags |= COOKIE_FLAG_SECURE;
	    }
	} else {
	    /*
	     * If secure has a value, assume someone misused it as cookie name. 
	     * - FM
	     */
	    known_attr = NO;
	}
    } else if (is_attr("discard", 7)) {
	if (value == NULL) {
	    known_attr = YES;
	    if (cur_cookie != NULL) {
		cur_cookie->flags |= COOKIE_FLAG_DISCARD;
	    }
	} else {
	    /*
	     * If discard has a value, assume someone used it as a cookie name. 
	     * - FM
	     */
	    known_attr = NO;
	}
    } else if (is_attr("comment", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat comment.  - FM
	 */
	    cur_cookie->comment == NULL) {
	    StrAllocCopy(cur_cookie->comment, value);
	    *cookie_len += strlen(cur_cookie->comment);
	}
    } else if (is_attr("commentURL", 10)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat commentURL.  - FM
	 */
	    cur_cookie->commentURL == NULL) {
	    /*
	     * We should get only absolute URLs as values, but will resolve
	     * versus the request's URL just in case.  - FM
	     */
	    cur_cookie->commentURL = HTParse(value,
					     address,
					     PARSE_ALL);
	    /*
	     * Accept only URLs for http or https servers.  - FM
	     */
	    if ((url_type = is_url(cur_cookie->commentURL)) &&
		(url_type == HTTP_URL_TYPE ||
		 url_type == HTTPS_URL_TYPE)) {
		*cookie_len += strlen(cur_cookie->commentURL);
	    } else {
		CTRACE((tfp,
			"LYProcessSetCookies: Rejecting commentURL value '%s'\n",
			cur_cookie->commentURL));
		FREE(cur_cookie->commentURL);
	    }
	}
    } else if (is_attr("domain", 6)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat domain.  - FM
	 */
	    !(cur_cookie->flags & COOKIE_FLAG_DOMAIN_SET)) {
	    *cookie_len -= strlen(cur_cookie->domain);
	    /*
	     * If the value does not have a lead dot, but does have an embedded
	     * dot, and is not an exact match to the hostname, nor is a numeric
	     * IP address, add a lead dot.  Otherwise, use the value as is.  -
	     * FM (domains - case insensitive).
	     */
	    if (value[0] != '.' && value[0] != '\0' &&
		value[1] != '\0' && strcasecomp(value, hostname)) {
		char *ptr = strchr(value, '.');

		if (ptr != NULL && ptr[1] != '\0') {
		    ptr = value;
		    while (*ptr == '.' ||
			   isdigit(UCH(*ptr)))
			ptr++;
		    if (*ptr != '\0') {
			CTRACE((tfp,
				"LYProcessSetCookies: Adding lead dot for domain value '%s'\n",
				value));
			StrAllocCopy(cur_cookie->domain, ".");
			StrAllocCat(cur_cookie->domain, value);
		    } else {
			StrAllocCopy(cur_cookie->domain, value);
		    }
		} else {
		    StrAllocCopy(cur_cookie->domain, value);
		}
	    } else {
		StrAllocCopy(cur_cookie->domain, value);
	    }
	    *cookie_len += strlen(cur_cookie->domain);
	    cur_cookie->flags |= COOKIE_FLAG_DOMAIN_SET;
	}
    } else if (is_attr("path", 4)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat path.  - FM
	 */
	    !(cur_cookie->flags & COOKIE_FLAG_PATH_SET)) {
	    *cookie_len -= strlen(cur_cookie->path);
	    StrAllocCopy(cur_cookie->path, value);
	    *cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
	    cur_cookie->flags |= COOKIE_FLAG_PATH_SET;
	}
    } else if (is_attr("port", 4)) {
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat port.  - FM
	 */
	    cur_cookie->PortList == NULL) {
	    char *cp = value;

	    while ((*cp != '\0') &&
		   (isdigit(UCH(*cp)) ||
		    *cp == ',' || *cp == ' ')) {
		cp++;
	    }
	    if (*cp == '\0') {
		if (!port_matches(port, value)) {
		    flags |= FLAGS_INVALID_PORT;
		} else {
		    StrAllocCopy(cur_cookie->PortList, value);
		    *cookie_len += strlen(cur_cookie->PortList);
		}
		known_attr = YES;
	    } else {
		known_attr = NO;
	    }
	} else if (cur_cookie != NULL) {
	    /*
	     * Don't process a repeat port.  - FM
	     */
	    if (cur_cookie->PortList == NULL) {
		HTSprintf0(&(cur_cookie->PortList), "%d", port);
		*cookie_len += strlen(cur_cookie->PortList);
	    }
	    known_attr = YES;
	}
    } else if (is_attr("version", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat version.  - FM
	 */
	    cur_cookie->version < 1) {
	    int temp = strtol(value, NULL, 10);

	    if (errno != -ERANGE) {
		cur_cookie->version = temp;
	    }
	}
    } else if (is_attr("max-age", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	/*
	 * Don't process a repeat max-age.  - FM
	 */
	    !(flags & FLAGS_MAXAGE_ATTR)) {
	    int temp = strtol(value, NULL, 10);

	    cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
	    if (errno == -ERANGE) {
		cur_cookie->expires = (time_t) 0;
	    } else {
		cur_cookie->expires = (time(NULL) + temp);
		CTRACE((tfp, "LYSetCookie: expires %ld, %s",
			(long) cur_cookie->expires,
			ctime(&cur_cookie->expires)));
	    }
	    flags |= FLAGS_MAXAGE_ATTR;
	}
    } else if (is_attr("expires", 7)) {
	/*
	 * Convert an 'expires' attribute value if we haven't received a
	 * 'max-age'.  Note that 'expires' should not be used in Version 1
	 * cookies, but it might be used for "backward compatibility", and, in
	 * turn, ill-informed people surely would start using it instead of,
	 * rather than in addition to, 'max-age'.  - FM
	 */
	known_attr = YES;
	if ((cur_cookie != NULL && !(flags & FLAGS_MAXAGE_ATTR)) &&
	    !(cur_cookie->flags & COOKIE_FLAG_EXPIRES_SET)) {
	    if (value) {
		cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
		cur_cookie->expires = LYmktime(value, FALSE);
		if (cur_cookie->expires > 0) {
		    CTRACE((tfp, "LYSetCookie: expires %ld, %s",
			    (long) cur_cookie->expires,
			    ctime(&cur_cookie->expires)));
		}
	    }
	}
    }
    if (known_attr)
	flags |= FLAGS_KNOWN_ATTR;
    return flags;
}

/*
 *  Process potentially concatenated Set-Cookie2 and/or Set-Cookie
 *  headers. - FM
 */
static void LYProcessSetCookies(const char *SetCookie,
				const char *SetCookie2,
				const char *address,
				char *hostname,
				char *path,
				int port)
{
    const char *p, *attr_start, *attr_end, *value_start, *value_end;
d782 1
a782 1
    int cookie_len = 0;
d784 1
d786 1
a786 1
    unsigned parse_flags = 0;
d788 2
a789 2
    if (isEmpty(SetCookie) &&
	isEmpty(SetCookie2)) {
d791 1
a791 1
	 * Yuk!  Garbage in, so nothing out.  - FM
d797 8
a804 7
     * If we have both Set-Cookie and Set-Cookie2 headers.  process the
     * Set-Cookie2 header.  Otherwise, process whichever of the two headers we
     * do have.  Note that if more than one instance of a valued attribute for
     * the same cookie is encountered, the value for the first instance is
     * retained.  We only accept up to 50 cookies from the header, and only if
     * a cookie's values do not exceed the 4096 byte limit on overall size.  -
     * FM
d809 2
a810 2
     * Process the Set-Cookie2 header, if present and not zero-length, adding
     * each cookie to the CombinedCookies list.  - FM
d812 1
a812 1
    p = NonNull(SetCookie2);
d814 1
a814 1
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie2 header.\n"));
d820 1
a820 1
	 * Get the attribute name.
d823 1
a823 1
	while (*p != '\0' && !isspace(UCH(*p)) &&
d830 8
a837 7
	 * Check for an '=' delimiter, or an 'expires' name followed by white,
	 * since Netscape's bogus parser doesn't require an '=' delimiter, and
	 * 'expires' attributes are being encountered without them.  These
	 * shouldn't be in a Set-Cookie2 header, but we'll assume it's an
	 * expires attribute rather a cookie with that name, since the
	 * attribute mistake rather than name mistake seems more likely to be
	 * made by providers.  - FM
d840 1
a840 1
	    !strncasecomp(attr_start, "Expires", 7)) {
d842 1
a842 1
	     * Get the value string.
d849 8
a856 7
	     * Hack alert!  We must handle Netscape-style cookies with
	     *          "Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *          "Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     * No quotes, but there are spaces.  Argh...  Anyway, we know it
	     * will have at least 3 space separators within it, and two dashes
	     * or two more spaces, so this code looks for a space after the 5th
	     * space separator or dash to mark the end of the value.  - FM
a860 1

d862 1
a862 1
		if (isdigit(UCH(*p))) {
d864 1
a864 1
		     * No alphabetic day field.  - FM
d869 1
a869 1
		     * Skip the alphabetic day field.  - FM
d871 1
a871 1
		    while (*p != '\0' && isalpha(UCH(*p))) {
d874 1
a874 1
		    while (*p == ',' || isspace(UCH(*p))) {
d881 2
a882 2
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
d890 7
a896 6
		/*
		 * Hack Alert!  The port attribute can take a comma separated
		 * list of numbers as a value, and such values should be
		 * quoted, but if not, make sure we don't treat a number in the
		 * list as the start of a new cookie.  - FM
		 */
d899 1
a899 1
		       isdigit(UCH(*p))) {
d901 1
a901 1
		 * The value starts as an unquoted number.
d903 1
a903 2
		const char *cp, *cp1;

d906 1
a906 1
		    while (isdigit(UCH(*p)))
d914 1
a914 1
			if (*cp != '\0' && isdigit(UCH(*cp))) {
d916 1
a916 1
			    while (isdigit(UCH(*cp1)))
d929 1
a929 1
		     * Trim trailing spaces.
d932 1
a932 1
			isspace(UCH(*(value_end - 1)))) {
d935 2
a936 2
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
a942 2
		BOOLEAN escaped = FALSE;

d944 1
a944 1
		 * It looks like quoted string.
d948 1
a948 2
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
d950 2
a951 3
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
a952 8
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
d955 1
a955 1
		 * Otherwise, it's an unquoted string.
d962 1
a962 1
		 * Trim trailing spaces.
d965 1
a965 1
		    isspace(UCH(*(value_end - 1)))) {
d968 2
a969 2
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
d977 1
a977 1
	 * Check for a separator character, and skip it.
d983 1
a983 1
	 * Now, we can handle this attribute/value pair.
d986 220
a1205 1
	    char *value = alloc_attr_value(value_start, value_end);
d1207 22
a1228 24
	    parse_flags = parse_attribute(parse_flags,
					  cur_cookie,
					  &cookie_len,
					  attr_start,
					  (attr_end - attr_start),
					  value,
					  address,
					  hostname,
					  port);

	    /*
	     * Presence of value is needed (indicated normally by '='),
	     * but it can be an empty string. - kw 1999-06-24
	     */
	    if (!(parse_flags & FLAGS_KNOWN_ATTR)
		&& value
		&& value_end >= value_start) {
		/*
		 * If we've started a cookie, and it's not too big, save it in
		 * the CombinedCookies list.  - FM
		 */
		if (cookie_len <= max_cookies_buffer
		    && cur_cookie != NULL
		    && !(parse_flags & FLAGS_INVALID_PORT)) {
d1230 1
a1230 1
		     * Assume version 1 if not set to that or higher.  - FM
d1237 12
a1248 12
		    CTRACE((tfp,
			    "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
			    (cur_cookie->name ?
			     cur_cookie->name : "[no name]"),
			    (cur_cookie->value ?
			     cur_cookie->value : "[no value]")));
		    CTRACE((tfp,
			    (parse_flags & FLAGS_INVALID_PORT) ?
			    "                     due to excessive length!\n"
			    : "                     due to invalid port!\n"));
		    if (parse_flags & FLAGS_INVALID_PORT) {
			NumCookies--;
d1254 1
a1254 1
		 * Start a new cookie.  - FM
d1257 2
a1258 1
		cookie_len = 0;
d1261 1
a1261 1
		cookie_len += strlen(cur_cookie->name);
d1263 1
a1263 1
		cookie_len += strlen(cur_cookie->value);
d1265 1
a1265 1
		cookie_len += strlen(cur_cookie->domain);
d1267 1
a1267 1
		cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
d1269 1
a1269 1
		parse_flags = 0;
d1277 2
a1278 2
     * Add any final SetCookie2 cookie to the CombinedCookie list if we are
     * within the length limit.  - FM
d1281 2
a1282 2
	&& cookie_len <= max_cookies_buffer
	&& cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
d1287 11
a1297 11
    } else if (cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
		(cookie_len > max_cookies_buffer ? "length" : ""),
		(cookie_len > max_cookies_buffer &&
		 NumCookies > max_cookies_domain
		 ? " and "
		 : ""),
		(NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1300 6
a1305 6
    } else if (cur_cookie != NULL) {	/* invalidport */
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to invalid port!\n"));
	NumCookies--;
d1311 2
a1312 2
     * Process the Set-Cookie header, if no non-zero-length Set-Cookie2 header
     * was present.  - FM
d1314 1
a1314 1
    cookie_len = 0;
d1317 1
a1317 1
    p = ((SetCookie && isEmpty(SetCookie2)) ? SetCookie : "");
d1319 1
a1319 1
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie header.\n"));
d1325 1
a1325 1
	 * Get the attribute name.
d1328 1
a1328 1
	while (*p != '\0' && !isspace(UCH(*p)) &&
d1335 4
a1338 3
	 * Check for an '=' delimiter, or an 'expires' name followed by white,
	 * since Netscape's bogus parser doesn't require an '=' delimiter, and
	 * 'expires' attributes are being encountered without them.  - FM
d1341 1
a1341 1
	    !strncasecomp(attr_start, "Expires", 7)) {
d1343 1
a1343 1
	     * Get the value string.
d1350 8
a1357 7
	     * Hack alert!  We must handle Netscape-style cookies with
	     *          "Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *          "Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     * No quotes, but there are spaces.  Argh...  Anyway, we know it
	     * will have at least 3 space separators within it, and two dashes
	     * or two more spaces, so this code looks for a space after the 5th
	     * space separator or dash to mark the end of the value.  - FM
a1361 1

d1363 1
a1363 1
		if (isdigit(UCH(*p))) {
d1365 1
a1365 1
		     * No alphabetic day field.  - FM
d1370 1
a1370 1
		     * Skip the alphabetic day field.  - FM
d1372 1
a1372 1
		    while (*p != '\0' && isalpha(UCH(*p))) {
d1375 1
a1375 1
		    while (*p == ',' || isspace(UCH(*p))) {
d1382 2
a1383 2
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
d1391 7
a1397 6
		/*
		 * Hack Alert!  The port attribute can take a comma separated
		 * list of numbers as a value, and such values should be
		 * quoted, but if not, make sure we don't treat a number in the
		 * list as the start of a new cookie.  - FM
		 */
d1400 1
a1400 1
		       isdigit(UCH(*p))) {
d1402 1
a1402 1
		 * The value starts as an unquoted number.
d1404 1
a1404 2
		const char *cp, *cp1;

d1407 1
a1407 1
		    while (isdigit(UCH(*p)))
d1415 1
a1415 1
			if (*cp != '\0' && isdigit(UCH(*cp))) {
d1417 1
a1417 1
			    while (isdigit(UCH(*cp1)))
d1430 1
a1430 1
		     * Trim trailing spaces.
d1433 1
a1433 1
			isspace(UCH(*(value_end - 1)))) {
d1436 2
a1437 2
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
a1443 2
		BOOLEAN escaped = FALSE;

d1445 1
a1445 1
		 * It looks like quoted string.
d1449 1
a1449 2
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
d1451 2
a1452 3
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
d1454 1
a1454 8
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
d1457 1
a1457 1
		 * Otherwise, it's an unquoted string.
d1464 1
a1464 1
		 * Trim trailing spaces.
d1467 1
a1467 1
		    isspace(UCH(*(value_end - 1)))) {
d1470 2
a1471 2
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
d1479 1
a1479 1
	 * Check for a separator character, and skip it.
d1485 1
a1485 1
	 * Now, we can handle this attribute/value pair.
d1488 205
a1692 1
	    char *value = alloc_attr_value(value_start, value_end);
d1694 16
a1709 17
	    parse_flags = parse_attribute(parse_flags,
					  cur_cookie,
					  &cookie_len,
					  attr_start,
					  (attr_end - attr_start),
					  value,
					  address,
					  hostname,
					  port);

	    /*
	     * Presence of value is needed (indicated normally by '='),
	     * but it can be an empty string. - kw 1999-06-24
	     */
	    if (!(parse_flags & FLAGS_KNOWN_ATTR)
		&& value
		&& value_end >= value_start) {
d1711 2
a1712 2
		 * If we've started a cookie, and it's not too big, save it in
		 * the CombinedCookies list.  - FM
d1714 1
a1714 2
		if (cookie_len <= max_cookies_buffer
		    && cur_cookie != NULL) {
d1716 3
a1718 2
		     * If we had a Set-Cookie2 header, make sure the version is
		     * at least 1, and mark it for quoting.  - FM
d1728 6
a1733 8
		    CTRACE((tfp,
			    "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
			    (cur_cookie->name ?
			     cur_cookie->name : "[no name]"),
			    (cur_cookie->value ?
			     cur_cookie->value : "[no value]")));
		    CTRACE((tfp,
			    "                     due to excessive length!\n"));
d1738 1
a1738 1
		 * Start a new cookie.  - FM
d1741 1
a1741 2
		NumCookies++;
		cookie_len = 0;
d1743 1
a1743 1
		cookie_len += strlen(cur_cookie->name);
d1745 1
a1745 1
		cookie_len += strlen(cur_cookie->value);
d1747 1
a1747 1
		cookie_len += strlen(cur_cookie->domain);
d1749 1
a1749 1
		cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
d1751 1
a1751 1
		parse_flags = 0;
d1760 1
a1760 1
     * Handle the final Set-Cookie cookie if within length limit.  - FM
d1762 1
a1762 3
    if (NumCookies <= max_cookies_domain
	&& cookie_len <= max_cookies_buffer
	&& cur_cookie != NULL) {
d1771 7
a1777 9
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
		(cookie_len > max_cookies_buffer ? "length" : ""),
		(cookie_len > max_cookies_buffer && NumCookies > max_cookies_domain
		 ? " and "
		 : ""),
		(NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1783 2
a1784 2
     * OK, now we can actually store any cookies in the CombinedCookies list. 
     * - FM
d1787 4
a1790 4
    while (NULL != (co = (cookie *) HTList_nextObject(cl))) {
	CTRACE((tfp, "LYProcessSetCookie: attr=value pair: '%s=%s'\n",
		(co->name ? co->name : "[no name]"),
		(co->value ? co->value : "[no value]")));
d1792 3
a1794 3
	    CTRACE((tfp, "                    expires: %ld, %s\n",
		    (long) co->expires,
		    ctime(&co->expires)));
d1796 1
a1796 1
	if (isHTTPS_URL(address) &&
d1800 1
a1800 1
	    CTRACE((tfp, "                    Forced the 'secure' flag on.\n"));
d1811 8
a1818 7
 *  Entry function for handling Set-Cookie: and/or Set-Cookie2:
 *  reply headers.   They may have been concatenated as comma
 *  separated lists in HTTP.c or HTMIME.c. - FM
 */
void LYSetCookie(const char *SetCookie,
		 const char *SetCookie2,
		 const char *address)
d1825 3
a1827 3
     * Get the hostname, port and path of the address, and report the
     * Set-Cookie and/or Set-Cookie2 header(s) if trace mode is on, but set the
     * cookie(s) only if LYSetCookies is TRUE.  - FM
d1830 1
a1830 1
	(ptr = strchr(hostname, ':')) != NULL) {
d1832 1
a1832 1
	 * Replace default port number.
d1837 1
a1837 1
    } else if (isHTTPS_URL(address)) {
d1841 1
a1841 1
			 PARSE_PATH | PARSE_PUNCTUATION)) != NULL) &&
d1844 1
a1844 1
	    *(ptr + 1) = '\0';	/* Leave a single '/' alone */
d1849 2
a1850 2
    if (isEmpty(SetCookie) &&
	isEmpty(SetCookie2)) {
d1852 3
a1854 2
	 * Yuk, something must have gone wrong in HTMIME.c or HTTP.c because
	 * both SetCookie and SetCookie2 are NULL or zero-length.  - FM
d1858 3
a1860 3
    CTRACE((tfp, "LYSetCookie called with host '%s', path '%s',\n",
	    NonNull(hostname),
	    NonNull(path)));
d1862 2
a1863 1
	CTRACE((tfp, "    and Set-Cookie: '%s'\n", SetCookie));
d1866 2
a1867 1
	CTRACE((tfp, "    and Set-Cookie2: '%s'\n", SetCookie2));
d1870 1
a1870 1
	CTRACE((tfp, "    Ignoring this Set-Cookie/Set-Cookie2 request.\n"));
d1874 1
a1874 1
     * We're done if LYSetCookies is off or we have bad headers.  - FM
d1883 1
a1883 1
     * Process the header(s).
d1892 8
a1899 7
 *  Entry function from creating a Cookie: request header
 *  if needed. - AK & FM
 */
char *LYAddCookieHeader(char *hostname,
			char *path,
			int port,
			BOOL secure)
d1905 4
a1908 4
    CTRACE((tfp, "LYCookie: Searching for '%s:%d', '%s'.\n",
	    NONNULL(hostname),
	    port,
	    NONNULL(path)));
d1911 2
a1912 2
     * Search the cookie_list elements in the domain_list for any cookies
     * associated with the //hostname:port/path
d1915 1
a1915 1
	de = (domain_entry *) hl->object;
d1921 3
a1923 2
		 * Scan the domain's cookie_list for any cookies we should
		 * include in our request header.
d1927 1
a1927 1
	    } else if (de->bv == QUERY_USER && de->invcheck_bv == DEFAULT_INVCHECK_BV) {
d1929 3
a1931 2
		 * No cookies in this domain, and no default accept/reject
		 * choice was set by the user, so delete the domain.  - FM
d1943 1
a1943 1
	return (header);
d1945 1
a1945 1
    return (NULL);
d1948 2
a1949 2
#ifdef USE_PERSISTENT_COOKIES
static int number_of_file_cookies = 0;
d1952 2
a1953 1
void LYLoadCookies(char *cookie_file)
a1958 1
    /* *INDENT-OFF* */
a1971 2
    /* *INDENT-ON* */

d1974 1
a1974 1
    cookie_handle = fopen(cookie_file, TXT_R);
d1978 1
a1978 1
    CTRACE((tfp, "LYLoadCookies: reading cookies from %s\n", cookie_file));
d1983 1
d1987 1
a1987 2
	LYTrimNewline(buf);
	if (buf[0] == '\0' || buf[0] == '#') {
d1991 1
a1991 1
	number_of_file_cookies++;
d1993 9
a2001 1
	strcat(buf, "\t");	/* add sep after line if enough space - kw */
d2013 1
a2013 7
	/*
	 * This fails when the path is blank
	 *
	 * sscanf(buf, "%s\t%s\t%s\t%s\t%d\t%s\t%[ -~]",
	 *  domain, what, path, secure, &expires, name, value);
	 */
	CTRACE((tfp, "LYLoadCookies: tokenising %s\n", buf));
d2017 3
a2019 5
	    CTRACE((tfp, "\t%d:[%03d]:[%s]\n",
		    tok_loop, tok_out - buf, tok_out));
	    LYstrncpy(tok_values[tok_loop].s,
		      tok_out,
		      tok_values[tok_loop].n);
d2028 1
d2030 6
a2035 6
	if (tok_values[tok_loop].s) {
	    /* tok_out in above loop must have been NULL prematurely - kw */
	    CTRACE((tfp,
		    "*** wrong format: not enough tokens, ignoring line!\n"));
	    continue;
	}
d2037 3
a2039 4
	expires = atol(expires_a);
	CTRACE((tfp, "expires:\t%s\n", ctime(&expires)));
/*	CTRACE((tfp, "%s\t%s\t%s\t%s\t%ld\t%s\t%s\tREADCOOKIE\n", */
/*	    domain, what, path, secure, (long) expires, name, value)); */
d2044 1
a2044 9
	if (value && value[0] == '"' &&
	    value[1] && value[strlen(value) - 1] == '"' &&
	    value[strlen(value) - 2] != '\\') {
	    value[strlen(value) - 1] = '\0';
	    StrAllocCopy(moo->value, value + 1);
	    moo->quoted = TRUE;
	} else {
	    StrAllocCopy(moo->value, value);
	}
d2050 2
a2051 2
	 *                           expiration originally, otherwise
	 *                           it would not be in the file.
d2054 23
a2076 23
	 *                           only matters for sending version 1
	 *                           cookies; the cookies read from the
	 *                           file are currently treated all like
	 *                           version 0 (we don't set moo->version)
	 *                           so $Domain= and $Path= will normally
	 *                           not be sent to the server.  But if
	 *                           these cookies somehow get mixed with
	 *                           new version 1 cookies we may end up
	 *                           sending version 1 to the server, and
	 *                           in that case we should send $Domain
	 *                           and $Path.  The state-man-mec drafts
	 *                           and RFC 2109 say that $Domain and
	 *                           $Path SHOULD be omitted if they were
	 *                           not given explicitly, but not that
	 *                           they MUST be omitted.
	 *                           See 8.2 Cookie Spoofing in draft -10
	 *                           for a good reason to send them.
	 *                           However, an explicit domain should be
	 *                           now prefixed with a dot (unless it is
	 *                           for a single host), so we check for
	 *                           that.
	 *  COOKIE_FLAG_SECURE       Should have "FALSE" for normal,
	 *                           otherwise set it.
d2079 1
a2079 1
	    COOKIE_FLAG_PATH_SET;
d2094 1
a2094 1
    LYCloseInput(cookie_handle);
d2098 2
a2099 1
void LYStoreCookies(char *cookie_file)
d2101 3
d2108 1
a2108 6
    time_t now = time(NULL);	/* system specific? - RP */

    if (!strcmp(cookie_file, "/dev/null")) {
	/* We give /dev/null the Unix meaning, regardless of OS */
	return;
    }
d2111 1
a2111 1
     * Check whether we have something to do.  - FM
d2121 1
a2121 1
    CTRACE((tfp, "LYStoreCookies: save cookies to %s on exit\n", cookie_file));
d2123 2
a2124 3
    cookie_handle = LYNewTxtFile(cookie_file);
    if (cookie_handle == NULL)
	return;
d2126 1
a2126 1
	de = (domain_entry *) (dl->object);
d2129 1
a2129 1
	     * Fote says the first object is NULL.  Go with that.
d2133 18
d2152 1
a2152 1
	 * Show the domain's cookies.  - FM
d2156 1
a2156 1
	     * First object is always NULL.  - FM
d2158 1
a2158 1
	    if ((co = (cookie *) cl->object) == NULL)
d2161 1
a2161 2
	    CTRACE((tfp, "LYStoreCookies: %ld cf %ld ",
		    (long) now, (long) co->expires));
d2164 1
a2164 1
		CTRACE((tfp, "not stored - DISCARD\n"));
d2167 1
a2167 1
		CTRACE((tfp, "not stored - no expiration time\n"));
d2170 1
a2170 1
		CTRACE((tfp, "not stored - EXPIRED\n"));
d2174 5
a2178 9
	    fprintf(cookie_handle, "%s\t%s\t%s\t%s\t%ld\t%s\t%s%s%s\n",
		    de->domain,
		    (de->domain[0] == '.') ? "TRUE" : "FALSE",
		    co->path,
		    co->flags & COOKIE_FLAG_SECURE ? "TRUE" : "FALSE",
		    (long) co->expires, co->name,
		    (co->quoted ? "\"" : ""),
		    NonNull(co->value),
		    (co->quoted ? "\"" : ""));
d2180 1
a2180 1
	    CTRACE((tfp, "STORED\n"));
d2183 1
a2183 1
    LYCloseOutput(cookie_handle);
d2190 22
a2211 21
 *	---------------
 *
 *  Lists all cookies by domain, and allows deletions of
 *  individual cookies or entire domains, and changes of
 *  'allow' settings.  The list is invoked via the COOKIE_JAR
 *  command (Ctrl-K), and deletions or changes of 'allow'
 *  settings are done by activating links in that list.
 *  The procedure uses a LYNXCOOKIE: internal URL scheme.
 *
 *  Semantics:
 *	LYNXCOOKIE:/			Create and load the Cookie Jar Page.
 *	LYNXCOOKIE://domain		Manipulate the domain.
 *	LYNXCOOKIE://domain/lynxID	Delete cookie with lynxID in domain.
 *
 *	New functions can be added as extensions to the path, and/or by
 *	assigning meanings to ;parameters, a ?searchpart, and/or #fragments.
 */
static int LYHandleCookies(const char *arg,
			   HTParentAnchor *anAnchor,
			   HTFormat format_out,
			   HTStream *sink)
d2226 1
a2226 1
     * Check whether we have something to do.  - FM
d2230 2
a2231 3
	LYSleepMsg();
	HTNoDataOK = 1;
	return (HT_NO_DATA);
d2235 3
a2237 3
     * If there's a domain string in the "host" field of the LYNXCOOKIE:  URL,
     * this is a request to delete something or change and 'allow' setting.  -
     * FM
d2244 3
a2246 3
	     * If there is a path string (not just a slash) in the LYNXCOOKIE: 
	     * URL, that's a cookie's lynxID and this is a request to delete it
	     * from the Cookie Jar.  - FM
d2257 1
a2257 1
	 * Seek the domain in the domain_list structure.  - FM
d2259 9
a2267 6
	if ((de = find_domain_entry(domain)) != NULL) {
	    FREE(domain);
	    /*
	     * We found the domain.  Check whether a lynxID is present.  - FM
	     */
	    if (lynxID) {
d2269 2
a2270 2
		 * Seek and delete the cookie with this lynxID in the domain's
		 * cookie list.  - FM
d2272 12
a2283 22
		for (cl = de->cookie_list; cl != NULL; cl = cl->next) {
		    if ((co = (cookie *) cl->object) == NULL)
			/*
			 * First object is always empty.  - FM
			 */
			continue;
		    if (!strcmp(lynxID, co->lynxID)) {
			/*
			 * We found the cookie.  Delete it if confirmed.  - FM
			 */
			if (HTConfirm(DELETE_COOKIE_CONFIRMATION) == FALSE) {
			    FREE(lynxID);
			    HTNoDataOK = 1;
			    return (HT_NO_DATA);
			}
			HTList_removeObject(de->cookie_list, co);
			freeCookie(co);
			co = NULL;
			total_cookies--;
			if ((de->bv == QUERY_USER &&
			     HTList_isEmpty(de->cookie_list)) &&
			    HTConfirm(DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
d2285 2
a2286 4
			     * No more cookies in this domain, no default
			     * accept/reject choice was set by the user, and
			     * got confirmation on deleting the domain, so do
			     * it.  - FM
d2288 29
a2316 8
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			} else {
			    HTProgress(COOKIE_EATEN);
a2317 3
			LYSleepMsg();
			HTNoDataOK = 1;
			break;
a2318 10
		}
	    } else {
		/*
		 * Prompt whether to delete all of the cookies in this domain,
		 * or the domain if no cookies in it, or to change its 'allow'
		 * setting, or to cancel, and then act on the user's response. 
		 * - FM
		 */
		if (HTList_isEmpty(de->cookie_list)) {
		    _statusline(DELETE_DOMAIN_SET_ALLOW_OR_CANCEL);
d2320 13
a2332 5
		    _statusline(DELETE_COOKIES_SET_ALLOW_OR_CANCEL);
		}
		HTNoDataOK = 1;
		while (1) {
		    ch = LYgetch_single();
d2334 4
a2337 4
		    if (HadVMSInterrupt) {
			HadVMSInterrupt = FALSE;
			ch = 'C';
		    }
d2339 98
a2436 16
		    switch (ch) {
		    case 'A':
			/*
			 * Set to accept all cookies from this domain.  - FM
			 */
			de->bv = ACCEPT_ALWAYS;
			HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
			return (HT_NO_DATA);

		    case 'C':
			/*
			 * Cancelled.  - FM
			 */
		      reject:
			HTUserMsg(CANCELLED);
			return (HT_NO_DATA);
d2438 2
a2439 50
		    case 'D':
			if (HTList_isEmpty(de->cookie_list)) {
			    /*
			     * We had an empty domain, so we were asked to
			     * delete it.  - FM
			     */
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			    LYSleepMsg();
			    break;
			}
		      Delete_all_cookies_in_domain:
			/*
			 * Delete all cookies in this domain.  - FM
			 */
			cl = de->cookie_list;
			while (cl) {
			    next = cl->next;
			    co = (cookie *) (cl->object);
			    if (co) {
				HTList_removeObject(de->cookie_list, co);
				freeCookie(co);
				co = NULL;
				total_cookies--;
			    }
			    cl = next;
			}
			HTProgress(DOMAIN_COOKIES_EATEN);
			LYSleepMsg();
			/*
			 * If a default accept/reject choice is set, we're
			 * done.  - FM
			 */
			if (de->bv != QUERY_USER)
			    return (HT_NO_DATA);
			/*
			 * Check whether to delete the empty domain.  - FM
			 */
			if (HTConfirm(DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			    LYSleepMsg();
a2441 25

		    case 'P':
			/*
			 * Set to prompt for cookie acceptance from this
			 * domain.  - FM
			 */
			de->bv = QUERY_USER;
			HTUserMsg2(PROMPTING_TO_ALLOW_COOKIES, de->domain);
			return (HT_NO_DATA);

		    case 'V':
			/*
			 * Set to reject all cookies from this domain.  - FM
			 */
			de->bv = REJECT_ALWAYS;
			HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
			if ((!HTList_isEmpty(de->cookie_list)) &&
			    HTConfirm(DELETE_ALL_COOKIES_IN_DOMAIN))
			    goto Delete_all_cookies_in_domain;
			return (HT_NO_DATA);

		    default:
			if (LYCharIsINTERRUPT(ch))
			    goto reject;
			continue;
a2442 1
		    break;
d2444 1
d2449 3
a2451 2
	     * There are no more domains left.  Don't delete the domain_list,
	     * otherwise atexit may be called multiple times.  - kw
d2454 1
a2454 1
	    LYSleepMsg();
d2458 1
a2458 1
	return (HT_NO_DATA);
d2462 5
a2466 4
     * If we get to here, it was a LYNXCOOKIE:/ URL for creating and displaying
     * the Cookie Jar Page, or we didn't find the domain or cookie in a
     * deletion request.  Set up an HTML stream and return an updated Cookie
     * Jar Page.  - FM
d2473 1
a2473 1
		   HTAtom_name(format_in), HTAtom_name(format_out));
d2476 1
a2476 1
	return (HT_NOT_LOADED);
d2480 2
a2481 2
     * Load HTML strings into buf and pass buf to the target for parsing and
     * rendering.  - FM
d2485 3
a2487 3
    HTSprintf0(&buf,
	       "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       COOKIE_JAR_TITLE);
d2490 3
a2492 3
	       LYNX_NAME, LYNX_VERSION,
	       HELP_ON_SEGMENT,
	       helpfilepath, COOKIE_JAR_HELP, COOKIE_JAR_TITLE);
d2495 1
a2495 1
    HTSprintf0(&buf, "<note>%s\n", ACTIVATE_TO_GOBBLE);
d2497 1
a2497 1
    HTSprintf0(&buf, "%s</note>\n", OR_CHANGE_ALLOW);
d2500 1
a2500 1
    HTSprintf0(&buf, "<dl compact>\n");
d2503 1
a2503 1
	de = (domain_entry *) (dl->object);
d2506 1
a2506 1
	     * First object always is NULL.  - FM
d2511 1
a2511 1
	 * Show the domain link and 'allow' setting.  - FM
d2513 2
a2514 2
	HTSprintf0(&buf, "<dt>%s<dd><a href=\"%s//%s/\">Domain=%s</a>\n",
		   de->domain, STR_LYNXCOOKIE, de->domain, de->domain);
d2517 14
a2530 9
	case (ACCEPT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_ALWAYS_ALLOWED);
	    break;
	case (REJECT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_NEVER_ALLOWED);
	    break;
	case (QUERY_USER):
	    HTSprintf0(&buf, COOKIES_ALLOWED_VIA_PROMPT);
	    break;
d2537 1
a2537 1
	 * Show the domain's cookies.  - FM
d2540 1
a2540 1
	    if ((co = (cookie *) cl->object) == NULL)
d2542 1
a2542 1
		 * First object is always NULL.  - FM
d2547 1
a2547 1
	     * Show the name=value pair.  - FM
d2561 2
a2562 2
	    HTSprintf0(&buf, "<dd><a href=\"%s//%s/%s\">%s=%s</a>\n",
		       STR_LYNXCOOKIE, de->domain, co->lynxID, name, value);
d2568 2
a2569 3
		HTSprintf0(&buf, "%s\n",
			   gettext("(from a previous session)"));
		PUTS(buf);
d2573 1
a2573 1
	     * Show the path, port, secure and discard setting.  - FM
d2581 4
a2584 5
	    HTSprintf0(&buf,
		       "<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",
		       path, co->port,
		       ((co->flags & COOKIE_FLAG_SECURE) ? "YES" : "NO"),
		       ((co->flags & COOKIE_FLAG_DISCARD) ? "YES" : "NO"));
d2589 1
a2589 1
	     * Show the list of acceptable ports, if present.  - FM
d2592 1
a2592 1
		HTSprintf0(&buf, "<dD>PortList=\"%s\"\n", co->PortList);
d2597 1
a2597 1
	     * Show the commentURL, if we have one.  - FM
d2605 3
a2607 3
			   "<dd>CommentURL: <a href=\"%s\">%s</a>\n",
			   Address,
			   Title);
d2614 1
a2614 1
	     * Show the comment, if we have one.  - FM
d2619 1
a2619 1
		HTSprintf0(&buf, "<dd>Comment: %s\n", comment);
d2625 1
a2625 1
	     * Show the Maximum Gobble Date.  - FM
d2627 4
a2630 4
	    HTSprintf0(&buf, "<dd><em>%s</em> %s%s",
		       gettext("Maximum Gobble Date:"),
		       ((co->flags & COOKIE_FLAG_EXPIRES_SET)
			?
d2632 3
a2634 3
		       ((co->flags & COOKIE_FLAG_EXPIRES_SET)
			?
			"" : "\n"));
d2637 1
a2637 1
	HTSprintf0(&buf, "</dt>\n");
d2640 1
a2640 1
    HTSprintf0(&buf, "</dl>\n</body>\n</html>\n");
d2644 2
a2645 2
     * Free the target to complete loading of the Cookie Jar Page, and report a
     * successful load.  - FM
d2647 1
a2647 1
    (*target->isa->_free) (target);
d2649 1
a2649 1
    return (HT_LOADED);
d2652 1
d2654 5
a2658 5
 *      ----------------------
 *      All purpose function to handle setting domain flags for a
 *      comma-delimited list of domains.  cookie_domain_flags handles
 *      invcheck behavior, as well as accept/reject behavior. - BJP
 */
d2660 3
a2662 2
static void cookie_domain_flag_set(char *domainstr,
				   int flag)
d2665 3
a2667 1
    char **str = typecalloc(char *);
d2670 1
d2672 2
a2673 5
    if (str == NULL) {
	HTAlwaysAlert(gettext("Internal"),
		      gettext("cookie_domain_flag_set error, aborting program"));
	exit_immediately(EXIT_FAILURE);
    }
d2676 2
a2677 1
     * Is this the first domain we're handling?  If so, initialize domain_list.
d2679 1
a2693 5
	if (*strsmall == '\0')
	    /* Never add a domain for empty string.  It would actually
	     * make more sense to use strtok here. - kw */
	    continue;

d2696 1
a2696 1
	 * re-setting of an already existing domain -- if so, just
d2700 14
a2713 2
	if ((de = find_domain_entry(strsmall)) == NULL) {
	    de = typecalloc(domain_entry);
d2715 1
a2715 4
		outofmem(__FILE__, "cookie_domain_flag_set");

	    de->bv = ACCEPT_ALWAYS;
	    de->invcheck_bv = INVCHECK_QUERY;
d2717 22
a2738 19
	    switch (flag) {
	    case (FLAG_ACCEPT_ALWAYS):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_REJECT_ALWAYS):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_QUERY_USER):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_INVCHECK_QUERY):
		de->bv = QUERY_USER;
		break;
	    case (FLAG_INVCHECK_STRICT):
		de->bv = QUERY_USER;
		break;
	    case (FLAG_INVCHECK_LOOSE):
		de->bv = QUERY_USER;
		break;
d2744 17
a2761 23
	switch (flag) {
	case (FLAG_ACCEPT_ALWAYS):
	    de->bv = ACCEPT_ALWAYS;
	    break;
	case (FLAG_REJECT_ALWAYS):
	    de->bv = REJECT_ALWAYS;
	    break;
	case (FLAG_QUERY_USER):
	    de->bv = QUERY_USER;
	    break;
	case (FLAG_INVCHECK_QUERY):
	    de->invcheck_bv = INVCHECK_QUERY;
	    break;
	case (FLAG_INVCHECK_STRICT):
	    de->invcheck_bv = INVCHECK_STRICT;
	    break;
	case (FLAG_INVCHECK_LOOSE):
	    de->invcheck_bv = INVCHECK_LOOSE;
	    break;
	}
	CTRACE((tfp,
		"cookie_domain_flag_set (%s, bv=%d, invcheck_bv=%d)\n",
		strsmall, de->bv, de->invcheck_bv));
a2768 43
/*
 * If any COOKIE_{ACCEPT,REJECT}_DOMAINS have been defined, process them.
 * These are comma delimited lists of domains.  - BJP
 *
 * And for query/strict/loose invalid cookie checking.  - BJP
 */
void LYConfigCookies(void)
{
    static const struct {
	char **domain;
	int flag;
	int once;
    } table[] = {
	/* *INDENT-OFF* */
	{ &LYCookieSAcceptDomains,	FLAG_ACCEPT_ALWAYS,   TRUE },
	{ &LYCookieSRejectDomains,	FLAG_REJECT_ALWAYS,   TRUE },
	{ &LYCookieSStrictCheckDomains, FLAG_INVCHECK_STRICT, TRUE },
	{ &LYCookieSLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  TRUE },
	{ &LYCookieSQueryCheckDomains,	FLAG_INVCHECK_QUERY,  TRUE },
	{ &LYCookieAcceptDomains,	FLAG_ACCEPT_ALWAYS,   FALSE },
	{ &LYCookieRejectDomains,	FLAG_REJECT_ALWAYS,   FALSE },
	{ &LYCookieStrictCheckDomains,	FLAG_INVCHECK_STRICT, FALSE },
	{ &LYCookieLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  FALSE },
	{ &LYCookieQueryCheckDomains,	FLAG_INVCHECK_QUERY,  FALSE },
	/* *INDENT-ON* */

    };
    unsigned n;

    for (n = 0; n < TABLESIZE(table); n++) {
	if (*(table[n].domain) != NULL) {
	    cookie_domain_flag_set(*(table[n].domain), table[n].flag);
	    /*
	     * Discard the value for system settings after we've used them.
	     * The local settings will be merged with the contents of .lynxrc
	     */
	    if (table[n].once) {
		FREE(*(table[n].domain));
	    }
	}
    }
}

d2771 1
a2771 1
GLOBALDEF(HTProtocol, LYLynxCookies, _LYCOOKIE_C_GLOBALDEF_1_INIT);
d2773 1
a2773 2
GLOBALDEF HTProtocol LYLynxCookies =
{"LYNXCOOKIE", LYHandleCookies, 0};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a76 3
/* default for new domains, one of the invcheck_behaviour_t values: */
#define DEFAULT_INVCHECK_BV INVCHECK_QUERY

d132 1
a132 1
    temp = typecallocn(char, (end - start) + 1);
d142 1
a142 1
    cookie *p = typecalloc(cookie);
a174 1
    CTRACE((tfp, "LYCookieJar_free\n"));
a176 1
	    CTRACE((tfp, "...LYCookieJar_free domain %s\n", de->domain));
d241 1
a241 1
    if (!(number && isdigit(UCH(*number))))
d248 1
a248 1
	while (isdigit(UCH(*number))) {
d251 1
a251 1
	while (*number != '\0' && !isdigit(UCH(*number))) {
a259 69
 * Returns the length of the given path ignoring trailing slashes.
 */
PRIVATE int ignore_trailing_slash ARGS1(CONST char *, a)
{
    int len = strlen(a);
    while (len > 1 && a[len-1] == '/')
	--len;
    return len;
}

/*
 * Check if the path 'a' is a prefix of path 'b', ignoring trailing slashes
 * in either, since they denote an empty component.
 */
PRIVATE BOOL is_prefix ARGS2(CONST char *, a, CONST char *, b)
{
    int len_a = ignore_trailing_slash(a);
    int len_b = ignore_trailing_slash(b);

    if (len_a > len_b) {
	return FALSE;
    } else {
	if (strncmp(a, b, len_a) != 0) {
	    return FALSE;
	}
	if (len_a < len_b && (len_a > 1 || a[0] != '/')) {
	    if (b[len_a] != '\0'
	     && b[len_a] != '/') {
		return FALSE;
	     }
	}
    }
    return TRUE;
}

/*
 * Find the domain-entry for the given name.
 */
PRIVATE domain_entry * find_domain_entry ARGS1(
    CONST char *,	name)
{
    HTList *hl;
    domain_entry *de = NULL;

    if (name != 0
     && *name != '\0') {
	for (hl = domain_list; hl != NULL; hl = hl->next) {
	    de = (domain_entry *)hl->object;
	    if (de != NULL && de->domain != NULL) {
		CTRACE2(TRACE_CFG,
			(tfp, "...test_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
			      de->domain,
			      de->bv,
			      de->invcheck_bv));
		if (!strcasecomp(name, de->domain)) {
		    break;
		}
	    }
	    de = NULL;
	}
    }
    CTRACE((tfp, "find_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
		 name,
		 de ? (int) de->bv : -1,
		 de ? (int) de->invcheck_bv : -1));
    return de;
}

/*
a273 3
    int invprompt_reasons = 0;	/* what is wrong with this cookie - kw */
#define FAILS_COND1 0x01
#define FAILS_COND4 0x02
d294 13
a306 2
    if ((de = find_domain_entry(co->domain)) != NULL)
	cookie_list = de->cookie_list;
d318 27
a344 16
    if (!is_prefix(co->path, path)) {
	invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
					       : DEFAULT_INVCHECK_BV);
	switch (invcheck_bv) {
	case INVCHECK_LOOSE:
	    break;		/* continue as if nothing were wrong */

	case INVCHECK_QUERY:
	    invprompt_reasons |= FAILS_COND1;
	    break;		/* will prompt later if we get that far */

	case INVCHECK_STRICT:
	    CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		   co->path, path));
	    freeCookie(co);
	    return;
a346 1

d356 2
a357 2
	    CTRACE((tfp, "store_cookie: Rejecting because '%s' has no dot.\n",
		    hostname));
d359 1
d371 2
a372 1
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n", co->domain));
d374 1
d379 2
a380 1
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n", co->domain));
d382 1
d391 2
a392 2
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
		    co->domain, hostname));
d394 1
d409 29
a437 41
	    invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
						   : DEFAULT_INVCHECK_BV);
	    switch (invcheck_bv) {
	    case INVCHECK_LOOSE:
		break;		/* continue as if nothing were wrong */

	    case INVCHECK_QUERY:
		invprompt_reasons |= FAILS_COND4;
		break;		/* will prompt later if we get that far */

	    case INVCHECK_STRICT:
		CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		       co->path, path));
		freeCookie(co);
		return;
	    }
	}
    }

    /*
     *  If we found reasons for issuing an invalid cookie confirmation
     *  prompt, do that now.  Rejection by the user here is the last
     *  chance to completely ignore this cookie; after it passes this
     *  hurdle, it may at least supersede a previous cookie (even if
     *  it finally gets rejected). - kw
     */
    if (invprompt_reasons) {
	char *msg = 0;
	if (invprompt_reasons & FAILS_COND4) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_DOMAIN_CONFIRMATION,
		       co->domain,
		       hostname);
	    if (!HTForcedPrompt(cookie_noprompt, msg, NO)) {
		CTRACE((tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
			co->domain,
			hostname));
		freeCookie(co);
		FREE(msg);
		return;
	    }
a438 13
	if (invprompt_reasons & FAILS_COND1) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_PATH_CONFIRMATION,
		       co->path, path);
	    if (!HTForcedPrompt(cookie_noprompt, msg, NO)) {
		CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		       co->path, path));
		freeCookie(co);
		FREE(msg);
		return;
	    }
	}
	FREE(msg);
d441 1
a441 1
    if (de == NULL) {
d443 1
a443 1
	 * Domain not found; add a new entry for this domain.
d445 1
a445 1
	de = typecalloc(domain_entry);
d448 17
a464 2
	de->bv = QUERY_USER;
	de->invcheck_bv = DEFAULT_INVCHECK_BV; /* should this go here? */
d493 1
a493 1
		   !strcasecomp(co->domain, c2->domain) &&
d535 1
a535 1
	CTRACE((tfp, "store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n"));
d543 1
a543 1
	CTRACE((tfp, "store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n"));
d550 2
a551 7
	/*
	 * Presence of value is now needed (indicated normally by '='),
	 * but it can now be an empty string.
	 * - kw 1999-06-24
	 */
    } else if (co->value == NULL) { /* should not happen - kw */
	CTRACE((tfp, "store_cookie: Value is NULL! Not storing cookie.\n"));
d594 2
a595 2
	char *,		hostname,
	char *,		path,
d598 1
a598 1
	char *,		header,
d612 2
a613 4
       if ((co) && /* speed-up host_matches() and limit trace output */
	   (LYstrstr(hostname, co->domain) != NULL))
       {
	    CTRACE((tfp, "Checking cookie %p %s=%s\n",
d616 2
a617 2
			(co->value ? co->value : "(no value)")));
	    CTRACE((tfp, "\t%s %s %d %s %s %d%s\n",
d623 1
a623 1
			    ? !is_prefix(co->path, path)
d627 1
a627 1
			    : ""));
d645 1
a645 1
	    (co->pathlen == 0 || is_prefix(co->path, path))) {
d741 1
a741 1
		if (co->PortList && isdigit(UCH(*co->PortList))) {
a767 255
 * Presence of value is needed (indicated normally by '=') to start a cookie,
 * but it can be an empty string.  - kw 1999-06-24
 */
PRIVATE char *alloc_attr_value ARGS2(
	CONST char *,	value_start,
	CONST char *,	value_end)
{
    char *value = NULL;

    if (value_start && value_end >= value_start) {
	int value_len = (value_end - value_start);

	if (value_len > max_cookies_buffer) {
	    value_len = max_cookies_buffer;
	}
	value = typecallocn(char, value_len + 1);
	if (value == NULL)
	    outofmem(__FILE__, "LYProcessSetCookies");
	LYstrncpy(value, value_start, value_len);
    }
    return value;
}

#define FLAGS_INVALID_PORT 1
#define FLAGS_KNOWN_ATTR   2
#define FLAGS_MAXAGE_ATTR  4

#define is_attr(s, len) attr_len == len && !strncasecomp(attr_start, s, len)

PRIVATE unsigned parse_attribute ARGS9(
	unsigned,	flags,
	cookie *,	cur_cookie,
	int *,		cookie_len,
	CONST char *,	attr_start,
	int,		attr_len,
	char *,		value,
	CONST char *,	address,
	char *,		hostname,
	int,		port)
{
    BOOLEAN known_attr = NO;
    int url_type;

    flags &= ~FLAGS_KNOWN_ATTR;
    if (is_attr("secure", 6)) {
	if (value == NULL) {
	    known_attr = YES;
	    if (cur_cookie != NULL) {
		cur_cookie->flags |= COOKIE_FLAG_SECURE;
	    }
	} else {
	    /*
	     *	If secure has a value, assume someone
	     *	misused it as cookie name. - FM
	     */
	    known_attr = NO;
	}
    } else if (is_attr("discard", 7)) {
	if (value == NULL) {
	    known_attr = YES;
	    if (cur_cookie != NULL) {
		cur_cookie->flags |= COOKIE_FLAG_DISCARD;
	    }
	} else {
	    /*
	     *	If discard has a value, assume someone
	     *	used it as a cookie name. - FM
	     */
	    known_attr = NO;
	}
    } else if (is_attr("comment", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	    /*
	     *	Don't process a repeat comment. - FM
	     */
	    cur_cookie->comment == NULL) {
	    StrAllocCopy(cur_cookie->comment, value);
	    *cookie_len += strlen(cur_cookie->comment);
	}
    } else if (is_attr("commentURL", 10)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	    /*
	     *	Don't process a repeat commentURL. - FM
	     */
	    cur_cookie->commentURL == NULL) {
	    /*
	     *	We should get only absolute URLs as
	     *	values, but will resolve versus the
	     *	request's URL just in case. - FM
	     */
	    cur_cookie->commentURL = HTParse(value,
					     address,
					     PARSE_ALL);
	    /*
	     *	Accept only URLs for http or https servers. - FM
	     */
	    if ((url_type = is_url(cur_cookie->commentURL)) &&
		(url_type == HTTP_URL_TYPE ||
		 url_type == HTTPS_URL_TYPE)) {
		*cookie_len += strlen(cur_cookie->commentURL);
	    } else {
		CTRACE((tfp, "LYProcessSetCookies: Rejecting commentURL value '%s'\n",
			    cur_cookie->commentURL));
		FREE(cur_cookie->commentURL);
	    }
	}
    } else if (is_attr("domain", 6)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	    /*
	     *	Don't process a repeat domain. - FM
	     */
	    !(cur_cookie->flags & COOKIE_FLAG_DOMAIN_SET)) {
	    *cookie_len -= strlen(cur_cookie->domain);
	    /*
	     *	If the value does not have a lead dot,
	     *	but does have an embedded dot, and is
	     *	not an exact match to the hostname, nor
	     *	is a numeric IP address, add a lead dot.
	     *	Otherwise, use the value as is. - FM
	     *	(domains - case insensitive).
	     */
	    if (value[0] != '.' && value[0] != '\0' &&
		value[1] != '\0' && strcasecomp(value, hostname)) {
		char *ptr = strchr(value, '.');
		if (ptr != NULL && ptr[1] != '\0') {
		    ptr = value;
		    while (*ptr == '.' ||
			   isdigit(UCH(*ptr)))
			ptr++;
		    if (*ptr != '\0') {
			CTRACE((tfp,
       "LYProcessSetCookies: Adding lead dot for domain value '%s'\n",
				    value));
			StrAllocCopy(cur_cookie->domain, ".");
			StrAllocCat(cur_cookie->domain, value);
		    } else {
			StrAllocCopy(cur_cookie->domain, value);
		    }
		} else {
		    StrAllocCopy(cur_cookie->domain, value);
		}
	    } else {
		StrAllocCopy(cur_cookie->domain, value);
	    }
	    *cookie_len += strlen(cur_cookie->domain);
	    cur_cookie->flags |= COOKIE_FLAG_DOMAIN_SET;
	}
    } else if (is_attr("path", 4)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	    /*
	     *	Don't process a repeat path. - FM
	     */
	    !(cur_cookie->flags & COOKIE_FLAG_PATH_SET)) {
	    *cookie_len -= strlen(cur_cookie->path);
	    StrAllocCopy(cur_cookie->path, value);
	    *cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
	    cur_cookie->flags |= COOKIE_FLAG_PATH_SET;
	}
    } else if (is_attr("port", 4)) {
	if (cur_cookie != NULL && value &&
	    /*
	     *	Don't process a repeat port. - FM
	     */
	    cur_cookie->PortList == NULL) {
	    char *cp = value;
	    while ((*cp != '\0') &&
		   (isdigit(UCH(*cp)) ||
		    *cp == ',' || *cp == ' ')) {
		cp++;
	    }
	    if (*cp == '\0') {
		if (!port_matches(port, value)) {
		    flags |= FLAGS_INVALID_PORT;
		} else {
		    StrAllocCopy(cur_cookie->PortList, value);
		    *cookie_len += strlen(cur_cookie->PortList);
		}
		known_attr = YES;
	    } else {
		known_attr = NO;
	    }
	} else if (cur_cookie != NULL) {
	    /*
	     *	Don't process a repeat port. - FM
	     */
	    if (cur_cookie->PortList == NULL) {
		HTSprintf0(&(cur_cookie->PortList), "%d", port);
		*cookie_len += strlen(cur_cookie->PortList);
	    }
	    known_attr = YES;
	}
    } else if (is_attr("version", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	    /*
	     *	Don't process a repeat version. - FM
	     */
	    cur_cookie->version < 1) {
	    int temp = strtol(value, NULL, 10);
	    if (errno != -ERANGE) {
		cur_cookie->version = temp;
	    }
	}
    } else if (is_attr("max-age", 7)) {
	known_attr = YES;
	if (cur_cookie != NULL && value &&
	    /*
	     *	Don't process a repeat max-age. - FM
	     */
	    !(flags & FLAGS_MAXAGE_ATTR)) {
	    int temp = strtol(value, NULL, 10);
	    cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
	    if (errno == -ERANGE) {
		cur_cookie->expires = (time_t)0;
	    } else {
		cur_cookie->expires = (time(NULL) + temp);
		CTRACE((tfp, "LYSetCookie: expires %ld, %s",
			    (long) cur_cookie->expires,
			    ctime(&cur_cookie->expires)));
	    }
	    flags |= FLAGS_MAXAGE_ATTR;
	}
    } else if (is_attr("expires", 7)) {
	/*
	 *  Convert an 'expires' attribute value if we haven't
	 *  received a 'max-age'.  Note that 'expires' should not
	 *  be used in Version 1 cookies, but it might be used for
	 *  "backward compatibility", and, in turn, ill-informed
	 *  people surely would start using it instead of, rather
	 *  than in addition to, 'max-age'. - FM
	 */
	known_attr = YES;
	if ((cur_cookie != NULL && !(flags & FLAGS_MAXAGE_ATTR)) &&
	     !(cur_cookie->flags & COOKIE_FLAG_EXPIRES_SET)) {
	    if (value) {
		cur_cookie->flags |= COOKIE_FLAG_EXPIRES_SET;
		cur_cookie->expires = LYmktime(value, FALSE);
		if (cur_cookie->expires > 0) {
		    CTRACE((tfp, "LYSetCookie: expires %ld, %s",
				(long) cur_cookie->expires,
				ctime(&cur_cookie->expires)));
		}
	    }
	}
    }
    if (known_attr)
	flags |= FLAGS_KNOWN_ATTR;
    return flags;
}

/*
d775 2
a776 2
	char *,		hostname,
	char *,		path,
d782 1
a782 1
    int cookie_len = 0;
d784 1
d786 1
a786 1
    unsigned parse_flags = 0;
d812 1
a812 1
    p = NonNull(SetCookie2);
d814 1
a814 1
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie2 header.\n"));
d823 1
a823 1
	while (*p != '\0' && !isspace(UCH(*p)) &&
d862 1
a862 1
		if (isdigit(UCH(*p))) {
d871 1
a871 1
		    while (*p != '\0' && isalpha(UCH(*p))) {
d874 1
a874 1
		    while (*p == ',' || isspace(UCH(*p))) {
d881 2
a882 2
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
d899 1
a899 1
		       isdigit(UCH(*p))) {
d906 1
a906 1
		    while (isdigit(UCH(*p)))
d914 1
a914 1
			if (*cp != '\0' && isdigit(UCH(*cp))) {
d916 1
a916 1
			    while (isdigit(UCH(*cp1)))
d932 1
a932 1
			isspace(UCH(*(value_end - 1)))) {
d935 2
a936 2
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
a942 1
		BOOLEAN escaped = FALSE;
d944 1
a944 1
		 *  It looks like quoted string.
d948 1
a948 2
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
d950 2
a951 3
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
a952 8
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
d965 1
a965 1
		    isspace(UCH(*(value_end - 1)))) {
d968 2
a969 2
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
d986 220
a1205 1
	    char *value = alloc_attr_value(value_start, value_end);
d1207 16
a1222 17
	    parse_flags = parse_attribute (parse_flags,
					   cur_cookie,
					   &cookie_len,
					   attr_start,
					   (attr_end - attr_start),
					   value,
					   address,
					   hostname,
					   port);

	    /*
	     * Presence of value is needed (indicated normally by '='),
	     * but it can be an empty string. - kw 1999-06-24
	     */
	    if (!(parse_flags & FLAGS_KNOWN_ATTR)
	      && value
	      && value_end >= value_start) {
d1227 2
a1228 3
		if (cookie_len <= max_cookies_buffer
		 && cur_cookie != NULL
		 && !(parse_flags & FLAGS_INVALID_PORT)) {
d1237 1
a1237 1
		    CTRACE((tfp,
d1242 3
a1244 3
				 cur_cookie->value : "[no value]")));
		    CTRACE((tfp,
			   (parse_flags & FLAGS_INVALID_PORT) ?
d1246 2
a1247 2
			 : "                     due to invalid port!\n"));
		    if (parse_flags & FLAGS_INVALID_PORT) {
d1257 2
a1258 1
		cookie_len = 0;
d1261 1
a1261 1
		cookie_len += strlen(cur_cookie->name);
d1263 1
a1263 1
		cookie_len += strlen(cur_cookie->value);
d1265 1
a1265 1
		cookie_len += strlen(cur_cookie->domain);
d1267 1
a1267 1
		cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
d1269 1
a1269 1
		parse_flags = 0;
d1281 2
a1282 2
     && cookie_len <= max_cookies_buffer
     && cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
d1287 2
a1288 2
    } else if (cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
d1290 4
a1293 4
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
		    (cookie_len > max_cookies_buffer ? "length" : ""),
		    (cookie_len > max_cookies_buffer &&
d1297 1
a1297 1
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1301 1
a1301 1
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
d1303 2
a1304 2
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to invalid port!\n"));
d1314 1
a1314 1
    cookie_len = 0;
d1319 1
a1319 1
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie header.\n"));
d1328 1
a1328 1
	while (*p != '\0' && !isspace(UCH(*p)) &&
d1363 1
a1363 1
		if (isdigit(UCH(*p))) {
d1372 1
a1372 1
		    while (*p != '\0' && isalpha(UCH(*p))) {
d1375 1
a1375 1
		    while (*p == ',' || isspace(UCH(*p))) {
d1382 2
a1383 2
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
d1400 1
a1400 1
		       isdigit(UCH(*p))) {
d1407 1
a1407 1
		    while (isdigit(UCH(*p)))
d1415 1
a1415 1
			if (*cp != '\0' && isdigit(UCH(*cp))) {
d1417 1
a1417 1
			    while (isdigit(UCH(*cp1)))
d1433 1
a1433 1
			isspace(UCH(*(value_end - 1)))) {
d1436 2
a1437 2
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
a1443 1
		BOOLEAN escaped = FALSE;
d1445 1
a1445 1
		 *  It looks like quoted string.
d1449 1
a1449 2
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
d1451 2
a1452 3
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
d1454 1
a1454 8
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
d1467 1
a1467 1
		    isspace(UCH(*(value_end - 1)))) {
d1470 2
a1471 2
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
d1488 205
a1692 1
	    char *value = alloc_attr_value(value_start, value_end);
d1694 16
a1709 17
	    parse_flags = parse_attribute (parse_flags,
					   cur_cookie,
					   &cookie_len,
					   attr_start,
					   (attr_end - attr_start),
					   value,
					   address,
					   hostname,
					   port);

	    /*
	     * Presence of value is needed (indicated normally by '='),
	     * but it can be an empty string. - kw 1999-06-24
	     */
	    if (!(parse_flags & FLAGS_KNOWN_ATTR)
	      && value
	      && value_end >= value_start) {
d1714 1
a1714 2
		if (cookie_len <= max_cookies_buffer
		 && cur_cookie != NULL) {
d1728 1
a1728 1
		    CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
d1732 2
a1733 2
				 cur_cookie->value : "[no value]")));
		    CTRACE((tfp, "                     due to excessive length!\n"));
d1741 1
a1741 2
		NumCookies++;
		cookie_len = 0;
d1743 1
a1743 1
		cookie_len += strlen(cur_cookie->name);
d1745 1
a1745 1
		cookie_len += strlen(cur_cookie->value);
d1747 1
a1747 1
		cookie_len += strlen(cur_cookie->domain);
d1749 1
a1749 1
		cookie_len += (cur_cookie->pathlen = strlen(cur_cookie->path));
d1751 1
a1751 1
		parse_flags = 0;
d1762 1
a1762 1
    if (NumCookies <= max_cookies_domain && cookie_len <= max_cookies_buffer && cur_cookie != NULL) {
d1771 1
a1771 1
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
d1773 5
a1777 5
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
		    (cookie_len > max_cookies_buffer ? "length" : ""),
		    (cookie_len > max_cookies_buffer && NumCookies > max_cookies_domain ? " and " : ""),
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1788 1
a1788 1
	CTRACE((tfp, "LYProcessSetCookie: attr=value pair: '%s=%s'\n",
d1790 1
a1790 1
			    (co->value ? co->value : "[no value]")));
d1792 1
a1792 1
		CTRACE((tfp, "                    expires: %ld, %s\n",
d1794 1
a1794 1
			    ctime(&co->expires)));
d1796 1
a1796 1
	if (isHTTPS_URL(address) &&
d1800 1
a1800 1
	    CTRACE((tfp, "                    Forced the 'secure' flag on.\n"));
d1837 1
a1837 1
    } else if (isHTTPS_URL(address)) {
d1858 3
a1860 3
    CTRACE((tfp, "LYSetCookie called with host '%s', path '%s',\n",
		NonNull(hostname),
		NonNull(path)));
d1862 2
a1863 1
	CTRACE((tfp, "    and Set-Cookie: '%s'\n", SetCookie));
d1866 2
a1867 1
	CTRACE((tfp, "    and Set-Cookie2: '%s'\n", SetCookie2));
d1870 1
a1870 1
	CTRACE((tfp, "    Ignoring this Set-Cookie/Set-Cookie2 request.\n"));
d1895 3
a1897 3
PUBLIC char * LYAddCookieHeader ARGS4(
	char *,		hostname,
	char *,		path,
d1905 2
a1906 2
    CTRACE((tfp, "LYCookie: Searching for '%s:%d', '%s'.\n",
		NONNULL(hostname),
d1908 1
a1908 1
		NONNULL(path)));
d1921 3
a1923 2
		 * Scan the domain's cookie_list for any cookies we should
		 * include in our request header.
d1927 1
a1927 1
	    } else if (de->bv == QUERY_USER && de->invcheck_bv == DEFAULT_INVCHECK_BV) {
d1929 3
a1931 2
		 * No cookies in this domain, and no default accept/reject
		 * choice was set by the user, so delete the domain.  - FM
d1974 1
a1974 1
    cookie_handle = fopen(cookie_file, TXT_R);
d1978 1
a1978 1
    CTRACE((tfp, "LYLoadCookies: reading cookies from %s\n", cookie_file));
d1983 1
d1987 1
a1987 2
	LYTrimNewline(buf);
	if (buf[0] == '\0' || buf[0] == '#') {
d1993 9
a2001 1
	strcat(buf, "\t");	/* add sep after line if enough space - kw */
d2013 1
a2013 7
	/*
	 * This fails when the path is blank
	 *
	 * sscanf(buf, "%s\t%s\t%s\t%s\t%d\t%s\t%[ -~]",
	 *  domain, what, path, secure, &expires, name, value);
	 */
	CTRACE((tfp, "LYLoadCookies: tokenising %s\n", buf));
d2017 2
a2018 2
	    CTRACE((tfp, "\t%d:[%03d]:[%s]\n",
		tok_loop, tok_out - buf, tok_out));
d2028 1
d2030 6
a2035 5
	if (tok_values[tok_loop].s) {
	    /* tok_out in above loop must have been NULL prematurely - kw */
	    CTRACE((tfp, "*** wrong format: not enough tokens, ignoring line!\n"));
	    continue;
	}
d2037 3
a2039 4
	expires = atol(expires_a);
	CTRACE((tfp, "expires:\t%s\n", ctime(&expires)));
/*	CTRACE((tfp, "%s\t%s\t%s\t%s\t%ld\t%s\t%s\tREADCOOKIE\n", */
/*	    domain, what, path, secure, (long) expires, name, value)); */
d2044 1
a2044 9
	if (value && value[0] == '"' &&
	    value[1] && value[strlen(value)-1] == '"' &&
	    value[strlen(value)-2] != '\\') {
	    value[strlen(value)-1] = '\0';
	    StrAllocCopy(moo->value, value+1);
	    moo->quoted = TRUE;
	} else {
	    StrAllocCopy(moo->value, value);
	}
d2079 1
a2079 1
			COOKIE_FLAG_PATH_SET;
d2094 1
a2094 1
    LYCloseInput (cookie_handle);
d2101 3
a2109 5
    if (!strcmp(cookie_file, "/dev/null")) {
	/* We give /dev/null the Unix meaning, regardless of OS */
	return;
    }

d2121 1
a2121 1
    CTRACE((tfp, "LYStoreCookies: save cookies to %s on exit\n", cookie_file));
d2133 18
d2161 1
a2161 2
	    CTRACE((tfp, "LYStoreCookies: %ld cf %ld ",
		   (long) now, (long) co->expires));
d2164 1
a2164 1
		CTRACE((tfp, "not stored - DISCARD\n"));
d2167 1
a2167 1
		CTRACE((tfp, "not stored - no expiration time\n"));
d2170 1
a2170 1
		CTRACE((tfp, "not stored - EXPIRED\n"));
d2174 5
a2178 9
	    fprintf(cookie_handle, "%s\t%s\t%s\t%s\t%ld\t%s\t%s%s%s\n",
		    de->domain,
		    (de->domain[0] == '.') ? "TRUE" : "FALSE",
		    co->path,
		    co->flags & COOKIE_FLAG_SECURE ? "TRUE" : "FALSE",
		    (long) co->expires, co->name,
		    (co->quoted ? "\"" : ""),
		    NonNull(co->value),
		    (co->quoted ? "\"" : ""));
d2180 1
a2180 1
	    CTRACE((tfp, "STORED\n"));
d2183 1
a2183 1
    LYCloseOutput(cookie_handle);
d2230 1
a2230 2
	LYSleepMsg();
	HTNoDataOK = 1;
d2259 9
a2267 7
	if ((de = find_domain_entry(domain)) != NULL) {
	    FREE(domain);
	    /*
	     *  We found the domain.  Check
	     *  whether a lynxID is present. - FM
	     */
	    if (lynxID) {
d2269 2
a2270 2
		 *	Seek and delete the cookie with this lynxID
		 *	in the domain's cookie list. - FM
d2272 12
a2283 24
		for (cl = de->cookie_list; cl != NULL; cl = cl->next) {
		    if ((co = (cookie *)cl->object) == NULL)
			/*
			 *	First object is always empty. - FM
			 */
			continue;
		    if (!strcmp(lynxID, co->lynxID)) {
			/*
			 *	We found the cookie.
			 *	Delete it if confirmed. - FM
			 */
			if (HTConfirm(DELETE_COOKIE_CONFIRMATION) == FALSE)
			{
			    FREE(lynxID);
			    HTNoDataOK = 1;
			    return(HT_NO_DATA);
			}
			HTList_removeObject(de->cookie_list, co);
			freeCookie(co);
			co = NULL;
			total_cookies--;
			if ((de->bv == QUERY_USER &&
			     HTList_isEmpty(de->cookie_list)) &&
			    HTConfirm(DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
d2285 2
a2286 4
			     *  No more cookies in this domain, no
			     *  default accept/reject choice was set
			     *  by the user, and got confirmation on
			     *  deleting the domain, so do it. - FM
d2288 29
a2316 8
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			} else {
			    HTProgress(COOKIE_EATEN);
a2317 3
			LYSleepMsg();
			HTNoDataOK = 1;
			break;
a2318 10
		}
	    } else {
		/*
		 * Prompt whether to delete all of the cookies in this domain,
		 * or the domain if no cookies in it, or to change its 'allow'
		 * setting, or to cancel, and then act on the user's response. 
		 * - FM
		 */
		if (HTList_isEmpty(de->cookie_list)) {
		    _statusline(DELETE_DOMAIN_SET_ALLOW_OR_CANCEL);
d2320 13
a2332 5
		    _statusline(DELETE_COOKIES_SET_ALLOW_OR_CANCEL);
		}
		HTNoDataOK = 1;
		while (1) {
		    ch = LYgetch_single();
d2334 4
a2337 4
		    if (HadVMSInterrupt) {
			HadVMSInterrupt = FALSE;
			ch = 'C';
		    }
d2339 98
a2436 16
		    switch(ch) {
		    case 'A':
			/*
			 * Set to accept all cookies from this domain.  - FM
			 */
			de->bv = ACCEPT_ALWAYS;
			HTUserMsg2(ALWAYS_ALLOWING_COOKIES, de->domain);
			return(HT_NO_DATA);

		    case 'C':
			/*
			 * Cancelled.  - FM
			 */
		      reject:
			HTUserMsg(CANCELLED);
			return(HT_NO_DATA);
d2438 2
a2439 50
		    case 'D':
			if (HTList_isEmpty(de->cookie_list)) {
			    /*
			     * We had an empty domain, so we were asked to
			     * delete it.  - FM
			     */
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			    LYSleepMsg();
			    break;
			}
Delete_all_cookies_in_domain:
			/*
			 * Delete all cookies in this domain.  - FM
			 */
			cl = de->cookie_list;
			while (cl) {
			    next = cl->next;
			    co = cl->object;
			    if (co) {
				HTList_removeObject(de->cookie_list, co);
				freeCookie(co);
				co = NULL;
				total_cookies--;
			    }
			    cl = next;
			}
			HTProgress(DOMAIN_COOKIES_EATEN);
			LYSleepMsg();
			/*
			 * If a default accept/reject choice is set, we're
			 * done.  - FM
			 */
			if (de->bv != QUERY_USER)
			    return(HT_NO_DATA);
			/*
			 * Check whether to delete the empty domain.  - FM
			 */
			if (HTConfirm(DELETE_EMPTY_DOMAIN_CONFIRMATION)) {
			    FREE(de->domain);
			    HTList_delete(de->cookie_list);
			    de->cookie_list = NULL;
			    HTList_removeObject(domain_list, de);
			    FREE(de);
			    HTProgress(DOMAIN_EATEN);
			    LYSleepMsg();
a2441 25

		    case 'P':
			/*
			 * Set to prompt for cookie acceptance from this
			 * domain.  - FM
			 */
			de->bv = QUERY_USER;
			HTUserMsg2(PROMPTING_TO_ALLOW_COOKIES, de->domain);
			return(HT_NO_DATA);

		    case 'V':
			/*
			 * Set to reject all cookies from this domain.  - FM
			 */
			de->bv = REJECT_ALWAYS;
			HTUserMsg2(NEVER_ALLOWING_COOKIES, de->domain);
			if ((!HTList_isEmpty(de->cookie_list)) &&
			    HTConfirm(DELETE_ALL_COOKIES_IN_DOMAIN))
			    goto Delete_all_cookies_in_domain;
			return(HT_NO_DATA);

		    default:
			if (LYCharIsINTERRUPT(ch))
			    goto reject;
			continue;
a2442 1
		    break;
d2444 1
d2449 3
a2451 2
	     * There are no more domains left.  Don't delete the domain_list,
	     * otherwise atexit may be called multiple times.  - kw
d2454 1
a2454 1
	    LYSleepMsg();
d2462 5
a2466 4
     * If we get to here, it was a LYNXCOOKIE:/ URL for creating and displaying
     * the Cookie Jar Page, or we didn't find the domain or cookie in a
     * deletion request.  Set up an HTML stream and return an updated Cookie
     * Jar Page.  - FM
d2480 2
a2481 2
     * Load HTML strings into buf and pass buf to the target for parsing and
     * rendering.  - FM
d2486 1
a2486 1
    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
d2495 1
a2495 1
    HTSprintf0(&buf, "<note>%s\n", ACTIVATE_TO_GOBBLE);
d2497 1
a2497 1
    HTSprintf0(&buf, "%s</note>\n", OR_CHANGE_ALLOW);
d2500 1
a2500 1
    HTSprintf0(&buf, "<dl compact>\n");
d2513 2
a2514 2
	HTSprintf0(&buf, "<dt>%s<dd><a href=\"%s//%s/\">Domain=%s</a>\n",
		      de->domain, STR_LYNXCOOKIE, de->domain, de->domain);
d2517 14
a2530 9
	case (ACCEPT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_ALWAYS_ALLOWED);
	    break;
	case (REJECT_ALWAYS):
	    HTSprintf0(&buf, COOKIES_NEVER_ALLOWED);
	    break;
	case (QUERY_USER):
	    HTSprintf0(&buf, COOKIES_ALLOWED_VIA_PROMPT);
	    break;
d2561 2
a2562 2
	    HTSprintf0(&buf, "<dd><a href=\"%s//%s/%s\">%s=%s</a>\n",
			 STR_LYNXCOOKIE, de->domain, co->lynxID, name, value);
d2569 1
a2569 1
		PUTS(buf);
d2581 1
a2581 1
	    HTSprintf0(&buf, "<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",
d2592 1
a2592 1
		HTSprintf0(&buf, "<dD>PortList=\"%s\"\n", co->PortList);
d2605 1
a2605 1
			"<dd>CommentURL: <a href=\"%s\">%s</a>\n",
d2619 1
a2619 1
		HTSprintf0(&buf, "<dd>Comment: %s\n", comment);
d2627 2
a2628 2
	    HTSprintf0(&buf, "<dd><em>%s</em> %s%s",
			 gettext("Maximum Gobble Date:"),
d2637 1
a2637 1
	HTSprintf0(&buf, "</dt>\n");
d2640 1
a2640 1
    HTSprintf0(&buf, "</dl>\n</body>\n</html>\n");
d2660 3
a2662 3
PRIVATE void cookie_domain_flag_set ARGS2(
	char *,		domainstr,
	int,		flag)
d2665 3
a2667 1
    char **str = typecalloc(char *);
d2670 1
d2672 2
a2673 5
    if (str == NULL) {
	HTAlwaysAlert(gettext("Internal"),
		      gettext("cookie_domain_flag_set error, aborting program"));
	exit_immediately(EXIT_FAILURE);
    }
d2676 2
a2677 1
     * Is this the first domain we're handling?  If so, initialize domain_list.
d2679 1
a2693 5
	if (*strsmall == '\0')
	    /* Never add a domain for empty string.  It would actually
	     * make more sense to use strtok here. - kw */
	    continue;

d2696 1
a2696 1
	 * re-setting of an already existing domain -- if so, just
d2700 14
a2713 2
	if ((de = find_domain_entry(strsmall)) == NULL) {
	    de = typecalloc(domain_entry);
a2716 3
	    de->bv = ACCEPT_ALWAYS;
	    de->invcheck_bv = INVCHECK_QUERY;

d2718 21
a2738 12
	    case (FLAG_ACCEPT_ALWAYS):	de->invcheck_bv = DEFAULT_INVCHECK_BV;
					break;
	    case (FLAG_REJECT_ALWAYS):	de->invcheck_bv = DEFAULT_INVCHECK_BV;
					break;
	    case (FLAG_QUERY_USER):	de->invcheck_bv = DEFAULT_INVCHECK_BV;
					break;
	    case (FLAG_INVCHECK_QUERY): de->bv = QUERY_USER;
					break;
	    case (FLAG_INVCHECK_STRICT): de->bv = QUERY_USER;
					break;
	    case (FLAG_INVCHECK_LOOSE): de->bv = QUERY_USER;
					break;
d2744 17
a2761 16
	switch(flag) {
	case (FLAG_ACCEPT_ALWAYS):	de->bv = ACCEPT_ALWAYS;
					break;
	case (FLAG_REJECT_ALWAYS):	de->bv = REJECT_ALWAYS;
					break;
	case (FLAG_QUERY_USER):		de->bv = QUERY_USER;
					break;
	case (FLAG_INVCHECK_QUERY):	de->invcheck_bv = INVCHECK_QUERY;
					break;
	case (FLAG_INVCHECK_STRICT):    de->invcheck_bv = INVCHECK_STRICT;
					break;
	case (FLAG_INVCHECK_LOOSE):	de->invcheck_bv = INVCHECK_LOOSE;
					break;
	}
	CTRACE((tfp, "cookie_domain_flag_set (%s, bv=%d, invcheck_bv=%d)\n",
		     strsmall, de->bv, de->invcheck_bv));
a2766 40
}

/*
 * If any COOKIE_{ACCEPT,REJECT}_DOMAINS have been defined, process them.
 * These are comma delimited lists of domains.  - BJP
 *
 * And for query/strict/loose invalid cookie checking.  - BJP
 */
PUBLIC void LYConfigCookies NOARGS
{
    static CONST struct {
	char **domain;
	int flag;
	int once;
    } table[] = {
	{ &LYCookieSAcceptDomains,	FLAG_ACCEPT_ALWAYS,   TRUE },
	{ &LYCookieSRejectDomains,	FLAG_REJECT_ALWAYS,   TRUE },
	{ &LYCookieSStrictCheckDomains, FLAG_INVCHECK_STRICT, TRUE },
	{ &LYCookieSLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  TRUE },
	{ &LYCookieSQueryCheckDomains,	FLAG_INVCHECK_QUERY,  TRUE },
	{ &LYCookieAcceptDomains,	FLAG_ACCEPT_ALWAYS,   FALSE },
	{ &LYCookieRejectDomains,	FLAG_REJECT_ALWAYS,   FALSE },
	{ &LYCookieStrictCheckDomains,	FLAG_INVCHECK_STRICT, FALSE },
	{ &LYCookieLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  FALSE },
	{ &LYCookieQueryCheckDomains,	FLAG_INVCHECK_QUERY,  FALSE },
    };
    unsigned n;

    for (n = 0; n < TABLESIZE(table); n++) {
	if (*(table[n].domain) != NULL) {
	    cookie_domain_flag_set(*(table[n].domain), table[n].flag);
	    /*
	     * Discard the value for system settings after we've used them.
	     * The local settings will be merged with the contents of .lynxrc
	     */
	    if (table[n].once) {
		FREE(*(table[n].domain));
	    }
	}
    }
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d1867 1
a1867 1
#ifdef USE_PERSISTENT_COOKIES
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d89 3
a91 3
static HTList *domain_list = NULL;
static HTList *cookie_list = NULL;
static int total_cookies = 0;
d123 4
a126 4
static void MemAllocCopy (
	char **	dest,
	const char *	start,
	const char *	end)
d143 1
a143 1
static cookie * newCookie (void)
d154 2
a155 2
static void freeCookie (
	cookie *	co)
d171 1
a171 1
static void LYCookieJar_free (void)
d210 3
a212 3
static BOOLEAN host_matches (
	const char *	A,
	const char *	B)
d240 3
a242 3
static BOOLEAN port_matches (
	int		port,
	const char *	list)
d244 1
a244 1
    const char *number = list;
d267 1
a267 1
static int ignore_trailing_slash (const char * a)
d279 1
a279 1
static BOOL is_prefix (const char * a, const char * b)
d303 2
a304 2
static domain_entry * find_domain_entry (
    const char *	name)
d336 4
a339 4
static void store_cookie (
	cookie *	co,
	const char *	hostname,
	const char *	path)
d345 1
a345 1
    const char *ptr;
d658 7
a664 7
static char * scan_cookie_sublist (
	char *		hostname,
	char *		path,
	int		port,
	HTList *	sublist,
	char *		header,
	BOOL		secure)
d838 3
a840 3
static char *alloc_attr_value (
	const char *	value_start,
	const char *	value_end)
d864 10
a873 10
static unsigned parse_attribute (
	unsigned	flags,
	cookie *	cur_cookie,
	int *		cookie_len,
	const char *	attr_start,
	int		attr_len,
	char *		value,
	const char *	address,
	char *		hostname,
	int		port)
d1093 7
a1099 7
static void LYProcessSetCookies (
	const char *	SetCookie,
	const char *	SetCookie2,
	const char *	address,
	char *		hostname,
	char *		path,
	int		port)
d1101 1
a1101 1
    const char *p, *attr_start, *attr_end, *value_start, *value_end;
d1224 1
a1224 1
		const char *cp, *cp1;
d1518 1
a1518 1
		const char *cp, *cp1;
d1738 4
a1741 4
void LYSetCookie (
	const char *	SetCookie,
	const char *	SetCookie2,
	const char *	address)
d1816 5
a1820 5
char * LYAddCookieHeader (
	char *		hostname,
	char *		path,
	int		port,
	BOOL		secure)
d1868 1
a1868 1
static int number_of_file_cookies = 0;
d1871 2
a1872 2
void LYLoadCookies (
	char *		cookie_file)
d2022 2
a2023 2
void LYStoreCookies (
	char *		cookie_file)
d2120 5
a2124 5
static int LYHandleCookies (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d2554 3
a2556 3
static void cookie_domain_flag_set (
	char *		domainstr,
	int		flag)
d2653 1
a2653 1
void LYConfigCookies (void)
d2655 1
a2655 1
    static const struct {
d2691 1
a2691 1
GLOBALDEF HTProtocol LYLynxCookies = {"LYNXCOOKIE",LYHandleCookies,0};
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 22
a23 22
 *			       ===================
 *
 *	Author: AMK	A.M. Kuchling (amk@@magnet.com)	12/25/96
 *
 *	Incorporated with mods by FM			01/16/97
 *
 *  Based on:
 *	http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-mgmt-05.txt
 *
 *	Updated for:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *		- FM					1997-07-09
 *
 *	Updated for:
 *   ftp://ds.internic.net/internet-drafts/draft-ietf-http-state-man-mec-03.txt
 *		- FM					1997-08-02
 *
 *	Partially checked against:
 *   http://www.ietf.org/internet-drafts/draft-ietf-http-state-man-mec-10.txt
 *		- kw					1998-12-11
 *
 *  TO DO: (roughly in order of decreasing priority)
d81 8
a88 8
 *  The first level of the cookie list is a list indexed by the domain
 *  string; cookies with the same domain will be placed in the same
 *  list.  Thus, finding the cookies that apply to a given URL is a
 *  two-level scan; first we check each domain to see if it applies,
 *  and if so, then we check the paths of all the cookies on that
 *  list.  We keep a running total of cookies as we add or delete
 *  them
 */
d94 14
a107 14
    char *lynxID;		/* Lynx cookie identifier */
    char *name;			/* Name of this cookie */
    char *value;		/* Value of this cookie */
    int version;		/* Cookie protocol version (=1) */
    char *comment;		/* Comment to show to user */
    char *commentURL;		/* URL for comment to show to user */
    char *domain;		/* Domain for which this cookie is valid */
    int port;			/* Server port from which this cookie was given (usu. 80) */
    char *PortList;		/* List of ports for which cookie can be sent */
    char *path;			/* Path prefix for which this cookie is valid */
    int pathlen;		/* Length of the path */
    int flags;			/* Various flags */
    time_t expires;		/* The time when this cookie expires */
    BOOL quoted;		/* Was a value quoted in the Set-Cookie header? */
d111 6
a116 6
#define COOKIE_FLAG_SECURE 1	/* If set, cookie requires secure links */
#define COOKIE_FLAG_DISCARD 2	/* If set, expire at end of session */
#define COOKIE_FLAG_EXPIRES_SET 4	/* If set, an expiry date was set */
#define COOKIE_FLAG_DOMAIN_SET 8	/* If set, an non-default domain was set */
#define COOKIE_FLAG_PATH_SET 16	/* If set, an non-default path was set */
#define COOKIE_FLAG_FROM_FILE 32	/* If set, this cookie was persistent */
d118 3
a120 2
struct _HTStream {
    HTStreamClass *isa;
d123 4
a126 3
static void MemAllocCopy(char **dest,
			 const char *start,
			 const char *end)
d143 1
a143 1
static cookie *newCookie(void)
d154 2
a155 1
static void freeCookie(cookie * co)
d171 1
a171 1
static void LYCookieJar_free(void)
d206 7
a212 6
 *  Compare two hostnames as specified in Section 2 of:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *	- AK & FM
 */
static BOOLEAN host_matches(const char *A,
			    const char *B)
d215 2
a216 2
     * The following line will handle both numeric IP addresses and FQDNs.  Do
     * numeric addresses require special handling?
d222 2
a223 2
     * The following will pass a "dotted tail" match to "a.b.c.e" as described
     * in Section 2 of draft-ietf-http-state-man-mec-10.txt.
a226 1

d236 7
a242 6
 *  Compare the current port with a port list as specified in Section 4.3 of:
 *   http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-state-man-mec-02.txt
 *	- FM
 */
static BOOLEAN port_matches(int port,
			    const char *list)
d247 1
a247 1
	return (FALSE);
d251 1
a251 1
	    return (TRUE);
d261 1
a261 1
    return (FALSE);
d267 1
a267 1
static int ignore_trailing_slash(const char *a)
d270 1
a270 2

    while (len > 1 && a[len - 1] == '/')
d279 1
a279 1
static BOOL is_prefix(const char *a, const char *b)
d292 1
a292 1
		&& b[len_a] != '/') {
d294 1
a294 1
	    }
d303 2
a304 1
static domain_entry *find_domain_entry(const char *name)
d310 1
a310 1
	&& *name != '\0') {
d312 1
a312 1
	    de = (domain_entry *) hl->object;
d315 4
a318 5
			(tfp,
			 "...test_domain_entry(%s) bv:%d, invcheck_bv:%d\n",
			 de->domain,
			 de->bv,
			 de->invcheck_bv));
d327 3
a329 3
	    name,
	    de ? (int) de->bv : -1,
	    de ? (int) de->invcheck_bv : -1));
d334 6
a339 4
 *  Store a cookie somewhere in the domain list. - AK & FM
 */
static void store_cookie(cookie * co, const char *hostname,
			 const char *path)
a348 1

d356 1
a356 1
     * Ensure that the domain list exists.
d367 2
a368 2
     * Look through domain_list to see if the cookie's domain is already
     * listed.
d386 1
a386 2
					    : DEFAULT_INVCHECK_BV);

d396 2
a397 3
	    CTRACE((tfp,
		    "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		    co->path, path));
d409 1
a409 1
	 * The hostname does not contain a dot.
d419 5
a423 5
	 * Section 4.3.2, condition 2:  The value for the Domain attribute
	 * contains no embedded dots or does not start with a dot.  (A dot is
	 * embedded if it's neither the first nor last character.) Note that we
	 * added a lead dot ourselves if a domain attribute value otherwise
	 * qualified.  - FM
d438 2
a439 2
	 * Section 4.3.2, condition 3:  The value for the request-host does not
	 * domain-match the Domain attribute.
d442 1
a442 2
	    CTRACE((tfp,
		    "store_cookie: Rejecting domain '%s' for host '%s'.\n",
d449 3
a451 3
	 * Section 4.3.2, condition 4:  The request-host is an HDN (not IP
	 * address) and has the form HD, where D is the value of the Domain
	 * attribute, and H is a string that contains one or more dots.
d453 3
a455 3
	 * If cookie checking for this domain is set to INVCHECK_LOOSE, then we
	 * want to bypass this check.  The user should be queried if set to
	 * INVCHECK_QUERY.
d460 1
a460 2
						: DEFAULT_INVCHECK_BV);

d470 2
a471 3
		CTRACE((tfp,
			"store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
			co->path, path));
d479 5
a483 5
     * If we found reasons for issuing an invalid cookie confirmation prompt,
     * do that now.  Rejection by the user here is the last chance to
     * completely ignore this cookie; after it passes this hurdle, it may at
     * least supersede a previous cookie (even if it finally gets rejected).  -
     * kw
a486 1

d493 1
a493 2
		CTRACE((tfp,
			"store_cookie: Rejecting domain '%s' for host '%s'.\n",
d506 2
a507 3
		CTRACE((tfp,
			"store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
			co->path, path));
d524 1
a524 1
	de->invcheck_bv = DEFAULT_INVCHECK_BV;	/* should this go here? */
d531 1
a531 1
     * Loop over the cookie list, deleting expired and matching cookies.
d536 1
a536 1
	c2 = (cookie *) hl->object;
d539 1
a539 1
	 * Check if this cookie has expired.
d549 3
a551 3
	    /*
	     * Check if this cookie matches the one we're inserting.
	     */
d564 14
a577 13
	     * This comparison determines the (tentative) position of the new
	     * cookie in the list such that it comes before existing cookies
	     * with a less specific path, but after existing cookies of equal
	     * (or greater) path length.  Thus it should normally preserve the
	     * order of new cookies with the same path as they are received,
	     * although this is not required.
	     *
	     * From RFC 2109 4.3.4:
	     *
	     * If multiple cookies satisfy the criteria above, they are ordered
	     * in the Cookie header such that those with more specific Path
	     * attributes precede those with less specific.  Ordering with
	     * respect to other attributes (e.g., Domain) is unspecified.
d585 1
a585 1
     * Don't bother to add the cookie if it's already expired.
d591 3
a593 3
	/*
	 * Don't add the cookie if we're over the domain's limit.  - FM
	 */
d595 1
a595 2
	CTRACE((tfp,
		"store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n"));
d599 3
a601 3
	/*
	 * Don't add the cookie if we're over the total cookie limit.  - FM
	 */
d603 1
a603 2
	CTRACE((tfp,
		"store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n"));
d607 3
a609 3
	/*
	 * Don't add the cookie if the value is NULL. - BJP
	 */
d615 1
a615 1
    } else if (co->value == NULL) {	/* should not happen - kw */
d620 5
a624 4
	/*
	 * If it's a replacement for a cookie that had not expired, and never
	 * allow has not been set, add it again without confirmation.  - FM
	 */
d629 11
a639 11
	/*
	 * Get confirmation if we need it, and add cookie if confirmed or
	 * 'allow' is set to always.  - FM
	 *
	 * Cookies read from file are accepted without confirmation prompting. 
	 * (Prompting may actually not be possible if LYLoadCookies is called
	 * before curses is setup.) Maybe this should instead depend on
	 * LYSetCookies and/or LYCookieAcceptDomains and/or
	 * LYCookieRejectDomains and/or LYAcceptAllCookies and/or some other
	 * settings.  -kw
	 */
d655 10
a664 9
 *  Scan a domain's cookie_list for any cookies we should
 *  include in a Cookie: request header. - AK & FM
 */
static char *scan_cookie_sublist(char *hostname,
				 char *path,
				 int port,
				 HTList *sublist,
				 char *header,
				 BOOL secure)
d674 1
a674 1
	co = (cookie *) hl->object;
d677 3
a679 2
	if ((co) &&		/* speed-up host_matches() and limit trace output */
	    (LYstrstr(hostname, co->domain) != NULL)) {
d681 3
a683 3
		    hl,
		    (co->name ? co->name : "(no name)"),
		    (co->value ? co->value : "(no value)")));
d685 10
a694 10
		    hostname,
		    (co->domain ? co->domain : "(no domain)"),
		    host_matches(hostname, co->domain),
		    path, co->path,
		    (co->pathlen > 0)
		    ? !is_prefix(co->path, path)
		    : 0,
		    (co->flags & COOKIE_FLAG_SECURE)
		    ? " secure"
		    : ""));
d697 1
a697 1
	 * Check if this cookie has expired, and if so, delete it.
d708 1
a708 1
	 * Check if we have a unexpired match, and handle if we do.
d714 3
a716 3
	     * Skip if the secure flag is set and we don't have a secure
	     * connection.  HTTP.c presently treats only SSL connections as
	     * secure.  - FM
d724 2
a725 2
	     * Skip if we have a port list and the current port is not listed. 
	     * - FM
d733 1
a733 1
	     * Start or append to the request header.
d738 3
a740 2
		     * For Version 1 (or greater) cookies, the version number
		     * goes before the first cookie.
d747 3
a749 3
		 * There's already cookie data there, so add a separator
		 * (always use a semi-colon for "backward compatibility").  -
		 * FM
d753 1
a753 1
		 * Check if we should fold the header.  - FM
d759 8
a766 6
		 * HTTP/1.0 headers may be folded onto multiple lines if each
		 * continuation line begins with a space or horizontal tab. 
		 * All linear whitespace, including folding, has the same
		 * semantics as SP.  [...] However, folding of header lines is
		 * not expected by some applications, and should not be
		 * generated by HTTP/1.0 applications.
d768 1
a768 1
		 * This code was causing problems.  Let's not use it.  -BJP
d778 1
a778 1
	     * Include the cookie name=value pair.
d793 4
a796 3
	     * For Version 1 (or greater) cookies, add $PATH, $PORT and/or
	     * $DOMAIN attributes for the cookie if they were specified via a
	     * server reply header.  - FM
d801 1
a801 1
		     * Append the path attribute.  - FM
d810 1
a810 1
		     * Append the port attribute.  - FM
d819 1
a819 1
		     * Append the domain attribute.  - FM
d831 1
a831 1
    return (header);
d838 3
a840 2
static char *alloc_attr_value(const char *value_start,
			      const char *value_end)
a850 1

d864 10
a873 9
static unsigned parse_attribute(unsigned flags,
				cookie * cur_cookie,
				int *cookie_len,
				const char *attr_start,
				int attr_len,
				char *value,
				const char *address,
				char *hostname,
				int port)
d887 2
a888 2
	     * If secure has a value, assume someone misused it as cookie name. 
	     * - FM
d900 2
a901 2
	     * If discard has a value, assume someone used it as a cookie name. 
	     * - FM
d908 3
a910 3
	/*
	 * Don't process a repeat comment.  - FM
	 */
d918 3
a920 3
	/*
	 * Don't process a repeat commentURL.  - FM
	 */
d923 3
a925 2
	     * We should get only absolute URLs as values, but will resolve
	     * versus the request's URL just in case.  - FM
d931 1
a931 1
	     * Accept only URLs for http or https servers.  - FM
d938 2
a939 3
		CTRACE((tfp,
			"LYProcessSetCookies: Rejecting commentURL value '%s'\n",
			cur_cookie->commentURL));
d946 3
a948 3
	/*
	 * Don't process a repeat domain.  - FM
	 */
d952 6
a957 4
	     * If the value does not have a lead dot, but does have an embedded
	     * dot, and is not an exact match to the hostname, nor is a numeric
	     * IP address, add a lead dot.  Otherwise, use the value as is.  -
	     * FM (domains - case insensitive).
a961 1

d969 2
a970 2
				"LYProcessSetCookies: Adding lead dot for domain value '%s'\n",
				value));
d988 3
a990 3
	/*
	 * Don't process a repeat path.  - FM
	 */
d999 3
a1001 3
	/*
	 * Don't process a repeat port.  - FM
	 */
a1003 1

d1022 1
a1022 1
	     * Don't process a repeat port.  - FM
d1033 3
a1035 3
	/*
	 * Don't process a repeat version.  - FM
	 */
a1037 1

d1045 3
a1047 3
	/*
	 * Don't process a repeat max-age.  - FM
	 */
a1049 1

d1052 1
a1052 1
		cur_cookie->expires = (time_t) 0;
d1056 2
a1057 2
			(long) cur_cookie->expires,
			ctime(&cur_cookie->expires)));
d1063 6
a1068 5
	 * Convert an 'expires' attribute value if we haven't received a
	 * 'max-age'.  Note that 'expires' should not be used in Version 1
	 * cookies, but it might be used for "backward compatibility", and, in
	 * turn, ill-informed people surely would start using it instead of,
	 * rather than in addition to, 'max-age'.  - FM
d1072 1
a1072 1
	    !(cur_cookie->flags & COOKIE_FLAG_EXPIRES_SET)) {
d1078 2
a1079 2
			    (long) cur_cookie->expires,
			    ctime(&cur_cookie->expires)));
d1090 10
a1099 9
 *  Process potentially concatenated Set-Cookie2 and/or Set-Cookie
 *  headers. - FM
 */
static void LYProcessSetCookies(const char *SetCookie,
				const char *SetCookie2,
				const char *address,
				char *hostname,
				char *path,
				int port)
d1112 1
a1112 1
	 * Yuk!  Garbage in, so nothing out.  - FM
d1118 8
a1125 7
     * If we have both Set-Cookie and Set-Cookie2 headers.  process the
     * Set-Cookie2 header.  Otherwise, process whichever of the two headers we
     * do have.  Note that if more than one instance of a valued attribute for
     * the same cookie is encountered, the value for the first instance is
     * retained.  We only accept up to 50 cookies from the header, and only if
     * a cookie's values do not exceed the 4096 byte limit on overall size.  -
     * FM
d1130 2
a1131 2
     * Process the Set-Cookie2 header, if present and not zero-length, adding
     * each cookie to the CombinedCookies list.  - FM
d1141 1
a1141 1
	 * Get the attribute name.
d1151 8
a1158 7
	 * Check for an '=' delimiter, or an 'expires' name followed by white,
	 * since Netscape's bogus parser doesn't require an '=' delimiter, and
	 * 'expires' attributes are being encountered without them.  These
	 * shouldn't be in a Set-Cookie2 header, but we'll assume it's an
	 * expires attribute rather a cookie with that name, since the
	 * attribute mistake rather than name mistake seems more likely to be
	 * made by providers.  - FM
d1161 1
a1161 1
	    !strncasecomp(attr_start, "Expires", 7)) {
d1163 1
a1163 1
	     * Get the value string.
d1170 8
a1177 7
	     * Hack alert!  We must handle Netscape-style cookies with
	     *          "Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *          "Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     * No quotes, but there are spaces.  Argh...  Anyway, we know it
	     * will have at least 3 space separators within it, and two dashes
	     * or two more spaces, so this code looks for a space after the 5th
	     * space separator or dash to mark the end of the value.  - FM
a1181 1

d1185 1
a1185 1
		     * No alphabetic day field.  - FM
d1190 1
a1190 1
		     * Skip the alphabetic day field.  - FM
d1211 7
a1217 6
		/*
		 * Hack Alert!  The port attribute can take a comma separated
		 * list of numbers as a value, and such values should be
		 * quoted, but if not, make sure we don't treat a number in the
		 * list as the start of a new cookie.  - FM
		 */
d1222 1
a1222 1
		 * The value starts as an unquoted number.
a1224 1

d1250 1
a1250 1
		     * Trim trailing spaces.
a1264 1

d1266 1
a1266 1
		 * It looks like quoted string.
d1287 1
a1287 1
		 * Otherwise, it's an unquoted string.
d1294 1
a1294 1
		 * Trim trailing spaces.
d1309 1
a1309 1
	 * Check for a separator character, and skip it.
d1315 1
a1315 1
	 * Now, we can handle this attribute/value pair.
d1320 9
a1328 9
	    parse_flags = parse_attribute(parse_flags,
					  cur_cookie,
					  &cookie_len,
					  attr_start,
					  (attr_end - attr_start),
					  value,
					  address,
					  hostname,
					  port);
d1335 2
a1336 2
		&& value
		&& value_end >= value_start) {
d1338 2
a1339 2
		 * If we've started a cookie, and it's not too big, save it in
		 * the CombinedCookies list.  - FM
d1342 2
a1343 2
		    && cur_cookie != NULL
		    && !(parse_flags & FLAGS_INVALID_PORT)) {
d1345 1
a1345 1
		     * Assume version 1 if not set to that or higher.  - FM
d1353 5
a1357 5
			    "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
			    (cur_cookie->name ?
			     cur_cookie->name : "[no name]"),
			    (cur_cookie->value ?
			     cur_cookie->value : "[no value]")));
d1359 3
a1361 3
			    (parse_flags & FLAGS_INVALID_PORT) ?
			    "                     due to excessive length!\n"
			    : "                     due to invalid port!\n"));
d1363 1
a1363 1
			NumCookies--;
d1369 1
a1369 1
		 * Start a new cookie.  - FM
d1391 2
a1392 2
     * Add any final SetCookie2 cookie to the CombinedCookie list if we are
     * within the length limit.  - FM
d1395 2
a1396 2
	&& cookie_len <= max_cookies_buffer
	&& cur_cookie != NULL && !(parse_flags & FLAGS_INVALID_PORT)) {
d1403 2
a1404 2
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
d1406 6
a1411 6
		(cookie_len > max_cookies_buffer ? "length" : ""),
		(cookie_len > max_cookies_buffer &&
		 NumCookies > max_cookies_domain
		 ? " and "
		 : ""),
		(NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1414 1
a1414 1
    } else if (cur_cookie != NULL) {	/* invalidport */
d1416 2
a1417 2
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
d1419 1
a1419 1
	NumCookies--;
d1425 2
a1426 2
     * Process the Set-Cookie header, if no non-zero-length Set-Cookie2 header
     * was present.  - FM
d1439 1
a1439 1
	 * Get the attribute name.
d1449 4
a1452 3
	 * Check for an '=' delimiter, or an 'expires' name followed by white,
	 * since Netscape's bogus parser doesn't require an '=' delimiter, and
	 * 'expires' attributes are being encountered without them.  - FM
d1455 1
a1455 1
	    !strncasecomp(attr_start, "Expires", 7)) {
d1457 1
a1457 1
	     * Get the value string.
d1464 8
a1471 7
	     * Hack alert!  We must handle Netscape-style cookies with
	     *          "Expires=Mon, 01-Jan-96 13:45:35 GMT" or
	     *          "Expires=Mon,  1 Jan 1996 13:45:35 GMT".
	     * No quotes, but there are spaces.  Argh...  Anyway, we know it
	     * will have at least 3 space separators within it, and two dashes
	     * or two more spaces, so this code looks for a space after the 5th
	     * space separator or dash to mark the end of the value.  - FM
a1475 1

d1479 1
a1479 1
		     * No alphabetic day field.  - FM
d1484 1
a1484 1
		     * Skip the alphabetic day field.  - FM
d1505 7
a1511 6
		/*
		 * Hack Alert!  The port attribute can take a comma separated
		 * list of numbers as a value, and such values should be
		 * quoted, but if not, make sure we don't treat a number in the
		 * list as the start of a new cookie.  - FM
		 */
d1516 1
a1516 1
		 * The value starts as an unquoted number.
a1518 1

d1544 1
a1544 1
		     * Trim trailing spaces.
a1558 1

d1560 1
a1560 1
		 * It looks like quoted string.
d1581 1
a1581 1
		 * Otherwise, it's an unquoted string.
d1588 1
a1588 1
		 * Trim trailing spaces.
d1603 1
a1603 1
	 * Check for a separator character, and skip it.
d1609 1
a1609 1
	 * Now, we can handle this attribute/value pair.
d1614 9
a1622 9
	    parse_flags = parse_attribute(parse_flags,
					  cur_cookie,
					  &cookie_len,
					  attr_start,
					  (attr_end - attr_start),
					  value,
					  address,
					  hostname,
					  port);
d1629 2
a1630 2
		&& value
		&& value_end >= value_start) {
d1632 2
a1633 2
		 * If we've started a cookie, and it's not too big, save it in
		 * the CombinedCookies list.  - FM
d1636 1
a1636 1
		    && cur_cookie != NULL) {
d1638 3
a1640 2
		     * If we had a Set-Cookie2 header, make sure the version is
		     * at least 1, and mark it for quoting.  - FM
d1650 6
a1655 8
		    CTRACE((tfp,
			    "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
			    (cur_cookie->name ?
			     cur_cookie->name : "[no name]"),
			    (cur_cookie->value ?
			     cur_cookie->value : "[no value]")));
		    CTRACE((tfp,
			    "                     due to excessive length!\n"));
d1660 1
a1660 1
		 * Start a new cookie.  - FM
d1683 1
a1683 1
     * Handle the final Set-Cookie cookie if within length limit.  - FM
d1685 1
a1685 3
    if (NumCookies <= max_cookies_domain
	&& cookie_len <= max_cookies_buffer
	&& cur_cookie != NULL) {
d1695 2
a1696 2
		(cur_cookie->name ? cur_cookie->name : "[no name]"),
		(cur_cookie->value ? cur_cookie->value : "[no value]")));
d1698 3
a1700 5
		(cookie_len > max_cookies_buffer ? "length" : ""),
		(cookie_len > max_cookies_buffer && NumCookies > max_cookies_domain
		 ? " and "
		 : ""),
		(NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1706 2
a1707 2
     * OK, now we can actually store any cookies in the CombinedCookies list. 
     * - FM
d1710 1
a1710 1
    while (NULL != (co = (cookie *) HTList_nextObject(cl))) {
d1712 2
a1713 2
		(co->name ? co->name : "[no name]"),
		(co->value ? co->value : "[no value]")));
d1715 3
a1717 3
	    CTRACE((tfp, "                    expires: %ld, %s\n",
		    (long) co->expires,
		    ctime(&co->expires)));
d1734 8
a1741 7
 *  Entry function for handling Set-Cookie: and/or Set-Cookie2:
 *  reply headers.   They may have been concatenated as comma
 *  separated lists in HTTP.c or HTMIME.c. - FM
 */
void LYSetCookie(const char *SetCookie,
		 const char *SetCookie2,
		 const char *address)
d1748 3
a1750 3
     * Get the hostname, port and path of the address, and report the
     * Set-Cookie and/or Set-Cookie2 header(s) if trace mode is on, but set the
     * cookie(s) only if LYSetCookies is TRUE.  - FM
d1753 1
a1753 1
	(ptr = strchr(hostname, ':')) != NULL) {
d1755 1
a1755 1
	 * Replace default port number.
d1764 1
a1764 1
			 PARSE_PATH | PARSE_PUNCTUATION)) != NULL) &&
d1767 1
a1767 1
	    *(ptr + 1) = '\0';	/* Leave a single '/' alone */
d1775 3
a1777 2
	 * Yuk, something must have gone wrong in HTMIME.c or HTTP.c because
	 * both SetCookie and SetCookie2 are NULL or zero-length.  - FM
d1782 2
a1783 2
	    NonNull(hostname),
	    NonNull(path)));
d1795 1
a1795 1
     * We're done if LYSetCookies is off or we have bad headers.  - FM
d1804 1
a1804 1
     * Process the header(s).
d1813 8
a1820 7
 *  Entry function from creating a Cookie: request header
 *  if needed. - AK & FM
 */
char *LYAddCookieHeader(char *hostname,
			char *path,
			int port,
			BOOL secure)
d1827 3
a1829 3
	    NONNULL(hostname),
	    port,
	    NONNULL(path)));
d1832 2
a1833 2
     * Search the cookie_list elements in the domain_list for any cookies
     * associated with the //hostname:port/path
d1836 1
a1836 1
	de = (domain_entry *) hl->object;
d1862 1
a1862 1
	return (header);
d1864 1
a1864 1
    return (NULL);
d1871 2
a1872 1
void LYLoadCookies(char *cookie_file)
a1877 1
    /* *INDENT-OFF* */
a1890 2
    /* *INDENT-ON* */

d1910 1
a1910 1
	number_of_file_cookies++;
d1935 2
a1936 4
		    tok_loop, tok_out - buf, tok_out));
	    LYstrncpy(tok_values[tok_loop].s,
		      tok_out,
		      tok_values[tok_loop].n);
d1948 1
a1948 2
	    CTRACE((tfp,
		    "*** wrong format: not enough tokens, ignoring line!\n"));
d1961 4
a1964 4
	    value[1] && value[strlen(value) - 1] == '"' &&
	    value[strlen(value) - 2] != '\\') {
	    value[strlen(value) - 1] = '\0';
	    StrAllocCopy(moo->value, value + 1);
d1974 2
a1975 2
	 *                           expiration originally, otherwise
	 *                           it would not be in the file.
d1978 23
a2000 23
	 *                           only matters for sending version 1
	 *                           cookies; the cookies read from the
	 *                           file are currently treated all like
	 *                           version 0 (we don't set moo->version)
	 *                           so $Domain= and $Path= will normally
	 *                           not be sent to the server.  But if
	 *                           these cookies somehow get mixed with
	 *                           new version 1 cookies we may end up
	 *                           sending version 1 to the server, and
	 *                           in that case we should send $Domain
	 *                           and $Path.  The state-man-mec drafts
	 *                           and RFC 2109 say that $Domain and
	 *                           $Path SHOULD be omitted if they were
	 *                           not given explicitly, but not that
	 *                           they MUST be omitted.
	 *                           See 8.2 Cookie Spoofing in draft -10
	 *                           for a good reason to send them.
	 *                           However, an explicit domain should be
	 *                           now prefixed with a dot (unless it is
	 *                           for a single host), so we check for
	 *                           that.
	 *  COOKIE_FLAG_SECURE       Should have "FALSE" for normal,
	 *                           otherwise set it.
d2003 1
a2003 1
	    COOKIE_FLAG_PATH_SET;
d2018 1
a2018 1
    LYCloseInput(cookie_handle);
d2022 2
a2023 1
void LYStoreCookies(char *cookie_file)
d2029 1
a2029 1
    time_t now = time(NULL);	/* system specific? - RP */
d2037 1
a2037 1
     * Check whether we have something to do.  - FM
d2049 2
a2050 3
    cookie_handle = LYNewTxtFile(cookie_file);
    if (cookie_handle == NULL)
	return;
d2055 1
a2055 1
	     * Fote says the first object is NULL.  Go with that.
d2060 1
a2060 1
	 * Show the domain's cookies.  - FM
d2064 1
a2064 1
	     * First object is always NULL.  - FM
d2066 1
a2066 1
	    if ((co = (cookie *) cl->object) == NULL)
d2070 1
a2070 1
		    (long) now, (long) co->expires));
d2103 22
a2124 21
 *	---------------
 *
 *  Lists all cookies by domain, and allows deletions of
 *  individual cookies or entire domains, and changes of
 *  'allow' settings.  The list is invoked via the COOKIE_JAR
 *  command (Ctrl-K), and deletions or changes of 'allow'
 *  settings are done by activating links in that list.
 *  The procedure uses a LYNXCOOKIE: internal URL scheme.
 *
 *  Semantics:
 *	LYNXCOOKIE:/			Create and load the Cookie Jar Page.
 *	LYNXCOOKIE://domain		Manipulate the domain.
 *	LYNXCOOKIE://domain/lynxID	Delete cookie with lynxID in domain.
 *
 *	New functions can be added as extensions to the path, and/or by
 *	assigning meanings to ;parameters, a ?searchpart, and/or #fragments.
 */
static int LYHandleCookies(const char *arg,
			   HTParentAnchor *anAnchor,
			   HTFormat format_out,
			   HTStream *sink)
d2139 1
a2139 1
     * Check whether we have something to do.  - FM
d2145 1
a2145 1
	return (HT_NO_DATA);
d2149 3
a2151 3
     * If there's a domain string in the "host" field of the LYNXCOOKIE:  URL,
     * this is a request to delete something or change and 'allow' setting.  -
     * FM
d2158 3
a2160 3
	     * If there is a path string (not just a slash) in the LYNXCOOKIE: 
	     * URL, that's a cookie's lynxID and this is a request to delete it
	     * from the Cookie Jar.  - FM
d2171 1
a2171 1
	 * Seek the domain in the domain_list structure.  - FM
d2176 2
a2177 1
	     * We found the domain.  Check whether a lynxID is present.  - FM
d2181 2
a2182 2
		 * Seek and delete the cookie with this lynxID in the domain's
		 * cookie list.  - FM
d2185 1
a2185 1
		    if ((co = (cookie *) cl->object) == NULL)
d2187 1
a2187 1
			 * First object is always empty.  - FM
d2192 2
a2193 1
			 * We found the cookie.  Delete it if confirmed.  - FM
d2195 2
a2196 1
			if (HTConfirm(DELETE_COOKIE_CONFIRMATION) == FALSE) {
d2199 1
a2199 1
			    return (HT_NO_DATA);
d2209 4
a2212 4
			     * No more cookies in this domain, no default
			     * accept/reject choice was set by the user, and
			     * got confirmation on deleting the domain, so do
			     * it.  - FM
d2249 1
a2249 1
		    switch (ch) {
d2256 1
a2256 1
			return (HT_NO_DATA);
d2264 1
a2264 1
			return (HT_NO_DATA);
d2281 1
a2281 1
		      Delete_all_cookies_in_domain:
d2304 1
a2304 1
			    return (HT_NO_DATA);
d2326 1
a2326 1
			return (HT_NO_DATA);
d2337 1
a2337 1
			return (HT_NO_DATA);
d2358 1
a2358 1
	return (HT_NO_DATA);
d2372 1
a2372 1
		   HTAtom_name(format_in), HTAtom_name(format_out));
d2375 1
a2375 1
	return (HT_NOT_LOADED);
d2384 3
a2386 3
    HTSprintf0(&buf,
	       "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       COOKIE_JAR_TITLE);
d2389 3
a2391 3
	       LYNX_NAME, LYNX_VERSION,
	       HELP_ON_SEGMENT,
	       helpfilepath, COOKIE_JAR_HELP, COOKIE_JAR_TITLE);
d2405 1
a2405 1
	     * First object always is NULL.  - FM
d2410 1
a2410 1
	 * Show the domain link and 'allow' setting.  - FM
d2413 1
a2413 1
		   de->domain, STR_LYNXCOOKIE, de->domain, de->domain);
d2431 1
a2431 1
	 * Show the domain's cookies.  - FM
d2434 1
a2434 1
	    if ((co = (cookie *) cl->object) == NULL)
d2436 1
a2436 1
		 * First object is always NULL.  - FM
d2441 1
a2441 1
	     * Show the name=value pair.  - FM
d2456 1
a2456 1
		       STR_LYNXCOOKIE, de->domain, co->lynxID, name, value);
d2462 1
a2462 2
		HTSprintf0(&buf, "%s\n",
			   gettext("(from a previous session)"));
d2467 1
a2467 1
	     * Show the path, port, secure and discard setting.  - FM
d2475 4
a2478 5
	    HTSprintf0(&buf,
		       "<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",
		       path, co->port,
		       ((co->flags & COOKIE_FLAG_SECURE) ? "YES" : "NO"),
		       ((co->flags & COOKIE_FLAG_DISCARD) ? "YES" : "NO"));
d2483 1
a2483 1
	     * Show the list of acceptable ports, if present.  - FM
d2491 1
a2491 1
	     * Show the commentURL, if we have one.  - FM
d2499 3
a2501 3
			   "<dd>CommentURL: <a href=\"%s\">%s</a>\n",
			   Address,
			   Title);
d2508 1
a2508 1
	     * Show the comment, if we have one.  - FM
d2519 1
a2519 1
	     * Show the Maximum Gobble Date.  - FM
d2522 3
a2524 3
		       gettext("Maximum Gobble Date:"),
		       ((co->flags & COOKIE_FLAG_EXPIRES_SET)
			?
d2526 3
a2528 3
		       ((co->flags & COOKIE_FLAG_EXPIRES_SET)
			?
			"" : "\n"));
d2538 2
a2539 2
     * Free the target to complete loading of the Cookie Jar Page, and report a
     * successful load.  - FM
d2541 1
a2541 1
    (*target->isa->_free) (target);
d2543 1
a2543 1
    return (HT_LOADED);
d2546 1
d2548 5
a2552 5
 *      ----------------------
 *      All purpose function to handle setting domain flags for a
 *      comma-delimited list of domains.  cookie_domain_flags handles
 *      invcheck behavior, as well as accept/reject behavior. - BJP
 */
d2554 3
a2556 2
static void cookie_domain_flag_set(char *domainstr,
				   int flag)
d2600 1
a2600 1
		outofmem(__FILE__, "cookie_domain_flag_set");
d2605 13
a2617 19
	    switch (flag) {
	    case (FLAG_ACCEPT_ALWAYS):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_REJECT_ALWAYS):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_QUERY_USER):
		de->invcheck_bv = DEFAULT_INVCHECK_BV;
		break;
	    case (FLAG_INVCHECK_QUERY):
		de->bv = QUERY_USER;
		break;
	    case (FLAG_INVCHECK_STRICT):
		de->bv = QUERY_USER;
		break;
	    case (FLAG_INVCHECK_LOOSE):
		de->bv = QUERY_USER;
		break;
d2624 13
a2636 19
	switch (flag) {
	case (FLAG_ACCEPT_ALWAYS):
	    de->bv = ACCEPT_ALWAYS;
	    break;
	case (FLAG_REJECT_ALWAYS):
	    de->bv = REJECT_ALWAYS;
	    break;
	case (FLAG_QUERY_USER):
	    de->bv = QUERY_USER;
	    break;
	case (FLAG_INVCHECK_QUERY):
	    de->invcheck_bv = INVCHECK_QUERY;
	    break;
	case (FLAG_INVCHECK_STRICT):
	    de->invcheck_bv = INVCHECK_STRICT;
	    break;
	case (FLAG_INVCHECK_LOOSE):
	    de->invcheck_bv = INVCHECK_LOOSE;
	    break;
d2638 2
a2639 3
	CTRACE((tfp,
		"cookie_domain_flag_set (%s, bv=%d, invcheck_bv=%d)\n",
		strsmall, de->bv, de->invcheck_bv));
d2653 1
a2653 1
void LYConfigCookies(void)
a2659 1
	/* *INDENT-OFF* */
a2669 2
	/* *INDENT-ON* */

d2689 1
a2689 1
GLOBALDEF(HTProtocol, LYLynxCookies, _LYCOOKIE_C_GLOBALDEF_1_INIT);
d2691 1
a2691 2
GLOBALDEF HTProtocol LYLynxCookies =
{"LYNXCOOKIE", LYHandleCookies, 0};
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d1106 2
a1107 2
    if (isEmpty(SetCookie) &&
	isEmpty(SetCookie2)) {
d1427 1
a1427 1
    p = ((SetCookie && isEmpty(SetCookie2)) ? SetCookie : "");
d1772 2
a1773 2
    if (isEmpty(SetCookie) &&
	isEmpty(SetCookie2)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a76 3
/* default for new domains, one of the invcheck_behaviour_t values: */
#define DEFAULT_INVCHECK_BV INVCHECK_QUERY

d132 1
a132 1
    temp = typecallocn(char, (end - start) + 1);
d142 1
a142 1
    cookie *p = typecalloc(cookie);
d241 1
a241 1
    if (!(number && isdigit(UCH(*number))))
d248 1
a248 1
	while (isdigit(UCH(*number))) {
d251 1
a251 1
	while (*number != '\0' && !isdigit(UCH(*number))) {
a259 36
 * Returns the length of the given path ignoring trailing slashes.
 */
PRIVATE int ignore_trailing_slash ARGS1(CONST char *, a)
{
    int len = strlen(a);
    while (len > 1 && a[len-1] == '/')
	--len;
    return len;
}

/*
 * Check if the path 'a' is a prefix of path 'b', ignoring trailing slashes
 * in either, since they denote an empty component.
 */
PRIVATE BOOL is_prefix ARGS2(CONST char *, a, CONST char *, b)
{
    int len_a = ignore_trailing_slash(a);
    int len_b = ignore_trailing_slash(b);

    if (len_a > len_b) {
	return FALSE;
    } else {
	if (strncmp(a, b, len_a) != 0) {
	    return FALSE;
	}
	if (len_a < len_b && (len_a > 1 || a[0] != '/')) {
	    if (b[len_a] != '\0'
	     && b[len_a] != '/') {
		return FALSE;
	     }
	}
    }
    return TRUE;
}

/*
a273 3
    int invprompt_reasons = 0;	/* what is wrong with this cookie - kw */
#define FAILS_COND1 0x01
#define FAILS_COND4 0x02
d297 1
a297 1
	    !strcasecomp(co->domain, de->domain)) {
d318 27
a344 16
    if (!is_prefix(co->path, path)) {
	invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
	    				       : DEFAULT_INVCHECK_BV);
	switch (invcheck_bv) {
	case INVCHECK_LOOSE:
	    break;		/* continue as if nothing were wrong */

	case INVCHECK_QUERY:
	    invprompt_reasons |= FAILS_COND1;
	    break;		/* will prompt later if we get that far */

	case INVCHECK_STRICT:
	    CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		   co->path, path));
	    freeCookie(co);
	    return;
d356 2
a357 2
	    CTRACE((tfp, "store_cookie: Rejecting because '%s' has no dot.\n",
		    hostname));
d359 1
d371 2
a372 2
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n",
		    co->domain));
d374 1
d379 2
a380 2
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s'.\n",
		    co->domain));
d382 1
d391 2
a392 2
	    CTRACE((tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
		    co->domain, hostname));
d394 1
d409 19
a427 35
	    invcheck_behaviour_t invcheck_bv = (de ? de->invcheck_bv
						   : DEFAULT_INVCHECK_BV);
	    switch (invcheck_bv) {
	    case INVCHECK_LOOSE:
		break;		/* continue as if nothing were wrong */

	    case INVCHECK_QUERY:
		invprompt_reasons |= FAILS_COND4;
		break;		/* will prompt later if we get that far */

	    case INVCHECK_STRICT:
		CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		       co->path, path));
		freeCookie(co);
		return;
	    }
	}
    }

    /*
     *  If we found reasons for issuing an invalid cookie confirmation
     *  prompt, do that now.  Rejection by the user here is the last
     *  chance to completely ignore this cookie; after it passes this
     *  hurdle, it may at least supersede a previous cookie (even if
     *  it finally gets rejected). - kw
     */
    if (invprompt_reasons) {
	char *msg = 0;
	if (invprompt_reasons & FAILS_COND4) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_DOMAIN_CONFIRMATION,
		       co->domain,
		       hostname);
	    if (!HTConfirmDefault(msg, NO)) {
		CTRACE((tfp, "store_cookie: Rejecting domain '%s' for host '%s'.\n",
d429 9
a437 17
					hostname));
		freeCookie(co);
		FREE(msg);
		return;
	    }
	}
	if (invprompt_reasons & FAILS_COND1) {
	    HTSprintf0(&msg,
		       INVALID_COOKIE_PATH_CONFIRMATION,
		       co->path, path);
	    if (!HTConfirmDefault(msg, NO)) {
		CTRACE((tfp, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n",
		       co->path, path));
		freeCookie(co);
		FREE(msg);
		return;
	    }
a438 1
	FREE(msg);
d445 1
a445 1
	de = typecalloc(domain_entry);
d450 7
a456 6
	 * The default behavior for this new domain could be set
	 * differently if the cookie comes from a file, as the
	 * code had it originally, but there doesn't seem to be
	 * a good reason for it any more; setting more permissive
	 * behavior for individual domains is now possible via
	 * configuration options. - kw
d460 1
a460 1
	    de->bv = ACCEPT_ALWAYS; /* ?? */
d464 1
a464 1
	de->invcheck_bv = DEFAULT_INVCHECK_BV; /* should this go here? */
d493 1
a493 1
		   !strcasecomp(co->domain, c2->domain) &&
d535 1
a535 1
	CTRACE((tfp, "store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n"));
d543 1
a543 1
	CTRACE((tfp, "store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n"));
d550 2
a551 7
	/*
	 * Presence of value is now needed (indicated normally by '='),
	 * but it can now be an empty string.
	 * - kw 1999-06-24
	 */
    } else if (co->value == NULL) { /* should not happen - kw */
	CTRACE((tfp, "store_cookie: Value is NULL! Not storing cookie.\n"));
d594 2
a595 2
	char *,		hostname,
	char *,		path,
d612 2
a613 4
       if ((co) && /* speed-up host_matches() and limit trace output */
	   (LYstrstr(hostname, co->domain) != NULL))
       {
	    CTRACE((tfp, "Checking cookie %p %s=%s\n",
d616 2
a617 2
			(co->value ? co->value : "(no value)")));
	    CTRACE((tfp, "\t%s %s %d %s %s %d%s\n",
d623 1
a623 1
			    ? !is_prefix(co->path, path)
d627 1
a627 1
			    : ""));
d645 1
a645 1
	    (co->pathlen == 0 || is_prefix(co->path, path))) {
d741 1
a741 1
		if (co->PortList && isdigit(UCH(*co->PortList))) {
d814 1
a814 1
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie2 header.\n"));
d823 1
a823 1
	while (*p != '\0' && !isspace(UCH(*p)) &&
d862 1
a862 1
		if (isdigit(UCH(*p))) {
d871 1
a871 1
		    while (*p != '\0' && isalpha(UCH(*p))) {
d874 1
a874 1
		    while (*p == ',' || isspace(UCH(*p))) {
d881 2
a882 2
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
d899 1
a899 1
		       isdigit(UCH(*p))) {
d906 1
a906 1
		    while (isdigit(UCH(*p)))
d914 1
a914 1
			if (*cp != '\0' && isdigit(UCH(*cp))) {
d916 1
a916 1
			    while (isdigit(UCH(*cp1)))
d932 1
a932 1
			isspace(UCH(*(value_end - 1)))) {
d935 2
a936 2
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
a942 1
		BOOLEAN escaped = FALSE;
d944 1
a944 1
		 *  It looks like quoted string.
d948 1
a948 2
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
d950 2
a951 3
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
a952 8
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
d965 1
a965 1
		    isspace(UCH(*(value_end - 1)))) {
d968 2
a969 2
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
d990 1
a990 6
	    if (value_start && value_end >= value_start) {
		/*
		 * Presence of value is now needed (indicated normally by '=')
		 * to start a cookie, but it can now be an empty string.
		 * - kw 1999-06-24
		 */
d996 1
a996 1
		value = typecallocn(char, value_len + 1);
d1061 2
a1062 2
			CTRACE((tfp, "LYProcessSetCookies: Rejecting commentURL value '%s'\n",
				    cur_cookie->commentURL));
d1088 1
a1088 1
				   isdigit(UCH(*ptr)))
d1091 1
a1091 1
				CTRACE((tfp,
d1093 1
a1093 1
					    value));
d1128 1
a1128 1
			   (isdigit(UCH(*cp)) ||
d1177 1
a1177 1
			CTRACE((tfp, "LYSetCookie: expires %ld, %s",
d1179 1
a1179 1
				    ctime(&cur_cookie->expires)));
d1199 1
a1199 1
			    CTRACE((tfp, "LYSetCookie: expires %ld, %s",
d1201 1
a1201 1
					ctime(&cur_cookie->expires)));
a1220 3
	     *
	     * Presence of value is now needed (indicated normally by '='),
	     * but it can now be an empty string. - kw 1999-06-24
d1222 1
a1222 1
	    if (!known_attr && value && value_end >= value_start) {
d1237 1
a1237 1
		    CTRACE((tfp,
d1242 2
a1243 2
				 cur_cookie->value : "[no value]")));
		    CTRACE((tfp,
d1246 1
a1246 1
			 : "                     due to invalid port!\n"));
d1288 1
a1288 1
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
d1290 2
a1291 2
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
d1297 1
a1297 1
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1301 1
a1301 1
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
d1303 2
a1304 2
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to invalid port!\n"));
d1319 1
a1319 1
	CTRACE((tfp, "LYProcessSetCookies: Using Set-Cookie header.\n"));
d1328 1
a1328 1
	while (*p != '\0' && !isspace(UCH(*p)) &&
d1363 1
a1363 1
		if (isdigit(UCH(*p))) {
d1372 1
a1372 1
		    while (*p != '\0' && isalpha(UCH(*p))) {
d1375 1
a1375 1
		    while (*p == ',' || isspace(UCH(*p))) {
d1382 2
a1383 2
		    if (isspace(UCH(*p))) {
			while (isspace(UCH(*(p + 1))))
d1400 1
a1400 1
		       isdigit(UCH(*p))) {
d1407 1
a1407 1
		    while (isdigit(UCH(*p)))
d1415 1
a1415 1
			if (*cp != '\0' && isdigit(UCH(*cp))) {
d1417 1
a1417 1
			    while (isdigit(UCH(*cp1)))
d1433 1
a1433 1
			isspace(UCH(*(value_end - 1)))) {
d1436 2
a1437 2
			       isspace(UCH(*value_end)) &&
			       isspace(UCH(*(value_end - 1)))) {
a1443 1
		BOOLEAN escaped = FALSE;
d1445 1
a1445 1
		 *  It looks like quoted string.
d1449 1
a1449 2
		while (*p != '\0' && (*p != '"' || escaped)) {
		    escaped = (BOOL) (!escaped && *p == '\\');
d1451 2
a1452 3
		}
		if (p != value_start && *p == '"' && !escaped) {
		    value_end = p;
d1454 1
a1454 8
		    Quoted = TRUE;
		} else {
		    value_start--;
		    value_end = p;
		    if (*p)
			p++;
		    Quoted = FALSE;
		}
d1467 1
a1467 1
		    isspace(UCH(*(value_end - 1)))) {
d1470 2
a1471 2
			   isspace(UCH(*value_end)) &&
			   isspace(UCH(*(value_end - 1)))) {
d1492 1
a1492 6
	    if (value_start && value_end >= value_start) {
		/*
		 * Presence of value is now needed (indicated normally by '=')
		 * to start a cookie, but it can now be an empty string.
		 * - kw 1999-06-24
		 */
d1498 1
a1498 1
		value = typecallocn(char, value_len + 1);
d1500 1
a1500 1
		    outofmem(__FILE__, "LYProcessSetCookies");
d1563 2
a1564 2
			CTRACE((tfp, "LYProcessSetCookies: Rejecting commentURL value '%s'\n",
				    cur_cookie->commentURL));
d1590 1
a1590 1
				   isdigit(UCH(*ptr)))
d1593 1
a1593 1
				CTRACE((tfp,
d1595 1
a1595 1
					    value));
d1630 1
a1630 1
			   (isdigit(UCH(*cp)) ||
a1707 3
	     *
	     * Presence of value is now needed (indicated normally by '='),
	     * but it can now be an empty string. - kw 1999-06-24
d1709 1
a1709 1
	    if (!known_attr && value && value_end >= value_start) {
d1728 1
a1728 1
		    CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
d1732 2
a1733 2
				 cur_cookie->value : "[no value]")));
		    CTRACE((tfp, "                     due to excessive length!\n"));
d1771 1
a1771 1
	CTRACE((tfp, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
d1773 2
a1774 2
		    (cur_cookie->value ? cur_cookie->value : "[no value]")));
	CTRACE((tfp, "                     due to excessive %s%s%s\n",
d1777 1
a1777 1
		    (NumCookies > max_cookies_domain ? "number!\n" : "!\n")));
d1788 1
a1788 1
	CTRACE((tfp, "LYProcessSetCookie: attr=value pair: '%s=%s'\n",
d1790 1
a1790 1
			    (co->value ? co->value : "[no value]")));
d1792 1
a1792 1
		CTRACE((tfp, "                    expires: %ld, %s\n",
d1794 1
a1794 1
			    ctime(&co->expires)));
d1800 1
a1800 1
	    CTRACE((tfp, "                    Forced the 'secure' flag on.\n"));
d1840 9
a1848 1
    path = HTParse(address, "", PARSE_PATH|PARSE_PUNCTUATION);
d1858 1
a1858 1
    CTRACE((tfp, "LYSetCookie called with host '%s', path '%s',\n",
d1860 1
a1860 1
		(path ? path : "")));
d1862 2
a1863 2
	CTRACE((tfp, "    and Set-Cookie: '%s'\n",
			 (SetCookie ? SetCookie : "")));
d1866 2
a1867 2
	CTRACE((tfp, "    and Set-Cookie2: '%s'\n",
			 (SetCookie2 ? SetCookie2 : "")));
d1870 1
a1870 1
	CTRACE((tfp, "    Ignoring this Set-Cookie/Set-Cookie2 request.\n"));
d1896 2
a1897 2
	char *,		hostname,
	char *,		path,
d1905 2
a1906 2
    CTRACE((tfp, "LYCookie: Searching for '%s:%d', '%s'.\n",
		NONNULL(hostname),
d1908 1
a1908 1
		NONNULL(path)));
d1927 1
a1927 1
	    } else if (de->bv == QUERY_USER && de->invcheck_bv == DEFAULT_INVCHECK_BV) {
d1974 1
a1974 1
    cookie_handle = fopen(cookie_file, TXT_R);
d1978 1
a1978 1
    CTRACE((tfp, "LYLoadCookies: reading cookies from %s\n", cookie_file));
d2001 1
a2001 4
	if (buf[i] == '\n') {
	    buf[i++] = '\t';	/* add sep after line if enough space - kw */
	    buf[i] = '\0';
	}
d2013 1
a2013 7
	/*
	 * This fails when the path is blank
	 *
	 * sscanf(buf, "%s\t%s\t%s\t%s\t%d\t%s\t%[ -~]",
	 *  domain, what, path, secure, &expires, name, value);
	 */
	CTRACE((tfp, "LYLoadCookies: tokenising %s\n", buf));
d2017 2
a2018 2
	    CTRACE((tfp, "\t%d:%p:%p:[%s]\n",
		tok_loop, tok_values[tok_loop].s, tok_out, tok_out));
d2028 1
d2030 6
a2035 5
	if (tok_values[tok_loop].s) {
	    /* tok_out in above loop must have been NULL prematurely - kw */
	    CTRACE((tfp, "*** wrong format: not enough tokens, ignoring line!\n"));
	    continue;
	}
d2037 3
a2039 4
	expires = atol(expires_a);
	CTRACE((tfp, "expires:\t%s\n", ctime(&expires)));
/* 	CTRACE((tfp, "%s\t%s\t%s\t%s\t%ld\t%s\t%s\tREADCOOKIE\n", */
/* 	    domain, what, path, secure, (long) expires, name, value)); */
d2044 1
a2044 9
	if (value && value[0] == '"' &&
	    value[1] && value[strlen(value)-1] == '"' &&
	    value[strlen(value)-2] != '\\') {
	    value[strlen(value)-1] = '\0';
	    StrAllocCopy(moo->value, value+1);
	    moo->quoted = TRUE;
	} else {
	    StrAllocCopy(moo->value, value);
	}
d2094 1
a2094 1
    LYCloseInput (cookie_handle);
d2101 3
a2109 5
    if (!strcmp(cookie_file, "/dev/null")) {
	/* We give /dev/null the Unix meaning, regardless of OS */
	return;
    }

d2121 1
a2121 1
    CTRACE((tfp, "LYStoreCookies: save cookies to %s on exit\n", cookie_file));
d2133 18
d2161 1
a2161 1
	    CTRACE((tfp, "LYStoreCookies: %ld cf %ld ", (long) now, (long) co->expires));
d2164 1
a2164 1
		CTRACE((tfp, "not stored - DISCARD\n"));
d2167 1
a2167 1
		CTRACE((tfp, "not stored - no expiration time\n"));
d2170 1
a2170 1
		CTRACE((tfp, "not stored - EXPIRED\n"));
d2174 1
a2174 1
	    fprintf(cookie_handle, "%s\t%s\t%s\t%s\t%ld\t%s\t%s%s%s\n",
d2176 1
a2176 2
		    (de->domain[0] == '.') ? "TRUE" : "FALSE",
		    co->path,
d2178 1
a2178 4
		(long) co->expires, co->name,
		    (co->quoted ? "\"" : ""),
		    co->value,
		    (co->quoted ? "\"" : ""));
d2180 1
a2180 1
	    CTRACE((tfp, "STORED\n"));
d2183 1
a2183 1
    LYCloseOutput(cookie_handle);
d2230 1
a2230 2
	LYSleepMsg();
	HTNoDataOK = 1;
d2266 1
a2266 1
	    if (!strcasecomp(domain, de->domain)) {
a2290 1
				HTNoDataOK = 1;
d2315 1
a2315 2
			    LYSleepMsg();
			    HTNoDataOK = 1;
a2330 1
		    HTNoDataOK = 1;
d2332 1
a2332 1
			ch = LYgetch_single();
d2339 1
a2339 1
			switch(ch) {
d2351 2
a2355 1
			      reject:
d2371 1
a2371 1
				    LYSleepMsg();
d2392 1
a2392 1
				LYSleepMsg();
d2411 1
a2411 1
				    LYSleepMsg();
a2438 2
				if (LYCharIsINTERRUPT(ch))
				    goto reject;
d2454 1
a2454 1
	    LYSleepMsg();
d2486 1
a2486 1
    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
d2495 1
a2495 1
    HTSprintf0(&buf, "<note>%s\n", ACTIVATE_TO_GOBBLE);
d2497 1
a2497 1
    HTSprintf0(&buf, "%s</note>\n", OR_CHANGE_ALLOW);
d2500 1
a2500 1
    HTSprintf0(&buf, "<dl compact>\n");
d2513 1
a2513 1
	HTSprintf0(&buf, "<dt>%s<dd><a href=\"LYNXCOOKIE://%s/\">Domain=%s</a>\n",
d2526 5
d2561 1
a2561 1
	    HTSprintf0(&buf, "<dd><a href=\"LYNXCOOKIE://%s/%s\">%s=%s</a>\n",
d2581 1
a2581 1
	    HTSprintf0(&buf, "<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",
d2592 1
a2592 1
		HTSprintf0(&buf, "<dD>PortList=\"%s\"\n", co->PortList);
d2605 1
a2605 1
			"<dd>CommentURL: <a href=\"%s\">%s</a>\n",
d2619 1
a2619 1
		HTSprintf0(&buf, "<dd>Comment: %s\n", comment);
d2627 1
a2627 1
	    HTSprintf0(&buf, "<dd><em>%s</em> %s%s",
d2637 1
a2637 1
	HTSprintf0(&buf, "</dt>\n");
d2640 1
a2640 1
    HTSprintf0(&buf, "</dl>\n</body>\n</html>\n");
d2662 1
a2662 1
	int, 		flag)
d2667 1
a2667 1
    char **str = typecalloc(char *);
d2672 2
a2673 5
    if (str == NULL) {
	HTAlwaysAlert(gettext("Internal"),
		      gettext("cookie_domain_flag_set error, aborting program"));
	exit_immediately(EXIT_FAILURE);
    }
a2693 5
	if (*strsmall == '\0')
	    /* Never add a domain for empty string.  It would actually
	     * make more sense to use strtok here. - kw */
	    continue;

d2703 1
a2703 1
		!strcasecomp(strsmall, de2->domain)) {
d2712 1
a2712 1
	    de = typecalloc(domain_entry);
d2719 1
a2719 1
					   de->invcheck_bv = DEFAULT_INVCHECK_BV;
d2722 1
a2722 1
					   de->invcheck_bv = DEFAULT_INVCHECK_BV;
d2725 4
a2728 1
					   de->invcheck_bv = DEFAULT_INVCHECK_BV;
d2752 2
a2766 40
}

/*
 * If any COOKIE_{ACCEPT,REJECT}_DOMAINS have been defined, process them. 
 * These are comma delimited lists of domains.  - BJP
 *
 * And for query/strict/loose invalid cookie checking.  - BJP
 */
PUBLIC void LYConfigCookies NOARGS
{
    static CONST struct {
	char **domain;
	int flag;
	int once;
    } table[] = {
	{ &LYCookieSAcceptDomains,	FLAG_ACCEPT_ALWAYS,   TRUE },
	{ &LYCookieSRejectDomains,	FLAG_REJECT_ALWAYS,   TRUE },
	{ &LYCookieSStrictCheckDomains, FLAG_INVCHECK_STRICT, TRUE },
	{ &LYCookieSLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  TRUE },
	{ &LYCookieSQueryCheckDomains,	FLAG_INVCHECK_QUERY,  TRUE },
	{ &LYCookieAcceptDomains,	FLAG_ACCEPT_ALWAYS,   FALSE },
	{ &LYCookieRejectDomains,	FLAG_REJECT_ALWAYS,   FALSE },
	{ &LYCookieStrictCheckDomains,	FLAG_INVCHECK_STRICT, FALSE },
	{ &LYCookieLooseCheckDomains,	FLAG_INVCHECK_LOOSE,  FALSE },
	{ &LYCookieQueryCheckDomains,	FLAG_INVCHECK_QUERY,  FALSE },
    };
    unsigned n;

    for (n = 0; n < TABLESIZE(table); n++) {
	if (*(table[n].domain) != NULL) {
	    cookie_domain_flag_set(*(table[n].domain), table[n].flag);
	    /*
	     * Discard the value for system settings after we've used them.
	     * The local settings will be merged with the contents of .lynxrc
	     */
	    if (table[n].once) {
		FREE(*(table[n].domain));
	    }
	}
    }
@

