head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.46.09;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.17.06;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.38;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.40;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.36;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.29;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.50;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.23;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.16.05;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.53.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@/*
 *  This file contains code for changing the Linux console mode.
 *  Currently some names for font files are hardwired in here.
 *  You have to change this code if it needs accommodation for your
 *  system (or get the required files...).
 *
 *  Depending on the Display Character Set switched to, and the previous
 *  one as far as it is known, system("setfont ...") and/or output of
 *  escape sequences to switch console mode are done.  Curses will be
 *  temporarily suspended while that happens.
 *
 *  NOTE that the setfont calls will also affect all other virtual consoles.
 *
 *  Any ideas how to do this for other systems?
 */

#include <HTUtils.h>
#include <LYUtils.h>

#include <UCMap.h>
#include <UCDefs.h>
#include <UCAuto.h>
#include <LYGlobalDefs.h>
#include <LYClean.h>
#include <LYLeaks.h>
#include <LYCharSets.h>

#ifdef EXP_CHARTRANS_AUTOSWITCH

#  ifdef CAN_SWITCH_DISPLAY_CHARSET
char *charset_switch_rules;
char *charsets_directory;
int auto_other_display_charset = -1;
int codepages[2];
int real_charsets[2] =
{-1, -1};			/* Non "auto-" charsets for the cps */
int switch_display_charsets;

#  endif

#  ifdef __EMX__
/* If we "just include" <os2.h>, BOOLEAN conflicts. */
#  define BOOLEAN OS2_BOOLEAN	/* This file doesn't use it, conflicts */
#  define INCL_VIO		/* I want some Vio functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
#  define INCL_DOSNLS		/* DosQueryCp. */
#  include <os2.h>		/* Misc stuff.. */
#  include <os2thunk.h>		/* 32 bit to 16 bit pointer conv */
#  endif

#ifdef LINUX
typedef enum {
    Is_Unset, Is_Set, Dunno, Dont_Care
} TGen_state_t;
typedef enum {
    G0, G1
} TGNstate_t;
typedef enum {
    GN_Blat1, GN_0decgraf, GN_Ucp437, GN_Kuser, GN_dunno, GN_dontCare
} TTransT_t;

static char *T_font_fn = NULL;
static char *T_umap_fn = NULL;

#define SETFONT "setfont"
#define NOOUTPUT "2>/dev/null >/dev/null"

/*
 * call_setfont - execute "setfont" command via system()
 * returns:	 0  ok (as far as we know)
 *		-1  error (assume font and umap are not loaded)
 *		 1  error with umap (assume font loaded but umap empty)
 */
static int call_setfont(const char *font,
			const char *fnsuffix,
			const char *umap)
{
    char *T_setfont_cmd = NULL;
    int rv;

    if ((font && T_font_fn && !strcmp(font, T_font_fn))
	&& (umap && T_umap_fn && !strcmp(umap, T_umap_fn))) {
	/*
	 * No need to repeat.
	 */
	return 0;
    }
    if (font)
	StrAllocCopy(T_font_fn, font);
    if (umap)
	StrAllocCopy(T_umap_fn, umap);

    if (!*fnsuffix)
	fnsuffix = "";

    if (umap && *umap && font && *font) {
	HTSprintf0(&T_setfont_cmd, "%s %s%s -u %s %s",
		   SETFONT, font, fnsuffix, umap, NOOUTPUT);
    } else if (font && *font) {
	HTSprintf0(&T_setfont_cmd, "%s %s%s %s",
		   SETFONT, font, fnsuffix, NOOUTPUT);
    } else if (umap && *umap) {
	HTSprintf0(&T_setfont_cmd, "%s -u %s %s",
		   SETFONT, umap, NOOUTPUT);
    }

    if (T_setfont_cmd) {
	CTRACE((tfp, "Executing setfont: '%s'\n", T_setfont_cmd));
	rv = LYSystem(T_setfont_cmd);
	FREE(T_setfont_cmd);
	if (rv) {
	    CTRACE((tfp, "call_setfont: system returned %d (0x%x)!\n",
		    rv, rv));
	    if ((rv == 0x4200 || rv == 0x4100) && umap && *umap)
		/*
		 * It seems setfont returns 65 or 66 to the shell if
		 * the font was loaded ok but something was wrong with
		 * the umap file. - kw
		 */
		return 1;
	    else
		return -1;
	}
    }
    return 0;
}

static void write_esc(const char *p)
{
    int fd = open("/dev/tty", O_WRONLY);

    if (fd >= 0) {
	write(fd, p, strlen(p));
	close(fd);
    }
}

static int nonempty_file(const char *p)
{
    struct stat sb;

    return (stat(p, &sb) == 0 &&
	    S_ISREG(sb.st_mode) &&
	    (sb.st_size != 0));
}

/*
 * This is the thing that actually gets called from display_page().
 */
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
{
    static int lastcs = -1;
    static const char *lastname = NULL;
    static TTransT_t lastTransT = GN_dunno;
    static TGen_state_t lastUtf = Dunno;
    static TGen_state_t lastHasUmap = Dunno;

    static char *old_font = NULL;
    static char *old_umap = NULL;

    const char *name;
    TTransT_t TransT = GN_dunno;
    TGen_state_t Utf = Dunno;
    TGen_state_t HasUmap = Dunno;

    char *tmpbuf1 = NULL;
    char *tmpbuf2 = NULL;
    int status = 0;

    /*
     * Restore the original character set.
     */
    if (newcs < 0 || p == 0) {
	if (old_font && *old_font &&
	    old_umap && *old_umap) {
	    int have_font = nonempty_file(old_font);
	    int have_umap = nonempty_file(old_umap);

	    if (have_font) {
		if (have_umap) {
		    HTSprintf0(&tmpbuf1, "%s %s -u %s %s",
			       SETFONT, old_font, old_umap, NOOUTPUT);
		} else {
		    HTSprintf0(&tmpbuf1, "%s %s %s",
			       SETFONT, old_font, NOOUTPUT);
		}
		CTRACE((tfp, "Executing setfont to restore: '%s'\n", tmpbuf1));
		status = LYSystem(tmpbuf1);
		FREE(tmpbuf1);
	    }
	}
	if (newcs < 0 && p == 0) {
	    if (old_font) {
		LYRemoveTemp(old_font);
		FREE(old_font);
	    }
	    if (old_umap) {
		LYRemoveTemp(old_umap);
		FREE(old_umap);
	    }
	    if (status == 0) {
		FREE(T_font_fn);
		FREE(T_umap_fn);
	    }
	}
	return;
    } else if (lastcs < 0 && old_umap == 0 && old_font == 0) {
	FILE *fp1;
	FILE *fp2 = NULL;
	if ((old_font = typecallocn(char, LY_MAXPATH)))
	      old_umap = typecallocn(char, LY_MAXPATH);

	if ((fp1 = LYOpenTemp(old_font, ".fnt", BIN_W)))
	    fp2 = LYOpenTemp(old_umap, ".uni", BIN_W);
	if (fp1 && fp2) {
	    size_t nlen;
	    char *rp;

	    HTSprintf0(&tmpbuf1, "%s -o %s -ou %s %s",
		       SETFONT, old_font, old_umap, NOOUTPUT);
	    CTRACE((tfp, "Executing setfont to save: '%s'\n", tmpbuf1));
	    LYSystem(tmpbuf1);
	    FREE(tmpbuf1);
	    LYCloseTempFP(fp1);
	    LYCloseTempFP(fp2);
	    if ((nlen = strlen(old_font)) + 1 < LY_MAXPATH &&
		(rp = typeRealloc(char, old_font, nlen + 1)))
		  old_font = rp;

	    if ((nlen = strlen(old_umap)) + 1 < LY_MAXPATH &&
		(rp = typeRealloc(char, old_umap, nlen + 1)))
		  old_umap = rp;
	} else {
	    if (fp1)
		LYRemoveTemp(old_font);
	    if (fp2)
		LYRemoveTemp(old_umap);
	    FREE(old_font);
	    FREE(old_umap);
	}
    }

    name = p->MIMEname;

    /*
     * Font sizes are currently hardwired here.
     */
#define SUFF1 ".f16"
#define SUFF2 "-16.psf"
#define SUFF3 "-8x16"
#define SUFF4 "8x16"
#define SUFF5 ".cp -16"

    /*
     * Use this for output of escape sequences.
     */
    if ((x_display != NULL) ||
	LYgetXDisplay() != NULL) {
	/*
	 * We won't do anything in an xterm.  Better that way...
	 */
	return;
    }

    /* NOTE: `!!umap not in kbd!!' comments below means that the *.uni file
       is not found in kbd package.  Reference Debian Package: kbd-data,
       Version: 0.96a-14.  They should be located elsewhere or generated.
       Also some cpNNN fonts used below are not in the kbd-data.  - kw
     */

    if (!strncmp(name, "iso-8859-1", 10) &&
	(!name[10] || !isdigit(UCH(name[10])))
	) {
	if ((lastHasUmap == Is_Set) && !strcmp(lastname, "cp850")) {
	    /*
	     * cp850 already contains all latin1 characters.
	     */
	    if (lastTransT != GN_Blat1) {
		TransT = GN_Blat1;
	    }
	} else {
	    /*
	     * "setfont lat1u-16.psf -u lat1u.uni"
	     */
	    status = call_setfont("lat1u", SUFF2, "lat1u.uni");
	    HasUmap = Is_Set;
	    if (lastTransT != GN_Blat1) {
		TransT = GN_Blat1;
	    }
	}
	Utf = Is_Unset;
    } else if (!strcmp(name, "iso-8859-2")) {
	/*
	 * "setfont iso02.f16 -u iso02.uni"
	 */
	status = call_setfont("iso02", SUFF1, "iso02.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "iso-8859-15")) {
	/*
	 * "setfont lat0-16.psf"
	 */
	status = call_setfont("lat0", SUFF2, NULL);
	TransT = GN_Blat1;	/* bogus! */
	HasUmap = Dunno;	/* distributed lat0 files have bogus map data! */
	Utf = Is_Unset;
    } else if (!strncmp(name, "iso-8859-", 9)) {
	if (strlen(name) <= 10 || !isdigit(UCH(name[10])))
	    HTSprintf0(&tmpbuf1, "iso0%s", &name[9]);
	else
	    HTSprintf0(&tmpbuf1, "iso%s", &name[9]);
	HTSprintf0(&tmpbuf2, "%s.uni", tmpbuf1);
	/*
	 * "setfont iso0N.f16 -u iso0N.uni"
	 */
	status = call_setfont(tmpbuf1, SUFF1, tmpbuf2);
	FREE(tmpbuf1);
	FREE(tmpbuf2);
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "koi8-r")) {
	/*
	 * "setfont koi8-8x16"
	 */
	status = call_setfont("koi8", SUFF3, "koi8r.uni");	/* !!umap not in kbd!! */
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp437")) {
	/*
	 * "setfont default8x16 -u cp437.uni"
	 */
	status = call_setfont("default", SUFF4, "cp437.uni");
	if (lastTransT == GN_Kuser || lastTransT == GN_Ucp437)
	    TransT = GN_dontCare;
	else
	    TransT = GN_Ucp437;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp850")) {
	/*
	 * "setfont cp850-8x16 -u cp850.uni"
	 */
	status = call_setfont("cp850", SUFF3, "cp850.uni");	/* !!umap not in kbd!! */
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp866") ||
	       !strcmp(name, "cp852") ||
	       !strcmp(name, "cp862")) {	/* MS-Kermit has these files */
	HTSprintf0(&tmpbuf2, "%s.uni", name);
	/*
	 * "setfont cpNNN.f16"
	 */
	status = call_setfont(name, SUFF1, tmpbuf2);	/* !!umap not in kbd!! */
	FREE(tmpbuf2);
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp737")) {
	/*
	 * "setfont cp737.cp"
	 */
	status = call_setfont("737", SUFF5, "cp737.uni");	/* !!umap not in kbd!! */
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "x-transparent")) {
	Utf = Dont_Care;
    } else if (!strcmp(name, "us-ascii")) {
	Utf = Dont_Care;
    } else if (!strncmp(name, "mnem", 4)) {
	Utf = Dont_Care;
    }

    if (status == 1)
	HasUmap = Is_Unset;
    else if (status < 0) {
	if (HasUmap == Is_Set)
	    HasUmap = Dunno;
	name = "unknown-8bit";
    }

    if (TransT != lastTransT) {
	if (TransT == GN_Blat1) {
	    /*
	     * Switch Linux console to lat1 table.
	     */
	    write_esc("\033(B");
	} else if (TransT == GN_0decgraf) {
	    write_esc("\033(0");
	} else if (TransT == GN_Ucp437) {
	    /*
	     * Switch Linux console to 437 table?
	     */
	    write_esc("\033(U");
	} else if (TransT == GN_Kuser) {
	    /*
	     * Switch Linux console to user table.
	     */
	    write_esc("\033(K");
	}
	if (TransT != GN_dunno && TransT != GN_dontCare) {
	    lastTransT = TransT;
	} else {
	    TransT = lastTransT;
	}
    }

    if (HasUmap != Dont_Care && HasUmap != Dunno)
	lastHasUmap = HasUmap;

    if (p->enc == UCT_ENC_UTF8) {
	if (lastUtf != Is_Set) {
	    Utf = Is_Set;
	    /*
	     * Turn Linux console UTF8 mode ON.
	     */
	    write_esc("\033%G");
	    lastUtf = Utf;
	}
	return;
    } else if (lastUtf == Is_Set && Utf != Dont_Care) {
	Utf = Is_Unset;
	/*
	 * Turn Linux console UTF8 mode OFF.
	 */
	write_esc("\033%@@");
	lastUtf = Utf;
    }

    if (Utf != Dont_Care && Utf != Dunno)
	lastUtf = Utf;

    lastcs = newcs;
    lastname = name;
}

#else /* Not LINUX: */
/*
 * This is the thing that actually gets called from display_page().
 */
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
{
#ifdef __EMX__
    int res = 0;

    if (newcs < 0)
	newcs = auto_display_charset;
    res = Switch_Display_Charset(newcs, SWITCH_DISPLAY_CHARSET_REALLY);
    CTRACE((tfp,
	    "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n",
	    newcs, res));
#else
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
#endif
}
#endif /* LINUX */

#ifdef CAN_SWITCH_DISPLAY_CHARSET

int Find_Best_Display_Charset(int ord)
{
    const char *name = LYCharSet_UC[ord].MIMEname;
    char *s = charset_switch_rules, *r;
    char buf[160];
    static int lowercase;
    int n = strlen(name), source = 1;

    if (!s || !n)
	return ord;
    if (!lowercase++)
	LYLowerCase(charset_switch_rules);
    while (1) {
	while (*s && strchr(" \t,", *s))
	    s++;		/* Go to start of a name or ':' */
	if (!*s && source)
	    return ord;		/* OK to find nothing */
	if (!*s) {
	    sprintf(buf, "No destination for '%.80s' in CHARSET_SWITCH_RULES",
		    name);
	    HTInfoMsg(buf);
	    return ord;
	}
	if (*s == ':') {
	    /* Before the replacement name */
	    while (*s && strchr(" \t:", *s))
		s++;		/* Go to the replacement */
	    /* At start of the replacement name */
	    r = s;
	    while (*s && !strchr(" \t,:", *s))
		s++;		/* Skip the replacement */
	    if (source)
		continue;
	    break;
	}
	/* At start of the source name */
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {	/* Found! */
	    source = 0;
	    s += n;
	    continue;		/* Look for the replacement */
	}
	while (*s && !strchr(" \t,:", *s))
	    s++;		/* Skip the other source names */
    }
    /* Here r point to the replacement, s to the end of the replacement. */
    if (s >= r + sizeof(buf)) {
	HTInfoMsg(gettext("Charset name in CHARSET_SWITCH_RULES too long"));
	return ord;
    }
    strncpy(buf, r, s - r);
    buf[s - r] = '\0';
    n = UCGetLYhndl_byMIME(buf);
    if (n < 0) {
	sprintf(buf, "Unknown charset name '%.*s' in CHARSET_SWITCH_RULES",
		s - r, r);
	HTInfoMsg(buf);
	return ord;
    }
    return n;
}

#  ifdef __EMX__
/* Switch display for the best fit for LYCharSet_UC[ord].
   If really is MAYBE, the switch is tentative only, another switch may happen
   before the actual display.

   Returns the charset we switched to.  */
static int _Switch_Display_Charset(int ord, enum switch_display_charset_t really)
{
    const char *name;
    unsigned short cp;
    static int font_loaded_for = -1, old_h, old_w;
    int rc, ord1;
    UCHAR msgbuf[MAXPATHLEN + 80];

    CTRACE((tfp, "_Switch_Display_Charset(cp=%d, really=%d).\n", ord, really));
    /* Do not trust current_char_set unless REALLY, we fake it if MAYBE! */
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;
    if (ord == auto_other_display_charset
	|| ord == auto_display_charset || ord == font_loaded_for) {
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord;		/* Report success, to avoid flicker, switch later */
    } else			/* Currently supports only koi8-r to cp866 translation */
	ord = Find_Best_Display_Charset(ord);

    /* Ignore sizechange unless the font is loaded */
    if (ord != font_loaded_for && really == SWITCH_DISPLAY_CHARSET_RESIZE)
	return ord;

    if (ord == real_charsets[0] || ord == real_charsets[1]) {
	ord1 = (ord == real_charsets[1]
		? auto_other_display_charset : auto_display_charset);
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord;		/* Can switch later, report success to avoid flicker */
    } else
	ord1 = ord;
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;

    name = LYCharSet_UC[ord1].MIMEname;
    if (ord1 == auto_other_display_charset || ord1 == auto_display_charset) {
      retry:
	rc = VioSetCp(0, codepages[ord1 == auto_other_display_charset], 0);
	if (rc == 0)
	    goto report;
      err:
	sprintf(msgbuf, "Can't change to '%s': err=%#lx=%ld", name, rc, rc);
	HTInfoMsg(msgbuf);
	return -1;
    }

    /* Not a "prepared" codepage.  Need to load the user font. */
    if (charsets_directory) {
	TIB *tib;		/* Can't load font in a windowed-VIO */
	PIB *pib;
	VIOFONTINFO f[2];
	VIOFONTINFO *font;
	UCHAR b[1 << 17];
	UCHAR *buf = b;
	UCHAR fnamebuf[MAXPATHLEN];
	FILE *file;
	APIRET rc;
	long i, j;

	/* 0 means a FS protected-mode session */
	if (font_loaded_for == -1	/* Did not try it yet */
	    && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0)) {
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	/* Should not cross 64K boundaries: */
	font = f;
	if (((((ULONG) (char *) f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
	    font++;
	if (((ULONG) buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG) buf) & 0xFFFF);
	font->cb = sizeof(*font);	/* How large is this structure */
	font->type = 0;		/* Not the BIOS, the loaded font. */
	font->cbData = 65535;	/* How large is my buffer? */
	font->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */

	rc = VioGetFont(font, 0);	/* Retrieve data for current font */
	if (rc) {
	    sprintf(msgbuf, "Can't fetch current font info: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	if (ord1 == font_loaded_for
	    && old_h == font->cyCell && old_w == font->cxCell) {
	    /* The same as the previous font */
	    if ((rc = VioSetCp(0, -1, 0)))	/* -1: User font */
		goto err;
	    goto report;
	}
	sprintf(fnamebuf, "%s/%dx%d/%s.fnt",
		charsets_directory, font->cyCell, font->cxCell, name);
	file = fopen(fnamebuf, BIN_R);
	if (!file) {
	    sprintf(msgbuf, "Can't open font file '%s'", fnamebuf);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	i = ftell(file);
	fseek(file, 0, SEEK_END);
	if (ftell(file) - i != font->cbData) {
	    fclose(file);
	    sprintf(msgbuf, "Mismatch of size of font file '%s'", fnamebuf);
	    HTAlert(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	fseek(file, i, SEEK_SET);
	fread(buf, 1, font->cbData, file);
	fclose(file);
	rc = VioSetFont(font, 0);	/* Put it all back.. */
	if (rc) {
	    sprintf(msgbuf, "Can't set font: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    font_loaded_for = -1;
	    goto retry;
	}
	font_loaded_for = ord1;
	old_h = font->cyCell;
	old_w = font->cxCell;
    } else {
	ord = ord1 = auto_display_charset;
	goto retry;
    }
  report:
    CTRACE((tfp, "Display font set to '%s'.\n", name));
    return ord;
}
#  endif			/* __EMX__ */

int Switch_Display_Charset(const int ord, const enum switch_display_charset_t really)
{
    int prev = current_char_set;
    int res;
    static int repeated;

    if (!switch_display_charsets
	&& (really == SWITCH_DISPLAY_CHARSET_MAYBE
#ifdef SWITCH_DISPLAY_CHARSET_NOT_NEEDED_ANY_MORE
    /* The first switch is not due to an interactive action */
	    || (really == SWITCH_DISPLAY_CHARSET_REALLY
		&& !(repeated++))
#endif
	))
	return 0;
    res = _Switch_Display_Charset(ord, really);
    if (res < 0 || prev == res)	/* No change */
	return 0;
    /* Register the change */
    current_char_set = res;
    HTMLUseCharacterSet(current_char_set);
    return 1;
}
#endif /* CAN_SWITCH_DISPLAY_CHARSET */

#else /* EXP_CHARTRANS_AUTOSWITCH not defined: */
/*
 * This is the thing that actually gets called from display_page().
 */
void UCChangeTerminalCodepage(int newcs GCC_UNUSED,
			      LYUCcharset *p GCC_UNUSED)
{
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
}
#endif /* EXP_CHARTRANS_AUTOSWITCH */
@


1.5
log
@automatic merge of lynx-current
@
text
@d228 3
a230 2
		(rp = realloc(old_font, nlen + 1)))
		old_font = rp;
d232 2
a233 2
		(rp = realloc(old_umap, nlen + 1)))
		old_umap = rp;
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 14
a15 14
**  This file contains code for changing the Linux console mode.
**  Currently some names for font files are hardwired in here.
**  You have to change this code if it needs accommodation for your
**  system (or get the required files...).
**
**  Depending on the Display Character Set switched to, and the previous
**  one as far as it is known, system("setfont ...") and/or output of
**  escape sequences to switch console mode are done.  Curses will be
**  temporarily suspended while that happens.
**
**  NOTE that the setfont calls will also affect all other virtual consoles.
**
**  Any ideas how to do this for other systems?
*/
d35 2
a36 1
int real_charsets[2] = {-1, -1};	/* Non "auto-" charsets for the cps */
d38 1
d43 6
a48 6
#  define BOOLEAN OS2_BOOLEAN		/* This file doesn't use it, conflicts */
#  define INCL_VIO			/* I want some Vio functions.. */
#  define INCL_DOSPROCESS			/* TIB PIB. */
#  define INCL_DOSNLS			/* DosQueryCp. */
#  include <os2.h>			/* Misc stuff.. */
#  include <os2thunk.h>			/* 32 bit to 16 bit pointer conv */
d69 4
a72 4
 *  call_setfont - execute "setfont" command via system()
 *  returns:	0  ok (as far as we know)
 *	       -1  error (assume font and umap are not loaded)
 *		1  error with umap (assume font loaded but umap empty)
d74 3
a76 4
static int call_setfont (
	const char *	font,
	const char *	fnsuffix,
	const char *	umap)
d82 1
a82 1
     && (umap && T_umap_fn && !strcmp(umap, T_umap_fn))) {
d84 1
a84 1
	 *  No need to repeat.
d96 1
a96 1
    if (umap &&*umap && font && *font) {
d98 1
a98 1
		SETFONT, font, fnsuffix,	umap,	NOOUTPUT);
d101 1
a101 1
		SETFONT, font, fnsuffix,		NOOUTPUT);
d104 1
a104 1
		SETFONT,			umap,	NOOUTPUT);
d113 1
a113 1
		   rv, rv));
d128 1
a128 2
static void write_esc (
	const char *	p)
d138 1
a138 2
static int nonempty_file (
	const char *	p)
d148 1
a148 1
 *  This is the thing that actually gets called from display_page().
d150 2
a151 3
void UCChangeTerminalCodepage (
	int		newcs,
	LYUCcharset *	p)
d154 1
a154 1
    static const char * lastname = NULL;
d162 1
a162 1
    const char * name;
d172 1
a172 1
     *	Restore the original character set.
d183 1
a183 1
			    SETFONT, old_font, old_umap, NOOUTPUT);
d186 1
a186 1
			    SETFONT, old_font, NOOUTPUT);
d209 2
a210 2
	FILE * fp1;
	FILE * fp2 = NULL;
d212 2
a213 1
	    old_umap = typecallocn(char, LY_MAXPATH);
d219 1
d228 1
a228 1
		 (rp = realloc(old_font, nlen + 1)))
d231 1
a231 1
		 (rp = realloc(old_umap, nlen + 1)))
d246 1
a246 1
     *	Font sizes are currently hardwired here.
d255 1
a255 1
     *	Use this for output of escape sequences.
d260 1
a260 1
	 *  We won't do anything in an xterm.  Better that way...
d269 1
a269 1
       */
d272 1
a272 1
	       (!name[10] || !isdigit(UCH(name[10])))
d276 1
a276 1
	     *	cp850 already contains all latin1 characters.
d283 1
a283 1
	     *	"setfont lat1u-16.psf -u lat1u.uni"
d294 1
a294 1
	 *  "setfont iso02.f16 -u iso02.uni"
d302 1
a302 1
	 *  "setfont lat0-16.psf"
d306 1
a306 1
	HasUmap = Dunno; /* distributed lat0 files have bogus map data! */
d315 1
a315 1
	 *  "setfont iso0N.f16 -u iso0N.uni"
d325 1
a325 1
	 *  "setfont koi8-8x16"
d327 1
a327 1
	status = call_setfont("koi8", SUFF3, "koi8r.uni"); /* !!umap not in kbd!! */
d333 1
a333 1
	 *  "setfont default8x16 -u cp437.uni"
d344 1
a344 1
	 *  "setfont cp850-8x16 -u cp850.uni"
d346 1
a346 1
	status = call_setfont("cp850", SUFF3, "cp850.uni"); /* !!umap not in kbd!! */
d352 1
a352 1
	       !strcmp(name, "cp862")) { /* MS-Kermit has these files */
d355 1
a355 1
	 *  "setfont cpNNN.f16"
d357 1
a357 1
	status = call_setfont(name, SUFF1, tmpbuf2); /* !!umap not in kbd!! */
d364 1
a364 1
	 *  "setfont cp737.cp"
d366 1
a366 1
	status = call_setfont("737", SUFF5, "cp737.uni"); /* !!umap not in kbd!! */
d389 1
a389 1
	     *	Switch Linux console to lat1 table.
d395 3
a397 3
	     /*
	      *  Switch Linux console to 437 table?
	      */
d400 3
a402 3
	     /*
	      *  Switch Linux console to user table.
	      */
d419 1
a419 1
	     *	Turn Linux console UTF8 mode ON.
d428 1
a428 1
	 *  Turn Linux console UTF8 mode OFF.
d443 1
a443 1
 *  This is the thing that actually gets called from display_page().
d445 2
a446 3
void UCChangeTerminalCodepage (
	int		newcs,
	LYUCcharset *	p)
d454 3
a456 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n", newcs, res));
d465 1
a465 1
int Find_Best_Display_Charset (int ord)
d479 1
a479 1
	    s++;			/* Go to start of a name or ':' */
d481 1
a481 1
	    return ord;			/* OK to find nothing */
d491 1
a491 1
		s++;			/* Go to the replacement */
d495 1
a495 1
		s++;			/* Skip the replacement */
d501 1
a501 1
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {/* Found! */
d504 1
a504 1
	    continue;			/* Look for the replacement */
d507 1
a507 1
	    s++;			/* Skip the other source names */
d514 2
a515 2
    strncpy(buf, r, s-r);
    buf[s-r] = '\0';
d519 1
a519 1
		s-r, r);
d532 1
a532 1
static int _Switch_Display_Charset (int ord, enum switch_display_charset_t really)
d547 2
a548 2
	    return ord; /* Report success, to avoid flicker, switch later */
    } else	/* Currently supports only koi8-r to cp866 translation */
d557 1
a557 1
	       ? auto_other_display_charset : auto_display_charset);
d559 1
a559 1
	    return ord; /* Can switch later, report success to avoid flicker */
d568 1
a568 1
	rc = VioSetCp(0,codepages[ord1 == auto_other_display_charset],0);
d579 1
a579 1
	TIB *tib;			/* Can't load font in a windowed-VIO */
d583 1
a583 1
	UCHAR b[1<<17];
d586 1
a586 1
	FILE  *file;
d591 2
a592 2
	if ( font_loaded_for == -1		/* Did not try it yet */
	     && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0) ) {
d598 1
a598 1
	if (((((ULONG)(char*)f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
d600 2
a601 2
	if (((ULONG)buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
d603 3
a605 3
	font->type=0;			/* Not the BIOS, the loaded font. */
	font->cbData = 65535;		/* How large is my buffer? */
	font->pbData = _emx_32to16(buf); /* Wants an 16:16 pointer */
d607 1
a607 1
	rc = VioGetFont(font,0);	/* Retrieve data for current font */
d614 2
a615 2
	if ( ord1 == font_loaded_for
	     && old_h == font->cyCell && old_w == font->cxCell ) {
d640 1
a640 1
	fread(buf, 1, font->cbData,file);
d642 1
a642 1
	rc = VioSetFont(font,0);	/* Put it all back.. */
d661 1
a661 1
#  endif /* __EMX__ */
d663 1
a663 1
int Switch_Display_Charset (const int ord, const enum switch_display_charset_t really)
d671 2
a672 1
	    /* The first switch is not due to an interactive action */
d674 3
a676 1
		&& !(repeated++))))
d679 1
a679 1
    if (res < 0 || prev == res)		/* No change */
d690 1
a690 1
 *  This is the thing that actually gets called from display_page().
d692 2
a693 3
void UCChangeTerminalCodepage (
	int		newcs GCC_UNUSED,
	LYUCcharset *	p GCC_UNUSED)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d72 4
a75 4
PRIVATE int call_setfont ARGS3(
	CONST char *,	font,
	CONST char *,	fnsuffix,
	CONST char *,	umap)
d127 2
a128 2
PRIVATE void write_esc ARGS1(
	CONST char *,	p)
d138 2
a139 2
PRIVATE int nonempty_file ARGS1(
	CONST char *,	p)
d151 3
a153 3
PUBLIC void UCChangeTerminalCodepage ARGS2(
	int,		newcs,
	LYUCcharset *,	p)
d156 1
a156 1
    static CONST char * lastname = NULL;
d164 1
a164 1
    CONST char * name;
d445 3
a447 3
PUBLIC void UCChangeTerminalCodepage ARGS2(
	int,		newcs,
	LYUCcharset *,	p)
d464 1
a464 1
PUBLIC int Find_Best_Display_Charset ARGS1 (int, ord)
d466 1
a466 1
    CONST char *name = LYCharSet_UC[ord].MIMEname;
d531 1
a531 1
PRIVATE int _Switch_Display_Charset ARGS2 (int, ord, enum switch_display_charset_t, really)
d533 1
a533 1
    CONST char *name;
d662 1
a662 1
PUBLIC int Switch_Display_Charset ARGS2 (CONST int, ord, CONST enum switch_display_charset_t, really)
d688 3
a690 3
PUBLIC void UCChangeTerminalCodepage ARGS2(
	int,		newcs GCC_UNUSED,
	LYUCcharset *,	p GCC_UNUSED)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d4 1
a4 1
**  You have to change this code if it needs accomodation for your
d26 1
d30 19
d66 10
a75 4
PRIVATE void call_setfont ARGS3(
	char *, 	font,
	char *, 	fnsuffix,
	char *, 	umap)
d78 1
d85 1
a85 1
	return;
d107 2
a108 2
	CTRACE(tfp, "Executing setfont: '%s'\n", T_setfont_cmd);
	LYSystem(T_setfont_cmd);
d110 13
d124 1
d161 2
a162 2
    static char *old_font;
    static char *old_umap;
d171 1
d190 2
a191 1
		LYSystem(tmpbuf1);
d194 44
a237 2

	    remove(old_font);
a238 3
	    old_font = 0;

	    remove(old_umap);
a239 1
	    old_umap = 0;
a240 8
	return;
    } else if (lastcs < 0 && old_umap == 0 && old_font == 0) {
	old_umap = tempnam((char *)0, "umap");
	old_font = tempnam((char *)0, "font");
	HTSprintf0(&tmpbuf1, "%s -o %s -ou %s %s",
		SETFONT, old_font, old_umap, NOOUTPUT);
	LYSystem(tmpbuf1);
	FREE(tmpbuf1);
d252 1
d265 9
a273 6
    if (!strcmp(name, "iso-8859-10")) {
	call_setfont("iso10", SUFF1, "iso10.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strncmp(name, "iso-8859-1", 10)) {
d285 1
a285 1
	    call_setfont("lat1u", SUFF2, "lat1u.uni");
a292 6
#ifdef NOTDEFINED
	/*
	 *  "setfont lat2-16.psf -u lat2.uni"
	 */
	call_setfont("lat2", SUFF2, "lat2.uni");  */
#endif /* NOTDEFINED */
d296 1
a296 1
	call_setfont("iso02", SUFF1, "iso02.uni");
d300 8
d309 5
a313 2
	HTSprintf0(&tmpbuf1, "iso0%s", &name[9]);
	HTSprintf0(&tmpbuf2, "iso0%s%s", &name[9],".uni");
d317 2
a318 1
	call_setfont(tmpbuf1, SUFF1, tmpbuf2);
d327 1
a327 1
	call_setfont("koi8", SUFF3, NULL);
d329 1
a329 1
	HasUmap = Is_Unset;
d335 2
a336 2
	call_setfont("default", SUFF4, "cp437.uni");
	if (TransT == GN_Kuser || TransT == GN_Ucp437)
d346 21
a366 1
	call_setfont("cp850", SUFF3, "cp850.uni");
d378 8
d452 4
a455 4
    if (p->codepage) {
	res = VioSetCp(0, p->codepage, 0);
	CTRACE(tfp, "UCChangeTerminalCodepage: VioSetCp(%d) returned %d\n", p->codepage, res);
    }
d457 1
a457 1
    CTRACE(tfp, "UCChangeTerminalCodepage: Called, but not implemented!");
d462 222
d692 1
a692 1
    CTRACE(tfp, "UCChangeTerminalCodepage: Called, but not implemented!");
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 14
a15 14
 *  This file contains code for changing the Linux console mode.
 *  Currently some names for font files are hardwired in here.
 *  You have to change this code if it needs accommodation for your
 *  system (or get the required files...).
 *
 *  Depending on the Display Character Set switched to, and the previous
 *  one as far as it is known, system("setfont ...") and/or output of
 *  escape sequences to switch console mode are done.  Curses will be
 *  temporarily suspended while that happens.
 *
 *  NOTE that the setfont calls will also affect all other virtual consoles.
 *
 *  Any ideas how to do this for other systems?
 */
a25 1
#include <LYCharSets.h>
a28 21
#  ifdef CAN_SWITCH_DISPLAY_CHARSET
char *charset_switch_rules;
char *charsets_directory;
int auto_other_display_charset = -1;
int codepages[2];
int real_charsets[2] =
{-1, -1};			/* Non "auto-" charsets for the cps */
int switch_display_charsets;

#  endif

#  ifdef __EMX__
/* If we "just include" <os2.h>, BOOLEAN conflicts. */
#  define BOOLEAN OS2_BOOLEAN	/* This file doesn't use it, conflicts */
#  define INCL_VIO		/* I want some Vio functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
#  define INCL_DOSNLS		/* DosQueryCp. */
#  include <os2.h>		/* Misc stuff.. */
#  include <os2thunk.h>		/* 32 bit to 16 bit pointer conv */
#  endif

d46 4
a49 9
/*
 * call_setfont - execute "setfont" command via system()
 * returns:	 0  ok (as far as we know)
 *		-1  error (assume font and umap are not loaded)
 *		 1  error with umap (assume font loaded but umap empty)
 */
static int call_setfont(const char *font,
			const char *fnsuffix,
			const char *umap)
a51 1
    int rv;
d54 1
a54 1
	&& (umap && T_umap_fn && !strcmp(umap, T_umap_fn))) {
d56 1
a56 1
	 * No need to repeat.
d58 1
a58 1
	return 0;
d68 1
a68 1
    if (umap && *umap && font && *font) {
d70 1
a70 1
		   SETFONT, font, fnsuffix, umap, NOOUTPUT);
d73 1
a73 1
		   SETFONT, font, fnsuffix, NOOUTPUT);
d76 1
a76 1
		   SETFONT, umap, NOOUTPUT);
d80 2
a81 2
	CTRACE((tfp, "Executing setfont: '%s'\n", T_setfont_cmd));
	rv = LYSystem(T_setfont_cmd);
a82 13
	if (rv) {
	    CTRACE((tfp, "call_setfont: system returned %d (0x%x)!\n",
		    rv, rv));
	    if ((rv == 0x4200 || rv == 0x4100) && umap && *umap)
		/*
		 * It seems setfont returns 65 or 66 to the shell if
		 * the font was loaded ok but something was wrong with
		 * the umap file. - kw
		 */
		return 1;
	    else
		return -1;
	}
a83 1
    return 0;
d86 2
a87 1
static void write_esc(const char *p)
d97 2
a98 1
static int nonempty_file(const char *p)
d108 1
a108 1
 * This is the thing that actually gets called from display_page().
d110 3
a112 2
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
d115 1
a115 1
    static const char *lastname = NULL;
d120 2
a121 2
    static char *old_font = NULL;
    static char *old_umap = NULL;
d123 1
a123 1
    const char *name;
a129 1
    int status = 0;
d132 1
a132 1
     * Restore the original character set.
d143 1
a143 1
			       SETFONT, old_font, old_umap, NOOUTPUT);
d146 1
a146 1
			       SETFONT, old_font, NOOUTPUT);
d148 1
a148 2
		CTRACE((tfp, "Executing setfont to restore: '%s'\n", tmpbuf1));
		status = LYSystem(tmpbuf1);
d151 8
a158 14
	}
	if (newcs < 0 && p == 0) {
	    if (old_font) {
		LYRemoveTemp(old_font);
		FREE(old_font);
	    }
	    if (old_umap) {
		LYRemoveTemp(old_umap);
		FREE(old_umap);
	    }
	    if (status == 0) {
		FREE(T_font_fn);
		FREE(T_umap_fn);
	    }
d162 6
a167 33
	FILE *fp1;
	FILE *fp2 = NULL;
	if ((old_font = typecallocn(char, LY_MAXPATH)))
	      old_umap = typecallocn(char, LY_MAXPATH);

	if ((fp1 = LYOpenTemp(old_font, ".fnt", BIN_W)))
	    fp2 = LYOpenTemp(old_umap, ".uni", BIN_W);
	if (fp1 && fp2) {
	    size_t nlen;
	    char *rp;

	    HTSprintf0(&tmpbuf1, "%s -o %s -ou %s %s",
		       SETFONT, old_font, old_umap, NOOUTPUT);
	    CTRACE((tfp, "Executing setfont to save: '%s'\n", tmpbuf1));
	    LYSystem(tmpbuf1);
	    FREE(tmpbuf1);
	    LYCloseTempFP(fp1);
	    LYCloseTempFP(fp2);
	    if ((nlen = strlen(old_font)) + 1 < LY_MAXPATH &&
		(rp = typeRealloc(char, old_font, nlen + 1)))
		  old_font = rp;

	    if ((nlen = strlen(old_umap)) + 1 < LY_MAXPATH &&
		(rp = typeRealloc(char, old_umap, nlen + 1)))
		  old_umap = rp;
	} else {
	    if (fp1)
		LYRemoveTemp(old_font);
	    if (fp2)
		LYRemoveTemp(old_umap);
	    FREE(old_font);
	    FREE(old_umap);
	}
d173 1
a173 1
     * Font sizes are currently hardwired here.
a178 1
#define SUFF5 ".cp -16"
d181 1
a181 1
     * Use this for output of escape sequences.
d186 1
a186 1
	 * We won't do anything in an xterm.  Better that way...
d191 6
a196 9
    /* NOTE: `!!umap not in kbd!!' comments below means that the *.uni file
       is not found in kbd package.  Reference Debian Package: kbd-data,
       Version: 0.96a-14.  They should be located elsewhere or generated.
       Also some cpNNN fonts used below are not in the kbd-data.  - kw
     */

    if (!strncmp(name, "iso-8859-1", 10) &&
	(!name[10] || !isdigit(UCH(name[10])))
	) {
d199 1
a199 1
	     * cp850 already contains all latin1 characters.
d206 1
a206 1
	     * "setfont lat1u-16.psf -u lat1u.uni"
d208 1
a208 1
	    status = call_setfont("lat1u", SUFF2, "lat1u.uni");
d216 6
d223 1
a223 1
	 * "setfont iso02.f16 -u iso02.uni"
d225 1
a225 1
	status = call_setfont("iso02", SUFF1, "iso02.uni");
a228 8
    } else if (!strcmp(name, "iso-8859-15")) {
	/*
	 * "setfont lat0-16.psf"
	 */
	status = call_setfont("lat0", SUFF2, NULL);
	TransT = GN_Blat1;	/* bogus! */
	HasUmap = Dunno;	/* distributed lat0 files have bogus map data! */
	Utf = Is_Unset;
d230 2
a231 5
	if (strlen(name) <= 10 || !isdigit(UCH(name[10])))
	    HTSprintf0(&tmpbuf1, "iso0%s", &name[9]);
	else
	    HTSprintf0(&tmpbuf1, "iso%s", &name[9]);
	HTSprintf0(&tmpbuf2, "%s.uni", tmpbuf1);
d233 1
a233 1
	 * "setfont iso0N.f16 -u iso0N.uni"
d235 1
a235 2
	status = call_setfont(tmpbuf1, SUFF1, tmpbuf2);
	FREE(tmpbuf1);
d242 1
a242 1
	 * "setfont koi8-8x16"
d244 1
a244 1
	status = call_setfont("koi8", SUFF3, "koi8r.uni");	/* !!umap not in kbd!! */
d246 1
a246 1
	HasUmap = Is_Set;
d250 1
a250 1
	 * "setfont default8x16 -u cp437.uni"
d252 2
a253 2
	status = call_setfont("default", SUFF4, "cp437.uni");
	if (lastTransT == GN_Kuser || lastTransT == GN_Ucp437)
d261 1
a261 12
	 * "setfont cp850-8x16 -u cp850.uni"
	 */
	status = call_setfont("cp850", SUFF3, "cp850.uni");	/* !!umap not in kbd!! */
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp866") ||
	       !strcmp(name, "cp852") ||
	       !strcmp(name, "cp862")) {	/* MS-Kermit has these files */
	HTSprintf0(&tmpbuf2, "%s.uni", name);
	/*
	 * "setfont cpNNN.f16"
d263 1
a263 10
	status = call_setfont(name, SUFF1, tmpbuf2);	/* !!umap not in kbd!! */
	FREE(tmpbuf2);
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp737")) {
	/*
	 * "setfont cp737.cp"
	 */
	status = call_setfont("737", SUFF5, "cp737.uni");	/* !!umap not in kbd!! */
a274 8
    if (status == 1)
	HasUmap = Is_Unset;
    else if (status < 0) {
	if (HasUmap == Is_Set)
	    HasUmap = Dunno;
	name = "unknown-8bit";
    }

d278 1
a278 1
	     * Switch Linux console to lat1 table.
d284 3
a286 3
	    /*
	     * Switch Linux console to 437 table?
	     */
d289 3
a291 3
	    /*
	     * Switch Linux console to user table.
	     */
d308 1
a308 1
	     * Turn Linux console UTF8 mode ON.
d317 1
a317 1
	 * Turn Linux console UTF8 mode OFF.
d332 1
a332 1
 * This is the thing that actually gets called from display_page().
d334 3
a336 2
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
d341 4
a344 6
    if (newcs < 0)
	newcs = auto_display_charset;
    res = Switch_Display_Charset(newcs, SWITCH_DISPLAY_CHARSET_REALLY);
    CTRACE((tfp,
	    "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n",
	    newcs, res));
d346 1
a346 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
a350 225
#ifdef CAN_SWITCH_DISPLAY_CHARSET

int Find_Best_Display_Charset(int ord)
{
    const char *name = LYCharSet_UC[ord].MIMEname;
    char *s = charset_switch_rules, *r;
    char buf[160];
    static int lowercase;
    int n = strlen(name), source = 1;

    if (!s || !n)
	return ord;
    if (!lowercase++)
	LYLowerCase(charset_switch_rules);
    while (1) {
	while (*s && strchr(" \t,", *s))
	    s++;		/* Go to start of a name or ':' */
	if (!*s && source)
	    return ord;		/* OK to find nothing */
	if (!*s) {
	    sprintf(buf, "No destination for '%.80s' in CHARSET_SWITCH_RULES",
		    name);
	    HTInfoMsg(buf);
	    return ord;
	}
	if (*s == ':') {
	    /* Before the replacement name */
	    while (*s && strchr(" \t:", *s))
		s++;		/* Go to the replacement */
	    /* At start of the replacement name */
	    r = s;
	    while (*s && !strchr(" \t,:", *s))
		s++;		/* Skip the replacement */
	    if (source)
		continue;
	    break;
	}
	/* At start of the source name */
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {	/* Found! */
	    source = 0;
	    s += n;
	    continue;		/* Look for the replacement */
	}
	while (*s && !strchr(" \t,:", *s))
	    s++;		/* Skip the other source names */
    }
    /* Here r point to the replacement, s to the end of the replacement. */
    if (s >= r + sizeof(buf)) {
	HTInfoMsg(gettext("Charset name in CHARSET_SWITCH_RULES too long"));
	return ord;
    }
    strncpy(buf, r, s - r);
    buf[s - r] = '\0';
    n = UCGetLYhndl_byMIME(buf);
    if (n < 0) {
	sprintf(buf, "Unknown charset name '%.*s' in CHARSET_SWITCH_RULES",
		s - r, r);
	HTInfoMsg(buf);
	return ord;
    }
    return n;
}

#  ifdef __EMX__
/* Switch display for the best fit for LYCharSet_UC[ord].
   If really is MAYBE, the switch is tentative only, another switch may happen
   before the actual display.

   Returns the charset we switched to.  */
static int _Switch_Display_Charset(int ord, enum switch_display_charset_t really)
{
    const char *name;
    unsigned short cp;
    static int font_loaded_for = -1, old_h, old_w;
    int rc, ord1;
    UCHAR msgbuf[MAXPATHLEN + 80];

    CTRACE((tfp, "_Switch_Display_Charset(cp=%d, really=%d).\n", ord, really));
    /* Do not trust current_char_set unless REALLY, we fake it if MAYBE! */
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;
    if (ord == auto_other_display_charset
	|| ord == auto_display_charset || ord == font_loaded_for) {
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord;		/* Report success, to avoid flicker, switch later */
    } else			/* Currently supports only koi8-r to cp866 translation */
	ord = Find_Best_Display_Charset(ord);

    /* Ignore sizechange unless the font is loaded */
    if (ord != font_loaded_for && really == SWITCH_DISPLAY_CHARSET_RESIZE)
	return ord;

    if (ord == real_charsets[0] || ord == real_charsets[1]) {
	ord1 = (ord == real_charsets[1]
		? auto_other_display_charset : auto_display_charset);
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord;		/* Can switch later, report success to avoid flicker */
    } else
	ord1 = ord;
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;

    name = LYCharSet_UC[ord1].MIMEname;
    if (ord1 == auto_other_display_charset || ord1 == auto_display_charset) {
      retry:
	rc = VioSetCp(0, codepages[ord1 == auto_other_display_charset], 0);
	if (rc == 0)
	    goto report;
      err:
	sprintf(msgbuf, "Can't change to '%s': err=%#lx=%ld", name, rc, rc);
	HTInfoMsg(msgbuf);
	return -1;
    }

    /* Not a "prepared" codepage.  Need to load the user font. */
    if (charsets_directory) {
	TIB *tib;		/* Can't load font in a windowed-VIO */
	PIB *pib;
	VIOFONTINFO f[2];
	VIOFONTINFO *font;
	UCHAR b[1 << 17];
	UCHAR *buf = b;
	UCHAR fnamebuf[MAXPATHLEN];
	FILE *file;
	APIRET rc;
	long i, j;

	/* 0 means a FS protected-mode session */
	if (font_loaded_for == -1	/* Did not try it yet */
	    && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0)) {
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	/* Should not cross 64K boundaries: */
	font = f;
	if (((((ULONG) (char *) f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
	    font++;
	if (((ULONG) buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG) buf) & 0xFFFF);
	font->cb = sizeof(*font);	/* How large is this structure */
	font->type = 0;		/* Not the BIOS, the loaded font. */
	font->cbData = 65535;	/* How large is my buffer? */
	font->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */

	rc = VioGetFont(font, 0);	/* Retrieve data for current font */
	if (rc) {
	    sprintf(msgbuf, "Can't fetch current font info: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	if (ord1 == font_loaded_for
	    && old_h == font->cyCell && old_w == font->cxCell) {
	    /* The same as the previous font */
	    if ((rc = VioSetCp(0, -1, 0)))	/* -1: User font */
		goto err;
	    goto report;
	}
	sprintf(fnamebuf, "%s/%dx%d/%s.fnt",
		charsets_directory, font->cyCell, font->cxCell, name);
	file = fopen(fnamebuf, BIN_R);
	if (!file) {
	    sprintf(msgbuf, "Can't open font file '%s'", fnamebuf);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	i = ftell(file);
	fseek(file, 0, SEEK_END);
	if (ftell(file) - i != font->cbData) {
	    fclose(file);
	    sprintf(msgbuf, "Mismatch of size of font file '%s'", fnamebuf);
	    HTAlert(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	fseek(file, i, SEEK_SET);
	fread(buf, 1, font->cbData, file);
	fclose(file);
	rc = VioSetFont(font, 0);	/* Put it all back.. */
	if (rc) {
	    sprintf(msgbuf, "Can't set font: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    font_loaded_for = -1;
	    goto retry;
	}
	font_loaded_for = ord1;
	old_h = font->cyCell;
	old_w = font->cxCell;
    } else {
	ord = ord1 = auto_display_charset;
	goto retry;
    }
  report:
    CTRACE((tfp, "Display font set to '%s'.\n", name));
    return ord;
}
#  endif			/* __EMX__ */

int Switch_Display_Charset(const int ord, const enum switch_display_charset_t really)
{
    int prev = current_char_set;
    int res;
    static int repeated;

    if (!switch_display_charsets
	&& (really == SWITCH_DISPLAY_CHARSET_MAYBE
#ifdef SWITCH_DISPLAY_CHARSET_NOT_NEEDED_ANY_MORE
    /* The first switch is not due to an interactive action */
	    || (really == SWITCH_DISPLAY_CHARSET_REALLY
		&& !(repeated++))
#endif
	))
	return 0;
    res = _Switch_Display_Charset(ord, really);
    if (res < 0 || prev == res)	/* No change */
	return 0;
    /* Register the change */
    current_char_set = res;
    HTMLUseCharacterSet(current_char_set);
    return 1;
}
#endif /* CAN_SWITCH_DISPLAY_CHARSET */

d353 1
a353 1
 * This is the thing that actually gets called from display_page().
d355 3
a357 2
void UCChangeTerminalCodepage(int newcs GCC_UNUSED,
			      LYUCcharset *p GCC_UNUSED)
d359 1
a359 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d4 1
a4 1
**  You have to change this code if it needs accommodation for your
a25 1
#include <LYCharSets.h>
a28 19
#  ifdef CAN_SWITCH_DISPLAY_CHARSET
char *charset_switch_rules;
char *charsets_directory;
int auto_other_display_charset = -1;
int codepages[2];
int real_charsets[2] = {-1, -1};	/* Non "auto-" charsets for the cps */
int switch_display_charsets;
#  endif

#  ifdef __EMX__
/* If we "just include" <os2.h>, BOOLEAN conflicts. */
#  define BOOLEAN OS2_BOOLEAN		/* This file doesn't use it, conflicts */
#  define INCL_VIO			/* I want some Vio functions.. */
#  define INCL_DOSPROCESS			/* TIB PIB. */
#  define INCL_DOSNLS			/* DosQueryCp. */
#  include <os2.h>			/* Misc stuff.. */
#  include <os2thunk.h>			/* 32 bit to 16 bit pointer conv */
#  endif

d46 4
a49 10
/*
 *  call_setfont - execute "setfont" command via system()
 *  returns:	0  ok (as far as we know)
 *	       -1  error (assume font and umap are not loaded)
 *		1  error with umap (assume font loaded but umap empty)
 */
PRIVATE int call_setfont ARGS3(
	CONST char *,	font,
	CONST char *,	fnsuffix,
	CONST char *,	umap)
a51 1
    int rv;
d58 1
a58 1
	return 0;
d80 2
a81 2
	CTRACE((tfp, "Executing setfont: '%s'\n", T_setfont_cmd));
	rv = LYSystem(T_setfont_cmd);
a82 13
	if (rv) {
	    CTRACE((tfp, "call_setfont: system returned %d (0x%x)!\n",
		   rv, rv));
	    if ((rv == 0x4200 || rv == 0x4100) && umap && *umap)
		/*
		 * It seems setfont returns 65 or 66 to the shell if
		 * the font was loaded ok but something was wrong with
		 * the umap file. - kw
		 */
		return 1;
	    else
		return -1;
	}
a83 1
    return 0;
d120 2
a121 2
    static char *old_font = NULL;
    static char *old_umap = NULL;
a129 1
    int status = 0;
d148 1
a148 2
		CTRACE((tfp, "Executing setfont to restore: '%s'\n", tmpbuf1));
		status = LYSystem(tmpbuf1);
d151 8
a158 14
	}
	if (newcs < 0 && p == 0) {
	    if (old_font) {
		LYRemoveTemp(old_font);
		FREE(old_font);
	    }
	    if (old_umap) {
		LYRemoveTemp(old_umap);
		FREE(old_umap);
	    }
	    if (status == 0) {
		FREE(T_font_fn);
		FREE(T_umap_fn);
	    }
d162 6
a167 30
	FILE * fp1;
	FILE * fp2 = NULL;
	if ((old_font = typecallocn(char, LY_MAXPATH)))
	    old_umap = typecallocn(char, LY_MAXPATH);
	if ((fp1 = LYOpenTemp(old_font, ".fnt", BIN_W)))
	    fp2 = LYOpenTemp(old_umap, ".uni", BIN_W);
	if (fp1 && fp2) {
	    size_t nlen;
	    char *rp;
	    HTSprintf0(&tmpbuf1, "%s -o %s -ou %s %s",
		       SETFONT, old_font, old_umap, NOOUTPUT);
	    CTRACE((tfp, "Executing setfont to save: '%s'\n", tmpbuf1));
	    LYSystem(tmpbuf1);
	    FREE(tmpbuf1);
	    LYCloseTempFP(fp1);
	    LYCloseTempFP(fp2);
	    if ((nlen = strlen(old_font)) + 1 < LY_MAXPATH &&
		 (rp = realloc(old_font, nlen + 1)))
		old_font = rp;
	    if ((nlen = strlen(old_umap)) + 1 < LY_MAXPATH &&
		 (rp = realloc(old_umap, nlen + 1)))
		old_umap = rp;
	} else {
	    if (fp1)
		LYRemoveTemp(old_font);
	    if (fp2)
		LYRemoveTemp(old_umap);
	    FREE(old_font);
	    FREE(old_umap);
	}
a178 1
#define SUFF5 ".cp -16"
d191 6
a196 9
    /* NOTE: `!!umap not in kbd!!' comments below means that the *.uni file
       is not found in kbd package.  Reference Debian Package: kbd-data,
       Version: 0.96a-14.  They should be located elsewhere or generated.
       Also some cpNNN fonts used below are not in the kbd-data.  - kw
       */

    if (!strncmp(name, "iso-8859-1", 10) &&
	       (!name[10] || !isdigit(UCH(name[10])))
	) {
d208 1
a208 1
	    status = call_setfont("lat1u", SUFF2, "lat1u.uni");
d216 6
d225 1
a225 1
	status = call_setfont("iso02", SUFF1, "iso02.uni");
a228 8
    } else if (!strcmp(name, "iso-8859-15")) {
	/*
	 *  "setfont lat0-16.psf"
	 */
	status = call_setfont("lat0", SUFF2, NULL);
	TransT = GN_Blat1;	/* bogus! */
	HasUmap = Dunno; /* distributed lat0 files have bogus map data! */
	Utf = Is_Unset;
d230 2
a231 5
	if (strlen(name) <= 10 || !isdigit(UCH(name[10])))
	    HTSprintf0(&tmpbuf1, "iso0%s", &name[9]);
	else
	    HTSprintf0(&tmpbuf1, "iso%s", &name[9]);
	HTSprintf0(&tmpbuf2, "%s.uni", tmpbuf1);
d235 1
a235 2
	status = call_setfont(tmpbuf1, SUFF1, tmpbuf2);
	FREE(tmpbuf1);
d244 1
a244 1
	status = call_setfont("koi8", SUFF3, "koi8r.uni"); /* !!umap not in kbd!! */
d246 1
a246 1
	HasUmap = Is_Set;
d252 2
a253 2
	status = call_setfont("default", SUFF4, "cp437.uni");
	if (lastTransT == GN_Kuser || lastTransT == GN_Ucp437)
d263 1
a263 21
	status = call_setfont("cp850", SUFF3, "cp850.uni"); /* !!umap not in kbd!! */
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp866") ||
	       !strcmp(name, "cp852") ||
	       !strcmp(name, "cp862")) { /* MS-Kermit has these files */
	HTSprintf0(&tmpbuf2, "%s.uni", name);
	/*
	 *  "setfont cpNNN.f16"
	 */
	status = call_setfont(name, SUFF1, tmpbuf2); /* !!umap not in kbd!! */
	FREE(tmpbuf2);
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp737")) {
	/*
	 *  "setfont cp737.cp"
	 */
	status = call_setfont("737", SUFF5, "cp737.uni"); /* !!umap not in kbd!! */
a274 8
    if (status == 1)
	HasUmap = Is_Unset;
    else if (status < 0) {
	if (HasUmap == Is_Set)
	    HasUmap = Dunno;
	name = "unknown-8bit";
    }

d341 4
a344 4
    if (newcs < 0)
	newcs = auto_display_charset;
    res = Switch_Display_Charset(newcs, SWITCH_DISPLAY_CHARSET_REALLY);
    CTRACE((tfp, "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n", newcs, res));
d346 1
a346 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
a350 222
#ifdef CAN_SWITCH_DISPLAY_CHARSET

PUBLIC int Find_Best_Display_Charset ARGS1 (int, ord)
{
    CONST char *name = LYCharSet_UC[ord].MIMEname;
    char *s = charset_switch_rules, *r;
    char buf[160];
    static int lowercase;
    int n = strlen(name), source = 1;

    if (!s || !n)
	return ord;
    if (!lowercase++)
	LYLowerCase(charset_switch_rules);
    while (1) {
	while (*s && strchr(" \t,", *s))
	    s++;			/* Go to start of a name or ':' */
	if (!*s && source)
	    return ord;			/* OK to find nothing */
	if (!*s) {
	    sprintf(buf, "No destination for '%.80s' in CHARSET_SWITCH_RULES",
		    name);
	    HTInfoMsg(buf);
	    return ord;
	}
	if (*s == ':') {
	    /* Before the replacement name */
	    while (*s && strchr(" \t:", *s))
		s++;			/* Go to the replacement */
	    /* At start of the replacement name */
	    r = s;
	    while (*s && !strchr(" \t,:", *s))
		s++;			/* Skip the replacement */
	    if (source)
		continue;
	    break;
	}
	/* At start of the source name */
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {/* Found! */
	    source = 0;
	    s += n;
	    continue;			/* Look for the replacement */
	}
	while (*s && !strchr(" \t,:", *s))
	    s++;			/* Skip the other source names */
    }
    /* Here r point to the replacement, s to the end of the replacement. */
    if (s >= r + sizeof(buf)) {
	HTInfoMsg(gettext("Charset name in CHARSET_SWITCH_RULES too long"));
	return ord;
    }
    strncpy(buf, r, s-r);
    buf[s-r] = '\0';
    n = UCGetLYhndl_byMIME(buf);
    if (n < 0) {
	sprintf(buf, "Unknown charset name '%.*s' in CHARSET_SWITCH_RULES",
		s-r, r);
	HTInfoMsg(buf);
	return ord;
    }
    return n;
}

#  ifdef __EMX__
/* Switch display for the best fit for LYCharSet_UC[ord].
   If really is MAYBE, the switch is tentative only, another switch may happen
   before the actual display.

   Returns the charset we switched to.  */
PRIVATE int _Switch_Display_Charset ARGS2 (int, ord, enum switch_display_charset_t, really)
{
    CONST char *name;
    unsigned short cp;
    static int font_loaded_for = -1, old_h, old_w;
    int rc, ord1;
    UCHAR msgbuf[MAXPATHLEN + 80];

    CTRACE((tfp, "_Switch_Display_Charset(cp=%d, really=%d).\n", ord, really));
    /* Do not trust current_char_set unless REALLY, we fake it if MAYBE! */
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;
    if (ord == auto_other_display_charset
	|| ord == auto_display_charset || ord == font_loaded_for) {
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord; /* Report success, to avoid flicker, switch later */
    } else	/* Currently supports only koi8-r to cp866 translation */
	ord = Find_Best_Display_Charset(ord);

    /* Ignore sizechange unless the font is loaded */
    if (ord != font_loaded_for && really == SWITCH_DISPLAY_CHARSET_RESIZE)
	return ord;

    if (ord == real_charsets[0] || ord == real_charsets[1]) {
	ord1 = (ord == real_charsets[1]
	       ? auto_other_display_charset : auto_display_charset);
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord; /* Can switch later, report success to avoid flicker */
    } else
	ord1 = ord;
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;

    name = LYCharSet_UC[ord1].MIMEname;
    if (ord1 == auto_other_display_charset || ord1 == auto_display_charset) {
      retry:
	rc = VioSetCp(0,codepages[ord1 == auto_other_display_charset],0);
	if (rc == 0)
	    goto report;
      err:
	sprintf(msgbuf, "Can't change to '%s': err=%#lx=%ld", name, rc, rc);
	HTInfoMsg(msgbuf);
	return -1;
    }

    /* Not a "prepared" codepage.  Need to load the user font. */
    if (charsets_directory) {
	TIB *tib;			/* Can't load font in a windowed-VIO */
	PIB *pib;
	VIOFONTINFO f[2];
	VIOFONTINFO *font;
	UCHAR b[1<<17];
	UCHAR *buf = b;
	UCHAR fnamebuf[MAXPATHLEN];
	FILE  *file;
	APIRET rc;
	long i, j;

	/* 0 means a FS protected-mode session */
	if ( font_loaded_for == -1		/* Did not try it yet */
	     && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0) ) {
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	/* Should not cross 64K boundaries: */
	font = f;
	if (((((ULONG)(char*)f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
	    font++;
	if (((ULONG)buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
	font->cb = sizeof(*font);	/* How large is this structure */
	font->type=0;			/* Not the BIOS, the loaded font. */
	font->cbData = 65535;		/* How large is my buffer? */
	font->pbData = _emx_32to16(buf); /* Wants an 16:16 pointer */

	rc = VioGetFont(font,0);	/* Retrieve data for current font */
	if (rc) {
	    sprintf(msgbuf, "Can't fetch current font info: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	if ( ord1 == font_loaded_for
	     && old_h == font->cyCell && old_w == font->cxCell ) {
	    /* The same as the previous font */
	    if ((rc = VioSetCp(0, -1, 0)))	/* -1: User font */
		goto err;
	    goto report;
	}
	sprintf(fnamebuf, "%s/%dx%d/%s.fnt",
		charsets_directory, font->cyCell, font->cxCell, name);
	file = fopen(fnamebuf, BIN_R);
	if (!file) {
	    sprintf(msgbuf, "Can't open font file '%s'", fnamebuf);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	i = ftell(file);
	fseek(file, 0, SEEK_END);
	if (ftell(file) - i != font->cbData) {
	    fclose(file);
	    sprintf(msgbuf, "Mismatch of size of font file '%s'", fnamebuf);
	    HTAlert(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	fseek(file, i, SEEK_SET);
	fread(buf, 1, font->cbData,file);
	fclose(file);
	rc = VioSetFont(font,0);	/* Put it all back.. */
	if (rc) {
	    sprintf(msgbuf, "Can't set font: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    font_loaded_for = -1;
	    goto retry;
	}
	font_loaded_for = ord1;
	old_h = font->cyCell;
	old_w = font->cxCell;
    } else {
	ord = ord1 = auto_display_charset;
	goto retry;
    }
  report:
    CTRACE((tfp, "Display font set to '%s'.\n", name));
    return ord;
}
#  endif /* __EMX__ */

PUBLIC int Switch_Display_Charset ARGS2 (CONST int, ord, CONST enum switch_display_charset_t, really)
{
    int prev = current_char_set;
    int res;
    static int repeated;

    if (!switch_display_charsets
	&& (really == SWITCH_DISPLAY_CHARSET_MAYBE
	    /* The first switch is not due to an interactive action */
	    || (really == SWITCH_DISPLAY_CHARSET_REALLY
		&& !(repeated++))))
	return 0;
    res = _Switch_Display_Charset(ord, really);
    if (res < 0 || prev == res)		/* No change */
	return 0;
    /* Register the change */
    current_char_set = res;
    HTMLUseCharacterSet(current_char_set);
    return 1;
}
#endif /* CAN_SWITCH_DISPLAY_CHARSET */

d359 1
a359 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d72 4
a75 4
static int call_setfont (
	const char *	font,
	const char *	fnsuffix,
	const char *	umap)
d127 2
a128 2
static void write_esc (
	const char *	p)
d138 2
a139 2
static int nonempty_file (
	const char *	p)
d151 3
a153 3
void UCChangeTerminalCodepage (
	int		newcs,
	LYUCcharset *	p)
d156 1
a156 1
    static const char * lastname = NULL;
d164 1
a164 1
    const char * name;
d445 3
a447 3
void UCChangeTerminalCodepage (
	int		newcs,
	LYUCcharset *	p)
d464 1
a464 1
int Find_Best_Display_Charset (int ord)
d466 1
a466 1
    const char *name = LYCharSet_UC[ord].MIMEname;
d531 1
a531 1
static int _Switch_Display_Charset (int ord, enum switch_display_charset_t really)
d533 1
a533 1
    const char *name;
d662 1
a662 1
int Switch_Display_Charset (const int ord, const enum switch_display_charset_t really)
d688 3
a690 3
void UCChangeTerminalCodepage (
	int		newcs GCC_UNUSED,
	LYUCcharset *	p GCC_UNUSED)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 14
a15 14
 *  This file contains code for changing the Linux console mode.
 *  Currently some names for font files are hardwired in here.
 *  You have to change this code if it needs accommodation for your
 *  system (or get the required files...).
 *
 *  Depending on the Display Character Set switched to, and the previous
 *  one as far as it is known, system("setfont ...") and/or output of
 *  escape sequences to switch console mode are done.  Curses will be
 *  temporarily suspended while that happens.
 *
 *  NOTE that the setfont calls will also affect all other virtual consoles.
 *
 *  Any ideas how to do this for other systems?
 */
d35 1
a35 2
int real_charsets[2] =
{-1, -1};			/* Non "auto-" charsets for the cps */
a36 1

d41 6
a46 6
#  define BOOLEAN OS2_BOOLEAN	/* This file doesn't use it, conflicts */
#  define INCL_VIO		/* I want some Vio functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
#  define INCL_DOSNLS		/* DosQueryCp. */
#  include <os2.h>		/* Misc stuff.. */
#  include <os2thunk.h>		/* 32 bit to 16 bit pointer conv */
d67 4
a70 4
 * call_setfont - execute "setfont" command via system()
 * returns:	 0  ok (as far as we know)
 *		-1  error (assume font and umap are not loaded)
 *		 1  error with umap (assume font loaded but umap empty)
d72 4
a75 3
static int call_setfont(const char *font,
			const char *fnsuffix,
			const char *umap)
d81 1
a81 1
	&& (umap && T_umap_fn && !strcmp(umap, T_umap_fn))) {
d83 1
a83 1
	 * No need to repeat.
d95 1
a95 1
    if (umap && *umap && font && *font) {
d97 1
a97 1
		   SETFONT, font, fnsuffix, umap, NOOUTPUT);
d100 1
a100 1
		   SETFONT, font, fnsuffix, NOOUTPUT);
d103 1
a103 1
		   SETFONT, umap, NOOUTPUT);
d112 1
a112 1
		    rv, rv));
d127 2
a128 1
static void write_esc(const char *p)
d138 2
a139 1
static int nonempty_file(const char *p)
d149 1
a149 1
 * This is the thing that actually gets called from display_page().
d151 3
a153 2
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
d156 1
a156 1
    static const char *lastname = NULL;
d164 1
a164 1
    const char *name;
d174 1
a174 1
     * Restore the original character set.
d185 1
a185 1
			       SETFONT, old_font, old_umap, NOOUTPUT);
d188 1
a188 1
			       SETFONT, old_font, NOOUTPUT);
d211 2
a212 2
	FILE *fp1;
	FILE *fp2 = NULL;
d214 1
a214 2
	      old_umap = typecallocn(char, LY_MAXPATH);

a219 1

d228 1
a228 1
		(rp = realloc(old_font, nlen + 1)))
d231 1
a231 1
		(rp = realloc(old_umap, nlen + 1)))
d246 1
a246 1
     * Font sizes are currently hardwired here.
d255 1
a255 1
     * Use this for output of escape sequences.
d260 1
a260 1
	 * We won't do anything in an xterm.  Better that way...
d269 1
a269 1
     */
d272 1
a272 1
	(!name[10] || !isdigit(UCH(name[10])))
d276 1
a276 1
	     * cp850 already contains all latin1 characters.
d283 1
a283 1
	     * "setfont lat1u-16.psf -u lat1u.uni"
d294 1
a294 1
	 * "setfont iso02.f16 -u iso02.uni"
d302 1
a302 1
	 * "setfont lat0-16.psf"
d306 1
a306 1
	HasUmap = Dunno;	/* distributed lat0 files have bogus map data! */
d315 1
a315 1
	 * "setfont iso0N.f16 -u iso0N.uni"
d325 1
a325 1
	 * "setfont koi8-8x16"
d327 1
a327 1
	status = call_setfont("koi8", SUFF3, "koi8r.uni");	/* !!umap not in kbd!! */
d333 1
a333 1
	 * "setfont default8x16 -u cp437.uni"
d344 1
a344 1
	 * "setfont cp850-8x16 -u cp850.uni"
d346 1
a346 1
	status = call_setfont("cp850", SUFF3, "cp850.uni");	/* !!umap not in kbd!! */
d352 1
a352 1
	       !strcmp(name, "cp862")) {	/* MS-Kermit has these files */
d355 1
a355 1
	 * "setfont cpNNN.f16"
d357 1
a357 1
	status = call_setfont(name, SUFF1, tmpbuf2);	/* !!umap not in kbd!! */
d364 1
a364 1
	 * "setfont cp737.cp"
d366 1
a366 1
	status = call_setfont("737", SUFF5, "cp737.uni");	/* !!umap not in kbd!! */
d389 1
a389 1
	     * Switch Linux console to lat1 table.
d395 3
a397 3
	    /*
	     * Switch Linux console to 437 table?
	     */
d400 3
a402 3
	    /*
	     * Switch Linux console to user table.
	     */
d419 1
a419 1
	     * Turn Linux console UTF8 mode ON.
d428 1
a428 1
	 * Turn Linux console UTF8 mode OFF.
d443 1
a443 1
 * This is the thing that actually gets called from display_page().
d445 3
a447 2
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
d455 1
a455 3
    CTRACE((tfp,
	    "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n",
	    newcs, res));
d464 1
a464 1
int Find_Best_Display_Charset(int ord)
d478 1
a478 1
	    s++;		/* Go to start of a name or ':' */
d480 1
a480 1
	    return ord;		/* OK to find nothing */
d490 1
a490 1
		s++;		/* Go to the replacement */
d494 1
a494 1
		s++;		/* Skip the replacement */
d500 1
a500 1
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {	/* Found! */
d503 1
a503 1
	    continue;		/* Look for the replacement */
d506 1
a506 1
	    s++;		/* Skip the other source names */
d513 2
a514 2
    strncpy(buf, r, s - r);
    buf[s - r] = '\0';
d518 1
a518 1
		s - r, r);
d531 1
a531 1
static int _Switch_Display_Charset(int ord, enum switch_display_charset_t really)
d546 2
a547 2
	    return ord;		/* Report success, to avoid flicker, switch later */
    } else			/* Currently supports only koi8-r to cp866 translation */
d556 1
a556 1
		? auto_other_display_charset : auto_display_charset);
d558 1
a558 1
	    return ord;		/* Can switch later, report success to avoid flicker */
d567 1
a567 1
	rc = VioSetCp(0, codepages[ord1 == auto_other_display_charset], 0);
d578 1
a578 1
	TIB *tib;		/* Can't load font in a windowed-VIO */
d582 1
a582 1
	UCHAR b[1 << 17];
d585 1
a585 1
	FILE *file;
d590 2
a591 2
	if (font_loaded_for == -1	/* Did not try it yet */
	    && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0)) {
d597 1
a597 1
	if (((((ULONG) (char *) f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
d599 2
a600 2
	if (((ULONG) buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG) buf) & 0xFFFF);
d602 3
a604 3
	font->type = 0;		/* Not the BIOS, the loaded font. */
	font->cbData = 65535;	/* How large is my buffer? */
	font->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */
d606 1
a606 1
	rc = VioGetFont(font, 0);	/* Retrieve data for current font */
d613 2
a614 2
	if (ord1 == font_loaded_for
	    && old_h == font->cyCell && old_w == font->cxCell) {
d639 1
a639 1
	fread(buf, 1, font->cbData, file);
d641 1
a641 1
	rc = VioSetFont(font, 0);	/* Put it all back.. */
d660 1
a660 1
#  endif			/* __EMX__ */
d662 1
a662 1
int Switch_Display_Charset(const int ord, const enum switch_display_charset_t really)
d670 1
a670 2
#ifdef SWITCH_DISPLAY_CHARSET_NOT_NEEDED_ANY_MORE
    /* The first switch is not due to an interactive action */
d672 1
a672 3
		&& !(repeated++))
#endif
	))
d675 1
a675 1
    if (res < 0 || prev == res)	/* No change */
d686 1
a686 1
 * This is the thing that actually gets called from display_page().
d688 3
a690 2
void UCChangeTerminalCodepage(int newcs GCC_UNUSED,
			      LYUCcharset *p GCC_UNUSED)
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d4 1
a4 1
**  You have to change this code if it needs accommodation for your
a25 1
#include <LYCharSets.h>
a28 19
#  ifdef CAN_SWITCH_DISPLAY_CHARSET
char *charset_switch_rules;
char *charsets_directory;
int auto_other_display_charset = -1;
int codepages[2];
int real_charsets[2] = {-1, -1};	/* Non "auto-" charsets for the cps */
int switch_display_charsets;
#  endif

#  ifdef __EMX__
/* If we "just include" <os2.h>, BOOLEAN conflicts. */
#  define BOOLEAN OS2_BOOLEAN		/* This file doesn't use it, conflicts */
#  define INCL_VIO			/* I want some Vio functions.. */
#  define INCL_DOSPROCESS			/* TIB PIB. */
#  define INCL_DOSNLS			/* DosQueryCp. */
#  include <os2.h>			/* Misc stuff.. */
#  include <os2thunk.h>			/* 32 bit to 16 bit pointer conv */
#  endif

d46 4
a49 10
/*
 *  call_setfont - execute "setfont" command via system()
 *  returns:	0  ok (as far as we know)
 *	       -1  error (assume font and umap are not loaded)
 *		1  error with umap (assume font loaded but umap empty)
 */
PRIVATE int call_setfont ARGS3(
	CONST char *,	font,
	CONST char *,	fnsuffix,
	CONST char *,	umap)
a51 1
    int rv;
d58 1
a58 1
	return 0;
d80 2
a81 2
	CTRACE((tfp, "Executing setfont: '%s'\n", T_setfont_cmd));
	rv = LYSystem(T_setfont_cmd);
a82 13
	if (rv) {
	    CTRACE((tfp, "call_setfont: system returned %d (0x%x)!\n",
		   rv, rv));
	    if ((rv == 0x4200 || rv == 0x4100) && umap && *umap)
		/*
		 * It seems setfont returns 65 or 66 to the shell if
		 * the font was loaded ok but something was wrong with
		 * the umap file. - kw
		 */
		return 1;
	    else
		return -1;
	}
a83 1
    return 0;
d120 2
a121 2
    static char *old_font = NULL;
    static char *old_umap = NULL;
a129 1
    int status = 0;
d148 1
a148 2
		CTRACE((tfp, "Executing setfont to restore: '%s'\n", tmpbuf1));
		status = LYSystem(tmpbuf1);
d151 8
a158 14
	}
	if (newcs < 0 && p == 0) {
	    if (old_font) {
		LYRemoveTemp(old_font);
		FREE(old_font);
	    }
	    if (old_umap) {
		LYRemoveTemp(old_umap);
		FREE(old_umap);
	    }
	    if (status == 0) {
		FREE(T_font_fn);
		FREE(T_umap_fn);
	    }
d162 6
a167 30
	FILE * fp1;
	FILE * fp2 = NULL;
	if ((old_font = typecallocn(char, LY_MAXPATH)))
	    old_umap = typecallocn(char, LY_MAXPATH);
	if ((fp1 = LYOpenTemp(old_font, ".fnt", BIN_W)))
	    fp2 = LYOpenTemp(old_umap, ".uni", BIN_W);
	if (fp1 && fp2) {
	    size_t nlen;
	    char *rp;
	    HTSprintf0(&tmpbuf1, "%s -o %s -ou %s %s",
		       SETFONT, old_font, old_umap, NOOUTPUT);
	    CTRACE((tfp, "Executing setfont to save: '%s'\n", tmpbuf1));
	    LYSystem(tmpbuf1);
	    FREE(tmpbuf1);
	    LYCloseTempFP(fp1);
	    LYCloseTempFP(fp2);
	    if ((nlen = strlen(old_font)) + 1 < LY_MAXPATH &&
		 (rp = realloc(old_font, nlen + 1)))
		old_font = rp;
	    if ((nlen = strlen(old_umap)) + 1 < LY_MAXPATH &&
		 (rp = realloc(old_umap, nlen + 1)))
		old_umap = rp;
	} else {
	    if (fp1)
		LYRemoveTemp(old_font);
	    if (fp2)
		LYRemoveTemp(old_umap);
	    FREE(old_font);
	    FREE(old_umap);
	}
a178 1
#define SUFF5 ".cp -16"
d191 6
a196 9
    /* NOTE: `!!umap not in kbd!!' comments below means that the *.uni file
       is not found in kbd package.  Reference Debian Package: kbd-data,
       Version: 0.96a-14.  They should be located elsewhere or generated.
       Also some cpNNN fonts used below are not in the kbd-data.  - kw
       */

    if (!strncmp(name, "iso-8859-1", 10) &&
	       (!name[10] || !isdigit(UCH(name[10])))
	) {
d208 1
a208 1
	    status = call_setfont("lat1u", SUFF2, "lat1u.uni");
d216 6
d225 1
a225 1
	status = call_setfont("iso02", SUFF1, "iso02.uni");
a228 8
    } else if (!strcmp(name, "iso-8859-15")) {
	/*
	 *  "setfont lat0-16.psf"
	 */
	status = call_setfont("lat0", SUFF2, NULL);
	TransT = GN_Blat1;	/* bogus! */
	HasUmap = Dunno; /* distributed lat0 files have bogus map data! */
	Utf = Is_Unset;
d230 2
a231 5
	if (strlen(name) <= 10 || !isdigit(UCH(name[10])))
	    HTSprintf0(&tmpbuf1, "iso0%s", &name[9]);
	else
	    HTSprintf0(&tmpbuf1, "iso%s", &name[9]);
	HTSprintf0(&tmpbuf2, "%s.uni", tmpbuf1);
d235 1
a235 2
	status = call_setfont(tmpbuf1, SUFF1, tmpbuf2);
	FREE(tmpbuf1);
d244 1
a244 1
	status = call_setfont("koi8", SUFF3, "koi8r.uni"); /* !!umap not in kbd!! */
d246 1
a246 1
	HasUmap = Is_Set;
d252 2
a253 2
	status = call_setfont("default", SUFF4, "cp437.uni");
	if (lastTransT == GN_Kuser || lastTransT == GN_Ucp437)
d263 1
a263 21
	status = call_setfont("cp850", SUFF3, "cp850.uni"); /* !!umap not in kbd!! */
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp866") ||
	       !strcmp(name, "cp852") ||
	       !strcmp(name, "cp862")) { /* MS-Kermit has these files */
	HTSprintf0(&tmpbuf2, "%s.uni", name);
	/*
	 *  "setfont cpNNN.f16"
	 */
	status = call_setfont(name, SUFF1, tmpbuf2); /* !!umap not in kbd!! */
	FREE(tmpbuf2);
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp737")) {
	/*
	 *  "setfont cp737.cp"
	 */
	status = call_setfont("737", SUFF5, "cp737.uni"); /* !!umap not in kbd!! */
a274 8
    if (status == 1)
	HasUmap = Is_Unset;
    else if (status < 0) {
	if (HasUmap == Is_Set)
	    HasUmap = Dunno;
	name = "unknown-8bit";
    }

d341 4
a344 4
    if (newcs < 0)
	newcs = auto_display_charset;
    res = Switch_Display_Charset(newcs, SWITCH_DISPLAY_CHARSET_REALLY);
    CTRACE((tfp, "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n", newcs, res));
d346 1
a346 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
a350 222
#ifdef CAN_SWITCH_DISPLAY_CHARSET

PUBLIC int Find_Best_Display_Charset ARGS1 (int, ord)
{
    CONST char *name = LYCharSet_UC[ord].MIMEname;
    char *s = charset_switch_rules, *r;
    char buf[160];
    static int lowercase;
    int n = strlen(name), source = 1;

    if (!s || !n)
	return ord;
    if (!lowercase++)
	LYLowerCase(charset_switch_rules);
    while (1) {
	while (*s && strchr(" \t,", *s))
	    s++;			/* Go to start of a name or ':' */
	if (!*s && source)
	    return ord;			/* OK to find nothing */
	if (!*s) {
	    sprintf(buf, "No destination for '%.80s' in CHARSET_SWITCH_RULES",
		    name);
	    HTInfoMsg(buf);
	    return ord;
	}
	if (*s == ':') {
	    /* Before the replacement name */
	    while (*s && strchr(" \t:", *s))
		s++;			/* Go to the replacement */
	    /* At start of the replacement name */
	    r = s;
	    while (*s && !strchr(" \t,:", *s))
		s++;			/* Skip the replacement */
	    if (source)
		continue;
	    break;
	}
	/* At start of the source name */
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {/* Found! */
	    source = 0;
	    s += n;
	    continue;			/* Look for the replacement */
	}
	while (*s && !strchr(" \t,:", *s))
	    s++;			/* Skip the other source names */
    }
    /* Here r point to the replacement, s to the end of the replacement. */
    if (s >= r + sizeof(buf)) {
	HTInfoMsg("Charset name in CHARSET_SWITCH_RULES too long");
	return ord;
    }
    strncpy(buf, r, s-r);
    buf[s-r] = '\0';
    n = UCGetLYhndl_byMIME(buf);
    if (n < 0) {
	sprintf(buf, "Unknown charset name '%.*s' in CHARSET_SWITCH_RULES",
		s-r, r);
	HTInfoMsg(buf);
	return ord;
    }
    return n;
}

#  ifdef __EMX__
/* Switch display for the best fit for LYCharSet_UC[ord].
   If really is MAYBE, the switch is tentative only, another switch may happen
   before the actual display.

   Returns the charset we switched to.  */
PRIVATE int _Switch_Display_Charset ARGS2 (int, ord, enum switch_display_charset_t, really)
{
    CONST char *name;
    unsigned short cp;
    static int font_loaded_for = -1, old_h, old_w;
    int rc, ord1;
    UCHAR msgbuf[MAXPATHLEN + 80];

    CTRACE((tfp, "_Switch_Display_Charset(cp=%d, really=%d).\n", ord, really));
    /* Do not trust current_char_set unless REALLY, we fake it if MAYBE! */
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;
    if (ord == auto_other_display_charset
	|| ord == auto_display_charset || ord == font_loaded_for) {
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord; /* Report success, to avoid flicker, switch later */
    } else	/* Currently supports only koi8-r to cp866 translation */
	ord = Find_Best_Display_Charset(ord);

    /* Ignore sizechange unless the font is loaded */
    if (ord != font_loaded_for && really == SWITCH_DISPLAY_CHARSET_SIZECHANGE)
	return ord;

    if (ord == real_charsets[0] || ord == real_charsets[1]) {
	ord1 = (ord == real_charsets[1]
	       ? auto_other_display_charset : auto_display_charset);
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord; /* Can switch later, report success to avoid flicker */
    } else
	ord1 = ord;
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;

    name = LYCharSet_UC[ord1].MIMEname;
    if (ord1 == auto_other_display_charset || ord1 == auto_display_charset) {
      retry:
	rc = VioSetCp(0,codepages[ord1 == auto_other_display_charset],0);
	if (rc == 0)
	    goto report;
      err:
	sprintf(msgbuf, "Can't change to '%s': err=%#lx=%ld", name, rc, rc);
	HTInfoMsg(msgbuf);
	return -1;
    }

    /* Not a "prepared" codepage.  Need to load the user font. */
    if (charsets_directory) {
	TIB *tib;			/* Can't load font in a windowed-VIO */
	PIB *pib;
	VIOFONTINFO f[2];
	VIOFONTINFO *font;
	UCHAR b[1<<17];
	UCHAR *buf = b;
	UCHAR fnamebuf[MAXPATHLEN];
	FILE  *file;
	APIRET rc;
	long i, j;

	/* 0 means a FS protected-mode session */
	if ( font_loaded_for == -1		/* Did not try it yet */
	     && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0) ) {
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	/* Should not cross 64K boundaries: */
	font = f;
	if (((((ULONG)(char*)f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
	    font++;
	if (((ULONG)buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
	font->cb = sizeof(*font);	/* How large is this structure */
	font->type=0;			/* Not the BIOS, the loaded font. */
	font->cbData = 65535;		/* How large is my buffer? */
	font->pbData = _emx_32to16(buf); /* Wants an 16:16 pointer */

	rc = VioGetFont(font,0);	/* Retrieve data for current font */
	if (rc) {
	    sprintf(msgbuf, "Can't fetch current font info: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	if ( ord1 == font_loaded_for
	     && old_h == font->cyCell && old_w == font->cxCell ) {
	    /* The same as the previous font */
	    if ((rc = VioSetCp(0, -1, 0)))	/* -1: User font */
		goto err;
	    goto report;
	}
	sprintf(fnamebuf, "%s/%dx%d/%s.fnt",
		charsets_directory, font->cyCell, font->cxCell, name);
	file = fopen(fnamebuf, BIN_R);
	if (!file) {
	    sprintf(msgbuf, "Can't open font file '%s'", fnamebuf);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	i = ftell(file);
	fseek(file, 0, SEEK_END);
	if (ftell(file) - i != font->cbData) {
	    fclose(file);
	    sprintf(msgbuf, "Mismatch of size of font file '%s'", fnamebuf);
	    HTAlert(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	fseek(file, i, SEEK_SET);
	fread(buf, 1, font->cbData,file);
	fclose(file);
	rc = VioSetFont(font,0);	/* Put it all back.. */
	if (rc) {
	    sprintf(msgbuf, "Can't set font: err=%#lx=%ld", rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    font_loaded_for = -1;
	    goto retry;
	}
	font_loaded_for = ord1;
	old_h = font->cyCell;
	old_w = font->cxCell;
    } else {
	ord = ord1 = auto_display_charset;
	goto retry;
    }
  report:
    CTRACE((tfp, "Display font set to '%s'.\n", name));
    return ord;
}
#  endif /* __EMX__ */

PUBLIC int Switch_Display_Charset ARGS2 (CONST int, ord, CONST enum switch_display_charset_t, really)
{
    int prev = current_char_set;
    int res;
    static int repeated;

    if (!switch_display_charsets
	&& (really == SWITCH_DISPLAY_CHARSET_MAYBE
	    /* The first switch is not due to an interactive action */
	    || (really == SWITCH_DISPLAY_CHARSET_REALLY
		&& !(repeated++))))
	return 0;
    res = _Switch_Display_Charset(ord, really);
    if (res < 0 || prev == res)		/* No change */
	return 0;
    /* Register the change */
    current_char_set = res;
    HTMLUseCharacterSet(current_char_set);
    return 1;
}
#endif /* CAN_SWITCH_DISPLAY_CHARSET */

d359 1
a359 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
@

