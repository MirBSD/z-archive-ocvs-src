head	1.7;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.6
	tg-mergefixes-1-branch:1.6.0.4
	tg-mergefixes-1-base:1.6
	MIROS_X:1.6.0.2
	MIROS_X_BASE:1.6
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.4
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2005.01.03.00.46.02;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.20.10.26.29;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.17.00;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.35;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.37;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.33;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.21;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.17;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.13;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.49;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.51.06;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.10.20.10.10.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@soft merge
@
text
@/*			Lynx Client-side Image MAP Support	       LYMap.c
 *			==================================
 *
 *	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
 *
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTAnchor.h>
#include <HTAccess.h>
#include <HTFormat.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <LYUtils.h>
#include <LYMap.h>
#include <GridText.h>
#include <LYGlobalDefs.h>
#include <LYKeymap.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>
#include <LYStrings.h>

#ifdef DIRED_SUPPORT
#include <LYUpload.h>
#include <LYLocal.h>
#endif

#include <LYexit.h>
#include <LYLeaks.h>

typedef struct _LYMapElement {
    char *address;
    char *title;
#ifndef DONT_TRACK_INTERNAL_LINKS
    BOOL intern_flag;
#endif
} LYMapElement;

typedef struct _LYImageMap {
    char *address;
    char *title;
    HTList *elements;
} LYImageMap;

struct _HTStream {
    HTStreamClass *isa;
};

static HTList *LynxMaps = NULL;

BOOL LYMapsOnly = FALSE;

/*
 * Utility for freeing a list of MAPs.
 */
void ImageMapList_free(HTList *theList)
{
    LYImageMap *map;
    LYMapElement *element;
    HTList *cur = theList;
    HTList *current;

    if (!cur)
	return;

    while (NULL != (map = (LYImageMap *) HTList_nextObject(cur))) {
	FREE(map->address);
	FREE(map->title);
	if (map->elements) {
	    current = map->elements;
	    while (NULL !=
		   (element = (LYMapElement *) HTList_nextObject(current))) {
		FREE(element->address);
		FREE(element->title);
		FREE(element);
	    }
	    HTList_delete(map->elements);
	    map->elements = NULL;
	}
	FREE(map);
    }
    HTList_delete(theList);
    return;
}

#ifdef LY_FIND_LEAKS
/*
 * Utility for freeing the global list of MAPs.  - kw
 */
static void LYLynxMaps_free(void)
{
    ImageMapList_free(LynxMaps);
    LynxMaps = NULL;
    return;
}
#endif /* LY_FIND_LEAKS */

/*
 * We keep two kinds of lists:
 * - A global list (LynxMaps) shared by MAPs from all documents that
 *   do not have POST data.
 * - For each response to a POST which contains MAPs, a list specific
 *   to this combination of URL and post_data.  It is kept in the
 *   HTParentAnchor structure and is freed when the document is removed
 *   from memory, in the course of normal removal of anchors.
 *   MAPs from POST responses can only be accessed via internal links,
 *   i.e., from within the same document (with the same post_data).
 *   The notion of "same document" is extended, so that LYNXIMGMAP:
 *   and List Page screens are logically part of the document on which
 *   they are based. - kw
 *
 * If DONT_TRACK_INTERNAL_LINKS is defined, only the global list will be used
 * for all MAPs.
 *
 */

/*
 * Utility for creating an LYImageMap list, if it doesn't exist already, adding
 * LYImageMap entry structures if needed, and removing any LYMapElements in a
 * pre-existing LYImageMap entry so that it will have only those from AREA tags
 * for the current analysis of MAP element content.  - FM
 */
BOOL LYAddImageMap(char *address,
		   char *title,
		   HTParentAnchor *node_anchor)
{
    LYImageMap *tmp = NULL;
    LYImageMap *old = NULL;
    HTList *cur = NULL;
    HTList *theList = NULL;
    HTList *curele = NULL;
    LYMapElement *ele = NULL;

    if (isEmpty(address))
	return FALSE;
    if (!(node_anchor && node_anchor->address))
	return FALSE;

    /*
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list is created if it doesn't
     * already exist.  - kw
     */
#ifndef DONT_TRACK_INTERNAL_LINKS
    if (node_anchor->post_data) {
	/*
	 * We are handling a MAP element found while parsing node_anchor's
	 * stream of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
	 */
	theList = node_anchor->imaps;
	if (!theList) {
	    theList = node_anchor->imaps = HTList_new();
	}
    } else
#endif
    {
	if (!LynxMaps) {
	    LynxMaps = HTList_new();
#ifdef LY_FIND_LEAKS
	    atexit(LYLynxMaps_free);
#endif
	}
	theList = LynxMaps;
    }

    if (theList) {
	cur = theList;
	while (NULL != (old = (LYImageMap *) HTList_nextObject(cur))) {
	    if (old->address == 0)	/* shouldn't happen */
		continue;
	    if (!strcmp(old->address, address)) {
		FREE(old->address);
		FREE(old->title);
		if (old->elements) {
		    curele = old->elements;
		    while (NULL !=
			   (ele = (LYMapElement *) HTList_nextObject(curele))) {
			FREE(ele->address);
			FREE(ele->title);
			FREE(ele);
		    }
		    HTList_delete(old->elements);
		    old->elements = NULL;
		}
		break;
	    }
	}
    }

    tmp = (old != NULL) ?
	old : typecalloc(LYImageMap);
    if (tmp == NULL) {
	outofmem(__FILE__, "LYAddImageMap");
	return FALSE;
    }
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
    if (tmp != old)
	HTList_addObject(theList, tmp);
    return TRUE;
}

/*
 * Utility for adding LYMapElements to LYImageMaps
 * in the appropriate list. - FM
 */
BOOL LYAddMapElement(char *map,
		     char *address,
		     char *title,
		     HTParentAnchor *node_anchor,
		     BOOL intern_flag GCC_UNUSED)
{
    LYMapElement *tmp = NULL;
    LYImageMap *theMap = NULL;
    HTList *theList = NULL;
    HTList *cur = NULL;

    if (isEmpty(map) || isEmpty(address))
	return FALSE;
    if (!(node_anchor && node_anchor->address))
	return FALSE;

    /*
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list should already exist, since
     * this function is only called if the AREA tag we are handling was within
     * a MAP element in node_anchor's stream of data, so that LYAddImageMap has
     * been called.  - kw
     */
#ifndef DONT_TRACK_INTERNAL_LINKS
    if (node_anchor->post_data) {
	/*
	 * We are handling an AREA tag found while parsing node_anchor's stream
	 * of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
	 */
	theList = node_anchor->imaps;
	if (!theList)
	    return FALSE;
    } else
#endif
    {
	if (!LynxMaps)
	    LYAddImageMap(map, NULL, node_anchor);
	theList = LynxMaps;
    }

    cur = theList;
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(theMap->address, map)) {
	    break;
	}
    }
    if (!theMap)
	return FALSE;
    if (!theMap->elements)
	theMap->elements = HTList_new();
    cur = theMap->elements;
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	if (!strcmp(tmp->address, address)) {
	    FREE(tmp->address);
	    FREE(tmp->title);
	    HTList_removeObject(theMap->elements, tmp);
	    FREE(tmp);
	    break;
	}
    }

    tmp = typecalloc(LYMapElement);
    if (tmp == NULL) {
	perror("Out of memory in LYAddMapElement");
	return FALSE;
    }
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
    else
	StrAllocCopy(tmp->title, address);
#ifndef DONT_TRACK_INTERNAL_LINKS
    tmp->intern_flag = intern_flag;
#endif
    HTList_appendObject(theMap->elements, tmp);
    return TRUE;
}

/*
 * Utility for checking whether an LYImageMap entry with a given address
 * already exists in the LynxMaps structure.  - FM
 */
BOOL LYHaveImageMap(char *address)
{
    LYImageMap *Map;
    HTList *cur = LynxMaps;

    if (!(cur && non_empty(address)))
	return FALSE;

    while (NULL != (Map = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(Map->address, address)) {
	    return TRUE;
	}
    }

    return FALSE;
}

/*
 * Fills in a DocAddress structure for getting the HTParentAnchor of the
 * underlying resource.  ALso returns a pointer to that anchor in
 * *punderlying if we are dealing with POST data.  - kw
 *
 * address  is the address of the underlying resource, i.e., the one
 *	    containing the MAP element, the MAP's name appended as
 *	    fragment is ignored.
 * anAnchor is the LYNXIMGMAP: anchor; if it is associated with POST
 *	    data, we want the specific list, otherwise the global list.
 */
static void fill_DocAddress(DocAddress *wwwdoc, char *address,
			    HTParentAnchor *anAnchor,
			    HTParentAnchor **punderlying)
{
    HTParentAnchor *underlying;

    if (anAnchor && anAnchor->post_data) {
	wwwdoc->address = address;
	wwwdoc->post_data = anAnchor->post_data;
	wwwdoc->post_content_type = anAnchor->post_content_type;
	wwwdoc->bookmark = NULL;
	wwwdoc->isHEAD = FALSE;
	wwwdoc->safe = FALSE;
	underlying = HTAnchor_findAddress(wwwdoc);
	if (underlying->safe)
	    wwwdoc->safe = TRUE;
	if (punderlying)
	    *punderlying = underlying;
    } else {
	wwwdoc->address = address;
	wwwdoc->post_data = NULL;
	wwwdoc->post_content_type = NULL;
	wwwdoc->bookmark = NULL;
	wwwdoc->isHEAD = FALSE;
	wwwdoc->safe = FALSE;
	if (punderlying)
	    *punderlying = NULL;
    }
}

/*
 * Get the appropriate list for creating a LYNXIMGMAP:  pseudo- document: 
 * either the global list (LynxMaps), or the specific list if a List Page for a
 * POST response is requested.  Also fill in the DocAddress structure etc.  by
 * calling fill_DocAddress().
 *
 * address is the address of the underlying resource, i.e., the one
 *	   containing the MAP element, the MAP's name appended as
 *	   fragment is ignored.
 * anchor  is the LYNXIMGMAP: anchor for which LYLoadIMGmap() is
 *	   requested; if it is associated with POST data, we want the
 *	   specific list for this combination of address+post_data.
 *
 * if DONT_TRACK_INTERNAL_LINKS is defined, the Anchor passed to
 * LYLoadIMGmap() will never have post_data, so that the global list
 * will be used. - kw
 */
static HTList *get_the_list(DocAddress *wwwdoc, char *address,
			    HTParentAnchor *anchor,
			    HTParentAnchor **punderlying)
{
    if (anchor && anchor->post_data) {
	fill_DocAddress(wwwdoc, address, anchor, punderlying);
	if (non_empty(punderlying))
	    return (*punderlying)->imaps;
	return anchor->imaps;
    } else {
	fill_DocAddress(wwwdoc, address, NULL, punderlying);
	return LynxMaps;
    }
}

/*	LYLoadIMGmap - F.Macrides (macrides@@sci.wfeb.edu)
 *	------------
 *	Create a text/html stream with a list of links
 *	for HyperText References in AREAs of a MAP.
 */

static int LYLoadIMGmap(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    LYMapElement *tmp = NULL;
    LYImageMap *theMap = NULL;
    char *MapTitle = NULL;
    char *MapAddress = NULL;
    HTList *theList;
    HTList *cur = NULL;
    char *address = NULL;
    char *cp = NULL;
    DocAddress WWWDoc;
    HTParentAnchor *underlying;
    BOOL old_cache_setting = LYforce_no_cache;
    BOOL old_reloading = reloading;
    HTFormat old_format_out = HTOutputFormat;

    if (isLYNXIMGMAP(arg)) {
	address = (char *) (arg + LEN_LYNXIMGMAP);
    }
    if (!(address && strchr(address, ':'))) {
	HTAlert(MISDIRECTED_MAP_REQUEST);
	return (HT_NOT_LOADED);
    }

    theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
    if (WWWDoc.safe)
	anAnchor->safe = TRUE;

    if (!theList) {
	if (anAnchor->post_data && !WWWDoc.safe &&
	    ((underlying && underlying->document && !LYforce_no_cache) ||
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert(FAILED_MAP_POST_REQUEST);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = TRUE;
	reloading = TRUE;
	HTOutputFormat = WWW_PRESENT;
	LYMapsOnly = TRUE;
	if (!HTLoadAbsolute(&WWWDoc)) {
	    LYforce_no_cache = old_cache_setting;
	    reloading = old_reloading;
	    HTOutputFormat = old_format_out;
	    LYMapsOnly = FALSE;
	    HTAlert(MAP_NOT_ACCESSIBLE);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = old_cache_setting;
	reloading = old_reloading;
	HTOutputFormat = old_format_out;
	LYMapsOnly = FALSE;
	theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
    }

    if (!theList) {
	HTAlert(MAPS_NOT_AVAILABLE);
	return (HT_NOT_LOADED);
    }

    cur = theList;
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(theMap->address, address)) {
	    break;
	}
    }
    if (theMap && HTList_count(theMap->elements) == 0) {
	/*
	 * We found a MAP without any usable AREA.  Fake a redirection to the
	 * address with fragment.  We do this even for post data (internal link
	 * within a document with post data) if it will not result in an
	 * unwanted network request.  - kw
	 */
	if (!anAnchor->post_data) {
	    StrAllocCopy(redirecting_url, address);
	    return (HT_REDIRECTING);
	} else if (WWWDoc.safe ||
		   (underlying->document && !anAnchor->document &&
		    (LYinternal_flag || LYoverride_no_cache))) {
	    StrAllocCopy(redirecting_url, address);
	    redirect_post_content = TRUE;
	    return (HT_REDIRECTING);
	}
    }
    if (!(theMap && theMap->elements)) {
	if (anAnchor->post_data && !WWWDoc.safe &&
	    ((underlying && underlying->document && !LYforce_no_cache) ||
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert(FAILED_MAP_POST_REQUEST);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = TRUE;
	reloading = TRUE;
	HTOutputFormat = WWW_PRESENT;
	LYMapsOnly = TRUE;
	if (!HTLoadAbsolute(&WWWDoc)) {
	    LYforce_no_cache = old_cache_setting;
	    reloading = old_reloading;
	    HTOutputFormat = old_format_out;
	    LYMapsOnly = FALSE;
	    HTAlert(MAP_NOT_ACCESSIBLE);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = old_cache_setting;
	reloading = old_reloading;
	HTOutputFormat = old_format_out;
	LYMapsOnly = FALSE;
	cur = get_the_list(&WWWDoc, address, anAnchor, &underlying);
	while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	    if (!strcmp(theMap->address, address)) {
		break;
	    }
	}
	if (!(theMap && theMap->elements)) {
	    HTAlert(MAP_NOT_AVAILABLE);
	    return (HT_NOT_LOADED);
	}
    }
#ifdef DONT_TRACK_INTERNAL_LINKS
    anAnchor->no_cache = TRUE;
#endif

    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);

    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }

    if (non_empty(theMap->title)) {
	StrAllocCopy(MapTitle, theMap->title);
    } else if (non_empty(anAnchor->title)) {
	StrAllocCopy(MapTitle, anAnchor->title);
    } else if (non_empty(LYRequestTitle) &&
	       strcasecomp(LYRequestTitle, "[USEMAP]")) {
	StrAllocCopy(MapTitle, LYRequestTitle);
    } else if ((cp = strchr(address, '#')) != NULL) {
	StrAllocCopy(MapTitle, (cp + 1));
    }
    if (isEmpty(MapTitle)) {
	StrAllocCopy(MapTitle, "[USEMAP]");
    } else {
	LYEntify(&MapTitle, TRUE);
    }

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n");
    PUTS(buf);
    HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
    PUTS(buf);
    /*
     * This page is a list of titles and anchors for them.  Since titles
     * already passed SGML/HTML stage they converted to current_char_set.  That
     * is why we insist on META charset for this page.
     */
    HTSprintf0(&buf, "<title>%s</title>\n", MapTitle);
    PUTS(buf);
    HTSprintf0(&buf, "</head>\n<body>\n");
    PUTS(buf);

    HTSprintf0(&buf, "<h1><em>%s</em></h1>\n", MapTitle);
    PUTS(buf);

    StrAllocCopy(MapAddress, address);
    LYEntify(&MapAddress, FALSE);
    HTSprintf0(&buf, "<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
    PUTS(buf);

    HTSprintf0(&buf, "<%s compact>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
					"ol" : "ul"));
    PUTS(buf);
    cur = theMap->elements;
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	StrAllocCopy(MapAddress, tmp->address);
	LYEntify(&MapAddress, FALSE);
	PUTS("<li><a href=\"");
	PUTS(MapAddress);
	PUTS("\"");
#ifndef DONT_TRACK_INTERNAL_LINKS
	if (tmp->intern_flag)
	    PUTS(" TYPE=\"internal link\"");
#endif
	PUTS("\n>");
	LYformTitle(&MapTitle, tmp->title);
	LYEntify(&MapTitle, TRUE);
	PUTS(MapTitle);
	PUTS("</a>\n");
    }
    HTSprintf0(&buf, "</%s>\n</body>\n</html>\n",
	       ((keypad_mode == NUMBERS_AS_ARROWS)
		? "ol"
		: "ul"));
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(MapAddress);
    FREE(MapTitle);
    FREE(buf);
    return (HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYIMGMAP_C_GLOBALDEF_1_INIT { "LYNXIMGMAP", LYLoadIMGmap, 0}
GLOBALDEF(HTProtocol, LYLynxIMGmap, _LYIMGMAP_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxIMGmap =
{"LYNXIMGMAP", LYLoadIMGmap, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.6
log
@automatic merge
@
text
@d128 1
a128 1
    LYImageMap *new = NULL;
d192 1
a192 1
    new = (old != NULL) ?
d194 1
a194 1
    if (new == NULL) {
d198 1
a198 1
    StrAllocCopy(new->address, address);
d200 3
a202 3
	StrAllocCopy(new->title, title);
    if (new != old)
	HTList_addObject(theList, new);
d216 1
a216 1
    LYMapElement *new = NULL;
d262 6
a267 6
    while (NULL != (new = (LYMapElement *) HTList_nextObject(cur))) {
	if (!strcmp(new->address, address)) {
	    FREE(new->address);
	    FREE(new->title);
	    HTList_removeObject(theMap->elements, new);
	    FREE(new);
d272 2
a273 2
    new = typecalloc(LYMapElement);
    if (new == NULL) {
d277 1
a277 1
    StrAllocCopy(new->address, address);
d279 1
a279 1
	StrAllocCopy(new->title, title);
d281 1
a281 1
	StrAllocCopy(new->title, address);
d283 1
a283 1
    new->intern_flag = intern_flag;
d285 1
a285 1
    HTList_appendObject(theMap->elements, new);
d397 1
a397 1
    LYMapElement *new = NULL;
d574 2
a575 2
    while (NULL != (new = (LYMapElement *) HTList_nextObject(cur))) {
	StrAllocCopy(MapAddress, new->address);
d581 1
a581 1
	if (new->intern_flag)
d585 1
a585 1
	LYformTitle(&MapTitle, new->title);
@


1.5
log
@automatic merge of lynx-current
@
text
@d22 1
d135 1
a135 1
    if (!(address && *address))
d199 1
a199 1
    if (title && *title)
d221 1
a221 1
    if (!(map && *map && address && *address))
d278 1
a278 1
    if (title && *title)
d298 1
a298 1
    if (!(cur && address && *address != '\0'))
d374 1
a374 1
	if (punderlying && *punderlying)
d528 1
a528 1
    if (theMap->title && *theMap->title) {
d530 1
a530 1
    } else if (anAnchor->title && *anAnchor->title) {
d532 1
a532 1
    } else if (LYRequestTitle && *LYRequestTitle &&
d538 1
a538 1
    if (!(MapTitle && *MapTitle)) {
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 5
a6 5
**			==================================
**
**	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
**
*/
d32 2
a33 2
   char * address;
   char * title;
d35 1
a35 1
   BOOL   intern_flag;
d40 3
a42 3
   char * address;
   char * title;
   HTList * elements;
d45 2
a46 3
struct _HTStream
{
  HTStreamClass * isa;
d49 1
a49 1
static HTList * LynxMaps = NULL;
d54 1
a54 1
 *  Utility for freeing a list of MAPs.
d56 1
a56 2
void ImageMapList_free (
    HTList *		theList)
d66 1
a66 1
    while (NULL != (map = (LYImageMap *)HTList_nextObject(cur))) {
d72 1
a72 1
		   (element = (LYMapElement *)HTList_nextObject(current))) {
d88 1
a88 1
 *  Utility for freeing the global list of MAPs. - kw
d90 1
a90 1
static void LYLynxMaps_free (void)
d99 12
a110 12
 *  We keep two kinds of lists:
 *  - A global list (LynxMaps) shared by MAPs from all documents that
 *    do not have POST data.
 *  - For each response to a POST which contains MAPs, a list specific
 *    to this combination of URL and post_data.  It is kept in the
 *    HTParentAnchor structure and is freed when the document is removed
 *    from memory, in the course of normal removal of anchors.
 *    MAPs from POST responses can only be accessed via internal links,
 *    i.e., from within the same document (with the same post_data).
 *    The notion of "same document" is extended, so that LYNXIMGMAP:
 *    and List Page screens are logically part of the document on which
 *    they are based. - kw
d112 2
a113 2
 *  If DONT_TRACK_INTERNAL_LINKS is defined, only the global list will
 *  be used for all MAPs.
d118 4
a121 5
 *  Utility for creating an LYImageMap list, if it doesn't
 *  exist already, adding LYImageMap entry structures if needed, and
 *  removing any LYMapElements in a pre-existing LYImageMap entry so that
 *  it will have only those from AREA tags for the current analysis of
 *  MAP element content. - FM
d123 3
a125 4
BOOL LYAddImageMap (
	char *		address,
	char *		title,
	HTParentAnchor * node_anchor)
d140 3
a142 3
     *	Set theList to either the global LynxMaps list or, if we
     *	are associated with post data, the specific list.  The
     *	list is created if it doesn't already exist. - kw
d147 3
a149 4
	 *  We are handling a MAP element found while parsing
	 *  node_anchor's stream of data, and node_anchor has
	 *  post_data associated and should therefore represent
	 *  a POST response, so use the specific list. - kw
d169 1
a169 1
	while (NULL != (old = (LYImageMap *)HTList_nextObject(cur))) {
d178 1
a178 1
			   (ele = (LYMapElement *)HTList_nextObject(curele))) {
d192 1
a192 1
		    old : typecalloc(LYImageMap);
d209 5
a213 6
BOOL LYAddMapElement (
	char *		map,
	char *		address,
	char *		title,
	HTParentAnchor * node_anchor,
	BOOL		intern_flag GCC_UNUSED)
d226 5
a230 6
     *	Set theList to either the global LynxMaps list or, if we
     *	are associated with post data, the specific list.  The
     *	list should already exist, since this function is only called
     *	if the AREA tag we are handling was within a MAP element
     *	in node_anchor's stream of data, so that LYAddImageMap has
     *	been called. - kw
d235 3
a237 4
	 *  We are handling an AREA tag found while parsing
	 *  node_anchor's stream of data, and node_anchor has
	 *  post_data associated and should therefore represent
	 *  a POST response, so use the specific list. - kw
d251 1
a251 1
    while (NULL != (theMap = (LYImageMap *)HTList_nextObject(cur))) {
d261 1
a261 1
    while (NULL != (new = (LYMapElement *)HTList_nextObject(cur))) {
d289 2
a290 3
 *  Utility for checking whether an LYImageMap entry
 *  with a given address already exists in the LynxMaps
 *  structure. - FM
d292 1
a292 2
BOOL LYHaveImageMap (
	char *		address)
d300 1
a300 1
    while (NULL != (Map = (LYImageMap *)HTList_nextObject(cur))) {
d310 3
a312 3
 *  Fills in a DocAddress structure for getting the HTParentAnchor of
 *  the underlying resource.  ALso returns a pointer to that anchor in
 *  *punderlying if we are dealing with POST data. - kw
d314 5
a318 5
 *  address  is the address of the underlying resource, i.e., the one
 *	     containing the MAP element, the MAP's name appended as
 *	     fragment is ignored.
 *  anAnchor is the LYNXIMGMAP: anchor; if it is associated with POST
 *	     data, we want the specific list, otherwise the global list.
d320 3
a322 5
static void fill_DocAddress (
    DocAddress *	wwwdoc,
    char *		address,
    HTParentAnchor *	anAnchor,
    HTParentAnchor **	punderlying)
d324 2
a325 1
    HTParentAnchor * underlying;
d351 4
a354 4
 *  Get the appropriate list for creating a LYNXIMGMAP: pseudo-
 *  document: either the global list (LynxMaps), or the specific
 *  list if a List Page for a POST response is requested.  Also
 *  fill in the DocAddress structure etc. by calling fill_DocAddress().
d356 6
a361 6
 *  address is the address of the underlying resource, i.e., the one
 *	    containing the MAP element, the MAP's name appended as
 *	    fragment is ignored.
 *  anchor  is the LYNXIMGMAP: anchor for which LYLoadIMGmap() is
 *	    requested; if it is associated with POST data, we want the
 *	    specific list for this combination of address+post_data.
d367 3
a369 5
static HTList * get_the_list (
    DocAddress *	wwwdoc,
    char *		address,
    HTParentAnchor *	anchor,
    HTParentAnchor **	punderlying)
d383 9
a391 10
**	------------
**	Create a text/html stream with a list of links
**	for HyperText References in AREAs of a MAP.
*/

static int LYLoadIMGmap (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d405 1
a405 1
    HTParentAnchor * underlying;
d411 1
a411 1
	address = (char *)(arg + LEN_LYNXIMGMAP);
d415 1
a415 1
	return(HT_NOT_LOADED);
d427 1
a427 1
	    return(HT_NOT_LOADED);
d439 1
a439 1
	    return(HT_NOT_LOADED);
d450 1
a450 1
	return(HT_NOT_LOADED);
d454 1
a454 1
    while (NULL != (theMap = (LYImageMap *)HTList_nextObject(cur))) {
d461 4
a464 5
	 *  We found a MAP without any usable AREA.
	 *  Fake a redirection to the address with fragment.
	 *  We do this even for post data (internal link within
	 *  a document with post data) if it will not result in
	 *  an unwanted network request. - kw
d468 1
a468 1
	    return(HT_REDIRECTING);
d474 1
a474 1
	    return(HT_REDIRECTING);
d480 1
a480 1
	    HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
d482 1
a482 1
	    return(HT_NOT_LOADED);
d494 1
a494 1
	    return(HT_NOT_LOADED);
d501 1
a501 1
	while (NULL != (theMap = (LYImageMap *)HTList_nextObject(cur))) {
d508 1
a508 1
	    return(HT_NOT_LOADED);
a510 1

d521 1
a521 1
		HTAtom_name(format_in), HTAtom_name(format_out));
d524 1
a524 1
	return(HT_NOT_LOADED);
d535 1
a535 1
	StrAllocCopy(MapTitle, (cp+1));
d548 2
a549 2
		"http-equiv=\"content-type\"",
		LYCharSet_UC[current_char_set].MIMEname);
d551 5
a555 6
	/*
	 *  This page is a list of titles and anchors for them.
	 *  Since titles already passed SGML/HTML stage
	 *  they converted to current_char_set.
	 *  That is why we insist on META charset for this page.
	 */
d561 1
a561 1
    HTSprintf0(&buf,"<h1><em>%s</em></h1>\n", MapTitle);
d566 1
a566 1
    HTSprintf0(&buf,"<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
d570 1
a570 1
				    "ol" : "ul"));
d573 1
a573 1
    while (NULL != (new=(LYMapElement *)HTList_nextObject(cur))) {
d590 3
a592 3
		    ((keypad_mode == NUMBERS_AS_ARROWS)
		    ? "ol"
		    : "ul"));
d595 1
a595 1
    (*target->isa->_free)(target);
d599 1
a599 1
    return(HT_LOADED);
d604 1
a604 1
GLOBALDEF (HTProtocol,LYLynxIMGmap,_LYIMGMAP_C_GLOBALDEF_1_INIT);
d606 2
a607 1
GLOBALDEF HTProtocol LYLynxIMGmap = {"LYNXIMGMAP", LYLoadIMGmap, 0};
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d50 1
a50 1
PRIVATE HTList * LynxMaps = NULL;
d52 1
a52 1
PUBLIC BOOL LYMapsOnly = FALSE;
d57 2
a58 2
PUBLIC void ImageMapList_free ARGS1(
    HTList *,		theList)
d92 1
a92 1
PRIVATE void LYLynxMaps_free NOARGS
d126 4
a129 4
PUBLIC BOOL LYAddImageMap ARGS3(
	char *,		address,
	char *,		title,
	HTParentAnchor *, node_anchor)
d214 6
a219 6
PUBLIC BOOL LYAddMapElement ARGS5(
	char *,		map,
	char *,		address,
	char *,		title,
	HTParentAnchor *, node_anchor,
	BOOL,		intern_flag GCC_UNUSED)
d301 2
a302 2
PUBLIC BOOL LYHaveImageMap ARGS1(
	char *,		address)
d330 5
a334 5
PRIVATE void fill_DocAddress ARGS4(
    DocAddress *,	wwwdoc,
    char *,		address,
    HTParentAnchor *,	anAnchor,
    HTParentAnchor **,	punderlying)
d378 5
a382 5
PRIVATE HTList * get_the_list ARGS4(
    DocAddress *,	wwwdoc,
    char *,		address,
    HTParentAnchor *,	anchor,
    HTParentAnchor **,	punderlying)
d401 5
a405 5
PRIVATE int LYLoadIMGmap ARGS4 (
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d623 1
a623 1
GLOBALDEF PUBLIC HTProtocol LYLynxIMGmap = {"LYNXIMGMAP", LYLoadIMGmap, 0};
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d127 2
a128 2
	char *, 	address,
	char *, 	title,
d176 1
a176 1
	    	continue;
d197 1
a197 1
		    old : (LYImageMap *)calloc(1, sizeof(LYImageMap));
d215 3
a217 3
	char *, 	map,
	char *, 	address,
	char *, 	title,
d219 1
a219 1
	BOOL,		intern_flag)
d279 1
a279 1
    new = (LYMapElement *)calloc(1, sizeof(LYMapElement));
d302 1
a302 1
	char *, 	address)
d344 1
a344 1
	underlying = HTAnchor_parent(HTAnchor_findAddress(wwwdoc));
d424 2
a425 2
    if (!strncasecomp(arg, "LYNXIMGMAP:", 11)) {
	address = (char * )(arg + 11);
d473 19
d536 1
a536 1
	HTSprintf(&buf, CANNOT_CONVERT_I_TO_O,
d550 1
a550 1
    } else if ((cp=strrchr(address, '#')) != NULL) {
d601 1
a601 1
	StrAllocCopy(MapTitle, new->title);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 5
a6 5
 *			==================================
 *
 *	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
 *
 */
a21 1
#include <LYStrings.h>
d32 2
a33 2
    char *address;
    char *title;
d35 1
a35 1
    BOOL intern_flag;
d40 3
a42 3
    char *address;
    char *title;
    HTList *elements;
d45 3
a47 2
struct _HTStream {
    HTStreamClass *isa;
d50 1
a50 1
static HTList *LynxMaps = NULL;
d52 1
a52 1
BOOL LYMapsOnly = FALSE;
d55 1
a55 1
 * Utility for freeing a list of MAPs.
d57 2
a58 1
void ImageMapList_free(HTList *theList)
d68 1
a68 1
    while (NULL != (map = (LYImageMap *) HTList_nextObject(cur))) {
d74 1
a74 1
		   (element = (LYMapElement *) HTList_nextObject(current))) {
d90 1
a90 1
 * Utility for freeing the global list of MAPs.  - kw
d92 1
a92 1
static void LYLynxMaps_free(void)
d101 12
a112 12
 * We keep two kinds of lists:
 * - A global list (LynxMaps) shared by MAPs from all documents that
 *   do not have POST data.
 * - For each response to a POST which contains MAPs, a list specific
 *   to this combination of URL and post_data.  It is kept in the
 *   HTParentAnchor structure and is freed when the document is removed
 *   from memory, in the course of normal removal of anchors.
 *   MAPs from POST responses can only be accessed via internal links,
 *   i.e., from within the same document (with the same post_data).
 *   The notion of "same document" is extended, so that LYNXIMGMAP:
 *   and List Page screens are logically part of the document on which
 *   they are based. - kw
d114 2
a115 2
 * If DONT_TRACK_INTERNAL_LINKS is defined, only the global list will be used
 * for all MAPs.
d120 5
a124 4
 * Utility for creating an LYImageMap list, if it doesn't exist already, adding
 * LYImageMap entry structures if needed, and removing any LYMapElements in a
 * pre-existing LYImageMap entry so that it will have only those from AREA tags
 * for the current analysis of MAP element content.  - FM
d126 4
a129 3
BOOL LYAddImageMap(char *address,
		   char *title,
		   HTParentAnchor *node_anchor)
d131 1
a131 1
    LYImageMap *tmp = NULL;
d138 1
a138 1
    if (isEmpty(address))
d144 3
a146 3
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list is created if it doesn't
     * already exist.  - kw
d151 4
a154 3
	 * We are handling a MAP element found while parsing node_anchor's
	 * stream of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
d174 1
a174 1
	while (NULL != (old = (LYImageMap *) HTList_nextObject(cur))) {
d176 1
a176 1
		continue;
d183 1
a183 1
			   (ele = (LYMapElement *) HTList_nextObject(curele))) {
d196 3
a198 3
    tmp = (old != NULL) ?
	old : typecalloc(LYImageMap);
    if (tmp == NULL) {
d202 5
a206 5
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
    if (tmp != old)
	HTList_addObject(theList, tmp);
d214 6
a219 5
BOOL LYAddMapElement(char *map,
		     char *address,
		     char *title,
		     HTParentAnchor *node_anchor,
		     BOOL intern_flag GCC_UNUSED)
d221 1
a221 1
    LYMapElement *tmp = NULL;
d226 1
a226 1
    if (isEmpty(map) || isEmpty(address))
d232 6
a237 5
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list should already exist, since
     * this function is only called if the AREA tag we are handling was within
     * a MAP element in node_anchor's stream of data, so that LYAddImageMap has
     * been called.  - kw
d242 4
a245 3
	 * We are handling an AREA tag found while parsing node_anchor's stream
	 * of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
d259 1
a259 1
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
d269 6
a274 6
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	if (!strcmp(tmp->address, address)) {
	    FREE(tmp->address);
	    FREE(tmp->title);
	    HTList_removeObject(theMap->elements, tmp);
	    FREE(tmp);
d279 2
a280 2
    tmp = typecalloc(LYMapElement);
    if (tmp == NULL) {
d284 3
a286 3
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
d288 1
a288 1
	StrAllocCopy(tmp->title, address);
d290 1
a290 1
    tmp->intern_flag = intern_flag;
d292 1
a292 1
    HTList_appendObject(theMap->elements, tmp);
d297 3
a299 2
 * Utility for checking whether an LYImageMap entry with a given address
 * already exists in the LynxMaps structure.  - FM
d301 2
a302 1
BOOL LYHaveImageMap(char *address)
d307 1
a307 1
    if (!(cur && non_empty(address)))
d310 1
a310 1
    while (NULL != (Map = (LYImageMap *) HTList_nextObject(cur))) {
d320 3
a322 3
 * Fills in a DocAddress structure for getting the HTParentAnchor of the
 * underlying resource.  ALso returns a pointer to that anchor in
 * *punderlying if we are dealing with POST data.  - kw
d324 5
a328 5
 * address  is the address of the underlying resource, i.e., the one
 *	    containing the MAP element, the MAP's name appended as
 *	    fragment is ignored.
 * anAnchor is the LYNXIMGMAP: anchor; if it is associated with POST
 *	    data, we want the specific list, otherwise the global list.
d330 5
a334 3
static void fill_DocAddress(DocAddress *wwwdoc, char *address,
			    HTParentAnchor *anAnchor,
			    HTParentAnchor **punderlying)
d336 1
a336 2
    HTParentAnchor *underlying;

d344 1
a344 1
	underlying = HTAnchor_findAddress(wwwdoc);
d362 4
a365 4
 * Get the appropriate list for creating a LYNXIMGMAP:  pseudo- document: 
 * either the global list (LynxMaps), or the specific list if a List Page for a
 * POST response is requested.  Also fill in the DocAddress structure etc.  by
 * calling fill_DocAddress().
d367 6
a372 6
 * address is the address of the underlying resource, i.e., the one
 *	   containing the MAP element, the MAP's name appended as
 *	   fragment is ignored.
 * anchor  is the LYNXIMGMAP: anchor for which LYLoadIMGmap() is
 *	   requested; if it is associated with POST data, we want the
 *	   specific list for this combination of address+post_data.
d378 5
a382 3
static HTList *get_the_list(DocAddress *wwwdoc, char *address,
			    HTParentAnchor *anchor,
			    HTParentAnchor **punderlying)
d386 1
a386 1
	if (non_empty(punderlying))
d396 10
a405 9
 *	------------
 *	Create a text/html stream with a list of links
 *	for HyperText References in AREAs of a MAP.
 */

static int LYLoadIMGmap(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
d410 1
a410 1
    LYMapElement *tmp = NULL;
d419 1
a419 1
    HTParentAnchor *underlying;
d424 2
a425 2
    if (isLYNXIMGMAP(arg)) {
	address = (char *) (arg + LEN_LYNXIMGMAP);
d429 1
a429 1
	return (HT_NOT_LOADED);
d441 1
a441 1
	    return (HT_NOT_LOADED);
d453 1
a453 1
	    return (HT_NOT_LOADED);
d464 1
a464 1
	return (HT_NOT_LOADED);
d468 1
a468 1
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
a472 18
    if (theMap && HTList_count(theMap->elements) == 0) {
	/*
	 * We found a MAP without any usable AREA.  Fake a redirection to the
	 * address with fragment.  We do this even for post data (internal link
	 * within a document with post data) if it will not result in an
	 * unwanted network request.  - kw
	 */
	if (!anAnchor->post_data) {
	    StrAllocCopy(redirecting_url, address);
	    return (HT_REDIRECTING);
	} else if (WWWDoc.safe ||
		   (underlying->document && !anAnchor->document &&
		    (LYinternal_flag || LYoverride_no_cache))) {
	    StrAllocCopy(redirecting_url, address);
	    redirect_post_content = TRUE;
	    return (HT_REDIRECTING);
	}
    }
d476 1
a476 1
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
d478 1
a478 1
	    return (HT_NOT_LOADED);
d490 1
a490 1
	    return (HT_NOT_LOADED);
d497 1
a497 1
	while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
d504 1
a504 1
	    return (HT_NOT_LOADED);
d507 1
d517 2
a518 2
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
d521 1
a521 1
	return (HT_NOT_LOADED);
d524 1
a524 1
    if (non_empty(theMap->title)) {
d526 1
a526 1
    } else if (non_empty(anAnchor->title)) {
d528 1
a528 1
    } else if (non_empty(LYRequestTitle) &&
d531 2
a532 2
    } else if ((cp = strchr(address, '#')) != NULL) {
	StrAllocCopy(MapTitle, (cp + 1));
d534 1
a534 1
    if (isEmpty(MapTitle)) {
d545 2
a546 2
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
d548 6
a553 5
    /*
     * This page is a list of titles and anchors for them.  Since titles
     * already passed SGML/HTML stage they converted to current_char_set.  That
     * is why we insist on META charset for this page.
     */
d559 1
a559 1
    HTSprintf0(&buf, "<h1><em>%s</em></h1>\n", MapTitle);
d564 1
a564 1
    HTSprintf0(&buf, "<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
d568 1
a568 1
					"ol" : "ul"));
d571 2
a572 2
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	StrAllocCopy(MapAddress, tmp->address);
d578 1
a578 1
	if (tmp->intern_flag)
d582 1
a582 1
	LYformTitle(&MapTitle, tmp->title);
d588 3
a590 3
	       ((keypad_mode == NUMBERS_AS_ARROWS)
		? "ol"
		: "ul"));
d593 1
a593 1
    (*target->isa->_free) (target);
d597 1
a597 1
    return (HT_LOADED);
d602 1
a602 1
GLOBALDEF(HTProtocol, LYLynxIMGmap, _LYIMGMAP_C_GLOBALDEF_1_INIT);
d604 1
a604 2
GLOBALDEF HTProtocol LYLynxIMGmap =
{"LYNXIMGMAP", LYLoadIMGmap, 0};
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d127 2
a128 2
	char *,		address,
	char *,		title,
d176 1
a176 1
		continue;
d197 1
a197 1
		    old : typecalloc(LYImageMap);
d215 3
a217 3
	char *,		map,
	char *,		address,
	char *,		title,
d219 1
a219 1
	BOOL,		intern_flag GCC_UNUSED)
d279 1
a279 1
    new = typecalloc(LYMapElement);
d302 1
a302 1
	char *,		address)
d344 1
a344 1
	underlying = HTAnchor_findAddress(wwwdoc);
d424 2
a425 2
    if (isLYNXIMGMAP(arg)) {
	address = (char *)(arg + LEN_LYNXIMGMAP);
a472 19
    if (theMap && HTList_count(theMap->elements) == 0) {
	/*
	 *  We found a MAP without any usable AREA.
	 *  Fake a redirection to the address with fragment.
	 *  We do this even for post data (internal link within
	 *  a document with post data) if it will not result in
	 *  an unwanted network request. - kw
	 */
	if (!anAnchor->post_data) {
	    StrAllocCopy(redirecting_url, address);
	    return(HT_REDIRECTING);
	} else if (WWWDoc.safe ||
		   (underlying->document && !anAnchor->document &&
		    (LYinternal_flag || LYoverride_no_cache))) {
	    StrAllocCopy(redirecting_url, address);
	    redirect_post_content = TRUE;
	    return(HT_REDIRECTING);
	}
    }
d517 1
a517 1
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
d531 1
a531 1
    } else if ((cp = strchr(address, '#')) != NULL) {
d582 1
a582 1
	LYformTitle(&MapTitle, new->title);
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d50 1
a50 1
static HTList * LynxMaps = NULL;
d52 1
a52 1
BOOL LYMapsOnly = FALSE;
d57 2
a58 2
void ImageMapList_free (
    HTList *		theList)
d92 1
a92 1
static void LYLynxMaps_free (void)
d126 4
a129 4
BOOL LYAddImageMap (
	char *		address,
	char *		title,
	HTParentAnchor * node_anchor)
d214 6
a219 6
BOOL LYAddMapElement (
	char *		map,
	char *		address,
	char *		title,
	HTParentAnchor * node_anchor,
	BOOL		intern_flag GCC_UNUSED)
d301 2
a302 2
BOOL LYHaveImageMap (
	char *		address)
d330 5
a334 5
static void fill_DocAddress (
    DocAddress *	wwwdoc,
    char *		address,
    HTParentAnchor *	anAnchor,
    HTParentAnchor **	punderlying)
d378 5
a382 5
static HTList * get_the_list (
    DocAddress *	wwwdoc,
    char *		address,
    HTParentAnchor *	anchor,
    HTParentAnchor **	punderlying)
d401 5
a405 5
static int LYLoadIMGmap (
	const char *		arg,
	HTParentAnchor *	anAnchor,
	HTFormat		format_out,
	HTStream*		sink)
d623 1
a623 1
GLOBALDEF HTProtocol LYLynxIMGmap = {"LYNXIMGMAP", LYLoadIMGmap, 0};
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 5
a6 5
 *			==================================
 *
 *	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
 *
 */
d32 2
a33 2
    char *address;
    char *title;
d35 1
a35 1
    BOOL intern_flag;
d40 3
a42 3
    char *address;
    char *title;
    HTList *elements;
d45 3
a47 2
struct _HTStream {
    HTStreamClass *isa;
d50 1
a50 1
static HTList *LynxMaps = NULL;
d55 1
a55 1
 * Utility for freeing a list of MAPs.
d57 2
a58 1
void ImageMapList_free(HTList *theList)
d68 1
a68 1
    while (NULL != (map = (LYImageMap *) HTList_nextObject(cur))) {
d74 1
a74 1
		   (element = (LYMapElement *) HTList_nextObject(current))) {
d90 1
a90 1
 * Utility for freeing the global list of MAPs.  - kw
d92 1
a92 1
static void LYLynxMaps_free(void)
d101 12
a112 12
 * We keep two kinds of lists:
 * - A global list (LynxMaps) shared by MAPs from all documents that
 *   do not have POST data.
 * - For each response to a POST which contains MAPs, a list specific
 *   to this combination of URL and post_data.  It is kept in the
 *   HTParentAnchor structure and is freed when the document is removed
 *   from memory, in the course of normal removal of anchors.
 *   MAPs from POST responses can only be accessed via internal links,
 *   i.e., from within the same document (with the same post_data).
 *   The notion of "same document" is extended, so that LYNXIMGMAP:
 *   and List Page screens are logically part of the document on which
 *   they are based. - kw
d114 2
a115 2
 * If DONT_TRACK_INTERNAL_LINKS is defined, only the global list will be used
 * for all MAPs.
d120 5
a124 4
 * Utility for creating an LYImageMap list, if it doesn't exist already, adding
 * LYImageMap entry structures if needed, and removing any LYMapElements in a
 * pre-existing LYImageMap entry so that it will have only those from AREA tags
 * for the current analysis of MAP element content.  - FM
d126 4
a129 3
BOOL LYAddImageMap(char *address,
		   char *title,
		   HTParentAnchor *node_anchor)
d144 3
a146 3
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list is created if it doesn't
     * already exist.  - kw
d151 4
a154 3
	 * We are handling a MAP element found while parsing node_anchor's
	 * stream of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
d174 1
a174 1
	while (NULL != (old = (LYImageMap *) HTList_nextObject(cur))) {
d183 1
a183 1
			   (ele = (LYMapElement *) HTList_nextObject(curele))) {
d197 1
a197 1
	old : typecalloc(LYImageMap);
d214 6
a219 5
BOOL LYAddMapElement(char *map,
		     char *address,
		     char *title,
		     HTParentAnchor *node_anchor,
		     BOOL intern_flag GCC_UNUSED)
d232 6
a237 5
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list should already exist, since
     * this function is only called if the AREA tag we are handling was within
     * a MAP element in node_anchor's stream of data, so that LYAddImageMap has
     * been called.  - kw
d242 4
a245 3
	 * We are handling an AREA tag found while parsing node_anchor's stream
	 * of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
d259 1
a259 1
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
d269 1
a269 1
    while (NULL != (new = (LYMapElement *) HTList_nextObject(cur))) {
d297 3
a299 2
 * Utility for checking whether an LYImageMap entry with a given address
 * already exists in the LynxMaps structure.  - FM
d301 2
a302 1
BOOL LYHaveImageMap(char *address)
d310 1
a310 1
    while (NULL != (Map = (LYImageMap *) HTList_nextObject(cur))) {
d320 3
a322 3
 * Fills in a DocAddress structure for getting the HTParentAnchor of the
 * underlying resource.  ALso returns a pointer to that anchor in
 * *punderlying if we are dealing with POST data.  - kw
d324 5
a328 5
 * address  is the address of the underlying resource, i.e., the one
 *	    containing the MAP element, the MAP's name appended as
 *	    fragment is ignored.
 * anAnchor is the LYNXIMGMAP: anchor; if it is associated with POST
 *	    data, we want the specific list, otherwise the global list.
d330 5
a334 3
static void fill_DocAddress(DocAddress *wwwdoc, char *address,
			    HTParentAnchor *anAnchor,
			    HTParentAnchor **punderlying)
d336 1
a336 2
    HTParentAnchor *underlying;

d362 4
a365 4
 * Get the appropriate list for creating a LYNXIMGMAP:  pseudo- document: 
 * either the global list (LynxMaps), or the specific list if a List Page for a
 * POST response is requested.  Also fill in the DocAddress structure etc.  by
 * calling fill_DocAddress().
d367 6
a372 6
 * address is the address of the underlying resource, i.e., the one
 *	   containing the MAP element, the MAP's name appended as
 *	   fragment is ignored.
 * anchor  is the LYNXIMGMAP: anchor for which LYLoadIMGmap() is
 *	   requested; if it is associated with POST data, we want the
 *	   specific list for this combination of address+post_data.
d378 5
a382 3
static HTList *get_the_list(DocAddress *wwwdoc, char *address,
			    HTParentAnchor *anchor,
			    HTParentAnchor **punderlying)
d396 10
a405 9
 *	------------
 *	Create a text/html stream with a list of links
 *	for HyperText References in AREAs of a MAP.
 */

static int LYLoadIMGmap(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
d419 1
a419 1
    HTParentAnchor *underlying;
d425 1
a425 1
	address = (char *) (arg + LEN_LYNXIMGMAP);
d429 1
a429 1
	return (HT_NOT_LOADED);
d441 1
a441 1
	    return (HT_NOT_LOADED);
d453 1
a453 1
	    return (HT_NOT_LOADED);
d464 1
a464 1
	return (HT_NOT_LOADED);
d468 1
a468 1
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
d475 5
a479 4
	 * We found a MAP without any usable AREA.  Fake a redirection to the
	 * address with fragment.  We do this even for post data (internal link
	 * within a document with post data) if it will not result in an
	 * unwanted network request.  - kw
d483 1
a483 1
	    return (HT_REDIRECTING);
d489 1
a489 1
	    return (HT_REDIRECTING);
d495 1
a495 1
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
d497 1
a497 1
	    return (HT_NOT_LOADED);
d509 1
a509 1
	    return (HT_NOT_LOADED);
d516 1
a516 1
	while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
d523 1
a523 1
	    return (HT_NOT_LOADED);
d526 1
d537 1
a537 1
		   HTAtom_name(format_in), HTAtom_name(format_out));
d540 1
a540 1
	return (HT_NOT_LOADED);
d551 1
a551 1
	StrAllocCopy(MapTitle, (cp + 1));
d564 2
a565 2
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
d567 6
a572 5
    /*
     * This page is a list of titles and anchors for them.  Since titles
     * already passed SGML/HTML stage they converted to current_char_set.  That
     * is why we insist on META charset for this page.
     */
d578 1
a578 1
    HTSprintf0(&buf, "<h1><em>%s</em></h1>\n", MapTitle);
d583 1
a583 1
    HTSprintf0(&buf, "<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
d587 1
a587 1
					"ol" : "ul"));
d590 1
a590 1
    while (NULL != (new = (LYMapElement *) HTList_nextObject(cur))) {
d607 3
a609 3
	       ((keypad_mode == NUMBERS_AS_ARROWS)
		? "ol"
		: "ul"));
d612 1
a612 1
    (*target->isa->_free) (target);
d616 1
a616 1
    return (HT_LOADED);
d621 1
a621 1
GLOBALDEF(HTProtocol, LYLynxIMGmap, _LYIMGMAP_C_GLOBALDEF_1_INIT);
d623 1
a623 2
GLOBALDEF HTProtocol LYLynxIMGmap =
{"LYNXIMGMAP", LYLoadIMGmap, 0};
@


1.1.3.4
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@a21 1
#include <LYStrings.h>
d134 1
a134 1
    if (isEmpty(address))
d198 1
a198 1
    if (non_empty(title))
d220 1
a220 1
    if (isEmpty(map) || isEmpty(address))
d277 1
a277 1
    if (non_empty(title))
d297 1
a297 1
    if (!(cur && non_empty(address)))
d373 1
a373 1
	if (non_empty(punderlying))
d527 1
a527 1
    if (non_empty(theMap->title)) {
d529 1
a529 1
    } else if (non_empty(anAnchor->title)) {
d531 1
a531 1
    } else if (non_empty(LYRequestTitle) &&
d537 1
a537 1
    if (isEmpty(MapTitle)) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d127 2
a128 2
	char *,		address,
	char *,		title,
d176 1
a176 1
		continue;
d197 1
a197 1
		    old : typecalloc(LYImageMap);
d215 3
a217 3
	char *,		map,
	char *,		address,
	char *,		title,
d279 1
a279 1
    new = typecalloc(LYMapElement);
d302 1
a302 1
	char *,		address)
a472 19
    if (theMap && HTList_count(theMap->elements) == 0) {
	/*
	 *  We found a MAP without any usable AREA.
	 *  Fake a redirection to the address with fragment.
	 *  We do this even for post data (internal link within
	 *  a document with post data) if it will not result in
	 *  an unwanted network request. - kw
	 */
	if (!anAnchor->post_data) {
	    StrAllocCopy(redirecting_url, address);
	    return(HT_REDIRECTING);
	} else if (WWWDoc.safe ||
		   (underlying->document && !anAnchor->document &&
		    (LYinternal_flag || LYoverride_no_cache))) {
	    StrAllocCopy(redirecting_url, address);
	    redirect_post_content = TRUE;
	    return(HT_REDIRECTING);
	}
    }
d517 1
a517 1
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
d582 1
a582 1
	LYformTitle(&MapTitle, new->title);
@

