head	1.4;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.1.3.5
	tg-mergefixes-1-branch:1.1.3.5.0.4
	tg-mergefixes-1-base:1.1.3.5
	MIROS_X:1.1.3.5.0.2
	MIROS_X_BASE:1.1.3.5
	MIRBSD_XP_MIRPPC:1.1.3.4.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.1.3.4
	MIRBSD_XP_SPARC:1.1.3.4.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2005.01.03.00.45.55;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.28;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.26;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.20;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.30;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.20;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.02.08.13.11.09;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.16.01;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.52.59;	author tg;	state Stab;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTAlert.h>
#include <HTFile.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYBookmark.h>
#include <LYGlobalDefs.h>
#include <LYClean.h>
#include <LYKeymap.h>
#include <LYCharUtils.h>	/* need for META charset */
#include <UCAux.h>
#include <LYCharSets.h>		/* need for LYHaveCJKCharacterSet */
#include <LYCurses.h>
#include <GridText.h>
#include <HTCJK.h>

#ifdef VMS
#include <nam.h>
#endif /* VMS */

#include <LYLeaks.h>

char *MBM_A_subbookmark[MBM_V_MAXFILES + 1];
char *MBM_A_subdescript[MBM_V_MAXFILES + 1];

static BOOLEAN is_mosaic_hotlist = FALSE;
static const char *convert_mosaic_bookmark_file(const char *filename_buffer);

int LYindex2MBM(int n)
{
    static char MBMcodes[MBM_V_MAXFILES + 2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    return n >= 0 && n <= MBM_V_MAXFILES ? MBMcodes[n] : '?';
}

int LYMBM2index(int ch)
{
    if ((ch = TOUPPER(ch)) > 0) {
	const char *letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const char *result = strchr(letters, ch);

	if (result != 0
	    && (result - letters) <= MBM_V_MAXFILES)
	    return (result - letters);
    }
    return -1;
}

static void show_bookmark_not_defined(void)
{
    char *string_buffer = 0;

    HTSprintf0(&string_buffer,
	       BOOKMARK_FILE_NOT_DEFINED,
	       key_for_func(LYK_OPTIONS));
    LYMBM_statusline(string_buffer);
    FREE(string_buffer);
}

/*
 * Tries to open a bookmark file for reading, which may be the default, or
 * based on offering the user a choice from the MBM_A_subbookmark[] array.  If
 * successful the file is closed, and the filename in system path specs is
 * returned, the URL is allocated into *URL, and the MBM_A_subbookmark[]
 * filepath is allocated into the BookmarkPage global.  Returns a zero-length
 * pointer to flag a cancel, or a space to flag an undefined selection, without
 * allocating into *URL or BookmarkPage.  Returns NULL with allocating into
 * BookmarkPage but not *URL is the selection is valid but the file doesn't yet
 * exist.  - FM
 */
const char *get_bookmark_filename(char **URL)
{
    static char filename_buffer[LY_MAXPATH];
    char *string_buffer = 0;
    FILE *fp;
    int MBM_tmp;

    /*
     * Multi_Bookmarks support.  - FMG & FM
     * Let user select a bookmark file.
     */
    MBM_tmp = select_multi_bookmarks();
    if (MBM_tmp == -2)
	/*
	 * Zero-length pointer flags a cancel.  - FM
	 */
	return ("");
    if (MBM_tmp == -1) {
	show_bookmark_not_defined();
	/*
	 * Space flags an undefined selection.  - FMG
	 */
	return (" ");
    } else {
	/*
	 * Save the filepath as a global.  The system path will be loaded into
	 * to the (static) filename_buffer as the return value, the URL will be
	 * allocated into *URL, and we also need the filepath available to
	 * calling functions.  This is all pitifully non-reentrant, a la the
	 * original Lynx, and should be redesigned someday.  - FM
	 */
	StrAllocCopy(BookmarkPage, MBM_A_subbookmark[MBM_tmp]);
    }

    /*
     * Seek it in the home path.  - FM
     */
    LYAddPathToHome(filename_buffer,
		    sizeof(filename_buffer),
		    BookmarkPage);
    CTRACE((tfp, "\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n",
	    BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) != NULL) {
	/*
	 * We now have the file open.
	 * Check if it is a mosaic hotlist.
	 */
	if (LYSafeGets(&string_buffer, fp) != 0
	    && *LYTrimNewline(string_buffer) != '\0'
	    && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 29)) {
	    const char *newname;

	    /*
	     * It is a mosaic hotlist file.
	     */
	    is_mosaic_hotlist = TRUE;
	    newname = convert_mosaic_bookmark_file(filename_buffer);
	    LYLocalFileToURL(URL, newname);
	} else {
	    is_mosaic_hotlist = FALSE;
	    LYLocalFileToURL(URL, filename_buffer);
	}
	FREE(string_buffer);
	LYCloseInput(fp);

	return (filename_buffer);	/* bookmark file exists */
    }
    return (NULL);

}				/* big end */

/*
 * Converts a Mosaic hotlist file into an HTML file for handling as a Lynx
 * bookmark file.  - FM
 */
static const char *convert_mosaic_bookmark_file(const char *filename_buffer)
{
    static char newfile[LY_MAXPATH];
    FILE *fp, *nfp;
    char *buf = NULL;
    int line = -2;

    LYRemoveTemp(newfile);
    if ((nfp = LYOpenTemp(newfile, HTML_SUFFIX, "w")) == NULL) {
	LYMBM_statusline(NO_TEMP_FOR_HOTLIST);
	LYSleepAlert();
	return ("");
    }

    if ((fp = fopen(filename_buffer, TXT_R)) == NULL)
	return ("");		/* should always open */

    fprintf(nfp, "<head>\n<title>%s</title>\n</head>\n", MOSAIC_BOOKMARK_TITLE);
    fprintf(nfp, "%s\n\n<p>\n<ol>\n", gettext("\
     This file is an HTML representation of the X Mosaic hotlist file.\n\
     Outdated or invalid links may be removed by using the\n\
     remove bookmark command, it is usually the 'R' key but may have\n\
     been remapped by you or your system administrator."));

    while ((LYSafeGets(&buf, fp)) != NULL) {
	if (line >= 0) {
	    LYTrimNewline(buf);
	    if ((line % 2) == 0) {	/* even lines */
		if (*buf != '\0') {
		    strtok(buf, " ");	/* kill everything after the space */
		    fprintf(nfp, "<LI><a href=\"%s\">", buf);	/* the URL */
		}
	    } else {		/* odd lines */
		fprintf(nfp, "%s</a>\n", buf);	/* the title */
	    }
	}
	/* else - ignore the line (this gets rid of first two lines) */
	line++;
    }
    LYCloseTempFP(nfp);
    LYCloseInput(fp);
    return (newfile);
}

static BOOLEAN havevisible(const char *Title);
static BOOLEAN have8bit(const char *Title);
static char *title_convert8bit(const char *Title);

/*
 * Adds a link to a bookmark file, creating the file if it doesn't already
 * exist, and making sure that no_cache is set for a pre-existing, cached file,
 * so that the change will be evident on return to to that file.  - FM
 */
void save_bookmark_link(const char *address,
			const char *title)
{
    FILE *fp;
    BOOLEAN first_time = FALSE;
    const char *filename;
    char *bookmark_URL = NULL;
    char filename_buffer[LY_MAXPATH];
    char string_buffer[BUFSIZ];
    char tmp_buffer[BUFSIZ];
    char *Address = NULL;
    char *Title = NULL;
    int i, c;
    DocAddress WWWDoc;
    HTParentAnchor *tmpanchor;
    HText *text;

    /*
     * Make sure we were passed something to save.  - FM
     */
    if (isEmpty(address)) {
	HTAlert(MALFORMED_ADDRESS);
	return;
    }

    /*
     * Offer a choice of bookmark files, or get the default.  - FMG
     */
    filename = get_bookmark_filename(&bookmark_URL);

    /*
     * If filename is NULL, must create a new file.  If filename is a space, an
     * invalid bookmark file was selected, or if zero-length, the user
     * cancelled.  Ignore request in both cases.  Otherwise, make a copy before
     * anything might change the static get_bookmark_filename() buffer.  - FM
     */
    if (filename == NULL) {
	first_time = TRUE;
	filename_buffer[0] = '\0';
    } else {
	if (*filename == '\0' || !strcmp(filename, " ")) {
	    FREE(bookmark_URL);
	    return;
	}
	LYstrncpy(filename_buffer, filename, sizeof(filename_buffer) - 1);
    }

    /*
     * If BookmarkPage is NULL, something went wrong, so ignore the request.  -
     * FM
     */
    if (BookmarkPage == NULL) {
	FREE(bookmark_URL);
	return;
    }

    /*
     * If the link will be added to the same bookmark file, get confirmation. 
     * - FM
     */
    if (LYMultiBookmarks != MBM_OFF) {
	const char *url = HTLoadedDocumentURL();
	const char *page = (*BookmarkPage == '.')
	? (BookmarkPage + 1)
	: BookmarkPage;

	if (strstr(url, page) != NULL) {
	    LYMBM_statusline(MULTIBOOKMARKS_SELF);
	    c = LYgetch_single();
	    if (c != 'L') {
		FREE(bookmark_URL);
		return;
	    }
	}
    }

    /*
     * Allow user to change the title.  - FM
     */
    do {
	if (HTCJK == JAPANESE) {
	    switch (kanji_code) {
	    case EUC:
		TO_EUC((const unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    case SJIS:
		TO_SJIS((const unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    default:
		break;
	    }
	    LYstrncpy(string_buffer, tmp_buffer, sizeof(string_buffer) - 1);
	} else {
	    LYstrncpy(string_buffer, title, sizeof(string_buffer) - 1);
	}
	LYReduceBlanks(string_buffer);
	LYMBM_statusline(TITLE_PROMPT);
	LYgetstr(string_buffer, VISIBLE, sizeof(string_buffer), NORECALL);
	if (*string_buffer == '\0') {
	    LYMBM_statusline(CANCELLED);
	    LYSleepMsg();
	    FREE(bookmark_URL);
	    return;
	}
    } while (!havevisible(string_buffer));

    /*
     * Create the Title with any left-angle-brackets converted to &lt; entities
     * and any ampersands converted to &amp; entities.  - FM
     *
     * Convert 8-bit letters to &#xUUUU to avoid dependencies from display
     * character set which may need changing.  Do NOT convert any 8-bit chars
     * if we have CJK display.  - LP
     */
    LYformTitle(&Title, string_buffer);
    LYEntify(&Title, TRUE);
    if (UCSaveBookmarksInUnicode &&
	have8bit(Title) && (!LYHaveCJKCharacterSet)) {
	char *p = title_convert8bit(Title);

	FREE(Title);
	Title = p;
    }

    /*
     * Create the bookmark file, if it doesn't exist already, Otherwise, open
     * the pre-existing bookmark file.  - FM
     */
    SetDefaultMode(O_TEXT);
    if (first_time) {
	/*
	 * Seek it in the home path.  - FM
	 */
	LYAddPathToHome(filename_buffer,
			sizeof(filename_buffer),
			BookmarkPage);
    }
    CTRACE((tfp, "\nsave_bookmark_link: SEEKING %s\n   AS %s\n\n",
	    BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, (first_time ? TXT_W : TXT_A))) == NULL) {
	LYMBM_statusline(BOOKMARK_OPEN_FAILED);
	LYSleepAlert();
	FREE(Title);
	FREE(bookmark_URL);
	return;
    }

    /*
     * Convert all ampersands in the address to &amp; entities.  - FM
     */
    StrAllocCopy(Address, address);
    LYEntify(&Address, FALSE);

    /*
     * If we created a new bookmark file, write the headers.  - FM
     * Once and forever...
     */
    if (first_time) {
	fprintf(fp, "<head>\n");
#if defined(SH_EX) && !defined(_WINDOWS)	/* 1997/12/11 (Thu) 19:13:40 */
	if (HTCJK != JAPANESE)
	    LYAddMETAcharsetToFD(fp, -1);
	else
	    fprintf(fp, "<META %s %s>\n",
		    "http-equiv=\"content-type\"",
		    "content=\"text/html;charset=iso-2022-jp\"");
#else
	LYAddMETAcharsetToFD(fp, -1);
#endif /* !_WINDOWS */
	fprintf(fp, "<title>%s</title>\n</head>\n", BOOKMARK_TITLE);
#ifdef _WINDOWS
	fprintf(fp,
		gettext("     You can delete links by the 'R' key<br>\n<ol>\n"));
#else
	fprintf(fp, "%s<br>\n%s\n\n<!--\n%s\n-->\n\n<p>\n<ol>\n",
		gettext("\
     You can delete links using the remove bookmark command.  It is usually\n\
     the 'R' key but may have been remapped by you or your system\n\
     administrator."),
		gettext("\
     This file also may be edited with a standard text editor to delete\n\
     outdated or invalid links, or to change their order."),
		gettext("\
Note: if you edit this file manually\n\
      you should not change the format within the lines\n\
      or add other HTML markup.\n\
      Make sure any bookmark link is saved as a single line."));
#endif /* _WINDOWS */
    }

    /*
     * Add the bookmark link, in Mosaic hotlist or Lynx format.  - FM
     */
    if (is_mosaic_hotlist) {
	time_t NowTime = time(NULL);
	char *TimeString = (char *) ctime(&NowTime);

	/*
	 * TimeString has a \n at the end.
	 */
	fprintf(fp, "%s %s%s\n", Address, TimeString, Title);
    } else {
	fprintf(fp, "<LI><a href=\"%s\">%s</a>\n", Address, Title);
    }
    LYCloseOutput(fp);

    SetDefaultMode(O_BINARY);
    /*
     * If this is a cached bookmark file, set nocache for it so we'll see the
     * new bookmark link when that cache is retrieved.  - FM
     */
    if (!first_time && nhist > 0 && bookmark_URL) {
	for (i = 0; i < nhist; i++) {
	    if (HDOC(i).bookmark &&
		!strcmp(HDOC(i).address, bookmark_URL)) {
		WWWDoc.address = HDOC(i).address;
		WWWDoc.post_data = NULL;
		WWWDoc.post_content_type = NULL;
		WWWDoc.bookmark = HDOC(i).bookmark;
		WWWDoc.isHEAD = FALSE;
		WWWDoc.safe = FALSE;
		tmpanchor = HTAnchor_findAddress(&WWWDoc);
		if ((text = (HText *) HTAnchor_document(tmpanchor)) != NULL) {
		    HText_setNoCache(text);
		}
		break;
	    }
	}
    }

    /*
     * Clean up and report success.
     */
    FREE(Title);
    FREE(Address);
    FREE(bookmark_URL);
    LYMBM_statusline(OPERATION_DONE);
    LYSleepMsg();
}

/*
 * Remove a link from a bookmark file.  The calling function is expected to
 * have used get_filename_link(), pass us the link number as cur, the
 * MBM_A_subbookmark[] string as cur_bookmark_page, and to have set up no_cache
 * itself.  - FM
 */
void remove_bookmark_link(int cur,
			  char *cur_bookmark_page)
{
    FILE *fp, *nfp;
    char *buf = NULL;
    int n;

#ifdef VMS
    char filename_buffer[NAM$C_MAXRSS + 12];
    char newfile[NAM$C_MAXRSS + 12];

#define keep_tempfile FALSE
#else
    char filename_buffer[LY_MAXPATH];
    char newfile[LY_MAXPATH];
    BOOLEAN keep_tempfile = FALSE;

#ifdef UNIX
    struct stat stat_buf;
    mode_t mode;
    BOOLEAN regular = FALSE;
#endif /* UNIX */
#endif /* VMS */
    char homepath[LY_MAXPATH];

    CTRACE((tfp, "remove_bookmark_link: deleting link number: %d\n", cur));

    if (!cur_bookmark_page)
	return;
    LYAddPathToHome(filename_buffer,
		    sizeof(filename_buffer),
		    cur_bookmark_page);
    CTRACE((tfp, "\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n",
	    cur_bookmark_page, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) == NULL) {
	HTAlert(BOOKMARK_OPEN_FAILED_FOR_DEL);
	return;
    }

    LYAddPathToHome(homepath, sizeof(homepath), "");
    if ((nfp = LYOpenScratch(newfile, homepath)) == 0) {
	LYCloseInput(fp);
	HTAlert(BOOKSCRA_OPEN_FAILED_FOR_DEL);
	return;
    }
#ifdef UNIX
    /*
     * Explicitly preserve bookmark file mode on Unix.  - DSL
     */
    if (stat(filename_buffer, &stat_buf) == 0) {
	regular = (S_ISREG(stat_buf.st_mode) && stat_buf.st_nlink == 1);
	mode = ((stat_buf.st_mode & 0777) | 0600);	/* make it writable */
	(void) chmod(newfile, mode);
	if ((nfp = LYReopenTemp(newfile)) == NULL) {
	    (void) LYCloseInput(fp);
	    HTAlert(BOOKTEMP_REOPEN_FAIL_FOR_DEL);
	    return;
	}
    }
#endif /* UNIX */

    if (is_mosaic_hotlist) {
	int del_line = cur * 2;	/* two lines per entry */

	n = -3;			/* skip past cookie and name lines */
	while (LYSafeGets(&buf, fp) != NULL) {
	    n++;
	    if (n == del_line || n == del_line + 1)
		continue;	/* remove two lines */
	    if (fputs(buf, nfp) == EOF)
		goto failure;
	}

    } else {
	char *cp, *cp2;
	BOOLEAN retain;
	int seen;

	n = -1;
	while (LYSafeGets(&buf, fp) != NULL) {
	    int keep_ol = FALSE;

	    retain = TRUE;
	    seen = 0;
	    cp = buf;
	    if ((cur == 0) && (cp2 = LYstrstr(cp, "<ol><LI>")))
		keep_ol = TRUE;	/* Do not erase, this corrects a bug in an
				   older version */
	    while (n < cur && (cp = LYstrstr(cp, "<a href="))) {
		seen++;
		if (++n == cur) {
		    if (seen != 1 || !LYstrstr(buf, "</a>") ||
			LYstrstr((cp + 1), "<a href=")) {
			HTAlert(BOOKMARK_LINK_NOT_ONE_LINE);
			goto failure;
		    }
		    CTRACE((tfp, "remove_bookmark_link: skipping link %d\n", n));
		    if (keep_ol)
			fprintf(nfp, "<ol>\n");
		    retain = FALSE;
		}
		cp += 8;
	    }
	    if (retain && fputs(buf, nfp) == EOF)
		goto failure;
	}
    }

    FREE(buf);
    CTRACE((tfp, "remove_bookmark_link: files: %s %s\n",
	    newfile, filename_buffer));

    LYCloseInput(fp);
    fp = NULL;
    if (fflush(nfp) == EOF) {
	CTRACE((tfp, "fflush(nfp): %s", LYStrerror(errno)));
	goto failure;
    }
    LYCloseTempFP(nfp);
    nfp = NULL;
#if defined(DOSPATH) || defined(__EMX__)
    remove(filename_buffer);
#endif /* DOSPATH */

#ifdef UNIX
    /*
     * By copying onto the bookmark file, rather than renaming it, we can
     * preserve the original ownership of the file, provided that it is
     * writable by the current process.
     *
     * Changed to copy 1998-04-26 -- gil
     *
     * But if the copy fails, for example because the filesystem is full, we
     * are left with a corrupt bookmark file.  Changed back to use the previous
     * mechanism [try rename(), then mv for EXDEV], except in usual cases (not
     * a regular file e.g., symbolic link, or has hard links).  This will let
     * bookmarks survive a filesystem full condition in the "normal" case
     * (bookmark is on same filesystem as home directory, is a regular file,
     * has no additional hard links).
     *
     * If we first tried LYCopyFile, and that fails, also fall back to trying
     * the other stuff.  That gives a chance to recover in case the LYCopyFile
     * left a corrupt target file.
     *
     * If there is an error, and that error may mean that the bookmark file has
     * been corrupted, don't remove the temporary newfile (which should always
     * be uncorrupted) in place, it may still be used to recover manually.  If
     * this applies, produce an additional message to that effect.  The temp
     * file will still be removed by normal program exit cleanup.  - kw
     * 1999-11-12
     */
    if (!regular) {
	if (LYCopyFile(newfile, filename_buffer) == 0) {
	    LYRemoveTemp(newfile);
	    return;
	}
	LYSleepAlert();		/* give a chance to see error from cp - kw */
	HTUserMsg(BOOKTEMP_COPY_FAIL);
	keep_tempfile = TRUE;
    }
#endif /* UNIX */

    if (rename(newfile, filename_buffer) != -1) {
#ifdef MULTI_USER_UNIX
	if (regular)
	    chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif
	HTSYS_purge(filename_buffer);
	return;
    } else {
#ifndef VMS
	/*
	 * Rename won't work across file systems.  Check if this is the case
	 * and do something appropriate.  Used to be ODD_RENAME
	 */
#if defined(_WINDOWS) || defined(WIN_EX)
#if defined(WIN_EX)
	if (GetLastError() == ERROR_NOT_SAME_DEVICE)
#else /* !_WIN_EX */
	if (errno == ENOTSAM)
#endif /* _WIN_EX */
	{
	    if (rename(newfile, filename_buffer) != 0) {
		if (LYCopyFile(newfile, filename_buffer) == 0)
		    remove(newfile);
	    }
	}
#else
	if (errno == EXDEV) {
	    static const char MV_FMT[] = "%s %s %s";
	    char *buffer = 0;
	    const char *program;

	    if ((program = HTGetProgramPath(ppMV)) != NULL) {
		HTAddParam(&buffer, MV_FMT, 1, program);
		HTAddParam(&buffer, MV_FMT, 2, newfile);
		HTAddParam(&buffer, MV_FMT, 3, filename_buffer);
		HTEndParam(&buffer, MV_FMT, 3);
		if (LYSystem(buffer) == 0) {
#ifdef MULTI_USER_UNIX
		    if (regular)
			chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif
		    FREE(buffer);
		    return;
		}
	    }
	    FREE(buffer);
	    keep_tempfile = TRUE;
	    goto failure;
	}
	CTRACE((tfp, "rename(): %s", LYStrerror(errno)));
#endif /* _WINDOWS */
#endif /* !VMS */

#ifdef VMS
	HTAlert(ERROR_RENAMING_SCRA);
#else
	HTAlert(ERROR_RENAMING_TEMP);
#endif /* VMS */
	if (TRACE)
	    perror("renaming the file");
    }

  failure:
    FREE(buf);
    HTAlert(BOOKMARK_DEL_FAILED);
    if (nfp)
	LYCloseTempFP(nfp);
    if (fp != NULL)
	LYCloseInput(fp);
    if (keep_tempfile) {
	HTUserMsg2(gettext("File may be recoverable from %s during this session"),
		   newfile);
    } else {
	LYRemoveTemp(newfile);
    }
}

/*
 * Allows user to select sub-bookmarks files.  - FMG & FM
 */
int select_multi_bookmarks(void)
{
    int c;

    /*
     * If not enabled, pick the "default" (0).
     */
    if (LYMultiBookmarks == MBM_OFF || LYHaveSubBookmarks() == FALSE) {
	if (MBM_A_subbookmark[0])	/* If it exists! */
	    return (0);
	else
	    return (-1);
    }

    /*
     * For ADVANCED users, we can just mess with the status line to save the 2
     * redraws of the screen, if LYMBMAdvnced is TRUE.  '=' will still show the
     * screen and let them do it the "long" way.
     */
    if (LYMultiBookmarks == MBM_ADVANCED && user_mode == ADVANCED_MODE) {
	LYMBM_statusline(MULTIBOOKMARKS_SELECT);
      get_advanced_choice:
	c = LYgetch();
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = LYCharINTERRUPT2;
	}
#endif /* VMS */
	if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) || LYCharIsINTERRUPT_HARD(c)) {
	    /*
	     * Treat left-arrow, ^G, or ^C as cancel.
	     */
	    return (-2);
	}
	if (LYisNonAlnumKeyname(c, LYK_REFRESH)) {
	    /*
	     * Refresh the screen.
	     */
	    lynx_force_repaint();
	    LYrefresh();
	    goto get_advanced_choice;
	}
	if (LYisNonAlnumKeyname(c, LYK_ACTIVATE)) {
	    /*
	     * Assume default bookmark file on ENTER or right-arrow.
	     */
	    return (MBM_A_subbookmark[0] ? 0 : -1);
	}
	switch (c) {
	case '=':
	    /*
	     * Get the choice via the menu.
	     */
	    return (select_menu_multi_bookmarks());

	default:
	    /*
	     * Convert to an array index, act on it if valid.
	     * Otherwise, get another keystroke.
	     */
	    if ((c = LYMBM2index(c)) < 0) {
		goto get_advanced_choice;
	    }
	}
	/*
	 * See if we have a bookmark like that.
	 */
	return (MBM_A_subbookmark[c] ? c : -1);
    } else {
	/*
	 * Get the choice via the menu.
	 */
	return (select_menu_multi_bookmarks());
    }
}

/*
 * Allows user to select sub-bookmarks files.  - FMG & FM
 */
int select_menu_multi_bookmarks(void)
{
    int c, d, MBM_tmp_count, MBM_allow;
    int MBM_screens, MBM_from, MBM_to, MBM_current;

    /*
     * If not enabled, pick the "default" (0).
     */
    if (LYMultiBookmarks == MBM_OFF)
	return (0);

    /*
     *        Filip M. Gieszczykiewicz (filipg@@paranoia.com) & FM
     *  ---------------------------------------------------
     * MBM_A_subbookmark[n] - Hold values of the respective "multi_bookmarkn"
     * in the lynxrc file.
     *
     * MBM_A_subdescript[n] - Hold description entries in the lynxrc file.
     *
     * Note: MBM_A_subbookmark[0] is defined to be same value as
     *       "bookmark_file" in the lynxrc file and/or the startup
     *       "bookmark_page".
     *
     * We make the display of bookmarks depend on rows we have available.
     *
     * We load BookmarkPage with the valid MBM_A_subbookmark[n] via
     * get_bookmark_filename().  Otherwise, that function returns a zero-length
     * string to indicate a cancel, a single space to indicate an invalid
     * choice, or NULL to indicate an inaccessible file.
     */
    MBM_allow = (LYlines - 7);	/* We need 7 for header and footer */
    /*
     * Screen big enough?
     */
    if (MBM_allow <= 0) {
	/*
	 * Too small.
	 */
	HTAlert(MULTIBOOKMARKS_SMALL);
	return (-2);
    }

    MBM_screens = (MBM_V_MAXFILES / MBM_allow) + 1;	/* int rounds off low. */

    MBM_current = 1;		/* Gotta start somewhere :-) */

    for (;;) {
	MBM_from = MBM_allow * MBM_current - MBM_allow;
	if (MBM_from < 0)
	    MBM_from = 0;	/* 0 is default bookmark... */
	if (MBM_current != 1)
	    MBM_from++;

	MBM_to = (MBM_allow * MBM_current);
	if (MBM_to > MBM_V_MAXFILES)
	    MBM_to = MBM_V_MAXFILES;

	/*
	 * Display menu of bookmarks.  NOTE that we avoid printw()'s to
	 * increase the chances that any non-ASCII or multibyte/CJK characters
	 * will be handled properly.  - FM
	 */
	LYclear();
	LYmove(1, 5);
	lynx_start_h1_color();
	if (MBM_screens > 1) {
	    char *shead_buffer = 0;

	    HTSprintf0(&shead_buffer,
		       MULTIBOOKMARKS_SHEAD_MASK, MBM_current, MBM_screens);
	    LYaddstr(shead_buffer);
	    FREE(shead_buffer);
	} else {
	    LYaddstr(MULTIBOOKMARKS_SHEAD);
	}

	lynx_stop_h1_color();

	MBM_tmp_count = 0;
	for (c = MBM_from; c <= MBM_to; c++) {
	    LYmove(3 + MBM_tmp_count, 5);
	    LYaddch(LYindex2MBM(c));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[c])
		LYaddstr(MBM_A_subdescript[c]);
	    LYmove(3 + MBM_tmp_count, 36);
	    LYaddch('(');
	    if (MBM_A_subbookmark[c])
		LYaddstr(MBM_A_subbookmark[c]);
	    LYaddch(')');
	    MBM_tmp_count++;
	}

	/*
	 * Don't need to show it if it all fits on one screen!
	 */
	if (MBM_screens > 1) {
	    LYmove(LYlines - 2, 0);
	    LYaddstr("'");
	    lynx_start_bold();
	    LYaddstr("[");
	    lynx_stop_bold();
	    LYaddstr("' ");
	    LYaddstr(PREVIOUS);
	    LYaddstr(", '");
	    lynx_start_bold();
	    LYaddstr("]");
	    lynx_stop_bold();
	    LYaddstr("' ");
	    LYaddstr(NEXT_SCREEN);
	}

	LYMBM_statusline(MULTIBOOKMARKS_SAVE);

	for (;;) {
	    c = LYgetch();
#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = 7;
	    }
#endif /* VMS */

	    if ((d = LYMBM2index(c)) >= 0) {
		/*
		 * See if we have a bookmark like that.
		 */
		if (MBM_A_subbookmark[d] != NULL)
		    return (d);

		show_bookmark_not_defined();
		LYMBM_statusline(MULTIBOOKMARKS_SAVE);
	    } else if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) ||
		       c == 7 || c == 3) {
		/*
		 * Treat left-arrow, ^G, or ^C as cancel.
		 */
		return (-2);
	    } else if (LYisNonAlnumKeyname(c, LYK_REFRESH)) {
		/*
		 * Refresh the screen.
		 */
		lynx_force_repaint();
		LYrefresh();
	    } else if (LYisNonAlnumKeyname(c, LYK_ACTIVATE)) {
		/*
		 * Assume default bookmark file on ENTER or right-arrow.
		 */
		return (MBM_A_subbookmark[0] ? 0 : -1);
	    } else if ((c == ']' || LYisNonAlnumKeyname(c, LYK_NEXT_PAGE)) &&
		       MBM_screens > 1) {
		/*
		 * Next range, if available.
		 */
		if (++MBM_current > MBM_screens)
		    MBM_current = 1;
		break;
	    }

	    else if ((c == '[' || LYisNonAlnumKeyname(c, LYK_PREV_PAGE)) &&
		     MBM_screens > 1) {
		/*
		 * Previous range, if available.
		 */
		if (--MBM_current <= 0)
		    MBM_current = MBM_screens;
		break;
	    }
	}
    }
}

/*
 * This function returns TRUE if we have sub-bookmarks defined.  Otherwise
 * (i.e., only the default bookmark file is defined), it returns FALSE.  - FM
 */
BOOLEAN LYHaveSubBookmarks(void)
{
    int i;

    for (i = 1; i < MBM_V_MAXFILES; i++) {
	if (non_empty(MBM_A_subbookmark[i]))
	    return (TRUE);
    }

    return (FALSE);
}

/*
 * This function passes a string to _statusline(), making sure it is at the
 * bottom of the screen if LYMultiBookmarks is not MBM_OFF, otherwise, letting
 * it go to the normal statusline position based on the current user mode.  We
 * want to use _statusline() so that any multibyte/CJK characters in the string
 * will be handled properly.  - FM
 */
void LYMBM_statusline(const char *text)
{
    if (LYMultiBookmarks != MBM_OFF && user_mode == NOVICE_MODE) {
	LYStatusLine = (LYlines - 1);
	_statusline(text);
	LYStatusLine = -1;
    } else {
	_statusline(text);
    }
}

/*
 * Check whether we have any visible (non-blank) chars.
 */
static BOOLEAN havevisible(const char *Title)
{
    const char *p = Title;
    unsigned char c;
    long unicode;

    for (; *p; p++) {
	c = UCH(TOASCII(*p));
	if (c > 32 && c < 127)
	    return (TRUE);
	if (c <= 32 || c == 127)
	    continue;
	if (LYHaveCJKCharacterSet || !UCCanUniTranslateFrom(current_char_set))
	    return (TRUE);
	unicode = UCTransToUni(*p, current_char_set);
	if (unicode > 32 && unicode < 127)
	    return (TRUE);
	if (unicode <= 32 || unicode == 0xa0 || unicode == 0xad)
	    continue;
	if (unicode >= 0x2000 && unicode < 0x200f)
	    continue;
	return (TRUE);
    }
    return (FALSE);		/* if we came here */
}

/*
 * Check whether string have 8 bit chars.
 */
static BOOLEAN have8bit(const char *Title)
{
    const char *p = Title;

    for (; *p; p++) {
	if (UCH(*p) > 127)
	    return (TRUE);
    }
    return (FALSE);		/* if we came here */
}

/*
 * Ok, title have 8-bit characters and they are in display charset.  Bookmarks
 * is a permanent file.  To avoid dependencies from display character set which
 * may be changed with time we store 8-bit characters as numeric character
 * reference (NCR), so where the character encoded as unicode number in form of
 * &#xUUUU;
 *
 * To make bookmarks more readable for human (&#xUUUU certainly not) we add a
 * comment with '7-bit approximation' from the converted string.  This is a
 * valid HTML and bookmarks code.
 *
 * We do not want use META charset tag in bookmarks file:  it will never be
 * changed later :-(
 *
 * NCR's translation is part of I18N and HTML4.0 supported starting with Lynx
 * 2.7.2, Netscape 4.0 and MSIE 4.0.  Older versions fail.
 */
static char *title_convert8bit(const char *Title)
{
    const char *p = Title;
    char *p0;
    char *q;
    char *comment = NULL;
    char *ncr = NULL;
    char *buf = NULL;
    int charset_in = current_char_set;
    int charset_out = UCGetLYhndl_byMIME("us-ascii");

    for (; *p; p++) {
	char temp[2];

	LYstrncpy(temp, p, sizeof(temp) - 1);
	if (UCH(*temp) <= 127) {
	    StrAllocCat(comment, temp);
	    StrAllocCat(ncr, temp);
	} else {
	    long unicode;
	    char replace_buf[32];

	    if (UCTransCharStr(replace_buf, sizeof(replace_buf), *temp,
			       charset_in, charset_out, YES) > 0)
		StrAllocCat(comment, replace_buf);

	    unicode = UCTransToUni(*temp, charset_in);

	    StrAllocCat(ncr, "&#");
	    sprintf(replace_buf, "%ld", unicode);
	    StrAllocCat(ncr, replace_buf);
	    StrAllocCat(ncr, ";");
	}
    }

    /*
     * Cleanup comment, collapse multiple dashes into one dash, skip '>'.
     */
    for (q = p0 = comment; *p0; p0++) {
	if (UCH(TOASCII(*p0)) >= 32 &&
	    *p0 != '>' &&
	    (q == comment || *p0 != '-' || *(q - 1) != '-')) {
	    *q++ = *p0;
	}
    }
    *q = '\0';

    /*
     * valid bookmark should be a single line (no linebreaks!).
     */
    StrAllocCat(buf, "<!-- ");
    StrAllocCat(buf, comment);
    StrAllocCat(buf, " -->");
    StrAllocCat(buf, ncr);

    FREE(comment);
    FREE(ncr);
    return (buf);
}

/*
 * Since this is the "Default Bookmark File", we save it as a global, and as
 * the first MBM_A_subbookmark entry.
 */
void set_default_bookmark_page(char *value)
{
    if (value != 0) {
	if (bookmark_page == 0
	    || strcmp(bookmark_page, value)) {
	    StrAllocCopy(bookmark_page, value);
	}
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
    }
}
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d10 1
a10 1
#include <LYCharUtils.h> /* need for META charset */
d12 1
a12 1
#include <LYCharSets.h>  /* need for LYHaveCJKCharacterSet */
d23 2
a24 2
PUBLIC char *MBM_A_subbookmark[MBM_V_MAXFILES+1];
PUBLIC char *MBM_A_subdescript[MBM_V_MAXFILES+1];
d26 2
a27 2
PRIVATE BOOLEAN is_mosaic_hotlist = FALSE;
PRIVATE char * convert_mosaic_bookmark_file PARAMS((char *filename_buffer));
d29 1
a29 1
PUBLIC int LYindex2MBM ARGS1(int, n)
d31 2
a32 1
    static char MBMcodes[MBM_V_MAXFILES+2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
d36 1
a36 1
PUBLIC int LYMBM2index ARGS1(int, ch)
d39 3
a41 2
	char *letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	char *result = strchr(letters, ch);
d43 1
a43 1
	 && (result - letters) <= MBM_V_MAXFILES)
d49 1
a49 2
PRIVATE void
show_bookmark_not_defined NOARGS
d54 2
a55 2
	    BOOKMARK_FILE_NOT_DEFINED,
	    key_for_func(LYK_OPTIONS));
d61 9
a69 11
 *  Tries to open a bookmark file for reading, which may be
 *  the default, or based on offering the user a choice from
 *  the MBM_A_subbookmark[] array.  If successful the file is
 *  closed, and the filename in system path specs is returned,
 *  the URL is allocated into *URL, and the MBM_A_subbookmark[]
 *  filepath is allocated into the BookmarkPage global.  Returns
 *  a zero-length pointer to flag a cancel, or a space to flag
 *  an undefined selection, without allocating into *URL or
 *  BookmarkPage.  Returns NULL with allocating into BookmarkPage
 *  but not *URL is the selection is valid but the file doesn't
 *  yet exist. - FM
d71 1
a71 2
PUBLIC char * get_bookmark_filename ARGS1(
	char **,	URL)
d79 2
a80 2
     *	Multi_Bookmarks support. - FMG & FM
     *	Let user select a bookmark file.
d85 1
a85 1
	 *  Zero-length pointer flags a cancel. - FM
d87 1
a87 1
	return("");
d91 1
a91 1
	 *  Space flags an undefined selection. - FMG
d93 1
a93 1
	return(" ");
d96 5
a100 6
	 *  Save the filepath as a global.  The system path will be
	 *  loaded into to the (static) filename_buffer as the return
	 *  value, the URL will be allocated into *URL, and we also
	 *  need the filepath available to calling functions.  This
	 *  is all pitifully non-reentrant, a la the original Lynx,
	 *  and should be redesigned someday. - FM
d106 1
a106 1
     *	Seek it in the home path. - FM
d112 1
a112 1
		BookmarkPage, filename_buffer));
d119 4
a122 3
	 && *LYTrimNewline(string_buffer) != '\0'
	 && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 29)) {
	    char *newname;
d124 1
a124 1
	     *  It is a mosaic hotlist file.
d136 1
a136 1
	return(filename_buffer);  /* bookmark file exists */
d138 1
a138 1
    return(NULL);
d140 1
a140 1
} /* big end */
d143 2
a144 2
 *  Converts a Mosaic hotlist file into an HTML
 *  file for handling as a Lynx bookmark file. - FM
d146 1
a146 2
PRIVATE char * convert_mosaic_bookmark_file ARGS1(
	char *,		filename_buffer)
d161 1
a161 1
	return ("");  /* should always open */
d163 1
a163 1
    fprintf(nfp,"<head>\n<title>%s</title>\n</head>\n",MOSAIC_BOOKMARK_TITLE);
d173 4
a176 4
	    if ((line % 2) == 0) { /* even lines */
		if(*buf != '\0') {
		    strtok(buf," "); /* kill everything after the space */
		    fprintf(nfp,"<LI><a href=\"%s\">",buf); /* the URL */
d178 2
a179 2
	    } else { /* odd lines */
		fprintf(nfp,"%s</a>\n",buf);  /* the title */
d187 1
a187 1
    return(newfile);
d190 3
a192 3
PRIVATE  BOOLEAN havevisible PARAMS((CONST char *Title));
PRIVATE  BOOLEAN have8bit PARAMS((CONST char *Title));
PRIVATE  char* title_convert8bit PARAMS((CONST char *Title));
d195 3
a197 5
 *  Adds a link to a bookmark file, creating the file
 *  if it doesn't already exist, and making sure that
 *  no_cache is set for a pre-existing, cached file,
 *  so that the change will be evident on return to
 *  to that file. - FM
d199 2
a200 3
PUBLIC void save_bookmark_link ARGS2(
	char *,		address,
	char *,		title)
d204 1
a204 1
    char *filename;
d217 1
a217 1
     *	Make sure we were passed something to save. - FM
d219 1
a219 1
    if (!(address && *address)) {
d225 1
a225 2
     *	Offer a choice of bookmark files,
     *	or get the default. - FMG
d230 4
a233 6
     *	If filename is NULL, must create a new file.  If
     *	filename is a space, an invalid bookmark file was
     *	selected, or if zero-length, the user cancelled.
     *	Ignore request in both cases.  Otherwise, make
     *	a copy before anything might change the static
     *	get_bookmark_filename() buffer. - FM
d239 1
a239 1
	if (*filename == '\0' || !strcmp(filename," ")) {
d243 1
a243 1
	LYstrncpy(filename_buffer, filename, sizeof(filename_buffer)-1);
d247 2
a248 2
     *	If BookmarkPage is NULL, something went
     *	wrong, so ignore the request. - FM
d256 2
a257 2
     *	If the link will be added to the same
     *	bookmark file, get confirmation. - FM
d260 5
a264 4
	CONST char *url = HTLoadedDocumentURL();
	CONST char *page = (*BookmarkPage == '.')
			    ? (BookmarkPage + 1)
			    : BookmarkPage;
d276 1
a276 1
     *	Allow user to change the title. - FM
d280 1
a280 1
	    switch(kanji_code) {
d282 1
a282 1
		TO_EUC((CONST unsigned char *) title, (unsigned char *) tmp_buffer);
d285 1
a285 1
		TO_SJIS((CONST unsigned char *) title, (unsigned char *) tmp_buffer);
d290 1
a290 1
	    LYstrncpy(string_buffer, tmp_buffer, sizeof(string_buffer)-1);
d292 1
a292 1
	    LYstrncpy(string_buffer, title, sizeof(string_buffer)-1);
d294 1
a294 1
	convert_to_spaces(string_buffer, FALSE);
d303 1
a303 1
    } while(!havevisible(string_buffer));
d306 2
a307 3
     *	Create the Title with any left-angle-brackets
     *	converted to &lt; entities and any ampersands
     *	converted to &amp; entities.  - FM
d309 3
a311 3
     *  Convert 8-bit letters to &#xUUUU to avoid dependencies
     *  from display character set which may need changing.
     *  Do NOT convert any 8-bit chars if we have CJK display. - LP
d318 1
d324 2
a325 2
     *	Create the bookmark file, if it doesn't exist already,
     *	Otherwise, open the pre-existing bookmark file. - FM
d330 1
a330 1
	 *  Seek it in the home path. - FM
d337 1
a337 1
		BookmarkPage, filename_buffer));
d347 1
a347 1
     *	Convert all ampersands in the address to &amp; entities. - FM
d353 2
a354 2
     *	If we created a new bookmark file, write the headers. - FM
     *  Once and forever...
d367 2
a368 2
#endif	/* !_WINDOWS */
	fprintf(fp,"<title>%s</title>\n</head>\n", BOOKMARK_TITLE);
d371 1
a371 1
	    gettext("     You can delete links by the 'R' key<br>\n<ol>\n"));
d374 1
a374 1
		    gettext("\
d378 1
a378 1
		    gettext("\
d381 1
a381 1
		    gettext("\
d386 1
a386 1
#endif	/* _WINDOWS */
d390 1
a390 1
     *	Add the bookmark link, in Mosaic hotlist or Lynx format. - FM
d394 2
a395 1
	char *TimeString = (char *)ctime (&NowTime);
d397 1
a397 1
	 *  TimeString has a \n at the end.
d399 1
a399 1
	fprintf(fp,"%s %s%s\n", Address, TimeString, Title);
d401 1
a401 1
	fprintf(fp,"<LI><a href=\"%s\">%s</a>\n", Address, Title);
d407 2
a408 3
     *	If this is a cached bookmark file, set nocache for
     *	it so we'll see the new bookmark link when that
     *	cache is retrieved. - FM
d421 1
a421 1
		if ((text = (HText *)HTAnchor_document(tmpanchor)) != NULL) {
d430 1
a430 1
     *	Clean up and report success.
d440 4
a443 5
 *  Remove a link from a bookmark file.  The calling
 *  function is expected to have used get_filename_link(),
 *  pass us the link number as cur, the MBM_A_subbookmark[]
 *  string as cur_bookmark_page, and to have set up no_cache
 *  itself. - FM
d445 2
a446 3
PUBLIC void remove_bookmark_link ARGS2(
	int,		cur,
	char *,		cur_bookmark_page)
d451 1
d453 3
a455 2
    char filename_buffer[NAM$C_MAXRSS+12];
    char newfile[NAM$C_MAXRSS+12];
d461 1
d478 1
a478 1
		cur_bookmark_page, filename_buffer));
a489 1

d492 1
a492 1
     *	Explicitly preserve bookmark file mode on Unix. - DSL
d496 1
a496 1
	mode = ((stat_buf.st_mode & 0777) | 0600); /* make it writable */
d507 3
a509 2
	int del_line = cur*2;  /* two lines per entry */
	n = -3;  /* skip past cookie and name lines */
d512 2
a513 2
	    if (n == del_line || n == del_line+1)
		continue;  /* remove two lines */
d526 1
d530 2
a531 2
	    if ((cur == 0) && (cp2 = LYstrstr(cp,"<ol><LI>")))
		keep_ol = TRUE; /* Do not erase, this corrects a bug in an
d543 1
a543 1
			fprintf(nfp,"<ol>\n");
d555 1
a555 1
			newfile, filename_buffer));
d571 24
a594 20
     *	By copying onto the bookmark file, rather than renaming it, we
     *	can preserve the original ownership of the file, provided that
     *	it is writable by the current process.
     *	Changed to copy  1998-04-26 -- gil
     *  But if the copy fails, for example because the filesystem is full,
     *  we are left with a corrupt bookmark file.  Changed back to use
     *  the previous mechanism [try rename(), then mv for EXDEV], except
     *  in usual cases (not a regular file e.g., symbolic link, or has hard
     *  links).  This will let bookmarks survive a filesystem full condition
     *  in the "normal" case (bookmark is on same filesystem as home directory,
     *  is a regular file, has no additional hard links).
     *  If we first tried LYCopyFile, and that fails, also fall back to trying
     *  the other stuff.  That gives a chance to recover in case the LYCopyFile
     *  left a corrupt target file.
     *  If there is an error, and that error may mean that the bookmark file
     *  has been corrupted, don't remove the temporary newfile (which should
     *  always be uncorrupted) in place, it may still be used to recover
     *  manually.  If this applies, produce an additional message to that
     *  effect.  The temp file will still be removed by normal program exit
     *  cleanup. - kw 1999-11-12
d601 1
a601 1
	LYSleepAlert();	/* give a chance to see error from cp - kw */
d605 1
a605 1
#endif  /* UNIX */
d617 2
a618 3
	 *  Rename won't work across file systems.
	 *  Check if this is the case and do something appropriate.
	 *  Used to be ODD_RENAME
d634 1
a634 1
	    static CONST char MV_FMT[] = "%s %s %s";
d636 1
a636 1
	    CONST char *program;
d669 1
a669 2

failure:
d685 1
a685 1
 *  Allows user to select sub-bookmarks files. - FMG & FM
d687 1
a687 1
PUBLIC int select_multi_bookmarks NOARGS
d692 1
a692 1
     *	If not enabled, pick the "default" (0).
d695 2
a696 2
	if (MBM_A_subbookmark[0]) /* If it exists! */
	    return(0);
d698 1
a698 1
	    return(-1);
d702 3
a704 3
     *	For ADVANCED users, we can just mess with the status line to save
     *	the 2 redraws of the screen, if LYMBMAdvnced is TRUE.  '=' will
     *	still show the screen and let them do it the "long" way.
d708 1
a708 1
get_advanced_choice:
d718 1
a718 1
	     *	Treat left-arrow, ^G, or ^C as cancel.
d720 1
a720 1
	    return(-2);
d724 1
a724 1
	     *	Refresh the screen.
d732 1
a732 1
	     *	Assume default bookmark file on ENTER or right-arrow.
d737 5
a741 5
	    case '=':
		/*
		 *  Get the choice via the menu.
		 */
		return(select_menu_multi_bookmarks());
d743 8
a750 8
	    default:
		/*
		 *  Convert to an array index, act on it if valid.
		 *  Otherwise, get another keystroke.
		 */
		if ((c = LYMBM2index(c)) < 0) {
		    goto get_advanced_choice;
		}
d753 1
a753 1
	 *  See if we have a bookmark like that.
d758 1
a758 1
	 *  Get the choice via the menu.
d760 1
a760 1
	return(select_menu_multi_bookmarks());
d765 1
a765 1
 *  Allows user to select sub-bookmarks files. - FMG & FM
d767 1
a767 1
PUBLIC int select_menu_multi_bookmarks NOARGS
d773 1
a773 1
     *	If not enabled, pick the "default" (0).
d776 1
a776 1
	return(0);
d779 4
a782 4
     *	Filip M. Gieszczykiewicz (filipg@@paranoia.com) & FM
     *	---------------------------------------------------
     *	MBM_A_subbookmark[n] - Hold values of the respective
     *	"multi_bookmarkn" in the lynxrc file.
d784 1
a784 2
     *	MBM_A_subdescript[n] - Hold description entries in the
     *	lynxrc file.
d786 3
a788 3
     *	Note: MBM_A_subbookmark[0] is defined to be same value as
     *	      "bookmark_file" in the lynxrc file and/or the startup
     *	      "bookmark_page".
d790 1
a790 2
     *	We make the display of bookmarks depend on rows we have
     *	available.
d792 4
a795 5
     *	We load BookmarkPage with the valid MBM_A_subbookmark[n]
     *	via get_bookmark_filename().  Otherwise, that function
     *	returns a zero-length string to indicate a cancel, a
     *	single space to indicate an invalid choice, or NULL to
     *	indicate an inaccessible file.
d797 1
a797 1
    MBM_allow=(LYlines-7);	/* We need 7 for header and footer */
d799 1
a799 1
     *	Screen big enough?
d803 1
a803 1
	 *  Too small.
d809 1
a809 1
    MBM_screens = (MBM_V_MAXFILES/MBM_allow)+1; /* int rounds off low. */
d811 1
a811 1
    MBM_current = 1; /* Gotta start somewhere :-) */
d816 1
a816 1
	    MBM_from = 0; /* 0 is default bookmark... */
d825 3
a827 3
	 *  Display menu of bookmarks.  NOTE that we avoid printw()'s
	 *  to increase the chances that any non-ASCII or multibyte/CJK
	 *  characters will be handled properly. - FM
d831 1
a831 1
	lynx_start_h1_color ();
d834 1
d836 1
a836 1
		    MULTIBOOKMARKS_SHEAD_MASK, MBM_current, MBM_screens);
d843 1
a843 1
	lynx_stop_h1_color ();
d847 1
a847 1
	    LYmove(3+MBM_tmp_count, 5);
d852 1
a852 1
	    LYmove(3+MBM_tmp_count,36);
d861 1
a861 1
	 *  Don't need to show it if it all fits on one screen!
d864 1
a864 1
	    LYmove(LYlines-2, 0);
d866 1
a866 1
	    start_bold();
d868 1
a868 1
	    stop_bold();
d872 1
a872 1
	    start_bold();
d874 1
a874 1
	    stop_bold();
d892 1
a892 1
		 *  See if we have a bookmark like that.
d895 1
a895 1
		    return(d);
d900 1
a900 1
		c == 7 || c == 3) {
d902 1
a902 1
		 *  Treat left-arrow, ^G, or ^C as cancel.
d904 1
a904 1
		return(-2);
d907 1
a907 1
		 *  Refresh the screen.
d913 1
a913 1
		 *  Assume default bookmark file on ENTER or right-arrow.
d915 3
a917 3
		return(MBM_A_subbookmark[0] ? 0 : -1);
	    } else if ((c == ']' ||  LYisNonAlnumKeyname(c, LYK_NEXT_PAGE)) &&
		MBM_screens > 1) {
d919 1
a919 1
		 *  Next range, if available.
d926 2
a927 2
	    else if ((c == '[' ||  LYisNonAlnumKeyname(c, LYK_PREV_PAGE)) &&
		MBM_screens > 1) {
d929 1
a929 1
		 *  Previous range, if available.
d940 2
a941 3
 *  This function returns TRUE if we have sub-bookmarks defined.
 *  Otherwise (i.e., only the default bookmark file is defined),
 *  it returns FALSE. - FM
d943 1
a943 1
PUBLIC BOOLEAN LYHaveSubBookmarks NOARGS
d948 2
a949 2
	if (MBM_A_subbookmark[i] != NULL && *MBM_A_subbookmark[i] != '\0')
	    return(TRUE);
d952 1
a952 1
    return(FALSE);
d956 5
a960 6
 *  This function passes a string to _statusline(), making
 *  sure it is at the bottom of the screen if LYMultiBookmarks
 *  is not MBM_OFF, otherwise, letting it go to the normal statusline
 *  position based on the current user mode.  We want to use
 *  _statusline() so that any multibyte/CJK characters in the
 *  string will be handled properly. - FM
d962 1
a962 2
PUBLIC void LYMBM_statusline  ARGS1(
	char *,		text)
d976 1
a976 1
PRIVATE  BOOLEAN havevisible ARGS1(CONST char *, Title)
d978 1
a978 1
    CONST char *p = Title;
d982 1
a982 1
    for ( ; *p; p++) {
d985 1
a985 1
	    return(TRUE);
d989 1
a989 1
	    return(TRUE);
d992 1
a992 1
	    return(TRUE);
d997 1
a997 1
	return(TRUE);
d999 1
a999 1
    return(FALSE); /* if we came here */
d1005 1
a1005 1
PRIVATE  BOOLEAN have8bit ARGS1(CONST char *, Title)
d1007 1
a1007 1
    CONST char *p = Title;
d1009 1
a1009 1
    for ( ; *p; p++) {
d1011 1
a1011 1
	return(TRUE);
d1013 1
a1013 1
    return(FALSE); /* if we came here */
d1017 5
a1021 5
 *  Ok, title have 8-bit characters and they are in display charset.
 *  Bookmarks is a permanent file.  To avoid dependencies from display
 *  character set which may be changed with time
 *  we store 8-bit characters as numeric character reference (NCR),
 *  so where the character encoded as unicode number in form of &#xUUUU;
d1023 3
a1025 3
 *  To make bookmarks more readable for human (&#xUUUU certainly not)
 *  we add a comment with '7-bit approximation' from the converted string.
 *  This is a valid HTML and bookmarks code.
d1027 2
a1028 6
 *  We do not want use META charset tag in bookmarks file:
 *  it will never be changed later :-(
 *  NCR's translation is part of I18N and HTML4.0
 *  supported starting with Lynx 2.7.2,
 *  Netscape 4.0 and MSIE 4.0.
 *  Older versions fail.
d1030 2
d1033 1
a1033 1
PRIVATE  char* title_convert8bit ARGS1(CONST char *, Title)
d1035 1
a1035 1
    CONST char *p = Title;
d1039 1
a1039 1
    char *ncr     = NULL;
d1041 1
a1041 1
    int charset_in  = current_char_set;
d1044 1
a1044 1
    for ( ; *p; p++) {
d1046 2
a1047 1
	LYstrncpy(temp, p, sizeof(temp)-1);
d1053 1
a1053 1
	    char replace_buf [32];
d1056 1
a1056 1
				  charset_in, charset_out, YES) > 0)
d1059 1
a1059 1
	    unicode = UCTransToUni( *temp, charset_in);
d1069 1
a1069 2
     *  Cleanup comment, collapse multiple dashes into one dash,
     *  skip '>'.
d1074 1
a1074 1
	    (q == comment || *p0 != '-' || *(q-1) != '-')) {
d1090 1
a1090 1
    return(buf);
d1097 1
a1097 2
PUBLIC void set_default_bookmark_page ARGS1(
	char *,		value)
d1101 1
a1101 1
	 || strcmp(bookmark_page, value)) {
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d3 1
d15 1
d29 18
d114 3
a116 19
    CTRACE(tfp, "\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n",
		BookmarkPage, filename_buffer);
    if ((fp = fopen(filename_buffer,"r")) != NULL) {
	goto success;
    }

    /*
     *	Failure.
     */
    return(NULL);

success:
    /*
     *	We now have the file open.
     *	Check if it is a mosaic hotlist.
     */
    if (LYSafeGets(&string_buffer, fp) != 0
     && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 29)) {
	char *newname;
d118 2
a119 1
	 *  It is a mosaic hotlist file.
d121 18
a138 6
	is_mosaic_hotlist = TRUE;
	newname = convert_mosaic_bookmark_file(filename_buffer);
	LYLocalFileToURL(URL, newname);
    } else {
	is_mosaic_hotlist = FALSE;
	LYLocalFileToURL(URL, filename_buffer);
d140 1
a140 4
    FREE(string_buffer);
    fclose(fp);

    return(filename_buffer);  /* bookmark file exists */
a154 1
    char *endline;
d159 1
a159 1
	sleep(AlertSecs);
d163 1
a163 1
    if ((fp = fopen(filename_buffer, "r")) == NULL)
d174 3
a176 5
	if(line >= 0) {
	    endline = &buf[strlen(buf)-1];
	    if(*endline == '\n')
		*endline = '\0';
	    if((line % 2) == 0) { /* even lines */
d189 1
a189 1
    fclose(fp);
d214 1
d252 1
a252 1
	strcpy(filename_buffer, filename);
d268 12
a279 9
    if (LYMultiBookmarks == TRUE &&
	strstr(HTLoadedDocumentURL(),
	       (*BookmarkPage == '.' ?
		    (BookmarkPage+1) : BookmarkPage)) != NULL) {
	LYMBM_statusline(MULTIBOOKMARKS_SELF);
	c = LYgetch();
	if (TOUPPER(c) != 'L') {
	    FREE(bookmark_URL);
	    return;
d287 15
a301 1
	LYstrncpy(string_buffer, title, sizeof(string_buffer)-1);
d307 1
a307 1
	    sleep(MessageSecs);
d322 1
a322 1
    StrAllocCopy(Title, string_buffer);
d344 3
a346 3
    CTRACE(tfp, "\nsave_bookmark_link: SEEKING %s\n   AS %s\n\n",
		BookmarkPage, filename_buffer);
    if ((fp = fopen(filename_buffer, (first_time ? "w" : "a+"))) == NULL) {
d348 1
a348 1
	sleep(AlertSecs);
d365 9
a373 1
	fprintf(fp,"<head>\n");
d375 1
d377 5
a381 1
	fprintf(fp, "%s<br>\n%s\n\n<!--\n%s\n-->\n\n<p>\n<ol>",
d394 1
d410 1
a410 1
    fclose(fp);
d420 3
a422 3
	    if (history[i].bookmark &&
		!strcmp(history[i].address, bookmark_URL)) {
		WWWDoc.address = history[i].address;
d425 1
a425 1
		WWWDoc.bookmark = history[i].bookmark;
d428 2
a429 4
		if (((tmpanchor = HTAnchor_parent(
					HTAnchor_findAddress(&WWWDoc)
						 )) != NULL) &&
		    (text = (HText *)HTAnchor_document(tmpanchor)) != NULL) {
d444 1
a444 1
    sleep(MessageSecs);
d464 1
d468 2
d472 2
d477 1
a477 1
    CTRACE(tfp, "remove_bookmark_link: deleting link number: %d\n", cur);
d484 3
a486 3
    CTRACE(tfp, "\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n",
		cur_bookmark_page, filename_buffer);
    if ((fp = fopen(filename_buffer, "r")) == NULL) {
d493 1
a493 1
	fclose(fp);
d503 1
d507 1
a507 1
	    (void) fclose(fp);
d526 1
a526 1
	char *cp;
d532 1
d536 3
d547 3
a549 1
		    CTRACE(tfp, "remove_bookmark_link: skipping link %d\n", n);
d559 3
a561 2
    CTRACE(tfp, "remove_bookmark_link: files: %s %s\n",
			newfile, filename_buffer);
d563 1
a563 1
    fclose(fp);
d565 4
d571 1
a571 1
#ifdef DOSPATH
d581 28
a608 5
     */
    if (LYCopyFile(newfile, filename_buffer) == 0)
	return;
    HTAlert(BOOKTEMP_COPY_FAIL);
#else  /* !UNIX */
d610 4
d623 4
a626 1
#ifdef _WINDOWS
d628 7
d636 1
a636 3
	if (errno == EXDEV)
#endif /* WINDOWS */
	{
d639 16
a654 5
	    HTAddParam(&buffer, MV_FMT, 1, MV_PATH);
	    HTAddParam(&buffer, MV_FMT, 2, newfile);
	    HTAddParam(&buffer, MV_FMT, 3, filename_buffer);
	    HTEndParam(&buffer, MV_FMT, 3);
	    LYSystem(buffer);
d656 2
a657 1
	    return;
d659 2
d671 1
a671 1
#endif /* UNIX */
d676 2
a677 1
    LYCloseTempFP(nfp);
d679 7
a685 2
	fclose(fp);
    LYRemoveTemp(newfile);
d698 1
a698 1
    if (LYMultiBookmarks == FALSE || LYHaveSubBookmarks() == FALSE) {
d710 1
a710 1
    if (LYMBMAdvanced && user_mode == ADVANCED_MODE) {
d717 1
a717 1
	    c = 7;
d720 1
a720 2
	if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) ||
	    c == 7 || c == 3) {
d731 1
a731 1
	    refresh();
d752 1
a752 2
		c = TOUPPER(c) - 'A';
		if (c < 0 || c > MBM_V_MAXFILES) {
d773 1
a773 1
    int c, MBM_tmp_count, MBM_allow;
d779 1
a779 1
    if (LYMultiBookmarks == FALSE)
a784 2
     *	LYMultiBookmarks - TRUE when multi_support enabled.
     *
d820 10
a829 28
draw_bookmark_choices:
    MBM_from = MBM_allow * MBM_current - MBM_allow;
    if (MBM_from < 0)
	MBM_from = 0; /* 0 is default bookmark... */
    if (MBM_current != 1)
	MBM_from++;

    MBM_to = (MBM_allow * MBM_current);
    if (MBM_to > MBM_V_MAXFILES)
	MBM_to = MBM_V_MAXFILES;

    /*
     *	Display menu of bookmarks.  NOTE that we avoid printw()'s
     *	to increase the chances that any non-ASCII or multibyte/CJK
     *	characters will be handled properly. - FM
     */
    clear();
    move(1, 5);
    lynx_start_h1_color ();
    if (MBM_screens > 1) {
	char *shead_buffer = 0;
	HTSprintf0(&shead_buffer,
		MULTIBOOKMARKS_SHEAD_MASK, MBM_current, MBM_screens);
	addstr(shead_buffer);
	FREE(shead_buffer);
    } else {
	addstr(MULTIBOOKMARKS_SHEAD);
    }
d831 17
a847 1
    lynx_stop_h1_color ();
d849 1
a849 14
    MBM_tmp_count = 0;
    for (c = MBM_from; c <= MBM_to; c++) {
	move(3+MBM_tmp_count, 5);
	addch((unsigned char)(c + 'A'));
	addstr(" : ");
	if (MBM_A_subdescript[c])
	    addstr(MBM_A_subdescript[c]);
	move(3+MBM_tmp_count,36);
	addch('(');
	if (MBM_A_subbookmark[c])
	    addstr(MBM_A_subbookmark[c]);
	addch(')');
	MBM_tmp_count++;
    }
d851 14
a864 28
    /*
     *	Don't need to show it if it all fits on one screen!
     */
    if (MBM_screens > 1) {
	move(LYlines-2, 0);
	addstr("'");
	standout();
	addstr("[");
	standend();
	addstr("' ");
	addstr(PREVIOUS);
	addstr(", '");
	standout();
	addstr("]");
	standend();
	addstr("' ");
	addstr(NEXT_SCREEN);
    }

    LYMBM_statusline(MULTIBOOKMARKS_SAVE);
get_bookmark_choice:
    c = LYgetch();
#ifdef VMS
    if (HadVMSInterrupt) {
	HadVMSInterrupt = FALSE;
	c = 7;
    }
#endif /* VMS */
a865 2
    if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) ||
	c == 7 || c == 3) {
d867 1
a867 1
	 *  Treat left-arrow, ^G, or ^C as cancel.
d869 15
a883 2
	return(-2);
    }
d885 1
a885 8
    if (LYisNonAlnumKeyname(c, LYK_REFRESH)) {
	/*
	 *  Refresh the screen.
	 */
	lynx_force_repaint();
	refresh();
	goto get_bookmark_choice;
    }
d887 8
a894 6
    if (LYisNonAlnumKeyname(c, LYK_ACTIVATE)) {
	/*
	 *  Assume default bookmark file on ENTER or right-arrow.
	 */
	return(MBM_A_subbookmark[0] ? 0 : -1);
    }
d896 6
a901 9
    /*
     *	Next range, if available.
     */
    if ((c == ']' ||  LYisNonAlnumKeyname(c, LYK_NEXT_PAGE)) &&
	MBM_screens > 1) {
	if (++MBM_current > MBM_screens)
	    MBM_current = 1;
	goto draw_bookmark_choices;
    }
d903 28
a930 9
    /*
     *	Previous range, if available.
     */
    if ((c == '[' ||  LYisNonAlnumKeyname(c, LYK_PREV_PAGE)) &&
	MBM_screens > 1) {
	if (--MBM_current <= 0)
	    MBM_current = MBM_screens;
	goto draw_bookmark_choices;
    }
d932 10
a941 12
    c = TOUPPER(c) - 'A';
    /*
     *	See if we have a bookmark like that.
     */
    if (c < 0 || c > MBM_V_MAXFILES) {
	goto get_bookmark_choice;
    } else if (!MBM_A_subbookmark[c]) {
	show_bookmark_not_defined();
	LYMBM_statusline(MULTIBOOKMARKS_SAVE);
	goto get_bookmark_choice;
    } else {
	return(c);
d965 1
a965 1
 *  is TRUE, otherwise, letting it go to the normal statusline
d973 1
a973 1
    if (LYMultiBookmarks == TRUE && user_mode == NOVICE_MODE) {
d992 1
a992 1
	c = (unsigned char)(TOASCII(*p));
d1019 1
a1019 1
	if ((unsigned char)*p > 127)
d1058 1
a1058 1
	if ((unsigned char)*temp <= 127) {
d1083 1
a1083 1
	if ((unsigned char)(TOASCII(*p0)) >= 32 &&
d1102 18
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a2 1
#include <HTFile.h>
d9 1
a9 1
#include <LYCharUtils.h>	/* need for META charset */
d11 1
a11 1
#include <LYCharSets.h>		/* need for LYHaveCJKCharacterSet */
a13 1
#include <HTCJK.h>
d21 2
a22 2
char *MBM_A_subbookmark[MBM_V_MAXFILES + 1];
char *MBM_A_subdescript[MBM_V_MAXFILES + 1];
d24 2
a25 2
static BOOLEAN is_mosaic_hotlist = FALSE;
static const char *convert_mosaic_bookmark_file(const char *filename_buffer);
d27 2
a28 21
int LYindex2MBM(int n)
{
    static char MBMcodes[MBM_V_MAXFILES + 2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    return n >= 0 && n <= MBM_V_MAXFILES ? MBMcodes[n] : '?';
}

int LYMBM2index(int ch)
{
    if ((ch = TOUPPER(ch)) > 0) {
	const char *letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const char *result = strchr(letters, ch);

	if (result != 0
	    && (result - letters) <= MBM_V_MAXFILES)
	    return (result - letters);
    }
    return -1;
}

static void show_bookmark_not_defined(void)
d33 2
a34 2
	       BOOKMARK_FILE_NOT_DEFINED,
	       key_for_func(LYK_OPTIONS));
d40 11
a50 9
 * Tries to open a bookmark file for reading, which may be the default, or
 * based on offering the user a choice from the MBM_A_subbookmark[] array.  If
 * successful the file is closed, and the filename in system path specs is
 * returned, the URL is allocated into *URL, and the MBM_A_subbookmark[]
 * filepath is allocated into the BookmarkPage global.  Returns a zero-length
 * pointer to flag a cancel, or a space to flag an undefined selection, without
 * allocating into *URL or BookmarkPage.  Returns NULL with allocating into
 * BookmarkPage but not *URL is the selection is valid but the file doesn't yet
 * exist.  - FM
d52 2
a53 1
const char *get_bookmark_filename(char **URL)
d61 2
a62 2
     * Multi_Bookmarks support.  - FMG & FM
     * Let user select a bookmark file.
d67 1
a67 1
	 * Zero-length pointer flags a cancel.  - FM
d69 1
a69 1
	return ("");
d73 1
a73 1
	 * Space flags an undefined selection.  - FMG
d75 1
a75 1
	return (" ");
d78 6
a83 5
	 * Save the filepath as a global.  The system path will be loaded into
	 * to the (static) filename_buffer as the return value, the URL will be
	 * allocated into *URL, and we also need the filepath available to
	 * calling functions.  This is all pitifully non-reentrant, a la the
	 * original Lynx, and should be redesigned someday.  - FM
d89 1
a89 1
     * Seek it in the home path.  - FM
d94 19
a112 3
    CTRACE((tfp, "\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n",
	    BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) != NULL) {
d114 1
a114 2
	 * We now have the file open.
	 * Check if it is a mosaic hotlist.
d116 9
a124 4
	if (LYSafeGets(&string_buffer, fp) != 0
	    && *LYTrimNewline(string_buffer) != '\0'
	    && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 29)) {
	    const char *newname;
d126 1
a126 16
	    /*
	     * It is a mosaic hotlist file.
	     */
	    is_mosaic_hotlist = TRUE;
	    newname = convert_mosaic_bookmark_file(filename_buffer);
	    LYLocalFileToURL(URL, newname);
	} else {
	    is_mosaic_hotlist = FALSE;
	    LYLocalFileToURL(URL, filename_buffer);
	}
	FREE(string_buffer);
	LYCloseInput(fp);

	return (filename_buffer);	/* bookmark file exists */
    }
    return (NULL);
d128 1
a128 1
}				/* big end */
d131 2
a132 2
 * Converts a Mosaic hotlist file into an HTML file for handling as a Lynx
 * bookmark file.  - FM
d134 2
a135 1
static const char *convert_mosaic_bookmark_file(const char *filename_buffer)
d141 1
d146 1
a146 1
	LYSleepAlert();
d150 2
a151 2
    if ((fp = fopen(filename_buffer, TXT_R)) == NULL)
	return ("");		/* should always open */
d153 1
a153 1
    fprintf(nfp, "<head>\n<title>%s</title>\n</head>\n", MOSAIC_BOOKMARK_TITLE);
d161 8
a168 6
	if (line >= 0) {
	    LYTrimNewline(buf);
	    if ((line % 2) == 0) {	/* even lines */
		if (*buf != '\0') {
		    strtok(buf, " ");	/* kill everything after the space */
		    fprintf(nfp, "<LI><a href=\"%s\">", buf);	/* the URL */
d170 2
a171 2
	    } else {		/* odd lines */
		fprintf(nfp, "%s</a>\n", buf);	/* the title */
d178 2
a179 2
    LYCloseInput(fp);
    return (newfile);
d182 3
a184 3
static BOOLEAN havevisible(const char *Title);
static BOOLEAN have8bit(const char *Title);
static char *title_convert8bit(const char *Title);
d187 5
a191 3
 * Adds a link to a bookmark file, creating the file if it doesn't already
 * exist, and making sure that no_cache is set for a pre-existing, cached file,
 * so that the change will be evident on return to to that file.  - FM
d193 3
a195 2
void save_bookmark_link(const char *address,
			const char *title)
d199 1
a199 1
    const char *filename;
a202 1
    char tmp_buffer[BUFSIZ];
d211 1
a211 1
     * Make sure we were passed something to save.  - FM
d213 1
a213 1
    if (isEmpty(address)) {
d219 2
a220 1
     * Offer a choice of bookmark files, or get the default.  - FMG
d225 6
a230 4
     * If filename is NULL, must create a new file.  If filename is a space, an
     * invalid bookmark file was selected, or if zero-length, the user
     * cancelled.  Ignore request in both cases.  Otherwise, make a copy before
     * anything might change the static get_bookmark_filename() buffer.  - FM
d236 1
a236 1
	if (*filename == '\0' || !strcmp(filename, " ")) {
d240 1
a240 1
	LYstrncpy(filename_buffer, filename, sizeof(filename_buffer) - 1);
d244 2
a245 2
     * If BookmarkPage is NULL, something went wrong, so ignore the request.  -
     * FM
d253 2
a254 2
     * If the link will be added to the same bookmark file, get confirmation. 
     * - FM
d256 9
a264 13
    if (LYMultiBookmarks != MBM_OFF) {
	const char *url = HTLoadedDocumentURL();
	const char *page = (*BookmarkPage == '.')
	? (BookmarkPage + 1)
	: BookmarkPage;

	if (strstr(url, page) != NULL) {
	    LYMBM_statusline(MULTIBOOKMARKS_SELF);
	    c = LYgetch_single();
	    if (c != 'L') {
		FREE(bookmark_URL);
		return;
	    }
d269 1
a269 1
     * Allow user to change the title.  - FM
d272 2
a273 16
	if (HTCJK == JAPANESE) {
	    switch (kanji_code) {
	    case EUC:
		TO_EUC((const unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    case SJIS:
		TO_SJIS((const unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    default:
		break;
	    }
	    LYstrncpy(string_buffer, tmp_buffer, sizeof(string_buffer) - 1);
	} else {
	    LYstrncpy(string_buffer, title, sizeof(string_buffer) - 1);
	}
	LYReduceBlanks(string_buffer);
d278 1
a278 1
	    LYSleepMsg();
d282 1
a282 1
    } while (!havevisible(string_buffer));
d285 3
a287 2
     * Create the Title with any left-angle-brackets converted to &lt; entities
     * and any ampersands converted to &amp; entities.  - FM
d289 3
a291 3
     * Convert 8-bit letters to &#xUUUU to avoid dependencies from display
     * character set which may need changing.  Do NOT convert any 8-bit chars
     * if we have CJK display.  - LP
d293 1
a293 1
    LYformTitle(&Title, string_buffer);
a297 1

d303 2
a304 2
     * Create the bookmark file, if it doesn't exist already, Otherwise, open
     * the pre-existing bookmark file.  - FM
d309 1
a309 1
	 * Seek it in the home path.  - FM
d315 3
a317 3
    CTRACE((tfp, "\nsave_bookmark_link: SEEKING %s\n   AS %s\n\n",
	    BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, (first_time ? TXT_W : TXT_A))) == NULL) {
d319 1
a319 1
	LYSleepAlert();
d326 1
a326 1
     * Convert all ampersands in the address to &amp; entities.  - FM
d332 2
a333 2
     * If we created a new bookmark file, write the headers.  - FM
     * Once and forever...
d336 1
a336 9
	fprintf(fp, "<head>\n");
#if defined(SH_EX) && !defined(_WINDOWS)	/* 1997/12/11 (Thu) 19:13:40 */
	if (HTCJK != JAPANESE)
	    LYAddMETAcharsetToFD(fp, -1);
	else
	    fprintf(fp, "<META %s %s>\n",
		    "http-equiv=\"content-type\"",
		    "content=\"text/html;charset=iso-2022-jp\"");
#else
d338 3
a340 8
#endif /* !_WINDOWS */
	fprintf(fp, "<title>%s</title>\n</head>\n", BOOKMARK_TITLE);
#ifdef _WINDOWS
	fprintf(fp,
		gettext("     You can delete links by the 'R' key<br>\n<ol>\n"));
#else
	fprintf(fp, "%s<br>\n%s\n\n<!--\n%s\n-->\n\n<p>\n<ol>\n",
		gettext("\
d344 1
a344 1
		gettext("\
d347 1
a347 1
		gettext("\
a351 1
#endif /* _WINDOWS */
d355 1
a355 1
     * Add the bookmark link, in Mosaic hotlist or Lynx format.  - FM
d359 1
a359 2
	char *TimeString = (char *) ctime(&NowTime);

d361 1
a361 1
	 * TimeString has a \n at the end.
d363 1
a363 1
	fprintf(fp, "%s %s%s\n", Address, TimeString, Title);
d365 1
a365 1
	fprintf(fp, "<LI><a href=\"%s\">%s</a>\n", Address, Title);
d367 1
a367 1
    LYCloseOutput(fp);
d371 3
a373 2
     * If this is a cached bookmark file, set nocache for it so we'll see the
     * new bookmark link when that cache is retrieved.  - FM
d377 3
a379 3
	    if (HDOC(i).bookmark &&
		!strcmp(HDOC(i).address, bookmark_URL)) {
		WWWDoc.address = HDOC(i).address;
d382 1
a382 1
		WWWDoc.bookmark = HDOC(i).bookmark;
d385 4
a388 2
		tmpanchor = HTAnchor_findAddress(&WWWDoc);
		if ((text = (HText *) HTAnchor_document(tmpanchor)) != NULL) {
d397 1
a397 1
     * Clean up and report success.
d403 1
a403 1
    LYSleepMsg();
d407 5
a411 4
 * Remove a link from a bookmark file.  The calling function is expected to
 * have used get_filename_link(), pass us the link number as cur, the
 * MBM_A_subbookmark[] string as cur_bookmark_page, and to have set up no_cache
 * itself.  - FM
d413 3
a415 2
void remove_bookmark_link(int cur,
			  char *cur_bookmark_page)
a419 1

d421 2
a422 4
    char filename_buffer[NAM$C_MAXRSS + 12];
    char newfile[NAM$C_MAXRSS + 12];

#define keep_tempfile FALSE
a425 3
    BOOLEAN keep_tempfile = FALSE;

#ifdef UNIX
a427 2
    BOOLEAN regular = FALSE;
#endif /* UNIX */
d431 1
a431 1
    CTRACE((tfp, "remove_bookmark_link: deleting link number: %d\n", cur));
d438 3
a440 3
    CTRACE((tfp, "\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n",
	    cur_bookmark_page, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) == NULL) {
d447 1
a447 1
	LYCloseInput(fp);
d451 1
d454 1
a454 1
     * Explicitly preserve bookmark file mode on Unix.  - DSL
d457 1
a457 2
	regular = (S_ISREG(stat_buf.st_mode) && stat_buf.st_nlink == 1);
	mode = ((stat_buf.st_mode & 0777) | 0600);	/* make it writable */
d460 1
a460 1
	    (void) LYCloseInput(fp);
d468 2
a469 3
	int del_line = cur * 2;	/* two lines per entry */

	n = -3;			/* skip past cookie and name lines */
d472 2
a473 2
	    if (n == del_line || n == del_line + 1)
		continue;	/* remove two lines */
d479 1
a479 1
	char *cp, *cp2;
a484 2
	    int keep_ol = FALSE;

a487 3
	    if ((cur == 0) && (cp2 = LYstrstr(cp, "<ol><LI>")))
		keep_ol = TRUE;	/* Do not erase, this corrects a bug in an
				   older version */
d496 1
a496 3
		    CTRACE((tfp, "remove_bookmark_link: skipping link %d\n", n));
		    if (keep_ol)
			fprintf(nfp, "<ol>\n");
d506 2
a507 3
    FREE(buf);
    CTRACE((tfp, "remove_bookmark_link: files: %s %s\n",
	    newfile, filename_buffer));
d509 1
a509 1
    LYCloseInput(fp);
a510 4
    if (fflush(nfp) == EOF) {
	CTRACE((tfp, "fflush(nfp): %s", LYStrerror(errno)));
	goto failure;
    }
d513 1
a513 1
#if defined(DOSPATH) || defined(__EMX__)
d519 9
a527 36
     * By copying onto the bookmark file, rather than renaming it, we can
     * preserve the original ownership of the file, provided that it is
     * writable by the current process.
     *
     * Changed to copy 1998-04-26 -- gil
     *
     * But if the copy fails, for example because the filesystem is full, we
     * are left with a corrupt bookmark file.  Changed back to use the previous
     * mechanism [try rename(), then mv for EXDEV], except in usual cases (not
     * a regular file e.g., symbolic link, or has hard links).  This will let
     * bookmarks survive a filesystem full condition in the "normal" case
     * (bookmark is on same filesystem as home directory, is a regular file,
     * has no additional hard links).
     *
     * If we first tried LYCopyFile, and that fails, also fall back to trying
     * the other stuff.  That gives a chance to recover in case the LYCopyFile
     * left a corrupt target file.
     *
     * If there is an error, and that error may mean that the bookmark file has
     * been corrupted, don't remove the temporary newfile (which should always
     * be uncorrupted) in place, it may still be used to recover manually.  If
     * this applies, produce an additional message to that effect.  The temp
     * file will still be removed by normal program exit cleanup.  - kw
     * 1999-11-12
     */
    if (!regular) {
	if (LYCopyFile(newfile, filename_buffer) == 0) {
	    LYRemoveTemp(newfile);
	    return;
	}
	LYSleepAlert();		/* give a chance to see error from cp - kw */
	HTUserMsg(BOOKTEMP_COPY_FAIL);
	keep_tempfile = TRUE;
    }
#endif /* UNIX */

a528 4
#ifdef MULTI_USER_UNIX
	if (regular)
	    chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif
d534 3
a536 2
	 * Rename won't work across file systems.  Check if this is the case
	 * and do something appropriate.  Used to be ODD_RENAME
d538 1
a538 4
#if defined(_WINDOWS) || defined(WIN_EX)
#if defined(WIN_EX)
	if (GetLastError() == ERROR_NOT_SAME_DEVICE)
#else /* !_WIN_EX */
d540 3
a542 1
#endif /* _WIN_EX */
d544 1
a544 8
	    if (rename(newfile, filename_buffer) != 0) {
		if (LYCopyFile(newfile, filename_buffer) == 0)
		    remove(newfile);
	    }
	}
#else
	if (errno == EXDEV) {
	    static const char MV_FMT[] = "%s %s %s";
d546 5
a550 16
	    const char *program;

	    if ((program = HTGetProgramPath(ppMV)) != NULL) {
		HTAddParam(&buffer, MV_FMT, 1, program);
		HTAddParam(&buffer, MV_FMT, 2, newfile);
		HTAddParam(&buffer, MV_FMT, 3, filename_buffer);
		HTEndParam(&buffer, MV_FMT, 3);
		if (LYSystem(buffer) == 0) {
#ifdef MULTI_USER_UNIX
		    if (regular)
			chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif
		    FREE(buffer);
		    return;
		}
	    }
d552 1
a552 2
	    keep_tempfile = TRUE;
	    goto failure;
a553 2
	CTRACE((tfp, "rename(): %s", LYStrerror(errno)));
#endif /* _WINDOWS */
d564 1
d566 1
a566 1
  failure:
d569 1
a569 2
    if (nfp)
	LYCloseTempFP(nfp);
d571 2
a572 7
	LYCloseInput(fp);
    if (keep_tempfile) {
	HTUserMsg2(gettext("File may be recoverable from %s during this session"),
		   newfile);
    } else {
	LYRemoveTemp(newfile);
    }
d576 1
a576 1
 * Allows user to select sub-bookmarks files.  - FMG & FM
d578 1
a578 1
int select_multi_bookmarks(void)
d583 1
a583 1
     * If not enabled, pick the "default" (0).
d585 3
a587 3
    if (LYMultiBookmarks == MBM_OFF || LYHaveSubBookmarks() == FALSE) {
	if (MBM_A_subbookmark[0])	/* If it exists! */
	    return (0);
d589 1
a589 1
	    return (-1);
d593 3
a595 3
     * For ADVANCED users, we can just mess with the status line to save the 2
     * redraws of the screen, if LYMBMAdvnced is TRUE.  '=' will still show the
     * screen and let them do it the "long" way.
d597 1
a597 1
    if (LYMultiBookmarks == MBM_ADVANCED && user_mode == ADVANCED_MODE) {
d599 1
a599 1
      get_advanced_choice:
d604 1
a604 1
	    c = LYCharINTERRUPT2;
d607 2
a608 1
	if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) || LYCharIsINTERRUPT_HARD(c)) {
d610 1
a610 1
	     * Treat left-arrow, ^G, or ^C as cancel.
d612 1
a612 1
	    return (-2);
d616 1
a616 1
	     * Refresh the screen.
d619 1
a619 1
	    LYrefresh();
d624 1
a624 1
	     * Assume default bookmark file on ENTER or right-arrow.
d629 5
a633 5
	case '=':
	    /*
	     * Get the choice via the menu.
	     */
	    return (select_menu_multi_bookmarks());
d635 9
a643 8
	default:
	    /*
	     * Convert to an array index, act on it if valid.
	     * Otherwise, get another keystroke.
	     */
	    if ((c = LYMBM2index(c)) < 0) {
		goto get_advanced_choice;
	    }
d646 1
a646 1
	 * See if we have a bookmark like that.
d651 1
a651 1
	 * Get the choice via the menu.
d653 1
a653 1
	return (select_menu_multi_bookmarks());
d658 1
a658 1
 * Allows user to select sub-bookmarks files.  - FMG & FM
d660 1
a660 1
int select_menu_multi_bookmarks(void)
d662 1
a662 1
    int c, d, MBM_tmp_count, MBM_allow;
d666 1
a666 1
     * If not enabled, pick the "default" (0).
d668 2
a669 2
    if (LYMultiBookmarks == MBM_OFF)
	return (0);
d672 3
a674 4
     *        Filip M. Gieszczykiewicz (filipg@@paranoia.com) & FM
     *  ---------------------------------------------------
     * MBM_A_subbookmark[n] - Hold values of the respective "multi_bookmarkn"
     * in the lynxrc file.
d676 2
a677 1
     * MBM_A_subdescript[n] - Hold description entries in the lynxrc file.
d679 2
a680 3
     * Note: MBM_A_subbookmark[0] is defined to be same value as
     *       "bookmark_file" in the lynxrc file and/or the startup
     *       "bookmark_page".
d682 3
a684 1
     * We make the display of bookmarks depend on rows we have available.
d686 8
a693 4
     * We load BookmarkPage with the valid MBM_A_subbookmark[n] via
     * get_bookmark_filename().  Otherwise, that function returns a zero-length
     * string to indicate a cancel, a single space to indicate an invalid
     * choice, or NULL to indicate an inaccessible file.
d695 1
a695 1
    MBM_allow = (LYlines - 7);	/* We need 7 for header and footer */
d697 1
a697 1
     * Screen big enough?
d701 1
a701 1
	 * Too small.
d707 1
a707 1
    MBM_screens = (MBM_V_MAXFILES / MBM_allow) + 1;	/* int rounds off low. */
d709 1
a709 1
    MBM_current = 1;		/* Gotta start somewhere :-) */
d711 28
a738 10
    for (;;) {
	MBM_from = MBM_allow * MBM_current - MBM_allow;
	if (MBM_from < 0)
	    MBM_from = 0;	/* 0 is default bookmark... */
	if (MBM_current != 1)
	    MBM_from++;

	MBM_to = (MBM_allow * MBM_current);
	if (MBM_to > MBM_V_MAXFILES)
	    MBM_to = MBM_V_MAXFILES;
d740 1
a740 18
	/*
	 * Display menu of bookmarks.  NOTE that we avoid printw()'s to
	 * increase the chances that any non-ASCII or multibyte/CJK characters
	 * will be handled properly.  - FM
	 */
	LYclear();
	LYmove(1, 5);
	lynx_start_h1_color();
	if (MBM_screens > 1) {
	    char *shead_buffer = 0;

	    HTSprintf0(&shead_buffer,
		       MULTIBOOKMARKS_SHEAD_MASK, MBM_current, MBM_screens);
	    LYaddstr(shead_buffer);
	    FREE(shead_buffer);
	} else {
	    LYaddstr(MULTIBOOKMARKS_SHEAD);
	}
d742 14
a755 1
	lynx_stop_h1_color();
d757 28
a784 14
	MBM_tmp_count = 0;
	for (c = MBM_from; c <= MBM_to; c++) {
	    LYmove(3 + MBM_tmp_count, 5);
	    LYaddch(LYindex2MBM(c));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[c])
		LYaddstr(MBM_A_subdescript[c]);
	    LYmove(3 + MBM_tmp_count, 36);
	    LYaddch('(');
	    if (MBM_A_subbookmark[c])
		LYaddstr(MBM_A_subbookmark[c]);
	    LYaddch(')');
	    MBM_tmp_count++;
	}
d786 2
d789 1
a789 1
	 * Don't need to show it if it all fits on one screen!
d791 2
a792 15
	if (MBM_screens > 1) {
	    LYmove(LYlines - 2, 0);
	    LYaddstr("'");
	    lynx_start_bold();
	    LYaddstr("[");
	    lynx_stop_bold();
	    LYaddstr("' ");
	    LYaddstr(PREVIOUS);
	    LYaddstr(", '");
	    lynx_start_bold();
	    LYaddstr("]");
	    lynx_stop_bold();
	    LYaddstr("' ");
	    LYaddstr(NEXT_SCREEN);
	}
d794 8
a801 1
	LYMBM_statusline(MULTIBOOKMARKS_SAVE);
d803 6
a808 8
	for (;;) {
	    c = LYgetch();
#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = 7;
	    }
#endif /* VMS */
d810 9
a818 6
	    if ((d = LYMBM2index(c)) >= 0) {
		/*
		 * See if we have a bookmark like that.
		 */
		if (MBM_A_subbookmark[d] != NULL)
		    return (d);
d820 9
a828 28
		show_bookmark_not_defined();
		LYMBM_statusline(MULTIBOOKMARKS_SAVE);
	    } else if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) ||
		       c == 7 || c == 3) {
		/*
		 * Treat left-arrow, ^G, or ^C as cancel.
		 */
		return (-2);
	    } else if (LYisNonAlnumKeyname(c, LYK_REFRESH)) {
		/*
		 * Refresh the screen.
		 */
		lynx_force_repaint();
		LYrefresh();
	    } else if (LYisNonAlnumKeyname(c, LYK_ACTIVATE)) {
		/*
		 * Assume default bookmark file on ENTER or right-arrow.
		 */
		return (MBM_A_subbookmark[0] ? 0 : -1);
	    } else if ((c == ']' || LYisNonAlnumKeyname(c, LYK_NEXT_PAGE)) &&
		       MBM_screens > 1) {
		/*
		 * Next range, if available.
		 */
		if (++MBM_current > MBM_screens)
		    MBM_current = 1;
		break;
	    }
d830 12
a841 10
	    else if ((c == '[' || LYisNonAlnumKeyname(c, LYK_PREV_PAGE)) &&
		     MBM_screens > 1) {
		/*
		 * Previous range, if available.
		 */
		if (--MBM_current <= 0)
		    MBM_current = MBM_screens;
		break;
	    }
	}
d846 3
a848 2
 * This function returns TRUE if we have sub-bookmarks defined.  Otherwise
 * (i.e., only the default bookmark file is defined), it returns FALSE.  - FM
d850 1
a850 1
BOOLEAN LYHaveSubBookmarks(void)
d855 2
a856 2
	if (non_empty(MBM_A_subbookmark[i]))
	    return (TRUE);
d859 1
a859 1
    return (FALSE);
d863 6
a868 5
 * This function passes a string to _statusline(), making sure it is at the
 * bottom of the screen if LYMultiBookmarks is not MBM_OFF, otherwise, letting
 * it go to the normal statusline position based on the current user mode.  We
 * want to use _statusline() so that any multibyte/CJK characters in the string
 * will be handled properly.  - FM
d870 2
a871 1
void LYMBM_statusline(const char *text)
d873 1
a873 1
    if (LYMultiBookmarks != MBM_OFF && user_mode == NOVICE_MODE) {
d885 1
a885 1
static BOOLEAN havevisible(const char *Title)
d887 1
a887 1
    const char *p = Title;
d891 2
a892 2
    for (; *p; p++) {
	c = UCH(TOASCII(*p));
d894 1
a894 1
	    return (TRUE);
d898 1
a898 1
	    return (TRUE);
d901 1
a901 1
	    return (TRUE);
d906 1
a906 1
	return (TRUE);
d908 1
a908 1
    return (FALSE);		/* if we came here */
d914 1
a914 1
static BOOLEAN have8bit(const char *Title)
d916 1
a916 1
    const char *p = Title;
d918 3
a920 3
    for (; *p; p++) {
	if (UCH(*p) > 127)
	    return (TRUE);
d922 1
a922 1
    return (FALSE);		/* if we came here */
d926 5
a930 5
 * Ok, title have 8-bit characters and they are in display charset.  Bookmarks
 * is a permanent file.  To avoid dependencies from display character set which
 * may be changed with time we store 8-bit characters as numeric character
 * reference (NCR), so where the character encoded as unicode number in form of
 * &#xUUUU;
d932 3
a934 3
 * To make bookmarks more readable for human (&#xUUUU certainly not) we add a
 * comment with '7-bit approximation' from the converted string.  This is a
 * valid HTML and bookmarks code.
d936 6
a941 2
 * We do not want use META charset tag in bookmarks file:  it will never be
 * changed later :-(
a942 2
 * NCR's translation is part of I18N and HTML4.0 supported starting with Lynx
 * 2.7.2, Netscape 4.0 and MSIE 4.0.  Older versions fail.
d944 1
a944 1
static char *title_convert8bit(const char *Title)
d946 1
a946 1
    const char *p = Title;
d950 1
a950 1
    char *ncr = NULL;
d952 1
a952 1
    int charset_in = current_char_set;
d955 1
a955 1
    for (; *p; p++) {
d957 2
a958 3

	LYstrncpy(temp, p, sizeof(temp) - 1);
	if (UCH(*temp) <= 127) {
d963 1
a963 1
	    char replace_buf[32];
d966 1
a966 1
			       charset_in, charset_out, YES) > 0)
d969 1
a969 1
	    unicode = UCTransToUni(*temp, charset_in);
d979 2
a980 1
     * Cleanup comment, collapse multiple dashes into one dash, skip '>'.
d983 1
a983 1
	if (UCH(TOASCII(*p0)) >= 32 &&
d985 1
a985 1
	    (q == comment || *p0 != '-' || *(q - 1) != '-')) {
d1001 1
a1001 18
    return (buf);
}

/*
 * Since this is the "Default Bookmark File", we save it as a global, and as
 * the first MBM_A_subbookmark entry.
 */
void set_default_bookmark_page(char *value)
{
    if (value != 0) {
	if (bookmark_page == 0
	    || strcmp(bookmark_page, value)) {
	    StrAllocCopy(bookmark_page, value);
	}
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
    }
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a2 1
#include <HTFile.h>
a13 1
#include <HTCJK.h>
a26 18
PUBLIC int LYindex2MBM ARGS1(int, n)
{
    static char MBMcodes[MBM_V_MAXFILES+2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return n >= 0 && n <= MBM_V_MAXFILES ? MBMcodes[n] : '?';
}

PUBLIC int LYMBM2index ARGS1(int, ch)
{
    if ((ch = TOUPPER(ch)) > 0) {
	char *letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	char *result = strchr(letters, ch);
	if (result != 0
	 && (result - letters) <= MBM_V_MAXFILES)
	    return (result - letters);
    }
    return -1;
}

d94 19
a112 3
    CTRACE((tfp, "\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n",
		BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) != NULL) {
d114 1
a114 2
	 * We now have the file open.
	 * Check if it is a mosaic hotlist.
d116 9
a124 16
	if (LYSafeGets(&string_buffer, fp) != 0
	 && *LYTrimNewline(string_buffer) != '\0'
	 && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 29)) {
	    char *newname;
	    /*
	     *  It is a mosaic hotlist file.
	     */
	    is_mosaic_hotlist = TRUE;
	    newname = convert_mosaic_bookmark_file(filename_buffer);
	    LYLocalFileToURL(URL, newname);
	} else {
	    is_mosaic_hotlist = FALSE;
	    LYLocalFileToURL(URL, filename_buffer);
	}
	FREE(string_buffer);
	LYCloseInput(fp);
d126 1
a126 3
	return(filename_buffer);  /* bookmark file exists */
    }
    return(NULL);
d141 1
d146 1
a146 1
	LYSleepAlert();
d150 1
a150 1
    if ((fp = fopen(filename_buffer, TXT_R)) == NULL)
d161 5
a165 3
	if (line >= 0) {
	    LYTrimNewline(buf);
	    if ((line % 2) == 0) { /* even lines */
d178 1
a178 1
    LYCloseInput(fp);
a202 1
    char tmp_buffer[BUFSIZ];
d240 1
a240 1
	LYstrncpy(filename_buffer, filename, sizeof(filename_buffer)-1);
d256 9
a264 12
    if (LYMultiBookmarks != MBM_OFF) {
	CONST char *url = HTLoadedDocumentURL();
	CONST char *page = (*BookmarkPage == '.')
			    ? (BookmarkPage + 1)
			    : BookmarkPage;
	if (strstr(url, page) != NULL) {
	    LYMBM_statusline(MULTIBOOKMARKS_SELF);
	    c = LYgetch_single();
	    if (c != 'L') {
		FREE(bookmark_URL);
		return;
	    }
d272 1
a272 15
	if (HTCJK == JAPANESE) {
	    switch(kanji_code) {
	    case EUC:
		TO_EUC((CONST unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    case SJIS:
		TO_SJIS((CONST unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    default:
		break;
	    }
	    LYstrncpy(string_buffer, tmp_buffer, sizeof(string_buffer)-1);
	} else {
	    LYstrncpy(string_buffer, title, sizeof(string_buffer)-1);
	}
d278 1
a278 1
	    LYSleepMsg();
d293 1
a293 1
    LYformTitle(&Title, string_buffer);
d315 3
a317 3
    CTRACE((tfp, "\nsave_bookmark_link: SEEKING %s\n   AS %s\n\n",
		BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, (first_time ? TXT_W : TXT_A))) == NULL) {
d319 1
a319 1
	LYSleepAlert();
d336 1
a336 9
	fprintf(fp, "<head>\n");
#if defined(SH_EX) && !defined(_WINDOWS)	/* 1997/12/11 (Thu) 19:13:40 */
	if (HTCJK != JAPANESE)
	    LYAddMETAcharsetToFD(fp, -1);
	else
	    fprintf(fp, "<META %s %s>\n",
		    "http-equiv=\"content-type\"",
		    "content=\"text/html;charset=iso-2022-jp\"");
#else
a337 1
#endif	/* !_WINDOWS */
d339 1
a339 5
#ifdef _WINDOWS
	fprintf(fp,
	    gettext("     You can delete links by the 'R' key<br>\n<ol>\n"));
#else
	fprintf(fp, "%s<br>\n%s\n\n<!--\n%s\n-->\n\n<p>\n<ol>\n",
a351 1
#endif	/* _WINDOWS */
d367 1
a367 1
    LYCloseOutput(fp);
d377 3
a379 3
	    if (HDOC(i).bookmark &&
		!strcmp(HDOC(i).address, bookmark_URL)) {
		WWWDoc.address = HDOC(i).address;
d382 1
a382 1
		WWWDoc.bookmark = HDOC(i).bookmark;
d385 4
a388 2
		tmpanchor = HTAnchor_findAddress(&WWWDoc);
		if ((text = (HText *)HTAnchor_document(tmpanchor)) != NULL) {
d403 1
a403 1
    LYSleepMsg();
a422 1
#define keep_tempfile FALSE
a425 2
    BOOLEAN keep_tempfile = FALSE;
#ifdef UNIX
a427 2
    BOOLEAN regular = FALSE;
#endif /* UNIX */
d431 1
a431 1
    CTRACE((tfp, "remove_bookmark_link: deleting link number: %d\n", cur));
d438 3
a440 3
    CTRACE((tfp, "\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n",
		cur_bookmark_page, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) == NULL) {
d447 1
a447 1
	LYCloseInput(fp);
a456 1
	regular = (S_ISREG(stat_buf.st_mode) && stat_buf.st_nlink == 1);
d460 1
a460 1
	    (void) LYCloseInput(fp);
d479 1
a479 1
	char *cp, *cp2;
a484 1
	    int keep_ol = FALSE;
a487 3
	    if ((cur == 0) && (cp2 = LYstrstr(cp,"<ol><LI>")))
		keep_ol = TRUE; /* Do not erase, this corrects a bug in an
				   older version */
d496 1
a496 3
		    CTRACE((tfp, "remove_bookmark_link: skipping link %d\n", n));
		    if (keep_ol)
			fprintf(nfp,"<ol>\n");
d506 2
a507 3
    FREE(buf);
    CTRACE((tfp, "remove_bookmark_link: files: %s %s\n",
			newfile, filename_buffer));
d509 1
a509 1
    LYCloseInput(fp);
a510 4
    if (fflush(nfp) == EOF) {
	CTRACE((tfp, "fflush(nfp): %s", LYStrerror(errno)));
	goto failure;
    }
d513 1
a513 1
#if defined(DOSPATH) || defined(__EMX__)
d523 5
a527 28
     *  But if the copy fails, for example because the filesystem is full,
     *  we are left with a corrupt bookmark file.  Changed back to use
     *  the previous mechanism [try rename(), then mv for EXDEV], except
     *  in usual cases (not a regular file e.g., symbolic link, or has hard
     *  links).  This will let bookmarks survive a filesystem full condition
     *  in the "normal" case (bookmark is on same filesystem as home directory,
     *  is a regular file, has no additional hard links).
     *  If we first tried LYCopyFile, and that fails, also fall back to trying
     *  the other stuff.  That gives a chance to recover in case the LYCopyFile
     *  left a corrupt target file.
     *  If there is an error, and that error may mean that the bookmark file
     *  has been corrupted, don't remove the temporary newfile (which should
     *  always be uncorrupted) in place, it may still be used to recover
     *  manually.  If this applies, produce an additional message to that
     *  effect.  The temp file will still be removed by normal program exit
     *  cleanup. - kw 1999-11-12
     */
    if (!regular) {
	if (LYCopyFile(newfile, filename_buffer) == 0) {
	    LYRemoveTemp(newfile);
	    return;
	}
	LYSleepAlert();	/* give a chance to see error from cp - kw */
	HTUserMsg(BOOKTEMP_COPY_FAIL);
	keep_tempfile = TRUE;
    }
#endif  /* UNIX */

a528 4
#ifdef MULTI_USER_UNIX
	if (regular)
	    chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif
d538 1
a538 4
#if defined(_WINDOWS) || defined(WIN_EX)
#if defined(WIN_EX)
	if (GetLastError() == ERROR_NOT_SAME_DEVICE)
#else /* !_WIN_EX */
d540 3
a542 1
#endif /* _WIN_EX */
a543 7
	    if (rename(newfile, filename_buffer) != 0) {
		if (LYCopyFile(newfile, filename_buffer) == 0)
		    remove(newfile);
	    }
	}
#else
	if (errno == EXDEV) {
d546 5
a550 16
	    CONST char *program;

	    if ((program = HTGetProgramPath(ppMV)) != NULL) {
		HTAddParam(&buffer, MV_FMT, 1, program);
		HTAddParam(&buffer, MV_FMT, 2, newfile);
		HTAddParam(&buffer, MV_FMT, 3, filename_buffer);
		HTEndParam(&buffer, MV_FMT, 3);
		if (LYSystem(buffer) == 0) {
#ifdef MULTI_USER_UNIX
		    if (regular)
			chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif
		    FREE(buffer);
		    return;
		}
	    }
d552 1
a552 2
	    keep_tempfile = TRUE;
	    goto failure;
a553 2
	CTRACE((tfp, "rename(): %s", LYStrerror(errno)));
#endif /* _WINDOWS */
d564 1
a564 1

d569 1
a569 2
    if (nfp)
	LYCloseTempFP(nfp);
d571 2
a572 7
	LYCloseInput(fp);
    if (keep_tempfile) {
	HTUserMsg2(gettext("File may be recoverable from %s during this session"),
		   newfile);
    } else {
	LYRemoveTemp(newfile);
    }
d585 1
a585 1
    if (LYMultiBookmarks == MBM_OFF || LYHaveSubBookmarks() == FALSE) {
d597 1
a597 1
    if (LYMultiBookmarks == MBM_ADVANCED && user_mode == ADVANCED_MODE) {
d604 1
a604 1
	    c = LYCharINTERRUPT2;
d607 2
a608 1
	if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) || LYCharIsINTERRUPT_HARD(c)) {
d619 1
a619 1
	    LYrefresh();
d640 2
a641 1
		if ((c = LYMBM2index(c)) < 0) {
d662 1
a662 1
    int c, d, MBM_tmp_count, MBM_allow;
d668 1
a668 1
    if (LYMultiBookmarks == MBM_OFF)
d674 2
d711 28
a738 10
    for (;;) {
	MBM_from = MBM_allow * MBM_current - MBM_allow;
	if (MBM_from < 0)
	    MBM_from = 0; /* 0 is default bookmark... */
	if (MBM_current != 1)
	    MBM_from++;

	MBM_to = (MBM_allow * MBM_current);
	if (MBM_to > MBM_V_MAXFILES)
	    MBM_to = MBM_V_MAXFILES;
d740 1
a740 17
	/*
	 *  Display menu of bookmarks.  NOTE that we avoid printw()'s
	 *  to increase the chances that any non-ASCII or multibyte/CJK
	 *  characters will be handled properly. - FM
	 */
	LYclear();
	LYmove(1, 5);
	lynx_start_h1_color ();
	if (MBM_screens > 1) {
	    char *shead_buffer = 0;
	    HTSprintf0(&shead_buffer,
		    MULTIBOOKMARKS_SHEAD_MASK, MBM_current, MBM_screens);
	    LYaddstr(shead_buffer);
	    FREE(shead_buffer);
	} else {
	    LYaddstr(MULTIBOOKMARKS_SHEAD);
	}
d742 14
a755 1
	lynx_stop_h1_color ();
d757 28
a784 14
	MBM_tmp_count = 0;
	for (c = MBM_from; c <= MBM_to; c++) {
	    LYmove(3+MBM_tmp_count, 5);
	    LYaddch(LYindex2MBM(c));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[c])
		LYaddstr(MBM_A_subdescript[c]);
	    LYmove(3+MBM_tmp_count,36);
	    LYaddch('(');
	    if (MBM_A_subbookmark[c])
		LYaddstr(MBM_A_subbookmark[c]);
	    LYaddch(')');
	    MBM_tmp_count++;
	}
d786 2
d789 1
a789 1
	 *  Don't need to show it if it all fits on one screen!
d791 2
a792 15
	if (MBM_screens > 1) {
	    LYmove(LYlines-2, 0);
	    LYaddstr("'");
	    start_bold();
	    LYaddstr("[");
	    stop_bold();
	    LYaddstr("' ");
	    LYaddstr(PREVIOUS);
	    LYaddstr(", '");
	    start_bold();
	    LYaddstr("]");
	    stop_bold();
	    LYaddstr("' ");
	    LYaddstr(NEXT_SCREEN);
	}
d794 8
a801 1
	LYMBM_statusline(MULTIBOOKMARKS_SAVE);
d803 6
a808 8
	for (;;) {
	    c = LYgetch();
#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = 7;
	    }
#endif /* VMS */
d810 9
a818 6
	    if ((d = LYMBM2index(c)) >= 0) {
		/*
		 *  See if we have a bookmark like that.
		 */
		if (MBM_A_subbookmark[d] != NULL)
		    return(d);
d820 9
a828 28
		show_bookmark_not_defined();
		LYMBM_statusline(MULTIBOOKMARKS_SAVE);
	    } else if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) ||
		c == 7 || c == 3) {
		/*
		 *  Treat left-arrow, ^G, or ^C as cancel.
		 */
		return(-2);
	    } else if (LYisNonAlnumKeyname(c, LYK_REFRESH)) {
		/*
		 *  Refresh the screen.
		 */
		lynx_force_repaint();
		LYrefresh();
	    } else if (LYisNonAlnumKeyname(c, LYK_ACTIVATE)) {
		/*
		 *  Assume default bookmark file on ENTER or right-arrow.
		 */
		return(MBM_A_subbookmark[0] ? 0 : -1);
	    } else if ((c == ']' ||  LYisNonAlnumKeyname(c, LYK_NEXT_PAGE)) &&
		MBM_screens > 1) {
		/*
		 *  Next range, if available.
		 */
		if (++MBM_current > MBM_screens)
		    MBM_current = 1;
		break;
	    }
d830 12
a841 10
	    else if ((c == '[' ||  LYisNonAlnumKeyname(c, LYK_PREV_PAGE)) &&
		MBM_screens > 1) {
		/*
		 *  Previous range, if available.
		 */
		if (--MBM_current <= 0)
		    MBM_current = MBM_screens;
		break;
	    }
	}
d865 1
a865 1
 *  is not MBM_OFF, otherwise, letting it go to the normal statusline
d873 1
a873 1
    if (LYMultiBookmarks != MBM_OFF && user_mode == NOVICE_MODE) {
d892 1
a892 1
	c = UCH(TOASCII(*p));
d919 1
a919 1
	if (UCH(*p) > 127)
d958 1
a958 1
	if (UCH(*temp) <= 127) {
d983 1
a983 1
	if (UCH(TOASCII(*p0)) >= 32 &&
a1001 18
}

/*
 * Since this is the "Default Bookmark File", we save it as a global, and as
 * the first MBM_A_subbookmark entry.
 */
PUBLIC void set_default_bookmark_page ARGS1(
	char *,		value)
{
    if (value != 0) {
	if (bookmark_page == 0
	 || strcmp(bookmark_page, value)) {
	    StrAllocCopy(bookmark_page, value);
	}
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
    }
@


1.1.3.2
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@d872 1
a872 1
	    lynx_start_bold();
d874 1
a874 1
	    lynx_stop_bold();
d878 1
a878 1
	    lynx_start_bold();
d880 1
a880 1
	    lynx_stop_bold();
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d23 2
a24 2
char *MBM_A_subbookmark[MBM_V_MAXFILES+1];
char *MBM_A_subdescript[MBM_V_MAXFILES+1];
d26 2
a27 2
static BOOLEAN is_mosaic_hotlist = FALSE;
static char * convert_mosaic_bookmark_file (char *filename_buffer);
d29 1
a29 1
int LYindex2MBM (int n)
d35 1
a35 1
int LYMBM2index (int ch)
d47 2
a48 2
static void
show_bookmark_not_defined (void)
d72 2
a73 2
char * get_bookmark_filename (
	char **	URL)
d148 2
a149 2
static char * convert_mosaic_bookmark_file (
	char *		filename_buffer)
d193 3
a195 3
static  BOOLEAN havevisible (const char *Title);
static  BOOLEAN have8bit (const char *Title);
static  char* title_convert8bit (const char *Title);
d204 3
a206 3
void save_bookmark_link (
	char *		address,
	char *		title)
d269 2
a270 2
	const char *url = HTLoadedDocumentURL();
	const char *page = (*BookmarkPage == '.')
d290 1
a290 1
		TO_EUC((const unsigned char *) title, (unsigned char *) tmp_buffer);
d293 1
a293 1
		TO_SJIS((const unsigned char *) title, (unsigned char *) tmp_buffer);
d454 3
a456 3
void remove_bookmark_link (
	int		cur,
	char *		cur_bookmark_page)
d637 1
a637 1
	    static const char MV_FMT[] = "%s %s %s";
d639 1
a639 1
	    const char *program;
d691 1
a691 1
int select_multi_bookmarks (void)
d771 1
a771 1
int select_menu_multi_bookmarks (void)
d950 1
a950 1
BOOLEAN LYHaveSubBookmarks (void)
d970 2
a971 2
void LYMBM_statusline  (
	char *		text)
d985 1
a985 1
static  BOOLEAN havevisible (const char * Title)
d987 1
a987 1
    const char *p = Title;
d1014 1
a1014 1
static  BOOLEAN have8bit (const char * Title)
d1016 1
a1016 1
    const char *p = Title;
d1044 1
a1044 1
static  char* title_convert8bit (const char * Title)
d1046 1
a1046 1
    const char *p = Title;
d1108 2
a1109 2
void set_default_bookmark_page (
	char *		value)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d10 1
a10 1
#include <LYCharUtils.h>	/* need for META charset */
d12 1
a12 1
#include <LYCharSets.h>		/* need for LYHaveCJKCharacterSet */
d23 2
a24 2
char *MBM_A_subbookmark[MBM_V_MAXFILES + 1];
char *MBM_A_subdescript[MBM_V_MAXFILES + 1];
d27 1
a27 1
static char *convert_mosaic_bookmark_file(char *filename_buffer);
d29 1
a29 1
int LYindex2MBM(int n)
d31 1
a31 2
    static char MBMcodes[MBM_V_MAXFILES + 2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

d35 1
a35 1
int LYMBM2index(int ch)
a39 1

d41 1
a41 1
	    && (result - letters) <= MBM_V_MAXFILES)
d47 2
a48 1
static void show_bookmark_not_defined(void)
d53 2
a54 2
	       BOOKMARK_FILE_NOT_DEFINED,
	       key_for_func(LYK_OPTIONS));
d60 11
a70 9
 * Tries to open a bookmark file for reading, which may be the default, or
 * based on offering the user a choice from the MBM_A_subbookmark[] array.  If
 * successful the file is closed, and the filename in system path specs is
 * returned, the URL is allocated into *URL, and the MBM_A_subbookmark[]
 * filepath is allocated into the BookmarkPage global.  Returns a zero-length
 * pointer to flag a cancel, or a space to flag an undefined selection, without
 * allocating into *URL or BookmarkPage.  Returns NULL with allocating into
 * BookmarkPage but not *URL is the selection is valid but the file doesn't yet
 * exist.  - FM
d72 2
a73 1
char *get_bookmark_filename(char **URL)
d81 2
a82 2
     * Multi_Bookmarks support.  - FMG & FM
     * Let user select a bookmark file.
d87 1
a87 1
	 * Zero-length pointer flags a cancel.  - FM
d89 1
a89 1
	return ("");
d93 1
a93 1
	 * Space flags an undefined selection.  - FMG
d95 1
a95 1
	return (" ");
d98 6
a103 5
	 * Save the filepath as a global.  The system path will be loaded into
	 * to the (static) filename_buffer as the return value, the URL will be
	 * allocated into *URL, and we also need the filepath available to
	 * calling functions.  This is all pitifully non-reentrant, a la the
	 * original Lynx, and should be redesigned someday.  - FM
d109 1
a109 1
     * Seek it in the home path.  - FM
d115 1
a115 1
	    BookmarkPage, filename_buffer));
d122 2
a123 2
	    && *LYTrimNewline(string_buffer) != '\0'
	    && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 29)) {
a124 1

d126 1
a126 1
	     * It is a mosaic hotlist file.
d138 1
a138 1
	return (filename_buffer);	/* bookmark file exists */
d140 1
a140 1
    return (NULL);
d142 1
a142 1
}				/* big end */
d145 2
a146 2
 * Converts a Mosaic hotlist file into an HTML file for handling as a Lynx
 * bookmark file.  - FM
d148 2
a149 1
static char *convert_mosaic_bookmark_file(char *filename_buffer)
d164 1
a164 1
	return ("");		/* should always open */
d166 1
a166 1
    fprintf(nfp, "<head>\n<title>%s</title>\n</head>\n", MOSAIC_BOOKMARK_TITLE);
d176 4
a179 4
	    if ((line % 2) == 0) {	/* even lines */
		if (*buf != '\0') {
		    strtok(buf, " ");	/* kill everything after the space */
		    fprintf(nfp, "<LI><a href=\"%s\">", buf);	/* the URL */
d181 2
a182 2
	    } else {		/* odd lines */
		fprintf(nfp, "%s</a>\n", buf);	/* the title */
d190 1
a190 1
    return (newfile);
d193 3
a195 3
static BOOLEAN havevisible(const char *Title);
static BOOLEAN have8bit(const char *Title);
static char *title_convert8bit(const char *Title);
d198 5
a202 3
 * Adds a link to a bookmark file, creating the file if it doesn't already
 * exist, and making sure that no_cache is set for a pre-existing, cached file,
 * so that the change will be evident on return to to that file.  - FM
d204 3
a206 2
void save_bookmark_link(char *address,
			char *title)
d223 1
a223 1
     * Make sure we were passed something to save.  - FM
d231 2
a232 1
     * Offer a choice of bookmark files, or get the default.  - FMG
d237 6
a242 4
     * If filename is NULL, must create a new file.  If filename is a space, an
     * invalid bookmark file was selected, or if zero-length, the user
     * cancelled.  Ignore request in both cases.  Otherwise, make a copy before
     * anything might change the static get_bookmark_filename() buffer.  - FM
d248 1
a248 1
	if (*filename == '\0' || !strcmp(filename, " ")) {
d252 1
a252 1
	LYstrncpy(filename_buffer, filename, sizeof(filename_buffer) - 1);
d256 2
a257 2
     * If BookmarkPage is NULL, something went wrong, so ignore the request.  -
     * FM
d265 2
a266 2
     * If the link will be added to the same bookmark file, get confirmation. 
     * - FM
d271 2
a272 3
	? (BookmarkPage + 1)
	: BookmarkPage;

d284 1
a284 1
     * Allow user to change the title.  - FM
d288 1
a288 1
	    switch (kanji_code) {
d298 1
a298 1
	    LYstrncpy(string_buffer, tmp_buffer, sizeof(string_buffer) - 1);
d300 1
a300 1
	    LYstrncpy(string_buffer, title, sizeof(string_buffer) - 1);
d311 1
a311 1
    } while (!havevisible(string_buffer));
d314 3
a316 2
     * Create the Title with any left-angle-brackets converted to &lt; entities
     * and any ampersands converted to &amp; entities.  - FM
d318 3
a320 3
     * Convert 8-bit letters to &#xUUUU to avoid dependencies from display
     * character set which may need changing.  Do NOT convert any 8-bit chars
     * if we have CJK display.  - LP
a326 1

d332 2
a333 2
     * Create the bookmark file, if it doesn't exist already, Otherwise, open
     * the pre-existing bookmark file.  - FM
d338 1
a338 1
	 * Seek it in the home path.  - FM
d345 1
a345 1
	    BookmarkPage, filename_buffer));
d355 1
a355 1
     * Convert all ampersands in the address to &amp; entities.  - FM
d361 2
a362 2
     * If we created a new bookmark file, write the headers.  - FM
     * Once and forever...
d375 2
a376 2
#endif /* !_WINDOWS */
	fprintf(fp, "<title>%s</title>\n</head>\n", BOOKMARK_TITLE);
d379 1
a379 1
		gettext("     You can delete links by the 'R' key<br>\n<ol>\n"));
d382 1
a382 1
		gettext("\
d386 1
a386 1
		gettext("\
d389 1
a389 1
		gettext("\
d394 1
a394 1
#endif /* _WINDOWS */
d398 1
a398 1
     * Add the bookmark link, in Mosaic hotlist or Lynx format.  - FM
d402 1
a402 2
	char *TimeString = (char *) ctime(&NowTime);

d404 1
a404 1
	 * TimeString has a \n at the end.
d406 1
a406 1
	fprintf(fp, "%s %s%s\n", Address, TimeString, Title);
d408 1
a408 1
	fprintf(fp, "<LI><a href=\"%s\">%s</a>\n", Address, Title);
d414 3
a416 2
     * If this is a cached bookmark file, set nocache for it so we'll see the
     * new bookmark link when that cache is retrieved.  - FM
d429 1
a429 1
		if ((text = (HText *) HTAnchor_document(tmpanchor)) != NULL) {
d438 1
a438 1
     * Clean up and report success.
d448 5
a452 4
 * Remove a link from a bookmark file.  The calling function is expected to
 * have used get_filename_link(), pass us the link number as cur, the
 * MBM_A_subbookmark[] string as cur_bookmark_page, and to have set up no_cache
 * itself.  - FM
d454 3
a456 2
void remove_bookmark_link(int cur,
			  char *cur_bookmark_page)
a460 1

d462 2
a463 3
    char filename_buffer[NAM$C_MAXRSS + 12];
    char newfile[NAM$C_MAXRSS + 12];

a468 1

d485 1
a485 1
	    cur_bookmark_page, filename_buffer));
d497 1
d500 1
a500 1
     * Explicitly preserve bookmark file mode on Unix.  - DSL
d504 1
a504 1
	mode = ((stat_buf.st_mode & 0777) | 0600);	/* make it writable */
d515 2
a516 3
	int del_line = cur * 2;	/* two lines per entry */

	n = -3;			/* skip past cookie and name lines */
d519 2
a520 2
	    if (n == del_line || n == del_line + 1)
		continue;	/* remove two lines */
a532 1

d536 2
a537 2
	    if ((cur == 0) && (cp2 = LYstrstr(cp, "<ol><LI>")))
		keep_ol = TRUE;	/* Do not erase, this corrects a bug in an
d549 1
a549 1
			fprintf(nfp, "<ol>\n");
d561 1
a561 1
	    newfile, filename_buffer));
d577 20
a596 24
     * By copying onto the bookmark file, rather than renaming it, we can
     * preserve the original ownership of the file, provided that it is
     * writable by the current process.
     *
     * Changed to copy 1998-04-26 -- gil
     *
     * But if the copy fails, for example because the filesystem is full, we
     * are left with a corrupt bookmark file.  Changed back to use the previous
     * mechanism [try rename(), then mv for EXDEV], except in usual cases (not
     * a regular file e.g., symbolic link, or has hard links).  This will let
     * bookmarks survive a filesystem full condition in the "normal" case
     * (bookmark is on same filesystem as home directory, is a regular file,
     * has no additional hard links).
     *
     * If we first tried LYCopyFile, and that fails, also fall back to trying
     * the other stuff.  That gives a chance to recover in case the LYCopyFile
     * left a corrupt target file.
     *
     * If there is an error, and that error may mean that the bookmark file has
     * been corrupted, don't remove the temporary newfile (which should always
     * be uncorrupted) in place, it may still be used to recover manually.  If
     * this applies, produce an additional message to that effect.  The temp
     * file will still be removed by normal program exit cleanup.  - kw
     * 1999-11-12
d603 1
a603 1
	LYSleepAlert();		/* give a chance to see error from cp - kw */
d607 1
a607 1
#endif /* UNIX */
d619 3
a621 2
	 * Rename won't work across file systems.  Check if this is the case
	 * and do something appropriate.  Used to be ODD_RENAME
d672 2
a673 1
  failure:
d689 1
a689 1
 * Allows user to select sub-bookmarks files.  - FMG & FM
d691 1
a691 1
int select_multi_bookmarks(void)
d696 1
a696 1
     * If not enabled, pick the "default" (0).
d699 2
a700 2
	if (MBM_A_subbookmark[0])	/* If it exists! */
	    return (0);
d702 1
a702 1
	    return (-1);
d706 3
a708 3
     * For ADVANCED users, we can just mess with the status line to save the 2
     * redraws of the screen, if LYMBMAdvnced is TRUE.  '=' will still show the
     * screen and let them do it the "long" way.
d712 1
a712 1
      get_advanced_choice:
d722 1
a722 1
	     * Treat left-arrow, ^G, or ^C as cancel.
d724 1
a724 1
	    return (-2);
d728 1
a728 1
	     * Refresh the screen.
d736 1
a736 1
	     * Assume default bookmark file on ENTER or right-arrow.
d741 5
a745 5
	case '=':
	    /*
	     * Get the choice via the menu.
	     */
	    return (select_menu_multi_bookmarks());
d747 8
a754 8
	default:
	    /*
	     * Convert to an array index, act on it if valid.
	     * Otherwise, get another keystroke.
	     */
	    if ((c = LYMBM2index(c)) < 0) {
		goto get_advanced_choice;
	    }
d757 1
a757 1
	 * See if we have a bookmark like that.
d762 1
a762 1
	 * Get the choice via the menu.
d764 1
a764 1
	return (select_menu_multi_bookmarks());
d769 1
a769 1
 * Allows user to select sub-bookmarks files.  - FMG & FM
d771 1
a771 1
int select_menu_multi_bookmarks(void)
d777 1
a777 1
     * If not enabled, pick the "default" (0).
d780 1
a780 1
	return (0);
d783 4
a786 4
     *        Filip M. Gieszczykiewicz (filipg@@paranoia.com) & FM
     *  ---------------------------------------------------
     * MBM_A_subbookmark[n] - Hold values of the respective "multi_bookmarkn"
     * in the lynxrc file.
d788 2
a789 1
     * MBM_A_subdescript[n] - Hold description entries in the lynxrc file.
d791 3
a793 3
     * Note: MBM_A_subbookmark[0] is defined to be same value as
     *       "bookmark_file" in the lynxrc file and/or the startup
     *       "bookmark_page".
d795 2
a796 1
     * We make the display of bookmarks depend on rows we have available.
d798 5
a802 4
     * We load BookmarkPage with the valid MBM_A_subbookmark[n] via
     * get_bookmark_filename().  Otherwise, that function returns a zero-length
     * string to indicate a cancel, a single space to indicate an invalid
     * choice, or NULL to indicate an inaccessible file.
d804 1
a804 1
    MBM_allow = (LYlines - 7);	/* We need 7 for header and footer */
d806 1
a806 1
     * Screen big enough?
d810 1
a810 1
	 * Too small.
d816 1
a816 1
    MBM_screens = (MBM_V_MAXFILES / MBM_allow) + 1;	/* int rounds off low. */
d818 1
a818 1
    MBM_current = 1;		/* Gotta start somewhere :-) */
d823 1
a823 1
	    MBM_from = 0;	/* 0 is default bookmark... */
d832 3
a834 3
	 * Display menu of bookmarks.  NOTE that we avoid printw()'s to
	 * increase the chances that any non-ASCII or multibyte/CJK characters
	 * will be handled properly.  - FM
d838 1
a838 1
	lynx_start_h1_color();
a840 1

d842 1
a842 1
		       MULTIBOOKMARKS_SHEAD_MASK, MBM_current, MBM_screens);
d849 1
a849 1
	lynx_stop_h1_color();
d853 1
a853 1
	    LYmove(3 + MBM_tmp_count, 5);
d858 1
a858 1
	    LYmove(3 + MBM_tmp_count, 36);
d867 1
a867 1
	 * Don't need to show it if it all fits on one screen!
d870 1
a870 1
	    LYmove(LYlines - 2, 0);
d898 1
a898 1
		 * See if we have a bookmark like that.
d901 1
a901 1
		    return (d);
d906 1
a906 1
		       c == 7 || c == 3) {
d908 1
a908 1
		 * Treat left-arrow, ^G, or ^C as cancel.
d910 1
a910 1
		return (-2);
d913 1
a913 1
		 * Refresh the screen.
d919 1
a919 1
		 * Assume default bookmark file on ENTER or right-arrow.
d921 3
a923 3
		return (MBM_A_subbookmark[0] ? 0 : -1);
	    } else if ((c == ']' || LYisNonAlnumKeyname(c, LYK_NEXT_PAGE)) &&
		       MBM_screens > 1) {
d925 1
a925 1
		 * Next range, if available.
d932 2
a933 2
	    else if ((c == '[' || LYisNonAlnumKeyname(c, LYK_PREV_PAGE)) &&
		     MBM_screens > 1) {
d935 1
a935 1
		 * Previous range, if available.
d946 3
a948 2
 * This function returns TRUE if we have sub-bookmarks defined.  Otherwise
 * (i.e., only the default bookmark file is defined), it returns FALSE.  - FM
d950 1
a950 1
BOOLEAN LYHaveSubBookmarks(void)
d956 1
a956 1
	    return (TRUE);
d959 1
a959 1
    return (FALSE);
d963 6
a968 5
 * This function passes a string to _statusline(), making sure it is at the
 * bottom of the screen if LYMultiBookmarks is not MBM_OFF, otherwise, letting
 * it go to the normal statusline position based on the current user mode.  We
 * want to use _statusline() so that any multibyte/CJK characters in the string
 * will be handled properly.  - FM
d970 2
a971 1
void LYMBM_statusline(char *text)
d985 1
a985 1
static BOOLEAN havevisible(const char *Title)
d991 1
a991 1
    for (; *p; p++) {
d994 1
a994 1
	    return (TRUE);
d998 1
a998 1
	    return (TRUE);
d1001 1
a1001 1
	    return (TRUE);
d1006 1
a1006 1
	return (TRUE);
d1008 1
a1008 1
    return (FALSE);		/* if we came here */
d1014 1
a1014 1
static BOOLEAN have8bit(const char *Title)
d1018 1
a1018 1
    for (; *p; p++) {
d1020 1
a1020 1
	    return (TRUE);
d1022 1
a1022 1
    return (FALSE);		/* if we came here */
d1026 5
a1030 5
 * Ok, title have 8-bit characters and they are in display charset.  Bookmarks
 * is a permanent file.  To avoid dependencies from display character set which
 * may be changed with time we store 8-bit characters as numeric character
 * reference (NCR), so where the character encoded as unicode number in form of
 * &#xUUUU;
d1032 3
a1034 3
 * To make bookmarks more readable for human (&#xUUUU certainly not) we add a
 * comment with '7-bit approximation' from the converted string.  This is a
 * valid HTML and bookmarks code.
d1036 6
a1041 2
 * We do not want use META charset tag in bookmarks file:  it will never be
 * changed later :-(
a1042 2
 * NCR's translation is part of I18N and HTML4.0 supported starting with Lynx
 * 2.7.2, Netscape 4.0 and MSIE 4.0.  Older versions fail.
d1044 1
a1044 1
static char *title_convert8bit(const char *Title)
d1050 1
a1050 1
    char *ncr = NULL;
d1052 1
a1052 1
    int charset_in = current_char_set;
d1055 1
a1055 1
    for (; *p; p++) {
d1057 1
a1057 2

	LYstrncpy(temp, p, sizeof(temp) - 1);
d1063 1
a1063 1
	    char replace_buf[32];
d1066 1
a1066 1
			       charset_in, charset_out, YES) > 0)
d1069 1
a1069 1
	    unicode = UCTransToUni(*temp, charset_in);
d1079 2
a1080 1
     * Cleanup comment, collapse multiple dashes into one dash, skip '>'.
d1085 1
a1085 1
	    (q == comment || *p0 != '-' || *(q - 1) != '-')) {
d1101 1
a1101 1
    return (buf);
d1108 2
a1109 1
void set_default_bookmark_page(char *value)
d1113 1
a1113 1
	    || strcmp(bookmark_page, value)) {
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d219 1
a219 1
    if (isEmpty(address)) {
d948 1
a948 1
	if (non_empty(MBM_A_subbookmark[i]))
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a13 1
#include <HTCJK.h>
a26 18
PUBLIC int LYindex2MBM ARGS1(int, n)
{
    static char MBMcodes[MBM_V_MAXFILES+2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return n >= 0 && n <= MBM_V_MAXFILES ? MBMcodes[n] : '?';
}

PUBLIC int LYMBM2index ARGS1(int, ch)
{
    if ((ch = TOUPPER(ch)) > 0) {
	char *letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	char *result = strchr(letters, ch);
	if (result != 0
	 && (result - letters) <= MBM_V_MAXFILES)
	    return (result - letters);
    }
    return -1;
}

d94 19
a112 3
    CTRACE((tfp, "\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n",
		BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) != NULL) {
d114 1
a114 2
	 * We now have the file open.
	 * Check if it is a mosaic hotlist.
d116 9
a124 15
	if (LYSafeGets(&string_buffer, fp) != 0
	 && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 29)) {
	    char *newname;
	    /*
	     *  It is a mosaic hotlist file.
	     */
	    is_mosaic_hotlist = TRUE;
	    newname = convert_mosaic_bookmark_file(filename_buffer);
	    LYLocalFileToURL(URL, newname);
	} else {
	    is_mosaic_hotlist = FALSE;
	    LYLocalFileToURL(URL, filename_buffer);
	}
	FREE(string_buffer);
	LYCloseInput(fp);
d126 1
a126 3
	return(filename_buffer);  /* bookmark file exists */
    }
    return(NULL);
d146 1
a146 1
	LYSleepAlert();
d150 1
a150 1
    if ((fp = fopen(filename_buffer, TXT_R)) == NULL)
a164 5
#ifdef DOSPATH	/* 1998/01/10 (Sat) 15:41:35 */
	    endline = strchr(buf, '\r');
	    if (endline == NULL)
		*endline = '\0';
#endif
d178 1
a178 1
    LYCloseInput(fp);
a202 1
    char tmp_buffer[BUFSIZ];
d240 1
a240 1
	LYstrncpy(filename_buffer, filename, sizeof(filename_buffer)-1);
d256 1
a256 1
    if (LYMultiBookmarks != MBM_OFF &&
d261 2
a262 2
	c = LYgetch_single();
	if (c != 'L') {
d272 1
a272 15
	if (HTCJK == JAPANESE) {
	    switch(kanji_code) {
	    case EUC:
		TO_EUC((CONST unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    case SJIS:
		TO_SJIS((CONST unsigned char *) title, (unsigned char *) tmp_buffer);
		break;
	    default:
		break;
	    }
	    LYstrncpy(string_buffer, tmp_buffer, sizeof(string_buffer)-1);
	} else {
	    LYstrncpy(string_buffer, title, sizeof(string_buffer)-1);
	}
d278 1
a278 1
	    LYSleepMsg();
d293 1
a293 1
    LYformTitle(&Title, string_buffer);
d315 3
a317 3
    CTRACE((tfp, "\nsave_bookmark_link: SEEKING %s\n   AS %s\n\n",
		BookmarkPage, filename_buffer));
    if ((fp = fopen(filename_buffer, (first_time ? TXT_W : TXT_A))) == NULL) {
d319 1
a319 1
	LYSleepAlert();
d336 1
a336 9
	fprintf(fp, "<head>\n");
#if defined(SH_EX) && !defined(_WINDOWS)	/* 1997/12/11 (Thu) 19:13:40 */
	if (HTCJK != JAPANESE)
	    LYAddMETAcharsetToFD(fp, -1);
	else
	    fprintf(fp, "<META %s %s>\n",
		    "http-equiv=\"content-type\"",
		    "content=\"text/html;charset=iso-2022-jp\"");
#else
a337 1
#endif	/* !_WINDOWS */
d339 1
a339 5
#ifdef _WINDOWS
	fprintf(fp,
	    gettext("     You can delete links by the 'R' key<br>\n<ol>\n"));
#else
	fprintf(fp, "%s<br>\n%s\n\n<!--\n%s\n-->\n\n<p>\n<ol>\n",
a351 1
#endif	/* _WINDOWS */
d367 1
a367 1
    LYCloseOutput(fp);
d403 1
a403 1
    LYSleepMsg();
a422 1
#define keep_tempfile FALSE
a425 2
    BOOLEAN keep_tempfile = FALSE;
#ifdef UNIX
a427 2
    BOOLEAN regular = FALSE;
#endif /* UNIX */
d431 1
a431 1
    CTRACE((tfp, "remove_bookmark_link: deleting link number: %d\n", cur));
d438 3
a440 3
    CTRACE((tfp, "\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n",
		cur_bookmark_page, filename_buffer));
    if ((fp = fopen(filename_buffer, TXT_R)) == NULL) {
d447 1
a447 1
	LYCloseInput(fp);
a456 1
	regular = (S_ISREG(stat_buf.st_mode) && stat_buf.st_nlink == 1);
d460 1
a460 1
	    (void) LYCloseInput(fp);
d479 1
a479 1
	char *cp, *cp2;
a484 1
	    int keep_ol = FALSE;
a487 3
	    if ((cur == 0) && (cp2 = LYstrstr(cp,"<ol><LI>")))
		keep_ol = TRUE; /* Do not erase, this corrects a bug in an
				   older version */
d496 1
a496 3
		    CTRACE((tfp, "remove_bookmark_link: skipping link %d\n", n));
		    if (keep_ol)
			fprintf(nfp,"<ol>\n");
d506 2
a507 3
    FREE(buf);
    CTRACE((tfp, "remove_bookmark_link: files: %s %s\n",
			newfile, filename_buffer));
d509 1
a509 1
    LYCloseInput(fp);
a510 4
    if (fflush(nfp) == EOF) {
	CTRACE((tfp, "fflush(nfp): %s", LYStrerror(errno)));
	goto failure;
    }
d523 5
a527 28
     *  But if the copy fails, for example because the filesystem is full,
     *  we are left with a corrupt bookmark file.  Changed back to use
     *  the previous mechanism [try rename(), then mv for EXDEV], except
     *  in usual cases (not a regular file e.g., symbolic link, or has hard
     *  links).  This will let bookmarks survive a filesystem full condition
     *  in the "normal" case (bookmark is on same filesystem as home directory,
     *  is a regular file, has no additional hard links).
     *  If we first tried LYCopyFile, and that fails, also fall back to trying
     *  the other stuff.  That gives a chance to recover in case the LYCopyFile
     *  left a corrupt target file.
     *  If there is an error, and that error may mean that the bookmark file
     *  has been corrupted, don't remove the temporary newfile (which should
     *  always be uncorrupted) in place, it may still be used to recover
     *  manually.  If this applies, produce an additional message to that
     *  effect.  The temp file will still be removed by normal program exit
     *  cleanup. - kw 1999-11-12
     */
    if (!regular) {
	if (LYCopyFile(newfile, filename_buffer) == 0) {
	    LYRemoveTemp(newfile);
	    return;
	}
	LYSleepAlert();	/* give a chance to see error from cp - kw */
	HTUserMsg(BOOKTEMP_COPY_FAIL);
	keep_tempfile = TRUE;
    }
#endif  /* UNIX */

a528 4
#ifdef UNIX
	if (regular)
	    chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif /* UNIX */
d538 1
a538 4
#if defined(_WINDOWS) || defined(WIN_EX)
#if defined(WIN_EX)
	if (GetLastError() == ERROR_NOT_SAME_DEVICE)
#else /* !_WIN_EX */
d540 3
a542 1
#endif /* _WIN_EX */
a543 7
	    if (rename(newfile, filename_buffer) != 0) {
		if (LYCopyFile(newfile, filename_buffer) == 0)
		    remove(newfile);
	    }
	}
#else
	if (errno == EXDEV) {
d550 3
a552 12
	    if (LYSystem(buffer) == 0) {
#ifdef UNIX
		if (regular)
		    chmod(filename_buffer, stat_buf.st_mode & 07777);
#endif /* UNIX */
		FREE(buffer);
		return;
	    } else {
		FREE(buffer);
		keep_tempfile = TRUE;
		goto failure;
	    }
a553 2
	CTRACE((tfp, "rename(): %s", LYStrerror(errno)));
#endif /* _WINDOWS */
d564 1
a564 1

d569 1
a569 2
    if (nfp)
	LYCloseTempFP(nfp);
d571 2
a572 7
	LYCloseInput(fp);
    if (keep_tempfile) {
	HTUserMsg2(gettext("File may be recoverable from %s during this session"),
		   newfile);
    } else {
	LYRemoveTemp(newfile);
    }
d585 1
a585 1
    if (LYMultiBookmarks == MBM_OFF || LYHaveSubBookmarks() == FALSE) {
d597 1
a597 1
    if (LYMultiBookmarks == MBM_ADVANCED && user_mode == ADVANCED_MODE) {
d604 1
a604 1
	    c = LYCharINTERRUPT2;
d607 2
a608 1
	if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) || LYCharIsINTERRUPT(c)) {
d619 1
a619 1
	    LYrefresh();
d640 2
a641 1
		if ((c = LYMBM2index(c)) < 0) {
d662 1
a662 1
    int c, d, MBM_tmp_count, MBM_allow;
d668 1
a668 1
    if (LYMultiBookmarks == MBM_OFF)
d674 2
d711 28
a738 10
    for (;;) {
	MBM_from = MBM_allow * MBM_current - MBM_allow;
	if (MBM_from < 0)
	    MBM_from = 0; /* 0 is default bookmark... */
	if (MBM_current != 1)
	    MBM_from++;

	MBM_to = (MBM_allow * MBM_current);
	if (MBM_to > MBM_V_MAXFILES)
	    MBM_to = MBM_V_MAXFILES;
d740 1
a740 17
	/*
	 *  Display menu of bookmarks.  NOTE that we avoid printw()'s
	 *  to increase the chances that any non-ASCII or multibyte/CJK
	 *  characters will be handled properly. - FM
	 */
	LYclear();
	LYmove(1, 5);
	lynx_start_h1_color ();
	if (MBM_screens > 1) {
	    char *shead_buffer = 0;
	    HTSprintf0(&shead_buffer,
		    MULTIBOOKMARKS_SHEAD_MASK, MBM_current, MBM_screens);
	    LYaddstr(shead_buffer);
	    FREE(shead_buffer);
	} else {
	    LYaddstr(MULTIBOOKMARKS_SHEAD);
	}
d742 14
a755 1
	lynx_stop_h1_color ();
d757 28
a784 14
	MBM_tmp_count = 0;
	for (c = MBM_from; c <= MBM_to; c++) {
	    LYmove(3+MBM_tmp_count, 5);
	    LYaddch(LYindex2MBM(c));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[c])
		LYaddstr(MBM_A_subdescript[c]);
	    LYmove(3+MBM_tmp_count,36);
	    LYaddch('(');
	    if (MBM_A_subbookmark[c])
		LYaddstr(MBM_A_subbookmark[c]);
	    LYaddch(')');
	    MBM_tmp_count++;
	}
d786 2
d789 1
a789 1
	 *  Don't need to show it if it all fits on one screen!
d791 2
a792 15
	if (MBM_screens > 1) {
	    LYmove(LYlines-2, 0);
	    LYaddstr("'");
	    start_bold();
	    LYaddstr("[");
	    stop_bold();
	    LYaddstr("' ");
	    LYaddstr(PREVIOUS);
	    LYaddstr(", '");
	    start_bold();
	    LYaddstr("]");
	    stop_bold();
	    LYaddstr("' ");
	    LYaddstr(NEXT_SCREEN);
	}
d794 8
a801 1
	LYMBM_statusline(MULTIBOOKMARKS_SAVE);
d803 6
a808 8
	for (;;) {
	    c = LYgetch();
#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = 7;
	    }
#endif /* VMS */
d810 9
a818 6
	    if ((d = LYMBM2index(c)) >= 0) {
		/*
		 *  See if we have a bookmark like that.
		 */
		if (MBM_A_subbookmark[d] != NULL)
		    return(d);
d820 9
a828 28
		show_bookmark_not_defined();
		LYMBM_statusline(MULTIBOOKMARKS_SAVE);
	    } else if (LYisNonAlnumKeyname(c, LYK_PREV_DOC) ||
		c == 7 || c == 3) {
		/*
		 *  Treat left-arrow, ^G, or ^C as cancel.
		 */
		return(-2);
	    } else if (LYisNonAlnumKeyname(c, LYK_REFRESH)) {
		/*
		 *  Refresh the screen.
		 */
		lynx_force_repaint();
		LYrefresh();
	    } else if (LYisNonAlnumKeyname(c, LYK_ACTIVATE)) {
		/*
		 *  Assume default bookmark file on ENTER or right-arrow.
		 */
		return(MBM_A_subbookmark[0] ? 0 : -1);
	    } else if ((c == ']' ||  LYisNonAlnumKeyname(c, LYK_NEXT_PAGE)) &&
		MBM_screens > 1) {
		/*
		 *  Next range, if available.
		 */
		if (++MBM_current > MBM_screens)
		    MBM_current = 1;
		break;
	    }
d830 12
a841 10
	    else if ((c == '[' ||  LYisNonAlnumKeyname(c, LYK_PREV_PAGE)) &&
		MBM_screens > 1) {
		/*
		 *  Previous range, if available.
		 */
		if (--MBM_current <= 0)
		    MBM_current = MBM_screens;
		break;
	    }
	}
d865 1
a865 1
 *  is not MBM_OFF, otherwise, letting it go to the normal statusline
d873 1
a873 1
    if (LYMultiBookmarks != MBM_OFF && user_mode == NOVICE_MODE) {
d892 1
a892 1
	c = UCH(TOASCII(*p));
d919 1
a919 1
	if (UCH(*p) > 127)
d958 1
a958 1
	if (UCH(*temp) <= 127) {
d983 1
a983 1
	if (UCH(TOASCII(*p0)) >= 32 &&
a1001 18
}

/*
 * Since this is the "Default Bookmark File", we save it as a global, and as
 * the first MBM_A_subbookmark entry.
 */
PUBLIC void set_default_bookmark_page ARGS1(
	char *,		value)
{
    if (value != 0) {
	if (bookmark_page == 0
	 || strcmp(bookmark_page, value)) {
	    StrAllocCopy(bookmark_page, value);
	}
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
    }
@

