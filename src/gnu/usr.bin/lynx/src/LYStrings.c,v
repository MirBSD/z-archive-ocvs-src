head	1.10;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.9
	tg-mergefixes-1-branch:1.9.0.4
	tg-mergefixes-1-base:1.9
	MIROS_X:1.9.0.2
	MIROS_X_BASE:1.9
	MIRBSD_XP_MIRPPC:1.8.0.4
	lynx-2_8_6dev_7b:1.1.3.6
	lynx-2_8_6dev_6:1.1.3.6
	MIRBSD_XP_SPARC_BASE:1.8
	MIRBSD_XP_SPARC:1.8.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.5
	lynx-2_8_6dev_5:1.1.3.5
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.4
	lynx-2_8_5:1.1.3.3
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2005.01.03.00.46.04;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.11.20.30.42;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.15.18.17.03;	author tg;	state Stab;
branches;
next	1.7;

1.7
date	2004.04.30.16.32.37;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.08.19.49.01;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.18.17.40.13;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.27;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.38;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.35;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.20;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.20;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.27;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.33;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.16;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.40;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.02.08.13.10.15;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.04.30.16.15.54;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.07.15.15.51.56;	author tg;	state Exp;
branches;
next	1.1.3.6;

1.1.3.6
date	2004.10.11.20.16.26;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTCJK.h>
#include <UCAux.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <GridText.h>
#include <LYKeymap.h>
#include <LYClean.h>
#include <LYMail.h>
#include <LYNews.h>
#include <LYOptions.h>
#include <LYCharSets.h>
#include <HTAlert.h>
#include <HTString.h>
#include <LYCharUtils.h>
#include <HTList.h>
#include <HTParse.h>
#ifdef USE_MOUSE
#include <LYMainLoop.h>
#endif

#ifdef DJGPP_KEYHANDLER
#include <pc.h>
#include <keys.h>
#endif /* DJGPP_KEYHANDLER */

#ifdef USE_COLOR_STYLE
#include <LYHash.h>
#include <AttrList.h>
#endif

#ifdef USE_SCROLLBAR
#include <LYMainLoop.h>
#endif

#ifdef EXP_CMD_LOGGING
#include <LYReadCFG.h>
#endif

#include <LYShowInfo.h>
#include <LYLeaks.h>

#if defined(WIN_EX)
#undef  BUTTON_CTRL
#define BUTTON_CTRL	0	/* Quick hack */
#endif

/*
 * The edit_history lists allow the user to press tab when entering URL to get
 * the closest match in the closet
 */
#define LYClosetSize 100

static HTList *URL_edit_history;
static HTList *MAIL_edit_history;

/* If you want to add mouse support for some new platform, it's fairly
 * simple to do.  Once you've determined the X and Y coordinates of
 * the mouse event, loop through the elements in the links[] array and
 * see if the coordinates fall within a highlighted link area.	If so,
 * the code must set mouse_link to the index of the chosen link,
 * and return a key value that corresponds to LYK_ACTIVATE.  The
 * LYK_ACTIVATE code in LYMainLoop.c will then check mouse_link
 * and activate that link.  If the mouse event didn't fall within a
 * link, the code should just set mouse_link to -1 and return -1. --AMK
 */

/* The number of the link selected w/ the mouse (-1 if none) */
static int mouse_link = -1;

static int have_levent;

#if defined(USE_MOUSE) && defined(NCURSES)
static MEVENT levent;
#endif

/* Return the value of mouse_link */
int peek_mouse_levent(void)
{
#if defined(USE_MOUSE) && defined(NCURSES)
    if (have_levent > 0) {
	ungetmouse(&levent);
	have_levent--;
	return 1;
    }
#endif
    return 0;
}

/* Return the value of mouse_link, erasing it */
int get_mouse_link(void)
{
    int t;

    t = mouse_link;
    mouse_link = -1;
    if (t < 0)
	t = -1;			/* Backward compatibility. */
    return t;
}

/* Return the value of mouse_link */
int peek_mouse_link(void)
{
    return mouse_link;
}

int fancy_mouse(WINDOW * win, int row,
		int *position)
{
    int cmd = LYK_DO_NOTHING;

#ifdef USE_MOUSE
/*********************************************************************/

#if defined(WIN_EX) && defined(PDCURSES)

    request_mouse_pos();

    if (BUTTON_STATUS(1)
	&& (MOUSE_X_POS >= getbegx(win)
	    && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
	int mypos = MOUSE_Y_POS - getbegy(win);
	int delta = mypos - row;

	if (mypos + 1 == getmaxy(win)) {
	    /* At the decorative border: scroll forward */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_END;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_NEXT_PAGE;
	    else
		cmd = LYK_NEXT_LINK;
	} else if (mypos >= getmaxy(win)) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_END;
	    else
		cmd = LYK_NEXT_PAGE;
	} else if (mypos == 0) {
	    /* At the decorative border: scroll back */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_HOME;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_PREV_PAGE;
	    else
		cmd = LYK_PREV_LINK;
	} else if (mypos < 0) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_HOME;
	    else
		cmd = LYK_PREV_PAGE;
#ifdef KNOW_HOW_TO_TOGGLE
	} else if (BUTTON_STATUS(1) & (BUTTON_CTRL)) {
	    cur_selection += delta;
	    cmd = LYX_TOGGLE;
#endif
	} else if (BUTTON_STATUS(1) & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)) {
	    /* Probably some unrelated activity, such as selecting some text.
	     * Select, but do nothing else.
	     */
	    *position += delta;
	    cmd = -1;
	} else {
	    /* No scrolling or overflow checks necessary. */
	    *position += delta;
	    cmd = LYK_ACTIVATE;
	}
    } else if (BUTTON_STATUS(1) & (BUTTON3_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED)) {
	cmd = LYK_QUIT;
    }
#else
#if defined(NCURSES)
    MEVENT event;

    getmouse(&event);
    if ((event.bstate & (BUTTON1_CLICKED
			 | BUTTON1_DOUBLE_CLICKED
			 | BUTTON1_TRIPLE_CLICKED))) {
	int mypos = event.y - getbegy(win);
	int delta = mypos - row;

	if ((event.x < getbegx(win) || event.x >= (getbegx(win) + getmaxx(win)))
	    && !(event.bstate & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)))
	    return LYK_QUIT;	/* User clicked outside, wants to quit? */
	if (mypos + 1 == getmaxy(win)) {
	    /* At the decorative border: scroll forward */
	    if (event.bstate & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_END;
	    else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_NEXT_PAGE;
	    else
		cmd = LYK_NEXT_LINK;
	} else if (mypos >= getmaxy(win)) {
	    if (event.bstate & (BUTTON1_DOUBLE_CLICKED
				| BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_END;
	    else
		cmd = LYK_NEXT_PAGE;
	} else if (mypos == 0) {
	    /* At the decorative border: scroll back */
	    if (event.bstate & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_HOME;
	    else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_PREV_PAGE;
	    else
		cmd = LYK_PREV_LINK;
	} else if (mypos < 0) {
	    if (event.bstate & (BUTTON1_DOUBLE_CLICKED
				| BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_HOME;
	    else
		cmd = LYK_PREV_PAGE;
#ifdef KNOW_HOW_TO_TOGGLE
	} else if (event.bstate & (BUTTON_CTRL)) {
	    cur_selection += delta;
	    cmd = LYX_TOGGLE;
#endif
	} else if (event.x <= getbegx(win) + 1 ||
		   event.x >= getbegx(win) + getmaxx(win) - 2) {
	    /* Click on left or right border for positioning without
	     * immediate action: select, but do nothing else.
	     * Actually, allow an error of one position inwards. - kw
	     */
	    *position += delta;
	    cmd = -1;
	} else if (event.bstate & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)) {
	    /* Probably some unrelated activity, such as selecting some text.
	     * Select, but do nothing else.
	     */
	    /* Possibly this is never returned by ncurses, so this case
	     * may be useless depending on situation (kind of mouse support
	     * and library versions). - kw
	     */
	    *position += delta;
	    cmd = -1;
	} else {
	    /* No scrolling or overflow checks necessary. */
	    *position += delta;
	    cmd = LYK_ACTIVATE;
	}
    } else if (event.bstate & (BUTTON3_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED)) {
	cmd = LYK_QUIT;
    }
#endif /* NCURSES */
#endif /* PDCURSES */

/************************************************************************/
#endif /* USE_MOUSE */
    return cmd;
}

/*
 * Manage the collection of edit-histories
 */
static HTList *whichRecall(RecallType recall)
{
    HTList **list;

    switch (recall) {
    case RECALL_CMD:
	return LYcommandList();
    case RECALL_MAIL:
	list = &MAIL_edit_history;
	break;
    default:
	list = &URL_edit_history;
	break;
    }
    if (*list == 0)
	*list = HTList_new();
    return *list;
}

/*
 * Remove the oldest item in the closet
 */
static void LYRemoveFromCloset(HTList *list)
{
    void *data = HTList_removeFirstObject(list);

    if (data != 0)
	FREE(data);
}

void LYCloseCloset(RecallType recall)
{
    HTList *list = whichRecall(recall);

    while (!HTList_isEmpty(list)) {
	LYRemoveFromCloset(list);
    }
    HTList_delete(list);	/* should already be empty */
}

/*
 * Strategy:  We begin at the top and search downwards.  We return the first
 * match, i.e., the newest since we search from the top.  This should be made
 * more intelligent, but works for now.
 */
static char *LYFindInCloset(RecallType recall, char *base)
{
    HTList *list = whichRecall(recall);
    char *data;
    unsigned len = strlen(base);

    while (!HTList_isEmpty(list)) {
	data = (char *) HTList_nextObject(list);
	if (!strncmp(base, data, len))
	    return (data);
    }

    return (0);
}

static void LYAddToCloset(RecallType recall, char *str)
{
    HTList *list = whichRecall(recall);
    char *data = NULL;

    StrAllocCopy(data, str);
    HTList_addObject(list, data);
    while (HTList_count(list) > LYClosetSize)
	LYRemoveFromCloset(list);
}

#ifdef USE_MOUSE
static int XYdist(int x1,
		  int y1,
		  int x2,
		  int y2,
		  int dx2)
{
    int xerr = 3 * (x2 - x1), yerr = 9 * (y2 - y1);

    if (xerr < 0)
	xerr = 3 * (x1 - x2 - dx2) + 1;		/* pos after string not really in it */
    if (xerr < 0)
	xerr = 0;
    if (yerr < 0)
	yerr = -yerr;
    if (!yerr)			/* same line is good */
	return (xerr > 0) ? (xerr * 2 - 1) : 0;
    if (xerr < 9 && yerr)	/* x-dist of 3 cell better than y-dist of 1 cell */
	yerr += (9 - xerr);
    return 2 * xerr + yerr;	/* Subjective factor; ratio -> approx. 6 / 9 */
/*
old: (IZ 1999-07-30)
 3  2  2  2  1  1  1 XX XX XX XX XX  0  1  1  1  2  2  2  3  3
 4\ 3  3  3  2  2  2  2  2  2  2  2  2  2  2  2  3  3  3/ 4  4
 5  4  4  4\ 3  3  3  3  3  3  3  3  3  3  3  3/ 4  4  4  5  5
 6  5  5  5  4  4  4  4  4  4  4  4  4  4  4  4  5  5  5  6  5
now: (kw 1999-10-23)
41 35 29|23 17 11  5 XX XX XX XX XX  1  7 13 19 25|31 37 43 49
   45 39 33\27 24 21 18 18 18 18 18 19 22 25 28/34 40 46 50
      48 42 36 33 30\27 27 27 27 27 28/31 34 37 43 49
         51 45 42 39 36 36 36 36 36 37 40 43 46 49
               51 48 45 45 45 45 45 46 49 52
*/
}

/* Given X and Y coordinates of a mouse event, set mouse_link to the
 * index of the corresponding hyperlink, or set mouse_link to -1 if no
 * link matches the event.  Returns -1 if no link matched the click,
 * or a keycode that must be returned from LYgetch() to activate the
 * link.
 */

static int set_clicked_link(int x,
			    int y,
			    int code,
			    int clicks)
{
    int left = 6;
    int right = LYcolLimit - 5;

    /* yes, I am assuming that my screen will be a certain width. */
    int i;
    int c = -1;

    if (y == (LYlines - 1) || y == 0) {		/* First or last row */
	/* XXXX In fact # is not always at x==0?  KANJI_CODE_OVERRIDE? */
	int toolbar = (y == 0 && HText_hasToolbar(HTMainText));

	mouse_link = -2;
	if (x == 0 && toolbar)	/* On '#' */
	    c = LAC_TO_LKC0(LYK_TOOLBAR);
#if defined(CAN_CUT_AND_PASTE) && defined(USE_COLOR_STYLE)
	else if (y == 0 && x == LYcolLimit && s_hot_paste != NOSTYLE)
	    c = LAC_TO_LKC0(LYK_PASTE_URL);
#endif
	else if (clicks > 1) {
	    if (x < left + toolbar)
		c = (code == FOR_PROMPT && y)
		    ? HOME : LAC_TO_LKC0(LYK_MAIN_MENU);
	    else if (x > right)
		c = (code == FOR_PROMPT && y)
		    ? END_KEY : LAC_TO_LKC0(LYK_VLINKS);
	    else if (y)		/* Last row */
		c = LAC_TO_LKC0(LYK_END);
	    else		/* First row */
		c = LAC_TO_LKC0(LYK_HOME);
	} else {
	    if (x < left + toolbar)
		c = (code == FOR_PROMPT && y)
		    ? LTARROW
		    : (
#ifdef USE_COLOR_STYLE
			  (s_forw_backw != NOSTYLE && x - toolbar >= 3)
			  ? LAC_TO_LKC0(LYK_NEXT_DOC)
			  : LAC_TO_LKC0(LYK_PREV_DOC)
#else
			  LAC_TO_LKC0(LYK_NEXT_DOC)
#endif
		    );
	    else if (x > right)
		c = (code == FOR_PROMPT && y)
		    ? RTARROW : LAC_TO_LKC0(LYK_HISTORY);
	    else if (y)		/* Last row */
		c = LAC_TO_LKC0(LYK_NEXT_PAGE);
	    else		/* First row */
		c = LAC_TO_LKC0(LYK_PREV_PAGE);
	}
#ifdef USE_SCROLLBAR
    } else if (x == (LYcols - 1) && LYShowScrollbar && LYsb_begin >= 0) {
	int h = display_lines - 2 * (LYsb_arrow != 0);

	mouse_link = -2;
	y -= 1 + (LYsb_arrow != 0);
	if (y < 0)
	    return LAC_TO_LKC0(LYK_UP_TWO);
	if (y >= h)
	    return LAC_TO_LKC0(LYK_DOWN_TWO);

	if (clicks >= 2) {
	    double frac = (1. * y) / (h - 1);
	    int l = HText_getNumOfLines() + 1;	/* NOL() off by one? */

	    l -= display_lines;
	    if (l > 0)
		LYSetNewline((int) (frac * l + 1 + 0.5));
	    return LYReverseKeymap(LYK_DO_NOTHING);
	}

	if (y < LYsb_begin)
	    return LAC_TO_LKC0(LYK_PREV_PAGE);
	if (y >= LYsb_end)
	    return LAC_TO_LKC0(LYK_NEXT_PAGE);
	mouse_link = -1;	/* No action in edit fields */
#endif
    } else {
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */ cur_err;

	/* Loop over the links and see if we can get a match */
	for (i = 0; i < nlinks; i++) {
	    int len, lx = links[i].lx, is_text = 0;
	    int count = 0;
	    const char *text = LYGetHiliteStr(i, count);

	    if (links[i].type == WWW_FORM_LINK_TYPE
		&& F_TEXTLIKE(links[i].l_form->type))
		is_text = 1;

	    /* Check the first line of the link */
	    if (text != NULL) {
		if (is_text)
		    len = links[i].l_form->size;
		else
		    len = strlen(text);
		cur_err = XYdist(x, y, links[i].lx, links[i].ly, len);
		/* Check the second line */
		while (cur_err > 0
		       && (text = LYGetHiliteStr(i, ++count)) != NULL) {
		    /* Note that there is at most one hightext if is_text */
		    int cur_err_2 = XYdist(x, y,
					   LYGetHilitePos(i, count),
					   links[i].ly + count,
					   strlen(text));

		    cur_err = HTMIN(cur_err, cur_err_2);
		}
		if (cur_err > 0 && is_text)
		    cur_err--;	/* a bit of preference for text fields,
				   enter field if hit exactly at end - kw */
		if (cur_err == 0) {
		    int cury, curx;

		    LYGetYX(cury, curx);
		    /* double-click, if we care:
		       submit text submit fields. - kw */
		    if (clicks > 1 && is_text &&
			links[i].l_form->type == F_TEXT_SUBMIT_TYPE) {
			if (code != FOR_INPUT
			/* submit current input field directly */
			    || !(cury == y && (curx >= lx) && ((curx - lx) <= len))) {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = i;
			} else {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = -1;
			}
			mouse_err = 0;
			break;
		    }
		    if (code != FOR_INPUT
		    /* Do not pick up the current input field */
			|| !((cury == y && (curx >= lx) && ((curx - lx) <= len)))) {
			if (is_text) {
			    have_levent = 1;
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
			    if (x == links[i].lx && y == links[i].ly)
				textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
			}
			mouse_link = i;
		    } else
			mouse_link = -1;
		    mouse_err = 0;
		    break;
		} else if (cur_err < mouse_err) {
		    mouse_err = cur_err;
		    mouse_link = i;
		}
	    }
	}
	/*
	 * If a link was hit, we must look for a key which will activate
	 * LYK_ACTIVATE We expect to find LYK_ACTIVATE (it's usually mapped to
	 * the Enter key).
	 */
	if (mouse_link >= 0) {
	    if (mouse_err == 0) {
		if (c == -1)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
	    } else if (mouse_err >= 0)
		c = LAC_TO_LKC0(LYK_CHANGE_LINK);
	} else {
	    if (2 * y > LYlines) {	/* Bottom Half of the screen */
		if (4 * y < 3 * LYlines) {
		    c = LAC_TO_LKC0(LYK_DOWN_TWO);	/* Third quarter */
		} else
		    c = LAC_TO_LKC0(LYK_DOWN_HALF);	/* Fourth quarter */
	    } else {		/* Upper Half of the screen */
		if (4 * y < LYlines) {
		    c = LAC_TO_LKC0(LYK_UP_HALF);	/* First quarter */
		} else
		    c = LAC_TO_LKC0(LYK_UP_TWO);	/* Second quarter */
	    }
	}
    }
    return c;
}
#endif /* USE_MOUSE */

/*
 * LYstrncpy() terminates strings with a null byte.  Writes a null byte into
 * the n+1 byte of dst.
 */
char *LYstrncpy(char *dst,
		const char *src,
		int n)
{
    char *val;
    int len;

    if (src == 0)
	src = "";
    len = strlen(src);

    if (n < 0)
	n = 0;

    val = strncpy(dst, src, n);
    if (len < n)
	*(dst + len) = '\0';
    else
	*(dst + n) = '\0';
    return val;
}

#define IS_NEW_GLYPH(ch) (utf_flag && (UCH(ch)&0xc0) != 0x80)
#define IS_UTF_EXTRA(ch) (utf_flag && (UCH(ch)&0xc0) == 0x80)

/*
 * LYmbcsstrncpy() terminates strings with a null byte.  It takes account of
 * multibyte characters.  The src string is copied until either end of string
 * or max number of either bytes or glyphs (mbcs sequences) (CJK or UTF8).  The
 * utf_flag argument should be TRUE for UTF8.  - KW & FM
 */
char *LYmbcsstrncpy(char *dst,
		    const char *src,
		    int n_bytes,
		    int n_glyphs,
		    BOOL utf_flag)
{
    char *val = dst;
    int i_bytes = 0, i_glyphs = 0;

    if (n_bytes < 0)
	n_bytes = 0;
    if (n_glyphs < 0)
	n_glyphs = 0;

    for (; *src != '\0' && i_bytes < n_bytes; i_bytes++) {
	if (IS_NEW_GLYPH(*src)) {
	    if (i_glyphs++ >= n_glyphs) {
		*dst = '\0';
		return val;
	    }
	}
	*(dst++) = *(src++);
    }
    *dst = '\0';

    return val;
}

/*
 * LYmbcs_skip_glyphs() skips a given number of display positions in a string
 * and returns the resulting pointer.  It takes account of UTF-8 encoded
 * characters.  - KW
 */
const char *LYmbcs_skip_glyphs(const char *data,
			       int n_glyphs,
			       BOOL utf_flag)
{
    int i_glyphs = 0;

    if (n_glyphs < 0)
	n_glyphs = 0;

    if (!data)
	return NULL;
    if (!utf_flag)
	return (data + n_glyphs);

    while (*data) {
	if (IS_NEW_GLYPH(*data)) {
	    if (i_glyphs++ >= n_glyphs) {
		return data;
	    }
	}
	data++;
    }
    return data;
}

/*
 * LYmbcsstrlen() returns the printable length of a string that might contain
 * IsSpecial or multibyte (CJK or UTF8) characters.  - FM
 *
 * Counts glyph cells if count_gcells is set.  (Full-width characters in CJK
 * mode count as two.) Counts character glyphs if count_gcells is unset. 
 * (Full- width characters in CJK mode count as one.) - kw
 */
int LYmbcsstrlen(const char *str,
		 BOOL utf_flag,
		 BOOL count_gcells)
{
    int i, j, len = 0;

    if (non_empty(str)) {
#ifdef WIDEC_CURSES
	if (count_gcells) {
	    len = LYstrCells(str);
	} else
#endif
	{
	    for (i = 0; str[i] != '\0'; i++) {
		if (!IsSpecialAttrChar(str[i])) {
		    len++;
		    if (IS_NEW_GLYPH(str[i])) {
			j = 0;
			while (IsNormalChar(str[(i + 1)]) &&
			       j < 5 &&
			       IS_UTF_EXTRA(str[(i + 1)])) {
			    i++;
			    j++;
			}
		    } else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
			       is8bits(str[i]) &&
			       IsNormalChar(str[(i + 1)])) {
			i++;
		    }
		}
	    }
	}
    }
    return (len);
}

#undef GetChar

#ifdef USE_SLANG
#if defined(VMS)
#define GetChar() ttgetc()
#elif defined(__DJGPP__)
#define GetChar() getxkey()	/* HTDos.c */
#elif defined(__CYGWIN__)
#define GetChar SLkp_getkey
#else
#define GetChar (int)SLang_getkey
#endif
#else /* curses */
#if defined(DJGPP)
#define GetChar() (djgpp_idle_loop(), wgetch(LYtopwindow()))
#elif defined(NCURSES)
#define GetChar() wgetch(LYtopwindow())
#endif
#endif

#if !defined(GetChar) && defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* PDCurses sends back key-modifiers that we don't use, but would waste time
 * upon, e.g., repainting the status line
 */
static int myGetChar(void)
{
    int c;
    BOOL done = FALSE;

    do {
	switch (c = wgetch(LYwin)) {
	case KEY_SHIFT_L:
	case KEY_SHIFT_R:
	case KEY_CONTROL_L:
	case KEY_CONTROL_R:
	case KEY_ALT_L:
	case KEY_ALT_R:
	case KEY_RESIZE:
	    break;
	default:
	    done = TRUE;
	    break;
	}
    } while (!done);
    return c;
}
#define GetChar() myGetChar()
#endif

#if !defined(GetChar) && defined(SNAKE)
#define GetChar() wgetch(LYwin)
#endif

#if !defined(GetChar) && defined(VMS)
#define GetChar() ttgetc()
#endif

#if !defined(GetChar)
#ifdef HAVE_KEYPAD
#define GetChar() getch()
#else
#ifndef USE_GETCHAR
#define USE_GETCHAR
#endif /* !USE_GETCHAR */
#define GetChar() getchar()	/* used to be "getc(stdin)" and "getch()" */
#endif /* HAVE_KEYPAD */
#endif /* !defined(GetChar) */

#if defined(USE_SLANG) && defined(USE_MOUSE)
static int sl_parse_mouse_event(int *x, int *y, int *button)
{
    /* "ESC [ M" has already been processed.  There more characters are
     * expected:  BUTTON X Y
     */
    *button = SLang_getkey();
    switch (*button) {
    case 040:			/* left button */
    case 041:			/* middle button */
    case 042:			/* right button */
	*button -= 040;
	break;

    default:			/* Hmmm.... */
	SLang_flush_input();
	return -1;
    }

    *x = SLang_getkey();
    if (*x == CH_ESC)		/* Undo 7-bit replace for large x - kw */
	*x = SLang_getkey() + 64 - 33;
    else
	*x -= 33;
    *y = SLang_getkey();
    if (*y == CH_ESC)		/* Undo 7-bit replace for large y - kw */
	*y = SLang_getkey() + 64 - 33;
    else
	*y -= 33;
    return 0;
}

static int sl_read_mouse_event(int code)
{
    int mouse_x, mouse_y, button;

    mouse_link = -1;
    if (-1 != sl_parse_mouse_event(&mouse_x, &mouse_y, &button)) {
	if (button == 0)	/* left */
	    return set_clicked_link(mouse_x, mouse_y, FOR_PANEL, 1);

	if (button == 1)	/* middle */
	    return LYReverseKeymap(LYK_VIEW_BOOKMARK);

	if (button == 2)	/* right */
	{
	    /* Right button: go back to prev document.
	     * The problem is that we need to determine
	     * what to return to achieve this.
	     */
	    return LYReverseKeymap(LYK_PREV_DOC);
	}
    }
    if (code == FOR_INPUT || code == FOR_PROMPT)
	return DO_NOTHING;
    else
	return -1;
}
#endif /* USE_SLANG and USE_MOUSE */

static BOOLEAN csi_is_csi = TRUE;
void ena_csi(BOOLEAN flag)
{
    csi_is_csi = flag;
}

#if defined(USE_KEYMAPS)

#ifdef USE_SLANG
#define define_key(string, code) \
	SLkm_define_keysym (string, code, Keymap_List)
#define expand_substring(dst, first, last, final) \
	(SLexpand_escaped_string(dst, (char *)first, (char *)last), 1)
static SLKeyMap_List_Type *Keymap_List;

/* This value should be larger than anything in LYStrings.h */
#define MOUSE_KEYSYM 0x0400
#endif

#define SQUOTE '\''
#define DQUOTE '"'
#define ESCAPE '\\'
#define LPAREN '('
#define RPAREN ')'

/*
 * For ncurses, we use the predefined keysyms, since that lets us also reuse
 * the CSI logic and other special cases for VMS, NCSA telnet, etc.
 */
#ifdef USE_SLANG
# ifdef VMS
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx}
# else
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx},{string1,lynx}
# endif
# define INTERN_KEY(string,lynx,curses)          {string,lynx}
#else
#define INTERN_KEY(string,lynx,curses)           {string,curses}
#define EXTERN_KEY(string,string1,lynx,curses)   {string,curses}
#endif

typedef struct {
    const char *string;
    int value;
} Keysym_String_List;
/* *INDENT-OFF* */
static Keysym_String_List Keysym_Strings [] =
{
    INTERN_KEY( "UPARROW",	UPARROW,	KEY_UP ),
    INTERN_KEY( "DNARROW",	DNARROW,	KEY_DOWN ),
    INTERN_KEY( "RTARROW",	RTARROW,	KEY_RIGHT ),
    INTERN_KEY( "LTARROW",	LTARROW,	KEY_LEFT ),
    INTERN_KEY( "PGDOWN",	PGDOWN,		KEY_NPAGE ),
    INTERN_KEY( "PGUP",		PGUP,		KEY_PPAGE ),
    INTERN_KEY( "HOME",		HOME,		KEY_HOME ),
    INTERN_KEY( "END",		END_KEY,	KEY_END ),
    INTERN_KEY( "F1",		F1,		KEY_F(1) ),
    INTERN_KEY( "DO_KEY",	DO_KEY,		KEY_F(16) ),
    INTERN_KEY( "FIND_KEY",	FIND_KEY,	KEY_FIND ),
    INTERN_KEY( "SELECT_KEY",	SELECT_KEY,	KEY_SELECT ),
    INTERN_KEY( "INSERT_KEY",	INSERT_KEY,	KEY_IC ),
    INTERN_KEY( "REMOVE_KEY",	REMOVE_KEY,	KEY_DC ),
    INTERN_KEY( "DO_NOTHING",	DO_NOTHING,	DO_NOTHING|LKC_ISLKC ),
    INTERN_KEY( NULL,		-1,		ERR )
};
/* *INDENT-ON* */

#ifdef NCURSES_VERSION
/*
 * Ncurses stores the termcap/terminfo names in arrays sorted to match the
 * array of strings in the TERMTYPE struct.
 */
static int lookup_tiname(char *name, NCURSES_CONST char *const *names)
{
    int code;

    for (code = 0; names[code] != 0; code++)
	if (!strcmp(names[code], name))
	    return code;
    return -1;
}

static const char *expand_tiname(const char *first, size_t len, char **result, char *final)
{
    char name[BUFSIZ];
    int code;

    strncpy(name, first, len);
    name[len] = '\0';
    if ((code = lookup_tiname(name, strnames)) >= 0
	|| (code = lookup_tiname(name, strfnames)) >= 0) {
	if (cur_term->type.Strings[code] != 0) {
	    LYstrncpy(*result, cur_term->type.Strings[code], final - *result);
	    (*result) += strlen(*result);
	}
    }
    return first + len;
}

static const char *expand_tichar(const char *first, char **result, char *final)
{
    int ch;
    int limit = 0;
    int radix = 0;
    int value = 0;
    const char *name = 0;

    switch (ch = *first++) {
    case 'E':
    case 'e':
	value = 27;
	break;
    case 'a':
	name = "bel";
	break;
    case 'b':
	value = '\b';
	break;
    case 'f':
	value = '\f';
	break;
    case 'n':
	value = '\n';
	break;
    case 'r':
	value = '\r';
	break;
    case 't':
	value = '\t';
	break;
    case 'v':
	value = '\v';
	break;
    case 'd':
	radix = 10;
	limit = 3;
	break;
    case 'x':
	radix = 16;
	limit = 2;
	break;
    default:
	if (isdigit(ch)) {
	    radix = 8;
	    limit = 3;
	    first--;
	} else {
	    value = *first;
	}
	break;
    }

    if (radix != 0) {
	char *last = 0;
	char tmp[80];

	LYstrncpy(tmp, first, limit);
	value = strtol(tmp, &last, radix);
	if (last != 0 && last != tmp)
	    first += (last - tmp);
    }

    if (name != 0) {
	(void) expand_tiname(name, strlen(name), result, final);
    } else {
	**result = value;
	(*result) += 1;
    }

    return first;
}

static int expand_substring(char *dst, const char *first, const char *last, char *final)
{
    int ch;

    while (first < last) {
	switch (ch = *first++) {
	case ESCAPE:
	    first = expand_tichar(first, &dst, final);
	    break;
	case '^':
	    ch = *first++;
	    if (ch == LPAREN) {
		const char *s = strchr(first, RPAREN);
		char *was = dst;

		if (s == 0)
		    s = first + strlen(first);
		first = expand_tiname(first, s - first, &dst, final);
		if (dst == was)
		    return 0;
		if (*first)
		    first++;
	    } else if (ch == '?') {	/* ASCII delete? */
		*dst++ = 127;
	    } else if ((ch & 0x3f) < 0x20) {	/* ASCII control char? */
		*dst++ = (ch & 0x1f);
	    } else {
		*dst++ = '^';
		first--;	/* not legal... */
	    }
	    break;
	case 0:		/* convert nulls for terminfo */
	    ch = 0200;
	    /* FALLTHRU */
	default:
	    *dst++ = ch;
	    break;
	}
    }
    *dst = '\0';
    return 1;
}
#endif

static void unescaped_char(const char *parse, int *keysym)
{
    size_t len = strlen(parse);
    char buf[BUFSIZ];

    if (len >= 3) {
	expand_substring(buf, parse + 1, parse + len - 1, buf + sizeof(buf) - 1);
	if (strlen(buf) == 1)
	    *keysym = *buf;
    }
}

static BOOLEAN unescape_string(char *src, char *dst, char *final)
{
    BOOLEAN ok = FALSE;

    if (*src == SQUOTE) {
	int keysym;

	unescaped_char(src, &keysym);
	if (keysym >= 0) {
	    dst[0] = keysym;
	    dst[1] = '\0';
	    ok = TRUE;
	}
    } else if (*src == DQUOTE)
	ok = expand_substring(dst, src + 1, src + strlen(src) - 1, final);
    return ok;
}

int map_string_to_keysym(const char *str, int *keysym)
{
    int modifier = 0;

    *keysym = -1;

    if (strncasecomp(str, "LAC:", 4) == 0) {
	char *other = strchr(str + 4, ':');

	if (other) {
	    int othersym = lecname_to_lec(other + 1);
	    char buf[BUFSIZ];

	    if (othersym >= 0 && other - str - 4 < BUFSIZ) {
		strncpy(buf, str + 4, other - str - 4);
		buf[other - str - 4] = '\0';
		*keysym = lacname_to_lac(buf);
		if (*keysym >= 0) {
		    *keysym = LACLEC_TO_LKC0(*keysym, othersym);
		    return (*keysym);
		}
	    }
	}
	*keysym = lacname_to_lac(str + 4);
	if (*keysym >= 0) {
	    *keysym = LAC_TO_LKC0(*keysym);
	    return (*keysym);
	}
    }
    if (strncasecomp(str, "Meta-", 5) == 0) {
	str += 5;
	modifier = LKC_MOD2;
	if (*str) {
	    size_t len = strlen(str);

	    if (len == 1)
		return (*keysym = (UCH(str[0])) | modifier);
	    else if (len == 2 && str[0] == '^' &&
		     (isalpha(UCH(str[1])) ||
		      (TOASCII(str[1]) >= '@@' && TOASCII(str[1]) <= '_')))
		return (*keysym = FROMASCII(UCH(str[1] & 0x1f)) | modifier);
	    else if (len == 2 && str[0] == '^' &&
		     str[1] == '?')
		return (*keysym = CH_DEL | modifier);
	    if (*str == '^' || *str == '\\') {
		char buf[BUFSIZ];

		expand_substring(buf,
				 str,
				 str + HTMIN(len, 28),
				 buf + sizeof(buf) - 1);
		if (strlen(buf) <= 1)
		    return (*keysym = (UCH(buf[0])) | modifier);
	    }
	}
    }
    if (*str == SQUOTE) {
	unescaped_char(str, keysym);
    } else if (isdigit(UCH(*str))) {
	char *tmp;
	long value = strtol(str, &tmp, 0);

	if (!isalnum(UCH(*tmp))) {
	    *keysym = value;
#ifndef USE_SLANG
	    if (*keysym > 255)
		*keysym |= LKC_ISLKC;	/* caller should remove this flag - kw */
#endif
	}
    } else {
	Keysym_String_List *k;

	k = Keysym_Strings;
	while (k->string != NULL) {
	    if (0 == strcmp(k->string, str)) {
		*keysym = k->value;
		break;
	    }
	    k++;
	}
    }

    if (*keysym >= 0)
	*keysym |= modifier;
    return (*keysym);
}

/*
 * Starting at a nonblank character, skip over a token, counting quoted and
 * escaped characters.
 */
static char *skip_keysym(char *parse)
{
    int quoted = 0;
    int escaped = 0;

    while (*parse) {
	if (escaped) {
	    escaped = 0;
	} else if (quoted) {
	    if (*parse == ESCAPE) {
		escaped = 1;
	    } else if (*parse == quoted) {
		quoted = 0;
	    }
	} else if (*parse == ESCAPE) {
	    escaped = 1;
	} else if (*parse == DQUOTE || *parse == SQUOTE) {
	    quoted = *parse;
	} else if (isspace(UCH(*parse))) {
	    break;
	}
	parse++;
    }
    return (quoted || escaped) ? 0 : parse;
}

/*
 * The first token is the string to define, the second is the name (of the
 * keysym) to define it to.
 */
static int setkey_cmd(char *parse)
{
    char *s, *t;
    int keysym;
    char buf[BUFSIZ];

    CTRACE((tfp, "KEYMAP(PA): in=%s", parse));	/* \n-terminated */
    if ((s = skip_keysym(parse)) != 0) {
	if (isspace(UCH(*s))) {
	    *s++ = '\0';
	    s = LYSkipBlanks(s);
	    if ((t = skip_keysym(s)) == 0) {
		CTRACE((tfp, "KEYMAP(SKIP) no key expansion found\n"));
		return -1;
	    }
	    if (t != s)
		*t = '\0';
	    if (map_string_to_keysym(s, &keysym) >= 0) {
		if (!unescape_string(parse, buf, buf + sizeof(buf) - 1)) {
		    CTRACE((tfp, "KEYMAP(SKIP) could unescape key\n"));
		    return 0;	/* Trace the failure and continue. */
		}
		if (LYTraceLogFP == 0) {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x\n", keysym));
		} else {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x, seq='%s'\n", keysym, buf));
		}
		return define_key(buf, keysym);
	    } else {
		CTRACE((tfp, "KEYMAP(SKIP) could not map to keysym\n"));
	    }
	} else {
	    CTRACE((tfp, "KEYMAP(SKIP) junk after key description: '%s'\n", s));
	}
    } else {
	CTRACE((tfp, "KEYMAP(SKIP) no key description\n"));
    }
    return -1;
}

static int unsetkey_cmd(char *parse)
{
    char *s = skip_keysym(parse);

    if (s != parse) {
	*s = '\0';
#ifdef NCURSES_VERSION
	/*
	 * This won't work with Slang.  Remove the definition for the given
	 * keysym.
	 */
	{
	    int keysym;

	    if (map_string_to_keysym(parse, &keysym) >= 0)
		define_key((char *) 0, keysym);
	}
#endif
#ifdef USE_SLANG
	/* Slang implements this, for undefining the string which is associated
	 * with a keysym (the reverse of what we normally want, but may
	 * occasionally find useful).
	 */
	SLang_undefine_key(parse, Keymap_List);
	if (SLang_Error)
	    return -1;
#endif
    }
    return 0;
}

#ifdef FNAMES_8_3
#define FNAME_LYNX_KEYMAPS "_lynxkey.map"
#else
#define FNAME_LYNX_KEYMAPS ".lynx-keymaps"
#endif /* FNAMES_8_3 */

static int read_keymap_file(void)
{
    /* *INDENT-OFF* */
    static struct {
	const char *name;
	int (*func) (char *s);
    } table[] = {
	{ "setkey",   setkey_cmd },
	{ "unsetkey", unsetkey_cmd },
    };
    /* *INDENT-ON* */

    char *line = NULL;
    FILE *fp;
    char file[LY_MAXPATH];
    int linenum;
    size_t n;

    LYAddPathToHome(file, sizeof(file), FNAME_LYNX_KEYMAPS);

    if ((fp = fopen(file, "r")) == 0)
	return 0;

    linenum = 0;
    while (LYSafeGets(&line, fp) != 0) {
	char *s = LYSkipBlanks(line);

	linenum++;

	if ((*s == 0) || (*s == '#'))
	    continue;

	for (n = 0; n < TABLESIZE(table); n++) {
	    size_t len = strlen(table[n].name);

	    if (strlen(s) > len && !strncmp(s, table[n].name, len)
		&& (*(table[n].func)) (LYSkipBlanks(s + len)) < 0)
		fprintf(stderr, FAILED_READING_KEYMAP, linenum, file);
	}
    }
    FREE(line);
    LYCloseInput(fp);
    return 0;
}

static void setup_vtXXX_keymap(void)
{
    /* *INDENT-OFF* */
    static Keysym_String_List table[] = {
	INTERN_KEY( "\033[A",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033OA",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033[B",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033OB",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033[C",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033OC",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033[D",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033OD",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033[1~",	FIND_KEY,	KEY_FIND ),
	INTERN_KEY( "\033[2~",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\033[3~",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\033[4~",	SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY( "\033[5~",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\033[6~",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\033[7~",	HOME,		KEY_HOME),
	INTERN_KEY( "\033[8~",	END_KEY,	KEY_END ),
	INTERN_KEY( "\033[11~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[28~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[29~",	DO_KEY,		KEY_F(16) ),
#if defined(USE_SLANG) && defined(__MINGW32__)
	INTERN_KEY( "\xE0H",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\xE0P",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\xE0M",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\xE0K",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\xE0R",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\xE0S",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\xE0I",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\xE0Q",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\xE0G",	HOME,		KEY_HOME),
	INTERN_KEY( "\xE0O",	END_KEY,	KEY_END ),
#endif
#if defined(USE_SLANG) && !defined(VMS)
	INTERN_KEY(	"^(ku)", UPARROW,	KEY_UP ),
	INTERN_KEY(	"^(kd)", DNARROW,	KEY_DOWN ),
	INTERN_KEY(	"^(kr)", RTARROW,	KEY_RIGHT ),
	INTERN_KEY(	"^(kl)", LTARROW,	KEY_LEFT ),
	INTERN_KEY(	"^(@@0)", FIND_KEY,	KEY_FIND ),
	INTERN_KEY(	"^(kI)", INSERT_KEY,	KEY_IC ),
	INTERN_KEY(	"^(kD)", REMOVE_KEY,	KEY_DC ),
	INTERN_KEY(	"^(*6)", SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY(	"^(kP)", PGUP,		KEY_PPAGE ),
	INTERN_KEY(	"^(kN)", PGDOWN,	KEY_NPAGE ),
	INTERN_KEY(	"^(@@7)", END_KEY,	KEY_END ),
	INTERN_KEY(	"^(kh)", HOME,		KEY_HOME),
	INTERN_KEY(	"^(k1)", F1,		KEY_F(1) ),
	INTERN_KEY(	"^(F6)", DO_KEY,	KEY_F(16) ),
#endif /* SLANG && !VMS */
    };
    /* *INDENT-ON* */

    size_t n;

    for (n = 0; n < TABLESIZE(table); n++)
	define_key(table[n].string, table[n].value);
}

int lynx_initialize_keymaps(void)
{
#ifdef USE_SLANG
    int i;
    char keybuf[2];

    /* The escape sequences may contain embedded termcap strings.  Make
     * sure the library is initialized for that.
     */
    SLtt_get_terminfo();

    if (NULL == (Keymap_List = SLang_create_keymap("Lynx", NULL)))
	return -1;

    keybuf[1] = 0;
    for (i = 1; i < 256; i++) {
	keybuf[0] = (char) i;
	define_key(keybuf, i);
    }

    setup_vtXXX_keymap();
    define_key("\033[M", MOUSE_KEYSYM);

    if (SLang_Error)
	SLang_exit_error("Unable to initialize keymaps");
#else
    setup_vtXXX_keymap();
#endif
    return read_keymap_file();
}

#endif /* USE_KEYMAPS */

#if defined(USE_MOUSE) && (defined(NCURSES))
static int LYmouse_menu(int x, int y, int atlink, int code)
{
#define ENT_ONLY_DOC	1
#define ENT_ONLY_LINK	2
    /* *INDENT-OFF* */
    static const struct {
	const char *txt;
	int  action;
	unsigned int  flag;
    } possible_entries[] = {
	{"Quit",			LYK_ABORT,		ENT_ONLY_DOC},
	{"Home page",			LYK_MAIN_MENU,		ENT_ONLY_DOC},
	{"Previous document",		LYK_PREV_DOC,		ENT_ONLY_DOC},
	{"Beginning of document",	LYK_HOME,		ENT_ONLY_DOC},
	{"Page up",			LYK_PREV_PAGE,		ENT_ONLY_DOC},
	{"Half page up",		LYK_UP_HALF,		ENT_ONLY_DOC},
	{"Two lines up",		LYK_UP_TWO,		ENT_ONLY_DOC},
	{"History",			LYK_HISTORY,		ENT_ONLY_DOC},
	{"Help",			LYK_HELP,		0},
	{"Do nothing (refresh)",	LYK_REFRESH,		0},
	{"Load again",			LYK_RELOAD,		ENT_ONLY_DOC},
	{"Edit Doc URL and load",	LYK_ECGOTO,		ENT_ONLY_DOC},
	{"Edit Link URL and load",	LYK_ELGOTO,		ENT_ONLY_LINK},
	{"Show info",			LYK_INFO,		0},
	{"Search",			LYK_WHEREIS,		ENT_ONLY_DOC},
	{"Print",			LYK_PRINT,		ENT_ONLY_DOC},
	{"Two lines down",		LYK_DOWN_TWO,		ENT_ONLY_DOC},
	{"Half page down",		LYK_DOWN_HALF,		ENT_ONLY_DOC},
	{"Page down",			LYK_NEXT_PAGE,		ENT_ONLY_DOC},
	{"End of document",		LYK_END,		ENT_ONLY_DOC},
	{"Bookmarks",			LYK_VIEW_BOOKMARK,	ENT_ONLY_DOC},
	{"Cookie jar",			LYK_COOKIE_JAR,		ENT_ONLY_DOC},
	{"Search index",		LYK_INDEX_SEARCH,	ENT_ONLY_DOC},
	{"Set Options",			LYK_OPTIONS,		ENT_ONLY_DOC},
	{"Activate this link",		LYK_SUBMIT,		ENT_ONLY_LINK},
	{"Download",			LYK_DOWNLOAD,		ENT_ONLY_LINK}
    };
    /* *INDENT-ON* */

#define TOTAL_MENUENTRIES	TABLESIZE(possible_entries)
    const char *choices[TOTAL_MENUENTRIES + 1];
    int actions[TOTAL_MENUENTRIES];

    int c, c1, retlac, filter_out = (atlink ? ENT_ONLY_DOC : ENT_ONLY_LINK);

    c = c1 = 0;
    while (c < (int) TOTAL_MENUENTRIES) {
	if (!(possible_entries[c].flag & filter_out)) {
	    choices[c1] = possible_entries[c].txt;
	    actions[c1++] = possible_entries[c].action;
	}
	c++;
    }
    choices[c1] = NULL;

    /* Somehow the mouse is over the number instead of being over the
       name, so we decrease x. */
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x - 5 : 1),
		      choices, c1, FALSE, TRUE);

    /*
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
     */
    if (term_options) {
	retlac = LYK_DO_NOTHING;
	term_options = FALSE;
    } else {
	retlac = actions[c];
    }

    if (code == FOR_INPUT && mouse_link == -1) {
	switch (retlac) {
	case LYK_ABORT:
	    retlac = LYK_QUIT;	/* a bit softer... */
	    /* fall through */
	case LYK_MAIN_MENU:
	case LYK_PREV_DOC:
	case LYK_HOME:
	case LYK_PREV_PAGE:
	case LYK_UP_HALF:
	case LYK_UP_TWO:
	case LYK_HISTORY:
	case LYK_HELP:
/*	    case LYK_REFRESH:*/
	case LYK_RELOAD:
	case LYK_ECGOTO:
	case LYK_INFO:
	case LYK_WHEREIS:
	case LYK_PRINT:
	case LYK_DOWN_TWO:
	case LYK_DOWN_HALF:
	case LYK_NEXT_PAGE:
	case LYK_END:
	case LYK_VIEW_BOOKMARK:
	case LYK_COOKIE_JAR:
	case LYK_INDEX_SEARCH:
	case LYK_OPTIONS:
	    mouse_link = -3;	/* so LYgetch_for() passes it on - kw */
	}
    }
    if (retlac == LYK_DO_NOTHING ||
	retlac == LYK_REFRESH) {
	mouse_link = -1;	/* mainloop should not change cur link - kw */
    }
    if (code == FOR_INPUT && retlac == LYK_DO_NOTHING) {
	repaint_main_statusline(FOR_INPUT);
    }
    return retlac;
}
#endif /* USE_MOUSE && (NCURSES || PDCURSES) */

#if defined(USE_KEYMAPS) && defined(USE_SLANG)
/************************************************************************/

static int current_sl_modifier = 0;

/* We cannot guarantee the type for 'GetChar', and should not use a cast. */
static int myGetChar(void)
{
    int i = GetChar();

    if (i == 0)			/* trick to get NUL char through - kw */
	current_sl_modifier = LKC_ISLKC;
    return i;
}

static int LYgetch_for(int code)
{
    SLang_Key_Type *key;
    int keysym;

    current_sl_modifier = 0;

    key = SLang_do_key(Keymap_List, myGetChar);
    if ((key == NULL) || (key->type != SLKEY_F_KEYSYM)) {
#ifdef __MINGW32__
	if ((key == NULL) && (current_sl_modifier == LKC_ISLKC)) {
	    key = SLang_do_key(Keymap_List, myGetChar);
	    keysym = key->f.keysym;
	    switch (keysym) {
	    case 'H':
		keysym = UPARROW;
		break;
	    case 'P':
		keysym = DNARROW;
		break;
	    case 'M':
		keysym = RTARROW;
		break;
	    case 'K':
		keysym = LTARROW;
		break;
	    case 'R':
		keysym = INSERT_KEY;
		break;
	    case 'S':
		keysym = REMOVE_KEY;
		break;
	    case 'I':
		keysym = PGUP;
		break;
	    case 'Q':
		keysym = PGDOWN;
		break;
	    case 'G':
		keysym = HOME;
		break;
	    case 'O':
		keysym = END_KEY;
		break;
	    case ';':
		keysym = F1;
		break;
	    }
	    return (keysym);
	}
#endif

	return (current_sl_modifier ? 0 : DO_NOTHING);
    }

    keysym = key->f.keysym;

#if defined (USE_MOUSE)
    if (keysym == MOUSE_KEYSYM)
	return sl_read_mouse_event(code);
#endif

    if (keysym < 0)
	return 0;

    if (keysym & (LKC_ISLECLAC | LKC_ISLAC))
	return (keysym);

    current_sl_modifier = 0;
    if (LKC_HAS_ESC_MOD(keysym)) {
	current_sl_modifier = LKC_MOD2;
	keysym &= LKC_MASK;
    }

    if (keysym + 1 >= KEYMAP_SIZE)
	return 0;

    return (keysym | current_sl_modifier);
}

/************************************************************************/
#else /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

/*
 * LYgetch() translates some escape sequences and may fake noecho.
 */
#define found_CSI(first,second) ((second) == '[' || (first) == 155)

static int LYgetch_for(int code)
{
    int a, b, c, d = -1;
    int current_modifier = 0;
    BOOLEAN done_esc = FALSE;

    have_levent = 0;

  re_read:
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
    if (errno == EINTR)
	set_errno(0);		/* reset - kw */
#endif /* UCX && VAXC */
#ifndef USE_SLANG
    clearerr(stdin);		/* needed here for ultrix and SOCKETSHR, but why? - FM */
#endif /* !USE_SLANG */
#if !defined(USE_SLANG) || defined(VMS) || defined(DJGPP_KEYHANDLER)
    c = GetChar();
    lynx_nl2crlf(FALSE);
#else
    if (LYCursesON) {
	c = GetChar();
	lynx_nl2crlf(FALSE);
    } else {
	c = getchar();
	if (c == EOF && errno == EINTR)		/* Ctrl-Z causes EINTR in getchar() */
	    clearerr(stdin);
	if (feof(stdin) || ferror(stdin) || c == EOF) {
#ifdef IGNORE_CTRL_C
	    if (sigint)
		sigint = FALSE;
#endif /* IGNORE_CTRL_C */
	    CTRACE((tfp, "GETCH: Translate ^C to ^G.\n"));
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
	}
    }
#endif /* !USE_SLANG || VMS */

    CTRACE((tfp, "GETCH: Got %#x.\n", c));
#ifdef MISC_EXP
    if (LYNoZapKey > 1 && errno != EINTR &&
	(c == EOF
#ifdef USE_SLANG
	 || (c == 0xFFFF)
#endif
	)) {
	int fd, kbd_fd;

	CTRACE((tfp,
		"nozap: Got EOF, curses %s, stdin is %p, LYNoZapKey reduced from %d to 0.\n",
		LYCursesON ? "on" : "off", stdin, LYNoZapKey));
	LYNoZapKey = 0;		/* 2 -> 0 */
	if ((fd = fileno(stdin)) == 0 && !isatty(fd) &&
	    (kbd_fd = LYConsoleInputFD(FALSE)) == fd) {
	    char *term_name;
	    int new_fd = INVSOC;

	    if ((term_name = ttyname(fileno(stdout))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC &&
		(term_name = ttyname(fileno(stderr))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC) {
		term_name = ctermid(NULL);
		new_fd = open(term_name, O_RDONLY);
	    }
	    CTRACE((tfp, "nozap: open(%s) returned %d.\n", term_name, new_fd));
	    if (new_fd >= 0) {
		FILE *frp;

		close(new_fd);
		frp = freopen(term_name, "r", stdin);
		CTRACE((tfp,
			"nozap: freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
			term_name, frp, stdin, fileno(stdin)));
		if (LYCursesON) {
		    stop_curses();
		    start_curses();
		    LYrefresh();
		}
		goto re_read;
	    }
	}
    }
#endif /* MISC_EXP */

#ifdef USE_GETCHAR
    if (c == EOF && errno == EINTR)	/* Ctrl-Z causes EINTR in getchar() */
	goto re_read;
#else
    if (c == EOF && errno == EINTR) {

#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		recent_sizechange));
	if (!recent_sizechange) {	/* not yet detected by ourselves */
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	}
#else /* HAVE_SIZECHANGE || USE_SLANG */
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
	set_errno(0);		/* reset - kw */
#endif /* UCX && VAXC */
	return (DO_NOTHING);
    }
#endif /* USE_GETCHAR */

#ifdef USE_SLANG
    if (c == 0xFFFF && LYCursesON) {
#ifdef IGNORE_CTRL_C
	if (sigint) {
	    sigint = FALSE;
	    goto re_read;
	}
#endif /* IGNORE_CTRL_C */
	return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
    }
#else /* not USE_SLANG: */
    if (feof(stdin) || ferror(stdin) || c == EOF) {
	if (recent_sizechange)
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
#ifdef IGNORE_CTRL_C
	if (sigint) {
	    sigint = FALSE;
	    /* clearerr(stdin);  don't need here if stays above - FM */
	    goto re_read;
	}
#endif /* IGNORE_CTRL_C */
#if !defined(USE_GETCHAR) && !defined(VMS) && !defined(NCURSES)
	if (c == ERR && errno == EINTR)		/* may have been handled signal - kw */
	    goto re_read;
#endif /* USE_GETCHAR */

	cleanup();
	exit_immediately(EXIT_SUCCESS);
    }
#endif /* USE_SLANG */

    if (!escape_bound
	&& (c == CH_ESC || (csi_is_csi && c == UCH(CH_ESC_PAR)))) {
	/* handle escape sequence  S/390 -- gil -- 2024 */
	done_esc = TRUE;	/* Flag: we did it, not keypad() */
	b = GetChar();

	if (b == '[' || b == 'O') {
	    a = GetChar();
	} else {
	    a = b;
	}

	switch (a) {
	case 'A':
	    c = UPARROW;
	    break;
	case 'B':
	    c = DNARROW;
	    break;
	case 'C':
	    c = RTARROW;
	    break;
	case 'D':
	    c = LTARROW;
	    break;
	case 'q':		/* vt100 application keypad 1 */
	    c = END_KEY;
	    break;
	case 'r':		/* vt100 application keypad 2 */
	    c = DNARROW;
	    break;
	case 's':		/* vt100 application keypad 3 */
	    c = PGDOWN;
	    break;
	case 't':		/* vt100 application keypad 4 */
	    c = LTARROW;
	    break;
	case 'v':		/* vt100 application keypad 6 */
	    c = RTARROW;
	    break;
	case 'w':		/* vt100 application keypad 7 */
	    c = HOME;
	    break;
	case 'x':		/* vt100 application keypad 8 */
	    c = UPARROW;
	    break;
	case 'y':		/* vt100 application keypad 9 */
	    c = PGUP;
	    break;
	case 'M':
#if defined(USE_SLANG) && defined(USE_MOUSE)
	    if (found_CSI(c, b)) {
		c = sl_read_mouse_event(code);
	    } else
#endif
		c = '\n';	/* keypad enter on pc ncsa telnet */
	    break;

	case 'm':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = '-';	/* keypad on pc ncsa telnet */
	    break;
	case 'k':
	    if (b == 'O')
		c = '+';	/* keypad + on my xterminal :) */
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case 'l':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = '+';	/* keypad on pc ncsa telnet */
	    break;
	case 'P':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = F1;
	    break;
	case 'u':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = F1;		/* macintosh help button */
	    break;
	case 'p':
#ifdef VMS
	    if (b == 'O')
#endif /* VMS */
		c = '0';	/* keypad 0 */
	    break;
	case '1':		/* VTxxx  Find  */
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
		c = FIND_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '2':
	    if (found_CSI(c, b)) {
		if ((d = GetChar()) == '~')	/* VTxxx Insert */
		    c = INSERT_KEY;
		else if ((d == '8' ||
			  d == '9') &&
			 GetChar() == '~') {
		    if (d == '8')	/* VTxxx   Help */
			c = F1;
		    else if (d == '9')	/* VTxxx    Do  */
			c = DO_KEY;
		    d = -1;
		}
	    } else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '3':			     /** VTxxx Delete **/
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
		c = REMOVE_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '4':			     /** VTxxx Select **/
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
		c = SELECT_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '5':			     /** VTxxx PrevScreen **/
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
		c = PGUP;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '6':			     /** VTxxx NextScreen **/
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
		c = PGDOWN;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '[':			     /** Linux F1-F5: ^[[[A etc. **/
	    if (found_CSI(c, b)) {
		if ((d = GetChar()) == 'A')
		    c = F1;
		break;
	    }
	    /* FALLTHRU */
	default:
	    if (c == CH_ESC && a == b && !found_CSI(c, b)) {
		current_modifier = LKC_MOD2;
		c = a;
		/* We're not yet done if ESC + curses-keysym: */
		done_esc = (BOOL) ((a & ~0xFF) == 0);
		break;
	    }
	    CTRACE((tfp, "Unknown key sequence: %d:%d:%d\n", c, b, a));
	    CTRACE_SLEEP(MessageSecs);
	    break;
	}
	if (isdigit(a) && found_CSI(c, b) && d != -1 && d != '~')
	    d = GetChar();
	if (!done_esc && (a & ~0xFF) == 0) {
	    if (a == b && !found_CSI(c, b) && c == CH_ESC) {
		current_modifier = LKC_MOD2;
		c = a;
		done_esc = TRUE;
	    } else {
		done_esc = TRUE;
	    }
	}
    }
#ifdef USE_KEYMAPS
    /* Extract a single code if two are merged: */
    if (c >= 0 && (c & LKC_ISLECLAC)) {
	if (!(code == FOR_INPUT || code == FOR_PROMPT))
	    c = LKC2_TO_LKC(c);
    } else if (c >= 0 && (c & LKC_ISLKC)) {
	c &= ~LKC_ISLKC;
	done_esc = TRUE;	/* already a lynxkeycode, skip keypad switches - kw */
    }
    if (c >= 0 && LKC_HAS_ESC_MOD(c)) {
	current_modifier = LKC_MOD2;
	c &= LKC_MASK;
    }
    if (c >= 0 && (c & (LKC_ISLECLAC | LKC_ISLAC))) {
	done_esc = TRUE;	/* already a lynxactioncode, skip keypad switches - iz */
    }
#endif
    if (done_esc) {
	/* don't do keypad() switches below, we already got it - kw */
    } else {
#ifdef HAVE_KEYPAD
	/*
	 * Convert keypad() mode keys into Lynx defined keys.
	 */
	switch (c) {
	case KEY_DOWN:		/* The four arrow keys ... */
	    c = DNARROW;
	    break;
	case KEY_UP:
	    c = UPARROW;
	    break;
	case KEY_LEFT:
	    c = LTARROW;
	    break;
	case KEY_RIGHT:	/* ... */
	    c = RTARROW;
	    break;
#if defined(SH_EX) && defined(DOSPATH)	/* for NEC PC-9800 1998/08/30 (Sun) 21:50:35 */
	case KEY_C2:
	    c = DNARROW;
	    break;
	case KEY_A2:
	    c = UPARROW;
	    break;
	case KEY_B1:
	    c = LTARROW;
	    break;
	case KEY_B3:
	    c = RTARROW;
	    break;
	case PAD0:		/* PC-9800 Ins */
	    c = INSERT_KEY;
	    break;
	case PADSTOP:		/* PC-9800 DEL */
	    c = REMOVE_KEY;
	    break;
#endif /* SH_EX */
	case KEY_HOME:		/* Home key (upward+left arrow) */
	    c = HOME;
	    break;
	case KEY_CLEAR:	/* Clear screen */
	    c = 18;		/* CTRL-R */
	    break;
	case KEY_NPAGE:	/* Next page */
	    c = PGDOWN;
	    break;
	case KEY_PPAGE:	/* Previous page */
	    c = PGUP;
	    break;
	case KEY_LL:		/* home down or bottom (lower left) */
	    c = END_KEY;
	    break;
#if defined(KEY_A1) && defined(KEY_C3)
	    /* The keypad is arranged like this: */
	    /*    a1    up    a3   */
	    /*   left   b2  right  */
	    /*    c1   down   c3   */
	case KEY_A1:		/* upper left of keypad */
	    c = HOME;
	    break;
	case KEY_A3:		/* upper right of keypad */
	    c = PGUP;
	    break;
	case KEY_B2:		/* center of keypad */
	    c = DO_NOTHING;
	    break;
	case KEY_C1:		/* lower left of keypad */
	    c = END_KEY;
	    break;
	case KEY_C3:		/* lower right of keypad */
	    c = PGDOWN;
	    break;
#endif /* defined(KEY_A1) && defined(KEY_C3) */
#ifdef KEY_ENTER
	case KEY_ENTER:	/* enter/return      */
	    c = '\n';
	    break;
#endif /* KEY_ENTER */
#ifdef PADENTER			/* PDCURSES */
	case PADENTER:
	    c = '\n';
	    break;
#endif /* PADENTER */
#ifdef KEY_END
	case KEY_END:		/* end key           001 */
	    c = END_KEY;
	    break;
#endif /* KEY_END */
#ifdef KEY_HELP
	case KEY_HELP:		/* help key          001 */
	    c = F1;
	    break;
#endif /* KEY_HELP */
#ifdef KEY_BACKSPACE
	case KEY_BACKSPACE:
	    c = CH_DEL;		/* backspace key (delete, not Ctrl-H)  S/390 -- gil -- 2041 */
	    break;
#endif /* KEY_BACKSPACE */
	case KEY_F(1):
	    c = F1;		/* VTxxx Help */
	    break;
#if defined(KEY_F) && !defined(__DJGPP__) && !defined(_WINDOWS)
	case KEY_F(16):
	    c = DO_KEY;		/* VTxxx Do */
	    break;
#endif /* KEY_F */
#ifdef KEY_REDO
	case KEY_REDO:		/* VTxxx Do */
	    c = DO_KEY;
	    break;
#endif /* KEY_REDO */
#ifdef KEY_FIND
	case KEY_FIND:
	    c = FIND_KEY;	/* VTxxx Find */
	    break;
#endif /* KEY_FIND */
#ifdef KEY_SELECT
	case KEY_SELECT:
	    c = SELECT_KEY;	/* VTxxx Select */
	    break;
#endif /* KEY_SELECT */
#ifdef KEY_IC
	case KEY_IC:
	    c = INSERT_KEY;	/* VTxxx Insert */
	    break;
#endif /* KEY_IC */
#ifdef KEY_DC
	case KEY_DC:
	    c = REMOVE_KEY;	/* VTxxx Remove */
	    break;
#endif /* KEY_DC */
#ifdef KEY_BTAB
	case KEY_BTAB:
	    c = BACKTAB_KEY;	/* Back tab, often Shift-Tab */
	    break;
#endif /* KEY_BTAB */
#ifdef KEY_RESIZE
	case KEY_RESIZE:	/* size change detected by ncurses */
#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	    /* Make call to detect new size, if that may be implemented.
	     * The call may set recent_sizechange (except for USE_SLANG),
	     * which will tell mainloop() to refresh. - kw
	     */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange so far is %d\n",
		    recent_sizechange));
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
#else /* HAVE_SIZECHANGE || USE_SLANG */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange is %d\n",
		    recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
	    if (!recent_sizechange) {
#if 0				/* assumption seems flawed? */
		/* Not detected by us or already processed by us.  It can
		 * happens that ncurses lags behind us in detecting the change,
		 * since its own SIGTSTP handler is not installed so detecting
		 * happened *at the end* of the last refresh.  Tell it to
		 * refresh again...  - kw
		 */
		LYrefresh();
#endif
#if defined(NCURSES)
		/*
		 * Work-around for scenario (Linux libc5) where we got a
		 * recent sizechange before reading KEY_RESIZE.  If we do
		 * not reset the flag, we'll next get an EOF read, which
		 * causes Lynx to exit.
		 */
		recent_sizechange = TRUE;
#endif
		/*
		 * May be just the delayed effect of mainloop()'s call to
		 * resizeterm().  Pretend we haven't read anything yet, don't
		 * return.  - kw
		 */
		goto re_read;
	    }
	    /*
	     * Yep, we agree there was a change.  Return now so that the caller
	     * can react to it.  - kw
	     */
	    c = DO_NOTHING;
	    break;
#endif /* KEY_RESIZE */

/* The following maps PDCurses keys away from lynx reserved values */
#if (defined(_WINDOWS) || defined(__DJGPP__)) && !defined(USE_SLANG)
	case KEY_F(2):
	    c = 0x213;
	    break;
	case KEY_F(3):
	    c = 0x214;
	    break;
	case KEY_F(4):
	    c = 0x215;
	    break;
	case KEY_F(5):
	    c = 0x216;
	    break;
	case KEY_F(6):
	    c = 0x217;
	    break;
	case KEY_F(7):
	    c = 0x218;
	    break;
#endif /* PDCurses */

#if defined(USE_MOUSE)
/********************************************************************/

#if defined(NCURSES) || defined(PDCURSES)
	case KEY_MOUSE:
	    CTRACE((tfp, "KEY_MOUSE\n"));
	    if (code == FOR_CHOICE) {
		c = MOUSE_KEY;	/* Will be processed by the caller */
	    }
#if defined(NCURSES)
	    else if (code == FOR_SINGLEKEY) {
		MEVENT event;

		getmouse(&event);	/* Completely ignore event - kw */
		c = DO_NOTHING;
	    }
#endif
	    else {
#if defined(NCURSES)
		MEVENT event;
		int err;
		int lac = LYK_UNKNOWN;

		c = -1;
		mouse_link = -1;
		err = getmouse(&event);
		if (err != OK) {
		    CTRACE((tfp, "Mouse error: no event available!\n"));
		    return (code == FOR_PANEL ? 0 : DO_NOTHING);
		}
		levent = event;	/* Allow setting pos in entry fields */
		if (event.bstate & BUTTON1_CLICKED) {
		    c = set_clicked_link(event.x, event.y, code, 1);
		} else if (event.bstate & BUTTON1_DOUBLE_CLICKED) {
		    c = set_clicked_link(event.x, event.y, code, 2);
		    if (c == LAC_TO_LKC0(LYK_SUBMIT) && code == FOR_INPUT)
			lac = LYK_SUBMIT;
		} else if (event.bstate & BUTTON3_CLICKED) {
		    c = LAC_TO_LKC0(LYK_PREV_DOC);
		} else if (code == FOR_PROMPT
		    /* Cannot ignore: see LYCurses.c */
			   || (event.bstate &
			       (BUTTON1_PRESSED | BUTTON1_RELEASED
				| BUTTON2_PRESSED | BUTTON2_RELEASED
				| BUTTON3_PRESSED | BUTTON3_RELEASED))) {
		    /* Completely ignore - don't return anything, to
		       avoid canceling the prompt - kw */
		    goto re_read;
		} else if (event.bstate & BUTTON2_CLICKED) {
		    int atlink;

		    c = set_clicked_link(event.x, event.y, code, 1);
		    atlink = (c == LAC_TO_LKC0(LYK_ACTIVATE));
		    if (!atlink)
			mouse_link = -1;	/* Forget about approx stuff. */

		    lac = LYmouse_menu(event.x, event.y, atlink, code);
		    if (lac == LYK_SUBMIT) {
			if (mouse_link == -1)
			    lac = LYK_ACTIVATE;
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			else if (mouse_link >= 0 &&
				 textfields_need_activation &&
				 links[mouse_link].type == WWW_FORM_LINK_TYPE &&
				 F_TEXTLIKE(links[mouse_link].l_form->type))
			    lac = LYK_ACTIVATE;
#endif
		    }
		    if (lac == LYK_ACTIVATE && mouse_link == -1) {
			HTAlert(gettext("No link chosen"));
			lac = LYK_REFRESH;
		    }
		    c = LAC_TO_LKC(lac);
#if 0				/* Probably not necessary any more - kw */
		    lynx_force_repaint();
		    LYrefresh();
#endif
		}
		if (code == FOR_INPUT && mouse_link == -1 &&
		    lac != LYK_REFRESH && lac != LYK_SUBMIT) {
		    ungetmouse(&event);		/* Caller will process this. */
		    wgetch(LYwin);	/* ungetmouse puts KEY_MOUSE back */
		    c = MOUSE_KEY;
		}
#else /* pdcurses version */

#define H_CMD_AREA	6
#define HIST_CMD_2	12
#define V_CMD_AREA	1

		int left = H_CMD_AREA;
		int right = (LYcolLimit - H_CMD_AREA - 1);

		/* yes, I am assuming that my screen will be a certain width. */

		int tick_count;
		char *p = NULL;
		char mouse_info[128];
		static int old_click = 0;	/* [m Sec] */

		c = -1;
		mouse_link = -1;

		if (!system_is_NT) {
		    tick_count = GetTickCount();

		    /* Guard Mouse button miss click */
		    if ((tick_count - old_click) < 700) {
			c = DO_NOTHING;
			break;
		    } else {
			old_click = tick_count;
		    }
		}
		request_mouse_pos();

		if (BUTTON_STATUS(1) & BUTTON_PRESSED) {
		    if (MOUSE_Y_POS > (LYlines - V_CMD_AREA - 1)) {
			/* Screen BOTTOM */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;
			    p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;
			    p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';
			    p = "Cancel";
			} else {
			    c = PGDOWN;
			    p = "PGDOWN";
			}
		    } else if (MOUSE_Y_POS < V_CMD_AREA) {
			/* Screen TOP */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;
			    p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;
			    p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';
			    p = "Cancel";
			} else {
			    c = PGUP;
			    p = "PGUP";
			}
		    } else {
			c = set_clicked_link(MOUSE_X_POS,
					     MOUSE_Y_POS,
					     FOR_PANEL, 1);
		    }
		}
		if (p && c != -1) {
		    snprintf(mouse_info, 128, "Mouse = 0x%x, [%s]", c, p);
		    SetConsoleTitle(mouse_info);
		}
#endif /* !(WIN_EX) */
		if ((c + 1) >= KEYMAP_SIZE && (c & LKC_ISLAC))
		    return (c);
	    }
	    break;
#endif /* NCURSES || PDCURSES */

/********************************************************************/
#endif /* USE_MOUSE */

	}
#endif /* HAVE_KEYPAD */
#ifdef DJGPP_KEYHANDLER
	switch (c) {
	case K_Down:		/* The four arrow keys ... */
	case K_EDown:
	    c = DNARROW;
	    break;
	case K_Up:
	case K_EUp:
	    c = UPARROW;
	    break;
	case K_Left:
	case K_ELeft:
	    c = LTARROW;
	    break;
	case K_Right:		/* ... */
	case K_ERight:
	    c = RTARROW;
	    break;
	case K_Home:		/* Home key (upward+left arrow) */
	case K_EHome:
	    c = HOME;
	    break;
	case K_PageDown:	/* Next page */
	case K_EPageDown:
	    c = PGDOWN;
	    break;
	case K_PageUp:		/* Previous page */
	case K_EPageUp:
	    c = PGUP;
	    break;
	case K_End:		/* home down or bottom (lower left) */
	case K_EEnd:
	    c = END_KEY;
	    break;
	case K_F1:		/* F1 key */
	    c = F1;
	    break;
	case K_Insert:		/* Insert key */
	case K_EInsert:
	    c = INSERT_KEY;
	    break;
	case K_Delete:		/* Delete key */
	case K_EDelete:
	    c = REMOVE_KEY;
	    break;
	case K_Alt_Escape:	/* Alt-Escape */
	    c = 0x1a7;
	    break;
	case K_Control_At:	/* CTRL-@@ */
	    c = 0x1a8;
	    break;
	case K_Alt_Backspace:	/* Alt-Backspace */
	    c = 0x1a9;
	    break;
	case K_BackTab:	/* BackTab */
	    c = BACKTAB_KEY;
	    break;
	}
#endif /* DGJPP_KEYHANDLER */
#if defined(USE_SLANG) && (defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(DJGPP_KEYHANDLER)  && !defined(USE_KEYMAPS)
	switch (c) {
	case SL_KEY_DOWN:	/* The four arrow keys ... */
	    c = DNARROW;
	    break;
	case SL_KEY_UP:
	    c = UPARROW;
	    break;
	case SL_KEY_LEFT:
	    c = LTARROW;
	    break;
	case SL_KEY_RIGHT:	/* ... */
	    c = RTARROW;
	    break;
	case SL_KEY_HOME:	/* Home key (upward+left arrow) */
	case SL_KEY_A1:	/* upper left of keypad */
	    c = HOME;
	    break;
	case SL_KEY_NPAGE:	/* Next page */
	case SL_KEY_C3:	/* lower right of keypad */
	    c = PGDOWN;
	    break;
	case SL_KEY_PPAGE:	/* Previous page */
	case SL_KEY_A3:	/* upper right of keypad */
	    c = PGUP;
	    break;
	case SL_KEY_END:	/* home down or bottom (lower left) */
	case SL_KEY_C1:	/* lower left of keypad */
	    c = END_KEY;
	    break;
	case SL_KEY_F(1):	/* F1 key */
	    c = F1;
	    break;
	case SL_KEY_IC:	/* Insert key */
	    c = INSERT_KEY;
	    break;
	case SL_KEY_DELETE:	/* Delete key */
	    c = REMOVE_KEY;
	    break;
	}
#endif /* USE_SLANG && __DJGPP__ && !DJGPP_KEYHANDLER && !USE_KEYMAPS */
    }

    if (c & (LKC_ISLAC | LKC_ISLECLAC))
	return (c);
    if ((c + 1) >= KEYMAP_SIZE) {
	/*
	 * Don't return raw values for KEYPAD symbols which we may have missed
	 * in the switch above if they are obviously invalid when used as an
	 * index into (e.g.) keypad[].  - KW
	 */
	return (0);
    } else {
	return (c | current_modifier);
    }
}

/************************************************************************/
#endif /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

int LYgetch(void)
{
    return LYReadCmdKey(FOR_PANEL);
}

/*
 * Read a single keystroke, allows mouse-selection.
 */
int LYgetch_choice(void)
{
    int ch = LYReadCmdKey(FOR_CHOICE);

    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, allows mouse events.
 */
int LYgetch_input(void)
{
    int ch = LYReadCmdKey(FOR_INPUT);

    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, ignoring case by translating it to uppercase.
 * Ignore mouse events, if any.
 */
int LYgetch_single(void)
{
    int ch = LYReadCmdKey(FOR_SINGLEKEY);

    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    else if (ch > 0 && ch < 256)
	ch = TOUPPER(ch);	/* will ignore case of result */
    return ch;
}

/*
 * Convert a null-terminated string to lowercase
 */
void LYLowerCase(char *arg_buffer)
{
    register unsigned char *buffer = (unsigned char *) arg_buffer;
    size_t i;

    for (i = 0; buffer[i]; i++)
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:04:55 */
    {
	if ((buffer[i] & 0x80) != 0
	    && buffer[i + 1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOLOWER(buffer[i]));
	}
    }
#else
	buffer[i] = TOLOWER(buffer[i]);
#endif
}

/*
 * Convert a null-terminated string to uppercase
 */
void LYUpperCase(char *arg_buffer)
{
    register unsigned char *buffer = (unsigned char *) arg_buffer;
    size_t i;

    for (i = 0; buffer[i]; i++)
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:05:10 */
    {
	if ((buffer[i] & 0x80) != 0
	    && buffer[i + 1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOUPPER(buffer[i]));
	}
    }
#else
	buffer[i] = UCH(TOUPPER(buffer[i]));
#endif
}

/*
 * Remove newlines from a string, returning true if we removed any.
 */
BOOLEAN LYRemoveNewlines(char *buffer)
{
    if (buffer != 0) {
	register char *buf = buffer;

	for (; *buf && *buf != '\n' && *buf != '\r'; buf++) ;
	if (*buf) {
	    /* runs very seldom */
	    char *old = buf;

	    for (; *old; old++) {
		if (*old != '\n' && *old != '\r')
		    *buf++ = *old;
	    }
	    *buf = '\0';
	    return TRUE;
	}
    }
    return FALSE;
}

/*
 * Remove leading/trailing whitespace from a string, reduce runs of embedded
 * whitespace to single blanks.
 */
char *LYReduceBlanks(char *buffer)
{
    if (non_empty(buffer)) {
	LYTrimLeading(buffer);
	LYTrimTrailing(buffer);
	convert_to_spaces(buffer, TRUE);
    }
    return buffer;
}

/*
 * Remove ALL whitespace from a string (including embedded blanks), and returns
 * a pointer to the end of the trimmed string.
 */
char *LYRemoveBlanks(char *buffer)
{
    if (buffer != 0) {
	register char *buf = buffer;

	for (; *buf && !isspace(UCH(*buf)); buf++) ;
	if (*buf) {
	    /* runs very seldom */
	    char *old = buf;

	    for (; *old; old++) {
		if (!isspace(UCH(*old)))
		    *buf++ = *old;
	    }
	    *buf = '\0';
	}
	return buf;
    }
    return NULL;
}

/*
 * Skip whitespace
 */
char *LYSkipBlanks(char *buffer)
{
    while (isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip non-whitespace
 */
char *LYSkipNonBlanks(char *buffer)
{
    while (*buffer != 0 && !isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip const whitespace
 */
const char *LYSkipCBlanks(const char *buffer)
{
    while (isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip const non-whitespace
 */
const char *LYSkipCNonBlanks(const char *buffer)
{
    while (*buffer != 0 && !isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Trim leading blanks from a string
 */
void LYTrimLeading(char *buffer)
{
    char *skipped = LYSkipBlanks(buffer);

    while ((*buffer++ = *skipped++) != 0) ;
}

/*
 * Trim trailing newline(s) from a string
 */
char *LYTrimNewline(char *buffer)
{
    size_t i = strlen(buffer);

    while (i != 0 && (buffer[i - 1] == '\n' || buffer[i - 1] == '\r'))
	buffer[--i] = 0;
    return buffer;
}

/*
 * Trim trailing blanks from a string
 */
void LYTrimTrailing(char *buffer)
{
    size_t i = strlen(buffer);

    while (i != 0 && isspace(UCH(buffer[i - 1])))
	buffer[--i] = 0;
}

/* 1997/11/10 (Mon) 14:26:10, originally string_short() in LYExterns.c, but
 * moved here because LYExterns is not always configured.
 */
char *LYElideString(char *str,
		    int cut_pos)
{
    char buff[MAX_LINE], *s, *d;
    static char s_str[MAX_LINE];
    int len;

    LYstrncpy(buff, str, sizeof(buff) - 1);
    len = strlen(buff);
    if (len > (LYcolLimit - 9)) {
	buff[cut_pos] = '.';
	buff[cut_pos + 1] = '.';
	for (s = (buff + len) - (LYcolLimit - 9) + cut_pos + 1,
	     d = (buff + cut_pos) + 2;
	     s >= buff &&
	     d >= buff &&
	     d < buff + LYcols &&
	     (*d++ = *s++) != 0;) ;
	buff[LYcols] = 0;
    }
    strlcpy(s_str, buff, MAX_LINE);
    return (s_str);
}

/*
 * Trim a startfile, returning true if it looks like one of the Lynx tags.
 */
BOOLEAN LYTrimStartfile(char *buffer)
{
    LYTrimHead(buffer);
    if (isLYNXEXEC(buffer) ||
	isLYNXPROG(buffer)) {
	/*
	 * The original implementations of these schemes expected white space
	 * without hex escaping, and did not check for hex escaping, so we'll
	 * continue to support that, until that code is redone in conformance
	 * with SGML principles.  - FM
	 */
	HTUnEscapeSome(buffer, " \r\n\t");
	convert_to_spaces(buffer, TRUE);
	return TRUE;
    }
    return FALSE;
}

/*
 * Escape unsafe characters in startfile, except for lynx internal URLs.
 */
void LYEscapeStartfile(char **buffer)
{
    if (!LYTrimStartfile(*buffer)) {
	char *escaped = HTEscapeUnsafe(*buffer);

	StrAllocCopy(*buffer, escaped);
	FREE(escaped);
    }
}

/*
 * Trim all blanks from startfile, except for lynx internal URLs.
 */
void LYTrimAllStartfile(char *buffer)
{
    if (!LYTrimStartfile(buffer)) {
	LYRemoveBlanks(buffer);
    }
}

/*
 *  Display the current value of the string and allow the user
 *  to edit it.
 */

#define EDREC	 EditFieldData

/*
 * Shorthand to get rid of all most of the "edit->suchandsos".
 */
#define Buf	 edit->buffer
#define Pos	 edit->pos
#define StrLen	 edit->strlen
#define MaxLen	 edit->maxlen
#define DspWdth  edit->dspwdth
#define DspStart edit->xpan
#define Margin	 edit->margin
#ifdef ENHANCED_LINEEDIT
#define Mark	 edit->mark
#endif

#ifdef ENHANCED_LINEEDIT
static char killbuffer[1024] = "\0";
#endif

void LYSetupEdit(EDREC * edit, char *old,
		 int maxstr,
		 int maxdsp)
{
    /*
     * Initialize edit record
     */
    LYGetYX(edit->sy, edit->sx);
    edit->pad = ' ';
    edit->dirty = TRUE;
    edit->panon = FALSE;
    edit->current_modifiers = 0;

    MaxLen = maxstr;
    DspWdth = maxdsp;
    Margin = 0;
    Pos = strlen(old);
#ifdef ENHANCED_LINEEDIT
    Mark = -1;			/* pos=0, but do not show it yet */
#endif
    DspStart = 0;

    if (maxstr > maxdsp) {	/* Need panning? */
	if (DspWdth > 4)	/* Else "{}" take up precious screen space */
	    edit->panon = TRUE;

	/*
	 * Figure out margins.  If too big, we do a lot of unnecessary
	 * scrolling.  If too small, user doesn't have sufficient look-ahead. 
	 * Let's say 25% for each margin, upper bound is 10 columns.
	 */
	Margin = DspWdth / 4;
	if (Margin > 10)
	    Margin = 10;
    }

    LYstrncpy(edit->buffer, old, maxstr);
    StrLen = strlen(edit->buffer);
}

#ifdef SUPPORT_MULTIBYTE_EDIT

static int prev_pos(EDREC * edit, int pos)
{
    int i = 0;

    if (pos <= 0)
	return 0;
    if (HTCJK == NOCJK)
	return (pos - 1);
    else {
	while (i < pos - 1) {
	    int c;

	    c = Buf[i];
	    if (is8bits(c) &&
		!((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c)))) {
		i++;
	    }
	    i++;
	}
	if (i == pos)
	    return (i - 2);
	else
	    return i;
    }
}
#endif /* SUPPORT_MULTIBYTE_EDIT */

#ifdef EXP_KEYBOARD_LAYOUT
static int map_active = 0;

#else
#define map_active 0
#endif

int LYEditInsert(EDREC * edit, unsigned const char *s,
		 int len,
		 int map,
		 BOOL maxMessage)
{
    int length = strlen(Buf);
    int remains = MaxLen - (length + len);
    int edited = 0, overflow = 0;

    /*
     * ch is (presumably) printable character.
     */
    if (remains < 0) {
	overflow = 1;
	len = 0;
	if (MaxLen > length)	/* Insert as much as we can */
	    len = MaxLen - length;
	else
	    goto finish;
    }
    Buf[length + len] = '\0';
    for (; length >= Pos; length--)	/* Make room */
	Buf[length + len] = Buf[length];
#ifdef EXP_KEYBOARD_LAYOUT
    if (map < 0)
	map = map_active;
    if (map && LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	int off = Pos;
	unsigned const char *e = s + len;
	char *tail = 0;

	while (s < e) {
	    char utfbuf[8];
	    int l = 1;

	    utfbuf[0] = *s;
	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
		UCode_t ucode = LYKbLayouts[current_layout][*s];

		if (ucode > 127) {
		    if (UCConvertUniToUtf8(ucode, utfbuf)) {
			l = strlen(utfbuf);
			remains -= l - 1;
			if (remains < 0) {
			    if (tail)
				strlcpy(Buf + off, tail, 1024 - off);
			    FREE(tail);
			    len = off;
			    overflow = 1;
			    goto finish;
			}
			if (l > 1 && !tail)
			    StrAllocCopy(tail, Buf + Pos + len);
		    } else
			utfbuf[0] = '?';
		} else
		    utfbuf[0] = UCH(ucode);
	    }
	    strncpy(Buf + off, utfbuf, l);
	    edited = 1;
	    off += l;
	    s++;
	}
	if (tail)
	    strlcpy(Buf + off, tail, 1024 - off);
	len = off - Pos;
	FREE(tail);
    } else if (map) {
	unsigned const char *e = s + len;
	unsigned char *t = (unsigned char *) Buf + Pos;

	while (s < e) {
	    int ch;

	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
		ch = UCTransUniChar(LYKbLayouts[current_layout][*s],
				    current_char_set);
		if (ch < 0)
		    ch = '?';
	    } else
		ch = *s;
	    *t = UCH(ch);
	    t++, s++;
	}
	edited = 1;
    } else
#endif /* defined EXP_KEYBOARD_LAYOUT */
    {
	strncpy(Buf + Pos, (const char *) s, len);
	edited = 1;
    }

  finish:
    Pos += len;
    StrLen += len;
    if (edited)
	edit->dirty = TRUE;
    if (overflow && maxMessage)
	_statusline(MAXLEN_REACHED_DEL_OR_MOV);
#ifdef ENHANCED_LINEEDIT
    if (Mark > Pos)
	Mark += len;
    else if (Mark < -1 - Pos)
	Mark -= len;
    if (Mark >= 0)
	Mark = -1 - Mark;	/* Disable it */
#endif
    return edited;
}

int LYEdit1(EDREC * edit, int ch,
	    int action,
	    BOOL maxMessage)
{				/* returns 0    character processed
				 *         -ch  if action should be performed outside of line-editing mode
				 *         ch   otherwise
				 */
    int i;
    int length;
    unsigned char uch;

    if (MaxLen <= 0)
	return (0);		/* Be defensive */

    length = strlen(&Buf[0]);
    StrLen = length;

    switch (action) {
#ifdef EXP_KEYBOARD_LAYOUT
    case LYE_SWMAP:
	/*
	 * Turn input character mapping on or off.
	 */
	map_active = ~map_active;
	break;
#endif
#ifndef CJK_EX
    case LYE_AIX:
	/*
	 * Hex 97.
	 * Fall through as a character for CJK, or if this is a valid character
	 * in the current display character set.  Otherwise, we treat this as
	 * LYE_ENTER.
	 */
	if (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97)
	    return (ch);
	/* FALLTHRU */
#endif
    case LYE_CHAR:
	uch = UCH(ch);
	LYEditInsert(edit, &uch, 1, map_active, maxMessage);
	return 0;		/* All changes already registered */

    case LYE_C1CHAR:
	/*
	 * ch is the second part (in most cases, a capital letter) of a 7-bit
	 * replacement for a character in the 8-bit C1 control range.
	 *
	 * This is meant to undo transformations like 0x81 -> 0x1b 0x41 (ESC A)
	 * etc.  done by slang on Unix and possibly some comm programs.  It's
	 * an imperfect workaround that doesn't work for all such characters.
	 */
	ch &= 0xFF;
	if (ch + 64 >= LYlowest_eightbit[current_char_set])
	    ch += 64;

	if (Pos <= (MaxLen) && StrLen < (MaxLen)) {
#ifdef ENHANCED_LINEEDIT
	    if (Mark > Pos)
		Mark++;
	    else if (Mark < -1 - Pos)
		Mark--;
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
#endif
	    for (i = length; i >= Pos; i--)	/* Make room */
		Buf[i + 1] = Buf[i];
	    Buf[length + 1] = '\0';
	    Buf[Pos] = UCH(ch);
	    Pos++;
	} else {
	    if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	    return (ch);
	}
	break;

    case LYE_BACKW:
#ifndef SUPPORT_MULTIBYTE_EDIT
	/*
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters.
	 */
	while (Pos && !isalnum(Buf[Pos - 1]))
	    Pos--;
	while (Pos && isalnum(Buf[Pos - 1]))
	    Pos--;
#else /* SUPPORT_MULTIBYTE_EDIT */
	/*
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters, or 1 or
	 * more multibyte character.
	 */
	{
	    int pos0;

	    pos0 = prev_pos(edit, Pos);
	    while (Pos &&
		   (HTCJK == NOCJK || !is8bits(Buf[pos0])) &&
		   !isalnum(UCH(Buf[pos0]))) {
		Pos = pos0;
		pos0 = prev_pos(edit, Pos);
	    }
	    if (HTCJK != NOCJK && is8bits(Buf[pos0])) {
		while (Pos && is8bits(Buf[pos0])) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    } else {
		while (Pos
		       && !is8bits(Buf[pos0])
		       && isalnum(UCH(Buf[pos0]))) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    }
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	break;

    case LYE_FORWW:
	/*
	 * Word forward.
	 */
#ifndef SUPPORT_MULTIBYTE_EDIT
	while (isalnum(Buf[Pos]))
	    Pos++;		/* '\0' is not a/n */
	while (!isalnum(Buf[Pos]) && Buf[Pos])
	    Pos++;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK && is8bits(Buf[Pos])) {
	    while (is8bits(Buf[Pos]))
		Pos += 2;
	} else {
	    while (!is8bits(Buf[Pos]) && isalnum(Buf[Pos]))
		Pos++;		/* '\0' is not a/n */
	}
	while ((HTCJK == NOCJK || !is8bits(Buf[Pos])) &&
	       !isalnum(UCH(Buf[Pos])) && Buf[Pos])
	    Pos++;
#endif /* SUPPORT_MULTIBYTE_EDIT */
	break;

    case LYE_ERASE:
	/*
	 * Erase the line to start fresh.
	 */
	Buf[0] = '\0';
#ifdef ENHANCED_LINEEDIT
	Mark = -1;		/* Do not show the mark */
#endif
	/* fall through */

    case LYE_BOL:
	/*
	 * Go to first column.
	 */
	Pos = 0;
	break;

    case LYE_EOL:
	/*
	 * Go to last column.
	 */
	Pos = length;
	break;

    case LYE_DELNW:
	/*
	 * Delete next word.
	 */
	{
	    int pos0 = Pos;

	    LYEdit1(edit, 0, LYE_FORWW, FALSE);
	    while (Pos > pos0)
		LYEdit1(edit, 0, LYE_DELP, FALSE);
	}
	break;

    case LYE_DELPW:
	/*
	 * Delete previous word.
	 */
	{
	    int pos0 = Pos;

	    LYEdit1(edit, 0, LYE_BACKW, FALSE);
	    pos0 -= Pos;
	    while (pos0--)
		LYEdit1(edit, 0, LYE_DELN, FALSE);
	}
	break;

    case LYE_DELBL:
	/*
	 * Delete from current cursor position back to BOL.
	 */
	{
	    int pos0 = Pos;

	    while (pos0--)
		LYEdit1(edit, 0, LYE_DELP, FALSE);
	}
	break;

    case LYE_DELEL:		/* @@@@@@ */
	/*
	 * Delete from current cursor position thru EOL.
	 */
	{
	    int pos0 = Pos;

	    LYEdit1(edit, 0, LYE_EOL, FALSE);
	    pos0 = Pos - pos0;
	    while (pos0--)
		LYEdit1(edit, 0, LYE_DELP, FALSE);
	}
	break;

    case LYE_DELN:
	/*
	 * Delete next character (I-beam style cursor), or current character
	 * (box/underline style cursor).
	 */
	if (Pos >= length)
	    break;
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (HTCJK != NOCJK && is8bits(Buf[Pos]))
	    Pos++;
#endif
	Pos++;
	/* fall through - DO NOT RELOCATE the LYE_DELN case wrt LYE_DELP */

    case LYE_DELP:
	/*
	 * Delete preceding character.
	 */
#ifndef SUPPORT_MULTIBYTE_EDIT
	if (length == 0 || Pos == 0)
	    break;
#ifdef ENHANCED_LINEEDIT
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark++;
#endif
	Pos--;
	for (i = Pos; i < length; i++)
	    Buf[i] = Buf[i + 1];
	i--;
#else /* SUPPORT_MULTIBYTE_EDIT */
	{
	    int offset = 1;
	    int pos0 = Pos;

	    if (length == 0 || Pos == 0)
		break;
	    if (HTCJK != NOCJK) {
		Pos = prev_pos(edit, pos0);
		offset = pos0 - Pos;
	    } else
		Pos--;
	    for (i = Pos; i < length; i++)
		Buf[i] = Buf[i + offset];
	    i -= offset;
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
	    if (Mark <= -1 - Pos)
		Mark += offset;
#endif
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	Buf[i] = 0;
	break;

    case LYE_FORW_RL:
    case LYE_FORW:
	/*
	 * Move cursor to the right.
	 */
#ifndef SUPPORT_MULTIBYTE_EDIT
	if (Pos < length)
	    Pos++;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos < length) {
	    Pos++;
	    if (HTCJK != NOCJK && is8bits(Buf[Pos - 1]))
		Pos++;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_FORW_RL)
	    return -ch;
	break;

    case LYE_BACK_LL:
    case LYE_BACK:
	/*
	 * Left-arrow move cursor to the left.
	 */
#ifndef SUPPORT_MULTIBYTE_EDIT
	if (Pos > 0)
	    Pos--;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos > 0) {
	    if (HTCJK != NOCJK)
		Pos = prev_pos(edit, Pos);
	    else
		Pos--;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_BACK_LL)
	    return -ch;
	break;

#ifdef ENHANCED_LINEEDIT
    case LYE_TPOS:
	/*
	 * Transpose characters - bash or ksh(emacs not gmacs) style
	 */
	if (length <= 1 || Pos == 0)
	    return (ch);
	if (Pos == length)
	    Pos--;
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Temporary enable it */
	if (Mark == Pos || Mark == Pos + 1)
	    Mark = Pos - 1;
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Buf[Pos - 1] == Buf[Pos]) {
	    Pos++;
	    break;
	}
	i = Buf[Pos - 1];
	Buf[Pos - 1] = Buf[Pos];
	Buf[Pos++] = (char) i;
	break;

    case LYE_SETMARK:
	/*
	 * primitive emacs-like set-mark-command
	 */
	Mark = Pos;
	return (0);

    case LYE_XPMARK:
	/*
	 * emacs-like exchange-point-and-mark
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Enable it */
	if (Mark == Pos)
	    return (0);
	i = Pos;
	Pos = Mark;
	Mark = i;
	break;

    case LYE_KILLREG:
	/*
	 * primitive emacs-like kill-region
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Enable it */
	if (Mark == Pos) {
	    killbuffer[0] = '\0';
	    return (0);
	}
	if (Mark > Pos)
	    LYEdit1(edit, 0, LYE_XPMARK, FALSE);
	{
	    int reglen = Pos - Mark;

	    LYstrncpy(killbuffer, &Buf[Mark],
		      HTMIN(reglen, (int) sizeof(killbuffer) - 1));
	    for (i = Mark; Buf[i + reglen]; i++)
		Buf[i] = Buf[i + reglen];
	    Buf[i] = Buf[i + reglen];	/* terminate */
	    Pos = Mark;
	}
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	break;

    case LYE_YANK:
	/*
	 * primitive emacs-like yank
	 */
	if (!killbuffer[0]) {
	    Mark = -1 - Pos;
	    return (0);
	} {
	    int yanklen = strlen(killbuffer);

	    if (Pos + yanklen <= (MaxLen) && StrLen + yanklen <= (MaxLen)) {
		Mark = -1 - Pos;

		for (i = length; i >= Pos; i--)		/* Make room */
		    Buf[i + yanklen] = Buf[i];
		for (i = 0; i < yanklen; i++)
		    Buf[Pos++] = UCH(killbuffer[i]);

	    } else if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	}
	break;

#endif /* ENHANCED_LINEEDIT */

    case LYE_UPPER:
	LYUpperCase(Buf);
	break;

    case LYE_LOWER:
	LYLowerCase(Buf);
	break;

    default:
	return (ch);
    }
    edit->dirty = TRUE;
    StrLen = strlen(&Buf[0]);
    return (0);
}

/*
 *  This function prompts for a choice or page number.
 *  If a 'g' or 'p' suffix is included, that will be
 *  loaded into c.  Otherwise, c is zeroed. - FM & LE
 */
int get_popup_number(const char *msg,
		     int *c,
		     int *rel)
{
    char temp[120];
    char *p = temp;
    int num;

    /*
     * Load the c argument into the prompt buffer.
     */
    temp[0] = (char) *c;
    temp[1] = '\0';
    _statusline(msg);

    /*
     * Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	*rel = '\0';
	return (0);
    }

    *rel = '\0';
    num = atoi(p);
    while (isdigit(UCH(*p)))
	++p;
    switch (*p) {
    case '+':
    case '-':
	/* 123+ or 123- */
	*rel = *p++;
	*c = *p;
	break;
    default:
	*c = *p++;
	*rel = *p;
	break;
    case 0:
	break;
    }

    /*
     * If we had a 'g' or 'p' suffix, load it into c.  Otherwise, zero c.  Then
     * return the number.
     */
    if (*p == 'g' || *p == 'G') {
	*c = 'g';
    } else if (*p == 'p' || *p == 'P') {
	*c = 'p';
    } else {
	*c = '\0';
    }
    if (*rel != '+' && *rel != '-')
	*rel = 0;
    return num;
}

#ifdef USE_COLOR_STYLE
#  define TmpStyleOn(s)		curses_style((s), STACK_ON)
#  define TmpStyleOff(s)	curses_style((s), STACK_OFF)
#else
#  define TmpStyleOn(s)
#  define TmpStyleOff(s)
#endif /* defined USE_COLOR_STYLE */

void LYRefreshEdit(EDREC * edit)
{
    int i;
    int length;
    int nrdisplayed;
    int padsize;
    char *str;
    char buffer[3];

#ifdef SUPPORT_MULTIBYTE_EDIT
    int begin_multi = 0;
    int end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
#ifdef USE_COLOR_STYLE
    int estyle, prompting = 0;
#endif

    buffer[0] = buffer[1] = buffer[2] = '\0';
    if (!edit->dirty || (DspWdth == 0))
	return;
    edit->dirty = FALSE;

    length = strlen(&Buf[0]);
    edit->strlen = length;
    /*
     * Now we have:
     *                .--DspWdth---.
     *      +---------+=============+-----------+
     *      |         |M           M|           |   (M=margin)
     *      +---------+=============+-----------+
     *      0         DspStart                   length
     *
     * Insertion point can be anywhere between 0 and stringlength.  Figure out
     * new display starting point.
     *
     * The first "if" below makes Lynx scroll several columns at a time when
     * extending the string.  Looks awful, but that way we can keep up with
     * data entry at low baudrates.
     */
    if ((DspStart + DspWdth) <= length) {
	if (Pos >= (DspStart + DspWdth) - Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
	    DspStart = (Pos - DspWdth) + Margin;
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (HTCJK != NOCJK) {
		int tmp = (Pos - DspWdth) + Margin;

		while (DspStart < tmp) {
		    if (is8bits(Buf[DspStart]))
			DspStart++;
		    DspStart++;
		}
	    } else {
		DspStart = (Pos - DspWdth) + Margin;
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
	}
    }

    if (Pos < DspStart + Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK) {
	    int tmp = Pos - Margin;

	    DspStart = 0;
	    while (DspStart < tmp) {
		if (is8bits(Buf[DspStart]))
		    DspStart++;
		DspStart++;
	    }
	} else {
	    DspStart = Pos - Margin;
	    if (DspStart < 0)
		DspStart = 0;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
    }

    str = &Buf[DspStart];
#ifdef SUPPORT_MULTIBYTE_EDIT
    if (HTCJK != NOCJK && is8bits(str[0]))
	begin_multi = 1;
#endif /* SUPPORT_MULTIBYTE_EDIT */

    nrdisplayed = length - DspStart;
    if (nrdisplayed > DspWdth)
	nrdisplayed = DspWdth;

    LYmove(edit->sy, edit->sx);
#ifdef USE_COLOR_STYLE
    /*
     * If this is the last screen line, set attributes to normal, should only
     * be needed for color styles.  The curses function may be used directly to
     * avoid complications.  - kw
     */
    if (edit->sy == (LYlines - 1))
	prompting = 1;
    if (prompting)
	estyle = s_prompt_edit;
    else
	estyle = s_aedit;
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.getstr: switching to <edit.%s>.\n",
	     prompting ? "prompt" : "active"));
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_ON);
    else
	wattrset(LYwin, A_NORMAL);	/* need to do something about colors? */
#endif
    if (edit->hidden) {
	for (i = 0; i < nrdisplayed; i++)
	    LYaddch('*');
    } else {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 && DspStart > Mark)
	    TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	for (i = 0; i < nrdisplayed; i++) {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			      || (DspStart + i == Pos && Pos < Mark)))
		TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			      || (DspStart + i == Pos && Pos > Mark)))
		TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	    if ((buffer[0] = str[i]) == 1 || buffer[0] == 2 ||
		(UCH(buffer[0]) == 160 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK ||
		   (LYCharSet_UC[current_char_set].enc != UCT_ENC_8859 &&
		    !(LYCharSet_UC[current_char_set].like8859
		      & UCT_R_8859SPECL))))) {
		LYaddch(' ');
#ifdef SUPPORT_MULTIBYTE_EDIT
		end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    } else {
		/* For CJK strings, by Masanobu Kimura */
		if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    if (i < (nrdisplayed - 1))
			buffer[1] = str[++i];
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = (i < nrdisplayed);
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
		    {
			int ii, yy, xx;

			LYGetYX(yy, xx);
			for (ii = 0; buffer[ii] != '\0'; ++ii)
			    LYaddch(' ');
			LYrefresh();
			LYmove(yy, xx);
		    }
#endif /* USE_SLANG */
#endif /* SUPPORT_MULTIBYTE_EDIT */
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		} else {
		    LYaddstr(buffer);
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
		}
	    }
	}
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 &&
	    ((DspStart + nrdisplayed <= Mark && DspStart + nrdisplayed > Pos)
	     || (DspStart + nrdisplayed > Mark
		 && DspStart + nrdisplayed <= Pos)))
	    TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
    }

    /*
     * Erase rest of input area.
     */
    padsize = DspWdth - nrdisplayed;
    if (padsize) {
	TmpStyleOn(prompting ? s_prompt_edit_pad : s_aedit_pad);
	while (padsize--)
	    LYaddch(UCH(edit->pad));
	TmpStyleOff(prompting ? s_prompt_edit_pad : s_aedit_pad);
    }

    /*
     * Scrolling indicators.
     */
    if (edit->panon) {
	if ((DspStart + nrdisplayed) < length) {
	    int add_space = 0;

	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (end_multi)
		add_space = 1;
#endif
	    LYmove(edit->sy, edit->sx + nrdisplayed - 1 - add_space);
	    if (add_space)
		LYaddch(' ');	/* Needed with styles? */
	    LYaddch(ACS_RARROW);
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
	if (DspStart) {
	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
	    LYmove(edit->sy, edit->sx);
	    LYaddch(ACS_LARROW);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (begin_multi)
		LYaddch(' ');	/* Needed with styles? */
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
    }

    LYmove(edit->sy, edit->sx + Pos - DspStart);

#ifdef USE_COLOR_STYLE
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_OFF);
#endif
    LYrefresh();
}

static void reinsertEdit(EditFieldData *edit, char *result)
{
    if (result != 0) {
	LYEdit1(edit, '\0', LYE_ERASE, FALSE);
	while (*result != '\0') {
	    LYLineEdit(edit, (int) (*result), FALSE);
	    result++;
	}
    }
}

static int caselessCmpList(const void *a,
			   const void *b)
{
    return strcasecomp(*(const char *const *) a, *(const char *const *) b);
}

static int normalCmpList(const void *a,
			 const void *b)
{
    return strcmp(*(const char *const *) a, *(const char *const *) b);
}

static char **sortedList(HTList *list, BOOL ignorecase)
{
    unsigned count = HTList_count(list);
    unsigned j = 0;
    unsigned k, jk;
    char **result = typecallocn(char *, count + 1);

    if (result == 0)
	outofmem(__FILE__, "sortedList");

    while (!HTList_isEmpty(list))
	result[j++] = (char *) HTList_nextObject(list);

    if (count > 1) {
	qsort((char *) result, count, sizeof(*result),
	      ignorecase ? caselessCmpList : normalCmpList);

	/* remove duplicate entries from the sorted index */
	for (j = 0; result[j] != 0; j++) {
	    k = j;
	    while (result[k] != 0
		   && !strcmp(result[j], result[k])) {
		k++;
	    }
	    k--;
	    if (j != k) {
		for (jk = j;; jk++) {
		    result[jk] = result[jk + k - j];
		    if (result[jk] == 0)
			break;
		}
	    }
	}
    }

    return result;
}

int LYarrayLength(const char **list)
{
    int result = 0;

    while (*list++ != 0)
	result++;
    return result;
}

int LYarrayWidth(const char **list)
{
    int result = 0;
    int check;

    while (*list != 0) {
	check = strlen(*list++);
	if (check > result)
	    result = check;
    }
    return result;
}

static void FormatChoiceNum(char *dst,
			    int num_choices,
			    int choice,
			    const char *value)
{
    if (num_choices >= 0) {
	int digits = (num_choices > 9) ? 2 : 1;

	sprintf(dst, "%*d: %.*s",
		digits, (choice + 1),
		MAX_LINE - 9 - digits, value);
    } else {
	LYstrncpy(dst, value, MAX_LINE - 1);
    }
}

static unsigned options_width(const char **list)
{
    unsigned width = 0;
    int count = 0;

    while (list[count] != 0) {
	if (strlen(list[count]) > width) {
	    width = strlen(list[count]);
	}
	count++;
    }
    return width;
}

static void draw_option(WINDOW * win, int entry,
			int width,
			BOOL reversed,
			int num_choices,
			int number,
			const char *value)
{
    char Cnum[MAX_LINE];

    FormatChoiceNum(Cnum, num_choices, number, "");
#ifdef USE_SLANG
    SLsmg_gotorc(win->top_y + entry, (win->left_x + 2));
    LYaddstr(Cnum);
    if (reversed)
	SLsmg_set_color(2);
    SLsmg_write_nstring((char *) value, win->width);
    if (reversed)
	SLsmg_set_color(0);
#else
    wmove(win, entry, 1);
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
    LynxWChangeStyle(win, s_menu_number, STACK_ON);
    waddstr(win, Cnum);
    LynxWChangeStyle(win, s_menu_number, STACK_OFF);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_ON);
#else
    if (reversed)
	wstart_reverse(win);
#endif
    LYpaddstr(win, width, value);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_OFF);
#else
    if (reversed)
	wstop_reverse(win);
#endif
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
#endif /* USE_SLANG */
}

/*
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
 *
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
 */
int LYhandlePopupList(int cur_choice,
		      int ly,
		      int lx,
		      const char **choices,
		      int width,
		      int i_length,
		      int disabled,
		      BOOLEAN for_mouse,
		      BOOLEAN numbered)
{
    int c = 0, cmd = 0, i = 0, j = 0, rel = 0;
    int orig_choice;
    WINDOW *form_window;
    int num_choices = 0;
    int max_choices = 0;
    int top, bottom, length = -1;
    int window_offset = 0;
    int lines_to_show;
    char Cnum[64];
    int Lnum;
    int npages;
    static char prev_target[MAX_LINE];	/* Search string buffer */
    static char prev_target_buffer[MAX_LINE];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0;
    RecallType recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN ReDraw = FALSE;
    int number;
    char buffer[MAX_LINE];
    const char *popup_status_msg = NULL;
    const char **Cptr = NULL;

#define CAN_SCROLL_DOWN	1
#define CAN_SCROLL_UP	2
#define CAN_SCROLL	4
    int can_scroll = 0, can_scroll_was = 0;

    orig_choice = cur_choice;
    if (cur_choice < 0)
	cur_choice = 0;

    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;

    /*
     * Count the number of choices to be displayed, where num_choices ranges
     * from 0 to n, and set width to the longest choice string length.  Also
     * set Lnum to the length for the highest choice number, then decrement
     * num_choices so as to be zero-based.  The window width will be based on
     * the sum of width and Lnum.  - FM
     */
    num_choices = LYarrayLength(choices) - 1;
    if (width <= 0)
	width = options_width(choices);
    if (numbered) {
	snprintf(Cnum, 64, "%d: ", num_choices);
	Lnum = strlen(Cnum);
	max_choices = num_choices;
    } else {
	Lnum = 0;
	max_choices = -1;
    }

    /*
     * Let's assume for the sake of sanity that ly is the number corresponding
     * to the line the choice is on.
     *
     * Let's also assume that cur_choice is the number of the item that should
     * be initially selected, as 0 being the first item.
     *
     * So what we have, is the top equal to the current screen line subtracting
     * the cur_choice + 1 (the one must be for the top line we will draw in a
     * box).  If the top goes under 0, consider it 0.
     */
    top = ly - (cur_choice + 1);
    if (top < 0)
	top = 0;

    /*
     * Check and see if we need to put the i_length parameter up to the number
     * of real choices.
     */
    if (i_length < 1) {
	i_length = num_choices;
    } else {
	/*
	 * Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     * The bottom is the value of the top plus the number of options to view
     * plus 3 (one for the top line, one for the bottom line, and one to offset
     * the 0 counted in the num_choices).
     */
    bottom = top + i_length + 3;

    /*
     * Set lines_to_show based on the user_mode global.
     */
    if (user_mode == NOVICE_MODE)
	lines_to_show = LYlines - 4;
    else
	lines_to_show = LYlines - 2;

    if (for_mouse && user_mode == NOVICE_MODE && lines_to_show > 2)
	lines_to_show--;

    /*
     * Hmm...  If the bottom goes beyond the number of lines available,
     */
    if (bottom > lines_to_show) {
	/*
	 * Position the window at the top if we have more choices than will fit
	 * in the window.
	 */
	if ((i_length + 3) > lines_to_show) {
	    top = 0;
	    bottom = (top + (i_length + 3));
	    if (bottom > lines_to_show)
		bottom = (lines_to_show + 1);
	} else {
	    /*
	     * Try to position the window so that the selected choice will
	     * appear where the selection box currently is positioned.  It
	     * could end up too high, at this point, but we'll move it down
	     * latter, if that has happened.
	     */
	    top = (lines_to_show + 1) - (i_length + 3);
	    bottom = (lines_to_show + 1);
	}
    }

    /*
     * This is really fun, when the length is 4, it means 0 to 4, or 5.
     */
    length = (bottom - top) - 2;
    if (length <= num_choices)
	can_scroll = CAN_SCROLL;

    /*
     * Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > lines_to_show + 1)
	    bottom = lines_to_show + 1;
	top = bottom - length - 2;
    }

    if (for_mouse) {
	int check = (Lnum + (int) width + 4);
	int limit = LYcols;

	/* shift horizontally to lie within screen width, if possible */
	if (check < limit) {
	    if (lx - 1 + check > limit)
		lx = limit + 1 - check;
	    else if (lx <= 0)
		lx = 1;
	}
    }

    /*
     * Set up the overall window, including the boxing characters ('*'), if it
     * all fits.  Otherwise, set up the widest window possible.  - FM
     */
    width += Lnum;
    bottom -= top;

    if (num_choices <= 0
	|| cur_choice > num_choices
	|| (form_window = LYstartPopup(&top,
				       &lx,
				       &bottom,
				       &width)) == 0)
	return (orig_choice);

    width -= Lnum;
    bottom += top;

    /*
     * Clear the command line and write the popup statusline.  - FM
     */
    LYmove((LYlines - 2), 0);
    LYclrtoeol();
    if (disabled) {
	popup_status_msg = CHOICE_LIST_UNM_MSG;
    } else if (!for_mouse) {
	popup_status_msg = CHOICE_LIST_MESSAGE;
#if defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES))
    } else {
	popup_status_msg =
	    gettext("Left mouse button or return to select, arrow keys to scroll.");
#endif
    }
    _statusline(popup_status_msg);

    /*
     * Set up the window_offset for choices.
     * cur_choice ranges from 0...n
     * length ranges from 0...m
     */
    if (cur_choice >= length) {
	window_offset = cur_choice - length + 1;
    }

    /*
     * Compute the number of popup window pages.  - FM
     */
    npages = ((num_choices + 1) > length) ?
	(((num_choices + 1) + (length - 1)) / (length))
	: 1;
    /*
     * OH!  I LOVE GOTOs!  hack hack hack
     */
  redraw:

    /*
     * Display the boxed choices.
     */
    for (i = 0; i <= num_choices; i++) {
	if (i >= window_offset && i - window_offset < length) {
	    draw_option(form_window, ((i + 1) - window_offset), width, FALSE,
			max_choices, i, choices[i]);
	}
    }
    LYbox(form_window, (BOOLEAN) !numbered);
    Cptr = NULL;

    /*
     * Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {
	int row = ((i + 1) - window_offset);

	/* Show scroll indicators. */
	if (can_scroll) {
	    can_scroll = ((window_offset ? CAN_SCROLL_UP : 0)
			  | (num_choices - window_offset >= length
			     ? CAN_SCROLL_DOWN : 0));
	    if (~can_scroll & can_scroll_was) {		/* Need to redraw */
		LYbox(form_window, (BOOLEAN) !numbered);
		can_scroll_was = 0;
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_UP) {
		wmove(form_window, 1, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_UARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_DOWN) {
		wmove(form_window, length, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_DARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	}

	/*
	 * Unreverse cur choice.
	 */
	if (Cptr != NULL) {
	    draw_option(form_window, row, width, FALSE,
			max_choices, i, Cptr[i]);
	}
	Cptr = choices;
	i = cur_choice;
	row = ((cur_choice + 1) - window_offset);
	draw_option(form_window, row, width, TRUE,
		    max_choices, cur_choice, Cptr[cur_choice]);
	LYstowCursor(form_window, row, 1);

	c = LYgetch_choice();
	if (term_options || LYCharIsINTERRUPT(c)) {	/* Control-C or Control-G */
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, row, &cur_choice)) < 0)
		goto redraw;
	    if (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = LKC_TO_LAC(keymap, c);
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch (cmd) {
	case LYK_F_LINK_NUM:
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
	case LYK_9:
	    /*
	     * Get a number from the user, possibly with a 'g' or 'p' suffix
	     * (which will be loaded into c).  - FM & LE
	     */
	    number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);

	    /* handle + or - suffix */
	    CTRACE((tfp, "got popup option number %d, ", number));
	    CTRACE((tfp, "rel='%c', c='%c', cur_choice=%d\n",
		    rel, c, cur_choice));
	    if (c == 'p') {
		int curpage = ((cur_choice + 1) > length) ?
		(((cur_choice + 1) + (length - 1)) / (length))
		: 1;

		CTRACE((tfp, "  curpage=%d\n", curpage));
		if (rel == '+')
		    number = curpage + number;
		else if (rel == '-')
		    number = curpage - number;
	    } else if (rel == '+') {
		number = cur_choice + number + 1;
	    } else if (rel == '-') {
		number = cur_choice - number + 1;
	    }
	    if (rel)
		CTRACE((tfp, "new number=%d\n", number));
	    /*
	     * Check for a 'p' suffix.  - FM
	     */
	    if (c == 'p') {
		/*
		 * Treat 1 or less as the first page.  - FM
		 */
		if (number <= 1) {
		    if (window_offset == 0) {
			HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			_statusline(popup_status_msg);
			break;
		    }
		    window_offset = 0;
		    cur_choice = 0;
		    _statusline(popup_status_msg);
		    goto redraw;
		}

		/*
		 * Treat a number equal to or greater than the number of pages
		 * as the last page.  - FM
		 */
		if (number >= npages) {
		    if (window_offset >= ((num_choices - length) + 1)) {
			HTUserMsg(ALREADY_AT_OPTION_END);
			_statusline(popup_status_msg);
			break;
		    }
		    window_offset = ((npages - 1) * length);
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }
		    if (cur_choice < window_offset)
			cur_choice = window_offset;
		    _statusline(popup_status_msg);
		    goto redraw;
		}

		/*
		 * We want an intermediate page.  - FM
		 */
		if (((number - 1) * length) == window_offset) {
		    char *msg = 0;

		    HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
		    HTUserMsg(msg);
		    FREE(msg);
		    _statusline(popup_status_msg);
		    break;
		}
		cur_choice = window_offset = ((number - 1) * length);
		_statusline(popup_status_msg);
		goto redraw;

	    }

	    /*
	     * Check for a positive number, which signifies that a choice
	     * should be sought.  - FM
	     */
	    if (number > 0) {
		/*
		 * Decrement the number so as to correspond with our cur_choice
		 * values.  - FM
		 */
		number--;

		/*
		 * If the number is in range and had no legal suffix, select
		 * the indicated choice.  - FM
		 */
		if (number <= num_choices && c == '\0') {
		    cur_choice = number;
		    cmd = LYK_ACTIVATE;
		    break;
		}

		/*
		 * Verify that we had a 'g' suffix, and act on the number.  -
		 * FM
		 */
		if (c == 'g') {
		    if (cur_choice == number) {
			/*
			 * The choice already is current.  - FM
			 */
			char *msg = 0;

			HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			HTUserMsg(msg);
			FREE(msg);
			_statusline(popup_status_msg);
			break;
		    }

		    if (number <= num_choices) {
			/*
			 * The number is in range and had a 'g' suffix, so make
			 * it the current option, scrolling if needed.  - FM
			 */
			j = (number - cur_choice);
			cur_choice = number;
			if ((j > 0) &&
			    (cur_choice - window_offset) >= length) {
			    window_offset += j;
			    if (window_offset > (num_choices - length + 1))
				window_offset = (num_choices - length + 1);
			} else if ((cur_choice - window_offset) < 0) {
			    window_offset -= abs(j);
			    if (window_offset < 0)
				window_offset = 0;
			}
			_statusline(popup_status_msg);
			goto redraw;
		    }

		    /*
		     * Not in range.  - FM
		     */
		    HTUserMsg(BAD_OPTION_NUM_ENTERED);
		}
	    }

	    /*
	     * Restore the popup statusline.  - FM
	     */
	    _statusline(popup_status_msg);
	    break;

	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	case LYK_FASTBACKW_LINK:
	case LYK_UP_LINK:

	    if (cur_choice > 0)
		cur_choice--;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset--;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	case LYK_FASTFORW_LINK:
	case LYK_DOWN_LINK:
	    if (cur_choice < num_choices)
		cur_choice++;

	    /*
	     * Scroll the window down if necessary
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset++;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_PAGE:
	    /*
	     * Okay, are we on the last page of the list?  If not then,
	     */
	    if (window_offset != (num_choices - length + 1)) {
		/*
		 * Modify the current choice to not be a coordinate in the
		 * list, but a coordinate on the item selected in the window.
		 */
		cur_choice -= window_offset;

		/*
		 * Page down the proper length for the list.  If simply to far,
		 * back up.
		 */
		window_offset += length;
		if (window_offset > (num_choices - length)) {
		    window_offset = (num_choices - length + 1);
		}

		/*
		 * Readjust the current selection to be a list coordinate
		 * rather than window.  Redraw this thing.
		 */
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice < num_choices) {
		/*
		 * Already on last page of the list so just redraw it with the
		 * last item selected.
		 */
		cur_choice = num_choices;
	    }
	    break;

	case LYK_PREV_PAGE:
	    /*
	     * Are we on the first page of the list?  If not then,
	     */
	    if (window_offset != 0) {
		/*
		 * Modify the current selection to not be a list coordinate,
		 * but a window coordinate.
		 */
		cur_choice -= window_offset;

		/*
		 * Page up the proper length.  If too far, back up.
		 */
		window_offset -= length;
		if (window_offset < 0) {
		    window_offset = 0;
		}

		/*
		 * Readjust the current choice.
		 */
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice > 0) {
		/*
		 * Already on the first page so just back up to the first item.
		 */
		cur_choice = 0;
	    }
	    break;

	case LYK_HOME:
	    cur_choice = 0;
	    if (window_offset > 0) {
		window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_END:
	    cur_choice = num_choices;
	    if (window_offset != (num_choices - length + 1)) {
		window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_DOWN_TWO:
	    cur_choice += 2;
	    if (cur_choice > num_choices)
		cur_choice = num_choices;

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += 2;
		if (window_offset > (num_choices - length + 1))
		    window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_UP_TWO:
	    cur_choice -= 2;
	    if (cur_choice < 0)
		cur_choice = 0;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= 2;
		if (window_offset < 0)
		    window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_DOWN_HALF:
	    cur_choice += (length / 2);
	    if (cur_choice > num_choices)
		cur_choice = num_choices;

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += (length / 2);
		if (window_offset > (num_choices - length + 1))
		    window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_UP_HALF:
	    cur_choice -= (length / 2);
	    if (cur_choice < 0)
		cur_choice = 0;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= (length / 2);
		if (window_offset < 0)
		    window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_REFRESH:
	    lynx_force_repaint();
	    LYrefresh();
	    break;

	case LYK_NEXT:
	    if (recall && *prev_target_buffer == '\0') {
		/*
		 * We got a 'n'ext command with no prior query specified within
		 * the popup window.  See if one was entered when the popup was
		 * retracted, and if so, assume that's what's wanted.  Note
		 * that it will become the default within popups, unless
		 * another is entered within a popup.  If the within popup
		 * default is to be changed at that point, use WHEREIS ('/')
		 * and enter it, or the up- or down-arrow keys to seek any of
		 * the previously entered queries, regardless of whether they
		 * were entered within or outside of a popup window.  - FM
		 */
		if ((cp = (char *) HTList_objectAt(search_queries,
						   0)) != NULL) {
		    LYstrncpy(prev_target_buffer,
			      cp,
			      sizeof(prev_target_buffer) - 1);
		    QueryNum = 0;
		    FirstRecall = FALSE;
		}
	    }
	    strcpy(prev_target, prev_target_buffer);
	    /* FALLTHRU */
	case LYK_WHEREIS:
	    if (*prev_target == '\0') {
		_statusline(ENTER_WHEREIS_QUERY);
		if ((ch = LYgetstr(prev_target, VISIBLE,
				   sizeof(prev_target_buffer),
				   recall)) < 0) {
		    /*
		     * User cancelled the search via ^G.  - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}
	    }

	  check_recall:
	    if (*prev_target == '\0' &&
		!(recall && (ch == UPARROW || ch == DNARROW))) {
		/*
		 * No entry.  Simply break.  - FM
		 */
		HTInfoMsg(CANCELLED);
		goto restore_popup_statusline;
	    }

	    if (recall && ch == UPARROW) {
		if (FirstRecall) {
		    /*
		     * Use the current string or last query in the list.  - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = (QueryTotal - 1);
			     QueryNum > 0; QueryNum--) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(prev_target_buffer, cp)) {
				break;
			    }
			}
		    } else {
			QueryNum = 0;
		    }
		} else {
		    /*
		     * Go back to the previous query in the list.  - FM
		     */
		    QueryNum++;
		}
		if (QueryNum >= QueryTotal) {
		    /*
		     * Roll around to the last query in the list.  - FM
		     */
		    QueryNum = 0;
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((*prev_target_buffer && QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
		    }
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer), recall)) < 0) {
			/*
			 * User cancelled the search via ^G.  - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		    goto check_recall;
		}
	    } else if (recall && ch == DNARROW) {
		if (FirstRecall) {
		    /*
		     * Use the current string or first query in the list.  - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(prev_target_buffer, cp)) {
				break;
			    }
			}
		    } else {
			QueryNum = (QueryTotal - 1);
		    }
		} else {
		    /*
		     * Advance to the next query in the list.  - FM
		     */
		    QueryNum--;
		}
		if (QueryNum < 0) {
		    /*
		     * Roll around to the first query in the list.  - FM
		     */
		    QueryNum = (QueryTotal - 1);
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((*prev_target_buffer &&
				QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
		    }
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 * User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		    goto check_recall;
		}
	    }
	    /*
	     * Replace the search string buffer with the new target.  - FM
	     */
	    strcpy(prev_target_buffer, prev_target);
	    HTAddSearchQuery(prev_target_buffer);

	    /*
	     * Start search at the next choice.  - FM
	     */
	    for (j = 1; Cptr[i + j] != NULL; j++) {
		FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i + j]);
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
			break;
		}
	    }
	    if (Cptr[i + j] != NULL) {
		/*
		 * We have a hit, so make that choice the current.  - FM
		 */
		cur_choice += j;
		/*
		 * Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += j;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    ReDraw = TRUE;
		}
		goto restore_popup_statusline;
	    }

	    /*
	     * If we started at the beginning, it can't be present.  - FM
	     */
	    if (cur_choice == 0) {
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		goto restore_popup_statusline;
	    }

	    /*
	     * Search from the beginning to the current choice.  - FM
	     */
	    for (j = 0; j < cur_choice; j++) {
		FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
			break;
		}
	    }
	    if (j < cur_choice) {
		/*
		 * We have a hit, so make that choice the current.  - FM
		 */
		j = (cur_choice - j);
		cur_choice -= j;
		/*
		 * Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= j;
		    if (window_offset < 0)
			window_offset = 0;
		    ReDraw = TRUE;
		}
		goto restore_popup_statusline;
	    }

	    /*
	     * Didn't find it in the preceding choices either.  - FM
	     */
	    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);

	  restore_popup_statusline:
	    /*
	     * Restore the popup statusline and reset the search variables.  -
	     * FM
	     */
	    _statusline(popup_status_msg);
	    *prev_target = '\0';
	    QueryTotal = (search_queries ? HTList_count(search_queries)
			  : 0);
	    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
	    QueryNum = QueryTotal;
	    if (ReDraw == TRUE) {
		ReDraw = FALSE;
		goto redraw;
	    }
	    break;

	case LYK_QUIT:
	case LYK_ABORT:
	case LYK_PREV_DOC:
	case LYK_INTERRUPT:
	    cur_choice = orig_choice;
	    cmd = LYK_ACTIVATE;	/* to exit */
	    break;
	}
    }
    LYstopPopup();

    return (disabled ? orig_choice : cur_choice);
}

#define CurModif MyEdit.current_modifiers

int LYgetstr(char *inputline,
	     int hidden,
	     size_t bufsize,
	     RecallType recall)
{
    int x, y, MaxStringSize;
    int ch;
    int xlec = -2;
    int last_xlec = -1;
    int last_xlkc = -1;
    EditFieldData MyEdit;

#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif /* SUPPORT_MULTIBYTE_EDIT */

    LYGetYX(y, x);		/* Use screen from cursor position to eol */
    MaxStringSize = (bufsize < sizeof(MyEdit.buffer)) ?
	(bufsize - 1) : (sizeof(MyEdit.buffer) - 1);
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, LYcolLimit - x);
    MyEdit.hidden = (BOOL) hidden;

    CTRACE((tfp, "called LYgetstr\n"));
    for (;;) {
      again:
#ifndef SUPPORT_MULTIBYTE_EDIT
	LYRefreshEdit(&MyEdit);
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (refresh_mb)
	    LYRefreshEdit(&MyEdit);
#endif /* SUPPORT_MULTIBYTE_EDIT */
	ch = LYReadCmdKey(FOR_PROMPT);
#ifdef SUPPORT_MULTIBYTE_EDIT
#ifdef CJK_EX			/* for SJIS code */
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR))
	    goto again;
#else
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR)
	    && (EditBinding(ch) != LYE_AIX))
	    goto again;
#endif
#endif /* SUPPORT_MULTIBYTE_EDIT */

	if (term_letter || term_options
#ifdef VMS
	    || HadVMSInterrupt
#endif /* VMS */
#ifndef DISABLE_NEWS
	    || term_message
#endif
	    ) {
#ifdef VMS
	    HadVMSInterrupt = FALSE;
#endif /* VMS */
	    ch = LYCharINTERRUPT2;
	}

	if (recall != NORECALL && (ch == UPARROW || ch == DNARROW)) {
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
	    LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) recall\n", inputline));
	    return (ch);
	}
	ch |= CurModif;
	CurModif = 0;
	if (last_xlkc != -1) {
	    if (ch == last_xlkc)
		ch |= LKC_MOD3;
	    last_xlkc = -1;	/* consumed */
	}
#ifndef WIN_EX
	if (LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
	    goto again;
#endif
	last_xlec = xlec;
	xlec = EditBinding(ch);
	if ((xlec & LYE_DF) && !(xlec & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    xlec &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}
	switch (xlec) {
	case LYE_SETM1:
	    /*
	     * Set flag for modifier 1.
	     */
	    CurModif |= LKC_MOD1;
	    break;
	case LYE_SETM2:
	    /*
	     * Set flag for modifier 2.
	     */
	    CurModif |= LKC_MOD2;
	    break;
	case LYE_TAB:
	    if (xlec == last_xlec && recall != NORECALL) {
		HTList *list = whichRecall(recall);

		if (!HTList_isEmpty(list)) {
		    char **data = sortedList(list, (BOOL) (recall == RECALL_CMD));
		    int old_y, old_x;
		    int cur_choice = 0;
		    int num_options = LYarrayLength((const char **) data);

		    while (cur_choice < num_options
			   && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
			cur_choice++;

		    LYGetYX(old_y, old_x);
		    cur_choice = LYhandlePopupList(cur_choice,
						   0,
						   old_x,
						   (const char **) data,
						   -1,
						   -1,
						   FALSE,
						   FALSE,
						   TRUE);
		    if (cur_choice >= 0) {
			if (recall == RECALL_CMD)
			    _statusline(": ");
			reinsertEdit(&MyEdit, data[cur_choice]);
		    }
		    wmove(LYwin, old_y, old_x);
		    FREE(data);
		}
	    } else {
		reinsertEdit(&MyEdit, LYFindInCloset(recall, MyEdit.buffer));
	    }
	    break;

#ifndef CJK_EX			/* 1997/11/03 (Mon) 20:13:45 */
	case LYE_AIX:
	    /*
	     * Hex 97.
	     * Treat as a character for CJK, or if this is a valid character in
	     * the current display character set.  Otherwise, we treat this as
	     * LYE_ENTER.
	     */
	    if (ch != '\t' &&
		(HTCJK != NOCJK ||
		 LYlowest_eightbit[current_char_set] <= 0x97)) {
		LYLineEdit(&MyEdit, ch, FALSE);
		break;
	    }
	    /* FALLTHRU */
#endif
	case LYE_ENTER:
	    /*
	     * Terminate the string and return.
	     */
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
	    if (!hidden)
		LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) LYE_ENTER\n", inputline));
	    return (ch);

#ifdef CAN_CUT_AND_PASTE
	    /* 1998/10/01 (Thu) 15:05:49 */

	case LYE_PASTE:
	    {
		unsigned char *s = (unsigned char *) get_clip_grab(), *e;
		int len;

		if (!s)
		    break;
		len = strlen((const char *) s);
		e = s + len;

		if (len > 0) {
		    unsigned char *e1 = s;

		    while (e1 < e) {
			if (*e1 < ' ') {	/* Stop here? */
			    if (e1 > s)
				LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
			    s = e1;
			    if (*e1 == '\t') {	/* Replace by space */
				LYEditInsert(&MyEdit,
					     (unsigned const char *) " ",
					     1,
					     map_active,
					     TRUE);
				s = ++e1;
			    } else
				break;
			} else
			    ++e1;
		    }
		    if (e1 > s)
			LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
		}
		get_clip_release();
		break;
	    }
#endif

	case LYE_ABORT:
	    /*
	     * Control-C or Control-G aborts.
	     */
	    inputline[0] = '\0';
	    CTRACE((tfp, "LYgetstr LYE_ABORT\n"));
	    return (-1);

	case LYE_STOP:
	    /*
	     * Deactivate.
	     */
	    CTRACE((tfp, "LYgetstr LYE_STOP\n"));
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    return (-1);
#else
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
#endif
#endif
	    break;

	case LYE_LKCMD:
	    /*
	     * Used only in form_getstr() for invoking the LYK_F_LINK_NUM
	     * prompt when in form text fields.  - FM
	     */
	    break;

	case LYE_FORM_PASS:
	    /*
	     * Used in form_getstr() to end line editing and pass on the input
	     * char/lynxkeycode.  Here it is just ignored.  - kw
	     */
	    break;

	default:
	    if (xlec & LYE_FORM_LAC) {
		/*
		 * Used in form_getstr() to end line editing and pass on the
		 * lynxkeycode already containing a lynxactioncode.  Here it is
		 * just ignored.  - kw
		 */
		break;
	    }
#ifndef SUPPORT_MULTIBYTE_EDIT
	    LYLineEdit(&MyEdit, ch, FALSE);
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (LYLineEdit(&MyEdit, ch, FALSE) == 0) {
		if (refresh_mb && HTCJK != NOCJK && (0x81 <= ch) && (ch <= 0xfe))
		    refresh_mb = FALSE;
		else
		    refresh_mb = TRUE;
	    } else {
		if (!refresh_mb) {
		    LYEdit1(&MyEdit, 0, LYE_DELP, FALSE);
		}
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
	}
    }
}

const char *LYLineeditHelpURL(void)
{
    static int lasthelp_lineedit = -1;
    static char helpbuf[LY_MAXPATH] = "\0";
    static char *phelp = &helpbuf[0];

    if (lasthelp_lineedit == current_lineedit)
	return &helpbuf[0];
    if (lasthelp_lineedit == -1) {
	LYstrncpy(helpbuf, helpfilepath, sizeof(helpbuf) - 1);
	phelp += strlen(helpbuf);
    }
    if (LYLineeditHelpURLs[current_lineedit] &&
	strlen(LYLineeditHelpURLs[current_lineedit]) &&
	(strlen(LYLineeditHelpURLs[current_lineedit]) <=
	 sizeof(helpbuf) - (phelp - helpbuf))) {
	LYstrncpy(phelp, LYLineeditHelpURLs[current_lineedit],
		  sizeof(helpbuf) - (phelp - helpbuf) - 1);
	lasthelp_lineedit = current_lineedit;
	return (&helpbuf[0]);
    }
    return NULL;
}

/*
 * A replacement for 'strsep()'
 */
char *LYstrsep(char **stringp,
	       const char *delim)
{
    char *tmp, *out;

    if (isEmpty(stringp))	/* nothing to do? */
	return 0;		/* then don't fall on our faces */

    out = *stringp;		/* save the start of the string */
    tmp = strpbrk(*stringp, delim);
    if (tmp) {
	*tmp = '\0';		/* terminate the substring with \0 */
	*stringp = ++tmp;	/* point at the next substring */
    } else
	*stringp = 0;		/* this was the last substring: */
    /* let caller see he's done */
    return out;
}

/*
 * LYstrstr will find the first occurrence of the string pointed to by tarptr
 * in the string pointed to by chptr.  It returns NULL if string not found.  It
 * is a case insensitive search.
 */
char *LYstrstr(char *chptr,
	       const char *tarptr)
{
    int len = strlen(tarptr);

    for (; *chptr != '\0'; chptr++) {
	if (0 == UPPER8(*chptr, *tarptr)) {
	    if (0 == strncasecomp8(chptr + 1, tarptr + 1, len - 1))
		return (chptr);
	}
    }				/* end for */

    return (NULL);		/* string not found or initial chptr was empty */
}

/*
 * LYno_attr_char_case_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
 *			       LY_UNDERLINE_END_CHAR
 *			       LY_BOLD_START_CHAR
 *			       LY_BOLD_END_CHAR
 *			       LY_SOFT_HYPHEN
 *			       if present in chptr.
 * It is a case insensitive search.
 */
const char *LYno_attr_char_case_strstr(const char *chptr,
				       const char *tarptr)
{
    register const char *tmpchptr, *tmptarptr;

    if (!chptr)
	return (NULL);

    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;

    for (; *chptr != '\0'; chptr++) {
	if (0 == UPPER8(*chptr, *tarptr)) {
	    /*
	     * See if they line up.
	     */
	    tmpchptr = chptr + 1;
	    tmptarptr = tarptr + 1;

	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);

	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (0 != UPPER8(*tmpchptr, *tmptarptr))
			break;
		    tmpchptr++;
		    tmptarptr++;
		} else {
		    tmpchptr++;
		}
		if (*tmptarptr == '\0')
		    return (chptr);
		if (*tmpchptr == '\0')
		    break;
	    }
	}
    }				/* end for */

    return (NULL);
}

/*
 * LYno_attr_char_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
 *			       LY_UNDERLINE_END_CHAR
 *			       LY_BOLD_START_CHAR
 *			       LY_BOLD_END_CHAR
 *			       LY_SOFT_HYPHEN
 *			       if present in chptr.
 * It is a case sensitive search.
 */
const char *LYno_attr_char_strstr(const char *chptr,
				  const char *tarptr)
{
    register const char *tmpchptr, *tmptarptr;

    if (!chptr)
	return (NULL);

    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;

    for (; *chptr != '\0'; chptr++) {
	if ((*chptr) == (*tarptr)) {
	    /*
	     * See if they line up.
	     */
	    tmpchptr = chptr + 1;
	    tmptarptr = tarptr + 1;

	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);

	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if ((*tmpchptr) != (*tmptarptr))
			break;
		    tmpchptr++;
		    tmptarptr++;
		} else {
		    tmpchptr++;
		}
		if (*tmptarptr == '\0')
		    return (chptr);
		if (*tmpchptr == '\0')
		    break;
	    }
	}
    }				/* end for */

    return (NULL);
}

/*
 * LYno_attr_mbcs_case_strstr will find the first occurrence of the string
 * pointed to by tarptr in the string pointed to by chptr.  It takes account of
 * MultiByte Character Sequences (UTF8).  The physical lengths of the displayed
 * string up to the start and end (= next position after) of the target string
 * are returned in *nstartp and *nendp if the search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
 * It ignores the characters: LY_UNDERLINE_START_CHAR and
 *			      LY_UNDERLINE_END_CHAR
 *			      LY_BOLD_START_CHAR
 *			      LY_BOLD_END_CHAR
 *			      LY_SOFT_HYPHEN
 *			      if present in chptr.
 * It assumes UTF8 if utf_flag is set.
 * It is a case insensitive search.  - KW & FM
 */
const char *LYno_attr_mbcs_case_strstr(const char *chptr,
				       const char *tarptr,
				       BOOL utf_flag,
				       BOOL count_gcells,
				       int *nstartp,
				       int *nendp)
{
    const char *tmpchptr;
    const char *tmptarptr;
    int len = 0;
    int offset;

    if (!(chptr && tarptr))
	return (NULL);

    /*
     * Skip initial IsSpecial chars.  - FM
     */
    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;

    /*
     * Seek a first target match.  - FM
     */
    for (; *chptr != '\0'; chptr++) {
	if ((!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
	     *chptr == *tarptr &&
	     IsNormalChar(*(chptr + 1))) ||
	    (0 == UPPER8(*chptr, *tarptr))) {
	    int tarlen = 0;

	    offset = len;
	    len++;

	    /*
	     * See if they line up.
	     */
	    tmpchptr = (chptr + 1);
	    tmptarptr = (tarptr + 1);

	    if (*tmptarptr == '\0') {
		/*
		 * One char target.
		 */
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
	    }
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		*chptr == *tarptr &&
		IsNormalChar(*tmpchptr)) {
		/*
		 * Check the CJK multibyte.  - FM
		 */
		if (*tmpchptr == *tmptarptr) {
		    /*
		     * It's a match.  Advance to next char.  - FM
		     */
		    tmpchptr++;
		    tmptarptr++;
		    if (count_gcells)
			tarlen++;
		    if (*tmptarptr == '\0') {
			/*
			 * One character match.  - FM
			 */
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
		    }
		} else {
		    /*
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
		     */
		    chptr++;
		    if (count_gcells)
			len++;
		    continue;
		}
	    }
	    /*
	     * See if the rest of the target matches.  - FM
	     */
	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
			if (*tmpchptr == *tmptarptr &&
			    *(tmpchptr + 1) == *(tmptarptr + 1) &&
			    !IsSpecialAttrChar(*(tmpchptr + 1))) {
			    tmpchptr++;
			    tmptarptr++;
			    if (count_gcells)
				tarlen++;
			} else {
			    break;
			}
		    } else if (0 != UPPER8(*tmpchptr, *tmptarptr)) {
			break;
		    }

		    if (!IS_UTF_EXTRA(*tmptarptr)) {
			tarlen++;
		    }
		    tmpchptr++;
		    tmptarptr++;

		} else {
		    tmpchptr++;
		}

		if (*tmptarptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
		}
		if (*tmpchptr == '\0')
		    break;
	    }
	} else if (!(IS_UTF_EXTRA(*chptr) ||
		     IsSpecialAttrChar(*chptr))) {
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		IsNormalChar(*(chptr + 1))) {
		chptr++;
		if (count_gcells)
		    len++;
	    }
	    len++;
	}
    }				/* end for */

    return (NULL);
}

/*
 * LYno_attr_mbcs_strstr will find the first occurrence of the string pointed
 * to by tarptr in the string pointed to by chptr.
 *
 * It takes account of CJK and MultiByte Character Sequences (UTF8).  The
 * physical lengths of the displayed string up to the start and end (= next
 * position after) the target string are returned in *nstartp and *nendp if the
 * search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
 * It ignores the characters: LY_UNDERLINE_START_CHAR and
 *			      LY_UNDERLINE_END_CHAR
 *			      LY_BOLD_START_CHAR
 *			      LY_BOLD_END_CHAR
 *			      LY_SOFT_HYPHEN
 *			      if present in chptr.
 * It assumes UTF8 if utf_flag is set.
 * It is a case sensitive search.  - KW & FM
 */
const char *LYno_attr_mbcs_strstr(const char *chptr,
				  const char *tarptr,
				  BOOL utf_flag,
				  BOOL count_gcells,
				  int *nstartp,
				  int *nendp)
{
    const char *tmpchptr;
    const char *tmptarptr;
    int len = 0;
    int offset;

    if (!(chptr && tarptr))
	return (NULL);

    /*
     * Skip initial IsSpecial chars.  - FM
     */
    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;

    /*
     * Seek a first target match.  - FM
     */
    for (; *chptr != '\0'; chptr++) {
	if ((*chptr) == (*tarptr)) {
	    int tarlen = 0;

	    offset = len;
	    len++;

	    /*
	     * See if they line up.
	     */
	    tmpchptr = (chptr + 1);
	    tmptarptr = (tarptr + 1);

	    if (*tmptarptr == '\0') {
		/*
		 * One char target.
		 */
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
	    }
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		IsNormalChar(*tmpchptr)) {
		/*
		 * Check the CJK multibyte.  - FM
		 */
		if (*tmpchptr == *tmptarptr) {
		    /*
		     * It's a match.  Advance to next char.  - FM
		     */
		    tmpchptr++;
		    tmptarptr++;
		    if (count_gcells)
			tarlen++;
		    if (*tmptarptr == '\0') {
			/*
			 * One character match.  - FM
			 */
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
		    }
		} else {
		    /*
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
		     */
		    chptr++;
		    if (count_gcells)
			len++;
		    continue;
		}
	    }
	    /*
	     * See if the rest of the target matches.  - FM
	     */
	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
			if (*tmpchptr == *tmptarptr &&
			    *(tmpchptr + 1) == *(tmptarptr + 1) &&
			    !IsSpecialAttrChar(*(tmpchptr + 1))) {
			    tmpchptr++;
			    tmptarptr++;
			    if (count_gcells)
				tarlen++;
			} else {
			    break;
			}
		    } else if ((*tmpchptr) != (*tmptarptr)) {
			break;
		    }

		    if (!IS_UTF_EXTRA(*tmptarptr)) {
			tarlen++;
		    }
		    tmpchptr++;
		    tmptarptr++;
		} else {
		    tmpchptr++;
		}

		if (*tmptarptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
		}
		if (*tmpchptr == '\0')
		    break;
	    }
	} else if (!(IS_UTF_EXTRA(*chptr) ||
		     IsSpecialAttrChar(*chptr))) {
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		IsNormalChar(*(chptr + 1))) {
		chptr++;
		if (count_gcells)
		    len++;
	    }
	    len++;
	}
    }				/* end for */

    return (NULL);
}

/*
 * Allocate a new copy of a string, and returns it.
 */
char *SNACopy(char **dest,
	      const char *src,
	      int n)
{
    FREE(*dest);
    if (src) {
	*dest = typeMallocn(char, n + 1);

	if (*dest == NULL) {
	    CTRACE((tfp, "Tried to malloc %d bytes\n", n));
	    outofmem(__FILE__, "SNACopy");
	}
	strncpy(*dest, src, n);
	*(*dest + n) = '\0';	/* terminate */
    }
    return *dest;
}

/*
 * String Allocate and Concatenate.
 */
char *SNACat(char **dest,
	     const char *src,
	     int n)
{
    if (non_empty(src)) {
	if (*dest) {
	    int length = strlen(*dest);

	    *dest = (char *) realloc(*dest, length + n + 1);
	    if (*dest == NULL)
		outofmem(__FILE__, "SNACat");
	    strncpy(*dest + length, src, n);
	    *(*dest + length + n) = '\0';	/* terminate */
	} else {
	    *dest = typeMallocn(char, n + 1);

	    if (*dest == NULL)
		outofmem(__FILE__, "SNACat");
	    memcpy(*dest, src, n);
	    (*dest)[n] = '\0';	/* terminate */
	}
    }
    return *dest;
}

#include <caselower.h>

/*
 * Returns lowercase equivalent for unicode,
 * transparent output if no equivalent found.
 */
static long UniToLowerCase(long upper)
{
    size_t i, high, low;
    long diff = 0;

    /*
     * Make check for sure.
     */
    if (upper <= 0)
	return (upper);

    /*
     * Try unicode_to_lower_case[].
     */
    low = 0;
    high = TABLESIZE(unicode_to_lower_case);
    while (low < high) {
	/*
	 * Binary search.
	 */
	i = (low + (high - low) / 2);
	diff = (unicode_to_lower_case[i].upper - upper);
	if (diff < 0)
	    low = i + 1;
	if (diff > 0)
	    high = i;
	if (diff == 0)
	    return (unicode_to_lower_case[i].lower);
    }

    return (upper);		/* if we came here */
}

/*
 *   UPPER8 ?
 *   it was "TOUPPER(a) - TOUPPER(b)" in its previous life...
 *
 *   It was realized that case-insensitive user search
 *   got information about upper/lower mapping from TOUPPER
 *   (precisely from "(TOUPPER(a) - TOUPPER(b))==0")
 *   and depends on locale in its 8bit mapping. -
 *   Usually fails with DOS/WINDOWS display charsets
 *   as well as on non-UNIX systems.
 *
 *   So use unicode case mapping.
 */
int UPPER8(int ch1, int ch2)
{
    /* if they are the same or one is a null characters return immediately. */
    if (ch1 == ch2)
	return 0;
    if (!ch2)
	return UCH(ch1);
    else if (!ch1)
	return -UCH(ch2);

    /* case-insensitive match for us-ascii */
    if (UCH(TOASCII(ch1)) < 128 && UCH(TOASCII(ch2)) < 128)
	return (TOUPPER(ch1) - TOUPPER(ch2));

    /* case-insensitive match for upper half */
    if (UCH(TOASCII(ch1)) > 127 &&	/* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127) {
	if (DisplayCharsetMatchLocale)
	    return (TOUPPER(ch1) - TOUPPER(ch2));	/* old-style */
	else {
	    long uni_ch2 = UCTransToUni((char) ch2, current_char_set);
	    long uni_ch1;

	    if (uni_ch2 < 0)
		return UCH(ch1);
	    uni_ch1 = UCTransToUni((char) ch1, current_char_set);
	    return (UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
	}
    }

    return (-10);		/* mismatch, if we come to here */
}

/*
 * Replaces 'fgets()' calls into a fixed-size buffer with reads into a buffer
 * that is allocated.  When an EOF or error is found, the buffer is freed
 * automatically.
 */
char *LYSafeGets(char **src,
		 FILE *fp)
{
    char buffer[BUFSIZ];
    char *result = 0;

    if (src != 0)
	result = *src;
    if (result != 0)
	*result = 0;

    while (fgets(buffer, sizeof(buffer), fp) != 0) {
	if (*buffer)
	    result = StrAllocCat(result, buffer);
	if (strchr(buffer, '\n') != 0)
	    break;
    }
    if (ferror(fp)) {
	FREE(result);
    } else if (feof(fp) && result && *result == '\0') {
	/*
	 * If the file ends in the middle of a line, return the partial line;
	 * if another call is made after this, it will return NULL.  - kw
	 */
	FREE(result);
    }
    if (src != 0)
	*src = result;
    return result;
}

#ifdef EXP_CMD_LOGGING
static FILE *cmd_logfile;
static FILE *cmd_script;

void LYOpenCmdLogfile(int argc,
		      char **argv)
{
    int n;

    if (lynx_cmd_logfile != 0) {
	cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
	if (cmd_logfile != 0) {
	    fprintf(cmd_logfile, "# Command logfile created by %s %s (%s)\n",
		    LYNX_NAME, LYNX_VERSION, LYVersionDate());
	    for (n = 0; n < argc; n++) {
		fprintf(cmd_logfile, "# Arg%d = %s\n", n, argv[n]);
	    }
	}
    }
}

BOOL LYHaveCmdScript(void)
{
    return (BOOL) (cmd_script != 0);
}

void LYOpenCmdScript(void)
{
    if (lynx_cmd_script != 0) {
	cmd_script = fopen(lynx_cmd_script, TXT_R);
	CTRACE((tfp, "LYOpenCmdScript(%s) %s\n",
		lynx_cmd_script,
		cmd_script != 0 ? "SUCCESS" : "FAIL"));
    }
}

int LYReadCmdKey(int mode)
{
    int ch = -1;

    if (cmd_script != 0) {
	char *buffer = 0;
	char *src;
	char *tmp;
	unsigned len;

	while ((ch < 0) && LYSafeGets(&buffer, cmd_script) != 0) {
	    LYTrimTrailing(buffer);
	    src = LYSkipBlanks(buffer);
	    tmp = LYSkipNonBlanks(src);
	    switch (len = (tmp - src)) {
	    case 4:
		if (!strncasecomp(src, "exit", 4))
		    exit_immediately(0);
		break;
	    case 3:
		if (!strncasecomp(src, "key", 3)) {
		    ch = LYStringToKeycode(LYSkipBlanks(tmp));
		} else if (!strncasecomp(src, "set", 3)) {
		    src = LYSkipBlanks(tmp);
		    tmp = src;
		    while (*tmp != '\0') {
			if (isspace(UCH(*tmp)) || *tmp == '=')
			    break;
			++tmp;
		    }
		    if (*tmp != '\0') {
			*tmp++ = '\0';
			tmp = LYSkipBlanks(tmp);
		    }
		    CTRACE((tfp, "LYSetConfigValue(%s, %s)\n", src, tmp));
		    LYSetConfigValue(src, tmp);
		}
		break;
	    }
	}
	if (feof(cmd_script)) {
	    fclose(cmd_script);
	    cmd_script = 0;
	}
	if (ch >= 0) {
	    LYSleepReplay();
	    LYrefresh();
	}
	FREE(buffer);
    } else {
	ch = LYgetch_for(mode);
    }
    CTRACE((tfp, "LYReadCmdKey(%d) ->%s (%#x)\n",
	    mode, LYKeycodeToString(ch, TRUE), ch));
    LYWriteCmdKey(ch);
    return ch;
}

/*
 * Write a LYKeymapCode 'ch' to the logfile.
 */
void LYWriteCmdKey(int ch)
{
    if (cmd_logfile != 0) {
	fprintf(cmd_logfile, "key %s\n", LYKeycodeToString(ch, FALSE));
    }
}

void LYCloseCmdLogfile(void)
{
    if (cmd_logfile != 0) {
	LYCloseOutput(cmd_logfile);
	cmd_logfile = 0;
    }
    if (cmd_script != 0) {
	LYCloseInput(cmd_script);
	cmd_script = 0;
    }
    FREE(lynx_cmd_logfile);
    FREE(lynx_cmd_script);
}
#endif /* EXP_CMD_LOGGING */
@


1.9
log
@automatic merge; regen configure
@
text
@d280 1
a280 1
    char *data = HTList_removeFirstObject(list);
d308 1
a308 1
	data = HTList_nextObject(list);
d458 1
a458 1
	    char *text = LYGetHiliteStr(i, count);
d623 3
a625 3
char *LYmbcs_skip_glyphs(char *data,
			 int n_glyphs,
			 BOOL utf_flag)
d656 1
a656 1
int LYmbcsstrlen(char *str,
d695 1
a695 1
#ifdef VMS
d697 3
a699 9
#else
#ifdef __DJGPP__
#ifdef DJGPP_KEYHANDLER
#define GetChar getxkey
#else
#define GetChar SLkp_getkey
#endif /* DJGPP_KEYHANDLER */
#else
#ifdef __CYGWIN__
d703 5
a707 6
#endif /* __CYGWIN__ */
#endif /* __DJGPP__ */
#endif /* VMS */
#endif /* USE_SLANG */

#if !defined(GetChar) && defined(NCURSES)
d710 1
d862 1
a862 1
    char *string;
d925 1
a925 1
    char *name = 0;
d1411 1
a1411 1
	char *txt;
d1445 1
a1445 1
    char *choices[TOTAL_MENUENTRIES + 1];
d2570 14
d2853 1
a2853 1
int LYEditInsert(EDREC * edit, unsigned char *s,
d2881 1
a2881 1
	unsigned char *e = s + len;
d2921 2
a2922 1
	unsigned char *e = s + len, *t = (unsigned char *) Buf + Pos;
d2941 1
a2941 1
	strncpy(Buf + Pos, (char *) s, len);
d3397 1
a3397 1
int get_popup_number(char *msg,
d3727 1
a3727 1
	result[j++] = HTList_nextObject(list);
d3882 2
a3883 1
    int ch = 0, recall;
d3890 1
a3890 1
    char *popup_status_msg = NULL;
d4974 1
a4974 1
					     (unsigned char *) " ",
d5134 2
a5135 2
char *LYno_attr_char_case_strstr(char *chptr,
				 char *tarptr)
d5137 1
a5137 1
    register char *tmpchptr, *tmptarptr;
d5187 2
a5188 2
char *LYno_attr_char_strstr(char *chptr,
			    char *tarptr)
d5190 1
a5190 1
    register char *tmpchptr, *tmptarptr;
d5250 6
a5255 6
char *LYno_attr_mbcs_case_strstr(char *chptr,
				 const char *tarptr,
				 BOOL utf_flag,
				 BOOL count_gcells,
				 int *nstartp,
				 int *nendp)
d5257 1
a5257 1
    char *tmpchptr;
d5413 6
a5418 6
char *LYno_attr_mbcs_strstr(char *chptr,
			    const char *tarptr,
			    BOOL utf_flag,
			    BOOL count_gcells,
			    int *nstartp,
			    int *nendp)
d5420 1
a5420 1
    char *tmpchptr;
d5771 1
a5771 1
		    exit(0);
@


1.8
log
@automatic merge of lynx-current
@
text
@d375 1
a375 1
    int right = LYcols - 6;
d389 1
a389 1
	else if (y == 0 && x == LYcols - 1 && s_hot_paste != NOSTYLE)
d425 1
a425 1
    } else if (x == LYcols - 1 && LYShowScrollbar && LYsb_begin >= 0) {
d662 24
a685 17
    if (!non_empty(str))
	return (len);

    for (i = 0; str[i] != '\0'; i++) {
	if (IsSpecialAttrChar(str[i])) {
	    continue;
	} else {
	    len++;
	}
	if (IS_NEW_GLYPH(str[i])) {
	    j = 0;
	    while (str[(i + 1)] != '\0' &&
		   !IsSpecialAttrChar(str[(i + 1)]) &&
		   j < 5 &&
		   IS_UTF_EXTRA(str[(i + 1)])) {
		i++;
		j++;
a686 4
	} else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
		   is8bits(str[i]) && str[(i + 1)] != '\0' &&
		   !IsSpecialAttrChar(str[(i + 1)])) {
	    i++;
a688 1

d2258 1
a2258 1
		int right = (LYcols - H_CMD_AREA);
d2685 1
a2685 1
    if (len > (LYcols - 10)) {
d2688 1
a2688 1
	for (s = (buff + len) - (LYcols - 10) + cut_pos + 1,
d4012 3
d4016 3
a4018 3
	if (Lnum + (int) width + 4 < LYcols) {
	    if (lx - 1 + (Lnum + (int) width + 4) > LYcols)
		lx = LYcols + 1 - (Lnum + width + 4);
d4028 3
d4033 4
a4036 3
	|| (form_window = LYstartPopup(top, lx,
				       bottom - top,
				       Lnum + width)) == 0)
d4039 3
d4800 1
a4800 1
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, (LYcols - 1) - x);
d5267 1
a5267 2
	     *(chptr + 1) != '\0' &&
	     !IsSpecialAttrChar(*(chptr + 1))) ||
d5292 1
a5292 2
		*tmpchptr != '\0' &&
		!IsSpecialAttrChar(*tmpchptr)) {
d5368 1
a5368 2
		*(chptr + 1) != '\0' &&
		!IsSpecialAttrChar(*(chptr + 1))) {
d5451 1
a5451 2
		*tmpchptr != '\0' &&
		!IsSpecialAttrChar(*tmpchptr)) {
d5526 1
a5526 2
		*(chptr + 1) != '\0' &&
		!IsSpecialAttrChar(*(chptr + 1))) {
@


1.7
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d59 9
a67 9
** simple to do.  Once you've determined the X and Y coordinates of
** the mouse event, loop through the elements in the links[] array and
** see if the coordinates fall within a highlighted link area.	If so,
** the code must set mouse_link to the index of the chosen link,
** and return a key value that corresponds to LYK_ACTIVATE.  The
** LYK_ACTIVATE code in LYMainLoop.c will then check mouse_link
** and activate that link.  If the mouse event didn't fall within a
** link, the code should just set mouse_link to -1 and return -1. --AMK
**/
d79 1
a79 1
int peek_mouse_levent (void)
d92 1
a92 1
int get_mouse_link (void)
d95 1
d104 1
a104 1
int peek_mouse_link (void)
d109 2
a110 5

int fancy_mouse (
    WINDOW *	win,
    int	row,
    int *	position)
d113 1
d122 2
a123 2
      && (MOUSE_X_POS >= getbegx(win)
      && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
d127 1
a127 1
	if (mypos+1 == getmaxy(win)) {
d174 1
a174 1
    MEVENT	event;
d178 2
a179 2
			      | BUTTON1_DOUBLE_CLICKED
			      | BUTTON1_TRIPLE_CLICKED))) {
d186 1
a186 1
	if (mypos+1 == getmaxy(win)) {
d196 1
a196 1
			      | BUTTON1_TRIPLE_CLICKED))
d210 1
a210 1
			      | BUTTON1_TRIPLE_CLICKED))
d249 1
a249 1
#endif  /* USE_MOUSE */
d256 1
a256 2
static HTList *whichRecall (
    RecallType		recall)
d278 1
a278 1
static void LYRemoveFromCloset (HTList * list)
d286 1
a286 1
void LYCloseCloset (RecallType recall)
d290 1
a290 1
    while (!HTList_isEmpty(list) ) {
d301 1
a301 1
static char * LYFindInCloset (RecallType recall, char* base)
d310 1
a310 1
	    return(data);
d313 1
a313 1
    return(0);
d316 1
a316 1
static void LYAddToCloset (RecallType recall, char* str)
d328 5
a332 6
static int XYdist (
    int	x1,
    int	y1,
    int	x2,
    int	y2,
    int	dx2)
d337 1
a337 1
	xerr = 3 * (x1 - x2 - dx2) + 1;	/* pos after string not really in it */
d343 2
a344 2
	return (xerr > 0) ? (xerr*2 - 1) : 0;
    if (xerr < 9 && yerr)   /* x-dist of 3 cell better than y-dist of 1 cell */
d346 1
a346 1
    return 2 * xerr + yerr; /* Subjective factor; ratio -> approx. 6 / 9 */
d363 10
a372 11
** index of the corresponding hyperlink, or set mouse_link to -1 if no
** link matches the event.  Returns -1 if no link matched the click,
** or a keycode that must be returned from LYgetch() to activate the
** link.
**/

static int set_clicked_link (
    int	x,
    int	y,
    int	code,
    int	clicks)
d375 2
a376 1
    int right = LYcols-6;
d381 1
a381 1
    if (y == (LYlines-1) || y == 0) {	/* First or last row */
d386 1
a386 1
	if (x == 0 && toolbar)		/* On '#' */
d394 1
a394 1
		c = (code==FOR_PROMPT && y)
d397 1
a397 1
		c = (code==FOR_PROMPT && y)
d399 1
a399 1
	    else if (y)			/* Last row */
d401 1
a401 1
	    else			/* First row */
d405 1
a405 1
		c = (code==FOR_PROMPT && y)
d409 3
a411 3
			(s_forw_backw != NOSTYLE && x - toolbar >= 3)
			? LAC_TO_LKC0(LYK_NEXT_DOC)
			: LAC_TO_LKC0(LYK_PREV_DOC)
d413 1
a413 1
			LAC_TO_LKC0(LYK_NEXT_DOC)
d415 1
a415 1
			);
d417 1
a417 1
		c = (code==FOR_PROMPT && y)
d419 1
a419 1
	    else if (y)			/* Last row */
d421 1
a421 1
	    else			/* First row */
d426 1
a426 1
	int h = display_lines - 2*(LYsb_arrow != 0);
d436 1
a436 1
	    double frac = (1. * y)/(h - 1);
d441 1
a441 1
		LYSetNewline((int)(frac * l + 1 + 0.5));
d449 1
a449 1
	mouse_link = -1;		/* No action in edit fields */
d452 1
a452 2
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */
	    cur_err;
d473 1
a473 1
		   && (text = LYGetHiliteStr(i, ++count)) != NULL) {
d479 1
d488 1
a488 1
		    LYGetYX(cury,curx);
d494 1
a494 1
			    /* submit current input field directly */
d506 1
a506 1
			/* Do not pick up the current input field */
d537 12
a548 13
	}
	else {
	   if (2*y > LYlines){		/* Bottom Half of the screen */
	      if (4*y < 3*LYlines){
		c = LAC_TO_LKC0(LYK_DOWN_TWO);	/* Third quarter */
	      } else
		c = LAC_TO_LKC0(LYK_DOWN_HALF);	/* Fourth quarter */
	   } else {			/* Upper Half of the screen */
	      if (4*y < LYlines){
		c = LAC_TO_LKC0(LYK_UP_HALF);	/* First quarter */
	      } else
		c = LAC_TO_LKC0(LYK_UP_TWO);	/* Second quarter */
	   }
d556 2
a557 2
 *  LYstrncpy() terminates strings with a null byte.
 *  Writes a null byte into the n+1 byte of dst.
d559 3
a561 4
char *LYstrncpy (
	char *		dst,
	const char *	src,
	int		n)
d575 1
a575 1
	*(dst+len) = '\0';
d577 1
a577 1
	*(dst+n) = '\0';
d585 10
a594 12
 *  LYmbcsstrncpy() terminates strings with a null byte.
 *  It takes account of multibyte characters.
 *  The src string is copied until either end of string or max number of
 *  either bytes or glyphs (mbcs sequences) (CJK or UTF8).  The utf_flag
 *  argument should be TRUE for UTF8. - KW & FM
 */
char * LYmbcsstrncpy (
	char *		dst,
	const char *	src,
	int		n_bytes,
	int		n_glyphs,
	BOOL		utf_flag)
d619 7
a625 8
 *  LYmbcs_skip_glyphs() skips a given number of display positions
 *  in a string and returns the resulting pointer.  It takes account
 *  of UTF-8 encoded characters. - KW
 */
char * LYmbcs_skip_glyphs (
	char *		data,
	int		n_glyphs,
	BOOL		utf_flag)
d649 10
a658 12
 *  LYmbcsstrlen() returns the printable length of a string
 *  that might contain IsSpecial or multibyte (CJK or UTF8)
 *  characters. - FM
 *  Counts glyph cells if count_gcells is set. (Full-width
 *  characters in CJK mode count as two.)
 *  Counts character glyphs if count_gcells is unset. (Full-
 *  width characters in CJK mode count as one.) - kw
 */
int LYmbcsstrlen (
	char *		str,
	BOOL		utf_flag,
	BOOL		count_gcells)
d663 1
a663 1
	return(len);
d682 1
a682 1
		    !IsSpecialAttrChar(str[(i + 1)])) {
d687 1
a687 1
    return(len);
d720 1
a720 1
static int myGetChar (void)
d726 8
a733 9
	switch (c = wgetch(LYwin))
	{
	case KEY_SHIFT_L :
	case KEY_SHIFT_R :
	case KEY_CONTROL_L :
	case KEY_CONTROL_R :
	case KEY_ALT_L :
	case KEY_ALT_R :
	case KEY_RESIZE :
d760 1
a760 1
#define GetChar() getchar()  /* used to be "getc(stdin)" and "getch()" */
d765 1
a765 1
static int sl_parse_mouse_event (int * x, int * y, int * button)
d770 2
a771 3
    *button = SLang_getkey ();
    switch (*button)
    {
d779 1
a779 1
	SLang_flush_input ();
d783 1
a783 1
    *x = SLang_getkey ();
d785 1
a785 1
	*x = SLang_getkey () + 64 - 33;
d788 1
a788 1
    *y = SLang_getkey ();
d790 1
a790 1
	*y = SLang_getkey () + 64 - 33;
d796 1
a796 2
static int sl_read_mouse_event (
    int	code)
d798 9
a806 1
   int mouse_x, mouse_y, button;
d808 13
a820 22
   mouse_link = -1;
   if (-1 != sl_parse_mouse_event (&mouse_x, &mouse_y, &button))
     {
	if (button == 0)  /* left */
	  return set_clicked_link (mouse_x, mouse_y, FOR_PANEL, 1);

	if (button == 1)  /* middle */
	  return LYReverseKeymap (LYK_VIEW_BOOKMARK);

	if (button == 2)   /* right */
	  {
	     /* Right button: go back to prev document.
	      * The problem is that we need to determine
	      * what to return to achieve this.
	      */
	     return LYReverseKeymap (LYK_PREV_DOC);
	  }
     }
   if (code == FOR_INPUT || code == FOR_PROMPT)
       return DO_NOTHING;
   else
       return -1;
d822 1
a822 2
#endif  /* USE_SLANG and USE_MOUSE */

d825 1
a825 2
void ena_csi (
    BOOLEAN	flag)
d838 1
d865 5
a869 8

typedef struct
{
   char *string;
   int value;
}
Keysym_String_List;

d889 1
d896 1
a896 1
static int lookup_tiname (char *name, NCURSES_CONST char *const *names)
d906 1
a906 1
static const char *expand_tiname (const char *first, size_t len, char **result, char *final)
d914 1
a914 1
     || (code = lookup_tiname(name, strfnames)) >= 0) {
d923 1
a923 1
static const char *expand_tichar (const char *first, char **result, char *final)
d932 33
a964 10
    case 'E': case 'e':	value = 27;			break;
    case 'a':		name  = "bel";			break;
    case 'b':		value = '\b';			break;
    case 'f':		value = '\f';			break;
    case 'n':		value = '\n';			break;
    case 'r':		value = '\r';			break;
    case 't':		value = '\t';			break;
    case 'v':		value = '\v';			break;
    case 'd':		radix = 10;	limit = 3;	break;
    case 'x':		radix = 16;	limit = 2;	break;
d979 1
d996 1
a996 1
static int expand_substring (char* dst, const char* first, const char* last, char *final)
d1010 1
d1013 1
a1013 1
		first = expand_tiname(first, s-first, &dst, final);
d1018 1
a1018 1
	    } else if (ch == '?') {		/* ASCII delete? */
d1027 1
a1027 1
	case 0:					/* convert nulls for terminfo */
d1040 1
a1040 1
static void unescaped_char (const char* parse, int* keysym)
d1052 1
a1052 1
static BOOLEAN unescape_string (char* src, char * dst, char * final)
d1058 1
d1070 1
a1070 1
int map_string_to_keysym (const char* str, int* keysym)
d1073 1
d1077 1
a1077 1
	char *other = strchr(str+4, ':');
d1080 2
a1081 2
	   int othersym = lecname_to_lec(other + 1);
	   char buf[BUFSIZ];
d1083 1
a1083 1
	   if (othersym >= 0 && other - str - 4 < BUFSIZ ) {
d1091 1
a1091 1
	   }
d1104 1
d1106 1
a1106 1
		return (*keysym = (UCH(str[0]))|modifier);
d1110 1
a1110 1
		return (*keysym = FROMASCII(UCH(str[1]&0x1f))|modifier);
d1113 1
a1113 1
		return (*keysym = CH_DEL|modifier);
d1116 5
a1120 1
		expand_substring(buf, str, str + HTMIN(len, 28), buf + sizeof(buf) - 1);
d1122 1
a1122 1
		    return (*keysym = (UCH(buf[0]))|modifier);
d1131 1
d1136 1
a1136 1
		*keysym |= LKC_ISLKC; /* caller should remove this flag - kw */
d1144 1
a1144 1
	    if (0 == strcmp (k->string, str)) {
d1161 1
a1161 1
static char *skip_keysym (char * parse)
d1191 1
a1191 1
static int setkey_cmd (char *parse)
d1208 1
a1208 1
	    if (map_string_to_keysym (s, &keysym) >= 0) {
d1211 1
a1211 1
		    return 0;		/* Trace the failure and continue. */
d1219 1
a1219 2
	    }
	    else {
d1222 1
a1222 2
	}
	else {
d1225 1
a1225 2
    }
    else {
d1231 1
a1231 1
static int unsetkey_cmd (char *parse)
d1234 1
d1244 3
a1246 2
	    if (map_string_to_keysym (parse, &keysym) >= 0)
		define_key((char *)0, keysym);
d1254 3
a1256 2
	SLang_undefine_key (parse, Keymap_List);
	if (SLang_Error) return -1;
d1268 1
a1268 1
static int read_keymap_file (void)
d1270 1
d1275 2
a1276 2
	{"setkey",   setkey_cmd },
	{"unsetkey", unsetkey_cmd },
d1278 1
d1288 1
a1288 1
    if ((fp = fopen (file, "r")) == 0)
d1303 3
a1305 3
	    if ( strlen(s) > len && !strncmp(s, table[n].name, len)
		 && (*(table[n].func))(LYSkipBlanks(s+len)) < 0 )
		fprintf (stderr, FAILED_READING_KEYMAP, linenum, file);
d1309 1
a1309 1
    LYCloseInput (fp);
d1313 1
a1313 1
static void setup_vtXXX_keymap (void)
d1315 1
d1367 2
d1370 1
d1375 1
a1375 1
int lynx_initialize_keymaps (void)
d1386 1
a1386 1
    if (NULL == (Keymap_List = SLang_create_keymap ("Lynx", NULL)))
d1390 1
a1390 2
    for (i = 1; i < 256; i++)
    {
d1392 1
a1392 1
	define_key (keybuf, i);
d1396 1
a1396 1
    define_key ("\033[M", MOUSE_KEYSYM);
d1399 1
a1399 1
	SLang_exit_error ("Unable to initialize keymaps");
d1406 1
a1406 2
#endif				       /* USE_KEYMAPS */

d1409 1
a1409 1
static int LYmouse_menu (int x, int y, int atlink, int code)
d1413 1
d1446 2
d1466 2
a1467 2
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x-5 : 1),
		     choices, c1, FALSE, TRUE);
d1470 4
a1473 5
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
d1484 11
a1494 11
	    case LYK_ABORT:
		retlac = LYK_QUIT; /* a bit softer... */
		/* fall through */
	    case LYK_MAIN_MENU:
	    case LYK_PREV_DOC:
	    case LYK_HOME:
	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_HISTORY:
	    case LYK_HELP:
d1496 14
a1509 14
	    case LYK_RELOAD:
	    case LYK_ECGOTO:
	    case LYK_INFO:
	    case LYK_WHEREIS:
	    case LYK_PRINT:
	    case LYK_DOWN_TWO:
	    case LYK_DOWN_HALF:
	    case LYK_NEXT_PAGE:
	    case LYK_END:
	    case LYK_VIEW_BOOKMARK:
	    case LYK_COOKIE_JAR:
	    case LYK_INDEX_SEARCH:
	    case LYK_OPTIONS:
		mouse_link = -3; /* so LYgetch_for() passes it on - kw */
a1522 1

d1529 1
a1529 1
static int myGetChar (void)
d1532 1
d1538 1
a1538 2
static int LYgetch_for (
	int	code)
d1540 4
a1543 3
   SLang_Key_Type *key;
   int keysym;
   current_sl_modifier = 0;
d1545 2
a1546 2
   key = SLang_do_key (Keymap_List, myGetChar);
   if ((key == NULL) || (key->type != SLKEY_F_KEYSYM)) {
d1548 40
a1587 18
	   if ((key == NULL) && (current_sl_modifier == LKC_ISLKC)) {
		   key = SLang_do_key (Keymap_List, myGetChar);
		   keysym = key->f.keysym;
		   switch (keysym) {
			   case 'H': keysym = UPARROW; break;
			   case 'P': keysym = DNARROW; break;
			   case 'M': keysym = RTARROW; break;
			   case 'K': keysym = LTARROW; break;
			   case 'R': keysym = INSERT_KEY; break;
			   case 'S': keysym = REMOVE_KEY; break;
			   case 'I': keysym = PGUP; break;
			   case 'Q': keysym = PGDOWN; break;
			   case 'G': keysym = HOME; break;
			   case 'O': keysym = END_KEY; break;
			   case ';': keysym = F1; break;
		   }
		   return(keysym);
	   }
d1590 2
a1591 2
     return (current_sl_modifier ? 0 : DO_NOTHING);
   }
d1593 1
a1593 1
   keysym = key->f.keysym;
d1596 2
a1597 2
   if (keysym == MOUSE_KEYSYM)
     return sl_read_mouse_event (code);
d1600 2
a1601 2
   if (keysym < 0)
       return 0;
d1603 2
a1604 2
   if (keysym & (LKC_ISLECLAC|LKC_ISLAC))
       return (keysym);
d1606 5
a1610 5
   current_sl_modifier = 0;
   if (LKC_HAS_ESC_MOD(keysym)) {
       current_sl_modifier = LKC_MOD2;
       keysym &= LKC_MASK;
   }
d1612 2
a1613 2
   if (keysym+1 >= KEYMAP_SIZE)
     return 0;
d1615 1
a1615 1
   return (keysym|current_sl_modifier);
d1619 1
a1619 2
#else	/* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

d1622 1
a1622 1
 *  LYgetch() translates some escape sequences and may fake noecho.
d1626 1
a1626 2
static int LYgetch_for (
	int	code)
d1634 2
a1635 2
re_read:
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
d1638 1
a1638 1
#endif  /* UCX && VAXC */
d1640 1
a1640 1
    clearerr(stdin); /* needed here for ultrix and SOCKETSHR, but why? - FM */
d1651 1
a1651 1
	if (c == EOF && errno == EINTR) /* Ctrl-Z causes EINTR in getchar() */
d1659 1
a1659 1
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1671 1
a1671 1
	    )) {
d1673 1
d1682 1
d1695 1
d1699 1
a1699 1
		"nozap: freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
d1719 6
a1724 6
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		  recent_sizechange));
	   if (!recent_sizechange) { /* not yet detected by ourselves */
	       size_change(0);
	       CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	   }
d1726 2
a1727 2
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		  recent_sizechange));
d1729 1
a1729 1
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
d1731 2
a1732 2
#endif  /* UCX && VAXC */
	return(DO_NOTHING);
d1744 1
a1744 1
	return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1746 1
a1746 1
#else  /* not USE_SLANG: */
d1749 1
a1749 1
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1758 1
a1758 1
	if (c == ERR && errno == EINTR) /* may have been handled signal - kw */
d1770 1
a1770 1
	done_esc = TRUE;		/* Flag: we did it, not keypad() */
d1780 36
a1815 12
	case 'A': c = UPARROW; break;
	case 'B': c = DNARROW; break;
	case 'C': c = RTARROW; break;
	case 'D': c = LTARROW; break;
	case 'q': c = END_KEY; break;	/* vt100 application keypad 1 */
	case 'r': c = DNARROW; break;	/* vt100 application keypad 2 */
	case 's': c = PGDOWN;  break;	/* vt100 application keypad 3 */
	case 't': c = LTARROW; break;	/* vt100 application keypad 4 */
	case 'v': c = RTARROW; break;	/* vt100 application keypad 6 */
	case 'w': c = HOME;    break;	/* vt100 application keypad 7 */
	case 'x': c = UPARROW; break;	/* vt100 application keypad 8 */
	case 'y': c = PGUP;    break;	/* vt100 application keypad 9 */
d1818 3
a1820 5
	   if (found_CSI(c,b))
	     {
		c = sl_read_mouse_event (code);
	     }
	   else
d1822 2
a1823 2
	     c = '\n';		/* keypad enter on pc ncsa telnet */
	   break;
d1835 1
a1835 1
		done_esc = FALSE; /* we have another look below - kw */
d1861 2
a1862 2
	case '1':		/** VTxxx  Find  **/
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1865 1
a1865 1
		done_esc = FALSE; /* we have another look below - kw */
d1868 2
a1869 2
	    if (found_CSI(c,b)) {
		if ((d=GetChar())=='~')     /** VTxxx Insert **/
d1873 2
a1874 3
			 GetChar() == '~')
		 {
		    if (d == '8')	     /** VTxxx	Help **/
d1876 1
a1876 1
		    else if (d == '9')	     /** VTxxx	 Do  **/
d1879 3
a1881 4
		 }
	    }
	    else
		done_esc = FALSE; /* we have another look below - kw */
d1884 1
a1884 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1887 1
a1887 1
		done_esc = FALSE; /* we have another look below - kw */
d1890 1
a1890 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1893 1
a1893 1
		done_esc = FALSE; /* we have another look below - kw */
d1896 1
a1896 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1899 1
a1899 1
		done_esc = FALSE; /* we have another look below - kw */
d1902 1
a1902 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1905 1
a1905 1
		done_esc = FALSE; /* we have another look below - kw */
d1908 2
a1909 2
	    if (found_CSI(c,b)) {
		if ((d=GetChar()) == 'A')
d1915 1
a1915 1
	    if (c == CH_ESC && a == b && !found_CSI(c,b)) {
d1922 1
a1922 1
	    CTRACE((tfp,"Unknown key sequence: %d:%d:%d\n",c,b,a));
d1926 1
a1926 1
	if (isdigit(a) && found_CSI(c,b) && d != -1 && d != '~')
d1929 1
a1929 1
	    if (a == b && !found_CSI(c,b) && c == CH_ESC) {
d1940 1
a1940 1
    if (c >= 0 && (c&LKC_ISLECLAC)) {
d1943 1
a1943 1
    } else if (c >= 0 && (c&LKC_ISLKC)) {
d1945 1
a1945 1
	done_esc = TRUE; /* already a lynxkeycode, skip keypad switches - kw */
d1951 2
a1952 2
    if (c >= 0 && (c&(LKC_ISLECLAC|LKC_ISLAC))) {
	done_esc = TRUE; /* already a lynxactioncode, skip keypad switches - iz */
d1960 1
a1960 1
	 *  Convert keypad() mode keys into Lynx defined keys.
d1962 4
a1965 4
	switch(c) {
	case KEY_DOWN:		   /* The four arrow keys ... */
	   c = DNARROW;
	   break;
d1967 2
a1968 2
	   c = UPARROW;
	   break;
d1970 5
a1974 5
	   c = LTARROW;
	   break;
	case KEY_RIGHT:		   /* ... */
	   c = RTARROW;
	   break;
d1977 2
a1978 2
	   c = DNARROW;
	   break;
d1980 2
a1981 2
	   c = UPARROW;
	   break;
d1983 2
a1984 2
	   c = LTARROW;
	   break;
d1986 8
a1993 8
	   c = RTARROW;
	   break;
	case PAD0:		   /* PC-9800 Ins */
	   c = INSERT_KEY;
	   break;
	case PADSTOP:		   /* PC-9800 DEL */
	   c = REMOVE_KEY;
	   break;
d1995 15
a2009 15
	case KEY_HOME:		   /* Home key (upward+left arrow) */
	   c = HOME;
	   break;
	case KEY_CLEAR:		   /* Clear screen */
	   c = 18; /* CTRL-R */
	   break;
	case KEY_NPAGE:		   /* Next page */
	   c = PGDOWN;
	   break;
	case KEY_PPAGE:		   /* Previous page */
	   c = PGUP;
	   break;
	case KEY_LL:		   /* home down or bottom (lower left) */
	   c = END_KEY;
	   break;
d2011 19
a2029 19
					/* The keypad is arranged like this:*/
					/*    a1    up	  a3   */
					/*   left   b2	right  */
					/*    c1   down   c3   */
	case KEY_A1:		   /* upper left of keypad */
	   c = HOME;
	   break;
	case KEY_A3:		   /* upper right of keypad */
	   c = PGUP;
	   break;
	case KEY_B2:		   /* center of keypad */
	   c = DO_NOTHING;
	   break;
	case KEY_C1:		   /* lower left of keypad */
	   c = END_KEY;
	   break;
	case KEY_C3:		   /* lower right of keypad */
	   c = PGDOWN;
	   break;
d2032 3
a2034 3
	case KEY_ENTER:		   /* enter/return	*/
	   c = '\n';
	   break;
d2036 1
a2036 1
#ifdef PADENTER			   /* PDCURSES */
d2038 2
a2039 2
	   c = '\n';
	   break;
d2042 3
a2044 3
	case KEY_END:		   /* end key		001 */
	   c = END_KEY;
	   break;
d2047 3
a2049 3
	case KEY_HELP:		   /* help key		001 */
	   c = F1;
	   break;
d2053 2
a2054 2
	   c = CH_DEL;		   /* backspace key (delete, not Ctrl-H)  S/390 -- gil -- 2041 */
	   break;
d2057 2
a2058 2
	   c = F1;		   /* VTxxx Help */
	   break;
d2061 2
a2062 2
	   c = DO_KEY;		   /* VTxxx Do */
	   break;
d2065 3
a2067 3
	case KEY_REDO:		   /* VTxxx Do */
	   c = DO_KEY;
	   break;
d2071 2
a2072 2
	   c = FIND_KEY;	   /* VTxxx Find */
	   break;
d2076 2
a2077 2
	   c = SELECT_KEY;	   /* VTxxx Select */
	   break;
d2081 2
a2082 2
	   c = INSERT_KEY;	   /* VTxxx Insert */
	   break;
d2086 2
a2087 2
	   c = REMOVE_KEY;	   /* VTxxx Remove */
	   break;
d2091 2
a2092 2
	   c = BACKTAB_KEY;	   /* Back tab, often Shift-Tab */
	   break;
d2095 1
a2095 1
	case KEY_RESIZE:	   /* size change detected by ncurses */
d2102 1
a2102 1
		  recent_sizechange));
d2107 1
a2107 1
		  recent_sizechange));
d2110 6
a2115 6
#if 0			/* assumption seems flawed? */
		/*  Not detected by us or already processed by us.  It can
		 *  happens that ncurses lags behind us in detecting the
		 *  change, since its own SIGTSTP handler is not installed
		 *  so detecting happened *at the end* of the last refresh.
		 *  Tell it to refresh again... - kw
d2129 3
a2131 3
		 *  May be just the delayed effect of mainloop()'s call
		 *  to resizeterm().  Pretend we haven't read anything
		 *  yet, don't return. - kw
d2136 2
a2137 2
	     *  Yep, we agree there was a change.  Return now so that
	     *  the caller can react to it. - kw
d2172 1
a2172 1
		c = MOUSE_KEY;		/* Will be processed by the caller */
d2177 1
d2193 1
a2193 1
		    return(code==FOR_PANEL ? 0 : DO_NOTHING);
d2195 1
a2195 1
		levent = event;		/* Allow setting pos in entry fields */
d2205 1
a2205 1
				 /* Cannot ignore: see LYCurses.c */
d2207 3
a2209 3
				( BUTTON1_PRESSED | BUTTON1_RELEASED
				  | BUTTON2_PRESSED | BUTTON2_RELEASED
				  | BUTTON3_PRESSED | BUTTON3_RELEASED))) {
d2219 1
a2219 1
			mouse_link = -1; /* Forget about approx stuff. */
d2238 1
a2238 1
#if 0	/* Probably not necessary any more - kw */
d2245 1
a2245 1
		    ungetmouse(&event);	/* Caller will process this. */
d2257 1
d2285 2
a2286 1
			    c = LTARROW;	p = "<-";
d2288 2
a2289 1
			    c = RTARROW;	p = "->";
d2291 2
a2292 1
			    c = 'z';		p = "Cancel";
d2294 2
a2295 1
			    c = PGDOWN;		p = "PGDOWN";
d2300 2
a2301 1
			    c = LTARROW;	p = "<-";
d2303 2
a2304 1
			    c = RTARROW;	p = "->";
d2306 2
a2307 1
			    c = 'z';		p = "Cancel";
d2309 2
a2310 1
			    c = PGUP;		p = "PGUP";
d2313 3
a2315 1
			c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL, 1);
d2323 2
a2324 2
		if ((c+1) >= KEYMAP_SIZE && (c&LKC_ISLAC))
		    return(c);
d2330 1
a2330 1
#endif  /* USE_MOUSE */
d2335 2
a2336 2
	switch(c) {
	case K_Down:		   /* The four arrow keys ... */
d2338 2
a2339 2
	   c = DNARROW;
	   break;
d2342 2
a2343 2
	   c = UPARROW;
	   break;
d2346 3
a2348 3
	   c = LTARROW;
	   break;
	case K_Right:		   /* ... */
d2350 3
a2352 3
	   c = RTARROW;
	   break;
	case K_Home:		   /* Home key (upward+left arrow) */
d2354 3
a2356 3
	   c = HOME;
	   break;
	case K_PageDown:	   /* Next page */
d2358 3
a2360 3
	   c = PGDOWN;
	   break;
	case K_PageUp:		   /* Previous page */
d2362 3
a2364 3
	   c = PGUP;
	   break;
	case K_End:		   /* home down or bottom (lower left) */
d2366 6
a2371 6
	   c = END_KEY;
	   break;
	case K_F1:		   /* F1 key */
	   c = F1;
	   break;
	case K_Insert:		   /* Insert key */
d2373 3
a2375 3
	   c = INSERT_KEY;
	   break;
	case K_Delete:		   /* Delete key */
d2377 14
a2390 14
	   c = REMOVE_KEY;
	   break;
	case K_Alt_Escape:	   /* Alt-Escape */
	   c = 0x1a7;
	   break;
	case K_Control_At:	   /* CTRL-@@ */
	   c = 0x1a8;
	   break;
	case K_Alt_Backspace:	   /* Alt-Backspace */
	   c = 0x1a9;
	   break;
	case K_BackTab:		   /* BackTab */
	   c = BACKTAB_KEY;
	   break;
d2394 4
a2397 4
	switch(c) {
	case SL_KEY_DOWN:	   /* The four arrow keys ... */
	   c = DNARROW;
	   break;
d2399 2
a2400 2
	   c = UPARROW;
	   break;
d2402 30
a2431 30
	   c = LTARROW;
	   break;
	case SL_KEY_RIGHT:	   /* ... */
	   c = RTARROW;
	   break;
	case SL_KEY_HOME:	   /* Home key (upward+left arrow) */
	case SL_KEY_A1:		   /* upper left of keypad */
	   c = HOME;
	   break;
	case SL_KEY_NPAGE:	   /* Next page */
	case SL_KEY_C3:		   /* lower right of keypad */
	   c = PGDOWN;
	   break;
	case SL_KEY_PPAGE:	   /* Previous page */
	case SL_KEY_A3:		   /* upper right of keypad */
	   c = PGUP;
	   break;
	case SL_KEY_END:	   /* home down or bottom (lower left) */
	case SL_KEY_C1:		   /* lower left of keypad */
	   c = END_KEY;
	   break;
	case SL_KEY_F(1):	   /* F1 key */
	   c = F1;
	   break;
	case SL_KEY_IC:		   /* Insert key */
	   c = INSERT_KEY;
	   break;
	case SL_KEY_DELETE:	   /* Delete key */
	   c = REMOVE_KEY;
	   break;
d2436 3
a2438 3
    if (c&(LKC_ISLAC|LKC_ISLECLAC))
	return(c);
    if ((c+1) >= KEYMAP_SIZE) {
d2440 3
a2442 3
	 *  Don't return raw values for KEYPAD symbols which we may have
	 *  missed in the switch above if they are obviously invalid when
	 *  used as an index into (e.g.) keypad[]. - KW
d2446 1
a2446 1
	return(c|current_modifier);
d2451 1
a2451 2
#endif	/* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

d2453 1
a2453 1
int LYgetch (void)
d2461 1
a2461 1
int LYgetch_choice (void)
d2464 1
d2466 1
a2466 1
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
d2473 1
a2473 1
int LYgetch_input (void)
d2476 1
d2478 1
a2478 1
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
d2486 1
a2486 1
int LYgetch_single (void)
d2489 1
d2491 1
a2491 1
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
d2500 1
a2500 2
void LYLowerCase (
	 char *	arg_buffer)
d2504 1
d2509 1
a2509 1
	 && buffer[i+1] != 0) {
d2526 1
a2526 2
void LYUpperCase (
	 char *	arg_buffer)
d2530 1
d2535 1
a2535 1
	 && buffer[i+1] != 0) {
d2552 1
a2552 2
BOOLEAN LYRemoveNewlines (
	char *		buffer)
d2555 3
a2557 3
	register char* buf = buffer;
	for ( ; *buf && *buf != '\n' && *buf != '\r'; buf++)
	    ;
d2560 3
a2562 2
	    char * old = buf;
	    for ( ; *old; old++) {
d2577 1
a2577 2
char * LYRemoveBlanks (
	char *		buffer)
d2580 3
a2582 3
	register char* buf = buffer;
	for ( ; *buf && !isspace(UCH(*buf)); buf++)
	    ;
d2585 3
a2587 2
	    char * old = buf;
	    for ( ; *old; old++) {
d2601 1
a2601 2
char * LYSkipBlanks (
	char *		buffer)
d2611 1
a2611 2
char * LYSkipNonBlanks (
	char *		buffer)
d2621 1
a2621 2
const char * LYSkipCBlanks (
	const char *	buffer)
d2631 1
a2631 2
const char * LYSkipCNonBlanks (
	const char *	buffer)
d2641 1
a2641 2
void LYTrimLeading (
	char *		buffer)
d2644 2
a2645 2
    while ((*buffer++ = *skipped++) != 0)
	;
d2651 1
a2651 2
char * LYTrimNewline (
	char *		buffer)
d2654 2
a2655 1
    while (i != 0 && (buffer[i-1] == '\n' || buffer[i-1] == '\r'))
d2663 1
a2663 2
void LYTrimTrailing (
	char *		buffer)
d2666 2
a2667 1
    while (i != 0 && isspace(UCH(buffer[i-1])))
d2674 2
a2675 3
char *LYElideString (
	char *		str,
	int		cut_pos)
d2681 1
a2681 1
    LYstrncpy(buff, str, sizeof(buff)-1);
d2691 1
a2691 2
	     (*d++ = *s++) != 0; )
	    ;
d2701 1
a2701 2
BOOLEAN LYTrimStartfile (
	char *		buffer)
d2707 4
a2710 5
	 *  The original implementations of these schemes expected
	 *  white space without hex escaping, and did not check
	 *  for hex escaping, so we'll continue to support that,
	 *  until that code is redone in conformance with SGML
	 *  principles.  - FM
d2722 1
a2722 2
void LYEscapeStartfile (
	char **		buffer)
d2726 1
d2735 1
a2735 2
void LYTrimAllStartfile (
	char *		buffer)
d2743 3
a2745 3
**  Display the current value of the string and allow the user
**  to edit it.
*/
d2750 1
a2750 1
 *  Shorthand to get rid of all most of the "edit->suchandsos".
d2767 3
a2769 5
void LYSetupEdit (
	EDREC *	edit,
	char *		old,
	int		maxstr,
	int		maxdsp)
d2772 1
a2772 1
     *	Initialize edit record
d2775 1
a2775 1
    edit->pad	= ' ';
d2780 1
a2780 1
    MaxLen  = maxstr;
d2782 1
a2782 1
    Margin  = 0;
d2789 2
a2790 2
    if (maxstr > maxdsp) {  /* Need panning? */
	if (DspWdth > 4)    /* Else "{}" take up precious screen space */
d2794 3
a2796 4
	 *  Figure out margins.  If too big, we do a lot of unnecessary
	 *  scrolling.	If too small, user doesn't have sufficient
	 *  look-ahead.  Let's say 25% for each margin, upper bound is
	 *  10 columns.
d2798 1
a2798 1
	Margin = DspWdth/4;
d2809 1
a2809 3
static int prev_pos (
	EDREC *	edit,
	int		pos)
d2820 1
d2823 1
a2823 1
		  !((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c)))) {
d2838 1
d2843 4
a2846 6
int LYEditInsert (
	EDREC *	edit,
	unsigned char *s,
	int		len,
	int		map,
	BOOL		maxMessage)
d2853 1
a2853 1
     *  ch is (presumably) printable character.
d2864 1
a2864 1
    for(; length >= Pos; length--)    /* Make room */
d2879 1
a2879 1
	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
d2911 1
a2911 1
	unsigned char *e = s + len, *t = (unsigned char *)Buf + Pos;
d2916 1
a2916 1
	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
d2927 5
a2932 6
    else
#endif	/* defined EXP_KEYBOARD_LAYOUT */
	{
	    strncpy(Buf + Pos, (char *) s, len);
	    edited = 1;
	}
d2947 1
a2947 1
	Mark = -1 - Mark;		/* Disable it */
d2952 7
a2958 9
int LYEdit1 (
	EDREC *	edit,
	int		ch,
	int		action,
	BOOL		maxMessage)
{   /* returns 0    character processed
     *         -ch  if action should be performed outside of line-editing mode
     *	       ch   otherwise
     */
d2964 1
a2964 1
	return(0); /* Be defensive */
d2973 1
a2973 1
	 *  Turn input character mapping on or off.
d2981 4
a2984 4
	 *  Hex 97.
	 *  Fall through as a character for CJK, or if this is a valid
	 *  character in the current display character set.
	 *  Otherwise, we treat this as LYE_ENTER.
d2987 1
a2987 1
	    return(ch);
d2993 1
a2993 1
	return 0;			/* All changes already registered */
d2997 6
a3002 7
	 *  ch is the second part (in most cases, a capital letter) of
	 *  a 7-bit replacement for a character in the 8-bit C1 control
	 *  range.
	 *  This is meant to undo transformations like
	 *  0x81 -> 0x1b 0x41 (ESC A) etc. done by slang on Unix and
	 *  possibly some comm programs.  It's an imperfect workaround
	 *  that doesn't work for all such characters.
d3015 1
a3015 1
		Mark = -1 - Mark;		/* Disable it */
d3017 3
a3019 3
	    for(i = length; i >= Pos; i--)    /* Make room */
		Buf[i+1] = Buf[i];
	    Buf[length+1]='\0';
d3024 3
a3026 3
	    _statusline(MAXLEN_REACHED_DEL_OR_MOV);
	}
	    return(ch);
d3033 2
a3034 2
	 *  Backword.
	 *  Definition of word is very naive: 1 or more a/n characters.
d3036 1
a3036 1
	while (Pos && !isalnum(Buf[Pos-1]))
d3038 1
a3038 1
	while (Pos &&  isalnum(Buf[Pos-1]))
d3042 3
a3044 3
	 *  Backword.
	 *  Definition of word is very naive: 1 or more a/n characters,
	 *  or 1 or more multibyte character.
d3063 2
a3064 2
		 && !is8bits(Buf[pos0])
		 && isalnum(UCH(Buf[pos0]))) {
d3075 1
a3075 1
	 *  Word forward.
d3079 1
a3079 1
	    Pos++;   /* '\0' is not a/n */
d3081 1
a3081 1
	    Pos++ ;
d3088 1
a3088 1
		Pos++;	/* '\0' is not a/n */
d3098 1
a3098 1
	 *  Erase the line to start fresh.
d3100 1
a3100 1
	 Buf[0] = '\0';
d3104 1
a3104 1
	 /* fall through */
d3108 1
a3108 1
	 *  Go to first column.
d3115 1
a3115 1
	 *  Go to last column.
d3122 1
a3122 1
	 *  Delete next word.
d3126 2
a3127 1
	    LYEdit1 (edit, 0, LYE_FORWW, FALSE);
d3135 1
a3135 1
	 *  Delete previous word.
d3139 2
a3140 1
	    LYEdit1 (edit, 0, LYE_BACKW, FALSE);
d3149 1
a3149 1
	 *  Delete from current cursor position back to BOL.
d3153 1
d3159 1
a3159 1
    case LYE_DELEL:	/* @@@@@@ */
d3161 1
a3161 1
	 *  Delete from current cursor position thru EOL.
d3165 1
d3175 2
a3176 2
	 *  Delete next character (I-beam style cursor), or current
	 *  character (box/underline style cursor).
d3189 1
a3189 1
	 *  Delete preceding character.
d3196 1
a3196 1
	    Mark = -1 - Mark;		/* Disable it */
d3202 1
a3202 1
	    Buf[i] = Buf[i+1];
d3221 1
a3221 1
		Mark = -1 - Mark;		/* Disable it */
d3233 1
a3233 1
	 *  Move cursor to the right.
d3241 1
a3241 1
	    if (HTCJK != NOCJK && is8bits(Buf[Pos-1]))
d3252 1
a3252 1
	 *  Left-arrow move cursor to the left.
d3272 1
a3272 1
	 *  Transpose characters - bash or ksh(emacs not gmacs) style
d3275 1
a3275 1
	    return(ch);
d3279 3
a3281 3
	    Mark = -1 - Mark;		/* Temporary enable it */
	if (Mark == Pos || Mark == Pos+1)
	    Mark = Pos-1;
d3283 2
a3284 2
	    Mark = -1 - Mark;		/* Disable it */
	if (Buf[Pos-1] == Buf[Pos]) {
d3288 3
a3290 1
	i = Buf[Pos-1]; Buf[Pos-1] = Buf[Pos]; Buf[Pos++] = (char) i;
d3295 1
a3295 1
	 *  primitive emacs-like set-mark-command
d3298 1
a3298 1
	return(0);
d3302 1
a3302 1
	 *  emacs-like exchange-point-and-mark
d3305 1
a3305 1
	    Mark = -1 - Mark;		/* Enable it */
d3307 4
a3310 2
	    return(0);
	i = Pos; Pos = Mark; Mark = i;
d3315 1
a3315 1
	 *  primitive emacs-like kill-region
d3318 1
a3318 1
	    Mark = -1 - Mark;		/* Enable it */
d3321 1
a3321 1
	    return(0);
d3329 4
a3332 4
		      HTMIN(reglen, (int)sizeof(killbuffer)-1));
	    for (i = Mark; Buf[i+reglen]; i++)
		Buf[i] = Buf[i+reglen];
	    Buf[i] = Buf[i+reglen]; /* terminate */
d3336 1
a3336 1
	    Mark = -1 - Mark;		/* Disable it */
d3341 1
a3341 1
	 *  primitive emacs-like yank
d3345 2
a3346 3
	    return(0);
	}
	{
d3349 1
a3349 1
	    if (Pos+yanklen <= (MaxLen) && StrLen+yanklen <= (MaxLen)) {
d3352 2
a3353 2
		for(i = length; i >= Pos; i--)    /* Make room */
		    Buf[i+yanklen] = Buf[i];
d3374 1
a3374 1
	return(ch);
d3378 1
a3378 1
    return(0);
d3382 7
a3388 8
**  This function prompts for a choice or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM & LE
*/
int get_popup_number (
	char *		msg,
	int *		c,
	int *		rel)
d3395 1
a3395 1
     *  Load the c argument into the prompt buffer.
d3402 1
a3402 1
     *  Get the number, possibly with a suffix, from the user.
d3408 1
a3408 1
	return(0);
d3413 1
a3413 1
    while ( isdigit(UCH(*p)) )
d3415 3
a3417 2
    switch ( *p ) {
    case '+': case '-':
d3419 2
a3420 1
	*rel = *p++; *c = *p;
d3431 2
a3432 2
     *  If we had a 'g' or 'p' suffix, load it into c.
     *  Otherwise, zero c.  Then return the number.
d3434 1
a3434 1
    if ( *p == 'g' || *p == 'G' ) {
d3436 1
a3436 1
    } else if (*p == 'p' || *p == 'P' ) {
d3441 1
a3441 1
    if ( *rel != '+' && *rel != '-' )
d3452 1
a3452 1
#endif	/* defined USE_COLOR_STYLE */
d3454 1
a3454 2
void LYRefreshEdit (
	EDREC *	edit)
d3462 1
d3476 1
a3476 1
    length=strlen(&Buf[0]);
d3478 15
a3492 15
/*
 *  Now we have:
 *                .--DspWdth---.
 *      +---------+=============+-----------+
 *      |         |M           M|           |   (M=margin)
 *      +---------+=============+-----------+
 *      0         DspStart                   length
 *
 *  Insertion point can be anywhere between 0 and stringlength.
 *  Figure out new display starting point.
 *
 *   The first "if" below makes Lynx scroll several columns at a time when
 *   extending the string.  Looks awful, but that way we can keep up with
 *   data entry at low baudrates.
 */
d3496 1
a3496 1
	    DspStart=(Pos - DspWdth) + Margin;
d3529 4
a3532 4
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
    }
d3542 1
a3542 1
    nrdisplayed = length-DspStart;
d3549 3
a3551 3
     *  If this is the last screen line, set attributes to normal,
     *  should only be needed for color styles.  The curses function
     *  may be used directly to avoid complications. - kw
d3561 1
a3561 1
		  prompting ? "prompt" : "active"));
d3565 1
a3565 1
	wattrset(LYwin,A_NORMAL); /* need to do something about colors? */
d3577 2
a3578 2
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			       || (DspStart + i == Pos && Pos < Mark) ))
d3580 2
a3581 2
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			       || (DspStart + i == Pos && Pos > Mark) ))
d3633 1
a3633 1
     *	Erase rest of input area.
d3635 1
a3635 1
    padsize = DspWdth-nrdisplayed;
d3644 1
a3644 1
     *	Scrolling indicators.
d3657 1
a3657 1
		LYaddch(' ');		/* Needed with styles? */
d3667 1
a3667 1
		LYaddch(' ');		/* Needed with styles? */
d3682 1
a3682 3
static void reinsertEdit (
    EditFieldData *	edit,
    char *		result)
d3687 1
a3687 1
	    LYLineEdit(edit, (int)(*result), FALSE);
d3693 2
a3694 3
static int caselessCmpList (
    const void *	a,
    const void *	b)
d3696 1
a3696 1
    return strcasecomp(*(const char *const *)a, *(const char *const *)b);
d3699 2
a3700 3
static int normalCmpList (
    const void *	a,
    const void *	b)
d3702 1
a3702 1
    return strcmp(*(const char *const *)a, *(const char *const *)b);
d3705 1
a3705 3
static char **sortedList (
    HTList *	list,
    BOOL	ignorecase)
d3719 1
a3719 1
	qsort((char *)result, count, sizeof(*result),
d3726 1
a3726 1
	     && !strcmp(result[j], result[k])) {
d3731 1
a3731 1
		for (jk = j; ; jk++) {
d3743 1
a3743 2
int LYarrayLength (
    const char **	list)
d3752 1
a3752 2
int LYarrayWidth (
    const char **	list)
d3765 4
a3768 5
static void FormatChoiceNum (
	char *		dst,
	int		num_choices,
	int		choice,
	const char *	value)
d3772 1
d3774 2
a3775 2
			digits, (choice + 1),
			MAX_LINE - 9 - digits, value);
d3777 1
a3777 1
	LYstrncpy(dst, value, MAX_LINE-1);
d3781 1
a3781 2
static unsigned options_width (
	const char **	list)
d3795 6
a3800 8
static void draw_option (
    WINDOW *		win,
    int		entry,
    int		width,
    BOOL		reversed,
    int		num_choices,
    int		number,
    const char *	value)
d3810 1
a3810 1
    SLsmg_write_nstring((char *)value, win->width);
d3841 2
a3842 3
 *  This function offers the choices for values of an
 *  option via a popup window which functions like
 *  that for selection of options in a form. - FM
d3844 1
a3844 2
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
d3846 9
a3854 10
int LYhandlePopupList (
	int		cur_choice,
	int		ly,
	int		lx,
	const char **	choices,
	int		width,
	int		i_length,
	int		disabled,
	BOOLEAN	for_mouse,
	BOOLEAN	numbered)
d3858 1
a3858 1
    WINDOW * form_window;
d3867 1
a3867 1
    static char prev_target[MAX_LINE];		/* Search string buffer */
d3880 1
d3903 5
a3907 6
     *	Count the number of choices to be displayed, where
     *	num_choices ranges from 0 to n, and set width to the
     *	longest choice string length.  Also set Lnum to the
     *	length for the highest choice number, then decrement
     *	num_choices so as to be zero-based.  The window width
     *	will be based on the sum of width and Lnum. - FM
d3922 9
a3930 9
     *  Let's assume for the sake of sanity that ly is the number
     *   corresponding to the line the choice is on.
     *  Let's also assume that cur_choice is the number of the
     *   item that should be initially selected, as 0 being the
     *   first item.
     *  So what we have, is the top equal to the current screen line
     *   subtracting the cur_choice + 1 (the one must be for the
     *   top line we will draw in a box).  If the top goes under 0,
     *   consider it 0.
d3937 2
a3938 2
     *  Check and see if we need to put the i_length parameter up to
     *  the number of real choices.
d3944 1
a3944 1
	 *  Otherwise, it is really one number too high.
d3950 3
a3952 3
     *  The bottom is the value of the top plus the number of options
     *  to view plus 3 (one for the top line, one for the bottom line,
     *  and one to offset the 0 counted in the num_choices).
d3957 1
a3957 1
     *  Set lines_to_show based on the user_mode global.
d3960 1
a3960 1
	lines_to_show = LYlines-4;
d3962 1
a3962 1
	lines_to_show = LYlines-2;
d3968 1
a3968 1
     *  Hmm...  If the bottom goes beyond the number of lines available,
d3972 2
a3973 2
	 *  Position the window at the top if we have more
	 *  choices than will fit in the window.
d3982 4
a3985 4
	     *  Try to position the window so that the selected choice will
	     *    appear where the selection box currently is positioned.
	     *  It could end up too high, at this point, but we'll move it
	     *    down latter, if that has happened.
d3993 1
a3993 1
     *  This is really fun, when the length is 4, it means 0 to 4, or 5.
d4000 1
a4000 1
     *  Move the window down if it's too high.
d4011 2
a4012 2
	if (Lnum + (int)width + 4 < LYcols) {
	    if (lx - 1 + (Lnum + (int)width + 4) > LYcols)
d4020 2
a4021 2
     *  Set up the overall window, including the boxing characters ('*'),
     *  if it all fits.  Otherwise, set up the widest window possible. - FM
d4024 5
a4028 3
     || cur_choice > num_choices
     || (form_window = LYstartPopup(top, lx, bottom - top, Lnum + width)) == 0)
	return(orig_choice);
d4031 1
a4031 2
     *	Clear the command line and write
     *	the popup statusline. - FM
d4041 2
a4042 2
	popup_status_msg = gettext(
		"Left mouse button or return to select, arrow keys to scroll.");
d4048 3
a4050 3
     *  Set up the window_offset for choices.
     *   cur_choice ranges from 0...n
     *   length ranges from 0...m
d4057 1
a4057 1
     *  Compute the number of popup window pages. - FM
d4060 6
a4065 6
		(((num_choices + 1) + (length - 1))/(length))
					  : 1;
/*
 *  OH!  I LOVE GOTOs! hack hack hack
 */
redraw:
d4068 1
a4068 1
     *  Display the boxed choices.
d4072 2
a4073 2
	    draw_option (form_window, ((i + 1) - window_offset), width, FALSE,
			 max_choices, i, choices[i]);
d4076 1
a4076 1
    LYbox(form_window, (BOOLEAN)!numbered);
d4080 1
a4080 1
     *  Loop on user input.
d4090 2
a4091 2
	    if (~can_scroll & can_scroll_was) {	/* Need to redraw */
		LYbox(form_window, (BOOLEAN)!numbered);
d4109 1
a4109 1
	 *  Unreverse cur choice.
d4112 2
a4113 2
	    draw_option (form_window, row, width, FALSE,
			 max_choices, i, Cptr[i]);
d4118 2
a4119 2
	draw_option (form_window, row, width, TRUE,
		     max_choices, cur_choice, Cptr[cur_choice]);
d4123 1
a4123 1
	if (term_options || LYCharIsINTERRUPT(c)) { /* Control-C or Control-G */
d4129 1
a4129 1
	    if  (cmd == LYK_ACTIVATE)
d4133 1
a4133 1
	    cmd = LKC_TO_LAC(keymap,c);
d4142 44
a4185 13
	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
		/* FALLTHRU */
	    case LYK_1: /* FALLTHRU */
	    case LYK_2: /* FALLTHRU */
	    case LYK_3: /* FALLTHRU */
	    case LYK_4: /* FALLTHRU */
	    case LYK_5: /* FALLTHRU */
	    case LYK_6: /* FALLTHRU */
	    case LYK_7: /* FALLTHRU */
	    case LYK_8: /* FALLTHRU */
	    case LYK_9:
d4187 1
a4187 3
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
d4189 11
a4199 1
		number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);
a4200 19
		/* handle + or - suffix */
		CTRACE((tfp,"got popup option number %d, ",number));
		CTRACE((tfp,"rel='%c', c='%c', cur_choice=%d\n",
				rel, c, cur_choice));
		if ( c == 'p' ) {
		    int curpage = ((cur_choice + 1) > length) ?
			(((cur_choice + 1) + (length - 1))/(length))
					  : 1;
		    CTRACE((tfp,"  curpage=%d\n",curpage));
		    if ( rel == '+' )
			number = curpage + number;
		    else if ( rel == '-' )
			number = curpage - number;
		} else if ( rel == '+' ) {
		    number = cur_choice + number + 1;
		} else if ( rel == '-' ) {
		    number = cur_choice - number + 1;
		}
		if ( rel ) CTRACE((tfp,"new number=%d\n",number));
d4202 2
a4203 1
		 *  Check for a 'p' suffix. - FM
d4205 3
a4207 12
		if (c == 'p') {
		    /*
		     *  Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = 0;
			cur_choice = 0;
d4209 5
a4213 1
			goto redraw;
d4215 21
d4237 22
a4258 19
		    /*
		     *  Treat a number equal to or greater than the
		     *  number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_choices - length) + 1)) {
			    HTUserMsg(ALREADY_AT_OPTION_END);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_choices - length)) {
			    window_offset = (num_choices - length + 1);
			}
			if (cur_choice < window_offset)
			    cur_choice = window_offset;
			_statusline(popup_status_msg);
			goto redraw;
		    }
d4260 9
a4268 4
		    /*
		     *  We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
d4270 2
a4271 1
			HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
a4276 3
		    cur_choice = window_offset = ((number - 1) * length);
		    _statusline(popup_status_msg);
		    goto redraw;
d4278 6
a4283 18
		}

		/*
		 *  Check for a positive number, which signifies
		 *  that a choice should be sought. - FM
		 */
		if (number > 0) {
		    /*
		     *  Decrement the number so as to correspond
		     *  with our cur_choice values. - FM
		     */
		    number--;

		    /*
		     *  If the number is in range and had no legal
		     *  suffix, select the indicated choice. - FM
		     */
		    if (number <= num_choices && c == '\0') {
d4285 12
a4296 2
			cmd = LYK_ACTIVATE;
			break;
d4300 1
a4300 2
		     *  Verify that we had a 'g' suffix,
		     *  and act on the number. - FM
d4302 9
a4310 12
		    if (c == 'g') {
			if (cur_choice == number) {
			    /*
			     *  The choice already is current. - FM
			     */
			    char *msg = 0;
			    HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(msg);
			    FREE(msg);
			    _statusline(popup_status_msg);
			    break;
			}
d4312 4
a4315 21
			if (number <= num_choices) {
			    /*
			     *  The number is in range and had a 'g'
			     *  suffix, so make it the current option,
			     *  scrolling if needed. - FM
			     */
			    j = (number - cur_choice);
			    cur_choice = number;
			    if ((j > 0) &&
				(cur_choice - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_choices - length + 1))
				    window_offset = (num_choices - length + 1);
			    } else if ((cur_choice - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    _statusline(popup_status_msg);
			    goto redraw;
			}
d4317 2
a4318 6
			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_OPTION_NUM_ENTERED);
		    }
		}
d4320 8
a4327 5
		/*
		 *  Restore the popup statusline. - FM
		 */
		_statusline(popup_status_msg);
		break;
d4329 6
a4334 4
	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:
d4336 8
a4343 2
		if (cur_choice > 0)
		    cur_choice--;
d4345 5
d4351 2
a4352 1
		 *  Scroll the window up if necessary.
d4354 1
a4354 12
		if ((cur_choice - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_LPOS_NEXT_LINK:
	    case LYK_FASTFORW_LINK:
	    case LYK_DOWN_LINK:
		if (cur_choice < num_choices)
		    cur_choice++;
d4357 2
a4358 1
		 *  Scroll the window down if necessary
d4360 3
a4362 3
		if ((cur_choice - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
a4363 1
		break;
a4364 1
	    case LYK_NEXT_PAGE:
d4366 9
a4374 2
		 *  Okay, are we on the last page of the list?
		 *  If not then,
d4376 3
a4378 7
		if (window_offset != (num_choices - length + 1)) {
		    /*
		     *	Modify the current choice to not be a
		     *  coordinate in the list, but a coordinate
		     *  on the item selected in the window.
		     */
		    cur_choice -= window_offset;
d4380 10
a4389 8
		    /*
		     *  Page down the proper length for the list.
		     *  If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }
d4391 6
a4396 7
		    /*
		     *  Readjust the current selection to be a
		     *  list coordinate rather than window.
		     *  Redraw this thing.
		     */
		    cur_choice += window_offset;
		    goto redraw;
a4397 8
		else if (cur_choice < num_choices) {
		    /*
		     *  Already on last page of the list so just
		     *  redraw it with the last item selected.
		     */
		    cur_choice = num_choices;
		}
		break;
a4398 1
	    case LYK_PREV_PAGE:
d4400 1
a4400 2
		 *  Are we on the first page of the list?
		 *  If not then,
d4402 25
a4426 6
		if (window_offset != 0) {
		    /*
		     *  Modify the current selection to not be a
		     *  list coordinate, but a window coordinate.
		     */
		    cur_choice -= window_offset;
d4428 4
a4431 8
		    /*
		     *  Page up the proper length.
		     *  If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }
d4433 10
a4442 13
		    /*
		     *  Readjust the current choice.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		} else if (cur_choice > 0) {
		    /*
		     *  Already on the first page so just
		     *  back up to the first item.
		     */
		    cur_choice = 0;
		}
		break;
d4444 3
a4446 1
	    case LYK_HOME:
d4448 7
a4454 1
		if (window_offset > 0) {
d4456 3
a4458 3
		    goto redraw;
		}
		break;
d4460 3
a4462 1
	    case LYK_END:
d4464 7
a4470 1
		if (window_offset != (num_choices - length + 1)) {
d4472 3
a4474 3
		    goto redraw;
		}
		break;
d4476 4
a4479 4
	    case LYK_DOWN_TWO:
		cur_choice += 2;
		if (cur_choice > num_choices)
		    cur_choice = num_choices;
d4481 10
a4490 10
		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;
d4492 4
a4495 4
	    case LYK_UP_TWO:
		cur_choice -= 2;
		if (cur_choice < 0)
		    cur_choice = 0;
d4497 2
d4500 9
a4508 1
		 *  Scroll the window up if necessary.
d4510 7
a4516 5
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
d4518 14
a4531 15
		break;

	    case LYK_DOWN_HALF:
		cur_choice += (length/2);
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
d4533 1
a4533 6
		break;

	    case LYK_UP_HALF:
		cur_choice -= (length/2);
		if (cur_choice < 0)
		    cur_choice = 0;
d4535 3
d4539 1
a4539 1
		 *  Scroll the window up if necessary.
d4541 3
a4543 12
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;
d4545 2
a4546 2
	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
d4548 1
a4548 12
		     *  We got a 'n'ext command with no prior query
		     *  specified within the popup window.  See if
		     *  one was entered when the popup was retracted,
		     *  and if so, assume that's what's wanted.  Note
		     *  that it will become the default within popups,
		     *  unless another is entered within a popup.  If
		     *  the within popup default is to be changed at
		     *  that point, use WHEREIS ('/') and enter it,
		     *  or the up- or down-arrow keys to seek any of
		     *  the previously entered queries, regardless of
		     *  whether they were entered within or outside
		     *  of a popup window. - FM
d4550 12
a4561 3
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			LYstrncpy(prev_target_buffer, cp, sizeof(prev_target_buffer) - 1);
a4562 1
			FirstRecall = FALSE;
d4564 5
d4570 19
a4588 5
		strlcpy(prev_target, prev_target_buffer, MAX_LINE);
		/* FALLTHRU */
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
d4590 1
a4590 2
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
d4592 1
a4592 1
			 *  User cancelled the search via ^G. - FM
d4597 1
d4599 2
a4600 4

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
d4602 1
a4602 1
		     *  No entry.  Simply break.   - FM
d4604 9
a4612 20
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
a4613 2
			} else {
			    QueryNum = 0;
d4616 1
a4616 4
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
d4618 23
a4640 49
		    if (QueryNum >= QueryTotal) {
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *  User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  first query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = 0;
				 QueryNum < (QueryTotal - 1); QueryNum++) {
				if ((cp = (char *)HTList_objectAt(
							    search_queries,
							    QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
					break;
				}
			    }
			} else {
			    QueryNum = (QueryTotal - 1);
			}
d4642 1
a4642 4
			/*
			 *  Advance to the next query in the list. - FM
			 */
			QueryNum--;
d4644 3
a4646 1
		    if (QueryNum < 0) {
d4648 1
a4648 1
			 *  Roll around to the first query in the list. - FM
d4650 2
a4651 26
			QueryNum = (QueryTotal - 1);
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
d4653 20
d4674 2
d4677 1
a4677 1
		 *  Replace the search string buffer with the new target. - FM
d4679 1
a4679 3
		strlcpy(prev_target_buffer, prev_target, MAX_LINE);
		HTAddSearchQuery(prev_target_buffer);

d4681 1
a4681 1
		 *  Start search at the next choice. - FM
d4683 5
a4687 9
		for (j = 1; Cptr[i+j] != NULL; j++) {
		    FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i+j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
d4689 22
a4710 15
		if (Cptr[i+j] != NULL) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    cur_choice += j;
		    /*
		     *  Scroll the window down if necessary.
		     */
		    if ((cur_choice - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_choices - length + 1))
			    window_offset = (num_choices - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
d4712 2
a4713 1

d4715 1
a4715 1
		 *  If we started at the beginning, it can't be present. - FM
d4717 2
a4718 5
		if (cur_choice == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}

d4720 1
a4720 1
		 *  Search from the beginning to the current choice. - FM
d4722 5
a4726 26
		for (j = 0; j < cur_choice; j++) {
		    FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_choice) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    j = (cur_choice - j);
		    cur_choice -= j;
		    /*
		     *  Scroll the window up if necessary.
		     */
		    if ((cur_choice - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
d4728 2
d4731 4
a4734 4
		/*
		 *  Didn't find it in the preceding choices either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
d4736 16
a4751 16
restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		_statusline(popup_status_msg);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
		}
		break;
d4753 7
a4759 7
	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
	    case LYK_INTERRUPT:
		cur_choice = orig_choice;
		cmd = LYK_ACTIVATE; /* to exit */
		break;
d4764 1
a4764 1
    return(disabled ? orig_choice : cur_choice);
d4769 4
a4772 5
int LYgetstr (
	char *		inputline,
	int		hidden,
	size_t		bufsize,
	RecallType	recall)
d4780 1
d4787 3
a4789 3
		    (bufsize - 1) : (sizeof(MyEdit.buffer) - 1);
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, (LYcols-1)-x);
    MyEdit.hidden = (BOOL) hidden ;
d4793 1
a4793 1
again:
d4802 1
a4802 1
#ifdef CJK_EX	/* for SJIS code */
d4804 1
a4804 1
	 && (EditBinding(ch) != LYE_CHAR))
d4808 2
a4809 2
	 && (EditBinding(ch) != LYE_CHAR)
	 && (EditBinding(ch) != LYE_AIX))
d4816 1
a4816 1
	      || HadVMSInterrupt
d4819 1
a4819 1
	      || term_message
d4821 1
a4821 1
	      ) {
d4829 1
a4829 1
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
d4832 1
a4832 1
	    return(ch);
d4842 1
a4842 1
	if (LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
d4856 1
a4856 1
	     *  Set flag for modifier 1.
d4862 1
a4862 1
	     *  Set flag for modifier 2.
d4869 1
d4871 1
a4871 1
		    char **data = sortedList(list, (BOOL)(recall == RECALL_CMD));
d4874 1
a4874 1
		    int num_options = LYarrayLength((const char **)data);
d4877 1
a4877 1
		     && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
d4881 9
a4889 10
		    cur_choice = LYhandlePopupList(
			cur_choice,
			0,
			old_x,
			(const char **)data,
			-1,
			-1,
			FALSE,
			FALSE,
			TRUE);
d4903 1
a4903 1
#ifndef CJK_EX	/* 1997/11/03 (Mon) 20:13:45 */
d4906 4
a4909 4
	     *	Hex 97.
	     *	Treat as a character for CJK, or if this is a valid
	     *	character in the current display character set.
	     *	Otherwise, we treat this as LYE_ENTER.
d4913 2
a4914 3
		 LYlowest_eightbit[current_char_set] <= 0x97))
	    {
		LYLineEdit(&MyEdit,ch, FALSE);
d4921 1
a4921 1
	     *	Terminate the string and return.
d4923 1
a4923 1
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
d4927 1
a4927 1
	    return(ch);
d4930 1
a4930 1
	/* 1998/10/01 (Thu) 15:05:49 */
d4946 1
a4946 1
			if (*e1 < ' ') { /* Stop here? */
d4950 6
a4955 2
			    if (*e1 == '\t') { /* Replace by space */
				LYEditInsert(&MyEdit, (unsigned char * ) " ", 1, map_active, TRUE);
d4972 1
a4972 1
	     *	Control-C or Control-G aborts.
d4976 1
a4976 1
	    return(-1);
d4980 1
a4980 1
	     *	Deactivate.
d4985 1
a4985 1
	    return(-1);
d4989 1
a4989 1
		Mark = -1 - Mark;		/* Disable it */
d4996 2
a4997 3
	     *	Used only in form_getstr() for invoking
	     *	the LYK_F_LINK_NUM prompt when in form
	     *	text fields. - FM
d5003 2
a5004 3
	     *	Used in form_getstr() to end line editing and
	     *	pass on the input char/lynxkeycode.  Here it
	     *	is just ignored. - kw
d5011 3
a5013 3
		 *	Used in form_getstr() to end line editing and
		 *	pass on the lynxkeycode already containing a
		 *	lynxactioncode.  Here it is just ignored. - kw
a5016 1

d5035 1
a5035 1
const char * LYLineeditHelpURL (void)
d5040 1
d5060 1
a5060 1
 *  A replacement for 'strsep()'
d5062 2
a5063 3
char *LYstrsep (
	char **	stringp,
	const char *	delim)
d5067 2
a5068 2
    if (isEmpty(stringp))		/* nothing to do? */
	return 0;			/* then don't fall on our faces */
d5070 1
a5070 1
    out = *stringp;			/* save the start of the string */
d5073 5
a5077 5
	*tmp = '\0';			/* terminate the substring with \0 */
	*stringp = ++tmp;		/* point at the next substring */
    }
    else *stringp = 0;			/* this was the last substring: */
					/* let caller see he's done */
d5082 6
a5087 8
 *  LYstrstr will find the first occurrence of the string
 *  pointed to by tarptr in the string pointed to by chptr.
 *  It returns NULL if string not found.
 *  It is a case insensitive search.
 */
char * LYstrstr (
	char *		chptr,
	const char *	tarptr)
d5091 1
a5091 1
    for(; *chptr != '\0'; chptr++) {
d5093 2
a5094 2
	    if (0 == strncasecomp8(chptr+1, tarptr+1, len-1))
		return(chptr);
d5096 1
a5096 1
    } /* end for */
d5098 1
a5098 1
    return(NULL); /* string not found or initial chptr was empty */
d5102 3
a5104 3
 *  LYno_attr_char_case_strstr will find the first occurrence of the
 *  string pointed to by tarptr in the string pointed to by chptr.
 *  It ignores the characters: LY_UNDERLINE_START_CHAR and
d5110 1
a5110 1
 *  It is a case insensitive search.
d5112 2
a5113 3
char * LYno_attr_char_case_strstr (
	char *		chptr,
	char *		tarptr)
d5118 1
a5118 1
	return(NULL);
d5124 1
a5124 1
	 if (0 == UPPER8(*chptr, *tarptr)) {
d5126 1
a5126 1
	     *	See if they line up.
d5128 2
a5129 2
	    tmpchptr = chptr+1;
	    tmptarptr = tarptr+1;
d5131 2
a5132 2
	    if (*tmptarptr == '\0')  /* one char target */
		 return(chptr);
d5144 1
a5144 1
		    return(chptr);
d5149 1
a5149 1
    } /* end for */
d5151 1
a5151 1
    return(NULL);
d5155 3
a5157 3
 *  LYno_attr_char_strstr will find the first occurrence of the
 *  string pointed to by tarptr in the string pointed to by chptr.
 *  It ignores the characters: LY_UNDERLINE_START_CHAR and
d5163 1
a5163 1
 *  It is a case sensitive search.
d5165 2
a5166 3
char * LYno_attr_char_strstr (
	char *		chptr,
	char *		tarptr)
d5171 1
a5171 1
	return(NULL);
d5179 1
a5179 1
	     *	See if they line up.
d5184 2
a5185 2
	    if (*tmptarptr == '\0')  /* one char target */
		 return(chptr);
d5188 1
a5188 1
		 if (!IsSpecialAttrChar(*tmpchptr)) {
d5193 1
a5193 1
		 } else {
d5195 5
a5199 5
		 }
		 if (*tmptarptr == '\0')
		     return(chptr);
		 if (*tmpchptr == '\0')
		     break;
d5202 1
a5202 1
    } /* end for */
d5204 1
a5204 1
    return(NULL);
d5209 10
a5218 9
 * pointed to by tarptr in the string pointed to by chptr.
 * It takes account of MultiByte Character Sequences (UTF8).
 * The physical lengths of the displayed string up to the start and
 * end (= next position after) of the target string are returned in *nstartp
 * and *nendp if the search is successful.
 *   These lengths count glyph cells if count_gcells is set. (Full-width
 *   characters in CJK mode count as two.)  Normally that's what we want.
 *   They count actual glyphs if count_gcells is unset. (Full-width
 *   characters in CJK mode count as one.)
d5226 1
a5226 1
 *  It is a case insensitive search. - KW & FM
d5228 6
a5233 7
char * LYno_attr_mbcs_case_strstr (
	char *		chptr,
	const char *	tarptr,
	BOOL		utf_flag,
	BOOL		count_gcells,
	int *		nstartp,
	int *		nendp)
d5241 1
a5241 1
	return(NULL);
d5244 1
a5244 1
     *	Skip initial IsSpecial chars. - FM
d5250 1
a5250 1
     *	Seek a first target match. - FM
d5259 1
d5264 1
a5264 1
	     *	See if they line up.
d5271 1
a5271 1
		 *  One char target.
d5273 5
a5277 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
d5280 3
a5282 3
		 *chptr == *tarptr &&
		 *tmpchptr != '\0' &&
		 !IsSpecialAttrChar(*tmpchptr)) {
d5284 1
a5284 1
		 *  Check the CJK multibyte. - FM
d5288 1
a5288 1
		     *	It's a match.  Advance to next char. - FM
d5292 2
a5293 1
		    if (count_gcells) tarlen++;
d5296 1
a5296 1
			 *  One character match. - FM
d5298 5
a5302 3
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
			return(chptr);
d5306 2
a5307 2
		     *	It's not a match, so go back to
		     *	seeking a first target match. - FM
d5310 2
a5311 1
		    if (count_gcells) len++;
d5316 1
a5316 1
	     *	See if the rest of the target matches. - FM
d5326 2
a5327 1
			    if (count_gcells) tarlen++;
d5346 5
a5350 3
		    if (nstartp)	*nstartp = offset;
		    if (nendp)		*nendp = len + tarlen;
		    return(chptr);
d5356 1
a5356 1
		      IsSpecialAttrChar(*chptr))) {
d5361 2
a5362 1
		if (count_gcells) len++;
d5366 1
a5366 1
    } /* end for */
d5368 1
a5368 1
    return(NULL);
d5372 13
a5384 10
 * LYno_attr_mbcs_strstr will find the first occurrence of the string
 * pointed to by tarptr in the string pointed to by chptr.
 *  It takes account of CJK and MultiByte Character Sequences (UTF8).
 *  The physical lengths of the displayed string up to the start and
 *  end (= next position after) the target string are returned in *nstartp
 *  and *nendp if the search is successful.
 *    These lengths count glyph cells if count_gcells is set. (Full-width
 *    characters in CJK mode count as two.)  Normally that's what we want.
 *    They count actual glyphs if count_gcells is unset. (Full-width
 *    characters in CJK mode count as one.)
d5392 1
a5392 1
 *  It is a case sensitive search. - KW & FM
d5394 6
a5399 7
char * LYno_attr_mbcs_strstr (
	char *		chptr,
	const char *	tarptr,
	BOOL		utf_flag,
	BOOL		count_gcells,
	int *		nstartp,
	int *		nendp)
d5407 1
a5407 1
	return(NULL);
d5410 1
a5410 1
     *	Skip initial IsSpecial chars. - FM
d5416 1
a5416 1
     *	Seek a first target match. - FM
d5421 1
d5426 1
a5426 1
	     *	See if they line up.
d5433 1
a5433 1
		 *  One char target.
d5435 5
a5439 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
d5442 2
a5443 2
		 *tmpchptr != '\0' &&
		 !IsSpecialAttrChar(*tmpchptr)) {
d5445 1
a5445 1
		 *  Check the CJK multibyte. - FM
d5449 1
a5449 1
		     *	It's a match.  Advance to next char. - FM
d5453 2
a5454 1
		    if (count_gcells) tarlen++;
d5457 1
a5457 1
			 *  One character match. - FM
d5459 5
a5463 3
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
			return(chptr);
d5467 2
a5468 2
		     *	It's not a match, so go back to
		     *	seeking a first target match. - FM
d5471 2
a5472 1
		    if (count_gcells) len++;
d5477 1
a5477 1
	     *	See if the rest of the target matches. - FM
d5480 1
a5480 1
		 if (!IsSpecialAttrChar(*tmpchptr)) {
d5487 2
a5488 1
			    if (count_gcells) tarlen++;
d5501 1
a5501 1
		 } else {
d5503 1
a5503 1
		 }
d5505 7
a5511 5
		 if (*tmptarptr == '\0') {
		     if (nstartp)	*nstartp = offset;
		     if (nendp)		*nendp = len + tarlen;
		     return(chptr);
		 }
d5513 1
a5513 1
		     break;
d5516 1
a5516 1
		      IsSpecialAttrChar(*chptr))) {
d5521 2
a5522 1
		if (count_gcells) len++;
d5526 1
a5526 1
    } /* end for */
d5528 1
a5528 1
    return(NULL);
d5532 1
a5532 1
 *  Allocate a new copy of a string, and returns it.
d5534 3
a5536 4
char * SNACopy (
	char **	dest,
	const char *	src,
	int		n)
d5541 1
d5546 2
a5547 2
	strncpy (*dest, src, n);
	*(*dest + n) = '\0'; /* terminate */
d5553 1
a5553 1
 *  String Allocate and Concatenate.
d5555 3
a5557 4
char * SNACat (
	char **	dest,
	const char *	src,
	int		n)
d5562 2
a5563 1
	    *dest = (char *)realloc(*dest, length + n + 1);
d5567 1
a5567 1
	    *(*dest + length + n) = '\0'; /* terminate */
d5570 1
d5574 1
a5574 1
	    (*dest)[n] = '\0'; /* terminate */
d5586 1
a5586 1
static long UniToLowerCase (long upper)
d5592 1
a5592 1
     *	Make check for sure.
d5595 1
a5595 1
	return(upper);
d5598 1
a5598 1
     *	Try unicode_to_lower_case[].
d5604 3
a5606 3
	**  Binary search.
	*/
	i = (low + (high-low)/2);
d5609 1
a5609 1
	    low = i+1;
d5616 1
a5616 1
    return(upper); /* if we came here */
d5620 13
a5632 13
**   UPPER8 ?
**   it was "TOUPPER(a) - TOUPPER(b)" in its previous life...
**
**   It was realized that case-insensitive user search
**   got information about upper/lower mapping from TOUPPER
**   (precisely from "(TOUPPER(a) - TOUPPER(b))==0")
**   and depends on locale in its 8bit mapping. -
**   Usually fails with DOS/WINDOWS display charsets
**   as well as on non-UNIX systems.
**
**   So use unicode case mapping.
*/
int UPPER8 (int ch1, int ch2)
d5644 1
a5644 1
	return(TOUPPER(ch1) - TOUPPER(ch2));
d5647 2
a5648 3
    if (UCH(TOASCII(ch1)) > 127 &&  /* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127)
    {
d5650 3
a5652 4
	   return(TOUPPER(ch1) - TOUPPER(ch2)); /* old-style */
	else
	{
	    long uni_ch2 = UCTransToUni((char)ch2, current_char_set);
d5654 1
d5657 2
a5658 2
	    uni_ch1 = UCTransToUni((char)ch1, current_char_set);
	    return(UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
d5662 1
a5662 1
    return(-10);  /* mismatch, if we come to here */
d5670 2
a5671 3
char *LYSafeGets (
	char **	src,
	FILE *		fp)
d5691 2
a5692 3
	 *  If the file ends in the middle of a line, return the
	 *  partial line; if another call is made after this, it
	 *  will return NULL. - kw
d5705 2
a5706 3
void LYOpenCmdLogfile (
	int		argc,
	char **	argv)
d5714 1
a5714 1
		LYNX_NAME, LYNX_VERSION, LYVersionDate());
d5722 1
a5722 1
BOOL LYHaveCmdScript (void)
d5724 1
a5724 1
    return (BOOL)(cmd_script != 0);
d5727 1
a5727 1
void LYOpenCmdScript (void)
d5737 1
a5737 2
int LYReadCmdKey (
	int	mode)
d5789 2
a5790 1
    CTRACE((tfp, "LYReadCmdKey(%d) ->%s (%#x)\n", mode, LYKeycodeToString(ch, TRUE), ch));
d5798 1
a5798 2
void LYWriteCmdKey (
	int	ch)
d5805 1
a5805 1
void LYCloseCmdLogfile (void)
@


1.6
log
@* bump to 0x079D (a bit late for tiff, but hey)
* sync lists
* regenerate configure files
* remove MirLibtool, go back to gcc3 libtool :-(
* fix for $stuff
* remove dupes (libz, etc.) and unused (libintl, getopt)
* update lynx
* update texinfo.tex
etc.

XXX borked commit, eleventh try
@
text
@d79 1
a79 1
PUBLIC int peek_mouse_levent NOARGS
d92 1
a92 1
PUBLIC int get_mouse_link NOARGS
d103 1
a103 1
PUBLIC int peek_mouse_link NOARGS
d109 4
a112 4
PUBLIC int fancy_mouse ARGS3(
    WINDOW *,	win,
    int,	row,
    int *,	position)
d257 2
a258 2
PRIVATE HTList *whichRecall ARGS1(
    RecallType,		recall)
d280 1
a280 1
PRIVATE void LYRemoveFromCloset ARGS1(HTList *, list)
d288 1
a288 1
PUBLIC void LYCloseCloset ARGS1(RecallType, recall)
d303 1
a303 1
PRIVATE char * LYFindInCloset ARGS2(RecallType, recall, char*, base)
d318 1
a318 1
PRIVATE void LYAddToCloset ARGS2(RecallType, recall, char*, str)
d330 6
a335 6
PRIVATE int XYdist ARGS5(
    int,	x1,
    int,	y1,
    int,	x2,
    int,	y2,
    int,	dx2)
d372 5
a376 5
PRIVATE int set_clicked_link ARGS4(
    int,	x,
    int,	y,
    int,	code,
    int,	clicks)
d563 4
a566 4
PUBLIC char *LYstrncpy ARGS3(
	char *,		dst,
	CONST char *,	src,
	int,		n)
d596 6
a601 6
PUBLIC char * LYmbcsstrncpy ARGS5(
	char *,		dst,
	CONST char *,	src,
	int,		n_bytes,
	int,		n_glyphs,
	BOOL,		utf_flag)
d630 4
a633 4
PUBLIC char * LYmbcs_skip_glyphs ARGS3(
	char *,		data,
	int,		n_glyphs,
	BOOL,		utf_flag)
d665 4
a668 4
PUBLIC int LYmbcsstrlen ARGS3(
	char *,		str,
	BOOL,		utf_flag,
	BOOL,		count_gcells)
d730 1
a730 1
PRIVATE int myGetChar NOARGS
d776 1
a776 1
PRIVATE int sl_parse_mouse_event ARGS3(int *, x, int *, y, int *, button)
d808 2
a809 2
PRIVATE int sl_read_mouse_event ARGS1(
    int,	code)
d839 3
a841 3
PRIVATE BOOLEAN csi_is_csi = TRUE;
PUBLIC void ena_csi ARGS1(
    BOOLEAN,	flag)
d913 1
a913 1
PRIVATE int lookup_tiname (char *name, NCURSES_CONST char *CONST *names)
d923 1
a923 1
PRIVATE CONST char *expand_tiname (CONST char *first, size_t len, char **result, char *final)
d940 1
a940 1
PRIVATE CONST char *expand_tichar (CONST char *first, char **result, char *final)
d989 1
a989 1
PRIVATE int expand_substring (char* dst, CONST char* first, CONST char* last, char *final)
d1001 1
a1001 1
		CONST char *s = strchr(first, RPAREN);
d1032 1
a1032 1
PRIVATE void unescaped_char ARGS2(CONST char*, parse, int*,keysym)
d1044 1
a1044 1
PRIVATE BOOLEAN unescape_string ARGS3(char*, src, char *, dst, char *, final)
d1061 1
a1061 1
PUBLIC int map_string_to_keysym ARGS2(CONST char*, str, int*,keysym)
d1145 1
a1145 1
PRIVATE char *skip_keysym ARGS1(char *, parse)
d1175 1
a1175 1
PRIVATE int setkey_cmd (char *parse)
d1218 1
a1218 1
PRIVATE int unsetkey_cmd (char *parse)
d1252 1
a1252 1
PRIVATE int read_keymap_file NOARGS
d1255 2
a1256 2
	CONST char *name;
	int (*func) PARAMS((char *s));
d1295 1
a1295 1
PRIVATE void setup_vtXXX_keymap NOARGS
d1353 1
a1353 1
PUBLIC int lynx_initialize_keymaps NOARGS
d1389 1
a1389 1
PRIVATE int LYmouse_menu ARGS4(int, x, int, y, int, atlink, int, code)
d1505 1
a1505 1
PRIVATE int current_sl_modifier = 0;
d1508 1
a1508 1
PRIVATE int myGetChar NOARGS
d1516 2
a1517 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
d1583 2
a1584 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
d2377 1
a2377 1
PUBLIC int LYgetch NOARGS
d2385 1
a2385 1
PUBLIC int LYgetch_choice NOARGS
d2396 1
a2396 1
PUBLIC int LYgetch_input NOARGS
d2408 1
a2408 1
PUBLIC int LYgetch_single NOARGS
d2421 2
a2422 2
PUBLIC void LYLowerCase ARGS1(
	 char *,	arg_buffer)
d2447 2
a2448 2
PUBLIC void LYUpperCase ARGS1(
	 char *,	arg_buffer)
d2473 2
a2474 2
PUBLIC BOOLEAN LYRemoveNewlines ARGS1(
	char *,		buffer)
d2498 2
a2499 2
PUBLIC char * LYRemoveBlanks ARGS1(
	char *,		buffer)
d2522 2
a2523 2
PUBLIC char * LYSkipBlanks ARGS1(
	char *,		buffer)
d2533 2
a2534 2
PUBLIC char * LYSkipNonBlanks ARGS1(
	char *,		buffer)
d2542 1
a2542 1
 * Skip CONST whitespace
d2544 2
a2545 2
PUBLIC CONST char * LYSkipCBlanks ARGS1(
	CONST char *,	buffer)
d2553 1
a2553 1
 * Skip CONST non-whitespace
d2555 2
a2556 2
PUBLIC CONST char * LYSkipCNonBlanks ARGS1(
	CONST char *,	buffer)
d2566 2
a2567 2
PUBLIC void LYTrimLeading ARGS1(
	char *,		buffer)
d2577 2
a2578 2
PUBLIC char * LYTrimNewline ARGS1(
	char *,		buffer)
d2589 2
a2590 2
PUBLIC void LYTrimTrailing ARGS1(
	char *,		buffer)
d2600 3
a2602 3
PUBLIC char *LYElideString ARGS2(
	char *,		str,
	int,		cut_pos)
d2629 2
a2630 2
PUBLIC BOOLEAN LYTrimStartfile ARGS1(
	char *,		buffer)
d2652 2
a2653 2
PUBLIC void LYEscapeStartfile ARGS1(
	char **,		buffer)
d2665 2
a2666 2
PUBLIC void LYTrimAllStartfile ARGS1(
	char *,		buffer)
d2695 1
a2695 1
PRIVATE char killbuffer[1024] = "\0";
d2698 5
a2702 5
PUBLIC void LYSetupEdit ARGS4(
	EDREC *,	edit,
	char *,		old,
	int,		maxstr,
	int,		maxdsp)
d2743 3
a2745 3
PRIVATE int prev_pos ARGS2(
	EDREC *,	edit,
	int,		pos)
d2777 6
a2782 6
PUBLIC int LYEditInsert ARGS5(
	EDREC *,	edit,
	unsigned char *,s,
	int,		len,
	int,		map,
	BOOL,		maxMessage)
d2889 5
a2893 5
PUBLIC int LYEdit1 ARGS4(
	EDREC *,	edit,
	int,		ch,
	int,		action,
	BOOL,		maxMessage)
d3319 4
a3322 4
PUBLIC int get_popup_number ARGS3(
	char *,		msg,
	int *,		c,
	int *,		rel)
d3386 2
a3387 2
PUBLIC void LYRefreshEdit ARGS1(
	EDREC *,	edit)
d3614 3
a3616 3
PRIVATE void reinsertEdit ARGS2(
    EditFieldData *,	edit,
    char *,		result)
d3627 3
a3629 3
PRIVATE int caselessCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
d3631 1
a3631 1
    return strcasecomp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
d3634 3
a3636 3
PRIVATE int normalCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
d3638 1
a3638 1
    return strcmp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
d3641 3
a3643 3
PRIVATE char **sortedList ARGS2(
    HTList *,	list,
    BOOL,	ignorecase)
d3681 2
a3682 2
PUBLIC int LYarrayLength ARGS1(
    CONST char **,	list)
d3691 2
a3692 2
PUBLIC int LYarrayWidth ARGS1(
    CONST char **,	list)
d3705 5
a3709 5
PRIVATE void FormatChoiceNum ARGS4(
	char *,		dst,
	int,		num_choices,
	int,		choice,
	CONST char *,	value)
d3721 2
a3722 2
PRIVATE unsigned options_width ARGS1(
	CONST char **,	list)
d3736 8
a3743 8
PRIVATE void draw_option ARGS7(
    WINDOW *,		win,
    int,		entry,
    int,		width,
    BOOL,		reversed,
    int,		num_choices,
    int,		number,
    CONST char *,	value)
d3791 10
a3800 10
PUBLIC int LYhandlePopupList ARGS9(
	int,		cur_choice,
	int,		ly,
	int,		lx,
	CONST char **,	choices,
	int,		width,
	int,		i_length,
	int,		disabled,
	BOOLEAN,	for_mouse,
	BOOLEAN,	numbered)
d3825 1
a3825 1
    CONST char **Cptr = NULL;
d4722 5
a4726 5
PUBLIC int LYgetstr ARGS4(
	char *,		inputline,
	int,		hidden,
	size_t,		bufsize,
	RecallType,	recall)
d4826 1
a4826 1
		    int num_options = LYarrayLength((CONST char **)data);
d4837 1
a4837 1
			(CONST char **)data,
d4988 1
a4988 1
PUBLIC CONST char * LYLineeditHelpURL NOARGS
d5014 3
a5016 3
PUBLIC char *LYstrsep ARGS2(
	char **,	stringp,
	CONST char *,	delim)
d5040 3
a5042 3
PUBLIC char * LYstrstr ARGS2(
	char *,		chptr,
	CONST char *,	tarptr)
d5067 3
a5069 3
PUBLIC char * LYno_attr_char_case_strstr ARGS2(
	char *,		chptr,
	char *,		tarptr)
d5121 3
a5123 3
PUBLIC char * LYno_attr_char_strstr ARGS2(
	char *,		chptr,
	char *,		tarptr)
d5184 7
a5190 7
PUBLIC char * LYno_attr_mbcs_case_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
	BOOL,		utf_flag,
	BOOL,		count_gcells,
	int *,		nstartp,
	int *,		nendp)
d5193 1
a5193 1
    CONST char *tmptarptr;
d5337 7
a5343 7
PUBLIC char * LYno_attr_mbcs_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
	BOOL,		utf_flag,
	BOOL,		count_gcells,
	int *,		nstartp,
	int *,		nendp)
d5346 1
a5346 1
    CONST char *tmptarptr;
d5467 4
a5470 4
PUBLIC char * SNACopy ARGS3(
	char **,	dest,
	CONST char *,	src,
	int,		n)
d5488 4
a5491 4
PUBLIC char * SNACat ARGS3(
	char **,	dest,
	CONST char *,	src,
	int,		n)
d5518 1
a5518 1
PRIVATE long UniToLowerCase ARGS1(long, upper)
d5564 1
a5564 1
PUBLIC int UPPER8 ARGS2(int,ch1, int,ch2)
d5603 3
a5605 3
PUBLIC char *LYSafeGets ARGS2(
	char **,	src,
	FILE *,		fp)
d5637 2
a5638 2
PRIVATE FILE *cmd_logfile;
PRIVATE FILE *cmd_script;
d5640 3
a5642 3
PUBLIC void LYOpenCmdLogfile ARGS2(
	int,		argc,
	char **,	argv)
d5658 1
a5658 1
PUBLIC BOOL LYHaveCmdScript NOARGS
d5663 1
a5663 1
PUBLIC void LYOpenCmdScript NOARGS
d5673 2
a5674 2
PUBLIC int LYReadCmdKey ARGS1(
	int,	mode)
d5734 2
a5735 2
PUBLIC void LYWriteCmdKey ARGS1(
	int,	ch)
d5742 1
a5742 1
PUBLIC void LYCloseCmdLogfile NOARGS
@


1.5
log
@some more string fixes, but I'll stop here...
I just noticed how much abuse is done with these
@
text
@d1319 12
d1524 22
a1545 1
   if ((key == NULL) || (key->type != SLKEY_F_KEYSYM))
d1547 1
d4888 1
a4888 1
		unsigned char *s = get_clip_grab(), *e;
d4893 1
a4893 1
		len = strlen(s);
d4905 1
a4905 1
				LYEditInsert(&MyEdit, " ", 1, map_active, TRUE);
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d2208 1
a2208 1
		    sprintf(mouse_info, "Mouse = 0x%x, [%s]", c, p);
d2588 1
a2588 1
    strcpy(s_str, buff);
d2790 1
a2790 1
				strcpy(Buf + off, tail);
d2809 1
a2809 1
	    strcpy(Buf + off, tail);
d3825 1
a3825 1
	sprintf(Cnum, "%d: ", num_choices);
d4436 1
a4436 1
		strcpy(prev_target, prev_target_buffer);
d4578 1
a4578 1
		strcpy(prev_target_buffer, prev_target);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d2547 1
a2547 1
    while (i != 0 && buffer[i-1] == '\n')
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d3 2
a6 1
#include <LYGlobalDefs.h>
d17 1
d19 3
d33 9
d44 4
a47 3
extern unsigned short *LYKbLayout;
extern BOOL HTPassHighCtrlRaw;
extern HTCJKlang HTCJK;
d49 4
a52 2
/*Allowing the user to press tab when entering URL to get the closest
  match in the closet*/
a53 2
static char* LYCloset[LYClosetSize]; /* Closet with LYClosetSize shelves */
static int LYClosetTop = 0;		/*Points to the next empty shelf */
d55 2
a56 4
PRIVATE char *LYFindInCloset PARAMS((
	char*		base));
PRIVATE int LYAddToCloset PARAMS((
	char*		str));
d74 1
a74 1
#ifdef NCURSES_MOUSE_VERSION
d81 2
a82 2
#ifdef NCURSES_MOUSE_VERSION
    if (have_levent) {
d84 1
d108 1
d115 43
a157 6
#ifdef NCURSES_MOUSE_VERSION
#ifndef getbegx
#define getbegx(win) ((win)->_begx)
#endif
#ifndef getbegy
#define getbegy(win) ((win)->_begy)
d159 16
d179 2
a180 4
		       | BUTTON1_DOUBLE_CLICKED
		       | BUTTON1_TRIPLE_CLICKED))
    && (event.x >= getbegx(win)
    && (event.x < (getbegx(win) + getmaxx(win))))) {
d184 3
d220 8
d232 4
a240 9
#if 0
	    /* Immediate action looks reasonable since we have no help
	     * available for individual options.  Moreover, one can position
	     * active element with shift-click-1.  (;-)
	     */
	    if (!(event.bstate & (BUTTON1_DOUBLE_CLICKED
				| BUTTON1_TRIPLE_CLICKED)))
		goto redraw;
#endif
d246 5
a250 1
#endif
d254 76
d337 1
a337 1
    int xerr = x2 - x1, yerr = y2 - y1;
d340 1
a340 1
	xerr = x1 - x2 - dx2;
d345 18
a362 1
    return xerr + yerr;
d372 1
a372 1
PRIVATE int set_clicked_link ARGS3(
d375 2
a376 1
    int,	code)
d384 4
a387 1
    if (y == (LYlines-1)) {
d389 42
a430 4
	if (x < left) c = LTARROW;
	else if (x > right) c = '\b';
	else c = PGDOWN;
    } else if (y == 0) {
d432 22
a453 3
	if (x < left) c = LTARROW;
	else if (x > right) c = '\b';
	else c = PGUP;
d455 2
a456 1
	int mouse_err = -1, cur_err;
d461 2
d465 1
a465 3
		/* XXXX What else? */
		&& (links[i].form->type == F_TEXTAREA_TYPE
		 || links[i].form->type == F_TEXT_TYPE))
a467 5
	    if (is_text)
		len = links[i].form->size;
	    else
		len = strlen(links[i].hightext );

d469 5
a473 1
	    if ( links[i].hightext != NULL) {
d475 13
d492 16
d511 1
a511 1
			if (is_text)
d513 5
a527 15
	    /* Check the second line */
	    if (links[i].hightext2 != NULL) {
		cur_err = XYdist(x, y,
				 links[i].hightext2_offset,
				 links[i].ly+1,
				 strlen(links[i].hightext2));
		if (cur_err == 0) {
		    mouse_link = i;
		    mouse_err = 0;
		    break;
		} else if (cur_err < mouse_err) {
		    mouse_err = cur_err;
		    mouse_link = i;
		}
	    }
d535 18
a552 4
	    if (mouse_err == 0)
		c = lookup_keymap(LYK_ACTIVATE);
	    else if (mouse_err >= 0)
		c = lookup_keymap(LYK_CHANGE_LINK);
d557 1
a557 16


/*
 *  LYstrerror emulates the ANSI strerror() function.
 */
#ifdef LYStrerror
    /* defined as macro in .h file. */
#else
PUBLIC char *LYStrerror ARGS1(int, code)
{
    static char temp[80];
    sprintf(temp, "System errno is %d.\r\n", code);
    return temp;
}
#endif /* HAVE_STRERROR */

d564 1
a564 1
	char *, 	dst,
d586 2
a587 2
#define IS_NEW_GLYPH(ch) (utf_flag && ((unsigned char)(ch)&0xc0) != 0x80)
#define IS_UTF_EXTRA(ch) (utf_flag && ((unsigned char)(ch)&0xc0) == 0x80)
d597 1
a597 1
	char *, 	dst,
d631 1
a631 1
	char *, 	data,
d660 4
d665 4
a668 3
PUBLIC int LYmbcsstrlen ARGS2(
	char *, 	str,
	BOOL,		utf_flag)
d672 1
a672 1
    if (!str && *str)
d690 2
a691 2
	} else if (!utf_flag && HTCJK != NOCJK && !isascii(str[i]) &&
		    str[(i + 1)] != '\0' &&
d713 3
d717 1
d723 31
a753 1
#define GetChar() wgetch(my_subwindow ? my_subwindow : stdscr)
d757 1
a757 1
#define GetChar() wgetch(stdscr)
d765 2
a766 2
#if HAVE_KEYPAD
#define GetChar getch
d775 1
a775 18
#if defined(NCURSES)
/*
 * Workaround a bug in ncurses order-of-refresh by setting a pointer to
 * the topmost window that should be displayed.
 *
 * FIXME: the associated call on 'keypad()' is not needed for Unix, but
 * something in the OS/2 EMX port requires it.
 */
PRIVATE WINDOW *my_subwindow;

PUBLIC void LYsubwindow ARGS1(WINDOW *, param)
{
    if ((my_subwindow = param) != 0)
	keypad(param, TRUE);
}
#endif

#ifdef USE_SLANG_MOUSE
d795 10
a804 2
    *x = SLang_getkey () - 33;
    *y = SLang_getkey () - 33;
d808 2
a809 1
PRIVATE int sl_read_mouse_event NOARGS
d817 4
a820 1
	  return set_clicked_link (mouse_x, mouse_y, FOR_PANEL);
d831 4
a834 1
   return -1;
d836 2
a837 1
#endif
d851 2
a852 2
#define expand_substring(dst, first, last) \
	SLexpand_escaped_string(dst, first, last)
d855 1
a855 1
#define MOUSE_KEYSYM 0x1000
a857 1

d869 6
a874 1
#define DEFINE_KEY(string,lynx,curses) {string,lynx}
d876 2
a877 1
#define DEFINE_KEY(string,lynx,curses) {string,curses}
d880 1
d890 16
a905 16
    DEFINE_KEY( "UPARROW",	UPARROW,	KEY_UP ),
    DEFINE_KEY( "DNARROW",	DNARROW,	KEY_DOWN ),
    DEFINE_KEY( "RTARROW",	RTARROW,	KEY_RIGHT ),
    DEFINE_KEY( "LTARROW",	LTARROW,	KEY_LEFT ),
    DEFINE_KEY( "PGDOWN",	PGDOWN,		KEY_NPAGE ),
    DEFINE_KEY( "PGUP",		PGUP,		KEY_PPAGE ),
    DEFINE_KEY( "HOME",		HOME,		KEY_HOME ),
    DEFINE_KEY( "END",		END_KEY,	KEY_END ),
    DEFINE_KEY( "F1",		F1,		KEY_F(1) ),
    DEFINE_KEY( "DO_KEY",	DO_KEY,		KEY_F(16) ),
    DEFINE_KEY( "FIND_KEY",	FIND_KEY,	KEY_FIND ),
    DEFINE_KEY( "SELECT_KEY",	SELECT_KEY,	KEY_SELECT ),
    DEFINE_KEY( "INSERT_KEY",	INSERT_KEY,	KEY_IC ),
    DEFINE_KEY( "REMOVE_KEY",	REMOVE_KEY,	KEY_DC ),
    DEFINE_KEY( "DO_NOTHING",	DO_NOTHING,	0 ),
    DEFINE_KEY( NULL, 		-1,		ERR )
d923 1
a923 1
PRIVATE char *expand_tiname (char *first, size_t len, char **result)
d933 1
a933 1
	    strcpy(*result, cur_term->type.Strings[code]);
d940 1
a940 1
PRIVATE char *expand_tichar (char *first, char **result)
d971 6
a976 6
	char *last;
	int save = first[limit];
	first[limit] = '\0';
	value = strtol(first, &last, radix);
	first[limit] = save;
	first = last;
d980 1
a980 1
	(void) expand_tiname(name, strlen(name), result);
d989 1
a989 1
PRIVATE void expand_substring (char* dst, char* first, char* last)
d992 1
d996 1
a996 1
	    first = expand_tichar(first, &dst);
d1001 2
a1002 1
		char *s = strchr(first, RPAREN);
d1005 3
a1007 1
		first = expand_tiname(first, s-first, &dst);
d1028 1
d1032 1
a1032 1
PRIVATE void unescaped_char ARGS2(char*, parse, int*,keysym)
d1038 1
a1038 1
	expand_substring(buf, parse + 1, parse + len - 1);
d1044 1
a1044 1
PRIVATE BOOLEAN unescape_string ARGS2(char*, src, char *, dst)
d1056 2
a1057 4
    } else if (*src == DQUOTE) {
	expand_substring(dst, src + 1, src + strlen(src) - 1);
	ok = TRUE;
    }
d1061 1
a1061 1
PRIVATE int map_string_to_keysym ARGS2(char*, str, int*,keysym)
d1063 1
d1066 45
d1113 1
a1113 1
    } else if (isdigit(*str)) {
d1116 1
a1116 1
	if (!isalnum(*tmp))
d1118 5
d1136 2
d1163 1
a1163 1
	} else if (isspace(*parse)) {
d1181 1
d1183 1
a1183 1
	if (isspace(*s)) {
d1186 2
a1187 1
	    if ((t = skip_keysym(s)) == 0)
d1189 1
d1192 10
a1201 2
	    if (map_string_to_keysym (s, &keysym) >= 0
	     && unescape_string(parse, buf)) {
d1204 3
d1208 6
a1264 1
    int ret;
d1274 1
a1274 3
    ret = 0;
    while (LYSafeGets(&line, fp) != 0 && (ret == 0))
    {
d1284 4
a1287 7
	    if (strlen(s) > len
	     && !strncmp(s, table[n].name, len)) {
		if ((*(table[n].func))(LYSkipBlanks(s+len)) < 0) {
		    ret = -1;
		    break;
		}
	    }
d1291 2
a1292 7

    fclose (fp);

    if (ret == -1)
	fprintf (stderr, FAILED_READING_KEYMAP, linenum, file);

    return ret;
d1298 37
a1334 20
	DEFINE_KEY( "\033[A",	UPARROW,	KEY_UP ),
	DEFINE_KEY( "\033OA",	UPARROW,	KEY_UP ),
	DEFINE_KEY( "\033[B",	DNARROW,	KEY_DOWN ),
	DEFINE_KEY( "\033OB",	DNARROW,	KEY_DOWN ),
	DEFINE_KEY( "\033[C",	RTARROW,	KEY_RIGHT ),
	DEFINE_KEY( "\033OC",	RTARROW,	KEY_RIGHT ),
	DEFINE_KEY( "\033[D",	LTARROW,	KEY_LEFT ),
	DEFINE_KEY( "\033OD",	LTARROW,	KEY_LEFT ),
	DEFINE_KEY( "\033[1~",	FIND_KEY,	KEY_FIND ),
	DEFINE_KEY( "\033[2~",	INSERT_KEY,	KEY_IC ),
	DEFINE_KEY( "\033[3~",	REMOVE_KEY,	KEY_DC ),
	DEFINE_KEY( "\033[4~",	SELECT_KEY,	KEY_SELECT ),
	DEFINE_KEY( "\033[5~",	PGUP,		KEY_PPAGE ),
	DEFINE_KEY( "\033[6~",	PGDOWN,		KEY_NPAGE ),
	DEFINE_KEY( "\033[8~",	END_KEY,	KEY_END ),
	DEFINE_KEY( "\033[7~",	HOME,		KEY_HOME),
	DEFINE_KEY( "\033[28~",	F1,		KEY_F(1) ),
	DEFINE_KEY( "\033OP",	F1,		KEY_F(1) ),
	DEFINE_KEY( "\033[OP",	F1,		KEY_F(1) ),
	DEFINE_KEY( "\033[29~",	DO_KEY,		KEY_F(16) ),
d1338 1
a1338 1
    	define_key(table[n].string, table[n].value);
d1347 5
d1365 2
a1366 4
    if (SLang_Error
    || (-1 == read_keymap_file ()))
    SLang_exit_error ("Unable to initialize keymaps");
    return 0;
d1369 1
a1370 1
#endif
d1375 3
a1377 2
#ifdef NCURSES_MOUSE_VERSION
PRIVATE int LYmouse_menu ARGS3(int, x, int, y, int, atlink)
d1379 33
a1411 25
    static char *choices[] = {
	"Quit",
	"Home page",
	"Previous document",
	"Beginning of document",
	"Page up",
	"Half page up",
	"Two lines up",
	"History",
	"Help",
	"Do nothing (refresh)",
	"Load again",
	"Edit URL and load",
	"Show info",
	"Search",
	"Print",
	"Two lines down",
	"Half page down",
	"Page down",
	"End of document",
	"Bookmarks",
 	"Cookie jar",
	"Search index",
	"Set Options",
	NULL
d1413 15
a1427 41
    static char *choices_link[] = {
	"Help",
	"Do nothing",
	"Activate this link",
	"Show info",
	"Download",
	NULL
    };
    static int actions[] = {
	LYK_ABORT,
	LYK_MAIN_MENU,
	LYK_PREV_DOC,
	LYK_HOME,
	LYK_PREV_PAGE,
	LYK_UP_HALF,
	LYK_UP_TWO,
	LYK_HISTORY,
	LYK_HELP,
	LYK_REFRESH,
	LYK_RELOAD,
	LYK_ECGOTO,
	LYK_INFO,
	LYK_WHEREIS,
	LYK_PRINT,
	LYK_DOWN_TWO,
	LYK_DOWN_HALF,
	LYK_NEXT_PAGE,
	LYK_END,
	LYK_VIEW_BOOKMARK,
 	LYK_COOKIE_JAR,
	LYK_INDEX_SEARCH,
	LYK_OPTIONS
    };
    static int actions_link[] = {
	LYK_HELP,
	LYK_REFRESH,
	LYK_ACTIVATE,
	LYK_INFO,
	LYK_DOWNLOAD
    };
    int c;
d1431 16
a1446 5
    c = popup_choice((atlink ? 2 : 9) - 1, y, (x >= 5 ? x-5 : 0),
		     (atlink ? choices_link : choices),
		     (atlink
		      ? (sizeof(actions_link)/sizeof(int))
		      : (sizeof(actions)/sizeof(int))), FALSE);
d1448 38
a1485 1
    return atlink ? (actions_link[c]) : (actions[c]);
d1487 2
a1488 1
#endif
d1491 3
d1498 4
a1501 1
   return GetChar();
d1504 2
a1505 1
PUBLIC int LYgetch NOARGS
d1509 1
d1513 1
a1513 1
     return DO_NOTHING;
d1517 1
a1517 1
#if defined (USE_SLANG_MOUSE)
d1519 1
a1519 1
     return sl_read_mouse_event ();
d1522 13
a1534 1
   if ((keysym+1 >= KEYMAP_SIZE) || (keysym < 0))
d1537 1
a1537 1
   return keysym;
d1540 2
a1541 5
PUBLIC int LYgetch_for ARGS1(
	int, 	code)
{
    return LYgetch();
}
a1542 1
#else	/* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */
d1549 2
a1550 7
PUBLIC int LYgetch NOARGS
{
    return LYgetch_for(FOR_PANEL);
}

PUBLIC int LYgetch_for ARGS1(
	int, 	code)
d1553 2
a1557 1
#if defined(IGNORE_CTRL_C) || defined(USE_GETCHAR) || !defined(NCURSES)
d1559 4
a1562 1
#endif /* IGNORE_CTRL_C || USE_GETCHAR */
d1568 1
d1572 1
d1582 2
a1583 1
	    return(7); /* use ^G to cancel whatever called us. */
d1588 45
d1636 19
d1665 1
a1665 1
	return(7); /* use ^G to cancel whatever called us. */
d1667 1
a1667 1
#else
d1670 1
a1670 1
	    return(7); /* use ^G to cancel whatever called us. */
d1684 1
a1684 1
	exit_immediately(0);
d1688 4
a1691 1
    if (c == CH_ESC || (csi_is_csi && c == (unsigned char)CH_ESC_PAR)) { /* handle escape sequence  S/390 -- gil -- 2024 */
a1701 1
	case 'x': c = UPARROW; break;  /* keypad up on pc ncsa telnet */
a1702 1
	case 'r': c = DNARROW; break; /* keypad down on pc ncsa telnet */
a1703 1
	case 'v': c = RTARROW; break; /* keypad right on pc ncsa telnet */
d1705 8
a1712 5
	case 't': c = LTARROW; break;  /* keypad left on pc ncsa telnet */
	case 'y': c = PGUP;    break;  /* keypad on pc ncsa telnet */
	case 's': c = PGDOWN;  break;  /* keypad on pc ncsa telnet */
	case 'w': c = HOME;    break;  /* keypad on pc ncsa telnet */
	case 'q': c = END_KEY; break;  /* keypad on pc ncsa telnet */
d1714 1
a1714 1
#ifdef USE_SLANG_MOUSE
d1717 1
a1717 1
		c = sl_read_mouse_event ();
d1721 1
a1721 1
	     c = '\n'; /* keypad enter on pc ncsa telnet */
d1728 1
a1728 1
		c = '-';  /* keypad on pc ncsa telnet */
d1732 3
a1734 1
		c = '+';  /* keypad + on my xterminal :) */
d1740 1
a1740 1
		c = '+';  /* keypad on pc ncsa telnet */
d1752 1
a1752 1
		c = F1;  /* macintosh help button */
d1758 1
a1758 1
		c = '0';  /* keypad 0 */
d1760 1
a1760 1
	case '1':			    /** VTxxx  Find  **/
d1763 2
d1781 2
d1787 2
d1793 2
d1799 2
d1805 2
d1814 1
d1816 8
a1823 1
	    CTRACE(tfp,"Unknown key sequence: %d:%d:%d\n",c,b,a);
d1829 22
d1852 8
a1859 2
#if HAVE_KEYPAD
    else {
d1873 14
a1886 1
	case KEY_RIGHT: 	   /* ... */
d1889 7
d1899 1
a1899 1
	case KEY_CLEAR: 	   /* Clear screen */
d1902 1
a1902 1
	case KEY_NPAGE: 	   /* Next page */
d1905 1
a1905 1
	case KEY_PPAGE: 	   /* Previous page */
d1911 1
d1931 1
d1995 48
d2047 2
a2048 2
	   c = 0x213;
	   break;
d2050 2
a2051 2
	   c = 0x214;
	   break;
d2053 2
a2054 2
	   c = 0x215;
	   break;
d2056 2
a2057 2
	   c = 0x216;
	   break;
d2059 2
a2060 2
	   c = 0x217;
	   break;
d2062 2
a2063 2
	   c = 0x218;
	   break;
d2065 5
a2069 1
#ifdef NCURSES_MOUSE_VERSION
d2071 1
d2074 10
a2083 2
	    } else {
#ifndef DOSPATH
d2086 1
d2091 4
d2097 1
a2097 1
		    c = set_clicked_link(event.x, event.y, code);
d2099 3
a2101 7
		    c = set_clicked_link(event.x, event.y, code);
		    if (c == PGDOWN)
			c = END_KEY;
		    else if (c == PGUP)
			c = HOME;
		    else if (c == LTARROW)
			c = LYReverseKeymap(LYK_MAIN_MENU);
d2103 10
a2112 1
		    c = LYReverseKeymap (LYK_PREV_DOC);
d2116 2
a2117 2
		    c = set_clicked_link(event.x, event.y, code);
		    atlink = c == LYReverseKeymap (LYK_ACTIVATE);
d2121 11
a2131 5
		    c = LYmouse_menu(event.x, event.y, atlink);
		    if (c == LYK_ACTIVATE && mouse_link == -1) {
			HTAlert("No link chosen");
			c = LYK_DO_NOTHING;
			c = LYK_REFRESH; /* refresh() below does not work... */
d2133 6
a2138 1
		    c = LYReverseKeymap(c);
d2140 2
a2141 1
		    refresh();
d2143 2
a2144 1
		if (code == FOR_INPUT && mouse_link == -1) {
d2146 1
a2146 1
		    getch();		/* ungetmouse puts KEY_MOUSE back */
d2150 14
d2166 12
d2179 31
a2209 4
		if (BUTTON_STATUS(1) & BUTTON_CLICKED) {
		    c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL);
		} else if (BUTTON_STATUS(3) & BUTTON_CLICKED) {
		    c = LYReverseKeymap (LYK_PREV_DOC);
d2211 3
a2213 1
#endif /* DOSPATH */
d2216 5
a2220 1
#endif /* NCURSES_MOUSE_VERSION */
a2221 1
    }
a2223 1
    else {
d2237 1
a2237 1
	case K_Right: 		   /* ... */
d2245 1
a2245 1
	case K_PageDown: 	   /* Next page */
d2249 1
a2249 1
	case K_PageUp:	 	   /* Previous page */
a2280 1
    }
d2282 1
a2282 2
#if defined(USE_SLANG) && defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)  && !defined(USE_KEYMAPS)
    else {
d2293 1
a2293 1
	case SL_KEY_RIGHT: 	   /* ... */
d2300 1
a2300 1
	case SL_KEY_NPAGE: 	   /* Next page */
d2304 1
a2304 1
	case SL_KEY_PPAGE: 	   /* Previous page */
d2322 1
a2323 1
#endif /* USE_SLANG && __DJGPP__ && !DJGPP_KEYHANDLER && !USE_KEYMAPS */
d2325 2
d2335 1
a2335 1
	return(c);
d2339 1
d2342 42
d2388 1
a2388 1
	char *, 	buffer)
d2390 1
d2393 13
d2407 1
d2414 1
a2414 1
	char *, 	buffer)
d2416 1
d2419 39
a2457 1
	buffer[i] = TOUPPER(buffer[i]);
d2461 2
a2462 1
 * Remove ALL whitespace from a string (including embedded blanks).
d2464 2
a2465 2
PUBLIC void LYRemoveBlanks ARGS1(
	char *, 	buffer)
d2468 13
a2480 5
	size_t i, j;
	for (i = j = 0; buffer[i]; i++)
	    if (!isspace((unsigned char)(buffer[i])))
		buffer[j++] = buffer[i];
	buffer[j] = 0;
d2482 1
d2489 1
a2489 1
	char *, 	buffer)
d2491 1
a2491 1
    while (isspace((unsigned char)(*buffer)))
d2500 1
a2500 1
	char *, 	buffer)
d2502 1
a2502 1
    while (*buffer != 0 && !isspace((unsigned char)(*buffer)))
d2513 1
a2513 1
    while (isspace((unsigned char)(*buffer)))
d2524 1
a2524 1
    while (*buffer != 0 && !isspace((unsigned char)(*buffer)))
d2533 1
a2533 1
	char *, 	buffer)
d2541 12
d2556 1
a2556 1
	char *, 	buffer)
d2559 1
a2559 1
    while (i != 0 && isspace((unsigned char)buffer[i-1]))
d2563 29
d2599 2
a2600 2
    if (!strncasecomp(buffer, "lynxexec:", 9) ||
	!strncasecomp(buffer, "lynxprog:", 9)) {
d2619 1
a2619 1
       char **,			buffer)
d2621 1
a2621 1
     if (!LYTrimStartfile(*buffer)) {
d2625 1
a2625 1
	}
d2632 1
a2632 1
       char *,         buffer)
d2635 1
a2635 1
       LYRemoveBlanks(buffer);
d2656 7
d2666 1
a2666 1
	char *, 	old,
d2677 1
a2678 1
    StrLen  = strlen(old);
d2683 3
d2703 51
d2755 74
a2828 13
     *	We expect the called function to pass us a default (old) value
     *	with a length that is less than or equal to maxstr, and to
     *	handle any messaging associated with actions to achieve that
     *	requirement.  However, in case the calling function screwed
     *	up, we'll check it here, and ensure that no buffer overrun can
     *	occur by loading only as much of the head as fits. - FM
     */
    if (strlen(old) >= (unsigned)maxstr) {
	strncpy(edit->buffer, old, maxstr);
	edit->buffer[maxstr] = '\0';
	StrLen = maxstr;
    } else {
	strcpy(edit->buffer, old);
d2830 23
d2861 2
a2862 1
     *         ch   otherwise
d2866 1
a2866 3
#ifdef EXP_KEYBOARD_LAYOUT
    static int map_active = 0;
#endif
d2883 1
d2891 4
a2894 2
	 if (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97)
	     return(ch);
d2896 5
a2900 6
#ifdef EXP_KEYBOARD_LAYOUT
	if (map_active && ch < 128 && ch >= 0 &&
	    LYKbLayouts[current_layout][ch])
	    ch = UCTransUniChar((long) LYKbLayouts[current_layout][ch],
		current_char_set);
#endif
d2902 7
a2908 1
	 *  ch is printable or ISO-8859-1 escape character.
d2910 4
d2915 8
d2926 1
a2926 1
	    Buf[Pos] = (unsigned char) ch;
d2928 2
a2929 1
	} else if (maxMessage) {
d2932 2
d2937 1
d2946 31
d2983 1
d2988 12
d3007 3
d3062 1
a3062 1
    case LYE_DELEL:
d3082 4
d3093 1
d3096 6
d3106 23
d3132 1
d3137 1
d3140 9
d3151 1
d3156 1
d3159 10
d3171 20
a3190 2
    case LYE_UPPER:
	LYUpperCase(Buf);
d3193 77
a3269 2
    case LYE_LOWER:
	LYLowerCase(Buf);
d3280 71
d3361 7
d3391 1219
a4609 3
    if ((DspStart + DspWdth) <= length)
	if (Pos >= (DspStart + DspWdth) - Margin)
	    DspStart=(Pos - DspWdth) + Margin;
d4611 7
a4617 5
    if (Pos < DspStart + Margin) {
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
    }
d4619 30
a4648 1
    str = &Buf[DspStart];
d4650 4
a4653 3
    nrdisplayed = length-DspStart;
    if (nrdisplayed > DspWdth)
	nrdisplayed = DspWdth;
d4655 14
a4668 36
    move(edit->sy, edit->sx);
#ifdef USE_COLOR_STYLE
    /*
     *  If this is the last screen line, set attributes to normal,
     *  should only be needed for color styles.  The curses function
     *  may be used directly to avoid complications. - kw
     */
    if (edit->sy == (LYlines - 1)) {
	if (s_normal != NOSTYLE) {
	    curses_style(s_normal, ABS_ON);
	} else {
	    attrset(A_NORMAL);	/* need to do something about colors? */
	}
    }
#endif
    if (edit->hidden) {
	for (i = 0; i < nrdisplayed; i++)
	    addch('*');
    } else {
	for (i = 0; i < nrdisplayed; i++)
	    if ((buffer[0] = str[i]) == 1 || buffer[0] == 2 ||
		((unsigned char)buffer[0] == 160 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK ||
		   (LYCharSet_UC[current_char_set].enc != UCT_ENC_8859 &&
		    !(LYCharSet_UC[current_char_set].like8859
		      & UCT_R_8859SPECL))))) {
		addch(' ');
	    } else {
		/* For CJK strings, by Masanobu Kimura */
		if (HTCJK != NOCJK && !isascii(buffer[0])) {
		    if (i < (nrdisplayed - 1))
			buffer[1] = str[++i];
		    addstr(buffer);
		    buffer[1] = '\0';
		} else {
		    addstr(buffer);
d4670 1
a4670 2
	    }
    }
d4672 7
a4678 18
    /*
     *	Erase rest of input area.
     */
    padsize = DspWdth-nrdisplayed;
    while (padsize--)
	addch((unsigned char)edit->pad);

    /*
     *	Scrolling indicators.
     */
    if (edit->panon) {
	if ((DspStart + nrdisplayed) < length) {
	    move(edit->sy, edit->sx+nrdisplayed-1);
	    addch('}');
	}
	if (DspStart) {
	    move(edit->sy, edit->sx);
	    addch('{');
d4681 1
d4683 1
a4683 2
    move(edit->sy, edit->sx + Pos - DspStart);
    refresh();
d4686 1
d4689 1
a4689 1
	char *, 	inputline,
d4691 2
a4692 2
	size_t, 	bufsize,
	int,		recall)
d4696 3
d4700 3
a4702 1
    char *res;
d4708 1
a4708 1
    MyEdit.hidden = hidden ;
d4710 1
d4713 1
d4715 19
a4733 1
	ch = LYgetch();
d4735 2
a4736 1
	if (term_letter || term_options ||
d4738 1
a4738 1
	      term_message
d4740 2
a4741 1
	      || HadVMSInterrupt) {
d4743 2
a4744 1
	    ch = 7;
d4746 5
a4750 11
#else
      if (term_letter || term_options
#ifndef DISABLE_NEWS
	      || term_message
#endif
	      )
	    ch = 7;
#endif /* VMS */
	if (recall && (ch == UPARROW || ch == DNARROW)) {
	    strcpy(inputline, MyEdit.buffer);
	    LYAddToCloset(MyEdit.buffer);
d4753 9
a4761 1
	if (keymap[ch + 1] == LYK_REFRESH)
d4763 22
a4784 1
	switch (EditBinding(ch)) {
d4786 30
a4815 9
	    ch = '\t';
	    /* This used to fall through to the next case before
	     tab completion was introduced */
	    res = LYFindInCloset(MyEdit.buffer);
	    if (res != 0) {
		LYEdit1(&MyEdit, '\0', LYE_ERASE, FALSE);
		while (*res != '\0') {
		    LYLineEdit(&MyEdit, (int)(*res), FALSE);
		    res++;
d4818 1
a4818 1
		ch = '\0';
d4821 2
d4832 2
a4833 1
		 LYlowest_eightbit[current_char_set] <= 0x97)) {
d4837 2
d4843 4
a4846 2
	    strcpy(inputline, MyEdit.buffer);
	    LYAddToCloset(MyEdit.buffer);
d4849 37
d4891 10
d4902 7
d4927 10
d4938 12
d4954 23
d4986 1
a4986 1
    if (!stringp || !*stringp)		/* nothing to do? */
a4988 5
    if (!**stringp) {			/* empty string: */
	*stringp = 0;			/* let caller see he's done; */
	return 0;			/* no tokens in an empty string */
    }

d5007 2
a5008 2
	char *, 	chptr,
	CONST char *, 	tarptr)
d5034 2
a5035 2
	char *, 	chptr,
	char *, 	tarptr)
d5088 2
a5089 2
	char *, 	chptr,
	char *, 	tarptr)
d5134 7
a5140 2
 * The physical length of the displayed string up to the end of the target
 * string is returned in *nendp if the search is successful.
d5144 2
a5145 2
 *				LY_BOLD_END_CHAR
 *				LY_SOFT_HYPHEN
d5150 3
a5152 3
PUBLIC char * LYno_attr_mbcs_case_strstr ARGS5(
	char *, 	chptr,
	char *, 	tarptr,
d5154 1
d5158 2
a5159 1
    register char *tmpchptr, *tmptarptr;
d5176 1
a5176 1
	if ((!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5195 3
a5197 3
		*nstartp = offset;
		*nendp = len;
		 return(chptr);
d5199 1
a5199 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5212 1
d5217 2
a5218 2
			*nstartp = offset;
			*nendp = len + tarlen;
a5220 1
		    tarlen++;
d5227 1
d5235 2
a5236 2
		 if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && HTCJK != NOCJK && !isascii(*tmpchptr)) {
d5242 1
d5244 1
a5244 1
			break;
d5256 1
a5256 1
		 } else {
d5258 1
a5258 1
		 }
d5260 7
a5266 8
		 if (*tmptarptr == '\0') {
		    *nstartp = offset;
		     *nendp = len + tarlen;
		     return(chptr);
		 }
		if (*tmpchptr == '\0') {
		     break;
	    }
d5270 1
a5270 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5274 1
d5288 6
a5293 2
 *  end of the target string are returned in *nstartp and *nendp if
 *  the search is successful.
d5298 1
a5298 1
 *				LY_SOFT_HYPHEN
d5303 3
a5305 3
PUBLIC char * LYno_attr_mbcs_strstr ARGS5(
	char *, 	chptr,
	char *, 	tarptr,
d5307 1
d5311 2
a5312 1
    register char *tmpchptr, *tmptarptr;
d5344 3
a5346 3
		*nstartp = offset;
		*nendp = len + 1;
		 return(chptr);
d5348 1
a5348 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5360 1
d5365 2
a5366 2
			*nstartp = offset;
			*nendp = len + tarlen;
a5368 1
		    tarlen++;
d5375 1
d5384 1
a5384 1
		    if (!utf_flag && HTCJK != NOCJK && !isascii(*tmpchptr)) {
d5390 1
d5408 2
a5409 2
		    *nstartp = offset;
		     *nendp = len + tarlen;
d5412 1
a5412 1
		if (*tmpchptr == '\0') {
a5414 1
	    }
d5417 1
a5417 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5421 1
a5429 57
PUBLIC void LYOpenCloset NOARGS
{
    /* We initialize the list-looka-like, i.e., the Closet */
    int i = 0;
    while(i < LYClosetSize){
	LYCloset[i] = NULL;
	i = i + 1;
    }
    LYClosetTop = 0;
}

PUBLIC void LYCloseCloset NOARGS
{
    int i = 0;

    /* Clean up the list-looka-like, i.e., the Closet */
    while (i < LYClosetSize){
	FREE(LYCloset[i]);
	i = i + 1;
    }
}

/*
 * Strategy:  We begin at the top and search downwards.  We return the first
 * match, i.e., the newest since we search from the top.  This should be made
 * more intelligent, but works for now.
 */
PRIVATE char * LYFindInCloset ARGS1(char*, base)
{
    int shelf;
    unsigned len = strlen(base);

    shelf = (LYClosetTop - 1 + LYClosetSize) % LYClosetSize;

    while (LYCloset[shelf] != NULL){
	if (!strncmp(base, LYCloset[shelf], len)) {
	    return(LYCloset[shelf]);
	}
	shelf = (shelf - 1 + LYClosetSize) % LYClosetSize;
    }
    return(0);
}

PRIVATE int LYAddToCloset ARGS1(char*, str)
{
    unsigned len = strlen(str);

    LYCloset[LYClosetTop] = malloc(len+1);
    if (!LYCloset[LYClosetTop])
	outofmem(__FILE__, "LYAddToCloset");
    strcpy(LYCloset[LYClosetTop], str);

    LYClosetTop = (LYClosetTop + 1) % LYClosetSize;
    FREE(LYCloset[LYClosetTop]);
    return(1);
}

d5440 1
a5440 1
	*dest = (char *)calloc(1, n + 1);
d5442 1
a5442 1
	    CTRACE(tfp, "Tried to calloc %d bytes\n", n);
d5459 1
a5459 1
    if (src && *src) {
d5468 1
a5468 1
	    *dest = (char *)calloc(1, strlen(src) + 1);
d5471 2
a5472 2
	    strncpy(*dest, src, n);
	    *dest[n] = '\0'; /* terminate */
d5499 1
a5499 1
    high = sizeof(unicode_to_lower_case)/sizeof(unicode_to_lower_case[0]);
d5532 7
d5541 1
a5541 44
    if ((unsigned char)TOASCII(ch1) < 128 && (unsigned char)TOASCII(ch2) < 128)
	return(TOUPPER(ch1) - TOUPPER(ch2));

    /* case-insensitive match for upper half */
    if ((unsigned char)TOASCII(ch1) > 127 &&  /* S/390 -- gil -- 2066 */
	(unsigned char)TOASCII(ch2) > 127)
    {
	if (DisplayCharsetMatchLocale)
	   return(TOUPPER(ch1) - TOUPPER(ch2)); /* old-style */
	else
	{
	long uni_ch1 = UCTransToUni(ch1, current_char_set);
	long uni_ch2 = UCTransToUni(ch2, current_char_set);
	return(UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
	}
    }

    return(-10);  /* mismatch, if we come to here */
}


#ifdef NOTUSED
/*
**   We extend this function for 8bit letters
**   using Lynx internal chartrans feature:
**   we assume that upper/lower case letters
**   have their "7bit approximation" images (in def7_uni.tbl)
**   matched case-insensitive (7bit).
**
**   By this technique we automatically cover *any* charset
**   known for Lynx chartrans and need no any extra information for it.
**
**   The cost of this assumption is that several differently accented letters
**   may be interpreted as equal, but this side effect is negligible
**   if the user search string is more than one character long.  - LP
**
**   We enable new technique only if  DisplayCharsetMatchLocale = FALSE
**   (see description in LYCharSets.c)
*/
PUBLIC int UPPER8 ARGS2(int,ch1, int,ch2)
{

    /* case-insensitive match for us-ascii */
    if ((unsigned char)TOASCII(ch1) < 128 && (unsigned char)TOASCII(ch2) < 128)
d5545 2
a5546 2
    if ((unsigned char)TOASCII(ch1) > 127 &&  /* S/390 -- gil -- 2066 */
	(unsigned char)TOASCII(ch2) > 127)
d5552 6
a5557 23
	/* compare "7bit approximation" for letters >127   */
	/* BTW, if we remove the check for >127 above	   */
	/* we get even more "relaxed" insensitive match... */

	int charset_in, charset_out, uck1, uck2;
	char replace_buf1 [10], replace_buf2 [10];

	charset_in  = current_char_set;  /* display character set */
	charset_out = UCGetLYhndl_byMIME("us-ascii");

	uck1 = UCTransCharStr(replace_buf1, sizeof(replace_buf1), ch1,
			      charset_in, charset_out, YES);
	uck2 = UCTransCharStr(replace_buf2, sizeof(replace_buf2), ch2,
			      charset_in, charset_out, YES);

	if ((uck1 > 0) && (uck2 > 0))  /* both replacement strings found */
	    return (strcasecomp(replace_buf1, replace_buf2));

	/* check to be sure we have not lost any strange characters */
	/* which are not found in def7_uni.tbl but _equal_ in fact. */
	/* this also applied for "x-transparent" display mode.	    */
	if ((unsigned char)ch1==(unsigned char)ch2)
	    return(0);	 /* match */
a5562 1
#endif /* NOTUSED */
d5587 8
a5594 2
    if (feof(fp)
     || ferror(fp)) {
d5601 121
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@a2 2
#include <UCAux.h>
#include <LYGlobalDefs.h>
d5 1
a15 1
#include <HTList.h>
a16 3
#ifdef USE_MOUSE
#include <LYMainLoop.h>
#endif
a27 9
#ifdef USE_SCROLLBAR
#include <LYMainLoop.h>
#endif

#ifdef EXP_CMD_LOGGING
#include <LYReadCFG.h>
#endif

#include <LYShowInfo.h>
d30 3
a32 4
#if defined(WIN_EX)
#undef  BUTTON_CTRL
#define BUTTON_CTRL	0	/* Quick hack */
#endif
d34 2
a35 4
/*
 * The edit_history lists allow the user to press tab when entering URL to get
 * the closest match in the closet
 */
d37 2
d40 4
a43 2
static HTList *URL_edit_history;
static HTList *MAIL_edit_history;
d46 9
a54 9
 * simple to do.  Once you've determined the X and Y coordinates of
 * the mouse event, loop through the elements in the links[] array and
 * see if the coordinates fall within a highlighted link area.	If so,
 * the code must set mouse_link to the index of the chosen link,
 * and return a key value that corresponds to LYK_ACTIVATE.  The
 * LYK_ACTIVATE code in LYMainLoop.c will then check mouse_link
 * and activate that link.  If the mouse event didn't fall within a
 * link, the code should just set mouse_link to -1 and return -1. --AMK
 */
d61 1
a61 1
#if defined(USE_MOUSE) && defined(NCURSES)
d66 1
a66 1
int peek_mouse_levent(void)
d68 2
a69 2
#if defined(USE_MOUSE) && defined(NCURSES)
    if (have_levent > 0) {
a70 1
	have_levent--;
d78 1
a78 1
int get_mouse_link(void)
a80 1

d89 1
a89 1
int peek_mouse_link(void)
d94 4
a97 2
int fancy_mouse(WINDOW * win, int row,
		int *position)
d100 6
a105 44

#ifdef USE_MOUSE
/*********************************************************************/

#if defined(WIN_EX) && defined(PDCURSES)

    request_mouse_pos();

    if (BUTTON_STATUS(1)
	&& (MOUSE_X_POS >= getbegx(win)
	    && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
	int mypos = MOUSE_Y_POS - getbegy(win);
	int delta = mypos - row;

	if (mypos + 1 == getmaxy(win)) {
	    /* At the decorative border: scroll forward */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_END;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_NEXT_PAGE;
	    else
		cmd = LYK_NEXT_LINK;
	} else if (mypos >= getmaxy(win)) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_END;
	    else
		cmd = LYK_NEXT_PAGE;
	} else if (mypos == 0) {
	    /* At the decorative border: scroll back */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_HOME;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_PREV_PAGE;
	    else
		cmd = LYK_PREV_LINK;
	} else if (mypos < 0) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_HOME;
	    else
		cmd = LYK_PREV_PAGE;
#ifdef KNOW_HOW_TO_TOGGLE
	} else if (BUTTON_STATUS(1) & (BUTTON_CTRL)) {
	    cur_selection += delta;
	    cmd = LYX_TOGGLE;
d107 1
a107 17
	} else if (BUTTON_STATUS(1) & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)) {
	    /* Probably some unrelated activity, such as selecting some text.
	     * Select, but do nothing else.
	     */
	    *position += delta;
	    cmd = -1;
	} else {
	    /* No scrolling or overflow checks necessary. */
	    *position += delta;
	    cmd = LYK_ACTIVATE;
	}
    } else if (BUTTON_STATUS(1) & (BUTTON3_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED)) {
	cmd = LYK_QUIT;
    }
#else
#if defined(NCURSES)
    MEVENT event;
d111 4
a114 2
			 | BUTTON1_DOUBLE_CLICKED
			 | BUTTON1_TRIPLE_CLICKED))) {
d118 1
a118 4
	if ((event.x < getbegx(win) || event.x >= (getbegx(win) + getmaxx(win)))
	    && !(event.bstate & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)))
	    return LYK_QUIT;	/* User clicked outside, wants to quit? */
	if (mypos + 1 == getmaxy(win)) {
d128 1
a128 1
				| BUTTON1_TRIPLE_CLICKED))
d142 1
a142 1
				| BUTTON1_TRIPLE_CLICKED))
a150 8
	} else if (event.x <= getbegx(win) + 1 ||
		   event.x >= getbegx(win) + getmaxx(win) - 2) {
	    /* Click on left or right border for positioning without
	     * immediate action: select, but do nothing else.
	     * Actually, allow an error of one position inwards. - kw
	     */
	    *position += delta;
	    cmd = -1;
a154 4
	    /* Possibly this is never returned by ncurses, so this case
	     * may be useless depending on situation (kind of mouse support
	     * and library versions). - kw
	     */
d160 9
d174 1
a174 5
#endif /* NCURSES */
#endif /* PDCURSES */

/************************************************************************/
#endif /* USE_MOUSE */
d178 6
a183 80
/*
 * Manage the collection of edit-histories
 */
static HTList *whichRecall(RecallType recall)
{
    HTList **list;

    switch (recall) {
    case RECALL_CMD:
	return LYcommandList();
    case RECALL_MAIL:
	list = &MAIL_edit_history;
	break;
    default:
	list = &URL_edit_history;
	break;
    }
    if (*list == 0)
	*list = HTList_new();
    return *list;
}

/*
 * Remove the oldest item in the closet
 */
static void LYRemoveFromCloset(HTList *list)
{
    void *data = HTList_removeFirstObject(list);

    if (data != 0)
	FREE(data);
}

void LYCloseCloset(RecallType recall)
{
    HTList *list = whichRecall(recall);

    while (!HTList_isEmpty(list)) {
	LYRemoveFromCloset(list);
    }
    HTList_delete(list);	/* should already be empty */
}

/*
 * Strategy:  We begin at the top and search downwards.  We return the first
 * match, i.e., the newest since we search from the top.  This should be made
 * more intelligent, but works for now.
 */
static char *LYFindInCloset(RecallType recall, char *base)
{
    HTList *list = whichRecall(recall);
    char *data;
    unsigned len = strlen(base);

    while (!HTList_isEmpty(list)) {
	data = (char *) HTList_nextObject(list);
	if (!strncmp(base, data, len))
	    return (data);
    }

    return (0);
}

static void LYAddToCloset(RecallType recall, char *str)
{
    HTList *list = whichRecall(recall);
    char *data = NULL;

    StrAllocCopy(data, str);
    HTList_addObject(list, data);
    while (HTList_count(list) > LYClosetSize)
	LYRemoveFromCloset(list);
}

#ifdef USE_MOUSE
static int XYdist(int x1,
		  int y1,
		  int x2,
		  int y2,
		  int dx2)
d185 1
a185 1
    int xerr = 3 * (x2 - x1), yerr = 9 * (y2 - y1);
d188 1
a188 1
	xerr = 3 * (x1 - x2 - dx2) + 1;		/* pos after string not really in it */
d193 1
a193 18
    if (!yerr)			/* same line is good */
	return (xerr > 0) ? (xerr * 2 - 1) : 0;
    if (xerr < 9 && yerr)	/* x-dist of 3 cell better than y-dist of 1 cell */
	yerr += (9 - xerr);
    return 2 * xerr + yerr;	/* Subjective factor; ratio -> approx. 6 / 9 */
/*
old: (IZ 1999-07-30)
 3  2  2  2  1  1  1 XX XX XX XX XX  0  1  1  1  2  2  2  3  3
 4\ 3  3  3  2  2  2  2  2  2  2  2  2  2  2  2  3  3  3/ 4  4
 5  4  4  4\ 3  3  3  3  3  3  3  3  3  3  3  3/ 4  4  4  5  5
 6  5  5  5  4  4  4  4  4  4  4  4  4  4  4  4  5  5  5  6  5
now: (kw 1999-10-23)
41 35 29|23 17 11  5 XX XX XX XX XX  1  7 13 19 25|31 37 43 49
   45 39 33\27 24 21 18 18 18 18 18 19 22 25 28/34 40 46 50
      48 42 36 33 30\27 27 27 27 27 28/31 34 37 43 49
         51 45 42 39 36 36 36 36 36 37 40 43 46 49
               51 48 45 45 45 45 45 46 49 52
*/
d197 10
a206 10
 * index of the corresponding hyperlink, or set mouse_link to -1 if no
 * link matches the event.  Returns -1 if no link matched the click,
 * or a keycode that must be returned from LYgetch() to activate the
 * link.
 */

static int set_clicked_link(int x,
			    int y,
			    int code,
			    int clicks)
d209 1
a209 2
    int right = LYcolLimit - 5;

d214 1
a214 4
    if (y == (LYlines - 1) || y == 0) {		/* First or last row */
	/* XXXX In fact # is not always at x==0?  KANJI_CODE_OVERRIDE? */
	int toolbar = (y == 0 && HText_hasToolbar(HTMainText));

d216 4
a219 42
	if (x == 0 && toolbar)	/* On '#' */
	    c = LAC_TO_LKC0(LYK_TOOLBAR);
#if defined(CAN_CUT_AND_PASTE) && defined(USE_COLOR_STYLE)
	else if (y == 0 && x == LYcolLimit && s_hot_paste != NOSTYLE)
	    c = LAC_TO_LKC0(LYK_PASTE_URL);
#endif
	else if (clicks > 1) {
	    if (x < left + toolbar)
		c = (code == FOR_PROMPT && y)
		    ? HOME : LAC_TO_LKC0(LYK_MAIN_MENU);
	    else if (x > right)
		c = (code == FOR_PROMPT && y)
		    ? END_KEY : LAC_TO_LKC0(LYK_VLINKS);
	    else if (y)		/* Last row */
		c = LAC_TO_LKC0(LYK_END);
	    else		/* First row */
		c = LAC_TO_LKC0(LYK_HOME);
	} else {
	    if (x < left + toolbar)
		c = (code == FOR_PROMPT && y)
		    ? LTARROW
		    : (
#ifdef USE_COLOR_STYLE
			  (s_forw_backw != NOSTYLE && x - toolbar >= 3)
			  ? LAC_TO_LKC0(LYK_NEXT_DOC)
			  : LAC_TO_LKC0(LYK_PREV_DOC)
#else
			  LAC_TO_LKC0(LYK_NEXT_DOC)
#endif
		    );
	    else if (x > right)
		c = (code == FOR_PROMPT && y)
		    ? RTARROW : LAC_TO_LKC0(LYK_HISTORY);
	    else if (y)		/* Last row */
		c = LAC_TO_LKC0(LYK_NEXT_PAGE);
	    else		/* First row */
		c = LAC_TO_LKC0(LYK_PREV_PAGE);
	}
#ifdef USE_SCROLLBAR
    } else if (x == (LYcols - 1) && LYShowScrollbar && LYsb_begin >= 0) {
	int h = display_lines - 2 * (LYsb_arrow != 0);

d221 3
a223 22
	y -= 1 + (LYsb_arrow != 0);
	if (y < 0)
	    return LAC_TO_LKC0(LYK_UP_TWO);
	if (y >= h)
	    return LAC_TO_LKC0(LYK_DOWN_TWO);

	if (clicks >= 2) {
	    double frac = (1. * y) / (h - 1);
	    int l = HText_getNumOfLines() + 1;	/* NOL() off by one? */

	    l -= display_lines;
	    if (l > 0)
		LYSetNewline((int) (frac * l + 1 + 0.5));
	    return LYReverseKeymap(LYK_DO_NOTHING);
	}

	if (y < LYsb_begin)
	    return LAC_TO_LKC0(LYK_PREV_PAGE);
	if (y >= LYsb_end)
	    return LAC_TO_LKC0(LYK_NEXT_PAGE);
	mouse_link = -1;	/* No action in edit fields */
#endif
d225 1
a225 1
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */ cur_err;
a229 2
	    int count = 0;
	    const char *text = LYGetHiliteStr(i, count);
d232 3
a234 1
		&& F_TEXTLIKE(links[i].l_form->type))
d237 5
d243 1
a243 5
	    if (text != NULL) {
		if (is_text)
		    len = links[i].l_form->size;
		else
		    len = strlen(text);
a244 14
		/* Check the second line */
		while (cur_err > 0
		       && (text = LYGetHiliteStr(i, ++count)) != NULL) {
		    /* Note that there is at most one hightext if is_text */
		    int cur_err_2 = XYdist(x, y,
					   LYGetHilitePos(i, count),
					   links[i].ly + count,
					   strlen(text));

		    cur_err = HTMIN(cur_err, cur_err_2);
		}
		if (cur_err > 0 && is_text)
		    cur_err--;	/* a bit of preference for text fields,
				   enter field if hit exactly at end - kw */
d248 1
a248 17
		    LYGetYX(cury, curx);
		    /* double-click, if we care:
		       submit text submit fields. - kw */
		    if (clicks > 1 && is_text &&
			links[i].l_form->type == F_TEXT_SUBMIT_TYPE) {
			if (code != FOR_INPUT
			/* submit current input field directly */
			    || !(cury == y && (curx >= lx) && ((curx - lx) <= len))) {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = i;
			} else {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = -1;
			}
			mouse_err = 0;
			break;
		    }
d250 1
a250 1
		    /* Do not pick up the current input field */
d252 1
a252 1
			if (is_text) {
a253 5
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
			    if (x == links[i].lx && y == links[i].ly)
				textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
			}
d264 15
d286 4
a289 17
	    if (mouse_err == 0) {
		if (c == -1)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
	    } else if (mouse_err >= 0)
		c = LAC_TO_LKC0(LYK_CHANGE_LINK);
	} else {
	    if (2 * y > LYlines) {	/* Bottom Half of the screen */
		if (4 * y < 3 * LYlines) {
		    c = LAC_TO_LKC0(LYK_DOWN_TWO);	/* Third quarter */
		} else
		    c = LAC_TO_LKC0(LYK_DOWN_HALF);	/* Fourth quarter */
	    } else {		/* Upper Half of the screen */
		if (4 * y < LYlines) {
		    c = LAC_TO_LKC0(LYK_UP_HALF);	/* First quarter */
		} else
		    c = LAC_TO_LKC0(LYK_UP_TWO);	/* Second quarter */
	    }
d294 16
a309 1
#endif /* USE_MOUSE */
d312 2
a313 2
 * LYstrncpy() terminates strings with a null byte.  Writes a null byte into
 * the n+1 byte of dst.
d315 4
a318 3
char *LYstrncpy(char *dst,
		const char *src,
		int n)
d332 1
a332 1
	*(dst + len) = '\0';
d334 1
a334 1
	*(dst + n) = '\0';
d338 2
a339 2
#define IS_NEW_GLYPH(ch) (utf_flag && (UCH(ch)&0xc0) != 0x80)
#define IS_UTF_EXTRA(ch) (utf_flag && (UCH(ch)&0xc0) == 0x80)
d342 12
a353 10
 * LYmbcsstrncpy() terminates strings with a null byte.  It takes account of
 * multibyte characters.  The src string is copied until either end of string
 * or max number of either bytes or glyphs (mbcs sequences) (CJK or UTF8).  The
 * utf_flag argument should be TRUE for UTF8.  - KW & FM
 */
char *LYmbcsstrncpy(char *dst,
		    const char *src,
		    int n_bytes,
		    int n_glyphs,
		    BOOL utf_flag)
d378 8
a385 7
 * LYmbcs_skip_glyphs() skips a given number of display positions in a string
 * and returns the resulting pointer.  It takes account of UTF-8 encoded
 * characters.  - KW
 */
const char *LYmbcs_skip_glyphs(const char *data,
			       int n_glyphs,
			       BOOL utf_flag)
d409 7
a415 10
 * LYmbcsstrlen() returns the printable length of a string that might contain
 * IsSpecial or multibyte (CJK or UTF8) characters.  - FM
 *
 * Counts glyph cells if count_gcells is set.  (Full-width characters in CJK
 * mode count as two.) Counts character glyphs if count_gcells is unset. 
 * (Full- width characters in CJK mode count as one.) - kw
 */
int LYmbcsstrlen(const char *str,
		 BOOL utf_flag,
		 BOOL count_gcells)
d419 17
a435 24
    if (non_empty(str)) {
#ifdef WIDEC_CURSES
	if (count_gcells) {
	    len = LYstrCells(str);
	} else
#endif
	{
	    for (i = 0; str[i] != '\0'; i++) {
		if (!IsSpecialAttrChar(str[i])) {
		    len++;
		    if (IS_NEW_GLYPH(str[i])) {
			j = 0;
			while (IsNormalChar(str[(i + 1)]) &&
			       j < 5 &&
			       IS_UTF_EXTRA(str[(i + 1)])) {
			    i++;
			    j++;
			}
		    } else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
			       is8bits(str[i]) &&
			       IsNormalChar(str[(i + 1)])) {
			i++;
		    }
		}
d437 4
d443 2
a444 1
    return (len);
d450 1
a450 1
#if defined(VMS)
d452 5
a456 3
#elif defined(__DJGPP__)
#define GetChar() getxkey()	/* HTDos.c */
#elif defined(__CYGWIN__)
d458 1
d461 3
a463 17
#endif
#else /* curses */
#if defined(DJGPP)
#define GetChar() (djgpp_idle_loop(), wgetch(LYtopwindow()))
#elif defined(NCURSES)
#define GetChar() wgetch(LYtopwindow())
#endif
#endif

#if !defined(GetChar) && defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* PDCurses sends back key-modifiers that we don't use, but would waste time
 * upon, e.g., repainting the status line
 */
static int myGetChar(void)
{
    int c;
    BOOL done = FALSE;
d465 2
a466 18
    do {
	switch (c = wgetch(LYwin)) {
	case KEY_SHIFT_L:
	case KEY_SHIFT_R:
	case KEY_CONTROL_L:
	case KEY_CONTROL_R:
	case KEY_ALT_L:
	case KEY_ALT_R:
	case KEY_RESIZE:
	    break;
	default:
	    done = TRUE;
	    break;
	}
    } while (!done);
    return c;
}
#define GetChar() myGetChar()
d470 1
a470 1
#define GetChar() wgetch(LYwin)
d478 2
a479 2
#ifdef HAVE_KEYPAD
#define GetChar() getch()
d484 1
a484 1
#define GetChar() getchar()	/* used to be "getc(stdin)" and "getch()" */
d488 19
a506 2
#if defined(USE_SLANG) && defined(USE_MOUSE)
static int sl_parse_mouse_event(int *x, int *y, int *button)
d511 3
a513 2
    *button = SLang_getkey();
    switch (*button) {
d521 1
a521 1
	SLang_flush_input();
d525 2
a526 10
    *x = SLang_getkey();
    if (*x == CH_ESC)		/* Undo 7-bit replace for large x - kw */
	*x = SLang_getkey() + 64 - 33;
    else
	*x -= 33;
    *y = SLang_getkey();
    if (*y == CH_ESC)		/* Undo 7-bit replace for large y - kw */
	*y = SLang_getkey() + 64 - 33;
    else
	*y -= 33;
d530 1
a530 1
static int sl_read_mouse_event(int code)
d532 1
a532 9
    int mouse_x, mouse_y, button;

    mouse_link = -1;
    if (-1 != sl_parse_mouse_event(&mouse_x, &mouse_y, &button)) {
	if (button == 0)	/* left */
	    return set_clicked_link(mouse_x, mouse_y, FOR_PANEL, 1);

	if (button == 1)	/* middle */
	    return LYReverseKeymap(LYK_VIEW_BOOKMARK);
d534 16
a549 13
	if (button == 2)	/* right */
	{
	    /* Right button: go back to prev document.
	     * The problem is that we need to determine
	     * what to return to achieve this.
	     */
	    return LYReverseKeymap(LYK_PREV_DOC);
	}
    }
    if (code == FOR_INPUT || code == FOR_PROMPT)
	return DO_NOTHING;
    else
	return -1;
d551 1
a551 1
#endif /* USE_SLANG and USE_MOUSE */
d553 3
a555 2
static BOOLEAN csi_is_csi = TRUE;
void ena_csi(BOOLEAN flag)
d565 2
a566 2
#define expand_substring(dst, first, last, final) \
	(SLexpand_escaped_string(dst, (char *)first, (char *)last), 1)
a567 1

d569 1
a569 1
#define MOUSE_KEYSYM 0x0400
d572 1
d584 1
a584 6
# ifdef VMS
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx}
# else
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx},{string1,lynx}
# endif
# define INTERN_KEY(string,lynx,curses)          {string,lynx}
d586 1
a586 2
#define INTERN_KEY(string,lynx,curses)           {string,curses}
#define EXTERN_KEY(string,string1,lynx,curses)   {string,curses}
d589 7
a595 5
typedef struct {
    const char *string;
    int value;
} Keysym_String_List;
/* *INDENT-OFF* */
d598 16
a613 16
    INTERN_KEY( "UPARROW",	UPARROW,	KEY_UP ),
    INTERN_KEY( "DNARROW",	DNARROW,	KEY_DOWN ),
    INTERN_KEY( "RTARROW",	RTARROW,	KEY_RIGHT ),
    INTERN_KEY( "LTARROW",	LTARROW,	KEY_LEFT ),
    INTERN_KEY( "PGDOWN",	PGDOWN,		KEY_NPAGE ),
    INTERN_KEY( "PGUP",		PGUP,		KEY_PPAGE ),
    INTERN_KEY( "HOME",		HOME,		KEY_HOME ),
    INTERN_KEY( "END",		END_KEY,	KEY_END ),
    INTERN_KEY( "F1",		F1,		KEY_F(1) ),
    INTERN_KEY( "DO_KEY",	DO_KEY,		KEY_F(16) ),
    INTERN_KEY( "FIND_KEY",	FIND_KEY,	KEY_FIND ),
    INTERN_KEY( "SELECT_KEY",	SELECT_KEY,	KEY_SELECT ),
    INTERN_KEY( "INSERT_KEY",	INSERT_KEY,	KEY_IC ),
    INTERN_KEY( "REMOVE_KEY",	REMOVE_KEY,	KEY_DC ),
    INTERN_KEY( "DO_NOTHING",	DO_NOTHING,	DO_NOTHING|LKC_ISLKC ),
    INTERN_KEY( NULL,		-1,		ERR )
a614 1
/* *INDENT-ON* */
d621 1
a621 1
static int lookup_tiname(char *name, NCURSES_CONST char *const *names)
d631 1
a631 1
static const char *expand_tiname(const char *first, size_t len, char **result, char *final)
d639 1
a639 1
	|| (code = lookup_tiname(name, strfnames)) >= 0) {
d641 1
a641 1
	    LYstrncpy(*result, cur_term->type.Strings[code], final - *result);
d648 1
a648 1
static const char *expand_tichar(const char *first, char **result, char *final)
d654 1
a654 1
    const char *name = 0;
d657 10
a666 33
    case 'E':
    case 'e':
	value = 27;
	break;
    case 'a':
	name = "bel";
	break;
    case 'b':
	value = '\b';
	break;
    case 'f':
	value = '\f';
	break;
    case 'n':
	value = '\n';
	break;
    case 'r':
	value = '\r';
	break;
    case 't':
	value = '\t';
	break;
    case 'v':
	value = '\v';
	break;
    case 'd':
	radix = 10;
	limit = 3;
	break;
    case 'x':
	radix = 16;
	limit = 2;
	break;
d679 6
a684 7
	char *last = 0;
	char tmp[80];

	LYstrncpy(tmp, first, limit);
	value = strtol(tmp, &last, radix);
	if (last != 0 && last != tmp)
	    first += (last - tmp);
d688 1
a688 1
	(void) expand_tiname(name, strlen(name), result, final);
d697 1
a697 1
static int expand_substring(char *dst, const char *first, const char *last, char *final)
a699 1

d703 1
a703 1
	    first = expand_tichar(first, &dst, final);
d708 1
a708 3
		const char *s = strchr(first, RPAREN);
		char *was = dst;

d711 1
a711 3
		first = expand_tiname(first, s - first, &dst, final);
		if (dst == was)
		    return 0;
d714 1
a714 1
	    } else if (ch == '?') {	/* ASCII delete? */
d723 1
a723 1
	case 0:		/* convert nulls for terminfo */
a731 1
    return 1;
d735 1
a735 1
static void unescaped_char(const char *parse, int *keysym)
d741 1
a741 1
	expand_substring(buf, parse + 1, parse + len - 1, buf + sizeof(buf) - 1);
d747 1
a747 1
static BOOLEAN unescape_string(char *src, char *dst, char *final)
a752 1

d759 4
a762 2
    } else if (*src == DQUOTE)
	ok = expand_substring(dst, src + 1, src + strlen(src) - 1, final);
d766 1
a766 1
int map_string_to_keysym(const char *str, int *keysym)
a767 2
    int modifier = 0;

a769 50
    if (strncasecomp(str, "LAC:", 4) == 0) {
	char *other = strchr(str + 4, ':');

	if (other) {
	    int othersym = lecname_to_lec(other + 1);
	    char buf[BUFSIZ];

	    if (othersym >= 0 && other - str - 4 < BUFSIZ) {
		strncpy(buf, str + 4, other - str - 4);
		buf[other - str - 4] = '\0';
		*keysym = lacname_to_lac(buf);
		if (*keysym >= 0) {
		    *keysym = LACLEC_TO_LKC0(*keysym, othersym);
		    return (*keysym);
		}
	    }
	}
	*keysym = lacname_to_lac(str + 4);
	if (*keysym >= 0) {
	    *keysym = LAC_TO_LKC0(*keysym);
	    return (*keysym);
	}
    }
    if (strncasecomp(str, "Meta-", 5) == 0) {
	str += 5;
	modifier = LKC_MOD2;
	if (*str) {
	    size_t len = strlen(str);

	    if (len == 1)
		return (*keysym = (UCH(str[0])) | modifier);
	    else if (len == 2 && str[0] == '^' &&
		     (isalpha(UCH(str[1])) ||
		      (TOASCII(str[1]) >= '@@' && TOASCII(str[1]) <= '_')))
		return (*keysym = FROMASCII(UCH(str[1] & 0x1f)) | modifier);
	    else if (len == 2 && str[0] == '^' &&
		     str[1] == '?')
		return (*keysym = CH_DEL | modifier);
	    if (*str == '^' || *str == '\\') {
		char buf[BUFSIZ];

		expand_substring(buf,
				 str,
				 str + HTMIN(len, 28),
				 buf + sizeof(buf) - 1);
		if (strlen(buf) <= 1)
		    return (*keysym = (UCH(buf[0])) | modifier);
	    }
	}
    }
d772 1
a772 1
    } else if (isdigit(UCH(*str))) {
d775 1
a775 2

	if (!isalnum(UCH(*tmp))) {
a776 5
#ifndef USE_SLANG
	    if (*keysym > 255)
		*keysym |= LKC_ISLKC;	/* caller should remove this flag - kw */
#endif
	}
d782 1
a782 1
	    if (0 == strcmp(k->string, str)) {
a789 2
    if (*keysym >= 0)
	*keysym |= modifier;
d797 1
a797 1
static char *skip_keysym(char *parse)
d815 1
a815 1
	} else if (isspace(UCH(*parse))) {
d827 1
a827 1
static int setkey_cmd(char *parse)
a832 1
    CTRACE((tfp, "KEYMAP(PA): in=%s", parse));	/* \n-terminated */
d834 1
a834 1
	if (isspace(UCH(*s))) {
d837 1
a837 2
	    if ((t = skip_keysym(s)) == 0) {
		CTRACE((tfp, "KEYMAP(SKIP) no key expansion found\n"));
a838 1
	    }
d841 2
a842 10
	    if (map_string_to_keysym(s, &keysym) >= 0) {
		if (!unescape_string(parse, buf, buf + sizeof(buf) - 1)) {
		    CTRACE((tfp, "KEYMAP(SKIP) could unescape key\n"));
		    return 0;	/* Trace the failure and continue. */
		}
		if (LYTraceLogFP == 0) {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x\n", keysym));
		} else {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x, seq='%s'\n", keysym, buf));
		}
a843 2
	    } else {
		CTRACE((tfp, "KEYMAP(SKIP) could not map to keysym\n"));
a844 2
	} else {
	    CTRACE((tfp, "KEYMAP(SKIP) junk after key description: '%s'\n", s));
a845 2
    } else {
	CTRACE((tfp, "KEYMAP(SKIP) no key description\n"));
d850 1
a850 1
static int unsetkey_cmd(char *parse)
a852 1

d862 2
a863 3

	    if (map_string_to_keysym(parse, &keysym) >= 0)
		define_key((char *) 0, keysym);
d871 2
a872 3
	SLang_undefine_key(parse, Keymap_List);
	if (SLang_Error)
	    return -1;
d884 1
a884 1
static int read_keymap_file(void)
a885 1
    /* *INDENT-OFF* */
d887 2
a888 2
	const char *name;
	int (*func) (char *s);
d890 2
a891 2
	{ "setkey",   setkey_cmd },
	{ "unsetkey", unsetkey_cmd },
a892 1
    /* *INDENT-ON* */
d897 1
d903 1
a903 1
    if ((fp = fopen(file, "r")) == 0)
d907 3
a909 1
    while (LYSafeGets(&line, fp) != 0) {
d919 7
a925 4

	    if (strlen(s) > len && !strncmp(s, table[n].name, len)
		&& (*(table[n].func)) (LYSkipBlanks(s + len)) < 0)
		fprintf(stderr, FAILED_READING_KEYMAP, linenum, file);
d929 7
a935 2
    LYCloseInput(fp);
    return 0;
d938 1
a938 1
static void setup_vtXXX_keymap(void)
a939 1
    /* *INDENT-OFF* */
d941 20
a960 49
	INTERN_KEY( "\033[A",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033OA",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033[B",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033OB",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033[C",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033OC",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033[D",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033OD",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033[1~",	FIND_KEY,	KEY_FIND ),
	INTERN_KEY( "\033[2~",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\033[3~",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\033[4~",	SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY( "\033[5~",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\033[6~",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\033[7~",	HOME,		KEY_HOME),
	INTERN_KEY( "\033[8~",	END_KEY,	KEY_END ),
	INTERN_KEY( "\033[11~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[28~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[29~",	DO_KEY,		KEY_F(16) ),
#if defined(USE_SLANG) && defined(__MINGW32__)
	INTERN_KEY( "\xE0H",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\xE0P",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\xE0M",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\xE0K",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\xE0R",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\xE0S",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\xE0I",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\xE0Q",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\xE0G",	HOME,		KEY_HOME),
	INTERN_KEY( "\xE0O",	END_KEY,	KEY_END ),
#endif
#if defined(USE_SLANG) && !defined(VMS)
	INTERN_KEY(	"^(ku)", UPARROW,	KEY_UP ),
	INTERN_KEY(	"^(kd)", DNARROW,	KEY_DOWN ),
	INTERN_KEY(	"^(kr)", RTARROW,	KEY_RIGHT ),
	INTERN_KEY(	"^(kl)", LTARROW,	KEY_LEFT ),
	INTERN_KEY(	"^(@@0)", FIND_KEY,	KEY_FIND ),
	INTERN_KEY(	"^(kI)", INSERT_KEY,	KEY_IC ),
	INTERN_KEY(	"^(kD)", REMOVE_KEY,	KEY_DC ),
	INTERN_KEY(	"^(*6)", SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY(	"^(kP)", PGUP,		KEY_PPAGE ),
	INTERN_KEY(	"^(kN)", PGDOWN,	KEY_NPAGE ),
	INTERN_KEY(	"^(@@7)", END_KEY,	KEY_END ),
	INTERN_KEY(	"^(kh)", HOME,		KEY_HOME),
	INTERN_KEY(	"^(k1)", F1,		KEY_F(1) ),
	INTERN_KEY(	"^(F6)", DO_KEY,	KEY_F(16) ),
#endif /* SLANG && !VMS */
a961 2
    /* *INDENT-ON* */

a962 1

d964 1
a964 1
	define_key(table[n].string, table[n].value);
d967 1
a967 1
int lynx_initialize_keymaps(void)
d973 1
a973 6
    /* The escape sequences may contain embedded termcap strings.  Make
     * sure the library is initialized for that.
     */
    SLtt_get_terminfo();

    if (NULL == (Keymap_List = SLang_create_keymap("Lynx", NULL)))
d977 2
a978 1
    for (i = 1; i < 256; i++) {
d980 1
a980 1
	define_key(keybuf, i);
d984 1
a984 1
    define_key("\033[M", MOUSE_KEYSYM);
d986 4
a989 2
    if (SLang_Error)
	SLang_exit_error("Unable to initialize keymaps");
d992 1
a993 1
    return read_keymap_file();
d996 1
a996 1
#endif /* USE_KEYMAPS */
d998 2
a999 2
#if defined(USE_MOUSE) && (defined(NCURSES))
static int LYmouse_menu(int x, int y, int atlink, int code)
d1001 25
a1025 34
#define ENT_ONLY_DOC	1
#define ENT_ONLY_LINK	2
    /* *INDENT-OFF* */
    static const struct {
	const char *txt;
	int  action;
	unsigned int  flag;
    } possible_entries[] = {
	{"Quit",			LYK_ABORT,		ENT_ONLY_DOC},
	{"Home page",			LYK_MAIN_MENU,		ENT_ONLY_DOC},
	{"Previous document",		LYK_PREV_DOC,		ENT_ONLY_DOC},
	{"Beginning of document",	LYK_HOME,		ENT_ONLY_DOC},
	{"Page up",			LYK_PREV_PAGE,		ENT_ONLY_DOC},
	{"Half page up",		LYK_UP_HALF,		ENT_ONLY_DOC},
	{"Two lines up",		LYK_UP_TWO,		ENT_ONLY_DOC},
	{"History",			LYK_HISTORY,		ENT_ONLY_DOC},
	{"Help",			LYK_HELP,		0},
	{"Do nothing (refresh)",	LYK_REFRESH,		0},
	{"Load again",			LYK_RELOAD,		ENT_ONLY_DOC},
	{"Edit Doc URL and load",	LYK_ECGOTO,		ENT_ONLY_DOC},
	{"Edit Link URL and load",	LYK_ELGOTO,		ENT_ONLY_LINK},
	{"Show info",			LYK_INFO,		0},
	{"Search",			LYK_WHEREIS,		ENT_ONLY_DOC},
	{"Print",			LYK_PRINT,		ENT_ONLY_DOC},
	{"Two lines down",		LYK_DOWN_TWO,		ENT_ONLY_DOC},
	{"Half page down",		LYK_DOWN_HALF,		ENT_ONLY_DOC},
	{"Page down",			LYK_NEXT_PAGE,		ENT_ONLY_DOC},
	{"End of document",		LYK_END,		ENT_ONLY_DOC},
	{"Bookmarks",			LYK_VIEW_BOOKMARK,	ENT_ONLY_DOC},
	{"Cookie jar",			LYK_COOKIE_JAR,		ENT_ONLY_DOC},
	{"Search index",		LYK_INDEX_SEARCH,	ENT_ONLY_DOC},
	{"Set Options",			LYK_OPTIONS,		ENT_ONLY_DOC},
	{"Activate this link",		LYK_SUBMIT,		ENT_ONLY_LINK},
	{"Download",			LYK_DOWNLOAD,		ENT_ONLY_LINK}
d1027 41
a1067 17
    /* *INDENT-ON* */

#define TOTAL_MENUENTRIES	TABLESIZE(possible_entries)
    const char *choices[TOTAL_MENUENTRIES + 1];
    int actions[TOTAL_MENUENTRIES];

    int c, c1, retlac, filter_out = (atlink ? ENT_ONLY_DOC : ENT_ONLY_LINK);

    c = c1 = 0;
    while (c < (int) TOTAL_MENUENTRIES) {
	if (!(possible_entries[c].flag & filter_out)) {
	    choices[c1] = possible_entries[c].txt;
	    actions[c1++] = possible_entries[c].action;
	}
	c++;
    }
    choices[c1] = NULL;
d1071 5
a1075 15
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x - 5 : 1),
		      choices, c1, FALSE, TRUE);

    /*
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
     */
    if (term_options) {
	retlac = LYK_DO_NOTHING;
	term_options = FALSE;
    } else {
	retlac = actions[c];
    }
d1077 1
a1077 38
    if (code == FOR_INPUT && mouse_link == -1) {
	switch (retlac) {
	case LYK_ABORT:
	    retlac = LYK_QUIT;	/* a bit softer... */
	    /* fall through */
	case LYK_MAIN_MENU:
	case LYK_PREV_DOC:
	case LYK_HOME:
	case LYK_PREV_PAGE:
	case LYK_UP_HALF:
	case LYK_UP_TWO:
	case LYK_HISTORY:
	case LYK_HELP:
/*	    case LYK_REFRESH:*/
	case LYK_RELOAD:
	case LYK_ECGOTO:
	case LYK_INFO:
	case LYK_WHEREIS:
	case LYK_PRINT:
	case LYK_DOWN_TWO:
	case LYK_DOWN_HALF:
	case LYK_NEXT_PAGE:
	case LYK_END:
	case LYK_VIEW_BOOKMARK:
	case LYK_COOKIE_JAR:
	case LYK_INDEX_SEARCH:
	case LYK_OPTIONS:
	    mouse_link = -3;	/* so LYgetch_for() passes it on - kw */
	}
    }
    if (retlac == LYK_DO_NOTHING ||
	retlac == LYK_REFRESH) {
	mouse_link = -1;	/* mainloop should not change cur link - kw */
    }
    if (code == FOR_INPUT && retlac == LYK_DO_NOTHING) {
	repaint_main_statusline(FOR_INPUT);
    }
    return retlac;
d1079 1
a1079 1
#endif /* USE_MOUSE && (NCURSES || PDCURSES) */
a1081 3
/************************************************************************/

static int current_sl_modifier = 0;
d1084 1
a1084 1
static int myGetChar(void)
d1086 1
a1086 5
    int i = GetChar();

    if (i == 0)			/* trick to get NUL char through - kw */
	current_sl_modifier = LKC_ISLKC;
    return i;
d1089 1
a1089 1
static int LYgetch_for(int code)
d1091 2
a1092 49
    SLang_Key_Type *key;
    int keysym;

    current_sl_modifier = 0;

    key = SLang_do_key(Keymap_List, myGetChar);
    if ((key == NULL) || (key->type != SLKEY_F_KEYSYM)) {
#ifdef __MINGW32__
	if ((key == NULL) && (current_sl_modifier == LKC_ISLKC)) {
	    key = SLang_do_key(Keymap_List, myGetChar);
	    keysym = key->f.keysym;
	    switch (keysym) {
	    case 'H':
		keysym = UPARROW;
		break;
	    case 'P':
		keysym = DNARROW;
		break;
	    case 'M':
		keysym = RTARROW;
		break;
	    case 'K':
		keysym = LTARROW;
		break;
	    case 'R':
		keysym = INSERT_KEY;
		break;
	    case 'S':
		keysym = REMOVE_KEY;
		break;
	    case 'I':
		keysym = PGUP;
		break;
	    case 'Q':
		keysym = PGDOWN;
		break;
	    case 'G':
		keysym = HOME;
		break;
	    case 'O':
		keysym = END_KEY;
		break;
	    case ';':
		keysym = F1;
		break;
	    }
	    return (keysym);
	}
#endif
d1094 3
a1096 2
	return (current_sl_modifier ? 0 : DO_NOTHING);
    }
d1098 1
a1098 1
    keysym = key->f.keysym;
d1100 3
a1102 3
#if defined (USE_MOUSE)
    if (keysym == MOUSE_KEYSYM)
	return sl_read_mouse_event(code);
d1105 2
a1106 2
    if (keysym < 0)
	return 0;
d1108 2
a1109 2
    if (keysym & (LKC_ISLECLAC | LKC_ISLAC))
	return (keysym);
d1111 4
a1114 10
    current_sl_modifier = 0;
    if (LKC_HAS_ESC_MOD(keysym)) {
	current_sl_modifier = LKC_MOD2;
	keysym &= LKC_MASK;
    }

    if (keysym + 1 >= KEYMAP_SIZE)
	return 0;

    return (keysym | current_sl_modifier);
d1117 1
a1117 2
/************************************************************************/
#else /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */
d1120 1
a1120 1
 * LYgetch() translates some escape sequences and may fake noecho.
d1124 7
a1130 1
static int LYgetch_for(int code)
a1132 2
    int current_modifier = 0;
    BOOLEAN done_esc = FALSE;
d1136 3
a1138 5
  re_read:
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
    if (errno == EINTR)
	set_errno(0);		/* reset - kw */
#endif /* UCX && VAXC */
d1140 1
a1140 1
    clearerr(stdin);		/* needed here for ultrix and SOCKETSHR, but why? - FM */
a1143 1
    lynx_nl2crlf(FALSE);
a1146 1
	lynx_nl2crlf(FALSE);
d1149 1
a1149 1
	if (c == EOF && errno == EINTR)		/* Ctrl-Z causes EINTR in getchar() */
d1156 1
a1156 2
	    CTRACE((tfp, "GETCH: Translate ^C to ^G.\n"));
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
a1160 48
    CTRACE((tfp, "GETCH: Got %#x.\n", c));
#ifdef MISC_EXP
    if (LYNoZapKey > 1 && errno != EINTR &&
	(c == EOF
#ifdef USE_SLANG
	 || (c == 0xFFFF)
#endif
	)) {
	int fd, kbd_fd;

	CTRACE((tfp,
		"nozap: Got EOF, curses %s, stdin is %p, LYNoZapKey reduced from %d to 0.\n",
		LYCursesON ? "on" : "off", stdin, LYNoZapKey));
	LYNoZapKey = 0;		/* 2 -> 0 */
	if ((fd = fileno(stdin)) == 0 && !isatty(fd) &&
	    (kbd_fd = LYConsoleInputFD(FALSE)) == fd) {
	    char *term_name;
	    int new_fd = INVSOC;

	    if ((term_name = ttyname(fileno(stdout))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC &&
		(term_name = ttyname(fileno(stderr))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC) {
		term_name = ctermid(NULL);
		new_fd = open(term_name, O_RDONLY);
	    }
	    CTRACE((tfp, "nozap: open(%s) returned %d.\n", term_name, new_fd));
	    if (new_fd >= 0) {
		FILE *frp;

		close(new_fd);
		frp = freopen(term_name, "r", stdin);
		CTRACE((tfp,
			"nozap: freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
			term_name, frp, stdin, fileno(stdin)));
		if (LYCursesON) {
		    stop_curses();
		    start_curses();
		    LYrefresh();
		}
		goto re_read;
	    }
	}
    }
#endif /* MISC_EXP */

a1163 19
#else
    if (c == EOF && errno == EINTR) {

#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		recent_sizechange));
	if (!recent_sizechange) {	/* not yet detected by ourselves */
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	}
#else /* HAVE_SIZECHANGE || USE_SLANG */
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
	set_errno(0);		/* reset - kw */
#endif /* UCX && VAXC */
	return (DO_NOTHING);
    }
d1174 1
a1174 1
	return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
d1176 1
a1176 1
#else /* not USE_SLANG: */
d1179 1
a1179 1
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
d1188 1
a1188 1
	if (c == ERR && errno == EINTR)		/* may have been handled signal - kw */
d1193 1
a1193 1
	exit_immediately(EXIT_SUCCESS);
d1197 1
a1197 4
    if (!escape_bound
	&& (c == CH_ESC || (csi_is_csi && c == UCH(CH_ESC_PAR)))) {
	/* handle escape sequence  S/390 -- gil -- 2024 */
	done_esc = TRUE;	/* Flag: we did it, not keypad() */
d1207 12
a1218 36
	case 'A':
	    c = UPARROW;
	    break;
	case 'B':
	    c = DNARROW;
	    break;
	case 'C':
	    c = RTARROW;
	    break;
	case 'D':
	    c = LTARROW;
	    break;
	case 'q':		/* vt100 application keypad 1 */
	    c = END_KEY;
	    break;
	case 'r':		/* vt100 application keypad 2 */
	    c = DNARROW;
	    break;
	case 's':		/* vt100 application keypad 3 */
	    c = PGDOWN;
	    break;
	case 't':		/* vt100 application keypad 4 */
	    c = LTARROW;
	    break;
	case 'v':		/* vt100 application keypad 6 */
	    c = RTARROW;
	    break;
	case 'w':		/* vt100 application keypad 7 */
	    c = HOME;
	    break;
	case 'x':		/* vt100 application keypad 8 */
	    c = UPARROW;
	    break;
	case 'y':		/* vt100 application keypad 9 */
	    c = PGUP;
	    break;
d1220 6
a1225 4
#if defined(USE_SLANG) && defined(USE_MOUSE)
	    if (found_CSI(c, b)) {
		c = sl_read_mouse_event(code);
	    } else
d1227 2
a1228 2
		c = '\n';	/* keypad enter on pc ncsa telnet */
	    break;
d1234 1
a1234 1
		c = '-';	/* keypad on pc ncsa telnet */
d1238 1
a1238 3
		c = '+';	/* keypad + on my xterminal :) */
	    else
		done_esc = FALSE;	/* we have another look below - kw */
d1244 1
a1244 1
		c = '+';	/* keypad on pc ncsa telnet */
d1256 1
a1256 1
		c = F1;		/* macintosh help button */
d1262 1
a1262 1
		c = '0';	/* keypad 0 */
d1264 2
a1265 2
	case '1':		/* VTxxx  Find  */
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
a1266 2
	    else
		done_esc = FALSE;	/* we have another look below - kw */
d1269 2
a1270 2
	    if (found_CSI(c, b)) {
		if ((d = GetChar()) == '~')	/* VTxxx Insert */
d1274 3
a1276 2
			 GetChar() == '~') {
		    if (d == '8')	/* VTxxx   Help */
d1278 1
a1278 1
		    else if (d == '9')	/* VTxxx    Do  */
d1281 2
a1282 3
		}
	    } else
		done_esc = FALSE;	/* we have another look below - kw */
d1285 1
a1285 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
a1286 2
	    else
		done_esc = FALSE;	/* we have another look below - kw */
d1289 1
a1289 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
a1290 2
	    else
		done_esc = FALSE;	/* we have another look below - kw */
d1293 1
a1293 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
a1294 2
	    else
		done_esc = FALSE;	/* we have another look below - kw */
d1297 1
a1297 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
a1298 2
	    else
		done_esc = FALSE;	/* we have another look below - kw */
d1301 2
a1302 2
	    if (found_CSI(c, b)) {
		if ((d = GetChar()) == 'A')
a1305 1
	    /* FALLTHRU */
d1307 1
a1307 8
	    if (c == CH_ESC && a == b && !found_CSI(c, b)) {
		current_modifier = LKC_MOD2;
		c = a;
		/* We're not yet done if ESC + curses-keysym: */
		done_esc = (BOOL) ((a & ~0xFF) == 0);
		break;
	    }
	    CTRACE((tfp, "Unknown key sequence: %d:%d:%d\n", c, b, a));
d1311 1
a1311 1
	if (isdigit(a) && found_CSI(c, b) && d != -1 && d != '~')
a1312 9
	if (!done_esc && (a & ~0xFF) == 0) {
	    if (a == b && !found_CSI(c, b) && c == CH_ESC) {
		current_modifier = LKC_MOD2;
		c = a;
		done_esc = TRUE;
	    } else {
		done_esc = TRUE;
	    }
	}
d1314 2
a1315 21
#ifdef USE_KEYMAPS
    /* Extract a single code if two are merged: */
    if (c >= 0 && (c & LKC_ISLECLAC)) {
	if (!(code == FOR_INPUT || code == FOR_PROMPT))
	    c = LKC2_TO_LKC(c);
    } else if (c >= 0 && (c & LKC_ISLKC)) {
	c &= ~LKC_ISLKC;
	done_esc = TRUE;	/* already a lynxkeycode, skip keypad switches - kw */
    }
    if (c >= 0 && LKC_HAS_ESC_MOD(c)) {
	current_modifier = LKC_MOD2;
	c &= LKC_MASK;
    }
    if (c >= 0 && (c & (LKC_ISLECLAC | LKC_ISLAC))) {
	done_esc = TRUE;	/* already a lynxactioncode, skip keypad switches - iz */
    }
#endif
    if (done_esc) {
	/* don't do keypad() switches below, we already got it - kw */
    } else {
#ifdef HAVE_KEYPAD
d1317 1
a1317 1
	 * Convert keypad() mode keys into Lynx defined keys.
d1319 4
a1322 4
	switch (c) {
	case KEY_DOWN:		/* The four arrow keys ... */
	    c = DNARROW;
	    break;
d1324 2
a1325 2
	    c = UPARROW;
	    break;
d1327 39
a1365 61
	    c = LTARROW;
	    break;
	case KEY_RIGHT:	/* ... */
	    c = RTARROW;
	    break;
#if defined(SH_EX) && defined(DOSPATH)	/* for NEC PC-9800 1998/08/30 (Sun) 21:50:35 */
	case KEY_C2:
	    c = DNARROW;
	    break;
	case KEY_A2:
	    c = UPARROW;
	    break;
	case KEY_B1:
	    c = LTARROW;
	    break;
	case KEY_B3:
	    c = RTARROW;
	    break;
	case PAD0:		/* PC-9800 Ins */
	    c = INSERT_KEY;
	    break;
	case PADSTOP:		/* PC-9800 DEL */
	    c = REMOVE_KEY;
	    break;
#endif /* SH_EX */
	case KEY_HOME:		/* Home key (upward+left arrow) */
	    c = HOME;
	    break;
	case KEY_CLEAR:	/* Clear screen */
	    c = 18;		/* CTRL-R */
	    break;
	case KEY_NPAGE:	/* Next page */
	    c = PGDOWN;
	    break;
	case KEY_PPAGE:	/* Previous page */
	    c = PGUP;
	    break;
	case KEY_LL:		/* home down or bottom (lower left) */
	    c = END_KEY;
	    break;
#if defined(KEY_A1) && defined(KEY_C3)
	    /* The keypad is arranged like this: */
	    /*    a1    up    a3   */
	    /*   left   b2  right  */
	    /*    c1   down   c3   */
	case KEY_A1:		/* upper left of keypad */
	    c = HOME;
	    break;
	case KEY_A3:		/* upper right of keypad */
	    c = PGUP;
	    break;
	case KEY_B2:		/* center of keypad */
	    c = DO_NOTHING;
	    break;
	case KEY_C1:		/* lower left of keypad */
	    c = END_KEY;
	    break;
	case KEY_C3:		/* lower right of keypad */
	    c = PGDOWN;
	    break;
#endif /* defined(KEY_A1) && defined(KEY_C3) */
d1367 3
a1369 3
	case KEY_ENTER:	/* enter/return      */
	    c = '\n';
	    break;
d1371 1
a1371 1
#ifdef PADENTER			/* PDCURSES */
d1373 2
a1374 2
	    c = '\n';
	    break;
d1377 3
a1379 3
	case KEY_END:		/* end key           001 */
	    c = END_KEY;
	    break;
d1382 3
a1384 3
	case KEY_HELP:		/* help key          001 */
	    c = F1;
	    break;
d1388 2
a1389 2
	    c = CH_DEL;		/* backspace key (delete, not Ctrl-H)  S/390 -- gil -- 2041 */
	    break;
d1392 2
a1393 2
	    c = F1;		/* VTxxx Help */
	    break;
d1396 2
a1397 2
	    c = DO_KEY;		/* VTxxx Do */
	    break;
d1400 3
a1402 3
	case KEY_REDO:		/* VTxxx Do */
	    c = DO_KEY;
	    break;
d1406 2
a1407 2
	    c = FIND_KEY;	/* VTxxx Find */
	    break;
d1411 2
a1412 2
	    c = SELECT_KEY;	/* VTxxx Select */
	    break;
d1416 2
a1417 2
	    c = INSERT_KEY;	/* VTxxx Insert */
	    break;
d1421 2
a1422 2
	    c = REMOVE_KEY;	/* VTxxx Remove */
	    break;
d1426 2
a1427 2
	    c = BACKTAB_KEY;	/* Back tab, often Shift-Tab */
	    break;
a1428 48
#ifdef KEY_RESIZE
	case KEY_RESIZE:	/* size change detected by ncurses */
#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	    /* Make call to detect new size, if that may be implemented.
	     * The call may set recent_sizechange (except for USE_SLANG),
	     * which will tell mainloop() to refresh. - kw
	     */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange so far is %d\n",
		    recent_sizechange));
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
#else /* HAVE_SIZECHANGE || USE_SLANG */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange is %d\n",
		    recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
	    if (!recent_sizechange) {
#if 0				/* assumption seems flawed? */
		/* Not detected by us or already processed by us.  It can
		 * happens that ncurses lags behind us in detecting the change,
		 * since its own SIGTSTP handler is not installed so detecting
		 * happened *at the end* of the last refresh.  Tell it to
		 * refresh again...  - kw
		 */
		LYrefresh();
#endif
#if defined(NCURSES)
		/*
		 * Work-around for scenario (Linux libc5) where we got a
		 * recent sizechange before reading KEY_RESIZE.  If we do
		 * not reset the flag, we'll next get an EOF read, which
		 * causes Lynx to exit.
		 */
		recent_sizechange = TRUE;
#endif
		/*
		 * May be just the delayed effect of mainloop()'s call to
		 * resizeterm().  Pretend we haven't read anything yet, don't
		 * return.  - kw
		 */
		goto re_read;
	    }
	    /*
	     * Yep, we agree there was a change.  Return now so that the caller
	     * can react to it.  - kw
	     */
	    c = DO_NOTHING;
	    break;
#endif /* KEY_RESIZE */
d1433 2
a1434 2
	    c = 0x213;
	    break;
d1436 2
a1437 2
	    c = 0x214;
	    break;
d1439 2
a1440 2
	    c = 0x215;
	    break;
d1442 2
a1443 2
	    c = 0x216;
	    break;
d1445 2
a1446 2
	    c = 0x217;
	    break;
d1448 2
a1449 2
	    c = 0x218;
	    break;
d1451 1
a1451 5

#if defined(USE_MOUSE)
/********************************************************************/

#if defined(NCURSES) || defined(PDCURSES)
a1452 1
	    CTRACE((tfp, "KEY_MOUSE\n"));
d1454 3
a1456 12
		c = MOUSE_KEY;	/* Will be processed by the caller */
	    }
#if defined(NCURSES)
	    else if (code == FOR_SINGLEKEY) {
		MEVENT event;

		getmouse(&event);	/* Completely ignore event - kw */
		c = DO_NOTHING;
	    }
#endif
	    else {
#if defined(NCURSES)
a1458 1
		int lac = LYK_UNKNOWN;
d1463 1
a1463 5
		if (err != OK) {
		    CTRACE((tfp, "Mouse error: no event available!\n"));
		    return (code == FOR_PANEL ? 0 : DO_NOTHING);
		}
		levent = event;	/* Allow setting pos in entry fields */
d1465 1
a1465 1
		    c = set_clicked_link(event.x, event.y, code, 1);
d1467 7
a1473 3
		    c = set_clicked_link(event.x, event.y, code, 2);
		    if (c == LAC_TO_LKC0(LYK_SUBMIT) && code == FOR_INPUT)
			lac = LYK_SUBMIT;
d1475 1
a1475 10
		    c = LAC_TO_LKC0(LYK_PREV_DOC);
		} else if (code == FOR_PROMPT
		    /* Cannot ignore: see LYCurses.c */
			   || (event.bstate &
			       (BUTTON1_PRESSED | BUTTON1_RELEASED
				| BUTTON2_PRESSED | BUTTON2_RELEASED
				| BUTTON3_PRESSED | BUTTON3_RELEASED))) {
		    /* Completely ignore - don't return anything, to
		       avoid canceling the prompt - kw */
		    goto re_read;
d1479 2
a1480 2
		    c = set_clicked_link(event.x, event.y, code, 1);
		    atlink = (c == LAC_TO_LKC0(LYK_ACTIVATE));
d1482 1
a1482 1
			mouse_link = -1;	/* Forget about approx stuff. */
d1484 5
a1488 11
		    lac = LYmouse_menu(event.x, event.y, atlink, code);
		    if (lac == LYK_SUBMIT) {
			if (mouse_link == -1)
			    lac = LYK_ACTIVATE;
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			else if (mouse_link >= 0 &&
				 textfields_need_activation &&
				 links[mouse_link].type == WWW_FORM_LINK_TYPE &&
				 F_TEXTLIKE(links[mouse_link].l_form->type))
			    lac = LYK_ACTIVATE;
#endif
d1490 1
a1490 6
		    if (lac == LYK_ACTIVATE && mouse_link == -1) {
			HTAlert(gettext("No link chosen"));
			lac = LYK_REFRESH;
		    }
		    c = LAC_TO_LKC(lac);
#if 0				/* Probably not necessary any more - kw */
d1492 1
a1492 2
		    LYrefresh();
#endif
d1494 3
a1496 4
		if (code == FOR_INPUT && mouse_link == -1 &&
		    lac != LYK_REFRESH && lac != LYK_SUBMIT) {
		    ungetmouse(&event);		/* Caller will process this. */
		    wgetch(LYwin);	/* ungetmouse puts KEY_MOUSE back */
a1499 15

#define H_CMD_AREA	6
#define HIST_CMD_2	12
#define V_CMD_AREA	1

		int left = H_CMD_AREA;
		int right = (LYcolLimit - H_CMD_AREA - 1);

		/* yes, I am assuming that my screen will be a certain width. */

		int tick_count;
		char *p = NULL;
		char mouse_info[128];
		static int old_click = 0;	/* [m Sec] */

a1501 12

		if (!system_is_NT) {
		    tick_count = GetTickCount();

		    /* Guard Mouse button miss click */
		    if ((tick_count - old_click) < 700) {
			c = DO_NOTHING;
			break;
		    } else {
			old_click = tick_count;
		    }
		}
d1503 4
a1506 41

		if (BUTTON_STATUS(1) & BUTTON_PRESSED) {
		    if (MOUSE_Y_POS > (LYlines - V_CMD_AREA - 1)) {
			/* Screen BOTTOM */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;
			    p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;
			    p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';
			    p = "Cancel";
			} else {
			    c = PGDOWN;
			    p = "PGDOWN";
			}
		    } else if (MOUSE_Y_POS < V_CMD_AREA) {
			/* Screen TOP */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;
			    p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;
			    p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';
			    p = "Cancel";
			} else {
			    c = PGUP;
			    p = "PGUP";
			}
		    } else {
			c = set_clicked_link(MOUSE_X_POS,
					     MOUSE_Y_POS,
					     FOR_PANEL, 1);
		    }
		}
		if (p && c != -1) {
		    sprintf(mouse_info, "Mouse = 0x%x, [%s]", c, p);
		    SetConsoleTitle(mouse_info);
d1508 1
a1508 3
#endif /* !(WIN_EX) */
		if ((c + 1) >= KEYMAP_SIZE && (c & LKC_ISLAC))
		    return (c);
d1511 1
a1511 5
#endif /* NCURSES || PDCURSES */

/********************************************************************/
#endif /* USE_MOUSE */

d1513 1
d1516 3
a1518 2
	switch (c) {
	case K_Down:		/* The four arrow keys ... */
d1520 2
a1521 2
	    c = DNARROW;
	    break;
d1524 2
a1525 2
	    c = UPARROW;
	    break;
d1528 3
a1530 3
	    c = LTARROW;
	    break;
	case K_Right:		/* ... */
d1532 3
a1534 3
	    c = RTARROW;
	    break;
	case K_Home:		/* Home key (upward+left arrow) */
d1536 3
a1538 3
	    c = HOME;
	    break;
	case K_PageDown:	/* Next page */
d1540 3
a1542 3
	    c = PGDOWN;
	    break;
	case K_PageUp:		/* Previous page */
d1544 3
a1546 3
	    c = PGUP;
	    break;
	case K_End:		/* home down or bottom (lower left) */
d1548 6
a1553 6
	    c = END_KEY;
	    break;
	case K_F1:		/* F1 key */
	    c = F1;
	    break;
	case K_Insert:		/* Insert key */
d1555 3
a1557 3
	    c = INSERT_KEY;
	    break;
	case K_Delete:		/* Delete key */
d1559 14
a1572 14
	    c = REMOVE_KEY;
	    break;
	case K_Alt_Escape:	/* Alt-Escape */
	    c = 0x1a7;
	    break;
	case K_Control_At:	/* CTRL-@@ */
	    c = 0x1a8;
	    break;
	case K_Alt_Backspace:	/* Alt-Backspace */
	    c = 0x1a9;
	    break;
	case K_BackTab:	/* BackTab */
	    c = BACKTAB_KEY;
	    break;
d1574 1
d1576 6
a1581 5
#if defined(USE_SLANG) && (defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(DJGPP_KEYHANDLER)  && !defined(USE_KEYMAPS)
	switch (c) {
	case SL_KEY_DOWN:	/* The four arrow keys ... */
	    c = DNARROW;
	    break;
d1583 2
a1584 2
	    c = UPARROW;
	    break;
d1586 30
a1615 30
	    c = LTARROW;
	    break;
	case SL_KEY_RIGHT:	/* ... */
	    c = RTARROW;
	    break;
	case SL_KEY_HOME:	/* Home key (upward+left arrow) */
	case SL_KEY_A1:	/* upper left of keypad */
	    c = HOME;
	    break;
	case SL_KEY_NPAGE:	/* Next page */
	case SL_KEY_C3:	/* lower right of keypad */
	    c = PGDOWN;
	    break;
	case SL_KEY_PPAGE:	/* Previous page */
	case SL_KEY_A3:	/* upper right of keypad */
	    c = PGUP;
	    break;
	case SL_KEY_END:	/* home down or bottom (lower left) */
	case SL_KEY_C1:	/* lower left of keypad */
	    c = END_KEY;
	    break;
	case SL_KEY_F(1):	/* F1 key */
	    c = F1;
	    break;
	case SL_KEY_IC:	/* Insert key */
	    c = INSERT_KEY;
	    break;
	case SL_KEY_DELETE:	/* Delete key */
	    c = REMOVE_KEY;
	    break;
d1617 1
a1618 1
    }
d1620 1
a1620 3
    if (c & (LKC_ISLAC | LKC_ISLECLAC))
	return (c);
    if ((c + 1) >= KEYMAP_SIZE) {
d1622 3
a1624 3
	 * Don't return raw values for KEYPAD symbols which we may have missed
	 * in the switch above if they are obviously invalid when used as an
	 * index into (e.g.) keypad[].  - KW
d1628 1
a1628 1
	return (c | current_modifier);
d1632 1
a1632 2
/************************************************************************/
#endif /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */
d1634 5
a1638 1
int LYgetch(void)
d1640 3
a1642 1
    return LYReadCmdKey(FOR_PANEL);
d1646 1
a1646 1
 * Read a single keystroke, allows mouse-selection.
d1648 2
a1649 1
int LYgetch_choice(void)
d1651 4
a1654 1
    int ch = LYReadCmdKey(FOR_CHOICE);
d1656 13
a1668 3
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    return ch;
d1672 1
a1672 1
 * Read a single keystroke, allows mouse events.
d1674 2
a1675 1
int LYgetch_input(void)
d1677 4
a1680 1
    int ch = LYReadCmdKey(FOR_INPUT);
d1682 9
a1690 3
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    return ch;
d1694 1
a1694 2
 * Read a single keystroke, ignoring case by translating it to uppercase.
 * Ignore mouse events, if any.
d1696 2
a1697 1
int LYgetch_single(void)
d1699 3
a1701 7
    int ch = LYReadCmdKey(FOR_SINGLEKEY);

    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    else if (ch > 0 && ch < 256)
	ch = TOUPPER(ch);	/* will ignore case of result */
    return ch;
d1705 1
a1705 1
 * Convert a null-terminated string to lowercase
d1707 2
a1708 1
void LYLowerCase(char *arg_buffer)
d1710 3
a1712 19
    register unsigned char *buffer = (unsigned char *) arg_buffer;
    size_t i;

    for (i = 0; buffer[i]; i++)
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:04:55 */
    {
	if ((buffer[i] & 0x80) != 0
	    && buffer[i + 1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOLOWER(buffer[i]));
	}
    }
#else
	buffer[i] = TOLOWER(buffer[i]);
#endif
d1716 1
a1716 1
 * Convert a null-terminated string to uppercase
d1718 2
a1719 1
void LYUpperCase(char *arg_buffer)
d1721 3
a1723 144
    register unsigned char *buffer = (unsigned char *) arg_buffer;
    size_t i;

    for (i = 0; buffer[i]; i++)
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:05:10 */
    {
	if ((buffer[i] & 0x80) != 0
	    && buffer[i + 1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOUPPER(buffer[i]));
	}
    }
#else
	buffer[i] = UCH(TOUPPER(buffer[i]));
#endif
}

/*
 * Remove newlines from a string, returning true if we removed any.
 */
BOOLEAN LYRemoveNewlines(char *buffer)
{
    if (buffer != 0) {
	register char *buf = buffer;

	for (; *buf && *buf != '\n' && *buf != '\r'; buf++) ;
	if (*buf) {
	    /* runs very seldom */
	    char *old = buf;

	    for (; *old; old++) {
		if (*old != '\n' && *old != '\r')
		    *buf++ = *old;
	    }
	    *buf = '\0';
	    return TRUE;
	}
    }
    return FALSE;
}

/*
 * Remove leading/trailing whitespace from a string, reduce runs of embedded
 * whitespace to single blanks.
 */
char *LYReduceBlanks(char *buffer)
{
    if (non_empty(buffer)) {
	LYTrimLeading(buffer);
	LYTrimTrailing(buffer);
	convert_to_spaces(buffer, TRUE);
    }
    return buffer;
}

/*
 * Remove ALL whitespace from a string (including embedded blanks), and returns
 * a pointer to the end of the trimmed string.
 */
char *LYRemoveBlanks(char *buffer)
{
    if (buffer != 0) {
	register char *buf = buffer;

	for (; *buf && !isspace(UCH(*buf)); buf++) ;
	if (*buf) {
	    /* runs very seldom */
	    char *old = buf;

	    for (; *old; old++) {
		if (!isspace(UCH(*old)))
		    *buf++ = *old;
	    }
	    *buf = '\0';
	}
	return buf;
    }
    return NULL;
}

/*
 * Skip whitespace
 */
char *LYSkipBlanks(char *buffer)
{
    while (isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip non-whitespace
 */
char *LYSkipNonBlanks(char *buffer)
{
    while (*buffer != 0 && !isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip const whitespace
 */
const char *LYSkipCBlanks(const char *buffer)
{
    while (isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip const non-whitespace
 */
const char *LYSkipCNonBlanks(const char *buffer)
{
    while (*buffer != 0 && !isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Trim leading blanks from a string
 */
void LYTrimLeading(char *buffer)
{
    char *skipped = LYSkipBlanks(buffer);

    while ((*buffer++ = *skipped++) != 0) ;
}

/*
 * Trim trailing newline(s) from a string
 */
char *LYTrimNewline(char *buffer)
{
    size_t i = strlen(buffer);

    while (i != 0 && (buffer[i - 1] == '\n' || buffer[i - 1] == '\r'))
	buffer[--i] = 0;
    return buffer;
d1729 2
a1730 1
void LYTrimTrailing(char *buffer)
d1733 1
a1733 2

    while (i != 0 && isspace(UCH(buffer[i - 1])))
a1736 27
/* 1997/11/10 (Mon) 14:26:10, originally string_short() in LYExterns.c, but
 * moved here because LYExterns is not always configured.
 */
char *LYElideString(char *str,
		    int cut_pos)
{
    char buff[MAX_LINE], *s, *d;
    static char s_str[MAX_LINE];
    int len;

    LYstrncpy(buff, str, sizeof(buff) - 1);
    len = strlen(buff);
    if (len > (LYcolLimit - 9)) {
	buff[cut_pos] = '.';
	buff[cut_pos + 1] = '.';
	for (s = (buff + len) - (LYcolLimit - 9) + cut_pos + 1,
	     d = (buff + cut_pos) + 2;
	     s >= buff &&
	     d >= buff &&
	     d < buff + LYcols &&
	     (*d++ = *s++) != 0;) ;
	buff[LYcols] = 0;
    }
    strcpy(s_str, buff);
    return (s_str);
}

d1740 2
a1741 1
BOOLEAN LYTrimStartfile(char *buffer)
d1744 2
a1745 2
    if (isLYNXEXEC(buffer) ||
	isLYNXPROG(buffer)) {
d1747 5
a1751 4
	 * The original implementations of these schemes expected white space
	 * without hex escaping, and did not check for hex escaping, so we'll
	 * continue to support that, until that code is redone in conformance
	 * with SGML principles.  - FM
d1763 2
a1764 1
void LYEscapeStartfile(char **buffer)
d1766 1
a1766 1
    if (!LYTrimStartfile(*buffer)) {
a1767 1

d1770 1
a1770 1
    }
d1776 2
a1777 1
void LYTrimAllStartfile(char *buffer)
d1780 1
a1780 1
	LYRemoveBlanks(buffer);
d1785 3
a1787 3
 *  Display the current value of the string and allow the user
 *  to edit it.
 */
d1792 1
a1792 1
 * Shorthand to get rid of all most of the "edit->suchandsos".
a1800 7
#ifdef ENHANCED_LINEEDIT
#define Mark	 edit->mark
#endif

#ifdef ENHANCED_LINEEDIT
static char killbuffer[1024] = "\0";
#endif
d1802 5
a1806 3
void LYSetupEdit(EDREC * edit, char *old,
		 int maxstr,
		 int maxdsp)
d1809 1
a1809 1
     * Initialize edit record
d1812 1
a1812 1
    edit->pad = ' ';
a1814 1
    edit->current_modifiers = 0;
d1816 2
a1817 1
    MaxLen = maxstr;
d1819 1
a1819 1
    Margin = 0;
a1820 3
#ifdef ENHANCED_LINEEDIT
    Mark = -1;			/* pos=0, but do not show it yet */
#endif
d1823 2
a1824 2
    if (maxstr > maxdsp) {	/* Need panning? */
	if (DspWdth > 4)	/* Else "{}" take up precious screen space */
d1828 4
a1831 3
	 * Figure out margins.  If too big, we do a lot of unnecessary
	 * scrolling.  If too small, user doesn't have sufficient look-ahead. 
	 * Let's say 25% for each margin, upper bound is 10 columns.
d1833 1
a1833 1
	Margin = DspWdth / 4;
d1838 14
a1851 29
    LYstrncpy(edit->buffer, old, maxstr);
    StrLen = strlen(edit->buffer);
}

#ifdef SUPPORT_MULTIBYTE_EDIT

static int prev_pos(EDREC * edit, int pos)
{
    int i = 0;

    if (pos <= 0)
	return 0;
    if (HTCJK == NOCJK)
	return (pos - 1);
    else {
	while (i < pos - 1) {
	    int c;

	    c = Buf[i];
	    if (is8bits(c) &&
		!((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c)))) {
		i++;
	    }
	    i++;
	}
	if (i == pos)
	    return (i - 2);
	else
	    return i;
a1853 1
#endif /* SUPPORT_MULTIBYTE_EDIT */
d1855 7
a1861 18
#ifdef EXP_KEYBOARD_LAYOUT
static int map_active = 0;

#else
#define map_active 0
#endif

int LYEditInsert(EDREC * edit, unsigned const char *s,
		 int len,
		 int map,
		 BOOL maxMessage)
{
    int length = strlen(Buf);
    int remains = MaxLen - (length + len);
    int edited = 0, overflow = 0;

    /*
     * ch is (presumably) printable character.
d1863 2
a1864 11
    if (remains < 0) {
	overflow = 1;
	len = 0;
	if (MaxLen > length)	/* Insert as much as we can */
	    len = MaxLen - length;
	else
	    goto finish;
    }
    Buf[length + len] = '\0';
    for (; length >= Pos; length--)	/* Make room */
	Buf[length + len] = Buf[length];
d1866 1
a1866 82
    if (map < 0)
	map = map_active;
    if (map && LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	int off = Pos;
	unsigned const char *e = s + len;
	char *tail = 0;

	while (s < e) {
	    char utfbuf[8];
	    int l = 1;

	    utfbuf[0] = *s;
	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
		UCode_t ucode = LYKbLayouts[current_layout][*s];

		if (ucode > 127) {
		    if (UCConvertUniToUtf8(ucode, utfbuf)) {
			l = strlen(utfbuf);
			remains -= l - 1;
			if (remains < 0) {
			    if (tail)
				strcpy(Buf + off, tail);
			    FREE(tail);
			    len = off;
			    overflow = 1;
			    goto finish;
			}
			if (l > 1 && !tail)
			    StrAllocCopy(tail, Buf + Pos + len);
		    } else
			utfbuf[0] = '?';
		} else
		    utfbuf[0] = UCH(ucode);
	    }
	    strncpy(Buf + off, utfbuf, l);
	    edited = 1;
	    off += l;
	    s++;
	}
	if (tail)
	    strcpy(Buf + off, tail);
	len = off - Pos;
	FREE(tail);
    } else if (map) {
	unsigned const char *e = s + len;
	unsigned char *t = (unsigned char *) Buf + Pos;

	while (s < e) {
	    int ch;

	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
		ch = UCTransUniChar(LYKbLayouts[current_layout][*s],
				    current_char_set);
		if (ch < 0)
		    ch = '?';
	    } else
		ch = *s;
	    *t = UCH(ch);
	    t++, s++;
	}
	edited = 1;
    } else
#endif /* defined EXP_KEYBOARD_LAYOUT */
    {
	strncpy(Buf + Pos, (const char *) s, len);
	edited = 1;
    }

  finish:
    Pos += len;
    StrLen += len;
    if (edited)
	edit->dirty = TRUE;
    if (overflow && maxMessage)
	_statusline(MAXLEN_REACHED_DEL_OR_MOV);
#ifdef ENHANCED_LINEEDIT
    if (Mark > Pos)
	Mark += len;
    else if (Mark < -1 - Pos)
	Mark -= len;
    if (Mark >= 0)
	Mark = -1 - Mark;	/* Disable it */
a1867 13
    return edited;
}

int LYEdit1(EDREC * edit, int ch,
	    int action,
	    BOOL maxMessage)
{				/* returns 0    character processed
				 *         -ch  if action should be performed outside of line-editing mode
				 *         ch   otherwise
				 */
    int i;
    int length;
    unsigned char uch;
d1870 1
a1870 1
	return (0);		/* Be defensive */
d1879 1
a1879 1
	 * Turn input character mapping on or off.
a1883 1
#ifndef CJK_EX
d1886 4
a1889 4
	 * Hex 97.
	 * Fall through as a character for CJK, or if this is a valid character
	 * in the current display character set.  Otherwise, we treat this as
	 * LYE_ENTER.
d1891 8
a1898 3
	if (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97)
	    return (ch);
	/* FALLTHRU */
a1899 6
    case LYE_CHAR:
	uch = UCH(ch);
	LYEditInsert(edit, &uch, 1, map_active, maxMessage);
	return 0;		/* All changes already registered */

    case LYE_C1CHAR:
d1901 1
a1901 6
	 * ch is the second part (in most cases, a capital letter) of a 7-bit
	 * replacement for a character in the 8-bit C1 control range.
	 *
	 * This is meant to undo transformations like 0x81 -> 0x1b 0x41 (ESC A)
	 * etc.  done by slang on Unix and possibly some comm programs.  It's
	 * an imperfect workaround that doesn't work for all such characters.
a1902 4
	ch &= 0xFF;
	if (ch + 64 >= LYlowest_eightbit[current_char_set])
	    ch += 64;

d1904 4
a1907 12
#ifdef ENHANCED_LINEEDIT
	    if (Mark > Pos)
		Mark++;
	    else if (Mark < -1 - Pos)
		Mark--;
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
#endif
	    for (i = length; i >= Pos; i--)	/* Make room */
		Buf[i + 1] = Buf[i];
	    Buf[length + 1] = '\0';
	    Buf[Pos] = UCH(ch);
d1909 2
a1910 5
	} else {
	    if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	    return (ch);
a1914 1
#ifndef SUPPORT_MULTIBYTE_EDIT
d1916 2
a1917 2
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters.
d1919 1
a1919 1
	while (Pos && !isalnum(Buf[Pos - 1]))
d1921 1
a1921 1
	while (Pos && isalnum(Buf[Pos - 1]))
a1922 31
#else /* SUPPORT_MULTIBYTE_EDIT */
	/*
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters, or 1 or
	 * more multibyte character.
	 */
	{
	    int pos0;

	    pos0 = prev_pos(edit, Pos);
	    while (Pos &&
		   (HTCJK == NOCJK || !is8bits(Buf[pos0])) &&
		   !isalnum(UCH(Buf[pos0]))) {
		Pos = pos0;
		pos0 = prev_pos(edit, Pos);
	    }
	    if (HTCJK != NOCJK && is8bits(Buf[pos0])) {
		while (Pos && is8bits(Buf[pos0])) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    } else {
		while (Pos
		       && !is8bits(Buf[pos0])
		       && isalnum(UCH(Buf[pos0]))) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    }
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
d1927 1
a1927 1
	 * Word forward.
a1928 1
#ifndef SUPPORT_MULTIBYTE_EDIT
d1930 1
a1930 1
	    Pos++;		/* '\0' is not a/n */
d1932 1
a1932 13
	    Pos++;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK && is8bits(Buf[Pos])) {
	    while (is8bits(Buf[Pos]))
		Pos += 2;
	} else {
	    while (!is8bits(Buf[Pos]) && isalnum(Buf[Pos]))
		Pos++;		/* '\0' is not a/n */
	}
	while ((HTCJK == NOCJK || !is8bits(Buf[Pos])) &&
	       !isalnum(UCH(Buf[Pos])) && Buf[Pos])
	    Pos++;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d1937 1
a1937 1
	 * Erase the line to start fresh.
d1939 2
a1940 5
	Buf[0] = '\0';
#ifdef ENHANCED_LINEEDIT
	Mark = -1;		/* Do not show the mark */
#endif
	/* fall through */
d1944 1
a1944 1
	 * Go to first column.
d1951 1
a1951 1
	 * Go to last column.
d1958 1
a1958 1
	 * Delete next word.
d1962 1
a1962 2

	    LYEdit1(edit, 0, LYE_FORWW, FALSE);
d1970 1
a1970 1
	 * Delete previous word.
d1974 1
a1974 2

	    LYEdit1(edit, 0, LYE_BACKW, FALSE);
d1983 1
a1983 1
	 * Delete from current cursor position back to BOL.
a1986 1

d1992 1
a1992 1
    case LYE_DELEL:		/* @@@@@@ */
d1994 1
a1994 1
	 * Delete from current cursor position thru EOL.
a1997 1

d2007 2
a2008 2
	 * Delete next character (I-beam style cursor), or current character
	 * (box/underline style cursor).
a2011 4
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (HTCJK != NOCJK && is8bits(Buf[Pos]))
	    Pos++;
#endif
d2017 1
a2017 1
	 * Delete preceding character.
a2018 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2020 6
#ifdef ENHANCED_LINEEDIT
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark++;
#endif
d2023 1
a2023 1
	    Buf[i] = Buf[i + 1];
a2024 23
#else /* SUPPORT_MULTIBYTE_EDIT */
	{
	    int offset = 1;
	    int pos0 = Pos;

	    if (length == 0 || Pos == 0)
		break;
	    if (HTCJK != NOCJK) {
		Pos = prev_pos(edit, pos0);
		offset = pos0 - Pos;
	    } else
		Pos--;
	    for (i = Pos; i < length; i++)
		Buf[i] = Buf[i + offset];
	    i -= offset;
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
	    if (Mark <= -1 - Pos)
		Mark += offset;
#endif
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
a2027 1
    case LYE_FORW_RL:
d2030 1
a2030 1
	 * Move cursor to the right.
a2031 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2033 9
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos < length) {
	    Pos++;
	    if (HTCJK != NOCJK && is8bits(Buf[Pos - 1]))
		Pos++;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_FORW_RL)
	    return -ch;
a2035 1
    case LYE_BACK_LL:
d2038 1
a2038 1
	 * Left-arrow move cursor to the left.
a2039 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2041 104
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos > 0) {
	    if (HTCJK != NOCJK)
		Pos = prev_pos(edit, Pos);
	    else
		Pos--;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_BACK_LL)
	    return -ch;
	break;

#ifdef ENHANCED_LINEEDIT
    case LYE_TPOS:
	/*
	 * Transpose characters - bash or ksh(emacs not gmacs) style
	 */
	if (length <= 1 || Pos == 0)
	    return (ch);
	if (Pos == length)
	    Pos--;
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Temporary enable it */
	if (Mark == Pos || Mark == Pos + 1)
	    Mark = Pos - 1;
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Buf[Pos - 1] == Buf[Pos]) {
	    Pos++;
	    break;
	}
	i = Buf[Pos - 1];
	Buf[Pos - 1] = Buf[Pos];
	Buf[Pos++] = (char) i;
	break;

    case LYE_SETMARK:
	/*
	 * primitive emacs-like set-mark-command
	 */
	Mark = Pos;
	return (0);

    case LYE_XPMARK:
	/*
	 * emacs-like exchange-point-and-mark
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Enable it */
	if (Mark == Pos)
	    return (0);
	i = Pos;
	Pos = Mark;
	Mark = i;
	break;

    case LYE_KILLREG:
	/*
	 * primitive emacs-like kill-region
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Enable it */
	if (Mark == Pos) {
	    killbuffer[0] = '\0';
	    return (0);
	}
	if (Mark > Pos)
	    LYEdit1(edit, 0, LYE_XPMARK, FALSE);
	{
	    int reglen = Pos - Mark;

	    LYstrncpy(killbuffer, &Buf[Mark],
		      HTMIN(reglen, (int) sizeof(killbuffer) - 1));
	    for (i = Mark; Buf[i + reglen]; i++)
		Buf[i] = Buf[i + reglen];
	    Buf[i] = Buf[i + reglen];	/* terminate */
	    Pos = Mark;
	}
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	break;

    case LYE_YANK:
	/*
	 * primitive emacs-like yank
	 */
	if (!killbuffer[0]) {
	    Mark = -1 - Pos;
	    return (0);
	} {
	    int yanklen = strlen(killbuffer);

	    if (Pos + yanklen <= (MaxLen) && StrLen + yanklen <= (MaxLen)) {
		Mark = -1 - Pos;

		for (i = length; i >= Pos; i--)		/* Make room */
		    Buf[i + yanklen] = Buf[i];
		for (i = 0; i < yanklen; i++)
		    Buf[Pos++] = UCH(killbuffer[i]);

	    } else if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	}
a2043 2
#endif /* ENHANCED_LINEEDIT */

d2053 1
a2053 1
	return (ch);
d2057 1
a2057 66
    return (0);
}

/*
 *  This function prompts for a choice or page number.
 *  If a 'g' or 'p' suffix is included, that will be
 *  loaded into c.  Otherwise, c is zeroed. - FM & LE
 */
int get_popup_number(const char *msg,
		     int *c,
		     int *rel)
{
    char temp[120];
    char *p = temp;
    int num;

    /*
     * Load the c argument into the prompt buffer.
     */
    temp[0] = (char) *c;
    temp[1] = '\0';
    _statusline(msg);

    /*
     * Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	*rel = '\0';
	return (0);
    }

    *rel = '\0';
    num = atoi(p);
    while (isdigit(UCH(*p)))
	++p;
    switch (*p) {
    case '+':
    case '-':
	/* 123+ or 123- */
	*rel = *p++;
	*c = *p;
	break;
    default:
	*c = *p++;
	*rel = *p;
	break;
    case 0:
	break;
    }

    /*
     * If we had a 'g' or 'p' suffix, load it into c.  Otherwise, zero c.  Then
     * return the number.
     */
    if (*p == 'g' || *p == 'G') {
	*c = 'g';
    } else if (*p == 'p' || *p == 'P') {
	*c = 'p';
    } else {
	*c = '\0';
    }
    if (*rel != '+' && *rel != '-')
	*rel = 0;
    return num;
a2059 7
#ifdef USE_COLOR_STYLE
#  define TmpStyleOn(s)		curses_style((s), STACK_ON)
#  define TmpStyleOff(s)	curses_style((s), STACK_OFF)
#else
#  define TmpStyleOn(s)
#  define TmpStyleOff(s)
#endif /* defined USE_COLOR_STYLE */
d2061 2
a2062 1
void LYRefreshEdit(EDREC * edit)
a2070 8
#ifdef SUPPORT_MULTIBYTE_EDIT
    int begin_multi = 0;
    int end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
#ifdef USE_COLOR_STYLE
    int estyle, prompting = 0;
#endif

d2076 1
a2076 1
    length = strlen(&Buf[0]);
d2078 18
a2095 34
    /*
     * Now we have:
     *                .--DspWdth---.
     *      +---------+=============+-----------+
     *      |         |M           M|           |   (M=margin)
     *      +---------+=============+-----------+
     *      0         DspStart                   length
     *
     * Insertion point can be anywhere between 0 and stringlength.  Figure out
     * new display starting point.
     *
     * The first "if" below makes Lynx scroll several columns at a time when
     * extending the string.  Looks awful, but that way we can keep up with
     * data entry at low baudrates.
     */
    if ((DspStart + DspWdth) <= length) {
	if (Pos >= (DspStart + DspWdth) - Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
	    DspStart = (Pos - DspWdth) + Margin;
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (HTCJK != NOCJK) {
		int tmp = (Pos - DspWdth) + Margin;

		while (DspStart < tmp) {
		    if (is8bits(Buf[DspStart]))
			DspStart++;
		    DspStart++;
		}
	    } else {
		DspStart = (Pos - DspWdth) + Margin;
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
	}
    }
a2097 1
#ifndef SUPPORT_MULTIBYTE_EDIT
d2101 3
a2103 3
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK) {
	    int tmp = Pos - Margin;
d2105 2
a2106 22
	    DspStart = 0;
	    while (DspStart < tmp) {
		if (is8bits(Buf[DspStart]))
		    DspStart++;
		DspStart++;
	    }
	} else {
	    DspStart = Pos - Margin;
	    if (DspStart < 0)
		DspStart = 0;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
    }

    str = &Buf[DspStart];
#ifdef SUPPORT_MULTIBYTE_EDIT
    if (HTCJK != NOCJK && is8bits(str[0]))
	begin_multi = 1;
#endif /* SUPPORT_MULTIBYTE_EDIT */

    nrdisplayed = length - DspStart;
    if (nrdisplayed > DspWdth)
d2109 1
a2109 1
    LYmove(edit->sy, edit->sx);
d2112 11
a2122 17
     * If this is the last screen line, set attributes to normal, should only
     * be needed for color styles.  The curses function may be used directly to
     * avoid complications.  - kw
     */
    if (edit->sy == (LYlines - 1))
	prompting = 1;
    if (prompting)
	estyle = s_prompt_edit;
    else
	estyle = s_aedit;
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.getstr: switching to <edit.%s>.\n",
	     prompting ? "prompt" : "active"));
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_ON);
    else
	wattrset(LYwin, A_NORMAL);	/* need to do something about colors? */
d2126 1
a2126 1
	    LYaddch('*');
d2128 1
a2128 13
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 && DspStart > Mark)
	    TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	for (i = 0; i < nrdisplayed; i++) {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			      || (DspStart + i == Pos && Pos < Mark)))
		TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			      || (DspStart + i == Pos && Pos > Mark)))
		TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
d2130 1
a2130 1
		(UCH(buffer[0]) == 160 &&
d2135 1
a2135 4
		LYaddch(' ');
#ifdef SUPPORT_MULTIBYTE_EDIT
		end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d2138 1
a2138 1
		if (HTCJK != NOCJK && is8bits(buffer[0])) {
d2141 1
a2141 15
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = (i < nrdisplayed);
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
		    {
			int ii, yy, xx;

			LYGetYX(yy, xx);
			for (ii = 0; buffer[ii] != '\0'; ++ii)
			    LYaddch(' ');
			LYrefresh();
			LYmove(yy, xx);
		    }
#endif /* USE_SLANG */
#endif /* SUPPORT_MULTIBYTE_EDIT */
		    LYaddstr(buffer);
d2144 1
a2144 1106
		    LYaddstr(buffer);
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
		}
	    }
	}
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 &&
	    ((DspStart + nrdisplayed <= Mark && DspStart + nrdisplayed > Pos)
	     || (DspStart + nrdisplayed > Mark
		 && DspStart + nrdisplayed <= Pos)))
	    TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
    }

    /*
     * Erase rest of input area.
     */
    padsize = DspWdth - nrdisplayed;
    if (padsize) {
	TmpStyleOn(prompting ? s_prompt_edit_pad : s_aedit_pad);
	while (padsize--)
	    LYaddch(UCH(edit->pad));
	TmpStyleOff(prompting ? s_prompt_edit_pad : s_aedit_pad);
    }

    /*
     * Scrolling indicators.
     */
    if (edit->panon) {
	if ((DspStart + nrdisplayed) < length) {
	    int add_space = 0;

	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (end_multi)
		add_space = 1;
#endif
	    LYmove(edit->sy, edit->sx + nrdisplayed - 1 - add_space);
	    if (add_space)
		LYaddch(' ');	/* Needed with styles? */
	    LYaddch(ACS_RARROW);
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
	if (DspStart) {
	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
	    LYmove(edit->sy, edit->sx);
	    LYaddch(ACS_LARROW);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (begin_multi)
		LYaddch(' ');	/* Needed with styles? */
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
    }

    LYmove(edit->sy, edit->sx + Pos - DspStart);

#ifdef USE_COLOR_STYLE
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_OFF);
#endif
    LYrefresh();
}

static void reinsertEdit(EditFieldData *edit, char *result)
{
    if (result != 0) {
	LYEdit1(edit, '\0', LYE_ERASE, FALSE);
	while (*result != '\0') {
	    LYLineEdit(edit, (int) (*result), FALSE);
	    result++;
	}
    }
}

static int caselessCmpList(const void *a,
			   const void *b)
{
    return strcasecomp(*(const char *const *) a, *(const char *const *) b);
}

static int normalCmpList(const void *a,
			 const void *b)
{
    return strcmp(*(const char *const *) a, *(const char *const *) b);
}

static char **sortedList(HTList *list, BOOL ignorecase)
{
    unsigned count = HTList_count(list);
    unsigned j = 0;
    unsigned k, jk;
    char **result = typecallocn(char *, count + 1);

    if (result == 0)
	outofmem(__FILE__, "sortedList");

    while (!HTList_isEmpty(list))
	result[j++] = (char *) HTList_nextObject(list);

    if (count > 1) {
	qsort((char *) result, count, sizeof(*result),
	      ignorecase ? caselessCmpList : normalCmpList);

	/* remove duplicate entries from the sorted index */
	for (j = 0; result[j] != 0; j++) {
	    k = j;
	    while (result[k] != 0
		   && !strcmp(result[j], result[k])) {
		k++;
	    }
	    k--;
	    if (j != k) {
		for (jk = j;; jk++) {
		    result[jk] = result[jk + k - j];
		    if (result[jk] == 0)
			break;
		}
	    }
	}
    }

    return result;
}

int LYarrayLength(const char **list)
{
    int result = 0;

    while (*list++ != 0)
	result++;
    return result;
}

int LYarrayWidth(const char **list)
{
    int result = 0;
    int check;

    while (*list != 0) {
	check = strlen(*list++);
	if (check > result)
	    result = check;
    }
    return result;
}

static void FormatChoiceNum(char *dst,
			    int num_choices,
			    int choice,
			    const char *value)
{
    if (num_choices >= 0) {
	int digits = (num_choices > 9) ? 2 : 1;

	sprintf(dst, "%*d: %.*s",
		digits, (choice + 1),
		MAX_LINE - 9 - digits, value);
    } else {
	LYstrncpy(dst, value, MAX_LINE - 1);
    }
}

static unsigned options_width(const char **list)
{
    unsigned width = 0;
    int count = 0;

    while (list[count] != 0) {
	if (strlen(list[count]) > width) {
	    width = strlen(list[count]);
	}
	count++;
    }
    return width;
}

static void draw_option(WINDOW * win, int entry,
			int width,
			BOOL reversed,
			int num_choices,
			int number,
			const char *value)
{
    char Cnum[MAX_LINE];

    FormatChoiceNum(Cnum, num_choices, number, "");
#ifdef USE_SLANG
    SLsmg_gotorc(win->top_y + entry, (win->left_x + 2));
    LYaddstr(Cnum);
    if (reversed)
	SLsmg_set_color(2);
    SLsmg_write_nstring((char *) value, win->width);
    if (reversed)
	SLsmg_set_color(0);
#else
    wmove(win, entry, 1);
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
    LynxWChangeStyle(win, s_menu_number, STACK_ON);
    waddstr(win, Cnum);
    LynxWChangeStyle(win, s_menu_number, STACK_OFF);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_ON);
#else
    if (reversed)
	wstart_reverse(win);
#endif
    LYpaddstr(win, width, value);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_OFF);
#else
    if (reversed)
	wstop_reverse(win);
#endif
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
#endif /* USE_SLANG */
}

/*
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
 *
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
 */
int LYhandlePopupList(int cur_choice,
		      int ly,
		      int lx,
		      const char **choices,
		      int width,
		      int i_length,
		      int disabled,
		      BOOLEAN for_mouse,
		      BOOLEAN numbered)
{
    int c = 0, cmd = 0, i = 0, j = 0, rel = 0;
    int orig_choice;
    WINDOW *form_window;
    int num_choices = 0;
    int max_choices = 0;
    int top, bottom, length = -1;
    int window_offset = 0;
    int lines_to_show;
    char Cnum[64];
    int Lnum;
    int npages;
    static char prev_target[MAX_LINE];	/* Search string buffer */
    static char prev_target_buffer[MAX_LINE];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0;
    RecallType recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN ReDraw = FALSE;
    int number;
    char buffer[MAX_LINE];
    const char *popup_status_msg = NULL;
    const char **Cptr = NULL;

#define CAN_SCROLL_DOWN	1
#define CAN_SCROLL_UP	2
#define CAN_SCROLL	4
    int can_scroll = 0, can_scroll_was = 0;

    orig_choice = cur_choice;
    if (cur_choice < 0)
	cur_choice = 0;

    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;

    /*
     * Count the number of choices to be displayed, where num_choices ranges
     * from 0 to n, and set width to the longest choice string length.  Also
     * set Lnum to the length for the highest choice number, then decrement
     * num_choices so as to be zero-based.  The window width will be based on
     * the sum of width and Lnum.  - FM
     */
    num_choices = LYarrayLength(choices) - 1;
    if (width <= 0)
	width = options_width(choices);
    if (numbered) {
	sprintf(Cnum, "%d: ", num_choices);
	Lnum = strlen(Cnum);
	max_choices = num_choices;
    } else {
	Lnum = 0;
	max_choices = -1;
    }

    /*
     * Let's assume for the sake of sanity that ly is the number corresponding
     * to the line the choice is on.
     *
     * Let's also assume that cur_choice is the number of the item that should
     * be initially selected, as 0 being the first item.
     *
     * So what we have, is the top equal to the current screen line subtracting
     * the cur_choice + 1 (the one must be for the top line we will draw in a
     * box).  If the top goes under 0, consider it 0.
     */
    top = ly - (cur_choice + 1);
    if (top < 0)
	top = 0;

    /*
     * Check and see if we need to put the i_length parameter up to the number
     * of real choices.
     */
    if (i_length < 1) {
	i_length = num_choices;
    } else {
	/*
	 * Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     * The bottom is the value of the top plus the number of options to view
     * plus 3 (one for the top line, one for the bottom line, and one to offset
     * the 0 counted in the num_choices).
     */
    bottom = top + i_length + 3;

    /*
     * Set lines_to_show based on the user_mode global.
     */
    if (user_mode == NOVICE_MODE)
	lines_to_show = LYlines - 4;
    else
	lines_to_show = LYlines - 2;

    if (for_mouse && user_mode == NOVICE_MODE && lines_to_show > 2)
	lines_to_show--;

    /*
     * Hmm...  If the bottom goes beyond the number of lines available,
     */
    if (bottom > lines_to_show) {
	/*
	 * Position the window at the top if we have more choices than will fit
	 * in the window.
	 */
	if ((i_length + 3) > lines_to_show) {
	    top = 0;
	    bottom = (top + (i_length + 3));
	    if (bottom > lines_to_show)
		bottom = (lines_to_show + 1);
	} else {
	    /*
	     * Try to position the window so that the selected choice will
	     * appear where the selection box currently is positioned.  It
	     * could end up too high, at this point, but we'll move it down
	     * latter, if that has happened.
	     */
	    top = (lines_to_show + 1) - (i_length + 3);
	    bottom = (lines_to_show + 1);
	}
    }

    /*
     * This is really fun, when the length is 4, it means 0 to 4, or 5.
     */
    length = (bottom - top) - 2;
    if (length <= num_choices)
	can_scroll = CAN_SCROLL;

    /*
     * Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > lines_to_show + 1)
	    bottom = lines_to_show + 1;
	top = bottom - length - 2;
    }

    if (for_mouse) {
	int check = (Lnum + (int) width + 4);
	int limit = LYcols;

	/* shift horizontally to lie within screen width, if possible */
	if (check < limit) {
	    if (lx - 1 + check > limit)
		lx = limit + 1 - check;
	    else if (lx <= 0)
		lx = 1;
	}
    }

    /*
     * Set up the overall window, including the boxing characters ('*'), if it
     * all fits.  Otherwise, set up the widest window possible.  - FM
     */
    width += Lnum;
    bottom -= top;

    if (num_choices <= 0
	|| cur_choice > num_choices
	|| (form_window = LYstartPopup(&top,
				       &lx,
				       &bottom,
				       &width)) == 0)
	return (orig_choice);

    width -= Lnum;
    bottom += top;

    /*
     * Clear the command line and write the popup statusline.  - FM
     */
    LYmove((LYlines - 2), 0);
    LYclrtoeol();
    if (disabled) {
	popup_status_msg = CHOICE_LIST_UNM_MSG;
    } else if (!for_mouse) {
	popup_status_msg = CHOICE_LIST_MESSAGE;
#if defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES))
    } else {
	popup_status_msg =
	    gettext("Left mouse button or return to select, arrow keys to scroll.");
#endif
    }
    _statusline(popup_status_msg);

    /*
     * Set up the window_offset for choices.
     * cur_choice ranges from 0...n
     * length ranges from 0...m
     */
    if (cur_choice >= length) {
	window_offset = cur_choice - length + 1;
    }

    /*
     * Compute the number of popup window pages.  - FM
     */
    npages = ((num_choices + 1) > length) ?
	(((num_choices + 1) + (length - 1)) / (length))
	: 1;
    /*
     * OH!  I LOVE GOTOs!  hack hack hack
     */
  redraw:

    /*
     * Display the boxed choices.
     */
    for (i = 0; i <= num_choices; i++) {
	if (i >= window_offset && i - window_offset < length) {
	    draw_option(form_window, ((i + 1) - window_offset), width, FALSE,
			max_choices, i, choices[i]);
	}
    }
    LYbox(form_window, (BOOLEAN) !numbered);
    Cptr = NULL;

    /*
     * Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {
	int row = ((i + 1) - window_offset);

	/* Show scroll indicators. */
	if (can_scroll) {
	    can_scroll = ((window_offset ? CAN_SCROLL_UP : 0)
			  | (num_choices - window_offset >= length
			     ? CAN_SCROLL_DOWN : 0));
	    if (~can_scroll & can_scroll_was) {		/* Need to redraw */
		LYbox(form_window, (BOOLEAN) !numbered);
		can_scroll_was = 0;
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_UP) {
		wmove(form_window, 1, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_UARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_DOWN) {
		wmove(form_window, length, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_DARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	}

	/*
	 * Unreverse cur choice.
	 */
	if (Cptr != NULL) {
	    draw_option(form_window, row, width, FALSE,
			max_choices, i, Cptr[i]);
	}
	Cptr = choices;
	i = cur_choice;
	row = ((cur_choice + 1) - window_offset);
	draw_option(form_window, row, width, TRUE,
		    max_choices, cur_choice, Cptr[cur_choice]);
	LYstowCursor(form_window, row, 1);

	c = LYgetch_choice();
	if (term_options || LYCharIsINTERRUPT(c)) {	/* Control-C or Control-G */
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, row, &cur_choice)) < 0)
		goto redraw;
	    if (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = LKC_TO_LAC(keymap, c);
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch (cmd) {
	case LYK_F_LINK_NUM:
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
	case LYK_9:
	    /*
	     * Get a number from the user, possibly with a 'g' or 'p' suffix
	     * (which will be loaded into c).  - FM & LE
	     */
	    number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);

	    /* handle + or - suffix */
	    CTRACE((tfp, "got popup option number %d, ", number));
	    CTRACE((tfp, "rel='%c', c='%c', cur_choice=%d\n",
		    rel, c, cur_choice));
	    if (c == 'p') {
		int curpage = ((cur_choice + 1) > length) ?
		(((cur_choice + 1) + (length - 1)) / (length))
		: 1;

		CTRACE((tfp, "  curpage=%d\n", curpage));
		if (rel == '+')
		    number = curpage + number;
		else if (rel == '-')
		    number = curpage - number;
	    } else if (rel == '+') {
		number = cur_choice + number + 1;
	    } else if (rel == '-') {
		number = cur_choice - number + 1;
	    }
	    if (rel)
		CTRACE((tfp, "new number=%d\n", number));
	    /*
	     * Check for a 'p' suffix.  - FM
	     */
	    if (c == 'p') {
		/*
		 * Treat 1 or less as the first page.  - FM
		 */
		if (number <= 1) {
		    if (window_offset == 0) {
			HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			_statusline(popup_status_msg);
			break;
		    }
		    window_offset = 0;
		    cur_choice = 0;
		    _statusline(popup_status_msg);
		    goto redraw;
		}

		/*
		 * Treat a number equal to or greater than the number of pages
		 * as the last page.  - FM
		 */
		if (number >= npages) {
		    if (window_offset >= ((num_choices - length) + 1)) {
			HTUserMsg(ALREADY_AT_OPTION_END);
			_statusline(popup_status_msg);
			break;
		    }
		    window_offset = ((npages - 1) * length);
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }
		    if (cur_choice < window_offset)
			cur_choice = window_offset;
		    _statusline(popup_status_msg);
		    goto redraw;
		}

		/*
		 * We want an intermediate page.  - FM
		 */
		if (((number - 1) * length) == window_offset) {
		    char *msg = 0;

		    HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
		    HTUserMsg(msg);
		    FREE(msg);
		    _statusline(popup_status_msg);
		    break;
		}
		cur_choice = window_offset = ((number - 1) * length);
		_statusline(popup_status_msg);
		goto redraw;

	    }

	    /*
	     * Check for a positive number, which signifies that a choice
	     * should be sought.  - FM
	     */
	    if (number > 0) {
		/*
		 * Decrement the number so as to correspond with our cur_choice
		 * values.  - FM
		 */
		number--;

		/*
		 * If the number is in range and had no legal suffix, select
		 * the indicated choice.  - FM
		 */
		if (number <= num_choices && c == '\0') {
		    cur_choice = number;
		    cmd = LYK_ACTIVATE;
		    break;
		}

		/*
		 * Verify that we had a 'g' suffix, and act on the number.  -
		 * FM
		 */
		if (c == 'g') {
		    if (cur_choice == number) {
			/*
			 * The choice already is current.  - FM
			 */
			char *msg = 0;

			HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			HTUserMsg(msg);
			FREE(msg);
			_statusline(popup_status_msg);
			break;
		    }

		    if (number <= num_choices) {
			/*
			 * The number is in range and had a 'g' suffix, so make
			 * it the current option, scrolling if needed.  - FM
			 */
			j = (number - cur_choice);
			cur_choice = number;
			if ((j > 0) &&
			    (cur_choice - window_offset) >= length) {
			    window_offset += j;
			    if (window_offset > (num_choices - length + 1))
				window_offset = (num_choices - length + 1);
			} else if ((cur_choice - window_offset) < 0) {
			    window_offset -= abs(j);
			    if (window_offset < 0)
				window_offset = 0;
			}
			_statusline(popup_status_msg);
			goto redraw;
		    }

		    /*
		     * Not in range.  - FM
		     */
		    HTUserMsg(BAD_OPTION_NUM_ENTERED);
		}
	    }

	    /*
	     * Restore the popup statusline.  - FM
	     */
	    _statusline(popup_status_msg);
	    break;

	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	case LYK_FASTBACKW_LINK:
	case LYK_UP_LINK:

	    if (cur_choice > 0)
		cur_choice--;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset--;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	case LYK_FASTFORW_LINK:
	case LYK_DOWN_LINK:
	    if (cur_choice < num_choices)
		cur_choice++;

	    /*
	     * Scroll the window down if necessary
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset++;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_PAGE:
	    /*
	     * Okay, are we on the last page of the list?  If not then,
	     */
	    if (window_offset != (num_choices - length + 1)) {
		/*
		 * Modify the current choice to not be a coordinate in the
		 * list, but a coordinate on the item selected in the window.
		 */
		cur_choice -= window_offset;

		/*
		 * Page down the proper length for the list.  If simply to far,
		 * back up.
		 */
		window_offset += length;
		if (window_offset > (num_choices - length)) {
		    window_offset = (num_choices - length + 1);
		}

		/*
		 * Readjust the current selection to be a list coordinate
		 * rather than window.  Redraw this thing.
		 */
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice < num_choices) {
		/*
		 * Already on last page of the list so just redraw it with the
		 * last item selected.
		 */
		cur_choice = num_choices;
	    }
	    break;

	case LYK_PREV_PAGE:
	    /*
	     * Are we on the first page of the list?  If not then,
	     */
	    if (window_offset != 0) {
		/*
		 * Modify the current selection to not be a list coordinate,
		 * but a window coordinate.
		 */
		cur_choice -= window_offset;

		/*
		 * Page up the proper length.  If too far, back up.
		 */
		window_offset -= length;
		if (window_offset < 0) {
		    window_offset = 0;
		}

		/*
		 * Readjust the current choice.
		 */
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice > 0) {
		/*
		 * Already on the first page so just back up to the first item.
		 */
		cur_choice = 0;
	    }
	    break;

	case LYK_HOME:
	    cur_choice = 0;
	    if (window_offset > 0) {
		window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_END:
	    cur_choice = num_choices;
	    if (window_offset != (num_choices - length + 1)) {
		window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_DOWN_TWO:
	    cur_choice += 2;
	    if (cur_choice > num_choices)
		cur_choice = num_choices;

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += 2;
		if (window_offset > (num_choices - length + 1))
		    window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_UP_TWO:
	    cur_choice -= 2;
	    if (cur_choice < 0)
		cur_choice = 0;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= 2;
		if (window_offset < 0)
		    window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_DOWN_HALF:
	    cur_choice += (length / 2);
	    if (cur_choice > num_choices)
		cur_choice = num_choices;

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += (length / 2);
		if (window_offset > (num_choices - length + 1))
		    window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_UP_HALF:
	    cur_choice -= (length / 2);
	    if (cur_choice < 0)
		cur_choice = 0;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= (length / 2);
		if (window_offset < 0)
		    window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_REFRESH:
	    lynx_force_repaint();
	    LYrefresh();
	    break;

	case LYK_NEXT:
	    if (recall && *prev_target_buffer == '\0') {
		/*
		 * We got a 'n'ext command with no prior query specified within
		 * the popup window.  See if one was entered when the popup was
		 * retracted, and if so, assume that's what's wanted.  Note
		 * that it will become the default within popups, unless
		 * another is entered within a popup.  If the within popup
		 * default is to be changed at that point, use WHEREIS ('/')
		 * and enter it, or the up- or down-arrow keys to seek any of
		 * the previously entered queries, regardless of whether they
		 * were entered within or outside of a popup window.  - FM
		 */
		if ((cp = (char *) HTList_objectAt(search_queries,
						   0)) != NULL) {
		    LYstrncpy(prev_target_buffer,
			      cp,
			      sizeof(prev_target_buffer) - 1);
		    QueryNum = 0;
		    FirstRecall = FALSE;
		}
	    }
	    strcpy(prev_target, prev_target_buffer);
	    /* FALLTHRU */
	case LYK_WHEREIS:
	    if (*prev_target == '\0') {
		_statusline(ENTER_WHEREIS_QUERY);
		if ((ch = LYgetstr(prev_target, VISIBLE,
				   sizeof(prev_target_buffer),
				   recall)) < 0) {
		    /*
		     * User cancelled the search via ^G.  - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}
	    }

	  check_recall:
	    if (*prev_target == '\0' &&
		!(recall && (ch == UPARROW || ch == DNARROW))) {
		/*
		 * No entry.  Simply break.  - FM
		 */
		HTInfoMsg(CANCELLED);
		goto restore_popup_statusline;
	    }

	    if (recall && ch == UPARROW) {
		if (FirstRecall) {
		    /*
		     * Use the current string or last query in the list.  - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = (QueryTotal - 1);
			     QueryNum > 0; QueryNum--) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(prev_target_buffer, cp)) {
				break;
			    }
			}
		    } else {
			QueryNum = 0;
		    }
		} else {
		    /*
		     * Go back to the previous query in the list.  - FM
		     */
		    QueryNum++;
		}
		if (QueryNum >= QueryTotal) {
		    /*
		     * Roll around to the last query in the list.  - FM
		     */
		    QueryNum = 0;
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((*prev_target_buffer && QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
		    }
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer), recall)) < 0) {
			/*
			 * User cancelled the search via ^G.  - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		    goto check_recall;
		}
	    } else if (recall && ch == DNARROW) {
		if (FirstRecall) {
		    /*
		     * Use the current string or first query in the list.  - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(prev_target_buffer, cp)) {
				break;
			    }
			}
		    } else {
			QueryNum = (QueryTotal - 1);
		    }
		} else {
		    /*
		     * Advance to the next query in the list.  - FM
		     */
		    QueryNum--;
		}
		if (QueryNum < 0) {
		    /*
		     * Roll around to the first query in the list.  - FM
		     */
		    QueryNum = (QueryTotal - 1);
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((*prev_target_buffer &&
				QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
		    }
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 * User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		    goto check_recall;
		}
	    }
	    /*
	     * Replace the search string buffer with the new target.  - FM
	     */
	    strcpy(prev_target_buffer, prev_target);
	    HTAddSearchQuery(prev_target_buffer);

	    /*
	     * Start search at the next choice.  - FM
	     */
	    for (j = 1; Cptr[i + j] != NULL; j++) {
		FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i + j]);
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
			break;
		}
	    }
	    if (Cptr[i + j] != NULL) {
		/*
		 * We have a hit, so make that choice the current.  - FM
		 */
		cur_choice += j;
		/*
		 * Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += j;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    ReDraw = TRUE;
		}
		goto restore_popup_statusline;
	    }

	    /*
	     * If we started at the beginning, it can't be present.  - FM
	     */
	    if (cur_choice == 0) {
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		goto restore_popup_statusline;
	    }

	    /*
	     * Search from the beginning to the current choice.  - FM
	     */
	    for (j = 0; j < cur_choice; j++) {
		FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
			break;
d2147 1
a2147 17
	    if (j < cur_choice) {
		/*
		 * We have a hit, so make that choice the current.  - FM
		 */
		j = (cur_choice - j);
		cur_choice -= j;
		/*
		 * Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= j;
		    if (window_offset < 0)
			window_offset = 0;
		    ReDraw = TRUE;
		}
		goto restore_popup_statusline;
	    }
d2149 6
a2154 4
	    /*
	     * Didn't find it in the preceding choices either.  - FM
	     */
	    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
d2156 11
a2166 24
	  restore_popup_statusline:
	    /*
	     * Restore the popup statusline and reset the search variables.  -
	     * FM
	     */
	    _statusline(popup_status_msg);
	    *prev_target = '\0';
	    QueryTotal = (search_queries ? HTList_count(search_queries)
			  : 0);
	    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
	    QueryNum = QueryTotal;
	    if (ReDraw == TRUE) {
		ReDraw = FALSE;
		goto redraw;
	    }
	    break;

	case LYK_QUIT:
	case LYK_ABORT:
	case LYK_PREV_DOC:
	case LYK_INTERRUPT:
	    cur_choice = orig_choice;
	    cmd = LYK_ACTIVATE;	/* to exit */
	    break;
a2168 1
    LYstopPopup();
d2170 2
a2171 1
    return (disabled ? orig_choice : cur_choice);
a2173 1
#define CurModif MyEdit.current_modifiers
d2175 5
a2179 4
int LYgetstr(char *inputline,
	     int hidden,
	     size_t bufsize,
	     RecallType recall)
a2182 3
    int xlec = -2;
    int last_xlec = -1;
    int last_xlkc = -1;
d2184 1
a2184 4

#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d2188 3
a2190 3
	(bufsize - 1) : (sizeof(MyEdit.buffer) - 1);
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, LYcolLimit - x);
    MyEdit.hidden = (BOOL) hidden;
a2191 1
    CTRACE((tfp, "called LYgetstr\n"));
d2193 1
a2193 2
      again:
#ifndef SUPPORT_MULTIBYTE_EDIT
d2195 1
a2195 19
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (refresh_mb)
	    LYRefreshEdit(&MyEdit);
#endif /* SUPPORT_MULTIBYTE_EDIT */
	ch = LYReadCmdKey(FOR_PROMPT);
#ifdef SUPPORT_MULTIBYTE_EDIT
#ifdef CJK_EX			/* for SJIS code */
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR))
	    goto again;
#else
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR)
	    && (EditBinding(ch) != LYE_AIX))
	    goto again;
#endif
#endif /* SUPPORT_MULTIBYTE_EDIT */

	if (term_letter || term_options
d2197 1
a2197 2
	    || HadVMSInterrupt
#endif /* VMS */
d2199 1
a2199 1
	    || term_message
d2201 1
a2201 2
	    ) {
#ifdef VMS
d2203 9
d2213 4
a2216 15
	    ch = LYCharINTERRUPT2;
	}

	if (recall != NORECALL && (ch == UPARROW || ch == DNARROW)) {
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
	    LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) recall\n", inputline));
	    return (ch);
	}
	ch |= CurModif;
	CurModif = 0;
	if (last_xlkc != -1) {
	    if (ch == last_xlkc)
		ch |= LKC_MOD3;
	    last_xlkc = -1;	/* consumed */
d2218 1
a2218 2
#ifndef WIN_EX
	if (LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
d2220 1
a2220 22
#endif
	last_xlec = xlec;
	xlec = EditBinding(ch);
	if ((xlec & LYE_DF) && !(xlec & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    xlec &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}
	switch (xlec) {
	case LYE_SETM1:
	    /*
	     * Set flag for modifier 1.
	     */
	    CurModif |= LKC_MOD1;
	    break;
	case LYE_SETM2:
	    /*
	     * Set flag for modifier 2.
	     */
	    CurModif |= LKC_MOD2;
	    break;
d2222 9
a2230 30
	    if (xlec == last_xlec && recall != NORECALL) {
		HTList *list = whichRecall(recall);

		if (!HTList_isEmpty(list)) {
		    char **data = sortedList(list, (BOOL) (recall == RECALL_CMD));
		    int old_y, old_x;
		    int cur_choice = 0;
		    int num_options = LYarrayLength((const char **) data);

		    while (cur_choice < num_options
			   && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
			cur_choice++;

		    LYGetYX(old_y, old_x);
		    cur_choice = LYhandlePopupList(cur_choice,
						   0,
						   old_x,
						   (const char **) data,
						   -1,
						   -1,
						   FALSE,
						   FALSE,
						   TRUE);
		    if (cur_choice >= 0) {
			if (recall == RECALL_CMD)
			    _statusline(": ");
			reinsertEdit(&MyEdit, data[cur_choice]);
		    }
		    wmove(LYwin, old_y, old_x);
		    FREE(data);
d2233 1
a2233 1
		reinsertEdit(&MyEdit, LYFindInCloset(recall, MyEdit.buffer));
a2235 2

#ifndef CJK_EX			/* 1997/11/03 (Mon) 20:13:45 */
d2238 4
a2241 4
	     * Hex 97.
	     * Treat as a character for CJK, or if this is a valid character in
	     * the current display character set.  Otherwise, we treat this as
	     * LYE_ENTER.
d2246 1
a2246 1
		LYLineEdit(&MyEdit, ch, FALSE);
a2248 2
	    /* FALLTHRU */
#endif
d2251 1
a2251 1
	     * Terminate the string and return.
d2253 3
a2255 46
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
	    if (!hidden)
		LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) LYE_ENTER\n", inputline));
	    return (ch);

#ifdef CAN_CUT_AND_PASTE
	    /* 1998/10/01 (Thu) 15:05:49 */

	case LYE_PASTE:
	    {
		unsigned char *s = (unsigned char *) get_clip_grab(), *e;
		int len;

		if (!s)
		    break;
		len = strlen((const char *) s);
		e = s + len;

		if (len > 0) {
		    unsigned char *e1 = s;

		    while (e1 < e) {
			if (*e1 < ' ') {	/* Stop here? */
			    if (e1 > s)
				LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
			    s = e1;
			    if (*e1 == '\t') {	/* Replace by space */
				LYEditInsert(&MyEdit,
					     (unsigned const char *) " ",
					     1,
					     map_active,
					     TRUE);
				s = ++e1;
			    } else
				break;
			} else
			    ++e1;
		    }
		    if (e1 > s)
			LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
		}
		get_clip_release();
		break;
	    }
#endif
d2259 1
a2259 1
	     * Control-C or Control-G aborts.
d2262 1
a2262 18
	    CTRACE((tfp, "LYgetstr LYE_ABORT\n"));
	    return (-1);

	case LYE_STOP:
	    /*
	     * Deactivate.
	     */
	    CTRACE((tfp, "LYgetstr LYE_STOP\n"));
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    return (-1);
#else
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
#endif
#endif
	    break;
d2266 3
a2268 2
	     * Used only in form_getstr() for invoking the LYK_F_LINK_NUM
	     * prompt when in form text fields.  - FM
d2274 3
a2276 2
	     * Used in form_getstr() to end line editing and pass on the input
	     * char/lynxkeycode.  Here it is just ignored.  - kw
a2280 9
	    if (xlec & LYE_FORM_LAC) {
		/*
		 * Used in form_getstr() to end line editing and pass on the
		 * lynxkeycode already containing a lynxactioncode.  Here it is
		 * just ignored.  - kw
		 */
		break;
	    }
#ifndef SUPPORT_MULTIBYTE_EDIT
a2281 12
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (LYLineEdit(&MyEdit, ch, FALSE) == 0) {
		if (refresh_mb && HTCJK != NOCJK && (0x81 <= ch) && (ch <= 0xfe))
		    refresh_mb = FALSE;
		else
		    refresh_mb = TRUE;
	    } else {
		if (!refresh_mb) {
		    LYEdit1(&MyEdit, 0, LYE_DELP, FALSE);
		}
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
a2285 24
const char *LYLineeditHelpURL(void)
{
    static int lasthelp_lineedit = -1;
    static char helpbuf[LY_MAXPATH] = "\0";
    static char *phelp = &helpbuf[0];

    if (lasthelp_lineedit == current_lineedit)
	return &helpbuf[0];
    if (lasthelp_lineedit == -1) {
	LYstrncpy(helpbuf, helpfilepath, sizeof(helpbuf) - 1);
	phelp += strlen(helpbuf);
    }
    if (LYLineeditHelpURLs[current_lineedit] &&
	strlen(LYLineeditHelpURLs[current_lineedit]) &&
	(strlen(LYLineeditHelpURLs[current_lineedit]) <=
	 sizeof(helpbuf) - (phelp - helpbuf))) {
	LYstrncpy(phelp, LYLineeditHelpURLs[current_lineedit],
		  sizeof(helpbuf) - (phelp - helpbuf) - 1);
	lasthelp_lineedit = current_lineedit;
	return (&helpbuf[0]);
    }
    return NULL;
}

d2287 1
a2287 1
 * A replacement for 'strsep()'
d2289 3
a2291 2
char *LYstrsep(char **stringp,
	       const char *delim)
d2295 7
a2301 2
    if (isEmpty(stringp))	/* nothing to do? */
	return 0;		/* then don't fall on our faces */
d2303 1
a2303 1
    out = *stringp;		/* save the start of the string */
d2306 5
a2310 5
	*tmp = '\0';		/* terminate the substring with \0 */
	*stringp = ++tmp;	/* point at the next substring */
    } else
	*stringp = 0;		/* this was the last substring: */
    /* let caller see he's done */
d2315 8
a2322 6
 * LYstrstr will find the first occurrence of the string pointed to by tarptr
 * in the string pointed to by chptr.  It returns NULL if string not found.  It
 * is a case insensitive search.
 */
char *LYstrstr(char *chptr,
	       const char *tarptr)
d2326 1
a2326 1
    for (; *chptr != '\0'; chptr++) {
d2328 2
a2329 2
	    if (0 == strncasecomp8(chptr + 1, tarptr + 1, len - 1))
		return (chptr);
d2331 1
a2331 1
    }				/* end for */
d2333 1
a2333 1
    return (NULL);		/* string not found or initial chptr was empty */
d2337 3
a2339 3
 * LYno_attr_char_case_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
d2345 1
a2345 1
 * It is a case insensitive search.
d2347 3
a2349 2
const char *LYno_attr_char_case_strstr(const char *chptr,
				       const char *tarptr)
d2351 1
a2351 1
    register const char *tmpchptr, *tmptarptr;
d2354 1
a2354 1
	return (NULL);
d2360 1
a2360 1
	if (0 == UPPER8(*chptr, *tarptr)) {
d2362 1
a2362 1
	     * See if they line up.
d2364 2
a2365 2
	    tmpchptr = chptr + 1;
	    tmptarptr = tarptr + 1;
d2367 2
a2368 2
	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);
d2380 1
a2380 1
		    return (chptr);
d2385 1
a2385 1
    }				/* end for */
d2387 1
a2387 1
    return (NULL);
d2391 3
a2393 3
 * LYno_attr_char_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
d2399 1
a2399 1
 * It is a case sensitive search.
d2401 3
a2403 2
const char *LYno_attr_char_strstr(const char *chptr,
				  const char *tarptr)
d2405 1
a2405 1
    register const char *tmpchptr, *tmptarptr;
d2408 1
a2408 1
	return (NULL);
d2416 1
a2416 1
	     * See if they line up.
d2421 2
a2422 2
	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);
d2425 1
a2425 1
		if (!IsSpecialAttrChar(*tmpchptr)) {
d2430 1
a2430 1
		} else {
d2432 5
a2436 5
		}
		if (*tmptarptr == '\0')
		    return (chptr);
		if (*tmpchptr == '\0')
		    break;
d2439 1
a2439 1
    }				/* end for */
d2441 1
a2441 1
    return (NULL);
d2446 4
a2449 10
 * pointed to by tarptr in the string pointed to by chptr.  It takes account of
 * MultiByte Character Sequences (UTF8).  The physical lengths of the displayed
 * string up to the start and end (= next position after) of the target string
 * are returned in *nstartp and *nendp if the search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
d2453 2
a2454 2
 *			      LY_BOLD_END_CHAR
 *			      LY_SOFT_HYPHEN
d2457 1
a2457 1
 * It is a case insensitive search.  - KW & FM
d2459 6
a2464 6
const char *LYno_attr_mbcs_case_strstr(const char *chptr,
				       const char *tarptr,
				       BOOL utf_flag,
				       BOOL count_gcells,
				       int *nstartp,
				       int *nendp)
d2466 1
a2466 2
    const char *tmpchptr;
    const char *tmptarptr;
d2471 1
a2471 1
	return (NULL);
d2474 1
a2474 1
     * Skip initial IsSpecial chars.  - FM
d2480 1
a2480 1
     * Seek a first target match.  - FM
d2483 1
a2483 1
	if ((!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
d2485 2
a2486 1
	     IsNormalChar(*(chptr + 1))) ||
a2488 1

d2493 1
a2493 1
	     * See if they line up.
d2500 1
a2500 1
		 * One char target.
d2502 8
a2509 9
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
	    }
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		*chptr == *tarptr &&
		IsNormalChar(*tmpchptr)) {
d2511 1
a2511 1
		 * Check the CJK multibyte.  - FM
d2515 1
a2515 1
		     * It's a match.  Advance to next char.  - FM
a2518 2
		    if (count_gcells)
			tarlen++;
d2521 1
a2521 1
			 * One character match.  - FM
d2523 3
a2525 5
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
d2527 1
d2530 2
a2531 2
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
a2533 2
		    if (count_gcells)
			len++;
d2538 1
a2538 1
	     * See if the rest of the target matches.  - FM
d2541 2
a2542 2
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
a2547 2
			    if (count_gcells)
				tarlen++;
d2549 1
a2549 1
			    break;
d2561 1
a2561 1
		} else {
d2563 1
a2563 1
		}
d2565 8
a2572 9
		if (*tmptarptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
		}
		if (*tmpchptr == '\0')
		    break;
d2575 4
a2578 3
		     IsSpecialAttrChar(*chptr))) {
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		IsNormalChar(*(chptr + 1))) {
a2579 2
		if (count_gcells)
		    len++;
d2583 1
a2583 1
    }				/* end for */
d2585 1
a2585 1
    return (NULL);
d2589 6
a2594 13
 * LYno_attr_mbcs_strstr will find the first occurrence of the string pointed
 * to by tarptr in the string pointed to by chptr.
 *
 * It takes account of CJK and MultiByte Character Sequences (UTF8).  The
 * physical lengths of the displayed string up to the start and end (= next
 * position after) the target string are returned in *nstartp and *nendp if the
 * search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
d2599 1
a2599 1
 *			      LY_SOFT_HYPHEN
d2602 1
a2602 1
 * It is a case sensitive search.  - KW & FM
d2604 6
a2609 6
const char *LYno_attr_mbcs_strstr(const char *chptr,
				  const char *tarptr,
				  BOOL utf_flag,
				  BOOL count_gcells,
				  int *nstartp,
				  int *nendp)
d2611 1
a2611 2
    const char *tmpchptr;
    const char *tmptarptr;
d2616 1
a2616 1
	return (NULL);
d2619 1
a2619 1
     * Skip initial IsSpecial chars.  - FM
d2625 1
a2625 1
     * Seek a first target match.  - FM
a2629 1

d2634 1
a2634 1
	     * See if they line up.
d2641 1
a2641 1
		 * One char target.
d2643 3
a2645 5
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
d2647 3
a2649 2
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		IsNormalChar(*tmpchptr)) {
d2651 1
a2651 1
		 * Check the CJK multibyte.  - FM
d2655 1
a2655 1
		     * It's a match.  Advance to next char.  - FM
a2658 2
		    if (count_gcells)
			tarlen++;
d2661 1
a2661 1
			 * One character match.  - FM
d2663 3
a2665 5
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
d2667 1
d2670 2
a2671 2
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
a2673 2
		    if (count_gcells)
			len++;
d2678 1
a2678 1
	     * See if the rest of the target matches.  - FM
d2681 2
a2682 2
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
a2687 2
			    if (count_gcells)
				tarlen++;
d2700 1
a2700 1
		} else {
d2702 1
a2702 1
		}
d2704 8
a2711 9
		if (*tmptarptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
		}
		if (*tmpchptr == '\0')
		    break;
d2714 4
a2717 3
		     IsSpecialAttrChar(*chptr))) {
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
		IsNormalChar(*(chptr + 1))) {
a2718 2
		if (count_gcells)
		    len++;
d2722 56
a2777 1
    }				/* end for */
d2779 3
a2781 1
    return (NULL);
d2785 1
a2785 1
 * Allocate a new copy of a string, and returns it.
d2787 4
a2790 3
char *SNACopy(char **dest,
	      const char *src,
	      int n)
d2794 1
a2794 2
	*dest = typeMallocn(char, n + 1);

d2796 1
a2796 1
	    CTRACE((tfp, "Tried to malloc %d bytes\n", n));
d2799 2
a2800 2
	strncpy(*dest, src, n);
	*(*dest + n) = '\0';	/* terminate */
d2806 1
a2806 1
 * String Allocate and Concatenate.
d2808 4
a2811 3
char *SNACat(char **dest,
	     const char *src,
	     int n)
d2813 1
a2813 1
    if (non_empty(src)) {
d2816 1
a2816 2

	    *dest = (char *) realloc(*dest, length + n + 1);
d2820 1
a2820 1
	    *(*dest + length + n) = '\0';	/* terminate */
d2822 1
a2822 2
	    *dest = typeMallocn(char, n + 1);

d2825 2
a2826 2
	    memcpy(*dest, src, n);
	    (*dest)[n] = '\0';	/* terminate */
d2838 1
a2838 1
static long UniToLowerCase(long upper)
d2844 1
a2844 1
     * Make check for sure.
d2847 1
a2847 1
	return (upper);
d2850 1
a2850 1
     * Try unicode_to_lower_case[].
d2853 1
a2853 1
    high = TABLESIZE(unicode_to_lower_case);
d2856 3
a2858 3
	 * Binary search.
	 */
	i = (low + (high - low) / 2);
d2861 1
a2861 1
	    low = i + 1;
d2868 38
a2905 1
    return (upper);		/* if we came here */
d2908 2
d2911 17
a2927 13
 *   UPPER8 ?
 *   it was "TOUPPER(a) - TOUPPER(b)" in its previous life...
 *
 *   It was realized that case-insensitive user search
 *   got information about upper/lower mapping from TOUPPER
 *   (precisely from "(TOUPPER(a) - TOUPPER(b))==0")
 *   and depends on locale in its 8bit mapping. -
 *   Usually fails with DOS/WINDOWS display charsets
 *   as well as on non-UNIX systems.
 *
 *   So use unicode case mapping.
 */
int UPPER8(int ch1, int ch2)
a2928 7
    /* if they are the same or one is a null characters return immediately. */
    if (ch1 == ch2)
	return 0;
    if (!ch2)
	return UCH(ch1);
    else if (!ch1)
	return -UCH(ch2);
d2931 2
a2932 2
    if (UCH(TOASCII(ch1)) < 128 && UCH(TOASCII(ch2)) < 128)
	return (TOUPPER(ch1) - TOUPPER(ch2));
d2935 3
a2937 2
    if (UCH(TOASCII(ch1)) > 127 &&	/* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127) {
d2939 17
a2955 4
	    return (TOUPPER(ch1) - TOUPPER(ch2));	/* old-style */
	else {
	    long uni_ch2 = UCTransToUni((char) ch2, current_char_set);
	    long uni_ch1;
d2957 8
a2964 4
	    if (uni_ch2 < 0)
		return UCH(ch1);
	    uni_ch1 = UCTransToUni((char) ch1, current_char_set);
	    return (UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
d2968 1
a2968 1
    return (-10);		/* mismatch, if we come to here */
d2970 1
d2977 3
a2979 2
char *LYSafeGets(char **src,
		 FILE *fp)
d2995 2
a2996 7
    if (ferror(fp)) {
	FREE(result);
    } else if (feof(fp) && result && *result == '\0') {
	/*
	 * If the file ends in the middle of a line, return the partial line;
	 * if another call is made after this, it will return NULL.  - kw
	 */
a3002 119

#ifdef EXP_CMD_LOGGING
static FILE *cmd_logfile;
static FILE *cmd_script;

void LYOpenCmdLogfile(int argc,
		      char **argv)
{
    int n;

    if (lynx_cmd_logfile != 0) {
	cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
	if (cmd_logfile != 0) {
	    fprintf(cmd_logfile, "# Command logfile created by %s %s (%s)\n",
		    LYNX_NAME, LYNX_VERSION, LYVersionDate());
	    for (n = 0; n < argc; n++) {
		fprintf(cmd_logfile, "# Arg%d = %s\n", n, argv[n]);
	    }
	}
    }
}

BOOL LYHaveCmdScript(void)
{
    return (BOOL) (cmd_script != 0);
}

void LYOpenCmdScript(void)
{
    if (lynx_cmd_script != 0) {
	cmd_script = fopen(lynx_cmd_script, TXT_R);
	CTRACE((tfp, "LYOpenCmdScript(%s) %s\n",
		lynx_cmd_script,
		cmd_script != 0 ? "SUCCESS" : "FAIL"));
    }
}

int LYReadCmdKey(int mode)
{
    int ch = -1;

    if (cmd_script != 0) {
	char *buffer = 0;
	char *src;
	char *tmp;
	unsigned len;

	while ((ch < 0) && LYSafeGets(&buffer, cmd_script) != 0) {
	    LYTrimTrailing(buffer);
	    src = LYSkipBlanks(buffer);
	    tmp = LYSkipNonBlanks(src);
	    switch (len = (tmp - src)) {
	    case 4:
		if (!strncasecomp(src, "exit", 4))
		    exit_immediately(0);
		break;
	    case 3:
		if (!strncasecomp(src, "key", 3)) {
		    ch = LYStringToKeycode(LYSkipBlanks(tmp));
		} else if (!strncasecomp(src, "set", 3)) {
		    src = LYSkipBlanks(tmp);
		    tmp = src;
		    while (*tmp != '\0') {
			if (isspace(UCH(*tmp)) || *tmp == '=')
			    break;
			++tmp;
		    }
		    if (*tmp != '\0') {
			*tmp++ = '\0';
			tmp = LYSkipBlanks(tmp);
		    }
		    CTRACE((tfp, "LYSetConfigValue(%s, %s)\n", src, tmp));
		    LYSetConfigValue(src, tmp);
		}
		break;
	    }
	}
	if (feof(cmd_script)) {
	    fclose(cmd_script);
	    cmd_script = 0;
	}
	if (ch >= 0) {
	    LYSleepReplay();
	    LYrefresh();
	}
	FREE(buffer);
    } else {
	ch = LYgetch_for(mode);
    }
    CTRACE((tfp, "LYReadCmdKey(%d) ->%s (%#x)\n",
	    mode, LYKeycodeToString(ch, TRUE), ch));
    LYWriteCmdKey(ch);
    return ch;
}

/*
 * Write a LYKeymapCode 'ch' to the logfile.
 */
void LYWriteCmdKey(int ch)
{
    if (cmd_logfile != 0) {
	fprintf(cmd_logfile, "key %s\n", LYKeycodeToString(ch, FALSE));
    }
}

void LYCloseCmdLogfile(void)
{
    if (cmd_logfile != 0) {
	LYCloseOutput(cmd_logfile);
	cmd_logfile = 0;
    }
    if (cmd_script != 0) {
	LYCloseInput(cmd_script);
	cmd_script = 0;
    }
    FREE(lynx_cmd_logfile);
    FREE(lynx_cmd_script);
}
#endif /* EXP_CMD_LOGGING */
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a2 2
#include <UCAux.h>
#include <LYGlobalDefs.h>
d5 1
a15 1
#include <HTList.h>
a16 3
#ifdef USE_MOUSE
#include <LYMainLoop.h>
#endif
a27 9
#ifdef USE_SCROLLBAR
#include <LYMainLoop.h>
#endif

#ifdef EXP_CMD_LOGGING
#include <LYReadCFG.h>
#endif

#include <LYShowInfo.h>
d30 3
a32 4
#if defined(WIN_EX)
#undef  BUTTON_CTRL
#define BUTTON_CTRL	0	/* Quick hack */
#endif
d34 2
a35 4
/*
 * The edit_history lists allow the user to press tab when entering URL to get
 * the closest match in the closet
 */
d37 2
d40 4
a43 2
static HTList *URL_edit_history;
static HTList *MAIL_edit_history;
d61 1
a61 1
#if defined(USE_MOUSE) && defined(NCURSES)
d68 2
a69 2
#if defined(USE_MOUSE) && defined(NCURSES)
    if (have_levent > 0) {
a70 1
	have_levent--;
a93 1

d100 6
a105 43
#ifdef USE_MOUSE
/*********************************************************************/

#if defined(WIN_EX) && defined(PDCURSES)

    request_mouse_pos();

    if (BUTTON_STATUS(1)
      && (MOUSE_X_POS >= getbegx(win)
      && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
	int mypos = MOUSE_Y_POS - getbegy(win);
	int delta = mypos - row;

	if (mypos+1 == getmaxy(win)) {
	    /* At the decorative border: scroll forward */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_END;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_NEXT_PAGE;
	    else
		cmd = LYK_NEXT_LINK;
	} else if (mypos >= getmaxy(win)) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_END;
	    else
		cmd = LYK_NEXT_PAGE;
	} else if (mypos == 0) {
	    /* At the decorative border: scroll back */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_HOME;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_PREV_PAGE;
	    else
		cmd = LYK_PREV_LINK;
	} else if (mypos < 0) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_HOME;
	    else
		cmd = LYK_PREV_PAGE;
#ifdef KNOW_HOW_TO_TOGGLE
	} else if (BUTTON_STATUS(1) & (BUTTON_CTRL)) {
	    cur_selection += delta;
	    cmd = LYX_TOGGLE;
a106 16
	} else if (BUTTON_STATUS(1) & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)) {
	    /* Probably some unrelated activity, such as selecting some text.
	     * Select, but do nothing else.
	     */
	    *position += delta;
	    cmd = -1;
	} else {
	    /* No scrolling or overflow checks necessary. */
	    *position += delta;
	    cmd = LYK_ACTIVATE;
	}
    } else if (BUTTON_STATUS(1) & (BUTTON3_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED)) {
	cmd = LYK_QUIT;
    }
#else
#if defined(NCURSES)
d111 4
a114 2
			      | BUTTON1_DOUBLE_CLICKED
			      | BUTTON1_TRIPLE_CLICKED))) {
a117 3
	if ((event.x < getbegx(win) || event.x >= (getbegx(win) + getmaxx(win)))
	    && !(event.bstate & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)))
	    return LYK_QUIT;	/* User clicked outside, wants to quit? */
a150 8
	} else if (event.x <= getbegx(win) + 1 ||
		   event.x >= getbegx(win) + getmaxx(win) - 2) {
	    /* Click on left or right border for positioning without
	     * immediate action: select, but do nothing else.
	     * Actually, allow an error of one position inwards. - kw
	     */
	    *position += delta;
	    cmd = -1;
a154 4
	    /* Possibly this is never returned by ncurses, so this case
	     * may be useless depending on situation (kind of mouse support
	     * and library versions). - kw
	     */
d160 9
d174 1
a174 5
#endif /* NCURSES */
#endif /* PDCURSES */

/************************************************************************/
#endif  /* USE_MOUSE */
a177 76
/*
 * Manage the collection of edit-histories
 */
PRIVATE HTList *whichRecall ARGS1(
    RecallType,		recall)
{
    HTList **list;

    switch (recall) {
    case RECALL_CMD:
	return LYcommandList();
    case RECALL_MAIL:
	list = &MAIL_edit_history;
	break;
    default:
	list = &URL_edit_history;
	break;
    }
    if (*list == 0)
	*list = HTList_new();
    return *list;
}

/*
 * Remove the oldest item in the closet
 */
PRIVATE void LYRemoveFromCloset ARGS1(HTList *, list)
{
    char *data = HTList_removeFirstObject(list);

    if (data != 0)
	FREE(data);
}

PUBLIC void LYCloseCloset ARGS1(RecallType, recall)
{
    HTList *list = whichRecall(recall);

    while (!HTList_isEmpty(list) ) {
	LYRemoveFromCloset(list);
    }
    HTList_delete(list);	/* should already be empty */
}

/*
 * Strategy:  We begin at the top and search downwards.  We return the first
 * match, i.e., the newest since we search from the top.  This should be made
 * more intelligent, but works for now.
 */
PRIVATE char * LYFindInCloset ARGS2(RecallType, recall, char*, base)
{
    HTList *list = whichRecall(recall);
    char *data;
    unsigned len = strlen(base);

    while (!HTList_isEmpty(list)) {
	data = HTList_nextObject(list);
	if (!strncmp(base, data, len))
	    return(data);
    }

    return(0);
}

PRIVATE void LYAddToCloset ARGS2(RecallType, recall, char*, str)
{
    HTList *list = whichRecall(recall);
    char *data = NULL;

    StrAllocCopy(data, str);
    HTList_addObject(list, data);
    while (HTList_count(list) > LYClosetSize)
	LYRemoveFromCloset(list);
}

#ifdef USE_MOUSE
d185 1
a185 1
    int xerr = 3 * (x2 - x1), yerr = 9 * (y2 - y1);
d188 1
a188 1
	xerr = 3 * (x1 - x2 - dx2) + 1;	/* pos after string not really in it */
d193 1
a193 18
    if (!yerr)			/* same line is good */
	return (xerr > 0) ? (xerr*2 - 1) : 0;
    if (xerr < 9 && yerr)   /* x-dist of 3 cell better than y-dist of 1 cell */
	yerr += (9 - xerr);
    return 2 * xerr + yerr; /* Subjective factor; ratio -> approx. 6 / 9 */
/*
old: (IZ 1999-07-30)
 3  2  2  2  1  1  1 XX XX XX XX XX  0  1  1  1  2  2  2  3  3
 4\ 3  3  3  2  2  2  2  2  2  2  2  2  2  2  2  3  3  3/ 4  4
 5  4  4  4\ 3  3  3  3  3  3  3  3  3  3  3  3/ 4  4  4  5  5
 6  5  5  5  4  4  4  4  4  4  4  4  4  4  4  4  5  5  5  6  5
now: (kw 1999-10-23)
41 35 29|23 17 11  5 XX XX XX XX XX  1  7 13 19 25|31 37 43 49
   45 39 33\27 24 21 18 18 18 18 18 19 22 25 28/34 40 46 50
      48 42 36 33 30\27 27 27 27 27 28/31 34 37 43 49
         51 45 42 39 36 36 36 36 36 37 40 43 46 49
               51 48 45 45 45 45 45 46 49 52
*/
d203 1
a203 1
PRIVATE int set_clicked_link ARGS4(
d206 1
a206 2
    int,	code,
    int,	clicks)
d214 1
a214 4
    if (y == (LYlines-1) || y == 0) {	/* First or last row */
	/* XXXX In fact # is not always at x==0?  KANJI_CODE_OVERRIDE? */
	int toolbar = (y == 0 && HText_hasToolbar(HTMainText));

d216 4
a219 42
	if (x == 0 && toolbar)		/* On '#' */
	    c = LAC_TO_LKC0(LYK_TOOLBAR);
#if defined(CAN_CUT_AND_PASTE) && defined(USE_COLOR_STYLE)
	else if (y == 0 && x == LYcols - 1 && s_hot_paste != NOSTYLE)
	    c = LAC_TO_LKC0(LYK_PASTE_URL);
#endif
	else if (clicks > 1) {
	    if (x < left + toolbar)
		c = (code==FOR_PROMPT && y)
		    ? HOME : LAC_TO_LKC0(LYK_MAIN_MENU);
	    else if (x > right)
		c = (code==FOR_PROMPT && y)
		    ? END_KEY : LAC_TO_LKC0(LYK_VLINKS);
	    else if (y)			/* Last row */
		c = LAC_TO_LKC0(LYK_END);
	    else			/* First row */
		c = LAC_TO_LKC0(LYK_HOME);
	} else {
	    if (x < left + toolbar)
		c = (code==FOR_PROMPT && y)
		    ? LTARROW
		    : (
#ifdef USE_COLOR_STYLE
			(s_forw_backw != NOSTYLE && x - toolbar >= 3)
			? LAC_TO_LKC0(LYK_NEXT_DOC)
			: LAC_TO_LKC0(LYK_PREV_DOC)
#else
			LAC_TO_LKC0(LYK_NEXT_DOC)
#endif
			);
	    else if (x > right)
		c = (code==FOR_PROMPT && y)
		    ? RTARROW : LAC_TO_LKC0(LYK_HISTORY);
	    else if (y)			/* Last row */
		c = LAC_TO_LKC0(LYK_NEXT_PAGE);
	    else			/* First row */
		c = LAC_TO_LKC0(LYK_PREV_PAGE);
	}
#ifdef USE_SCROLLBAR
    } else if (x == LYcols - 1 && LYShowScrollbar && LYsb_begin >= 0) {
	int h = display_lines - 2*(LYsb_arrow != 0);

d221 3
a223 22
	y -= 1 + (LYsb_arrow != 0);
	if (y < 0)
	    return LAC_TO_LKC0(LYK_UP_TWO);
	if (y >= h)
	    return LAC_TO_LKC0(LYK_DOWN_TWO);

	if (clicks >= 2) {
	    double frac = (1. * y)/(h - 1);
	    int l = HText_getNumOfLines() + 1;	/* NOL() off by one? */

	    l -= display_lines;
	    if (l > 0)
		LYSetNewline((int)(frac * l + 1 + 0.5));
	    return LYReverseKeymap(LYK_DO_NOTHING);
	}

	if (y < LYsb_begin)
	    return LAC_TO_LKC0(LYK_PREV_PAGE);
	if (y >= LYsb_end)
	    return LAC_TO_LKC0(LYK_NEXT_PAGE);
	mouse_link = -1;		/* No action in edit fields */
#endif
d225 1
a225 2
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */
	    cur_err;
a229 2
	    int count = 0;
	    char *text = LYGetHiliteStr(i, count);
d232 3
a234 1
		&& F_TEXTLIKE(links[i].l_form->type))
d237 5
d243 1
a243 5
	    if (text != NULL) {
		if (is_text)
		    len = links[i].l_form->size;
		else
		    len = strlen(text);
a244 13
		/* Check the second line */
		while (cur_err > 0
		   && (text = LYGetHiliteStr(i, ++count)) != NULL) {
		    /* Note that there is at most one hightext if is_text */
		    int cur_err_2 = XYdist(x, y,
					   LYGetHilitePos(i, count),
					   links[i].ly + count,
					   strlen(text));
		    cur_err = HTMIN(cur_err, cur_err_2);
		}
		if (cur_err > 0 && is_text)
		    cur_err--;	/* a bit of preference for text fields,
				   enter field if hit exactly at end - kw */
a248 16
		    /* double-click, if we care:
		       submit text submit fields. - kw */
		    if (clicks > 1 && is_text &&
			links[i].l_form->type == F_TEXT_SUBMIT_TYPE) {
			if (code != FOR_INPUT
			    /* submit current input field directly */
			    || !(cury == y && (curx >= lx) && ((curx - lx) <= len))) {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = i;
			} else {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = -1;
			}
			mouse_err = 0;
			break;
		    }
d252 1
a252 1
			if (is_text) {
a253 5
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
			    if (x == links[i].lx && y == links[i].ly)
				textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
			}
d264 15
d286 4
a289 18
	    if (mouse_err == 0) {
		if (c == -1)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
	    } else if (mouse_err >= 0)
		c = LAC_TO_LKC0(LYK_CHANGE_LINK);
	}
	else {
	   if (2*y > LYlines){		/* Bottom Half of the screen */
	      if (4*y < 3*LYlines){
		c = LAC_TO_LKC0(LYK_DOWN_TWO);	/* Third quarter */
	      } else
		c = LAC_TO_LKC0(LYK_DOWN_HALF);	/* Fourth quarter */
	   } else {			/* Upper Half of the screen */
	      if (4*y < LYlines){
		c = LAC_TO_LKC0(LYK_UP_HALF);	/* First quarter */
	      } else
		c = LAC_TO_LKC0(LYK_UP_TWO);	/* Second quarter */
	   }
d294 16
a309 1
#endif /* USE_MOUSE */
d316 1
a316 1
	char *,		dst,
d338 2
a339 2
#define IS_NEW_GLYPH(ch) (utf_flag && (UCH(ch)&0xc0) != 0x80)
#define IS_UTF_EXTRA(ch) (utf_flag && (UCH(ch)&0xc0) == 0x80)
d349 1
a349 1
	char *,		dst,
d383 1
a383 1
	char *,		data,
a411 4
 *  Counts glyph cells if count_gcells is set. (Full-width
 *  characters in CJK mode count as two.)
 *  Counts character glyphs if count_gcells is unset. (Full-
 *  width characters in CJK mode count as one.) - kw
d413 3
a415 4
PUBLIC int LYmbcsstrlen ARGS3(
	char *,		str,
	BOOL,		utf_flag,
	BOOL,		count_gcells)
d419 1
a419 1
    if (!non_empty(str))
d437 2
a438 2
	} else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
		   is8bits(str[i]) && str[(i + 1)] != '\0' &&
a459 3
#ifdef __CYGWIN__
#define GetChar SLkp_getkey
#else
a460 1
#endif /* __CYGWIN__ */
d466 1
a466 31
#define GetChar() wgetch(LYtopwindow())
#endif

#if !defined(GetChar) && defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* PDCurses sends back key-modifiers that we don't use, but would waste time
 * upon, e.g., repainting the status line
 */
PRIVATE int myGetChar NOARGS
{
    int c;
    BOOL done = FALSE;

    do {
	switch (c = wgetch(LYwin))
	{
	case KEY_SHIFT_L :
	case KEY_SHIFT_R :
	case KEY_CONTROL_L :
	case KEY_CONTROL_R :
	case KEY_ALT_L :
	case KEY_ALT_R :
	case KEY_RESIZE :
	    break;
	default:
	    done = TRUE;
	    break;
	}
    } while (!done);
    return c;
}
#define GetChar() myGetChar()
d470 1
a470 1
#define GetChar() wgetch(LYwin)
d478 2
a479 2
#ifdef HAVE_KEYPAD
#define GetChar() getch()
d488 18
a505 1
#if defined(USE_SLANG) && defined(USE_MOUSE)
d525 2
a526 10
    *x = SLang_getkey ();
    if (*x == CH_ESC)		/* Undo 7-bit replace for large x - kw */
	*x = SLang_getkey () + 64 - 33;
    else
	*x -= 33;
    *y = SLang_getkey ();
    if (*y == CH_ESC)		/* Undo 7-bit replace for large y - kw */
	*y = SLang_getkey () + 64 - 33;
    else
	*y -= 33;
d530 1
a530 2
PRIVATE int sl_read_mouse_event ARGS1(
    int,	code)
d538 1
a538 4
	  return set_clicked_link (mouse_x, mouse_y, FOR_PANEL, 1);

	if (button == 1)  /* middle */
	  return LYReverseKeymap (LYK_VIEW_BOOKMARK);
d549 1
a549 4
   if (code == FOR_INPUT || code == FOR_PROMPT)
       return DO_NOTHING;
   else
       return -1;
d551 1
a551 2
#endif  /* USE_SLANG and USE_MOUSE */

d565 2
a566 2
#define expand_substring(dst, first, last, final) \
	(SLexpand_escaped_string(dst, (char *)first, (char *)last), 1)
d569 1
a569 1
#define MOUSE_KEYSYM 0x0400
d572 1
d584 1
a584 6
# ifdef VMS
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx}
# else
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx},{string1,lynx}
# endif
# define INTERN_KEY(string,lynx,curses)          {string,lynx}
d586 1
a586 2
#define INTERN_KEY(string,lynx,curses)           {string,curses}
#define EXTERN_KEY(string,string1,lynx,curses)   {string,curses}
a588 1

d598 16
a613 16
    INTERN_KEY( "UPARROW",	UPARROW,	KEY_UP ),
    INTERN_KEY( "DNARROW",	DNARROW,	KEY_DOWN ),
    INTERN_KEY( "RTARROW",	RTARROW,	KEY_RIGHT ),
    INTERN_KEY( "LTARROW",	LTARROW,	KEY_LEFT ),
    INTERN_KEY( "PGDOWN",	PGDOWN,		KEY_NPAGE ),
    INTERN_KEY( "PGUP",		PGUP,		KEY_PPAGE ),
    INTERN_KEY( "HOME",		HOME,		KEY_HOME ),
    INTERN_KEY( "END",		END_KEY,	KEY_END ),
    INTERN_KEY( "F1",		F1,		KEY_F(1) ),
    INTERN_KEY( "DO_KEY",	DO_KEY,		KEY_F(16) ),
    INTERN_KEY( "FIND_KEY",	FIND_KEY,	KEY_FIND ),
    INTERN_KEY( "SELECT_KEY",	SELECT_KEY,	KEY_SELECT ),
    INTERN_KEY( "INSERT_KEY",	INSERT_KEY,	KEY_IC ),
    INTERN_KEY( "REMOVE_KEY",	REMOVE_KEY,	KEY_DC ),
    INTERN_KEY( "DO_NOTHING",	DO_NOTHING,	DO_NOTHING|LKC_ISLKC ),
    INTERN_KEY( NULL,		-1,		ERR )
d631 1
a631 1
PRIVATE CONST char *expand_tiname (CONST char *first, size_t len, char **result, char *final)
d641 1
a641 1
	    LYstrncpy(*result, cur_term->type.Strings[code], final - *result);
d648 1
a648 1
PRIVATE CONST char *expand_tichar (CONST char *first, char **result, char *final)
d679 6
a684 6
	char *last = 0;
	char tmp[80];
	LYstrncpy(tmp, first, limit);
	value = strtol(tmp, &last, radix);
	if (last != 0 && last != tmp)
	    first += (last - tmp);
d688 1
a688 1
	(void) expand_tiname(name, strlen(name), result, final);
d697 1
a697 1
PRIVATE int expand_substring (char* dst, CONST char* first, CONST char* last, char *final)
a699 1

d703 1
a703 1
	    first = expand_tichar(first, &dst, final);
d708 1
a708 2
		CONST char *s = strchr(first, RPAREN);
		char *was = dst;
d711 1
a711 3
		first = expand_tiname(first, s-first, &dst, final);
		if (dst == was)
		    return 0;
a731 1
    return 1;
d735 1
a735 1
PRIVATE void unescaped_char ARGS2(CONST char*, parse, int*,keysym)
d741 1
a741 1
	expand_substring(buf, parse + 1, parse + len - 1, buf + sizeof(buf) - 1);
d747 1
a747 1
PRIVATE BOOLEAN unescape_string ARGS3(char*, src, char *, dst, char *, final)
d759 4
a762 2
    } else if (*src == DQUOTE)
	ok = expand_substring(dst, src + 1, src + strlen(src) - 1, final);
d766 1
a766 1
PUBLIC int map_string_to_keysym ARGS2(CONST char*, str, int*,keysym)
a767 1
    int modifier = 0;
a769 45
    if (strncasecomp(str, "LAC:", 4) == 0) {
	char *other = strchr(str+4, ':');

	if (other) {
	   int othersym = lecname_to_lec(other + 1);
	   char buf[BUFSIZ];

	   if (othersym >= 0 && other - str - 4 < BUFSIZ ) {
		strncpy(buf, str + 4, other - str - 4);
		buf[other - str - 4] = '\0';
		*keysym = lacname_to_lac(buf);
		if (*keysym >= 0) {
		    *keysym = LACLEC_TO_LKC0(*keysym, othersym);
		    return (*keysym);
		}
	   }
	}
	*keysym = lacname_to_lac(str + 4);
	if (*keysym >= 0) {
	    *keysym = LAC_TO_LKC0(*keysym);
	    return (*keysym);
	}
    }
    if (strncasecomp(str, "Meta-", 5) == 0) {
	str += 5;
	modifier = LKC_MOD2;
	if (*str) {
	    size_t len = strlen(str);
	    if (len == 1)
		return (*keysym = (UCH(str[0]))|modifier);
	    else if (len == 2 && str[0] == '^' &&
		     (isalpha(UCH(str[1])) ||
		      (TOASCII(str[1]) >= '@@' && TOASCII(str[1]) <= '_')))
		return (*keysym = FROMASCII(UCH(str[1]&0x1f))|modifier);
	    else if (len == 2 && str[0] == '^' &&
		     str[1] == '?')
		return (*keysym = CH_DEL|modifier);
	    if (*str == '^' || *str == '\\') {
		char buf[BUFSIZ];
		expand_substring(buf, str, str + HTMIN(len, 28), buf + sizeof(buf) - 1);
		if (strlen(buf) <= 1)
		    return (*keysym = (UCH(buf[0]))|modifier);
	    }
	}
    }
d772 1
a772 1
    } else if (isdigit(UCH(*str))) {
d775 1
a775 1
	if (!isalnum(UCH(*tmp))) {
a776 5
#ifndef USE_SLANG
	    if (*keysym > 255)
		*keysym |= LKC_ISLKC; /* caller should remove this flag - kw */
#endif
	}
a789 2
    if (*keysym >= 0)
	*keysym |= modifier;
d815 1
a815 1
	} else if (isspace(UCH(*parse))) {
a832 1
    CTRACE((tfp, "KEYMAP(PA): in=%s", parse));	/* \n-terminated */
d834 1
a834 1
	if (isspace(UCH(*s))) {
d837 1
a837 2
	    if ((t = skip_keysym(s)) == 0) {
		CTRACE((tfp, "KEYMAP(SKIP) no key expansion found\n"));
a838 1
	    }
d841 2
a842 10
	    if (map_string_to_keysym (s, &keysym) >= 0) {
		if (!unescape_string(parse, buf, buf + sizeof(buf) - 1)) {
		    CTRACE((tfp, "KEYMAP(SKIP) could unescape key\n"));
		    return 0;		/* Trace the failure and continue. */
		}
		if (LYTraceLogFP == 0) {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x\n", keysym));
		} else {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x, seq='%s'\n", keysym, buf));
		}
a844 3
	    else {
		CTRACE((tfp, "KEYMAP(SKIP) could not map to keysym\n"));
	    }
a845 6
	else {
	    CTRACE((tfp, "KEYMAP(SKIP) junk after key description: '%s'\n", s));
	}
    }
    else {
	CTRACE((tfp, "KEYMAP(SKIP) no key description\n"));
d897 1
d907 3
a909 1
    while (LYSafeGets(&line, fp) != 0) {
d919 7
a925 4

	    if ( strlen(s) > len && !strncmp(s, table[n].name, len)
		 && (*(table[n].func))(LYSkipBlanks(s+len)) < 0 )
		fprintf (stderr, FAILED_READING_KEYMAP, linenum, file);
d929 7
a935 2
    LYCloseInput (fp);
    return 0;
d941 20
a960 37
	INTERN_KEY( "\033[A",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033OA",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033[B",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033OB",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033[C",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033OC",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033[D",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033OD",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033[1~",	FIND_KEY,	KEY_FIND ),
	INTERN_KEY( "\033[2~",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\033[3~",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\033[4~",	SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY( "\033[5~",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\033[6~",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\033[7~",	HOME,		KEY_HOME),
	INTERN_KEY( "\033[8~",	END_KEY,	KEY_END ),
	INTERN_KEY( "\033[11~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[28~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[29~",	DO_KEY,		KEY_F(16) ),
#if defined(USE_SLANG) && !defined(VMS)
	INTERN_KEY(	"^(ku)", UPARROW,	KEY_UP ),
	INTERN_KEY(	"^(kd)", DNARROW,	KEY_DOWN ),
	INTERN_KEY(	"^(kr)", RTARROW,	KEY_RIGHT ),
	INTERN_KEY(	"^(kl)", LTARROW,	KEY_LEFT ),
	INTERN_KEY(	"^(@@0)", FIND_KEY,	KEY_FIND ),
	INTERN_KEY(	"^(kI)", INSERT_KEY,	KEY_IC ),
	INTERN_KEY(	"^(kD)", REMOVE_KEY,	KEY_DC ),
	INTERN_KEY(	"^(*6)", SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY(	"^(kP)", PGUP,		KEY_PPAGE ),
	INTERN_KEY(	"^(kN)", PGDOWN,	KEY_NPAGE ),
	INTERN_KEY(	"^(@@7)", END_KEY,	KEY_END ),
	INTERN_KEY(	"^(kh)", HOME,		KEY_HOME),
	INTERN_KEY(	"^(k1)", F1,		KEY_F(1) ),
	INTERN_KEY(	"^(F6)", DO_KEY,	KEY_F(16) ),
#endif /* SLANG && !VMS */
d964 1
a964 1
	define_key(table[n].string, table[n].value);
a972 5
    /* The escape sequences may contain embedded termcap strings.  Make
     * sure the library is initialized for that.
     */
    SLtt_get_terminfo();

d986 4
a989 2
    if (SLang_Error)
	SLang_exit_error ("Unable to initialize keymaps");
d992 1
a993 1
    return read_keymap_file();
d998 2
a999 3

#if defined(USE_MOUSE) && (defined(NCURSES))
PRIVATE int LYmouse_menu ARGS4(int, x, int, y, int, atlink, int, code)
d1001 58
a1058 33
#define ENT_ONLY_DOC	1
#define ENT_ONLY_LINK	2
    static const struct {
	char *txt;
	int  action;
	unsigned int  flag;
    } possible_entries[] = {
	{"Quit",			LYK_ABORT,		ENT_ONLY_DOC},
	{"Home page",			LYK_MAIN_MENU,		ENT_ONLY_DOC},
	{"Previous document",		LYK_PREV_DOC,		ENT_ONLY_DOC},
	{"Beginning of document",	LYK_HOME,		ENT_ONLY_DOC},
	{"Page up",			LYK_PREV_PAGE,		ENT_ONLY_DOC},
	{"Half page up",		LYK_UP_HALF,		ENT_ONLY_DOC},
	{"Two lines up",		LYK_UP_TWO,		ENT_ONLY_DOC},
	{"History",			LYK_HISTORY,		ENT_ONLY_DOC},
	{"Help",			LYK_HELP,		0},
	{"Do nothing (refresh)",	LYK_REFRESH,		0},
	{"Load again",			LYK_RELOAD,		ENT_ONLY_DOC},
	{"Edit Doc URL and load",	LYK_ECGOTO,		ENT_ONLY_DOC},
	{"Edit Link URL and load",	LYK_ELGOTO,		ENT_ONLY_LINK},
	{"Show info",			LYK_INFO,		0},
	{"Search",			LYK_WHEREIS,		ENT_ONLY_DOC},
	{"Print",			LYK_PRINT,		ENT_ONLY_DOC},
	{"Two lines down",		LYK_DOWN_TWO,		ENT_ONLY_DOC},
	{"Half page down",		LYK_DOWN_HALF,		ENT_ONLY_DOC},
	{"Page down",			LYK_NEXT_PAGE,		ENT_ONLY_DOC},
	{"End of document",		LYK_END,		ENT_ONLY_DOC},
	{"Bookmarks",			LYK_VIEW_BOOKMARK,	ENT_ONLY_DOC},
	{"Cookie jar",			LYK_COOKIE_JAR,		ENT_ONLY_DOC},
	{"Search index",		LYK_INDEX_SEARCH,	ENT_ONLY_DOC},
	{"Set Options",			LYK_OPTIONS,		ENT_ONLY_DOC},
	{"Activate this link",		LYK_SUBMIT,		ENT_ONLY_LINK},
	{"Download",			LYK_DOWNLOAD,		ENT_ONLY_LINK}
d1060 8
a1067 15
#define TOTAL_MENUENTRIES	TABLESIZE(possible_entries)
    char *choices[TOTAL_MENUENTRIES + 1];
    int actions[TOTAL_MENUENTRIES];

    int c, c1, retlac, filter_out = (atlink ? ENT_ONLY_DOC : ENT_ONLY_LINK);

    c = c1 = 0;
    while (c < (int) TOTAL_MENUENTRIES) {
	if (!(possible_entries[c].flag & filter_out)) {
	    choices[c1] = possible_entries[c].txt;
	    actions[c1++] = possible_entries[c].action;
	}
	c++;
    }
    choices[c1] = NULL;
d1071 5
a1075 16
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x-5 : 1),
		     choices, c1, FALSE, TRUE);

    /*
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
     */
    if (term_options) {
	retlac = LYK_DO_NOTHING;
	term_options = FALSE;
    } else {
	retlac = actions[c];
    }
d1077 1
a1077 38
    if (code == FOR_INPUT && mouse_link == -1) {
	switch (retlac) {
	    case LYK_ABORT:
		retlac = LYK_QUIT; /* a bit softer... */
		/* fall through */
	    case LYK_MAIN_MENU:
	    case LYK_PREV_DOC:
	    case LYK_HOME:
	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_HISTORY:
	    case LYK_HELP:
/*	    case LYK_REFRESH:*/
	    case LYK_RELOAD:
	    case LYK_ECGOTO:
	    case LYK_INFO:
	    case LYK_WHEREIS:
	    case LYK_PRINT:
	    case LYK_DOWN_TWO:
	    case LYK_DOWN_HALF:
	    case LYK_NEXT_PAGE:
	    case LYK_END:
	    case LYK_VIEW_BOOKMARK:
	    case LYK_COOKIE_JAR:
	    case LYK_INDEX_SEARCH:
	    case LYK_OPTIONS:
		mouse_link = -3; /* so LYgetch_for() passes it on - kw */
	}
    }
    if (retlac == LYK_DO_NOTHING ||
	retlac == LYK_REFRESH) {
	mouse_link = -1;	/* mainloop should not change cur link - kw */
    }
    if (code == FOR_INPUT && retlac == LYK_DO_NOTHING) {
	repaint_main_statusline(FOR_INPUT);
    }
    return retlac;
d1079 1
a1079 2
#endif /* USE_MOUSE && (NCURSES || PDCURSES) */

a1081 3
/************************************************************************/

PRIVATE int current_sl_modifier = 0;
d1086 1
a1086 4
    int i = GetChar();
    if (i == 0)			/* trick to get NUL char through - kw */
	current_sl_modifier = LKC_ISLKC;
    return i;
d1089 1
a1089 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
a1092 1
   current_sl_modifier = 0;
d1096 1
a1096 1
     return (current_sl_modifier ? 0 : DO_NOTHING);
d1100 1
a1100 1
#if defined (USE_MOUSE)
d1102 1
a1102 1
     return sl_read_mouse_event (code);
d1105 2
a1106 2
   if (keysym < 0)
       return 0;
d1108 2
a1109 2
   if (keysym & (LKC_ISLECLAC|LKC_ISLAC))
       return (keysym);
d1111 4
a1114 10
   current_sl_modifier = 0;
   if (LKC_HAS_ESC_MOD(keysym)) {
       current_sl_modifier = LKC_MOD2;
       keysym &= LKC_MASK;
   }

   if (keysym+1 >= KEYMAP_SIZE)
     return 0;

   return (keysym|current_sl_modifier);
a1116 1
/************************************************************************/
a1118 1

d1124 7
a1130 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
a1132 2
    int current_modifier = 0;
    BOOLEAN done_esc = FALSE;
d1136 1
d1138 1
a1138 4
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
    if (errno == EINTR)
	set_errno(0);		/* reset - kw */
#endif  /* UCX && VAXC */
a1143 1
    lynx_nl2crlf(FALSE);
a1146 1
	lynx_nl2crlf(FALSE);
d1156 1
a1156 2
	    CTRACE((tfp, "GETCH: Translate ^C to ^G.\n"));
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
a1160 45
    CTRACE((tfp, "GETCH: Got %#x.\n", c));
#ifdef MISC_EXP
    if (LYNoZapKey > 1 && errno != EINTR &&
	(c == EOF
#ifdef USE_SLANG
	 || (c == 0xFFFF)
#endif
	    )) {
	int fd, kbd_fd;
	CTRACE((tfp,
		"nozap: Got EOF, curses %s, stdin is %p, LYNoZapKey reduced from %d to 0.\n",
		LYCursesON ? "on" : "off", stdin, LYNoZapKey));
	LYNoZapKey = 0;		/* 2 -> 0 */
	if ((fd = fileno(stdin)) == 0 && !isatty(fd) &&
	    (kbd_fd = LYConsoleInputFD(FALSE)) == fd) {
	    char *term_name;
	    int new_fd = INVSOC;
	    if ((term_name = ttyname(fileno(stdout))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC &&
		(term_name = ttyname(fileno(stderr))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC) {
		term_name = ctermid(NULL);
		new_fd = open(term_name, O_RDONLY);
	    }
	    CTRACE((tfp, "nozap: open(%s) returned %d.\n", term_name, new_fd));
	    if (new_fd >= 0) {
		FILE *frp;
		close(new_fd);
		frp = freopen(term_name, "r", stdin);
		CTRACE((tfp,
		"nozap: freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
			term_name, frp, stdin, fileno(stdin)));
		if (LYCursesON) {
		    stop_curses();
		    start_curses();
		    LYrefresh();
		}
		goto re_read;
	    }
	}
    }
#endif /* MISC_EXP */

a1163 19
#else
    if (c == EOF && errno == EINTR) {

#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		  recent_sizechange));
	   if (!recent_sizechange) { /* not yet detected by ourselves */
	       size_change(0);
	       CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	   }
#else /* HAVE_SIZECHANGE || USE_SLANG */
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		  recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
	set_errno(0);		/* reset - kw */
#endif  /* UCX && VAXC */
	return(DO_NOTHING);
    }
d1174 1
a1174 1
	return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1176 1
a1176 1
#else  /* not USE_SLANG: */
d1179 1
a1179 1
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1193 1
a1193 1
	exit_immediately(EXIT_SUCCESS);
d1197 1
a1197 4
    if (!escape_bound
	&& (c == CH_ESC || (csi_is_csi && c == UCH(CH_ESC_PAR)))) {
	/* handle escape sequence  S/390 -- gil -- 2024 */
	done_esc = TRUE;		/* Flag: we did it, not keypad() */
d1208 1
d1210 1
d1212 1
d1214 5
a1218 8
	case 'q': c = END_KEY; break;	/* vt100 application keypad 1 */
	case 'r': c = DNARROW; break;	/* vt100 application keypad 2 */
	case 's': c = PGDOWN;  break;	/* vt100 application keypad 3 */
	case 't': c = LTARROW; break;	/* vt100 application keypad 4 */
	case 'v': c = RTARROW; break;	/* vt100 application keypad 6 */
	case 'w': c = HOME;    break;	/* vt100 application keypad 7 */
	case 'x': c = UPARROW; break;	/* vt100 application keypad 8 */
	case 'y': c = PGUP;    break;	/* vt100 application keypad 9 */
d1220 1
a1220 1
#if defined(USE_SLANG) && defined(USE_MOUSE)
d1223 1
a1223 1
		c = sl_read_mouse_event (code);
d1227 1
a1227 1
	     c = '\n';		/* keypad enter on pc ncsa telnet */
d1234 1
a1234 1
		c = '-';	/* keypad on pc ncsa telnet */
d1238 1
a1238 3
		c = '+';	/* keypad + on my xterminal :) */
	    else
		done_esc = FALSE; /* we have another look below - kw */
d1244 1
a1244 1
		c = '+';	/* keypad on pc ncsa telnet */
d1256 1
a1256 1
		c = F1;		/* macintosh help button */
d1262 1
a1262 1
		c = '0';	/* keypad 0 */
d1264 1
a1264 1
	case '1':		/** VTxxx  Find  **/
a1266 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1282 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1286 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1290 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1294 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1298 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1305 1
	    /* FALLTHRU */
d1307 1
a1307 8
	    if (c == CH_ESC && a == b && !found_CSI(c,b)) {
		current_modifier = LKC_MOD2;
		c = a;
		/* We're not yet done if ESC + curses-keysym: */
		done_esc = (BOOL) ((a & ~0xFF) == 0);
		break;
	    }
	    CTRACE((tfp,"Unknown key sequence: %d:%d:%d\n",c,b,a));
a1312 9
	if (!done_esc && (a & ~0xFF) == 0) {
	    if (a == b && !found_CSI(c,b) && c == CH_ESC) {
		current_modifier = LKC_MOD2;
		c = a;
		done_esc = TRUE;
	    } else {
		done_esc = TRUE;
	    }
	}
d1314 2
a1315 21
#ifdef USE_KEYMAPS
    /* Extract a single code if two are merged: */
    if (c >= 0 && (c&LKC_ISLECLAC)) {
	if (!(code == FOR_INPUT || code == FOR_PROMPT))
	    c = LKC2_TO_LKC(c);
    } else if (c >= 0 && (c&LKC_ISLKC)) {
	c &= ~LKC_ISLKC;
	done_esc = TRUE; /* already a lynxkeycode, skip keypad switches - kw */
    }
    if (c >= 0 && LKC_HAS_ESC_MOD(c)) {
	current_modifier = LKC_MOD2;
	c &= LKC_MASK;
    }
    if (c >= 0 && (c&(LKC_ISLECLAC|LKC_ISLAC))) {
	done_esc = TRUE; /* already a lynxactioncode, skip keypad switches - iz */
    }
#endif
    if (done_esc) {
	/* don't do keypad() switches below, we already got it - kw */
    } else {
#ifdef HAVE_KEYPAD
d1329 1
a1329 14
	case KEY_RIGHT:		   /* ... */
	   c = RTARROW;
	   break;
#if defined(SH_EX) && defined(DOSPATH)	/* for NEC PC-9800 1998/08/30 (Sun) 21:50:35 */
	case KEY_C2:
	   c = DNARROW;
	   break;
	case KEY_A2:
	   c = UPARROW;
	   break;
	case KEY_B1:
	   c = LTARROW;
	   break;
	case KEY_B3:
a1331 7
	case PAD0:		   /* PC-9800 Ins */
	   c = INSERT_KEY;
	   break;
	case PADSTOP:		   /* PC-9800 DEL */
	   c = REMOVE_KEY;
	   break;
#endif /* SH_EX */
d1335 1
a1335 1
	case KEY_CLEAR:		   /* Clear screen */
d1338 1
a1338 1
	case KEY_NPAGE:		   /* Next page */
d1341 1
a1341 1
	case KEY_PPAGE:		   /* Previous page */
a1346 1
#if defined(KEY_A1) && defined(KEY_C3)
a1365 1
#endif /* defined(KEY_A1) && defined(KEY_C3) */
a1428 48
#ifdef KEY_RESIZE
	case KEY_RESIZE:	   /* size change detected by ncurses */
#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	    /* Make call to detect new size, if that may be implemented.
	     * The call may set recent_sizechange (except for USE_SLANG),
	     * which will tell mainloop() to refresh. - kw
	     */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange so far is %d\n",
		  recent_sizechange));
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
#else /* HAVE_SIZECHANGE || USE_SLANG */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange is %d\n",
		  recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
	    if (!recent_sizechange) {
#if 0			/* assumption seems flawed? */
		/*  Not detected by us or already processed by us.  It can
		 *  happens that ncurses lags behind us in detecting the
		 *  change, since its own SIGTSTP handler is not installed
		 *  so detecting happened *at the end* of the last refresh.
		 *  Tell it to refresh again... - kw
		 */
		LYrefresh();
#endif
#if defined(NCURSES)
		/*
		 * Work-around for scenario (Linux libc5) where we got a
		 * recent sizechange before reading KEY_RESIZE.  If we do
		 * not reset the flag, we'll next get an EOF read, which
		 * causes Lynx to exit.
		 */
		recent_sizechange = TRUE;
#endif
		/*
		 *  May be just the delayed effect of mainloop()'s call
		 *  to resizeterm().  Pretend we haven't read anything
		 *  yet, don't return. - kw
		 */
		goto re_read;
	    }
	    /*
	     *  Yep, we agree there was a change.  Return now so that
	     *  the caller can react to it. - kw
	     */
	    c = DO_NOTHING;
	    break;
#endif /* KEY_RESIZE */
d1433 2
a1434 2
	    c = 0x213;
	    break;
d1436 2
a1437 2
	    c = 0x214;
	    break;
d1439 2
a1440 2
	    c = 0x215;
	    break;
d1442 2
a1443 2
	    c = 0x216;
	    break;
d1445 2
a1446 2
	    c = 0x217;
	    break;
d1448 2
a1449 2
	    c = 0x218;
	    break;
d1451 1
a1451 5

#if defined(USE_MOUSE)
/********************************************************************/

#if defined(NCURSES) || defined(PDCURSES)
a1452 1
	    CTRACE((tfp, "KEY_MOUSE\n"));
d1455 2
a1456 10
	    }
#if defined(NCURSES)
	    else if (code == FOR_SINGLEKEY) {
		MEVENT event;
		getmouse(&event);	/* Completely ignore event - kw */
		c = DO_NOTHING;
	    }
#endif
	    else {
#if defined(NCURSES)
a1458 1
		int lac = LYK_UNKNOWN;
a1462 4
		if (err != OK) {
		    CTRACE((tfp, "Mouse error: no event available!\n"));
		    return(code==FOR_PANEL ? 0 : DO_NOTHING);
		}
d1465 1
a1465 1
		    c = set_clicked_link(event.x, event.y, code, 1);
d1467 7
a1473 3
		    c = set_clicked_link(event.x, event.y, code, 2);
		    if (c == LAC_TO_LKC0(LYK_SUBMIT) && code == FOR_INPUT)
			lac = LYK_SUBMIT;
d1475 1
a1475 10
		    c = LAC_TO_LKC0(LYK_PREV_DOC);
		} else if (code == FOR_PROMPT
				 /* Cannot ignore: see LYCurses.c */
			   || (event.bstate &
				( BUTTON1_PRESSED | BUTTON1_RELEASED
				  | BUTTON2_PRESSED | BUTTON2_RELEASED
				  | BUTTON3_PRESSED | BUTTON3_RELEASED))) {
		    /* Completely ignore - don't return anything, to
		       avoid canceling the prompt - kw */
		    goto re_read;
d1479 2
a1480 2
		    c = set_clicked_link(event.x, event.y, code, 1);
		    atlink = (c == LAC_TO_LKC0(LYK_ACTIVATE));
d1484 5
a1488 11
		    lac = LYmouse_menu(event.x, event.y, atlink, code);
		    if (lac == LYK_SUBMIT) {
			if (mouse_link == -1)
			    lac = LYK_ACTIVATE;
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			else if (mouse_link >= 0 &&
				 textfields_need_activation &&
				 links[mouse_link].type == WWW_FORM_LINK_TYPE &&
				 F_TEXTLIKE(links[mouse_link].l_form->type))
			    lac = LYK_ACTIVATE;
#endif
d1490 1
a1490 6
		    if (lac == LYK_ACTIVATE && mouse_link == -1) {
			HTAlert(gettext("No link chosen"));
			lac = LYK_REFRESH;
		    }
		    c = LAC_TO_LKC(lac);
#if 0	/* Probably not necessary any more - kw */
d1492 1
a1492 2
		    LYrefresh();
#endif
d1494 1
a1494 2
		if (code == FOR_INPUT && mouse_link == -1 &&
		    lac != LYK_REFRESH && lac != LYK_SUBMIT) {
d1496 1
a1496 1
		    wgetch(LYwin);	/* ungetmouse puts KEY_MOUSE back */
a1499 14

#define H_CMD_AREA	6
#define HIST_CMD_2	12
#define V_CMD_AREA	1

		int left = H_CMD_AREA;
		int right = (LYcols - H_CMD_AREA);
		/* yes, I am assuming that my screen will be a certain width. */

		int tick_count;
		char *p = NULL;
		char mouse_info[128];
		static int old_click = 0;	/* [m Sec] */

a1501 12

		if (!system_is_NT) {
		    tick_count = GetTickCount();

		    /* Guard Mouse button miss click */
		    if ((tick_count - old_click) < 700) {
			c = DO_NOTHING;
			break;
		    } else {
			old_click = tick_count;
		    }
		}
d1503 4
a1506 31

		if (BUTTON_STATUS(1) & BUTTON_PRESSED) {
		    if (MOUSE_Y_POS > (LYlines - V_CMD_AREA - 1)) {
			/* Screen BOTTOM */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;	p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;	p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';		p = "Cancel";
			} else {
			    c = PGDOWN;		p = "PGDOWN";
			}
		    } else if (MOUSE_Y_POS < V_CMD_AREA) {
			/* Screen TOP */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;	p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;	p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';		p = "Cancel";
			} else {
			    c = PGUP;		p = "PGUP";
			}
		    } else {
			c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL, 1);
		    }
		}
		if (p && c != -1) {
		    sprintf(mouse_info, "Mouse = 0x%x, [%s]", c, p);
		    SetConsoleTitle(mouse_info);
d1508 1
a1508 3
#endif /* !(WIN_EX) */
		if ((c+1) >= KEYMAP_SIZE && (c&LKC_ISLAC))
		    return(c);
d1511 1
a1511 5
#endif /* NCURSES || PDCURSES */

/********************************************************************/
#endif  /* USE_MOUSE */

d1513 1
d1516 1
d1530 1
a1530 1
	case K_Right:		   /* ... */
d1538 1
a1538 1
	case K_PageDown:	   /* Next page */
d1542 1
a1542 1
	case K_PageUp:		   /* Previous page */
d1574 1
d1576 2
a1577 1
#if defined(USE_SLANG) && (defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(DJGPP_KEYHANDLER)  && !defined(USE_KEYMAPS)
d1588 1
a1588 1
	case SL_KEY_RIGHT:	   /* ... */
d1595 1
a1595 1
	case SL_KEY_NPAGE:	   /* Next page */
d1599 1
a1599 1
	case SL_KEY_PPAGE:	   /* Previous page */
d1617 1
a1618 1
    }
a1619 2
    if (c&(LKC_ISLAC|LKC_ISLECLAC))
	return(c);
d1628 1
a1628 1
	return(c|current_modifier);
a1631 1
/************************************************************************/
a1633 42

PUBLIC int LYgetch NOARGS
{
    return LYReadCmdKey(FOR_PANEL);
}

/*
 * Read a single keystroke, allows mouse-selection.
 */
PUBLIC int LYgetch_choice NOARGS
{
    int ch = LYReadCmdKey(FOR_CHOICE);
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, allows mouse events.
 */
PUBLIC int LYgetch_input NOARGS
{
    int ch = LYReadCmdKey(FOR_INPUT);
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, ignoring case by translating it to uppercase.
 * Ignore mouse events, if any.
 */
PUBLIC int LYgetch_single NOARGS
{
    int ch = LYReadCmdKey(FOR_SINGLEKEY);
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
    else if (ch > 0 && ch < 256)
	ch = TOUPPER(ch);	/* will ignore case of result */
    return ch;
}

d1638 1
a1638 1
	 char *,	arg_buffer)
a1639 1
    register unsigned char *buffer = (unsigned char *) arg_buffer;
a1641 13
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:04:55 */
    {
	if ((buffer[i] & 0x80) != 0
	 && buffer[i+1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOLOWER(buffer[i]));
	}
    }
#else
a1642 1
#endif
d1649 1
a1649 1
	 char *,	arg_buffer)
a1650 1
    register unsigned char *buffer = (unsigned char *) arg_buffer;
d1653 1
a1653 39
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:05:10 */
    {
	if ((buffer[i] & 0x80) != 0
	 && buffer[i+1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOUPPER(buffer[i]));
	}
    }
#else
	buffer[i] = UCH(TOUPPER(buffer[i]));
#endif
}

/*
 * Remove newlines from a string, returning true if we removed any.
 */
PUBLIC BOOLEAN LYRemoveNewlines ARGS1(
	char *,		buffer)
{
    if (buffer != 0) {
	register char* buf = buffer;
	for ( ; *buf && *buf != '\n' && *buf != '\r'; buf++)
	    ;
	if (*buf) {
	    /* runs very seldom */
	    char * old = buf;
	    for ( ; *old; old++) {
		if (*old != '\n' && *old != '\r')
		    *buf++ = *old;
	    }
	    *buf = '\0';
	    return TRUE;
	}
    }
    return FALSE;
d1657 1
a1657 2
 * Remove ALL whitespace from a string (including embedded blanks), and returns
 * a pointer to the end of the trimmed string.
d1659 2
a1660 2
PUBLIC char * LYRemoveBlanks ARGS1(
	char *,		buffer)
d1663 5
a1667 13
	register char* buf = buffer;
	for ( ; *buf && !isspace(UCH(*buf)); buf++)
	    ;
	if (*buf) {
	    /* runs very seldom */
	    char * old = buf;
	    for ( ; *old; old++) {
		if (!isspace(UCH(*old)))
		    *buf++ = *old;
	    }
	    *buf = '\0';
	}
	return buf;
a1668 1
    return NULL;
d1675 1
a1675 1
	char *,		buffer)
d1677 1
a1677 1
    while (isspace(UCH((*buffer))))
d1686 1
a1686 1
	char *,		buffer)
d1688 1
a1688 1
    while (*buffer != 0 && !isspace(UCH((*buffer))))
d1699 1
a1699 1
    while (isspace(UCH((*buffer))))
d1710 1
a1710 1
    while (*buffer != 0 && !isspace(UCH((*buffer))))
d1719 1
a1719 1
	char *,		buffer)
a1726 12
 * Trim trailing newline(s) from a string
 */
PUBLIC char * LYTrimNewline ARGS1(
	char *,		buffer)
{
    size_t i = strlen(buffer);
    while (i != 0 && buffer[i-1] == '\n')
	buffer[--i] = 0;
    return buffer;
}

/*
d1730 1
a1730 1
	char *,		buffer)
d1733 1
a1733 1
    while (i != 0 && isspace(UCH(buffer[i-1])))
a1736 29
/* 1997/11/10 (Mon) 14:26:10, originally string_short() in LYExterns.c, but
 * moved here because LYExterns is not always configured.
 */
PUBLIC char *LYElideString ARGS2(
	char *,		str,
	int,		cut_pos)
{
    char buff[MAX_LINE], *s, *d;
    static char s_str[MAX_LINE];
    int len;

    LYstrncpy(buff, str, sizeof(buff)-1);
    len = strlen(buff);
    if (len > (LYcols - 10)) {
	buff[cut_pos] = '.';
	buff[cut_pos + 1] = '.';
	for (s = (buff + len) - (LYcols - 10) + cut_pos + 1,
	     d = (buff + cut_pos) + 2;
	     s >= buff &&
	     d >= buff &&
	     d < buff + LYcols &&
	     (*d++ = *s++) != 0; )
	    ;
	buff[LYcols] = 0;
    }
    strcpy(s_str, buff);
    return (s_str);
}

d1744 2
a1745 2
    if (isLYNXEXEC(buffer) ||
	isLYNXPROG(buffer)) {
d1764 1
a1764 1
	char **,		buffer)
d1766 1
a1766 1
    if (!LYTrimStartfile(*buffer)) {
d1770 1
a1770 1
    }
d1777 1
a1777 1
	char *,		buffer)
d1780 1
a1780 1
	LYRemoveBlanks(buffer);
a1800 7
#ifdef ENHANCED_LINEEDIT
#define Mark	 edit->mark
#endif

#ifdef ENHANCED_LINEEDIT
PRIVATE char killbuffer[1024] = "\0";
#endif
d1804 1
a1804 1
	char *,		old,
a1814 1
    edit->current_modifiers = 0;
d1816 1
a1820 3
#ifdef ENHANCED_LINEEDIT
    Mark = -1;			/* pos=0, but do not show it yet */
#endif
a1837 51
    LYstrncpy(edit->buffer, old, maxstr);
    StrLen = strlen(edit->buffer);
}

#ifdef SUPPORT_MULTIBYTE_EDIT

PRIVATE int prev_pos ARGS2(
	EDREC *,	edit,
	int,		pos)
{
    int i = 0;

    if (pos <= 0)
	return 0;
    if (HTCJK == NOCJK)
	return (pos - 1);
    else {
	while (i < pos - 1) {
	    int c;
	    c = Buf[i];
	    if (is8bits(c) &&
		  !((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c)))) {
		i++;
	    }
	    i++;
	}
	if (i == pos)
	    return (i - 2);
	else
	    return i;
    }
}
#endif /* SUPPORT_MULTIBYTE_EDIT */

#ifdef EXP_KEYBOARD_LAYOUT
static int map_active = 0;
#else
#define map_active 0
#endif

PUBLIC int LYEditInsert ARGS5(
	EDREC *,	edit,
	unsigned char *,s,
	int,		len,
	int,		map,
	BOOL,		maxMessage)
{
    int length = strlen(Buf);
    int remains = MaxLen - (length + len);
    int edited = 0, overflow = 0;

d1839 13
a1851 74
     *  ch is (presumably) printable character.
     */
    if (remains < 0) {
	overflow = 1;
	len = 0;
	if (MaxLen > length)	/* Insert as much as we can */
	    len = MaxLen - length;
	else
	    goto finish;
    }
    Buf[length + len] = '\0';
    for(; length >= Pos; length--)    /* Make room */
	Buf[length + len] = Buf[length];
#ifdef EXP_KEYBOARD_LAYOUT
    if (map < 0)
	map = map_active;
    if (map && LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	int off = Pos;
	unsigned char *e = s + len;
	char *tail = 0;

	while (s < e) {
	    char utfbuf[8];
	    int l = 1;

	    utfbuf[0] = *s;
	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
		UCode_t ucode = LYKbLayouts[current_layout][*s];

		if (ucode > 127) {
		    if (UCConvertUniToUtf8(ucode, utfbuf)) {
			l = strlen(utfbuf);
			remains -= l - 1;
			if (remains < 0) {
			    if (tail)
				strcpy(Buf + off, tail);
			    FREE(tail);
			    len = off;
			    overflow = 1;
			    goto finish;
			}
			if (l > 1 && !tail)
			    StrAllocCopy(tail, Buf + Pos + len);
		    } else
			utfbuf[0] = '?';
		} else
		    utfbuf[0] = UCH(ucode);
	    }
	    strncpy(Buf + off, utfbuf, l);
	    edited = 1;
	    off += l;
	    s++;
	}
	if (tail)
	    strcpy(Buf + off, tail);
	len = off - Pos;
	FREE(tail);
    } else if (map) {
	unsigned char *e = s + len, *t = (unsigned char *)Buf + Pos;

	while (s < e) {
	    int ch;

	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
		ch = UCTransUniChar(LYKbLayouts[current_layout][*s],
				    current_char_set);
		if (ch < 0)
		    ch = '?';
	    } else
		ch = *s;
	    *t = UCH(ch);
	    t++, s++;
	}
	edited = 1;
a1852 23
    else
#endif	/* defined EXP_KEYBOARD_LAYOUT */
	{
	    strncpy(Buf + Pos, (char *) s, len);
	    edited = 1;
	}

  finish:
    Pos += len;
    StrLen += len;
    if (edited)
	edit->dirty = TRUE;
    if (overflow && maxMessage)
	_statusline(MAXLEN_REACHED_DEL_OR_MOV);
#ifdef ENHANCED_LINEEDIT
    if (Mark > Pos)
	Mark += len;
    else if (Mark < -1 - Pos)
	Mark -= len;
    if (Mark >= 0)
	Mark = -1 - Mark;		/* Disable it */
#endif
    return edited;
d1861 1
a1861 2
     *         -ch  if action should be performed outside of line-editing mode
     *	       ch   otherwise
d1865 3
a1867 1
    unsigned char uch;
a1883 1
#ifndef CJK_EX
d1891 8
a1898 3
	if (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97)
	    return(ch);
	/* FALLTHRU */
a1899 6
    case LYE_CHAR:
	uch = UCH(ch);
	LYEditInsert(edit, &uch, 1, map_active, maxMessage);
	return 0;			/* All changes already registered */

    case LYE_C1CHAR:
d1901 1
a1901 7
	 *  ch is the second part (in most cases, a capital letter) of
	 *  a 7-bit replacement for a character in the 8-bit C1 control
	 *  range.
	 *  This is meant to undo transformations like
	 *  0x81 -> 0x1b 0x41 (ESC A) etc. done by slang on Unix and
	 *  possibly some comm programs.  It's an imperfect workaround
	 *  that doesn't work for all such characters.
a1902 4
	ch &= 0xFF;
	if (ch + 64 >= LYlowest_eightbit[current_char_set])
	    ch += 64;

a1903 8
#ifdef ENHANCED_LINEEDIT
	    if (Mark > Pos)
		Mark++;
	    else if (Mark < -1 - Pos)
		Mark--;
	    if (Mark >= 0)
		Mark = -1 - Mark;		/* Disable it */
#endif
d1907 1
a1907 1
	    Buf[Pos] = UCH(ch);
d1909 1
a1909 2
	} else {
	    if (maxMessage) {
a1911 2
	    return(ch);
	}
a1914 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a1922 31
#else /* SUPPORT_MULTIBYTE_EDIT */
	/*
	 *  Backword.
	 *  Definition of word is very naive: 1 or more a/n characters,
	 *  or 1 or more multibyte character.
	 */
	{
	    int pos0;

	    pos0 = prev_pos(edit, Pos);
	    while (Pos &&
		   (HTCJK == NOCJK || !is8bits(Buf[pos0])) &&
		   !isalnum(UCH(Buf[pos0]))) {
		Pos = pos0;
		pos0 = prev_pos(edit, Pos);
	    }
	    if (HTCJK != NOCJK && is8bits(Buf[pos0])) {
		while (Pos && is8bits(Buf[pos0])) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    } else {
		while (Pos
		 && !is8bits(Buf[pos0])
		 && isalnum(UCH(Buf[pos0]))) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    }
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
a1928 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a1932 12
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK && is8bits(Buf[Pos])) {
	    while (is8bits(Buf[Pos]))
		Pos += 2;
	} else {
	    while (!is8bits(Buf[Pos]) && isalnum(Buf[Pos]))
		Pos++;	/* '\0' is not a/n */
	}
	while ((HTCJK == NOCJK || !is8bits(Buf[Pos])) &&
	       !isalnum(UCH(Buf[Pos])) && Buf[Pos])
	    Pos++;
#endif /* SUPPORT_MULTIBYTE_EDIT */
a1939 3
#ifdef ENHANCED_LINEEDIT
	Mark = -1;		/* Do not show the mark */
#endif
d1992 1
a1992 1
    case LYE_DELEL:	/* @@@@@@ */
a2011 4
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (HTCJK != NOCJK && is8bits(Buf[Pos]))
	    Pos++;
#endif
a2018 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2020 6
#ifdef ENHANCED_LINEEDIT
	if (Mark >= 0)
	    Mark = -1 - Mark;		/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark++;
#endif
a2024 23
#else /* SUPPORT_MULTIBYTE_EDIT */
	{
	    int offset = 1;
	    int pos0 = Pos;

	    if (length == 0 || Pos == 0)
		break;
	    if (HTCJK != NOCJK) {
		Pos = prev_pos(edit, pos0);
		offset = pos0 - Pos;
	    } else
		Pos--;
	    for (i = Pos; i < length; i++)
		Buf[i] = Buf[i + offset];
	    i -= offset;
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;		/* Disable it */
	    if (Mark <= -1 - Pos)
		Mark += offset;
#endif
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
a2027 1
    case LYE_FORW_RL:
a2031 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2033 9
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos < length) {
	    Pos++;
	    if (HTCJK != NOCJK && is8bits(Buf[Pos-1]))
		Pos++;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_FORW_RL)
	    return -ch;
a2035 1
    case LYE_BACK_LL:
a2039 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2041 10
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos > 0) {
	    if (HTCJK != NOCJK)
		Pos = prev_pos(edit, Pos);
	    else
		Pos--;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_BACK_LL)
	    return -ch;
d2044 2
a2045 20
#ifdef ENHANCED_LINEEDIT
    case LYE_TPOS:
	/*
	 *  Transpose characters - bash or ksh(emacs not gmacs) style
	 */
	if (length <= 1 || Pos == 0)
	    return(ch);
	if (Pos == length)
	    Pos--;
	if (Mark < 0)
	    Mark = -1 - Mark;		/* Temporary enable it */
	if (Mark == Pos || Mark == Pos+1)
	    Mark = Pos-1;
	if (Mark >= 0)
	    Mark = -1 - Mark;		/* Disable it */
	if (Buf[Pos-1] == Buf[Pos]) {
	    Pos++;
	    break;
	}
	i = Buf[Pos-1]; Buf[Pos-1] = Buf[Pos]; Buf[Pos++] = (char) i;
d2048 2
a2049 77
    case LYE_SETMARK:
	/*
	 *  primitive emacs-like set-mark-command
	 */
	Mark = Pos;
	return(0);

    case LYE_XPMARK:
	/*
	 *  emacs-like exchange-point-and-mark
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;		/* Enable it */
	if (Mark == Pos)
	    return(0);
	i = Pos; Pos = Mark; Mark = i;
	break;

    case LYE_KILLREG:
	/*
	 *  primitive emacs-like kill-region
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;		/* Enable it */
	if (Mark == Pos) {
	    killbuffer[0] = '\0';
	    return(0);
	}
	if (Mark > Pos)
	    LYEdit1(edit, 0, LYE_XPMARK, FALSE);
	{
	    int reglen = Pos - Mark;

	    LYstrncpy(killbuffer, &Buf[Mark],
		      HTMIN(reglen, (int)sizeof(killbuffer)-1));
	    for (i = Mark; Buf[i+reglen]; i++)
		Buf[i] = Buf[i+reglen];
	    Buf[i] = Buf[i+reglen]; /* terminate */
	    Pos = Mark;
	}
	if (Mark >= 0)
	    Mark = -1 - Mark;		/* Disable it */
	break;

    case LYE_YANK:
	/*
	 *  primitive emacs-like yank
	 */
	if (!killbuffer[0]) {
	    Mark = -1 - Pos;
	    return(0);
	}
	{
	    int yanklen = strlen(killbuffer);

	    if (Pos+yanklen <= (MaxLen) && StrLen+yanklen <= (MaxLen)) {
		Mark = -1 - Pos;

		for(i = length; i >= Pos; i--)    /* Make room */
		    Buf[i+yanklen] = Buf[i];
		for (i = 0; i < yanklen; i++)
		    Buf[Pos++] = UCH(killbuffer[i]);

	    } else if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	}
	break;

#endif /* ENHANCED_LINEEDIT */

    case LYE_UPPER:
	LYUpperCase(Buf);
	break;

    case LYE_LOWER:
	LYLowerCase(Buf);
a2059 71
/*
**  This function prompts for a choice or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM & LE
*/
PUBLIC int get_popup_number ARGS3(
	char *,		msg,
	int *,		c,
	int *,		rel)
{
    char temp[120];
    char *p = temp;
    int num;

    /*
     *  Load the c argument into the prompt buffer.
     */
    temp[0] = (char) *c;
    temp[1] = '\0';
    _statusline(msg);

    /*
     *  Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	*rel = '\0';
	return(0);
    }

    *rel = '\0';
    num = atoi(p);
    while ( isdigit(UCH(*p)) )
	++p;
    switch ( *p ) {
    case '+': case '-':
	/* 123+ or 123- */
	*rel = *p++; *c = *p;
	break;
    default:
	*c = *p++;
	*rel = *p;
	break;
    case 0:
	break;
    }

    /*
     *  If we had a 'g' or 'p' suffix, load it into c.
     *  Otherwise, zero c.  Then return the number.
     */
    if ( *p == 'g' || *p == 'G' ) {
	*c = 'g';
    } else if (*p == 'p' || *p == 'P' ) {
	*c = 'p';
    } else {
	*c = '\0';
    }
    if ( *rel != '+' && *rel != '-' )
	*rel = 0;
    return num;
}

#ifdef USE_COLOR_STYLE
#  define TmpStyleOn(s)		curses_style((s), STACK_ON)
#  define TmpStyleOff(s)	curses_style((s), STACK_OFF)
#else
#  define TmpStyleOn(s)
#  define TmpStyleOff(s)
#endif	/* defined USE_COLOR_STYLE */
a2069 7
#ifdef SUPPORT_MULTIBYTE_EDIT
    int begin_multi = 0;
    int end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
#ifdef USE_COLOR_STYLE
    int estyle, prompting = 0;
#endif
d2093 2
a2094 3
    if ((DspStart + DspWdth) <= length) {
	if (Pos >= (DspStart + DspWdth) - Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
a2095 1215
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (HTCJK != NOCJK) {
		int tmp = (Pos - DspWdth) + Margin;

		while (DspStart < tmp) {
		    if (is8bits(Buf[DspStart]))
			DspStart++;
		    DspStart++;
		}
	    } else {
		DspStart = (Pos - DspWdth) + Margin;
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
	}
    }

    if (Pos < DspStart + Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK) {
	    int tmp = Pos - Margin;

	    DspStart = 0;
	    while (DspStart < tmp) {
		if (is8bits(Buf[DspStart]))
		    DspStart++;
		DspStart++;
	    }
	} else {
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
    }

    str = &Buf[DspStart];
#ifdef SUPPORT_MULTIBYTE_EDIT
    if (HTCJK != NOCJK && is8bits(str[0]))
	begin_multi = 1;
#endif /* SUPPORT_MULTIBYTE_EDIT */

    nrdisplayed = length-DspStart;
    if (nrdisplayed > DspWdth)
	nrdisplayed = DspWdth;

    LYmove(edit->sy, edit->sx);
#ifdef USE_COLOR_STYLE
    /*
     *  If this is the last screen line, set attributes to normal,
     *  should only be needed for color styles.  The curses function
     *  may be used directly to avoid complications. - kw
     */
    if (edit->sy == (LYlines - 1))
	prompting = 1;
    if (prompting)
	estyle = s_prompt_edit;
    else
	estyle = s_aedit;
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.getstr: switching to <edit.%s>.\n",
		  prompting ? "prompt" : "active"));
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_ON);
    else
	wattrset(LYwin,A_NORMAL); /* need to do something about colors? */
#endif
    if (edit->hidden) {
	for (i = 0; i < nrdisplayed; i++)
	    LYaddch('*');
    } else {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 && DspStart > Mark)
	    TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	for (i = 0; i < nrdisplayed; i++) {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			       || (DspStart + i == Pos && Pos < Mark) ))
		TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			       || (DspStart + i == Pos && Pos > Mark) ))
		TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	    if ((buffer[0] = str[i]) == 1 || buffer[0] == 2 ||
		(UCH(buffer[0]) == 160 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK ||
		   (LYCharSet_UC[current_char_set].enc != UCT_ENC_8859 &&
		    !(LYCharSet_UC[current_char_set].like8859
		      & UCT_R_8859SPECL))))) {
		LYaddch(' ');
#ifdef SUPPORT_MULTIBYTE_EDIT
		end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    } else {
		/* For CJK strings, by Masanobu Kimura */
		if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    if (i < (nrdisplayed - 1))
			buffer[1] = str[++i];
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = (i < nrdisplayed);
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
		    {
			int ii, yy, xx;

			LYGetYX(yy, xx);
			for (ii = 0; buffer[ii] != '\0'; ++ii)
			    LYaddch(' ');
			LYrefresh();
			LYmove(yy, xx);
		    }
#endif /* USE_SLANG */
#endif /* SUPPORT_MULTIBYTE_EDIT */
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		} else {
		    LYaddstr(buffer);
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
		}
	    }
	}
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 &&
	    ((DspStart + nrdisplayed <= Mark && DspStart + nrdisplayed > Pos)
	     || (DspStart + nrdisplayed > Mark
		 && DspStart + nrdisplayed <= Pos)))
	    TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
    }

    /*
     *	Erase rest of input area.
     */
    padsize = DspWdth-nrdisplayed;
    if (padsize) {
	TmpStyleOn(prompting ? s_prompt_edit_pad : s_aedit_pad);
	while (padsize--)
	    LYaddch(UCH(edit->pad));
	TmpStyleOff(prompting ? s_prompt_edit_pad : s_aedit_pad);
    }

    /*
     *	Scrolling indicators.
     */
    if (edit->panon) {
	if ((DspStart + nrdisplayed) < length) {
	    int add_space = 0;

	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (end_multi)
		add_space = 1;
#endif
	    LYmove(edit->sy, edit->sx + nrdisplayed - 1 - add_space);
	    if (add_space)
		LYaddch(' ');		/* Needed with styles? */
	    LYaddch(ACS_RARROW);
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
	if (DspStart) {
	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
	    LYmove(edit->sy, edit->sx);
	    LYaddch(ACS_LARROW);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (begin_multi)
		LYaddch(' ');		/* Needed with styles? */
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
    }

    LYmove(edit->sy, edit->sx + Pos - DspStart);

#ifdef USE_COLOR_STYLE
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_OFF);
#endif
    LYrefresh();
}

PRIVATE void reinsertEdit ARGS2(
    EditFieldData *,	edit,
    char *,		result)
{
    if (result != 0) {
	LYEdit1(edit, '\0', LYE_ERASE, FALSE);
	while (*result != '\0') {
	    LYLineEdit(edit, (int)(*result), FALSE);
	    result++;
	}
    }
}

PRIVATE int caselessCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
{
    return strcasecomp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
}

PRIVATE int normalCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
{
    return strcmp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
}

PRIVATE char **sortedList ARGS2(
    HTList *,	list,
    BOOL,	ignorecase)
{
    unsigned count = HTList_count(list);
    unsigned j = 0;
    unsigned k, jk;
    char **result = typecallocn(char *, count + 1);

    if (result == 0)
	outofmem(__FILE__, "sortedList");

    while (!HTList_isEmpty(list))
	result[j++] = HTList_nextObject(list);

    if (count > 1) {
	qsort((char *)result, count, sizeof(*result),
	      ignorecase ? caselessCmpList : normalCmpList);

	/* remove duplicate entries from the sorted index */
	for (j = 0; result[j] != 0; j++) {
	    k = j;
	    while (result[k] != 0
	     && !strcmp(result[j], result[k])) {
		k++;
	    }
	    k--;
	    if (j != k) {
		for (jk = j; ; jk++) {
		    result[jk] = result[jk + k - j];
		    if (result[jk] == 0)
			break;
		}
	    }
	}
    }

    return result;
}

PUBLIC int LYarrayLength ARGS1(
    CONST char **,	list)
{
    int result = 0;

    while (*list++ != 0)
	result++;
    return result;
}

PUBLIC int LYarrayWidth ARGS1(
    CONST char **,	list)
{
    int result = 0;
    int check;

    while (*list != 0) {
	check = strlen(*list++);
	if (check > result)
	    result = check;
    }
    return result;
}

PRIVATE void FormatChoiceNum ARGS4(
	char *,		dst,
	int,		num_choices,
	int,		choice,
	CONST char *,	value)
{
    if (num_choices >= 0) {
	int digits = (num_choices > 9) ? 2 : 1;
	sprintf(dst, "%*d: %.*s",
			digits, (choice + 1),
			MAX_LINE - 9 - digits, value);
    } else {
	LYstrncpy(dst, value, MAX_LINE-1);
    }
}

PRIVATE unsigned options_width ARGS1(
	CONST char **,	list)
{
    unsigned width = 0;
    int count = 0;

    while (list[count] != 0) {
	if (strlen(list[count]) > width) {
	    width = strlen(list[count]);
	}
	count++;
    }
    return width;
}

PRIVATE void draw_option ARGS7(
    WINDOW *,		win,
    int,		entry,
    int,		width,
    BOOL,		reversed,
    int,		num_choices,
    int,		number,
    CONST char *,	value)
{
    char Cnum[MAX_LINE];

    FormatChoiceNum(Cnum, num_choices, number, "");
#ifdef USE_SLANG
    SLsmg_gotorc(win->top_y + entry, (win->left_x + 2));
    LYaddstr(Cnum);
    if (reversed)
	SLsmg_set_color(2);
    SLsmg_write_nstring((char *)value, win->width);
    if (reversed)
	SLsmg_set_color(0);
#else
    wmove(win, entry, 1);
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
    LynxWChangeStyle(win, s_menu_number, STACK_ON);
    waddstr(win, Cnum);
    LynxWChangeStyle(win, s_menu_number, STACK_OFF);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_ON);
#else
    if (reversed)
	wstart_reverse(win);
#endif
    LYpaddstr(win, width, value);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_OFF);
#else
    if (reversed)
	wstop_reverse(win);
#endif
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
#endif /* USE_SLANG */
}

/*
 *  This function offers the choices for values of an
 *  option via a popup window which functions like
 *  that for selection of options in a form. - FM
 *
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
 */
PUBLIC int LYhandlePopupList ARGS9(
	int,		cur_choice,
	int,		ly,
	int,		lx,
	CONST char **,	choices,
	int,		width,
	int,		i_length,
	int,		disabled,
	BOOLEAN,	for_mouse,
	BOOLEAN,	numbered)
{
    int c = 0, cmd = 0, i = 0, j = 0, rel = 0;
    int orig_choice;
    WINDOW * form_window;
    int num_choices = 0;
    int max_choices = 0;
    int top, bottom, length = -1;
    int window_offset = 0;
    int lines_to_show;
    char Cnum[64];
    int Lnum;
    int npages;
    static char prev_target[MAX_LINE];		/* Search string buffer */
    static char prev_target_buffer[MAX_LINE];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0, recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN ReDraw = FALSE;
    int number;
    char buffer[MAX_LINE];
    char *popup_status_msg = NULL;
    CONST char **Cptr = NULL;
#define CAN_SCROLL_DOWN	1
#define CAN_SCROLL_UP	2
#define CAN_SCROLL	4
    int can_scroll = 0, can_scroll_was = 0;

    orig_choice = cur_choice;
    if (cur_choice < 0)
	cur_choice = 0;

    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;

    /*
     *	Count the number of choices to be displayed, where
     *	num_choices ranges from 0 to n, and set width to the
     *	longest choice string length.  Also set Lnum to the
     *	length for the highest choice number, then decrement
     *	num_choices so as to be zero-based.  The window width
     *	will be based on the sum of width and Lnum. - FM
     */
    num_choices = LYarrayLength(choices) - 1;
    if (width <= 0)
	width = options_width(choices);
    if (numbered) {
	sprintf(Cnum, "%d: ", num_choices);
	Lnum = strlen(Cnum);
	max_choices = num_choices;
    } else {
	Lnum = 0;
	max_choices = -1;
    }

    /*
     *  Let's assume for the sake of sanity that ly is the number
     *   corresponding to the line the choice is on.
     *  Let's also assume that cur_choice is the number of the
     *   item that should be initially selected, as 0 being the
     *   first item.
     *  So what we have, is the top equal to the current screen line
     *   subtracting the cur_choice + 1 (the one must be for the
     *   top line we will draw in a box).  If the top goes under 0,
     *   consider it 0.
     */
    top = ly - (cur_choice + 1);
    if (top < 0)
	top = 0;

    /*
     *  Check and see if we need to put the i_length parameter up to
     *  the number of real choices.
     */
    if (i_length < 1) {
	i_length = num_choices;
    } else {
	/*
	 *  Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     *  The bottom is the value of the top plus the number of options
     *  to view plus 3 (one for the top line, one for the bottom line,
     *  and one to offset the 0 counted in the num_choices).
     */
    bottom = top + i_length + 3;

    /*
     *  Set lines_to_show based on the user_mode global.
     */
    if (user_mode == NOVICE_MODE)
	lines_to_show = LYlines-4;
    else
	lines_to_show = LYlines-2;

    if (for_mouse && user_mode == NOVICE_MODE && lines_to_show > 2)
	lines_to_show--;

    /*
     *  Hmm...  If the bottom goes beyond the number of lines available,
     */
    if (bottom > lines_to_show) {
	/*
	 *  Position the window at the top if we have more
	 *  choices than will fit in the window.
	 */
	if ((i_length + 3) > lines_to_show) {
	    top = 0;
	    bottom = (top + (i_length + 3));
	    if (bottom > lines_to_show)
		bottom = (lines_to_show + 1);
	} else {
	    /*
	     *  Try to position the window so that the selected choice will
	     *    appear where the selection box currently is positioned.
	     *  It could end up too high, at this point, but we'll move it
	     *    down latter, if that has happened.
	     */
	    top = (lines_to_show + 1) - (i_length + 3);
	    bottom = (lines_to_show + 1);
	}
    }

    /*
     *  This is really fun, when the length is 4, it means 0 to 4, or 5.
     */
    length = (bottom - top) - 2;
    if (length <= num_choices)
	can_scroll = CAN_SCROLL;

    /*
     *  Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > lines_to_show + 1)
	    bottom = lines_to_show + 1;
	top = bottom - length - 2;
    }

    if (for_mouse) {
	/* shift horizontally to lie within screen width, if possible */
	if (Lnum + (int)width + 4 < LYcols) {
	    if (lx - 1 + (Lnum + (int)width + 4) > LYcols)
		lx = LYcols + 1 - (Lnum + width + 4);
	    else if (lx <= 0)
		lx = 1;
	}
    }

    /*
     *  Set up the overall window, including the boxing characters ('*'),
     *  if it all fits.  Otherwise, set up the widest window possible. - FM
     */
    if (num_choices <= 0
     || cur_choice > num_choices
     || (form_window = LYstartPopup(top, lx, bottom - top, Lnum + width)) == 0)
	return(orig_choice);

    /*
     *	Clear the command line and write
     *	the popup statusline. - FM
     */
    LYmove((LYlines - 2), 0);
    LYclrtoeol();
    if (disabled) {
	popup_status_msg = CHOICE_LIST_UNM_MSG;
    } else if (!for_mouse) {
	popup_status_msg = CHOICE_LIST_MESSAGE;
#if defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES))
    } else {
	popup_status_msg = gettext(
		"Left mouse button or return to select, arrow keys to scroll.");
#endif
    }
    _statusline(popup_status_msg);

    /*
     *  Set up the window_offset for choices.
     *   cur_choice ranges from 0...n
     *   length ranges from 0...m
     */
    if (cur_choice >= length) {
	window_offset = cur_choice - length + 1;
    }

    /*
     *  Compute the number of popup window pages. - FM
     */
    npages = ((num_choices + 1) > length) ?
		(((num_choices + 1) + (length - 1))/(length))
					  : 1;
/*
 *  OH!  I LOVE GOTOs! hack hack hack
 */
redraw:

    /*
     *  Display the boxed choices.
     */
    for (i = 0; i <= num_choices; i++) {
	if (i >= window_offset && i - window_offset < length) {
	    draw_option (form_window, ((i + 1) - window_offset), width, FALSE,
			 max_choices, i, choices[i]);
	}
    }
    LYbox(form_window, (BOOLEAN)!numbered);
    Cptr = NULL;

    /*
     *  Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {
	int row = ((i + 1) - window_offset);

	/* Show scroll indicators. */
	if (can_scroll) {
	    can_scroll = ((window_offset ? CAN_SCROLL_UP : 0)
			  | (num_choices - window_offset >= length
			     ? CAN_SCROLL_DOWN : 0));
	    if (~can_scroll & can_scroll_was) {	/* Need to redraw */
		LYbox(form_window, (BOOLEAN)!numbered);
		can_scroll_was = 0;
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_UP) {
		wmove(form_window, 1, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_UARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_DOWN) {
		wmove(form_window, length, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_DARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	}

	/*
	 *  Unreverse cur choice.
	 */
	if (Cptr != NULL) {
	    draw_option (form_window, row, width, FALSE,
			 max_choices, i, Cptr[i]);
	}
	Cptr = choices;
	i = cur_choice;
	row = ((cur_choice + 1) - window_offset);
	draw_option (form_window, row, width, TRUE,
		     max_choices, cur_choice, Cptr[cur_choice]);
	LYstowCursor(form_window, row, 1);

	c = LYgetch_choice();
	if (term_options || LYCharIsINTERRUPT(c)) { /* Control-C or Control-G */
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, row, &cur_choice)) < 0)
		goto redraw;
	    if  (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = LKC_TO_LAC(keymap,c);
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
		/* FALLTHRU */
	    case LYK_1: /* FALLTHRU */
	    case LYK_2: /* FALLTHRU */
	    case LYK_3: /* FALLTHRU */
	    case LYK_4: /* FALLTHRU */
	    case LYK_5: /* FALLTHRU */
	    case LYK_6: /* FALLTHRU */
	    case LYK_7: /* FALLTHRU */
	    case LYK_8: /* FALLTHRU */
	    case LYK_9:
		/*
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
		 */
		number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);

		/* handle + or - suffix */
		CTRACE((tfp,"got popup option number %d, ",number));
		CTRACE((tfp,"rel='%c', c='%c', cur_choice=%d\n",
				rel, c, cur_choice));
		if ( c == 'p' ) {
		    int curpage = ((cur_choice + 1) > length) ?
			(((cur_choice + 1) + (length - 1))/(length))
					  : 1;
		    CTRACE((tfp,"  curpage=%d\n",curpage));
		    if ( rel == '+' )
			number = curpage + number;
		    else if ( rel == '-' )
			number = curpage - number;
		} else if ( rel == '+' ) {
		    number = cur_choice + number + 1;
		} else if ( rel == '-' ) {
		    number = cur_choice - number + 1;
		}
		if ( rel ) CTRACE((tfp,"new number=%d\n",number));
		/*
		 *  Check for a 'p' suffix. - FM
		 */
		if (c == 'p') {
		    /*
		     *  Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = 0;
			cur_choice = 0;
			_statusline(popup_status_msg);
			goto redraw;
		    }

		    /*
		     *  Treat a number equal to or greater than the
		     *  number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_choices - length) + 1)) {
			    HTUserMsg(ALREADY_AT_OPTION_END);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_choices - length)) {
			    window_offset = (num_choices - length + 1);
			}
			if (cur_choice < window_offset)
			    cur_choice = window_offset;
			_statusline(popup_status_msg);
			goto redraw;
		    }

		    /*
		     *  We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
			char *msg = 0;
			HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
			HTUserMsg(msg);
			FREE(msg);
			_statusline(popup_status_msg);
			break;
		    }
		    cur_choice = window_offset = ((number - 1) * length);
		    _statusline(popup_status_msg);
		    goto redraw;

		}

		/*
		 *  Check for a positive number, which signifies
		 *  that a choice should be sought. - FM
		 */
		if (number > 0) {
		    /*
		     *  Decrement the number so as to correspond
		     *  with our cur_choice values. - FM
		     */
		    number--;

		    /*
		     *  If the number is in range and had no legal
		     *  suffix, select the indicated choice. - FM
		     */
		    if (number <= num_choices && c == '\0') {
			cur_choice = number;
			cmd = LYK_ACTIVATE;
			break;
		    }

		    /*
		     *  Verify that we had a 'g' suffix,
		     *  and act on the number. - FM
		     */
		    if (c == 'g') {
			if (cur_choice == number) {
			    /*
			     *  The choice already is current. - FM
			     */
			    char *msg = 0;
			    HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(msg);
			    FREE(msg);
			    _statusline(popup_status_msg);
			    break;
			}

			if (number <= num_choices) {
			    /*
			     *  The number is in range and had a 'g'
			     *  suffix, so make it the current option,
			     *  scrolling if needed. - FM
			     */
			    j = (number - cur_choice);
			    cur_choice = number;
			    if ((j > 0) &&
				(cur_choice - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_choices - length + 1))
				    window_offset = (num_choices - length + 1);
			    } else if ((cur_choice - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    _statusline(popup_status_msg);
			    goto redraw;
			}

			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_OPTION_NUM_ENTERED);
		    }
		}

		/*
		 *  Restore the popup statusline. - FM
		 */
		_statusline(popup_status_msg);
		break;

	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:

		if (cur_choice > 0)
		    cur_choice--;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_LPOS_NEXT_LINK:
	    case LYK_FASTFORW_LINK:
	    case LYK_DOWN_LINK:
		if (cur_choice < num_choices)
		    cur_choice++;

		/*
		 *  Scroll the window down if necessary
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_PAGE:
		/*
		 *  Okay, are we on the last page of the list?
		 *  If not then,
		 */
		if (window_offset != (num_choices - length + 1)) {
		    /*
		     *	Modify the current choice to not be a
		     *  coordinate in the list, but a coordinate
		     *  on the item selected in the window.
		     */
		    cur_choice -= window_offset;

		    /*
		     *  Page down the proper length for the list.
		     *  If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }

		    /*
		     *  Readjust the current selection to be a
		     *  list coordinate rather than window.
		     *  Redraw this thing.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		}
		else if (cur_choice < num_choices) {
		    /*
		     *  Already on last page of the list so just
		     *  redraw it with the last item selected.
		     */
		    cur_choice = num_choices;
		}
		break;

	    case LYK_PREV_PAGE:
		/*
		 *  Are we on the first page of the list?
		 *  If not then,
		 */
		if (window_offset != 0) {
		    /*
		     *  Modify the current selection to not be a
		     *  list coordinate, but a window coordinate.
		     */
		    cur_choice -= window_offset;

		    /*
		     *  Page up the proper length.
		     *  If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }

		    /*
		     *  Readjust the current choice.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		} else if (cur_choice > 0) {
		    /*
		     *  Already on the first page so just
		     *  back up to the first item.
		     */
		    cur_choice = 0;
		}
		break;

	    case LYK_HOME:
		cur_choice = 0;
		if (window_offset > 0) {
		    window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_END:
		cur_choice = num_choices;
		if (window_offset != (num_choices - length + 1)) {
		    window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_DOWN_TWO:
		cur_choice += 2;
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_TWO:
		cur_choice -= 2;
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_DOWN_HALF:
		cur_choice += (length/2);
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_HALF:
		cur_choice -= (length/2);
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;

	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
		    /*
		     *  We got a 'n'ext command with no prior query
		     *  specified within the popup window.  See if
		     *  one was entered when the popup was retracted,
		     *  and if so, assume that's what's wanted.  Note
		     *  that it will become the default within popups,
		     *  unless another is entered within a popup.  If
		     *  the within popup default is to be changed at
		     *  that point, use WHEREIS ('/') and enter it,
		     *  or the up- or down-arrow keys to seek any of
		     *  the previously entered queries, regardless of
		     *  whether they were entered within or outside
		     *  of a popup window. - FM
		     */
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			LYstrncpy(prev_target_buffer, cp, sizeof(prev_target_buffer) - 1);
			QueryNum = 0;
			FirstRecall = FALSE;
		    }
		}
		strcpy(prev_target, prev_target_buffer);
		/* FALLTHRU */
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		}

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
		    /*
		     *  No entry.  Simply break.   - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
			    }
			} else {
			    QueryNum = 0;
			}
		    } else {
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
		    }
		    if (QueryNum >= QueryTotal) {
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *  User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  first query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = 0;
				 QueryNum < (QueryTotal - 1); QueryNum++) {
				if ((cp = (char *)HTList_objectAt(
							    search_queries,
							    QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
					break;
				}
			    }
			} else {
			    QueryNum = (QueryTotal - 1);
			}
		    } else {
			/*
			 *  Advance to the next query in the list. - FM
			 */
			QueryNum--;
		    }
		    if (QueryNum < 0) {
			/*
			 *  Roll around to the first query in the list. - FM
			 */
			QueryNum = (QueryTotal - 1);
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		}
		/*
		 *  Replace the search string buffer with the new target. - FM
		 */
		strcpy(prev_target_buffer, prev_target);
		HTAddSearchQuery(prev_target_buffer);

		/*
		 *  Start search at the next choice. - FM
		 */
		for (j = 1; Cptr[i+j] != NULL; j++) {
		    FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i+j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (Cptr[i+j] != NULL) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    cur_choice += j;
		    /*
		     *  Scroll the window down if necessary.
		     */
		    if ((cur_choice - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_choices - length + 1))
			    window_offset = (num_choices - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}
d2097 5
a2101 7
		/*
		 *  If we started at the beginning, it can't be present. - FM
		 */
		if (cur_choice == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}
d2103 1
a2103 30
		/*
		 *  Search from the beginning to the current choice. - FM
		 */
		for (j = 0; j < cur_choice; j++) {
		    FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_choice) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    j = (cur_choice - j);
		    cur_choice -= j;
		    /*
		     *  Scroll the window up if necessary.
		     */
		    if ((cur_choice - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}
d2105 3
a2107 4
		/*
		 *  Didn't find it in the preceding choices either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
d2109 36
a2144 14
restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		_statusline(popup_status_msg);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
d2146 9
a2154 1
		break;
d2156 11
a2166 7
	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
	    case LYK_INTERRUPT:
		cur_choice = orig_choice;
		cmd = LYK_ACTIVATE; /* to exit */
		break;
a2168 1
    LYstopPopup();
d2170 2
a2171 1
    return(disabled ? orig_choice : cur_choice);
a2173 1
#define CurModif MyEdit.current_modifiers
d2176 1
a2176 1
	char *,		inputline,
d2178 2
a2179 2
	size_t,		bufsize,
	RecallType,	recall)
a2182 3
    int xlec = -2;
    int last_xlec = -1;
    int last_xlkc = -1;
d2184 1
a2184 3
#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d2190 1
a2190 1
    MyEdit.hidden = (BOOL) hidden ;
a2191 1
    CTRACE((tfp, "called LYgetstr\n"));
a2193 1
#ifndef SUPPORT_MULTIBYTE_EDIT
d2195 10
a2204 10
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (refresh_mb)
	    LYRefreshEdit(&MyEdit);
#endif /* SUPPORT_MULTIBYTE_EDIT */
	ch = LYReadCmdKey(FOR_PROMPT);
#ifdef SUPPORT_MULTIBYTE_EDIT
#ifdef CJK_EX	/* for SJIS code */
	if (!refresh_mb
	 && (EditBinding(ch) != LYE_CHAR))
	    goto again;
d2206 1
a2206 11
	if (!refresh_mb
	 && (EditBinding(ch) != LYE_CHAR)
	 && (EditBinding(ch) != LYE_AIX))
	    goto again;
#endif
#endif /* SUPPORT_MULTIBYTE_EDIT */

	if (term_letter || term_options
#ifdef VMS
	      || HadVMSInterrupt
#endif /* VMS */
d2210 2
a2211 3
	      ) {
#ifdef VMS
	    HadVMSInterrupt = FALSE;
d2213 3
a2215 7
	    ch = LYCharINTERRUPT2;
	}

	if (recall != NORECALL && (ch == UPARROW || ch == DNARROW)) {
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
	    LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) recall\n", inputline));
d2218 1
a2218 9
	ch |= CurModif;
	CurModif = 0;
	if (last_xlkc != -1) {
	    if (ch == last_xlkc)
		ch |= LKC_MOD3;
	    last_xlkc = -1;	/* consumed */
	}
#ifndef WIN_EX
	if (LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
d2220 1
a2220 22
#endif
	last_xlec = xlec;
	xlec = EditBinding(ch);
	if ((xlec & LYE_DF) && !(xlec & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    xlec &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}
	switch (xlec) {
	case LYE_SETM1:
	    /*
	     *  Set flag for modifier 1.
	     */
	    CurModif |= LKC_MOD1;
	    break;
	case LYE_SETM2:
	    /*
	     *  Set flag for modifier 2.
	     */
	    CurModif |= LKC_MOD2;
	    break;
d2222 9
a2230 30
	    if (xlec == last_xlec && recall != NORECALL) {
		HTList *list = whichRecall(recall);
		if (!HTList_isEmpty(list)) {
		    char **data = sortedList(list, (BOOL)(recall == RECALL_CMD));
		    int old_y, old_x;
		    int cur_choice = 0;
		    int num_options = LYarrayLength((CONST char **)data);

		    while (cur_choice < num_options
		     && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
			cur_choice++;

		    LYGetYX(old_y, old_x);
		    cur_choice = LYhandlePopupList(
			cur_choice,
			0,
			old_x,
			(CONST char **)data,
			-1,
			-1,
			FALSE,
			FALSE,
			TRUE);
		    if (cur_choice >= 0) {
			if (recall == RECALL_CMD)
			    _statusline(": ");
			reinsertEdit(&MyEdit, data[cur_choice]);
		    }
		    wmove(LYwin, old_y, old_x);
		    FREE(data);
d2233 1
a2233 1
		reinsertEdit(&MyEdit, LYFindInCloset(recall, MyEdit.buffer));
a2235 2

#ifndef CJK_EX	/* 1997/11/03 (Mon) 20:13:45 */
d2245 1
a2245 2
		 LYlowest_eightbit[current_char_set] <= 0x97))
	    {
a2248 2
	    /* FALLTHRU */
#endif
d2253 2
a2254 4
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
	    if (!hidden)
		LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) LYE_ENTER\n", inputline));
a2256 37
#ifdef CAN_CUT_AND_PASTE
	/* 1998/10/01 (Thu) 15:05:49 */

	case LYE_PASTE:
	    {
		unsigned char *s = get_clip_grab(), *e;
		int len;

		if (!s)
		    break;
		len = strlen(s);
		e = s + len;

		if (len > 0) {
		    unsigned char *e1 = s;

		    while (e1 < e) {
			if (*e1 < ' ') { /* Stop here? */
			    if (e1 > s)
				LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
			    s = e1;
			    if (*e1 == '\t') { /* Replace by space */
				LYEditInsert(&MyEdit, " ", 1, map_active, TRUE);
				s = ++e1;
			    } else
				break;
			} else
			    ++e1;
		    }
		    if (e1 > s)
			LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
		}
		get_clip_release();
		break;
	    }
#endif

a2261 10
	    CTRACE((tfp, "LYgetstr LYE_ABORT\n"));
	    return(-1);

	case LYE_STOP:
	    /*
	     *	Deactivate.
	     */
	    CTRACE((tfp, "LYgetstr LYE_STOP\n"));
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
a2262 7
#else
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;		/* Disable it */
#endif
#endif
	    break;
a2280 10
	    if (xlec & LYE_FORM_LAC) {
		/*
		 *	Used in form_getstr() to end line editing and
		 *	pass on the lynxkeycode already containing a
		 *	lynxactioncode.  Here it is just ignored. - kw
		 */
		break;
	    }

#ifndef SUPPORT_MULTIBYTE_EDIT
a2281 12
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (LYLineEdit(&MyEdit, ch, FALSE) == 0) {
		if (refresh_mb && HTCJK != NOCJK && (0x81 <= ch) && (ch <= 0xfe))
		    refresh_mb = FALSE;
		else
		    refresh_mb = TRUE;
	    } else {
		if (!refresh_mb) {
		    LYEdit1(&MyEdit, 0, LYE_DELP, FALSE);
		}
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
a2285 23
PUBLIC CONST char * LYLineeditHelpURL NOARGS
{
    static int lasthelp_lineedit = -1;
    static char helpbuf[LY_MAXPATH] = "\0";
    static char *phelp = &helpbuf[0];
    if (lasthelp_lineedit == current_lineedit)
	return &helpbuf[0];
    if (lasthelp_lineedit == -1) {
	LYstrncpy(helpbuf, helpfilepath, sizeof(helpbuf) - 1);
	phelp += strlen(helpbuf);
    }
    if (LYLineeditHelpURLs[current_lineedit] &&
	strlen(LYLineeditHelpURLs[current_lineedit]) &&
	(strlen(LYLineeditHelpURLs[current_lineedit]) <=
	 sizeof(helpbuf) - (phelp - helpbuf))) {
	LYstrncpy(phelp, LYLineeditHelpURLs[current_lineedit],
		  sizeof(helpbuf) - (phelp - helpbuf) - 1);
	lasthelp_lineedit = current_lineedit;
	return (&helpbuf[0]);
    }
    return NULL;
}

d2295 1
a2295 1
    if (isEmpty(stringp))		/* nothing to do? */
d2298 5
d2321 2
a2322 2
	char *,		chptr,
	CONST char *,	tarptr)
d2348 2
a2349 2
	char *,		chptr,
	char *,		tarptr)
d2402 2
a2403 2
	char *,		chptr,
	char *,		tarptr)
d2448 2
a2449 7
 * The physical lengths of the displayed string up to the start and
 * end (= next position after) of the target string are returned in *nstartp
 * and *nendp if the search is successful.
 *   These lengths count glyph cells if count_gcells is set. (Full-width
 *   characters in CJK mode count as two.)  Normally that's what we want.
 *   They count actual glyphs if count_gcells is unset. (Full-width
 *   characters in CJK mode count as one.)
d2453 2
a2454 2
 *			      LY_BOLD_END_CHAR
 *			      LY_SOFT_HYPHEN
d2459 3
a2461 3
PUBLIC char * LYno_attr_mbcs_case_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
a2462 1
	BOOL,		count_gcells,
d2466 1
a2466 2
    char *tmpchptr;
    CONST char *tmptarptr;
d2483 1
a2483 1
	if ((!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
d2502 3
a2504 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
d2506 1
a2506 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
a2518 1
		    if (count_gcells) tarlen++;
d2523 2
a2524 2
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
d2527 1
a2533 1
		    if (count_gcells) len++;
d2541 2
a2542 2
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
a2547 1
			    if (count_gcells) tarlen++;
d2549 1
a2549 1
			    break;
d2561 1
a2561 1
		} else {
d2563 1
a2563 1
		}
d2565 8
a2572 7
		if (*tmptarptr == '\0') {
		    if (nstartp)	*nstartp = offset;
		    if (nendp)		*nendp = len + tarlen;
		    return(chptr);
		}
		if (*tmpchptr == '\0')
		    break;
d2576 1
a2576 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
a2579 1
		if (count_gcells) len++;
d2593 2
a2594 6
 *  end (= next position after) the target string are returned in *nstartp
 *  and *nendp if the search is successful.
 *    These lengths count glyph cells if count_gcells is set. (Full-width
 *    characters in CJK mode count as two.)  Normally that's what we want.
 *    They count actual glyphs if count_gcells is unset. (Full-width
 *    characters in CJK mode count as one.)
d2599 1
a2599 1
 *			      LY_SOFT_HYPHEN
d2604 3
a2606 3
PUBLIC char * LYno_attr_mbcs_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
a2607 1
	BOOL,		count_gcells,
d2611 1
a2611 2
    char *tmpchptr;
    CONST char *tmptarptr;
d2643 3
a2645 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
d2647 1
a2647 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
a2658 1
		    if (count_gcells) tarlen++;
d2663 2
a2664 2
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
d2667 1
a2673 1
		    if (count_gcells) len++;
d2682 1
a2682 1
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
a2687 1
			    if (count_gcells) tarlen++;
d2705 2
a2706 2
		     if (nstartp)	*nstartp = offset;
		     if (nendp)		*nendp = len + tarlen;
d2709 1
a2709 1
		if (*tmpchptr == '\0')
d2712 1
d2715 1
a2715 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
a2718 1
		if (count_gcells) len++;
d2727 57
d2794 1
a2794 1
	*dest = typeMallocn(char, n + 1);
d2796 1
a2796 1
	    CTRACE((tfp, "Tried to malloc %d bytes\n", n));
d2813 1
a2813 1
    if (non_empty(src)) {
d2822 1
a2822 1
	    *dest = typeMallocn(char, n + 1);
d2825 2
a2826 2
	    memcpy(*dest, src, n);
	    (*dest)[n] = '\0'; /* terminate */
d2853 1
a2853 1
    high = TABLESIZE(unicode_to_lower_case);
a2885 7
    /* if they are the same or one is a null characters return immediately. */
    if (ch1 == ch2)
	return 0;
    if (!ch2)
	return UCH(ch1);
    else if (!ch1)
	return -UCH(ch2);
d2888 44
a2931 1
    if (UCH(TOASCII(ch1)) < 128 && UCH(TOASCII(ch2)) < 128)
d2935 2
a2936 2
    if (UCH(TOASCII(ch1)) > 127 &&  /* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127)
d2942 23
a2964 6
	    long uni_ch2 = UCTransToUni((char)ch2, current_char_set);
	    long uni_ch1;
	    if (uni_ch2 < 0)
		return UCH(ch1);
	    uni_ch1 = UCTransToUni((char)ch1, current_char_set);
	    return(UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
d2970 1
d2995 2
a2996 8
    if (ferror(fp)) {
	FREE(result);
    } else if (feof(fp) && result && *result == '\0') {
	/*
	 *  If the file ends in the middle of a line, return the
	 *  partial line; if another call is made after this, it
	 *  will return NULL. - kw
	 */
a3002 121

#ifdef EXP_CMD_LOGGING
PRIVATE FILE *cmd_logfile;
PRIVATE FILE *cmd_script;

PUBLIC void LYOpenCmdLogfile ARGS2(
	int,		argc,
	char **,	argv)
{
    int n;

    if (lynx_cmd_logfile != 0) {
	cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
	if (cmd_logfile != 0) {
	    fprintf(cmd_logfile, "# Command logfile created by %s %s (%s)\n",
		LYNX_NAME, LYNX_VERSION, LYVersionDate());
	    for (n = 0; n < argc; n++) {
		fprintf(cmd_logfile, "# Arg%d = %s\n", n, argv[n]);
	    }
	}
    }
}

PUBLIC BOOL LYHaveCmdScript NOARGS
{
    return (BOOL)(cmd_script != 0);
}

PUBLIC void LYOpenCmdScript NOARGS
{
    if (lynx_cmd_script != 0) {
	cmd_script = fopen(lynx_cmd_script, TXT_R);
	CTRACE((tfp, "LYOpenCmdScript(%s) %s\n",
		lynx_cmd_script,
		cmd_script != 0 ? "SUCCESS" : "FAIL"));
    }
}

PUBLIC int LYReadCmdKey ARGS1(
	int,	mode)
{
    int ch = -1;

    if (cmd_script != 0) {
	char *buffer = 0;
	char *src;
	char *tmp;
	unsigned len;

	while ((ch < 0) && LYSafeGets(&buffer, cmd_script) != 0) {
	    LYTrimTrailing(buffer);
	    src = LYSkipBlanks(buffer);
	    tmp = LYSkipNonBlanks(src);
	    switch (len = (tmp - src)) {
	    case 4:
		if (!strncasecomp(src, "exit", 4))
		    exit(0);
		break;
	    case 3:
		if (!strncasecomp(src, "key", 3)) {
		    ch = LYStringToKeycode(LYSkipBlanks(tmp));
		} else if (!strncasecomp(src, "set", 3)) {
		    src = LYSkipBlanks(tmp);
		    tmp = src;
		    while (*tmp != '\0') {
			if (isspace(UCH(*tmp)) || *tmp == '=')
			    break;
			++tmp;
		    }
		    if (*tmp != '\0') {
			*tmp++ = '\0';
			tmp = LYSkipBlanks(tmp);
		    }
		    CTRACE((tfp, "LYSetConfigValue(%s, %s)\n", src, tmp));
		    LYSetConfigValue(src, tmp);
		}
		break;
	    }
	}
	if (feof(cmd_script)) {
	    fclose(cmd_script);
	    cmd_script = 0;
	}
	if (ch >= 0) {
	    LYSleepReplay();
	    LYrefresh();
	}
	FREE(buffer);
    } else {
	ch = LYgetch_for(mode);
    }
    CTRACE((tfp, "LYReadCmdKey(%d) ->%s (%#x)\n", mode, LYKeycodeToString(ch, TRUE), ch));
    LYWriteCmdKey(ch);
    return ch;
}

/*
 * Write a LYKeymapCode 'ch' to the logfile.
 */
PUBLIC void LYWriteCmdKey ARGS1(
	int,	ch)
{
    if (cmd_logfile != 0) {
	fprintf(cmd_logfile, "key %s\n", LYKeycodeToString(ch, FALSE));
    }
}

PUBLIC void LYCloseCmdLogfile NOARGS
{
    if (cmd_logfile != 0) {
	LYCloseOutput(cmd_logfile);
	cmd_logfile = 0;
    }
    if (cmd_script != 0) {
	LYCloseInput(cmd_script);
	cmd_script = 0;
    }
    FREE(lynx_cmd_logfile);
    FREE(lynx_cmd_script);
}
#endif /* EXP_CMD_LOGGING */
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d2547 1
a2547 1
    while (i != 0 && (buffer[i-1] == '\n' || buffer[i-1] == '\r'))
@


1.1.3.3
log
@Update to the lynx 2.8.5 release (only minor diffs)
so the lusers won't cry we aren't up to date
@
text
@a1318 12
#if defined(USE_SLANG) && defined(__MINGW32__)
	INTERN_KEY( "\xE0H",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\xE0P",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\xE0M",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\xE0K",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\xE0R",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\xE0S",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\xE0I",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\xE0Q",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\xE0G",	HOME,		KEY_HOME),
	INTERN_KEY( "\xE0O",	END_KEY,	KEY_END ),
#endif
d1512 1
a1512 22
   if ((key == NULL) || (key->type != SLKEY_F_KEYSYM)) {
#ifdef __MINGW32__
	   if ((key == NULL) && (current_sl_modifier == LKC_ISLKC)) {
		   key = SLang_do_key (Keymap_List, myGetChar);
		   keysym = key->f.keysym;
		   switch (keysym) {
			   case 'H': keysym = UPARROW; break;
			   case 'P': keysym = DNARROW; break;
			   case 'M': keysym = RTARROW; break;
			   case 'K': keysym = LTARROW; break;
			   case 'R': keysym = INSERT_KEY; break;
			   case 'S': keysym = REMOVE_KEY; break;
			   case 'I': keysym = PGUP; break;
			   case 'Q': keysym = PGDOWN; break;
			   case 'G': keysym = HOME; break;
			   case 'O': keysym = END_KEY; break;
			   case ';': keysym = F1; break;
		   }
		   return(keysym);
	   }
#endif

a1513 1
   }
d4854 1
a4854 1
		unsigned char *s = (unsigned char *) get_clip_grab(), *e;
d4859 1
a4859 1
		len = strlen((const char *) s);
d4871 1
a4871 1
				LYEditInsert(&MyEdit, (unsigned char * ) " ", 1, map_active, TRUE);
@


1.1.3.4
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d79 1
a79 1
int peek_mouse_levent (void)
d92 1
a92 1
int get_mouse_link (void)
d103 1
a103 1
int peek_mouse_link (void)
d109 4
a112 4
int fancy_mouse (
    WINDOW *	win,
    int	row,
    int *	position)
d257 2
a258 2
static HTList *whichRecall (
    RecallType		recall)
d280 1
a280 1
static void LYRemoveFromCloset (HTList * list)
d288 1
a288 1
void LYCloseCloset (RecallType recall)
d303 1
a303 1
static char * LYFindInCloset (RecallType recall, char* base)
d318 1
a318 1
static void LYAddToCloset (RecallType recall, char* str)
d330 6
a335 6
static int XYdist (
    int	x1,
    int	y1,
    int	x2,
    int	y2,
    int	dx2)
d372 5
a376 5
static int set_clicked_link (
    int	x,
    int	y,
    int	code,
    int	clicks)
d563 4
a566 4
char *LYstrncpy (
	char *		dst,
	const char *	src,
	int		n)
d596 6
a601 6
char * LYmbcsstrncpy (
	char *		dst,
	const char *	src,
	int		n_bytes,
	int		n_glyphs,
	BOOL		utf_flag)
d630 4
a633 4
char * LYmbcs_skip_glyphs (
	char *		data,
	int		n_glyphs,
	BOOL		utf_flag)
d665 4
a668 4
int LYmbcsstrlen (
	char *		str,
	BOOL		utf_flag,
	BOOL		count_gcells)
d730 1
a730 1
static int myGetChar (void)
d776 1
a776 1
static int sl_parse_mouse_event (int * x, int * y, int * button)
d808 2
a809 2
static int sl_read_mouse_event (
    int	code)
d839 3
a841 3
static BOOLEAN csi_is_csi = TRUE;
void ena_csi (
    BOOLEAN	flag)
d913 1
a913 1
static int lookup_tiname (char *name, NCURSES_CONST char *const *names)
d923 1
a923 1
static const char *expand_tiname (const char *first, size_t len, char **result, char *final)
d940 1
a940 1
static const char *expand_tichar (const char *first, char **result, char *final)
d989 1
a989 1
static int expand_substring (char* dst, const char* first, const char* last, char *final)
d1001 1
a1001 1
		const char *s = strchr(first, RPAREN);
d1032 1
a1032 1
static void unescaped_char (const char* parse, int* keysym)
d1044 1
a1044 1
static BOOLEAN unescape_string (char* src, char * dst, char * final)
d1061 1
a1061 1
int map_string_to_keysym (const char* str, int* keysym)
d1145 1
a1145 1
static char *skip_keysym (char * parse)
d1175 1
a1175 1
static int setkey_cmd (char *parse)
d1218 1
a1218 1
static int unsetkey_cmd (char *parse)
d1252 1
a1252 1
static int read_keymap_file (void)
d1255 2
a1256 2
	const char *name;
	int (*func) (char *s);
d1295 1
a1295 1
static void setup_vtXXX_keymap (void)
d1353 1
a1353 1
int lynx_initialize_keymaps (void)
d1389 1
a1389 1
static int LYmouse_menu (int x, int y, int atlink, int code)
d1505 1
a1505 1
static int current_sl_modifier = 0;
d1508 1
a1508 1
static int myGetChar (void)
d1516 2
a1517 2
static int LYgetch_for (
	int	code)
d1583 2
a1584 2
static int LYgetch_for (
	int	code)
d2377 1
a2377 1
int LYgetch (void)
d2385 1
a2385 1
int LYgetch_choice (void)
d2396 1
a2396 1
int LYgetch_input (void)
d2408 1
a2408 1
int LYgetch_single (void)
d2421 2
a2422 2
void LYLowerCase (
	 char *	arg_buffer)
d2447 2
a2448 2
void LYUpperCase (
	 char *	arg_buffer)
d2473 2
a2474 2
BOOLEAN LYRemoveNewlines (
	char *		buffer)
d2498 2
a2499 2
char * LYRemoveBlanks (
	char *		buffer)
d2522 2
a2523 2
char * LYSkipBlanks (
	char *		buffer)
d2533 2
a2534 2
char * LYSkipNonBlanks (
	char *		buffer)
d2542 1
a2542 1
 * Skip const whitespace
d2544 2
a2545 2
const char * LYSkipCBlanks (
	const char *	buffer)
d2553 1
a2553 1
 * Skip const non-whitespace
d2555 2
a2556 2
const char * LYSkipCNonBlanks (
	const char *	buffer)
d2566 2
a2567 2
void LYTrimLeading (
	char *		buffer)
d2577 2
a2578 2
char * LYTrimNewline (
	char *		buffer)
d2589 2
a2590 2
void LYTrimTrailing (
	char *		buffer)
d2600 3
a2602 3
char *LYElideString (
	char *		str,
	int		cut_pos)
d2629 2
a2630 2
BOOLEAN LYTrimStartfile (
	char *		buffer)
d2652 2
a2653 2
void LYEscapeStartfile (
	char **		buffer)
d2665 2
a2666 2
void LYTrimAllStartfile (
	char *		buffer)
d2695 1
a2695 1
static char killbuffer[1024] = "\0";
d2698 5
a2702 5
void LYSetupEdit (
	EDREC *	edit,
	char *		old,
	int		maxstr,
	int		maxdsp)
d2743 3
a2745 3
static int prev_pos (
	EDREC *	edit,
	int		pos)
d2777 6
a2782 6
int LYEditInsert (
	EDREC *	edit,
	unsigned char *s,
	int		len,
	int		map,
	BOOL		maxMessage)
d2889 5
a2893 5
int LYEdit1 (
	EDREC *	edit,
	int		ch,
	int		action,
	BOOL		maxMessage)
d3319 4
a3322 4
int get_popup_number (
	char *		msg,
	int *		c,
	int *		rel)
d3386 2
a3387 2
void LYRefreshEdit (
	EDREC *	edit)
d3614 3
a3616 3
static void reinsertEdit (
    EditFieldData *	edit,
    char *		result)
d3627 3
a3629 3
static int caselessCmpList (
    const void *	a,
    const void *	b)
d3631 1
a3631 1
    return strcasecomp(*(const char *const *)a, *(const char *const *)b);
d3634 3
a3636 3
static int normalCmpList (
    const void *	a,
    const void *	b)
d3638 1
a3638 1
    return strcmp(*(const char *const *)a, *(const char *const *)b);
d3641 3
a3643 3
static char **sortedList (
    HTList *	list,
    BOOL	ignorecase)
d3681 2
a3682 2
int LYarrayLength (
    const char **	list)
d3691 2
a3692 2
int LYarrayWidth (
    const char **	list)
d3705 5
a3709 5
static void FormatChoiceNum (
	char *		dst,
	int		num_choices,
	int		choice,
	const char *	value)
d3721 2
a3722 2
static unsigned options_width (
	const char **	list)
d3736 8
a3743 8
static void draw_option (
    WINDOW *		win,
    int		entry,
    int		width,
    BOOL		reversed,
    int		num_choices,
    int		number,
    const char *	value)
d3791 10
a3800 10
int LYhandlePopupList (
	int		cur_choice,
	int		ly,
	int		lx,
	const char **	choices,
	int		width,
	int		i_length,
	int		disabled,
	BOOLEAN	for_mouse,
	BOOLEAN	numbered)
d3825 1
a3825 1
    const char **Cptr = NULL;
d4722 5
a4726 5
int LYgetstr (
	char *		inputline,
	int		hidden,
	size_t		bufsize,
	RecallType	recall)
d4826 1
a4826 1
		    int num_options = LYarrayLength((const char **)data);
d4837 1
a4837 1
			(const char **)data,
d4988 1
a4988 1
const char * LYLineeditHelpURL (void)
d5014 3
a5016 3
char *LYstrsep (
	char **	stringp,
	const char *	delim)
d5040 3
a5042 3
char * LYstrstr (
	char *		chptr,
	const char *	tarptr)
d5067 3
a5069 3
char * LYno_attr_char_case_strstr (
	char *		chptr,
	char *		tarptr)
d5121 3
a5123 3
char * LYno_attr_char_strstr (
	char *		chptr,
	char *		tarptr)
d5184 7
a5190 7
char * LYno_attr_mbcs_case_strstr (
	char *		chptr,
	const char *	tarptr,
	BOOL		utf_flag,
	BOOL		count_gcells,
	int *		nstartp,
	int *		nendp)
d5193 1
a5193 1
    const char *tmptarptr;
d5337 7
a5343 7
char * LYno_attr_mbcs_strstr (
	char *		chptr,
	const char *	tarptr,
	BOOL		utf_flag,
	BOOL		count_gcells,
	int *		nstartp,
	int *		nendp)
d5346 1
a5346 1
    const char *tmptarptr;
d5467 4
a5470 4
char * SNACopy (
	char **	dest,
	const char *	src,
	int		n)
d5488 4
a5491 4
char * SNACat (
	char **	dest,
	const char *	src,
	int		n)
d5518 1
a5518 1
static long UniToLowerCase (long upper)
d5564 1
a5564 1
int UPPER8 (int ch1, int ch2)
d5603 3
a5605 3
char *LYSafeGets (
	char **	src,
	FILE *		fp)
d5637 2
a5638 2
static FILE *cmd_logfile;
static FILE *cmd_script;
d5640 3
a5642 3
void LYOpenCmdLogfile (
	int		argc,
	char **	argv)
d5658 1
a5658 1
BOOL LYHaveCmdScript (void)
d5663 1
a5663 1
void LYOpenCmdScript (void)
d5673 2
a5674 2
int LYReadCmdKey (
	int	mode)
d5734 2
a5735 2
void LYWriteCmdKey (
	int	ch)
d5742 1
a5742 1
void LYCloseCmdLogfile (void)
@


1.1.3.5
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d59 9
a67 9
 * simple to do.  Once you've determined the X and Y coordinates of
 * the mouse event, loop through the elements in the links[] array and
 * see if the coordinates fall within a highlighted link area.	If so,
 * the code must set mouse_link to the index of the chosen link,
 * and return a key value that corresponds to LYK_ACTIVATE.  The
 * LYK_ACTIVATE code in LYMainLoop.c will then check mouse_link
 * and activate that link.  If the mouse event didn't fall within a
 * link, the code should just set mouse_link to -1 and return -1. --AMK
 */
d79 1
a79 1
int peek_mouse_levent(void)
d92 1
a92 1
int get_mouse_link(void)
a94 1

d103 1
a103 1
int peek_mouse_link(void)
d108 5
a112 2
int fancy_mouse(WINDOW * win, int row,
		int *position)
a114 1

d123 2
a124 2
	&& (MOUSE_X_POS >= getbegx(win)
	    && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
d128 1
a128 1
	if (mypos + 1 == getmaxy(win)) {
d175 1
a175 1
    MEVENT event;
d179 2
a180 2
			 | BUTTON1_DOUBLE_CLICKED
			 | BUTTON1_TRIPLE_CLICKED))) {
d187 1
a187 1
	if (mypos + 1 == getmaxy(win)) {
d197 1
a197 1
				| BUTTON1_TRIPLE_CLICKED))
d211 1
a211 1
				| BUTTON1_TRIPLE_CLICKED))
d250 1
a250 1
#endif /* USE_MOUSE */
d257 2
a258 1
static HTList *whichRecall(RecallType recall)
d280 1
a280 1
static void LYRemoveFromCloset(HTList *list)
d288 1
a288 1
void LYCloseCloset(RecallType recall)
d292 1
a292 1
    while (!HTList_isEmpty(list)) {
d303 1
a303 1
static char *LYFindInCloset(RecallType recall, char *base)
d312 1
a312 1
	    return (data);
d315 1
a315 1
    return (0);
d318 1
a318 1
static void LYAddToCloset(RecallType recall, char *str)
d330 6
a335 5
static int XYdist(int x1,
		  int y1,
		  int x2,
		  int y2,
		  int dx2)
d340 1
a340 1
	xerr = 3 * (x1 - x2 - dx2) + 1;		/* pos after string not really in it */
d346 2
a347 2
	return (xerr > 0) ? (xerr * 2 - 1) : 0;
    if (xerr < 9 && yerr)	/* x-dist of 3 cell better than y-dist of 1 cell */
d349 1
a349 1
    return 2 * xerr + yerr;	/* Subjective factor; ratio -> approx. 6 / 9 */
d366 11
a376 10
 * index of the corresponding hyperlink, or set mouse_link to -1 if no
 * link matches the event.  Returns -1 if no link matched the click,
 * or a keycode that must be returned from LYgetch() to activate the
 * link.
 */

static int set_clicked_link(int x,
			    int y,
			    int code,
			    int clicks)
d379 1
a379 2
    int right = LYcols - 6;

d384 1
a384 1
    if (y == (LYlines - 1) || y == 0) {		/* First or last row */
d389 1
a389 1
	if (x == 0 && toolbar)	/* On '#' */
d397 1
a397 1
		c = (code == FOR_PROMPT && y)
d400 1
a400 1
		c = (code == FOR_PROMPT && y)
d402 1
a402 1
	    else if (y)		/* Last row */
d404 1
a404 1
	    else		/* First row */
d408 1
a408 1
		c = (code == FOR_PROMPT && y)
d412 3
a414 3
			  (s_forw_backw != NOSTYLE && x - toolbar >= 3)
			  ? LAC_TO_LKC0(LYK_NEXT_DOC)
			  : LAC_TO_LKC0(LYK_PREV_DOC)
d416 1
a416 1
			  LAC_TO_LKC0(LYK_NEXT_DOC)
d418 1
a418 1
		    );
d420 1
a420 1
		c = (code == FOR_PROMPT && y)
d422 1
a422 1
	    else if (y)		/* Last row */
d424 1
a424 1
	    else		/* First row */
d429 1
a429 1
	int h = display_lines - 2 * (LYsb_arrow != 0);
d439 1
a439 1
	    double frac = (1. * y) / (h - 1);
d444 1
a444 1
		LYSetNewline((int) (frac * l + 1 + 0.5));
d452 1
a452 1
	mouse_link = -1;	/* No action in edit fields */
d455 2
a456 1
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */ cur_err;
d477 1
a477 1
		       && (text = LYGetHiliteStr(i, ++count)) != NULL) {
a482 1

d491 1
a491 1
		    LYGetYX(cury, curx);
d497 1
a497 1
			/* submit current input field directly */
d509 1
a509 1
		    /* Do not pick up the current input field */
d540 13
a552 12
	} else {
	    if (2 * y > LYlines) {	/* Bottom Half of the screen */
		if (4 * y < 3 * LYlines) {
		    c = LAC_TO_LKC0(LYK_DOWN_TWO);	/* Third quarter */
		} else
		    c = LAC_TO_LKC0(LYK_DOWN_HALF);	/* Fourth quarter */
	    } else {		/* Upper Half of the screen */
		if (4 * y < LYlines) {
		    c = LAC_TO_LKC0(LYK_UP_HALF);	/* First quarter */
		} else
		    c = LAC_TO_LKC0(LYK_UP_TWO);	/* Second quarter */
	    }
d560 2
a561 2
 * LYstrncpy() terminates strings with a null byte.  Writes a null byte into
 * the n+1 byte of dst.
d563 4
a566 3
char *LYstrncpy(char *dst,
		const char *src,
		int n)
d580 1
a580 1
	*(dst + len) = '\0';
d582 1
a582 1
	*(dst + n) = '\0';
d590 12
a601 10
 * LYmbcsstrncpy() terminates strings with a null byte.  It takes account of
 * multibyte characters.  The src string is copied until either end of string
 * or max number of either bytes or glyphs (mbcs sequences) (CJK or UTF8).  The
 * utf_flag argument should be TRUE for UTF8.  - KW & FM
 */
char *LYmbcsstrncpy(char *dst,
		    const char *src,
		    int n_bytes,
		    int n_glyphs,
		    BOOL utf_flag)
d626 8
a633 7
 * LYmbcs_skip_glyphs() skips a given number of display positions in a string
 * and returns the resulting pointer.  It takes account of UTF-8 encoded
 * characters.  - KW
 */
char *LYmbcs_skip_glyphs(char *data,
			 int n_glyphs,
			 BOOL utf_flag)
d657 12
a668 10
 * LYmbcsstrlen() returns the printable length of a string that might contain
 * IsSpecial or multibyte (CJK or UTF8) characters.  - FM
 *
 * Counts glyph cells if count_gcells is set.  (Full-width characters in CJK
 * mode count as two.) Counts character glyphs if count_gcells is unset. 
 * (Full- width characters in CJK mode count as one.) - kw
 */
int LYmbcsstrlen(char *str,
		 BOOL utf_flag,
		 BOOL count_gcells)
d673 1
a673 1
	return (len);
d692 1
a692 1
		   !IsSpecialAttrChar(str[(i + 1)])) {
d697 1
a697 1
    return (len);
d730 1
a730 1
static int myGetChar(void)
d736 9
a744 8
	switch (c = wgetch(LYwin)) {
	case KEY_SHIFT_L:
	case KEY_SHIFT_R:
	case KEY_CONTROL_L:
	case KEY_CONTROL_R:
	case KEY_ALT_L:
	case KEY_ALT_R:
	case KEY_RESIZE:
d771 1
a771 1
#define GetChar() getchar()	/* used to be "getc(stdin)" and "getch()" */
d776 1
a776 1
static int sl_parse_mouse_event(int *x, int *y, int *button)
d781 3
a783 2
    *button = SLang_getkey();
    switch (*button) {
d791 1
a791 1
	SLang_flush_input();
d795 1
a795 1
    *x = SLang_getkey();
d797 1
a797 1
	*x = SLang_getkey() + 64 - 33;
d800 1
a800 1
    *y = SLang_getkey();
d802 1
a802 1
	*y = SLang_getkey() + 64 - 33;
d808 2
a809 1
static int sl_read_mouse_event(int code)
d811 1
a811 1
    int mouse_x, mouse_y, button;
d813 24
a836 7
    mouse_link = -1;
    if (-1 != sl_parse_mouse_event(&mouse_x, &mouse_y, &button)) {
	if (button == 0)	/* left */
	    return set_clicked_link(mouse_x, mouse_y, FOR_PANEL, 1);

	if (button == 1)	/* middle */
	    return LYReverseKeymap(LYK_VIEW_BOOKMARK);
a837 15
	if (button == 2)	/* right */
	{
	    /* Right button: go back to prev document.
	     * The problem is that we need to determine
	     * what to return to achieve this.
	     */
	    return LYReverseKeymap(LYK_PREV_DOC);
	}
    }
    if (code == FOR_INPUT || code == FOR_PROMPT)
	return DO_NOTHING;
    else
	return -1;
}
#endif /* USE_SLANG and USE_MOUSE */
d840 2
a841 1
void ena_csi(BOOLEAN flag)
a853 1

d880 8
a887 5
typedef struct {
    char *string;
    int value;
} Keysym_String_List;
/* *INDENT-OFF* */
a906 1
/* *INDENT-ON* */
d913 1
a913 1
static int lookup_tiname(char *name, NCURSES_CONST char *const *names)
d923 1
a923 1
static const char *expand_tiname(const char *first, size_t len, char **result, char *final)
d931 1
a931 1
	|| (code = lookup_tiname(name, strfnames)) >= 0) {
d940 1
a940 1
static const char *expand_tichar(const char *first, char **result, char *final)
d949 10
a958 33
    case 'E':
    case 'e':
	value = 27;
	break;
    case 'a':
	name = "bel";
	break;
    case 'b':
	value = '\b';
	break;
    case 'f':
	value = '\f';
	break;
    case 'n':
	value = '\n';
	break;
    case 'r':
	value = '\r';
	break;
    case 't':
	value = '\t';
	break;
    case 'v':
	value = '\v';
	break;
    case 'd':
	radix = 10;
	limit = 3;
	break;
    case 'x':
	radix = 16;
	limit = 2;
	break;
a972 1

d989 1
a989 1
static int expand_substring(char *dst, const char *first, const char *last, char *final)
a1002 1

d1005 1
a1005 1
		first = expand_tiname(first, s - first, &dst, final);
d1010 1
a1010 1
	    } else if (ch == '?') {	/* ASCII delete? */
d1019 1
a1019 1
	case 0:		/* convert nulls for terminfo */
d1032 1
a1032 1
static void unescaped_char(const char *parse, int *keysym)
d1044 1
a1044 1
static BOOLEAN unescape_string(char *src, char *dst, char *final)
a1049 1

d1061 1
a1061 1
int map_string_to_keysym(const char *str, int *keysym)
a1063 1

d1067 1
a1067 1
	char *other = strchr(str + 4, ':');
d1070 2
a1071 2
	    int othersym = lecname_to_lec(other + 1);
	    char buf[BUFSIZ];
d1073 1
a1073 1
	    if (othersym >= 0 && other - str - 4 < BUFSIZ) {
d1081 1
a1081 1
	    }
a1093 1

d1095 1
a1095 1
		return (*keysym = (UCH(str[0])) | modifier);
d1099 1
a1099 1
		return (*keysym = FROMASCII(UCH(str[1] & 0x1f)) | modifier);
d1102 1
a1102 1
		return (*keysym = CH_DEL | modifier);
d1105 1
a1105 5

		expand_substring(buf,
				 str,
				 str + HTMIN(len, 28),
				 buf + sizeof(buf) - 1);
d1107 1
a1107 1
		    return (*keysym = (UCH(buf[0])) | modifier);
a1115 1

d1120 1
a1120 1
		*keysym |= LKC_ISLKC;	/* caller should remove this flag - kw */
d1128 1
a1128 1
	    if (0 == strcmp(k->string, str)) {
d1145 1
a1145 1
static char *skip_keysym(char *parse)
d1175 1
a1175 1
static int setkey_cmd(char *parse)
d1192 1
a1192 1
	    if (map_string_to_keysym(s, &keysym) >= 0) {
d1195 1
a1195 1
		    return 0;	/* Trace the failure and continue. */
d1203 2
a1204 1
	    } else {
d1207 2
a1208 1
	} else {
d1211 2
a1212 1
    } else {
d1218 1
a1218 1
static int unsetkey_cmd(char *parse)
a1220 1

d1230 2
a1231 3

	    if (map_string_to_keysym(parse, &keysym) >= 0)
		define_key((char *) 0, keysym);
d1239 2
a1240 3
	SLang_undefine_key(parse, Keymap_List);
	if (SLang_Error)
	    return -1;
d1252 1
a1252 1
static int read_keymap_file(void)
a1253 1
    /* *INDENT-OFF* */
d1258 2
a1259 2
	{ "setkey",   setkey_cmd },
	{ "unsetkey", unsetkey_cmd },
a1260 1
    /* *INDENT-ON* */
d1270 1
a1270 1
    if ((fp = fopen(file, "r")) == 0)
d1285 3
a1287 3
	    if (strlen(s) > len && !strncmp(s, table[n].name, len)
		&& (*(table[n].func)) (LYSkipBlanks(s + len)) < 0)
		fprintf(stderr, FAILED_READING_KEYMAP, linenum, file);
d1291 1
a1291 1
    LYCloseInput(fp);
d1295 1
a1295 1
static void setup_vtXXX_keymap(void)
a1296 1
    /* *INDENT-OFF* */
a1347 2
    /* *INDENT-ON* */

a1348 1

d1353 1
a1353 1
int lynx_initialize_keymaps(void)
d1364 1
a1364 1
    if (NULL == (Keymap_List = SLang_create_keymap("Lynx", NULL)))
d1368 2
a1369 1
    for (i = 1; i < 256; i++) {
d1371 1
a1371 1
	define_key(keybuf, i);
d1375 1
a1375 1
    define_key("\033[M", MOUSE_KEYSYM);
d1378 1
a1378 1
	SLang_exit_error("Unable to initialize keymaps");
d1385 2
a1386 1
#endif /* USE_KEYMAPS */
d1389 1
a1389 1
static int LYmouse_menu(int x, int y, int atlink, int code)
a1392 1
    /* *INDENT-OFF* */
a1424 2
    /* *INDENT-ON* */

d1443 2
a1444 2
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x - 5 : 1),
		      choices, c1, FALSE, TRUE);
d1447 5
a1451 4
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
d1462 11
a1472 11
	case LYK_ABORT:
	    retlac = LYK_QUIT;	/* a bit softer... */
	    /* fall through */
	case LYK_MAIN_MENU:
	case LYK_PREV_DOC:
	case LYK_HOME:
	case LYK_PREV_PAGE:
	case LYK_UP_HALF:
	case LYK_UP_TWO:
	case LYK_HISTORY:
	case LYK_HELP:
d1474 14
a1487 14
	case LYK_RELOAD:
	case LYK_ECGOTO:
	case LYK_INFO:
	case LYK_WHEREIS:
	case LYK_PRINT:
	case LYK_DOWN_TWO:
	case LYK_DOWN_HALF:
	case LYK_NEXT_PAGE:
	case LYK_END:
	case LYK_VIEW_BOOKMARK:
	case LYK_COOKIE_JAR:
	case LYK_INDEX_SEARCH:
	case LYK_OPTIONS:
	    mouse_link = -3;	/* so LYgetch_for() passes it on - kw */
d1501 1
d1508 1
a1508 1
static int myGetChar(void)
a1510 1

d1516 2
a1517 1
static int LYgetch_for(int code)
d1519 3
a1521 4
    SLang_Key_Type *key;
    int keysym;

    current_sl_modifier = 0;
d1523 2
a1524 2
    key = SLang_do_key(Keymap_List, myGetChar);
    if ((key == NULL) || (key->type != SLKEY_F_KEYSYM)) {
d1526 18
a1543 40
	if ((key == NULL) && (current_sl_modifier == LKC_ISLKC)) {
	    key = SLang_do_key(Keymap_List, myGetChar);
	    keysym = key->f.keysym;
	    switch (keysym) {
	    case 'H':
		keysym = UPARROW;
		break;
	    case 'P':
		keysym = DNARROW;
		break;
	    case 'M':
		keysym = RTARROW;
		break;
	    case 'K':
		keysym = LTARROW;
		break;
	    case 'R':
		keysym = INSERT_KEY;
		break;
	    case 'S':
		keysym = REMOVE_KEY;
		break;
	    case 'I':
		keysym = PGUP;
		break;
	    case 'Q':
		keysym = PGDOWN;
		break;
	    case 'G':
		keysym = HOME;
		break;
	    case 'O':
		keysym = END_KEY;
		break;
	    case ';':
		keysym = F1;
		break;
	    }
	    return (keysym);
	}
d1546 2
a1547 2
	return (current_sl_modifier ? 0 : DO_NOTHING);
    }
d1549 1
a1549 1
    keysym = key->f.keysym;
d1552 2
a1553 2
    if (keysym == MOUSE_KEYSYM)
	return sl_read_mouse_event(code);
d1556 2
a1557 2
    if (keysym < 0)
	return 0;
d1559 2
a1560 2
    if (keysym & (LKC_ISLECLAC | LKC_ISLAC))
	return (keysym);
d1562 5
a1566 5
    current_sl_modifier = 0;
    if (LKC_HAS_ESC_MOD(keysym)) {
	current_sl_modifier = LKC_MOD2;
	keysym &= LKC_MASK;
    }
d1568 2
a1569 2
    if (keysym + 1 >= KEYMAP_SIZE)
	return 0;
d1571 1
a1571 1
    return (keysym | current_sl_modifier);
d1575 2
a1576 1
#else /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */
d1579 1
a1579 1
 * LYgetch() translates some escape sequences and may fake noecho.
d1583 2
a1584 1
static int LYgetch_for(int code)
d1592 2
a1593 2
  re_read:
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
d1596 1
a1596 1
#endif /* UCX && VAXC */
d1598 1
a1598 1
    clearerr(stdin);		/* needed here for ultrix and SOCKETSHR, but why? - FM */
d1609 1
a1609 1
	if (c == EOF && errno == EINTR)		/* Ctrl-Z causes EINTR in getchar() */
d1617 1
a1617 1
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
d1629 1
a1629 1
	)) {
a1630 1

a1638 1

a1650 1

d1654 1
a1654 1
			"nozap: freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
d1674 6
a1679 6
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		recent_sizechange));
	if (!recent_sizechange) {	/* not yet detected by ourselves */
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	}
d1681 2
a1682 2
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		recent_sizechange));
d1684 1
a1684 1
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
d1686 2
a1687 2
#endif /* UCX && VAXC */
	return (DO_NOTHING);
d1699 1
a1699 1
	return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
d1701 1
a1701 1
#else /* not USE_SLANG: */
d1704 1
a1704 1
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
d1713 1
a1713 1
	if (c == ERR && errno == EINTR)		/* may have been handled signal - kw */
d1725 1
a1725 1
	done_esc = TRUE;	/* Flag: we did it, not keypad() */
d1735 12
a1746 36
	case 'A':
	    c = UPARROW;
	    break;
	case 'B':
	    c = DNARROW;
	    break;
	case 'C':
	    c = RTARROW;
	    break;
	case 'D':
	    c = LTARROW;
	    break;
	case 'q':		/* vt100 application keypad 1 */
	    c = END_KEY;
	    break;
	case 'r':		/* vt100 application keypad 2 */
	    c = DNARROW;
	    break;
	case 's':		/* vt100 application keypad 3 */
	    c = PGDOWN;
	    break;
	case 't':		/* vt100 application keypad 4 */
	    c = LTARROW;
	    break;
	case 'v':		/* vt100 application keypad 6 */
	    c = RTARROW;
	    break;
	case 'w':		/* vt100 application keypad 7 */
	    c = HOME;
	    break;
	case 'x':		/* vt100 application keypad 8 */
	    c = UPARROW;
	    break;
	case 'y':		/* vt100 application keypad 9 */
	    c = PGUP;
	    break;
d1749 5
a1753 3
	    if (found_CSI(c, b)) {
		c = sl_read_mouse_event(code);
	    } else
d1755 2
a1756 2
		c = '\n';	/* keypad enter on pc ncsa telnet */
	    break;
d1768 1
a1768 1
		done_esc = FALSE;	/* we have another look below - kw */
d1794 2
a1795 2
	case '1':		/* VTxxx  Find  */
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1798 1
a1798 1
		done_esc = FALSE;	/* we have another look below - kw */
d1801 2
a1802 2
	    if (found_CSI(c, b)) {
		if ((d = GetChar()) == '~')	/* VTxxx Insert */
d1806 3
a1808 2
			 GetChar() == '~') {
		    if (d == '8')	/* VTxxx   Help */
d1810 1
a1810 1
		    else if (d == '9')	/* VTxxx    Do  */
d1813 4
a1816 3
		}
	    } else
		done_esc = FALSE;	/* we have another look below - kw */
d1819 1
a1819 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1822 1
a1822 1
		done_esc = FALSE;	/* we have another look below - kw */
d1825 1
a1825 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1828 1
a1828 1
		done_esc = FALSE;	/* we have another look below - kw */
d1831 1
a1831 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1834 1
a1834 1
		done_esc = FALSE;	/* we have another look below - kw */
d1837 1
a1837 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1840 1
a1840 1
		done_esc = FALSE;	/* we have another look below - kw */
d1843 2
a1844 2
	    if (found_CSI(c, b)) {
		if ((d = GetChar()) == 'A')
d1850 1
a1850 1
	    if (c == CH_ESC && a == b && !found_CSI(c, b)) {
d1857 1
a1857 1
	    CTRACE((tfp, "Unknown key sequence: %d:%d:%d\n", c, b, a));
d1861 1
a1861 1
	if (isdigit(a) && found_CSI(c, b) && d != -1 && d != '~')
d1864 1
a1864 1
	    if (a == b && !found_CSI(c, b) && c == CH_ESC) {
d1875 1
a1875 1
    if (c >= 0 && (c & LKC_ISLECLAC)) {
d1878 1
a1878 1
    } else if (c >= 0 && (c & LKC_ISLKC)) {
d1880 1
a1880 1
	done_esc = TRUE;	/* already a lynxkeycode, skip keypad switches - kw */
d1886 2
a1887 2
    if (c >= 0 && (c & (LKC_ISLECLAC | LKC_ISLAC))) {
	done_esc = TRUE;	/* already a lynxactioncode, skip keypad switches - iz */
d1895 1
a1895 1
	 * Convert keypad() mode keys into Lynx defined keys.
d1897 4
a1900 4
	switch (c) {
	case KEY_DOWN:		/* The four arrow keys ... */
	    c = DNARROW;
	    break;
d1902 2
a1903 2
	    c = UPARROW;
	    break;
d1905 5
a1909 5
	    c = LTARROW;
	    break;
	case KEY_RIGHT:	/* ... */
	    c = RTARROW;
	    break;
d1912 2
a1913 2
	    c = DNARROW;
	    break;
d1915 2
a1916 2
	    c = UPARROW;
	    break;
d1918 2
a1919 2
	    c = LTARROW;
	    break;
d1921 8
a1928 8
	    c = RTARROW;
	    break;
	case PAD0:		/* PC-9800 Ins */
	    c = INSERT_KEY;
	    break;
	case PADSTOP:		/* PC-9800 DEL */
	    c = REMOVE_KEY;
	    break;
d1930 15
a1944 15
	case KEY_HOME:		/* Home key (upward+left arrow) */
	    c = HOME;
	    break;
	case KEY_CLEAR:	/* Clear screen */
	    c = 18;		/* CTRL-R */
	    break;
	case KEY_NPAGE:	/* Next page */
	    c = PGDOWN;
	    break;
	case KEY_PPAGE:	/* Previous page */
	    c = PGUP;
	    break;
	case KEY_LL:		/* home down or bottom (lower left) */
	    c = END_KEY;
	    break;
d1946 19
a1964 19
	    /* The keypad is arranged like this: */
	    /*    a1    up    a3   */
	    /*   left   b2  right  */
	    /*    c1   down   c3   */
	case KEY_A1:		/* upper left of keypad */
	    c = HOME;
	    break;
	case KEY_A3:		/* upper right of keypad */
	    c = PGUP;
	    break;
	case KEY_B2:		/* center of keypad */
	    c = DO_NOTHING;
	    break;
	case KEY_C1:		/* lower left of keypad */
	    c = END_KEY;
	    break;
	case KEY_C3:		/* lower right of keypad */
	    c = PGDOWN;
	    break;
d1967 3
a1969 3
	case KEY_ENTER:	/* enter/return      */
	    c = '\n';
	    break;
d1971 1
a1971 1
#ifdef PADENTER			/* PDCURSES */
d1973 2
a1974 2
	    c = '\n';
	    break;
d1977 3
a1979 3
	case KEY_END:		/* end key           001 */
	    c = END_KEY;
	    break;
d1982 3
a1984 3
	case KEY_HELP:		/* help key          001 */
	    c = F1;
	    break;
d1988 2
a1989 2
	    c = CH_DEL;		/* backspace key (delete, not Ctrl-H)  S/390 -- gil -- 2041 */
	    break;
d1992 2
a1993 2
	    c = F1;		/* VTxxx Help */
	    break;
d1996 2
a1997 2
	    c = DO_KEY;		/* VTxxx Do */
	    break;
d2000 3
a2002 3
	case KEY_REDO:		/* VTxxx Do */
	    c = DO_KEY;
	    break;
d2006 2
a2007 2
	    c = FIND_KEY;	/* VTxxx Find */
	    break;
d2011 2
a2012 2
	    c = SELECT_KEY;	/* VTxxx Select */
	    break;
d2016 2
a2017 2
	    c = INSERT_KEY;	/* VTxxx Insert */
	    break;
d2021 2
a2022 2
	    c = REMOVE_KEY;	/* VTxxx Remove */
	    break;
d2026 2
a2027 2
	    c = BACKTAB_KEY;	/* Back tab, often Shift-Tab */
	    break;
d2030 1
a2030 1
	case KEY_RESIZE:	/* size change detected by ncurses */
d2037 1
a2037 1
		    recent_sizechange));
d2042 1
a2042 1
		    recent_sizechange));
d2045 6
a2050 6
#if 0				/* assumption seems flawed? */
		/* Not detected by us or already processed by us.  It can
		 * happens that ncurses lags behind us in detecting the change,
		 * since its own SIGTSTP handler is not installed so detecting
		 * happened *at the end* of the last refresh.  Tell it to
		 * refresh again...  - kw
d2064 3
a2066 3
		 * May be just the delayed effect of mainloop()'s call to
		 * resizeterm().  Pretend we haven't read anything yet, don't
		 * return.  - kw
d2071 2
a2072 2
	     * Yep, we agree there was a change.  Return now so that the caller
	     * can react to it.  - kw
d2107 1
a2107 1
		c = MOUSE_KEY;	/* Will be processed by the caller */
a2111 1

d2127 1
a2127 1
		    return (code == FOR_PANEL ? 0 : DO_NOTHING);
d2129 1
a2129 1
		levent = event;	/* Allow setting pos in entry fields */
d2139 1
a2139 1
		    /* Cannot ignore: see LYCurses.c */
d2141 3
a2143 3
			       (BUTTON1_PRESSED | BUTTON1_RELEASED
				| BUTTON2_PRESSED | BUTTON2_RELEASED
				| BUTTON3_PRESSED | BUTTON3_RELEASED))) {
d2153 1
a2153 1
			mouse_link = -1;	/* Forget about approx stuff. */
d2172 1
a2172 1
#if 0				/* Probably not necessary any more - kw */
d2179 1
a2179 1
		    ungetmouse(&event);		/* Caller will process this. */
a2190 1

d2218 1
a2218 2
			    c = LTARROW;
			    p = "<-";
d2220 1
a2220 2
			    c = RTARROW;
			    p = "->";
d2222 1
a2222 2
			    c = 'z';
			    p = "Cancel";
d2224 1
a2224 2
			    c = PGDOWN;
			    p = "PGDOWN";
d2229 1
a2229 2
			    c = LTARROW;
			    p = "<-";
d2231 1
a2231 2
			    c = RTARROW;
			    p = "->";
d2233 1
a2233 2
			    c = 'z';
			    p = "Cancel";
d2235 1
a2235 2
			    c = PGUP;
			    p = "PGUP";
d2238 1
a2238 3
			c = set_clicked_link(MOUSE_X_POS,
					     MOUSE_Y_POS,
					     FOR_PANEL, 1);
d2246 2
a2247 2
		if ((c + 1) >= KEYMAP_SIZE && (c & LKC_ISLAC))
		    return (c);
d2253 1
a2253 1
#endif /* USE_MOUSE */
d2258 2
a2259 2
	switch (c) {
	case K_Down:		/* The four arrow keys ... */
d2261 2
a2262 2
	    c = DNARROW;
	    break;
d2265 2
a2266 2
	    c = UPARROW;
	    break;
d2269 3
a2271 3
	    c = LTARROW;
	    break;
	case K_Right:		/* ... */
d2273 3
a2275 3
	    c = RTARROW;
	    break;
	case K_Home:		/* Home key (upward+left arrow) */
d2277 3
a2279 3
	    c = HOME;
	    break;
	case K_PageDown:	/* Next page */
d2281 3
a2283 3
	    c = PGDOWN;
	    break;
	case K_PageUp:		/* Previous page */
d2285 3
a2287 3
	    c = PGUP;
	    break;
	case K_End:		/* home down or bottom (lower left) */
d2289 6
a2294 6
	    c = END_KEY;
	    break;
	case K_F1:		/* F1 key */
	    c = F1;
	    break;
	case K_Insert:		/* Insert key */
d2296 3
a2298 3
	    c = INSERT_KEY;
	    break;
	case K_Delete:		/* Delete key */
d2300 14
a2313 14
	    c = REMOVE_KEY;
	    break;
	case K_Alt_Escape:	/* Alt-Escape */
	    c = 0x1a7;
	    break;
	case K_Control_At:	/* CTRL-@@ */
	    c = 0x1a8;
	    break;
	case K_Alt_Backspace:	/* Alt-Backspace */
	    c = 0x1a9;
	    break;
	case K_BackTab:	/* BackTab */
	    c = BACKTAB_KEY;
	    break;
d2317 4
a2320 4
	switch (c) {
	case SL_KEY_DOWN:	/* The four arrow keys ... */
	    c = DNARROW;
	    break;
d2322 2
a2323 2
	    c = UPARROW;
	    break;
d2325 30
a2354 30
	    c = LTARROW;
	    break;
	case SL_KEY_RIGHT:	/* ... */
	    c = RTARROW;
	    break;
	case SL_KEY_HOME:	/* Home key (upward+left arrow) */
	case SL_KEY_A1:	/* upper left of keypad */
	    c = HOME;
	    break;
	case SL_KEY_NPAGE:	/* Next page */
	case SL_KEY_C3:	/* lower right of keypad */
	    c = PGDOWN;
	    break;
	case SL_KEY_PPAGE:	/* Previous page */
	case SL_KEY_A3:	/* upper right of keypad */
	    c = PGUP;
	    break;
	case SL_KEY_END:	/* home down or bottom (lower left) */
	case SL_KEY_C1:	/* lower left of keypad */
	    c = END_KEY;
	    break;
	case SL_KEY_F(1):	/* F1 key */
	    c = F1;
	    break;
	case SL_KEY_IC:	/* Insert key */
	    c = INSERT_KEY;
	    break;
	case SL_KEY_DELETE:	/* Delete key */
	    c = REMOVE_KEY;
	    break;
d2359 3
a2361 3
    if (c & (LKC_ISLAC | LKC_ISLECLAC))
	return (c);
    if ((c + 1) >= KEYMAP_SIZE) {
d2363 3
a2365 3
	 * Don't return raw values for KEYPAD symbols which we may have missed
	 * in the switch above if they are obviously invalid when used as an
	 * index into (e.g.) keypad[].  - KW
d2369 1
a2369 1
	return (c | current_modifier);
d2374 2
a2375 1
#endif /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */
d2377 1
a2377 1
int LYgetch(void)
d2385 1
a2385 1
int LYgetch_choice(void)
a2387 1

d2389 1
a2389 1
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
d2396 1
a2396 1
int LYgetch_input(void)
a2398 1

d2400 1
a2400 1
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
d2408 1
a2408 1
int LYgetch_single(void)
a2410 1

d2412 1
a2412 1
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
d2421 2
a2422 1
void LYLowerCase(char *arg_buffer)
a2425 1

d2430 1
a2430 1
	    && buffer[i + 1] != 0) {
d2447 2
a2448 1
void LYUpperCase(char *arg_buffer)
a2451 1

d2456 1
a2456 1
	    && buffer[i + 1] != 0) {
d2473 2
a2474 1
BOOLEAN LYRemoveNewlines(char *buffer)
d2477 3
a2479 3
	register char *buf = buffer;

	for (; *buf && *buf != '\n' && *buf != '\r'; buf++) ;
d2482 2
a2483 3
	    char *old = buf;

	    for (; *old; old++) {
d2498 2
a2499 1
char *LYRemoveBlanks(char *buffer)
d2502 3
a2504 3
	register char *buf = buffer;

	for (; *buf && !isspace(UCH(*buf)); buf++) ;
d2507 2
a2508 3
	    char *old = buf;

	    for (; *old; old++) {
d2522 2
a2523 1
char *LYSkipBlanks(char *buffer)
d2533 2
a2534 1
char *LYSkipNonBlanks(char *buffer)
d2544 2
a2545 1
const char *LYSkipCBlanks(const char *buffer)
d2555 2
a2556 1
const char *LYSkipCNonBlanks(const char *buffer)
d2566 2
a2567 1
void LYTrimLeading(char *buffer)
d2570 2
a2571 2

    while ((*buffer++ = *skipped++) != 0) ;
d2577 2
a2578 1
char *LYTrimNewline(char *buffer)
d2581 1
a2581 2

    while (i != 0 && (buffer[i - 1] == '\n' || buffer[i - 1] == '\r'))
d2589 2
a2590 1
void LYTrimTrailing(char *buffer)
d2593 1
a2593 2

    while (i != 0 && isspace(UCH(buffer[i - 1])))
d2600 3
a2602 2
char *LYElideString(char *str,
		    int cut_pos)
d2608 1
a2608 1
    LYstrncpy(buff, str, sizeof(buff) - 1);
d2618 2
a2619 1
	     (*d++ = *s++) != 0;) ;
d2629 2
a2630 1
BOOLEAN LYTrimStartfile(char *buffer)
d2636 5
a2640 4
	 * The original implementations of these schemes expected white space
	 * without hex escaping, and did not check for hex escaping, so we'll
	 * continue to support that, until that code is redone in conformance
	 * with SGML principles.  - FM
d2652 2
a2653 1
void LYEscapeStartfile(char **buffer)
a2656 1

d2665 2
a2666 1
void LYTrimAllStartfile(char *buffer)
d2674 3
a2676 3
 *  Display the current value of the string and allow the user
 *  to edit it.
 */
d2681 1
a2681 1
 * Shorthand to get rid of all most of the "edit->suchandsos".
d2698 5
a2702 3
void LYSetupEdit(EDREC * edit, char *old,
		 int maxstr,
		 int maxdsp)
d2705 1
a2705 1
     * Initialize edit record
d2708 1
a2708 1
    edit->pad = ' ';
d2713 1
a2713 1
    MaxLen = maxstr;
d2715 1
a2715 1
    Margin = 0;
d2722 2
a2723 2
    if (maxstr > maxdsp) {	/* Need panning? */
	if (DspWdth > 4)	/* Else "{}" take up precious screen space */
d2727 4
a2730 3
	 * Figure out margins.  If too big, we do a lot of unnecessary
	 * scrolling.  If too small, user doesn't have sufficient look-ahead. 
	 * Let's say 25% for each margin, upper bound is 10 columns.
d2732 1
a2732 1
	Margin = DspWdth / 4;
d2743 3
a2745 1
static int prev_pos(EDREC * edit, int pos)
a2755 1

d2758 1
a2758 1
		!((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c)))) {
a2772 1

d2777 6
a2782 4
int LYEditInsert(EDREC * edit, unsigned char *s,
		 int len,
		 int map,
		 BOOL maxMessage)
d2789 1
a2789 1
     * ch is (presumably) printable character.
d2800 1
a2800 1
    for (; length >= Pos; length--)	/* Make room */
d2815 1
a2815 1
	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
d2847 1
a2847 1
	unsigned char *e = s + len, *t = (unsigned char *) Buf + Pos;
d2852 1
a2852 1
	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
a2862 5
    } else
#endif /* defined EXP_KEYBOARD_LAYOUT */
    {
	strncpy(Buf + Pos, (char *) s, len);
	edited = 1;
d2864 6
d2884 1
a2884 1
	Mark = -1 - Mark;	/* Disable it */
d2889 9
a2897 7
int LYEdit1(EDREC * edit, int ch,
	    int action,
	    BOOL maxMessage)
{				/* returns 0    character processed
				 *         -ch  if action should be performed outside of line-editing mode
				 *         ch   otherwise
				 */
d2903 1
a2903 1
	return (0);		/* Be defensive */
d2912 1
a2912 1
	 * Turn input character mapping on or off.
d2920 4
a2923 4
	 * Hex 97.
	 * Fall through as a character for CJK, or if this is a valid character
	 * in the current display character set.  Otherwise, we treat this as
	 * LYE_ENTER.
d2926 1
a2926 1
	    return (ch);
d2932 1
a2932 1
	return 0;		/* All changes already registered */
d2936 7
a2942 6
	 * ch is the second part (in most cases, a capital letter) of a 7-bit
	 * replacement for a character in the 8-bit C1 control range.
	 *
	 * This is meant to undo transformations like 0x81 -> 0x1b 0x41 (ESC A)
	 * etc.  done by slang on Unix and possibly some comm programs.  It's
	 * an imperfect workaround that doesn't work for all such characters.
d2955 1
a2955 1
		Mark = -1 - Mark;	/* Disable it */
d2957 3
a2959 3
	    for (i = length; i >= Pos; i--)	/* Make room */
		Buf[i + 1] = Buf[i];
	    Buf[length + 1] = '\0';
d2964 3
a2966 3
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	    return (ch);
d2973 2
a2974 2
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters.
d2976 1
a2976 1
	while (Pos && !isalnum(Buf[Pos - 1]))
d2978 1
a2978 1
	while (Pos && isalnum(Buf[Pos - 1]))
d2982 3
a2984 3
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters, or 1 or
	 * more multibyte character.
d3003 2
a3004 2
		       && !is8bits(Buf[pos0])
		       && isalnum(UCH(Buf[pos0]))) {
d3015 1
a3015 1
	 * Word forward.
d3019 1
a3019 1
	    Pos++;		/* '\0' is not a/n */
d3021 1
a3021 1
	    Pos++;
d3028 1
a3028 1
		Pos++;		/* '\0' is not a/n */
d3038 1
a3038 1
	 * Erase the line to start fresh.
d3040 1
a3040 1
	Buf[0] = '\0';
d3044 1
a3044 1
	/* fall through */
d3048 1
a3048 1
	 * Go to first column.
d3055 1
a3055 1
	 * Go to last column.
d3062 1
a3062 1
	 * Delete next word.
d3066 1
a3066 2

	    LYEdit1(edit, 0, LYE_FORWW, FALSE);
d3074 1
a3074 1
	 * Delete previous word.
d3078 1
a3078 2

	    LYEdit1(edit, 0, LYE_BACKW, FALSE);
d3087 1
a3087 1
	 * Delete from current cursor position back to BOL.
a3090 1

d3096 1
a3096 1
    case LYE_DELEL:		/* @@@@@@ */
d3098 1
a3098 1
	 * Delete from current cursor position thru EOL.
a3101 1

d3111 2
a3112 2
	 * Delete next character (I-beam style cursor), or current character
	 * (box/underline style cursor).
d3125 1
a3125 1
	 * Delete preceding character.
d3132 1
a3132 1
	    Mark = -1 - Mark;	/* Disable it */
d3138 1
a3138 1
	    Buf[i] = Buf[i + 1];
d3157 1
a3157 1
		Mark = -1 - Mark;	/* Disable it */
d3169 1
a3169 1
	 * Move cursor to the right.
d3177 1
a3177 1
	    if (HTCJK != NOCJK && is8bits(Buf[Pos - 1]))
d3188 1
a3188 1
	 * Left-arrow move cursor to the left.
d3208 1
a3208 1
	 * Transpose characters - bash or ksh(emacs not gmacs) style
d3211 1
a3211 1
	    return (ch);
d3215 3
a3217 3
	    Mark = -1 - Mark;	/* Temporary enable it */
	if (Mark == Pos || Mark == Pos + 1)
	    Mark = Pos - 1;
d3219 2
a3220 2
	    Mark = -1 - Mark;	/* Disable it */
	if (Buf[Pos - 1] == Buf[Pos]) {
d3224 1
a3224 3
	i = Buf[Pos - 1];
	Buf[Pos - 1] = Buf[Pos];
	Buf[Pos++] = (char) i;
d3229 1
a3229 1
	 * primitive emacs-like set-mark-command
d3232 1
a3232 1
	return (0);
d3236 1
a3236 1
	 * emacs-like exchange-point-and-mark
d3239 1
a3239 1
	    Mark = -1 - Mark;	/* Enable it */
d3241 2
a3242 4
	    return (0);
	i = Pos;
	Pos = Mark;
	Mark = i;
d3247 1
a3247 1
	 * primitive emacs-like kill-region
d3250 1
a3250 1
	    Mark = -1 - Mark;	/* Enable it */
d3253 1
a3253 1
	    return (0);
d3261 4
a3264 4
		      HTMIN(reglen, (int) sizeof(killbuffer) - 1));
	    for (i = Mark; Buf[i + reglen]; i++)
		Buf[i] = Buf[i + reglen];
	    Buf[i] = Buf[i + reglen];	/* terminate */
d3268 1
a3268 1
	    Mark = -1 - Mark;	/* Disable it */
d3273 1
a3273 1
	 * primitive emacs-like yank
d3277 3
a3279 2
	    return (0);
	} {
d3282 1
a3282 1
	    if (Pos + yanklen <= (MaxLen) && StrLen + yanklen <= (MaxLen)) {
d3285 2
a3286 2
		for (i = length; i >= Pos; i--)		/* Make room */
		    Buf[i + yanklen] = Buf[i];
d3307 1
a3307 1
	return (ch);
d3311 1
a3311 1
    return (0);
d3315 8
a3322 7
 *  This function prompts for a choice or page number.
 *  If a 'g' or 'p' suffix is included, that will be
 *  loaded into c.  Otherwise, c is zeroed. - FM & LE
 */
int get_popup_number(char *msg,
		     int *c,
		     int *rel)
d3329 1
a3329 1
     * Load the c argument into the prompt buffer.
d3336 1
a3336 1
     * Get the number, possibly with a suffix, from the user.
d3342 1
a3342 1
	return (0);
d3347 1
a3347 1
    while (isdigit(UCH(*p)))
d3349 2
a3350 3
    switch (*p) {
    case '+':
    case '-':
d3352 1
a3352 2
	*rel = *p++;
	*c = *p;
d3363 2
a3364 2
     * If we had a 'g' or 'p' suffix, load it into c.  Otherwise, zero c.  Then
     * return the number.
d3366 1
a3366 1
    if (*p == 'g' || *p == 'G') {
d3368 1
a3368 1
    } else if (*p == 'p' || *p == 'P') {
d3373 1
a3373 1
    if (*rel != '+' && *rel != '-')
d3384 1
a3384 1
#endif /* defined USE_COLOR_STYLE */
d3386 2
a3387 1
void LYRefreshEdit(EDREC * edit)
a3394 1

d3408 1
a3408 1
    length = strlen(&Buf[0]);
d3410 15
a3424 15
    /*
     * Now we have:
     *                .--DspWdth---.
     *      +---------+=============+-----------+
     *      |         |M           M|           |   (M=margin)
     *      +---------+=============+-----------+
     *      0         DspStart                   length
     *
     * Insertion point can be anywhere between 0 and stringlength.  Figure out
     * new display starting point.
     *
     * The first "if" below makes Lynx scroll several columns at a time when
     * extending the string.  Looks awful, but that way we can keep up with
     * data entry at low baudrates.
     */
d3428 1
a3428 1
	    DspStart = (Pos - DspWdth) + Margin;
d3461 4
a3464 4
	    DspStart = Pos - Margin;
	    if (DspStart < 0)
		DspStart = 0;
	}
d3474 1
a3474 1
    nrdisplayed = length - DspStart;
d3481 3
a3483 3
     * If this is the last screen line, set attributes to normal, should only
     * be needed for color styles.  The curses function may be used directly to
     * avoid complications.  - kw
d3493 1
a3493 1
	     prompting ? "prompt" : "active"));
d3497 1
a3497 1
	wattrset(LYwin, A_NORMAL);	/* need to do something about colors? */
d3509 2
a3510 2
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			      || (DspStart + i == Pos && Pos < Mark)))
d3512 2
a3513 2
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			      || (DspStart + i == Pos && Pos > Mark)))
d3565 1
a3565 1
     * Erase rest of input area.
d3567 1
a3567 1
    padsize = DspWdth - nrdisplayed;
d3576 1
a3576 1
     * Scrolling indicators.
d3589 1
a3589 1
		LYaddch(' ');	/* Needed with styles? */
d3599 1
a3599 1
		LYaddch(' ');	/* Needed with styles? */
d3614 3
a3616 1
static void reinsertEdit(EditFieldData *edit, char *result)
d3621 1
a3621 1
	    LYLineEdit(edit, (int) (*result), FALSE);
d3627 3
a3629 2
static int caselessCmpList(const void *a,
			   const void *b)
d3631 1
a3631 1
    return strcasecomp(*(const char *const *) a, *(const char *const *) b);
d3634 3
a3636 2
static int normalCmpList(const void *a,
			 const void *b)
d3638 1
a3638 1
    return strcmp(*(const char *const *) a, *(const char *const *) b);
d3641 3
a3643 1
static char **sortedList(HTList *list, BOOL ignorecase)
d3657 1
a3657 1
	qsort((char *) result, count, sizeof(*result),
d3664 1
a3664 1
		   && !strcmp(result[j], result[k])) {
d3669 1
a3669 1
		for (jk = j;; jk++) {
d3681 2
a3682 1
int LYarrayLength(const char **list)
d3691 2
a3692 1
int LYarrayWidth(const char **list)
d3705 5
a3709 4
static void FormatChoiceNum(char *dst,
			    int num_choices,
			    int choice,
			    const char *value)
a3712 1

d3714 2
a3715 2
		digits, (choice + 1),
		MAX_LINE - 9 - digits, value);
d3717 1
a3717 1
	LYstrncpy(dst, value, MAX_LINE - 1);
d3721 2
a3722 1
static unsigned options_width(const char **list)
d3736 8
a3743 6
static void draw_option(WINDOW * win, int entry,
			int width,
			BOOL reversed,
			int num_choices,
			int number,
			const char *value)
d3753 1
a3753 1
    SLsmg_write_nstring((char *) value, win->width);
d3784 3
a3786 2
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
d3788 2
a3789 1
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
d3791 10
a3800 9
int LYhandlePopupList(int cur_choice,
		      int ly,
		      int lx,
		      const char **choices,
		      int width,
		      int i_length,
		      int disabled,
		      BOOLEAN for_mouse,
		      BOOLEAN numbered)
d3804 1
a3804 1
    WINDOW *form_window;
d3813 1
a3813 1
    static char prev_target[MAX_LINE];	/* Search string buffer */
a3825 1

d3848 6
a3853 5
     * Count the number of choices to be displayed, where num_choices ranges
     * from 0 to n, and set width to the longest choice string length.  Also
     * set Lnum to the length for the highest choice number, then decrement
     * num_choices so as to be zero-based.  The window width will be based on
     * the sum of width and Lnum.  - FM
d3868 9
a3876 9
     * Let's assume for the sake of sanity that ly is the number corresponding
     * to the line the choice is on.
     *
     * Let's also assume that cur_choice is the number of the item that should
     * be initially selected, as 0 being the first item.
     *
     * So what we have, is the top equal to the current screen line subtracting
     * the cur_choice + 1 (the one must be for the top line we will draw in a
     * box).  If the top goes under 0, consider it 0.
d3883 2
a3884 2
     * Check and see if we need to put the i_length parameter up to the number
     * of real choices.
d3890 1
a3890 1
	 * Otherwise, it is really one number too high.
d3896 3
a3898 3
     * The bottom is the value of the top plus the number of options to view
     * plus 3 (one for the top line, one for the bottom line, and one to offset
     * the 0 counted in the num_choices).
d3903 1
a3903 1
     * Set lines_to_show based on the user_mode global.
d3906 1
a3906 1
	lines_to_show = LYlines - 4;
d3908 1
a3908 1
	lines_to_show = LYlines - 2;
d3914 1
a3914 1
     * Hmm...  If the bottom goes beyond the number of lines available,
d3918 2
a3919 2
	 * Position the window at the top if we have more choices than will fit
	 * in the window.
d3928 4
a3931 4
	     * Try to position the window so that the selected choice will
	     * appear where the selection box currently is positioned.  It
	     * could end up too high, at this point, but we'll move it down
	     * latter, if that has happened.
d3939 1
a3939 1
     * This is really fun, when the length is 4, it means 0 to 4, or 5.
d3946 1
a3946 1
     * Move the window down if it's too high.
d3957 2
a3958 2
	if (Lnum + (int) width + 4 < LYcols) {
	    if (lx - 1 + (Lnum + (int) width + 4) > LYcols)
d3966 2
a3967 2
     * Set up the overall window, including the boxing characters ('*'), if it
     * all fits.  Otherwise, set up the widest window possible.  - FM
d3970 3
a3972 5
	|| cur_choice > num_choices
	|| (form_window = LYstartPopup(top, lx,
				       bottom - top,
				       Lnum + width)) == 0)
	return (orig_choice);
d3975 2
a3976 1
     * Clear the command line and write the popup statusline.  - FM
d3986 2
a3987 2
	popup_status_msg =
	    gettext("Left mouse button or return to select, arrow keys to scroll.");
d3993 3
a3995 3
     * Set up the window_offset for choices.
     * cur_choice ranges from 0...n
     * length ranges from 0...m
d4002 1
a4002 1
     * Compute the number of popup window pages.  - FM
d4005 6
a4010 6
	(((num_choices + 1) + (length - 1)) / (length))
	: 1;
    /*
     * OH!  I LOVE GOTOs!  hack hack hack
     */
  redraw:
d4013 1
a4013 1
     * Display the boxed choices.
d4017 2
a4018 2
	    draw_option(form_window, ((i + 1) - window_offset), width, FALSE,
			max_choices, i, choices[i]);
d4021 1
a4021 1
    LYbox(form_window, (BOOLEAN) !numbered);
d4025 1
a4025 1
     * Loop on user input.
d4035 2
a4036 2
	    if (~can_scroll & can_scroll_was) {		/* Need to redraw */
		LYbox(form_window, (BOOLEAN) !numbered);
d4054 1
a4054 1
	 * Unreverse cur choice.
d4057 2
a4058 2
	    draw_option(form_window, row, width, FALSE,
			max_choices, i, Cptr[i]);
d4063 2
a4064 2
	draw_option(form_window, row, width, TRUE,
		    max_choices, cur_choice, Cptr[cur_choice]);
d4068 1
a4068 1
	if (term_options || LYCharIsINTERRUPT(c)) {	/* Control-C or Control-G */
d4074 1
a4074 1
	    if (cmd == LYK_ACTIVATE)
d4078 1
a4078 1
	    cmd = LKC_TO_LAC(keymap, c);
d4087 19
a4105 18
	switch (cmd) {
	case LYK_F_LINK_NUM:
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
	case LYK_9:
	    /*
	     * Get a number from the user, possibly with a 'g' or 'p' suffix
	     * (which will be loaded into c).  - FM & LE
	     */
	    number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);
d4107 19
a4125 25
	    /* handle + or - suffix */
	    CTRACE((tfp, "got popup option number %d, ", number));
	    CTRACE((tfp, "rel='%c', c='%c', cur_choice=%d\n",
		    rel, c, cur_choice));
	    if (c == 'p') {
		int curpage = ((cur_choice + 1) > length) ?
		(((cur_choice + 1) + (length - 1)) / (length))
		: 1;

		CTRACE((tfp, "  curpage=%d\n", curpage));
		if (rel == '+')
		    number = curpage + number;
		else if (rel == '-')
		    number = curpage - number;
	    } else if (rel == '+') {
		number = cur_choice + number + 1;
	    } else if (rel == '-') {
		number = cur_choice - number + 1;
	    }
	    if (rel)
		CTRACE((tfp, "new number=%d\n", number));
	    /*
	     * Check for a 'p' suffix.  - FM
	     */
	    if (c == 'p') {
d4127 1
a4127 1
		 * Treat 1 or less as the first page.  - FM
d4129 12
a4140 3
		if (number <= 1) {
		    if (window_offset == 0) {
			HTUserMsg(ALREADY_AT_OPTION_BEGIN);
d4142 1
a4142 1
			break;
a4143 5
		    window_offset = 0;
		    cur_choice = 0;
		    _statusline(popup_status_msg);
		    goto redraw;
		}
d4145 28
a4172 7
		/*
		 * Treat a number equal to or greater than the number of pages
		 * as the last page.  - FM
		 */
		if (number >= npages) {
		    if (window_offset >= ((num_choices - length) + 1)) {
			HTUserMsg(ALREADY_AT_OPTION_END);
d4176 1
a4176 6
		    window_offset = ((npages - 1) * length);
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }
		    if (cur_choice < window_offset)
			cur_choice = window_offset;
a4178 1
		}
a4179 11
		/*
		 * We want an intermediate page.  - FM
		 */
		if (((number - 1) * length) == window_offset) {
		    char *msg = 0;

		    HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
		    HTUserMsg(msg);
		    FREE(msg);
		    _statusline(popup_status_msg);
		    break;
a4180 5
		cur_choice = window_offset = ((number - 1) * length);
		_statusline(popup_status_msg);
		goto redraw;

	    }
a4181 5
	    /*
	     * Check for a positive number, which signifies that a choice
	     * should be sought.  - FM
	     */
	    if (number > 0) {
d4183 2
a4184 2
		 * Decrement the number so as to correspond with our cur_choice
		 * values.  - FM
d4186 6
a4191 1
		number--;
d4193 9
a4201 9
		/*
		 * If the number is in range and had no legal suffix, select
		 * the indicated choice.  - FM
		 */
		if (number <= num_choices && c == '\0') {
		    cur_choice = number;
		    cmd = LYK_ACTIVATE;
		    break;
		}
d4203 16
a4218 10
		/*
		 * Verify that we had a 'g' suffix, and act on the number.  -
		 * FM
		 */
		if (c == 'g') {
		    if (cur_choice == number) {
			/*
			 * The choice already is current.  - FM
			 */
			char *msg = 0;
d4220 21
a4240 6
			HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			HTUserMsg(msg);
			FREE(msg);
			_statusline(popup_status_msg);
			break;
		    }
a4241 1
		    if (number <= num_choices) {
d4243 1
a4243 2
			 * The number is in range and had a 'g' suffix, so make
			 * it the current option, scrolling if needed.  - FM
d4245 1
a4245 14
			j = (number - cur_choice);
			cur_choice = number;
			if ((j > 0) &&
			    (cur_choice - window_offset) >= length) {
			    window_offset += j;
			    if (window_offset > (num_choices - length + 1))
				window_offset = (num_choices - length + 1);
			} else if ((cur_choice - window_offset) < 0) {
			    window_offset -= abs(j);
			    if (window_offset < 0)
				window_offset = 0;
			}
			_statusline(popup_status_msg);
			goto redraw;
a4246 5

		    /*
		     * Not in range.  - FM
		     */
		    HTUserMsg(BAD_OPTION_NUM_ENTERED);
a4247 1
	    }
d4249 5
a4253 5
	    /*
	     * Restore the popup statusline.  - FM
	     */
	    _statusline(popup_status_msg);
	    break;
d4255 4
a4258 4
	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	case LYK_FASTBACKW_LINK:
	case LYK_UP_LINK:
d4260 2
a4261 2
	    if (cur_choice > 0)
		cur_choice--;
a4262 30
	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset--;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	case LYK_FASTFORW_LINK:
	case LYK_DOWN_LINK:
	    if (cur_choice < num_choices)
		cur_choice++;

	    /*
	     * Scroll the window down if necessary
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset++;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_PAGE:
	    /*
	     * Okay, are we on the last page of the list?  If not then,
	     */
	    if (window_offset != (num_choices - length + 1)) {
d4264 1
a4264 2
		 * Modify the current choice to not be a coordinate in the
		 * list, but a coordinate on the item selected in the window.
d4266 12
a4277 1
		cur_choice -= window_offset;
d4280 1
a4280 2
		 * Page down the proper length for the list.  If simply to far,
		 * back up.
d4282 3
a4284 3
		window_offset += length;
		if (window_offset > (num_choices - length)) {
		    window_offset = (num_choices - length + 1);
d4286 1
d4288 1
d4290 2
a4291 2
		 * Readjust the current selection to be a list coordinate
		 * rather than window.  Redraw this thing.
d4293 7
a4299 10
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice < num_choices) {
		/*
		 * Already on last page of the list so just redraw it with the
		 * last item selected.
		 */
		cur_choice = num_choices;
	    }
	    break;
d4301 8
a4308 10
	case LYK_PREV_PAGE:
	    /*
	     * Are we on the first page of the list?  If not then,
	     */
	    if (window_offset != 0) {
		/*
		 * Modify the current selection to not be a list coordinate,
		 * but a window coordinate.
		 */
		cur_choice -= window_offset;
d4310 14
a4323 6
		/*
		 * Page up the proper length.  If too far, back up.
		 */
		window_offset -= length;
		if (window_offset < 0) {
		    window_offset = 0;
d4325 1
d4327 1
d4329 2
a4330 1
		 * Readjust the current choice.
d4332 6
a4337 9
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice > 0) {
		/*
		 * Already on the first page so just back up to the first item.
		 */
		cur_choice = 0;
	    }
	    break;
d4339 8
a4346 7
	case LYK_HOME:
	    cur_choice = 0;
	    if (window_offset > 0) {
		window_offset = 0;
		goto redraw;
	    }
	    break;
d4348 13
a4360 7
	case LYK_END:
	    cur_choice = num_choices;
	    if (window_offset != (num_choices - length + 1)) {
		window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;
d4362 1
a4362 19
	case LYK_DOWN_TWO:
	    cur_choice += 2;
	    if (cur_choice > num_choices)
		cur_choice = num_choices;

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += 2;
		if (window_offset > (num_choices - length + 1))
		    window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_UP_TWO:
	    cur_choice -= 2;
	    if (cur_choice < 0)
d4364 1
a4364 7

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= 2;
		if (window_offset < 0)
d4366 3
a4368 3
		goto redraw;
	    }
	    break;
d4370 1
a4370 3
	case LYK_DOWN_HALF:
	    cur_choice += (length / 2);
	    if (cur_choice > num_choices)
d4372 1
a4372 7

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += (length / 2);
		if (window_offset > (num_choices - length + 1))
d4374 3
a4376 3
		goto redraw;
	    }
	    break;
d4378 4
a4381 4
	case LYK_UP_HALF:
	    cur_choice -= (length / 2);
	    if (cur_choice < 0)
		cur_choice = 0;
d4383 10
a4392 10
	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= (length / 2);
		if (window_offset < 0)
		    window_offset = 0;
		goto redraw;
	    }
	    break;
d4394 4
a4397 4
	case LYK_REFRESH:
	    lynx_force_repaint();
	    LYrefresh();
	    break;
a4398 2
	case LYK_NEXT:
	    if (recall && *prev_target_buffer == '\0') {
d4400 1
a4400 9
		 * We got a 'n'ext command with no prior query specified within
		 * the popup window.  See if one was entered when the popup was
		 * retracted, and if so, assume that's what's wanted.  Note
		 * that it will become the default within popups, unless
		 * another is entered within a popup.  If the within popup
		 * default is to be changed at that point, use WHEREIS ('/')
		 * and enter it, or the up- or down-arrow keys to seek any of
		 * the previously entered queries, regardless of whether they
		 * were entered within or outside of a popup window.  - FM
d4402 5
a4406 7
		if ((cp = (char *) HTList_objectAt(search_queries,
						   0)) != NULL) {
		    LYstrncpy(prev_target_buffer,
			      cp,
			      sizeof(prev_target_buffer) - 1);
		    QueryNum = 0;
		    FirstRecall = FALSE;
d4408 15
a4422 14
	    }
	    strcpy(prev_target, prev_target_buffer);
	    /* FALLTHRU */
	case LYK_WHEREIS:
	    if (*prev_target == '\0') {
		_statusline(ENTER_WHEREIS_QUERY);
		if ((ch = LYgetstr(prev_target, VISIBLE,
				   sizeof(prev_target_buffer),
				   recall)) < 0) {
		    /*
		     * User cancelled the search via ^G.  - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
d4424 6
a4429 1
	    }
a4430 3
	  check_recall:
	    if (*prev_target == '\0' &&
		!(recall && (ch == UPARROW || ch == DNARROW))) {
d4432 1
a4432 1
		 * No entry.  Simply break.  - FM
d4434 12
a4445 3
		HTInfoMsg(CANCELLED);
		goto restore_popup_statusline;
	    }
d4447 2
a4448 2
	    if (recall && ch == UPARROW) {
		if (FirstRecall) {
d4450 12
a4461 1
		     * Use the current string or last query in the list.  - FM
d4463 3
a4465 12
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = (QueryTotal - 1);
			     QueryNum > 0; QueryNum--) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(prev_target_buffer, cp)) {
				break;
			    }
			}
		    } else {
d4467 1
a4468 5
		} else {
		    /*
		     * Go back to the previous query in the list.  - FM
		     */
		    QueryNum++;
d4470 5
a4474 19
		if (QueryNum >= QueryTotal) {
		    /*
		     * Roll around to the last query in the list.  - FM
		     */
		    QueryNum = 0;
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((*prev_target_buffer && QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
		    }
d4476 2
a4477 1
				       sizeof(prev_target_buffer), recall)) < 0) {
d4479 1
a4479 1
			 * User cancelled the search via ^G.  - FM
a4483 1
		    goto check_recall;
d4485 4
a4488 2
	    } else if (recall && ch == DNARROW) {
		if (FirstRecall) {
d4490 1
a4490 1
		     * Use the current string or first query in the list.  - FM
d4492 75
a4566 9
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(prev_target_buffer, cp)) {
				break;
d4568 2
d4572 9
d4583 46
a4628 1
		} else {
d4630 1
a4630 1
		     * Advance to the next query in the list.  - FM
d4632 1
a4632 3
		    QueryNum--;
		}
		if (QueryNum < 0) {
d4634 1
a4634 1
		     * Roll around to the first query in the list.  - FM
d4636 5
a4640 15
		    QueryNum = (QueryTotal - 1);
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((*prev_target_buffer &&
				QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
d4642 1
a4642 10
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 * User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		    goto check_recall;
a4643 6
	    }
	    /*
	     * Replace the search string buffer with the new target.  - FM
	     */
	    strcpy(prev_target_buffer, prev_target);
	    HTAddSearchQuery(prev_target_buffer);
a4644 14
	    /*
	     * Start search at the next choice.  - FM
	     */
	    for (j = 1; Cptr[i + j] != NULL; j++) {
		FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i + j]);
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
			break;
		}
	    }
	    if (Cptr[i + j] != NULL) {
d4646 1
a4646 1
		 * We have a hit, so make that choice the current.  - FM
d4648 5
a4652 1
		cur_choice += j;
d4654 1
a4654 1
		 * Scroll the window down if necessary.
d4656 26
a4681 5
		if ((cur_choice - window_offset) >= length) {
		    window_offset += j;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    ReDraw = TRUE;
a4682 2
		goto restore_popup_statusline;
	    }
d4684 3
a4686 4
	    /*
	     * If we started at the beginning, it can't be present.  - FM
	     */
	    if (cur_choice == 0) {
a4687 2
		goto restore_popup_statusline;
	    }
d4689 1
a4689 14
	    /*
	     * Search from the beginning to the current choice.  - FM
	     */
	    for (j = 0; j < cur_choice; j++) {
		FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
			break;
		}
	    }
	    if (j < cur_choice) {
d4691 2
a4692 1
		 * We have a hit, so make that choice the current.  - FM
d4694 9
a4702 10
		j = (cur_choice - j);
		cur_choice -= j;
		/*
		 * Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= j;
		    if (window_offset < 0)
			window_offset = 0;
		    ReDraw = TRUE;
d4704 1
a4704 2
		goto restore_popup_statusline;
	    }
d4706 7
a4712 29
	    /*
	     * Didn't find it in the preceding choices either.  - FM
	     */
	    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);

	  restore_popup_statusline:
	    /*
	     * Restore the popup statusline and reset the search variables.  -
	     * FM
	     */
	    _statusline(popup_status_msg);
	    *prev_target = '\0';
	    QueryTotal = (search_queries ? HTList_count(search_queries)
			  : 0);
	    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
	    QueryNum = QueryTotal;
	    if (ReDraw == TRUE) {
		ReDraw = FALSE;
		goto redraw;
	    }
	    break;

	case LYK_QUIT:
	case LYK_ABORT:
	case LYK_PREV_DOC:
	case LYK_INTERRUPT:
	    cur_choice = orig_choice;
	    cmd = LYK_ACTIVATE;	/* to exit */
	    break;
d4717 1
a4717 1
    return (disabled ? orig_choice : cur_choice);
d4722 5
a4726 4
int LYgetstr(char *inputline,
	     int hidden,
	     size_t bufsize,
	     RecallType recall)
a4733 1

d4740 3
a4742 3
	(bufsize - 1) : (sizeof(MyEdit.buffer) - 1);
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, (LYcols - 1) - x);
    MyEdit.hidden = (BOOL) hidden;
d4746 1
a4746 1
      again:
d4755 1
a4755 1
#ifdef CJK_EX			/* for SJIS code */
d4757 1
a4757 1
	    && (EditBinding(ch) != LYE_CHAR))
d4761 2
a4762 2
	    && (EditBinding(ch) != LYE_CHAR)
	    && (EditBinding(ch) != LYE_AIX))
d4769 1
a4769 1
	    || HadVMSInterrupt
d4772 1
a4772 1
	    || term_message
d4774 1
a4774 1
	    ) {
d4782 1
a4782 1
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
d4785 1
a4785 1
	    return (ch);
d4795 1
a4795 1
	if (LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
d4809 1
a4809 1
	     * Set flag for modifier 1.
d4815 1
a4815 1
	     * Set flag for modifier 2.
a4821 1

d4823 1
a4823 1
		    char **data = sortedList(list, (BOOL) (recall == RECALL_CMD));
d4826 1
a4826 1
		    int num_options = LYarrayLength((const char **) data);
d4829 1
a4829 1
			   && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
d4833 10
a4842 9
		    cur_choice = LYhandlePopupList(cur_choice,
						   0,
						   old_x,
						   (const char **) data,
						   -1,
						   -1,
						   FALSE,
						   FALSE,
						   TRUE);
d4856 1
a4856 1
#ifndef CJK_EX			/* 1997/11/03 (Mon) 20:13:45 */
d4859 4
a4862 4
	     * Hex 97.
	     * Treat as a character for CJK, or if this is a valid character in
	     * the current display character set.  Otherwise, we treat this as
	     * LYE_ENTER.
d4866 3
a4868 2
		 LYlowest_eightbit[current_char_set] <= 0x97)) {
		LYLineEdit(&MyEdit, ch, FALSE);
d4875 1
a4875 1
	     * Terminate the string and return.
d4877 1
a4877 1
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
d4881 1
a4881 1
	    return (ch);
d4884 1
a4884 1
	    /* 1998/10/01 (Thu) 15:05:49 */
d4900 1
a4900 1
			if (*e1 < ' ') {	/* Stop here? */
d4904 2
a4905 6
			    if (*e1 == '\t') {	/* Replace by space */
				LYEditInsert(&MyEdit,
					     (unsigned char *) " ",
					     1,
					     map_active,
					     TRUE);
d4922 1
a4922 1
	     * Control-C or Control-G aborts.
d4926 1
a4926 1
	    return (-1);
d4930 1
a4930 1
	     * Deactivate.
d4935 1
a4935 1
	    return (-1);
d4939 1
a4939 1
		Mark = -1 - Mark;	/* Disable it */
d4946 3
a4948 2
	     * Used only in form_getstr() for invoking the LYK_F_LINK_NUM
	     * prompt when in form text fields.  - FM
d4954 3
a4956 2
	     * Used in form_getstr() to end line editing and pass on the input
	     * char/lynxkeycode.  Here it is just ignored.  - kw
d4963 3
a4965 3
		 * Used in form_getstr() to end line editing and pass on the
		 * lynxkeycode already containing a lynxactioncode.  Here it is
		 * just ignored.  - kw
d4969 1
d4988 1
a4988 1
const char *LYLineeditHelpURL(void)
a4992 1

d5012 1
a5012 1
 * A replacement for 'strsep()'
d5014 3
a5016 2
char *LYstrsep(char **stringp,
	       const char *delim)
d5020 2
a5021 2
    if (isEmpty(stringp))	/* nothing to do? */
	return 0;		/* then don't fall on our faces */
d5023 1
a5023 1
    out = *stringp;		/* save the start of the string */
d5026 5
a5030 5
	*tmp = '\0';		/* terminate the substring with \0 */
	*stringp = ++tmp;	/* point at the next substring */
    } else
	*stringp = 0;		/* this was the last substring: */
    /* let caller see he's done */
d5035 8
a5042 6
 * LYstrstr will find the first occurrence of the string pointed to by tarptr
 * in the string pointed to by chptr.  It returns NULL if string not found.  It
 * is a case insensitive search.
 */
char *LYstrstr(char *chptr,
	       const char *tarptr)
d5046 1
a5046 1
    for (; *chptr != '\0'; chptr++) {
d5048 2
a5049 2
	    if (0 == strncasecomp8(chptr + 1, tarptr + 1, len - 1))
		return (chptr);
d5051 1
a5051 1
    }				/* end for */
d5053 1
a5053 1
    return (NULL);		/* string not found or initial chptr was empty */
d5057 3
a5059 3
 * LYno_attr_char_case_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
d5065 1
a5065 1
 * It is a case insensitive search.
d5067 3
a5069 2
char *LYno_attr_char_case_strstr(char *chptr,
				 char *tarptr)
d5074 1
a5074 1
	return (NULL);
d5080 1
a5080 1
	if (0 == UPPER8(*chptr, *tarptr)) {
d5082 1
a5082 1
	     * See if they line up.
d5084 2
a5085 2
	    tmpchptr = chptr + 1;
	    tmptarptr = tarptr + 1;
d5087 2
a5088 2
	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);
d5100 1
a5100 1
		    return (chptr);
d5105 1
a5105 1
    }				/* end for */
d5107 1
a5107 1
    return (NULL);
d5111 3
a5113 3
 * LYno_attr_char_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
d5119 1
a5119 1
 * It is a case sensitive search.
d5121 3
a5123 2
char *LYno_attr_char_strstr(char *chptr,
			    char *tarptr)
d5128 1
a5128 1
	return (NULL);
d5136 1
a5136 1
	     * See if they line up.
d5141 2
a5142 2
	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);
d5145 1
a5145 1
		if (!IsSpecialAttrChar(*tmpchptr)) {
d5150 1
a5150 1
		} else {
d5152 5
a5156 5
		}
		if (*tmptarptr == '\0')
		    return (chptr);
		if (*tmpchptr == '\0')
		    break;
d5159 1
a5159 1
    }				/* end for */
d5161 1
a5161 1
    return (NULL);
d5166 9
a5174 10
 * pointed to by tarptr in the string pointed to by chptr.  It takes account of
 * MultiByte Character Sequences (UTF8).  The physical lengths of the displayed
 * string up to the start and end (= next position after) of the target string
 * are returned in *nstartp and *nendp if the search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
d5182 1
a5182 1
 * It is a case insensitive search.  - KW & FM
d5184 7
a5190 6
char *LYno_attr_mbcs_case_strstr(char *chptr,
				 const char *tarptr,
				 BOOL utf_flag,
				 BOOL count_gcells,
				 int *nstartp,
				 int *nendp)
d5198 1
a5198 1
	return (NULL);
d5201 1
a5201 1
     * Skip initial IsSpecial chars.  - FM
d5207 1
a5207 1
     * Seek a first target match.  - FM
a5215 1

d5220 1
a5220 1
	     * See if they line up.
d5227 1
a5227 1
		 * One char target.
d5229 3
a5231 5
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
d5234 3
a5236 3
		*chptr == *tarptr &&
		*tmpchptr != '\0' &&
		!IsSpecialAttrChar(*tmpchptr)) {
d5238 1
a5238 1
		 * Check the CJK multibyte.  - FM
d5242 1
a5242 1
		     * It's a match.  Advance to next char.  - FM
d5246 1
a5246 2
		    if (count_gcells)
			tarlen++;
d5249 1
a5249 1
			 * One character match.  - FM
d5251 3
a5253 5
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
d5257 2
a5258 2
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
d5261 1
a5261 2
		    if (count_gcells)
			len++;
d5266 1
a5266 1
	     * See if the rest of the target matches.  - FM
d5276 1
a5276 2
			    if (count_gcells)
				tarlen++;
d5295 3
a5297 5
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
d5303 1
a5303 1
		     IsSpecialAttrChar(*chptr))) {
d5308 1
a5308 2
		if (count_gcells)
		    len++;
d5312 1
a5312 1
    }				/* end for */
d5314 1
a5314 1
    return (NULL);
d5318 10
a5327 13
 * LYno_attr_mbcs_strstr will find the first occurrence of the string pointed
 * to by tarptr in the string pointed to by chptr.
 *
 * It takes account of CJK and MultiByte Character Sequences (UTF8).  The
 * physical lengths of the displayed string up to the start and end (= next
 * position after) the target string are returned in *nstartp and *nendp if the
 * search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
d5335 1
a5335 1
 * It is a case sensitive search.  - KW & FM
d5337 7
a5343 6
char *LYno_attr_mbcs_strstr(char *chptr,
			    const char *tarptr,
			    BOOL utf_flag,
			    BOOL count_gcells,
			    int *nstartp,
			    int *nendp)
d5351 1
a5351 1
	return (NULL);
d5354 1
a5354 1
     * Skip initial IsSpecial chars.  - FM
d5360 1
a5360 1
     * Seek a first target match.  - FM
a5364 1

d5369 1
a5369 1
	     * See if they line up.
d5376 1
a5376 1
		 * One char target.
d5378 3
a5380 5
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
d5383 2
a5384 2
		*tmpchptr != '\0' &&
		!IsSpecialAttrChar(*tmpchptr)) {
d5386 1
a5386 1
		 * Check the CJK multibyte.  - FM
d5390 1
a5390 1
		     * It's a match.  Advance to next char.  - FM
d5394 1
a5394 2
		    if (count_gcells)
			tarlen++;
d5397 1
a5397 1
			 * One character match.  - FM
d5399 3
a5401 5
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
d5405 2
a5406 2
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
d5409 1
a5409 2
		    if (count_gcells)
			len++;
d5414 1
a5414 1
	     * See if the rest of the target matches.  - FM
d5417 1
a5417 1
		if (!IsSpecialAttrChar(*tmpchptr)) {
d5424 1
a5424 2
			    if (count_gcells)
				tarlen++;
d5437 1
a5437 1
		} else {
d5439 1
a5439 1
		}
d5441 5
a5445 7
		if (*tmptarptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
		}
d5447 1
a5447 1
		    break;
d5450 1
a5450 1
		     IsSpecialAttrChar(*chptr))) {
d5455 1
a5455 2
		if (count_gcells)
		    len++;
d5459 1
a5459 1
    }				/* end for */
d5461 1
a5461 1
    return (NULL);
d5465 1
a5465 1
 * Allocate a new copy of a string, and returns it.
d5467 4
a5470 3
char *SNACopy(char **dest,
	      const char *src,
	      int n)
a5474 1

d5479 2
a5480 2
	strncpy(*dest, src, n);
	*(*dest + n) = '\0';	/* terminate */
d5486 1
a5486 1
 * String Allocate and Concatenate.
d5488 4
a5491 3
char *SNACat(char **dest,
	     const char *src,
	     int n)
d5496 1
a5496 2

	    *dest = (char *) realloc(*dest, length + n + 1);
d5500 1
a5500 1
	    *(*dest + length + n) = '\0';	/* terminate */
a5502 1

d5506 1
a5506 1
	    (*dest)[n] = '\0';	/* terminate */
d5518 1
a5518 1
static long UniToLowerCase(long upper)
d5524 1
a5524 1
     * Make check for sure.
d5527 1
a5527 1
	return (upper);
d5530 1
a5530 1
     * Try unicode_to_lower_case[].
d5536 3
a5538 3
	 * Binary search.
	 */
	i = (low + (high - low) / 2);
d5541 1
a5541 1
	    low = i + 1;
d5548 1
a5548 1
    return (upper);		/* if we came here */
d5552 13
a5564 13
 *   UPPER8 ?
 *   it was "TOUPPER(a) - TOUPPER(b)" in its previous life...
 *
 *   It was realized that case-insensitive user search
 *   got information about upper/lower mapping from TOUPPER
 *   (precisely from "(TOUPPER(a) - TOUPPER(b))==0")
 *   and depends on locale in its 8bit mapping. -
 *   Usually fails with DOS/WINDOWS display charsets
 *   as well as on non-UNIX systems.
 *
 *   So use unicode case mapping.
 */
int UPPER8(int ch1, int ch2)
d5576 1
a5576 1
	return (TOUPPER(ch1) - TOUPPER(ch2));
d5579 3
a5581 2
    if (UCH(TOASCII(ch1)) > 127 &&	/* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127) {
d5583 4
a5586 3
	    return (TOUPPER(ch1) - TOUPPER(ch2));	/* old-style */
	else {
	    long uni_ch2 = UCTransToUni((char) ch2, current_char_set);
a5587 1

d5590 2
a5591 2
	    uni_ch1 = UCTransToUni((char) ch1, current_char_set);
	    return (UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
d5595 1
a5595 1
    return (-10);		/* mismatch, if we come to here */
d5603 3
a5605 2
char *LYSafeGets(char **src,
		 FILE *fp)
d5625 3
a5627 2
	 * If the file ends in the middle of a line, return the partial line;
	 * if another call is made after this, it will return NULL.  - kw
d5640 3
a5642 2
void LYOpenCmdLogfile(int argc,
		      char **argv)
d5650 1
a5650 1
		    LYNX_NAME, LYNX_VERSION, LYVersionDate());
d5658 1
a5658 1
BOOL LYHaveCmdScript(void)
d5660 1
a5660 1
    return (BOOL) (cmd_script != 0);
d5663 1
a5663 1
void LYOpenCmdScript(void)
d5673 2
a5674 1
int LYReadCmdKey(int mode)
d5726 1
a5726 2
    CTRACE((tfp, "LYReadCmdKey(%d) ->%s (%#x)\n",
	    mode, LYKeycodeToString(ch, TRUE), ch));
d5734 2
a5735 1
void LYWriteCmdKey(int ch)
d5742 1
a5742 1
void LYCloseCmdLogfile(void)
@


1.1.3.6
log
@Tom Dickey provides us with another high-quality development
snapshot of The Webbrowser; thanks for your good work!
@
text
@d375 1
a375 1
    int right = LYcolLimit - 5;
d389 1
a389 1
	else if (y == 0 && x == LYcolLimit && s_hot_paste != NOSTYLE)
d425 1
a425 1
    } else if (x == (LYcols - 1) && LYShowScrollbar && LYsb_begin >= 0) {
d662 17
a678 24
    if (non_empty(str)) {
#ifdef WIDEC_CURSES
	if (count_gcells) {
	    len = LYstrCells(str);
	} else
#endif
	{
	    for (i = 0; str[i] != '\0'; i++) {
		if (!IsSpecialAttrChar(str[i])) {
		    len++;
		    if (IS_NEW_GLYPH(str[i])) {
			j = 0;
			while (IsNormalChar(str[(i + 1)]) &&
			       j < 5 &&
			       IS_UTF_EXTRA(str[(i + 1)])) {
			    i++;
			    j++;
			}
		    } else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
			       is8bits(str[i]) &&
			       IsNormalChar(str[(i + 1)])) {
			i++;
		    }
		}
d680 4
d686 1
d2256 1
a2256 1
		int right = (LYcolLimit - H_CMD_AREA - 1);
d2683 1
a2683 1
    if (len > (LYcolLimit - 9)) {
d2686 1
a2686 1
	for (s = (buff + len) - (LYcolLimit - 9) + cut_pos + 1,
a4009 3
	int check = (Lnum + (int) width + 4);
	int limit = LYcols;

d4011 3
a4013 3
	if (check < limit) {
	    if (lx - 1 + check > limit)
		lx = limit + 1 - check;
a4022 3
    width += Lnum;
    bottom -= top;

d4025 3
a4027 4
	|| (form_window = LYstartPopup(&top,
				       &lx,
				       &bottom,
				       &width)) == 0)
a4029 3
    width -= Lnum;
    bottom += top;

d4788 1
a4788 1
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, LYcolLimit - x);
d5255 2
a5256 1
	     IsNormalChar(*(chptr + 1))) ||
d5281 2
a5282 1
		IsNormalChar(*tmpchptr)) {
d5358 2
a5359 1
		IsNormalChar(*(chptr + 1))) {
d5442 2
a5443 1
		IsNormalChar(*tmpchptr)) {
d5518 2
a5519 1
		IsNormalChar(*(chptr + 1))) {
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a2 2
#include <UCAux.h>
#include <LYGlobalDefs.h>
d5 1
a15 1
#include <HTList.h>
a16 3
#ifdef USE_MOUSE
#include <LYMainLoop.h>
#endif
a27 5
#ifdef USE_SCROLLBAR
#include <LYMainLoop.h>
#endif

#include <LYShowInfo.h>
d30 1
d32 1
d34 2
a35 9
#if defined(WIN_EX)
#undef  BUTTON_CTRL
#define BUTTON_CTRL	0	/* Quick hack */
#endif

/*
 * The edit_history lists allow the user to press tab when entering URL to get
 * the closest match in the closet
 */
d37 2
d40 4
a43 2
static HTList *URL_edit_history;
static HTList *MAIL_edit_history;
d61 1
a61 1
#if defined(USE_MOUSE) && defined(NCURSES)
d68 2
a69 2
#if defined(USE_MOUSE) && defined(NCURSES)
    if (have_levent > 0) {
a70 1
	have_levent--;
a93 1

d100 6
a105 43
#ifdef USE_MOUSE
/*********************************************************************/

#if defined(WIN_EX) && defined(PDCURSES)

    request_mouse_pos();

    if (BUTTON_STATUS(1)
      && (MOUSE_X_POS >= getbegx(win)
      && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
	int mypos = MOUSE_Y_POS - getbegy(win);
	int delta = mypos - row;

	if (mypos+1 == getmaxy(win)) {
	    /* At the decorative border: scroll forward */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_END;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_NEXT_PAGE;
	    else
		cmd = LYK_NEXT_LINK;
	} else if (mypos >= getmaxy(win)) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_END;
	    else
		cmd = LYK_NEXT_PAGE;
	} else if (mypos == 0) {
	    /* At the decorative border: scroll back */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_HOME;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_PREV_PAGE;
	    else
		cmd = LYK_PREV_LINK;
	} else if (mypos < 0) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_HOME;
	    else
		cmd = LYK_PREV_PAGE;
#ifdef KNOW_HOW_TO_TOGGLE
	} else if (BUTTON_STATUS(1) & (BUTTON_CTRL)) {
	    cur_selection += delta;
	    cmd = LYX_TOGGLE;
a106 16
	} else if (BUTTON_STATUS(1) & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)) {
	    /* Probably some unrelated activity, such as selecting some text.
	     * Select, but do nothing else.
	     */
	    *position += delta;
	    cmd = -1;
	} else {
	    /* No scrolling or overflow checks necessary. */
	    *position += delta;
	    cmd = LYK_ACTIVATE;
	}
    } else if (BUTTON_STATUS(1) & (BUTTON3_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED)) {
	cmd = LYK_QUIT;
    }
#else
#if defined(NCURSES)
d111 4
a114 2
			      | BUTTON1_DOUBLE_CLICKED
			      | BUTTON1_TRIPLE_CLICKED))) {
a117 3
	if ((event.x < getbegx(win) || event.x >= (getbegx(win) + getmaxx(win)))
	    && !(event.bstate & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)))
	    return LYK_QUIT;	/* User clicked outside, wants to quit? */
a150 8
	} else if (event.x <= getbegx(win) + 1 ||
		   event.x >= getbegx(win) + getmaxx(win) - 2) {
	    /* Click on left or right border for positioning without
	     * immediate action: select, but do nothing else.
	     * Actually, allow an error of one position inwards. - kw
	     */
	    *position += delta;
	    cmd = -1;
a154 4
	    /* Possibly this is never returned by ncurses, so this case
	     * may be useless depending on situation (kind of mouse support
	     * and library versions). - kw
	     */
d160 9
d174 1
a174 5
#endif /* NCURSES */
#endif	/* _WINDOWS */

/************************************************************************/
#endif  /* USE_MOUSE */
a177 76
/*
 * Manage the collection of edit-histories
 */
PRIVATE HTList *whichRecall ARGS1(
    RecallType,		recall)
{
    HTList **list;

    switch (recall) {
    case RECALL_CMD:
	return LYcommandList();
    case RECALL_MAIL:
	list = &MAIL_edit_history;
	break;
    default:
	list = &URL_edit_history;
	break;
    }
    if (*list == 0)
	*list = HTList_new();
    return *list;
}

/*
 * Remove the oldest item in the closet
 */
PRIVATE void LYRemoveFromCloset ARGS1(HTList *, list)
{
    char *data = HTList_removeFirstObject(list);

    if (data != 0)
	FREE(data);
}

PUBLIC void LYCloseCloset ARGS1(RecallType, recall)
{
    HTList *list = whichRecall(recall);

    while (!HTList_isEmpty(list) ) {
	LYRemoveFromCloset(list);
    }
    HTList_delete(list);	/* should already be empty */
}

/*
 * Strategy:  We begin at the top and search downwards.  We return the first
 * match, i.e., the newest since we search from the top.  This should be made
 * more intelligent, but works for now.
 */
PRIVATE char * LYFindInCloset ARGS2(RecallType, recall, char*, base)
{
    HTList *list = whichRecall(recall);
    char *data;
    unsigned len = strlen(base);

    while (!HTList_isEmpty(list)) {
	data = HTList_nextObject(list);
	if (!strncmp(base, data, len))
	    return(data);
    }

    return(0);
}

PRIVATE void LYAddToCloset ARGS2(RecallType, recall, char*, str)
{
    HTList *list = whichRecall(recall);
    char *data = NULL;

    StrAllocCopy(data, str);
    HTList_addObject(list, data);
    while (HTList_count(list) > LYClosetSize)
	LYRemoveFromCloset(list);
}


d185 1
a185 1
    int xerr = 3 * (x2 - x1), yerr = 9 * (y2 - y1);
d188 1
a188 1
	xerr = 3 * (x1 - x2 - dx2) + 1;	/* pos after string not really in it */
d193 1
a193 18
    if (!yerr)			/* same line is good */
	return (xerr > 0) ? (xerr*2 - 1) : 0;
    if (xerr < 9 && yerr)   /* x-dist of 3 cell better than y-dist of 1 cell */
	yerr += (9 - xerr);
    return 2 * xerr + yerr; /* Subjective factor; ratio -> approx. 6 / 9 */
/*
old: (IZ 1999-07-30)
 3  2  2  2  1  1  1 XX XX XX XX XX  0  1  1  1  2  2  2  3  3
 4\ 3  3  3  2  2  2  2  2  2  2  2  2  2  2  2  3  3  3/ 4  4
 5  4  4  4\ 3  3  3  3  3  3  3  3  3  3  3  3/ 4  4  4  5  5
 6  5  5  5  4  4  4  4  4  4  4  4  4  4  4  4  5  5  5  6  5
now: (kw 1999-10-23)
41 35 29|23 17 11  5 XX XX XX XX XX  1  7 13 19 25|31 37 43 49
   45 39 33\27 24 21 18 18 18 18 18 19 22 25 28/34 40 46 50
      48 42 36 33 30\27 27 27 27 27 28/31 34 37 43 49
         51 45 42 39 36 36 36 36 36 37 40 43 46 49
               51 48 45 45 45 45 45 46 49 52
*/
d203 1
a203 1
PRIVATE int set_clicked_link ARGS4(
d206 1
a206 2
    int,	code,
    int,	clicks)
d214 1
a214 4
    if (y == (LYlines-1) || y == 0) {	/* First or last row */
	/* XXXX In fact # is not always at x==0?  KANJI_CODE_OVERRIDE? */
	int toolbar = (y == 0 && HText_hasToolbar(HTMainText));

d216 4
a219 38
	if (x == 0 && toolbar)		/* On '#' */
	    c = LAC_TO_LKC0(LYK_TOOLBAR);
	else if (clicks > 1) {
	    if (x < left + toolbar)
		c = (code==FOR_PROMPT && y)
		    ? HOME : LAC_TO_LKC0(LYK_MAIN_MENU);
	    else if (x > right)
		c = (code==FOR_PROMPT && y)
		    ? END_KEY : LAC_TO_LKC0(LYK_VLINKS);
	    else if (y)			/* Last row */
		c = LAC_TO_LKC0(LYK_END);
	    else			/* First row */
		c = LAC_TO_LKC0(LYK_HOME);
	} else {
	    if (x < left + toolbar)
		c = (code==FOR_PROMPT && y)
		    ? LTARROW
		    : (
#ifdef USE_COLOR_STYLE
			(s_forw_backw != NOSTYLE && x - toolbar >= 3)
			? LAC_TO_LKC0(LYK_NEXT_DOC)
			: LAC_TO_LKC0(LYK_PREV_DOC)
#else
			LAC_TO_LKC0(LYK_NEXT_DOC)
#endif
			);
	    else if (x > right)
		c = (code==FOR_PROMPT && y)
		    ? RTARROW : LAC_TO_LKC0(LYK_HISTORY);
	    else if (y)			/* Last row */
		c = LAC_TO_LKC0(LYK_NEXT_PAGE);
	    else			/* First row */
		c = LAC_TO_LKC0(LYK_PREV_PAGE);
	}
#ifdef USE_SCROLLBAR
    } else if (x == LYcols - 1 && LYsb && LYsb_begin >= 0) {
	int h = display_lines - 2*(LYsb_arrow != 0);

d221 3
a223 22
	y -= 1 + (LYsb_arrow != 0);
	if (y < 0)
	    return LAC_TO_LKC0(LYK_UP_TWO);
	if (y >= h)
	    return LAC_TO_LKC0(LYK_DOWN_TWO);

	if (clicks >= 2) {
	    double frac = (1. * y)/(h - 1);
	    int l = HText_getNumOfLines() + 1;	/* NOL() off by one? */

	    l -= display_lines;
	    if (l > 0)
		LYSetNewline((int)(frac * l + 1 + 0.5));
	    return LYReverseKeymap(LYK_DO_NOTHING);
	}

	if (y < LYsb_begin)
	    return LAC_TO_LKC0(LYK_PREV_PAGE);
	if (y >= LYsb_end)
	    return LAC_TO_LKC0(LYK_NEXT_PAGE);
	mouse_link = -1;		/* No action in edit fields */
#endif
d225 1
a225 2
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */
	    cur_err;
d232 3
a234 1
		&& F_TEXTLIKE(links[i].form->type))
a244 12
		/* Check the second line */
		if (cur_err > 0 && links[i].hightext2 != NULL) {
		    /* Note that there is never hightext2 if is_text */
		    int cur_err_2 = XYdist(x, y,
					   links[i].hightext2_offset,
					   links[i].ly+1,
					   strlen(links[i].hightext2));
		    cur_err = HTMIN(cur_err, cur_err_2);
		}
		if (cur_err > 0 && is_text)
		    cur_err--;	/* a bit of preference for text fields,
				   enter field if hit exactly at end - kw */
a248 16
		    /* double-click, if we care:
		       submit text submit fields. - kw */
		    if (clicks > 1 && is_text &&
			links[i].form->type == F_TEXT_SUBMIT_TYPE) {
			if (code != FOR_INPUT
			    /* submit current input field directly */
			    || !(cury == y && (curx >= lx) && ((curx - lx) <= len))) {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = i;
			} else {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
			    mouse_link = -1;
			}
			mouse_err = 0;
			break;
		    }
d252 1
a252 1
			if (is_text) {
a253 5
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
			    if (x == links[i].lx && y == links[i].ly)
				textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
			}
d264 15
d286 4
a289 5
	    if (mouse_err == 0) {
		if (c == -1)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
	    } else if (mouse_err >= 0)
		c = LAC_TO_LKC0(LYK_CHANGE_LINK);
d296 14
d316 1
a316 1
	char *,		dst,
d338 2
a339 2
#define IS_NEW_GLYPH(ch) (utf_flag && (UCH(ch)&0xc0) != 0x80)
#define IS_UTF_EXTRA(ch) (utf_flag && (UCH(ch)&0xc0) == 0x80)
d349 1
a349 1
	char *,		dst,
d383 1
a383 1
	char *,		data,
a411 4
 *  Counts glyph cells if count_gcells is set. (Full-width
 *  characters in CJK mode count as two.)
 *  Counts character glyphs if count_gcells is unset. (Full-
 *  width characters in CJK mode count as one.) - kw
d413 3
a415 4
PUBLIC int LYmbcsstrlen ARGS3(
	char *,		str,
	BOOL,		utf_flag,
	BOOL,		count_gcells)
d437 2
a438 2
	} else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
		   !isascii(str[i]) && str[(i + 1)] != '\0' &&
a459 3
#ifdef __CYGWIN__
#define GetChar SLkp_getkey
#else
a460 1
#endif /* __CYGWIN__ */
d466 1
a466 31
#define GetChar() wgetch(my_subwindow ? my_subwindow : LYwin)
#endif

#if !defined(GetChar) && defined(PDCURSES)
/* PDCurses sends back key-modifiers that we don't use, but would waste time
 * upon, e.g., repainting the status line
 */
PRIVATE int myGetChar NOARGS
{
    int c;
    BOOL done = FALSE;

    do {
	switch (c = wgetch(LYwin))
	{
	case KEY_SHIFT_L :
	case KEY_SHIFT_R :
	case KEY_CONTROL_L :
	case KEY_CONTROL_R :
	case KEY_ALT_L :
	case KEY_ALT_R :
	case KEY_RESIZE :
	    break;
	default:
	    done = TRUE;
	    break;
	}
    } while (!done);
    return c;
}
#define GetChar() myGetChar()
d470 1
a470 1
#define GetChar() wgetch(LYwin)
d479 1
a479 1
#define GetChar() getch()
d488 1
a495 1
#ifndef USE_SLANG
d500 2
a501 15
    if (param != 0) {
	my_subwindow = param;
#if defined(NCURSES) || defined(PDCURSES)
	keypad(my_subwindow, TRUE);
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
	wbkgd(my_subwindow, getbkgd(LYwin));
	wbkgdset(my_subwindow, getbkgd(LYwin));
#endif
#endif
	scrollok(my_subwindow, TRUE);
    } else {
	touchwin(LYwin);
	delwin(my_subwindow);
	my_subwindow = 0;
    }
d505 1
a505 2

#if defined(USE_SLANG) && defined(USE_MOUSE)
d525 2
a526 10
    *x = SLang_getkey ();
    if (*x == CH_ESC)		/* Undo 7-bit replace for large x - kw */
	*x = SLang_getkey () + 64 - 33;
    else
	*x -= 33;
    *y = SLang_getkey ();
    if (*y == CH_ESC)		/* Undo 7-bit replace for large y - kw */
	*y = SLang_getkey () + 64 - 33;
    else
	*y -= 33;
d530 1
a530 2
PRIVATE int sl_read_mouse_event ARGS1(
    int,	code)
d538 1
a538 1
	  return set_clicked_link (mouse_x, mouse_y, FOR_PANEL, 1);
d549 1
a549 4
   if (code == FOR_INPUT || code == FOR_PROMPT)
       return DO_NOTHING;
   else
       return -1;
d551 1
a551 2
#endif  /* USE_SLANG and USE_MOUSE */

d565 2
a566 2
#define expand_substring(dst, first, last, final) \
	(SLexpand_escaped_string(dst, (char *)first, (char *)last), 1)
d569 1
a569 1
#define MOUSE_KEYSYM 0x0400
d572 1
d584 1
a584 6
# ifdef VMS
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx}
# else
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx},{string1,lynx}
# endif
# define INTERN_KEY(string,lynx,curses)          {string,lynx}
d586 1
a586 2
#define INTERN_KEY(string,lynx,curses)           {string,curses}
#define EXTERN_KEY(string,string1,lynx,curses)   {string,curses}
a588 1

d598 16
a613 16
    INTERN_KEY( "UPARROW",	UPARROW,	KEY_UP ),
    INTERN_KEY( "DNARROW",	DNARROW,	KEY_DOWN ),
    INTERN_KEY( "RTARROW",	RTARROW,	KEY_RIGHT ),
    INTERN_KEY( "LTARROW",	LTARROW,	KEY_LEFT ),
    INTERN_KEY( "PGDOWN",	PGDOWN,		KEY_NPAGE ),
    INTERN_KEY( "PGUP",		PGUP,		KEY_PPAGE ),
    INTERN_KEY( "HOME",		HOME,		KEY_HOME ),
    INTERN_KEY( "END",		END_KEY,	KEY_END ),
    INTERN_KEY( "F1",		F1,		KEY_F(1) ),
    INTERN_KEY( "DO_KEY",	DO_KEY,		KEY_F(16) ),
    INTERN_KEY( "FIND_KEY",	FIND_KEY,	KEY_FIND ),
    INTERN_KEY( "SELECT_KEY",	SELECT_KEY,	KEY_SELECT ),
    INTERN_KEY( "INSERT_KEY",	INSERT_KEY,	KEY_IC ),
    INTERN_KEY( "REMOVE_KEY",	REMOVE_KEY,	KEY_DC ),
    INTERN_KEY( "DO_NOTHING",	DO_NOTHING,	DO_NOTHING|LKC_ISLKC ),
    INTERN_KEY( NULL,		-1,		ERR )
d631 1
a631 1
PRIVATE CONST char *expand_tiname (CONST char *first, size_t len, char **result, char *final)
d641 1
a641 1
	    LYstrncpy(*result, cur_term->type.Strings[code], final - *result);
d648 1
a648 1
PRIVATE CONST char *expand_tichar (CONST char *first, char **result, char *final)
d679 6
a684 6
	char *last = 0;
	char tmp[80];
	LYstrncpy(tmp, first, limit);
	value = strtol(tmp, &last, radix);
	if (last != 0 && last != tmp)
	    first += (last - tmp);
d688 1
a688 1
	(void) expand_tiname(name, strlen(name), result, final);
d697 1
a697 1
PRIVATE int expand_substring (char* dst, CONST char* first, CONST char* last, char *final)
a699 1

d703 1
a703 1
	    first = expand_tichar(first, &dst, final);
d708 1
a708 2
		CONST char *s = strchr(first, RPAREN);
		char *was = dst;
d711 1
a711 3
		first = expand_tiname(first, s-first, &dst, final);
		if (dst == was)
		    return 0;
a731 1
    return 1;
d735 1
a735 1
PRIVATE void unescaped_char ARGS2(CONST char*, parse, int*,keysym)
d741 1
a741 1
	expand_substring(buf, parse + 1, parse + len - 1, buf + sizeof(buf) - 1);
d747 1
a747 1
PRIVATE BOOLEAN unescape_string ARGS3(char*, src, char *, dst, char *, final)
d759 4
a762 2
    } else if (*src == DQUOTE)
	ok = expand_substring(dst, src + 1, src + strlen(src) - 1, final);
d766 1
a766 1
PUBLIC int map_string_to_keysym ARGS2(CONST char*, str, int*,keysym)
a767 1
    int modifier = 0;
a769 45
    if (strncasecomp(str, "LAC:", 4) == 0) {
	char *other = strchr(str+4, ':');

	if (other) {
	   int othersym = lecname_to_lec(other + 1);
	   char buf[BUFSIZ];

	   if (othersym >= 0 && other - str - 4 < BUFSIZ ) {
		strncpy(buf, str + 4, other - str - 4);
		buf[other - str - 4] = '\0';
		*keysym = lacname_to_lac(buf);
		if (*keysym >= 0) {
		    *keysym = LACLEC_TO_LKC0(*keysym, othersym);
		    return (*keysym);
		}
	   }
	}
	*keysym = lacname_to_lac(str + 4);
	if (*keysym >= 0) {
	    *keysym = LAC_TO_LKC0(*keysym);
	    return (*keysym);
	}
    }
    if (strncasecomp(str, "Meta-", 5) == 0) {
	str += 5;
	modifier = LKC_MOD2;
	if (*str) {
	    size_t len = strlen(str);
	    if (len == 1)
		return (*keysym = (UCH(str[0]))|modifier);
	    else if (len == 2 && str[0] == '^' &&
		     (isalpha(UCH(str[1])) ||
		      (TOASCII(str[1]) >= '@@' && TOASCII(str[1]) <= '_')))
		return (*keysym = FROMASCII(UCH(str[1]&0x1f))|modifier);
	    else if (len == 2 && str[0] == '^' &&
		     str[1] == '?')
		return (*keysym = CH_DEL|modifier);
	    if (*str == '^' || *str == '\\') {
		char buf[BUFSIZ];
		expand_substring(buf, str, str + HTMIN(len, 28), buf + sizeof(buf) - 1);
		if (strlen(buf) <= 1)
		    return (*keysym = (UCH(buf[0]))|modifier);
	    }
	}
    }
d772 1
a772 1
    } else if (isdigit(UCH(*str))) {
d775 1
a775 1
	if (!isalnum(UCH(*tmp))) {
a776 5
#ifndef USE_SLANG
	    if (*keysym > 255)
		*keysym |= LKC_ISLKC; /* caller should remove this flag - kw */
#endif
	}
a789 2
    if (*keysym >= 0)
	*keysym |= modifier;
d815 1
a815 1
	} else if (isspace(UCH(*parse))) {
a832 1
    CTRACE((tfp, "KEYMAP(PA): in=%s", parse));	/* \n-terminated */
d834 1
a834 1
	if (isspace(UCH(*s))) {
d837 1
a837 2
	    if ((t = skip_keysym(s)) == 0) {
		CTRACE((tfp, "KEYMAP(SKIP) no key expansion found\n"));
a838 1
	    }
d841 2
a842 10
	    if (map_string_to_keysym (s, &keysym) >= 0) {
		if (!unescape_string(parse, buf, buf + sizeof(buf) - 1)) {
		    CTRACE((tfp, "KEYMAP(SKIP) could unescape key\n"));
		    return 0;		/* Trace the failure and continue. */
		}
		if (LYTraceLogFP == 0) {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x\n", keysym));
		} else {
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x, seq='%s'\n", keysym, buf));
		}
a844 3
	    else {
		CTRACE((tfp, "KEYMAP(SKIP) could not map to keysym\n"));
	    }
a845 6
	else {
	    CTRACE((tfp, "KEYMAP(SKIP) junk after key description: '%s'\n", s));
	}
    }
    else {
	CTRACE((tfp, "KEYMAP(SKIP) no key description\n"));
d897 1
d907 3
a909 1
    while (LYSafeGets(&line, fp) != 0) {
d919 7
a925 4

	    if ( strlen(s) > len && !strncmp(s, table[n].name, len)
		 && (*(table[n].func))(LYSkipBlanks(s+len)) < 0 )
		fprintf (stderr, FAILED_READING_KEYMAP, linenum, file);
d929 7
a935 2
    LYCloseInput (fp);
    return 0;
d941 20
a960 37
	INTERN_KEY( "\033[A",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033OA",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033[B",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033OB",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033[C",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033OC",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033[D",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033OD",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033[1~",	FIND_KEY,	KEY_FIND ),
	INTERN_KEY( "\033[2~",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\033[3~",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\033[4~",	SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY( "\033[5~",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\033[6~",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\033[7~",	HOME,		KEY_HOME),
	INTERN_KEY( "\033[8~",	END_KEY,	KEY_END ),
	INTERN_KEY( "\033[11~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[28~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[29~",	DO_KEY,		KEY_F(16) ),
#if defined(USE_SLANG) && !defined(VMS)
	INTERN_KEY(	"^(ku)", UPARROW,	KEY_UP ),
	INTERN_KEY(	"^(kd)", DNARROW,	KEY_DOWN ),
	INTERN_KEY(	"^(kr)", RTARROW,	KEY_RIGHT ),
	INTERN_KEY(	"^(kl)", LTARROW,	KEY_LEFT ),
	INTERN_KEY(	"^(@@0)", FIND_KEY,	KEY_FIND ),
	INTERN_KEY(	"^(kI)", INSERT_KEY,	KEY_IC ),
	INTERN_KEY(	"^(kD)", REMOVE_KEY,	KEY_DC ),
	INTERN_KEY(	"^(*6)", SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY(	"^(kP)", PGUP,		KEY_PPAGE ),
	INTERN_KEY(	"^(kN)", PGDOWN,	KEY_NPAGE ),
	INTERN_KEY(	"^(@@7)", END_KEY,	KEY_END ),
	INTERN_KEY(	"^(kh)", HOME,		KEY_HOME),
	INTERN_KEY(	"^(k1)", F1,		KEY_F(1) ),
	INTERN_KEY(	"^(F6)", DO_KEY,	KEY_F(16) ),
#endif /* SLANG && !VMS */
d964 1
a964 1
	define_key(table[n].string, table[n].value);
a972 5
    /* The escape sequences may contain embedded termcap strings.  Make
     * sure the library is initialized for that.
     */
    SLtt_get_terminfo();

d986 4
a989 2
    if (SLang_Error)
	SLang_exit_error ("Unable to initialize keymaps");
d992 1
a993 1
    return read_keymap_file();
d998 2
a999 3

#if defined(USE_MOUSE) && (defined(NCURSES))
PRIVATE int LYmouse_menu ARGS4(int, x, int, y, int, atlink, int, code)
d1001 58
a1058 33
#define ENT_ONLY_DOC	1
#define ENT_ONLY_LINK	2
    static const struct {
	char *txt;
	int  action;
	unsigned int  flag;
    } possible_entries[] = {
	{"Quit",			LYK_ABORT,		ENT_ONLY_DOC},
	{"Home page",			LYK_MAIN_MENU,		ENT_ONLY_DOC},
	{"Previous document",		LYK_PREV_DOC,		ENT_ONLY_DOC},
	{"Beginning of document",	LYK_HOME,		ENT_ONLY_DOC},
	{"Page up",			LYK_PREV_PAGE,		ENT_ONLY_DOC},
	{"Half page up",		LYK_UP_HALF,		ENT_ONLY_DOC},
	{"Two lines up",		LYK_UP_TWO,		ENT_ONLY_DOC},
	{"History",			LYK_HISTORY,		ENT_ONLY_DOC},
	{"Help",			LYK_HELP,		0},
	{"Do nothing (refresh)",	LYK_REFRESH,		0},
	{"Load again",			LYK_RELOAD,		ENT_ONLY_DOC},
	{"Edit Doc URL and load",	LYK_ECGOTO,		ENT_ONLY_DOC},
	{"Edit Link URL and load",	LYK_ELGOTO,		ENT_ONLY_LINK},
	{"Show info",			LYK_INFO,		0},
	{"Search",			LYK_WHEREIS,		ENT_ONLY_DOC},
	{"Print",			LYK_PRINT,		ENT_ONLY_DOC},
	{"Two lines down",		LYK_DOWN_TWO,		ENT_ONLY_DOC},
	{"Half page down",		LYK_DOWN_HALF,		ENT_ONLY_DOC},
	{"Page down",			LYK_NEXT_PAGE,		ENT_ONLY_DOC},
	{"End of document",		LYK_END,		ENT_ONLY_DOC},
	{"Bookmarks",			LYK_VIEW_BOOKMARK,	ENT_ONLY_DOC},
	{"Cookie jar",			LYK_COOKIE_JAR,		ENT_ONLY_DOC},
	{"Search index",		LYK_INDEX_SEARCH,	ENT_ONLY_DOC},
	{"Set Options",			LYK_OPTIONS,		ENT_ONLY_DOC},
	{"Activate this link",		LYK_SUBMIT,		ENT_ONLY_LINK},
	{"Download",			LYK_DOWNLOAD,		ENT_ONLY_LINK}
d1060 8
a1067 15
#define TOTAL_MENUENTRIES	TABLESIZE(possible_entries)
    char *choices[TOTAL_MENUENTRIES + 1];
    int actions[TOTAL_MENUENTRIES];

    int c, c1, retlac, filter_out = (atlink ? ENT_ONLY_DOC : ENT_ONLY_LINK);

    c = c1 = 0;
    while (c < (int) TOTAL_MENUENTRIES) {
	if (!(possible_entries[c].flag & filter_out)) {
	    choices[c1] = possible_entries[c].txt;
	    actions[c1++] = possible_entries[c].action;
	}
	c++;
    }
    choices[c1] = NULL;
d1071 5
a1075 16
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x-5 : 1),
		     choices, c1, FALSE, TRUE);

    /*
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
     */
    if (term_options) {
	retlac = LYK_DO_NOTHING;
	term_options = FALSE;
    } else {
	retlac = actions[c];
    }
d1077 1
a1077 38
    if (code == FOR_INPUT && mouse_link == -1) {
	switch (retlac) {
	    case LYK_ABORT:
		retlac = LYK_QUIT; /* a bit softer... */
		/* fall through */
	    case LYK_MAIN_MENU:
	    case LYK_PREV_DOC:
	    case LYK_HOME:
	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_HISTORY:
	    case LYK_HELP:
/*	    case LYK_REFRESH:*/
	    case LYK_RELOAD:
	    case LYK_ECGOTO:
	    case LYK_INFO:
	    case LYK_WHEREIS:
	    case LYK_PRINT:
	    case LYK_DOWN_TWO:
	    case LYK_DOWN_HALF:
	    case LYK_NEXT_PAGE:
	    case LYK_END:
	    case LYK_VIEW_BOOKMARK:
	    case LYK_COOKIE_JAR:
	    case LYK_INDEX_SEARCH:
	    case LYK_OPTIONS:
		mouse_link = -3; /* so LYgetch_for() passes it on - kw */
	}
    }
    if (retlac == LYK_DO_NOTHING ||
	retlac == LYK_REFRESH) {
	mouse_link = -1;	/* mainloop should not change cur link - kw */
    }
    if (code == FOR_INPUT && retlac == LYK_DO_NOTHING) {
	repaint_main_statusline(FOR_INPUT);
    }
    return retlac;
d1079 1
a1079 2
#endif /* USE_MOUSE && (NCURSES || PDCURSES) */

a1081 3
/************************************************************************/

PRIVATE int current_sl_modifier = 0;
d1086 1
a1086 4
    int i = GetChar();
    if (i == 0)			/* trick to get NUL char through - kw */
	current_sl_modifier = LKC_ISLKC;
    return i;
d1089 1
a1089 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
a1092 1
   current_sl_modifier = 0;
d1096 1
a1096 1
     return (current_sl_modifier ? 0 : DO_NOTHING);
d1100 1
a1100 1
#if defined (USE_MOUSE)
d1102 1
a1102 1
     return sl_read_mouse_event (code);
d1105 2
a1106 2
   if (keysym < 0)
       return 0;
d1108 2
a1109 2
   if (keysym & (LKC_ISLECLAC|LKC_ISLAC))
       return (keysym);
d1111 4
a1114 10
   current_sl_modifier = 0;
   if (LKC_HAS_ESC_MOD(keysym)) {
       current_sl_modifier = LKC_MOD2;
       keysym &= LKC_MASK;
   }

   if (keysym+1 >= KEYMAP_SIZE)
     return 0;

   return (keysym|current_sl_modifier);
a1116 1
/************************************************************************/
a1118 1

d1124 7
a1130 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
a1132 2
    int current_modifier = 0;
    BOOLEAN done_esc = FALSE;
d1136 1
d1138 1
a1138 4
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
    if (errno == EINTR)
	set_errno(0);		/* reset - kw */
#endif  /* UCX && VAXC */
a1143 1
    lynx_nl2crlf(FALSE);
a1146 1
	lynx_nl2crlf(FALSE);
d1156 1
a1156 2
	    CTRACE((tfp, "GETCH: Translate ^C to ^G.\n"));
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
a1160 45
    CTRACE((tfp, "GETCH: Got %#x.\n", c));
#ifdef MISC_EXP
    if (LYNoZapKey > 1 && errno != EINTR &&
	(c == EOF
#ifdef USE_SLANG
	 || (c == 0xFFFF)
#endif
	    )) {
	int fd, kbd_fd;
	CTRACE((tfp,
		"nozap: Got EOF, curses %s, stdin is %p, LYNoZapKey reduced from %d to 0.\n",
		LYCursesON ? "on" : "off", stdin, LYNoZapKey));
	LYNoZapKey = 0;		/* 2 -> 0 */
	if ((fd = fileno(stdin)) == 0 && !isatty(fd) &&
	    (kbd_fd = LYConsoleInputFD(FALSE)) == fd) {
	    char *term_name;
	    int new_fd = INVSOC;
	    if ((term_name = ttyname(fileno(stdout))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC &&
		(term_name = ttyname(fileno(stderr))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC) {
		term_name = ctermid(NULL);
		new_fd = open(term_name, O_RDONLY);
	    }
	    CTRACE((tfp, "nozap: open(%s) returned %d.\n", term_name, new_fd));
	    if (new_fd >= 0) {
		FILE *frp;
		close(new_fd);
		frp = freopen(term_name, "r", stdin);
		CTRACE((tfp,
		"nozap: freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
			term_name, frp, stdin, fileno(stdin)));
		if (LYCursesON) {
		    stop_curses();
		    start_curses();
		    LYrefresh();
		}
		goto re_read;
	    }
	}
    }
#endif /* MISC_EXP */

a1163 19
#else
    if (c == EOF && errno == EINTR) {

#if HAVE_SIZECHANGE || defined(USE_SLANG)
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		  recent_sizechange));
	   if (!recent_sizechange) { /* not yet detected by ourselves */
	       size_change(0);
	       CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	   }
#else /* HAVE_SIZECHANGE || USE_SLANG */
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		  recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
	set_errno(0);		/* reset - kw */
#endif  /* UCX && VAXC */
	return(DO_NOTHING);
    }
d1174 1
a1174 1
	return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1176 1
a1176 1
#else  /* not USE_SLANG: */
d1179 1
a1179 1
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1193 1
a1193 1
	exit_immediately(EXIT_SUCCESS);
d1197 1
a1197 4
    if (!escape_bound
	&& (c == CH_ESC || (csi_is_csi && c == UCH(CH_ESC_PAR)))) {
	/* handle escape sequence  S/390 -- gil -- 2024 */
	done_esc = TRUE;		/* Flag: we did it, not keypad() */
d1208 1
a1208 1
	case 'x': c = UPARROW; break;	/* keypad up on pc ncsa telnet */
d1210 1
a1210 1
	case 'r': c = DNARROW; break;	/* keypad down on pc ncsa telnet */
d1212 1
a1212 1
	case 'v': c = RTARROW; break;	/* keypad right on pc ncsa telnet */
d1214 5
a1218 5
	case 't': c = LTARROW; break;	/* keypad left on pc ncsa telnet */
	case 'y': c = PGUP;    break;	/* keypad on pc ncsa telnet */
	case 's': c = PGDOWN;  break;	/* keypad on pc ncsa telnet */
	case 'w': c = HOME;    break;	/* keypad on pc ncsa telnet */
	case 'q': c = END_KEY; break;	/* keypad on pc ncsa telnet */
d1220 1
a1220 1
#if defined(USE_SLANG) && defined(USE_MOUSE)
d1223 1
a1223 1
		c = sl_read_mouse_event (code);
d1227 1
a1227 1
	     c = '\n';		/* keypad enter on pc ncsa telnet */
d1234 1
a1234 1
		c = '-';	/* keypad on pc ncsa telnet */
d1238 1
a1238 3
		c = '+';	/* keypad + on my xterminal :) */
	    else
		done_esc = FALSE; /* we have another look below - kw */
d1244 1
a1244 1
		c = '+';	/* keypad on pc ncsa telnet */
d1256 1
a1256 1
		c = F1;		/* macintosh help button */
d1262 1
a1262 1
		c = '0';	/* keypad 0 */
d1264 1
a1264 1
	case '1':		/** VTxxx  Find  **/
a1266 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1282 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1286 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1290 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1294 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1298 2
	    else
		done_esc = FALSE; /* we have another look below - kw */
a1305 1
	    /* FALLTHRU */
d1307 1
a1307 8
	    if (c == CH_ESC && a == b && !found_CSI(c,b)) {
		current_modifier = LKC_MOD2;
		c = a;
		/* We're not yet done if ESC + curses-keysym: */
		done_esc = (BOOL) ((a & ~0xFF) == 0);
		break;
	    }
	    CTRACE((tfp,"Unknown key sequence: %d:%d:%d\n",c,b,a));
a1312 9
	if (!done_esc && (a & ~0xFF) == 0) {
	    if (a == b && !found_CSI(c,b) && c == CH_ESC) {
		current_modifier = LKC_MOD2;
		c = a;
		done_esc = TRUE;
	    } else {
		done_esc = TRUE;
	    }
	}
d1314 3
a1316 22
#ifdef USE_KEYMAPS
    /* Extract a single code if two are merged: */
    if (c >= 0 && (c&LKC_ISLECLAC)) {
	if (!(code == FOR_INPUT || code == FOR_PROMPT))
	    c = LKC2_TO_LKC(c);
    } else if (c >= 0 && (c&LKC_ISLKC)) {
	c &= ~LKC_ISLKC;
	done_esc = TRUE; /* already a lynxkeycode, skip keypad switches - kw */
    }
    if (c >= 0 && LKC_HAS_ESC_MOD(c)) {
	current_modifier = LKC_MOD2;
	c &= LKC_MASK;
    }
    if (c >= 0 && (c&(LKC_ISLECLAC|LKC_ISLAC))) {
	done_esc = TRUE; /* already a lynxactioncode, skip keypad switches - iz */
    }
#endif
    if (done_esc) {
	/* don't do keypad() switches below, we already got it - kw */
    } else {
#if HAVE_KEYPAD
	/*
d1329 1
a1329 14
	case KEY_RIGHT:		   /* ... */
	   c = RTARROW;
	   break;
#if defined(SH_EX) && defined(DOSPATH)	/* for NEC PC-9800 1998/08/30 (Sun) 21:50:35 */
	case KEY_C2:
	   c = DNARROW;
	   break;
	case KEY_A2:
	   c = UPARROW;
	   break;
	case KEY_B1:
	   c = LTARROW;
	   break;
	case KEY_B3:
a1331 7
	case PAD0:		   /* PC-9800 Ins */
	   c = INSERT_KEY;
	   break;
	case PADSTOP:		   /* PC-9800 DEL */
	   c = REMOVE_KEY;
	   break;
#endif /* SH_EX */
d1335 1
a1335 1
	case KEY_CLEAR:		   /* Clear screen */
d1338 1
a1338 1
	case KEY_NPAGE:		   /* Next page */
d1341 1
a1341 1
	case KEY_PPAGE:		   /* Previous page */
a1346 1
#if defined(KEY_A1) && defined(KEY_C3)
a1365 1
#endif /* defined(KEY_A1) && defined(KEY_C3) */
a1428 48
#ifdef KEY_RESIZE
	case KEY_RESIZE:	   /* size change detected by ncurses */
#if HAVE_SIZECHANGE || defined(USE_SLANG)
	    /* Make call to detect new size, if that may be implemented.
	     * The call may set recent_sizechange (except for USE_SLANG),
	     * which will tell mainloop() to refresh. - kw
	     */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange so far is %d\n",
		  recent_sizechange));
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
#else /* HAVE_SIZECHANGE || USE_SLANG */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange is %d\n",
		  recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
	    if (!recent_sizechange) {
#if 0			/* assumption seems flawed? */
		/*  Not detected by us or already processed by us.  It can
		 *  happens that ncurses lags behind us in detecting the
		 *  change, since its own SIGTSTP handler is not installed
		 *  so detecting happened *at the end* of the last refresh.
		 *  Tell it to refresh again... - kw
		 */
		LYrefresh();
#endif
#if defined(NCURSES)
		/*
		 * Work-around for scenario (Linux libc5) where we got a
		 * recent sizechange before reading KEY_RESIZE.  If we do
		 * not reset the flag, we'll next get an EOF read, which
		 * causes Lynx to exit.
		 */
		recent_sizechange = TRUE;
#endif
		/*
		 *  May be just the delayed effect of mainloop()'s call
		 *  to resizeterm().  Pretend we haven't read anything
		 *  yet, don't return. - kw
		 */
		goto re_read;
	    }
	    /*
	     *  Yep, we agree there was a change.  Return now so that
	     *  the caller can react to it. - kw
	     */
	    c = DO_NOTHING;
	    break;
#endif /* KEY_RESIZE */
d1433 2
a1434 2
	    c = 0x213;
	    break;
d1436 2
a1437 2
	    c = 0x214;
	    break;
d1439 2
a1440 2
	    c = 0x215;
	    break;
d1442 2
a1443 2
	    c = 0x216;
	    break;
d1445 2
a1446 2
	    c = 0x217;
	    break;
d1448 2
a1449 2
	    c = 0x218;
	    break;
d1451 1
a1451 5

#if defined(USE_MOUSE)
/********************************************************************/

#if defined(NCURSES) || defined(PDCURSES)
a1452 1
	    CTRACE((tfp, "KEY_MOUSE\n"));
d1455 2
a1456 10
	    }
#if defined(NCURSES)
	    else if (code == FOR_SINGLEKEY) {
		MEVENT event;
		getmouse(&event);	/* Completely ignore event - kw */
		c = DO_NOTHING;
	    }
#endif
	    else {
#if defined(NCURSES)
a1458 1
		int lac = LYK_UNKNOWN;
a1462 4
		if (err != OK) {
		    CTRACE((tfp, "Mouse error: no event available!\n"));
		    return(code==FOR_PANEL ? 0 : DO_NOTHING);
		}
d1465 1
a1465 1
		    c = set_clicked_link(event.x, event.y, code, 1);
d1467 7
a1473 3
		    c = set_clicked_link(event.x, event.y, code, 2);
		    if (c == LAC_TO_LKC0(LYK_SUBMIT) && code == FOR_INPUT)
			lac = LYK_SUBMIT;
d1475 1
a1475 10
		    c = LAC_TO_LKC0(LYK_PREV_DOC);
		} else if (code == FOR_PROMPT
				 /* Cannot ignore: see LYCurses.c */
			   || (event.bstate &
				( BUTTON1_PRESSED | BUTTON1_RELEASED
				  | BUTTON2_PRESSED | BUTTON2_RELEASED
				  | BUTTON3_PRESSED | BUTTON3_RELEASED))) {
		    /* Completely ignore - don't return anything, to
		       avoid canceling the prompt - kw */
		    goto re_read;
d1479 2
a1480 2
		    c = set_clicked_link(event.x, event.y, code, 1);
		    atlink = (c == LAC_TO_LKC0(LYK_ACTIVATE));
d1484 5
a1488 11
		    lac = LYmouse_menu(event.x, event.y, atlink, code);
		    if (lac == LYK_SUBMIT) {
			if (mouse_link == -1)
			    lac = LYK_ACTIVATE;
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			else if (mouse_link >= 0 &&
				 textfields_need_activation &&
				 links[mouse_link].type == WWW_FORM_LINK_TYPE &&
				 F_TEXTLIKE(links[mouse_link].form->type))
			    lac = LYK_ACTIVATE;
#endif
d1490 1
a1490 6
		    if (lac == LYK_ACTIVATE && mouse_link == -1) {
			HTAlert(gettext("No link chosen"));
			lac = LYK_REFRESH;
		    }
		    c = LAC_TO_LKC(lac);
#if 0	/* Probably not necessary any more - kw */
d1492 1
a1492 2
		    LYrefresh();
#endif
d1494 1
a1494 2
		if (code == FOR_INPUT && mouse_link == -1 &&
		    lac != LYK_REFRESH && lac != LYK_SUBMIT) {
d1496 1
a1496 1
		    wgetch(LYwin);	/* ungetmouse puts KEY_MOUSE back */
a1499 16

	/* _WINDOWS 1997/10/18 (Sat) 19:41:59 */

#define H_CMD_AREA	6
#define HIST_CMD_2	12
#define V_CMD_AREA	1

		int left = H_CMD_AREA;
		int right = (LYcols - H_CMD_AREA);
		/* yes, I am assuming that my screen will be a certain width. */

		int tick_count;
		char *p = NULL;
		char mouse_info[128];
		static int old_click = 0;	/* [m Sec] */

d1502 5
a1506 69

		if (system_is_NT) {
		/* for Windows NT */
		  request_mouse_pos();

		  if (BUTTON_STATUS(1) & BUTTON_PRESSED) {
			if (MOUSE_Y_POS > (LYlines - V_CMD_AREA)) {
			    /* Screen BOTTOM */
			    if (MOUSE_X_POS < left) {
				c = LTARROW;		p = "<-";
			    } else if (MOUSE_X_POS < HIST_CMD_2) {
				c = RTARROW;		p = "->";
			    } else if (MOUSE_X_POS > right) {
				c = 'z';		p = "Cancel";
			    } else {
				c = PGDOWN;		p = "PGDOWN";
			    }
			} else if (MOUSE_Y_POS < V_CMD_AREA) {
			    /* Screen TOP */
			    if (MOUSE_X_POS < left) {
				c = LTARROW;		p = "<-";
			    } else if (MOUSE_X_POS < HIST_CMD_2) {
				c = RTARROW;		p = "->";
			    } else if (MOUSE_X_POS > right) {
				c = 'z';		p = "Cancel";
			    } else {
				c = PGUP;		p = "PGUP";
			    }
			} else {
			    c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL, 1);
			}
		    }
		} else {
		    /* for Windows 95 */
		    tick_count = GetTickCount();

		    /* Guard Mouse button miss click */
		    if ((tick_count - old_click) < 700) {
			c = DO_NOTHING;
			break;
		    } else {
			old_click = tick_count;
		    }
		    request_mouse_pos();
		    if (MOUSE_Y_POS > (LYlines - V_CMD_AREA)) {
			/* Screen BOTTOM */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;	p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;	p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = '\b';		p = "History";
			} else {
			    c = PGDOWN;		p = "PGDOWN";
			}
		    } else if (MOUSE_Y_POS < V_CMD_AREA) {
			/* Screen TOP */
			if (MOUSE_X_POS < left) {
			    c = LTARROW;	p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW;	p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';		p = "Cancel";
			} else {
			    c = PGUP;		p = "PGUP";
			}
		    } else {
			c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL, 1);
		    }
d1508 1
a1508 7
		if (p && c != -1) {
		    sprintf(mouse_info, "Mouse = 0x%x, [%s]", c, p);
		    SetConsoleTitle(mouse_info);
		}
#endif /* !(WIN_EX) */
		if ((c+1) >= KEYMAP_SIZE && (c&LKC_ISLAC))
		    return(c);
d1511 1
a1511 5
#endif /* NCURSES || PDCURSES */

/********************************************************************/
#endif  /* USE_MOUSE */

d1513 1
d1516 1
d1530 1
a1530 1
	case K_Right:		   /* ... */
d1538 1
a1538 1
	case K_PageDown:	   /* Next page */
d1542 1
a1542 1
	case K_PageUp:		   /* Previous page */
d1574 1
d1576 2
a1577 1
#if defined(USE_SLANG) && (defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(DJGPP_KEYHANDLER)  && !defined(USE_KEYMAPS)
d1588 1
a1588 1
	case SL_KEY_RIGHT:	   /* ... */
d1595 1
a1595 1
	case SL_KEY_NPAGE:	   /* Next page */
d1599 1
a1599 1
	case SL_KEY_PPAGE:	   /* Previous page */
d1617 1
a1618 1
    }
a1619 2
    if (c&(LKC_ISLAC|LKC_ISLECLAC))
	return(c);
d1628 1
a1628 1
	return(c|current_modifier);
a1631 1
/************************************************************************/
a1633 42

PUBLIC int LYgetch NOARGS
{
    return LYReadCmdKey(FOR_PANEL);
}

/*
 * Read a single keystroke, allows mouse-selection.
 */
PUBLIC int LYgetch_choice NOARGS
{
    int ch = LYReadCmdKey(FOR_CHOICE);
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, allows mouse events.
 */
PUBLIC int LYgetch_input NOARGS
{
    int ch = LYReadCmdKey(FOR_INPUT);
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, ignoring case by translating it to uppercase.
 * Ignore mouse events, if any.
 */
PUBLIC int LYgetch_single NOARGS
{
    int ch = LYReadCmdKey(FOR_SINGLEKEY);
    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
    else if (ch > 0 && ch < 256)
	ch = TOUPPER(ch);	/* will ignore case of result */
    return ch;
}

d1638 1
a1638 1
	 char *,	arg_buffer)
a1639 1
    register unsigned char *buffer = (unsigned char *) arg_buffer;
a1641 12
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:04:55 */
    {
	if (buffer[i] & 0x80) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOLOWER(buffer[i]));
	}
    }
#else
a1642 1
#endif
d1649 1
a1649 1
	 char *,	arg_buffer)
a1650 1
    register unsigned char *buffer = (unsigned char *) arg_buffer;
d1653 1
a1653 14
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:05:10 */
    {
	if (buffer[i] & 0x80) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOUPPER(buffer[i]));
	}
    }
#else
	buffer[i] = UCH(TOUPPER(buffer[i]));
#endif
d1660 1
a1660 1
	char *,		buffer)
d1665 1
a1665 1
	    if (!isspace(UCH((buffer[i]))))
d1675 1
a1675 1
	char *,		buffer)
d1677 1
a1677 1
    while (isspace(UCH((*buffer))))
d1686 1
a1686 1
	char *,		buffer)
d1688 1
a1688 1
    while (*buffer != 0 && !isspace(UCH((*buffer))))
d1699 1
a1699 1
    while (isspace(UCH((*buffer))))
d1710 1
a1710 1
    while (*buffer != 0 && !isspace(UCH((*buffer))))
d1719 1
a1719 1
	char *,		buffer)
d1730 1
a1730 1
	char *,		buffer)
d1733 1
a1733 1
    while (i != 0 && isspace(UCH(buffer[i-1])))
a1736 29
/* 1997/11/10 (Mon) 14:26:10, originally string_short() in LYExterns.c, but
 * moved here because LYExterns is not always configured.
 */
PUBLIC char *LYElideString ARGS2(
	char *,		str,
	int,		cut_pos)
{
    char buff[MAX_LINE], *s, *d;
    static char s_str[MAX_LINE];
    int len;

    LYstrncpy(buff, str, sizeof(buff)-1);
    len = strlen(buff);
    if (len > (LYcols - 10)) {
	buff[cut_pos] = '.';
	buff[cut_pos + 1] = '.';
	for (s = (buff + len) - (LYcols - 10) + cut_pos + 1,
	     d = (buff + cut_pos) + 2;
	     s >= buff &&
	     d >= buff &&
	     d < buff + LYcols &&
	     (*d++ = *s++) != 0; )
	    ;
	buff[LYcols] = 0;
    }
    strcpy(s_str, buff);
    return (s_str);
}

d1764 1
a1764 1
	char **,		buffer)
d1766 1
a1766 1
    if (!LYTrimStartfile(*buffer)) {
d1770 1
a1770 1
    }
d1777 1
a1777 1
	char *,		buffer)
d1780 1
a1780 1
	LYRemoveBlanks(buffer);
a1800 7
#ifdef ENHANCED_LINEEDIT
#define Mark	 edit->mark
#endif

#ifdef ENHANCED_LINEEDIT
PRIVATE char killbuffer[1024] = "\0";
#endif
d1804 1
a1804 1
	char *,		old,
a1814 1
    edit->current_modifiers = 0;
d1816 1
a1820 3
#ifdef ENHANCED_LINEEDIT
    Mark = -1;			/* pos=0, but do not show it yet */
#endif
a1837 51
    LYstrncpy(edit->buffer, old, maxstr);
    StrLen = strlen(edit->buffer);
}

#ifdef SUPPORT_MULTIBYTE_EDIT

PRIVATE int prev_pos ARGS2(
	EDREC *,	edit,
	int,		pos)
{
    int i = 0;

    if (pos <= 0)
	return 0;
    if (HTCJK == NOCJK)
	return (pos - 1);
    else {
	while (i < pos - 1) {
	    int c;
	    c = Buf[i];
	    if (!(isascii(c) ||
		  ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c))))) {
		i++;
	    }
	    i++;
	}
	if (i == pos)
	    return (i - 2);
	else
	    return i;
    }
}
#endif /* SUPPORT_MULTIBYTE_EDIT */

#ifdef EXP_KEYBOARD_LAYOUT
static int map_active = 0;
#else
#define map_active 0
#endif

PUBLIC int LYEditInsert ARGS5(
	EDREC *,	edit,
	unsigned char *,s,
	int,		len,
	int,		map,
	BOOL,		maxMessage)
{
    int length = strlen(Buf);
    int remains = MaxLen - (length + len);
    int edited = 0, overflow = 0;

d1839 13
a1851 74
     *  ch is (presumably) printable character.
     */
    if (remains < 0) {
	overflow = 1;
	len = 0;
	if (MaxLen > length)	/* Insert as much as we can */
	    len = MaxLen - length;
	else
	    goto finish;
    }
    Buf[length + len] = '\0';
    for(; length >= Pos; length--)    /* Make room */
	Buf[length + len] = Buf[length];
#ifdef EXP_KEYBOARD_LAYOUT
    if (map < 0)
	map = map_active;
    if (map && LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	int off = Pos;
	unsigned char *e = s + len;
	char *tail = 0;

	while (s < e) {
	    char utfbuf[8];
	    int l = 1;

	    utfbuf[0] = *s;
	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
		UCode_t ucode = LYKbLayouts[current_layout][*s];

		if (ucode > 127) {
		    if (UCConvertUniToUtf8(ucode, utfbuf)) {
			l = strlen(utfbuf);
			remains -= l - 1;
			if (remains < 0) {
			    if (tail)
				strcpy(Buf + off, tail);
			    FREE(tail);
			    len = off;
			    overflow = 1;
			    goto finish;
			}
			if (l > 1 && !tail)
			    StrAllocCopy(tail, Buf + Pos + len);
		    } else
			utfbuf[0] = '?';
		} else
		    utfbuf[0] = UCH(ucode);
	    }
	    strncpy(Buf + off, utfbuf, l);
	    edited = 1;
	    off += l;
	    s++;
	}
	if (tail)
	    strcpy(Buf + off, tail);
	len = off - Pos;
	FREE(tail);
    } else if (map) {
	unsigned char *e = s + len, *t = (unsigned char *)Buf + Pos;

	while (s < e) {
	    int ch;

	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
		ch = UCTransUniChar(LYKbLayouts[current_layout][*s],
				    current_char_set);
		if (ch < 0)
		    ch = '?';
	    } else
		ch = *s;
	    *t = UCH(ch);
	    t++, s++;
	}
	edited = 1;
a1852 23
    else
#endif	/* defined EXP_KEYBOARD_LAYOUT */
	{
	    strncpy(Buf + Pos, (char *) s, len);
	    edited = 1;
	}

  finish:
    Pos += len;
    StrLen += len;
    if (edited)
	edit->dirty = TRUE;
    if (overflow && maxMessage)
	_statusline(MAXLEN_REACHED_DEL_OR_MOV);
#ifdef ENHANCED_LINEEDIT
    if (Mark > Pos)
	Mark += len;
    else if (Mark < -1 - Pos)
	Mark -= len;
    if (Mark >= 0)
	Mark = -1 - Mark;		/* Disable it */
#endif
    return edited;
d1861 1
a1861 2
     *         -ch  if action should be performed outside of line-editing mode
     *	       ch   otherwise
d1865 3
a1867 1
    unsigned char uch;
a1883 1
#ifndef CJK_EX
d1891 8
a1898 3
	if (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97)
	    return(ch);
	/* FALLTHRU */
a1899 6
    case LYE_CHAR:
	uch = UCH(ch);
	LYEditInsert(edit, &uch, 1, map_active, maxMessage);
	return 0;			/* All changes already registered */

    case LYE_C1CHAR:
d1901 1
a1901 7
	 *  ch is the second part (in most cases, a capital letter) of
	 *  a 7-bit replacement for a character in the 8-bit C1 control
	 *  range.
	 *  This is meant to undo transformations like
	 *  0x81 -> 0x1b 0x41 (ESC A) etc. done by slang on Unix and
	 *  possibly some comm programs.  It's an imperfect workaround
	 *  that doesn't work for all such characters.
a1902 4
	ch &= 0xFF;
	if (ch + 64 >= LYlowest_eightbit[current_char_set])
	    ch += 64;

a1903 8
#ifdef ENHANCED_LINEEDIT
	    if (Mark > Pos)
		Mark++;
	    else if (Mark < -1 - Pos)
		Mark--;
	    if (Mark >= 0)
		Mark = -1 - Mark;		/* Disable it */
#endif
d1907 1
a1907 1
	    Buf[Pos] = UCH(ch);
d1909 1
a1909 2
	} else {
	    if (maxMessage) {
a1911 2
	    return(ch);
	}
a1914 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a1922 31
#else /* SUPPORT_MULTIBYTE_EDIT */
	/*
	 *  Backword.
	 *  Definition of word is very naive: 1 or more a/n characters,
	 *  or 1 or more multibyte character.
	 */
	{
	    int pos0;

	    pos0 = prev_pos(edit, Pos);
	    while (Pos &&
		   (HTCJK == NOCJK || isascii(Buf[pos0])) &&
		   !isalnum(UCH(Buf[pos0]))) {
		Pos = pos0;
		pos0 = prev_pos(edit, Pos);
	    }
	    if (HTCJK != NOCJK && !isascii(Buf[pos0])) {
		while (Pos && !isascii(Buf[pos0])) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    } else {
		while (Pos
		 && isascii(UCH(Buf[pos0]))
		 && isalnum(UCH(Buf[pos0]))) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    }
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
a1928 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a1932 12
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK && !isascii(Buf[Pos])) {
	    while (!isascii(Buf[Pos]))
		Pos += 2;
	} else {
	    while (isascii(UCH(Buf[Pos])) && isalnum(UCH(Buf[Pos])))
		Pos++;	/* '\0' is not a/n */
	}
	while ((HTCJK == NOCJK || isascii(UCH(Buf[Pos]))) &&
	       !isalnum(UCH(Buf[Pos])) && Buf[Pos])
	    Pos++;
#endif /* SUPPORT_MULTIBYTE_EDIT */
a1939 3
#ifdef ENHANCED_LINEEDIT
	Mark = -1;		/* Do not show the mark */
#endif
d1992 1
a1992 1
    case LYE_DELEL:	/* @@@@@@ */
a2011 4
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (HTCJK != NOCJK && !isascii(Buf[Pos]))
	    Pos++;
#endif
a2018 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2020 6
#ifdef ENHANCED_LINEEDIT
	if (Mark >= 0)
	    Mark = -1 - Mark;		/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark++;
#endif
a2024 23
#else /* SUPPORT_MULTIBYTE_EDIT */
	{
	    int offset = 1;
	    int pos0 = Pos;

	    if (length == 0 || Pos == 0)
		break;
	    if (HTCJK != NOCJK) {
		Pos = prev_pos(edit, pos0);
		offset = pos0 - Pos;
	    } else
		Pos--;
	    for (i = Pos; i < length; i++)
		Buf[i] = Buf[i + offset];
	    i -= offset;
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;		/* Disable it */
	    if (Mark <= -1 - Pos)
		Mark += offset;
#endif
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
a2027 1
    case LYE_FORW_RL:
a2031 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2033 9
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos < length) {
	    Pos++;
	    if (HTCJK != NOCJK && !isascii(Buf[Pos-1]))
		Pos++;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_FORW_RL)
	    return -ch;
a2035 1
    case LYE_BACK_LL:
a2039 1
#ifndef SUPPORT_MULTIBYTE_EDIT
a2041 101
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos > 0) {
	    if (HTCJK != NOCJK)
		Pos = prev_pos(edit, Pos);
	    else
		Pos--;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	else if (action == LYE_BACK_LL)
	    return -ch;
	break;

#ifdef ENHANCED_LINEEDIT
    case LYE_TPOS:
	/*
	 *  Transpose characters - bash or ksh(emacs not gmacs) style
	 */
	if (length <= 1 || Pos == 0)
	    return(ch);
	if (Pos == length)
	    Pos--;
	if (Mark < 0)
	    Mark = -1 - Mark;		/* Temporary enable it */
	if (Mark == Pos || Mark == Pos+1)
	    Mark = Pos-1;
	if (Mark >= 0)
	    Mark = -1 - Mark;		/* Disable it */
	if (Buf[Pos-1] == Buf[Pos]) {
	    Pos++;
	    break;
	}
	i = Buf[Pos-1]; Buf[Pos-1] = Buf[Pos]; Buf[Pos++] = (char) i;
	break;

    case LYE_SETMARK:
	/*
	 *  primitive emacs-like set-mark-command
	 */
	Mark = Pos;
	return(0);

    case LYE_XPMARK:
	/*
	 *  emacs-like exchange-point-and-mark
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;		/* Enable it */
	if (Mark == Pos)
	    return(0);
	i = Pos; Pos = Mark; Mark = i;
	break;

    case LYE_KILLREG:
	/*
	 *  primitive emacs-like kill-region
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;		/* Enable it */
	if (Mark == Pos) {
	    killbuffer[0] = '\0';
	    return(0);
	}
	if (Mark > Pos)
	    LYEdit1(edit, 0, LYE_XPMARK, FALSE);
	{
	    int reglen = Pos - Mark;

	    LYstrncpy(killbuffer, &Buf[Mark],
		      HTMIN(reglen, (int)sizeof(killbuffer)-1));
	    for (i = Mark; Buf[i+reglen]; i++)
		Buf[i] = Buf[i+reglen];
	    Buf[i] = Buf[i+reglen]; /* terminate */
	    Pos = Mark;
	}
	if (Mark >= 0)
	    Mark = -1 - Mark;		/* Disable it */
	break;

    case LYE_YANK:
	/*
	 *  primitive emacs-like yank
	 */
	if (!killbuffer[0]) {
	    Mark = -1 - Pos;
	    return(0);
	}
	{
	    int yanklen = strlen(killbuffer);

	    if (Pos+yanklen <= (MaxLen) && StrLen+yanklen <= (MaxLen)) {
		Mark = -1 - Pos;

		for(i = length; i >= Pos; i--)    /* Make room */
		    Buf[i+yanklen] = Buf[i];
		for (i = 0; i < yanklen; i++)
		    Buf[Pos++] = UCH(killbuffer[i]);

	    } else if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	}
a2043 2
#endif /* ENHANCED_LINEEDIT */

a2059 13
/*
**  This function prompts for a choice or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM & LE
*/
PUBLIC int get_popup_number ARGS3(
	char *,		msg,
	int *,		c,
	int *,		rel)
{
    char temp[120];
    char *p = temp;
    int num;
d2061 1
a2061 59
    /*
     *  Load the c argument into the prompt buffer.
     */
    temp[0] = (char) *c;
    temp[1] = '\0';
    _statusline(msg);

    /*
     *  Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	*rel = '\0';
	return(0);
    }

    *rel = '\0';
    num = atoi(p);
    while ( isdigit(UCH(*p)) )
	++p;
    switch ( *p ) {
    case '+': case '-':
	/* 123+ or 123- */
	*rel = *p++; *c = *p;
	break;
    default:
	*c = *p++;
	*rel = *p;
	break;
    case 0:
	break;
    }

    /*
     *  If we had a 'g' or 'p' suffix, load it into c.
     *  Otherwise, zero c.  Then return the number.
     */
    if ( *p == 'g' || *p == 'G' ) {
	*c = 'g';
    } else if (*p == 'p' || *p == 'P' ) {
	*c = 'p';
    } else {
	*c = '\0';
    }
    if ( *rel != '+' && *rel != '-' )
	*rel = 0;
    return num;
}

#ifdef USE_COLOR_STYLE
#  define TmpStyleOn(s)		curses_style((s), STACK_ON)
#  define TmpStyleOff(s)	curses_style((s), STACK_OFF)
#else
#  define TmpStyleOn(s)
#  define TmpStyleOff(s)
#endif	/* defined USE_COLOR_STYLE */

PUBLIC void LYRefreshEdit ARGS1(
a2069 7
#ifdef SUPPORT_MULTIBYTE_EDIT
    int begin_multi = 0;
    int end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
#ifdef USE_COLOR_STYLE
    int estyle, prompting = 0;
#endif
d2093 2
a2094 3
    if ((DspStart + DspWdth) <= length) {
	if (Pos >= (DspStart + DspWdth) - Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
a2095 1215
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (HTCJK != NOCJK) {
		int tmp = (Pos - DspWdth) + Margin;

		while (DspStart < tmp) {
		    if (!isascii(Buf[DspStart]))
			DspStart++;
		    DspStart++;
		}
	    } else {
		DspStart = (Pos - DspWdth) + Margin;
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
	}
    }

    if (Pos < DspStart + Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK) {
	    int tmp = Pos - Margin;

	    DspStart = 0;
	    while (DspStart < tmp) {
		if (!isascii(Buf[DspStart]))
		    DspStart++;
		DspStart++;
	    }
	} else {
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
    }

    str = &Buf[DspStart];
#ifdef SUPPORT_MULTIBYTE_EDIT
    if (HTCJK != NOCJK && !isascii(str[0]))
	begin_multi = 1;
#endif /* SUPPORT_MULTIBYTE_EDIT */

    nrdisplayed = length-DspStart;
    if (nrdisplayed > DspWdth)
	nrdisplayed = DspWdth;

    LYmove(edit->sy, edit->sx);
#ifdef USE_COLOR_STYLE
    /*
     *  If this is the last screen line, set attributes to normal,
     *  should only be needed for color styles.  The curses function
     *  may be used directly to avoid complications. - kw
     */
    if (edit->sy == (LYlines - 1))
	prompting = 1;
    if (prompting)
	estyle = s_prompt_edit;
    else
	estyle = s_aedit;
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.getstr: switching to <edit.%s>.\n",
		  prompting ? "prompt" : "active"));
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_ON);
    else
	wattrset(LYwin,A_NORMAL); /* need to do something about colors? */
#endif
    if (edit->hidden) {
	for (i = 0; i < nrdisplayed; i++)
	    LYaddch('*');
    } else {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 && DspStart > Mark)
	    TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	for (i = 0; i < nrdisplayed; i++) {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			       || (DspStart + i == Pos && Pos < Mark) ))
		TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			       || (DspStart + i == Pos && Pos > Mark) ))
		TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	    if ((buffer[0] = str[i]) == 1 || buffer[0] == 2 ||
		(UCH(buffer[0]) == 160 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK ||
		   (LYCharSet_UC[current_char_set].enc != UCT_ENC_8859 &&
		    !(LYCharSet_UC[current_char_set].like8859
		      & UCT_R_8859SPECL))))) {
		LYaddch(' ');
#ifdef SUPPORT_MULTIBYTE_EDIT
		end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    } else {
		/* For CJK strings, by Masanobu Kimura */
		if (HTCJK != NOCJK && !isascii(buffer[0])) {
#ifndef SUPPORT_MULTIBYTE_EDIT
		    if (i < (nrdisplayed - 1))
			buffer[1] = str[++i];
#else /* SUPPORT_MULTIBYTE_EDIT */
		    if (i < (nrdisplayed - 1)) {
			buffer[1] = str[++i];
			end_multi = 1;
		    } else
			end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		} else {
		    LYaddstr(buffer);
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
		}
	    }
	}
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (Mark >= 0 &&
	    ((DspStart + nrdisplayed <= Mark && DspStart + nrdisplayed > Pos)
	     || (DspStart + nrdisplayed > Mark
		 && DspStart + nrdisplayed <= Pos)))
	    TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
    }

    /*
     *	Erase rest of input area.
     */
    padsize = DspWdth-nrdisplayed;
    if (padsize) {
	TmpStyleOn(prompting ? s_prompt_edit_pad : s_aedit_pad);
	while (padsize--)
	    LYaddch(UCH(edit->pad));
	TmpStyleOff(prompting ? s_prompt_edit_pad : s_aedit_pad);
    }

    /*
     *	Scrolling indicators.
     */
    if (edit->panon) {
	if ((DspStart + nrdisplayed) < length) {
	    int add_space = 0;

	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (end_multi)
		add_space = 1;
#endif
	    LYmove(edit->sy, edit->sx + nrdisplayed - 1 - add_space);
	    if (add_space)
		LYaddch(' ');		/* Needed with styles? */
	    LYaddch(ACS_RARROW);
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
	if (DspStart) {
	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
	    LYmove(edit->sy, edit->sx);
	    LYaddch(ACS_LARROW);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (begin_multi)
		LYaddch(' ');		/* Needed with styles? */
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
    }

    LYmove(edit->sy, edit->sx + Pos - DspStart);
#ifdef SUPPORT_MULTIBYTE_EDIT
#if (!USE_SLANG && !defined(USE_MULTIBYTE_CURSES))
    if (HTCJK != NOCJK)
	lynx_force_repaint();
#endif /* !USE_SLANG && !defined(USE_MULTIBYTE_CURSES) */
#endif /* SUPPORT_MULTIBYTE_EDIT */

#ifdef USE_COLOR_STYLE
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_OFF);
#endif
    LYrefresh();
}

PRIVATE void reinsertEdit ARGS2(
    EditFieldData *,	edit,
    char *,		result)
{
    if (result != 0) {
	LYEdit1(edit, '\0', LYE_ERASE, FALSE);
	while (*result != '\0') {
	    LYLineEdit(edit, (int)(*result), FALSE);
	    result++;
	}
    }
}

PRIVATE int caselessCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
{
    return strcasecomp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
}

PRIVATE int normalCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
{
    return strcmp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
}

PRIVATE char **sortedList ARGS2(
    HTList *,	list,
    BOOL,	ignorecase)
{
    unsigned count = HTList_count(list);
    unsigned j = 0;
    unsigned k, jk;
    char **result = typecallocn(char *, count + 1);

    if (result == 0)
	outofmem(__FILE__, "sortedList");

    while (!HTList_isEmpty(list))
	result[j++] = HTList_nextObject(list);

    if (count > 1) {
	qsort((char *)result, count, sizeof(*result),
	      ignorecase ? caselessCmpList : normalCmpList);

	/* remove duplicate entries from the sorted index */
	for (j = 0; result[j] != 0; j++) {
	    k = j;
	    while (result[k] != 0
	     && !strcmp(result[j], result[k])) {
		k++;
	    }
	    k--;
	    if (j != k) {
		for (jk = j; ; jk++) {
		    result[jk] = result[jk + k - j];
		    if (result[jk] == 0)
			break;
		}
	    }
	}
    }

    return result;
}

PUBLIC int LYarrayLength ARGS1(
    CONST char **,	list)
{
    int result = 0;

    while (*list++ != 0)
	result++;
    return result;
}

PUBLIC int LYarrayWidth ARGS1(
    CONST char **,	list)
{
    int result = 0;
    int check;

    while (*list != 0) {
	check = strlen(*list++);
	if (check > result)
	    result = check;
    }
    return result;
}

PRIVATE void FormatChoiceNum ARGS4(
	char *,		dst,
	int,		num_choices,
	int,		choice,
	CONST char *,	value)
{
    if (num_choices >= 0) {
	int digits = (num_choices > 9) ? 2 : 1;
	sprintf(dst, "%*d: %.*s",
			digits, (choice + 1),
			MAX_LINE - 9 - digits, value);
    } else {
	LYstrncpy(dst, value, MAX_LINE-1);
    }
}

PRIVATE unsigned options_width ARGS1(
	CONST char **,	list)
{
    unsigned width = 0;
    int count = 0;

    while (list[count] != 0) {
	if (strlen(list[count]) > width) {
	    width = strlen(list[count]);
	}
	count++;
    }
    return width;
}

PRIVATE void draw_option ARGS7(
    WINDOW *,		win,
    int,		entry,
    int,		width,
    BOOL,		reversed,
    int,		num_choices,
    int,		number,
    CONST char *,	value)
{
    char Cnum[MAX_LINE];

    FormatChoiceNum(Cnum, num_choices, number, "");
#ifdef USE_SLANG
    SLsmg_gotorc(win->top_y + entry, (win->left_x + 2));
    LYaddstr(Cnum);
    if (reversed)
	SLsmg_set_color(2);
    SLsmg_write_nstring((char *)value, win->width);
    if (reversed)
	SLsmg_set_color(0);
#else
    wmove(win, entry, 1);
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
    LynxWChangeStyle(win, s_menu_number, STACK_ON);
    waddstr(win, Cnum);
    LynxWChangeStyle(win, s_menu_number, STACK_OFF);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_ON);
#else
    if (reversed)
	wstart_reverse(win);
#endif
    LYpaddstr(win, width, value);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_OFF);
#else
    if (reversed)
	wstop_reverse(win);
#endif
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
#endif /* USE_SLANG */
}

/*
 *  This function offers the choices for values of an
 *  option via a popup window which functions like
 *  that for selection of options in a form. - FM
 *
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
 */
PUBLIC int LYhandlePopupList ARGS9(
	int,		cur_choice,
	int,		ly,
	int,		lx,
	CONST char **,	choices,
	int,		width,
	int,		i_length,
	int,		disabled,
	BOOLEAN,	for_mouse,
	BOOLEAN,	numbered)
{
    int c = 0, cmd = 0, i = 0, j = 0, rel = 0;
    int orig_choice;
    WINDOW * form_window;
    int num_choices = 0;
    int max_choices = 0;
    int top, bottom, length = -1;
    int window_offset = 0;
    int lines_to_show;
    char Cnum[64];
    int Lnum;
    int npages;
    static char prev_target[MAX_LINE];		/* Search string buffer */
    static char prev_target_buffer[MAX_LINE];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0, recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN ReDraw = FALSE;
    int number;
    char buffer[MAX_LINE];
    char *popup_status_msg = NULL;
    CONST char **Cptr = NULL;
#define CAN_SCROLL_DOWN	1
#define CAN_SCROLL_UP	2
#define CAN_SCROLL	4
    int can_scroll = 0, can_scroll_was = 0;

    orig_choice = cur_choice;
    if (cur_choice < 0)
	cur_choice = 0;

    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;

    /*
     *	Count the number of choices to be displayed, where
     *	num_choices ranges from 0 to n, and set width to the
     *	longest choice string length.  Also set Lnum to the
     *	length for the highest choice number, then decrement
     *	num_choices so as to be zero-based.  The window width
     *	will be based on the sum of width and Lnum. - FM
     */
    num_choices = LYarrayLength(choices) - 1;
    if (width <= 0)
	width = options_width(choices);
    if (numbered) {
	sprintf(Cnum, "%d: ", num_choices);
	Lnum = strlen(Cnum);
	max_choices = num_choices;
    } else {
	Lnum = 0;
	max_choices = -1;
    }

    /*
     *  Let's assume for the sake of sanity that ly is the number
     *   corresponding to the line the choice is on.
     *  Let's also assume that cur_choice is the number of the
     *   item that should be initially selected, as 0 being the
     *   first item.
     *  So what we have, is the top equal to the current screen line
     *   subtracting the cur_choice + 1 (the one must be for the
     *   top line we will draw in a box).  If the top goes under 0,
     *   consider it 0.
     */
    top = ly - (cur_choice + 1);
    if (top < 0)
	top = 0;

    /*
     *  Check and see if we need to put the i_length parameter up to
     *  the number of real choices.
     */
    if (i_length < 1) {
	i_length = num_choices;
    } else {
	/*
	 *  Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     *  The bottom is the value of the top plus the number of options
     *  to view plus 3 (one for the top line, one for the bottom line,
     *  and one to offset the 0 counted in the num_choices).
     */
    bottom = top + i_length + 3;

    /*
     *  Set lines_to_show based on the user_mode global.
     */
    if (user_mode == NOVICE_MODE)
	lines_to_show = LYlines-4;
    else
	lines_to_show = LYlines-2;

    if (for_mouse && user_mode == NOVICE_MODE && lines_to_show > 2)
	lines_to_show--;

    /*
     *  Hmm...  If the bottom goes beyond the number of lines available,
     */
    if (bottom > lines_to_show) {
	/*
	 *  Position the window at the top if we have more
	 *  choices than will fit in the window.
	 */
	if ((i_length + 3) > lines_to_show) {
	    top = 0;
	    bottom = (top + (i_length + 3));
	    if (bottom > lines_to_show)
		bottom = (lines_to_show + 1);
	} else {
	    /*
	     *  Try to position the window so that the selected choice will
	     *    appear where the selection box currently is positioned.
	     *  It could end up too high, at this point, but we'll move it
	     *    down latter, if that has happened.
	     */
	    top = (lines_to_show + 1) - (i_length + 3);
	    bottom = (lines_to_show + 1);
	}
    }

    /*
     *  This is really fun, when the length is 4, it means 0 to 4, or 5.
     */
    length = (bottom - top) - 2;
    if (length <= num_choices)
	can_scroll = CAN_SCROLL;

    /*
     *  Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > lines_to_show + 1)
	    bottom = lines_to_show + 1;
	top = bottom - length - 2;
    }

    if (for_mouse) {
	/* shift horizontally to lie within screen width, if possible */
	if (Lnum + (int)width + 4 < LYcols) {
	    if (lx - 1 + (Lnum + (int)width + 4) > LYcols)
		lx = LYcols + 1 - (Lnum + width + 4);
	    else if (lx <= 0)
		lx = 1;
	}
    }

    /*
     *  Set up the overall window, including the boxing characters ('*'),
     *  if it all fits.  Otherwise, set up the widest window possible. - FM
     */
    if (num_choices <= 0
     || cur_choice > num_choices
     || (form_window = LYstartPopup(top, lx, bottom - top, Lnum + width)) == 0)
	return(orig_choice);

    /*
     *	Clear the command line and write
     *	the popup statusline. - FM
     */
    LYmove((LYlines - 2), 0);
    LYclrtoeol();
    if (disabled) {
	popup_status_msg = CHOICE_LIST_UNM_MSG;
    } else if (!for_mouse) {
	popup_status_msg = CHOICE_LIST_MESSAGE;
#if defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES))
    } else {
	popup_status_msg = gettext(
		"Left mouse button or return to select, arrow keys to scroll.");
#endif
    }
    _statusline(popup_status_msg);

    /*
     *  Set up the window_offset for choices.
     *   cur_choice ranges from 0...n
     *   length ranges from 0...m
     */
    if (cur_choice >= length) {
	window_offset = cur_choice - length + 1;
    }

    /*
     *  Compute the number of popup window pages. - FM
     */
    npages = ((num_choices + 1) > length) ?
		(((num_choices + 1) + (length - 1))/(length))
					  : 1;
/*
 *  OH!  I LOVE GOTOs! hack hack hack
 */
redraw:

    /*
     *  Display the boxed choices.
     */
    for (i = 0; i <= num_choices; i++) {
	if (i >= window_offset && i - window_offset < length) {
	    draw_option (form_window, ((i + 1) - window_offset), width, FALSE,
			 max_choices, i, choices[i]);
	}
    }
    LYbox(form_window, (BOOLEAN)!numbered);
    Cptr = NULL;

    /*
     *  Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {
	int row = ((i + 1) - window_offset);

	/* Show scroll indicators. */
	if (can_scroll) {
	    can_scroll = ((window_offset ? CAN_SCROLL_UP : 0)
			  | (num_choices - window_offset >= length
			     ? CAN_SCROLL_DOWN : 0));
	    if (~can_scroll & can_scroll_was) {	/* Need to redraw */
		LYbox(form_window, (BOOLEAN)!numbered);
		can_scroll_was = 0;
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_UP) {
		wmove(form_window, 1, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_UARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_DOWN) {
		wmove(form_window, length, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_DARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	}

	/*
	 *  Unreverse cur choice.
	 */
	if (Cptr != NULL) {
	    draw_option (form_window, row, width, FALSE,
			 max_choices, i, Cptr[i]);
	}
	Cptr = choices;
	i = cur_choice;
	row = ((cur_choice + 1) - window_offset);
	draw_option (form_window, row, width, TRUE,
		     max_choices, cur_choice, Cptr[cur_choice]);
	LYstowCursor(form_window, row, 1);

	c = LYgetch_choice();
	if (term_options || LYCharIsINTERRUPT(c)) { /* Control-C or Control-G */
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, row, &cur_choice)) < 0)
		goto redraw;
	    if  (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = LKC_TO_LAC(keymap,c);
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
		/* FALLTHRU */
	    case LYK_1: /* FALLTHRU */
	    case LYK_2: /* FALLTHRU */
	    case LYK_3: /* FALLTHRU */
	    case LYK_4: /* FALLTHRU */
	    case LYK_5: /* FALLTHRU */
	    case LYK_6: /* FALLTHRU */
	    case LYK_7: /* FALLTHRU */
	    case LYK_8: /* FALLTHRU */
	    case LYK_9:
		/*
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
		 */
		number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);

		/* handle + or - suffix */
		CTRACE((tfp,"got popup option number %d, ",number));
		CTRACE((tfp,"rel='%c', c='%c', cur_choice=%d\n",
				rel, c, cur_choice));
		if ( c == 'p' ) {
		    int curpage = ((cur_choice + 1) > length) ?
			(((cur_choice + 1) + (length - 1))/(length))
					  : 1;
		    CTRACE((tfp,"  curpage=%d\n",curpage));
		    if ( rel == '+' )
			number = curpage + number;
		    else if ( rel == '-' )
			number = curpage - number;
		} else if ( rel == '+' ) {
		    number = cur_choice + number + 1;
		} else if ( rel == '-' ) {
		    number = cur_choice - number + 1;
		}
		if ( rel ) CTRACE((tfp,"new number=%d\n",number));
		/*
		 *  Check for a 'p' suffix. - FM
		 */
		if (c == 'p') {
		    /*
		     *  Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = 0;
			cur_choice = 0;
			_statusline(popup_status_msg);
			goto redraw;
		    }

		    /*
		     *  Treat a number equal to or greater than the
		     *  number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_choices - length) + 1)) {
			    HTUserMsg(ALREADY_AT_OPTION_END);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_choices - length)) {
			    window_offset = (num_choices - length + 1);
			}
			if (cur_choice < window_offset)
			    cur_choice = window_offset;
			_statusline(popup_status_msg);
			goto redraw;
		    }

		    /*
		     *  We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
			char *msg = 0;
			HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
			HTUserMsg(msg);
			FREE(msg);
			_statusline(popup_status_msg);
			break;
		    }
		    cur_choice = window_offset = ((number - 1) * length);
		    _statusline(popup_status_msg);
		    goto redraw;

		}

		/*
		 *  Check for a positive number, which signifies
		 *  that a choice should be sought. - FM
		 */
		if (number > 0) {
		    /*
		     *  Decrement the number so as to correspond
		     *  with our cur_choice values. - FM
		     */
		    number--;

		    /*
		     *  If the number is in range and had no legal
		     *  suffix, select the indicated choice. - FM
		     */
		    if (number <= num_choices && c == '\0') {
			cur_choice = number;
			cmd = LYK_ACTIVATE;
			break;
		    }

		    /*
		     *  Verify that we had a 'g' suffix,
		     *  and act on the number. - FM
		     */
		    if (c == 'g') {
			if (cur_choice == number) {
			    /*
			     *  The choice already is current. - FM
			     */
			    char *msg = 0;
			    HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(msg);
			    FREE(msg);
			    _statusline(popup_status_msg);
			    break;
			}

			if (number <= num_choices) {
			    /*
			     *  The number is in range and had a 'g'
			     *  suffix, so make it the current option,
			     *  scrolling if needed. - FM
			     */
			    j = (number - cur_choice);
			    cur_choice = number;
			    if ((j > 0) &&
				(cur_choice - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_choices - length + 1))
				    window_offset = (num_choices - length + 1);
			    } else if ((cur_choice - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    _statusline(popup_status_msg);
			    goto redraw;
			}

			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_OPTION_NUM_ENTERED);
		    }
		}

		/*
		 *  Restore the popup statusline. - FM
		 */
		_statusline(popup_status_msg);
		break;

	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:

		if (cur_choice > 0)
		    cur_choice--;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_LPOS_NEXT_LINK:
	    case LYK_FASTFORW_LINK:
	    case LYK_DOWN_LINK:
		if (cur_choice < num_choices)
		    cur_choice++;

		/*
		 *  Scroll the window down if necessary
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_PAGE:
		/*
		 *  Okay, are we on the last page of the list?
		 *  If not then,
		 */
		if (window_offset != (num_choices - length + 1)) {
		    /*
		     *	Modify the current choice to not be a
		     *  coordinate in the list, but a coordinate
		     *  on the item selected in the window.
		     */
		    cur_choice -= window_offset;

		    /*
		     *  Page down the proper length for the list.
		     *  If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }

		    /*
		     *  Readjust the current selection to be a
		     *  list coordinate rather than window.
		     *  Redraw this thing.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		}
		else if (cur_choice < num_choices) {
		    /*
		     *  Already on last page of the list so just
		     *  redraw it with the last item selected.
		     */
		    cur_choice = num_choices;
		}
		break;

	    case LYK_PREV_PAGE:
		/*
		 *  Are we on the first page of the list?
		 *  If not then,
		 */
		if (window_offset != 0) {
		    /*
		     *  Modify the current selection to not be a
		     *  list coordinate, but a window coordinate.
		     */
		    cur_choice -= window_offset;

		    /*
		     *  Page up the proper length.
		     *  If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }

		    /*
		     *  Readjust the current choice.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		} else if (cur_choice > 0) {
		    /*
		     *  Already on the first page so just
		     *  back up to the first item.
		     */
		    cur_choice = 0;
		}
		break;

	    case LYK_HOME:
		cur_choice = 0;
		if (window_offset > 0) {
		    window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_END:
		cur_choice = num_choices;
		if (window_offset != (num_choices - length + 1)) {
		    window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_DOWN_TWO:
		cur_choice += 2;
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_TWO:
		cur_choice -= 2;
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_DOWN_HALF:
		cur_choice += (length/2);
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_HALF:
		cur_choice -= (length/2);
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;

	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
		    /*
		     *  We got a 'n'ext command with no prior query
		     *  specified within the popup window.  See if
		     *  one was entered when the popup was retracted,
		     *  and if so, assume that's what's wanted.  Note
		     *  that it will become the default within popups,
		     *  unless another is entered within a popup.  If
		     *  the within popup default is to be changed at
		     *  that point, use WHEREIS ('/') and enter it,
		     *  or the up- or down-arrow keys to seek any of
		     *  the previously entered queries, regardless of
		     *  whether they were entered within or outside
		     *  of a popup window. - FM
		     */
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			LYstrncpy(prev_target_buffer, cp, sizeof(prev_target_buffer));
			QueryNum = 0;
			FirstRecall = FALSE;
		    }
		}
		strcpy(prev_target, prev_target_buffer);
		/* FALLTHRU */
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		}

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
		    /*
		     *  No entry.  Simply break.   - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
			    }
			} else {
			    QueryNum = 0;
			}
		    } else {
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
		    }
		    if (QueryNum >= QueryTotal) {
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *  User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  first query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = 0;
				 QueryNum < (QueryTotal - 1); QueryNum++) {
				if ((cp = (char *)HTList_objectAt(
							    search_queries,
							    QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
					break;
				}
			    }
			} else {
			    QueryNum = (QueryTotal - 1);
			}
		    } else {
			/*
			 *  Advance to the next query in the list. - FM
			 */
			QueryNum--;
		    }
		    if (QueryNum < 0) {
			/*
			 *  Roll around to the first query in the list. - FM
			 */
			QueryNum = (QueryTotal - 1);
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		}
		/*
		 *  Replace the search string buffer with the new target. - FM
		 */
		strcpy(prev_target_buffer, prev_target);
		HTAddSearchQuery(prev_target_buffer);

		/*
		 *  Start search at the next choice. - FM
		 */
		for (j = 1; Cptr[i+j] != NULL; j++) {
		    FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i+j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (Cptr[i+j] != NULL) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    cur_choice += j;
		    /*
		     *  Scroll the window down if necessary.
		     */
		    if ((cur_choice - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_choices - length + 1))
			    window_offset = (num_choices - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}
d2097 5
a2101 7
		/*
		 *  If we started at the beginning, it can't be present. - FM
		 */
		if (cur_choice == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}
d2103 1
a2103 30
		/*
		 *  Search from the beginning to the current choice. - FM
		 */
		for (j = 0; j < cur_choice; j++) {
		    FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_choice) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    j = (cur_choice - j);
		    cur_choice -= j;
		    /*
		     *  Scroll the window up if necessary.
		     */
		    if ((cur_choice - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}
d2105 3
a2107 4
		/*
		 *  Didn't find it in the preceding choices either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
d2109 36
a2144 14
restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		_statusline(popup_status_msg);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
d2146 9
a2154 1
		break;
d2156 11
a2166 7
	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
	    case LYK_INTERRUPT:
		cur_choice = orig_choice;
		cmd = LYK_ACTIVATE; /* to exit */
		break;
a2168 1
    LYstopPopup();
d2170 2
a2171 1
    return(disabled ? orig_choice : cur_choice);
a2173 1
#define CurModif MyEdit.current_modifiers
d2176 1
a2176 1
	char *,		inputline,
d2178 2
a2179 2
	size_t,		bufsize,
	RecallType,	recall)
a2182 3
    int xlec = -2;
    int last_xlec = -1;
    int last_xlkc = -1;
d2184 1
a2184 3
#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d2190 1
a2190 1
    MyEdit.hidden = (BOOL) hidden ;
a2191 1
    CTRACE((tfp, "called LYgetstr\n"));
a2193 1
#ifndef SUPPORT_MULTIBYTE_EDIT
d2195 10
a2204 10
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (refresh_mb)
	    LYRefreshEdit(&MyEdit);
#endif /* SUPPORT_MULTIBYTE_EDIT */
	ch = LYReadCmdKey(FOR_PROMPT);
#ifdef SUPPORT_MULTIBYTE_EDIT
#ifdef CJK_EX	/* for SJIS code */
	if (!refresh_mb
	 && (EditBinding(ch) != LYE_CHAR))
	    goto again;
d2206 1
a2206 11
	if (!refresh_mb
	 && (EditBinding(ch) != LYE_CHAR)
	 && (EditBinding(ch) != LYE_AIX))
	    goto again;
#endif
#endif /* SUPPORT_MULTIBYTE_EDIT */

	if (term_letter || term_options
#ifdef VMS
	      || HadVMSInterrupt
#endif /* VMS */
d2210 2
a2211 3
	      ) {
#ifdef VMS
	    HadVMSInterrupt = FALSE;
d2213 3
a2215 7
	    ch = LYCharINTERRUPT2;
	}

	if (recall != NORECALL && (ch == UPARROW || ch == DNARROW)) {
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
	    LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) recall\n", inputline));
d2218 1
a2218 9
	ch |= CurModif;
	CurModif = 0;
	if (last_xlkc != -1) {
	    if (ch == last_xlkc)
		ch |= LKC_MOD3;
	    last_xlkc = -1;	/* consumed */
	}
#ifndef WIN_EX
	if (LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
d2220 1
a2220 22
#endif
	last_xlec = xlec;
	xlec = EditBinding(ch);
	if ((xlec & LYE_DF) && !(xlec & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    xlec &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}
	switch (xlec) {
	case LYE_SETM1:
	    /*
	     *  Set flag for modifier 1.
	     */
	    CurModif |= LKC_MOD1;
	    break;
	case LYE_SETM2:
	    /*
	     *  Set flag for modifier 2.
	     */
	    CurModif |= LKC_MOD2;
	    break;
d2222 9
a2230 39
	    if (xlec == last_xlec && recall != NORECALL) {
		HTList *list = whichRecall(recall);
		if (!HTList_isEmpty(list)) {
		    char **data = sortedList(list, (BOOL)(recall == RECALL_CMD));
		    int old_y, old_x;
		    int cur_choice = 0;
		    int num_options = LYarrayLength((CONST char **)data);

		    while (cur_choice < num_options
		     && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
			cur_choice++;
#ifdef USE_SLANG
		    old_y = SLsmg_get_row();
		    old_x = SLsmg_get_column();
#else
		    getyx(LYwin, old_y, old_x);
#endif

		    cur_choice = LYhandlePopupList(
			cur_choice,
			0,
			old_x,
			(CONST char **)data,
			-1,
			-1,
			FALSE,
			FALSE,
			TRUE);
		    if (cur_choice >= 0) {
			if (recall == RECALL_CMD)
			    _statusline(": ");
			reinsertEdit(&MyEdit, data[cur_choice]);
		    }
#ifdef USE_SLANG
		    SLsmg_gotorc(old_y, old_x);
#else
		    wmove(LYwin, old_y, old_x);
#endif
		    FREE(data);
d2233 1
a2233 1
		reinsertEdit(&MyEdit, LYFindInCloset(recall, MyEdit.buffer));
a2235 2

#ifndef CJK_EX	/* 1997/11/03 (Mon) 20:13:45 */
d2245 1
a2245 2
		 LYlowest_eightbit[current_char_set] <= 0x97))
	    {
a2248 2
	    /* FALLTHRU */
#endif
d2253 2
a2254 4
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
	    if (!hidden)
		LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) LYE_ENTER\n", inputline));
a2256 37
#ifdef CAN_CUT_AND_PASTE
	/* 1998/10/01 (Thu) 15:05:49 */

	case LYE_PASTE:
	    {
		unsigned char *s = get_clip_grab(), *e;
		int len;

		if (!s)
		    break;
		len = strlen(s);
		e = s + len;

		if (len > 0) {
		    unsigned char *e1 = s;

		    while (e1 < e) {
			if (*e1 < ' ') { /* Stop here? */
			    if (e1 > s)
				LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
			    s = e1;
			    if (*e1 == '\t') { /* Replace by space */
				LYEditInsert(&MyEdit, " ", 1, map_active, TRUE);
				s = ++e1;
			    } else
				break;
			} else
			    ++e1;
		    }
		    if (e1 > s)
			LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
		}
		get_clip_release();
		break;
	    }
#endif

a2261 10
	    CTRACE((tfp, "LYgetstr LYE_ABORT\n"));
	    return(-1);

	case LYE_STOP:
	    /*
	     *	Deactivate.
	     */
	    CTRACE((tfp, "LYgetstr LYE_STOP\n"));
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
a2262 7
#else
#ifdef ENHANCED_LINEEDIT
	    if (Mark >= 0)
		Mark = -1 - Mark;		/* Disable it */
#endif
#endif
	    break;
a2280 10
	    if (xlec & LYE_FORM_LAC) {
		/*
		 *	Used in form_getstr() to end line editing and
		 *	pass on the lynxkeycode already containing a
		 *	lynxactioncode.  Here it is just ignored. - kw
		 */
		break;
	    }

#ifndef SUPPORT_MULTIBYTE_EDIT
a2281 12
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (LYLineEdit(&MyEdit, ch, FALSE) == 0) {
		if (refresh_mb && HTCJK != NOCJK && (0x81 <= ch) && (ch <= 0xfe))
		    refresh_mb = FALSE;
		else
		    refresh_mb = TRUE;
	    } else {
		if (!refresh_mb) {
		    LYEdit1(&MyEdit, 0, LYE_DELP, FALSE);
		}
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
a2285 22
PUBLIC CONST char * LYLineeditHelpURL NOARGS
{
    static int lasthelp_lineedit = -1;
    static char helpbuf[LY_MAXPATH] = "\0";
    static char *phelp = &helpbuf[0];
    if (lasthelp_lineedit == current_lineedit)
	return &helpbuf[0];
    if (lasthelp_lineedit == -1) {
	LYstrncpy(helpbuf, helpfilepath, sizeof(helpbuf) - 1);
	phelp += strlen(helpbuf);
    }
    if (LYLineeditHelpURLs[current_lineedit] &&
	strlen(LYLineeditHelpURLs[current_lineedit]) &&
	(strlen(LYLineeditHelpURLs[current_lineedit]) <=
	 sizeof(helpbuf) - (phelp - helpbuf))) {
	LYstrncpy(phelp, LYLineeditHelpURLs[current_lineedit],
		  sizeof(helpbuf) - (phelp - helpbuf) - 1);
	lasthelp_lineedit = current_lineedit;
	return (&helpbuf[0]);
    }
    return NULL;
}
d2298 5
d2321 2
a2322 2
	char *,		chptr,
	CONST char *,	tarptr)
d2348 2
a2349 2
	char *,		chptr,
	char *,		tarptr)
d2402 2
a2403 2
	char *,		chptr,
	char *,		tarptr)
d2448 2
a2449 7
 * The physical lengths of the displayed string up to the start and
 * end (= next position after) of the target string are returned in *nstartp
 * and *nendp if the search is successful.
 *   These lengths count glyph cells if count_gcells is set. (Full-width
 *   characters in CJK mode count as two.)  Normally that's what we want.
 *   They count actual glyphs if count_gcells is unset. (Full-width
 *   characters in CJK mode count as one.)
d2453 2
a2454 2
 *			      LY_BOLD_END_CHAR
 *			      LY_SOFT_HYPHEN
d2459 3
a2461 3
PUBLIC char * LYno_attr_mbcs_case_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
a2462 1
	BOOL,		count_gcells,
d2466 1
a2466 2
    char *tmpchptr;
    CONST char *tmptarptr;
d2502 3
a2504 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
a2518 1
		    if (count_gcells) tarlen++;
d2523 2
a2524 2
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
d2527 1
a2533 1
		    if (count_gcells) len++;
d2541 1
a2541 1
		if (!IsSpecialAttrChar(*tmpchptr)) {
a2547 1
			    if (count_gcells) tarlen++;
d2549 1
a2549 1
			    break;
d2561 1
a2561 1
		} else {
d2563 1
a2563 1
		}
d2565 8
a2572 7
		if (*tmptarptr == '\0') {
		    if (nstartp)	*nstartp = offset;
		    if (nendp)		*nendp = len + tarlen;
		    return(chptr);
		}
		if (*tmpchptr == '\0')
		    break;
a2579 1
		if (count_gcells) len++;
d2593 2
a2594 6
 *  end (= next position after) the target string are returned in *nstartp
 *  and *nendp if the search is successful.
 *    These lengths count glyph cells if count_gcells is set. (Full-width
 *    characters in CJK mode count as two.)  Normally that's what we want.
 *    They count actual glyphs if count_gcells is unset. (Full-width
 *    characters in CJK mode count as one.)
d2599 1
a2599 1
 *			      LY_SOFT_HYPHEN
d2604 3
a2606 3
PUBLIC char * LYno_attr_mbcs_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
a2607 1
	BOOL,		count_gcells,
d2611 1
a2611 2
    char *tmpchptr;
    CONST char *tmptarptr;
d2643 3
a2645 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
a2658 1
		    if (count_gcells) tarlen++;
d2663 2
a2664 2
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
d2667 1
a2673 1
		    if (count_gcells) len++;
a2687 1
			    if (count_gcells) tarlen++;
d2705 2
a2706 2
		     if (nstartp)	*nstartp = offset;
		     if (nendp)		*nendp = len + tarlen;
d2709 1
a2709 1
		if (*tmpchptr == '\0')
d2712 1
a2718 1
		if (count_gcells) len++;
d2727 57
d2794 1
a2794 1
	*dest = typecallocn(char, n + 1);
d2796 1
a2796 1
	    CTRACE((tfp, "Tried to calloc %d bytes\n", n));
d2822 1
a2822 1
	    *dest = typecallocn(char, n + 1);
d2825 2
a2826 2
	    memcpy(*dest, src, n);
	    (*dest)[n] = '\0'; /* terminate */
d2853 1
a2853 1
    high = TABLESIZE(unicode_to_lower_case);
a2885 7
    /* if they are the same or one is a null characters return immediately. */
    if (ch1 == ch2)
	return 0;
    if (!ch2)
	return UCH(ch1);
    else if (!ch1)
	return -UCH(ch2);
d2888 44
a2931 1
    if (UCH(TOASCII(ch1)) < 128 && UCH(TOASCII(ch2)) < 128)
d2935 2
a2936 2
    if (UCH(TOASCII(ch1)) > 127 &&  /* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127)
d2942 23
a2964 6
	    long uni_ch2 = UCTransToUni((char)ch2, current_char_set);
	    long uni_ch1;
	    if (uni_ch2 < 0)
		return UCH(ch1);
	    uni_ch1 = UCTransToUni((char)ch1, current_char_set);
	    return(UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
d2970 1
d2995 2
a2996 8
    if (ferror(fp)) {
	FREE(result);
    } else if (feof(fp) && result && *result == '\0') {
	/*
	 *  If the file ends in the middle of a line, return the
	 *  partial line; if another call is made after this, it
	 *  will return NULL. - kw
	 */
a3002 163

#ifdef EXP_FILE_UPLOAD
static char basis_64[] =
   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

#define B64_LINE       76

PUBLIC void base64_encode ARGS3(
    char *,	dest,
    char *,	src,
    int,	len)
{
    int rlen;   /* length of result string */
    unsigned char c1, c2, c3;
    char *eol, *r, *str;
    int eollen;
    int chunk;

    str = src;
    eol = "\n";
    eollen = 1;

    /* calculate the length of the result */
    rlen = (len+2) / 3 * 4;	/* encoded bytes */
    if (rlen) {
	/* add space for EOL */
	rlen += ((rlen-1) / B64_LINE + 1) * eollen;
    }

    /* allocate a result buffer */
    r = dest;

    /* encode */
    for (chunk=0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE/4)) {
	    char *c = eol;
	    char *e = eol + eollen;
	    while (c < e)
		*r++ = *c++;
	    chunk = 0;
	}
	c1 = *str++;
	c2 = *str++;
	*r++ = basis_64[c1>>2];
	*r++ = basis_64[((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4)];
	if (len > 2) {
	    c3 = *str++;
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
	    *r++ = basis_64[c3 & 0x3F];
	} else if (len == 2) {
	    *r++ = basis_64[(c2 & 0xF) << 2];
	    *r++ = '=';
	} else { /* len == 1 */
	    *r++ = '=';
	    *r++ = '=';
	}
    }
    if (rlen) {
	/* append eol to the result string */
	char *c = eol;
	char *e = eol + eollen;
	while (c < e)
	    *r++ = *c++;
    }
    *r = '\0';  /* every SV in perl should be NUL-terminated */
}

#endif /* EXP_FILE_UPLOAD */

#ifdef EXP_CMD_LOGGING
PRIVATE FILE *cmd_logfile;
PRIVATE FILE *cmd_script;

PUBLIC void LYOpenCmdLogfile ARGS2(
	int,		argc,
	char **,	argv)
{
    int n;

    if (lynx_cmd_logfile != 0) {
	cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
	if (cmd_logfile != 0) {
	    fprintf(cmd_logfile, "# Command logfile created by %s %s (%s)\n",
		LYNX_NAME, LYNX_VERSION, LYVersionDate());
	    for (n = 0; n < argc; n++) {
		fprintf(cmd_logfile, "# Arg%d = %s\n", n, argv[n]);
	    }
	}
    }
}

PUBLIC BOOL LYHaveCmdScript NOARGS
{
    return (BOOL)(cmd_script != 0);
}

PUBLIC void LYOpenCmdScript NOARGS
{
    if (lynx_cmd_script != 0) {
	cmd_script = fopen(lynx_cmd_script, TXT_R);
	CTRACE((tfp, "LYOpenCmdScript(%s) %s\n",
		lynx_cmd_script,
		cmd_script != 0 ? "SUCCESS" : "FAIL"));
    }
}

PUBLIC int LYReadCmdKey ARGS1(
	int,	mode)
{
    int ch = -1;

    if (cmd_script != 0) {
	char *buffer = 0;
	char *src;
	char *tmp;

	while (LYSafeGets(&buffer, cmd_script) != 0) {
	    LYTrimTrailing(buffer);
	    src = LYSkipBlanks(buffer);
	    tmp = LYSkipNonBlanks(src);
	    if (tmp - src != 3
	     || strncasecomp(src, "key", 3))
		continue;
	    src = LYSkipBlanks(tmp);
	    if ((ch = LYStringToKeycode(src)) >= 0) {
		LYrefresh();
		break;
	    }
	}
	FREE(buffer);
    } else {
	ch = LYgetch_for(mode);
    }
    CTRACE((tfp, "LYReadCmdKey(%d) ->%c (%#x)\n", mode, ch, ch));
    LYWriteCmdKey(ch);
    return ch;
}

/*
 * Write a LYKeymapCode 'ch' to the logfile.
 */
PUBLIC void LYWriteCmdKey ARGS1(
	int,	ch)
{
    if (cmd_logfile != 0) {
	fprintf(cmd_logfile, "key %s\n", LYKeycodeToString(ch, FALSE));
    }
}

PUBLIC void LYCloseCmdLogfile NOARGS
{
    if (cmd_logfile != 0) {
	LYCloseOutput(cmd_logfile);
	cmd_logfile = 0;
    }
    if (cmd_script != 0) {
	LYCloseInput(cmd_script);
	cmd_script = 0;
    }
    FREE(lynx_cmd_logfile);
    FREE(lynx_cmd_script);
}
#endif /* EXP_CMD_LOGGING */
@

