head	1.6;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.5
	tg-mergefixes-1-branch:1.5.0.8
	tg-mergefixes-1-base:1.5
	MIROS_X:1.5.0.6
	MIROS_X_BASE:1.5
	MIRBSD_XP_MIRPPC:1.5.0.4
	lynx-2_8_6dev_7b:1.1.3.3
	lynx-2_8_6dev_6:1.1.3.3
	MIRBSD_XP_SPARC_BASE:1.5
	MIRBSD_XP_SPARC:1.5.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.3
	lynx-2_8_6dev_5:1.1.3.3
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.2
	lynx-2_8_5:1.1.3.1
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.1
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.01.03.00.46.04;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.17.03;	author tg;	state Stab;
branches;
next	1.4;

1.4
date	2004.04.30.16.32.36;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.38;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.34;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.27;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.31.27;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.16;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.04.30.16.15.55;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.07.15.15.52.03;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@soft merge
@
text
@#include <HTUtils.h>
#include <HTAlert.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYSearch.h>
#include <LYGlobalDefs.h>
#include <GridText.h>

#include <LYLeaks.h>

static BOOL link_has_target(int cur,
			    char *target)
{
    LinkInfo *a = &links[cur];
    OptionType *option;
    char *stars = NULL;
    const char *cp;
    int count;

    /*
     * Search the hightext strings, if present, taking the case_sensitive
     * setting into account.
     */
    for (count = 0;; ++count) {
	const char *text = LYGetHiliteStr(cur, count);

	if (text == NULL)
	    break;
	if (LYno_attr_strstr(text, target))
	    return TRUE;
    }

    /*
     * Search the relevant form fields, taking the case_sensitive setting into
     * account.  - FM
     */
    if ((a->l_form != NULL && a->l_form->value != NULL) &&
	a->l_form->type != F_HIDDEN_TYPE) {
	if (a->l_form->type == F_PASSWORD_TYPE) {
	    /*
	     * Check the actual, hidden password, and then the displayed
	     * string.  - FM
	     */
	    if (LYno_attr_strstr(a->l_form->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->l_form->value);
	    memset(stars, '*', strlen(stars));
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->l_form->type == F_OPTION_LIST_TYPE) {
	    /*
	     * Search the option strings that are displayed when the popup is
	     * invoked.  - FM
	     */
	    option = a->l_form->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->l_form->type == F_RADIO_TYPE) {
	    /*
	     * Search for checked or unchecked parens.  - FM
	     */
	    if (a->l_form->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->l_form->type == F_CHECKBOX_TYPE) {
	    /*
	     * Search for checked or unchecked square brackets.  - FM
	     */
	    if (a->l_form->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     * Check the values intended for display.  May have been found
	     * already via the hightext search, but make sure here that the
	     * entire value is searched.  - FM
	     */
	    if (LYno_attr_strstr(a->l_form->value, target)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

/*
 * Search for the target string inside of the links that are currently
 * displayed on the screen beginning with the one after the currently selected
 * one.  If found set cur to the new value and return TRUE.  If not found do
 * not reset cur and return FALSE.
 */

static int check_next_target_in_links(int *cur,
				      char *target)
{
    int i;

    if (nlinks != 0) {
	for (i = *cur + 1; i < nlinks; ++i) {
	    if (link_has_target(i, target)) {
		*cur = i;
		return TRUE;
	    }
	}
    }
    return FALSE;
}

static int check_prev_target_in_links(int *cur,
				      char *target)
{
    int i;

    if (nlinks != 0) {
	for (i = *cur - 1; i >= 0; --i) {
	    if (link_has_target(i, target)) {
		*cur = i;
		return TRUE;
	    }
	}
    }
    return FALSE;
}

/*
 * Textsearch checks the prev_target variable to see if it is empty.  If it is
 * then it requests a new search string.  It then searches the current file for
 * the next instance of the search string and finds the line number that the
 * string is on
 *
 * This is the primary USER search engine and is case sensitive or case
 * insensitive depending on the 'case_sensitive' global variable
 */
BOOL textsearch(DocInfo *cur_doc, char *prev_target,
		int target_size,
		int direction)
{
    int offset;
    int oldcur = cur_doc->link;
    static char prev_target_buffer[512];	/* Search string buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0;
    RecallType recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;

    /*
     * Initialize the search string buffer.  - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }

    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;

    if (direction != 0)
	/*
	 * LYK_NEXT or LYK_PREV was pressed, so copy the buffer into
	 * prev_target.
	 */
	LYstrncpy(prev_target, prev_target_buffer, target_size);

    if (strlen(prev_target) == 0) {
	/*
	 * This is a new WHEREIS search ('/'), or LYK_NEXT was pressed but
	 * there was no previous search, so we need to get a search string from
	 * the user.  - FM
	 */
	_statusline(ENTER_WHEREIS_QUERY);

	if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
	    /*
	     * User cancelled the search via ^G.  Restore prev_target and
	     * return.  - FM
	     */
	    LYstrncpy(prev_target, prev_target_buffer, target_size);
	    HTInfoMsg(CANCELLED);
	    return (FALSE);
	}
    }

  check_recall:
    if (strlen(prev_target) == 0 &&
	!(recall && (ch == UPARROW || ch == DNARROW))) {
	/*
	 * No entry.  Simply return, retaining the current buffer.  Because
	 * prev_target is now reset, highlighting of the previous search string
	 * will no longer occur, but it can be used again via LYK_NEXT or
	 * LYK_PREV.
	 */
	HTInfoMsg(CANCELLED);
	return (FALSE);
    }

    if (recall && ch == UPARROW) {
	if (FirstRecall) {
	    /*
	     * Use the current string or last query in the list.  - FM
	     */
	    FirstRecall = FALSE;
	    if (*prev_target_buffer) {
		for (QueryNum = (QueryTotal - 1); QueryNum > 0; QueryNum--) {
		    if ((cp = (char *) HTList_objectAt(search_queries,
						       QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
		    }
		}
	    } else {
		QueryNum = 0;
	    }
	} else {
	    /*
	     * Go back to the previous query in the list.  - FM
	     */
	    QueryNum++;
	}
	if (QueryNum >= QueryTotal)
	    /*
	     * Roll around to the last query in the list.  - FM
	     */
	    QueryNum = 0;
	if ((cp = (char *) HTList_objectAt(search_queries,
					   QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
	    if (*prev_target_buffer &&
		!strcmp(prev_target_buffer, prev_target)) {
		_statusline(EDIT_CURRENT_QUERY);
	    } else if ((*prev_target_buffer && QueryTotal == 2) ||
		       (!(*prev_target_buffer) && QueryTotal == 1)) {
		_statusline(EDIT_THE_PREV_QUERY);
	    } else {
		_statusline(EDIT_A_PREV_QUERY);
	    }
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
		 * User canceled the search via ^G.  Restore prev_target and
		 * return.  - FM
		 */
		LYstrncpy(prev_target, prev_target_buffer, target_size);
		HTInfoMsg(CANCELLED);
		return (FALSE);
	    }
	    goto check_recall;
	}
    } else if (recall && ch == DNARROW) {
	if (FirstRecall) {
	    /*
	     * Use the current string or first query in the list.  - FM
	     */
	    FirstRecall = FALSE;
	    if (*prev_target_buffer) {
		for (QueryNum = 0; QueryNum < (QueryTotal - 1); QueryNum++) {
		    if ((cp = (char *) HTList_objectAt(search_queries,
						       QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
		    }
		}
	    } else {
		QueryNum = QueryTotal - 1;
	    }
	} else {
	    /*
	     * Advance to the next query in the list.  - FM
	     */
	    QueryNum--;
	}
	if (QueryNum < 0)
	    /*
	     * Roll around to the first query in the list.  - FM
	     */
	    QueryNum = QueryTotal - 1;
	if ((cp = (char *) HTList_objectAt(search_queries,
					   QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
	    if (*prev_target_buffer &&
		!strcmp(prev_target_buffer, prev_target)) {
		_statusline(EDIT_CURRENT_QUERY);
	    } else if ((*prev_target_buffer && QueryTotal == 2) ||
		       (!(*prev_target_buffer) && QueryTotal == 1)) {
		_statusline(EDIT_THE_PREV_QUERY);
	    } else {
		_statusline(EDIT_A_PREV_QUERY);
	    }
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
		 * User cancelled the search via ^G.  Restore prev_target and
		 * return.  - FM
		 */
		LYstrncpy(prev_target, prev_target_buffer, target_size);
		HTInfoMsg(CANCELLED);
		return (FALSE);
	    }
	    goto check_recall;
	}
    }
    /*
     * Replace the search string buffer with the new target.  - FM
     */
    LYstrncpy(prev_target_buffer, prev_target, sizeof(prev_target_buffer) - 1);
    HTAddSearchQuery(prev_target_buffer);

    if (direction < 0) {
	offset = 0;
	if (check_prev_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     * Found in link, changed cur, we're done.
	     */
	    LYhighlight(OFF, oldcur, prev_target);
	    return (TRUE);
	}
    } else {

	/*
	 * Search the links on the currently displayed page for the string,
	 * starting after the current link.  - FM
	 */
	if (check_next_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     * Found in link, changed cur, we're done.
	     */
	    LYhighlight(OFF, oldcur, prev_target);
	    return (TRUE);
	}

	/*
	 * We'll search the text starting from the link we are on, or the next
	 * page.
	 */
	if (nlinks == 0)
	    offset = (display_lines - 1);
	else
	    offset = links[cur_doc->link].ly - 1;
    }

    /*
     * Resume search, this time for all text.  Set www_search_result if string
     * found, and position the hit near top of screen.
     */
    www_user_search((cur_doc->line + offset), cur_doc, prev_target, direction);
    if (cur_doc->link != oldcur) {
	LYhighlight(OFF, oldcur, prev_target);
	return (TRUE);
    }
    return (BOOL) (www_search_result > 0);
}
@


1.5
log
@automatic merge of lynx-current
@
text
@d16 2
a17 1
    char *stars = NULL, *cp;
d25 1
a25 1
	char *text = LYGetHiliteStr(cur, count);
d48 1
a48 2
	    for (cp = stars; *cp != '\0'; cp++)
		*cp = '*';
d161 2
a162 1
    int ch = 0, recall;
@


1.4
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d11 2
a12 3
static BOOL link_has_target (
	int		cur,
	char *		target)
d23 1
a23 1
    for (count = 0; ; ++count) {
d25 1
d33 2
a34 2
     *  Search the relevant form fields, taking the
     *  case_sensitive setting into account. - FM
d40 2
a41 2
	     *  Check the actual, hidden password, and then
	     *  the displayed string. - FM
d56 2
a57 2
	     *  Search the option strings that are displayed
	     *  when the popup is invoked. - FM
d68 1
a68 1
	     *  Search for checked or unchecked parens. - FM
d80 1
a80 1
	     *  Search for checked or unchecked square brackets. - FM
d92 3
a94 4
	     *  Check the values intended for display.
	     *  May have been found already via the
	     *  hightext search, but make sure here
	     *  that the entire value is searched. - FM
d105 4
a108 5
 *  Search for the target string inside of the links
 *  that are currently displayed on the screen beginning
 *  with the one after the currently selected one.
 *  If found set cur to the new value and return TRUE.
 *  If not found do not reset cur and return FALSE.
d111 2
a112 3
static int check_next_target_in_links (
	int *		cur,
	char *		target)
d127 2
a128 3
static int check_prev_target_in_links (
	int *		cur,
	char *		target)
d144 4
a147 4
 *  Textsearch checks the prev_target variable to see if it is empty.
 *  If it is then it requests a new search string.  It then searches
 *  the current file for the next instance of the search string and
 *  finds the line number that the string is on
d149 2
a150 3
 *  This is the primary USER search engine and is case sensitive
 *  or case insensitive depending on the 'case_sensitive' global
 *  variable
d152 3
a154 5
BOOL textsearch (
	DocInfo *	cur_doc,
	char *		prev_target,
	int		target_size,
	int		direction)
d158 1
a158 1
    static char prev_target_buffer[512]; /* Search string buffer */
d167 1
a167 1
     *  Initialize the search string buffer. - FM
d180 2
a181 2
	 *  LYK_NEXT or LYK_PREV was pressed, so copy the
	 *  buffer into prev_target.
d185 1
a185 1
    if (strlen(prev_target) == 0 ) {
d187 3
a189 4
	 *  This is a new WHEREIS search ('/'), or
	 *  LYK_NEXT was pressed but there was no
	 *  previous search, so we need to get a
	 *  search string from the user. - FM
d195 2
a196 2
	     *  User cancelled the search via ^G.
	     *  Restore prev_target and return. - FM
d200 1
a200 1
	    return(FALSE);
d204 1
a204 1
check_recall:
d208 4
a211 4
	 *  No entry.  Simply return, retaining the current buffer.
	 *  Because prev_target is now reset, highlighting of the
	 *  previous search string will no longer occur, but it can
	 *  be used again via LYK_NEXT or LYK_PREV.
d214 1
a214 1
	return(FALSE);
d220 1
a220 1
	     *  Use the current string or last query in the list. - FM
d225 2
a226 2
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL &&
d230 2
a231 2
		 }
	     } else {
d233 1
a233 1
	     }
d236 1
a236 1
	     *  Go back to the previous query in the list. - FM
d242 1
a242 1
	     *  Roll around to the last query in the list. - FM
d245 2
a246 2
	if ((cp = (char *)HTList_objectAt(search_queries,
					  QueryNum)) != NULL) {
d259 2
a260 2
		 *  User canceled the search via ^G.
		 *  Restore prev_target and return. - FM
d264 1
a264 1
		return(FALSE);
d271 1
a271 1
	     *  Use the current string or first query in the list. - FM
d276 2
a277 2
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL &&
d287 1
a287 1
	     *  Advance to the next query in the list. - FM
d293 1
a293 1
	     *  Roll around to the first query in the list. - FM
d296 2
a297 2
	if ((cp = (char *)HTList_objectAt(search_queries,
					  QueryNum)) != NULL) {
d310 2
a311 2
		 *  User cancelled the search via ^G.
		 *  Restore prev_target and return. - FM
d315 1
a315 1
		return(FALSE);
d321 1
a321 1
     *  Replace the search string buffer with the new target. - FM
d323 1
a323 1
    LYstrncpy(prev_target_buffer, prev_target, sizeof(prev_target_buffer)-1);
d330 1
a330 1
	     *  Found in link, changed cur, we're done.
d333 1
a333 1
	    return(TRUE);
d338 2
a339 2
	 *  Search the links on the currently displayed page for
	 *  the string, starting after the current link. - FM
d343 1
a343 1
	     *  Found in link, changed cur, we're done.
d346 1
a346 1
	    return(TRUE);
d350 2
a351 2
	 *  We'll search the text starting from the
	 *  link we are on, or the next page.
d360 2
a361 3
     *  Resume search, this time for all text.
     *  Set www_search_result if string found,
     *  and position the hit near top of screen.
d366 1
a366 1
	return(TRUE);
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d11 3
a13 3
PRIVATE BOOL link_has_target ARGS2(
	int,		cur,
	char *,		target)
d113 3
a115 3
PRIVATE int check_next_target_in_links ARGS2(
	int *,		cur,
	char *,		target)
d130 3
a132 3
PRIVATE int check_prev_target_in_links ARGS2(
	int *,		cur,
	char *,		target)
d157 5
a161 5
PUBLIC BOOL textsearch ARGS4(
	DocInfo *,	cur_doc,
	char *,		prev_target,
	int,		target_size,
	int,		direction)
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@d11 94
d113 1
a113 1
PRIVATE int check_for_target_in_links ARGS2(
d115 1
a115 1
	char *,		new_target)
d117 1
a117 3
    int i = *cur + 1;
    OptionType *option;
    char *stars = NULL, *cp;
d119 10
a128 2
    if (nlinks == 0)
	return(FALSE);
d130 5
a134 17
    for (; i < nlinks; i++) {
        /*
	 *  Search the hightext string, and hightext2 if present,
	 *  taking the case_sensitive setting into account. - FM
	 */
	if (((links[i].hightext != NULL && case_sensitive == TRUE) &&
	     LYno_attr_char_strstr(links[i].hightext, new_target)) ||
	    ((links[i].hightext != NULL && case_sensitive == FALSE) &&
	     LYno_attr_char_case_strstr(links[i].hightext, new_target))) {
	    break;
	}
	if (((links[i].hightext2 != NULL && case_sensitive == TRUE) &&
	     LYno_attr_char_strstr(links[i].hightext2, new_target)) ||
	    ((links[i].hightext2 != NULL && case_sensitive == FALSE) &&
	     LYno_attr_char_case_strstr(links[i].hightext2, new_target))) {
	    break;
	}
d136 5
a140 96
	/*
	 *  Search the relevant form fields, taking the
	 *  case_sensitive setting into account. - FM
	 */
	if ((links[i].form != NULL && links[i].form->value != NULL) &&
	    links[i].form->type != F_HIDDEN_TYPE) {
	    if (links[i].form->type == F_PASSWORD_TYPE) {
	        /*
		 *  Check the actual, hidden password, and then
		 *  the displayed string. - FM
		 */
		if (((case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(links[i].form->value,
					   new_target)) ||
		    ((case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(links[i].form->value,
						new_target))) {
		    break;
		}
		StrAllocCopy(stars, links[i].form->value);
		for (cp = stars; *cp != '\0'; cp++)
		    *cp = '*';
		if (((case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(stars, new_target)) ||
		    ((case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(stars, new_target))) {
		    FREE(stars);
		    break;
		}
		FREE(stars);
	    } else if (links[i].form->type == F_OPTION_LIST_TYPE) {
		/*
		 *  Search the option strings that are displayed
		 *  when the popup is invoked. - FM
		 */
		option = links[i].form->select_list;
		while (option != NULL) {
		    if (((option->name != NULL &&
			  case_sensitive == TRUE) &&
			 LYno_attr_char_strstr(option->name, new_target)) ||
			((option->name != NULL &&
			  case_sensitive == FALSE) &&
			 LYno_attr_char_case_strstr(option->name,
						    new_target))) {
			break;
		    }
		    option = option->next;
		}
		if (option != NULL) {
		    break;
		}
	    } else if (links[i].form->type == F_RADIO_TYPE) {
		/*
		 *  Search for checked or unchecked parens. - FM
		 */
	        if (links[i].form->num_value) {
		    cp = checked_radio;
		} else {
		    cp = unchecked_radio;
		}
		if (((case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(cp, new_target)) ||
		    ((case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(cp, new_target))) {
		    break;
		}
	    } else if (links[i].form->type == F_CHECKBOX_TYPE) {
		/*
		 *  Search for checked or unchecked square brackets. - FM
		 */
	        if (links[i].form->num_value) {
		    cp = checked_box;
		} else {
		    cp = unchecked_box;
		}
		if (((case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(cp, new_target)) ||
		    ((case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(cp, new_target))) {
		    break;
		}
	    } else {
	        /*
		 *  Check the values intended for display.
		 *  May have been found already via the
		 *  hightext search, but make sure here
		 *  that the entire value is searched. - FM
		 */
		if (((case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(links[i].form->value,
					   new_target)) ||
		    ((case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(links[i].form->value,
						new_target))) {
		    break;
		}
d144 1
a144 6

    if (i == nlinks)
	return(FALSE);
 
    *cur = i;
    return(TRUE);
d149 1
a149 1
 *  If it is then it requests a new search string.  It then searches 
d152 1
a152 1
 * 
a155 1
 *
d157 2
a158 3
		
PUBLIC BOOL textsearch ARGS3(
	document *,	cur_doc,
d160 2
a161 1
	BOOL,		next)
d182 1
a182 1
    recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
d185 4
a188 4
    if (next)
        /*
	 *  LYK_NEXT was pressed, so copy the
	 *  buffer into prev_target. - FM
d190 1
a190 1
	strcpy(prev_target, prev_target_buffer);
d193 1
a193 1
        /*
d201 1
a201 2
	if ((ch = LYgetstr(prev_target, VISIBLE,
	    		   sizeof(prev_target_buffer), recall)) < 0) {
d206 1
a206 1
	    strcpy(prev_target, prev_target_buffer);
d214 2
a215 2
        !(recall && (ch == UPARROW || ch == DNARROW))) {
        /*
d219 1
a219 1
	 *  be used again via LYK_NEXT.   - FM
d221 1
a221 1
        HTInfoMsg(CANCELLED);
d232 1
a232 1
	        for (QueryNum = (QueryTotal - 1); QueryNum > 0; QueryNum--) {
d234 3
a236 3
	    					      QueryNum)) != NULL &&
		        !strcmp(prev_target_buffer, cp)) {
		        break;
d254 2
a255 2
	    				  QueryNum)) != NULL) {
	    strcpy(prev_target, cp);
d257 1
a257 1
	        !strcmp(prev_target_buffer, prev_target)) {
d265 3
a267 4
	    if ((ch = LYgetstr(prev_target, VISIBLE,
	    		       sizeof(prev_target_buffer), recall)) < 0) {
	        /*
		 *  User cancelled the search via ^G.
d270 1
a270 1
		strcpy(prev_target, prev_target_buffer);
d283 1
a283 1
	        for (QueryNum = 0; QueryNum < (QueryTotal - 1); QueryNum++) {
d285 3
a287 3
	    					      QueryNum)) != NULL &&
		        !strcmp(prev_target_buffer, cp)) {
		        break;
d305 2
a306 2
	    				  QueryNum)) != NULL) {
	    strcpy(prev_target, cp);
d308 1
a308 1
	        !strcmp(prev_target_buffer, prev_target)) {
d316 2
a317 3
	    if ((ch = LYgetstr(prev_target, VISIBLE,
			       sizeof(prev_target_buffer), recall)) < 0) {
	        /*
d321 1
a321 1
		strcpy(prev_target, prev_target_buffer);
d331 1
a331 1
    strcpy(prev_target_buffer, prev_target);
d334 23
a356 5
    /*
     *  Search the links on the currently displayed page for
     *  the string, starting after the current link. - FM
     */
    if (check_for_target_in_links(&cur_doc->link, prev_target)) {
d358 2
a359 1
	 *  Found in link, changed cur, we're done.
d361 4
a364 2
	highlight(OFF, oldcur, prev_target);
	return(TRUE); 
a365 9
	
    /*
     *  We'll search the text starting from the
     *  link we are on, or the next page.
     */
    if (nlinks == 0)
	offset = (display_lines - 1);
    else
	offset = links[cur_doc->link].ly - 1;
d372 1
a372 1
    www_user_search((cur_doc->line + offset), cur_doc, prev_target);
d374 1
a374 1
	highlight(OFF, oldcur, prev_target);
d377 1
a377 1
    return(www_search_result > 0);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d11 11
a21 2
static BOOL link_has_target(int cur,
			    char *target)
d23 1
a23 1
    LinkInfo *a = &links[cur];
d25 1
a25 3
    char *stars = NULL;
    const char *cp;
    int count;
d27 2
a28 6
    /*
     * Search the hightext strings, if present, taking the case_sensitive
     * setting into account.
     */
    for (count = 0;; ++count) {
	const char *text = LYGetHiliteStr(cur, count);
d30 9
a38 1
	if (text == NULL)
d40 7
a46 3
	if (LYno_attr_strstr(text, target))
	    return TRUE;
    }
d48 29
a76 17
    /*
     * Search the relevant form fields, taking the case_sensitive setting into
     * account.  - FM
     */
    if ((a->l_form != NULL && a->l_form->value != NULL) &&
	a->l_form->type != F_HIDDEN_TYPE) {
	if (a->l_form->type == F_PASSWORD_TYPE) {
	    /*
	     * Check the actual, hidden password, and then the displayed
	     * string.  - FM
	     */
	    if (LYno_attr_strstr(a->l_form->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->l_form->value);
	    memset(stars, '*', strlen(stars));
	    if (LYno_attr_strstr(stars, target)) {
d78 50
a127 12
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->l_form->type == F_OPTION_LIST_TYPE) {
	    /*
	     * Search the option strings that are displayed when the popup is
	     * invoked.  - FM
	     */
	    option = a->l_form->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
a128 8
		option = option->next;
	    }
	} else if (a->l_form->type == F_RADIO_TYPE) {
	    /*
	     * Search for checked or unchecked parens.  - FM
	     */
	    if (a->l_form->num_value) {
		cp = checked_radio;
d130 14
a143 25
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->l_form->type == F_CHECKBOX_TYPE) {
	    /*
	     * Search for checked or unchecked square brackets.  - FM
	     */
	    if (a->l_form->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     * Check the values intended for display.  May have been found
	     * already via the hightext search, but make sure here that the
	     * entire value is searched.  - FM
	     */
	    if (LYno_attr_strstr(a->l_form->value, target)) {
		return TRUE;
a146 2
    return FALSE;
}
d148 5
a152 37
/*
 * Search for the target string inside of the links that are currently
 * displayed on the screen beginning with the one after the currently selected
 * one.  If found set cur to the new value and return TRUE.  If not found do
 * not reset cur and return FALSE.
 */

static int check_next_target_in_links(int *cur,
				      char *target)
{
    int i;

    if (nlinks != 0) {
	for (i = *cur + 1; i < nlinks; ++i) {
	    if (link_has_target(i, target)) {
		*cur = i;
		return TRUE;
	    }
	}
    }
    return FALSE;
}

static int check_prev_target_in_links(int *cur,
				      char *target)
{
    int i;

    if (nlinks != 0) {
	for (i = *cur - 1; i >= 0; --i) {
	    if (link_has_target(i, target)) {
		*cur = i;
		return TRUE;
	    }
	}
    }
    return FALSE;
d156 8
a163 4
 * Textsearch checks the prev_target variable to see if it is empty.  If it is
 * then it requests a new search string.  It then searches the current file for
 * the next instance of the search string and finds the line number that the
 * string is on
a164 2
 * This is the primary USER search engine and is case sensitive or case
 * insensitive depending on the 'case_sensitive' global variable
d166 5
a170 3
BOOL textsearch(DocInfo *cur_doc, char *prev_target,
		int target_size,
		int direction)
d174 1
a174 1
    static char prev_target_buffer[512];	/* Search string buffer */
d177 1
a177 2
    int ch = 0;
    RecallType recall;
d183 1
a183 1
     * Initialize the search string buffer.  - FM
d191 1
a191 1
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
d194 4
a197 4
    if (direction != 0)
	/*
	 * LYK_NEXT or LYK_PREV was pressed, so copy the buffer into
	 * prev_target.
d199 1
a199 1
	LYstrncpy(prev_target, prev_target_buffer, target_size);
d201 6
a206 5
    if (strlen(prev_target) == 0) {
	/*
	 * This is a new WHEREIS search ('/'), or LYK_NEXT was pressed but
	 * there was no previous search, so we need to get a search string from
	 * the user.  - FM
d210 2
a211 1
	if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
d213 2
a214 2
	     * User cancelled the search via ^G.  Restore prev_target and
	     * return.  - FM
d216 1
a216 1
	    LYstrncpy(prev_target, prev_target_buffer, target_size);
d218 1
a218 1
	    return (FALSE);
d222 1
a222 1
  check_recall:
d224 6
a229 6
	!(recall && (ch == UPARROW || ch == DNARROW))) {
	/*
	 * No entry.  Simply return, retaining the current buffer.  Because
	 * prev_target is now reset, highlighting of the previous search string
	 * will no longer occur, but it can be used again via LYK_NEXT or
	 * LYK_PREV.
d231 2
a232 2
	HTInfoMsg(CANCELLED);
	return (FALSE);
d238 1
a238 1
	     * Use the current string or last query in the list.  - FM
d242 5
a246 5
		for (QueryNum = (QueryTotal - 1); QueryNum > 0; QueryNum--) {
		    if ((cp = (char *) HTList_objectAt(search_queries,
						       QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
d248 2
a249 2
		}
	    } else {
d251 1
a251 1
	    }
d254 1
a254 1
	     * Go back to the previous query in the list.  - FM
d260 1
a260 1
	     * Roll around to the last query in the list.  - FM
d263 3
a265 3
	if ((cp = (char *) HTList_objectAt(search_queries,
					   QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
d267 1
a267 1
		!strcmp(prev_target_buffer, prev_target)) {
d275 5
a279 4
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
		 * User canceled the search via ^G.  Restore prev_target and
		 * return.  - FM
d281 1
a281 1
		LYstrncpy(prev_target, prev_target_buffer, target_size);
d283 1
a283 1
		return (FALSE);
d290 1
a290 1
	     * Use the current string or first query in the list.  - FM
d294 5
a298 5
		for (QueryNum = 0; QueryNum < (QueryTotal - 1); QueryNum++) {
		    if ((cp = (char *) HTList_objectAt(search_queries,
						       QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
d306 1
a306 1
	     * Advance to the next query in the list.  - FM
d312 1
a312 1
	     * Roll around to the first query in the list.  - FM
d315 3
a317 3
	if ((cp = (char *) HTList_objectAt(search_queries,
					   QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
d319 1
a319 1
		!strcmp(prev_target_buffer, prev_target)) {
d327 5
a331 4
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
		 * User cancelled the search via ^G.  Restore prev_target and
		 * return.  - FM
d333 1
a333 1
		LYstrncpy(prev_target, prev_target_buffer, target_size);
d335 1
a335 1
		return (FALSE);
d341 1
a341 1
     * Replace the search string buffer with the new target.  - FM
d343 1
a343 1
    LYstrncpy(prev_target_buffer, prev_target, sizeof(prev_target_buffer) - 1);
d346 5
a350 11
    if (direction < 0) {
	offset = 0;
	if (check_prev_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     * Found in link, changed cur, we're done.
	     */
	    LYhighlight(OFF, oldcur, prev_target);
	    return (TRUE);
	}
    } else {

d352 1
a352 2
	 * Search the links on the currently displayed page for the string,
	 * starting after the current link.  - FM
d354 2
a355 16
	if (check_next_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     * Found in link, changed cur, we're done.
	     */
	    LYhighlight(OFF, oldcur, prev_target);
	    return (TRUE);
	}

	/*
	 * We'll search the text starting from the link we are on, or the next
	 * page.
	 */
	if (nlinks == 0)
	    offset = (display_lines - 1);
	else
	    offset = links[cur_doc->link].ly - 1;
d357 9
d368 3
a370 2
     * Resume search, this time for all text.  Set www_search_result if string
     * found, and position the hit near top of screen.
d372 1
a372 1
    www_user_search((cur_doc->line + offset), cur_doc, prev_target, direction);
d374 2
a375 2
	LYhighlight(OFF, oldcur, prev_target);
	return (TRUE);
d377 1
a377 1
    return (BOOL) (www_search_result > 0);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@a10 94
PRIVATE BOOL link_has_target ARGS2(
	int,		cur,
	char *,		target)
{
    LinkInfo *a = &links[cur];
    OptionType *option;
    char *stars = NULL, *cp;
    int count;

    /*
     * Search the hightext strings, if present, taking the case_sensitive
     * setting into account.
     */
    for (count = 0; ; ++count) {
	char *text = LYGetHiliteStr(cur, count);
	if (text == NULL)
	    break;
	if (LYno_attr_strstr(text, target))
	    return TRUE;
    }

    /*
     *  Search the relevant form fields, taking the
     *  case_sensitive setting into account. - FM
     */
    if ((a->l_form != NULL && a->l_form->value != NULL) &&
	a->l_form->type != F_HIDDEN_TYPE) {
	if (a->l_form->type == F_PASSWORD_TYPE) {
	    /*
	     *  Check the actual, hidden password, and then
	     *  the displayed string. - FM
	     */
	    if (LYno_attr_strstr(a->l_form->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->l_form->value);
	    for (cp = stars; *cp != '\0'; cp++)
		*cp = '*';
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->l_form->type == F_OPTION_LIST_TYPE) {
	    /*
	     *  Search the option strings that are displayed
	     *  when the popup is invoked. - FM
	     */
	    option = a->l_form->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->l_form->type == F_RADIO_TYPE) {
	    /*
	     *  Search for checked or unchecked parens. - FM
	     */
	    if (a->l_form->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->l_form->type == F_CHECKBOX_TYPE) {
	    /*
	     *  Search for checked or unchecked square brackets. - FM
	     */
	    if (a->l_form->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     *  Check the values intended for display.
	     *  May have been found already via the
	     *  hightext search, but make sure here
	     *  that the entire value is searched. - FM
	     */
	    if (LYno_attr_strstr(a->l_form->value, target)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

d19 1
a19 1
PRIVATE int check_next_target_in_links ARGS2(
d21 1
a21 1
	char *,		target)
d23 6
a28 1
    int i;
d30 16
a45 6
    if (nlinks != 0) {
	for (i = *cur + 1; i < nlinks; ++i) {
	    if (link_has_target(i, target)) {
		*cur = i;
		return TRUE;
	    }
a46 3
    }
    return FALSE;
}
d48 96
a143 11
PRIVATE int check_prev_target_in_links ARGS2(
	int *,		cur,
	char *,		target)
{
    int i;

    if (nlinks != 0) {
	for (i = *cur - 1; i >= 0; --i) {
	    if (link_has_target(i, target)) {
		*cur = i;
		return TRUE;
d147 6
a152 1
    return FALSE;
d157 1
a157 1
 *  If it is then it requests a new search string.  It then searches
d160 1
a160 1
 *
d164 1
d166 3
a168 2
PUBLIC BOOL textsearch ARGS4(
	DocInfo *,	cur_doc,
d170 1
a170 2
	int,		target_size,
	int,		direction)
d191 1
a191 1
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
d194 4
a197 4
    if (direction != 0)
	/*
	 *  LYK_NEXT or LYK_PREV was pressed, so copy the
	 *  buffer into prev_target.
d199 1
a199 1
	LYstrncpy(prev_target, prev_target_buffer, target_size);
d202 1
a202 1
	/*
d210 2
a211 1
	if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
d216 1
a216 1
	    LYstrncpy(prev_target, prev_target_buffer, target_size);
d224 2
a225 2
	!(recall && (ch == UPARROW || ch == DNARROW))) {
	/*
d229 1
a229 1
	 *  be used again via LYK_NEXT or LYK_PREV.
d231 1
a231 1
	HTInfoMsg(CANCELLED);
d242 1
a242 1
		for (QueryNum = (QueryTotal - 1); QueryNum > 0; QueryNum--) {
d244 3
a246 3
						      QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
d264 2
a265 2
					  QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
d267 1
a267 1
		!strcmp(prev_target_buffer, prev_target)) {
d275 4
a278 3
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
		 *  User canceled the search via ^G.
d281 1
a281 1
		LYstrncpy(prev_target, prev_target_buffer, target_size);
d294 1
a294 1
		for (QueryNum = 0; QueryNum < (QueryTotal - 1); QueryNum++) {
d296 3
a298 3
						      QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
d316 2
a317 2
					  QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
d319 1
a319 1
		!strcmp(prev_target_buffer, prev_target)) {
d327 3
a329 2
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
d333 1
a333 1
		LYstrncpy(prev_target, prev_target_buffer, target_size);
d343 1
a343 1
    LYstrncpy(prev_target_buffer, prev_target, sizeof(prev_target_buffer)-1);
d346 5
a350 23
    if (direction < 0) {
	offset = 0;
	if (check_prev_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     *  Found in link, changed cur, we're done.
	     */
	    LYhighlight(OFF, oldcur, prev_target);
	    return(TRUE);
	}
    } else {

	/*
	 *  Search the links on the currently displayed page for
	 *  the string, starting after the current link. - FM
	 */
	if (check_next_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     *  Found in link, changed cur, we're done.
	     */
	    LYhighlight(OFF, oldcur, prev_target);
	    return(TRUE);
	}

d352 1
a352 2
	 *  We'll search the text starting from the
	 *  link we are on, or the next page.
d354 2
a355 4
	if (nlinks == 0)
	    offset = (display_lines - 1);
	else
	    offset = links[cur_doc->link].ly - 1;
d357 9
d372 1
a372 1
    www_user_search((cur_doc->line + offset), cur_doc, prev_target, direction);
d374 1
a374 1
	LYhighlight(OFF, oldcur, prev_target);
d377 1
a377 1
    return (BOOL) (www_search_result > 0);
@


1.1.3.2
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d11 3
a13 3
static BOOL link_has_target (
	int		cur,
	char *		target)
d113 3
a115 3
static int check_next_target_in_links (
	int *		cur,
	char *		target)
d130 3
a132 3
static int check_prev_target_in_links (
	int *		cur,
	char *		target)
d157 5
a161 5
BOOL textsearch (
	DocInfo *	cur_doc,
	char *		prev_target,
	int		target_size,
	int		direction)
@


1.1.3.3
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d11 3
a13 2
static BOOL link_has_target(int cur,
			    char *target)
d24 1
a24 1
    for (count = 0;; ++count) {
a25 1

d33 2
a34 2
     * Search the relevant form fields, taking the case_sensitive setting into
     * account.  - FM
d40 2
a41 2
	     * Check the actual, hidden password, and then the displayed
	     * string.  - FM
d56 2
a57 2
	     * Search the option strings that are displayed when the popup is
	     * invoked.  - FM
d68 1
a68 1
	     * Search for checked or unchecked parens.  - FM
d80 1
a80 1
	     * Search for checked or unchecked square brackets.  - FM
d92 4
a95 3
	     * Check the values intended for display.  May have been found
	     * already via the hightext search, but make sure here that the
	     * entire value is searched.  - FM
d106 5
a110 4
 * Search for the target string inside of the links that are currently
 * displayed on the screen beginning with the one after the currently selected
 * one.  If found set cur to the new value and return TRUE.  If not found do
 * not reset cur and return FALSE.
d113 3
a115 2
static int check_next_target_in_links(int *cur,
				      char *target)
d130 3
a132 2
static int check_prev_target_in_links(int *cur,
				      char *target)
d148 4
a151 4
 * Textsearch checks the prev_target variable to see if it is empty.  If it is
 * then it requests a new search string.  It then searches the current file for
 * the next instance of the search string and finds the line number that the
 * string is on
d153 3
a155 2
 * This is the primary USER search engine and is case sensitive or case
 * insensitive depending on the 'case_sensitive' global variable
d157 5
a161 3
BOOL textsearch(DocInfo *cur_doc, char *prev_target,
		int target_size,
		int direction)
d165 1
a165 1
    static char prev_target_buffer[512];	/* Search string buffer */
d174 1
a174 1
     * Initialize the search string buffer.  - FM
d187 2
a188 2
	 * LYK_NEXT or LYK_PREV was pressed, so copy the buffer into
	 * prev_target.
d192 1
a192 1
    if (strlen(prev_target) == 0) {
d194 4
a197 3
	 * This is a new WHEREIS search ('/'), or LYK_NEXT was pressed but
	 * there was no previous search, so we need to get a search string from
	 * the user.  - FM
d203 2
a204 2
	     * User cancelled the search via ^G.  Restore prev_target and
	     * return.  - FM
d208 1
a208 1
	    return (FALSE);
d212 1
a212 1
  check_recall:
d216 4
a219 4
	 * No entry.  Simply return, retaining the current buffer.  Because
	 * prev_target is now reset, highlighting of the previous search string
	 * will no longer occur, but it can be used again via LYK_NEXT or
	 * LYK_PREV.
d222 1
a222 1
	return (FALSE);
d228 1
a228 1
	     * Use the current string or last query in the list.  - FM
d233 2
a234 2
		    if ((cp = (char *) HTList_objectAt(search_queries,
						       QueryNum)) != NULL &&
d238 2
a239 2
		}
	    } else {
d241 1
a241 1
	    }
d244 1
a244 1
	     * Go back to the previous query in the list.  - FM
d250 1
a250 1
	     * Roll around to the last query in the list.  - FM
d253 2
a254 2
	if ((cp = (char *) HTList_objectAt(search_queries,
					   QueryNum)) != NULL) {
d267 2
a268 2
		 * User canceled the search via ^G.  Restore prev_target and
		 * return.  - FM
d272 1
a272 1
		return (FALSE);
d279 1
a279 1
	     * Use the current string or first query in the list.  - FM
d284 2
a285 2
		    if ((cp = (char *) HTList_objectAt(search_queries,
						       QueryNum)) != NULL &&
d295 1
a295 1
	     * Advance to the next query in the list.  - FM
d301 1
a301 1
	     * Roll around to the first query in the list.  - FM
d304 2
a305 2
	if ((cp = (char *) HTList_objectAt(search_queries,
					   QueryNum)) != NULL) {
d318 2
a319 2
		 * User cancelled the search via ^G.  Restore prev_target and
		 * return.  - FM
d323 1
a323 1
		return (FALSE);
d329 1
a329 1
     * Replace the search string buffer with the new target.  - FM
d331 1
a331 1
    LYstrncpy(prev_target_buffer, prev_target, sizeof(prev_target_buffer) - 1);
d338 1
a338 1
	     * Found in link, changed cur, we're done.
d341 1
a341 1
	    return (TRUE);
d346 2
a347 2
	 * Search the links on the currently displayed page for the string,
	 * starting after the current link.  - FM
d351 1
a351 1
	     * Found in link, changed cur, we're done.
d354 1
a354 1
	    return (TRUE);
d358 2
a359 2
	 * We'll search the text starting from the link we are on, or the next
	 * page.
d368 3
a370 2
     * Resume search, this time for all text.  Set www_search_result if string
     * found, and position the hit near top of screen.
d375 1
a375 1
	return (TRUE);
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@a10 89
PRIVATE BOOL link_has_target ARGS2(
	linkstruct *,	a,
	char *,		target)
{
    OptionType *option;
    char *stars = NULL, *cp;

    /*
     *  Search the hightext string, and hightext2 if present,
     *  taking the case_sensitive setting into account. - FM
     */
    if (LYno_attr_strstr(a->hightext, target)
     || LYno_attr_strstr(a->hightext2, target)) {
	return TRUE;
    }

    /*
     *  Search the relevant form fields, taking the
     *  case_sensitive setting into account. - FM
     */
    if ((a->form != NULL && a->form->value != NULL) &&
	a->form->type != F_HIDDEN_TYPE) {
	if (a->form->type == F_PASSWORD_TYPE) {
	    /*
	     *  Check the actual, hidden password, and then
	     *  the displayed string. - FM
	     */
	    if (LYno_attr_strstr(a->form->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->form->value);
	    for (cp = stars; *cp != '\0'; cp++)
		*cp = '*';
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->form->type == F_OPTION_LIST_TYPE) {
	    /*
	     *  Search the option strings that are displayed
	     *  when the popup is invoked. - FM
	     */
	    option = a->form->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->form->type == F_RADIO_TYPE) {
	    /*
	     *  Search for checked or unchecked parens. - FM
	     */
	    if (a->form->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->form->type == F_CHECKBOX_TYPE) {
	    /*
	     *  Search for checked or unchecked square brackets. - FM
	     */
	    if (a->form->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     *  Check the values intended for display.
	     *  May have been found already via the
	     *  hightext search, but make sure here
	     *  that the entire value is searched. - FM
	     */
	    if (LYno_attr_strstr(a->form->value, target)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

d19 1
a19 1
PRIVATE int check_next_target_in_links ARGS2(
d21 1
a21 1
	char *,		target)
d23 6
a28 1
    int i;
d30 16
a45 6
    if (nlinks != 0) {
	for (i = *cur + 1; i < nlinks; ++i) {
	    if (link_has_target(&links[i], target)) {
		*cur = i;
		return TRUE;
	    }
a46 3
    }
    return FALSE;
}
d48 96
a143 11
PRIVATE int check_prev_target_in_links ARGS2(
	int *,		cur,
	char *,		target)
{
    int i;

    if (nlinks != 0) {
	for (i = *cur - 1; i >= 0; --i) {
	    if (link_has_target(&links[i], target)) {
		*cur = i;
		return TRUE;
d147 6
a152 1
    return FALSE;
d157 1
a157 1
 *  If it is then it requests a new search string.  It then searches
d160 1
a160 1
 *
d164 1
d166 2
a167 1
PUBLIC BOOL textsearch ARGS4(
d170 1
a170 2
	int,		target_size,
	int,		direction)
d191 1
a191 1
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
d194 4
a197 4
    if (direction != 0)
	/*
	 *  LYK_NEXT or LYK_PREV was pressed, so copy the
	 *  buffer into prev_target.
d199 1
a199 1
	LYstrncpy(prev_target, prev_target_buffer, target_size);
d202 1
a202 1
	/*
d210 2
a211 1
	if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
d216 1
a216 1
	    LYstrncpy(prev_target, prev_target_buffer, target_size);
d224 2
a225 2
	!(recall && (ch == UPARROW || ch == DNARROW))) {
	/*
d229 1
a229 1
	 *  be used again via LYK_NEXT or LYK_PREV.
d231 1
a231 1
	HTInfoMsg(CANCELLED);
d242 1
a242 1
		for (QueryNum = (QueryTotal - 1); QueryNum > 0; QueryNum--) {
d244 3
a246 3
						      QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
d264 2
a265 2
					  QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
d267 1
a267 1
		!strcmp(prev_target_buffer, prev_target)) {
d275 4
a278 3
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
		 *  User canceled the search via ^G.
d281 1
a281 1
		LYstrncpy(prev_target, prev_target_buffer, target_size);
d294 1
a294 1
		for (QueryNum = 0; QueryNum < (QueryTotal - 1); QueryNum++) {
d296 3
a298 3
						      QueryNum)) != NULL &&
			!strcmp(prev_target_buffer, cp)) {
			break;
d316 2
a317 2
					  QueryNum)) != NULL) {
	    LYstrncpy(prev_target, cp, target_size);
d319 1
a319 1
		!strcmp(prev_target_buffer, prev_target)) {
d327 3
a329 2
	    if ((ch = LYgetstr(prev_target, VISIBLE, target_size, recall)) < 0) {
		/*
d333 1
a333 1
		LYstrncpy(prev_target, prev_target_buffer, target_size);
d343 1
a343 1
    LYstrncpy(prev_target_buffer, prev_target, sizeof(prev_target_buffer)-1);
d346 5
a350 11
    if (direction < 0) {
	offset = 0;
	if (check_prev_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     *  Found in link, changed cur, we're done.
	     */
	    highlight(OFF, oldcur, prev_target);
	    return(TRUE);
	}
    } else {

d352 1
a352 2
	 *  Search the links on the currently displayed page for
	 *  the string, starting after the current link. - FM
d354 2
a355 16
	if (check_next_target_in_links(&cur_doc->link, prev_target)) {
	    /*
	     *  Found in link, changed cur, we're done.
	     */
	    highlight(OFF, oldcur, prev_target);
	    return(TRUE);
	}

	/*
	 *  We'll search the text starting from the
	 *  link we are on, or the next page.
	 */
	if (nlinks == 0)
	    offset = (display_lines - 1);
	else
	    offset = links[cur_doc->link].ly - 1;
d357 9
d372 1
a372 1
    www_user_search((cur_doc->line + offset), cur_doc, prev_target, direction);
d377 1
a377 1
    return (BOOL) (www_search_result > 0);
@

