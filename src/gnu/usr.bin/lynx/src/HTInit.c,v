head	1.8;
access;
symbols
	lynx-2_8_6dev10:1.1.2.1
	FSF:1.1.2
	tg-mergetmp-mirosx-1:1.7
	tg-mergefixes-1-branch:1.7.0.4
	tg-mergefixes-1-base:1.7
	MIROS_X:1.7.0.2
	MIROS_X_BASE:1.7
	MIRBSD_XP_MIRPPC:1.6.0.4
	lynx-2_8_6dev_7b:1.1.3.5
	lynx-2_8_6dev_6:1.1.3.4
	MIRBSD_XP_SPARC_BASE:1.6
	MIRBSD_XP_SPARC:1.6.0.2
	lynx-2_8_6dev_5-iz2:1.1.3.4
	lynx-2_8_6dev_5:1.1.3.4
	cvs-200406091940:1.1.1.2
	MIRBSD_7quater:1.3
	cvs-200405160640:1.1.1.2
	lynx-2_8_6dev2:1.1.3.3
	lynx-2_8_5:1.1.3.2
	cvs-200401271800:1.1.1.2
	cvs-200401261630:1.1.1.2
	lynx_2-8-5_dev17d:1.1.3.2
	cvs-200401021645:1.1.1.2
	MIRBSD_7_ALPHA:1.3.0.6
	MIRBSD_7:1.3.0.4
	cvs-200312222040:1.1.1.2
	MIRBSD_7ter:1.3
	MIRBSD_7_DEV:1.3.0.2
	cvs-200310020700:1.1.1.2
	lynx_2-8-5_dev16c:1.1.3.1
	cvs-200309271030:1.1.1.2
	cvs-200309251530:1.1.1.2
	lynx_2-8-5_dev16:1.1.3.1
	tg:1.1.3
	cvs-200308302005:1.1.1.2
	cvs-200308171200:1.1.1.2
	ctm-3496:1.1.1.2
	ctm-3449:1.1.1.2
	ctm-3437:1.1.1.2
	cvs-200307191805:1.1.1.2
	ctm-3425:1.1.1.2
	cvs-200307091500:1.1.1.2
	VENDOR_LYNX_285dev16:1.3
	ctm-3389:1.1.1.2
	cvs-200306291430:1.1.1.2
	ctm-3341:1.1.1.2
	MIRBSD_5:1.1.1.2
	cvs-200306082100:1.1.1.2
	ctm-3316:1.1.1.2
	ctm-3272:1.1.1.2
	ctm-3264:1.1.1.2
	cvs-200305071630:1.1.1.2
	MIRBSD_4:1.1.1.1
	ctm-3203:1.1.1.1
	cvs-20030410-1130:1.1.1.1
	ctm-3155:1.1.1.1
	ctm-3132:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.01.03.00.45.54;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.10.26.25;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.18.16.49;	author tg;	state Stab;
branches;
next	1.5;

1.5
date	2004.04.30.16.32.30;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.18.16.56.04;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.18.58.27;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.07.18.49.25;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	2003.03.22.17.42.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.07.17.30.16;	author tg;	state Exp;
branches;
next	;

1.1.2.1
date	2005.01.03.00.30.19;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2003.09.17.14.20.21;	author tg;	state Exp;
branches;
next	1.1.3.2;

1.1.3.2
date	2004.01.18.15.34.42;	author tg;	state Exp;
branches;
next	1.1.3.3;

1.1.3.3
date	2004.04.30.16.16.02;	author tg;	state Exp;
branches;
next	1.1.3.4;

1.1.3.4
date	2004.07.15.15.53.18;	author tg;	state Exp;
branches;
next	1.1.3.5;

1.1.3.5
date	2004.10.20.10.10.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@soft merge
@
text
@/*		Configuration-specific Initialization		HTInit.c
 *		----------------------------------------
 */

/*	Define a basic set of suffixes and presentations
 *	------------------------------------------------
 */

#include <HTUtils.h>

/* Implements:
*/
#include <HTInit.h>

#include <HTML.h>
#include <HTPlain.h>
#include <HTMLGen.h>
#include <HTFile.h>
#include <HTFormat.h>
#include <HTMIME.h>
#include <HTWSRC.h>

#include <HTSaveToFile.h>	/* LJM */
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>

#include <LYexit.h>
#include <LYLeaks.h>

static int HTLoadTypesConfigFile(char *fn, AcceptMedia media);
static int HTLoadExtensionsConfigFile(char *fn);

#define SET_SUFFIX1(suffix, description, type) \
	HTSetSuffix(suffix, description, type, 1.0)

#define SET_SUFFIX5(suffix, mimetype, type, description) \
       HTSetSuffix5(suffix, mimetype, type, description, 1.0)

#define SET_PRESENT(mimetype, command, quality, delay) \
  HTSetPresentation(mimetype, command, 0, quality, delay, 0.0, 0, media)

#define SET_EXTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 3.0, 0.0, 0, mediaEXT)

#define SET_INTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 0.0, 0.0, 0, mediaINT)

void HTFormatInit(void)
{
    AcceptMedia media = mediaEXT;

#ifdef NeXT
    SET_PRESENT("application/postscript", "open %s", 1.0, 2.0);
    SET_PRESENT("image/x-tiff", "open %s", 2.0, 2.0);
    SET_PRESENT("image/tiff", "open %s", 1.0, 2.0);
    SET_PRESENT("audio/basic", "open %s", 1.0, 2.0);
    SET_PRESENT("*", "open %s", 1.0, 0.0);
#else
    if (LYgetXDisplay() != 0) {	/* Must have X11 */
	SET_PRESENT("application/postscript", "ghostview %s&", 1.0, 3.0);
	if (non_empty(XLoadImageCommand)) {
	    /* *INDENT-OFF* */
	    SET_PRESENT("image/gif",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbm",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbitmap", XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-png",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/png",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-rgb",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-tiff",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/tiff",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/jpeg",	   XLoadImageCommand, 1.0, 3.0);
	    /* *INDENT-ON* */

	}
	SET_PRESENT("video/mpeg", "mpeg_play %s &", 1.0, 3.0);

    }
#endif

#ifdef EXEC_SCRIPTS
    /* set quality to 999.0 for protected exec applications */
#ifndef VMS
    SET_PRESENT("application/x-csh", "csh %s", 999.0, 3.0);
    SET_PRESENT("application/x-sh", "sh %s", 999.0, 3.0);
    SET_PRESENT("application/x-ksh", "ksh %s", 999.0, 3.0);
#else
    SET_PRESENT("application/x-VMS_script", "@@%s", 999.0, 3.0);
#endif /* not VMS */
#endif /* EXEC_SCRIPTS */

    /*
     * Add our header handlers.
     */
    media = mediaINT;
    SET_INTERNL("message/x-http-redirection", "*", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/present", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/debug", HTMIMERedirect, 1.0);
    SET_INTERNL("www/mime", "www/present", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/download", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/source", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/dump", HTMIMEConvert, 1.0);

    /*
     * Add our compressed file handlers.
     */
    SET_INTERNL("www/compressed", "www/download", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/present", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/source", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/dump", HTCompressed, 1.0);

    /*
     * Added the following to support some content types beginning to surface.
     */
    SET_INTERNL("application/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("application/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("application/html", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/xhtml+xml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/x-wais-source", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/x-wais-source", "www/present", HTWSRCConvert, 2.0);
    SET_INTERNL("application/x-wais-source", "www/download", HTWSRCConvert, 1.0);
    SET_INTERNL("application/x-wais-source", "www/dump", HTWSRCConvert, 1.0);

    /*
     * Save all unknown mime types to disk.
     */
    SET_EXTERNL("www/source", "www/present", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/source", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/download", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "*", HTSaveToFile, 1.0);

    /*
     * Output all www/dump presentations to stdout.
     */
    SET_EXTERNL("www/source", "www/dump", HTDumpToStdout, 1.0);

    /*
     * Now add our basic conversions.
     */
    SET_INTERNL("text/x-sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/x-sgml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("text/sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/sgml", "www/present", HTMLPresent, 1.0);
    SET_INTERNL("text/plain", "www/present", HTPlainPresent, 1.0);
    SET_INTERNL("text/plain", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("text/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("text/html", "www/present", HTMLPresent, 1.0);

    /*
     * These should override the default types as necessary.
     */
    HTLoadTypesConfigFile(global_type_map, mediaSYS);

    /*
     * Load the local maps.
     */
    if (LYCanReadFile(personal_type_map)) {
	/* These should override everything else. */
	HTLoadTypesConfigFile(personal_type_map, mediaUSR);
    } else {
	char buffer[LY_MAXPATH];

	LYAddPathToHome(buffer, sizeof(buffer), personal_type_map);
	HTLoadTypesConfigFile(buffer, mediaUSR);
    }

    /*
     * Put text/html and text/plain at beginning of list.  - kw
     */
    HTReorderPresentation(WWW_PLAINTEXT, WWW_PRESENT);
    HTReorderPresentation(WWW_HTML, WWW_PRESENT);

    /*
     * Analyze the list, and set 'get_accept' for those whose representations
     * are not redundant.
     */
    HTFilterPresentations();
}

void HTPreparsedFormatInit(void)
{
    if (LYPreparsedSource) {
	SET_INTERNL("text/html", "www/source", HTMLParsedPresent, 1.0);
	SET_INTERNL("text/html", "www/dump", HTMLParsedPresent, 1.0);
    }
}

/* Some of the following is taken from: */

/*
Copyright (c) 1991 Bell Communications Research, Inc. (Bellcore)

Permission to use, copy, modify, and distribute this material
for any purpose and without fee is hereby granted, provided
that the above copyright notice and this permission notice
appear in all copies, and that the name of Bellcore not be
used in advertising or publicity pertaining to this
material without the specific, prior written permission
of an authorized representative of Bellcore.  BELLCORE
MAKES NO REPRESENTATIONS ABOUT THE ACCURACY OR SUITABILITY
OF THIS MATERIAL FOR ANY PURPOSE.  IT IS PROVIDED "AS IS",
WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.
*/
/******************************************************
    Metamail -- A tool to help diverse mail readers
                cope with diverse multimedia mail formats.

    Author:  Nathaniel S. Borenstein, Bellcore

 ******************************************************* */

struct MailcapEntry {
    char *contenttype;
    char *command;
    char *testcommand;
    int needsterminal;
    int copiousoutput;
    int needtofree;
    char *label;
    char *printcommand;
    char *nametemplate;
    float quality;
    long int maxbytes;
};

static int ExitWithError(const char *txt);
static int PassesTest(struct MailcapEntry *mc);

static char *GetCommand(char *s, char **t)
{
    char *s2;
    int quoted = 0;

    s = LYSkipBlanks(s);
    /* marca -- added + 1 for error case -- oct 24, 1993. */
    s2 = typeMallocn(char, strlen(s) * 2 + 1);	/* absolute max, if all % signs */

    if (!s2)
	ExitWithError(MEMORY_EXHAUSTED_ABORT);

    *t = s2;
    while (non_empty(s)) {
	if (quoted) {
	    if (*s == '%')
		*s2++ = '%';	/* Quote through next level, ugh! */

	    *s2++ = *s++;
	    quoted = 0;
	} else {
	    if (*s == ';') {
		*s2 = '\0';
		return (++s);
	    }
	    if (*s == '\\') {
		quoted = 1;
		++s;
	    } else {
		*s2++ = *s++;
	    }
	}
    }
    *s2 = '\0';
    return (NULL);
}

/* no leading or trailing space, all lower case */
static char *Cleanse(char *s)
{
    LYTrimLeading(s);
    LYTrimTrailing(s);
    LYLowerCase(s);
    return (s);
}

/* remove unnecessary (unquoted) blanks in a shell command */
static void TrimCommand(char *command)
{
    LYTrimTrailing(command);
#ifdef UNIX
    {
	char *s = command;
	char *d = command;
	int ch;
	int c0 = ' ';
	BOOL escape = FALSE;
	BOOL dquote = FALSE;
	BOOL squote = FALSE;

	while ((ch = *s++) != '\0') {
	    if (escape) {
		escape = FALSE;
	    } else if (squote) {
		if (ch == '\'')
		    squote = FALSE;
	    } else if (dquote) {
		if (ch == '"')
		    dquote = FALSE;
	    } else {
		switch (ch) {
		case '"':
		    dquote = TRUE;
		    break;
		case '\'':
		    squote = TRUE;
		    break;
		case '\\':
		    if (dquote)
			escape = TRUE;
		    break;
		}
	    }
	    if (!escape && !dquote && !squote) {
		if (ch == '\t')
		    ch = ' ';
		if (ch == ' ') {
		    if (c0 == ' ')
			continue;
		}
	    }
	    *d++ = ch;
	    c0 = ch;
	}
	*d = '\0';
    }
#endif
}

static int ProcessMailcapEntry(FILE *fp, struct MailcapEntry *mc, AcceptMedia media)
{
    size_t rawentryalloc = 2000, len, need;
    char *rawentry, *s, *t;
    char *LineBuf = NULL;

    rawentry = (char *) malloc(rawentryalloc);
    if (!rawentry)
	ExitWithError(MEMORY_EXHAUSTED_ABORT);
    *rawentry = '\0';
    while (LYSafeGets(&LineBuf, fp) != 0) {
	LYTrimNewline(LineBuf);
	if (LineBuf[0] == '#' || LineBuf[0] == '\0')
	    continue;
	len = strlen(LineBuf);
	need = len + strlen(rawentry) + 1;
	if (need > rawentryalloc) {
	    rawentryalloc += (2000 + need);
	    rawentry = typeRealloc(char, rawentry, rawentryalloc);

	    if (!rawentry)
		ExitWithError(MEMORY_EXHAUSTED_ABORT);
	}
	if (len > 0 && LineBuf[len - 1] == '\\') {
	    LineBuf[len - 1] = '\0';
	    strcat(rawentry, LineBuf);
	} else {
	    strcat(rawentry, LineBuf);
	    break;
	}
    }
    FREE(LineBuf);

    t = s = LYSkipBlanks(rawentry);
    if (!*s) {
	/* totally blank entry -- quietly ignore */
	FREE(rawentry);
	return (0);
    }
    s = strchr(rawentry, ';');
    if (s == NULL) {
	CTRACE((tfp,
		"ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		rawentry));
	FREE(rawentry);
	return (0);
    }
    *s++ = '\0';
    if (!strncasecomp(t, "text/html", 9) ||
	!strncasecomp(t, "text/plain", 10)) {
	--s;
	*s = ';';
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
		rawentry));
	FREE(rawentry);
	return (0);
    }
    LYRemoveBlanks(rawentry);
    LYLowerCase(rawentry);

    mc->needsterminal = 0;
    mc->copiousoutput = 0;
    mc->needtofree = 1;
    mc->testcommand = NULL;
    mc->label = NULL;
    mc->printcommand = NULL;
    mc->contenttype = NULL;
    StrAllocCopy(mc->contenttype, rawentry);
    mc->quality = (float) 1.0;
    mc->maxbytes = 0;
    t = GetCommand(s, &mc->command);
    if (!t) {
	goto assign_presentation;
    }
    s = LYSkipBlanks(t);
    while (s) {
	char *arg, *eq, *mallocd_string;

	t = GetCommand(s, &mallocd_string);
	arg = mallocd_string;
	eq = strchr(arg, '=');
	if (eq) {
	    *eq++ = '\0';
	    eq = LYSkipBlanks(eq);
	}
	if (non_empty(arg)) {
	    arg = Cleanse(arg);
	    if (!strcmp(arg, "needsterminal")) {
		mc->needsterminal = 1;
	    } else if (!strcmp(arg, "copiousoutput")) {
		mc->copiousoutput = 1;
	    } else if (eq && !strcmp(arg, "test")) {
		mc->testcommand = NULL;
		StrAllocCopy(mc->testcommand, eq);
		TrimCommand(mc->testcommand);
		CTRACE((tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
			mc->testcommand));
	    } else if (eq && !strcmp(arg, "description")) {
		mc->label = eq;	/* ignored */
	    } else if (eq && !strcmp(arg, "label")) {
		mc->label = eq;	/* ignored: bogus old name for description */
	    } else if (eq && !strcmp(arg, "print")) {
		mc->printcommand = eq;	/* ignored */
	    } else if (eq && !strcmp(arg, "textualnewlines")) {
		/* no support for now.  What does this do anyways? */
		/* ExceptionalNewline(mc->contenttype, atoi(eq)); */
	    } else if (eq && !strcmp(arg, "q")) {
		mc->quality = (float) atof(eq);
		if (mc->quality > 0.000 && mc->quality < 0.001)
		    mc->quality = (float) 0.001;
	    } else if (eq && !strcmp(arg, "mxb")) {
		mc->maxbytes = atol(eq);
		if (mc->maxbytes < 0)
		    mc->maxbytes = 0;
	    } else if (strcmp(arg, "notes")) {	/* IGNORE notes field */
		if (*arg)
		    CTRACE((tfp,
			    "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			    arg));
	    }

	}
	FREE(mallocd_string);
	s = t;
    }

  assign_presentation:
    FREE(rawentry);

    if (PassesTest(mc)) {
	CTRACE((tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
		mc->contenttype, mc->command));
	HTSetPresentation(mc->contenttype,
			  mc->command,
			  mc->testcommand,
			  mc->quality,
			  3.0, 0.0, mc->maxbytes, media);
    }
    FREE(mc->command);
    FREE(mc->testcommand);
    FREE(mc->contenttype);

    return (1);
}

#define L_CURL '{'
#define R_CURL '}'

static const char *LYSkipQuoted(const char *s)
{
    int escaped = 0;

    ++s;			/* skip first quote */
    while (*s != 0) {
	if (escaped) {
	    escaped = 0;
	} else if (*s == '\\') {
	    escaped = 1;
	} else if (*s == '"') {
	    ++s;
	    break;
	}
	++s;
    }
    return s;
}

/*
 * Note: the tspecials[] here are those defined for Content-Type header, so
 * this function is not really general-purpose.
 */
static const char *LYSkipToken(const char *s)
{
    static const char tspecials[] = "\"()<>@@,;:\\/[]?.=";

    while (*s != '\0' && !WHITE(*s) && strchr(tspecials, *s) == 0) {
	++s;
    }
    return s;
}

static const char *LYSkipValue(const char *s)
{
    if (*s == '"')
	s = LYSkipQuoted(s);
    else
	s = LYSkipToken(s);
    return s;
}

/*
 * Copy the value from the source, dequoting if needed.
 */
static char *LYCopyValue(const char *s)
{
    const char *t;
    char *result = 0;
    int j, k;

    if (*s == '"') {
	t = LYSkipQuoted(s);
	StrAllocCopy(result, s + 1);
	result[t - s - 2] = '\0';
	for (j = k = 0;; ++j, ++k) {
	    if (result[j] == '\\') {
		++j;
	    }
	    if ((result[k] = result[j]) == '\0')
		break;
	}
    } else {
	t = LYSkipToken(s);
	StrAllocCopy(result, s);
	result[t - s] = '\0';
    }
    return result;
}

/*
 * The "Content-Type:" field, contains zero or more parameters after a ';'.
 * Return the value of the named parameter, or null.
 */
static char *LYGetContentType(const char *name,
			      const char *params)
{
    char *result = 0;

    if (params != 0) {
	if (name != 0) {
	    size_t length = strlen(name);
	    const char *test = strchr(params, ';');	/* skip type/subtype */
	    const char *next;

	    while (test != 0) {
		BOOL found = FALSE;

		++test;		/* skip the ';' */
		test = LYSkipCBlanks(test);
		next = LYSkipToken(test);
		if ((next - test) == (int) length
		    && !strncmp(test, name, length)) {
		    found = TRUE;
		}
		test = LYSkipCBlanks(next);
		if (*test == '=') {
		    ++test;
		    test = LYSkipCBlanks(test);
		    if (found) {
			result = LYCopyValue(test);
			break;
		    } else {
			test = LYSkipValue(test);
		    }
		    test = LYSkipCBlanks(test);
		}
		if (*test != ';') {
		    break;	/* we're lost */
		}
	    }
	} else {		/* return the content-type */
	    StrAllocCopy(result, params);
	    *LYSkipNonBlanks(result) = '\0';
	}
    }
    return result;
}

/*
 * Check if the command uses a "%s" substitution.  We need to know this, to
 * decide when to create temporary files, etc.
 */
BOOL LYMailcapUsesPctS(const char *controlstring)
{
    int result = FALSE;
    const char *from;
    const char *next;
    int prefixed = 0;
    int escaped = 0;

    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	} else if (*from == '\\') {
	    escaped = 1;
	} else if (prefixed) {
	    prefixed = 0;
	    switch (*from) {
	    case '%':		/* not defined */
	    case 'n':
	    case 'F':
	    case 't':
		break;
	    case 's':
		result = TRUE;
		break;
	    case L_CURL:
		next = strchr(from, R_CURL);
		if (next != 0) {
		    from = next;
		    break;
		}
		/* FALLTHRU */
	    default:
		break;
	    }
	} else if (*from == '%') {
	    prefixed = 1;
	}
    }
    return result;
}

/*
 * Build the command string for testing or executing a mailcap entry.
 * If a substitution from the Content-Type header is requested but no
 * parameters are available, return -1, otherwise 0.
 *
 * This does not support multipart %n or %F (does this apply to lynx?)
 */
static int BuildCommand(HTChunk *cmd,
			const char *controlstring,
			const char *TmpFileName,
			const char *params)
{
    int result = 0;
    size_t TmpFileLen = strlen(TmpFileName);
    const char *from;
    const char *next;
    char *name, *value;
    int prefixed = 0;
    int escaped = 0;

    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	    HTChunkPutc(cmd, *from);
	} else if (*from == '\\') {
	    escaped = 1;
	} else if (prefixed) {
	    prefixed = 0;
	    switch (*from) {
	    case '%':		/* not defined */
		HTChunkPutc(cmd, *from);
		break;
	    case 'n':
		/* FALLTHRU */
	    case 'F':
		CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
			controlstring));
		break;
	    case 't':
		if ((value = LYGetContentType(NULL, params)) != 0) {
		    HTChunkPuts(cmd, value);
		    FREE(value);
		}
		break;
	    case 's':
		if (TmpFileLen && TmpFileName) {
		    HTChunkPuts(cmd, TmpFileName);
		}
		break;
	    case L_CURL:
		next = strchr(from, R_CURL);
		if (next != 0) {
		    if (params != 0) {
			++from;
			name = 0;
			HTSprintf0(&name, "%.*s", next - from, from);
			if ((value = LYGetContentType(name, params)) != 0) {
			    HTChunkPuts(cmd, value);
			    FREE(value);
			} else {
			    if (!strcmp(name, "charset")) {
				HTChunkPuts(cmd, "ISO-8859-1");
			    } else {
				CTRACE((tfp, "BuildCommand no value for %s\n", name));
			    }
			}
			FREE(name);
		    } else {
			result = -1;
		    }
		    from = next;
		    break;
		}
		/* FALLTHRU */
	    default:
		CTRACE((tfp,
			"BuildCommand: Ignoring unrecognized format code in mailcap file '%%%c'.\n",
			*from));
		break;
	    }
	} else if (*from == '%') {
	    prefixed = 1;
	} else {
	    HTChunkPutc(cmd, *from);
	}
    }
    HTChunkTerminate(cmd);
    return result;
}

/*
 * Build the mailcap test-command and execute it.  This is only invoked when
 * we cannot tell just by looking at the command if it would succeed.
 *
 * Returns 0 for success, -1 for error and 1 for deferred.
 */
int LYTestMailcapCommand(const char *testcommand,
			 const char *params)
{
    int result;
    char TmpFileName[LY_MAXPATH];
    HTChunk *expanded = 0;

    if (LYMailcapUsesPctS(testcommand)) {
	if (LYOpenTemp(TmpFileName, HTML_SUFFIX, "w") == 0)
	    ExitWithError(CANNOT_OPEN_TEMP);
	LYCloseTemp(TmpFileName);
    } else {
	/* We normally don't need a temp file name - kw */
	TmpFileName[0] = '\0';
    }
    expanded = HTChunkCreate(1024);
    if ((result = BuildCommand(expanded, testcommand, TmpFileName, params)) != 0) {
	result = 1;
	CTRACE((tfp, "PassesTest: Deferring test command: %s\n", expanded->data));
    } else {
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", expanded->data));
	if ((result = LYSystem(expanded->data)) != 0) {
	    result = -1;
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	} else {
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
	}
    }

    HTChunkFree(expanded);
    LYRemoveTemp(TmpFileName);

    return result;
}

char *LYMakeMailcapCommand(const char *command,
			   const char *params,
			   const char *filename)
{
    HTChunk *expanded = 0;
    char *result = 0;

    expanded = HTChunkCreate(1024);
    BuildCommand(expanded, command, filename, params);
    StrAllocCopy(result, expanded->data);
    HTChunkFree(expanded);
    return result;
}

#define RTR_forget      0
#define RTR_lookup      1
#define RTR_add         2

static int RememberTestResult(int mode, char *cmd, int result)
{
    struct cmdlist_s {
	char *cmd;
	int result;
	struct cmdlist_s *next;
    };
    static struct cmdlist_s *cmdlist = NULL;
    struct cmdlist_s *cur;

    switch (mode) {
    case RTR_forget:
	while (cmdlist) {
	    cur = cmdlist->next;
	    FREE(cmdlist->cmd);
	    FREE(cmdlist);
	    cmdlist = cur;
	}
	break;
    case RTR_lookup:
	for (cur = cmdlist; cur; cur = cur->next)
	    if (!strcmp(cmd, cur->cmd))
		return cur->result;
	return -1;
    case RTR_add:
	cur = typecalloc(struct cmdlist_s);

	if (cur == NULL)
	    outofmem(__FILE__, "RememberTestResult");
	cur->next = cmdlist;
	StrAllocCopy(cur->cmd, cmd);
	cur->result = result;
	cmdlist = cur;
	break;
    }
    return 0;
}

/* FIXME: this sometimes used caseless comparison, e.g., strcasecomp */
#define SameCommand(tst,ref) !strcmp(tst,ref)

static int PassesTest(struct MailcapEntry *mc)
{
    int result;

    /*
     *  Make sure we have a command
     */
    if (!mc->testcommand)
	return (1);

    /*
     *  Save overhead of system() calls by faking these. - FM
     */
    if (SameCommand(mc->testcommand, "test \"$DISPLAY\"") ||
	SameCommand(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	SameCommand(mc->testcommand, "test -n \"$DISPLAY\"")) {
	FREE(mc->testcommand);
	CTRACE((tfp, "PassesTest: Testing for XWINDOWS environment.\n"));
	if (LYgetXDisplay() != NULL) {
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
	    return (0 == 0);
	} else {
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	    return (-1 == 0);
	}
    }
    if (SameCommand(mc->testcommand, "test -z \"$DISPLAY\"")) {
	FREE(mc->testcommand);
	CTRACE((tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n"));
	if (LYgetXDisplay() == NULL) {
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
	    return (0 == 0);
	} else {
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	    return (-1 == 0);
	}
    }

    /*
     *  Why do anything but return success for this one! - FM
     */
    if (SameCommand(mc->testcommand, "test -n \"$LYNX_VERSION\"")) {
	FREE(mc->testcommand);
	CTRACE((tfp, "PassesTest: Testing for LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test passed!\n"));
	return (0 == 0);
    } else
	/*
	 *  ... or failure for this one! - FM
	 */
    if (SameCommand(mc->testcommand, "test -z \"$LYNX_VERSION\"")) {
	FREE(mc->testcommand);
	CTRACE((tfp, "PassesTest: Testing for non-LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test failed!\n"));
	return (-1 == 0);
    }

    result = RememberTestResult(RTR_lookup, mc->testcommand, 0);
    if (result == -1) {
	result = LYTestMailcapCommand(mc->testcommand, NULL);
	RememberTestResult(RTR_add, mc->testcommand, result ? 1 : 0);
    }

    /*
     *  Free the test command as well since
     *  we wont be needing it anymore.
     */
    if (result != 1)
	FREE(mc->testcommand);

    if (result < 0) {
	CTRACE((tfp, "PassesTest: Test failed!\n"));
    } else if (result == 0) {
	CTRACE((tfp, "PassesTest: Test passed!\n"));
    }

    return (result >= 0);
}

static int ProcessMailcapFile(char *file, AcceptMedia media)
{
    struct MailcapEntry mc;
    FILE *fp;

    CTRACE((tfp, "ProcessMailcapFile: Loading file '%s'.\n",
	    file));
    if ((fp = fopen(file, TXT_R)) == NULL) {
	CTRACE((tfp, "ProcessMailcapFile: Could not open '%s'.\n",
		file));
	return (-1 == 0);
    }

    while (fp && !feof(fp)) {
	ProcessMailcapEntry(fp, &mc, media);
    }
    LYCloseInput(fp);
    RememberTestResult(RTR_forget, NULL, 0);
    return (0 == 0);
}

static int ExitWithError(const char *txt)
{
    if (txt)
	fprintf(tfp, "Lynx: %s\n", txt);
    exit_immediately(EXIT_FAILURE);
    return (-1);
}

/* Reverse the entries from each mailcap after it has been read, so that
 * earlier entries have precedence.  Set to 0 to get traditional lynx
 * behavior, which means that the last match wins. - kw */
static int reverse_mailcap = 1;

static int HTLoadTypesConfigFile(char *fn, AcceptMedia media)
{
    int result = 0;
    HTList *saved = HTPresentations;

    if (reverse_mailcap) {	/* temporarily hide existing list */
	HTPresentations = NULL;
    }

    result = ProcessMailcapFile(fn, media);

    if (reverse_mailcap) {
	if (result && HTPresentations) {
	    HTList_reverse(HTPresentations);
	    HTList_appendList(HTPresentations, saved);
	    FREE(saved);
	} else {
	    HTPresentations = saved;
	}
    }
    return result;
}

/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */

/*	Define a basic set of suffixes
 *	------------------------------
 *
 *	The LAST suffix for a type is that used for temporary files
 *	of that type.
 *	The quality is an apriori bias as to whether the file should be
 *	used.  Not that different suffixes can be used to represent files
 *	which are of the same format but are originals or regenerated,
 *	with different values.
 */
/*
 * Additional notes:  the encoding parameter may be taken into account when
 * looking for a match; for that purpose "7bit", "8bit", and "binary" are
 * equivalent.
 *
 * Use of mixed case and of pseudo MIME types with embedded spaces should be
 * avoided.  It was once necessary for getting the fancy strings into type
 * labels in FTP directory listings, but that can now be done with the
 * description field (using HTSetSuffix5).  AFAIK the only effect of such
 * "fancy" (and mostly invalid) types that cannot be reproduced by using a
 * description fields is some statusline messages in SaveToFile (HTFWriter.c). 
 * And showing the user an invalid MIME type as the 'Content-type:' is not such
 * a hot idea anyway, IMO.  Still, if you want it, it is still possible (even
 * in lynx.cfg now), but use of it in the defaults below has been reduced.
 *
 * Case variations rely on peculiar behavior of HTAtom.c for matching.  They
 * lead to surprising behavior, Lynx retains the case of a string in the form
 * first encountered after starting up.  So while later suffix rules generally
 * override or modify earlier ones, the case used for a MIME time is determined
 * by the first suffix rule (or other occurrence).  Matching in HTAtom_for is
 * effectively case insensitive, except for the first character of the string
 * which is treated as case-sensitive by the hash function there; best not to
 * rely on that, rather convert MIME types to lowercase on input as is already
 * done in most places (And HTAtom could become consistently case-sensitive, as
 * in newer W3C libwww).
 *  - kw 1999-10-12
 */
void HTFileInit(void)
{
#ifdef BUILTIN_SUFFIX_MAPS
    if (LYUseBuiltinSuffixes) {
	CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));

	/* default suffix interpretation */
	SET_SUFFIX1("*", "text/plain", "8bit");
	SET_SUFFIX1("*.*", "text/plain", "8bit");

#ifdef EXEC_SCRIPTS
	/*
	 * define these extensions for exec scripts.
	 */
#ifndef VMS
	/* for csh exec links */
	HTSetSuffix(".csh", "application/x-csh", "8bit", 0.8);
	HTSetSuffix(".sh", "application/x-sh", "8bit", 0.8);
	HTSetSuffix(".ksh", "application/x-ksh", "8bit", 0.8);
#else
	HTSetSuffix(".com", "application/x-VMS_script", "8bit", 0.8);
#endif /* !VMS */
#endif /* EXEC_SCRIPTS */

	/*
	 * Some of the old incarnation of the mappings is preserved and can be had
	 * by defining TRADITIONAL_SUFFIXES.  This is for some cases where I felt
	 * the old rules might be preferred by someone, for some reason.  It's not
	 * done consistently.  A lot more of this stuff could probably be changed
	 * too or omitted, now that nearly the equivalent functionality is
	 * available in lynx.cfg.  - kw 1999-10-12
	 */
	/* *INDENT-OFF* */
	SET_SUFFIX1(".saveme",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".dump",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".bin",	"application/x-Binary",		"binary");

	SET_SUFFIX1(".arc",	"application/x-Compressed",	"binary");

	SET_SUFFIX1(".alpha-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".alpha_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX_exe", "application/x-Executable",	"binary");
	SET_SUFFIX5(".exe",	"application/octet-stream",	"binary", "Executable");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".exe.Z",	"application/x-Comp. Executable", "binary");
	SET_SUFFIX1(".Z",	"application/UNIX Compressed",	"binary");
	SET_SUFFIX1(".tar_Z",	"application/UNIX Compr. Tar",	"binary");
	SET_SUFFIX1(".tar.Z",	"application/UNIX Compr. Tar",	"binary");
#else
	SET_SUFFIX5(".Z",	"application/x-compress",	"binary", "UNIX Compressed");
	SET_SUFFIX5(".Z",	NULL,				"compress", "UNIX Compressed");
	SET_SUFFIX5(".exe.Z",	"application/octet-stream",	"compress", "Executable");
	SET_SUFFIX5(".tar_Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
	SET_SUFFIX5(".tar.Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
#endif

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1("-gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1("_gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1(".gz",	"application/GNU Compressed",	"binary");

	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"binary", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
#else
	SET_SUFFIX5("-gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("_gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5(".gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("-gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5("_gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5(".gz",	NULL,				"gzip", "GNU Compressed");

	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
#endif

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".src",	"application/x-WAIS-source",	"8bit");
	SET_SUFFIX1(".wsrc",	"application/x-WAIS-source",	"8bit");
#else
	SET_SUFFIX5(".wsrc",	"application/x-wais-source",	"8bit", "WAIS-source");
#endif

	SET_SUFFIX5(".zip",	"application/zip",		"binary", "Zip File");

	SET_SUFFIX1(".zz",	"application/x-deflate",	"binary");
	SET_SUFFIX1(".zz",	"application/deflate",		"binary");

	SET_SUFFIX1(".bz2",	"application/x-bzip2",		"binary");
	SET_SUFFIX1(".bz2",	"application/bzip2",		"binary");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".uu",	"application/x-UUencoded",	"8bit");

	SET_SUFFIX1(".hqx",	"application/x-Binhex",		"8bit");

	SET_SUFFIX1(".o",	"application/x-Prog. Object",	"binary");
	SET_SUFFIX1(".a",	"application/x-Prog. Library",	"binary");
#else
	SET_SUFFIX5(".uu",	"application/x-uuencoded",	"7bit", "UUencoded");

	SET_SUFFIX5(".hqx",	"application/mac-binhex40",	"8bit", "Mac BinHex");

	HTSetSuffix5(".o",	"application/octet-stream",	"binary", "Prog. Object", 0.5);
	HTSetSuffix5(".a",	"application/octet-stream",	"binary", "Prog. Library", 0.5);
	HTSetSuffix5(".so",	"application/octet-stream",	"binary", "Shared Lib", 0.5);
#endif

	SET_SUFFIX5(".oda",	"application/oda",		"binary", "ODA");

	SET_SUFFIX5(".pdf",	"application/pdf",		"binary", "PDF");

	SET_SUFFIX5(".eps",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ai",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ps",	"application/postscript",	"8bit", "Postscript");

	SET_SUFFIX5(".rtf",	"application/rtf",		"8bit", "RTF");

	SET_SUFFIX5(".dvi",	"application/x-dvi",		"8bit", "DVI");

	SET_SUFFIX5(".hdf",	"application/x-hdf",		"8bit", "HDF");

	SET_SUFFIX1(".cdf",	"application/x-netcdf",		"8bit");
	SET_SUFFIX1(".nc",	"application/x-netcdf",		"8bit");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".latex",	"application/x-Latex",		"8bit");
	SET_SUFFIX1(".tex",	"application/x-Tex",		"8bit");
	SET_SUFFIX1(".texinfo", "application/x-Texinfo",	"8bit");
	SET_SUFFIX1(".texi",	"application/x-Texinfo",	"8bit");
#else
	SET_SUFFIX5(".latex",	"application/x-latex",		"8bit", "LaTeX");
	SET_SUFFIX5(".tex",	"text/x-tex",			"8bit", "TeX");
	SET_SUFFIX5(".texinfo", "application/x-texinfo",	"8bit", "Texinfo");
	SET_SUFFIX5(".texi",	"application/x-texinfo",	"8bit", "Texinfo");
#endif

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".t",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".tr",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".roff",	"application/x-Troff",		"8bit");

	SET_SUFFIX1(".man",	"application/x-Troff-man",	"8bit");
	SET_SUFFIX1(".me",	"application/x-Troff-me",	"8bit");
	SET_SUFFIX1(".ms",	"application/x-Troff-ms",	"8bit");
#else
	SET_SUFFIX5(".t",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".tr",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".roff",	"application/x-troff",		"8bit", "Troff");

	SET_SUFFIX5(".man",	"application/x-troff-man",	"8bit", "Man Page");
	SET_SUFFIX5(".me",	"application/x-troff-me",	"8bit", "Troff me");
	SET_SUFFIX5(".ms",	"application/x-troff-ms",	"8bit", "Troff ms");
#endif

	SET_SUFFIX1(".zoo",	"application/x-Zoo File",	"binary");

#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
	SET_SUFFIX1(".bak",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bkp",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bck",	"application/x-VMS BAK File",	"binary");

	SET_SUFFIX5(".bkp_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bkp-gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck-gz",	"application/octet-stream",	"gzip", "GNU BAK File");

	SET_SUFFIX5(".bkp-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bkp_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
#else
	HTSetSuffix5(".bak",	NULL,				"binary", "Backup", 0.5);
	SET_SUFFIX5(".bkp",	"application/octet-stream",	"binary", "VMS BAK File");
	SET_SUFFIX5(".bck",	"application/octet-stream",	"binary", "VMS BAK File");
#endif

#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
	SET_SUFFIX1(".hlb",	"application/x-VMS Help Libr.", "binary");
	SET_SUFFIX1(".olb",	"application/x-VMS Obj. Libr.", "binary");
	SET_SUFFIX1(".tlb",	"application/x-VMS Text Libr.", "binary");
	SET_SUFFIX1(".obj",	"application/x-VMS Prog. Obj.", "binary");
	SET_SUFFIX1(".decw$book", "application/x-DEC BookReader", "binary");
	SET_SUFFIX1(".mem",	"application/x-RUNOFF-MANUAL", "8bit");
#else
	SET_SUFFIX5(".hlb",	"application/octet-stream",	"binary", "VMS Help Libr.");
	SET_SUFFIX5(".olb",	"application/octet-stream",	"binary", "VMS Obj. Libr.");
	SET_SUFFIX5(".tlb",	"application/octet-stream",	"binary", "VMS Text Libr.");
	SET_SUFFIX5(".obj",	"application/octet-stream",	"binary", "Prog. Object");
	SET_SUFFIX5(".decw$book", "application/octet-stream",	"binary", "DEC BookReader");
	SET_SUFFIX5(".mem",	"text/x-runoff-manual",		"8bit", "RUNOFF-MANUAL");
#endif

	SET_SUFFIX1(".vsd",	"application/visio",		"binary");

	SET_SUFFIX5(".lha",	"application/x-lha",		"binary", "lha File");
	SET_SUFFIX5(".lzh",	"application/x-lzh",		"binary", "lzh File");
	SET_SUFFIX5(".sea",	"application/x-sea",		"binary", "sea File");
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX5(".sit",	"application/x-sit",		"binary", "sit File");
#else
	SET_SUFFIX5(".sit",	"application/x-stuffit",	"binary", "StuffIt");
#endif
	SET_SUFFIX5(".dms",	"application/x-dms",		"binary", "dms File");
	SET_SUFFIX5(".iff",	"application/x-iff",		"binary", "iff File");

	SET_SUFFIX1(".bcpio",	"application/x-bcpio",		"binary");
	SET_SUFFIX1(".cpio",	"application/x-cpio",		"binary");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".gtar",	"application/x-gtar",		"binary");
#endif

	SET_SUFFIX1(".shar",	"application/x-shar",		"8bit");
	SET_SUFFIX1(".share",	"application/x-share",		"8bit");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".sh",	"application/x-sh",		"8bit"); /* xtra */
#endif

	SET_SUFFIX1(".sv4cpio", "application/x-sv4cpio",	"binary");
	SET_SUFFIX1(".sv4crc",	"application/x-sv4crc",		"binary");

	SET_SUFFIX5(".tar",	"application/x-tar",		"binary", "Tar File");
	SET_SUFFIX1(".ustar",	"application/x-ustar",		"binary");

	SET_SUFFIX1(".snd",	"audio/basic",			"binary");
	SET_SUFFIX1(".au",	"audio/basic",			"binary");

	SET_SUFFIX1(".aifc",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aif",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aiff",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".wav",	"audio/x-wav",			"binary");
	SET_SUFFIX1(".midi",	"audio/midi",			"binary");
	SET_SUFFIX1(".mod",	"audio/mod",			"binary");

	SET_SUFFIX1(".gif",	"image/gif",			"binary");
	SET_SUFFIX1(".ief",	"image/ief",			"binary");
	SET_SUFFIX1(".jfif",	"image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jfif-tbnl", "image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jpe",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpeg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".tif",	"image/tiff",			"binary");
	SET_SUFFIX1(".tiff",	"image/tiff",			"binary");
	SET_SUFFIX1(".ham",	"image/ham",			"binary");
	SET_SUFFIX1(".ras",	"image/x-cmu-rast",		"binary");
	SET_SUFFIX1(".pnm",	"image/x-portable-anymap",	"binary");
	SET_SUFFIX1(".pbm",	"image/x-portable-bitmap",	"binary");
	SET_SUFFIX1(".pgm",	"image/x-portable-graymap",	"binary");
	SET_SUFFIX1(".ppm",	"image/x-portable-pixmap",	"binary");
	SET_SUFFIX1(".png",	"image/png",			"binary");
	SET_SUFFIX1(".rgb",	"image/x-rgb",			"binary");
	SET_SUFFIX1(".xbm",	"image/x-xbitmap",		"binary");
	SET_SUFFIX1(".xpm",	"image/x-xpixmap",		"binary");
	SET_SUFFIX1(".xwd",	"image/x-xwindowdump",		"binary");

	SET_SUFFIX1(".rtx",	"text/richtext",		"8bit");
	SET_SUFFIX1(".tsv",	"text/tab-separated-values",	"8bit");
	SET_SUFFIX1(".etx",	"text/x-setext",		"8bit");

	SET_SUFFIX1(".mpg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpe",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpeg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mov",	"video/quicktime",		"binary");
	SET_SUFFIX1(".qt",	"video/quicktime",		"binary");
	SET_SUFFIX1(".avi",	"video/x-msvideo",		"binary");
	SET_SUFFIX1(".movie",	"video/x-sgi-movie",		"binary");
	SET_SUFFIX1(".mv",	"video/x-sgi-movie",		"binary");

	SET_SUFFIX1(".mime",	"message/rfc822",		"8bit");

	SET_SUFFIX1(".c",	"text/plain",			"8bit");
	SET_SUFFIX1(".cc",	"text/plain",			"8bit");
	SET_SUFFIX1(".c++",	"text/plain",			"8bit");
	SET_SUFFIX1(".h",	"text/plain",			"8bit");
	SET_SUFFIX1(".pl",	"text/plain",			"8bit");
	SET_SUFFIX1(".text",	"text/plain",			"8bit");
	SET_SUFFIX1(".txt",	"text/plain",			"8bit");

	SET_SUFFIX1(".php",	"text/html",			"8bit");
	SET_SUFFIX1(".php3",	"text/html",			"8bit");
	SET_SUFFIX1(".html3",	"text/html",			"8bit");
	SET_SUFFIX1(".ht3",	"text/html",			"8bit");
	SET_SUFFIX1(".phtml",	"text/html",			"8bit");
	SET_SUFFIX1(".shtml",	"text/html",			"8bit");
	SET_SUFFIX1(".sht",	"text/html",			"8bit");
	SET_SUFFIX1(".htmlx",	"text/html",			"8bit");
	SET_SUFFIX1(".htm",	"text/html",			"8bit");
	SET_SUFFIX1(".html",	"text/html",			"8bit");
	/* *INDENT-ON* */

    } else {			/* LYSuffixRules */
	/*
	 * Note that even .html -> text/html, .htm -> text/html are omitted if
	 * default maps are compiled in but then skipped because of a
	 * configuration file directive.  Whoever changes the config file in
	 * this way can easily also add the SUFFIX rules there.  - kw
	 */
	CTRACE((tfp,
		"HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    }				/* LYSuffixRules */

#else /* BUILTIN_SUFFIX_MAPS */

    CTRACE((tfp,
	    "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
    /*
     * The following two are still used if BUILTIN_SUFFIX_MAPS was undefined. 
     * Without one of them, lynx would always need to have a mapping specified
     * in a lynx.cfg or mime.types file to be usable for local HTML files at
     * all.  That includes many of the generated user interface pages.  - kw
     */
    SET_SUFFIX1(".htm", "text/html", "8bit");
    SET_SUFFIX1(".html", "text/html", "8bit");
#endif /* BUILTIN_SUFFIX_MAPS */

    /* These should override the default extensions as necessary. */
    HTLoadExtensionsConfigFile(global_extension_map);

    if (LYCanReadFile(personal_extension_map)) {
	/* These should override everything else. */
	HTLoadExtensionsConfigFile(personal_extension_map);
    } else {
	char buffer[LY_MAXPATH];

	LYAddPathToHome(buffer, sizeof(buffer), personal_extension_map);
	/* These should override everything else. */
	HTLoadExtensionsConfigFile(buffer);
    }
}

/* -------------------- Extension config file reading --------------------- */

/*
 *  The following is lifted from NCSA httpd 1.0a1, by Rob McCool;
 *  NCSA httpd is in the public domain, as is this code.
 *
 *  Modified Oct 97 - KW
 */

#define MAX_STRING_LEN 256

static int HTGetLine(char *s, int n, FILE *f)
{
    register int i = 0, r;

    if (!f)
	return (1);

    while (1) {
	r = fgetc(f);
	s[i] = (char) r;

	if (s[i] == CR) {
	    r = fgetc(f);
	    if (r == LF)
		s[i] = (char) r;
	    else if (r != EOF)
		ungetc(r, f);
	}

	if ((r == EOF) || (s[i] == LF) || (s[i] == CR) || (i == (n - 1))) {
	    s[i] = '\0';
	    return (feof(f) ? 1 : 0);
	}
	++i;
    }
}

static void HTGetWord(char *word, char *line, char stop, char stop2)
{
    int x = 0, y;

    for (x = 0; line[x] && line[x] != stop && line[x] != stop2; x++) {
	word[x] = line[x];
    }

    word[x] = '\0';
    if (line[x])
	++x;
    y = 0;

    while ((line[y++] = line[x++])) ;

    return;
}

static int HTLoadExtensionsConfigFile(char *fn)
{
    char line[MAX_STRING_LEN];
    char word[MAX_STRING_LEN];
    char *ct;
    FILE *f;
    int count = 0;

    CTRACE((tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn));

    if ((f = fopen(fn, TXT_R)) == NULL) {
	CTRACE((tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn));
	return count;
    }

    while (!(HTGetLine(line, sizeof(line), f))) {
	HTGetWord(word, line, ' ', '\t');
	if (line[0] == '\0' || word[0] == '#')
	    continue;
	ct = NULL;
	StrAllocCopy(ct, word);
	LYLowerCase(ct);

	while (line[0]) {
	    HTGetWord(word, line, ' ', '\t');
	    if (word[0] && (word[0] != ' ')) {
		char *ext = NULL;

		HTSprintf0(&ext, ".%s", word);
		LYLowerCase(ext);

		CTRACE((tfp, "SETTING SUFFIX '%s' to '%s'.\n", ext, ct));

		if (strstr(ct, "tex") != NULL ||
		    strstr(ct, "postscript") != NULL ||
		    strstr(ct, "sh") != NULL ||
		    strstr(ct, "troff") != NULL ||
		    strstr(ct, "rtf") != NULL)
		    SET_SUFFIX1(ext, ct, "8bit");
		else
		    SET_SUFFIX1(ext, ct, "binary");
		count++;

		FREE(ext);
	    }
	}
	FREE(ct);
    }
    LYCloseInput(f);

    return count;
}
@


1.7
log
@automatic merge
@
text
@d229 1
a229 1
static int ExitWithError(char *txt);
d239 2
a240 1
    s2 = malloc(strlen(s) * 2 + 1);	/* absolute max, if all % signs */
d349 2
a350 1
	    rawentry = realloc(rawentry, rawentryalloc);
d933 1
a933 1
static int ExitWithError(char *txt)
@


1.6
log
@automatic merge of lynx-current
@
text
@d62 1
a62 1
	if (XLoadImageCommand && *XLoadImageCommand) {
d244 1
a244 1
    while (s && *s) {
d414 1
a414 1
	if (arg && *arg) {
d1096 3
a1099 1

@


1.5
log
@pretty much automatic merge of Lynx update
now, we live in an ANSI C world...
@
text
@d2 2
a3 2
**		----------------------------------------
*/
d6 2
a7 2
**	------------------------------------------------
*/
d23 1
a23 1
#include <HTSaveToFile.h>  /* LJM */
d31 11
a41 2
static int HTLoadTypesConfigFile (char *fn);
static int HTLoadExtensionsConfigFile (char *fn);
d43 7
a49 1
void HTFormatInit (void)
d51 2
d54 5
a58 5
  HTSetPresentation("application/postscript",   "open %s", 1.0, 2.0, 0.0, 0);
  HTSetPresentation("image/x-tiff",             "open %s", 2.0, 2.0, 0.0, 0);
  HTSetPresentation("image/tiff",               "open %s", 1.0, 2.0, 0.0, 0);
  HTSetPresentation("audio/basic",              "open %s", 1.0, 2.0, 0.0, 0);
  HTSetPresentation("*",                        "open %s", 1.0, 0.0, 0.0, 0);
d60 14
a73 15
 if (LYgetXDisplay() != 0) {	/* Must have X11 */
  HTSetPresentation("application/postscript", "ghostview %s&",
							    1.0, 3.0, 0.0, 0);
  if (XLoadImageCommand && *XLoadImageCommand) {
      HTSetPresentation("image/gif",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbm",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbitmap",XLoadImageCommand,1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-png",	XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/png",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-rgb",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-tiff", XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/tiff",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/jpeg",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  }
  HTSetPresentation("video/mpeg",       "mpeg_play %s &",   1.0, 3.0, 0.0, 0);
d75 4
a78 1
 }
d82 1
a82 1
 /* set quality to 999.0 for protected exec applications */
d84 3
a86 3
 HTSetPresentation("application/x-csh", "csh %s", 999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-sh",  "sh %s",  999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-ksh", "ksh %s", 999.0, 3.0, 0.0, 0);
d88 1
a88 1
 HTSetPresentation("application/x-VMS_script",	"@@%s", 999.0, 3.0, 0.0, 0);
d92 83
a174 13
/*
 *  Add our header handlers.
 */
 HTSetConversion("message/x-http-redirection", "*",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/present",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/debug",
					     HTMIMERedirect, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/present",  HTMIMEConvert, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/download", HTMIMEConvert, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/source",   HTMIMEConvert, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/dump",     HTMIMEConvert, 1.0, 0.0, 0.0, 0);
d176 6
a181 48
/*
 *  Add our compressed file handlers.
 */
 HTSetConversion("www/compressed", "www/download",
					      HTCompressed,   1.0, 0.0, 0.0, 0);
 HTSetConversion("www/compressed", "www/present",
					      HTCompressed,   1.0, 0.0, 0.0, 0);
 HTSetConversion("www/compressed", "www/source",
					      HTCompressed,   1.0, 0.0, 0.0, 0);
 HTSetConversion("www/compressed", "www/dump",
					      HTCompressed,   1.0, 0.0, 0.0, 0);

 /*
  * Added the following to support some content types beginning to surface.
  */
 HTSetConversion("application/html", "text/x-c",
					HTMLToC,	0.5, 0.0, 0.0, 0);
 HTSetConversion("application/html", "text/plain",
					HTMLToPlain,	0.5, 0.0, 0.0, 0);
 HTSetConversion("application/html", "www/present",
					HTMLPresent,	2.0, 0.0, 0.0, 0);
 HTSetConversion("application/html", "www/source",
					HTPlainPresent,	1.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/source",
					HTPlainPresent,	1.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/present",
				        HTWSRCConvert,	2.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/download",
					HTWSRCConvert,	1.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/dump",
					HTWSRCConvert,	1.0, 0.0, 0.0, 0);

 /*
  *  Save all unknown mime types to disk.
  */
 HTSetConversion("www/source",  "www/present",
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
 HTSetConversion("www/source",  "www/source",
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
 HTSetConversion("www/source",  "www/download",
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
 HTSetConversion("www/source",  "*",	HTSaveToFile,	1.0, 3.0, 0.0, 0);

 /*
  *  Output all www/dump presentations to stdout.
  */
 HTSetConversion("www/source",  "www/dump",
					HTDumpToStdout,	1.0, 3.0, 0.0, 0);
d183 6
a188 52
/*
 *  Now add our basic conversions.
 */
 HTSetConversion("text/x-sgml",
			      "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/x-sgml",
			      "www/present", HTMLPresent,    2.0, 0.0, 0.0, 0);
 HTSetConversion("text/sgml", "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/sgml", "www/present", HTMLPresent,    1.0, 0.0, 0.0, 0);
 HTSetConversion("text/plain","www/present", HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/plain","www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/html", "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/html", "text/x-c",    HTMLToC,	     0.5, 0.0, 0.0, 0);
 HTSetConversion("text/html", "text/plain",  HTMLToPlain,    0.5, 0.0, 0.0, 0);
 HTSetConversion("text/html", "www/present", HTMLPresent,    1.0, 0.0, 0.0, 0);

 /*
  *  These should override the default types as necessary.
  */
 HTLoadTypesConfigFile(global_type_map);

 /*
  *  Load the local maps.
  */
 if (LYCanReadFile(personal_type_map)) {
     /* These should override everything else. */
     HTLoadTypesConfigFile(personal_type_map);
 } else {
     char buffer[LY_MAXPATH];
     LYAddPathToHome(buffer, sizeof(buffer), personal_type_map);
     HTLoadTypesConfigFile(buffer);
 }

 /*
  *  Put text/html and text/plain at beginning of list. - kw
  */
 HTReorderPresentation(WWW_PLAINTEXT, WWW_PRESENT);
 HTReorderPresentation(WWW_HTML, WWW_PRESENT);

 /*
  * Analyze the list, and set 'get_accept' for those whose representations
  * are not redundant.
  */
 HTFilterPresentations();
}

void HTPreparsedFormatInit (void)
{
 if (LYPreparsedSource) {
     HTSetConversion("text/html", "www/source", HTMLParsedPresent, 1.0, 0.0, 0.0, 0);
     HTSetConversion("text/html", "www/dump",	HTMLParsedPresent, 1.0, 0.0, 0.0, 0);
 }
d224 1
d229 2
d232 1
a232 8
static int ExitWithError (char *txt);
static int PassesTest (struct MailcapEntry *mc);

#define LINE_BUF_SIZE		2048

static char *GetCommand (
	char *		s,
	char **	t)
d239 1
a239 1
    s2 = malloc(strlen(s)*2 + 1); /* absolute max, if all % signs */
d246 2
a247 1
	    if (*s == '%') *s2++ = '%'; /* Quote through next level, ugh! */
d254 1
a254 1
		return(++s);
d265 1
a265 1
    return(NULL);
d269 1
a269 2
static char *Cleanse (
	char *		s)
d274 1
a274 1
    return(s);
d277 54
a330 3
static int ProcessMailcapEntry (
	FILE *			fp,
	struct MailcapEntry *	mc)
d336 1
a336 1
    rawentry = (char *)malloc(rawentryalloc);
d350 1
a350 1
	        ExitWithError(MEMORY_EXHAUSTED_ABORT);
d352 2
a353 2
	if (len > 0 && LineBuf[len-1] == '\\') {
	    LineBuf[len-1] = '\0';
d366 1
a366 1
	return(0);
d370 3
a372 2
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		    rawentry));
d374 1
a374 1
	return(0);
d382 1
a382 1
		    rawentry));
d384 1
a384 1
	return(0);
d423 1
d425 1
a425 1
			    mc->testcommand));
d427 1
a427 1
		mc->label = eq;
d429 1
a429 1
		mc->label = eq; /* bogus old name for description */
d431 1
a431 1
		mc->printcommand = eq;
d436 1
a436 1
	        mc->quality = (float)atof(eq);
d440 1
a440 1
	        mc->maxbytes = atol(eq);
d443 1
a443 1
	    } else if (strcmp(arg, "notes")) { /* IGNORE notes field */
d445 3
a447 2
		    CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			        arg));
d455 1
a455 1
assign_presentation:
d460 6
a465 3
		    mc->contenttype, mc->command));
	HTSetPresentation(mc->contenttype, mc->command,
			  mc->quality, 3.0, 0.0, mc->maxbytes);
d468 1
d471 123
a593 1
    return(1);
d596 5
a600 6
static void BuildCommand (
	char **	pBuf,
	size_t		Bufsize,
	char *		controlstring,
	char *		TmpFileName,
	size_t		TmpFileLen)
d602 3
a604 1
    char *from, *to;
d606 1
d608 6
a613 2
    for (from = controlstring, to = *pBuf; *from != '\0'; from++) {
	if (prefixed) {
d615 13
a627 3
	    switch(*from) {
		case '%':
		    *to++ = '%';
d629 77
a705 15
		case 'n':
		    /* FALLTHRU */
		case 'F':
		    CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
				controlstring));
		    /* FALLTHRU */
		case 's':
		    if (TmpFileLen && TmpFileName) {
			if ((to - *pBuf) + TmpFileLen + 1 > Bufsize) {
			    *to = '\0';
			    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
			    CTRACE((tfp, "              ignoring: %s%s...\n",
					*pBuf, TmpFileName));
			    **pBuf = '\0';
			    return;
d707 3
a709 2
			strcpy(to, TmpFileName);
			to += strlen(TmpFileName);
d711 1
d713 5
a717 3
		default:
		    CTRACE((tfp,
  "BuildCommand: Ignoring unrecognized format code in mailcap file '%%%c'.\n",
d719 1
a719 1
		    break;
d724 1
a724 1
	    *to++ = *from;
d726 37
a762 7
	if (to >= *pBuf + Bufsize) {
	    (*pBuf)[Bufsize - 1] = '\0';
	    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
	    CTRACE((tfp, "              ignoring: %s...\n",
			*pBuf));
	    **pBuf = '\0';
	    return;
d765 19
a783 1
    *to = '\0';
d790 1
a790 4
static int RememberTestResult (
	int		mode,
	char *		cmd,
	int		result)
d800 6
a805 21
    switch(mode) {
	case RTR_forget:
	    while(cmdlist) {
		cur = cmdlist->next;
		FREE(cmdlist->cmd);
		FREE(cmdlist);
		cmdlist = cur;
	    }
	    break;
	case RTR_lookup:
	    for(cur = cmdlist; cur; cur = cur->next)
		if(!strcmp(cmd, cur->cmd))
		    return cur->result;
	    return -1;
	case RTR_add:
	    cur = typecalloc(struct cmdlist_s);
	    if (cur == NULL)
		outofmem(__FILE__, "RememberTestResult");
	    cur->next = cmdlist;
	    StrAllocCopy(cur->cmd, cmd);
	    cur->result = result;
d807 17
a823 1
	    break;
d828 4
a831 2
static int PassesTest (
	struct MailcapEntry *	mc)
a833 1
    char *cmd, TmpFileName[LY_MAXPATH];
d839 1
a839 1
	return(1);
d844 3
a846 3
    if (0 == strcmp(mc->testcommand, "test \"$DISPLAY\"") ||
	0 == strcmp(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	0 == strcasecomp(mc->testcommand, "test -n \"$DISPLAY\"")) {
d851 1
a851 1
	    return(0 == 0);
d854 1
a854 1
	    return(-1 == 0);
d857 1
a857 1
    if (0 == strcasecomp(mc->testcommand, "test -z \"$DISPLAY\"")) {
d861 2
a862 2
	    CTRACE((tfp,"PassesTest: Test passed!\n"));
	    return(0 == 0);
d864 2
a865 2
	    CTRACE((tfp,"PassesTest: Test failed!\n"));
	    return(-1 == 0);
d872 1
a872 1
    if (0 == strcasecomp(mc->testcommand, "test -n \"$LYNX_VERSION\"")){
d876 1
a876 1
	return(0 == 0);
d878 4
a881 4
    /*
     *  ... or failure for this one! - FM
     */
    if (0 == strcasecomp(mc->testcommand, "test -z \"$LYNX_VERSION\"")) {
d885 1
a885 1
	return(-1 == 0);
d889 2
a890 23
    if(result == -1) {
	/*
	 *  Build the command and execute it.
	 */
	if (strchr(mc->testcommand, '%')) {
	    if (LYOpenTemp(TmpFileName, HTML_SUFFIX, "w") == 0)
		ExitWithError(CANNOT_OPEN_TEMP);
	    LYCloseTemp(TmpFileName);
	} else {
	    /* We normally don't need a temp file name - kw */
	    TmpFileName[0] = '\0';
	}
	cmd = (char *)malloc(1024);
	if (!cmd)
	    ExitWithError(MEMORY_EXHAUSTED_ABORT);
	BuildCommand(&cmd, 1024,
		     mc->testcommand,
		     TmpFileName,
		     strlen(TmpFileName));
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", cmd));
	result = LYSystem(cmd);
	FREE(cmd);
	LYRemoveTemp(TmpFileName);
d898 2
a899 1
    FREE(mc->testcommand);
d901 4
a904 4
    if (result) {
	CTRACE((tfp,"PassesTest: Test failed!\n"));
    } else {
	CTRACE((tfp,"PassesTest: Test passed!\n"));
d907 1
a907 1
    return(result == 0);
d910 1
a910 2
static int ProcessMailcapFile (
	char *		file)
d916 1
a916 1
		file));
d919 2
a920 2
		    file));
	return(-1 == 0);
d924 1
a924 1
	ProcessMailcapEntry(fp, &mc);
d928 1
a928 1
    return(0 == 0);
d931 1
a931 2
static int ExitWithError (
	char *		txt)
d936 1
a936 1
    return(-1);
d944 1
a944 2
static int HTLoadTypesConfigFile (
	char *		fn)
d947 1
a947 1
    HTList * saved = HTPresentations;
d949 1
a949 1
    if (reverse_mailcap) {		/* temporarily hide existing list */
d953 1
a953 1
    result = ProcessMailcapFile(fn);
a966 3



d972 9
a980 9
**	------------------------------
**
**	The LAST suffix for a type is that used for temporary files
**	of that type.
**	The quality is an apriori bias as to whether the file should be
**	used.  Not that different suffixes can be used to represent files
**	which are of the same format but are originals or regenerated,
**	with different values.
*/
d982 24
a1005 23
 *  Additional notes: the encoding parameter may be taken into account when
 *  looking for a match; for that purpose "7bit", "8bit", and "binary" are
 *  equivalent.
 *  Use of mixed case and of pseudo MIME types with embedded spaces should
 *  be avoided.  It was once necessary for getting the fancy strings into
 *  type labels in FTP directory listings, but that can now be done with
 *  the description field (using HTSetSuffix5).  AFAIK the only effect of
 *  such "fancy" (and mostly invalid) types that cannot be reproduced by
 *  using a description fields is some statusline messages in SaveToFile
 *  (HTFWriter.c).  And showing the user an invalid MIME type as the
 *  'Content-type:' is not such a hot idea anyway, IMO.  Still, if you
 *  want it, it is still possible (even in lynx.cfg now), but use of it
 *  in the defaults below has been reduced.
 *  Case variations rely on peculiar behavior of HTAtom.c for matching.
 *  They lead to surprising behavior, Lynx retains the case of a string
 *  in the form first encountered after starting up.  So while later suffix
 *  rules generally override or modify earlier ones, the case used for a
 *  MIME time is determined by the first suffix rule (or other occurrence).
 *  Matching in HTAtom_for is effectively case insensitive, except for the
 *  first character of the string which is treated as case-sensitive by the
 *  hash function there; best not to rely on that, rather convert MIME types
 *  to lowercase on input as is already done in most places (And HTAtom could
 *  become consistently case-sensitive, as in newer W3C libwww).
d1008 1
a1008 1
void HTFileInit (void)
d1011 2
a1012 7
    if (LYUseBuiltinSuffixes)
    {
    CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));

    /* default suffix interpretation */
    HTSetSuffix("*",		"text/plain", "8bit", 1.0);
    HTSetSuffix("*.*",		"text/plain", "8bit", 1.0);
d1014 3
d1019 3
a1021 3
    /*
     *  define these extensions for exec scripts.
     */
d1023 4
a1026 4
    /* for csh exec links */
    HTSetSuffix(".csh",		"application/x-csh", "8bit", 0.8);
    HTSetSuffix(".sh",		"application/x-sh", "8bit", 0.8);
    HTSetSuffix(".ksh",		"application/x-ksh", "8bit", 0.8);
d1028 1
a1028 1
    HTSetSuffix(".com",		"application/x-VMS_script", "8bit", 0.8);
d1032 22
a1053 22
    /*
     *  Some of the old incarnation of the mappings is preserved
     *  and can be had by defining TRADITIONAL_SUFFIXES.  This
     *  is for some cases where I felt the old rules might be preferred
     *  by someone, for some reason.  It's not done consistently.
     *  A lot more of this stuff could probably be changed too or
     *  omitted, now that nearly the equivalent functionality is
     *  available in lynx.cfg. - kw 1999-10-12
     */
    HTSetSuffix(".saveme",	"application/x-Binary", "binary", 1.0);
    HTSetSuffix(".dump",	"application/x-Binary", "binary", 1.0);
    HTSetSuffix(".bin",		"application/x-Binary", "binary", 1.0);

    HTSetSuffix(".arc",		"application/x-Compressed", "binary", 1.0);

    HTSetSuffix(".alpha-exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".alpha_exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".AXP-exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".AXP_exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".VAX-exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".VAX_exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix5(".exe",	"application/octet-stream", "binary", "Executable", 1.0);
d1056 4
a1059 5
    HTSetSuffix(".exe.Z",	"application/x-Comp. Executable",
							     "binary", 1.0);
    HTSetSuffix(".Z",	        "application/UNIX Compressed", "binary", 1.0);
    HTSetSuffix(".tar_Z",	"application/UNIX Compr. Tar", "binary", 1.0);
    HTSetSuffix(".tar.Z",	"application/UNIX Compr. Tar", "binary", 1.0);
d1061 5
a1065 8
    HTSetSuffix5(".Z",	        "application/x-compress", "binary", "UNIX Compressed", 1.0);
    HTSetSuffix5(".Z",	        NULL, "compress",      "UNIX Compressed", 1.0);
    HTSetSuffix5(".exe.Z",	"application/octet-stream", "compress",
						       "Executable", 1.0);
    HTSetSuffix5(".tar_Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
    HTSetSuffix5(".tar.Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
d1069 3
a1071 3
    HTSetSuffix("-gz",		"application/GNU Compressed", "binary", 1.0);
    HTSetSuffix("_gz",		"application/GNU Compressed", "binary", 1.0);
    HTSetSuffix(".gz",		"application/GNU Compressed", "binary", 1.0);
d1073 2
a1074 2
    HTSetSuffix5(".tar.gz",	"application/x-tar", "binary", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".tgz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
d1076 6
a1081 6
    HTSetSuffix5("-gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("-gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		NULL, "gzip", "GNU Compressed", 1.0);
d1083 2
a1084 2
    HTSetSuffix5(".tar.gz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".tgz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
d1088 2
a1089 2
    HTSetSuffix(".src",		"application/x-WAIS-source", "8bit", 1.0);
    HTSetSuffix(".wsrc",	"application/x-WAIS-source", "8bit", 1.0);
d1091 1
a1091 1
    HTSetSuffix5(".wsrc",	"application/x-wais-source", "8bit", "WAIS-source", 1.0);
d1094 1
a1094 1
    HTSetSuffix5(".zip",	"application/zip", "binary", "Zip File", 1.0);
d1096 1
a1096 1
    HTSetSuffix(".bz2",		"application/x-bzip2", "binary", 1.0);
d1098 1
a1098 1
    HTSetSuffix(".bz2",		"application/bzip2", "binary", 1.0);
d1101 1
a1101 1
    HTSetSuffix(".uu",		"application/x-UUencoded", "8bit", 1.0);
d1103 1
a1103 1
    HTSetSuffix(".hqx",		"application/x-Binhex", "8bit", 1.0);
d1105 2
a1106 2
    HTSetSuffix(".o",		"application/x-Prog. Object", "binary", 1.0);
    HTSetSuffix(".a",		"application/x-Prog. Library", "binary", 1.0);
d1108 1
a1108 1
    HTSetSuffix5(".uu",		"application/x-uuencoded", "7bit", "UUencoded", 1.0);
d1110 1
a1110 1
    HTSetSuffix5(".hqx",	"application/mac-binhex40", "8bit", "Mac BinHex", 1.0);
d1112 3
a1114 3
    HTSetSuffix5(".o",		"application/octet-stream", "binary", "Prog. Object", 0.5);
    HTSetSuffix5(".a",		"application/octet-stream", "binary", "Prog. Library", 0.5);
    HTSetSuffix5(".so",		"application/octet-stream", "binary", "Shared Lib", 0.5);
d1117 1
a1117 1
    HTSetSuffix5(".oda",	"application/oda", "binary", "ODA", 1.0);
d1119 1
a1119 1
    HTSetSuffix5(".pdf",	"application/pdf", "binary", "PDF", 1.0);
d1121 3
a1123 3
    HTSetSuffix5(".eps",	"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ai",		"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ps",		"application/postscript", "8bit", "Postscript", 1.0);
d1125 1
a1125 1
    HTSetSuffix5(".rtf",	"application/rtf", "8bit", "RTF", 1.0);
d1127 1
a1127 1
    HTSetSuffix5(".dvi",	"application/x-dvi", "8bit", "DVI", 1.0);
d1129 1
a1129 1
    HTSetSuffix5(".hdf",	"application/x-hdf", "8bit", "HDF", 1.0);
d1131 2
a1132 2
    HTSetSuffix(".cdf",		"application/x-netcdf", "8bit", 1.0);
    HTSetSuffix(".nc",		"application/x-netcdf", "8bit", 1.0);
d1135 4
a1138 4
    HTSetSuffix(".latex",	"application/x-Latex", "8bit", 1.0);
    HTSetSuffix(".tex",		"application/x-Tex", "8bit", 1.0);
    HTSetSuffix(".texinfo",	"application/x-Texinfo", "8bit", 1.0);
    HTSetSuffix(".texi",	"application/x-Texinfo", "8bit", 1.0);
d1140 4
a1143 4
    HTSetSuffix5(".latex",	"application/x-latex", "8bit", "LaTeX", 1.0);
    HTSetSuffix5(".tex",	"text/x-tex", "8bit", "TeX", 1.0);
    HTSetSuffix5(".texinfo",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
    HTSetSuffix5(".texi",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
d1147 7
a1153 7
    HTSetSuffix(".t",		"application/x-Troff", "8bit", 1.0);
    HTSetSuffix(".tr",		"application/x-Troff", "8bit", 1.0);
    HTSetSuffix(".roff",	"application/x-Troff", "8bit", 1.0);

    HTSetSuffix(".man",		"application/x-Troff-man", "8bit", 1.0);
    HTSetSuffix(".me",		"application/x-Troff-me", "8bit", 1.0);
    HTSetSuffix(".ms",		"application/x-Troff-ms", "8bit", 1.0);
d1155 7
a1161 7
    HTSetSuffix5(".t",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".tr",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".roff",	"application/x-troff", "8bit", "Troff", 1.0);

    HTSetSuffix5(".man",	"application/x-troff-man", "8bit", "Man Page", 1.0);
    HTSetSuffix5(".me",		"application/x-troff-me", "8bit", "Troff me", 1.0);
    HTSetSuffix5(".ms",		"application/x-troff-ms", "8bit", "Troff ms", 1.0);
d1164 1
a1164 1
    HTSetSuffix(".zoo",		"application/x-Zoo File", "binary", 1.0);
d1167 13
a1179 13
    HTSetSuffix(".bak",		"application/x-VMS BAK File", "binary", 1.0);
    HTSetSuffix(".bkp",		"application/x-VMS BAK File", "binary", 1.0);
    HTSetSuffix(".bck",		"application/x-VMS BAK File", "binary", 1.0);

    HTSetSuffix5(".bkp_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bkp-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);

    HTSetSuffix5(".bkp-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bkp_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
d1181 3
a1183 3
    HTSetSuffix5(".bak",	NULL, "binary", "Backup", 0.5);
    HTSetSuffix5(".bkp",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
    HTSetSuffix5(".bck",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
d1187 6
a1192 6
    HTSetSuffix(".hlb",		"application/x-VMS Help Libr.", "binary", 1.0);
    HTSetSuffix(".olb",		"application/x-VMS Obj. Libr.", "binary", 1.0);
    HTSetSuffix(".tlb",		"application/x-VMS Text Libr.", "binary", 1.0);
    HTSetSuffix(".obj",		"application/x-VMS Prog. Obj.", "binary", 1.0);
    HTSetSuffix(".decw$book",	"application/x-DEC BookReader", "binary", 1.0);
    HTSetSuffix(".mem",		"application/x-RUNOFF-MANUAL", "8bit", 1.0);
d1194 6
a1199 6
    HTSetSuffix5(".hlb",	"application/octet-stream", "binary", "VMS Help Libr.", 1.0);
    HTSetSuffix5(".olb",	"application/octet-stream", "binary", "VMS Obj. Libr.", 1.0);
    HTSetSuffix5(".tlb",	"application/octet-stream", "binary", "VMS Text Libr.", 1.0);
    HTSetSuffix5(".obj",	"application/octet-stream", "binary", "Prog. Object", 1.0);
    HTSetSuffix5(".decw$book",	"application/octet-stream", "binary", "DEC BookReader", 1.0);
    HTSetSuffix5(".mem",	"text/x-runoff-manual", "8bit", "RUNOFF-MANUAL", 1.0);
d1202 1
a1202 1
    HTSetSuffix(".vsd",		"application/visio", "binary", 1.0);
d1204 3
a1206 3
    HTSetSuffix5(".lha",	"application/x-lha", "binary", "lha File", 1.0);
    HTSetSuffix5(".lzh",	"application/x-lzh", "binary", "lzh File", 1.0);
    HTSetSuffix5(".sea",	"application/x-sea", "binary", "sea File", 1.0);
d1208 1
a1208 1
    HTSetSuffix5(".sit",	"application/x-sit", "binary", "sit File", 1.0);
d1210 1
a1210 1
    HTSetSuffix5(".sit",	"application/x-stuffit", "binary", "StuffIt", 1.0);
d1212 2
a1213 2
    HTSetSuffix5(".dms",	"application/x-dms", "binary", "dms File", 1.0);
    HTSetSuffix5(".iff",	"application/x-iff", "binary", "iff File", 1.0);
d1215 2
a1216 2
    HTSetSuffix(".bcpio",	"application/x-bcpio", "binary", 1.0);
    HTSetSuffix(".cpio",	"application/x-cpio", "binary", 1.0);
d1219 1
a1219 1
    HTSetSuffix(".gtar",	"application/x-gtar", "binary", 1.0);
d1222 2
a1223 2
    HTSetSuffix(".shar",	"application/x-shar", "8bit", 1.0);
    HTSetSuffix(".share",	"application/x-share", "8bit", 1.0);
d1226 1
a1226 1
    HTSetSuffix(".sh",		"application/x-sh", "8bit", 1.0); /* xtra */
d1229 2
a1230 2
    HTSetSuffix(".sv4cpio",	"application/x-sv4cpio", "binary", 1.0);
    HTSetSuffix(".sv4crc",	"application/x-sv4crc", "binary", 1.0);
d1232 2
a1233 2
    HTSetSuffix5(".tar",	"application/x-tar", "binary", "Tar File", 1.0);
    HTSetSuffix(".ustar",	"application/x-ustar", "binary", 1.0);
d1235 2
a1236 2
    HTSetSuffix(".snd",		"audio/basic", "binary", 1.0);
    HTSetSuffix(".au",		"audio/basic", "binary", 1.0);
d1238 62
a1299 61
    HTSetSuffix(".aifc",	"audio/x-aiff", "binary", 1.0);
    HTSetSuffix(".aif",		"audio/x-aiff", "binary", 1.0);
    HTSetSuffix(".aiff",	"audio/x-aiff", "binary", 1.0);
    HTSetSuffix(".wav",		"audio/x-wav", "binary", 1.0);
    HTSetSuffix(".midi",	"audio/midi", "binary", 1.0);
    HTSetSuffix(".mod",		"audio/mod", "binary", 1.0);

    HTSetSuffix(".gif",		"image/gif", "binary", 1.0);
    HTSetSuffix(".ief",		"image/ief", "binary", 1.0);
    HTSetSuffix(".jfif",	"image/jpeg", "binary", 1.0); /* xtra */
    HTSetSuffix(".jfif-tbnl",	"image/jpeg", "binary", 1.0); /* xtra */
    HTSetSuffix(".jpe",		"image/jpeg", "binary", 1.0);
    HTSetSuffix(".jpg",		"image/jpeg", "binary", 1.0);
    HTSetSuffix(".jpeg",	"image/jpeg", "binary", 1.0);
    HTSetSuffix(".tif",		"image/tiff", "binary", 1.0);
    HTSetSuffix(".tiff",	"image/tiff", "binary", 1.0);
    HTSetSuffix(".ham",		"image/ham", "binary", 1.0);
    HTSetSuffix(".ras",		"image/x-cmu-rast", "binary", 1.0);
    HTSetSuffix(".pnm",		"image/x-portable-anymap", "binary", 1.0);
    HTSetSuffix(".pbm",		"image/x-portable-bitmap", "binary", 1.0);
    HTSetSuffix(".pgm",		"image/x-portable-graymap", "binary", 1.0);
    HTSetSuffix(".ppm",		"image/x-portable-pixmap", "binary", 1.0);
    HTSetSuffix(".png",		"image/png", "binary", 1.0);
    HTSetSuffix(".rgb",		"image/x-rgb", "binary", 1.0);
    HTSetSuffix(".xbm",		"image/x-xbitmap", "binary", 1.0);
    HTSetSuffix(".xpm",		"image/x-xpixmap", "binary", 1.0);
    HTSetSuffix(".xwd",		"image/x-xwindowdump", "binary", 1.0);

    HTSetSuffix(".rtx",		"text/richtext", "8bit", 1.0);
    HTSetSuffix(".tsv",		"text/tab-separated-values", "8bit", 1.0);
    HTSetSuffix(".etx",		"text/x-setext", "8bit", 1.0);

    HTSetSuffix(".mpg",		"video/mpeg", "binary", 1.0);
    HTSetSuffix(".mpe",		"video/mpeg", "binary", 1.0);
    HTSetSuffix(".mpeg",	"video/mpeg", "binary", 1.0);
    HTSetSuffix(".mov",		"video/quicktime", "binary", 1.0);
    HTSetSuffix(".qt",		"video/quicktime", "binary", 1.0);
    HTSetSuffix(".avi",		"video/x-msvideo", "binary", 1.0);
    HTSetSuffix(".movie",	"video/x-sgi-movie", "binary", 1.0);
    HTSetSuffix(".mv",		"video/x-sgi-movie", "binary", 1.0);

    HTSetSuffix(".mime",	"message/rfc822", "8bit", 1.0);

    HTSetSuffix(".c",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".cc",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".c++",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".h",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".pl",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".text",	"text/plain", "8bit", 1.0);
    HTSetSuffix(".txt",		"text/plain", "8bit", 1.0);

    HTSetSuffix(".php",		"text/html", "8bit", 1.0);
    HTSetSuffix(".php3",	"text/html", "8bit", 1.0);
    HTSetSuffix(".html3",	"text/html", "8bit", 1.0);
    HTSetSuffix(".ht3",		"text/html", "8bit", 1.0);
    HTSetSuffix(".phtml",	"text/html", "8bit", 1.0);
    HTSetSuffix(".shtml",	"text/html", "8bit", 1.0);
    HTSetSuffix(".sht",		"text/html", "8bit", 1.0);
    HTSetSuffix(".htmlx",	"text/html", "8bit", 1.0);
    HTSetSuffix(".htm",		"text/html", "8bit", 1.0);
    HTSetSuffix(".html",	"text/html", "8bit", 1.0);
d1301 10
a1310 9
    } else { /* LYSuffixRules */
    /*
     *  Note that even .html -> text/html, .htm -> text/html are omitted
     *  if default maps are compiled in but then skipped because of a
     *  configuration file directive.  Whoever changes the config file
     *  in this way can easily also add the SUFFIX rules there. - kw
     */
    CTRACE((tfp, "HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    } /* LYSuffixRules */
d1314 2
a1315 1
    CTRACE((tfp, "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
d1317 4
a1320 5
     *  The followin two are still used if BUILTIN_SUFFIX_MAPS was
     *  undefined.  Without one of them, lynx would always need to
     *  have a mapping specified in a lynx.cfg or mime.types file
     *  to be usable for local HTML files at all.  That includes
     *  many of the generated user interface pages. - kw
d1322 2
a1323 2
    HTSetSuffix(".htm",		"text/html", "8bit", 1.0);
    HTSetSuffix(".html",	"text/html", "8bit", 1.0);
a1325 1

d1334 1
a1340 1

d1352 1
a1352 4
static int HTGetLine (
	char *		s,
	int		n,
	FILE *		f)
d1357 1
a1357 1
	return(1);
d1361 1
a1361 1
	s[i] = (char)r;
d1371 1
a1371 1
	if ((r == EOF) || (s[i] == LF) || (s[i] == CR) || (i == (n-1))) {
d1379 1
a1379 5
static void HTGetWord (
	char *		word,
	char *		line,
	char 		stop,
	char 		stop2)
d1390 1
a1390 1
    y=0;
d1392 1
a1392 2
    while ((line[y++] = line[x++]))
	;
d1397 1
a1397 2
static int HTLoadExtensionsConfigFile (
	char *		fn)
d1412 1
a1412 1
    while (!(HTGetLine(line,sizeof(line),f))) {
d1420 1
a1420 1
	while(line[0]) {
d1430 2
a1431 2
	        if (strstr(ct, "tex") != NULL ||
	            strstr(ct, "postscript") != NULL ||
d1435 3
a1437 3
		    HTSetSuffix (ext, ct, "8bit", 1.0);
	        else
		    HTSetSuffix (ext, ct, "binary", 1.0);
@


1.4
log
@Upgrade lynx to 2.8.5dev.17d, retaining local changes if needed
@
text
@d31 2
a32 2
PRIVATE int HTLoadTypesConfigFile PARAMS((char *fn));
PRIVATE int HTLoadExtensionsConfigFile PARAMS((char *fn));
d34 1
a34 1
PUBLIC void HTFormatInit NOARGS
d182 1
a182 1
PUBLIC void HTPreparsedFormatInit NOARGS
d228 2
a229 2
PRIVATE int ExitWithError PARAMS((char *txt));
PRIVATE int PassesTest PARAMS((struct MailcapEntry *mc));
d233 3
a235 3
PRIVATE char *GetCommand ARGS2(
	char *,		s,
	char **,	t)
d271 2
a272 2
PRIVATE char *Cleanse ARGS1(
	char *,		s)
d280 3
a282 3
PRIVATE int ProcessMailcapEntry ARGS2(
	FILE *,			fp,
	struct MailcapEntry *,	mc)
d419 6
a424 6
PRIVATE void BuildCommand ARGS5(
	char **,	pBuf,
	size_t,		Bufsize,
	char *,		controlstring,
	char *,		TmpFileName,
	size_t,		TmpFileLen)
d483 4
a486 4
PRIVATE int RememberTestResult ARGS3(
	int,		mode,
	char *,		cmd,
	int,		result)
d523 2
a524 2
PRIVATE int PassesTest ARGS1(
	struct MailcapEntry *,	mc)
d624 2
a625 2
PRIVATE int ProcessMailcapFile ARGS1(
	char *,		file)
d646 2
a647 2
PRIVATE int ExitWithError ARGS1(
	char *,		txt)
d660 2
a661 2
PRIVATE int HTLoadTypesConfigFile ARGS1(
	char *,		fn)
d727 1
a727 1
PUBLIC void HTFileInit NOARGS
d1076 4
a1079 4
PRIVATE int HTGetLine ARGS3(
	char *,		s,
	int,		n,
	FILE *,		f)
d1106 5
a1110 5
PRIVATE void HTGetWord ARGS4(
	char *,		word,
	char *,		line,
	char ,		stop,
	char ,		stop2)
d1129 2
a1130 2
PRIVATE int HTLoadExtensionsConfigFile ARGS1(
	char *,		fn)
@


1.3
log
@un-tar the file
>>> lynx2.8.5dev.16.tar.gz
from http://lynx.isc.org/current/

the following files need -kb:
- LYStyle.c
- Xsystem.c
- WWW HTMIME.c
@
text
@d45 1
a45 1
  							    1.0, 3.0, 0.0, 0);
d91 1
a91 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d93 1
a93 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d95 1
a95 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d97 1
a97 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d103 1
a103 1
 					HTMLToC,	0.5, 0.0, 0.0, 0);
d105 1
a105 1
 					HTMLToPlain,	0.5, 0.0, 0.0, 0);
d107 1
a107 1
 					HTMLPresent,	2.0, 0.0, 0.0, 0);
d109 1
a109 1
 					HTPlainPresent,	1.0, 0.0, 0.0, 0);
d123 1
a123 1
 					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d125 1
a125 1
 					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d127 1
a127 1
 					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d134 1
a134 1
 					HTDumpToStdout,	1.0, 3.0, 0.0, 0);
d140 1
a140 1
 			      "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
d142 1
a142 1
 			      "www/present", HTMLPresent,    2.0, 0.0, 0.0, 0);
d148 1
a148 1
 HTSetConversion("text/html", "text/x-c",    HTMLToC, 	     0.5, 0.0, 0.0, 0);
d420 1
a420 1
	char **, 	pBuf,
d543 1
a543 1
    	if (LYgetXDisplay() != NULL) {
d554 1
a554 1
    	if (LYgetXDisplay() == NULL) {
d778 1
a778 1
    							     "binary", 1.0);
d786 1
a786 1
    						       "Executable", 1.0);
d861 1
a861 1
    HTSetSuffix(".tex",  	"application/x-Tex", "8bit", 1.0);
d866 1
a866 1
    HTSetSuffix5(".tex",  	"text/x-tex", "8bit", "TeX", 1.0);
@


1.2
log
@remove lynx 2.8.4 patchlevel 1d
@
text
@a35 2
 FILE *fp = NULL;

d46 11
a56 9
  HTSetPresentation("image/gif",        XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-xbm",      XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-xbitmap",  XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-png",      XLoadImageCommand,  2.0, 3.0, 0.0, 0);
  HTSetPresentation("image/png",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-rgb",      XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-tiff",     XLoadImageCommand,  2.0, 3.0, 0.0, 0);
  HTSetPresentation("image/tiff",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/jpeg",       XLoadImageCommand,  1.0, 3.0, 0.0, 0);
d65 3
a67 3
 HTSetPresentation("application/x-csh",	"csh %s", 999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-sh",	"sh %s",  999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-ksh",	"ksh %s", 999.0, 3.0, 0.0, 0);
d76 6
a89 2
 HTSetConversion("www/compressed", "www/present",
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d160 1
a160 2
 if ((fp = fopen(personal_type_map,"r")) != NULL) {
     fclose(fp);
d174 6
d240 1
d284 1
a284 1
    size_t rawentryalloc = 2000, len;
d288 1
a288 1
    rawentry = (char *)malloc(1 + rawentryalloc);
d293 2
a294 1
	if (LineBuf[0] == '#')
d297 4
a300 7
	if (len == 0)
	    continue;
	if (LineBuf[len-1] == '\n')
	    LineBuf[--len] = '\0';
	if ((len + strlen(rawentry)) > rawentryalloc) {
	    rawentryalloc += 2000;
	    rawentry = realloc(rawentry, rawentryalloc+1);
d314 1
a314 1
    s = LYSkipBlanks(rawentry);
d322 2
a323 2
	CTRACE(tfp, "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		    rawentry);
d328 2
a329 2
    if (!strncasecomp(rawentry, "text/html", 9) ||
	!strncasecomp(rawentry, "text/plain", 10)) {
d332 2
a333 2
	CTRACE(tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
		    rawentry);
d346 3
a348 5
    mc->contenttype = (char *)malloc(1 + strlen(rawentry));
    if (!mc->contenttype)
	ExitWithError(MEMORY_EXHAUSTED_ABORT);
    strcpy(mc->contenttype, rawentry);
    mc->quality = 1.0;
d363 1
d374 2
a375 2
		CTRACE(tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
			    mc->testcommand);
d386 1
a386 1
	        mc->quality = atof(eq);
d388 1
a388 1
		    mc->quality = 0.001;
d395 2
a396 2
		    CTRACE(tfp, "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			        arg);
d408 2
a409 2
	CTRACE(tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
		    mc->contenttype, mc->command);
d437 1
d439 3
a441 2
		    CTRACE(tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
				controlstring);
d446 3
a448 3
			    CTRACE(tfp, "BuildCommand: Too long mailcap \"test\" clause,\n");
			    CTRACE(tfp, "              ignoring: %s%s...\n",
					*pBuf, TmpFileName);
d457 1
a457 1
		    CTRACE(tfp,
d459 1
a459 1
			*from);
d469 3
a471 3
	    CTRACE(tfp, "BuildCommand: Too long mailcap \"test\" clause,\n");
	    CTRACE(tfp, "              ignoring: %s...\n",
			*pBuf);
d511 1
a511 1
	    cur = calloc(1, sizeof(struct cmdlist_s));
d515 1
a515 5
	    cur->cmd = (char *)malloc(strlen(cmd) + 1);
	    if(cur->cmd)
		strcpy(cur->cmd, cmd);
	    else
		ExitWithError("Out of memory");
d538 3
a540 1
    if (0 == strcasecomp(mc->testcommand, "test -n \"$DISPLAY\"")) {
d542 1
a542 1
	CTRACE(tfp, "PassesTest: Testing for XWINDOWS environment.\n");
d544 1
a544 1
	    CTRACE(tfp, "PassesTest: Test passed!\n");
d547 1
a547 1
	    CTRACE(tfp, "PassesTest: Test failed!\n");
d553 1
a553 1
	CTRACE(tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n");
d555 1
a555 1
	    CTRACE(tfp,"PassesTest: Test passed!\n");
d558 1
a558 1
	    CTRACE(tfp,"PassesTest: Test failed!\n");
d568 2
a569 2
	CTRACE(tfp, "PassesTest: Testing for LYNX environment.\n");
	CTRACE(tfp, "PassesTest: Test passed!\n");
d577 2
a578 2
	CTRACE(tfp, "PassesTest: Testing for non-LYNX environment.\n");
	CTRACE(tfp, "PassesTest: Test failed!\n");
d602 1
a602 1
	CTRACE(tfp, "PassesTest: Executing test command: %s\n", cmd);
d616 1
a616 1
	CTRACE(tfp,"PassesTest: Test failed!\n");
d618 1
a618 1
	CTRACE(tfp,"PassesTest: Test passed!\n");
d630 5
a634 5
    CTRACE(tfp, "ProcessMailcapFile: Loading file '%s'.\n",
		file);
    if ((fp = fopen(file, "r")) == NULL) {
	CTRACE(tfp, "ProcessMailcapFile: Could not open '%s'.\n",
		    file);
d641 1
a641 1
    fclose(fp);
d650 2
a651 2
	fprintf(tfp, "metamail: %s\n", txt);
    exit_immediately(-1);
d655 4
a658 1
#define reverse_mailcap 1
d701 26
a726 1

d729 4
a732 1
    FILE *fp;
d734 3
a736 1
    CTRACE(tfp, "HTFileInit: Loading default (HTInit) extension maps.\n");
a737 3
    /* default suffix interpretation */
    HTSetSuffix("*",		"text/plain", "7bit", 1.0);
    HTSetSuffix("*.*",		"text/plain", "7bit", 1.0);
d753 9
a761 1

d774 1
a774 1
    HTSetSuffix(".exe",		"application/x-Executable", "binary", 1.0);
d776 1
a778 1

a779 1

d782 10
d793 1
d800 11
d812 1
d815 3
d819 1
a819 1
    HTSetSuffix(".zip",		"application/x-Zip File", "binary", 1.0);
d823 3
d832 9
d846 3
a848 3
    HTSetSuffix(".eps",		"application/Postscript", "8bit", 1.0);
    HTSetSuffix(".ai",		"application/Postscript", "8bit", 1.0);
    HTSetSuffix(".ps",		"application/Postscript", "8bit", 1.0);
d850 1
a850 1
    HTSetSuffix(".rtf",		"application/RTF", "8bit", 1.0);
d852 1
a852 1
    HTSetSuffix(".dvi",		"application/x-DVI", "8bit", 1.0);
d854 1
a854 1
    HTSetSuffix(".hdf",		"application/x-HDF", "8bit", 1.0);
d859 1
d864 6
d871 1
d879 9
d891 1
d896 14
a909 9
    HTSetSuffix(".bkp_gz",	"application/x-GNU BAK File", "binary", 1.0);
    HTSetSuffix(".bkp-gz",	"application/x-GNU BAK File", "binary", 1.0);
    HTSetSuffix(".bck_gz",	"application/x-GNU BAK File", "binary", 1.0);
    HTSetSuffix(".bck-gz",	"application/x-GNU BAK File", "binary", 1.0);

    HTSetSuffix(".bkp-Z",	"application/x-Comp. BAK File", "binary", 1.0);
    HTSetSuffix(".bkp_Z",	"application/x-Comp. BAK File", "binary", 1.0);
    HTSetSuffix(".bck-Z",	"application/x-Comp. BAK File", "binary", 1.0);
    HTSetSuffix(".bck_Z",	"application/x-Comp. BAK File", "binary", 1.0);
d911 1
d918 8
d929 10
a938 9
    HTSetSuffix(".lha",		"application/x-lha File", "binary", 1.0);
    HTSetSuffix(".lzh",		"application/x-lzh File", "binary", 1.0);

    HTSetSuffix(".sea",		"application/x-sea File", "binary", 1.0);
    HTSetSuffix(".sit",		"application/x-sit File", "binary", 1.0);

    HTSetSuffix(".dms",		"application/x-dms File", "binary", 1.0);

    HTSetSuffix(".iff",		"application/x-iff File", "binary", 1.0);
d943 1
d945 1
d950 1
d952 1
d1014 2
d1025 25
d1053 1
a1053 2
    if ((fp = fopen(personal_extension_map,"r")) != NULL) {
	fclose(fp);
d1093 1
a1093 1
		s[i] = r;
d1138 1
a1138 1
    CTRACE(tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn);
d1140 2
a1141 2
    if ((f = fopen(fn,"r")) == NULL) {
	CTRACE(tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn);
d1149 2
a1150 4
	ct = (char *)malloc(sizeof(char) * (strlen(word) + 1));
	if (!ct)
	    outofmem(__FILE__, "HTLoadExtensionsConfigFile");
	strcpy(ct,word);
d1156 1
a1156 3
		char *ext = (char *)malloc(sizeof(char) * (strlen(word)+1+1));
	        if (!ext)
	            outofmem(__FILE__, "HTLoadExtensionsConfigFile");
d1158 1
a1158 1
		sprintf(ext, ".%s", word);
d1161 1
a1161 1
		CTRACE (tfp, "SETTING SUFFIX '%s' to '%s'.\n", ext, ct);
d1178 1
a1178 1
    fclose(f);
@


1.1
log
@Initial revision
@
text
@@


1.1.2.1
log
@Lynx 2.8.6dev.10 as imported into ncvs
@
text
@d2 2
a3 2
 *		----------------------------------------
 */
d6 2
a7 2
 *	------------------------------------------------
 */
d23 1
a23 1
#include <HTSaveToFile.h>	/* LJM */
d31 2
a32 14
static int HTLoadTypesConfigFile(char *fn, AcceptMedia media);
static int HTLoadExtensionsConfigFile(char *fn);

#define SET_SUFFIX1(suffix, description, type) \
	HTSetSuffix(suffix, description, type, 1.0)

#define SET_SUFFIX5(suffix, mimetype, type, description) \
       HTSetSuffix5(suffix, mimetype, type, description, 1.0)

#define SET_PRESENT(mimetype, command, quality, delay) \
  HTSetPresentation(mimetype, command, 0, quality, delay, 0.0, 0, media)

#define SET_EXTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 3.0, 0.0, 0, mediaEXT)
d34 1
a34 4
#define SET_INTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 0.0, 0.0, 0, mediaINT)

void HTFormatInit(void)
d36 1
a36 1
    AcceptMedia media = mediaEXT;
d39 5
a43 5
    SET_PRESENT("application/postscript", "open %s", 1.0, 2.0);
    SET_PRESENT("image/x-tiff", "open %s", 2.0, 2.0);
    SET_PRESENT("image/tiff", "open %s", 1.0, 2.0);
    SET_PRESENT("audio/basic", "open %s", 1.0, 2.0);
    SET_PRESENT("*", "open %s", 1.0, 0.0);
d45 13
a57 17
    if (LYgetXDisplay() != 0) {	/* Must have X11 */
	SET_PRESENT("application/postscript", "ghostview %s&", 1.0, 3.0);
	if (non_empty(XLoadImageCommand)) {
	    /* *INDENT-OFF* */
	    SET_PRESENT("image/gif",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbm",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbitmap", XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-png",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/png",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-rgb",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-tiff",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/tiff",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/jpeg",	   XLoadImageCommand, 1.0, 3.0);
	    /* *INDENT-ON* */

	}
	SET_PRESENT("video/mpeg", "mpeg_play %s &", 1.0, 3.0);
d59 1
a59 1
    }
d63 1
a63 1
    /* set quality to 999.0 for protected exec applications */
d65 3
a67 3
    SET_PRESENT("application/x-csh", "csh %s", 999.0, 3.0);
    SET_PRESENT("application/x-sh", "sh %s", 999.0, 3.0);
    SET_PRESENT("application/x-ksh", "ksh %s", 999.0, 3.0);
d69 1
a69 1
    SET_PRESENT("application/x-VMS_script", "@@%s", 999.0, 3.0);
d73 7
a79 11
    /*
     * Add our header handlers.
     */
    media = mediaINT;
    SET_INTERNL("message/x-http-redirection", "*", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/present", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/debug", HTMIMERedirect, 1.0);
    SET_INTERNL("www/mime", "www/present", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/download", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/source", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/dump", HTMIMEConvert, 1.0);
d81 50
a130 7
    /*
     * Add our compressed file handlers.
     */
    SET_INTERNL("www/compressed", "www/download", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/present", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/source", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/dump", HTCompressed, 1.0);
d132 47
a178 77
    /*
     * Added the following to support some content types beginning to surface.
     */
    SET_INTERNL("application/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("application/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("application/html", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/xhtml+xml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/x-wais-source", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/x-wais-source", "www/present", HTWSRCConvert, 2.0);
    SET_INTERNL("application/x-wais-source", "www/download", HTWSRCConvert, 1.0);
    SET_INTERNL("application/x-wais-source", "www/dump", HTWSRCConvert, 1.0);

    /*
     * Save all unknown mime types to disk.
     */
    SET_EXTERNL("www/source", "www/present", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/source", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/download", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "*", HTSaveToFile, 1.0);

    /*
     * Output all www/dump presentations to stdout.
     */
    SET_EXTERNL("www/source", "www/dump", HTDumpToStdout, 1.0);

    /*
     * Now add our basic conversions.
     */
    SET_INTERNL("text/x-sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/x-sgml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("text/sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/sgml", "www/present", HTMLPresent, 1.0);
    SET_INTERNL("text/plain", "www/present", HTPlainPresent, 1.0);
    SET_INTERNL("text/plain", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("text/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("text/html", "www/present", HTMLPresent, 1.0);

    /*
     * These should override the default types as necessary.
     */
    HTLoadTypesConfigFile(global_type_map, mediaSYS);

    /*
     * Load the local maps.
     */
    if (LYCanReadFile(personal_type_map)) {
	/* These should override everything else. */
	HTLoadTypesConfigFile(personal_type_map, mediaUSR);
    } else {
	char buffer[LY_MAXPATH];

	LYAddPathToHome(buffer, sizeof(buffer), personal_type_map);
	HTLoadTypesConfigFile(buffer, mediaUSR);
    }

    /*
     * Put text/html and text/plain at beginning of list.  - kw
     */
    HTReorderPresentation(WWW_PLAINTEXT, WWW_PRESENT);
    HTReorderPresentation(WWW_HTML, WWW_PRESENT);

    /*
     * Analyze the list, and set 'get_accept' for those whose representations
     * are not redundant.
     */
    HTFilterPresentations();
}

void HTPreparsedFormatInit(void)
{
    if (LYPreparsedSource) {
	SET_INTERNL("text/html", "www/source", HTMLParsedPresent, 1.0);
	SET_INTERNL("text/html", "www/dump", HTMLParsedPresent, 1.0);
    }
a213 1
    char *nametemplate;
a217 2
static int ExitWithError(const char *txt);
static int PassesTest(struct MailcapEntry *mc);
d219 8
a226 1
static char *GetCommand(char *s, char **t)
a230 1
    s = LYSkipBlanks(s);
d232 1
a232 2
    s2 = typeMallocn(char, strlen(s) * 2 + 1);	/* absolute max, if all % signs */

d237 1
a237 1
    while (non_empty(s)) {
d239 1
a239 2
	    if (*s == '%')
		*s2++ = '%';	/* Quote through next level, ugh! */
d246 1
a246 1
		return (++s);
d257 1
a257 1
    return (NULL);
d261 2
a262 1
static char *Cleanse(char *s)
d267 1
a267 1
    return (s);
d270 3
a272 2
/* remove unnecessary (unquoted) blanks in a shell command */
static void TrimCommand(char *command)
d274 1
a274 53
    LYTrimTrailing(command);
#ifdef UNIX
    {
	char *s = command;
	char *d = command;
	int ch;
	int c0 = ' ';
	BOOL escape = FALSE;
	BOOL dquote = FALSE;
	BOOL squote = FALSE;

	while ((ch = *s++) != '\0') {
	    if (escape) {
		escape = FALSE;
	    } else if (squote) {
		if (ch == '\'')
		    squote = FALSE;
	    } else if (dquote) {
		if (ch == '"')
		    dquote = FALSE;
	    } else {
		switch (ch) {
		case '"':
		    dquote = TRUE;
		    break;
		case '\'':
		    squote = TRUE;
		    break;
		case '\\':
		    if (dquote)
			escape = TRUE;
		    break;
		}
	    }
	    if (!escape && !dquote && !squote) {
		if (ch == '\t')
		    ch = ' ';
		if (ch == ' ') {
		    if (c0 == ' ')
			continue;
		}
	    }
	    *d++ = ch;
	    c0 = ch;
	}
	*d = '\0';
    }
#endif
}

static int ProcessMailcapEntry(FILE *fp, struct MailcapEntry *mc, AcceptMedia media)
{
    size_t rawentryalloc = 2000, len, need;
d278 1
a278 1
    rawentry = (char *) malloc(rawentryalloc);
d283 1
a283 2
	LYTrimNewline(LineBuf);
	if (LineBuf[0] == '#' || LineBuf[0] == '\0')
d286 7
a292 5
	need = len + strlen(rawentry) + 1;
	if (need > rawentryalloc) {
	    rawentryalloc += (2000 + need);
	    rawentry = typeRealloc(char, rawentry, rawentryalloc);

d294 1
a294 1
		ExitWithError(MEMORY_EXHAUSTED_ABORT);
d296 2
a297 2
	if (len > 0 && LineBuf[len - 1] == '\\') {
	    LineBuf[len - 1] = '\0';
d306 1
a306 1
    t = s = LYSkipBlanks(rawentry);
d310 1
a310 1
	return (0);
d314 2
a315 3
	CTRACE((tfp,
		"ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		rawentry));
d317 1
a317 1
	return (0);
d320 2
a321 2
    if (!strncasecomp(t, "text/html", 9) ||
	!strncasecomp(t, "text/plain", 10)) {
d324 2
a325 2
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
		rawentry));
d327 1
a327 1
	return (0);
d338 5
a342 3
    mc->contenttype = NULL;
    StrAllocCopy(mc->contenttype, rawentry);
    mc->quality = (float) 1.0;
a356 1
	    eq = LYSkipBlanks(eq);
d358 1
a358 1
	if (non_empty(arg)) {
d367 2
a368 3
		TrimCommand(mc->testcommand);
		CTRACE((tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
			mc->testcommand));
d370 1
a370 1
		mc->label = eq;	/* ignored */
d372 1
a372 1
		mc->label = eq;	/* ignored: bogus old name for description */
d374 1
a374 1
		mc->printcommand = eq;	/* ignored */
d379 1
a379 1
		mc->quality = (float) atof(eq);
d381 1
a381 1
		    mc->quality = (float) 0.001;
d383 1
a383 1
		mc->maxbytes = atol(eq);
d386 1
a386 1
	    } else if (strcmp(arg, "notes")) {	/* IGNORE notes field */
d388 2
a389 3
		    CTRACE((tfp,
			    "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			    arg));
d397 1
a397 1
  assign_presentation:
d401 4
a404 7
	CTRACE((tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
		mc->contenttype, mc->command));
	HTSetPresentation(mc->contenttype,
			  mc->command,
			  mc->testcommand,
			  mc->quality,
			  3.0, 0.0, mc->maxbytes, media);
a406 1
    FREE(mc->testcommand);
d409 1
a409 123
    return (1);
}

#define L_CURL '{'
#define R_CURL '}'

static const char *LYSkipQuoted(const char *s)
{
    int escaped = 0;

    ++s;			/* skip first quote */
    while (*s != 0) {
	if (escaped) {
	    escaped = 0;
	} else if (*s == '\\') {
	    escaped = 1;
	} else if (*s == '"') {
	    ++s;
	    break;
	}
	++s;
    }
    return s;
}

/*
 * Note: the tspecials[] here are those defined for Content-Type header, so
 * this function is not really general-purpose.
 */
static const char *LYSkipToken(const char *s)
{
    static const char tspecials[] = "\"()<>@@,;:\\/[]?.=";

    while (*s != '\0' && !WHITE(*s) && strchr(tspecials, *s) == 0) {
	++s;
    }
    return s;
}

static const char *LYSkipValue(const char *s)
{
    if (*s == '"')
	s = LYSkipQuoted(s);
    else
	s = LYSkipToken(s);
    return s;
}

/*
 * Copy the value from the source, dequoting if needed.
 */
static char *LYCopyValue(const char *s)
{
    const char *t;
    char *result = 0;
    int j, k;

    if (*s == '"') {
	t = LYSkipQuoted(s);
	StrAllocCopy(result, s + 1);
	result[t - s - 2] = '\0';
	for (j = k = 0;; ++j, ++k) {
	    if (result[j] == '\\') {
		++j;
	    }
	    if ((result[k] = result[j]) == '\0')
		break;
	}
    } else {
	t = LYSkipToken(s);
	StrAllocCopy(result, s);
	result[t - s] = '\0';
    }
    return result;
}

/*
 * The "Content-Type:" field, contains zero or more parameters after a ';'.
 * Return the value of the named parameter, or null.
 */
static char *LYGetContentType(const char *name,
			      const char *params)
{
    char *result = 0;

    if (params != 0) {
	if (name != 0) {
	    size_t length = strlen(name);
	    const char *test = strchr(params, ';');	/* skip type/subtype */
	    const char *next;

	    while (test != 0) {
		BOOL found = FALSE;

		++test;		/* skip the ';' */
		test = LYSkipCBlanks(test);
		next = LYSkipToken(test);
		if ((next - test) == (int) length
		    && !strncmp(test, name, length)) {
		    found = TRUE;
		}
		test = LYSkipCBlanks(next);
		if (*test == '=') {
		    ++test;
		    test = LYSkipCBlanks(test);
		    if (found) {
			result = LYCopyValue(test);
			break;
		    } else {
			test = LYSkipValue(test);
		    }
		    test = LYSkipCBlanks(test);
		}
		if (*test != ';') {
		    break;	/* we're lost */
		}
	    }
	} else {		/* return the content-type */
	    StrAllocCopy(result, params);
	    *LYSkipNonBlanks(result) = '\0';
	}
    }
    return result;
d412 6
a417 5
/*
 * Check if the command uses a "%s" substitution.  We need to know this, to
 * decide when to create temporary files, etc.
 */
BOOL LYMailcapUsesPctS(const char *controlstring)
d419 1
a419 3
    int result = FALSE;
    const char *from;
    const char *next;
a420 1
    int escaped = 0;
d422 2
a423 6
    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	} else if (*from == '\\') {
	    escaped = 1;
	} else if (prefixed) {
d425 3
a427 13
	    switch (*from) {
	    case '%':		/* not defined */
	    case 'n':
	    case 'F':
	    case 't':
		break;
	    case 's':
		result = TRUE;
		break;
	    case L_CURL:
		next = strchr(from, R_CURL);
		if (next != 0) {
		    from = next;
d429 13
a441 77
		}
		/* FALLTHRU */
	    default:
		break;
	    }
	} else if (*from == '%') {
	    prefixed = 1;
	}
    }
    return result;
}

/*
 * Build the command string for testing or executing a mailcap entry.
 * If a substitution from the Content-Type header is requested but no
 * parameters are available, return -1, otherwise 0.
 *
 * This does not support multipart %n or %F (does this apply to lynx?)
 */
static int BuildCommand(HTChunk *cmd,
			const char *controlstring,
			const char *TmpFileName,
			const char *params)
{
    int result = 0;
    size_t TmpFileLen = strlen(TmpFileName);
    const char *from;
    const char *next;
    char *name, *value;
    int prefixed = 0;
    int escaped = 0;

    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	    HTChunkPutc(cmd, *from);
	} else if (*from == '\\') {
	    escaped = 1;
	} else if (prefixed) {
	    prefixed = 0;
	    switch (*from) {
	    case '%':		/* not defined */
		HTChunkPutc(cmd, *from);
		break;
	    case 'n':
		/* FALLTHRU */
	    case 'F':
		CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
			controlstring));
		break;
	    case 't':
		if ((value = LYGetContentType(NULL, params)) != 0) {
		    HTChunkPuts(cmd, value);
		    FREE(value);
		}
		break;
	    case 's':
		if (TmpFileLen && TmpFileName) {
		    HTChunkPuts(cmd, TmpFileName);
		}
		break;
	    case L_CURL:
		next = strchr(from, R_CURL);
		if (next != 0) {
		    if (params != 0) {
			++from;
			name = 0;
			HTSprintf0(&name, "%.*s", next - from, from);
			if ((value = LYGetContentType(name, params)) != 0) {
			    HTChunkPuts(cmd, value);
			    FREE(value);
			} else {
			    if (!strcmp(name, "charset")) {
				HTChunkPuts(cmd, "ISO-8859-1");
			    } else {
				CTRACE((tfp, "BuildCommand no value for %s\n", name));
			    }
d443 2
a444 3
			FREE(name);
		    } else {
			result = -1;
a445 1
		    from = next;
d447 5
a451 7
		}
		/* FALLTHRU */
	    default:
		CTRACE((tfp,
			"BuildCommand: Ignoring unrecognized format code in mailcap file '%%%c'.\n",
			*from));
		break;
d456 1
a456 1
	    HTChunkPutc(cmd, *from);
d458 7
a464 37
    }
    HTChunkTerminate(cmd);
    return result;
}

/*
 * Build the mailcap test-command and execute it.  This is only invoked when
 * we cannot tell just by looking at the command if it would succeed.
 *
 * Returns 0 for success, -1 for error and 1 for deferred.
 */
int LYTestMailcapCommand(const char *testcommand,
			 const char *params)
{
    int result;
    char TmpFileName[LY_MAXPATH];
    HTChunk *expanded = 0;

    if (LYMailcapUsesPctS(testcommand)) {
	if (LYOpenTemp(TmpFileName, HTML_SUFFIX, "w") == 0)
	    ExitWithError(CANNOT_OPEN_TEMP);
	LYCloseTemp(TmpFileName);
    } else {
	/* We normally don't need a temp file name - kw */
	TmpFileName[0] = '\0';
    }
    expanded = HTChunkCreate(1024);
    if ((result = BuildCommand(expanded, testcommand, TmpFileName, params)) != 0) {
	result = 1;
	CTRACE((tfp, "PassesTest: Deferring test command: %s\n", expanded->data));
    } else {
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", expanded->data));
	if ((result = LYSystem(expanded->data)) != 0) {
	    result = -1;
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	} else {
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
d467 1
a467 19

    HTChunkFree(expanded);
    LYRemoveTemp(TmpFileName);

    return result;
}

char *LYMakeMailcapCommand(const char *command,
			   const char *params,
			   const char *filename)
{
    HTChunk *expanded = 0;
    char *result = 0;

    expanded = HTChunkCreate(1024);
    BuildCommand(expanded, command, filename, params);
    StrAllocCopy(result, expanded->data);
    HTChunkFree(expanded);
    return result;
d474 4
a477 1
static int RememberTestResult(int mode, char *cmd, int result)
d487 25
a511 6
    switch (mode) {
    case RTR_forget:
	while (cmdlist) {
	    cur = cmdlist->next;
	    FREE(cmdlist->cmd);
	    FREE(cmdlist);
d513 1
a513 17
	}
	break;
    case RTR_lookup:
	for (cur = cmdlist; cur; cur = cur->next)
	    if (!strcmp(cmd, cur->cmd))
		return cur->result;
	return -1;
    case RTR_add:
	cur = typecalloc(struct cmdlist_s);

	if (cur == NULL)
	    outofmem(__FILE__, "RememberTestResult");
	cur->next = cmdlist;
	StrAllocCopy(cur->cmd, cmd);
	cur->result = result;
	cmdlist = cur;
	break;
d518 2
a519 4
/* FIXME: this sometimes used caseless comparison, e.g., strcasecomp */
#define SameCommand(tst,ref) !strcmp(tst,ref)

static int PassesTest(struct MailcapEntry *mc)
d522 1
d528 1
a528 1
	return (1);
d533 1
a533 3
    if (SameCommand(mc->testcommand, "test \"$DISPLAY\"") ||
	SameCommand(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	SameCommand(mc->testcommand, "test -n \"$DISPLAY\"")) {
d535 4
a538 4
	CTRACE((tfp, "PassesTest: Testing for XWINDOWS environment.\n"));
	if (LYgetXDisplay() != NULL) {
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
	    return (0 == 0);
d540 2
a541 2
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	    return (-1 == 0);
d544 1
a544 1
    if (SameCommand(mc->testcommand, "test -z \"$DISPLAY\"")) {
d546 4
a549 4
	CTRACE((tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n"));
	if (LYgetXDisplay() == NULL) {
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
	    return (0 == 0);
d551 2
a552 2
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	    return (-1 == 0);
d559 1
a559 1
    if (SameCommand(mc->testcommand, "test -n \"$LYNX_VERSION\"")) {
d561 3
a563 3
	CTRACE((tfp, "PassesTest: Testing for LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test passed!\n"));
	return (0 == 0);
d565 4
a568 4
	/*
	 *  ... or failure for this one! - FM
	 */
    if (SameCommand(mc->testcommand, "test -z \"$LYNX_VERSION\"")) {
d570 3
a572 3
	CTRACE((tfp, "PassesTest: Testing for non-LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test failed!\n"));
	return (-1 == 0);
d576 23
a598 2
    if (result == -1) {
	result = LYTestMailcapCommand(mc->testcommand, NULL);
d606 1
a606 2
    if (result != 1)
	FREE(mc->testcommand);
d608 4
a611 4
    if (result < 0) {
	CTRACE((tfp, "PassesTest: Test failed!\n"));
    } else if (result == 0) {
	CTRACE((tfp, "PassesTest: Test passed!\n"));
d614 1
a614 1
    return (result >= 0);
d617 2
a618 1
static int ProcessMailcapFile(char *file, AcceptMedia media)
d623 6
a628 6
    CTRACE((tfp, "ProcessMailcapFile: Loading file '%s'.\n",
	    file));
    if ((fp = fopen(file, TXT_R)) == NULL) {
	CTRACE((tfp, "ProcessMailcapFile: Could not open '%s'.\n",
		file));
	return (-1 == 0);
d632 1
a632 1
	ProcessMailcapEntry(fp, &mc, media);
d634 1
a634 1
    LYCloseInput(fp);
d636 1
a636 1
    return (0 == 0);
d639 2
a640 1
static int ExitWithError(const char *txt)
d643 3
a645 3
	fprintf(tfp, "Lynx: %s\n", txt);
    exit_immediately(EXIT_FAILURE);
    return (-1);
d648 1
a648 4
/* Reverse the entries from each mailcap after it has been read, so that
 * earlier entries have precedence.  Set to 0 to get traditional lynx
 * behavior, which means that the last match wins. - kw */
static int reverse_mailcap = 1;
d650 2
a651 1
static int HTLoadTypesConfigFile(char *fn, AcceptMedia media)
d654 1
a654 1
    HTList *saved = HTPresentations;
d656 1
a656 1
    if (reverse_mailcap) {	/* temporarily hide existing list */
d660 1
a660 1
    result = ProcessMailcapFile(fn, media);
d674 3
d682 11
a692 37
 *	------------------------------
 *
 *	The LAST suffix for a type is that used for temporary files
 *	of that type.
 *	The quality is an apriori bias as to whether the file should be
 *	used.  Not that different suffixes can be used to represent files
 *	which are of the same format but are originals or regenerated,
 *	with different values.
 */
/*
 * Additional notes:  the encoding parameter may be taken into account when
 * looking for a match; for that purpose "7bit", "8bit", and "binary" are
 * equivalent.
 *
 * Use of mixed case and of pseudo MIME types with embedded spaces should be
 * avoided.  It was once necessary for getting the fancy strings into type
 * labels in FTP directory listings, but that can now be done with the
 * description field (using HTSetSuffix5).  AFAIK the only effect of such
 * "fancy" (and mostly invalid) types that cannot be reproduced by using a
 * description fields is some statusline messages in SaveToFile (HTFWriter.c). 
 * And showing the user an invalid MIME type as the 'Content-type:' is not such
 * a hot idea anyway, IMO.  Still, if you want it, it is still possible (even
 * in lynx.cfg now), but use of it in the defaults below has been reduced.
 *
 * Case variations rely on peculiar behavior of HTAtom.c for matching.  They
 * lead to surprising behavior, Lynx retains the case of a string in the form
 * first encountered after starting up.  So while later suffix rules generally
 * override or modify earlier ones, the case used for a MIME time is determined
 * by the first suffix rule (or other occurrence).  Matching in HTAtom_for is
 * effectively case insensitive, except for the first character of the string
 * which is treated as case-sensitive by the hash function there; best not to
 * rely on that, rather convert MIME types to lowercase on input as is already
 * done in most places (And HTAtom could become consistently case-sensitive, as
 * in newer W3C libwww).
 *  - kw 1999-10-12
 */
void HTFileInit(void)
d694 7
a700 7
#ifdef BUILTIN_SUFFIX_MAPS
    if (LYUseBuiltinSuffixes) {
	CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));

	/* default suffix interpretation */
	SET_SUFFIX1("*", "text/plain", "8bit");
	SET_SUFFIX1("*.*", "text/plain", "8bit");
d703 3
a705 3
	/*
	 * define these extensions for exec scripts.
	 */
d707 4
a710 4
	/* for csh exec links */
	HTSetSuffix(".csh", "application/x-csh", "8bit", 0.8);
	HTSetSuffix(".sh", "application/x-sh", "8bit", 0.8);
	HTSetSuffix(".ksh", "application/x-ksh", "8bit", 0.8);
d712 1
a712 1
	HTSetSuffix(".com", "application/x-VMS_script", "8bit", 0.8);
a715 35
	/*
	 * Some of the old incarnation of the mappings is preserved and can be had
	 * by defining TRADITIONAL_SUFFIXES.  This is for some cases where I felt
	 * the old rules might be preferred by someone, for some reason.  It's not
	 * done consistently.  A lot more of this stuff could probably be changed
	 * too or omitted, now that nearly the equivalent functionality is
	 * available in lynx.cfg.  - kw 1999-10-12
	 */
	/* *INDENT-OFF* */
	SET_SUFFIX1(".saveme",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".dump",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".bin",	"application/x-Binary",		"binary");

	SET_SUFFIX1(".arc",	"application/x-Compressed",	"binary");

	SET_SUFFIX1(".alpha-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".alpha_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX_exe", "application/x-Executable",	"binary");
	SET_SUFFIX5(".exe",	"application/octet-stream",	"binary", "Executable");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".exe.Z",	"application/x-Comp. Executable", "binary");
	SET_SUFFIX1(".Z",	"application/UNIX Compressed",	"binary");
	SET_SUFFIX1(".tar_Z",	"application/UNIX Compr. Tar",	"binary");
	SET_SUFFIX1(".tar.Z",	"application/UNIX Compr. Tar",	"binary");
#else
	SET_SUFFIX5(".Z",	"application/x-compress",	"binary", "UNIX Compressed");
	SET_SUFFIX5(".Z",	NULL,				"compress", "UNIX Compressed");
	SET_SUFFIX5(".exe.Z",	"application/octet-stream",	"compress", "Executable");
	SET_SUFFIX5(".tar_Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
	SET_SUFFIX5(".tar.Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
#endif
d717 37
a753 4
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1("-gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1("_gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1(".gz",	"application/GNU Compressed",	"binary");
d755 1
a755 9
	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"binary", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
#else
	SET_SUFFIX5("-gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("_gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5(".gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("-gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5("_gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5(".gz",	NULL,				"gzip", "GNU Compressed");
d757 2
a758 3
	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
#endif
d760 1
a760 6
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".src",	"application/x-WAIS-source",	"8bit");
	SET_SUFFIX1(".wsrc",	"application/x-WAIS-source",	"8bit");
#else
	SET_SUFFIX5(".wsrc",	"application/x-wais-source",	"8bit", "WAIS-source");
#endif
d762 1
a762 1
	SET_SUFFIX5(".zip",	"application/zip",		"binary", "Zip File");
d764 3
a766 2
	SET_SUFFIX1(".zz",	"application/x-deflate",	"binary");
	SET_SUFFIX1(".zz",	"application/deflate",		"binary");
d768 1
a768 2
	SET_SUFFIX1(".bz2",	"application/x-bzip2",		"binary");
	SET_SUFFIX1(".bz2",	"application/bzip2",		"binary");
d770 1
a770 2
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".uu",	"application/x-UUencoded",	"8bit");
d772 1
a772 1
	SET_SUFFIX1(".hqx",	"application/x-Binhex",		"8bit");
d774 2
a775 4
	SET_SUFFIX1(".o",	"application/x-Prog. Object",	"binary");
	SET_SUFFIX1(".a",	"application/x-Prog. Library",	"binary");
#else
	SET_SUFFIX5(".uu",	"application/x-uuencoded",	"7bit", "UUencoded");
d777 4
a780 1
	SET_SUFFIX5(".hqx",	"application/mac-binhex40",	"8bit", "Mac BinHex");
d782 3
a784 4
	HTSetSuffix5(".o",	"application/octet-stream",	"binary", "Prog. Object", 0.5);
	HTSetSuffix5(".a",	"application/octet-stream",	"binary", "Prog. Library", 0.5);
	HTSetSuffix5(".so",	"application/octet-stream",	"binary", "Shared Lib", 0.5);
#endif
d786 3
a788 1
	SET_SUFFIX5(".oda",	"application/oda",		"binary", "ODA");
d790 1
a790 1
	SET_SUFFIX5(".pdf",	"application/pdf",		"binary", "PDF");
d792 3
a794 3
	SET_SUFFIX5(".eps",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ai",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ps",	"application/postscript",	"8bit", "Postscript");
d796 4
a799 1
	SET_SUFFIX5(".rtf",	"application/rtf",		"8bit", "RTF");
d801 4
a804 1
	SET_SUFFIX5(".dvi",	"application/x-dvi",		"8bit", "DVI");
d806 6
a811 1
	SET_SUFFIX5(".hdf",	"application/x-hdf",		"8bit", "HDF");
d813 1
a813 2
	SET_SUFFIX1(".cdf",	"application/x-netcdf",		"8bit");
	SET_SUFFIX1(".nc",	"application/x-netcdf",		"8bit");
d815 2
a816 11
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".latex",	"application/x-Latex",		"8bit");
	SET_SUFFIX1(".tex",	"application/x-Tex",		"8bit");
	SET_SUFFIX1(".texinfo", "application/x-Texinfo",	"8bit");
	SET_SUFFIX1(".texi",	"application/x-Texinfo",	"8bit");
#else
	SET_SUFFIX5(".latex",	"application/x-latex",		"8bit", "LaTeX");
	SET_SUFFIX5(".tex",	"text/x-tex",			"8bit", "TeX");
	SET_SUFFIX5(".texinfo", "application/x-texinfo",	"8bit", "Texinfo");
	SET_SUFFIX5(".texi",	"application/x-texinfo",	"8bit", "Texinfo");
#endif
d818 2
a819 17
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".t",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".tr",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".roff",	"application/x-Troff",		"8bit");

	SET_SUFFIX1(".man",	"application/x-Troff-man",	"8bit");
	SET_SUFFIX1(".me",	"application/x-Troff-me",	"8bit");
	SET_SUFFIX1(".ms",	"application/x-Troff-ms",	"8bit");
#else
	SET_SUFFIX5(".t",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".tr",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".roff",	"application/x-troff",		"8bit", "Troff");

	SET_SUFFIX5(".man",	"application/x-troff-man",	"8bit", "Man Page");
	SET_SUFFIX5(".me",	"application/x-troff-me",	"8bit", "Troff me");
	SET_SUFFIX5(".ms",	"application/x-troff-ms",	"8bit", "Troff ms");
#endif
d821 1
a821 1
	SET_SUFFIX1(".zoo",	"application/x-Zoo File",	"binary");
d823 1
a823 19
#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
	SET_SUFFIX1(".bak",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bkp",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bck",	"application/x-VMS BAK File",	"binary");

	SET_SUFFIX5(".bkp_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bkp-gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck-gz",	"application/octet-stream",	"gzip", "GNU BAK File");

	SET_SUFFIX5(".bkp-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bkp_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
#else
	HTSetSuffix5(".bak",	NULL,				"binary", "Backup", 0.5);
	SET_SUFFIX5(".bkp",	"application/octet-stream",	"binary", "VMS BAK File");
	SET_SUFFIX5(".bck",	"application/octet-stream",	"binary", "VMS BAK File");
#endif
d825 2
a826 15
#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
	SET_SUFFIX1(".hlb",	"application/x-VMS Help Libr.", "binary");
	SET_SUFFIX1(".olb",	"application/x-VMS Obj. Libr.", "binary");
	SET_SUFFIX1(".tlb",	"application/x-VMS Text Libr.", "binary");
	SET_SUFFIX1(".obj",	"application/x-VMS Prog. Obj.", "binary");
	SET_SUFFIX1(".decw$book", "application/x-DEC BookReader", "binary");
	SET_SUFFIX1(".mem",	"application/x-RUNOFF-MANUAL", "8bit");
#else
	SET_SUFFIX5(".hlb",	"application/octet-stream",	"binary", "VMS Help Libr.");
	SET_SUFFIX5(".olb",	"application/octet-stream",	"binary", "VMS Obj. Libr.");
	SET_SUFFIX5(".tlb",	"application/octet-stream",	"binary", "VMS Text Libr.");
	SET_SUFFIX5(".obj",	"application/octet-stream",	"binary", "Prog. Object");
	SET_SUFFIX5(".decw$book", "application/octet-stream",	"binary", "DEC BookReader");
	SET_SUFFIX5(".mem",	"text/x-runoff-manual",		"8bit", "RUNOFF-MANUAL");
#endif
d828 1
a828 1
	SET_SUFFIX1(".vsd",	"application/visio",		"binary");
d830 2
a831 10
	SET_SUFFIX5(".lha",	"application/x-lha",		"binary", "lha File");
	SET_SUFFIX5(".lzh",	"application/x-lzh",		"binary", "lzh File");
	SET_SUFFIX5(".sea",	"application/x-sea",		"binary", "sea File");
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX5(".sit",	"application/x-sit",		"binary", "sit File");
#else
	SET_SUFFIX5(".sit",	"application/x-stuffit",	"binary", "StuffIt");
#endif
	SET_SUFFIX5(".dms",	"application/x-dms",		"binary", "dms File");
	SET_SUFFIX5(".iff",	"application/x-iff",		"binary", "iff File");
d833 1
a833 2
	SET_SUFFIX1(".bcpio",	"application/x-bcpio",		"binary");
	SET_SUFFIX1(".cpio",	"application/x-cpio",		"binary");
d835 2
a836 3
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".gtar",	"application/x-gtar",		"binary");
#endif
d838 2
a839 2
	SET_SUFFIX1(".shar",	"application/x-shar",		"8bit");
	SET_SUFFIX1(".share",	"application/x-share",		"8bit");
d841 2
a842 3
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".sh",	"application/x-sh",		"8bit"); /* xtra */
#endif
d844 6
a849 2
	SET_SUFFIX1(".sv4cpio", "application/x-sv4cpio",	"binary");
	SET_SUFFIX1(".sv4crc",	"application/x-sv4crc",		"binary");
d851 20
a870 2
	SET_SUFFIX5(".tar",	"application/x-tar",		"binary", "Tar File");
	SET_SUFFIX1(".ustar",	"application/x-ustar",		"binary");
d872 3
a874 2
	SET_SUFFIX1(".snd",	"audio/basic",			"binary");
	SET_SUFFIX1(".au",	"audio/basic",			"binary");
d876 8
a883 62
	SET_SUFFIX1(".aifc",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aif",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aiff",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".wav",	"audio/x-wav",			"binary");
	SET_SUFFIX1(".midi",	"audio/midi",			"binary");
	SET_SUFFIX1(".mod",	"audio/mod",			"binary");

	SET_SUFFIX1(".gif",	"image/gif",			"binary");
	SET_SUFFIX1(".ief",	"image/ief",			"binary");
	SET_SUFFIX1(".jfif",	"image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jfif-tbnl", "image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jpe",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpeg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".tif",	"image/tiff",			"binary");
	SET_SUFFIX1(".tiff",	"image/tiff",			"binary");
	SET_SUFFIX1(".ham",	"image/ham",			"binary");
	SET_SUFFIX1(".ras",	"image/x-cmu-rast",		"binary");
	SET_SUFFIX1(".pnm",	"image/x-portable-anymap",	"binary");
	SET_SUFFIX1(".pbm",	"image/x-portable-bitmap",	"binary");
	SET_SUFFIX1(".pgm",	"image/x-portable-graymap",	"binary");
	SET_SUFFIX1(".ppm",	"image/x-portable-pixmap",	"binary");
	SET_SUFFIX1(".png",	"image/png",			"binary");
	SET_SUFFIX1(".rgb",	"image/x-rgb",			"binary");
	SET_SUFFIX1(".xbm",	"image/x-xbitmap",		"binary");
	SET_SUFFIX1(".xpm",	"image/x-xpixmap",		"binary");
	SET_SUFFIX1(".xwd",	"image/x-xwindowdump",		"binary");

	SET_SUFFIX1(".rtx",	"text/richtext",		"8bit");
	SET_SUFFIX1(".tsv",	"text/tab-separated-values",	"8bit");
	SET_SUFFIX1(".etx",	"text/x-setext",		"8bit");

	SET_SUFFIX1(".mpg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpe",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpeg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mov",	"video/quicktime",		"binary");
	SET_SUFFIX1(".qt",	"video/quicktime",		"binary");
	SET_SUFFIX1(".avi",	"video/x-msvideo",		"binary");
	SET_SUFFIX1(".movie",	"video/x-sgi-movie",		"binary");
	SET_SUFFIX1(".mv",	"video/x-sgi-movie",		"binary");

	SET_SUFFIX1(".mime",	"message/rfc822",		"8bit");

	SET_SUFFIX1(".c",	"text/plain",			"8bit");
	SET_SUFFIX1(".cc",	"text/plain",			"8bit");
	SET_SUFFIX1(".c++",	"text/plain",			"8bit");
	SET_SUFFIX1(".h",	"text/plain",			"8bit");
	SET_SUFFIX1(".pl",	"text/plain",			"8bit");
	SET_SUFFIX1(".text",	"text/plain",			"8bit");
	SET_SUFFIX1(".txt",	"text/plain",			"8bit");

	SET_SUFFIX1(".php",	"text/html",			"8bit");
	SET_SUFFIX1(".php3",	"text/html",			"8bit");
	SET_SUFFIX1(".html3",	"text/html",			"8bit");
	SET_SUFFIX1(".ht3",	"text/html",			"8bit");
	SET_SUFFIX1(".phtml",	"text/html",			"8bit");
	SET_SUFFIX1(".shtml",	"text/html",			"8bit");
	SET_SUFFIX1(".sht",	"text/html",			"8bit");
	SET_SUFFIX1(".htmlx",	"text/html",			"8bit");
	SET_SUFFIX1(".htm",	"text/html",			"8bit");
	SET_SUFFIX1(".html",	"text/html",			"8bit");
	/* *INDENT-ON* */
d885 1
a885 10
    } else {			/* LYSuffixRules */
	/*
	 * Note that even .html -> text/html, .htm -> text/html are omitted if
	 * default maps are compiled in but then skipped because of a
	 * configuration file directive.  Whoever changes the config file in
	 * this way can easily also add the SUFFIX rules there.  - kw
	 */
	CTRACE((tfp,
		"HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    }				/* LYSuffixRules */
d887 7
a893 1
#else /* BUILTIN_SUFFIX_MAPS */
d895 8
a902 11
    CTRACE((tfp,
	    "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
    /*
     * The following two are still used if BUILTIN_SUFFIX_MAPS was undefined. 
     * Without one of them, lynx would always need to have a mapping specified
     * in a lynx.cfg or mime.types file to be usable for local HTML files at
     * all.  That includes many of the generated user interface pages.  - kw
     */
    SET_SUFFIX1(".htm", "text/html", "8bit");
    SET_SUFFIX1(".html", "text/html", "8bit");
#endif /* BUILTIN_SUFFIX_MAPS */
d907 2
a908 1
    if (LYCanReadFile(personal_extension_map)) {
a912 1

d919 1
d931 4
a934 1
static int HTGetLine(char *s, int n, FILE *f)
d939 1
a939 1
	return (1);
d943 1
a943 1
	s[i] = (char) r;
d948 1
a948 1
		s[i] = (char) r;
d953 1
a953 1
	if ((r == EOF) || (s[i] == LF) || (s[i] == CR) || (i == (n - 1))) {
d961 5
a965 1
static void HTGetWord(char *word, char *line, char stop, char stop2)
d976 1
a976 1
    y = 0;
d978 2
a979 1
    while ((line[y++] = line[x++])) ;
d984 2
a985 1
static int HTLoadExtensionsConfigFile(char *fn)
d993 1
a993 1
    CTRACE((tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn));
d995 2
a996 2
    if ((f = fopen(fn, TXT_R)) == NULL) {
	CTRACE((tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn));
d1000 1
a1000 1
    while (!(HTGetLine(line, sizeof(line), f))) {
d1004 4
a1007 2
	ct = NULL;
	StrAllocCopy(ct, word);
d1010 1
a1010 1
	while (line[0]) {
d1013 3
a1015 1
		char *ext = NULL;
d1017 1
a1017 1
		HTSprintf0(&ext, ".%s", word);
d1020 1
a1020 1
		CTRACE((tfp, "SETTING SUFFIX '%s' to '%s'.\n", ext, ct));
d1022 2
a1023 2
		if (strstr(ct, "tex") != NULL ||
		    strstr(ct, "postscript") != NULL ||
d1027 3
a1029 3
		    SET_SUFFIX1(ext, ct, "8bit");
		else
		    SET_SUFFIX1(ext, ct, "binary");
d1037 1
a1037 1
    LYCloseInput(f);
@


1.1.3.1
log
@Import Lynx 2.8.5.dev16 again, this time via a vendor branch (tg),
to ease tracking of the upcoming dev17 (2.8.6-prerelease) update.
@
text
@d36 2
d48 9
a56 11
  if (XLoadImageCommand && *XLoadImageCommand) {
      HTSetPresentation("image/gif",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbm",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbitmap",XLoadImageCommand,1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-png",	XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/png",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-rgb",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-tiff", XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/tiff",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/jpeg",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  }
d65 3
a67 3
 HTSetPresentation("application/x-csh", "csh %s", 999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-sh",  "sh %s",  999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-ksh", "ksh %s", 999.0, 3.0, 0.0, 0);
a75 6
 HTSetConversion("message/x-http-redirection", "*",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/present",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/debug",
					     HTMIMERedirect, 1.0, 0.0, 0.0, 0);
d84 2
d156 2
a157 1
 if (LYCanReadFile(personal_type_map)) {
a170 6

 /*
  * Analyze the list, and set 'get_accept' for those whose representations
  * are not redundant.
  */
 HTFilterPresentations();
a230 1
    s = LYSkipBlanks(s);
d274 1
a274 1
    size_t rawentryalloc = 2000, len, need;
d278 1
a278 1
    rawentry = (char *)malloc(rawentryalloc);
d283 1
a283 2
	LYTrimNewline(LineBuf);
	if (LineBuf[0] == '#' || LineBuf[0] == '\0')
d286 7
a292 4
	need = len + strlen(rawentry) + 1;
	if (need > rawentryalloc) {
	    rawentryalloc += (2000 + need);
	    rawentry = realloc(rawentry, rawentryalloc);
d306 1
a306 1
    t = s = LYSkipBlanks(rawentry);
d314 2
a315 2
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		    rawentry));
d320 2
a321 2
    if (!strncasecomp(t, "text/html", 9) ||
	!strncasecomp(t, "text/plain", 10)) {
d324 2
a325 2
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
		    rawentry));
d338 5
a342 3
    mc->contenttype = NULL;
    StrAllocCopy(mc->contenttype, rawentry);
    mc->quality = (float) 1.0;
a356 1
	    eq = LYSkipBlanks(eq);
d367 2
a368 2
		CTRACE((tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
			    mc->testcommand));
d379 1
a379 1
	        mc->quality = (float)atof(eq);
d381 1
a381 1
		    mc->quality = (float) 0.001;
d388 2
a389 2
		    CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			        arg));
d401 2
a402 2
	CTRACE((tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
		    mc->contenttype, mc->command));
a429 1
		    /* FALLTHRU */
d431 2
a432 3
		    CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
				controlstring));
		    /* FALLTHRU */
d437 3
a439 3
			    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
			    CTRACE((tfp, "              ignoring: %s%s...\n",
					*pBuf, TmpFileName));
d448 1
a448 1
		    CTRACE((tfp,
d450 1
a450 1
			*from));
d460 3
a462 3
	    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
	    CTRACE((tfp, "              ignoring: %s...\n",
			*pBuf));
d502 1
a502 1
	    cur = typecalloc(struct cmdlist_s);
d506 5
a510 1
	    StrAllocCopy(cur->cmd, cmd);
d533 1
a533 3
    if (0 == strcmp(mc->testcommand, "test \"$DISPLAY\"") ||
	0 == strcmp(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	0 == strcasecomp(mc->testcommand, "test -n \"$DISPLAY\"")) {
d535 1
a535 1
	CTRACE((tfp, "PassesTest: Testing for XWINDOWS environment.\n"));
d537 1
a537 1
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
d540 1
a540 1
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
d546 1
a546 1
	CTRACE((tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n"));
d548 1
a548 1
	    CTRACE((tfp,"PassesTest: Test passed!\n"));
d551 1
a551 1
	    CTRACE((tfp,"PassesTest: Test failed!\n"));
d561 2
a562 2
	CTRACE((tfp, "PassesTest: Testing for LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test passed!\n"));
d570 2
a571 2
	CTRACE((tfp, "PassesTest: Testing for non-LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test failed!\n"));
d595 1
a595 1
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", cmd));
d609 1
a609 1
	CTRACE((tfp,"PassesTest: Test failed!\n"));
d611 1
a611 1
	CTRACE((tfp,"PassesTest: Test passed!\n"));
d623 5
a627 5
    CTRACE((tfp, "ProcessMailcapFile: Loading file '%s'.\n",
		file));
    if ((fp = fopen(file, TXT_R)) == NULL) {
	CTRACE((tfp, "ProcessMailcapFile: Could not open '%s'.\n",
		    file));
d634 1
a634 1
    LYCloseInput(fp);
d643 2
a644 2
	fprintf(tfp, "Lynx: %s\n", txt);
    exit_immediately(EXIT_FAILURE);
d648 1
a648 4
/* Reverse the entries from each mailcap after it has been read, so that
 * earlier entries have precedence.  Set to 0 to get traditional lynx
 * behavior, which means that the last match wins. - kw */
static int reverse_mailcap = 1;
d691 1
a691 26
/*
 *  Additional notes: the encoding parameter may be taken into account when
 *  looking for a match; for that purpose "7bit", "8bit", and "binary" are
 *  equivalent.
 *  Use of mixed case and of pseudo MIME types with embedded spaces should
 *  be avoided.  It was once necessary for getting the fancy strings into
 *  type labels in FTP directory listings, but that can now be done with
 *  the description field (using HTSetSuffix5).  AFAIK the only effect of
 *  such "fancy" (and mostly invalid) types that cannot be reproduced by
 *  using a description fields is some statusline messages in SaveToFile
 *  (HTFWriter.c).  And showing the user an invalid MIME type as the
 *  'Content-type:' is not such a hot idea anyway, IMO.  Still, if you
 *  want it, it is still possible (even in lynx.cfg now), but use of it
 *  in the defaults below has been reduced.
 *  Case variations rely on peculiar behavior of HTAtom.c for matching.
 *  They lead to surprising behavior, Lynx retains the case of a string
 *  in the form first encountered after starting up.  So while later suffix
 *  rules generally override or modify earlier ones, the case used for a
 *  MIME time is determined by the first suffix rule (or other occurrence).
 *  Matching in HTAtom_for is effectively case insensitive, except for the
 *  first character of the string which is treated as case-sensitive by the
 *  hash function there; best not to rely on that, rather convert MIME types
 *  to lowercase on input as is already done in most places (And HTAtom could
 *  become consistently case-sensitive, as in newer W3C libwww).
 *  - kw 1999-10-12
 */
d694 3
a696 4
#ifdef BUILTIN_SUFFIX_MAPS
    if (LYUseBuiltinSuffixes)
    {
    CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));
d699 2
a700 3
    HTSetSuffix("*",		"text/plain", "8bit", 1.0);
    HTSetSuffix("*.*",		"text/plain", "8bit", 1.0);

d716 1
a716 9
    /*
     *  Some of the old incarnation of the mappings is preserved
     *  and can be had by defining TRADITIONAL_SUFFIXES.  This
     *  is for some cases where I felt the old rules might be preferred
     *  by someone, for some reason.  It's not done consistently.
     *  A lot more of this stuff could probably be changed too or
     *  omitted, now that nearly the equivalent functionality is
     *  available in lynx.cfg. - kw 1999-10-12
     */
d729 1
a729 1
    HTSetSuffix5(".exe",	"application/octet-stream", "binary", "Executable", 1.0);
a730 1
#ifdef TRADITIONAL_SUFFIXES
d733 1
d735 1
a737 10
#else
    HTSetSuffix5(".Z",	        "application/x-compress", "binary", "UNIX Compressed", 1.0);
    HTSetSuffix5(".Z",	        NULL, "compress",      "UNIX Compressed", 1.0);
    HTSetSuffix5(".exe.Z",	"application/octet-stream", "compress",
    						       "Executable", 1.0);
    HTSetSuffix5(".tar_Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
    HTSetSuffix5(".tar.Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
#endif
a738 1
#ifdef TRADITIONAL_SUFFIXES
a744 11
#else
    HTSetSuffix5("-gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("-gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		NULL, "gzip", "GNU Compressed", 1.0);

    HTSetSuffix5(".tar.gz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".tgz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
#endif
a745 1
#ifdef TRADITIONAL_SUFFIXES
a747 3
#else
    HTSetSuffix5(".wsrc",	"application/x-wais-source", "8bit", "WAIS-source", 1.0);
#endif
d749 1
a749 1
    HTSetSuffix5(".zip",	"application/zip", "binary", "Zip File", 1.0);
a752 3
    HTSetSuffix(".bz2",		"application/bzip2", "binary", 1.0);

#ifdef TRADITIONAL_SUFFIXES
a758 9
#else
    HTSetSuffix5(".uu",		"application/x-uuencoded", "7bit", "UUencoded", 1.0);

    HTSetSuffix5(".hqx",	"application/mac-binhex40", "8bit", "Mac BinHex", 1.0);

    HTSetSuffix5(".o",		"application/octet-stream", "binary", "Prog. Object", 0.5);
    HTSetSuffix5(".a",		"application/octet-stream", "binary", "Prog. Library", 0.5);
    HTSetSuffix5(".so",		"application/octet-stream", "binary", "Shared Lib", 0.5);
#endif
d764 3
a766 3
    HTSetSuffix5(".eps",	"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ai",		"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ps",		"application/postscript", "8bit", "Postscript", 1.0);
d768 1
a768 1
    HTSetSuffix5(".rtf",	"application/rtf", "8bit", "RTF", 1.0);
d770 1
a770 1
    HTSetSuffix5(".dvi",	"application/x-dvi", "8bit", "DVI", 1.0);
d772 1
a772 1
    HTSetSuffix5(".hdf",	"application/x-hdf", "8bit", "HDF", 1.0);
a776 1
#ifdef TRADITIONAL_SUFFIXES
a780 6
#else
    HTSetSuffix5(".latex",	"application/x-latex", "8bit", "LaTeX", 1.0);
    HTSetSuffix5(".tex",  	"text/x-tex", "8bit", "TeX", 1.0);
    HTSetSuffix5(".texinfo",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
    HTSetSuffix5(".texi",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
#endif
a781 1
#ifdef TRADITIONAL_SUFFIXES
a788 9
#else
    HTSetSuffix5(".t",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".tr",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".roff",	"application/x-troff", "8bit", "Troff", 1.0);

    HTSetSuffix5(".man",	"application/x-troff-man", "8bit", "Man Page", 1.0);
    HTSetSuffix5(".me",		"application/x-troff-me", "8bit", "Troff me", 1.0);
    HTSetSuffix5(".ms",		"application/x-troff-ms", "8bit", "Troff ms", 1.0);
#endif
a791 1
#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
d796 9
a804 14
    HTSetSuffix5(".bkp_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bkp-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);

    HTSetSuffix5(".bkp-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bkp_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
#else
    HTSetSuffix5(".bak",	NULL, "binary", "Backup", 0.5);
    HTSetSuffix5(".bkp",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
    HTSetSuffix5(".bck",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
#endif
a805 1
#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
a811 8
#else
    HTSetSuffix5(".hlb",	"application/octet-stream", "binary", "VMS Help Libr.", 1.0);
    HTSetSuffix5(".olb",	"application/octet-stream", "binary", "VMS Obj. Libr.", 1.0);
    HTSetSuffix5(".tlb",	"application/octet-stream", "binary", "VMS Text Libr.", 1.0);
    HTSetSuffix5(".obj",	"application/octet-stream", "binary", "Prog. Object", 1.0);
    HTSetSuffix5(".decw$book",	"application/octet-stream", "binary", "DEC BookReader", 1.0);
    HTSetSuffix5(".mem",	"text/x-runoff-manual", "8bit", "RUNOFF-MANUAL", 1.0);
#endif
d815 9
a823 10
    HTSetSuffix5(".lha",	"application/x-lha", "binary", "lha File", 1.0);
    HTSetSuffix5(".lzh",	"application/x-lzh", "binary", "lzh File", 1.0);
    HTSetSuffix5(".sea",	"application/x-sea", "binary", "sea File", 1.0);
#ifdef TRADITIONAL_SUFFIXES
    HTSetSuffix5(".sit",	"application/x-sit", "binary", "sit File", 1.0);
#else
    HTSetSuffix5(".sit",	"application/x-stuffit", "binary", "StuffIt", 1.0);
#endif
    HTSetSuffix5(".dms",	"application/x-dms", "binary", "dms File", 1.0);
    HTSetSuffix5(".iff",	"application/x-iff", "binary", "iff File", 1.0);
a827 1
#ifdef TRADITIONAL_SUFFIXES
a828 1
#endif
a832 1
#ifdef TRADITIONAL_SUFFIXES
a833 1
#endif
a894 2
    HTSetSuffix(".php",		"text/html", "8bit", 1.0);
    HTSetSuffix(".php3",	"text/html", "8bit", 1.0);
a903 25
    } else { /* LYSuffixRules */
    /*
     *  Note that even .html -> text/html, .htm -> text/html are omitted
     *  if default maps are compiled in but then skipped because of a
     *  configuration file directive.  Whoever changes the config file
     *  in this way can easily also add the SUFFIX rules there. - kw
     */
    CTRACE((tfp, "HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    } /* LYSuffixRules */

#else /* BUILTIN_SUFFIX_MAPS */

    CTRACE((tfp, "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
    /*
     *  The followin two are still used if BUILTIN_SUFFIX_MAPS was
     *  undefined.  Without one of them, lynx would always need to
     *  have a mapping specified in a lynx.cfg or mime.types file
     *  to be usable for local HTML files at all.  That includes
     *  many of the generated user interface pages. - kw
     */
    HTSetSuffix(".htm",		"text/html", "8bit", 1.0);
    HTSetSuffix(".html",	"text/html", "8bit", 1.0);
#endif /* BUILTIN_SUFFIX_MAPS */


d907 2
a908 1
    if (LYCanReadFile(personal_extension_map)) {
d948 1
a948 1
		s[i] = (char) r;
d993 1
a993 1
    CTRACE((tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn));
d995 2
a996 2
    if ((f = fopen(fn, TXT_R)) == NULL) {
	CTRACE((tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn));
d1004 4
a1007 2
	ct = NULL;
	StrAllocCopy(ct, word);
d1013 3
a1015 1
		char *ext = NULL;
d1017 1
a1017 1
		HTSprintf0(&ext, ".%s", word);
d1020 1
a1020 1
		CTRACE((tfp, "SETTING SUFFIX '%s' to '%s'.\n", ext, ct));
d1037 1
a1037 1
    LYCloseInput(f);
@


1.1.3.2
log
@Lynx 2.8.5dev.17 Patchlevel d

This fixes, among many others, the following:
* correct some mismatches between INSTALLATION and "configure --help" (prompted
  by discussion with Stef Caunter) -TD
* amend check for refresh-URL to ensure it only prepends a link for text/html
  content type (report by Carlton Anderson).
* do not strip parameters from refresh-URL (report by Carlton Anderson gave an
  example of their use) -TD
* remove obsolete XMOSAIC_HACK defines -TD
* improve check for Unix-style shell given in $SHELL by limiting the check to
  the base-name (discussion with GV, DK) -TD
* modify increment_tagged_htline() to reallocate its HTLine parameter if the
  result would be larger than the allocation.  This can happen when a large
  textarea is adjusted (report by Thorsten Glaser)  -TD
* add ifdef'd logic to change HTLine to calloc() rather than memory pools,
  making it possible to use valgrind, etc., for debugging -LP
* add check for broken ProFTPD 1.2.5rc1, e.g., at ftp://ftp.oldskool.org/pub,
  and force a reconnection if an error 550 is detected when doing RETR.  This
  is ifdef'd with BROKEN_PROFTPD and checks version (reports by GV, DK) -TD
* modify file-upload to not print a warning message if the form-field is empty
  (Frank Heckenbach).
* add a few null-pointer checks to GridText.c (addresses symptoms reported by
  Frederic L W Meunier when nested-tables are toggled off) -TD
* modify LYTrimNewline() to trim carriage-returns as well as line-feeds, making
  it possible to share cookie files between platforms that have different
  line-terminations (report by Frederic L W Meunier) -TD
* rename EXP_PERSISTENT_COOKIES ifdef to USE_PERSISTENT_COOKIES -TD
* rename EXP_READPROGRESS ifdef to USE_READPROGRESS -TD
* rename SOURCE_CACHE ifdef to USE_SOURCE_CACHE -TD
* change a few configure script defaults to "enable":  source-cache, prettysrc
  and read-eta.  Also change default for read-eta configuration flag to "Show
  KB/Sec" (requests by LP, Frederic L W Meunier) -TD
* change configure script to compile-in file-upload by default, change its
  corresponding ifdef to USE_FILE_UPLOAD -TD
* revert table-layout changes from dev.15/dev.16 because of unresolved
  issues -TD
* add configure option --with-bzlib -TD
* implement support for bzip compression by internal calls to libbz2 -IZ
* if a document is in the cache (the rendering is in memory), on reload it
  should not be cleared from the cache until the connection to the server is
  opened; if the connection fails, the user will reuse the old version (request
  by IZ) -LP
* correct strings in LYOptions.c so ENABLE_LYNXRC works for bookmark_file
  and run_all_execution_links -DK
* fix pathname generated for "View temporary file" in LYDownload.c using new
  function LYAddPathToSave() (report by P.J.Walsh) -TD
* change code to match lynx.cfg description for FORCE_COOKIE_PROMPT and
  FORCE_SSL_PROMPT, making "prompt" rather than "default" the keyword to use
  when telling lynx to prompt (report by DK) -TD
* modify ifdef's to use mkdtemp() if it is available (prompted by MirBSD
  patch) -TD
* several fixes from Thorsten Glaser (MirBSD):
  + workaround for invoking shell scripts when executable permissions are
    discarded as a result from using CVS.
  + adjust buffer-size used in a readlink() call in case the result is too
    long to include trailing null.
  + change default ftp mode to passive.
  + if ftp connection fails, automatically retry, switching between passive
    and active modes.  Do this retry switching only when connecting to a
    different host.  A new variable ftp_local_passive distinguishes this
    from the user preference in ftp_passive.
  + improved certificate handling (case-insensitive domain-comparison, strip
    port-numbers from comparison).
  + fix a few typos & compiler-warnings.
* modify configure script to not use "head -1", which does not work for some
  platforms when POSIXLY_CORRECT (sic) is set -TD
* fix configure script check for term.h, which may be <ncursesw/term.h> -TD
* amend change in dev.15 to HTParse() to escape spaces, to exclude non-URL
  strings such as absolute filenames (report by Patrick Ash) -TD
* modify LYParseTagParam() (added in dev.13) to not stop on ';' (fixes a bug
  reported by LV which broke complicated refresh-URL containing "&amp;") -TD
* change default start page to lynx.isc.org, since lynx.browser.org is not
  maintained -TD
@
text
@d45 1
a45 1
							    1.0, 3.0, 0.0, 0);
d91 1
a91 1
					      HTCompressed,   1.0, 0.0, 0.0, 0);
d93 1
a93 1
					      HTCompressed,   1.0, 0.0, 0.0, 0);
d95 1
a95 1
					      HTCompressed,   1.0, 0.0, 0.0, 0);
d97 1
a97 1
					      HTCompressed,   1.0, 0.0, 0.0, 0);
d103 1
a103 1
					HTMLToC,	0.5, 0.0, 0.0, 0);
d105 1
a105 1
					HTMLToPlain,	0.5, 0.0, 0.0, 0);
d107 1
a107 1
					HTMLPresent,	2.0, 0.0, 0.0, 0);
d109 1
a109 1
					HTPlainPresent,	1.0, 0.0, 0.0, 0);
d123 1
a123 1
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d125 1
a125 1
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d127 1
a127 1
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d134 1
a134 1
					HTDumpToStdout,	1.0, 3.0, 0.0, 0);
d140 1
a140 1
			      "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
d142 1
a142 1
			      "www/present", HTMLPresent,    2.0, 0.0, 0.0, 0);
d148 1
a148 1
 HTSetConversion("text/html", "text/x-c",    HTMLToC,	     0.5, 0.0, 0.0, 0);
d420 1
a420 1
	char **,	pBuf,
d543 1
a543 1
	if (LYgetXDisplay() != NULL) {
d554 1
a554 1
	if (LYgetXDisplay() == NULL) {
d778 1
a778 1
							     "binary", 1.0);
d786 1
a786 1
						       "Executable", 1.0);
d861 1
a861 1
    HTSetSuffix(".tex",		"application/x-Tex", "8bit", 1.0);
d866 1
a866 1
    HTSetSuffix5(".tex",	"text/x-tex", "8bit", "TeX", 1.0);
@


1.1.3.3
log
@A three-days old development version of Lynx, the best web browser ever,
which follows the OpenBSD paradigma to only provide high-quality, func-
tional snapshots.
@
text
@d31 2
a32 2
static int HTLoadTypesConfigFile (char *fn);
static int HTLoadExtensionsConfigFile (char *fn);
d34 1
a34 1
void HTFormatInit (void)
d182 1
a182 1
void HTPreparsedFormatInit (void)
d228 2
a229 2
static int ExitWithError (char *txt);
static int PassesTest (struct MailcapEntry *mc);
d233 3
a235 3
static char *GetCommand (
	char *		s,
	char **	t)
d271 2
a272 2
static char *Cleanse (
	char *		s)
d280 3
a282 3
static int ProcessMailcapEntry (
	FILE *			fp,
	struct MailcapEntry *	mc)
d419 6
a424 6
static void BuildCommand (
	char **	pBuf,
	size_t		Bufsize,
	char *		controlstring,
	char *		TmpFileName,
	size_t		TmpFileLen)
d483 4
a486 4
static int RememberTestResult (
	int		mode,
	char *		cmd,
	int		result)
d523 2
a524 2
static int PassesTest (
	struct MailcapEntry *	mc)
d624 2
a625 2
static int ProcessMailcapFile (
	char *		file)
d646 2
a647 2
static int ExitWithError (
	char *		txt)
d660 2
a661 2
static int HTLoadTypesConfigFile (
	char *		fn)
d727 1
a727 1
void HTFileInit (void)
d1076 4
a1079 4
static int HTGetLine (
	char *		s,
	int		n,
	FILE *		f)
d1106 5
a1110 5
static void HTGetWord (
	char *		word,
	char *		line,
	char 		stop,
	char 		stop2)
d1129 2
a1130 2
static int HTLoadExtensionsConfigFile (
	char *		fn)
@


1.1.3.4
log
@Lynx 2.8.6dev.5 fresh from the ISC
@
text
@d2 2
a3 2
 *		----------------------------------------
 */
d6 2
a7 2
 *	------------------------------------------------
 */
d23 1
a23 1
#include <HTSaveToFile.h>	/* LJM */
d31 2
a32 11
static int HTLoadTypesConfigFile(char *fn, AcceptMedia media);
static int HTLoadExtensionsConfigFile(char *fn);

#define SET_SUFFIX1(suffix, description, type) \
	HTSetSuffix(suffix, description, type, 1.0)

#define SET_SUFFIX5(suffix, mimetype, type, description) \
       HTSetSuffix5(suffix, mimetype, type, description, 1.0)

#define SET_PRESENT(mimetype, command, quality, delay) \
  HTSetPresentation(mimetype, command, 0, quality, delay, 0.0, 0, media)
d34 1
a34 7
#define SET_EXTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 3.0, 0.0, 0, mediaEXT)

#define SET_INTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 0.0, 0.0, 0, mediaINT)

void HTFormatInit(void)
a35 2
    AcceptMedia media = mediaEXT;

d37 5
a41 5
    SET_PRESENT("application/postscript", "open %s", 1.0, 2.0);
    SET_PRESENT("image/x-tiff", "open %s", 2.0, 2.0);
    SET_PRESENT("image/tiff", "open %s", 1.0, 2.0);
    SET_PRESENT("audio/basic", "open %s", 1.0, 2.0);
    SET_PRESENT("*", "open %s", 1.0, 0.0);
d43 15
a57 14
    if (LYgetXDisplay() != 0) {	/* Must have X11 */
	SET_PRESENT("application/postscript", "ghostview %s&", 1.0, 3.0);
	if (XLoadImageCommand && *XLoadImageCommand) {
	    /* *INDENT-OFF* */
	    SET_PRESENT("image/gif",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbm",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbitmap", XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-png",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/png",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-rgb",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-tiff",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/tiff",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/jpeg",	   XLoadImageCommand, 1.0, 3.0);
	    /* *INDENT-ON* */
d59 1
a59 4
	}
	SET_PRESENT("video/mpeg", "mpeg_play %s &", 1.0, 3.0);

    }
d63 1
a63 1
    /* set quality to 999.0 for protected exec applications */
d65 3
a67 3
    SET_PRESENT("application/x-csh", "csh %s", 999.0, 3.0);
    SET_PRESENT("application/x-sh", "sh %s", 999.0, 3.0);
    SET_PRESENT("application/x-ksh", "ksh %s", 999.0, 3.0);
d69 1
a69 1
    SET_PRESENT("application/x-VMS_script", "@@%s", 999.0, 3.0);
d73 13
a85 11
    /*
     * Add our header handlers.
     */
    media = mediaINT;
    SET_INTERNL("message/x-http-redirection", "*", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/present", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/debug", HTMIMERedirect, 1.0);
    SET_INTERNL("www/mime", "www/present", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/download", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/source", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/dump", HTMIMEConvert, 1.0);
d87 48
a134 7
    /*
     * Add our compressed file handlers.
     */
    SET_INTERNL("www/compressed", "www/download", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/present", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/source", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/dump", HTCompressed, 1.0);
d136 52
a187 77
    /*
     * Added the following to support some content types beginning to surface.
     */
    SET_INTERNL("application/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("application/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("application/html", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/xhtml+xml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/x-wais-source", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/x-wais-source", "www/present", HTWSRCConvert, 2.0);
    SET_INTERNL("application/x-wais-source", "www/download", HTWSRCConvert, 1.0);
    SET_INTERNL("application/x-wais-source", "www/dump", HTWSRCConvert, 1.0);

    /*
     * Save all unknown mime types to disk.
     */
    SET_EXTERNL("www/source", "www/present", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/source", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/download", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "*", HTSaveToFile, 1.0);

    /*
     * Output all www/dump presentations to stdout.
     */
    SET_EXTERNL("www/source", "www/dump", HTDumpToStdout, 1.0);

    /*
     * Now add our basic conversions.
     */
    SET_INTERNL("text/x-sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/x-sgml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("text/sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/sgml", "www/present", HTMLPresent, 1.0);
    SET_INTERNL("text/plain", "www/present", HTPlainPresent, 1.0);
    SET_INTERNL("text/plain", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("text/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("text/html", "www/present", HTMLPresent, 1.0);

    /*
     * These should override the default types as necessary.
     */
    HTLoadTypesConfigFile(global_type_map, mediaSYS);

    /*
     * Load the local maps.
     */
    if (LYCanReadFile(personal_type_map)) {
	/* These should override everything else. */
	HTLoadTypesConfigFile(personal_type_map, mediaUSR);
    } else {
	char buffer[LY_MAXPATH];

	LYAddPathToHome(buffer, sizeof(buffer), personal_type_map);
	HTLoadTypesConfigFile(buffer, mediaUSR);
    }

    /*
     * Put text/html and text/plain at beginning of list.  - kw
     */
    HTReorderPresentation(WWW_PLAINTEXT, WWW_PRESENT);
    HTReorderPresentation(WWW_HTML, WWW_PRESENT);

    /*
     * Analyze the list, and set 'get_accept' for those whose representations
     * are not redundant.
     */
    HTFilterPresentations();
}

void HTPreparsedFormatInit(void)
{
    if (LYPreparsedSource) {
	SET_INTERNL("text/html", "www/source", HTMLParsedPresent, 1.0);
	SET_INTERNL("text/html", "www/dump", HTMLParsedPresent, 1.0);
    }
a222 1
    char *nametemplate;
a226 2
static int ExitWithError(char *txt);
static int PassesTest(struct MailcapEntry *mc);
d228 8
a235 1
static char *GetCommand(char *s, char **t)
d242 1
a242 1
    s2 = malloc(strlen(s) * 2 + 1);	/* absolute max, if all % signs */
d249 1
a249 2
	    if (*s == '%')
		*s2++ = '%';	/* Quote through next level, ugh! */
d256 1
a256 1
		return (++s);
d267 1
a267 1
    return (NULL);
d271 2
a272 1
static char *Cleanse(char *s)
d277 1
a277 1
    return (s);
d280 3
a282 54
/* remove unnecessary (unquoted) blanks in a shell command */
static void TrimCommand(char *command)
{
    LYTrimTrailing(command);
#ifdef UNIX
    {
	char *s = command;
	char *d = command;
	int ch;
	int c0 = ' ';
	BOOL escape = FALSE;
	BOOL dquote = FALSE;
	BOOL squote = FALSE;

	while ((ch = *s++) != '\0') {
	    if (escape) {
		escape = FALSE;
	    } else if (squote) {
		if (ch == '\'')
		    squote = FALSE;
	    } else if (dquote) {
		if (ch == '"')
		    dquote = FALSE;
	    } else {
		switch (ch) {
		case '"':
		    dquote = TRUE;
		    break;
		case '\'':
		    squote = TRUE;
		    break;
		case '\\':
		    if (dquote)
			escape = TRUE;
		    break;
		}
	    }
	    if (!escape && !dquote && !squote) {
		if (ch == '\t')
		    ch = ' ';
		if (ch == ' ') {
		    if (c0 == ' ')
			continue;
		}
	    }
	    *d++ = ch;
	    c0 = ch;
	}
	*d = '\0';
    }
#endif
}

static int ProcessMailcapEntry(FILE *fp, struct MailcapEntry *mc, AcceptMedia media)
d288 1
a288 1
    rawentry = (char *) malloc(rawentryalloc);
d302 1
a302 1
		ExitWithError(MEMORY_EXHAUSTED_ABORT);
d304 2
a305 2
	if (len > 0 && LineBuf[len - 1] == '\\') {
	    LineBuf[len - 1] = '\0';
d318 1
a318 1
	return (0);
d322 2
a323 3
	CTRACE((tfp,
		"ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		rawentry));
d325 1
a325 1
	return (0);
d333 1
a333 1
		rawentry));
d335 1
a335 1
	return (0);
a373 1
		TrimCommand(mc->testcommand);
d375 1
a375 1
			mc->testcommand));
d377 1
a377 1
		mc->label = eq;	/* ignored */
d379 1
a379 1
		mc->label = eq;	/* ignored: bogus old name for description */
d381 1
a381 1
		mc->printcommand = eq;	/* ignored */
d386 1
a386 1
		mc->quality = (float) atof(eq);
d390 1
a390 1
		mc->maxbytes = atol(eq);
d393 1
a393 1
	    } else if (strcmp(arg, "notes")) {	/* IGNORE notes field */
d395 2
a396 3
		    CTRACE((tfp,
			    "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			    arg));
d404 1
a404 1
  assign_presentation:
d409 3
a411 6
		mc->contenttype, mc->command));
	HTSetPresentation(mc->contenttype,
			  mc->command,
			  mc->testcommand,
			  mc->quality,
			  3.0, 0.0, mc->maxbytes, media);
a413 1
    FREE(mc->testcommand);
d416 1
a416 123
    return (1);
}

#define L_CURL '{'
#define R_CURL '}'

static const char *LYSkipQuoted(const char *s)
{
    int escaped = 0;

    ++s;			/* skip first quote */
    while (*s != 0) {
	if (escaped) {
	    escaped = 0;
	} else if (*s == '\\') {
	    escaped = 1;
	} else if (*s == '"') {
	    ++s;
	    break;
	}
	++s;
    }
    return s;
}

/*
 * Note: the tspecials[] here are those defined for Content-Type header, so
 * this function is not really general-purpose.
 */
static const char *LYSkipToken(const char *s)
{
    static const char tspecials[] = "\"()<>@@,;:\\/[]?.=";

    while (*s != '\0' && !WHITE(*s) && strchr(tspecials, *s) == 0) {
	++s;
    }
    return s;
}

static const char *LYSkipValue(const char *s)
{
    if (*s == '"')
	s = LYSkipQuoted(s);
    else
	s = LYSkipToken(s);
    return s;
}

/*
 * Copy the value from the source, dequoting if needed.
 */
static char *LYCopyValue(const char *s)
{
    const char *t;
    char *result = 0;
    int j, k;

    if (*s == '"') {
	t = LYSkipQuoted(s);
	StrAllocCopy(result, s + 1);
	result[t - s - 2] = '\0';
	for (j = k = 0;; ++j, ++k) {
	    if (result[j] == '\\') {
		++j;
	    }
	    if ((result[k] = result[j]) == '\0')
		break;
	}
    } else {
	t = LYSkipToken(s);
	StrAllocCopy(result, s);
	result[t - s] = '\0';
    }
    return result;
}

/*
 * The "Content-Type:" field, contains zero or more parameters after a ';'.
 * Return the value of the named parameter, or null.
 */
static char *LYGetContentType(const char *name,
			      const char *params)
{
    char *result = 0;

    if (params != 0) {
	if (name != 0) {
	    size_t length = strlen(name);
	    const char *test = strchr(params, ';');	/* skip type/subtype */
	    const char *next;

	    while (test != 0) {
		BOOL found = FALSE;

		++test;		/* skip the ';' */
		test = LYSkipCBlanks(test);
		next = LYSkipToken(test);
		if ((next - test) == (int) length
		    && !strncmp(test, name, length)) {
		    found = TRUE;
		}
		test = LYSkipCBlanks(next);
		if (*test == '=') {
		    ++test;
		    test = LYSkipCBlanks(test);
		    if (found) {
			result = LYCopyValue(test);
			break;
		    } else {
			test = LYSkipValue(test);
		    }
		    test = LYSkipCBlanks(test);
		}
		if (*test != ';') {
		    break;	/* we're lost */
		}
	    }
	} else {		/* return the content-type */
	    StrAllocCopy(result, params);
	    *LYSkipNonBlanks(result) = '\0';
	}
    }
    return result;
d419 6
a424 5
/*
 * Check if the command uses a "%s" substitution.  We need to know this, to
 * decide when to create temporary files, etc.
 */
BOOL LYMailcapUsesPctS(const char *controlstring)
d426 1
a426 3
    int result = FALSE;
    const char *from;
    const char *next;
a427 1
    int escaped = 0;
d429 2
a430 6
    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	} else if (*from == '\\') {
	    escaped = 1;
	} else if (prefixed) {
d432 3
a434 13
	    switch (*from) {
	    case '%':		/* not defined */
	    case 'n':
	    case 'F':
	    case 't':
		break;
	    case 's':
		result = TRUE;
		break;
	    case L_CURL:
		next = strchr(from, R_CURL);
		if (next != 0) {
		    from = next;
d436 15
a450 77
		}
		/* FALLTHRU */
	    default:
		break;
	    }
	} else if (*from == '%') {
	    prefixed = 1;
	}
    }
    return result;
}

/*
 * Build the command string for testing or executing a mailcap entry.
 * If a substitution from the Content-Type header is requested but no
 * parameters are available, return -1, otherwise 0.
 *
 * This does not support multipart %n or %F (does this apply to lynx?)
 */
static int BuildCommand(HTChunk *cmd,
			const char *controlstring,
			const char *TmpFileName,
			const char *params)
{
    int result = 0;
    size_t TmpFileLen = strlen(TmpFileName);
    const char *from;
    const char *next;
    char *name, *value;
    int prefixed = 0;
    int escaped = 0;

    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	    HTChunkPutc(cmd, *from);
	} else if (*from == '\\') {
	    escaped = 1;
	} else if (prefixed) {
	    prefixed = 0;
	    switch (*from) {
	    case '%':		/* not defined */
		HTChunkPutc(cmd, *from);
		break;
	    case 'n':
		/* FALLTHRU */
	    case 'F':
		CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
			controlstring));
		break;
	    case 't':
		if ((value = LYGetContentType(NULL, params)) != 0) {
		    HTChunkPuts(cmd, value);
		    FREE(value);
		}
		break;
	    case 's':
		if (TmpFileLen && TmpFileName) {
		    HTChunkPuts(cmd, TmpFileName);
		}
		break;
	    case L_CURL:
		next = strchr(from, R_CURL);
		if (next != 0) {
		    if (params != 0) {
			++from;
			name = 0;
			HTSprintf0(&name, "%.*s", next - from, from);
			if ((value = LYGetContentType(name, params)) != 0) {
			    HTChunkPuts(cmd, value);
			    FREE(value);
			} else {
			    if (!strcmp(name, "charset")) {
				HTChunkPuts(cmd, "ISO-8859-1");
			    } else {
				CTRACE((tfp, "BuildCommand no value for %s\n", name));
			    }
d452 2
a453 3
			FREE(name);
		    } else {
			result = -1;
a454 1
		    from = next;
d456 3
a458 5
		}
		/* FALLTHRU */
	    default:
		CTRACE((tfp,
			"BuildCommand: Ignoring unrecognized format code in mailcap file '%%%c'.\n",
d460 1
a460 1
		break;
d465 1
a465 1
	    HTChunkPutc(cmd, *from);
d467 7
a473 37
    }
    HTChunkTerminate(cmd);
    return result;
}

/*
 * Build the mailcap test-command and execute it.  This is only invoked when
 * we cannot tell just by looking at the command if it would succeed.
 *
 * Returns 0 for success, -1 for error and 1 for deferred.
 */
int LYTestMailcapCommand(const char *testcommand,
			 const char *params)
{
    int result;
    char TmpFileName[LY_MAXPATH];
    HTChunk *expanded = 0;

    if (LYMailcapUsesPctS(testcommand)) {
	if (LYOpenTemp(TmpFileName, HTML_SUFFIX, "w") == 0)
	    ExitWithError(CANNOT_OPEN_TEMP);
	LYCloseTemp(TmpFileName);
    } else {
	/* We normally don't need a temp file name - kw */
	TmpFileName[0] = '\0';
    }
    expanded = HTChunkCreate(1024);
    if ((result = BuildCommand(expanded, testcommand, TmpFileName, params)) != 0) {
	result = 1;
	CTRACE((tfp, "PassesTest: Deferring test command: %s\n", expanded->data));
    } else {
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", expanded->data));
	if ((result = LYSystem(expanded->data)) != 0) {
	    result = -1;
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	} else {
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
d476 1
a476 19

    HTChunkFree(expanded);
    LYRemoveTemp(TmpFileName);

    return result;
}

char *LYMakeMailcapCommand(const char *command,
			   const char *params,
			   const char *filename)
{
    HTChunk *expanded = 0;
    char *result = 0;

    expanded = HTChunkCreate(1024);
    BuildCommand(expanded, command, filename, params);
    StrAllocCopy(result, expanded->data);
    HTChunkFree(expanded);
    return result;
d483 4
a486 1
static int RememberTestResult(int mode, char *cmd, int result)
d496 21
a516 6
    switch (mode) {
    case RTR_forget:
	while (cmdlist) {
	    cur = cmdlist->next;
	    FREE(cmdlist->cmd);
	    FREE(cmdlist);
d518 1
a518 17
	}
	break;
    case RTR_lookup:
	for (cur = cmdlist; cur; cur = cur->next)
	    if (!strcmp(cmd, cur->cmd))
		return cur->result;
	return -1;
    case RTR_add:
	cur = typecalloc(struct cmdlist_s);

	if (cur == NULL)
	    outofmem(__FILE__, "RememberTestResult");
	cur->next = cmdlist;
	StrAllocCopy(cur->cmd, cmd);
	cur->result = result;
	cmdlist = cur;
	break;
d523 2
a524 4
/* FIXME: this sometimes used caseless comparison, e.g., strcasecomp */
#define SameCommand(tst,ref) !strcmp(tst,ref)

static int PassesTest(struct MailcapEntry *mc)
d527 1
d533 1
a533 1
	return (1);
d538 3
a540 3
    if (SameCommand(mc->testcommand, "test \"$DISPLAY\"") ||
	SameCommand(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	SameCommand(mc->testcommand, "test -n \"$DISPLAY\"")) {
d545 1
a545 1
	    return (0 == 0);
d548 1
a548 1
	    return (-1 == 0);
d551 1
a551 1
    if (SameCommand(mc->testcommand, "test -z \"$DISPLAY\"")) {
d555 2
a556 2
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
	    return (0 == 0);
d558 2
a559 2
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
	    return (-1 == 0);
d566 1
a566 1
    if (SameCommand(mc->testcommand, "test -n \"$LYNX_VERSION\"")) {
d570 1
a570 1
	return (0 == 0);
d572 4
a575 4
	/*
	 *  ... or failure for this one! - FM
	 */
    if (SameCommand(mc->testcommand, "test -z \"$LYNX_VERSION\"")) {
d579 1
a579 1
	return (-1 == 0);
d583 23
a605 2
    if (result == -1) {
	result = LYTestMailcapCommand(mc->testcommand, NULL);
d613 1
a613 2
    if (result != 1)
	FREE(mc->testcommand);
d615 4
a618 4
    if (result < 0) {
	CTRACE((tfp, "PassesTest: Test failed!\n"));
    } else if (result == 0) {
	CTRACE((tfp, "PassesTest: Test passed!\n"));
d621 1
a621 1
    return (result >= 0);
d624 2
a625 1
static int ProcessMailcapFile(char *file, AcceptMedia media)
d631 1
a631 1
	    file));
d634 2
a635 2
		file));
	return (-1 == 0);
d639 1
a639 1
	ProcessMailcapEntry(fp, &mc, media);
d643 1
a643 1
    return (0 == 0);
d646 2
a647 1
static int ExitWithError(char *txt)
d652 1
a652 1
    return (-1);
d660 2
a661 1
static int HTLoadTypesConfigFile(char *fn, AcceptMedia media)
d664 1
a664 1
    HTList *saved = HTPresentations;
d666 1
a666 1
    if (reverse_mailcap) {	/* temporarily hide existing list */
d670 1
a670 1
    result = ProcessMailcapFile(fn, media);
d684 3
d692 9
a700 9
 *	------------------------------
 *
 *	The LAST suffix for a type is that used for temporary files
 *	of that type.
 *	The quality is an apriori bias as to whether the file should be
 *	used.  Not that different suffixes can be used to represent files
 *	which are of the same format but are originals or regenerated,
 *	with different values.
 */
d702 23
a724 24
 * Additional notes:  the encoding parameter may be taken into account when
 * looking for a match; for that purpose "7bit", "8bit", and "binary" are
 * equivalent.
 *
 * Use of mixed case and of pseudo MIME types with embedded spaces should be
 * avoided.  It was once necessary for getting the fancy strings into type
 * labels in FTP directory listings, but that can now be done with the
 * description field (using HTSetSuffix5).  AFAIK the only effect of such
 * "fancy" (and mostly invalid) types that cannot be reproduced by using a
 * description fields is some statusline messages in SaveToFile (HTFWriter.c). 
 * And showing the user an invalid MIME type as the 'Content-type:' is not such
 * a hot idea anyway, IMO.  Still, if you want it, it is still possible (even
 * in lynx.cfg now), but use of it in the defaults below has been reduced.
 *
 * Case variations rely on peculiar behavior of HTAtom.c for matching.  They
 * lead to surprising behavior, Lynx retains the case of a string in the form
 * first encountered after starting up.  So while later suffix rules generally
 * override or modify earlier ones, the case used for a MIME time is determined
 * by the first suffix rule (or other occurrence).  Matching in HTAtom_for is
 * effectively case insensitive, except for the first character of the string
 * which is treated as case-sensitive by the hash function there; best not to
 * rely on that, rather convert MIME types to lowercase on input as is already
 * done in most places (And HTAtom could become consistently case-sensitive, as
 * in newer W3C libwww).
d727 1
a727 1
void HTFileInit(void)
d730 7
a736 2
    if (LYUseBuiltinSuffixes) {
	CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));
a737 3
	/* default suffix interpretation */
	SET_SUFFIX1("*", "text/plain", "8bit");
	SET_SUFFIX1("*.*", "text/plain", "8bit");
d740 3
a742 3
	/*
	 * define these extensions for exec scripts.
	 */
d744 4
a747 4
	/* for csh exec links */
	HTSetSuffix(".csh", "application/x-csh", "8bit", 0.8);
	HTSetSuffix(".sh", "application/x-sh", "8bit", 0.8);
	HTSetSuffix(".ksh", "application/x-ksh", "8bit", 0.8);
d749 1
a749 1
	HTSetSuffix(".com", "application/x-VMS_script", "8bit", 0.8);
d753 22
a774 22
	/*
	 * Some of the old incarnation of the mappings is preserved and can be had
	 * by defining TRADITIONAL_SUFFIXES.  This is for some cases where I felt
	 * the old rules might be preferred by someone, for some reason.  It's not
	 * done consistently.  A lot more of this stuff could probably be changed
	 * too or omitted, now that nearly the equivalent functionality is
	 * available in lynx.cfg.  - kw 1999-10-12
	 */
	/* *INDENT-OFF* */
	SET_SUFFIX1(".saveme",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".dump",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".bin",	"application/x-Binary",		"binary");

	SET_SUFFIX1(".arc",	"application/x-Compressed",	"binary");

	SET_SUFFIX1(".alpha-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".alpha_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX_exe", "application/x-Executable",	"binary");
	SET_SUFFIX5(".exe",	"application/octet-stream",	"binary", "Executable");
d777 5
a781 4
	SET_SUFFIX1(".exe.Z",	"application/x-Comp. Executable", "binary");
	SET_SUFFIX1(".Z",	"application/UNIX Compressed",	"binary");
	SET_SUFFIX1(".tar_Z",	"application/UNIX Compr. Tar",	"binary");
	SET_SUFFIX1(".tar.Z",	"application/UNIX Compr. Tar",	"binary");
d783 8
a790 5
	SET_SUFFIX5(".Z",	"application/x-compress",	"binary", "UNIX Compressed");
	SET_SUFFIX5(".Z",	NULL,				"compress", "UNIX Compressed");
	SET_SUFFIX5(".exe.Z",	"application/octet-stream",	"compress", "Executable");
	SET_SUFFIX5(".tar_Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
	SET_SUFFIX5(".tar.Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
d794 3
a796 3
	SET_SUFFIX1("-gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1("_gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1(".gz",	"application/GNU Compressed",	"binary");
d798 2
a799 2
	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"binary", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
d801 6
a806 6
	SET_SUFFIX5("-gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("_gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5(".gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("-gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5("_gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5(".gz",	NULL,				"gzip", "GNU Compressed");
d808 2
a809 2
	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
d813 2
a814 2
	SET_SUFFIX1(".src",	"application/x-WAIS-source",	"8bit");
	SET_SUFFIX1(".wsrc",	"application/x-WAIS-source",	"8bit");
d816 1
a816 1
	SET_SUFFIX5(".wsrc",	"application/x-wais-source",	"8bit", "WAIS-source");
d819 1
a819 1
	SET_SUFFIX5(".zip",	"application/zip",		"binary", "Zip File");
d821 1
a821 1
	SET_SUFFIX1(".bz2",	"application/x-bzip2",		"binary");
d823 1
a823 1
	SET_SUFFIX1(".bz2",	"application/bzip2",		"binary");
d826 1
a826 1
	SET_SUFFIX1(".uu",	"application/x-UUencoded",	"8bit");
d828 1
a828 1
	SET_SUFFIX1(".hqx",	"application/x-Binhex",		"8bit");
d830 2
a831 2
	SET_SUFFIX1(".o",	"application/x-Prog. Object",	"binary");
	SET_SUFFIX1(".a",	"application/x-Prog. Library",	"binary");
d833 1
a833 1
	SET_SUFFIX5(".uu",	"application/x-uuencoded",	"7bit", "UUencoded");
d835 1
a835 1
	SET_SUFFIX5(".hqx",	"application/mac-binhex40",	"8bit", "Mac BinHex");
d837 3
a839 3
	HTSetSuffix5(".o",	"application/octet-stream",	"binary", "Prog. Object", 0.5);
	HTSetSuffix5(".a",	"application/octet-stream",	"binary", "Prog. Library", 0.5);
	HTSetSuffix5(".so",	"application/octet-stream",	"binary", "Shared Lib", 0.5);
d842 1
a842 1
	SET_SUFFIX5(".oda",	"application/oda",		"binary", "ODA");
d844 1
a844 1
	SET_SUFFIX5(".pdf",	"application/pdf",		"binary", "PDF");
d846 3
a848 3
	SET_SUFFIX5(".eps",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ai",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ps",	"application/postscript",	"8bit", "Postscript");
d850 1
a850 1
	SET_SUFFIX5(".rtf",	"application/rtf",		"8bit", "RTF");
d852 1
a852 1
	SET_SUFFIX5(".dvi",	"application/x-dvi",		"8bit", "DVI");
d854 1
a854 1
	SET_SUFFIX5(".hdf",	"application/x-hdf",		"8bit", "HDF");
d856 2
a857 2
	SET_SUFFIX1(".cdf",	"application/x-netcdf",		"8bit");
	SET_SUFFIX1(".nc",	"application/x-netcdf",		"8bit");
d860 4
a863 4
	SET_SUFFIX1(".latex",	"application/x-Latex",		"8bit");
	SET_SUFFIX1(".tex",	"application/x-Tex",		"8bit");
	SET_SUFFIX1(".texinfo", "application/x-Texinfo",	"8bit");
	SET_SUFFIX1(".texi",	"application/x-Texinfo",	"8bit");
d865 4
a868 4
	SET_SUFFIX5(".latex",	"application/x-latex",		"8bit", "LaTeX");
	SET_SUFFIX5(".tex",	"text/x-tex",			"8bit", "TeX");
	SET_SUFFIX5(".texinfo", "application/x-texinfo",	"8bit", "Texinfo");
	SET_SUFFIX5(".texi",	"application/x-texinfo",	"8bit", "Texinfo");
d872 7
a878 7
	SET_SUFFIX1(".t",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".tr",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".roff",	"application/x-Troff",		"8bit");

	SET_SUFFIX1(".man",	"application/x-Troff-man",	"8bit");
	SET_SUFFIX1(".me",	"application/x-Troff-me",	"8bit");
	SET_SUFFIX1(".ms",	"application/x-Troff-ms",	"8bit");
d880 7
a886 7
	SET_SUFFIX5(".t",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".tr",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".roff",	"application/x-troff",		"8bit", "Troff");

	SET_SUFFIX5(".man",	"application/x-troff-man",	"8bit", "Man Page");
	SET_SUFFIX5(".me",	"application/x-troff-me",	"8bit", "Troff me");
	SET_SUFFIX5(".ms",	"application/x-troff-ms",	"8bit", "Troff ms");
d889 1
a889 1
	SET_SUFFIX1(".zoo",	"application/x-Zoo File",	"binary");
d892 13
a904 13
	SET_SUFFIX1(".bak",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bkp",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bck",	"application/x-VMS BAK File",	"binary");

	SET_SUFFIX5(".bkp_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bkp-gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck-gz",	"application/octet-stream",	"gzip", "GNU BAK File");

	SET_SUFFIX5(".bkp-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bkp_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
d906 3
a908 3
	HTSetSuffix5(".bak",	NULL,				"binary", "Backup", 0.5);
	SET_SUFFIX5(".bkp",	"application/octet-stream",	"binary", "VMS BAK File");
	SET_SUFFIX5(".bck",	"application/octet-stream",	"binary", "VMS BAK File");
d912 6
a917 6
	SET_SUFFIX1(".hlb",	"application/x-VMS Help Libr.", "binary");
	SET_SUFFIX1(".olb",	"application/x-VMS Obj. Libr.", "binary");
	SET_SUFFIX1(".tlb",	"application/x-VMS Text Libr.", "binary");
	SET_SUFFIX1(".obj",	"application/x-VMS Prog. Obj.", "binary");
	SET_SUFFIX1(".decw$book", "application/x-DEC BookReader", "binary");
	SET_SUFFIX1(".mem",	"application/x-RUNOFF-MANUAL", "8bit");
d919 6
a924 6
	SET_SUFFIX5(".hlb",	"application/octet-stream",	"binary", "VMS Help Libr.");
	SET_SUFFIX5(".olb",	"application/octet-stream",	"binary", "VMS Obj. Libr.");
	SET_SUFFIX5(".tlb",	"application/octet-stream",	"binary", "VMS Text Libr.");
	SET_SUFFIX5(".obj",	"application/octet-stream",	"binary", "Prog. Object");
	SET_SUFFIX5(".decw$book", "application/octet-stream",	"binary", "DEC BookReader");
	SET_SUFFIX5(".mem",	"text/x-runoff-manual",		"8bit", "RUNOFF-MANUAL");
d927 1
a927 1
	SET_SUFFIX1(".vsd",	"application/visio",		"binary");
d929 3
a931 3
	SET_SUFFIX5(".lha",	"application/x-lha",		"binary", "lha File");
	SET_SUFFIX5(".lzh",	"application/x-lzh",		"binary", "lzh File");
	SET_SUFFIX5(".sea",	"application/x-sea",		"binary", "sea File");
d933 1
a933 1
	SET_SUFFIX5(".sit",	"application/x-sit",		"binary", "sit File");
d935 1
a935 1
	SET_SUFFIX5(".sit",	"application/x-stuffit",	"binary", "StuffIt");
d937 2
a938 2
	SET_SUFFIX5(".dms",	"application/x-dms",		"binary", "dms File");
	SET_SUFFIX5(".iff",	"application/x-iff",		"binary", "iff File");
d940 2
a941 2
	SET_SUFFIX1(".bcpio",	"application/x-bcpio",		"binary");
	SET_SUFFIX1(".cpio",	"application/x-cpio",		"binary");
d944 1
a944 1
	SET_SUFFIX1(".gtar",	"application/x-gtar",		"binary");
d947 2
a948 2
	SET_SUFFIX1(".shar",	"application/x-shar",		"8bit");
	SET_SUFFIX1(".share",	"application/x-share",		"8bit");
d951 1
a951 1
	SET_SUFFIX1(".sh",	"application/x-sh",		"8bit"); /* xtra */
d954 2
a955 2
	SET_SUFFIX1(".sv4cpio", "application/x-sv4cpio",	"binary");
	SET_SUFFIX1(".sv4crc",	"application/x-sv4crc",		"binary");
d957 2
a958 2
	SET_SUFFIX5(".tar",	"application/x-tar",		"binary", "Tar File");
	SET_SUFFIX1(".ustar",	"application/x-ustar",		"binary");
d960 2
a961 2
	SET_SUFFIX1(".snd",	"audio/basic",			"binary");
	SET_SUFFIX1(".au",	"audio/basic",			"binary");
d963 61
a1023 62
	SET_SUFFIX1(".aifc",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aif",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aiff",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".wav",	"audio/x-wav",			"binary");
	SET_SUFFIX1(".midi",	"audio/midi",			"binary");
	SET_SUFFIX1(".mod",	"audio/mod",			"binary");

	SET_SUFFIX1(".gif",	"image/gif",			"binary");
	SET_SUFFIX1(".ief",	"image/ief",			"binary");
	SET_SUFFIX1(".jfif",	"image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jfif-tbnl", "image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jpe",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpeg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".tif",	"image/tiff",			"binary");
	SET_SUFFIX1(".tiff",	"image/tiff",			"binary");
	SET_SUFFIX1(".ham",	"image/ham",			"binary");
	SET_SUFFIX1(".ras",	"image/x-cmu-rast",		"binary");
	SET_SUFFIX1(".pnm",	"image/x-portable-anymap",	"binary");
	SET_SUFFIX1(".pbm",	"image/x-portable-bitmap",	"binary");
	SET_SUFFIX1(".pgm",	"image/x-portable-graymap",	"binary");
	SET_SUFFIX1(".ppm",	"image/x-portable-pixmap",	"binary");
	SET_SUFFIX1(".png",	"image/png",			"binary");
	SET_SUFFIX1(".rgb",	"image/x-rgb",			"binary");
	SET_SUFFIX1(".xbm",	"image/x-xbitmap",		"binary");
	SET_SUFFIX1(".xpm",	"image/x-xpixmap",		"binary");
	SET_SUFFIX1(".xwd",	"image/x-xwindowdump",		"binary");

	SET_SUFFIX1(".rtx",	"text/richtext",		"8bit");
	SET_SUFFIX1(".tsv",	"text/tab-separated-values",	"8bit");
	SET_SUFFIX1(".etx",	"text/x-setext",		"8bit");

	SET_SUFFIX1(".mpg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpe",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpeg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mov",	"video/quicktime",		"binary");
	SET_SUFFIX1(".qt",	"video/quicktime",		"binary");
	SET_SUFFIX1(".avi",	"video/x-msvideo",		"binary");
	SET_SUFFIX1(".movie",	"video/x-sgi-movie",		"binary");
	SET_SUFFIX1(".mv",	"video/x-sgi-movie",		"binary");

	SET_SUFFIX1(".mime",	"message/rfc822",		"8bit");

	SET_SUFFIX1(".c",	"text/plain",			"8bit");
	SET_SUFFIX1(".cc",	"text/plain",			"8bit");
	SET_SUFFIX1(".c++",	"text/plain",			"8bit");
	SET_SUFFIX1(".h",	"text/plain",			"8bit");
	SET_SUFFIX1(".pl",	"text/plain",			"8bit");
	SET_SUFFIX1(".text",	"text/plain",			"8bit");
	SET_SUFFIX1(".txt",	"text/plain",			"8bit");

	SET_SUFFIX1(".php",	"text/html",			"8bit");
	SET_SUFFIX1(".php3",	"text/html",			"8bit");
	SET_SUFFIX1(".html3",	"text/html",			"8bit");
	SET_SUFFIX1(".ht3",	"text/html",			"8bit");
	SET_SUFFIX1(".phtml",	"text/html",			"8bit");
	SET_SUFFIX1(".shtml",	"text/html",			"8bit");
	SET_SUFFIX1(".sht",	"text/html",			"8bit");
	SET_SUFFIX1(".htmlx",	"text/html",			"8bit");
	SET_SUFFIX1(".htm",	"text/html",			"8bit");
	SET_SUFFIX1(".html",	"text/html",			"8bit");
	/* *INDENT-ON* */
d1025 9
a1033 10
    } else {			/* LYSuffixRules */
	/*
	 * Note that even .html -> text/html, .htm -> text/html are omitted if
	 * default maps are compiled in but then skipped because of a
	 * configuration file directive.  Whoever changes the config file in
	 * this way can easily also add the SUFFIX rules there.  - kw
	 */
	CTRACE((tfp,
		"HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    }				/* LYSuffixRules */
d1037 1
a1037 2
    CTRACE((tfp,
	    "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
d1039 5
a1043 4
     * The following two are still used if BUILTIN_SUFFIX_MAPS was undefined. 
     * Without one of them, lynx would always need to have a mapping specified
     * in a lynx.cfg or mime.types file to be usable for local HTML files at
     * all.  That includes many of the generated user interface pages.  - kw
d1045 2
a1046 2
    SET_SUFFIX1(".htm", "text/html", "8bit");
    SET_SUFFIX1(".html", "text/html", "8bit");
d1049 1
a1057 1

d1064 1
d1076 4
a1079 1
static int HTGetLine(char *s, int n, FILE *f)
d1084 1
a1084 1
	return (1);
d1088 1
a1088 1
	s[i] = (char) r;
d1098 1
a1098 1
	if ((r == EOF) || (s[i] == LF) || (s[i] == CR) || (i == (n - 1))) {
d1106 5
a1110 1
static void HTGetWord(char *word, char *line, char stop, char stop2)
d1121 1
a1121 1
    y = 0;
d1123 2
a1124 1
    while ((line[y++] = line[x++])) ;
d1129 2
a1130 1
static int HTLoadExtensionsConfigFile(char *fn)
d1145 1
a1145 1
    while (!(HTGetLine(line, sizeof(line), f))) {
d1153 1
a1153 1
	while (line[0]) {
d1163 2
a1164 2
		if (strstr(ct, "tex") != NULL ||
		    strstr(ct, "postscript") != NULL ||
d1168 3
a1170 3
		    SET_SUFFIX1(ext, ct, "8bit");
		else
		    SET_SUFFIX1(ext, ct, "binary");
@


1.1.3.5
log
@fix important bugs in lynx by updating to latest -current snapshot
@
text
@d62 1
a62 1
	if (non_empty(XLoadImageCommand)) {
d244 1
a244 1
    while (non_empty(s)) {
d414 1
a414 1
	if (non_empty(arg)) {
d1096 1
a1096 2
	SET_SUFFIX1(".zz",	"application/x-deflate",	"binary");
	SET_SUFFIX1(".zz",	"application/deflate",		"binary");
a1097 1
	SET_SUFFIX1(".bz2",	"application/x-bzip2",		"binary");
@


1.1.1.1
log
@Import OpenBSD 3.3 source repository from CTM 3132 the first time
This opens an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@Import OpenBSD source tree of short before 17:00 UTC today
@
text
@d36 2
d48 9
a56 11
  if (XLoadImageCommand && *XLoadImageCommand) {
      HTSetPresentation("image/gif",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbm",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbitmap",XLoadImageCommand,1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-png",	XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/png",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-rgb",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-tiff", XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/tiff",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/jpeg",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  }
d65 3
a67 3
 HTSetPresentation("application/x-csh", "csh %s", 999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-sh",  "sh %s",  999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-ksh", "ksh %s", 999.0, 3.0, 0.0, 0);
a75 6
 HTSetConversion("message/x-http-redirection", "*",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/present",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/debug",
					     HTMIMERedirect, 1.0, 0.0, 0.0, 0);
d84 2
d156 2
a157 1
 if (LYCanReadFile(personal_type_map)) {
a170 6

 /*
  * Analyze the list, and set 'get_accept' for those whose representations
  * are not redundant.
  */
 HTFilterPresentations();
a230 1
    s = LYSkipBlanks(s);
d306 1
a306 1
    t = s = LYSkipBlanks(rawentry);
d314 2
a315 2
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		    rawentry));
d320 2
a321 2
    if (!strncasecomp(t, "text/html", 9) ||
	!strncasecomp(t, "text/plain", 10)) {
d324 2
a325 2
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
		    rawentry));
d338 5
a342 3
    mc->contenttype = NULL;
    StrAllocCopy(mc->contenttype, rawentry);
    mc->quality = (float) 1.0;
a356 1
	    eq = LYSkipBlanks(eq);
d367 2
a368 2
		CTRACE((tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
			    mc->testcommand));
d379 1
a379 1
	        mc->quality = (float)atof(eq);
d381 1
a381 1
		    mc->quality = (float) 0.001;
d388 2
a389 2
		    CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			        arg));
d401 2
a402 2
	CTRACE((tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
		    mc->contenttype, mc->command));
a429 1
		    /* FALLTHRU */
d431 2
a432 3
		    CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
				controlstring));
		    /* FALLTHRU */
d437 3
a439 3
			    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
			    CTRACE((tfp, "              ignoring: %s%s...\n",
					*pBuf, TmpFileName));
d448 1
a448 1
		    CTRACE((tfp,
d450 1
a450 1
			*from));
d460 3
a462 3
	    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
	    CTRACE((tfp, "              ignoring: %s...\n",
			*pBuf));
d502 1
a502 1
	    cur = typecalloc(struct cmdlist_s);
d506 5
a510 1
	    StrAllocCopy(cur->cmd, cmd);
d533 1
a533 3
    if (0 == strcmp(mc->testcommand, "test \"$DISPLAY\"") ||
	0 == strcmp(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	0 == strcasecomp(mc->testcommand, "test -n \"$DISPLAY\"")) {
d535 1
a535 1
	CTRACE((tfp, "PassesTest: Testing for XWINDOWS environment.\n"));
d537 1
a537 1
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
d540 1
a540 1
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
d546 1
a546 1
	CTRACE((tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n"));
d548 1
a548 1
	    CTRACE((tfp,"PassesTest: Test passed!\n"));
d551 1
a551 1
	    CTRACE((tfp,"PassesTest: Test failed!\n"));
d561 2
a562 2
	CTRACE((tfp, "PassesTest: Testing for LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test passed!\n"));
d570 2
a571 2
	CTRACE((tfp, "PassesTest: Testing for non-LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test failed!\n"));
d595 1
a595 1
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", cmd));
d609 1
a609 1
	CTRACE((tfp,"PassesTest: Test failed!\n"));
d611 1
a611 1
	CTRACE((tfp,"PassesTest: Test passed!\n"));
d623 5
a627 5
    CTRACE((tfp, "ProcessMailcapFile: Loading file '%s'.\n",
		file));
    if ((fp = fopen(file, TXT_R)) == NULL) {
	CTRACE((tfp, "ProcessMailcapFile: Could not open '%s'.\n",
		    file));
d634 1
a634 1
    LYCloseInput(fp);
d643 2
a644 2
	fprintf(tfp, "Lynx: %s\n", txt);
    exit_immediately(EXIT_FAILURE);
d648 1
a648 4
/* Reverse the entries from each mailcap after it has been read, so that
 * earlier entries have precedence.  Set to 0 to get traditional lynx
 * behavior, which means that the last match wins. - kw */
static int reverse_mailcap = 1;
d691 1
a691 26
/*
 *  Additional notes: the encoding parameter may be taken into account when
 *  looking for a match; for that purpose "7bit", "8bit", and "binary" are
 *  equivalent.
 *  Use of mixed case and of pseudo MIME types with embedded spaces should
 *  be avoided.  It was once necessary for getting the fancy strings into
 *  type labels in FTP directory listings, but that can now be done with
 *  the description field (using HTSetSuffix5).  AFAIK the only effect of
 *  such "fancy" (and mostly invalid) types that cannot be reproduced by
 *  using a description fields is some statusline messages in SaveToFile
 *  (HTFWriter.c).  And showing the user an invalid MIME type as the
 *  'Content-type:' is not such a hot idea anyway, IMO.  Still, if you
 *  want it, it is still possible (even in lynx.cfg now), but use of it
 *  in the defaults below has been reduced.
 *  Case variations rely on peculiar behavior of HTAtom.c for matching.
 *  They lead to surprising behavior, Lynx retains the case of a string
 *  in the form first encountered after starting up.  So while later suffix
 *  rules generally override or modify earlier ones, the case used for a
 *  MIME time is determined by the first suffix rule (or other occurrence).
 *  Matching in HTAtom_for is effectively case insensitive, except for the
 *  first character of the string which is treated as case-sensitive by the
 *  hash function there; best not to rely on that, rather convert MIME types
 *  to lowercase on input as is already done in most places (And HTAtom could
 *  become consistently case-sensitive, as in newer W3C libwww).
 *  - kw 1999-10-12
 */
d694 3
a696 4
#ifdef BUILTIN_SUFFIX_MAPS
    if (LYUseBuiltinSuffixes)
    {
    CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));
d699 2
a700 3
    HTSetSuffix("*",		"text/plain", "8bit", 1.0);
    HTSetSuffix("*.*",		"text/plain", "8bit", 1.0);

d716 1
a716 9
    /*
     *  Some of the old incarnation of the mappings is preserved
     *  and can be had by defining TRADITIONAL_SUFFIXES.  This
     *  is for some cases where I felt the old rules might be preferred
     *  by someone, for some reason.  It's not done consistently.
     *  A lot more of this stuff could probably be changed too or
     *  omitted, now that nearly the equivalent functionality is
     *  available in lynx.cfg. - kw 1999-10-12
     */
d729 1
a729 1
    HTSetSuffix5(".exe",	"application/octet-stream", "binary", "Executable", 1.0);
a730 1
#ifdef TRADITIONAL_SUFFIXES
d733 1
d735 1
a737 10
#else
    HTSetSuffix5(".Z",	        "application/x-compress", "binary", "UNIX Compressed", 1.0);
    HTSetSuffix5(".Z",	        NULL, "compress",      "UNIX Compressed", 1.0);
    HTSetSuffix5(".exe.Z",	"application/octet-stream", "compress",
    						       "Executable", 1.0);
    HTSetSuffix5(".tar_Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
    HTSetSuffix5(".tar.Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
#endif
a738 1
#ifdef TRADITIONAL_SUFFIXES
a744 11
#else
    HTSetSuffix5("-gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("-gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		NULL, "gzip", "GNU Compressed", 1.0);

    HTSetSuffix5(".tar.gz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".tgz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
#endif
a745 1
#ifdef TRADITIONAL_SUFFIXES
a747 3
#else
    HTSetSuffix5(".wsrc",	"application/x-wais-source", "8bit", "WAIS-source", 1.0);
#endif
d749 1
a749 1
    HTSetSuffix5(".zip",	"application/zip", "binary", "Zip File", 1.0);
a752 3
    HTSetSuffix(".bz2",		"application/bzip2", "binary", 1.0);

#ifdef TRADITIONAL_SUFFIXES
a758 9
#else
    HTSetSuffix5(".uu",		"application/x-uuencoded", "7bit", "UUencoded", 1.0);

    HTSetSuffix5(".hqx",	"application/mac-binhex40", "8bit", "Mac BinHex", 1.0);

    HTSetSuffix5(".o",		"application/octet-stream", "binary", "Prog. Object", 0.5);
    HTSetSuffix5(".a",		"application/octet-stream", "binary", "Prog. Library", 0.5);
    HTSetSuffix5(".so",		"application/octet-stream", "binary", "Shared Lib", 0.5);
#endif
d764 3
a766 3
    HTSetSuffix5(".eps",	"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ai",		"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ps",		"application/postscript", "8bit", "Postscript", 1.0);
d768 1
a768 1
    HTSetSuffix5(".rtf",	"application/rtf", "8bit", "RTF", 1.0);
d770 1
a770 1
    HTSetSuffix5(".dvi",	"application/x-dvi", "8bit", "DVI", 1.0);
d772 1
a772 1
    HTSetSuffix5(".hdf",	"application/x-hdf", "8bit", "HDF", 1.0);
a776 1
#ifdef TRADITIONAL_SUFFIXES
a780 6
#else
    HTSetSuffix5(".latex",	"application/x-latex", "8bit", "LaTeX", 1.0);
    HTSetSuffix5(".tex",  	"text/x-tex", "8bit", "TeX", 1.0);
    HTSetSuffix5(".texinfo",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
    HTSetSuffix5(".texi",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
#endif
a781 1
#ifdef TRADITIONAL_SUFFIXES
a788 9
#else
    HTSetSuffix5(".t",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".tr",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".roff",	"application/x-troff", "8bit", "Troff", 1.0);

    HTSetSuffix5(".man",	"application/x-troff-man", "8bit", "Man Page", 1.0);
    HTSetSuffix5(".me",		"application/x-troff-me", "8bit", "Troff me", 1.0);
    HTSetSuffix5(".ms",		"application/x-troff-ms", "8bit", "Troff ms", 1.0);
#endif
a791 1
#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
d796 9
a804 14
    HTSetSuffix5(".bkp_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bkp-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);

    HTSetSuffix5(".bkp-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bkp_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
#else
    HTSetSuffix5(".bak",	NULL, "binary", "Backup", 0.5);
    HTSetSuffix5(".bkp",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
    HTSetSuffix5(".bck",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
#endif
a805 1
#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
a811 8
#else
    HTSetSuffix5(".hlb",	"application/octet-stream", "binary", "VMS Help Libr.", 1.0);
    HTSetSuffix5(".olb",	"application/octet-stream", "binary", "VMS Obj. Libr.", 1.0);
    HTSetSuffix5(".tlb",	"application/octet-stream", "binary", "VMS Text Libr.", 1.0);
    HTSetSuffix5(".obj",	"application/octet-stream", "binary", "Prog. Object", 1.0);
    HTSetSuffix5(".decw$book",	"application/octet-stream", "binary", "DEC BookReader", 1.0);
    HTSetSuffix5(".mem",	"text/x-runoff-manual", "8bit", "RUNOFF-MANUAL", 1.0);
#endif
d815 9
a823 10
    HTSetSuffix5(".lha",	"application/x-lha", "binary", "lha File", 1.0);
    HTSetSuffix5(".lzh",	"application/x-lzh", "binary", "lzh File", 1.0);
    HTSetSuffix5(".sea",	"application/x-sea", "binary", "sea File", 1.0);
#ifdef TRADITIONAL_SUFFIXES
    HTSetSuffix5(".sit",	"application/x-sit", "binary", "sit File", 1.0);
#else
    HTSetSuffix5(".sit",	"application/x-stuffit", "binary", "StuffIt", 1.0);
#endif
    HTSetSuffix5(".dms",	"application/x-dms", "binary", "dms File", 1.0);
    HTSetSuffix5(".iff",	"application/x-iff", "binary", "iff File", 1.0);
a827 1
#ifdef TRADITIONAL_SUFFIXES
a828 1
#endif
a832 1
#ifdef TRADITIONAL_SUFFIXES
a833 1
#endif
a903 25
    } else { /* LYSuffixRules */
    /*
     *  Note that even .html -> text/html, .htm -> text/html are omitted
     *  if default maps are compiled in but then skipped because of a
     *  configuration file directive.  Whoever changes the config file
     *  in this way can easily also add the SUFFIX rules there. - kw
     */
    CTRACE((tfp, "HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    } /* LYSuffixRules */

#else /* BUILTIN_SUFFIX_MAPS */

    CTRACE((tfp, "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
    /*
     *  The followin two are still used if BUILTIN_SUFFIX_MAPS was
     *  undefined.  Without one of them, lynx would always need to
     *  have a mapping specified in a lynx.cfg or mime.types file
     *  to be usable for local HTML files at all.  That includes
     *  many of the generated user interface pages. - kw
     */
    HTSetSuffix(".htm",		"text/html", "8bit", 1.0);
    HTSetSuffix(".html",	"text/html", "8bit", 1.0);
#endif /* BUILTIN_SUFFIX_MAPS */


d907 2
a908 1
    if (LYCanReadFile(personal_extension_map)) {
d948 1
a948 1
		s[i] = (char) r;
d993 1
a993 1
    CTRACE((tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn));
d995 2
a996 2
    if ((f = fopen(fn, TXT_R)) == NULL) {
	CTRACE((tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn));
d1004 4
a1007 2
	ct = NULL;
	StrAllocCopy(ct, word);
d1013 3
a1015 1
		char *ext = NULL;
d1017 1
a1017 1
		HTSprintf0(&ext, ".%s", word);
d1020 1
a1020 1
		CTRACE((tfp, "SETTING SUFFIX '%s' to '%s'.\n", ext, ct));
d1037 1
a1037 1
    LYCloseInput(f);
@

